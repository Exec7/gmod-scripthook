--Stealed clientside server code by exechack.cc
--Hostname: Age of Clones | Clone Wars Roleplay | Eigener Spielmodus - Part 7/12 - 06/04/2025


--PATH addons/arccw_base_modified/lua/arccw/shared/sh_acwcommon.lua:
ArcCW.EnableCustomization = true
ArcCW.PresetPath          = "arccw_presets/"

ArcCW.NoDraw = true

ArcCW.HUToM    = 0.0254 -- 1 / 12 * 0.3048
ArcCW.MOAToAcc = 0.00092592592 -- 10 / 180 / 60
ArcCW.RecoilUnit = 41.4 -- lbfps

ArcCW.STATE_IDLE      = 0
ArcCW.STATE_SIGHTS    = 1
ArcCW.STATE_SPRINT    = 2
ArcCW.STATE_DISABLE   = 3
ArcCW.STATE_CUSTOMIZE = 4
ArcCW.STATE_BIPOD     = 5

ArcCW.SCROLL_NONE = 0
ArcCW.SCROLL_ZOOM = 1

ArcCW.FLASH_ATT_CONSTANT = 0
ArcCW.FLASH_ATT_LINEAR = 1
ArcCW.FLASH_ATT_QUADRATIC = 2

ArcCW.VolumetricLightModel = "models/effects/vol_light256x384.mdl"
ArcCW.VolumetricLightX = 256
ArcCW.VolumetricLightY = 256
ArcCW.VolumetricLightZ = 384

-- Special clip size denoting an bottomless clip
ArcCW.BottomlessMagicNumber = -1

COND_WEAPON_HAS_LOS = 41
COND_WEAPON_SIGHT_OCCLUDED = 45

ArcCW.ShellSoundsTable = {
    "weapons/arccw/casings/casing_556_1.wav",
    "weapons/arccw/casings/casing_556_2.wav",
    "weapons/arccw/casings/casing_556_3.wav",
    "weapons/arccw/casings/casing_556_4.wav"
}

ArcCW.MediumShellSoundsTable = {
    "weapons/arccw/casings/casing_308_1.wav",
    "weapons/arccw/casings/casing_308_2.wav",
    "weapons/arccw/casings/casing_308_3.wav",
    "weapons/arccw/casings/casing_308_4.wav"
}

ArcCW.PistolShellSoundsTable = {
    "weapons/arccw/casings/casing_9mm_1.wav",
    "weapons/arccw/casings/casing_9mm_2.wav",
    "weapons/arccw/casings/casing_9mm_3.wav",
    "weapons/arccw/casings/casing_9mm_4.wav"
}

ArcCW.TinyShellSoundsTable = {
    "weapons/arccw/casings/casing_22_1.wav",
    "weapons/arccw/casings/casing_22_2.wav",
    "weapons/arccw/casings/casing_22_3.wav",
    "weapons/arccw/casings/casing_22_4.wav"
}

ArcCW.ShotgunShellSoundsTable = {
    "weapons/arccw/casings/casing_12ga_1.wav",
    "weapons/arccw/casings/casing_12ga_2.wav",
    "weapons/arccw/casings/casing_12ga_3.wav",
    "weapons/arccw/casings/casing_12ga_4.wav"
}

ArcCW.RicochetSounds = {
    "weapons/arccw/ricochet01.wav",
    "weapons/arccw/ricochet02.wav",
    "weapons/arccw/ricochet03.wav",
    "weapons/arccw/ricochet04.wav",
    "weapons/arccw/ricochet05.wav"
 }

ArcCW.ReloadTimeTable = {
    [ACT_HL2MP_GESTURE_RELOAD_AR2]      = 2,
    [ACT_HL2MP_GESTURE_RELOAD_SMG1]     = 2,
    [ACT_HL2MP_GESTURE_RELOAD_PISTOL]   = 1.5,
    [ACT_HL2MP_GESTURE_RELOAD_REVOLVER] = 2.5,
    [ACT_HL2MP_GESTURE_RELOAD_SHOTGUN]  = 2.5,
    [ACT_HL2MP_GESTURE_RELOAD_DUEL]     = 3.25,
}

ArcCW.LimbCompensation = {
    [1] = {
        [HITGROUP_HEAD]     = 1 / 2,
        [HITGROUP_LEFTARM]  = 1 / 0.25,
        [HITGROUP_RIGHTARM] = 1 / 0.25,
        [HITGROUP_LEFTLEG]  = 1 / 0.25,
        [HITGROUP_RIGHTLEG] = 1 / 0.25,
        [HITGROUP_GEAR]     = 1 / 0.25,
    },
    ["terrortown"] = {
        [HITGROUP_HEAD]     = 1 / 2.5, -- ArcCW's sh_ttt.lua line 5!!!
        [HITGROUP_LEFTARM]  = 1 / 0.55,
        [HITGROUP_RIGHTARM] = 1 / 0.55,
        [HITGROUP_LEFTLEG]  = 1 / 0.55,
        [HITGROUP_RIGHTLEG] = 1 / 0.55,
        [HITGROUP_GEAR]     = 1 / 0.55,
    },
}

ArcCW.ReplaceWeapons = {
    ["weapon_pistol"]    = true,
    ["weapon_smg1"]      = true,
    ["weapon_ar2"]       = true,
    ["weapon_shotgun"]   = true,
    ["weapon_357"]       = true,
    ["weapon_alyxgun"]   = true,
    ["weapon_crossbow"]  = true,
    ["weapon_rpg"]       = true,
    ["weapon_annabelle"] = true,
}

ArcCW.MeleeDamageTypes = {
    [DMG_GENERIC] = "dmg.generic",
    [DMG_BULLET] = "dmg.bullet",
    [DMG_SLASH] = "dmg.slash",
    [DMG_CLUB] = "dmg.club",
    [DMG_SHOCK] = "dmg.shock",
}

ArcCW.PenTable = {
   [MAT_ANTLION]     = 1,
   [MAT_BLOODYFLESH] = 1,
   [MAT_CONCRETE]    = 0.75,
   [MAT_DIRT]        = 0.5,
   [MAT_EGGSHELL]    = 1,
   [MAT_FLESH]       = 0.1,
   [MAT_GRATE]       = 1,
   [MAT_ALIENFLESH]  = 0.25,
   [MAT_CLIP]        = 1000,
   [MAT_SNOW]        = 0.25,
   [MAT_PLASTIC]     = 0.5,
   [MAT_METAL]       = 1.5,
   [MAT_SAND]        = 0.25,
   [MAT_FOLIAGE]     = 0.5,
   [MAT_COMPUTER]    = 0.25,
   [MAT_SLOSH]       = 1,
   [MAT_TILE]        = 0.5,
   [MAT_GRASS]       = 0.5,
   [MAT_VENT]        = 0.75,
   [MAT_WOOD]        = 0.5,
   [MAT_DEFAULT]     = 0.75,
   [MAT_GLASS]       = 0.025,
   [MAT_WARPSHIELD]  = 1
}

ArcCW.Colors = {
    POS     = Color(25, 225, 25),
    MINIPOS = Color(75, 225, 75),
    NEU     = Color(225, 225, 225),
    MININEG = Color(225, 75, 75),
    NEG     = Color(225, 25, 25),
    COSM    = Color(100, 100, 225)
}

ArcCW.LHIKBones = {
    "ValveBiped.Bip01_L_UpperArm",
    "ValveBiped.Bip01_L_Forearm",
    "ValveBiped.Bip01_L_Wrist",
    "ValveBiped.Bip01_L_Ulna",
    "ValveBiped.Bip01_L_Hand",
    "ValveBiped.Bip01_L_Finger4",
    "ValveBiped.Bip01_L_Finger41",
    "ValveBiped.Bip01_L_Finger42",
    "ValveBiped.Bip01_L_Finger3",
    "ValveBiped.Bip01_L_Finger31",
    "ValveBiped.Bip01_L_Finger32",
    "ValveBiped.Bip01_L_Finger2",
    "ValveBiped.Bip01_L_Finger21",
    "ValveBiped.Bip01_L_Finger22",
    "ValveBiped.Bip01_L_Finger1",
    "ValveBiped.Bip01_L_Finger11",
    "ValveBiped.Bip01_L_Finger12",
    "ValveBiped.Bip01_L_Finger0",
    "ValveBiped.Bip01_L_Finger01",
    "ValveBiped.Bip01_L_Finger02"
}
--addons/arccw_weapons/lua/arccw/shared/attachments/15a_barrel_extended.lua:
att.PrintName = "15a Extended barrel"
att.Description = "Extended barrel for DC-15a."
att.SortOrder = 40
att.Desc_Pros = {}
att.Icon = Material("interfaz/armas/swrp_att_a280c_grip.png")
att.Desc_Cons = {}

att.AutoStats = true

att.Slot = "15a_barrel"
att.ActivateElements = {"15a_barrel_extended"}

att.Mult_MoveSpeed = 0.9

att.Mult_MoveDispersion = 1.25
att.Mult_SightTime = 1.15
att.Mult_AccuracyMOA = 0.8
att.Mult_ShootPitch = 0.95

--addons/arccw_weapons/lua/arccw/shared/attachments/15s_mag_ext.lua:
att.PrintName = "15s Extended Magazine"
att.SortOrder = 100
att.Icon = nil
att.Description = "Extended magazine for DC-15s"
att.Desc_Pros = {}
att.Desc_Cons = {}

att.Slot = "15s_mag"
att.ActivateElements = {"15s_mag_ext"}

att.AutoStats = true
att.HideIfBlocked = true
att.Override_ClipSize = 60

att.Mult_SightTime = 1.05
att.Mult_Sway = 2.1
att.Mult_SpeedMult = 0.95
att.Mult_ShootSpeedMult = 0.95
att.Mult_DrawTime = 1.25
att.Mult_HolsterTime = 1.25
att.Mult_HipDispersion = 1.3

--addons/arccw_weapons/lua/arccw/shared/attachments/ammo_gl_smoke.lua:
att.PrintName = "Smoke Grenade Launcher"
att.Icon = Material("interfaz/armas/sw_smokegrenade.png")
att.Description = "Throwable grenade with smoke capacity."
att.Desc_Pros = {}
att.Desc_Cons = {}
att.Desc_Neutrals = {}
att.AutoStats = true
att.Slot = "ammo_rocket"

att.SortOrder = 1738
att.Override_ShootEntity = "tfa_battlefront_ent_nade_smoke"
att.Mult_SightTime = 1.25
att.Mult_SpeedMult = 0.8
att.Mult_SightedSpeedMult = 0.85
--addons/arccw_weapons/lua/arccw/shared/attachments/ammo_rocket_nofuze.lua:
att.PrintName = "No Fuze"
att.Description = "No fuze timer. Also slightly faster velocity"
att.Icon = Material("interfaz/iconos/jedi/2721145501_3098306349.png")

att.Desc_Pros = {
    "close range explosions",
    "can be used on other launchers",
}
att.Desc_Cons = {
    "the fuze timer was there for a reason",
    "missiles have a very slight arc",
}
att.AutoStats = true
att.Slot = "rocket_emp"

att.Override_ShootEntity = "arccw_rocket_nofuze"
--addons/arccw_weapons/lua/arccw/shared/attachments/ammo_rocket_shovel.lua:
att.PrintName = "Shovel Tip"
att.Icon = Material("entities/acwatt_ammo_shovel.png")
att.Description = "A far cry from those regular rockets"
att.Ignore = true
att.Desc_Pros = {
}
att.Desc_Cons = {
    "- Direct Hit Only",
}
att.AutoStats = true
att.Slot = "ammo_rocket"

att.Mult_SightTime = 0.9
att.Mult_MoveSpeed = 1.15

att.Override_ShootEntity = ""
--addons/arccw_weapons/lua/arccw/shared/attachments/ammo_rocket_tandem.lua:
att.PrintName = "Tandem Warhead"
att.Icon = Material("entities/acwatt_ammo_rpg7_he.png")
att.Description = "Load tandem shaped charge warheads that have excellent direct hit damage but very poor splash damage."
att.Desc_Pros = {
    "Increased Direct Hit Damage"
}
att.Desc_Cons = {
    "Poor Splash Damage",
}
att.AutoStats = true
att.Slot = "ammo_rocket"

att.Mult_SightTime = 1.25
att.Mult_MoveSpeed = 0.8
att.Mult_ReloadTime = 1.2

att.Override_ShootEntity = "arccw_rocket_tandem"
--addons/arccw_weapons/lua/arccw/shared/attachments/arccw_apex_proscreen.lua:
att.PrintName = "Pro Screen"
att.AbbrevName = "Pro Screen"
att.Icon = Material("entities/arccw_proscreen.png", "mips")
att.Description = "Adds a small screen to the side of the weapon, showing how many player kills you have achieved with this weapon."
att.SortOrder = 1.1

att.Model = "models/weapons/attachments/pro_screen.mdl"
att.ModelScale = Vector(1, 1, 1)
att.ModelOffset  = Vector(0, 0, 0)
att.Slot = {"charm", "killcounter"}

att.ToggleLockDefault = true 
att.ToggleStats = {
    {
        PrintName = "Global weapon",
        AutoStatName = "Global weapon",
        GivesFlags = {"st_global"}
    },
    {
        PrintName = "Local weapon",
        AutoStatName = "Local",
        GivesFlags = {"st_local"}
    },
}


-- att.Ignore = true -- WIP

att.Hook_Think = function(wep) 
    -- why there s no hook for att equip?? if it ever going to happen copy function to it from deploy
    if SERVER or !wep:GetOwner():IsPlayer() then return end

    if !wep.FileKillsTable then -- same as below but here 
        wep.FileKillsTable = util.JSONToTable(file.Read("arccw_stattrack.json", "DATA") or "") or {}
        wep.FileKills = wep.FileKillsTable[wep:GetClass()] or 0

        wep:SetNWInt("STFileKills", wep.FileKills)

        net.Start("arrcwstattracksend")
        net.WriteUInt(wep.FileKills, 20)
        net.SendToServer()
    end
end

att.Hook_OnDeploy = function(wep) 
    if SERVER or !wep:GetOwner():IsPlayer() then return end
    -- load from file
    wep.FileKillsTable = util.JSONToTable(file.Read("arccw_stattrack.json", "DATA") or "") or {}
    wep.FileKills = wep.FileKillsTable[wep:GetClass()] or 0

    wep:SetNWInt("STFileKills", wep.FileKills)

    net.Start("arrcwstattracksend")
    net.WriteUInt(wep.FileKills, 20)
    net.SendToServer()

    -- wep:SetNWInt("STFileKills", wep.FileKills)
end

att.Hook_OnHolster = function(wep) 
    if CLIENT or !wep:GetOwner():IsPlayer() then return end
    -- save in file
    net.Start("arrcwstattracksave")
    net.WriteEntity(wep)
    net.Send(wep:GetOwner())
    

    -- local curtable = {[wep:GetClass()] = wep:GetNWInt("STFileKills") or 777}

    -- local content = util.TableToJSON(table.Merge(wep.FileKillsTable or {}, curtable))

    -- file.Write("arccw_stattrack.json", content)
    -- print("hi!!")
end
--addons/arccw_weapons/lua/arccw/shared/attachments/charm_dingus.lua:

att.PrintName = "Dingus"
att.Icon = Material("entities/dingus-icon.png")
att.Description = "dingus, a tribute to my best-friend cat."

att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.AutoStats = true
att.Slot = "charm"

att.Free = true

att.Model = "models/weapons/arccw/atts/charmbase.mdl"

att.DroppedModel = "models/Items/BoxSRounds.mdl"

att.Charm = true
att.CharmModel = "models/weapons/arccw/dingus/dingus.mdl"
att.CharmAtt = "Charm"
att.CharmScale = Vector(0.05, 0.05, 0.05)
att.CharmOffset = Vector(0, -0.4, 0)
att.CharmAngle = Angle(-60, 0, 90)

--addons/arccw_weapons/lua/arccw/shared/attachments/dc17_cooling.lua:
att.PrintName = "Cooling Improved"
att.Description = "Improves the weapon performance."

att.Desc_Pros = {
}
att.Desc_Cons = {
}

att.AutoStats = true
att.Slot = "dc17_cooling"
att.ActivateElements = {"dc17_cooling"}

att.Mult_Damage = 1.1
att.Mult_Recoil = 0.9
att.Mult_SightTime = 1.1
att.Mult_MoveSpeed = 0.95
--addons/arccw_base_modified/lua/arccw/shared/attachments/default.lua:

/*

    Take a look at
    https://github.com/HaodongMo/ArcCW/wiki/Attachment-Parameters
    for descriptions on these

*/

att.PrintName = ""
att.AbbrevName = "" -- Shown in lists, cust2 only
att.Icon = nil
att.Description = ""
att.Desc_Pros = {}
att.Desc_Cons = {}
att.Desc_Neutrals = {}
att.Slot = ""

att.SortOrder = 0

att.Spawnable = false -- generate entity
att.AdminOnly = false -- see above
att.Ignore = true
att.InvAtt = nil -- use this other attachment in inventory
att.Free = false -- attachment is always available, and doesn't need to be picked up or unlocked
att.IgnorePickX = false -- will not increment the Pick X counter
att.Hidden = false
att.HideIfBlocked = false -- if the attachment cannot be attached due to flag reasons, do not show up
att.HideIfUnavailable = false -- if the attachment is not owned, do not show up even if "Hide Unowned Attachments" is off
att.NoRandom = false -- will not be randomly rolled
att.RandomWeight = 1 -- random rolling weight, defaults to 1

att.NotForNPCs = false

att.AddPrefix = ""
att.AddSuffix = ""

att.ToggleLockDefault = false -- if true then lock attachment from switching stats through bind (use on stocks/colored stuff) 

att.ToggleStats = {
    -- {
    --     PrintName = "Red",
    --     AutoStatName = "On",
    --     NoAutoStat = false,
    --     Laser = true,
    --     LaserColor = Color(255, 0, 0),
    --     Mult_HipDispersion = 0.75,
    --     AdditionalSights = {
    --         {
    --             Pos = Vector(-2, 10, -4), -- relative to where att.Model is placed
    --             Ang = Angle(0, 0, -45),
    --             GlobalPos = false,
    --             GlobalAng = true,
    --             Magnification = 1
    --         }
    --     },
    -- },
    -- {
    --     PrintName = "Blue",
    --     AutoStats = true,
    --     Laser = true,
    --     LaserColor = Color(0, 0, 255),
    --     Mult_HipDispersion = 0.75,
    --     AdditionalSights = {
    --         {
    --             Pos = Vector(-2, 10, -4), -- relative to where att.Model is placed
    --             Ang = Angle(0, 0, -45),
    --             GlobalPos = false,
    --             GlobalAng = true,
    --             Magnification = 1
    --         }
    --     },
    -- },
    -- {
    --     PrintName = "Off",
    --     Laser = false,
    --     Mult_HipDispersion = 1,
    -- }
}

att.KeepBaseIrons = false
att.BaseIronsFirst = false

att.GivesFlags = {}
att.RequireFlags = {}
att.ExcludeFlags = {}

-- any strings present in data will be added to weapon flags
att.Hook_ExtraFlags = function(wep, data) end

-- Do not use right now.
att.SubSlots = {
    {
        PrintName = "Optic",
        Slot = {"optic", "optic_lp"}, -- OR
        Slot = "optic",
        DefaultAttName = "Iron Sights",
        DefaultAttIcon = Material(""),
        MergeSlots = {}, -- mergeslots are relative to att.SubSlots, so this entry would be [1], then [2], etc
        -- bone/wmbone is inherited
        ExtraSightDist = 0,
        Offset = { -- inherits from base slot
            vpos = Vector(0, 0, 0),
            vang = Angle(0, 0, 0),
            wpos = Vector(0, 0, 0),
            wang = Angle(0, 0, 0)
        },
        SlideAmount = {
            vmin = Vector(0, 0, 0),
            vmax = Vector(0, 0, 0),
            wmin = Vector(0, 0, 0),
            wmax = Vector(0, 0, 0),
        },
    }
    -- CorrectiveAng/Pos is inherited from base slot
    -- everything else is the same as normal slots
}

att.Max = nil -- the maximum number of this attachment that can be attached.

att.Model = ""
att.HideModel = false
att.ModelBodygroups = ""
att.ModelSkin = 0
att.ModelScale = Vector(1, 1, 1)
att.ModelOffset = Vector(0, 0, 0)
att.OffsetAng = Angle(0, 0, 0)
att.ModelIsShield = false
att.ShieldResistance = nil -- amount of penetration to get through one unit of shield
att.ShieldBone = "ValveBiped.Bip01_R_Hand"

att.Charm = false
att.CharmBone = "Charm"
att.CharmModel = ""
att.CharmOffset = Vector(0, 0, 0)
att.CharmScale = Vector(1, 1, 1)
att.CharmSkin = 0
att.CharmBodygroups = ""

att.Health = 0 -- for breakable attachments

att.ShieldCorrectAng = Angle(0, 0, 0)
att.ShieldCorrectPos = Vector(0, 0, 0)

-- amount of damage done to this attachment
-- attachments which are even a bit damaged are not returned
att.DamageOnShoot = 0
att.DamageOnReload = 0
att.DamagePerSecond = 0

-- {slot = int, atthp = float, dmg = DamageInfo}
att.Hook_PlayerTakeDamage = function(wep, data) end

-- {slot = int, oldhp = float, dmg = float}
att.Hook_AttTakeDamage = function(wep, data) end

-- {slot = int, dmg = float}
att.Hook_AttDestroyed = function(wep, data) end

att.VMColor = Color(255, 255, 255)
att.WMColor = Color(255, 255, 255)
att.VMMaterial = ""
att.WMMaterial = ""

att.DroppedModel = nil
att.LHIKHide = false -- use this to just hide the left hand
att.LHIK = false -- use this model for left hand IK
att.LHIK_Animation = false
att.LHIK_GunDriver = ""
att.LHIK_CamDriver = ""

att.Override_NoHideLeftHandInCustomization = nil

att.ActivateElements = {}

att.MountPositionOverride = nil -- set between 0 to 1 to always mount in a certain position

att.AdditionalSights = {
    {
        Pos = Vector(0, 0, 0), -- relative to where att.Model is placed
        Ang = Angle(0, 0, 0),
        GlobalPos = false, -- solver will not correct position relative to att.Model position
        GlobalAng = false, -- solver will not correct angle
        ViewModelFOV = 45,
        ScrollFunc = ArcCW.SCROLL_ZOOM,
        ZoomLevels = 6,
        ZoomSound = "weapons/arccw/fiveseven/fiveseven_slideback.wav",
        NVScope = nil, -- enables night vision effects for scope
        NVScopeColor = Color(0, 255, 100),
        NVFullColor = false, -- night vision scope is true full color
        Thermal = true,
        ThermalScopeColor = Color(255, 255, 255),
        ThermalHighlightColor = Color(255, 255, 255),
        ThermalFullColor = false,
        ThermalScopeSimple = false,
        ThermalNoCC = false,
        ThermalBHOT = false, -- invert bright/dark
        IgnoreExtra = false, -- ignore gun-determined extra sight distance
        Contrast = 1, -- allows you to adjust the values for contrast and brightness when either NVScope or Thermal is enabled.
        Brightness = 0,
        SpecialScopeFunction = function(screen) end -- perform whatever screen space effects you like here, copy SWEP:FormThermalImaging and SWEP:FormNightVision for examples
    }
}

att.UBGL = false -- is underbarrel grenade launcher
att.UBGL_Icon = nil -- set to a IMaterial to replace icon in HUD


att.UBGL_Automatic = false
att.UBGL_ClipSize = 1
att.UBGL_Ammo = "smg1_grenade"
att.UBGL_RPM = 300

-- Use animations on the weapon itself, useful for weapon-specific UBGL
att.UBGL_BaseAnims = false

-- wep: weapon
-- ubgl: UBGL attachment slot.
att.UBGL_Fire = function(wep, ubgl) end
att.UBGL_Reload = function(wep, ubgl) end

att.Silencer = false

att.Bipod = false
att.Bipod_Icon = nil -- set to a IMaterial to replace icon in HUD
att.Mult_BipodRecoil = 0.25
att.Mult_BipodDispersion = 0.1
att.Override_InBipodPos = nil

att.Override_AlwaysPhysBullet = nil
att.Override_NeverPhysBullet = nil

att.Override_AmmoPerShot = 1
att.Override_InfiniteAmmo = nil
att.Override_BottomlessClip = nil

att.MagExtender = false
att.MagReducer = false
att.OverrideClipSize = nil
att.Add_ClipSize = 0
att.BaseClipSize = nil -- currently only used to make autostats treat this as the "base" clip size for pros/cons

att.Override_FuseTime = nil

att.Laser = false
att.LaserStrength = 1
att.LaserBone = "laser"
att.LaserColor = Color(255, 0, 0)

att.Flashlight = false
att.FlashlightFOV = 50
att.FlashlightHFOV = nil -- horizontal FOV
att.FlashlightVFOV = nil -- vertical FOV
-- basically, use HFOV + VFOV if you want it to be non square
att.FlashlightFarZ = 512 -- how far it goes
att.FlashlightNearZ = 4 -- how far away it starts
att.FlashlightAttenuationType = ArcCW.FLASH_ATT_LINEAR -- LINEAR, CONSTANT, QUADRATIC are available
att.FlashlightColor = Color(255, 255, 255)
att.FlashlightTexture = ""
att.FlashlightBrightness = 1
att.FlashlightBone = "laser"

att.Holosight = false
att.HolosightReticle = nil
att.HolosightFlare = nil
att.HolosightSize = nil
att.HolosightBone = "holosight"
att.HolosightPiece = nil -- the lens of the holo sight, if applicable
att.HolosightMagnification = 1 -- magnify the lens by this much
att.HolosightBlackbox = false
att.HolosightNoHSP = false -- for this holosight ignore HSP
att.HolosightConstDist = nil -- constant holosight distance, mainly for scopes with range finder

att.Colorable = false -- automatically use the player's color option
att.HolosightColor = Color(255, 255, 255)

att.Override_Ammo = "ar2" -- overrides the ammo type with this one

att.Override_Firemodes = {}

-- you can use _Priority to determine the priority of overrides.
-- append it to the end of an Override_ stat to set this.
-- for example, att.Override_Firemodes_Priority = 2
-- higher priority = will be chosen over lower priority
-- default priority for all stats is 1.

-- all hooks will work when applied to the SWEP table as well
-- e.g. SWEP.Hook_FireBullets

-- use A_Hook_[Add_Whatever] to hook into additive hooks.
-- {buff = string buff, add = num add}
-- return table

-- use O_Hook_[Override_Whatever] to hook into override hooks.
-- {buff = string buff, current = any override, winningslot = int slot}

-- use M_Hook_[Mult_Whatever] to hook into multiply hooks.
-- {buff = string buff, mult = num mult}

-- all hooks, mults, and adds will work on fire modes

-- called when the active sight is changed
-- return to change activesight
-- {active = int activesight, asight = table}
att.Hook_SwitchActiveSights = function(wep, data) end

-- Allows you to directly edit the burst count
att.Hook_GetBurstCount = function(wep, burstcount) end

-- Allows you to directly edit how long a burst is
att.Hook_GetBurstLength = function(wep, length) end

-- Allows you to directly edit whether the weapon is reloading/inoperable
att.Hook_GetReloading = function(wep, reloading) end

-- Directly modify dispersion
att.Hook_ModDispersion = function(wep, dispersion) end

-- Allows you to change the weapon's name
-- string name
att.Hook_NameChange = function(wep, name) end

-- allows you to do whatever you like to the weapon VMs
-- {vm = vm, eles = ae}
att.Hook_ModifyBodygroups = function(wep, data) end

-- modify the attachment however you like; only called for the particular attachment
-- {vm = vm, element = VElement / WElement, slottbl = slottbl, wm = false/true}
att.Hook_ModifyAttBodygroups = function(wep, data) end

-- allows you to return a shotgun spread offset
-- {n = int number, ang = angle offset}
att.Hook_ShotgunSpreadOffset = function(wep, data) end

-- done before playing an effect
-- return false to prevent playing
-- fx: {eff = effect name, fx = EffectData()}
att.Hook_PreDoEffects = function(wep, fx) end

-- return true = compatible
-- return false = incompatible
-- data = {slot = string or table, att = string}
att.Hook_Compatible = function(wep, data) end

-- called before the bullet is made.
att.Hook_PostFireBullets = function(wep) end

-- hook that lets you change the values of the bullet before it's fired.
att.Hook_FireBullets = function(wep, bullettable) end

-- called after all other primary attack functions. Do stuff here.
att.Hook_PostFireBullets = function(wep) end

-- return true to prevent fire
att.Hook_ShouldNotFire = function(wep) end

-- return true to prevent fire, bashing, anything involving the fire button
att.Hook_ShouldNotFireFirst = function(wep) end

-- return true to prevent ads
att.Hook_ShouldNotSight = function(wep) end

-- return anything to select this reload animation. Bear in mind that not all guns have the same animations, so check first.
att.Hook_SelectReloadAnimation = function(wep, curanim) end

-- return anything to multiply reload time by that much
att.Hook_MultReload = function(wep, mult) end

-- data has entries:
-- number count, how much ammo to add with this insert
-- string anim, which animation to play
-- bool empty, whether we are reloading from empty
att.Hook_SelectInsertAnimation = function(wep, data) end

-- return to override fire animation
att.Hook_SelectFireAnimation = function(wep, curanim) end

-- return string to change played anim
-- string anim, animation we are attempting to play
-- return false to block animation
-- return nil to do nothing
att.Hook_TranslateAnimation = function(wep, anim) end

-- directly changes source sequence to play
-- seq and return can either be string or table
att.Hook_TranslateSequence = function(wep, seq) end

-- called when the vm is about to play an idle animation
-- return a value to override ianim
att.Hook_IdleReset = function(wep, ianim) end

-- allows any sound to be translated to any other
att.Hook_TranslateSound = function(wep, soundname) end

-- directly changes sequence to play
-- return "DoNotPlayIdle" to stop idle animation
att.Hook_LHIK_TranslateAnimation = function(wep, anim) end

-- att.Hook_TranslateAnimation = function(wep, anim)
--     if anim == "reload" then
--         return "reload_soh"
--     elseif anim == "reload_empty" then
--         return "reload_empty_soh"
--     end
-- end

-- anim is string
att.Hook_SelectBashAnim = function(wep, anim) end

att.Hook_SelectFixAnim = function(wep, anim) end

att.Hook_PreBash = function(wep) end

-- data = {tr = tr, dmg = dmg}
att.Hook_PostBash = function(wep, data) end

-- Called just before a physbullet will call FireBullets
-- data.bullet - physbullet info; data.tr - trace info
att.Hook_PhysBulletHit = function(wep, data) end

-- data has entries:
-- number range, the distance the bullet had to travel
-- number damage, the calculated damage the bullet will do
-- number penleft, the amount of penetration the bullet still possesses
-- enum dmgtype, the DMG_ enum of the damagetype
-- table tr, the trace result
-- entity att, the attacker (?)
-- DamageInfo dmg, the damage info

-- changes to dmg may be overwritten later, so set damage and dmgtype instead
att.Hook_BulletHit = function(wep, data) end

-- called right after BulletHit, no further changes can be applied to damage
att.Hook_PostBulletHit = function(wep, data) end

-- return true to prevent reloading
att.Hook_PreReload = function(wep) end

att.Hook_PostReload = function(wep) end

-- return true to prevent firemode change
att.Hook_ChangeFiremode = function(wep) end

-- return true to ignore current bullets in clip when reloading
att.Hook_ReloadDumpClip = function(wep) end

att.Hook_GetVisualBullets = function(wep) end

att.Hook_GetVisualClip = function(wep) end

-- modify what the event system be do
-- the event is a table containing stuff that it does
-- sh_timers last stuff timers are stupid lets not
-- please dont return anything people kinda would wanna run events i'd imagine
att.Hook_PrePlayEvent = function(wep, event) end
att.Hook_PostPlayEvent = function(wep, event) end

-- return to set mag capacity
att.Hook_GetCapacity = function(wep, cap) end

-- return false to suppress shoot sound
-- string sound = default sound
att.Hook_GetShootSound = function(wep, sound) end
att.Hook_GetShootDrySound = function(wep, sound) end
att.Hook_GetDistantShootSound = function(wep, sound) end

-- return a string to change the default attachment name and icon for that slot
-- int slot = slot of attachment to name/set icon
att.Hook_GetDefaultAttName = function(wep, slot) end
att.Hook_GetDefaultAttIcon = function(wep, slot) end

-- or just add more!
-- data has entries:
-- string sound
-- number volume
-- number pitch
att.Hook_AddShootSound = function(wep, data) end
--    att.Hook_AddShootSound = function(wep, data)
--      wep:MyEmitSound("weapons/pistol/pistol_fire2.wav", data.volume, data.pitch, 1, CHAN_WEAPON - 1)
--    end

-- allows you to modify the weapon's rate of fire
att.Hook_ModifyRPM = function(wep, delay) end

-- return a table containing Recoil, RecoilSide, VisualRecoilMult to multiply them
-- Alternatively, edit the values in rec without returning, which supports multiple hooks changing the value
att.Hook_ModifyRecoil = function(wep, rec) end

-- run in Think()
att.Hook_Think = function(wep) end

-- thinking hook for att
att.DrawFunc = function(wep, element, wm) end

-- after ADS starts or ends
att.Hook_SightToggle = function(wep, enter) end

att.Override_Trivia_Class = nil -- "Submachine Gun"
att.Override_Trivia_Desc = nil -- "Ubiquitous 9mm SMG. Created as a response to the need for a faster-firing and more reliable submachine gun than existing options at the time."
att.Override_Trivia_Manufacturer = nil -- "Auschen Waffenfabrik"
att.Override_Trivia_Calibre = nil -- "9x21mm Jager"
att.Override_Trivia_Mechanism = nil -- "Roller-Delayed Blowback"
att.Override_Trivia_Country = nil -- "Austria"
att.Override_Trivia_Year = nil -- 1968

att.Mult_Damage = 1
att.Mult_DamageMin = 1
att.Mult_DamageRand = 1
att.Mult_DamageNPC = 1 -- damage WHEN USED BY NPCS not when used against them
att.Mult_Range = 1
att.Mult_Penetration = 1
att.Override_DamageType = nil
att.Override_DamageTypeHandled = nil
att.Override_ShootEntity = nil
att.Mult_MuzzleVelocity = 1

att.Override_BodyDamageMults = nil

att.Override_ShotgunSpreadPattern = {}
att.Override_ShotgunSpreadPatternOverrun = {}

att.Override_NoRandSpread = false -- disable (random) spread modification after bullet table override

att.Mult_MeleeTime = 1
att.Mult_MeleeDamage = 1
att.Add_MeleeRange = 0
att.Mult_MeleeAttackTime = 1
att.Override_MeleeDamageType = nil

att.Override_Lunge = nil
att.Add_LungeLength = 0
att.Mult_LungeLength = 1

-- jam/heat related buffs
att.Override_Jamming = nil
att.Mult_HeatCapacity = 1
att.Mult_FixTime = 1
att.Mult_HeatDissipation = 1
att.Mult_HeatDelayTime = 1
att.Override_HeatFix = nil
att.Override_HeatLockout = nil
att.Hook_Overheat = function(wep, heat) end
att.Hook_PostOverheat = function(wep) end
-- Return true to not do animation/heat locking
att.Hook_OnOverheat = function(wep) end
att.HeatOverflow = nil

-- malfunction related buffs
att.Override_Malfunction = nil
att.Override_MalfunctionTakeRound = nil
att.Override_MalfunctionJam = nil
att.Mult_MalfunctionMean = 1
att.Mult_MalfunctionVariance = 1
att.Mult_MalfunctionFixTime = 1

-- Called every time malfunction is checked. return true to cause malfunction
att.Hook_Malfunction = function(wep, count) end
-- Called when a malfunction is about to happen. return true to stop malfunction
att.Hook_OnMalfunction = function(wep, count) end
-- Called after a malfunction has occurred.
att.Hook_PostMalfunction = function(wep) end

att.Override_Tracer = nil -- tracer effect name
att.Override_TracerNum = nil
-- att.Override_TracerCol = nil
-- att.Mult_TracerWidth = 1
att.TracerFinalMag = nil

att.Override_PhysTracerProfile = nil -- color for phys tracer.
-- there are 8 options:
-- 0 = normal
-- 1 = red
-- 2 = green
-- 3 = blue
-- 4 = yellow
-- 5 = violet
-- 6 = cyan
-- 7 = black/invisible

att.Override_CanBash = nil

att.Override_ShotgunReload = nil
att.Override_HybridReload = nil

att.Override_AutoReload = nil

att.Override_ManualAction = nil

att.Override_CanFireUnderwater = nil

att.Override_ChamberSize = nil
att.Add_ChamberSize = nil

att.Mult_Recoil = 1
att.Mult_RecoilSide = 1
att.Mult_VisualRecoilMult = 1

att.Mult_Sway = 1

att.Override_ShootWhileSprint = nil

att.Mult_RPM = 1

att.Add_Num = nil
att.Mult_Num = nil
att.Override_Num = nil

att.Mult_AccuracyMOA = 1
att.Mult_HipDispersion = 1
att.Mult_SightsDispersion = 1

att.Mult_ShootVol = 1
att.Mult_ShootPitch = 1

att.Mult_GlintMagnitude = 1

att.Override_MuzzleEffect = nil
att.Override_FastMuzzleEffect = nil
att.Override_GMMuzzleEffect = nil

att.Override_ShellEffect = nil
att.Override_ShellMaterial = nil

att.Override_MuzzleEffectAttachment = nil
att.Override_CaseEffectAttachment = nil

att.Mult_SpeedMult = 1
att.Mult_SightedSpeedMult = 1
att.Mult_ShootSpeedMult = 1

att.Override_HoldtypeHolstered = nil
att.Override_HoldtypeActive = nil
att.Override_HoldtypeSights = nil

att.Override_AnimShoot = nil

att.Override_HolsterPos = nil
att.Override_HolsterAng = nil

att.Add_BarrelLength = 0

att.Override_BarrelOffsetSighted = nil
att.Override_BarrelOffsetHip = nil

att.Mult_ReloadTime = 1
att.Mult_DrawTime = 1
att.Mult_SightTime = 1
att.Mult_CycleTime = 1

att.AttachSound = nil
att.DetachSound = nil
att.ToggleSound = nil

-- free aim related buffs
att.Override_FreeAimAngle = nil
att.Mult_FreeAimAngle = nil
att.Add_FreeAimAngle = nil
att.Override_NeverFreeAim = nil
att.Override_AlwaysFreeAim = nil

att.Hook_OnDeploy = function(wep) end
att.Hook_OnHolster = function(wep) end
att.Hook_OnHolsterEnd = function(wep) end

-- bool dodefault - set false to not do default throwing behavior
-- vector force
-- string shootentity
-- number/nil fusetime
att.Hook_Throw = function(wep, data) end
--lua/arccw/shared/attachments/uc_charm_rmccharm.lua:
att.PrintName = "Red Mountain Company"
att.Description = "Be the change you want to see."
att.Ignore = true

att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.AutoStats = true
att.Slot = "charm"

att.Free = true

att.Model = "models/weapons/arccw/atts/charmbase.mdl"

att.DroppedModel = "models/Items/BoxSRounds.mdl"

att.Charm = true
att.CharmModel = "models/weapons/arccw/atts/uc_rmccharm.mdl"
att.CharmAtt = "Charm"
att.CharmScale = Vector(0.5, 0.5, 0.5)
att.CharmOffset = Vector(0, -1, -0.2)
att.CharmAngle = Angle(20, 0, 80)
--lua/arccw/shared/attachments/uc_charm_urbancharm_anarchy.lua:
att.PrintName = "Urban Charm - Anarchy"
att.Description = "The icon of a Garry's Mod addon."
att.Ignore = true
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.AutoStats = true
att.Slot = "charm"

att.Free = true

att.Model = "models/weapons/arccw/atts/charmbase.mdl"

att.DroppedModel = "models/Items/BoxSRounds.mdl"

att.Charm = true
att.CharmModel = "models/weapons/arccw/atts/uc_urbancharm.mdl"
att.CharmAtt = "Charm"
att.CharmScale = Vector(0.5, 0.5, 0.5)
att.CharmOffset = Vector(0, -1.1, -0.2)
att.CharmAngle = Angle(20, 0, 80)
att.CharmSkin = 3

--lua/arccw/shared/attachments/uc_choke_rifled.lua:
att.PrintName = "Rifled Choke"

att.Icon = nil -- Material("entities/att/acwatt_lowpolysaiga12extmag.png", "smooth mips")
att.Description = "A special choke that improves the aerodynamics of slug rounds. It is not as effective as a fully rifled barrel."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
    "uc.reqslug"
}
att.Slot = {"choke","muzzle"}
att.AutoStats = true

att.Hook_Compatible = function(wep)
    if !wep:GetIsShotgun() then
        return false
    end
end

att.Mult_AccuracyMOA = .7
att.Mult_HipDispersion = 1.15
att.Mult_Recoil = 1.05

att.RequireFlags = {"uc_slug"}
att.GivesFlags = {"uc_choke_rifled"}
att.ExcludeFlags = {"uc_fg_sg_rifled"}
--lua/arccw/shared/attachments/uc_muzzle_compensator.lua:
att.PrintName = "Basilisk Heavy Compensator"
att.AbbrevName = "Basilisk Compensator"
att.Icon = Material("entities/att/acwatt_uc_muzzle_compensator.png", "mips smooth")
att.Description = "Redirects propellant gases to reduce weapon recoil.\nImproves recoil stability."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.AutoStats = true
att.AutoStats = true
att.Slot = {"muzzle"}

att.SortOrder = 100

att.Model = "models/weapons/arccw/atts/uc_muzzle5.mdl"
att.ModelOffset = Vector(2.0, 0, 0)
att.ModelScale = Vector(.85, .85, .85)
att.OffsetAng = Angle(0, 0, 0)

att.IsMuzzleDevice = true

att.Mult_RecoilSide = 0.75

att.Mult_ShootSpeedMult = 0.9
att.Mult_Sway = 1.15

att.AttachSound = "arccw_uc/common/gunsmith/suppressor_thread.ogg"
--lua/arccw/shared/attachments/uc_muzzle_supp_tgpa.lua:
att.PrintName = "TGP-A Suppressor"

att.Icon = Material("entities/att/acwatt_uc_muzzle_supp_tgpa.png", "mips smooth")
att.Description = "Traps propellant gas from the muzzle, reducing visual and audible report.\nWell rounded suppressor with no notable downsides."
att.Desc_Neutrals = {"uc.exclusive.545", "uc.supptail"}

att.AutoStats = true
att.Slot = {"ur_ak_muzzle"}

att.SortOrder = 149

att.Model = "models/weapons/arccw/atts/uc_tgpa.mdl"
att.ModelOffset = Vector(2.6, 0, 0)
att.ModelScale = Vector(1.15, 1.15, 1.15)
att.OffsetAng = Angle(0, 0, 0)

att.Silencer = true
att.Override_MuzzleEffect = "muzzleflash_suppressed"
att.IsMuzzleDevice = true

att.Mult_ShootPitch = 1.1
att.Mult_ShootVol = 0.75

att.Add_BarrelLength = 5
att.Mult_Range = 0.9
att.Mult_SightTime = 1.07
att.Mult_Sway = 1.15

att.AttachSound = "arccw_uc/common/gunsmith/suppressor_thread.ogg"

att.Hook_Compatible = function(wep)
    if wep:GetBuff_Override("Override_Ammo", wep.Primary.Ammo) != "smg1" then
        return false
    end
end

att.Hook_GetDistantShootSound = function(wep, distancesound)
    if wep:GetBuff("PhysBulletMuzzleVelocity") < ArcCW.UC.SubsonicThreshold then
        return false
    end
end
--lua/arccw/shared/attachments/uc_optic_holosun1.lua:
att.PrintName = "Holosun HS510C (Riser) (RDS)"
att.AbbrevName = "Holosun (R) (RDS)"
att.Icon = Material("entities/att/acwatt_uc_optic_holosun1.png", "mips smooth")
att.Description = "Improves sighted visibility with a red-dot targeting reticle, while adding minimal extra weight.\nIncludes a riser."

att.SortOrder = 1

att.Desc_Pros = {
    "autostat.holosight",
}
att.Desc_Cons = {
}
att.AutoStats = true
att.Slot = {"optic"}

att.Model = "models/weapons/arccw/atts/uc_holosun1.mdl"
att.ModelScale = Vector( 1.5, 1.5, 1.5 )
att.ModelOffset = Vector( -0.5, 0, 0 )

att.AdditionalSights = {
    {
        Pos = Vector(0, 9.5, -1.5),
        Ang = Angle(0, 0, 0),
        Magnification = 1.1,
        ScrollFunc = ArcCW.SCROLL_NONE
    }
}

att.Holosight = true
att.HolosightReticle = Material("hud/reticles/uc_reddot.png", "mips smooth")
att.HolosightNoFlare = false
att.HolosightSize = 1.5
att.HolosightBone = "holosight"
att.Colorable = true

att.Mult_SightedSpeedMult = .9
--lua/arccw/shared/attachments/uc_tac_flashlight2.lua:
att.PrintName = "Tactical Rail-Mounted Flashlight"
att.AbbrevName = "Tactical Flashlight"
att.Icon = Material("entities/att/acwatt_uc_tac_flashlight2.png", "mips smooth")
att.Description = "Illuminates dark areas in front of the muzzle.\nCan be adjusted for a focused light."
att.Desc_Pros = {
    "uc.light"
}
att.Desc_Cons = {
    "con.light"
}
att.Desc_Neutrals = {}
att.AutoStats = true

att.Slot = {"tac","tac_pistol"}
att.SortOrder = 30+2

att.Model = "models/weapons/arccw/atts/ud_flashlight_2.mdl"
att.ModelOffset = Vector(0,0,-.1)

att.Flashlight = false
att.FlashlightFOV = 50
att.FlashlightFarZ = 1024 -- how far it goes
att.FlashlightNearZ = 1 -- how far away it starts
att.FlashlightAttenuationType = ArcCW.FLASH_ATT_LINEAR -- LINEAR, CONSTANT, QUADRATIC are available
att.FlashlightColor = Color(255, 255, 255)
att.FlashlightTexture = "effects/flashlight001"
att.FlashlightBrightness = 3
att.FlashlightBone = "light"

att.ToggleStats = {
    {
        PrintName = "On",
        Flashlight = true
    },
    {
        PrintName = "Tight",
        Flashlight = true,
        FlashlightFOV = 30,
        FlashlightFarZ = 1536,
        FlashlightBrightness = 5
    },
    {
        PrintName = "Off",
        Flashlight = false,
    }
}
--addons/arccw_weapons/lua/arccw/shared/attachments/wepcamo_disarray.lua:
att.PrintName = "Disarray"
att.Icon = nil
att.Description = "Colour splash"
att.Desc_Pros = {}
att.Desc_Cons = {}
att.Slot = "rep_vibrocamo"
att.Free = true

att.ActivateElements = {"wepcamo-disarray"}

att.SortOrder = 1 *-1
--addons/arccw_base_modified/lua/arccw/client/cl_menus.lua:
--[[
    Panel table doc:
    id (any number) = data:
    type
    type args

    types:
    h - header                        text
    c - control help                  text
    b - checkbox                      text var
    i - integer slider                text var min max
    f - float slider (2 nums after .) text var min max
    m - color mixer                   text r g b a
    p - press or button               text func
    t - textbox                       text string
    o - combo box                     text var choices (key - cvar, value - text)
    d - binder                        text var
    (you can add custom types in ArcCW.GeneratePanelElements's AddControl table)

    Generate elements via ArcCW.GeneratePanelElements:
    panel, panel table with data

    Add menu generation to ArcCW.ClientMenus:
    name = data:
    text - header text
    func - generator function
]]

local BulletPanel = {
    { type = "h", text = "#arccw.adminonly" },
    { type = "c", text = "#arccw.bullet_help" },
    { type = "b", text = "#arccw.cvar.bullet_enable", var = "arccw_bullet_enable", sv = true },
    { type = "b", text = "#arccw.cvar.enable_penetration", var = "arccw_enable_penetration", sv = true },
    { type = "b", text = "#arccw.cvar.enable_ricochet", var = "arccw_enable_ricochet", sv = true },
    { type = "f", text = "#arccw.cvar.bullet_velocity", var = "arccw_bullet_velocity", min = 0, max = 3, sv = true },
    { type = "f", text = "#arccw.cvar.bullet_gravity", var = "arccw_bullet_gravity", min = 0, max = 1200, sv = true },
    { type = "f", text = "#arccw.cvar.bullet_drag", var = "arccw_bullet_drag", min = 0, max = 10, sv = true },
    { type = "f", text = "#arccw.cvar.bullet_lifetime", var = "arccw_bullet_lifetime", min = 1, max = 20, sv = true},
}

local ClientPanel = {
    { type = "h", text = "#arccw.clientcfg" },
    { type = "b", text = "#arccw.cvar.automaticreload", var = "arccw_automaticreload" },
    { type = "c", text = "#arccw.cvar.automaticreload.desc" },
    { type = "f", text = "#arccw.cvar.adjustsensthreshold", var = "arccw_adjustsensthreshold", min = 0, max = 50, sv = true },
    { type = "c", text = "#arccw.cvar.adjustsensthreshold.desc" },
    { type = "b", text = "#arccw.cvar.toggleads", var = "arccw_toggleads" },
    { type = "b", text = "#arccw.cvar.autosave", var = "arccw_autosave" },
    { type = "c", text = "#arccw.cvar.autosave.desc" },
    --{ type = "b", text = "#arccw.cvar.embracetradition", var = "arccw_hud_embracetradition" },
    --{ type = "c", text = "#arccw.cvar.embracetradition.desc" },
    { type = "b", text = "#arccw.cvar.glare", var = "arccw_glare" },
    { type = "c", text = "#arccw.cvar.glare.desc" },
    { type = "b", text = "#arccw.cvar.shake", var = "arccw_shake" },
    { type = "b", text = "#arccw.cvar.shakevm", var = "arccw_shakevm" },
    { type = "c", text = "#arccw.cvar.shake_info" },
    { type = "b", text = "#arccw.cvar.aimassist", var = "arccw_aimassist_cl" },
    { type = "c", text = "#arccw.cvar.aimassist_cl.desc" },
    -- { type = "b", text = "#arccw.cvar.2d3d", var = "arccw_2d3d" },
    { type = "o", text = "#arccw.cvar.2d3d", var = "arccw_2d3d",
            choices = {[0] = "#arccw.combobox.disabled", [1] = "#arccw.cvar.2d3d.1", [2] = "#arccw.cvar.2d3d.2"}},
    { type = "c", text = "#arccw.cvar.2d3d_info" },
    { type = "t", text = "#arccw.cvar.language", var = "arccw_language"  },
    { type = "c", text = "#arccw.cvar.language_info" },
    { type = "b", text = "#arccw.cvar.ammonames", var = "arccw_ammonames" },
    { type = "c", text = "#arccw.cvar.ammonames.desc" },
    { type = "b", text = "#arccw.cvar.noinspect", var = "arccw_noinspect" },
}

local PerformancePanel = {
    --{ type = "h", text = "#arccw.clientcfg" },
    { type = "h", text = "#arccw.performance" },
    { type = "b", text = "#arccw.cvar.cheapscopes", var = "arccw_cheapscopes" },
    { type = "c", text = "#arccw.cvar.cheapscopes.desc" },
    -- { type = "b", text = "#arccw.cvar.flatscopes", var = "arccw_flatscopes" },
    -- { type = "c", text = "#arccw.cvar.flatscopes.desc" },
    { type = "b", text = "#arccw.cvar.muzzleeffects", var = "arccw_muzzleeffects" },
    { type = "b", text = "#arccw.cvar.fastmuzzles", var = "arccw_fastmuzzles" },
    { type = "b", text = "#arccw.cvar.fasttracers", var = "arccw_fasttracers" },
    { type = "b", text = "#arccw.cvar.shelleffects", var = "arccw_shelleffects" },
    { type = "b", text = "#arccw.cvar.att_showothers", var = "arccw_att_showothers" },
    { type = "b", text = "#arccw.cvar.att_showground", var = "arccw_att_showground" },
    { type = "i", text = "#arccw.cvar.visibility", var = "arccw_visibility", min = -1, max = 32000},
    { type = "c", text = "#arccw.cvar.visibility.desc" },
    { type = "b", text = "#arccw.cvar.blur", var = "arccw_blur" },
    { type = "b", text = "#arccw.cvar.blur_toytown", var = "arccw_blur_toytown" },
    { type = "b", text = "#arccw.cvar.bullet_imaginary", var = "arccw_bullet_imaginary" },
    { type = "c", text = "#arccw.cvar.bullet_imaginary.desc" },
    { type = "f", text = "#arccw.cvar.shelltime", var = "arccw_shelltime", min = 0, max = 180 },
}

local ViewmodelPanel = {
    { type = "b", text = "#arccw.cvar.vm_coolsway", var = "arccw_vm_coolsway" },
    { type = "b", text = "#arccw.cvar.vm_coolview", var = "arccw_vm_coolview" },
    { type = "h", text = "" },
    { type = "c", text = "#arccw.cvar.vm_offsetwarn" },
    { type = "f", text = "#arccw.cvar.vm_fov", var = "arccw_vm_fov",         min = -15, max = 15 },
    { type = "f", text = "#arccw.cvar.vm_right", var = "arccw_vm_right",     min = -5, max = 5 },
    { type = "f", text = "#arccw.cvar.vm_forward", var = "arccw_vm_forward", min = -5, max = 5 },
    { type = "f", text = "#arccw.cvar.vm_up", var = "arccw_vm_up",           min = -5, max = 5 },
    { type = "f", text = "#arccw.cvar.vm_pitch", var = "arccw_vm_pitch",     min = -15, max = 15 },
    { type = "f", text = "#arccw.cvar.vm_yaw", var = "arccw_vm_yaw",         min = -15, max = 15 },
    { type = "f", text = "#arccw.cvar.vm_roll", var = "arccw_vm_roll",       min = -15, max = 15 },
    { type = "c", text = "" },
    { type = "c", text = "#arccw.cvar.vm_swaywarn" },
    { type = "f", text = "#arccw.cvar.vm_look_xmult", var = "arccw_vm_look_xmult", min = -10, max = 10 },
    { type = "f", text = "#arccw.cvar.vm_look_ymult", var = "arccw_vm_look_ymult", min = -10, max = 10 },
    { type = "f", text = "#arccw.cvar.vm_sway_xmult", var = "arccw_vm_sway_xmult", min = -5, max = 5 },
    { type = "f", text = "#arccw.cvar.vm_sway_ymult", var = "arccw_vm_sway_ymult", min = -5, max = 5 },
    { type = "f", text = "#arccw.cvar.vm_sway_zmult", var = "arccw_vm_sway_zmult", min = -5, max = 5 },
    { type = "f", text = "#arccw.cvar.vm_sway_speedmult", var = "arccw_vm_sway_speedmult", min = 0, max = 2 },
    { type = "h", text = "" },
    { type = "c", text = "#arccw.cvar.vm_viewwarn" },
    { type = "f", text = "#arccw.cvar.vm_coolviewmult", var = "arccw_vm_coolview_mult", min = -5, max = 5 },
    { type = "b", text = "#arccw.cvar.vm_nearwall", var = "arccw_vm_nearwall" },
}

local HudPanel = {
    { type = "h", text = "#arccw.clientcfg" },
    { type = "h", text = "#arccw.hud_svwarning" },
    { type = "b", text = "#arccw.cvar.hud_showhealth", var = "arccw_hud_showhealth" },
    { type = "c", text = "#arccw.cvar.hud_showhealth.desc" },
    { type = "b", text = "#arccw.cvar.hud_showammo", var = "arccw_hud_showammo" },
    { type = "c", text = "#arccw.cvar.hud_showammo.desc" },
    { type = "i", text = "#arccw.cvar.hud_3dfun_decay", var = "arccw_hud_3dfun_decaytime", min = 0, max = 5 },
    { type = "c", text = "#arccw.cvar.hud_3dfun_decay.desc" },
    { type = "b", text = "#arccw.cvar.hud_minimal", var = "arccw_hud_minimal" },
    { type = "c", text = "#arccw.cvar.hud_minimal.desc" },
    { type = "b", text = "#arccw.cvar.hud_forceshow", var = "arccw_hud_forceshow" },
    { type = "c", text = "#arccw.cvar.hud_forceshow.desc" },
    { type = "b", text = "#arccw.cvar.attinv_closeonhurt", var = "arccw_attinv_closeonhurt" },
    { type = "f", text = "#arccw.cvar.hudpos_deadzone_x", var = "arccw_hud_deadzone_x", min = 0, max = 0.5 },
    { type = "f", text = "#arccw.cvar.hudpos_deadzone_y", var = "arccw_hud_deadzone_y", min = 0, max = 0.5 },
    { type = "c", text = "#arccw.cvar.hudpos_deadzone.desc" },
    { type = "f", text = "#arccw.cvar.hudpos_size", var = "arccw_hud_size", min = 0.67, max = 1.5 },
    { type = "c", text = "#arccw.cvar.hudpos_size.desc" },
    { type = "t", text = "#arccw.cvar.font", var = "arccw_font"  },
    { type = "c", text = "#arccw.cvar.font_info" },

    { type = "b", text = "#arccw.cvar.attinv_sound", var = "arccw_cust_sounds" },
    { type = "c", text = "#arccw.cvar.attinv_sound.desc" },
    { type = "b", text = "#arccw.cvar.attinv_hideunowned", var = "arccw_attinv_hideunowned" },
    { type = "b", text = "#arccw.cvar.attinv_darkunowned", var = "arccw_attinv_darkunowned" },
    { type = "b", text = "#arccw.cvar.attinv_onlyinspect", var = "arccw_attinv_onlyinspect" },
    { type = "b", text = "#arccw.cvar.attinv_simpleproscons", var = "arccw_attinv_simpleproscons" },
    --{ type = "b", text = "#arccw.cvar.attinv_gamemodebuttons", var = "arccw_attinv_gamemodebuttons" },
    --{ type = "c", text = "#arccw.cvar.attinv_gamemodebuttons.desc" },

    { type = "h", text = "#arccw.ammohud" },
    { type = "b", text = "#arccw.cvar.hud_3dfun", var = "arccw_hud_3dfun" },
    { type = "c", text = "#arccw.cvar.hud_3dfun.desc" },
    { type = "b", text = "#arccw.cvar.hud_3dfun_lite", var = "arccw_hud_3dfun_lite" },
    { type = "c", text = "#arccw.cvar.hud_3dfun_lite.desc" },
    { type = "b", text = "#arccw.cvar.hud_fcgbars", var = "arccw_hud_fcgbars" },
    { type = "b", text = "#arccw.cvar.hud_fcgabbrev", var = "arccw_hud_fcgabbrev" },
    { type = "b", text = "#arccw.cvar.hud_3dfun_ammotype", var = "arccw_hud_3dfun_ammotype" },
    { type = "c", text = "#arccw.cvar.hud_3dfun_ammotype.desc" },

    { type = "f", text = "#arccw.cvar.hud_3dfun_right", var = "arccw_hud_3dfun_right", min = -5, max = 5 },
    { type = "f", text = "#arccw.cvar.hud_3dfun_up", var = "arccw_hud_3dfun_up", min = -5, max = 5 },
    { type = "f", text = "#arccw.cvar.hud_3dfun_forward", var = "arccw_hud_3dfun_forward", min = -5, max = 5 },
}

local CrosshairPanel = {
    { type = "h", text = "#arccw.clientcfg" },
    { type = "b", text = "#arccw.cvar.crosshair", var = "arccw_crosshair" },
    { type = "f", text = "#arccw.cvar.crosshair_length", var = "arccw_crosshair_length", min = 0, max = 10 },
    { type = "f", text = "#arccw.cvar.crosshair_thickness", var = "arccw_crosshair_thickness", min = 0, max = 2 },
    { type = "f", text = "#arccw.cvar.crosshair_gap", var = "arccw_crosshair_gap", min = 0, max = 2 },
    { type = "b", text = "#arccw.cvar.crosshair_dot", var = "arccw_crosshair_dot" },
    { type = "b", text = "#arccw.cvar.crosshair_shotgun", var = "arccw_crosshair_shotgun" },
    { type = "b", text = "#arccw.cvar.crosshair_equip", var = "arccw_crosshair_equip" },
    { type = "b", text = "#arccw.cvar.crosshair_static", var = "arccw_crosshair_static" },
    { type = "b", text = "#arccw.cvar.crosshair_trueaim", var = "arccw_crosshair_trueaim" },
    { type = "b", text = "#arccw.cvar.crosshair_clump", var = "arccw_crosshair_clump" },
    { type = "b", text = "#arccw.cvar.crosshair_clump_outline", var = "arccw_crosshair_clump_outline" },
    { type = "b", text = "#arccw.cvar.crosshair_clump_always", var = "arccw_crosshair_clump_always" },
    { type = "b", text = "#arccw.cvar.crosshair_aa", var = "arccw_crosshair_aa" },
    { type = "b", text = "#arccw.cvar.crosshair_tilt", var = "arccw_crosshair_tilt" },
    { type = "b", text = "#arccw.cvar.crosshair_prong_top", var = "arccw_crosshair_prong_top" },
    { type = "b", text = "#arccw.cvar.crosshair_prong_left", var = "arccw_crosshair_prong_left" },
    { type = "b", text = "#arccw.cvar.crosshair_prong_right", var = "arccw_crosshair_prong_right" },
    { type = "b", text = "#arccw.cvar.crosshair_prong_bottom", var = "arccw_crosshair_prong_bottom" },
    { type = "m", text = "#arccw.cvar.crosshair_clr", r = "arccw_crosshair_clr_r", g = "arccw_crosshair_clr_g", b = "arccw_crosshair_clr_b", a = "arccw_crosshair_clr_a" },
    { type = "f", text = "#arccw.cvar.crosshair_outline", var = "arccw_crosshair_outline", min = 0, max = 4 },
    { type = "m", text = "#arccw.cvar.crosshair_outline_clr", r = "arccw_crosshair_outline_r", g = "arccw_crosshair_outline_g", b = "arccw_crosshair_outline_b", a = "arccw_crosshair_outline_a" },
}

local BindsPanel = {
    { type = "h", text = "#arccw.bindhelp" },
    { type = "b", text = "#arccw.cvar.nohl2flash", var = "arccw_nohl2flash" },
    { type = "b", text = "#arccw.cvar.altsafety", var = "arccw_altsafety" },
    { type = "b", text = "#arccw.cvar.altbindsonly", var = "arccw_altbindsonly" },
    { type = "c", text = "#arccw.cvar.altbindsonly.desc" },
    { type = "d", text = "#arccw.bind.firemode", var = "arccw_firemode" },
    { type = "d", text = "#arccw.bind.zoom_in", var = "arccw_zoom_in" },
    { type = "d", text = "#arccw.bind.zoom_out", var = "arccw_zoom_out" },
    { type = "d", text = "#arccw.bind.toggle_inv", var = "arccw_toggle_inv" },
    { type = "d", text = "#arccw.bind.switch_scope", var = "arccw_switch_scope" },
    { type = "d", text = "#arccw.bind.toggle_ubgl", var = "arccw_toggle_ubgl" },
    { type = "d", text = "#arccw.bind.melee", var = "arccw_melee" },
    { type = "d", text = "#arccw.bind.toggle_att", var = "arccw_toggle_att" },
}

local ServerPanel = {
    { type = "h", text = "#arccw.adminonly" },
    { type = "o", text = "#arccw.cvar.enable_customization", var = "arccw_enable_customization", sv = true,
            choices = {[-1] = "#arccw.cvar.enable_customization.-1", [0] = "#arccw.cvar.enable_customization.0", [1] = "#arccw.cvar.enable_customization.1"}},
    { type = "c", text = "#arccw.cvar.enable_customization.desc" },
    { type = "b", text = "#arccw.cvar.truenames", var = "arccw_truenames", sv = true },
    { type = "b", text = "#arccw.cvar.equipmentammo", var = "arccw_equipmentammo", sv = true },
    { type = "c", text = "#arccw.cvar.equipmentammo.desc" },
    { type = "b", text = "#arccw.cvar.equipmentsingleton", var = "arccw_equipmentsingleton", sv = true },
    { type = "c", text = "#arccw.cvar.equipmentsingleton.desc" },
    { type = "i", text = "#arccw.cvar.equipmenttime", var = "arccw_equipmenttime", min = 15, max = 3600, sv = true },
    { type = "b", text = "#arccw.cvar.throwinertia", var = "arccw_throwinertia", sv = true },
    { type = "o", text = "#arccw.cvar.freeaim", var = "arccw_freeaim", sv = true,
            choices = {[0] = "#arccw.combobox.disabled", [1] = "#arccw.cvar.freeaim.1", [2] = "#arccw.cvar.freeaim.2"}},
    { type = "b", text = "#arccw.cvar.override_crosshair_off", var = "arccw_override_crosshair_off", sv = true },
    { type = "b", text = "#arccw.cvar.override_hud_off", var = "arccw_override_hud_off", sv = true },
    { type = "b", text = "#arccw.cvar.override_barrellength", var = "arccw_override_nearwall", sv = true },
    { type = "b", text = "#arccw.cvar.doorbust", var = "arccw_doorbust", sv = true },
    { type = "b", text = "#arccw.cvar.override_lunge_off", var = "arccw_override_lunge_off", sv = true },
    { type = "c", text = "#arccw.cvar.override_lunge_off.desc" },
    --[[]
    { type = "b", text = "#arccw.cvar.limityear_enable", var = "arccw_limityear_enable", sv = true },
    { type = "i", text = "#arccw.cvar.limityear", var = "arccw_limityear", min = 1800, max = 2100, sv = true },
    { type = "c", text = "#arccw.cvar.limityear.desc"},
    ]]
    { type = "b", text = "#arccw.cvar.bodydamagecancel", var = "arccw_bodydamagemult_cancel", sv = true},
    { type = "c", text = "#arccw.cvar.bodydamagecancel.desc"},
    { type = "b", text = "#arccw.cvar.desync", var = "arccw_desync", sv = true },
    { type = "c", text = "#arccw.cvar.desync.desc" },
    { type = "f", text = "#arccw.cvar.weakensounds", var = "arccw_weakensounds", min = -20, max = 30, sv = true},
    { type = "c", text = "#arccw.cvar.weakensounds.desc" },
    { type = "b", text = "#arccw.cvar.reloadincust", var = "arccw_reloadincust", sv = true },
    { type = "c", text = "#arccw.cvar.reloadincust.desc" },
    { type = "b", text = "#arccw.cvar.aimassist", var = "arccw_aimassist", sv = true },
    { type = "c", text = "#arccw.cvar.aimassist.desc" },
    { type = "b", text = "#arccw.cvar.aimassist_head", var = "arccw_aimassist_head", sv = true },
    { type = "f", text = "#arccw.cvar.aimassist_cone", var = "arccw_aimassist_cone", min = 0, max = 360, sv = true},
    { type = "f", text = "#arccw.cvar.aimassist_distance", var = "arccw_aimassist_distance", min = 128, max = 4096, sv = true},
    { type = "f", text = "#arccw.cvar.aimassist_intensity", var = "arccw_aimassist_intensity", min = 0, max = 10, sv = true},
}

local AmmoPanel = {
    { type = "h", text = "#arccw.adminonly" },
    { type = "o", text = "#arccw.cvar.ammo_detonationmode", var = "arccw_ammo_detonationmode", sv = true,
            choices = {[-1] = "#arccw.cvar.ammo_detonationmode.-1", [0] = "#arccw.cvar.ammo_detonationmode.0", [1] = "#arccw.cvar.ammo_detonationmode.1", [2] = "#arccw.cvar.ammo_detonationmode.2"}},
    { type = "b", text = "#arccw.cvar.ammo_autopickup", var = "arccw_ammo_autopickup", sv = true },
    { type = "b", text = "#arccw.cvar.ammo_largetrigger", var = "arccw_ammo_largetrigger", sv = true },
    { type = "f", text = "#arccw.cvar.ammo_rareskin", var = "arccw_ammo_rareskin", min = 0, max = 1, sv = true },
    { type = "b", text = "#arccw.cvar.ammo_chaindet", var = "arccw_ammo_chaindet", sv = true },
    { type = "b", text = "#arccw.cvar.ammo_replace", var = "arccw_ammo_replace", sv = true },
    { type = "f", text = "#arccw.cvar.mult_ammohealth", var = "arccw_mult_ammohealth", min = -1, max = 10, sv = true },
    { type = "f", text = "#arccw.cvar.mult_ammoamount", var = "arccw_mult_ammoamount", min = 0.1, max = 10, sv = true },
}

local AttsPanel = {
    { type = "h", text = "#arccw.adminonly" },
    { type = "h", text = "#arccw.attdesc1" },
    { type = "h", text = "#arccw.attdesc2" },
    { type = "b", text = "#arccw.cvar.attinv_free", var = "arccw_attinv_free", sv = true },
    { type = "b", text = "#arccw.cvar.attinv_lockmode", var = "arccw_attinv_lockmode", sv = true },
    { type = "o", text = "#arccw.cvar.attinv_loseondie", var = "arccw_attinv_loseondie", sv = true,
            choices = {[0] = "#arccw.combobox.disabled", [1] = "#arccw.cvar.attinv_loseondie.1", [2] = "#arccw.cvar.attinv_loseondie.2"}},
    { type = "i", text = "#arccw.cvar.attinv_giveonspawn", var = "arccw_attinv_giveonspawn", min = 0, max = 100, sv = true },
    { type = "i", text = "#arccw.cvar.atts_pickx", var = "arccw_atts_pickx", min = 0, max = 10, sv = true },
    { type = "c", text = "#arccw.cvar.atts_pickx.desc", sv = true },
    { type = "b", text = "#arccw.cvar.enable_dropping", var = "arccw_enable_dropping", sv = true },
    { type = "b", text = "#arccw.cvar.atts_spawnrand", var = "arccw_atts_spawnrand", sv = true },
    { type = "b", text = "#arccw.cvar.atts_ubglautoload", var = "arccw_atts_ubglautoload", sv = true },
    { type = "p", text = "#arccw.blacklist", func = function() RunConsoleCommand("arccw_blacklist") end },
}

local DevPanel = {
    { type = "h", text = "#arccw.adminonly" },
    { type = "h", text = "#arccw.dev_info1" },
    { type = "h", text = "#arccw.dev_info2" },
    { type = "b", text = "#arccw.cvar.dev_reloadonadmincleanup", var = "arccw_reloadatts_mapcleanup", sv = true },
    { type = "c", text = "#arccw.cvar.dev_reloadonadmincleanup.desc" },
    { type = "b", text = "#arccw.cvar.dev_registerentities", var = "arccw_reloadatts_registerentities", sv = true },
    { type = "c", text = "#arccw.cvar.dev_registerentities.desc" },
    { type = "b", text = "#arccw.cvar.dev_showignored", var = "arccw_reloadatts_showignored", sv = true },
    { type = "c", text = "#arccw.cvar.dev_showignored.desc" },
    { type = "b", text = "#arccw.cvar.dev_debug", var = "arccw_dev_debug", sv = true },
    { type = "c", text = "#arccw.cvar.dev_debug.desc" },
    --{ type = "b", text = "Customization Menu Overhaul beta", var = "arccw_dev_cust2beta", sv = true },
    --{ type = "c", text = "Enable the customization menu overhaul. Remove this convar when we done doe" },
    { type = "b", text = "#arccw.cvar.dev_alwaysready", var = "arccw_dev_alwaysready", sv = true },
    { type = "c", text = "#arccw.cvar.dev_alwaysready.desc" },
    { type = "b", text = "#arccw.cvar.dev_benchgun", var = "arccw_dev_benchgun", sv = true },
    { type = "c", text = "#arccw.cvar.dev_benchgun.desc" },
    { type = "t", text = "#arccw.cvar.dev_benchgun_custom", var = "arccw_dev_benchgun_custom", sv = true },
    { type = "c", text = "#arccw.cvar.dev_benchgun_custom.desc" },
    { type = "o", text = "Firing Info", var = "arccw_dev_shootinfo", sv = true,
            choices = {[0] = "#arccw.combobox.disabled", [1] = "1 - Damage", [2] = "2 - Penetration", [3] = "3 - Dispersion"}},
    { type = "c", text = "Show information when shooting the weapon. Requires 'developer' ConVar to be enabled." },
    { type = "p", text = "#arccw.cvar.dev_reloadatts", func = function() RunConsoleCommand("arccw_reloadatts") end },
    { type = "h", text = "#arccw.cvar.dev_reloadatts.desc" },
    { type = "p", text = "#arccw.cvar.dev_reloadlangs", func = function() RunConsoleCommand("arccw_reloadlangs") end },
    { type = "h", text = "#arccw.cvar.dev_reloadlangs.desc" },
    { type = "p", text = "#arccw.cvar.dev_spawnmenureload", func = function() RunConsoleCommand("spawnmenu_reload") end },
    { type = "h", text = "#arccw.cvar.dev_spawnmenureload.desc" },
}


local ScopesPanel = {
    { type = "h", text = "#arccw.clientcfg" },

    { type = "b", text = "#arccw.cvar.cheapscopes", var = "arccw_cheapscopes" },
    { type = "c", text = "#arccw.cvar.cheapscopesv2.desc" },
    { type = "f", text = "#arccw.cvar.cheapscopesv2_ratio", var = "arccw_cheapscopesv2_ratio", min = 0, max = 1},
    { type = "c", text = "#arccw.cvar.cheapscopesv2_ratio.desc" },

    { type = "b", text = "#arccw.cvar.drawbarrel", var = "arccw_drawbarrel" },
    { type = "f", text = "#arccw.cvar.vm_addads", var = "arccw_vm_add_ads", min = -0.5, max = 9 },
    { type = "b", text = "#arccw.cvar.scopepp", var = "arccw_scopepp" },
    { type = "b", text = "#arccw.cvar.thermalpp", var = "arccw_thermalpp" },
    { type = "b", text = "#arccw.cvar.scopepp_refract", var = "arccw_scopepp_refract" },
    { type = "f", text = "#arccw.cvar.scopepp_refract_ratio", var = "arccw_scopepp_refract_ratio", min = -1, max = 2 },

    { type = "m", text = "#arccw.cvar.scope_clr", r = "arccw_scope_r", g = "arccw_scope_g", b = "arccw_scope_b" },
}

local MultsPanel = {
    { type = "h", text = "#arccw.adminonly" },
    { type = "f", text = "#arccw.cvar.mult_damage",          var = "arccw_mult_damage", min = 0, max = 10, sv = true },
    { type = "f", text = "#arccw.cvar.mult_npcdamage",       var = "arccw_mult_npcdamage", min = 0, max = 5, sv = true },
    { type = "f", text = "#arccw.cvar.mult_range",           var = "arccw_mult_range", min = 0.1, max = 5, sv = true },
    { type = "f", text = "#arccw.cvar.mult_recoil",          var = "arccw_mult_recoil", min = 0, max = 5, sv = true },
    { type = "f", text = "#arccw.cvar.mult_penetration",     var = "arccw_mult_penetration", min = 0, max = 5, sv = true },
    { type = "f", text = "#arccw.cvar.mult_hipfire",         var = "arccw_mult_hipfire", min = 0, max = 3, sv = true },
    { type = "f", text = "#arccw.cvar.mult_accuracy",        var = "arccw_mult_accuracy", min = 0, max = 3, sv = true },
    { type = "f", text = "#arccw.cvar.mult_movedisp",        var = "arccw_mult_movedisp", min = 0, max = 3, sv = true },
    { type = "f", text = "#arccw.cvar.mult_reloadtime",      var = "arccw_mult_reloadtime", min = 0.2, max = 3, sv = true },
    { type = "f", text = "#arccw.cvar.mult_sighttime",       var = "arccw_mult_sighttime", min = 0.25, max = 3, sv = true },
    { type = "i", text = "#arccw.cvar.mult_defaultammo",     var = "arccw_mult_defaultammo", min = 0, max = 10, sv = true },
    { type = "f", text = "#arccw.cvar.mult_attchance",       var = "arccw_mult_attchance", min = 0, max = 10, sv = true },
    { type = "f", text = "#arccw.cvar.mult_heat",            var = "arccw_mult_heat", min = 0, max = 3, sv = true },
    { type = "f", text = "#arccw.cvar.mult_crouchdisp",      var = "arccw_mult_crouchdisp", min = 0, max = 1, sv = true },
    { type = "f", text = "#arccw.cvar.mult_crouchrecoil",    var = "arccw_mult_crouchrecoil", min = 0, max = 1, sv = true },
    { type = "f", text = "#arccw.cvar.mult_movespeed",       var = "arccw_mult_movespeed", min = 0, max = 1, sv = true },
    { type = "f", text = "#arccw.cvar.mult_movespeedads",    var = "arccw_mult_movespeedads", min = 0, max = 1, sv = true },
    { type = "f", text = "#arccw.cvar.mult_movespeedfire",   var = "arccw_mult_movespeedfire", min = 0, max = 1, sv = true },

    { type = "f", text = "#arccw.cvar.mult_meleedamage",     var = "arccw_mult_meleedamage", min = 0, max = 4, sv = true },
    { type = "f", text = "#arccw.cvar.mult_meleetime",       var = "arccw_mult_meleetime", min = 0, max = 3, sv = true },
    { type = "f", text = "#arccw.cvar.mult_malfunction",     var = "arccw_mult_malfunction", min = 0, max = 10, sv = true },
    { type = "f", text = "#arccw.cvar.mult_rpm",             var = "arccw_mult_rpm", min = 0.1, max = 5, sv = true },
    { type = "c", text = "#arccw.cvar.mult_rpm.desc" },

    { type = "b", text = "#arccw.cvar.mult_startunloaded",   var = "arccw_mult_startunloaded", sv = true },
    { type = "b", text = "#arccw.cvar.mult_shootwhilesprinting",   var = "arccw_mult_shootwhilesprinting", sv = true },
    { type = "o", text = "#arccw.cvar.malfunction", var = "arccw_malfunction", sv = true,
            choices = {[0] = "#arccw.cvar.malfunction.0", [1] = "#arccw.cvar.malfunction.1", [2] = "#arccw.cvar.malfunction.2"}},

    { type = "b", text = "#arccw.cvar.mult_bottomlessclip",  var = "arccw_mult_bottomlessclip", sv = true },
    { type = "c", text = "Weapon feeds from reserve." },
    { type = "b", text = "#arccw.cvar.mult_infiniteammo",    var = "arccw_mult_infiniteammo", sv = true },
    { type = "c", text = "Infinite reserve ammo." },

    { type = "b", text = "#arccw.cvar.enable_sway",          var = "arccw_enable_sway", sv = true },
    { type = "c", text = "#arccw.cvar.enable_sway.desc" },
    { type = "f", text = "#arccw.cvar.add_sway",             var  = "arccw_add_sway", min = 0, max = 5, sv = true },
    { type = "f", text = "#arccw.cvar.mult_sway",            var = "arccw_mult_sway", min = 0, max = 10, sv = true },
}

local HelpPanel = {
    { type = "h",       text = "Links to the ArcCW online wiki." },

    { type = "url",     text = "Checking for Addon Conflicts",
                        url = "https://github.com/HaodongMo/ArcCW/wiki/Help-&-Troubleshooting#checking-for-addon-conflicts", },
    { type = "c",       text = "Check for addon conflicts that may be causing issues with ArcCW weapons." },

    { type = "url",     text = "Cheap Scopes",
                        url = "https://github.com/HaodongMo/ArcCW/wiki/Help-&-Troubleshooting#cheap-scopes", },
    { type = "c",       text = "'Why are my scopes so blurry?'" },

    { type = "url",     text = "Underbarrel Weapons",
                        url = "https://github.com/HaodongMo/ArcCW/wiki/Help-&-Troubleshooting#underbarrel-weapons", },
    { type = "c",       text = "'Why aren't my underbarrels weapons working?'" },
    { type = "c",       text = "'How do I use my underbarrel weapons?'" },

    { type = "url",     text = "Free Attachments",
                        url = "https://github.com/HaodongMo/ArcCW/wiki/Help-&-Troubleshooting#free-attachments", },
    { type = "c",       text = "'Why are my attachments red?'" },

    { type = "url",     text = "cam.End3D errors",
                        url = "https://github.com/HaodongMo/ArcCW/wiki/Help-&-Troubleshooting#camend3d-errors", },
    { type = "c",       text = "'Warning: Calling cam.End3D because someone forgot to!'" },

}

local MultPresets = {
    ["#preset.default"] = { -- this needs fills
        arccw_mult_damage                   = "1",
        arccw_mult_npcdamage                = "1",
        arccw_mult_range                    = "1",
        arccw_mult_recoil                   = "1",
        arccw_mult_penetration              = "1",
        arccw_mult_hipfire                  = "1",
        arccw_mult_movedisp                 = "1",
        arccw_mult_reloadtime               = "1",
        arccw_mult_sighttime                = "1",
        arccw_mult_defaultclip              = "1",
        arccw_mult_attchance                = "1",
        arccw_mult_crouchdisp               = "1",
        arccw_mult_crouchrecoil             = "1",
        arccw_mult_movespeed                = "1",
        arccw_mult_movespeedads             = "1",
        arccw_mult_movespeedfire            = "1",
        arccw_mult_heat                     = "1",
        arccw_mult_meleetime                = "1",
        arccw_mult_meleedamage              = "1",
        arccw_mult_malfunction              = "1",
        arccw_mult_startunloaded            = "0",
        arccw_mult_shootwhilesprinting      = "0",
        arccw_mult_bottomlessclip           = "0",
        arccw_mult_infiniteammo             = "0",
    }
}

local NPCsPanel = {
    { type = "h", text = "#arccw.adminonly" },
    { type = "b", text = "Replace NPC Weapons", var = "arccw_npc_replace", sv = true },
    { type = "b", text = "NPC Attachments", var = "arccw_npc_atts", sv = true },
}

function ArcCW.NetworkConvar(convar, value, p)
    if IsValid(LocalPlayer()) and !LocalPlayer():IsAdmin() then return end
    if (p.TickCreated or 0) == UnPredictedCurTime() then return end
    if value == true or value == false then
        value = value and 1 or 0
    end
    if IsColor(value) then
        value = tostring(value.r) .. " " .. tostring(value.g) .. " " .. tostring(value.b) .. " " .. tostring(value.a)
    end

    local command = convar .. " " .. tostring(value)

    local timername = "change" .. convar

    if timer.Exists(timername) then
        timer.Remove(timername)
    end

    timer.Create(timername, 0.25, 1, function()
        net.Start("arccw_sendconvar")
        net.WriteString(command)
        net.SendToServer()
    end)
end

function ArcCW.GeneratePanelElements(panel, table)
    local AddControl = {
        ["h"] = function(p, d) return p:Help(d.text) end,
        ["c"] = function(p, d) return p:ControlHelp(d.text) end,
        ["b"] = function(p, d) return p:CheckBox(d.text, d.var) end,
        ["i"] = function(p, d) return p:NumSlider(d.text, d.var, d.min, d.max, 0) end,
        ["f"] = function(p, d) return p:NumSlider(d.text, d.var, d.min, d.max, 2) end,
        ["m"] = function(p, d) --return p:AddControl("color", { Label = d.text, Red = d.r, Green = d.g, Blue = d.b, Alpha = d.a })
            local ctrl = vgui.Create("DColorMixer", p)
            ctrl:SetLabel( d.text ) ctrl:SetConVarR( d.r ) ctrl:SetConVarG( d.g ) ctrl:SetConVarB( d.b ) ctrl:SetConVarA( d.a )
            p:AddItem( ctrl ) return ctrl
        end,
        ["p"] = function(p, d) local b = p:Button(d.text) b.DoClick = d.func return b end,
        ["url"] = function(p, d) local b = p:Button(d.text) b.DoClick = function() gui.OpenURL(d.url) end return b end,
        ["t"] = function(p, d) return p:TextEntry(d.text, d.var) end,
        ["o"] = function(p, d) local cb = p:ComboBox(d.text, d.var) for k, v in pairs(d.choices) do cb:AddChoice(v, k) end return cb end,
        ["d"] = function(p, d)
                local s = vgui.Create("DSizeToContents", p) s:SetSizeX(false) s:Dock(TOP) s:InvalidateLayout()
                local l = vgui.Create("DLabel", s) l:SetText(d.text) l:SetTextColor(Color(0, 0, 0)) l:Dock(TOP) l:SetContentAlignment(5)
                local bd = vgui.Create("DBinder", s)
                if input.LookupBinding(d.var) then bd:SetValue(input.GetKeyCode(input.LookupBinding(d.var))) end
                bd.OnChange = function(b, k)
                    if k and input.GetKeyName(k) then
                        local str = input.LookupKeyBinding(k)
                        if str then
                            str = string.Replace(str, d.var .. "; ", "")
                            str = string.Replace(str, d.var, "")
                            chat.AddText(Color(255, 255, 255), language.GetPhrase("arccw.bind.msg"), Color(255, 128, 0), "bind " .. input.GetKeyName(k) .. " \"" .. str .. "; " .. d.var .. "\"")
                        else
                            chat.AddText(Color(255, 255, 255), language.GetPhrase("arccw.bind.msg"), Color(255, 128, 0), "bind " .. input.GetKeyName(k) .. " " .. d.var .. "")
                        end
                    end
                end
                bd:Dock(TOP) p:AddItem(s) return s end
    }

    local concommands = {
        ["b"] = true,
        ["i"] = true,
        ["f"] = true,
        ["m"] = true,
        ["t"] = true,
    }

    for _, data in SortedPairs(table) do
        local p = AddControl[data.type](panel, data)

        if concommands[data.type] and data.sv then
            p.TickCreated = UnPredictedCurTime()
            if data.type == "b" then
                p.OnChange = function(self, bval)
                    ArcCW.NetworkConvar(data.var, bval, self)
                end
            elseif data.type == "i" or data.type == "f" or data.type == "m" or data.type == "t" then
                p.OnValueChanged = function(self, bval)
                    ArcCW.NetworkConvar(data.var, bval, self)
                end
            end
        end
    end
end

local CrosshairPresets = {
    ["#preset.default"] = {
        arccw_crosshair_length        = "4",
        arccw_crosshair_thickness     = "1",
        arccw_crosshair_gap           = "1",
        arccw_crosshair_dot           = "1",
        arccw_crosshair_shotgun       = "1",
        arccw_crosshair_equip         = "1",
        arccw_crosshair_static        = "0",
        arccw_crosshair_clump         = "0",
        arccw_crosshair_clump_outline = "0",
        arccw_crosshair_clump_always  = "0",
        arccw_crosshair_clr_r         = "255",
        arccw_crosshair_clr_g         = "255",
        arccw_crosshair_clr_b         = "255",
        arccw_crosshair_clr_a         = "255",
        arccw_crosshair_outline       = "2",
        arccw_crosshair_outline_r     = "0",
        arccw_crosshair_outline_g     = "0",
        arccw_crosshair_outline_b     = "0",
        arccw_crosshair_outline_a     = "255",
        arccw_scope_r                 = "255",
        arccw_scope_g                 = "0",
        arccw_scope_b                 = "0",
    },
    ["#arccw.crosshair.tfa"] = {
        arccw_crosshair_length        = "8",
        arccw_crosshair_thickness     = "0.4",
        arccw_crosshair_gap           = "1",
        arccw_crosshair_dot           = "0",
        arccw_crosshair_shotgun       = "0",
        arccw_crosshair_equip         = "0",
        arccw_crosshair_static        = "0",
        arccw_crosshair_clump         = "0",
        arccw_crosshair_clump_outline = "0",
        arccw_crosshair_clump_always  = "0",
        arccw_crosshair_clr_r         = "255",
        arccw_crosshair_clr_g         = "255",
        arccw_crosshair_clr_b         = "255",
        arccw_crosshair_clr_a         = "255",
        arccw_crosshair_outline       = "2",
        arccw_crosshair_outline_r     = "0",
        arccw_crosshair_outline_g     = "0",
        arccw_crosshair_outline_b     = "0",
        arccw_crosshair_outline_a     = "255",
        arccw_scope_r                 = "255",
        arccw_scope_g                 = "0",
        arccw_scope_b                 = "0",
    },
    ["#arccw.crosshair.cw2"] = {
        arccw_crosshair_length        = "3.5",
        arccw_crosshair_thickness     = "0.4",
        arccw_crosshair_gap           = "1",
        arccw_crosshair_dot           = "0",
        arccw_crosshair_shotgun       = "0",
        arccw_crosshair_equip         = "0",
        arccw_crosshair_static        = "0",
        arccw_crosshair_clump         = "1",
        arccw_crosshair_clump_outline = "1",
        arccw_crosshair_clump_always  = "0",
        arccw_crosshair_clr_r         = "255",
        arccw_crosshair_clr_g         = "255",
        arccw_crosshair_clr_b         = "255",
        arccw_crosshair_clr_a         = "200",
        arccw_crosshair_outline       = "2",
        arccw_crosshair_outline_r     = "0",
        arccw_crosshair_outline_g     = "0",
        arccw_crosshair_outline_b     = "0",
        arccw_crosshair_outline_a     = "200",
        arccw_scope_r                 = "255",
        arccw_scope_g                 = "0",
        arccw_scope_b                 = "0",
    },
    ["#arccw.crosshair.cs"] = {
        arccw_crosshair_length        = "3",
        arccw_crosshair_thickness     = "0.4",
        arccw_crosshair_gap           = "0.4",
        arccw_crosshair_dot           = "0",
        arccw_crosshair_shotgun       = "0",
        arccw_crosshair_equip         = "0",
        arccw_crosshair_static        = "1",
        arccw_crosshair_clump         = "0",
        arccw_crosshair_clump_outline = "0",
        arccw_crosshair_clump_always  = "0",
        arccw_crosshair_clr_r         = "0",
        arccw_crosshair_clr_g         = "255",
        arccw_crosshair_clr_b         = "0",
        arccw_crosshair_clr_a         = "255",
        arccw_crosshair_outline       = "0",
        arccw_crosshair_outline_r     = "0",
        arccw_crosshair_outline_g     = "0",
        arccw_crosshair_outline_b     = "0",
        arccw_crosshair_outline_a     = "0",
        arccw_scope_r                 = "255",
        arccw_scope_g                 = "0",
        arccw_scope_b                 = "0",
    },
    ["#arccw.crosshair.light"] = {
        arccw_crosshair_length        = "4",
        arccw_crosshair_thickness     = "0.8",
        arccw_crosshair_gap           = "1",
        arccw_crosshair_dot           = "0",
        arccw_crosshair_shotgun       = "1",
        arccw_crosshair_equip         = "1",
        arccw_crosshair_static        = "0",
        arccw_crosshair_clump         = "1",
        arccw_crosshair_clump_outline = "1",
        arccw_crosshair_clump_always  = "0",
        arccw_crosshair_clr_r         = "255",
        arccw_crosshair_clr_g         = "255",
        arccw_crosshair_clr_b         = "255",
        arccw_crosshair_clr_a         = "200",
        arccw_crosshair_outline       = "2",
        arccw_crosshair_outline_r     = "0",
        arccw_crosshair_outline_g     = "0",
        arccw_crosshair_outline_b     = "0",
        arccw_crosshair_outline_a     = "200",
        arccw_scope_r                 = "255",
        arccw_scope_g                 = "0",
        arccw_scope_b                 = "0",
    },
}

local ViewmodelPresets = {
    ["#preset.default"] = {
        arccw_vm_coolsway             = "1",
        arccw_vm_coolview             = "1",
        arccw_vm_right                = "0",
        arccw_vm_forward              = "0",
        arccw_vm_up                   = "0",
        arccw_vm_look_xmult            = "1",
        arccw_vm_look_ymult            = "1",
        arccw_vm_sway_xmult            = "1",
        arccw_vm_sway_ymult            = "1",
        arccw_vm_sway_zmult            = "1",
        arccw_vm_sway_speedmult        = "1",
        arccw_vm_coolview_mult        = "1",
    }
}

function ArcCW_Options_Bullet(panel)
    ArcCW.GeneratePanelElements(panel, BulletPanel)
end

function ArcCW_Options_Client(panel)
    ArcCW.GeneratePanelElements(panel, ClientPanel)
end

function ArcCW_Options_Perf(panel)
    ArcCW.GeneratePanelElements(panel, PerformancePanel)
end

function ArcCW_Options_Viewmodel(panel, no_preset)
    if !no_preset then
        panel:AddControl("ComboBox", {
            MenuButton = "1",
            Label      = "#Presets",
            Folder     = "arccw_vm",
            CVars      = { "" },
            Options    = ViewmodelPresets
        })
    end

    ArcCW.GeneratePanelElements(panel, ViewmodelPanel)
end

function ArcCW_Options_HUD(panel)
    ArcCW.GeneratePanelElements(panel, HudPanel)
end

function ArcCW_Options_Dev(panel)
    ArcCW.GeneratePanelElements(panel, DevPanel)
end

function ArcCW_Options_Crosshair(panel, no_preset)
    if !no_preset then
        panel:AddControl("ComboBox", {
            MenuButton = "1",
            Label      = "#Presets",
            Folder     = "arccw_crosshair",
            CVars      = { "" },
            Options    = CrosshairPresets
        })
    end
    ArcCW.GeneratePanelElements(panel, CrosshairPanel)
end

function ArcCW_Options_Server(panel)
    ArcCW.GeneratePanelElements(panel, ServerPanel)
end

function ArcCW_Options_Ammo(panel)
    ArcCW.GeneratePanelElements(panel, AmmoPanel)
end

function ArcCW_Options_Mults(panel, no_preset)
    if !no_preset then
        panel:AddControl("ComboBox", {
            MenuButton = "1",
            Label      = "#Presets",
            Folder     = "arccw_mults",
            CVars      = { "" },
            Options    = MultPresets
        })
    end
    ArcCW.GeneratePanelElements(panel, MultsPanel)
end

function ArcCW_Options_Atts(panel)
    ArcCW.GeneratePanelElements(panel, AttsPanel)
end

function ArcCW_Options_NPC(panel)
    ArcCW.GeneratePanelElements(panel, NPCsPanel)
end

function ArcCW_Options_Binds(panel)
    ArcCW.GeneratePanelElements(panel, BindsPanel)
end

function ArcCW_Options_Scopes(panel)
    ArcCW.GeneratePanelElements(panel, ScopesPanel)
end

function ArcCW_Options_Help(panel)
    ArcCW.GeneratePanelElements(panel, HelpPanel)
end

ArcCW.ClientMenus = {
    ["ArcCW_Options_Client"]    = { text = "#arccw.menus.client",    func = ArcCW_Options_Client,    tbl = ClientPanel },
    ["ArcCW_Options_Help"]      = { text = "Help & Troubleshooting", func = ArcCW_Options_Help,      tbl = HelpPanel },
    ["ArcCW_Options_Bullet"]    = { text = "#arccw.menus.bullet",    func = ArcCW_Options_Bullet,    tbl = BulletPanel },
    ["ArcCW_Options_Perf"]      = { text = "#arccw.menus.perf",      func = ArcCW_Options_Perf,      tbl = PerformancePanel },
    ["ArcCW_Options_Viewmodel"] = { text = "#arccw.menus.vmodel",    func = ArcCW_Options_Viewmodel, tbl = ViewmodelPanel },
    ["ArcCW_Options_HUD"]       = { text = "#arccw.menus.hud",       func = ArcCW_Options_HUD,       tbl = HudPanel },
    ["ArcCW_Options_Crosshair"] = { text = "#arccw.menus.xhair",     func = ArcCW_Options_Crosshair, tbl = CrosshairPanel },
    ["ArcCW_Options_Server"]    = { text = "#arccw.menus.server",    func = ArcCW_Options_Server,    tbl = ServerPanel },
    ["ArcCW_Options_Ammo"]      = { text = "#arccw.menus.ammo",      func = ArcCW_Options_Ammo,      tbl = AmmoPanel },
    ["ArcCW_Options_Atts"]      = { text = "#arccw.menus.atts",      func = ArcCW_Options_Atts,      tbl = AttsPanel },
    ["ArcCW_Options_Mults"]     = { text = "#arccw.menus.mults",     func = ArcCW_Options_Mults,     tbl = MultsPanel },
    ["ArcCW_Options_Dev"]       = { text = "#arccw.menus.dev",       func = ArcCW_Options_Dev,       tbl = DevPanel },
    ["ArcCW_Options_NPC"]       = { text = "#arccw.menus.npcs",      func = ArcCW_Options_NPC,       tbl = NPCsPanel },
    ["ArcCW_Options_Binds"]     = { text = "#arccw.menus.binds",     func = ArcCW_Options_Binds,     tbl = BindsPanel },
    ["ArcCW_Options_Scopes"]    = { text = "#arccw.menus.scopes",    func = ArcCW_Options_Scopes,    tbl = ScopesPanel },
}

hook.Add("PopulateToolMenu", "ArcCW_Options", function()
    for menu, data in pairs(ArcCW.ClientMenus) do
        spawnmenu.AddToolMenuOption("Options", "ArcCW", menu, data.text, "", "", data.func)
    end
end)

-- As of 2023-11-12, this feature is only available on dev branch.
-- Won't break anything on release branch though.
list.Set("ContentCategoryIcons", "ArcCW - Ammo", "arccw/icon_16.png")
list.Set("ContentCategoryIcons", "ArcCW - Attachments", "arccw/icon_16.png")

-- Give all categories with ArcCW weapons our icon unless one is already set
local first_populate = true
hook.Add("PopulateWeapons", "ArcCW_ContentCategoryIcons", function()
    if !first_populate then return end
    for i, wep in pairs(weapons.GetList()) do
        local weap = weapons.Get(wep.ClassName)
        if weap and weap.ArcCW then
            local cat = weap.Category
            if cat and !list.HasEntry("ContentCategoryIcons", cat) then
                list.Set("ContentCategoryIcons", cat, "arccw/icon_16.png")
            end
        end
    end
    first_populate = false
end)
--addons/aoc_fire_system/lua/autorun/ch_fire_system_initialize.lua:
-- INITIALIZE SCRIPT
if SERVER then
	for k, v in ipairs( file.Find( "ch_fire_system/shared/*.lua", "LUA" ) ) do
		include( "ch_fire_system/shared/" .. v )
		--print("shared: ".. v)
	end
	
	for k, v in ipairs( file.Find( "ch_fire_system/shared/*.lua", "LUA" ) ) do
		AddCSLuaFile( "ch_fire_system/shared/" .. v )
		--print("cs shared: ".. v)
	end
	
	for k, v in ipairs( file.Find( "ch_fire_system/server/*.lua", "LUA" ) ) do
		include( "ch_fire_system/server/" .. v )
		--print("server: ".. v)
	end
	
	for k, v in ipairs( file.Find( "ch_fire_system/client/*.lua", "LUA" ) ) do
		AddCSLuaFile( "ch_fire_system/client/" .. v )
		--print("cs client: ".. v)
	end
end

if CLIENT then
	for k, v in ipairs( file.Find( "ch_fire_system/shared/*.lua", "LUA" ) ) do
		include( "ch_fire_system/shared/" .. v )
		--print("shared client: ".. v)
	end
	
	for k, v in ipairs( file.Find( "ch_fire_system/client/*.lua", "LUA" ) ) do
		include( "ch_fire_system/client/" .. v )
		--print("client: ".. v)
	end
end
--lua/autorun/el-les.lua:
local function AddPlayerModel( name, model )

	list.Set( "PlayerOptionsModel", name, model )
	player_manager.AddValidModel( name, model )

end


AddPlayerModel( "El-Les",		"models/player/tiki/el-les.mdl" )

--addons/gm_express_binding/lua/gm_express_bindings/sh_loader.lua:
AddCSLuaFile()
local modulesRoot = "gm_express_bindings"

local _, modules = file.Find( modulesRoot .. "/*", "LUA" )
print( "Loading " .. #modules .. " Express Bindings modules..." )

for _, module in ipairs( modules ) do
    local path = modulesRoot .. "/" .. module .. "/sh_init.lua"
    print( "Loading Express Bindings module: " .. module )
    include( path )
end

--addons/gm_express/lua/gm_express/cl_init.lua:
express._receiverMadeQueue = {}
express._canSendReceiverMade = false


net.Receive( "express_access", function()
    express:SetAccess( net.ReadString() )
    express:_sendReceiversMadeQueue()
end )

function express:_sendReceiversMadeQueue()
    express._canSendReceiverMade = true

    local messages = table.GetKeys( express._receiverMadeQueue )
    express:_alertReceiversMade( unpack( messages ) )
end

function express:_alertReceiversMade( ... )
    local names = { ... }
    local receiverCount = #names

    net.Start( "express_receivers_made" )
    net.WriteUInt( receiverCount, 8 )

    for i = 1, receiverCount do
        net.WriteString( names[i] )
    end

    net.SendToServer()
end


-- Registers a basic receiver --
function express.Receive( message, cb )
    express:_setReceiver( message, cb )

    if not express._canSendReceiverMade then
        express._receiverMadeQueue[message] = true
        return
    end

    express:_alertReceiversMade( message )
end


-- Calls the main _send function but passes nil for the recipient --
function express.Send( message, data, onProof )
    express:_send( message, data, nil, onProof )
end


function express:SetExpected( hash, cb )
    self._awaitingProof[hash] = cb
end

--addons/aocrp_map/lua/gmaps/cl_gmaps.lua:

surface.CreateFont("gmaps_FrameTitle",{
	font = "Century Gothic",
	size = 26,
	weight = 1000,
	extended=true
})
surface.CreateFont("gmaps_Details",{
	font = "Century Gothic",
	size = 18,
	weight = 650,
	extended=true
})

gmaps.KeyBind = CreateClientConVar("gmaps_key", gmaps.Config.DefaultKey or 0, true, false)
gmaps.PinCorner = CreateClientConVar("gmaps_pin_corner", gmaps.Config.DefaultCorner or 1, true, false)
gmaps.WorldPOI = CreateClientConVar("gmaps_worldspace_poi", 1, true, false)
gmaps.WorldNav = CreateClientConVar("gmaps_worldspace_nav", 1, true, false)
gmaps.HomeZoom = CreateClientConVar("gmaps_default_zoom", 1800, true, false)
gmaps.MinimapSize = CreateClientConVar("gmaps_mapsize", 1, true, false, "Minimapsize", 1, 3)



gmaps.ZoomSpeed = CreateClientConVar("gmaps_zoom_speed", 70, true, false)
gmaps.Blur = CreateClientConVar("gmaps_blur", 1, true, false)
gmaps.Path = gmaps.Path or {}

SKIN = SKIN or {}
local tex = SKIN.GwenTexture
SKIN.GwenTexture = Material("materials/gmaps/pinbutton_gwen.png","unlitgeneric")
local up = GWEN.CreateTextureCentered(0,0,30,17)
local down = GWEN.CreateTextureCentered(30,0,29,16)
local hover = GWEN.CreateTextureCentered(30+30,0,29,16)
SKIN.GwenTexture = tex

function gmaps.Open(frame)
	//Shitload of DFrame code, followed by like 5 lines of map code:
		
	if not IsValid(g_ContextMenu) then 
		g_ContextMenu = vgui.Create("DPanel")
		g_ContextMenu:SetVisible(false)
	end

	local wasframe = IsValid(frame)
	
	if not wasframe then
		frame = frame or vgui.Create("DFrame")
		frame:MakePopup()
	end
	frame:SetDraggable(true)
	frame:SetSizable(true)
	frame:SetMinWidth(300)
	frame:SetMinHeight(300)
	frame:SetTitle("")
	frame:ShowCloseButton(false)
	frame:DockPadding(5,5,5,5)
	-- frame:SetSize(SIZEX,SIZEY)
	frame:SetSize(math.min(ScrW()*.75,1024),math.min(ScrH()*.90,691))
	frame:Center()
	
	frame.lblTitle:SetFont("gmaps_FrameTitle")
	frame.lblTitle:SetTextColor(Color(255,255,255))
	frame.lblTitle:SetExpensiveShadow(2,Color(0,0,0,200))
	frame.lblTitle:SetTall(100)
	function frame:OnClose() //fix focus issues
		if IsValid(g_ContextMenu) and g_ContextMenu:IsVisible() then
			g_ContextMenu:EndKeyFocus()
			local k = _G["KEY_"..(input.LookupBinding( "+menu_context" ):upper())]
			if !input.IsKeyDown(k) then
				RunConsoleCommand("-menu_context")
			end
		end
		CloseDermaMenus()
	end
	
	InstallBlur(frame)
	
	frame.btnMaxim:SetDisabled(false)
	frame.btnMinim:SetDisabled(false)
	local fx,fy = frame:GetPos()
	local fw,fh = frame:GetSize()
	function frame.btnMaxim:DoClick()
		local cw,ch = frame:GetSize()
		local cx,cy = frame:GetPos()
		
		if !frame.Maxim then
			fx,fy = cx,cy
			fw,fh = cw,ch
			frame:SetSize(ScrW(),ScrH())
			frame:Center()
			frame.Maxim = true
		else
			frame:SetPos(fx,fy)
			frame:SetSize(fw,fh)
			frame.Maxim = false
		end
		
	end
	function frame.btnMaxim.Paint(panel,w,h)
		if ( !panel.m_bBackground ) then return end
		local self = panel:GetSkin()
		local k = frame.Maxim and "Restore" or "Maxi"
	
		if ( panel:GetDisabled() ) then
			return self.tex.Window[k]( 0, 0, w, h, Color( 255, 255, 255, 50 ) )
		end
		
		if ( panel.Depressed || panel:IsSelected() ) then
			return self.tex.Window[k.."_Down"]( 0, 0, w, h )
		end
		
		if ( panel.Hovered ) then
			return self.tex.Window[k.."_Hover"]( 0, 0, w, h )
		end

		self.tex.Window[k]( 0, 0, w, h )
	end
	
	function frame.btnMinim:DoClick() --pin to HUD
		if not frame.Pinned then
			frame.Pinned = true
			frame.PrePinSize = {frame:GetSize()}
			frame.PrePinPos = {frame:GetPos()}
			frame:ParentToHUD()
			local s = math.max(ScrW()*.2,frame:GetMinWidth())
			frame:SetSize(s,s)
				
			local corner = gmaps.PinCorner:GetInt()
			if corner == 3 or corner == 2 then
				frame:AlignLeft(5)
			else
				frame:AlignRight(5)
			end
			if corner > 2 then
				frame:AlignBottom(5) --we do this in think,too.
			else
				frame:AlignTop(5) --we do this in think,too.
			end
			
			frame:SetKeyboardInputEnabled(false)
			frame:SetMouseInputEnabled(false)
			
			frame.Map:ResetCamera(.2)
			-- frame:KillFocus()
			-- timer.Simple(1,function()
				-- frame:Close()
			-- end)
		else
			frame.Pinned = false
			frame:SetParent()
			frame:SetSize(unpack(frame.PrePinSize))
			frame:SetPos(unpack(frame.PrePinPos))
		end
	end
	function frame.btnMinim:Paint(w,h)--[[]]
		if self.Depressed then
			down(2,4,29,16)
		elseif self.Hovered then
			hover(2,4,29,16)
		else
			up(3,4,29,17)
		end
	end
	
	frame._oldlayout = frame.PerformLayout
	function frame:PerformLayout(w,h)
		self:_oldlayout(w,h)
		self.lblTitle:SetTall(25)
	end
	
	hook.Add("Think",frame,function()
		if not IsValid(frame) then hook.Remove("Think",frame) end
		if frame.Pinned then
			if g_ContextMenu:IsVisible() then
				if !(frame:GetParent() == g_ContextMenu) then
					frame:SetParent(g_ContextMenu)
					frame:MakePopup()
				end
				if not( gmaps.PinCorner:GetInt() > 2) then
					frame:AlignTop(35)
				end
			else
				if frame:GetParent() == g_ContextMenu then
					frame:ParentToHUD()
					frame:SetKeyboardInputEnabled(false)
					frame:SetMouseInputEnabled(false)
					frame:KillFocus()
				end
				if not( gmaps.PinCorner:GetInt() > 2) then
					frame:AlignTop(5)
				end
			end
		end
	end)
	
	//Create the actual map.
	local map = vgui.Create("DMap",frame)
	map:Dock(FILL)
	frame.Map = map
	
	gmaps.Frame = frame
	

	frame:SetSize(ScrW()*0.7,ScrH()*0.7)
	frame:Center()


	return frame
end

concommand.Add("gmaps_open",function()
	
	if IsValid(gmaps.Frame) then
		gmaps.Frame:Close()
	end
	gmaps.Open()
	
end)
concommand.Add("gmaps_close",function()
	if IsValid(gmaps.Frame)then
		gmaps.Frame:Close()
	end
end)


local function pinMap()
	local frame = gmaps.Frame
	if not frame.Pinned then
		frame.Pinned = true
		frame.PrePinSize = {frame:GetSize()}
		frame.PrePinPos = {frame:GetPos()}
		frame:ParentToHUD()
		local s = math.max(ScrW()* (0.1*gmaps.MinimapSize:GetInt()),frame:GetMinWidth())
		frame:SetSize(s,s)
			
		local corner = gmaps.PinCorner:GetInt()
		if corner == 3 or corner == 2 then
			frame:AlignLeft(5)
		else
			frame:AlignRight(5)
		end
		if corner > 2 then
			frame:AlignBottom(5) --we do this in think,too.
		else
			frame:AlignTop(5) --we do this in think,too.
		end
		
		frame:SetKeyboardInputEnabled(false)
		frame:SetMouseInputEnabled(false)
		
		frame.Map:ResetCamera((0.1*gmaps.MinimapSize:GetInt()))

		frame.Map.Home:SetVisible(false)
	
		frame.Map.ZSlide:SetVisible(false)
		-- frame:KillFocus()
		-- timer.Simple(1,function()
			-- frame:Close()
		-- end)
	end
end

//Keybinding backend
local wasdown = false
hook.Add("Think","GMaps Keybinding", function()
	local focus = vgui.GetKeyboardFocus()
	if (not IsValid(focus) or focus==gmaps.Frame) and not gui.IsConsoleVisible() then
		if not wasdown and input.IsButtonDown(AOCRP_Binds:FindBindByID("map")) then
			wasdown = true
			if not IsValid(gmaps.Frame) then
				RunConsoleCommand("gmaps_open")
			else
				if gmaps.Frame:GetParent() == g_ContextMenu then
					gmaps.Frame:SetParent()
					gmaps.Frame:MakePopup()
				elseif gmaps.Frame.Pinned then
					RunConsoleCommand("gmaps_close")
				else
					pinMap()
				end
			end
		elseif !input.IsButtonDown(AOCRP_Binds:FindBindByID("map")) then
			wasdown=false
		end
	end
end)

-- surface.CreateFont("gmaps_Checkbox",{
	-- font = "Century Gothic",
	-- size = 16,
	-- weight = 500,
	-- extended=true
-- })

function gmaps.DeletePOI(id)
	net.Start("GMaps_POIDelete")
		net.WriteFloat(id)
	net.SendToServer()
end

function gmaps.NavigateTo(pos)
	net.Start("GMaps_Nav")
		net.WriteVector(pos)
	net.SendToServer()
end

net.Receive("GMaps_POI",function(l)
	local tbl = net.ReadTable()
	gmaps.POI = tbl
end)

net.Receive("GMaps_POIResult",function(l)
	gmaps.POIResult = {net.ReadString(),net.ReadUInt(3),net.ReadFloat()}
end)

net.Receive("GMaps_Nav",function(l)
	local success = net.ReadBool()
	if success then
		if not gmaps.Arrived then
			gmaps.Path = net.ReadTable()
		end
	elseif not success then
		
	end
end)

net.Receive("GMaps_Arrive",function(l)
	gmaps.Arrived = true
	gmaps.Path={}
	timer.Simple(1,function()
		gmaps.Arrived = false
	end)
end)

function gmaps.POIDetails(poi)
	-- if not LocalPlayer():IsAdmin() then return end
	local menu = DermaMenu()
	menu:AddOption( "Show Details", function() 
		print("\n\n-----------------------POI Details:---------------------")
		PrintTable(poi)
		print("--------------------------------------------------------")
		RunConsoleCommand("showconsole")
	end )
	menu:AddOption( "Cancel", function() print( "Close pressed" ) end ) -- The menu will remove itself, we don't have to do anything.
	menu:Open()
end

local arrow = Material("materials/gmaps/arrow.png","unlitgeneric smooth nocull")
local flag = Material("materials/gmaps/flag.png","unlitgeneric smooth nocull")
hook.Add("PostDrawTranslucentRenderables","GMaps_DrawPath",function(depth,skybox)
	if depth then return end
	if skybox then return end
-- hook.Add("HUDPaint","GMaps_DrawPath",function()
	-- cam.Start3D()
	local flagsize = gmaps.Config.NavFlagSize
	if gmaps.WorldNav:GetBool() then
		local arrowsize = gmaps.Config.NavArrowSize
		if not gmaps.Rendering then
			
			if gmaps.Path[1] then
				local start = gmaps.Path[1]
				for k,v in ipairs(gmaps.Path or {})do
					if k==1 then continue end
					
					//Draw nodes
					local step = 80
					local delta = (start-v)
					local dist = delta:Length2D()
					local ang = delta:Angle()
					ang:RotateAroundAxis(ang:Up(),90)
					local endpos
					for i=0,dist-arrowsize,step do
						endpos = start - delta*(i/dist)
						
						cam.Start3D2D(endpos+ang:Up()*6,ang,1)
							surface.SetMaterial(arrow)
							surface.SetDrawColor(color_black)
							surface.DrawTexturedRect(-arrowsize/2,-arrowsize/2+1,arrowsize,arrowsize)
							surface.SetDrawColor(gmaps.NavPath)
							surface.DrawTexturedRect(-arrowsize/2,-arrowsize/2,arrowsize,arrowsize)
						cam.End3D2D()
						
					end
					
					start = v
					
				end
				
				local last = gmaps.Path[#gmaps.Path]
				local yawoff = (last-EyePos()):Angle().y
				local ang = Angle(0,yawoff-90,90)
				cam.Start3D2D(last+Vector(0,0,flagsize),ang,1)
					surface.SetMaterial(flag)
					surface.SetDrawColor(color_black)
					surface.DrawTexturedRect(-flagsize/2,-flagsize/2+1,flagsize,flagsize)
					surface.SetDrawColor(gmaps.NavFlag)
					surface.DrawTexturedRect(-flagsize/2,-flagsize/2,flagsize,flagsize)
				cam.End3D2D()
			end
			
		end
	end
	
	if gmaps.WorldPOI:GetBool() then
		
		for k,v in pairs(gmaps.POI or {})do
			if gmaps.CanSee(v,LocalPlayer()) then
				local yawoff = (v.pos-EyePos()):Angle().y
				local ang = Angle(0,yawoff-90,90)
				cam.Start3D2D(v.pos+Vector(0,0,flagsize+72),ang,1)
					surface.SetMaterial(Material(v.icon,"unlitgeneric smooth"))
					surface.SetDrawColor(color_black)
					surface.DrawTexturedRect(-flagsize/2,-flagsize/2+1,flagsize,flagsize)
					surface.SetDrawColor(v.color)
					surface.DrawTexturedRect(-flagsize/2,-flagsize/2,flagsize,flagsize)
				cam.End3D2D()
			end
		end
		
	end
	-- cam.End3D()
end)


local blur = Material("pp/blurscreen");
function InstallBlur(pnl,amount,bordercol) --thank you Gambit (used with permission).
	local bc = bordercol or color_black;
	local lev = amount or 6;
	
	if gmaps.Blur:GetBool() then
		pnl.Paint = function(this, w, h)
			local x, y = this:LocalToScreen(0, 0);

			surface.SetDrawColor(color_white);
			surface.SetMaterial(blur);

			for i = 1, 3 do
				blur:SetFloat("$blur", (i / 3) * lev);
				blur:Recompute();

				render.UpdateScreenEffectTexture();
				surface.DrawTexturedRect(x * -1, y * -1, ScrW(), ScrH());
			end

			surface.SetDrawColor(bc);
			surface.DrawOutlinedRect(0, 0, w, h);
		end
	else
		pnl.Paint = function(this, w, h)
			surface.SetDrawColor(Color(0,0,0,100));
			surface.DrawRect(0,0,w,h)
			surface.SetDrawColor(bc);
			surface.DrawOutlinedRect(0, 0, w, h);
		end
	end
end

function string.Wrap(str,font,linewide)
	surface.SetFont(font)
	local txt = ""
	for line in string.gmatch(str.."\n","([^\n]*)\n")do
		local w = 0
		for word in string.gmatch(line.." ","([^ ]*) ")do
			local wordwide,_ = surface.GetTextSize(word.." ")
			w = w + wordwide
			if w > linewide then
				txt = txt .. "\n"
				w = wordwide
			end
			txt = txt .. word .. " "
		end
		txt = txt:sub(1,txt:len()-1) .. "\n"
	end
	txt = txt:sub(1,txt:len()-1)
	return txt
end

function string.OneLine(str)
	return str:gsub("\n"," "):gsub("  ", " ")
end

function gmaps.Circle( x, y, radius, col, rough)
	local cir = {}

	table.insert( cir, { x = x, y = y} )
	for i = 0, 360, (rough or 1) do
		local a = math.rad( ( i / 360 ) * -360 )
		table.insert( cir, { x = x + math.sin( a ) * radius, y = y + math.cos( a ) * radius} )
	end

	local a = math.rad( 0 ) -- This is need for non absolute segment counts
	table.insert( cir, { x = x + math.sin( a ) * radius, y = y + math.cos( a ) * radius } )

	surface.SetDrawColor(col)
	surface.DrawPoly( cir )
end


-- hook.Add("PreDrawOpaqueRenderables","GMaps Clear", function()
	-- if gmaps.Rendering and !gmaps.Cleared then
		-- render.Clear(0,255,0,255,false,false)
		-- gmaps.Cleared = true
	-- end
-- end)

-- local ent = FindMetaTable("Entity")
-- function ent:CreatedByMap()
	-- return ent:GetNWBool("GMaps_MapEnt",false)
-- end

--addons/billy_gas/lua/gmodadminsuite/modules/fpsbooster/lang/english.lua:
return {
	Name = "English",
	Flag = "flags16/gb.png",
	Phrases = function() return {

		module_name = "FPS Booster",

		--####################### UI PHRASES #######################--

		fps_booster          = "FPS Booster",
		never_show_again     = "Never Show Again",
		never_show_again_tip = "You'll lose the benefits of this menu! Type \"gmodadminsuite fpsbooster\" in your console to open this menu in future.",

		--####################### SETTING PHRASES #######################--

		show_fps                 = "Show FPS",
		multicore_rendering      = "Enable Multicore Rendering",
		multicore_rendering_help = "This is an experimental feature of GMod which boosts FPS by rendering frames using more than a single CPU core.",
		hardware_acceleration    = "Enable Hardware Acceleration",
		shadows                  = "Disable Shadows",
		disable_skybox           = "Disable Skybox",
		sprays                   = "Disable Player Sprays",
		gibs                     = "Disable Gibs",
		gibs_help                = "\"Gibs\" are particles and objects that can fly off of corpses and ragdolls.",

} end }
--addons/billy_gas_logging/lua/gmodadminsuite/modules/logging/sh_init.lua:
if (SERVER) then
	include("sv_backwards_compatibility.lua")

	GAS_Logging_ReadyCallbacks = {}
	function GAS_Logging_Init(callback)
		if (GAS and GAS.Logging and GAS.Logging.Loaded) then
			callback()
		else
			table.insert(GAS_Logging_ReadyCallbacks, callback)
		end
	end
	
	AddCSLuaFile("cl_menu.lua")
	AddCSLuaFile("cl_livelogs.lua")
	AddCSLuaFile("sh_log_formatting.lua")
	AddCSLuaFile("sh_scenes.lua")
end

GAS:hook("gmodadminsuite:LoadModule:logging", "LoadModule:jobwhitelist:logging", function(module_info)
	if (GAS.Logging and IsValid(GAS.Logging.Menu)) then
		GAS.Logging.Menu:Close()
	end

	GAS.Logging = {}

	GAS.Logging.FORMAT_PLAYER    = 0
	GAS.Logging.FORMAT_WEAPON    = 1
	GAS.Logging.FORMAT_ENTITY    = 2
	GAS.Logging.FORMAT_PROP      = 3
	GAS.Logging.FORMAT_RAGDOLL   = 4
	GAS.Logging.FORMAT_CURRENCY  = 5
	GAS.Logging.FORMAT_COUNTRY   = 6
	GAS.Logging.FORMAT_AMMO      = 7
	GAS.Logging.FORMAT_TEAM      = 8
	GAS.Logging.FORMAT_USERGROUP = 9
	GAS.Logging.FORMAT_STRING    = 10
	GAS.Logging.FORMAT_HIGHLIGHT = 11
	GAS.Logging.FORMAT_ROLE      = 12
	GAS.Logging.FORMAT_VEHICLE   = 13
	GAS.Logging.FORMAT_DAMAGE    = 14
	
	function GAS.Logging:ClassTypeNames(L) return {
		[GAS.Logging.FORMAT_PLAYER]    = L"class_type_player",
		[GAS.Logging.FORMAT_WEAPON]    = L"class_type_weapon",
		[GAS.Logging.FORMAT_ENTITY]    = L"class_type_entity",
		[GAS.Logging.FORMAT_PROP]      = L"class_type_prop",
		[GAS.Logging.FORMAT_RAGDOLL]   = L"class_type_ragdoll",
		[GAS.Logging.FORMAT_COUNTRY]   = L"class_type_country",
		[GAS.Logging.FORMAT_AMMO]      = L"class_type_ammo",
		[GAS.Logging.FORMAT_TEAM]      = L"class_type_team",
		[GAS.Logging.FORMAT_USERGROUP] = L"class_type_usergroup",
		[GAS.Logging.FORMAT_ROLE]      = L"class_type_role",
		[GAS.Logging.FORMAT_VEHICLE]   = L"class_type_vehicle",
		[GAS.Logging.FORMAT_DAMAGE]    = L"class_type_damage",
	} end

	GAS.Logging.PvP_LOG_TYPE_CHAT                = 0
	GAS.Logging.PvP_LOG_TYPE_CHAT_TEAM           = 1
	GAS.Logging.PvP_LOG_TYPE_WEAPON_PICKUP       = 2
	GAS.Logging.PvP_LOG_TYPE_WEAPON_DROPPED      = 3
	GAS.Logging.PvP_LOG_TYPE_ITEM_PICKUP         = 4
	GAS.Logging.PvP_LOG_TYPE_SPAWNMENU           = 5
	GAS.Logging.PvP_LOG_TYPE_DARKRP_PURCHASE     = 6
	GAS.Logging.PvP_LOG_TYPE_DISCONNECT          = 7
	GAS.Logging.PvP_LOG_TYPE_WEAPON_SWITCHED     = 8
	GAS.Logging.PvP_LOG_TYPE_TEAM_SWITCH         = 9
	GAS.Logging.PVP_LOG_TYPE_SILENT_DEATH        = 10
	GAS.Logging.PvP_LOG_TYPE_DEATH_WORLD         = 11
	GAS.Logging.PvP_LOG_TYPE_DEATH_PLAYER_WEP    = 12
	GAS.Logging.PvP_LOG_TYPE_DEATH_PLAYER        = 13
	GAS.Logging.PvP_LOG_TYPE_DEATH_ENT           = 14
	GAS.Logging.PvP_LOG_TYPE_DEATH               = 15
	GAS.Logging.PvP_LOG_TYPE_DEATH_PROPKILL_SELF = 16
	GAS.Logging.PvP_LOG_TYPE_DEATH_PROPKILL      = 17

	GAS.Logging.PvP_FLAG_FRIENDLYFIRE     = 0
	GAS.Logging.PvP_FLAG_LAWENFORCEMENT   = 1
	GAS.Logging.PvP_FLAG_LINKED           = 2
	GAS.Logging.PvP_FLAG_ADMIN            = 3
	GAS.Logging.PvP_FLAG_SUPERADMIN       = 4
	GAS.Logging.PvP_FLAG_VEHICLE          = 5
	GAS.Logging.PvP_FLAG_PROPS            = 6
	GAS.Logging.PvP_FLAG_DISCONNECT       = 7
	GAS.Logging.PvP_FLAG_WORLD            = 9
	GAS.Logging.PvP_FLAG_ONGOING          = 10
	GAS.Logging.PvP_FLAG_FINISHED         = 11
	GAS.Logging.PvP_FLAG_TEAM_SWITCHED    = 12
	GAS.Logging.PvP_FLAG_INSTIGATOR_DEATH = 13
	GAS.Logging.PvP_FLAG_VICTIM_DEATH     = 14

	GAS.Logging.PvP_EVENT_ID              = 1
	GAS.Logging.PvP_PRECISE_CREATION_TIME = 2
	GAS.Logging.PvP_LAST_UPDATED          = 3
	GAS.Logging.PvP_INSTIGATOR            = 4
	GAS.Logging.PvP_INSTIGATOR_WEPS       = 5
	GAS.Logging.PvP_INSTIGATOR_DMG_TKN    = 6
	GAS.Logging.PvP_INSTIGATOR_DMG_GVN    = 7
	GAS.Logging.PvP_INSTIGATOR_TEAM       = 8
	GAS.Logging.PvP_VICTIM                = 9
	GAS.Logging.PvP_VICTIM_WEPS           = 10
	GAS.Logging.PvP_VICTIM_DMG_TKN        = 11
	GAS.Logging.PvP_VICTIM_DMG_GVN        = 12
	GAS.Logging.PvP_VICTIM_TEAM           = 13
	GAS.Logging.PvP_TOTAL_DMG             = 14
	GAS.Logging.PvP_LINKED_EVENTS         = 15
	GAS.Logging.PvP_EVENT_LOGS            = 16
	GAS.Logging.PvP_EVENT_LOGS_CHRONOLOGY = 17
	GAS.Logging.PvP_WEP_VEHICLES          = 18
	GAS.Logging.PvP_FLAGS                 = 19
	GAS.Logging.PvP_ONGOING               = 20
	GAS.Logging.PvP_INSTIGATOR_NICK       = 21
	GAS.Logging.PvP_VICTIM_NICK           = 22
	GAS.Logging.PvP_COMBAT_SCENE          = 23
	GAS.Logging.PvP_CREATION_TIMESTAMP    = 24

	GAS.Logging.PvP_SCENE_MODEL              = 1
	GAS.Logging.PvP_SCENE_POS                = 2
	GAS.Logging.PvP_SCENE_ANG                = 3
	GAS.Logging.PvP_SCENE_PLY_COLOR          = 4
	GAS.Logging.PvP_SCENE_SHOOT_POS          = 5
	GAS.Logging.PvP_SCENE_EYE_POS            = 6
	GAS.Logging.PvP_SCENE_HEAD_ANG           = 7
	GAS.Logging.PvP_SCENE_WEAPON_MDL         = 8
	GAS.Logging.PvP_SCENE_WEAPON_CLASS       = 9
	GAS.Logging.PvP_SCENE_SEQUENCE           = 10
	GAS.Logging.PvP_SCENE_VEHICLE_MODEL      = 11
	GAS.Logging.PvP_SCENE_VEHICLE_POS        = 12
	GAS.Logging.PvP_SCENE_VEHICLE_ANG        = 13
	GAS.Logging.PvP_SCENE_VEHICLE_ATTACHMENT = 14

	GAS.Logging.PvP_DAMAGE_TYPES = {
		DMG_GENERIC,
		DMG_CRUSH,
		DMG_BULLET,
		DMG_SLASH,
		DMG_BURN,
		DMG_VEHICLE,
		DMG_FALL,
		DMG_BLAST,
		DMG_CLUB,
		DMG_SHOCK,
		DMG_SONIC,
		DMG_ENERGYBEAM,
		DMG_PREVENT_PHYSICS_FORCE,
		DMG_NEVERGIB,
		DMG_ALWAYSGIB,
		DMG_DROWN,
		DMG_PARALYZE,
		DMG_NERVEGAS,
		DMG_POISON,
		DMG_RADIATION,
		DMG_DROWNRECOVER,
		DMG_ACID,
		DMG_SLOWBURN,
		DMG_REMOVENORAGDOLL,
		DMG_PHYSGUN,
		DMG_PLASMA,
		DMG_AIRBOAT,
		DMG_DISSOLVE,
		DMG_BLAST_SURFACE,
		DMG_DIRECT,
		DMG_BUCKSHOT,
		DMG_SNIPER,
		DMG_MISSILEDEFENSE
	}

	GAS.Logging.ThirdPartyAddons = {
		["ULX Admin Mod"] = {installed = function()
			return ulx ~= nil
		end, website = "https://ulyssesmod.net"},

		["ServerGuard Admin Mod"] = {installed = function()
			return SERVERGUARD ~= nil
		end, gmodstore = "1847"},

		["AWarn"] = {installed = function()
			return AWarn ~= nil
		end, gmodstore = "629"},

		["Cuffs - Handcuffs and Restraints"] = {installed = function()
			return ConVarExists("cuffs_allowbreakout")
		end, gmodstore = "910"},

		["Medic / Armor NPC"] = {installed = function()
			return MavNPCModel ~= nil
		end, workshop = "912372779"},

		["PAC3"] = {installed = function()
			return pac ~= nil
		end, workshop = "104691717"},

		["Pointshop Trading System"] = {installed = function()
			return TRADING ~= nil
		end, gmodstore = "1672"},

		["Simple Party System"] = {installed = function()
			return party ~= nil
		end, gmodstore = "2109"},

		["SprayMesh"] = {installed = function()
			return SprayMesh ~= nil
		end, workshop = "394091909"},

		["Star Wars Vehicles"] = {installed = function()
			local SWVehicles = list.Get("SWVehicles")
			return SWVehicles and table.Count(SWVehicles) > 0
		end, workshop = "1311553933"},

		["WAC Aircraft"] = {installed = function()
			return wac ~= nil
		end, workshop = "104990330"},

		["Wyozi Cinema Kit"] = {installed = function()
			return wck ~= nil
		end, gmodstore = "1471"},

		["Wyozi DJ Kit"] = {installed = function()
			return wdj ~= nil
		end, gmodstore = "1534"},

		["bWhitelist"] = {installed = function()
			return GAS.JobWhitelist ~= nil
		end, gmodadminsuite = "jobwhitelist", gmodstore = "6017"},

		["bKeycardScanner"] = {installed = function()
			return bKeycardScanner ~= nil
		end, gmodstore = "3192"},
	}

	GAS.Logging.RolesEnabled = false
	function GAS.Logging:EnableRoles()
		GAS.Logging.RolesEnabled = true
	end

	if (SERVER) then
		include("gmodadminsuite/modules/logging/sv_logging.lua")
		include("gmodadminsuite/modules/logging/sv_logscanning.lua")

		GAS.XEON:PostLoad(function()
			XEON:Init("6016", "[GAS] Billy's Logs", "2.4", "gmodadminsuite/modules/logging/sv_drm.lua", include("gmodadminsuite/modules/logging/license.lua"))
		end)
	else
		include("gmodadminsuite/modules/logging/cl_menu.lua")
		include("gmodadminsuite/modules/logging/cl_livelogs.lua")
	end

	include("gmodadminsuite/modules/logging/sh_log_formatting.lua")
	include("gmodadminsuite/modules/logging/sh_scenes.lua")

	if (CLIENT) then
		local _,ds = file.Find("gmodadminsuite/modules/logging/modules/gamemodes/*", "LUA")
		for _,d in ipairs(ds) do
			if (file.Exists("gmodadminsuite/modules/logging/modules/gamemodes/" .. d .. "/_roles.lua", "LUA")) then
				include("gmodadminsuite/modules/logging/modules/gamemodes/" .. d .. "/_roles.lua")
			end
		end

		GAS:netReceive("logging:NetworkConfig", function()
			GAS.Logging.Config = {}
			GAS.Logging.Config.OverrideMoneyFormat = net.ReadBool()
			GAS.Logging.Config.MoneyFormat = net.ReadString()
			GAS.Logging.Config.Player_RecordTeam = net.ReadBool()
			GAS.Logging.Config.Player_RecordUsergroup = net.ReadBool()
			GAS.Logging.Config.Player_RecordHealth = net.ReadBool()
			GAS.Logging.Config.Player_RecordArmor = net.ReadBool()
			GAS.Logging.Config.Player_RecordWeapon = net.ReadBool()
			GAS.Logging.Config.Player_RecordRole = net.ReadBool()
			GAS.Logging.Config.DeepStorageEnabled = net.ReadBool()

			GAS.Logging.Config.Player_RecordWeapon_DoNotRecord = {}
			for i=1,net.ReadUInt(6) do
				GAS.Logging.Config.Player_RecordWeapon_DoNotRecord[net.ReadString()] = true
			end
		end)

		GAS:InitPostEntity(function()
			GAS:netStart("logging:NetworkConfig")
			net.SendToServer()
		end)
	end
end)
--addons/tools/lua/autorun/gpart.lua:
local Cache = {}

local trash = {
    P = true,
    ["@"] = true,
    yDB = true,
    ["yD@"] = true,
    jFG = true,
    [";E-"] = true,
    [";ED"] = true,
    ['"D3'] = true,

}

local function ProcessFile( data, behind )
    data = data:Read(data:Size())
    local strings = string.Explode("\x03\x00", data)
    local definitions = {}
    for slot, line in pairs(strings) do
        local cursor = 1
        while (line[cursor] != "\x00" and cursor < #line) do
            cursor = cursor + 1
        end
        local result = string.match(string.sub(line, 1, cursor), "(%g+)")
        if not result or trash[result] or #result < 4 then continue end
        table.insert(definitions, result)
    end
    table.remove(definitions, 1)
    return definitions
end

local function GetList( fileName )
    if Cache[fileName] then
        return Cache[fileName]
    end

    game.AddParticles( fileName )

    local fileData = file.Open( fileName, "rb", "GAME" )
    local resultData = ProcessFile(fileData)

    Cache[fileName] = resultData
    return resultData
end

function util.GetParticleList(name)
    return GetList(name)
end

--addons/joes_stuff/lua/autorun/joe_bomb_system_autoload.lua:
BombSystem = BombSystem or {}
BombSystem.Version = "1.8"
local mainfolder = "bomb_system/"

if SERVER then
    if JoeBase then
        JoeBase:RegisterProduct("Bomb-System", BombSystem.Version)
    else
        hook.Add("JoeBase:FinishedLoading", "BombSystem:Register", function()
            JoeBase:RegisterProduct("Bomb-System", BombSystem.Version)
        end)
    end
end

-- sh files
for k,v in pairs(file.Find(mainfolder .. "sh_*", "LUA")) do
    include(mainfolder .. tostring(v))
    if SERVER then AddCSLuaFile(mainfolder .. tostring(v)) end
end
-- sv files
if SERVER then
    for k,v in pairs(file.Find(mainfolder .. "sv_*", "LUA")) do
        include(mainfolder .. tostring(v))
    end
end
-- cl files
for k,v in pairs(file.Find(mainfolder .. "cl_*", "LUA")) do
    if SERVER then AddCSLuaFile(mainfolder ..  tostring(v))
    else include(mainfolder .. tostring(v))
    end
end
--addons/joes_stuff/lua/bomb_system/cl_bombdefusal.lua:
local frame

local col1 = Color(134, 235, 255,255)
local col2 = Color(9, 125, 168, 100)
local col4 = Color(255, 0, 0, 255)

net.Receive("bomb_defusable_menu", function()
    if IsValid(frame) then frame:Remove() end
    frame = vgui.Create("DFrame")
    frame:SetSize(400, 200)
    frame:Center()
    frame:MakePopup()
    frame:SetTitle("")
    frame.Paint = function(s,w,h)
        surface.SetDrawColor(col2)
        surface.DrawRect(0, 0, w, h)
    end

    local remote = vgui.Create("DButton", frame)
    remote:SetSize(140, 40)
    remote:SetText("Remote")
    remote:SetPos(35,80)
    remote:SetFont("DermaLarge")
    remote.DoClick = function()
        frame:Remove()
        net.Start("bomb_defusable_menu")
        net.WriteInt(1,3)
        net.SendToServer()
    end
    remote.Paint = function(s,w,h)
        if s:IsHovered() then
            surface.SetDrawColor(col1)
            s:SetTextColor(col2)
        else
            surface.SetDrawColor(col2)
            s:SetTextColor(col1)
        end
        surface.DrawRect(0, 0, w, h)
        surface.SetDrawColor(col1)
        surface.DrawOutlinedRect(0, 0, w, h, 3)
    end

    local timeentry = vgui.Create("DTextEntry", frame)
    timeentry:SetSize(140, 40)
    timeentry:SetPos(215,60)
    timeentry:SetNumeric(true)
    timeentry:SetFont("DermaLarge")
    timeentry.Paint = function(s,w,h)
        surface.SetDrawColor(col2)
        surface.DrawRect(0, 0, w, h)
        surface.SetDrawColor(col1)
        surface.DrawOutlinedRect(0, 0, w, h, 3)
        s:DrawTextEntryText(col1, col2, col2)
    end

    local time = vgui.Create("DButton", frame)
    time:SetSize(140, 40)
    time:SetPos(215,120)
    time:SetText("Timer")
    time:SetFont("DermaLarge")
    time.DoClick = function()
        frame:Remove()
        net.Start("bomb_defusable_menu")
        net.WriteInt(2,3)
        net.WriteInt(tonumber(timeentry:GetValue()), 32)
        net.SendToServer()
    end
    time.Paint = function(s,w,h)
        if s:IsHovered() then
            surface.SetDrawColor(col1)
            s:SetTextColor(col2)
        else
            surface.SetDrawColor(col2)
            s:SetTextColor(col1)
        end
        surface.DrawRect(0, 0, w, h)
        surface.SetDrawColor(col1)
        surface.DrawOutlinedRect(0, 0, w, h, 3)
    end
end)

net.Receive("bomb_defusable_sound", function()
    local pos = net.ReadVector()
    local range1 = ( BombSystem.radius * 4 ) ^ 2
    local range2 = ( BombSystem.radius * 12 ) ^ 2
    local dist = LocalPlayer():GetPos():DistToSqr(pos) 
    if dist < range1 then
        surface.PlaySound("ambient/explosions/explode_2.wav")
    elseif dist < range2 then
        surface.PlaySound("ambient/explosions/exp3.wav")
    end
end)
--lua/autorun/kiwi_custom.lua:
list.Set( "Kiwi", "starwars/kiwi/arc/kiwi_custom_arc.mdl" )   // "starwars/kiwi/arc/kiwi_custom_arc.mdl" )
player_manager.AddValidModel( "Kiwi", "starwars/kiwi/arc/kiwi_custom_arc.mdl" )   // "starwars/kiwi/arc/kiwi_custom_arc.mdl" )
--addons/weapon_jedi/lua/lscs/combos/jarkai.lua:
COMBO.id = "jarkai"
COMBO.PrintName = "Unterform VI | Jar'Kai"
COMBO.Author = "Deltaa"
COMBO.Description = "Nutzung von 2 Lichtschwertern"

COMBO.DeflectBullets = true
COMBO.AutoBlock = true

COMBO.LeftSaberActive = true

COMBO.HoldType = "lscs_jarkai"

COMBO.DamageMultiplier = 0.8
COMBO.MaxBlockPoints = 125

COMBO.Attacks = {
	["FRONT_DASH"] = {
		AttackAnim = "pure_b_right_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
			timer.Simple(0.6, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)

			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1600 )
			else
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 600 + Vector(0,0,40) )
			end
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 1.4,
	 },
	["BACKFLIP"] = {
		AttackAnim = "r_c6_t1",
		BeginAttack = function( weapon, ply )  
			ply:SetVelocity( Vector(0,0,250) - Angle(0,ply:EyeAngles().y,0):Forward() * 25 )
			ply:lscsSuppressFalldamage(CurTime() + 5)
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.8,
	},
	["ROLL_RIGHT"] = {
		AttackAnim = "rollright",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) + Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["ROLL_LEFT"] = {
		AttackAnim = "rollleft",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) - Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["____"] = {
		AttackAnim = "phalanx_b_left_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 2, CurTime(), 0.3, Vector(100,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.25,
		Duration = 0.5,
	},
    ["-45-"] = {
		AttackAnim = "r_c6_t3",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.8,
	},
	["W_S_"] = {
		AttackAnim = "pure_r_s1_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.3,
	},
	["__S_"] = {
		AttackAnim = "r_left_t2",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.3,
	},
	["_A__"] = {
		AttackAnim = "pure_b_left_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(0,-100,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.3, 0.3, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.25,
		Duration = 0.5,
	},
	["___D"] = {
		AttackAnim = "pure_b_right_t2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(0,100,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.3, 0.3, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.25,
		Duration = 1,
	},
	["_AS_"] = {
		AttackAnim = "pure_r_left_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove(1, CurTime(), 0.5, Vector(100, 0, 0))
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 1,
	},
    ["__SD"] = {
		AttackAnim = "pure_b_right_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(0,100,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.3, 0.3, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.25,
		Duration = 1,
	},
	["W___"] = {
		AttackAnim = "ryoku_r_c4_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:lscsSetTimedMove( 1, CurTime(), 0.9, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.7,
	},
}
--addons/weapon_jedi/lua/lscs/combos/makashi.lua:
COMBO.id = "makashi"
COMBO.PrintName = "Form II | Makashi"
COMBO.Author = "Deltaa"
COMBO.Description = "Der Weg des Ysalamir"

COMBO.DeflectBullets = true
COMBO.AutoBlock = true

COMBO.LeftSaberActive = false

COMBO.HoldType = "lscs_makashi"
COMBO.MaxBlockPoints = 150

COMBO.Attacks = {
	["BACKFLIP"] = {
		AttackAnim = "rollback",
		BeginAttack = function( weapon, ply )  
			weapon:SetDMGActive(false)

			ply:SetVelocity(Vector(0, 0, 250) - Angle(0, ply:EyeAngles().y, 0):Forward() * 100)
			ply:lscsSuppressFalldamage(CurTime() + 5)
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.5,
	},
	["____"] = {
		AttackAnim = "phalanx_r_left_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.3,
	},
	["-45-"] = {
		AttackAnim = "phalanx_b_s1_t3",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.4,
	},
	["+45+"] = {
		AttackAnim = "phalanx_b_s1_t1",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove(1, CurTime() + 0.3, 0.4, Vector(100, 0, 0))
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.8,
	},
	["W_S_"] = {
		AttackAnim = "h_right_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.7, Vector(250,0,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.7, 0.2, Vector(100,0,0) )
			ply:lscsSetTimedMove( 3, CurTime() + 0.9, 0.7, Vector(0,0,0) )

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
			timer.Simple(0.8, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 1.6,
	},
	["__S_"] = {
		AttackAnim = "vanguard_r_s3_t3",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.3,
	},
	["_A__"] = {
		AttackAnim = "phalanx_r_left_t2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

            ply:lscsSetTimedMove(1, CurTime(), 0.1, Vector(10, 0, 0))
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.2,
	},
	["___D"] = {
		AttackAnim = "phalanx_b_right_t2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.25,
		Duration = 0.2,
	},
	["W__D"] = {
		AttackAnim = "phalanx_r_right_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.3,
		Duration = 0.5,
	},
	["WA__"] = {
		AttackAnim = "phalanx_r_left_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.3,
		Duration = 0.6,
	},
	["__SD"] = {
		AttackAnim = "phalanx_b_right_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-1,1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.2,
		Duration = 0.3,
	},
	["_AS_"] = {
		AttackAnim = "phalanx_b_left_t2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-1,-1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.3,
		Duration = 0.3,
	},
	["W___"] = {
		AttackAnim = "phalanx_b_s2_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.5,
	},
}
--addons/lvs_base/lua/lvs_framework/autorun/lvs_net.lua:

if SERVER then
	util.AddNetworkString( "lvs_player_request_filter" )
	util.AddNetworkString( "lvs_player_enterexit" )
	util.AddNetworkString( "lvs_toggle_mouseaim" )

	net.Receive( "lvs_toggle_mouseaim", function( length, ply )
		ply:lvsBuildControls()

		local veh = ply:lvsGetVehicle()

		if not IsValid( veh ) then return end

		veh:AlignView( ply )
	end)

	net.Receive( "lvs_player_request_filter", function( length, ply )
		if not IsValid( ply ) then return end

		local ent = net.ReadEntity()

		if not IsValid( ent ) or not ent.GetCrosshairFilterEnts then return end -- TODO: Make this loop around and wait for ent.IsInitialized to exist and ent:IsInitialized() to return true

		local CrosshairFilterEnts = table.Copy( ent:GetCrosshairFilterEnts() )

		for id, entity in pairs( CrosshairFilterEnts ) do
			if not IsValid( entity ) or entity:GetNoDraw() then
				CrosshairFilterEnts[ id ] = nil
			end
		end

		net.Start( "lvs_player_request_filter" )
			net.WriteEntity( ent )
			net.WriteTable( CrosshairFilterEnts )
		net.Send( ply )
	end)
else
	net.Receive( "lvs_player_request_filter", function( length )
		local LVSent = net.ReadEntity()

		if not IsValid( LVSent ) then return end

		local Filter = {}

		for _, entity in pairs( net.ReadTable() ) do
			if not IsValid( entity ) then continue end
			table.insert( Filter, entity )
		end

		LVSent.CrosshairFilterEnts = Filter
	end )

	net.Receive( "lvs_player_enterexit", function( len )
		local Enable = net.ReadBool()
		local Vehicle = net.ReadEntity()

		if Enable then
			hook.Run( "LVS.PlayerEnteredVehicle", LocalPlayer(), Vehicle )
		else
			hook.Run( "LVS.PlayerLeaveVehicle", LocalPlayer(), Vehicle )
		end
	end )
end
--lua/autorun/npc_buzz_droid.lua:
local Category = "Star Wars"
local NPC = { 	Name = "Buzz Droid", 
		Class = "npc_manhack",
		Weapons = { "" },
		Model = "models/loic_buzzdroid/buzzdroid.mdl",
		Health = "25",
		Numgrenades = "0",
		Category = Category}
list.Set( "NPC", "npc_buzz_droid", NPC )
--addons/admin_sam/lua/sam_language.lua:
return "english"
--addons/admin_sam_sui/lua/sui/vgui/sui_frame.lua:
local math = math
local gui = gui
local draw = draw
local surface = surface

local ScrW = ScrW
local ScrH = ScrH
local IsValid = IsValid
local ipairs = ipairs

local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name
local TDLib = sui.TDLib

local FRAME_FONT = SUI.CreateFont("Frame", "Roboto", 18)

local Panel = FindMetaTable("Panel")

local PANEL = {}

AccessorFunc(PANEL, "m_bHeaderHeight", "HeaderHeight", FORCE_NUMBER)
AccessorFunc(PANEL, "m_bTitleFont", "TitleFont", FORCE_STRING)
AccessorFunc(PANEL, "m_bSizable", "Sizable", FORCE_BOOL)
AccessorFunc(PANEL, "m_iMinWidth", "MinWidth", FORCE_NUMBER)
AccessorFunc(PANEL, "m_iMinHeight", "MinHeight", FORCE_NUMBER)

local header_Think = function(s)
	local parent = s.parent
	local sw, sh = ScrW(), ScrH()

	if s.dragging then
		local x, y = input.GetCursorPos()
		x, y = math.Clamp(x, 1, sw - 1), math.Clamp(y, 1, sh - 1)
		x, y = x - s.dragging[1], y - s.dragging[2]

		parent:SetPos(x, y)
		parent:InvalidateLayout(true)
		parent:OnPosChanged()
	else
		local x, y, w, h = parent:GetBounds()
		parent:SetPos(math.Clamp(x, 5, sw - w - 5), math.Clamp(y, 5, sh - h - 5))
	end
end

local header_OnMousePressed = function(s)
	local parent = s.parent
	s.dragging = {gui.MouseX() - parent.x, gui.MouseY() - parent.y}
	s:MouseCapture(true)
end

local header_OnMouseReleased = function(s)
	s.dragging = nil
	s:MouseCapture(false)
end

local title_SetBGColor = function(s, c)
	s:SetVisible(c and true or false)
end

local title_update_color = function(s)
	s:SetTextColor(SUI.GetColor("title"))
end

local close_DoClick = function(s)
	s.frame:Remove()
end

function PANEL:Init()
	local header_buttons = {}
	self.header_buttons = header_buttons

	self:Center()
	self:SetHeaderHeight(28)

	local header = self:Add("PANEL")
	header:Dock(TOP)
	header.Paint = self.HeaderPaint
	header:SetCursor("sizeall")

	header.parent = self
	header.Think = header_Think
	header.OnMousePressed = header_OnMousePressed
	header.OnMouseReleased = header_OnMouseReleased
	self.header = header

	local title = header:Add(NAME .. ".Label")
	title:Dock(LEFT)
	title:DockMargin(6, 2, 0, 2)
	title:SetText("")
	title:SetTextColor(SUI.GetColor("title"))
	title:SizeToContents()
	title.SetBGColor = title_SetBGColor
	hook.Add(NAME .. ".ThemeChanged", title, title_update_color)
	self.title = title

	self.close = self:AddHeaderButton("https://raw.githubusercontent.com/Srlion/Addons-Data/main/icons/sui/close.png", "close", close_DoClick)
	self.close.frame = self

	self:SetSize(SUI.Scale(520), SUI.Scale(364))
	self:SetTitleFont(FRAME_FONT)
	SUI.OnScaleChanged(self, self.ScaleChanged)

	function self:PerformLayout(w, h)
		if IsValid(title) then
			title:SizeToContents()
		end

		if IsValid(header) then
			header:SetTall(SUI.Scale(self:GetHeaderHeight()))
		end

		for k, v in ipairs(header_buttons) do
			if IsValid(v) then
				v:SetWide(v:GetTall())
				local margin = SUI.Scale(4)
				v.image:DockMargin(margin, margin, margin, margin)
			end
		end
	end
end

function PANEL:SetSize(w, h)
	self.real_w, self.real_h = w, h
	self:ScaleChanged()
end

function PANEL:HeaderPaint(w, h)
	draw.RoundedBoxEx(3, 0, 0, w, h, SUI.GetColor("header"), true, true)
end

local SetSize = Panel.SetSize
PANEL.RealSetSize = SetSize
function PANEL:ScaleChanged()
	if self.sizing then return end

	local new_w, new_h = SUI.Scale(self.real_w), SUI.Scale(self.real_h)
	self.x, self.y = self.x + (self:GetWide() / 2 - new_w / 2), self.y + (self:GetTall() / 2 - new_h / 2)
	SetSize(self, new_w, new_h)
	self:InvalidateLayout(true)
end

function PANEL:Paint(w, h)
	if SUI.GetColor("frame_blur") then
		TDLib.BlurPanel(self)
	end

	self:RoundedBox("Background", 3, 0, 0, w, h, SUI.GetColor("frame"))
end

function PANEL:SetTitleFont(font)
	self.m_bTitleFont = font
	self.title:SetFont(font)
end

function PANEL:SetTitle(text)
	self.title:SetText(text)
	self.title:SizeToContents()
end

function PANEL:AddHeaderButton(image_name, name, callback)
	local button = self.header:Add("DButton")
	button:SetText("")
	button:Dock(RIGHT)
	button:DockMargin(0, 2, #self.header:GetChildren() == 1 and 4 or 2, 2)

	local hover = name .. "_hover"
	local press = name .. "_press"
	local circle = {}
	button.Paint = function(s, w, h)
		if s:IsHovered() then
			TDLib.DrawCircle(circle, w / 2, h / 2, w / 2, SUI.GetColor(hover))
		end

		if s.Depressed then
			TDLib.DrawCircle(circle, w / 2, h / 2, w / 2, SUI.GetColor(press))
		end
	end
	button.DoClick = callback

	local image = button:Add(NAME .. ".Image")
	image:Dock(FILL)
	image:SetMouseInputEnabled(false)
	image:SetImage(image_name)

	button.image = image

	table.insert(self.header_buttons, button)

	return button
end

function PANEL:OnMousePressed(_, checking)
	if not self.m_bSizable then return end

	local x, y = self:LocalToScreen(0, 0)
	local w, h = self:GetSize()
	if gui.MouseX() > (x + w - 20) and gui.MouseY() > (y + h - 20) then
		if not checking then
			self.sizing = {gui.MouseX() - w, gui.MouseY() - h}
			self:MouseCapture(true)
		end

		self:SetCursor("sizenwse")

		return
	end

	if checking then
		self:SetCursor("arrow")
	end
end

function PANEL:OnMouseReleased()
	if not self.m_bSizable then return end

	self:MouseCapture(false)
	SUI.CallScaleChanged()
	self.sizing = nil
end

function PANEL:Think()
	if not self.m_bSizable then return end

	self:OnMousePressed(nil, true)

	if not self.sizing then return end

	local sw, sh = ScrW(), ScrH()

	local cx, cy = input.GetCursorPos()
	local mousex = math.Clamp(cx, 1, sw - 1)
	local mousey = math.Clamp(cy, 1, sh - 1)

	local x = mousex - self.sizing[1]
	x = math.Clamp(x, self.m_iMinWidth, sw - 10)

	local y = mousey - self.sizing[2]
	y = math.Clamp(y, self.m_iMinHeight, sh - 10)

	self.real_w, self.real_h = x, y
	SetSize(self, x, y)
	self:InvalidateLayout(true)
	self:SetCursor("sizenwse")
end

function PANEL:OnPosChanged()
end

local SetVisible = Panel.SetVisible
local Remove = Panel.Remove

local anim_speed = 0.2

local show = function(s)
	local w, h = s.real_w, s.real_h

	if s.anim_scale then
		w, h = SUI.Scale(w), SUI.Scale(h)
	end

	SetVisible(s, true)

	SetSize(s, w * 1.1, h * 1.1)
	s:Center()

	s:Stop()
	s:SizeTo(w, h, anim_speed, 0, -1)
	s:MoveTo((ScrW() / 2) - (w / 2), (ScrH() / 2) - (h / 2), anim_speed, 0, -1)
	s:AlphaTo(255, anim_speed + 0.02, 0)
	s:MakePopup()
end

local remove = function(s, hide)
	if not hide and not s:IsVisible() then
		Remove(s)
		return
	end

	local w, h = s.real_w, s.real_h

	if s.anim_scale then
		w, h = SUI.Scale(w), SUI.Scale(h)
	end

	w, h = w * 1.1, h * 1.1

	s:Stop()
	s:SizeTo(w, h, anim_speed, 0, -1)
	s:MoveTo((ScrW() / 2) - (w / 2), (ScrH() / 2) - (h / 2), anim_speed, 0, -1)
	s:SetMouseInputEnabled(false)
	s:SetKeyboardInputEnabled(false)
	s:AlphaTo(0, anim_speed + 0.02, 0, function()
		if hide then
			SetVisible(s, false)
		else
			Remove(s)
		end
	end)
end

local hide = function(s)
	remove(s, true)
end

function PANEL:AddAnimations(w, h, no_scale)
	self.anim_scale = not no_scale
	self.real_w, self.real_h = w, h

	self:SetAlpha(0)
	show(self)

	self.Remove = remove
	self.Hide = hide
	self.Show = show
end

sui.register("Frame", PANEL, "EditablePanel")
--addons/admin_sam_sui/lua/sui/vgui/sui_image.lua:
local table = table
local file = file
local coroutine = coroutine
local surface = surface

local UnPredictedCurTime = UnPredictedCurTime
local pairs = pairs

local color_white = color_white

local sui = sui
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local read_gif = include("sui/libs/gif_loader.lua")
local generate_png = include("sui/libs/png_encoder.lua")

local images_path = (NAME .. "/images/"):lower()
file.CreateDir(images_path)

local get_image_path = function(url)
	return images_path .. (url:gsub("%W", "_") .. ".png")
end

local Write = file.Write
local gif_to_png; do
	local internal_gif_to_png = function(file_path, chunk)
		local gif = read_gif(chunk)
		local frames = gif:get_frames()
		local w, h = gif.width, gif.height

		local path = file_path .. "/"
		file.CreateDir(path)

		for frame_id = 1, #frames do
			local frame = frames[frame_id]
			local data = frame.data
			local png = generate_png(w, h, data)
			Write(("%s%d_%d.png"):format(path, frame_id, frame.delay), png)
			coroutine.yield()
		end
	end

	local delay = 0.01
	local next_run = 0

	local coroutines = {}
	local callbacks = {}
	gif_to_png = function(file_path, data, callback)
		local co = coroutine.create(internal_gif_to_png)
		local i = table.insert(coroutines, co)
		callbacks[i] = callback
		coroutine.resume(co, file_path, data)
		next_run = UnPredictedCurTime()
	end

	hook.Add("Think", NAME .. "ProcessGIFs", function()
		local co = coroutines[1]
		if not co then return end
		if UnPredictedCurTime() < next_run then return end

		if coroutine.status(co) == "suspended" then
			coroutine.resume(co)
		else
			callbacks[1]()
			table.remove(coroutines, 1)
			table.remove(callbacks, 1)
		end

		next_run = UnPredictedCurTime() + delay
	end)

	hook.Add(NAME .. "ImagesCleared", "ClearCoroutines", function()
		table.Empty(coroutines)
		table.Empty(callbacks)
	end)
end

local download_image, is_downloading_image; do
	-- https://stackoverflow.com/questions/25959386/how-to-check-if-a-file-is-a-valid-image
	local valid_images = {
		["\xff\xd8\xff"] = "jpeg",
		["\x89PNG\r\n\x1a\n"] = "png",
		["GIF87a"] = "gif",
		["GIF89a"] = "gif",
	}

	local get_image_type = function(data)
		for k, v in pairs(valid_images) do
			if data:StartWith(k) then
				return v
			end
		end
		return false
	end

	local downloading_images = {}

	local process_callbacks = function(url)
		local callbacks = downloading_images[url] or {}
		downloading_images[url] = nil

		for _, func in ipairs(callbacks) do
			func()
		end
	end

	download_image = function(url, callback)
		if downloading_images[url] then
			table.insert(downloading_images[url], callback)
			return
		end

		downloading_images[url] = {callback}

		http.Fetch(url, function(data)
			local image_type = get_image_type(data)
			if not image_type then
				downloading_images[url] = nil
				return
			end

			local image_path = get_image_path(url)

			if image_type == "gif" then
				gif_to_png(image_path, data, function()
					process_callbacks(url)
				end)
			else
				file.Write(image_path, data)
				process_callbacks(url)
			end
		end, function(err)
			print("(SUI) Failed to download an image, error: " .. err)
			downloading_images[url] = nil
		end)
	end

	is_downloading_image = function(url)
		return downloading_images[url] ~= nil
	end

	hook.Add(NAME .. "ImagesCleared", "ClearDownloadingImages", function()
		table.Empty(downloading_images)
	end)
end

local images_panels = {}

local PANEL = {}

local err_mat = SUI.Material("error")

function PANEL:Init()
	self:SetMouseInputEnabled(false)

	self.minus = 0
	self.rotation = 0
	self.image = err_mat
	self.image_col = color_white

	table.insert(images_panels, self)
end

function PANEL:OnRemove()
	for k, v in ipairs(images_panels) do
		if v == self then
			table.remove(images_panels, k)
			return
		end
	end
end

function PANEL:SetMinus(minus)
	self.minus = minus
end

function PANEL:SetRotation(rotation)
	self.rotation = rotation
end

function PANEL:SetImageColor(col)
	self.image_col = col
end

local cached_files = {}
local get_files = function(image_path)
	local f = cached_files[image_path]
	if f then return f end

	cached_files[image_path] = file.Find(image_path .. "/*", "DATA")

	return cached_files[image_path]
end

function PANEL:SetImage(url)
	self.image = err_mat

	self.pos = nil
	self.delay = nil

	self.images = nil
	self.delays = nil
	self.url = url

	if url:sub(1, 4) ~= "http" then
		self.image = SUI.Material(url)
		return
	end

	local image_path = get_image_path(url)
	if not file.Exists(image_path, "DATA") or is_downloading_image(url) then
		download_image(url, function()
			if self:IsValid() then
				self:SetImage(url)
			end
		end)
		return
	end

	local is_gif = file.IsDir(image_path, "DATA")
	if is_gif then
		local images = {}
		local delays = {}

		local files = get_files(image_path)
		for i = 1, #files do
			local v = files[i]
			local id, delay = v:match("(.*)_(.*)%.png")
			id = tonumber(id)
			local img_path = "../data/" .. image_path .. "/" .. v
			images[id] = img_path
			delays[id] = delay
		end

		self.frame = 1
		self.delay = (UnPredictedCurTime() * 100) + delays[1]

		self.images = images
		self.delays = delays

		self.max_images = #files
	else
		self.image = SUI.Material("../data/" .. image_path)
	end
end

local SetMaterial = surface.SetMaterial
function PANEL:PaintGIF(w, h, images)
	local frame = self.frame

	-- SUI.Material() caches materials by default
	local mat = SUI.Material(images[frame], true)
	if not mat then
		if frame > 1 then
			mat = SUI.Material(images[frame - 1])
		else
			mat = err_mat
		end

		SetMaterial(mat)

		return
	end

	SetMaterial(mat)

	local curtime = UnPredictedCurTime() * 100
	if curtime < self.delay then return end
	frame = frame + 1
	if frame > self.max_images then
		frame = 1
	end

	self.frame = frame
	self.delay = curtime + self.delays[frame]
end

local PaintGIF = PANEL.PaintGIF
local SetDrawColor = surface.SetDrawColor
local DrawTexturedRectRotated = surface.DrawTexturedRectRotated
function PANEL:Paint(w, h)
	SetDrawColor(self.image_col)

	local images = self.images
	if images then
		PaintGIF(self, w, h, images)
	else
		SetMaterial(self.image)
	end

	if self.Draw then
		self:Draw(w, h, true)
	else
		local minus = self.minus
		DrawTexturedRectRotated(w * 0.5, h * 0.5, w - minus, h - minus, self.rotation)
	end
end

sui.register("Image", PANEL, "PANEL")

function SUI.ClearImages()
	local files, dirs = file.Find(images_path .. "/*", "DATA")
	for _, f in ipairs(files) do
		file.Delete(images_path .. f)
	end

	for _, d in ipairs(dirs) do
		for _, f in ipairs(file.Find(images_path .. d .. "/*", "DATA")) do
			file.Delete(images_path .. (d .. "/" .. f))
		end
		file.Delete(images_path .. d)
	end

	table.Empty(SUI.materials)
	table.Empty(cached_files)

	hook.Call(NAME .. "ImagesCleared")

	for k, v in ipairs(images_panels) do
		if v.url then
			v:SetImage(v.url)
		end
	end
end
--addons/admin_sam_sui/lua/sui/vgui/sui_scroll_panel.lua:
local math = math
local table = table

local pairs = pairs

local TDLib = sui.TDLib
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name
local RoundedBox = sui.TDLib.LibClasses.RoundedBox

local Panel = {}

AccessorFunc(Panel, "m_bFromBottom", "FromBottom", FORCE_BOOL)
AccessorFunc(Panel, "m_bVBarPadding", "VBarPadding", FORCE_NUMBER)

Panel:SetVBarPadding(0)

Panel.NoOverrideClear = true

-- VBar
local starting_scroll_speed = 3

local vbar_OnMouseWheeled = function(s, delta)
	s.scroll_speed = s.scroll_speed + 20 * 0.012 --[[ slowly increase scroll speed ]]
	s:AddScroll(delta * -s.scroll_speed)
end

-- default set scroll clamps amount
local vbar_SetScroll = function(s, amount)
	if not s.Enabled then s.Scroll = 0 return end

	s.scroll_target = amount
	s:InvalidateLayout()
end

-- \_()_/ https://github.com/Facepunch/garrysmod/blob/cd3d894288b847e3d081570129963d4089e36261/garrysmod/lua/vgui/dvscrollbar.lua#L234
local vbar_OnCursorMoved = function(s, _, y)
	if s.Dragging then
		y = y - s.HoldPos
		y = y / (s:GetTall() - s:GetWide() * 2 - s.btnGrip:GetTall())
		s.scroll_target = y * s.CanvasSize
	end
end

local vbar_Think = function(s)
	local frame_time = RealFrameTime() * 17
	local scroll_target = s.scroll_target

	s.Scroll = Lerp(frame_time, s.Scroll, scroll_target)

	if not s.Dragging then
		s.scroll_target = Lerp(frame_time, scroll_target, math.Clamp(scroll_target, 0, s.CanvasSize))
	end

	-- now start slowing it down!!!
	s.scroll_speed = Lerp(frame_time / 10, s.scroll_speed, starting_scroll_speed)
end

local vbar_Paint = function(s, w, h)
	TDLib.RoundedBox(s.vertices, 3, 0, 0, w, h, SUI.GetColor("scroll"))
end

local vbarGrip_Paint = function(s, w, h)
	TDLib.RoundedBox(s.vertices, 3, 0, 0, w, h, SUI.GetColor("scroll_grip"))
end

local vbar_PerformLayout = function(s, w, h)
	local scroll = s:GetScroll() / s.CanvasSize
	local bar_size = math.max(s:BarScale() * h, 10)

	local track = (h - bar_size) + 1
	scroll = scroll * track

	s.btnGrip.y = scroll
	s.btnGrip:SetSize(w, bar_size)
end
--

function Panel:Init()
	local canvas = self:GetCanvas()
	canvas:SUI_TDLib()

	local children = {}
	function canvas:OnChildAdded(child)
		table.insert(children, child)
	end
	function canvas:OnChildRemoved(child)
		for i = 1, #children do
			local v = children[i]
			if v == child then
				table.remove(children, i)
				return
			end
		end
	end
	canvas.GetChildren = function()
		return children
	end
	canvas.children = children

	local vbar = self.VBar
	vbar:SetHideButtons(true)
	vbar.btnUp:SetVisible(false)
	vbar.btnDown:SetVisible(false)

	vbar.vertices = {}
	vbar.scroll_target = 0
	vbar.scroll_speed = starting_scroll_speed

	vbar.OnMouseWheeled = vbar_OnMouseWheeled
	vbar.SetScroll = vbar_SetScroll
	vbar.OnCursorMoved = vbar_OnCursorMoved
	vbar.Think = vbar_Think
	vbar.Paint = vbar_Paint
	vbar.PerformLayout = vbar_PerformLayout

	vbar.btnGrip.vertices = {}
	vbar.btnGrip.Paint = vbarGrip_Paint

	self:ScaleChanged()
	SUI.OnScaleChanged(self, self.ScaleChanged)
end

function Panel:OnChildAdded(child)
	self:AddItem(child)
	self:ChildAdded(child)
end

function Panel:ChildAdded()
end

function Panel:ScaleChanged()
	local w = SUI.Scale(4)

	self.VBar:SetWide(w)
	self.VBar.btnDown:SetSize(w, 0)
	self.VBar.btnUp:SetSize(w, 0)
end

function Panel:Paint(w, h)
	local outline = SUI.GetColor("scroll_panel_outline")
	if outline then
		TDLib.DrawOutlinedBox(3, 0, 0, w, h, SUI.GetColor("scroll_panel"), outline, 1)
	else
		RoundedBox(self, "Background", 3, 0, 0, w, h, SUI.GetColor("scroll_panel"))
	end
end

function Panel:ScrollToBottom()
	local vbar = self.VBar
	for k, anim in pairs(vbar.m_AnimList or {}) do
		anim:Think(vbar, 1)
		vbar.m_AnimList[k] = nil
	end

	self:InvalidateParent(true)
	self:InvalidateChildren(true)

	vbar:SetScroll(vbar.CanvasSize)
end

function Panel:PerformLayoutInternal(w, h)
	w = w or self:GetWide()
	h = h or self:GetTall()

	local canvas = self.pnlCanvas

	self:Rebuild()

	local vbar = self.VBar
	vbar:SetUp(h, canvas:GetTall())

	if vbar.Enabled then
		w = w - vbar:GetWide() - self.m_bVBarPadding
	end

	canvas:SetWide(w)

	self:Rebuild()
end

function Panel:Think()
	local canvas = self.pnlCanvas

	local vbar = self.VBar
	if vbar.Enabled then
		canvas.y = -vbar.Scroll
	else
		if self:GetFromBottom() then
			canvas._y = Lerp(10 * RealFrameTime(), canvas._y or canvas.y, self:GetTall() - canvas:GetTall())
		else
			canvas._y = Lerp(10 * RealFrameTime(), canvas._y or canvas.y, -vbar.Scroll)
		end
		canvas.y = canvas._y
	end
end

sui.register("ScrollPanel", Panel, "DScrollPanel")

--addons/admin_sam/lua/sui/vgui/sam_player_line.lua:
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local TDLib = sui.TDLib
local draw_material = sui.draw_material
local lerp_color = sui.lerp_color

local GetColor = SUI.GetColor
local RoundedBox = TDLib.RoundedBox
local CircleAvatar = TDLib.LibClasses.CircleAvatar
local CircleClick2 = TDLib.LibClasses.CircleClick2

local PLAYER_LINE_NAME = SUI.CreateFont("PlayerLineName", "Roboto Bold", 17)
local PLAYER_LINE_RANK = SUI.CreateFont("PlayerLineRank", "Roboto Bold", 13)
local PLAYER_LINE_STEAMID = SUI.CreateFont("PlayerLineSteamID", "Roboto Medium", 12)

local PANEL = {}

function PANEL:Init()
	local size = SUI.Scale(34)

	self:Dock(TOP)
	self:SetTall(size)

	self.size = size
end

local rank_Paint = function(s, w, h)
	RoundedBox(s.rect, SUI.Scale(10), 0, 0, w, h, s.col)
end

function PANEL:SetInfo(info)
	local size = self.size

	local container
	do
		local w = SUI.Scale(280) + size

		local _container = self:Add("Panel")
		_container:Dock(LEFT)
		_container:SetMouseInputEnabled(false)
		_container:SetWide(w)

		container = _container:Add("Panel")
		container:SetSize(w, size)

		function _container:PerformLayout()
			container:Center()
		end
	end

	do
		local avatar = container:Add("Panel")
		avatar:Dock(LEFT)
		avatar:DockMargin(0, 0, 5, 0)
		avatar:SetWide(size)
		avatar:SetMouseInputEnabled(false)
		CircleAvatar(avatar)

		avatar:SetSteamID(util.SteamIDTo64(info.steamid), size)
	end

	do
		local top_container = container:Add("Panel")
		top_container:Dock(TOP)
		top_container:DockMargin(0, 0, 0, 2)

		local name = top_container:Add("SAM.Label")
		name:Dock(LEFT)
		name:SetFont(PLAYER_LINE_NAME)
		self.name = name

		local pname = info.name
		if not pname or pname == "" then
			name:SetTextColor(GetColor("player_list_names_2"))
			self:SetName("N/A")
		else
			name:SetTextColor(GetColor("player_list_names"))
			self:SetName(pname)
		end

		if info.rank then
			local rank_bg = top_container:Add("Panel")
			rank_bg:Dock(LEFT)
			rank_bg:DockMargin(5, 0, 0, 0)

			rank_bg.rect = {}
			rank_bg.col = info.rank_bg or GetColor("player_list_rank")
			rank_bg.Paint = rank_Paint

			local rank = rank_bg:Add("SAM.Label")
			rank:Dock(FILL)
			rank:DockMargin(SUI.Scale(8), 0, 0, 0)
			rank:SetTextColor(GetColor("player_list_rank_text"))
			rank:SetFont(PLAYER_LINE_RANK)
			rank.bg = rank_bg

			self.rank = rank
			self:SetRank(info.rank)

			rank_bg:SetSize(rank:GetTextSize() + SUI.Scale(8) * 2)
		end

		top_container:SizeToChildren(true, true)
	end

	local steamid = container:Add("SAM.Label")
	steamid:Dock(TOP)
	steamid:SetTextColor(GetColor("player_list_steamid"))
	steamid:SetFont(PLAYER_LINE_STEAMID)
	steamid:SetText(info.steamid)
	steamid:SizeToContents()
	steamid:SetAutoStretchVertical(true)

	self.container = container
end

function PANEL:SetName(new_name)
	local name =  self.name
	name:SetText(new_name)
	name:SizeToContents()
	if name:GetWide() > 160 then
		name:SetWide(158)
	end
end

function PANEL:SetRank(new_rank)
	local rank = self.rank
	rank:SetText(new_rank)
	rank:SizeToContents()
	rank.bg:SetSize(rank:GetTextSize() + SUI.Scale(8) * 2)
end

function PANEL:Actions()
	local container
		do
		local size = self.size

		local _container = self:Add("Panel")
		_container:Dock(RIGHT)
		_container:SetWide(size)

		container = _container:Add("Panel")
		container:SetSize(size, size)

		function _container:PerformLayout()
			container:Center()
		end
	end

	local actions_button = container:Add("SAM.Button")
	actions_button:SetText("")
	actions_button:ClearPaint()

	function container:PerformLayout(w, h)
		actions_button:SetSize(h, h)
		actions_button:Center()
	end

	local image = actions_button:Add("SAM.Image")
	image:Dock(FILL)
	image:SetImage("https://raw.githubusercontent.com/Srlion/Addons-Data/main/icons/sam/dots_verticle.png")

	local current_icon_color = Color(GetColor("actions_button_icon"):Unpack())
	function image:Draw(w, h)
		if not h then return end

		if actions_button.Hovered then
			lerp_color(current_icon_color, GetColor("actions_button_icon_hover"))
		else
			lerp_color(current_icon_color, GetColor("actions_button_icon"))
		end

		draw_material(nil, w / 2, h / 2, SUI.ScaleEven(20), current_icon_color)
	end

	CircleClick2(actions_button, Color(62, 62, 62), 10)
	actions_button:Center()

	return actions_button
end

sui.register("PlayerLine", PANEL, "Panel")
--addons/admin_sam/lua/sam/modules/cami.lua:
if SAM_LOADED then return end

--[[
CAMI - Common Admin Mod Interface.
Copyright 2020 CAMI Contributors

Makes admin mods intercompatible and provides an abstract privilege interface
for third party addons.

Follows the specification on this page:
https://github.com/glua/CAMI/blob/master/README.md

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
]]

-- Version number in YearMonthDay format.
local version = 20201130

if CAMI and CAMI.Version >= version then return end

CAMI = CAMI or {}
CAMI.Version = version


--- @class CAMI_USERGROUP
--- defines the charactaristics of a usergroup
--- @field Name string @The name of the usergroup
--- @field Inherits string @The name of the usergroup this usergroup inherits from

--- @class CAMI_PRIVILEGE
--- defines the charactaristics of a privilege
--- @field Name string @The name of the privilege
--- @field MinAccess "'user'" | "'admin'" | "'superadmin'" @Default group that should have this privilege
--- @field Description string | nil @Optional text describing the purpose of the privilege
local CAMI_PRIVILEGE = {}
--- Optional function to check if a player has access to this privilege
--- (and optionally execute it on another player)
---
---  **Warning**: This function may not be called by all admin mods
--- @param actor GPlayer @The player
--- @param target GPlayer | nil @Optional - the target
--- @return boolean @If they can or not
--- @return string | nil @Optional reason
function CAMI_PRIVILEGE:HasAccess(actor, target)
end

--- Contains the registered CAMI_USERGROUP usergroup structures.
--- Indexed by usergroup name.
--- @type CAMI_USERGROUP[]
local usergroups = CAMI.GetUsergroups and CAMI.GetUsergroups() or {
    user = {
        Name = "user",
        Inherits = "user"
    },
    admin = {
        Name = "admin",
        Inherits = "user"
    },
    superadmin = {
        Name = "superadmin",
        Inherits = "admin"
    }
}

--- Contains the registered CAMI_PRIVILEGE privilege structures.
--- Indexed by privilege name.
--- @type CAMI_PRIVILEGE[]
local privileges = CAMI.GetPrivileges and CAMI.GetPrivileges() or {}

--- Registers a usergroup with CAMI.
---
--- Use the source parameter to make sure CAMI.RegisterUsergroup function and
--- the CAMI.OnUsergroupRegistered hook don't cause an infinite loop
--- @param usergroup CAMI_USERGROUP @The structure for the usergroup you want to register
--- @param source any @Identifier for your own admin mod. Can be anything.
--- @return CAMI_USERGROUP @The usergroup given as an argument
function CAMI.RegisterUsergroup(usergroup, source)
    usergroups[usergroup.Name] = usergroup

    hook.Call("CAMI.OnUsergroupRegistered", nil, usergroup, source)
    return usergroup
end

--- Unregisters a usergroup from CAMI. This will call a hook that will notify
--- all other admin mods of the removal.
---
---  **Warning**: Call only when the usergroup is to be permanently removed.
---
--- Use the source parameter to make sure CAMI.UnregisterUsergroup function and
--- the CAMI.OnUsergroupUnregistered hook don't cause an infinite loop
--- @param usergroupName string @The name of the usergroup.
--- @param source any @Identifier for your own admin mod. Can be anything.
--- @return boolean @Whether the unregistering succeeded.
function CAMI.UnregisterUsergroup(usergroupName, source)
    if not usergroups[usergroupName] then return false end

    local usergroup = usergroups[usergroupName]
    usergroups[usergroupName] = nil

    hook.Call("CAMI.OnUsergroupUnregistered", nil, usergroup, source)

    return true
end

--- Retrieves all registered usergroups.
--- @return CAMI_USERGROUP[] @Usergroups indexed by their names.
function CAMI.GetUsergroups()
    return usergroups
end

--- Receives information about a usergroup.
--- @param usergroupName string
--- @return CAMI_USERGROUP | nil @Returns nil when the usergroup does not exist.
function CAMI.GetUsergroup(usergroupName)
    return usergroups[usergroupName]
end

--- Checks to see if potentialAncestor is an ancestor of usergroupName.
--- All usergroups are ancestors of themselves.
---
--- Examples:
--- * `user` is an ancestor of `admin` and also `superadmin`
--- * `admin` is an ancestor of `superadmin`, but not `user`
--- @param usergroupName string @The usergroup to query
--- @param potentialAncestor string @The ancestor to query
--- @return boolean @Whether usergroupName inherits potentialAncestor.
function CAMI.UsergroupInherits(usergroupName, potentialAncestor)
    repeat
        if usergroupName == potentialAncestor then return true end

        usergroupName = usergroups[usergroupName] and
                         usergroups[usergroupName].Inherits or
                         usergroupName
    until not usergroups[usergroupName] or
          usergroups[usergroupName].Inherits == usergroupName

    -- One can only be sure the usergroup inherits from user if the
    -- usergroup isn't registered.
    return usergroupName == potentialAncestor or potentialAncestor == "user"
end

--- Find the base group a usergroup inherits from.
---
--- This function traverses down the inheritence chain, so for example if you have
--- `user` -> `group1` -> `group2`
--- this function will return `user` if you pass it `group2`.
---
---  **NOTE**: All usergroups must eventually inherit either user, admin or superadmin.
--- @param usergroupName string @The name of the usergroup
--- @return "'user'" | "'admin'" | "'superadmin'" @The name of the root usergroup
function CAMI.InheritanceRoot(usergroupName)
    if not usergroups[usergroupName] then return end

    local inherits = usergroups[usergroupName].Inherits
    while inherits ~= usergroups[usergroupName].Inherits do
        usergroupName = usergroups[usergroupName].Inherits
    end

    return usergroupName
end

--- Registers an addon privilege with CAMI.
---
---  **Warning**: This should only be used by addons. Admin mods must *NOT*
---  register their privileges using this function.
--- @param privilege CAMI_PRIVILEGE
--- @return CAMI_PRIVILEGE @The privilege given as argument.
function CAMI.RegisterPrivilege(privilege)
    privileges[privilege.Name] = privilege

    hook.Call("CAMI.OnPrivilegeRegistered", nil, privilege)

    return privilege
end

--- Unregisters a privilege from CAMI.
--- This will call a hook that will notify any admin mods of the removal.
---
---  **Warning**: Call only when the privilege is to be permanently removed.
--- @param privilegeName string @The name of the privilege.
--- @return boolean @Whether the unregistering succeeded.
function CAMI.UnregisterPrivilege(privilegeName)
    if not privileges[privilegeName] then return false end

    local privilege = privileges[privilegeName]
    privileges[privilegeName] = nil

    hook.Call("CAMI.OnPrivilegeUnregistered", nil, privilege)

    return true
end

--- Retrieves all registered privileges.
--- @return CAMI_PRIVILEGE[] @All privileges indexed by their names.
function CAMI.GetPrivileges()
    return privileges
end

--- Receives information about a privilege.
--- @param privilegeName string
--- @return CAMI_PRIVILEGE | nil
function CAMI.GetPrivilege(privilegeName)
    return privileges[privilegeName]
end

-- Default access handler
local defaultAccessHandler = {["CAMI.PlayerHasAccess"] =
    function(_, actorPly, privilegeName, callback, targetPly, extraInfoTbl)
        -- The server always has access in the fallback
        if not IsValid(actorPly) then return callback(true, "Fallback.") end

        local priv = privileges[privilegeName]

        local fallback = extraInfoTbl and (
            not extraInfoTbl.Fallback and actorPly:IsAdmin() or
            extraInfoTbl.Fallback == "user" and true or
            extraInfoTbl.Fallback == "admin" and actorPly:IsAdmin() or
            extraInfoTbl.Fallback == "superadmin" and actorPly:IsSuperAdmin())


        if not priv then return callback(fallback, "Fallback.") end

        local hasAccess =
            priv.MinAccess == "user" or
            priv.MinAccess == "admin" and actorPly:IsAdmin() or
            priv.MinAccess == "superadmin" and actorPly:IsSuperAdmin()

        if hasAccess and priv.HasAccess then
            hasAccess = priv:HasAccess(actorPly, targetPly)
        end

        callback(hasAccess, "Fallback.")
    end,
    ["CAMI.SteamIDHasAccess"] =
    function(_, _, _, callback)
        callback(false, "No information available.")
    end
}

--- @class CAMI_ACCESS_EXTRA_INFO
--- @field Fallback "'user'" | "'admin'" | "'superadmin'" @Fallback status for if the privilege doesn't exist. Defaults to `admin`.
--- @field IgnoreImmunity boolean @Ignore any immunity mechanisms an admin mod might have.
--- @field CommandArguments table @Extra arguments that were given to the privilege command.

--- Checks if a player has access to a privilege
--- (and optionally can execute it on targetPly)
---
--- This function is designed to be asynchronous but will be invoked
---  synchronously if no callback is passed.
---
---  **Warning**: If the currently installed admin mod does not support
---                 synchronous queries, this function will throw an error!
--- @param actorPly GPlayer @The player to query
--- @param privilegeName string @The privilege to query
--- @param callback fun(hasAccess: boolean, reason: string|nil) @Callback to receive the answer, or nil for synchronous
--- @param targetPly GPlayer | nil @Optional - target for if the privilege effects another player (eg kick/ban)
--- @param extraInfoTbl CAMI_ACCESS_EXTRA_INFO | nil @Table of extra information for the admin mod
--- @return boolean | nil @Synchronous only - if the player has the privilege
--- @return string | nil @Synchronous only - optional reason from admin mod
function CAMI.PlayerHasAccess(actorPly, privilegeName, callback, targetPly,
extraInfoTbl)
    local hasAccess, reason = nil, nil
    local callback_ = callback or function(hA, r) hasAccess, reason = hA, r end

    hook.Call("CAMI.PlayerHasAccess", defaultAccessHandler, actorPly,
        privilegeName, callback_, targetPly, extraInfoTbl)

    if callback ~= nil then return end

    if hasAccess == nil then
        local err = [[The function CAMI.PlayerHasAccess was used to find out
        whether Player %s has privilege "%s", but an admin mod did not give an
        immediate answer!]]
        error(string.format(err,
            actorPly:IsPlayer() and actorPly:Nick() or tostring(actorPly),
            privilegeName))
    end

    return hasAccess, reason
end

--- Get all the players on the server with a certain privilege
--- (and optionally who can execute it on targetPly)
---
---  **NOTE**: This is an asynchronous function!
--- @param privilegeName string @The privilege to query
--- @param callback fun(players: GPlayer[]) @Callback to receive the answer
--- @param targetPly GPlayer | nil @Optional - target for if the privilege effects another player (eg kick/ban)
--- @param extraInfoTbl CAMI_ACCESS_EXTRA_INFO | nil @Table of extra information for the admin mod
function CAMI.GetPlayersWithAccess(privilegeName, callback, targetPly,
extraInfoTbl)
    local allowedPlys = {}
    local allPlys = player.GetAll()
    local countdown = #allPlys

    local function onResult(ply, hasAccess, _)
        countdown = countdown - 1

        if hasAccess then table.insert(allowedPlys, ply) end
        if countdown == 0 then callback(allowedPlys) end
    end

    for _, ply in ipairs(allPlys) do
        CAMI.PlayerHasAccess(ply, privilegeName,
            function(...) onResult(ply, ...) end,
            targetPly, extraInfoTbl)
    end
end

--- @class CAMI_STEAM_ACCESS_EXTRA_INFO
--- @field IgnoreImmunity boolean @Ignore any immunity mechanisms an admin mod might have.
--- @field CommandArguments table @Extra arguments that were given to the privilege command.

--- Checks if a (potentially offline) SteamID has access to a privilege
--- (and optionally if they can execute it on a target SteamID)
---
---  **NOTE**: This is an asynchronous function!
--- @param actorSteam string | nil @The SteamID to query
--- @param privilegeName string @The privilege to query
--- @param callback fun(hasAccess: boolean, reason: string|nil) @Callback to receive  the answer
--- @param targetSteam string | nil @Optional - target SteamID for if the privilege effects another player (eg kick/ban)
--- @param extraInfoTbl CAMI_STEAM_ACCESS_EXTRA_INFO | nil @Table of extra information for the admin mod
function CAMI.SteamIDHasAccess(actorSteam, privilegeName, callback,
targetSteam, extraInfoTbl)
    hook.Call("CAMI.SteamIDHasAccess", defaultAccessHandler, actorSteam,
        privilegeName, callback, targetSteam, extraInfoTbl)
end

--- Signify that your admin mod has changed the usergroup of a player. This
--- function communicates to other admin mods what it thinks the usergroup
--- of a player should be.
---
--- Listen to the hook to receive the usergroup changes of other admin mods.
--- @param ply GPlayer @The player for which the usergroup is changed
--- @param old string @The previous usergroup of the player.
--- @param new string @The new usergroup of the player.
--- @param source any @Identifier for your own admin mod. Can be anything.
function CAMI.SignalUserGroupChanged(ply, old, new, source)
    hook.Call("CAMI.PlayerUsergroupChanged", nil, ply, old, new, source)
end

--- Signify that your admin mod has changed the usergroup of a disconnected
--- player. This communicates to other admin mods what it thinks the usergroup
--- of a player should be.
---
--- Listen to the hook to receive the usergroup changes of other admin mods.
--- @param steamId string @The steam ID of the player for which the usergroup is changed
--- @param old string @The previous usergroup of the player.
--- @param new string @The new usergroup of the player.
--- @param source any @Identifier for your own admin mod. Can be anything.
function CAMI.SignalSteamIDUserGroupChanged(steamId, old, new, source)
    hook.Call("CAMI.SteamIDUsergroupChanged", nil, steamId, old, new, source)
end

--addons/admin_sam/lua/sam/modules/murder.lua:
if SAM_LOADED then return end

local add = not GAMEMODE and hook.Add or function(_, _, fn)
	fn()
end

-- Thanks to https://github.com/boxama/addons/blob/master/addons/ULX_Murder/lua/ulx/modules/sh/murder.lua
add("PostGamemodeLoaded", "SAM.Murder", function()
	if GAMEMODE.Author ~= "MechanicalMind" then return end
	if not isstring(GAMEMODE.Version) or GAMEMODE.Version < "28" then return end

	local sam, command = sam, sam.command

	command.set_category("Murder")

	local autoslain_players = {}

	command.new("slaynr")
		:SetPermission("slaynr", "admin")

		:AddArg("player")
		:AddArg("number", {hint = "rounds", optional = true, default = 1, min = 1, max = 100, round = true})

		:Help("Slays the target(s) at the beggining of the next round.")

		:OnExecute(function(ply, targets, rounds)
			for i = 1, #targets do
				local v = targets[i]
				v.MurdererChance = 0

				if not v:IsBot() then
					autoslain_players[v:AccountID()] = rounds
				end
			end

			sam.player.send_message(nil, "{A} set {T} to be autoslain for {V} round(s)", {
				A = ply, T = targets, V = rounds
			})
		end)
	:End()

	command.new("unslaynr")
		:SetPermission("unslaynr", "admin")

		:AddArg("player")

		:Help("Remove target(s) autoslays.")

		:OnExecute(function(ply, targets)
			for i = 1, #targets do
				local v = targets[i]
				v.MurdererChance = 1

				if not v:IsBot() then
					autoslain_players[v:AccountID()] = nil
				end
			end

			sam.player.send_message(nil, "Removed all autoslays for {T} ", {
				A = ply, T = targets
			})
		end)
	:End()

	hook.Add("OnStartRound", "SAM.Murder", function()
		timer.Simple(3, function()
			local players = team.GetPlayers(2)
			local targets = {admin = sam.console}
			for i = 1, #players do
				local v = players[i]
				if not v:IsBot() then continue end

				local slays = autoslain_players[v:AccountID()]
				if not slays then continue end

				v:Kill()

				slays = slays - 1

				targets[1] = v
				sam.player.send_message(nil, "{A} autoslayed {T}, autoslays left: {V}.", {
					A = sam.console, T = targets, V = slays
				})

				autoslain_players[v:AccountID()] = slays > 0 and slays or nil
			end
		end)
	end)

	hook.Add("PlayerInitialSpawn", "SAM.Murder", function(ply)
		if autoslain_players[ply:AccountID()] then
			ply.MurdererChance = 0
		end
	end)

	command.new("respawn")
		:SetPermission("respawn", "admin")

		:AddArg("player", {single_target = true})

		:Help("Respawn a target.")

		:OnExecute(function(ply, targets)
			local target = targets[1]

			if target:Team() ~= 2 then
				return ply:sam_add_text("You cannot respawn a spectator!")
			end

			target:Spectate(OBS_MODE_NONE)
			target:Spawn()

			sam.player.send_message(nil, "respawn", {
				A = ply, T = targets
			})
		end)
	:End()

	local get_admins = function()
		local admins = {}

		local players = player.GetHumans()
		for i = 1, #players do
			local v = players[i]
			if v:IsAdmin() then
				table.insert(admins, v)
			end
		end

		return admins
	end

	command.new("givemagnum")
		:SetPermission("givemagnum", "superadmin")

		:AddArg("player", {single_target = true, optional = true})

		:Help("Give the target a magnum.")

		:OnExecute(function(ply, targets)
			local target = targets[1]

			if target:Team() ~= 2 then
				return ply:sam_add_text("You cannot give spectator a magnum!")
			end

			target:Give("weapon_mu_magnum")

			sam.player.send_message(get_admins(), "{A} gave {T} a {V}", {
				A = ply, T = targets, V = "magnum"
			})
		end)
	:End()

	command.new("giveknife")
		:SetPermission("giveknife", "superadmin")

		:AddArg("player", {single_target = true, optional = true})

		:Help("Give the target a knife.")

		:OnExecute(function(ply, targets)
			local target = targets[1]

			if target:Team() ~= 2 then
				return ply:sam_add_text("You cannot give spectator a knife!")
			end

			target:Give("weapon_mu_knife")

			sam.player.send_message(get_admins(), "{A} gave {T} a {V}", {
				A = ply, T = targets, V = "knife"
			})
		end)
	:End()

	command.new("forcemurderer")
		:SetPermission("forcemurderer", "admin")

		:AddArg("player", {single_target = true, optional = true})

		:Help("Force the target to me a murderer next round.")

		:OnExecute(function(ply, targets)
			GAMEMODE.ForceNextMurderer = targets[1]

			sam.player.send_message(get_admins(), "{A} set {T} to be the Murderer next round!", {
				A = ply, T = targets
			})
		end)
	:End()

	command.new("getmurderers")
		:SetPermission("getmurderers", "admin")

		:Help("Print all murderers in chat.")

		:OnExecute(function(ply)
			local murderers = {admin = ply}

			local players = team.GetPlayers(2)
			for i = 1, #players do
				local v = players[i]
				if v:GetMurderer() then
					table.insert(murderers, v)
				end
			end

			sam.player.send_message(ply, "Murderers are: {T}", {
				T = murderers
			})
		end)
	:End()
end)
--addons/admin_sam/lua/sam/modules/util.lua:
if SAM_LOADED then return end

local sam, command, language = sam, sam.command, sam.language

command.set_category("Utility")

command.new("map")
	:SetPermission("map", "admin")

	:AddArg("map")
	:AddArg("text", {hint = "gamemode", optional = true, check = sam.is_valid_gamemode})

	:Help("map_help")

	:OnExecute(function(ply, map, gamemode)
		if not gamemode then
			sam.player.send_message(nil, "map_change", {
				A = ply, V = map
			})
		else
			sam.player.send_message(nil, "map_change2", {
				A = ply, V = map, V_2 = gamemode
			})
			RunConsoleCommand("gamemode", gamemode)
		end

		if #player.GetHumans() == 0 then
			RunConsoleCommand("changelevel", map)
		else
			timer.Create("SAM.Command.Map", 20, 1, function()
				RunConsoleCommand("changelevel", map)
			end)
			AOCRP.Discord:CallMapchange(map, ply:GetSteamName())
			--AOCRP.HUD:CallNotify(player.GetHumans(), "Mapchange in 20 Sekunden", Color(255,0,0), "ACHTUNG")
			AOCRP.HUD:Notification(player.GetHumans(), {title="MAPCHANGE", titlecolor=Color(255,0,0), text="Mapchange in 20 Sekunden",barcolor=Color(255,0,0),sound="everfall/miscellaneous/ux/purchase/lootbox_purchase_01.mp3",delay=20}) 

		end
	end)
:End()

command.new("maprestart")
	:SetPermission("maprestart", "admin")

	:Help("map_restart_help")

	:OnExecute(function(ply)
		if #player.GetHumans() == 0 then
			RunConsoleCommand("changelevel", game.GetMap())
		else
			timer.Create("SAM.Command.MapRestart", 10, 1, function()
				RunConsoleCommand("changelevel", game.GetMap())
			end)

			sam.player.send_message(nil, "map_restart", {
				A = ply
			})
		end
	end)
:End()

command.new("mapreset")
	:SetPermission("mapreset", "admin")

	:Help("mapreset_help")

	:OnExecute(function(ply)
		game.CleanUpMap(false, nil, function() end)

		sam.player.send_message(nil, "mapreset", {
			A = ply
		})
	end)
:End()

command.new("kick")
	:SetPermission("kick", "admin")

	:AddArg("player", {single_target = true})
	:AddArg("text", {hint = "reason", optional = true, default = sam.language.get("default_reason")})

	:GetRestArgs()

	:Help("kick_help")

	:OnExecute(function(ply, targets, reason)
		local target = targets[1]
		target:Kick(reason)

		sam.player.send_message(nil, "kick", {
			A = ply, T = target:Name(), V = reason
		})
	end)
:End()

command.new("ban")
	:SetPermission("ban", "admin")

	:AddArg("player", {single_target = true})
	:AddArg("length", {optional = true, default = 0})
	:AddArg("text", {hint = "reason", optional = true, default = sam.language.get("default_reason")})

	:GetRestArgs()

	:Help("ban_help")

	:OnExecute(function(ply, targets, length, reason)
		local target = targets[1]
		if ply:GetBanLimit() ~= 0 then
			if length == 0 then
				length = ply:GetBanLimit()
			else
				length = math.Clamp(length, 1, ply:GetBanLimit())
			end
		end
		target:sam_ban(length, reason, ply:SteamID())

		sam.player.send_message(nil, "ban", {
			A = ply, T = target:Name(), V = sam.format_length(length), V_2 = reason
		})
	end)
:End()

command.new("banid")
	:SetPermission("banid", "admin")

	:AddArg("steamid")
	:AddArg("length", {optional = true, default = 0})
	:AddArg("text", {hint = "reason", optional = true, default = sam.language.get("default_reason")})

	:GetRestArgs()

	:Help("banid_help")

	:OnExecute(function(ply, promise, length, reason)
		local a_steamid, a_name, a_ban_limit = ply:SteamID(), ply:Name(), ply:GetBanLimit()

		promise:done(function(data)
			local steamid, target = data[1], data[2]

			if a_ban_limit ~= 0 then
				if length == 0 then
					length = a_ban_limit
				else
					length = math.Clamp(length, 1, a_ban_limit)
				end
			end

			if target then
				target:sam_ban(length, reason, a_steamid)

				sam.player.send_message(nil, "ban", {
					A = a_name, T = target:Name(), V = sam.format_length(length), V_2 = reason
				})
			else
				sam.player.ban_id(steamid, length, reason, a_steamid)

				sam.player.send_message(nil, "banid", {
					A = a_name, T = steamid, V = sam.format_length(length), V_2 = reason
				})
			end
		end)
	end)
:End()

command.new("unban")
	:SetPermission("unban", "admin")

	:AddArg("steamid", {allow_higher_target = true})

	:Help("unban_help")

	:OnExecute(function(ply, steamid, reason)
		sam.player.unban(steamid, ply:SteamID())

		sam.player.send_message(nil, "unban", {
			A = ply, T = steamid
		})
	end)
:End()

do
	command.new("noclip")
		:SetPermission("noclip", "admin")

		:AddArg("player", {optional = true})

		:Help("noclip_help")

		:OnExecute(function(ply, targets)
			local id
			for i = 1, #targets do
				local v = targets[i]
				v:SetMoveType(v:GetMoveType() == MOVETYPE_WALK and MOVETYPE_NOCLIP or MOVETYPE_WALK)
				if v == ply then
					id = i
				end
			end

			if id then
				table.remove(targets, id)
				if #targets == 0 then return end
			end

			sam.player.send_message(nil, "noclip", {
				A = ply, T = targets
			})
		end)
	:End()

	sam.permissions.add("can_noclip", nil, "admin")

	hook.Add("PlayerNoClip", "SAM.CanNoClip", function(ply)
		if ply:HasPermission("can_noclip") then
			return true
		end
	end)
end

do
	local config = sam.config

	sam.permissions.add("can_physgun_players", nil, "admin")

	if CLIENT then
		local add_setting = function(body, title, key)
			local setting = body:Add("SAM.LabelPanel")
			setting:Dock(TOP)
			setting:SetLabel(title)

			local enable = setting:Add("SAM.ToggleButton")
			enable:SetConfig(key, true)

			return setting
		end

		config.add_menu_setting("Physgun", function(body)
			local setting_body

			do
				local p = add_setting(body, "Physgun (Enable/Disable all physgun features except picking up players)", "Physgun.Enabled")
				p:DockMargin(8, 6, 8, 0)
			end

			setting_body = body:Add("Panel")
			setting_body:Dock(TOP)
			setting_body:DockMargin(8, 6, 8, 0)
			setting_body:DockPadding(8, 0, 8, 0)

			add_setting(setting_body, "No fall damage on drop", "Physgun.NoFallDamageOnDrop")
			add_setting(setting_body, "Right click to freeze players", "Physgun.RightClickToFreeze")
			add_setting(setting_body, "Reset Velocity to fix some issues when players fall", "Physgun.ResetVelocity")

			function setting_body:PerformLayout()
				setting_body:SizeToChildren(false, true)
			end
		end)
	end

	local freeze_player = function(ply)
		if SERVER then
			ply:Lock()
		end
		ply:SetMoveType(MOVETYPE_NONE)
		ply:SetCollisionGroup(COLLISION_GROUP_WORLD)
	end

	sam.hook_first("PhysgunPickup", "SAM.CanPhysgunPlayer", function(ply, target)
		if sam.type(target) == "Player" and ply:HasPermission("can_physgun_players") and ply:CanTarget(target) then
			freeze_player(target)
			return true
		end
	end)

	local load_phygun_settings = function()
		hook.Remove("PhysgunDrop", "SAM.PhysgunDrop")
		hook.Remove("OnPlayerHitGround", "SAM.PhysgunDropOnPlayerHitGround")

		if config.get("Physgun.Enabled", true) == false then
			-- add a hook to unlock the player if the physgun is disabled and other stuff
			hook.Add("PhysgunDrop", "SAM.PhysgunDrop", function(ply, target)
				if sam.type(target) == "Player" then
					target:SetMoveType(MOVETYPE_WALK)
					target:SetCollisionGroup(COLLISION_GROUP_PLAYER)

					if SERVER then
						target:UnLock()
						if target.sam_has_god_mode then
							target:GodEnable()
						end
					end
				end
			end)
			return
		end

		local right_click_to_freeze = config.get("Physgun.RightClickToFreeze", true)
		local reset_velocity = config.get("Physgun.ResetVelocity", true)
		hook.Add("PhysgunDrop", "SAM.PhysgunDrop", function(ply, target)
			if sam.type(target) ~= "Player" then return end

			if right_click_to_freeze and ply:KeyPressed(IN_ATTACK2) then
				freeze_player(target)

				if SERVER then
					target:sam_set_nwvar("frozen", true)
					target:sam_set_exclusive("frozen")
				end
			else
				if reset_velocity then
					target:SetLocalVelocity(Vector(0, 0, 0))
				end

				if SERVER then
					target:UnLock()
					target:sam_set_nwvar("frozen", false)
					target:sam_set_exclusive(nil)

					if target.sam_has_god_mode then
						target:GodEnable()
					end

					target.sam_physgun_drop_was_frozen = not target:IsOnGround()
				end

				target:SetMoveType(MOVETYPE_WALK)
				target:SetCollisionGroup(COLLISION_GROUP_PLAYER)
			end
		end)

		if config.get("Physgun.NoFallDamageOnDrop", true) then
			hook.Add("OnPlayerHitGround", "SAM.PhysgunDropOnPlayerHitGround", function(ply)
				if ply.sam_physgun_drop_was_frozen then
					ply.sam_physgun_drop_was_frozen = false
					return true
				end
			end)
		end
	end

	config.hook({"Physgun.Enabled", "Physgun.RightClickToFreeze", "Physgun.ResetVelocity", "Physgun.NoFallDamageOnDrop"}, load_phygun_settings)
end

do
	command.new("cleardecals")
		:SetPermission("cleardecals", "admin")
		:Help("cleardecals_help")

		:OnExecute(function(ply)
			sam.netstream.Start(nil, "cleardecals")

			sam.player.send_message(nil, "cleardecals", {
				A = ply
			})
		end)
	:End()

	if CLIENT then
		sam.netstream.Hook("cleardecals", function()
			game.RemoveRagdolls()
			RunConsoleCommand("r_cleardecals")
		end)
	end
end

do
	command.new("stopsound")
		:SetPermission("stopsound", "admin")
		:Help("stopsound_help")

		:OnExecute(function(ply)
			sam.netstream.Start(nil, "stopsound")

			sam.player.send_message(nil, "stopsound", {
				A = ply
			})
		end)
	:End()

	if CLIENT then
		sam.netstream.Hook("stopsound", function()
			RunConsoleCommand("stopsound")
		end)
	end
end

command.new("exit")
	:SetPermission("exit_vehicle", "admin")

	:AddArg("player", {single_target = true})

	:Help("exit_vehicle_help")

	:OnExecute(function(ply, targets)
		local target = targets[1]

		if not target:InVehicle() then
			if ply == target then
				return ply:sam_send_message("not_in_vehicle")
			else
				return ply:sam_send_message("not_in_vehicle2", {
					S = target:Name()
				})
			end
		end

		target:ExitVehicle()

		sam.player.send_message(nil, "exit_vehicle", {
			A = ply, T = targets
		})
	end)
:End()

command.new("time")
	:SetPermission("time", "user")

	:AddArg("player", {single_target = true, optional = true})

	:Help("time_help")

	:OnExecute(function(ply, targets)
		if ply == targets[1] then
			sam.player.send_message(ply, "time_your", {
				V = sam.reverse_parse_length(targets[1]:sam_get_play_time() / 60)
			})
		else
			sam.player.send_message(ply, "time_player", {
				T = targets, V = sam.reverse_parse_length(targets[1]:sam_get_play_time() / 60)
			})
		end
	end)
:End()

command.new("admin")
	:SetPermission("admin_mode", "admin")

	:Help("admin_help")

	:OnExecute(function(ply)
		if ply.AdminMode then
			ply.AdminMode = false
			ply:sam_uncloak()
			ply:GodDisable()
			ply:SetMoveType(MOVETYPE_WALK)
            ply:SetSolid(SOLID_BBOX)
			ply:SetNoTarget(false)
            AOCRP.HUD:Notify(ply, "Du hast den Admin-Modus deaktiviert", 2)
			ply:SetNWString("CustomRedTitle", "")
		else
			ply.AdminMode = true
			ply:sam_cloak()
			ply:GodEnable()
			ply:SetMoveType(MOVETYPE_NOCLIP)
            ply:SetSolid(SOLID_NONE)
			ply:SetNoTarget(true)
			ply:Give("weapon_physgun")
			ply:Give("gmod_tool")
            AOCRP.HUD:Notify(ply, "Du hast den Admin-Modus aktiviert", 1)
		end
	end)
:End()

command.new("unadmin")
	:SetPermission("admin_mode", "admin")

	:Help("unadmin_help")

	:OnExecute(function(ply)
		ply:sam_uncloak()
		ply:GodDisable()
		ply:SetMoveType(MOVETYPE_WALK)
	end)
:End()

do
	command.new("buddha")
		:SetPermission("buddha", "admin")

		:AddArg("player", {optional = true})

		:Help("buddha_help")

		:OnExecute(function(ply, targets)
			for i = 1, #targets do
				targets[i].sam_buddha = true
			end

			sam.player.send_message(nil, "buddha", {
				A = ply, T = targets
			})
		end)
	:End()

	command.new("unbuddha")
		:SetPermission("buddha", "admin")

		:AddArg("player", {optional = true})

		:Help("unbuddha_help")

		:OnExecute(function(ply, targets)
			for i = 1, #targets do
				targets[i].sam_buddha = nil
			end

			sam.player.send_message(nil, "unbuddha", {
				A = ply, T = targets
			})
		end)
	:End()

	if SERVER then
		hook.Add("EntityTakeDamage", "SAM.BuddhaMode", function(ply, info)
			if ply.sam_buddha and ply:Health() - info:GetDamage() <= 0 then
				ply:SetHealth(10000)
				return true
			end
		end)
	end
end

command.new("give")
	:SetPermission("give", "superadmin")

	:AddArg("player")
	:AddArg("text", {hint = "weapon/entity"})

	:Help("give_help")

	:OnExecute(function(ply, targets, weapon)
		for i = 1, #targets do
			targets[i]:Give(weapon)
		end

		sam.player.send_message(nil, "give", {
			A = ply, T = targets, V = weapon
		})
	end)
:End()

-- do
-- 	if CLIENT then
-- 		sam.netstream.Hook("GetFriends", function()
-- 			local friends = {}
-- 			local humans = player.GetHumans()
-- 			for i = 1, #humans do
-- 				local human = humans[i]
-- 				if human:GetFriendStatus() == "friend" then
-- 					table.insert(friends, human)
-- 				end
-- 			end
-- 			netstream.Start("GetFriends", friends)
-- 		end)
-- 	else
-- 		hook.Add("SAM.AuthedPlayer", "GetPlayerFriends", function(ply)
-- 			timer.Simple(0, function()
-- 				ply.sam_requesting_friends = true
-- 				netstream.Start(ply, "GetFriends")
-- 			end)
-- 		end)

-- 		local invalid_friends = function(ply, friends, new_list)
-- 			if not sam.istable(friends) then return true end

-- 			local count = #friends
-- 			local max_players = game.MaxPlayers()
-- 			for k, friend in pairs(friends) do
-- 				if not sam.isnumber(k) then return true end
-- 				if not sam.isentity(friend) then return true end
-- 				if k > max_players then return true end
-- 				if k > count then return true end

-- 				if IsValid(friend) then
-- 					table.insert(new_list, friend)
-- 				end
-- 			end
-- 		end

-- 		sam.netstream.Hook("GetFriends", function(ply, friends)
-- 			local new_list = {}
-- 			if invalid_friends(ply, friends, new_list) then
-- 				ply.sam_friends_invalid = true
-- 				return
-- 			end
-- 			ply.sam_friends = new_list
-- 		end, function()
-- 			return ply.sam_requesting_friends
-- 		end)
-- 	end

-- 	command.new("friends")
-- 		:SetPermission("friends", "superadmin")

-- 		:AddArg("player", {single_target = true})

-- 		:Help(language.get("friends_help"))

-- 		:OnExecute(function(ply, targets)
-- 			local target = targets[1]
-- 			target.sam_friends_requests = target.sam_friends_requests or {}
-- 			target.sam_friends_requests[ply] = true
-- 		end)
-- 	:End()
-- end

--addons/admin_sam/lua/sam/modules/vote.lua:
if SAM_LOADED then return end

-- DONT EVER TALK TO ME ABOUT THIS CODE

local sam, command = sam, sam.command

command.set_category("Voting")

local start_vote, end_vote
if SERVER then
	local vote_on = false
	local options, players_voted

	local shuffle = function(tbl) -- https://gist.github.com/Uradamus/10323382
		for i = #tbl, 2, -1 do
			local j = math.random(i)
			tbl[i], tbl[j] = tbl[j], tbl[i]
		end
		return tbl
	end

	end_vote = function(ply, callback)
		if not vote_on then
			return ply:sam_add_text(color_white, "There is no vote to end.")
		end

		vote_on = false

		sam.set_global("Vote", nil)

		if callback then
			local tbl = {}
			local total_count = 0

			for i = 1, #options do
				local count = sam.get_global("Votings" .. i)
				total_count = total_count + count
				table.insert(tbl, {i, count})
				sam.set_global("Votings" .. i, nil)
			end

			if total_count == 0 then
				return sam.player.add_text(nil, color_white, "The vote have been canceled because nobody voted.")
			end

			table.sort(shuffle(tbl), function(a,b) return a[2] > b[2] end)

			local v = tbl[1]
			local winner, count = v[1], v[2]

			callback(winner, options[winner], count, total_count)
		else
			for i = 1, #options do
				sam.set_global("Votings" .. i, nil)
			end
		end

		options, players_voted = nil, nil

		timer.Remove("SAM.Vote")
	end

	start_vote = function(ply, callback, title, ...)
		if vote_on then
			return ply:sam_add_text(color_white, "There is an active vote, wait for it to finish.")
		end

		vote_on = true

		options, players_voted = {}, {}

		local args, n = {...}, select("#", ...)
		for i = 1, n do
			local v = args[i]
			if v then
				table.insert(options, v)
			end
		end

		sam.set_global("Vote", {title, options, CurTime()})

		for k in ipairs(options) do
			sam.set_global("Votings" .. k, 0)
		end

		timer.Create("SAM.Vote", 25, 1, function()
			end_vote(ply, callback)
		end)

		return true
	end

	sam.netstream.Hook("Vote", function(ply, index)
		if not sam.isnumber(index) or index > 5 then return end

		local votings = sam.get_global("Votings" .. index)
		if not votings then return end

		local old_index = players_voted[ply:AccountID()]
		if old_index == index then return end

		if old_index then
			sam.set_global("Votings" .. old_index, sam.get_global("Votings" .. old_index) - 1)
		end

		sam.set_global("Votings" .. index, votings + 1)

		players_voted[ply:AccountID()] = index
	end)
end

if CLIENT then
	local SUI = sam.SUI
	-- https://github.com/Facepunch/garrysmod/blob/master/garrysmod/lua/includes/extensions/client/player.lua

	local VOTING_TITLE = SUI.CreateFont("VotingTitle", "Roboto Bold", 15)
	local VOTING_OPTION = SUI.CreateFont("VotingTitle", "Roboto Medium", 14)

	local bind_translation = {}
	for i = 0, 9 do
		bind_translation["slot" .. i] = i
	end

	local voting_frame

	end_vote = function()
		if IsValid(voting_frame) then
			voting_frame:Remove()
		end
		hook.Remove("PlayerBindPress", "SAM.Voting")
		hook.Remove("SAM.ChangedGlobalVar", "SAM.VotingCount")
	end

	hook.Add("SAM.ChangedGlobalVar", "Voting", function(key, value)
		if key ~= "Vote" then return end

		if not value then
			end_vote()
			return
		end

		local title, options, start_time = value[1], value[2], value[3]

		sui.TDLib.Start()

		voting_frame = vgui.Create("EditablePanel")
		voting_frame:SetSize(SUI.Scale(165), SUI.Scale(230))
		voting_frame:SetPos(5, ScrH() * 0.25)
		voting_frame:DockPadding(4, 4, 4, 4)
		voting_frame:Blur()
			:Background(Color(30, 30, 30, 240))

		local voting_title = voting_frame:Add("SAM.Label")
		voting_title:Dock(TOP)
		voting_title:SetFont(VOTING_TITLE)
		voting_title:TextColor(Color(220, 220, 220))
		voting_title:SetText(title)
		voting_title:SetWrap(true)
		voting_title:SetAutoStretchVertical(true)

		local line = voting_frame:Add("SAM.Label")
		line:Dock(TOP)
		line:TextColor(Color(220, 220, 220))
		line:SetText("-")

		local options_added = {}
		for i, v in ipairs(options) do
			local option = voting_frame:Add("SAM.Label")
			option:Dock(TOP)
			option:SetFont(VOTING_OPTION)
			option:TextColor(Color(220, 220, 220), true)
			option:SetText(i .. ". " .. v .. " (0)")
			option:SetWrap(true)
			option:SetAutoStretchVertical(true)

			options_added[i] = option
		end

		function voting_frame:Think() -- fucking gmod
			self:SizeToChildren(false, true)

			local time_left = math.floor(25 - (CurTime() - start_time))
			if time_left <= 0 then
				end_vote()
				voting_frame.Think = nil
				return
			end

			voting_title:SetText(title .. " (" .. time_left .. ")")
		end

		line = voting_frame:Add("SAM.Label")
		line:Dock(TOP)
		line:TextColor(Color(220, 220, 220))
		line:SetText("-")

		local option = voting_frame:Add("SAM.Label")
		option:Dock(TOP)
		option:SetFont(VOTING_OPTION)
		option:TextColor(Color(220, 220, 220), true)
		option:SetText("0. Close")
		option:SetWrap(true)
		option:SetAutoStretchVertical(true)

		sui.TDLib.End()

		local current_index
		hook.Add("PlayerBindPress", "SAM.Voting", function(_, bind, down)
			if not down then return end

			local index = bind_translation[bind]
			if not index then return end

			if index == 0 then
				end_vote()
				return true
			end

			if not options[index] then return true end

			if current_index then
				options_added[current_index]:TextColor(Color(220, 220, 220), true)
			end

			options_added[index]:TextColor(Color(65, 185, 255), true)
			current_index = index

			sam.netstream.Start("Vote", index)

			return true
		end)

		hook.Add("SAM.ChangedGlobalVar", "SAM.VotingCount", function(key2, count)
			if key2:sub(1, 7) ~= "Votings" then return end
			if not count then return end

			local index = tonumber(key2:sub(8))
			options_added[index]:SetText(index .. ". " .. options[index] .. " (" .. count .. ")")
		end)
	end)
end

local vote_check = function(str)
	return str:match("%S") ~= nil
end

command.new("vote")
	:SetPermission("vote", "admin")

	:AddArg("text", {hint = "title", check = vote_check})
	:AddArg("text", {hint = "option", check = vote_check})
	:AddArg("text", {hint = "option", check = vote_check})
	:AddArg("text", {hint = "option", optional = true, check = vote_check})
	:AddArg("text", {hint = "option", optional = true, check = vote_check})
	:AddArg("text", {hint = "option", optional = true, check = vote_check})

	:Help("Start a vote!")

	:OnExecute(function(ply, title, ...)
		local callback = function(_, option, count, total_count)
			sam.player.send_message(nil, "Vote {V} for {V_2} has been passed. ({V_3}/{V_4})", {
				V = title, V_2 = option, V_3 = count, V_4 = total_count
			})
		end

		if start_vote(ply, callback, title, ...) then
			sam.player.send_message(nil, "{A} started a vote with title {V}.", {
				A = ply, V = title
			})
		end
	end)
:End()

command.new("endvote")
	:SetPermission("endvote", "admin")

	:Help("End current vote.")

	:OnExecute(function(ply)
		end_vote(ply)
	end)
:End()

command.new("votekick")
	:SetPermission("votekick", "admin")

	:AddArg("player", {single_target = true})
	:AddArg("text", {hint = "reason", optional = true})

	:GetRestArgs()

	:Help("Start a vote to kick a player.")

	:OnExecute(function(ply, targets, reason)
		local target = targets[1]
		local target_name = target:Name()

		local callback = function(index, option, count, total_count)
			if not IsValid(ply) then
				sam.player.send_message(nil, "Vote was canceled because {T} left.", {
					T = target_name
				})
				return
			end

			if index == 1 then
				target:Kick("Vote was successful (" .. (reason or "none") .. ")")

				sam.player.send_message(nil, "Vote was successful, {T} has been kicked. ({V})", {
					T = targets, V = reason
				})
			else
				sam.player.send_message(nil, "Vote was unsuccessful, {T} won't be kicked.", {
					T = target_name
				})
			end
		end

		local title = "Kick " .. target_name .. "?"
		if reason then
			title = title .. " (" .. reason .. ")"
		end

		if start_vote(ply, callback, title, "Yes", "No") then
			if reason then
				sam.player.send_message(nil, "{A} started a votekick against {T} ({V})", {
					A = ply, T = targets, V = reason
				})
			else
				sam.player.send_message(nil, "{A} started a votekick against {T}", {
					A = ply, T = targets
				})
			end
		end
	end)
:End()

command.new("voteban")
	:SetPermission("voteban", "admin")

	:AddArg("player", {single_target = true})
	:AddArg("length", {optional = true, default = 60, min = 30, max = 120})
	:AddArg("text", {hint = "reason", optional = true})

	:GetRestArgs()

	:Help("Start a vote to ban a player.")

	:OnExecute(function(ply, targets, length, reason)
		local target = targets[1]
		local target_steamid, target_name = target:SteamID(), target:Name()
		local ply_steamid = ply:SteamID()

		local callback = function(index, option, count, total_count)
			if index == 1 then
				sam.player.ban_id(target_steamid, length, "Vote was successful (" .. (reason or "none") .. ")", ply_steamid)

				sam.player.send_message(nil, "Vote was successful, {T} has been banned. ({V})", {
					T = target_name, V = reason
				})
			else
				sam.player.send_message(nil, "Vote was unsuccessful, {T} won't be banned.", {
					T = target_name
				})
			end
		end

		local title = "Ban " .. target_name .. "?"
		if reason then
			title = title .. " (" .. reason .. ")"
		end

		if start_vote(ply, callback, title, "Yes", "No") then
			if reason then
				sam.player.send_message(nil, "{A} started a voteban against {T} for {V} ({V_2})", {
					A = ply, T = targets, V = sam.format_length(length), V_2 = reason
				})
			else
				sam.player.send_message(nil, "{A} started a voteban against {T} for {V}", {
					A = ply, T = targets, V = sam.format_length(length)
				})
			end
		end
	end)
:End()

command.new("votemute")
	:SetPermission("votemute", "admin")

	:AddArg("player", {single_target = true})
	:AddArg("text", {hint = "reason", optional = true})

	:GetRestArgs()

	:Help("Start a vote to mute and gag a player.")

	:OnExecute(function(ply, targets, reason)
		local _reason = reason and (" (" .. reason .. ")") or ""

		local target = targets[1]
		local target_name = target:Name()

		local callback = function(index, option, count, total_count)
			if not IsValid(target) then
				sam.player.send_message(nil, "Vote was canceled because {T} left.", {
					T = target_name
				})
				return
			end

			if index == 1 then
				RunConsoleCommand("sam", "mute", "#" .. target:EntIndex(), 0, "votemute" .. _reason)
				RunConsoleCommand("sam", "gag", "#" .. target:EntIndex(), 0, "votemute" .. _reason)

				sam.player.send_message(nil, "Vote was successful, {T} has been muted. ({V})", {
					T = target_name, V = reason
				})
			else
				sam.player.send_message(nil, "Vote was unsuccessful, {T} won't be muted.", {
					T = target_name
				})
			end
		end

		local title = "Mute " .. target_name .. "?" .. _reason
		if start_vote(ply, callback, title, "Yes", "No") then
			if reason then
				sam.player.send_message(nil, "{A} started a votemute against {T} ({V}).", {
					A = ply, T = targets, V = reason
				})
			else
				sam.player.send_message(nil, "{A} started a votemute against {T}.", {
					A = ply, T = targets
				})
			end
		end
	end)
:End()

command.new("votemap")
	:SetPermission("votemap", "admin")

	:AddArg("map", {exclude_current = true})
	:AddArg("map", {optional =  true, exclude_current = true})
	:AddArg("map", {optional =  true, exclude_current = true})

	:GetRestArgs()

	:Help("Start a vote to change map.")

	:OnExecute(function(ply, ...)
		local callback = function(_, option, count, total_count)
			sam.player.send_message(nil, "Map vote for {V} has been passed. ({V_2}/{V_3})", {
				V = option, V_2 = count, V_3 = total_count
			})

			if sam.is_valid_map(option) then
				RunConsoleCommand("sam", "map", option)
			end
		end

		local args = {...}
		for i = select("#", ...), 1, -1 do
			if args[i] == "None" then
				args[i] = nil
			end
		end
		table.insert(args, "Extend Current Map")

		if start_vote(ply, callback, "Vote for the next map!", unpack(args)) then
			sam.player.send_message(nil, "{A} started a map change vote.", {
				A = ply
			})
		end
	end)
:End()
--addons/admin_sam/lua/sam/cl_adverts.lua:
if SAM_LOADED then return end

local sam = sam
local config = sam.config

local times = {}

local entry_OnValueChange = function(s)
	s:SetTall(s:GetNumLines() * (sam.SUI.Scale(16) --[[font size]] + 1) + 1 + 2)
end

local entry_OnEnter = function(s)
	local ads = config.get("Adverts")
	local txt = s:GetText()
	if txt == "" then
		s:Remove()
		if s.i then
			table.remove(ads, s.i)
		end
	else
		if txt == s.ad then return end
		ads[s.i] = txt
		s.ad = txt
	end
	config.set("Adverts", ads, true)
end

local entry_OnKeyCodeTyped = function(s, code)
	if code == KEY_ENTER then
		s:old_OnKeyCodeTyped(code)
		return true
	else
		return s:old_OnKeyCodeTyped(code)
	end
end

config.add_menu_setting("Adverts", function(body)
	local adverts_body

	local adverts = body:Add("SAM.LabelPanel")
	adverts:Dock(TOP)
	adverts:DockMargin(8, 6, 8, 0)
	adverts:SetLabel("Adverts\n- Random adverts print every 60 seconds\n- Timed adverts can be done like this: {1m} This advert prints every 1 minute")

	local add_advert = adverts:Add("SAM.Button")
	add_advert:SetText("+")
	add_advert:SetSize(25, 25)

	local zpos = 0
	local add_func = function(ad, ad_i)
		zpos = zpos + 1

		local entry = adverts_body:Add("SAM.TextEntry")
		entry:SetPlaceholder("")
		entry:SetMultiline(true)
		entry:SetNoBar(true)
		entry:Dock(TOP)
		entry:DockMargin(8, 6, 8, 0)
		entry:SetZPos(zpos)
		entry.ad = ad
		entry.no_scale = true

		if not sam.ispanel(ad) then
			entry.i = ad_i
			entry:SetValue(ad)
		else
			entry.i = #config.get("Adverts") + 1
		end

		entry.OnValueChange = entry_OnValueChange
		entry.OnEnter = entry_OnEnter
		entry.old_OnKeyCodeTyped = entry.OnKeyCodeTyped
		entry.OnKeyCodeTyped = entry_OnKeyCodeTyped
	end
	add_advert:On("DoClick", add_func)

	adverts_body = body:Add("Panel")
	adverts_body:Dock(TOP)

	function adverts_body:PerformLayout(w, h)
		for k, v in ipairs(self:GetChildren()) do
			entry_OnValueChange(v)
		end
		self:SizeToChildren(false, true)
	end

	sam.config.hook({"Adverts"}, function()
		if not IsValid(adverts_body) then return end
		adverts_body:Clear()

		for k, v in ipairs(config.get("Adverts")) do
			add_func(v, k)
		end
	end)
end)

local random = {}

timer.Create("SAM.Advert.RandomAdverts", 60, 0, function()
	local ad = random[math.random(1, #random)]
	if not ad then return end
	sam.player.send_message(nil, ad)
end)

sam.config.hook({"Adverts"}, function()
	for i = #times, 1, -1 do
		times[i] = nil
		timer.Remove("SAM.Adverts." .. i)
	end

	random = {}
	for k, v in ipairs(config.get("Adverts")) do
		if v:sub(1, 1) == "{" then
			local time, message = v:match("(%b{}) *(.*)")
			time = sam.parse_length(time)
			if time then
				timer.Create("SAM.Adverts." .. table.insert(times, true), time * 60, 0, function()
					sam.player.send_message(nil, message)
				end)
			else
				table.insert(random, v)
			end
		else
			table.insert(random, v)
		end
	end
end)

--addons/aoc_nextbots/lua/autorun/sh_nextbots_init.lua:
AOCRPNextbots = {}

local rootDir = "summe_nextbots"

local function AddFile(File, dir)
    local fileSide = string.lower(string.Left(File, 3))

    if SERVER and fileSide == "sv_" then
        include(dir .. File)
    elseif fileSide == "sh_" then
        if SERVER then
            AddCSLuaFile(dir .. File)
        end

        include(dir .. File)
    elseif fileSide == "cl_" then
        if SERVER then
            AddCSLuaFile(dir .. File)
        elseif CLIENT then
            include(dir .. File)
        end
    end
end

local function IncludeDir(dir)
    dir = dir .. "/"
    local File, Directory = file.Find(dir .. "*", "LUA")

    for k, v in ipairs(File) do
        if string.EndsWith(v, ".lua") then
            AddFile(v, dir)
        end
    end

    for k, v in ipairs(Directory) do
        IncludeDir(dir .. v)
    end

    hook.Run("AOCRPNextbots.Loaded")
end

IncludeDir(rootDir)
--addons/aocrp_pixelui/lua/pixelui/sh_config.lua:

--[[
PIXEL UI
Copyright (C) 2021 Tom O'Sullivan (Tom.bat)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
]]

--[[
    Should we override the default derma popups for the PIXEL UI reskins?
    0 = No - forced off.
    1 = No - but users can opt in via convar (pixel_ui_override_popups).
    2 = Yes - but users can opt out via convar.
    3 = Yes - forced on.
]]
PIXEL.OverrideDermaMenus = 0

--[[
    The Imgur ID of the progress image you want to appear when Imgur content is loading.
]]
PIXEL.ProgressImageID = "635PPvg"

--[[
    Colour definitions.
]]
PIXEL.Colors = {
    Background = Color(22, 22, 22),
    Header = Color(28, 28, 28),
    Scroller = Color(61, 61, 61),

    PrimaryText = Color(255, 255, 255),
    SecondaryText = Color(220, 220, 220),
    DisabledText = Color(40, 40, 40),

    Primary = Color(47, 128, 200),
    Disabled = Color(180, 180, 180),
    Positive = Color(66, 134, 50),
    Negative = Color(164, 50, 50),

    Gold = Color(214, 174, 34),
    Silver = Color(192, 192, 192),
    Bronze = Color(145, 94, 49),

    Transparent = Color(0, 0, 0, 0)
}

--addons/aocrp_pixelui/lua/pixelui/drawing/cl_outlined_box.lua:

--[[
PIXEL UI
Copyright (C) 2021 Tom O'Sullivan (Tom.bat)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
]]

local setDrawColor = surface.SetDrawColor
local drawOutlinedRect = surface.DrawOutlinedRect

function PIXEL.DrawOutlinedBox(x, y, w, h, thickness, col)
    setDrawColor(col.r, col.g, col.b, col.a)
    for i = 0, thickness - 1 do
        drawOutlinedRect(x + i, y + i, w - i * 2, h - i * 2)
    end
end

local ipairs = ipairs
local setTexture = surface.SetTexture
local drawPoly = surface.DrawPoly
local drawRect = surface.DrawRect

local roundedBoxCache = {}
local whiteTexture = surface.GetTextureID("vgui/white")

function PIXEL.DrawOutlinedRoundedBox(borderSize, x, y, w, h, col, thickness)
    thickness = thickness or 1

    setDrawColor(col.r, col.g, col.b, col.a)

    if borderSize <= 0 then
        PIXEL.DrawOutlinedBox(x, y, w, h, thickness, col)
        return
    end

    local fullRight = x + w
    local fullBottom = y + h

    local left, right = x + borderSize, fullRight - borderSize
    local top, bottom = y + borderSize, fullBottom - borderSize

    local halfBorder = borderSize * .6

    local width, height = w - borderSize * 2, h - borderSize * 2

    drawRect(x, top, thickness, height) --Left
    drawRect(x + w - thickness, top, thickness, height) --Right
    drawRect(left, y, width, thickness) --Top
    drawRect(left, y + h - thickness, width, thickness) --Bottom

    local cacheName = borderSize .. x .. y .. w .. h .. thickness
    local cache = roundedBoxCache[cacheName]
    if not cache then
        cache = {
            { --Top Right
                {x = right, y = y}, --Outer
                {x = right + halfBorder, y = top - halfBorder},
                {x = fullRight, y = top},

                {x = fullRight - thickness, y = top}, --Inner
                {x = right + halfBorder - thickness, y = top - halfBorder + thickness},
                {x = right, y = y + thickness}
            },
            { --Bottom Right
                {x = fullRight, y = bottom}, --Outer
                {x = right + halfBorder, y = bottom + halfBorder},
                {x = right, y = fullBottom},

                {x = right, y = fullBottom - thickness}, --Inner
                {x = right + halfBorder - thickness, y = bottom + halfBorder - thickness},
                {x = fullRight - thickness, y = bottom}
            },
            { --Bottom Left
                {x = left, y = fullBottom}, --Outer
                {x = left - halfBorder, y = bottom + halfBorder},
                {x = x, y = bottom},

                {x = x + thickness, y = bottom}, --Inner
                {x = left - halfBorder + thickness, y = bottom + halfBorder - thickness},
                {x = left, y = fullBottom - thickness},
            },
            { --Top Left
                {x = x, y = top}, --Outer
                {x = left - halfBorder, y = top - halfBorder},
                {x = left, y = y},

                {x = left, y = y + thickness}, --Inner
                {x = left - halfBorder + thickness, y = top - halfBorder + thickness},
                {x = x + thickness, y = top}
            }
        }

        roundedBoxCache[cacheName] = cache
    end

    setTexture(whiteTexture)

    for k,v in ipairs(cache) do
        drawPoly(v)
    end
end
--addons/aocrp_pixelui/lua/pixelui/elements/cl_category.lua:

--[[
PIXEL UI
Copyright (C) 2021 Tom O'Sullivan (Tom.bat)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
]]

local PANEL = {}

AccessorFunc(PANEL, "Title", "Title", FORCE_STRING)

PIXEL.RegisterFont("UI.CategoryHeader", "Open Sans Bold", 19)

function PANEL:Init()
    self.ArrowRotation = 0

    self.BackgroundCol = PIXEL.OffsetColor(PIXEL.Colors.Background, 6)
end

function PANEL:DoClick()
    self:GetParent():Toggle()
end

local lerp = Lerp
function PANEL:Paint(w, h)
    PIXEL.DrawRoundedBox(PIXEL.Scale(4), 0, 0, w, h, self.BackgroundCol)
    PIXEL.DrawSimpleText(self.Title, "UI.CategoryHeader", PIXEL.Scale(10), h / 2, PIXEL.Colors.PrimaryText, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)

    self.ArrowRotation = lerp(FrameTime() * 10, self.ArrowRotation, self:GetParent():GetExpanded() and 0 or 90)

    local arrowSize = h * .45
    PIXEL.DrawImgurRotated(w - h * .3 - PIXEL.Scale(4), h / 2, arrowSize, arrowSize, self.ArrowRotation, "30Bvuwi", PIXEL.Colors.PrimaryText)
end

vgui.Register("PIXEL.CategoryHeader", PANEL, "PIXEL.Button")

PANEL = {}

AccessorFunc(PANEL, "m_bSizeExpanded", "Expanded", FORCE_BOOL)
AccessorFunc(PANEL, "m_iContentHeight", "StartHeight")
AccessorFunc(PANEL, "m_fAnimTime", "AnimTime")
AccessorFunc(PANEL, "m_bDrawBackground", "PaintBackground", FORCE_BOOL)
AccessorFunc(PANEL, "m_iPadding", "Padding")
AccessorFunc(PANEL, "m_pList", "List")

function PANEL:Init()
    self.Header = vgui.Create("PIXEL.CategoryHeader", self)

    self:SetTitle("PIXEL Category")

    self:SetExpanded(true)
    self:SetMouseInputEnabled(true)

    self:SetAnimTime(0.2)
    self.SlideAnimation = Derma_Anim("Anim", self, self.AnimSlide)

    self.BackgroundCol = PIXEL.OffsetColor(PIXEL.Colors.Background, 2)
end

function PANEL:UnselectAll()
    local children = self:GetChildren()
    for k, v in pairs(children) do
        if v.SetSelected then
            v:SetSelected(false)
        end
    end
end

function PANEL:Think()
    self.SlideAnimation:Run()
end

function PANEL:SetTitle(title)
    self.Header:SetTitle(title)
end

function PANEL:Paint(w, h)
    PIXEL.DrawRoundedBox(PIXEL.Scale(4), 0, 0, w, h, self.BackgroundCol)
end

function PANEL:SetContents(contents)
    self.Contents = contents
    self.Contents:SetParent(self)
    self.Contents:Dock(FILL)

    local margin = PIXEL.Scale(8)
    self.Contents:DockMargin(margin, margin, margin, margin)

    if not self:GetExpanded() then
        self.OldHeight = self:GetTall()
    elseif self:GetExpanded() and IsValid(self.Contents) and self.Contents:GetTall() < 1 then
        self.Contents:SizeToChildren(false, true)
        self.OldHeight = self.Contents:GetTall()
        self:SetTall(self.OldHeight)
    end

    self:InvalidateLayout(true)
end

function PANEL:SetExpanded(expanded)
    self.m_bSizeExpanded = tobool(expanded)

    if not self:GetExpanded() then
        if not self.SlideAnimation.Finished and self.OldHeight then return end
        self.OldHeight = self:GetTall()
    end
end

function PANEL:Toggle()
    self:SetExpanded(not self:GetExpanded())

    self.SlideAnimation:Start(self:GetAnimTime(), {From = self:GetTall()})

    self:InvalidateLayout(true)

    self:OnToggle(self:GetExpanded())
end

function PANEL:OnToggle(expanded) end

function PANEL:DoExpansion(b)
    if self:GetExpanded() == b then return end
    self:Toggle()
end

function PANEL:LayoutContent(w, h) end

function PANEL:PerformLayout(w, h)
    self.Header:Dock(TOP)
    self.Header:SetTall(PIXEL.Scale(26))

    if IsValid(self.Contents) then
        if self:GetExpanded() then
            self.Contents:InvalidateLayout(true)
            self.Contents:SetVisible(true)
        else
            self.Contents:SetVisible(false)
        end
    end

    if self:GetExpanded() then
        if IsValid(self.Contents) and #self.Contents:GetChildren() > 0 then self.Contents:SizeToChildren(false, true) end
        self:SizeToChildren(false, true)
    else
        if IsValid(self.Contents) and not self.OldHeight then self.OldHeight = self.Contents:GetTall() end
        self:SetTall(self.Header:GetTall())
    end

    self.SlideAnimation:Run()

    self:LayoutContent(w, h)
end

function PANEL:OnMousePressed(mcode)
    if not self:GetParent().OnMousePressed then return end
    return self:GetParent():OnMousePressed(mcode)
end

function PANEL:AnimSlide(anim, delta, data)
    self:InvalidateLayout()
    self:InvalidateParent()

    if anim.Started then
        if not IsValid(self.Contents) and (self.OldHeight or 0) < self.Header:GetTall() then
            self.OldHeight = 0
            for id, pnl in pairs(self:GetChildren()) do
                self.OldHeight = self.OldHeight + pnl:GetTall()
            end
        end

        if self:GetExpanded() then
            data.To = math.max(self.OldHeight, self:GetTall())
        else
            data.To = self:GetTall()
        end
    end

    if IsValid(self.Contents) then self.Contents:SetVisible(true) end

    self:GetParent():InvalidateLayout()
    self:GetParent():GetParent():InvalidateLayout()

    self:SetTall(Lerp(delta, data.From, data.To))
end

vgui.Register("PIXEL.Category", PANEL, "Panel")
--addons/aocrp_pixelui/lua/pixelui/elements/cl_text_entry_internal.lua:

--[[
PIXEL UI
Copyright (C) 2021 Tom O'Sullivan (Tom.bat)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
]]

local PANEL = {}

AccessorFunc(PANEL, "m_bAllowEnter", "EnterAllowed", FORCE_BOOL)
AccessorFunc(PANEL, "m_bUpdateOnType", "UpdateOnType", FORCE_BOOL)
AccessorFunc(PANEL, "m_bNumeric", "Numeric", FORCE_BOOL)
AccessorFunc(PANEL, "m_bHistory", "HistoryEnabled", FORCE_BOOL)
AccessorFunc(PANEL, "m_bDisableTabbing", "TabbingDisabled", FORCE_BOOL)
AccessorFunc(PANEL, "m_txtPlaceholder", "PlaceholderText", FORCE_STRING)

Derma_Install_Convar_Functions(PANEL)

PIXEL.RegisterFont("UI.TextEntry", "Open Sans SemiBold", 18)

function PANEL:Init()
    self:SetHistoryEnabled(false)
    self.History = {}
    self.HistoryPos = 0

    self:SetPaintBorderEnabled(false)
    self:SetPaintBackgroundEnabled(false)

    self:SetEnterAllowed(true)
    self:SetUpdateOnType(false)
    self:SetNumeric(false)
    self:SetAllowNonAsciiCharacters(true)

    self:SetTall(PIXEL.Scale(34))

    self.m_bLoseFocusOnClickAway = true

    self:SetCursor("beam")
    self:SetFontInternal(PIXEL.GetRealFont("UI.TextEntry"))
end

function PANEL:IsEditing()
    return self == vgui.GetKeyboardFocus()
end

function PANEL:OnKeyCodeTyped(code)
    self:OnKeyCode(code)

    if code == KEY_ENTER and not self:IsMultiline() and self:GetEnterAllowed() then
        if IsValid(self.Menu) then self.Menu:Remove() end

        self:FocusNext()
        self:OnEnter()
        self.HistoryPos = 0
    end

    if self.m_bHistory or IsValid(self.Menu) then
        if code == KEY_UP then
            self.HistoryPos = self.HistoryPos - 1
            self:UpdateFromHistory()
        end

        if code == KEY_DOWN or code == KEY_TAB then
            self.HistoryPos = self.HistoryPos + 1
            self:UpdateFromHistory()
        end
    end
end

function PANEL:OnKeyCode(code)
    local parent = self:GetParent()
    if not parent then return end

    if parent.OnKeyCode then parent:OnKeyCode() end
end

function PANEL:UpdateFromHistory()
    if IsValid(self.Menu) then return self:UpdateFromMenu() end
    local pos = self.HistoryPos

    if pos < 0 then
        pos = #self.History
    end

    if pos > #self.History then
        pos = 0
    end

    local text = self.History[pos]
    if not text then
        text = ""
    end

    self:SetText(text)
    self:SetCaretPos(text:len())
    self:OnTextChanged()
    self.HistoryPos = pos
end

function PANEL:UpdateFromMenu()
    local pos = self.HistoryPos
    local num = self.Menu:ChildCount()
    self.Menu:ClearHighlights()

    if pos < 0 then
        pos = num
    end

    if pos > num then
        pos = 0
    end

    local item = self.Menu:GetChild(pos)
    if not item then
        self:SetText("")
        self.HistoryPos = pos
        return
    end

    self.Menu:HighlightItem(item)

    local txt = item:GetText()
    self:SetText(txt)
    self:SetCaretPos(txt:len())
    self:OnTextChanged(true)
    self.HistoryPos = pos
end

function PANEL:OnTextChanged(noMenuRemoval)
    self.HistoryPos = 0

    if self:GetUpdateOnType() then
        self:UpdateConvarValue()
        self:OnValueChange(self:GetText())
    end

    if IsValid(self.Menu) and not noMenuRemoval then
        self.Menu:Remove()
    end

    local tab = self:GetAutoComplete(self:GetText())

    if tab then
        self:OpenAutoComplete(tab)
    end

    self:OnChange()
end

function PANEL:OnChange()
    local parent = self:GetParent()
    if not parent then return end

    if parent.OnChange then parent:OnChange() end
end

function PANEL:OpenAutoComplete(tab)
    if not tab then return end
    if #tab == 0 then return end
    self.Menu = DermaMenu()

    for k, v in pairs(tab) do
        self.Menu:AddOption(v, function()
            self:SetText(v)
            self:SetCaretPos(v:len())
            self:RequestFocus()
        end)
    end

    local x, y = self:LocalToScreen(0, self:GetTall())
    self.Menu:SetMinimumWidth(self:GetWide())
    self.Menu:Open(x, y, true, self)
    self.Menu:SetPos(x, y)
    self.Menu:SetMaxHeight((ScrH() - y) - 10)
end

function PANEL:Think()
    self:ConVarStringThink()
end

function PANEL:OnEnter()
    self:UpdateConvarValue()
    self:OnValueChange(self:GetText())

    local parent = self:GetParent()
    if not parent then return end

    if parent.OnEnter then parent:OnEnter() end
end

function PANEL:UpdateConvarValue()
    self:ConVarChanged(self:GetValue())
end

function PANEL:Paint(w, h)
    self:DrawTextEntryText(color_white, PIXEL.Colors.Primary, PIXEL.Colors.Primary)
end

function PANEL:SetValue(value)
    if self:IsEditing() then return end

    self:SetText(value)
    self:OnValueChange(value)
    self:SetCaretPos(self:GetCaretPos())
end

function PANEL:OnValueChange(value)
    local parent = self:GetParent()
    if not parent then return end

    if parent.OnValueChange then parent:OnValueChange(value) end
end

local numericChars = "1234567890.-"
function PANEL:CheckNumeric(value)
    if not self:GetNumeric() then return false end
    if not string.find(numericChars, value, 1, true) then return true end

    return false
end

function PANEL:AllowInput(value)
    if self:CheckNumeric(value) then return true end

    local parent = self:GetParent()
    if not parent then return end

    if parent.AllowInput then parent:AllowInput() end
end

function PANEL:SetEditable(enabled)
    self:SetKeyboardInputEnabled(enabled)
    self:SetMouseInputEnabled(enabled)
end

function PANEL:OnGetFocus()
    hook.Run("OnTextEntryGetFocus", self)

    local parent = self:GetParent()
    if not parent then return end

    if parent.OnGetFocus then parent:OnGetFocus() end
end

function PANEL:OnLoseFocus()
    self:UpdateConvarValue()
    hook.Call("OnTextEntryLoseFocus", nil, self)

    local parent = self:GetParent()
    if not parent then return end

    if parent.OnLoseFocus then parent:OnLoseFocus() end
end

function PANEL:OnMousePressed(mcode)
    self:OnGetFocus()
end

function PANEL:AddHistory(txt)
    if not txt or txt == "" then return end

    table.RemoveByValue(self.History, txt)
    table.insert(self.History, txt)
end

function PANEL:GetAutoComplete(txt)
    local parent = self:GetParent()
    if not parent then return end

    if parent.GetAutoComplete then parent:GetAutoComplete() end
end

function PANEL:GetInt()
    local num = tonumber(self:GetText())
    if not num then return end

    return math.floor(num + 0.5)
end

function PANEL:GetFloat()
    return tonumber(self:GetText())
end

vgui.Register("PIXEL.TextEntryInternal", PANEL, "TextEntry")
--addons/sit_everywhere/lua/sitanywhere/client/sit.lua:
local TAG = "SitAny_"
local useAlt = CreateClientConVar("sitting_use_walk", "1.00", true, true, "Makes sitting require the use of walk, disable this to sit simply by using use", 0, 1)
local forceBinds = CreateClientConVar("sitting_force_left_alt", "0", true, true, "Forces left alt to always act as a walk key for sitting", 0, 1)
local SittingNoAltServer = CreateConVar("sitting_force_no_walk", "0", {FCVAR_NOTIFY, FCVAR_ARCHIVE, FCVAR_REPLICATED}, "Disables the need for using walk to sit anywhere on the server", 0, 1)

CreateClientConVar("sitting_allow_on_me", "1.00", true, true, "Allows people to sit on you", 0, 1)

local function ShouldSit(ply)
	return hook.Run("ShouldSit", ply)
end

local arrow, drawScale, traceDist = Material("widgets/arrow.png"), 0.1, 20
local traceScaled = traceDist / drawScale

local function StartSit(trace)
	local wantedAng = nil
	local cancelled = false
	local start = CurTime()
	local ply = LocalPlayer()

	hook.Add("PostDrawOpaqueRenderables", TAG .. "PostDrawOpaqueRenderables", function(depth, skybox)
		if CurTime() - start <= 0.25 then return end
		if trace.StartPos:Distance(ply:EyePos()) > 10 then
			cancelled, wantedAng = true, nil
			hook.Remove("PostDrawOpaqueRenderables", TAG .. "PostDrawOpaqueRenderables")
			return
		end

		local vec = util.IntersectRayWithPlane(ply:EyePos(), ply:EyeAngles():Forward(), trace.HitPos, Vector(0, 0, 1))
		if not vec then
			return
		end

		local posOnPlane = WorldToLocal(vec, Angle(0, 90, 0), trace.HitPos, Angle(0, 0, 0))
		local testVec = posOnPlane:GetNormal() * traceScaled
		local currentAng = (trace.HitPos - vec):Angle()
		wantedAng = currentAng

		if posOnPlane:Length() < 2 then
			wantedAng = nil
			return
		end

		if wantedAng then
			local goodSit = SitAnywhere.CheckValidAngForSit(trace.HitPos, trace.HitNormal:Angle(), wantedAng.y)
			if not goodSit then wantedAng = nil end
			cam.Start3D2D(trace.HitPos + Vector(0, 0, 1), Angle(0, 0, 0), drawScale)
				surface.SetDrawColor(goodSit and Color(255, 255, 255, 255) or Color(255, 0, 0, 255))
				surface.SetMaterial(arrow)
				surface.DrawTexturedRectRotated(testVec.x * 0.5, testVec.y * -0.5, 2 / drawScale, traceScaled, currentAng.y + 90)
			cam.End3D2D()
		end
	end)

	return function()
		hook.Remove("PostDrawOpaqueRenderables", TAG .. "PostDrawOpaqueRenderables")
		if cancelled then return end

		if CurTime() - start < 0.25 then
			RunConsoleCommand("sit")
			return
		end

		if wantedAng then
			net.Start("SitAnywhere")
				net.WriteInt(SitAnywhere.NET.SitWantedAng, 4)
				net.WriteFloat(wantedAng.y)
				net.WriteVector(trace.StartPos)
				net.WriteVector(trace.Normal)
			net.SendToServer()
			wantedAng = nil
		end
	end
end

local function DoSit(trace)
	if not trace.Hit then return end

	local surfaceAng = trace.HitNormal:Angle() + Angle(-270, 0, 0)

	local playerTrace = not trace.HitWorld and IsValid(trace.Entity) and trace.Entity:IsPlayer()

	local goodSit = SitAnywhere.GetAreaProfile(trace.HitPos + Vector(0, 0, 0.1), 24, true)
	if math.abs(surfaceAng.pitch) >= 15 or not goodSit or playerTrace then
		RunConsoleCommand"sit"
		return
	end

	local valid = SitAnywhere.ValidSitTrace(LocalPlayer(), trace)
	if not valid then
		return
	end

	return StartSit(trace)
end

local currSit
concommand.Add("+sit", function(ply, cmd, args)
	if currSit then return end
	if not IsValid(ply) or not ply.GetEyeTrace then return end
	currSit = DoSit(ply:GetEyeTrace())
end)

concommand.Add("-sit", function(ply, cmd, args)
	if currSit then
		currSit()
		currSit = nil
	end
end)


hook.Add("KeyPress", TAG .. "KeyPress", function(ply, key)
	if not IsFirstTimePredicted() and not game.SinglePlayer() then return end
	if currSit then return end

	if key ~= IN_USE then return end
	local good = not useAlt:GetBool()
	local alwaysSit = ShouldSit(ply)

	if forceBinds:GetBool() then
		if useAlt:GetBool() and input.IsKeyDown(KEY_LALT) then
			good = true
		end
	else
		if useAlt:GetBool() and ply:KeyDown(IN_WALK) then
			good = true
		end
	end

	if SittingNoAltServer:GetBool() then
		good = true
	end

	if alwaysSit == true then
		good = true
	elseif alwaysSit == false then
		good = false
	end

	if not good then return end
	local trace = LocalPlayer():GetEyeTrace()

	if trace.Hit then
		currSit = DoSit(trace)
		hook.Add("KeyRelease", TAG .. "KeyRelease", function(releasePly, releaseKey)
			if not IsFirstTimePredicted() and not game.SinglePlayer() then return end
			if ply ~= releasePly or releaseKey ~= IN_USE then return end
			hook.Remove("KeyRelease", TAG .. "KeyRelease")
			if not currSit then return end

			currSit()
			currSit = nil
		end)
	end
end)
--addons/weapons_other/lua/autorun/sv_handcuffs.lua:
-------------------------------------
---------------- Cuffs --------------
-------------------------------------
-- Copyright (c) 2015 Nathan Healy --
-------- All rights reserved --------
-------------------------------------
-- sv_handcuffs.lua         SERVER --
--                                 --
-- Server-side handcuff stuff.     --
-------------------------------------

if CLIENT then return end

util.AddNetworkString( "Cuffs_GagPlayer" )
util.AddNetworkString( "Cuffs_BlindPlayer" )
util.AddNetworkString( "Cuffs_FreePlayer" )
util.AddNetworkString( "Cuffs_DragPlayer" )

util.AddNetworkString( "Cuffs_TiePlayers" )
util.AddNetworkString( "Cuffs_UntiePlayers" )

local function GetTrace( ply )
	local tr = util.TraceLine( {start=ply:EyePos(), endpos=ply:EyePos()+(ply:GetAimVector()*100), filter=ply} )
	if IsValid(tr.Entity) and tr.Entity:IsPlayer() then
		local cuffed,wep = tr.Entity:IsHandcuffed()
		if cuffed then return tr,wep end
	end
end

//
// Standard hooks
CreateConVar( "cuffs_restrictsuicide", 1, {FCVAR_ARCHIVE,FCVAR_SERVER_CAN_EXECUTE} )
hook.Add( "CanPlayerSuicide", "Cuffs RestrictSuicide", function( ply )
	if ply:IsHandcuffed() and cvars.Bool("cuffs_restrictarrest") then return false end
end)
CreateConVar( "cuffs_restrictteams", 1, {FCVAR_ARCHIVE,FCVAR_SERVER_CAN_EXECUTE} )
hook.Add( "PlayerCanJoinTeam", "Cuffs RestrictTeam", function( ply )
	if ply:IsHandcuffed() and cvars.Bool("cuffs_restrictteams") then return false end
end)
-- hook.Add( "PlayerCanSeePlayersChat", "Cuffs ChatGag", function( _,_,_, ply )
-- 	if not IsValid(ply) then return end
	
-- 	local cuffed,wep = ply:IsHandcuffed()
-- 	if cuffed and wep:GetIsGagged() then return false end
-- end)
-- hook.Add( "PlayerCanHearPlayersVoice", "Cuffs VoiceGag", function( _, ply )
-- 	if not IsValid(ply) then return end
	
-- 	local cuffed,wep = ply:IsHandcuffed()
-- 	if cuffed and wep:GetIsGagged() then return false end
-- end)

// 
// DarkRP
CreateConVar( "cuffs_restrictwarrant", 1, {FCVAR_ARCHIVE,FCVAR_SERVER_CAN_EXECUTE,FCVAR_REPLICATED} )
hook.Add( "canRequestWarrant", "Cuffs PreventWarrant", function( crim, cop, reason )
	if cvars.Bool("cuffs_restrictwarrant") and cop:IsHandcuffed() then return false,"You can issue warrants when cuffed!" end
end)
hook.Add( "canWanted", "Cuffs PreventWarrant", function( crim, cop, reason )
	if cvars.Bool("cuffs_restrictwarrant") and cop:IsHandcuffed() then return false,"You can issue warrants when cuffed!" end
end)
CreateConVar( "cuffs_restrictarrest", 1, {FCVAR_ARCHIVE,FCVAR_SERVER_CAN_EXECUTE} )
hook.Add( "canArrest", "Cuffs RestrictArrest", function( cop, crim ) // DarkRP Arrest hook
	if IsValid(crim) and cvars.Bool("cuffs_restrictarrest") and not crim:IsHandcuffed() then return false,"You must handcuff a suspect to arrest them!" end
end)
hook.Add( "playerCanChangeTeam", "Cuffs RestrictTeam", function( ply, tm, force )
	if ply:IsHandcuffed() and cvars.Bool("cuffs_restrictteams") and not force then return false,"You can't change jobs when cuffed!" end
end)
hook.Add( "CanChangeRPName", "Cuffs RestrictName", function( ply )
	if ply:IsHandcuffed() then return false,"You can't change your name when cuffed!" end
end)

//
// Think
local NextTieHookCleanup
hook.Add( "Think", "Cuffs ForceJump CleanupTieHooks", function()


--[[ 	for _,v in pairs(player.GetAll()) do

		if v:HasWeapon( "weapon_handcuffed" ) and v:GetActiveWeapon():GetClass() != "weapon_handcuffed" then
			v:SelectWeapon( "weapon_handcuffed" )
		end
		if v.Cuff_ForceJump then
			if not v:OnGround() then return end
			
			local tr = util.TraceLine( {start = v:GetPos(), endpos = v:GetPos()+Vector(0,0,20), filter = v} )
			if tr.Hit then return end
			
			v:SetPos(v:GetPos()+Vector(0,0,5) )
			
			v.Cuff_ForceJump = nil
		end
	end ]]
	
	if CurTime()>=(NextTieHookCleanup or 0) then
		for _,v in pairs(ents.GetAll()) do
			if v.IsHandcuffHook and v.TiedHandcuffs then
				for i=#v.TiedHandcuffs,0,-1 do
					if not IsValid(v.TiedHandcuffs[i]) then
						table.remove( v.TiedHandcuffs, i )
					end
				end
				if #v.TiedHandcuffs<=0 then
					v:Remove()
					continue
				end
			end
		end
	end
end)

//
// Cuffed player interaction
net.Receive( "Cuffs_GagPlayer", function(_,ply)
	if (not IsValid(ply)) or ply:IsHandcuffed() then return end
	
	local target = net.ReadEntity()
	if (not IsValid(target)) or target==ply then return end
	
	local cuffed, cuffs = target:IsHandcuffed()
	if not (cuffed and IsValid(cuffs) and cuffs:GetCanGag()) then return end
	
	local tr = GetTrace(ply)
	if not (tr and tr.Entity==target) then return end
	
	local shouldGag = net.ReadBit()==1
	cuffs:SetIsGagged( shouldGag )
	hook.Call( shouldGag and "OnHandcuffGag" or "OnHandcuffUnGag", GAMEMODE, ply, target, cuffs )
end)
net.Receive( "Cuffs_BlindPlayer", function(_,ply)
	if (not IsValid(ply)) or ply:IsHandcuffed() then return end
	
	local target = net.ReadEntity()
	if (not IsValid(target)) or target==ply then return end
	
	local cuffed, cuffs = target:IsHandcuffed()
	if not (cuffed and IsValid(cuffs) and cuffs:GetCanBlind()) then return end
	
	local tr = GetTrace(ply)
	if not (tr and tr.Entity==target) then return end
	
	local shouldBlind = net.ReadBit()==1
	cuffs:SetIsBlind( shouldBlind )
	hook.Call( shouldBlind and "OnHandcuffBlindfold" or "OnHandcuffUnBlindfold", GAMEMODE, ply, target, cuffs )
end)
net.Receive( "Cuffs_FreePlayer", function(_,ply)
	if (not IsValid(ply)) or ply:IsHandcuffed() then return end
	
	local target = net.ReadEntity()
	if (not IsValid(target)) or target==ply then return end
	
	local cuffed, cuffs = target:IsHandcuffed()
	if not (cuffed and IsValid(cuffs)) then return end
	if IsValid(cuffs:GetFriendBreaking()) then return end
	
	local tr = GetTrace(ply)
	if not (tr and tr.Entity==target) then return end
	
	cuffs:SetFriendBreaking( ply )
end)
net.Receive( "Cuffs_DragPlayer", function(_,ply)
	if (not IsValid(ply)) or ply:IsHandcuffed() then return end
	
	local target = net.ReadEntity()
	if (not IsValid(target)) or target==ply then return end
	
	local cuffed, cuffs = target:IsHandcuffed()
	if not (cuffed and IsValid(cuffs) and cuffs:GetRopeLength()>0) then return end
	
	local tr = GetTrace(ply)
	if not (tr and tr.Entity==target) then return end
	
	local shouldDrag = net.ReadBit()==1
	if shouldDrag then
		if not (IsValid(cuffs:GetKidnapper())) then
			cuffs:SetKidnapper( ply )
			hook.Call( "OnHandcuffStartDragging", GAMEMODE, ply, target, cuffs )
		end
	else
		if ply==cuffs:GetKidnapper() then
			cuffs:SetKidnapper( nil )
			hook.Call( "OnHandcuffStopDragging", GAMEMODE, ply, target, cuffs )
		end
	end
end)

local HookModel = Model("models/props_c17/TrapPropeller_Lever.mdl")
net.Receive( "Cuffs_TiePlayers", function(_,ply)
	if (not IsValid(ply)) or ply:IsHandcuffed() then return end
	
	local DraggedCuffs = {}
	for _,c in pairs(ents.FindByClass("weapon_handcuffed")) do
		if c:GetRopeLength()>0 and c:GetKidnapper()==ply then
			table.insert( DraggedCuffs, c )
		end
	end
	if #DraggedCuffs<=0 then return end
	
	local tr = util.TraceLine( {start=ply:EyePos(), endpos=ply:EyePos()+(ply:GetAimVector()*100), filter=ply} )
	if not tr.Hit then return end
	
	if IsValid(tr.Entity) then // Pass to another player
		if tr.Entity:IsPlayer() then
			for i=1,#DraggedCuffs do
				if DraggedCuffs[i].Owner==tr.Entity then
					DraggedCuffs[i]:SetKidnapper(nil)
					hook.Call( "OnHandcuffStopDragging", GAMEMODE, ply, DraggedCuffs[i].Owner, DraggedCuffs[i] )
				else
					DraggedCuffs[i]:SetKidnapper(tr.Entity)
					hook.Call( "OnHandcuffStopDragging", GAMEMODE, ply, DraggedCuffs[i].Owner, DraggedCuffs[i] )
					hook.Call( "OnHandcuffStartDragging", GAMEMODE, tr.Entity, DraggedCuffs[i].Owner, DraggedCuffs[i] )
				end
			end
			return
		elseif tr.Entity.IsHandcuffHook and tr.Entity.TiedHandcuffs then
			for i=1,#DraggedCuffs do
				DraggedCuffs[i]:SetKidnapper(tr.Entity)
				table.insert( tr.Entity.TiedHandcuffs, DraggedCuffs[i] )
				hook.Call( "OnHandcuffStopDragging", GAMEMODE, ply, DraggedCuffs[i].Owner, DraggedCuffs[i] )
				hook.Call( "OnHandcuffTied", GAMEMODE, ply, DraggedCuffs[i].Owner, DraggedCuffs[i], tr.Entity )
			end
			return
		end
	end
	
	local hk = ents.Create("prop_physics")
	hk:SetPos( tr.HitPos + tr.HitNormal )
	local ang = tr.HitNormal:Angle()
	ang:RotateAroundAxis( ang:Up(), -90 )
	hk:SetAngles( ang )
	hk:SetModel( HookModel )
	hk:Spawn()
	
	-- hk:SetMoveType( MOVETYPE_NONE )
	if IsValid(tr.Entity) then
		hk:SetParent( tr.Entity )
		hk:SetMoveType( MOVETYPE_VPHYSICS )
	else
		hk:SetMoveType( MOVETYPE_NONE )
	end
	hk:SetCollisionGroup( COLLISION_GROUP_WEAPON )
	
	hk:SetNWBool("Cuffs_TieHook", true)
	hk.IsHandcuffHook = true
	hk.TiedHandcuffs = {}
	
	for i=1,#DraggedCuffs do
		DraggedCuffs[i]:SetKidnapper( hk )
		table.insert( hk.TiedHandcuffs, DraggedCuffs[i] )
		hook.Call( "OnHandcuffStopDragging", GAMEMODE, ply, DraggedCuffs[i].Owner, DraggedCuffs[i] )
		hook.Call( "OnHandcuffTied", GAMEMODE, ply, DraggedCuffs[i].Owner, DraggedCuffs[i], hk )
	end
end)

local function DoUntie( ply, ent )
	for i=1,#ent.TiedHandcuffs do
		if not IsValid(ent.TiedHandcuffs[i]) then continue end
		
		ent.TiedHandcuffs[i]:SetKidnapper( ply )
		hook.Call( "OnHandcuffUnTied", GAMEMODE, ply, ent.TiedHandcuffs[i].Owner, ent.TiedHandcuffs[i], ent )
		hook.Call( "OnHandcuffStartDragging", GAMEMODE, ply, ent.TiedHandcuffs[i].Owner, ent.TiedHandcuffs[i] )
	end
	
	ent:Remove()
end
net.Receive( "Cuffs_UntiePlayers", function(_,ply)
	if (not IsValid(ply)) or ply:IsHandcuffed() then return end
	
	local tr = util.TraceLine( {start=ply:EyePos(), endpos=ply:EyePos()+(ply:GetAimVector()*100), filter=ply} )
	if IsValid(tr.Entity) and tr.Entity.IsHandcuffHook and tr.Entity.TiedHandcuffs then
		DoUntie( ply, tr.Entity )
	end
end)
hook.Add( "AllowPlayerPickup", "Cuffs UntieHook", function(ply,ent)
	if IsValid(ent) and ent.IsHandcuffHook and ent.TiedHandcuffs then
		if (not IsValid(ply)) or ply:IsHandcuffed() then return end
		
		DoUntie( ply, ent )
		return false
	end
end)

//
// GmodDayZ support
// Created by and added with permission of Phoenix129 ( http://steamcommunity.com/profiles/76561198039440140/ )
hook.Add("OnHandcuffed", "DayZCuffs RemoveInventoryItem", function(ply, cuffedply, handcuffs)
	if engine.ActiveGamemode() == "dayz" then
		ply:TakeCharItem( handcuffs.CuffType )
	end
end)
 
hook.Add("OnHandcuffBreak", "DayZCuffs GiveInventoryItemIfFriend", function(cuffedply, handcuffs, friend)
	if engine.ActiveGamemode() == "dayz" then
		if IsValid(friend) and handcuffs.CuffType and handcuffs.CuffType~="" then
			friend:GiveItem(handcuffs.CuffType, 1)
		end
	end
end)

hook.Add( "CuffsCanHandcuff", "DayZCuffs SafezoneProtectCuffs", function( ply, target )
	if engine.ActiveGamemode() == "dayz" then
		if target.SafeZone or target.SafeZoneEdge or target.Loading or !target.Ready then
			return false
		end
	end
end)
hook.Add("PlayerDisconnected", "DayZCuffs DieHandcuffs", function(ply)
	if engine.ActiveGamemode() == "dayz" then
		if ply:IsHandcuffed() then ply:Kill() end
	end
end)

--addons/vyhub-gmod/lua/vyhub/shared/sh_util.lua:
local f = string.format
local date = VyHub.Lib.date

VyHub.Util = VyHub.Util or {}
VyHub.Util.chat_commands = VyHub.Util.chat_commands or {}

if SERVER then
	util.AddNetworkString("vyhub_print_chat")
	util.AddNetworkString("vyhub_play_sound")
	util.AddNetworkString("vyhub_open_url")
end

function VyHub.Util:format_datetime(unix_timestamp)
    unix_timestamp = unix_timestamp or os.time()

    local tz_wrong = os.date("%z", unix_timestamp)
    local timezone = f("%s:%s", string.sub(tz_wrong, 1, 3), string.sub(tz_wrong, 4, 5))

    return os.date("%Y-%m-%dT%H:%M:%S" .. timezone, unix_timestamp)
end

function VyHub.Util:is_server(obj)
	if type(obj) == "Entity" and (obj.EntIndex and obj:EntIndex() == 0) and !IsValid(obj) then
		return true
	else
		return false
	end
end

function VyHub.Util:iso_to_unix_timestamp(datetime)
	if datetime == nil then return nil end

	local pd = date(datetime)

	if pd == nil then return nil end

	local time = os.time(
		{
			year = pd:getyear(),
			month = pd:getmonth(),
			day = pd:getday(),
			hour = pd:gethours(),
			minute = pd:getminutes(),
			second = pd:getseconds(),
		}
	)

	return time
end

function VyHub.Util:get_ply_by_nick(nick)
	nick = string.lower(nick);
	
	for _, v in ipairs(player.GetHumans()) do
		if(string.find(string.lower(v:Name()), nick, 1, true) != nil)
			then return v;
		end
	end
end

function VyHub.Util:register_chat_command(strCommand, Func)
	if !strCommand || !Func then return end
	
	for k, v in pairs( VyHub.Util.chat_commands ) do
		if( strCommand == k ) then
			return
		end
	end
	
	VyHub.Util.chat_commands[ tostring( strCommand ) ] = Func;
end

function VyHub.Util:concat_args(args, pos)
	local toconcat = {}

	if pos > 1 then
		for i = pos, #args, 1 do
			toconcat[#toconcat+1] = args[i]
		end
	end

	return string.Implode(" ", toconcat)
end


if SERVER then
	hook.Add("PlayerSay", "vyhub_util_PlayerSay", function(ply, message)
		if VyHub.ready then
			local chat_string = string.Explode(" ", message)
			local ret = nil
		
			for k, v in pairs( VyHub.Util.chat_commands ) do
				if( string.lower(chat_string[1]) == string.lower(k) ) then
					table.remove(chat_string, 1)
					ret = v(ply, chat_string)
					break
				end
			end
		
			if ret != nil then
				return ret
			end
		end	
	end)
end

local colors = {
	red = Color(255, 24, 35),
	green = Color(45, 170, 0),
	blue = Color(0, 115, 204),
	yellow = Color(229, 221, 0),
	pink = Color(229, 0, 218),
}

-- Takes a str message with colors and returns a table
function VyHub.Util:replace_colors(message, no_color)
    local resultTable = {}
    local currentIndex = 1

    local function getColor(colorName)
        if colors[colorName] then
            return colors[colorName]
        else
            return no_color
        end
    end

    local function addStringToTable(str, color)
        table.insert(resultTable, color)
        table.insert(resultTable, str)
    end

    local tags = {}

    -- Extract all color tags and their corresponding content
    for tag, content in string.gmatch(message, "<([%l]+)>([^<]+)</%1>") do
        table.insert(tags, {tag = tag, content = content})
    end

    -- Process the string, splitting it based on the color tags
    for _, tagData in ipairs(tags) do
        local startIndex, endIndex = string.find(message, f("<(%s)>[^<]+</%s>", string.PatternSafe(tagData.tag), string.PatternSafe(tagData.tag)), currentIndex, false)

        if startIndex then
            local str = string.sub(message, currentIndex, startIndex - 1)

            addStringToTable(str, no_color)
            addStringToTable(tagData.content, getColor(tagData.tag))

            currentIndex = endIndex + 1
        end
    end

    -- Append any remaining part of the string
    local str = string.sub(message, currentIndex)
    if str != "" then
        addStringToTable(str, no_color)
    end

    return resultTable
end

local color_tag = Color(0, 187, 255)

function VyHub.Util:print_chat(ply, message, tag, color)
	color = color or color_white
	
	if SERVER then
		if IsValid(ply) then
			if not VyHub.Config.chat_tag then
				VyHub.Config.chat_tag = "[VyHub] "
			end

			if not tag then
				tag = VyHub.Config.chat_tag
			end

			message = string.Replace(message, '\r', '')
			message = string.Replace(message, '\n', '')

			net.Start("vyhub_print_chat")
				net.WriteString(message)
				net.WriteString(tag)
				net.WriteColor(color)
			net.Send(ply)
		end
	elseif CLIENT then
		msg_table = VyHub.Util:replace_colors(message, color)

		chat.AddText(color_tag, tag, color_white, unpack(msg_table))
	end
end

function VyHub.Util:print_chat_steamid(steamid, message, tag, color)
	if steamid != nil and steamid != false then
		local ply = player.GetBySteamID64(steamid)
	
		if IsValid(ply) then
			VyHub.Util:print_chat(ply, message, tag, color)
		end
	end
end

function VyHub.Util:play_sound_steamid(steamid, url)
	if steamid then
		local ply = player.GetBySteamID64(steamid)
	
		if IsValid(ply) then
			return VyHub.Util:play_sound(ply, url)
		end
	end
end

function VyHub.Util:play_sound(ply, url)
	if SERVER then
		if IsValid(ply) then
			net.Start("vyhub_play_sound")
				net.WriteString(url)
			net.Send(ply)
		end
	elseif CLIENT then
		sound.PlayURL ( url, "", function() end)
	end
end

function VyHub.Util:open_url(ply, url)
	if SERVER then
		if IsValid(ply) then
			net.Start("vyhub_open_url")
				net.WriteString(url)
			net.Send(ply)
		end
	elseif CLIENT then
		gui.OpenURL(url)
	end
end

function VyHub.Util:print_chat_all(message, tag, color)
	for _, ply in ipairs(player.GetHumans()) do
		VyHub.Util:print_chat(ply, message, tag, color)
	end
end


function VyHub.Util:get_player_by_nick(nick)
	nick = string.lower(nick);
	
	for _,v in ipairs(player.GetHumans()) do
		if(string.find(string.lower(v:Name()), nick, 1, true) != nil)
			then return v;
		end
	end
end


function VyHub.Util:hex2rgb(hex)
    hex = hex:gsub("#","")
    if(string.len(hex) == 3) then
        return Color(tonumber("0x"..hex:sub(1,1)) * 17, tonumber("0x"..hex:sub(2,2)) * 17, tonumber("0x"..hex:sub(3,3)) * 17)
    elseif(string.len(hex) == 6) then
        return Color(tonumber("0x"..hex:sub(1,2)), tonumber("0x"..hex:sub(3,4)), tonumber("0x"..hex:sub(5,6)))
    else
    	return color_white
    end
end

function VyHub.Util:iso_ts_to_local_str(iso_ts)
	local bias = VyHub.Config.time_offset != nil and -math.Round(VyHub.Config.time_offset * 60 * 60) or nil

	return date(iso_ts):setbias(bias):tolocal():fmt(VyHub.Config.date_format)
end


function VyHub.Util:invalid_str(str_list)
	for _, str in ipairs(str_list) do
		if str == nil or string.Trim(str) == "" then
			return true
		end
	end

	return false
end

function VyHub.Util:escape_concommand_str(str)
	str = string.Replace(str, '"', "'")

	return str
end



if CLIENT then
	net.Receive("vyhub_print_chat", function ()
		local message = net.ReadString()
		local tag = net.ReadString()
		local color = net.ReadColor()

		VyHub.Util:print_chat(nil, message, tag, color)
	end)

	net.Receive("vyhub_play_sound", function ()
		local url = net.ReadString()

		VyHub.Util:play_sound(nil, url)
	end)

	net.Receive("vyhub_open_url", function ()
		local url = net.ReadString()

		VyHub.Util:open_url(nil, url)
	end)
end

--lua/wos/anim_extension/holdtypes/a_combo4.lua:
--[[-------------------------------------------------------------------
	Blade Symphony Judgement - Heavy Hold Type:
		Uses the Heavy variation of the Judgement animations from Blade Symphony to create a variety Hold Type
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
----------------------------- Copyright 2017, David "King David" Wiltos ]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
-- Copyright 2017, David "King David" Wiltos ]]--


local DATA = {}

DATA.Name = "character holdtype"
DATA.HoldType = "a_combo4"
DATA.BaseHoldType = "melee2"
DATA.Translations = {}

DATA.Translations[ ACT_MP_STAND_IDLE ]					= "customcharacter_idle"
DATA.Translations[ ACT_MP_WALK ]						= "walk_charactercustom"
DATA.Translations[ ACT_MP_RUN ]							= "run_charactercustom"
DATA.Translations[ ACT_MP_CROUCH_IDLE ]					= "couch_idle"
DATA.Translations[ ACT_MP_CROUCHWALK ]					= "cwalk_melee1"
DATA.Translations[ ACT_MP_ATTACK_STAND_PRIMARYFIRE ]	= "a_combo4" 
DATA.Translations[ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE ]	= "a_combo4" 
--DATA.Translations[ ACT_MP_RELOAD_STAND ]				= IdleActivity + 6
--DATA.Translations[ ACT_MP_RELOAD_CROUCH ]				= IdleActivity + 6
DATA.Translations[ ACT_MP_JUMP ]						= "inair"
--DATA.Translations[ ACT_MP_SWIM ]						= IdleActivity + 9
DATA.Translations[ ACT_LAND ]							= "wos_bs_shared_jump_land"

wOS.AnimExtension:RegisterHoldtype( DATA )
--lua/wos/anim_extension/holdtypes/g_rollright.lua:
--[[-------------------------------------------------------------------
	Blade Symphony Judgement - Heavy Hold Type:
		Uses the Heavy variation of the Judgement animations from Blade Symphony to create a variety Hold Type
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
----------------------------- Copyright 2017, David "King David" Wiltos ]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
-- Copyright 2017, David "King David" Wiltos ]]--


local DATA = {}

DATA.Name = "character holdtype"
DATA.HoldType = "g_rollright"
DATA.BaseHoldType = "melee2"
DATA.Translations = {}

DATA.Translations[ ACT_MP_STAND_IDLE ]					= "customcharacter_idle"
DATA.Translations[ ACT_MP_WALK ]						= "walk_charactercustom"
DATA.Translations[ ACT_MP_RUN ]							= "run_charactercustom"
DATA.Translations[ ACT_MP_CROUCH_IDLE ]					= "couch_idle"
DATA.Translations[ ACT_MP_CROUCHWALK ]					= "cwalk_melee1"
DATA.Translations[ ACT_MP_ATTACK_STAND_PRIMARYFIRE ]	= "rollright" 
DATA.Translations[ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE ]	= "rollright" 
--DATA.Translations[ ACT_MP_RELOAD_STAND ]				= IdleActivity + 6
--DATA.Translations[ ACT_MP_RELOAD_CROUCH ]				= IdleActivity + 6
DATA.Translations[ ACT_MP_JUMP ]						= "wos_judge_a_idle"
--DATA.Translations[ ACT_MP_SWIM ]						= IdleActivity + 9
DATA.Translations[ ACT_LAND ]							= "wos_bs_shared_jump_land"

wOS.AnimExtension:RegisterHoldtype( DATA )
--addons/wos-passiveevent-ageo/lua/autorun/wos_css_enums.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2019
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--

WOS_CSS = WOS_CSS or {}

WOS_CSS.Version = 0.1
WOS_CSS.Debug = false

WOS_CSS.CONFIG = {
	BOOL = 1,
	NUMBER = 2,
	NSLIDER = 3,
	NSLIDERTOGGLE = 4,
	STRING = 5,
	SDROPDOWN = 6,
	COLOR = 7, -- Not Functional Currently (Placeholder)
	MTABLE = 8,
}

WOS_CSS.MODE = {
	INITIAL = 1,
	AREASELECT = 2,
    SIMSELECTED = 3,
    CHALLENGESELECTED = 4,
    POINTSELECT = 5,
}

WOS_CSS.AREASELECT = {
	BORDER = 1,
	HEIGHT = 2
}

--addons/z_anticrash_v1.4.6/lua/autorun/z_anticrash_setup.lua:
-- [[ CREATED BY ZOMBIE EXTINGUISHER ]]

local function findFiles(searchQuota,searchPath,foundTbl)
	
	foundTbl = foundTbl or {}
	searchPath = searchPath or "z_anticrash"
	
	local files, dirs = file.Find( searchPath.."/*", "LUA" )
	
	for i=1,#dirs do
		findFiles(searchQuota,searchPath..'/'..dirs[i],foundTbl)
	end
	
	for i=1,#files do
		
		local f = files[i]
		
		for ii=1,#searchQuota do
			
			local quota = searchQuota[ii]
			
			if string.StartWith( f, quota ) then
				table.insert(foundTbl, (quota == "sh_" and 1 or #foundTbl+1),searchPath..'/'..f)
				break
			end
		
		end
		
	end
	
	return foundTbl
	
end

local searchQuota = {}
searchQuota.priority = {"settings","vars"}
searchQuota.cl = {"sh_","cl_","p_"}
searchQuota.sv = {"sh_","sv_"}

local priorityFiles = findFiles(searchQuota.priority)
local clFiles = findFiles(searchQuota.cl)
local svFiles = findFiles(searchQuota.sv)

CL_ANTICRASH = {}
SH_ANTICRASH = {} 
SV_ANTICRASH = {} 
	
-- load shared priority files first
for _,priorityFile in ipairs( priorityFiles ) do
	include( priorityFile )
end

if CLIENT then

	for _,clFile in pairs( clFiles ) do
		include( clFile )
	end

end

if SERVER then 

	-- Anti-Crash content for clients
	--resource.AddWorkshop(2159259261)
	
	for _,priorityFile in pairs( priorityFiles ) do
		AddCSLuaFile( priorityFile )
	end
	
	for _,clFile in pairs( clFiles ) do
		AddCSLuaFile( clFile )
	end

	for _,svFile in pairs( svFiles ) do 
		include( svFile )
	end
end
--addons/z_anticrash_v1.4.6/lua/z_anticrash/vars.lua:
-- [[ CREATED BY ZOMBIE EXTINGUISHER ]]

-- if SH_ANTICRASH.VARS then return end

SH_ANTICRASH.VARS = {}
SH_ANTICRASH.VARS.LATESTVERSION = true
SH_ANTICRASH.VARS.NEIGHBOUROFFSETVECTOR = Vector(10,10,10)

// COLOR (Thank you Sleepy <3)
SH_ANTICRASH.VARS.COLOR = {

	-- Contrast Checker: https://juicystudio.com/services/luminositycontrastratio.php#specify

	DARK = Color(30, 30, 30),
	MOREDARKY = Color(35, 35, 35),
	DARKY = Color(41, 41, 41),
	LESSDARKY = Color(45, 45, 45),
	LIGHTDARK = Color(48, 48, 48),
	LIGHTYDARK = Color(52, 52, 52),
	GREY = Color(109, 125, 126),
	DARKGREY = Color(149, 165, 166),
	LIGHTGREY = Color(150, 150, 150),
	
	PURPLE = Color(154, 0, 223),
	DARKPURPLE = Color(104, 0, 173),
	FUCHSIA = Color(255,0,255),
	CONTRASTFUCHSIA = Color(222, 0, 222),
	
	BLUE = Color(41, 128, 185),
	DARKBLUE = Color(0,0,139),
	LIGHTBLUE = Color(41, 183, 185),
	
	RED = Color(230, 58, 64),
	DARKRED = Color(139, 0, 0),
	
	GREEN = Color(46, 204, 113),
	
	LIGHTYELLOW = Color(189, 201, 15),
	YELLOW = Color(255, 215, 0),
	
	LIGHTORANGE = Color(255, 100, 73),
	ORANGE = Color(230, 153, 58),
	DARKORGANGE = Color(255, 140, 0),
	CONTRASTORGANGE = Color(222, 121, 0),
	SUPERDARKORGANGE = Color(191, 115, 0),
	ORANGERED = Color(255, 83, 73),
	CONTRASTORANGERED = Color(222, 44, 0),
	
}

// HOOKS
SH_ANTICRASH.VARS.HOOKS = {}

SH_ANTICRASH.VARS.HOOKS.SPAWN = {
	"PlayerSpawnObject",
	"PlayerSpawnNPC",
	"PlayerSpawnSENT",
	"PlayerSpawnSWEP",
	"PlayerSpawnVehicle",
	"CanTool"
}

SH_ANTICRASH.VARS.HOOKS.SPAWNED = {
	"PlayerSpawnedEffect",
	"PlayerSpawnedNPC",
	"PlayerSpawnedProp",
	"PlayerSpawnedRagdoll",
	"PlayerSpawnedSENT",
	"PlayerSpawnedSWEP",
	"PlayerSpawnedVehicle"
}

// CMD Load order priority
if SERVER then

	SV_ANTICRASH.CMD = SV_ANTICRASH.CMD or {}
	SV_ANTICRASH.CMD.REGISTERED = SV_ANTICRASH.CMD.REGISTERED or {}

	function SV_ANTICRASH.CMD.RegisterCMD(cmd,info,func)

		SV_ANTICRASH.CMD.REGISTERED[cmd] = {
			info = info,
			func = func
		}
		
	end
	
end

// Cleanup types
SH_ANTICRASH.VARS.CLEANUP = {}

SH_ANTICRASH.VARS.CLEANUP.COLORS = {
	[1] = Color(150,0,0)
}

SH_ANTICRASH.VARS.CLEANUP.TYPES = {
	[1] = { type = "resetmap", name = "resetMap" },
	[2] = { type = "removeall", name = "removeEntities" },
	[3] = { type = "freezeall", name = "freezeEntities" },
	[4] = { type = "nocollideall", name = "noCollideEntities" },
}

SH_ANTICRASH.VARS.CLEANUP.TYPESBYKEY = {}

local function GetCleanupName(cleanupType)
	return CLIENT and language.GetPhrase("Cleanup_"..cleanupType) or cleanupType
end

local function CleanupInit()

	local cleanupTbl = cleanup.GetTable()
	
	if #cleanupTbl == 0 then
		timer.Simple(1,CleanupInit)
		return
	end

	table.sort(cleanupTbl, function(a, b) 
		return GetCleanupName(a) < GetCleanupName(b)
	end)

	for _, cleanupType in pairs(cleanupTbl) do
		
		local insertKey = table.insert(SH_ANTICRASH.VARS.CLEANUP.TYPES, {
			type = cleanupType,
			name = GetCleanupName(cleanupType),
			isDefault = true
		})
		
		if SERVER then
			SV_ANTICRASH.CMD.RegisterCMD(cleanupType, "Remove "..cleanupType, function(ply, cmd, args)
				SV_ANTICRASH.DefaultCleanup(ply,cleanupType)
			end)
		end
		
	end
	
	-- Create table with cleanupType as key, custom key: 76561199084269612
	for i=1, #SH_ANTICRASH.VARS.CLEANUP.TYPES do
		local cleanupType = SH_ANTICRASH.VARS.CLEANUP.TYPES[i].type
		SH_ANTICRASH.VARS.CLEANUP.TYPESBYKEY[cleanupType] = SH_ANTICRASH.VARS.CLEANUP.TYPES[i]
	end
	
	local startColor = SH_ANTICRASH.VARS.CLEANUP.COLORS[1]
	local tintDiff = 120/#SH_ANTICRASH.VARS.CLEANUP.TYPES
	for i=2, #SH_ANTICRASH.VARS.CLEANUP.TYPES do
		
		local diff = (tintDiff*i)
		local newColor = Color(startColor.r-diff,startColor.g-diff,startColor.b-diff)
	
		SH_ANTICRASH.VARS.CLEANUP.COLORS[i] = newColor
		
	end

end
hook.Add("PostGamemodeLoaded","sh_anticrash_CleanupInit", CleanupInit)
--addons/z_anticrash_v1.4.6/lua/z_anticrash/shared/sh_meta.lua:
-- [[ CREATED BY ZOMBIE EXTINGUISHER ]]

// ENTITY
local ent = FindMetaTable("Entity")
local nwCreatorStr = "z_anticrash_Creator"

function ent:z_anticrashSetCreator(ply)
	self:SetNWEntity(nwCreatorStr,ply)
end

function ent:z_anticrashGetCreator()
	return self:GetNWEntity(nwCreatorStr)
end

function ent:z_anticrashHasCreator()
	return IsValid(self:z_anticrashGetCreator())
end

function ent:z_anticrashIsValidEnt()
	return IsValid(self) and self:z_anticrashHasCreator()
end

// PLAYER
local ply = FindMetaTable("Player")
local nwCanSpawnStr = "z_anticrash_CanSpawn_"
local nwCanSpawnGlobalStr = "z_anticrash_CanSpawn_Global"
local nwFlaggedStr = "z_anticrash_Flagged"
local nwSpawnCountStr = "z_anticrash_SpawnCount"
local nwConstraintCountStr = "z_anticrash_ConstraintCount"

function ply:z_anticrashSetCanSpawn(spawnHook,bool)

	if spawnHook == '*' then
		
		for i=1, SH_ANTICRASH.VARS.HOOKS.SPAWN do
			
			local spawnHook = SH_ANTICRASH.VARS.HOOKS.SPAWN[i]
		
			self:SetNWBool(nwCanSpawnStr..spawnHook,bool)
			
		end
		
	else
		self:SetNWBool(nwCanSpawnStr..spawnHook,bool)
	end

end

function ply:z_anticrashGetCanSpawn(spawnHook)
	return self:GetNWBool(nwCanSpawnStr..spawnHook, true)	
end

function ply:z_anticrashSetCanSpawnGlobal(bool)
	self:SetNWBool(nwCanSpawnGlobalStr, bool)
end

function ply:z_anticrashGetCanSpawnGlobal()
	return self:GetNWBool(nwCanSpawnGlobalStr, true)
end

function ply:z_anticrashFlagPlayer(flagNum)
	
	local newFlaggedCount = self:z_anticrashGetFlaggedCount() + (flagNum or 1)
	
	self:SetNWInt(nwFlaggedStr, newFlaggedCount)
	
end

function ply:z_anticrashGetFlaggedCount()
	return self:GetNWInt(nwFlaggedStr)
end

function ply:z_anticrashResetFlaggedCount()
	self:SetNWInt(nwFlaggedStr, 0)
end

function ply:z_anticrashIncreaseSpawnCount()

	self.__spawnCount = (self.__spawnCount or 0) + 1
	
	-- Timer to avoid overflowing the net channel when rapidly setting value
	timer.Create("z_anticrash_SpawnCount", 0.1, 1, function()
		self:SetNWInt(nwSpawnCountStr, self.__spawnCount)
	end)

end

function ply:z_anticrashGetSpawnCount()
	return self:GetNWInt(nwSpawnCountStr)
end

function ply:z_anticrashSetConstraintCount(num)
	self:SetNWInt(nwConstraintCountStr, num)
end

function ply:z_anticrashGetConstraintCount()
	return self:GetNWInt(nwConstraintCountStr)
end
--addons/z_anticrash_v1.4.6/lua/z_anticrash/languages/nl.lua:
-- [[ CREATED BY ZOMBIE EXTINGUISHER ]]

local en = {
	
	-- Stats
	lag = "LAG",
	collisions = "COLLISIONS",
	props = "PROPS",
	propsFrozen = "BEVROZEN PROPS",
	npcs = "NPCS",
	vehicles = "VOERTUIGEN",
	players = "SPELERS",
	uptime = "UPTIME",
	entities = "ENTITEITEN",
	spawned = "GESPAWNED",
	fps = "FPS",
	tickrate = "TICKRATE",
	runAntiLagMeasures = "VOER ANTI-LAG MAATREGELEN UIT",
	
	-- Users
	search = "Zoek",
	constraints = "CONSTRAINTS",
	showEntities = "Toon Entiteiten",
	hideEntities = "Verberg Entiteiten",
	resetMap = "Reset Map",
	freezeEntities = "Bevries Entiteiten",
	removeEntities = "Verwijder Entiteiten",
	
	-- Global
	noCollideEntities = "No-Collide Entiteiten",
	
	-- Lag
	heavyLag = "Zware lag gedetecteerd!",
	lagIsStuck = "Waarschuwing: lag zit vast!",
	crashPrevented = "Server crash voorkomen!",
	cleaningMap = "+ Map opruimen...",
	removingEnts = "+ %s entiteiten aan het verwijderen",
	revertChanges = "+ %s entiteiten gecreerd in the laatste %s minuten aan het verwijderen",
	freezeingEnts = "+ %s entiteiten aan het bevriezen",
	noCollidingEnts = "+ %s entiteiten aan het no-colliden",
	offenderWarning = "%s heeft verdachte hoeveelheid entiteiten (%s) net voor de lag begon!",
	freezingAllEntities = "Alle entiteiten bevrozen (%s)",
	
	-- Dupes
	dupesNotEnabled = "Dupes zijn niet toegestaan op deze server!",
	advDupesNotEnabled = "Advanced Dupes zijn niet toegestaan op deze server!",
	dupeExceedsSize = "Deze dupe overschrijdt de maximale limiet! (grootte:%s, max:%s)",
	dupeInformation = "%s spawnt dupe die %s entiteiten en %s constraints bevat",
	
	-- Notifications
	triggeredAntiLagMeasures = "heeft de anti-lag maatregelen getriggered!",
	ranAntilagMeasures = "heeft de anti-lag maatregelen gerunt!",
	hasNoEntities = "heeft geen entiteiten!",
	youRemovedFrom = "Jij hebt %s entiteiten van %s verwijderd!",
	removedYourObjects = "heeft jou gespawnde objecten verwijderd!",
	youFrozeFrom = "Jij hebt %s entiteiten van %s bevrozen!",
	frozeYourObjects = "heeft jou gespawnde objecten bevrozen!",
	enabledSpawnAbility = "heeft jou vermogen om objecten te spawnen gereactiveerd!",
	disabledSpawnAbility = "heeft jou vermogen om objecten te spawned gedeactiveerd!",
	youEnabledSpawnAbility = "Jij hebt %s's vermogen om objecten the spawnen gereactiveerd!",
	youDisabledSpawnAbility = "Jij hebt %s's vermogen om objecten the spawnen gedeactiveerd!",
	
	resetTheMap = "map gereset!",
	noEntNameFound = "Geen %s gevonden!",
	noEntitiesFound = "Geen entiteiten gevonden!",
	noUnfrozenEntsFound = "Geen niet-bevrozen entiteiten gevonden!",
	noUnCollidedEntsFound = "Geen niet-collided entiteiten gevonden!",
	freezeAllEnts = "%s bevroos alle %s! (%s)",
	noCollideAllEnts = "%s no-collided alle %s! (%s)",
	removedAllEntName = "%s verwijderde alle %s! (%s)",
	entitiesLowCase = "entiteiten",
	
	-- Console Log
	removedEntitiesFrom = "%s verwijderde %s entiteiten van %s!",
	frozeEntitiesFrom = "%s bevroos %s entiteiten van %s!",
	enabledSpawningCapabilities = "%s reactiveerde spawning capaciteiten van %s!",
	disabledSpawningCapabilities = "%s deactiveerde spawning capaciteiten van %s!",
	removingHighCollision = "Hoge collision %s (%s) verwijderd van %s!",
	
}

return en
--addons/z_anticrash_v1.4.6/lua/z_anticrash/panels/p_utils.lua:
-- [[ CREATED BY ZOMBIE EXTINGUISHER]]

function CL_ANTICRASH.CreateLbl(x, y, txt, font, col, parent)
	
	local lbl = vgui.Create( "DLabel", parent )
	lbl:SetFont(font)
	lbl:SetContentAlignment( 5 )
	lbl:SetTextColor(col)
	lbl:SetText(txt)
	lbl.UpdateSize = function(self)
		self:SetSize(self:GetContentSize()+10)
		self:SizeToContentsY()
		self:SetPos(x,y)
	end
	lbl:UpdateSize()
	
	return lbl
	
end

function CL_ANTICRASH.CreateButton(x, y, w, h, txt, font, col, parent, doClick)
	
	
	local btn = vgui.Create("DButton", parent)
	btn:SetPos(x,y)
	btn:SetSize(w,h)
	btn:SetText(txt)
	btn:SetFont(font)
	btn:SetTextColor(color_white)
	btn.DoClick = doClick
	btn.Paint = function(self, w, h)
		
		-- Bg
		draw.RoundedBox( 4, 0, 0, w, h, col )
		
	end
	
	return btn

end

function CL_ANTICRASH.CreateButtonColorFade(x, y, w, h, txt, font, col, col2, parent, doClick)

	local btn = CL_ANTICRASH.CreateButton(x, y, w, h, txt, font, col, parent, doClick)
	btn.isSelected = false
	btn.__bgAlpha = 0
	
	local nextThink, fadeSpeed, fadeLimit = 0, 40, 150
	btn.Think = function(self, w, h)
		
		if nextThink < CurTime() then
	
			-- Alpha fade
			if self.isSelected then
				
				self.__bgAlpha = math.Approach(self.__bgAlpha, fadeLimit, fadeSpeed)
				
				if self.__bgAlpha == fadeLimit then
					self.isSelected = false
				end
				
			else
				self.__bgAlpha = math.Approach(self.__bgAlpha, 0, fadeSpeed)
			end
			
			-- Limit to 30FPS
			nextThink = CurTime() + 0.033
		
		end
		
	end
	btn.Paint = function(self, w, h)
		
		-- Bg
		draw.RoundedBox( 4, 0, 0, w, h, ColorAlpha(col,255-self.__bgAlpha) )
		
		-- Fg
		draw.RoundedBox( 4, 0, 0, w, h, ColorAlpha(col2,self.__bgAlpha) )
		
	end
	btn.DoClick = function(self)
	
		self.isSelected = true
	
		doClick(self)
		
	end
	
	return btn
	
end

function CL_ANTICRASH.CreateColorSwitchButton(x, y, w, h, txt, font, col1, col2, isSelected, parent, doClick)
	
	local entityVisionBtn = vgui.Create("DButton", parent)
	entityVisionBtn:SetPos(x,y)
	entityVisionBtn:SetSize(w,h)
	entityVisionBtn:SetText(txt)
	entityVisionBtn:SetFont(font)
	entityVisionBtn:SetTextColor(color_white)
	entityVisionBtn.DoClick = doClick
	entityVisionBtn.__isSelected = isSelected
	entityVisionBtn.Paint = function(self, w, h)
		
		local bgCol = self.__isSelected and col2 or col1
		
		-- Bg
		draw.RoundedBox( 4, 0, 0, w, h, bgCol )
		
	end
	
	return entityVisionBtn

end

function CL_ANTICRASH.CreateTextInput(x, y, w, h, defaultVal, font, col, parent)
	
	local bgPanel = vgui.Create("DPanel", parent)
	bgPanel:SetPos( x, y )
	bgPanel:SetSize( w, h )
	bgPanel.Paint = function(self, w, h)
		
		-- Bg
		draw.RoundedBox( 4, 0, 0, w, h, SH_ANTICRASH.VARS.COLOR.DARKY )
		
	end

	local offsetW, offsetH = 4, 4
	local textInput = vgui.Create( "DTextEntry", bgPanel )
	textInput:SetPos( offsetW, offsetH )
	textInput:SetSize(w-(offsetW*2), h-(offsetH*2))
	textInput:SetFont( font )
	textInput:SetTextColor(col)
	textInput:SetText( defaultVal )
	textInput:SetDrawBackground(false)
	textInput.m_colCursor = col
	textInput.m_colPlaceholder = col
	
	local oldPaint = textInput.Paint
	textInput.Paint = function(self, w, h)
		
		-- Small BG
		draw.RoundedBox( 4, 0, 0, w, h, SH_ANTICRASH.VARS.COLOR.LESSDARKY )
		
		-- Input box
		oldPaint(self,w,h)
		
	end 
	
	return bgPanel, textInput
	
end

function CL_ANTICRASH.CreateDividerLine(x, y, w, h, col, parent)
	
	local dividerPnl = vgui.Create("DPanel",parent)
	dividerPnl:SetPos(x,y)
	dividerPnl:SetSize(w,h)
	dividerPnl.Paint = function(self, w, h)
	
		-- Bg
		draw.RoundedBox( 4, 0, 0, w, h, col )
		
	end
	
	return dividerPnl

end

function CL_ANTICRASH.DrawCircle(x, y, radius, col)

	local smoothness = 5
	local seg = 32
	local cir = {}

	table.insert( cir, { x = x, y = y, u = 0.5, v = 0.5 } )
		
	for i = 0, seg do
	
		local a = math.rad( ( i / seg ) * -360 )
		
		cir[i] = {
			x = x + math.sin( a ) * radius,
			y = y + math.cos( a ) * radius,
			u = math.sin( a ) / 2 + 0.5,
			v = math.cos( a ) / 2 + 0.5
		} 
		
	end

	local a = math.rad( 0 )
	
	table.insert( cir, { x = x + math.sin( a ) * radius, y = y + math.cos( a ) * radius, u = math.sin( a ) / 2 + 0.5, v = math.cos( a ) / 2 + 0.5 } )

	surface.SetDrawColor(col) 
	draw.NoTexture()
	surface.DrawPoly( cir )

end

function CL_ANTICRASH.CreateInfoLabel(x, y, h, txt, col, font, parent)

	local infoLbl = vgui.Create( "DLabel", parent )
	infoLbl:SetPos(x, y)
	infoLbl:SetFont(font)
	infoLbl:SetContentAlignment( 5 )
	infoLbl:SetTextColor(col)
	infoLbl:SetText(txt)
	infoLbl.UpdateSize = function(self)
		self:SetSize(0,h)
		self:SizeToContentsX()
	end
	infoLbl:UpdateSize()
	
	return infoLbl
	
end

function CL_ANTICRASH.CreateGraphInfoLabel(x, y, w, h, txt, infoKey, showFraction, parent, drawBorders)

	local infoCol = CL_ANTICRASH.GRAPH.COL[infoKey]
	local edgeOffset = 2
	local infoLblOffset = 8

	local bgPanel = vgui.Create("DPanel",parent)
	bgPanel:SetPos(x,y)
	bgPanel:SetSize(w,h)
	bgPanel.Paint = function(self, w, h)
		
		if drawBorders then
		
			-- Left edge
			draw.RoundedBox( 4, 0, 0, w/2, h, infoCol )
			
			-- Right edge
			draw.RoundedBox( 4, w/2, 0, w/2, h, infoCol )
			
		end
		
		-- Bg
		draw.RoundedBox( 4, edgeOffset, 0, w-(edgeOffset*2), h, SH_ANTICRASH.VARS.COLOR.DARKY )
		
	end
	
	-- Info name
	CL_ANTICRASH.CreateInfoLabel(x+infoLblOffset,y,h,txt,infoCol, "z_anticrash_graph_label", parent)

	-- Info value
	local valLbl = CL_ANTICRASH.CreateInfoLabel(0,y,h,"",infoCol, "z_anticrash_graph_label", parent)
	
	-- Keep value up to date
	valLbl.Think = function()
	
		local graphInfo = CL_ANTICRASH.GRAPH.INFO[infoKey]
		local valTxt = graphInfo.cur
		
		if !showFraction then
			local num = math.Clamp(math.Round(100*(graphInfo.cur/graphInfo.max)),0,100)
			-- valTxt = num.."%"
			valTxt = num
		end
		
		valLbl:SetText(valTxt)
		valLbl:UpdateSize()
		valLbl:SetPos(bgPanel:GetRightX()-infoLblOffset-valLbl:GetWide(),y)
	
	end
	
	return bgPanel
	
end

function CL_ANTICRASH.CreateGraph(x, y, w, h, parent)

	local graphPanel = vgui.Create("DPanel",parent)
	graphPanel:SetPos(x,y)
	graphPanel:SetSize(w,h)
	
	local graphLineCol = SH_ANTICRASH.VARS.COLOR.DARK
	local graphLineOffset = h/6
	local graphLineCount = SH_ANTICRASH.SETTINGS.GRAPH.TIMEWINDOW
	
	graphPanel.Paint = function(self, w, h)
	
		-- Bg
		draw.RoundedBox( 4, 0, 0, w, h, SH_ANTICRASH.VARS.COLOR.LIGHTDARK )
		
		-- Bg Lines
		for i=1, 6 do
			
			local lineY = graphLineOffset*i
		
			surface.SetDrawColor( graphLineCol )
			surface.DrawLine( 0, lineY, w, lineY)
			
		end
	
		-- Graph Lines
		for k,points in SortedPairs(CL_ANTICRASH.GRAPH.POINTS) do

			local prevGraphPoint = nil
			local lineCol = CL_ANTICRASH.GRAPH.COL[k]
			
			for i=1, #points do
				
				local pointInfo = points[i]
				
				if !prevGraphPoint then
					prevGraphPoint = pointInfo
					continue
				end
				
				local startX, startY = (w/graphLineCount) * (graphLineCount-i+2), h - (h * prevGraphPoint.cur/prevGraphPoint.max)
				local endX, endY = (w/graphLineCount) * (graphLineCount-i+1), h - (h * pointInfo.cur/pointInfo.max)
				
				startY = math.Clamp(startY,1,h-2)
				endY = math.Clamp(endY,1,h-2)
				
				surface.SetDrawColor( lineCol )
				surface.DrawLine( startX, startY+1, endX, endY+1 )
				surface.DrawLine( startX, startY-1, endX, endY-1 )
				surface.DrawLine( startX, startY, endX, endY )
				
				prevGraphPoint = pointInfo
			
			end	
		
		end

	
	end
	
	
	
	return graphPanel

end

function CL_ANTICRASH.CreateUserInfoPanel(x, y, w, h, txt, colKey, funcKey, target, parent)
	
	local infoCol = CL_ANTICRASH.USERDATA.COL[colKey]
	local infoColFade = ColorAlpha(infoCol,50)
	local infoLblOffset = 5
	local edgeOffset = 2
	
	-- Info panel
	local infoPanel = vgui.Create("DPanel",parent)
	infoPanel:SetPos(x,y)
	infoPanel:SetSize(w,h)
	infoPanel.Paint = function(self, w, h)
		
		-- Bg
		draw.RoundedBox( 4, 0, 0, w, h, infoCol )
		
	end
	
	-- Info button
	/*
	local infoButton = vgui.Create("DButton",infoPanel)
	infoButton:SetSize(w,h)
	infoButton:SetText("")
	infoButton.Paint = function() end
	*/
	
	-- Info name
	CL_ANTICRASH.CreateInfoLabel(infoLblOffset,0,h,txt,SH_ANTICRASH.VARS.COLOR.DARKGREY, "z_anticrash_user_info_label", infoPanel)

	-- Info value
	local valLbl = CL_ANTICRASH.CreateInfoLabel(0,0,h,"",SH_ANTICRASH.VARS.COLOR.DARKGREY, "z_anticrash_user_info_label", infoPanel)
	
	-- Keep value up to date
	local nextThink = 0
	valLbl.Think = function()
	
		if !parent.isExpanded then return end
		
		if nextThink < CurTime() then
	
			local valTxt = CL_ANTICRASH.USERDATA[funcKey](target)
			
			valLbl:SetText(valTxt)
			valLbl:UpdateSize()
			valLbl:SetPos(infoPanel:GetWide()-infoLblOffset-valLbl:GetWide(),0)
			
			nextThink = CurTime() + 0.5
	
		end
	
	end
	
	return infoPanel
	
end

function CL_ANTICRASH.HookSearchInputFilter(searchInput, filterPanels)

	searchInput.OnChange = function(self)
		
		local filter = string.Trim( self:GetText():lower() ) 
		
		local prevFilterPnl = nil
		
		for i=1, #filterPanels do
		
			local filterStr, filterPanel = filterPanels[i].filterStr, filterPanels[i].filterPanel
			
			-- show panel if there is no filter or the filter matches
			if #filter == 0 or string.find( filterStr:lower(), filter, 1, true ) ~= nil then
			
				-- set filtered panel to auto adjust position
				if prevFilterPnl ~= nil then
					filterPanel.prevPnl = prevFilterPnl
				else
					-- make sure the first filtered result is on the start position
					filterPanel.prevPnl = nil
					filterPanel:SetPos(5,searchInput:GetBottomY()+filterPanel.panelOffset)
				end
			
				filterPanel:SetVisible(true)
				
				prevFilterPnl = filterPanel
				
				continue
			end
			
			filterPanel:Hide()
		
		end
		
	end

end

function CL_ANTICRASH.SkinScrollPanel(scrollP)
	
	local sbar = scrollP:GetVBar()
	
	sbar:SetWide(3)
	sbar:SetHideButtons( true )
	
	function sbar:Paint( w, h )
	end
	
	function sbar.btnGrip:Paint( w, h )
		draw.RoundedBox( 0, 0, 0, w, h, color_white )
	end

end
--addons/tools_advdupe/lua/autorun/client/advdupe2_cl_init.lua:
AdvDupe2 = {
	Version = "1.1.0",
	Revision = 51,
	InfoText = {},
	DataFolder = "advdupe2",
	FileRenameTryLimit = 256,
	ProgressBar = {}
}

if(!file.Exists(AdvDupe2.DataFolder, "DATA"))then
	file.CreateDir(AdvDupe2.DataFolder)
end

include( "advdupe2/file_browser.lua" )
include( "advdupe2/sh_codec.lua" )
include( "advdupe2/cl_file.lua" )
include( "advdupe2/cl_ghost.lua" )

function AdvDupe2.Notify(msg,typ,dur)
	surface.PlaySound(typ == 1 and "buttons/button10.wav" or "ambient/water/drip1.wav")
	GAMEMODE:AddNotify(msg, typ or NOTIFY_GENERIC, dur or 5)
	//if not game.SinglePlayer() then
		print("[AdvDupe2Notify]\t"..msg)
	//end
end

net.Receive("AdvDupe2Notify", function()
	AdvDupe2.Notify(net.ReadString(), net.ReadUInt(8), net.ReadFloat())
end)

--addons/tools_advdupe/lua/advdupe2/sh_codec_legacy.lua:
--[[
	Title: Adv. Dupe 2 Codec Legacy Support

	Desc: Facilitates opening of dupes from AD1 and earlier AD2 versions.

	Author: emspike

	Version: 2.0
]]

local pairs = pairs
local type = type
local tonumber = tonumber
local error = error
local Vector = Vector
local Angle = Angle
local format = string.format
local char = string.char
local byte = string.byte
local sub = string.sub
local gsub = string.gsub
local find = string.find
local gmatch = string.gmatch
local match = string.match
local concat = table.concat

--[[
	Name:	GenerateDupeStamp
	Desc:	Generates an info table.
	Params:	<player> ply
	Return:	<table> stamp
]]
function AdvDupe2.GenerateDupeStamp(ply)
	local stamp = {}
	stamp.name = ply:GetName()
	stamp.time = os.date("%I:%M %p")
	stamp.date = os.date("%d %B %Y")
	stamp.timezone = os.date("%z")
	hook.Call("AdvDupe2_StampGenerated",GAMEMODE,stamp)
	return stamp
end

local AD2FF = "AD2F%s\n%s\n%s"

local decode_types_v1, decode_types_v2
local tables = 0
local str,pos
local a,b,c,m,n,w,tblref

local function read_v2()
	local t = byte(str, pos+1)
	if t then
		local dt = decode_types_v2[t]
		if dt then
			pos = pos + 1
			return dt()
		else
			error(format("encountered invalid data type (%u)\n",t))
		end
	else
		error("expected value, got EOF\n")
	end
end

decode_types_v2 = {
	[1	] = function()
		error("expected value, got terminator\n")
	end,
	[2	] = function() -- table
		
		m = find(str, "\1", pos)
		if m then
			w = sub(str, pos+1, m-1)
			pos = m
		else
			error("expected table identifier, got EOF\n")
		end
		
		local t = {}
		tables[w] = t
		
		while true do
			if byte(str, pos+1) == 1 then
				pos = pos + 1
				return t
			else
				t[read_v2()] = read_v2()
			end
		end
	end,
	[3	] = function() -- array
		
		m = find(str, "\1", pos)
		if m then
			w = sub(str, pos+1, m-1)
			pos = m
		else
			error("expected table identifier, got EOF\n")
		end
		
		local t, i = {}, 1
		
		tables[w] = t
		
		while true do
			if byte(str,pos+1) == 1 then
				pos = pos+1
				return t
			else
				t[i] = read_v2()
				i = i + 1
			end
		end
	end,
	[4	] = function() -- false boolean
		return false
	end,
	[5	] = function() -- true boolean
		return true
	end,
	[6	] = function() -- number
		m = find(str, "\1", pos)
		if m then
			a = tonumber(sub(str, pos+1, m-1)) or 0
			pos = m
			return a
		else
			error("expected number, got EOF\n")
		end
	end,
	[7	] = function() -- string
		m = find(str,"\1",pos)
		if m then
			w = sub(str, pos+1, m-1)
			pos = m
			return w
		else
			error("expected string, got EOF\n")
		end
	end,
	[8	] = function() -- Vector
		m,n = find(str,".-\1.-\1.-\1", pos)
		if m then
			a,b,c = match(str,"^(.-)\1(.-)\1(.-)\1",pos+1)
			pos = n
			return Vector(tonumber(a), tonumber(b), tonumber(c))
		else
			error("expected vector, got EOF\n")
		end
	end,
	[9	] = function() -- Angle
		m,n = find(str, ".-\1.-\1.-\1", pos)
		if m then
			a,b,c = match(str, "^(.-)\1(.-)\1(.-)\1",pos+1)
			pos = n
			return Angle(tonumber(a), tonumber(b), tonumber(c))
		else
			error("expected angle, got EOF\n")
		end
	end,
	[10	] = function() -- Table Reference
		m = find(str,"\1",pos)
		if m then
			w = sub(str,pos+1,m-1)
			pos = m
		else
			error("expected table identifier, got EOF\n")
		end
		tblref = tables[w]
		
		if tblref then
			return tblref
		else
			error(format("table identifier %s points to nil\n", w))
		end
		
	end
}



local function read_v1()
	local t = byte(str,pos+1)
	if t then
		local dt = decode_types_v1[t]
		if dt then
			pos = pos + 1
			return dt()
		else
			error(format("encountered invalid data type (%u)\n",t))
		end
	else
		error("expected value, got EOF\n")
	end
end

decode_types_v1 = {
	[1	] = function()
		error("expected value, got terminator\n")
	end,
	[2	] = function() -- table
		local t = {}
		while true do
			if byte(str,pos+1) == 1 then
				pos = pos+1
				return t
			else
				t[read_v1()] = read_v1()
			end
		end
	end,
	[3	] = function() -- array
		local t, i = {}, 1
		while true do
			if byte(str,pos+1) == 1 then
				pos = pos+1
				return t
			else
				t[i] = read_v1()
				i = i + 1
			end
		end
	end,
	[4	] = function() -- false boolean
		return false
	end,
	[5	] = function() -- true boolean
		return true
	end,
	[6	] = function() -- number
		m = find(str,"\1",pos)
		if m then
			a = tonumber(sub(str,pos+1,m-1)) or 0
			pos = m
			return a
		else
			error("expected number, got EOF\n")
		end
	end,
	[7	] = function() -- string
		m = find(str,"\1",pos)
		if m then
			w = sub(str,pos+1,m-1)
			pos = m
			return w
		else
			error("expected string, got EOF\n")
		end
	end,
	[8	] = function() -- Vector
		m,n = find(str,".-\1.-\1.-\1",pos)
		if m then
			a,b,c = match(str,"^(.-)\1(.-)\1(.-)\1",pos+1)
			pos = n
			return Vector(tonumber(a), tonumber(b), tonumber(c))
		else
			error("expected vector, got EOF\n")
		end
	end,
	[9	] = function() -- Angle
		m,n = find(str,".-\1.-\1.-\1",pos)
		if m then
			a,b,c = match(str,"^(.-)\1(.-)\1(.-)\1",pos+1)
			pos = n
			return Angle(tonumber(a), tonumber(b), tonumber(c))
		else
			error("expected angle, got EOF\n")
		end
	end
}

local function deserialize_v1(data)
	str = data
	pos = 0
	tables = {}
	return read_v1()
end

local function deserialize_v2(data)
	str = data
	pos = 0
	tables = {}
	return read_v2()
end

local function lzwDecode(encoded)
	local dictionary_length = 256
	local dictionary = {}
	for i = 0, 255 do
		dictionary[i] = char(i)
	end
	
	local pos = 2
	local decompressed = {}
	local decompressed_length = 1
	
	local index = byte(encoded)
	local word = dictionary[index]
	
	decompressed[decompressed_length] = dictionary[index]
	
	local entry
	local encoded_length = #encoded
	local firstbyte --of an index
	while pos <= encoded_length do
		firstbyte = byte(encoded,pos)
		if firstbyte > 252 then --now we know it's a length indicator for a multibyte index
			index = 0
			firstbyte = 256 - firstbyte
			
			--[[if pos+firstbyte > encoded_length then	--will test for performance impact
				error("expected index got EOF")
			end]]
			
			for i = pos+firstbyte, pos+1, -1 do
				index = bit.bor(bit.lshift(index, 8), byte(encoded,i))
			end
			pos = pos + firstbyte + 1
		else
			index = firstbyte
			pos = pos + 1
		end
		entry = dictionary[index] or (word..sub(word,1,1))
		decompressed_length = decompressed_length + 1
		decompressed[decompressed_length] = entry
		dictionary[dictionary_length] = word..sub(entry,1,1)
		dictionary_length = dictionary_length + 1
		word = entry
	end
	return concat(decompressed)
end

--http://en.wikipedia.org/wiki/Huffman_coding#Decompression

local invcodes = {[2]={[0]="\254"},[5]={[22]="\1",[11]="\2"},[6]={[13]="\7",[35]="\6",[37]="\5",[58]="\3",[31]="\8",[9]="\13",[51]="\9",[55]="\10",[57]="\4",[59]="\15"},[7]={[1]="\14",[15]="\16",[87]="\31",[89]="\30",[62]="\26",[17]="\27",[97]="\19",[19]="\43",[10]="\12",[39]="\33",[41]="\24",[82]="\40",[3]="\32",[46]="\41",[47]="\38",[94]="\25",[65]="\23",[50]="\39",[26]="\11",[7]="\28",[33]="\18",[61]="\17",[25]="\42"},[8]={[111]="\101",[162]="\29",[2]="\34",[133]="\21",[142]="\36",[5]="\20",[21]="\37",[170]="\44",[130]="\22",[66]="\35"},[9]={[241]="\121",[361]="\104",[365]="\184",[125]="\227",[373]="\198",[253]="\117",[381]="\57",[270]="\49",[413]="\80",[290]="\47",[294]="\115",[38]="\112",[429]="\74",[433]="\0",[437]="\48",[158]="\183",[453]="\107",[166]="\111",[469]="\182",[477]="\241",[45]="\86",[489]="\69",[366]="\100",[497]="\61",[509]="\76",[49]="\53",[390]="\78",[279]="\196",[283]="\70",[414]="\98",[53]="\55",[422]="\109",[233]="\79",[349]="\89",[369]="\52",[14]="\105",[238]="\56",[319]="\162",[323]="\83",[327]="\63",[458]="\65",[335]="\231",[339]="\225",[337]="\114",[347]="\193",[493]="\139",[23]="\209",[359]="\250",[490]="\68",[42]="\54",[63]="\91",[286]="\97",[254]="\50",[510]="\108",[109]="\73",[67]="\103",[255]="\122",[69]="\170",[70]="\110",[407]="\176",[411]="\119",[110]="\120",[83]="\146",[149]="\163",[151]="\224",[85]="\51",[155]="\177",[79]="\251",[27]="\118",[447]="\159",[451]="\228",[455]="\175",[383]="\174",[463]="\243",[467]="\157",[173]="\210",[475]="\167",[177]="\84",[90]="\45",[487]="\206",[93]="\226",[495]="\245",[207]="\64",[127]="\147",[191]="\155",[511]="\153",[195]="\208",[197]="\85",[199]="\178",[181]="\82",[102]="\116",[103]="\71",[285]="\144",[105]="\102",[211]="\199",[213]="\123",[301]="\66",[305]="\46",[219]="\137",[81]="\67",[91]="\88",[157]="\130",[325]="\95",[29]="\58",[231]="\201",[117]="\99",[341]="\222",[237]="\77",[239]="\211",[71]="\223"},[10]={[710]="\149",[245]="\60",[742]="\172",[774]="\81",[134]="\151",[917]="\145",[274]="\216",[405]="\242",[146]="\194",[838]="\246",[298]="\248",[870]="\189",[1013]="\150",[894]="\190",[326]="\244",[330]="\166",[334]="\217",[465]="\179",[346]="\59",[354]="\180",[966]="\212",[974]="\143",[370]="\148",[998]="\154",[625]="\138",[382]="\161",[194]="\141",[198]="\126",[402]="\96",[206]="\185",[586]="\129",[721]="\187",[610]="\135",[618]="\181",[626]="\72",[226]="\62",[454]="\127",[658]="\113",[462]="\164",[234]="\214",[474]="\140",[242]="\106",[714]="\188",[730]="\87",[498]="\237",[746]="\125",[754]="\229",[786]="\128",[202]="\93",[18]="\255",[810]="\173",[846]="\131",[74]="\192",[842]="\142",[977]="\252",[858]="\235",[78]="\134",[874]="\234",[882]="\90",[646]="\92",[1006]="\160",[126]="\165",[914]="\221",[718]="\94",[738]="\238",[638]="\197",[482]="\230",[34]="\220",[962]="\133",[6]="\213",[706]="\219",[986]="\171",[994]="\233",[866]="\200",[1010]="\247",[98]="\169",[518]="\236",[494]="\207",[230]="\205",[542]="\191",[501]="\202",[530]="\203",[450]="\204",[209]="\158",[106]="\186",[590]="\136",[218]="\232",[733]="\124",[309]="\168",[221]="\152",[757]="\240",[113]="\215",[114]="\156",[362]="\239",[486]="\132",[358]="\249",[262]="\75",[30]="\218",[821]="\195",[546]="\253"}}

local function huffmanDecode(encoded)
	
	local h1,h2,h3 = byte(encoded, 1, 3)
	
	if (not h3) or (#encoded < 4) then
		error("invalid input")
	end
	
	local original_length = bit.bor(bit.lshift(h3,16), bit.lshift(h2,8), h1)
	local encoded_length = #encoded+1
	local decoded = {}
	local decoded_length = 0
	local buffer = 0
	local buffer_length = 0
	local code
	local code_len = 2
	local temp
	local pos = 4
	
	while decoded_length < original_length do
		if code_len <= buffer_length then
			temp = invcodes[code_len]
			code = bit.band(buffer, bit.lshift(1, code_len)-1)
			if temp and temp[code] then --most of the time temp is nil
				decoded_length = decoded_length + 1
				decoded[decoded_length] = temp[code]
				buffer = bit.rshift(buffer, code_len)
				buffer_length = buffer_length - code_len
				code_len = 2
			else
				code_len = code_len + 1
				if code_len > 10 then
					error("malformed code")
				end
			end
		else
			buffer = bit.bor(buffer, bit.lshift(byte(encoded, pos), buffer_length))
			buffer_length = buffer_length + 8
			pos = pos + 1
			if pos > encoded_length then
				error("malformed code")
			end
		end
	end
	
	return concat(decoded)
end

local function invEscapeSub(str)
	local escseq,body = match(str,"^(.-)\n(.-)$")
	
	if not escseq then error("invalid input") end
	
	return gsub(body,escseq,"\26")
end

local dictionary
local subtables

local function deserializeChunk(chunk)
	
	local ctype,val = byte(chunk),sub(chunk,3)
	
	if     ctype == 89 then return dictionary[ val ]
	elseif ctype == 86 then
		local a,b,c = match(val,"^(.-),(.-),(.+)$")
		return Vector( tonumber(a), tonumber(b), tonumber(c) )
	elseif ctype == 65 then
		local a,b,c = match(val,"^(.-),(.-),(.+)$")
		return Angle( tonumber(a), tonumber(b), tonumber(c) )
	elseif ctype == 84 then 
		local t = {}
		local tv = subtables[val]
		if not tv then
			tv = {}
			subtables[ val ] = tv
		end
		tv[#tv+1] = t
		return t
	elseif ctype == 78 then return tonumber(val)
	elseif ctype == 83 then return gsub(sub(val,2,-2),"",";")
	elseif ctype == 66 then return val == "t"
	elseif ctype == 80 then return 1
	end
	
	error(format("AD1 deserialization failed: invalid chunk (%u:%s)",ctype,val))
	
end

local function deserializeAD1(dupestring)
	
	dupestring = dupestring:Replace("\r\n", "\n")
	local header, extraHeader, dupeBlock, dictBlock = dupestring:match("%[Info%]\n(.+)\n%[More Information%]\n(.+)\n%[Save%]\n(.+)\n%[Dict%]\n(.+)")
	
	if not header then
		error("unknown duplication format")
	end
	
	local info = {}
	for k,v in header:gmatch("([^\n:]+):([^\n]+)") do
		info[k] = v
	end
		
	local moreinfo = {}
	for k,v in extraHeader:gmatch("([^\n:]+):([^\n]+)") do
		moreinfo[k] = v
	end
	
	dictionary = {}
	for k,v in dictBlock:gmatch("(.-):\"(.-)\"\n") do
		dictionary[k] = v
	end

	local dupe = {}
	for key,block in dupeBlock:gmatch("([^\n:]+):([^\n]+)") do
		
		local tables = {}
		subtables = {}
		local head
		
		for id,chunk in block:gmatch('(%w+){(.-)}') do
			
			--check if this table is the trunk
			if byte(id) == 72 then
				id = sub(id,2)
				head = id
			end
			
			tables[id] = {}
			
			for kv in gmatch(chunk,'[^;]+') do
				
				local k,v = match(kv,'(.-)=(.+)')
				
				if k then
					k = deserializeChunk( k )
					v = deserializeChunk( v )
					
					tables[id][k] = v
				else
					v = deserializeChunk( kv )
					local tid = tables[id]
					tid[#tid+1]=v
				end
				
			end
		end
		
		--Restore table references
		for id,tbls in pairs( subtables ) do
			for _,tbl in pairs( tbls ) do
				if not tables[id] then error("attempt to reference a nonexistent table") end
				for k,v in pairs(tables[id]) do
					tbl[k] = v
				end
			end
		end
		
		dupe[key] = tables[ head ]
		
	end
	
	return dupe, info, moreinfo
	
end

--seperates the header and body and converts the header to a table
local function getInfo(str)
	local last = str:find("\2")
	if not last then
		error("attempt to read AD2 file with malformed info block error 1")
	end
	local info = {}
	local ss = str:sub(1,last-1)
	for k,v in ss:gmatch("(.-)\1(.-)\1") do
		info[k] = v
	end
	if info.check ~= "\r\n\t\n" then
		if info.check == "\10\9\10" then
			error("detected AD2 file corrupted in file transfer (newlines homogenized)(when using FTP, transfer AD2 files in image/binary mode, not ASCII/text mode)")
		else
			error("attempt to read AD2 file with malformed info block error 2")
		end
	end
	return info, str:sub(last+2)
end

--decoders for individual versions go here
local versions = {}

versions[2] = function(encodedDupe)
	encodedDupe = encodedDupe:Replace("\r\r\n\t\r\n", "\t\t\t\t")
	encodedDupe = encodedDupe:Replace("\r\n\t\n", "\t\t\t\t")
	encodedDupe = encodedDupe:Replace("\r\n", "\n")
	encodedDupe = encodedDupe:Replace("\t\t\t\t", "\r\n\t\n")
	local info, dupestring = getInfo(encodedDupe:sub(7))
	return deserialize_v2(
				lzwDecode(
					huffmanDecode(
						invEscapeSub(dupestring)
					)
				)
			), info
end

versions[1] = function(encodedDupe)
	encodedDupe = encodedDupe:Replace("\r\r\n\t\r\n", "\t\t\t\t")
	encodedDupe = encodedDupe:Replace("\r\n\t\n", "\t\t\t\t")
	encodedDupe = encodedDupe:Replace("\r\n", "\n")
	encodedDupe = encodedDupe:Replace("\t\t\t\t", "\r\n\t\n")
	local info, dupestring = getInfo(encodedDupe:sub(7))
	return deserialize_v1(
				lzwDecode(
					huffmanDecode(
						invEscapeSub(dupestring)
					)
				)
			), info
end

versions[0] = deserializeAD1

AdvDupe2.LegacyDecoders = versions
--addons/wos-passiveevent-ageo/lua/wos/pes/vgui/wos_nodebackground.lua:
--[[-------------------------------------------------------------------]]--[[

	Copyright wiltOS Technologies LLC, 2021

	Contact: www.wiltostech.com

----------------------------------------]]--

























































































































































local PANEL = {}

local bgMaterial = Material("wos/pes/bg.png", "noclamp smooth")
local borderBlack = Color(0, 0, 0, 150)
local bgBlack = Color(36,36,36) -- annoyingly 1 rgb off when actual rendering from the png WHY SOURCE WHYYYYY
local bgLighter = Color(255,255,255,100)
local bgWhite = Color(200,200,200)

PANEL.CreationType = WOS_PES.CREATOR.EVENT
PANEL.MatrixCore = Matrix()
PANEL.ZoomScale = 1
PANEL.PES_Element = true

function PANEL:PushBackgroundScale()
    local zoom_scale = self:GetZoomScale()
    local scale = ( 1 - zoom_scale )*0.5
    self.MatrixCore:SetScale( Vector( zoom_scale, zoom_scale, 1 ) )
    local tall, wide = self:GetTall(), self:GetWide()
    self.MatrixCore:SetTranslation( Vector( wide*scale, tall*scale, 0 ) )
    cam.PushModelMatrix(self.MatrixCore)
end

function PANEL:PopBackgroundScale()
    cam.PopModelMatrix()
end

function PANEL:Init()
    self.DirtyNodes = false
    self.LastKey = 0
    self.Nodes = {}
    self.Name = ""
    self.Links = {}

    self._x = 0
    self._y = 0

    self._tx = 0
    self._ty = 0

    self._background = vgui.Create("DButton", self)
    self._background:SetSize(1920*4, 1920*4)
    self._background:Center()
    self._background:SetText("")
    //self._background:NoClipping( true )
    self._background.PES_BACKGROUND = true
    self._background.Paint = function(sef, w, h)

        self.WasClippedDisabled = DisableClipping( true )
        self:PushBackgroundScale()

		surface.SetDrawColor(255,255,255,255)
		surface.SetMaterial(bgMaterial)
		surface.DrawTexturedRectUV(0,0,w,h,0,0,w*self:GetZoomScale(), h*self:GetZoomScale())

        for pnl, triggerLinks in pairs(self.Links) do
            if !IsValid(pnl) then
                self:NodeRemove(pnl)
                continue
            end

            for triggerName, panelTable in pairs(triggerLinks) do
                for index, oPnl in ipairs(panelTable) do
                    if !IsValid(oPnl) then
                        self:RemoveLink(pnl, triggerName, oPnl)
                        continue
                    end

                    local x,y = pnl:GetPos()
                    local w,h = oPnl:GetPos()
                    local posY, id, col = pnl:GetTriggerPos(triggerName)

                    if !posY then
                        self:RemoveLink(pnl, triggerName, oPnl)
                        continue
                    end

                    h = h + oPnl:GetTall()*0.5
                    y = y + posY

                    x = x + pnl:GetWide() + pnl:GetWide()*0.04
                    col = col or color_white

                    surface.SetDrawColor( col )
                    surface.DrawLine( x, y, w, h )
                end
            end
        end

        // Draw the child nodes
        for _, child in ipairs( sef:GetChildren() ) do
            if not child.RecursiveManualPaint then continue end
            child:RecursiveManualPaint()
        end

        DisableClipping( self.WasClippedDisabled )
        self:PopBackgroundScale()
    end

    local ohover = self._background.TestHover
    self._background.TestHover = function( bg, mx, my )
        mx, my = self:GetZoomedCursorPos(mx, my)
        mx, my = bg:ScreenToLocal( mx, my )
        local bx, by = bg:GetSize()
        return ( mx >= 0 ) && ( my >= 0 ) && ( mx <= bx ) && ( my <= by )
    end

    self._background.OnDepressed = function( s )
        if input.IsMouseDown( MOUSE_LEFT ) then
            self.SelectedPanel = nil
        end
        self:StartDragging()
    end

    self._background.OnReleased = function( s )
        self:StopDragging()
    end

    local tools = vgui.Create("DPanel", self)
    tools:SetWide(70)
    tools:SetHeight(self:GetTall()-60)
	tools.Paint = function(self, w, h)
		draw.RoundedBox(4, 0, 0, w, h, borderBlack)
		draw.RoundedBox(4, 4, 4, w-8, h-8, bgBlack)
		draw.RoundedBox(4, 4, 4, w-8, h-8, bgLighter)
	end

    local addNode = vgui.Create("DButton", tools)
    addNode:SetSize(60,60)
    addNode:Dock(TOP)
    addNode:DockMargin(6,5,6,5)
    addNode:SetText("Add\nNode")
    addNode.DoClick = function()
		self:OpenNode()
	end
	addNode.Paint = function(self, w, h)
		draw.RoundedBox(4, 0, 0, w, h, borderBlack)
		draw.RoundedBox(4, 4, 4, w-8, h-8, bgWhite)
		if self.Hovered then
			draw.RoundedBox(4, 4, 4, w-8, h-8, bgLighter)
		end
	end

    local printEvent = vgui.Create("DButton", tools)
    printEvent:SetSize(60, 60)
    printEvent:Dock(TOP)
    printEvent:DockMargin(6,5,6,5)
    printEvent:SetText("Save\nEvent")
	printEvent.Paint = function(self, w, h)
		draw.RoundedBox(4, 0, 0, w, h, borderBlack)
		draw.RoundedBox(4, 4, 4, w-8, h-8, bgWhite)
		if self.Hovered then
			draw.RoundedBox(4, 4, 4, w-8, h-8, bgLighter)
		end
	end
    printEvent.DoClick = function( pan )
        if not self:SanityCheckNodes() then return end
        local tbl = {
            Name = "",
            oldname = self.Name,
            Nodes = {},
        }

        if self.Imported then
            tbl.oldname = ""
        end

        for index, node in ipairs(self.Nodes) do

            if node.IsOpen then
                node:NodeClose()
            end

            local eventTbl = {
                ID = node.ID,
                Type = node.Type,
                Triggers = {},
                Pos = {},
                _vars = node:GetVars(),
                _toggles = {},
            }

            eventTbl.Pos.x, eventTbl.Pos.y = node:GetPos()

            local nodeData = wOS.PES.Nodes:Get(node.Type)

            if !nodeData and node:IsStart() then
                nodeData = {Triggers = {"Instant"}}
            end

            if self.Links[node] then
                for triggerName, panelTable in pairs(self.Links[node]) do
                    local tbl = {}
                    for _, oPnl in pairs(panelTable) do
                        tbl[#tbl + 1] = oPnl.ID
                    end
                    eventTbl.Triggers[triggerName] = tbl
                end
            end

            if nodeData and nodeData.Vars then
                for name, varData in pairs( nodeData.Vars ) do // make this run a getValue on it.
                    // Why not make this one line? Because lua don't like dealing with one liners and bools apparently??
                    local var = node:GetVar( name )
                    if var == nil then
                        var = varData.Default
                    end
                    eventTbl._vars[name] = var

                    local disabled = node:GetVarDisabled( name )
                    if not disabled then continue end
                    eventTbl._toggles[name] = disabled
                end
            end

            if nodeData and nodeData.Triggers then
                for index, tdata in ipairs(nodeData.Triggers) do

                    local triggerName = tdata
                    if istable( tdata ) then
                        triggerName = tdata.Type or triggerName
                    end

                    local triggerData = wOS.PES.Triggers:Get(triggerName)
					if not triggerData then break end
                    for name, varData in pairs( triggerData.Vars ) do
                        // Why not make this one line? Because lua don't like dealing with one liners and bools apparently??
                        local var = node:GetVar( name )
                        if var == nil then
                            var = varData.Default
                        end
                        eventTbl._vars[name] = var
                        local disabled = node:GetVarDisabled( name )
                        if not disabled then continue end
                        eventTbl._toggles[name] = disabled
                    end
                end
            end

            tbl.Nodes[node.ID] = eventTbl
        end
        self:CreateSaveBox( tbl )
    end
    self._tools = tools
end

function PANEL:AddToolBox( tools )
    -- for overrides
end

function PANEL:SetupTool()
    -- for overrides
end

function PANEL:CreateSaveBox( event_tbl )
    local dummy_frame = vgui.Create( "DFrame" )
    dummy_frame:SetSize( ScrW(), ScrH() )
    dummy_frame:SetTitle( "" )
    dummy_frame:SetDraggable( false )
    dummy_frame:ShowCloseButton( false )
    dummy_frame.Paint = function( pan, ww, hh )
        draw.RoundedBox(0, 0, 0, ww, hh, Color( 0, 0, 0, 200 ) )
    end
    dummy_frame:MakePopup()

    local dframe = vgui.Create("DFrame", dummy_frame)
    dframe:MakePopup()
    dframe:SetSize(300, 300)
    dframe:SetTitle( "" )
    dframe.Think = function( pan )
        pan:MoveToFront()
    end
    dframe:Center()

    dummy_frame.Think = function( pan )
        if not IsValid( dframe ) then
            pan:Remove()
        end
    end

    local textentry = vgui.Create("DTextEntry", dframe)
    textentry:SetSize(280, 20)
    textentry:SetPos(10, 30)
    textentry:SetPlaceholderText("Event Name")
    if self.Name != "" then
        textentry:SetText(self.Name)
    end

    local descriptentry = vgui.Create("DTextEntry", dframe)
    descriptentry:SetSize(280, 20)
    descriptentry:SetPos(10, 60)
    descriptentry:SetText( "No description available" )
    descriptentry:SetPlaceholderText("Simulation Description")
    if self.Description then
        descriptentry:SetText(self.Description)
    end

    local random = vgui.Create("DTextEntry", dframe)
    random:SetSize(280, 20)
    random:SetPos(10, 110)
    random:SetPlaceholderText("Event Randomness")
    random:SetPlaceholderText("Random Chance")
    if self.random != nil then
        random:SetText(self.random)
    end

    local randombuton = vgui.Create("DCheckBoxLabel", dframe)
    randombuton:SetSize(20,20)
    randombuton:SetPos(10, 90)
    randombuton:SetText("Start Event Randomly?")
    randombuton.OnChange = function(self, val)
        random:SetEnabled(val)
        if !val then random:SetText("") end
    end

    if self.random != nil and self.random != 0 then
        randombuton:SetChecked(true)
        random:SetEnabled(true)
    else
        random:SetEnabled(false)
    end

    local importbut = vgui.Create("DCheckBoxLabel", dframe)
    importbut:SetSize(20,20)
    importbut:SetPos(10, 140)
    importbut:SetText("Allow for import/export")
    importbut:SetChecked( self.Importable )

    local urlbut = vgui.Create("DCheckBoxLabel", dframe)
    urlbut:SetSize(20,20)
    urlbut:SetPos(10, 250)
    urlbut:SetText("Export to URL on Confirm")
    urlbut:SetChecked( false )

    local but = vgui.Create("DButton", dframe)
    but:SetSize(60, 20)
    but:SetText("Confirm")
    but:SetPos(225, 270)
    but.DoClick =  function()
        event_tbl.Name = textentry:GetText()
        if #event_tbl.Name < 1 then
            notification.AddLegacy( "[wOS-PES] Can not leave event name blank!", NOTIFY_ERROR, 3 )
            return
        end
        event_tbl.Description = descriptentry:GetText()
        event_tbl.Importable = importbut:GetChecked()
        event_tbl.random = math.Round( math.abs(tonumber(random:GetText()) or 0))
        event_tbl.Export = urlbut:GetChecked()
        dummy_frame:Remove()
        wOS.PES.NetworkEvent(event_tbl)

    end


    urlbut.OnChange = function(self, val)
        if val then
            but:SetText("Confirm and Export")
            but:SetSize(120, 20)
            but:SetPos(165, 270)
        else
            but:SetText("Confirm")
            but:SetSize(60, 20)
            but:SetPos(225, 270)
        end
    end

end

function PANEL:OnSizeChanged(nW, nH)
    self._background:Center()
    self._tools:SetHeight(nH-60)
    self._tools:SetPos(nW - self._tools:GetWide(), 30)
end

function PANEL:GetCenter()
    local aX = self._background:GetWide()/2 - self._x
    local aY = self._background:GetTall()/2 - self._y

    return aX, aY
end

function PANEL:GetZoomScale()
    return self.ZoomScale
end


    -- local base_offsetx = lcx - boundx/2
    -- local base_offsety = lcy - boundy/2
    -- local new_lcx, new_lcy = lcx - (boundx/2)*zoomscale, lcy - (boundy/2)*zoomscale
function PANEL:GetZoomedCursorPos(mx, my)
    if self:GetZoomScale() >= 1 then return mx, my end
    local bg = self._background
    local zoomscale = self:GetZoomScale()

    local ox, oy = self:LocalToScreen( self:GetPos() )
    local lcx, lcy = (ScrW() - ox*0.5)*0.5, (ScrH() - oy*0.5)*0.5
    local mouse_offx, mouse_offy = mx - lcx, my - lcy

    mx = lcx + mouse_offx/zoomscale
    my = lcy + mouse_offy/zoomscale

    return mx, my
end

function PANEL:CreateStartNode()
    local start = self:AddNode("Start", true)
    start.Type = nil
    start:CreateLinks()
    start:SetMainLink(false)
    start:SetAsStart( true )

    //I pulled this out of the node vgui because this won't always be done
    start.DeleteButton:Remove()
    start.ExpandButton:Remove()
    return start
end

function PANEL:AddNode(name, nofunc)
    local id = #self.Nodes + 1
    local x,y = self:GetCenter()
    local dbutton = vgui.Create("WOS_PES_NODE", self._background)

    dbutton.main = self
	local wide = 280 * (ScrW()/1920)
    local tall = wide*0.8
	dbutton:SetSize( wide, tall )
    dbutton:SetPos( x-wide/2, y-tall/2  )

	dbutton.ID = id
	dbutton:SetFont( "wOS.PES.NodeText" )
    dbutton.TextName = name
	dbutton.Type = name

    if not nofunc then
        dbutton:RecalculateName()
        dbutton:CreateLinks()
    end

    self.Nodes[id] = dbutton

    return dbutton
end

function PANEL:StartDragging()
    self.Dragging = true

    if IsValid(self.ViewingNode) then
        self.ViewingNode:NodeClose()
        self.ViewingNode = false
    end

    local x,y = self:GetCursorPos()

    self.mousepos = {x = x, y = y}
end

local speed = 100

function PANEL:OpenEventSelector( events )
    if self.EventList then
        self.EventList:Remove()
    end
    self.EventList = vgui.Create( "DFrame", self )
    self.EventList:SetSize( ScrW(), ScrH() )
    self.EventList:SetTitle( "" )
    self.EventList:ShowCloseButton( false )
    self.EventList:SetDraggable( false )
    self.EventList.Paint = function( pan, ww, hh )
        draw.RoundedBox(0, 0, 0, ww, hh, Color( 0, 0, 0, 200 ) )
    end
    self.EventList:MakePopup()

	local pnl = vgui.Create("DFrame", self)
	pnl:SetSize(ScrW() / 1.5, ScrH()/1.5)
	pnl:MakePopup()
	pnl:Center()
	pnl:SetTitle("")
	pnl:SetDraggable(false)
	pnl:ShowCloseButton(false)
	pnl.Think = function( pan )
		pan:MoveToFront()
	end
	pnl.Paint = function(self, w,h)
		surface.SetDrawColor(35.5,35.5,35.5)
		surface.DrawRect(0,0, w, h)
	end

    self.EventList.Think = function( pan )
        if not IsValid( pnl ) then
            pan:Remove()
        end
    end


	local close = vgui.Create("DButton", pnl)
	close:SetSize(20,20)
	close:SetPos(pnl:GetWide() - 20, 0)
    close:SetText("")
    close.Paint = function(self, w, h)
        local col = Color(255, 255, 255, (self.Hovered and 255) or 150)

        surface.SetDrawColor(col)
        surface.DrawLine(0,0, w, h)
        surface.DrawLine(w,0, 0, h)
    end
    close.DoClick = function() pnl:Remove() end

	local cats = vgui.Create("DPanel", pnl)
	cats:Dock(LEFT)
	cats:SetWide(200)
	cats:DockMargin(0,0, 5, 0)

	cats.Known = {}

	local pnls = {}

	local recalculateButs

	local scroll = vgui.Create("DScrollPanel", pnl)
	scroll:Dock(FILL)

	local List = vgui.Create( "DIconLayout", scroll )
	List:Dock( FILL )
	List:SetSpaceY( 10 )
	List:SetSpaceX( 10 )

	local impbutt = vgui.Create("DButton", cats)
	impbutt:Dock(BOTTOM)
	impbutt:DockMargin(4,4,4,4)
	impbutt:SetTall(20)
	impbutt:SetText( "Import From URL" )
    impbutt.DoClick = function( pan )
        pnl:Hide()
        local dframe = vgui.Create("DFrame", self.EventList )
        dframe:MakePopup()
        dframe:ShowCloseButton( false )
        dframe:SetDraggable( false )
        dframe:SetSize(300, 300)
        dframe:SetTitle( "" )
        dframe.Think = function( pan )
            pan:MoveToFront()
        end
        dframe:Center()

        local textentry = vgui.Create("DLabel", dframe )
        textentry:SetWrap( true )
        textentry:SetText("")
        textentry:SetPos( 10, 35 )
        textentry:SetSize( 280, 130 )
        textentry.Paint = function( pan, ww, hh )
            local text = "Input a URL below that leads DIRECTLY to the exported event text\n\n----------WARNING----------\n\nVERIFY THAT ALL SOURCES ARE COMPLETELY TRUSTED BEFORE IMPORTING AN EVENT!"
            text = wOS.PES.WrapText( text, "Trebuchet18", ww*0.95 )
            draw.DrawText(text, "Trebuchet18", ww/2, 0, color_white, TEXT_ALIGN_CENTER )
        end

        local utextentry = vgui.Create("DTextEntry", dframe )
        utextentry:SetSize(260, 30)
        utextentry:SetText( "INPUT URL HERE" )
        utextentry:SetPos(20, 180)

        local no = vgui.Create("DButton", dframe)
        no:SetSize(260, 20)
        no:SetText("GO BACK")
        no:SetPos(20, 260)
        no.Data = pan.Data
        no.DoClick =  function( pann )
            pnl:Show()
            dframe:Remove()
        end

        local yes = vgui.Create("DButton", dframe)
        yes:SetSize(260, 20)
        yes:SetText("FETCH EVENT")
        yes:SetPos(20, 230)
        yes.Data = pan.Data
        yes.DoClick =  function( pann )
            local text = utextentry:GetText()
            if #text < 1 then return end
            wOS.PES.RequestURLImport(text, function( data )
                local estruct = {}
                if data.Event then
                    estruct = data.Event
                else
                    estruct = data
                end
                wOS.PES:OpenNodeMenu( estruct, data.Dirty )
            end )
        end
    end

	local newbutt = vgui.Create("DButton", cats)
	newbutt:Dock(BOTTOM)
	newbutt:DockMargin(4,4,4,4)
	newbutt:SetTall(20)
	newbutt:SetText( "Create New Event" )
    newbutt.DoClick = function( pan )
        pnl:Hide()
        local dframe = vgui.Create("DFrame", self.EventList )
        dframe:MakePopup()
        dframe:ShowCloseButton( false )
        dframe:SetDraggable( false )
        dframe:SetSize(300, 100)
        dframe:SetTitle( "" )
        dframe.Think = function( pan )
            pan:MoveToFront()
        end
        dframe:Center()

        local textentry = vgui.Create("DLabel", dframe )
        textentry:SetWrap( true )
        textentry:SetText("Making a new event will completely delete any unsaved progress. Are you sure you want to create a new event?" )
        textentry:SetPos( 10, 5 )
        textentry:SetSize( 280, 65 )

        local no = vgui.Create("DButton", dframe)
        no:SetSize(60, 20)
        no:SetText("No")
        no:SetPos(25, 75)
        no.Data = pan.Data
        no.DoClick =  function( pann )
            pnl:Show()
            dframe:Remove()
        end

        local yes = vgui.Create("DButton", dframe)
        yes:SetSize(60, 20)
        yes:SetText("Yes")
        yes:SetPos(225, 75)
        yes.Data = pan.Data
        yes.DoClick =  function( pann )
            wOS.PES:OpenNodeMenu(nil,nil,true)
        end
    end

	local textentry = vgui.Create("DTextEntry", cats)
	textentry:Dock(TOP)
	textentry:DockMargin(4,4,4,4)
	textentry:SetTall(30)
	textentry.OnChange = function(self)
		recalculateButs()
	end

	local catScroll = vgui.Create("DScrollPanel", cats)
	catScroll:Dock(FILL)

	local catB = vgui.Create("DButton", catScroll)
	catB:Dock(TOP)
	catB:SetText("All")
	catB.DoClick = function()
		cats.Category = nil
		recalculateButs()
	end

	recalculateButs = function()
		local value = string.lower(textentry:GetText())

		for index, col in ipairs(pnls) do
			if string.find(string.lower(col.Name), value) and ( not cats.Category or ( col.Category == cats.Category)) then
				col:Show()
			else
				col:Hide()
			end
		end
		List:Layout()
	end

	for _, data in ipairs( events ) do
        local button = List:Add("DButton")
		button:SetSize(200, 200)
		button:SetText("")
		button.Name = data.Name
        button.Data = data

		local nam = wOS.PES.WrapText(data.Name, "wOS.PES.NodeText", button:GetWide()*0.9 )
		local descript = wOS.PES.WrapText(data.Description or "No description available", "DermaDefault", button:GetWide()*0.9 )

		button.Paint = function(self, w,h)
			draw.RoundedBox(6, 0, 0, w, h, Color(0, 0, 0, 255))
			draw.RoundedBox(5, 1, 1, w-2, h-2, Color(255, 255, 255, 127))

            local offset = h*0.02
            draw.DrawText(nam, "wOS.PES.NodeText", w/2, offset, color_black, TEXT_ALIGN_CENTER )

            surface.SetFont( "wOS.PES.NodeText" )
            local _, dH = surface.GetTextSize( nam )
            offset = offset + dH * 1.2

			draw.DrawText(descript, "DermaDefault", w*0.05, offset, color_black, TEXT_ALIGN_LEFT )

            //Add more as we go along
            if data.IsSimulation then
                draw.SimpleText("SIMULATION", "wOS.PES.CategoryText", w/2, h*0.98, Color( 0, 0, 0 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
            else
                draw.SimpleText("EVENT", "wOS.PES.CategoryText", w/2, h*0.98, Color( 0, 0, 0 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
            end
		end

		button.DoClick = function( pan )

            pnl:Hide()
            local dframe = vgui.Create("DFrame", self.EventList )
            dframe:MakePopup()
            dframe:ShowCloseButton( true )
            dframe:SetDraggable( false )
            dframe:SetSize(300, 100)
            dframe:SetTitle( "" )
            dframe.Think = function( pan )
                pan:MoveToFront()
            end
            dframe.OnClose = function()
                self.EventList:Remove()
            end
            dframe:Center()

            local textentry = vgui.Create("DLabel", dframe )
            textentry:SetWrap( true )
            textentry:SetText("Loading a new layout will completely delete any unsaved progress. Are you sure you want to load this event?\n    NAME: " .. pan.Data.Name )
            textentry:SetPos( 10, 20 )
            textentry:SetSize( 280, 65 )

            local no = vgui.Create("DButton", dframe)
            no:SetSize(60, 20)
            no:SetText("No")
            no:SetPos(25, 75)
            no.Data = pan.Data
            no.DoClick =  function( pann )
                pnl:Show()
                dframe:Remove()
            end

            local yes = vgui.Create("DButton", dframe)
            yes:SetSize(60, 20)
            yes:SetText("Yes")
            yes:SetPos(225, 75)
            yes.Data = pan.Data
            yes.DoClick =  function( pann )
                if pann.DisableButt then return end
                pann.DisableButt = true
                no:Hide()
                yes:Hide()
                textentry:SetText("Fetching your requested layout from the server..\n\nNOTE: This may take a few seconds depending on the size" )
                if pann.Data.IsSimulation then
                    wOS.PES.RequestSimulationData(pann.Data.Name, function( simdata )
                        if not IsValid( self.EventList ) then return end
                        wOS.PES:OpenNodeMenu( simdata.Event, true )
                    end, pann.Data.ID )
                else
                    wOS.PES.RequestEventData(pann.Data.Name, function( simdata )
                        if not IsValid( self.EventList ) then return end
                        wOS.PES:OpenNodeMenu( simdata )
                    end )
                end
            end

		end
		button.Category = data.Category

		if data.Category and not cats.Known[data.Category] then
			local category = data.Category
			cats.Known[category] = true
			local catB = vgui.Create("DButton", catScroll)
			catB:Dock(TOP)
			catB:SetText(category)
			catB.DoClick = function( pan )
				cats.Category = category
				recalculateButs()
			end
		end

		pnls[#pnls + 1] = button
	end
end

function PANEL:OpenEventDeleter()

    local dummy_frame = vgui.Create( "DFrame", self )
    dummy_frame:SetSize( ScrW(), ScrH() )
    dummy_frame:SetTitle( "" )
    dummy_frame:ShowCloseButton( false )
    dummy_frame:SetDraggable( false )
    dummy_frame.Paint = function( pan, ww, hh )
        draw.RoundedBox(0, 0, 0, ww, hh, Color( 0, 0, 0, 200 ) )
    end
    dummy_frame:MakePopup()

    local dframe = vgui.Create("DFrame", dummy_frame )
    dframe:MakePopup()
    dframe:ShowCloseButton( false )
    dframe:SetDraggable( false )
    dframe:SetSize(300, 100)
    dframe:SetTitle( "" )
    dframe.Think = function( pan )
        pan:MoveToFront()
    end
    dframe:Center()

    local textentry = vgui.Create("DLabel", dframe )
    textentry:SetWrap( true )
    textentry:SetText("This action can not be undone. Are you sure you want to delete this event?" )
    textentry:SetPos( 10, 5 )
    textentry:SetSize( 280, 65 )

    local no = vgui.Create("DButton", dframe)
    no:SetSize(60, 20)
    no:SetText("Cancel")
    no:SetPos(25, 75)
    no.DoClick =  function( pann )
        dummy_frame:Remove()
    end

    local yes = vgui.Create("DButton", dframe)
    yes:SetSize(60, 20)
    yes:SetText("Delete")
    yes:SetPos(225, 75)
    yes.DoClick =  function( pann )
        if self.CreationType == WOS_PES.CREATOR.EVENT then
            net.Start( "wOS.PES.RequestEventDelete" )
                net.WriteString( self.Name )
            net.SendToServer()
        elseif self.CreationType == WOS_PES.CREATOR.SIMULATION then
            net.Start( "wOS.CSS.RequestSimDelete" )
                net.WriteString( self.Name )
            net.SendToServer()

            net.Start("wOS.CombatSim.ResetTool")
            net.SendToServer()
            hook.Call( "wOS.PES.OnCreatorClose", nil, WOS_PES.CREATOR.SIMULATION )
            self:GetParent():Remove()
            return
        else return end

        wOS.PES:OpenNodeMenu(nil,nil,true)
    end

end

function PANEL:OpenNode()

    local dummy_frame = vgui.Create( "DFrame", self )
    dummy_frame:SetSize( ScrW(), ScrH() )
    dummy_frame:SetTitle( "" )
    dummy_frame:ShowCloseButton( false )
    dummy_frame:SetDraggable( false )
    dummy_frame.Paint = function( pan, ww, hh )
        draw.RoundedBox(0, 0, 0, ww, hh, Color( 0, 0, 0, 200 ) )
    end
    dummy_frame:MakePopup()

	local pnl = vgui.Create("DFrame", self)
	pnl:SetSize(ScrW() / 1.5, ScrH()/1.5)
	pnl:MakePopup()
	pnl:Center()
	pnl:SetTitle("")
	pnl:SetDraggable(false)
	pnl:ShowCloseButton(false)
	pnl.Think = function( pan )
		pan:MoveToFront()
	end
	pnl.Paint = function(self, w,h)
		surface.SetDrawColor(35.5,35.5,35.5)
		surface.DrawRect(0,0, w, h)
	end

    dummy_frame.Think = function( pan )
        if not IsValid( pnl ) then
            pan:Remove()
        end
    end


	local close = vgui.Create("DButton", pnl)
	close:SetSize(20,20)
	close:SetPos(pnl:GetWide() - 20, 0)
    close:SetText("")
    close.Paint = function(self, w, h)
        local col = Color(255, 255, 255, (self.Hovered and 255) or 150)

        surface.SetDrawColor(col)
        surface.DrawLine(0,0, w, h)
        surface.DrawLine(w,0, 0, h)
    end
    close.DoClick = function() pnl:Remove() end

	local cats = vgui.Create("DPanel", pnl)
	cats:Dock(LEFT)
	cats:SetWide(200)
	cats:DockMargin(0,0, 5, 0)

	cats.Known = {}

	local pnls = {}

	local recalculateButs

	local scroll = vgui.Create("DScrollPanel", pnl)
	scroll:Dock(FILL)

	local List = vgui.Create( "DIconLayout", scroll )
	List:Dock( FILL )
	List:SetSpaceY( 10 )
	List:SetSpaceX( 10 )

	local textentry = vgui.Create("DTextEntry", cats)
	textentry:Dock(TOP)
	textentry:DockMargin(4,4,4,4)
	textentry:SetTall(30)
	textentry.OnChange = function(self)
		recalculateButs()
	end

	local catScroll = vgui.Create("DScrollPanel", cats)
	catScroll:Dock(FILL)

	local catB = vgui.Create("DButton", catScroll)
	catB:Dock(TOP)
	catB:SetText("All")
	catB.DoClick = function()
		cats.Category = nil
		recalculateButs()
	end

	recalculateButs = function()
		local value = string.lower(textentry:GetText())

		for index, col in ipairs(pnls) do
			if string.find(string.lower(col.Name), value) and ( not cats.Category or ( col.Category == cats.Category)) then
				col:Show()
			else
				col:Hide()
			end
		end
		List:Layout()
	end

	local tbl = wOS.PES.Nodes:GetAll()

	for name, data in SortedPairs(tbl) do
        if data.Hidden then continue end
        if data.UserGroups then
            if not table.HasValue( data.UserGroups, LocalPlayer():GetUserGroup() ) then continue end
        end
        if data.SupportedTypes then
            local block = data.SupportedTypes != self.CreationType
            if istable( data.SupportedTypes ) then
                block = !table.HasValue( data.SupportedTypes, self.CreationType )
            end
            if block then continue end
        end
        local button = List:Add("DButton")
		button:SetSize(200, 200)
		button:SetText("")
		button.Name = name

		local nam = wOS.PES.WrapText(data.Name, "wOS.PES.NodeText", button:GetWide()*0.9 )
		local descript = wOS.PES.WrapText(data.Description, "DermaDefault", button:GetWide()*0.9 )

		button.Paint = function(self, w,h)
			draw.RoundedBox(6, 0, 0, w, h, Color(0, 0, 0, 255))
			draw.RoundedBox(5, 1, 1, w-2, h-2, Color(255, 255, 255, 127))

            local offset = h*0.02
            draw.DrawText(nam, "wOS.PES.NodeText", w/2, offset, color_black, TEXT_ALIGN_CENTER )

            surface.SetFont( "wOS.PES.NodeText" )
            local _, dH = surface.GetTextSize( nam )
            offset = offset + dH * 1.2

			draw.DrawText(descript, "DermaDefault", w*0.05, offset, color_black, TEXT_ALIGN_LEFT )
		end

		button.DoClick = function( pan )
			self:AddNode(name)
			pnl:Remove()
		end

		button.Category = data.Category

		if data.Category and not cats.Known[data.Category] then
			local category = data.Category
			cats.Known[category] = true
			local catB = vgui.Create("DButton", catScroll)
			catB:Dock(TOP)
			catB:SetText(category)
			catB.DoClick = function( pan )
				cats.Category = category
				recalculateButs()
			end
		end

		pnls[#pnls + 1] = button
	end
end

function PANEL:DragThink()
    local x,y = self:GetCursorPos()
    if !self.mousepos then
        self.mousepos = {x = x, y = y}
    end
    local dX = x - self.mousepos.x
    local dY = y - self.mousepos.y

    local oldMouseY = self.mousepos.y
    self.mousepos = {x = x, y = y}

    self._tx = dX + self._x
    self._ty = dY + self._y
    local posChanged = false

    if self.tx != self._x then
        posChanged = true
        self._x = math.Approach(self._x, self._tx, FrameTime() * speed*self:GetWide())
    end

    if self.ty != self._y then
        local x,y = self._background:GetPos()

        posChanged = true
        self._y = math.Approach(self._y, self._ty, FrameTime() * speed*self:GetTall())
    end

    if posChanged then
        local aX = self:GetWide()/2 -self._background:GetWide()/2
        local aY = self:GetTall()/2 -self._background:GetTall()/2
        local x,y = self._background:GetPos()

        self._background:SetPos( aX+self._x,  aY + self._y)
    end
end

function PANEL:CopyNode()
    if not IsValid( self.SelectedPanel ) then return end
    if self.SelectedPanel:IsStart() then return end
    LocalPlayer():EmitSound( "garrysmod/balloon_pop_cute.wav", 75, 75 )
    self.StoredPanel = self.SelectedPanel:GetCopy()
end

function PANEL:PasteNode()
    if not self.StoredPanel then return end
    LocalPlayer():EmitSound( "garrysmod/balloon_pop_cute.wav", 75, 130 )
    local node = self:AddNode(self.StoredPanel.Type)

    node:SetVars( table.Copy( self.StoredPanel.Vars ) )
	node:SetDisableVars( table.Copy( self.StoredPanel.Toggles ) )
    local bx, by = self:GetCenter()
    local mx, my = self:GetCursorPos()
    mx = mx - ScrW()/2
    my = my - ScrH()/2
    local sw, sh = node:GetSize()
    node:SetPos( bx + mx - sw/2, by + my - sh/2 )
end

function PANEL:CutNode()
    if not IsValid( self.SelectedPanel ) then return end
    if self.SelectedPanel:IsStart() then return end
    self:CopyNode()
    self:NodeRemove(self.SelectedPanel)
end

function PANEL:ComboThink()

    if input.IsKeyDown( KEY_DELETE ) then
        if not IsValid( self.SelectedPanel ) then return end
        self:NodeRemove( self.SelectedPanel )
        self.SelectedPanel = nil
        self.LastKey = 0
        return
    end

    // Yo I hate the way this is done but it pretty much ensures you don't accidentally fuck a node up, so it stays until a better way

	// one for loop and if it doesn't break check last key?
	if input.IsKeyDown( KEY_LCONTROL ) || input.IsKeyDown( KEY_RCONTROL ) then
        if input.IsKeyDown( KEY_C ) then
            self.LastKey = KEY_C
        elseif input.IsKeyDown( KEY_V ) then
            self.LastKey = KEY_V
        elseif input.IsKeyDown( KEY_X ) then
            self.LastKey = KEY_X
        else
            if self.LastKey == KEY_C then
                self:CopyNode()
            elseif self.LastKey == KEY_V then
                self:PasteNode()
            elseif self.LastKey == KEY_X then
                self:CutNode()
            end
            self.LastKey = 0
        end
    end
end

function PANEL:OnMouseWheeled( delta )
    if not (input.IsKeyDown( KEY_LCONTROL ) || input.IsKeyDown( KEY_RCONTROL )) then return end
    self.ZoomScale = math.Clamp( self.ZoomScale + delta*0.02, 0.1, 1 )
end


function PANEL:Think()

    if not self.ToolBoxHook then
        self:AddToolBox( self._tools )
        self.ToolBoxHook = true
    end

    if self.Dragging then
        self:DragThink()
        return
    end

    self:ComboThink()

end

function PANEL:StopDragging()
    self.Dragging = false
end

/*
	Name: wOS.PES:MakeLink(pnl, oPnl, type)
	Description: Make a link to a node using the trigger Type
	Args: Panel pnl, Panel oPnl, String type
	Returns: boolean success
*/
function PANEL:MakeLink(pnl, oPnl, type)
    if pnl == oPnl then return false end
    if not oPnl then return false end
    if not oPnl:GetMainLink() then return false end
    self.Links[pnl] = self.Links[pnl] || {}
    self.Links[pnl][type] = self.Links[pnl][type] || {}
    if table.HasValue(self.Links[pnl][type], oPnl) then return false end
    table.insert(self.Links[pnl][type], oPnl)
	return true
end

/*
	Name: wOS.PES:RemoveLink(pnl, type, oPnl = nil)
	Description: Removes either a single link of all links of the trigger type
	Args: Panel pnl, String type, Panel oPnl
	Returns: boolean success
*/

function PANEL:RemoveLink(pnl, type, oPnl)
    if not self.Links[pnl] then return false end
    if not self.Links[pnl][type] then return false end

    if oPnl then
        table.RemoveByValue(self.Links[pnl][type],oPnl)
    else
        self.Links[pnl][type] = {}
    end

    return true
end

function PANEL:GetLinks(pnl)
    return self.Links[pnl] || {}
end

/*
	Name: wOS.PES:NodeRemove(node)
	Description: Removes a node from the menu
	Args: Panel node
	Returns: boolean success
*/
function PANEL:NodeRemove(node)
    if node:IsStart() then return false end
    self.Links[node] = nil

    local id = 1

    if IsValid(node) then
        node:Remove()
    end

    local invalidIndexs = {}

    for index, node in ipairs(self.Nodes) do
        if !IsValid(node) then
            invalidIndexs[#invalidIndexs + 1] = index
        else
            node.ID = id
            id = id + 1
            if not node:IsStart() then
                node:RecalculateName()
            end
        end
    end

    for x = 1, #invalidIndexs do
        table.remove(self.Nodes,invalidIndexs[#invalidIndexs])
    end
	return true
end

function PANEL:SelectNode( pan )
    self.SelectedPanel = nil
    if not IsValid( pan ) then return end
    self.SelectedPanel = pan
end

function PANEL:SanityCheckNodes()
    local TK_OK = true
    local ends = false
    for index, node in ipairs(self.Nodes) do
        if node.Type == "End" then
            ends = true
        end
        node:RecalculateDirty()
        if not node.NodeDirty then continue end
        TK_OK = false
    end

    if not TK_OK then
        surface.PlaySound( "buttons/button10.wav" )
        notification.AddLegacy( "[wOS-PES] Event could not be saved: Nodes have unresolved errors ( make sure all variables are filled out! )", NOTIFY_ERROR, 3 )
    end

    if not ends then
        TK_OK = false
        surface.PlaySound( "buttons/button10.wav" )
        notification.AddLegacy( "[wOS-PES] Event could not be saved: No END node to terminate event logic ( infinite events consume memory )", NOTIFY_ERROR, 3 )
    end

    return TK_OK
end

function PANEL:Paint()
    local globs = vgui.GetWorldPanel():GetChildren()
    for _, child in ipairs( globs ) do
        local class = child:GetClassName()
        if not ( child.SetLegacyType ) and not ( child.StartTime and child.fx and child.fy ) then continue end
        child:MakePopup()
    end
end

function PANEL:GetCursorPos()
    return self:GetZoomedCursorPos( input.GetCursorPos() )
end

vgui.Register( "WOS_PES_NodeBG", PANEL, "Panel" )
--addons/wos-passiveevent-ageo/lua/wos/pes/addons/display/cl_entsdisplay.lua:


hook.Add("HUDPaint", "wOS.PES.DrwaInteractableNames", function()

	local tr = util.TraceLine({
		start = LocalPlayer():EyePos(),
		endpos = LocalPlayer():EyePos() + LocalPlayer():EyeAngles():Forward() * 100,
		filter = LocalPlayer(),
		mask = MASK_SHOT
	})

	if !tr.Hit or !IsValid(tr.Entity)  then return end

	local ent = tr.Entity

	// Need to figure out how to tell if this ent has come from the same event that the player is in
	// we could use event ids, with nw ints but that can cause issues with nw lag 

	if !ent:GetNWString("PES.DisplayMessage") then return end

	local pos = ent:GetPos() + ent:OBBCenter()

	local text = ent:GetNWString("PES.DisplayMessage")
	local pos = pos:ToScreen()
	local x, y = pos.x, pos.y

	draw.DrawText(text, "wOS.PES.CapturePoint", x, y, Color(255, 255, 255, 255), TEXT_ALIGN_CENTER)
end)

// should an addon be registered?

--addons/wos-passiveevent-ageo/lua/wos/pes/core/cl_accessors.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--

























































































































































wOS = wOS or {}
wOS.PES = wOS.PES or {}

wOS.PES.Triggers = wOS.PES.Triggers || {}
wOS.PES.Triggers.Data = wOS.PES.Triggers.Data || {}

wOS.PES.Nodes = wOS.PES.Nodes || {}
wOS.PES.Nodes.Data = wOS.PES.Nodes.Data || {}

function wOS.PES.Triggers:GetAll()
    return self.Data
end

function wOS.PES.Triggers:Get(name)
    if not name then return end
    return self.Data[name]
end

function wOS.PES.Nodes:GetAll()
    return self.Data
end

function wOS.PES.Nodes:Get(name)
    if not name then return end
    return self.Data[name]
end
--addons/wos-passiveevent-ageo/lua/wos/css/entities/wos_simulation_system/cl_wos_simulation_system.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2019
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--

local ENT = {}

ENT.Type 			= "anim"
ENT.Base 			= "base_anim"

ENT.Spawnable = false

-- Sets up the NetworkVars for the entity.
function ENT:SetupDataTables()
	self:NetworkVar( "Bool", 0, "Activated" )

	self:NetworkVar( "Int", 0, "Score" )
	self:NetworkVar( "Int", 1, "StartTime" )
	self:NetworkVar( "Int", 2, "EndTime" )
	self:NetworkVar( "Int", 3, "BorderPointCount" )
	self:NetworkVar( "Int", 4, "BorderHeight" )
    
	self:NetworkVar( "String", 0, "SimulatorName" )

	self:NetworkVar( "Float", 0, "BorderUpdate" )
	
end

function ENT:PrepareCheckBorderValues()
	self.PreparedBorderValues = {}
	
	local borderPointCount = self:GetBorderPointCount()

	for i=1, borderPointCount do
		local preparedValue = {
			v = self:GetNW2Vector("BorderPoint" .. i)
		}

		self.PreparedBorderValues[i] = preparedValue
	end

	local j = borderPointCount

	for i=1, borderPointCount do
		local borderI = self.PreparedBorderValues[i].v
		local borderJ = self.PreparedBorderValues[j].v

		if borderJ.y == borderI.y then
			self.PreparedBorderValues[i].c = borderI.x
			self.PreparedBorderValues[i].m = 0
		else
			self.PreparedBorderValues[i].c = borderI.x - (borderI.y * borderJ.x) / (borderJ.y - borderI.y) + (borderI.y * borderI.x) / (borderJ.y - borderI.y)
			self.PreparedBorderValues[i].m = (borderJ.x - borderI.x) / (borderJ.y - borderI.y);
		end

		j = i
	end
end

-- Check if the Vector is inside the 2D border of the sim area.
--
-- @param Vector vec
-- @return Bool inBorders
function ENT:CheckInBorders2D(vec)
	local borderPointCount = self:GetBorderPointCount()

	if not self.PreparedBorderValues or #self.PreparedBorderValues ~= borderPointCount then 
		self:PrepareCheckBorderValues()
	end
	
	local j = borderPointCount
	local inBorders = false

	for i=1, borderPointCount do
		local borderI = self.PreparedBorderValues[i].v
		local borderJ = self.PreparedBorderValues[j].v

		if ((borderI.y<vec.y && borderJ.y>=vec.y || borderJ.y<vec.y && borderI.y>=vec.y)) then
			if (vec.y * self.PreparedBorderValues[i].m + self.PreparedBorderValues[i].c < vec.x) then
				inBorders = not inBorders
			end
	  	end

		j = i
	end

	return inBorders
end

-- Check if the given vector is inside the border of the sim area.
--
-- @param Vector vec
-- @return Bool inBorders
function ENT:CheckInBorders(vec)
	local firstPoint = self:GetNW2Vector("BorderPoint1")

	local heightt = self:GetBorderHeight()
	local below = vec.z - 50 < firstPoint.z + heightt
	local above = vec.z + 50 > firstPoint.z

	if heightt < 0 then
		below = vec.z - 50 < firstPoint.z 
		above = vec.z + 50 > firstPoint.z + heightt
	end

	if below && above then
		if self:CheckInBorders2D(vec) then
			return true
		end
	end

	return false
end

-- Returns the time left until the game ends.
--
-- @return Number timeLeft
function ENT:GetTimeLeft()
	return math.Round(CurTime() - self:GetStartTime(), 0)
end

-- Clientside Initialize
function ENT:Initialize()
	self.Positions = {}
	self.BorderUpdate = 0
end

-- Clientside Think
function ENT:Think()
	if self.BorderUpdate != self:GetBorderUpdate() and self:GetBorderUpdate() < CurTime() then
		self.BorderUpdate = self:GetBorderUpdate()
		self.PreparedBorderValues = nil
	end
end

-- Clientside OnRemove
function ENT:OnRemove()
end

---- Main Draw function.
--function ENT:Draw()
--	self:DrawModel()
--end

scripted_ents.Register(ENT, "wos_simulation_system")
--addons/wos-passiveevent-ageo/lua/wos/css/entities/wos_simulation_wall/sh_wos_simulation_wall.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2019
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--


--addons/billy_gas/lua/vgui/bvgui/columnlayout.lua:
local PANEL = {}

bVGUI.COLUMN_LAYOUT_COLUMN_GROW = 0
bVGUI.COLUMN_LAYOUT_COLUMN_SHRINK = 1
bVGUI.COLUMN_LAYOUT_COLUMN_GROW_COLUMN = 2

function PANEL:Init()
	self.Columns = {}
	self.Rows = {}
	self.ColumnPadding = 0
	self.RowPadding = 0

	function self.pnlCanvas:PerformLayout()
		self:GetParent():ColumnLayout()
		self:InvalidateParent(true)
	end
end

function PANEL:SetPaddings(column_padding, row_padding)
	self.ColumnPadding = column_padding
	self.RowPadding = row_padding
end

function PANEL:SetColumns(...)
	self.Columns = {...}
	self.GrowColumnCount = 0
	for _,v in ipairs(self.Columns) do
		if (v == bVGUI.COLUMN_LAYOUT_COLUMN_GROW or v == bVGUI.COLUMN_LAYOUT_COLUMN_GROW_COLUMN) then
			self.GrowColumnCount = self.GrowColumnCount + 1
		end
	end
end

function PANEL:AddRow(...)
	local i = table.insert(self.Rows, {...})
	self.pnlCanvas:InvalidateLayout(true)
	return i
end

function PANEL:RemoveRow(row_index)
	for _,element in ipairs(self.Rows[row_index]) do
		element:Remove()
	end
	table.remove(self.Rows, row_index)
	self.pnlCanvas:InvalidateLayout(true)
end

function PANEL:ColumnLayout()
	local column_widths = {}
	local row_heights = {}
	for row_i, elements in ipairs(self.Rows) do
		for column_i, element in ipairs(elements) do
			if (self.Columns[column_i] == bVGUI.COLUMN_LAYOUT_COLUMN_SHRINK) then
				local element_w = element:GetWide()
				local column_w = column_widths[column_i]
				if (not column_w or element_w > column_w) then
					column_widths[column_i] = element_w
				end
			end
			local element_h = element:GetTall()
			local row_h = row_heights[row_i]
			if (not row_h or element_h > row_h) then
				row_heights[row_i] = element_h
			end
		end
	end
	local grow_column_width = 0
	for i,v in pairs(column_widths) do
		grow_column_width = grow_column_width - v - self.ColumnPadding
	end
	grow_column_width = ((grow_column_width + self:GetWide()) / self.GrowColumnCount) - 4

	local row_y = 0
	for row_i, elements in ipairs(self.Rows) do
		local column_x = 0
		for column_i, element in ipairs(elements) do
			local column_sizing = self.Columns[column_i]
			if (column_sizing == bVGUI.COLUMN_LAYOUT_COLUMN_SHRINK) then
				element:SetWide(column_widths[column_i])
				element:SetPos(column_x, row_y)
				column_x = column_x + column_widths[column_i] + self.ColumnPadding
			elseif (column_sizing == bVGUI.COLUMN_LAYOUT_COLUMN_GROW or column_sizing == bVGUI.COLUMN_LAYOUT_COLUMN_GROW_COLUMN) then
				if (bVGUI.COLUMN_LAYOUT_COLUMN_GROW_COLUMN) then
					element:SetWide(grow_column_width)
				else
					element:SetSize(grow_column_width, row_heights[row_i])
				end
				element:SetPos(column_x, row_y)
				column_x = column_x + grow_column_width + self.ColumnPadding
			end
		end
		row_y = row_y + row_heights[row_i] + self.RowPadding
	end
end

derma.DefineControl("bVGUI.ColumnLayout", nil, PANEL, "bVGUI.ScrollPanel")
--addons/billy_gas/lua/vgui/bvgui/horizontaldivider.lua:
local PANEL = {}

function PANEL:Init()
	self:SetMouseInputEnabled(true)
	self:SetCursor("sizewe")

	self.LeftWidth = 0
	self.MiddleWidth = 0
	self.RightWidth = 0
end

function PANEL:SetLeft(pnl)
	self.LeftPnl = pnl
	pnl:SetParent(self)
end

function PANEL:SetMiddle(pnl)
	self.MiddlePnl = pnl
	pnl:SetParent(self)
end

function PANEL:SetRight(pnl)
	self.RightPnl = pnl
	pnl:SetParent(self)
end

function PANEL:SetDividerWidth(w)
	self.DividerWidth = w
end

function PANEL:BalanceWidths()
	self.BalanceWidth = true
end

function PANEL:PerformLayout(w,h)
	if (self.BalanceWidth) then
		self.BalanceWidth = nil

		if (IsValid(self.MiddlePnl)) then
			self.LeftWidth   = (w - (self.DividerWidth * 2)) / 3
			self.MiddleWidth = (w - (self.DividerWidth * 2)) / 3
			self.RightWidth  = (w - (self.DividerWidth * 2)) / 3
		else
			self.LeftWidth   = (w - self.DividerWidth) / 2
			self.MiddleWidth = 0
			self.RightWidth  = (w - self.DividerWidth) / 2
		end
	end

	if (IsValid(self.LeftPnl)) then
		self.LeftPnl:SetSize(self.LeftWidth, h)
		self.LeftPnl:AlignLeft(0)
	end
	if (IsValid(self.MiddlePnl)) then
		self.MiddlePnl:SetSize(self.MiddleWidth, h)
		self.MiddlePnl:AlignLeft(self.LeftWidth + self.DividerWidth)
	end
	if (IsValid(self.RightPnl)) then
		self.RightPnl:SetSize(self.RightWidth, h)
		self.RightPnl:AlignRight(0)
	end
end

function PANEL:Paint(w,h)
	if (not IsValid(self.LeftPnl) or not IsValid(self.RightPnl)) then return end

	surface.SetDrawColor(51,80,114)
	surface.DrawRect(self.LeftWidth,0,self.DividerWidth,h)

	surface.SetMaterial(bVGUI.MATERIAL_GRADIENT_LARGE)
	surface.DrawTexturedRect(self.LeftWidth,0,self.DividerWidth,h)

	if (IsValid(self.MiddlePnl)) then
		surface.SetDrawColor(51,80,114)
		surface.DrawRect(w - self.RightWidth - self.DividerWidth,0,self.DividerWidth,h)

		surface.SetMaterial(bVGUI.MATERIAL_GRADIENT_LARGE)
		surface.DrawTexturedRect(w - self.RightWidth - self.DividerWidth,0,self.DividerWidth,h)
	end
end

function PANEL:OnMousePressed(m)
	if (m == MOUSE_LEFT) then
		self.Dragging = true
	end
end
function PANEL:OnCursorMoved(x,y)
	local w,h = self:GetSize()
	if (self.Dragging) then
		
	end
end
function PANEL:OnMouseReleased(m)
	if (m == MOUSE_LEFT) then
		self.Dragging = nil
	end
end

derma.DefineControl("bVGUI.HorizontalDivider", nil, PANEL, "DHorizontalDivider")
--gamemodes/starwarsrp/gamemode/modules/unit/cl_unitmgmt.lua:
--
AOCRP.UnitMgmt = AOCRP.UnitMgmt or {}



local function navbarBtn(pnl,txt,func)

        local DButton = AOCDerma:Button(pnl, txt, func, "")
        DButton:Dock( LEFT )
        --DButton:SetWide(100)
        DButton:DockMargin(0,0,5,0)
        pnl:AddPanel(DButton)
end


local function UnitHome(pnl, unitid)

end

local function CreateRangOptionsMenu(data)
    local Menu = DermaMenu()

    -- Simple option, but we're going to add an icon
    local btnWithIcon = Menu:AddOption( "Rang ndern" )
    Menu:AddSpacer()
    for k, v in pairs(AOCRP.Ranks) do
        if k < LocalPlayer():GetRankID() then

            if k == data.rankid then
                local btnWithIcon = Menu:AddOption( ">> "..v.name )
            else
                local btnWithIcon = Menu:AddOption( v.name )
            end
        end

    end

    return Menu
end


function AOCRP.UnitMgmt:ShowPlayerActivityChart(cloneid,name)

    AOCRP.API:Request("getcharsessions", function(data) 
        PrintTable(data)

        local days = {}
        local time = {}


        for k, v in pairs(data) do
             table.insert(days,v.date)
            table.insert(time,math.Round(tonumber(v.time)/60))               
        end



        print(util.TableToJSON(days))
        PrintTable(time)

        if ValidPanel(self.Chart) then self.Chart:Remove() end
        self.Chart = AOCDerma:DefaultFrame()
        self.Chart:SetNewTitle("Anwesenheit "..AOCRP.CharSys:IDToDashID(cloneid).. " "..name)
        self.Chart:SetSize(ScrW()*.4, ScrH()*.55)
        self.Chart:Center()

        local htmlCode = [[

            <!DOCTYPE html>
        <html>
  <!-- Plotly.js -->
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
        <body>
        <div id="myDiv" style="width:100%;"></div>

        <script>
      
var trace1 = {
 	x: ]].. util.TableToJSON(days) .. [[,
	y: ]].. util.TableToJSON(time) .. [[,
	type: 'scatter'
};

var data = [trace1];

var config = {
  displayModeBar: false, // this is the line that hides the bar.
  scrollZoom: true,
};

var layout = {
	title: 'Anwesenheit in Stunden',
	showlegend: false};

Plotly.newPlot('myDiv', data, layout, config);


        </script>

        </body>
        </html>


            ]]


    
    


        local html = vgui.Create("DHTML", self.Chart)
        html:Dock(FILL)
        html:SetHTML(htmlCode)




    end, {["cloneid"]=cloneid} )

end





PIXEL.RegisterFont("AOCRP_UNITMGMT_TITLE", "Agency FB", 50, 1000)
PIXEL.RegisterFont("AOCRP_UNITMGMT_ID", "Agency FB", 50, 100)
PIXEL.RegisterFont("AOCRP_UNITMGMT_NAME", "Agency FB", 40, 100)
local function ShowPlayerData(data,pnl)
    pnl:Clear()


    local scrollpnl = AOCDerma:ScrollBar(pnl) 
    scrollpnl:Dock(FILL)
    scrollpnl:DockMargin(5,5,5,5)

    local akte = vgui.Create("DPanel", pnl)
    function akte:Paint(w,h)
                draw.RoundedBox(0,0,0,w,h,Color(0,0,0,200))
        draw.DrawText("- PERSONALAKTE -", PIXEL.UI.RegisteredFonts["AOCRP_UNITMGMT_TITLE"], w/2, 0, Color(255,255,255), TEXT_ALIGN_CENTER)
        draw.DrawText("CT-"..AOCRP.CharSys:IDToDashID(data.cloneid) , PIXEL.UI.RegisteredFonts["AOCRP_UNITMGMT_ID"], w/2, AOCH(50), Color(255,255,255), TEXT_ALIGN_CENTER)
        draw.DrawText('"'..data.name..'"' , PIXEL.UI.RegisteredFonts["AOCRP_UNITMGMT_NAME"], w/2, AOCH(95), Color(255,255,255), TEXT_ALIGN_CENTER)
    end
    akte:Dock(TOP)
    akte:SetTall(AOCH(150))
    akte:DockMargin(10,5,10,10)


    local rang = vgui.Create("DPanel", pnl)
    function rang:Paint(w,h)
                draw.RoundedBox(0,0,0,w,h,Color(0,0,0,200))
        draw.DrawText("Dienstgrad", PIXEL.UI.RegisteredFonts["AOCRP_UNITMGMT_NAME"], w/2, 0, Color(255,255,255), TEXT_ALIGN_CENTER)
        draw.DrawText(AOCRP.Ranks[data.rankid].name, PIXEL.UI.RegisteredFonts["AOCRP_UNITMGMT_ID"], w/2, AOCH(40), Color(255,255,255), TEXT_ALIGN_CENTER)
    end
    rang:Dock(TOP)
    rang:SetTall(AOCH(90))
    function rang:OnMousePressed()
        local RangEditMenu = CreateRangOptionsMenu(data)
        RangEditMenu:Open()
    end
    rang:DockMargin(10,0,10,10)

     local btn = AOCDerma:Button(pnl, "Aktivitt", function()  AOCRP.UnitMgmt:ShowPlayerActivityChart(data.cloneid, data.name) end, "bc")
         btn:Dock(TOP)
    btn:DockMargin(10,0,10,10)
  

end

local function AddMembers(data, pnl, search, lpnl)
    pnl:Clear()
        if #data > 0 then
            for k, v in SortedPairsByMemberValue(data, "rankid", true) do
                local name = "P:"..AOCRP.SubUnits[v.subunit].prefix .. " R:" .. AOCRP.Ranks[v.rankid].prefix .. " " .. AOCRP.CharSys:IDToDashID(v.cloneid) .. " ".. v.name
                if string.find( name:lower(), search:lower() ) then
                    local btn = AOCDerma:Button(pnl, name, function() ShowPlayerData(v,lpnl) end, "b")
                    btn:Dock(TOP)
                end
            end 
        end
end





local function MemberManagement(pnl, unitid)


local LeftPanel = vgui.Create( "DPanel", pnl ) -- Can be any panel, it will be stretched
LeftPanel:SetPaintBackground(false)
local RightPanel = vgui.Create( "DPanel", pnl )
RightPanel:SetPaintBackground(true)
function RightPanel:Paint(w,h)
    draw.RoundedBox(0,0,0,2,h,Color(255,255,255))
end

local div = vgui.Create( "DHorizontalDivider", pnl )
div:Dock( FILL ) -- Make the divider fill the space of the DFrame
div:SetLeft( LeftPanel ) -- Set what panel is in left side of the divider
div:SetRight( RightPanel )
div:SetDividerWidth( AOCW(4) ) -- Set the divider width. Default is 8
div:SetLeftMin( AOCW(400) ) -- Set the Minimum width of left side

--[[ div:SetRightMin( 20 )
div:SetLeftWidth( 50 ) -- Set the default left side width ]]

    AOCRP.API:Request("getunitmembers", function(data) 

        local searchpnl = AOCDerma:TextEntry(LeftPanel,"Mitgliedersuche..")
        searchpnl:Dock(TOP)
        searchpnl:SetTall(AOCH(50))
        searchpnl:DockMargin(5,5,5,5)
        searchpnl:SetUpdateOnType(true)
        function searchpnl:OnValueChange(val)
            AddMembers(data, pnl.memberlist, val,RightPanel)
        end   

        pnl.memberlist = AOCDerma:ScrollBar(LeftPanel) 
        pnl.memberlist:Dock(FILL)
        pnl.memberlist:DockMargin(5,5,5,5)


        AddMembers(data, pnl.memberlist, "",RightPanel)


    end, {["unitid"]=unitid})

end








local function UnitEinheitsbeitrag(pnl, unitid)
    local html = vgui.Create("DHTML", pnl)
    html:Dock(FILL)
    html:OpenURL(AOCRP.Units[unitid].rulesurl)
end





function AOCRP.UnitMgmt:OpenUnit(unitid)

    if !AOCRP.Units[unitid] then return end
    if LocalPlayer():GetUnitID() != unitid or !LocalPlayer():IsSuperAdmin() then return end

    local unitData = AOCRP.Units[unitid]

    if ValidPanel(self.UnitFrame) then self.UnitFrame:Remove() end
    self.UnitFrame = AOCDerma:DefaultFrame()
    self.UnitFrame:SetNewTitle(unitData.name)
    self.UnitFrame:SetSize(ScrW()*.8, ScrH()*.9)
    self.UnitFrame:Center()


    local navbar = vgui.Create( "DHorizontalScroller", self.UnitFrame )
    navbar:Dock( TOP )
    navbar:SetTall(55)
    navbar:SetOverlap( -5 )
    function navbar:Paint(w,h)
        draw.RoundedBox(0,0,0,w,h,Color(0,0,0,100))
        draw.RoundedBox(0,0,h-1,w,1,Color(255,255,255))
    end
    function navbar.btnLeft:Paint( w, h )
        draw.RoundedBox( 0, 0, 0, w, h, Color( 255, 255, 255) )
    end
    function navbar.btnRight:Paint( w, h )
        draw.RoundedBox( 0, 0, 0, w, h, Color( 255, 255, 255) )
    end

    self.UnitFrame.Content = vgui.Create("DPanel", self.UnitFrame)
    self.UnitFrame.Content:Dock(FILL)
    self.UnitFrame.Content:SetPaintBackground(false)


    local home = navbarBtn(navbar,"Startseite",function() 
        self.UnitFrame.Content:Clear()
        UnitHome(self.UnitFrame.Content, unitid)
    end)
    local home = navbarBtn(navbar,"Mitgliederverwaltung",function() 
        self.UnitFrame.Content:Clear()
        MemberManagement(self.UnitFrame.Content, unitid)
    end)
    local home = navbarBtn(navbar,"Einheitslog",function() 
        self.UnitFrame.Content:Clear()
    end)
    local home = navbarBtn(navbar,"Einheitsbeitrag",function() 
        self.UnitFrame.Content:Clear()
        UnitEinheitsbeitrag(self.UnitFrame.Content, unitid)
    end)
    local home = navbarBtn(navbar,"Rechtemanagement",function() 
        self.UnitFrame.Content:Clear()
    end)
    local home = navbarBtn(navbar,"Ausrstungsverwaltung",function()
        self.UnitFrame.Content:Clear()
    end)
    local home = navbarBtn(navbar,"Einstellungen",function() 
        self.UnitFrame.Content:Clear()
    end)
  

end


local function addMemberPanel(pnl, memberData)
    local memberPanel = vgui.Create("DPanel", pnl)
    memberPanel:Dock(TOP)
    memberPanel:SetTall(AOCH(50))
    memberPanel:DockMargin(0,0,0,AOCH(5))
    function memberPanel:Paint(w,h)
        draw.RoundedBox(0,0,0,w,h,Color(0,0,0,100))
        draw.DrawText(memberData.cloneid.. " ".. memberData.name, AOCDerma:Font("MemberPanel_Text"), w/2, AOCH(5), Color(255,255,255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
    end
    memberPanel:Dock(TOP) 
  

end 

AOCDerma:RegisterFont("MemberPanel_Text", "Agency FB", 30, 1)
AOCDerma:RegisterFont("MemberPanel_Ranks", "Agency FB", 30, 1000)
function AOCRP.UnitMgmt:MemberManagement(frame, unitid)

    AOCRP.UnitMgmt.MemberData = {}
   
--[[ 
    
    local searchEntry = AOCDerma:TextEntry(frame," Soldat suchen...")
    searchEntry:Dock(TOP)
    searchEntry:SetTall(AOCH(50))
    searchEntry:DockMargin(0,0,AOCW(10),AOCH(10))
    searchEntry:SetUpdateOnType( true )
    function searchEntry:OnValueChange(txt) 
        SearchResults:Clear()
        for k, v in pairs(AOCRP.UnitMgmt.MemberData) do
            if string.find(v.name, txt) then
                addMemberPanel(SearchResults, v)
            end
        end
    end
    

    SearchResults = vgui.Create( "DCollapsibleCategory", frame )	-- Create a collapsible category
    SearchResults:SetLabel("")						-- Set the name ( label )
    SearchResults:SetExpanded( true )	-- Start collapsed
    SearchResults.Header:SetTall(AOCH(40))
    SearchResults:Dock(TOP)

    SearchResults.Paint = function() end
    SearchResults.Header.Paint = function(self, w,h)
        draw.SimpleText( "Suchergebnisse", AOCDerma:Font("MemberPanel_Ranks"), w/2, h/2, Color(255,255,255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        surface.SetDrawColor(Color(255,255,255,10))
        surface.DrawRect(0, h-1, w, 1)
    end
 ]]

    local RankCategorys = {}
    for k, v in SortedPairs(AOCRP.Ranks, true) do


            RankCategorys[k] = {}
            RankCategorys[k].count = 0

            local DCollapsible = vgui.Create( "DCollapsibleCategory", frame )	-- Create a collapsible category
            DCollapsible:SetLabel("")						-- Set the name ( label )
            DCollapsible:SetExpanded( true )	-- Start collapsed
                DCollapsible.Header:SetTall(AOCH(40))
            DCollapsible:Dock(TOP)
    
            DCollapsible.Paint = function() end
            DCollapsible.Header.Name = v.name
            DCollapsible.Header.ID = k
            DCollapsible.Header.Paint = function(self, w,h)
                draw.SimpleText( self.Name .. " ("..RankCategorys[self.ID].count..")", AOCDerma:Font("MemberPanel_Ranks"), w/2, h/2, Color(255,255,255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
                surface.SetDrawColor(Color(255,255,255,10))
                surface.DrawRect(0, h-1, w, 1)
            end

            RankCategorys[k].panel = DCollapsible
            
    end 


    AOCRP.API:Request("getunitmembers", function(data) 


    
        AOCRP.UnitMgmt.MemberData = data

        for k, v in pairs(AOCRP.UnitMgmt.MemberData) do 
            addMemberPanel(RankCategorys[v.rankid].panel, v)
            RankCategorys[v.rankid].count = RankCategorys[v.rankid].count + 1
        end 


        for k, v in pairs(RankCategorys) do
            if v.count < 1 then 
                v.panel:SetVisible(false)
            end
            v.panel:Toggle()
        end



    end, {["unitid"]=unitid})


end 


AOCDerma:RegisterFont("UnitTitle", "Agency FB", 50, 1000)

function AOCRP.UnitMgmt:Datapad(unitid)


    local core = AOCRP.Datapad.MainFrame

    if !IsValid(core) then return end 

    if !AOCRP.Units[unitid] then return end


    local unitData = AOCRP.Units[unitid]


    core.MenuPanel:Clear()

    local btn = AOCDerma:Button(core.MenuPanel, "Zurck", function() 
        AOCRP.Datapad:DataPadFrame()

    end, "b")
    btn:Dock(BOTTOM)
    btn:DockMargin(0,AOCH(30),AOCW(10),AOCH(10))
    btn.akzent = Color(200,0,0)
    btn.akzenthover = Color(255,0,0)

    local titlePnl = vgui.Create("DPanel", core.MenuPanel)
    titlePnl:Dock(TOP)
    titlePnl:SetTall(AOCH(50))
    function titlePnl:Paint(w,h) 
        draw.RoundedBox(0,0,0,w,h,Color(0,0,0,100))
        draw.DrawText(unitData.name, AOCDerma:Font("UnitTitle"), w/2, 0, AOCDerma:HexToColor(unitData.colorhex), TEXT_ALIGN_CENTER)
        draw.RoundedBox(0,0,h-1,w,1,Color(255,255,255))
    end 

 
    
    local btn = AOCDerma:Button(core.MenuPanel, "Mitglieder", function(me) 
        
        AOCRP.Datapad.MainFrame.OpenText = me.printtext
        AOCRP.Datapad.MainFrame.ContentPanel:Clear() 
        AOCRP.UnitMgmt:MemberManagement(AOCRP.Datapad.MainFrame.ContentPanel, unitid)
    
    end, "b")
    btn:Dock(TOP)
    btn:DockMargin(0,AOCH(10),AOCW(10),AOCH(10))

    function btn:PaintOver(w,h)
        if self.printtext == AOCRP.Datapad.MainFrame.OpenText then
            self.akzent = Color(0,200,0)
            self.akzenthover = Color(0,255,0)
        else
            self.akzent = Color(200,200,200)
            self.akzenthover = Color(255,255,255)       
        end
    end
--[[ 
    if !AOCRP.Units[unitid] then return end
    if LocalPlayer():GetUnitID() != unitid then return end

    local unitData = AOCRP.Units[unitid]


    local navbar = vgui.Create( "DHorizontalScroller", frame )
    navbar:Dock( TOP )
    navbar:SetTall(55)
    navbar:SetOverlap( -5 )
    function navbar:Paint(w,h)
        draw.RoundedBox(0,0,0,w,h,Color(0,0,0,100))
        draw.RoundedBox(0,0,h-1,w,1,Color(255,255,255))
    end
    function navbar.btnLeft:Paint( w, h )
        draw.RoundedBox( 0, 0, 0, w, h, Color( 255, 255, 255) )
    end
    function navbar.btnRight:Paint( w, h )
        draw.RoundedBox( 0, 0, 0, w, h, Color( 255, 255, 255) )
    end

    frame.Content = AOCDerma:ScrollBar(frame) 
    frame.Content:Dock(FILL)
    frame.Content:SetPaintBackground(true)


    local home = navbarBtn(navbar,"Startseite",function() 
        frame.Content:Clear()
        --UnitHome(frame.Content, unitid)
    end)
    local home = navbarBtn(navbar,"Mitglieder",function() 
        frame.Content:Clear()

         local RankCategorys = {}
        for k, v in pairs(AOCRP.Ranks) do
    
                print("test")
    
                RankCategorys[k] = {}
                RankCategorys[k].count = 0
    
                local DCollapsible = vgui.Create( "DCollapsibleCategory", frame.Content )	-- Create a collapsible category
                DCollapsible:SetLabel("")						-- Set the name ( label )
                DCollapsible.NewLabel = v.name .. " ("..RankCategorys[k].count..")"
                DCollapsible:SetExpanded( true )	-- Start collapsed
                    DCollapsible.Header:SetTall(AOCH(40))
                DCollapsible:Dock(TOP)
        
                DCollapsible.Paint = function() end
                DCollapsible.Header.Paint = function(self, w,h)
                    draw.SimpleText( DCollapsible.NewLabel, PIXEL.UI.RegisteredFonts["AOCRP.ScoreBoard.Unit"], w/2, h/2, Color(255,255,255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
                    surface.SetDrawColor(Color(255,255,255,10))
                    surface.DrawRect(0, h-1, w, 1)
                end
    
                RankCategorys[k].panel = DCollapsible
                
        end 

        --AOCRP.UnitMgmt:MemberManagement(unitid)
    end)
    local home = navbarBtn(navbar,"Einheitslog",function() 
        frame.Content:Clear()
    end) ]]
end



--gamemodes/starwarsrp/gamemode/modules/permaprops/cl_drawent.lua:
/*
   ____          _          _   ____          __  __       _ _                     
  / ___|___   __| | ___  __| | | __ ) _   _  |  \/  | __ _| | |__   ___  _ __ ___  
 | |   / _ \ / _` |/ _ \/ _` | |  _ \| | | | | |\/| |/ _` | | '_ \ / _ \| '__/ _ \ 
 | |__| (_) | (_| |  __/ (_| | | |_) | |_| | | |  | | (_| | | |_) | (_) | | | (_) |
  \____\___/ \__,_|\___|\__,_| |____/ \__, | |_|  |_|\__,_|_|_.__/ \___/|_|  \___/ 
                                      |___/                                        
*/

local function PermaPropsViewer()

	if not LocalPlayer().DrawPPEnt or not istable(LocalPlayer().DrawPPEnt) then return end

    local pos = LocalPlayer():EyePos() + LocalPlayer():EyeAngles():Forward() * 10
    local ang = LocalPlayer():EyeAngles()

    ang = Angle(ang.p + 90, ang.y, 0)

    for k, v in pairs(LocalPlayer().DrawPPEnt) do

    	if not v or not v:IsValid() then LocalPlayer().DrawPPEnt[k] = nil continue end

	    render.ClearStencil()
	    render.SetStencilEnable(true)
	        render.SetStencilWriteMask(255)
	        render.SetStencilTestMask(255)
	        render.SetStencilReferenceValue(15)
	        render.SetStencilFailOperation(STENCILOPERATION_REPLACE)
	        render.SetStencilZFailOperation(STENCILOPERATION_REPLACE)
	        render.SetStencilPassOperation(STENCILOPERATION_KEEP)
	        render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_ALWAYS)
	        render.SetBlend(0)
	        v:DrawModel()
	        render.SetBlend(1)
	        render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_EQUAL)
	        cam.Start3D2D(pos, ang, 1)
	                surface.SetDrawColor(255, 0, 0, 255)
	                surface.DrawRect(-ScrW(), -ScrH(), ScrW() * 2, ScrH() * 2)
	        cam.End3D2D()
	        v:DrawModel()
	    render.SetStencilEnable(false)

	end

end
hook.Add("PostDrawOpaqueRenderables", "PermaPropsViewer", PermaPropsViewer)
--gamemodes/starwarsrp/gamemode/modules/admin/sh_eventcal.lua:
AOCRP.EventCal = AOCRP.EventCal or {}

if SERVER then
    util.AddNetworkString("AOCRP.EventCal.Add")

    function AOCRP.EventCal:Add(title,desc,starttime, duration)
        --test
    end
end
if CLIENT then
   
   local function textentry(pnl, lbl, val)
        local DLabel = vgui.Create( "DLabel", pnl )
        DLabel:Dock(TOP)
        DLabel:SetText( lbl )
        
        entry = vgui.Create( "DTextEntry", pnl ) -- create the form as a child of frame
        entry:Dock( TOP )
        entry:SetTall(30)
        entry:SetValue(val) 
        return entry 
    end
   local function textentrybig(pnl, lbl, val)
        local DLabel = vgui.Create( "DLabel", pnl )
        DLabel:Dock(TOP)
        DLabel:SetText( lbl )
        
        entry = vgui.Create( "DTextEntry", pnl ) -- create the form as a child of frame
        entry:Dock( TOP )
         entry:SetMultiline(true )
        entry:SetTall(100)
        entry:SetValue(val) 
        return entry 
    end

    function AOCRP.EventCal:AddEventFrame()
        self.Frame = vgui.Create("DFrame")
        self.Frame:SetSize(500,500)
        self.Frame:Center()
        self.Frame:SetTitle("Neues Ereignis eintragen")

        local title = textentry(self.Frame, "Titel", "")

        local descrip = textentrybig(self.Frame, "Beschreibung", "")

        local startzeit = textentry(self.Frame, "Startzeit (TT.MM.JJJJ HH:MM)", "")

                local vorausdauer = textentry(self.Frame, "Geschtze Dauer", "")

        local btn = vgui.Create("DButton", self.Frame)
        btn:SetText("Eintragen")
        btn:Dock(BOTTOM)
        btn:SetTall(50)

        function btn:DoClick()

        end
    end

end



--gamemodes/starwarsrp/gamemode/modules/abilitys/sh_ability.lua:
AOCRP.Ability = AOCRP.Ability or {}


AOCRP.Ability.Items = {}


AOCRP.Ability.Items["ruestungsflicker1"] = {
    name = "Rstungsflicker 1",
    desc = "Repariert 1/6 der maximalen Rstung",
    icon = "RF1",
    cost = 1,
    requires = nil,
    run = function(ply) ply:SetArmor(math.min(ply:Armor()+ply:GetMaxArmor()/6, ply:GetMaxArmor())) end,
    delay = 180,
    passive = false,
}

AOCRP.Ability.Items["ruestungsflicker2"] = {
    name = "Rstungsflicker 2",
    desc = "Repariert 1/5 der maximalen Rstung",
    icon = "RF3",
    cost = 1,
    requires = "ruestungsflicker1",
    run = function(ply) ply:SetArmor(math.min(ply:Armor()+ply:GetMaxArmor()/5, ply:GetMaxArmor())) end,
    delay = 180,
    passive = false, 
}

AOCRP.Ability.Items["ruestungsflicker3"] = {
    name = "Rstungsflicker 3",
    desc = "Repariert 1/4 der maximalen Rstung",
    icon = "RF3",
    cost = 1,
    requires = "ruestungsflicker2",
    run = function(ply) ply:SetArmor(math.min(ply:Armor()+ply:GetMaxArmor()/4, ply:GetMaxArmor())) end,
    delay = 180,
    passive = false, 
}


AOCRP.Ability.Items["ruestungsflicker4"] = {
    name = "Rstungsflicker 4",
    desc = "Repariert 1/2 der maximalen Rstung",
    icon = "RF4",
    cost = 3,
    requires = "ruestungsflicker3",
    run = function(ply) ply:SetArmor(math.min(ply:Armor()+ply:GetMaxArmor()/2, ply:GetMaxArmor())) end,
    delay = 180,
    passive = false, 
}


AOCRP.Ability.Items["ruestungsflicker5"] = {
    name = "Rstungsflicker 5",
    desc = "Repariert die volle Rstung",
    icon = "RF5",
    cost = 5,
    requires = "ruestungsflicker4",
    run = function(ply) ply:SetArmor(ply:GetMaxArmor()) end,
    delay = 180,
    passive = false, 
}



AOCRP.Ability.Items["antischock"] = {
    name = "Antischock",
    desc = "Hebt einmalig einen Betubungsschuss auf.",
    icon = "AS",
    sound = "everfall/equipment/battle_command/start/health_battlecommand_start_var_01.mp3",
    cost = 10,
    requires = nil,
    run = function(ply) ply:Freeze(false) end,
    delay = 10,
    passive = false, 
}

AOCRP.Ability.Items["antischockextrem"] = {
    name = "Antischock Ultra",
    desc = "Hebt einen Betubungsschuss auf",
    icon = "ASU",
    sound = "everfall/equipment/battle_command/start/health_battlecommand_start_var_01.mp3",
    cost = 999,
    requires = "antischock",
    run = function(ply) ply:Freeze(false) end,
    delay = 0.1,
    passive = false, 
}

AOCRP.Ability.Items["jump"] = {
    name = "Hochsprung",
    desc = "Springe etwas hher als normal.",
    icon = "HS",
    cost = 3,
    requires = nil,
    run = function(ply) 
        local velocity = ply:GetVelocity()
        velocity.z = 400 -- Adjust the Z (vertical) velocity to leapHeight
        ply:SetVelocity(velocity)
    end,
    delay = 60,
    passive = false, 
}


AOCRP.Ability.Items["ammo"] = {
    name = "Munitionssammler",
    desc = "Gibt dir extra Munition fr die Waffe in deiner Hand",
    icon = "MS",
    cost = 2,
    requires = nil,
    run = function(ply) 
        wep = ply:GetActiveWeapon()
        if wep then
            ply:GiveAmmo(99999, wep:GetPrimaryAmmoType())
            ply:GiveAmmo(99999, wep:GetSecondaryAmmoType())
        end
    end,
    delay = 600,
    passive = false, 
}



AOCRP.Ability.Items["roll"] = {
    name = "Abrollen",
    desc = "Halten beim Fallen STRG gedrckt um den Schaden zu reduzieren",
    icon = "ABR",
    cost = 1,
    requires = nil,
    run = function(ply) 
    end,
    delay = 0,
    passive = true, 
}


AOCRP.Ability.Items["beserker"] = {
    name = "Beserker 1",
    desc = "Unzerstrbar fr 2.5s",
    icon = "BS1",
    cost = 5,
    requires = nil,
    run = function(ply) 
        ply:GodEnable()
        timer.Simple(2.5, function() if IsValid(ply) then ply:GodDisable() end end )
    end,
    delay = 600,
    passive = false,
}

AOCRP.Ability.Items["beserker2"] = {
    name = "Beserker 2",
    desc = "Unzerstrbar fr 5s",
    icon = "BS2",
    cost = 5,
    requires = "beserker",
    run = function(ply) 
        ply:GodEnable()
        timer.Simple(5, function() if IsValid(ply) then ply:GodDisable() end end )
    end,
    delay = 600,
    passive = false,
}


AOCRP.Ability.Items["camouflage1"] = {
    name = "Camouflage 1",
    desc = "Droiden sehen dich nicht fr 5s",
    icon = "CF1",
    cost = 2,
    requires = nil,
    run = function(ply) 
        ply:SetNoTarget(true)
        timer.Simple(5, function() if IsValid(ply) then ply:SetNoTarget(false) end end )
    end,
    delay = 180,
    passive = false,
}
AOCRP.Ability.Items["camouflage2"] = {
    name = "Camouflage 2",
    desc = "Droiden sehen dich nicht fr 10s",
    icon = "CF2",
    cost = 2,
    requires = "camouflage1",
    run = function(ply) 
        ply:SetNoTarget(true)
        timer.Simple(10, function() if IsValid(ply) then ply:SetNoTarget(false) end end )
    end,
    delay = 180,
    passive = false,
}
AOCRP.Ability.Items["camouflage3"] = {
    name = "Camouflage 3",
    desc = "Droiden sehen dich nicht fr 20s",
    icon = "CF3",
    cost = 2,
    requires = "camouflage2",
    run = function(ply)
        ply:SetNoTarget(true)
        timer.Simple(20, function() if IsValid(ply) then ply:SetNoTarget(false) end end )
    end,
    delay = 180,
    passive = false,
}


AOCRP.Ability.Items["speed1"] = {
    name = "Sprint 1",
    desc = "Sprinte 10% schneller fr 10s",
    icon = "SP1",
    cost = 1,
    requires = nil,
    run = function(ply) 

        local normalRun = ply:GetRunSpeed()
        local newRun = ply:GetRunSpeed() + ply:GetRunSpeed()*0.1

        ply:SetRunSpeed(newRun)


        timer.Simple(10, function() if IsValid(ply) then ply:SetRunSpeed(normalRun) end end )
    end,
    delay = 120,
    passive = false,
}
AOCRP.Ability.Items["speed2"] = {
    name = "Sprint 2",
    desc = "Sprinte 15% schneller fr 15s",
    icon = "SP2",
    cost = 1,
    requires = "speed1",
    run = function(ply) 

        local normalRun = ply:GetRunSpeed()
        local newRun = ply:GetRunSpeed() + ply:GetRunSpeed()*0.15

        ply:SetRunSpeed(newRun)


        timer.Simple(15, function() if IsValid(ply) then ply:SetRunSpeed(normalRun) end end )
    end,
    delay = 120,
    passive = false,
}
AOCRP.Ability.Items["speed3"] = {
    name = "Sprint 3",
    desc = "Sprinte 20% schneller fr 20s",
    icon = "SP3",
    cost = 1,
    requires = "speed2",
    run = function(ply) 

        local normalRun = ply:GetRunSpeed()
        local newRun = ply:GetRunSpeed() + ply:GetRunSpeed()*0.2

        ply:SetRunSpeed(newRun)


        timer.Simple(20, function() if IsValid(ply) then ply:SetRunSpeed(normalRun) end end )
    end,
    delay = 120,
    passive = false,
}
AOCRP.Ability.Items["speed4"] = {
    name = "Sprint 4",
    desc = "Sprinte 25% schneller fr 20s",
    icon = "SP4",
    cost = 1,
    requires = "speed3",
    run = function(ply) 

        local normalRun = ply:GetRunSpeed()
        local newRun = ply:GetRunSpeed() + ply:GetRunSpeed()*0.25

        ply:SetRunSpeed(newRun)


        timer.Simple(20, function() if IsValid(ply) then ply:SetRunSpeed(normalRun) end end )
    end,
    delay = 120,
    passive = false,
}
AOCRP.Ability.Items["speed5"] = {
    name = "Sprint 5",
    desc = "Sprinte 30% schneller fr 20s",
    icon = "SP5",
    cost = 1,
    requires = "speed4",
    run = function(ply) 

        local normalRun = ply:GetRunSpeed()
        local newRun = ply:GetRunSpeed() + ply:GetRunSpeed()*0.3

        ply:SetRunSpeed(newRun)


        timer.Simple(20, function() if IsValid(ply) then ply:SetRunSpeed(normalRun) end end )
    end,
    delay = 120,
    passive = false,
}
AOCRP.Ability.Items["speed6"] = {
    name = "Sprint 6",
    desc = "Sprinte 35% schneller fr 20s",
    icon = "SP6",
    cost = 1,
    requires = "speed5",
    run = function(ply) 

        local normalRun = ply:GetRunSpeed()
        local newRun = ply:GetRunSpeed() + ply:GetRunSpeed()*0.35

        ply:SetRunSpeed(newRun)


        timer.Simple(20, function() if IsValid(ply) then ply:SetRunSpeed(normalRun) end end )
    end,
    delay = 120,
    passive = false,
}

AOCRP.Ability.Items["speed7"] = {
    name = "Sprint 7",
    desc = "Sprinte 40% schneller fr 20s",
    icon = "SP7",
    cost = 1,
    requires = "speed6",
    run = function(ply) 

        local normalRun = ply:GetRunSpeed()
        local newRun = ply:GetRunSpeed() + ply:GetRunSpeed()*0.4

        ply:SetRunSpeed(newRun)


        timer.Simple(20, function() if IsValid(ply) then ply:SetRunSpeed(normalRun) end end )
    end,
    delay = 120,
    passive = false,
}
AOCRP.Ability.Items["speed8"] = {
    name = "Sprint 8",
    desc = "Sprinte 45% schneller fr 20s",
    icon = "SP8",
    cost = 1,
    requires = "speed7",
    run = function(ply) 

        local normalRun = ply:GetRunSpeed()
        local newRun = ply:GetRunSpeed() + ply:GetRunSpeed()*0.45

        ply:SetRunSpeed(newRun)


        timer.Simple(20, function() if IsValid(ply) then ply:SetRunSpeed(normalRun) end end )
    end,
    delay = 120,
    passive = false,
}
AOCRP.Ability.Items["speed9"] = {
    name = "Sprint 9",
    desc = "Sprinte 50% schneller fr 20s",
    icon = "SP9",
    cost = 1,
    requires = "speed8",
    run = function(ply) 

        local normalRun = ply:GetRunSpeed()
        local newRun = ply:GetRunSpeed() + ply:GetRunSpeed()*0.5

        ply:SetRunSpeed(newRun)


        timer.Simple(20, function() if IsValid(ply) then ply:SetRunSpeed(normalRun) end end )
    end,
    delay = 120,
    passive = false,
}

AOCRP.Ability.Items["reload1"] = {
    name = "Reload 1",
    desc = "Ldt sofort dein aktives Magazin nach",
    icon = "R1",
    cost = 1,
    requires = nil,
    run = function(ply) 

        local weapon = ply:GetActiveWeapon()

        if IsValid(weapon) then
            local maxClip = weapon:GetMaxClip1()
            weapon:SetClip1(maxClip) 
        end
    end,
    delay = 500,
    passive = false,
}

AOCRP.Ability.Items["reload2"] = {
    name = "Reload 2",
    desc = "Ldt sofort dein aktives Magazin nach",
    icon = "R2",
    cost = 1,
    requires = "reload1",
    run = function(ply) 

        local weapon = ply:GetActiveWeapon()

        if IsValid(weapon) then
            local maxClip = weapon:GetMaxClip1()
            weapon:SetClip1(maxClip) 
        end
    end,
    delay = 400,
    passive = false,
}

AOCRP.Ability.Items["reload3"] = {
    name = "Reload 3",
    desc = "Ldt sofort dein aktives Magazin nach",
    icon = "R3",
    cost = 1,
    requires = "reload2",
    run = function(ply) 

        local weapon = ply:GetActiveWeapon()

        if IsValid(weapon) then
            local maxClip = weapon:GetMaxClip1()
            weapon:SetClip1(maxClip) 
        end
    end,
    delay = 300,
    passive = false,
}

AOCRP.Ability.Items["reload4"] = {
    name = "Reload 4",
    desc = "Ldt sofort dein aktives Magazin nach",
    icon = "R4",
    cost = 1,
    requires = "reload3",
    run = function(ply) 

        local weapon = ply:GetActiveWeapon()

        if IsValid(weapon) then
            local maxClip = weapon:GetMaxClip1()
            weapon:SetClip1(maxClip) 
        end
    end,
    delay = 200,
    passive = false,
}

AOCRP.Ability.Items["reload5"] = {
    name = "Reload 5",
    desc = "Ldt sofort dein aktives Magazin nach",
    icon = "R5",
    cost = 1,
    requires = "reload4",
    run = function(ply) 

        local weapon = ply:GetActiveWeapon()

        if IsValid(weapon) then
            local maxClip = weapon:GetMaxClip1()
            weapon:SetClip1(maxClip) 
        end
    end,
    delay = 100,
    passive = false,
}
--addons/wos-passiveevent-ageo/lua/wos/pes/config/general/sh_permissions.lua:
wOS = wOS or {}
wOS.PES = wOS.PES or {}
wOS.PES.Config = wOS.PES.Config or {}

// What user groups can do every action?
wOS.PES.Config.FullPermissionUsergroup = {
    ["superadmin"] = true,
	["admin"] = true,
    ["Senior-Moderator"] = true,
    ["Moderator"] = true,
    ["Junior-Moderator"] = true
}

// What user groups can create new events?
wOS.PES.Config.CreateEventUsersgroup = {
    ["superadmin"] = true,
	["admin"] = true,
    ["Senior-Moderator"] = true,
    ["Moderator"] = true,
    ["Junior-Moderator"] = true
}

// What user groups can stop an event
wOS.PES.Config.StopUsergroup = {
	["superadmin"] = true,
    ["admin"] = true,
    ["Senior-Moderator"] = true,
    ["Moderator"] = true,
    ["Junior-Moderator"] = true
}

wOS.PES.Config.StartUsergroup = {
	["superadmin"] = true,
    ["admin"] = true,
    ["Senior-Moderator"] = true,
    ["Moderator"] = true,
    ["Junior-Moderator"] = true
}

wOS.PES.Config.StartTimeUsergroup = {
	["superadmin"] = true,
    ["admin"] = true,
    ["Senior-Moderator"] = true,
    ["Moderator"] = true,
    ["Junior-Moderator"] = true
}

wOS.PES.Config.StartRandomUsergroup = {
	["superadmin"] = true,
    ["admin"] = true,
    ["Senior-Moderator"] = true,
    ["Moderator"] = true,
    ["Junior-Moderator"] = true
}

wOS.PES.Config.CanSnoozeUsergroup = {
	["superadmin"] = true,
    ["admin"] = true,
    ["Senior-Moderator"] = true,
    ["Moderator"] = true,
    ["Junior-Moderator"] = true
}
--addons/wos-passiveevent-ageo/lua/wos/pes/addons/display/cl_entsdisplay.lua:


hook.Add("HUDPaint", "wOS.PES.DrwaInteractableNames", function()

	local tr = util.TraceLine({
		start = LocalPlayer():EyePos(),
		endpos = LocalPlayer():EyePos() + LocalPlayer():EyeAngles():Forward() * 100,
		filter = LocalPlayer(),
		mask = MASK_SHOT
	})

	if !tr.Hit or !IsValid(tr.Entity)  then return end

	local ent = tr.Entity

	// Need to figure out how to tell if this ent has come from the same event that the player is in
	// we could use event ids, with nw ints but that can cause issues with nw lag 

	if !ent:GetNWString("PES.DisplayMessage") then return end

	local pos = ent:GetPos() + ent:OBBCenter()

	local text = ent:GetNWString("PES.DisplayMessage")
	local pos = pos:ToScreen()
	local x, y = pos.x, pos.y

	draw.DrawText(text, "wOS.PES.CapturePoint", x, y, Color(255, 255, 255, 255), TEXT_ALIGN_CENTER)
end)

// should an addon be registered?

--addons/wos-passiveevent-ageo/lua/wos/pes/vars/float.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--


local VAR = {}
VAR.Name = "Float"

VAR.IsValid = function(varTable, value)
    if not isnumber(value) then
        return false
    end

    return true
end

VAR.DermaElement = function(varTable, value)
    local numSlider = vgui.Create("DNumSlider")
    numSlider.Label:SetColor( Color( 125, 0, 255 ) )

    if isnumber(varTable.Min) then
        numSlider:SetMin(varTable.Min)
    end

    if isnumber(varTable.Max) then
        numSlider:SetMax(varTable.Max)
    end

    if isnumber(value) then
        numSlider:SetValue(value)
    else
        numSlider:SetValue(varTable.Default)
    end

    return numSlider
end

VAR.GetValue = function(numSlider)
    return numSlider:GetValue()
end

return VAR

--addons/wos-passiveevent-ageo/lua/wos/pes/vars/list_uneditable.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--


local VAR = {}

VAR.Name = "Read-Only List"

VAR.IsValid = function(varTable, value)
    if not istable(value) then
        return false
    end

    for _, entry in pairs(value) do
        if not isstring(entry) then
            return false
        end
    end

    return true
end

VAR.DermaElement = function(varTable, value)
    local listView = vgui.Create("DListView")
    listView:SetTall(200)
    listView:SetMultiSelect(true)

    if isstring(varTable.Header) then
        listView:AddColumn(varTable.Header)
    else
        listView:AddColumn("Variable View")
    end
    
    if isstring( varTable.Values ) and string.Left(varTable.Values, 6) == "FUNC::" then
        local func_name = string.Replace( varTable.Values, "FUNC::", "" )
        local layers = string.Split( func_name, "." )

        local func = _G
        for _, layer in ipairs( layers ) do
            func = func[ layer ] 
        end
        varTable.Values = func()

    end

    for _, entry in pairs(varTable.Values or {}) do
        local line = listView:AddLine(entry)
        if table.HasValue(listView.SelectedValues, entry) then
            line:SetSelected(true)
        end
    end

    return listView
end

VAR.GetValue = function(listView)
    local values = {}
    for k, line in ipairs( listView:GetLines() ) do
        table.insert( values, line:GetValue( 1 ) )
    end
    return values
end

return VAR
--addons/wos-passiveevent-ageo/lua/wos/pes/vars/scene.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--


local VAR = {}

VAR.Name = "Scene"
VAR.DirtyValidate = true
VAR.IsValid = function(varTable, value)
	value = value or {}
	local a = {}
	for index, data in ipairs(value or {}) do
		// If we have old data, keep it.
		if istable(data) then 
			a[#a+1] = data 
			continue 
		end

		local ent = ents.GetByIndex(data)
		if not IsValid(ent) then continue end

		local data = wOS.PES.ReadEntity(ent)
		a[#a+1] = data
		ent:Remove()
	end

	-- who know that variable overrides don't update
	-- value = a doesn't work
	table.CopyFromTo( a, value )
	return true
end

VAR.DermaElement = function(varTable, value)
	local pnl = vgui.Create("DPanel")
	pnl.Paint = function() end
	local button = vgui.Create("DButton", pnl)

	button.data = value or {}
	button:SetText("Record") // Want to localise two variables here in the future to make maintaining easier

	pnl.button = button

	button:Dock(LEFT)
	
	button.DoClick = function(self)

		local scenemodule = wOS.PES.Modules:Get("scene")

		if button:GetText() == "Record" then
			button:SetText("Recording ...")
			wOS.PES:GetActiveMenu():Hide()
			if scenemodule and scenemodule.StartRecording then
				scenemodule.StartRecording(button)
				button.data = {}
			end
		else
			button:SetText("Record")
			if scenemodule and scenemodule.StopRecording then
				scenemodule.StopRecording(button)
			end
		end
	end

	local wipe = vgui.Create("DButton", pnl)
	wipe:Dock(LEFT)
	wipe:SetText("Reset")
	wipe.DoClick = function()
		button.data = {}
		if button:GetText() != "Record" then
			button:SetText("Record")
			if scenemodule and scenemodule.StopRecording then
				scenemodule.StopRecording(button)
			end
		end
	end

	return pnl
end

VAR.GetValue = function(dermaElement)
	return dermaElement.button.data
end

return VAR

--addons/wos-passiveevent-ageo/lua/wos/css/entities/wos_simulation_wall/sh_wos_simulation_wall.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2019
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--


--lua/weapons/antlion_dagger/shared.lua:
SWEP.Author       = "Segaretka"
SWEP.PrintName    = "Antlion dagger"
SWEP.Category     = "Gluk Melee"
SWEP.Contact      = "Type:Melee Class:Ant" 
SWEP.Purpose      = ""
SWEP.Instructions = "LMB to attack, RBM to special attack, Special +jump"
 
SWEP.AdminSpawnable = true
SWEP.AutoSwitchTo   = false
SWEP.Spawnable      = true
SWEP.AutoSwitchFrom = false
SWEP.FiresUnderwater= false
SWEP.Weight         = 5
SWEP.DrawCrosshair  = true
SWEP.Slot           = 0
SWEP.SlotPos        = 1
SWEP.DrawAmmo		= false
SWEP.base           = "weapon_base"
SWEP.HoldType       = "knife"

SWEP.UseHands = true
SWEP.ViewModelFOV   = 40
SWEP.ViewModel = "models/weapons/cstrike/c_knife_t.mdl"
SWEP.WorldModel = "models/weapons/w_knife_t.mdl"
SWEP.ViewModelFlip  = false
SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
["v_weapon.Knife_Handle"] = { scale = Vector(0.37, 0.37, 0.37), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) }
}
SWEP.VElements = {
	["hils++"] = { type = "Model", model = "models/gibs/antlion_gib_large_2.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0.55, 0, 4.675), angle = Angle(0, 0.8, 1.169), size = Vector(0.05, 0.172, 0.05), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["hils+"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, -0.102), angle = Angle(0, 90, 0), size = Vector(0.028, 0.039, 0.028), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/camera", skin = 0, bodygroup = {} },
	["hils+++"] = { type = "Model", model = "models/gibs/antlion_gib_large_2.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(-0.551, 0, 4.675), angle = Angle(180, 0.8, 180), size = Vector(0.05, 0.172, 0.05), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["hils"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "v_weapon.Knife_Handle", rel = "", pos = Vector(0, 0, -0.7), angle = Angle(0, 0.8, 0), size = Vector(0.05, 0.039, 0.108), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/bomb", skin = 0, bodygroup = {} },
	["blade"] = { type = "Model", model = "models/hunter/misc/squarecap1x1x1.mdl", bone = "ValveBiped.Bip01_Spine4", rel = "hils", pos = Vector(0, 0, 8.831), angle = Angle(0, 90, 0), size = Vector(0.041, 0.009, 0.172), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/ps_grass", skin = 0, bodygroup = {} }
}
SWEP.WElements = {
	["hils++"] = { type = "Model", model = "models/gibs/antlion_gib_large_2.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0.55, 0, 4.675), angle = Angle(0, 0.8, 1.169), size = Vector(0.05, 0.172, 0.05), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["hils+"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, -0.102), angle = Angle(0, 90, 0), size = Vector(0.028, 0.039, 0.028), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/camera", skin = 0, bodygroup = {} },
	["hils+++"] = { type = "Model", model = "models/gibs/antlion_gib_large_2.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(-0.551, 0, 4.675), angle = Angle(180, 0.8, 180), size = Vector(0.05, 0.172, 0.05), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["hils"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3, 1, 2.5), angle = Angle(-170, -31.559, 8), size = Vector(0.05, 0.039, 0.108), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/bomb", skin = 0, bodygroup = {} },
	["blade"] = { type = "Model", model = "models/hunter/misc/squarecap1x1x1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, 8.831), angle = Angle(0, 90, 0), size = Vector(0.041, 0.009, 0.172), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/ps_grass", skin = 0, bodygroup = {} }
}

SWEP.BobScale = 1
SWEP.SwayScale = 0

SWEP.Idle = 0
SWEP.IdleTimer = CurTime()

SWEP.Primary.ClipSize 	 = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic   = true
SWEP.Primary.Ammo 		 = "none"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

SWEP.Primary.Damage 	 = 10
SWEP.Primary.DelayMiss	 = 1
SWEP.Primary.DelayHit 	 = 0.26
SWEP.Primary.Force 		 = 1
SWEP.Primary.ImpactDecal = "ManhackCut"
SWEP.Primary.Range       = 10

SWEP.Secondary.Damage 	   = 30
SWEP.Secondary.DelayMiss   = 1.5
SWEP.Secondary.DelayHit	   = 0.7
SWEP.Secondary.Force	   = 5
SWEP.Secondary.ImpactDecal = "Impact.Metal"
SWEP.Secondary.Range       = 12

local SwingSound = Sound( "WeaponFrag.Roll" )
local HitSoundWorld = Sound( "GlassBottle.ImpactHard" )
local HitSoundBody = Sound( "Flesh_Bloody.ImpactHard" )
local HitSoundProp = Sound( "" )
local indec = 0

SWEP.indec = 0
SWEP.SetJumpPower=205

function SWEP:Initialize()
self:SetWeaponHoldType( self.HoldType )
self.Idle = 0
self.IdleTimer = CurTime() + 1
end

function SWEP:Deploy()
self:SetWeaponHoldType( self.HoldType )
self.Weapon:SendWeaponAnim( ACT_VM_DRAW )
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
return true
end

function SWEP:Holster()
self.Idle = 0
self.IdleTimer = CurTime()
self.indec = 0
self.Owner:SetJumpPower(self.SetJumpPower)
return true
end

function SWEP:PrimaryAttack()
self:SetHoldType( self.HoldType )
self:EmitSound( SwingSound )
local bullet = {}
bullet.Num = 1
bullet.Src = self.Owner:GetShootPos()
bullet.Dir = self.Owner:GetAimVector()
bullet.Distance = self.Primary.Distance
bullet.Spread = Vector( 0, 0, 0 )
bullet.Tracer = 0
bullet.Force = self.Primary.Force
bullet.Damage = 0
bullet.AmmoType = "none"

local tr = util.TraceLine( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Primary.Range*4,
filter = self.Owner,
mask = MASK_SHOT_HULL,
} )
if ( tr.Hit ) then
util.Decal(self.Primary.ImpactDecal, tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)  
end
if !IsValid( tr.Entity ) then
tr = util.TraceHull( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Primary.Range*4,
filter = self.Owner,
mins = Vector( -1* self.Primary.Range, -1*self.Primary.Range, 0 ),
maxs = Vector(  1* self.Primary.Range,  1*self.Primary.Range, 0 ),
mask = MASK_SHOT_HULL,
} )
end
if SERVER then
if IsValid( tr.Entity ) then
local dmg = DamageInfo()
local attacker = self.Owner
if !IsValid( attacker ) then
attacker = self
end
dmg:SetAttacker( attacker )
dmg:SetInflictor( self )
dmg:SetDamage( self.Primary.Damage )
dmg:SetDamageForce( self.Owner:GetForward() * self.Primary.Force )
tr.Entity:TakeDamageInfo( dmg )
end
if ( tr.Hit ) then
		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") or string.find(tr.Entity:GetClass(),"prop_physics") then
		if string.find(tr.Entity:GetClass(),"prop_physics") then
		self:EmitSound( HitSoundProp )
		else
		self:EmitSound( HitSoundBody )
		if self.indec < 11 then
		self.Owner:SetJumpPower(self.SetJumpPower+20)
		self.SetJumpPower=self.SetJumpPower +25
		self.indec = self.indec + 1
		
		end
		end
		self.Owner:FireBullets(bullet)	
		else
		self:EmitSound( HitSoundWorld )
		end
		end
end
if !tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_PRIMARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayMiss )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayMiss )
end
if tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_MISSCENTER )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayHit )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayHit )
end
self:ShootEffects()
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end


function SWEP:SecondaryAttack()
self:SetHoldType( self.HoldType )
self:EmitSound( SwingSound )
local bullet = {}
bullet.Num = 1
bullet.Src = self.Owner:GetShootPos()
bullet.Dir = self.Owner:GetAimVector()
bullet.Distance = self.Secondary.Distance
bullet.Spread = Vector( 0, 0, 0 )
bullet.Tracer = 0
bullet.Force = self.Secondary.Force
bullet.Damage = 0
bullet.AmmoType = "none"

local tr = util.TraceLine( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Secondary.Range*4,
filter = self.Owner,
mask = MASK_SHOT_HULL,
} )
if ( tr.Hit ) then
util.Decal(self.Secondary.ImpactDecal, tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)  
end
if !IsValid( tr.Entity ) then
tr = util.TraceHull( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Secondary.Range*4,
filter = self.Owner,
mins = Vector( -16, -16, 0 ),
maxs = Vector( 16, 16, 0 ),
mask = MASK_SHOT_HULL,
} )
end
if SERVER then
if IsValid( tr.Entity ) then
local dmg = DamageInfo()
local attacker = self.Owner
if !IsValid( attacker ) then
attacker = self
end
dmg:SetAttacker( attacker )
dmg:SetInflictor( self )
dmg:SetDamage( self.Secondary.Damage )
dmg:SetDamageForce( self.Owner:GetForward() * self.Secondary.Force )
tr.Entity:TakeDamageInfo( dmg )
end
if ( tr.Hit ) then
		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") or string.find(tr.Entity:GetClass(),"prop_physics") then
		if string.find(tr.Entity:GetClass(),"prop_physics") then
		self:EmitSound( HitSoundProp )
		else
		self:EmitSound( HitSoundBody )
		if self.indec < 11 then
		self.Owner:SetJumpPower(self.SetJumpPower+20)
		self.SetJumpPower=self.SetJumpPower +25
		self.indec = self.indec + 1
		end
		end
		self.Owner:FireBullets(bullet)	
		else
		self:EmitSound( HitSoundWorld )
		end
		end
end
if !tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_SECONDARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Secondary.DelayMiss )
self:SetNextSecondaryFire( CurTime() + self.Secondary.DelayMiss )
end
if tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_SECONDARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Secondary.DelayHit )
self:SetNextSecondaryFire( CurTime() + self.Secondary.DelayHit )
end
self:ShootEffects()
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end

function SWEP:ShootEffects()
self.Owner:SetAnimation( PLAYER_ATTACK1 )
end

function SWEP:Reload()
end

function SWEP:Think()
if self.IdleTimer <= CurTime() then
if self.Idle == 0 then
self.Idle = 1
end
if SERVER and self.Idle == 1 then
self.Weapon:SendWeaponAnim( ACT_VM_IDLE )
end
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end
end


/********************************************************
	SWEP Construction Kit base code
		Created by Clavus
	Available for public use, thread at:
	   facepunch.com/threads/1032378
	   
	   
	DESCRIPTION:
		This script is meant for experienced scripters 
		that KNOW WHAT THEY ARE DOING. Don't come to me 
		with basic Lua questions.
		
		Just copy into your SWEP or SWEP base of choice
		and merge with your own code.
		
		The SWEP.VElements, SWEP.WElements and
		SWEP.ViewModelBoneMods tables are all optional
		and only have to be visible to the client.
********************************************************/

function SWEP:Initialize()

	// other initialize code goes here

	if CLIENT then
		
		self:SetWeaponHoldType( self.HoldType )	
		// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		// init view model bone build function
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				--[[// Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end]]--
			end
		end
		
	end

end

function SWEP:Holster()
	
	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	
	return true
end

function SWEP:OnRemove()
	self:Holster()
end

if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			// we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			// when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			// !! WORKAROUND !! //
			// We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			// !! ----------- !! //
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				// !! WORKAROUND !! //
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				// !! ----------- !! //
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

	/**************************
		Global utility code
	**************************/

	// Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	// Does not copy entities of course, only copies their reference.
	// WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end


--gamemodes/starwarsrp/entities/weapons/aocrp_rs4.lua:

AddCSLuaFile()

SWEP.Author			= "Hoff"
SWEP.Instructions	= ""

SWEP.Category = "AOCRP - Eingestellte Waffen"
SWEP.Spawnable			= true
SWEP.AdminSpawnable		= true

SWEP.ViewModel			= "models/hoff/weapons/c4/c_c4.mdl"
SWEP.WorldModel			= "models/hoff/weapons/c4/w_c4.mdl"
SWEP.ViewModelFOV = 75

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= 5
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo		= "slam"
SWEP.Primary.Delay = 1

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= true
SWEP.Secondary.Ammo			= "none"

SWEP.Weight				= 5
SWEP.AutoSwitchTo		= false
SWEP.AutoSwitchFrom		= false

SWEP.PrintName			= "RS-4"
SWEP.Slot				= 4
SWEP.SlotPos			= 1
SWEP.DrawAmmo			= true
SWEP.DrawCrosshair		= false

SWEP.UseHands = true

SWEP.Offset = {
	Pos = {
		Up = 0,
		Right = 7,
		Forward = 3.5,
	},
	Ang = {
		Up = 0,
		Right = 90,
		Forward = 190,
	}
}
function SWEP:DrawWorldModel( )
	if not IsValid( self:GetOwner() ) then
		self:DrawModel( )
		return
	end

	local bone = self:GetOwner():LookupBone( "ValveBiped.Bip01_R_Hand" )
	if not bone then
		self:DrawModel( )
		return
	end

	local pos, ang = self:GetOwner():GetBonePosition( bone )
	pos = pos + ang:Right() * self.Offset.Pos.Right + ang:Forward() * self.Offset.Pos.Forward + ang:Up() * self.Offset.Pos.Up
	ang:RotateAroundAxis( ang:Right(), self.Offset.Ang.Right )
	ang:RotateAroundAxis( ang:Forward(), self.Offset.Ang.Forward )
	ang:RotateAroundAxis( ang:Up(), self.Offset.Ang.Up )

	self:SetRenderOrigin( pos )
	self:SetRenderAngles( ang )

	self:DrawModel()
end

function SWEP:Deploy()
	if not self:GetOwner().C4s or #self:GetOwner().C4s == 0 then 
		self:GetOwner().C4s = {} 
	end
	timer.Simple(0.3, function()
		if IsValid(self) then
			self:EmitSound("hoff/mpl/seal_c4/bar_selectorswitch.wav", 45) 
		end
	end)
	self:SetCollisionGroup(COLLISION_GROUP_NONE)
	self:SetHoldType("Slam")
end

function SWEP:StartExplosionChain()
	if table.Count(self:GetOwner().C4s) <= 0 then
		return
	end
	local ent = self:GetOwner().C4s[1] -- Get the first entity in the table

	if not IsValid(ent) then
		table.remove(self:GetOwner().C4s, 1)
		self:StartExplosionChain()
		return
	end

	if ent.QueuedForExplode then
		return
	end

	ent.QueuedForExplode = true
	ent.ExplodedViaWorld = false
	ent:DelayedDestroy(true)
end

function SWEP:PrimaryAttack()
	self:SendWeaponAnim(ACT_VM_PRIMARYATTACK)	

	timer.Simple(0.1,function() 
		if IsValid(self) then 
			self:EmitSound("hoff/mpl/seal_c4/c4_click.wav") 
		end 
	end)

	if self:GetOwner():Alive() and self:GetOwner():IsValid() then
		if SERVER then
			timer.Simple(0.175, function() 
				if IsValid(self) then
					self:StartExplosionChain()
				end
			end)
		end	
	end

	self:SetNextPrimaryFire(CurTime() + 1.1)

	-- Need to stop insane values from crashing servers
	local ClampedThrowSpeed = math.Clamp(GetConVar("C4_ThrowSpeed"):GetFloat(), 0.25, 10)
	self:SetNextSecondaryFire(CurTime() + (0.8 / ClampedThrowSpeed))
end

hook.Add("PlayerDeath", "SetAllC4sUnowned", function(victim, weapon, killer)
	if IsValid(victim) and victim:IsPlayer() and victim.C4s and #victim.C4s > 0 then
		for k,v in pairs(victim.C4s) do
			victim.C4s[k].ExplodedViaWorld = true
		end
	end
end)

function SWEP:SecondaryAttack()

	if GetConVar("C4_Infinite"):GetInt() == 0 and self:Ammo1() <= 0 then
		return
	end

	self:SendWeaponAnim(ACT_VM_THROW)	
	self:GetOwner():SetAnimation(PLAYER_ATTACK1)

	self:EmitSound("hoff/mpl/seal_c4/whoosh_01.wav")
	timer.Simple(0.095, function()
		if !IsValid(self) then
			return
		end
		if SERVER then

			local TargetPosition = self:GetOwner():GetShootPos() + (self:GetOwner():GetRight() * -8) + (self:GetOwner():GetUp() * -1) + (self:GetOwner():GetForward() * 10)

			local model = "models/hoff/weapons/c4/w_c4.mdl"
			util.PrecacheModel(model)

--[[ 			local TempC4 = ents.Create("prop_physics")
			TempC4:SetModel(model)
			TempC4:SetPos(TargetPosition)
			TempC4:SetCollisionGroup(COLLISION_GROUP_NONE)
			TempC4:Spawn()

			local mins, maxs = TempC4:GetCollisionBounds()

			TempC4:Remove() ]]


			local ent = ents.Create("rs4_ent")
			ent:SetPos(Vector(0,0,0))
			ent:SetOwner(self:GetOwner())  -- Disables collision between the C4 and its owner
			ent:SetPos(TargetPosition)
			ent:SetAngles(Angle(1,0,0))
			ent:Spawn()
			ent:SetOwner(self:GetOwner())  -- Disables collision between the C4 and its owner
			ent.C4Owner = self:GetOwner()
			ent.ThisTrigger = self
			ent.ExplodedViaWorld = false
			ent.QueuedForExplode = false
			ent.UniqueExplodeTimer = "ExplodeTimer" .. self:GetOwner():SteamID() .. math.Rand(1, 1000)
			ent:SetNWString("OwnerID", self:GetOwner():SteamID())

			local phys = ent:GetPhysicsObject()

			--phys:SetMass(0.6)

			-- Compensate for the offcenter spawn
			local aimvector = self:GetOwner():GetAimVector()
			local aimangle = aimvector:Angle()
			aimangle:RotateAroundAxis(aimangle:Up(), -1.5)
			aimvector = aimangle:Forward()
			phys:ApplyForceCenter( aimvector * 1500)

			-- The positive z coordinate emulates the spin from a left underhand throw
			local angvel = Vector(0, math.random(-5000,-2000), math.random(-100,-900))
			angvel:Rotate(-1 * ent:EyeAngles())
			angvel:Rotate(Angle(0, self:GetOwner():EyeAngles().y, 0))

			--local angvel = Vector(0, math.random(-5000,-2000), math.random(-100,-900))
			angvel.x = math.Clamp(angvel.x, -1000, 1000)
			angvel.y = math.Clamp(angvel.y, -1000, 1000)
			angvel.z = math.Clamp(angvel.z, -1000, 1000)

			phys:SetAngleVelocity(Vector(math.Clamp(angvel.x, -2000, 2000), math.Clamp(angvel.y, -2000, 2000), math.Clamp(angvel.z, -2000, 2000)))

			table.insert( self:GetOwner().C4s, ent )
			if engine.ActiveGamemode() ~= "nzombies" then
				undo.Create("C4")
					undo.AddEntity(ent)
					undo.SetPlayer(self:GetOwner())
					undo.AddFunction(function(undo)
						local ent = undo.Entities[1]

						-- Check if the entity is still valid
						if ent:IsValid() then
							-- Remove the entity from the owner's C4s table
							table.RemoveByValue(undo.Owner.C4s, ent)
						else
							-- The c4 doesn't exist anymore (probably exploded)
							return false
						end
					end)
				undo.Finish()

				self:GetOwner():AddCount("sents", ent) -- Add to the SENTs count ( ownership )
				self:GetOwner():AddCount("my_props", ent) -- Add count to our personal count
				self:GetOwner():AddCleanup("sents", ent) -- Add item to the sents cleanup
				self:GetOwner():AddCleanup("my_props", ent) -- Add item to the cleanup
			end
		end

		if GetConVar("C4_Infinite"):GetInt() == 0 then
			self:GetOwner():RemoveAmmo(1,"slam")
		end
	end)

	self:SetNextPrimaryFire(CurTime() + 1.1)

	-- Need to stop insane values from crashing servers
	local ClampedThrowSpeed = math.Clamp(GetConVar("C4_ThrowSpeed"):GetFloat(), 0.25, 10)
	self:SetNextSecondaryFire(CurTime() + (0.8 / ClampedThrowSpeed))
end

function SWEP:ShouldDropOnDie()
	return false
end

function SWEP:Reload()
	-- First, check if the reload delay has expired
	if self.ReloadDelay and CurTime() < self.ReloadDelay then 
		return
	end

	-- Trace a line to a hit location and do a sphere trace from there and sort by distance
	-- We have to do this because GetEyeTrace to a c4 parented to an entity is unreliable
	local trace = util.TraceLine({
		start = self:GetOwner():EyePos(),
		endpos = self:GetOwner():EyePos() + self:GetOwner():EyeAngles():Forward() * 85,
		filter = {self:GetOwner()}
	})
	local hitPos = trace.HitPos
	local c4s = ents.FindInSphere(hitPos, 1)
	table.sort(c4s, function(a, b) return a:GetPos():Distance(hitPos) < b:GetPos():Distance(hitPos) end)
	local hitEnt = nil
	for _, ent in ipairs(c4s) do
		if ent:GetClass() == "rs4_ent" then
			hitEnt = ent
			break
		end
	end

	-- Check if the trace hit an entity and if it is a C4 entity
	if IsValid(hitEnt) and hitEnt:GetClass() == "rs4_ent" then
		-- Check if the C4 entity is owned by the player
		if hitEnt:GetNWString("OwnerID") == self:GetOwner():SteamID() then

			if self:GetOwner():EyePos():Distance(hitEnt:GetPos()) > 85 then 
				return 
			end

			local effectData = EffectData()
			effectData:SetOrigin(hitEnt:GetPos())
			util.Effect("inflator_magic", effectData)

			if SERVER then
				if GetConVar("C4_Infinite"):GetBool() == false then
					-- Give the player one "Slam" ammo
					self:GetOwner():GiveAmmo(1, "Slam")
				end

				-- Remove the C4 entity from the player's C4s array
				if table.HasValue(self:GetOwner().C4s, hitEnt) then
					table.RemoveByValue(self:GetOwner().C4s, hitEnt)
				end

				-- Remove the C4 entity from the world
				hitEnt:Remove()
			else
				--if self.HasContextAnims then
				--	net.Start("VManip_SimplePlay") 
				--	net.WriteString("use") 
				--	net.Send(self.Owner)
				--end
			end
			
			-- Set the reload delay so the player cannot reload again for 0.5 seconds
			self.ReloadDelay = CurTime() + 0.5
		end
	end
end

function SWEP:DrawHUD()
	surface.SetDrawColor( 255, 255, 255, 255 )
	surface.SetMaterial( Material("models/hoff/weapons/c4/c4_reticle.png") )
	surface.DrawTexturedRect( ScrW() / 2 - 16, ScrH() / 2 - 16, 32, 32 )
end

--gamemodes/starwarsrp/entities/weapons/aocrp_twld1.lua:
if SERVER then
	AddCSLuaFile()
	SWEP.Weight = 20
	SWEP.AutoSwitchTo = false
	SWEP.AutoSwitchFrom = false
end
if CLIENT then
	SWEP.PrintName = "TW-LD1"
	SWEP.Slot = 1
	SWEP.SlotPos = 1
	SWEP.DrawAmmo = false
	SWEP.DrawCrosshair = true
	SWEP.WepSelectIcon = surface.GetTextureID("vgui/entities/intscope_icon")
end



SWEP.Spawnable = true
SWEP.AdminSpawnable = true
SWEP.AdminOnly = false
SWEP.Base = "weapon_base"
SWEP.HoldType = "camera"
SWEP.Category = "AOCRP - Eingestellte Waffen"
SWEP.ViewModel = "models/vm_view/c_intscope.mdl"
SWEP.WorldModel = "models/MaxOfS2D/camera.mdl"

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Delay = 0.05
SWEP.Primary.Ammo = "none"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"
SWEP.UseHands = true


SWEP.WElements = {
	["element_name"] = { type = "Model", model = "models/vm_view/c_intscope.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(-22.338, 9.869, -7.792), angle = Angle(3.506, 5.843, -157.793), size = Vector(1.5, 1.5, 1.5), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}


/********************************************************
	SWEP Construction Kit base code
		Created by Clavus
	Available for public use, thread at:
	   facepunch.com/threads/1032378
	   
	   
	DESCRIPTION:
		This script is meant for experienced scripters 
		that KNOW WHAT THEY ARE DOING. Don't come to me 
		with basic Lua questions.
		
		Just copy into your SWEP or SWEP base of choice
		and merge with your own code.
		
		The SWEP.VElements, SWEP.WElements and
		SWEP.ViewModelBoneMods tables are all optional
		and only have to be visible to the client.
********************************************************/

SWEP.ShowWorldModel = false
SWEP.ViewModelBoneMods = {}


function SWEP:Initialize()

	// other initialize code goes here
	self.cooldown = 0
	if CLIENT then
		defFov = LocalPlayer():GetFOV()
	end
	self:SetHoldType( "camera")


	if CLIENT then
	
		// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		// init view model bone build function
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				// Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end
			end
		end
		
	end

end

function SWEP:Holster()
	
	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	
	return true
end

function SWEP:OnRemove()
	self:Holster()
end

if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			// we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			// when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			// !! WORKAROUND !! //
			// We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			// !! ----------- !! //
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				// !! WORKAROUND !! //
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				// !! ----------- !! //
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

	/**************************
		Global utility code
	**************************/

	// Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	// Does not copy entities of course, only copies their reference.
	// WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end







function SWEP:PrimaryAttack()

	if !IsFirstTimePredicted() then return end

	if self:GetNetVar("Zoomed",false) then
		
		local zoom = self:GetNetVar("ZoomStufe", 1)

		if zoom < 5 then
			self:SetNetVar("ZoomStufe", zoom+1)
		else
			self:SetNetVar("ZoomStufe", 1)
		end
	end

	self:EmitSound("zoomfirst.wav")

	self:SetNextPrimaryFire(CurTime()+1)
end


function SWEP:Reload()
	if !IsFirstTimePredicted() then return end

	if CurTime() < self.cooldown then return end
	if !self:GetNetVar("Zoomed",false) then return end
	self.cooldown = CurTime() + 2



	self.Owner:SetNetVar("AOCRP_LaserTarget", self.Owner:GetEyeTrace().HitPos)

	self:EmitSound("zoomfinal.wav")

	

end

function SWEP:SecondaryAttack()

	if !IsFirstTimePredicted() then return end

	if SERVER then
		self:SetNetVar("Zoomed", !self:GetNetVar("Zoomed",false))
	end

	if !self:GetNetVar("Zoomed",false) then
		self:EmitSound("openbinoculars.wav")
		self:SetHoldType( "normal")
	else
		self:EmitSound("closebinoculars.wav")
		self:SetHoldType( "camera")
	end

	self:SetNextSecondaryFire(CurTime()+1)
end


function SWEP:Think()

--[[ 
		local laserTarget = self.Owner:GetNetVar("AOCRP_LaserTarget", nil)
		if isvector(laserTarget) then
			if !self.Owner:KeyDown(IN_RELOAD) then
				self.Owner:SetNetVar("AOCRP_LaserTarget", nil)
			end
		end ]]

end


function SWEP:DoDrawCrosshair(x, y)
end


function SWEP:TranslateFOV( fov )

	if self:GetNetVar("Zoomed",false) then
		if self:GetNetVar("ZoomStufe", 1) == 5 then
			return fov / 10
		end
		if self:GetNetVar("ZoomStufe", 1) == 4 then
			return fov / 7
		end
		if self:GetNetVar("ZoomStufe", 1) == 3 then
			return fov / 5
		end
		if self:GetNetVar("ZoomStufe", 1) == 2 then
			return fov / 3
		end
		if self:GetNetVar("ZoomStufe", 1) == 1 then
			return fov /  2
		end

	else
		return fov
	end
end

if CLIENT then



	function SWEP:CalcViewModelView( ViewModel, OldEyePos, OldEyeAng, EyePos, EyeAng )
		if self:GetNetVar("Zoomed",false) then
			return OldEyePos - OldEyeAng:Forward()*10000, OldEyeAng
		end
	end



	surface.CreateFont("OverFont", {
		font = "Agency FB",
		size = ScreenScale(8.5),
		weight = 5000,
		shadow = false
	})
	

	local mouseX, mouseY = 0, 0
	local elevation = 0
	local compass = 0

	local screenScaleX = ScrW() / 1920
	local screenScaleY = ScrH() / 1080
	
	local centerX = (ScrW() / 2)
	local centerY = (ScrH() / 2)

	function SWEP:DrawHUD()

	if self:GetNetVar("Zoomed",false) then
		
	
			local EyeTrace = LocalPlayer():GetEyeTrace()

			local HitPos = EyeTrace.HitPos 
			local Distance = LocalPlayer():GetPos():Distance(HitPos)  * 1.905 / 100


				
				local binAlpha = math.Rand(100, 255)
				
				surface.SetDrawColor(255, 255, 255, 255)
				surface.SetTexture(surface.GetTextureID("overlay.vtf"))
				surface.DrawTexturedRect(0, 0, ScrW(), ScrH())
				surface.SetDrawColor(255, 255, 255, binAlpha)
				surface.SetTexture(surface.GetTextureID("cross.vtf"))
				surface.DrawTexturedRect(mouseX, mouseY, ScrW(), ScrH())
				surface.SetTexture(surface.GetTextureID("elevation.vtf"))
				surface.DrawTexturedRect(mouseX - 325*screenScaleX, mouseY + 7*screenScaleY - elevation*screenScaleY/ScrH()*3000*screenScaleY, ScrW(), ScrH())



				draw.DrawText(math.Round(Distance), "OverFont", AOCW(634), AOCH(527),Color(255, 255, 255, binAlpha*0.75), TEXT_ALIGN_RIGHT )
				



				draw.DrawText("DISTANZ", "OverFont", AOCW(573), AOCH(235),Color(255, 255, 255, binAlpha*0.75), TEXT_ALIGN_LEFT )

				draw.DrawText("ZOOM", "OverFont", AOCW(1350), AOCH(235),Color(255, 255, 255, binAlpha*0.75), TEXT_ALIGN_RIGHT )
				

				local target = self.Owner:GetNetVar("AOCRP_LaserTarget", nil)
				if isvector(target) then
					draw.DrawText("ZIEL ERFASST", "OverFont", ScrW()/2, AOCH(235),Color(255, 0, 0, binAlpha*0.75), TEXT_ALIGN_CENTER )

					draw.DrawText("X ="..target.x.." / Y = "..target.y.. " / Z = ".. target.z, "OverFont", ScrW()/2, AOCH(110),Color(255, 255, 255, binAlpha*0.75), TEXT_ALIGN_CENTER )
				end
				
				surface.SetDrawColor(255, 255, 255, binAlpha*0.75)
				surface.DrawRect(AOCW(1312), mouseY + 1080/2*screenScaleY+50*screenScaleY - LocalPlayer():GetFOV()/defFov*screenScaleY * 575, 30*screenScaleX, 10*screenScaleY)
				surface.DrawRect(mouseX + 1312*screenScaleX, mouseY + 1080/2*screenScaleY-60*screenScaleY + LocalPlayer():GetFOV()/defFov*screenScaleY * 575, 30*screenScaleX, 10*screenScaleY)
				
			

				draw.DrawText( "X" .. math.Round(defFov/LocalPlayer():GetFOV()), "OverFont", AOCW(1350), AOCH(820),Color(255, 255, 255, binAlpha*0.75), TEXT_ALIGN_RIGHT )
				

				
		
			end
	end
end


--addons/arccw_base_modified/lua/weapons/arccw_base/sh_think.lua:
if CLIENT then
    ArcCW.LastWeapon = nil
end

local vec1 = Vector(1, 1, 1)
local vec0 = vec1 * 0
local ang0 = Angle(0, 0, 0)

local lastUBGL = 0
function SWEP:Think()
    if IsValid(self:GetOwner()) and self:GetClass() == "arccw_base" then
        self:Remove()
        return
    end

    local owner = self:GetOwner()

    if !IsValid(owner) or owner:IsNPC() then return end

    if self:GetState() == ArcCW.STATE_DISABLE and !self:GetPriorityAnim() then
        self:SetState(ArcCW.STATE_IDLE)

        if CLIENT and self.UnReady then
            self.UnReady = false
        end
    end

    for i, v in ipairs(self.EventTable) do
        for ed, bz in pairs(v) do
            if ed <= CurTime() then
                if bz.AnimKey and (bz.AnimKey != self.LastAnimKey or bz.StartTime != self.LastAnimStartTime) then
                    continue
                end
                self:PlayEvent(bz)
                self.EventTable[i][ed] = nil
                --print(CurTime(), "Event completed at " .. i, ed)
                if table.IsEmpty(v) and i != 1 then self.EventTable[i] = nil --[[print(CurTime(), "No more events at " .. i .. ", killing")]] end
            end
        end
    end

    if CLIENT and (!game.SinglePlayer() and IsFirstTimePredicted() or true)
            and self:GetOwner() == LocalPlayer() and ArcCW.InvHUD
            and !ArcCW.Inv_Hidden and ArcCW.Inv_Fade == 0 then
        ArcCW.InvHUD:Remove()
        ArcCW.Inv_Fade = 0.01
    end

    local vm = owner:GetViewModel()

    self.BurstCount = self:GetBurstCount()

    local sg = self:GetShotgunReloading()
    if (sg == 2 or sg == 4) and owner:KeyPressed(IN_ATTACK) then
        self:SetShotgunReloading(sg + 1)
    elseif (sg >= 2) and self:GetReloadingREAL() <= CurTime() then
        self:ReloadInsert((sg >= 4) and true or false)
    end

    self:InBipod()

    if self:GetNeedCycle() and !self.Throwing and !self:GetReloading() and self:GetWeaponOpDelay() < CurTime() and self:GetNextPrimaryFire() < CurTime() and -- Adding this delays bolting if the RPM is too low, but removing it may reintroduce the double pump bug. Increasing the RPM allows you to shoot twice on many multiplayer servers. Sure would be convenient if everything just worked nicely
            (!ArcCW.ConVars["clicktocycle"]:GetBool() and (self:GetCurrentFiremode().Mode == 2 or !owner:KeyDown(IN_ATTACK))
            or ArcCW.ConVars["clicktocycle"]:GetBool() and (self:GetCurrentFiremode().Mode == 2 or owner:KeyPressed(IN_ATTACK))) then
        local anim = self:SelectAnimation("cycle")
        anim = self:GetBuff_Hook("Hook_SelectCycleAnimation", anim) or anim
        local mult = self:GetBuff_Mult("Mult_CycleTime")
        local p = self:PlayAnimation(anim, mult, true, 0, true)
        if p then
            self:SetNeedCycle(false)
            self:SetPriorityAnim(CurTime() + self:GetAnimKeyTime(anim, true) * mult)
        end
    end

    if self:GetGrenadePrimed() and !(owner:KeyDown(IN_ATTACK) or owner:KeyDown(IN_ATTACK2)) and (!game.SinglePlayer() or SERVER) then
        self:Throw()
    end

    if self:GetGrenadePrimed() and self.GrenadePrimeTime > 0 and self.isCooked then
        local heldtime = (CurTime() - self.GrenadePrimeTime)

        local ft = self:GetBuff_Override("Override_FuseTime") or self.FuseTime

        if ft and (heldtime >= ft) and (!game.SinglePlayer() or SERVER) then
            self:Throw()
        end
    end

    if IsFirstTimePredicted() and self:GetNextPrimaryFire() < CurTime() and owner:KeyReleased(IN_USE) then
        if self:InBipod() then
            self:ExitBipod()
        else
            self:EnterBipod()
        end
    end

    if ((game.SinglePlayer() and SERVER) or (!game.SinglePlayer() and true)) and self:GetBuff_Override("Override_TriggerDelay", self.TriggerDelay) then
        if owner:KeyReleased(IN_ATTACK) and self:GetBuff_Override("Override_TriggerCharge", self.TriggerCharge) and self:GetTriggerDelta(true) >= 1 then
            self:PrimaryAttack()
        else
            self:DoTriggerDelay()
        end
    end

    if self:GetCurrentFiremode().RunawayBurst then

        if self:GetBurstCount() > 0 and ((game.SinglePlayer() and SERVER) or (!game.SinglePlayer() and true)) then
            self:PrimaryAttack()
        end

        if self:Clip1() < self:GetBuff("AmmoPerShot") or self:GetBurstCount() == self:GetBurstLength() then
            self:SetBurstCount(0)
            if !self:GetCurrentFiremode().AutoBurst then
                self.Primary.Automatic = false
            end
        end
    end

    if owner:KeyReleased(IN_ATTACK) then

        if !self:GetCurrentFiremode().RunawayBurst then
            self:SetBurstCount(0)
            self.LastTriggerTime = -1 -- Cannot fire again until trigger released
            self.LastTriggerDuration = 0
        end

        if self:GetCurrentFiremode().Mode < 0 and !self:GetCurrentFiremode().RunawayBurst then
            local postburst = self:GetCurrentFiremode().PostBurstDelay or 0

            if (CurTime() + postburst) > self:GetWeaponOpDelay() then
                --self:SetNextPrimaryFire(CurTime() + postburst)
                self:SetWeaponOpDelay(CurTime() + postburst * self:GetBuff_Mult("Mult_PostBurstDelay") + self:GetBuff_Add("Add_PostBurstDelay"))
            end
        end
    end

    if owner and owner:GetInfoNum("arccw_automaticreload", 0) == 1 and self:Clip1() == 0 and !self:GetReloading() and CurTime() > self:GetNextPrimaryFire() + 0.2 then
        self:Reload()
    end

    if (!(self:GetBuff_Override("Override_ReloadInSights") or self.ReloadInSights) and (self:GetReloading() or owner:KeyDown(IN_RELOAD))) then
        if !(self:GetBuff_Override("Override_ReloadInSights") or self.ReloadInSights) and self:GetReloading() then
            self:ExitSights()
        end
    end


    if self:GetBuff_Hook("Hook_ShouldNotSight") and (self.Sighted or self:GetState() == ArcCW.STATE_SIGHTS) then
        self:ExitSights()
    elseif self:GetHolster_Time() > 0 then
        self:ExitSights()
    else

        -- no it really doesn't, past me
        local sighted = self:GetState() == ArcCW.STATE_SIGHTS
        local toggle = owner:GetInfoNum("arccw_toggleads", 0) >= 1
        local suitzoom = owner:KeyDown(IN_ZOOM)
        local sp_cl = game.SinglePlayer() and CLIENT

        -- if in singleplayer, client realm should be completely ignored
        if toggle and !sp_cl then
            if owner:KeyPressed(IN_ATTACK2) then
                if sighted then
                    self:ExitSights()
                elseif !suitzoom then
                    self:EnterSights()
                end
            elseif suitzoom and sighted then
                self:ExitSights()
            end
        elseif !toggle then
            if (owner:KeyDown(IN_ATTACK2) and !suitzoom) and !sighted then
                self:EnterSights()
            elseif (!owner:KeyDown(IN_ATTACK2) or suitzoom) and sighted then
                self:ExitSights()
            end
        end

    end

    if (!game.SinglePlayer() and IsFirstTimePredicted()) or (game.SinglePlayer() and true) then
        if self:InSprint() and (self:GetState() != ArcCW.STATE_SPRINT) then
            self:EnterSprint()
        elseif !self:InSprint() and (self:GetState() == ArcCW.STATE_SPRINT) then
            self:ExitSprint()
        end
    end

    if game.SinglePlayer() or IsFirstTimePredicted() then
        self:SetSightDelta(math.Approach(self:GetSightDelta(), self:GetState() == ArcCW.STATE_SIGHTS and 0 or 1, FrameTime() / self:GetSightTime()))
        self:SetSprintDelta(math.Approach(self:GetSprintDelta(), self:GetState() == ArcCW.STATE_SPRINT and 1 or 0, FrameTime() / self:GetSprintTime()))
    end

    if CLIENT and (game.SinglePlayer() or IsFirstTimePredicted()) then
        self:ProcessRecoil()
    end

    if CLIENT and IsValid(vm) then

        for i = 1, vm:GetBoneCount() do
            vm:ManipulateBoneScale(i, vec1)
        end

        for i, k in pairs(self:GetBuff_Override("Override_CaseBones", self.CaseBones) or {}) do
            if !isnumber(i) then continue end
            for _, b in pairs(istable(k) and k or {k}) do
                local bone = vm:LookupBone(b)

                if !bone then continue end

                if self:GetVisualClip() >= i then
                    vm:ManipulateBoneScale(bone, vec1)
                else
                    vm:ManipulateBoneScale(bone, vec0)
                end
            end
        end

        for i, k in pairs(self:GetBuff_Override("Override_BulletBones", self.BulletBones) or {}) do
            if !isnumber(i) then continue end
            for _, b in pairs(istable(k) and k or {k}) do
                local bone = vm:LookupBone(b)

                if !bone then continue end

                if self:GetVisualBullets() >= i then
                    vm:ManipulateBoneScale(bone, vec1)
                else
                    vm:ManipulateBoneScale(bone, vec0)
                end
            end
        end

        for i, k in pairs(self:GetBuff_Override("Override_StripperClipBones", self.StripperClipBones) or {}) do
            if !isnumber(i) then continue end
            for _, b in pairs(istable(k) and k or {k}) do
                local bone = vm:LookupBone(b)

                if !bone then continue end

                if self:GetVisualLoadAmount() >= i then
                    vm:ManipulateBoneScale(bone, vec1)
                else
                    vm:ManipulateBoneScale(bone, vec0)
                end
            end
        end
    end

    self:DoHeat()

    self:ThinkFreeAim()

    -- if CLIENT then
        -- if !IsValid(ArcCW.InvHUD) then
        --     gui.EnableScreenClicker(false)
        -- end

        -- if self:GetState() != ArcCW.STATE_CUSTOMIZE then
        --     self:CloseCustomizeHUD()
        -- else
        --     self:OpenCustomizeHUD()
        -- end
    -- end

    for i, k in pairs(self.Attachments) do
        if !k.Installed then continue end
        local atttbl = ArcCW.AttachmentTable[k.Installed]

        if atttbl.DamagePerSecond then
            local dmg = atttbl.DamagePerSecond * FrameTime()

            self:DamageAttachment(i, dmg)
        end
    end

    if CLIENT then
        self:DoOurViewPunch()
    end

    if self.Throwing and self:Clip1() == 0 and self:Ammo1() > 0 then
        self:SetClip1(1)
        owner:SetAmmo(self:Ammo1() - 1, self.Primary.Ammo)
    end

    -- self:RefreshBGs()

    if self:GetMagUpIn() != 0 and CurTime() > self:GetMagUpIn() then
        self:ReloadTimed()
        self:SetMagUpIn( 0 )
    end

    if self:HasBottomlessClip() and self:Clip1() != ArcCW.BottomlessMagicNumber then
        self:Unload()
        self:SetClip1(ArcCW.BottomlessMagicNumber)
    elseif !self:HasBottomlessClip() and self:Clip1() == ArcCW.BottomlessMagicNumber then
        self:SetClip1(0)
    end

    -- Performing traces in rendering contexts seem to cause flickering with c_hands that have QC attachments(?)
    -- Since we need to run the trace every tick anyways, do it here instead
    if CLIENT then
        self:BarrelHitWall()
    end

    self:GetBuff_Hook("Hook_Think")

    -- Running this only serverside in SP breaks animation processing and causes CheckpointAnimation to !reset.
    --if SERVER or !game.SinglePlayer() then
        self:ProcessTimers()
    --end

    -- Only reset to idle if we don't need cycle. empty idle animation usually doesn't play nice
    if self:GetNextIdle() != 0 and self:GetNextIdle() <= CurTime() and !self:GetNeedCycle()
            and self:GetHolster_Time() == 0 and self:GetShotgunReloading() == 0 then
        self:SetNextIdle(0)
        self:PlayIdleAnimation(true)
    end

    if self:GetUBGLDebounce() and !self:GetOwner():KeyDown(IN_RELOAD) then
        self:SetUBGLDebounce( false )
    end
end

local lst = SysTime()

function SWEP:ProcessRecoil()
    local owner = self:GetOwner()
    local ft = (SysTime() - (lst or SysTime())) * GetConVar("host_timescale"):GetFloat()
    local newang = owner:EyeAngles()
    -- local r = self.RecoilAmount -- self:GetNWFloat("recoil", 0)
    -- local rs = self.RecoilAmountSide -- self:GetNWFloat("recoilside", 0)

    local ra = Angle(ang0)

    ra = ra + (self:GetBuff_Override("Override_RecoilDirection", self.RecoilDirection) * self.RecoilAmount * 0.5)
    ra = ra + (self:GetBuff_Override("Override_RecoilDirectionSide", self.RecoilDirectionSide) * self.RecoilAmountSide * 0.5)

    newang = newang - ra

    local rpb = self.RecoilPunchBack
    local rps = self.RecoilPunchSide
    local rpu = self.RecoilPunchUp

    if rpb != 0 then
        self.RecoilPunchBack = math.Approach(rpb, 0, ft * rpb * 10)
    end

    if rps != 0 then
        self.RecoilPunchSide = math.Approach(rps, 0, ft * rps * 5)
    end

    if rpu != 0 then
        self.RecoilPunchUp = math.Approach(rpu, 0, ft * rpu * 5)
    end

    lst = SysTime()
end

function SWEP:InSprint()
    local owner = self:GetOwner()

    local sm = self.SpeedMult * self:GetBuff_Mult("Mult_SpeedMult") * self:GetBuff_Mult("Mult_MoveSpeed")

    sm = math.Clamp(sm, 0, 1)

    local sprintspeed = owner:GetRunSpeed() * sm
    local walkspeed = owner:GetWalkSpeed() * sm

    local curspeed = owner:GetVelocity():Length()

    if TTT2 and owner.isSprinting == true then
        return (owner.sprintProgress or 0) > 0 and owner:KeyDown(IN_SPEED) and !owner:Crouching() and curspeed > walkspeed and owner:OnGround()
    end

    if !owner:KeyDown(IN_SPEED) or !owner:KeyDown(IN_FORWARD+IN_MOVELEFT+IN_MOVERIGHT+IN_BACK) then return false end
    if !owner:OnGround() then return false end
    if owner:Crouching() then return false end
    if curspeed < Lerp(0.5, walkspeed, sprintspeed) then
        -- provide some grace time so changing directions won't immediately exit sprint
        self.LastExitSprintCheck = self.LastExitSprintCheck or CurTime()
        if self.LastExitSprintCheck < CurTime() - 0.25 then
            return false
        end
    else
        self.LastExitSprintCheck = nil
    end

    return true
end

function SWEP:IsTriggerHeld()
    return self:GetOwner():KeyDown(IN_ATTACK) and (self:CanShootWhileSprint() or (!self.Sprinted or self:GetState() != ArcCW.STATE_SPRINT)) and (self:GetHolster_Time() < CurTime()) and !self:GetPriorityAnim()
end

SWEP.LastTriggerTime = 0
SWEP.LastTriggerDuration = 0
function SWEP:GetTriggerDelta(noheldcheck)
    if self.LastTriggerTime <= 0 or (!noheldcheck and !self:IsTriggerHeld()) then return 0 end
    return math.Clamp((CurTime() - self.LastTriggerTime) / self.LastTriggerDuration, 0, 1)
end

function SWEP:DoTriggerDelay()
    local shouldHold = self:IsTriggerHeld()

    local reserve = self:HasBottomlessClip() and self:Ammo1() or self:Clip1()
    if self.LastTriggerTime == -1 or (!self.TriggerPullWhenEmpty and (reserve < self:GetBuff("AmmoPerShot"))) and self:GetNextPrimaryFire() < CurTime() then
        if !shouldHold then
            self.LastTriggerTime = 0 -- Good to fire again
            self.LastTriggerDuration = 0
        end
        return
    end

    if self:GetBurstCount() > 0 and self:GetCurrentFiremode().Mode == 1 then
        self.LastTriggerTime = -1 -- Cannot fire again until trigger released
        self.LastTriggerDuration = 0
    elseif self:GetNextPrimaryFire() < CurTime() and self.LastTriggerTime > 0 and !shouldHold then
        -- Attack key is released. Stop the animation and clear progress
        local anim = self:SelectAnimation("untrigger")
        if anim then
            self:PlayAnimation(anim, self:GetBuff_Mult("Mult_TriggerDelayTime"), true, 0)
        end
        self.LastTriggerTime = 0
        self.LastTriggerDuration = 0
        self:GetBuff_Hook("Hook_OnTriggerRelease")
    elseif self:GetNextPrimaryFire() < CurTime() and self.LastTriggerTime == 0 and shouldHold then
        -- We haven't played the animation yet. Pull it!
        local anim = self:SelectAnimation("trigger")
        self:PlayAnimation(anim, self:GetBuff_Mult("Mult_TriggerDelayTime"), true, 0, nil, nil, true) -- need to overwrite sprint up
        self.LastTriggerTime = CurTime()
        self.LastTriggerDuration = self:GetAnimKeyTime(anim, true) * self:GetBuff_Mult("Mult_TriggerDelayTime")
        self:GetBuff_Hook("Hook_OnTriggerHeld")
    end
end

--addons/arccw_weapons/lua/weapons/arccw_dc15s_v2.lua:
AddCSLuaFile()
SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true -- this obviously has to be set to true
SWEP.Category = "AOCRP - Nicht eingestelle Waffen" -- edit this if you like
SWEP.AdminOnly = false

SWEP.PrintName = "DC-15s"
SWEP.Trivia_Class = "Modular Blaster"
SWEP.Trivia_Desc = "High tech verstile modular blaster base, suited for allround usage."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Medium Density"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"

SWEP.ViewModel = "models/meeks/c_dc15s_meek.mdl"
SWEP.WorldModel = "models/meeks/v_dc15s.mdl"
SWEP.IconOverride = "materials/entities/rw_sw_dc15s.png"
SWEP.ViewModelFOV = 70

SWEP.DefaultBodygroups = "111"
SWEP.DefaultWMBodygroups = "111"
SWEP.DefaultSkin = 0
SWEP.DefaultWMSkin = 0

SWEP.NoHideLeftHandInCustomization = false

SWEP.Damage = 27
SWEP.DamageMin = 14 -- damage done at maximum range
SWEP.DamageRand = 0 -- damage will vary randomly each shot by this fraction
SWEP.RangeMin = 100 -- how far bullets will retain their maximum damage for
SWEP.Range = 300 -- in METRES
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.DamageTypeHandled = false -- set to true to have the base not do anything with damage types
-- this includes: igniting if type has DMG_BURN; adding DMG_AIRBOAT when hitting helicopter; adding DMG_BULLET to DMG_BUCKSHOT

SWEP.MuzzleVelocity = 400 -- projectile muzzle velocity in m/s

SWEP.AlwaysPhysBullet = false
SWEP.NeverPhysBullet = false
SWEP.PhysTracerProfile = 3 -- color for phys tracer.

SWEP.TracerNum = 1 -- tracer every X
SWEP.TracerFinalMag = 0 -- the last X bullets in a magazine are all tracers
SWEP.Tracer = "tfa_tracer_blue" -- override tracer (hitscan) effect
SWEP.TracerCol = Color(0, 47, 255)
SWEP.HullSize = 2 -- HullSize used by FireBullets

SWEP.ChamberSize = 0 -- how many rounds can be chambered.
SWEP.Primary.ClipSize = 20 -- DefaultClip is automatically set.

SWEP.AmmoPerShot = 1

SWEP.ReloadInSights = false
SWEP.ReloadInSights_CloseIn = 0.25
SWEP.ReloadInSights_FOVMult = 0.875
SWEP.LockSightsInReload = false

SWEP.Recoil = 0.5
SWEP.RecoilSide = 0.15
SWEP.RecoilRise = 0.53
-- SWEP.VisualRecoilMult = 2
-- SWEP.RecoilPunch = 1.4
SWEP.RecoilPunchBackMax = 0.9

SWEP.RecoilDirection = Angle(1.1, 0, 0)
SWEP.RecoilDirectionSide = Angle(0, 1.1, 0)

SWEP.Delay = 60 / 330 -- 60 / RPM.
SWEP.Num = 1 -- number of shots per trigger pull.
SWEP.Firemode = 2 -- 0: safe, 1: semi, 2: auto, negative: burst
SWEP.Firemodes = {
	{
		Mode = 2,
   	},
    {
		Mode = 1,
    },
	{
		Mode = 0,
   	}
}

SWEP.NotForNPCS = true
SWEP.NPCWeaponType = nil -- string or table, the NPC weapons for this gun to replace

SWEP.AccuracyMOA = 5 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 410 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 65 -- inaccuracy added by moving. Applies in sights as well! Walking speed is considered as "maximum".
SWEP.SightsDispersion = 130 -- dispersion that remains even in sights
SWEP.JumpDispersion = 200 -- dispersion penalty when in the air

SWEP.ShootWhileSprint = false

SWEP.Primary.Ammo = "ar2" -- what ammo type the gun uses
SWEP.MagID = "mpk1" -- the magazine pool this gun draws from

SWEP.ShootVol = 50 -- volume of shoot sound
SWEP.ShootPitch = 100 -- pitch of shoot sound
SWEP.ShootPitchVariation = 0.05

SWEP.ShootSound = "dc15s/blasters_dc15_laser_close_var_02.mp3"
SWEP.ShootSoundSilenced = "w/dc19.wav"
SWEP.FiremodeSound = "weapons/arccw/firemode.wav"
SWEP.MeleeSwingSound = "weapons/arccw/melee_lift.wav"
SWEP.MeleeMissSound = "weapons/arccw/melee_miss.wav"
SWEP.MeleeHitSound = "weapons/arccw/melee_hitworld.wav"
SWEP.MeleeHitNPCSound = "weapons/arccw/melee_hitbody.wav"


SWEP.NoFlash = nil -- disable light flash
-- SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false -- Use Gmod muzzle effects rather than particle effects

SWEP.MuzzleEffectAttachment = 1 -- which attachment to put the muzzle on
SWEP.ProceduralViewBobAttachment = 1 -- attachment on which coolview is affected by, default is muzzleeffect
SWEP.MuzzleFlashColor = Color(0, 102, 255)

SWEP.SpeedMult = 0.9
SWEP.SightedSpeedMult = 0.75
SWEP.ShootSpeedMult = 1

SWEP.IronSightStruct = {
    Pos = Vector(-2.85, -2, 2.25),
    Ang = Angle(0, 0, -0),
    Midpoint = { -- Where the gun should be at the middle of it's irons
        Pos = Vector(0, 0, 0),
        Ang = Angle(0, 0, 0),
    },
    Magnification = 1,
    CrosshairInSights = false,
}


SWEP.SightTime = 0.13
SWEP.SprintTime = 0
-- If Malfunction is enabled, the gun has a random chance to be jammed
-- after the gun is jammed, it won't fire unless reload is pressed, which plays the "unjam" animation
-- if no "unjam", "fix", or "cycle" animations exist, the weapon will reload instead
SWEP.Malfunction = false
SWEP.MalfunctionJam = true -- After a malfunction happens, the gun will dryfire until reload is pressed. If unset, instead plays animation right after.
SWEP.MalfunctionTakeRound = true -- When malfunctioning, a bullet is consumed.
SWEP.MalfunctionWait = 0.5 -- The amount of time to wait before playing malfunction animation (or can reload)
SWEP.MalfunctionMean = nil -- The mean number of shots between malfunctions, will be autocalculated if nil
SWEP.MalfunctionVariance = 0.25 -- The fraction of mean for variance. e.g. 0.2 means 20% variance
SWEP.MalfunctionSound = "weapons/arccw/malfunction.wav"

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "ar2"
SWEP.HoldtypeCustomize = "slam"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2
SWEP.CanBash = true
SWEP.MeleeDamage = 25
SWEP.MeleeRange = 16
SWEP.MeleeDamageType = DMG_CLUB
SWEP.MeleeTime = 0.5
SWEP.MeleeGesture = nil
SWEP.MeleeAttackTime = 0.2

SWEP.SprintPos = Vector(6, -4, 0)
SWEP.SprintAng = Angle(-16.524, 60, -11.046)

SWEP.BashPreparePos = Vector(2.187, -4.117, -7.14)
SWEP.BashPrepareAng = Angle(32.182, -3.652, -19.039)

SWEP.BashPos = Vector(8.876, 0, 0)
SWEP.BashAng = Angle(-16.524, 70, -11.046)

SWEP.ActivePos = Vector(0, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Angle(-4.633, 36.881, 0)

SWEP.BarrelOffsetSighted = Vector(0, 0, 0)
SWEP.BarrelOffsetCrouch = nil
SWEP.BarrelOffsetHip = Vector(3, 0, -3)

SWEP.CustomizePos = Vector(10.824, -7, 4.897)
SWEP.CustomizeAng = Angle(12.149, 45.547, 45)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 1, 1)

SWEP.BarrelLength = 24

SWEP.SightPlusOffset = true

SWEP.DefaultElements = {}

SWEP.AttachmentElements = {
    ["nil"] = {
        VMElements = {
            {
                Model = "models/arccw/props/e11r_scope/e11r_scope.mdl",
                Bone = "weapon",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(0.05, -2.85, 0.8),
                    ang = Angle(-0.3, 0, -90)
                }
            }
        },
        WMElements = { -- Purely handles muzzle effect on the world model
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(20, 0.5, -8),
                    ang = Angle(0, 0, 0)
                },
                IsMuzzleDevice = true
            }
        }, -- change the world model to something else. Please make sure it's compatible with the last one.
    },
}


SWEP.Attachments = {
	[1] = {
		PrintName = "Optic", -- print name
		DefaultAttName = "Iron Sights", -- used to display the "no attachment" text
		Slot = "optic",
        DefaultEles = {"ironsight"},
		Bone = "DC15", -- relevant bone any attachments will be mostly referring to
		Offset = {
            vpos = Vector(0.02, -1.5, 0),
            vang = Angle(90, 0, -88),
            wpos = Vector(6, 1.5, -5),
            wang = Angle(-10, 2, 180)
        },
        NoWM = false
	},
    [2] = {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"tactical", "tac_pistol"},
        Bone = "DC15", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(.9, -0.5, 6),
            vang = Angle(90, 0, -0),
            wpos = Vector(14, 2, -5.5),
            wang = Angle(-10, 5, -90)
        },
        NoWM = false
    },
    [3] = {
        PrintName = "Charms", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"charm"},
        Bone = "DC15", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.9, 0, -3.5),
            vang = Angle(90, 0, -90),
            wpos = Vector(6, 1.8, -4.5),
            wang = Angle(0, 0, 180)
        },
    },
    [4] = {
        PrintName = "Foregrip", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = "foregrip",
        Bone = "DC15", -- relevant bone any attachments wwill be mostly referring to /
        Offset = {
            vpos = Vector(-0, 0.2, 2.5),
            vang = Angle(90, 0, -90),
            wpos = Vector(9, .5, 2),
            wang = Angle(0, 0, 180)            
        },
        SlideAmount = {
        vmin = Vector(-0, 0.2, 2),
        vmax = Vector(-0, 0.2, 6),
        wmin = Vector(14, 1, -4.5), 
        wmax = Vector(14, 1, -4.5) -- how far this attachment can slide in both directions.
        },          -- Set this to false if you want the foregrips to display on ViewModels.          
    },
    [5] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = {"ammo", "sw_ammo"},
    },
    [6] = {
        PrintName = "Training/Perk", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "perk",
    },
    [7] = {
        PrintName = "Magazine", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"dc15a_magazine_75"},
        Bone = "Magazine", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(2, 0.7, -1.6),
            vang = Angle(180, 0, 0),
            wpos = Vector(9.5, 1.5, -3.8),
            wang = Angle(80, 90, 0) 
        },
    },
    [8] = {
        PrintName = "Muzzle", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"muzzle"},
        Bone = "DC15", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0, -0.5, 11.5),
            vang = Angle(90, 0, -90),
            wpos = Vector(20, 1, -6.5),
            wang = Angle(-12, 0.5, 180) 
        },
    },                              
}

SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["fire"] = {
        Source = "fire",-- Overwrites the duration of the animation (changes speed). Don't set to use sequence length
    },
    ["enter_sight"] = {
        Source = "neutral",
        Time = 0, -- Overwrites the duration of the animation (changes speed). Don't set to use sequence length
    },
    ["exit_sight"] = {
        Source = "neutral",
        Time = 0, -- Overwrites the duration of the animation (changes speed). Don't set to use sequence length
    },  
	["reload"] = {
        Source = "reload",
        LHIK = true,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
		SoundTable = {
	        {
				s = "dc15s/overheat_manualcooling_resetfoley_generic_var_03.mp3", -- sound; can be string or table
				p = 100, -- pitch
				v = 100, -- volume
				t = 0.1, -- time at which to play relative to Animations.Time
				c = CHAN_ITEM, -- channel to play the sound
			},
			{
				s = "dc15s/overheat_reset_var_02.mp3", -- "everfall/weapons/miscellaneous/charge/blasters_deathray_charge_start_var_04.mp3"sound; can be string or table
				p = 100, -- pitch
				v = 100, -- volume
				t = 1.1, -- time at which to play relative to Animations.Time
				c = CHAN_ITEM, -- channel to play the sound
			},
		}
    },
	["draw"] = {
        Source = "draw",
        Mult = 1.5,
        SoundTable = {
            {
                s = "dc15s/overheat_manualcooling_resetfoley_generic_var_01.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
	["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "dc15s/gunfoley_blaster_sheathe_var_03.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
}
--addons/arccw_weapons/lua/weapons/arccw_dc17_stun_v2.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "DC-17 (Stun)"
SWEP.Trivia_Class = "Heavy Blaster Pistol"
SWEP.Trivia_Desc = "Heavy blaster pistol for CQB enviroments"
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Low Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 1

SWEP.UseHands = true

SWEP.ViewModel = "models/meeks/v_dc17_meeks.mdl"
SWEP.WorldModel = "models/meeks/worldmodels/w_dc17_v2.mdl"
SWEP.ViewModelFOV = 70
SWEP.HideViewmodel = false
SWEP.WorldModelOffset = {
    pos = Vector(11, 0, -4.4),
    ang = Angle(175, 180, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

SWEP.IconOverride = "materials/entities/rw_sw_stun_dc17.png"

SWEP.DefaultBodygroups = "000000000000"

SWEP.Damage = 30
SWEP.RangeMin = 90
SWEP.DamageMin = 23
SWEP.Range = 350
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400


SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_blue"
SWEP.TracerCol = Color(0, 0, 255)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 20

SWEP.Recoil = 0.34
SWEP.RecoilPunch = 0.4
SWEP.RecoilSide = 0.2
SWEP.RecoilRise = 0.17

SWEP.Delay = 60 / 240
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 1
	},
    {
        Mode = 0
    },
}

SWEP.AccuracyMOA = 0.22 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 530 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50

SWEP.NoFlash = nil -- disable light flash
-- SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false -- Use Gmod muzzle effects rather than particle effects

SWEP.MuzzleEffectAttachment = "1" -- which attachment to put the muzzle on
SWEP.ProceduralViewBobAttachment = 1 -- attachment on which coolview is affected by, default is muzzleeffect
SWEP.MuzzleFlashColor = Color(0, 0, 250)

----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100

SWEP.DistantShootSound = "dc17/SW01_Weapons_Blasters_Shared_Corebass_Close_Tight_VAR_02 0 0 0.mp3"
SWEP.ShootSound = "dc17/SW02_Weapons_Blasters_DC17_Laser_Close_VAR_07 0 0 0.mp3"
SWEP.ShootSoundSilenced = "w/dc19.wav"

SWEP.IronSightStruct = {
    Pos = Vector(-5.4, -0, 0.4),
    Ang = Angle(0, 0, 0),
    Midpoint = { -- Where the gun should be at the middle of it's irons
        Pos = Vector(0, 0, 0),
        Ang = Angle(0, 0, 0),
    },
    Magnification = 1,
    CrosshairInSights = false,
}
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(1, -3, -1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(2, -10,-10)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Vector(-15, 0, 0)

SWEP.CustomizePos = Vector(20.824, -16, 4.897)
SWEP.CustomizeAng = Angle(12.149, 50.547, 45)

SWEP.DefaultElements = {""}

SWEP.AttachmentElements = {
    ["dc17"] = {
        VMElements = {
            {
                Model = "models/arccw/SW_Battlefront/Weapons/dc17_blaster.mdl",
                Bone = "v_scoutblaster_reference001",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(0, 0, 0),
                    ang = Angle(0, 90, 0)
                }
            }
        },
        WMElements = {
            {
                Model = "models/arccw/SW_Battlefront/Weapons/dc17_blaster.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(300, 100, -90),
                    ang = Angle(-15, 0, 180)
                }
            }
        },
    },
}
WMOverride = "models/arccw/SW_Battlefront/Weapons/dc17_blaster.mdl" -- change the world model to something else. Please make sure it's compatible with the last one.

--SWEP.Attachments 
SWEP.Attachments = {
    [1] = {
        PrintName = "Optic", -- print name
        DefaultAttName = "Iron Sights", -- used to display the "no attachment" text
        Slot = "optic_lp",
        Bone = "DC-15SA", -- relevant bone any attachments will be mostly referring to
		Offset = {
            vpos = Vector(-0.4, -3.1, -3),
            vang = Angle(90, 0, -90),
            wpos = Vector(5, 1.13, -5.3),
            wang = Angle(-6, 0, 180)
        },
    },
    [2] = {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"tactical", "tac_pistol"},
        Bone = "DC-15SA", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(-.3, 0, 0),
            vang = Angle(90, 0, -90),
            wpos = Vector(9, 1.12, -2.8),
            wang = Angle(-5, 0, 180)
        },
    },
    [3] = {
        PrintName = "Muzzle", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        Bone = "DC-15SA", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(-.4, -1.4, 2),
            vang = Angle(90, 0, -90),
            wpos = Vector(10.2, 1.12, -4.2),
            wang = Angle(-6, 0, 180)
        },
    },        
    [4] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = "ammo",
    },
    [5] = {
        PrintName = "Training/Perk", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "perk",
    },
    [6] = {
        PrintName = "Charms", -- print name
        DefaultAttName = "No Charm", -- used to display the "no attachment" text
        Slot = {"charm"},
        Bone = "DC-15SA", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.24, -2, -2),
            vang = Angle(90, 0, -90),
            wpos = Vector(8, 1.7, -4.6),
            wang = Angle(-10, 0, 180)
        },
    },          
    [7] = {
        PrintName = "Killcounter", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = {"killcounter"},
        Bone = "DC-15SA", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.7, 0.5, 0),
            vang = Angle(90, 0, -90),
            wpos = Vector(0, 0, -0),
            wang = Angle(-15, 0, 180)
        },
    },   
    [8] = {
        PrintName = "Grip", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "grip",
    },    
    [9] = {
        PrintName = "Internal Modifications", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "uc_fg",
    },   
}


SWEP.Animations = {
    ["idle"] = {
        Source = "Idle",
    },
    ["fire"] = {
        Source = "Fire",
    },
    ["fire_sights"] = {
        Source = "",
        Time = -1,
    },
    ["idle_sights"] = {
        Source = "",
        Time = -1,
    },
    ["enter_sight"] = {
        Source = "neutral",
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "draw/gunfoley_pistol_draw_var_06.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "holster/gunfoley_pistol_sheathe_var_09.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        Time = 2.5,
        SoundTable = {
            {s = "reloads/pistols.wav", t = 1 / 30}, --s sound file
        },
    },
}
--addons/arccw_weapons/lua/weapons/arccw_dc17m_rocket_v2.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = { Author1 = "Meeks"}
SWEP.PrintName = "DC-17m Launcher"
SWEP.Trivia_Class = "Blaster Rifle"
SWEP.Trivia_Desc = "High tech DC-17m Blaster Rifle, preffered for long-range combat and general allround usage."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Medium Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 3

SWEP.UseHands = true

SWEP.ViewModel = "models/meeks/viewmodels/v_dc17m_rocket.mdl"
SWEP.WorldModel = "models/meeks/worldmodels/w_dc17m_rocket_v2.mdl"
SWEP.ViewModelFOV = 70
SWEP.HideViewmodel = false
SWEP.WorldModelOffset = {
    pos = Vector(9, 0, -4.5),
    ang = Angle(170, 180, 0),
    bone = "ValveBiped.Bip01_R_Hand",
}

SWEP.IconOverride = "materials/entities/rw_sw_dc17m_launcher.png"
SWEP.NoHideLeftHandInCustomization = false
SWEP.DefaultBodygroups = "00000000000"
SWEP.DefaultWMBodygroups = "00000000"

SWEP.ShootEntity = "arccw_rocket"

SWEP.Damage = 50
SWEP.DamageMin = 22
SWEP.Range = 950
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 2100


SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1
SWEP.ImpactDecal = "FadingScorch"

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_blue"
SWEP.TracerCol = Color(0, 0, 255)
SWEP.HullSize = 1

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 1

SWEP.Recoil = 0.5
SWEP.RecoilSide = 0.2
SWEP.RecoilRise = 0.18

SWEP.Delay = 60 / 120
SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 1
    },
    {
        Mode = 0
    },         
}

SWEP.AccuracyMOA = 0.56 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 400 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50

----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100


-- SWEP.DistantShootSound = "dc15a/SW02_Weapons_Blasters_Shared_Corebass_Tight_Close_VAR_02 0 0 0.mp3"
SWEP.ShootSound = "dc17m/dc17mrocket.wav"
SWEP.ShootSoundSilenced = "w/dc19.wav"

SWEP.NoFlash = nil -- disable light flash
-- SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false -- Use Gmod muzzle effects rather than particle effects

SWEP.MuzzleEffectAttachment = "1" -- which attachment to put the muzzle on
SWEP.ProceduralViewBobAttachment = 1 -- attachment on which coolview is affected by, default is muzzleeffect
SWEP.MuzzleFlashColor = Color(0, 0, 250)

SWEP.IronSightStruct = {
    Pos = Vector(-3.2, -3, 0),
    Ang = Angle(0, 0, 0),
     Magnification = 1.1,
     SwitchToSound = "zoom_in/gunfoley_zoomin_blasterheavy_05.mp3",
     ViewModelFOV = 55,
}
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(3, 0, -1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(1, 0, -1)
SWEP.SprintAng = Angle(-10, 40, -40)

SWEP.HolsterPos = Vector(0.2, -1, -1)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.CustomizePos = Vector(10.824, -2, -5.897)
SWEP.CustomizeAng = Angle(12.149, 30.547, 0)

SWEP.DefaultElements = {"", ""}

SWEP.AttachmentElements = {
    ["dc17m_ext_v2"] = {
        VMBodygroups = {{ind = 2, bg = 1}},
    },
}

--SWEP.Attachments 
SWEP.Attachments = {
    [1] = {
        PrintName = "Optic", -- print name
        DefaultAttName = "Iron Sights", -- used to display the "no attachment" text
        Slot = "optic",
        -- WMScale = Vector(111, 111, 111),
        Bone = "dlt19_sight", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(0.05, 0.4, 3.15),
            vang = Angle(90, 0, -90),
            wpos = Vector(390, 0, -460),
            wang = Angle(-15, 0, 180)
        },
        -- CorrectiveAng = Angle(-2.4, -0, 0)
    },
    [2] = {
        PrintName = "Foregrip", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"foregrip"},
        WMScale = Vector(111, 111, 111),
        Bone = "dlt19_sight", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(-0.2, 4.8, 6.5),
            vang = Angle(90, 0, -90),
            wang = Angle(170, 180, 0),
        },
    },          
    [3] = {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"tactical","tac_pistol","tac"},
        WMScale = Vector(111, 111, 111),
        Bone = "dlt19_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(1.5, 0.75, 12),
            vang = Angle(90, 0, 30),
            wpos = Vector(3200, 120, -1100),
            wang = Angle(-15, 0, -90)
        },
    },
    [4] = {
        PrintName = "Muzzle", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        WMScale = Vector(111, 111, 111),
        Slot = {"muzzle","dlt19_muzzle", "dc15a_muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "dlt19_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.05, 1.15, 19.45),
            vang = Angle(90, 0, -90),
            wpos = Vector(3650, 0, -1210),
            wang = Angle(-15, 0, -90)
        },
    },    
    [5] = {
        PrintName = "Magazine", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        WMScale = Vector(111, 111, 111),
        Slot = {"dc17m_ext_v2"},
        Bone = "dlt19_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.3, 2.3, -3),
            vang = Angle(0, 0, 0),
            wpos = Vector(440, 10, -260),
            wang = Angle(-15, 90, -90)
        },
    },         
    [6] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = "ammo",
    },
    [7] = {
        PrintName = "Training/Perk", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "perk",
    },
    [8] = {
        PrintName = "Charms", -- print name
        DefaultAttName = "No Charm", -- used to display the "no attachment" text
        Slot = {"charm"},
        WMScale = Vector(111, 111, 111),
        Bone = "dlt19_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(1.4, 1.6, 2),
            vang = Angle(90, 0, -70),
            wpos = Vector(900, 70, -470),
            wang = Angle(-10 , 0, 180)
        },
    },    
    [9] = {
        PrintName = "Killcounter", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = {"killcounter"},
        WMScale = Vector(111, 111, 111),
        Bone = "dlt19_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(1, 2, 2),
            vang = Angle(90, 0, -90),
            wpos = Vector(675, 90, -400),
            wang = Angle(-15 , 0, 180)
        },
    },   
    [10] = {
        PrintName = "Grip", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "grip",
    },    
    [11] = {
        PrintName = "Internal Modifications", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "uc_fg",
    },   
}
SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = "Fire"
    },
    ["fire_iron"] = {
        Source = "idle"
    },
    ["draw"] = {
        Source = "Draw",
        SoundTable = {
            {
                s = "draw/gunfoley_blaster_draw_var_04.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "Holster",
        SoundTable = {
            {
                s = "draw/gunfoley_blaster_draw_var_08.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "Reload", 
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        SoundTable = {
            --{s = "viper/weapons/sierra552/wfoly_ar_sierra552_reload_xmag_fast_empty_end.ogg", t = 20 / 60},
            {s = "dc17m/reload/SW02_Weapons_Overheat_ManualCooling_VAR_04 0 0 0.ogg", v = 10 , t = 23 / 60},
            {s = "dc17m/reload/magin.ogg", t = 115 / 60},
            {s = "dc17m/reload/maghit.ogg", t = 132 / 60},
            {s = "dc17m/reload/SCIMisc_Ammo Replenish_01.ogg", t = 139 / 60} --s sound file
        },
    },
}
--addons/arccw_weapons/lua/weapons/arccw_dl44.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "AOCRP - Zivilisten"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "[P] DL-44"
SWEP.Trivia_Class = "Galactic Blaster Pistol"
SWEP.Trivia_Desc = "A Blaster pistol for shooting enviroments"
SWEP.Trivia_Manufacturer = "Forged Armory"
SWEP.Trivia_Calibre = "Low Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 1

SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/bf2017/c_scoutblaster.mdl"
SWEP.WorldModel = "models/arccw/bf2017/w_scoutblaster.mdl"
SWEP.ViewModelFOV = 70
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

SWEP.IconOverride = "materials/entities/rw_sw_dl44.png"

SWEP.DefaultBodygroups = "000000000000"

SWEP.Damage = 32
SWEP.RangeMin = 85
SWEP.DamageMin = 14
SWEP.Range = 312
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400


SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_red"
SWEP.TracerCol = Color(255, 0, 0)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 14

SWEP.Recoil = 0.34
SWEP.RecoilPunch = 0.4
SWEP.RecoilSide = 0.2
SWEP.RecoilRise = 0.17

SWEP.Delay = 60 / 250
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 1
	},
    {
        Mode = 0
    },    
}

SWEP.AccuracyMOA = 0.22 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 530 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50

SWEP.NoFlash = nil -- disable light flash
SWEP.MuzzleEffect = nil
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false --
SWEP.MuzzleFlashColor = Color(250, 0, 0)


----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100

SWEP.ShootSound = "w/dl44.wav"
SWEP.IronSightStruct = {
    Pos = Vector(-3.94, -8, 1.85),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "zoom_in/gunfoley_zoomin_blasterpistol_04.mp3",
     ViewModelFOV = 60,
}
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(3, -4, -1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(5, -10,-20)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Vector(-15, 0, 0)

SWEP.CustomizePos = Vector(20.824, -16, 4.897)
SWEP.CustomizeAng = Angle(12.149, 50.547, 45)

SWEP.DefaultElements = {"dl44"}

SWEP.AttachmentElements = {
    ["dl44"] = {
        VMElements = {
            {
                Model = "models/arccw/sw_battlefront/weapons/dl44_pistol_ext.mdl",
                Bone = "v_scoutblaster_reference001",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(0, 0, 0),
                    ang = Angle(0, 180, 0)
                }
            }
        },
        WMElements = {
            {
                Model = "models/arccw/sw_battlefront/weapons/dl44_pistol_ext.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(40, 20, -15.3),
                    ang = Angle(-15, -90, 180)
                }
            }
        },
    },
}
WMOverride = "models/arccw/sw_battlefront/weapons/dl44_pistol_ext.mdl" -- change the world model to something else. Please make sure it's compatible with the last one.

--SWEP.Attachments 
SWEP.Attachments = {
    [1] = {
        PrintName = "Optic", -- print name
        DefaultAttName = "Iron Sights", -- used to display the "no attachment" text
        Slot = "swoptic_module",
        VMScale = Vector(0.8, 0.8, 0.8),
        WMScale = Vector(9, 9, 9),
        Bone = "v_scoutblaster_reference001", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(0, -2.4, 2.9),
            vang = Angle(0, 180, 0),
            wpos = Vector(70, 20, -50),
            wang = Angle(-15, 90, 180)
        },
    },
    [2] = {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment",
        VMScale = Vector(0.8, 0.8, 0.8),
        WMScale = Vector(9, 9, 9), -- used to display the "no attachment" text
        Slot = {"tactical","tac_pistol"},
        Bone = "v_scoutblaster_reference001", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.6, -8, 1.8),
            vang = Angle(0, 90, 0),
            wpos = Vector(115, 20, -56),
            wang = Angle(-15, 0, 180)
        },
    },
    [3] = {
        PrintName = "Muzzle", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        NoWM = true,
        Slot = {},
        Bone = "scoutblaster_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0, 0.3, 8.6),
            vang = Angle(90, 0, -90),
            wpos = Vector(113, 20, -55),
            wang = Angle(-15, 0, 180)
        },
    },      
    [6] = {
        PrintName = "Charms", -- print name
        DefaultAttName = "No Charm", -- used to display the "no attachment" text
        Slot = {"charm"},
        WMScale = Vector(8, 8, 8),
        Bone = "scoutblaster_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.35, 0.9, 2.5),
            vang = Angle(90, 0, -90),
            wpos = Vector(60, 22, -35),
            wang = Angle(-10, 0, 180)
        },
    },          
}


SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = "fire"
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "draw/gunfoley_pistol_draw_var_06.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "holster/gunfoley_pistol_sheathe_var_09.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
 --       Time = 3.35,
        SoundTable = {
            {s = "ArcCW_dc17.reload2", t = 1 / 30}, --s sound file
        },
    },


sound.Add({
    name =          "ArcCW_dc17.reload2",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "weapons/bf3/pistols.wav"
    }),
}
--addons/arccw_weapons/lua/weapons/arccw_dp23_v2.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "DP-23"
SWEP.Trivia_Class = "Blaster Rifle"
SWEP.Trivia_Desc = "High tech Blaster shotgun, built for piercing the enemy defenses."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Medium Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 3

SWEP.UseHands = true

SWEP.ViewModel = "models/meeks/v_dp23_v2.mdl"
SWEP.WorldModel = "models/meeks/worldmodels/w_dp23_v2.mdl"
SWEP.ViewModelFOV = 70
SWEP.HideViewmodel = false
SWEP.WorldModelOffset = {
    pos = Vector(10, 0, -4),
    ang = Angle(165, 180, 0),
    bone = "ValveBiped.Bip01_R_Hand",
}

SWEP.IconOverride = "materials/entities/rw_sw_dp23.png"
SWEP.NoHideLeftHandInCustomization = true
SWEP.DefaultBodygroups = "000000000000"

SWEP.Damage = 27
SWEP.RangeMin = 20
SWEP.DamageMin = 17
SWEP.Range = 50
SWEP.Penetration = 1
SWEP.DamageType = DMG_BUCKSHOT
SWEP.MuzzleVelocity = 400

SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_blue"
SWEP.TracerCol = Color(0, 0, 255)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 5

SWEP.Recoil = 1.5
SWEP.RecoilSide = 0.6
SWEP.RecoilPunch = 0.8
SWEP.RecoilRise = 1

SWEP.Delay = 90 / 240
SWEP.Num = 5
SWEP.Firemodes = {
	{
		Mode = 1
	},
    {
        Mode = 0
    },
}

SWEP.AccuracyMOA = 50 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 450 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 100

SWEP.NoFlash = nil -- disable light flash
-- SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false --
SWEP.MuzzleFlashColor = Color(0, 0, 255)



----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100


SWEP.DistantShootSound = "dc15a/SW02_Weapons_Blasters_Shared_Corebass_Tight_Close_VAR_02 0 0 0.mp3"
SWEP.ShootSound = "dp23/dp23.wav"
SWEP.ShootSoundSilenced = "w/dc19.wav"

SWEP.MuzzleEffectAttachment = "1" -- which attachment to put the muzzle on
SWEP.ProceduralViewBobAttachment = 1 -- attachment on which coolview is affected by, default is muzzleeffect
SWEP.MuzzleFlashColor = Color(0, 0, 250)

SWEP.IronSightStruct = {
    Pos = Vector(-2.81, -7, 1.4),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "zoom_in/gunfoley_zoomin_blasterheavy_01.mp3",
     ViewModelFOV = 60,
}
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(1.5, -2, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(3, 0, 0)
SWEP.SprintAng = Angle(-10, 40, -40)

SWEP.HolsterPos = Vector(0.2, -1, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.CustomizePos = Vector(20.824, -10, 3.897)
SWEP.CustomizeAng = Angle(12.149, 50.547, 45)

-- SWEP.DefaultElements = {"", ""}

-- SWEP.AttachmentElements = {
--     ["dc15a"] = {
--         VMElements = {
--             {
--                 Model = "models/arccw/sw_battlefront/weapons/new/DC15A_Rifle.mdl", -- using the model-edit i made in like 2 mins lol
--                 Bone = "v_dlt19_reference001",
--                 Scale = Vector(1.2, 1.2, 1.2),
--                 Offset = {
--                     pos = Vector(.7, -0.3, 0.5),
--                     ang = Angle(0,-90, 0)
--                 },
--             }
--         },
--     },
--     ["muzzle"] = {
--          VMElements = {
--             {
--                 Model = "models/hunter/plates/plate.mdl",
--                 Bone = "dlt19_sight",
--                 Scale = Vector(0, 0, 0),                
--                 Offset = {
--                     pos = Vector(-0.5, 4, 27 ),
--                     ang = Angle(-90, 180, 0)
--                 },
--                 IsMuzzleDevice = true
--             }
--         },
--         WMElements = {
--             {
--                 Model = "models/arccw/sw_battlefront/weapons/new/dc15a_rifle.mdl",
--                 Bone = "ValveBiped.Bip01_R_Hand",
--                 Scale = Vector(1.1, 1.1, 1.1),
--                 Offset = {
--                     pos = Vector(3.75, 2.5, -1.5),
--                     ang = Angle(-15, 0, 180)
--                 }
--             },
--             {
--                 Model = "models/hunter/plates/plate.mdl",
--                 Bone = "ValveBiped.Bip01_R_Hand",
--                 Scale = Vector(0, 0, 0),
--                 Offset = {
--                     pos = Vector(3500, 0, -1100),
--                     ang = Angle(-15, 0, 180)
--                 },
--                 IsMuzzleDevice = true
--             },
--         }, -- change the world model to something else. Please make sure it's compatible with the last one.
--     }
-- }
-- WMOverride = "models/arccw/sw_battlefront/weapons/new/dc15a_rifle.mdl"

--SWEP.Attachments 
SWEP.Attachments = {
    [1] = {
        PrintName = "Optic", -- print name
        DefaultAttName = "Iron Sights", -- used to display the "no attachment" text
        Slot = "optic",
        -- WMScale = Vector(111, 111, 111),
        Bone = "sights", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(-0.04, -0.7, 0.15),
            vang = Angle(90, 0, -90),
            wpos = Vector(3, 1, -3.8),
            wang = Angle(-15, 0, 180)
        },
    },
    [2] = {
        PrintName = "Foregrip", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"foregrip"},
        Bone = "sights", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(-0., 1.65, 6.5),
            vang = Angle(90, 0, -90),
            wang = Angle(165, 180, 0),
        },
        SlideAmount = {
            vmin = Vector(-0, 2.2, 6),
            vmax = Vector(-0, 2.2, 12),
            wmin = Vector(12.2, 1, -3), 
            wmax = Vector(18, 1, -4.35) -- how far this attachment can slide in both directions.
        },    
    },          
    [3] = {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"tactical","tac_pistol","tac"},
        Bone = "sights", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.65, 0.85, 11),
            vang = Angle(90, 0, -0),
            wpos = Vector(20, 1.8, -6.5),
            wang = Angle(-15, 0, -90)
        },
    },
    [4] = {
        PrintName = "Muzzle", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"muzzle","dlt19_muzzle", "dc15a_muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "sights", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(-0.04, 0.84, 15.4),
            vang = Angle(90, 0, -90),
            wpos = Vector(23.1, 1, -7.4),
            wang = Angle(-15, 0, -90)
        },
    },    
    [5] = {
        PrintName = "Magazine", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Bone = "sights", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.3, 2.3, -3),
            vang = Angle(0, 0, 0),
            wpos = Vector(440, 10, -260),
            wang = Angle(-15, 90, -90)
        },
    },         
    [6] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = "ammo",
    },
    [7] = {
        PrintName = "Training/Perk", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "perk",
    },
    [8] = {
        PrintName = "Charms", -- print name
        DefaultAttName = "No Charm", -- used to display the "no attachment" text
        Slot = {"charm"},
        Bone = "sights", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.7, 0.8, 5.9),
            vang = Angle(90, 0, -90),
            wpos = Vector(10, 1.8, -4),
            wang = Angle(-10 , 0, 180)
        },
    },    
    [9] = {
        PrintName = "Killcounter", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = {"killcounter"},
        Bone = "sights", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(1, 1, 3),
            vang = Angle(90, 0, -90),
            wpos = Vector(675, 90, -400),
            wang = Angle(-15 , 0, 180)
        },
    },   
    [10] = {
        PrintName = "Grip", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "grip",
    },    
    [11] = {
        PrintName = "Internal Modifications", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "uc_fg",
    },   
}
SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = "fire"
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "draw/gunfoley_blaster_draw_var_04.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "draw/gunfoley_blaster_draw_var_08.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        Time = 3,
        LHIK = true,
        LHIKOut = 0.6,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "reloads/heavy.wav", t = 4 / 30}, --s sound file
        },
    },

}
--addons/arccw_weapons/lua/weapons/arccw_m57.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "M-57"
SWEP.Trivia_Class = "Galactic Blaster Pistol"
SWEP.Trivia_Desc = "A Blaster pistol for shooting enviroments"
SWEP.Trivia_Manufacturer = "Forged Armory"
SWEP.Trivia_Calibre = "Low Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 1

SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/bf2017/c_scoutblaster.mdl"
SWEP.WorldModel = "models/arccw/bf2017/w_scoutblaster.mdl"
SWEP.ViewModelFOV = 70
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

SWEP.IconOverride = "materials/entities/rw_sw_m57.png"

SWEP.DefaultBodygroups = "000000000000"

SWEP.Damage = 55
SWEP.RangeMin = 95
SWEP.DamageMin = 18
SWEP.Range = 290
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400


SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1


SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_red"
SWEP.TracerCol = Color(250, 0, 0)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 8

SWEP.Recoil = 0.34
SWEP.RecoilPunch = 0.4
SWEP.RecoilSide = 0.2
SWEP.RecoilRise = 0.17

SWEP.Delay = 60 / 145
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 1
	},
    {
        Mode = 0
    },
}

SWEP.AccuracyMOA = 0.22 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 530 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50

SWEP.NoFlash = nil -- disable light flash
SWEP.MuzzleEffect = nil
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false --
SWEP.MuzzleFlashColor = Color(250, 0, 0)


----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100

SWEP.ShootSound = "w/dl44.wav"
SWEP.IronSightStruct = {
    Pos = Vector(-3.94, -8, 1.1),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "",
     ViewModelFOV = 60,
}
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(3, -4, -1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(5, -10,-20)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Vector(-15, 0, 0)

SWEP.CustomizePos = Vector(20.824, -16, 4.897)
SWEP.CustomizeAng = Angle(12.149, 50.547, 45)

SWEP.DefaultElements = {"m57"}

SWEP.AttachmentElements = {
    ["m57"] = {
        VMElements = {
            {
                Model = "models/arccw/sw_battlefront/weapons/dl44_pistol_ext.mdl",
                Bone = "v_scoutblaster_reference001",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(0, 0, 0.65),
                    ang = Angle(0, 180, 0)
                }
            }
        },
        WMElements = {
            {
                Model = "models/arccw/sw_battlefront/weapons/dl44_pistol_ext.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(40, 10, -15.3),
                    ang = Angle(-15, -90, 180)
                }
            }
        },
    },
}
WMOverride = "models/arccw/sw_battlefront/weapons/dl44_pistol_ext.mdl" -- change the world model to something else. Please make sure it's compatible with the last one.

--SWEP.Attachments 
SWEP.Attachments = {
    [1] = {
        PrintName = "Optic", -- print name
        DefaultAttName = "Iron Sights", -- used to display the "no attachment" text
        Slot = "swoptic_module",
        VMScale = Vector(0.8, 0.8, 0.8),
        WMScale = Vector(9, 9, 9),
        Bone = "v_scoutblaster_reference001", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(0, -2.4, 3.1),
            vang = Angle(0, 180, 0),
            wpos = Vector(70, 10, -54),
            wang = Angle(-15, 90, 180)
        },
    },
    [2] = {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment",
        VMScale = Vector(0.8, 0.8, 0.8), -- used to display the "no attachment" text
        Slot = {"tactical","tac_pistol"},
        WMScale = Vector(9, 9, 9),
        Bone = "v_scoutblaster_reference001", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0, -6, 2.7),
            vang = Angle(0, 90, 0),
            wpos = Vector(115, 10, -59),
            wang = Angle(-15, 0, 180)
        },
    },    
    [3] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = "ammo",
    },
    [4] = {
        PrintName = "Training/Perk", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "perk",
    },
    [5] = {
        PrintName = "Charms", -- print name
        DefaultAttName = "No Charm", -- used to display the "no attachment" text
        Slot = {"charm"},
        WMScale = Vector(8, 8, 8),
        Bone = "scoutblaster_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.35, 0.6, 3.8),
            vang = Angle(90, 0, -90),
            wpos = Vector(80, 13, -35),
            wang = Angle(-10, 0, 180)
        },
    },          
}


SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = "fire"
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "draw/gunfoley_pistol_draw_var_06.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "holster/gunfoley_pistol_sheathe_var_09.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
 --       Time = 3.35,
        SoundTable = {
            {s = "ArcCW_dc17.reload2", t = 1 / 30}, --s sound file
        },
    },


sound.Add({
    name =          "ArcCW_dc17.reload2",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "weapons/bf3/pistols.wav"
    }),
}
--addons/arccw_weapons/lua/weapons/arccw_meeks_dual_dc17.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true

SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = "Meeks"
SWEP.PrintName = "Dual DC-17"
SWEP.Trivia_Class = "Dual Blaster Pistol"
SWEP.Trivia_Desc = "The DC-17 hand blaster, also known as DC-17 blaster pistol, was a heavy blaster pistol wielded by the clone troopers of the Grand Army of the Galactic Republic during the Clone Wars. An advanced firearm, it was fielded to elite soldiers in the army, most notably Advanced Recon Commandos, clone trooper commanders, and clone jet troopers."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = ""

SWEP.Slot = 1

SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/ser/starwars/c_dual_dc-17.mdl"
SWEP.WorldModel = "models/rising/base/c_akimbo.mdl"
SWEP.ViewModelFOV = 80
SWEP.HideViewmodel = false
SWEP.MirrorVMWM = nil
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 180, 180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

SWEP.DefaultBodygroups = "000000000000"
SWEP.NoHideLeftHandInCustomization = true
SWEP.Damage = 23
SWEP.RangeMin = 100
SWEP.DamageMin = 17
SWEP.Range = 350
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400

SWEP.DefaultWMSkin = 1
SWEP.DefaultSkin = 1

SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_blue"
SWEP.TracerCol = Color(0, 0, 255)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 31

SWEP.Recoil = 0.345
SWEP.RecoilPunch = 0.6
SWEP.RecoilSide = 0.17
SWEP.RecoilRise = 0.22

SWEP.Delay = 60 / 348
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 1
	},
    {
        Mode = 2
    },
    {
        Mode = 0
    },        
}

SWEP.AccuracyMOA = 0.34 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 210 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50

SWEP.RecoilDirection = Angle(1.1, 0, 0)
SWEP.RecoilDirectionSide = Angle(0, 1.1, 0)

SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2
SWEP.ShootSound = "weapons/bf3/dc17.wav"
SWEP.MuzzleFlashColor = Color(0, 0, 255)

SWEP.IronSightStruct = {
    Pos = Vector(0, -7, 1),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "armasclasicas/wpn_cis_medequip.wav",
     ViewModelFOV = 90,
}
SWEP.HoldtypeHolstered = ""
SWEP.HoldtypeActive = "duel"
SWEP.HoldtypeSights = ""


SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, -5, -0.5)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, -14,-10)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Vector(-25, 0, 0)

SWEP.ReloadPos = Vector(0, -5, -0)

SWEP.CustomizePos = Vector(-0.5, -8, -4.897)
SWEP.CustomizeAng = Angle(10, 0, 0)

SWEP.BarrelLength = 60
SWEP.BarrelOffsetSighted = Vector(0, 0, 0)
SWEP.BarrelOffsetHip = Vector(3, 0, -3)

SWEP.DefaultElements = {"akimbo"}
SWEP.AttachmentElements = {
    ["akimbo"] = {
        VMElements = {},
        WMElements = {
            {
                Model = "models/arccw/SW_Battlefront/Weapons/dc17_blaster.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(30, 15, -10),
                    ang = Angle(180, -180, 2)
                }
            },
            {
                Model = "models/arccw/SW_Battlefront/Weapons/dc17_blaster.mdl",
                Bone = "ValveBiped.Bip01_L_Hand",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(-50, 230, -55),
                    ang = Angle(180, -180, 2)
                }
            },
        },            -- change the world model to something else. Please make sure it's compatible with the last one.
    }
}
WMOverride = "models/arccw/SW_Battlefront/Weapons/dc17_blaster.mdl"


--SWEP.Attachments 
SWEP.Attachments = {   
    [1] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = "ammo",
    },
    [2] = {
        PrintName = "Internal Modifications", -- print name
        DefaultAttName = "Standard", -- used to display the "no attachment" text
        Slot = "uc_fg",
    },
}


SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["bash"] = {
        Source = "bash"
    },
    ["idle_inspect"] = {
        Source = "lookat01",
        Time = 7,
    },
    ["exit_inspect"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = {"shoot_l", "shoot_r"},
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1.5,
        SoundTable = {
            {
                s = "draw/gunfoley_pistol_draw_var_10.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "holster/gunfoley_pistol_sheathe_var_09.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PHYSGUN,
        SoundTable = {
            {s = "armas/misc/dc17s_dual_reload.wav", t = 0}, 
        },
    },
}
--addons/arccw_weapons/lua/weapons/arccw_sops_dca4bi.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3

SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = "Kraken"
SWEP.PrintName = "DC-A4 'Blastech Industries'"
SWEP.Trivia_Class = "Blaster-Experimental Rifle"
SWEP.Trivia_Desc = "An ancient instrument of war, renewed and enhanced by BlasTech Industries."
SWEP.IconOverride = "entities/sopsmisc/dca4_bi.png"

SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sops-v2/c_khvostov7g0x.mdl"
SWEP.WorldModel = "models/arccw/bf2017/w_e11.mdl"
SWEP.ViewModelFOV = 58
SWEP.MirrorVMWM = false
SWEP.NoHideLeftHandInCustomization = false
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.009
}

-- Special properties
SWEP.ShellModel = "models/shells/shell_556.mdl"
SWEP.ShellPitch = 95
SWEP.ShellScale = 1.4
SWEP.DefaultSkin = 1

-- Damage & Entity Options
SWEP.Damage = 45
SWEP.DamageMin = 25
SWEP.RangeMin = 239
SWEP.Range = 540
SWEP.DamageType = DMG_BULLET
SWEP.Penetration = 1
SWEP.MuzzleVelocity = 800

SWEP.TracerNum = 1
SWEP.TracerCol = Color(25, 125, 255)
SWEP.TracerWidth = 10
SWEP.PhysTracerProfile = "apex_bullet_energy"
SWEP.Tracer = "arccw_apex_tracer_energy_sniper"
SWEP.HullSize = 0.5
SWEP.Num = 1 

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 1
SWEP.Primary.ClipSize = 40
SWEP.ExtendedClipSize = 60
SWEP.ReducedClipSize = 30

SWEP.Recoil = 0.68
SWEP.RecoilRise = 0.73
SWEP.RecoilSide = 0.32

SWEP.AccuracyMOA = 0.5
SWEP.HipDispersion = 250
SWEP.MoveDispersion = 100

SWEP.Delay = 60 / 402
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
		Mode = 2,
    },
	{
		Mode = 0,
   	}
}

SWEP.SpeedMult = 1
SWEP.SightedSpeedMult = 0.40

SWEP.Primary.Ammo = "ar2" 
SWEP.ShootVol = 50
SWEP.ShootPitch = 90
SWEP.ShootPitchVariation = 0.2
SWEP.FirstShootSound = "sops-v2/weapons/dca4/kvfire1.wav"
SWEP.ShootSound = "sops-v2/weapons/dca4/kvfire2.wav", "sops-v2/weapons/dca4/kvfire3.wav", "sops-v2/weapons/dca4/kvfire4.wav", "sops-v2/weapons/dca4/kvfire5.wav"
SWEP.ShootSoundSilenced = "sops-v2/weapons/silenced.mp3"

SWEP.NoFlash = nil
-- SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false 

SWEP.CaseEffectAttachment = 2
SWEP.MuzzleEffectAttachment = 1 
SWEP.MuzzleFlashColor = Color(0, 0, 250)

SWEP.IronSightStruct = {
    Pos = Vector(-6.244, -9.494, 1.947),
    Ang = Angle(0, 0, 0),
     Magnification = 1.5,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 55,
}

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.HoldtypeCustomize = "slam"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(-2, 0, 0)
SWEP.ActiveAng = Angle(1, -0.5, -5)

SWEP.SprintPos = Vector(7, 0, -4)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(9.824, 2, -2.897)
SWEP.CustomizeAng = Angle(12.149, 30.547, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.DefaultElements = {"dca4"}
SWEP.AttachmentElements = {
    ["dca4"] = {
        WMElements = {
            {
                Model = "models/arccw/kraken/sops-v2/c_khvostov7g0x.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1, 1, 1),
                ModelSkin = 1,
                Offset = {
                    pos = Vector(-1650, 800, -450),
                    ang = Angle(-10, 0, 180)
                }
            },
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(3200, 200, -800),
                    ang = Angle(-15, 0, 180)
                },
                IsMuzzleDevice = true
            },            
        }, 
    }
}WMOverride = "models/arccw/kraken/sops-v2/c_khvostov7g0x.mdl"


SWEP.Attachments = {    
    {
        PrintName = "Sight",
        DefaultAttName = "None",
        Slot = "optic",
        WMScale = Vector(111, 111, 111),
        Bone = "WeaponBone",
        Offset = {
            vpos = Vector(0, -6, 1.8),
            vang = Angle(0, 90, 180),
            wpos = Vector(600, 100, -535),
            wang = Angle(-10, -0.50, 180)
        },
        CorrectiveAng = Angle(0, -180, 0),
        CorrectivePos = Vector(0, 0, -0),
    },    
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        Bone = "WeaponBone",
        WMScale = Vector(111, 111, 111),
        VMScale = Vector(1.3,1.3,1.3),
        Offset = {
            vpos = Vector(0.1, -30, 3),
            vang = Angle(0, 90, 180),
            wpos = Vector(3520, 100, -908),
            wang = Angle(-10, -1, 180)
        },
    },    
    {
        PrintName = "Energization", 
        DefaultAttName = "Standard",
        Slot = {"ammo", "ammo_masita"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = {"perk", "mw3_pro"},
    },
    {
        PrintName = "Grip",
        Slot = "grip",
        DefaultAttName = "Standard Grip"
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },      
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        WMScale = Vector(111, 111, 111),
        Bone = "WeaponBone",
        Offset = {
            vpos = Vector(0.5, -4, 4.5),
            vang = Angle(90, 90, -90),
            wpos = Vector(500, 145, -200),
            wang = Angle(-10, 0, 180)
        },
    },     
    {
        PrintName = "Charms",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "WeaponBone",
        WMScale = Vector(111, 111, 111),
        Offset = {
            vpos = Vector(0.9, -7.5, 7.5),
            vang = Angle(90, 90, -90),
            wpos = Vector(1100, 210, -0),
            wang = Angle(-10, 0, 180)
        },
    },   
}

SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = "shoot1",
        ShellEjectAt = 0.1,
    },
    ["fire_iron"] = {
        Source = "shoot1",
        ShellEjectAt = 0.1,
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "sops-v2/interaction/equip.wav",
                p = 100,
                v = 75,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "sops-v2/interaction/equip1.wav",
                p = 100,
                v = 75,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload",
        LHIK = true,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "sops-v2/weapons/dca4/kvreload.wav", t = 0.1 },
        },
    },
}
--addons/arccw_weapons/lua/weapons/arccw_sops_oldwould.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 2

-- Trivia
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = "Kraken"
SWEP.PrintName = "'Old Wound'"
SWEP.Trivia_Class = "Blaster Revolver"
SWEP.Trivia_Desc = "Yours, until the last flame dies and all words have been spoken."
SWEP.IconOverride = "entities/sopsmisc/oldwound.png"

SWEP.HideViewmodel = false
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sops-v2/c_the_last_word_laconic.mdl"
SWEP.WorldModel = "models/arccw/bf2017/w_e11.mdl"
SWEP.ViewModelFOV = 58
SWEP.MirrorVMWM = true
SWEP.NoHideLeftHandInCustomization = true
SWEP.WorldModelOffset = {
    pos = Vector(-19, 6, -5),
    ang = Angle(-10, 0, 180)
}

-- Damage & Entity options
SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 43
SWEP.RangeMin = 143
SWEP.DamageMin = 24
SWEP.Range = 298
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 800

SWEP.TracerNum = 1
SWEP.TracerCol = Color(25, 125, 255)
SWEP.TracerWidth = 10
SWEP.PhysTracerProfile = "apex_bullet_energy"
SWEP.Tracer = "arccw_apex_tracer_energy_sniper"
SWEP.HullSize = 0.5
SWEP.Primary.ClipSize = 8
SWEP.AmmoPerShot = 1

SWEP.Recoil = 1.63
SWEP.RecoilSide = 0.2
SWEP.RecoilRise = 0.62

SWEP.Delay = 60 / 170
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 1
	},
    {
		Mode = 2
	},
    {
        Mode = 0
    },
}

SWEP.AccuracyMOA = 0.5
SWEP.HipDispersion = 200
SWEP.MoveDispersion = 50

SWEP.NoFlash = nil
-- SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false 

SWEP.MuzzleEffectAttachment = 1 
SWEP.ProceduralViewBobAttachment = 1
SWEP.MuzzleFlashColor = Color(0, 0, 250)

-- Ammo & Stuff
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 150
SWEP.ShootPitch = 75
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "sops-v2/weapons/revolvers.wav"
SWEP.ShootSound = "sops-v2/weapons/revolvers.wav"
SWEP.ShootSoundSilenced = "sops-v2/weapons/silenced.mp3"

SWEP.IronSightStruct = {
    Pos = Vector(-5.373, -11.532, 1.552),
    Ang = Angle(0, 0, 0),
     Magnification = 1.5,
     SwitchToSound = "sops-v2/interaction/zoom_start.mp3",
     SwitchFromSound = "sops-v2/interaction/zoom_end.mp3",
     ViewModelFOV = 60,
}

SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "revolver"
SWEP.HoldtypeSights = "revolver"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_REVOLVER

SWEP.ActivePos = Vector(-1, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, 0, -20)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Vector(-15, 0, 0)

SWEP.CustomizePos = Vector(10, -13, 0)
SWEP.CustomizeAng = Angle(12, 50.5, 45)

-- Attachments 
SWEP.Attachments = {
    {
        PrintName = "Energization", 
        DefaultAttName = "Standard",
        Slot = {"ammo", "ammo_masita"},
    },
    {
        PrintName = "Grip",
        Slot = "grip",
        DefaultAttName = "Standard Grip"
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = {"perk", "mw3_pro"},
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },      
}


SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = {"shoot"},
        Time = 0.9,
    },
    ["fire_iron"] = {
        ShellEjectAt = 0,
        Source = {"shoot"}
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "sops-v2/interaction/equip.wav",
                p = 100, 
                v = 75, 
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "sops-v2/interaction/equip2.wav",
                p = 100, 
                v = 75, 
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_REVOLVER,
        SoundTable = {
            {s = "sops-v2/weapons/revolver_reload.wav", t = 0.1 / 30},
        },
    },
}
--addons/arccw_weapons/lua/weapons/arccw_westar35.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "AOCRP - Zivilisten"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "[P] Westar-35"
SWEP.Trivia_Class = "Galactic Blaster Pistol"
SWEP.Trivia_Desc = "A Blaster pistol for shooting enviroments"
SWEP.Trivia_Manufacturer = "Concordian Crescent Technologies"
SWEP.Trivia_Calibre = "Low Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 1

SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/bf2017/c_scoutblaster.mdl"
SWEP.WorldModel = "models/arccw/bf2017/w_scoutblaster.mdl"
SWEP.ViewModelFOV = 70
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

SWEP.IconOverride = "materials/entities/rw_sw_westar35.png"

SWEP.DefaultBodygroups = "000000000000"

SWEP.Damage = 30
SWEP.RangeMin = 110
SWEP.DamageMin = 19
SWEP.Range = 310
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400


SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_yellow"
SWEP.TracerCol = Color(255, 165, 18)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 20

SWEP.Recoil = 0.34
SWEP.RecoilPunch = 0.4
SWEP.RecoilSide = 0.2
SWEP.RecoilRise = 0.17

SWEP.Delay = 60 / 300
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 1
	},
    {
        Mode = 0
    },
}

SWEP.AccuracyMOA = 0.22 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 530 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50

SWEP.NoFlash = nil -- disable light flash
SWEP.MuzzleEffect = nil
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false --
SWEP.MuzzleFlashColor = Color(255, 165, 18)


----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100

SWEP.ShootSound = "w/westar35.wav"
SWEP.IronSightStruct = {
    Pos = Vector(-3.65, -8, 3),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "zoom_in/gunfoley_zoomin_blasterpistol_04.mp3",
     ViewModelFOV = 60,
}
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(3, -4, -1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(5, -10,-20)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Vector(-15, 0, 0)

SWEP.CustomizePos = Vector(20.824, -16, 4.897)
SWEP.CustomizeAng = Angle(12.149, 50.547, 45)

SWEP.DefaultElements = {"westar35"}

SWEP.AttachmentElements = {
    ["westar35"] = {
        VMElements = {
            {
                Model = "models/arccw/sw_battlefront/weapons/westar_35_pistol.mdl",
                Bone = "v_scoutblaster_reference001",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(-0.25, -0.5, 0),
                    ang = Angle(0, 180, 0)
                }
            }
        },
        WMElements = {
            {
                Model = "models/arccw/sw_battlefront/weapons/westar_35_pistol.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(40, 20, -15.3),
                    ang = Angle(-15, -90, 180)
                }
            }
        },
    },
}
WMOverride = "models/arccw/sw_battlefront/weapons/westar_35_pistol.mdl" -- change the world model to something else. Please make sure it's compatible with the last one.

--SWEP.Attachments 
SWEP.Attachments = {
    [1] = {
        PrintName = "Optic", -- print name
        DefaultAttName = "Iron Sights", -- used to display the "no attachment" text
        Slot = "swoptic_module",
        VMScale = Vector(1,1,1),
        WMScale = Vector(9, 9, 9),
        Bone = "v_scoutblaster_reference001", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(-0.25, -2.4, 1.9),
            vang = Angle(0, 180, 0),
            wpos = Vector(70, 20, -40),
            wang = Angle(-15, 90, 180)
        },
    },
    [2] = {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment",
        VMScale = Vector(0.8, 0.8, 0.8),
        WMScale = Vector(9, 9, 9), -- used to display the "no attachment" text
        Slot = {"tactical","tac_pistol"},
        Bone = "v_scoutblaster_reference001", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(-0.5, -8, -0.5),
            vang = Angle(0, 90, 0),
            wpos = Vector(115, 20, -30),
            wang = Angle(-15, 0, 180)
        },
    },    
    [3] = {
        PrintName = "Muzzle", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"muzzle"},
        WMScale = Vector(9, 9, 9),
        Bone = "scoutblaster_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0, 0.3, 8.6),
            vang = Angle(90, 0, -90),
            wpos = Vector(130, 20, -53),
            wang = Angle(-15, 0, 180)
        },
    },        
    [6] = {
        PrintName = "Charms", -- print name
        DefaultAttName = "No Charm", -- used to display the "no attachment" text
        Slot = {"charm"},
        WMScale = Vector(8, 8, 8),
        Bone = "scoutblaster_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.9, 1.5, 5),
            vang = Angle(90, 0, -90),
            wpos = Vector(70, 27, -35),
            wang = Angle(-10, 0, 180)
        },
    },          
}


SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = "fire"
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "draw/gunfoley_pistol_draw_var_06.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "holster/gunfoley_pistol_sheathe_var_09.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
 --       Time = 3.35,
        SoundTable = {
            {s = "ArcCW_dc17.reload2", t = 1 / 30}, --s sound file
        },
    },


sound.Add({
    name =          "ArcCW_dc17.reload2",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "weapons/bf3/pistols.wav"
    }),
}
--addons/arccw_weapons/lua/weapons/arccw_westarm5_v2.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "Westar M5"
SWEP.Trivia_Class = "Blaster Rifle"
SWEP.Trivia_Desc = "High tech compact Westar M5 Blaster Carbine, preffered for CQB enviroments and general allround usage."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Medium Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 3

SWEP.UseHands = true

SWEP.ViewModel = "models/meeks/v_westar_meeks.mdl"
SWEP.WorldModel = "models/meeks/worldmodels/w_westar_v2.mdl"
SWEP.ViewModelFOV = 70
SWEP.HideViewmodel = false
SWEP.WorldModelOffset = {
    pos = Vector(10, 0, -5),
    ang = Angle(170, 180, 0),
    bone = "ValveBiped.Bip01_R_Hand",
}

SWEP.IconOverride = "materials/entities/westarm5_m.png"
SWEP.NoHideLeftHandInCustomization = false
SWEP.DefaultBodygroups = "000000000000"

SWEP.Damage = 35
SWEP.RangeMin = 180
SWEP.DamageMin = 27
SWEP.Range = 400
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400

SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_blue"
SWEP.TracerCol = Color(0, 0, 255)
SWEP.HullSize = 1

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 25

SWEP.Recoil = 0.27
SWEP.RecoilSide = 0.25
SWEP.RecoilRise = 0.13

SWEP.Delay = 60 / 440
SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 2
    },
    {
        Mode = 1
    },
    {
        Mode = 0
    },         
}
SWEP.AccuracyMOA = 0.5 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 500 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50

----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100


SWEP.DistantShootSound = "dc15a/SW02_Weapons_Blasters_Shared_Corebass_Tight_Close_VAR_02 0 0 0.mp3"
SWEP.ShootSound = "westar/blasters_f-11aba_heavycannon_laser_close_var_01.mp3"
SWEP.ShootSoundSilenced = "w/dc19.wav"

SWEP.NoFlash = nil -- disable light flash
-- SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false -- Use Gmod muzzle effects rather than particle effects

SWEP.MuzzleEffectAttachment = "1" -- which attachment to put the muzzle on
SWEP.ProceduralViewBobAttachment = 1 -- attachment on which coolview is affected by, default is muzzleeffect
SWEP.MuzzleFlashColor = Color(0, 0, 250)

SWEP.IronSightStruct = {
    Pos = Vector(-2.845, -4, 0.8),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "zoom_in/gunfoley_zoomin_blasterrifle_08.mp3",
     ViewModelFOV = 50,
}
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(1.5, -2, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(7, -10, 0)
SWEP.SprintAng = Angle(-10, 40, 0)

SWEP.CustomizePos = Vector(20.824, -10, 3.897)
SWEP.CustomizeAng = Angle(12.149, 50.547, 45)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.Attachments = {
    [1] = {
        PrintName = "Optic", -- print name
        DefaultAttName = "Iron Sights", -- used to display the "no attachment" text
        Slot = "optic",
        Bone = "sights", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(-0.07, -1.7, 1),
            vang = Angle(90, 0, -90),
            wpos = Vector(9, 1.2, -6),
            wang = Angle(-10, 0, 180)
        },
    },
    [2] = {
        PrintName = "Foregrip", -- print name
        DefaultAttName = "No Attachment",
        NoVM = true,
        NoWM = true, -- used to display the "no attachment" text
        Slot = {"foregrip"},
        Bone = "sights", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(-0.2, 4.8, 6.5),
            vang = Angle(0, 0, -90),
            wpos = Vector(10, 1.5, -3),
            wang = Angle(170, 180, 0),
        },
    },          
    [3] = {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"tactical","tac_pistol","tac"},
        Bone = "sights", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(1.1, -0.5, 10),
            vang = Angle(90, 0, 0),
            wpos = Vector(16, 2, -6.5),
            wang = Angle(-10, 0, -90)
        },
    },
    [4] = {
        PrintName = "Muzzle", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"muzzle","dlt19_muzzle", "dc15a_muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "sights", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(-0.055, -0.4  , 13.8),
            vang = Angle(90, 0, -90),
            wpos = Vector(20, 1.1, -7.1),
            wang = Angle(-10, 0, -90)
        },
    },    
    [5] = {
        PrintName = "Magazine", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {},
        Bone = "sights", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.3, 2.3, -3),
            vang = Angle(0, 0, 0),
        },
    },         
    [6] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = "ammo",
    },
    [7] = {
        PrintName = "Training/Perk", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "perk",
    },
    [8] = {
        PrintName = "Charms", -- print name
        DefaultAttName = "No Charm", -- used to display the "no attachment" text
        Slot = {"charm"},
        Bone = "sights", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(.9, -0.7, -3.3),
            vang = Angle(90, 0, -90),
            wpos = Vector(6, 1.8, -5),
            wang = Angle(-10 , 0, 190)
        },
    },     
    [9] = {
        PrintName = "Grip", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "grip",
    },    
    [10] = {
        PrintName = "Internal Modifications", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "uc_fg",
    },   
}
SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = "fire"
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "draw/gunfoley_blaster_draw_var_04.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "draw/gunfoley_blaster_draw_var_08.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        LHIK = true,
        LHIKOut = 0.6,
        Time = 3,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "reloads/heavy.wav", t = 4 / 30}, --s sound file
        },
    },

}
--lua/weapons/dagger/shared.lua:
SWEP.Author       = "Segaretka"
SWEP.PrintName    = " Dagger"
SWEP.Category     = "Gluk Melee"
SWEP.Contact      = "Type:Melee Class:Simple"
SWEP.Purpose      = ""
SWEP.Instructions = "LMB to attack, RBM to special attack"
 
SWEP.AdminSpawnable = true
SWEP.AutoSwitchTo   = false
SWEP.Spawnable      = true
SWEP.AutoSwitchFrom = false
SWEP.FiresUnderwater= false
SWEP.Weight         = 5
SWEP.DrawCrosshair  = true
SWEP.Slot           = 0
SWEP.SlotPos        = 1
SWEP.DrawAmmo		= false
SWEP.base           = "weapon_base"
SWEP.HoldType       = "knife"

SWEP.UseHands = true
SWEP.ViewModelFOV   = 40
SWEP.ViewModel = "models/weapons/cstrike/c_knife_t.mdl"
SWEP.WorldModel = "models/weapons/w_knife_t.mdl"
SWEP.ViewModelFlip  = false
SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
["v_weapon.Knife_Handle"] = { scale = Vector(0.37, 0.37, 0.37), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) }
}
SWEP.VElements = {
	["blade"] = { type = "Model", model = "models/hunter/misc/squarecap1x1x1.mdl", bone = "ValveBiped.Bip01_Spine4", rel = "hils", pos = Vector(0, 0, 8.831), angle = Angle(0, 90, 0), size = Vector(0.041, 0.009, 0.172), color = Color(255, 255, 255, 255), surpresslightning = false, material = "metal2a", skin = 0, bodygroup = {} },
	["hils++"] = { type = "Model", model = "models/hunter/blocks/cube025x125x025.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0.3, -1, 4.675), angle = Angle(0, 0.8, 1.169), size = Vector(0.05, 0.059, 0.05), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/indenttiles_1-2", skin = 0, bodygroup = {} },
	["hils"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "v_weapon.Knife_Handle", rel = "", pos = Vector(0, 0, -0.7), angle = Angle(0, 0.8, 0), size = Vector(0.05, 0.039, 0.108), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/metalset_1-2", skin = 0, bodygroup = {} },
	["hils+"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, -0.102), angle = Angle(0, 90, 0), size = Vector(0.028, 0.039, 0.028), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/indenttiles_1-2", skin = 0, bodygroup = {} }
}
SWEP.WElements = {
	["hils"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3, 1, 2.5), angle = Angle(-170, 5, 0), size = Vector(0.05, 0.039, 0.108), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/metalset_1-2", skin = 0, bodygroup = {} },
	["hils++"] = { type = "Model", model = "models/hunter/blocks/cube025x125x025.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0.3, -1, 4.675), angle = Angle(0, 0.8, 1.169), size = Vector(0.05, 0.059, 0.05), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/indenttiles_1-2", skin = 0, bodygroup = {} },
	["blade"] = { type = "Model", model = "models/hunter/misc/squarecap1x1x1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, 8.831), angle = Angle(0, 90, 0), size = Vector(0.041, 0.009, 0.172), color = Color(255, 255, 255, 255), surpresslightning = false, material = "metal2a", skin = 0, bodygroup = {} },
	["hils+"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, -0.102), angle = Angle(0, 90, 0), size = Vector(0.028, 0.039, 0.028), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/indenttiles_1-2", skin = 0, bodygroup = {} }
}

SWEP.BobScale = 1
SWEP.SwayScale = 0

SWEP.Idle = 0
SWEP.IdleTimer = CurTime()

SWEP.Primary.ClipSize 	 = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic   = true
SWEP.Primary.Ammo 		 = "none"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

SWEP.Primary.Damage 	 = 10
SWEP.Primary.DelayMiss	 = 1
SWEP.Primary.DelayHit 	 = 0.26
SWEP.Primary.Force 		 = 1
SWEP.Primary.ImpactDecal = "ManhackCut"
SWEP.Primary.Range       = 10

SWEP.Secondary.Damage 	   = 30
SWEP.Secondary.DelayMiss   = 1.5
SWEP.Secondary.DelayHit	   = 0.7
SWEP.Secondary.Force	   = 5
SWEP.Secondary.ImpactDecal = "Impact.Metal"
SWEP.Secondary.Range       = 12

local SwingSound = Sound( "WeaponFrag.Roll" )
local HitSoundWorld = Sound( "GlassBottle.ImpactHard" )
local HitSoundBody = Sound( "Flesh_Bloody.ImpactHard" )
local HitSoundProp = Sound( "" )
local indec = 0

SWEP.indec = 0

function SWEP:Initialize()
self:SetWeaponHoldType( self.HoldType )
self.Idle = 0
self.IdleTimer = CurTime() + 1
end

function SWEP:Deploy()
self:SetWeaponHoldType( self.HoldType )
self.Weapon:SendWeaponAnim( ACT_VM_DRAW )
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
return true
end

function SWEP:Holster()
self.Idle = 0
self.IdleTimer = CurTime()
self.indec = 0
return true
end

function SWEP:PrimaryAttack()
self:SetHoldType( self.HoldType )
self:EmitSound( SwingSound )
local bullet = {}
bullet.Num = 1
bullet.Src = self.Owner:GetShootPos()
bullet.Dir = self.Owner:GetAimVector()
bullet.Distance = self.Primary.Distance
bullet.Spread = Vector( 0, 0, 0 )
bullet.Tracer = 0
bullet.Force = self.Primary.Force
bullet.Damage = 0
bullet.AmmoType = "none"

local tr = util.TraceLine( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Primary.Range*4,
filter = self.Owner,
mask = MASK_SHOT_HULL,
} )
if ( tr.Hit ) then
util.Decal(self.Primary.ImpactDecal, tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)  
end
if !IsValid( tr.Entity ) then
tr = util.TraceHull( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Primary.Range*4,
filter = self.Owner,
mins = Vector( -1* self.Primary.Range, -1*self.Primary.Range, 0 ),
maxs = Vector(  1* self.Primary.Range,  1*self.Primary.Range, 0 ),
mask = MASK_SHOT_HULL,
} )
end
if SERVER then
if IsValid( tr.Entity ) then
local dmg = DamageInfo()
local attacker = self.Owner
if !IsValid( attacker ) then
attacker = self
end
dmg:SetAttacker( attacker )
dmg:SetInflictor( self )
dmg:SetDamage( self.Primary.Damage )
dmg:SetDamageForce( self.Owner:GetForward() * self.Primary.Force )
tr.Entity:TakeDamageInfo( dmg )
end
if ( tr.Hit ) then
		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") or string.find(tr.Entity:GetClass(),"prop_physics") then
		if string.find(tr.Entity:GetClass(),"prop_physics") then
		self:EmitSound( HitSoundProp )
		else
		self:EmitSound( HitSoundBody )
		if self.indec < 11 then
		self.indec = self.indec + 1
		
		end
		end
		self.Owner:FireBullets(bullet)	
		else
		self:EmitSound( HitSoundWorld )
		end
		end
end
if !tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_PRIMARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayMiss )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayMiss )
end
if tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_MISSCENTER )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayHit )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayHit )
end
self:ShootEffects()
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end


function SWEP:SecondaryAttack()
self:SetHoldType( self.HoldType )
self:EmitSound( SwingSound )
local bullet = {}
bullet.Num = 1
bullet.Src = self.Owner:GetShootPos()
bullet.Dir = self.Owner:GetAimVector()
bullet.Distance = self.Secondary.Distance
bullet.Spread = Vector( 0, 0, 0 )
bullet.Tracer = 0
bullet.Force = self.Secondary.Force
bullet.Damage = 0
bullet.AmmoType = "none"

local tr = util.TraceLine( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Secondary.Range*4,
filter = self.Owner,
mask = MASK_SHOT_HULL,
} )
if ( tr.Hit ) then
util.Decal(self.Secondary.ImpactDecal, tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)  
end
if !IsValid( tr.Entity ) then
tr = util.TraceHull( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Secondary.Range*4,
filter = self.Owner,
mins = Vector( -16, -16, 0 ),
maxs = Vector( 16, 16, 0 ),
mask = MASK_SHOT_HULL,
} )
end
if SERVER then
if IsValid( tr.Entity ) then
local dmg = DamageInfo()
local attacker = self.Owner
if !IsValid( attacker ) then
attacker = self
end
dmg:SetAttacker( attacker )
dmg:SetInflictor( self )
dmg:SetDamage( self.Secondary.Damage )
dmg:SetDamageForce( self.Owner:GetForward() * self.Secondary.Force )
tr.Entity:TakeDamageInfo( dmg )
end
if ( tr.Hit ) then
		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") or string.find(tr.Entity:GetClass(),"prop_physics") then
		if string.find(tr.Entity:GetClass(),"prop_physics") then
		self:EmitSound( HitSoundProp )
		else
		self:EmitSound( HitSoundBody )
		if self.indec < 11 then
		self.indec = self.indec + 1
		end
		end
		self.Owner:FireBullets(bullet)	
		else
		self:EmitSound( HitSoundWorld )
		end
		end
end
if !tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_SECONDARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Secondary.DelayMiss )
self:SetNextSecondaryFire( CurTime() + self.Secondary.DelayMiss )
end
if tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_SECONDARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Secondary.DelayHit )
self:SetNextSecondaryFire( CurTime() + self.Secondary.DelayHit )
end
self:ShootEffects()
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end

function SWEP:ShootEffects()
self.Owner:SetAnimation( PLAYER_ATTACK1 )
end

function SWEP:Reload()
end

function SWEP:Think()
if self.IdleTimer <= CurTime() then
if self.Idle == 0 then
self.Idle = 1
end
if SERVER and self.Idle == 1 then
self.Weapon:SendWeaponAnim( ACT_VM_IDLE )
end
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end
end


/********************************************************
	SWEP Construction Kit base code
		Created by Clavus
	Available for public use, thread at:
	   facepunch.com/threads/1032378
	   
	   
	DESCRIPTION:
		This script is meant for experienced scripters 
		that KNOW WHAT THEY ARE DOING. Don't come to me 
		with basic Lua questions.
		
		Just copy into your SWEP or SWEP base of choice
		and merge with your own code.
		
		The SWEP.VElements, SWEP.WElements and
		SWEP.ViewModelBoneMods tables are all optional
		and only have to be visible to the client.
********************************************************/

function SWEP:Initialize()

	// other initialize code goes here

	if CLIENT then
		
		self:SetWeaponHoldType( self.HoldType )	
		// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		// init view model bone build function
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				--[[// Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end]]--
			end
		end
		
	end

end

function SWEP:Holster()
	
	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	
	return true
end

function SWEP:OnRemove()
	self:Holster()
end

if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			// we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			// when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			// !! WORKAROUND !! //
			// We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			// !! ----------- !! //
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				// !! WORKAROUND !! //
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				// !! ----------- !! //
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

	/**************************
		Global utility code
	**************************/

	// Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	// Does not copy entities of course, only copies their reference.
	// WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end


--lua/weapons/demonic_mace/shared.lua:
SWEP.Author       = "Segaretka"
SWEP.PrintName    = "Demonic Mace"
SWEP.Category     = "Gluk Melee"
SWEP.Contact      = "Type:Melee Class:Demonic"
SWEP.Purpose      = ""
SWEP.Instructions = "LMB to attack"
 
SWEP.AdminSpawnable = true
SWEP.AutoSwitchTo   = false
SWEP.Spawnable      = true
SWEP.AutoSwitchFrom = false
SWEP.FiresUnderwater= false
SWEP.Weight         = 5
SWEP.DrawCrosshair  = true
SWEP.Slot           = 0
SWEP.SlotPos        = 1
SWEP.DrawAmmo		= false
SWEP.base           = "weapon_base"
SWEP.HoldType       = "melee"

SWEP.UseHands = true
SWEP.ViewModelFOV   = 40
SWEP.ViewModel = "models/weapons/cstrike/c_knife_t.mdl"
SWEP.WorldModel = "models/weapons/w_knife_t.mdl"
SWEP.ViewModelFlip  = false
SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
	["ValveBiped.Bip01_L_Clavicle"] = { scale = Vector(1, 1, 1), pos = Vector(-23.519, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_R_Forearm"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(50, 0, 0) },
	["ValveBiped.Bip01_R_Clavicle"] = { scale = Vector(1, 1, 1), pos = Vector(-8.334, 3.888, 5.741), angle = Angle(10, 0, 0) },
	["v_weapon.Knife_Handle"] = { scale = Vector(0.37, 0.37, 0.37), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) }
}
SWEP.VElements = {
	["hils++"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, 4.675), angle = Angle(0, 90, 0), size = Vector(0.028, 0.039, 0.028), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/road", skin = 0, bodygroup = {} },
	["hils++++++"] = { type = "Model", model = "models/hunter/blocks/cube05x05x05.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, 22.337), angle = Angle(141.429, 90, 0), size = Vector(0.081, 0.081, 0.081), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/road", skin = 0, bodygroup = {} },
	["hils+"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, -0.102), angle = Angle(0, 90, 0), size = Vector(0.028, 0.039, 0.028), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/road", skin = 0, bodygroup = {} },
	["hils+++++"] = { type = "Model", model = "models/hunter/blocks/cube05x05x05.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, 22.337), angle = Angle(0, 90, 50), size = Vector(0.082, 0.082, 0.082), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/road", skin = 0, bodygroup = {} },
	["hils+++"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, 4.675), angle = Angle(0, 0.8, 0), size = Vector(0.05, 0.039, 0.4), color = Color(52, 39, 0, 255), surpresslightning = false, material = "phoenix_storms/road", skin = 0, bodygroup = {} },
	["hils"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "v_weapon.Knife_Handle", rel = "", pos = Vector(0, 0, -0.7), angle = Angle(0, 0.8, 0), size = Vector(0.05, 0.039, 0.108), color = Color(52, 39, 0, 255), surpresslightning = false, material = "phoenix_storms/road", skin = 0, bodygroup = {} },
	["hils++++"] = { type = "Model", model = "models/hunter/blocks/cube05x05x05.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, 22.337), angle = Angle(0, 90, 0), size = Vector(0.079, 0.079, 0.079), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/road", skin = 0, bodygroup = {} }
}
SWEP.WElements = {
	["hils++++++"] = { type = "Model", model = "models/hunter/blocks/cube05x05x05.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, 22.337), angle = Angle(141.429, 90, 0), size = Vector(0.081, 0.081, 0.081), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/road", skin = 0, bodygroup = {} },
	["hils++++"] = { type = "Model", model = "models/hunter/blocks/cube05x05x05.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, 22.337), angle = Angle(0, 90, 0), size = Vector(0.079, 0.079, 0.079), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/road", skin = 0, bodygroup = {} },
	["hils+++++"] = { type = "Model", model = "models/hunter/blocks/cube05x05x05.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, 22.337), angle = Angle(0, 90, 50), size = Vector(0.082, 0.082, 0.082), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/road", skin = 0, bodygroup = {} },
	["hils+"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, -0.102), angle = Angle(0, 90, 0), size = Vector(0.028, 0.039, 0.028), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/road", skin = 0, bodygroup = {} },
	["hils+++"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, 4.675), angle = Angle(0, 0.8, 0), size = Vector(0.05, 0.039, 0.4), color = Color(52, 39, 0, 255), surpresslightning = false, material = "phoenix_storms/road", skin = 0, bodygroup = {} },
	["hils"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3, 1, 2.5), angle = Angle(-170, -36.235, 8), size = Vector(0.05, 0.039, 0.108), color = Color(52, 39, 0, 255), surpresslightning = false, material = "phoenix_storms/road", skin = 0, bodygroup = {} },
	["hils++"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, 4.675), angle = Angle(0, 90, 0), size = Vector(0.028, 0.039, 0.028), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/road", skin = 0, bodygroup = {} }
}



SWEP.BobScale = 1
SWEP.SwayScale = 0

SWEP.Idle = 0
SWEP.IdleTimer = CurTime()

SWEP.Primary.ClipSize 	 = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic   = true
SWEP.Primary.Ammo 		 = "none"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

SWEP.Primary.Damage 	 = 40
SWEP.Primary.DelayMiss	 = 1.2
SWEP.Primary.DelayHit 	 = 0.98
SWEP.Primary.Force 		 = 1
SWEP.Primary.ImpactDecal = "Impact.Glass"
SWEP.Primary.Range       = 12

SWEP.Secondary.Life        = false
SWEP.Secondary.Damage 	   = 70
SWEP.Secondary.DelayMiss   = 1.5
SWEP.Secondary.DelayHit	   = 0.7
SWEP.Secondary.Force	   = 5
SWEP.Secondary.ImpactDecal = "Impact.Metal"
SWEP.Secondary.Range       = 18

local SwingSound = Sound( "WeaponFrag.Roll" )
local HitSoundWorld = Sound( "GlassBottle.ImpactHard" )
local HitSoundBody = Sound( "Flesh_Bloody.ImpactHard" )
local HitSoundProp = Sound( "" )
local indec = 0

SWEP.indec = 0

function SWEP:Initialize()
self:SetWeaponHoldType( self.HoldType )
self.Idle = 0
self.IdleTimer = CurTime() + 1
end

function SWEP:Deploy()
self:SetWeaponHoldType( self.HoldType )
self.Weapon:SendWeaponAnim( ACT_VM_DRAW )
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
return true
end

function SWEP:Holster()
self.Idle = 0
self.IdleTimer = CurTime()
self.indec = 0
return true
end

function SWEP:PrimaryAttack()
self:SetHoldType( self.HoldType )
self:EmitSound( SwingSound )
local bullet = {}
bullet.Num = 1
bullet.Src = self.Owner:GetShootPos()
bullet.Dir = self.Owner:GetAimVector()
bullet.Distance = self.Primary.Distance
bullet.Spread = Vector( 0, 0, 0 )
bullet.Tracer = 0
bullet.Force = self.Primary.Force
bullet.Damage = 0
bullet.AmmoType = "none"

local tr = util.TraceLine( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Primary.Range*4,
filter = self.Owner,
mask = MASK_SHOT_HULL,
} )
if ( tr.Hit ) then
util.Decal(self.Primary.ImpactDecal, tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)  
end
if !IsValid( tr.Entity ) then
tr = util.TraceHull( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Primary.Range*4,
filter = self.Owner,
mins = Vector( -1* self.Primary.Range, -1*self.Primary.Range, 0 ),
maxs = Vector(  1* self.Primary.Range,  1*self.Primary.Range, 0 ),
mask = MASK_SHOT_HULL,
} )
end
if SERVER then
if IsValid( tr.Entity ) then
local dmg = DamageInfo()
local attacker = self.Owner
if !IsValid( attacker ) then
attacker = self
end
dmg:SetAttacker( attacker )
dmg:SetInflictor( self )
dmg:SetDamage( self.Primary.Damage )
dmg:SetDamageForce( self.Owner:GetForward() * self.Primary.Force )
tr.Entity:TakeDamageInfo( dmg )
end
if ( tr.Hit ) then
		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") or string.find(tr.Entity:GetClass(),"prop_physics") then
		if string.find(tr.Entity:GetClass(),"prop_physics") then
		self:EmitSound( HitSoundProp )
		else
		self:EmitSound( HitSoundBody )
		if self.indec < 11 then
		self.Primary.Damage = self.Primary.Damage + 5
		self.Secondary.Damage = self.Secondary.Damage + 5
		self.indec = self.indec + 1
		
		end
		end
		self.Owner:FireBullets(bullet)	
		else
		self:EmitSound( HitSoundWorld )
		end
		end
end
if !tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_PRIMARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayMiss )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayMiss )
end
if tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_MISSCENTER )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayHit )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayHit )
end
self:ShootEffects()
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end


function SWEP:SecondaryAttack()
self:SetHoldType( self.HoldType )
self:EmitSound( SwingSound )
local bullet = {}
bullet.Num = 1
bullet.Src = self.Owner:GetShootPos()
bullet.Dir = self.Owner:GetAimVector()
bullet.Distance = self.Secondary.Distance
bullet.Spread = Vector( 0, 0, 0 )
bullet.Tracer = 0
bullet.Force = self.Secondary.Force
bullet.Damage = 0
bullet.AmmoType = "none"

local tr = util.TraceLine( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Secondary.Range*4,
filter = self.Owner,
mask = MASK_SHOT_HULL,
} )
if ( tr.Hit ) then
util.Decal(self.Secondary.ImpactDecal, tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)  
end
if !IsValid( tr.Entity ) then
tr = util.TraceHull( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Secondary.Range*4,
filter = self.Owner,
mins = Vector( -16, -16, 0 ),
maxs = Vector( 16, 16, 0 ),
mask = MASK_SHOT_HULL,
} )
end
if SERVER then
if IsValid( tr.Entity ) then
local dmg = DamageInfo()
local attacker = self.Owner
if !IsValid( attacker ) then
attacker = self
end
dmg:SetAttacker( attacker )
dmg:SetInflictor( self )
dmg:SetDamage( self.Secondary.Damage )
dmg:SetDamageForce( self.Owner:GetForward() * self.Secondary.Force )
tr.Entity:TakeDamageInfo( dmg )
end
if ( tr.Hit ) then
		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") or string.find(tr.Entity:GetClass(),"prop_physics") then
		if string.find(tr.Entity:GetClass(),"prop_physics") then
		self:EmitSound( HitSoundProp )
		else
		self:EmitSound( HitSoundBody )
		if self.indec < 11 then
		self.Primary.Damage = self.Primary.Damage + 5
		self.Secondary.Damage = self.Secondary.Damage + 5
		self.indec = self.indec + 1
		end
		end
		self.Owner:FireBullets(bullet)	
		else
		self:EmitSound( HitSoundWorld )
		end
		end
end
if !tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_SECONDARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Secondary.DelayMiss )
self:SetNextSecondaryFire( CurTime() + self.Secondary.DelayMiss )
end
if tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_SECONDARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Secondary.DelayHit )
self:SetNextSecondaryFire( CurTime() + self.Secondary.DelayHit )
end
self:ShootEffects()
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end

function SWEP:ShootEffects()
self.Owner:SetAnimation( PLAYER_ATTACK1 )
end

function SWEP:Reload()
end

function SWEP:Think()
if self.IdleTimer <= CurTime() then
if self.Idle == 0 then
self.Idle = 1
end
if SERVER and self.Idle == 1 then
self.Weapon:SendWeaponAnim( ACT_VM_IDLE )
end
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end
end


/********************************************************
	SWEP Construction Kit base code
		Created by Clavus
	Available for public use, thread at:
	   facepunch.com/threads/1032378
	   
	   
	DESCRIPTION:
		This script is meant for experienced scripters 
		that KNOW WHAT THEY ARE DOING. Don't come to me 
		with basic Lua questions.
		
		Just copy into your SWEP or SWEP base of choice
		and merge with your own code.
		
		The SWEP.VElements, SWEP.WElements and
		SWEP.ViewModelBoneMods tables are all optional
		and only have to be visible to the client.
********************************************************/

function SWEP:Initialize()

	// other initialize code goes here

	if CLIENT then
		
		self:SetWeaponHoldType( self.HoldType )	
		// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		// init view model bone build function
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				--[[// Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end]]--
			end
		end
		
	end

end

function SWEP:Holster()
	
	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	
	return true
end

function SWEP:OnRemove()
	self:Holster()
end

if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			// we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			// when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			// !! WORKAROUND !! //
			// We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			// !! ----------- !! //
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				// !! WORKAROUND !! //
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				// !! ----------- !! //
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

	/**************************
		Global utility code
	**************************/

	// Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	// Does not copy entities of course, only copies their reference.
	// WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end


--lua/weapons/ls_vehicle_mine_swep.lua:
AddCSLuaFile()

hook.Add("Initialize", "ls_add_vehicle_mine_ammo", function()
    game.AddAmmoType( {
        name = "LS_VEHICLE_MINE",
        dmgtype = DMG_BLAST, 
        plydmg = 0,
        npcdmg = 0,
        force = 0,
        maxcarry = 5,
        minsplash = 0,
        maxsplash = 0
    } )
end)
if CLIENT then
    language.Add("LS_VEHICLE_MINE_ammo", "Anti-Vehicle Mine")
end

SWEP.Base = "ls_base_mine_swep"

SWEP.PrintName = "Anti-Vehicle Mine"
SWEP.Author = "List-Scripts"
SWEP.Instructions = ""
SWEP.Category = "Star Wars - Mines"

SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Primary.DefaultClip = 5 -- the default amount of ammo the swep comes with
SWEP.Primary.Ammo = "LS_VEHICLE_MINE" -- the ammo type of the swep

SWEP.Mine = "ls_vehicle_mine" -- class of the mine entity to be used
SWEP.AngleLimitation = 10 -- the max angle the mine can be placed at, false for no limit
SWEP.PlaceDelay = 0.5 -- the delay between placing mines
SWEP.CanUndo = false -- whether the mine can be undone by the player

-- put the model for view and world model here, which the player hold in his hand
-- use the swep construction kit for help with positioning if wanted

SWEP.VElements = {
	["mine"] = { type = "Model", model = "models/props/starwars/weapons/lasertrap.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(5.714, 6.752, 0.518), angle = Angle(-180, 0, 0)}
}

SWEP.WElements = {
	["mine"] = { type = "Model", model = "models/props/starwars/weapons/lasertrap.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(4.675, 6.752, -0.519), angle = Angle(-180, -29.222, 0)}
}
--addons/arccw_weapons/lua/weapons/masita_dc15s_modular.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 -- Change this if you want to select the weapon with other number

-- Trivia
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = "Kraken/Masita"
SWEP.PrintName = "Modular DC-15s"
SWEP.Trivia_Class = "Blaster Carabine"
SWEP.Trivia_Desc = "The DC-15A blaster carbine, also referred to as the DC-15S blaster, was a blaster carbine model used by the Grand Army of the Republic. It was part of the DC-15 family. While smaller than the larger DC-15A blaster rifle, both could be referred to as blaster rifles. It was one of the most common weapons issued to clone troopers during the Clone Wars and were used during many battles."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/masita/dc15s_modular.png"

-- Viewmodel & Entity Properties
SWEP.UseHands = true
SWEP.MirrorVMWM = true
SWEP.NoHideLeftHandInCustomization = false

SWEP.ViewModel = "models/arccw/kraken/c_dc15s_modular.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dc15s_modular.mdl"
SWEP.ViewModelFOV = 58
SWEP.WorldModelOffset = {
    pos = Vector(-11, 4.3, -3.4),
    ang = Angle(-10, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
}

-- Damage & Tracer
SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.2,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 37
SWEP.RangeMin = 198
SWEP.DamageMin = 21
SWEP.Range = 399
SWEP.Penetration = 1.1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400
SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1
SWEP.TracerNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 250)
SWEP.HullSize = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 34

SWEP.Recoil = 0.67
SWEP.RecoilSide = 0.34
SWEP.RecoilRise = 0.53
SWEP.Delay = 60 / 255

SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 1
    },
    {
        Mode = 2
    },
    {
        Mode = 0
    },         
}

SWEP.AccuracyMOA = 0.2 
SWEP.HipDispersion = 490
SWEP.MoveDispersion = 60

-- Sounds & Muzzleflash
SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 50
SWEP.ShootPitch = 90
SWEP.ShootPitchVariation = 0.05

SWEP.ShootSound = "armas/disparos/dc15s.wav"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"

SWEP.NoFlash = nil
-- SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 0, 250)

-- Ironsight & Holdtype
SWEP.IronSightStruct = {
    Pos = Vector(-4.157, -6.7, 1.56),
    Ang = Angle(0, 0, 0),
     Magnification = 1.6,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 55,
}

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "smg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SMG1

SWEP.ActivePos = Vector(0, 0, 0)
SWEP.ActiveAng = Angle(1, -0.5, -5)

SWEP.SprintPos = Vector(7, 0, -4)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(9.824, 2, -2.897)
SWEP.CustomizeAng = Angle(12.149, 30.547, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments 
SWEP.AttachmentElements = {
    ["15s_barrel"] = {
        VMBodygroups = {{ind = 1, bg = 1}},
        NameChange = "Sniper DC-15s",
        AttPosMods = {
            [6] = {
                vpos = Vector(-.1, 0.1, 24.6),
            },
        }
    },
    ["15s_mag_ext"] = {
        VMBodygroups = {{ind = 2, bg = 1}},
    },
    ["15s_mag_a280"] = {
        VMBodygroups = {{ind = 2, bg = 2}},
    },
    ["15s_mag_drum"] = {
        VMBodygroups = {{ind = 2, bg = 3}},
    },
    ["15s_stock_extended"] = {
        VMBodygroups = {{ind = 6, bg = 1}},
    },
    ["15s_stock_skeleton"] = {
        VMBodygroups = {{ind = 6, bg = 2}},
    },
    ["15s_ironsight"] = {
        VMBodygroups = {{ind = 4, bg = 1}},
    },
}
SWEP.Attachments = {
    [1] = {   
        PrintName = "Optic", 
        DefaultAttName = "Standard", 
        Slot = "optic",
        Bone = "DC15s",
        InstalledEles = {"15s_ironsight"},
        Offset = {
            vpos = Vector(-0.2, -0.7, 2.4),
            vang = Angle(90, 0, -90),
        },
    },    
    [2] = {
        PrintName = "Foregrip",
        DefaultAttName = "None",
        Slot = "foregrip",
        Bone = "DC15s",
        Offset = {
            vpos = Vector(-0.101, 2.378, 6.164),
            vang = Angle(90, 0, -90),
        },
        SlideAmount = {
        vmin = Vector(-0.1, 0, 7),
        vmax = Vector(-0.1, 0, 10),
        },          
    },
    [3] = {
        PrintName = "Stock",
        DefaultAttName = "None",
        Bone = "DC15s",
        Slot = {"stock", "15s_stock"},
        Offset = {
            vpos = Vector(-0.2, 1.3, -6.6),
            vang = Angle(0, 0, -90),
        },
    }, 
    [4] = {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.7, 0.7, 0.7),
        Bone = "DC15s", 
        Offset = {
            vpos = Vector(0.4, 0, 11),
            vang = Angle(90, 0, 0),
        },
    },
    [5] = {
        PrintName = "Barrel",
        DefaultAttName = "None",
        Slot = {"15s_barrel"},
        Bone = "DC15s",
    },   
    [6] = {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"15s_barrel", "muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "DC15s",
        Offset = {
            vpos = Vector(-.1, 0.1, 13.7),
            vang = Angle(90, 0, -90),
        },
    },    
    [7] = {
        PrintName = "Magazine",
        DefaultAttName = "Standard",
        Slot = {"15s_mag"},
    },
    [8] = {
        PrintName = "Ammo",
        DefaultAttName = "Standard",
        Slot = {"ammo"},
    },
    [9] = {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    [10] = {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = "uc_fg",
    },
    [11] = {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "DC15s",
        VMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(0.55, 1.5, 2.6),
            vang = Angle(90, 0, -90),
        },
    },     
    [12] = {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        Bone = "DC15s",
        Offset = {
            vpos = Vector(0.65, 0.35, -3),
            vang = Angle(90, 0, -90),
        },
    },      
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = false,
    },
    ["fire"] = {
        Source = "fire"
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1.4,
        SoundTable = {
            {
                s = "w/dc15s/overheat_manualcooling_resetfoley_generic_var_01.mp3",
                p = 100,
                v = 75,
                t = 0,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "w/dc15s/gunfoley_blaster_sheathe_var_03.mp3",
                p = 100, 
                v = 75, 
                t = 0,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        SoundTable = {
            {s = "everfall/weapons/miscellaneous/reload/overheat/overheat_overheated_large_var_02.mp3", t = 10 / 60},
            {s = "everfall/weapons/miscellaneous/reload/reset/overheat_reset_var_04.mp3", t = 120 / 60},
        },
    },
}
--addons/arccw_weapons/lua/weapons/masita_dc17_train.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 2

-- Trivia
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = "Kraken/Masita"
SWEP.PrintName = "Training DC-17"
SWEP.Trivia_Class = "Blaster Pistol"
SWEP.Trivia_Desc = "The DC-17 hand blaster, also known as DC-17 blaster pistol, was a heavy blaster pistol wielded by the clone troopers of the Grand Army of the Galactic Republic during the Clone Wars. An advanced firearm, it was fielded to elite soldiers in the army, most notably Advanced Recon Commandos, clone trooper commanders, and clone jet troopers."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/masita/dc17_training.png"

SWEP.UseHands = true
SWEP.MirrorVMWM = true
SWEP.NoHideLeftHandInCustomization = true

SWEP.ViewModel = "models/venator/weapons/viewmodels/c_dc17.mdl"
SWEP.WorldModel = "models/venator/weapons/worldmodels/w_dc-17.mdl"
SWEP.ViewModelFOV = 58
SWEP.WorldModelOffset = {
    pos = Vector(-11.3, 4.3, -3),
    ang = Angle(-10, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
}

SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 1.5,
    [HITGROUP_CHEST] = 1,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 1
SWEP.RangeMin = 102
SWEP.DamageMin = 1
SWEP.Range = 299
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400

SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tracer_orange"
SWEP.TracerCol = Color(255, 145, 0)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 20

SWEP.Recoil = 0.98
SWEP.RecoilPunch = 0.8
SWEP.RecoilSide = 0.17
SWEP.RecoilRise = 0.24

SWEP.Delay = 60 / 300
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 1
	},
    {
		Mode = -2
	},
    {
        Mode = 0
    },
}

SWEP.AccuracyMOA = 0.22 
SWEP.HipDispersion = 530
SWEP.MoveDispersion = 50

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17_orange"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(255, 174, 0)

---- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-3.922, -4.125, 0.237),
    Ang = Vector(0.158, -3.961, 0),
     Magnification = 1.2,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 50,
}

SWEP.Primary.Ammo = "ar2"

-- Sound & Holdtype
SWEP.ShootVol = 50
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

SWEP.FirstShootSound = "armas/disparos/dc17_2.wav"
SWEP.ShootSound = "armas/disparos/dc17_1.wav"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"

SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL

SWEP.ActivePos = Vector(1, 6, 1)
SWEP.ActiveAng = Angle(-3.2, -3, 0)

SWEP.SprintPos = Vector(1, -6, -10)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.CustomizePos = Vector(10, 0, -1.08)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

-- Attachments 
SWEP.AttachmentElements = {
    ["dc17_powerpack"] = {
        VMBodygroups = {
            {ind = 4, bg = 1},
        },
    },
    ["dc17_cooling"] = {
        VMBodygroups = {
            {ind = 3, bg = 1},
        },
    },
}

SWEP.Attachments = {
    {
        PrintName = "Sight", 
        DefaultAttName = "Standard", 
        Slot = "optic",
        Bone = "DC-17",
        Offset = {
            vpos = Vector(0, -2.3, 0),
            vang = Angle(90, 0, -90),
        },
        CorrectiveAng = Angle(9, 0, 0),
        CorrectivePos = Vector(0, 0, 0),
    },  
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        WMScale = Vector(0.7, 0.7, 0.7),
        VMScale = Vector(0.7, 0.7, 0.7),
        Bone = "DC-17",
        Offset = {
            vpos = Vector(0, -0.3, 2.7),
            vang = Angle(90, 0, -90),
        },
    },     
    {
        PrintName = "Muzzle", 
        DefaultAttName = "None", 
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        Bone = "DC-17",
        Offset = {
            vpos = Vector(0, -1.2, 3.442),
            vang = Angle(90, 0, -90),
        },
    }, 
    {
        PrintName = "Grip",
        Slot = "grip",
        DefaultAttName = "Standard Grip"
    },        
    {
        PrintName = "Energization", 
        DefaultAttName = "Standard",
        Slot = "ammo",
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Cooling System",
        DefaultAttName = "None",
        Slot = "dc17_cooling",
    },
    {
        PrintName = "Powerpack",
        DefaultAttName = "None",
        Slot = "dc17_powerpack",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = "uc_fg",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        VMScale = Vector(0.7,0.7,0.7),
        Bone = "DC-17",
        Offset = {
            vpos = Vector(0.7, -0.848, 0.184),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        Bone = "DC-17",
        Offset = {
            vpos = Vector(0.7, -0.848, -3),
            vang = Angle(90, 0, -90),
        },
    },   
}


SWEP.Animations = {
    ["idle"] = {
        Source = false,
    },
    ["fire"] = {
        Source = "fire"
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "draw/gunfoley_pistol_draw_var_06.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "holster/gunfoley_pistol_sheathe_var_09.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        SoundTable = {
            {s = "dc17_1", t = 1 / 60}, --s sound file
        },
    },


sound.Add({
    name =          "dc17_1",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "armasclasicas/wpn_wristrocket_reload.wav"
    }),
}
--addons/arccw_weapons/lua/weapons/masita_dp23.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = "Kraken/Masita"
SWEP.PrintName = "DP-23"
SWEP.Trivia_Class = "Blaster Heavy Shotgun"
SWEP.Trivia_Desc = "The DP-23 was a type of blaster that could pierce through enemy defenses. It was used by the Grand Army of the Republic's clone troopers during the Clone Wars between the Galactic Republic and the Confederacy of Independent Systems. The DP-23 fired blue blaster bolts, and had a ridged barrel with a pointed muzzle, a black stock, and a small foregrip."
SWEP.Trivia_Manufacturer = "Unknown"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/masita/dp23.png"

SWEP.Slot = 3

SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/bf2017/c_dlt19.mdl"
SWEP.WorldModel = "models/arccw/bf2017/w_e11.mdl"
SWEP.ViewModelFOV = 55
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.009
}

SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 1.5,
    [HITGROUP_CHEST] = 1.5,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 25
SWEP.RangeMin = 20
SWEP.DamageMin = 17
SWEP.Range = 55
SWEP.Penetration = 1.1
SWEP.DamageType = DMG_BUCKSHOT
SWEP.MuzzleVelocity = 400

SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 255)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 12

SWEP.Recoil = 2
SWEP.RecoilSide = 2
SWEP.RecoilPunch = 0.9
SWEP.RecoilRise = 0.9

SWEP.Delay = 10 / 70
SWEP.Num = 5
SWEP.Firemodes = {
	{
		Mode = 1
	},
    {
        Mode = 0
    },
}

SWEP.AccuracyMOA = 50
SWEP.HipDispersion = 450
SWEP.MoveDispersion = 100

SWEP.NoFlash = nil -- disable light flash
-- SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 0, 250)
SWEP.Primary.Ammo = "ar2"

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-3.325, -5.188, 2),
    Ang = Vector(0, 0, 0),
     Magnification = 1.2,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.04
SWEP.ShootSound = "armas/disparos/dp23.wav"
SWEP.ShootSoundSilenced = "armas/disparos/silenced_sniper.mp3"

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "shotgun"
SWEP.HoldtypeSights = "smg"
SWEP.HoldtypeCustomize = "slam"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN

SWEP.ActivePos = Vector(-1, 2, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(4.019, -5.226, -0.805)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.CustomizePos = Vector(7, -3, -1.206)
SWEP.CustomizeAng = Angle(18.291, 30.954, 17.587)

SWEP.DefaultElements = {"dp23", "muzzle"}
SWEP.AttachmentElements = {
    ["dp23"] = {
        VMElements = {
            {
                Model = "models/tor/dp23_base.mdl",
                Bone = "v_dlt19_reference001",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(-0.5, 5, 1.5),
                    ang = Angle(0, -180, 0)
                }
            }
        }
    },
    ["muzzle"] = {
         VMElements = {
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "dlt19_sight",
                Scale = Vector(0, 0, 0),             
                Offset = {
                    pos = Vector(-0.5, 5, 8),
                    ang = Angle(90, 0, 0)
                },
                IsMuzzleDevice = true
            }
        },
        WMElements = {
            {
                Model = "models/tor/dp23_base.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1.2, 1.2, 1.2),
                Offset = {
                    pos = Vector(1100, -50, -450),
                    ang = Angle(5, 90, 190)
                }
            },
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(2800, 0, -500),
                    ang = Angle(-15, 0, 180)
                },
                IsMuzzleDevice = true
            },            
        }, 
    }
}
WMOverride = "models/tor/dp23_base.mdl"

--SWEP.Attachments
SWEP.Attachments = {
    {
        PrintName = "Sight", 
        DefaultAttName = "Standard",
        Slot = "optic",
        Bone = "dlt19_sight",
        VMScale = Vector(0.8, 0.8, 0.8),
        WMScale = Vector(111, 111, 111),
        Offset = {
            vpos = Vector(-0.150, 0.6, -1.5),
            vang = Angle(90, 0, -90),
            wpos = Vector(1000, 50, -740),
            wang = Angle(-5, -1, 180)
        },
        CorrectiveAng = Angle(0, 0, 0),
        CorrectivePos = Vector(0, 0, 0),
    }, 
    {
        PrintName = "Tactical",
        DefaultAttName = "None", 
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.8, 0.8, 0.8),
        WMScale = Vector(111, 111, 111),
        Bone = "dlt19_sight",
        Offset = {
            vpos = Vector(0.8, 2.5, 7),
            vang = Angle(90, 0, -0),
            wpos = Vector(2300, 200, -600),
            wang = Angle(-5, -1, -90)
        },
    },    
    {
        PrintName = "Grenade Launcher", 
        DefaultAttName = "None",
        Slot = "rep_ubgl",
        Bone = "v_dlt19_reference001",
        WMScale = Vector(130, 130, 130),
        Offset = {
            vpos = Vector(0, 5, 1.6),
            vang = Angle(0, -90, 0),
            wpos = Vector(1200, 50, -530),
            wang = Angle(-5, -1, -180)
        },   
        LHIK = true    
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None", 
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "dlt19_sight", 
        WMScale = Vector(111, 111, 111),
        Offset = {
            vpos = Vector(0, 2.5, 10),
            vang = Angle(90, 0, -90),
            wpos = Vector(2800, 50, -650),
            wang = Angle(-5, 0.5, 180)
        },
    },  
    {
        PrintName = "Energization",
        DefaultAttName = "Standard Energization",
        Slot = {"ammo", "shotgun_ammo"}
    }, 
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },       
    {
        PrintName = "Training/Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        WMScale = Vector(111, 111, 111),
        Bone = "dlt19_sight",
        Offset = {
            vpos = Vector(0.5, 2.5, -6),
            vang = Angle(90, 0, -90),
            wpos = Vector(400, 150, -430),
            wang = Angle(-5, 0, 180)
        },
    },           
}
SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = {"shoot1", "shoot2", "shoot3"}
    },
    ["fire_iron"] = {
        Source = {"shoot1", "shoot2", "shoot3"}
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "draw/gunfoley_pistol_draw_var_06.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "holster/gunfoley_pistol_sheathe_var_09.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "everfall/weapons/miscellaneous/reload/overheat/overheat_overheated_large_var_04.mp3", t = 0.1/30},
            {s = "everfall/weapons/miscellaneous/reload/reset/overheatactivecoolingsuccess_var_01.mp3", t = 2},
        },
    },
}
--lua/weapons/spear/shared.lua:
SWEP.Author       = "Killua"
SWEP.PrintName    = " Spear"
SWEP.Category     = "Gluk Melee"
SWEP.Contact      = "Type:Melee Class:Simple"
SWEP.Purpose      = ""
SWEP.Instructions = "LMB to attack"
 
SWEP.AdminSpawnable = true
SWEP.AutoSwitchTo   = false
SWEP.Spawnable      = true
SWEP.AutoSwitchFrom = false
SWEP.FiresUnderwater= false
SWEP.Weight         = 5
SWEP.DrawCrosshair  = true
SWEP.Slot           = 0
SWEP.SlotPos        = 1
SWEP.DrawAmmo		= false
SWEP.base           = "weapon_base"
SWEP.HoldType 		= "knife"

SWEP.UseHands = true
SWEP.ViewModelFOV   = 40
SWEP.ViewModel = "models/weapons/cstrike/c_knife_t.mdl"
SWEP.WorldModel = "models/weapons/w_knife_t.mdl"
SWEP.ViewModelFlip  = false
SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
	["v_weapon.Knife_Handle"] = { scale = Vector(0.093, 0.093, 0.093), pos = Vector(0, 0, 0), angle = Angle(-7.778, 0, 0) },
	["ValveBiped.Bip01_R_Forearm"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(14.444, 0, 0) },
	["ValveBiped.Bip01_Spine4"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, -12.778), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_R_Clavicle"] = { scale = Vector(1, 1, 1), pos = Vector(-0.556, 0, 2.407), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_L_Clavicle"] = { scale = Vector(1, 1, 1), pos = Vector(-2.3, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_R_Hand"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0.925), angle = Angle(-56.667, 0, 0) }
}

SWEP.VElements = {
	["Pipe"] = { type = "Model", model = "models/props_junk/harpoon002a.mdl", bone = "v_weapon.Knife_Handle", rel = "", pos = Vector(0.218, -0.12, 2.596), angle = Angle(94.675, 0, 0), size = Vector(0.497, 0.497, 0.497), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
}

SWEP.WElements = {
	["Pipe"] = { type = "Model", model = "models/props_junk/harpoon002a.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(2, 1, -14.027), angle = Angle(-94.676, 0, 0), size = Vector(0.69, 0.69, 0.69), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}


SWEP.BobScale = 1
SWEP.SwayScale = 0

SWEP.Idle = 0
SWEP.IdleTimer = CurTime()

SWEP.Primary.ClipSize 	 = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic   = true
SWEP.Primary.Ammo 		 = "none"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

SWEP.Primary.Damage 	 = 40
SWEP.Primary.DelayMiss	 = 1.2
SWEP.Primary.DelayHit 	 = 0.98
SWEP.Primary.Force 		 = 1
SWEP.Primary.ImpactDecal = "Impact.Metal"
SWEP.Primary.Range       = 26

SWEP.Secondary.Life        = false
SWEP.Secondary.Damage 	   = 70
SWEP.Secondary.DelayMiss   = 1.5
SWEP.Secondary.DelayHit	   = 0.7
SWEP.Secondary.Force	   = 5
SWEP.Secondary.ImpactDecal = "Impact.Metal"
SWEP.Secondary.Range       = 18

local SwingSound = Sound( "WeaponFrag.Roll" )
local HitSoundWorld = Sound( "GlassBottle.ImpactHard" )
local HitSoundBody = Sound( "Flesh_Bloody.ImpactHard" )
local HitSoundProp = Sound( "" )
local indec = 0

SWEP.indec = 0

function SWEP:Initialize()
self:SetWeaponHoldType( self.HoldType )
self.Idle = 0
self.IdleTimer = CurTime() + 1
end

function SWEP:Deploy()
self:SetWeaponHoldType( self.HoldType )
self.Weapon:SendWeaponAnim( ACT_VM_DRAW )
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
return true
end

function SWEP:Holster()
self.Idle = 0
self.IdleTimer = CurTime()
self.indec = 0
return true
end

function SWEP:PrimaryAttack()
self:SetHoldType( self.HoldType )
self:EmitSound( SwingSound )
local bullet = {}
bullet.Num = 1
bullet.Src = self.Owner:GetShootPos()
bullet.Dir = self.Owner:GetAimVector()
bullet.Distance = self.Primary.Distance
bullet.Spread = Vector( 0, 0, 0 )
bullet.Tracer = 0
bullet.Force = self.Primary.Force
bullet.Damage = 0
bullet.AmmoType = "none"

local tr = util.TraceLine( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Primary.Range*4,
filter = self.Owner,
mask = MASK_SHOT_HULL,
} )
if ( tr.Hit ) then
util.Decal(self.Primary.ImpactDecal, tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)  
end
if !IsValid( tr.Entity ) then
tr = util.TraceHull( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Primary.Range*4,
filter = self.Owner,
mins = Vector( -1* self.Primary.Range, -1*self.Primary.Range, 0 ),
maxs = Vector(  1* self.Primary.Range,  1*self.Primary.Range, 0 ),
mask = MASK_SHOT_HULL,
} )
end
if SERVER then
if IsValid( tr.Entity ) then
local dmg = DamageInfo()
local attacker = self.Owner
if !IsValid( attacker ) then
attacker = self
end
dmg:SetAttacker( attacker )
dmg:SetInflictor( self )
dmg:SetDamage( self.Primary.Damage )
dmg:SetDamageForce( self.Owner:GetForward() * self.Primary.Force )
tr.Entity:TakeDamageInfo( dmg )
end
if ( tr.Hit ) then
		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") or string.find(tr.Entity:GetClass(),"prop_physics") then
		if string.find(tr.Entity:GetClass(),"prop_physics") then
		self:EmitSound( HitSoundProp )
		else
		self:EmitSound( HitSoundBody )
		if self.indec < 11 then
		self.indec = self.indec + 1
		
		end
		end
		self.Owner:FireBullets(bullet)	
		else
		self:EmitSound( HitSoundWorld )
		end
		end
end
if !tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_PRIMARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayMiss )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayMiss )
end
if tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_MISSCENTER )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayHit )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayHit )
end
self:ShootEffects()
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end


function SWEP:SecondaryAttack()
self:SetHoldType( self.HoldType )
self:EmitSound( SwingSound )
local bullet = {}
bullet.Num = 1
bullet.Src = self.Owner:GetShootPos()
bullet.Dir = self.Owner:GetAimVector()
bullet.Distance = self.Secondary.Distance
bullet.Spread = Vector( 0, 0, 0 )
bullet.Tracer = 0
bullet.Force = self.Secondary.Force
bullet.Damage = 0
bullet.AmmoType = "none"

local tr = util.TraceLine( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Secondary.Range*4,
filter = self.Owner,
mask = MASK_SHOT_HULL,
} )
if ( tr.Hit ) then
util.Decal(self.Secondary.ImpactDecal, tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)  
end
if !IsValid( tr.Entity ) then
tr = util.TraceHull( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Secondary.Range*4,
filter = self.Owner,
mins = Vector( -16, -16, 0 ),
maxs = Vector( 16, 16, 0 ),
mask = MASK_SHOT_HULL,
} )
end
if SERVER then
if IsValid( tr.Entity ) then
local dmg = DamageInfo()
local attacker = self.Owner
if !IsValid( attacker ) then
attacker = self
end
dmg:SetAttacker( attacker )
dmg:SetInflictor( self )
dmg:SetDamage( self.Secondary.Damage )
dmg:SetDamageForce( self.Owner:GetForward() * self.Secondary.Force )
tr.Entity:TakeDamageInfo( dmg )
end
if ( tr.Hit ) then
		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") or string.find(tr.Entity:GetClass(),"prop_physics") then
		if string.find(tr.Entity:GetClass(),"prop_physics") then
		self:EmitSound( HitSoundProp )
		else
		self:EmitSound( HitSoundBody )
		if self.indec < 11 then
		self.indec = self.indec + 1
		end
		end
		self.Owner:FireBullets(bullet)	
		else
		self:EmitSound( HitSoundWorld )
		end
		end
end
if !tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_SECONDARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Secondary.DelayMiss )
self:SetNextSecondaryFire( CurTime() + self.Secondary.DelayMiss )
end
if tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_SECONDARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Secondary.DelayHit )
self:SetNextSecondaryFire( CurTime() + self.Secondary.DelayHit )
end
self:ShootEffects()
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end

function SWEP:ShootEffects()
self.Owner:SetAnimation( PLAYER_ATTACK1 )
end

function SWEP:Reload()
end

function SWEP:Think()
if self.IdleTimer <= CurTime() then
if self.Idle == 0 then
self.Idle = 1
end
if SERVER and self.Idle == 1 then
self.Weapon:SendWeaponAnim( ACT_VM_IDLE )
end
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end
end


/********************************************************
	SWEP Construction Kit base code
		Created by Clavus
	Available for public use, thread at:
	   facepunch.com/threads/1032378
	   
	   
	DESCRIPTION:
		This script is meant for experienced scripters 
		that KNOW WHAT THEY ARE DOING. Don't come to me 
		with basic Lua questions.
		
		Just copy into your SWEP or SWEP base of choice
		and merge with your own code.
		
		The SWEP.VElements, SWEP.WElements and
		SWEP.ViewModelBoneMods tables are all optional
		and only have to be visible to the client.
********************************************************/

function SWEP:Initialize()

	// other initialize code goes here

	if CLIENT then
		
		self:SetWeaponHoldType( self.HoldType )	
		// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		// init view model bone build function
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				--[[// Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end]]--
			end
		end
		
	end

end

function SWEP:Holster()
	
	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	
	return true
end

function SWEP:OnRemove()
	self:Holster()
end

if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			// we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			// when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			// !! WORKAROUND !! //
			// We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			// !! ----------- !! //
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				// !! WORKAROUND !! //
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				// !! ----------- !! //
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

	/**************************
		Global utility code
	**************************/

	// Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	// Does not copy entities of course, only copies their reference.
	// WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end


--addons/weapons_other/lua/weapons/st_schild.lua:
AddCSLuaFile()


/* 
---------------------------------------------------------------------------------------------------------------------------------------------
				Downloading content from workshop
---------------------------------------------------------------------------------------------------------------------------------------------
*/	

--if SERVER then resource.AddWorkshop("2441211404"); end

/* 
---------------------------------------------------------------------------------------------------------------------------------------------
				Config
---------------------------------------------------------------------------------------------------------------------------------------------
*/

SWEP.shieldDamage = 10;
SWEP.bashReloadTime = 20;
SWEP.stunTime = 1;

SWEP.canBeDestroyedByDamage = false;
SWEP.onlyExplosionDamage = true;
SWEP.defaultHealth = 1000;

local deleteShieldsAfterDeath = true;

/* 
---------------------------------------------------------------------------------------------------------------------------------------------
				Default SWEP config
---------------------------------------------------------------------------------------------------------------------------------------------
*/

SWEP.DrawAmmo = false
SWEP.DrawCrosshair = false
SWEP.Author = "Drover | Edit by Mickerd"
SWEP.Contact = "Discord: Mickerd#1593"
SWEP.Purpose = ""
SWEP.IconLetter = ""
SWEP.PrintName = "ST Kampfschild"
SWEP.ViewModelFOV = 62
SWEP.ViewModelFlip = false
SWEP.AnimPrefix = "physgun"
SWEP.HoldType ="physgun"
SWEP.Spawnable = true
SWEP.AdminOnly = true
SWEP.Category = "AOCRP - Eingestellte Waffen"

SWEP.ViewModel = Model("models/drover/shield.mdl");
SWEP.WorldModel = Model("models/weapons/arccw_cg/v_shield.mdl");



SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = 0
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = ""

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = 0
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = ""



/* 
---------------------------------------------------------------------------------------------------------------------------------------------
				Initialize
---------------------------------------------------------------------------------------------------------------------------------------------
*/

function SWEP:Initialize()
    self:SetHoldType("physgun");
end



function SWEP:SetupShield()
	--if true then return end
	if CLIENT then return end;
	self.shieldProp = ents.Create("prop_physics");
	self.shieldProp:SetModel("models/hunter/blocks/cube075x2x025.mdl");
	
	self.shieldProp:Spawn(); 
	--self.shieldProp:SetModelScale(0,0);
	local phys = self.shieldProp:GetPhysicsObject();
	if not IsValid(phys) then
		self.Owner:ChatPrint("not valid physics object!");
		return;
	end
	phys:SetMass(5000);
	
	local nothand = false;
	local attach = self.Owner:LookupAttachment("anim_attachment_RH");
	if attach == nil or attach == 0 then
		--self.Owner:ChatPrint("Attachment 'anim_attachment_RH' not found for this player model!");
		attach = self.Owner:LookupAttachment("forward");
		nothand = true;
		if attach == nil or attach == 0 then
			self.Owner:ChatPrint("Attachment 'anim_attachment_RH' and 'forward' not found for this player model!");
			return;
		end
	end
	
	local up = -15;
	local forward = 15;
	local right = -8;
	
	local aforward = 20;
	local aup = 70;
	
	if nothand then
	    up = -20;
		forward = 17;
		aforward = 0;
		aup = 90;
	end
	local attachTable = self.Owner:GetAttachment(attach);
	self.shieldProp:SetPos(attachTable.Pos + attachTable.Ang:Up()*up + attachTable.Ang:Forward()*forward + attachTable.Ang:Right()*right);
	
	attachTable.Ang:RotateAroundAxis(attachTable.Ang:Forward(),110);
	attachTable.Ang:RotateAroundAxis(attachTable.Ang:Up(),0);
	attachTable.Ang:RotateAroundAxis(attachTable.Ang:Right(),105);
	self.shieldProp:SetAngles(attachTable.Ang);
	self.shieldProp:SetCollisionGroup( COLLISION_GROUP_WORLD );
	self.shieldProp:SetParent(self.Owner,attach);
	self.shieldProp:SetRenderMode( RENDERMODE_TRANSCOLOR )
	self.shieldProp:SetColor(Color(0,0,0,0))
	--self.shieldProp:SetModelScale(1,0);
	--self.shieldProp:SetNoDraw( true )
--[[ 	timer.Simple(0.2,function()
		if IsValid(self) and IsValid(self.shieldProp) then
			self.shieldProp:SetModelScale(1,0);
			net.Start("disable_shielddraw") net.WriteEntity(self) net.WriteEntity(self.shieldProp) net.Send(self.Owner);
		end
	end) ]]
	
	--self:SetupCollisionHelp()
end


/* 
---------------------------------------------------------------------------------------------------------------------------------------------
				CheckPlace
---------------------------------------------------------------------------------------------------------------------------------------------
*/
function SWEP:CheckPlace(pos)

	local mins = Vector( -10, -20, -3);
	local maxs = Vector( 20, 20, 40);
	local tr = {
		start = pos, 
		endpos = pos + Vector(0,0,5), 
		mins = mins, 
		maxs = maxs,
		filter = {self.Owner,self.shieldProp}
	}
	local hullTrace = util.TraceHull( tr );
	if ( hullTrace.Hit ) then
		return false;
	end	
	return true;	
end



/* 
---------------------------------------------------------------------------------------------------------------------------------------------
				Shield bash
---------------------------------------------------------------------------------------------------------------------------------------------
*/


function SWEP:FreezeEnemy(ply)
	ply:Freeze(true);
	timer.Create('unfreezemeswep'..tostring(ply:EntIndex()),self.stunTime,1,function()
		if IsValid(ply) then ply:Freeze(false); end
	end)
end

function SWEP:FindEnemy()
	local mins = Vector( -10, -10, -3);
	local maxs = Vector( 10, 10, 40);
	local pos = self.Owner:GetPos() + self.Owner:GetForward()*35 + Vector(0,0,40);
	local tr = {
		start = pos, 
		endpos = pos + Vector(0,0,5), 
		mins = mins, 
		maxs = maxs,
		filter = {self.Owner,self.shieldProp,Entity(0)}
	}
	local hullTrace = util.TraceHull( tr );
	if ( hullTrace.Hit ) then
		if hullTrace.Entity:IsPlayer() then
			return hullTrace.Entity;
		end
		return false;
	end
	return false;
end


function SWEP:ShieldBash()
	local enemy = self:FindEnemy();
    --self.Owner:EmitSound("w/dc15x/sdkaswq.wav");
	if enemy == false then return end;
	--enemy:TakeDamage(self.shieldDamage,self.Owner,self);
	--self:FreezeEnemy(enemy);

    --print(b:Nick() .. " > "..b:GetPos():DistToSqr( self:GetPos() ))
    GMSERV:AddStatus(b, enemy, "stun", 3, 10, true)
    self:EmitSound("everfall/explosions/ion/destruction_explosions_modular_sfx_small_disruption_var_05.mp3")

   -- self.Owner:EmitSound("w/dc15x/sdkaswq.wav");

end

/* 
---------------------------------------------------------------------------------------------------------------------------------------------
				Primary attack
---------------------------------------------------------------------------------------------------------------------------------------------
*/

function SWEP:PrimaryAttack()
	self:SetNextPrimaryFire(CurTime() + self.bashReloadTime);
	--self.Weapon:SendWeaponAnim( ACT_VM_PRIMARYATTACK );
	if CLIENT then return end;


    self:ShieldBash()

	
end


/* 
---------------------------------------------------------------------------------------------------------------------------------------------
				Secondary attack / Deploy static shield
---------------------------------------------------------------------------------------------------------------------------------------------
*/
function SWEP:SecondaryAttack()
	if CLIENT then return end;

--[[ 	for k, v in pairs(ents.GetAll()) do
		if v:GetClass() == "police_shield" then
			if v.Owner == self.Owner then
				v:Remove()
			end
		end
	end

	local ang = self.Owner:GetAngles()
	ang.p = 0;
	ang.r = 0;
	local pos = self.Owner:GetPos() + ang:Forward()*45 + Vector(0,0,10);
	local checkingPlace = self:CheckPlace(pos);
	if not checkingPlace then return end;
	local shieldEnt = ents.Create("police_shield");
	shieldEnt:SetPos(pos);
	local tempAngle = self.Owner:GetAngles();
	shieldEnt:SetAngles(Angle(0,tempAngle.y,0));
	
	shieldEnt.canBeDestroyedByDamage = self.canBeDestroyedByDamage;
	shieldEnt.onlyExplosionDamage = self.onlyExplosionDamage;
	shieldEnt.currentHealth = self.defaultHealth;
	
	shieldEnt:Spawn();
	shieldEnt.Owner = self.Owner;

	self:Remove(); ]]
end



/* 
---------------------------------------------------------------------------------------------------------------------------------------------
				Network initialize && Client Receive
---------------------------------------------------------------------------------------------------------------------------------------------
*/

if SERVER then
	util.AddNetworkString("disable_shielddraw");
	util.AddNetworkString("shieldbash");
end

if CLIENT then
	net.Receive("disable_shielddraw",function()
		local weaponEntity = net.ReadEntity();
		local shieldProp = net.ReadEntity();
		if IsValid(shieldProp) then
			shieldProp:SetNoDraw(true);
		if IsValid(weaponEntity) then
			weaponEntity.shieldProp = shieldProp;
		end	
		end
	end)
	
	
net.Receive('shieldbash',function()
	local ply = net.ReadEntity();
	if not IsValid(ply) or not ply:IsPlayer() or not ply:Alive() then return end;
--[[ 	ply:AnimRestartGesture( GESTURE_SLOT_GRENADE,ACT_GMOD_GESTURE_MELEE_SHOVE_2HAND, true );
 ]]
    local elec = EffectData()
    elec:SetOrigin(ply:GetPos())
    elec:SetMagnitude(3)
end)
	
	
end

/* 
---------------------------------------------------------------------------------------------------------------------------------------------
				Weapon dropped / replace world model
---------------------------------------------------------------------------------------------------------------------------------------------
*/
/*
 hook.Add("onDarkRPWeaponDropped","Police Shield",function(d2, ent, weapon)
	if weapon:GetClass() == "weapon_policeshield" then
		ent:SetModel("models/drover/w_shield.mdl");
	end
 end)
*/

/* 
---------------------------------------------------------------------------------------------------------------------------------------------
				Player Death / delete our shields
---------------------------------------------------------------------------------------------------------------------------------------------
*/

-- Nicht mehr da
-- hook.Add("PlayerDeath","PlayerDeathDeleteShields",function(ply)
-- 	if deleteShieldsAfterDeath then
-- 		for k,v in pairs(ents.FindByClass("police_shield")) do
-- 			if v.Owner != nil and IsValid(v.Owner) and v.Owner == ply then
-- 				v:Remove();
-- 			end
-- 		end
-- 	end	
-- end)

hook.Add("OnPlayerChangedTeam","PlayerChangeTeamDeleteShields",function(ply)
    if deleteShieldsAfterDeath then
        for k,v in pairs(ents.FindByClass("police_shield")) do
            if v.Owner != nil and IsValid(v.Owner) and v.Owner == ply then
                v:Remove();
            end
        end
    end
end)

/* 
---------------------------------------------------------------------------------------------------------------------------------------------
				Reload && Deploy && Holster && Drop && Remove
---------------------------------------------------------------------------------------------------------------------------------------------
*/


function SWEP:ViewModelDrawn(viewmodel)
	if IsValid(self.shieldProp) and !self.shieldProp:GetNoDraw() then
		self.shieldProp:SetNoDraw(true);
	end
end

if CLIENT then
	local WorldModel = ClientsideModel(SWEP.WorldModel)

	-- Settings...
	WorldModel:SetSkin(1)
	WorldModel:SetNoDraw(true)


	function SWEP:DrawWorldModel()
		local _Owner = self:GetOwner()

		if (IsValid(_Owner)) then
			-- Specify a good position
			local offsetVec = Vector(8,2,-24)
			local offsetAng = Angle(-10,15,200)
			
			local boneid = _Owner:LookupBone("ValveBiped.Bip01_R_Hand") -- Right Hand
			if !boneid then return end

			local matrix = _Owner:GetBoneMatrix(boneid)
			if !matrix then return end

			local newPos, newAng = LocalToWorld(offsetVec, offsetAng, matrix:GetTranslation(), matrix:GetAngles())

			WorldModel:SetPos(newPos)
			WorldModel:SetAngles(newAng)

			WorldModel:SetupBones()
		else
			WorldModel:SetPos(self:GetPos())
			WorldModel:SetAngles(self:GetAngles())
		end

		WorldModel:DrawModel()
	end
end

function SWEP:Reload()

end

function SWEP:Deploy()
	self:SetHoldType("physgun"); 
	self:SetupShield();
	return true
end

function SWEP:Holster()
	if CLIENT then return end;
	if not IsValid(self.shieldProp) then return true end;
	self.shieldProp:Remove();
	if not IsValid(self.collProp) then return true end;
	self.collProp:Remove()
	return true;
end


function SWEP:OnDrop()
	if CLIENT then return end;
	if not IsValid(self.shieldProp) then return true end;
	self.shieldProp:Remove();
	if not IsValid(self.collProp) then return true end;
	self.collProp:Remove()
	return true;
end

function SWEP:OnRemove()
	if CLIENT then return end;
	if not IsValid(self.shieldProp) then return true end;
	self.shieldProp:Remove();
	if not IsValid(self.collProp) then return true end;
	self.collProp:Remove()
	return true;
end


--addons/weapons_other/lua/weapons/weapon_handcuffed.lua:
-------------------------------------
---------------- Cuffs --------------
-------------------------------------
-- Copyright (c) 2015 Nathan Healy --
-------- All rights reserved --------
-------------------------------------
-- weapon_handcuffed.lua    SHARED --
--                                 --
-- Handcuffed. Limits what         --
-- equipping player can do.        --
-------------------------------------

AddCSLuaFile()

SWEP.Base = "weapon_base"

SWEP.Category = "Handcuffs"
SWEP.Author = "my_hat_stinks"
SWEP.Instructions = ""

SWEP.Spawnable = false
SWEP.AdminSpawnable = false
SWEP.AdminOnly = false

SWEP.Slot = 4
SWEP.PrintName = "Gefesselt"

SWEP.ViewModelFOV = 60
SWEP.Weight = 5
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false

SWEP.WorldModel = "models/weapons/w_toolgun.mdl"
SWEP.ViewModel = "models/weapons/c_arms_citizen.mdl"
SWEP.UseHands = true

SWEP.Primary.Recoil = 1
SWEP.Primary.Damage = 5
SWEP.Primary.NumShots = 1
SWEP.Primary.Cone = 0
SWEP.Primary.Delay = 1

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Primary.ClipMax = -1

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"
SWEP.Secondary.ClipMax = -1

SWEP.DeploySpeed = 1.5

SWEP.PrimaryAnim = ACT_VM_PRIMARYATTACK
SWEP.ReloadAnim = ACT_VM_RELOAD
SWEP.HoldType = "duel"

SWEP.IsHandcuffs = true
SWEP.CuffType = ""

CreateConVar( "cuffs_allowbreakout", 1, {FCVAR_ARCHIVE,FCVAR_SERVER_CAN_EXECUTE,FCVAR_REPLICATED,FCVAR_NOTIFY} )

// For anything that might try to drop this
SWEP.CanDrop = false
SWEP.PreventDrop = true
-- Missing anything?

//
// DataTables
function SWEP:SetupDataTables()
	self:NetworkVar( "Entity", 0, "Kidnapper" )
	self:NetworkVar( "Entity", 1, "FriendBreaking" )
	
	self:NetworkVar( "Float", 0, "RopeLength" )
	self:NetworkVar( "Float", 1, "CuffBroken" )
	self:NetworkVar( "Float", 2, "CuffStrength" )
	self:NetworkVar( "Float", 3, "CuffRegen" )
	
	self:NetworkVar( "String", 0, "RopeMaterial" )
	self:NetworkVar( "String", 1, "CuffMaterial" )
	
	self:NetworkVar( "Bool", 0, "CanGag" )
	self:NetworkVar( "Bool", 1, "IsGagged" )
	
	self:NetworkVar( "Bool", 2, "CanBlind" )
	self:NetworkVar( "Bool", 3, "IsBlind" )
end

//
// Initialize
function SWEP:Initialize()
	hook.Add( "canDropWeapon", self, function(wep, ply) if wep==self then return false end end) // Thank you DarkRP, your code is terrible
	
	if self:GetCuffStrength()<=0 then self:SetCuffStrength(1) end
	if self:GetCuffRegen()<=0 then self:SetCuffRegen(1) end
	self:SetCuffBroken( 0 )
	
	self:SetHoldType( self.HoldType )
end

//
// Standard SWEP functions
function SWEP:PrimaryAttack()
	--if SERVER then self:AttemptBreak() end
end
function SWEP:SecondaryAttack() end
function SWEP:Reload() end

//
// Equip and Holster
function SWEP:Equip( newOwner )
	newOwner:SelectWeapon( self:GetClass() )
	
	timer.Simple( 0.1, function() // Fucking FA:S
		if IsValid(self) and  IsValid(newOwner) and newOwner:GetActiveWeapon()~=self then
			local wep = newOwner:GetActiveWeapon()
			if not IsValid(wep) then return end
			
			local oHolster = wep.Holster
			wep.Holster = function() return true end
			newOwner:SelectWeapon( self:GetClass() )
			wep.Holster = oHolster
		end
	end)
	
	return true
end
function SWEP:Holster()
	return false
end

//
// Deploy
function SWEP:Deploy()
	local viewModel = self.Owner:GetViewModel()
	viewModel:SendViewModelMatchingSequence( viewModel:LookupSequence("fists_idle_01") )
	
	return true
end
function SWEP:PreDrawViewModel( viewModel ) // Fixes visible base hands
	viewModel:SetMaterial( "engine/occlusionproxy" )
end
function SWEP:OnRemove() // Fixes invisible other weapons
	if IsValid(self.Owner) then
		local viewModel = self.Owner:GetViewModel()
		if IsValid(viewModel) then viewModel:SetMaterial("") end
	end
	if IsValid( self.cmdl_LeftCuff ) then self.cmdl_LeftCuff:Remove() end
	if IsValid( self.cmdl_RightCuff ) then self.cmdl_RightCuff:Remove() end
	return true
end

//
// Release
function SWEP:Uncuff()
	local ply = IsValid(self.Owner) and self.Owner
	
	self:Remove()
	
	if ply then ply:ConCommand( "lastinv" ) end
end

//
// Breakout
if SERVER then
	local BreakSound = Sound( "physics/metal/metal_barrel_impact_soft4.wav" )
	function SWEP:Breakout()
		if IsValid(self.Owner) then
			sound.Play( BreakSound, self.Owner:GetShootPos(), 75, 100, 1 )
			if IsValid( self:GetFriendBreaking() ) then
				hook.Call( "OnHandcuffBreak", GAMEMODE, self.Owner, self, self:GetFriendBreaking() )
			else
				hook.Call( "OnHandcuffBreak", GAMEMODE, self.Owner, self )
			end
		end
		
		self:Uncuff()
	end
	function SWEP:AttemptBreak()
		if not cvars.Bool( "cuffs_allowbreakout" ) then return end
		
		self:SetCuffBroken( self:GetCuffBroken() + math.abs(4/self:GetCuffStrength()) )
		
		if self:GetCuffBroken()>=100 then
			self:Breakout()
		end
	end
	
	local function GetTrace( ply )
		local tr = util.TraceLine( {start=ply:EyePos(), endpos=ply:EyePos()+(ply:GetAimVector()*100), filter=ply} )
		if IsValid(tr.Entity) and tr.Entity:IsPlayer() then
			local cuffed,wep = tr.Entity:IsHandcuffed()
			if cuffed then return tr,wep end
		end
	end
	function SWEP:Think()
		if (self.NextRegen or 0)<=CurTime() then
			local regen = self:GetCuffRegen()
			local friend = self:GetFriendBreaking()
			if IsValid(friend) and friend:IsPlayer() then
				local tr = GetTrace(friend)
				if tr and tr.Entity==self.Owner then
					regen = (regen*0.5) - (2/self:GetCuffStrength())
				else
					self:SetFriendBreaking( nil )
				end
			end
			
			self:SetCuffBroken( math.Approach( self:GetCuffBroken(), regen<0 and 100 or 0, math.abs(regen) ) )
			self.NextRegen = CurTime()+0.05
			
			if self:GetCuffBroken()>=100 then self:Breakout() end
		end
		if IsValid(self:GetKidnapper()) and (self:GetKidnapper():IsPlayer() and not self:GetKidnapper():Alive()) then
			self:SetKidnapper( nil )
		end
		if IsValid(self.Owner) then
			self.Owner.KnockoutTimer = CurTime()+10 // Fucking DarkRP
		end
	end
end

//
// UI
if CLIENT then
	surface.CreateFont( "HandcuffsText", {
		font = "Arial",
		size = 20,
		weight = 700,
	})
	local Col = {
		Text = Color(255,255,255), TextShadow = Color(0,0,0),
		
		BoxOutline = Color(0,0,0), BoxBackground = Color(255,255,255,20), BoxLeft = Color(255,0,0), BoxRight = Color(0,255,0),
		
		Blind = Color(0,0,0, 253), Blind2 = Color(0,0,0, 255),
	}
	local matGrad = Material( "gui/gradient" )
	function SWEP:DrawHUD()
		local w,h = (ScrW()/2), (ScrH()/2)
		
		local TextPos = h+30
		local str = "Deine Hnde sind mit Handschellen fixiert."		
		draw.SimpleText( str, "HandcuffsText", w+1, TextPos+1, Col.TextShadow, TEXT_ALIGN_CENTER )
		draw.SimpleText( str, "HandcuffsText", w, TextPos, Col.Text, TEXT_ALIGN_CENTER )
		
		if self:GetIsBlind() then
			TextPos = TextPos+20
			draw.SimpleText( "Du siehst nix mehr.","HandcuffsText", w+1, TextPos+1, Col.TextShadow, TEXT_ALIGN_CENTER )
			draw.SimpleText( "Du siehst nix mehr.", "HandcuffsText", w, TextPos, Col.Text, TEXT_ALIGN_CENTER )
		end
		if self:GetIsGagged() then
			TextPos = TextPos+20
			draw.SimpleText( "You have been gagged", "HandcuffsText", w+1, TextPos+1, Col.TextShadow, TEXT_ALIGN_CENTER )
			draw.SimpleText( "You have been gagged", "HandcuffsText", w, TextPos, Col.Text, TEXT_ALIGN_CENTER )
		end
		
		if cvars.Bool( "cuffs_allowbreakout" ) then
			TextPos = TextPos+20
			str = string.format("%s to struggle", (input.LookupBinding("+attack") or "[Primary Fire]"):upper())
			draw.SimpleText( str, "HandcuffsText", w+1, TextPos+1, Col.TextShadow, TEXT_ALIGN_CENTER )
			draw.SimpleText( str, "HandcuffsText", w, TextPos, Col.Text, TEXT_ALIGN_CENTER )
		end
		--[[
		TextPos = TextPos+25
		surface.SetDrawColor( Col.BoxOutline )
		surface.DrawOutlinedRect( w-101, TextPos-1, 202, 22 )
		surface.SetDrawColor( Col.BoxBackground )
		surface.DrawRect( w-100, TextPos, 200, 20 )
		
		render.SetScissorRect( w-100, TextPos, (w-100)+((self:GetCuffBroken()/100)*200), TextPos+20, true )
			surface.SetDrawColor( Col.BoxRight )
			surface.DrawRect( w-100,TextPos, 200,20 )
			
			surface.SetMaterial( matGrad )
			surface.SetDrawColor( Col.BoxLeft )
			surface.DrawTexturedRect( w-100,TextPos, 200,20 )
		render.SetScissorRect( 0,0,0,0, false ) ]]--
	end
	function SWEP:DrawHUDBackground()
		if self:GetIsBlind() then
			surface.SetDrawColor( Col.Blind )
			surface.DrawRect( 0,0, ScrW(), ScrH() )
			
			surface.SetDrawColor( Col.Blind2 )
			for i=1,ScrH(),5 do
				surface.DrawRect( 0,i, ScrW(), 4 )
			end
			for i=1,ScrW(),5 do
				surface.DrawRect( i,0, 4,ScrH() )
			end
		end
	end
end

//
// Rendering
local renderpos = {
	left = {bone = "ValveBiped.Bip01_L_Wrist", pos=Vector(0.4,-0.15,-0.45), ang=Angle(90,0,0), scale = Vector(0.035,0.035,0.015)},
	right = {bone = "ValveBiped.Bip01_R_Wrist", pos=Vector(0.2,-0.15,0.35), ang=Angle(100,0,0), scale = Vector(0.035,0.035,0.015)},
	rope = {l = Vector(-0.2,1.3,-0.25), r = Vector(0.4,1.4,-0.2)},
}
local CuffMdl = "models/hunter/tubes/tube2x2x1.mdl"
local DefaultRope = "cable/cable2"
local RopeCol = Color(255,255,255)
function SWEP:ViewModelDrawn( vm )
	if not IsValid(vm) then return end
	
	if not IsValid(self.cmdl_LeftCuff) then
		self.cmdl_LeftCuff = ClientsideModel( CuffMdl, RENDER_GROUP_VIEW_MODEL_OPAQUE )
		self.cmdl_LeftCuff:SetNoDraw( true )
		self.cmdl_LeftCuff:SetParent( vm )
	end
	if not IsValid(self.cmdl_RightCuff) then
		self.cmdl_RightCuff = ClientsideModel( CuffMdl, RENDER_GROUP_VIEW_MODEL_OPAQUE )
		self.cmdl_RightCuff:SetNoDraw( true )
		self.cmdl_RightCuff:SetParent( vm )
	end
	
	local lpos, lang = self:GetBonePos( renderpos.left.bone, vm )
	local rpos, rang = self:GetBonePos( renderpos.right.bone, vm )
	if not (lpos and rpos and lang and rang) then return end
	
	// Left
	self.cmdl_LeftCuff:SetPos( lpos + (lang:Forward()*renderpos.left.pos.x) + (lang:Right()*renderpos.left.pos.y) + (lang:Up()*renderpos.left.pos.z) )
	local u,r,f = lang:Up(), lang:Right(), lang:Forward() // Prevents moving axes
	lang:RotateAroundAxis( u, renderpos.left.ang.y )
	lang:RotateAroundAxis( r, renderpos.left.ang.p )
	lang:RotateAroundAxis( f, renderpos.left.ang.r )
	self.cmdl_LeftCuff:SetAngles( lang )
	
	local matrix = Matrix()
	matrix:Scale( renderpos.left.scale )
	self.cmdl_LeftCuff:EnableMatrix( "RenderMultiply", matrix )
	
	self.cmdl_LeftCuff:SetMaterial( self:GetCuffMaterial() or "" )
	self.cmdl_LeftCuff:DrawModel()
	
	// Right
	self.cmdl_RightCuff:SetPos( rpos + (rang:Forward()*renderpos.right.pos.x) + (rang:Right()*renderpos.right.pos.y) + (rang:Up()*renderpos.right.pos.z) )
	local u,r,f = rang:Up(), rang:Right(), rang:Forward() // Prevents moving axes
	rang:RotateAroundAxis( u, renderpos.right.ang.y )
	rang:RotateAroundAxis( r, renderpos.right.ang.p )
	rang:RotateAroundAxis( f, renderpos.right.ang.r )
	self.cmdl_RightCuff:SetAngles( rang )
	
	local matrix = Matrix()
	matrix:Scale( renderpos.right.scale )
	self.cmdl_RightCuff:EnableMatrix( "RenderMultiply", matrix )
	
	self.cmdl_RightCuff:SetMaterial( self:GetCuffMaterial() or "" )
	self.cmdl_RightCuff:DrawModel()
	
	// Rope
	if self:GetRopeMaterial()~=self.LastMatStr then
		self.RopeMat = Material( self:GetRopeMaterial() )
		self.LastMatStr = self:GetRopeMaterial()
	end
	if not self.RopeMat then self.RopeMat = Material(DefaultRope) end
	
	render.SetMaterial( self.RopeMat )
	render.DrawBeam( lpos + (lang:Forward()*renderpos.rope.l.x) + (lang:Right()*renderpos.rope.l.y) + (lang:Up()*renderpos.rope.l.z),
		rpos + (rang:Forward()*renderpos.rope.r.x) + (rang:Right()*renderpos.rope.r.y) + (rang:Up()*renderpos.rope.r.z),
		0.7, 0, 5, RopeCol )
end

local wrender = {
	left = {bone = "ValveBiped.Bip01_L_Hand", pos=Vector(0,0,0), ang=Angle(90,0,0), scale = Vector(0.035,0.035,0.035)},
	right = {bone = "ValveBiped.Bip01_R_Hand", pos=Vector(0.2,0,0), ang=Angle(90,0,0), scale = Vector(0.035,0.035,0.035)},
	rope = {l = Vector(-0.2,1.3,-0.25), r = Vector(0.4,1.4,-0.2)},
}
function SWEP:DrawWorldModel()
	if not IsValid(self.Owner) then return end
	
	if not IsValid(self.cmdl_LeftCuff) then
		self.cmdl_LeftCuff = ClientsideModel( CuffMdl, RENDER_GROUP_VIEW_MODEL_OPAQUE )
		self.cmdl_LeftCuff:SetNoDraw( true )
		-- self.cmdl_LeftCuff:SetParent( vm )
	end
	if not IsValid(self.cmdl_RightCuff) then
		self.cmdl_RightCuff = ClientsideModel( CuffMdl, RENDER_GROUP_VIEW_MODEL_OPAQUE )
		self.cmdl_RightCuff:SetNoDraw( true )
		-- self.cmdl_RightCuff:SetParent( vm )
	end
	
	local lpos, lang = self:GetBonePos( wrender.left.bone, self.Owner )
	local rpos, rang = self:GetBonePos( wrender.right.bone, self.Owner )
	if not (lpos and rpos and lang and rang) then return end
	
	// Left
	self.cmdl_LeftCuff:SetPos( lpos + (lang:Forward()*wrender.left.pos.x) + (lang:Right()*wrender.left.pos.y) + (lang:Up()*wrender.left.pos.z) )
	local u,r,f = lang:Up(), lang:Right(), lang:Forward() // Prevents moving axes
	lang:RotateAroundAxis( u, wrender.left.ang.y )
	lang:RotateAroundAxis( r, wrender.left.ang.p )
	lang:RotateAroundAxis( f, wrender.left.ang.r )
	self.cmdl_LeftCuff:SetAngles( lang )
	
	local matrix = Matrix()
	matrix:Scale( wrender.left.scale )
	self.cmdl_LeftCuff:EnableMatrix( "RenderMultiply", matrix )
	
	self.cmdl_LeftCuff:SetMaterial( self:GetCuffMaterial() or "" )
	self.cmdl_LeftCuff:DrawModel()
	
	// Right
	self.cmdl_RightCuff:SetPos( rpos + (rang:Forward()*wrender.right.pos.x) + (rang:Right()*wrender.right.pos.y) + (rang:Up()*wrender.right.pos.z) )
	local u,r,f = rang:Up(), rang:Right(), rang:Forward() // Prevents moving axes
	rang:RotateAroundAxis( u, wrender.right.ang.y )
	rang:RotateAroundAxis( r, wrender.right.ang.p )
	rang:RotateAroundAxis( f, wrender.right.ang.r )
	self.cmdl_RightCuff:SetAngles( rang )
	
	local matrix = Matrix()
	matrix:Scale( wrender.right.scale )
	self.cmdl_RightCuff:EnableMatrix( "RenderMultiply", matrix )
	
	self.cmdl_RightCuff:SetMaterial( self:GetCuffMaterial() or "" )
	self.cmdl_RightCuff:DrawModel()
	
	// Rope
	if (lpos.x==0 and lpos.y==0 and lpos.z==0) or (rpos.x==0 and rpos.y==0 and rpos.z==0) then return end // Rope accross half the map...
	
	if self:GetRopeMaterial()~=self.LastMatStr then
		self.RopeMat = Material( self:GetRopeMaterial() )
		self.LastMatStr = self:GetRopeMaterial()
	end
	if not self.RopeMat then self.RopeMat = Material(DefaultRope) end
	
	render.SetMaterial( self.RopeMat )
	render.DrawBeam( lpos + (lang:Forward()*wrender.rope.l.x) + (lang:Right()*wrender.rope.l.y) + (lang:Up()*wrender.rope.l.z),
		rpos + (rang:Forward()*wrender.rope.r.x) + (rang:Right()*wrender.rope.r.y) + (rang:Up()*wrender.rope.r.z),
		0.7, 0, 5, RopeCol )
end

//
// Bones
function SWEP:GetBonePos( bonename, vm )
	local bone = vm:LookupBone( bonename )
	if not bone then return end
	
	local pos,ang = Vector(0,0,0),Angle(0,0,0)
	local matrix = vm:GetBoneMatrix( bone )
	if matrix then
		pos = matrix:GetTranslation()
		ang = matrix:GetAngles()
	end
	
	if self.ViewModelFlip then ang.r = -ang.r end
	
	-- if pos.x==0 and pos.y==0 and pos.z==0 then print( bonename, vm ) end
	return pos, ang
end


--addons/weapon_jedi/lua/weapons/weapon_lscs/sh_animations.lua:

function SWEP:SetGestureTime( time )
	self:SetNWGestureTime( time )
	self.f_NextGesture = time
end

function SWEP:GetGestureTime()
	if SERVER then
		return self:GetNWGestureTime()
	else
		local ply = self:GetOwner()
		if IsValid( ply ) and ply == LocalPlayer() then
			return (self.f_NextGesture or 0)
		else
			return self:GetNWGestureTime()
		end
	end
end

function SWEP:PlayAnimation( anim, start )
	if not start then
		start = 0
	end

	local ply = self:GetOwner()

	if not IsValid( ply ) then return end

	if game.SinglePlayer() then

		ply:AddVCDSequenceToGestureSlot( GESTURE_SLOT_ATTACK_AND_RELOAD, ply:LookupSequence( anim ), start, true )

		return
	end

	ply.s_vcd_anim = anim

	if SERVER then
		net.Start( "lscs_animations" )
			net.WriteEntity( ply )
			net.WriteBool( true )
			net.WriteString( anim )
			net.WriteString( tostring(start) )
		net.Broadcast()
	end

	ply:AddVCDSequenceToGestureSlot( GESTURE_SLOT_ATTACK_AND_RELOAD, ply:LookupSequence( anim ), start, true )
end

function SWEP:StopAnimation()
	local ply = self:GetOwner()

	if not IsValid( ply ) then return end

	ply.s_vcd_anim = nil

	self:SetGestureTime( CurTime() )

	ply:AnimResetGestureSlot( GESTURE_SLOT_ATTACK_AND_RELOAD )
end
--addons/weapon_jedi/lua/weapons/weapon_lscs/cl_worldmodel.lua:
SWEP.WorldModelCL = {}
SWEP.BladeModelCL = {}

function SWEP:DrawBladeModel( HandID, BladeID, PosData, bladeObject, Mul, HiltAngles )
	local HiltMDL = self:GetWorldModel( HandID )

	if not IsValid( HiltMDL ) then return end

	local BladeMDL = self:GetBladeModel( HandID, BladeID )

	if IsValid( BladeMDL ) then
		local Ang = HiltAngles
		local Forward = HiltAngles:Up()
		local Right = HiltAngles:Right()

		Ang:RotateAroundAxis( Right, math.deg( math.acos( math.Clamp( Forward:Dot( PosData.dir ) ,-1,1) ) ) )

		BladeMDL:SetPos( PosData.pos )
		BladeMDL:SetAngles( Ang )
		BladeMDL:SetupBones()
		BladeMDL:DrawModel()

		if bladeObject.mdl_poseparameter then
			BladeMDL:SetPoseParameter(bladeObject.mdl_poseparameter, Mul  )
			BladeMDL:InvalidateBoneCache()
		end
	else
		local Model = ClientsideModel( bladeObject.mdl )
		Model:SetNoDraw( true )
		self.BladeModelCL[ HandID ][BladeID ] = Model
	end
end

function SWEP:GetBladeModel( HandID, BladeID )
	if not self.BladeModelCL[ HandID ] then
		self.BladeModelCL[ HandID ] = {}
	end

	if HandID and BladeID then
		if not self.BladeModelCL[ HandID ][BladeID ] then
			return false
		else
			return self.BladeModelCL[ HandID ][BladeID ]
		end
	else
		return self.BladeModelCL
	end
end

function SWEP:GetWorldModel( handID )
	if handID then
		return self.WorldModelCL[ handID ]
	else
		return self.WorldModelCL
	end
end

function SWEP:UpdateWorldModel( hand , hiltobject )
	if hand == self.HAND_RIGHT then
		if IsValid( self.WorldModelCL[ self.HAND_RIGHT ] ) then
			self.WorldModelCL[ self.HAND_RIGHT ]:Remove()
		end

		if hiltobject then
			local WorldModel = ClientsideModel( hiltobject.mdl )
			WorldModel:SetNoDraw( true )
			self.WorldModelCL[ self.HAND_RIGHT ] = WorldModel
		end
	end

	if hand == self.HAND_LEFT then
		if IsValid( self.WorldModelCL[ self.HAND_LEFT ] ) then
			self.WorldModelCL[ self.HAND_LEFT ]:Remove()
		end

		if hiltobject then
			local WorldModel = ClientsideModel( hiltobject.mdl )
			WorldModel:SetNoDraw( true )
			self.WorldModelCL[ self.HAND_LEFT ] = WorldModel
		end
	end
end

function SWEP:ClearWorldModel()
	for _, mdl in pairs( self.WorldModelCL ) do
		if not IsValid( mdl ) then continue end

		mdl:Remove()
	end
end

function SWEP:ClearBladeModel()
	for _, tbl in pairs( self.BladeModelCL ) do
		if not tbl then continue end

		for _, mdl in pairs( tbl ) do
			if not IsValid( mdl ) then continue end
			mdl:Remove()
		end
	end
end

function SWEP:DrawWorldModel( flags )
end

function SWEP:DrawWorldModelUnequipped( ply )
	local Pos = self:GetPos() 
	local Ang = self:GetAngles()

	for handID, hiltObject in pairs( self:GetHiltData() ) do
		local WorldModel = self:GetWorldModel( handID )

		if not IsValid( WorldModel ) then continue end

		WorldModel:SetPos( Pos )
		WorldModel:SetAngles( Ang )
		WorldModel:SetupBones()
		WorldModel:DrawModel()
	end
end

function SWEP:DrawWorldModelTranslucent( flags, target )
	local ply = self:GetOwner()

	if not IsValid( ply ) then
		self:DrawWorldModelUnequipped( ply )

		return
	end

	if self:IsThrown() then
		if IsValid( target ) then
			ply = target
		else
			return
		end
	end

	local BladeID = 1
	local Mul = self:GetLength()

	for handID, hiltObject in pairs( self:GetHiltData() ) do
		local WorldModel = self:GetWorldModel( handID )

		if not IsValid( WorldModel ) then 
			self:RefreshWorldModel()

			continue
		end

		local data = hiltObject.info.ParentData[ self.HAND_STRING[ handID ] ]

		local offsetVec = data.pos
		local offsetAng = data.ang
		local boneid = ply:LookupBone( data.bone )

		if not boneid then continue end

		local matrix = ply:GetBoneMatrix( boneid )

		if not matrix then continue end

		local newPos, newAng = LocalToWorld(offsetVec, offsetAng, matrix:GetTranslation(), matrix:GetAngles())

		WorldModel:SetPos( newPos )
		WorldModel:SetAngles( newAng )
		WorldModel:SetupBones()
		WorldModel:DrawModel()

		if Mul <= 0 then continue end

		local Positions = hiltObject.info.GetBladePos( WorldModel )

		if not Positions then continue end

		local COMBO = self:GetCombo()

		for _, PosData in ipairs( Positions ) do
			local BladeData = self:GetBladeData( handID )

			if not IsValid( target ) then
				if (handID == 2 and not COMBO.LeftSaberActive) then continue end
			end

			if BladeData then
				self:DrawBlade( handID, BladeID, PosData, BladeData, Mul, newAng )
				if not BladeData.no_trail and not PosData.no_trail then
					self:CalcTrail( handID, BladeID, PosData, BladeData, Mul )
				end
			end

			BladeID = BladeID + 1
		end
	end
end

function SWEP:RefreshWorldModel()
	self._oldHiltR = nil
	self._oldHiltL = nil
	self._oldBladeR = nil
	self._oldBladeL = nil
end
--addons/aocrp_map/lua/weapons/weapon_nav_editor.lua:


AddCSLuaFile()

SWEP.PrintName				= "Navmesh Editing SWEP"
SWEP.Author					= "Bobblehead"
SWEP.Purpose				= "Edit Navmeshes the easy way."
SWEP.Instructions			= "Right click to select a tool. Left click to use the tool. REQUIRES SV_CHEATS 1."

SWEP.Slot					= 2
SWEP.SlotPos				= 1

SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true

SWEP.ViewModel				= Model( "models/weapons/v_toolgun.mdl" )
SWEP.WorldModel				= Model( "models/weapons/w_toolgun.mdl" )
SWEP.ViewModelFOV			= 54
SWEP.UseHands				= false

SWEP.DrawCrosshair			= false

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic		= false
SWEP.Primary.Ammo			= "none"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= false
SWEP.Secondary.Ammo			= "none"

SWEP.DrawAmmo				= false
SWEP.AdminOnly				= true

if SERVER then
	util.AddNetworkString("nav_editor_mode")
	net.Receive("nav_editor_mode", function(len,ply)
		local wep = ply:GetActiveWeapon()
		if IsValid(wep) and wep:GetClass() == "weapon_nav_editor" then
			local str = net.ReadString()
			if str == "generate" then
				RunConsoleCommand("nav_generate")
			else
				wep:SetMode(str)
				wep.Stage = 1
			end
		end
	end)
end


function SWEP:SetupDataTables()
	self:NetworkVar( "String", 0, "Mode" )
	self:NetworkVar( "Int", 0, "NavEdit" )
end

function SWEP:Initialize()
	
	
	self:SetHoldType( "pistol" )
	self:SetMode("")
	self.Changed = false
	self.Stage = 1
	self:SetNavEdit(GetConVarNumber("nav_edit"))
	self.LastReload = CurTime()
	
end

function SWEP:Deploy()
	self:SetNavEdit(GetConVarNumber("nav_edit"))
	RunConsoleCommand("nav_edit", 1)
	return true
end
function SWEP:Holster()
	RunConsoleCommand("nav_edit", self:GetNavEdit())
	return true
end

function SWEP:PrimaryAttack()
	if game.SinglePlayer() then
		self:CallOnClient("PrimaryAttack")
	end
	self:SetNextPrimaryFire( CurTime() + 0.1 )

	self:EmitSound( Sound("buttons/button16.wav") )
	-- self:EmitSound( Sound("ambient/water/drip"..math.random(1,4)..".wav") )
	self:ShootEffects( self )
	
	if SERVER then
		
		if not (GetConVarNumber("nav_edit") > 0) then self.Owner:PrintMessage(HUD_PRINTTALK,"This SWEP requires 'nav_edit 1'. Run 'nav_edit 1' in the server console to continue.") return end
		if not (GetConVarNumber("sv_cheats") > 0) then self.Owner:PrintMessage(HUD_PRINTTALK,"This SWEP requires 'sv_cheats 1'. Run 'sv_cheats 1' in the server console to continue.") return end
		
		local cmd = self:GetMode()
		
		if cmd == "delete" then
			RunConsoleCommand("nav_delete")
		elseif cmd == "create" then
			if self.Stage == 1 then
				RunConsoleCommand("nav_begin_area")
				self.Stage = 2
			else
				RunConsoleCommand("nav_end_area")
				self.Stage = 1
			end
		elseif cmd == "connect" then
			if self.Stage == 1 then
				RunConsoleCommand("nav_mark")
				self.Stage = 2
			else
				RunConsoleCommand("nav_connect")
				self.Stage = 1
			end
		elseif cmd == "disconnect" then
			if self.Stage == 1 then
				RunConsoleCommand("nav_mark")
				self.Stage = 2
			else
				RunConsoleCommand("nav_disconnect")
				self.Stage = 1
			end
		elseif cmd == "merge" then
			if self.Stage == 1 then
				RunConsoleCommand("nav_mark")
				self.Stage = 2
			else
				RunConsoleCommand("nav_merge")
				self.Stage = 1
			end
		elseif cmd == "splice" then
			if self.Stage == 1 then
				RunConsoleCommand("nav_mark")
				self.Stage = 2
			else
				RunConsoleCommand("nav_splice")
				self.Stage = 1
			end
		elseif cmd == "split" then
			RunConsoleCommand("nav_split")
		elseif cmd == "avoid" then
			RunConsoleCommand("nav_avoid")
		elseif cmd == "subdivide" then
			RunConsoleCommand("nav_subdivide")
		end
		
		
		self.Changed = true
		
	end
end

function SWEP:SecondaryAttack()
	if game.SinglePlayer() then
		self:CallOnClient("SecondaryAttack")
	end
	self:SetNextPrimaryFire( CurTime() + 0.1 )
	
	if CLIENT then
	
		local menu = vgui.Create("DFrame")
			-- menu:ParentToHUD()
			menu:SetSize(305,200)
			menu:Center()
			menu:SetTitle("Select Mode")
			menu:MakePopup()
			function menu.OnClose()
				if game.IsDedicated() then self.Owner:PrintMessage(HUD_PRINTTALK,"You should probably do your navmesh editing in singleplayer to avoid issues. :)") end
				self:EmitSound( Sound("ambient/water/drip"..math.random(1,4)..".wav") )
			end
		
		local List	= vgui.Create( "DIconLayout", menu )
			List:Dock(FILL)
			List:SetSpaceY( 5 ) //Sets the space in between the panels on the X Axis by 5
			List:SetSpaceX( 5 ) //Sets the space in between the panels on the Y Axis by 5

		local delete = List:Add( "DButton" ) //Add DPanel to the DIconLayout
			delete:SetSize( 95, 40 ) //Set the size of it
			delete:SetText("Delete Areas")
			function delete.DoClick(s)
				net.Start("nav_editor_mode")
					net.WriteString("delete")
				net.SendToServer()
				menu:Close()
			end
		
		local create = List:Add( "DButton" ) //Add DPanel to the DIconLayout
			create:SetSize( 95, 40 ) //Set the size of it
			create:SetText("Create Areas")
			function create.DoClick(s)
				net.Start("nav_editor_mode")
					net.WriteString("create")
				net.SendToServer()
				menu:Close()
			end
		
		local connect = List:Add( "DButton" ) //Add DPanel to the DIconLayout
			connect:SetSize( 95, 40 ) //Set the size of it
			connect:SetText("Connect Areas")
			function connect.DoClick(s)
				net.Start("nav_editor_mode")
					net.WriteString("connect")
				net.SendToServer()
				menu:Close()
			end
		
		local disconnect = List:Add( "DButton" ) //Add DPanel to the DIconLayout
			disconnect:SetSize( 95, 40 ) //Set the size of it
			disconnect:SetText("Disconnect Areas")
			function disconnect.DoClick(s)
				net.Start("nav_editor_mode")
					net.WriteString("disconnect")
				net.SendToServer()
				menu:Close()
			end
		
		local merge = List:Add( "DButton" ) //Add DPanel to the DIconLayout
			merge:SetSize( 95, 40 ) //Set the size of it
			merge:SetText("Merge Areas")
			function merge.DoClick(s)
				net.Start("nav_editor_mode")
					net.WriteString("merge")
				net.SendToServer()
				menu:Close()
			end
		
		local splice = List:Add( "DButton" ) //Add DPanel to the DIconLayout
			splice:SetSize( 95, 40 ) //Set the size of it
			splice:SetText("Splice Areas")
			function splice.DoClick(s)
				net.Start("nav_editor_mode")
					net.WriteString("splice")
				net.SendToServer()
				menu:Close()
			end
		
		local split = List:Add( "DButton" ) //Add DPanel to the DIconLayout
			split:SetSize( 95, 40 ) //Set the size of it
			split:SetText("Split Areas")
			function split.DoClick(s)
				net.Start("nav_editor_mode")
					net.WriteString("split")
				net.SendToServer()
				menu:Close()
			end
		
		local subdivide = List:Add( "DButton" ) //Add DPanel to the DIconLayout
			subdivide:SetSize( 95, 40 ) //Set the size of it
			subdivide:SetText("Subdivide Area")
			function subdivide.DoClick(s)
				net.Start("nav_editor_mode")
					net.WriteString("subdivide")
				net.SendToServer()
				menu:Close()
			end
		
		local avoid = List:Add( "DButton" ) //Add DPanel to the DIconLayout
			avoid:SetSize( 95, 40 ) //Set the size of it
			avoid:SetText("Mark as Avoid")
			function avoid.DoClick(s)
				net.Start("nav_editor_mode")
					net.WriteString("avoid")
				net.SendToServer()
				menu:Close()
			end
		
		local help = List:Add( "DButton" ) //Add DPanel to the DIconLayout
			help:SetSize( 145, 30 ) //Set the size of it
			help:SetText("Instructions")
			function help.DoClick(s)
				menu:Close()
				self:ShowHelp()
			end
			
		local generate = List:Add( "DButton" ) //Add DPanel to the DIconLayout
			generate:SetSize( 145, 30 ) //Set the size of it
			generate:SetText("Generate Navmesh")
			function generate.DoClick(s)
				Derma_Query("This will take a long time and reload the map. Are you sure?","Generate Navmesh","Generate",function()
					RunConsoleCommand("showconsole")
					net.Start("nav_editor_mode")
						net.WriteString("generate")
					net.SendToServer()
					menu:Close()
				end,
				"Cancel",
				function()
				end
				)
			end
		
		
	end
	
	
end

function SWEP:DrawHUD()
	draw.WordBox( 8, ScrW()/2 - 101, ScrH()-160, "Left click to run a command.", "ChatFont", Color(0,0,0,150), Color(255,255,255) )
	draw.WordBox( 8, ScrW()/2-115, ScrH()-129, "Right click to change commands.", "ChatFont", Color(0,0,0,150), Color(255,255,255) )
	draw.WordBox( 8, ScrW()/2-58, ScrH()-98, "Reload to save.", "ChatFont", Color(0,0,0,150), Color(255,255,255) )
	draw.WordBox( 8, ScrW()/2-85, ScrH()-67, "Requires 'sv_cheats 1'.", "ChatFont", Color(0,0,0,150), Color(255,255,255) )
end

function SWEP:ShowHelp()
	
	local menu = vgui.Create("DFrame")
		-- menu:ParentToHUD()
		menu:SetSize(600,400)
		menu:Center()
		menu:SetTitle("Navmesh Help")
		menu:MakePopup()
		function menu.OnClose()
			self:SecondaryAttack()
		end
	
	local lbl = vgui.Create("DLabel", menu)
		lbl:SetText("Loading...")
		lbl:SizeToContents()
		lbl:Center()
	
	local utube = vgui.Create("DHTML", menu)
		utube:Dock(FILL)
		utube:SetHTML([[<iframe width="573" height="350" src="https://www.youtube.com/embed/OB7gRmB-nGw" frameborder="0" allowfullscreen></iframe>]])
	
	
end

function SWEP:Reload()
	if IsFirstTimePredicted() then
		if self.LastReload < CurTime() - 2 then
			if CLIENT then
				RunConsoleCommand("showconsole")
			end
			if self.Changed then
				RunConsoleCommand("nav_analyze")
			else
				RunConsoleCommand("nav_save")
			end
			self.LastReload = CurTime()
		end
	end
end

if SERVER then
	hook.Add("InitPostEntity","nav_editing_0", function()
		RunConsoleCommand("nav_edit", 0)
	end)
end

--addons/weapon_jedi/lua/weapons/weapon_vibrosword.lua:
AddCSLuaFile()

SWEP.Base = "weapon_lscs"
DEFINE_BASECLASS( "weapon_lscs" )

SWEP.Category			= "[LSCS]"
SWEP.PrintName		= "Vibro Sword"
SWEP.Author			= "Blu-x92 / Luna"

SWEP.Slot				= 0
SWEP.SlotPos			= 2

SWEP.Spawnable		= false
SWEP.AdminOnly		= true

function SWEP:SetupDataTables()
	BaseClass.SetupDataTables( self )

	if SERVER then
		self:SetHiltR("vibrosword")
		self:SetBladeR("nanoparticles")
	end
end

--lua/weapons/wood_katana/shared.lua:
SWEP.Author       = "Killua"
SWEP.PrintName    = "Wood katana"
SWEP.Category     = "Gluk Melee"
SWEP.Contact      = "Type:Melee Class:Wood"
SWEP.Purpose      = ""
SWEP.Instructions = "LMB to attack, RBM to special attack"
 
SWEP.AdminSpawnable = true
SWEP.AutoSwitchTo   = false
SWEP.Spawnable      = true
SWEP.AutoSwitchFrom = false
SWEP.FiresUnderwater= false
SWEP.Weight         = 5
SWEP.DrawCrosshair  = true
SWEP.Slot           = 0
SWEP.SlotPos        = 1
SWEP.DrawAmmo		= false
SWEP.base           = "weapon_base"
SWEP.HoldType       = "melee2"

SWEP.UseHands = true
SWEP.ViewModelFOV   = 50
SWEP.ViewModel = "models/weapons/cstrike/c_knife_t.mdl"
SWEP.WorldModel = "models/weapons/w_knife_t.mdl"
SWEP.ViewModelFlip  = false
SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
	["ValveBiped.Bip01_L_Clavicle"] = { scale = Vector(1, 1, 1), pos = Vector(-23.519, 0, 0), angle = Angle(0, 0, 0) },
	["v_weapon.Knife_Handle"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_R_Forearm"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(50, 0, 0) },
	["ValveBiped.Bip01_R_Clavicle"] = { scale = Vector(1, 1, 1), pos = Vector(-8.334, 3.888, 5.741), angle = Angle(10, 0, 0) },
	["ValveBiped.Bip01_R_Hand"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0.925), angle = Angle(-47.778, 0, 0) }
}
SWEP.VElements = {
	["blade+"] = { type = "Model", model = "models/hunter/plates/plate1x1.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(-0.5, 0, 11), angle = Angle(175, 180, 90), size = Vector(0.029, 0.2, 0.029), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/fender_wood", skin = 0, bodygroup = {} },
	["hils+"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, -0.101), angle = Angle(0, 90, 0), size = Vector(0.029, 0.039, 0.029), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/fender_wood", skin = 0, bodygroup = {} },
	["hils"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "v_weapon.Knife_Handle", rel = "", pos = Vector(0, 0, -0.7), angle = Angle(0, -45, 0), size = Vector(0.05, 0.039, 0.109), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/fender_wood", skin = 0, bodygroup = {} },
	["hils+++"] = { type = "Model", model = "models/maxofs2d/button_05.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, 4.9), angle = Angle(0, 180, 0), size = Vector(0.15, 0.15, 0.3), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/fender_wood", skin = 0, bodygroup = {} },
	["blade"] = { type = "Model", model = "models/hunter/blocks/cube1x1x1.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(-0.601, 0, 9), angle = Angle(0, 90, -5), size = Vector(0.009, 0.019, 0.1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/fender_wood", skin = 0, bodygroup = {} },
	["blade++"] = { type = "Model", model = "models/hunter/plates/plate1x1.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(-1.8, 0, 19), angle = Angle(165, 180, 90), size = Vector(0.029, 0.15, 0.029), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/fender_wood", skin = 0, bodygroup = {} }
}
SWEP.WElements = {
	["hils+"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, -0.101), angle = Angle(0, 90, 0), size = Vector(0.029, 0.039, 0.029), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/fender_wood", skin = 0, bodygroup = {} },
	["blade++"] = { type = "Model", model = "models/hunter/plates/plate1x1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(-1.8, 0, 19), angle = Angle(165, 180, 90), size = Vector(0.029, 0.15, 0.029), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/fender_wood", skin = 0, bodygroup = {} },
	["blade"] = { type = "Model", model = "models/hunter/blocks/cube1x1x1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(-0.601, 0, 9), angle = Angle(0, 90, -5), size = Vector(0.009, 0.019, 0.1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/fender_wood", skin = 0, bodygroup = {} },
	["blade+"] = { type = "Model", model = "models/hunter/plates/plate1x1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(-0.5, 0, 11), angle = Angle(175, 180, 90), size = Vector(0.029, 0.2, 0.029), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/fender_wood", skin = 0, bodygroup = {} },
	["hils"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3, 1, 2.5), angle = Angle(-170, 50, 8), size = Vector(0.05, 0.039, 0.109), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/fender_wood", skin = 0, bodygroup = {} },
	["hils+++"] = { type = "Model", model = "models/maxofs2d/button_05.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, 4.9), angle = Angle(0, 180, 0), size = Vector(0.15, 0.15, 0.3), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/fender_wood", skin = 0, bodygroup = {} }
}



SWEP.BobScale = 1
SWEP.SwayScale = 0

SWEP.Idle = 0
SWEP.IdleTimer = CurTime()

SWEP.Primary.ClipSize 	 = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic   = true
SWEP.Primary.Ammo 		 = "none"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

SWEP.Primary.Damage 	 = 2
SWEP.Primary.DelayMiss	 = 1
SWEP.Primary.DelayHit 	 = 0.26
SWEP.Primary.Force 		 = 1
SWEP.Primary.ImpactDecal = "ManhackCut"
SWEP.Primary.Range       = 16

SWEP.Secondary.Life        = true
SWEP.Secondary.Damage 	   = 60
SWEP.Secondary.DelayMiss   = 1.5
SWEP.Secondary.DelayHit	   = 0.7
SWEP.Secondary.Force	   = 5
SWEP.Secondary.ImpactDecal = "Impact.Metal"
SWEP.Secondary.Range       = 18

local SwingSound = Sound( "WeaponFrag.Roll" )
local HitSoundWorld = Sound( "GlassBottle.ImpactHard" )
local HitSoundBody = Sound( "Flesh_Bloody.ImpactHard" )
local HitSoundProp = Sound( "" )
local indec = 0

SWEP.indec = 0

function SWEP:Initialize()
self:SetWeaponHoldType( self.HoldType )
self.Idle = 0
self.IdleTimer = CurTime() + 1
end

function SWEP:Deploy()
self:SetWeaponHoldType( self.HoldType )
self.Weapon:SendWeaponAnim( ACT_VM_DRAW )
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
return true
end

function SWEP:Holster()
self.Idle = 0
self.IdleTimer = CurTime()
self.indec = 0
return true
end

function SWEP:PrimaryAttack()
self:SetHoldType( self.HoldType )
self:EmitSound( SwingSound )
local bullet = {}
bullet.Num = 1
bullet.Src = self.Owner:GetShootPos()
bullet.Dir = self.Owner:GetAimVector()
bullet.Distance = self.Primary.Distance
bullet.Spread = Vector( 0, 0, 0 )
bullet.Tracer = 0
bullet.Force = self.Primary.Force
bullet.Damage = 0
bullet.AmmoType = "none"

local tr = util.TraceLine( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Primary.Range*4,
filter = self.Owner,
mask = MASK_SHOT_HULL,
} )
if ( tr.Hit ) then
util.Decal(self.Primary.ImpactDecal, tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)  
end
if !IsValid( tr.Entity ) then
tr = util.TraceHull( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Primary.Range*4,
filter = self.Owner,
mins = Vector( -1* self.Primary.Range, -1*self.Primary.Range, 0 ),
maxs = Vector(  1* self.Primary.Range,  1*self.Primary.Range, 0 ),
mask = MASK_SHOT_HULL,
} )
end
if SERVER then
if IsValid( tr.Entity ) then
local dmg = DamageInfo()
local attacker = self.Owner
if !IsValid( attacker ) then
attacker = self
end
dmg:SetAttacker( attacker )
dmg:SetInflictor( self )
dmg:SetDamage( self.Primary.Damage )
dmg:SetDamageForce( self.Owner:GetForward() * self.Primary.Force )
tr.Entity:TakeDamageInfo( dmg )
end
if ( tr.Hit ) then
		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") or string.find(tr.Entity:GetClass(),"prop_physics") then
		if string.find(tr.Entity:GetClass(),"prop_physics") then
		self:EmitSound( HitSoundProp )
		else
		self:EmitSound( HitSoundBody )
		if self.indec < 11 then
		self.indec = self.indec + 1
		
		end
		end
		self.Owner:FireBullets(bullet)	
		else
		self:EmitSound( HitSoundWorld )
		end
		end
end
if !tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_PRIMARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayMiss )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayMiss )
end
if tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_MISSCENTER )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayHit )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayHit )
end
self:ShootEffects()
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end


function SWEP:SecondaryAttack()
self:SetHoldType( self.HoldType )
self:EmitSound( SwingSound )
local bullet = {}
bullet.Num = 1
bullet.Src = self.Owner:GetShootPos()
bullet.Dir = self.Owner:GetAimVector()
bullet.Distance = self.Secondary.Distance
bullet.Spread = Vector( 0, 0, 0 )
bullet.Tracer = 0
bullet.Force = self.Secondary.Force
bullet.Damage = 0
bullet.AmmoType = "none"

local tr = util.TraceLine( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Secondary.Range*4,
filter = self.Owner,
mask = MASK_SHOT_HULL,
} )
if ( tr.Hit ) then
util.Decal(self.Secondary.ImpactDecal, tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)  
end
if !IsValid( tr.Entity ) then
tr = util.TraceHull( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Secondary.Range*4,
filter = self.Owner,
mins = Vector( -16, -16, 0 ),
maxs = Vector( 16, 16, 0 ),
mask = MASK_SHOT_HULL,
} )
end
if SERVER then
if IsValid( tr.Entity ) then
local dmg = DamageInfo()
local attacker = self.Owner
if !IsValid( attacker ) then
attacker = self
end
dmg:SetAttacker( attacker )
dmg:SetInflictor( self )
dmg:SetDamage( self.Secondary.Damage )
dmg:SetDamageForce( self.Owner:GetForward() * self.Secondary.Force )
tr.Entity:TakeDamageInfo( dmg )
end
if ( tr.Hit ) then
		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") or string.find(tr.Entity:GetClass(),"prop_physics") then
		if string.find(tr.Entity:GetClass(),"prop_physics") then
		self:EmitSound( HitSoundProp )
		else
		self:EmitSound( HitSoundBody )
		if self.indec < 11 then
		self.indec = self.indec + 1
		end
		end
		self.Owner:FireBullets(bullet)	
		else
		self:EmitSound( HitSoundWorld )
		end
		end
end
if !tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_SECONDARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Secondary.DelayMiss )
self:SetNextSecondaryFire( CurTime() + self.Secondary.DelayMiss )
end
if tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_SECONDARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Secondary.DelayHit )
self:SetNextSecondaryFire( CurTime() + self.Secondary.DelayHit )
end
self:ShootEffects()
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end

function SWEP:ShootEffects()
self.Owner:SetAnimation( PLAYER_ATTACK1 )
end

function SWEP:Reload()
end

function SWEP:Think()
if self.IdleTimer <= CurTime() then
if self.Idle == 0 then
self.Idle = 1
end
if SERVER and self.Idle == 1 then
self.Weapon:SendWeaponAnim( ACT_VM_IDLE )
end
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end
end


/********************************************************
	SWEP Construction Kit base code
		Created by Clavus
	Available for public use, thread at:
	   facepunch.com/threads/1032378
	   
	   
	DESCRIPTION:
		This script is meant for experienced scripters 
		that KNOW WHAT THEY ARE DOING. Don't come to me 
		with basic Lua questions.
		
		Just copy into your SWEP or SWEP base of choice
		and merge with your own code.
		
		The SWEP.VElements, SWEP.WElements and
		SWEP.ViewModelBoneMods tables are all optional
		and only have to be visible to the client.
********************************************************/

function SWEP:Initialize()

	// other initialize code goes here

	if CLIENT then
		
		self:SetWeaponHoldType( self.HoldType )	
		// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		// init view model bone build function
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				--[[// Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end]]--
			end
		end
		
	end

end

function SWEP:Holster()
	
	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	
	return true
end

function SWEP:OnRemove()
	self:Holster()
end

if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			// we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			// when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			// !! WORKAROUND !! //
			// We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			// !! ----------- !! //
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				// !! WORKAROUND !! //
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				// !! ----------- !! //
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

	/**************************
		Global utility code
	**************************/

	// Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	// Does not copy entities of course, only copies their reference.
	// WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end


--gamemodes/starwarsrp/entities/entities/aoc_ausbildung_tafel.lua:
AddCSLuaFile()

ENT.Type = "anim"
ENT.Base = "base_anim"
 
ENT.PrintName = "Ausbildungstafel"
ENT.Category = "AOCRP"
ENT.Spawnable = true

function ENT:SetupDataTables()
	self:NetworkVar("Float", 0, "Page")
	self:NetworkVar("Float", 1, "Max")
	
	--[[CONFIG]]--

	--[[change max pages here]]--
	--[[You would do this if you plan on adding more pages with information or removing unnesscary pages]]--
	self:SetPage(1)
	self:SetMax(12) 

	--[[true = Republic | false = Imperial]]--
	self.era = true 

	--[[Header Color and Background Color]]--
	self.hcolor = Color(25, 1, 2448, 0)
	self.bcolor = Color(0, 0, 0, 0)
	--[[Header Text Color and Text Color]]--
	self.htextcolor = Color(255, 255, 255)
	self.textcolor = Color(255, 255, 255)
	--[[Rounded Box and Text inside on bottom of panel]]--
	self.boxcolor = Color(191, 0, 0)
	self.boxtextcolor = Color(255, 255, 255)
	--[[Page changing hint text color and page number color]]--
	self.hinttext = Color(255, 255, 255)
	self.pagenum = Color(255, 255, 255)
	--[[Changes the shade of the arrows when hovered over]]--
	self.pcolor = Color(255, 220, 50, 220)
end


if SERVER then
    function math.inrange(val, min, max)
        return val <= max and val >= min
    end

    function ENT:Initialize()
        self:SetModel("models/hunter/plates/plate3x5.mdl")
        self:PhysicsInit(SOLID_VPHYSICS)
        self:SetMoveType(MOVETYPE_VPHYSICS)
        self:SetSolid(SOLID_VPHYSICS)
        self:SetUseType(SIMPLE_USE)

        self:SetMaterial("models/debug/debugwhite")
        self:SetColor(Color(50, 50, 50))
    
        local phys = self:GetPhysicsObject()
        
        if IsValid(phys) then
            phys:EnableMotion(false)
        end
    end

    local size = -950 / 2

    function ENT:Use(caller)
        local trace = caller:GetEyeTrace()
        if not trace.Entity == self then return end

        local cursor = self:WorldToLocal(trace.HitPos) * Vector(10, 10, 10)

        if math.inrange(cursor.y, -size - 64 - 64, -size) and math.inrange(cursor.x, -size - 64 - 64, -size) then 
            if self:GetPage() >= self:GetMax() then return end

            self:SetPage(self:GetPage() + 1)
            self:EmitSound("buttons/blip1.wav")
        end

        if math.inrange(cursor.y, size , size + 64 + 64) and math.inrange(cursor.x, -size - 64 - 64, -size) then 
            if self:GetPage() <= 1 then return end

            self:SetPage(self:GetPage() - 1)
            self:EmitSound("buttons/blip1.wav")
        end
    end
end


if CLIENT then


    local size = -950 / 2

    function math.inrange(val, min, max)
        return val <= max and val >= min
    end

    local arrow_icon = Material("materials/shared/arrow.png")
    local replogo_icon = Material("materials/shared/replogo.png")
    local aoc_icon = Material("shared/aoclogo.png")
    local aoc_medic = Material("shared/MEDICNEU.png")
    local squad = Material("shared/Squadsystem.png")
    local grundlage = Material("shared/RPGRUNDLAGEN.png")
    local name = Material("shared/NAMENSGEBUNG.png")
    local passivrp = Material("shared/PASSIVRPNEU.png")
    local chat = Material("shared/CHATNEU.png")
    local keybinds = Material("shared/KEYBINDSNEU.png")
    local funk1 = Material("shared/funkcode1.png")
    local funk2 = Material("shared/funkcode2.png")
    local gesichter = Material("shared/gesichter.png")
    local formationen = Material("shared/formation.png")
    local regel1 = Material("shared/regel1.png")
    local regel2 = Material("shared/regel2.png")
    local autorisierung = Material("shared/autorisierung.png")
    local defcon = Material("shared/defcon.png")
    local rangstruktur = Material("shared/RANGSTRUKTURNEU.png")

    surface.CreateFont("FORMATION:Main", {
        font = "Roboto",
        size = 50
    })

    surface.CreateFont("FORMATION:Title", {
        font = "Roboto",
        size = 80
    })

    function ENT:Initialize()
        self.x = 0
        self.lx = 0
        self.t = 0

        self.min = 0
        self.max = 0

        self.tpage = self:GetPage()

        self:Work()
    end

    function ENT:Work()
        self.t = !self.t

        if self.t then 
            self.x = self.min
        else
            self.x = self.max
        end

        timer.Simple(1, function()
            if not IsValid(self) then return end
            self:Work()
        end)
    end

    function ENT:OnPage()
        if self.tpage == 3 then 
            self.x = -25
            self.lx = -25
            return
        end
        
        self.x = 0
        self.lx = 0
    end

    function ENT:Think()
        if self:GetPage() != self.tpage then 
            self.tpage = self:GetPage()

            self:OnPage()
        end
    end

    function ENT:Page(number)
    if number == 1 then 
            
            if self.era == true then
            surface.SetDrawColor(Color(255, 255, 255))
            surface.SetMaterial(grundlage)
            surface.DrawTexturedRectRotated(size + 475, -size - 480, 2400, 1200, 0)
            elseif self.era == false then

            end
            
            end
            
        if number == 2 then 
            surface.SetDrawColor(Color(255, 255, 255))
            surface.SetMaterial(name)
            surface.DrawTexturedRectRotated(size + 475, -size - 480, 2400, 1200, 0)
            elseif self.era == false then
        end
        if number == 3 then 
            surface.SetDrawColor(Color(255, 255, 255))
            surface.SetMaterial(passivrp)
            surface.DrawTexturedRectRotated(size + 475, -size - 480, 2400, 1200, 0)
            elseif self.era == false then
        end
        if number == 4 then 
            surface.SetDrawColor(Color(255, 255, 255))
            surface.SetMaterial(aoc_medic)
            surface.DrawTexturedRectRotated(size + 475, -size - 480, 2400, 1200, 0)
            elseif self.era == false then
        end
        if number == 5 then 
            surface.SetDrawColor(Color(255, 255, 255))
            surface.SetMaterial(chat)
            surface.DrawTexturedRectRotated(size + 475, -size - 480, 2400, 1200, 0)
            elseif self.era == false then
        end
        if number == 6 then 
            surface.SetDrawColor(Color(255, 255, 255))
            surface.SetMaterial(keybinds)
            surface.DrawTexturedRectRotated(size + 475, -size - 480, 2400, 1200, 0)
            elseif self.era == false then
        end
        --[[if number == 7 then 
            surface.SetDrawColor(Color(255, 255, 255))
            surface.SetMaterial(aoc_icon)
            surface.DrawTexturedRectRotated(size + 475, -size - 580, 2400, 1200, 0)
            elseif self.era == false then
        end]]
        if number == 7 then 
            surface.SetDrawColor(Color(255, 255, 255))
            surface.SetMaterial(funk1)
            surface.DrawTexturedRectRotated(size + 475, -size - 480, 2400, 1200, 0)
            elseif self.era == false then
        end
        if number == 8 then 
            surface.SetDrawColor(Color(255, 255, 255))
            surface.SetMaterial(funk2)
            surface.DrawTexturedRectRotated(size + 475, -size - 480, 2400, 1200, 0)
            elseif self.era == false then
        end
        --[[if number == 10 then 
            surface.SetDrawColor(Color(255, 255, 255))
            surface.SetMaterial(gesichter)
            surface.DrawTexturedRectRotated(size + 475, -size - 480, 2400, 1200, 0)
            elseif self.era == false then
        end]]
        --[[if number == 11 then 
            surface.SetDrawColor(Color(255, 255, 255))
            surface.SetMaterial(formationen)
            surface.DrawTexturedRectRotated(size + 475, -size - 580, 1800, 1000, 0)
            elseif self.era == false then
        end]]
        if number == 9 then 
            surface.SetDrawColor(Color(255, 255, 255))
            surface.SetMaterial(regel1)
            surface.DrawTexturedRectRotated(size + -260, -size - 480, 1700, 900, 0)
            elseif self.era == false then
        end
        if number == 10 then 
            surface.SetDrawColor(Color(255, 255, 255))
            surface.SetMaterial(regel2)
            surface.DrawTexturedRectRotated(size + 890, -size - 480, 1700, 900, 0)
            elseif self.era == false then
        end
        if number == 11 then 
            surface.SetDrawColor(Color(255, 255, 255))
            surface.SetMaterial(autorisierung)
            surface.DrawTexturedRectRotated(size + 475, -size - 490, 1700, 920, 0)
            elseif self.era == false then
        end
        --[[if number == 14 then 
            surface.SetDrawColor(Color(255, 255, 255))
            surface.SetMaterial(defcon)
            surface.DrawTexturedRectRotated(size + 475, -size - 490, 1700, 920, 0)
            elseif self.era == false then
        end]]
        if number == 12 then 
            surface.SetDrawColor(Color(255, 255, 255))
            surface.SetMaterial(rangstruktur)
            surface.DrawTexturedRectRotated(size + 475, -size - 580, 1800, 1000, 0)
            elseif self.era == false then
        end
        end


    function ENT:Draw()
        self:DrawModel()

        local trace = LocalPlayer():GetEyeTrace()
        if not trace.Entity == self then return end

        local cursor = self:WorldToLocal(trace.HitPos) * Vector(10, 10, 10)

        local pos = self:LocalToWorld(Vector(0, 0, 2.5))
        local ang = self:LocalToWorldAngles(Angle(0, 90, 0))
        --[[Change the distance at which clients will render the panel]]--
        if LocalPlayer():GetPos():Distance(self:GetPos()) >= 500 then return end 

        cam.Start3D2D(pos, ang, 0.1)
            draw.RoundedBox(0, -2370 / 2, -1420 / 2, 2370, 100, self.hcolor)
            draw.RoundedBox(0, -2370 / 2, -1240 / 2, 2370, 1330, self.bcolor)
            --[[---------------------------------------------------------
                Name: Arrows
            -----------------------------------------------------------]]
            if math.inrange(cursor.y, -size - 64 - 64, -size) and math.inrange(cursor.x, -size - 64 - 64, -size) then 
                surface.SetDrawColor(self.pcolor)
            else
                surface.SetDrawColor(Color(255, 255, 255))
            end
            
            surface.SetMaterial(arrow_icon)
            surface.DrawTexturedRectRotated(-size - 64, -size - 20, 64, 64, 180)

            if math.inrange(cursor.y, size , size + 64 + 64) and math.inrange(cursor.x, -size - 64 - 64, -size) then 
                surface.SetDrawColor(self.pcolor)
            else
                surface.SetDrawColor(Color(255, 255, 255))
            end
            
            surface.SetMaterial(arrow_icon)
            surface.DrawTexturedRectRotated(size + 64, -size - 20, 64, 64, 0)

            draw.SimpleText("Seite ".. self:GetPage().. " von 12", "FORMATION:Main", 0, -size - 20, self.pagenum, 1, 1)

            self:Page(self:GetPage())
            
              surface.SetDrawColor(Color(255, 255, 255))
            surface.SetMaterial(aoc_icon)
            surface.DrawTexturedRectRotated(size + -550, -size - 1105, 300, 300, 0)          

        cam.End3D2D()
        

        
    end 
end
--gamemodes/starwarsrp/entities/entities/aoc_keypad.lua:
AddCSLuaFile()

ENT.Type = "anim"
ENT.Base = "base_anim"

ENT.PrintName		= "Keypad"
ENT.Author			= "Lt. Sammy"
ENT.Contact			= ""
ENT.Purpose			= ""
ENT.Instructions	= ""
ENT.Category        = "AOCRP"
ENT.Spawnable       = true
ENT.AOCRPInteract = true

ENT.Editable = true 



function ENT:SetupDataTables()


    local editTbl = {}

    for k, v in pairs(AOCRP.Config.Sicherheitslevel) do
        editTbl[v.name] = k
    end
    
	self:NetworkVar( "Int", 0, "Sicherheitslevel", { KeyName = "sicherheitslevel",	Edit = { type = "Combo", order = 1, text = "", values=editTbl} } ) 
    self:NetworkVar( "Int", 1, "KeypadState" ) 
	self:NetworkVar( "String", 0, "KeypadName", { KeyName = "keypadname",	Edit = { type = "String" } } ) 
    self:NetworkVar( "Bool", 0, "KeypadToggle", { KeyName = "keypadtoggle",	Edit = { type = "Boolean" } } ) 
    self:SetKeypadState(1)
 
end

function ENT:isAllowed(ply, sleveldata)

    if ply:GetRankID() >= sleveldata.rank then
        return true
    end
    if table.HasValue(sleveldata.units, ply:GetUnitID()) then 
        return true 
    end
    if ply == GetGlobalNetVar( "AOCRP.COMMANDINGOFFICER", nil) then 
        return true
    end 
    return false
end 

if SERVER then
        
    local function findEntByPPID(ppid)
        for k, v in ipairs(ents.GetAll()) do
            if v.PermaProps_ID then
                if v.PermaProps_ID == ppid then
                    return v
                end
            end
        end
    end

    function ENT:SetDoorStatus(open)

        if !self.selectedDoors then return end 
            for k, v in ipairs(self.selectedDoors) do


                if string.StartsWith(v, "PP") then 
                    local ppid = tonumber(string.sub(v, 3))
                    local ent = findEntByPPID(ppid)

                    if !IsValid(ent) then return end 

                    local color = ent:GetColor()
                    if open then 
                        ent:SetRenderMode(RENDERMODE_TRANSALPHA) -- Set render mode to allow transparency
                        ent:SetColor(Color(color.r, color.g, color.b, 0)) -- Set alpha to 0 (fully transparent)
                        ent:SetCollisionGroup(COLLISION_GROUP_WORLD)
                    else 
                        --ent:SetRenderMode(RENDERMODE_NORMAL) -- Set render mode to allow transparency
                        ent:SetColor(Color(color.r, color.g, color.b, 255)) -- Set alpha to 0 (fully transparent)
                        ent:SetCollisionGroup(COLLISION_GROUP_PLAYER)
                    end

                    return
                end

                local door = ents.GetMapCreatedEntity(v)

                if !IsValid(door) then return end

                door.IsKeypadControlled = true 

                if open then 

                    door:Fire("unlock")
                    door:Fire("open")

                else 

                    door:Fire("lock")
                    door:Fire("close")

                end

            end

    end 

    function ENT:Initialize()


        self:SetUseType(SIMPLE_USE)
        self:DropToFloor()
        self:SetModel("models/kingpommes/starwars/misc/imp_wallpanel.mdl")
        self:PhysicsInit(SOLID_VPHYSICS)
        self:SetMoveType(MOVETYPE_NONE)
        self:SetSolid(SOLID_VPHYSICS)
    
        local phys = self:GetPhysicsObject()
    
        if phys:IsValid() then
            phys:Wake()
            phys:EnableMotion(false)
        end

        self:SetDoorStatus(false)
        self:SetKeypadState(1)
    end

    ENT.LastUse = 0

    ENT.Log = {}


    local function getCurrentTime()
        local time = os.date("*t")
        local hour = string.format("%02d", time.hour)
        local min = string.format("%02d", time.min)
        local sec = string.format("%02d", time.sec)
        return hour .. ":" .. min .. ":" .. sec
    end
    
    function ENT:WriteLog(text)

        table.insert(self.Log, "["..getCurrentTime().."] - ".. text)
    end

    ENT.HackProgress = 0
    function ENT:Hack()

        if self.HackProgress <= 0 then 
            self:WriteLog("ALARM AUSGELST, HACK ERKANNT")
            self:EmitSound("ambient/alarms/scanner_alert_pass1.wav")
            self:SetKeypadState(4)
        end 

        if self.HackProgress >= 100 then 
            self:SetDoorStatus(true)
            self:EmitSound("buttons/button9.wav")
            self:WriteLog("Tr durch Hack geffnet")
            self.HackProgress = 0
        end 

        self.HackProgress = self.HackProgress + 2

        self:EmitSound("ambient/energy/spark"..math.random(6)..".wav")
    end

    function ENT:Use( activator, caller )


        if self.LastUse > CurTime() then return end 

        self.LastUse = CurTime()+6

        if !self:isAllowed(activator, AOCRP.Config.Sicherheitslevel[self:GetSicherheitslevel()]) then 
            self:EmitSound("buttons/button8.wav")
            self:SetKeypadState(2)
            self:WriteLog( activator:Nick() .. " # Zugriff verweigert")
            return 
        end

        self.HackProgress = 0
        self:EmitSound("buttons/button9.wav")

        if self:GetKeypadState() == 3 then
            self:SetDoorStatus(false)
            self:SetKeypadState(1)
            self:SetSkin(0) 
           
            self:WriteLog( activator:Nick() .. " # Zugriff erteilt, Tr geschlossen")
            return
        end


            self:SetDoorStatus(true)
            self:SetKeypadState(3)
            self:SetSkin(1)
            self:WriteLog( activator:Nick() .. " # Zugriff erteilt, Tr geffnet")

            timer.Create(self:EntIndex().."_DoorTimer", 5, 1, function()

                if !self:GetKeypadToggle() then 
                    self:SetKeypadState(1)
                    self:SetSkin(0) 
                    self:SetDoorStatus(false)
                end
            end) 
  
    end


end

--[[ AOCRP.Config.Sicherheitslevel = {}
AOCRP.Config.Sicherheitslevel[0] = { name = "Echo", color = Color(0,255,0), text = "E", rank = 2, units = {}, gears = {}}
AOCRP.Config.Sicherheitslevel[1] = { name = "Delta", color = Color(255,255,0), text = "D", rank = 14, units = {6,4,8,9}} 
AOCRP.Config.Sicherheitslevel[2] = { name = "Charlie", color = Color(255,100,0), text = "C", rank = 10, units = {6,4,8,9}}
AOCRP.Config.Sicherheitslevel[3] = { name = "Bravo", color = Color(255,0,0), text = "B", rank = 14, units = {6,4,8,9}}
AOCRP.Config.Sicherheitslevel[4] = { name = "Alpha", color = Color(255,0,255), text = "A", rank = 16, units = {6,4,8,9}}
AOCRP.Config.Sicherheitslevel[5] = { name = "Gefngnis", color = Color(255,0,255), text = "G", rank = 14, units = {6,4,8,9}}

 ]]
if CLIENT then
    

    local stateToText = {}
    stateToText[1] = {text = "Erwarte ID-Chip", color = Color(252,180,9,255)}
    stateToText[2] = {text = "Zugriff verweigert", color = Color(255,0,0,255)}
    stateToText[3] = {text = "Tr geffnet", color = Color(0,255,0)}
    stateToText[4] = {text = "KRITTISCHER FEHLER", color = Color(255,0,0)}

    surface.CreateFont( "AOCRP_KeypadStatus", {font = "Agency FB",size = 60,weight = 1000} )
    surface.CreateFont( "AOCRP_KeypadLevel", {font = "Aurebesh",size = 50,weight = 100} )

    local controlDots = {}
    
    local color_Red = Color(0,0,0)
    local color_Gold = Color(252,180,9,255)
    local color_Positive =  Color(66, 134, 50)

    local distance = 6
    
    function ENT:Draw()
        self:DrawModel()
    
        local pos = self:LocalToWorld(Vector(0.55,0, 0))
        local ang = self:LocalToWorldAngles(Angle(0, 90, 90))
        local clearance = AOCRP.Config.Sicherheitslevel[self:GetSicherheitslevel()]
        
        controlDots[self] = controlDots[self] or {}
    
        if !controlDots[self].lastTime or controlDots[self].lastTime <= CurTime() then
            controlDots[self].lastTime = CurTime() + 0.5
            controlDots[self].dots = controlDots[self].dots or ""
    
            if controlDots[self].dots == "..." then
                controlDots[self].dots = ""
            else
                controlDots[self].dots = controlDots[self].dots.."."
            end
        end
    
        if self:GetPos():DistToSqr(LocalPlayer():GetPos()) < (distance ^ distance) then
            cam.Start3D2D(pos, ang, 0.025)

                        draw.RoundedBox(0,-183,-298,364,115, Color(27,27,27))

                        if self:GetKeypadName() != "" and self:GetKeypadState() == 1 then 
                            draw.SimpleText(self:GetKeypadName(), "AOCRP_KeypadStatus", 0, -270, color_Gold, TEXT_ALIGN_CENTER)
                        else 
                            draw.SimpleText(stateToText[self:GetKeypadState()].text, "AOCRP_KeypadStatus", 0, -275, stateToText[self:GetKeypadState()].color, TEXT_ALIGN_CENTER)
                        end
    
                draw.SimpleText(clearance.text, "AOCRP_KeypadLevel", 100, -150, clearance.color, TEXT_ALIGN_CENTER)
    
            cam.End3D2D()
        end
    end


end
--gamemodes/starwarsrp/entities/entities/aoc_textscreen.lua:
AddCSLuaFile()

ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.Category = "AOCRP"
ENT.PrintName = "Textscreen"
ENT.Author = "Lt. Sammy"
ENT.Spawnable = true
ENT.RenderGroup = RENDERGROUP_TRANSLUCENT
ENT.Editable = true

function ENT:SetupDataTables()


    self:NetworkVar("String", "ScreenText", { KeyName = "screentext",	Edit = { type = "Generic",	order = 1 } } )
    self:NetworkVar("Float",  "ScreenScale", { KeyName = "screenscale",	Edit = { type = "Float",	order = 1, min = 0.0001, max = 1} } )
    self:NetworkVar( "Vector", "ScreenTextColor",	{ KeyName = "screentextcolor",	Edit = { type = "VectorColor",	order = 4 } } )

    if SERVER then 
        self:SetScreenScale(0.1)
    end
end

if SERVER then

    
    function ENT:Initialize()
        self:SetRenderMode(RENDERMODE_TRANSALPHA)
        self:DrawShadow(false)
        self:SetModel("models/hunter/plates/plate1x1.mdl")
       self:SetMaterial("models/effects/vol_light001")
        self:SetSolid(SOLID_VPHYSICS)
        self:SetCollisionGroup(COLLISION_GROUP_WORLD)
        self:PhysicsInit(SOLID_VPHYSICS)
        self:SetMoveType(MOVETYPE_VPHYSICS)
        local phys = self:GetPhysicsObject()
        if IsValid(phys) then
            phys:EnableMotion(false)
        end
        self.heldby = 0
    end

    function ENT:PhysicsUpdate(phys)
        if self.heldby <= 0 then
            phys:Sleep()
        end
    end

    local function textScreenPickup(ply, ent)
        if IsValid(ent) and ent:GetClass() == "aoc_textscreen" then
            ent.heldby = ent.heldby + 1
        end
    end
    hook.Add("PhysgunPickup", "AOCRPSLSSPreventTravelPickup", textScreenPickup)

    local function textScreenDrop(ply, ent)
        if IsValid(ent) and ent:GetClass() == "aoc_textscreen" then
            ent.heldby = ent.heldby - 1
            local phys = ent:GetPhysicsObject()
            if IsValid(phys) then
                ent:PhysicsUpdate(phys)
            end
        end
    end
    hook.Add("PhysgunDrop", "AOCRPSLSSPreventTravelDrop", textScreenDrop)

end

if CLIENT then
    function ENT:Initialize()
        self:SetMaterial("models/effects/vol_light001")
        self:SetRenderMode(RENDERMODE_NONE)
    end


--[[     PIXEL.RegisterFont("AOCRP.Sicherheitslevel.Title", "Agency FB", 60, 10)
    PIXEL.RegisterFont("AOCRP.Sicherheitslevel.Text", "DermaLarge", 40, 1000)
    PIXEL.RegisterFont("AOCRP.Sicherheitslevel.Level", "Aurebesh", 60, 1)
 ]]
    surface.CreateFont( "AOCRP_Textscreen", {font = "DermaLarge",size = 200,weight = 1000} )

    local plyShootPos, ang, pos, camangle




    function ENT:DrawTranslucent()
		ang = self:GetAngles()
		pos = self:GetPos()


        if LocalPlayer():GetPos():DistToSqr(pos) > 7^7 then return end 


        local scale = 0.1


        if self:GetScreenScale() > 0 then
            scale = self:GetScreenScale()
        end

        local color = self:GetScreenTextColor():ToColor()
 
        local text = "FICK BEN"
        if self:GetScreenText() != "" then
            text = self:GetScreenText()
        end      

		cam.Start3D2D(pos, ang, scale )

                draw.DrawText(text,"AOCRP_Textscreen", 0,0, color,TEXT_ALIGN_CENTER)

		cam.End3D2D()
        camangle = Angle(ang.p, ang.y, ang.r)
        newAng = camangle:RotateAroundAxis(camangle:Right(), 180)
		cam.Start3D2D(pos, camangle, scale )

            draw.DrawText(text,"AOCRP_Textscreen", 0,0, color,TEXT_ALIGN_CENTER)

		cam.End3D2D()
    end

end
--gamemodes/starwarsrp/entities/entities/aoc_training.lua:
AddCSLuaFile()


ENT.Type = "anim"
ENT.Base = "base_anim"

ENT.PrintName		= "Trainingsbox"
ENT.Author			= "Lt. Sammy"
ENT.Contact			= ""
ENT.Purpose			= ""
ENT.Instructions	= ""
ENT.Category        = "AOCRP"
ENT.Spawnable       = true
ENT.AOCRPInteract = true

if SERVER then
        
    function ENT:Initialize()

        self:SetModel( "models/reizer_props/srsp/sci_fi/crate_04/crate_04.mdl" )
        self:PhysicsInit( SOLID_VPHYSICS )      -- Make us work with physics,
        self:SetMoveType( MOVETYPE_VPHYSICS )   -- after all, gmod is a physics
        self:SetSolid( SOLID_VPHYSICS )         -- Toolbox
    
        self:SetUseType( SIMPLE_USE )


            local phys = self:GetPhysicsObject()
        if (phys:IsValid()) then
            phys:Wake()
        end
    end
    
    function ENT:Use( activator, caller )

        activator:SetHealth(activator:GetMaxHealth())
        activator:SetArmor(activator:GetMaxArmor())
        wep = activator:GetActiveWeapon()
        if wep then
            activator:GiveAmmo(100, wep:GetPrimaryAmmoType())
            activator:GiveAmmo(100, wep:GetSecondaryAmmoType())
        end
    end


end


--gamemodes/starwarsrp/entities/entities/aoc_waffenkiste.lua:
AddCSLuaFile()


ENT.Type = "anim"
ENT.Base = "base_anim"

ENT.PrintName		= "Waffenkiste"
ENT.Author			= "Lt. Sammy"
ENT.Contact			= ""
ENT.Purpose			= ""
ENT.Instructions	= ""
ENT.Category        = "AOCRP"
ENT.Spawnable       = true
ENT.AOCRPInteract = true

if SERVER then
        
    function ENT:Initialize()

        self:SetModel( "models/reizer_props/srsp/sci_fi/crate_02/crate_02.mdl" )
        self:PhysicsInit( SOLID_VPHYSICS )      -- Make us work with physics,
        self:SetMoveType( MOVETYPE_VPHYSICS )   -- after all, gmod is a physics
        self:SetSolid( SOLID_VPHYSICS )         -- Toolbox
    
        self:SetUseType( SIMPLE_USE )


            local phys = self:GetPhysicsObject()
        if (phys:IsValid()) then
            phys:Wake()
        end
    end
    
    function ENT:Use( activator, caller )
        net.Start("AOCRP_WAFFENKISTE")
        net.Send(activator)
    end




end



if CLIENT then

    function ENT:Draw()
        self.BaseClass.Draw(self)  -- We want to override rendering, so don't call baseclass.
                                    -- Use this when you need to add to the rendering.
        --self:DrawEntityOutline( 1.0 ) -- Draw an outline of 1 world unit.
        --self:DrawModel()       -- Draw the model.


    end

end




if SERVER then
     
    util.AddNetworkString( "AOCRP_WAFFENKISTE" )
    util.AddNetworkString( "AOCRP_WAFFENKISTE_ARC" )
    util.AddNetworkString( "AOCRP_WAFFENKISTE_GIVE" )
    util.AddNetworkString( "AOCRP_WAFFENKISTE_TAKE" )
    
    
    
    net.Receive( "AOCRP_WAFFENKISTE_GIVE", function( len, ply )

        local wep = net.ReadString()
        if !AOCRP.Gear:HasWeaponInBox(ply, wep) then return end
        --ply:ConCommand("say /me nimmt sich eine Waffe aus der Waffekiste.")
        ply:Give(wep)
        timer.Simple( 0.5, function() 
            if wep == "aoc_chaingun" then
                ply:StripWeapon("rw_sw_z6")
            end
        end )
        timer.Simple( 0.5, function() 
        if wep == "rw_sw_z6" then
            ply:StripWeapon("aoc_chaingun")
        end
        end )
        ply:SelectWeapon(wep)
        ply:EmitSound("items/ammo_pickup.wav")
        ply:ConCommand("changeslotpos")
    end)
    
    net.Receive( "AOCRP_WAFFENKISTE_TAKE", function( len, ply )
        local wep = net.ReadString()
        --ply:ConCommand("say /me legt eine Waffe zurck in die Waffenkiste.")
        ply:StripWeapon(wep)
        ply:EmitSound("items/ammo_pickup.wav")
    
    end)
    
    
    end
        
    
    if CLIENT then
    
        function AOCRP_Waffenkiste(data) 
            if ValidPanel(AOCWaffenKisteFrame) then AOCWaffenKisteFrame:Remove() end
            AOCWaffenKisteFrame = AOCDerma:DefaultFrame()
            AOCWaffenKisteFrame:SetSize(AOCW(500),AOCH(600))
            AOCWaffenKisteFrame:Center()
            AOCWaffenKisteFrame:SetNewTitle("Waffenkiste")
            AOCWaffenKisteFrame:SetSizable(false)
            AOCWaffenKisteFrame:SetDraggable(false)
    
            local content = AOCDerma:ScrollBar(AOCWaffenKisteFrame) 
            content:Dock(FILL)
            local newTable = data
            --table.Merge(newTable, RPExtraTeams[LocalPlayer():Team()].weapons)
    
            for k, v in pairs(newTable) do
    
                local text = v
                
                local wepTbl = weapons.Get( v )
    
                if istable(wepTbl) then
                    text = wepTbl.PrintName
                
    
                
    
                    local btn = AOCDerma:Button(content, text, function() 
    
                        if LocalPlayer():HasWeapon(v) then
                            net.Start( "AOCRP_WAFFENKISTE_TAKE" )
                            net.WriteString(v)
                            net.SendToServer()
                        else
                            net.Start( "AOCRP_WAFFENKISTE_GIVE" )
                            net.WriteString(v)
                            net.SendToServer()      
                        end
                    end, "lc")
    
                    btn:Dock(TOP)
                    btn:DockMargin(5,10,5,0)
    
                    function btn:Think() 
                         if LocalPlayer():HasWeapon(v) then
                            self.akzent = Color(0,200,0)
                            self.akzenthover = Color(0,255,0,255)
                         else
                            self.akzent = Color(200,0,0)
                            self.akzenthover = Color(255,0,0,255)
                         end
                    end
                    
                end
    
    
            end        
        end
    
        net.Receive( "AOCRP_WAFFENKISTE", function( len, ply )
            AOCRP_Waffenkiste(AOCRP.Gears[LocalPlayer():GetGearID()].weaponbox) 
        end )
    
        net.Receive( "AOCRP_WAFFENKISTE_ARC", function( len, ply )
            AOCRP_Waffenkiste(AOCRP.Config.ARCWaffen) 
        end )

    end

    
--gamemodes/starwarsrp/entities/entities/aoc_waffenschrank.lua:
AddCSLuaFile()


ENT.Type = "anim"
ENT.Base = "base_anim"

ENT.PrintName		= "Waffenschrank"
ENT.Author			= "Lt. Sammy"
ENT.Contact			= ""
ENT.Purpose			= ""
ENT.Instructions	= ""
ENT.Category        = "AOCRP"
ENT.Spawnable       = true
ENT.AOCRPInteract = true

if SERVER then
        
    function ENT:Initialize()

        self:SetModel( "models/reizer_props/srsp/sci_fi/armory_02/armory_02.mdl" )
        self:PhysicsInit( SOLID_VPHYSICS )      -- Make us work with physics,
        self:SetMoveType( MOVETYPE_VPHYSICS )   -- after all, gmod is a physics
        self:SetSolid( SOLID_VPHYSICS )         -- Toolbox
    
        self:SetUseType( SIMPLE_USE )


            local phys = self:GetPhysicsObject()
        if (phys:IsValid()) then
            phys:Wake()
        end
    end
    
    function ENT:Use( activator, caller )
        net.Start("AOCRP_WAFFENKISTE")
        net.Send(activator)
    end




end



if CLIENT then

    function ENT:Draw()
        self.BaseClass.Draw(self)  -- We want to override rendering, so don't call baseclass.

    end

end



--addons/aoc_nextbots/lua/entities/aocrp_nextbot_uglymando.lua:
AddCSLuaFile()

ENT.Base = "aocrp_nextbot_b2_jetpack"
ENT.PrintName = "Mandalorianer"
ENT.Category = "AOCRP | Nextbots"
ENT.Spawnable = false
ENT.AdminOnly = false

ENT.Model = {
    "models/porky-da-corgi/starwars/mandalorians/bountyhunter_npc_hostile.mdl",
}

ENT.Weapon = "weapon_npc_westar35"
ENT.HP = 600
ENT.ShootingRange = 600
ENT.LooseRadius = 4000
ENT.Proficiency = 0.3
ENT.Speed = 100

ENT.Melee = true
ENT.MeleeDamage = 25
ENT.MeleeDelay = 3

ENT.ThrowGrenades = true
ENT.Grenades = {"summe_gr_grenade"}

ENT.Sounds = {}

ENT.ActivitiesEnabled = true
ENT.Activities = {
    ["idle"] = ACT_IDLE,
    ["shoot"] = ACT_IDLE_ANGRY_SMG1,
    ["reload"] = ACT_RELOAD,
    ["walk_slow"] = ACT_WALK_RIFLE,
    ["walk_fast"] = ACT_RUN_RIFLE,
    ["melee"] = ACT_MELEE_ATTACK1,
    ["jump"] = ACT_WALK_RIFLE
}

function ENT:OnNPCSpawn()
    self:PlayAnimation("idle")
end
--addons/arccw_base_modified/lua/entities/arccw_gl_ammodet.lua:
ENT.Type                  = "anim"
ENT.Base                  = "base_entity"
ENT.PrintName             = "HE Round"
ENT.Author                = ""
ENT.Information           = ""

ENT.Spawnable             = false


AddCSLuaFile()

ENT.Model = "models/items/ar2_grenade.mdl"
ENT.Ticks = 0
ENT.FuseTime = 10

function ENT:Draw()
    self:DrawModel()
end

ENT.Ticks = 0

function ENT:Detonate()
    if !self:IsValid() then return end
    local effectdata = EffectData()
        effectdata:SetOrigin( self:GetPos() )

    if self:WaterLevel() >= 1 then
        util.Effect( "WaterSurfaceExplosion", effectdata )
        self:EmitSound("weapons/underwater_explode3.wav", 125, 100, 1, CHAN_AUTO)
    else
        util.Effect( "Explosion", effectdata)
        self:EmitSound("phx/kaboom.wav", 125, 100, 1, CHAN_AUTO)
    end

    local attacker = self

    if self:GetOwner():IsValid() then
        attacker = self:GetOwner()
    end

    util.BlastDamage(self, attacker, self:GetPos(), 300, 50)

    self:FireBullets({
        Attacker = attacker,
        Damage = 0,
        Tracer = 0,
        Distance = 20000,
        Dir = self:GetVelocity(),
        Src = self:GetPos(),
        Callback = function(att, tr, dmg)
            util.Decal("Scorch", tr.StartPos, tr.HitPos - (tr.HitNormal * 16), self)
        end
    })

    self:Remove()
end

if CLIENT then
    function ENT:Think()
        if self.Ticks % 2 == 0 then
            local emitter = ParticleEmitter(self:GetPos())

            if !self:IsValid() or self:WaterLevel() > 2 then return end
            if !IsValid(emitter) then return end

            local smoke = emitter:Add("particle/particle_smokegrenade", self:GetPos())
            smoke:SetVelocity( VectorRand() * 25 )
            smoke:SetGravity( Vector(math.Rand(-5, 5), math.Rand(-5, 5), math.Rand(-20, -25)) )
            smoke:SetDieTime( math.Rand(1.5, 2.0) )
            smoke:SetStartAlpha( 255 )
            smoke:SetEndAlpha( 0 )
            smoke:SetStartSize( 0 )
            smoke:SetEndSize( 100 )
            smoke:SetRoll( math.Rand(-180, 180) )
            smoke:SetRollDelta( math.Rand(-0.2,0.2) )
            smoke:SetColor( 20, 20, 20 )
            smoke:SetAirResistance( 5 )
            smoke:SetPos( self:GetPos() )
            smoke:SetLighting( false )
            emitter:Finish()
        end

        self.Ticks = self.Ticks + 1
    end
else

    function ENT:Initialize()
        local pb_vert = 1
        local pb_hor = 1
        self:SetModel(self.Model)
        self:PhysicsInitBox( Vector(-pb_vert,-pb_hor,-pb_hor), Vector(pb_vert,pb_hor,pb_hor) )

        local phys = self:GetPhysicsObject()
        if phys:IsValid() then
            phys:Wake()
        end

        self.SpawnTime = CurTime()

        timer.Simple(0.1, function()
            if !IsValid(self) then return end
            self:SetCollisionGroup(COLLISION_GROUP_PROJECTILE)
        end)
    end

    function ENT:Think()
        if SERVER and CurTime() - self.SpawnTime >= self.FuseTime then
            self:Detonate()
        end
    end

    function ENT:PhysicsCollide(colData, collider)
        self:Detonate()
    end

end
--addons/arccw_weapons/lua/entities/arccw_projectile_base.lua:
AddCSLuaFile()

ENT.Type 				= "anim"
ENT.Base 				= "base_entity"
ENT.PrintName 			= "Base Projectile"

ENT.Spawnable 			= false
ENT.CollisionGroup = COLLISION_GROUP_PROJECTILE

ENT.Model = "models/Items/AR2_Grenade.mdl"
ENT.Ticks = 0
ENT.FuseTime = 0.05
ENT.Defused = false
ENT.BoxSize = Vector(2, 2, 2)
ENT.SmokeTrail = true

ENT.Drag = true
ENT.Gravity = true
ENT.DragCoefficient = 0.25
ENT.Boost = 0
ENT.Lift = 0
ENT.GunshipWorkaround = true
ENT.HelicopterWorkaround = true

ENT.Damage = 150
ENT.Radius = 300
ENT.ImpactDamage = nil

if SERVER then
    local gunship = {["npc_combinegunship"] = true, ["npc_combinedropship"] = true}

    function ENT:Initialize()
        local pb_vert = self.BoxSize[1]
        local pb_hor = self.BoxSize[2]
        self:SetModel(self.Model)
        self:PhysicsInitBox( Vector(-pb_vert,-pb_hor,-pb_hor), Vector(pb_vert,pb_hor,pb_hor) )

        local phys = self:GetPhysicsObject()
        if phys:IsValid() then
            phys:Wake()
            phys:EnableDrag(self.Drag)
            phys:SetDragCoefficient(self.DragCoefficient)
            phys:EnableGravity(self.Gravity)
            phys:SetMass(5)
            phys:SetBuoyancyRatio(0.4)
        end

        self.SpawnTime = CurTime()

        if self.SmokeTrail then
            util.SpriteTrail(self, 0, Color( 255 , 255 , 255 ), false, 6, 6, 0.5, 1 / (6 + 6) * 0.5, "particle/particle_smokegrenade")
        end
    end

    function ENT:Think()
        if self.Defused or self:WaterLevel() > 0 then return end

        self:GetPhysicsObject():AddVelocity(Vector(0, 0, self.Lift) + self:GetForward() * self.Boost)

        -- Gunships have no physics collection, periodically trace to try and blow up in their face
        if self.GunshipWorkaround and (self.GunshipCheck or 0 < CurTime()) then
            self.GunshipCheck = CurTime() + 0.33
            local tr = util.TraceLine({
                start = self:GetPos(),
                endpos = self:GetPos() + self:GetVelocity(),
                filter = self,
                mask = MASK_SHOT
            })
            if IsValid(tr.Entity) and gunship[tr.Entity:GetClass()] then
                self:SetPos(tr.HitPos)
                self:Detonate()
            end
        end
    end

function ENT:Detonate()
    if SERVER then
        local effectdata = EffectData()
            effectdata:SetOrigin( self:GetPos() )

        if self:WaterLevel() >= 1 then
            util.Effect("WaterSurfaceExplosion", effectdata)
            self:EmitSound("weapons/underwater_explode3.wav", 120, 100, 1, CHAN_AUTO)
        else
            local explode = ents.Create( "info_particle_system" )
            explode:SetKeyValue( "effect_name", "grenade_final" )
            explode:SetOwner( self.Owner )
            explode:SetPos( self:GetPos() )
            explode:Spawn()
            explode:Activate()
            explode:Fire( "start", "", 0 )
            explode:Fire( "kill", "", 30 )
            --util.Effect("Explosion", effectdata)
            --util.Effect("hl2mmod_explosion_grenade", effectdata)
            self:EmitSound("weapons/grenades/explode" .. math.random(1,3) .. ".wav", 90, 100, 1, CHAN_AUTO)
        end

        local attacker = self

        if self.Owner:IsValid() then
            attacker = self.Owner
        end

        local hit = false
        
        local pos = self:GetPos()

        for _, ent in pairs(ents.FindInSphere(pos, 350)) do
           
            local distSqr = ent:GetPos():DistToSqr(pos)
            local f = 1
            if distSqr > 9216 then -- 96 * 96
                f = Lerp((distSqr - 9216) / (122500 - 9216), 1, 0.25)
            end
            local dmginfo = DamageInfo()
            dmginfo:SetDamageType(DMG_BLAST)
            dmginfo:SetAttacker(attacker)
            dmginfo:SetDamage(190 * f)
            dmginfo:SetDamageForce((ent:WorldSpaceCenter() - pos):GetNormalized() * 9001 * f)
            dmginfo:SetInflictor(self)
            ent:TakeDamageInfo(dmginfo)
        end
        self:Remove()
        util.Decal("Scorch", pos, pos - Vector(0, 0, 16))
    end
end

    function ENT:PhysicsCollide(colData, physobj)
        if !self:IsValid() then return end

        if self.FuseTime > 0 and CurTime() - self.SpawnTime < self.FuseTime then
            if IsValid(colData.HitEntity) then
                local v = colData.OurOldVelocity:Length() ^ 0.5
                local dmg = DamageInfo()
                dmg:SetAttacker(IsValid(self:GetOwner()) and self:GetOwner() or self)
                dmg:SetInflictor(self)
                dmg:SetDamageType(DMG_CRUSH)
                dmg:SetDamage(v)
                dmg:SetDamagePosition(colData.HitPos)
                dmg:SetDamageForce(colData.OurOldVelocity)
                colData.HitEntity:TakeDamageInfo(dmg)
                self:EmitSound("weapons/rpg/shotdown.wav", 80, math.random(90, 110))
            end
            self:Defuse()
            return
        end

        local effectdata = EffectData()
            effectdata:SetOrigin( self:GetPos() )

        -- simulate AP damage on vehicles, mainly simfphys
        local tgt = colData.HitEntity
        while IsValid(tgt) do
            if tgt.GetParent and IsValid(tgt:GetParent()) then
                tgt = tgt:GetParent()
            elseif tgt.GetBaseEnt and IsValid(tgt:GetBaseEnt()) then
                tgt = tgt:GetBaseEnt()
            else
                break
            end
        end

        if self.ImpactDamage and IsValid(tgt) then
            local dmg = DamageInfo()
            dmg:SetAttacker(IsValid(self:GetOwner()) and self:GetOwner() or self)
            dmg:SetInflictor(self)
            dmg:SetDamageType(DMG_BLAST) -- helicopters
            dmg:SetDamage(self.ImpactDamage)
            dmg:SetDamagePosition(colData.HitPos)
            dmg:SetDamageForce(self:GetForward() * self.ImpactDamage)

            if IsValid(tgt:GetOwner()) and tgt:GetOwner():GetClass() == "npc_helicopter" then
                tgt = tgt:GetOwner()
                dmg:ScaleDamage(0.1)
                dmg:SetDamageType(DMG_BLAST + DMG_AIRBOAT)
                dmg:SetDamageForce(self:GetForward() * 100)
            end

            tgt:TakeDamageInfo(dmg)
        end

        self.HitPos = colData.HitPos
        self.HitVelocity = colData.OurOldVelocity
        self:Detonate()
    end

    -- Combine Helicopters are hard-coded to only take DMG_AIRBOAT damage
    hook.Add("EntityTakeDamage", "ArcCW_HelicopterWorkaround", function(ent, dmginfo)
        if IsValid(ent:GetOwner()) and ent:GetOwner():GetClass() == "npc_helicopter" then ent = ent:GetOwner() end
        if ent:GetClass() == "npc_helicopter" and dmginfo:GetInflictor().HelicopterWorkaround then
            dmginfo:SetDamageType(bit.bor(dmginfo:GetDamageType(), DMG_AIRBOAT))
        end
    end)
end

function ENT:Defuse()
    self.Defused = true
    SafeRemoveEntityDelayed(self, 5)
end

function ENT:Draw()
    self:DrawModel()
end
--addons/arccw_weapons/lua/entities/arccw_rocket_heat/shared.lua:
ENT.Type 				= "anim"
ENT.Base 				= "base_entity"
ENT.PrintName 			= "RPG-7 HEAT Round"
ENT.Author 				= ""
ENT.Information 		= ""

ENT.Spawnable 			= false


AddCSLuaFile()

ENT.Model = "models/items/ar2_grenade.mdl"
ENT.Ticks = 0
ENT.FuseTime = 4.5

if SERVER then

function ENT:Initialize()
    local pb_vert = 1
    local pb_hor = 1
    self:SetModel(self.Model)
    self:PhysicsInitBox( Vector(-pb_vert,-pb_hor,-pb_hor), Vector(pb_vert,pb_hor,pb_hor) )

    local phys = self:GetPhysicsObject()
    if phys:IsValid() then
        phys:Wake()
        phys:EnableGravity(false)
    end

    self.SpawnTime = CurTime()
    self.motorsound = CreateSound( self, "weapons/rpg/rocket1.wav")
    self.motorsound:Play()

    timer.Simple(0.1, function()
        if !IsValid(self) then return end
        self:SetCollisionGroup(COLLISION_GROUP_PROJECTILE)
    end)
end

function ENT:Think()
    if SERVER and CurTime() - self.SpawnTime >= self.FuseTime then
        self:Detonate()
    end
end

function ENT:OnRemove()
    self.motorsound:Stop()
end

end

function ENT:Think()
    if SERVER then
        local phys = self:GetPhysicsObject()
        phys:ApplyForceCenter( self:GetAngles():Forward() * 500 )

        if self.SpawnTime + self.FuseTime <= CurTime() then
            self:Detonate()
        end
    else
        if self.Ticks % 5 == 0 then
            local emitter = ParticleEmitter(self:GetPos())

            if !self:IsValid() or self:WaterLevel() > 2 then return end
            if !IsValid(emitter) then return end

            local smoke = emitter:Add("particle/particle_smokegrenade", self:GetPos())
            smoke:SetVelocity( VectorRand() * 25 )
            smoke:SetGravity( Vector(math.Rand(-5, 5), math.Rand(-5, 5), math.Rand(-20, -25)) )
            smoke:SetDieTime( math.Rand(1.5, 2.0) )
            smoke:SetStartAlpha( 255 )
            smoke:SetEndAlpha( 0 )
            smoke:SetStartSize( 0 )
            smoke:SetEndSize( 100 )
            smoke:SetRoll( math.Rand(-180, 180) )
            smoke:SetRollDelta( math.Rand(-0.2,0.2) )
            smoke:SetColor( 20, 20, 20 )
            smoke:SetAirResistance( 5 )
            smoke:SetPos( self:GetPos() )
            smoke:SetLighting( false )
            emitter:Finish()
        end

        self.Ticks = self.Ticks + 1
    end
end

function ENT:Detonate()
    if !self:IsValid() then return end
    local effectdata = EffectData()
        effectdata:SetOrigin( self:GetPos() )

    if self:WaterLevel() >= 1 then
        util.Effect( "WaterSurfaceExplosion", effectdata )
        self:EmitSound("weapons/underwater_explode3.wav", 125, 100, 1, CHAN_AUTO)
    else
        util.Effect( "Explosion", effectdata)
        self:EmitSound("phx/kaboom.wav", 125, 100, 1, CHAN_AUTO)
    end

    local attacker = self

    if self.Owner:IsValid() then
        attacker = self.Owner
    end

    util.BlastDamage(self, attacker, self:GetPos(), 50, 2000)
    util.BlastDamage(self, attacker, self:GetPos(), 300, 500)

    self:FireBullets({
        Attacker = attacker,
        Damage = 0,
        Tracer = 0,
        Distance = 20000,
        Dir = self:GetVelocity(),
        Src = self:GetPos(),
        Callback = function(att, tr, dmg)
            util.Decal("Scorch", tr.StartPos, tr.HitPos - (tr.HitNormal * 16), self)
        end
    })

    self:Remove()
end

function ENT:PhysicsCollide(colData, collider)
    self:Detonate()
end

function ENT:Draw()
    cam.Start3D() -- Start the 3D function so we can draw onto the screen.
        render.SetMaterial( Material("effects/blueflare1") ) -- Tell render what material we want, in this case the flash from the gravgun
        render.DrawSprite( self:GetPos(), math.random(100, 200), math.random(100, 200), Color(255, 225, 175) ) -- Draw the sprite in the middle of the map, at 16x16 in it's original colour with full alpha.
    cam.End3D()
end
--addons/arccw_weapons/lua/entities/emp_rocket/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_entity"
ENT.PrintName = "EMP Rocket"
ENT.Author = ""
ENT.Information = ""
ENT.Spawnable = false
ENT.AdminSpawnable = false

ENT.Model = "models/weapons/star_wars_battlefront/com_weap_missile.mdl"
ENT.FuseTime = 30
ENT.ArmTime = 0

AddCSLuaFile()

function ENT:Initialize()
    if SERVER then
        self:SetModel( self.Model )
        self:SetMoveType( MOVETYPE_VPHYSICS )
        self:SetSolid( SOLID_VPHYSICS )
        self:PhysicsInit( SOLID_VPHYSICS )
        self:SetCollisionGroup( COLLISION_GROUP_PROJECTILE )
        self:DrawShadow( true )

        local phys = self:GetPhysicsObject()
        if phys:IsValid() then
            phys:Wake()
	phys:SetMass(3)
            phys:SetBuoyancyRatio(0)
            phys:EnableGravity( false )
        end

        self.kt = CurTime() + self.FuseTime
        self.motorsound = CreateSound( self, "weapons/star_wars_battlefront/common/ammo_rocket_lp06.wav")
    end

    self.at = CurTime() + self.ArmTime
    self.Armed = false
end

function ENT:OnRemove()
    if SERVER then
        self.motorsound:Stop()
    end
end


function ENT:PhysicsCollide(data, physobj)
    if self.at <= CurTime() then
        self:Detonate()
    elseif self.at > CurTime() then
        local effectdata = EffectData()
            effectdata:SetOrigin( self:GetPos() )
        util.Effect( "RPGShotDown", effectdata)
        util.Effect( "StunstickImpact", effectdata)
        self:Remove()
    end
end

function ENT:Arm()
    if SERVER then
        self.motorsound:Play()
    end
end

function ENT:Think()

    if CurTime() >= self.at and !self.Armed then
        self:Arm()
        self.Armed = true
    end

    if SERVER then

        if self.Armed then
            local phys = self:GetPhysicsObject()
            phys:ApplyForceCenter( self:GetAngles():Forward() * 500 )
        end

        if CurTime() >= self.kt then
            self:Detonate()
        end
    end

    if CLIENT then
        if self.Armed then
		ParticleEffectAttach( "astw2_swbf_muzzle_rep_sniper", PATTACH_POINT_FOLLOW, self, 0 )
            local emitter = ParticleEmitter(self:GetPos())

            if !self:IsValid() or self:WaterLevel() > 2 then return end

            local smoke = emitter:Add("effects/swbf/thicksmoke", self:GetPos())
        smoke:SetGravity( Vector(math.Rand(-5, 5), math.Rand(-5, 5), math.Rand(-20, -25)) )
        smoke:SetVelocity( self:GetAngles():Forward() * 100 )
        smoke:SetDieTime( math.Rand(0.5,0.75) )
        smoke:SetStartAlpha( 50 )
        smoke:SetEndAlpha( 0 )
        smoke:SetStartSize( 5 )
        smoke:SetEndSize( 20 )
        smoke:SetRoll( math.Rand(-180, 180) )
        smoke:SetRollDelta( math.Rand(-0.2,0.2) )
        smoke:SetColor( 155, 155, 255 )
        smoke:SetAirResistance( 50 )
        smoke:SetPos( self:GetPos() )
        smoke:SetLighting( true )
        emitter:Finish()
        end
    end
end

function ENT:Detonate()
    if SERVER then
        if !self:IsValid() then return end
        local effectdata = EffectData()
            effectdata:SetOrigin( self:GetPos() )

        if self:WaterLevel() >= 1 then
            util.Effect( "WaterSurfaceExplosion", effectdata )
        else
            ParticleEffect( "astw2_swbf_explosion_rep_emp_rocket", self:GetPos(), self:GetAngles() )
					sound.Play( "weapons/star_wars_battlefront/common/exp_ord_haywireGrenade.wav",  self:GetPos(), 100, 100 )

        end

        local attacker = self

        if self.Owner:IsValid() then
            attacker = self.Owner
        end

        	 -- util.BlastDamage(self, self.Owner, self:GetPos(), 65, 100)
	 local ent = self.Owner
	if !IsValid(ent) then ent = self end
	 local t = DamageInfo()
			t:SetDamage(185)
			t:SetDamageType(DMG_SHOCK)
			t:SetAttacker(ent)
			t:SetInflictor(self)
	util.BlastDamageInfo(t, self:GetPos(), 400)
	util.Decal( "Scorch", self:GetPos(), self:GetPos() - Vector(0, 0, 32), self )
		util.ScreenShake(self:GetPos(),18000,500,1.2,2048)
	  -- local targets = ents.FindInSphere(self:GetPos(), 256)
        -- for _, k in pairs(targets) do
            -- if k:IsPlayer() or k:IsNPC() or scripted_ents.IsBasedOn( k:GetClass(), "base_nextbot" ) then
                -- local regen = FrameTime() * 900
                -- k:SetHealth( math.Clamp( k:Health() - regen, 0, k:GetMaxHealth()+k:GetMaxHealth() ) )
				-- if(SERVER) then
				-- k:Ignite( 10 )
				-- end
			-- if !k:IsPlayer() or !k:IsNPC() then
				-- end
            -- end
        -- end
        self:Remove()

    end
end

function ENT:Draw()
    if CLIENT then
        self:DrawModel()

        if self.Armed then
            cam.Start3D() -- Start the 3D function so we can draw onto the screen.
                render.SetMaterial( Material("effects/blueflare1") ) -- Tell render what material we want, in this case the flash from the gravgun
                render.DrawSprite( self:GetPos(), math.random(45, 85), math.random(45, 85), Color(175, 100, 255) ) -- Draw the sprite in the middle of the map, at 16x16 in it's original colour with full alpha.
            cam.End3D()
        end
    end
end
--gamemodes/starwarsrp/entities/entities/ent_realistic_hook.lua:
AddCSLuaFile()

ENT.Type = "anim"

ENT.Spawnable = false
ENT.AdminSpawnable = true

ENT.Model = "models/props_c17/TrapPropeller_Lever.mdl"
ENT.HitSound = Sound( "physics/metal/metal_barrel_impact_hard7.wav" )

local ServerConvarFlags = {FCVAR_ARCHIVE, FCVAR_REPLICATED, FCVAR_SERVER_CAN_EXECUTE}
CreateConVar( "hatshook_hookplayers", "1", ServerConvarFlags, "Allows the Grappling Hook to grab players" )
CreateConVar( "hatshook_physics", "1", ServerConvarFlags, "Grappling hook is launched as a projectile" )
CreateConVar( "hatshook_speed", "1000", ServerConvarFlags, "Launch velocity of the grappling hook (Max range for non-physics hooks)" )

CreateConVar( "hatshook_breakpower", "3", ServerConvarFlags, "Strength of each breakout attempt" )
CreateConVar( "hatshook_breakregen", "1", ServerConvarFlags, "Breakout depletion rate" )

CreateConVar( "hatshook_ammo", "-1", ServerConvarFlags, "Number of uses each grappling hook has. -1 is infinite." )

function ENT:SetupDataTables()
	self:NetworkVar( "Bool", 0, "HasHit" )
	
	self:NetworkVar( "Entity", 0, "Wep" )
	self:NetworkVar( "Entity", 1, "TargetEnt" )
	
	self:NetworkVar( "Int", 0, "Dist" )
	self:NetworkVar( "Int", 1, "Durability" )
	
	self:NetworkVar( "Int", 2, "FollowBone" )
	self:NetworkVar( "Vector", 1, "FollowOffset" )
	self:NetworkVar( "Angle", 0, "FollowAngle" )
	
	self:NetworkVar( "Vector", 0, "ShootDir" )
end

function ENT:Initialize()
	self:SetModel( self.Model )
	
	--self:SetMoveType( MOVETYPE_VPHYSICS )
	self:PhysicsInit( SOLID_VPHYSICS )
	if not cvars.Bool( "hatshook_hookplayers" ) then
		self:SetCollisionGroup( COLLISION_GROUP_WEAPON )
	end
	
	self:PhysWake()
	local phys = self:GetPhysicsObject()
	if IsValid(phys) then
		if SERVER then
			self:SetShootDir( self.Owner:GetAimVector() * cvars.Number( "hatshook_speed" ) )
		end
		phys:SetVelocity( self:GetShootDir() )
	end
	
	self.HookHealth = 100
	
	hook.Add( "AllowPlayerPickup", self, self.AllowPlayerPickup )
	if CLIENT then hook.Add( "HUDPaint", self, self.HUDPaint ) end
	
	if SERVER then
		local timerName = tostring(self).." Hook Durability Restore"
		timer.Create( timerName, 0.1, 0, function()
			if not IsValid(self) then timer.Destroy(timerName) return end
			self:SetDurability( math.Approach(self:GetDurability(), 0, cvars.Number("hatshook_breakregen") ) )
		end)
		hook.Add( "KeyPress", self, self.PlayerKeyPress )
	end
end

function ENT:Destroyed( NoCooldown )
	if CLIENT then return end
	
	local ef = EffectData()
	ef:SetStart( self:GetPos() )
	ef:SetOrigin( self:GetPos() )
	ef:SetScale( 1 )
	ef:SetRadius( 1 )
	ef:SetMagnitude( 1 )
	ef:SetNormal( self:GetRight() )
	
	util.Effect( "Sparks", ef, true, true )
	sound.Play( self.HitSound, self:GetPos(), 75, 100 )
	
	if IsValid( self:GetWep() ) and self:GetWep().SetCooldown then
		self:GetWep():SetCooldown( NoCooldown and self:GetWep():GetCooldown()+10 or 100 )
	end
	
	self:Remove()
end
function ENT:OnTakeDamage( DmgInfo )
	self.HookHealth = (self.HookHealth or 0) - DmgInfo:GetDamage()
	if self.HookHealth<=0 then
		self:Destroyed()
	end
end

function ENT:DoParent( target, obj )
	if IsValid( target ) and target~=self and target~=self.Owner and (not (target:IsWeapon() and target:GetOwner()==self.Owner)) then
		self:SetParent( target )
		
		if target:GetClass():sub(1,5)~="func_" then
			for i=0,target:GetPhysicsObjectCount()-1 do
				local p = target:GetPhysicsObjectNum( i )
				if p==obj then
					--self:SetParentPhysNum( target:TranslatePhysBoneToBone(i) )
					--self:FollowBone( target, target:TranslatePhysBoneToBone(i) )
					--print(i,target:TranslatePhysBoneToBone(i))
					
					self:SetFollowBone( target:TranslatePhysBoneToBone(i) )
					local pos, ang = target:GetBonePosition( self:GetFollowBone() )
					if pos and ang then
						self:SetFollowOffset( self:GetPos() - pos )
						self:SetFollowAngle( self:GetAngles()-ang )
					end
					break
				end
			end
		end
		
		self:SetTargetEnt( target )
	end
end

local NoHitEnts = { ["func_breakable_surf"] = true, ["ent_realistic_hook"] = true, } // This is stuff we shouldn't attach to, glitches out
function ENT:PhysicsCollide( data, phys )
	if self:GetHasHit() then return end // Already hit
	
	if IsValid(data.HitEntity) and NoHitEnts[data.HitEntity:GetClass()] then // Something that'll bug out, eg a window
		self:Destroyed( true )
		return
	end
	if not IsValid(self:GetWep()) and IsValid(self:GetWep().Owner) and self:GetWep().Owner:IsPlayer() then self:Destroyed( true ) return end
	
	local tr = util.TraceLine( {start = (data.HitPos - (data.HitNormal*10)), endpos = (data.HitPos+data.HitNormal*10), filter = self} )
	if tr.HitSky then return end
	
	timer.Simple(0,function()
		if not IsValid(self) then return end
		if not (IsValid(self:GetWep()) and IsValid(self:GetWep().Owner)) then self:Destroyed( true ) return end
		
		self:SetCollisionGroup( COLLISION_GROUP_WORLD )
		
		self:SetPos( data.HitPos )
		local ang = data.HitNormal:Angle()
		ang:RotateAroundAxis( ang:Up(), 90 )
		self:SetAngles( ang )
		self:SetMoveType( MOVETYPE_NONE )
		
		self:SetDist( data.HitPos:Distance( self:GetWep().Owner:GetShootPos() ) )
		self:DoParent( data.HitEntity, data.HitObject )
	end)
	
	self:SetDist( data.HitPos:Distance( self:GetWep().Owner:GetShootPos() ) )
	
	local ef = EffectData()
	ef:SetOrigin( data.HitPos )
	ef:SetNormal( data.HitNormal )
	ef:SetStart( data.HitPos )
	ef:SetMagnitude( 2 )
	ef:SetScale( 1 )
	ef:SetRadius( 1 )
	
	util.Effect( "Sparks", ef, true, true )
	sound.Play( self.HitSound, data.HitPos, 75, 100 )
	
	self:SetHasHit( true )
end

-- Misc hooks --
----------------
function ENT:Think()
	if SERVER and (not (IsValid(self:GetWep()) and self:GetWep()==self.Owner:GetActiveWeapon()) ) then self:Remove() return end
	
	local phys = self:GetPhysicsObject()
	if IsValid(phys) and self:GetHasHit() then // This stuff doesn't work in the collision hook
		phys:EnableMotion( false )
		phys:SetPos( self:GetPos() )
		phys:SetAngles( self:GetAngles() )
	end
end

function ENT:AllowPlayerPickup( ply, ent )
	if ply==self.Owner then return false end // They're currently hooked to something, if we let them pick it up they can exploit and fly
end

-- 3D Drawing --
----------------
local HookCable = Material( "cable/cable2" )
function ENT:Draw()
	if IsValid( self:GetTargetEnt() ) then
		local bpos, bang = self:GetTargetEnt():GetBonePosition( self:GetFollowBone() )
		local npos, nang = self:GetFollowOffset(), self:GetFollowAngle()
		if npos and nang and bpos and bang then
			npos:Rotate( nang )
			nang = nang+bang
			
			npos = bpos+npos
			
			self:SetPos( npos )
			self:SetAngles( nang )
		end
	end
	
	self:DrawModel()
	
	// We'll draw the beam from both the weapon and the hook, less likely to move out of rendering when it should be visible
	if not IsValid( self:GetWep() ) then return end
	if self.Owner==LocalPlayer() and not hook.Call("ShouldDrawLocalPlayer", GAMEMODE, self.Owner) then return end // Badly aligned, the rope will always be visible from the ViewModel draw anyway
	
	if IsValid(self.Owner) then
		local att = self:GetWep():GetAttachment( 1 )
		
		render.SetMaterial( HookCable )
		if att and att.Pos then
			render.DrawBeam( self:GetPos(), att.Pos, 1, 0, 2, Color(255,255,255,255) )
		else
			render.DrawBeam( self:GetPos(), self:GetWep():GetPos(), 1, 0, 2, Color(255,255,255,255) )
		end
	end
end

-- HUD stuff --
---------------
local ChargeBarCol = { White = Color(255,255,255), DefCol1 = Color(255,50,50), DefCol2 = Color(50,255,50) }
local Gradient = Material( "gui/gradient" )
local function DrawChargeBar( xpos, ypos, width, height, charge, col1, col2 )
	draw.NoTexture()
	
	surface.SetDrawColor( ChargeBarCol.White )
	surface.DrawOutlinedRect( xpos, ypos, width, height )
	
	charge = math.Clamp( charge or 50, 0, 100)
	barLen = (width-2)*(charge/100)
	render.SetScissorRect( xpos+1, ypos+1, xpos+1+barLen, (ypos+height)-1, true )
		surface.SetDrawColor( col2 or ChargeBarCol.DefCol2 )
		surface.DrawRect( xpos+1, ypos+1, width-1, height-2 )
		
		surface.SetMaterial( Gradient )
		surface.SetDrawColor( col1 or ChargeBarCol.DefCol1 )
		surface.DrawTexturedRect( xpos+1, ypos+1, width-1, height-2 )
	render.SetScissorRect( xpos+1, ypos+1, xpos+1+barLen, (ypos+height)-1, false )
	
	draw.NoTexture()
end
local function ShadowText( txt, x, y, col )
	draw.DrawText( txt, "Default", x+1, y+1, Color(0,0,0), TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
	draw.DrawText( txt, "Default", x, y, col or Color(255,255,255), TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
end
function ENT:HUDPaint()
	if not (LocalPlayer()==self:GetTargetEnt()) then return end
	
	ShadowText( "Seillnge: "..tostring(self:GetDist()), ScrW()/2, ScrH()/2-60 )
	ShadowText( "Du hngst am Haken!", ScrW()/2, ScrH()/2-75, Color(255,100,100) )
	ShadowText( (input.LookupBinding("+use") or "[E]"):upper() .. " - zum befreien", ScrW()/2, ScrH()/2-40 )
	DrawChargeBar( (ScrW()/2)-70, (ScrH()/2)-20, 140, 15, self:GetDurability() )
end

if SERVER then
	function ENT:PlayerKeyPress( ply, key )
		if (ply~=self:GetTargetEnt() or key~=IN_USE) then return end
		
		self:SetDurability( self:GetDurability()+cvars.Number("hatshook_breakpower") )
		if self:GetDurability()>=100 then self:Destroyed() end
	end
end

--addons/arccw_weapons/lua/entities/haywire/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_entity"
ENT.PrintName = "Haywire Grenade (Thrown)"
ENT.Author = ""
ENT.Information = ""
ENT.Spawnable = false
ENT.AdminSpawnable = false

ENT.Model = "models/weapons/star_wars_battlefront/ThermalDetonator_Thrown.mdl"
ENT.FuseTime = 1.5
ENT.ArmTime = 0
ENT.ImpactFuse = false

AddCSLuaFile()

function ENT:Initialize()
    if SERVER then
        self:SetModel( self.Model )
        self:SetMoveType( MOVETYPE_VPHYSICS )
        self:SetSolid( SOLID_VPHYSICS )
        self:PhysicsInit( SOLID_VPHYSICS )
        self:SetCollisionGroup( COLLISION_GROUP_PROJECTILE )
        self:DrawShadow( true )

        local phys = self:GetPhysicsObject()
        if phys:IsValid() then
	    phys:SetMass(10)
            phys:Wake()
            phys:SetBuoyancyRatio(0)
        end

        self.kt = CurTime() + self.FuseTime
        self.at = CurTime() + self.ArmTime
    end
end

function ENT:PhysicsCollide(data, physobj)
    if SERVER then
        if data.Speed > 75 then
            self:EmitSound(Sound("weapons/star_wars_battlefront/common/imp_grenade_stone_0" .. math.random(1,3) .. ".wav"))
        elseif data.Speed > 25 then
            self:EmitSound(Sound("weapons/star_wars_battlefront/common/imp_grenade_dirt_0" .. math.random(1,3) .. ".wav"))
        end
		self:SetAngles(Angle(0,0,0))
        if self.at <= CurTime() and self.ImpactFuse then
            self:Detonate()
		
        end
    end
end

function ENT:Think()
    if SERVER and CurTime() >= self.kt then
        self:Detonate()
    end
end

function ENT:Detonate()
    if SERVER then
        if not self:IsValid() then return end
        local effectdata = EffectData()
            effectdata:SetOrigin( self:GetPos() )

        if self:WaterLevel() >= 1 then
            util.Effect( "WaterSurfaceExplosion", effectdata )
        else
            ParticleEffect( "astw2_swbf_explosion_emp", self:GetPos(), self:GetAngles() )
			sound.Play( "weapons/star_wars_battlefront/common/exp_ord_haywireGrenade.wav",  self:GetPos(), 100, 100 )

        end

        local attacker = self

        if self.Owner:IsValid() then
            attacker = self.Owner
        end

    	 -- util.BlastDamage(self, self.Owner, self:GetPos(), 65, 100)
	 local ent = self.Owner
	if !IsValid(ent) then ent = self end
	 local t = DamageInfo()
			t:SetDamage(185)
			t:SetDamageType(DMG_SHOCK)
			t:SetAttacker(ent)
			t:SetInflictor(self)
	util.BlastDamageInfo(t, self:GetPos(), 400)
	util.Decal( "Scorch", self:GetPos(), self:GetPos() - Vector(0, 0, 32), self )
		util.ScreenShake(self:GetPos(),18000,500,1.2,2048)
	  -- local targets = ents.FindInSphere(self:GetPos(), 256)
        -- for _, k in pairs(targets) do
            -- if k:IsPlayer() or k:IsNPC() or scripted_ents.IsBasedOn( k:GetClass(), "base_nextbot" ) then
                -- local regen = FrameTime() * 900
                -- k:SetHealth( math.Clamp( k:Health() - regen, 0, k:GetMaxHealth()+k:GetMaxHealth() ) )
				-- if(SERVER) then
				-- k:Ignite( 10 )
				-- end
			-- if !k:IsPlayer() or !k:IsNPC() then
				-- end
            -- end
        -- end
        self:Remove()

    end
end

function ENT:Draw()
    if CLIENT then
        self:DrawModel()
		
            cam.Start3D() -- Start the 3D function so we can draw onto the screen.
                render.SetMaterial( Material("effects/swbf/flare0") ) -- Tell render what material we want, in this case the flash from the gravgun
                render.DrawSprite( self:GetPos(), math.random(30, 40), math.random(30, 40), Color(50, 50, 155) ) -- Draw the sprite in the middle of the map, at 16x16 in it's original colour with full alpha.
            cam.End3D()
      
    end
end
--lua/entities/heracles421_lfs_mtt/cl_init.lua:
include("shared.lua")

function ENT:DamageFX()
	local HP = self:GetHP()
	if HP == 0 or HP > self:GetMaxHP() * 0.5 then return end

	self.nextDFX = self.nextDFX or 0

	if self.nextDFX < CurTime() then
		self.nextDFX = CurTime() + 0.05

		local effectdata = EffectData()
			effectdata:SetOrigin( self:LocalToWorld( Vector(-120,0,300) ) )
		util.Effect( "lfs_blacksmoke", effectdata )
	end
end

function ENT:LFSCalcViewThirdPerson( view, ply, FirstPerson )
	local Pod = ply:GetVehicle()

	if ply == self:GetTurretDriver() then
		local radius = 800
		radius = radius + radius * Pod:GetCameraDistance()

		local StartPos = self:LocalToWorld( Vector(320,0,300) ) + view.angles:Up() * 100
		local EndPos = StartPos - view.angles:Forward() * radius

		local WallOffset = 4

		local tr = util.TraceHull( {
			start = StartPos,
			endpos = EndPos,
			filter = function( e )
				local c = e:GetClass()
				local collide = not c:StartWith( "prop_physics" ) and not c:StartWith( "prop_dynamic" ) and not c:StartWith( "prop_ragdoll" ) and not e:IsVehicle() and not c:StartWith( "gmod_" ) and not c:StartWith( "player" ) and not e.LFS

				return collide
			end,
			mins = Vector( -WallOffset, -WallOffset, -WallOffset ),
			maxs = Vector( WallOffset, WallOffset, WallOffset ),
		} )

		view.drawviewer = true
		view.origin = tr.HitPos

		if tr.Hit and not tr.StartSolid then
			view.origin = view.origin + tr.HitNormal * WallOffset
		end

	end

	return view
end

function ENT:LFSHudPaintInfoText( X, Y, speed, alt, AmmoPrimary, AmmoSecondary, Throttle )
	draw.SimpleText( "SPEED", "LFS_FONT", 10, 10, Color(255,255,255,255), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
	draw.SimpleText( speed.."km/h", "LFS_FONT", 120, 10, Color(255,255,255,255), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )

	draw.SimpleText( "PRI", "LFS_FONT", 10, 35, Color(255,255,255,255), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
	draw.SimpleText( AmmoPrimary, "LFS_FONT", 120, 35, Color(255,255,255,255), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
end

function ENT:EngineActiveChanged( bActive )
	if bActive then
		self.ENG = CreateSound( self, "GALACTICA_MTT_ENGINE" )
		self.ENG:PlayEx(0,0)

		--self.DIST = CreateSound( self, "LFS_SPITFIRE_DIST" )
		--self.DIST:PlayEx(0,0)
	else
		self:SoundStop()
	end
end

function ENT:LFSHudPaintCrosshair( HitEnt, HitPly )
	self:LFSHudPaintDrivingCrosshair( HitEnt, HitPly )
	--[[if LocalPlayer():lfsGetInput( "FREELOOK" ) then
		self:LFSHudPaintAimingCrosshair( 0, 0, LocalPlayer() )
	else
		self:LFSHudPaintDrivingCrosshair( HitEnt, HitPly )
	end]]
end

function ENT:LFSHudPaintDrivingCrosshair( HitEnt, HitPly )
	local startpos = self:GetRotorPos()
	local TracePilot = util.TraceHull( {
		start = startpos,
		endpos = (startpos + LocalPlayer():EyeAngles():Forward() * 50000),
		mins = Vector( -10, -10, -10 ),
		maxs = Vector( 10, 10, 10 ),
		filter = {self}
	} )
	local HitPilot = TracePilot.HitPos:ToScreen()

	local X = HitPilot.x
	local Y = HitPilot.y

	if self:GetFrontInRange() then
		surface.SetDrawColor( 255, 255, 255, 255 )
	else
		surface.SetDrawColor( 255, 0, 0, 255 )
	end

	simfphys.LFS.DrawCircle( X, Y, 10 )
	surface.DrawLine( X + 10, Y, X + 20, Y )
	surface.DrawLine( X - 10, Y, X - 20, Y )
	surface.DrawLine( X, Y + 10, X, Y + 20 )
	surface.DrawLine( X, Y - 10, X, Y - 20 )
	simfphys.LFS.DrawCircle( HitEnt.x, HitEnt.y, 20 )

	-- shadow
	surface.SetDrawColor( 0, 0, 0, 80 )
	simfphys.LFS.DrawCircle( X + 1, Y + 1, 10 )
	surface.DrawLine( X + 11, Y + 1, X + 21, Y + 1 )
	surface.DrawLine( X - 9, Y + 1, X - 16, Y + 1 )
	surface.DrawLine( X + 1, Y + 11, X + 1, Y + 21 )
	surface.DrawLine( X + 1, Y - 19, X + 1, Y - 16 )
	simfphys.LFS.DrawCircle( HitEnt.x + 1, HitEnt.y + 1, 20 )
end

function ENT:LFSHudPaintAimingCrosshair( HitEnt, HitPly )
	local ID = self:LookupAttachment( "muzzle_right_top" )
	local Muzzle = self:GetAttachment( ID )

	if Muzzle then
		local startpos = Muzzle.Pos
		local Trace = util.TraceHull( {
			start = startpos,
			endpos = (startpos + Muzzle.Ang:Up() * 5000000),
			mins = Vector( -10, -10, -10 ),
			maxs = Vector( 10, 10, 10 ),
			filter = function( ent ) if ent == self or ent:GetClass() == "lunasflightschool_missile" then return false end return true end
		} )
		local HitPos = Trace.HitPos:ToScreen()

		local X = HitPos.x
		local Y = HitPos.y

		if self:GetIsCarried() then
			surface.SetDrawColor( 255, 0, 0, 255 )
		else
			surface.SetDrawColor( 255, 255, 255, 255 )
		end

		simfphys.LFS.DrawCircle( X, Y, 10 )
		surface.DrawLine( X + 10, Y, X + 20, Y )
		surface.DrawLine( X - 10, Y, X - 20, Y )
		surface.DrawLine( X, Y + 10, X, Y + 20 )
		surface.DrawLine( X, Y - 10, X, Y - 20 )

		-- shadow
		surface.SetDrawColor( 0, 0, 0, 80 )
		simfphys.LFS.DrawCircle( X + 1, Y + 1, 10 )
		surface.DrawLine( X + 11, Y + 1, X + 21, Y + 1 )
		surface.DrawLine( X - 9, Y + 1, X - 16, Y + 1 )
		surface.DrawLine( X + 1, Y + 11, X + 1, Y + 21 )
		surface.DrawLine( X + 1, Y - 19, X + 1, Y - 16 )
	end
end

--[[function ENT:AnimLandingGear()
	self.SMLG = self.SMLG and self.SMLG + (20 *  self:GetLGear() - self.SMLG) * FrameTime() * 2 or 0

	local Ang = 20 - self.SMLG
	self:ManipulateBoneAngles( 8, Angle(0,-Ang,0) )
	self:ManipulateBoneAngles( 9, Angle(0,Ang,0) )

	self:ManipulateBoneAngles( 10, Angle(0,Ang,0) )
	self:ManipulateBoneAngles( 11, Angle(0,-Ang,0) )
end]]

--addons/weapon_joe_fort/lua/entities/joefort_ressource_250/shared.lua:
ENT.Type = "anim"
ENT.Base = "joefort_ressource_base"
 
ENT.PrintName = "Big Resource Crate"
ENT.Author  = "Joe"
ENT.Spawnable = true
ENT.AdminSpawnable = false
ENT.Category = "JoeFort"

ENT.Ressourceamount = 250
ENT.model = "models/Items/ammocrate_ar2.mdl"
ENT.Destroyable = true
--addons/lvs_addons/lua/entities/laat_hatch/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel() 
end
--addons/arccw_weapons/lua/entities/landmine/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.PrintName = "LandMine"
ENT.Author = ""
ENT.Information = ""
ENT.Spawnable = false
ENT.AdminSpawnable = false

ENT.Model = "models/weapons/star_wars_battlefront/com_weap_inf_landmine_placed.mdl"

AddCSLuaFile()

function ENT:Initialize()
    if SERVER then
        self:SetModel( self.Model )
        self:PhysicsInit( SOLID_VPHYSICS )
        self:SetMoveType( MOVETYPE_VPHYSICS )
        self:SetSolid( SOLID_VPHYSICS )
        self:SetCollisionGroup( COLLISION_GROUP_PROJECTILE )
        self:DrawShadow( true )
        self:SetUseType( CONTINUOUS_USE )

        local phys = self:GetPhysicsObject()
        if phys:IsValid() then
            phys:Wake()
            phys:SetBuoyancyRatio(0)
        end

    self.Armed = false

    end
end

function ENT:OnTakeDamage()
    if SERVER then
        local effectdata = EffectData()
            effectdata:SetOrigin( self:GetPos() )
        if self:WaterLevel() >= 1 then
            util.Effect( "WaterSurfaceExplosion", effectdata )
        else
            util.Effect( "ManhackSparks", effectdata)
        end
        self:Remove()
    end
end

function ENT:PhysicsCollide(data, physobj)
    if SERVER and !self.Armed then
        self:EmitSound( "weapons/star_wars_battlefront/gcw/wpn_all_unit_lockon_lp.wav" )
        self:SetAngles( data.HitNormal:Angle() + Angle( 0, 0, 0 ) )
        self:SetPos( data.HitPos + (data.HitNormal * -1) )
        -- self:SetCollisionGroup( COLLISION_GROUP_DEBRIS )
        -- self:SetMoveType( MOVETYPE_NONE )
        if !data.HitEntity:IsPlayer() and data.HitEntity:GetClass() != "worldspawn" then
            self:SetParent( data.HitEntity )
        end

        self.st = CurTime() + 1.5
        self.armtime = CurTime() + 3.5
        self.Armed = true
    end
end

function ENT:Detonate()
    if SERVER then
        if !self:IsValid() then return end
        local effectdata = EffectData()
            effectdata:SetOrigin( self:GetPos() )

        if self:WaterLevel() >= 1 then
            util.Effect( "WaterSurfaceExplosion", effectdata )
        else
            ParticleEffect( "astw2_swbf_explosion_thermal_detonator", self:GetPos(), self:GetAngles() )
			sound.Play( "weapons/star_wars_battlefront/common/exp_obj_med0" .. math.random(1,5) .. ".wav",  self:GetPos(), 100, 100 )
			util.ScreenShake(self:GetPos(),36000,500,2.2,2048)
        end
		
		
        util.BlastDamage(self, self.Owner, self:GetPos(), 512, 256)

        self:Remove()

    end
end

function ENT:Think()
    if SERVER then

        if self.Armed and CurTime() >= self.st then
            -- self:EmitSound( "weapons/svm/mine_beep.wav", 75, 100 , 0.5)
            self.st = CurTime() + 0.85
			self:SetAngles(Angle(0,0,0))
        end

       
        end

		 if self.Armed and self.armtime < CurTime() then

    local targets = ents.FindInSphere(self:GetPos(), 160)
        for _, k in pairs(targets) do
            -- if (k:IsPlayer() and k:GetVelocity():Length() > 75) then
                 -- self:Detonate()
		-- k:Ignite( 5 )
				 -- else
		if k:IsNPC() or k:IsPlayer() then
		-- k:Ignite( 8 )
		self:Detonate()
				 end
		 if (k:IsValid() and scripted_ents.IsBasedOn( k:GetClass(), "base_nextbot" ) and (!k.FriendlyToPlayers or k:GetOwner()!=self.Owner) ) then
                    self:Detonate()
			-- k:Ignite( 8 ) 
                end
            end
        end
    end


function ENT:Draw()
        self:DrawModel()
		-- if self.Armed then
            cam.Start3D() -- Start the 3D function so we can draw onto the screen.
                render.SetMaterial( Material("effects/swbf/flare1") ) -- Tell render what material we want, in this case the flash from the gravgun
                render.DrawSprite( self:GetPos(), math.random(8, 32), math.random(8, 32), Color(255, 50, 50) ) -- Draw the sprite in the middle of the map, at 16x16 in it's original colour with full alpha.
            cam.End3D()
        -- end
end
--addons/lvs_addons/lua/entities/lfs_tx-427_main_imperial.lua:
AddCSLuaFile()

ENT.Type = "anim"

if SERVER then
	function ENT:Initialize()	
		self:SetModel( "models/weapons/w_missile_launch.mdl" )
		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )
		self:SetRenderMode( RENDERMODE_TRANSALPHA )
		self:PhysWake()
		self:SetCollisionGroup( COLLISION_GROUP_WORLD )

		local pObj = self:GetPhysicsObject()
		if IsValid( pObj ) then
			pObj:EnableGravity( false ) 
			pObj:SetMass( 1 ) 
		end

		self.SpawnTime = CurTime()
	end
	
	function ENT:Think()
		if self.SpawnTime + 12 < CurTime() then
			self:Detonate()
		end
		
		local pObj = self:GetPhysicsObject()
		if IsValid( pObj ) then
			pObj:SetVelocityInstantaneous( self:GetForward() * 4000 )
		end
	end

	function ENT:Detonate()
		util.BlastDamage( IsValid( self.inflictor ) and self.inflictor or self, IsValid( self.attacker ) and self.attacker or self, self:GetPos(), 100, 200 )

		local effectdata = EffectData()
			effectdata:SetOrigin( self:GetPos() )
		util.Effect( "lfs_tx-427_main_explosion_red", effectdata )

		self:Remove()
	end

	function ENT:PhysicsCollide( data )
		self:Detonate()
	end
else
	local mat = Material( "sprites/light_glow02_add" )
	local mat_laser = Material( "effects/spark" )
	local blue = Color(255,0,0,255)
	local white = Color(255,255,255,255)
	function ENT:Draw()
		local pos = self:GetPos()
		local dir = self:GetForward()
		local length = 100

		render.SetMaterial( mat_laser )
		render.DrawBeam( pos + dir * length, pos, 40, 1, 0, blue )
		render.DrawBeam( pos + dir * length, pos, 15, 1, 0, white )

		render.SetMaterial( mat )
		render.DrawSprite( pos + dir * length * 0.3, 100, 100, blue )
		render.DrawSprite( pos + dir * length * 0.45, 100, 100, blue )
		render.DrawSprite( pos + dir * length * 0.6, 100, 100, blue )
		render.DrawSprite( pos + dir * length * 0.75, 100, 100, blue )
		render.DrawSprite( pos + dir * length * 0.9, 100, 100, blue )
	end
end
--addons/weapon_jedi/lua/entities/lscs_crystal_base.lua:
AddCSLuaFile()

ENT.Base = "lscs_pickupable"
DEFINE_BASECLASS( "lscs_pickupable" )

ENT.Spawnable       = false
ENT.AdminSpawnable  = false

ENT.PickupSound = "physics/metal/metal_grenade_impact_hard1.wav"
ENT.ImpactHardSound = "Rock.ImpactHard"
ENT.ImpactSoftSound = "Rock.ImpactSoft"

if SERVER then
	function ENT:Initialize()
		self:SetModel( "models/props_junk/rock001a.mdl" )

		self:SetMaterial("lights/white")
		self:SetColor( LSCS:GetBlade( self.ID ).color_core )
		self:DrawShadow( false )

		self:SetModelScale( 0.5 )

		BaseClass.Initialize( self )
	end
else
	local mat = Material( "sprites/light_glow02_add" )
	function ENT:DrawTranslucent()
		self:DrawModel()

		if not self.col then
			self.col = LSCS:GetBlade( self.ID ).color_blur
		end

		render.SetMaterial( mat )
		render.DrawSprite( self:GetPos(), 64, 64, self.col )
	end

	function ENT:Draw()
	end
end
--addons/lvs_addons/lua/entities/lunasflightschool_niksacokica_tx-427_imperial/shared.lua:

ENT.Base = "lvs_base_fakehover"

ENT.PrintName = "TX-427 [Imperial Variant]"
ENT.Author = "kavtehman and xn"
ENT.Category = "[LVS] - Orbital Vehicles"

ENT.Spawnable			= false
ENT.AdminSpawnable		= false

ENT.MDL = "models/lfs_vehicles/tx427/tx427_imperial_static.mdl"
ENT.GibModels = {
	"models/gibs/helicopter_brokenpiece_01.mdl",
	"models/gibs/helicopter_brokenpiece_02.mdl",
	"models/gibs/helicopter_brokenpiece_03.mdl",
	"models/combine_apc_destroyed_gib02.mdl",
	"models/combine_apc_destroyed_gib04.mdl",
	"models/combine_apc_destroyed_gib05.mdl",
	"models/props_c17/trappropeller_engine.mdl",
	"models/gibs/airboat_broken_engine.mdl",
}

ENT.AITEAM = 1

ENT.MaxHealth = 3500

ENT.ForceAngleMultiplier = 2
ENT.ForceAngleDampingMultiplier = 1

ENT.ForceLinearMultiplier = 1
ENT.ForceLinearRate = 0.25

ENT.MaxVelocityX = 250
ENT.MaxVelocityY = 180

ENT.MaxTurnRate = 0.5

ENT.BoostAddVelocityX = 120
ENT.BoostAddVelocityY = 120

ENT.GroundTraceHitWater = true
ENT.GroundTraceLength = 50
ENT.GroundTraceHull = 100

ENT.TurretTurnRate = 100

ENT.RotorPos = Vector(-130, 0, 100)

ENT.LAATC_PICKUPABLE = true
ENT.LAATC_DROP_IN_AIR = true
ENT.LAATC_PICKUP_POS = Vector(-200,0,25)
ENT.LAATC_PICKUP_Angle = Angle(0,0,0)

function ENT:OnSetupDataTables()
	self:AddDT( "Bool", "IsCarried" )
	self:AddDT( "Entity", "GunnerSeat" )
	self:AddDT( "Entity", "CoDriver" )
	self:AddDT( "Entity", "CoSeat" )
	self:AddDT( "Float", "TurretPitch" )
	self:AddDT( "Float", "TurretYaw" )

	if SERVER then
		self:NetworkVarNotify( "IsCarried", self.OnIsCarried )
	end
end
function ENT:OnIsCarried( name, old, new)
	if new == old then return end
	if new then
		self:SetPoseParameter("blasters_left_yaw", 0 )
		self:SetPoseParameter("blasters_left_pitch", 0 )

		self:SetPoseParameter("blasters_right_yaw", 0 )
		self:SetPoseParameter("blasters_right_pitch", 0 )
		
		self:SetPoseParameter("missiles_left_pitch", 0 )
		self:SetPoseParameter("missiles_right_pitch", 0 )
		self:SetDisabled( true )
	else
		self:SetDisabled( false )
	end
end

function ENT:GetEyeTrace()
	local startpos = self:GetPos()

	local pod = self:GetDriverSeat()

	if IsValid( pod ) then
		startpos = pod:LocalToWorld( Vector(0,0,33) )
	end

	local trace = util.TraceLine( {
		start = startpos,
		endpos = (startpos + self:GetAimVector() * 50000),
		filter = self:GetCrosshairFilterEnts()
	} )

	return trace
end

function ENT:GetAimAngles()
	local trace = self:GetEyeTrace()

	local AimAnglesR = self:WorldToLocalAngles( (trace.HitPos - self:LocalToWorld( Vector(10,-60,81) ) ):GetNormalized():Angle() )
	local AimAnglesL = self:WorldToLocalAngles( (trace.HitPos - self:LocalToWorld( Vector(10,60,81) ) ):GetNormalized():Angle() )

	return AimAnglesR, AimAnglesL
end

function ENT:WeaponsInRange()
	if self:GetIsCarried() then return false end

	local AimAnglesR, AimAnglesL = self:GetAimAngles()

	return not ((AimAnglesR.p >= 30 and AimAnglesL.p >= 30) or (AimAnglesR.p <= -25 and AimAnglesL.p <= -25) or (math.abs(AimAnglesL.y) + math.abs(AimAnglesL.y)) >= 60)
end

function ENT:InitWeapons()
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/missile.png")
	weapon.Ammo = 32
	weapon.Delay = 0.3
	weapon.HeatRateUp = 0
	weapon.HeatRateDown = 0.2
	weapon.Attack = function( ent )
		if not ent:WeaponsInRange() then return true end
		local turretPos = ent.directionTurretPos or "right"
		local turretYPos = ent.turrentColumnPos or 0
		local turretXPos = ent.turrentRowPox or 0

		local newMuzzle = "missiles_" .. turretPos .. "_muzzle_" .. turretYPos .. (turretPos == "right" and turretXPos or 3 - turretXPos)

		local Driver = ent:GetDriver()

		if not IsValid( ent ) then return end
		ent:TakeAmmo()

		local att = self:LookupAttachment(newMuzzle)

		local pos1 = self:GetAttachment( att ).Pos
		local ang1 = ( -self:GetAttachment( att ).Ang:Right() ):Angle()
		local projectile = ents.Create( "lvs_concussionmissile" )
		projectile:SetPos( pos1 )
		projectile:SetAngles( ang1 )
		projectile:SetParent( ent )
		projectile:Spawn()
		projectile:Activate()
		projectile.GetTarget = function( missile ) return missile end
		projectile.GetTargetPos = function( missile )
			return missile:LocalToWorld( Vector(150,0,0) + VectorRand() * math.random(-15,15) )
		end
		projectile:SetAttacker( IsValid( Driver ) and Driver or self )
		projectile:SetEntityFilter( ent:GetCrosshairFilterEnts() )
		projectile:SetSpeed( 4000 )
		projectile:SetDamage( 400 )
		projectile:SetRadius( 200 )
		projectile:Enable()
		projectile:EmitSound( "LVS.IFTX.FIRE_MISSILE" )

		if turretPos == "right" then
			ent.directionTurretPos = "left"
		else
			ent.directionTurretPos = "right"
			if turretXPos == 3 then
				ent.turrentRowPox = 0
				if turretYPos == 3 then
					ent.turrentColumnPos = 0
				else
					ent.turrentColumnPos = turretYPos + 1
				end
			else
				ent.turrentRowPox = turretXPos + 1
			end
		end
	end
	weapon.OnThink = function( ent, active )
		if ent:GetIsCarried() then
			self:SetPoseParameter("missiles_right_pitch", 0 )
			self:SetPoseParameter("missiles_right_yaw", 0 )

			self:SetPoseParameter("missiles_left_pitch", 0 )
			self:SetPoseParameter("missiles_left_yaw", 0 )

			return
		end

		local AimAnglesR, AimAnglesL = ent:GetAimAngles()

		self:SetPoseParameter("missiles_right_pitch", -AimAnglesR.p )
		self:SetPoseParameter("missiles_right_yaw", -AimAnglesR.y )

		self:SetPoseParameter("missiles_left_pitch", -AimAnglesL.p )
		self:SetPoseParameter("missiles_left_yaw", -AimAnglesL.y )
	end
	self:AddWeapon( weapon )


	local COLOR_RED = Color(255,0,0,255)
	local COLOR_WHITE = Color(255,255,255,255)
	self.RearGunAngleRange = 35

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Ammo = -1
	weapon.Delay = 0.6
	weapon.HeatRateUp = 0.02
	weapon.HeatRateDown = 0.03
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	weapon.Attack = function( ent )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		if ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) > base.RearGunAngleRange then return true end

		local trace = ent:GetEyeTrace()

		local Pos,Ang = WorldToLocal( Vector(0,0,0), (trace.HitPos - self:LocalToWorld( Vector(-400,0,158.5)) ):GetNormalized():Angle(), Vector(0,0,0), self:LocalToWorldAngles( Angle(0,180,0) ) )

		if not IsValid( ent ) then return end
		ent:TakeAmmo()

		local mru = self:LookupAttachment( "blaster_right_muzzle_up" ) 
		local RightMuzzleUp = self:GetAttachment(mru)
		local mrd = self:LookupAttachment( "blaster_right_muzzle_down" ) 
		local RightMuzzleDown = self:GetAttachment(mrd)

		local mlu = self:LookupAttachment( "blaster_left_muzzle_up" ) 
		local LeftMuzzleUp = self:GetAttachment(mlu)
		local mld = self:LookupAttachment( "blaster_left_muzzle_down" ) 
		local LeftMuzzleDown = self:GetAttachment(mld)

		if not RightMuzzleUp or not RightMuzzleDown or not LeftMuzzleUp or not LeftMuzzleDown then return end
		local muzzles = { RightMuzzleUp, LeftMuzzleUp, RightMuzzleDown, LeftMuzzleDown }
		self:EmitSound( "niksacokica/tx-427/cannon_small.wav" )

		for i, muzzle in ipairs( muzzles ) do
			local bullet = {}
			bullet.Src 	= muzzle.Pos
			bullet.Dir 	= (trace.HitPos - muzzle.Pos):GetNormalized()
			bullet.Spread 	= Vector( 0.015,  0.015, 0.01 )
			bullet.TracerName = "lvs_laser_red"
			bullet.Force	= 100
			bullet.HullSize 	= 1
			bullet.Damage	= 16
			bullet.Velocity = 40000
			bullet.Attacker 	= ent:GetDriver()
			bullet.Callback = function(att, tr, dmginfo)
				local effectdata = EffectData()
					effectdata:SetStart( Vector(255,50,50) ) 
					effectdata:SetOrigin( tr.HitPos )
					effectdata:SetNormal( tr.HitNormal )
				util.Effect( "lvs_laser_impact", effectdata )
			end
			ent:LVSFireBullet( bullet )
		end
		
		ent:TakeAmmo()

		if ent.MirrorPrimary then
			if not IsValid( ent.SNDLeft ) then return end
			ent.SNDLeft:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
			return
		end
		
	end	

	weapon.OnThink = function( ent, active )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		

		local trace = ent:GetEyeTrace()

        local _,AimAnglesR = WorldToLocal(Vector(0,0,0),(trace.HitPos - self:LocalToWorld( Vector(-400,0,158.5)) ):GetNormalized():Angle(), Vector(0,0,0), self:LocalToWorldAngles( Angle(0,0,0) ) )
        local _,AimAnglesL = WorldToLocal(Vector(0,0,0),(trace.HitPos - self:LocalToWorld( Vector(-400,0,158.5)) ):GetNormalized():Angle(), Vector(0,0,0), self:LocalToWorldAngles( Angle(0,0,0) ) )

		base:SetPoseParameter("blasters_right_pitch", -AimAnglesR.p )
		base:SetPoseParameter("blasters_right_yaw",  AimAnglesR.y )

		base:SetPoseParameter("blasters_left_pitch", -AimAnglesL.p )
		base:SetPoseParameter("blasters_left_yaw", AimAnglesL.y )
		
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		local RearGunInRange = ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) > base.RearGunAngleRange

		local Col = RearGunInRange and COLOR_RED or COLOR_WHITE

		local Pos2D = ent:GetEyeTrace().HitPos:ToScreen() 

		base:PaintCrosshairCenter( Pos2D, Col )
		base:PaintCrosshairOuter( Pos2D, Col )
		base:LVSPaintHitMarker( Pos2D )
	end
	self:AddWeapon( weapon, 3 )

	self:InitTurret()
end

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/iftx/loop.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 85,
	},
	{
		sound = "lvs/vehicles/iftx/loop_hi.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 85,
	},
	{
		sound = "^lvs/vehicles/iftx/dist.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		SoundLevel = 90,
	},
}

sound.Add( {
	name = "LVS.IFTX.FIRE_MISSILE",
	channel = CHAN_WEAPON,
	volume = 1.0,
	level = 125,
	pitch = {95, 105},
	sound = "lvs/vehicles/iftx/fire_missile.mp3"
} )

--addons/lvs_addons/lua/entities/lvs_base_fakehover/cl_hud.lua:

ENT.IconEngine = Material( "lvs/engine.png" )

function ENT:LVSHudPaintInfoText( X, Y, W, H, ScrX, ScrY, ply )
	local kmh = math.Round(self:GetVelocity():Length() * 0.09144,0)
	draw.DrawText( "km/h ", "LVS_FONT", X + 72, Y + 35, color_white, TEXT_ALIGN_RIGHT )
	draw.DrawText( kmh, "LVS_FONT_HUD_LARGE", X + 72, Y + 20, color_white, TEXT_ALIGN_LEFT )

	if ply ~= self:GetDriver() then return end

	local hX = X + W - H * 0.5
	local hY = Y + H * 0.25 + H * 0.25

	surface.SetMaterial( self.IconEngine )
	surface.SetDrawColor( 0, 0, 0, 200 )
	surface.DrawTexturedRectRotated( hX + 4, hY + 1, H * 0.5, H * 0.5, 0 )
	surface.SetDrawColor( color_white )
	surface.DrawTexturedRectRotated( hX + 2, hY - 1, H * 0.5, H * 0.5, 0 )

	if not self:GetEngineActive() then
		draw.SimpleText( "X" , "LVS_FONT",  hX, hY, Color(0,0,0,255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	else
		self:LVSDrawCircle( hX, hY, H * 0.35, self:GetThrottle() )
	end
end

function ENT:LVSPreHudPaint( X, Y, ply )
	return true
end

local zoom = 0
local zoom_mat = Material( "vgui/zoom" )

function ENT:PaintZoom( X, Y, ply )
	local TargetZoom = ply:lvsKeyDown( "ZOOM" ) and 1 or 0

	zoom = zoom + (TargetZoom - zoom) * RealFrameTime() * 10

	X = X * 0.5
	Y = Y * 0.5

	surface.SetDrawColor( Color(255,255,255,255 * zoom) )
	surface.SetMaterial(zoom_mat ) 
	surface.DrawTexturedRectRotated( X + X * 0.5, Y * 0.5, X, Y, 0 )
	surface.DrawTexturedRectRotated( X + X * 0.5, Y + Y * 0.5, Y, X, 270 )
	surface.DrawTexturedRectRotated( X * 0.5, Y * 0.5, Y, X, 90 )
	surface.DrawTexturedRectRotated( X * 0.5, Y + Y * 0.5, X, Y, 180 )
end

function ENT:LVSHudPaint( X, Y, ply )
	if not self:LVSPreHudPaint( X, Y, ply ) then return end

	self:PaintZoom( X, Y, ply )
end

--addons/lvs_addons/lua/entities/lvs_base_repulsorlift/cl_init.lua:
include("shared.lua")

--addons/lvs_addons/lua/entities/lvs_fakehover_iftx/shared.lua:

ENT.Base = "lvs_base_fakehover"

ENT.PrintName = "IFT-X"
ENT.Author = "Luna"
ENT.Information = "Hover Tank of the Galactic Republic"
ENT.Category = "[LVS] - Star Wars"

ENT.VehicleCategory = "Star Wars"
ENT.VehicleSubCategory = "Hover Tanks"

ENT.Spawnable			= false
ENT.AdminSpawnable		= false

ENT.MDL = "models/blu/iftx.mdl"
ENT.GibModels = {
	"models/gibs/helicopter_brokenpiece_01.mdl",
	"models/gibs/helicopter_brokenpiece_02.mdl",
	"models/gibs/helicopter_brokenpiece_03.mdl",
	"models/combine_apc_destroyed_gib02.mdl",
	"models/combine_apc_destroyed_gib04.mdl",
	"models/combine_apc_destroyed_gib05.mdl",
	"models/props_c17/trappropeller_engine.mdl",
	"models/gibs/airboat_broken_engine.mdl",
}

ENT.AITEAM = 2

ENT.MaxHealth = 2000

ENT.ForceAngleMultiplier = 2
ENT.ForceAngleDampingMultiplier = 1

ENT.ForceLinearMultiplier = 1
ENT.ForceLinearRate = 0.25

ENT.MaxVelocityX = 180
ENT.MaxVelocityY = 180

ENT.MaxTurnRate = 0.5

ENT.BoostAddVelocityX = 120
ENT.BoostAddVelocityY = 120

ENT.GroundTraceHitWater = true
ENT.GroundTraceLength = 50
ENT.GroundTraceHull = 100

ENT.LAATC_PICKUPABLE = true
ENT.LAATC_DROP_IN_AIR = true
ENT.LAATC_PICKUP_POS = Vector(-200,0,25)
ENT.LAATC_PICKUP_Angle = Angle(0,0,0)

function ENT:OnSetupDataTables()
	self:AddDT( "Bool", "BTLFire" )
	self:AddDT( "Bool", "IsCarried" )
	self:AddDT( "Entity", "GunnerSeat" )

	if SERVER then
		self:NetworkVarNotify( "IsCarried", self.OnIsCarried )
	end
end

function ENT:GetAimAngles()
	local trace = self:GetEyeTrace()

	local AimAnglesR = self:WorldToLocalAngles( (trace.HitPos - self:LocalToWorld( Vector(-60,-51,43) ) ):GetNormalized():Angle() )
	local AimAnglesL = self:WorldToLocalAngles( (trace.HitPos - self:LocalToWorld( Vector(-60,51,43) ) ):GetNormalized():Angle() )

	return AimAnglesR, AimAnglesL
end

function ENT:WeaponsInRange()
	if self:GetIsCarried() then return false end

	local AimAnglesR, AimAnglesL = self:GetAimAngles()

	return not ((AimAnglesR.p >= 10 and AimAnglesL.p >= 10) or (AimAnglesR.p <= -25 and AimAnglesL.p <= -25) or (math.abs(AimAnglesL.y) + math.abs(AimAnglesL.y)) >= 30)
end

function ENT:InitWeapons()
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Ammo = 600
	weapon.Delay = 0.2
	weapon.HeatRateUp = 0.25
	weapon.HeatRateDown = 0.25
	weapon.Attack = function( ent )
		if not ent:WeaponsInRange() then return true end

		local ID_L = ent:LookupAttachment( "muzzle_left" )
		local ID_R = ent:LookupAttachment( "muzzle_right" )
		local MuzzleL = ent:GetAttachment( ID_L )
		local MuzzleR = ent:GetAttachment( ID_R )

		if not MuzzleL or not MuzzleR then return end

		ent.MirrorPrimary = not ent.MirrorPrimary

		local Pos = ent.MirrorPrimary and MuzzleL.Pos or MuzzleR.Pos
		local Dir =  (ent.MirrorPrimary and MuzzleL.Ang or MuzzleR.Ang):Up()

		local bullet = {}
		bullet.Src 	= Pos
		bullet.Dir 	= Dir
		bullet.Spread 	= Vector( 0.01,  0.01, 0 )
		bullet.TracerName = "lvs_laser_blue_long"
		bullet.Force	= 10000
		bullet.HullSize 	= 1
		bullet.Damage	= 25
		bullet.Velocity = 40000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(50,50,255) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_impact", effectdata )
		end
		ent:LVSFireBullet( bullet )

		local effectdata = EffectData()
		effectdata:SetStart( Vector(50,50,255) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( Dir )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )

		ent:TakeAmmo()

		if ent.MirrorPrimary then
			ent:PlayAnimation( "fire_left" )
	
			if not IsValid( ent.SNDLeft ) then return end
	
			ent.SNDLeft:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )

			return
		end

		ent:PlayAnimation( "fire_right" )

		if not IsValid( ent.SNDRight ) then return end

		ent.SNDRight:PlayOnce( 100 + math.sin( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	weapon.OnThink = function( ent, active )
		if ent:GetIsCarried() then
			self:SetPoseParameter("cannon_right_pitch", 0 )
			self:SetPoseParameter("cannon_right_yaw", 0 )

			self:SetPoseParameter("cannon_left_pitch", 0 )
			self:SetPoseParameter("cannon_left_yaw", 0 )

			return
		end

		local AimAnglesR, AimAnglesL = ent:GetAimAngles()

		self:SetPoseParameter("cannon_right_pitch", AimAnglesR.p )
		self:SetPoseParameter("cannon_right_yaw", AimAnglesR.y )

		self:SetPoseParameter("cannon_left_pitch", AimAnglesL.p )
		self:SetPoseParameter("cannon_left_yaw", AimAnglesL.y )
	end
	self:AddWeapon( weapon )


	local weapon = {}
	weapon.Icon = Material("lvs/weapons/missile.png")
	weapon.Ammo = 60
	weapon.Delay = 1
	weapon.HeatRateUp = 0
	weapon.HeatRateDown = 0.2
	weapon.Attack = function( ent )
		if not ent:WeaponsInRange() then return true end

		local Driver = ent:GetDriver()

		for i = 1, 6 do
			timer.Simple( (i / 5) * 0.75, function()
				if not IsValid( ent ) then return end

				if ent:GetAmmo() <= 0 then ent:SetHeat( 1 ) return end
	
				ent:TakeAmmo()

				local ID_L = ent:LookupAttachment( "muzzle_left" )
				local ID_R = ent:LookupAttachment( "muzzle_right" )
				local MuzzleL = ent:GetAttachment( ID_L )
				local MuzzleR = ent:GetAttachment( ID_R )

				if not MuzzleL or not MuzzleR then return end

				ent.MirrorPrimary = not ent.MirrorPrimary

				local Pos = ent.MirrorPrimary and MuzzleL.Pos or MuzzleR.Pos
				local Dir =  (ent.MirrorPrimary and MuzzleL.Ang or MuzzleR.Ang):Up()

				local projectile = ents.Create( "lvs_concussionmissile" )
				projectile:SetPos( Pos )
				projectile:SetAngles( Dir:Angle() )
				projectile:SetParent( ent )
				projectile:Spawn()
				projectile:Activate()
				projectile.GetTarget = function( missile ) return missile end
				projectile.GetTargetPos = function( missile )
					return missile:LocalToWorld( Vector(150,0,0) + VectorRand() * math.random(-10,10) )
				end
				projectile:SetAttacker( IsValid( Driver ) and Driver or self )
				projectile:SetEntityFilter( ent:GetCrosshairFilterEnts() )
				projectile:SetDamage( 300 )
				projectile:SetRadius( 150 )
				projectile:Enable()
				projectile:EmitSound( "LVS.IFTX.FIRE_MISSILE" )

				if ent.MirrorPrimary then
					ent:PlayAnimation( "fire_left" )
				else
					ent:PlayAnimation( "fire_right" )
				end
			end)
		end

		ent:SetHeat( 1 )
		ent:SetOverheated( true )
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("weapons/shotgun/shotgun_cock.wav")
	end
	self:AddWeapon( weapon )

	self:InitTurret()
end

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/iftx/loop.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 85,
	},
	{
		sound = "lvs/vehicles/iftx/loop_hi.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 85,
	},
	{
		sound = "^lvs/vehicles/iftx/dist.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		SoundLevel = 90,
	},
}

sound.Add( {
	name = "LVS.IFTX.FIRE_MISSILE",
	channel = CHAN_WEAPON,
	volume = 1.0,
	level = 125,
	pitch = {95, 105},
	sound = "lvs/vehicles/iftx/fire_missile.mp3"
} )

--lua/entities/lvs_fakehover_mtt/cl_init.lua:
include("shared.lua")
include("cl_prediction.lua")

function ENT:OnSpawn()
    local mins, maxs = self:GetRenderBounds()
    self:SetRenderBounds(mins, maxs, Vector( 80, 0, 0 ))
end

function ENT:DamageFX()
	self.nextDFX = self.nextDFX or 0

	if self.nextDFX < CurTime() then
		self.nextDFX = CurTime() + 0.05

		local HP = self:GetHP()
		local MaxHP = self:GetMaxHP()

		if HP > MaxHP * 0.5 then return end

		local effectdata = EffectData()
			effectdata:SetOrigin( self:LocalToWorld( Vector(11,0,46) ) )
			effectdata:SetEntity( self )
		util.Effect( "lvs_engine_blacksmoke", effectdata )

		if HP <= MaxHP * 0.25 then
			local effectdata = EffectData()
				effectdata:SetOrigin( self:LocalToWorld( Vector(11,40,46) ) )
				effectdata:SetNormal( self:GetUp() )
				effectdata:SetMagnitude( math.Rand(0.5,1.5) )
				effectdata:SetEntity( self )
			util.Effect( "lvs_exhaust_fire", effectdata )

			local effectdata = EffectData()
				effectdata:SetOrigin( self:LocalToWorld( Vector(11,-40,46) ) )
				effectdata:SetNormal( self:GetUp() )
				effectdata:SetMagnitude( math.Rand(0.5,1.5) )
				effectdata:SetEntity( self )
			util.Effect( "lvs_exhaust_fire", effectdata )
		end
	end
end

function ENT:OnFrame()
	self:PredictPoseParamaters()
	self:DamageFX()
end

function ENT:CalcViewOverride( ply, pos, angles, fov, pod )
	if ply == self:GetDriver() and not pod:GetThirdPersonMode() then
		return pos + self:GetForward() * 395 - self:GetUp() * -50, angles, fov
	end

	return pos + self:GetForward() * -100 - self:GetUp() * -300, angles, fov
end

local COLOR_RED = Color(255,0,0,255)
local COLOR_WHITE = Color(255,255,255,255)

function ENT:LVSPreHudPaint( X, Y, ply )
	if self:GetIsCarried() then return false end

	if ply == self:GetDriver() then
		local Col = self:WeaponsInRange() and COLOR_WHITE or COLOR_RED

		local Pos2D = self:GetEyeTrace().HitPos:ToScreen() 

		self:PaintCrosshairCenter( Pos2D, Col )
		self:PaintCrosshairOuter( Pos2D, Col )
		self:LVSPaintHitMarker( Pos2D )
	end

	return true
end
--addons/lvs_addons/lua/entities/lvs_laatle_patrolgunship_rep/shared.lua:
ENT.Base = "lvs_base_repulsorlift"

ENT.PrintName = "LAAT/le Gunship"
ENT.Author = "Durian"
ENT.Information = ""
ENT.Category = "[LVS] - Republik"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/kingpommes/starwars/patrol_transport/main.mdl"
ENT.GibModels = {
}

ENT.AITEAM = 2

ENT.MaxVelocity = 1250
ENT.MaxThrust = 1250

ENT.MaxPitch = 60

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 2

ENT.TurnRatePitch = 0.7
ENT.TurnRateYaw = 0.7
ENT.TurnRateRoll = 0.66

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 700
ENT.MaxShield = 400

function ENT:OnSetupDataTables()
	self:AddDT( "Bool", "WingsDown" )
	self:AddDT( "Entity", "GunnerSeat" )
	self:AddDT( "Bool", "SpotlightToggle" )
	self:AddDT( "Bool", "DoorsClose")

	if SERVER or CLIENT then
		self:NetworkVarNotify( "WingsDown", self.OnWingsChanged )
	end
end

function ENT:InitWeapons()

	local weapon = {}
		weapon.Icon = Material("lvs/weapons/concussionmissile.png")
		weapon.Ammo = 20
		weapon.Delay = 0 -- this will turn weapon.Attack to a somewhat think function
		weapon.HeatRateUp = -0.5 -- cool down when attack key is held. This system fires on key-release.
		weapon.HeatRateDown = 0.25
		weapon.Attack = function( ent )
			local T = CurTime()

			if IsValid( ent._ConcussionMissile ) then
				if (ent._nextMissleTracking or 0) > T then return end

				ent._nextMissleTracking = T + 0.1 -- 0.1 second interval because those find functions can be expensive

				ent._ConcussionMissile:FindTarget( ent:GetPos(), ent:GetForward(), 30, 7500 )

				return
			end

			if (ent._nextMissle or 0) > T then return end

			ent._nextMissle = T + 0.5

			ent._swapMissile = not ent._swapMissile

			local Pos = Vector( 180, (ent._swapMissile and -35 or 35), 20 )Vector(180.79,35.9,22.68)

			local Driver = self:GetDriver()

			local projectile = ents.Create( "lvs_concussionmissile" )
			projectile:SetPos( ent:LocalToWorld( Pos ) )
			projectile:SetAngles( ent:GetAngles() )
			projectile:SetParent( ent )
			projectile:Spawn()
			projectile:Activate()
			projectile:SetAttacker( IsValid( Driver ) and Driver or self )
			projectile:SetEntityFilter( ent:GetCrosshairFilterEnts() )
			projectile:SetSpeed( ent:GetVelocity():Length() + 4000 )
			projectile:SetDamage( 800 )
			projectile:SetRadius( 300 )

			ent._ConcussionMissile = projectile

			ent:SetNextAttack( CurTime() + 0.1 ) -- wait 0.1 second before starting to track
		end
		weapon.FinishAttack = function( ent )
			if not IsValid( ent._ConcussionMissile ) then return end

			local projectile = ent._ConcussionMissile

			projectile:Enable()
			projectile:EmitSound( "lvs/vehicles/vulturedroid/fire_missile.mp3", 125 )
			ent:TakeAmmo()

			ent._ConcussionMissile = nil

			local NewHeat = ent:GetHeat() + 0.75

			ent:SetHeat( NewHeat )
			if NewHeat >= 1 then
				ent:SetOverheated( true )
			end
		end
		weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
		weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/vehicles/imperial/overheat.wav") end
	self:AddWeapon( weapon )

	local weapon = {}		
		weapon.Icon = Material("lvs/weapons/dual_hmg.png")
		weapon.Ammo = 1250
		weapon.Delay = 0.25
		weapon.HeatRateUp = 0.3
		weapon.HeatRateDown = 0.3
		weapon.Attack = function( ent )
			local pod = ent:GetDriverSeat()

			if not IsValid( pod ) then return end

			if ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) >= 61 then return true end

			ent.FirePositions = {
				Vector(180.79,-35.9,22.68),
				Vector(180.79,35.9,22.68)
,
			}
			
			
			ent.NumPrim = ent.NumPrim and ent.NumPrim + 1 or 1
			if ent.NumPrim > #ent.FirePositions then ent.NumPrim = 1 end

			local startpos = pod:LocalToWorld( pod:OBBCenter() )
			local trace = ent:GetEyeTrace()

			local bullet = {}
			bullet.Src 	= ent:LocalToWorld( ent.FirePositions[ent.NumPrim] )
			bullet.Dir 	= (trace.HitPos - bullet.Src):GetNormalized()
			bullet.Spread 	= Vector( 0.01,  0.01, 0.01 )
			bullet.TracerName = "lvs_laser_green"
			bullet.Force	= 10
			bullet.HullSize 	= 25
			bullet.Damage	= 60
			bullet.Velocity = 60000
			bullet.Attacker 	= ent:GetDriver()
			bullet.Callback = function(att, tr, dmginfo)
				local effectdata = EffectData()
					effectdata:SetStart( Vector(50,255,50) ) 
					effectdata:SetOrigin( tr.HitPos )
					effectdata:SetNormal( tr.HitNormal )
				util.Effect( "lvs_laser_impact", effectdata )
			end
			ent:LVSFireBullet( bullet )

			local effectdata = EffectData()
			effectdata:SetStart( Vector(50,255,50) )
			effectdata:SetOrigin( bullet.Src )
			effectdata:SetNormal( ent:GetForward() )
			effectdata:SetEntity( ent )
			util.Effect( "lvs_muzzle_colorable", effectdata )

			ent:TakeAmmo()

			veh = ent:GetVehicle()

			veh.PrimarySND:PlayOnce( 100 + math.cos( CurTime() + self:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
		end
		weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
		weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/vehicles/imperial/overheat.wav") end
		weapon.CalcView = function( ent, ply, pos, angles, fov, pod )
			local base = ent:GetVehicle()

			if not IsValid( base ) then 
				return LVS:CalcView( ent, ply, pos, angles, fov, pod )
			end

			if pod:GetThirdPersonMode() then
				pos = pos + base:GetUp() * 100
			end

			return LVS:CalcView( base, ply, pos, angles, fov, pod )
		end
		weapon.HudPaint = function( ent, X, Y, ply )
			local Col = (ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) > 60) and COLOR_RED or COLOR_WHITE

			local Pos2D = ent:GetEyeTrace().HitPos:ToScreen() 

			local base = ent:GetVehicle()
			base:PaintCrosshairCenter( Pos2D, Col )
			base:PaintCrosshairOuter( Pos2D, Col )
			base:LVSPaintHitMarker( Pos2D )
		end
		weapon.CalcView = function( ent, ply, pos, angles, fov, pod )
			local view = {}
			view.origin = pos
			view.angles = angles
			view.fov = fov
			view.drawviewer = false

			local mn = self:OBBMins()
			local mx = self:OBBMaxs()
			local radius = ( mn - mx ):Length()
			local radius = radius + radius * pod:GetCameraDistance()

			local clamped_angles = pod:WorldToLocalAngles( angles )
			clamped_angles.p = math.max( clamped_angles.p, -20 )
			clamped_angles = pod:LocalToWorldAngles( clamped_angles )

			local StartPos = self:LocalToWorld( Vector(-150,0,150) ) + clamped_angles:Up() * 150
			local EndPos = StartPos - clamped_angles:Forward() * radius + clamped_angles:Up() * radius * 0.2

			local WallOffset = 4

			local tr = util.TraceHull( {
				start = StartPos,
				endpos = EndPos,
				filter = function( e )
					local c = e:GetClass()
					local collide = not c:StartWith( "prop_physics" ) and not c:StartWith( "prop_dynamic" ) and not c:StartWith( "prop_ragdoll" ) and not e:IsVehicle() and not c:StartWith( "gmod_" ) and not c:StartWith( "lvs_" ) and not c:StartWith( "player" ) and not e.LVS

					return collide
				end,
				mins = Vector( -WallOffset, -WallOffset, -WallOffset ),
				maxs = Vector( WallOffset, WallOffset, WallOffset ),
			} )

			view.angles = angles + Angle(5,0,0)
			view.origin = tr.HitPos
			view.drawviewer = true

			if tr.Hit and  not tr.StartSolid then
				view.origin = view.origin + tr.HitNormal * WallOffset
			end

			return view
		end
	self:AddWeapon( weapon, 2 )

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/spotlight.png")
	weapon.Ammo = -1
	weapon.Delay = 0.1
	weapon.HeatRateUp = 0
	weapon.HeatRateDown = 1
	weapon.StartAttack = function( ent )
		if self:GetSpotlightToggle() == true then
			self:SetSpotlightToggle(false)
		else
			self:SetSpotlightToggle(true)
		end
	end
	self:AddWeapon( weapon )

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/gunship_sidedoor.png")
	weapon.Ammo = -1
	weapon.Delay = 0
	weapon.HeatRateUp = 0
	weapon.HeatRateDown = 0
	weapon.StartAttack = function( ent )
		if self:GetAI() then return end
	
		if self.t1 > CurTime() then return end
		if(self.Doors:GetSequence() == self.Doors:LookupSequence("DoorsOpen")) then
			self.Doors:ResetSequence(self.Doors:LookupSequence("DoorsClose"))
			self:SetDoorsClose(false)
		else				
			self.Doors:ResetSequence(self.Doors:LookupSequence("DoorsOpen"))
			self:SetDoorsClose(true)
		end
		self.t1 = CurTime() + 0.5
	end
	self:AddWeapon( weapon )
end

ENT.FlyByAdvance = 0.5
ENT.FlyBySound = "lvs/vehicles/laat/flyby"..math.random(1,2,3,4,5)..".wav"

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/laat/loop.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
	{
		sound = "^lvs/vehicles/laat/dist.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0.35,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		VolumeMin = 0,
		VolumeMax = 1,
		SoundLevel = 110,
	},
}

function ENT:CalcMainActivity( ply )
	local Pod = ply:GetVehicle()

	if Pod == self:GetDriverSeat() or Pod == self:GetGunnerSeat() then return end

	if ply.m_bWasNoclipping then 
		ply.m_bWasNoclipping = nil 
		ply:AnimResetGestureSlot( GESTURE_SLOT_CUSTOM ) 

		if CLIENT then 
			ply:SetIK( true )
		end 
	end 

	ply.CalcIdeal = ACT_STAND
	ply.CalcSeqOverride = ply:LookupSequence( "idle_all_02" )

	if ply:GetAllowWeaponsInVehicle() and IsValid( ply:GetActiveWeapon() ) then

		local holdtype = ply:GetActiveWeapon():GetHoldType()

		if holdtype == "smg" then 
			holdtype = "smg1"
		end

		local seqid = ply:LookupSequence( "idle_" .. holdtype )

		if seqid ~= -1 then
			ply.CalcSeqOverride = seqid
		end
	end

	return ply.CalcIdeal, ply.CalcSeqOverride
end
--addons/lvs_addons/lua/entities/lvs_protonbomb.lua:
AddCSLuaFile()

ENT.Base = "lvs_bomb"

ENT.Type = "anim"

ENT.PrintName = "Proton Bomb"
ENT.Author = "KurtJQ"
ENT.Information = "LVS Proton Bomb"
ENT.Category = "[LVS]"

ENT.Spawnable = false
ENT.AdminOnly = false

ENT.ExplosionEffect = "lvs_proton_explosion"
ENT.GlowColor = Color( 0, 127, 255, 255 )

if SERVER then
	function ENT:GetDamage() return
		(self._dmg or 2000)
	end

	function ENT:GetRadius() return
		(self._radius or 400)
	end

	return
end

ENT.GlowMat = Material( "sprites/light_glow02_add" )

function ENT:Initialize()
	self:SetModel( "models/weapons/w_missile_launch.mdl" )
end

function ENT:Enable()
	if self.IsEnabled then return end

	self.IsEnabled = true

	local effectdata = EffectData()
		effectdata:SetOrigin( self:GetPos() )
		effectdata:SetEntity( self )
	util.Effect( "lvs_proton_trail", effectdata)
end

function ENT:Draw()
	if not self:GetActive() then return end

	self:DrawModel()

	render.SetMaterial( self.GlowMat )

	local pos = self:GetPos()
	local dir = self:GetForward()

	for i = 0, 30 do
		local Size = ((30 - i) / 30) ^ 2 * 128

		render.DrawSprite( pos - dir * i * 7, Size, Size, self.GlowColor )
	end
end
--addons/lvs_addons/lua/entities/lvs_reptransport_swtor/cl_init.lua:
include("shared.lua")

-- Engine Particles start

ENT.EngineColor = Color( 251, 255, 0)
ENT.EngineGlow = Material( "sprites/light_glow02_add" )
ENT.EnginePos = {
	Vector(-284.06,-40.51,26.31),
	Vector(-284.06,40.51,26.31),
}

function ENT:OnSpawn()
	self:RegisterTrail( Vector(-34,326,-13), 0, 20, 2, 1000, 150 )
	self:RegisterTrail( Vector(-34,-326,-13), 0, 20, 2, 1000, 150 )
end

function ENT:EngineEffects()
	if not self:GetEngineActive() then return end

	local T = CurTime()

	if (self.nextEFX or 0) > T then return end

	self.nextEFX = T + 0.01

	local THR = self:GetThrottle()

	local emitter = self:GetParticleEmitter( self:GetPos() )

	if not IsValid( emitter ) then return end

	for _, pos in pairs( self.EnginePos ) do
		local vOffset = self:LocalToWorld( pos )
		local vNormal = -self:GetForward()

		vOffset = vOffset + vNormal * 5

		local particle = emitter:Add( "effects/muzzleflash2", vOffset )

		if not particle then continue end

		particle:SetVelocity( vNormal * (math.Rand(500,1000) + self:GetBoost() * 10) + self:GetVelocity() )
		particle:SetLifeTime( 0 )
		particle:SetDieTime( 0.1 )
		particle:SetStartAlpha( 255 )
		particle:SetEndAlpha( 0 )
		particle:SetStartSize( math.Rand(15,25) )
		particle:SetEndSize( math.Rand(0,10) )
		particle:SetRoll( math.Rand(-1,1) * 100 )
		particle:SetColor( 251, 255, 0)
	end
end

function ENT:OnFrame()
	self:EngineEffects()
end


-- Engine Particles End


function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	local Size = 80 + self:GetThrottle() * 120 + self:GetBoost() * 2

	render.SetMaterial( self.EngineGlow )

	for _, pos in pairs( self.EnginePos ) do
		render.DrawSprite(  self:LocalToWorld( pos ), Size, Size, self.EngineColor )
	end
end

function ENT:OnStartBoost()
	self:EmitSound( "ophra/ships/powerstart3.wav", 85 )
end

function ENT:OnStopBoost()
	self:EmitSound( "ophra/ships/shutdown.wav", 85 )
end

--addons/lvs_addons/lua/entities/lvs_starfighter_droidtrifighter/shared.lua:

ENT.Base = "lvs_base_starfighter"

ENT.PrintName = "Droid Tri-Fighter"
ENT.Author = "Luna"
ENT.Information = "Droid Starfighter of the Separatists"
ENT.Category = "[LVS] - Star Wars"

ENT.VehicleCategory = "Star Wars"
ENT.VehicleSubCategory = "Starfighters"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/salza/droidtrifighter.mdl"
ENT.GibModels = {
	"models/salza/tridroid_gib1.mdl",
	"models/salza/tridroid_gib2.mdl",
	"models/salza/tridroid_gib3.mdl",
	"models/salza/tridroid_gib4.mdl",
	"models/salza/tridroid_gib5.mdl",
}

ENT.AITEAM = 1

ENT.MaxVelocity = 2150
ENT.MaxThrust = 2150

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3

ENT.TurnRatePitch = 1
ENT.TurnRateYaw = 1
ENT.TurnRateRoll = 1.25

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 250

function ENT:InitWeapons()
	self.FirePositions = {
		Vector(114.58,0,86.08),
		Vector(112.54,74.47,-42.69),
		Vector(112.54,-74.47,-42.69),
	}

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/mg.png")
	weapon.Ammo = 1200
	weapon.Delay = 0.1
	weapon.HeatRateUp = 0.25
	weapon.HeatRateDown = 1
	weapon.Attack = function( ent )
		ent.NumPrim = ent.NumPrim and ent.NumPrim + 1 or 1
		if ent.NumPrim > #ent.FirePositions then ent.NumPrim = 1 end

		local pod = ent:GetDriverSeat()

		if not IsValid( pod ) then return end

		local startpos = pod:LocalToWorld( pod:OBBCenter() )
		local trace = util.TraceHull( {
			start = startpos,
			endpos = (startpos + ent:GetForward() * 50000),
			mins = Vector( -10, -10, -10 ),
			maxs = Vector( 10, 10, 10 ),
			filter = ent:GetCrosshairFilterEnts()
		} )

		local bullet = {}
		bullet.Src 	= ent:LocalToWorld( ent.FirePositions[ent.NumPrim] )
		bullet.Dir 	= (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread 	= Vector( 0.02,  0.02, 0 )
		bullet.TracerName = "lvs_laser_red"
		bullet.Force	= 10
		bullet.HullSize 	= 40
		bullet.Damage	= 10
		bullet.Velocity = 60000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(255,50,50) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_impact", effectdata )
		end
		ent:LVSFireBullet( bullet )

		local effectdata = EffectData()
		effectdata:SetStart( Vector(255,50,50) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( ent:GetForward() )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )

		ent:TakeAmmo()

		ent.PrimarySND:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )


	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Ammo = 200
	weapon.Delay = 0.1
	weapon.HeatRateUp = 1.5
	weapon.HeatRateDown = 1
	weapon.Attack = function( ent )
		local bullet = {}
		bullet.Src 	= ent:LocalToWorld( Vector(152.24,0,0) )
		bullet.Dir 	= ent:GetForward()
		bullet.Spread 	= Vector( 0.015,  0.015, 0 )
		bullet.TracerName = "lvs_laser_red"
		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 40
		bullet.SplashDamage = 40
		bullet.SplashDamageRadius = 200
		bullet.Velocity = 30000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(255,0,0) ) 
				effectdata:SetOrigin( tr.HitPos )
			util.Effect( "lvs_laser_explosion", effectdata )
		end
		ent:LVSFireBullet( bullet )

		local effectdata = EffectData()
		effectdata:SetStart( Vector(255,50,50) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( ent:GetForward() )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )

		ent:TakeAmmo()

		ent.SecondarySND:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) end
	self:AddWeapon( weapon )

	self:AddWeapon( LVS:GetWeaponPreset( "TURBO" ) )
end

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/droidtrifighter/loop.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
	{
		sound = "^lvs/vehicles/vulturedroid/dist.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0.35,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		VolumeMin = 0,
		VolumeMax = 1,
		SoundLevel = 100,
	},
}
--addons/lvs_addons/lua/entities/lvs_starfighter_geo/cl_init.lua:
include("shared.lua")

ENT.EngineColor = Color( 150, 150, 255, 255)
ENT.EngineGlow = Material( "sprites/light_glow02_add" )
ENT.EnginePos = {
	[1] = Vector(-110,0,50),
}

function ENT:CalcViewOverride( ply, pos, angles, fov, pod )
	if self:GetDriver() == ply then
		local newpos = pos + self:GetForward() * 37 + self:GetUp() * 8

		return newpos, angles, fov
	else
		return pos, angles, fov
	end
end

function ENT:OnSpawn()
	self:RegisterTrail( Vector(-100,0,50), 0, 20, 2, 1000, 150 )
end

function ENT:OnFrame()
	self:EngineEffects()
end

function ENT:AnimWings()
end

function ENT:EngineEffects()
	if not self:GetEngineActive() then return end

	local T = CurTime()

	if (self.nextEFX or 0) > T then return end

	self.nextEFX = T + 0.01

	local THR = self:GetThrottle()

	local emitter = self:GetParticleEmitter( self:GetPos() )

	if not IsValid( emitter ) then return end

	for _, pos in pairs( self.EnginePos ) do
		local vOffset = self:LocalToWorld( pos )
		local vNormal = -self:GetForward()

		vOffset = vOffset + vNormal * 5

		local particle = emitter:Add( "sprites/heatwave", vOffset )
		if not particle then return end

		particle:SetVelocity( vNormal * math.Rand(500,1000) + self:GetVelocity() )
		particle:SetLifeTime( 0 )
		particle:SetDieTime( 0.1 )
		particle:SetStartAlpha( 255 )
		particle:SetEndAlpha( 0 )
		particle:SetStartSize( math.Rand(15,20) )
		particle:SetEndSize( math.Rand(0,10) )
		particle:SetRoll( math.Rand(-1,1) * 100 )
		
		particle:SetColor( 255, 255, 255 )
	end
end

function ENT:PostDraw()
end

function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	local Size = 60 + self:GetThrottle() * 60 + self:GetBoost()

	render.SetMaterial( self.EngineGlow )

	for _, pos in pairs( self.EnginePos ) do
		render.DrawSprite(  self:LocalToWorld( pos ), Size, Size, self.EngineColor )
	end
end

function ENT:OnStartBoost()
	self:EmitSound( "lvs/vehicles/vwing/boost.wav", 85 )
end

function ENT:OnStopBoost()
	self:EmitSound( "lvs/vehicles/vwing/brake.wav", 85 )
end

--addons/lvs_addons/lua/entities/lvs_starfighter_havoc/shared.lua:

ENT.Base = "lvs_base_starfighter"

ENT.PrintName = "Scurrg H-6"
ENT.Author = "Nashatok"
ENT.Information = "Prototype bomber by the Nubian Design Collective, stolen and modified by pirates and other unsavories"
ENT.Category = "[LVS] - Star Wars"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/havoc/rep_havoc.mdl"

ENT.AITEAM = 1

ENT.MaxVelocity = 1900
ENT.MaxThrust = 1900

ENT.TurnRatePitch = 1
ENT.TurnRateYaw = 1
ENT.TurnRateRoll = 1

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 750
ENT.MaxShield = 250

function ENT:OnSetupDataTables()
	self:AddDT( "Entity", "GunnerSeat" )
end

function ENT:InitWeapons()
	self.FirePositions = {
		Vector(143,235,24),
		Vector(130,220,24),
		Vector(143,-235,24),
		Vector(130,-220,24)
	}
	
	--Weapon 1 - Rapid-fire Laser Cannons
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/mg.png")
	weapon.Ammo = 1200
	weapon.Delay = 0.1
	weapon.HeatRateUp = 0.25
	weapon.HeatRateDown = 1
	weapon.Attack = function( ent )
		self.NumPrim = self.NumPrim and self.NumPrim + 1 or 1
		if self.NumPrim > 4 then self.NumPrim = 1 end

		local pod = ent:GetDriverSeat()

		if not IsValid( pod ) then return end

		local startpos = pod:LocalToWorld( pod:OBBCenter() )
		local trace = util.TraceHull( {
			start = startpos,
			endpos = (startpos + ent:GetForward() * 50000),
			mins = Vector( -10, -10, -10 ),
			maxs = Vector( 10, 10, 10 ),
			filter = ent:GetCrosshairFilterEnts()
		} )

		local bullet = {}
		bullet.Src 	= ent:LocalToWorld( ent.FirePositions[ent.NumPrim] )
		bullet.Dir 	= (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread 	= Vector( 0.02,  0.02, 0 )
		bullet.TracerName = "lvs_laser_yellow"
		bullet.Force	= 10
		bullet.HullSize 	= 40
		bullet.Damage	= 30
		bullet.Velocity = 60000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(200,150,50) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_impact", effectdata )
		end

		local effectdata = EffectData()
		effectdata:SetStart( Vector(200,150,50) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( ent:GetForward() )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )
		
		ent:LVSFireBullet( bullet )

		ent:TakeAmmo()

		ent.PrimarySND:PlayOnce( 100 + math.cos( CurTime() + self:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )
	
	--Weapon 2 - Proton Torpedoes
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/protontorpedo.png")
	weapon.UseableByAI = false
	weapon.Ammo = 12
	weapon.Delay = 0 -- this will turn weapon.Attack to a somewhat think function
	weapon.HeatRateUp = -0.5 -- cool down when attack key is held. This system fires on key-release.
	weapon.HeatRateDown = 0.25
	weapon.Attack = function( ent )
		local T = CurTime()

		if IsValid( ent._ProtonTorpedo ) then
			if (ent._nextMissleTracking or 0) > T then return end

			ent._nextMissleTracking = T + 0.1 -- 0.1 second interval because those find functions can be expensive

			ent._ProtonTorpedo:FindTarget( ent:GetPos(), ent:GetForward(), 30, 7500 )

			return
		end

		local T = CurTime()

		if (ent._nextMissle or 0) > T then return end

		ent._nextMissle = T + 0.5

		ent._swapMissile = not ent._swapMissile

		local Pos = Vector( 125, (ent._swapMissile and -87 or 89), 8 )

		local projectile = ents.Create( "lvs_protontorpedo" )
		projectile:SetPos( ent:LocalToWorld( Pos ) )
		projectile:SetAngles( ent:GetAngles() )
		projectile:SetParent( ent )
		projectile:Spawn()
		projectile:Activate()
		projectile:SetAttacker( ent:GetDriver() )
		projectile:SetEntityFilter( ent:GetCrosshairFilterEnts() )
		projectile:SetSpeed( ent:GetVelocity():Length() + 4000 )

		ent._ProtonTorpedo = projectile

		ent:SetNextAttack( CurTime() + 0.1 ) -- wait 0.1 second before starting to track
	end
	weapon.FinishAttack = function( ent )
		if not IsValid( ent._ProtonTorpedo ) then return end

		local projectile = ent._ProtonTorpedo

		projectile:Enable()
		projectile:EmitSound( "lvs/vehicles/naboo_n1_starfighter/proton_fire.mp3", 125 )
		ent:TakeAmmo()

		ent._ProtonTorpedo = nil

		local NewHeat = ent:GetHeat() + 0.75

		ent:SetHeat( NewHeat )
		if NewHeat >= 1 then
			ent:SetOverheated( true )
		end
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )

	--Weapon 3 - High-Calliber Slugthrowers
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Ammo = 36
	weapon.Delay = 0.2
	weapon.HeatRateUp = 2
	weapon.HeatRateDown = 0.333
	weapon.Attack = function( ent )
		local bullet = {}
		bullet.Spread 	= Vector( 0.035,  0.035, 0.015 )
		bullet.TracerName = "lvs_tracer_orange"
		bullet.Force	= 100
		bullet.HullSize 	= 25
		bullet.Damage	= 80
		bullet.Velocity = 22000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(50,255,50) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_bullet_impact", effectdata )
		end

		for i = -1,1,2 do
			bullet.Src 	= ent:LocalToWorld( Vector(100,211 * i,24) )
			bullet.Dir 	= ent:LocalToWorldAngles( Angle(0,-0.4 * i,0) ):Forward()
			ent:LVSFireBullet( bullet )
		end

		ent:TakeAmmo()
		
		ent.SecondarySND:PlayOnce( 100 + math.cos( CurTime() + self:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )
	
	--Gunner Weapon
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Delay = 0.15
	--weapon.HeatRateUp = 0.6
	--weapon.HeatRateDown = 0.5
	weapon.Attack = function( ent )
		local pod = ent:GetDriverSeat()

		if not IsValid( pod ) then return end

		local dir = ent:GetAimVector()

		if ent:AngleBetweenNormal( dir, ent:GetForward() ) > 180 then return true end

		local trace = ent:GetEyeTrace()

		ent.SwapTopBottom = not ent.SwapTopBottom

		local veh = ent:GetVehicle()

		veh.SNDTail:PlayOnce( 100 + math.Rand(-3,3), 1 )

		local bullet = {}
		bullet.Src = veh:LocalToWorld( ent.SwapTopBottom and Vector(50,8,78) or Vector(50,-8,78) )
		bullet.Dir = (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread 	= Vector( 0.03,  0.03, 0.03 )
		bullet.TracerName = "lvs_laser_yellow"
		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 15
		bullet.Velocity = 50000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(255,150,50) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_impact", effectdata )
		end
		ent:LVSFireBullet( bullet )
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav")end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon, 2 )
end

ENT.FlyByAdvance = 0.75
ENT.FlyBySound = "lvs/vehicles/naboo_n1_starfighter/flyby.wav" 
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/naboo_n1_starfighter/loop.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
}
--addons/lvs_addons/lua/entities/lvs_starfighter_peltaclass/cl_init.lua:
include("shared.lua")


ENT.EngineFXPos = {
	Vector(-1299.02,-5.95,431.46),
	Vector(-1096.42,-199.4,484.04),
	Vector(-1096.42,199.4,484.04),
	Vector(-1100.4,192.72,367.3),
	Vector(-1100.4,-192.72,367.3),
	Vector(-965.55,774.91,425.67),
	Vector(-965.55,-774.91,425.67),
	Vector(-1000.17,983.13,426.26),
	Vector(-1000.17,-983.13,426.26),
	Vector(-1018.42,1102.7,424.37),
	Vector(-1018.42,-1102.7,424.37),
	Vector(-957.22,-325.03,426.88),
	Vector(-957.22,325.03,426.88),
}

function ENT:OnSpawn()
	self:RegisterTrail( Vector(-1156.11,1335.7,368.39), 0, 20, 2, 2500, 150 )
	self:RegisterTrail( Vector(-1156.11,-1335.7,368.39), 0, 20, 2, 2500, 150 )
	self:RegisterTrail( Vector(-1158.6,1335.03,481.42), 0, 20, 2, 2500, 150 )
	self:RegisterTrail( Vector(-1158.6,-1335.03,481.42), 0, 20, 2, 2500, 150 )
end

function ENT:OnFrame()
	self:EngineEffects()
end

ENT.EngineGlow = Material( "sprites/light_glow02_add" )

function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	local Size = 600 + self:GetThrottle() * 40 + self:GetBoost() * 0.8

	render.SetMaterial( self.EngineGlow )
	render.DrawSprite( self:LocalToWorld( Vector(-1299.02,-5.95,431.46) ), Size, Size, Color( 242, 140, 40) )
	render.DrawSprite( self:LocalToWorld( Vector(-1096.42,-199.4,484.04) ), Size, Size, Color(242, 140, 40) )
	render.DrawSprite( self:LocalToWorld( Vector(-1096.42,199.4,484.04) ), Size, Size, Color( 242, 140, 40) )
	render.DrawSprite( self:LocalToWorld( Vector(-1100.4,192.72,367.3) ), Size, Size, Color( 242, 140, 40) )
	render.DrawSprite( self:LocalToWorld( Vector(-1100.4,-192.72,367.3) ), Size, Size, Color( 242, 140, 40) )
	render.DrawSprite( self:LocalToWorld( Vector(-965.55,774.91,425.67) ), Size, Size, Color( 242, 140, 40) )
	render.DrawSprite( self:LocalToWorld( Vector(-965.55,-774.91,425.67) ), Size, Size, Color( 242, 140, 40) )
	render.DrawSprite( self:LocalToWorld( Vector(-1000.17,983.13,426.26) ), Size, Size, Color( 242, 140, 40) )
	render.DrawSprite( self:LocalToWorld( Vector(-1000.17,-983.13,426.26) ), Size, Size, Color(242, 140, 40) )
	render.DrawSprite( self:LocalToWorld( Vector(-1018.42,1102.7,424.37) ), Size, Size, Color( 242, 140, 40) )
	render.DrawSprite( self:LocalToWorld( Vector(-1018.42,-1102.7,424.37) ), Size, Size, Color( 242, 140, 40) )
	render.DrawSprite( self:LocalToWorld( Vector(-957.22,325.03,426.88) ), Size, Size, Color( 242, 140, 40) )
	render.DrawSprite( self:LocalToWorld( Vector(-957.22,-325.03,426.88) ), Size, Size, Color( 242, 140, 40) )
end

function ENT:EngineEffects()
	if not self:GetEngineActive() then return end

	local T = CurTime()

	if (self.nextEFX or 0) > T then return end

	self.nextEFX = T + 0.01

	local THR = self:GetThrottle()

	local emitter = self:GetParticleEmitter( self:GetPos() )

	if not IsValid( emitter ) then return end

	for _, v in pairs( self.EngineFXPos ) do
		local Sub = Mirror and 1 or -1
		local vOffset = self:LocalToWorld( v )
		local vNormal = -self:GetForward()

		vOffset = vOffset + vNormal * 5

		local particle = emitter:Add( "effects/muzzleflash2", vOffset )

		if not particle then continue end

		particle:SetVelocity( vNormal * math.Rand(2000,1000) + self:GetVelocity() )
		particle:SetLifeTime( 0 )
		particle:SetDieTime( 0.1 )
		particle:SetStartAlpha( 255 )
		particle:SetEndAlpha( 0 )
		particle:SetStartSize( math.Rand(20,25) )
		particle:SetEndSize( math.Rand(0,50) )
		particle:SetRoll( math.Rand(-1,1) * 100 )
		
		particle:SetColor(255, 95, 31)
	end
end
function ENT:OnStartBoost()
	self:EmitSound( "lvs/vehicles/frigates/takeoff2.mp3", 500 )
end

function ENT:OnStopBoost()
	self:EmitSound( "lvs/vehicles/vwing/brake.wav", 120 )
end

--addons/lvs_addons/lua/entities/lvs_turbo_laser/shared.lua:
ENT.Type = "anim"
ENT.Base = "lvs_base_fakehover"

ENT.PrintName = "Turbolaser"
ENT.Author = "Dec"
ENT.Information = "Big Turbolasers make things go boom"
ENT.Category = "[LVS] SW-Vehicles"

ENT.Spawnable		= true
ENT.AdminSpawnable	= false


ENT.MDL = "models/starwars/sky/dec_vehicle/turbolaser/turbolaser1.mdl"
ENT.GibModels = {
	"models/gibs/helicopter_brokenpiece_01.mdl",
	"models/gibs/helicopter_brokenpiece_02.mdl",
	"models/gibs/helicopter_brokenpiece_03.mdl",
	"models/combine_apc_destroyed_gib02.mdl",
	"models/combine_apc_destroyed_gib04.mdl",
	"models/combine_apc_destroyed_gib05.mdl",
	"models/props_c17/trappropeller_engine.mdl",
	"models/gibs/airboat_broken_engine.mdl",
}


ENT.AITEAM = 2

ENT.MaxVelocityY = 0
ENT.BoostAddVelocityY = 0

ENT.ForceAngleMultiplier = 0
ENT.ForceAngleDampingMultiplier = 0

ENT.ForceLinearMultiplier = 0
ENT.ForceLinearRate = 0

ENT.MaxVelocityZ = 0
ENT.BoostAddVelocityZ = 0

ENT.MaxHealth = 10000
ENT.MaxShield = 0
ENT.MaxVelocityX = 0
ENT.BoostAddVelocitX = 0
ENT.IgnoreWater = false

ENT.MaxTurnRate = 0

ENT.GroundTraceLength = 0
ENT.GroundTraceHull = 0

function ENT:OnSetupDataTables()
	self:AddDT( "Entity", "GunnerSeat" )
end

function ENT:GetAimAngles( ent )
    local trace = ent:GetEyeTrace()
    local AimAngles = self:WorldToLocalAngles( (trace.HitPos - self:LocalToWorld( Vector(0,0,115) ) ):GetNormalized():Angle() )

    return AimAngles
end



function ENT:InitWeapons()
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/dual_mg.png")
	weapon.Delay = 0.85
	weapon.HeatRateUp = .3
	weapon.HeatRateDown = .45
	weapon.Attack = function( ent )
		local base = ent:GetVehicle()

		local trace = ent:GetEyeTrace()


		local ID_1 = self:LookupAttachment( "muzzle_r" )
		local ID_2 = self:LookupAttachment( "muzzle_l" )
		
		local Muzzle1 = self:GetAttachment( ID_1 )
		local Muzzle2 = self:GetAttachment( ID_2 )


		ent.MirrorPrimary = not ent.MirrorPrimary

		local Pos = ent.MirrorPrimary and Muzzle1.Pos or Muzzle2.Pos
		local Dir =  (ent.MirrorPrimary and Muzzle1.Ang or Muzzle2.Ang):Forward()

		local bullet = {}
		bullet.Src 	= Pos
		bullet.Dir 	= Dir
		bullet.Spread 	= Vector( 0.025,  0.025, 0.025 )
		bullet.TracerName = "lvs_laser_blue"
		bullet.Force	= 100
		bullet.HullSize 	= 50
		bullet.Damage	= 500
		bullet.Velocity = 9000
		bullet.SplashDamage	= 450
		bullet.SplashDamageRadius	= 350
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(50,50,255) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_concussion_explosion", effectdata )
		end

		local effectdata = EffectData()
		effectdata:SetStart( Vector(50,50,255) )
		effectdata:SetOrigin( bullet.Src )
		--effectdata:SetNormal( Dir )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )

		base.PrimarySND:PlayOnce( 100 + math.Rand(-3,3), 1 )
		ent:LVSFireBullet( bullet )
		
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav")end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	weapon.OnThink = function( ent )
		if self:GetAI() or IsValid(self:GetGunnerSeat():GetDriver()) then
			local AimAngles = self:GetAimAngles( ent )

			self:SetPoseParameter("turbolaser_aim_pitch", (-AimAngles.p / 3) )
			self:SetPoseParameter("turbolaser_aim_yaw", (AimAngles.y - 90) )
		end
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local Col = (ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) > 360) and COLOR_RED or COLOR_WHITE

		local Pos2D = ent:GetEyeTrace().HitPos:ToScreen() 

		local base = ent:GetVehicle()
		base:PaintCrosshairCenter( Pos2D, Col )
		base:PaintCrosshairOuter( Pos2D, Col )
		base:LVSPaintHitMarker( Pos2D )
	end

	self:AddWeapon( weapon, 2 )

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/dual_mg.png")
	weapon.Delay = 1.05
	weapon.HeatRateUp = .6
	weapon.HeatRateDown = .4
	weapon.Attack = function( ent )
		for i = 1, 2 do
			local base = ent:GetVehicle()
			local ID_1 = self:LookupAttachment( "muzzle_r" )
			local ID_2 = self:LookupAttachment( "muzzle_l" )
			
			local Muzzle1 = self:GetAttachment( ID_1 )
			local Muzzle2 = self:GetAttachment( ID_2 )


			ent.MirrorPrimary = not ent.MirrorPrimary

			local Pos = ent.MirrorPrimary and Muzzle1.Pos or Muzzle2.Pos
			local Dir =  (ent.MirrorPrimary and Muzzle1.Ang or Muzzle2.Ang):Forward()

			local bullet = {}
			bullet.Src 	= Pos
			bullet.Dir 	= Dir
			bullet.Spread 	= Vector( 0.025,  0.025, 0.025 )
			bullet.TracerName = "lvs_laser_blue"
			bullet.Force	= 100
			bullet.HullSize 	= 50
			bullet.Damage	= 800
			bullet.Velocity = 9000
			bullet.SplashDamage	= 1200
			bullet.SplashDamageRadius	= 450
			bullet.Attacker 	= ent:GetDriver()
			bullet.Callback = function(att, tr, dmginfo)
				local effectdata = EffectData()
					effectdata:SetStart( Vector(50,50,255) ) 
					effectdata:SetOrigin( tr.HitPos )
					effectdata:SetNormal( tr.HitNormal )
				util.Effect( "lvs_concussion_explosion", effectdata )
			end

			local effectdata = EffectData()
			effectdata:SetStart( Vector(50,50,255) )
			effectdata:SetOrigin( bullet.Src )
			effectdata:SetNormal( Dir )
			effectdata:SetEntity( ent )
			util.Effect( "lvs_muzzle_colorable", effectdata )

			base.PrimarySND:PlayOnce( 100 + math.Rand(-3,3), 1 )
			ent:LVSFireBullet( bullet )
		end
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav")end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	weapon.OnThink = function( ent )
		if self:GetAI() or IsValid(self:GetGunnerSeat():GetDriver()) then
			local AimAngles = self:GetAimAngles( ent )

			self:SetPoseParameter("turbolaser_aim_pitch", (-AimAngles.p / 3) )
			self:SetPoseParameter("turbolaser_aim_yaw", (AimAngles.y - 90) )
		end
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local Col = (ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) > 360) and COLOR_RED or COLOR_WHITE

		local Pos2D = ent:GetEyeTrace().HitPos:ToScreen() 

		local base = ent:GetVehicle()
		base:PaintCrosshairCenter( Pos2D, Col )
		base:PaintCrosshairOuter( Pos2D, Col )
		base:LVSPaintHitMarker( Pos2D )
	end
	self:AddWeapon( weapon, 2 )






	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Delay = 0.25
	weapon.HeatRateUp = .3
	weapon.HeatRateDown = .4
	weapon.Attack = function( ent )
		for i = 1, 2 do
			local base = ent:GetVehicle()
			local ID_1 = self:LookupAttachment( "muzzle_r" )
			local ID_2 = self:LookupAttachment( "muzzle_l" )
			
			local Muzzle1 = self:GetAttachment( ID_1 )
			local Muzzle2 = self:GetAttachment( ID_2 )


			ent.MirrorPrimary = not ent.MirrorPrimary

			local Pos = ent.MirrorPrimary and Muzzle1.Pos or Muzzle2.Pos
			local Dir =  (ent.MirrorPrimary and Muzzle1.Ang or Muzzle2.Ang):Forward()

			local bullet = {}
			bullet.Src 	= Pos
			bullet.Dir 	= Dir
			bullet.Spread 	= Vector( 0.025,  0.025, 0.025 )
			bullet.TracerName = "lvs_laser_green"
			bullet.Force	= 100
			bullet.HullSize 	= 50
			bullet.Damage	= 50
			bullet.Velocity = 9000
			bullet.SplashDamage	= 50
			bullet.SplashDamageRadius	= 50
			bullet.Attacker 	= ent:GetDriver()
			bullet.Callback = function(att, tr, dmginfo)
				local effectdata = EffectData()
					effectdata:SetStart( Vector(50,50,255) ) 
					effectdata:SetOrigin( tr.HitPos )
					effectdata:SetNormal( tr.HitNormal )
				util.Effect( "lvs_concussion_explosion", effectdata )
			end

			local effectdata = EffectData()
			effectdata:SetStart( Vector(50,50,255) )
			effectdata:SetOrigin( bullet.Src )
			effectdata:SetNormal( Dir )
			effectdata:SetEntity( ent )
			util.Effect( "lvs_muzzle_colorable", effectdata )

			base.SecondarySND:PlayOnce( 100 + math.Rand(-3,3), 1 )
			ent:LVSFireBullet( bullet )
		end
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav")end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	weapon.OnThink = function( ent )
		if self:GetAI() or IsValid(self:GetGunnerSeat():GetDriver()) then
			local AimAngles = self:GetAimAngles( ent )

			self:SetPoseParameter("turbolaser_aim_pitch", (-AimAngles.p / 3) )
			self:SetPoseParameter("turbolaser_aim_yaw", (AimAngles.y - 90) )
		end
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local Col = (ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) > 360) and COLOR_RED or COLOR_WHITE

		local Pos2D = ent:GetEyeTrace().HitPos:ToScreen() 

		local base = ent:GetVehicle()
		base:PaintCrosshairCenter( Pos2D, Col )
		base:PaintCrosshairOuter( Pos2D, Col )
		base:LVSPaintHitMarker( Pos2D )
	end
	self:AddWeapon( weapon, 2 )

end
--addons/lvs_addons/lua/entities/lvs_turret_aa_red/shared.lua:
ENT.Base = "lvs_base_turret"

ENT.PrintName = "Anti-Air Turret"
ENT.Author = "Luna"
ENT.Information = "It shoots lasers into the sky and makes things go boom"
ENT.Category = "[LVS] - Turrets (CIS)"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/antiairturret/rep_anti-airturret.mdl"

ENT.AITEAM = 1

ENT.MaxVelocity = 3000
ENT.MaxThrust = 3000

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3

ENT.TurnRatePitch = 1
ENT.TurnRateYaw = 1
ENT.TurnRateRoll = 1

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.LAATC_PICKUPABLE = true
ENT.LAATC_DROP_IN_AIR = true
ENT.LAATC_PICKUP_POS = Vector(-200,0,25)
ENT.LAATC_PICKUP_Angle = Angle(0,0,0)

ENT.MaxHealth = 4800

function ENT:OnSetupDataTables()
	self:AddDT( "Bool", "IsCarried" )
	self:AddDT( "Entity", "GunnerSeat" )
	self:AddDT( "Float", "TurretPitch" )
	self:AddDT( "Float", "TurretYaw" )

	if SERVER then
		self:NetworkVarNotify( "IsCarried", self.OnIsCarried )
	end
end

function ENT:TraceTurret()
	local ID = self:LookupAttachment( "muzzle1" )
	local Muzzle = self:GetAttachment( ID )

	if not Muzzle then return end

	local dir = Muzzle.Ang:Up()
	local pos = Muzzle.Pos

	local trace = util.TraceLine( {
		start = pos,
		endpos = (pos + dir * 50000),
	} )

	return trace
end

function ENT:GetAimAngles( ent )
    local trace = ent:GetEyeTrace()
    local AimAngles = self:WorldToLocalAngles( (trace.HitPos - self:LocalToWorld( Vector(0,0,60) ) ):GetNormalized():Angle() )

    return AimAngles
end

function ENT:WeaponsInRange( ent )
    local AimAngles = self:GetAimAngles( ent )

    return not (AimAngles.p >= -10 or AimAngles.p <= -180)
end

function ENT:InitWeapons()
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Delay = 0.25
	weapon.HeatRateUp = .34
	weapon.HeatRateDown = .5
	weapon.Attack = function( ent )
        if not ent:GetVehicle():WeaponsInRange( ent ) then return true end
		local base = ent:GetVehicle()

		local ID_1 = self:LookupAttachment( "muzzle1" )
		local ID_2 = self:LookupAttachment( "muzzle2" )
		local Muzzle1 = self:GetAttachment( ID_1 )
		local Muzzle2 = self:GetAttachment( ID_2 )

		if not Muzzle1 or not Muzzle2 then return end		

		ent.MirrorPrimary = not ent.MirrorPrimary

		local Pos = ent.MirrorPrimary and Muzzle1.Pos or Muzzle2.Pos
		local Dir =  (ent.MirrorPrimary and Muzzle1.Ang or Muzzle2.Ang):Up()

		local bullet = {}
		bullet.Src 	= Pos
		bullet.Dir 	= Dir
		bullet.Spread 	= Vector( 0.025,  0.025, 0.025 )
		bullet.TracerName = "lvs_laser_red"
		bullet.Force	= 100
		bullet.HullSize 	= 50
		bullet.Damage	= 35
		bullet.Velocity = 50000
		bullet.SplashDamage	= 70
		bullet.SplashDamageRadius	= 250
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(255,50,50) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_explosion", effectdata )
		end

		local effectdata = EffectData()
		effectdata:SetStart( Vector(255,50,50) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( Dir )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )

		base.PrimarySND:PlayOnce( 100 + math.Rand(-3,3), 1 )
		ent:LVSFireBullet( bullet )
		
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav")end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	weapon.OnThink = function( ent, active )	
		if ent:GetVehicle():GetIsCarried( ent ) then
			self:SetPoseParameter("turret_pitch", 0 )
			self:SetPoseParameter("turret_yaw", 0 )
		end
		
		local AimAngles = self:GetAimAngles( ent )

		self:SetPoseParameter("turret_pitch", AimAngles.p )
		self:SetPoseParameter("turret_yaw", AimAngles.y )
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		local Pos2D = base:TraceTurret().HitPos:ToScreen()

		base:PaintCrosshairCenter( Pos2D, color_white )
		base:PaintCrosshairOuter( Pos2D, color_white )
		base:LVSPaintHitMarker( Pos2D )
	end
	self:AddWeapon( weapon, 2 )
	
	
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/dual_mg.png")
	weapon.Delay = 0.1
	weapon.HeatRateUp = .2
	weapon.HeatRateDown = .5
	weapon.Attack = function( ent )
        if not ent:GetVehicle():WeaponsInRange( ent ) then return true end
		local pod = ent:GetDriverSeat()
		local dir = ent:GetAimVector()
		local trace = ent:GetEyeTrace()
		local base = ent:GetVehicle()

		local ID_1 = self:LookupAttachment( "muzzle1" )
		local ID_2 = self:LookupAttachment( "muzzle2" )
		local Muzzle1 = self:GetAttachment( ID_1 )
		local Muzzle2 = self:GetAttachment( ID_2 )

		if not Muzzle1 or not Muzzle2 then return end

		ent.MirrorPrimary = not ent.MirrorPrimary

		local Pos = ent.MirrorPrimary and Muzzle1.Pos or Muzzle2.Pos
		local Dir =  (ent.MirrorPrimary and Muzzle1.Ang or Muzzle2.Ang):Up()

		ent.SwapTopBottom = not ent.SwapTopBottom

		base.SecondarySND:PlayOnce( 100 + math.Rand(-3,3), 1 )

		local bullet = {}
		bullet.Src = Pos
		bullet.Dir = Dir
		bullet.Spread 	= Vector( 0.07,  0.07, 0.07 )
		bullet.TracerName = "lvs_laser_red"
		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 20
		bullet.Velocity = 50000
		--bullet.SplashDamage	= 20
		--bullet.SplashDamageRadius	= 200
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(255,50,50) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_explosion", effectdata )
		end

		local effectdata = EffectData()
		effectdata:SetStart( Vector(255,50,50) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( Dir )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )
		
		ent:LVSFireBullet( bullet )
	end
	
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav")end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	weapon.HudPaint = function( ent, X, Y, ply )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		local Pos2D = base:TraceTurret().HitPos:ToScreen()

		base:PaintCrosshairCenter( Pos2D, color_white )
		base:PaintCrosshairOuter( Pos2D, color_white )
		base:LVSPaintHitMarker( Pos2D )
	end
	self:AddWeapon( weapon, 2 )
end

ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"
--addons/lvs_addons/lua/entities/lvs_zakfighter_swtor/shared.lua:

ENT.Base = "lvs_base_starfighter"

ENT.PrintName = "Zakuul Fighter"
ENT.Author = "Ophra"
ENT.Information = "Fighter of the Zakuul Empire"
ENT.Category = "[LVS] - SWTOR"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/ophra/ships/veh_neu_zak_fighter.mdl"
ENT.GibModels = {
	"models/salza/arc170_gib1.mdl",
	"models/salza/arc170_gib2.mdl",
	"models/salza/arc170_gib3.mdl",
	"models/salza/arc170_gib4.mdl",
	"models/salza/arc170_gib5.mdl",
	"models/salza/arc170_gib6.mdl"
}

ENT.AITEAM = 3

ENT.MaxVelocity = 2150
ENT.MaxThrust = 2150

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3

ENT.TurnRatePitch = 0.7
ENT.TurnRateYaw = 0.7
ENT.TurnRateRoll = 0.7

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 800
ENT.MaxShield = 100

function ENT:OnSetupDataTables()
	self:AddDT( "Bool", "Foils" )
	self:AddDT( "Entity", "TailGunnerSeat" )

	if SERVER then
		self:NetworkVarNotify( "Foils", self.OnFoilsChanged )
	end
end

function ENT:InitWeapons()
	self.FirePositions = {
		Vector(0,90,-15),
		Vector(0,-90,-15),
	}


	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Ammo = 1000
	weapon.Delay = 0.15
	weapon.HeatRateUp = 0.5
	weapon.HeatRateDown = 1
	weapon.Attack = function( ent )
		ent.NumPrim = ent.NumPrim and ent.NumPrim + 1 or 1
		if ent.NumPrim > #ent.FirePositions then ent.NumPrim = 1 end
 
		local pod = ent:GetDriverSeat()

		if not IsValid( pod ) then return end

		local startpos = pod:LocalToWorld( pod:OBBCenter() )
		local trace = util.TraceHull( {
			start = startpos,
			endpos = (startpos + ent:GetForward() * 50000),
			mins = Vector( -10, -10, -10 ),
			maxs = Vector( 10, 10, 10 ),
			filter = ent:GetCrosshairFilterEnts()
		} )

		local CurPos = ent.FirePositions[ent.NumPrim]

		local bullet = {}
		bullet.Src 	= ent:LocalToWorld( CurPos )
		bullet.Dir 	= (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread 	= Vector( 0.025,  0.025, 0 )
		bullet.TracerName = "lvs_laser_blue"
		 
		bullet.Force	= 10
		bullet.HullSize 	= 30
		bullet.Damage	= 40
		bullet.Velocity = 50000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(0, 229, 255) ) 
				effectdata:SetOrigin( tr.HitPos )
			util.Effect( "lvs_laser_explosion", effectdata )
		end
		ent:LVSFireBullet( bullet )

		local effectdata = EffectData()
		effectdata:SetStart( Vector(0, 229, 255) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( ent:GetForward() )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )

		ent:TakeAmmo()

		if CurPos.y > 0 then
			ent.SNDLeft:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
		else
			ent.SNDRight:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
		end
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("ophra/ships/weaponswitch.wav")
		if ent.SetFoils then ent:SetFoils( true ) end
	end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )



	local weapon = {}
	weapon.Icon = Material("lvs/weapons/protontorpedo.png")
	weapon.Ammo = 32
	weapon.Delay = 0 -- this will turn weapon.Attack to a somewhat think function
	weapon.HeatRateUp = -0.5 -- cool down when attack key is held. This system fires on key-release.
	weapon.HeatRateDown = 0.25
	weapon.Attack = function( ent )
		local T = CurTime()

		if IsValid( ent._ProtonTorpedo ) then
			if (ent._nextMissleTracking or 0) > T then return end

			ent._nextMissleTracking = T + 0.1 -- 0.1 second interval because those find functions can be expensive

			ent._ProtonTorpedo:FindTarget( ent:GetPos(), ent:GetForward(), 30, 7500 )

			return
		end

		local T = CurTime()

		if (ent._nextMissle or 0) > T then return end

		ent._nextMissle = T + 0.5

		ent._swapMissile = not ent._swapMissile

		local Pos = Vector( 0, (ent._swapMissile and -90 or 90), -15 )

		local Driver = self:GetDriver()

		local projectile = ents.Create( "lvs_protontorpedo" )
		projectile:SetPos( ent:LocalToWorld( Pos ) )
		projectile:SetAngles( ent:LocalToWorldAngles( Angle(0,ent._swapMissile and 2 or -2,0) ) )
		projectile:SetParent( ent )
		projectile:Spawn()
		projectile:Activate()
		projectile:SetAttacker( IsValid( Driver ) and Driver or self )
		projectile:SetEntityFilter( ent:GetCrosshairFilterEnts() )
		projectile:SetSpeed( ent:GetVelocity():Length() + 4000 )

		ent._ProtonTorpedo = projectile

		ent:SetNextAttack( CurTime() + 0.1 ) -- wait 0.1 second before starting to track
	end
	weapon.FinishAttack = function( ent )
		if not IsValid( ent._ProtonTorpedo ) then return end

		local projectile = ent._ProtonTorpedo

		projectile:Enable()
		projectile:EmitSound( "ophra/ships/shootsound4heavy.wav", 125 )
		ent:TakeAmmo()

		ent._ProtonTorpedo = nil

		local NewHeat = ent:GetHeat() + 0.75

		ent:SetHeat( NewHeat )
		if NewHeat >= 1 then
			ent:SetOverheated( true )
		end
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("ophra/ships/weaponswitch.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )

end


	local COLOR_RED = Color(255,0,0,255)
	local COLOR_WHITE = Color(255,255,255,255)

	

ENT.FlyByAdvance = 0.5
ENT.FlyBySound = "lvs/vehicles/arc170/flyby.wav" 
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

ENT.EngineSounds = {
	{
		sound = "ophra/ships/flysound5.wav",
		Volume = 3000,
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
}

--addons/star_wars_mortar/lua/entities/mortar_smoke_shell/shared.lua:
ENT.Type			=	"anim"
ENT.Base			=	"base_entity"
ENT.PrintName		=	"[DU] Mortar Smoke Shell"
ENT.Spawnable		=	false
ENT.Category 		=   "DolUnity"
--addons/weapons_other/lua/entities/police_shield/shared.lua:
ENT.Type = "anim";
ENT.Base = "base_anim";
ENT.PrintName = "Police Shield";
ENT.Author = "Drover | Edit by Mickerd";
ENT.Spawnable = true;
ENT.Category = "Police Shield";
ENT.AutomaticFrameAdvance = true;
ENT.RenderGroup 		= RENDERGROUP_BOTH;

/* 
---------------------------------------------------------------------------------------------------------------------------------------------
				Config
---------------------------------------------------------------------------------------------------------------------------------------------
*/


/*


AddEntity("Police Shield", {
        ent = "police_shield",
        model = "models/drover/w_shield.mdl", 
        price = 500,
        max = 2,
        cmd = "buyshieldpolice",
        allowed = {TEAM_POLICE}
}) 


*/
--gamemodes/starwarsrp/entities/entities/pp_prop_effect.lua:
AddCSLuaFile()

ENT.Type = "anim"

ENT.PrintName		= ""
ENT.Author			= ""
ENT.Contact			= ""
ENT.Purpose			= ""
ENT.Instructions	= ""
ENT.Spawnable		= false
ENT.AdminOnly		= false

--[[---------------------------------------------------------
	Name: Initialize
-----------------------------------------------------------]]
function ENT:Initialize()

	local Radius = 6
	local min = Vector( 1, 1, 1 ) * Radius * -0.5
	local max = Vector( 1, 1, 1 ) * Radius * 0.5

	if ( SERVER ) then

		self.AttachedEntity = ents.Create( "prop_dynamic" )
		self.AttachedEntity:SetModel( self:GetModel() )
		self.AttachedEntity:SetAngles( self:GetAngles() )
		self.AttachedEntity:SetPos( self:GetPos() )
		self.AttachedEntity:SetSkin( self:GetSkin() )
		self.AttachedEntity:Spawn()
		self.AttachedEntity:SetParent( self.Entity )
		self.AttachedEntity:DrawShadow( false )

		self:SetModel( "models/props_junk/watermelon01.mdl" )

		self:DeleteOnRemove( self.AttachedEntity )

		-- Don't use the model's physics - create a box instead
		self:PhysicsInitBox( min, max )

		-- Set up our physics object here
		local phys = self:GetPhysicsObject()
		if ( IsValid( phys ) ) then
			phys:Wake()
			phys:EnableGravity( false )
			phys:EnableDrag( false )
		end

		self:DrawShadow( false )
		self:SetCollisionGroup( COLLISION_GROUP_WEAPON )

	else

		self.GripMaterial = Material( "sprites/grip" )

		-- Get the attached entity so that clientside functions like properties can interact with it
		local tab = ents.FindByClassAndParent( "prop_dynamic", self )
		if ( tab && IsValid( tab[ 1 ] ) ) then self.AttachedEntity = tab[ 1 ] end

	end

	-- Set collision bounds exactly
	self:SetCollisionBounds( min, max )

end


--[[---------------------------------------------------------
	Name: Draw
-----------------------------------------------------------]]
function ENT:Draw()

	render.SetMaterial( self.GripMaterial )

end


--[[---------------------------------------------------------
	Name: PhysicsUpdate
-----------------------------------------------------------]]
function ENT:PhysicsUpdate( physobj )

	if ( CLIENT ) then return end

	-- Don't do anything if the player isn't holding us
	if ( !self:IsPlayerHolding() && !self:IsConstrained() ) then

		physobj:SetVelocity( Vector( 0, 0, 0 ) )
		physobj:Sleep()

	end

end


--[[---------------------------------------------------------
	Name: Called after entity 'copy'
-----------------------------------------------------------]]
function ENT:OnEntityCopyTableFinish( tab )

	-- We need to store the model of the attached entity
	-- Not the one we have here.
	tab.Model = self.AttachedEntity:GetModel()

	-- Store the attached entity's table so we can restore it after being pasted
	tab.AttachedEntityInfo = table.Copy( duplicator.CopyEntTable( self.AttachedEntity ) )
	tab.AttachedEntityInfo.Pos = nil -- Don't even save angles and position, we are a parented entity
	tab.AttachedEntityInfo.Angle = nil

	-- Do NOT store the attached entity itself in our table!
	-- Otherwise, if we copy-paste the prop with the duplicator, its AttachedEntity value will point towards the original prop's attached entity instead, and that'll break stuff
	tab.AttachedEntity = nil

end


--[[---------------------------------------------------------
	Name: PostEntityPaste
-----------------------------------------------------------]]
function ENT:PostEntityPaste( ply )

	-- Restore the attached entity using the information we've saved
	if ( IsValid( self.AttachedEntity ) ) and ( self.AttachedEntityInfo ) then

		-- Apply skin, bodygroups, bone manipulator, etc.
		duplicator.DoGeneric( self.AttachedEntity, self.AttachedEntityInfo )

		if ( self.AttachedEntityInfo.EntityMods ) then
			self.AttachedEntity.EntityMods = table.Copy( self.AttachedEntityInfo.EntityMods )
			duplicator.ApplyEntityModifiers( ply, self.AttachedEntity )
		end

		if ( self.AttachedEntityInfo.BoneMods ) then
			self.AttachedEntity.BoneMods = table.Copy( self.AttachedEntityInfo.BoneMods )
			duplicator.ApplyBoneModifiers( ply, self.AttachedEntity )
		end

		self.AttachedEntityInfo = nil

	end

end

--addons/aocrp_emplacements/lua/entities/rail_shell/shared.lua:
 ENT.Type 			= "anim"  
 ENT.Base 			= "base_gmodentity"     
 ENT.PrintName			= "40mm High Explosive"  
 ENT.Author			= "Generic Default"  
 ENT.Contact			= "AIDS"  
 ENT.Purpose			= "SPLODE"  
 ENT.Instructions		= "SHOOT"  
 
ENT.Spawnable			= false
ENT.AdminSpawnable		= false


--gamemodes/starwarsrp/entities/entities/rs4_ent/cl_init.lua:
include( "shared.lua" )

ENT.RenderGroup = RENDERGROUP_TRANSLUCENT

function ENT:Draw()
	self:DrawShadow( false )
	self:DrawModel()
end

function ENT:Initialize()

end

--addons/tools/lua/entities/sammyservers_textscreen/cl_init.lua:
include("shared.lua")

local render_convar_range = CreateClientConVar("ss_render_range", 1500, true, false, "Determines the render range for Textscreens. Default 1500")
local render_rainbow = CreateClientConVar("ss_render_rainbow", 1, true, false, "Determines if rainbow screens are rendered. If disabled (0), will render as solid white. Default enabled (1)", 0, 1)
local render_range = render_convar_range:GetInt() * render_convar_range:GetInt() --We multiply this is that we can use DistToSqr instead of Distance so we don't need to workout the square root all the time
local rainbow_enabled = cvars.Number("ss_enable_rainbow", 1)
local textscreenFonts = textscreenFonts
local screenInfo = {}
local shouldDrawBoth = false

-- Numbers used in conjunction with text width to work out the render bounds
local widthBoundsDivider = 7.9
local heightBoundsDivider = 12.4

-- ENUM type things for faster table indexing
local FONT = 1
local TEXT = 2
local POSX = 3
local POSY = 4
local COL = 5
local LEN = 6
local SIZE = 7
local CAMSIZE = 8
local RAINBOW = 9

-- Make ply:ShouldDrawLocalPlayer() never get called more than once a frame
hook.Add("Think", "ss_should_draw_both_sides", function()
	shouldDrawBoth = LocalPlayer():ShouldDrawLocalPlayer()
end)

local function ValidFont(f)
	if textscreenFonts[f] ~= nil then
		return textscreenFonts[f]
	elseif table.HasValue(textscreenFonts, f) then
		return f
	else
		return false
	end
end

cvars.AddChangeCallback("ss_render_range", function(convar_name, value_old, value_new)
	render_range = tonumber(value_new) * tonumber(value_new)
end, "3D2DScreens")

cvars.AddChangeCallback("ss_render_rainbow", function(convar_name, value_old, value_new)
	render_rainbow = tonumber(value_new)
end, "3D2DScreens")

-- TODO: https://github.com/Facepunch/garrysmod-issues/issues/3740
-- cvars.AddChangeCallback("ss_enable_rainbow", function(convar_name, value_old, value_new)
-- 	print('ss_enable_rainbow changed: '.. value_new)
-- 	rainbow_enabled = tonumber(value_new)
-- end, "3D2DScreens")

function ENT:Initialize()
	self:SetMaterial("models/effects/vol_light001")
	self:SetRenderMode(RENDERMODE_NONE)
	net.Start("textscreens_download")
	net.WriteEntity(self)
	net.SendToServer()
end

local product
local function IsInFront(entPos, plyShootPos, direction)
	product = (entPos.x - plyShootPos.x) * direction.x +
		(entPos.y - plyShootPos.y) * direction.y +
		(entPos.z - plyShootPos.z) * direction.z
	return product < 0
end


-- Draws the 3D2D text with the given positions, angles and data(text/font/col)
local function Draw3D2D(ang, pos, camangle, data)

	for i = 1, data[LEN] do
		if not data[i] or not data[i][TEXT] then continue end

		cam.Start3D2D(pos, camangle, data[i][CAMSIZE] )
			render.PushFilterMin(TEXFILTER.ANISOTROPIC)
			-- Font
			surface.SetFont(data[i][FONT])
			-- Position
			surface.SetTextPos(data[i][POSX], data[i][POSY])
			-- Rainbow
			if data[i][RAINBOW] ~= nil and data[i][RAINBOW] ~= 0 then
				local j = 0
				for _, code in utf8.codes(data[i][TEXT]) do
					j = j + 1
					--Color
					if rainbow_enabled == 1 and render_rainbow ~= 0 then
						surface.SetTextColor(HSVToColor((CurTime() * 60 + (j * 5)) % 360, 1, 1))
					else
						-- Render as solid white if ss_render_rainbow is disabled or server disabled via ss_enable_rainbow
						surface.SetTextColor(255, 255, 255)
					end
					--Text
					surface.DrawText(utf8.char(code))
				end
			else
				--Color
				surface.SetTextColor(data[i][COL])
				--Text
				surface.DrawText(data[i][TEXT])
			end

			render.PopFilterMin()
		cam.End3D2D()
	end

end

local plyShootPos, ang, pos, camangle, showFront, data -- Less variables being created each frame
function ENT:DrawTranslucent()
	-- Cache the shoot pos for this frame
	plyShootPos = LocalPlayer():GetShootPos()

	if screenInfo[self] ~= nil and self:GetPos():DistToSqr(plyShootPos) < render_range then
		ang = self:GetAngles()
		pos = self:GetPos() + ang:Up()
		camangle = Angle(ang.p, ang.y, ang.r)
		data = screenInfo[self]

		-- Should we draw both screens? (Third person/calview drawing fix)
		if shouldDrawBoth then
			Draw3D2D(ang, pos, camangle, data)
			camangle:RotateAroundAxis(camangle:Right(), 180)
			Draw3D2D(ang, pos, camangle, data)
		else
			-- Is the front of the screen facing us or the back?
			showFront = IsInFront(pos, plyShootPos, ang:Up())

			-- Draw the front of the screen
			if showFront then
				Draw3D2D(ang, pos, camangle, data)
			else
			-- Draw the back of the screen
				camangle:RotateAroundAxis(camangle:Right(), 180)
				Draw3D2D(ang, pos, camangle, data)
			end
		end
	end
end

local function AddDrawingInfo(ent, rawData)
	local drawData = {}
	local textSize = {}

	local totalHeight = 0
	local maxWidth = 0
	local currentHeight = 0

	for i = 1, #rawData do
		-- Setup tables
		if not rawData[i] or not rawData[i].text then continue end
		drawData[i] = {}
		textSize[i] = {}
		-- Text
		drawData[i][TEXT] = rawData[i].text
		-- Font
		drawData[i][FONT] = (ValidFont(rawData[i].font) or textscreenFonts[1])
		-- Text size
		surface.SetFont(drawData[i][FONT])
		textSize[i][1], textSize[i][2] = surface.GetTextSize(drawData[i][TEXT])
		textSize[i][2] = rawData[i].size
		-- Workout max width for render bounds
		maxWidth = maxWidth > textSize[i][1] and maxWidth or textSize[i][1]
		-- Position
		totalHeight = totalHeight + textSize[i][2]
		-- Colour
		drawData[i][COL] = Color(rawData[i].color.r, rawData[i].color.g, rawData[i].color.b, 255)
		-- Size
		drawData[i][SIZE] = rawData[i]["size"]
		-- Remove text if text is empty so we don't waste performance
		if string.len(drawData[i][TEXT]) == 0 or string.len(string.Replace( drawData[i][TEXT], " ", "" )) == 0 then drawData[i][TEXT] = nil end
		--Rainbow
		drawData[i][RAINBOW] = rawData[i]["rainbow"] or 0
	end

	-- Sort out heights
	for i = 1, #rawData do
		if not rawData[i] then continue end
		-- The x position at which to draw the text relative to the text screen entity
		drawData[i][POSX] = math.ceil(-textSize[i][1] / 2)
		-- The y position at which to draw the text relative to the text screen entity
		drawData[i][POSY] = math.ceil(-(totalHeight / 2) + currentHeight)
		-- Calculate the cam.Start3D2D size based on the size of the font
		drawData[i][CAMSIZE] = (0.25 * drawData[i][SIZE]) / 100
		-- Use the CAMSIZE to "scale" the POSY
		drawData[i][POSY] = (0.25 / drawData[i][CAMSIZE] * drawData[i][POSY])
		-- Highest line to lowest, so that everything is central
		currentHeight = currentHeight + textSize[i][2]
	end

	-- Cache the number of lines/length
	drawData[LEN] = #drawData
	-- Add the new data to our text screen list
	screenInfo[ent] = drawData

	-- Calculate the render bounds
	local x = maxWidth / widthBoundsDivider
	local y = currentHeight / heightBoundsDivider + 13 -- Text is above the centre

	-- Setup the render bounds
	ent:SetRenderBounds(Vector(-x, -y, -1.75), Vector(x, y, 1.75))
end

net.Receive("textscreens_update", function(len)
	local ent = net.ReadEntity()

	if IsValid(ent) and ent:GetClass() == "sammyservers_textscreen" then

		local t = net.ReadTable()

		ent.lines = t -- Incase an addon or something wants to read the information.

		AddDrawingInfo(ent, t)
	end
end)

-- Auto refresh
if IsValid(LocalPlayer()) then
	local screens = ents.FindByClass("sammyservers_textscreen")
	for k, v in ipairs(screens) do
		if screenInfo[v] == nil and v.lines ~= nil then
			AddDrawingInfo(v, v.lines)
		end
	end
end

--addons/joes_stuff/lua/entities/shield_3/cl_init.lua:
include('shared.lua')

--addons/sse_101/lua/entities/sse_board.lua:
AddCSLuaFile()


ENT.Base = "sse_base"
ENT.Category        = "SSE"
ENT.PrintName		= "Board"
ENT.Spawnable       = true
ENT.Editable = true
ENT.ConfigName = "Boards"
ENT.NoHudName = true

function ENT:Initialize()
    self:SetModel("models/hunter/plates/plate3x5.mdl")
    self:PhysicsInit(SOLID_VPHYSICS)
    self:SetMoveType(MOVETYPE_VPHYSICS)
    self:SetSolid(SOLID_VPHYSICS)

    if SERVER then 
        self:SetUseType(SIMPLE_USE)

        local phys = self:GetPhysicsObject()
        
        if IsValid(phys) then
            phys:EnableMotion(false)
        end
    end
end

if SERVER then
        


    util.AddNetworkString("SSE_Board_SetPage")
    net.Receive( "SSE_Board_SetPage", function( len, ply )
        local ent = net.ReadEntity()
        local page = net.ReadInt(8)

        if SSE:AntiSpam(ply) then return end

        if not ent:ConfigValue(ent:GetBoard()) then return end
        local boardData = ent:ConfigValue(ent:GetBoard())   
      
        if page > #boardData.pages then return end
        if page < 1 then return end

        ent:SetPage(page)
    end)

    function ENT:UpdateBoardData( name, old, new )
        if not self:ConfigValueNoPrint(new) then return end
        local boardData = self:ConfigValueNoPrint(new)

        self:SetModel( boardData.model  )
        self:PhysicsInit( SOLID_VPHYSICS )      -- Make us work with physics,
    end

end

function ENT:SetupDataTables()

    self:NetworkVar( "String", 0, "Board", { KeyName = "Boards",	Edit = { type = "Text"  } } ) 
    self:NetworkVar( "Int", 0, "Page" ) 


    if SERVER then
        self:SetBoard("Default")
        self:SetPage(1)
        self:NetworkVarNotify( "Board", self.UpdateBoardData )
    end

end


if CLIENT then


    ENT.RenderGroup = RENDERGROUP_TRANSLUCENT


    function ENT:NextPage()
          
        if not self:ConfigValue(self:GetBoard()) then return end
        local boardData = self:ConfigValue(self:GetBoard()) 
 

        if self:GetPage() >= #boardData.pages then return end

        net.Start("SSE_Board_SetPage")
            net.WriteEntity(self)
            net.WriteInt(self:GetPage()+1, 8)
        net.SendToServer()
    end 

    function ENT:PreviousPage()
                  
        if not self:ConfigValue(self:GetBoard()) then return end
         local boardData = self:ConfigValue(self:GetBoard())   
       
    
            if self:GetPage() <= 1 then return end
    
            net.Start("SSE_Board_SetPage")
                net.WriteEntity(self)
                net.WriteInt(self:GetPage()-1, 8)
            net.SendToServer()

    end


    function ENT:DrawTranslucent()
        
      local imgui = SSE.Imgui
        if not self:ConfigValueNoPrint(self:GetBoard())then return end
        local boardData = self:ConfigValueNoPrint(self:GetBoard())

        local page = boardData.pages[self:GetPage()]

        local pageMaterial = nil 

        if page.material then
            pageMaterial = Material(page.material)
        end
        if page.imgur then
            if not SSE_Imgur_Materials[page.imgur] then

                SSE.GetImgur(page.imgur, function(mat)
                    SSE_Imgur_Materials[page.imgur] = mat
                end)
            else 
                pageMaterial = SSE_Imgur_Materials[page.imgur]
            end
        end

        local x, y, w, h = -boardData.width/2, -boardData.height/2, boardData.width, boardData.height
        --self:DrawModel()

  
 
        if imgui.Entity3D2D(self, Vector(0, 0, 0), Angle(0, 90, 0), 0.1, 1000, 500) then

            draw.RoundedBox(0, x, y, w, h, boardData.background)

            if pageMaterial != nil then
                surface.SetDrawColor( 255, 255, 255, 255 ) -- Set the drawing color
                surface.SetMaterial( pageMaterial ) -- Use our cached material
                surface.DrawTexturedRect(x, y, w, h)
            else 
                draw.SimpleText("Board not configured", imgui.xFont("!Arial@50"), 0, 0, Color(255,0,0), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
            end
 
            if imgui.xTextButton(">", "!Arial@50", w/2-100, h/2-100, 75, 75, 1, Color(145,145,145), Color(255,255,255), Color(255,0,0)) then
                self:NextPage()
            end

            if imgui.xTextButton("<", "!Arial@50", -w/2+25, h/2-100, 75, 75, 1, Color(145,145,145), Color(255,255,255), Color(255,0,0)) then
                self:PreviousPage()
            end

        imgui.End3D2D()
        end
    end
end
--addons/sse_101/lua/entities/sse_galaxymap.lua:
AddCSLuaFile()


ENT.Base = "sse_base"

ENT.PrintName		= "Galaxymap"
ENT.Spawnable       = true
ENT.ConfigName = "GalaxyMap"
ENT.ClientInteraction = true
ENT.Category        = "SSE"

if CLIENT then

    function ENT:ClientUse()
        local frame =  SSE:DefaultFrame("The Galaxy")
        frame:SetSize(ScrW() * 0.8, ScrH() * 0.8)
        frame:Center()

        local html = vgui.Create("DHTML", frame)
        html:Dock(FILL)
        html:OpenURL("https://hbernberg.carto.com/builder/6650a85d-b115-4680-ab97-721bf8a41a90/embed")
    end

end




--addons/sse_101/lua/entities/sse_holotable.lua:
AddCSLuaFile()


ENT.Base = "sse_base"

ENT.PrintName		= "Holotable"
ENT.Spawnable       = true
ENT.ConfigName = "Holotable"
ENT.NoHudName = true
ENT.Category        = "SSE"

if SERVER then
        
    
    function ENT:Use( activator, caller )
        if ( !activator.IsHologram ) then
            activator.IsHologram = true
            activator:SetMaterial( self:ConfigValue("Material") )
        else
            activator.IsHologram = false
            activator:SetMaterial( "") 
        end
    end


end


--addons/sse_101/lua/entities/sse_liveradar.lua:
AddCSLuaFile()



ENT.Base = "sse_base"
ENT.PrintName		= "Live Radar Scanner"
ENT.Spawnable       = true
ENT.ConfigName = "LiveScanner"
ENT.NoHudName = true
ENT.Category        = "SSE"


if CLIENT then




    ENT.RenderGroup = RENDERGROUP_TRANSLUCENT

    
    function ENT:DrawTranslucent()

        local imgui = SSE.Imgui

        local radarSize = self:ConfigValue("Size") -- Half of the radar size (since the radar is square)
        
        -- Fetch map bounds
        local world = game.GetWorld()
        local mapMinBound, mapMaxBound = world:GetModelBounds()
        
        -- Function to map world coordinates to radar coordinates
        local function WorldToRadar(worldPos)
            -- Calculate scale based on the map bounds
            local scaleX = radarSize * 2 / (mapMaxBound.x - mapMinBound.x)
            local scaleY = radarSize * 2 / (mapMaxBound.y - mapMinBound.y)
    
            -- Convert world position to radar position
            local radarX = (worldPos.x - mapMinBound.x) * scaleX - radarSize
            local radarY = (worldPos.y - mapMinBound.y) * scaleY - radarSize
    
            -- Clamp to ensure the position stays within the radar square
            radarX = math.Clamp(radarX, -radarSize, radarSize)
            radarY = math.Clamp(radarY, -radarSize, radarSize)
    
            return radarX, radarY
        end
    
        if imgui.Entity3D2D(self, Vector(0, 0, 0), Angle(0, 90, 0), 0.1, 1000, 500) then
            -- Draw filled radar square
            draw.RoundedBox(0, -radarSize, -radarSize, radarSize * 2, radarSize * 2, self:ConfigValue("BackgroundColor"))
    
            -- Draw radar center
            --draw.RoundedBox(50, -5, -5, 10, 10, Color(0, 255, 0, 200))
    

            -- Draw radar border
            surface.SetDrawColor(255, 255, 255, 255)
            surface.DrawOutlinedRect(-radarSize, -radarSize, radarSize * 2, radarSize * 2)


            local rX, rY = WorldToRadar(self:GetPos())
            draw.RoundedBox(50, rX-5,rY-5, 10, 10, self:ConfigValue("SelfColor") )

            for k, v in ipairs(ents.GetAll()) do
                if !v.LVS then continue end
          
                local pX, pY = WorldToRadar(v:GetPos())
    
                local name = v.PrintName or ""
                -- Ensure the player dot is drawn within radar boundaries
                if math.abs(pX) <= radarSize and math.abs(pY) <= radarSize then
                    draw.RoundedBox(50, pX - 5, pY - 5, 10, 10, self:ConfigValue("Target"))

                     if self:ConfigValueNoPrint("ShowNames") then 
                        draw.DrawText(name  .. " # ".. v:EntIndex(), SSE.xFont("!Agency FB@15#1"), pX, pY+2, Color(255,255,255), TEXT_ALIGN_CENTER)
                    end
                end
            end
    
            imgui.End3D2D()
        end
    end
    
    

    
end
--addons/arccw_weapons/lua/entities/tfa_battlefront_ent_nade_thermal.lua:
AddCSLuaFile()
ENT.Type = "anim"
ENT.Base = "arccw_thr"
ENT.Spawnable = false

function ENT:Draw()
	self:DrawModel()
end

function ENT:Initialize()
	if SERVER then
		self:SetModel( "models/weapons/tfa_starwars/w_thermal.mdl" )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )
		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetCollisionGroup( COLLISION_GROUP_WEAPON )
		self:DrawShadow( true )
	end
	self:EmitSound("weapons/tfa_starwars/ThermalDetonator_Beeps_01.wav")
	self.ExplodeTimer = CurTime() + 2.5
end

function ENT:Think()
	if SERVER and self.ExplodeTimer <= CurTime() then
		self:Explode()
		self:Remove()
	end
end

function ENT:PhysicsCollide( data )
	if SERVER and data.Speed > 150 then
	self:EmitSound( "TFA_CSGO_HEGrenade.Bounce" )
	end
end

function ENT:OnRemove()
end

function ENT:Explode()
	local effectdata = EffectData()
    effectdata:SetOrigin( self:GetPos() )
    util.Effect("Explosion", effectdata)
	util.BlastDamage( self, self.Owner, self:GetPos(), 350, 150 )
	local spos = self:GetPos()
	local trs = util.TraceLine({start=spos + Vector(0,0,64), endpos=spos + Vector(0,0,-32), filter=self})
	util.Decal("Scorch", trs.HitPos + trs.HitNormal, trs.HitPos - trs.HitNormal)    
end
--addons/wos-passiveevent-ageo/lua/entities/wos_pes_capture_point/cl_init.lua:
include("shared.lua")

surface.CreateFont( "wOS.PES.CapturePoint", {
	font = "Arial",
	extended = false,
	size = 35,
	weight = 1000,
    shadow = true,
    outline = false
} )

surface.CreateFont( "wOS.PES.3DFont", {
	font = "Arial",
	extended = false,
	size = 100,
	weight = 500,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
} )

function ENT:Initialize()
    self:SharedInit()
    timer.Simple(0, function()
        local mins = self:OBBMins()
        local maxs = self:OBBMaxs()
        maxs.z = maxs.z + 30
        self:SetRenderBounds(mins, maxs)
    end)
end

function ENT:Draw()
    self:DrawModel()

    local p = self:GetPos()

    p.z = p.z + self:OBBMaxs().z

    local radS = self:GetCaptureRange()*self:GetCaptureRange()

    if LocalPlayer():GetPos():DistToSqr(p) < radS then

        local ang = self:GetAngles()
        ang:RotateAroundAxis( ang:Forward(), 90 )
        ang:RotateAroundAxis( ang:Up(), 90 )
        ang.y = LocalPlayer():EyeAngles().y - 90

        if !self.currentValue then self.currentValue = self:GetCaptureValue() end

        self.currentValue = math.Approach( self.currentValue, self:GetCaptureValue(), FrameTime() * 20 )

        local maxValue = self:GetMaxCaptureValue()

        local size = 400
        local height = 50

        cam.Start3D2D( p + Vector( 0, 0, 30 ), Angle( 0, ang.y, 90 ), .15 )
            draw.RoundedBox( 5, -size/2, 0, size, height, Color( 0, 0, 0, 230 ) )
            draw.RoundedBox( 5, - size/2 + 2, 2, math.Clamp( self.currentValue/maxValue , 0, 1 ) * (size-4), height -4, Color( 0, 0, 100, 230 ) )

            if self:GetCaptureValue() == self:GetMaxCaptureValue() then
                draw.DrawText( "Captured", "wOS.PES.CapturePoint", 0, 2, Color( 255, 255, 255, 255 ), 1, 1 )
            else
                draw.DrawText( "Capturing...", "wOS.PES.CapturePoint", 0, 2, Color( 255, 255, 255, 255 ), 1, 1 )
            end
        cam.End3D2D()
    end
end

--addons/arccw_weapons/lua/effects/arccw_apex_tracer_energy_sg/init.lua:
EFFECT.TracerName = "tfa_apex_energy_tracer_shotgun"

function EFFECT:Init(data)
    self.WeaponEnt = data:GetEntity()
    --print(self.ParticleName)
    if not IsValid(self.WeaponEnt) then return end
    self.Attachment = data:GetAttachment() or 1
    self.Position = self:GetTracerShootPos(data:GetStart(), self.WeaponEnt, self.Attachment)

    if IsValid(self.WeaponEnt.Owner) then
        if self.WeaponEnt.Owner == LocalPlayer() then
            if not self.WeaponEnt.Owner:GetViewEntity() then
                ang = self.WeaponEnt.Owner:EyeAngles()
                ang:Normalize()
                --ang.p = math.max(math.min(ang.p,55),-55)
                self.Forward = ang:Forward()
            else
                self.WeaponEnt = self.WeaponEnt.Owner:GetViewModel()
            end
            --ang.p = math.max(math.min(ang.p,55),-55)
        else
            ang = self.WeaponEnt.Owner:EyeAngles()
            ang:Normalize()
            self.Forward = ang:Forward()
        end
    end

    self.EndPos = data:GetOrigin()
    -- util.ParticleTracerEx(self.ParticleName, self.StartPos, self.EndPos, false, self:EntIndex(), self.Attachment)
    local pcf = CreateParticleSystem(self.WeaponEnt, self.TracerName, PATTACH_POINT, self.Attachment)
    if IsValid(pcf) then
        pcf:SetControlPoint(0,self.Position)
        pcf:SetControlPoint(1,self.EndPos)
        pcf:StartEmission()
    end
    timer.Simple(5.0, function()
        if IsValid(pcf) then
            pcf:StopEmissionAndDestroyImmediately()
        end
    end)
end

function EFFECT:Think()
    return false
end

function EFFECT:Render()
    if self.InValid then return false end
end
--addons/arccw_weapons/lua/effects/effect_astw2_halo2_impact_plasmarifle/init.lua:
EFFECT.Duration			= 0.25;
EFFECT.Size				= 32;

local MaterialGlow		= Material( "effects/halo3/8pt_ringed_star_flare" );

function EFFECT:Init( data )

	self.Position = data:GetOrigin();
	self.Normal = data:GetNormal();
	self.LifeTime = self.Duration;

	-- particles
	local emitter = ParticleEmitter( self.Position );
	if( emitter ) then
		
		for i = 1, 1 do

			local particle = emitter:Add( "effects/halo3/flash_large", self.Position + self.Normal * 2 );
			particle:SetVelocity( ( self.Normal + Vector(math.Rand(3, 5),math.Rand(3, 5),1) * 0.75 ):GetNormal() * math.Rand( 75, 125 ) );
			particle:SetDieTime( math.Rand( 0.05, 0.15 ) );
			particle:SetStartAlpha( 255 );
			particle:SetEndAlpha( 0 );
			particle:SetStartSize( math.Rand( 3, 5 ) );
			particle:SetEndSize( 35 );
			particle:SetRoll( math.Rand(-55, 85) );
			particle:SetGravity( Vector( 0, 0, 0 ) );
			particle:SetColor(100, 100, 255);
			particle:SetCollide( true );
			particle:SetBounce( 0 );
			particle:SetAirResistance( 500 );

		end
	for i = 1, 1 do

			local particle = emitter:Add( "effects/halo3/explosive_burst", self.Position + self.Normal * 2 );
			particle:SetVelocity( ( self.Normal + Vector(math.Rand(3, 5),math.Rand(3, 5),1) * 0.75 ):GetNormal() * math.Rand( 75, 125 ) );
			particle:SetDieTime( math.Rand( 0.1, 0.2 ) );
			particle:SetStartAlpha( 255 );
			particle:SetEndAlpha( 0 );
			particle:SetStartSize( math.Rand( 3, 5 ) );
			particle:SetEndSize( 30 );
			particle:SetRoll( math.Rand(-55, 85) );
			particle:SetGravity( Vector( 0, 0, 0 ) );
			particle:SetColor(100, 100, 255);
			particle:SetCollide( true );
			particle:SetBounce( 0 );
			particle:SetAirResistance( 500 );

		end
		emitter:Finish();
	end
	end


function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime();
	return self.LifeTime > 0;

end


function EFFECT:Render()

	local frac = math.max( 0, self.LifeTime / self.Duration );
	local rgb = 255 * frac;
	local color = Color( rgb, rgb, 255, 255 );

	render.SetMaterial( MaterialGlow );
	render.DrawQuadEasy( self.Position + self.Normal, self.Normal, self.Size, self.Size, color );

end

--addons/arccw_weapons/lua/effects/effect_astw2_halo2_tracer_human/init.lua:

local Tracer = Material( "effects/halo2/contrail_human" )
local Tracer2  = Material( "effects/halo2/contrail_human" )
local Width = 3
local Width2 = 8

function EFFECT:Init( data )

	self.Position = data:GetStart()
	self.EndPos = data:GetOrigin()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()
	self.StartPos = self:GetTracerShootPos( self.Position, self.WeaponEnt, self.Attachment )
	self:SetRenderBoundsWS( self.StartPos, self.EndPos )

	self.Dir = ( self.EndPos - self.StartPos ):GetNormalized()
	self.Dist = self.StartPos:Distance( self.EndPos )
	
	self.LifeTime = 0.15
	self.LifeTime2 = 0.1 * 1/2
	self.DieTime = CurTime() + self.LifeTime
	self.DieTime2 = CurTime() + self.LifeTime2

end

function EFFECT:Think()

	if ( CurTime() > self.DieTime ) then return false end
	return true

end

function EFFECT:Render()

	local r = 255
	local g = 255
	local b = 255
	
	local v = ( self.DieTime - CurTime() ) / self.LifeTime
	
	local v2 = ( self.DieTime2 - CurTime() ) / self.LifeTime2

	render.SetMaterial( Tracer )
	render.DrawBeam( self.StartPos, self.EndPos, (v * Width)*3/2, 0, (self.Dist/10)*math.Rand(-2,2), Color( 255, 255, 200, v * 155 ) )
	
	render.SetMaterial( Tracer2 )
	render.DrawBeam( self.StartPos, self.EndPos, (v2 * Width2)*2/3, 0, (self.Dist/10)*math.Rand(-2,2), Color( r, b, g, (v2 * 155)*3/2.5 ) )

end

--addons/arccw_weapons/lua/effects/effect_astw2_halo2_tracer_plasmapistol/init.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002;
SOUND_FROM_WORLD			= 0;
CHAN_STATIC					= 6;

EFFECT.Speed				= 4000;
EFFECT.Length				= 96;
//EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 72;

local MaterialMain			= Material( "effects/halo_spv3/flash/muzzle_flash/muzzle_flash_pp_side" );
local MaterialFront			= Material( "effects/halo_ce/flare_pr_overcharge" );

function EFFECT:GetTracerOrigin( data )

	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart();
	
	-- use attachment?
	if( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then

		local entity = data:GetEntity();
		
		if( not IsValid( entity ) ) then return start; end
		if( not game.SinglePlayer() and entity:IsEFlagSet( EFL_DORMANT ) ) then return start; end
		
		if( entity:IsWeapon() and entity:IsCarriedByLocalPlayer() ) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			
			-- use the view model
			local pl = entity:GetOwner();
			if( IsValid( pl ) ) then
				local vm = pl:GetViewModel();
				if( IsValid( vm ) and not LocalPlayer():ShouldDrawLocalPlayer() ) then
					entity = vm;
				else
					-- HACK: fix the model in multiplayer
					if( entity.WorldModel ) then
						entity:SetModel( entity.WorldModel );
					end
				end
			end
		end

		local attachment = entity:GetAttachment( data:GetAttachment() );
		if( attachment ) then
			start = attachment.Pos;
		end

	end
	
	return start;

end


function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data );
	self.EndPos = data:GetOrigin();
	
	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos );

	local diff = ( self.EndPos - self.StartPos );
	
	self.Normal = diff:GetNormal();
	self.StartTime = 0;
	self.LifeTime = ( diff:Length() + self.Length ) / self.Speed;
	
	-- whiz by sound
	local weapon = data:GetEntity();
	if( IsValid( weapon ) and ( not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer() ) ) then

		local dist, pos, time = util.DistanceToLine( self.StartPos, self.EndPos, EyePos() );
	end

end


function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime();
	self.StartTime = self.StartTime + FrameTime(); 

	return self.LifeTime > 0;

end


function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime;
	local startDistance = endDistance - self.Length;
	
	startDistance = math.max( 0, startDistance );
	endDistance = math.max( 0, endDistance );

	local startPos = self.StartPos + self.Normal * startDistance;
	local endPos = self.StartPos + self.Normal * endDistance;
	
	render.SetMaterial( MaterialFront );
	render.DrawSprite( endPos, 0, 0, color_white );

	render.SetMaterial( MaterialMain );
	render.DrawBeam( startPos, endPos, 5, 0, 1, color_white );
	
end

--addons/arccw_weapons/lua/effects/effect_astw2_halo3_impact_needler/init.lua:
EFFECT.Duration			= 0.25;
EFFECT.Size				= 16;

local MaterialGlow		= Material( "effects/halo3/flare1" );

function EFFECT:Init( data )

	self.Position = data:GetOrigin();
	self.Normal = data:GetNormal();
	self.LifeTime = self.Duration;

	-- particles
	local emitter = ParticleEmitter( self.Position );
	if( emitter ) then
		
		for i = 1, 1 do

			local particle = emitter:Add( "effects/halo3/flash_large", self.Position + self.Normal * 2 );
			particle:SetVelocity( ( self.Normal + Vector(math.Rand(3, 5),math.Rand(3, 5),1) * 0.75 ):GetNormal() * math.Rand( 75, 125 ) );
			particle:SetDieTime( math.Rand( 0.05, 0.15 ) );
			particle:SetStartAlpha( 255 );
			particle:SetEndAlpha( 0 );
			particle:SetStartSize( math.Rand( 3, 5 ) );
			particle:SetEndSize( 30 );
			particle:SetRoll( math.Rand(-55, 85) );
			particle:SetGravity( Vector( 0, 0, 0 ) );
			particle:SetColor(255, 200, 240);
			particle:SetCollide( true );
			particle:SetBounce( 0 );
			particle:SetAirResistance( 500 );

		end
		
		for i = 1, 1 do

			local particle = emitter:Add( "effects/halo3/muzzle_flash_round_gaseous", self.Position + self.Normal * 2 );
			particle:SetVelocity( ( self.Normal + Vector(math.Rand(3, 5),math.Rand(3, 5),1) * 0.75 ):GetNormal() * math.Rand( 75, 125 ) );
			particle:SetDieTime( math.Rand( 0.2, 0.3 ) );
			particle:SetStartAlpha( 155 );
			particle:SetEndAlpha( 0 );
			particle:SetStartSize( math.Rand( 3, 5 ) );
			particle:SetEndSize( 25 );
			particle:SetRoll( math.Rand(-55, 85) );
			particle:SetGravity( Vector( 0, 0, 0 ) );
			particle:SetColor(255, 175, 225);
			particle:SetCollide( true );
			particle:SetBounce( 0 );
			particle:SetAirResistance( 500 );

		end

		for i = 1, 1 do

			local particle = emitter:Add( "effects/halo3/electric_arcs", self.Position + self.Normal * 2 );
			particle:SetVelocity( ( self.Normal + Vector(math.Rand(3, 5),math.Rand(3, 5),1) * 0.75 ):GetNormal() * math.Rand( 75, 125 ) );
			particle:SetDieTime( math.Rand( 0.05, 0.1 ) );
			particle:SetStartAlpha( 255 );
			particle:SetEndAlpha( 0 );
			particle:SetStartSize( math.Rand( 3, 5 ) );
			particle:SetEndSize( 20 );
			particle:SetRoll( math.Rand(-55, 85) );
			particle:SetGravity( Vector( 0, 0, 0 ) );
			particle:SetColor(255, 175, 225);
			particle:SetCollide( true );
			particle:SetBounce( 0 );
			particle:SetAirResistance( 500 );

		end
		
	for i = 1, 1 do

			local particle = emitter:Add( "effects/halo3/explosive_burst", self.Position + self.Normal * 2 );
			particle:SetVelocity( ( self.Normal + Vector(math.Rand(3, 5),math.Rand(3, 5),1) * 0.75 ):GetNormal() * math.Rand( 75, 125 ) );
			particle:SetDieTime( math.Rand( 0.1, 0.2 ) );
			particle:SetStartAlpha( 255 );
			particle:SetEndAlpha( 0 );
			particle:SetStartSize( math.Rand( 3, 5 ) );
			particle:SetEndSize( 25 );
			particle:SetRoll( math.Rand(-55, 85) );
			particle:SetGravity( Vector( 0, 0, 0 ) );
			particle:SetColor(255, 200, 240);
			particle:SetCollide( true );
			particle:SetBounce( 0 );
			particle:SetAirResistance( 500 );

		end
		emitter:Finish();
	end
	end


function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime();
	return self.LifeTime > 0;

end


function EFFECT:Render()

	local frac = math.max( 0, self.LifeTime / self.Duration );
	local rgb = 255 * frac;
	local color = Color( 255, 200, 225, 255 );

	render.SetMaterial( MaterialGlow );
	render.DrawQuadEasy( self.Position + self.Normal, self.Normal, self.Size, self.Size, color );

end

--addons/arccw_weapons/lua/effects/effect_astw2_halo_ce_impact_pr/init.lua:
EFFECT.Duration			= 0.25;
EFFECT.Size				= 48;

local MaterialGlow		= Material( "effects/halo_ce/flare_pr_overcharge" );

function EFFECT:Init( data )

	self.Position = data:GetOrigin();
	self.Normal = data:GetNormal();
	self.LifeTime = self.Duration;

	-- particles
	local emitter = ParticleEmitter( self.Position );
	if( emitter ) then
		
		for i = 1, 1 do

			local particle = emitter:Add( "effects/halo_ce/flare_generic2", self.Position + self.Normal * 2 );
			particle:SetVelocity( ( self.Normal + Vector(math.Rand(3, 5),math.Rand(3, 5),1) * 0.75 ):GetNormal() * math.Rand( 75, 125 ) );
			particle:SetDieTime( math.Rand( 0.05, 0.15 ) );
			particle:SetStartAlpha( 255 );
			particle:SetEndAlpha( 0 );
			particle:SetStartSize( math.Rand( 3, 5 ) );
			particle:SetEndSize( 30 );
			particle:SetRoll( math.Rand(-55, 85) );
			particle:SetGravity( Vector( 0, 0, 0 ) );
			particle:SetColor(135, 135, 255);
			particle:SetCollide( true );
			particle:SetBounce( 0 );
			particle:SetAirResistance( 500 );

		end
		
		for i = 1, 1 do

			local particle = emitter:Add( "effects/halo_ce/flare_generic2a", self.Position + self.Normal * 2 );
			particle:SetVelocity( ( self.Normal + Vector(math.Rand(3, 5),math.Rand(3, 5),1) * 0.75 ):GetNormal() * math.Rand( 75, 125 ) );
			particle:SetDieTime( math.Rand( 0.2, 0.3 ) );
			particle:SetStartAlpha( 255 );
			particle:SetEndAlpha( 0 );
			particle:SetStartSize( math.Rand( 3, 5 ) );
			particle:SetEndSize( 25 );
			particle:SetRoll( math.Rand(-55, 85) );
			particle:SetGravity( Vector( 0, 0, 0 ) );
			particle:SetColor(135, 135, 255);
			particle:SetCollide( true );
			particle:SetBounce( 0 );
			particle:SetAirResistance( 500 );

		end

		
	for i = 1, 1 do

			local particle = emitter:Add( "effects/halo_ce/flare_pr_overcharge", self.Position + self.Normal * 2 );
			particle:SetVelocity( ( self.Normal + Vector(math.Rand(3, 5),math.Rand(3, 5),1) * 0.75 ):GetNormal() * math.Rand( 75, 125 ) );
			particle:SetDieTime( math.Rand( 0.1, 0.2 ) );
			particle:SetStartAlpha( 255 );
			particle:SetEndAlpha( 0 );
			particle:SetStartSize( math.Rand( 3, 5 ) );
			particle:SetEndSize( 35 );
			particle:SetRoll( math.Rand(-55, 85) );
			particle:SetGravity( Vector( 0, 0, 0 ) );
			particle:SetColor(225, 225, 255);
			particle:SetCollide( true );
			particle:SetBounce( 0 );
			particle:SetAirResistance( 500 );

		end
		emitter:Finish();
	end
	end


function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime();
	return self.LifeTime > 0;

end


function EFFECT:Render()

	local frac = math.max( 0, self.LifeTime / self.Duration );
	local rgb = 255 * frac;
	local color = Color( 135, 135, 255, 255 );

	render.SetMaterial( MaterialGlow );
	render.DrawQuadEasy( self.Position + self.Normal, self.Normal, self.Size, self.Size, color );

end

--addons/arccw_weapons/lua/effects/effect_astw2_halo_spv3_tracer_plasma_rifle/init.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002;
SOUND_FROM_WORLD			= 0;
CHAN_STATIC					= 6;

EFFECT.Speed				= 1500;
EFFECT.Length				= 90;
//EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 72;

local MaterialMain			= Material( "effects/halo_spv3/flash/muzzle_flash/muzzle_flash_pr_side" );
local MaterialFront			= Material( "effects/halo_spv3/flash/smg_new" );

function EFFECT:GetTracerOrigin( data )

	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart();
	
	-- use attachment?
	if( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then

		local entity = data:GetEntity();
		
		if( not IsValid( entity ) ) then return start; end
		if( not game.SinglePlayer() and entity:IsEFlagSet( EFL_DORMANT ) ) then return start; end
		
		if( entity:IsWeapon() and entity:IsCarriedByLocalPlayer() ) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			
			-- use the view model
			local pl = entity:GetOwner();
			if( IsValid( pl ) ) then
				local vm = pl:GetViewModel();
				if( IsValid( vm ) and not LocalPlayer():ShouldDrawLocalPlayer() ) then
					entity = vm;
				else
					-- HACK: fix the model in multiplayer
					if( entity.WorldModel ) then
						entity:SetModel( entity.WorldModel );
					end
				end
			end
		end

		local attachment = entity:GetAttachment( data:GetAttachment() );
		if( attachment ) then
			start = attachment.Pos;
		end

	end
	
	return start;

end


function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data );
	self.EndPos = data:GetOrigin();
	
	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos );

	local diff = ( self.EndPos - self.StartPos );
	
	self.Normal = diff:GetNormal();
	self.StartTime = 0;
	self.LifeTime = ( diff:Length() + self.Length ) / self.Speed;
	
	-- whiz by sound
	local weapon = data:GetEntity();
	if( IsValid( weapon ) and ( not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer() ) ) then

		local dist, pos, time = util.DistanceToLine( self.StartPos, self.EndPos, EyePos() );
	end

end


function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime();
	self.StartTime = self.StartTime + FrameTime(); 

	return self.LifeTime > 0;

end


function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime;
	local startDistance = endDistance - self.Length;
	
	startDistance = math.max( 0, startDistance );
	endDistance = math.max( 0, endDistance );

	local startPos = self.StartPos + self.Normal * startDistance;
	local endPos = self.StartPos + self.Normal * endDistance;
	
	render.SetMaterial( MaterialFront );
	render.DrawSprite( endPos, 0, 0, color_white );

	render.SetMaterial( MaterialMain );
	render.DrawBeam( startPos, endPos, 6, 0, 1, color_white );
	
end

--addons/arccw_weapons/lua/effects/effect_astw2_swbf_impact_2/init.lua:
EFFECT.Duration			= 0.25;
EFFECT.Size				= 32;

local MaterialGlow		= Material( "effects/sw_laser_bit" );

function EFFECT:Init( data )

	self.Position = data:GetOrigin();
	self.Normal = data:GetNormal();
	self.LifeTime = self.Duration;

	-- particles
	local emitter = ParticleEmitter( self.Position );
	if( emitter ) then
		
		for i = 1, 32 do

			local particle = emitter:Add( "effects/sw_laser_bit", self.Position + self.Normal * 2 );
			particle:SetVelocity( ( self.Normal + VectorRand() * 0.75 ):GetNormal() * math.Rand( 75, 125 ) );
			particle:SetDieTime( math.Rand( 0.5, 1.25 ) );
			particle:SetStartAlpha( 255 );
			particle:SetEndAlpha( 0 );
			particle:SetStartSize( math.Rand( 4, 8 ) );
			particle:SetEndSize( 0 );
			particle:SetRoll( 0 );
			particle:SetGravity( Vector( 0, 0, -250 ) );
			particle:SetCollide( true );
			particle:SetBounce( 0.3 );
			particle:SetAirResistance( 5 );

		end
		emitter:Finish();
	end
	
	local emitter_s = ParticleEmitter( self.Position );
	if( emitter_s ) then
		for i = 1, 8 do
			local smokeTexture	= "effects/awoi_musket_smoke_01"
			
			local particle_s = emitter_s:Add(smokeTexture, self.Position+self.Normal*2);
			particle_s:SetVelocity((self.Normal+VectorRand()*0.10):GetNormal()*math.Rand(250, 2500));
			particle_s:SetDieTime(math.Rand(1, 3));
			particle_s:SetStartAlpha(150);
			particle_s:SetEndAlpha(0);
			particle_s:SetStartSize(math.Rand(10, 20));
			particle_s:SetEndSize(math.Rand(10, 20));
			particle_s:SetGravity(Vector(math.Rand(0, 500), math.Rand(250, 1000), math.Rand(-250, 250)));
			particle_s:SetRoll(math.Rand(0, 360));
			particle_s:SetRollDelta(math.Rand(-0.5, 0.5));
			local colour = math.Rand(50, 150);
			particle_s:SetColor(colour, colour, colour, 100);
			particle_s:SetCollide(false);
			particle_s:SetAirResistance(2000);
		end
		emitter_s:Finish();
	end
	
end


function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime();
	return self.LifeTime > 0;

end


function EFFECT:Render()

	local frac = math.max( 0, self.LifeTime / self.Duration );
	local rgb = 255 * frac;
	local color = Color( rgb, rgb, rgb, 255 );

	render.SetMaterial( MaterialGlow );
	render.DrawQuadEasy( self.Position + self.Normal, self.Normal, self.Size, self.Size, color );

end

--addons/arccw_weapons/lua/effects/effect_astw2_swbf_laser_purple_sniper/init.lua:

local Tracer = Material( "effects/laser1" )
local Tracer2  = Material( "effects/swbf/blue_beam" )
local Width = 15
local Width2 = 10

function EFFECT:Init( data )

	self.Position = data:GetStart()
	self.EndPos = data:GetOrigin()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()
	self.StartPos = self:GetTracerShootPos( self.Position, self.WeaponEnt, self.Attachment )
	self:SetRenderBoundsWS( self.StartPos, self.EndPos )

	self.Dir = ( self.EndPos - self.StartPos ):GetNormalized()
	self.Dist = self.StartPos:Distance( self.EndPos )
	
	self.LifeTime = 0.25
	self.LifeTime2 = 0.45
	self.DieTime = CurTime() + self.LifeTime
	self.DieTime2 = CurTime() + self.LifeTime2

end

function EFFECT:Think()

	if ( CurTime() > self.DieTime ) then return false end
	return true

end

function EFFECT:Render()

	local r = 255
	local g = 255
	local b = 255
	
	local v = ( self.DieTime - CurTime() ) / self.LifeTime
	
	local v2 = ( self.DieTime2 - CurTime() ) / self.LifeTime2

	render.SetMaterial( Tracer )
	render.DrawBeam( self.StartPos, self.EndPos, (v * Width)*3/2, 0, (self.Dist/10)*math.Rand(-2,2), Color( 255, 50, 255, v * 100 ) )
	
	render.SetMaterial( Tracer2 )
	render.DrawBeam( self.StartPos, self.EndPos, (v2 * Width2)*2/3, 0, (self.Dist/10)*math.Rand(-2,2), Color( 255, 85, 255, (v2 * 100)*3/2.5 ) )

end

--addons/arccw_weapons/lua/effects/effect_astw2_swbf_laser_red_sniper/init.lua:

local Tracer = Material( "effects/laser1" )
local Tracer2  = Material( "effects/swbf/red_beam" )
local Width = 15
local Width2 = 10

function EFFECT:Init( data )

	self.Position = data:GetStart()
	self.EndPos = data:GetOrigin()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()
	self.StartPos = self:GetTracerShootPos( self.Position, self.WeaponEnt, self.Attachment )
	self:SetRenderBoundsWS( self.StartPos, self.EndPos )

	self.Dir = ( self.EndPos - self.StartPos ):GetNormalized()
	self.Dist = self.StartPos:Distance( self.EndPos )
	
	self.LifeTime = 0.25
	self.LifeTime2 = 0.45
	self.DieTime = CurTime() + self.LifeTime
	self.DieTime2 = CurTime() + self.LifeTime2

end

function EFFECT:Think()

	if ( CurTime() > self.DieTime ) then return false end
	return true

end

function EFFECT:Render()

	local r = 255
	local g = 255
	local b = 255
	
	local v = ( self.DieTime - CurTime() ) / self.LifeTime
	
	local v2 = ( self.DieTime2 - CurTime() ) / self.LifeTime2

	render.SetMaterial( Tracer )
	render.DrawBeam( self.StartPos, self.EndPos, (v * Width)*3/2, 0, (self.Dist/10)*math.Rand(-2,2), Color( 255, 35, 15, v * 100 ) )
	
	render.SetMaterial( Tracer2 )
	render.DrawBeam( self.StartPos, self.EndPos, (v2 * Width2)*2/3, 0, (self.Dist/10)*math.Rand(-2,2), Color( 255, 255, 255, (v2 * 100)*3/2.5 ) )

end

--addons/arccw_weapons/lua/effects/effect_astw2_swbf_laser_teal/init.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002;
SOUND_FROM_WORLD			= 0;
CHAN_STATIC					= 6;

EFFECT.Speed				= 4000;
EFFECT.Length				= 128;
//EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 72;

local MaterialMain			= Material( "effects/swbf/blasterfire_tor" );
local MaterialFront			= Material( "effects/swbf/blasterfire_tor" );

function EFFECT:GetTracerOrigin( data )

	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart();
	
	-- use attachment?
	if( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then

		local entity = data:GetEntity();
		
		if( not IsValid( entity ) ) then return start; end
		if( not game.SinglePlayer() and entity:IsEFlagSet( EFL_DORMANT ) ) then return start; end
		
		if( entity:IsWeapon() and entity:IsCarriedByLocalPlayer() ) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			
			-- use the view model
			local pl = entity:GetOwner();
			if( IsValid( pl ) ) then
				local vm = pl:GetViewModel();
				if( IsValid( vm ) and not LocalPlayer():ShouldDrawLocalPlayer() ) then
					entity = vm;
				else
					-- HACK: fix the model in multiplayer
					if( entity.WorldModel ) then
						entity:SetModel( entity.WorldModel );
					end
				end
			end
		end

		local attachment = entity:GetAttachment( data:GetAttachment() );
		if( attachment ) then
			start = attachment.Pos;
		end

	end
	
	return start;

end


function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data );
	self.EndPos = data:GetOrigin();
	
	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos );

	local diff = ( self.EndPos - self.StartPos );
	
	self.Normal = diff:GetNormal();
	self.StartTime = 0;
	self.LifeTime = ( diff:Length() + self.Length ) / self.Speed;
	
	-- whiz by sound
	local weapon = data:GetEntity();
	if( IsValid( weapon ) and ( not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer() ) ) then

		local dist, pos, time = util.DistanceToLine( self.StartPos, self.EndPos, EyePos() );
	end
end


function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime();
	self.StartTime = self.StartTime + FrameTime(); 

	return self.LifeTime > 0;

end


function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime;
	local startDistance = endDistance - self.Length;
	
	startDistance = math.max( 0, startDistance );
	endDistance = math.max( 0, endDistance );

	local startPos = self.StartPos + self.Normal * startDistance;
	local endPos = self.StartPos + self.Normal * endDistance;
	
	render.SetMaterial( MaterialFront );
	render.DrawSprite( endPos, 0, 0, color_white );

	render.SetMaterial( MaterialMain );
	render.DrawBeam( startPos, endPos, 20, 0, 1, color_white );
	
end

--addons/star_wars_mortar/lua/effects/effect_smokenade_smoke/init.lua:
function EFFECT:Init(data)

	local emitter = ParticleEmitter(data:GetOrigin())

		for i = 0, 128 do

			if !emitter then return end

			local Pos = (data:GetOrigin() + Vector( math.Rand(-32,32), math.Rand(-32,32), math.Rand(-32,32) ) + Vector(0,0,64))

			local particle = emitter:Add( "particle/particle_smokegrenade", Pos )
			if (particle) then

				particle:SetVelocity(VectorRand() * math.Rand(1420,5200))

				particle:SetLifeTime(0)
				particle:SetDieTime(math.Rand(16, 18))

				local rand = math.random(242,255)
				if math.random(1,10) == 10 then rand = math.random(210,232) end
				particle:SetColor(rand,rand,rand)

				particle:SetStartAlpha(math.Rand(242,255))
				particle:SetEndAlpha(0)

				local Size = math.Rand(132,162)
				particle:SetStartSize(Size)
				particle:SetEndSize(Size)

				particle:SetRoll(math.Rand(-360, 360))
				particle:SetRollDelta(math.Rand(-0.21, 0.21))

				particle:SetAirResistance(math.Rand(520,620))

				particle:SetGravity( Vector(0, 0, math.Rand(-42, -82)) )

				particle:SetCollide(true)
				particle:SetBounce(0.42)

				particle:SetLighting(1)

			end

		end

	emitter:Finish()

end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end
--addons/weapon_jedi/lua/effects/force_lightning.lua:
--DO NOT EDIT OR REUPLOAD THIS FILE

function EFFECT:Init( data )
	self.Ent = data:GetEntity()

	self.LifeTime = 0.2
	self.DieTime = CurTime() + self.LifeTime

	if IsValid( self.Ent ) then
		local Dir = self.Ent:GetAimVector()
		local StartPos = self.Ent:GetShootPos() - Dir * 25
		local EndPos = StartPos + Dir * 625
		self:SetRenderBoundsWS( StartPos, EndPos )
	end
end

function EFFECT:Think()
	if self.DieTime < CurTime() or not IsValid( self.Ent ) then 
		return false
	end

	return true
end

local BeamMat = Material( "trails/electric" )
local mat = Material( "sprites/light_glow02_add" )

function EFFECT:Render()
	if IsValid( self.Ent ) then

		local boneID = self.Ent:LookupBone( "ValveBiped.Bip01_L_Hand" )

		if boneID then
			local T = CurTime() * 10

			local X = math.cos( T ) * math.cos( T * 10 ) * 4
			local Y = math.sin( T ) * math.cos( T * 10 ) * 4
			local pos, ang = self.Ent:GetBonePosition( boneID )
			local StartPos = pos + ang:Up() * 2 + ang:Forward() * 5 + ang:Right() * 2

			if not self.TargetPos then
				self.TargetPos = self.Ent:GetEyeTrace().HitPos
	
				local dlight = DynamicLight( self.Ent:EntIndex() + math.random(0,99) )
				if dlight then
					dlight.pos = StartPos
					dlight.r = 255
					dlight.g = 255
					dlight.b = 255
					dlight.brightness = 3
					dlight.Decay = 2000
					dlight.Size = 150
					dlight.DieTime = CurTime() + 0.1
				end
			end


			local Dir = ((self.TargetPos - StartPos):Angle() + Angle(X,Y,0)):Forward()
			local EndPos = StartPos + Dir * math.random(600,1000)

			local trace = util.TraceLine( { start = StartPos, endpos = EndPos, filter = self.Ent} )

			if (self.HitFX or 0) < CurTime() then
				self.HitFX = CurTime() + 0.01

				if trace.Hit then
					local effectdata = EffectData()
						effectdata:SetOrigin( trace.HitPos + trace.HitNormal )
						effectdata:SetNormal( -trace.HitNormal )
					util.Effect("force_lightning_hit", effectdata)

					if math.random(1,3) == 3 then

						local dlight = DynamicLight( self.Ent:EntIndex() + math.random(100,9999) )
						if dlight then
							dlight.pos = trace.HitPos + trace.HitNormal
							dlight.r = 255
							dlight.g = 150
							dlight.b = 255
							dlight.brightness = 3
							dlight.Decay = 2000
							dlight.Size = 100
							dlight.DieTime = CurTime() + 0.01
						end

						self:EmitSound("lscs/force/lightninghit"..math.random(1,3)..".mp3")
					end
				end
			end

			render.SetMaterial( mat )
			render.DrawSprite( StartPos, 64, 64, Color( 0, 50, 255, 255) )
			render.DrawSprite( StartPos, 16, 16, Color( 255, 255, 255, 255) )

			local BeamStart = StartPos
			local BeamPrevious = BeamStart
			local BeamEnd = trace.HitPos
			local BeamSub = BeamEnd - BeamStart
			local BeamDir = BeamSub:GetNormalized()
			local BeamDistance = (BeamSub):Length()
			local SegmentLength = 50

			render.SetMaterial( BeamMat )

			render.DrawBeam( BeamStart, BeamEnd, 18, 0, 1, Color( 255, 255, 255, 255 ) )

			for SegmentStart = 0, BeamDistance, SegmentLength do
				local SegmentEnd = BeamPrevious + (BeamDir:Angle() + Angle(math.Rand(-8,8),math.Rand(-8,8),0)):Forward() * SegmentLength

				local Width = (SegmentStart / BeamDistance)
				if SegmentStart + SegmentLength >= BeamDistance then
					SegmentEnd = BeamEnd
				end

				render.DrawBeam( BeamPrevious, SegmentEnd, 16 * (1 - Width), Width, Width + 0.15, Color( 255, 150 + 155 * Width, 255, 255 ) )

				local BranchEnd1 = SegmentEnd + (BeamDir:Angle() + Angle(math.Rand(-20,20),math.Rand(-20,20),0)):Forward() * SegmentLength * 0.5

				render.DrawBeam( SegmentEnd, BranchEnd1, math.Rand(8,16) * (1 - Width), 0, 0.2, Color( 255, 255, 255, 255 ) )
				render.DrawBeam( BranchEnd1, BranchEnd1 + (BeamDir:Angle() + Angle(math.Rand(-6,6),math.Rand(-6,6),0)):Forward() * SegmentLength * 1.5, math.Rand(4,8) * (1 - Width), 0, 1.5, Color( 255, 255, 255, 255 ) )

				BeamPrevious = SegmentEnd
			end
		end
	end
end

--addons/lvs_addons/lua/effects/hmp_concussion_explosion.lua:

local GlowMat = Material( "sprites/light_glow02_add" )
local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	self.Pos = data:GetOrigin()

	self.LifeTime = 0.9
	self.DieTime = CurTime() + self.LifeTime

	local emitter = ParticleEmitter( self.Pos, false )

	if not IsValid( emitter ) then return end

	for i = 0,30 do
		local particle = emitter:Add( Materials[ math.random(1, #Materials ) ], self.Pos )
		
		if particle then
			particle:SetVelocity( VectorRand(-1,1) * 800 )
			particle:SetDieTime( math.Rand(4,6) )
			particle:SetAirResistance( math.Rand(200,600) ) 
			particle:SetStartAlpha( 100 )
			particle:SetStartSize( math.Rand(30,60) )
			particle:SetEndSize( math.Rand(100,150) )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( 255,255,255 )
			particle:SetGravity( Vector( 0, 0, 100 ) )
			particle:SetCollide( false )
		end
	end

	for i = 0, 20 do
		local particle = emitter:Add( "sprites/light_glow02_add", self.Pos )
		
		local vel = VectorRand() * 400
		
		if particle then
			particle:SetVelocity( vel )
			particle:SetAngles( vel:Angle() + Angle(0,90,0) )
			particle:SetDieTime( math.Rand(0.4,0.8) )
			particle:SetStartAlpha( 255 )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( math.Rand(24,48) )
			particle:SetEndSize( 0 )
			particle:SetRoll( math.Rand(-100,100) )
			particle:SetRollDelta( math.Rand(-100,100) )
			particle:SetColor( 0,255,255 )
			particle:SetGravity( Vector(0,0,-600) )

			particle:SetAirResistance( 0 )
			
			particle:SetCollide( true )
			particle:SetBounce( 0.5 )
		end
	end
	
	for i = 0, 40 do
		local particle = emitter:Add( "sprites/flamelet"..math.random(1,5), self.Pos )
		
		if particle then
			particle:SetVelocity( VectorRand(-1,1) * 500 )
			particle:SetDieTime( 0.14 )
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 10 )
			particle:SetEndSize( math.Rand(30,60) )
			particle:SetEndAlpha( 100 )
			particle:SetRoll( math.Rand( -1, 1 ) )
			particle:SetColor( 255,255,255 )
			particle:SetCollide( false )
		end
	end

	emitter:Finish()

	local Pos = self.Pos
	local ply = LocalPlayer():GetViewEntity()
	if IsValid( ply ) then
		local delay = (Pos - ply:GetPos()):Length() / 13503.9
		if delay <= 0.11 then
			sound.Play( "hmp/destruction_explosions_modular_sfx_small_disruption_var_05.mp3", Pos, 85, 100, 1 - delay * 8 )
		end

		timer.Simple( delay, function()
			sound.Play( "LVS.MISSILE_EXPLOSION", Pos )
		end )
	else
		sound.Play( "LVS.MISSILE_EXPLOSION", Pos )
	end
end

function EFFECT:Think()
	if self.DieTime < CurTime() then return false end

	return true
end

function EFFECT:Render()
	local Scale = (self.DieTime - CurTime()) / self.LifeTime
	render.SetMaterial( GlowMat )
	render.DrawSprite( self.Pos, 400 * Scale, 500 * Scale, Color( 255,255,255) )
	render.DrawSprite( self.Pos, 100 * Scale, 100 * Scale, Color( 255,255,255) )
end

--addons/arccw_weapons/lua/effects/ion_exp_effect.lua:
if SERVER then AddCSLuaFile() end

function EFFECT:Init(data)
	self.Start = data:GetOrigin()
	self.size = data:GetScale()
	self.Emitter = ParticleEmitter(self.Start)
	for i = 1, math.random(20, 50) do
		local p = self.Emitter:Add("effects/muzzleflash"..math.random(1,4), self.Start)
		p:SetDieTime(math.Rand(0.1*3, 0.25*3))
		p:SetStartAlpha(255)
		p:SetEndAlpha(0)
		p:SetStartSize(math.random(50, 150) * self.size)
		p:SetEndSize(50 * self.size)
		p:SetRoll(math.Rand(-50, 50))
		p:SetRollDelta(math.Rand(-10, 10))
		p:SetCollide(true)
		p:SetVelocity(VectorRand():GetNormal() * math.random(25, 75) * self.size)
		p:SetColor(255, 255, 0)
	end
	for i = 1, 400 do
		local vec = VectorRand():GetNormal()
		vec.z = 0
		local pos = (self.Start + vec * 50)
		local p = self.Emitter:Add("sprites/orangeflare1", self.Start + vec * 10)
		p:SetDieTime(math.Rand(0.9, 1.1))
		p:SetStartAlpha(255)
		p:SetEndAlpha(35)
		p:SetStartSize(18)
		p:SetEndSize(12)
		p:SetVelocity(((pos - self.Start):GetNormal() * math.random(250, 285)) + Vector(0, 0, math.random(-80, 80)) * self.size)
		p:SetGravity( Vector( 0, 0, 0 ) );
		p:SetColor(255, 255, 0)
		p:SetCollide(false)
	end

	self.Emitter:Finish()
end

function EFFECT:Think()
	return false
end
--addons/lvs_addons/lua/effects/lfs_fb_ballturret_right_projector.lua:
EFFECT.Mat = Material("effects/lfs_base/ballturret_projectorbeam")
EFFECT.HitMat = Material("sprites/light_glow02_add")

function EFFECT:Init( data )
	self.Entity = data:GetEntity()
	
	if IsValid(self.Entity) then
		self.ID = self.Entity:LookupAttachment("R_Ball_Attachement")
		
		if self.ID then
			local Muzzle = self.Entity:GetAttachment(self.ID)

			self:SetRenderBoundsWS(self.Entity:GetPos(), Muzzle.Ang:Up() * 50000)
		end
	end
end

function EFFECT:Think()
	if not IsValid(self.Entity) or not self.ID or not self.Entity:GetBTRFire() then
		return false
	end
	
	return true
end

function EFFECT:Render()
	if not self.ID or not IsValid(self.Entity) then return end
	
	local Muzzle = self.Entity:GetAttachment(self.ID)
	
	local Dir = -Muzzle.Ang:Forward()
    local Up = Muzzle.Ang:Up()
	local StartPos = Muzzle.Pos + Up * 20 + Dir * 60
	local Trace = util.TraceLine( { start = StartPos, endpos = StartPos + Dir * 50000, filter = self } )
	local EndPos = Trace.HitPos
	
	self:SetRenderBoundsWS( StartPos, EndPos )
	
	render.SetMaterial( self.Mat )
	render.DrawBeam( StartPos, EndPos, 14 + math.random(0,4), 1, 0, Color(0,255,0,255) )
	render.DrawBeam( StartPos, EndPos, 3 + math.random(0,4), 1, 0, Color(255,255,255,255) )
	
	render.SetMaterial( self.HitMat )
	local A = 150 + math.random(0,20)
	local B = 70 + math.random(0,20)
	render.DrawSprite( StartPos, A, A, Color(0,255,0,255) )
	render.DrawSprite( StartPos, B, B, Color(255,255,255,255) )
	
	render.DrawSprite( EndPos, A, A, Color(0,255,0,255) )
	render.DrawSprite( EndPos + VectorRand() * 10, B, B, Color(255,255,255,255) )
	
	if math.random(0,5) == 1 then
		local emitter = ParticleEmitter( EndPos, false )
		local dir = (self.Entity:GetPos() - EndPos):GetNormalized()
		
		for i = 0, 10 do
			local particle = emitter:Add( "sprites/rico1", EndPos )
			local vel = VectorRand()  * 100 + dir * 40
			
			if particle then
				particle:SetVelocity( vel )
				particle:SetAngles( vel:Angle() + Angle(0,90,0) )
				particle:SetDieTime( math.Rand(0.1,0.3) * 0.5 )
				particle:SetStartAlpha( math.Rand( 200, 255 ) )
				particle:SetEndAlpha( 0 )
				particle:SetStartSize( math.Rand(1,30) )
				particle:SetEndSize( 0 )
				particle:SetRoll( math.Rand(-100,100) )
				particle:SetRollDelta( math.Rand(-100,100) )

				particle:SetAirResistance( 0 )
			end
		end
		
		emitter:Finish()
	end
end

--addons/lvs_addons/lua/effects/lfs_tx-427_main_explosion.lua:
function EFFECT:Init( data )
	self.Pos = data:GetOrigin()
	self.DieTime = CurTime() + 0.4

	sound.Play( "lfsAAT_EXPLOSION", self.Pos )
	self:Explode()
end

function EFFECT:Explode()
	local emitter = ParticleEmitter( self.Pos, false )
	if not emitter then return end

	for i = 0, 20 do
		local particle = emitter:Add( "particle/smokesprites_00" .. math.random( 0, 1 ) .. math.random( 1, 6 ), self.Pos + VectorRand() * 5 )
		if particle then
			particle:SetVelocity( VectorRand() * 2000 )
			particle:SetDieTime( math.Rand( 2, 3 ) )
			particle:SetAirResistance( math.Rand( 1000, 1500 ) ) 
			particle:SetStartAlpha( 255 )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( math.Rand( 20, 25 ) )
			particle:SetEndSize( math.Rand( 75, 100 ) )
			particle:SetRoll( math.Rand( -1, 1 ) )
			particle:SetColor( 50, 50, 50 )
			particle:SetGravity( Vector( 0, 0, 50 ) )
			particle:SetCollide( false )
		end
		
		particle = emitter:Add( "sprites/flamelet"..math.random( 1, 5 ), self.Pos )
		if particle then
			particle:SetVelocity( VectorRand() * 200 )
			particle:SetDieTime( math.Rand( 0.2, 0.3 ) )
			particle:SetStartAlpha( 255 )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( 15 )
			particle:SetEndSize( math.Rand( 25, 50 ) )
			particle:SetColor( 200,150,150 )
			particle:SetCollide( false )
		end
		
		particle = emitter:Add( "sprites/light_glow02_add", self.Pos )
		if particle then
			particle:SetVelocity( VectorRand() * 500 )
			particle:SetDieTime( math.Rand( 0.5, 1 ) )
			particle:SetStartAlpha( 255 )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( math.Rand( 15, 20 ) )
			particle:SetEndSize( math.Rand( 25, 50 ) )
			particle:SetColor( 0, 0, 255 )
			particle:SetGravity( Vector( 0, 0, -1000 ) )
			particle:SetCollide( true )
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	if self.DieTime < CurTime() then return false end
end

function EFFECT:Render()
end
--addons/lvs_addons/lua/effects/lvs_laat_left_projector.lua:
EFFECT.Mat = Material( "effects/lvs/ballturret_projectorbeam" )
EFFECT.HitMat = Material( "sprites/light_glow02_add" )

function EFFECT:Init( data )
	self.Entity = data:GetEntity()

	if IsValid( self.Entity ) then
		self.ID = self.Entity:LookupAttachment( "muzzle_ballturret_left" )

		if self.ID then
			local Muzzle = self.Entity:GetAttachment( self.ID )

			self:SetRenderBoundsWS( self.Entity:GetPos(), Muzzle.Ang:Up() * 50000 )
		end
	end
end

function EFFECT:Think()
	if not IsValid( self.Entity ) or not self.ID or not self.Entity:GetBTLFire() then
		return false
	end

	return true
end


function EFFECT:Render()
	if not self.ID or not IsValid( self.Entity ) then return end

	local Muzzle = self.Entity:GetAttachment( self.ID )

	local Dir = Muzzle.Ang:Up()
	local StartPos = Muzzle.Pos + Dir * 14
	local Trace = util.TraceLine( { start = StartPos, endpos = StartPos + Dir * 50000, filter = self } )
	local EndPos = Trace.HitPos

	self:SetRenderBoundsWS( StartPos, EndPos )

	render.SetMaterial( self.Mat )
	render.DrawBeam( StartPos, EndPos, 14 + math.random(0,4), 1, 0, Color(0,255,0,255) )
	render.DrawBeam( StartPos, EndPos, 3 + math.random(0,4), 1, 0, Color(255,255,255,255) )

	render.SetMaterial( self.HitMat )
	local A = 150 + math.random(0,20)
	local B = 70 + math.random(0,20)
	render.DrawSprite( StartPos, A, A, Color(0,255,0,255) )
	render.DrawSprite( StartPos, B, B, Color(255,255,255,255) )

	render.DrawSprite( EndPos, A, A, Color(0,255,0,255) )
	render.DrawSprite( EndPos + VectorRand() * 10, B, B, Color(255,255,255,255) )

	if math.random(0,5) == 1 then
		local emitter = ParticleEmitter( EndPos, false )
		local dir = (self.Entity:GetPos() - EndPos):GetNormalized()
		
		for i = 0, 10 do
			local particle = emitter:Add( "sprites/rico1", EndPos )
			
			local vel = VectorRand()  * 100 + dir * 40
			
			if not particle then continue end

			particle:SetVelocity( vel )
			particle:SetAngles( vel:Angle() + Angle(0,90,0) )
			particle:SetDieTime( math.Rand(0.1,0.3) * 0.5 )
			particle:SetStartAlpha( math.Rand( 200, 255 ) )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( math.Rand(1,30) )
			particle:SetEndSize( 0 )
			particle:SetRoll( math.Rand(-100,100) )
			particle:SetRollDelta( math.Rand(-100,100) )

			particle:SetAirResistance( 0 )
		end
		
		emitter:Finish()
	end
end

--addons/lvs_addons/lua/effects/lvs_laser_green.lua:

EFFECT.MatBeam = Material( "effects/spark" )
EFFECT.MatSprite = Material( "sprites/light_glow02_add" )

function EFFECT:Init( data )
	local pos  = data:GetOrigin()
	local dir = data:GetNormal()

	self.ID = data:GetMaterialIndex()

	self:SetRenderBoundsWS( pos, pos + dir * 50000 )
end

function EFFECT:Think()
	if not LVS:GetBullet( self.ID ) then return false end

	return true
end

function EFFECT:Render()
	local bullet = LVS:GetBullet( self.ID )

	local endpos = bullet:GetPos()
	local dir = bullet:GetDir()

	local len = 1000 * bullet:GetLength()

	render.SetMaterial( self.MatSprite ) 
	render.DrawBeam( endpos - dir * len * 4, endpos + dir * len * 4, 200, 1, 0, Color( 0, 255, 0, 255 ) )

	render.SetMaterial( self.MatBeam )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 45, 1, 0, Color( 0, 255, 0, 255 ) )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 15, 1, 0, Color( 255, 255, 255, 255 ) )
end

--addons/lvs_base/lua/effects/lvs_muzzle_colorable.lua:

function EFFECT:Init( data )
	local Pos = data:GetOrigin()
	local Dir = data:GetNormal()
	local Ent = data:GetEntity()
	local Col = data:GetStart() or Vector(255,255,255)
	local Vel = Dir * 10

	if IsValid( Ent ) then
		Vel = Ent:GetVelocity()
	end

	local emitter = ParticleEmitter( Pos, false )

	if not IsValid( emitter ) then return end

	for i = 0, 12 do
		local particle = emitter:Add( "effects/muzzleflash2", Pos + Dir * i * 0.7 * math.random(1,2) * 0.5 )
		local Size = 1

		if not particle then continue end

		particle:SetVelocity( Dir * 800 + Vel )
		particle:SetDieTime( 0.05 )
		particle:SetStartAlpha( 255 * Size )
		particle:SetStartSize( math.max( math.random(10,24) - i * 0.5,0.1 ) * Size )
		particle:SetEndSize( 0 )
		particle:SetRoll( math.Rand( -1, 1 ) )
		particle:SetColor( Col.x, Col.y, Col.z )
		particle:SetCollide( false )
	end

	emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--addons/lvs_addons/lua/effects/lvs_proton_explosion.lua:

local GlowMat = Material( "sprites/light_glow02_add" )
local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	self.Pos = data:GetOrigin()

	self.LifeTime = 0.4
	self.DieTime = CurTime() + self.LifeTime

	local emitter = ParticleEmitter( self.Pos, false )

	if not IsValid( emitter ) then return end

	for i = 0,30 do
		local particle = emitter:Add(  Materials[ math.random(1, #Materials ) ], self.Pos )
		
		if particle then
			particle:SetVelocity( VectorRand(-1,1) * 800 )
			particle:SetDieTime( math.Rand(4,6) )
			particle:SetAirResistance( math.Rand(200,600) ) 
			particle:SetStartAlpha( 100 )
			particle:SetStartSize( math.Rand(30,60) )
			particle:SetEndSize( math.Rand(100,150) )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( 50,50,50 )
			particle:SetGravity( Vector( 0, 0, 100 ) )
			particle:SetCollide( false )
		end
	end

	for i = 0, 20 do
		local particle = emitter:Add( "sprites/light_glow02_add", self.Pos )
		
		local vel = VectorRand() * 400
		
		if particle then
			particle:SetVelocity( vel )
			particle:SetAngles( vel:Angle() + Angle(0,90,0) )
			particle:SetDieTime( math.Rand(0.4,0.8) )
			particle:SetStartAlpha( 255 )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( math.Rand(24,48) )
			particle:SetEndSize( 0 )
			particle:SetRoll( math.Rand(-100,100) )
			particle:SetRollDelta( math.Rand(-100,100) )
			particle:SetColor( 0,127,255 )
			particle:SetGravity( Vector(0,0,-600) )

			particle:SetAirResistance( 0 )
			
			particle:SetCollide( true )
			particle:SetBounce( 0.5 )
		end
	end
	
	for i = 0, 40 do
		local particle = emitter:Add( "effects/lvs_base/flamelet"..math.random(1,5), self.Pos )
		
		if particle then
			particle:SetVelocity( VectorRand(-1,1) * 500 )
			particle:SetDieTime( 0.14 )
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 10 )
			particle:SetEndSize( math.Rand(30,60) )
			particle:SetEndAlpha( 100 )
			particle:SetRoll( math.Rand( -1, 1 ) )
			particle:SetColor( 200,150,150 )
			particle:SetCollide( false )
		end
	end

	emitter:Finish()

	local Pos = self.Pos
	local ply = LocalPlayer():GetViewEntity()
	if IsValid( ply ) then
		local delay = (Pos - ply:GetPos()):Length() / 13503.9
		if delay <= 0.11 then
			sound.Play( "ambient/explosions/explode_9.wav", Pos, 85, 100, 1 - delay * 8 )
		end

		timer.Simple( delay, function()
			sound.Play( "LVS.MISSILE_EXPLOSION", Pos )
		end )
	else
		sound.Play( "LVS.MISSILE_EXPLOSION", Pos )
	end
end

function EFFECT:Think()
	if self.DieTime < CurTime() then return false end

	return true
end

function EFFECT:Render()
	local Scale = (self.DieTime - CurTime()) / self.LifeTime
	render.SetMaterial( GlowMat )
	render.DrawSprite( self.Pos, 400 * Scale, 400 * Scale, Color( 0, 127, 255, 255) )
	render.DrawSprite( self.Pos, 100 * Scale, 100 * Scale, Color( 255, 255, 255, 255) )
end

--addons/lvs_addons/lua/effects/lvs_walker_stomp.lua:
local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	local pos = data:GetOrigin()
	
	local emitter = ParticleEmitter( pos, false )

	for i = 1,12 do
		local particle = emitter:Add( Materials[ math.random(1, #Materials ) ],pos )
		
		if not particle then continue end

		local ang = i * 30
		local X = math.cos( math.rad(ang) )
		local Y = math.sin( math.rad(ang) )
			
		particle:SetVelocity( Vector(X,Y,0) * math.Rand(3000,4000) )
		particle:SetDieTime( math.Rand(0.5,1) )
		particle:SetAirResistance( math.Rand(3000,5000) ) 
		particle:SetStartAlpha( 100 )
		particle:SetStartSize( 20 )
		particle:SetEndSize( math.Rand(30,40) )
		particle:SetRoll( math.Rand(-1,1) )
		particle:SetColor( 60,60,60 )
		particle:SetGravity( VectorRand() * 200 + Vector(0,0,1000) )
		particle:SetCollide( false )
	end

	emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--addons/weapon_jedi/lua/effects/rb655_force_heal.lua:

function EFFECT:Init( data )
	local pos = data:GetOrigin()
	local emitter = ParticleEmitter( pos )

	if ( !emitter ) then return end

	local particle = emitter:Add( "effects/rb655_health_over_bg", pos + Vector( math.random( -16, 16 ), math.random( -16, 16 ), math.random( 0, 72 ) ) )
	if ( particle ) then
		particle:SetLifeTime( 0 )
		particle:SetDieTime( 2 )

		particle:SetGravity( Vector( 0, 0, 100 ) )
		particle:SetVelocity( Vector( 0, 0, 0 ) )

		particle:SetStartSize( math.random( 4, 6 ) )
		particle:SetEndSize( math.random( 0, 1 ) )

		particle:SetStartAlpha( math.random( 200, 255 ) )
		particle:SetEndAlpha( 0 )

		particle:SetColor( 255, 0, 0 )
		--particle:SetAngleVelocity( Angle( math.Rand( -180, 180 ), math.Rand( -180, 180 ), math.Rand( -180, 180 ) ) )
	end

	emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--addons/arccw_weapons/lua/effects/tracer_orange/init.lua:
EFFECT.Mat = Material("effects/laser_tracer")
EFFECT.Speed = 1024 * 15
EFFECT.TracerLength = 5

local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()

	if IsValid(self.WeaponEnt) and self.WeaponEnt.GetMuzzleAttachment then
		self.Attachment = self.WeaponEnt:GetMuzzleAttachment()
	end

	-- Keep the start and end pos - we're going to interpolate between them
    self.StartPos = self:GetTracerShootPos(self.Position, self.WeaponEnt, self.Attachment)
    self.EndPos = data:GetOrigin()

	self.Dir = self.EndPos - self.StartPos

	self:SetRenderBoundsWS( self.StartPos, self.EndPos )

    self.StartTime = 0
	self.TracerTime = math.min( 1, self.StartPos:Distance( self.EndPos ) / 7000 ) * 1
	self.Length = 0.33

	-- Die when it reaches its target
	self.DieTime = CurTime() + self.TracerTime

	local Dir = self.Dir:GetNormalized()

	local emitter = ParticleEmitter( self.StartPos, false )

	for i = 0, 5 do
		local particle = emitter:Add( Materials[math.random(1,table.Count( Materials ))], self.StartPos )

		local rCol = 255

		if particle then
			particle:SetVelocity( Dir * math.Rand(100,500) + VectorRand() * math.Rand(0,10) )
			particle:SetDieTime( math.Rand(0.05,0.2) )
			particle:SetAirResistance( math.Rand(50,100) )
			particle:SetStartAlpha( 5 )
			particle:SetStartSize( 2 )
			particle:SetEndSize( math.Rand(5,10) )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( rCol, rCol, rCol )
			particle:SetGravity( VectorRand() * 200 + Vector(0,0, -500) )
			particle:SetCollide( false )
		end
	end

	emitter:Finish()
end

local hitColor = Vector(255, 140, 0)

function EFFECT:Think()
    self.StartTime = self.StartTime + FrameTime()

	if CurTime() > self.DieTime then
		local effectdata = EffectData()
			effectdata:SetStart( hitColor )
			effectdata:SetOrigin( self.EndPos )
			effectdata:SetNormal( self.Dir:GetNormalized() )
		util.Effect( "laser_hit", effectdata )

		return false
	end

	return true
end

local mainColor = Color(255, 120, 0)
local innerColor = Color(192, 192, 192)

function EFFECT:Render()
	local fDelta = ( self.DieTime - CurTime() ) / self.TracerTime
	fDelta = math.Clamp( fDelta, 0, 1 ) ^ 2

	local sinWave = math.sin( fDelta * math.pi )

	local Pos1 = self.EndPos - self.Dir * ( fDelta - sinWave * self.Length )

	render.SetMaterial( self.Mat )
	render.DrawBeam( Pos1,
		self.EndPos - self.Dir * ( fDelta + sinWave * self.Length ),
        8, 5, 0, mainColor
    )

	render.DrawBeam( Pos1,
		self.EndPos - self.Dir * ( fDelta + sinWave * self.Length ),
        2, 5, 0, innerColor
    )

    if --[[DynamicTracer:GetBool()]] true then
    local spawn = util.CRC(tostring(self:GetPos()))
    local dlight = DynamicLight(self:EntIndex() + spawn)
    local endDistance = self.Speed * self.StartTime
    local endPos = self.StartPos + self.Dir:GetNormalized() * endDistance

    if (dlight) then
        dlight.pos = endPos
        dlight.r = 255
        dlight.g = 165
        dlight.b = 0
        dlight.brightness = 7
        dlight.Decay = 1000
        dlight.Size = 500
        dlight.DieTime = CurTime() + 3
    end
end
end
--addons/billy_gas_logging/lua/gmodadminsuite/modules/logging/sh_log_formatting.lua:
local function L(phrase, ...)
	if (#({...}) == 0) then
		return GAS:Phrase(phrase, "logging")
	else
		return GAS:PhraseFormat(phrase, "logging", ...)
	end
end

GAS.Logging.LogFormattingSettings_Default = {
	Colors = {
		Highlight = Color(255,125,0),
		Money = Color(0,200,20),
		Weapon = Color(255,70,60),
		Vehicle = Color(200,0,255),
		Entity = Color(255,125,0),
		Health = Color(255,70,60),
		Armor = Color(30,90,255),
		Usergroup = Color(255,125,0),
		Unavailable = Color(90,90,90),
	},
	PlayerDataOrder = {
		"Role", "Team", "Health", "Armor", "Weapon", "Usergroup"
	}
}
if (CLIENT) then
	GAS.Logging.LogFormattingSettings = GAS:GetLocalConfig("logging_log_formatting", GAS.Logging.LogFormattingSettings_Default)
else
	GAS.Logging.LogFormattingSettings = GAS.Logging.LogFormattingSettings_Default
end

local function comma_value(amount)
	local formatted = amount
	while (true) do
		formatted, k = string.gsub(formatted, "^(-?%d+)(%d%d%d)", "%1,%2")
		if (k==0) then
			break
		end
	end
	return formatted
end
function GAS.Logging:FormatCurrencyStr(amount)
	amount = tonumber(amount)
	if (GAS.Logging.Config.OverrideMoneyFormat == true) then
		return GAS.Logging.Config.MoneyFormat:format(comma_value(amount))
	elseif (DarkRP and DarkRP.formatMoney) then
		return DarkRP.formatMoney(amount)
	else
		return "$" .. comma_value(amount)
	end
end

local function EncapsulateColor(color, text, allow_color)
	if (allow_color == false) then
		return GAS:EscapeMarkup(text)
	else
		return "<color=" .. GAS:Unvectorize(color) .. ">" .. GAS:EscapeMarkup(text) .. "</color>"
	end
end

local function EncapsulateMarkdown(text, special_char, markdown_format)
	if (markdown_format == true) then
		if (special_char == "`") then
			return "`" .. (text:gsub("`","")) .. "`"
		elseif (special_char) then
			return special_char .. GAS:EscapeMarkdown(text) .. special_char
		else
			return GAS:EscapeMarkdown(text)
		end
	else
		return text
	end
end

local function IsDamageType(dmg_type, is_dmg_type)
	return bit.band(dmg_type, is_dmg_type) == is_dmg_type
end

local INSTIGATOR_COL = Color(255,0,0)
local VICTIM_COL = Color(0,255,0)
function GAS.Logging:ProcessReplacement(replacement, allow_color, markdown_format, victim_account_id, instigator_account_id)
	if (replacement[1] == GAS.Logging.FORMAT_PLAYER) then
		local ply_replacement = ""
		if (replacement[2] == "CONSOLE") then
			ply_replacement = EncapsulateColor(GAS.Logging.LogFormattingSettings.Colors.Unavailable, "CONSOLE", allow_color)
		elseif (replacement[2] == "BOT") then
			ply_replacement = EncapsulateColor(GAS.Logging.LogFormattingSettings.Colors.Entity, "BOT", allow_color)
		elseif (victim_account_id ~= nil and tonumber(replacement[2]) == victim_account_id) then
			ply_replacement = EncapsulateColor(VICTIM_COL, "[" .. string.upper(L"victim") .. "]", allow_color)
		elseif (instigator_account_id ~= nil and tonumber(replacement[2]) == instigator_account_id) then
			ply_replacement = EncapsulateColor(INSTIGATOR_COL, "[" .. string.upper(L"instigator") .. "]", allow_color)
		elseif (tonumber(replacement[2])) then
			local ply = player.GetByAccountID(tonumber(replacement[2]))
			if (IsValid(ply)) then
				ply_replacement = EncapsulateColor(team.GetColor(ply:Team()), ply:Nick(), allow_color)
			elseif (replacement[3] ~= nil and replacement[3][1] ~= nil) then
				ply_replacement = EncapsulateColor(GAS.Logging.LogFormattingSettings.Colors.Unavailable, replacement[3][1], allow_color)
			else
				ply_replacement = EncapsulateColor(GAS.Logging.LogFormattingSettings.Colors.Unavailable, GAS:AccountIDToSteamID(replacement[2]), allow_color)
			end
		end
		local metadata = ""
		if (replacement[3] ~= nil) then
			if (replacement[3][2] == "Joining/Connecting") then replacement[3][2] = TEAM_CONNECTING end
			if (replacement[3][2] == "Unassigned") then replacement[3][2] = TEAM_UNASSIGNED end
			if (replacement[3][2] == "Spectator") then replacement[3][2] = TEAM_SPECTATOR end
			for _,v in ipairs(GAS.Logging.LogFormattingSettings.PlayerDataOrder) do
				if (v == "Team" and replacement[3][2] ~= nil) then
					local team_index = replacement[3][2]
					if (isstring(team_index)) then
						team_index = OpenPermissions:GetTeamFromIdentifier(team_index)
					end
					metadata = metadata .. " " .. EncapsulateColor(team.GetColor(team_index), team.GetName(team_index), allow_color)
				elseif (v == "Health" and replacement[3][4] ~= nil) then
					metadata = metadata .. " " .. EncapsulateColor(GAS.Logging.LogFormattingSettings.Colors.Health, L("health_abbrieviated", replacement[3][4]), allow_color)
				elseif (v == "Armor" and replacement[3][5] ~= nil) then
					metadata = metadata .. " " .. EncapsulateColor(GAS.Logging.LogFormattingSettings.Colors.Armor, L("armor_abbrieviated", replacement[3][5]), allow_color)
				elseif (v == "Weapon" and replacement[3][6] ~= nil) then
					metadata = metadata .. " " .. EncapsulateColor(GAS.Logging.LogFormattingSettings.Colors.Weapon, replacement[3][6], allow_color)
				elseif (v == "Usergroup" and replacement[3][3] ~= nil) then
					metadata = metadata .. " " .. EncapsulateColor(GAS.Logging.LogFormattingSettings.Colors.Usergroup, replacement[3][3], allow_color)
				elseif (v == "Role" and replacement[3][7] ~= nil) then
					local role_name, role_color = hook.Run("GAS:logging:GetRoleInfo", replacement[3][7])
					metadata = metadata .. " " .. EncapsulateColor(role_color or GAS.Logging.LogFormattingSettings.Colors.Unavailable, role_name or replacement[3][7], allow_color)
				end
			end
		end
		if (#metadata > 0) then
			metadata = "  " .. EncapsulateMarkdown(metadata:sub(2), "_", markdown_format)
		end
		return ply_replacement .. metadata
	elseif (replacement[1] == GAS.Logging.FORMAT_WEAPON) then
		return EncapsulateColor(GAS.Logging.LogFormattingSettings.Colors.Weapon, replacement[2], allow_color)
	elseif (replacement[1] == GAS.Logging.FORMAT_USERGROUP) then
		return EncapsulateColor(GAS.Logging.LogFormattingSettings.Colors.Usergroup, replacement[2], allow_color)
	elseif (replacement[1] == GAS.Logging.FORMAT_VEHICLE) then
		if (replacement[4] ~= nil) then
			return EncapsulateColor(GAS.Logging.LogFormattingSettings.Colors.Vehicle, replacement[2], allow_color) .. " (" .. L"vehicle_driver" .. " " .. GAS.Logging:ProcessReplacement({GAS.Logging.FORMAT_PLAYER, replacement[4], replacement[5]}, allow_color, markdown_format, victim_account_id, instigator_account_id) .. ")"
		else
			return EncapsulateColor(GAS.Logging.LogFormattingSettings.Colors.Vehicle, replacement[2], allow_color)
		end
	elseif (replacement[1] == GAS.Logging.FORMAT_ENTITY) then
		return EncapsulateColor(GAS.Logging.LogFormattingSettings.Colors.Entity, replacement[2], allow_color)
	elseif (replacement[1] == GAS.Logging.FORMAT_DAMAGE) then
		if (IsDamageType(replacement[3], DMG_AIRBOAT)) then
			return EncapsulateColor(GAS.Logging.LogFormattingSettings.Colors.Highlight, GAS:PhraseFormat("pvp_dmgtype_airboat", "logging", replacement[2]), allow_color)
		elseif (IsDamageType(replacement[3], DMG_PHYSGUN)) then
			return EncapsulateColor(GAS.Logging.LogFormattingSettings.Colors.Highlight, GAS:PhraseFormat("pvp_dmgtype_gravgun", "logging", replacement[2]), allow_color)
		elseif (IsDamageType(replacement[3], DMG_VEHICLE)) then
			return EncapsulateColor(GAS.Logging.LogFormattingSettings.Colors.Highlight, GAS:PhraseFormat("pvp_dmgtype_vehicle", "logging", replacement[2]), allow_color)
		elseif (IsDamageType(replacement[3], DMG_FALL)) then
			return EncapsulateColor(GAS.Logging.LogFormattingSettings.Colors.Highlight, GAS:PhraseFormat("pvp_dmgtype_fall", "logging", replacement[2]), allow_color)
		elseif (IsDamageType(replacement[3], DMG_CRUSH)) then
			return EncapsulateColor(GAS.Logging.LogFormattingSettings.Colors.Highlight, GAS:PhraseFormat("pvp_dmgtype_crush", "logging", replacement[2]), allow_color)
		elseif (IsDamageType(replacement[3], DMG_SNIPER)) then
			return EncapsulateColor(GAS.Logging.LogFormattingSettings.Colors.Highlight, GAS:PhraseFormat("pvp_dmgtype_sniper", "logging", replacement[2]), allow_color)
		elseif (IsDamageType(replacement[3], DMG_BUCKSHOT)) then
			return EncapsulateColor(GAS.Logging.LogFormattingSettings.Colors.Highlight, GAS:PhraseFormat("pvp_dmgtype_buckshot", "logging", replacement[2]), allow_color)
		elseif (IsDamageType(replacement[3], DMG_SONIC)) then
			return EncapsulateColor(GAS.Logging.LogFormattingSettings.Colors.Highlight, GAS:PhraseFormat("pvp_dmgtype_sonic", "logging", replacement[2]), allow_color)
		elseif (IsDamageType(replacement[3], DMG_SHOCK)) then
			return EncapsulateColor(GAS.Logging.LogFormattingSettings.Colors.Highlight, GAS:PhraseFormat("pvp_dmgtype_shock", "logging", replacement[2]), allow_color)
		elseif (IsDamageType(replacement[3], DMG_CLUB)) then
			return EncapsulateColor(GAS.Logging.LogFormattingSettings.Colors.Highlight, GAS:PhraseFormat("pvp_dmgtype_club", "logging", replacement[2]), allow_color)
		elseif (IsDamageType(replacement[3], DMG_ENERGYBEAM)) then
			return EncapsulateColor(GAS.Logging.LogFormattingSettings.Colors.Highlight, GAS:PhraseFormat("pvp_dmgtype_energybeam", "logging", replacement[2]), allow_color)
		elseif (IsDamageType(replacement[3], DMG_PLASMA)) then
			return EncapsulateColor(GAS.Logging.LogFormattingSettings.Colors.Highlight, GAS:PhraseFormat("pvp_dmgtype_plasma", "logging", replacement[2]), allow_color)
		elseif (IsDamageType(replacement[3], DMG_DROWN)) then
			return EncapsulateColor(GAS.Logging.LogFormattingSettings.Colors.Highlight, GAS:PhraseFormat("pvp_dmgtype_drown", "logging", replacement[2]), allow_color)
		elseif (IsDamageType(replacement[3], DMG_SLASH)) then
			return EncapsulateColor(GAS.Logging.LogFormattingSettings.Colors.Highlight, GAS:PhraseFormat("pvp_dmgtype_slash", "logging", replacement[2]), allow_color)
		elseif (IsDamageType(replacement[3], DMG_NERVEGAS)) then
			return EncapsulateColor(GAS.Logging.LogFormattingSettings.Colors.Highlight, GAS:PhraseFormat("pvp_dmgtype_nervegas", "logging", replacement[2]), allow_color)
		elseif (IsDamageType(replacement[3], DMG_BLAST)) then
			return EncapsulateColor(GAS.Logging.LogFormattingSettings.Colors.Highlight, GAS:PhraseFormat("pvp_dmgtype_blast", "logging", replacement[2]), allow_color)
		elseif (IsDamageType(replacement[3], DMG_RADIATION)) then
			return EncapsulateColor(GAS.Logging.LogFormattingSettings.Colors.Highlight, GAS:PhraseFormat("pvp_dmgtype_radiation", "logging", replacement[2]), allow_color)
		elseif (IsDamageType(replacement[3], DMG_ACID)) then
			return EncapsulateColor(GAS.Logging.LogFormattingSettings.Colors.Highlight, GAS:PhraseFormat("pvp_dmgtype_acid", "logging", replacement[2]), allow_color)
		elseif (IsDamageType(replacement[3], DMG_BULLET)) then
			return EncapsulateColor(GAS.Logging.LogFormattingSettings.Colors.Highlight, GAS:PhraseFormat("pvp_dmgtype_bullet", "logging", replacement[2]), allow_color)
		elseif (IsDamageType(replacement[3], DMG_BURN) or IsDamageType(replacement[3], DMG_SLOWBURN)) then
			return EncapsulateColor(GAS.Logging.LogFormattingSettings.Colors.Highlight, GAS:PhraseFormat("pvp_dmgtype_burn", "logging", replacement[2]), allow_color)
		elseif (IsDamageType(replacement[3], DMG_POISON) or IsDamageType(replacement[3], DMG_PARALYZE)) then
			return EncapsulateColor(GAS.Logging.LogFormattingSettings.Colors.Highlight, GAS:PhraseFormat("pvp_dmgtype_poison", "logging", replacement[2]), allow_color)
		else
			return EncapsulateColor(GAS.Logging.LogFormattingSettings.Colors.Highlight, GAS:PhraseFormat("pvp_dmgtype_generic", "logging", replacement[2]), allow_color)
		end
	elseif (replacement[1] == GAS.Logging.FORMAT_CURRENCY) then
		return EncapsulateColor(GAS.Logging.LogFormattingSettings.Colors.Money, GAS.Logging:FormatCurrencyStr(replacement[2]), allow_color)
	elseif (replacement[1] == GAS.Logging.FORMAT_STRING) then
		return EncapsulateMarkdown(GAS:EscapeMarkup(replacement[2]), nil, markdown_format)
	elseif (replacement[1] == GAS.Logging.FORMAT_HIGHLIGHT) then
		return EncapsulateColor(GAS.Logging.LogFormattingSettings.Colors.Highlight, EncapsulateMarkdown(replacement[2], "`", markdown_format), allow_color)
	elseif (replacement[1] == GAS.Logging.FORMAT_TEAM) then
		if (replacement[4] == nil or replacement[3] == nil) then
			if (replacement[2] == -1) then
				replacement[4] = GAS.Logging.LogFormattingSettings.Colors.Unavailable
				replacement[3] = L"deleted_team"
			else
				replacement[4] = team.GetColor(replacement[2])
				replacement[3] = team.GetName(replacement[2])
			end
		end
		return EncapsulateColor(replacement[4], replacement[3], allow_color)
	else
		return EncapsulateColor(GAS.Logging.LogFormattingSettings.Colors.Highlight, replacement[2], allow_color)
	end
end

function GAS.Logging:FormatMarkupLogCustom(unreplaced_log, log_replacements, allow_color, markdown_format, victim_account_id, instigator_account_id)
	local replacements = {}
	for _,replacement in ipairs(log_replacements) do
		replacements[#replacements + 1] = GAS.Logging:ProcessReplacement(replacement, allow_color, markdown_format, victim_account_id, instigator_account_id)
	end

	local str = unreplaced_log
	while (true) do
		local s,e = str:find("%{%d+%}")
		if (not s) then break end
		local prepend = ""
		local append = ""
		local middle = replacements[tonumber(str:sub(s + 1, e - 1))]
		if (s > 1) then
			prepend = str:sub(1, s - 1)
		end
		if (e < #str) then
			append = str:sub(e + 1)
		end
		if (allow_color == false) then
			str = prepend .. (middle or "MISSING DATA") .. append
		else
			str = prepend .. (middle or "<color=255,0,0>MISSING DATA</color>") .. append
		end
	end

	return str
end

function GAS.Logging:FormatMarkupLog(log, allow_color, markdown_format, victim_account_id, instigator_account_id)
	local unreplaced_log
	if (log[4] ~= nil) then
		unreplaced_log = log[4]
	elseif (log[5] ~= nil) then
		unreplaced_log = GAS:Phrase(log[5], "logging", "Logs")
	end

	local replacements = {}
	for _,replacement in ipairs(log[1]) do
		replacements[#replacements + 1] = GAS.Logging:ProcessReplacement(replacement, allow_color, markdown_format, victim_account_id, instigator_account_id)
	end

	local str = unreplaced_log
	while (true) do
		local s,e = str:find("%{%d+%}")
		if (not s) then break end
		local prepend = ""
		local append = ""
		local middle = replacements[tonumber(str:sub(s + 1, e - 1))]
		if (s > 1) then
			prepend = str:sub(1, s - 1)
		end
		if (e < #str) then
			append = str:sub(e + 1)
		end
		if (allow_color == false) then
			str = prepend .. (middle or "MISSING DATA") .. append
		else
			str = prepend .. (middle or "<color=255,0,0>MISSING DATA</color>") .. append
		end
	end

	return str
end
--addons/billy_gas/lua/gmodadminsuite/modules/secondaryusergroups/sh_core.lua:
local function L(phrase, ...)
	if (#({...}) == 0) then
		return GAS:Phrase(phrase, "secondaryusergroups")
	else
		return GAS:PhraseFormat(phrase, "secondaryusergroups", ...)
	end
end

GAS.SecondaryUsergroups = {}
GAS.SecondaryUsergroups.CachedUsergroups = {}
GAS.SecondaryUsergroups.CachedUsergroupsCount = 0

GAS:hook("OpenPermissions:GetUserGroups", "secondaryusergroups:OpenPermissions:GetUserGroups", function(ply, usergroups_tbl)
	if (GAS.SecondaryUsergroups.CachedUsergroups[ply:AccountID()]) then
		for usergroup in pairs(GAS.SecondaryUsergroups.CachedUsergroups[ply:AccountID()]) do
			usergroups_tbl[usergroup] = true
		end
	end
end)

GAS:hook("OpenPermissions:IsUserGroup", "secondaryusergroups:OpenPermissions:IsUserGroup", function(ply, usergroup)
	if (GAS.SecondaryUsergroups.CachedUsergroups[ply:AccountID()]) then
		if (GAS.SecondaryUsergroups.CachedUsergroups[ply:AccountID()][usergroup] == true) then
			return true
		end
	end
end)

if (CLIENT) then
	GAS:netReceive("secondaryusergroups:SyncUsergroups", function()
		local account_id = net.ReadUInt(31)
		GAS.SecondaryUsergroups.CachedUsergroups[account_id] = {}
		local usergroups_len = net.ReadUInt(8)
		for i=1,usergroups_len do
			GAS.SecondaryUsergroups.CachedUsergroups[account_id][net.ReadString()] = true
		end
	end)

	GAS:netReceive("secondaryusergroups:SyncAllUsergroups", function()
		local ply_len = net.ReadUInt(8)
		for i=1,ply_len do
			local account_id = net.ReadUInt(31)
			GAS.SecondaryUsergroups.CachedUsergroups[account_id] = {}
			local usergroups_len = net.ReadUInt(8)
			for i=1,usergroups_len do
				GAS.SecondaryUsergroups.CachedUsergroups[account_id][net.ReadString()] = true
			end
		end
	end)

	GAS:netReceive("secondaryusergroups:UsergroupGiven", function()
		local account_id = net.ReadUInt(31)
		GAS.SecondaryUsergroups.CachedUsergroups[account_id] = GAS.SecondaryUsergroups.CachedUsergroups[account_id] or {}
		GAS.SecondaryUsergroups.CachedUsergroups[account_id][net.ReadString()] = true
	end)

	GAS:netReceive("secondaryusergroups:UsergroupRevoked", function()
		local account_id = net.ReadUInt(31)
		local usergroup = net.ReadString()
		if (GAS.SecondaryUsergroups.CachedUsergroups[account_id] ~= nil) then
			GAS.SecondaryUsergroups.CachedUsergroups[account_id][usergroup] = nil
			if (GAS:table_IsEmpty(GAS.SecondaryUsergroups.CachedUsergroups[account_id])) then
				GAS.SecondaryUsergroups.CachedUsergroups[account_id] = nil
			end
		end
	end)

	GAS:InitPostEntity(function()
		GAS:netStart("secondaryusergroups:SyncAllUsergroups")
		net.SendToServer()
	end)

	GAS:ContextProperty("gas_secondaryusergroups", {
		MenuLabel = L"module_name",
		MenuIcon = "icon16/user_edit.png",
		MenuOpen = function(self, option, ply, tr, option_pnl)
			GAS.SecondaryUsergroups:OpenContextMenu(option, ply, true, option_pnl)
		end,
		Filter = function(self, ent, ply)
			return ent:IsPlayer() and not ent:IsBot() and OpenPermissions:HasPermission(LocalPlayer(), "gmodadminsuite/secondaryusergroups")
		end
	})
end
--addons/billy_gas/lua/gmodadminsuite/modules/secondaryusergroups/cl_menu.lua:
local function L(phrase, ...)
	if (#({...}) == 0) then
		return GAS:Phrase(phrase, "secondaryusergroups")
	else
		return GAS:PhraseFormat(phrase, "secondaryusergroups", ...)
	end
end

local function SortedUsergroups(all_data)
	local all_usergroups = {}
	for account_id, usergroups in pairs(GAS.SecondaryUsergroups.AllData) do
		for usergroup in pairs(usergroups) do
			all_usergroups[usergroup] = true
		end
	end
	local sorted = table.GetKeys(all_usergroups)
	table.sort(sorted)
	return sorted
end

function GAS.SecondaryUsergroups:OpenContextMenu(submenu, ply, open_menu_btn, submenu_pnl)
	if (open_menu_btn) then
		submenu:AddOption(L"open_menu", function()
			RunConsoleCommand("gmodadminsuite", "secondaryusergroups")
		end):SetIcon("icon16/application_form_magnify.png")

		submenu:AddSpacer()
	end

	submenu:AddOption(L"custom_ellipsis", function()
		bVGUI.StringQuery(L"give_usergroup", nil, L"usergroup_ellipsis", function(usergroup)
			GAS:netStart("secondaryusergroups:GiveUsergroup")
				net.WriteUInt(ply:AccountID(), 31)
				net.WriteString(usergroup)
			net.SendToServer()
		end)
	end):SetIcon("icon16/pencil.png")

	local option = submenu:AddOption(ply:GetUserGroup())
	option:SetIcon("icon16/wrench_orange.png")
	function option:OnMouseReleased(m)
		DButton.OnMouseReleased(self, m)
		if (m ~= MOUSE_LEFT or not self.m_MenuClicking) then return end
		self.m_MenuClicking = false
	end
	
	local function Populate()
		local all_usergroups = SortedUsergroups()
		local my_usergroups = OpenPermissions:GetUserGroups(ply)

		for _,usergroup in ipairs(all_usergroups) do
			local option = submenu:AddOption(usergroup)
			option.HasUsergroup = my_usergroups[usergroup] or false
			if (option.HasUsergroup) then
				option:SetIcon("icon16/tick.png")
			else
				option:SetIcon("icon16/cross.png")
			end
			function option:OnMouseReleased(m)
				DButton.OnMouseReleased(self, m)
				if (m ~= MOUSE_LEFT or not self.m_MenuClicking) then return end
				self.m_MenuClicking = false

				self.HasUsergroup = not self.HasUsergroup
				if (self.HasUsergroup) then
					option:SetIcon("icon16/tick.png")
					GAS:netStart("secondaryusergroups:GiveUsergroup")
				else
					option:SetIcon("icon16/cross.png")
					GAS:netStart("secondaryusergroups:RevokeUsergroup")
				end
				
				net.WriteUInt(ply:AccountID(), 31)
				net.WriteString(usergroup)

				net.SendToServer()
			end
		end
	end	

	local loading_option
	local has_loaded
	submenu_pnl.GAS_OLD_ENTER = submenu_pnl.OnCursorEntered
	function submenu_pnl:OnCursorEntered(...)
		self:GAS_OLD_ENTER(...)

		if (not has_loaded) then
			loading_option = bVGUI_DermaMenuOption_Loading(submenu)

			GAS:netStart("secondaryusergroups:GetAllData")
			net.SendToServer()

			GAS:netReceive("secondaryusergroups:GetAllData", function(l)
				GAS.SecondaryUsergroups.AllData = GAS:DeserializeTable(util.Decompress(net.ReadData(l)))
				if (not IsValid(loading_option)) then return end
				loading_option:Remove()

				has_loaded = true

				Populate()
			end)
		end
	end
end

GAS:hook("gmodadminsuite:ModuleSize:secondaryusergroups", "secondaryusergroups:framesize", function()
	return 700,500
end)

local logo_mat = Material("gmodadminsuite/secondaryusergroups.vtf")
GAS:hook("gmodadminsuite:ModuleFrame:secondaryusergroups", "secondaryusergroups:menu", function(ModuleFrame)
	local main_content = vgui.Create("bVGUI.BlankPanel", ModuleFrame)
	main_content:Dock(FILL)

	local left_content = vgui.Create("bVGUI.BlankPanel", main_content)
	left_content:Dock(LEFT)
	left_content:SetWide(175)

	local categories = vgui.Create("bVGUI.Categories", left_content)
	categories:Dock(FILL)
	categories:EnableSearchBar()
	categories:SetLoading(true)
	local category = categories:AddCategory(L"players", Color(216,75,75))

	local offline_container = vgui.Create("DPanel", left_content)
	offline_container:Dock(BOTTOM)
	offline_container:DockPadding(5,5,5,5)
	offline_container:SetTall(35)
	function offline_container:Paint(w,h)
		surface.SetDrawColor(bVGUI.COLOR_DARK_GREY)
		surface.DrawRect(0,0,w,h)
	end

		local offline_btn = vgui.Create("bVGUI.Button", offline_container)
		offline_btn:SetColor(bVGUI.BUTTON_COLOR_BLUE)
		offline_btn:SetText(L"offline_btn")
		offline_btn:Dock(FILL)

	local logo_content = vgui.Create("bVGUI.BlankPanel", main_content)
	logo_content:Dock(FILL)

	local logo_btn = vgui.Create("bVGUI.Button", logo_content)
	logo_btn:SetColor(bVGUI.BUTTON_COLOR_GREEN)
	logo_btn:SetSize(150,30)
	logo_btn:SetText(L"help")
	logo_btn:SetEnabled(false)
	function logo_btn:DoClick()
		GAS:OpenURL("https://gmodsto.re/gmodadminsuite-secondaryusergroups-help")
	end

	function logo_content:Paint(w,h)
		surface.SetMaterial(logo_mat)
		surface.SetDrawColor(255,255,255)
		surface.DrawTexturedRect(w / 2 - 256 / 2, (h / 2 - 256 / 2) - 15 - 30, 256, 256)
	end

	function logo_content:PerformLayout(w,h)
		logo_btn:SetPos(w / 2 - 150 / 2, (h / 2 - 256 / 2) + 185 + 15)
	end

	local function ShowUsergroups(account_id)
		if (IsValid(logo_content)) then
			logo_content:Remove()
		end

		if (IsValid(main_content.Content)) then
			main_content.Content:Remove()
		end
		main_content.Content = vgui.Create("bVGUI.ScrollPanel", main_content)
		main_content.Content:Dock(FILL)

		local btn = vgui.Create("bVGUI.ButtonContainer", main_content.Content)
		btn:Dock(TOP)
		btn:DockMargin(10,10,10,0)
		btn.Button:SetColor(bVGUI.COLOR_GMOD_BLUE)
		btn.Button:SetText(L"give_usergroup")
		btn.Button:SetWide(150)
		function btn.Button:DoClick()
			bVGUI.StringQuery(L"give_usergroup", nil, L"usergroup_ellipsis", function(usergroup)
				local switch = vgui.Create("bVGUI.Switch", main_content.Content)
				switch:DockMargin(10,10,10,0)
				switch:Dock(TOP)
				switch:SetText(usergroup)
				switch:SetChecked(true)
				function switch:OnChange()
					if (self:GetChecked()) then
						GAS:netStart("secondaryusergroups:GiveUsergroup")
					else
						GAS:netStart("secondaryusergroups:RevokeUsergroup")
					end

					net.WriteUInt(account_id, 31)
					net.WriteString(usergroup)

					net.SendToServer()
				end
				switch:OnChange()
			end)
		end

		local switch = vgui.Create("bVGUI.Switch", main_content.Content)
		switch:DockMargin(10,10,10,0)
		switch:Dock(TOP)
		switch:SetText(L"loading_ellipsis")
		switch:SetChecked(true)
		switch:SetDisabled(true)
		switch:SetHelpText(L"usergroup_is_main")

		local all_usergroups = SortedUsergroups()

		for _,usergroup in ipairs(all_usergroups) do
			local switch = vgui.Create("bVGUI.Switch", main_content.Content)
			switch:DockMargin(10,10,10,0)
			switch:Dock(TOP)
			switch:SetText(usergroup)
			switch:SetChecked(GAS.SecondaryUsergroups.AllData[account_id] ~= nil and GAS.SecondaryUsergroups.AllData[account_id][usergroup] == true)
			function switch:OnChange()
				if (self:GetChecked()) then
					GAS:netStart("secondaryusergroups:GiveUsergroup")
				else
					GAS:netStart("secondaryusergroups:RevokeUsergroup")
				end
				
				net.WriteUInt(account_id, 31)
				net.WriteString(usergroup)

				net.SendToServer()
			end
		end

		local main_usergroup
		local target_ply = player.GetByAccountID(account_id)
		if (IsValid(target_ply)) then
			switch:SetText(target_ply:GetUserGroup())
		else
			GAS.OfflinePlayerData:AccountID(account_id, function(success, data)
				if (success) then
					switch:SetText(data.usergroup)
				else
					switch:SetText(L"unknown")
				end
			end)
		end
	end

	function offline_btn:DoClick()
		GAS.SelectionPrompts:PromptAccountID(function(account_id, ply)
			category:AddAccountID(account_id, ShowUsergroups)
		end)
	end

	function main_content:PaintOver(w,h)
		surface.SetDrawColor(255,255,255,255)
		surface.SetMaterial(bVGUI.MATERIAL_SHADOW)
		surface.DrawTexturedRect(categories:GetWide(),0,10,h)
	end

	GAS:netStart("secondaryusergroups:GetAllData")
	net.SendToServer()

	GAS:netReceive("secondaryusergroups:GetAllData", function(l)
		GAS.SecondaryUsergroups.AllData = GAS:DeserializeTable(util.Decompress(net.ReadData(l)))
		categories:SetLoading(false)
		for account_id, usergroups in pairs(GAS.SecondaryUsergroups.AllData) do
			category:AddAccountID(account_id, ShowUsergroups)
		end
	end)
end)