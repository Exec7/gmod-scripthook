--Stealed clientside server code by exechack.cc
--Hostname: [PL] [PixelMod] PelugeRP SWRP | .gg/pixelmod - Part 1/10 - 06/04/2025


--PATH lua/autorun/arccw_autorun.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/arccw/shared/arccw_k_galactic_sounds.lua:
-- Interaction
sound.Add( {
    name = "ArcCW_Kraken.Draw",
    channel = CHAN_ITEM + 6,
    volume = 1.0,
    level = 140,
    pitch = {95, 105},
    sound = {
        "arccw/kraken/40k_essentials/draw_rifle.wav",
        "arccw/kraken/40k_essentials/draw_pistol.wav",
    }
} )

sound.Add( {
    name = "ArcCW_Kraken.Grab",
    channel = CHAN_ITEM + 6,
    volume = 0.5,
    level = 120,
    pitch = {90, 115},
    sound = {
        "shared/manual_reset_1.mp3",
        "shared/manual_reset_2.mp3",
        "shared/manual_reset_3.mp3",
        "shared/manual_reset_4.mp3",
    }
} )

sound.Add( {
    name = "ArcCW_Kraken.Overheat",
    channel = CHAN_WEAPON + 6,
    volume = 0.5,
    level = 120,
    pitch = {90, 115},
    sound = {
        "shared/overheat/overheat_1.wav",
        "shared/overheat/overheat_2.wav",
        "shared/overheat/overheat_3.wav",
        "shared/overheat/overheat_4.wav",
        "shared/overheat/overheat_5.wav",
        "shared/overheat/overheat_6.wav",
        "shared/overheat/overheat_7.wav",
        "shared/overheat/overheat_8.wav",
        "shared/overheat/overheat_9.wav",
        "shared/overheat/overheat_10.wav",
        "shared/overheat/overheat_11.wav",
        "shared/overheat/overheat_12.wav",
        "shared/overheat/overheat_13.wav",
        "shared/overheat/overheat_14.wav",
        "shared/overheat/overheat_15.wav",
        "shared/overheat/overheat_16.wav",
        "shared/overheat/overheat_17.wav",
        "shared/overheat/overheat_18.wav",
        "shared/overheat/overheat_19.wav",
        "shared/overheat/overheat_20.wav",
        "shared/overheat/overheat_21.wav",
    }
} )

sound.Add( {
    name = "ArcCW_Kraken.OverheatFix",
    channel = CHAN_WEAPON + 6,
    volume = 0.5,
    level = 120,
    pitch = {90, 115},
    sound = {
        "shared/overheat/overheat_fix_1.wav",
        "shared/overheat/overheat_fix_2.wav",
        "shared/overheat/overheat_fix_3.wav",
        "shared/overheat/overheat_fix_4.wav",
    }
} )

sound.Add( {
    name = "ArcCW_Kraken.OverheatReplenished",
    channel = CHAN_WEAPON + 6,
    volume = 0.5,
    level = 120,
    pitch = {90, 115},
    sound = {
        "shared/overheat/overheat_replenished_1.wav",
        "shared/overheat/overheat_replenished_2.wav",
        "shared/overheat/overheat_replenished_3.wav",
        "shared/overheat/overheat_replenished_4.wav",
        "shared/overheat/overheat_replenished_5.wav",
    }
} )


sound.Add( {
    name = "ArcCW_Kraken.OverheatWarn",
    channel = CHAN_ITEM + 6,
    volume = 0.5,
    level = 120,
    pitch = {90, 115},
    sound = {
        "shared/overheat/overheat_warning_1.wav",
        "shared/overheat/overheat_warning_2.wav",
        "shared/overheat/overheat_warning_3.wav",
        "shared/overheat/overheat_warning_4.wav",
        "shared/overheat/overheat_warning_5.wav",
    }
} )
-- Corebass
sound.Add( {
    name = "ArcCW_Kraken.HeavyCorebass",
    channel = CHAN_AUTO + 6,
    volume = 1.0,
    level = 140,
    pitch = {95, 105},
    sound = {
        "shared/corebass/heavy/corebass_heavy_1.wav",
        "shared/corebass/heavy/corebass_heavy_2.wav",
        "shared/corebass/heavy/corebass_heavy_3.wav",
        "shared/corebass/heavy/corebass_heavy_4.wav",
        "shared/corebass/heavy/corebass_heavy_5.wav",
        "shared/corebass/heavy/corebass_heavy_6.wav",
        "shared/corebass/heavy/corebass_heavy_7.wav",
        "shared/corebass/heavy/corebass_heavy_8.wav",
        "shared/corebass/heavy/corebass_heavy_9.wav",
    }
} )

sound.Add( {
    name = "ArcCW_Kraken.LightCorebass",
    channel = CHAN_AUTO + 6,
    volume = 1.0,
    level = 140,
    pitch = {95, 105},
    sound = {
        "shared/corebass/light/corebass_light_1.wav",
        "shared/corebass/light/corebass_light_2.wav",
        "shared/corebass/light/corebass_light_3.wav",
        "shared/corebass/light/corebass_light_4.wav",
        "shared/corebass/light/corebass_light_5.wav",
    }
} )

sound.Add( {
    name = "ArcCW_Kraken.StandardCorebass",
    channel = CHAN_AUTO + 6,
    volume = 1.0,
    level = 140,
    pitch = {95, 105},
    sound = {
        "shared/corebass/rifle/corebass_rifle_1.wav",
        "shared/corebass/rifle/corebass_rifle_2.wav",
        "shared/corebass/rifle/corebass_rifle_3.wav",
        "shared/corebass/rifle/corebass_rifle_4.wav",
        "shared/corebass/rifle/corebass_rifle_6.wav",
        "shared/corebass/rifle/corebass_rifle_5.wav",
    }
} )


-- Weapons
sound.Add( {
    name = "ArcCW_Kraken.SW_DLT74",
    channel = CHAN_WEAPON + 6,
    volume = 1.0,
    level = 140,
    pitch = {95, 105},
    sound = {
        "arccw/kraken/sw_galactic/weapons/dlt74/dlt74.wav",
        "arccw/kraken/sw_galactic/weapons/dlt74/dlt74.wav",
        "arccw/kraken/sw_galactic/weapons/dlt74/dlt74.wav",
        "arccw/kraken/sw_galactic/weapons/dlt74/dlt74.wav",
    }
} )
sound.Add( {
    name = "ArcCW_Kraken.SW_DC40",
    channel = CHAN_WEAPON + 6,
    volume = 1.0,
    level = 140,
    pitch = {95, 105},
    sound = {
        "arccw/kraken/sw_galactic/weapons/dlt74/dc40.wav",
        "arccw/kraken/sw_galactic/weapons/dlt74/dc40.wav",
        "arccw/kraken/sw_galactic/weapons/dlt74/dc40.wav",
        "arccw/kraken/sw_galactic/weapons/dlt74/dc40.wav",
    }
} )
sound.Add( {
    name = "ArcCW_Kraken.SW_NN14",
    channel = CHAN_WEAPON + 6,
    volume = 1.0,
    level = 140,
    pitch = {95, 105},
    sound = {
        "arccw/kraken/sw_galactic/weapons/nn14.wav",
        "arccw/kraken/sw_galactic/weapons/nn14.wav",
        "arccw/kraken/sw_galactic/weapons/nn14.wav",
        "arccw/kraken/sw_galactic/weapons/nn14.wav",
    }
} )
sound.Add( {
    name = "ArcCW_Kraken.SW_RELBY",
    channel = CHAN_WEAPON + 6,
    volume = 1.0,
    level = 140,
    pitch = {95, 105},
    sound = {
        "arccw/kraken/sw_galactic/weapons/relby/sw02_weapons_blasters_relby-v10_laser_close_shotgun_var_01_04.mp3",
        "arccw/kraken/sw_galactic/weapons/relby/sw02_weapons_blasters_relby-v10_laser_close_shotgun_var_01_05.mp3",
        "arccw/kraken/sw_galactic/weapons/relby/sw02_weapons_blasters_relby-v10_laser_close_shotgun_var_01_06.mp3",
        "arccw/kraken/sw_galactic/weapons/relby/sw02_weapons_blasters_relby-v10_laser_close_shotgun_var_01_07.mp3",
    }
} )
sound.Add( {
    name = "ArcCW_Kraken.SW_MD12",
    channel = CHAN_WEAPON + 6,
    volume = 1.0,
    level = 140,
    pitch = {95, 105},
    sound = {
        "arccw/kraken/sw_galactic/weapons/md12.wav",
        "arccw/kraken/sw_galactic/weapons/md12.wav",
        "arccw/kraken/sw_galactic/weapons/md12.wav",
    }
} )
sound.Add( {
    name = "ArcCW_Kraken.SW_S5",
    channel = CHAN_WEAPON + 6,
    volume = 1.0,
    level = 140,
    pitch = {95, 105},
    sound = {
        "arccw/kraken/sw_galactic/weapons/s-5/sw02_weapons_blasters_s-5_laser_close_var_04_01.wav",
        "arccw/kraken/sw_galactic/weapons/s-5/sw02_weapons_blasters_s-5_laser_close_var_04_02.wav",
        "arccw/kraken/sw_galactic/weapons/s-5/sw02_weapons_blasters_s-5_laser_close_var_04_03.wav",
        "arccw/kraken/sw_galactic/weapons/s-5/sw02_weapons_blasters_s-5_laser_close_var_04_04.wav",
        "arccw/kraken/sw_galactic/weapons/s-5/sw02_weapons_blasters_s-5_laser_close_var_04_05.wav",
        "arccw/kraken/sw_galactic/weapons/s-5/sw02_weapons_blasters_s-5_laser_close_var_04_06.wav",
        "arccw/kraken/sw_galactic/weapons/s-5/sw02_weapons_blasters_s-5_laser_close_var_04_07.wav",
    }
} )
sound.Add( {
    name = "ArcCW_Kraken.SW_M45",
    channel = CHAN_WEAPON + 6,
    volume = 1.0,
    level = 140,
    pitch = {95, 105},
    sound = {
        "arccw/kraken/sw_galactic/weapons/no se que arma es esta jaja.wav",
        "arccw/kraken/sw_galactic/weapons/no se que arma es esta jaja.wav",
        "arccw/kraken/sw_galactic/weapons/no se que arma es esta jaja.wav",
        "arccw/kraken/sw_galactic/weapons/no se que arma es esta jaja.wav",
    }
} )
sound.Add( {
    name = "ArcCW_Kraken.SW_X8",
    channel = CHAN_WEAPON + 6,
    volume = 1.0,
    level = 140,
    pitch = {95, 105},
    sound = {
        "arccw/kraken/sw_galactic/weapons/x8/sw02_weapons_blasters_x8_laser_close_var_01_01.wav",
        "arccw/kraken/sw_galactic/weapons/x8/sw02_weapons_blasters_x8_laser_close_var_01_02.wav",
        "arccw/kraken/sw_galactic/weapons/x8/sw02_weapons_blasters_x8_laser_close_var_01_03.wav",
        "arccw/kraken/sw_galactic/weapons/x8/sw02_weapons_blasters_x8_laser_close_var_01_04.wav",
        "arccw/kraken/sw_galactic/weapons/x8/sw02_weapons_blasters_x8_laser_close_var_01_05.wav",
        "arccw/kraken/sw_galactic/weapons/x8/sw02_weapons_blasters_x8_laser_close_var_01_06.wav",
    }
} )
sound.Add( {
    name = "ArcCW_Kraken.SW_MK2PALADIN",
    channel = CHAN_WEAPON + 6,
    volume = 1.0,
    level = 140,
    pitch = {95, 105},
    sound = {
        "arccw/kraken/sw_galactic/weapons/x8/sw02_weapons_blasters_x8_laser_close_var_01_01.wav",
        "arccw/kraken/sw_galactic/weapons/x8/sw02_weapons_blasters_x8_laser_close_var_01_02.wav",
        "arccw/kraken/sw_galactic/weapons/x8/sw02_weapons_blasters_x8_laser_close_var_01_03.wav",
        "arccw/kraken/sw_galactic/weapons/x8/sw02_weapons_blasters_x8_laser_close_var_01_04.wav",
        "arccw/kraken/sw_galactic/weapons/x8/sw02_weapons_blasters_x8_laser_close_var_01_05.wav",
        "arccw/kraken/sw_galactic/weapons/x8/sw02_weapons_blasters_x8_laser_close_var_01_06.wav",
    }
} )
sound.Add( {
    name = "ArcCW_Kraken.SW_ZERZIUM",
    channel = CHAN_WEAPON + 6,
    volume = 1.0,
    level = 140,
    pitch = {95, 105},
    sound = {
        "arccw/kraken/sw_galactic/weapons/iqa11/handling/fire-sup-01.ogg",
        "arccw/kraken/sw_galactic/weapons/iqa11/handling/fire-sup-02.ogg",
        "arccw/kraken/sw_galactic/weapons/iqa11/handling/fire-sup-03.ogg",
        "arccw/kraken/sw_galactic/weapons/iqa11/handling/fire-sup-04.ogg",
        "arccw/kraken/sw_galactic/weapons/iqa11/handling/fire-sup-05.ogg",
        "arccw/kraken/sw_galactic/weapons/iqa11/handling/fire-sup-06.ogg",
    }
} )
sound.Add( {
    name = "ArcCW_Kraken.SW_STW48",
    channel = CHAN_WEAPON + 6,
    volume = 1.0,
    level = 140,
    pitch = {95, 105},
    sound = {
        "arccw/kraken/sw_galactic/weapons/st-w48/sw02_weapons_blasters_st-w48_laser_close_var_01_02.mp3",
        "arccw/kraken/sw_galactic/weapons/st-w48/sw02_weapons_blasters_st-w48_laser_close_var_01_03.mp3",
        "arccw/kraken/sw_galactic/weapons/st-w48/sw02_weapons_blasters_st-w48_laser_close_var_01_01.mp3",
        "arccw/kraken/sw_galactic/weapons/st-w48/sw02_weapons_blasters_st-w48_laser_close_var_01_04.mp3",
        "arccw/kraken/sw_galactic/weapons/st-w48/sw02_weapons_blasters_st-w48_laser_close_var_01_05.mp3",
        "arccw/kraken/sw_galactic/weapons/st-w48/sw02_weapons_blasters_st-w48_laser_close_var_01_06.mp3",
        "arccw/kraken/sw_galactic/weapons/st-w48/sw02_weapons_blasters_st-w48_laser_close_var_01_07.mp3",
        "arccw/kraken/sw_galactic/weapons/st-w48/sw02_weapons_blasters_st-w48_laser_close_var_01_08.mp3",
        "arccw/kraken/sw_galactic/weapons/st-w48/sw02_weapons_blasters_st-w48_laser_close_var_01_09.mp3",
    }
} )
sound.Add( {
    name = "ArcCW_Kraken.SW_IQA",
    channel = CHAN_WEAPON + 6,
    volume = 1.0,
    level = 140,
    pitch = {95, 105},
    sound = {
        "arccw/kraken/sw_galactic/weapons/iqa11/sw02_weapons_blasters_iqa11_laser_close_var_01_01.wav",
        "arccw/kraken/sw_galactic/weapons/iqa11/sw02_weapons_blasters_iqa11_laser_close_var_01_02.wav",
        "arccw/kraken/sw_galactic/weapons/iqa11/sw02_weapons_blasters_iqa11_laser_close_var_01_03.wav",
        "arccw/kraken/sw_galactic/weapons/iqa11/sw02_weapons_blasters_iqa11_laser_close_var_01_04.wav",
        "arccw/kraken/sw_galactic/weapons/iqa11/sw02_weapons_blasters_iqa11_laser_close_var_01_05.wav",
        "arccw/kraken/sw_galactic/weapons/iqa11/sw02_weapons_blasters_iqa11_laser_close_var_01_06.wav",
        "arccw/kraken/sw_galactic/weapons/iqa11/sw02_weapons_blasters_iqa11_laser_close_var_01_07.wav",
        "arccw/kraken/sw_galactic/weapons/iqa11/sw02_weapons_blasters_iqa11_laser_close_var_01_08.wav",
    }
} )
sound.Add( {
    name = "ArcCW_Kraken.SW_F10",
    channel = CHAN_WEAPON + 6,
    volume = 1.0,
    level = 140,
    pitch = {95, 105},
    sound = {
        "arccw/kraken/sw_galactic/weapons/f-11d/sw02_weapons_blasters_f-11d_laser_close_var_03_01.wav",
        "arccw/kraken/sw_galactic/weapons/f-11d/sw02_weapons_blasters_f-11d_laser_close_var_03_02.wav",
        "arccw/kraken/sw_galactic/weapons/f-11d/sw02_weapons_blasters_f-11d_laser_close_var_03_03.wav",
        "arccw/kraken/sw_galactic/weapons/f-11d/sw02_weapons_blasters_f-11d_laser_close_var_03_04.wav",
        "arccw/kraken/sw_galactic/weapons/f-11d/sw02_weapons_blasters_f-11d_laser_close_var_03_05.wav",
        "arccw/kraken/sw_galactic/weapons/f-11d/sw02_weapons_blasters_f-11d_laser_close_var_03_06.wav",
        "arccw/kraken/sw_galactic/weapons/f-11d/sw02_weapons_blasters_f-11d_laser_close_var_03_07.wav",
        "arccw/kraken/sw_galactic/weapons/f-11d/sw02_weapons_blasters_f-11d_laser_close_var_03_08.wav",
    }
} )
sound.Add( {
    name = "ArcCW_Kraken.SW_9228",
    channel = CHAN_WEAPON + 6,
    volume = 1.0,
    level = 140,
    pitch = {95, 105},
    sound = {
        "arccw/kraken/sw_galactic/weapons/x8/sw02_weapons_blasters_x8_sharpshot_laser_close_var_07_01.wav",
        "arccw/kraken/sw_galactic/weapons/x8/sw02_weapons_blasters_x8_sharpshot_laser_close_var_07_02.wav",
        "arccw/kraken/sw_galactic/weapons/x8/sw02_weapons_blasters_x8_sharpshot_laser_close_var_07_03.wav",
        "arccw/kraken/sw_galactic/weapons/x8/sw02_weapons_blasters_x8_sharpshot_laser_close_var_07_04.wav",
    }
} )
sound.Add( {
    name = "ArcCW_Kraken.SW_DLT16X",
    channel = CHAN_WEAPON + 6,
    volume = 1.0,
    level = 140,
    pitch = {95, 105},
    sound = {
        "arccw/kraken/sw_galactic/weapons/dlt19x/sw02_weapons_blaster_dlt19x_laser_close_var_01_01.wav",
        "arccw/kraken/sw_galactic/weapons/dlt19x/sw02_weapons_blaster_dlt19x_laser_close_var_01_02.wav",
        "arccw/kraken/sw_galactic/weapons/dlt19x/sw02_weapons_blaster_dlt19x_laser_close_var_01_03.wav",
        "arccw/kraken/sw_galactic/weapons/dlt19x/sw02_weapons_blaster_dlt19x_laser_close_var_01_04.wav",
    }
} )
sound.Add( {
    name = "ArcCW_Kraken.SW_DLT16",
    channel = CHAN_WEAPON + 6,
    volume = 1.0,
    level = 140,
    pitch = {95, 105},
    sound = {
        "arccw/kraken/sw_galactic/weapons/dlt19/sw02_weapons_blasters_dlt19_laser_close_var_02_01.wav",
        "arccw/kraken/sw_galactic/weapons/dlt19/sw02_weapons_blasters_dlt19_laser_close_var_02_02.wav",
        "arccw/kraken/sw_galactic/weapons/dlt19/sw02_weapons_blasters_dlt19_laser_close_var_02_03.wav",
        "arccw/kraken/sw_galactic/weapons/dlt19/sw02_weapons_blasters_dlt19_laser_close_var_02_04.wav",
        "arccw/kraken/sw_galactic/weapons/dlt19/sw02_weapons_blasters_dlt19_laser_close_var_02_05.wav",
        "arccw/kraken/sw_galactic/weapons/dlt19/sw02_weapons_blasters_dlt19_laser_close_var_02_06.wav",
        "arccw/kraken/sw_galactic/weapons/dlt19/sw02_weapons_blasters_dlt19_laser_close_var_02_07.wav",
        "arccw/kraken/sw_galactic/weapons/dlt19/sw02_weapons_blasters_dlt19_laser_close_var_02_09.wav",
    }
} )
sound.Add( {
    name = "ArcCW_Kraken.SW_WESTAR",
    channel = CHAN_WEAPON + 6,
    volume = 1.0,
    level = 140,
    pitch = {95, 105},
    sound = {
        "arccw/kraken/sw_galactic/weapons/westar35.wav",
        "arccw/kraken/sw_galactic/weapons/westar35.wav",
        "arccw/kraken/sw_galactic/weapons/westar35.wav",
        "arccw/kraken/sw_galactic/weapons/westar35.wav",
    }
} )
sound.Add( {
    name = "ArcCW_Kraken.SW_BRYAR",
    channel = CHAN_WEAPON + 6,
    volume = 1.0,
    level = 140,
    pitch = {95, 105},
    sound = {
        "arccw/kraken/sw_galactic/weapons/bryar.wav",
        "arccw/kraken/sw_galactic/weapons/bryar.wav",
        "arccw/kraken/sw_galactic/weapons/bryar.wav",
        "arccw/kraken/sw_galactic/weapons/bryar.wav",
    }
} )
sound.Add( {
    name = "ArcCW_Kraken.SW_DEFENDER",
    channel = CHAN_WEAPON + 6,
    volume = 1.0,
    level = 140,
    pitch = {95, 105},
    sound = {
        "arccw/kraken/sw_galactic/weapons/defender/sw02_weapons_blasters_defender_laser_close_var_02_01.wav",
        "arccw/kraken/sw_galactic/weapons/defender/sw02_weapons_blasters_defender_laser_close_var_02_02.wav",
        "arccw/kraken/sw_galactic/weapons/defender/sw02_weapons_blasters_defender_laser_close_var_02_03.wav",
        "arccw/kraken/sw_galactic/weapons/defender/sw02_weapons_blasters_defender_laser_close_var_02_04.wav",
        "arccw/kraken/sw_galactic/weapons/defender/sw02_weapons_blasters_defender_laser_close_var_02_05.wav",
        "arccw/kraken/sw_galactic/weapons/defender/sw02_weapons_blasters_defender_laser_close_var_02_06.wav",
    }
} )
sound.Add( {
    name = "ArcCW_Kraken.SW_DC92",
    channel = CHAN_WEAPON + 6,
    volume = 1.0,
    level = 140,
    pitch = {95, 105},
    sound = {
        "arccw/kraken/sw_galactic/weapons/dc92.wav",
        "arccw/kraken/sw_galactic/weapons/dc92.wav",
        "arccw/kraken/sw_galactic/weapons/dc92.wav",
        "arccw/kraken/sw_galactic/weapons/dc92.wav",
    }
} )
sound.Add( {
    name = "ArcCW_Kraken.SW_GLIE44",
    channel = CHAN_WEAPON + 6,
    volume = 1.0,
    level = 140,
    pitch = {95, 105},
    sound = {
        "arccw/kraken/sw_galactic/weapons/glie44/sw02_weapons_blasters_glie44_laser_close_var_01_01.wav",
        "arccw/kraken/sw_galactic/weapons/glie44/sw02_weapons_blasters_glie44_laser_close_var_01_02.wav",
    }
} )
sound.Add( {
    name = "ArcCW_Kraken.SW_EL16",
    channel = CHAN_WEAPON + 6,
    volume = 1.0,
    level = 140,
    pitch = {95, 105},
    sound = {
        "arccw/kraken/sw_galactic/weapons/glie44/sw02_weapons_blasters_glie44_laser_close_var_01_01.wav",
        "arccw/kraken/sw_galactic/weapons/glie44/sw02_weapons_blasters_glie44_laser_close_var_01_02.wav",
    }
} )
sound.Add( {
    name = "ArcCW_Kraken.SW_FWMB",
    channel = CHAN_WEAPON + 6,
    volume = 1.0,
    level = 140,
    pitch = {95, 105},
    sound = {
        "arccw/kraken/sw_galactic/weapons/fwmb-10/sw02_weapons_blasters_fwmb-10_laser_close_var_03_01.wav",
        "arccw/kraken/sw_galactic/weapons/fwmb-10/sw02_weapons_blasters_fwmb-10_laser_close_var_03_02.wav",
        "arccw/kraken/sw_galactic/weapons/fwmb-10/sw02_weapons_blasters_fwmb-10_laser_close_var_03_03.wav",
        "arccw/kraken/sw_galactic/weapons/fwmb-10/sw02_weapons_blasters_fwmb-10_laser_close_var_03_04.wav",
        "arccw/kraken/sw_galactic/weapons/fwmb-10/sw02_weapons_blasters_fwmb-10_laser_close_var_03_05.wav",
        "arccw/kraken/sw_galactic/weapons/fwmb-10/sw02_weapons_blasters_fwmb-10_laser_close_var_03_06.wav",
        "arccw/kraken/sw_galactic/weapons/fwmb-10/sw02_weapons_blasters_fwmb-10_laser_close_var_03_07.wav",
    }
} )
sound.Add( {
    name = "ArcCW_Kraken.SW_E9X",
    channel = CHAN_WEAPON + 6,
    volume = 1.0,
    level = 140,
    pitch = {95, 105},
    sound = {
        "arccw/kraken/sw_galactic/weapons/e9/fire_normal.mp3",
        "arccw/kraken/sw_galactic/weapons/e9/fire_normal.mp3",
    }
} )
sound.Add( {
    name = "ArcCW_Kraken.SW_E9",
    channel = CHAN_WEAPON + 6,
    volume = 1.0,
    level = 140,
    pitch = {95, 105},
    sound = {
        "arccw/kraken/sw_galactic/weapons/e9/e9.mp3",
        "arccw/kraken/sw_galactic/weapons/e9/e9.mp3",
    }
} )
sound.Add( {
    name = "ArcCW_Kraken.SW_KYD21",
    channel = CHAN_WEAPON + 6,
    volume = 1.0,
    level = 140,
    pitch = {95, 105},
    sound = {
        "arccw/kraken/sw_galactic/weapons/caradune/sw02_weapons_blasters_scandart_laser_distant_var_01_03.wav",
        "arccw/kraken/sw_galactic/weapons/caradune/sw02_weapons_blasters_scandart_laser_distant_var_01_04.wav",
    }
} )
sound.Add( {
    name = "ArcCW_Kraken.SW_SMUGGLER",
    channel = CHAN_WEAPON + 6,
    volume = 1.0,
    level = 140,
    pitch = {95, 105},
    sound = {
        "arccw/kraken/sw_galactic/weapons/smuggler/fire.mp3",
    }
} )
sound.Add( {
    name = "ArcCW_Kraken.SW_CARADUNE",
    channel = CHAN_WEAPON + 6,
    volume = 1.0,
    level = 140,
    pitch = {95, 105},
    sound = {
        "arccw/kraken/sw_galactic/weapons/caradune/sw02_weapons_blasters_scandart_laser_close_var_04_01.wav",
        "arccw/kraken/sw_galactic/weapons/caradune/sw02_weapons_blasters_scandart_laser_close_var_04_03.wav",
        "arccw/kraken/sw_galactic/weapons/caradune/sw02_weapons_blasters_scandart_laser_close_var_04_03.wav",
        "arccw/kraken/sw_galactic/weapons/caradune/sw02_weapons_blasters_scandart_laser_close_var_04_04.wav",
        "arccw/kraken/sw_galactic/weapons/caradune/sw02_weapons_blasters_scandart_laser_distant_var_01_01.wav",
        "arccw/kraken/sw_galactic/weapons/caradune/sw02_weapons_blasters_scandart_laser_distant_var_01_02.wav",
    }
} )
sound.Add( {
    name = "ArcCW_Kraken.SW_PULSE",
    channel = CHAN_WEAPON + 6,
    volume = 1.0,
    level = 140,
    pitch = {95, 105},
    sound = {
        "arccw/kraken/sw_galactic/weapons/glie44/sw02_weapons_blasters_glie44_laser_close_var_01_01.wav",
        "arccw/kraken/sw_galactic/weapons/glie44/sw02_weapons_blasters_glie44_laser_close_var_01_02.wav",
    }
} )
sound.Add( {
    name = "ArcCW_Kraken.SW_EE3R",
    channel = CHAN_WEAPON + 6,
    volume = 1.0,
    level = 140,
    pitch = {95, 105},
    sound = {
        "arccw/kraken/sw_galactic/weapons/ee3r/fire1.mp3",
        "arccw/kraken/sw_galactic/weapons/ee3r/fire2.mp3",
    }
} )
sound.Add( {
    name = "ArcCW_Kraken.SW_J1",
    channel = CHAN_WEAPON + 6,
    volume = 1.0,
    level = 140,
    pitch = {95, 105},
    sound = {
        "arccw/kraken/sw_galactic/weapons/j1/fire.mp3",
        "arccw/kraken/sw_galactic/weapons/j1/fire.mp3",
    }
} )
sound.Add( {
    name = "ArcCW_Kraken.SW_DE18",
    channel = CHAN_WEAPON + 6,
    volume = 1.0,
    level = 140,
    pitch = {95, 105},
    sound = {
        "arccw/kraken/sw_galactic/weapons/de18/fire_1.wav",
        "arccw/kraken/sw_galactic/weapons/de18/fire_2.wav",
        "arccw/kraken/sw_galactic/weapons/de18/fire_3.wav",
    }
} )
sound.Add( {
    name = "ArcCW_Kraken.SW_A280",
    channel = CHAN_WEAPON + 6,
    volume = 1.0,
    level = 140,
    pitch = {95, 105},
    sound = {
        "arccw/kraken/sw_galactic/weapons/a280/sw02_weapons_blasters_a280_laser_close_var_01_01.wav",
        "arccw/kraken/sw_galactic/weapons/a280/sw02_weapons_blasters_a280_laser_close_var_01_02.wav",
        "arccw/kraken/sw_galactic/weapons/a280/sw02_weapons_blasters_a280_laser_close_var_01_03.wav",
        "arccw/kraken/sw_galactic/weapons/a280/sw02_weapons_blasters_a280_laser_close_var_01_04.wav",
    }
} )
sound.Add( {
    name = "ArcCW_Kraken.SW_DLT20",
    channel = CHAN_WEAPON + 6,
    volume = 1.0,
    level = 140,
    pitch = {95, 105},
    sound = {
        "arccw/kraken/sw_galactic/weapons/dlt20a/sw02_weapons_blasters_dlt20a_laser_distant_var_05_01.wav",
        "arccw/kraken/sw_galactic/weapons/dlt20a/sw02_weapons_blasters_dlt20a_laser_distant_var_05_03.wav",
        "arccw/kraken/sw_galactic/weapons/dlt20a/sw02_weapons_blasters_dlt20a_laser_distant_var_05_06.wav",
        "arccw/kraken/sw_galactic/weapons/dlt20a/sw02_weapons_blasters_dlt20a_laser_distant_var_05_02.wav",
    }
} )
sound.Add( {
    name = "ArcCW_Kraken.SW_BOWCASTEREXT",
    channel = CHAN_WEAPON + 6,
    volume = 1.0,
    level = 140,
    pitch = {95, 105},
    sound = {
        "arccw/kraken/sw_galactic/weapons/bowcaster/sw02_weapons_blasters_bowcaster_frenzy_laser_close_var_02_01.wav",
        "arccw/kraken/sw_galactic/weapons/bowcaster/sw02_weapons_blasters_bowcaster_frenzy_laser_close_var_02_02.wav",
        "arccw/kraken/sw_galactic/weapons/bowcaster/sw02_weapons_blasters_bowcaster_frenzy_laser_close_var_02_03.wav",
    }
} )
sound.Add( {
    name = "ArcCW_Kraken.SW_BOWCASTER",
    channel = CHAN_WEAPON + 6,
    volume = 1.0,
    level = 140,
    pitch = {95, 105},
    sound = {
        "arccw/kraken/sw_galactic/weapons/bowcaster/sw02_weapons_blasters_bowcaster_furious_laser_close_var_01_01.wav",
        "arccw/kraken/sw_galactic/weapons/bowcaster/sw02_weapons_blasters_bowcaster_furious_laser_close_var_01_03.wav",
        "arccw/kraken/sw_galactic/weapons/bowcaster/sw02_weapons_blasters_bowcaster_furious_laser_close_var_01_04.wav",
        "arccw/kraken/sw_galactic/weapons/bowcaster/sw02_weapons_blasters_bowcaster_furious_laser_close_var_01_05.wav",
    }
} )
sound.Add( {
    name = "ArcCW_Kraken.SW_EE3",
    channel = CHAN_WEAPON + 6,
    volume = 1.0,
    level = 140,
    pitch = {95, 105},
    sound = {
        "arccw/kraken/sw_galactic/weapons/ee-3/sw02_weapons_blasters_ee3_laser_close_var_03_01.wav",
        "arccw/kraken/sw_galactic/weapons/ee-3/sw02_weapons_blasters_ee3_laser_close_var_03_02.wav",
        "arccw/kraken/sw_galactic/weapons/ee-3/sw02_weapons_blasters_ee3_laser_close_var_03_03.wav",
        "arccw/kraken/sw_galactic/weapons/ee-3/sw02_weapons_blasters_ee3_laser_close_var_03_04.wav",
        "arccw/kraken/sw_galactic/weapons/ee-3/sw02_weapons_blasters_ee3_laser_close_var_03_05.wav",
        "arccw/kraken/sw_galactic/weapons/ee-3/sw02_weapons_blasters_ee3_laser_close_var_03_06.wav",
        "arccw/kraken/sw_galactic/weapons/ee-3/sw02_weapons_blasters_ee3_laser_close_var_03_07.wav",
    }
} )
sound.Add( {
    name = "ArcCW_Kraken.SW_DH17",
    channel = CHAN_WEAPON + 6,
    volume = 1.0,
    level = 140,
    pitch = {95, 105},
    sound = {
        "arccw/kraken/sw_galactic/weapons/dh17/sw02_weapons_blasters_dh17_laser_close_var_03_01.wav",
        "arccw/kraken/sw_galactic/weapons/dh17/sw02_weapons_blasters_dh17_laser_close_var_03_02.wav",
        "arccw/kraken/sw_galactic/weapons/dh17/sw02_weapons_blasters_dh17_laser_close_var_03_03.wav",
        "arccw/kraken/sw_galactic/weapons/dh17/sw02_weapons_blasters_dh17_laser_close_var_03_04.wav",
        "arccw/kraken/sw_galactic/weapons/dh17/sw02_weapons_blasters_dh17_laser_close_var_03_05.wav",
        "arccw/kraken/sw_galactic/weapons/dh17/sw02_weapons_blasters_dh17_laser_close_var_03_07.wav",
        "arccw/kraken/sw_galactic/weapons/dh17/sw02_weapons_blasters_dh17_laser_close_var_03_08.wav",
    }
} )
sound.Add( {
    name = "ArcCW_Kraken.SW_DL18",
    channel = CHAN_WEAPON + 6,
    volume = 1.0,
    level = 140,
    pitch = {95, 105},
    sound = {
        "arccw/kraken/sw_galactic/weapons/dl-18/sw02_weapons_blasters_dl-18_laser_close_var_15_01.wav",
        "arccw/kraken/sw_galactic/weapons/dl-18/sw02_weapons_blasters_dl-18_laser_close_var_15_02.wav",
        "arccw/kraken/sw_galactic/weapons/dl-18/sw02_weapons_blasters_dl-18_laser_close_var_15_03.wav",
        "arccw/kraken/sw_galactic/weapons/dl-18/sw02_weapons_blasters_dl-18_laser_close_var_15_04.wav",
        "arccw/kraken/sw_galactic/weapons/dl-18/sw02_weapons_blasters_dl-18_laser_close_var_15_05.wav",
        "arccw/kraken/sw_galactic/weapons/dl-18/sw02_weapons_blasters_dl-18_laser_close_var_15_06.wav",
        "arccw/kraken/sw_galactic/weapons/dl-18/sw02_weapons_blasters_dl-18_laser_close_var_15_07.wav",
        "arccw/kraken/sw_galactic/weapons/dl-18/sw02_weapons_blasters_dl-18_laser_close_var_15_08.wav",
    }
} )
sound.Add( {
    name = "ArcCW_Kraken.SW_RT97",
    channel = CHAN_WEAPON + 6,
    volume = 1.0,
    level = 140,
    pitch = {95, 105},
    sound = {
        "arccw/kraken/sw_galactic/weapons/rt97c/sw02_weapons_blasters_rt96c_laser_close_var_06_01.wav",
        "arccw/kraken/sw_galactic/weapons/rt97c/sw02_weapons_blasters_rt96c_laser_close_var_06_02.wav",
        "arccw/kraken/sw_galactic/weapons/rt97c/sw02_weapons_blasters_rt96c_laser_close_var_06_03.wav",
        "arccw/kraken/sw_galactic/weapons/rt97c/sw02_weapons_blasters_rt96c_laser_close_var_06_04.wav",
        "arccw/kraken/sw_galactic/weapons/rt97c/sw02_weapons_blasters_rt96c_laser_close_var_06_05.wav",
        "arccw/kraken/sw_galactic/weapons/rt97c/sw02_weapons_blasters_rt96c_laser_close_var_06_06.wav",
        "arccw/kraken/sw_galactic/weapons/rt97c/sw02_weapons_blasters_rt96c_laser_close_var_06_06.wav",
        "arccw/kraken/sw_galactic/weapons/rt97c/sw02_weapons_blasters_rt96c_laser_close_var_06_07.wav",
        "arccw/kraken/sw_galactic/weapons/rt97c/sw02_weapons_blasters_rt96c_laser_close_var_06_08.wav",
        "arccw/kraken/sw_galactic/weapons/rt97c/sw02_weapons_blasters_rt96c_laser_close_var_06_10.wav",
    }
} )
sound.Add( {
    name = "ArcCW_Kraken.SW_CYCLERO",
    channel = CHAN_WEAPON + 6,
    volume = 1.0,
    level = 140,
    pitch = {95, 105},
    sound = {
        "arccw/kraken/sw_galactic/weapons/tuskencyclerrifle/handling/weap_romeo870_fire_plr_01.ogg",
        "arccw/kraken/sw_galactic/weapons/tuskencyclerrifle/handling/weap_romeo870_fire_plr_01.ogg",
    }
} )
sound.Add( {
    name = "ArcCW_Kraken.SW_DC15",
    channel = CHAN_WEAPON + 6,
    volume = 1.0,
    level = 140,
    pitch = {95, 105},
    sound = {
        "arccw/kraken/sw_galactic/weapons/dc15/sw02_weapons_blasters_dc15_laser_close_var_03_01.wav",
        "arccw/kraken/sw_galactic/weapons/dc15/sw02_weapons_blasters_dc15_laser_close_var_03_02.wav",
        "arccw/kraken/sw_galactic/weapons/dc15/sw02_weapons_blasters_dc15_laser_close_var_03_03.wav",
        "arccw/kraken/sw_galactic/weapons/dc15/sw02_weapons_blasters_dc15_laser_close_var_03_04.wav",
        "arccw/kraken/sw_galactic/weapons/dc15/sw02_weapons_blasters_dc15_laser_close_var_03_05.wav",
        "arccw/kraken/sw_galactic/weapons/dc15/sw02_weapons_blasters_dc15_laser_close_var_03_06.wav",
        "arccw/kraken/sw_galactic/weapons/dc15/sw02_weapons_blasters_dc15_laser_close_var_03_07.wav",
        "arccw/kraken/sw_galactic/weapons/dc15/sw02_weapons_blasters_dc15_laser_close_var_03_08.wav",
        "arccw/kraken/sw_galactic/weapons/dc15/sw02_weapons_blasters_dc15_laser_close_var_03_09.wav",
    }
} )
sound.Add( {
    name = "ArcCW_Kraken.SW_CR2",
    channel = CHAN_WEAPON + 6,
    volume = 1.0,
    level = 140,
    pitch = {95, 105},
    sound = {
        "arccw/kraken/sw_galactic/weapons/cr2/sw02_weapons_blasters_cr2_laser_close_var_01_01.wav",
        "arccw/kraken/sw_galactic/weapons/cr2/sw02_weapons_blasters_cr2_laser_close_var_01_02.wav",
        "arccw/kraken/sw_galactic/weapons/cr2/sw02_weapons_blasters_cr2_laser_close_var_01_03.wav",
        "arccw/kraken/sw_galactic/weapons/cr2/sw02_weapons_blasters_cr2_laser_close_var_01_04.wav",
        "arccw/kraken/sw_galactic/weapons/cr2/sw02_weapons_blasters_cr2_laser_close_var_01_05.wav",
        "arccw/kraken/sw_galactic/weapons/cr2/sw02_weapons_blasters_cr2_laser_close_var_01_06.wav",
        "arccw/kraken/sw_galactic/weapons/cr2/sw02_weapons_blasters_cr2_laser_close_var_01_07.wav",
        "arccw/kraken/sw_galactic/weapons/cr2/sw02_weapons_blasters_cr2_laser_close_var_01_08.wav",
    }
} )
sound.Add( {
    name = "ArcCW_Kraken.SW_NT242",
    channel = CHAN_WEAPON + 6,
    volume = 1.0,
    level = 140,
    pitch = {95, 105},
    sound = {
        "arccw/kraken/sw_galactic/weapons/nt242/sw02_weapons_blasters_nt242_laser_close_var_05_01.wav",
        "arccw/kraken/sw_galactic/weapons/nt242/sw02_weapons_blasters_nt242_laser_close_var_05_02.wav",
        "arccw/kraken/sw_galactic/weapons/nt242/sw02_weapons_blasters_nt242_laser_close_var_05_03.wav",
        "arccw/kraken/sw_galactic/weapons/nt242/sw02_weapons_blasters_nt242_laser_close_var_05_04.wav",
        "arccw/kraken/sw_galactic/weapons/nt242/sw02_weapons_blasters_nt242_laser_close_var_05_05.wav",
        "arccw/kraken/sw_galactic/weapons/nt242/sw02_weapons_blasters_nt242_laser_close_var_05_06.wav",
        "arccw/kraken/sw_galactic/weapons/nt242/sw02_weapons_blasters_nt242_laser_close_var_05_07.wav",
        "arccw/kraken/sw_galactic/weapons/nt242/sw02_weapons_blasters_nt242_laser_close_var_05_08.wav",
    }
} )
sound.Add( {
    name = "ArcCW_Kraken.SW_NT242Distant",
    channel = CHAN_WEAPON + 6,
    volume = 1.0,
    level = 140,
    pitch = {95, 105},
    sound = {
        "arccw/kraken/sw_galactic/weapons/nt242/sw02_weapons_blasters_nt242_laser_distant_var_02_01.wav",
        "arccw/kraken/sw_galactic/weapons/nt242/sw02_weapons_blasters_nt242_laser_distant_var_02_02.wav",
        "arccw/kraken/sw_galactic/weapons/nt242/sw02_weapons_blasters_nt242_laser_distant_var_02_03.wav",
        "arccw/kraken/sw_galactic/weapons/nt242/sw02_weapons_blasters_nt242_laser_distant_var_02_04.wav",
        "arccw/kraken/sw_galactic/weapons/nt242/sw02_weapons_blasters_nt242_laser_distant_var_02_05.wav",
        "arccw/kraken/sw_galactic/weapons/nt242/sw02_weapons_blasters_nt242_laser_distant_var_02_06.wav",
        "arccw/kraken/sw_galactic/weapons/nt242/sw02_weapons_blasters_nt242_laser_distant_var_02_07.wav",
        "arccw/kraken/sw_galactic/weapons/nt242/sw02_weapons_blasters_nt242_laser_distant_var_02_08.wav",
    }
} )
--PATH lua/arccw/shared/arccw_kraken_sw_effects.lua:
return gluapack()()
--PATH lua/arccw/shared/sh_acwcommon.lua:
return gluapack()()
--PATH lua/arccw/shared/sh_attachments.lua:
ArcCW.AttachmentBlacklistTable = ArcCW.AttachmentBlacklistTable or {}

function ArcCW:PlayerCanAttach(ply, wep, attname, slot, detach)
    -- The global variable takes priority over everything
    if !ArcCW.EnableCustomization then return false end

    -- Attach and Detach require a player (usually the owner)
    if !IsValid(ply) then return false end

    -- Spectators taking off your attachments is funny, but also cursed
    if wep:GetOwner() != ply then return false end

    -- Allow hooks to block or force allow attachment usage
    local ret = hook.Run("ArcCW_PlayerCanAttach", ply, wep, attname, slot, detach)

    if ret == nil and engine.ActiveGamemode() == "terrortown" then
        local mode = ArcCW.ConVars["ttt_customizemode"]:GetInt()
        if mode == 1 and !ply.ArcCW_AllowCustomize then return false
        elseif mode == 2 and !ply.ArcCW_AllowCustomize and GetRoundState() == ROUND_ACTIVE then return false
        elseif mode == 3 and !ply.ArcCW_AllowCustomize and !ply:IsActiveTraitor() and !ply:IsActiveDetective() then return false end
    elseif ret == nil and ArcCW.ConVars["enable_customization"]:GetInt() <= 0 then
        return false
    end

    return (ret == nil and true) or ret
end

function ArcCW:GetAttsForSlot(slot, wep, random)
    local ret = {}

    for id, atttbl in pairs(ArcCW.AttachmentTable) do

        if !ArcCW:SlotAcceptsAtt(slot, wep, id) then continue end
        if random and (atttbl.NoRandom or (atttbl.RandomWeight or 1) <= 0) then continue end

        table.insert(ret, id)
    end

    return ret
end

function ArcCW:GetAttList(name, filter)
    if self.AttachmentCachedLists[name] then return self.AttachmentCachedLists[name] end
    self.AttachmentCachedLists[name] = {}
    for k, v in pairs(self.AttachmentTable) do
        local k2, v2 = filter(k, v)
        if k2 then
            self.AttachmentCachedLists[name][k2] = v2
        end
    end
    return self.AttachmentCachedLists[name]
end

local function weighted_random(tbl, amt)
    amt = amt or 1
    local max = 0
    for k, v in pairs(tbl) do max = max + v end
    local ret = {}
    for i = 1, amt do
        local rng = math.random() * max
        for k, v in pairs(tbl) do
            rng = rng - v
            if rng <= 0 then
                ret[k] = (ret[k] or 0) + 1
                break
            end
        end
    end
    return ret
end

function ArcCW:RollRandomAttachment(all, wep, slot)
    for k, v in pairs(self:RollRandomAttachments(1, all, wep, slot)) do return k end
end

function ArcCW:RollRandomAttachments(amt, all, wep, slot)
    if wep == nil then
        -- cache the list results and randomly get one
        local tbl = self:GetAttList("random" .. (all and "_all" or ""), function(k, v)
            if ((!v.Free and !v.InvAtt) or all) and !v.NoRandom and (v.RandomWeight or 1) >= 0 then
                return k, v.RandomWeight or 1
            end
        end)
        return weighted_random(tbl, amt)
    else
        -- can't cache this because it is weapon-dependent
        local tbl = {}
        for id, atttbl in pairs(ArcCW.AttachmentTable) do
            if ((!atttbl.Free and !atttbl.InvAtt) or all) and (atttbl.NoRandom or (atttbl.RandomWeight or 1) <= 0) then continue end
            if !wep:CheckFlags(atttbl.ExcludeFlags, atttbl.RequireFlags) then continue end
            if slot != nil and !ArcCW:SlotAcceptsAtt(slot.Slot, wep, id) then continue end
            tbl[id] = atttbl.RandomWeight or 1
        end
        return weighted_random(tbl, amt)
    end
end

function ArcCW:SlotAcceptsAtt(slot, wep, att)
    local slots = {}

    if isstring(slot) then
        slots[slot] = true
    elseif istable(slot) then
        for _, i in pairs(slot) do
            slots[i] = true
        end
    end

    local atttbl = ArcCW.AttachmentTable[att]
    if !atttbl then return false end

    if atttbl.Hidden or atttbl.Blacklisted or ArcCW.AttachmentBlacklistTable[att] then return false end

    local Owner = wep.GetOwner and wep:GetOwner()
    if (atttbl.NotForNPC or atttbl.NotForNPCs) and Owner and Owner:IsNPC() then
        return false
    end
    if atttbl.AdminOnly and IsValid(Owner) and !(Owner:IsPlayer() and Owner:IsAdmin()) then return false end

    if wep.RejectAttachments and wep.RejectAttachments[att] then return false end

    if isstring(atttbl.Slot) then
        if !slots[atttbl.Slot] then return false end
    elseif istable(atttbl.Slot) then
        local yeah = false

        for _, i in pairs(atttbl.Slot) do
            if slots[i] then
                yeah = true
                break
            end
        end

        if !yeah then
            return false
        end
    end

    if wep and atttbl.Hook_Compatible then
        local compat = atttbl.Hook_Compatible(wep, {slot = slot, att = att})
        if compat == true then
            return true
        elseif compat == false then
            return false
        end
    end

    return true
end

function ArcCW:WeaponAcceptsAtt(wep, att)
    if wep.ArcCW and wep.Attachments then
        local tbl = {}
        for i, v in pairs(wep.Attachments) do
            table.insert(tbl, i)
        end
        return ArcCW:SlotAcceptsAtt(wep, wep, att)
    end
    return false
end

function ArcCW:PlayerGetAtts(ply, att)
    if !IsValid(ply) then return 0 end
    if ArcCW.ConVars["attinv_free"]:GetBool() then return 999 end

    if att == "" then return 999 end

    local atttbl = ArcCW.AttachmentTable[att]

    if !atttbl then return 0 end

    if atttbl.Free then return 999 end

    if !IsValid(ply) then return 0 end

    if !ply:IsAdmin() and atttbl.AdminOnly then
        return 0
    end

    if atttbl.InvAtt then att = atttbl.InvAtt end

    if !ply.ArcCW_AttInv then return 0 end

    if !ply.ArcCW_AttInv[att] then return 0 end

    return ply.ArcCW_AttInv[att]
end

function ArcCW:PlayerGiveAtt(ply, att, amt)
    amt = amt or 1

    if !IsValid(ply) then return end

    if !ply.ArcCW_AttInv then
        ply.ArcCW_AttInv = {}
    end

    local atttbl = ArcCW.AttachmentTable[att]

    if !atttbl then print("Invalid att " .. att) return end
    if atttbl.Free then return end -- You can't give a free attachment, silly
    if atttbl.AdminOnly and !(ply:IsPlayer() and ply:IsAdmin()) then return false end

    if atttbl.InvAtt then att = atttbl.InvAtt end

    if ArcCW.ConVars["attinv_lockmode"]:GetBool() then
        if ply.ArcCW_AttInv[att] == 1 then return end
        ply.ArcCW_AttInv[att] = 1
    else
        ply.ArcCW_AttInv[att] = (ply.ArcCW_AttInv[att] or 0) + amt
    end
end

function ArcCW:PlayerTakeAtt(ply, att, amt)
    amt = amt or 1

    if ArcCW.ConVars["attinv_lockmode"]:GetBool() then return end

    if !IsValid(ply) then return end

    if !ply.ArcCW_AttInv then
        ply.ArcCW_AttInv = {}
    end

    local atttbl = ArcCW.AttachmentTable[att]
    if !atttbl or atttbl.Free then return end

    if atttbl.InvAtt then att = atttbl.InvAtt end

    ply.ArcCW_AttInv[att] = ply.ArcCW_AttInv[att] or 0

    if ply.ArcCW_AttInv[att] < amt then
        return false
    end

    ply.ArcCW_AttInv[att] = ply.ArcCW_AttInv[att] - amt
    if ply.ArcCW_AttInv[att] <= 0 then
        ply.ArcCW_AttInv[att] = nil
    end
    return true
end

if CLIENT then

local function postsetup(wpn)
    if wpn.SetupModel then
        wpn:SetupModel(true)
        if wpn:GetOwner() == LocalPlayer() then
            wpn:SetupModel(false)
        end
        wpn:AdjustAtts()
    else
        timer.Simple(0.1, function()
            postsetup(wpn)
        end)
    end
end

net.Receive("arccw_networkatts", function(len, ply)
   local wpn = net.ReadEntity()
    if !IsValid(wpn) then return end
    if !wpn.ArcCW then return end

    local attnum = net.ReadUInt(8)
    wpn.Attachments = wpn.Attachments or {}
    wpn.SubSlotCount = 0

    for i = 1, attnum do
        local attid = net.ReadUInt(ArcCW.GetBitNecessity())

        wpn.Attachments[i] = wpn.Attachments[i] or {}

        if attid == 0 then
            if !istable(wpn.Attachments[i]) then continue end
            wpn.Attachments[i].Installed = nil
            continue
        end

        local att = ArcCW.AttachmentIDTable[attid]
        wpn.Attachments[i].Installed = att

        if wpn.Attachments[i].SlideAmount then
            wpn.Attachments[i].SlidePos = net.ReadFloat()
        end

        if ArcCW.AttachmentTable[att].ToggleStats then
            wpn.Attachments[i].ToggleNum = net.ReadUInt(8)
        end

        wpn:AddSubSlot(i, att)
    end

    wpn.CertainAboutAtts = true

    postsetup(wpn)
end)

net.Receive("arccw_sendattinv", function(len, ply)
    if !IsValid(LocalPlayer()) then return end -- This might be called before we are valid
    LocalPlayer().ArcCW_AttInv = {}

    local count = net.ReadUInt(32)

    for i = 1, count do
        local attid = net.ReadUInt(ArcCW.GetBitNecessity())
        local acount = net.ReadUInt(32)

        local att = ArcCW.AttachmentIDTable[attid]

        LocalPlayer().ArcCW_AttInv[att] = acount
    end

    -- This function will not exist until initialized (by having an ArcCW weapon exist)!
    -- It also obviously needs menu2 open
    if ArcCW.InvHUD_FormAttachmentSelect and IsValid(ArcCW.InvHUD) and IsValid(ArcCW.InvHUD_Menu2) then
        ArcCW.InvHUD_FormAttachmentSelect()
    end
end)

net.Receive("arccw_sendatthp", function(len, ply)
    local wpn = LocalPlayer():GetActiveWeapon()

    while net.ReadBool() do
        local slot = net.ReadUInt(8)
        local hp = net.ReadFloat()

        wpn.Attachments[slot].HP = hp
    end
end)

elseif SERVER then

hook.Add("PlayerDeath", "ArcCW_DeathAttInv", function(ply)
    ply.ArcCW_AttInv = ply.ArcCW_AttInv or {}
    if !table.IsEmpty(ply.ArcCW_AttInv)
            and ArcCW.ConVars["attinv_loseondie"]:GetInt() >= 2
            and !ArcCW.ConVars["attinv_free"]:GetBool() then
        local boxEnt = ents.Create("arccw_att_dropped")
        boxEnt:SetPos(ply:GetPos() + Vector(0, 0, 4))
        boxEnt.GiveAttachments = ply.ArcCW_AttInv
        boxEnt:Spawn()
        boxEnt:SetNWString("boxname", ply:GetName() .. "'s Death Box")
        local count = 0
        for i, v in pairs(boxEnt.GiveAttachments) do count = count + v end
        boxEnt:SetNWInt("boxcount", count)
    end
end)

hook.Add("PlayerSpawn", "ArcCW_SpawnAttInv", function(ply, trans)
    if trans then return end

    if ArcCW.ConVars["attinv_loseondie"]:GetInt() >= 1 then
        ply.ArcCW_AttInv = {}
    end
    local amt = ArcCW.ConVars["attinv_giveonspawn"]:GetInt()
    if amt > 0 then
        local giv = ArcCW:RollRandomAttachments(amt)
        for k, v in pairs(giv) do
            ArcCW:PlayerGiveAtt(ply, k, v)
        end
    end
    ArcCW:PlayerSendAttInv(ply)
end)

net.Receive("arccw_rqwpnnet", function(len, ply)
    local wpn = net.ReadEntity()

    if !wpn.ArcCW then return end

    wpn:RecalcAllBuffs()
    wpn:NetworkWeapon(ply)
end)

net.Receive("arccw_slidepos", function(len, ply)
    local wpn = ply:GetActiveWeapon()

    local slot = net.ReadUInt(8)
    local pos = net.ReadFloat()

    if !wpn.ArcCW then return end

    if !wpn.Attachments[slot] then return end

    wpn.Attachments[slot].SlidePos = pos
end)


net.Receive("arccw_togglenum", function(len, ply)
    local wpn = ply:GetActiveWeapon()

    local slot = net.ReadUInt(8)
    local num = net.ReadUInt(8)

    if !wpn.ArcCW then return end

    if !wpn.Attachments[slot] then return end

    wpn.Attachments[slot].ToggleNum = num

    wpn:AdjustAtts()
    wpn:NetworkWeapon()
    wpn:SetupModel(false)
    wpn:SetupModel(true)
end)


net.Receive("arccw_asktoattach", function(len, ply)
    local wpn = ply:GetActiveWeapon()

    local slot = net.ReadUInt(8)
    local attid = net.ReadUInt(24)

    local att = ArcCW.AttachmentIDTable[attid]

    if !wpn.ArcCW then return end
    if !wpn.Attachments[slot] then return end
    if !att then return end

    wpn:Attach(slot, att)
end)

net.Receive("arccw_asktodetach", function(len, ply)
    local wpn = ply:GetActiveWeapon()

    local slot = net.ReadUInt(8)

    if !wpn.ArcCW then return end
    if !wpn.Attachments[slot] then return end

    wpn:Detach(slot)
end)

net.Receive("arccw_asktodrop", function(len, ply)

    local attid = net.ReadUInt(24)
    local att = ArcCW.AttachmentIDTable[attid]

    if ArcCW.ConVars["attinv_free"]:GetBool() then return end
    if ArcCW.ConVars["attinv_lockmode"]:GetBool() then return end
    if ArcCW.ConVars["enable_customization"]:GetInt() < 0 then return end
    if !ArcCW.ConVars["enable_dropping"]:GetBool() then return end

    if !att then return end

    local atttbl = ArcCW.AttachmentTable[att]

    if !atttbl then return end
    if atttbl.Free then return end
    if ArcCW:PlayerGetAtts(ply, att) < 1 then return end

    -- better to do it like this in case you don't want to generate the attachment entities
    local ent = ents.Create("arccw_att_base")
    if !IsValid(ent) then return end
    ent:SetPos(ply:EyePos() + ply:EyeAngles():Forward() * 32)

    ent:SetNWInt("attid", attid)

    ent.GiveAttachments = {[att] = 1}
    ent.Model = atttbl.DroppedModel or atttbl.Model or "models/Items/BoxSRounds.mdl"
    ent.Icon = atttbl.Icon
    ent.PrintName = atttbl.PrintName or att

    ent:Spawn()
    timer.Simple(0, function()
        local phys = ent:GetPhysicsObject()
        if phys:IsValid() then
            phys:SetVelocity(ply:EyeAngles():Forward() * 32 * math.max(phys:GetMass(), 4))
        end
    end)
    ArcCW:PlayerTakeAtt(ply, att, 1)
    ArcCW:PlayerSendAttInv(ply)
end)

if SERVER then
    net.Receive("arccw_applypreset", function(len, ply)
        local wpn = net.ReadEntity()

        if wpn:GetOwner() != ply or !wpn.ArcCW then return end
        if ply.ArcCW_DisableAutosave or ply.ArcCW_Sandbox_RandomAtts then
            ply.ArcCW_Sandbox_RandomAtts = nil
            return
        end

        for k, v in pairs(wpn.Attachments) do
            wpn:Detach(k, true, true)
        end

        wpn.Attachments.BaseClass = nil -- AGHHHHHHHHHH
        for k, v in SortedPairs(wpn.Attachments) do
            local attid = net.ReadUInt(ArcCW.GetBitNecessity())

            local attname = ArcCW.AttachmentIDTable[attid or 0] or ""
            local atttbl = ArcCW.AttachmentTable[attname]
            if !atttbl then continue end

            wpn:Attach(k, attname, true, true)

            if net.ReadBool() then
                v.SlidePos = net.ReadFloat()
                v.SlidePos = atttbl.MountPositionOverride or v.SlidePos
            else
                v.SlidePos = 0.5
            end

            if atttbl.ToggleStats then
                v.ToggleNum = math.Clamp(net.ReadUInt(8), 1, #atttbl.ToggleStats)
            else
                v.ToggleNum = 1
            end
        end

        wpn:AdjustAtts()
        wpn:RefreshBGs()

        if ply.ArcCW_Sandbox_FirstSpawn then
            -- Curiously, RestoreAmmo has a sync delay only in singleplayer
            ply.ArcCW_Sandbox_FirstSpawn = nil
            wpn:RestoreAmmo()
        end

        wpn:NetworkWeapon()
        wpn:SetupModel(false)
        wpn:SetupModel(true)

        net.Start("arccw_applypreset")
            net.WriteEntity(wpn)
        net.Send(ply)
    end)
else
    net.Receive("arccw_applypreset", function()
        local wpn = net.ReadEntity()
        if !IsValid(wpn) then return end
        wpn:SavePreset("autosave")
    end)
end

function ArcCW:PlayerSendAttInv(ply)
    if ArcCW.ConVars["attinv_free"]:GetBool() then return end

    if !IsValid(ply) then return end

    if !ply.ArcCW_AttInv then return end

    net.Start("arccw_sendattinv")

    net.WriteUInt(table.Count(ply.ArcCW_AttInv), 32)

    for att, count in pairs(ply.ArcCW_AttInv) do
        local atttbl = ArcCW.AttachmentTable[att]
        local attid = atttbl.ID
        net.WriteUInt(attid, ArcCW.GetBitNecessity())
        net.WriteUInt(count, 32)
    end

    net.Send(ply)
end

end

--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/15a_barrel_longrange.lua:
return gluapack()()
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/arccw/shared/attachments/a180_grip.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/ammo_destabilization_mod.lua:
att.PrintName = "Destablized Mod"
att.Icon = Material("entities/acwatt_go_ammo_blanks.png", "mips smooth")
att.Description = "Destablized rounds"
att.Desc_Pros = {
}
att.Desc_Cons = {
}

att.AutoStats = true
att.Slot = "ammo"
att.Reload = 1
att.Mult_DamageMin = 0.3
att.Mult_Recoil = 1.15
att.Mult_SightTime = 1
att.Mult_RPM = 2

att.NotForNPCs = true
att.Mult_Damage = 0.6
att.Mult_MuzzleVelocity = 1

att.Override_Tracer = "tfa_tracer_green" -- tracer effect name
att.Override_MuzzleEffect = "wpn_muzzleflash_dc17_green"
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/ammo_explosive_mod.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/ammo_gl_stun.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/ammo_hailfire.lua:
return gluapack()()
--PATH lua/arccw/shared/attachments/charm_dingus.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/gl_dioxis.lua:
att.PrintName = "Grenade Launcher (Dioxis)"
att.Icon = Material("interfaz/armas/sw_stimpack.png")
att.Description = "Grenade Launcher module. Replaces a charged tibanna cartridge with a grenade launcher one."
att.Desc_Pros = {
    "pro.ubgl",
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
    "info.toggleubgl"
}
att.AutoStats = true
att.Slot = "ubgl_module"

att.SortOrder = 1738

att.MountPositionOverride = 0

att.UBGL = true
att.UBGL_BaseAnims = false
att.UBGL_PrintName = "Grenade Launcher (Dioxis)"
att.UBGL_Automatic = false
att.UBGL_MuzzleEffect = "swrp_muzzleflash_blue"
att.UBGL_ClipSize = 1
att.UBGL_Ammo = "Grenade"
att.UBGL_RPM = 1200
att.UBGL_Recoil = 2
att.UBGL_Capacity = 1

att.AddSuffix = "Grenadier"

att.Hook_ShouldNotSight = function(wep)
    return wep:GetInUBGL()
end

local function Ammo(wep)
    return wep.Owner:GetAmmoCount("Grenade")
end

att.UBGL_Fire = function(wep, ubgl)
    if wep:Clip2() <= 0 then return end

    wep:PlayAnimation("Reload", 1, true, nil, nil, nil, true)

    wep:FireRocket("tfa_battlefront_ent_nade_poison", 1000)

    if wep.MW2_M203isGP25 then
        wep:EmitSound("armas3/gl_fire_1.wav", 100)
    else
        wep:EmitSound("armas3/gl_fire_4.wav", 100)
    end

    wep:SetClip2(wep:Clip2() - 1)

    wep:DoEffects()
end

att.UBGL_Reload = function(wep, ubgl)
    if wep:Clip2() >= 1 then return end

    if Ammo(wep) <= 0 then return end

    wep:PlayAnimation("reload", 1, true, nil, nil, nil, true)
    wep:SetReloading(CurTime() + wep:GetAnimKeyTime("reload"))

    local reserve = Ammo(wep)

    reserve = reserve + wep:Clip2()

    local clip = 1

    local load = math.Clamp(clip, 0, reserve)

    wep.Owner:SetAmmo(reserve - load, "Grenade")

    wep:SetClip2(load)
end

att.Mult_SightTime = 1.25
-- att.Mult_SpeedMult = 0.8
att.Mult_SightedSpeedMult = 0.85
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/arccw/shared/attachments/mode_g125.lua:
att.PrintName = "Tri-barrel Launcher"
att.Icon = Material("entities/kraken/g125_mode.png")
att.Description = "Reconfigure the blaster to fire from the tri-barreled projectile launcher at the expense of increased heat buildup."

att.Slot = "g125_mode"

att.Override_MuzzleEffect = "nio_charge"
att.Override_ShootEntity = "g125_projectile"
att.Override_Delay = 60 / 700
att.MuzzleFlashColor = Color(0, 250, 0)
att.Override_HeatCapacity = 3

att.Mult_Recoil = 1.3
att.Mult_RecoilSide = 1.3
att.Mult_VisualRecoilMult = 1.3

att.Override_InfiniteAmmo = true
att.Override_BottomlessClip = true

att.Desc_Pros = {}
att.Desc_Cons = {}

att.NotForNPCs = true
att.AutoStats = true

att.Hook_GetShootSound = function(wep, sound)
    return false
end
att.Hook_AddShootSound = function(wep, data)
    wep:MyEmitSound("kraken/explosives/g125/g125.wav", data.volume, data.pitch, 1, CHAN_WEAPON - 1)
end
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/arccw/shared/attachments/mode_le.lua:
return gluapack()()
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/arccw/shared/attachments/mode_le.lua:
att.PrintName = "Long Engagements Mode"
att.Icon = Material("entities/arccw/kraken/republic-arsenal/atts/le_mode.png")
att.Description = "Set the weapon mode to long range. It will greatly improve its performance at long range, but it loses proficiency at short range."

att.Slot = "sw_mode_rifle"

att.Override_MuzzleEffect = "blaster_muzzle_red"
att.Override_Tracer = "tracer_red"
att.Override_DamageType = DMG_BLAST
att.Override_AmmoPerShot = 5
att.Mult_RPM = 1.5

att.Mult_DamageMin = 0.4
att.Mult_Recoil = 2
att.Mult_RecoilSide = 1.2
att.Mult_VisualRecoilMult = 1.2

att.MuzzleFlashColor = Color(250, 0, 0)

att.Desc_Pros = {}
att.Desc_Cons = {}

att.NotForNPCs = true
att.AutoStats = true

--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/arccw/shared/attachments/mode_scatter.lua:
att.PrintName = "Blaster Scatter Mode"
att.Icon = Material("entities/arccw/kraken/republic-arsenal/atts/scatter.png")
att.Description = "Set the weapon mode to Scatter. Turns your weapon into a shotgun."

att.Slot = "sw_mode_universal"

att.Desc_Pros = {}
att.Desc_Cons = {}

att.Override_DamageType = DMG_BUCKSHOT
att.Add_Num = 5
att.Mult_Range = 1.25

att.Mult_AccuracyMOA = 20
att.Mult_HipDispersion = 2
att.Mult_SightsDispersion = 2

att.Mult_Damage = 0.9
att.Mult_DamageMin = 0.9
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/arccw/shared/attachments/mode_supersonic.lua:
return gluapack()()
--PATH lua/arccw/shared/attachments/muzzle_dc15a_mod.lua:
att.PrintName = "DC15-A Muzzle Mod"
att.Description = "Bulky and heavy, but provides better ballistic performance.\n\n\"By the time you figured it out, it would be too late.\""

att.AutoStats = true
att.Slot = {"muzzle"}

att.SortOrder = 150

att.Model = "models/atts/dc15a_muzzle.mdl"
att.ModelOffset = Vector(0, 0, 0)
att.OffsetAng = Angle(0, 0, 0)

att.Silencer = false
att.IsMuzzleDevice = false

att.Mult_ShootPitch = 1.1
att.Mult_ShootVol = 1


att.Mult_RecoilSide = 0.75

att.Mult_ShootSpeedMult = 1.05
att.Mult_Sway = 1

att.Add_BarrelLength = 6
att.Mult_SightTime = 1.1
att.Mult_HipDispersion = 1.1
att.Mult_Range = 1
--PATH lua/arccw/shared/attachments/muzzle_heavy_dc15a_mod.lua:
att.PrintName = "Heavy DC15-A Muzzle Mod"
att.Description = "Bulky and heavy, but provides better ballistic performance.\n\n\"By the time you figured it out, it would be too late.\""

att.AutoStats = true
att.Slot = {"muzzle"}

att.SortOrder = 150

att.Model = "models/atts/dlt19_heavyrifle_muzzle1.mdl"
att.ModelOffset = Vector(0, 0, 0)
att.OffsetAng = Angle(0, 0, 0)

att.Silencer = false
att.IsMuzzleDevice = false

att.Mult_ShootPitch = 1.1
att.Mult_ShootVol = 1


att.Mult_RecoilSide = 0.75

att.Mult_ShootSpeedMult = 1.05
att.Mult_Sway = 1

att.Add_BarrelLength = 6
att.Mult_SightTime = 1.1
att.Mult_HipDispersion = 1.1
att.Mult_Range = 1
--PATH lua/arccw/shared/attachments/optic_a280cfe_scope.lua:
att.PrintName = "A280-CFE Magnifying Optic"
att.Icon = Material("entities/dlt19x_icon.png")
att.Description = "High-magnification sniper rifle scope for long range combat."

att.SortOrder = 9

att.Desc_Pros = {
    "autostat.holosight",
    "autostat.zoom",
}
att.Desc_Cons = {
}
att.AutoStats = true
att.Slot = "optic"

att.Model = "models/atts/a280cfe_default_scope2.mdl"
att.ModelOffset = Vector(0, 0, -0)
att.AdditionalSights = {
    {
        Pos = Vector(0, 9, -1.03),
        Ang = Angle(0, 0, 0),
        Magnification = 1.5,
        ScrollFunc = ArcCW.SCROLL_ZOOM,
        ZoomLevels = 10,
        ZoomSound = "weapons/arccw/fiveseven/fiveseven_slideback.wav",
        IgnoreExtra = true
    }
}

att.ScopeGlint = false

att.Holosight = true
att.HolosightReticle = Material("scope/star_ret.png", "smooth")
att.HolosightNoFlare = true
att.HolosightSize = 7
att.HolosightBone = "holosight"
att.HolosightPiece = "models/atts/a280cfe_default_scope2_hsp.mdl"
att.Colorable = false

att.HolosightMagnification = 0
att.HolosightBlackbox = true

att.HolosightConstDist = 44

att.HolosightMagnificationMin = 2
att.HolosightMagnificationMax = 3
att.HoloSightColorable = false

att.Mult_SightTime = 1.35
att.Mult_SightedSpeedMult = 0.8
att.Mult_SpeedMult = 0.9
--PATH lua/arccw/shared/attachments/optic_dlt19_scope.lua:
att.PrintName = "DLT-19x Magnifying Optic"
att.Icon = Material("entities/dlt19x_icon.png")
att.Description = "High-magnification sniper rifle scope for long range combat."

att.SortOrder = 9

att.Desc_Pros = {
    "autostat.holosight",
    "autostat.zoom",
}
att.Desc_Cons = {
}
att.AutoStats = true
att.Slot = "optic"

att.Model = "models/weapons/arccw/DLT19X_scope.mdl"
att.ModelOffset = Vector(0, 0, -0.1)
att.AdditionalSights = {
    {
        Pos = Vector(0, 14, -1.6),
        Ang = Angle(0, 0, 0),
        Magnification = 1.5,
        ScrollFunc = ArcCW.SCROLL_ZOOM,
        ZoomLevels = 10,
        ZoomSound = "weapons/arccw/fiveseven/fiveseven_slideback.wav",
        IgnoreExtra = true
    }
}

att.ScopeGlint = false

att.Holosight = true
att.HolosightReticle = Material("scope/star_ret.png", "smooth")
att.HolosightNoFlare = true
att.HolosightSize = 8.5
att.HolosightBone = "holosight"
att.HolosightPiece = "models/weapons/arccw/DLT19X_scope_HSP.mdl"
att.Colorable = false

att.HolosightMagnification = 0
att.HolosightBlackbox = true

att.HolosightConstDist = 64

att.HolosightMagnificationMin = 2
att.HolosightMagnificationMax = 3
att.HoloSightColorable = false

att.Mult_SightTime = 1.35
att.Mult_SightedSpeedMult = 0.8
att.Mult_SpeedMult = 0.9
--PATH lua/arccw/shared/attachments/optic_ee4_scope.lua:
return gluapack()()
--PATH lua/arccw/shared/attachments/optic_iqa11_scope.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/perk_basic.lua:
return gluapack()()
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/arccw/shared/attachments/perk_clonearf.lua:
att.PrintName = "ARF Trooper Training"

att.Icon = Material("entities/arccw/kraken/republic-arsenal/atts/arftrooper.png")
att.Description = [[Unrivaled advanced reconnaissance troops. Their skills in difficult terrain and sniping or precision rifles make them unrivaled marksmen and an imminent threat.]]
att.Desc_Pros = {}
att.Desc_Cons = {}
att.Desc_Neutrals = {}
att.Slot = {"perk"}

att.AutoStats = true
att.NotForNPC = true

att.Mult_AccuracyMOA = 0.95
att.Mult_HipDispersion = 1.15
att.Mult_MoveDispersion = 1.15

att.Mult_SpeedMult = 1.20
att.Mult_SightedSpeedMult = 0.75
att.Mult_ReloadTime = 0.85
att.Mult_Recoil = 1.05
att.Mult_RecoilSide = 1.05

att.Mult_SightsDispersion = 0.5
att.Mult_Range = 1.5
att.Mult_Damage = 1.1
att.Mult_DamageMin = 0.5

--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/arccw/shared/attachments/perk_clonetrooper.lua:
att.PrintName = "Clone Trooper Training"

att.Icon = Material("entities/arccw/kraken/republic-arsenal/atts/clone.png")
att.Description = [[Clone troopers, also known as Republic troopers, Republic troops, Republic soldiers, Regs, and nicknamed the "Boys in White," were highly trained soldiers in the Grand Army of the Republic. Representing the future of galactic warfare, clones were designed to be far superior to battle droids.]]
att.Desc_Pros = {}
att.Desc_Cons = {}
att.Desc_Neutrals = {}
att.Slot = {"perk"}

att.AutoStats = true
att.NotForNPC = true

att.Mult_AccuracyMOA = 0.95
att.Mult_HipDispersion = 0.95
att.Mult_MoveDispersion = 0.95

att.Mult_DrawTime = 0.9
att.Mult_HolsterTime = 0.9
att.Mult_SightTime = 0.9

att.Mult_SpeedMult = 1.05
att.Mult_SightedSpeedMult = 1.1

att.Mult_ReloadTime = 0.95

att.Mult_Recoil = 0.85
att.Mult_RecoilSide = 0.85
att.Mult_VisualRecoilMult = 0.8
att.Mult_Sway = 0.9

--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/perk_underload.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/special_explosive.lua:
att.PrintName = "Explosive Rounds"
att.Icon = Material("interfaz/armas/sw_demolish.png")
att.Description = "Tibanna compression with explosive results"
att.Desc_Pros = {
}
att.Desc_Cons = {
}

att.AutoStats = true
att.Slot = "special_ammo"

att.Mult_ShootPitch = 0.6
att.Mult_ShootVol = 1.7
att.Mult_Penetration = 1.1
att.Mult_Damage = 4
att.Mult_Range = 0.7

att.Override_DamageType = DMG_BURN

att.Override_Tracer = "tracer_yellow"

att.Hook_GetCapacity = function(wep, cap)
    return math.Clamp(math.Round(wep.RegularClipSize * 1), 1, 12)
end

att.Hook_BulletHit = function(wep, data)
    local ent = data.tr.Entity
    util.BlastDamage(wep, wep:GetOwner(), data.tr.HitPos, 96, wep:GetDamage(data.range))
    if ent:IsValid() and ent:GetClass() == "npc_helicopter" then
        data.dmgtype = DMG_AIRBOAT
    end
end
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/sw_grip_e11.lua:
att.PrintName = "SW-E11 Grip"
att.AbbrevName = "E11 Grip"
att.SortOrder = 100
att.Icon = nil
att.Description = "Better control."
att.Desc_Pros = {}
att.Desc_Cons = {}

att.Desc_Neutrals = {}
att.Slot = "e11_grip"

att.Model = "models/arccw/sw_battlefront/props/e11_grip/e11_grip.mdl"
att.DroppedModel = "models/Items/BoxSRounds.mdl"
att.OffsetAng = Angle(-90, 0, 0)
att.ModelOffset = Vector(0.5, -3, -0.1)
att.ModelScale = Vector(1, 1, 1)

att.AutoStats = true

att.HideIfBlocked = true

att.Mult_SightTime = 0.95
att.Mult_Sway = 0.85
att.Mult_SpeedMult = 0.95

att.Mult_DrawTime = 0.85
att.Mult_HolsterTime = 0.9

att.Mult_HipDispersion = 0.85

--[[]
att.Override_Jamming = true
att.Override_HeatCapacity = 200
att.Override_HeatDissipation = 4
att.Override_HeatDelayTime = 3
]]

--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/sw_mag_dc15a_60mag.lua:
att.PrintName = "SW-Extended Magazine"
att.AbbrevName = "60-Round Mag"
att.SortOrder = 100
att.Icon = nil
att.Description = "Extended magazine, ideal for additional fire support. Slight Bulky construction and additional ammo capacity increases weight, making the weapon difficult to handle"
att.Desc_Pros = {}
att.Desc_Cons = {}

att.Desc_Neutrals = {}
att.Slot = "dc15a_magazine"

att.Model = "models/weapons/arccw/atts/magazine/a280_cell_mod.mdl"
att.DroppedModel = "models/Items/BoxSRounds.mdl"
att.OffsetAng = Angle(0, -90, 90)
att.ModelOffset = Vector(-0.9, -0.3, -2.8)
att.ModelScale = Vector(1.5, 1.5, 1.5)

att.AutoStats = true

att.HideIfBlocked = true

att.Override_ClipSize = 60

att.Mult_SightTime = 1.05
att.Mult_Sway = 2.1

att.Mult_SpeedMult = 0.95
att.Mult_ShootSpeedMult = 0.95

att.Mult_DrawTime = 1.25
att.Mult_HolsterTime = 1.25

att.Mult_HipDispersion = 1.3

--[[]
att.Override_Jamming = true
att.Override_HeatCapacity = 200
att.Override_HeatDissipation = 4
att.Override_HeatDelayTime = 3
]]

--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/sw_stock_e11b.lua:
att.PrintName = "SW-Stock E11b"
att.AbbrevName = "E11-b Stock"
att.SortOrder = 100
att.Icon = nil
att.Description = "Better control."
att.Desc_Pros = {}
att.Desc_Cons = {}

att.Desc_Neutrals = {}
att.Slot = "e11b_stock"

att.Model = "models/arccw/sw_battlefront/props/e11b_stock/e11b_stock.mdl"
att.DroppedModel = "models/Items/BoxSRounds.mdl"
att.OffsetAng = Angle(0, 0, 0)
att.ModelOffset = Vector(-12.5, 0, -1)
att.ModelScale = Vector(1, 1, 1)

att.AutoStats = true

att.HideIfBlocked = true
att.Mult_Damage = 1.15

att.Override_ClipSize = 40

att.Mult_SightTime = 1.05
att.Mult_Sway = 1.1
att.Mult_RPM = 0.85

att.Mult_SpeedMult = 0.95

att.Mult_DrawTime = 1.1
att.Mult_HolsterTime = 1.05

att.Mult_HipDispersion = 1.05

--[[]
att.Override_Jamming = true
att.Override_HeatCapacity = 200
att.Override_HeatDissipation = 4
att.Override_HeatDelayTime = 3
]]

--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/arccw/shared/attachments/sw_stun10.lua:
return gluapack()()
--PATH lua/arccw/client/cl_languages/en.lua:
-- These strings are loaded into GMod's language library instead of our custom one.
-- They are only to be used in the options menu.
L = {}

-- Generic
L["arccw.adminonly"]                      = "These options require admin privileges to change. They are automatically networked in multiplayer games."
L["arccw.clientcfg"]                      = "All options in this menu can be customized by players, and do not need admin privileges."
-- Menus
L["arccw.menus.hud"]                      = "HUD"
L["arccw.menus.client"]                   = "Client"
L["arccw.menus.vmodel"]                   = "Viewmodel"
L["arccw.menus.perf"]                     = "Performance"
L["arccw.menus.server"]                   = "Server"
L["arccw.menus.mults"]                    = "Modifiers"
L["arccw.menus.npcs"]                     = "NPCs"
L["arccw.menus.atts"]                     = "Attachments"
L["arccw.menus.ammo"]                     = "Ammo"
L["arccw.menus.dev"]                      = "Developer"
L["arccw.menus.xhair"]                    = "Crosshair"
L["arccw.menus.bullet"]                   = "Bullet Physics"
L["arccw.menus.scopes"]                   = "Scopes"
L["arccw.bullet_help"]                    = "\nEnabling physical bullets in multiplayer may reduce the reliability of hit detection."
-- ArcCW_Options_Ammo
L["arccw.cvar.ammo_detonationmode"]       = "Ammo Detonation"
L["arccw.cvar.ammo_detonationmode.desc"]  = "-1 - don't explode\n 0 - simple explosion\n 1 - fragmentation\n 2 - frag + burning"
L["arccw.cvar.ammo_autopickup"]           = "Auto Pickup"
L["arccw.cvar.ammo_largetrigger"]         = "Large Pickup Trigger"
L["arccw.cvar.ammo_rareskin"]             = "Rare Skin Chance"
L["arccw.cvar.ammo_chaindet"]             = "Chain Detonation"
L["arccw.cvar.mult_ammohealth"]           = "Ammo Health (-1 for indestructible)"
L["arccw.cvar.mult_ammoamount"]           = "Ammo Amount"
-- ArcCW_Options_HUD
L["arccw.cvar.hud_showhealth"]            = "Show Health"
L["arccw.cvar.hud_showhealth.desc"]       = "Draw a custom health & armor counter."
L["arccw.cvar.hud_showammo"]              = "Show Ammo"
L["arccw.cvar.hud_showammo.desc"]         = "Custom ammo counter with firemode info and weapon name."
L["arccw.3d2d"]                           = "\n3D2D HUD" -- Obsolete
L["arccw.cvar.hud_3dfun"]                 = "Use 3D2D Ammo HUD"
L["arccw.cvar.hud_3dfun.desc"]            = "Use a 3D2D ammo counter."
L["arccw.cvar.hud_3dfun_decay"]           = "HUD Decay Time"
L["arccw.cvar.hud_3dfun_decay.desc"]      = "Time until the HUD starts fading away.\nSet to 0 to always stay visible."
L["arccw.cvar.hud_minimal"]               = "Allow Backup Ammo HUD"
L["arccw.cvar.hud_minimal.desc"]          = "If we can't draw our own HUD, use a minimal one."
L["arccw.cvar.hud_forceshow"]             = "Force HUD On"
L["arccw.cvar.hud_forceshow.desc"]        = "Don't play by the rules and draw our HUD anyways."
L["arccw.cvar.hudpos_deadzone_x"]         = "Deadzone X"
L["arccw.cvar.hudpos_deadzone_y"]         = "Deadzone Y"
L["arccw.cvar.hudpos_deadzone.desc"]      = "Use ArcCW on your HDTV!"
L["arccw.cvar.hudpos_size"]               = "HUD and Font Size"
L["arccw.cvar.hudpos_size.desc"]          = "Custom HUD scaling."
-- ArcCW_Options_Bullet
L["arccw.cvar.bullet_enable"]             = "Physical Bullets"
L["arccw.cvar.enable_penetration"]        = "Enable Penetration"
L["arccw.cvar.enable_ricochet"]           = "Enable Ricochet"
L["arccw.cvar.bullet_gravity"]            = "Gravity"
L["arccw.cvar.bullet_drag"]               = "Drag"
L["arccw.cvar.bullet_lifetime"]           = "Despawn Time"
L["arccw.cvar.bullet_velocity"]           = "Multiply Velocity"
L["arccw.cvar.bullet_imaginary"]          = "Imaginary Bullets"
L["arccw.cvar.bullet_imaginary.desc"]     = "Bullets will appear to continue to travel through the 3D skybox."
-- ArcCW_Options_Client
L["arccw.cvar.automaticreload"]           = "Automatic Reload"
L["arccw.cvar.automaticreload.desc"]      = "Automatically reload when your clip is empty."
L["arccw.cvar.toggleads"]                 = "Toggle Aim"
L["arccw.cvar.altfcgkey"]                 = "USE + RELOAD Toggles Firemode"
L["arccw.cvar.altubglkey"]                = "USE + RMB Toggles Underbarrel"
L["arccw.cvar.altsafety"]                 = "Hold Walk to Toggle Safety"
L["arccw.cvar.altlaserkey"]               = "E+WALK To Toggle Laser (Default WALK+E)"
L["arccw.cvar.autosave"]                  = "Autosave Attachments"
L["arccw.cvar.autosave.desc"]             = "Attempt to re-equip the last equipped set of attachments on weapon pickup."
L["arccw.cvar.embracetradition"]          = "Classic Customization HUD"
L["arccw.cvar.embracetradition.desc"]     = "Use the classic bulky customization HUD. Embrace tradition. Good on 4:3."
L["arccw.cvar.glare"]                     = "Scope Glare"
L["arccw.cvar.glare.desc"]                = "Glare visible on your scope lens when aiming."
L["arccw.cvar.shake"]                     = "Screen Shake"
L["arccw.cvar.shakevm"]                   = "Viewmodel Shake"
L["arccw.cvar.shake_info"]                = "Aggressive snap when you shoot a weapon."
L["arccw.cvar.2d3d"]                      = "Draw Help Text"
L["arccw.cvar.2d3d_info"]                 = "Draw name of weapons, ammo and attachments on the ground."
L["arccw.cvar.attinv_hideunowned"]        = "Hide Unowned Attachments"
L["arccw.cvar.attinv_darkunowned"]        = "Grey Out Unowned Attachments"
L["arccw.cvar.attinv_onlyinspect"]        = "Hide Customization UI"
L["arccw.cvar.attinv_simpleproscons"]     = "Simple Pros And Cons"
L["arccw.cvar.attinv_closeonhurt"]        = "Close menu on damage taken"
L["arccw.cvar.language"]                  = "Language"
L["arccw.cvar.language_info"]             = "Override the language. Leave blank for gmod_language."
L["arccw.cvar.font"]                      = "Font"
L["arccw.cvar.font_info"]                 = "Override the font. Leave blank for default."
-- ArcCW_Options_Perf
L["arccw.performance"]                    = "The options below may change performance."
L["arccw.cvar.cheapscopes"]               = "Cheap Scopes"
L["arccw.cvar.cheapscopes.desc"]          = "A cheaper PIP scope implementation like in modern games. Saves a significant amount of performance on big maps. \nYou can configure it in 'Scopes' tab."
L["arccw.cvar.cheapscopesv2_ratio"]       = "FOV Boost"
L["arccw.cvar.cheapscopesv2_ratio.desc"]  = "Cheap Scope field of view boost ratio. 0 is full FOV and full quality scope, 1 is default FOV with low quality scope."
L["arccw.cvar.cheapscopesv2.desc"]        = "A cheaper PIP scope implementation like in modern games."
L["arccw.cvar.scopepp"]                   = "Scope chromatic aberration"
L["arccw.cvar.thermalpp"]                 = "Thermal scope post-processing effects"
L["arccw.cvar.scopepp_refract"]           = "Scope lense refract effect (experimental)"
L["arccw.cvar.scopepp_refract_ratio"]     = "Refract ratio"
--["arccw.cvar.flatscopes"]                = "Flat Scopes"
--L["arccw.cvar.flatscopes.desc"]           = "For the ultimate performance gain.\nUse a traditional-style scope implementation that's not very impressive, but actually saves performance relative to even being unscoped."
L["arccw.cvar.muzzleeffects"]             = "Enable World Muzzle Effects"
L["arccw.cvar.fastmuzzles"]               = "Low Performance Muzzle Effects"
L["arccw.cvar.fasttracers"]               = "Low Performance Tracer Effects"
L["arccw.cvar.shelleffects"]              = "Enable World Case Effects"
L["arccw.cvar.att_showothers"]            = "Show Others' Attachments"
L["arccw.cvar.shelltime"]                 = "Case Lifetime"
L["arccw.cvar.blur"]                      = "Customization Blur"
L["arccw.cvar.blur_toytown"]              = "Aim Blur"
L["arccw.cvar.visibility"]                = "Worldmodel Visibility"
L["arccw.cvar.visibility.desc"]           = "Attachments will not render past this distance. -1 for always render."
-- ArcCW_Options_Viewmodel
L["arccw.cvar.vm_coolsway"]               = "Custom Swaying"
L["arccw.cvar.vm_coolview"]               = "Custom Camera Movement"
L["arccw.cvar.drawbarrel"]                = "Draw barrel in RT scopes (experimental)"
L["arccw.cvar.vm_addads"]                 = "Viewmodel FOV in ADS"
L["arccw.cvar.vm_right"]                  = "Viewmodel Right"
L["arccw.cvar.vm_forward"]                = "Viewmodel Forward"
L["arccw.cvar.vm_up"]                     = "Viewmodel Up"
L["arccw.cvar.vm_pitch"]                  = "Viewmodel Pitch"
L["arccw.cvar.vm_yaw"]                    = "Viewmodel Yaw"
L["arccw.cvar.vm_roll"]                   = "Viewmodel Roll"
L["arccw.cvar.vm_fov"]                    = "Viewmodel FOV"
L["arccw.cvar.vm_offsetwarn"]             = "Warning! Viewmodel offset settings may cause clipping or other undesired effects!"
L["arccw.cvar.vm_sway_sprint"]            = "Sprint Bob" -- This is intentionally flipped
L["arccw.cvar.vm_bob_sprint"]             = "Sprint Sway" -- Ditto
L["arccw.cvar.vm_swaywarn"]               = "The following only applies when Custom Swaying is enabled"
L["arccw.cvar.vm_look_ymult"]              = "Horizontal Look Sway"
L["arccw.cvar.vm_look_xmult"]              = "Vertical Look Sway"
L["arccw.cvar.vm_sway_xmult"]              = "Bob Right"
L["arccw.cvar.vm_sway_ymult"]              = "Bob Forward"
L["arccw.cvar.vm_sway_zmult"]              = "Bob Up"
L["arccw.cvar.vm_sway_wigglemult"]         = "Bob Wiggle"
L["arccw.cvar.vm_sway_speedmult"]          = "Bob Speed"
L["arccw.cvar.vm_sway_rotatemult"]         = "Bob Rotate"

L["arccw.cvar.vm_accelmult"]              = "Sway Tightness"
L["arccw.cvar.vm_viewwarn"]               = "The following only applies when Custom Camera Movement is enabled"
L["arccw.cvar.vm_coolviewmult"]           = "View Move Multiplier"
-- ArcCW_Options_Crosshair
L["arccw.crosshair.tfa"]                  = "TFA"
L["arccw.crosshair.cw2"]                  = "CW 2.0"
L["arccw.crosshair.cs"]                   = "Counter-Strike"
L["arccw.crosshair.light"]                = "Lightweight"
L["arccw.cvar.crosshair"]                 = "Enable Crosshair"
L["arccw.cvar.crosshair_length"]          = "Crosshair Length"
L["arccw.cvar.crosshair_thickness"]       = "Crosshair Thickness"
L["arccw.cvar.crosshair_gap"]             = "Crosshair Gap Scale"
L["arccw.cvar.crosshair_dot"]             = "Show Center Dot"
L["arccw.cvar.crosshair_shotgun"]         = "Use Shotgun Prongs"
L["arccw.cvar.crosshair_equip"]           = "Use Equipment Prongs"
L["arccw.cvar.crosshair_static"]          = "Static Crosshair"
L["arccw.cvar.crosshair_trueaim"]          = "Accurate Crosshair"
L["arccw.cvar.crosshair_clump"]           = "Use CW2-Style Clump Circle"
L["arccw.cvar.crosshair_clump_outline"]   = "Clump Circle Outline"
L["arccw.cvar.crosshair_clump_always"]    = "Clump Circle Always On"
L["arccw.cvar.crosshair_clr"]             = "Crosshair Color"
L["arccw.cvar.crosshair_outline"]         = "Outline Size"
L["arccw.cvar.crosshair_outline_clr"]     = "Outline Color"
L["arccw.cvar.scope_clr"]                 = "Sight Color"
-- ArcCW_Options_Mults
L["arccw.cvar.mult_damage"]               = "Damage"
L["arccw.cvar.mult_npcdamage"]            = "NPC Damage"
L["arccw.cvar.mult_range"]                = "Range"
L["arccw.cvar.mult_recoil"]               = "Recoil"
L["arccw.cvar.mult_penetration"]          = "Penetration"
L["arccw.cvar.mult_accuracy"]             = "Precision"
L["arccw.cvar.mult_hipfire"]              = "Hip Dispersion"
L["arccw.cvar.mult_movedisp"]             = "Move Dispersion"
L["arccw.cvar.mult_reloadtime"]           = "Reload Time"
L["arccw.cvar.mult_sighttime"]            = "ADS Time"
L["arccw.cvar.mult_defaultclip"]          = "Default Clip"
L["arccw.cvar.mult_attchance"]            = "Random Att. Chance"
L["arccw.cvar.mult_heat"]                 = "Heat Gain"
L["arccw.cvar.mult_shootwhilesprinting"]  = "Shoot While Sprinting"
-- ArcCW_Options_Atts
L["arccw.attdesc1"]                       = "ArcCW supports attachment inventory style behaviour (Like ACT3) as well as attachment locking style behaviour (Like CW2.0) as well as giving everyone all attachments for free (Like TFA Base)."
L["arccw.attdesc2"]                       = "Leave all options off for ACT3 style attachment inventory behaviour."
L["arccw.cvar.attinv_free"]               = "Free Attachments"
L["arccw.cvar.attinv_lockmode"]           = "Attachment Locking"
L["arccw.cvar.attinv_loseondie.desc"]     = "Lose Attachments Modes:\n0 - Disable\n1 = Removed on death\n2 = Drop Attachment Box on death"
L["arccw.cvar.attinv_loseondie"]          = "Lose Atts. On Death"
L["arccw.cvar.atts_pickx.desc"]           = "Pick X behaviour allows you to set a limit on attachments that can be placed on any weapon.\n0 = unlimited."
L["arccw.cvar.atts_pickx"]                = "Pick X"
L["arccw.cvar.enable_dropping"]           = "Attachment Dropping"
L["arccw.cvar.atts_spawnrand"]            = "Random Attachments on Spawn"
L["arccw.cvar.atts_ubglautoload"]         = "Underbarrel Weapons Automatically Loaded"
L["arccw.blacklist"]                      = "Blacklist Menu"
-- ArcCW_Options_Server
L["arccw.cvar.enable_customization"]      = "Enable Customization"
L["arccw.cvar.enable_customization.desc"] = "-1 will disable both customization and the entirety of the Customization UI.\n0 will not allow users to customize their weapons.\n1 will allow customization, the default."
L["arccw.cvar.truenames"]                 = "True Names (Requires Restart)"
L["arccw.cvar.equipmentammo.desc"]        = "There is a limit of 255 ammo types, and enabling this option can cause problems related to this. Requires restart."
L["arccw.cvar.equipmentammo"]             = "Equipment Unique Ammo Types"
L["arccw.cvar.equipmentsingleton.desc"]   = "Singletons can be used once and then remove themselves from your inventory. Requires restart."
L["arccw.cvar.equipmentsingleton"]        = "Grenade/Equipment Singleton"
L["arccw.cvar.equipmenttime"]             = "Equipment Self-Destruct Time"
L["arccw.cvar.throwinertia"]              = "Grenade Inherit Velocity"
L["arccw.cvar.limityear_enable"]          = "Enable Year Limit"
L["arccw.cvar.limityear"]                 = "Year Limit"
L["arccw.cvar.override_crosshair_off"]    = "Force Disable Crosshair"
L["arccw.cvar.override_barrellength"]     = "Enable Near-Walling"
L["arccw.cvar.doorbust"]                  = "Enable Door-Busting"
L["arccw.cvar.desync"]                    = "Desync Bullets"
L["arccw.cvar.desync.desc"]               = "Desync bullets between the server and the client, making the nospread cheat useless."
L["arccw.cvar.weakensounds"]              = "Weaken Sounds"
L["arccw.cvar.weakensounds.desc"]         = "Reduce all weapons' firing volume by this much decibels, making it easier to hide shooting sounds. Clamped to 60-150dB."
-- ArcCW_Options_Dev
L["arccw.dev_info1"]                      = "These are primarily related to attachments and are of use to developers only."
L["arccw.dev_info2"]                      = "Settings will not save."
L["arccw.cvar.dev_reloadonadmincleanup"]  = "Reload on Admin Cleanup"
L["arccw.cvar.dev_reloadonadmincleanup.desc"]    = "Disabled by default.\nDoing an admin cleanup will reload all attachment data."
L["arccw.cvar.dev_registerentities"]      = "Register Att. Entities"
L["arccw.cvar.dev_registerentities.desc"] = "Enabled by default.\nCreates entities for ArcCW attachments. Increases time to reload attachment data."
L["arccw.cvar.dev_reloadatts"]            = "Reload Attachment Data"
L["arccw.cvar.dev_reloadatts.desc"]       = "Reloads attachment data. Use after making a change to an attachment."
L["arccw.cvar.dev_reloadlangs"]           = "Reload Languages"
L["arccw.cvar.dev_reloadlangs.desc"]      = "Reloads all language files."
L["arccw.cvar.dev_spawnmenureload"]       = "Reload Spawnmenu"
L["arccw.cvar.dev_spawnmenureload.desc"]  = "Not exactly an ArcCW specific command, but here for the sake of convenience."
-- TTT Menus
L["arccw.cvar.attinv_loseondie.help"]     = "If enabled, players lose attachment on death and round end."
L["arccw.cvar.ammo_detonationmode.help"]  = "Determines what happens if ammo boxes are destroyed."
L["arccw.cvar.equipmenttime.help"]        = "Applies to deployable equipment like Claymores, in seconds."
L["arccw.cvar.ttt_bodyattinfo"]           = "Body Attachment Info"
L["arccw.cvar.ttt_bodyattinfo.help"]      = "If enabled, searching a body will reveal the attachments on the weapon used to kill someone."
L["arccw.cvar.ttt_bodyattinfo.desc"]      = "0 - Off; 1 - Detectives can see; 2 - Everyone can see"
L["arccw.cvar.attinv_free.help"]          = "If enabled, players have access to all attachments.\nCustomization mode may still restrict them from using them."
L["arccw.cvar.attinv_lockmode.help"]      = "If enabled, picking up one attachment unlocks it for every weapon, a-la CW2."
L["arccw.cvar.enable_customization.help"] = "If disabled, nobody can customize. This overrides Customization Mode."
L["arccw.cvar.ttt_replace"]               = "Auto-replace Weapons"
L["arccw.cvar.ttt_replaceammo"]           = "Auto-replace Ammo"
L["arccw.cvar.ttt_atts"]                  = "Randomize Attachments"
L["arccw.cvar.ttt_customizemode"]         = "Customization Mode"
L["arccw.cvar.ttt_customizemode.desc"]    = "0 - No restrictions; 1 - Restricted; 2 - Pregame only; 3 - Traitor/Detective only"
L["arccw.cvar.ttt_rolecrosshair"]         = "Enable role-based crosshair color"
L["arccw.cvar.ttt_inforoundstart"]        = "Enable round startup info"

-- 2020-11-22
L["arccw.cvar.ammo_replace"]              = "Replace HL2 Ammo Entities"

-- 2020-11-25
L["arccw.cvar.hud_3dfun_lite"]            = "Minimal Mode"
L["arccw.cvar.hud_3dfun_lite.desc"]       = "HUD will only show up when pressing RELOAD. Hold WALK to not reload when doing so."
L["arccw.cvar.hud_3dfun_right"]           = "3D2D Offset Right"
L["arccw.cvar.hud_3dfun_forward"]         = "3D2D Offset Forward"
L["arccw.cvar.hud_3dfun_up"]              = "3D2D Offset Up"
L["arccw.cvar.hud_3dfun_ammotype"]        = "Show Ammo Type"
L["arccw.cvar.hud_3dfun_ammotype.desc"]   = "Ammo HUD will also show weapon's current ammo type."

-- 2021-01-03
L["arccw.combobox.disabled"]              = "0 - Disabled"
L["arccw.cvar.attinv_loseondie.1"]        = "1 - Removed on death"
L["arccw.cvar.attinv_loseondie.2"]        = "2 - Drop attachment box on death"
L["arccw.cvar.ammo_detonationmode.-1"]    = "-1 - Don't explode"
L["arccw.cvar.ammo_detonationmode.0"]     = "0 - Simple explosion"
L["arccw.cvar.ammo_detonationmode.1"]     = "1 - Fragmentation"
L["arccw.cvar.ammo_detonationmode.2"]     = "2 - Frag + Burning"
L["arccw.cvar.enable_customization.-1"]   = "-1 - Disable UI and all customization"
L["arccw.cvar.enable_customization.0"]    = "0 - Players cannot customize"
L["arccw.cvar.enable_customization.1"]    = "1 - Enabled"
L["arccw.cvar.limityear.desc"]            = "If enabled, weapons with a trivia year later than the limit cannot be spawned.\nGood for gmod realism."

-- 2021-01-05
L["arccw.menus.binds"]                    = "Binds"
L["arccw.bindhelp"]                       = "All players can use this panel to set custom bindings for ArcCW features.\n\nBecause of a Garry's Mod limitation, for custom binds you must input the command provided in chat into the console yourself."
L["arccw.cvar.altbindsonly"]              = "Custom Binds Only"
L["arccw.cvar.altbindsonly.desc"]         = "If enabled, default controls will no longer work with ArcCW weapons. Please ensure all of the below buttons are bound so you have access to them."
L["arccw.bind.firemode"]                  = "Change Firemode"
L["arccw.bind.zoom_in"]                   = "Scope Zoom In"
L["arccw.bind.zoom_out"]                  = "Scope Zoom Out"
L["arccw.bind.toggle_inv"]                = "Customize Menu"
L["arccw.bind.switch_scope"]              = "Toggle Sights"
L["arccw.bind.toggle_ubgl"]               = "Toggle Underbarrel"
L["arccw.bind.melee"]                     = "Melee"
L["arccw.bind.msg"]                       = "Type into console: "

-- 2021-01-14
L["arccw.cvar.mult_startunloaded"]        = "Start Unloaded"
L["arccw.cvar.mult_defaultammo"]          = "Default Ammo"

-- 2021-01-18
L["arccw.cvar.dev_showignored"]           = "Load Ignored Atts"
L["arccw.cvar.dev_showignored.desc"]      = "Disabled by default.\nLoad attachments that have att.Ignore set to true. These attachments may be broken or unimplemented.\nThey will be highlighted in light yellow."
L["arccw.cvar.aimassist"]                 = "Enable Aim Assist"
L["arccw.cvar.aimassist.desc"]            = "Allow players to snap their view to NPCs and players near their aim."
L["arccw.cvar.aimassist_cl.desc"]         = "Snap your view to nearby NPCs and players. Only usable if enabled serverside!"
L["arccw.cvar.aimassist_head"]            = "Aim Assist Seeks Head"
L["arccw.cvar.aimassist_cone"]            = "Aim Assist Cone"
L["arccw.cvar.aimassist_distance"]        = "Aim Assist Distance"
L["arccw.cvar.aimassist_intensity"]       = "Aim Assist Intensity"

-- 2021-01-19
L["arccw.cvar.adjustsensthreshold"]       = "Adjust Sensitivity Threshold"
L["arccw.cvar.adjustsensthreshold.desc"]  = "If your total magnification is less than this, your sensitivity will not be adjusted while in sights."

-- 2021-01-20
L["arccw.cvar.crosshair_aa"]              = "Aim Assist Indicator"

-- 2021-1-25
L["arccw.menus.ttt_client"]               = "TTT (Client)"
L["arccw.menus.ttt_server"]               = "TTT (Server)"
L["arccw.ttt_clienthelp"]                 = "These options are TTT-specific, and can be changed by all players. Other tabs may contain non-TTT-specific configurations."
L["arccw.ttt_serverhelp"]                 = "These options are TTT-specific, and require admin privileges to change. They are automatically networked in multiplayer games."
L["arccw.cvar.ttt_customizemode.0"]       = "0 - Unrestricted"
L["arccw.cvar.ttt_customizemode.1"]       = "1 - Restricted"
L["arccw.cvar.ttt_customizemode.2"]       = "2 - Pre-game only"
L["arccw.cvar.ttt_customizemode.3"]       = "3 - Detectives/Traitors only"
L["arccw.cvar.ttt_bodyattinfo.1"]         = "1 - Detectives can see"
L["arccw.cvar.ttt_bodyattinfo.2"]         = "2 - Everyone can see"
L["arccw.cvar.mult_crouchdisp"]           = "Crouched Dispersion"
L["arccw.cvar.mult_crouchrecoil"]         = "Crouched Recoil"

-- 2021-2-19
L["arccw.cvar.dev_debug"]                 = "Debug Menu"
L["arccw.cvar.dev_debug.desc"]            = "Disabled by default.\nDraws a debug menu over your screen where you can view certain elements blah blah?"

L["arccw.cvar.attinv_sound"]              = "Customization Menu Sounds"
L["arccw.cvar.attinv_sound.desc"]         = "Enable or disable sounds for the customization menu."

-- 2021-3-2
L["arccw.ammohud"]                        = "\nAmmo HUD" -- Obsoletes "3D2D HUD" since they're basically the same now"
L["arccw.cvar.hud_fcgbars"]               = "Show Firemode Bars"
L["arccw.bind.toggle_att"]                = "Toggle Attachments"

-- 2021-05-05
L["arccw.cvar.attinv_gamemodebuttons"]    = "Gamemode-specific buttons"
L["arccw.cvar.attinv_gamemodebuttons.desc"] = "Shows helpful functions for gamemodes like TTT and DarkRP.\nIn addition to using these, you can hold USE to access original keybinds as well."

-- 2021-05-13
L["arccw.cvar.mult_malfunction"] = "Malfunction Chance"
L["arccw.cvar.malfunction"]    = "Malfunction Mode"
L["arccw.cvar.malfunction.0"]   = "0 - Force disable on all guns"
L["arccw.cvar.malfunction.1"]    = "1 - Enabled"
L["arccw.cvar.malfunction.2"]    = "2 - Force enable on all guns"

-- 2021-05-26
L["arccw.cvar.mult_meleedamage"] = "Melee Damage"
L["arccw.cvar.mult_meleetime"] = "Melee Time"

-- 2021-05-27
L["arccw.cvar.ammonames"] = "Custom Ammo Names"
L["arccw.cvar.ammonames.desc"] = "Replaces default ammo type names with custom ones that are a bit more realistic (such as Pulse Ammo to Rifle Ammo). Also replaces references everywhere else!"
L["arccw.cvar.att_showground"] = "Show Ground Attachments"

-- 2021-06-02
L["arccw.cvar.mult_bottomlessclip"] = "Bottomless Clip"
L["arccw.cvar.mult_infiniteammo"] = "Infinite Ammo"

-- 2021-06-07
L["arccw.cvar.bodydamagecancel"] = "Cancel Body Damage"
L["arccw.cvar.bodydamagecancel.desc"] = "When a weapon specifies limb damage modifiers, cancel Gmod's default multipliers. Disable when you have another mod that does this."

L["arccw.cvar.enable_sway"] = "Enable Sway"
L["arccw.cvar.enable_sway.desc"] = "Most weapons do not specify a sway value. If you wish to give sway to all weapons, use the 'Add Sway' slider."
L["arccw.cvar.add_sway"] = "Add Sway"
L["arccw.cvar.mult_sway"]    = "Multiply Sway"

-- 2021-08-15
L["arccw.cvar.mult_rpm"] = "Fire Rate"
L["arccw.cvar.mult_rpm.desc"] = "May be disastrous on performance. May also be a ton of fun."

-- 2021-08-16
L["arccw.cvar.dev_benchgun"] = "Benchgun"
L["arccw.cvar.dev_benchgun.desc"] = "Places the viewmodel in a stationary position, usually at world origin."
L["arccw.cvar.dev_benchgun_custom"] = "Benchgun Custom"
L["arccw.cvar.dev_benchgun_custom.desc"] = "Custom location to place the viewmodel at. Use getpos and place the result here.\nExample:\nsetpos 61 -397 -63;setang 0 96 0"

-- 2021-08-18
L["arccw.cvar.crosshair_prong_top"] = "Show Top Prong"
L["arccw.cvar.crosshair_prong_left"] = "Show Left Prong"
L["arccw.cvar.crosshair_prong_right"] = "Show Right Prong"
L["arccw.cvar.crosshair_prong_bottom"] = "Show Bottom Prong"
L["arccw.cvar.crosshair_tilt"] = "Tilted Crosshair"
L["arccw.cvar.attinv_giveonspawn"] = "Give Atts. On Spawn"

-- 2021-10-10
L["arccw.cvar.hud_fcgabbrev"] = "Abbreviate Firemode Names"

-- 2021-10-31
L["arccw.cvar.reloadincust"] = "Reloading In Customize Menu"
L["arccw.cvar.reloadincust.desc"] = "May allow players to cheese reload times by swapping magazine attachments.\nWill also disable left hand lowering in the customize menu."

-- 2021-11-11
L["arccw.cvar.freeaim"] = "Free Aim"
L["arccw.cvar.freeaim.1"] = "1 - Enabled"
L["arccw.cvar.freeaim.2"] = "2 - No Dispersion Tweak"

-- 2021-11-24
L["arccw.cvar.override_lunge_off"] = "Disable Melee Lunging"
L["arccw.cvar.override_lunge_off.desc"] = "Bashing with a weapon can allow you to dash a short distance if there is a target in front. This option disables that momentum for all weapons."

-- 2021-11-27
L["arccw.cvar.mult_movespeed"] = "Speed"
L["arccw.cvar.mult_movespeedads"] = "Speed in ADS"
L["arccw.cvar.mult_movespeedfire"] = "Speed while firing"

-- 2022-02-14
L["arccw.cvar.vm_nearwall"] = "Near-wall Movement"
L["arccw.cvar.nohl2flash"] = "Toggle attachments modes through flashlight bind"

-- 2022-03-24
L["arccw.cvar.dev_alwaysready"] = "Always Use Ready Animation"
L["arccw.cvar.dev_alwaysready.desc"] = "Always use the ready animation while drawing when available."

L["arccw.cvar.noinspect"] = "Disable inspect animations"

-- 2022-07-10
L["arccw.cvar.override_hud_off"] = "Force Disable HUD"
L["arccw.hud_svwarning"] = "The HUD can be disabled serverside by a server administrator."

-- 2023-10-10
L["arccw.cvar.2d3d.1"]  = "1 - When Pointed At"
L["arccw.cvar.2d3d.2"]  = "2 - Always"
--PATH lua/arccw/shared/sh_penetration.lua:
return gluapack()()
--PATH lua/arccw/client/cl_npc.lua:
return gluapack()()
--PATH lua/arccw/client/cl_sway.lua:
return gluapack()()
--PATH lua/autorun/arfegle.lua:
return gluapack()()
--PATH lua/autorun/armand.lua:
player_manager.AddValidModel( "navy armand", 		"models/navy/gnavyarmand.mdl" );
list.Set( "PlayerOptionsModel", "navy armand", 	"models/navy/gnavyarmand.mdl" );
--PATH lua/autorun/aussi_cgicg_arms.lua:
return gluapack()()
--PATH lua/autorun/aussi_cgicustom_arms.lua:
return gluapack()()
--PATH lua/autorun/aussi_cgicustom_arms.lua:
list.Set( "PlayerOptionsModel", "ARC Captain Pab (CGI)", "models/aussiwozzi/cgi/base/arc_cpt_pab.mdl" )
player_manager.AddValidModel( "ARC Captain Pab (CGI)", "models/aussiwozzi/cgi/base/arc_cpt_pab.mdl" )
player_manager.AddValidHands( "ARC Captain Pab (CGI)", "models/aussiwozzi/cgi/base/arc_cpt_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "ARC Captain Rat (CGI)", "models/aussiwozzi/cgi/base/arc_cpt_rat.mdl" )
player_manager.AddValidModel( "ARC Captain Rat (CGI)", "models/aussiwozzi/cgi/base/arc_cpt_rat.mdl" )
player_manager.AddValidHands( "ARC Captain Rat (CGI)", "models/aussiwozzi/cgi/base/arc_cpt_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "ARC Captain Shadowz (CGI)", "models/aussiwozzi/cgi/base/arc_cpt_shadowz.mdl" )
player_manager.AddValidModel( "ARC Captain Shadowz (CGI)", "models/aussiwozzi/cgi/base/arc_cpt_shadowz.mdl" )
player_manager.AddValidHands( "ARC Captain Shadowz (CGI)", "models/aussiwozzi/cgi/base/arc_cpt_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "ARC Captain Jarr (CGI)", "models/aussiwozzi/cgi/base/arc_cpt_jarr.mdl" )
player_manager.AddValidModel( "ARC Captain Jarr (CGI)", "models/aussiwozzi/cgi/base/arc_cpt_jarr.mdl" )
player_manager.AddValidHands( "ARC Captain Jarr (CGI)", "models/aussiwozzi/cgi/base/arc_cpt_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "ARC LT Macka (CGI)", "models/aussiwozzi/cgi/base/arc_lt_macka.mdl" )
player_manager.AddValidModel( "ARC LT Macka (CGI)", "models/aussiwozzi/cgi/base/arc_lt_macka.mdl" )
player_manager.AddValidHands( "ARC LT Macka (CGI)", "models/aussiwozzi/cgi/base/arc_cpt_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "ARC LT Chunky (CGI)", "models/aussiwozzi/cgi/base/arc_lt_Chunky.mdl" )
player_manager.AddValidModel( "ARC LT Chunky (CGI)", "models/aussiwozzi/cgi/base/arc_lt_Chunky.mdl" )
player_manager.AddValidHands( "ARC LT Chunky (CGI)", "models/aussiwozzi/cgi/base/arc_lt_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 501st Knotts (CGI)", "models/aussiwozzi/cgi/base/501st_knotts.mdl" )
player_manager.AddValidModel( "Phase 2 501st Knotts (CGI)", "models/aussiwozzi/cgi/base/501st_knotts.mdl" )
player_manager.AddValidHands( "Phase 2 501st Knotts (CGI)", "models/aussiwozzi/cgi/base/501st_trooper_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 501st Sarge (CGI)", "models/aussiwozzi/cgi/base/501st_sarge.mdl" )
player_manager.AddValidModel( "Phase 2 501st Sarge (CGI)", "models/aussiwozzi/cgi/base/501st_sarge.mdl" )
player_manager.AddValidHands( "Phase 2 501st Sarge (CGI)", "models/aussiwozzi/cgi/base/501st_trooper_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 501st Bulldog (CGI)", "models/aussiwozzi/cgi/base/501st_brighton.mdl" )
player_manager.AddValidModel( "Phase 2 501st Bulldog (CGI)", "models/aussiwozzi/cgi/base/501st_brighton.mdl" )
player_manager.AddValidHands( "Phase 2 501st Bulldog (CGI)", "models/aussiwozzi/cgi/base/501st_trooper_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 Buck Advisor (CGI)", "models/aussiwozzi/cgi/base/buck_advisor.mdl" )
player_manager.AddValidModel( "Phase 2 Buck Advisor (CGI)", "models/aussiwozzi/cgi/base/buck_advisor.mdl" )
player_manager.AddValidHands( "Phase 2 Buck Advisor (CGI)", "models/aussiwozzi/cgi/base/shadow_trooper_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 104th Dash (CGI)", "models/aussiwozzi/cgi/base/104th_dash.mdl" )
player_manager.AddValidModel( "Phase 2  104th Dash (CGI)", "models/aussiwozzi/cgi/base/104th_dash.mdl" )
player_manager.AddValidHands( "Phase 2  104th Dash (CGI)", "models/aussiwozzi/cgi/base/104th_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 104th Outback (CGI)", "models/aussiwozzi/cgi/base/104th_outback.mdl" )
player_manager.AddValidModel( "Phase 2  104th Outback (CGI)", "models/aussiwozzi/cgi/base/104th_outback.mdl" )
player_manager.AddValidHands( "Phase 2  104th Outback (CGI)", "models/aussiwozzi/cgi/base/104th_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 104th ARC Dash (CGI)", "models/aussiwozzi/cgi/base/104th_arc_dusty.mdl" )
player_manager.AddValidModel( "Phase 2  104th ARC Dash (CGI)", "models/aussiwozzi/cgi/base/104th_arc_dusty.mdl" )
player_manager.AddValidHands( "Phase 2  104th ARC Dash (CGI)", "models/aussiwozzi/cgi/base/104th_arc_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 CG Tops (CGI)", "models/aussiwozzi/cgi/base/cg_tops.mdl" )
player_manager.AddValidModel( "Phase 2 CG Tops (CGI)", "models/aussiwozzi/cgi/base/cg_tops.mdl" )
player_manager.AddValidHands( "Phase 2 CG Tops (CGI)", "models/aussiwozzi/cgi/base/cg_trooper_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 Doom's Unit Jet Trooper (CGI)", "models/aussiwozzi/cgi/base/doom_jet.mdl" )
player_manager.AddValidModel( "Phase 2 Doom's Unit Jet Trooper (CGI)", "models/aussiwozzi/cgi/base/doom_jet.mdl" )
player_manager.AddValidHands( "Phase 2 Doom's Unit Jet Trooper (CGI)", "models/aussiwozzi/cgi/base/doom_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 Doom's Unit HRS Trooper (CGI)", "models/aussiwozzi/cgi/base/doom_hrs.mdl" )
player_manager.AddValidModel( "Phase 2 Doom's Unit HRS Trooper (CGI)", "models/aussiwozzi/cgi/base/doom_hrs.mdl" )
player_manager.AddValidHands( "Phase 2 Doom's Unit HRS Trooper (CGI)", "models/aussiwozzi/cgi/base/doom_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 Doom's Unit Sydney (CGI)", "models/aussiwozzi/cgi/base/doom_sydney.mdl" )
player_manager.AddValidModel( "Phase 2 Doom's Unit HRS Sydney (CGI)", "models/aussiwozzi/cgi/base/doom_sydney.mdl" )
player_manager.AddValidHands( "Phase 2 Doom's Unit HRS Sydney (CGI)", "models/aussiwozzi/cgi/base/doom_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 Doom's Unit HRS Officer (CGI)", "models/aussiwozzi/cgi/base/doom_hrs_officer.mdl" )
player_manager.AddValidModel( "Phase 2 Doom's Unit HRS Officer (CGI)", "models/aussiwozzi/cgi/base/doom_hrs_officer.mdl" )
player_manager.AddValidHands( "Phase 2 Doom's Unit HRS Officer (CGI)", "models/aussiwozzi/cgi/base/doom_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 Doom's Unit HRS Medic (CGI)", "models/aussiwozzi/cgi/base/doom_hrs_medic.mdl" )
player_manager.AddValidModel( "Phase 2 Doom's Unit HRS Medic (CGI)", "models/aussiwozzi/cgi/base/doom_hrs_medic.mdl" )
player_manager.AddValidHands( "Phase 2 Doom's Unit HRS Medic (CGI)", "models/aussiwozzi/cgi/base/doom_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 21st Nova Corps Tre (CGI)", "models/aussiwozzi/cgi/base/gm_elite.mdl" )
player_manager.AddValidModel( "Phase 2 21st Nova Corps Tre (CGI)", "models/aussiwozzi/cgi/base/gm_elite.mdl" )
player_manager.AddValidHands( "Phase 2 21st Nova Corps Tre (CGI)", "models/aussiwozzi/cgi/base/gm_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 Doom's Unit ARC 2 (CGI)", "models/aussiwozzi/cgi/base/gm_tre.mdl" )
player_manager.AddValidModel( "Phase 2 Doom's Unit ARC 2 (CGI)", "models/aussiwozzi/cgi/base/gm_tre.mdl" )
player_manager.AddValidHands( "Phase 2 Doom's Unit ARC 2 (CGI)", "models/aussiwozzi/cgi/base/doom_arc_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 Doom's Unit ARC 3 (CGI)", "models/aussiwozzi/cgi/base/doom_arc_3.mdl" )
player_manager.AddValidModel( "Phase 2 Doom's Unit ARC 3 (CGI)", "models/aussiwozzi/cgi/base/doom_arc_3.mdl" )
player_manager.AddValidHands( "Phase 2 Doom's Unit ARC 3 (CGI)", "models/aussiwozzi/cgi/base/doom_arc_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 Tesla (CGI)", "models/aussiwozzi/cgi/base/unassigned_com_tesla.mdl" )
player_manager.AddValidModel( "Phase 2 Tesla (CGI)", "models/aussiwozzi/cgi/base/unassigned_com_tesla.mdl" )
player_manager.AddValidHands( "Phase 2 Tesla (CGI)", "models/aussiwozzi/cgi/base/com_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 Clone Captain Howzer (CGI)", "models/aussiwozzi/cgi/base/howzer.mdl" )
player_manager.AddValidModel( "Phase 2 Clone Captain Howzer (CGI)", "models/aussiwozzi/cgi/base/howzer.mdl" )
player_manager.AddValidHands( "Phase 2 Clone Captain Howzer (CGI)", "models/aussiwozzi/cgi/base/howzer_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Clone Captain Breaker (CGI)", "models/aussiwozzi/cgi/base/captain_breaker.mdl" )
player_manager.AddValidModel( "Clone Captain Breaker (CGI)", "models/aussiwozzi/cgi/base/captain_breaker.mdl" )
player_manager.AddValidHands( "Clone Captain Breaker (CGI)", "models/aussiwozzi/cgi/base/captain_breaker_arms.mdl",0,"10000000" )


list.Set( "PlayerOptionsModel", "Phase 2 Shadow Azreiath (CGI)", "models/aussiwozzi/cgi/base/shadow_azre.mdl" )
player_manager.AddValidModel( "Phase 2 Shadow Azreiath (CGI)", "models/aussiwozzi/cgi/base/shadow_azre.mdl" )
player_manager.AddValidHands( "Phase 2 Shadow Azreiath (CGI)", "models/aussiwozzi/cgi/base/shadow_trooper_arms.mdl",0,"10000000" )







--PATH lua/autorun/aussi_cgidoom_arms.lua:
return gluapack()()
--PATH lua/autorun/aussi_cgidoom_arms.lua:
list.Set( "PlayerOptionsModel", "Phase 2 Doom's Unit Clone Trooper (CGI)", "models/aussiwozzi/cgi/base/doom_trooper.mdl" )
player_manager.AddValidModel( "Phase 2 Doom's Unit Clone Trooper (CGI)", "models/aussiwozzi/cgi/base/doom_trooper.mdl" )
player_manager.AddValidHands( "Phase 2 Doom's Unit Clone Trooper (CGI)", "models/aussiwozzi/cgi/base/doom_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 Doom's Unit Medic (CGI)", "models/aussiwozzi/cgi/base/doom_medic.mdl" )
player_manager.AddValidModel( "Phase 2 Doom's Unit Medic (CGI)", "models/aussiwozzi/cgi/base/doom_medic.mdl" )
player_manager.AddValidHands( "Phase 2 Doom's Unit Medic (CGI)", "models/aussiwozzi/cgi/base/doom_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 Doom's Unit Medic Officer (CGI)", "models/aussiwozzi/cgi/base/doom_medic_officer.mdl" )
player_manager.AddValidModel( "Phase 2 Doom's Unit Medic Officer (CGI)", "models/aussiwozzi/cgi/base/doom_medic_officer.mdl" )
player_manager.AddValidHands( "Phase 2 Doom's Unit Medic Officer (CGI)", "models/aussiwozzi/cgi/base/doom_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 Doom's Unit Officer (CGI)", "models/aussiwozzi/cgi/base/doom_officer.mdl" )
player_manager.AddValidModel( "Phase 2 Doom's Unit Officer (CGI)", "models/aussiwozzi/cgi/base/doom_officer.mdl" )
player_manager.AddValidHands( "Phase 2 Doom's Unit Officer (CGI)", "models/aussiwozzi/cgi/base/doom_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 Doom's Unit Commander Doom (CGI)", "models/aussiwozzi/cgi/base/doom_commander.mdl" )
player_manager.AddValidModel( "Phase 2 Doom's Unit Commander Doom (CGI)", "models/aussiwozzi/cgi/base/doom_commander.mdl" )
player_manager.AddValidHands( "Phase 2 Doom's Unit Commander Doom (CGI)", "models/aussiwozzi/cgi/base/doom_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 Doom's Unit Pilot (CGI)", "models/aussiwozzi/cgi/base/doom_pilot.mdl" )
player_manager.AddValidModel( "Phase 2 Doom's Unit Pilot (CGI)", "models/aussiwozzi/cgi/base/doom_pilot.mdl" )
player_manager.AddValidHands( "Phase 2 Doom's Unit Pilot (CGI)", "models/aussiwozzi/cgi/base/doom_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 Doom's Unit Demo Trooper (CGI)", "models/aussiwozzi/cgi/base/doom_demo.mdl" )
player_manager.AddValidModel( "Phase 2 Doom's Unit Demo Trooper (CGI)", "models/aussiwozzi/cgi/base/doom_demo.mdl" )
player_manager.AddValidHands( "Phase 2 Doom's Unit Demo Trooper (CGI)", "models/aussiwozzi/cgi/base/doom_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 Doom's Unit BARC (CGI)", "models/aussiwozzi/cgi/base/doom_barc.mdl" )
player_manager.AddValidModel( "Phase 2 Doom's Unit BARC (CGI)", "models/aussiwozzi/cgi/base/doom_barc.mdl" )
player_manager.AddValidHands( "Phase 2 Doom's Unit BARC (CGI)", "models/aussiwozzi/cgi/base/doom_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 Doom's Unit ARF Trooper (CGI)", "models/aussiwozzi/cgi/base/doom_arf.mdl" )
player_manager.AddValidModel( "Phase 2 Doom's Unit ARF Trooper (CGI)", "models/aussiwozzi/cgi/base/doom_arf.mdl" )
player_manager.AddValidHands( "Phase 2 Doom's Unit ARF Trooper (CGI)", "models/aussiwozzi/cgi/base/doom_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 2 Doom's Unit ARC Trooper (CGI)", "models/aussiwozzi/cgi/base/doom_arc.mdl" )
player_manager.AddValidModel( "Phase 2 Doom's Unit ARC Trooper (CGI)", "models/aussiwozzi/cgi/base/doom_arc.mdl" )
player_manager.AddValidHands( "Phase 2 Doom's Unit ARC Trooper (CGI)", "models/aussiwozzi/cgi/base/doom_arc_arms.mdl",0,"10000000" )

--PATH addons/[admin] awarn3/lua/includes/cl_awarn3.lua:
return gluapack()()
--PATH addons/[admin] awarn3/lua/includes/sh_awarn3.lua:
AddCSLuaFile()
--[[
      __          __              ____  
     /\ \        / /             |___ \ 
    /  \ \  /\  / /_ _ _ __ _ __   __) |
   / /\ \ \/  \/ / _` | '__| '_ \ |__ < 
  / ____ \  /\  / (_| | |  | | | |___) |
 /_/    \_\/  \/ \__,_|_|  |_| |_|____/ 

	AWarn3 by Mr.President
]]


function AWarn:CheckDirectory()
	if not file.Exists( "awarn3", "DATA" ) then file.CreateDir( "awarn3" ) end
end

function AWarn:FindPlayerByName( plName )
	local pl = nil
	local plCount = 0
	for k, v in pairs( player.GetAll() ) do
		if string.find( string.lower( v:GetName() ), string.lower( plName ) ) then
			pl = v
			plCount = plCount + 1
		end
	end
	if plCount == 1 then
		return pl
	elseif plCount > 1 then
		MsgC( Color(0,255,0), "[AWarn3] ", AWARN3_WHITE, "Multiple players found\n" )
		return nil
	else
		MsgC( Color(0,255,0), "[AWarn3] ", AWARN3_WHITE, "No players found\n" )
		return nil
	end
end

function AWarn:GetIDFromNameOrSteamID( str )
	local str = str
	local id = nil
	if str:lower():Left(7) == "steam_0" then
		id = util.SteamIDTo64( str )
	else
		if self:FindPlayerByName( str ) then
			id = AWarn:SteamID64( self:FindPlayerByName( str ) )
		end
	end
	
	return id
end

function AWarn:GetPlayerFromID64( id )
	local pl = nil
	for k, v in pairs( player.GetAll() ) do
		if AWarn:SteamID64( v ) == id then
			pl = v
			break
		end
	end
	
	return pl
end

function AWarn:SteamID64( pl )

	if pl:IsBot() then 
		return pl:GetName()
	else
		return pl:SteamID64()
	end
	

end

function AWarn:RegisterAdminModPermissions()
	MsgC( AWARN3_STATECOLOR, "[AWarn3] ", AWARN3_WHITE, "Registering Admin Mod Access Permissions\n" )
	if ulx then
		if SERVER then
			for k, v in pairs( self.Permissions ) do
				ULib.ucl.registerAccess( self.Permissions[k].permissionString, ULib.ACCESS_SUPERADMIN, self.Permissions[k].description, "AWarn" )
			end
		end
	elseif serverguard then
		for k, v in pairs( self.Permissions ) do
			serverguard.permission:Add(self.Permissions[k].permissionString)
		end
	elseif sAdmin then
		for k, v in pairs( self.Permissions ) do
			sAdmin.registerPermission(self.Permissions[k].permissionString, "AWarn3", false, true)
		end
	elseif CAMI then
		for k, v in pairs( self.Permissions ) do
			CAMI.RegisterPrivilege({
				Name = self.Permissions[k].permissionString,
				MinAccess = "superadmin",
				Description = self.Permissions[k].description
			})
		end
	end	
end

timer.Simple( 3, function() AWarn:RegisterAdminModPermissions() end )
--PATH addons/[misc] bodygroupr/lua/bodyman/bodyman_config.lua:
BODYMAN.HelpText = [[]]

BODYMAN.HelpText_En = [[Wybierz Grupy ciaa w panelu po prawej stronie.
Przecignij poziomo, aby obrci model gracza.
Przecignij w pionie, aby powikszy.
Kliknij prawym przyciskiem myszy i przecignij, aby ustawi kamer.]] -- edit this to your liking.

BODYMAN.HelpText_Fr = [[Slectionnez Bodygroups dans le panneau de droite .
Faites glisser horizontalement pour faire pivoter le joueur.
Faites glisser verticalement pour zoomer.
Faites un clic droit et faites glisser pour positionner la camra.]]

BODYMAN.HelpText_De = [[Whle die Krper Gruppe im rechten Feld.
Ziehe Horizontal um das Model zu drehen.
Ziehe Vertikal um an das Model heran/heraus zu zoomen.
Rechts Klick und ziehen um die Kamera zu bewegen.]]

BODYMAN.ClosetViewDistance = 256 -- how far the text can be seen on the closet
BODYMAN.ClosetName = "" -- what should the closet be called?
BODYMAN.ClosetHelpText = [[]]

BODYMAN.ClosetName_En = "Closet" -- what should the closet be called?
BODYMAN.ClosetHelpText_En = [[Nacinij [E], aby dostosowa swj
wygld.]]

BODYMAN.ClosetName_Fr = "Armoire"
BODYMAN.ClosetHelpText_Fr = [[Appuyez sur [ E ] pour personnaliser votre
apparence.]]

BODYMAN.ClosetName_De = "Kleiderschrank" -- what should the closet be called?
BODYMAN.ClosetHelpText_De = [[Drcke [E] um dein Aussehen zu verndern.]]

BODYMAN.ClosetsOnly = true -- set this to true if you think players MUST use a closet. They will not be able to access the interface normally.

BODYMAN.strings = {
	Appearance = "Appearance",
	Playermodels = "Playermodels",
	Skins = "Skins",
	Bodygroups = "Bodygroups",
	Save = "Save",
	Load = "Load",
	Remove_All = "Remove All",
	Without_Saving = "Without Saving",
	Spawn_a = "Spawn a",
	Physique = "Build",
}
BODYMAN.strings_en = {
	Appearance = "Wygld",
	Playermodels = "Playermodels",
	Skins = "Skins",
	Bodygroups = "Grupy ciaa",
	Save = "Zapisz",
	Load = "Zaaduj",
	Remove_All = "Usu wszystko",
	Without_Saving = "Bez zapisywania",
	Spawn_a = "Spawn a",
	Physique = "Buduj",
}
BODYMAN.strings_fr = {
	Appearance = "Apparence",
	Playermodels = "Joueur",
	Skins = "Peau",
	Bodygroups = "Bodygroups",
	Save = "Sauvegarder l'",
	Load = "Reapparatre",
	Remove_All = "Retirer toutes les",
	Without_Saving = "sans sauvegarder",
	Spawn_a = "Apparatre",
	Physique = "Physique",
}
BODYMAN.strings_de = {
	Appearance = "Aussehen",
	Playermodels = "Spieler Modelle",
	Skins = "Haut",
	Bodygroups = "Accessoire",
	Save = "Speichern",
	Load = "Laden",
	Remove_All = "Alle entfernen",
	Without_Saving = "Ohne zu speichern",
	Spawn_a = "Erzeugen",
	Physique = "Build",
}

BODYMAN.French = false -- Set this to true if your server speaks French/Francais.
BODYMAN.German = false -- Set this to true if your server speaks German/Deutsche.

BODYMAN.ClosetsCanBreak = false -- set this to true if you want closets to be destroyable with guns
BODYMAN.ClosetHealth = 100 -- default HP of closets. increase this if you want to take more shots to destroy them.

BODYMAN.Ranks = {}

-- !! Note !! the default required access level for changing bodygroups and skins is 10. If you wanted to make bodygroupr VIP only, then you would have to change bodyman_openmenu access level.
-- Players can only access commands when their access level meets or exceeds the command's access level.
-- e.g. admin can access all commands with access level 30 or lower.

-- Any group not found defaults to access level 10.

BODYMAN.Ranks["user"] = 10
BODYMAN.Ranks["support"] = 10
BODYMAN.Ranks["moderator"] = 10
BODYMAN.Ranks["admin"] = 29
BODYMAN.Ranks["superadmin"] = 40
BODYMAN.Ranks["Developer"] = 50

BODYMAN.PlayerAccess = {}

BODYMAN.PlayerAccess["owner_steamid"] = 50

BODYMAN.Permissions = {

	-- moderator and admin tools
	["listbodygroups"] = 20,
	["bodyman_saveclosets"] = 30,
	["bodyman_loadclosets"] = 30,
	["bodyman_removeclosets"] = 30,
	["bodyman_spawncloset"] = 20,

	-- playermodel, bodygroup and skin changes
	["bodyman_model_change"] = 9,
	["bodygroups_change"] = 9,
	["skins_change"] = 9,

	-- menus
	["bodyman_openmenu"] = 10,
	["bodyman_adminmenu"] = 30,
}


function BODYMAN:IsVip(ply)
	--edit this to fit your server
	return true
end
--PATH lua/autorun/boss_health.lua:

bossHealthSystem = bossHealthSystem or {}

if SERVER then
	util.AddNetworkString("add_boss")
	util.AddNetworkString("remove_boss")
	util.AddNetworkString("boss_data")
end

// Getters and setters
function bossHealthSystem:GetBoss()
	return self.bossEntity
end

function bossHealthSystem:GetMult()
	return self.bossDmgscale
end

function bossHealthSystem:AddBoss(ent, maxHealth, health, name, label, dmgscale, icon)
	if SERVER then
		ent:SetHealth(health)
		ent:SetMaxHealth(maxHealth)
	end

	self.bossEntity = ent
	self.bossName = name
	self.bossLabel = label
	self.bossDmgscale = dmgscale
	self.bossIcon = icon
	
	if SERVER then
		net.Start("add_boss")
			net.WriteEntity(self.bossEntity)
			net.WriteString(name)
			net.WriteString(label)
			net.WriteString(icon)
		net.Broadcast()

		net.Start("boss_data")
			net.WriteEntity(self.bossEntity)
			net.WriteString(name)
			net.WriteString(label)
			net.WriteString(icon)
		net.Broadcast()
	end
end

function bossHealthSystem:RemoveBoss()
	self.bossEntity = nil

	if SERVER then
		net.Start("remove_boss")
		net.Broadcast()
	end
end

function bossHealthSystem:IsValidBoss()
	return IsValid(self.bossEntity)
end

if CLIENT then
	net.Receive("add_boss", function(len) 
		local ent = net.ReadEntity()
		local name = net.ReadString()
		local label = net.ReadString()
		local icon = net.ReadString()

		bossHealthSystem:AddBoss(ent, name, label, icon)
	end)

	net.Receive("remove_boss", function(len)
		bossHealthSystem:AddBoss(NULL)
	end)
end

--SERVER HOOKS!!!!!!--
hook.Add("OnNPCKilled","BossNPCDeath",function(npc)
	if not IsValid(bossHealthSystem:GetBoss()) then return end
	if npc == bossHealthSystem:GetBoss() then
		bossHealthSystem:RemoveBoss()
	end
end)

hook.Add("PlayerDeath","BossDeath",function(victim)
	if not IsValid(bossHealthSystem:GetBoss()) then return end
	if victim == bossHealthSystem:GetBoss() then
		bossHealthSystem:RemoveBoss()
	end
end)

hook.Add("EntityRemoved","BossRemoved",function(ent)
	if not IsValid(bossHealthSystem:GetBoss()) then return end
	if ent == bossHealthSystem:GetBoss() then
		bossHealthSystem:RemoveBoss()
	end
end)

hook.Add("PlayerDisconnected","BossDisconnected",function(ply)
	if not IsValid(bossHealthSystem:GetBoss()) then return end
	if ply == bossHealthSystem:GetBoss() then
		bossHealthSystem:RemoveBoss()
	end
end)

hook.Add("EntityTakeDamage","BossDamageMult",function(ply,dmg)
	if not IsValid(bossHealthSystem:GetBoss()) then return end
	local bossent = dmg:GetAttacker()
	if bossent == bossHealthSystem:GetBoss() then
		dmg:ScaleDamage(bossHealthSystem:GetMult())
	end
end) 
--PATH lua/autorun/cdraw.lua:
return gluapack()()
--PATH lua/autorun/civ_pm_female.lua:
player_manager.AddValidModel( "Civilian Resident Female", "models/resident/pm_civ_resident_human_female.mdl" );
list.Set( "PlayerOptionsModel",  "Civilian Resident Female", "models/resident/pm_civ_resident_human_female.mdl" );
player_manager.AddValidModel( "Civilian Dweller Female", "models/dweller/pm_civ_dweller_human_female.mdl" );
list.Set( "PlayerOptionsModel",  "Civilian Dweller Female", "models/dweller/pm_civ_dweller_human_female.mdl" );
player_manager.AddValidModel( "Civilian Formal Female", "models/formal/pm_civ_formal_human_female.mdl" );
list.Set( "PlayerOptionsModel",  "Civilian Formal Female", "models/formal/pm_civ_formal_human_female.mdl" );
player_manager.AddValidModel( "Civilian Noble Female", "models/noble/pm_civ_noble_human_female.mdl" );
list.Set( "PlayerOptionsModel",  "Civilian Noble Female", "models/noble/pm_civ_noble_human_female.mdl" );
player_manager.AddValidModel( "Civilian Smuggler Female", "models/smuggler/pm_civ_smuggler_human_female.mdl" );
list.Set( "PlayerOptionsModel",  "Civilian Smuggler Female", "models/smuggler/pm_civ_smuggler_human_female.mdl" );


player_manager.AddValidModel( "Civilian Merc Female", "models/merc/pm_civ_merc_human_female.mdl" );
list.Set( "PlayerOptionsModel",  "Civilian Merc Female", "models/merc/pm_civ_merc_human_female.mdl" );
player_manager.AddValidModel( "Civilian Guard Female", "models/guard/pm_civ_guard_human_female.mdl" );
list.Set( "PlayerOptionsModel",  "Civilian Guard Female", "models/guard/pm_civ_guard_human_female.mdl" );
player_manager.AddValidModel( "Civilian Assassin Female", "models/assassin/pm_civ_assassin_human_female.mdl" );
list.Set( "PlayerOptionsModel",  "Civilian Assassin Female", "models/assassin/pm_civ_assassin_human_female.mdl" );
player_manager.AddValidModel( "Civilian Renegade Female", "models/renegade/pm_civ_renegade_human_female.mdl" );
list.Set( "PlayerOptionsModel",  "Civilian Renegade Female", "models/renegade/pm_civ_renegade_human_female.mdl" );
player_manager.AddValidModel( "Civilian Bandit Female", "models/bandit/pm_civ_bandit_human_female.mdl" );
list.Set( "PlayerOptionsModel",  "Civilian Bandit Female", "models/bandit/pm_civ_bandit_human_female.mdl" );

player_manager.AddValidModel( "Civilian Gundark Female", "models/gundark/pm_civ_gundark_costume_female.mdl" );
list.Set( "PlayerOptionsModel",  "Civilian Gundark Female", "models/gundark/pm_civ_gundark_costume_female.mdl" );
player_manager.AddValidModel( "Civilian Wampa Female", "models/wampa/pm_civ_wampa_costume_female.mdl" );
list.Set( "PlayerOptionsModel",  "Civilian Wampa Female", "models/wampa/pm_civ_wampa_costume_female.mdl" );
player_manager.AddValidModel( "Civilian Clown Female", "models/clown/pm_civ_clown_costume_female.mdl" );
list.Set( "PlayerOptionsModel",  "Civilian Clown Female", "models/clown/pm_civ_clown_costume_female.mdl" );

player_manager.AddValidModel( "Civilian Festive Female", "models/festive/pm_civ_festive_human_female.mdl" );
list.Set( "PlayerOptionsModel",  "Civilian Festive Female", "models/festive/pm_civ_festive_human_female.mdl" );


--PATH lua/autorun/cshield.lua:
hook.Add('ScalePlayerDamage','CShield',function(ply,hitgroup,dmg)
	if !dmg:IsFallDamage() and IsValid(ply:GetNWEntity('CShield')) then
		if ply:GetNWEntity('CShield'):GetActive() then
			return true
		end
	end
end)

if SERVER then

	hook.Add('EntityTakeDamage','CShield',function(ent,dmg)
		if ent:IsPlayer() and !dmg:IsFallDamage() and IsValid(ent:GetNWEntity('CShield')) and ent:GetNWEntity('CShield'):GetActive() then
			return true
		end
	end)

	hook.Add('EntityFireBullets','CShield',function(ent,data)
		local shield = ent:GetNWEntity('CShield')
		if IsValid(shield) then
			data.IgnoreEntity = shield
			return true
		end
	end)

	hook.Add('PhysgunPickup','CShield',function(ply,ent)
		if ent:GetClass() == 'shuffle_shield' then return false end
	end)

end

if CLIENT then

	local CDRAW = include('CDRAW.lua')

	hook.Add('EntityFireBullets','CShield',function(ent,data)
		if ent ~= LocalPlayer() then return end
		local shield = ent:GetNWEntity('CShield')
		if IsValid(shield) then
			data.IgnoreEntity = shield
			return true
		end
	end)

	surface.CreateFont('SHLACK',{font='Trebuchet MS',size=32,weight=400})

	local MSW, MSH = ScrW(), ScrH()
	local off_h = MSH/2-32
	local col_bg = Color(0,0,0,192)
	local col_fill = Color(64,128,192,255)
	local col_fill_dmg = Color(128,64,64,255)
	local col_txt = Color(255,255,255)
	local mat_shuffle = Material('models/props_combine/stasisshield_sheet')

	hook.Add('HUDPaint','CShield',function()
		if !IsValid(LocalPlayer()) or !IsValid(LocalPlayer():GetActiveWeapon()) then return end
		local shield = LocalPlayer():GetNWEntity('CShield')
		if IsValid(shield) then
			if !(!shield:GetActive() and !shield:GetDamaged() and LocalPlayer():GetActiveWeapon():GetClass() ~= 'weapon_shield_activator') then
				if shield:GetActive() and !LocalPlayer():ShouldDrawLocalPlayer() then
					render.SetMaterial(mat_shuffle)
					render.OverrideBlend(true,2,4,BLENDFUNC_ADD)
					render.DrawScreenQuadEx(0,0,MSW,MSH)
					render.OverrideBlend(false,2,4,BLENDFUNC_ADD)
				end
				local hp = math.Clamp(shield:Health(),0,shield:GetMaxHealth())
				local distext = shield:GetActive() and ('Active: '..hp..'%') or (shield:GetDamaged() and 'Recharge in '..math.floor(shield:GetActiveOffset()-CurTime())..'...' or 'Shield is inactive')
				local fulfill = shield:GetActive() and (hp/shield:GetMaxHealth()) or (shield:GetDamaged() and (shield:GetActiveOffset()-CurTime())/shield.RechargeTime or 0)
				CDRAW.DrawRect(col_bg,MSW-256-16,off_h,256,64)
				CDRAW.DrawRect((!shield:GetActive() and shield:GetDamaged()) and col_fill_dmg or col_fill,MSW-256-16+4,off_h+4,248*fulfill,56)
				CDRAW.DrawText('SHLACK',MSW-256-8,off_h+16,col_txt,distext)
			end
		end
	end)

end
--PATH lua/autorun/dathomir_pm.lua:
return gluapack()()
--PATH addons/[opt] decals/lua/decals/util/cl_halo.lua:
return gluapack()()
--PATH addons/[opt] decals/lua/decals/load/cl_load.lua:
return gluapack()()
--PATH addons/!discordintegration/lua/autorun/discord_integration.lua:
return gluapack()()
--PATH addons/!discordintegration/lua/discord/core/cl_backend.lua:
return gluapack()()
--PATH lua/autorun/dw_npc.lua:
return gluapack()()
--PATH lua/autorun/engineer.lua:
return gluapack()()
--PATH lua/autorun/explosives_particles.lua:
return gluapack()()
--PATH lua/autorun/fpsfog.lua:

if SERVER then 
	util.AddNetworkString("fpsfog_3dsky") 
	util.AddNetworkString("fpsfog_sendskycamera") 
end

if CLIENT then LocalPlayer().fpsfog_3dsky = GetConVar("r_3dsky"):GetFloat() end

CreateConVar( "fpsfog_active", 0, 8192 + 128, "enables fps saving fog", 0, 1 )
CreateConVar( "fpsfog_skybox", 1, 8192 + 128, "disables skybox", 0, 1 )
CreateConVar( "fpsfog_distance", 6500, 8192 + 128, "distance at which fog becomes opaque", 0, 20000 )
CreateConVar( "fpsfog_thickness", 50, 8192 + 128, "distance at which fog starts", 0, 100 )
CreateConVar( "fpsfog_color_r", 200, 8192 + 128, "red component", 0, 255 )
CreateConVar( "fpsfog_color_g", 200, 8192 + 128, "blue component", 0, 255 )
CreateConVar( "fpsfog_color_b", 200, 8192 + 128, "green component", 0, 255 )

local fpsfog_SC_pos = fpsfog_SC_pos 
local fpsfog_SC_scale = fpsfog_SC_scale

cvars.AddChangeCallback("fpsfog_skybox", function(name, old, new)

	if #player.GetAll() > 0 and SERVER then

		local skyscale = 1
		local skypos = Vector(0,0,0)
		local skybox = 0

		if IsValid(fpsfog_skycamera) then 
			skyscale = fpsfog_skycamera:GetKeyValues().scale 
			skypos = fpsfog_skycamera:GetPos()
			skybox = new
		end

		net.Start("fpsfog_3dsky")
		net.WriteInt(skybox, 3)
		net.WriteInt(skyscale, 8)
		net.WriteVector(skypos)
		net.Broadcast()

	end

end)

net.Receive("fpsfog_3dsky", function(len, ply)

	local active = net.ReadInt(3)
	fpsfog_SC_scale = net.ReadInt(8)
	fpsfog_SC_pos = net.ReadVector()

	LocalPlayer():ConCommand("r_3dsky " .. tostring(active))
	

end)

local fogactive = true
local fogend = 5000
local fogstart = 3000
local fogcolor = Color(83,83,83)

local fpsfog_newcontroller = nil

if SERVER then

	fpsfog_newcontroller = ents.Create("env_fog_controller")

end

--gmod wiki my beloved

local load_queue = {}

hook.Add("PlayerInitialSpawn", "fpsfog_plyspawn", function(ply)
	load_queue[ply] = true
end)

hook.Add("SetupMove", "fpsfog_plyload", function(ply, _, cmd)
	if load_queue[ply] and not cmd:IsForced() then
		load_queue[ply] = nil

		local skyscale = 1
		local skypos = Vector(0,0,0)
		if IsValid(fpsfog_skycamera) then 
			skyscale = fpsfog_skycamera:GetKeyValues().scale 
			skypos = fpsfog_skycamera:GetPos()
		end


		net.Start("fpsfog_3dsky")
		net.WriteInt(GetConVar("fpsfog_skybox"):GetFloat(), 3)
		net.WriteInt(skyscale, 8)
		net.WriteVector(skypos)
		net.Send(ply)

	end
end)


hook.Add( "InitPostEntity", "fpsfog_postinit", function()

	local existingcontrollers = ents.FindByClass("env_fog_controller")

	PrintTable(existingcontrollers)

	for _, v in ipairs(existingcontrollers) do

		v.fpsfog_originalvalue = v:GetKeyValues().farz

	end

	if #existingcontrollers > 1 and SERVER then

		fpsfog_newcontroller:Remove()

	end

	fpsfog_skycamera = ents.FindByClass("sky_camera")[1]

end )


hook.Add("Think", "fpsfog_farz", function()

	local active = GetConVar("fpsfog_active"):GetFloat()
	local fogend = GetConVar("fpsfog_distance"):GetFloat()

	if SERVER then 

		if active == 1 then

			for k, v in pairs(ents.FindByClass("env_fog_controller")) do
			
				v:SetKeyValue("farz", fogend + 250)

			end

		else

			for k, v in pairs(ents.FindByClass("env_fog_controller")) do

				v:SetKeyValue("farz", v.fpsfog_originalvalue or -1)

			end

		end
		
	end

end)

hook.Add("ShutDown", "fpsfog_returnsky", function()

	if CLIENT then
		RunConsoleCommand( "r_3dsky", 1)
	end

end)


local constructmat = Material("gm_construct/color_room")

hook.Add("PreDrawOpaqueRenderables", "fpsfog_removeskybox", function(depth, skybox)


		local active = GetConVar("fpsfog_active"):GetFloat()

		if active == 1 and fpsfog_SC_scale ~= nil then 

			local ply = LocalPlayer()
			local view = render.GetViewSetup()
			local lookdir = view.angles
			local lookpos = view.origin
			local looknorm = Vector(1,0,0)
			looknorm:Rotate(lookdir)
			local fogend = GetConVar("fpsfog_distance"):GetFloat()
			local fpsfog_r = GetConVar("fpsfog_color_r"):GetFloat()
			local fpsfog_g = GetConVar("fpsfog_color_g"):GetFloat()
			local fpsfog_b = GetConVar("fpsfog_color_b"):GetFloat()

			if skybox and GetConVar("fpsfog_skybox"):GetFloat() == 1 then

				render.SetMaterial(constructmat)
				render.DrawQuadEasy((lookpos + looknorm * fogend) / fpsfog_SC_scale + fpsfog_SC_pos, looknorm * -1, 1000000, 1000000, Color(fpsfog_r, fpsfog_g, fpsfog_b))

			elseif GetConVar("fpsfog_skybox"):GetFloat() == 0 then

				render.SetMaterial(constructmat)
				render.DrawQuadEasy((lookpos + looknorm * fogend), looknorm * -1, 1000000, 1000000, Color(fpsfog_r, fpsfog_g, fpsfog_b))

			end

		end




end)

hook.Add("SetupWorldFog", "fpsfog_fog", function()

	local active = GetConVar("fpsfog_active"):GetFloat()

	if active == 1 then

		local fogend = GetConVar("fpsfog_distance"):GetFloat()
		local fogstart = fogend - fogend * (GetConVar("fpsfog_thickness"):GetFloat() / 100)
		local fpsfog_r = GetConVar("fpsfog_color_r"):GetFloat()
		local fpsfog_g = GetConVar("fpsfog_color_g"):GetFloat()
		local fpsfog_b = GetConVar("fpsfog_color_b"):GetFloat()

		render.FogMode(active)
		render.FogColor( fpsfog_r, fpsfog_g, fpsfog_b )
		render.FogMaxDensity(1)
		render.FogStart(fogstart)
		render.FogEnd(fogend)

		return true

	end


end)

hook.Add("SetupSkyboxFog", "fpsfog_skyfog", function(scale)

	local active = GetConVar("fpsfog_active"):GetFloat()

	if active == 1 then

		local fogend = GetConVar("fpsfog_distance"):GetFloat()
		local fogstart = fogend - fogend * (GetConVar("fpsfog_thickness"):GetFloat() / 100)
		local fpsfog_r = GetConVar("fpsfog_color_r"):GetFloat()
		local fpsfog_g = GetConVar("fpsfog_color_g"):GetFloat()
		local fpsfog_b = GetConVar("fpsfog_color_b"):GetFloat()

		render.FogMode(active)
		render.FogColor( fpsfog_r, fpsfog_g, fpsfog_b )
		render.FogMaxDensity(1)
		render.FogStart(fogstart * scale)
		render.FogEnd(fogend * scale)

		return true

	end


end)

list.Set( "DesktopWindows", "fpsfog", {

	title		= "Fps Fog Menu",
	icon		= "icon16/weather_clouds.png",
	width		= 300,
	height		= 380,
	onewindow	= true,
	init		= function( icon, frame )

	local mainframe = frame:Add( "DPanel" )
	mainframe:Dock(FILL)

	local fogenablevar = mainframe:Add( "DCheckBoxLabel" )
	fogenablevar:SetValue(GetConVar("fpsfog_active"):GetFloat() or 0)
	fogenablevar:SetTextColor(Color(0,0,0))
	fogenablevar:SetText("Fog Enabled")
	fogenablevar:Dock(TOP)
	fogenablevar:DockMargin(9, 10, 0, 0)
	fogenablevar:SetConVar("fpsfog_active")

	local fogskyboxvar = mainframe:Add( "DCheckBoxLabel" )
	fogskyboxvar:SetValue(GetConVar("fpsfog_active"):GetFloat() or 0)
	fogskyboxvar:SetTextColor(Color(0,0,0))
	fogskyboxvar:SetText("Skybox Enabled")
	fogskyboxvar:Dock(TOP)
	fogskyboxvar:DockMargin(9, 10, 0, 0)
	fogskyboxvar:SetConVar("fpsfog_skybox")

	local fogendvar = mainframe:Add("DNumSlider")
	fogendvar:SetDecimals(0)
	fogendvar:SetValue(GetConVar("fpsfog_distance"):GetFloat() or 5000)
	fogendvar:SetMinMax(0, 20000)
	fogendvar:Dock(TOP)
	fogendvar:Center()
	fogendvar:DockPadding(10, 10, 0, 0)
	fogendvar.Label:SetTextColor(Color(0,0,0))
	fogendvar:SetText("Fog Distance")
	fogendvar:SetConVar("fpsfog_distance")

	local fogstartvar = mainframe:Add("DNumSlider")
	fogstartvar:SetDecimals(0)
	fogstartvar:SetValue(GetConVar("fpsfog_thickness"):GetFloat() or 25)
	fogstartvar:SetMinMax(0, 100)
	fogstartvar:Dock(TOP)
	fogstartvar:Center()
	fogstartvar:DockPadding(10, 10, 0, 0)
	fogstartvar.Label:SetTextColor(Color(0,0,0))
	fogstartvar:SetText("Fog Thickness")
	fogstartvar:SetConVar("fpsfog_thickness")


	local fogcolorvar = mainframe:Add( "DColorMixer" )
	fogcolorvar:Dock( TOP )
	fogcolorvar:SetAlphaBar(false)
	fogcolorvar:DockPadding(10, 10, 10, 10)
	fogcolorvar:SetConVarR("fpsfog_color_r")
	fogcolorvar:SetConVarG("fpsfog_color_g")
	fogcolorvar:SetConVarB("fpsfog_color_b")

	end})
--PATH addons/[gas] gmodadminsuite-config-master/lua/gmodadminsuite_config.lua:
return gluapack()()
--PATH addons/[gas] gmodadminsuite-config-master/lua/gmodadminsuite_lua_functions.lua:
return gluapack()()
--PATH lua/gmodadminsuite/lang/chinese.lua:
return gluapack()()
--PATH lua/gmodadminsuite/lang/english.lua:
return gluapack()()
--PATH lua/gmodadminsuite/lang/french.lua:
return {
	Name = "French",
	Flag = "flags16/fr.png",
	Phrases = function() return {

		open_menu                 = "Ouvrir Menu",
		menu_nopermission         = "Dsol, mais vous n'avez pas la permission d'accder au menu GmodAdminSuite.",
		menu_unknown_module       = "Dsol, mais le module spcifi n'est pas install ou n'existe pas.",
		menu_disabled_module      = "Dsol, mais ce module est dsactiv.",
		menu_module_nopermission  = "Dsol, mais vous n'avez pas la permission d'accder  ce module.",
		open_gas                  = "Ouvrir GmodAdminSuite",
		module_shortcut           = "Raccourci Module",
		module_shortcut_info      = [[You can quickly access this GmodAdminSuite module through console and chat commands.

		To access the module through your console, type: %s
		To access the module through chat, type: %s

		Additionally, you can bind a key on your keyboard to a specific module.
		To do this, in your console, type: %s

		Make sure to replace KEY with a key on your keyboard of your choice.
		%s]],
		close                     = "Fermer",
		wiki                      = "Wiki",
		licensee                  = "Licenci",
		support                   = "Support",
		module_shop               = "Boutique de Modules",
		welcome                   = "Bienvenue",
		operator                  = "Oprateur",
		script_page               = "Page du Script",
		wiki                      = "Wiki",
		no_modules_available      = "Aucuns modules disponnibles!",
		no_modules_available_info = [[Dsol, but there aren't any GmodAdminSuite modules available for you to use.
		You may have insufficient permissions to use any, or none are enabled.]],
		custom_ellipsis           = "Custom...",
		usergroup_ellipsis        = "Groupe d'Utilisateurs...",
		steamid_ellipsis          = "SteamID...",
		enter_steamid_ellipsis    = "Entrez SteamID...",
		by_distance               = "Par Distance",
		by_usergroup              = "Par Groupes d'Utilisateurs",
		by_team                   = "Par Equipe",
		by_name                   = "Par Nom",
		right_click_to_focus      = "Clic Droit pour faire le focus",
		unknown                   = "Inconnu",
		utilities                 = "Utilitaires",
		player_management         = "Gestion Joueurs",
		administration            = "Administration",
		s_second                  = "1 seconde",
		s_seconds                 = "%d secondes",
		s_minute                  = "1 minute",
		s_minutes                 = "%d minutes",
		s_hour                    = "1 heure",
		s_hours                   = "%d heures",
		second_ago                = "il y a 1 seconde",
		seconds_ago               = "il y a %d secondes",
		minute_ago                = "il y a 1 minute",
		minutes_ago               = "il y a %d minutes",
		hour_ago                  = "il y a 1 heure",
		hours_ago                 = "il y a %d heures",
		just_now                  = "A l'instant",
		click_to_focus            = "Clic pour faire le focus",
		add_steamid               = "SteamID Custom",
		copied                    = "Copi !",
		settings                  = "Paramtres",
		add_steamid_help          = [[Entrez un SteamID ou SteamID64. Exemples:
		SteamID: %s
		SteamID64: %s]],

		setting_default_module = "Module par Dfaut",
		setting_default_module_tip = "Quel module doit tre ouvert lorsque le menu principal GmodAdminSuite est ouvert ?",
		none = "Aucun",
		general = "Gnral",
		localization = "Localisation",
		setting_menu_voicechat = "Autoriser Chat Vocal\nlorsque les menu GAS sont ouverts",
		setting_menu_voicechat_tip = "Les menu GmodAdminSuite ne vous empchent pas de communiquer en jeu lorsqu'ils sont ouverts. Si cette option est active, appuyez simplement sur votre touche dsigne  cet effet pour parler.",
		use_gas_language = "Utiliser le langage GmodAdminSuite",
		default_format = "Format par Dfaut",
		short_date_format = "Format Date Abrge",
		long_date_format = "Format Date Entire",
		short_date_format_tip = "Date format used for shorter date formats\n\nThe default format automatically matches the date format of your region (North America, Europe, etc.)",
		long_date_format_tip = "Date format used for longer date formats",
		permissions = "Permissions",
		module_enable_switch_tip = "Changes to this will only apply after a server restart/map change",
		enabled = "Activ",
		modules = "Modules",
		permissions_help = [[GmodAdminSuite utilise une librairie de permission open-sources nomme OpenPermissions, dveloppe par Billy pour GAS. Elle fournit une gestion optimise des permissions pour les systmes avances fonctionnant sur des serveurs de tous types.
		
		OpenPermissions est l'addon depuis lequel vous contrlerez quels groupes peuvent accder  quels modules, et ce qu'ils peuvent faire avec ces modules.
		Il peut tre ouvert ouvert n'importe quand en crivant "!openpermissions" dans le chat, ou "openpermissions" dans la console en jeu.

		Pour obtenir de l'aide, ou des informations, cliquez sur l'onglet "Aide" dans le menu OpenPermissions.]],
		website = "Site Web",
		fun = "Fun",

		bvgui_copied               = "Copi !",
		bvgui_open_context_menu    = "Ouvrir Menu Contextuel",
		bvgui_open_steam_profile   = "Afficher Profil Steam",
		bvgui_right_click_to_focus = "Clic Droit pour faire le focus",
		bvgui_click_to_focus       = "Clic pour faire le focus",
		bvgui_unknown              = "Inconnu",
		bvgui_no_data              = "Aucune Donnes",
		bvgui_no_results_found     = "Aucun rsultat trouv",
		bvgui_done                 = "Termin",
		bvgui_enter_text_ellipsis  = "Entrez texte...",
		bvgui_loading_ellipsis     = "Chargement...",
		bvgui_pin_tip              = "Appuyez sur ECHAP pour pouvoir de nouveau intragir avec le menu",

} end }
--PATH addons/[gas] gmodadminsuite-jobwhitelist-1.3.4/lua/gmodadminsuite/modules/jobwhitelist/lang/english.lua:
return {
	Name = "English",
	Flag = "flags16/gb.png",
	Phrases = function() return {

		module_name = "Billy's Whitelist",

		insufficient_permissions_jobwhitelist = "The whitelist/blacklist is not enabled for this job,\nand you have insufficient permissions to enable them.",
		no_data                               = "No data",
		type                                  = "Type",
		value                                 = "Value",
		name                                  = "Name",
		added_by                              = "Added by",
		click_delete_entry_tip                = "Click on an entry to delete it!",
		copied                                = "Copied!",
		delete_entry                          = "Delete Entry",
		add_player                            = "Add Player",
		add_usergroup                         = "Add Usergroup",
		add_lua_function                      = "Add Lua Function",
		lua_function                          = "Lua Function",
		script_page                           = "Script Page",
		wiki                                  = "Wiki",
		jobs                                  = "Jobs",
		whitelist                             = "Whitelist",
		blacklist                             = "Blacklist",
		settings                              = "Settings",
		enable_whitelist                      = "Enable Whitelist",
		enable_blacklist                      = "Enable Blacklist",
		default_whitelisted                   = "Whitelisted to by default",
		default_blacklisted                   = "Blacklisted from by default",
		disable_autoswitch                    = "Disable AutoSwitch for this job",
		players                               = "Players",
		job                                   = "Job",
		usergroup                             = "Usergroup",
		distance                              = "Distance",
		click_for_options_tip                 = "Click for options!",
		refreshing_ellipsis                   = "Refreshing...",
		refreshing_in_1_second                = "Refreshing in 1 second",
		refreshing_in_seconds                 = "Refreshing in %s seconds",
		operator                              = "Operator",
		OperatorsSkipWhitelists_help          = "If this is on, Operators will skip whitelists.",
		OperatorsSkipBlacklists_help          = "If this is on, Operators will skip blacklists.",
		ShowUnjoinableJobs_help               = "If off, players won't see the jobs they're blacklisted from/not whitelisted to in the F4 menu.\nIf on, players will see the default state of the F4 menu.",
		ContextMenu_help                      = "If on, then players can interact with bWhitelist through the context menu (recommended)\nIf off, then this feature is disabled.",
		off                                   = "Off",
		FunctionMenuKey_help                  = "Allows you to assign a function key to the bWhitelist menu (F1/F2/F3/F4)",
		AutoSwitch_help                       = "If on, when a player is whitelisted to a job, they will be automatically switched to it. (Only works with SteamIDs)",
		SwitchJobOnUnwhitelist_help           = "If on, when a player is unwhitelisted from their job, they'll be switched back to the default team. (Only works with SteamIDs)",
		SwitchJobOnBlacklist_help             = "If on, when a player is blacklisted from their job, they'll be switched back to the default team. (Only works with SteamIDs)",
		NotWhitelistedMsg_help                = "This is the message the player will see in the bottom right corner when they try to join a job they are not whitelisted to.",
		BlacklistedMsg_help                   = "This is the message the player will see in the bottom right corner when they try to join a job they are blacklisted from.",
		NotifyWhitelisted_help                = "Turn on to notify players when they have been whitelisted to a job. (Only works with SteamIDs)",
		NotifyWhitelisted_Msg_help            = "This is the message the player will see in chat when they are notified of being whitelisted to a job.",
		NotifyUnwhitelisted_help              = "Turn on to notify players when they have been unwhitelisted from a job. (Only works with SteamIDs)",
		NotifyUnwhitelisted_Msg_help          = "This is the message the player will see in chat when they are notified of being unwhitelisted from a job.",
		NotifyBlacklisted_help                = "Turn on to notify players when they have been blacklisted from a job. (Only works with SteamIDs)",
		NotifyBlacklisted_Msg_help            = "This is the message the player will see in chat when they are notified of being blacklisted from a job.",
		NotifyUnblacklisted_help              = "Turn on to notify players when they have been unblacklisted from a job. (Only works with SteamIDs)",
		NotifyUnblacklisted_Msg_help          = "This is the message the player will see in chat when they are notified of being unblacklisted from a job.",
		permissions                           = "Permissions",
		modify_whitelist                      = "Modify Whitelist",
		modify_blacklist                      = "Modify Blacklist",
		enable_disable_whitelist              = "Enable/Disable Whitelist",
		enable_disable_blacklist              = "Enable/Disable Blacklist",
		job_category                          = "Job Category",
		steamid                               = "SteamID",
		all_jobs                              = "ALL JOBS",
		save                                  = "Save",
		all_jobs_in_category                  = "All jobs in category",
		job_categories                        = "Job Categories",
		usergroups                            = "Usergroups",
		steamids                              = "SteamIDs",
		lua_functions                         = "Lua Functions",
		usergroup_ellipsis                    = "Usergroup...",
		steamid_ellipsis                      = "SteamID...",
		enter_steamid_ellipsis                = "Enter SteamID...",
		resets                                = "Resets",
		enable_buttons                        = "Enable Buttons",
		reset_config                          = "Reset Config",
		done_exclamation                      = "Done!",
		reset_permissions_config              = "Reset Permissions Config",
		disable_all_whitelists                = "Disable All Whitelists",
		disable_all_blacklists                = "Disable All Blacklists",
		destroy_whitelist                     = "Destroy Whitelist Data...",
		destroy_blacklist                     = "Destroy Blacklist Data...",
		destroy_all_data                      = "Destroy All Data",
		destroy_all_data_help                 = "Destroys all whitelist and blacklist data, disables all whitelists and blacklists but does NOT reset your configuration.",
		reset_everything                      = "Reset Everything",
		reset_everything_help                 = "Destroys all whitelist and blacklist data, disables all whitelists and blacklists and resets your configuration.",
		disable_buttons                       = "Disable Buttons",
		open_menu                             = "Open Menu",
		add_to_whitelist                      = "Add to Whitelist",
		loading_ellipsis                      = "Loading...",
		no_whitelists_available               = "No whitelists available!",
		add_to_blacklist                      = "Add to Blacklist",
		no_blacklists_available               = "No blacklists available!",
		click_to_focus                        = "Click to focus",
		right_click_to_focus                  = "Right click to focus",
		copy_steamid                          = "Copy SteamID",
		copy_steamid64                        = "Copy SteamID64",
		copy                                  = "Copy",
		default_team_error                    = "You cannot whitelist/blacklist this job because it is the default job.",
		saved_exclamation                     = "Saved!",
		whitelisted                           = "Whitelisted",
		blacklisted                           = "Blacklisted",
		choose_faction                        = "Choose a faction",
		faction_not_permitted                 = "(You are not permitted to join this faction)",
		factions                              = "Factions",
		new_faction                           = "New Faction",
		destroy_faction_data                  = "Destroy Faction Data",
		destroy_faction_data_help             = "Destroys all faction data (e.g. what factions players have chosen)",
		reset_factions_config                 = "Reset Factions Config",
		logo_url                              = "Logo URL... (PNG)",
		faction_name                          = "Faction Name",
		faction_name_tip                      = "The name of this faction",
		description                           = "Description",
		faction_description_tip               = "Players will see the description after hovering over the faction",
		ShowIfNotPermitted                    = "Show even if not permitted",
		ShowIfNotPermitted_help               = "If the player is not permitted to join the faction, should it be shown?",
		SetTeam                               = "Job to set player to",
		SetTeam_help                          = "What job should the player be set to after choosing the faction?",
		WhitelistedTo                         = "Whitelist to",
		WhitelistedTo_help                    = "What jobs should the player be whitelisted to as this faction?",
		BlacklistedFrom                       = "Blacklist from",
		BlacklistedFrom_help                  = "What jobs should the player be blacklisted from as this faction?",
		delete_faction_confirm                = "Are you sure you want to delete this faction?",
		confirm_action                        = "Confirm Action",
		yes                                   = "Yes",
		no                                    = "No",
		save_faction                          = "Save Faction",
		delete_faction                        = "Delete Faction",
		factions_ShowOnFirstJoin              = "Show on first join",
		factions_ShowOnFirstJoin_help         = "Show the factions selector when a player first joins?",
		factions_ShowOnEveryJoin              = "Show on every join",
		factions_ShowOnEveryJoin_help         = "Show the factions selector whenever a player joins?",
		factions_ShowOnEverySpawn             = "Show on every spawn",
		factions_ShowOnEverySpawn_help        = "Show the factions selector whenever a player spawns?",
		factions_HelpText                     = "Help Tip",
		factions_HelpText_help                = "Text to display when no factions are being hovered over",
		factions_OnPopupSound                 = "Popup Sound",
		factions_OnPopupSound_help            = "Sound to play when the factions selector is opened",
		factions_OnHoverSound                 = "Hover Sound",
		factions_OnHoverSound_help            = "Sound to play when a faction is hovered over",
		factions_OnSelectionSound             = "Selection Sound",
		factions_OnSelectionSound_help        = "Sound to play when a faction is selected",
		factions_PermissionDeniedSound        = "Permission Denied Sound",
		factions_PermissionDeniedSound_help   = "Sound to play when a forbidden faction is selected",
		enable_factions                       = "Enable Factions",
		edit_factions                         = "Edit Factions",
		chat_command                          = "Chat Command",
		console_command                       = "Console Command",
		blank_to_disable                      = "Set to blank to disable",
		add_to_all_whitelists                 = "ADD to all whitelists",
		add_to_all_blacklists                 = "ADD to all blacklists",
		remove_from_all_whitelists            = "REMOVE from all whitelists",
		remove_from_all_blacklists            = "REMOVE from all blacklists",
		bulk_actions                          = "Bulk actions",
		add                                   = "Add",
		remove                                = "Remove",
		remove_player                         = "Remove Player",
		remove_usergroup                      = "Remove Usergroup",
		remove_lua_function                   = "Remove Lua Function",
		convert_old_data                      = "Convert old bWhitelist data",
		offline                               = "Offline",
		no_permission_action                  = "You do not have permission to do this!",
		clear_whitelist                       = "Clear Whitelist",
		clear_whitelist_confirm               = "Are you sure you want to clear this whitelist?",
		clear_blacklist                       = "Clear Blacklist",
		clear_blacklist_confirm               = "Are you sure you want to clear this blacklist?",
		enable_all_whitelists                 = "Enable All Whitelists",
		enable_all_blacklists                 = "Enable All Blacklists",
		spawn_as_job                          = "Spawn as job",
		spawn_as_job_tip                      = "The jobs nearer the bottom of your DarkRP jobs.lua file will be prioritized",

} end }
--PATH addons/[gas] gmodadminsuite-jobwhitelist-1.3.4/lua/gmodadminsuite/modules/jobwhitelist/lang/french.lua:
return {
	Name = "French",
	Flag = "flags16/fr.png",
	Phrases = function() return {

		module_name = "Billy's Whitelist",

		insufficient_permissions_jobwhitelist = "La Whitelist/Blacklist ne sont pas actives pour ce mtier,\net vous n'avez pas les permissions suffisantes pour les activer.",
		no_data                               = "Aucune Donnes",
		type                                  = "Type",
		value                                 = "Valeur",
		name                                  = "Nom",
		added_by                              = "Ajout Par",
		click_delete_entry_tip                = "Cliquez sur une entre pour la supprimer !",
		copied                                = "Copi !",
		delete_entry                          = "Supprimer Entre",
		add_player                            = "Ajouter un Joueur",
		add_usergroup                         = "Ajouter Groupe d'Utilisateurs",
		add_lua_function                      = "Ajouter Fonction Lua",
		lua_function                          = "Fonction Lua",
		script_page                           = "Page du Script",
		wiki                                  = "Wiki",
		jobs                                  = "Mtiers",
		whitelist                             = "Whitelist",
		blacklist                             = "Blacklist",
		settings                              = "Paramtres",
		enable_whitelist                      = "Activer Whitelist",
		enable_blacklist                      = "Activer Blacklist",
		default_whitelisted                   = "Whitelist par dfaut",
		default_blacklisted                   = "Blacklist par dfaut",
		disable_autoswitch                    = "Dsactiver l'AutoSwitch pour ce mtier",
		players                               = "Joueurs",
		job                                   = "Mtier",
		usergroup                             = "Groupes d'Utilisateurs",
		distance                              = "Distance",
		click_for_options_tip                 = "Cliquez pour les paramtres !",
		refreshing_ellipsis                   = "Actualisation...",
		refreshing_in_1_second                = "Actualisation dans 1 seconde",
		refreshing_in_seconds                 = "Actualisation dans %s secondes",
		operator                              = "Oprateur",
		OperatorsSkipWhitelists_help          = "Lorsque activ, les Oprateurs outre-passeront les whitelists.",
		OperatorsSkipBlacklists_help          = "Lorsque activ, les Oprateurs outre-passeront les blacklists.",
		ShowUnjoinableJobs_help               = "Lorsque dsactiv, les joueurs ne verront pas les mtiers dont ils ne sont pas whitelists, ou dont ils sont blacklists, dans le menu F4.\nSi activ, les joueurs verront le menu F4 dans son tat normal.",
		ContextMenu_help                      = "Lorsque activ, les joueurs pourront interragir avec bWhitelist  travers le menu contextuel (recommand)\nLorsque dsactiv, cette fonctionnalit est dsactive.",
		off                                   = "Innactif",
		FunctionMenuKey_help                  = "Vous autorise  assigner une touche de fonction au menu bWhitelist (F1/F2/F3/F4)",
		AutoSwitch_help                       = "Lorsque activ, quand un joueur est whitelist, il est automatiquement assign  ce mtier. (Fonctionne seulement avec les SteamIDs)",
		SwitchJobOnUnwhitelist_help           = "Lorsque activ, quand un joueur est retir de la whitelist de son mtier, il est automatiquement assign au mtier par dfaut. (Fonctionne seulement avec les SteamIDs)",
		SwitchJobOnBlacklist_help             = "Lorsque activ, quand un joueur est blacklist de son mtier, il est automatiquement assign au mtier par dfaut. (Fonctionne seulement avec les SteamIDs)",
		NotWhitelistedMsg_help                = "C'est le message affich lorsqu'un joueur essaie de rejoindre un mtier auquel il n'est pas whitelist.",
		BlacklistedMsg_help                   = "C'est le message affich lorsqu'un joueur essaie de rejoindre un mtier auquel il est blacklist.",
		NotifyWhitelisted_help                = "Active les notifications lorsqu'un joueur vient d'tre whitelist sur un mtier. (Fonctionnement seulement avec les SteamIDs)",
		NotifyWhitelisted_Msg_help            = "C'est le message affich lorsqu'un joueur vient d'tre whitelist sur un mtier.",
		NotifyUnwhitelisted_help              = "Active les notifications lorsqu'un joueur vient d'tre retir de la whitelist d'un mtier. (Fonctionnement seulement avec les SteamIDs)",
		NotifyUnwhitelisted_Msg_help          = "C'est le message affich lorsqu'un joueur vient d'tre retir de la whitelist d'un mtier.",
		NotifyBlacklisted_help                = "Active les notifications lorsqu'un joueur vient d'tre blacklist d'un mtier. (Fonctionnement seulement avec les SteamIDs)",
		NotifyBlacklisted_Msg_help            = "C'est le message affich lorsqu'un joueur vient d'tre blacklist d'un mtier.",
		NotifyUnblacklisted_help              = "Active les notifications lorsqu'un joueur vient d'tre retir de la blacklist d'un mtier. (Fonctionnement seulement avec les SteamIDs)",
		NotifyUnblacklisted_Msg_help          = "C'est le message affich lorsqu'un joueur vient d'tre retir de la blacklist d'un mtier.",
		permissions                           = "Permissions",
		modify_whitelist                      = "Modifier Whitelist",
		modify_blacklist                      = "Modifier Blacklist",
		enable_disable_whitelist              = "Activer/Dsactiver Whitelist",
		enable_disable_blacklist              = "Activer/Dsactiver Blacklist",
		job_category                          = "Catgorie du Mtier",
		steamid                               = "SteamID",
		all_jobs                              = "TOUS LES METIERS",
		save                                  = "Sauvegarder",
		all_jobs_in_category                  = "Tous les mtiers dans la catgorie",
		job_categories                        = "Catgories de mtier",
		usergroups                            = "Groupes d'Utilisateurs",
		steamids                              = "SteamIDs",
		lua_functions                         = "Fonctions Lua",
		usergroup_ellipsis                    = "Groupes d'Utilisateurs...",
		steamid_ellipsis                      = "SteamID...",
		enter_steamid_ellipsis                = "Entrez SteamID...",
		resets                                = "Rinitialiser",
		enable_buttons                        = "Activer Boutons",
		reset_config                          = "Rinitialiser Config",
		done_exclamation                      = "Termin !",
		reset_permissions_config              = "Rinitialiser Config Permissions",
		disable_all_whitelists                = "Dsactiver Toutes les Whitelists",
		disable_all_blacklists                = "Dsactiver Toutes les Blacklists",
		destroy_whitelist                     = "Dtruire les Donnes de Whitelist...",
		destroy_blacklist                     = "Dtruire les Donnes de Blacklist...",
		destroy_all_data                      = "Dtruire Toutes les Donnes",
		destroy_all_data_help                 = "Dtruits toutes les donnes de whitelist et de blacklist, dsactive toutes les whitelists et blacklists mais ne rinitialise pas la configuration.",
		reset_everything                      = "Tout Rinitialiser",
		reset_everything_help                 = "Dtruits toutes les donnes de whitelists et blacklists, dsactive toutes les whitelists et blacklists et rinitialise la configuration.",
		disable_buttons                       = "Dtruits les Boutons",
		open_menu                             = "Ouvrir Menu",
		add_to_whitelist                      = "Ajouter  la Whitelist",
		loading_ellipsis                      = "Chargement...",
		no_whitelists_available               = "Aucunes whitelists disponnibles !",
		add_to_blacklist                      = "Ajouter  la Blacklist",
		no_blacklists_available               = "Aucunes blacklists disponnibles !",
		click_to_focus                        = "Clic pour faire le focus",
		right_click_to_focus                  = "Clic Droit pour faire le focus",
		copy_steamid                          = "Copier SteamID",
		copy_steamid64                        = "Copier SteamID64",
		copy                                  = "Copier",
		default_team_error                    = "Vous ne pouvez pas whitelister/blacklister ce mtier car c'est le mtier de base.",
		saved_exclamation                     = "Sauvegard !",
		whitelisted                           = "Whitelist",
		blacklisted                           = "Blacklist",
		choose_faction                        = "Choisissez une fonction",
		faction_not_permitted                 = "(Vous n'tes pas autoris  rejoindre cette faction)",
		factions                              = "Factions",
		new_faction                           = "Nouvelles Faction",
		destroy_faction_data                  = "Dtruire les Donnes de Faction",
		destroy_faction_data_help             = "Dtruits toutes les donnes de faction (ex: what factions players have chosen)",
		reset_factions_config                 = "Rinitialiser Config des Factions",
		logo_url                              = "URL du Logo... (PNG)",
		faction_name                          = "Nom de la Faction",
		faction_name_tip                      = "Le nom de cette faction",
		description                           = "Description",
		faction_description_tip               = "Les joueurs verront la description lorsqu'ils survoleront la faction avec leur curseur",
		ShowIfNotPermitted                    = "Afficher, mme si non-autoris",
		ShowIfNotPermitted_help               = "Si le joueur n'est pas autoris  rejoindre la faction, est-ce que cela doit tre affich ?",
		SetTeam                               = "Mtier dfini pour le joueur",
		SetTeam_help                          = "A quel mtier le joueur doit-il est assign aprs avoir choisit sa faction ?",
		WhitelistedTo                         = "Whitelist pour",
		WhitelistedTo_help                    = "A quels mtiers de cette faction le joueur doit-il tre whitelist ?",
		BlacklistedFrom                       = "Blacklist de",
		BlacklistedFrom_help                  = "De quels mtiers de cette faction le joueur doit-il est blacklist ?",
		delete_faction_confirm                = "Etes-vous certain de vouloir supprimer cette faction ?",
		confirm_action                        = "Confirmer Action",
		yes                                   = "Oui",
		no                                    = "Non",
		save_faction                          = "Sauvegarder Faction",
		delete_faction                        = "Supprimer Faction",
		factions_ShowOnFirstJoin              = "Afficher  la premire connexion",
		factions_ShowOnFirstJoin_help         = "Afficher le menu de slction des factions  la premire connexion d'un joueur ?",
		factions_ShowOnEveryJoin              = "Afficher  chaque connexion",
		factions_ShowOnEveryJoin_help         = "Afficher le menu de slction des factions  chaque connexion d'un joueur ?",
		factions_ShowOnEverySpawn             = "Afficher  chaque apparition",
		factions_ShowOnEverySpawn_help        = "Afficher le menu de slction des factions  chaque apparition d'un joueur ?",
		factions_HelpText                     = "Conseil d'Aide",
		factions_HelpText_help                = "Texte  afficher lorsque le joueur ne survole aucune faction avec son curseur",
		factions_OnPopupSound                 = "Son de Popup",
		factions_OnPopupSound_help            = "Son  jouer lorsque le menu de slction des factions est ouvert",
		factions_OnHoverSound                 = "Son de Survol",
		factions_OnHoverSound_help            = "Son  jouer lorsqu'une faction est survole par le curseur du joueur",
		factions_OnSelectionSound             = "Son de Slction",
		factions_OnSelectionSound_help        = "Son  jouer lorsqu'une faction est slctionne",
		factions_PermissionDeniedSound        = "Son Permission Refuse",
		factions_PermissionDeniedSound_help   = "Song  jouer lorsqu'une faction interdite est slctionne",
		enable_factions                       = "Activer Factions",
		edit_factions                         = "Modifier Factions",
		chat_command                          = "Commande du Chat",
		console_command                       = "Commande de Console",
		blank_to_disable                      = "Laissez vide pour dsactiver",
		add_to_all_whitelists                 = "AJOUTER  toutes les whitelists",
		add_to_all_blacklists                 = "AJOUTER  toutes les blacklists",
		remove_from_all_whitelists            = "SUPPRIMER de toutes les whitelists",
		remove_from_all_blacklists            = "SUPPRIMER de toutes les blacklists",
		bulk_actions                          = "Action de Masse",
		add                                   = "Ajouter",
		remove                                = "Supprimer",
		remove_player                         = "Supprimer Joueur",
		remove_usergroup                      = "Supprimer Groupe d'Utilisateurs",
		remove_lua_function                   = "Supprimer Fonction Lua",
		convert_old_data                      = "Convertir anciennes donnes de bWhitelist",
		offline                               = "Hors Ligne",
		add_usergroup                         = "Ajouter Groupe d'Utilisateurs",
		no_permission_action                  = "Vous n'avez pas la permission de faire cela !",

} end }
--PATH addons/[gas] gmodadminsuite-logging-2.4.8/lua/gmodadminsuite/modules/logging/lang/spanish.lua:
return gluapack()()
--PATH lua/gmodadminsuite/modules/playerdatabase/lang/french.lua:
return {
	Name = "French",
	Flag = "flags16/fr.png",
	Phrases = function() return {

		module_name = "Player Database",

		right_click_to_focus    = "Clic Droit pour faire le focus",
		steamid                 = "SteamID",
		name                    = "Nom",
		usergroup               = "Groupe",
		ip_address              = "Adresse IP",
		last_seen               = "Dernire Connexion",
		copy_steamid            = "Copier SteamID",
		copy_steamid64          = "Copier SteamID64",
		copy_usergroup          = "Copier Groupe d'Utilisateurs",
		copy_ip_address         = "Copier IP Address",
		copy_name               = "Copier Nom",
		copy_steam_profile_link = "Copier Lien de Page de Profil Steam",
		search                  = "Chercher",
		country                 = "Pays",
		copy_country            = "Copier Country",
		search_usergroup        = "Chercher Groupe d'Utilisateurs",
		search_ip_address       = "Chercher Adresse IP",
		search_country          = "Chercher Pays",
		search_name             = "Chercher Nom",
		none                    = "< none >",
		cancel                  = "Annuler",
		steamid                 = "SteamID",

} end }
--PATH lua/gmodadminsuite/cl_country_codes.lua:
--Source: https://datahub.io/core/country-list

GAS.CountryCodes = GAS.CountryCodes or GAS.spon.decode([[[S02DMS08DominicaS02IOS1EBritish Indian Ocean TerritoryS02FMS1FMicronesia, Federated States ofS02AMS07ArmeniaS02JOS06JordanS02CMS08CameroonS02BMS07BermudaS02FOS0DFaroe IslandsS02AOS06AngolaS02DOS12Dominican RepublicS02BOS1FBolivia, Plurinational State ofS02TKS07TokelauS02ZMS06ZambiaS02COS08ColombiaS02TMS0CTurkmenistanS02RSS06SerbiaS02MSS0AMontserratS02PSS13Palestine, State ofS02PMS19Saint Pierre and MiquelonS02SMS0ASan MarinoS02MMS07MyanmarS02WSS05SamoaS02USS0DUnited StatesS02BQS20Bonaire, Sint Eustatius and SabaS02ROS07RomaniaS02MOS05MacaoS02GQS11Equatorial GuineaS02SOS07SomaliaS02AQS0AAntarcticaS02BSS07BahamasS02TWS19Taiwan, Province of ChinaS02ASS0EAmerican SamoaS02MWS06MalawiS02IQS04IraqS02CRS0ACosta RicaS02ESS05SpainS02GUS04GuamS02ZWS08ZimbabweS02AUS09AustraliaS02UYS07UruguayS02LSS07LesothoS02KMS07ComorosS02PYS08ParaguayS02LUS0ALuxembourgS02AWS05ArubaS02NUS04NiueS02GWS0DGuinea-BissauS02BWS08BotswanaS02IMS0BIsle of ManS02VIS14Virgin Islands, U.S.S02CWS08CuraaoS02SKS08SlovakiaS02GTS09GuatemalaS02KYS0ECayman IslandsS02ECS07EcuadorS02GSS2CSouth Georgia and the South Sandwich IslandsS02LYS05LibyaS02FIS07FinlandS02KWS06KuwaitS02GIS09GibraltarS02IDS09IndonesiaS02CYS06CyprusS02BYS07BelarusS02ETS08EthiopiaS02HKS09Hong KongS02GYS06GuyanaS02CIS0ECte d'IvoireS02BBS08BarbadosS02EGS05EgyptS02VUS07VanuatuS02KGS0AKyrgyzstanS02YES05YemenS02GBS0EUnited KingdomS02LIS0DLiechtensteinS02GDS07GrenadaS02LKS09Sri LankaS02ADS07AndorraS02CUS04CubaS02CDS25Congo, the Democratic Republic of theS02KIS08KiribatiS02GMS06GambiaS02LBS07LebanonS02UMS24United States Minor Outlying IslandsS02AFS0BAfghanistanS02SBS0FSolomon IslandsS02GFS0DFrench GuianaS02CGS05CongoS02MFS1ASaint Martin (French part)S02BFS0CBurkina FasoS02CFS18Central African RepublicS02KES05KenyaS02KHS08CambodiaS02NFS0ENorfolk IslandS02EHS0EWestern SaharaS02SDS05SudanS02CNS05ChinaS02MDS14Moldova, Republic ofS02IES07IrelandS02NES05NigerS02CHS0BSwitzerlandS02AGS13Antigua and BarbudaS02WFS11Wallis and FutunaS02TFS1BFrench Southern TerritoriesS02GHS05GhanaS02KNS15Saint Kitts and NevisS02BTS06BhutanS02PFS10French PolynesiaS02BES07BelgiumS02VAS1DHoly See (Vatican City State)S02BJS05BeninS02ILS06IsraelS02NLS0BNetherlandsS02RUS12Russian FederationS02FJS04FijiS02NCS0DNew CaledoniaS02DJS08DjiboutiS02GLS09GreenlandS02INS05IndiaS02ALS07AlbaniaS02THS08ThailandS02CLS05ChileS02SLS0CSierra LeoneS02DES07GermanyS02BLS11Saint BarthlemyS02HNS08HondurasS02PTS08PortugalS02SJS16Svalbard and Jan MayenS02GNS06GuineaS02MYS08MalaysiaS02SSS0BSouth SudanS02BNS11Brunei DarussalamS02TJS0ATajikistanS02MHS10Marshall IslandsS02TLS0BTimor-LesteS02MRS0AMauritaniaS02ARS09ArgentinaS02SRS08SurinameS02PRS0BPuerto RicoS02MLS04MaliS02PWS05PalauS02MQS0AMartiniqueS02TRS06TurkeyS02VNS08Viet NamS02TTS13Trinidad and TobagoS02TNS07TunisiaS02GPS0AGuadeloupeS02STS15Sao Tome and PrincipeS02SNS07SenegalS02PNS08PitcairnS02KPS26Korea, Democratic People's Republic ofS02HUS07HungaryS02BRS06BrazilS02JPS05JapanS02MUS09MauritiusS02TVS06TuvaluS02FRS06FranceS02GRS06GreeceS02SVS0BEl SalvadorS02ERS07EritreaS02YTS07MayotteS02KRS12Korea, Republic ofS02HRS07CroatiaS02IRS19Iran, Islamic Republic ofS02NRS05NauruS02NOS06NorwayS02LRS07LiberiaS02MPS18Northern Mariana IslandsS02SXS19Sint Maarten (Dutch part)S02UZS0AUzbekistanS02MXS06MexicoS02BDS0ABangladeshS02HTS05HaitiS02BVS0DBouvet IslandS02CVS0ACape VerdeS02TDS04ChadS02LVS06LatviaS02MZS0AMozambiqueS02SYS14Syrian Arab RepublicS02SZS09SwazilandS02FKS1BFalkland Islands (Malvinas)S02AXS0Eland IslandsS02MNS08MongoliaS02MES0AMontenegroS02TZS1CTanzania, United Republic ofS02MVS08MaldivesS02MKS2AMacedonia, the Former Yugoslav Republic ofS02KZS0AKazakhstanS02CXS10Christmas IslandS02NPS05NepalS02NZS0BNew ZealandS02ATS07AustriaS02CAS06CanadaS02BAS16Bosnia and HerzegovinaS02BZS06BelizeS02CZS0ECzech RepublicS02GAS05GabonS02AZS0AAzerbaijanS02ITS05ItalyS02LTS09LithuaniaS02DZS07AlgeriaS02PKS08PakistanS02CCS17Cocos (Keeling) IslandsS02LAS20Lao People's Democratic RepublicS02GGS08GuernseyS02NAS07NamibiaS02MTS05MaltaS02PAS06PanamaS02SAS0CSaudi ArabiaS02GES07GeorgiaS02MAS07MoroccoS02AES14United Arab EmiratesS02PLS06PolandS02LCS0BSaint LuciaS02QAS05QatarS02RWS06RwandaS02MCS06MonacoS02ZAS0CSouth AfricaS02SCS0ASeychellesS02VCS20Saint Vincent and the GrenadinesS02BGS08BulgariaS02TCS18Turks and Caicos IslandsS02JES06JerseyS02EES07EstoniaS02NGS07NigeriaS02PHS0BPhilippinesS02VES21Venezuela, Bolivarian Republic ofS02SHS2CSaint Helena, Ascension and Tristan da CunhaS02PES04PeruS02SES06SwedenS02RES08RunionS02NIS09NicaraguaS02VGS17Virgin Islands, BritishS02BHS07BahrainS02TGS04TogoS02BIS07BurundiS02UAS07UkraineS02MGS0AMadagascarS02PGS10Papua New GuineaS02SGS09SingaporeS02AIS08AnguillaS02TOS05TongaS02SIS08SloveniaS02OMS04OmanS02CKS0CCook IslandsS02UGS06UgandaS02HMS21Heard Island and McDonald IslandsS02DKS07DenmarkS02JMS07JamaicaS02ISS07Iceland)]])
GAS.CountryCodesReverse = GAS.CountryCodesReverse or GAS:table_Flip(GAS.CountryCodes)
--PATH addons/[gas] gmodadminsuite-logging-2.4.8/lua/gmodadminsuite/modules/logging/sh_init.lua:
return gluapack()()
--PATH lua/gmodadminsuite/cl_menubar.lua:
local function L(phrase, ...)
	if (#({...}) == 0) then
		return GAS:Phrase(phrase)
	else
		return GAS:PhraseFormat(phrase, nil, ...)
	end
end

hook.Add("PopulateMenuBar", "gmodadminsuite.menubar", function(p)
	p.GASMenu = p:AddOrGetMenu("GmodAdminSuite")

	p.GASMenu:AddOption(L"open_gas", function()
		RunConsoleCommand("gmodadminsuite")
	end):SetIcon("icon16/shield.png")

	p.GASMenu:AddSpacer()

	for ident, tab in pairs(GAS.Modules.Info) do
		hook.Add("gmodadminsuite:LoadModule:"..ident, "gmodadminsuite.menubar", function()
			p.GASMenu:AddOption(tab.Name, function()
				GAS:PlaySound("popup")
				RunConsoleCommand("gmodadminsuite", ident)
			end):SetIcon(tab.Icon)
			hook.Remove("gmodadminsuite:LoadModule:"..ident, "gmodadminsuite.menubar")
		end)
	end
end)
--PATH lua/autorun/grunt_addon.lua:
return gluapack()()
--PATH lua/autorun/gwarm_addon.lua:
player_manager.AddValidModel( "Pirate Gwarm", "models/player/ohanak_gang/pm_pirate_gwarm.mdl" );
list.Set( "PlayerOptionsModel",  "Pirate Gwarm", "models/player/ohanak_gang/pm_pirate_gwarm.mdl" );


--PATH lua/imagetool/cl_net.lua:
--[[
         AsterionStaff 2022.
        This script was created from the developers of the AsterionTeam.
        You can get more information from one of the links below:
            Site - https://asterion.games
            Discord - https://discord.gg/CtfS8r5W3M
        
        developer(s):
            Selenter - https://steamcommunity.com/id/selenter

         Chop your own wood and it will warm you twice.
]]--


--   
net.Receive("image.SendImage", function()
    local length = net.ReadUInt(32)
    local id = net.ReadUInt(32)
    local data = net.ReadData(length)

    local uncompressed = util.Decompress(data)
    local info = util.JSONToTable(uncompressed)

    ImageTool.imageList[id] = info -- 

    if ImageTool:IsUsesTool(LocalPlayer()) then
        LocalPlayer():ChatPrint(ImageTool.prefix .. " Image was added successfully! (ID: " .. id .. ")")
    end
end)

--  
net.Receive("image.RemoveImage", function()
    local id = net.ReadUInt(32)

    ImageTool.imageList[id] = nil -- 

    if ImageTool:IsUsesTool(LocalPlayer()) then
        LocalPlayer():ChatPrint(ImageTool.prefix .. " Image has been successfully deleted! (ID: " .. id .. ")")
    end
end)

--   
net.Receive("image.RemoveImageAll", function()
    for id in pairs(ImageTool:GetImages()) do
        ImageTool.imageList[id] = nil -- 
    end

    if ImageTool:IsUsesTool(LocalPlayer()) then
        LocalPlayer():ChatPrint(ImageTool.prefix .. " All pictures have been removed from the world!")
    end
end)

--    
net.Receive("image.SaveImage", function()
    local url = net.ReadString()

    local history = ImageTool:GetHistory() or {}

    --   url    ,   
    for k, v in ipairs(history) do
        if v == url then
            return
        end
    end

    table.insert(history, url)
    ImageTool:SaveHistory(history)

    ImageTool:LoadingHistory()
end)
--PATH lua/autorun/jawa.lua:
player_manager.AddValidModel( "Jawa",		"models/jajoff/sw/jawa.mdl" );
list.Set( "PlayerOptionsModel", "Jawa",		"models/jajoff/sw/jawa.mdl" );
--PATH lua/autorun/jawa02.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/init.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/autorun/cl_forcepowers.lua:
local blur = Material("pp/blurscreen")

local SelectorWidth = 410
local SelectorItemHeight = 64
local SelectedItemHeight = 72
local SelectedItemHalfHeight = SelectedItemHeight * 0.5
local StartOffsetToSelectable = 5
local FrameThickness = 3
local SelectorHeight = SelectedItemHeight + 2 * FrameThickness

local X = ScrW() * 0.5 - SelectorWidth * 0.5
local Y = ScrH() - SelectorHeight - 25

local MouseWheelScroller = false
local Selected = 1
local smOffset = 0
local smAlpha = 0
local FadeTimer = 0

LSCS.ForceSelector = LSCS.ForceSelector or {
	KeyActivate = CreateClientConVar( "lscs_key_selector_activate", KEY_LALT, true, true ),
	KeyNext = CreateClientConVar( "lscs_key_selector_next", KEY_H, true, true ),
	KeyPrev = CreateClientConVar( "lscs_key_selector_prev", KEY_G, true, true ),
	KeyUse = CreateClientConVar( "lscs_key_selector_use", KEY_F, true, true ),
}

if IsValid( LSCS.ForceSelector.Selector ) then
	LSCS.ForceSelector.Selector:Remove()
	LSCS.ForceSelector.Selector = nil
end

local function CreateSelector()
	local ForceSelector = vgui.Create("DPanel")
	ForceSelector:SetPos( X, Y )
	ForceSelector:SetSize( SelectorWidth, SelectorHeight + 25 )
	ForceSelector.Paint = function( self, w, h )
		local Time = CurTime()

		local smRate = RealFrameTime()
		local tAlpha = (FadeTimer > Time) and 1 or 0

		smAlpha = smAlpha + math.Clamp(tAlpha - smAlpha,-smRate * 3,smRate * 50)

		if smAlpha == 0 then return end

		local fading_white = Color(255,255,255,smAlpha * 255)
		local fading_blue = Color(0, 127, 255, smAlpha * 255)

		local pX, pY = self:GetPos()
		surface.SetMaterial( blur )
		blur:SetFloat( "$blur", 5 )
		blur:Recompute()
		if render then render.UpdateScreenEffectTexture() end
		surface.SetDrawColor( 255, 255, 255, fading_white.a )
		surface.DrawTexturedRect( -pX, -pY, ScrW(), ScrH() )
		surface.SetDrawColor( 0, 0, 0, 200 * smAlpha )
		surface.DrawRect( 0, 0, w, h )

		local StartX = w * 0.5 + smOffset

		local xh = SelectorItemHeight
		local yh = SelectorHeight

		local ply = LocalPlayer()

		local Rate = RealFrameTime() * 450

		smOffset = math.Clamp(smOffset - math.Clamp(smOffset,-Rate,Rate),-xh * 0.6,xh * 0.6)
		local ForcePowers = ply:lscsGetForceAbilities()

		local Selection = ForcePowers[ Selected ]

		if not Selection then return end

		local SelectionPlus = {}
		local SelectionMinus = {}

		local StartIDp = Selected
		local StartIDm = StartIDp

		for ID = 1, 3 do
			StartIDp = StartIDp + 1
			StartIDm = StartIDm - 1

			if StartIDp > #ForcePowers then
				StartIDp = 1
			end
			if StartIDm < 1 then
				StartIDm = #ForcePowers
			end

			SelectionPlus[ ID ] = ForcePowers[ StartIDp ]
			SelectionMinus[ ID ] = ForcePowers[ StartIDm ]
		end

		surface.SetDrawColor( fading_white )

		surface.SetMaterial( Selection.icon )

		if smOffset ~= 0 then
			surface.DrawTexturedRect( StartX - xh * 0.5, (yh - xh) * 0.5, xh, xh )
		else
			surface.DrawTexturedRect( StartX - SelectedItemHalfHeight + 3, FrameThickness + 3, SelectedItemHeight - 6, SelectedItemHeight - 6 )
			draw.SimpleText( Selection.item.name, "LSCS_FONT", w * 0.5, h - 13, fading_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		end

		local addX = SelectedItemHalfHeight + StartOffsetToSelectable
		for _, obj in pairs( SelectionPlus ) do
			surface.SetMaterial( obj.icon )
			surface.DrawTexturedRect( StartX + addX, yh - xh, xh, xh )
			addX = addX + xh
		end

		local subX = -xh - SelectedItemHalfHeight - StartOffsetToSelectable
		for _, obj in pairs( SelectionMinus ) do
			surface.SetMaterial( obj.icon )
			surface.DrawTexturedRect( StartX + subX, yh - xh, xh, xh )
			subX = subX - xh
		end

		surface.DrawRect( 0, 0, FrameThickness, h )
		surface.DrawRect( w - FrameThickness, 0, FrameThickness, h )

		surface.SetDrawColor( fading_blue )

		local Thickness = (smOffset ~= 0) and (3 + math.floor( math.abs( math.cos( CurTime() * 100 ) * 6 )) ) or FrameThickness -- looks cool

		local fXstat = w * 0.5 - SelectedItemHalfHeight
		surface.DrawRect( fXstat, 0, SelectedItemHeight, Thickness )
		surface.DrawRect( fXstat, yh - Thickness, SelectedItemHeight, Thickness )
		surface.DrawRect( fXstat, Thickness, Thickness, yh - 2 * Thickness )
		surface.DrawRect( fXstat + SelectedItemHeight - Thickness, Thickness, Thickness, yh - 2 * Thickness )
	end

	LSCS.ForceSelector.Selector = ForceSelector
end

local ID_IN_USE

local function Use( ID )
	ID_IN_USE = ID

	net.Start("lscs_force_use")
		net.WriteInt( ID, 8 ) -- 127 equipped force powers are enough?
		net.WriteBool( true )
	net.SendToServer()
end

local function StopUse( ID )
	ID_IN_USE = nil

	net.Start("lscs_force_use")
		net.WriteInt( ID, 8 )
		net.WriteBool( false )
	net.SendToServer()
end

net.Receive( "lscs_force_use", function( len )
	ID_IN_USE = nil
end )

local NextNav = 0

local function Prev( dont_set_time )
	if not IsValid( LSCS.ForceSelector.Selector ) then CreateSelector() end

	local Time = CurTime()
	if NextNav > Time then return end
	NextNav = Time + 0.01

	local ply = LocalPlayer()

	if not IsValid( ply ) or not ply:lscsGetForceAllowed() then return end

	local ForcePowers = ply:lscsGetForceAbilities()

	if #ForcePowers == 0 then return end

	Selected = Selected + 1

	surface.PlaySound( "lscs/force_next.mp3" )

	if Selected > #ForcePowers then
		Selected = 1
	end

	smOffset = smOffset + SelectorItemHeight

	if dont_set_time then return end

	FadeTimer = CurTime() + 2
end

local function Next( dont_set_time )
	if not IsValid( LSCS.ForceSelector.Selector ) then CreateSelector() end

	local Time = CurTime()
	if NextNav > Time then return end
	NextNav = Time + 0.01

	local ply = LocalPlayer()

	if not IsValid( ply ) or not ply:lscsGetForceAllowed() then return end

	local ForcePowers = ply:lscsGetForceAbilities()

	if #ForcePowers == 0 then return end

	Selected = Selected - 1

	surface.PlaySound( "lscs/force_next.mp3" )

	if Selected < 1 then
		Selected = #ForcePowers
	end

	smOffset = smOffset - SelectorItemHeight

	if dont_set_time then return end

	FadeTimer = CurTime() + 2
end

local function PlayerButtonDown( ply, button )
	local selector = LSCS.ForceSelector

	local InVehicle = ply:InVehicle()

	local AllowForce = not InVehicle or (InVehicle and ply:GetAllowWeaponsInVehicle())

	if AllowForce then
	-- this needs to be reworked at some point to the same method used as direct inputs
		if button == selector.KeyActivate:GetInt() and ply:lscsGetForceAllowed() then
			if #ply:lscsGetForceAbilities() == 0 then return end

			MouseWheelScroller = true
			FadeTimer = CurTime() + 9999
		end
		if button == selector.KeyUse:GetInt() then
			Use( Selected )
		end
		if button == selector.KeyNext:GetInt() then
			Prev() -- inverted lmao
		end
		if button == selector.KeyPrev:GetInt() then
			Next()
		end
	end

	local Input = LSCS.KeyToForce[ button ]

	if not Input then return end

	local ForcePowers = ply:lscsGetForceAbilities()

	for _, name in pairs( Input ) do
		for ID, power in pairs( ForcePowers ) do
			if power.item.id == name then
				Use( ID )
			end
		end
	end
end

local function PlayerButtonUp( ply, button )
	local selector = LSCS.ForceSelector

	if button == selector.KeyActivate:GetInt() then
		MouseWheelScroller = false
		FadeTimer = 0
	end
	if ID_IN_USE and button == selector.KeyUse:GetInt() then
		StopUse( ID_IN_USE )
	end

	local Input = LSCS.KeyToForce[ button ]

	if not Input then return end

	local ForcePowers = ply:lscsGetForceAbilities()

	for _, name in pairs( Input ) do
		for ID, power in pairs( ForcePowers ) do
			if power.item.id == name then
				StopUse( ID )
			end
		end
	end
end

if game.SinglePlayer() then -- holy shit i hate gmod so much why dont these hooks run in SP holy fucking shit
	local IS_MOUSE_ENUM = {
		[MOUSE_LEFT] = true,
		[MOUSE_RIGHT] = true,
		[MOUSE_MIDDLE] = true,
		[MOUSE_4] = true,
		[MOUSE_5] = true,
		[MOUSE_WHEEL_UP] = true,
		[MOUSE_WHEEL_DOWN] = true,
	}

	local function InputPressed( key )
		if IS_MOUSE_ENUM[ key ] then
			return input.IsMouseDown( key ) 
		else
			return input.IsKeyDown( key ) 
		end
	end

	local OldPressed = {false, false,false,false}
	local OldPressedForce = {}

	hook.Add( "Think", "!!!lscs_gmods_prediction_system_is_cancer", function()
		local ply = LocalPlayer()

		local selector = LSCS.ForceSelector

		local SelectorButtons = {selector.KeyActivate:GetInt(),selector.KeyUse:GetInt(),selector.KeyNext:GetInt(),selector.KeyPrev:GetInt()}

		for id, key in pairs( SelectorButtons ) do
			local pressed = InputPressed( key )

			if OldPressed[ id ] ~= pressed then
				OldPressed[ id ] = pressed
				if pressed then
					PlayerButtonDown( ply, key )
				else
					PlayerButtonUp( ply, key )
				end
			end
		end

		for _, entry in pairs( LSCS.Force ) do
			local key = entry.cmd:GetInt()
			if not OldPressedForce[ key ] then OldPressedForce[ key ] = false end
	
			local pressed = InputPressed( key )

			if OldPressedForce[ key ] ~= pressed then
				OldPressedForce[ key ] = pressed
				if pressed then
					PlayerButtonDown( ply, key )
				else
					PlayerButtonUp( ply, key )
				end
			end
		end
	end )
else
	hook.Add( "PlayerButtonDown", "!!!!lscs_buttondownstuff", function( ply, button )
		if IsFirstTimePredicted() then
			PlayerButtonDown( ply, button )
		end
	end)

	hook.Add( "PlayerButtonUp", "!!!!lscs_buttonupstuff", function( ply, button )
		if IsFirstTimePredicted() then
			PlayerButtonUp( ply, button )
		end
	end)
end

local LAST_USED_LMB

hook.Add( "PlayerBindPress", "!!!!_lscs_playerbindpress", function( ply, bind, pressed )
	if not MouseWheelScroller then

		if not LAST_USED_LMB then return end

		if bind ~= "+attack" or pressed then return end

		StopUse( LAST_USED_LMB )

		return
	end

	if ply:InVehicle() and not ply:GetAllowWeaponsInVehicle() then return end

	local Time = CurTime()

	if bind == "invprev" then
		if pressed then
			Prev( true )
		end

		return true
	end
	if bind == "invnext" then
		if pressed then
			Next( true )
		end

		return true
	end
	if bind == "+attack" then
		if pressed then
			LAST_USED_LMB = Selected

			Use( Selected )
		else
			if LAST_USED_LMB then
				StopUse( LAST_USED_LMB )
			end

			LAST_USED_LMB = nil
		end

		return true
	end
end )

--PATH addons/[miecze] moce i hilty/lua/lscs/autorun/lscs_damage.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/autorun/lscs_soundscripts_vader.lua:
sound.Add( {
	name = "vader_saber_on",
	channel = CHAN_STATIC,
	volume = 0.6,
	level = 75,
	pitch = { 100, 100 },
	sound = "lscs/saber/vader_saber_on.mp3",
} )

sound.Add( {
	name = "saber_idle6",
	channel = CHAN_STATIC,
	volume = 0.6,
	level = 75,
	pitch = { 100, 100 },
	sound = "lightsaber/saber_loop6.wav",
} )

sound.Add( {
	name = "saber_on3",
	channel = CHAN_STATIC,
	volume = 0.6,
	level = 75,
	pitch = { 100, 100 },
	sound = "lightsaber/saber_on3.wav",
} )

sound.Add( {
	name = "saber_off3",
	channel = CHAN_STATIC,
	volume = 0.6,
	level = 75,
	pitch = { 100, 100 },
	sound = "lightsaber/saber_off3.wav",
} )
--PATH addons/[miecze] moce i hilty/lua/lscs/combos/aggresive.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/combos/agiledual.lua:
COMBO.id = "agiledual"
COMBO.PrintName = "Agile {Dual Wield}"
COMBO.Author = "RareLogan"
COMBO.Description = ""

COMBO.DeflectBullets = true
COMBO.AutoBlock = true

COMBO.LeftSaberActive = true

COMBO.HoldType = "wos-meleestamina-type"

COMBO.DamageMultiplier = 0.75
COMBO.BPDrainPerHit = 75
COMBO.BlockDistanceNormal = 45 -- distance of crosshair to block pos until  a normal block is detected with this stance. Avoid using this. Only uncomment if you really need it.
COMBO.BlockDistancePerfect = 15 -- distance of crosshair to block pos until  a perfect block is detected with this stance. Avoid using this. Only uncomment if you really need it.

COMBO.Attacks = {
	["SLAM"] = {
		AttackAnim = "judge_a_s1_t1",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:Freeze( true )
			ply:SetVelocity( Vector(0,0,200) )
			ply:lscsSuppressFalldamage( CurTime() + 5 )

			timer.Simple( 0.25, function()
				if IsValid( weapon ) and IsValid( ply ) then
					ply:SetVelocity( Vector(0,0,-1500) )
				end
			end)
		end,
		FinishAttack = function( weapon, ply )
			ply:Freeze( false )
		end,
		Delay = 0.0,
		Duration = 1.5,
	},
	["FRONT_DASH"] = {
		AttackAnim = "b_right_t2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
			timer.Simple(0.6, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)

			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1600 )
			else
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 600 + Vector(0,0,40) )
			end
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 1.3,
	 },
	["BACKFLIP"] = {
		AttackAnim = "rollback",
		BeginAttack = function( weapon, ply )  
			weapon:SetDMGActive( false )

			ply:SetVelocity( Vector(0,0,250) - Angle(0,ply:EyeAngles().y,0):Forward() * 100 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.5,
	},
	["ROLL_RIGHT"] = {
		AttackAnim = "rollright",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) + Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["ROLL_LEFT"] = {
		AttackAnim = "rollleft",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) - Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["____"] = {
		AttackAnim = "b_c1_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 2, CurTime() + 0.3, 0.3, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.25,
		Duration = 0.5,
	},
	["-45-"] = {
		AttackAnim = "vanguard_b_s1_t1",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.8,
	},
	["+45+"] = {
		AttackAnim = "wos_bs_shared_kick",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.8,
	},
	["W_S_"] = {
		AttackAnim = "vanguard_h_right_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.7, Vector(250,0,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.7, 0.2, Vector(100,0,0) )
			ply:lscsSetTimedMove( 3, CurTime() + 0.9, 0.7, Vector(0,0,0) )

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
			timer.Simple(0.8, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 1.6,
	},
	["__S_"] = {
		AttackAnim = "h_right_t2",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.3,
	},
	["_A__"] = {
		AttackAnim = "ryoku_b_left_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(0,-100,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.3, 0.3, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.25,
		Duration = 0.7,
	},
	["___D"] = {
		AttackAnim = "ryoku_r_right_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(0,100,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.3, 0.3, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.25,
		Duration = 0.7,
	},
	["W__D"] = {
		AttackAnim = "ryoku_b_right_t2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.4, Vector(1,1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.3,
		Duration = 1,
	},
	["WA__"] = {
		AttackAnim = "ryoku_b_left_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(25,-25,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.3,
		Duration = 1,
	},
	["__SD"] = {
		AttackAnim = "vanguard_r_left_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-1,1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.2,
		Duration = 0.7,
	},
	["_AS_"] = {
		AttackAnim = "vanguard_r_left_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-1,-1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.3,
		Duration = 0.7,
	},
	["W___"] = {
		AttackAnim = "b_c4_t2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1000 )
			end
			ply:lscsSetTimedMove( 1, CurTime(), 0.9, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.8,
	},
}
--PATH addons/[miecze] moce i hilty/lua/lscs/combos/bladedancerdual.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/combos/defensive.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/combos/defensive.lua:
COMBO.id = "defensive"
COMBO.PrintName = "Defensive"
COMBO.Author = "Miller"
COMBO.Description = "Defensive stance for defense."

COMBO.DeflectBullets = true
COMBO.AutoBlock = true

COMBO.LeftSaberActive = false

COMBO.HoldType = "slam"

COMBO.Attacks = {
	["SLAM"] = {
		AttackAnim = "slashdown",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:Freeze( true )
			ply:SetVelocity( Vector(0,0,200) )
			ply:lscsSuppressFalldamage( CurTime() + 5 )

			timer.Simple( 0.5, function()
				if IsValid( weapon ) and IsValid( ply ) then
					ply:SetVelocity( Vector(0,0,-1500) )
				end
			end)
		end,
		FinishAttack = function( weapon, ply )
			ply:Freeze( false )
		end,
		Delay = 0.0,
		Duration = 1.5,
	},
	["FRONT_DASH"] = {
		AttackAnim = "h_c1_charge",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1600 )
			else
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 600 + Vector(0,0,40) )
			end
		end,

		FinishAttack = function( weapon, ply ) end,
		Delay = 0.2,
		Duration = 0.6,
	 },
	["BACKFLIP"] = {
		AttackAnim = "rollback",
		BeginAttack = function( weapon, ply )  
			weapon:SetDMGActive( false )

			ply:SetVelocity( Vector(0,0,250) - Angle(0,ply:EyeAngles().y,0):Forward() * 50 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.5,
	},
	["ROLL_RIGHT"] = {
		AttackAnim = "rollright",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) + Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["ROLL_LEFT"] = {
		AttackAnim = "rollleft",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) - Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["____"] = {
		AttackAnim = "flourish_bow_basic",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.6,
	},
	["-45-"] = {
		AttackAnim = "flourish_bow_basic",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 1.2,
	},
	["+45+"] = {
		AttackAnim = "a_combo4",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.3,
	},
	["W_S_"] = {
		AttackAnim = "flourish_bow_basic",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.7, Vector(250,0,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.7, 0.2, Vector(100,0,0) )
			ply:lscsSetTimedMove( 3, CurTime() + 0.9, 0.4, Vector(0,0,0) )

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
			timer.Simple(0.6, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.6,
	},
	["__S_"] = {
		AttackAnim = "judge_r_s1_t2",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.6,
	},
	["_A__"] = {
		AttackAnim = "judge_r_left_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.2, Vector(0,-100,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.2, 0.1, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.6,
	},
	["___D"] = {
		AttackAnim = "judge_r_right_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.2, Vector(0,100,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.2, 0.1, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.6,
	},
	["W__D"] = {
		AttackAnim = "judge_a_right_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.4, Vector(1,1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.2,
		Duration = 0.6,
	},
	["WA__"] = {
		AttackAnim = "judge_a_left_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(25,-25,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.6,
	},
	["__SD"] = {
		AttackAnim = "judge_a_right_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-1,1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.6,
	},
	["_AS_"] = {
		AttackAnim = "judge_a_left_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-1,-1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.6,
	},
	["W___"] = {
		AttackAnim = "judge_a_s1_t2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1000 )
			end
			ply:lscsSetTimedMove( 1, CurTime(), 0.9, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 1.2,
	},
}

--PATH addons/[miecze] moce i hilty/lua/lscs/combos/juyo-vaapaddual.lua:
COMBO.id = "vaapaddual"
COMBO.PrintName = "Juyo-Vaapad(VII) {Duel Wield}"
COMBO.Author = ""
COMBO.Description = ""

COMBO.DeflectBullets = true
COMBO.AutoBlock = true

COMBO.LeftSaberActive = true

COMBO.HoldType = "wos-meleestamina-type"

COMBO.DamageMultiplier = 1.75
COMBO.BPDrainPerHit = 75

COMBO.Attacks = {
	["SLAM"] = {
		AttackAnim = "judge_a_s1_t1",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:Freeze( true )
			ply:SetVelocity( Vector(0,0,200) )
			ply:lscsSuppressFalldamage( CurTime() + 5 )

			timer.Simple( 0.25, function()
				if IsValid( weapon ) and IsValid( ply ) then
					ply:SetVelocity( Vector(0,0,-1500) )
				end
			end)
		end,
		FinishAttack = function( weapon, ply )
			ply:Freeze( false )
		end,
		Delay = 0.0,
		Duration = 1.5,
	},
	["FRONT_DASH"] = {
		AttackAnim = "b_right_t2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
			timer.Simple(0.6, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)

			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1600 )
			else
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 200 + Vector(0,0,40) )
			end
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 1.3,
	 },
	["BACKFLIP"] = {
		AttackAnim = "rollback",
		BeginAttack = function( weapon, ply )  
			weapon:SetDMGActive( false )

			ply:SetVelocity( Vector(0,0,250) - Angle(0,ply:EyeAngles().y,0):Forward() * 100 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.5,
	},
	["ROLL_RIGHT"] = {
		AttackAnim = "rollright",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) + Angle(0,ply:EyeAngles().y,0):Right() * 100 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["ROLL_LEFT"] = {
		AttackAnim = "rollleft",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) - Angle(0,ply:EyeAngles().y,0):Right() * 100 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["____"] = {
		AttackAnim = "pure_a_s1_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 2, CurTime() + 0.3, 0.3, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.25,
		Duration = 0.5,
	},
	["-45-"] = {
		AttackAnim = "judge_b_s2_t1",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.8,
	},
	["+45+"] = {
		AttackAnim = "judge_h_s2_t3",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.8,
	},
	["W_S_"] = {
		AttackAnim = "ryoku_h_s1_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.7, Vector(250,0,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.7, 0.2, Vector(100,0,0) )
			ply:lscsSetTimedMove( 3, CurTime() + 0.9, 0.7, Vector(0,0,0) )

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
			timer.Simple(0.8, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 1.6,
	},
	["__S_"] = {
		AttackAnim = "wos_judge_h_s1_t1",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.3,
	},
	["_A__"] = {
		AttackAnim = "vanguard_r_left_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(0,-100,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.3, 0.3, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.25,
		Duration = 0.7,
	},
	["___D"] = {
		AttackAnim = "pure_b_left_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(0,100,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.3, 0.3, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.25,
		Duration = 0.7,
	},
	["W__D"] = {
		AttackAnim = "judge_h_right_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.4, Vector(1,1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.3,
		Duration = 1,
	},
	["WA__"] = {
		AttackAnim = "judge_h_left_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(25,-25,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.3,
		Duration = 1,
	},
	["__SD"] = {
		AttackAnim = "ryoku_b_right_t2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-1,1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.2,
		Duration = 0.7,
	},
	["_AS_"] = {
		AttackAnim = "ryoku_b_s2_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-1,-1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.3,
		Duration = 0.7,
	},
	["W___"] = {
		AttackAnim = "wos_phalanx_b_s3_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1000 )
			end
			ply:lscsSetTimedMove( 1, CurTime(), 0.9, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.8,
	},
}
LSCS:Reload()
--PATH addons/[miecze] moce i hilty/lua/lscs/combos/vader.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/content/blades_eri.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/content/blades_gica.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/content/blades_ihatemylife.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/content/blades_inq.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/content/force_barrier.lua:
local function endBarrier(ply)
	ply._lscsBarrierTime = nil
	hook.Add( "EntityTakeDamage", "EntityDamageExample", function( target, dmginfo )
		if target == ply then
			dmginfo:ScaleDamage( 1 )
		else return end
	end)
	ply._lscsForceBarrier = false
	ply._SfBarrierTime = nil
end

local force = {}
force.PrintName = "Barrier"
force.Author = "Solace"
force.Description = "Protect yourself from incoming damage."
force.id = "sfbarrier"
force.OnClk =  function( ply, TIME )
	if not ply._lscsForceBarrier then return end
	
	ply:lscsTakeForce()
	
	hook.Add( "EntityTakeDamage", "EntityDamageExample", function( target, dmginfo )
		if target == ply then
			print(target)
			dmginfo:ScaleDamage( 0.2 )
		else return end
	end)
	
	local effectdata = EffectData()
		effectdata:SetOrigin( ply:GetPos() )
		effectdata:SetEntity( ply )
	util.Effect( "force_barrier", effectdata, true, true )
	
	if ply._SfBarrierTime < CurTime() then endBarrier(ply) end
	if not ply:Alive() then endBarrier(ply) end
end
force.StartUse = function( ply )
	local Time = CurTime()

	local CanBarrier = (ply._lscsNextForce or 0) < Time
	if not CanBarrier then return end

	ply._lscsNextForce = Time + 10
	
	if ply:lscsGetForce() < 50 then return end
			
	ply._lscsForceBarrier = true
	ply._SfBarrierTime = CurTime() + 10

	ply:lscsTakeForce( 50 )
	ply:EmitSound("lscs/force/protect.mp3")
end
force.StopUse = function( ply )
end
LSCS:RegisterForce( force )
--PATH addons/[miecze] moce i hilty/lua/lscs/content/force_healother.lua:
local force = {}

force.PrintName = "Heal Other"
force.Author = "Madminer2243 and Douglas"
force.Description = "Heal targeted player."
force.id = "sharedhealing" -- lowercase only

force.Equip = function(ply)
    print("Equipped Target Healing")
end

force.UnEquip = function(ply)
    print("Unequipped Target Healing")
end

-- Function to heal a player
local function HealPlayer(player, amount)
    local currentHealth = player:Health()
    local maxHealth = player:GetMaxHealth()
    local newHealth = math.min(currentHealth + amount, maxHealth)
    player:SetHealth(newHealth)
end

force.StartUse = function(ply)
    if ply:lscsGetForce() < 10 then
        return  -- Minimum force requirement not met
    end

    ply:lscsTakeForce(10)  -- Consume force points

    local target = ply:GetEyeTrace().Entity  -- Get the position where the player is aiming
    if not target == nil and target:IsPlayer() then
        HealPlayer(target,25)
        local effectdata = EffectData()
        effectdata:SetOrigin(target:GetPos())
        effectdata:SetEntity(target)
        util.Effect("force_heal", effectdata, true, true)
    end

    -- Emit sound effect for the lightning
    ply:EmitSound("ambient/energy/zap7.wav")
    -- Play animation or gesture
    LSCS:PlayVCDSequence(ply, "gesture_signal_halt", 0)
end

force.StopUse = function(ply)
    -- Called when the force power key is released
end

LSCS:RegisterForce(force)
--PATH lua/lscs/content/force_pull.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/content/force_shrinkself.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/content/force_shrinkself.lua:
local force = {}
force.PrintName = "Shrink Self"
force.Author = "Midnight"
force.Description = "Shrink yourself by using the Force!"
force.id = "shrink"

force.StartUse = function(ply)
    if ply:lscsGetForce() < 10 then return end -- Check if the player has enough Force points

    ply:lscsTakeForce(10) -- Deduct Force points required to use the power

    ply:SetModelScale(0.5, 1) -- Scale the player's model down to 50%
    ply:EmitSound("npc/combine_gunship/ping_search.wav") -- Play sound effect
    LSCS:PlayVCDSequence(ply, "gesture_signal_halt", 0) -- Play animation

    -- Optional: Reset the player's scale after 10 seconds
    timer.Create("ResetModelScale_" .. ply:EntIndex(), 10, 1, function()
        if IsValid(ply) then
            ply:SetModelScale(1, 1) -- Reset to normal size
        end
    end)
end

force.StopUse = function(ply)
    -- Called when the force power key is released
    -- In this case, nothing is needed here
end

LSCS:RegisterForce(force)

--PATH addons/[miecze] moce i hilty/lua/lscs/content/force_wizforce_shield_forward.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/content/hilts_ihatemylife.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/content/memetis_powers.lua:
local force = {}
force.PrintName = "Boulder Throw"
force.Author = "Memeti"
force.Description = "Lob a boulder at your foe"
force.id = "boulderthrow"
force.Cooldown = 30
force.StartUse = function( ply )
    if ply:lscsGetForce() < 40 then return end -- do we have enough force points ?
    local Time = CurTime()
    if not ply.ConfirmBoulder or ply.ConfirmBoulder < CurTime() then
        ply.ConfirmBoulder = CurTime() + 5
        ply:ChatPrint("Activate again to confirm boulder throw.")
        return
    end
    ply.ConfirmBoulder = nil

	ply:lscsTakeForce( 40 ) -- take amount of force we need
    
	LSCS:PlayVCDSequence( ply, "gesture_signal_halt", 0 ) -- play animation
    
    local ent = ents.Create( "boulder" )
    ent:SetPos( ply:EyePos() + (ply:GetAimVector() * 60) )
    ent:SetAngles( ply:EyeAngles() )
    ent:Spawn()
    ent:SetOwner( ply )

    local phys = ent:GetPhysicsObject()
    if (phys:IsValid()) then
        phys:SetVelocity( ply:GetAimVector() * 1200 )
    end

    return true
end
LSCS:RegisterForce( force )


local force = {}
force.PrintName = "Whirlwind"
force.Author = "Memeti"
force.Description = "Use the force to lift your target"
force.id = "whirlwind"
force.OnClk =  function( ply, TIME )
    if not IsValid( ply.WindTarget ) then return end
    if ply.WindTarget:IsPlayer() and not ply.WindTarget:Alive() then ply.WindTarget = nil return end
    local vec = ( ( ply:EyePos() + ply:GetAimVector()*ply.WindDistance  ) - ply.WindTarget:GetPos() )
    local vec2 = ( ( ply:EyePos() + ply:GetAimVector()*2*ply.WindDistance  ) - ply.WindTarget:GetPos() )

    if ply.WindTarget:IsPlayer() or ply.WindTarget:IsNPC() then
        ply.WindTarget:SetLocalVelocity( vec*10 )
    else
        local phys = ply.WindTarget:GetPhysicsObject()
        phys:SetVelocity( vec*10 )
    end

    ply:lscsTakeForce( 1 )

    if ply:lscsGetForce() < 1 then
        local ed = EffectData()
        ed:SetOrigin( ply.WindTarget:GetPos() + Vector( 0, 0, 36 ) )
        ed:SetRadius( 128 )
        util.Effect( "rb655_force_repulse_out", ed, true, true )
        if ply.WindTarget:IsPlayer() then
            if timer.Exists("force_whirlwind_p1_" .. ply.WindTarget:SteamID64()) then
                timer.Remove("force_whirlwind_p1_" .. ply.WindTarget:SteamID64())
            end
            ply.WindTarget:SetNW2Float( "wOS_Hates_Devs.WhirlwindCooldown", CurTime() + 5 )
        end
        ply.WindTarget = nil
    end

    if not ply:KeyReleased( IN_ATTACK2 ) then return end

    local ed = EffectData()
    ed:SetOrigin( ply.WindTarget:GetPos() + Vector( 0, 0, 36 ) )
    ed:SetRadius( 128 )
    util.Effect( "rb655_force_repulse_out", ed, true, true )
    if ply.WindTarget:IsPlayer() or ply.WindTarget:IsNPC() then
        ply.WindTarget:SetLocalVelocity( vec2*10 )
    else
        local phys = ply.WindTarget:GetPhysicsObject()
        phys:SetVelocity( vec2*10 )
    end
    if ply.WindTarget:IsPlayer() then
        if timer.Exists("force_whirlwind_p1_" .. ply.WindTarget:SteamID64()) then
            timer.Remove("force_whirlwind_p1_" .. ply.WindTarget:SteamID64())
        end
        ply.WindTarget:SetNW2Float( "wOS_Hates_Devs.WhirlwindCooldown", CurTime() + 5 )
    end
    ply.WindTarget = nil
end
force.StartUse = function( ply )
    if ply:lscsGetForce() < 1 then return end
    if IsValid( ply.WindTarget ) then return end
    local tr = util.TraceLine( util.GetPlayerTrace( ply ) )
    local dist = tr.HitPos:Distance( ply:GetPos() )
    if not tr.Entity then return end
    if tr.LFS then return end
    if string.match(tr.Entity:GetClass(), "_pod") then return end
    if dist >= 400 then return end
    ply.WindTarget = tr.Entity
    ply.WindDistance = dist

    return true
end
force.StopUse = function( ply )
    if not IsValid( ply.WindTarget ) then return end
    local ed = EffectData()
    ed:SetOrigin( ply.WindTarget:GetPos() + Vector( 0, 0, 36 ) )
    ed:SetRadius( 128 )
    util.Effect( "rb655_force_repulse_out", ed, true, true )

    ply.WindTarget = nil
end
LSCS:RegisterForce( force )


local force = {}
force.PrintName = "Cloak"
force.Author = "Memeti"
force.Description = "Shroud yourself in the force"
force.id = "cloak" -- lowercase only
-- force.Spawnable = false  -- uncomment to unlist in q-menu
force.Cooldown = 10 -- cooldown in seconds

force.OnClk =  function( ply, TIME )
    if not ply:GetNWBool("IsCloaked", false) then return end
    if not ply.LSCS_Cloak then return end
    if ply:lscsGetForce() < 0.2 then ply:EndCloak() return end
    ply:lscsTakeForce( 1.5 )
end

force.StartUse = function( ply )
    if ply:lscsGetForce() < 1 then return end
    if ply:GetNWBool("IsCloaked", false) then
        ply.LSCS_Cloak = false
        ply:EndCloak()
        return
    end
    ply:SetNWBool("IsCloaked", true)
    ply.LSCS_Cloak = true

    return true
end

force.StopUse = function( ply )
	return
end

LSCS:RegisterForce( force )

local force = {}
force.PrintName = "Cloak II"
force.Author = "Valkorius"
force.Description = "Shroud yourself in the force for longer"
force.id = "cloakii" -- lowercase only
-- force.Spawnable = false  -- uncomment to unlist in q-menu
force.Cooldown = 10 -- cooldown in seconds

force.OnClk =  function( ply, TIME )
    if not ply:GetNWBool("IsCloaked", false) then return end
    if not ply.LSCS_Cloakii then return end
    if ply:lscsGetForce() < 0.2 then ply:EndCloak() return end
    ply:lscsTakeForce( .75 )
end

force.StartUse = function( ply )
    if ply:lscsGetForce() < 1 then return end
    if ply:GetNWBool("IsCloaked", false) then
        ply.LSCS_Cloakii = false
        ply:EndCloak()
        return
    end
    ply:SetNWBool("IsCloaked", true)
    ply.LSCS_Cloakii = true

    return true
end

force.StopUse = function( ply )
	return
end

LSCS:RegisterForce( force )

local force = {}
force.PrintName = "Cloak III"
force.Author = "Valkorius"
force.Description = "Shroud yourself in the force for even longer"
force.id = "cloakiii" -- lowercase only
-- force.Spawnable = false  -- uncomment to unlist in q-menu
force.Cooldown = 10 -- cooldown in seconds

force.OnClk =  function( ply, TIME )
    if not ply:GetNWBool("IsCloaked", false) then return end
    if not ply.LSCS_Cloakiii then return end
    if ply:lscsGetForce() < 0.2 then ply:EndCloak() return end
    ply:lscsTakeForce( 0.4 )
end

force.StartUse = function( ply )
    if ply:lscsGetForce() < 1 then return end
    if ply:GetNWBool("IsCloaked", false) then
        ply.LSCS_Cloakiii = false
        ply:EndCloak()
        return
    end
    ply:SetNWBool("IsCloaked", true)
    ply.LSCS_Cloakiii = true

    return true
end

force.StopUse = function( ply )
	return
end

LSCS:RegisterForce( force )


local function EndAdrenaline(ply)
    if not ply.lscs_adrenaline then return end
    ply:SetRunSpeed(ply:GetRunSpeed() - 200)
    ply.lscs_adrenaline = false
end
local force = {}
force.PrintName = "Adrenaline"
force.Author = "UCCROW"
force.Description = "Speed yourself up with the force"
force.id = "adrenaline" -- lowercase only
-- force.Spawnable = false  -- uncomment to unlist in q-menu
force.Cooldown = 10 -- cooldown in seconds

force.OnClk =  function( ply, TIME )
    if not ply.lscs_adrenaline then return end
    if ply:lscsGetForce() < 1 then EndAdrenaline(ply) return end
    ply:lscsTakeForce(2)
end

force.StartUse = function( ply )
    if ply.lscs_adrenaline then return end
    ply.lscs_adrenaline = true
    ply:SetRunSpeed(ply:GetRunSpeed() + 200)

    return true
end

force.StopUse = function( ply )
    if not ply.lscs_adrenaline then return end
	ply.lscs_adrenaline = false
    ply:SetRunSpeed(ply:GetRunSpeed() - 200)
end

LSCS:RegisterForce( force )

local function EndAdrenalineii(ply)
    if not ply.lscs_adrenalineii then return end
    ply:SetRunSpeed(ply:GetRunSpeed() - 400)
    ply.lscs_adrenalineii = false
end
local force = {}
force.PrintName = "Adrenaline II"
force.Author = "Valkorius"
force.Description = "Speed yourself up with the force even more"
force.id = "adrenalineii" -- lowercase only
-- force.Spawnable = false  -- uncomment to unlist in q-menu
force.Cooldown = 10 -- cooldown in seconds

force.OnClk =  function( ply, TIME )
    if not ply.lscs_adrenalineii then return end
    if ply:lscsGetForce() < 1 then EndAdrenalineii(ply) return end
    ply:lscsTakeForce(2)
end

force.StartUse = function( ply )
    if ply.lscs_adrenalineii then return end
    ply.lscs_adrenalineii = true
    ply:SetRunSpeed(ply:GetRunSpeed() + 400)

    return true
end

force.StopUse = function( ply )
    if not ply.lscs_adrenalineii then return end
	ply.lscs_adrenalineii = false
    ply:SetRunSpeed(ply:GetRunSpeed() - 400)
end

LSCS:RegisterForce( force )

local function EndAdrenalineiii(ply)
    if not ply.lscs_adrenalineiii then return end
    ply:SetRunSpeed(ply:GetRunSpeed() - 600)
    ply.lscs_adrenalineiii = false
end
local force = {}
force.PrintName = "Adrenaline III"
force.Author = "Valkorius"
force.Description = "Speed yourself up with the force even even more"
force.id = "adrenalineiii" -- lowercase only
-- force.Spawnable = false  -- uncomment to unlist in q-menu
force.Cooldown = 10 -- cooldown in seconds

force.OnClk =  function( ply, TIME )
    if not ply.lscs_adrenalineiii then return end
    if ply:lscsGetForce() < 1 then EndAdrenalineiii(ply) return end
    ply:lscsTakeForce(2)
end

force.StartUse = function( ply )
    if ply.lscs_adrenalineiii then return end
    ply.lscs_adrenalineiii = true
    ply:SetRunSpeed(ply:GetRunSpeed() + 600)

    return true
end

force.StopUse = function( ply )
    if not ply.lscs_adrenalineiii then return end
	ply.lscs_adrenalineiii = false
    ply:SetRunSpeed(ply:GetRunSpeed() - 600)
end

LSCS:RegisterForce( force )

local function EndAdrenalineiiii(ply)
    if not ply.lscs_adrenalineiiii then return end
    ply:SetRunSpeed(ply:GetRunSpeed() - 600)
    ply.lscs_adrenalineiii = false
end
local force = {}
force.PrintName = "Shadowstep"
force.Author = "Valkorius"
force.Description = "Shh nothing to see here."
force.id = "adrenalineiiii" -- lowercase only
-- force.Spawnable = false  -- uncomment to unlist in q-menu
force.Cooldown = 10 -- cooldown in seconds

force.OnClk =  function( ply, TIME )
    if not ply.lscs_adrenalineiiii then return end
    if ply:lscsGetForce() < 1 then EndAdrenalineiiii(ply) return end
    ply:lscsTakeForce(0.1)
end

force.StartUse = function( ply )
    if ply.lscs_adrenalineiiii then return end
    ply.lscs_adrenalineiiii = true
    ply:SetRunSpeed(ply:GetRunSpeed() + 600)

    return true
end

force.StopUse = function( ply )
    if not ply.lscs_adrenalineiiii then return end
	ply.lscs_adrenalineiiii = false
    ply:SetRunSpeed(ply:GetRunSpeed() - 600)
end

LSCS:RegisterForce( force )


local force = {}
force.PrintName = "Better Heal"
force.Author = "Memeti"
force.Description = "Heal yourself using the Force at suspicious speeds"
force.id = "betterheal"
force.Cooldown = 2
force.StartUse = function( ply )
	local available = ply:lscsGetForce()
	local need = ply:GetMaxHealth() - ply:Health()
    local MaxHeal = ply:GetMaxHealth() * 0.2

	if need > 0 and available >= 5 then
		local take = math.min( need, available, MaxHeal )
        local ForceUse = math.Round((take / MaxHeal)*10)
		ply:lscsTakeForce( ForceUse )
		ply:SetHealth( math.min(ply:Health() + take ) )

		ply:EmitSound("lscs/force/heal.mp3")

		local effectdata = EffectData()
			effectdata:SetOrigin( ply:GetPos() )
			effectdata:SetEntity( ply )
		util.Effect( "force_heal", effectdata, true, true )

        return true
	end

    return false
end
LSCS:RegisterForce( force )


local force = {}
force.PrintName = "Greater Heal"
force.Author = "Midnight"
force.Description = "Heal yourself using the Force within seconds"
force.id = "greaterheal"
force.Cooldown = 20
force.StartUse = function( ply )
	local available = ply:lscsGetForce()
	local need = ply:GetMaxHealth() - ply:Health()
    local MaxHeal = ply:GetMaxHealth() * 20

	if need > 0 and available >= 5 then
		local take = math.min( need, available, MaxHeal )
        local ForceUse = math.Round((take / MaxHeal)*10)
		ply:lscsTakeForce( ForceUse )
		ply:SetHealth( math.min(ply:Health() + take ) )

		ply:EmitSound("lscs/force/heal.mp3")

		local effectdata = EffectData()
			effectdata:SetOrigin( ply:GetPos() )
			effectdata:SetEntity( ply )
		util.Effect( "force_heal", effectdata, true, true )

        return true
	end

    return false
end
LSCS:RegisterForce( force )

local force = {}
force.PrintName = "Grand Heal"
force.Author = "Midnight"
force.Description = "Fully recover yourself with the force"
force.id = "grandheal"
force.Cooldown = 60
force.StartUse = function( ply )
	local available = ply:lscsGetForce()
	local need = ply:GetMaxHealth() - ply:Health()
    local MaxHeal = ply:GetMaxHealth() * 5000

	if need > 0 and available >= 5 then
		local take = math.min( need, available, MaxHeal )
        local ForceUse = math.Round((take / MaxHeal)*10)
		ply:lscsTakeForce( ForceUse )
		ply:SetHealth( math.min(ply:Health() + take ) )

		ply:EmitSound("lscs/force/heal.mp3")

		local effectdata = EffectData()
			effectdata:SetOrigin( ply:GetPos() )
			effectdata:SetEntity( ply )
		util.Effect( "force_heal", effectdata, true, true )

        return true
	end

    return false
end
LSCS:RegisterForce( force )

local force = {}
force.PrintName = "Teleport"
force.Author = "Memeti"
force.Description = "Transmit yourself to a location using the Force"
force.id = "teleport"
force.Cooldown = 2
force.StartUse = function( ply )
    local forceuse = 20
    if ply:lscsGetForce() < forceuse then return end

    local speed = 4000;
    local bFoundEdge = false;

    ply:SetNW2Float("wOS.ShowBlink", 0 );

    local hullTrace = util.TraceHull({
        start = ply:EyePos(),
        endpos = ply:EyePos() + ply:EyeAngles():Forward() * 1500,
        filter = ply,
        mins = Vector(-16, -16, 0),
        maxs = Vector(16, 16, 9)
    });

    local groundTrace = util.TraceEntity({
        start = hullTrace.HitPos + Vector(0, 0, 1),
        endpos = hullTrace.HitPos - (ply:EyePos() - ply:GetPos()),
        filter = ply
    }, ply);

    local edgeTrace;

    if (hullTrace.Hit and hullTrace.HitNormal.z <= 0) then
        local ledgeForward = Angle(0, hullTrace.HitNormal:Angle().y, 0):Forward();
        edgeTrace = util.TraceEntity({
            start = hullTrace.HitPos - ledgeForward * 33 + Vector(0, 0, 40),
            endpos = hullTrace.HitPos - ledgeForward * 33,
            filter = ply
        }, ply);

        if (edgeTrace.Hit and !edgeTrace.AllSolid) then
            local clearTrace = util.TraceHull({
                start = hullTrace.HitPos,
                endpos = hullTrace.HitPos + Vector(0, 0, 35),
                mins = Vector(-16, -16, 0),
                maxs = Vector(16, 16, 1),
                filter = ply
            });

            bFoundEdge = !clearTrace.Hit;
        end;
    end;

    if (!bFoundEdge and groundTrace.AllSolid) then
        return;
    end;

    local endPos = ( bFoundEdge and edgeTrace.HitPos ) or groundTrace.HitPos;

    ply:SetPos( endPos )
    ply:EmitSound("blink/exit" .. math.random(1, 2) .. ".wav");

    ply:lscsTakeForce( forceuse )

    return true
end
LSCS:RegisterForce( force )

local force = {}
force.PrintName = "Rebuke"
force.Author = "Memeti"
force.Description = "Strengthen your resolve and reflect a percentage of damage back to the attacker"
force.id = "rebuke"
force.Cooldown = 10
force.StartUse = function( ply )
    local forceuse = 20
	local CanDo = ply:lscsGetForce() >= forceuse
	if not CanDo then return end

	ply:SetNWFloat("lscs_rebuke", CurTime() + 10)
    ply:lscsTakeForce( forceuse )

    return true
end
LSCS:RegisterForce( force )

local force = {}
force.PrintName = "Group Heal"
force.Author = "Apollo"
force.Description = "Mend the injuries of your nearby allies"
force.id = "groupheal"
force.Cooldown = 10
force.StartUse = function( ply )
    local forceuse = 60
    local CanDo = ply:lscsGetForce() >= forceuse
	if not CanDo then return end

    for k,v in ipairs(ents.FindInSphere(ply:GetPos(), 150)) do
        if not IsValid(v) or not v:IsPlayer() or not v:Alive() then continue end
        v:SetHealth(math.min(v:Health() + v:GetMaxHealth()*0.4, v:GetMaxHealth()))
        local effectdata = EffectData()
			effectdata:SetOrigin( v:GetPos() )
			effectdata:SetEntity( v )
		util.Effect( "force_heal", effectdata, true, true )
    end
    local ent = ents.Create("pfx4_0b")
    local stopvfx = 1.5
    ent:SetPos(ply:GetPos())
    ent:SetOwner(ply)
    ent:SetParent(ply)
    ent:Spawn()
    timer.Simple(stopvfx, function()
        if not IsValid(ent) then return end
        SafeRemoveEntity(ent)
    end)

    ply:lscsTakeForce( forceuse )

    return true
end
LSCS:RegisterForce( force )

local force = {}
force.PrintName = "Wave"
force.Author = "Apollo"
force.Description = "Create a ripple in the force to repel and damage your opponents"
force.id = "forcewave"
force.Cooldown = 5
force.StartUse = function( ply )
    local forceuse = 40
    local CanDo = ply:lscsGetForce() >= forceuse
    if not CanDo then return end

    for k,v in ipairs(ents.FindInCone(ply:GetPos(), ply:GetAimVector(), 250, 0.5)) do
        if not IsValid(v) then continue end
        v:TakeDamage(75, ply, ply)
        local plypos = ply:GetPos()
        local vpos = v:GetPos()
        local dir = (vpos - plypos)
        local dist = dir:LengthSqr()
        dir:Normalize()
        local maxforce = 300
        local pushforce = math.max(maxforce / dist, 1)
        v:SetVelocity((dir + Vector(0,0,0.4)) * pushforce)
    end

    ply:lscsTakeForce( forceuse )

    return true
end
LSCS:RegisterForce( force )

local force = {}
force.PrintName = "Blind"
force.Author = "Memeti"
force.Description = "Enter your opponent's mind and blind them for a short time"
force.id = "blind"
force.Cooldown = 15
force.StartUse = function( ply )
    local forceuse = 80
    local CanDo = ply:lscsGetForce() >= forceuse
    if not CanDo then return end

    for k, v in ipairs(ents.FindInSphere(ply:GetPos(), 200)) do
        if not IsValid(v) or not v:IsPlayer() or not v:Alive() or v == ply then continue end
        v:ScreenFade(SCREENFADE.OUT, Color(0, 0, 0, 255), 0.5, 10)
    end

    ply:lscsTakeForce( forceuse )

    return true
end
LSCS:RegisterForce( force )
--PATH addons/[miecze] moce i hilty/lua/lscs/content/tenkara.hilt.lua:
return gluapack()()
--PATH lua/lvs_framework/autorun/lvs_bulletsystem.lua:
return gluapack()()
--PATH lua/lvs_framework/autorun/lvs_damagenotify.lua:

if CLIENT then 
	net.Receive( "lvs_hurtmarker", function( len )
		if not LVS.ShowHitMarker then return end

		local ply = LocalPlayer()

		local vehicle = ply:lvsGetVehicle()

		if not IsValid( vehicle ) then return end

		vehicle:HurtMarker( net.ReadFloat() )
	end )

	net.Receive( "lvs_hitmarker", function( len )
		if not LVS.ShowHitMarker then return end

		local ply = LocalPlayer()

		local vehicle = ply:lvsGetVehicle()

		local IsCrit = net.ReadBool()

		if not IsValid( vehicle ) then
			hook.Run( "LVS:OnHudIndicator", ply,  IsCrit and "crit" or "hit" )

			return
		end

		if IsCrit then
			vehicle:CritMarker()
		else
			vehicle:HitMarker()
		end
	end )

	net.Receive( "lvs_killmarker", function( len )
		if not LVS.ShowHitMarker then return end

		local ply = LocalPlayer()

		local vehicle = ply:lvsGetVehicle()

		if not IsValid( vehicle ) then
			hook.Run( "LVS:OnHudIndicator", ply, "kill" )

			return
		end

		vehicle:KillMarker()
	end )

	net.Receive( "lvs_armormarker", function( len )
		if not LVS.ShowHitMarker then return end

		local ply = LocalPlayer()

		local vehicle = ply:lvsGetVehicle()

		local IsDamage = net.ReadBool()

		if not IsValid( vehicle ) then
			hook.Run( "LVS:OnHudIndicator", ply, IsDamage and "armorcrit" or "armor" )

			return
		end

		vehicle:ArmorMarker( IsDamage )
	end )

	return
end

util.AddNetworkString( "lvs_hitmarker" )
util.AddNetworkString( "lvs_hurtmarker" )
util.AddNetworkString( "lvs_killmarker" )
util.AddNetworkString( "lvs_armormarker" )
--PATH lua/lvs_framework/autorun/lvs_entitytracker.lua:
return gluapack()()
--PATH lua/lvs_framework/autorun/lvs_keybinding.lua:
return gluapack()()
--PATH lua/lvs_framework/autorun/lvs_keybinding.lua:

hook.Add( "LVS:Initialize", "!!11lvs_default_keys", function()
	local KEYS = {
		{
			name = "ATTACK",
			category = "Armament",
			name_menu = "Attack",
			default = MOUSE_LEFT,
			cmd = "lvs_lmb"
		},
		{
			name = "ZOOM",
			category = "Armament",
			name_menu = "Zoom",
			default = MOUSE_RIGHT,
			cmd = "lvs_rmb"
		},
		{
			name = "~SELECT~WEAPON#1",
			category = "Armament",
			name_menu = "Select Weapon 1",
			cmd = "lvs_select_weapon1"
		},
		{
			name = "~SELECT~WEAPON#2",
			category = "Armament",
			name_menu = "Select Weapon 2",
			cmd = "lvs_select_weapon2"
		},
		{
			name = "~SELECT~WEAPON#3",
			category = "Armament",
			name_menu = "Select Weapon 3",
			cmd = "lvs_select_weapon3"
		},
		{
			name = "~SELECT~WEAPON#4",
			category = "Armament",
			name_menu = "Select Weapon 4",
			cmd = "lvs_select_weapon4"
		},
		--[[ only adding 4 because i dont want to bloat the menu. There can be added as many keys as neededed the system should figure it out by itself
		{
			name = "~SELECT~WEAPON#5",
			category = "Armament",
			name_menu = "Select Weapon 5",
			cmd = "lvs_select_weapon5"
		},
		]]
		{
			name = "EXIT",
			category = "Misc",
			name_menu = "Exit Vehicle",
			default = "+use",
			cmd = "lvs_exit"
		},
		{
			name = "VIEWDIST",
			category = "Misc",
			name_menu = "Enable Mouse-Wheel Set-Camera-Distance",
			default = MOUSE_MIDDLE,
			cmd = "lvs_viewzoom"
		},
		{
			name = "VIEWHEIGHT",
			category = "Misc",
			name_menu = "Set-Camera-Distance => Set-Camera-Height",
			default = "phys_swap",
			cmd = "lvs_viewheight"
		},
		{
			name = "THIRDPERSON",
			category = "Misc",
			name_menu = "Toggle Thirdperson",
			default = "+duck",
			cmd = "lvs_thirdperson"
		},
		{
			name = "FREELOOK",
			category = "Misc",
			name_menu = "Freelook (Hold)",
			default = "+walk",
			cmd = "lvs_freelook"
		},
		{
			name = "ENGINE",
			category = "Misc",
			name_menu = "Toggle Engine",
			default = "+reload",
			cmd = "lvs_startengine"
		},
		{
			name = "VSPEC",
			category = "Misc",
			name_menu = "Toggle Vehicle-specific Function",
			default = "+jump",
			cmd = "lvs_special"
		},
	}

	for _, v in pairs( KEYS ) do
		LVS:AddKey( v.name, v.category, v.name_menu, v.cmd, v.default )
	end
end )

if SERVER then return end

concommand.Add( "lvs_mouseaim_toggle", function( ply, cmd, args )
	local OldVar = GetConVar( "lvs_mouseaim" ):GetInt()

	if OldVar == 0 then
		ply:PrintMessage( HUD_PRINTTALK, "[LVS] Mouse-Aim: Enabled" )
		RunConsoleCommand( "lvs_mouseaim", "1" )

	else
		ply:PrintMessage( HUD_PRINTTALK, "[LVS] Mouse-Aim: Disabled" )
		RunConsoleCommand( "lvs_mouseaim", "0" )
	end
end )

hook.Add( "PlayerBindPress", "!!!!_LVS_PlayerBindPress", function( ply, bind, pressed )
	if not ply.lvsGetVehicle then return end

	local vehicle = ply:lvsGetVehicle()

	if not IsValid( vehicle ) then return end

	if not ply:lvsKeyDown( "VIEWDIST" ) then
		if string.find( bind, "invnext" ) then
			vehicle:NextWeapon()
		end
		if string.find( bind, "invprev" ) then
			vehicle:PrevWeapon()
		end
	end

	if string.find( bind, "+zoom" ) then
		if vehicle.lvsDisableZoom then
			return true
		end
	end
end )

hook.Add( "SpawnMenuOpen", "!!!lvs_spawnmenudisable", function()
	local ply = LocalPlayer() 

	if not ply._lvsDisableSpawnMenu or not IsValid( ply:lvsGetVehicle() ) then return end

	return false
end )

hook.Add( "ContextMenuOpen", "!!!lvs_contextmenudisable", function()
	local ply = LocalPlayer() 

	if not ply._lvsDisableContextMenu or not IsValid( ply:lvsGetVehicle() ) then return end

	return false
end )

--PATH lua/autorun/includes/extensions/sh_url.lua:
-----------------------------------------------------------------------------
-- URI parsing, composition and relative URL resolution
-- LuaSocket toolkit.
-- Author: Diego Nehab
-- RCS ID: $Id: url.lua,v 1.38 2006/04/03 04:45:42 diego Exp $
-----------------------------------------------------------------------------

-----------------------------------------------------------------------------
-- Declare module
-----------------------------------------------------------------------------
local string = string
local base = _G
local table = table
local pairs = pairs
local ipairs = ipairs
local tonumber = tonumber
local type = type
module("url")

-----------------------------------------------------------------------------
-- Module version
-----------------------------------------------------------------------------
_VERSION = "URL 1.0.1"

-----------------------------------------------------------------------------
-- HTML Entity Translation Table
-- http://lua-users.org/lists/lua-l/2005-10/msg00328.html
-----------------------------------------------------------------------------
local entities = {
	[' '] = '&nbsp;',
	[''] = '&iexcl;',
	[''] = '&cent;',
	[''] = '&pound;',
	[''] = '&curren;',
	[''] = '&yen;',
	[''] = '&brvbar;',
	[''] = '&sect;',
	[''] = '&uml;',
	[''] = '&copy;',
	[''] = '&ordf;',
	[''] = '&laquo;',
	[''] = '&not;',
	[''] = '&shy;',
	[''] = '&reg;',
	[''] = '&macr;',
	[''] = '&deg;',
	[''] = '&plusmn;',
	[''] = '&sup2;',
	[''] = '&sup3;',
	[''] = '&acute;',
	[''] = '&micro;',
	[''] = '&para;',
	[''] = '&middot;',
	[''] = '&cedil;',
	[''] = '&sup1;',
	[''] = '&ordm;',
	[''] = '&raquo;',
	[''] = '&frac14;',
	[''] = '&frac12;',
	[''] = '&frac34;',
	[''] = '&iquest;',
	[''] = '&Agrave;',
	[''] = '&Aacute;',
	[''] = '&Acirc;',
	[''] = '&Atilde;',
	[''] = '&Auml;',
	[''] = '&Aring;',
	[''] = '&AElig;',
	[''] = '&Ccedil;',
	[''] = '&Egrave;',
	[''] = '&Eacute;',
	[''] = '&Ecirc;',
	[''] = '&Euml;',
	[''] = '&Igrave;',
	[''] = '&Iacute;',
	[''] = '&Icirc;',
	[''] = '&Iuml;',
	[''] = '&ETH;',
	[''] = '&Ntilde;',
	[''] = '&Ograve;',
	[''] = '&Oacute;',
	[''] = '&Ocirc;',
	[''] = '&Otilde;',
	[''] = '&Ouml;',
	[''] = '&times;',
	[''] = '&Oslash;',
	[''] = '&Ugrave;',
	[''] = '&Uacute;',
	[''] = '&Ucirc;',
	[''] = '&Uuml;',
	[''] = '&Yacute;',
	[''] = '&THORN;',
	[''] = '&szlig;',
	[''] = '&agrave;',
	[''] = '&aacute;',
	[''] = '&acirc;',
	[''] = '&atilde;',
	[''] = '&auml;',
	[''] = '&aring;',
	[''] = '&aelig;',
	[''] = '&ccedil;',
	[''] = '&egrave;',
	[''] = '&eacute;',
	[''] = '&ecirc;',
	[''] = '&euml;',
	[''] = '&igrave;',
	[''] = '&iacute;',
	[''] = '&icirc;',
	[''] = '&iuml;',
	[''] = '&eth;',
	[''] = '&ntilde;',
	[''] = '&ograve;',
	[''] = '&oacute;',
	[''] = '&ocirc;',
	[''] = '&otilde;',
	[''] = '&ouml;',
	[''] = '&divide;',
	[''] = '&oslash;',
	[''] = '&ugrave;',
	[''] = '&uacute;',
	[''] = '&ucirc;',
	[''] = '&uuml;',
	[''] = '&yacute;',
	[''] = '&thorn;',
	[''] = '&yuml;',
	['"'] = '&quot;',
	["'"] = '&#39;',
	['<'] = '&lt;',
	['>'] = '&gt;',
	['&'] = '&amp;'
}

function htmlentities(s)
	for k, v in pairs(entities) do
		s = string.gsub(s, k, v)
	end
	return s
end

function htmlentities_decode(s)
	for k, v in pairs(entities) do
		s = string.gsub(s, v, k)
	end
	return s
end

-----------------------------------------------------------------------------
-- Encodes a string into its escaped hexadecimal representation
-- Input
--   s: binary string to be encoded
-- Returns
--   escaped representation of string binary
-----------------------------------------------------------------------------
function escape(s)
	return string.gsub(s, "([^A-Za-z0-9_])", function(c)
		return string.format("%%%02x", string.byte(c))
	end)
end

-----------------------------------------------------------------------------
-- Protects a path segment, to prevent it from interfering with the
-- url parsing.
-- Input
--   s: binary string to be encoded
-- Returns
--   escaped representation of string binary
-----------------------------------------------------------------------------
local function make_set(t)
	local s = {}
	for i,v in ipairs(t) do
		s[t[i]] = 1
	end
	return s
end

-- these are allowed withing a path segment, along with alphanum
-- other characters must be escaped
local segment_set = make_set {
	"-", "_", ".", "!", "~", "*", "'", "(",
	")", ":", "@", "&", "=", "+", "$", ",",
}

local function protect_segment(s)
	return string.gsub(s, "([^A-Za-z0-9_])", function (c)
		if segment_set[c] then return c
		else return string.format("%%%02x", string.byte(c)) end
	end)
end

-----------------------------------------------------------------------------
-- Encodes a string into its escaped hexadecimal representation
-- Input
--   s: binary string to be encoded
-- Returns
--   escaped representation of string binary
-----------------------------------------------------------------------------
function unescape(s)
	return string.gsub(s, "%%(%x%x)", function(hex)
		return string.char(tonumber(hex, 16))
	end)
end

-----------------------------------------------------------------------------
-- Builds a path from a base path and a relative path
-- Input
--   base_path
--   relative_path
-- Returns
--   corresponding absolute path
-----------------------------------------------------------------------------
local function absolute_path(base_path, relative_path)
	if string.sub(relative_path, 1, 1) == "/" then return relative_path end
	local path = string.gsub(base_path, "[^/]*$", "")
	path = path .. relative_path
	path = string.gsub(path, "([^/]*%./)", function (s)
		if s ~= "./" then return s else return "" end
	end)
	path = string.gsub(path, "/%.$", "/")
	local reduced
	while reduced ~= path do
		reduced = path
		path = string.gsub(reduced, "([^/]*/%.%./)", function (s)
			if s ~= "../../" then return "" else return s end
		end)
	end
	path = string.gsub(reduced, "([^/]*/%.%.)$", function (s)
		if s ~= "../.." then return "" else return s end
	end)
	return path
end

-----------------------------------------------------------------------------
-- Parses a url and returns a table with all its parts according to RFC 2396
-- The following grammar describes the names given to the URL parts
-- <url> ::= <scheme>://<authority>/<path>;<params>?<query>#<fragment>
-- <authority> ::= <userinfo>@<host>:<port>
-- <userinfo> ::= <user>[:<password>]
-- <path> :: = {<segment>/}<segment>
-- Input
--   url: uniform resource locator of request
--   default: table with default values for each field
-- Returns
--   table with the following fields, where RFC naming conventions have
--   been preserved:
--     scheme, authority, userinfo, user, password, host, port,
--     path, params, query, fragment
-- Obs:
--   the leading '/' in {/<path>} is considered part of <path>
-----------------------------------------------------------------------------
function parse(url, default)
	-- initialize default parameters
	local parsed = {}
	for i,v in pairs(default or parsed) do parsed[i] = v end
	-- empty url is parsed to nil
	if not url or url == "" then return nil, "invalid url" end
	-- remove whitespace
	-- url = string.gsub(url, "%s", "")
	-- get fragment
	url = string.gsub(url, "#(.*)$", function(f)
		parsed.fragment = f
		return ""
	end)
	-- get scheme
	url = string.gsub(url, "^([%w][%w%+%-%.]*)%://",
		function(s) parsed.scheme = s; return "" end)
	-- get authority
	url = string.gsub(url, "^([^/%?]*)", function(n)
		parsed.authority = n
		return ""
	end)
	-- get query stringing
	url = string.gsub(url, "%?(.*)", function(q)
		parsed.query = q
		return ""
	end)
	-- get params
	url = string.gsub(url, "%;(.*)", function(p)
		parsed.params = p
		return ""
	end)
	-- path is whatever was left
	if url ~= "" then parsed.path = url else parsed.path = "/" end
	local authority = parsed.authority
	if not authority then return parsed end
	authority = string.gsub(authority,"^([^@]*)@",
		function(u) parsed.userinfo = u; return "" end)
	authority = string.gsub(authority, ":([^:]*)$",
		function(p) parsed.port = p; return "" end)
	if authority ~= "" then parsed.host = authority end
	local userinfo = parsed.userinfo
	if not userinfo then return parsed end
	userinfo = string.gsub(userinfo, ":([^:]*)$",
		function(p) parsed.password = p; return "" end)
	parsed.user = userinfo
	return parsed
end

-----------------------------------------------------------------------------
-- Parses the url and also seperates the query terms into a table
-----------------------------------------------------------------------------
function parse2(url, default)
	local parsed = parse(url, default)

	if parsed.query then
		local prmstr = parsed.query
		local prmarr = string.Explode("&", prmstr)
		local params = {}

		for i = 1, #prmarr do
			local tmparr = string.Explode("=", prmarr[i])
			params[tmparr[1]] = tmparr[2]
		end

		parsed.query = params
	end

	if parsed.fragment then
		local prmstr = parsed.fragment
		local prmarr = string.Explode("&", prmstr)
		local params = {}

		for i = 1, #prmarr do
			local tmparr = string.Explode("=", prmarr[i])
			params[tmparr[1]] = tmparr[2]
		end

		parsed.fragment = params
	end

	return parsed
end

-----------------------------------------------------------------------------
-- Rebuilds a parsed URL from its components.
-- Components are protected if any reserved or unallowed characters are found
-- Input
--   parsed: parsed URL, as returned by parse
-- Returns
--   a stringing with the corresponding URL
-----------------------------------------------------------------------------
function build(parsed)
	local ppath = parse_path(parsed.path or "")
	local url = build_path(ppath)
	local url = (parsed.path or ""):gsub("[^/]+", unescape)
	local url = url:gsub("[^/]*", protect_segment)
	if parsed.params then url = url .. ";" .. parsed.params end
	if parsed.query then url = url .. "?" .. parsed.query end
	local authority = parsed.authority
	if parsed.host then
		authority = parsed.host
		if parsed.port then authority = authority .. ":" .. parsed.port end
		local userinfo = parsed.userinfo
		if parsed.user then
			userinfo = parsed.user
			if parsed.password then
				userinfo = userinfo .. ":" .. parsed.password
			end
		end
		if userinfo then authority = userinfo .. "@" .. authority end
	end
	if authority then url = "//" .. authority .. url end
	if parsed.scheme then url = parsed.scheme .. ":" .. url end
	if parsed.fragment then url = url .. "#" .. parsed.fragment end
	-- url = string.gsub(url, "%s", "")
	return url
end

-----------------------------------------------------------------------------
-- Builds a absolute URL from a base and a relative URL according to RFC 2396
-- Input
--   base_url
--   relative_url
-- Returns
--   corresponding absolute url
-----------------------------------------------------------------------------
function absolute(base_url, relative_url)
	if type(base_url) == "table" then
		base_parsed = base_url
		base_url = build(base_parsed)
	else
		base_parsed = parse(base_url)
	end
	local relative_parsed = parse(relative_url)
	if not base_parsed then return relative_url
	elseif not relative_parsed then return base_url
	elseif relative_parsed.scheme then return relative_url
	else
		relative_parsed.scheme = base_parsed.scheme
		if not relative_parsed.authority or relative_parsed.authority == "" then
			relative_parsed.authority = base_parsed.authority
			if not relative_parsed.path then
				relative_parsed.path = base_parsed.path
				if not relative_parsed.params then
					relative_parsed.params = base_parsed.params
					if not relative_parsed.query then
						relative_parsed.query = base_parsed.query
					end
				end
			else    
				relative_parsed.path = absolute_path(base_parsed.path or "",
					relative_parsed.path)
			end
		end
		return build(relative_parsed)
	end
end

-----------------------------------------------------------------------------
-- Breaks a path into its segments, unescaping the segments
-- Input
--   path
-- Returns
--   segment: a table with one entry per segment
-----------------------------------------------------------------------------
function parse_path(path)
	local parsed = {}
	path = path or ""
	--path = string.gsub(path, "%s", "")
	string.gsub(path, "([^/]*)", function (s) table.insert(parsed, s) end)
	for i = 1, table.getn(parsed) do
		parsed[i] = unescape(parsed[i])
	end
	if string.sub(path, 1, 1) == "/" then parsed.is_absolute = 1 end
	if string.sub(path, -1, -1) == "/" then parsed.is_directory = 1 end
	return parsed
end

-----------------------------------------------------------------------------
-- Builds a path component from its segments, escaping protected characters.
-- Input
--   parsed: path segments
--   unsafe: if true, segments are not protected before path is built
-- Returns
--   path: corresponding path stringing
-----------------------------------------------------------------------------
function build_path(parsed, unsafe)
	local path = ""
  local escape = unsafe and function(x) return x end or protect_segment
	local n = table.getn(parsed)
  for i = 1, n-1 do
	if parsed[i]~= "" or parsed[i+1] == "" then
	  path = path .. escape(parsed[i])
	  if i < n - 1 or parsed[i+1] ~= "" then path = path .. "/" end
	end
  end
  if n > 0 then
	path = path .. escape(parsed[n])
	if parsed.is_directory then path = path .. "/" end
  end
	if parsed.is_absolute then path = "/" .. path end
	return path
end
--PATH lua/autorun/includes/modules/browserpool.lua:
return gluapack()()
--PATH lua/autorun/includes/modules/inputhook.lua:
return gluapack()()
--PATH lua/autorun/includes/modules/htmlmaterial.lua:
return gluapack()()
--PATH lua/autorun/includes/modules/spritesheet.lua:
return gluapack()()
--PATH lua/mediaplayer/config/client.lua:
--[[----------------------------------------------------------------------------
	Media Player client configuration
------------------------------------------------------------------------------]]
MediaPlayer.SetConfig({

	---
	-- HTML content
	--
	html = {

		---
		-- Base URL where HTML content is located.
		-- @type String
		--
		base_url = "http://samuelmaddock.github.io/gm-mediaplayer/"

	},

	---
	-- Request menu
	--
	request = {

		---
		-- URL of the request menu.
		-- @type String
		--
		url = "http://samuelmaddock.github.io/gm-mediaplayer/request.html"

	}

})

--PATH lua/mediaplayer/players/base/sh_snapshot.lua:
function MEDIAPLAYER:GetSnapshot()
	local queue = table.Copy( self:GetMediaQueue() )
	local media = self:GetMedia()

	return {
		media = media,
		currentTime = media and media:CurrentTime(),
		queue = queue,
		queueRepeat = self:GetQueueRepeat(),
		queueShuffle = self:GetQueueShuffle(),
		queueLocked = self:GetQueueLocked()
	}
end

function MEDIAPLAYER:RestoreSnapshot( snapshot )
	self._Queue = {}

	self:SetQueueRepeat( snapshot.queueRepeat )
	self:SetQueueShuffle( snapshot.queueShuffle )
	self:SetQueueLocked( snapshot.queueLocked )

	if snapshot.media then
		-- restore currently playing media from where it left off
		local mediaSnapshot = snapshot.media
		local media = MediaPlayer.GetMediaForUrl( mediaSnapshot.url )
		if media then
			table.Merge( media, mediaSnapshot )
			media:StartTime( RealTime() - snapshot.currentTime )
			self:SetMedia( media )
		end
	else
		self:SetMedia( nil )
	end

	if snapshot.queue then
		-- restore queue
		for _, mediaSnapshot in ipairs( snapshot.queue ) do
			local media = MediaPlayer.GetMediaForUrl( mediaSnapshot.url )
			if media then
				table.Merge( media, mediaSnapshot )
				self:AddMedia( media )
			end
		end

		self:QueueUpdated()
	end
end

--PATH lua/mediaplayer/players/base/cl_fullscreen.lua:
local pcall = pcall
local Color = Color
local RealTime = RealTime
local ScrW = ScrW
local ScrH = ScrH
local ValidPanel = ValidPanel
local Vector = Vector
local cam = cam
local draw = draw
local math = math
local string = string
local surface = surface

local FullscreenCvar = MediaPlayer.Cvars.Fullscreen

--[[---------------------------------------------------------
	Convar callback
-----------------------------------------------------------]]

local function OnFullscreenConVarChanged( name, old, new )

	new = (new == "1.00")
	old = (old == "1.00")

	local media

	for _, mp in pairs(MediaPlayer.List) do

		mp._LastMediaUpdate = RealTime()

		media = mp:CurrentMedia()

		if IsValid(media) and ValidPanel(media.Browser) then
			MediaPlayer.SetBrowserSize( media.Browser )
		end

	end

	MediaPlayer.SetBrowserSize( MediaPlayer.GetIdlescreen() )

	hook.Run( "MediaPlayerFullscreenToggled", new, old )

end
cvars.AddChangeCallback( FullscreenCvar:GetName(), OnFullscreenConVarChanged )


--[[---------------------------------------------------------
	Client controls for toggling fullscreen
-----------------------------------------------------------]]

inputhook.AddKeyPress( KEY_F11, "Toggle MediaPlayer Fullscreen", function()

	local isFullscreen = FullscreenCvar:GetBool()
	local numMp = #MediaPlayer.GetAll()

	-- only toggle if there's an active media player or we're in fullscreen mode
	if numMp == 0 and not isFullscreen then
		return
	end

	local value = isFullscreen and 0 or 1
	RunConsoleCommand( "mediaplayer_fullscreen", value )

end )


--[[---------------------------------------------------------
	Draw functions
-----------------------------------------------------------]]

function MEDIAPLAYER:DrawFullscreen()

	-- Don't draw if we're not fullscreen
	if not FullscreenCvar:GetBool() then return end

	local w, h = ScrW(), ScrH()
	local media = self:CurrentMedia()

	if IsValid(media) then

		-- Custom media draw function
		if media.Draw then
			media:Draw( w, h )
		end
		-- TODO: else draw 'not yet implemented' screen?

		-- Draw media info
		local succ, err = pcall( self.DrawMediaInfo, self, media, w, h )
		if not succ then
			print( err )
		end

	else

		local browser = MediaPlayer.GetIdlescreen()

		if ValidPanel(browser) then
			self:DrawHTML( browser, w, h )
		end

	end

end

--PATH lua/mediaplayer/services/audiofile/cl_init.lua:
return gluapack()()
--PATH lua/mediaplayer/cl_requests.lua:
return gluapack()()
--PATH lua/mp_menu/icons.lua:
local spritesheet = spritesheet

--[[--------------------------------------------
	Icons spritesheet
----------------------------------------------]]

local mpSpritesheetMat = Material( "mediaplayer/ui/spritesheet2015-10-7.png" )
local blockSize = 24

local function mpIcon( name, i, j, w, h )
	return {
		name = name,
		mat = mpSpritesheetMat,
		w = w,
		h = h,
		xoffset = i * blockSize,
		yoffset = j * blockSize
	}
end

spritesheet.Register {
	mpIcon( "mp-thumbs-up",			0, 0, 18, 21 ),
	mpIcon( "mp-thumbs-down",		1, 0, 18, 21 ),
	mpIcon( "mp-delete",			2, 0, 15, 20 ),
	mpIcon( "mp-favorite",			3, 0, 21, 21 ),
	mpIcon( "mp-favorite-outline", 	4, 0, 21, 21 ),
	mpIcon( "mp-volume-mute", 		0, 1, 18, 17 ),
	mpIcon( "mp-volume", 			1, 1, 18, 17 ),
	mpIcon( "mp-back", 				2, 1, 16, 17 ),
	mpIcon( "mp-forward", 			3, 1, 16, 17 ),
	mpIcon( "mp-home", 				4, 1, 19, 17 ),
	mpIcon( "mp-close", 			0, 2, 16, 16 ),
	mpIcon( "mp-skip", 				1, 2, 16, 16 ),
	mpIcon( "mp-refresh", 			2, 2, 16, 15 ),
	mpIcon( "mp-plus", 				3, 2, 14, 14 ),
	mpIcon( "mp-repeat", 			4, 2, 18, 18 ),
	mpIcon( "mp-shuffle", 			0, 3, 16, 16 ),
	mpIcon( "mp-replay", 			1, 3, 13, 16 ),
	mpIcon( "mp-lock", 			    2, 3, 12, 16 ),
	mpIcon( "mp-lock-open", 		3, 3, 12, 16 ),

	mpIcon( "mp-play", 				3, 4, 19, 25 ),
	mpIcon( "mp-pause",				4, 4, 22, 24 ),
}


--[[--------------------------------------------
	DIcon
----------------------------------------------]]

local DICON = {}

AccessorFunc( DICON, "m_strIcon", 				"Icon" )
AccessorFunc( DICON, "m_Color", 				"IconColor" )
AccessorFunc( DICON, "m_bKeepAspect", 			"KeepAspect" )

function DICON:Init()

	self:SetIconColor( color_white )
	self:SetMouseInputEnabled( false )
	self:SetKeyboardInputEnabled( false )

	self:SetKeepAspect( false )

	self.IconWidth = 10
	self.IconHeight = 10

end

function DICON:SetIcon( icon )

	self.m_strIcon = icon

	self.IconWidth, self.IconHeight = spritesheet.GetIconSize( icon )

end

function DICON:SizeToContents( strImage )

	self:SetSize( self.IconWidth, self.IconHeight )

end

function DICON:Paint( w, h )
	self:PaintAt( 0, 0, w, h )
end

function DICON:PaintAt( x, y, dw, dh )

	if not self.m_strIcon then return end

	if ( self.m_bKeepAspect ) then

		local w = self.IconWidth
		local h = self.IconHeight

		-- Image is bigger than panel, shrink to suitable size
		if ( w > dw and h > dh ) then

			if ( w > dw ) then

				local diff = dw / w
				w = w * diff
				h = h * diff

			end

			if ( h > dh ) then

				local diff = dh / h
				w = w * diff
				h = h * diff

			end

		end

		if ( w < dw ) then

			local diff = dw / w
			w = w * diff
			h = h * diff

		end

		if ( h < dh ) then

			local diff = dh / h
			w = w * diff
			h = h * diff

		end

		local OffX = ceil((dw - w) * 0.5)
		local OffY = ceil((dh - h) * 0.5)

		spritesheet.DrawIcon( self.m_strIcon, OffX+y, OffY+y, w, h, self.m_Color )
		return true

	end

	spritesheet.DrawIcon( self.m_strIcon, x, y, dw, dh, self.m_Color )
	return true

end

derma.DefineControl( "DIcon", "", DICON, "DPanel" )


--[[--------------------------------------------
	DIconButton
----------------------------------------------]]

local DICONBTN = {}

AccessorFunc( DICONBTN, "m_strIcon", "Icon" )
AccessorFunc( DICONBTN, "m_bStretchToFit", 			"StretchToFit" )

function DICONBTN:Init()

	self:SetDrawBackground( false )
	self:SetDrawBorder( false )
	self:SetStretchToFit( false )

	self:SetCursor( "hand" )
	self.m_Icon = vgui.Create( "DIcon", self )

	self:SetText( "" )

	self:SetColor( Color( 255, 255, 255, 255 ) )

end

function DICONBTN:SetIconVisible( bBool )

	self.m_Icon:SetVisible( bBool )

end

function DICONBTN:SetIcon( strIcon )

	self.m_Icon:SetIcon( strIcon )

end

function DICONBTN:SetColor( col )

	self.m_Icon:SetIconColor( col )

end

function DICONBTN:GetIcon()

	return self.m_Icon:GetIcon()

end

function DICONBTN:SetKeepAspect( bKeep )

	self.m_Icon:SetKeepAspect( bKeep )

end

function DICONBTN:SizeToContents( )

	self.m_Icon:SizeToContents()
	self:SetSize( self.m_Icon:GetWide(), self.m_Icon:GetTall() )

end

function DICONBTN:PerformLayout()

	if ( self.m_bStretchToFit ) then

		self.m_Icon:SetPos( 0, 0 )
		self.m_Icon:SetSize( self:GetSize() )

	else

		self.m_Icon:SizeToContents()
		self.m_Icon:Center()

	end

end

derma.DefineControl( "DIconButton", "", DICONBTN, "DButton" )


--[[--------------------------------------------
	DIconButton
----------------------------------------------]]

local DICONLBLBTN = {}

AccessorFunc( DICONLBLBTN, "m_LabelSpacing", "LabelSpacing" )
AccessorFunc( DICONLBLBTN, "m_Padding", "Padding" )

function DICONLBLBTN:Init()

	self.BaseClass.Init( self )

	self.BtnLbl = vgui.Create( "DLabel", self )
	self.BtnLbl:SetText( "" )

	self:SetLabelSpacing( 4 )
	self:SetPadding( 4 )

end

function DICONLBLBTN:PerformLayout()

	self.m_Icon:SizeToContents()
	self.m_Icon:AlignLeft( self.m_Padding )

	self.BtnLbl:SizeToContents()
	self.BtnLbl:MoveRightOf( self.m_Icon, self.m_LabelSpacing )

	local w = self.BtnLbl:GetPos() + self.BtnLbl:GetWide() + self.m_Padding
	local h = math.max( self.m_Icon:GetTall(), self.BtnLbl:GetTall() )
	self:SetWide( w, h )

	self.m_Icon:CenterVertical()
	self.BtnLbl:CenterVertical()

end

derma.DefineControl( "DIconLabeledButton", "", DICONLBLBTN, "DIconButton" )

--PATH addons/[ui] msd_ui/lua/msd/sh_language.lua:
return gluapack()()
--PATH addons/[ui] msd_ui/lua/msd/language/es.lua:
MSD.Language["es"] = {

	-- UI

	lang_name = "Spanish",

	ok = "OK",
	map = "Mapa",
	off = "Apagado",
	on = "Encendido",
	time_add = "Tiempo para agregar",
	type = "Tipo",
	delay = "Retraso",
	cancel = "Cancelar",
	enable = "Permitir",
	model = "Modelo",
	name = "Nombre",
	settings = "Ajustes",
	editor = "Editor",
	red = "Rojo",
	green = "Verde",
	blue = "Azul",
	admin_menu = "Men de admin",
	ui_settings = "Ajustes de interfaz",
	active = "Activo",
	inactive = "Inactivo",
	disabled = "Deshabilitado",
	warning = "Peligro",
	remove = "Eliminar",
	theme = "Tema",
	dark_theme = "Tema oscuro",
	payment = "Pago",
	load_autosave = "Cargar el ultimo autoguardado?",
	load_save = "Cargar guardado",
	create_new = "Crear nuevo",
	enable_option = "Permitir opcin",
	main_opt = "Opciones principales",
	copy_data = "Copiar datos",
	save_chng = "Guardar cambios",
	enter_name = "Ingresar el nombre",
	enter_id = "Ingresar el ID",
	confirm_action = "Por favor confirma tus acciones",
	check_fpr_errors = "Chequear errores",
	enter_description = "Ingresar descripcin",
	cooldown_ok = "Enfriamiento en el xito",
	cooldown_fail = "Enfriamiento en caso de falla",
	s_team_whitelist = "Configurar la lista blanca del equipo",
	whitelist_blacklist = "La lista blanca es una lista negra",
	custom_val = "Colocar valor personalizado",
	set_hp_full = "Colocar todo el HP",
	dist_to_close = "Distancia al ms cercano",

	e_text = "Ingresar texto",
	e_number = "Ingresar nmero",
	e_class = "Ingresar clase",
	e_value = "Ingresar valor",
	e_blank_dis = "Dejar en blanco para deshabilitar",
	e_blank_default = "Dejar en blanco para usar por defecto",
	e_url = "Ingresar URL",
	e_model = "Ingresar ruta del modelo",
	e_material = "Ingresar ruta del material",
	e_wep_class = "Ingresar ruta de la arma",
	e_ent_class = "Ingresar ruta de la entidad",
	e_veh_class = "Ingresar ruta del vehculo",
	e_npc_class = "Ingresar clase del NPC",

	select_ammo = "Municin seleccionada",
	amount_ammo = " Cantidad municin",
	disable_phys = "Deshabilitar la fsica",
	none = "Ninguno",
	custom_icon = "Seleccionar icono personalizado",
	weapon_name = "Nombre del arma",
	moveup = "Mover hacia arriba",
	movedown = "Mover hacia abajo",
	movepoint = "Mover punto",
	swap = "Intercambiar",
	swapmod = "Intercambiar mod habilitado. Click para deshabilitar",
	copy_from_ent = "Copiar de la entidad que mira",
	set_pos_self = "Establecer en su posicin",
	set_pos_aim = "Establecer en el punto de mira",
	spawn_point = "Spawnear punto",
	spawn_ang = "Spawnear ngulo",
	mark_area = "Marcar rea",
	time_wait = "Tiempo de espera",
	map_marker = "Seleccionar punto del mapa",
	in_sec = "En segundos",
	def_units = "Default %s unidades", -- "350 unidades por defecto" leave %s as is
	def_seconds = "Default %s segundos", -- "10 segundos por defecto" leave %s as is
	ent_show_pointer = "Mostrar puntero sobre la entidad",
	ent_arcade_style = "Apariencia de entidad de estilo arcade",
	ent_stnd_style = "Apariencia de la entidad estndar",
	custom_color = "Habilitar color personalizado",
	mat_default = "Dejar en blanco para material por defecto",

	set_ui = "Ajustes de la interfaz de usuario",
	set_hud = "Ajustes del HUD",
	set_hud_pos = "Posicin HUD de las misiones",
	set_hud_themes = "Temas del HUD",
	set_server = "Ajustes de servidor",
	set_ui_blur = "Desenfoque del fondo",
	set_ui_mono = "Fondo monocromtico",
	set_ui_vignette = "Efecto de vieta para el fondo",
	set_ui_brightness = "Brillo de fondo",
	set_ui_color = "Seleccionar el color principal",
	set_ui_align_left = "Alineacin vertical hacia la izquierda",
	set_ui_align_right = "Alineacin vertical hacia la derecha",
	set_ui_align_top = "Alineacin vertical hacia arriba",
	set_ui_align_bottom = "Alineacin vertical hasta la parte inferior",
	set_ui_offset_h = "Compensacin horizontal",
	set_ui_offset_v = "Compensacin vertical",

	upl_changes = "Subir cambios al servidor",
	res_changes = "Restablecer cambios",

	-- Jugador

	dead = "Estas muerto",
	time_ex = "Tiempo expirado",
	vehicle_bum = "Tu Vehculo esta destruido",
	left_area = "Dejaste la zona",
	m_blew = "You blew up the mission",
	m_failed = "Misin fallida",
	m_success = "Misin exitosa",
	m_loop = "Actualizacin de la misin",

	-- Errores

	inv_quest = "Misin Invalida",
	team_bl = "Tu equipo est en lista negra",
	no_players = "El servidor necesita ms jugadores conectados antes que puedas hacer esto",
	no_players_team = "El servidor necesita ms jugadores conectados para equipo(s) especifico(s)antes que puedas hacer esto",
	need_admin = "Solo los administradores pueden realizar esta accion",

	-- Misiones

	active_quest = "Tienes una misin activa",
	inactive_quest = "No puedes jugar esta misin",
	quest_editor = "Editor de misiones",
	quest_list = "Lista de misiones",
	quests = "Misiones",
	leave_pnt = "Dejar punto",

	q_editobj = "Editar objetivos",
	q_incvobj = "Objetivo invalido",
	q_setobj = "Ajustes de objetivo",
	q_newobj = "Aadir nuevo objetivo",
	q_editrwd = "Editar recompensas",
	q_rwdeditor = "Editor de recompensas",
	q_rwdlist = "Lista de recompensas",
	q_rwdsets = "Ajustes de recompensas",
	q_findmap = "Encontrar misiones de otros mapas",
	q_obj_des = "Descripcin de objetivo",
	q_dist_point = "Distancia al punto",
	q_dist_from_point = "Distancia desde el punto",
	q_ignore_veh = "Ignorar vehculo de misin",
	q_timer_show = "Mostrar el temporizador al jugador",
	q_area_stay = "El jugador debe quedarse en el area",
	q_start = "Empezar Misin",
	q_new = "Nueva misin",
	q_submit = "Enviar misin",
	q_addnew = "Aadir nueva misin",
	q_remove = "Eliminar misin",
	q_id_unique = "La ID debe ser nica para cada misin",
	q_complete_msg = "Mensaje de misin completada",
	q_dotime = "Tiempo para hacer la misin",
	q_dotime_ok = "Misin exitosa al finalizar el tiempo",
	q_dotime_fail = "Falla la misin al finalizar el tiempo",
	q_death_fail = "Fall la misin al morir el jugador",
	q_loop = "Tareas de misiones en bucle",
	q_loop_reward = "Recompensa al jugador en cada bucle",
	q_enable = "Habilitar misin",
	q_events = "Eventos",
	q_eventadd = "Aadir Evento",
	q_eventedit = "Editor de evento",
	q_eventremove = "Eliminar evento",
	q_in_progress = "Misin en progreso",
	q_time_left = "Tiempo restante",
	q_ply_limit = "Limite de jugadores para la misin",
	q_ply_team_limit = "Configurar equipos limitados",
	q_ply_team_need = "Jugadores de equipo necesarios",
	q_ply_need = "Cantidad de jugadores necesarios para comenzar",
	q_play_limit = "Hay un lmite en cuantos jugadores pueden jugar esta misin",
	q_must_stay_area = "Debes permanecer dentro de esta rea, o la misin fallara",
	q_time_wait = "Debes esperar antes de repetir esta misin",
	q_dotime_reset = "Restablecer el tiempo de realizacin de la misin",
	q_dotime_add = "Aadir tiempo para hacer la misin",
	q_noreplay = "No puedes re jugar esta misin",
	q_dis_replay = "Des habilitar repeticin de la misin",
	q_needquest = "Debes completar otra misin primero",
	q_needquest_menu = "Requiere misin completada",
	q_enterror = "Entidades de misin no spawnean, chequear configuracin de misin",
	q_get = "Puedes obtener una misin de estos NPCS",
	q_noquests = "Todava no hay forma de jugar las misiones :(",
	q_ent_draw = "Distancia del dibujo de la entidad",
	q_loop_stop_key = "Tecla para detener misin en bucle",
	q_hold_key_stop = "Para detener la misin, mantenga [%s]", -- Para detener la mision mantenga apretado [P]
	q_enter_veh = "Entrar a tu vehculo",
	q_npc_link = "Linquear misin a un NPC",
	q_icon68 = "Ingresar url a un icono .PNG de 68x68 px",
	q_ent_pos_show = "Mostrar locacin de entidades al jugador",
	q_area_size = "Tamao de rea",
	q_area_pos = "Posicin de rea",
	q_s_area_size = "Buscar tamao de rea",
	q_s_area_pos = "Buscar posicin de rea",
	q_npc_answer_ok = "Respuesta positiva del jugador",
	q_npc_answer_no = "Respuesta negativa del jugador",
	q_npc_answer_noq = "Respuesta del jugador si no hay misiones",
	q_npc_quest_no = "Discurso del NPC si no hay misiones",
	q_money_give = "Dinero para dar",

	-- Simple NPCs

	npc_editor = "Editor de NPC",
	npc_new = "Nuevo NPC",
	npc_select = "Seleccionar un NPC",
	npc_e_speech = " Ingresar el discurso del NPC",
	npc_submit = "Confirmar creacin del NPC",
	npc_update = "Actualizar NPC",
	npc_remove = "Eliminar NPC",
	npc_q_enable = "Habilitar misiones de NPCs",
	npc_did_open = "ID de dialogo para abrir",
	npc_q_target = "NPC is an objective target",
	npc_hostile = "NPC Hostil",

}

-- Otras frases
local es = "es"

MSD.Language[es]["Move to point"] = "Mover al punto"
MSD.Language[es]["Leave area"] = "Dejar rea"
MSD.Language[es]["Kill NPC"] = "Matar NPC"
MSD.Language[es]["Collect quest ents"] = "Recoger misiones"
MSD.Language[es]["Talk to NPC"] = "Hablar al NPC"

MSD.Language[es]["No hay misiones disponibles"] = "No hay misiones disponibles"

MSD.Language[es]["Give weapon"] = "Dar arma"
MSD.Language[es]["Give ammo"] = "Dar municin"
MSD.Language[es]["Strip Weapon"] = "Extraer arma"
MSD.Language[es]["Spawn quest entity"] = "Spawnear entidad de misin"
MSD.Language[es]["Spawn entity"] = "Spawnear entidad"
MSD.Language[es]["Spawn npc"] = "Spawnear npc"
MSD.Language[es]["Manage do time"] = "Administrar el tiempo"
MSD.Language[es]["Spawn vehicle"] = "Spawnear vehculo"
MSD.Language[es]["Remove vehicle"] = "Elminar vehculo"
MSD.Language[es]["Remove all entites"] = "Remover todas las entidades"
MSD.Language[es]["Set HP"] = "Configurar HP"
MSD.Language[es]["Set Armor"] = "Configurar armadura"

MSD.Language[es]["DarkRP Money"] = " Dinero DarkRP"

MSD.Language[es]["Quest NPCs are disabled"] = "Los NPCs de las misiones estn deshabilitados"
MSD.Language[es]["You can enable them in settings"] = "Puedes habilitarlos en las configuraciones"
MSD.Language[es]["Wait time"] = "Tiempo de espera"

--PATH lua/mvp/cl_init.lua:
return gluapack()()
--PATH lua/mvp/core/config/cl_config.lua:
mvp = mvp or {}
mvp.config = mvp.config or {}

mvp.config.list = mvp.config.list or {}

-- @todo: retrieve configs from server
function mvp.config.RequestSynchronization()
    net.Start("mvp.config.RequestSynchronization")
    net.SendToServer()
end

net.Receive("mvp.config.Synchronize", function()
    local configs = net.ReadTable()

    for k, v in pairs(configs) do
        if (not mvp.config.list[k]) then
           continue 
        end

        mvp.config.list[k].value = v
    end

    mvp.logger.Log(mvp.LOG.DEBUG, "Config", "Synchronized configs with server")

    hook.Run("mvp.config.Synchronized")
end)

net.Receive("mvp.config.UpdateValue", function()
    local key = net.ReadString()
    local value = net.ReadType()

    local config = mvp.config.list[key]

    if (not config) then
        return
    end
    
    local oldValue = config.value

    config.preSet(value, oldValue)
    config.value = value
    config.postSet(value, oldValue)

    if (value ~= oldValue) then
        hook.Run("mvp.config.Updated", key, value, oldValue)
    end
end)

concommand.Add("mvp_config_sync", function()
    mvp.config.RequestSynchronization()
end)
--PATH lua/mvp/configs/terminal.lua:
local TERMINAL_SECTION = mvp.config.RegisterSection("terminal", -1)

local GENERAL_GROUP = mvp.config.RegisterCategory("general", TERMINAL_SECTION, 1)

mvp.config.Add("prefix", "!", {
    description = "Prefix for all commands.",
    category = GENERAL_GROUP,

    ui = {} 
}, 1)

mvp.config.Add("allowConsoleCommand", true, {
    description = "Controls whether or not the console command for opening menu is allowed.",
    category = GENERAL_GROUP,

    ui = {}
}, 3)

local APPEARANCE_GROUP = mvp.config.RegisterCategory("appearance", TERMINAL_SECTION, 2)

mvp.config.Add("tag", "[Terminal]", {
    description = "Tag for all chat messages.",
    category = APPEARANCE_GROUP,

    ui = {}
}, 1)

mvp.config.Add("language", "en", {
    description = "Language for Terminal to use.",
    category = APPEARANCE_GROUP,

    ui = {
        type = "dropdown",
        choices = function()
            local storedLanguages = mvp.language.list
            local languages = {}

            for k, v in pairs(storedLanguages) do
                languages[k] = k
            end

            return languages
        end
    }
}, 2)

mvp.config.Add("useNotifications", true, {
    description = "Controls whether or not notifications are used.",
    category = APPEARANCE_GROUP,

    ui = {}
}, 3)

mvp.config.Add("notificationsPosition", "bc", {
    description = "Position of notifications.",
    category = APPEARANCE_GROUP,

    postSet = function()
        if (CLIENT) then
            mvp.notification.Add(mvp.NOTIFICATION.INFO, mvp.q.Lang("value.notificationsPosition.ps.title"), mvp.q.Lang("value.notificationsPosition.ps.description"), 5)
        end
    end,

    ui = {
        type = "dropdown",
        choices = function()
            local positionsKeys = {"tl", "tc", "tr", "cl", "cc", "cr", "bl", "bc", "br"}
            local positions = {}

            for _, pos in ipairs(positionsKeys) do
                positions[pos] = mvp.q.Lang("general.screen_position." .. pos)
            end

            return positions
        end
    }
}, 4)

local DEVELOPER_GROUP = mvp.config.RegisterCategory("developer", TERMINAL_SECTION, 100)

mvp.config.Add("debug", false, {
    description = "Controls whether or not debug messages are printed to the console.",
    category = DEVELOPER_GROUP,

    ui = {}
}, 1)


--PATH lua/mvp/core/credits/sh_icons.lua:
mvp = mvp or {}
mvp.credits = mvp.credits or {}

mvp.credits.iconsList = mvp.credits.iconsList or {}

function mvp.credits.AddIcon( icon, name, authorName, authorUrl)
    if (type(icon) ~= "IMaterial") then
        icon = Material(icon,"smooth mips")
    end
    
    mvp.credits.iconsList[#mvp.credits.iconsList + 1] = {
        icon = icon,
        name = name,
        author = {
            name = authorName,
            url = authorUrl
        }
    }
end

function mvp.credits.GetIcons()
    return mvp.credits.iconsList
end

function mvp.credits.ClearIcons()
    mvp.credits.iconsList = {}
end
--PATH lua/mvp/commands/terminal.lua:
local C = mvp.meta.command:New()

C:SetID("terminal")
C:SetName("terminal")
C:SetDescription("Open a terminal")

function C:Execute(ply)
    -- only executed on the server

    net.Start("mvp.terminal.open")
    net.Send(ply)
end

if (SERVER) then
    util.AddNetworkString("mvp.terminal.open")
else
    net.Receive("mvp.terminal.open", function()
        mvp.menus.admin.Open()
    end)
end

mvp.command.Register(C)
--PATH lua/mvp/core/package/sh_package.lua:
mvp = mvp or {}
mvp.package = mvp.package or {}
mvp.package.list = mvp.package.list or {}
mvp.package.lookup = mvp.package.lookup or {}

mvp.package.dependenciesResolverList = mvp.package.dependenciesResolverList or {}

--- Registers a package
-- This function registers a package and loads all files that are specified in the package.
-- @tparam mvp.meta.package The package to register
function mvp.package.Register(package)
    local id = package:GetID()

    if (mvp.package.list[id]) then
        mvp.logger.Log(mvp.LOG.WARN, "Packages", "Package '" .. id .. "' already registered! Overwriting...")
        mvp.logger.Log(mvp.LOG.WARN, "Packages", "This is probably a bug! Since this should not happen outside of development!")

        mvp.logger.Log(mvp.LOG.DEBUG, nil, "ID: " .. id)
        mvp.logger.Log(mvp.LOG.DEBUG, nil, "Original CWD: " .. mvp.package.list[id]:GetCWD())
        mvp.logger.Log(mvp.LOG.DEBUG, nil, "New CWD: " .. package:GetCWD())

        mvp.package.list[id] = nil
    end

    mvp.package.list[id] = package

    if (table.Count(package:GetDependencies()) == 0) then
        mvp.package.LoadPackage(package)
        return
    end

    -- resolve dependencies
    local shouldLoadImmediately = true
    for _, depId in ipairs(package:GetDependencies()) do
        mvp.package.dependenciesResolverList[id] = mvp.package.dependenciesResolverList[id] or {}

        if (mvp.package.list[depId] and mvp.package.list[depId].isLoaded) then
            mvp.package.dependenciesResolverList[id][depId] = true -- dependency is loaded earlier
        else
            mvp.package.dependenciesResolverList[id][depId] = false -- dependency is not loaded yet

            shouldLoadImmediately = false
        end
    end

    if (shouldLoadImmediately) then
        mvp.package.LoadPackage(package)
    end
end

function mvp.package.LoadPackage(package)
    for _, file in ipairs(package._files) do
        mvp.loader.LoadFile(file)
    end

    package.isLoaded = true

    mvp.logger.Log(mvp.LOG.INFO, "Packages", "Loaded package '" .. package:GetID() .. "@" .. package:GetVersion() .. "'")
    hook.Run("mvp.package.Registered", package)
end

hook.Add("mvp.package.Registered", "mvp.package.DependenceisResolver", function(package)
    local possibleDepId = package:GetID()

    local packagesInNeed = {}

    for id, deps in pairs(mvp.package.dependenciesResolverList) do
        if (deps[possibleDepId] == false) then
            table.insert(packagesInNeed, id)
        end
    end

    if (#packagesInNeed == 0) then
        return
    end

    for _, id in ipairs(packagesInNeed) do
        local package = mvp.package.list[id]

        if (not package) then
            mvp.logger.Log(mvp.LOG.ERROR, "Packages", "Could not resolve dependencies for package '" .. id .. "'! Package not found!")
            return
        end

        local allDepsLoaded = true

        for _, depId in ipairs(package:GetDependencies()) do
            if (not mvp.package.list[depId]) then
                allDepsLoaded = false
                break
            end

            if (not mvp.package.list[depId].isLoaded) then
                allDepsLoaded = false
                break
            end
        end

        if (allDepsLoaded) then
            mvp.package.dependenciesResolverList[id] = nil
            mvp.package.LoadPackage(package)
        end
    end
end)

--- Gets a package by its ID
-- This function returns a package by its ID. If not ID is specified, it will try to auto-find the package.
-- Auto-finding the package is only possible if the function is called from a file that is located in the package's folder.
-- If package ID differs from the folder name, you can add a lookup value with `mvp.package.AddLookupValue`.
-- If the package could not be found, an error will be thrown.
-- @tparam[opt] string id The ID of the package
-- @treturn mvp.meta.package The package
function mvp.package.Get(id)
    if (not id) then
        local cwd = debug.getinfo(2, "S").short_src
        local packageFolder = string.match(cwd, "mvp/packages/([^/]+)/[^/]+")
        
        if (mvp.package.lookup[packageFolder]) then
            packageFolder = mvp.package.lookup[packageFolder]
        end

        if (not packageFolder or not mvp.package.list[packageFolder]) then
            mvp.logger.Log(mvp.LOG.ERROR, "Could not auto-find package! Please specify the package ID manually!\n" .. cwd)
        end

        id = packageFolder
    end

    local package = mvp.package.list[id]
    if (not package) then
        package = mvp.package.list[mvp.package.lookup[id]]
    end

    return package
end

--- Gets is package is registered
-- This function returns if a package is registered.
-- @tparam string id The ID of the package
-- @treturn bool If the package is registered
function mvp.package.IsRegistered(id)
    return mvp.package.list[id] and true or false
end

--- Gets is package is loaded
-- This function returns if a package is loaded.
-- @tparam string id The ID of the package
-- @treturn bool If the package is loaded
function mvp.package.IsLoaded(id)
    return mvp.package.list[id] and mvp.package.list[id].isLoaded or false
end

--- Gets all registered packages
-- This function returns all registered packages.
-- @treturn table The packages
function mvp.package.GetAll()
    return mvp.package.list
end

--- Adds a lookup value
-- This function adds a lookup value for a package.
-- This is useful if the package ID differs from the folder name.
-- @tparam string original The original folder name
-- @tparam string lookFor The package ID
function mvp.package.AddLookupValue(original, lookFor)
    if (mvp.package.lookup[original]) then

        mvp.logger.Log(mvp.LOG.WARN, "Packages", "Lookup value '" .. original .. "' already registered! Overwriting...")
        mvp.logger.Log(mvp.LOG.WARN, "Packages", "This is probably a bug! Since this should not happen outside of development!")

        mvp.logger.Log(mvp.LOG.DEBUG, nil, "Key: " .. original)
        mvp.logger.Log(mvp.LOG.DEBUG, nil, "Original: " .. mvp.package.lookup[original])
        mvp.logger.Log(mvp.LOG.DEBUG, nil, "New: " .. lookFor)

        mvp.package.lookup[original] = nil
    end

    mvp.package.lookup[original] = lookFor
end

function mvp.package.Init()
    mvp.logger.Log(mvp.LOG.INFO, "Packages", "Loading packages...")

    local _, folders = file.Find( mvp.loader.relativePath .. "packages/*", "LUA")

    for k, v in ipairs(folders) do
        local files = file.Find(mvp.loader.relativePath .. "packages/" .. v .. "/*.lua", "LUA")

        for _, v2 in pairs(files) do
            if (v2 == "sh_package.lua") then
                mvp.loader.LoadFile("packages/" .. v .. "/" .. v2)
            end
        end
    end

    for k, v in pairs(mvp.package.dependenciesResolverList) do
        local missingDeps = {}

        for depId, isLoaded in pairs(v) do
            if (not isLoaded) then
                table.insert(missingDeps, depId)
            end
        end

        mvp.q.LogFatal("Packages", "Could not resolve dependencies for package '" .. k .. "'! Missing dependencies: " .. table.concat(missingDeps, ", ") .. "!")
    end

    mvp.logger.Log(mvp.LOG.INFO, "Packages", "Loading packages!")
end
--PATH lua/mvp/core/package/sh_package.meta.lua:
return gluapack()()
--PATH lua/mvp/packages/radialmenu/languages/en.lua:
local l = {}

l["radialmenu.select_option"] = "Select option to continue"

l["radialmenu.select"] = "Select"
l["radialmenu.cancel"] = "Cancel"

mvp.language.Register("en", l)
--PATH addons/[bronie] perfect-hands/lua/mvp/packages/perfecthands/animations/cl_animations.lua:
return gluapack()()
--PATH lua/mvp/gamemodes/darkrp.lua:
local gm = mvp.meta.gamemode:New()

gm:SetName("DarkRP")
gm:SetDescription("Support for DarkRP gamemode.")
gm:SetAuthor("Kot")
gm:SetVersion("1.0.0")
gm:SetLicense("MIT")

function gm:GetMoney(ply)
    return ply:getDarkRPVar("money") or 0
end

function gm:CanAfford(ply, sum)
    print(ply, sum)
    return ply:canAfford(sum)
end

function gm:AddMoney(ply, sum)
    return ply:addMoney(sum)
end

function gm:TakeMoney(ply, sum)
    return ply:addMoney(-sum)
end

function gm:FormatMoney(ply, sum)
    return DarkRP.formatMoney(sum)
end

mvp.gamemode.Register(gm)
--PATH lua/mvp/vgui/cl_frame.lua:
return gluapack()()
--PATH lua/mvp/vgui/cl_text_enty.lua:
return gluapack()()
--PATH lua/mvp/vgui/button/cl_button.lua:
local PANEL = {}

DEFINE_BASECLASS("Panel")

AccessorFunc(PANEL, "roundness", "Roundness")

function PANEL:Init()
    self.colors = {}
    
    self:SetStyle("secondary")
    self:SetFont(mvp.Font(18, 600))
    self:SetTextColor(mvp.colors.Text)
    self:SetRoundness(mvp.ui.ScaleWithFactor(16))

    self.backgroundColor = self.colors.Background

    self.extRoundness = {
        true, true, true, true
    }

    self.iconSize = 16
    self.icon = nil
end

function PANEL:Think()
    self:SetCursor(self:IsEnabled() and "hand" or "no")
end

function PANEL:SetIconSize(size)
    self.iconSize = size
end

function PANEL:SetIcon(icon, params)
    if (type(icon) ~= "IMaterial") then
        icon = Material(icon, params or "smooth")
    end

    self.icon = icon
end
function PANEL:PerformLayout(w, h)
    if (self.icon) then
        self.iconSize = h * .5
    end
end

function PANEL:SizeToContents(addedWidth, addedHeight)
    addedWidth = addedWidth or 0
    addedHeight = addedHeight or 0
    
    if (self.icon) then
        surface.SetFont(self:GetFont())
        local tw, th = surface.GetTextSize(self:GetText())

        self:SetSize(tw + self.iconSize + 5 + addedWidth, th + 10 + addedHeight)
    else
        BaseClass.SizeToContents(self, addedWidth, addedHeight)
    end
end

function PANEL:SizeToContentsX(addedWidth)
    addedWidth = addedWidth or 0
    
    if (self.icon) then
        surface.SetFont(self:GetFont())
        local tw, th = surface.GetTextSize(self:GetText())

        self:SetWide(tw + self.iconSize + 5 + addedWidth)
    else
        BaseClass.SizeToContentsX(self, addedWidth)
    end
end

function PANEL:SizeToContentsY(addedHeight)
    addedHeight = addedHeight or 0
    
    if (self.icon) then
        surface.SetFont(self:GetFont())
        local tw, th = surface.GetTextSize(self:GetText())

        self:SetTall(th + 10 + addedHeight)
    else
        BaseClass.SizeToContentsY(self, addedHeight)
    end
end

function PANEL:Paint(w, h)
    local col = self.backgroundColor
    
    if (not self:IsEnabled()) then
        col = Color(col.r * .4, col.g * .4, col.b * .4, col.a)
    end

    draw.RoundedBoxEx(self.roundness, 0, 0, w, h, col, unpack(self.extRoundness))
    
    if (self.icon) then
        surface.SetFont(self:GetFont())
        local tw, th = surface.GetTextSize(self:GetText())

        local iconSize = self.iconSize
        local iconX = (w - tw - iconSize) * .5 - 2.5
        local iconY = (h - iconSize) * .5

        local textX = iconX + iconSize + 5
        local textY = (h - th) * .5

        surface.SetDrawColor(self:GetTextColor())
        surface.SetMaterial(self.icon)
        surface.DrawTexturedRect(iconX, iconY, iconSize, iconSize)

        draw.SimpleText(self:GetText(), self:GetFont(), textX, textY, self:GetTextColor(), TEXT_ALIGN_LEFT)

        return true
    end

    draw.SimpleText(self:GetText(), self:GetFont(), w * .5, h * .5, self:GetTextColor(), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

    return true
end

function PANEL:OnCursorEntered()
    if (not self:IsEnabled()) then
        return
    end

    self:LerpColor("backgroundColor", self.colors.BackgroundHover, .2)
end

function PANEL:OnCursorExited()
    if (not self:IsEnabled()) then
        return
    end

    self:LerpColor("backgroundColor", self.colors.Background, .2)
end

function PANEL:SetRoundedTopLeft(b)
    self.extRoundness[1] = b
end
function PANEL:SetRoundedTopRight(b)
    self.extRoundness[2] = b
end
function PANEL:SetRoundedBottomLeft(b)
    self.extRoundness[3] = b
end
function PANEL:SetRoundedBottomRight(b)
    self.extRoundness[4] = b
end

function PANEL:SetExtendedRoundness(r)
    self:SetRoundedTopLeft(r[1])
    self:SetRoundedTopRight(r[2])
    self:SetRoundedBottomLeft(r[3])
    self:SetRoundedBottomRight(r[4])
end

local stylesMap = {
    ["primary"] = {
        mvp.ui.MuteColor(mvp.colors.Accent),
        mvp.colors.Accent
    },
    ["secondary"] = {
        mvp.colors.SecondaryBackground,
        mvp.colors.BackgroundHover
    },
    ["success"] = {
        ColorAlpha(mvp.colors.Green, 150),
        mvp.colors.Green
    },
    ["danger"] = {
        ColorAlpha(mvp.colors.Red, 150),
        mvp.colors.Red
    }
}

function PANEL:SetStyle(style)
    local styleColors = stylesMap[style]

    if (not styleColors) then
        return
    end

    self.colors.Background = styleColors[1]
    self.colors.BackgroundHover = styleColors[2]

    self.backgroundColor = self.colors.Background
end

function PANEL:SetCustomStyle(color, hoverColor)
    self.colors.Background = color
    self.colors.BackgroundHover = hoverColor

    self.backgroundColor = self.colors.Background
end

vgui.Register("mvp.Button", PANEL, "DButton")
--PATH lua/mvp/vgui/menu/cl_menu.lua:
local PANEL = {}

local roundness = mvp.ui.ScaleWithFactor(16)
local spaceBetween = mvp.ui.Scale(10)


function PANEL:Init()
    self.sidebar = vgui.Create("mvp.Sidebar", self)
    self.sidebar:Dock(LEFT)
    self.sidebar:SetWide(64 + spaceBetween * 3)
    self.sidebar:SetZPos(99)

    self.sidebar.close.DoClick = function()
        self:Remove()
    end

    self.content = vgui.Create("EditablePanel", self)
    self.content:Dock(FILL)
    self.content:DockMargin(-spaceBetween * 3, 0, 0, 0)
    self.content:DockPadding(spaceBetween * 3, 5, spaceBetween, spaceBetween)

    self.content.Paint = function(pnl, w, h)
        draw.RoundedBox(roundness, 0, 0, w, h, mvp.colors.Background)
    end

    self.buttons = {}
end

function PANEL:Paint(w, h)
    draw.RoundedBox(roundness, 0, 0, w, h, mvp.colors.SecondaryBackground)
end

function PANEL:GetCanvas()
    self.content:InvalidateParent(true)
    return self.content
end

function PANEL:AddButton(text, icon, callback, activeByDefault)
    local iconParams = "mips smooth"

    if (type(icon) ~= "IMaterial") then
        icon = Material(icon, iconParams)
    end

    local c = function(...)
        self:GetCanvas():Clear()

        if (callback) then
            callback(...)
        end
    end
    
    local but = self.sidebar:AddButton(text, icon, iconParams, c, activeByDefault)

    self.buttons[text] = but

    return but
end

function PANEL:SelectButton(text, ...)
    local but = self.buttons[text]
    
    if (but) then
        but:DoClick(...)
    end
end

function PANEL:AddSeparator()
    return self.sidebar:AddSeparator()
end

vgui.Register("mvp.Menu", PANEL, "EditablePanel")
--PATH lua/mvp/menus/admin/cl_credits.lua:
mvp = mvp or {}
mvp.menus = mvp.menus or {}

mvp.menus.admin = mvp.menus.admin or {}

local spaceBetween = mvp.ui.Scale(10)
local spacing = mvp.ui.Scale(10)

local linkMaterial = Material("mvp/terminal/vgui/link.png", "smooth mips")
local linkTypeMaterials = {
    ["workshop"] = Material("mvp/terminal/icons/steam.png", "smooth mips"),
    ["github"] = Material("mvp/terminal/icons/github.png", "smooth mips"),
    ["store"] = Material("mvp/terminal/icons/store.png", "smooth mips")
}

function mvp.menus.admin.Credits(container, defaultActive)
    defaultActive = defaultActive or "terminal"

    local content = vgui.Create("EditablePanel", container)
    content:Dock(FILL)
    content:InvalidateParent(true)

    local title = vgui.Create("mvp.MenuHeader", content)
    title:Dock(TOP)
    title:SetTall(mvp.ui.Scale(64))  
    
    title:SetText(mvp.q.Lang("ui.credits"))
    title:SetDescription(mvp.q.Lang("ui.credits.description"))

    local pageContent = vgui.Create("EditablePanel", content)
    pageContent:Dock(FILL)
    pageContent:InvalidateParent(true)

    local topNavigation = vgui.Create("DHorizontalScroller", pageContent)
    topNavigation:Dock(TOP)
    topNavigation:SetTall(mvp.ui.Scale(38))
    topNavigation:SetOverlap( -spaceBetween * .5 )

    local creditsContent = vgui.Create("EditablePanel", pageContent)
    creditsContent:Dock(FILL)
    creditsContent:DockMargin(0, spaceBetween * .5, 0, 0)
    creditsContent:InvalidateParent(true)

    local buttonGroup = vgui.Create("mvp.ButtonGroup")
    topNavigation:AddPanel(buttonGroup)
    buttonGroup:SetRoundness(mvp.ui.ScaleWithFactor(8))

    local buttons = {}

    buttons["terminal"] = buttonGroup:AddButton(mvp.q.Lang("ui.credits.terminal"), function()
        creditsContent:Clear()

        local contributors = mvp.credits.GetContributors()

        local grid = vgui.Create("ThreeGrid", creditsContent)
        grid:Dock(FILL)
        grid:InvalidateParent(true)

        grid:SetColumns(2)
        grid:SetHorizontalMargin(spaceBetween * .5)
        grid:SetVerticalMargin(spaceBetween * .5)

        for k, v in ipairs(contributors) do
            local pnl = vgui.Create("DPanel")
            pnl:SetTall(mvp.ui.Scale(128))

            local avatar = vgui.Create("AvatarImage", pnl)
            avatar:Dock(LEFT)
            avatar:DockMargin(spaceBetween, spaceBetween, spaceBetween, spaceBetween)
            avatar:InvalidateParent(true)
            avatar:SetSteamID(v.steamId, 128)
            avatar:SetWide(avatar:GetTall())
            
            pnl.Paint = function(pnl, w, h)
                draw.RoundedBox(mvp.ui.ScaleWithFactor(8), 0, 0, w, h, ColorAlpha(mvp.colors.SecondaryBackground, 150))

                local _, th = draw.SimpleText(v.name, mvp.Font(36, 600), spaceBetween + avatar:GetWide() + spaceBetween, spaceBetween, mvp.colors.Accent)
                draw.SimpleText(v.role, mvp.Font(24, 500), spaceBetween + avatar:GetWide() + spaceBetween, spaceBetween + th, mvp.colors.Text)
            end

            local button = vgui.Create("mvp.Button", pnl)
            button:Dock(BOTTOM)
            button:DockMargin(0, spaceBetween * 1.3, spaceBetween * 1.3, spaceBetween * 1.3)
            button:SetTall(mvp.ui.Scale(40))
            button:SetFont(mvp.Font(20, 500))
            button:SetRoundness(mvp.ui.ScaleWithFactor(8))
            button:SetText(mvp.q.Lang("ui.credits.steam_profile"))
            button:SetIcon(linkTypeMaterials["workshop"])
            
            button.DoClick = function()
                gui.OpenURL("https://steamcommunity.com/profiles/" .. v.steamId)
            end

            grid:AddCell(pnl)
        end
    end)
    buttons["icons"] = buttonGroup:AddButton(mvp.q.Lang("ui.credits.icons"), function()
        creditsContent:Clear()
        
        local icons = mvp.credits.GetIcons()

        local grid = vgui.Create("ThreeGrid", creditsContent)
        grid:Dock(FILL)
        grid:InvalidateParent(true)

        grid:SetColumns(3)
        grid:SetHorizontalMargin(spaceBetween * .5)
        grid:SetVerticalMargin(spaceBetween * .5)

        for k, v in pairs(icons) do
            local icon = vgui.Create("DPanel")
            icon:SetTall(mvp.ui.Scale(64))
            icon:DockMargin(0, 0, 0, spaceBetween * .5)

            local iconMaterial = v.icon
            local iconSize = mvp.ui.Scale(32)

            local text = mvp.q.Lang("general.by_x", v.author.name)

            icon.Paint = function(pnl, w, h)
                draw.RoundedBox(mvp.ui.ScaleWithFactor(8), 0, 0, w, h, ColorAlpha(mvp.colors.SecondaryBackground, 150))

                surface.SetDrawColor(mvp.colors.Text)
                surface.SetMaterial(iconMaterial)
                surface.DrawTexturedRect(spaceBetween * 2, h * .5 - iconSize * .5, iconSize, iconSize)

                draw.SimpleText(v.name, mvp.Font(24, 600), spaceBetween * 2 + iconSize + spaceBetween, h * .5, mvp.colors.Accent, nil, TEXT_ALIGN_BOTTOM)
                draw.SimpleText(text, mvp.Font(20, 500), spaceBetween * 2 + iconSize + spaceBetween, h * .5, mvp.colors.Text, nil, TEXT_ALIGN_TOP)
            end

            local iconButton = vgui.Create("mvp.ImageButton", icon)
            iconButton:Dock(RIGHT)
            iconButton:DockMargin(0, spaceBetween * 1.3, spaceBetween * 1.3, spaceBetween * 1.3)
            iconButton:SetImage(linkMaterial)

            iconButton.DoClick = function()
                gui.OpenURL(v.author.url)
            end


            grid:AddCell(icon)
        end
    end)
    buttons["packages"] = buttonGroup:AddButton(mvp.q.Lang("ui.credits.packages"), function()
        creditsContent:Clear() 
        
        local grid = vgui.Create("ThreeGrid", creditsContent)
        grid:Dock(FILL)
        grid:InvalidateParent(true)

        grid:SetColumns(3)
        grid:SetHorizontalMargin(spaceBetween * .5)
        grid:SetVerticalMargin(spaceBetween * .5)

        local packages = mvp.package.GetAll()

        for k, v in pairs(packages) do
            local package = vgui.Create("DPanel")
            package:SetTall(mvp.ui.Scale(80))

            local iconMaterial = v:GetIcon()
            local iconSize = mvp.ui.Scale(64)

            local packageName = v:GetName()
            local authorText = mvp.q.Lang("general.by_x", v:GetAuthor())

            package.Paint = function(pnl, w, h)
                draw.RoundedBox(mvp.ui.ScaleWithFactor(8), 0, 0, w, h, ColorAlpha(mvp.colors.SecondaryBackground, 150))

                if (iconMaterial and not iconMaterial:IsError()) then
                    surface.SetDrawColor(mvp.colors.Text)
                    surface.SetMaterial(iconMaterial)
                    surface.DrawTexturedRect(spaceBetween, h * .5 - iconSize * .5, iconSize, iconSize)
                else
                    draw.RoundedBox(mvp.ui.ScaleWithFactor(8), spaceBetween, h * .5 - iconSize * .5, iconSize, iconSize, mvp.colors.SecondaryBackground)
                    draw.SimpleText("?", mvp.Font(32, 600), spaceBetween + iconSize * .5, h * .5, mvp.colors.Text, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
                end

                draw.SimpleText(packageName, mvp.Font(24, 600), spaceBetween + iconSize + spaceBetween, h * .5, mvp.colors.Accent, nil, TEXT_ALIGN_BOTTOM)
                draw.SimpleText(authorText, mvp.Font(20, 500), spaceBetween + iconSize + spaceBetween, h * .5, mvp.colors.Text, nil, TEXT_ALIGN_TOP)
            end

            grid:AddCell(package)
        
        end
    end)
    
    if (not buttons[defaultActive]) then
        defaultActive = "terminal"
    end
    buttons[defaultActive]:DoClick()
end
--PATH lua/mvp/menus/admin/cl_home.lua:
mvp = mvp or {}
mvp.menus = mvp.menus or {}

mvp.menus.admin = mvp.menus.admin or {}
mvp.menus.admin.notifications = mvp.menus.admin.notifications or {}

local spaceBetween = mvp.ui.Scale(10)
local spacing = mvp.ui.Scale(10)

local linkTypeMaterials = {
    ["workshop"] = Material("mvp/terminal/icons/steam.png", "smooth mips"),
    ["github"] = Material("mvp/terminal/icons/github.png", "smooth mips"),
    ["store"] = Material("mvp/terminal/icons/store.png", "smooth mips")
}
local linkTypeNames = {
    ["workshop"] = "Steam Workshop",
    ["github"] = "GitHub",
    ["store"] = "Store"
}

function mvp.menus.admin.AddNotification(id, title, text, color, actions)
    mvp.menus.admin.notifications[#mvp.menus.admin.notifications + 1] = {
        id = id,
        title = title,
        text = text,
        color = color,
        actions = actions
    }
end
function mvp.menus.admin.ClearNotifications()
    mvp.menus.admin.notifications = {}
end
function mvp.menus.admin.GetNotifications()
    return mvp.menus.admin.notifications
end
function mvp.menus.admin.GetNotificationsCount()
    return #mvp.menus.admin.notifications
end
function mvp.menus.admin.RemoveNotification(id)
    for k, v in ipairs(mvp.menus.admin.notifications) do
        if (v.id == id) then
            table.remove(mvp.menus.admin.notifications, k)
            return
        end
    end
end
function mvp.menus.admin.HasNotification(id)
    for k, v in ipairs(mvp.menus.admin.notifications) do
        if (v.id == id) then
            return true
        end
    end

    return false
end

function mvp.menus.admin.AddNotificationPanel(pnl, title, text, color, actions)
    local scale = mvp.ui.ScaleWithFactor(8)
    
    local card = vgui.Create("EditablePanel", pnl)
    card:Dock(TOP)
    card:DockMargin(0, 0, 0, spaceBetween * .5)
    
    pnl:InvalidateLayout(true)
    card:InvalidateParent(true)

    card.Paint = function(pnl, w, h)
        draw.RoundedBox(scale, 0, 0, w - 3, h, color)
        draw.RoundedBoxEx(scale, scale, 0, w - scale, h, mvp.colors.BackgroundHover, false, true, false, true)
    end

    local cardActions = vgui.Create("EditablePanel", card)
    cardActions:Dock(RIGHT)
    cardActions:SetWide(mvp.ui.Scale(128))
    cardActions:DockMargin(0, spaceBetween, spaceBetween, 0)

    for k, v in ipairs(actions) do
        local action = vgui.Create("mvp.Button", cardActions)
        action:Dock(TOP)
        action:DockMargin(0, 0, 0, spaceBetween * .5)
        action:SetText(v.text)
        action:SetTall(mvp.ui.Scale(32))
        action:SetRoundness(mvp.ui.ScaleWithFactor(8))

        action.colors.BackgroundHover = mvp.colors.Background

        action.DoClick = function()
            if (v.callback) then
                v.callback()
            end
        end
    end

    local cardTexts = vgui.Create("DPanel", card)
    cardTexts:Dock(FILL)
    cardTexts:DockMargin(scale + spaceBetween, 0, spaceBetween, 0)
    cardTexts:InvalidateParent(true)

    local cardWidth = cardTexts:GetWide()
    local wrappedText = mvp.utils.WrapText(text, mvp.Font(20, 500), cardWidth)

    surface.SetFont(mvp.Font(22, 600))
    local _, headerHeight = surface.GetTextSize(title)
    surface.SetFont(mvp.Font(20, 500))
    local _, wrappedTextHeight = surface.GetTextSize(wrappedText)

    card:SetTall(wrappedTextHeight + headerHeight + spaceBetween * 2)

    cardTexts.Paint = function(pnl, w, h)
        draw.SimpleText(title, mvp.Font(22, 600), 0, 5, color)
        draw.DrawText(wrappedText, mvp.Font(20, 500), 0, headerHeight + spaceBetween, mvp.colors.Text, TEXT_ALIGN_LEFT)
    end

    return card
end

function mvp.menus.admin.Home(container)
    local content = vgui.Create("EditablePanel", container)
    content:Dock(FILL)
    content:InvalidateParent(true)

    local title = vgui.Create("mvp.MenuHeader", content)
    title:Dock(TOP)
    title:SetTall(mvp.ui.Scale(64))
    title:SetText(mvp.q.Lang("ui.home"))
    title:SetDescription(mvp.q.Lang("ui.home.description"))

    local pageContent = vgui.Create("EditablePanel", content)
    pageContent:Dock(FILL)
    pageContent:DockMargin(0, spaceBetween, 0, 0)
    pageContent:InvalidateParent(true)

    local left = vgui.Create("EditablePanel", pageContent)
    left:Dock(LEFT)
    left:SetWide(pageContent:GetWide() * 0.6 - spaceBetween * 0.5)

    local notifications = vgui.Create("EditablePanel", left)
    notifications:Dock(TOP)
    notifications:SetTall(mvp.ui.Scale(350))

    surface.SetFont(mvp.Font(22, 600))
    local _, h = surface.GetTextSize("Notifications")

    notifications:DockPadding(0, spaceBetween + h, 0, 0)
    notifications:InvalidateParent(true)

    notifications.Paint = function(pnl, w, h)
        draw.RoundedBox(mvp.ui.ScaleWithFactor(8), 0, 0, w, h, ColorAlpha(mvp.colors.SecondaryBackground, 100))

        draw.SimpleText("Notifications", mvp.Font(22, 600), spaceBetween, spaceBetween, mvp.colors.Text)
    end

    local notificationsList = vgui.Create("mvp.ScrollPanel", notifications)
    notificationsList:Dock(FILL)
    notificationsList:DockMargin(spaceBetween, spaceBetween, spaceBetween, spaceBetween)
    notificationsList:InvalidateParent(true)

    for k, v in ipairs(mvp.menus.admin.GetNotifications()) do
        mvp.menus.admin.AddNotificationPanel(notificationsList, v.title, v.text, v.color, v.actions)
    end

    local right = vgui.Create("EditablePanel", pageContent)
    right:Dock(RIGHT)
    right:SetWide(pageContent:GetWide() * 0.4 - spaceBetween * 0.5)

    local packages = vgui.Create("EditablePanel", right)
    packages:Dock(FILL)
    -- packages:SetTall(mvp.ui.Scale(350))

    local packagesText = mvp.q.Lang("ui.packages")
    surface.SetFont(mvp.Font(22, 600))
    local _, h = surface.GetTextSize(packagesText)
    
    packages:DockPadding(spaceBetween, spaceBetween + h, spaceBetween, 0)
    packages:InvalidateParent(true)

    packages.Paint = function(pnl, w, h)
        draw.RoundedBox(mvp.ui.ScaleWithFactor(8), 0, 0, w, h, ColorAlpha(mvp.colors.SecondaryBackground, 100))
        draw.SimpleText(packagesText, mvp.Font(22, 600), spaceBetween, spaceBetween, mvp.colors.Text)
    end

    local packagesList = vgui.Create("mvp.CategoryList", packages)
    packagesList:Dock(FILL)
    packagesList:DockMargin(0, spaceBetween - 2, 0, spaceBetween)
    packagesList:InvalidateParent(true)

    local installedPackagesCategory = packagesList:Add(mvp.q.Lang("ui.packages.installed"))
    local installedPackages = mvp.package.GetAll()

    local installedPackagesContent = vgui.Create("EditablePanel")
    installedPackagesCategory:SetContents(installedPackagesContent)

    local installedPackagesGrid = vgui.Create("ThreeGrid", installedPackagesContent)
    installedPackagesGrid:SetColumns(2)
    installedPackagesGrid:SetHorizontalMargin(spaceBetween * .5)
    installedPackagesGrid:SetVerticalMargin(spaceBetween * .5)

    installedPackagesContent:Dock(FILL)
    installedPackagesContent:InvalidateParent(true)
    installedPackagesGrid:Dock(TOP)
    installedPackagesGrid:InvalidateParent(true)
    
    for k, v in pairs(installedPackages) do
        local packagePanel = vgui.Create("DPanel")
        packagePanel:Dock(TOP)
        packagePanel:SetTall(mvp.ui.Scale(105))
        packagePanel:DockMargin(0, 0, 0, spaceBetween * .5)

        installedPackagesGrid:AddCell(packagePanel)

        local packageName = v:GetName()
        local packageDescription = v:GetDescription()

        function packagePanel:Paint(w, h)
            draw.RoundedBox(mvp.ui.ScaleWithFactor(8), 0, 0, w, h, ColorAlpha(mvp.colors.SecondaryBackground, 150))
            
            local packageLoaded = v.isLoaded
            draw.SimpleText(packageLoaded and "Loaded" or "Not loaded", mvp.Font(20, 600), w - spacing, spacing + 2, packageLoaded and mvp.colors.Green or mvp.colors.Red, TEXT_ALIGN_RIGHT)

            draw.SimpleText(packageName, mvp.Font(22, 600), spacing, spacing, mvp.colors.Accent)

            local wrappedText = mvp.utils.WrapText(packageDescription, mvp.Font(20, 500), w - spacing * 2)
            draw.DrawText(wrappedText, mvp.Font(20, 500), spacing, spacing + 20, mvp.colors.Text, TEXT_ALIGN_LEFT)
        end
    end
    installedPackagesGrid:SetTall(installedPackagesGrid:GetRowsHeight())

    http.Fetch("https://raw.githubusercontent.com/MULTIVERSE-Project/terminal/lists/packages-list.json", function(data, _, _, code)
        if (code ~= 200) then
            return
        end

        local packages = util.JSONToTable(data)

        local avaliblePackagesCategory = packagesList:Add(mvp.q.Lang("ui.packages.available"))
        avaliblePackagesCategory:DockMargin(0, spaceBetween * .5, 0, 0)
        local avaliblePackagesContent = vgui.Create("EditablePanel")
        avaliblePackagesCategory:SetContents(avaliblePackagesContent)

        local avaliblePackagesGrid = vgui.Create("ThreeGrid", avaliblePackagesContent)
        avaliblePackagesGrid:SetColumns(2)
        avaliblePackagesGrid:SetHorizontalMargin(spaceBetween * .5)
        avaliblePackagesGrid:SetVerticalMargin(spaceBetween * .5)

        avaliblePackagesContent:Dock(FILL)
        avaliblePackagesContent:InvalidateParent(true)
        avaliblePackagesGrid:Dock(TOP)
        avaliblePackagesGrid:InvalidateParent(true)

        for k, v in pairs(packages) do
            if (installedPackages[v.id]) then
                continue
            end

            local packagePanel = vgui.Create("DPanel")
            packagePanel:Dock(TOP)
            packagePanel:SetTall(mvp.ui.Scale(140))
            packagePanel:DockMargin(0, 0, 0, spaceBetween * .5)

            avaliblePackagesGrid:AddCell(packagePanel)

            local packageName = v.name
            local packageDescription = v.description

            local price = v.isFree and "Free" or v.price .. "$"

            function packagePanel:Paint(w, h)
                draw.RoundedBox(mvp.ui.ScaleWithFactor(8), 0, 0, w, h, ColorAlpha(mvp.colors.SecondaryBackground, 150))
                
                draw.SimpleText(price, mvp.Font(20, 600), w - spacing, spacing + 2, mvp.colors.Green, TEXT_ALIGN_RIGHT)

                draw.SimpleText(packageName, mvp.Font(22, 600), spacing, spacing, mvp.colors.Accent)

                local wrappedText = mvp.utils.WrapText(packageDescription, mvp.Font(20, 500), w - spacing * 2)
                draw.DrawText(wrappedText, mvp.Font(20, 500), spacing, spacing + 20, mvp.colors.Text, TEXT_ALIGN_LEFT)
            end

            local buttons = vgui.Create("mvp.ButtonGroup", packagePanel)
            buttons:Dock(BOTTOM)
            buttons:DockMargin(spaceBetween, spaceBetween * 1.3, spaceBetween, spaceBetween * 1.3)
            buttons:InvalidateParent(true)
            buttons:SetTall(mvp.ui.Scale(40))
            buttons:SetRoundness(mvp.ui.ScaleWithFactor(8))

            for k, v in pairs(v.links or {}) do
                if (v == "") then continue end

                buttons:AddButton(linkTypeNames[k] or k, function()
                    gui.OpenURL(v)
                end):SetIcon(linkTypeMaterials[k] or linkMaterial)
            end
        end
        avaliblePackagesGrid:SetTall(avaliblePackagesGrid:GetRowsHeight())
    end)
end
--PATH lua/mvp/menus/admin/cl_settings.lua:
mvp = mvp or {}
mvp.menus = mvp.menus or {}

mvp.menus.admin = mvp.menus.admin or {}

mvp.menus.admin.editedConfigs = mvp.menus.admin.editedConfigs or {}

local restoreToDefaultMaterial = Material("mvp/terminal/vgui/undo.png", "smooth")

local spaceBetween = mvp.ui.Scale(10)
local spacing = mvp.ui.Scale(10)

-- @notes: Maybe add a global storage for types and their input functions
local inputTypes = {
    -- 3 basic types
    [mvp.type.string] = function(config)
        local val = mvp.menus.admin.editedConfigs[config.key] or config.value
        
        local valueInput = vgui.Create("mvp.TextEntry")
        valueInput:SetRoundness(mvp.ui.ScaleWithFactor(8))
        
        valueInput:SetText(tostring(val))
        valueInput:SetUpdateOnType(true)

        function valueInput:OnValueChange(value)
            valueInput.UpdateConfigValue(value)
        end
        function valueInput:SetConfigValue(val)
            self:SetText(tostring(val))
        end

        return valueInput
    end,
    [mvp.type.number] = function(config)
        local val = mvp.menus.admin.editedConfigs[config.key] or config.value

        local valueInput = vgui.Create("mvp.TextEntry")
        valueInput:SetRoundness(mvp.ui.ScaleWithFactor(8))

        valueInput:SetText(tostring(val))
        valueInput:SetUpdateOnType(true)
        valueInput:SetNumeric(true)

        function valueInput:OnValueChange(value)
            valueInput.UpdateConfigValue(value)
        end
        function valueInput:SetConfigValue(val)
            self:SetText(tostring(val))
        end
        
        return valueInput
    end,
    [mvp.type.bool] = function(config)
        local val = config.value

        if (mvp.menus.admin.editedConfigs[config.key] ~= nil) then
            val = mvp.menus.admin.editedConfigs[config.key]
        end

        local valueInput = vgui.Create("mvp.CheckBox", configPanel)
        valueInput:SetRoundness(mvp.ui.ScaleWithFactor(8))

        valueInput:SetChecked(val)

        function valueInput:OnChanged(value)
            valueInput.UpdateConfigValue(value)
        end
        function valueInput:SetConfigValue(val)
            self:SetChecked(tobool(val))
        end


        return valueInput
    end,

    -- combo box
    ["dropdown"] = function(config)
        local val = mvp.menus.admin.editedConfigs[config.key] ~= nil and mvp.menus.admin.editedConfigs[config.key] or config.value
        
        local choices = config.ui.choices()
        local currentChoice = val

        local currentChoiceText = choices[currentChoice] or mvp.q.Lang("ui.general.none")

        local valueInput = vgui.Create("mvp.Button", configPanel)
        valueInput:SetRoundness(mvp.ui.ScaleWithFactor(8))
        valueInput:SetFont(mvp.Font(20, 500))
        valueInput:SetText(currentChoiceText)

        function valueInput:SetConfigValue(val)
            self:SetText(choices[val] or mvp.q.Lang("ui.general.none"))
        end

        valueInput.DoClick = function()
            local dropdown = vgui.Create("mvp.DropdownMenu")
            dropdown:SetRoundness(mvp.ui.ScaleWithFactor(8))
            dropdown:SetMinimumWidth(mvp.ui.Scale(200))

            for k, v in pairs(choices) do
                dropdown:AddOption(v, function()
                    valueInput:SetText(v)
                    valueInput.UpdateConfigValue(k)
                end)
            end

            local x, y = valueInput:LocalToScreen(0, valueInput:GetTall())

            dropdown:Open(x, y + spacing * .5)
        end

        return valueInput
    end,

    -- custom
    ["custom"] = function(config)
        local valueInput = vgui.Create("mvp.Button", configPanel)
        valueInput:SetRoundness(mvp.ui.ScaleWithFactor(8))
        valueInput:SetFont(mvp.Font(20, 500))
        valueInput:SetText(mvp.q.Lang("ui.general.edit"))

        function valueInput:DoClick()
            local value = mvp.menus.admin.editedConfigs[config.key] ~= nil and mvp.menus.admin.editedConfigs[config.key] or config.value
            config.ui.open(config, value, function(val)
                valueInput.UpdateConfigValue(val)
            end)
        end
        
        function valueInput:SetConfigValue(val)
            -- don't need this one here, since there no UI to update immediately
            -- leaving it here to avoid creating edge cases and errors
        end

        return valueInput
    end
}

function mvp.menus.admin.SettingsInput(container, restoreToDefaulButton, config)
    local inputType = config.ui.type and config.ui.type or config.typeOf
    local inputFunction = inputTypes[inputType]

    if (not inputFunction) then
        mvp.logger.Log(mvp.LOG.ERROR, nil, "No input function found for config " .. config.key)
        
        return
    end

    local onChange = function(value)
        mvp.menus.admin.editedConfigs[config.key] = value
    end

    local valueInput = inputFunction(config)
    valueInput.UpdateConfigValue = onChange

    valueInput:SetParent(container)
    valueInput:Dock(RIGHT)
    valueInput:DockMargin(0, spaceBetween * 1.3, spacing, spaceBetween * 1.3)
    valueInput:InvalidateParent(true)

    valueInput:SetWide(inputType == mvp.type.bool and valueInput:GetTall() or mvp.ui.Scale(200))

    restoreToDefaulButton.DoClick = function()
        valueInput:SetConfigValue(config.default)
        mvp.menus.admin.editedConfigs[config.key] = config.default
    end

    return valueInput
end

function mvp.menus.admin.SettingsCategory(container, configs)
    for key, config in SortedPairsByMemberValue(configs, "sortIndex") do
        if (config.ui.hide) then continue end

        local configPanel = vgui.Create("EditablePanel", container)
        configPanel:Dock(TOP)
        configPanel:DockMargin(0, 0, 0, spaceBetween)
        configPanel:SetTall(mvp.ui.Scale(64))

        local description = mvp.q.Lang("value." .. config.key .. ".description")
        if (string.StartsWith(description, "notfound#")) then
            description = config.description
        end

        configPanel.Paint = function(pnl, w, h)
            draw.RoundedBox(mvp.ui.ScaleWithFactor(8), 0, 0, w, h, ColorAlpha(mvp.colors.SecondaryBackground, 150))

            draw.SimpleText(key, mvp.Font(22, 600), spacing, spacing, mvp.colors.Accent)
            draw.SimpleText(description, mvp.Font(20, 500), spacing, h - spacing, mvp.colors.Text, nil, TEXT_ALIGN_BOTTOM)
        end

        local restoreToDefault = vgui.Create("mvp.ImageButton", configPanel)
        restoreToDefault:Dock(RIGHT)
        restoreToDefault:DockMargin(0, spaceBetween * 1.3, spacing, spaceBetween * 1.3)
        restoreToDefault:InvalidateParent(true)

        restoreToDefault:SetWide(restoreToDefault:GetTall())

        restoreToDefault:SetFont(mvp.Font(20, 500))
        restoreToDefault:SetRoundness(mvp.ui.ScaleWithFactor(8))
        restoreToDefault:SetImage(restoreToDefaultMaterial)

        local valueInput = mvp.menus.admin.SettingsInput(configPanel, restoreToDefault, config)
    end
end

function mvp.menus.admin.SettingsSection(container, categories)
    local configContent = vgui.Create("mvp.CategoryList", container)
    configContent:Dock(FILL)

    for _, category in SortedPairsByMemberValue(categories, "sortIndex") do
        local categoryPanel = configContent:Add(mvp.q.Lang("section." .. category.section .. "." .. category.name))
        categoryPanel:SetExpanded(true)
        categoryPanel:DockMargin(0, 0, 0, spaceBetween)

        local categoryContent = vgui.Create("EditablePanel")

        mvp.menus.admin.SettingsCategory(categoryContent, category.configs)

        categoryPanel:SetContents(categoryContent)
    end
end

function mvp.menus.admin.Settings(container, defaultActive)
    defaultActive = defaultActive or "terminal"
    mvp.menus.admin.editedConfigs = {}

    local content = vgui.Create("EditablePanel", container)
    content:Dock(FILL)
    content:InvalidateParent(true)

    local title = vgui.Create("mvp.MenuHeader", content)
    title:Dock(TOP)
    title:SetTall(mvp.ui.Scale(64))  
    
    title:SetText(mvp.q.Lang("ui.config"))
    title:SetDescription(mvp.q.Lang("ui.config.description"))

    local saveConfig = vgui.Create("mvp.Button", title)
    saveConfig:Dock(RIGHT)
    saveConfig:DockMargin(0, spaceBetween, spaceBetween, spaceBetween)
    saveConfig:SetText(mvp.q.Lang("ui.config.save"))
    saveConfig:SetStyle("success")
    saveConfig:SetFont(mvp.Font(20, 500))
    saveConfig:SetEnabled(false)
    saveConfig:SetRoundness(mvp.ui.ScaleWithFactor(8))
    saveConfig:SetIcon(Material("mvp/terminal/icons/save.png", "smooth"))
    saveConfig:SizeToContentsX(spaceBetween * 4)

    function saveConfig:DoClick()
        for k, v in pairs(mvp.menus.admin.editedConfigs) do
            mvp.config.Set(k, v)
        end
        mvp.menus.admin.editedConfigs = {}

        mvp.notification.Add(mvp.NOTIFICATION.SUCCESS, mvp.q.Lang("ui.config.saved"), mvp.q.Lang("ui.config.saved.description"))
    end

    function content:Think()
        local hasChanges = false
        for k, v in pairs(mvp.menus.admin.editedConfigs) do
            if (v == "") then
                mvp.menus.admin.editedConfigs[k] = nil
                continue 
            end

            if (mvp.config.Get(k) ~= v) then
                hasChanges = true
                break 
            end
        end

        saveConfig:SetEnabled(hasChanges)
    end

    local sections = mvp.config.sections
    local configSectionButtons = {}

    local pageContent = vgui.Create("EditablePanel", content)
    pageContent:Dock(FILL)

    local topNavigation = vgui.Create("DHorizontalScroller", pageContent)
    topNavigation:Dock(TOP)
    topNavigation:SetTall(mvp.ui.Scale(38))
    topNavigation:SetOverlap( -spaceBetween * .5 )

    local buttonGroup = vgui.Create("mvp.ButtonGroup")
    topNavigation:AddPanel(buttonGroup)
    buttonGroup:SetRoundness(mvp.ui.ScaleWithFactor(8))

    local configsSpace = vgui.Create("EditablePanel", pageContent)
    configsSpace:Dock(FILL)
    configsSpace:DockMargin(0, spaceBetween * .5, 0, 0)

    for k, v in SortedPairsByMemberValue(sections, "sortIndex") do
        local button = buttonGroup:AddButton(mvp.q.Lang("section." .. v.name), function()
            configsSpace:Clear()

            mvp.menus.admin.SettingsSection(configsSpace, v.categories)
        end)
        configSectionButtons[v.name] = button

        if (not configSectionButtons[defaultActive]) then
            defaultActive = v.name
        end
    end

    if (not configSectionButtons[defaultActive]) then
        defaultActive = "terminal"
    end

    configSectionButtons[defaultActive]:DoClick()
end
--PATH lua/ncs_shared/sh_hooks.lua:
return gluapack()()
--PATH lua/ncs_shared/characters/list/sh_mcs.lua:
NCS_SHARED.AddCharacterSystem("mcs", {
    GetCharacterID = function(P)    
        return P:GetCharacter()
    end,
    hooks = {
        ["CharacterDeleted"] = function(P, SLOT)
            hook.Run("NCS_SHARED_CharacterDeleted", P, SLOT)
        end,
        ["PlayerLoadedCharacter"] = function(P, SLOT)
            hook.Run("NCS_SHARED_CharacterLoaded", P, SLOT)
        end,
        ["PrePlayerLoadedCharacter"] = function(P, NEW, OLD)
            if not OLD then return end
    
            if NEW ~= OLD then
                hook.Run("NCS_SHARED_CharacterChanged", P, NEW, OLD)
            end
        end,
    }
})
--PATH lua/ncs_shared/characters/list/sh_nutscript.lua:
NCS_SHARED.AddCharacterSystem("nutscript", {
    GetCharacterID = function(P)    
        return ( P:getChar() and P:getChar():getID() )
    end,
    hooks = {
        ["OnCharacterDelete"] = function(P, SLOT)
            hook.Run("NCS_SHARED_CharacterDeleted", P, SLOT)
        end,
        ["PlayerLoadedChar"] = function(P, NEW, OLD)
            hook.Run("NCS_SHARED_CharacterLoaded", client, NEW:getID())

            if not OLD then return end
    
            if NEW ~= OLD then
                hook.Run("NCS_SHARED_CharacterChanged", client, NEW:getID(), OLD:getID())
            end
        end,
    }
})
--PATH lua/ncs_shared/characters/list/sh_voidchar.lua:
return gluapack()()
--PATH lua/ncs_shared/vgui/cl_frame.lua:
return gluapack()()
--PATH lua/ncs_shared/vgui/cl_sidebar.lua:
local COL_2 = Color(39,39,39,235)
local COL_3 = Color(36,36,36, 225)
local COL_4 = Color(68,131,171,255)

local PANEL = {
	Init = function(self)
        self.ACTIVE = false
        self.HOVERED = {}
        self.SELECTED = false

        local PARENT = self:GetParent()

        local w, h = PARENT:GetSize()

        self.SCROLL = vgui.Create("DScrollPanel", PARENT)
        self.SCROLL:Dock(LEFT)
        self.SCROLL:SetSize(w * 0.3, h)
        self.SCROLL:DockMargin(w * 0.02, h * 0.02, w * 0.02, h * 0.02)
        self.SCROLL.Paint = function(self, w, h)
            surface.SetDrawColor( Color(122,132,137, 180) )
            surface.DrawOutlinedRect( 0, 0, w, h )
        end
    end,
    AddPage = function(self, title, icon, cb)
        self.PAGES = self.PAGES or {}

        local COL = Color(122,132,137, 180)

        local BUTTON = self.SCROLL:Add("DButton")
        BUTTON:SetText("")
        
        local w, h = BUTTON:GetSize()
        BUTTON:Dock(TOP)
        BUTTON:SetHeight(self.SCROLL:GetTall() * 0.075)
        BUTTON:SetFont("NCS_SHARED_FRAME_TITLE")
        BUTTON:SetText(title)
        BUTTON:SetTextColor(color_white)

        BUTTON.Paint = function(s, w, h)
            local S_W, S_H = s:GetSize()

            if ( self.ACTIVE == title ) or self.HOVERED[s] then
                COL = Color(252,180,9,255)
            else
                COL = Color(122,132,137, 180)
            end

            surface.SetDrawColor(COL)
            surface.DrawOutlinedRect( 0, 0, w, h )

            local imageSize = w * 0.075 + (h * 0.1) * 1
            local imageOffset = (h - imageSize) / 2

            if icon then
                NCS_SHARED.DrawImgur(w * 0.05, imageOffset, imageSize, imageSize, icon, COL)
            end
        end

        BUTTON.DoClick = function(s)
            if self.SELECTED and self.SELECTED ~= s then
                if self.HOVERED[self.SELECTED] then
                    self.HOVERED[self.SELECTED] = false
                end

                self.SELECTED:SetTextColor(color_white)
            end

            self.SELECTED = s

            surface.PlaySound("ncs/ui/activate.mp3")

            self:SelectPage(title)
        end
        BUTTON.OnCursorEntered = function(s)
            surface.PlaySound("ncs/ui/slider.mp3")

            s:SetTextColor(Color(252,180,9,255))

            self.HOVERED[s] = true
        end
        BUTTON.OnCursorExited = function(s)
            if self.SELECTED == s then return end

            s:SetTextColor(color_white)

            self.HOVERED[s] = nil
        end

        self.PAGES[title] = {
            BUTTON = BUTTON,
            CALLBACK = cb,
        }
    end,
    GetPage = function(self)
        self.ACTIVE = self.ACTIVE or false

        return self.ACTIVE
    end,
    SelectPage = function(self, title)
        local TAB = self.PAGES[title]

        if TAB then
            if TAB.CALLBACK then
                TAB:CALLBACK()
            end

            self.ACTIVE = title
            self.SELECTED = self.PAGES[title].BUTTON

            self.SELECTED:SetTextColor(Color(252,180,9,255))

        end
    end,
}

vgui.Register( "NCS_SHARED_SIDEBAR", PANEL )
--PATH lua/ncs_shared/vgui/cl_textbutton.lua:
return gluapack()()
--PATH lua/autorun/new_effect_player.lua:
return gluapack()()
--PATH lua/autorun/new_effect_player.lua:

WeaponTrail = WeaponTrail or {}
if SERVER then
    AddCSLuaFile("effect/trail.lua")
	AddCSLuaFile("effect/trail.Bone_Set.lua")
    util.AddNetworkString("weapontrail.PlayEffect" )
    util.AddNetworkString("weapontrail.StopEffect" )
elseif CLIENT then
    include("effect/trail.lua")
	include("effect/trail.Bone_Set.lua")
    WeaponTrail.EffectList = WeaponTrail.EffectList or {}


    hook.Add( "PostDrawOpaqueRenderables", "WeaponTrail.Effect", function()
        local EffectList = WeaponTrail.EffectList
        local ply = LocalPlayer()
        for v, k in pairs(EffectList) do
            if k.Owner:IsValid() then
                if k.Draw then
                    k:Draw()
                    if k.Draw == false then
                      table.remove(WeaponTrail.EffectList, v)
                      if k.EndEffect then
                          k:EndEffect(ply)
                      end
                    end

                end
                if k.DieTime - CurTime() <= 0 then

                    table.remove(WeaponTrail.EffectList, v)
                    if k.EndEffect then
                        k:EndEffect(ply)
                    end
                end
            else
              table.remove(WeaponTrail.EffectList, v)
            end
        end

    end)
    hook.Add("Think", "WeaponTrail.EffectThink", function()
      /*
        local EffectList = WeaponTrail.EffectList
        local ply = LocalPlayer()
        for v, k in pairs(EffectList) do
            if k.Think then
                k:Think(ply)
                if k.Think == false then
                    table.remove(WeaponTrail.EffectList, v)
                    if k.EndEffect then
                        k:EndEffect(ply)
                    end
                end
            end
            if k.DieTime - CurTime() <= 0 then

                table.remove(WeaponTrail.EffectList, v)
                if k.EndEffect then
                    k:EndEffect(ply)
                end
            end
        end
        */
    end)
end

local meta = FindMetaTable("Entity")

function meta:SetWeaponTrail(mat, _time, size, flag)
    local data = {}
    data.Mat = mat
    data.Owner = self
    data.Time = _time
    data.Size = size
    data.Flag = flag

    net.Start("weapontrail.PlayEffect")
        net.WriteTable(data)
    net.Broadcast()
end
function meta:StopWeaponTrail()
    local data = {}
    data.Owner = self
    net.Start("weapontrail.StopEffect")
        net.WriteTable(data)
    net.Broadcast()
end
net.Receive("weapontrail.PlayEffect", function(len)
    local Data = net.ReadTable()
    local effect = WeaponTrail.Eff
    if effect then
        effect.Owner = Data.Owner
        effect.Mat = Data.Mat
        effect.CustomTime = Data.Time
        effect.Size = Data.Size
        effect.Flag = Data.Flag
        effect.DieTime = Data.Time + CurTime()
        if Data.Owner:IsValid() then
            effect:InitEffect()
        end
        if Data.Time != -1 then
            WeaponTrail.EffectList[#WeaponTrail.EffectList+1] = table.Copy( effect )
        end
    end
end)
net.Receive("weapontrail.StopEffect", function(len)
    local Data = net.ReadTable()
    local EffectList = WeaponTrail.EffectList
    for v, k in pairs(EffectList) do
        if !Data.Other or Data.Other == false then
            if k.Owner == Data.Owner then
                table.remove(WeaponTrail.EffectList, v)
            end
        elseif Data.Other == true then
            k.EndTime = 0
        end
    end
end)

--PATH lua/effect/trail.lua:
return gluapack()()
--PATH addons/[lib] onyx_framework_2/lua/onyx/init.lua:
return gluapack()()
--PATH addons/[lib] onyx_framework_2/lua/onyx/framework/libs/thirdparty/sh_cami.lua:
return gluapack()()
--PATH addons/[lib] onyx_framework_2/lua/onyx/framework/libs/thirdparty/sh_utf8.lua:
return gluapack()()
--PATH addons/[lib] onyx_framework_2/lua/onyx/framework/libs/sh_inconfig.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

03/05/2023

--]]

if (netchunk == nil) then
    include('sh_netchunk.lua')
end

netchunk.Register('onyx:SyncConfig')

onyx.inconfig = onyx.inconfig or {}
onyx.inconfig.options = onyx.inconfig.options or {}
onyx.inconfig.values = onyx.inconfig.values or {}
onyx.inconfig.index = onyx.inconfig.index or {}

local inconfig = onyx.inconfig

function inconfig:Register(id, data)
    assert(isstring(id), 'bad argument #1 to \'inconfig:Register\' (string expected, got ' .. type(id) .. ')')
    assert(istable(data), 'bad argument #2 to \'inconfig:Register\' (table expected, got ' .. type(data) .. ')')
    assert(data.type, 'you must provide type in option data (' .. id .. ')')
    assert(data.default ~= nil, 'you must provide default value in option data (' .. id .. ')')
    assert(isstring(data.cami), Format('bad field \"cami\"\'s value in option \"%s\" (expected string, got %s)', id, type(data.cami)))                                                                                                                                             -- 5409e8b9-5bf9-4f0d-8990-ecb0a7db9134 | fe61f1cf-ecf1-4a90-84f0-0c90ef8a0d27
    data.id = id
    if (SERVER) then
        data.title = nil
        data.desc = nil
    end
    if (not self.options[id]) then
        data.index = table.insert(inconfig.index, id)
    end
    self.options[id] = data
    return data
end

function inconfig:Get(id)
    local value = self.values[id]
    if (value ~= nil) then
        return value
    else
        local option = self.options[id]
        assert(option, 'trying to get value from unregistered option (' .. id .. ')')
        return option.default
    end
end

do
    inconfig.Error = {
        INVALID_VALUE = 0x0,
        NUMBER_EXPECTED = 0x1,
        STRING_EXPECTED = 0x2,
        MIN_CHARS = 0x3,
        MAX_CHARS = 0x4,
        MIN_NUMBER = 0x5,
        MAX_NUMBER = 0x6,
        INVALID_MODEL = 0x7
    }

    local types = {}
    types['bool'] = function(option, value)
        return isbool(value)
    end
    types['int'] = function(option, value)
        if (not isnumber(value)) then
            return false, inconfig.Error.NUMBER_EXPECTED
        end

        if (option.min and value < option.min) then
            return false, inconfig.Error.MIN_NUMBER, option.min
        end

        if (option.max and value > option.max) then
            return false, inconfig.Error.MAX_NUMBER, option.max
        end

        return true
    end
    types['string'] = function(option, value)
        if (not isstring(value)) then
            return false, inconfig.Error.STRING_EXPECTED
        end

        value = value:Trim()

        local len = utf8.len(value)

        if (option.min and len < option.min) then
            return false, inconfig.Error.MIN_CHARS
        end

        if (option.max and len > option.max) then
            return false, inconfig.Error.MAX_CHARS
        end

        return true
    end
    types['model'] = function(option, value)
        if (not isstring(value)) then
            return false, inconfig.Error.STRING_EXPECTED
        end

        value = value:Trim()

        local validModel = value:Right(4) == '.mdl'

        return validModel, inconfig.Error.INVALID_MODEL
    end

    function inconfig:CheckValue(id, value)
        local option = self.options[id]
        if (value == nil) then return false, inconfig.Error.INVALID_VALUE end

        local check = types[option.type]

        assert(check, 'invalid type (' .. option.type .. ') for option (' .. id .. ')')

        local allowed, enumError, argument = check(option, value)

        if (allowed and option.check) then
            return option.check(value)
        end

        return allowed, enumError, argument
    end
end

if (SERVER) then
    util.AddNetworkString('onyx.inconfig:Set')
    util.AddNetworkString('onyx.inconfig:SetTable')
    util.AddNetworkString('onyx.inconfig:SyncSingle')

    function inconfig:Set(id, value, bIgnoreOnSet)
        local option = self.options[id]
        assert(option, 'invalid option (' .. id .. ')')

        self.values[id] = value

        if (not bIgnoreOnSet and option.onSet) then
            option.onSet(value)
        end

        net.Start('onyx.inconfig:SyncSingle')
            net.WriteString(id)
            net.WriteString(onyx.TypeToString(value))
        net.Broadcast()

        hook.Run('onyx.inconfig.OnValueChange', id, value)
    end

    function inconfig:Sync(ply)
        netchunk.Send(ply, 'onyx:SyncConfig', self.values)
    end

    net.Receive('onyx.inconfig:Set', function(len, ply)
        local optionID = net.ReadString()
        local optionTable = inconfig.options[optionID]
        if (not optionTable) then return end
        if (ply:GetVar('onyx_inconfigRequestDelay', 0) > CurTime()) then return end

        ply:SetVar('onyx_inconfigRequestDelay', CurTime() + 1)

        local valueStr = net.ReadString() -- I guess that would be better than net.ReadType
        local success, valueParsed = pcall(onyx.StringToType, valueStr) -- in case someone tries to throw errors
        if (not success) then return end

        if (not inconfig:CheckValue(optionID, valueParsed)) then
            return
        end

        CAMI.PlayerHasAccess(ply, optionTable.cami, function(bAllowed)
            if (bAllowed) then
                inconfig:Set(optionID, valueParsed)
            end
        end)
    end)

    net.Receive('onyx.inconfig:SetTable', function(len, ply)
        -- local optionID = net.ReadString()
        if (ply:GetVar('onyx_inconfigRequestDelay', 0) > CurTime()) then return end

        ply:SetVar('onyx_inconfigRequestDelay', CurTime() + 1)

        local amount = net.ReadUInt(6)
        for index = 1, amount do
            local optionID = net.ReadString()
            local optionTable = inconfig.options[optionID]
            if (not optionTable) then return end -- not continue, just return, how can a player request to set invalid option without sending fake net messages :\

            local valueStr = net.ReadString() -- I guess that would be better than net.ReadType
            local success, valueParsed = pcall(onyx.StringToType, valueStr) -- in case someone tries to throw errors
            if (not success) then continue end -- just in case

            if (not inconfig:CheckValue(optionID, valueParsed)) then
                continue
            end

            CAMI.PlayerHasAccess(ply, optionTable.cami, function(bAllowed) -- every option may have own cami privilege
                if (bAllowed) then
                    inconfig:Set(optionID, valueParsed)
                end
            end)
        end
    end)

    hook.Add('onyx.PlayerNetworkReady', 'onyx.inconfig.Sync', function(ply)
        inconfig:Sync(ply)
    end)
else
    netchunk.Callback('onyx:SyncConfig', function(data)
        onyx.inconfig.values = data
        onyx:Print('Synchronized settings.')
        hook.Run('onyx.inconfig.Synchronized')
    end)

    net.Receive('onyx.inconfig:SyncSingle', function()
        local optionID = net.ReadString()
        local value = net.ReadString()
        local optionValue = onyx.StringToType(value)
        local oldValue = onyx.inconfig.values[optionID]

        onyx:Print('Updated option #, new value: #', optionID, value)
        onyx.inconfig.values[optionID] = optionValue

        hook.Run('onyx.inconfig.Updated', optionID, oldValue, optionValue)
    end)
end
--PATH addons/[lib] onyx_framework_2/lua/onyx/ui/sh_init_ui.lua:
return gluapack()()
--PATH addons/[lib] onyx_framework_2/lua/onyx/ui/libs/thirdparty/cl_tween.lua:
return gluapack()()
--PATH addons/[lib] onyx_framework_2/lua/onyx/ui/libs/cl_font.lua:
return gluapack()()
--PATH addons/[lib] onyx_framework_2/lua/onyx/ui/libs/cl_font.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

15/04/2022

--]]

onyx.fonts = {}

local string_Explode = string.Explode
local math_ceil = math.ceil
local surface_CreateFont = surface.CreateFont
local tonumber = tonumber

local function createFont(font, size, parameters, initialSize)
    local name = 'onyx.' .. font .. size .. util.CRC(parameters or '')

    if onyx.fonts[name] then
        return name
    end

    local data = {
        font = font,
        size = size,
        extended = true,
        initialSize = initialSize
    }

    if parameters then
        local tblParameters = string_Explode(';', parameters)
        for _, str in ipairs(tblParameters) do
            local parts = string_Explode(':', str)
            local key, val = parts[1], parts[2]
            if tonumber(val) then
                data[key] = tonumber(val)
            else
                if val == 'true' then
                    data[key] = true
                else
                    data[key] = false
                end
            end
        end
    end

    onyx.fonts[name] = data

    surface_CreateFont(name, data)

    return name
end

local fetchFont do
    local aliases = {}

    function fetchFont(family)
        local overridedFont = hook.Call('onyx.ui.OverrideFont', nil, family)
        return (overridedFont or aliases[family] or family)
    end

    local function createAlias(alias, real)
        aliases[alias] = real
    end

    createAlias('Averta', 'AvertaStd-Regular')
    createAlias('Averta Bold', 'AvertaStd-Bold')
    createAlias('Averta Black', 'AvertaStd-Black')
end

function onyx.Font(pattern, parameters)
    local parts = string_Explode('@', pattern)
    local family, size = fetchFont(parts[1]), tonumber(parts[2])
    local scaledSize = math_ceil(size / 900 * ScrH())

    return createFont(family, scaledSize, parameters, size)
end

function onyx.FontNoScale(pattern, size, parameters)
    local family

    if size then
        family = fetchFont(pattern)
    else
        local parts = string_Explode('@', pattern)

        family, size = fetchFont(parts[1]), parts[2]
    end

    return createFont(family, size, parameters)
end

hook.Add('OnScreenSizeChanged', 'onyx.font.Recreate', function()
    for name, data in pairs(onyx.fonts) do
        if data.initialSize then
            data.size = math_ceil(data.initialSize / 900 * ScrH())
            surface_CreateFont(name, data)
        end
    end
end)
--PATH addons/[lib] onyx_framework_2/lua/onyx/ui/traits/cl_hover.lua:
return gluapack()()
--PATH addons/[lib] onyx_framework_2/lua/onyx/ui/traits/cl_hover.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

18/04/2022

--]]

local TRAIT = {}

AccessorFunc(TRAIT, 'm_colIdle', 'ColorIdle')
AccessorFunc(TRAIT, 'm_colHover', 'ColorHover')
AccessorFunc(TRAIT, 'm_colPressed', 'ColorPressed')
AccessorFunc(TRAIT, 'm_bHoverBlocked', 'HoverBlocked')

local ANIM_DURATION = .2

local function isDisabled(panel)
    if panel.GetDisabled then
        return panel:GetDisabled()
    end
end

local function animColor(panel, targetkey, duration)
    local key = panel.m_ColorKey

    onyx.anim.Create(panel, duration or ANIM_DURATION, {
        index = onyx.anim.ANIM_HOVER,
        target = {
            [key] = panel[targetkey]
        }
    })
end

function TRAIT:SetColorKey(colorKey)
    self.m_ColorKey = colorKey
end

function TRAIT:SetColorIdle(color, offset)
    self.m_colIdle = color
    self[self.m_ColorKey] = onyx.CopyColor(color)

    if (offset) then
        self:SetColorHover(onyx.OffsetColor(color, offset))
    end
end

function TRAIT:OnPress()
    if isDisabled(self) then return end
    if self:GetHoverBlocked() then return end

    animColor(self, 'm_colPressed')
end

function TRAIT:OnRelease()
    if isDisabled(self) then return end
    if self:GetHoverBlocked() then return end
    if self:IsHovered() then
        animColor(self, 'm_colHover')
    end
end

function TRAIT:OnCursorEntered()
    if isDisabled(self) then return end
    if self:GetHoverBlocked() then return end

    animColor(self, 'm_colHover')
end

function TRAIT:OnCursorExited()
    if isDisabled(self) then return end
    if self:GetHoverBlocked() then return end

    animColor(self, 'm_colIdle')
end

onyx.trait.Register('hovercolor', TRAIT)
--PATH addons/[lib] onyx_framework_2/lua/onyx/ui/elements/cl_checkbox.lua:
return gluapack()()
--PATH addons/[lib] onyx_framework_2/lua/onyx/ui/elements/cl_color_wheel.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

13/06/2023

--]]

onyx.wimg.Register('color_wheel', 'https://i.imgur.com/i0asO69.png')

local wimgColorCircle = onyx.wimg.Create('color_wheel', 'mips')

local PANEL = {}

AccessorFunc(PANEL, 'm_Saturation', 'Saturation', FORCE_NUMBER)
AccessorFunc(PANEL, 'm_Hue', 'Hue', FORCE_NUMBER)
AccessorFunc(PANEL, 'm_Value', 'Value', FORCE_NUMBER)

function PANEL:Init()
    self:SetSaturation(0)
    self:SetHue(0)
    self:SetValue(1)
    self.dragging = false
end

function PANEL:SetValue(value)
    self.m_Value = math.Clamp(value, 0, 1)

    local brightness = 255 * self.m_Value
    local crosshairBrightness = 255 - brightness

    self.wheelColor = Color(brightness, brightness, brightness)
    self.crosshairColor = Color(crosshairBrightness, crosshairBrightness, crosshairBrightness)
end

function PANEL:Paint(w, h)
    local saturation = self.m_Saturation
    local hue = self.m_Hue

    -- draw circle with smooth edges
    render.PushFilterMin(TEXFILTER.ANISOTROPIC)
    render.PushFilterMag(TEXFILTER.ANISOTROPIC)
    wimgColorCircle:Draw(0, 0, w, h, self.wheelColor)
    render.PopFilterMin()
    render.PopFilterMag()

    -- draw crosshair
    local x0, y0 = w * .5, h * .5
    local x, y = x0, y0

    local r = h * .5 * saturation
    local rad = math.rad((hue - 90) % 360)
    local sin, cos = math.sin(rad), math.cos(rad)

    x = x0 + r * cos
    y = y0 + r * sin

    surface.SetDrawColor(self.crosshairColor)
    surface.DrawRect(x - 4, y - 1, 8, 2)
    surface.DrawRect(x - 1, y - 4, 2, 8)
end

function PANEL:OnMousePressed()
    self.dragging = true
    self:MouseCapture(true)
end

function PANEL:OnMouseReleased()
    self.dragging = false
    self:MouseCapture(false)
end

function PANEL:Think()
    if (self.dragging) then
        local x, y = self:ScreenToLocal(input.GetCursorPos())
        local w, h = self:GetSize()
        local radius = w * .5

        x = math.Clamp(x, 0, w)
        y = math.Clamp(y, 0, h)

        local xRelative0, yRelative0 = x - radius, y - radius

        local rad = math.atan2(yRelative0, xRelative0)
        local length = math.sqrt( math.pow(xRelative0, 2) + math.pow(yRelative0, 2) )

        self.m_Hue = (math.deg(rad) + 90) % 360
        self.m_Saturation = math.min(1, length / radius)
    end
end

function PANEL:GetColor()
    -- https://github.com/facepunch/garrysmod-issues/issues/2407
    local colorTable = HSVToColor(self.m_Hue, self.m_Saturation, self.m_Value)
    local colorObject = Color(colorTable.r, colorTable.g, colorTable.b)
    return colorObject
end

function PANEL:SetColor(color)
    local h, s, v = ColorToHSV(color)

    self:SetHue(h)
    self:SetSaturation(s)
    self:SetValue(v)
end

onyx.gui.Register('onyx.ColorWheel', PANEL)

-- onyx.gui.Test('DFrame', .5, .5, function(self)
--     self:MakePopup()

--     local mixer = self:Add('onyx.ColorWheel')
--     mixer:SetSize(64, 64)
--     mixer:Center()
--     mixer:SetSaturation(.5)
--     mixer:SetValue(1)
--     mixer:SetColor(Color(255, 53, 53))

--     local panel = self:Add('Panel')
--     panel:SetSize(48, 48)
--     panel.Paint = function(p, w, h)
--         surface.SetDrawColor(mixer:GetColor())
--         surface.DrawRect(0, 0, w, h)
--     end
-- end)
--PATH addons/[lib] onyx_framework_2/lua/onyx/ui/elements/cl_image.lua:
return gluapack()()
--PATH addons/[lib] onyx_framework_2/lua/onyx/ui/elements/cl_image.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

05/06/2022

--]]

local PANEL = {}

AccessorFunc(PANEL, 'm_Material', 'Material')
AccessorFunc(PANEL, 'm_colColor', 'Color')
AccessorFunc(PANEL, 'm_iImageAngle', 'ImageAngle')
AccessorFunc(PANEL, 'm_iImageScale', 'ImageScale')
AccessorFunc(PANEL, 'm_iImageWide', 'ImageWide')
AccessorFunc(PANEL, 'm_iImageTall', 'ImageTall')

function PANEL:Init()
    self:SetImageScale(1)
    self:SetImageAngle(0)
    self:SetColor(color_white)
    self:SetURL('https://i.imgur.com/PnE3dNf.png', 'smooth mips')
end

function PANEL:SetImageSize(w, h)
    h = h or w -- square

    self:SetImageWide(w)
    self:SetImageTall(h)
end

function PANEL:SetURL(url, parameters)
    self.m_WebImage = onyx.wimg.Simple(url, parameters)
end

function PANEL:SetWebImage(id, parameters)
    self.m_WebImage = onyx.wimg.Create(id, parameters)
end

function PANEL:SetSVG(id, w, h, colorable)
    self.m_SVG = onyx.svg.Create(id, w, (h or w), colorable)
end

function PANEL:SetImage(path, params)
    self:SetMaterial(Material(path, params))
end

function PANEL:GetWebImage()
    return self.m_WebImage
end

function PANEL:GetSVG()
    return self.m_SVG
end

function PANEL:Paint(w, h)
    self:Call('PaintBackground', nil, w, h)

    local webImage = self:GetWebImage()
    local material = self:GetMaterial()
    local svg = self:GetSVG()
    local color = self:GetColor()
    local scale = self:GetImageScale()
    local angle = self:GetImageAngle()
    local iw, ih = self:GetImageWide() or w, self:GetImageTall() or h
    local ix, iy = w * .5, h * .5

    iw = iw * scale
    ih = ih * scale

    if svg then
    --     print(svg:GetWide(), svg:GetMaterial())
        svg:Draw(w * .5 - svg:GetWide() * .5, h * .5 - svg:GetTall() * .5, nil, nil, color)
    elseif webImage then
        webImage:DrawRotated(ix, iy, iw, ih, angle, color)
    elseif material then
        onyx.DrawMaterialRotated(material, ix, iy, iw, ih, angle, color)
    end
end

onyx.gui.Register('onyx.Image', PANEL)

-- ANCHOR Test

-- onyx.gui.Test('onyx.Frame', .65, .65, function(self)
--     local test = self:Add('onyx.Image')
--     test:SetSVG('user-outline', 128, nil, true)
--     test:SetSize(256, 256)
--     test:Center()
--     test.PaintBackground = function(panel, w, h)
--         surface.SetDrawColor(0, 0, 0)
--         surface.DrawRect(0, 0, w, h)
--     end
-- end)
--PATH addons/[lib] onyx_framework_2/lua/onyx/ui/elements/cl_scroll.lua:
return gluapack()()
--PATH addons/[lib] onyx_framework_2/lua/onyx/ui/elements/cl_toggler.lua:
return gluapack()()
--PATH addons/[ui] onyx_f4/lua/onyx/modules/f4/sh_init.lua:
return gluapack()()
--PATH addons/[ui] onyx_f4/lua/onyx/modules/f4/core/cl_favorites.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

12/01/2024

--]]

onyx.f4.favorites = onyx.f4.favorites or {}

file.CreateDir('onyx_f4_favorites')

local function getFileName()
    local ip = game.GetIPAddress()
    return string.Explode(':', ip:gsub('%.', '_'))[1]
end

local function saveFavorites()
    local name = getFileName()

    file.Write('onyx_f4_favorites/' .. name .. '.json', util.TableToJSON(onyx.f4.favorites))
end

local function loadFavorites()
    local name = getFileName()
    local content = file.Read('onyx_f4_favorites/' .. name .. '.json', 'DATA')
    if (content) then
        local success, data = pcall(util.JSONToTable, content)
        if (success) then
            onyx.f4.favorites = data
        else
            onyx.f4:PrintError('Failed to load favorites.')
            print(data)
        end
    end
end
hook.Add('InitPostEntity', 'onyx.f4.LoadFavorites', loadFavorites)

function onyx.f4:SetFavorite(itemIdentifier, bState)
    self.favorites[itemIdentifier] = bState
    saveFavorites()
end

function onyx.f4:IsFavorite(itemIdentifier)
    return self.favorites[itemIdentifier]
end

function onyx.f4:FetchFavoriteObjects(itemType)
    local categories = DarkRP.getCategories()[itemType]
    if (not categories) then return false end

    local client = LocalPlayer()
    local clientTeam = client:Team()
    local showUnavailable = onyx.f4:GetOptionValue('job_show_unavailable')
    local showWrong = onyx.f4:GetOptionValue('job_show_requirejob')
    local result = {}

    for _, cat in ipairs(categories) do
        if ( cat.canSee and not cat.canSee( client ) ) then continue end

        for _, member in ipairs(cat.members or {}) do
            local id = (member.command or member.ent or member.entity or member.name)
            local customCheck = member.customCheck
            local needToChangeFrom = member.NeedToChangeFrom
            local allowed = member.allowed
            local reason

            if (customCheck and not customCheck(client)) then
                if (showUnavailable) then
                    reason = onyx.lang:Get('f4_unavailable')
                else
                    continue
                end
            end

            if (needToChangeFrom and needToChangeFrom ~= clientTeam) then
                if (showWrong) then
                    reason = onyx.lang:Get('f4_unavailable')
                else
                    continue
                end
            end

            if (allowed and not table.HasValue(allowed, clientTeam)) then
                continue
            end

            if (self:IsFavorite(id)) then
                table.insert(result, {
                    job = member,
                    item = member,
                    reason = reason
                })
            end
        end
    end

    return result
end
--PATH addons/[ui] onyx_f4/lua/onyx/modules/f4/core/sh_core.lua:
return gluapack()()
--PATH addons/[ui] onyx_f4/lua/onyx/modules/f4/core/stats/sh_stats.lua:
return gluapack()()
--PATH addons/[ui] onyx_f4/lua/onyx/modules/f4/cfg/cl_ranks.lua:
return gluapack()()
--PATH addons/[ui] onyx_f4/lua/onyx/modules/f4/ui/cl_frame.lua:
return gluapack()()
--PATH addons/[ui] onyx_f4/lua/onyx/modules/f4/ui/cl_job_preview.lua:
return gluapack()()
--PATH addons/[ui] onyx_f4/lua/onyx/modules/f4/ui/cl_tab_shop.lua:
return gluapack()()
--PATH addons/[ui] onyx_hud/lua/onyx/modules/hud/languages/cl_polish.lua:
--[[
KayZed @ 2024
--]]

local LANG = {}

--[[
    .............
    General Words
]]--

LANG[ 'hud_status_wanted' ] = 'Poszukiwany'
LANG[ 'hud_status_speaking' ] = 'Mwi'
LANG[ 'hud_status_typing' ] = 'Pisze'
LANG[ 'props' ] = 'Propy'
LANG[ 'close' ] = 'Zamknij'
LANG[ 'alert' ] = 'Alert'
LANG[ 'message' ] = 'Wiadomo'
LANG[ 'unknown' ] = 'Nieznany'
LANG[ 'accept' ] = 'Akceptuj'
LANG[ 'deny' ] = 'Odrzu'
LANG[ 'none' ] = 'Brak'
LANG[ 'add' ] = 'Dodaj'
LANG[ 'remove' ] = 'Usu'
LANG[ 'jobs' ] = 'Prace'
LANG[ 'door' ] = 'Drzwi'
LANG[ 'vehicle' ] = 'Pojazd'
LANG[ 'door_groups' ] = 'Grupy drzwi'
LANG[ 'display' ] = 'Wywietl'
LANG[ 'general' ] = 'Oglne'
LANG[ 'speedometer' ] = 'Prdkociomierz'
LANG[ 'fuel' ] = 'Paliwo'
LANG[ 'vote' ] = 'Gosowanie'
LANG[ 'question' ] = 'Pytanie'

--[[
    .......
    Timeout
]]--

LANG[ 'timeout_title' ] = 'UTRATA POCZENIA'
LANG[ 'timeout_info' ] = 'Serwer jest obecnie niedostpny, przepraszamy'
LANG[ 'timeout_status' ] = 'Zostaniesz ponownie poczony za %d sekund'

--[[
    ......
    Themes
]]--

LANG[ 'hud.theme.default.name' ] = 'Domylny'
LANG[ 'hud.theme.forest.name' ] = 'Las'
LANG[ 'hud.theme.violet_night.name' ] = 'Fioletowa Noc'
LANG[ 'hud.theme.rustic_ember.name' ] = 'Zardzewiay ar'
LANG[ 'hud.theme.green_apple.name' ] = 'Zielone Jabko'
LANG[ 'hud.theme.lavender.name' ] = 'Lawenda'
LANG[ 'hud.theme.elegance.name' ] = 'Elegancja'
LANG[ 'hud.theme.mint_light.name' ] = 'Mita'
LANG[ 'hud.theme.gray.name' ] = 'Szary'
LANG[ 'hud.theme.rose_garden.name' ] = 'Rany Ogrd'
LANG[ 'hud.theme.ocean_wave.name' ] = 'Oceaniczna Fala'
LANG[ 'hud.theme.sky_blue.name' ] = 'Niebieskie Niebo'
LANG[ 'hud.theme.golden_dawn.name' ] = 'Zota Jutrzenka'

--[[
    ....
    Help
    - Full phrase: "Type <command> to open settings"
]]

LANG[ 'hud_help_type' ] = 'Wpisz'
LANG[ 'hud_help_to' ] = 'aby otworzy ustawienia'

--[[
    .............
    3D2D Doors
]]--

LANG[ 'door_purchase' ] = 'Kup {object}'
LANG[ 'door_sell' ] = 'Sprzedaj {object}'
LANG[ 'door_addowner' ] = 'Dodaj waciciela'
LANG[ 'door_rmowner' ] = 'Usu waciciela'
LANG[ 'door_rmowner_help' ] = 'Wybierz gracza, ktremu chcesz odebra wasno'
LANG[ 'door_addowner_help' ] = 'Wybierz gracza, ktremu chcesz przyzna wasno'
LANG[ 'door_title' ] = 'Ustaw tytu'
LANG[ 'door_title_help' ] = 'Jaki tytu chcesz ustawi?'
LANG[ 'door_admin_disallow' ] = 'Odmw wasnoci'
LANG[ 'door_admin_allow' ] = 'Zezwl na wasno'
LANG[ 'door_admin_edit' ] = 'Edytuj dostp'
LANG[ 'door_owned' ] = 'Wasno Prywatna'
LANG[ 'door_unowned' ] = 'Na Sprzeda'

LANG[ 'hud_door_help' ] = 'Nacinij {bind}, aby kupi za {price}'
LANG[ 'hud_door_owner' ] = 'Waciciel: {name}'
LANG[ 'hud_door_allowed' ] = 'Uprawnieni do posiadania'
LANG[ 'hud_door_coowners' ] = 'Wspwaciciele'
LANG[ 'hud_and_more' ] = 'i wicej...'

--[[
    .........
    Uppercase
]]--

LANG[ 'reconnect_u' ] = 'PONOWNIE POCZ'
LANG[ 'disconnect_u' ] = 'ROZCZ'
LANG[ 'settings_u' ] = 'USTAWIENIA'
LANG[ 'configuration_u' ] = 'KONFIGURACJA'
LANG[ 'introduction_u' ] = 'WPROWADZENIE'

--[[
    .........
    Lowercase
]]--

LANG[ 'seconds_l' ] = 'sekundy'
LANG[ 'minutes_l' ] = 'minuty'

--[[
    .............
    Configuration
]]--

LANG[ 'hud.timeout.name' ] = 'Czas Trwania Przerwy'
LANG[ 'hud.timeout.desc' ] = 'Ile sekund przed automatycznym ponownym poczeniem'

LANG[ 'hud.alert_queue.name' ] = 'Kolejka Alertw'
LANG[ 'hud.alert_queue.desc' ] = 'Czy alerty powinny by umieszczone w kolejce'

LANG[ 'hud.props_counter.name' ] = 'Licznik propw'
LANG[ 'hud.props_counter.desc' ] = 'Poka licznik propw'

LANG[ 'hud.main_avatar_mode.name' ] = 'Gwny Typ Awatara'
LANG[ 'hud.main_avatar_mode.desc' ] = 'Wybierz typ'

LANG[ 'hud.voice_avatar_mode.name' ] = 'Typ Awatara Gosowego'
LANG[ 'hud.voice_avatar_mode.desc' ] = 'Wybierz typ'

LANG[ 'hud.restrict_themes.name' ] = 'Ogranicz Motywy'
LANG[ 'hud.restrict_themes.desc' ] = 'Ogranicz graczy do wyboru motyww'

LANG[ 'hud.speedometer_mph.name' ] = 'Uywaj Mil'
LANG[ 'hud.speedometer_mph.desc' ] = 'Przecz jednostki na mile na godzin'

LANG[ 'hud.speedometer_max_speed.name' ] = 'Maksymalna Domylna Prdko'
LANG[ 'hud.speedometer_max_speed.desc' ] = 'Maksymalna prdko dla prdkociomierza'

LANG[ 'hud_should_draw' ] = 'Czy powinno rysowa element'
LANG[ 'hud.main.name' ] = 'Gwne HUD'
LANG[ 'hud.ammo.name' ] = 'Amunicja'
LANG[ 'hud.agenda.name' ] = 'Agenda'
LANG[ 'hud.alerts.name' ] = 'Alerty'
LANG[ 'hud.pickup_history.name' ] = 'Historia Podnoszenia'
LANG[ 'hud.level.name' ] = 'Poziom'
LANG[ 'hud.voice.name' ] = 'Panele Gosowe'
LANG[ 'hud.overhead_health.name' ] = '3D2D Pasek Zdrowia'
LANG[ 'hud.overhead_armor.name' ] = '3D2D Pasek Pancerza'
LANG[ 'hud.vehicle.name' ] = 'HUD Pojazdu'

--[[
    ........
    Settings
]]--

LANG[ 'hud.theme.name' ] = 'Motyw'
LANG[ 'hud.theme.desc' ] = 'Wybierz motyw HUDu'

LANG[ 'hud.scale.name' ] = 'Skala'
LANG[ 'hud.scale.desc' ] = 'Dostosuj skal HUDu'

LANG[ 'hud.roundness.name' ] = 'Zaokrglenie'
LANG[ 'hud.roundness.desc' ] = 'Dostosuj zaokrglenie HUDu'

LANG[ 'hud.margin.name' ] = 'Margines'
LANG[ 'hud.margin.desc' ] = 'Odlego midzy HUDem a krawdziami'

LANG[ 'hud.icons_3d.name' ] = '3D Modele'
LANG[ 'hud.icons_3d.desc' ] = 'Renderuj ikony modeli w 3D'

LANG[ 'hud.compact.name' ] = 'Tryb Kompaktowy'
LANG[ 'hud.compact.desc' ] = 'Wcz tryb kompaktowy'

LANG[ 'hud.speedometer_blur.name' ] = 'Rozmycie Prdkociomierza'
LANG[ 'hud.speedometer_blur.desc' ] = 'Wcz rozmycie prdkociomierza'

LANG[ 'hud.3d2d_max_details.name' ] = 'Maks. Detale 3D2D'
LANG[ 'hud.3d2d_max_details.desc' ] = 'Maksymalna ilo szczegowych informacji renderowanych'

--[[
    ......
    Status
]]--

LANG[ 'hud_lockdown' ] = 'GODZINA POLICYJNA'
LANG[ 'hud_lockdown_help' ] = 'Prosz wrci do swoich domw!'

LANG[ 'hud_wanted' ] = 'POSZUKIWANY'
LANG[ 'hud_wanted_help' ] = 'Powd: {reason}'

LANG[ 'hud_arrested' ] = 'ARESZTOWANY'
LANG[ 'hud_arrested_help' ] = 'Zostaniesz wypuszczony za {time}'

onyx.lang:AddPhrases( 'polish', LANG )
--PATH addons/[ui] onyx_hud/lua/onyx/modules/hud/languages/cl_spanish.lua:
return gluapack()()
--PATH addons/[ui] onyx_hud/lua/onyx/modules/hud/core/cl_core.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

30/07/2024

--]]

onyx.hud.elements = onyx.hud.elements or {}
onyx.hud.sortedElements = onyx.hud.sortedElements or {}

local CONVAR_ROUNDNESS = CreateClientConVar( 'cl_onyx_hud_roundness', '8', true, false, '', 0, 16 )
local CONVAR_PADDING = CreateClientConVar( 'cl_onyx_hud_screen_padding', '30', true, false, '', 5, 40 )

RunConsoleCommand( 'mp_show_voice_icons', '0' )

local function updateSortedElements()
    onyx.hud.sortedElements = {}

    for id, element in pairs( onyx.hud.elements ) do
        table.insert( onyx.hud.sortedElements, element )        
    end

    table.sort( onyx.hud.sortedElements, function( a, b )
        return a.priority < b.priority -- reverse
    end )
end

do
    local cachedPadding = CONVAR_PADDING:GetInt()
    
    cvars.AddChangeCallback( 'cl_onyx_hud_screen_padding', function( _, _, new )
        cachedPadding = tonumber( new ) or CONVAR_PADDING:GetDefault()
    end, 'onyx.hud.internal' )

    function onyx.hud.GetScreenPadding()
        return onyx.ScaleTall( cachedPadding )
    end
end

do
    local parseRoundness = function( value ) return ( math.floor( value / 4 ) * 4 ) end
    local cachedRoundness = parseRoundness( CONVAR_ROUNDNESS:GetInt() )
    
    cvars.AddChangeCallback( 'cl_onyx_hud_roundness', function( _, _, new )
        cachedRoundness = parseRoundness( tonumber( new ) or CONVAR_ROUNDNESS:GetDefault() )
    end, 'onyx.hud.internal' )

    function onyx.hud.GetRoundness()
        return cachedRoundness
    end
end

function onyx.hud.IsElementEnabled( id )
    local optionID = 'hud_display_' .. id
    local optionTable = onyx.inconfig.options[ optionID ]

    if ( optionTable ) then
        return onyx.hud:GetOptionValue( 'display_' .. id )
    end

    return true
end

function onyx.hud.UpdateModelIcon( modelIcon, modelData )
    local is2D = modelIcon.ClassName == 'SpawnIcon'
    local model = modelData.model
    local skin = modelData.skin
    local bodygroups = modelData.bodygroups
    
    if ( is2D ) then
        -- This one is always rebuilding spawnicons...
        -- local bodygroupsStr = ''
        -- for index = 1, 9 do
        --     local id = index - 1
        --     local value = bodygroups[ id ] or 0            

        --     bodygroupsStr = bodygroupsStr .. tostring( value )
        -- end
        
        -- modelIcon:SetModel( model, skin, bodygroupsStr )

        if ( modelIcon:GetModelName() ~= model ) then
            modelIcon:SetModel( model )
        end
    else
        if ( modelIcon:GetModel() ~= model ) then
            modelIcon:SetModel( model ) 
        end

        local ent = modelIcon.Entity
        if ( IsValid( ent ) ) then
            ent:SetSkin( skin )

            for id, value in pairs( bodygroups ) do
                ent:SetBodygroup( id, value )
            end
        end
    end
end

function onyx.hud.GetModelData( ent )
    local bodygroups = {}
    for _, bodygroup in ipairs( ent:GetBodyGroups() ) do
        local id = bodygroup.id
        local value = ent:GetBodygroup( bodygroup.id )
    
        bodygroups[ id ] = value
    end
    
    return {
        model = ent:GetModel(),
        skin = ent:GetSkin(),
        bodygroups = bodygroups
    }
end

function onyx.hud.CompareModelData( modelData1, modelData2 )
    for key, value in pairs( modelData1 ) do
        local otherValue = modelData2[ key ]

        if ( istable( value ) ) then
            for key2, value2 in pairs( value ) do
                local otherValue2 = otherValue[ key2 ]
                if ( not otherValue2 or otherValue2 ~= value2 ) then
                    return false
                end
            end
        else
            if ( value ~= otherValue ) then
                return false
            end
        end
    end

    return true
end

do
    local COLOR_RED = Color( 255, 52, 52)
    local COLOR_BLUE = Color( 55, 52, 255)
    function onyx.hud.GetAnimColor( id )
        if ( id == 0 ) then
            return onyx.LerpColor( math.abs( math.sin( CurTime() ) ), COLOR_RED, COLOR_BLUE )
        end
    end
end

function onyx.hud.OverrideGamemode( id, fn )
    if ( GM or GAMEMODE ) then
        fn()
    end

    -- it's a bit harder to override darkrp func
    -- lol I've had super weird bug on my laptop, that not all InitPostEntity hooks were initiated (without any errors) so I've found this solution
    hook.Add( 'Think', id, function()
        hook.Remove( 'Think', id )
        timer.Create( id, engine.TickInterval(), 1, function()
            fn()
        end )
    end )
end

function onyx.hud.GetMaxProps( client )
    -- SAM / Other admin mod support, however source is unknown so we should avoid errors and stuff :\
    if ( client.GetLimit ) then
        local success, value = pcall( client.GetLimit, client, 'props' )
        if ( success and isnumber( value ) ) then
            return value
        end
    end

    return GetConVar( 'sbox_maxprops' ):GetInt()
end

do
    -- Because draw.SimpleText and other functions have surface.GetTextSize & we do not need it.
    local SetTextColor = surface.SetTextColor
    local SetTextPos = surface.SetTextPos
    local SetFont = surface.SetFont
    local DrawText = surface.DrawText
    function onyx.hud.DrawCheapText( text, font, x, y, color )
        local color = color or color_white

        SetTextColor( color.r, color.g, color.b, color.a )
        SetTextPos( x, y )
        SetFont( font )
        DrawText( text )
    end
end

do
    -- Micro-optimization since we are drawing it a lot of times
    local Clamp = math.Clamp
    local SetDrawColor = surface.SetDrawColor
    local DrawRect = surface.DrawRect
    local RoundedBoxEx = draw.RoundedBoxEx
    local GetRoundness = onyx.hud.GetRoundness
    function onyx.hud.DrawRoundedBoxEx( x, y, w, h, color, co1, co2, co3, co4 )
        local roundness = Clamp( GetRoundness(), 0, h * .5 )
        if ( roundness == 0 ) then
            SetDrawColor( color )
            DrawRect( x, y, w, h )
        else
            RoundedBoxEx( roundness, x, y, w, h, color, co1, co2, co3, co4 )
        end
    end
end

do
    local GetAlphaMultiplier = surface.GetAlphaMultiplier
    local SetAlphaMultiplier = surface.SetAlphaMultiplier
    function onyx.hud.OverrideAlpha( alpha, callback )
        local prev = GetAlphaMultiplier()

        SetAlphaMultiplier( math.min( alpha, prev ) )
            callback()
        SetAlphaMultiplier( prev )
    end
end

do
    local SetScissorRect = render.SetScissorRect
    function onyx.hud.ScissorRect( x, y, w, h, callback )
        SetScissorRect( x, y, x + w, y + h, true )
            callback()
        SetScissorRect( 0, 0, 0, 0, false )
    end
end

function onyx.hud.DrawRoundedBox( x, y, w, h, color )
    onyx.hud.DrawRoundedBoxEx( x, y, w, h, color, true, true, true, true )
end

do
    function onyx.hud.DrawShadowText( text, font, x, y, color, ax, ay )
        local textW, textH
    
        -- Calculate & return size only if required
        if ( ax or ay ) then
            surface.SetFont( font )
            textW, textH = surface.GetTextSize( text )
        
            if ( ax == 1 ) then
                x = x - textW * .5
            end
        
            if ( ay == 1 ) then
                y = y - textH * .5
            end
        end
        
        onyx.hud.DrawCheapText( text, font .. '.Blur', x + 2, y + 2, color_black, ax, ay )
        onyx.hud.DrawCheapText( text, font, x, y, color, ax, ay )
    
        return textW, textH
    end
end

do
    local ELEMENT_MT = {}
    ELEMENT_MT.__index = ELEMENT_MT

    AccessorFunc( ELEMENT_MT, 'm_bInitiliazed', 'Initialized' )

    function ELEMENT_MT:GetID()
        return tostring( self.id )
    end

    function ELEMENT_MT:IsEnabled()
        return onyx.hud.IsElementEnabled( self:GetID() )
    end

    function ELEMENT_MT:Draw( client, scrW, scrH )
        local drawFn = self.drawFn
        assert( drawFn, '\'' .. self:GetID() .. '\' missing draw function' )
        
        drawFn( self, client, scrW, scrH )
    end

    function onyx.hud:RegisterElement( id, data )
        onyx.AssertType( id, 'string', 'RegisterElement', 1 )
        onyx.AssertType( data, 'table', 'RegisterElement', 2 )
    
        data.id = id
        data.priority = data.priority or 50

        self.elements[ id ] = setmetatable( data, ELEMENT_MT )

        updateSortedElements()

        return self.elements[ id ]
    end
end

hook.Add( 'HUDPaint', 'onyx.hud.Paint', function()
    local client = LocalPlayer()
    local scrW, scrH = ScrW(), ScrH()

    if ( IsValid( client ) ) then
        if ( not onyx.hud.builtFonts ) then
            onyx.hud.BuildFonts()
        end

        for _, element in ipairs( onyx.hud.sortedElements ) do
            local id = element.id

            if ( not element:GetInitialized() ) then
                element:SetInitialized( true )
                if ( element.initFunc ) then
                    element:initFunc( client )
                end
            end
            
            if ( element:IsEnabled() ) then
                onyx.hud.StartScaling( id )
                    ProtectedCall( element.Draw, element, client, scrW, scrH ) -- it won't break the whole cycle
                onyx.hud.EndScaling()
            end
        end
    end
end )

do
    local HIDE = {
        [ 'DarkRP_HUD' ] = true,
        [ 'DarkRP_LocalPlayerHUD' ] = true,
        [ 'DarkRP_EntityDisplay' ] = true,
        [ 'DarkRP_Hungermod' ] = true,
        [ 'CHudHealth' ] = true,
        [ 'CHudBattery' ] = true,
        [ 'CHudDamageIndicator' ] = true,
        [ 'CHUDQuickInfo' ] = true,
        [ 'CHudSuitPower' ] = true,
        [ 'CHudPoisonDamageIndicator' ] = true
    }

    hook.Add( 'HUDShouldDraw', 'onyx.hud.Hide', function( name )
        if ( HIDE[ name ] ) then
            return false
        else
            for id, element in pairs( onyx.hud.elements ) do
                if ( element.hideElements and element.hideElements[ name ] ) then
                    return false
                end
            end
        end
    end )

    hook.Add( 'HUDDrawTargetID', 'onyx.hud.Hide', function()
        return false
    end )

    hook.Add( 'DrawDeathNotice', 'onyx.hud.Hide', function()
        return false
    end )
end
--PATH addons/[ui] onyx_hud/lua/onyx/modules/hud/core/cl_level_support.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

21/08/2024

--]]

onyx.hud.levelling = onyx.hud.levelling or {}

local function validateDataValue( data, key )
    assert( data[ key ], Format( '`onyx.hud.RegisterLevelSystem` bad data (missing value for \'%s\')', key ) )
    assert( isfunction( data[ key ] ), Format( '`onyx.hud.RegisterLevelSystem` bad data (the value should be function \'%s\')', type( data ), key ) )
end

function onyx.hud.RegisterLevelSystem( id, data )
    assert( isstring( id ), Format( '`onyx.hud.RegisterLevelSystem` bad argument #1 (expected string, got %s)', type( id ) ) )
    assert( istable( data ), Format( '`onyx.hud.RegisterLevelSystem` bad argument #2 (expected table, got %s)', type( data ) ) )
    validateDataValue( data, 'getLevel' )
    validateDataValue( data, 'getMaxXP' )
    validateDataValue( data, 'getXP' )
    validateDataValue( data, 'customCheck' )

    data.id = id
    onyx.hud.levelling[ id ] = data
end

function onyx.hud.IsLevellingEnabled()
    return ( onyx.hud.levelSystem ~= nil )
end

function onyx.hud.GetLevelData( client )
    local sysTable = onyx.hud.levelSystem
    if ( sysTable ) then
        local level = math.Round( sysTable.getLevel( client ) )
        local maxXP = math.Round( sysTable.getMaxXP( client ) )
        local xp = math.Round( sysTable.getXP( client ) )

        return level, xp, maxXP
    end
end

onyx.WaitForGamemode( 'onyx.hud.CheckLevelSystem', function()
    for sysID, sysTable in pairs( onyx.hud.levelling ) do
        if ( sysTable.customCheck() ) then
            if ( not sysTable.detected and sysTable.onDetected ) then
                sysTable.detected = true
                sysTable.onDetected()
            end

            onyx.hud.levelSystem = sysTable
        end
    end
end )
--PATH addons/[ui] onyx_hud/lua/onyx/modules/hud/core/cl_theme.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

14/08/2024

--]]

onyx.hud.themes = onyx.hud.themes or {}

local CONVAR_THEME = CreateClientConVar( 'cl_onyx_hud_theme_id', 'default', true, false )

cvars.AddChangeCallback( 'cl_onyx_hud_theme_id', function( _, _, new )
    hook.Run( 'onyx.hud.OnChangedTheme', onyx.hud:GetCurrentTheme() )
end, 'onyx.hud.internal' )

-- predefined colors
local COLORS = {
    [ 'light' ] = {
        textPrimary = color_black,
        textSecondary = Color( 45, 45, 45 ),
        textTertiary = Color( 70, 70, 70),
        negative = Color( 210, 35, 35),
        lockdown = Color( 166, 44, 44)
    },
    [ 'dark' ] = {
        textPrimary = color_white,
        textSecondary = Color( 171, 171, 171),
        textTertiary = Color( 97, 97, 97),
        negative = Color( 255, 76, 76),
        lockdown = Color( 255, 76, 76)
    }
}

function onyx.hud:GetColor( id )
    local themeTable = self:GetCurrentTheme()
    local colorsTable = themeTable.colors
    
    return ( colorsTable[ id ] )
end

function onyx.hud:GetCurrentTheme()
    if ( self:GetOptionValue( 'restrict_themes' ) ) then
        return self.themes[ 'default' ]
    else
        local themeID = CONVAR_THEME:GetString()
        return ( self.themes[ themeID ] or self.themes[ 'default' ] )
    end
end

function onyx.hud:IsDark()
    return self:GetCurrentTheme().dark
end

function onyx.hud:CreateTheme( id, data )
    local colors = data.colors
    local _, _, lightness = ColorToHSL( colors.primary )
    local isDark = lightness < .5
    local predefinedColors = COLORS[ isDark and 'dark' or 'light' ]

    data.id = id
    data.dark = isDark
    data.isDark = isDark
    
    table.Inherit( colors, predefinedColors )
    
    self.themes[ id ] = data
end

--PATH addons/[ui] onyx_hud/lua/onyx/modules/hud/cfg/cl_level_systems.lua:
return gluapack()()
--PATH addons/[ui] onyx_hud/lua/onyx/modules/hud/elements/cl_agenda.lua:
return gluapack()()
--PATH addons/[ui] onyx_hud/lua/onyx/modules/hud/elements/cl_pickup_history.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

14/08/2024

--]]

local TYPE_AMMO = 0
local TYPE_WEAPON = 1
local TYPE_ITEM = 2
local HOLD_DURATION = 3

local hud = onyx.hud
local history = {}

-- Colors inspired by the original UI, so it would be easy to adapt for players
local TYPES = {
    [ TYPE_AMMO ] = Color( 107, 136, 255 ),
    [ TYPE_ITEM ] = Color( 107, 255, 166 ),
    [ TYPE_WEAPON ] = Color( 255, 198, 107),
}

local MAX_RECORDS = 10

local function addRecord( name, type, amount )
    table.insert( history, 1, {
        name = name,
        amount = amount,
        endtime = CurTime() + HOLD_DURATION,
        duration = HOLD_DURATION,
        type = type,
        color = TYPES[ type ],
        fraction = 0
    } )

    if ( #history > MAX_RECORDS ) then 
        table.remove( history, ( MAX_RECORDS + 1 ) )
    end
end

hook.Add( 'onyx.inconfig.Updated', 'onyx.hud.ClearPickupHistory', function( id, old, new )
    if ( id and id == 'hud_display_pickup_history' ) then
        history = {}
    end
end )

hook.Add( 'HUDAmmoPickedUp', 'onyx.hud.InsertPickupHistory', function( ammoID, amount )
    if ( onyx.hud:GetOptionValue( 'display_pickup_history' ) ) then
        local niceName = language.GetPhrase( string.format( '#%s_ammo', ammoID ) )
    
        for _, record in ipairs( history ) do
            if ( record.name == niceName ) then
                record.endtime = CurTime() + HOLD_DURATION
                record.fraction = 0
                record.amount = record.amount + amount
                return true
            end
        end
    
        addRecord( niceName, TYPE_AMMO, amount )
    end

    return true
end )

hook.Add( 'HUDWeaponPickedUp', 'onyx.hud.InsertPickupHistory', function( weapon )
    -- lol I have encountered a really weird bug when physgun_beam is passed here
    if ( IsValid( weapon ) and weapon:IsWeapon() and onyx.hud:GetOptionValue( 'display_pickup_history' ) ) then
        addRecord( language.GetPhrase( weapon:GetPrintName() ), TYPE_WEAPON, 1 )
    end
    return true
end )

hook.Add( 'HUDItemPickedUp', 'onyx.hud.InsertPickupHistory', function( itemName )
    if ( onyx.hud:GetOptionValue( 'display_pickup_history' ) ) then
        addRecord( language.GetPhrase( itemName ), TYPE_ITEM, 1 )
    end

    return true
end )

hook.Add( 'HUDDrawPickupHistory', 'onyx.hud.DrawPickupHistory', function()
    if ( #history == 0 ) then return true end
    if ( not onyx.hud:GetOptionValue( 'display_pickup_history' ) ) then return true end

    local scrW = ScrW()
    local scrH = ScrH()

    local screenPadding = onyx.hud.GetScreenPadding() * 0.5
    local baseY = scrH * .5
    local baseX = scrW - screenPadding

    local colorPrimary = onyx.hud:GetColor( 'primary' )
    local colorPrimaryText = onyx.hud:GetColor( 'textPrimary' )

    local recordW = hud.ScaleWide( 140 )
    local recordH = hud.ScaleTall( 22 )
    local recordSpace = hud.ScaleTall( 5 )
    local lineW = hud.ScaleWide( 5 )
    local padding = hud.ScaleTall( 5 )
    local posY = baseY

    for index, record in ipairs( history ) do
        local isExpired = record.endtime <= CurTime()
        local targetFraction = isExpired and 0 or 1
        local amount = record.amount

        record.fraction = math.Approach( record.fraction, targetFraction, FrameTime() * 8 )

        local posX = baseX - recordW

        record.x = Lerp( record.fraction, ScrW(), posX )
        record.y = Lerp( FrameTime() * 16, record.y or posY, posY )
        local x, y = record.x, record.y

        local prevAlpha = surface.GetAlphaMultiplier()

        surface.SetAlphaMultiplier( record.fraction )
    
            hud.DrawRoundedBox( x, y, recordW, recordH, colorPrimary )

            render.SetScissorRect( x, y, x + lineW, y + recordH, true )
                hud.DrawRoundedBox( x, y, recordW, recordH, record.color )
            render.SetScissorRect( 0, 0, 0, 0, false )

            draw.SimpleText( record.name, onyx.hud.fonts.TinyBold, x + padding + lineW, y + recordH * .5, colorPrimaryText, 0, 1 )

            if ( amount > 1 ) then
                draw.SimpleText( amount, onyx.hud.fonts.TinyBold, x + recordW - padding, y + recordH * .5, colorPrimaryText, 2, 1 )
            end
            
        surface.SetAlphaMultiplier( prevAlpha )

        posY = posY - recordH - recordSpace

        if ( isExpired and record.fraction == 0 ) then
            table.remove( history, index )
        end
    end

    return true
end )
--PATH addons/[ui] onyx_hud/lua/onyx/modules/hud/elements/cl_status.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

18/08/2024

--]]

local hud = onyx.hud
local arrestEndTime

local L = function( ... ) return onyx.lang:Get( ... ) end
local WIMG_LOCKDOWN = onyx.wimg.Create( 'hud_lockdown', 'smooth mips' )
local WIMG_WANTED = onyx.wimg.Create( 'hud_wanted', 'smooth mips' )
local WIMG_ARRESTED = onyx.wimg.Create( 'hud_arrested', 'smooth mips' )

local function drawLabel( x, y, w, h, padding, wimg, title, desc, color )
    local x0, y0 = x + w * .5, y + h * .5
    local iconSize = h - padding * 2

    hud.DrawRoundedBox( x, y, w, h, hud:GetColor( 'primary' ) )

    wimg:Draw( x + padding, y + padding, iconSize, iconSize, ColorAlpha( color, 100 + 155 * math.abs( math.sin( CurTime() * 4 ) ) ) )

    draw.SimpleText( title, hud.fonts.TinyBold, x + padding * 2 + iconSize, y0, color, 0, 4 )
    draw.SimpleText( desc, hud.fonts.Tiny, x + padding * 2 + iconSize, y0, hud:GetColor( 'textSecondary' ), 0, 0 )
end

hud:RegisterElement( 'status', { 
    height = 120,
    priority = 60,
    drawFn = function( element, client, scrW, scrH )
        local parent = onyx.hud.elements[ 'agenda' ]
        local screenPadding = hud.GetScreenPadding()
        local padding = hud.ScaleTall( parent.padding )
        local w = hud.ScaleWide( parent.width )
        local h = hud.ScaleTall( 50 )
        local space = hud.ScaleTall( 7.5 )

        local x, y = scrW - w - screenPadding, screenPadding
        if ( parent.active ) then
            y = y + hud.ScaleTall( parent.height ) + space
        end

        if ( GetGlobalBool( 'DarkRP_LockDown' ) ) then
            drawLabel( x, y, w, h, padding, WIMG_LOCKDOWN, L( 'hud_lockdown' ), L( 'hud_lockdown_help' ), hud:GetColor( 'lockdown' ) )
            y = y + h + space
        end

        if ( client:getDarkRPVar( 'wanted' ) ) then
            drawLabel( x, y, w, h, padding, WIMG_WANTED, L( 'hud_wanted' ), L( 'hud_wanted_help', { reason = client:getDarkRPVar( 'wantedReason' ) or '' } ), hud.GetAnimColor( 0 ) )
            y = y + h + space
        end

        if ( client:getDarkRPVar( 'Arrested' ) ) then
            local timeLeft = arrestEndTime and math.Clamp( math.Round( arrestEndTime - CurTime() ), 0, 9999 ) or -1
            local timeFormatted
        
            if ( timeLeft >= 0 ) then
                if ( timeLeft > 300 ) then
                    timeFormatted = string.format( '%d %s', math.Round( timeLeft / 60 ) , L( 'minutes_l' ) )
                else
                    timeFormatted = string.format( '%d %s', timeLeft , L( 'seconds_l' ) )
                end
            else
                timeFormatted = L( 'unknown' )
            end

            local helpText = L( 'hud_arrested_help', { time = timeFormatted } )

            drawLabel( x, y, w, h, padding, WIMG_ARRESTED, L( 'hud_arrested' ), helpText, hud:GetColor( 'textPrimary' ) )
        else
            arrestEndTime = nil
        end
    end, 
} )

onyx.hud.OverrideGamemode( 'onyx.hud.OverrideArrest', function()
    usermessage.Hook( 'GotArrested', function( msg )
        arrestEndTime = CurTime() + msg:ReadFloat()
    end )
end )
--PATH addons/[ui] onyx_hud/lua/onyx/modules/hud/elements/cl_voice_chat.lua:
return gluapack()()
--PATH addons/[ui] onyx_scoreboard/lua/onyx/modules/scoreboard/sh_init.lua:
return gluapack()()
--PATH addons/[ui] onyx_scoreboard/lua/onyx/modules/scoreboard/languages/cl_polish.lua:
--[[
KayZed @ 2024
--]]

local LANG = {}

-- Phrases
LANG['copied_clipboard'] = 'Skopiowano do schowka'
LANG['scoreboard_search'] = 'Szukaj... (Nazwa/SteamID)'
LANG['you'] = 'Ty'
LANG['friend'] = 'Przyjaciel'
LANG['addon_return_u'] = 'POWRT'

-- Columns
LANG['scoreboard_col_team'] = 'Druyna'
LANG['scoreboard_col_job'] = 'Praca'
LANG['scoreboard_col_money'] = 'Pienidze'
LANG['scoreboard_col_rank'] = 'Ranga'
LANG['scoreboard_col_karma'] = 'Karma'
LANG['scoreboard_col_playtime'] = 'Czas Gry'
LANG['scoreboard_col_health'] = 'Zdrowie'
LANG['scoreboard_col_level'] = 'Poziom'
LANG['scoreboard_col_none'] = 'Brak'
LANG['scoreboard_col_gang'] = 'Gang'
LANG['scoreboard_col_ashop_badges'] = 'Odznaki'
LANG['scoreboard_col_faction'] = 'Frakcja'

-- Name Effects
LANG['scoreboard_eff_default'] = 'Domylny'
LANG['scoreboard_eff_glow'] = 'Powiata'
LANG['scoreboard_eff_rainbow'] = 'Tcza'
LANG['scoreboard_eff_scanning_vertical'] = 'Skanujcy (Pionowo)'
LANG['scoreboard_eff_scanning_horizontal'] = 'Skanujcy (Poziomo)'
LANG['scoreboard_eff_gradient_invert'] = 'Gradient (Odwr Kolor)'
LANG['scoreboard_eff_wavy_dual'] = 'Falujcy (Podwjny Kolor)'

-- Buttons
LANG['scoreboard_btn_profile'] = 'Otwrz Profil'
LANG['scoreboard_btn_freeze'] = 'Zamro'
LANG['scoreboard_btn_goto'] = 'Id Do'
LANG['scoreboard_btn_bring'] = 'Przynie'
LANG['scoreboard_btn_return'] = 'Powrt'
LANG['scoreboard_btn_respawn'] = 'Odrod'
LANG['scoreboard_btn_slay'] = 'Zabij'
LANG['scoreboard_btn_spectate'] = 'Obserwuj'

-- Words
LANG['rank_id'] = 'Identyfikator Rangi'
LANG['name'] = 'Nazwa'
LANG['effect'] = 'Efekt'
LANG['color'] = 'Kolor'
LANG['preview'] = 'Podgld'
LANG['creation'] = 'Tworzenie'
LANG['save'] = 'Zapisz'
LANG['dead'] = 'Martwy'
LANG['create_new'] = 'Utwrz Nowy'
LANG['column'] = 'Kolumna'

-- Settings
LANG['addon_settings_u'] = 'USTAWIENIA'
LANG['scoreboard_ranks_u'] = 'RANGI'
LANG['scoreboard_columns_u'] = 'KOLUMNY'

LANG['scoreboard.title.name'] = 'Tytu'
LANG['scoreboard.title.desc'] = 'Wprowad tytu dla ramki'

LANG['scoreboard.group_teams.name'] = 'Grupuj Zespoy'
LANG['scoreboard.group_teams.desc'] = '(DarkRP) Grupuj zespoy wedug kategorii prac'

LANG['scoreboard.colored_players.name'] = 'Koloryzowany Gradient'
LANG['scoreboard.colored_players.desc'] = 'Poka gradient kolorw na linii gracza'

LANG['scoreboard.blur.name'] = 'Rozmycie Motywu'
LANG['scoreboard.blur.desc'] = 'Wcz motyw rozmycia'

LANG['scoreboard.scale.name'] = 'Skala Wielkoci Ramki'
LANG['scoreboard.scale.desc'] = 'Skaluj wielko ramki tabeli wynikw'

onyx.lang:AddPhrases('polish', LANG)
--PATH addons/[ui] onyx_scoreboard/lua/onyx/modules/scoreboard/core/cl_init.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

28/02/2024

--]]

onyx.scoreboard.Buttons = onyx.scoreboard.Buttons or {}

local function openFrame()
    local ratio = 1.641
    local scale = onyx.scoreboard:GetOptionValue('scale') / 100
    local height = math.min(math.ceil((702 / 1080 * ScrH()) * scale), ScrH() * .9)
    local width = math.ceil(height * ratio)

    onyx.scoreboard.Frame = vgui.Create('onyx.Scoreboard.Frame')
    onyx.scoreboard.Frame:SetSize(width, height)
    onyx.scoreboard.Frame:Center()
    onyx.scoreboard.Frame:MakePopup()
    onyx.scoreboard.Frame:SetKeyboardInputEnabled(false)
    onyx.scoreboard.Frame:ShowCloseButton(false)

    hook.Run('onyx.scoreboard.OnOpened', onyx.scoreboard.Frame)

    return onyx.scoreboard.Frame
end

function onyx.scoreboard:RegisterButton(name, data)
    assert(isstring(name), string.format('bad argument #1 (expected string, got %s)', type(name)))
    assert(istable(data), string.format('bad argument #2 (expected table, got %s)', type(data)))

    data.name = name
    table.insert(self.Buttons, data)
end

function onyx.scoreboard.IsBlurActive()
    return onyx.scoreboard:GetOptionValue('blur')
end

do
    local TTT_Names = {
        ['GROUP_TERROR'] = {'terrorists', Color(0, 200, 0)},
        ['GROUP_SPEC'] = {'spectators', Color(200, 200, 0)},
        ['GROUP_NOTFOUND'] = {'sb_mia', Color(130, 190, 130)},
        ['GROUP_FOUND'] = {'sb_confirmed', Color(130, 170, 10)},
    }

    local TTT_RoleColors = {
        default = Color(121, 121, 121),
        traitor = Color(255, 96, 96),
        detective = Color(60, 112, 255)
    }

    function onyx.scoreboard.IsTTT()
        return (engine.ActiveGamemode() == 'terrortown')
    end

    function onyx.scoreboard.GetTeamTTT(ply)
        local group = ScoreGroup(ply)
        local color = color_white
        local name = ''

        if (group) then
            for globalKey, data in pairs(TTT_Names) do
                local index = _G[globalKey]
                if (index == group) then
                    local langID = data[1]
                    local groupColor = data[2]

                    name = LANG.GetTranslation(langID)
                    color = groupColor

                    break
                end
            end
        end

        return group, name, color
    end

    function onyx.scoreboard.GetRoleColorTTT(ply)
        if (ply:IsTraitor()) then
            return TTT_RoleColors.traitor
        elseif (ply:IsDetective()) then
            return TTT_RoleColors.detective
        end

        return TTT_RoleColors.default
    end
end

function onyx.scoreboard.ConvertTeamColor(color)
    local h, s, v = ColorToHSV(color)
    return onyx.ColorEditHSV(color, nil, s - .2, v + .2)
end

function onyx.scoreboard.OpenAdminSettings(tab)                                                                                                                                                                                                                                         -- 5409e8b9-5bf9-4f0d-8990-ecb0a7db9134
    local frame = vgui.Create('onyx.Frame')
    frame:SetSize(ScrW() * .6, ScrH() * .6)
    frame:Center()
    frame:MakePopup()
    frame:SetTitle('ONYX SCOREBOARD (ADMIN)')

    local p = onyx.ScaleTall(15)
    local content = frame:Add('Panel')
    content:Dock(FILL)
    content:DockPadding(p, p, p, p)

    local sidebar = frame:Add('onyx.Sidebar')
    sidebar:SetContainer(content)
    sidebar:SetWide(frame:GetWide() * .2)
    sidebar:Dock(LEFT)

    sidebar:AddTab({
        name = onyx.lang:Get('addon_settings_u'),
        desc = '',
        icon = 'https://i.imgur.com/ECLKU9s.png',
        class = 'onyx.Configuration',
        onSelected = function(panel)
            panel:LoadAddonSettings('scoreboard')
            panel:OpenCategories()
        end
    })

    sidebar:AddTab({
        name = onyx.lang:Get('scoreboard_ranks_u'),
        desc = '',
        icon = 'https://i.imgur.com/vaYzFPG.png',
        class = 'onyx.scoreboard.RankEditor'
    })

    sidebar:AddTab({
        name = onyx.lang:Get('scoreboard_columns_u'),
        desc = '',
        icon = 'https://i.imgur.com/fUaIb3B.png',
        class = 'onyx.scoreboard.ColumnEditor'
    })

    sidebar:AddTab({
        name = onyx.lang:Get('addon_return_u'),
        desc = '',
        icon = 'https://i.imgur.com/B9XOMVX.png',
        onClick = function()
            frame:Remove()

            local scoreboard = openFrame()
            scoreboard.closeDisabled = true
            scoreboard:ShowCloseButton(true)

            return false
        end
    })

    sidebar:ChooseTab(tab or 1)

    return frame
end

hook.Add('ScoreboardShow', 'onyx.scoreboard.Show', function()
    if (IsValid(onyx.scoreboard.Frame)) then
        return true
    end

    openFrame()

    return true
end)

hook.Add('ScoreboardHide', 'onyx.scoreboard.Hide', function()
    if (IsValid(onyx.scoreboard.Frame) and not onyx.scoreboard.Frame.closeDisabled) then
        onyx.scoreboard.Frame:Remove()
        onyx.scoreboard.Frame:SetMouseInputEnabled(false)
        hook.Run('onyx.scoreboard.OnClosed')
    end

    return true
end)

onyx.WaitForGamemode('onyx.scoreboard.BlockFAdmin', function()
    hook.Remove('ScoreboardShow', 'FAdmin_scoreboard')
    hook.Remove('ScoreboardHide', 'FAdmin_scoreboard')
end)
--PATH addons/[ui] onyx_scoreboard/lua/onyx/modules/scoreboard/core/integrations/sh_brick_gangs.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

19/03/2024

--]]

netchunk.Register('onyx.scoreboard:SyncBrickGangs')
--PATH addons/[ui] onyx_scoreboard/lua/onyx/modules/scoreboard/core/ranks/cl_ranks.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

04/03/2024

--]]

onyx.scoreboard.nameEffects = {}

function onyx.scoreboard:RegisterNameEffect(id, func)
    table.insert(onyx.scoreboard.nameEffects, {
        id = id,
        func = func,
        name = ('scoreboard_eff_' .. id)
    })
end

function onyx.scoreboard:FindNameEffect(id)
    for index, data in ipairs(self.nameEffects) do
        if (data.id == id) then
            return data, index
        end
    end
end

do
    local fontCommon = onyx.Font('Comfortaa SemiBold@16') -- the size got dynamically changed
    local fontGlow = onyx.Font('Comfortaa SemiBold@16', 'blursize:2') -- the size got dynamically changed

    local COLOR_SHADOW = Color(0, 0, 0, 100)
    local SHADOW_DISTANCE = 2

    local ColorAlpha = ColorAlpha
    local SimpleText = draw.SimpleText

    -- Common (colorized)
    onyx.scoreboard:RegisterNameEffect('default', function(text, x, y, color, ax, ay)
        SimpleText(text, fontCommon, x + SHADOW_DISTANCE, y + SHADOW_DISTANCE, COLOR_SHADOW, ax, ay)
        SimpleText(text, fontCommon, x, y, color, ax, ay)
    end)

    -- Glow (colorized)
    onyx.scoreboard:RegisterNameEffect('glow', function(text, x, y, color, ax, ay)
        SimpleText(text, fontCommon, x + SHADOW_DISTANCE, y + SHADOW_DISTANCE, COLOR_SHADOW, ax, ay)
        SimpleText(text, fontGlow, x, y, ColorAlpha(color, 80 + 80 * math.abs(math.sin(CurTime() * 2))), ax, ay)
        SimpleText(text, fontCommon, x, y, color, ax, ay)
    end)

    -- Rainbow
    onyx.scoreboard:RegisterNameEffect('rainbow', function(text, x, y, color, ax, ay)
        local lastX = x
        local counter = 0
        local speed = CurTime() * 50

        SimpleText(text, fontCommon, x + SHADOW_DISTANCE, y + SHADOW_DISTANCE, COLOR_SHADOW, ax, ay)

        for _, code in utf8.codes(text) do
            local offset = counter * 5
            local color = HSVToColor((speed + offset) % 360, 1, 1)

            counter = counter + 1
            lastX = lastX + select(1, SimpleText(utf8.char(code), fontCommon, lastX, y, color, ax, ay))
        end
    end)

    -- Wavy Dual
    onyx.scoreboard:RegisterNameEffect('wavy_dual', function(text, x, y, color, ax, ay)
        local lastX = x
        local counter = 0
        local speed = CurTime() * 5

        -- draw.SimpleText(text, fontCommon, x + SHADOW_DISTANCE, y + SHADOW_DISTANCE, COLOR_SHADOW, ax, ay)

        for _, code in utf8.codes(text) do
            local offset = math[counter % 2 == 0 and 'cos' or 'sin'](speed)
            local fraction = math.abs(offset)
            local color1 = color
            local h, s, v = ColorToHSV(color1)
            local color2 = onyx.ColorEditHSV(color1, (h + 90) % 360)
            local color = onyx.LerpColor(fraction, color1, color2)
            local char = utf8.char(code)

            counter = counter + 1

            SimpleText(char, fontCommon, lastX + SHADOW_DISTANCE, y + offset * .05 + SHADOW_DISTANCE, COLOR_SHADOW, ax, ay)
            lastX = lastX + select(1, SimpleText(char, fontCommon, lastX, y + offset * .05, color, ax, ay))
        end
    end)

    -- Gradient
    onyx.scoreboard:RegisterNameEffect('gradient_invert', function(text, x, y, color, ax, ay, realX, realY)
        local color1 = color
        local h, s, v = ColorToHSV(color1)
        local color2 = onyx.ColorEditHSV(color1, (h + 180) % 360)

        SimpleText(text, fontCommon, x + SHADOW_DISTANCE, y + SHADOW_DISTANCE, COLOR_SHADOW, ax, ay)
        local textW, textH = SimpleText(text, fontCommon, x, y, color, ax, ay)

        local realYStart = realY - textH * .5

        render.SetScissorRect(realX, realYStart + textH * .65, realX + textW, realYStart + textH, true)
            SimpleText(text, fontCommon, x, y, color2, ax, ay)
        render.SetScissorRect(0, 0, 0, 0, false)
    end)

    -- Scanning
    onyx.scoreboard:RegisterNameEffect('scanning_vertical', function(text, x, y, color, ax, ay, realX, realY)
        SimpleText(text, fontCommon, x + SHADOW_DISTANCE, y + SHADOW_DISTANCE, COLOR_SHADOW, ax, ay)
        SimpleText(text, fontGlow, x, y, ColorAlpha(color, 30), ax, ay)
        local textW, textH = SimpleText(text, fontCommon, x, y, color_black, ax, ay)

        local realYStart = realY - textH * .5
        local animYStart = realYStart + textH * ((CurTime() * .5) % 1.5)
        local scanLineHeight = textH
        local scanLineRadius = scanLineHeight * .15

        render.SetScissorRect(realX, animYStart, realX + textW, animYStart + scanLineRadius, true)
            SimpleText(text, fontCommon, x, y, color, ax, ay)
        render.SetScissorRect(0, 0, 0, 0, false)
    end)

    onyx.scoreboard:RegisterNameEffect('scanning_horizontal', function(text, x, y, color, ax, ay, realX, realY)
        SimpleText(text, fontCommon, x + SHADOW_DISTANCE, y + SHADOW_DISTANCE, COLOR_SHADOW, ax, ay)
        SimpleText(text, fontGlow, x, y, ColorAlpha(color, 30), ax, ay)
        local textW, textH = SimpleText(text, fontCommon, x, y, color_black, ax, ay)

        local realYStart = realY - textH * .5
        local animXStart = realX + textW * ((CurTime() * 1) % 1.5)
        local scanLineWidth = textW
        local scanLineRadius = scanLineWidth * .1

        render.SetScissorRect(animXStart, realYStart, animXStart + scanLineRadius, realYStart + textH, true)
            SimpleText(text, fontCommon, x, y, color, ax, ay)
        render.SetScissorRect(0, 0, 0, 0, false)
    end)
end

net.Receive('onyx.scoreboard:SyncRanks', function(length)
    local rawData = net.ReadData(length)
    local parsedData = pon.decode(rawData)

    onyx.scoreboard.ranks = parsedData
    onyx.scoreboard:Print('Synchronized ranks.')

    hook.Run('onyx.scoreboard.SyncedRanks')
end)
--PATH addons/[gas] gmodadminsuite-config-master/lua/openpermissions_config.lua:
return gluapack()()
--PATH lua/openpermissions/lang/english.lua:
return gluapack()()
--PATH addons/[ekonomia] pcasino/lua/perfectcasino/core/sh_core.lua:
-- The letters bodygroup and width
PerfectCasino.Core.Letter = {
	["a"] = {b = 0, w = 5},
	["b"] = {b = 1, w = 4},
	["c"] = {b = 2, w = 4.2},
	["d"] = {b = 3, w = 4.5},
	["e"] = {b = 4, w = 3.7},
	["f"] = {b = 5, w = 3.6},
	["g"] = {b = 6, w = 5},
	["h"] = {b = 7, w = 5},
	["i"] = {b = 8, w = 2},
	["j"] = {b = 9, w = 3.2},
	["k"] = {b = 10, w = 4.7},
	["l"] = {b = 11, w = 3.7},
	["m"] = {b = 12, w = 6},
	["n"] = {b = 13, w = 5},
	["o"] = {b = 14, w = 5},
	["p"] = {b = 15, w = 4},
	["q"] = {b = 16, w = 5},
	["r"] = {b = 17, w = 4.7},
	["s"] = {b = 18, w = 4},
	["t"] = {b = 19, w = 4.5},
	["u"] = {b = 20, w = 4.5},
	["v"] = {b = 21, w = 5.2},
	["w"] = {b = 22, w = 7.3},
	["x"] = {b = 23, w = 5},
	["y"] = {b = 24, w = 4.7},
	["z"] = {b = 25, w = 4.6},
	["0"] = {b = 26, w = 4.2},
	["1"] = {b = 27, w = 3},
	["2"] = {b = 28, w = 4},
	["3"] = {b = 29, w = 3.8},
	["4"] = {b = 30, w = 4.4},
	["5"] = {b = 31, w = 3.8},
	["6"] = {b = 32, w = 4.1},
	["7"] = {b = 33, w = 4.1},
	["8"] = {b = 34, w = 4.2},
	["9"] = {b = 35, w = 4.1},
	["-"] = {b = 36, w = 2.7},
	["!"] = {b = 37, w = 2},
	["."] = {b = 38, w = 2.3}
}

-- Who has "admin" perms
function PerfectCasino.Core.Access(user)
	if not IsValid(user) then return false end
	return PerfectCasino.Config.AccessGroups[user:GetUserGroup()] or PerfectCasino.Config.AccessGroups[user:SteamID64()] or PerfectCasino.Config.AccessGroups[user:SteamID()]
end

-- Chat messages
function PerfectCasino.Core.Msg(msg, ply)
	if SERVER then
		net.Start("pCasino:Msg")
			net.WriteString(msg)
		if not ply then
			net.Broadcast()
		else
			net.Send(ply)
		end
	else
		chat.AddText(PerfectCasino.Config.PrefixColor, PerfectCasino.Config.Prefix..": ", Color( 255, 255, 255 ), msg)
	end
end


if SERVER then return end

net.Receive("pCasino:Msg", function()
	PerfectCasino.Core.Msg(net.ReadString())
end)


--PATH addons/[ekonomia] pcasino/lua/perfectcasino/core/sh_card.lua:
-- Build a deck
local allCards = {}
-- hearts, diamonds, spades, clubs
for _, s in pairs({"h", "d", "s", "c"}) do
	for _, v in pairs{"a", 2, 3, 4, 5, 6, 7, 8, 9, "t", "j", "k", "q"} do -- We use 't' instead of '10' so that we can just check the 2nd value for what the card is worth
		table.insert(allCards, s..v)
	end
end

function PerfectCasino.Cards:GetRandom()
	local card = table.Random(allCards)

	--return "sq"
	return card
end

function PerfectCasino.Cards:GetValue(card, sum)
	local v = card[2]
	if not v then return false end

	if (v == "t") or (v == "j") or (v == "k") or (v == "q") then
		return 10
	elseif v == "a" then
		if sum then -- Check if we're basing it off a current evaluation
			if sum <= 10 then -- If the current sum is less than 11, we can return 11 without going bust
				return 11
			end

			return 1 -- Return 1 as a fallback
		end

		return 11
	else
		return tonumber(v)
	end
end

-- The card var must be a table of cards in the format obtained with PerfectCasino.Cards:GetRandom()
function PerfectCasino.Cards:GetHandValue(cards)
	local totalValue = 0
	local aces = 0

	for k, v in pairs(cards) do
		-- We calculate the aces after we've summmed up the total
		if v[2] == "a" then
			aces = aces + 1
			continue
		end
		totalValue = totalValue + PerfectCasino.Cards:GetValue(v)
	end

	if aces > 0 then
		for i=1, aces do
			totalValue = totalValue + PerfectCasino.Cards:GetValue("ha", totalValue) -- It doesn't matter the card we give it, as long as it's an ace
		end
	end

	return totalValue
end

local skins = {["h"] = 0, ["d"] = 1, ["c"] = 2, ["s"] = 3}
local bodygroups = {["a"] = 0, ["2"] = 1, ["3"] = 2, ["4"] = 3, ["5"] = 4, ["6"] = 5, ["7"] = 6, ["8"] = 7, ["9"] = 8, ["t"] = 9, ["j"] = 10, ["q"] = 11, ["k"] = 12}
function PerfectCasino.Cards:GetFaceData(card)
	if not card then return end

	return skins[card[1]] or 0, bodygroups[card[2]] or 0
end
--PATH addons/[ekonomia] pcasino/lua/perfectcasino/core/cl_core.lua:
if not file.Exists("pcasino_data", "DATA") then
	file.CreateDir("pcasino_data")
	file.CreateDir("pcasino_data/ui")
end	

PerfectCasino.Icons = {}
PerfectCasino.IconsList = {} -- This is a list of all the icons. It is used in some UI elements to allow players to cycle through them all.
function PerfectCasino.Core.AddIcon(id, name, url, internal)
	PerfectCasino.Icons[id] = {name = name, url = url, internal = internal, mat = Material(id..".png")}

	table.insert(PerfectCasino.IconsList, id)
end

PerfectCasino.Core.AddIcon("anything", "Anything", "pcasino/anything.png", true)
PerfectCasino.Core.AddIcon("bell", "Bell", "pcasino/bell.png", true)
PerfectCasino.Core.AddIcon("berry", "Strawberry", "pcasino/berry.png", true)
PerfectCasino.Core.AddIcon("cherry", "Cherry", "pcasino/cherry.png", true)
PerfectCasino.Core.AddIcon("clover", "Clover", "pcasino/clover.png", true)
PerfectCasino.Core.AddIcon("diamond", "Diamond", "pcasino/diamond.png", true)
PerfectCasino.Core.AddIcon("dollar", "Dollar", "pcasino/dollar.png", true)
PerfectCasino.Core.AddIcon("melon", "Watermelon", "pcasino/melon.png", true)
PerfectCasino.Core.AddIcon("seven", "Seven", "pcasino/seven.png", true)
PerfectCasino.Core.AddIcon("gold", "Gold Bars", "pcasino/gold.png", true)
PerfectCasino.Core.AddIcon("coins", "Coins", "pcasino/coins.png", true)
PerfectCasino.Core.AddIcon("emerald", "Emerald", "pcasino/emerald.png", true)
PerfectCasino.Core.AddIcon("bag", "Money Bag", "pcasino/bag.png", true)
PerfectCasino.Core.AddIcon("bar", "Gold Bar", "pcasino/bar.png", true)
PerfectCasino.Core.AddIcon("coin", "Coin", "pcasino/coin.png", true)
PerfectCasino.Core.AddIcon("vault", "Vault", "pcasino/vault.png", true)
PerfectCasino.Core.AddIcon("chest", "Treasure Chest", "pcasino/chest.png", true)
PerfectCasino.Core.AddIcon("mystery_1", "Mystery Wheel 1", "pcasino/mystery_1.png", true)
PerfectCasino.Core.AddIcon("mystery_2", "Mystery Wheel 2", "pcasino/mystery_2.png", true)
PerfectCasino.Core.AddIcon("mystery_3", "Mystery Wheel 3", "pcasino/mystery_3.png", true)
PerfectCasino.Core.AddIcon("dolla", "Dolla", "pcasino/dolla.png", true)

function PerfectCasino.Core.LoadIconsFromURL()
	for k, v in pairs(PerfectCasino.Icons) do
		if (v.internal) then continue end

		print("[pCasino]", "Checking icon", k)
		if file.Exists( "pcasino_data/ui/"..k..".png", "DATA" ) then print("	", "Found") continue end

		print("	", "Attempting to download from", v.url)
		http.Fetch(v.url, function( body, len, headers, code )
			file.Write("pcasino_data/ui/"..k..".png", body)
			v.mat = Material("data/pcasino_data/ui/"..k..".png")

			print("[pCasino]", k, "Download is complete. The image can be found at", "pcasino_data/ui/"..k..".png")
		end)
	end
end

function PerfectCasino.Core.LoadIcons()
	for k, v in pairs(PerfectCasino.Icons) do
		if (!v.internal) then continue end;

		v.mat = Material(v.url)
	end
end

hook.Add("HUDPaint", "pVault:LoadIcons", function()
	hook.Remove("HUDPaint", "pVault:LoadIcons")

	PerfectCasino.Core.LoadIconsFromURL()
	PerfectCasino.Core.LoadIcons()
end)

-- Seat text
local draw_simpletext = draw.SimpleText
hook.Add("HUDPaint", "pVault:ChairLeave", function()
	local myChair = LocalPlayer():GetVehicle()
	if (not IsValid(myChair)) or (not IsValid(myChair:GetParent())) then return end
	if not (myChair:GetParent():GetClass() == "pcasino_chair") then return end

	draw_simpletext(PerfectCasino.Translation.UI.LeaveSeat, "pCasino.Entity.Bid", ScrW()*0.5, ScrH(), color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM)
end)

-- Free spin received
net.Receive("pCasino:FreeSpin", function()
	PerfectCasino.Spins = net.ReadUInt(6)
end)



-- Improved toolgun
concommand.Add("pcasino_clone", function()
	if not PerfectCasino.Core.Access(LocalPlayer()) then return end
	local entity = LocalPlayer():GetEyeTrace().Entity

	if not string.match(entity:GetClass(), "pcasino") then return end
	if not entity.data then return end

	PerfectCasino.UI.CurrentSettings.Entity = entity:GetClass()
	PerfectCasino.UI.CurrentSettings.Settings = table.Copy(entity.data)

	if IsValid(PerfectCasino.UI.ConfigMenu) then
		PerfectCasino.UI.ConfigMenu:Close()
	end

	PerfectCasino.UI.Config()

	local comboBox = PerfectCasino.UI.ConfigMenu.entitySelectBox
	local key
	for k, v in pairs(comboBox.Choices) do
		if not (v == PerfectCasino.Translation.Entities[entity:GetClass()]) then continue end

		key = k
	end

	if not key then return end
	comboBox:ChooseOptionID(key)

	PerfectCasino.UI.ConfigMenu:Hide()
end)

-- Used for debugging
concommand.Add("pcasino_print_data", function()
	if not PerfectCasino.Core.Access(LocalPlayer()) then return end
	local entity = LocalPlayer():GetEyeTrace().Entity

	if not string.match(entity:GetClass(), "pcasino") then return end
	if not entity.data then return end

	PrintTable(entity.data)
end)
--PATH lua/autorun/pirate_npc.lua:
return gluapack()()
--PATH lua/autorun/ppfx_cache.lua:
game.AddParticles( "particles/pfx_redux.pcf" )
-- 1
PrecacheParticleSystem("[1]campfire1")
PrecacheParticleSystem("[1]cig_smoke*")
PrecacheParticleSystem("[1]candle_flame")
PrecacheParticleSystem("[1]ground_fire_1")
PrecacheParticleSystem("[1]ground_fire_1*")
PrecacheParticleSystem("[1]smoke_lifting_01")
PrecacheParticleSystem("[1]_large_campfire")
PrecacheParticleSystem("[1]fireplace_default")
PrecacheParticleSystem("[1]_smoke_colorful_1")
PrecacheParticleSystem("[1]groundflame1")
PrecacheParticleSystem("[1]molotov_ground")
PrecacheParticleSystem("[1]embers")
PrecacheParticleSystem("[1]embers_~")
PrecacheParticleSystem("[1]flametrail")
PrecacheParticleSystem("[1]groundflame")
PrecacheParticleSystem("[1]flamethrower_basic")
PrecacheParticleSystem("[1]big_smoke")
PrecacheParticleSystem("[1]_large_campfire_red")
PrecacheParticleSystem("[1]_campfire_red")
PrecacheParticleSystem("[1]_large_campfire_yellow")
PrecacheParticleSystem("[1]_campfire_yellow")
PrecacheParticleSystem("[1]_large_campfire_purple")
PrecacheParticleSystem("[1]_campfire_purple")
PrecacheParticleSystem("[1]_large_campfire_green")
PrecacheParticleSystem("[1]_campfire_green")
PrecacheParticleSystem("[1]_large_campfire_pink")
PrecacheParticleSystem("[1]_campfire_pink")
PrecacheParticleSystem("[1]_large_campfire_blue")
PrecacheParticleSystem("[1]_campfire_blue")
PrecacheParticleSystem("[1]g_leak_flame")
-- 2
PrecacheParticleSystem("[2]sparkle1")
PrecacheParticleSystem("[2]sparkle2")
PrecacheParticleSystem("[2]gushing_blood_alien")
PrecacheParticleSystem("[2]gushing_blood_alien*")
PrecacheParticleSystem("[2]gushing_blood")
PrecacheParticleSystem("[2]gushing_blood*")
PrecacheParticleSystem("[2]acid_ground")
PrecacheParticleSystem("[2]swirl_1")
PrecacheParticleSystem("[2]swirl_rnd")
PrecacheParticleSystem("[2]gman_lines")
PrecacheParticleSystem("[2]blood_leak")
PrecacheParticleSystem("[2]blood_leak_alien")
-- 3
PrecacheParticleSystem("[3]sakura_env")
PrecacheParticleSystem("[3]leaves_env")
-- 4
PrecacheParticleSystem("[4]jet_r")
PrecacheParticleSystem("[4]jet_r*")
PrecacheParticleSystem("[4]jet_r_s")
PrecacheParticleSystem("[4]jet_r_s*")
PrecacheParticleSystem("[4]jet_g_s")
PrecacheParticleSystem("[4]jet_g_s*")
PrecacheParticleSystem("[4]jet_g")
PrecacheParticleSystem("[4]jet_g*")
PrecacheParticleSystem("[4]jet_b_s")
PrecacheParticleSystem("[4]jet_b_s*")
PrecacheParticleSystem("[4]jet_b")
PrecacheParticleSystem("[4]jet_b*")
PrecacheParticleSystem("[4]jet_f_s")
PrecacheParticleSystem("[4]jet_f_s*")
PrecacheParticleSystem("[4]jet_f")
PrecacheParticleSystem("[4]jet_f*")
PrecacheParticleSystem("[4]jet_v_s")
PrecacheParticleSystem("[4]jet_v_s*")
PrecacheParticleSystem("[4]jet_v")
PrecacheParticleSystem("[4]jet_v*")
PrecacheParticleSystem("[4]energy_rod_r")
PrecacheParticleSystem("[4]energy_rod_g")
PrecacheParticleSystem("[4]energy_rod_b")
PrecacheParticleSystem("[4]energy_rod_y")
PrecacheParticleSystem("[4]arcs_electric_1")
PrecacheParticleSystem("[4]arcs_electric_1_small")
PrecacheParticleSystem("[4]bfg_*proj")
PrecacheParticleSystem("[4]electric_beam")
PrecacheParticleSystem("[4]matrix_core")
PrecacheParticleSystem("[4]binary_sphere")
PrecacheParticleSystem("[4]_car_nitro")
-- 5
PrecacheParticleSystem("[5]black_hole_micro_b")
PrecacheParticleSystem("[5]black_hole_mmicro_b")
PrecacheParticleSystem("[5]black_hole_b")
PrecacheParticleSystem("[5]black_hole_micro")
PrecacheParticleSystem("[5]black_hole_mmicro")
PrecacheParticleSystem("[5]black_hole")
PrecacheParticleSystem("[5]starfield1")
PrecacheParticleSystem("[5]starfield_2")
PrecacheParticleSystem("[5]simple_galaxy")
-- 6
PrecacheParticleSystem("[6]gunfire_generic")
PrecacheParticleSystem("[6]bullet_tracer_generic")
PrecacheParticleSystem("[6]gunfire_ar2")
PrecacheParticleSystem("[6]bullet_tracer_ar2")
-- 7
PrecacheParticleSystem("[7]dusty_wind1")
PrecacheParticleSystem("[7]rain")
PrecacheParticleSystem("[7]snow")
PrecacheParticleSystem("[7]areal_fog_s")
PrecacheParticleSystem("[7]area_of_fog")
PrecacheParticleSystem("[7]blizzard_mod")
-- 8
PrecacheParticleSystem("[8]magic_1")
PrecacheParticleSystem("[8]red_vortex")
PrecacheParticleSystem("[8]magic_flame")
PrecacheParticleSystem("[8]magic_portal*")
PrecacheParticleSystem("[8]magic_portal")
PrecacheParticleSystem("[8]core_1")
PrecacheParticleSystem("[8]ball_core")
PrecacheParticleSystem("[8]orb_1")
PrecacheParticleSystem("[8]frostbeam")
-- 9
PrecacheParticleSystem("[9]colorful_trail_1")
-- A
PrecacheParticleSystem("[A]waterleak_1")

--PATH lua/autorun/prone_init.lua:
-- Copyright 2020, George "Stalker" Petrou. Enjoy!

--[[	DOCUMENTATION
prone.Version
	- Version of Prone Mod in YearMonthDay form.

COMMANDS:
	prone
		- Client
		- Enters or exits prone.
	prone_config
		- Client
		- Opens a little config menu for your prone keys.

HOOKS:
	prone.Initialized
		- Shared
		- Called after the Prone Mod has finished loading.
	prone.ShouldChangeCalcView
		- Client
		- Should the Prone Mod handle the transition of the player's view down/up from prone.
		- Arg One:	Local player.
		- Return:	Boolean. False to disable, anything else to enable.
	prone.ShouldChangeCalcViewModelView
		- Client
		- Same as prone.ShouldChangeCalcView but for their view model.

	Note:	These hooks are called on the server and client entering prone
			They are also predicted:
	
	prone.OnPlayerEntered
		- Called when a player is getting down to go prone.
		- Arg One:	Player entering prone.
		- Arg Two:	The length of their get down animation.
	prone.OnPlayerExitted
		- Called when a player just completely exitted prone.
		- Arg One:	The player that exitted prone.
	prone.CanEnter
		- Called to see if a player can enter prone.
		- Arg One:	The player that wants to go prone.
		- Return:	A boolean determining if they can enter prone or not.
	prone.CanExit
		- Called to see if a player can exit prone.
		- Arg One:	The player that wants to exit prone.
		- Return:	A boolean determining if they can exit prone or not.
		
FUNCTIONS:
	Note: None of these functions exist till after the initialize hook is called.
	
	PLAYER:IsProne()
		- Shared
		- Returns true if the player is prone.
	PLAYER:GetProneAnimationState()
		- Shared
		- Returns one of the PRONE_ enums mentionned below.
	prone.Handle(Player)
		- Shared
		- If the player is prone this will make them end, otherwise it will make them enter prone.
		- For prediction try to call this shared if you can.
	prone.Enter(Player)
		- Shared
		- Will make the player go prone, doesn't check to see if they should or if they are already in prone.
		- You should probably check with ply:IsProne() and prone.CanEnter(Player) before using this function.
		- For prediction try to call this shared if you can.
	prone.End(Player)
		- Shared
		- Will make the given player exit prone, doesn't check to see if they should or if they are already out of prone.
		- You should probably check with ply:IsProne() and prone.CanExit(Player) before using this function.
		- For prediction try to call this shared if you can.
	prone.Exit(Player)
		- Shared
		- Will make the player immediately exit prone, skipping the get up animation. Doesn't check to see if a player is already prone.
	prone.Request()
		- Client
		- Will ask the server to exit prone if they are prone or to enter prone if they aren't.
	RunConsoleCommand("prone_config")
		- Client
		- Will open up the in-game prone configuration menu.

	Note: These functions below MUST be called in or after the prone.Initialzed hook has been called.
	prone.AddNewHoldTypeAnimation(holdtype, movingSequenceName, idleSequenceName)
		- Shared
		- Registers a new hold type animation. Requires a sequence name for the moving animation and idle animation for that holdtype.
		- Can be used to override pre-existing holdtypes. Must be called shared.
	prone.GetIdleAnimation(holdtype)
		- Shared
		- Returns the name of the sequence corresponding the idle stance of the given holdtype.
	prone.GetMovingAnimation(holdtype)
		- Shared
		- Returns the name of the sequence corresponding the moving stance of the given holdtype.

ENUMERATIONS:
	PRONE_GETTINGDOWN	= 0
		-- Prone state. Set when the player is getting down into prone.
	PRONE_INPRONE		= 1
		-- Prone state. Set when the player is down in prone.
	PRONE_GETTINGUP		= 2
		-- Prone state. Set when the player is getting up.
	PRONE_NOTINPRONE	= 3
		-- Prone state. Set when a player is not prone.
	PRONE_IMPULSE		= 217
		-- Sent to server from client using CUserCmd:SetImpulse() to signify the user wanting to go prone.
	PRONE_CUSTOM_ANIM_EVENT_NUM		= 69420
		-- Passed as a data arg with Player:DoCustomAnimEvent() to be used in the GM:DoAnimationEvent hook.

CONVARS:
	prone_movespeed
		-- Server (replicated and archived)
		-- Number, speed of moving while prone.
	prone_bindkey_enabled
		-- Client (archived)
		-- Boolean (1 or 0), should a bind key be pressed to enter prone, or just the "prone" command.
	prone_bindkey_key
		-- Client (archived)
		-- Number, representing a KEY enum, for what the bind key should be.
	prone_bindkey_doubletap
		-- Client (archived)
		-- Boolean, should we have to double press the bind key to go prone.
	prone_jumptogetup
		-- Client (archived)
		-- Boolean, should the jump key toggle prone.
	prone_jumptogetup_doubletap
		-- Client (archived)
		-- Boolean, if prone_jumptogetup is enabled, should we have to double tap it.
	prone_disabletransitions
		-- Client (archived)
		-- Boolean, should we disable view transitions when entering and exitting prone.
]]

----------------------------------------------------------------
-- Initialization
----------------------------------------------------------------
prone = prone or {}
prone.Config = prone.Config or {}
prone.Animations = prone.Animations or {}

-- YearMonthDay
prone.Version = 20200711

-- States
PRONE_GETTINGDOWN	= 0
PRONE_INPRONE		= 1
PRONE_GETTINGUP		= 2
PRONE_NOTINPRONE	= 3

-- The impulse number to be used for toggling prone.
-- If anybody steals my number there will be hell to pay.
PRONE_IMPULSE = 127

-- This number is passed as the "data" arg to ply:DoCustomAnimEvent().
-- Again, steal this number and there will be hell to pay.
PRONE_CUSTOM_ANIM_EVENT_NUM = 69420

if SERVER then
	-- https://steamcommunity.com/sharedfiles/filedetails/?id=775573383
	resource.AddWorkshop("775573383")
end

hook.Add("Initialize", "prone.Initialize", function()
	-- Send files
	if SERVER then
		AddCSLuaFile("prone/class_prone_statedata.lua")
		AddCSLuaFile("prone/config.lua")
		AddCSLuaFile("prone/sh_prone.lua")
		AddCSLuaFile("prone/sh_thirdparty_compat.lua")
		AddCSLuaFile("prone/cl_prone.lua")
	end

	-- Load files (in order)
	include("prone/class_prone_statedata.lua")
	include("prone/config.lua")
	include("prone/sh_prone.lua")
	include("prone/sh_thirdparty_compat.lua")
	if SERVER then
		include("prone/sv_prone.lua")
	else
		include("prone/cl_prone.lua")
	end

	print("Initialized The Prone Mod, by Stalker and Stiffy360 (wOS version)")
	hook.Call("prone.Initialized")
end)


----------------------------------------------------------------
-- Pre-Library
---------------
-- Collection of small functions used throughout the addon.
----------------------------------------------------------------

---------------------
-- prone.WritePlayer
---------------------
-- Desc:		Writes a player entity via the net library.
-- Arg One:		Player, to write.
function prone.WritePlayer(ply)
	if IsValid(ply) then
		net.WriteUInt(ply:EntIndex(), 7)
	else
		net.WriteUInt(0, 7)
	end
end

--------------------
-- prone.ReadPlayer
--------------------
-- Desc:		Reads a player entity via the net library.
-- Arg One:		Player, to read.
function prone.ReadPlayer()
	local i = net.ReadUInt(7)
	if not i then
		return
	end
	return Entity(i)
end

-- Sandbox C-Menu
if CLIENT then
	hook.Add("PopulateToolMenu", "prone.SandboxOptionsMenu", function()
		spawnmenu.AddToolMenuOption("Utilities", "User", "prone_options", "Prone Options", "", "", function(panel)
			panel:SetName("Prone Mod")
			panel:AddControl("Header", {
				Text = "",
				Description = "Configuration menu for the Prone Mod."
			})

			panel:AddControl("Checkbox", {
				Label = "Enable the bind key",
				Command = "prone_bindkey_enabled"
			})

			panel:AddControl("Checkbox", {
				Label = "Double-tap the bind key",
				Command = "prone_bindkey_doubletap"
			})

			panel:AddControl("Checkbox", {
				Label = "Can press jump to get up",
				Command = "prone_jumptogetup"
			})

			panel:AddControl("Checkbox", {
				Label = "Double-tap jump to get up",
				Command = "prone_jumptogetup_doubletap"
			})

			panel:AddControl("Numpad", {
				Label = "Set the Bind-Key",
				Command = "prone_bindkey_key"
			})
		end)
	end)
end
--PATH lua/reality_development/client/cl_fonts.lua:
surface.CreateFont("RD_FONTS_CORE_OVERHEAD", {
    font = "Good Times Rg",
    extended = false,
    size = 40,
    weight = 500,
    blursize = 0,
    scanlines = 0,
    antialias = true
})
surface.CreateFont("RD_FONTS_CORE_OVERHEAD_SMALL", {
    font = "Good Times Rg",
    extended = false,
    size = 20,
    weight = 500,
    blursize = 0,
    scanlines = 0,
    antialias = true
})

surface.CreateFont( "RD_FONTS_CORE_LABEL_LOWER", {
    font = "Montserrat",
    size = ScrW() * 0.012,
    weight = 0,
    blursize = 0,
    scanlines = 0,
    antialias = true,
    extended = true,
} )

surface.CreateFont("RD_FONTS_CORE_PROPERTY_TABS", {
    font = "Montserrat",
    size = ScrW() * 0.01,
    weight = 0,
    blursize = 0,
    scanlines = 0,
    antialias = true,
    extended = true,
})
--PATH lua/reality_development/client/vgui/cl_collapsiblecategory.lua:
return gluapack()()
--PATH lua/reality_development/functions/sh_functions.lua:
return gluapack()()
--PATH lua/reality_development/functions/sh_products.lua:
return gluapack()()
--PATH lua/reality_development/functions/net/sh_net.lua:
hook.Add("Initialize", "RDV.LIBRARY.NetPlayer", function()
    if net.ReadPlayer or net.WritePlayer then
        return
    end

    function net.ReadPlayer()
        local VALID = net.ReadBool()

        if VALID then
            return Entity(net.ReadUInt(8))
        else
            return NULL
        end
    end

    function net.WritePlayer(ply)
        if !ply then return end

        if IsValid(ply) and ply:IsPlayer() then
            net.WriteBool(true)
            net.WriteUInt(ply:EntIndex(), 8)
        else
            net.WriteBool(false)
        end
    end
end)
--PATH lua/reality_development/functions/notifications/sh_chat_notifications.lua:
return gluapack()()
--PATH lua/reality_development/libs/characters/sh_register.lua:
local CHARACTERS = {}

function RDV.LIBRARY.RegisterCharacter(NAME)
    CHARACTERS[NAME] = {}

    return CHARACTERS[NAME]
end

local HOOKS = {}

function RDV.LIBRARY.AddCharacterHook(hookname, callback)
    if not hookname then return end

    HOOKS = HOOKS or {}

    local position = table.insert(HOOKS, hookname)

    hook.Add(hookname, hookname..".RDV."..position, callback)
end

--[[
    Currency Functions.
--]]

function RDV.LIBRARY.GetCharacterID(player, game_mode)
    if !game_mode then
        game_mode = RDV.LIBRARY.GetConfigOption("SAL_csChoose")
    end

    local TAB = CHARACTERS[game_mode]

    if not TAB or not isfunction(TAB.GetCharacterID) then
        return false
    end
        
    return TAB:GetCharacterID(player)
end

function RDV.LIBRARY.OnCharacterLoaded(game_mode, callback)
    if !game_mode then
        game_mode = RDV.LIBRARY.GetConfigOption("SAL_csChoose")
    end

    local TAB = CHARACTERS[game_mode]

    if not TAB or not isfunction(TAB.OnCharacterLoaded) then
        return false
    end

    TAB:OnCharacterLoaded(function(player, slot)
        callback(player, tonumber(slot))
    end)
end


function RDV.LIBRARY.OnCharacterDeleted(game_mode, callback)
    if !game_mode then
        game_mode = RDV.LIBRARY.GetConfigOption("SAL_csChoose")
    end

    local TAB = CHARACTERS[game_mode]

    if not TAB or not isfunction(TAB.OnCharacterDeleted) then
        return false
    end

    TAB:OnCharacterDeleted(function(player, slot)
        callback(player, tonumber(slot))
    end)
end

function RDV.LIBRARY.OnCharacterChanged(game_mode, callback)
    if !game_mode then
        game_mode = RDV.LIBRARY.GetConfigOption("SAL_csChoose")
    end

    local TAB = CHARACTERS[game_mode]

    if not TAB or not isfunction(TAB.OnCharacterChanged) then
        return false
    end

    TAB:OnCharacterChanged(function(player, new, old)
        callback(player, tonumber(new), tonumber(old))
    end)
end

function RDV.LIBRARY.GetCharacterEnabled()
    return RDV.LIBRARY.GetConfigOption("SAL_csEnabled")
end

hook.Add("RDV_LIB_Loaded", "RDV_LIB_CHARACTER", function()
    local N = {}

    for k, v in pairs(CHARACTERS) do
        table.insert(N, k)
    end

    RDV.LIBRARY.AddConfigOption("SAL_csEnabled", {
        TYPE = RDV.LIBRARY.TYPE.BL,
        DEFAULT = false,
		CATEGORY = "Library", 
        DESCRIPTION = "Character System", 
        SECTION = "Character System",
    })

    RDV.LIBRARY.AddConfigOption("SAL_csChoose", {
        TYPE = RDV.LIBRARY.TYPE.SE,
        LIST = N, 
		CATEGORY = "Library", 
        DESCRIPTION = "Character System", 
        SECTION = "Character System",
        DEFAULT = "helix",
    })
end )
--PATH lua/reality_development/libs/config/cl_config.lua:
return gluapack()()
--PATH lua/reality_development/libs/config/sh_config.lua:
return gluapack()()
--PATH lua/reality_development/libs/currencies/list/sh_basewars.lua:
local OBJ = RDV.LIBRARY.RegisterCurrency("basewars")

function OBJ:AddMoney(p, amount)
    p:GiveMoney(amount)
end

function OBJ:CanAfford(p, amount)
    return p:GetMoney() >= amount
end

function OBJ:FormatMoney(money)
    return string.Comma(money)
end
--PATH lua/reality_development/libs/currencies/list/sh_nutscript.lua:
local OBJ = RDV.LIBRARY.RegisterCurrency("nutscript")

function OBJ:AddMoney(p, amount)
    if amount > 0 then
        p:getChar():giveMoney(amount)
    else
        p:getChar():takeMoney(amount)
    end
end

function OBJ:CanAfford(p, amount)
    if not p:getChar():hasMoney(amount) then
        return false
    else
        return true
    end
end

function OBJ:FormatMoney(amount)
    return nut.currency.get(amount)
end
--PATH addons/[admin] sam-160/lua/sam/sh_permissions.lua:
return gluapack()()
--PATH addons/[admin] sam-160/lua/sam/sh_permissions.lua:
if SAM_LOADED then return end

local permissions = {}

local give_permission
if SERVER then
	local permissions_to_add = {}

	give_permission = function(name, permission)
		if sam.ranks.ranks_loaded() then
			local rank = sam.ranks.get_rank(name)
			if rank and rank.data.permissions[permission] == nil then
				sam.ranks.give_permission(name, permission)
			end
		else
			table.insert(permissions_to_add, {name, permission})
		end
	end

	hook.Add("SAM.LoadedRanks", "SAM.Command.GivePermissions", function()
		for k, v in ipairs(permissions_to_add) do
			give_permission(v[1], v[2])
		end
	end)
end

local get_next_Other = function()
	for i, v in ipairs(permissions) do
		if v.category == "Other" then
			return i
		end
	end
	return #permissions + 1
end

function sam.permissions.add(permission, category, rank)
	if not sam.isstring(category) then
		category = "Other"
	end

	local permission_data = {
		name = permission,
		category = category,
		rank = rank,
		value = value
	}

	local index = sam.permissions.get_index(permission)
	if not index then
		if category ~= "Other" then
			table.insert(permissions, get_next_Other(), permission_data)
		else
			table.insert(permissions, permission_data)
		end
		hook.Call("SAM.AddedPermission", nil, permission, category, rank, value)
	else
		permissions[index] = permission_data
		hook.Call("SAM.PermissionModified", nil, permission, category, rank, value)
	end

	if SERVER and rank then
		give_permission(rank, permission)
	end
end

function sam.permissions.get_index(permission)
	for i, v in ipairs(permissions) do
		if v.name == permission then
			return i
		end
	end
end

function sam.permissions.remove(permission)
	local index = sam.permissions.get_index(permission)
	if index then
		table.remove(permissions, index)
		hook.Call("SAM.RemovedPermission", nil, permission)
	end
end

function sam.permissions.exists(permission)
	return sam.permissions.get_index(permission) and true or false
end

function sam.permissions.get()
	return permissions
end
--PATH addons/[admin] sam-160/lua/sam/player/sh_nw_vars.lua:
if SAM_LOADED then return end

local netstream = sam.netstream

local nwvars = {}

if SERVER then
	function sam.player.set_nwvar(ply, key, value, force)
		local id = ply:EntIndex()
		if force or nwvars[id][key] ~= value then
			nwvars[id][key] = value
			netstream.Start(nil, "SetNWVar", id, key, value)
		end
	end
end

if CLIENT then
	function sam.player.set_nwvar(ply, key, value)
		local id_vars = nwvars[ply:EntIndex()]
		id_vars[key] = value
	end

	netstream.Hook("SetNWVar", function(id, key, value)
		local id_vars = nwvars[id]
		if id_vars == nil then
			nwvars[id] = {
				[key] = value
			}
		else
			id_vars[key] = value
		end
	end)

	netstream.Hook("SendNWVars", function(vars)
		nwvars = vars
	end)

	netstream.Hook("RemoveNWVar", function(id)
		nwvars[id] = nil
	end)
end

function sam.player.get_nwvar(ply, key, default)
	local value = nwvars[ply:EntIndex()]
	if value then
		value = value[key]
		if value ~= nil then
			return value
		end
	end
	return default
end

if SERVER then
	hook.Add("OnEntityCreated", "SAM.NWVars", function(ent)
		if ent:IsPlayer() and ent:IsValid() then
			nwvars[ent:EntIndex()] = {}
		end
	end)

	hook.Add("SAM.PlayerNetReady", "SAM.SendNWVars", function(ply)
		netstream.Start(ply, "SendNWVars", nwvars)
	end)

	hook.Add("EntityRemoved", "SAM.RemoveNWVars", function(ent)
		if ent:IsPlayer() then
			local id = ent:EntIndex()
			nwvars[id] = nil
			netstream.Start(nil, "RemoveNWVar", id)
		end
	end)
end

--PATH addons/[admin] sam-160/lua/sam/command/arguments/map.lua:
return gluapack()()
--PATH addons/[admin] sam-160/lua/sam/command/arguments/player.lua:
return gluapack()()
--PATH addons/[lib] sui/lua/includes/modules/sui.lua:
return gluapack()()
--PATH addons/[lib] sui/lua/sui/libs/tdlib/cl_tdlib.lua:
--[[
	Three's Derma Lib
	Made by Threebow

	You are free to use this anywhere you like, or sell any addons
	made using this, as long as I am properly accredited.
]]

local pairs = pairs
local ipairs = ipairs
local Color = Color
local render = render
local SysTime = SysTime
local Lerp, RealFrameTime = Lerp, RealFrameTime
local RoundedBox, RoundedBoxEx, NoTexture = draw.RoundedBox, draw.RoundedBoxEx, draw.NoTexture
local SetDrawColor, DrawRect = surface.SetDrawColor, surface.DrawRect
local DrawPoly = surface.DrawPoly
local sui = sui

local Panel = FindMetaTable("Panel")

--[[
	Constants
]]
local BLUR = CreateMaterial("SUI.TDLib.Blur", "gmodscreenspace", {
	["$basetexture"] = "_rt_fullframefb",
	["$blur"] = (1 / 3) * 7,
})

local COL_WHITE_1 = Color(255, 255, 255)
local COL_WHITE_2 = Color(255, 255, 255, 30)

--[[
	credits to http://slabode.exofire.net/circle_draw.shtml
]]
local calculate_circle do
	local cos = math.cos
	local sin = math.sin
	local round = math.Round
	local sqrt = math.sqrt
	local pi = math.pi
	calculate_circle = function(circle, x_centre, y_centre, r)
		if circle.x == x_centre and circle.y == y_centre and circle.r == r then return end

		local step = (2 * pi) / round(6 * sqrt(r))

		local i = 0
		for theta = 2 * pi, 0, -step do
			local x = x_centre + r * cos(theta)
			local y = y_centre - r * sin(theta)
			i = i + 1
			circle[i] = {
				x = x,
				y = y
			}
		end

		for i = i + 1, #circle do
			circle[i] = nil
		end

		circle.x = x_centre
		circle.y = y_centre
		circle.r = r
	end
end

--[[
void DrawArc(float cx, float cy, float r, float start_angle, float arc_angle, int num_segments)
{
	float theta = arc_angle / float(num_segments - 1);//theta is now calculated from the arc angle instead, the - 1 bit comes from the fact that the arc is open

	float tangetial_factor = tanf(theta);

	float radial_factor = cosf(theta);


	float x = r * cosf(start_angle);//we now start at the start angle
	float y = r * sinf(start_angle);

	glBegin(GL_LINE_STRIP);//since the arc is not a closed curve, this is a strip now
	for(int ii = 0; ii < num_segments; ii++)
	{
		glVertex2f(x + cx, y + cy);

		float tx = -y;
		float ty = x;

		x += tx * tangetial_factor;
		y += ty * tangetial_factor;

		x *= radial_factor;
		y *= radial_factor;
	}
	glEnd();
}
]]

local copy_color = function(color)
	return Color(color.r, color.g, color.b, color.a)
end

local color_alpha = function(color, a)
	color.a = a
	return color
end

--[[
	Collection of various utilities
]]

local TDLibUtil = {}

function TDLibUtil.DrawCircle(circle, x, y, r, color)
	calculate_circle(circle, x, y, r)

	SetDrawColor(color)
	NoTexture()
	DrawPoly(circle)
end
local DrawCircle = TDLibUtil.DrawCircle

do
	local SetMaterial = surface.SetMaterial
	local UpdateScreenEffectTexture, DrawTexturedRect, SetScissorRect = render.UpdateScreenEffectTexture, surface.DrawTexturedRect, render.SetScissorRect

	local scrW, scrH = ScrW(), ScrH()
	hook.Add("OnScreenSizeChanged", "SUI.TDLib", function()
		scrW, scrH = ScrW(), ScrH()
	end)

	function TDLibUtil.BlurPanel(s)
		local x, y = s:LocalToScreen(0, 0)

		SetDrawColor(255, 255, 255)
		SetMaterial(BLUR)

		for i = 1, 2 do
			UpdateScreenEffectTexture()
			DrawTexturedRect(x * -1, y * -1, scrW, scrH)
		end
	end

	function TDLibUtil.DrawBlur(x, y, w, h)
		SetDrawColor(255, 255, 255)
		SetMaterial(BLUR)

		SetScissorRect(x, y, x + w, y + h, true)
			for i = 1, 2 do
				UpdateScreenEffectTexture()
				DrawTexturedRect(-1, -1, scrW, scrH)
			end
		SetScissorRect(0, 0, 0, 0, false)
	end
end

local LibClasses = {}

do
	local on_funcs = {}

	function LibClasses:On(name, func)
		local old_func = self[name]

		if not old_func then
			self[name] = func
			return self
		end

		local name_2 = name .. "_funcs"

		-- we gotta avoid creating 13535035 closures
		if not on_funcs[name] then
			on_funcs[name] = function(s, a1, a2, a3, a4)
				local funcs = s[name_2]
				local i, n = 0, #funcs
				::loop::
				i = i + 1
				if i <= n then
					funcs[i](s, a1, a2, a3, a4)
					goto loop
				end
			end
		end

		if not self[name_2] then
			self[name] = on_funcs[name]
			self[name_2] = {
				old_func,
				func
			}
		else
			table.insert(self[name_2], func)
		end

		return self
	end
end

do
	local UnPredictedCurTime = UnPredictedCurTime

	local transition_func = function(s)
		local transitions = s.transitions
		local i, n = 0, #transitions
		::loop::
		i = i + 1

		if i <= n then
			local v = transitions[i]
			local name = v.name
			local v2 = s[name]
			if v.func(s) then
				if v.start_0 then
					v.start_1, v.start_0 = UnPredictedCurTime(), nil
				end

				if v2 ~= 1 then
					s[name] = Lerp((UnPredictedCurTime() - v.start_1) / v.time, v2, 1)
				end
			else
				if v.start_1 then
					v.start_0, v.start_1 = UnPredictedCurTime(), nil
				end

				if v2 ~= 0 then
					s[name] = Lerp((UnPredictedCurTime() - v.start_0) / v.time, v2, 0)
				end
			end

			goto loop
		end
	end

	function LibClasses:SetupTransition(name, time, func)
		self[name] = 0

		local transition = {
			name = name,
			time = time,
			func = func,
			start_0 = 0,
			start_1 = 0,
		}

		if self.transitions then
			for k, v in ipairs(self.transitions) do
				if v.name == name then
					self.transitions[k] = transition
					return self
				end
			end
			table.insert(self.transitions, transition)
		else
			self.transitions = {transition}
			self:On("Think", transition_func)
		end

		return self
	end
end

function LibClasses:ClearPaint()
	self.Paint = nil
	self.Paint_funcs = nil
	local SetPaintBackgroundEnabled = self.SetPaintBackgroundEnabled
	if SetPaintBackgroundEnabled then
		SetPaintBackgroundEnabled(self, false)
	end
	return self
end

function LibClasses:RoundedBox(id, r, x, y, w, h, c)
	self.colors = self.colors or {}
	local colors = self.colors

	local id_c = colors[id]
	if not id_c then
		id_c = Color(c:Unpack())
		colors[id] = id_c
	end

	sui.lerp_color(id_c, c)
	RoundedBox(r, x, y, w, h, id_c)
end

do
	local SetFGColor = Panel.SetFGColor

	local set_color = function(s, col)
		s.m_colText = col
		SetFGColor(s, col.r, col.g, col.b, col.a)
	end

	local paint = function(s)
		local col = s.sui_textcolor
		sui.lerp_color(col, s.new_col)
		set_color(s, col)
	end

	function LibClasses:TextColor(c, use_paint)
		local col = self.sui_textcolor
		if not col then
			col = Color(c:Unpack())
			self.sui_textcolor = col

			if use_paint then
				self:On("Paint", paint)
			end
		end

		if use_paint then
			self.new_col = c
		else
			sui.lerp_color(col, c)
			self:SetTextColor(col)
		end
	end
end

do
	local fade_hover_Paint = function(s, w, h)
		if s.FadeHovers ~= 0 then
			color_alpha(s.fadehover_color, s.fadehover_old_alpha * s.FadeHovers)
			if s.fadehover_radius > 0 then
				RoundedBox(s.fadehover_radius, 0, 0, w, h, s.fadehover_color)
			else
				SetDrawColor(s.fadehover_color)
				DrawRect(0, 0, w, h)
			end
		end
	end

	function LibClasses:FadeHover(color, time, radius, func)
		color = copy_color(color or COL_WHITE_2)
		self.fadehover_color = color
		self.fadehover_radius = radius or 0
		self.fadehover_old_alpha = color.a
		self:SetupTransition("FadeHovers", time or 0.8, func or TDLibUtil.HoverFunc)
		self:On("Paint", fade_hover_Paint)
		return self
	end
end

function LibClasses:BarHover(color, height, time)
	color = color or COL_WHITE_1
	height = height or 2
	time = time or 1.6
	self:SetupTransition("BarHovers", time, TDLibUtil.HoverFunc)
	self:On("Paint", function(s, w, h)
		if s.BarHovers ~= 0 then
			local bar = Round(w * s.BarHovers)
			SetDrawColor(color)
			DrawRect((w / 2) - (bar / 2), h - height, bar, height)
		end
	end)
	return self
end

do
	local paint = function(s, w, h)
		draw.RoundedBox(0, 0, 0, w, h, s.SUI_GetColor("line"))
	end

	function LibClasses:Line(dock, m1, m2, m3, m4)
		self.making_line = true

		local line = self:Add("SAM.Panel")
		line:Dock(dock or TOP)

		if self.line_margin then
			line:DockMargin(unpack(self.line_margin))
		else
			line:DockMargin(m1 or 0, m2 or 0, m3 or 0, m4 or 10)
		end

		line.no_scale = true
		line:SetTall(1)
		line.Paint = paint

		self.making_line = false
		return line
	end

	function LibClasses:LineMargin(m1, m2, m3, m4)
		self.line_margin = {m1 or 0, m2 or 0, m3 or 0, m4 or 0}
		return self
	end
end

do
	local background_Paint_1 = function(s)
		s:SetBGColor(s.background_color)
	end

	local background_Paint_2 = function(s, w, h)
		RoundedBoxEx(s.background_radius, 0, 0, w, h, s.background_color, true, true, true, true)
	end

	local background_Paint_3 = function(s, w, h)
		RoundedBoxEx(s.background_radius, 0, 0, w, h, s.background_color, s.background_r_tl, s.background_r_tr, s.background_r_bl, s.background_r_br)
	end

	function LibClasses:Background(color, radius, r_tl, r_tr, r_bl, r_br)
		self.background_color = color
		if isnumber(radius) and radius ~= 0 then
			self.background_radius = radius
			if isbool(r_tl) or isbool(r_tr) or isbool(r_bl) or isbool(r_br) then
				self.background_r_tl = r_tl
				self.background_r_tr = r_tr
				self.background_r_bl = r_bl
				self.background_r_br = r_br
				self:On("Paint", background_Paint_3)
			else
				self:On("Paint", background_Paint_2)
			end
		else
			self:SetPaintBackgroundEnabled(true)
			self:On("ApplySchemeSettings", background_Paint_1)
			self:On("PerformLayout", background_Paint_1)
		end
		return self
	end
end

function LibClasses:CircleClick(color, speed, target_radius)
	self.circle_click_color = color or COL_WHITE_2

	speed = speed or 5
	target_radius = isnumber(target_radius) and target_radius or false

	local radius, alpha, click_x, click_y = 0, -1, 0, 0
	local circle = {}
	self:On("Paint", function(s, w)
		if alpha >= 0 then
			DrawCircle(circle, click_x, click_y, radius, ColorAlpha(self.circle_click_color, alpha))
			local frame_time = RealFrameTime()
			radius, alpha = Lerp(frame_time * speed, radius, target_radius or w), Lerp(frame_time * speed, alpha, -1)
		end
	end)
	self:On("DoClick", function()
		click_x, click_y = self:CursorPos()
		radius, alpha = 0, self.circle_click_color.a
	end)
	return self
end

do
	local min = math.min
	function LibClasses:CircleClick2(color, speed, target_radius, start_radius)
		color = color or COL_WHITE_2
		local _color = Color(color:Unpack())

		speed = speed or 5
		target_radius = isnumber(target_radius) and target_radius or false

		local radius, alpha = 0, -1
		local circle = {}
		self:On("Paint", function(s, w, h)
			if alpha >= 0 then
				_color.a = alpha
				DrawCircle(circle, w / 2, h / 2, radius, _color)

				local frame_time = RealFrameTime()
				radius, alpha = Lerp(frame_time * speed, radius, target_radius or min(w, h) / 2), Lerp(frame_time * speed, alpha, -1)
			end
		end)

		self:On("DoClick", function()
			radius, alpha = start_radius or 0, color.a
		end)

		return self
	end
end

-- https://github.com/Facepunch/garrysmod/pull/1520#issuecomment-410458090
function LibClasses:Outline(color, width)
	color = color or COL_WHITE_1
	width = width or 1
	self:On("Paint", function(s, w, h)
		SetDrawColor(color)
		DrawRect(0, 0, w, width)
		DrawRect(0, h - width, w, width)
		DrawRect(0, width, width, h - (width * 2))
		DrawRect(w - width, width, width, h - (width * 2))
	end)
	return self
end

function LibClasses:LinedCorners(color, len)
	color = color or COL_WHITE_1
	len = len or 15
	self:On("Paint", function(s, w, h)
		SetDrawColor(color)
		DrawRect(0, 0, len, 1)
		DrawRect(0, 1, 1, len - 1)
		DrawRect(w - len, h - 1, len, 1)
		DrawRect(w - 1, h - len, 1, len - 1)
	end)
	return self
end

function LibClasses:SideBlock(color, size, side)
	color = color or COL_WHITE_1
	size = size or 3
	side = side or LEFT
	self:On("Paint", function(s, w, h)
		SetDrawColor(color)
		if side == LEFT then
			DrawRect(0, 0, size, h)
		elseif side == TOP then
			DrawRect(0, 0, w, size)
		elseif size == RIGHT then
			DrawRect(w - size, 0, size, h)
		elseif side == BOTTOM then
			DrawRect(0, h - size, w, size)
		end
	end)
	return self
end

function LibClasses:Blur()
	self:On("Paint", TDLibUtil.BlurPanel)
	return self
end

do
	local STENCILOPERATION_REPLACE = STENCILOPERATION_REPLACE
	local STENCILOPERATION_ZERO = STENCILOPERATION_ZERO
	local STENCILCOMPARISONFUNCTION_NEVER = STENCILCOMPARISONFUNCTION_NEVER
	local STENCILCOMPARISONFUNCTION_EQUAL = STENCILCOMPARISONFUNCTION_EQUAL

	local ClearStencil = render.ClearStencil
	local SetStencilEnable = render.SetStencilEnable
	local SetStencilWriteMask = render.SetStencilWriteMask
	local SetStencilTestMask = render.SetStencilTestMask
	local SetStencilFailOperation = render.SetStencilFailOperation
	local SetStencilPassOperation = render.SetStencilPassOperation
	local SetStencilZFailOperation = render.SetStencilZFailOperation
	local SetStencilCompareFunction = render.SetStencilCompareFunction
	local SetStencilReferenceValue = render.SetStencilReferenceValue

	local color_white = color_white

	local avatar_setplayer = function(s, ply, size)
		s.avatar:SetPlayer(ply, size)
	end

	local avatar_setsteamid = function(s, steamid, size)
		s.avatar:SetSteamID(steamid, size)
	end

	function LibClasses:CircleAvatar()
		local avatar = self:Add("AvatarImage")
		avatar:Dock(FILL)
		avatar:SetPaintedManually(true)
		self.avatar = avatar
		self.SetSteamID = avatar_setsteamid
		self.SetPlayer = avatar_setplayer

		local circle = {}
		local PaintManual = avatar.PaintManual
		self.Paint = function(s, w, h)
			ClearStencil()
			SetStencilEnable(true)

			SetStencilWriteMask(1)
			SetStencilTestMask(1)

			SetStencilFailOperation(STENCILOPERATION_REPLACE)
			SetStencilPassOperation(STENCILOPERATION_ZERO)
			SetStencilZFailOperation(STENCILOPERATION_ZERO)
			SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_NEVER)
			SetStencilReferenceValue(1)

			local a = w / 2
			DrawCircle(circle, a, a, a, color_white)

			SetStencilFailOperation(STENCILOPERATION_ZERO)
			SetStencilPassOperation(STENCILOPERATION_REPLACE)
			SetStencilZFailOperation(STENCILOPERATION_ZERO)
			SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_EQUAL)
			SetStencilReferenceValue(1)

			PaintManual(avatar)

			SetStencilEnable(false)
		end
		return self
	end
end

do
	function LibClasses:AnimationThinkInternal()
		local systime = SysTime()

		if self.Term and self.Term <= systime then
			self:Remove()

			return
		end

		local m_AnimList = self.m_AnimList
		if not m_AnimList then return end

		for i = #m_AnimList, 1, -1 do
			local anim = m_AnimList[i]
			if systime >= anim.StartTime then
				local frac = math.TimeFraction(anim.StartTime, anim.EndTime, systime)
				frac = math.Clamp(frac, 0, 1)

				local Think = anim.Think
				if Think then
					Think(anim, self, frac ^ (1.0 - (frac - 0.5)))
				end

				if frac == 1 then
					local OnEnd = anim.OnEnd
					if OnEnd then
						OnEnd(anim, self)
					end

					m_AnimList[i] = nil
				end
			end
		end
	end

	local sort = function(a, b)
		return a.EndTime > b.EndTime
	end

	function LibClasses:NewAnimation(length, delay, ease, callback)
		delay = delay or 0
		ease = ease or -1

		if self.m_AnimQueue then
			delay = delay + self:AnimTail()
			self.m_AnimQueue = false
		else
			delay = delay + SysTime()
		end

		local anim = {
			StartTime = delay,
			EndTime = delay + length,
			Ease = ease,
			OnEnd = callback
		}

		self:SetAnimationEnabled(true)

		if self.m_AnimList == nil then
			self.m_AnimList = {}
		end

		table.insert(self.m_AnimList, anim)
		table.sort(self.m_AnimList, sort)

		self.AnimationThink = self.AnimationThinkInternal

		return anim
	end

	local MoveThink = function(anim, panel, frac)
		if not anim.startx then
			anim.startx = panel.x
			anim.starty = panel.y
		end

		local x = Lerp(frac, anim.startx, anim.x)
		local y = Lerp(frac, anim.starty, anim.y)
		panel:SetPos(x, y)
	end

	function LibClasses:MoveTo(x, y, length, delay, ease, callback)
		if self.x == x and self.y == y then return end

		local anim = self:NewAnimation(length, delay, ease, callback)
		anim.x = x
		anim.y = y
		anim.Think = MoveThink
	end

	local SetSize = Panel.SetSize
	local SizeThink = function(anim, panel, frac)
		if not anim.startw then
			anim.startw, anim.starth = panel:GetSize()
		end

		local w, h
		if anim.sizew and anim.sizeh then
			w = Lerp(frac, anim.startw, anim.w)
			h = Lerp(frac, anim.starth, anim.h)
			SetSize(panel, w, h)
		elseif anim.sizew then
			w = Lerp(frac, anim.startw, anim.w)
			SetSize(panel, w, panel.starth)
		else
			h = Lerp(frac, anim.starth, anim.h)
			SetSize(panel, panel.startw, h)
		end

		if panel:GetDock() > 0 then
			panel:InvalidateParent()
		end
	end

	function LibClasses:SizeTo(w, h, length, delay, ease, callback)
		local anim = self:NewAnimation(length, delay, ease, callback)

		if w ~= -1 then
			anim.sizew = true
		end

		if h ~= -1 then
			anim.sizeh = true
		end

		anim.w, anim.h = w, h
		anim.Think = SizeThink

		return anim
	end

	local SetVisible = Panel.SetVisible
	local IsVisible = Panel.IsVisible

	local is_visible = function(s)
		local state = s.visible_state
		if state ~= nil then
			return state
		else
			return IsVisible(s)
		end
	end

	function LibClasses:AnimatedSetVisible(visible, cb)
		if visible == is_visible(self) then
			if cb then
				cb()
			end
			return
		end

		if visible then
			SetVisible(self, true)
		end

		self.visible_state = visible
		self:Stop()

		self:AlphaTo(visible and 255 or 0, 0.2, 0, function()
			SetVisible(self, visible)
			self:InvalidateParent(true)
			if cb then
				cb()
			end
		end)

		self:InvalidateParent(true)
	end

	function LibClasses:AnimatedToggleVisible()
		self:AnimatedSetVisible(not is_visible(self))
	end

	function LibClasses:AnimatedIsVisible()
		return is_visible(self)
	end
end

function Panel:SUI_TDLib()
	for k, v in pairs(LibClasses) do
		self[k] = v
	end
	return self
end

TDLibUtil.Install = Panel.SUI_TDLib

local count = 0
TDLibUtil.Start = function()
	count = count + 1
	for k, v in pairs(LibClasses) do
		if not Panel["SUI_OLD" .. k] then
			local old = Panel[k]
			if old == nil then
				old = v
			end
			Panel[k], Panel["SUI_OLD" .. k] = v, old
		end
	end
end

TDLibUtil.End = function()
	count = count - 1
	if count > 0 then return end
	for k, v in pairs(LibClasses) do
		local old = Panel["SUI_OLD" .. k]
		if old == v then
			Panel[k] = nil
		else
			Panel[k] = old
		end
		Panel["SUI_OLD" .. k] = nil
	end
end

TDLibUtil.HoverFunc = function(p)
	return p:IsHovered() and not p:GetDisabled()
end

TDLibUtil.DrawOutlinedBox = function(radius, x, y, w, h, bg, outline, thickness)
	thickness = thickness or 2
	draw.RoundedBox(radius, x, y, w, h, outline)
	draw.RoundedBox(radius, x + thickness, y + thickness, w - (thickness * 2), h - (thickness * 2), bg)
end

do
	local cos, sin, sqrt = math.cos, math.sin, math.sqrt
	local clamp, floor = math.Clamp, math.floor
	local min, max = math.min, math.max

	local calc_ellipse_points = function(rx, ry)
		local points = sqrt(((rx * ry) / 2) * 6)
		return max(points, 8)
	end

	local M_PI = 3.14159265358979323846
	calc_rect = function(c, r, x, y, w, h)
		if
			(c.r == r) and
			(c.x == x and c.y == y) and
			(c.w == w and c.h == h)
		then return end

		r = clamp(r, 0, min(w, h) / 2)

		local rx, ry = r, r
		if w >= 0.02 then
			rx = min(rx, w / 2.0 - 0.01)
		end
		if h >= 0.02 then
			ry = min(ry, h / 2.0 - 0.01)
		end

		local points = max(calc_ellipse_points(rx, ry) / 4, 1)
		points = floor(points)

		local half_pi = M_PI / 2
		local angle_shift = half_pi / (points + 1)

		local phi = 0
		for i = 1, points + 2 do
			c[i] = {
				x = x + rx * (1 - cos(phi)),
				y = y + ry * (1 - sin(phi))
			}
			phi = phi + angle_shift
		end

		phi = half_pi
		for i = points + 3, 2 * (points + 2) do
			c[i] = {
				x = x + w - rx * (1 + cos(phi)),
				y = y +     ry * (1 - sin(phi))
			}
			phi = phi + angle_shift
		end

		phi = 2 * half_pi
		for i = (2 * (points + 2)) + 1, 3 * (points + 2) do
			c[i] = {
				x = x + w - rx * (1 + cos(phi)),
				y = y + h - ry * (1 + sin(phi))
			}
			phi = phi + angle_shift
		end

		phi = 3 * half_pi
		for i = (3 * (points + 2)) + 1, 4 * (points + 2) do
			c[i] = {
				x = x +     rx * (1 - cos(phi)),
				y = y + h - ry * (1 + sin(phi))
			}
			phi = phi + angle_shift
		end

		local last = (points + 2) * 4 + 1
		c[last] = c[1]

		for i = last + 1, #c do
			c[i] = nil
		end

		c.r = r
		c.x, c.y = x, y
		c.w, c.h = w, h
	end

	TDLibUtil.RoundedBox = function(c, r, x, y, w, h, color)
		calc_rect(c, r, x, y, w, h)

		SetDrawColor(color)
		NoTexture()
		DrawPoly(c)
	end
end

TDLibUtil.LibClasses = LibClasses

sui.TDLib = TDLibUtil
--PATH addons/[lib] sui/lua/sui/libs/types.lua:
-- https://gist.github.com/CapsAdmin/0d9c1e77d0fc22d910e182bfeb9812e5
local getmetatable = getmetatable

do
	local types = {
		["string"] = "",
		["boolean"] = true,
		["number"] = 0,
		["function"] = function() end,
		["thread"] = coroutine.create(getmetatable),
		["Color"] = Color(0, 0, 0),
	}

	for k, v in pairs(types) do
		if not getmetatable(v) then
			debug.setmetatable(v, {MetaName = k})
		else
			getmetatable(v).MetaName = k
		end
	end
end

function sui.type(value)
	if value == nil then
		return "nil"
	end
	local meta = getmetatable(value)
	if meta then
		meta = meta.MetaName
		if meta then
			return meta
		end
	end
	return "table"
end

do
	local function add(name)
		local new_name = name
		if name == "bool" then
			new_name = "boolean"
		end
		sui["is" .. name:lower()] = function(value)
			local meta = getmetatable(value)
			if meta and meta.MetaName == new_name then
				return true
			else
				return false
			end
		end
	end

	add("string")
	add("number")
	add("bool")
	add("function")

	add("Angle")
	add("Vector")
	add("Panel")
	add("Matrix")
end

function sui.isentity(value)
	local meta = getmetatable(value)
	if meta then
		if meta.MetaName == "Entity" then
			return true
		end
		meta = meta.MetaBaseClass
		if meta then
			return meta.MetaName == "Entity"
		end
	end
	return false
end
sui.IsEntity = sui.isentity

local type = sui.type
function sui.istable(value)
	return type(value) == "table"
end
--PATH addons/[lib] sui/lua/sui/cl_base.lua:
local hook = hook
local bit = bit
local math = math

local Color = Color
local ipairs = ipairs
local RealFrameTime = RealFrameTime

local color_white = color_white
local color_black = color_black

local sui = sui

local isfunction = sui.isfunction
local isstring = sui.isstring

local floor = math.floor

function sui.scale(v)
	return ScrH() * (v / 900)
end

function sui.hex_rgb(hex)
	hex = tonumber(hex:gsub("^([%w])([%w])([%w])$", "%1%1%2%2%3%3", 1), 16)

	return Color(
		bit.band(bit.rshift(hex, 16), 0xFF),
		bit.band(bit.rshift(hex, 8), 0xFF),
		bit.band(hex, 0xFF)
	)
end

function sui.rgb_hex(c)
	return bit.tohex((c.r * 0x10000) + (c.g * 0x100) + c.b, 6)
end
local rgb_hex = sui.rgb_hex

function sui.lerp_color(from, to)
	local frac = RealFrameTime() * 10
	from.r = Lerp(frac, from.r, to.r)
	from.g = Lerp(frac, from.g, to.g)
	from.b = Lerp(frac, from.b, to.b)
	from.a = Lerp(frac, from.a, to.a)
end

do
	local colors = {
		["41b9ff"] = Color(44, 62, 80),
		["00c853"] = Color(44, 62, 80),
		["181818"] = Color(242, 241, 239),
		["212121"] = Color(242, 241, 239),
	}

	function sui.contrast_color(color)
		local c = colors[rgb_hex(color)]
		if c then return c end

		local luminance = (0.299 * color.r + 0.587 * color.g + 0.114 * color.b) / 255
		return luminance > 0.5 and color_black or color_white
	end
end

do
	local SetDrawColor = surface.SetDrawColor
	local SetMaterial = surface.SetMaterial
	local DrawTexturedRectRotated = surface.DrawTexturedRectRotated
	function sui.draw_material(mat, x, y, size, col, rot)
		SetDrawColor(col)

		if x == -1 then
			x = size / 2
		end

		if y == -1 then
			y = size / 2
		end

		if mat then
			SetMaterial(mat)
		end

		DrawTexturedRectRotated(x, y, size, size, rot or 0)
	end
end

do
	local hsv_t = {
		[0] = function(v, p, q, t)
			return v, t, p
		end,
		[1] = function(v, p, q, t)
			return q, v, p
		end,
		[2] = function(v, p, q, t)
			return p, v, t
		end,
		[3] = function(v, p, q, t)
			return p, q, v
		end,
		[4] = function(v, p, q, t)
			return t, p, v
		end,
		[5] = function(v, p, q, t)
			return v, p, q
		end
	}

	function sui.hsv_to_rgb(h, s, v)
		local i = floor(h * 6)
		local f = h * 6 - i

		return hsv_t[i % 6](
			v * 255, -- v
			(v * (1 - s)) * 255, -- p
			(v * (1 - f * s)) * 255, -- q
			(v * (1 - (1 - f) * s)) * 255 -- t
		)
	end
end

local Panel = FindMetaTable("Panel")
local SetSize = Panel.SetSize
local GetWide = Panel.GetWide
local GetTall = Panel.GetTall
function sui.scaling_functions(panel)
	local scale_changed
	local SUI = CURRENT_SUI

	local dock_top = function(s, h)
		if not h then return end

		if not scale_changed then
			s.real_h = h
		end

		if not s.no_scale then
			h = SUI.Scale(h)
		end

		if GetTall(s) == h then return end

		SetSize(s, GetWide(s), h)
	end

	local dock_right = function(s, w)
		if not w then return end

		if not scale_changed then
			s.real_w = w
		end

		if not s.no_scale then
			w = SUI.Scale(w)
		end

		if GetWide(s) == w then return end

		SetSize(s, w, GetTall(s))
	end

	local size_changed = function(s, w, h)
		if s.using_scale then return end

		s.using_scale = true

		local dock = s:GetDock()

		if dock ~= FILL then
			if dock == NODOCK then
				dock_top(s, h)
				dock_right(s, w)
			elseif dock == TOP or dock == BOTTOM then
				dock_top(s, h)
			else
				dock_right(s, w)
			end
		end

		s.using_scale = nil
	end

	local wide_changed = function(s, w)
		size_changed(s, w)
	end

	local tall_changed = function(s, h)
		size_changed(s, nil, h)
	end

	function panel:ScaleChanged()
		scale_changed = true
		size_changed(self, self.real_w, self.real_h)
		scale_changed = nil
		if self.OnScaleChange then
			self:OnScaleChange()
		end
	end

	local on_remove = function(s)
		SUI.RemoveScaleHook(s)
	end

	function panel:ScaleInit()
		self.SetSize = size_changed
		self.SetWide = wide_changed
		self.SetTall = tall_changed
		SUI.OnScaleChanged(self, self.ScaleChanged)
		self:On("OnRemove", on_remove)
	end
end

do
	local utf8 = {}

	local str_rel_to_abs = function(str, v, str_n)
		return v > 0 and v or math.max(str_n + v + 1, 1)
	end

	local utf8_decode = function(str, start_pos, str_n)
		start_pos = str_rel_to_abs(str, start_pos or 1, str_n)

		local b1 = str:byte(start_pos, start_pos)
		if not b1 then return nil end
		if b1 < 0x80 then return start_pos, start_pos, b1 end
		if b1 > 0xF4 or b1 < 0xC2 then return nil end

		local cont_byte_count = b1 >= 0xF0 and 3 or b1 >= 0xE0 and 2 or b1 >= 0xC0 and 1
		local end_pos = start_pos + cont_byte_count
		local code_point = 0

		if str_n < end_pos then return nil end

		local bytes = {str:byte(start_pos + 1, end_pos)}
		for i = 1, #bytes do
			local b_x = bytes[i]
			if bit.band(b_x, 0xC0) ~= 0x80 then return nil end
			code_point = bit.bor(bit.lshift(code_point, 6), bit.band(b_x, 0x3F))
			b1 = bit.lshift(b1, 1)
		end

		code_point = bit.bor(code_point, bit.lshift(bit.band(b1, 0x7F), cont_byte_count * 5))

		return start_pos, end_pos, code_point
	end

	local replacement = string.char(239, 191, 189)

	function utf8.force(str)
		local end_pos = #str
		if end_pos == 0 then return str, end_pos end

		local ret = ""
		local cur_pos = 1

		repeat
			local seq_start_pos, seq_end_pos = utf8_decode(str, cur_pos, end_pos)

			if not seq_start_pos then
				ret = ret .. replacement
				cur_pos = cur_pos + 1
			else
				ret = ret .. str:sub(seq_start_pos, seq_end_pos)
				cur_pos = seq_end_pos + 1
			end
		until cur_pos > end_pos

		return ret, #ret
	end

	-- https://gist.github.com/gdeglin/4128882

	local utf8_char_bytes = function(c)
		if c > 0 and c <= 127 then
			return 1
		elseif c >= 194 and c <= 223 then
			return 2
		elseif c >= 224 and c <= 239 then
			return 3
		elseif c >= 240 and c <= 244 then
			return 4
		end
	end
	utf8.char_bytes = utf8_char_bytes

	function utf8.len(str)
		local length = #str

		local len = 0

		local pos = 1
		while pos <= length do
			len = len + 1
			pos = pos + utf8_char_bytes(str:byte(pos))
		end

		return len
	end

	function utf8.sub(str, i, j)
		j = j or -1

		if i == nil then return "" end

		local l = (i >= 0 and j >= 0) or utf8.len(str)
		local start_char = (i >= 0) and i or l + i + 1
		local end_char = (j >= 0) and j or l + j + 1

		if start_char > end_char then return "" end

		local pos = 1
		local length = #str
		local len = 0

		local start_byte, end_byte = 1, length

		while pos <= length do
			len = len + 1

			if len == start_char then
				start_byte = pos
			end

			pos = pos + utf8_char_bytes(str:byte(pos))

			if len == end_char then
				end_byte = pos - 1
				break
			end
		end

		return str:sub(start_byte, end_byte)
	end

	sui.utf8 = utf8
end

--
-- thanks falco!
-- https://github.com/FPtje/DarkRP/blob/4fd2c3c315427e79bb7624702cfaefe9ad26ac7e/gamemode/modules/base/cl_util.lua#L42
--
do
	local utf8 = utf8
	local surface = surface

	local max_width, original_width, can_fix

	local fix_width = function()
		if can_fix then
			can_fix = false
			max_width = original_width
		end
	end

	local char_wrap = function(text, remaining_width)
		local total_width  = 0

		local new_text = ""
		for char in text:gmatch(utf8.charpattern) do
			total_width  = total_width  + surface.GetTextSize(char)
			if total_width >= remaining_width then
				total_width = surface.GetTextSize(char)
				fix_width()
				remaining_width = max_width

				new_text = new_text .. ("\n" .. char)
			else
				new_text = new_text .. char
			end
		end

		return new_text, total_width
	end

	function sui.wrap_text(text, font, width, first_width)
		text = sui.utf8.force(text)

		local total_width = 0
		can_fix = first_width and true or false
		max_width, original_width = first_width or width, width

		surface.SetFont(font)

		local space_width = surface.GetTextSize(" ")

		text = text:gsub("(%s?[%S]*)", function(word)
			local char = word:sub(1, 1)
			if char == "\n" then
				total_width = 0
				fix_width()
			end

			local wordlen = surface.GetTextSize(word)
			total_width = total_width + wordlen

			if wordlen >= max_width then
				local split_word
				split_word, total_width = char_wrap(word, max_width - (total_width - wordlen))
				return split_word
			elseif total_width < max_width then
				return word
			end

			fix_width()

			total_width = wordlen

			if char == " " then
				total_width = total_width - space_width
				return "\n" .. word:sub(2)
			end

			return "\n" .. word
		end)

		return text
	end
end

function sui.register(classname, panel_table, parent_class)
	sui.TDLib.Install(panel_table)

	if not panel_table.Add then
		function panel_table:Add(pnl)
			return vgui.Create(pnl, self)
		end
	end

	if not panel_table.NoOverrideClear and not panel_table.Clear then
		function panel_table:Clear()
			local children = self:GetChildren()
			for i = 1, #children do
				children[i]:Remove()
			end
		end
	end

	local SUI = CURRENT_SUI

	for k, v in pairs(SUI.panels_funcs) do
		panel_table[k] = v
	end

	panel_table.SUI_GetColor = function(name)
		return SUI.GetColor(name)
	end

	SUI.panels[classname] = panel_table

	return vgui.Register(SUI.name .. "." .. classname, panel_table, parent_class)
end

local Material; do
	local C_Material, material_str = select(2, debug.getupvalue(_G.Material, 1)), "0001010" -- [["mips smooth"]]
	Material = function(name)
		return C_Material(name, material_str)
	end
end
sui.Material = Material

local function prepare_theme(theme)
	for k, v in pairs(theme) do
		if IsColor(v) then continue end

		if istable(v) then
			prepare_theme(v)
		elseif isstring(v) and v:sub(1, 1) == "#" then
			theme[k] = sui.hex_rgb(v:sub(2))
		end
	end
end

function sui.new(addon_name, default_scaling, panels_funcs)
	local SUI = {
		name = addon_name,
		panels = {},
		panels_funcs = panels_funcs or {}
	}

	CURRENT_SUI = SUI

	do
		local themes = table.Copy(sui.themes)
		local current_theme_table

		function SUI.GetColor(color_name)
			return current_theme_table[color_name]
		end

		function SUI.SetTheme(theme_name)
			SUI.current_theme = theme_name
			current_theme_table = themes[theme_name]
			hook.Call(addon_name .. ".ThemeChanged")
		end

		function SUI.GetThemes()
			return themes
		end

		function SUI.AddToTheme(theme_name, tbl)
			local theme = themes[theme_name]
			for k, v in pairs(tbl) do
				theme[k] = v
			end
			prepare_theme(theme)
		end

		function SUI.RemoveTheme(theme_name)
			themes[theme_name] = nil
			if theme_name == SUI.current_theme then
				SUI.SetTheme(next(themes))
			end
		end

		function SUI.AddTheme(theme_name, tbl)
			prepare_theme(tbl)
			themes[theme_name] = tbl
		end

		SUI.themes = themes
	end

	local Scale
	do
		local scale = 1

		if default_scaling then
			SUI.Scale = sui.scale
		else
			function SUI.Scale(v)
				return floor((v * scale) + 0.5)
			end
		end
		Scale = SUI.Scale

		function SUI.ScaleEven(v)
			v = Scale(v)
			if v % 2 ~= 0 then
				v = v + 1
			end
			return v
		end

		function SUI.SetScale(_scale)
			if _scale == scale then return end

			scale = _scale
			SUI.scale = _scale

			for k, v in pairs(SUI.fonts) do
				SUI.CreateFont(k:sub(#addon_name + 1), v.font, v.size, v.weight)
			end

			SUI.CallScaleChanged()
		end

		local n = 0
		local keys = {}
		local hooks = {}
		_G[addon_name .. "_HOOKS"] = keys
		_G[addon_name .. "_KEYS"] = hooks
		_G[addon_name .. "_N"] = function()
			return n
		end
		function SUI.OnScaleChanged(name, func)
			if not isfunction(func) then
				error("Invalid function?")
			end

			if not name then
				error("Invalid name?")
			end

			if not isstring(name) then
				local _func = func
				func = function()
					local isvalid = name.IsValid
					if isvalid and isvalid(name) then
						_func(name)
					else
						SUI.RemoveScaleHook(name, true)
					end
				end
			end

			local pos = keys[name]
			if pos then
				hooks[pos + 1] = func
			else
				hooks[n + 1] = name
				hooks[n + 2] = func
				keys[name] = n + 1
				n = n + 2
			end
		end

		function SUI.RemoveScaleHook(name, in_hook)
			local pos = keys[name]
			if not pos then return end

			if in_hook then
				hooks[pos] = nil
				hooks[pos + 1] = nil
			else
				local new_name = hooks[n - 1]
				if new_name then
					hooks[pos], hooks[pos + 1] = new_name, hooks[n]
					hooks[n - 1], hooks[n] = nil, nil
					keys[new_name] = pos
				end
				n = n - 2
			end
			keys[name] = nil
		end

		function SUI.CallScaleChanged()
			if n == 0 then return end

			local i, c_n = 2, n
			::loop::
			local func = hooks[i]
			if func then
				func()
				i = i + 2
			else
				local _n, _i = c_n, i
				if n ~= c_n then
					_n = n
					i = i + 2
				else
					c_n = c_n - 2
				end

				local new_name = hooks[_n - 1]
				if new_name then
					hooks[_i - 1], hooks[_i] = new_name, hooks[_n]
					hooks[_n - 1], hooks[_n] = nil, nil
					keys[new_name] = _i - 1
				end

				n = n - 2
			end

			if i <= c_n then
				goto loop
			end
		end

		function SUI.GetScale()
			return scale
		end

		SUI.scale = 1
	end

	do
		local fonts = {}

		function SUI.CreateFont(font_name, font, size, weight)
			font_name = addon_name .. font_name

			fonts[font_name] = fonts[font_name] or {
				font = font,
				size = size,
				weight = weight
			}

			surface.CreateFont(font_name, {
				font = font,
				size = Scale(size),
				weight = weight,
				extended = true
			})

			return font_name
		end

		function SUI.GetFont(font_name)
			return addon_name .. font_name
		end

		function SUI.GetFontHeight(font_name)
			local font = fonts[addon_name .. font_name] or fonts[font_name]
			if not font then return 0 end

			return floor(Scale(font.size or 0))
		end

		SUI.fonts = fonts
	end

	do
		local materials = {}

		local delay = 0.008
		local next_run = UnPredictedCurTime()

		function SUI.Material(mat, allow_delay)
			local _mat = materials[mat]
			if _mat then return _mat end

			if allow_delay then
				if UnPredictedCurTime() < next_run then return end
				next_run = UnPredictedCurTime() + delay
			end

			materials[mat] = Material(mat)

			return materials[mat]
		end

		SUI.materials = materials
	end

	SUI.SetTheme("Dark")

	for _, f in ipairs(file.Find("sui/vgui/sui_*.lua", "LUA")) do
		include("sui/vgui/" .. f)
	end

	for _, f in ipairs(file.Find(string.format("sui/vgui/%s_*.lua", addon_name:lower()), "LUA")) do
		include("sui/vgui/" .. f)
	end

	return SUI
end

sui.themes = sui.themes or {}
function sui.add_theme(name, tbl)
	prepare_theme(tbl)
	sui.themes[name] = tbl
end

function sui.valid_options()
	local objs = {}
	objs.IsValid = function()
		local valid = true
		for i = 1, #objs do
			local obj = objs[i]
			if obj:IsValid() and obj.valid == false then
				valid = false
				break
			end
		end
		return valid
	end
	objs.Add = function(obj)
		table.insert(objs, obj)
	end
	return objs
end

do
	local label = vgui.Create("Label")
	label:SetVisible(false)
	label:SetMouseInputEnabled(false)
	label:SetKeyboardInputEnabled(false)

	local SetFontInternal = label.SetFontInternal
	local SetText = label.SetText
	local GetTextSize = label.GetTextSize
	function sui.get_text_size(text, font)
		SetFontInternal(label, font)
		SetText(label, text)
		return GetTextSize(label)
	end
end

do
	local SURFACE = Color(31, 31, 31)
	local PRIMARY = Color(65, 185, 255)

	local ON_SURFACE = Color(255, 255, 255)
	local ON_SURFACE_HIGH_EMPHASIS = ColorAlpha(ON_SURFACE, 221)
	local ON_SURFACE_MEDIUM_EMPHASIS = ColorAlpha(ON_SURFACE, 122)
	local ON_SURFACE_DISABLED = ColorAlpha(ON_SURFACE, 97)

	local ON_PRIMARY = Color(60, 60, 60)

	sui.add_theme("Dark", {
		frame = Color(18, 18, 18),
		frame_blur = false,

		title = ON_SURFACE,
		header = SURFACE,

		close = ON_SURFACE_MEDIUM_EMPHASIS,
		close_hover = Color(255, 60, 60),
		close_press = Color(255, 255, 255, 30),

		button = PRIMARY,
		button_text = "#050709",
		button_hover = ColorAlpha(ON_PRIMARY, 100),
		button_click = ColorAlpha(ON_PRIMARY, 240),
		button_disabled = Color(100, 100, 100),
		button_disabled_text = "#bdbdbd",

		button2_hover = ColorAlpha(PRIMARY, 5),
		button2_selected = ColorAlpha(PRIMARY, 15),

		scroll = ColorAlpha(PRIMARY, 97),
		scroll_grip = PRIMARY,

		scroll_panel = Color(29, 29, 29),
		scroll_panel_outline = false,

		text_entry_bg = Color(34, 34, 34),
		text_entry_bar_color = Color(0, 0, 0, 0),
		text_entry = ON_SURFACE_HIGH_EMPHASIS,
		text_entry_2 = ON_SURFACE_MEDIUM_EMPHASIS,
		text_entry_3 = PRIMARY,

		property_sheet_bg = Color(39, 39, 39),
		property_sheet_tab = Color(150, 150, 150),
		property_sheet_tab_click = Color(255, 255, 255, 30),
		property_sheet_tab_active = PRIMARY,

		toggle_button = ON_SURFACE_DISABLED,
		toggle_button_switch = ON_SURFACE_HIGH_EMPHASIS,

		toggle_button_active = ColorAlpha(PRIMARY, 65),
		toggle_button_switch_active = PRIMARY,

		slider_knob = PRIMARY,
		slider_track = ColorAlpha(PRIMARY, 65),
		slider_hover = ColorAlpha(PRIMARY, 5),
		slider_pressed = ColorAlpha(PRIMARY, 30),

		on_sheet = Color(43, 43, 43, 200),
		on_sheet_hover = Color(200, 200, 200, 20),

		--=--
		query_box_bg = "#181818",
		query_box_cancel = Color(244, 67, 54, 30),
		query_box_cancel_text = "#f44336",
		--=--

		--=--
		menu = "#212121",

		menu_option = "#212121",
		menu_option_text = "#bdbdbd",
		menu_option_hover = "#3b3b3b",
		menu_option_hover_text = "#fefefe",

		menu_spacer = "#303030",
		--=--

		line = "#303030",

		--=--
		column_sheet = "#263238",
		column_sheet_bar = "#202020",

		column_sheet_tab = "#202020",
		column_sheet_tab_hover = "#2e2e2e",
		column_sheet_tab_active = "#383838",

		column_sheet_tab_icon = "#909090",
		column_sheet_tab_icon_hover = "#f0f0f0",
		column_sheet_tab_icon_active = "#34a1e0",
		--=--

		--=--
		collapse_category_header = "#272727",
		collapse_category_header_hover = "#2a2a2a",
		collapse_category_header_active = "#2e2e2e",

		collapse_category_header_text = "#aaaaaa",
		collapse_category_header_text_hover = "#dcdcdc",
		collapse_category_header_text_active = "#34A1E0",

		collapse_category_item = "#343434",
		collapse_category_item_hover = "#464646",
		collapse_category_item_active = "#535353",

		collapse_category_item_text = "#aaaaaa",
		collapse_category_item_text_hover = "#dcdcdc",
		collapse_category_item_text_active = "#ffffff",
		--=--
	})
end

do
	local PRIMARY = Color(65, 185, 255)

	local ON_PRIMARY = Color(220, 220, 220)

	sui.add_theme("Blur", {
		frame = Color(30, 30, 30, 220),
		frame_blur = true,

		title = Color(255, 255, 255),
		header = Color(60, 60, 60, 200),

		close = Color(200, 200, 200),
		close_hover = Color(255, 60, 60),
		close_press = Color(255, 255, 255, 30),

		button = ColorAlpha(PRIMARY, 130),
		button_text = ON_PRIMARY,
		button_hover = Color(0, 0, 0, 30),
		button_click = PRIMARY,
		button_disabled = Color(100, 100, 100),
		button_disabled_text = "#bdbdbd",

		button2_hover = ColorAlpha(PRIMARY, 5),
		button2_selected = ColorAlpha(PRIMARY, 15),

		scroll = Color(0, 0, 0, 100),
		scroll_grip = PRIMARY,

		scroll_panel = Color(255, 255, 255, 10),
		scroll_panel_outline = false,

		text_entry_bg = Color(0, 0, 0, 0),
		text_entry_bar_color = Color(200, 200, 200, 153),
		text_entry = Color(240, 240, 240, 221),
		text_entry_2 = Color(200, 200, 200, 153),
		text_entry_3 = PRIMARY,

		property_sheet_bg = Color(60, 60, 60, 200),
		property_sheet_tab = Color(150, 150, 150),
		property_sheet_tab_click = Color(255, 255, 255, 40),
		property_sheet_tab_active = PRIMARY,

		toggle_button = Color(244, 67, 54),
		toggle_button_switch = Color(230, 230, 230),

		toggle_button_active = PRIMARY,
		toggle_button_switch_active = Color(230, 230, 230),

		slider_knob = PRIMARY,
		slider_track = ColorAlpha(PRIMARY, 100),
		slider_hover = ColorAlpha(PRIMARY, 40),
		slider_pressed = ColorAlpha(PRIMARY, 70),

		on_sheet = Color(60, 60, 60, 180),
		on_sheet_hover = Color(30, 30, 30, 70),

		--=--
		query_box_bg = Color(0, 0, 0, 100),
		query_box_cancel = Color(244, 67, 54, 30),
		query_box_cancel_text = "#f44336",
		--=--
	})
end

--PATH addons/[lib] sui/lua/sui/libs/gif_loader.lua:
return gluapack()()
--PATH addons/[lib] sui/lua/sui/vgui/sui_label.lua:
return gluapack()()
--PATH addons/[lib] sui/lua/sui/vgui/sui_property_sheet.lua:
local draw = draw
local surface = surface
local vgui = vgui

local TYPE_MATERIAL = TYPE_MATERIAL

local RealFrameTime = RealFrameTime
local IsValid = IsValid
local Lerp = Lerp
local pairs = pairs
local TypeID = TypeID

local TDLib_Classes = sui.TDLib.LibClasses
local TextColor = TDLib_Classes.TextColor
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local PROPERTY_SHEET_FONT = SUI.CreateFont("PropertySheet", "Roboto Regular", 18)

local PANEL = {}

AccessorFunc(PANEL, "m_FontName", "Font", FORCE_STRING)

function PANEL:Init()
	self.tabs = {}

	self:SetFont(PROPERTY_SHEET_FONT)

	local tab_scroller = self:Add("DHorizontalScroller")
	tab_scroller:Dock(TOP)

	self.tabs_tall = 26
	self.tab_scroller = tab_scroller

	self:ScaleChanged()
	SUI.OnScaleChanged(self, self.ScaleChanged)
end

function PANEL:ScaleChanged()
	self.tab_scroller:SetTall(SUI.Scale(self.tabs_tall))

	for k, v in pairs(self.tab_scroller.Panels) do
		if v:IsValid() then
			if v.Material then
				v:SetWide(self.tab_scroller:GetTall())
			else
				v:SizeToContentsX()
			end
		end
	end

	self:InvalidateLayout(true)
end

function PANEL:Paint(w, h)
	self:RoundedBox("Background", 1, 0, 0, w, self.tab_scroller:GetTall(), SUI.GetColor("property_sheet_bg"))
end

function PANEL:PaintOver(w, h)
	local active_tab = self:GetActiveTab()
	if not IsValid(active_tab) then return end

	local tab_scroller = self.tab_scroller
	local offset = tab_scroller:GetTall() - SUI.Scale(1)

	local x = active_tab:LocalToScreen(0) - self:LocalToScreen(0)

	if not self.activeTabX then
		self.activeTabX = x
		self.activeTabW = active_tab:GetWide()
	end

	local delta = RealFrameTime() * 6
	if delta then
		self.activeTabX = Lerp(delta, self.activeTabX, x)
		self.activeTabW = Lerp(delta, self.activeTabW, active_tab:GetWide())
	end

	self:RoundedBox("Background2", 1, self.activeTabX, tab_scroller.y + offset, self.activeTabW, SUI.Scale(1), SUI.GetColor("property_sheet_tab_active"))
end

local tab_Paint = function(s, w, h)
	s.circle_click_color = SUI.GetColor("property_sheet_tab_click")
	if s.property_sheet:GetActiveTab() == s then
		TextColor(s, SUI.GetColor("property_sheet_tab_active"))
	else
		TextColor(s, SUI.GetColor("property_sheet_tab"))
	end
end

local tab_DoClick = function(s)
	s.parent:SetActiveTab(s)
end

local image_paint = function(s, w, h)
	surface.SetDrawColor(color_white)
	surface.SetMaterial(s.Material)
	surface.DrawTexturedRectRotated(w * 0.5, h * 0.5, w - 10, h - 10, 0)
end

function PANEL:AddSheet(name, load_func)
	local tab = vgui.Create("DButton")
	if TypeID(name) == TYPE_MATERIAL then
		tab:SetText("")
		tab.Material = name
		tab.Paint = image_paint
		tab:SetWide(self.tab_scroller:GetTall())
	else
		tab:SetFont(self:GetFont())
		tab:SetText(name)
		tab:SetTextInset(10, 0)
		tab:SizeToContentsX()

		tab.Paint = tab_Paint
	end

	tab.parent = self
	tab.DoClick = tab_DoClick

	tab.load_func = load_func
	tab.property_sheet = self

	tab.On = TDLib_Classes.On
	TDLib_Classes.CircleClick(tab)

	self.tab_scroller:AddPanel(tab)

	if not self:GetActiveTab() then
		self:SetActiveTab(tab)
	end

	table.insert(self.tabs, tab)

	return tab
end

function PANEL:GetActiveTab()
	return self.active_tab
end

function PANEL:SetActiveTab(new_tab)
	if IsValid(new_tab) and not IsValid(new_tab.panel) then
		local panel = new_tab.load_func(self)
		panel:SetParent(self)
		panel:SetVisible(false)

		panel.tab = new_tab
		new_tab.panel = panel
	end

	if self.active_tab and IsValid(self.active_tab.panel) then
		self.active_tab.panel:SetVisible(false)
	end

	if IsValid(new_tab) then
		new_tab.panel:SetVisible(true)
	end

	self.active_tab = new_tab
end

sui.register("PropertySheet", PANEL, "EditablePanel")
--PATH addons/[lib] sui/lua/sui/vgui/sui_scroll_panel.lua:
return gluapack()()
--PATH addons/[lib] sui/lua/sui/vgui/sui_slider.lua:
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name
local TDLib = sui.TDLib

local Panel = {}

sui.scaling_functions(Panel)

AccessorFunc(Panel, "m_bValue", "Value", FORCE_NUMBER)
AccessorFunc(Panel, "m_bMin", "Min", FORCE_NUMBER)
AccessorFunc(Panel, "m_bMax", "Max", FORCE_NUMBER)
AccessorFunc(Panel, "m_bDecimals", "Decimals", FORCE_NUMBER)


AccessorFunc(Panel, "m_fSlideX", "SlideX")
AccessorFunc(Panel, "m_fSlideY", "SlideY")

AccessorFunc(Panel, "m_iLockX", "LockX")
AccessorFunc(Panel, "m_iLockY", "LockY")

AccessorFunc(Panel, "Dragging", "Dragging")

function Panel:Init()
	self:ScaleInit()

	self:SetSlideX(0.5)
	self:SetSlideY(0.5)

	self:SetMouseInputEnabled(true)
	self:SetMin(0)
	self:SetMax(10)
	self:SetValue(1)
	self:SetDecimals(1)

	self:SetSize(100, 12)

	self.rounded_box = {}

	self.Knob = vgui.Create("DButton", self)
	self.Knob:SetText("")
	self.Knob:SetSize(15, 15)
	self.Knob:NoClipping(true)
	self.Knob.Paint = self.KnobPaint
	self.Knob.OnCursorMoved = function(panel, x, y)
		x, y = panel:LocalToScreen(x, y)
		x, y = self:ScreenToLocal(x, y)
		self:OnCursorMoved(x, y)
	end
	self.Knob.circle = {}

	self:SetLockY(0.5)
end

function Panel:IsEditing()
	return self.Dragging or self.Knob.Depressed
end

function Panel:SetEnabled(b)
	self.Knob:SetEnabled(b)
	FindMetaTable("Panel").SetEnabled(self, b) -- There has to be a better way!
end

function Panel:OnCursorMoved(x, y)
	if (not self.Dragging and not self.Knob.Depressed) then return end

	local w, h = self:GetSize()
	local iw, ih = self.Knob:GetSize()

	w = w - iw
	h = h - ih

	x = x - iw * 0.5
	y = y - ih * 0.5

	x = math.Clamp(x, 0, w) / w
	y = math.Clamp(y, 0, h) / h

	if self.m_iLockX then x = self.m_iLockX end
	if self.m_iLockY then y = self.m_iLockY end

	x, y = self:TranslateValues(x, y)

	self:SetSlideX(x)
	self:SetSlideY(y)

	self:InvalidateLayout()
end

function Panel:OnMousePressed(mcode)
	if not self:IsEnabled() then return true end

	-- When starting dragging with not pressing on the knob.
	self.Knob.Hovered = true

	self:SetDragging(true)
	self:MouseCapture(true)

	local x, y = self:CursorPos()
	self:OnCursorMoved(x, y)
end

function Panel:OnMouseReleased(mcode)
	-- This is a hack. Panel.Hovered is not updated when dragging a panel (Source's dragging, not Lua Drag'n'drop)
	self.Knob.Hovered = vgui.GetHoveredPanel() == self.Knob

	self:SetDragging(false)
	self:MouseCapture(false)
end

function Panel:SetMinMax(min, max)
	self:SetMin(min)
	self:SetMax(max)
end

function Panel:TranslateValues(x, y)
	self:SetValue(self:GetMin() + (x * self:GetRange()))
	return self:GetFraction(), y
end

function Panel:GetFraction()
	return (self:GetValue() - self:GetMin()) / self:GetRange()
end

function Panel:SetValue(val)
	val = math.Clamp(val, self:GetMin(), self:GetMax())
	val = math.Round(val, self:GetDecimals())

	self.m_bValue = val
	self:SetSlideX((val - self:GetMin()) / self:GetRange())

	self:OnValueChanged(val)
end

function Panel:OnValueChanged(val)
end

function Panel:GetRange()
	return self:GetMax() - self:GetMin()
end

function Panel:Paint(w, h)
	local _h = SUI.Scale(2)
	TDLib.RoundedBox(self.rounded_box, 3, 0, h / 2 - _h / 2, w, _h, SUI.GetColor("slider_track"))
end

function Panel:KnobPaint(w, h)
	if self.Depressed then
		TDLib.DrawCircle(self.circle, w / 2, h / 2, h / 1.1, SUI.GetColor("slider_pressed"))
	elseif self.Hovered then
		TDLib.DrawCircle(self.circle, w / 2, h / 2, h / 1.1, SUI.GetColor("slider_hover"))
	end

	TDLib.DrawCircle(self.circle, w / 2, h / 2, h / 2, SUI.GetColor("slider_knob"))
end

function Panel:PerformLayout(w, h)
	local knob_size = SUI.Scale(12)
	self.Knob:SetSize(knob_size, knob_size)

	w = w - knob_size
	h = h - knob_size
	self.Knob:SetPos((self.m_fSlideX or 0) * w, (self.m_fSlideY or 0) * h)
end

function Panel:SetSlideX(i)
	self.m_fSlideX = i
	self:InvalidateLayout()
end

function Panel:SetSlideY(i)
	self.m_fSlideY = i
	self:InvalidateLayout()
end

function Panel:GetDragging()
	return self.Dragging or self.Knob.Depressed
end

sui.register("Slider", Panel, "Panel")

--PATH addons/[lib] sui/lua/sui/vgui/sui_toggle_button.lua:
return gluapack()()
--PATH addons/[lib] sui/lua/sui/vgui/sui_zcolumn_sheet.lua:
return gluapack()()
--PATH addons/[admin] sam-160/lua/sam/sh_motd.lua:
return gluapack()()
--PATH addons/[admin] sam-160/lua/sam/modules/cami.lua:
--[[
CAMI - Common Admin Mod Interface.
Copyright 2020 CAMI Contributors

Makes admin mods intercompatible and provides an abstract privilege interface
for third party addons.

Follows the specification on this page:
https://github.com/glua/CAMI/blob/master/README.md

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
]]

-- Version number in YearMonthDay format.
local version = 20211019

if CAMI and CAMI.Version >= version then return end

CAMI = CAMI or {}
CAMI.Version = version


--- @class CAMI_USERGROUP
--- defines the charactaristics of a usergroup
--- @field Name string @The name of the usergroup
--- @field Inherits string @The name of the usergroup this usergroup inherits from
--- @field CAMI_Source string @The source specified by the admin mod which registered this usergroup (if any, converted to a string)

--- @class CAMI_PRIVILEGE
--- defines the charactaristics of a privilege
--- @field Name string @The name of the privilege
--- @field MinAccess "'user'" | "'admin'" | "'superadmin'" @Default group that should have this privilege
--- @field Description string | nil @Optional text describing the purpose of the privilege
local CAMI_PRIVILEGE = {}
--- Optional function to check if a player has access to this privilege
--- (and optionally execute it on another player)
---
---  **Warning**: This function may not be called by all admin mods
--- @param actor GPlayer @The player
--- @param target GPlayer | nil @Optional - the target
--- @return boolean @If they can or not
--- @return string | nil @Optional reason
function CAMI_PRIVILEGE:HasAccess(actor, target)
end

--- Contains the registered CAMI_USERGROUP usergroup structures.
--- Indexed by usergroup name.
--- @type CAMI_USERGROUP[]
local usergroups = CAMI.GetUsergroups and CAMI.GetUsergroups() or {
    user = {
        Name = "user",
        Inherits = "user",
        CAMI_Source = "Garry's Mod",
    },
    admin = {
        Name = "admin",
        Inherits = "user",
        CAMI_Source = "Garry's Mod",
    },
    superadmin = {
        Name = "superadmin",
        Inherits = "admin",
        CAMI_Source = "Garry's Mod",
    }
}

--- Contains the registered CAMI_PRIVILEGE privilege structures.
--- Indexed by privilege name.
--- @type CAMI_PRIVILEGE[]
local privileges = CAMI.GetPrivileges and CAMI.GetPrivileges() or {}

--- Registers a usergroup with CAMI.
---
--- Use the source parameter to make sure CAMI.RegisterUsergroup function and
--- the CAMI.OnUsergroupRegistered hook don't cause an infinite loop
--- @param usergroup CAMI_USERGROUP @The structure for the usergroup you want to register
--- @param source any @Identifier for your own admin mod. Can be anything.
--- @return CAMI_USERGROUP @The usergroup given as an argument
function CAMI.RegisterUsergroup(usergroup, source)
    if source then
        usergroup.CAMI_Source = tostring(source)
    end
    usergroups[usergroup.Name] = usergroup

    hook.Call("CAMI.OnUsergroupRegistered", nil, usergroup, source)
    return usergroup
end

--- Unregisters a usergroup from CAMI. This will call a hook that will notify
--- all other admin mods of the removal.
---
---  **Warning**: Call only when the usergroup is to be permanently removed.
---
--- Use the source parameter to make sure CAMI.UnregisterUsergroup function and
--- the CAMI.OnUsergroupUnregistered hook don't cause an infinite loop
--- @param usergroupName string @The name of the usergroup.
--- @param source any @Identifier for your own admin mod. Can be anything.
--- @return boolean @Whether the unregistering succeeded.
function CAMI.UnregisterUsergroup(usergroupName, source)
    if not usergroups[usergroupName] then return false end

    local usergroup = usergroups[usergroupName]
    usergroups[usergroupName] = nil

    hook.Call("CAMI.OnUsergroupUnregistered", nil, usergroup, source)

    return true
end

--- Retrieves all registered usergroups.
--- @return CAMI_USERGROUP[] @Usergroups indexed by their names.
function CAMI.GetUsergroups()
    return usergroups
end

--- Receives information about a usergroup.
--- @param usergroupName string
--- @return CAMI_USERGROUP | nil @Returns nil when the usergroup does not exist.
function CAMI.GetUsergroup(usergroupName)
    return usergroups[usergroupName]
end

--- Checks to see if potentialAncestor is an ancestor of usergroupName.
--- All usergroups are ancestors of themselves.
---
--- Examples:
--- * `user` is an ancestor of `admin` and also `superadmin`
--- * `admin` is an ancestor of `superadmin`, but not `user`
--- @param usergroupName string @The usergroup to query
--- @param potentialAncestor string @The ancestor to query
--- @return boolean @Whether usergroupName inherits potentialAncestor.
function CAMI.UsergroupInherits(usergroupName, potentialAncestor)
    repeat
        if usergroupName == potentialAncestor then return true end

        usergroupName = usergroups[usergroupName] and
                         usergroups[usergroupName].Inherits or
                         usergroupName
    until not usergroups[usergroupName] or
          usergroups[usergroupName].Inherits == usergroupName

    -- One can only be sure the usergroup inherits from user if the
    -- usergroup isn't registered.
    return usergroupName == potentialAncestor or potentialAncestor == "user"
end

--- Find the base group a usergroup inherits from.
---
--- This function traverses down the inheritence chain, so for example if you have
--- `user` -> `group1` -> `group2`
--- this function will return `user` if you pass it `group2`.
---
---  **NOTE**: All usergroups must eventually inherit either user, admin or superadmin.
--- @param usergroupName string @The name of the usergroup
--- @return "'user'" | "'admin'" | "'superadmin'" @The name of the root usergroup
function CAMI.InheritanceRoot(usergroupName)
    if not usergroups[usergroupName] then return end

    local inherits = usergroups[usergroupName].Inherits
    while inherits ~= usergroups[usergroupName].Inherits do
        usergroupName = usergroups[usergroupName].Inherits
    end

    return usergroupName
end

--- Registers an addon privilege with CAMI.
---
---  **Warning**: This should only be used by addons. Admin mods must *NOT*
---  register their privileges using this function.
--- @param privilege CAMI_PRIVILEGE
--- @return CAMI_PRIVILEGE @The privilege given as argument.
function CAMI.RegisterPrivilege(privilege)
    privileges[privilege.Name] = privilege

    hook.Call("CAMI.OnPrivilegeRegistered", nil, privilege)

    return privilege
end

--- Unregisters a privilege from CAMI.
--- This will call a hook that will notify any admin mods of the removal.
---
---  **Warning**: Call only when the privilege is to be permanently removed.
--- @param privilegeName string @The name of the privilege.
--- @return boolean @Whether the unregistering succeeded.
function CAMI.UnregisterPrivilege(privilegeName)
    if not privileges[privilegeName] then return false end

    local privilege = privileges[privilegeName]
    privileges[privilegeName] = nil

    hook.Call("CAMI.OnPrivilegeUnregistered", nil, privilege)

    return true
end

--- Retrieves all registered privileges.
--- @return CAMI_PRIVILEGE[] @All privileges indexed by their names.
function CAMI.GetPrivileges()
    return privileges
end

--- Receives information about a privilege.
--- @param privilegeName string
--- @return CAMI_PRIVILEGE | nil
function CAMI.GetPrivilege(privilegeName)
    return privileges[privilegeName]
end

-- Default access handler
local defaultAccessHandler = {["CAMI.PlayerHasAccess"] =
    function(_, actorPly, privilegeName, callback, targetPly, extraInfoTbl)
        -- The server always has access in the fallback
        if not IsValid(actorPly) then return callback(true, "Fallback.") end

        local priv = privileges[privilegeName]

        local fallback = extraInfoTbl and (
            not extraInfoTbl.Fallback and actorPly:IsAdmin() or
            extraInfoTbl.Fallback == "user" and true or
            extraInfoTbl.Fallback == "admin" and actorPly:IsAdmin() or
            extraInfoTbl.Fallback == "superadmin" and actorPly:IsSuperAdmin())


        if not priv then return callback(fallback, "Fallback.") end

        local hasAccess =
            priv.MinAccess == "user" or
            priv.MinAccess == "admin" and actorPly:IsAdmin() or
            priv.MinAccess == "superadmin" and actorPly:IsSuperAdmin()

        if hasAccess and priv.HasAccess then
            hasAccess = priv:HasAccess(actorPly, targetPly)
        end

        callback(hasAccess, "Fallback.")
    end,
    ["CAMI.SteamIDHasAccess"] =
    function(_, _, _, callback)
        callback(false, "No information available.")
    end
}

--- @class CAMI_ACCESS_EXTRA_INFO
--- @field Fallback "'user'" | "'admin'" | "'superadmin'" @Fallback status for if the privilege doesn't exist. Defaults to `admin`.
--- @field IgnoreImmunity boolean @Ignore any immunity mechanisms an admin mod might have.
--- @field CommandArguments table @Extra arguments that were given to the privilege command.

--- Checks if a player has access to a privilege
--- (and optionally can execute it on targetPly)
---
--- This function is designed to be asynchronous but will be invoked
---  synchronously if no callback is passed.
---
---  **Warning**: If the currently installed admin mod does not support
---                 synchronous queries, this function will throw an error!
--- @param actorPly GPlayer @The player to query
--- @param privilegeName string @The privilege to query
--- @param callback fun(hasAccess: boolean, reason: string|nil) @Callback to receive the answer, or nil for synchronous
--- @param targetPly GPlayer | nil @Optional - target for if the privilege effects another player (eg kick/ban)
--- @param extraInfoTbl CAMI_ACCESS_EXTRA_INFO | nil @Table of extra information for the admin mod
--- @return boolean | nil @Synchronous only - if the player has the privilege
--- @return string | nil @Synchronous only - optional reason from admin mod
function CAMI.PlayerHasAccess(actorPly, privilegeName, callback, targetPly,
extraInfoTbl)
    local hasAccess, reason = nil, nil
    local callback_ = callback or function(hA, r) hasAccess, reason = hA, r end

    hook.Call("CAMI.PlayerHasAccess", defaultAccessHandler, actorPly,
        privilegeName, callback_, targetPly, extraInfoTbl)

    if callback ~= nil then return end

    if hasAccess == nil then
        local err = [[The function CAMI.PlayerHasAccess was used to find out
        whether Player %s has privilege "%s", but an admin mod did not give an
        immediate answer!]]
        error(string.format(err,
            actorPly:IsPlayer() and actorPly:Nick() or tostring(actorPly),
            privilegeName))
    end

    return hasAccess, reason
end

--- Get all the players on the server with a certain privilege
--- (and optionally who can execute it on targetPly)
---
---  **NOTE**: This is an asynchronous function!
--- @param privilegeName string @The privilege to query
--- @param callback fun(players: GPlayer[]) @Callback to receive the answer
--- @param targetPly GPlayer | nil @Optional - target for if the privilege effects another player (eg kick/ban)
--- @param extraInfoTbl CAMI_ACCESS_EXTRA_INFO | nil @Table of extra information for the admin mod
function CAMI.GetPlayersWithAccess(privilegeName, callback, targetPly,
extraInfoTbl)
    local allowedPlys = {}
    local allPlys = player.GetAll()
    local countdown = #allPlys

    local function onResult(ply, hasAccess, _)
        countdown = countdown - 1

        if hasAccess then table.insert(allowedPlys, ply) end
        if countdown == 0 then callback(allowedPlys) end
    end

    for _, ply in ipairs(allPlys) do
        CAMI.PlayerHasAccess(ply, privilegeName,
            function(...) onResult(ply, ...) end,
            targetPly, extraInfoTbl)
    end
end

--- @class CAMI_STEAM_ACCESS_EXTRA_INFO
--- @field IgnoreImmunity boolean @Ignore any immunity mechanisms an admin mod might have.
--- @field CommandArguments table @Extra arguments that were given to the privilege command.

--- Checks if a (potentially offline) SteamID has access to a privilege
--- (and optionally if they can execute it on a target SteamID)
---
---  **NOTE**: This is an asynchronous function!
--- @param actorSteam string | nil @The SteamID to query
--- @param privilegeName string @The privilege to query
--- @param callback fun(hasAccess: boolean, reason: string|nil) @Callback to receive  the answer
--- @param targetSteam string | nil @Optional - target SteamID for if the privilege effects another player (eg kick/ban)
--- @param extraInfoTbl CAMI_STEAM_ACCESS_EXTRA_INFO | nil @Table of extra information for the admin mod
function CAMI.SteamIDHasAccess(actorSteam, privilegeName, callback,
targetSteam, extraInfoTbl)
    hook.Call("CAMI.SteamIDHasAccess", defaultAccessHandler, actorSteam,
        privilegeName, callback, targetSteam, extraInfoTbl)
end

--- Signify that your admin mod has changed the usergroup of a player. This
--- function communicates to other admin mods what it thinks the usergroup
--- of a player should be.
---
--- Listen to the hook to receive the usergroup changes of other admin mods.
--- @param ply GPlayer @The player for which the usergroup is changed
--- @param old string @The previous usergroup of the player.
--- @param new string @The new usergroup of the player.
--- @param source any @Identifier for your own admin mod. Can be anything.
function CAMI.SignalUserGroupChanged(ply, old, new, source)
    hook.Call("CAMI.PlayerUsergroupChanged", nil, ply, old, new, source)
end

--- Signify that your admin mod has changed the usergroup of a disconnected
--- player. This communicates to other admin mods what it thinks the usergroup
--- of a player should be.
---
--- Listen to the hook to receive the usergroup changes of other admin mods.
--- @param steamId string @The steam ID of the player for which the usergroup is changed
--- @param old string @The previous usergroup of the player.
--- @param new string @The new usergroup of the player.
--- @param source any @Identifier for your own admin mod. Can be anything.
function CAMI.SignalSteamIDUserGroupChanged(steamId, old, new, source)
    hook.Call("CAMI.SteamIDUsergroupChanged", nil, steamId, old, new, source)
end

--PATH addons/[tfres] frest_levels/lua/sam/modules/frest_lvl.lua:
return gluapack()()
--PATH addons/[tfres] frest_levels/lua/sam/modules/frest_lvl.lua:
if SAM_LOADED then return end

local add = not GAMEMODE and hook.Add or function(_, _, fn)
	fn()
end

add("PostGamemodeLoaded", "SAM.DarkRP2", function()
	if not DarkRP then return end

	local sam, command, language = sam, sam.command, sam.language

	command.set_category("DarkRP")

	command.new("setlevel")
		:SetPermission("setlevel", "superadmin")

		:AddArg("player",{single_target = true})
        :AddArg("number", {hint = "Jaki ma mie lvl?", min = 0, max = 500, round = true, default = 100})
        :AddArg("text", {hint = "klasad,naukowiec itd TYLKO JEDEN NA RAZ"})
        


		:OnExecute(function(ply, targets,number,text)
			for i = 1, #targets do
				local target = targets[i]
				-- do something with him --
				target:SetLevel(number,text)
			end
			

			sam.player.send_message(nil, "{A} Ustawi Level {V1} {V2} {T} ", {
				A = ply, T = targets, V1 = number, V2 = text
			})
		end)
	:End()
	command.new("addlevel")
		:SetPermission("setlevel", "superadmin")

		:AddArg("player",{single_target = true})
        :AddArg("number", {hint = "ile ma doda?", min = 1, max = 500, round = true, default = 100})
        :AddArg("text", {hint = "klasad,naukowiec itd TYLKO JEDEN NA RAZ"})
        

		:OnExecute(function(ply, targets,number,text)
			for i = 1, #targets do
				local target = targets[i]
				-- do something with him --
			local l = target:getDarkRPVar(text.."_lvl",0)
			target:SetLevel(l + number,text)
			end


			sam.player.send_message(nil, "{A} Ustawi doda Level {V1} {V2} {T}", {
				A = ply, T = targets, V1 = number, V2 = text
			})
		end)
	:End()
	command.new("addexp")
		:SetPermission("addexp", "superadmin")

		:AddArg("player",{single_target = true})
        :AddArg("number", {hint = "ile ma doda?", min = 1, max = 5000, round = true, default = 100})
        :AddArg("text", {hint = "klasad,naukowiec itd TYLKO JEDEN NA RAZ"})
        

		:OnExecute(function(ply, targets,number,text)
			for i = 1, #targets do
				local target = targets[i]
				-- do something with him --
			target:AddExp(number,text)
		end


			sam.player.send_message(nil, "{A} Ustawi doda EXP {V1} {V2} {T}", {
				A = ply, T = targets, V1 = number, V2 = text
			})
		end)
	:End()
end)
--PATH addons/[lib] sui/lua/sui/vgui/sui_combobox.lua:
return gluapack()()
--PATH addons/[lib] sui/lua/sui/vgui/sui_slider.lua:
return gluapack()()
--PATH addons/[lib] sui/lua/sui/vgui/sui_zbutton.lua:
return gluapack()()
--PATH addons/[chat] scb-29/lua/sh_scb_config.lua:
if SCB_LOADED then return end

local config = scb.config

--
-- Chatbox title!@!
-- SERVER_NAME will be replaced with your server name
-- PLAYER_COUNT will be replaced with your online player count
-- EG.
-- config.chatbox_title = "SERVER_NAME (PLAYER_COUNT)" -- > Srlion Gaming (1)
--
config.chatbox_title = "SERVER_NAME (PLAYER_COUNT)"

--
-- By default it uses 12h format, for 24h use "%H:%M:%S"
--
config.timestamps_format = "%I:%M:%S %p"

--
-- Allow parsing in chat print functions? (chat.AddText/Player:ChatPrint/Player:PrintMessage)
-- If it causes problems then disable it.
--
config.parse_in_chat = true

--
-- Hide language sign that appears behing emojis if you are typing in a non-English language
--
config.hide_language_sign = true

--
-- Enable the custom join messages
--
config.enable_custom_join_messages = false

--
-- Enable the custom leave messages
--
config.enable_custom_leave_messages = false

--
-- Enable avatars
--
config.enable_avatars = true

--
-- You can use SteamID/SteamID64/Ranks
-- If the first value is 'true' then anyone can use it
--
config.permissions = {
	--
	-- Who can add/remove/edit emojis & tags?
	--
	menu = {
		"superadmin",
		"76561198261855442",
		"STEAM_0:0:150794857",
	},

	--
	-- Who can use rainbow texts?
	-- Eg.
	-- hi there {* everyone}!
	--
	rainbow = {
		"superadmin",
		"admin",
		"vip",
		"vip+",
	},

	--
	-- Who can use flashing texts?
	-- Eg.
	-- hi there {! everyone}!
	--
	flashing = {
		false, -- anyone can use this!!!
	},

	--
	-- Who can use colored texts?
	-- Eg.
	-- hi there {red Srlion}!
	-- hi there {#ff0000 Srlion}!
	--
	colored_texts = {
		false, -- anyone can use this!!!
	},

	--
	-- Who can use custom emojis?
	--
	custom_emojis = {
		true, -- anyone can use this because true is the first value!!!
		"superadmin",
	}
}

--
-- You can add colors that can be used in chatbox, eg. {my_new_color hi there!}
-- Use something like https://www.hexcolortool.com to get hex codes!
--
config.colors = {
	red = "f44336",
	pink = "E91E63",
	purple = "9C27B0",
	blue = "1773c4",
	cyan = "00BCD4",
	green = "4CAF50",
	yellow = "FFEB3B",
	orange = "FF9800",
	brown = "7b5804",
	grey = "9E9E9E",
	white = "E0E0E0",
	black = "080808"
}

scb.language = {
	save = "SAVE",
	cancel = "CANCEL",
	edit = "Edit",
	search = "Search...",
	team = "TEAM",
	dead = "*DEAD* ",
	console = "Console",
	remove = "Remove",

	type_something = "type something...",

	settings_title = "Settings",

	client_title = "Client",
	tags_title = "Tags",
	emojis_title = "Emojis",

	show_avatars = "Show avatars",
	show_time = "Show timestapms",
	disable_rainbow = "Disable rainbow colors",
	disable_flashing = "Disable flashing texts",
	blur_theme = "Blur theme",
	join_messages = "Join/Disconnect messages",
	scale = "Scale",
	messages_fade = "Messages fade out time",
	max_messages = "Max messages",
	reset_size = "Reset chatbox size",
	reset_position = "Reset chatbox position",
	clear_reload = "Clear & Reload images (can fix problems if some images are outdated or not loading)",

	add_tag = "Add Tag",
	tag_owner = "SteamID/SteamID64/Rank",
	tag = "Tag",

	add_emoji = "Add Emoji",
	emoji_name = "Name",
	emoji_url = "URL",

	copy_text = "Copy Text",
	copy_message = "Copy Message",
	copy_steamid = "Copy Steamid",
	copy_steamid64 = "Copy Steamid64",
	show_profile = "Show Player Profile",
	copy_time = "Copy Message Time",
	copy_url = "Copy URL",

	bot_joined = "",
	bot_left = "",

	-- STEAMID gets replaced by the player steamid
	player_connecting = "",
	player_left = "",
}
--PATH addons/[chat] scb-29/lua/scb/settings/tabs/client.lua:
if SCB_LOADED then return end

local vgui = vgui

local ipairs = ipairs

local scb = scb
local SUI = scb.SUI
local language = scb.language

local toggle_convars = {
	{
		title = "show_time",
		convar = "scb_show_timestamps",
	},
	{
		title = "disable_rainbow",
		convar = "scb_disable_rainbow_colors",
		value = "0"
	},
	{
		title = "disable_flashing",
		convar = "scb_disable_flashing_texts",
		value = "0"
	},
	{
		title = "blur_theme",
		convar = "scb_blur_theme",
		value = SUI.current_theme == "Blur" and "1" or "0",
		on_change = function(value)
			SUI.SetTheme(value == "1" and "Blur" or "Dark")
		end
	},
	{
		title = "join_messages",
		convar = "scb_joindisconnect_message",
		value = "1"
	},
	{
		"number",
		title = "scale",
		convar = "scb_scale",
		value = "5",
		min = 1, max = 9,
		load = function(slider, convar)
			slider:GetParent():SetWide(110)

			slider:SetDecimals(0)
			slider:SetMinMax(1, 9)
			slider.Knob:SUI_TDLib()

			local on_mouse_released = function()
				convar:SetInt(slider:GetValue())
			end
			slider:On("OnMouseReleased", on_mouse_released)
			slider.Knob:On("OnMouseReleased", on_mouse_released)

			slider:SetValue(scb.to_new_range(SUI.GetScale(), 0.5, 1.5, 1, 9))
		end,
		on_change = function(value)
			SUI.SetScale(scb.to_new_range(value, 1, 9, 0.5, 1.5))
		end
	},
	{
		"number",
		title = "messages_fade",
		convar = "scb_message_fade_out_time",
		value = "6",
		min = 0, max = 60,
		load = function(slider, convar)
			slider:GetParent():SetWide(160)

			slider:SetDecimals(0)
			slider:SetMinMax(0, 60)

			slider:On("OnValueChanged", function(_, v)
				convar:SetInt(v)
			end)

			slider:SetValue(convar:GetInt())
		end
	},
	{
		"number",
		title = "max_messages",
		convar = "scb_max_messages",
		value = "200",
		min = 100, max = 400,
		load = function(slider, convar)
			slider:GetParent():SetWide(160)

			slider:SetDecimals(0)
			slider:SetMinMax(100, 400)

			slider:On("OnValueChanged", function(_, v)
				convar:SetInt(v)
			end)

			slider:SetValue(convar:GetInt())
		end
	}
}

if scb.config.enable_avatars then
	table.insert(toggle_convars, 1, {
		title = "show_avatars",
		convar = "scb_show_avatars",
	})
end

if not scb.config.enable_custom_join_messages and not scb.config.enable_custom_leave_messages then
	for k, v in ipairs(toggle_convars) do
		if v.convar == "scb_joindisconnect_message" then
			table.remove(toggle_convars, k)
			break
		end
	end
end

for _, v in ipairs(toggle_convars) do
	local convar = CreateClientConVar(v.convar, v.value or "1", true, false, "", v.min or 0, v.max or 1)

	if v.on_change then
		v.on_change(convar:GetString())
		cvars.AddChangeCallback(v.convar, function(_, _, value_new)
			v.on_change(value_new, v.panel)
		end)
	end
end

return {
	title = language.client_title,
	pos = 1,
	check = false,
	func = function(parent)
		local body = parent:Add("SCB.ScrollPanel")
		body:Dock(FILL)
		body:DockMargin(0, 1, 0, 0)

		local add_setting = function(title, pnl)
			local setting = body:Add("SCB.LabelPanel")
			setting:DockMargin(4, 4, 4, 0)
			setting:SetLabel(title)
			setting:SetPanel(pnl)
			return setting
		end

		for _, v in ipairs(toggle_convars) do
			local panel
			if v[1] == "number" then
				panel = vgui.Create("SCB.NumberSlider")

				v.panel = panel.slider
				v.load(panel.slider, v.convar and GetConVar(v.convar))
			else
				panel = vgui.Create("SCB.ToggleButton")
				panel:SetConVar(v.convar)
			end

			add_setting(language[v.title], panel)
		end

		local reset_size = vgui.Create("SCB.Button")
		reset_size:SetText("Reset")
		reset_size:SetSize(70, 24)
		reset_size:On("DoClick", function()
			scb.chatbox:SetSize(480, 220)
		end)
		add_setting(language.reset_size, reset_size)

		local reset_position = vgui.Create("SCB.Button")
		reset_position:SetText("Reset")
		reset_position:SetSize(70, 24)
		reset_position:On("DoClick", function()
			scb.chatbox:SetPos(sui.scale(18), ScrH() - scb.chatbox:GetTall() - sui.scale(170))
			scb.chatbox:OnPosChanged()
		end)
		add_setting(language.reset_position, reset_position)

		local clear_cache = vgui.Create("SCB.Button")
		clear_cache:SetText("Clear")
		clear_cache:SetSize(70, 24)

		clear_cache:On("DoClick", function()
			SUI.ClearImages()
		end)

		add_setting(language.clear_reload, clear_cache)

		return body
	end
}
--PATH addons/[chat] scb-29/lua/scb/vgui/scb_emojis_select.lua:
if SCB_LOADED then return end

local draw = draw

local scb = scb
local sui = sui
local SUI = scb.SUI

local Panel = {}

AccessorFunc(Panel, "m_bTextEntry", "TextEntry")

function Panel:Init()
	self.emojis = {}
end

local line_DoClick = function(s)
	local parent = s:GetParent()
	parent[KEY_ENTER](parent)
end

local emoji_Paint = function(s, w, h)
	local parent = s.parent
	if parent.selected_emoji == s then
		draw.RoundedBox(0, 0, 0, w, h, SUI.GetColor("emoji_select_menu_selected"))
	end
end

local emoji_OnCursorEntered = function(s)
	s.parent.selected_emoji = s.emoji
end

function Panel:AddEmoji(name)
	local line = self:Add("DButton")
	line:Dock(TOP)
	line:SetTall(SUI.ScaleEven(22))
	line:InvalidateParent(true)
	line:SetText("")
	line.Paint = nil
	line.DoClick = line_DoClick
	line.parent = self
	line.OnCursorEntered = emoji_OnCursorEntered

	local emoji = line:Add("SCB.ChatLine")
	emoji:Dock(NODOCK)
	emoji:SetSize(line:GetSize())
	emoji:NewLabel(" ")
	emoji:NewEmoji(name, scb.emojis[name], 20)
	emoji:NewLabel(" :" .. name .. ":")
	emoji:Center()
	emoji:SetMouseInputEnabled(false)

	emoji.parent = self
	emoji.name = name
	emoji.Paint = emoji_Paint

	emoji.i = table.insert(self.emojis, emoji)

	if emoji.i == 1 then
		self.selected_emoji = emoji
	end

	line.emoji = emoji

	self:InvalidateLayout(true)
	self:SizeToChildren(false, true)

	return emoji
end

function Panel:SetStartEnd(start, _end)
	self.start, self._end = start, _end
end

function Panel:Paint(w, h)
	if SUI.GetColor("frame_blur") then
		sui.TDLib.BlurPanel(self)
	end

	draw.RoundedBox(3, 0, 0, w, h, SUI.GetColor("emoji_select_menu"))
end

Panel[KEY_UP] = function(self)
	self.selected_emoji = self.emojis[self.selected_emoji.i - 1] or self.emojis[#self.emojis]
	return true
end

Panel[KEY_DOWN] = function(self)
	self.selected_emoji = self.emojis[self.selected_emoji.i + 1] or self.emojis[1]
	return true
end

Panel[KEY_ENTER] = function(self)
	local text_entry = self:GetTextEntry()
	text_entry:RequestFocus()
	text_entry:AddValue(":" .. self.selected_emoji.name .. ": ", self.start - 1, self._end + 1)

	scb.emoji_set_used(self.selected_emoji.name)
	return true
end
Panel[KEY_TAB] = Panel[KEY_ENTER]

Panel[KEY_ESCAPE] = function(self)
	gui.HideGameUI()
	self:Remove()
end

sui.register("EmojisSelect", Panel, "Panel")
--PATH lua/autorun/serv_statuseffects.lua:
if SERVER then AddCSLuaFile() end

GMSERV = {}
GMSERV.StatusEffects = {
	["heal"] = {
		["string"] = "Healing",
		["function"] =
			function(target, dealer, effect, duration, amount)
				local mult
				if target == dealer then
					mult = 0.25
				else
					mult = 1
				end
				local hpam = amount*mult
				local hpdur = duration
				local hptick = (amount/duration)*mult

				local HealAmount
				for i = 1, hpdur*hptick do
					timer.Simple(i/hptick, function()
						if !target:IsValid() then return end
						local futureheal = ( hpam/hpdur )/hptick

						if (target:GetMaxHealth()*2) - target:Health() >= futureheal then
							HealAmount = futureheal
						else
							HealAmount = ((target:GetMaxHealth()*2) - target:Health())
						end

						target:SetHealth( target:Health() + HealAmount )
					end)
				end

				if effect then
					local ED_Heal = EffectData()
					ED_Heal:SetOrigin( target:GetPos() )
					ED_Heal:SetEntity( target )
					ED_Heal:SetMagnitude( hpam )
					ED_Heal:SetScale( hpdur )
					util.Effect("serv_passive_heal", ED_Heal, true, true)
				end
			end
		},
	["stun"] = {
		["string"] = "Stun",
		["function"] =
			function(target, dealer, effect, duration)
				local function RemoveFrozen(target)
					if target:IsValid() then
						target.SERVStatFrozen = false

						if target:IsPlayer() then
							target:ScreenFade( SCREENFADE.IN, Color( 0, 0, 0, 0 ), 0.4, 0.2 )
							target:Freeze( false )
						elseif target:IsNPC() then
							target:SetCondition( 68 )
							if target:Health() < 1 then
								target:SetNPCState(7)
							end
						end
					end
				end

				if ((target:IsPlayer() and target ~= dealer) or target:IsNPC()) then
					if target.SERVStatFrozen then
						if target:Health() < 1 then
							RemoveFrozen(target)
						end
					else
						target.SERVStatFrozen = true

						if target:IsPlayer() then
							target:ScreenFade( SCREENFADE.OUT, Color( 0, 200, 255, 0 ), 0.2, 2.5 )
							target:Freeze( true ) 
						elseif target:IsNPC() then
							target:SetSchedule( SCHED_NPC_FREEZE )
							target:StopMoving()
						end

						timer.Simple( duration, function()
							RemoveFrozen(target)
						end )
					end

					if effect then
						local ED_Stun = EffectData()
						ED_Stun:SetOrigin( target:GetPos() )
						ED_Stun:SetEntity( target )
						ED_Stun:SetScale( duration )
						util.Effect("SERV_passive_stun", ED_Stun, true, true)
					end
				end
			end
		},
	["poison"] = {
		["string"] = "Poison",
		["function"] =
			function(target, dealer, effect, duration, damage)
				if !(target:IsPlayer() or target:IsNPC()) then return false end
				local tick = damage/duration
				if target:IsPlayer() then
					local playerdead = false
				end
				for i = 1, duration do
					timer.Simple(i-1, function()
						if target:IsPlayer() then
							if !target:Alive() then 
								playerdead = true
							end
							if playerdead then return end
						end
						if !target:IsValid() then return end
						local futdmg = ( damage/duration )
						target:TakeDamage(futdmg, dealer, dealer)
					end)
				end

				if effect then
					local ED_Poison = EffectData()
					ED_Poison:SetOrigin( target:GetPos() )
					ED_Poison:SetEntity( target )
					ED_Poison:SetMagnitude( damage )
					ED_Poison:SetScale( duration )
					util.Effect("SERV_passive_poison", ED_Poison, true, true)
				end

			end
		},
}

function GMSERV:AddStatus(target, dealer, type, a, b, c)
	if target:IsPlayer() or target:IsNPC() then
		GMSERV.StatusEffects[type]["function"](target, dealer, c, a, b)
	end
end
--PATH lua/autorun/sh_addmaterials.lua:
return gluapack()()
--PATH lua/arc9/common/localization/content_base_en.lua:
return gluapack()()
--PATH lua/arc9/common/localization/font_en.lua:
L = {}

/////////////////////////////////////// Font
//////////////////// If a custom font should be used, rename the string. Useful for Pinyin, Kanji, etc.
////////// Do not create a font file if your language does not need it.

L["font"] = "Venryn Sans"
--PATH lua/arc9/common/localization/content_base_de.lua:
L = {}

//////// Folders
-- L["folder.arc9"] = "ARC9"
-- L["folder.arc9.community"] = "Community"

-- L["attachment.sticker"] = "Sticker"

//////// Flat Camo
-- L["camo_arc9_base_flat_od.printname"] = "Olive Drab"
-- L["camo_arc9_base_flat_od.compactname"] = "OD"
-- L["camo_arc9_base_flat_od.description"] = "Standard Olive Drab camouflage."

-- L["camo_arc9_base_flat_deserttan.printname"] = "Desert Tan"
-- L["camo_arc9_base_flat_deserttan.compactname"] = "Tan"
-- L["camo_arc9_base_flat_deserttan.description"] = "Standard Desert Tan camouflage."

-- L["camo_arc9_base_flat_arctic.printname"] = "Arctic White"
-- L["camo_arc9_base_flat_arctic.compactname"] = "Arctic"
-- L["camo_arc9_base_flat_arctic.description"] = "Standard Arctic White camouflage."

-- L["camo_arc9_base_flat_black.printname"] = "Factory Black"
-- L["camo_arc9_base_flat_black.compactname"] = "Black"
-- L["camo_arc9_base_flat_black.description"] = "Standard Factory Issue Black."

-- L["camo_arc9_base_flat_urbangray.printname"] = "Urban Gray"
-- L["camo_arc9_base_flat_urbangray.compactname"] = "Urban"
-- L["camo_arc9_base_flat_urbangray.description"] = "Standard Urban Gray camouflage."

-- L["camo_arc9_base_flat_forestgreen.printname"] = "Forest Green"
-- L["camo_arc9_base_flat_forestgreen.compactname"] = "Forest"
-- L["camo_arc9_base_flat_forestgreen.description"] = "Standard Forest Green camouflage."

-- L["camo_arc9_base_flat_navy.printname"] = "Navy Blue"
-- L["camo_arc9_base_flat_navy.compactname"] = "Navy"
-- L["camo_arc9_base_flat_navy.description"] = "Standard Navy Blue color."

-- L["camo_arc9_base_flat_mountbattenpink.printname"] = "Mountbatten Pink"
-- L["camo_arc9_base_flat_mountbattenpink.compactname"] = "MP"
-- L["camo_arc9_base_flat_mountbattenpink.description"] = "Standard Mountbatten Pink camouflage.\nShockingly effective in desert conditions."

-- L["camo_arc9_base_flat_fde.printname"] = "Flat Dark Earth"
-- L["camo_arc9_base_flat_fde.compactname"] = "FDE"
-- L["camo_arc9_base_flat_fde.description"] = "Standard Flat Dark Earth camouflage."

//////// Flat Colour
-- L["camo_arc9_base_flat_red.printname"] = "Red"
-- L["camo_arc9_base_flat_red.compactname"] = "Red"
-- L["camo_arc9_base_flat_red.description"] = "Basic red color."

-- L["camo_arc9_base_flat_orange.printname"] = "Orange"
-- L["camo_arc9_base_flat_orange.compactname"] = "Orange"
-- L["camo_arc9_base_flat_orange.description"] = "Basic orange color."

-- L["camo_arc9_base_flat_yellow.printname"] = "Yellow"
-- L["camo_arc9_base_flat_yellow.compactname"] = "Yellow"
-- L["camo_arc9_base_flat_yellow.description"] = "Basic yellow color."

-- L["camo_arc9_base_flat_green.printname"] = "Green"
-- L["camo_arc9_base_flat_green.compactname"] = "Green"
-- L["camo_arc9_base_flat_green.description"] = "Basic green color."

-- L["camo_arc9_base_flat_blue.printname"] = "Blue"
-- L["camo_arc9_base_flat_blue.compactname"] = "Blue"
-- L["camo_arc9_base_flat_blue.description"] = "Basic blue color."

-- L["camo_arc9_base_flat_purple.printname"] = "Purple"
-- L["camo_arc9_base_flat_purple.compactname"] = "Purple"
-- L["camo_arc9_base_flat_purple.description"] = "Basic purple color."

-- L["camo_arc9_base_flat_pink.printname"] = "Pink"
-- L["camo_arc9_base_flat_pink.compactname"] = "Pink"
-- L["camo_arc9_base_flat_pink.description"] = "Eye searingly bright pink color."

-- L["camo_arc9_base_flat_arc9orange.printname"] = "ARC9 Orange"
-- L["camo_arc9_base_flat_arc9orange.compactname"] = "ARC9 Orange"
-- L["camo_arc9_base_flat_arc9orange.description"] = "The perfect shade of orange for that cute little ARC9 Logo sticker."

//////// Charms
-- L["charm_gs_killcounter.printname"] = "Kill Counter"
-- L["charm_gs_killcounter.compactname"] = "KILL"
-- L["charm_gs_killcounter.description"] = "Device for tracking your weapon's kill stats."

-- L["charm_gs_clock.printname"] = "Basic Clock"
-- L["charm_gs_clock.compactname"] = "CLOCK"
-- L["charm_gs_clock.description"] = "Device that displays the real-world time."

-- L["charm_gs_sticker.printname"] = "Sticker Panel"
-- L["charm_gs_sticker.compactname"] = "STICKER"
-- L["charm_gs_sticker.description"] = "Device that allows a custom sticker to be applied onto its screen."

//////// Stickers, Base
-- L["sticker_spray.printname"] = "Player Spray"
-- L["sticker_spray.compactname"] = "Spray"
-- L["sticker_spray.description"] = [[Your own spray as a sticker!
-- You will only be able to see your own and not ones from other players.

-- Sticker included in the ARC9 Base.]]

-- L["sticker_arc9.printname"] = "ARC9 Logo (Low Vis.)"
-- L["sticker_arc9.compactname"] = "ARC9"
-- L["sticker_arc9.description"] = [[Dark version of the ARC9 logo.
-- Design by The Villain.

-- Sticker included in the ARC9 Base.]]

-- L["sticker_arc9_lowvis.printname"] = "ARC9 Logo"
-- L["sticker_arc9_lowvis.compactname"] = "ARC9"
-- L["sticker_arc9_lowvis.description"] = [[Here's to you.
-- Design by The Villain.

-- Sticker included in the ARC9 Base.]]

-- L["sticker_a9k.printname"] = "ARCTICTHRON 9.000 WEAPON BASE"
-- L["sticker_a9k.compactname"] = "A9K"
-- L["sticker_a9k.description"] = [[this is what "arc9" actually means

-- Sticker included in the ARC9 Base.]]

-- L["sticker_a9cylo.printname"] = "ARC9 Concept logo by CyloWalker"
-- L["sticker_a9cylo.compactname"] = "A9 Cylo"
-- L["sticker_a9cylo.description"] = [[One of the first concepts for ARC9 logo/icon by CyloWalker (he's cool!)

-- Sticker included in the ARC9 Base.]]

-- L["sticker_sus9.printname"] = "Sus 9"
-- L["sticker_sus9.compactname"] = "Sus 9"
-- L["sticker_sus9.description"] = [[The impostor could be anywhere among us...
-- Design by Darsu.

-- Sticker included in the ARC9 Base.]]

//////// Stickers, Com. Wave 1
-- L["sticker_alien_lean.printname"] = "Legalize Alien Lean"
-- L["sticker_alien_lean.compactname"] = "Alien Lean"
-- L["sticker_alien_lean.description"] = [[Hop down to Agartha with the white boys for a cup of alien lean and... other things.
-- Design by Opt1ca.

-- Sticker included in the ARC9 Base.]]

-- L["sticker_tomatocat.printname"] = "Tomato Cat"
-- L["sticker_tomatocat.compactname"] = "Tomato Cat"
-- L["sticker_tomatocat.description"] = [[Sometimes people ask whether tomatoes are fruits or vegetables... This one might be a tougher question.
-- Design by Ender2Point0.

-- Sticker included in the ARC9 Base.]]

-- L["sticker_actionbird.printname"] = "Action Bird"
-- L["sticker_actionbird.compactname"] = "Action Bird"
-- L["sticker_actionbird.description"] = [[This is what Arctic looks like in real life.
-- Design by CyloWalker.

-- Sticker included in the ARC9 Base.]]

-- L["sticker_warcrimes.printname"] = "War Crimes"
-- L["sticker_warcrimes.compactname"] = "War Crimes"
-- L["sticker_warcrimes.description"] = [[You're already doing them, so why not shout it out loud? Who's gonna stop you, the UN?
-- Design by Rimuchii. Made using Project Sekai sticker base.

-- Sticker included in the ARC9 Base.]]

-- L["sticker_sillycat.printname"] = "Silly Cat"
-- L["sticker_sillycat.compactname"] = "Silly Cat"
-- L["sticker_sillycat.description"] = [[imsillyimsillyimsillyimsillyimsillyimsillyimsillyimsilly
-- Design by Stan_Jacobs.

-- Sticker included in the ARC9 Base.]]

-- L["sticker_muertosskull.printname"] = "Dia De Los Muertos Calavera"
-- L["sticker_muertosskull.compactname"] = "Los Muertos"
-- L["sticker_muertosskull.description"] = [["this should be my final version i think, unless anyone gives me suggestions to change it, the name: "Dia de los muertos calavera" the description: i cant think of one, something about day of the dead skull mexico blah blah blah"
-- Design by rooneyviz.

-- Sticker included in the ARC9 Base.]]

-- L["sticker_bandaid.printname"] = "Band-Aid"
-- L["sticker_bandaid.compactname"] = "Band-Aid"
-- L["sticker_bandaid.description"] = [[Put it on your boo-boo and kiss it all better.
-- Design by Itzal.

-- Sticker included in the ARC9 Base.]]

-- L["sticker_peacedove.printname"] = "Peace Through Superior Firepower"
-- L["sticker_peacedove.compactname"] = "PTSF"
-- L["sticker_peacedove.description"] = [[The dove brings peace, but the gun brings peace through superior firepower.
-- Design by Xipil.

-- Sticker included in the ARC9 Base.]]

-- L["sticker_borntomodify.printname"] = "Born To Modify"
-- L["sticker_borntomodify.compactname"] = "BTM"
-- L["sticker_borntomodify.description"] = [[Another sight - another scope - a grenade launcher, here and there...
-- Design by Duck.

-- Sticker included in the ARC9 Base.]]

-- L["sticker_cad.printname"] = "cad"
-- L["sticker_cad.compactname"] = "cad"
-- L["sticker_cad.description"] = [[cad
-- Design by Opt1ca.

-- Sticker included in the ARC9 Base.]]

-- L["sticker_fumo.printname"] = "Fumo"
-- L["sticker_fumo.compactname"] = "Fumo"
-- L["sticker_fumo.description"] = [[D-don't look at me like that, raifu-kun...
-- Design by Itzal.

-- Sticker included in the ARC9 Base.]]

-- L["sticker_hotlead.printname"] = "Hot Lead"
-- L["sticker_hotlead.compactname"] = "Hot Lead"
-- L["sticker_hotlead.description"] = [[Careful! It's hot!
-- Design by Arqu.

-- Sticker included in the ARC9 Base.]]

-- L["sticker_steamhappy.printname"] = ":steamhappy:"
-- L["sticker_steamhappy.compactname"] = ":steamhappy:"
-- L["sticker_steamhappy.description"] = [[Happy about it
-- Design from Steam.

-- Sticker included in the ARC9 Base.]]

-- L["sticker_amidstus.printname"] = "Amidstus"
-- L["sticker_amidstus.compactname"] = "Amidstus"
-- L["sticker_amidstus.description"] = [[Why settle for the original when you could have a cheap knockoff?!
-- Design from Optica.

-- Sticker included in the ARC9 Base.]]

-- L["sticker_arcglory.printname"] = "Glory!"
-- L["sticker_arcglory.compactname"] = "Glory!"
-- L["sticker_arcglory.description"] = [[Took nine brain cells to scribble this
-- Design from Optica.

-- Sticker included in the ARC9 Base.]]

-- L["sticker_wp.printname"] = "World Peace!"
-- L["sticker_wp.compactname"] = "World Peace!"
-- L["sticker_wp.description"] = [[A delusion!
-- Design from Fidget.

-- Sticker included in the ARC9 Base.]]

-- L["sticker_tonkr.printname"] = "Send It"
-- L["sticker_tonkr.compactname"] = "Send It"
-- L["sticker_tonkr.description"] = [[Yeah, it's that heavy. Yeah, it's that powerful.
-- Design from CyloWalker.

-- Sticker included in the ARC9 Base.]]

-- L["sticker_s6amblem.printname"] = "Section 6"
-- L["sticker_s6amblem.compactname"] = "Section 6"
-- L["sticker_s6amblem.description"] = [[Reach for the stars. Forward to Glory!
-- Design from CyloWalker.

-- Sticker included in the ARC9 Base.]]

-- L["sticker_babies.printname"] = "Baby Hazard"
-- L["sticker_babies.compactname"] = "Baby Hazard"
-- L["sticker_babies.description"] = [[Children ages 0-3 should be kept away from this.. firearm.
-- Design from Itzal.

-- Sticker included in the ARC9 Base.]]

-- L["sticker_drawberf.printname"] = "Berf"
-- L["sticker_drawberf.compactname"] = "Berf"
-- L["sticker_drawberf.description"] = [[Draw Berf.
-- Design by The Villain.

-- Sticker included in the ARC9 Base.]]

-- L["sticker_arcbird.printname"] = "Arc Bird"
-- L["sticker_arcbird.compactname"] = "Arc Bird"
-- L["sticker_arcbird.description"] = [[Arc Bird.
-- Design by Nori/Chewable.

-- Sticker included in the ARC9 Base.]]

--PATH lua/arc9/common/localization/base_ru.lua:
L = {}

/////////////////////////////////////// Font
////////////////////// See "font_en" file

/////////////////////////////////////// General
////////////////////// Units of measurement
L["unit.second"] = ""
L["unit.meter"] = ""
L["unit.millimeter"] = ""
L["unit.meterpersecond"] = "/"
L["unit.hammerunit"] = "HU"
L["unit.decibel"] = ""
L["unit.rpm"] = "RPM"
L["unit.moa"] = "MOA"
L["unit.dmg"] = "DMG"
L["unit.projectiles"] = "PROJ"

L["unit.inch"] = "in"
L["unit.foot"] = "ft"
L["unit.footpersecond"] = "ft/s"
L["unit.yard"] = "yd"

////////////////////// Ammo types
L["ammo.pistol"] = ". "
L["ammo.357"] = " "
L["ammo.smg1"] = ". "
L["ammo.ar2"] = ". "
L["ammo.buckshot"] = ". "
L["ammo.sniperpenetratedround"] = ". "
L["ammo.smg1_grenade"] = ""
L["ammo.xbowbolt"] = ". "
L["ammo.rpg_round"] = ""
L["ammo.grenade"] = ""
L["ammo.slam"] = "SLAM"
L["ammo.alyxgun"] = "Alyx Gun "

/////////////////////////////////////// HUD
L["hud.version"] = "ARCTIC SYSTEMS HUD v"
L["hud.jammed"] = "!"
L["hud.therm_deco"] = ". "

L["hud.firemode.single"] = "."
L["hud.firemode.burst"] = ""
L["hud.firemode.auto"] = "."
L["hud.firemode.safe"] = "."

L["hud.hint.bash"] = ""
L["hud.hint.bipod"] = ""
L["hud.hint.breath"] = " "
L["hud.hint.customize"] = ""
L["hud.hint.cycle"] = " "
L["hud.hint.firemode"] = "  "
L["hud.hint.inspect"] = ""
L["hud.hint.lean"] = ""
L["hud.hint.peek"] = ""
L["hud.hint.reload"] = "!"
L["hud.hint.safe"] = ""
L["hud.hint.switchsights"] = " "
L["hud.hint.toggleatts"] = ". "
L["hud.hint.ubgl"] = ". "
-- L["hud.hint.unjam"] = "Unjam"
L["hud.hint.zoom"] = " "
L["hud.hint.quicknade"] = " "

L["hud.hint.lowammo"] = " "
L["hud.hint.noammo"] = " "

L["hud.error.missingbind"] = "   %s"
L["hud.error.missingbind_zoom"] = " \"\"  !"
L["hud.error.missingbind_context"] = " \"Open Context Menu\"  !"

/////////////////////////////////////// Customization menu
L["customize.panel.customize"] = ""
L["customize.panel.personalize"] = ""
L["customize.panel.stats"] = "- & "
L["customize.panel.trivia"] = ""
L["customize.panel.inspect"] = ""
L["customize.panel.presets"] = ""

L["customize.stats.aimtime"] = " ."
L["customize.stats.ammo"] = " "
L["customize.stats.armorpiercing"] = ""
L["customize.stats.burstdelay"] = " "
L["customize.stats.capacity"] = ""
L["customize.stats.cyclic"] = ""
L["customize.stats.explosive"] = " "
L["customize.stats.firemodes"] = ""
L["customize.stats.firepower"] = ". "
L["customize.stats.freeaim"] = " . "
L["customize.stats.muzzlevelocity"] = " "
L["customize.stats.noise"] = ""
L["customize.stats.penetration"] = ""
L["customize.stats.precision"] = ""
L["customize.stats.range"] = ""
L["customize.stats.ricochet"] = " "
L["customize.stats.rof"] = ""
L["customize.stats.speed"] = " "
L["customize.stats.sprinttofire"] = " "
L["customize.stats.supplylimit"] = " "
L["customize.stats.sway"] = ""
L["customize.stats.triggerdelay"] = " "

L["customize.hint.attach"] = ""
L["customize.hint.controller"] = "  ."
L["customize.hint.cursor"] = ""
L["customize.hint.cycle"] = ". "
L["customize.hint.delete"] = ""
L["customize.hint.deselect"] = ". "
L["customize.hint.expand"] = ""
L["customize.hint.export"] = ""
L["customize.hint.favorite"] = "  "
L["customize.hint.import"] = ""
L["customize.hint.install"] = ""
L["customize.hint.last"] = ". "
L["customize.hint.lastmode"] = ". "
L["customize.hint.nextmode"] = ". "
L["customize.hint.open"] = ""
L["customize.hint.pan"] = ""
L["customize.hint.quicksave"] = " "
L["customize.hint.randomize"] = " "
L["customize.hint.recalculate"] = ""
L["customize.hint.recenter"] = ""
L["customize.hint.rotate"] = ""
L["customize.hint.save"] = ""
L["customize.hint.select"] = ""
L["customize.hint.unattach"] = ""
L["customize.hint.unfavorite"] = "  "
L["customize.hint.zoom"] = ""

L["customize.trivia.description"] = ""

L["customize.stats.explain.firepower"] = " ."
L["customize.stats.explain.rof"] = " ."
L["customize.stats.explain.cyclic"] = "       ."
L["customize.stats.explain.capacity"] = "        ."
L["customize.stats.explain.range"] = "    ."
L["customize.stats.explain.precision"] = " .     (MoA)."
L["customize.stats.explain.muzzlevelocity"] = "  ."
L["customize.stats.explain.ammo"] = "  ."
L["customize.stats.explain.penetration"] = "     ."
L["customize.stats.explain.ricochet"] = "   ."
L["customize.stats.explain.armorpiercing"] = "     ."
L["customize.stats.explain.explosive"] = " ."
L["customize.stats.explain.speed"] = "       ."
L["customize.stats.explain.aimtime"] = "    ."
L["customize.stats.explain.sprinttofire"] = "        ."
L["customize.stats.explain.firemodes"] = "     ."
L["customize.stats.explain.burstdelay"] = "  ."
L["customize.stats.explain.triggerdelay"] = "      ."
L["customize.stats.explain.noise"] = "   ."
L["customize.stats.explain.sway"] = "    ."
L["customize.stats.explain.freeaim"] = "   .  - ."
L["customize.stats.explain.supplylimit"] = "       ARC9."

L["customize.bench.dummy"] = " "
L["customize.bench.effect"] = "  "
L["customize.bench.ballistics"] = "  "
L["customize.bench.precision"] = " "

L["folder.back"] = ""
L["folder.deselect"] = ""
L["folder.favorites"] = " "
L["folder.select"] = ""

////////////////////// Automatic stats
L["autostat.enable.pre"] = "."
L["autostat.disable.pre"] = "."
L["autostat.enable.post"] = ""
L["autostat.disable.post"] = ""

L["autostat.aimdownsightstime"] = " "
L["autostat.alwaysphysbullet"] = " "
L["autostat.ammopershot"] = "  "
L["autostat.armdamage"] = "  "
L["autostat.armorpiercing"] = ""
L["autostat.autoburst"] = " "
L["autostat.autoreload"] = ""
L["autostat.bash"] = ""
L["autostat.bashdamage"] = " "
L["autostat.bashlungerange"] = "  "
L["autostat.bashrange"] = " "
L["autostat.bashspeed"] = " "
L["autostat.bipod"] = ""
L["autostat.bottomlessclip"] = " "
L["autostat.breathholdtime"] = "  "
L["autostat.bulletguidance"] = ""
L["autostat.bulletguidanceamount"] = " "
L["autostat.canfireunderwater"] = " "
L["autostat.cantpeek"] = " "
L["autostat.chambersize"] = ""
L["autostat.chestdamage"] = "  "
L["autostat.clipsize"] = " "
L["autostat.cycletime"] = " "
L["autostat.damagemax"] = " "
L["autostat.damagemin"] = "  "
L["autostat.damagerand"] = " "
L["autostat.deploytime"] = " "
L["autostat.distance"] = " "
L["autostat.entitymuzzlevelocity"] = " "
L["autostat.explosiondamage"] = " "
L["autostat.explosionradius"] = " "
L["autostat.fixtime"] = "  "
L["autostat.freeaimradius"] = "  "
L["autostat.headshotdamage"] = "  "
L["autostat.heatcapacity"] = ""
L["autostat.heatdissipation"] = " "
L["autostat.heatpershot"] = "  "
L["autostat.hybridreload"] = " "
L["autostat.infiniteammo"] = " "
L["autostat.legdamage"] = "  "
L["autostat.malfunction"] = ""
L["autostat.malfunctionmeanshotstofail"] = " "
L["autostat.malfunctionwait"] = "  "
L["autostat.manualaction"] = " "
L["autostat.manualactionchamber"] = "  "
L["autostat.neverphysbullet"] = " "
L["autostat.noflash"] = "  "
L["autostat.num"] = "- "
L["autostat.overheat"] = ""
L["autostat.overheattime"] = " "
L["autostat.pelletspread"] = "  "
L["autostat.penetration"] = " "
L["autostat.penetrationdelta"] = "  "
L["autostat.physbulletdrag"] = " "
L["autostat.physbulletgravity"] = " "
L["autostat.physbulletmuzzlevelocity"] = " "
L["autostat.postburstdelay"] = "  "
L["autostat.pushbackforce"] = ""
L["autostat.rangemax"] = " "
L["autostat.rangemin"] = " "
L["autostat.recoil"] = ""
L["autostat.recoilautocontrol"] = " "
L["autostat.recoildissipationrate"] = "  "
L["autostat.recoilkick"] = " "
L["autostat.recoilmodifiercap"] = " "
L["autostat.recoilpatterndrift"] = " "
L["autostat.recoilpershot"] = ".   "
L["autostat.recoilrandomside"] = ".  "
L["autostat.recoilrandomup"] = ".  "
L["autostat.recoilresettime"] = "   "
L["autostat.recoilside"] = " "
L["autostat.recoilup"] = " "
L["autostat.reloadtime"] = " "
L["autostat.ricochetanglemax"] = " "
L["autostat.ricochetchance"] = " "
L["autostat.rpm"] = ""
L["autostat.runawayburst"] = "  "
L["autostat.secondarysupplylimit"] = "  "
L["autostat.shootvolume"] = " "
L["autostat.shootwhilesprint"] = "   "
L["autostat.shotgunreload"] = "  "
L["autostat.speed"] = " "
L["autostat.spread"] = ""
L["autostat.sprinttofiretime"] = "  "
L["autostat.stomachdamage"] = "  "
L["autostat.supplylimit"] = " "
L["autostat.sway"] = " "
L["autostat.triggerdelay"] = " "
L["autostat.triggerdelaytime"] = "   "
L["autostat.visualrecoil"] = " "
L["autostat.visualrecoilpunch"] = ".  "
L["autostat.visualrecoilroll"] = ".  "
L["autostat.visualrecoilside"] = ".  "
L["autostat.visualrecoilup"] = ".  "

L["autostat.secondary._beforephrase"] = false
-- if true, secondary stat phrasing comes before the stat
L["autostat.secondary._divider"] = " "
-- space between the secondary phrase from the stat phrase. set true to use empty string

-- L["autostat.secondary.blindfire"] = "while Blind-Firing"
L["autostat.secondary.bipod"] = " "
L["autostat.secondary.crouch"] = " "
L["autostat.secondary.empty"] = " "
L["autostat.secondary.evenreload"] = " . "
L["autostat.secondary.evenshot"] = "  "
L["autostat.secondary.first"] = " "
L["autostat.secondary.firstshot"] = " "
L["autostat.secondary.heated"] = " "
L["autostat.secondary.hipfire"] = " "
L["autostat.secondary.hot"] = " "
L["autostat.secondary.last"] = " "
L["autostat.secondary.lastshot"] = " "
L["autostat.secondary.midair"] = " "
L["autostat.secondary.move"] = " "
L["autostat.secondary.oddreload"] = " . "
L["autostat.secondary.oddshot"] = "  "
L["autostat.secondary.recoil"] = " " --"With Each Shot"
L["autostat.secondary.shooting"] = " "
L["autostat.secondary.sighted"] = " "
L["autostat.secondary.sights"] = " "
L["autostat.secondary.silenced"] = " "
L["autostat.secondary.sprint"] = "  "
L["autostat.secondary.true"] = " . TrueNames"
L["autostat.secondary.ubgl"] = " "

////////////////////// Blacklist menu
L["blacklist.title"] = "ARC9   "
L["blacklist.desc"] = "    "
L["blacklist.blisted"] = " "
L["blacklist.all"] = ""
L["blacklist.id"] = "ID"
L["blacklist.name"] = ""
L["blacklist.filter"] = ""

////////////////////// Incompatible addons
L["incompatible.title"] = "ARC9:  "
L["incompatible.line1"] = "          ARC9."
L["incompatible.line2"] = " ,  -    !"
L["incompatible.confirm"] = ""
L["incompatible.wait"] = " {time}"
L["incompatible.never"] = "  "
L["incompatible.never.hover"] = "? ,     ."
L["incompatible.never.confirm"] = "      .  -   -    ,     ."

////////////////////// Warning panel
L["badconf.title"] = "ARC9:   "
L["badconf.line1"] = "     ."
L["badconf.line2"] = "       ."
L["badconf.confirm"] = ""
L["badconf.wait"] = " {time}"

L["badconf.directx.title"] = "  DirectX"
L["badconf.directx.desc"] = "      DirectX 8  8.1.  GMod   ,            . (dx9   21  !)"
L["badconf.directx.solution"] = ":    Garry's Mod's    \"-dxlevel 95\".    \"-dxlevel 70/80/85\"    ."

L["badconf.tickrate.title"] = "   "
L["badconf.tickrate.desc"] = "        . ARC9       20   ( 66+)."
L["badconf.tickrate.solution"] = ":    ,  \"-tickrate 33\"    ."

L["badconf.matbumpmap.title"] = "mat_bumpmap "
L["badconf.matbumpmap.desc"] = "    ,          ."
L["badconf.matbumpmap.solution"] = ":    \"mat_bumpmap 1\".     FPS       \"autoexec.cfg\"  mat_bumpmap 0."

L["badconf.addons.title"] = "  !  lua  "
L["badconf.addons.desc"] = "        Lua . ARC9   ,    ."
L["badconf.addons.solution"] = ":         (   , JMOD,    ..)."

L["badconf.warning"] = "!   -    ."
L["badconf.warning.desc"] = " FPS  .     .\n\n       ."

L["badconf.x64.title"] = "  32- GMod "
L["badconf.x64.desc"] = [[      32- ,    .

:    Garry's Mod's   " "     "x86-64 - Chromium + 64-bit binaries".

 "gmod x64"      .]]

L["badconf.multicore.title"] = "   "
L["badconf.multicore.desc"] = [[     ,         autoexec.cfg.

 "gmod multicore"      .

    :
gmod_mcore_test 1
mat_queue_mode 2
cl_threaded_bone_setup 1
cl_threaded_client_leaf_system 1
r_threaded_client_shadow_manager 1
r_threaded_renderables 1]]

////////////////////// Presets
L["customize.presets.atts"] = " "
L["customize.presets.back"] = ""
L["customize.presets.cancel"] = ""
L["customize.presets.code"] = "  (   )"
L["customize.presets.default"] = ""
L["customize.presets.default.long"] = " "
L["customize.presets.dumb"] = " ?"
L["customize.presets.import"] = ""
L["customize.presets.invalid"] = " !"
L["customize.presets.new"] = "  "
L["customize.presets.paste"] = "  "
L["customize.presets.random"] = ""
L["customize.presets.save"] = ""
L["customize.presets.unnamed"] = " "

L["customize.presets.deldef"] = "     \"{name}\" ?"
L["customize.presets.deldef2"] = "  ,        ."
L["customize.presets.yes"] = ""

////////////////////// Tips
L["tips.arc-9"] = "  ARC9,  ARC-9   Arc9."
L["tips.blacklist"] = "      !       ARC9  ."
L["tips.bugs"] = "       issue  ."
L["tips.custombinds"] = "     .   +arc9_     ."
L["tips.cyberdemon"] = "   -    ."
L["tips.description"] = "         ."
L["tips.development"] = "    ARC9?       ."
L["tips.discord"] = "   !        (    )."
L["tips.external"] = "   ARC9  ,    !"
L["tips.hints"] = "  HUD     ."
L["tips.lean"] = "   ,    +alt1  +alt2."
L["tips.love"] = "     -  ."
L["tips.m9k"] = " M9K!."
L["tips.official"] = " ARC9   . .        ( )."
L["tips.presets"] = "          !"
L["tips.settings"] = "    ,       ARC9.     !"
L["tips.tips"] = "   .       ."
L["tips.tolerance"] = "            .       ."

////////////////////// Other
L["atts.favourites"] = ""
L["atts.filter"] = ""

/////////////////////////////////////// Settings menu
-- Use this method to localize convars in settings menu:
-- settings.convar.title = "Convar Title"
-- settings.convar.desc = "Convar Description"

L["settings.title"] = " ARC9"
L["settings.desc"] = ""

L["settings.default_convar"] = "  "
L["settings.convar_server"] = " "
L["settings.convar_client"] = " "

////////////////////// General
L["settings.tabname.general"] = ""

L["settings.general.client"] = ""
L["settings.language_id.title"] = ""
L["settings.language_id.desc"] = "  ARC9."
L["settings.truenames.title"] = "  "
L["settings.truenames.desc"] = "         . (     )\n\n  ."
L["settings.resetsettings.cl.title"] = "  "

L["settings.general.server"] = ""
L["settings.truenames_default.title"] = ".   ."
L["settings.truenames_default.desc"] = "      .     \" \"     ."
L["settings.truenames_enforced.title"] = "  "
L["settings.truenames_enforced.desc"] = "       ."

L["settings.resetsettings.sv.title"] = "  "

L["settings.reset"] = "!"

////////////////////// Performance
L["settings.tabname.performance"] = ""

L["settings.performance.important"] = ""
L["settings.cheapscopes.title"] = " "
L["settings.cheapscopes.desc"] = "        ,    .         ."
L["settings.tpik.title"] = " TPIK"
L["settings.tpik.desc"] = "TPIK (    )            .\n\n       ."
L["settings.allflash.title"] = "   "
L["settings.allflash.desc"] = "      .\n\n    ."

L["settings.performance.blur.title"] = ""
L["settings.cust_blur.title"] = " "
L["settings.cust_blur.desc"] = "    ."
L["settings.fx_reloadblur.title"] = "  "
L["settings.fx_reloadblur.desc"] = "    ."
L["settings.fx_animblur.title"] = "  "
L["settings.fx_animblur.desc"] = "        ."
L["settings.fx_rtblur.title"] = " "
L["settings.fx_rtblur.desc"] = "     ."
L["settings.fx_adsblur.title"] = " "
L["settings.fx_adsblur.desc"] = "      ."
L["settings.fx_rtvm.title"] = "   "
L["settings.fx_rtvm.desc"] = "!   !\n      RT .   \" \".\n  ."
L["settings.fx_rtblur.title2"] = "  "

L["settings.performance.shelleject.title"] = ""
L["settings.eject_fx.title"] = " "
L["settings.eject_fx.desc"] = "       . ( )"
L["settings.eject_time.title"] = ". "
L["settings.eject_time.desc"] = "   .   ."

L["settings.performance.fx.title"] = ""
L["settings.muzzle_light.title"] = ".   "
L["settings.muzzle_light.desc"] = "     ."
L["settings.muzzle_others.title"] = "    "
L["settings.muzzle_others.desc"] = "          ."

////////////////////// Optics
L["settings.tabname.optics"] = ""

L["settings.optics.control"] = ""
L["settings.optics.sensmult.title"] = "  "
L["settings.optics.sensmult.desc"] = "    \n   -   .\n          ."
L["settings.optics.compensate_sens.title"] = " "
L["settings.optics.compensate_sens.desc"] = "     ."
L["settings.optics.toggleads.title"] = "  "
L["settings.optics.toggleads.desc"] = "       ."

-- L["settings.optics.dtap_sights.title"] = "Double-Tap to Switch Sights"
-- L["settings.optics.dtap_sights.desc"] = "Allows double-tapping the USE key to switch sights."

L["settings.optics.color"] = " "
L["settings.optics.reflex.title"] = " "
L["settings.optics.reflex.desc"] = "   /  .\n\n     ."
L["settings.optics.scope.title"] = ""
L["settings.optics.scope.desc"] = "    .\n\n     ."

////////////////////// Crosshair
L["settings.tabname.crosshair"] = ""

L["settings.crosshair.crosshair"] = ""
L["settings.crosshair.cross_enable.title"] = " "
L["settings.crosshair.cross_enable.desc"] = " .    ."
L["settings.crosshair.cross.title"] = ""
L["settings.crosshair.cross.desc"] = " ."
L["settings.crosshair.cross_size_mult.title"] = ""
L["settings.crosshair.cross_size_mult.desc"] = "  ."
L["settings.crosshair.cross_size_dot.title"] = " "
L["settings.crosshair.cross_size_dot.desc"] = "   ."
L["settings.crosshair.cross_size_prong.title"] = " "
L["settings.crosshair.cross_size_prong.desc"] = "    ."
L["settings.crosshair.crosshair_static.title"] = ""
L["settings.crosshair.crosshair_static.desc"] = "   ,     ."
L["settings.crosshair.crosshair_force.title"] = " "
L["settings.crosshair.crosshair_force.desc"] = "         .\n\n  ."
L["settings.crosshair.crosshair_target.title"] = "   "
L["settings.crosshair.crosshair_target.desc"] = "      .\n    - ( )"
L["settings.crosshair.crosshair_peeking.title"] = "  "
L["settings.crosshair.crosshair_peeking.desc"] = "     - ."

////////////////////// Customization
L["settings.tabname.hud_cust"] = ""

L["settings.hud_cust.hud"] = "HUD"
L["settings.hud_cust.hud_scale.title"] = ""
L["settings.hud_cust.hud_scale.desc"] = "   ARC9."
L["settings.hud_cust.hud_deadzonex.title"] = ".  "
L["settings.hud_cust.hud_deadzonex.desc"] = " \" \"     HUD .\n   ."
L["settings.hud_cust.hud_color.title"] = " "
L["settings.hud_cust.hud_color.desc"] = "  , ."
L["settings.hud_cust.hud_holiday.title"] = " "
L["settings.hud_cust.hud_holiday.desc"] = "      () .\n   ."
L["settings.hud_cust.hud_darkmode.title"] = " "
L["settings.hud_cust.hud_darkmode.desc"] = "          ."
L["settings.hud_cust.cust_light.title"] = " "
L["settings.hud_cust.cust_light.desc"] = "     .\n\n  ,      ."
L["settings.hud_cust.cust_light_brightness.title"] = " "
L["settings.hud_cust.cust_light_brightness.desc"] = "  .\n\n    !"

L["settings.hud_cust.customization"] = ""
L["settings.hud_cust.cust_hints.title"] = ""
L["settings.hud_cust.cust_hints.desc"] = "    ."
L["settings.hud_cust.cust_tips.title"] = ""
L["settings.hud_cust.cust_tips.desc"] = "    ."
L["settings.hud_cust.cust_exit_reset_sel.title"] = "   "
L["settings.hud_cust.cust_exit_reset_sel.desc"] = "        ."
-- L["settings.hud_cust.imperial.title"] = "Imperial Measurement"
-- L["settings.hud_cust.imperial.desc"] = "Replaces various measurement systems to their Imperial variants.\nOnly affects the \"Stats & Ballistics\" customization screen."

////////////////////// Game HUD
L["settings.tabname.hud_game"] = " HUD"

L["settings.hud_game.lcd"] = "LCD "
L["settings.hud_game.hud_arc9.title"] = " HUD"
L["settings.hud_game.hud_arc9.desc"] = " HUD  ARC9 ."
L["settings.hud_game.hud_always.title"] = "  "
L["settings.hud_game.hud_always.desc"] = "  HUD   ."
L["settings.hud_game.hud_compact.title"] = " "
L["settings.hud_game.hud_compact.desc"] = "    HUD."
L["settings.hud_game.hud_nohints.title"] = " "
L["settings.hud_game.hud_nohints.desc"] = "  .      3D ,   2D."
L["settings.hud_game.hud_keephints.title"] = ""
L["settings.hud_game.hud_keephints.desc"] = "     ARC9  ."
L["settings.hud_game.hud_force_disable.title"] = "  HUD"
L["settings.hud_game.hud_force_disable.desc"] = "       .    ."

L["settings.hud_game.killfeed"] = ""
L["settings.hud_game.killfeed_enable.title"] = "  "
L["settings.hud_game.killfeed_enable.desc"] = "   ARC9 ."
L["settings.hud_game.killfeed_dynamic.title"] = " "
L["settings.hud_game.killfeed_dynamic.desc"] = "        .\n\n,     0.1 ."
L["settings.hud_game.killfeed_colour.title"] = " "
L["settings.hud_game.killfeed_colour.desc"] = "        (  )."

L["settings.hud_game.breath"] = " "
L["settings.hud_game.breath_hud.title"] = ""
L["settings.hud_game.breath_hud.desc"] = ",          ."
L["settings.hud_game.breath_pp.title"] = "-"
L["settings.hud_game.breath_pp.desc"] = "       ."
L["settings.hud_game.breath_sfx.title"] = ""
L["settings.hud_game.breath_sfx.desc"] = "      ."

L["settings.hud_game.centerhint"] = "   "
L["settings.hud_game.centerhint_reload.title"] = ""
-- L["settings.hud_game.centerhint_reload.desc"] = "Display a reload tip when low on ammunition."
L["settings.hud_game.centerhint_reload_percent.title"] = " "
-- L["settings.hud_game.centerhint_reload_percent.desc"] = "Display the reload tip when the current magazine is at this percentage value."
L["settings.hud_game.centerhint_bipod.title"] = ""
L["settings.hud_game.centerhint_bipod.desc"] = "       ."
L["settings.hud_game.centerhint_jammed.title"] = ""
-- L["settings.hud_game.centerhint_jammed.desc"] = "Display a tip when your weapon is jammed."

L["settings.hud_game.centerhint_firemode.title"] = " "
-- L["settings.hud_game.centerhint_firemode.desc"] = "Display a tip when you swap firing mode or toggle your safety."
-- L["settings.hud_game.centerhint_firemode_time.title"] = "Display Firemode Time"
-- L["settings.hud_game.centerhint_firemode_time.desc"] = "How long the firing mode should be displayed."

L["settings.hud_game.centerhint_overheat.title"] = ""
-- L["settings.hud_game.centerhint_overheat.desc"] = "Displays an overlayed tip showing how close the weapon is to overheating.\n\nNot displayed if ARC9 HUD is enabled or the weapon does not support overheat."

L["settings.hud_game.hud_glyph"] = " "

L["settings.hud_game.hud_glyph_type_hud.title"] = "HUD"
L["settings.hud_game.hud_glyph_type_hud.desc"] = "      .\n   ."

L["settings.hud_game.hud_glyph_type_cust.title"] = " "
L["settings.hud_game.hud_glyph_type_cust.desc"] = "C      .\n     ."

L["settings.hud_game.hud_glyph_light"] = " "
L["settings.hud_game.hud_glyph_dark"] = " "
L["settings.hud_game.hud_glyph_knockout"] = "Knockout "

////////////////////// NPCs
L["settings.tabname.npc"] = "NPC"

L["settings.npc.weapons"] = " NPC"
L["settings.npc.npc_equality.title"] = " "
L["settings.npc.npc_equality.desc"] = "NPC         .\n\n  ."
L["settings.npc.npc_spread.title"] = "  NPC"
L["settings.npc.npc_spread.desc"] = "   ARC9   NPC."
L["settings.npc.npc_atts.title"] = "  "
L["settings.npc.npc_atts.desc"] = "   ARC9      .\n\n  ."
L["settings.npc.npc_autoreplace.title"] = "   NPC"
L["settings.npc.npc_autoreplace.desc"] = "   NPC  ARC9 .\n\n  ."
L["settings.npc.replace_spawned.title"] = "   "
L["settings.npc.replace_spawned.desc"] = "     HL2   ARC9 .\n\n  ."
L["settings.npc.npc_give_weapons.title"] = "   "
L["settings.npc.npc_give_weapons.desc"] = "     NPC     .\n\n  ."

////////////////////// Gameplay
L["settings.tabname.gameplay"] = ""

L["settings.gameplay.controls"] = ""
L["settings.gameplay.toggleads.title"] = "  "
L["settings.gameplay.toggleads.desc"] = "       ."
L["settings.gameplay.autolean.title"] = ""
L["settings.gameplay.autolean.desc"] = "         ."
L["settings.gameplay.autoreload.title"] = ""
L["settings.gameplay.autoreload.desc"] = "  ARC9   ."
L["settings.gameplay.togglelean.title"] = "  "
L["settings.gameplay.togglelean.desc"] = "       ."
L["settings.gameplay.togglepeek.title"] = "  "
L["settings.gameplay.togglepeek.desc"] = "       ."
L["settings.gameplay.togglepeek_reset.title"] = "   ."
L["settings.gameplay.togglepeek_reset.desc"] = "(     )\n       ."
L["settings.gameplay.togglebreath.title"] = "   "
L["settings.gameplay.togglebreath.desc"] = "        ."

L["settings.gameplay.mechanics"] = " "
L["settings.gameplay.infinite_ammo.title"] = " "
L["settings.gameplay.infinite_ammo.desc"] = "    .\n\n  ."
L["settings.gameplay.realrecoil.title"] = " "
L["settings.gameplay.realrecoil.desc"] = "     ()       ,   .       .\n\n  ."
L["settings.gameplay.lean.title"] = ""
L["settings.gameplay.lean.desc"] = "      +alt1  +alt2,    ( ).\n\n  ."
L["settings.gameplay.mod_sway.title"] = " "
L["settings.gameplay.mod_sway.desc"] = "          (   ).\n\n  ."
L["settings.gameplay.mod_freeaim.title"] = " "
L["settings.gameplay.mod_freeaim.desc"] = "    ,      (Free aim).\n\n  ."
L["settings.gameplay.mod_bodydamagecancel.title"] = ".    "
L["settings.gameplay.mod_bodydamagecancel.desc"] = "     .              .\n\n  ."
L["settings.gameplay.breath_slowmo.title"] = "-   "
L["settings.gameplay.breath_slowmo.desc"] = "     .\n\n   ."
L["settings.gameplay.manualbolt.title"] = " "
L["settings.gameplay.manualbolt.desc"] = "       ,      R. \n\n   FA:S 2.0"
L["settings.gameplay.never_ready.title"] = " Ready "
L["settings.gameplay.never_ready.desc"] = "   \"ready\"     .\n\n  ."
L["settings.gameplay.recoilshake.title"] = "    "
L["settings.gameplay.recoilshake.desc"] = "    "
L["settings.gameplay.equipment_generate_ammo.title"] = "    "
L["settings.gameplay.equipment_generate_ammo.desc"] = "     255  ,      ,        .\n\n  .\n\n ."

-- ??
L["settings.gameplay.mult_defaultammo.title"] = " .  ."
L["settings.gameplay.mult_defaultammo.desc"] = "  //          ?\n\n  ."
L["settings.gameplay.nearwall.title"] = "  "
L["settings.gameplay.nearwall.desc"] = "            ."

////////////////////// Visuals
L["settings.tabname.visuals"] = ""

L["settings.visuals.viewmodel"] = "Viewmodel"
L["settings.visuals.vm_bobstyle.title"] = " "
L["settings.visuals.vm_bobstyle.desc"] = "       ARC9 ( valve!)."
L["settings.visuals.fov.title"] = "FOV"
L["settings.visuals.fov.desc"] = "   .     .  ."
L["settings.visuals.vm_addx.title"] = "  X"
L["settings.visuals.vm_addx.desc"] = "    ."
L["settings.visuals.vm_addy.title"] = "  Y"
L["settings.visuals.vm_addy.desc"] = "    ."
L["settings.visuals.vm_addz.title"] = "  Z"
L["settings.visuals.vm_addz.desc"] = "    ."

L["settings.visuals.cambob"] = " "
L["settings.visuals.vm_cambob.title"] = "  "
L["settings.visuals.vm_cambob.desc"] = "     ."
L["settings.visuals.vm_cambobwalk.title"] = "  "
L["settings.visuals.vm_cambobwalk.desc"] = "        (    )"
L["settings.visuals.vm_cambobintensity.title"] = ""
L["settings.visuals.vm_cambobintensity.desc"] = "   "

L["settings.visuals.tpik"] = "TPIK"
L["settings.visuals.tpik.title"] = " TPIK"
L["settings.visuals.tpik.desc"] = "TPIK (    )            ."
L["settings.visuals.tpik_others.title"] = "TPIK  "
L["settings.visuals.tpik_others.desc"] = "      .  ."
L["settings.visuals.tpik_framerate.title"] = " TPIK"
L["settings.visuals.tpik_framerate.desc"] = "    TPIK .   0   ."

////////////////////// Bullet Physics
L["settings.tabname.bullets"] = " "

L["settings.bullets.bullets"] = " "
L["settings.bullets.bullet_physics.title"] = " "
L["settings.bullets.bullet_physics.desc"] = "   .   ,          .      .\n\n  ."
L["settings.bullets.bullet_gravity.title"] = ""
L["settings.bullets.bullet_gravity.desc"] = "  .\n\n  ."
L["settings.bullets.bullet_drag.title"] = ". "
L["settings.bullets.bullet_drag.desc"] = "    .\n\n  ."
L["settings.bullets.ricochet.title"] = ""
L["settings.bullets.ricochet.desc"] = "        .\n\n  ."
L["settings.bullets.mod_penetration.title"] = ""
L["settings.bullets.mod_penetration.desc"] = "         ,     .\n\n  ."
L["settings.bullets.bullet_lifetime.title"] = " "
L["settings.bullets.bullet_lifetime.desc"] = "      .\n\n  ."
L["settings.bullets.bullet_imaginary.title"] = " "
L["settings.bullets.bullet_imaginary.desc"] = "       \"\"  ."

////////////////////// Attachments
L["settings.tabname.attachments"] = ""

L["settings.attachments.customization"] = ""
L["settings.attachments.atts_nocustomize.title"] = " "
L["settings.attachments.atts_nocustomize.desc"] = "    .\n\n  ."
L["settings.attachments.atts_max.title"] = ". "
L["settings.attachments.atts_max.desc"] = "     ,   .\n\n  ."
L["settings.attachments.autosave.title"] = ""
L["settings.attachments.autosave.desc"] = "           ."
L["settings.attachments.blacklist.title"] = " "
L["settings.attachments.blacklist.open"] = ""

L["settings.attachments.inventory"] = ""
L["settings.attachments.free_atts.title"] = " "
L["settings.attachments.free_atts.desc"] = "       .\n\n  ."
L["settings.attachments.atts_lock.title"] = "  "
L["settings.attachments.atts_lock.desc"] = "           .\n\n  ."
L["settings.attachments.atts_loseondie.title"] = "  "
L["settings.attachments.atts_loseondie.desc"] = "      .\n\n  ."
L["settings.attachments.atts_generateentities.title"] = " "
L["settings.attachments.atts_generateentities.desc"] = "         (   ).\n\n     .\n\n  ."

////////////////////// Modifiers
L["settings.tabname.modifiers"] = ""

L["settings.modifiers.quick.title"] = "  "
L["settings.modifiers.quick.desc"] = " "

L["settings.mod_damage.title"] = ""
L["settings.mod_spread.title"] = ""
L["settings.mod_recoil.title"] = ""
L["settings.mod_visualrecoil.title"] = ". "
L["settings.mod_adstime.title"] = " "
L["settings.mod_sprinttime.title"] = "  "
L["settings.mod_damagerand.title"] = " "
L["settings.mod_muzzlevelocity.title"] = " "
L["settings.mod_rpm.title"] = ""
L["settings.mod_headshotdamage.title"] = "  "
L["settings.mod_malfunction.title"] = " "

////////////////////// Controller
L["settings.tabname.controller"] = ""

L["settings.controller.misc"] = ""
L["settings.controller.misc.desc"] = "          ,       > Options > ARC9 > Controller."
L["settings.controller.controller.title"] = " "
L["settings.controller.controller.desc"] = "    ,       ."
L["settings.controller.controller_rumble.title"] = ""
L["settings.controller.controller_rumble.desc"] = "Enable controller rumble as long as Fesiug's DLL mod is loaded.\n\ngithub.com/Fesiug/\ngmod-sinput"
L["settings.controller.controller_config.title"] = " "
L["settings.controller.controller_config.content"] = " "
L["settings.controller.controller_config.desc"] = "     ."

L["settings.controller.glyphs.title"] = " "
L["settings.controller.glyphs.desc"] = "      .\n   \"\" > Options > ARC9 > Controller."

////////////////////// Aim Assist
L["settings.tabname.aimassist"] = "-"
L["settings.tabname.aimassist.desc"] = "      (-)            ."

L["settings.aimassist.enable.title"] = " -"
L["settings.aimassist.enable.desc"] = "   .       .\n\n  .\n\n    -  ."

L["settings.aimassist.enable_general.desc"] = "         .\n\n   \"-\"."

L["settings.aimassist.enable_client.desc"] = "   .       .\n\n  -   ."

L["settings.aimassist.intensity.title"] = ""
L["settings.aimassist.intensity.desc"] = "     .\n\n  ."

L["settings.aimassist.cone.title"] = " "
L["settings.aimassist.cone.desc"] = "         -  .\n\n  ."

L["settings.aimassist.head.title"] = "  "
L["settings.aimassist.head.desc"] = "  -       ?\n\n  ."

L["settings.aimassist.sensmult.desc"] = "      .\n  ,   ."

////////////////////// Asset Caching
L["settings.tabname.caching"] = ""
L["settings.caching.title"] = " "
L["settings.caching.desc"] = "   (       )         !\n\n    -       ."

L["settings.caching.precache_sounds_onfirsttake.title"] = "  :  "
L["settings.caching.precache_sounds_onfirsttake.desc"] = "        (  ).\n\n    ,         ."

L["settings.caching.precache_attsmodels_onfirsttake.title"] = "  : .  "
L["settings.caching.precache_attsmodels_onfirsttake.desc"] = "   ARC9    ARC9     .\n\n   ,       ."
L["settings.caching.precache_wepmodels_onfirsttake.title"] = "  : .   "
L["settings.caching.precache_wepmodels_onfirsttake.desc"] = "    ARC9   ARC9     .\n\n   ,       ."

L["settings.caching.precache_allsounds_onstartup.title"] = "  : .   "
L["settings.caching.precache_allsounds_onstartup.desc"] = "    ARC9     (  ).\n\n    ,       ."
L["settings.caching.precache_attsmodels_onstartup.title"] = "  : .  "
L["settings.caching.precache_attsmodels_onstartup.desc"] = "   ARC9    .\n\n     ,       ."
L["settings.caching.precache_wepmodels_onstartup.title"] = "  : .   "
L["settings.caching.precache_wepmodels_onstartup.desc"] = "    ARC9   .\n\n     ,       ."

L["settings.caching.precache_allsounds.title"] = "  "
L["settings.caching.precache_wepmodels.title"] = "  "
L["settings.caching.precache_attsmodels.title"] = "  "

L["settings.developer.cache"] = ""

////////////////////// Developer
L["settings.tabname.developer"] = " "

L["settings.developer.developer"] = " "
L["settings.developer.dev_always_ready.title"] = " Ready"
L["settings.developer.dev_always_ready.desc"] = "   \"ready\"   .\n\n  ."
L["settings.developer.dev_benchgun.title"] = "Benchgun"
L["settings.developer.dev_benchgun.desc"] = "    ,      ."
L["settings.developer.dev_crosshair.title"] = " "
L["settings.developer.dev_crosshair.desc"] = "          .\n\n     ."
-- L["settings.developer.dev_show_affectors.title"] = "Display Affectors"
-- L["settings.developer.dev_show_affectors.desc"] = "Displays which current affectors are currently applied.\n\nRequires \"Dev Crosshair\"."
L["settings.developer.dev_show_shield.title"] = " "
L["settings.developer.dev_show_shield.desc"] = "    ."
L["settings.developer.dev_greenscreen.title"] = "   "
L["settings.developer.dev_greenscreen.desc"] = "         .\n\n   HDR,    mat_bloom_scalefactor_scalar  0!"
L["settings.developer.reloadatts.title"] = ""
L["settings.developer.reloadlangs.title"] = ""
L["settings.developer.dev_listmyatts.title"] = " "
L["settings.developer.dev_listanims.title"] = " "
L["settings.developer.dev_listbones.title"] = " "
L["settings.developer.dev_listbgs.title"] = " "
L["settings.developer.dev_listatts.title"] = " QCAttachaments"
L["settings.developer.dev_export.title"] = " "
L["settings.developer.dev_getjson.title"] = "JSON "

L["settings.developer.presets_clear.title"] = " "
L["settings.developer.presets_clear.desc"] = "  ,      ,      .\n\n:      ARC9   ,      !"

L["settings.developer.clear"] = ""
L["settings.developer.print"] = " "
L["settings.developer.reload"] = ""

////////////////////// ARC9 Premium
L["premium.title"] = "ARC9 Premium"
L["premium.desc"] = "ARC9 Premium            ."

L["premium.requires"] = " <color=255,106,0>ARC9 Premium</color>."
L["premium.acquire"] = "  <color=255,106,0>ARC9 Premium</color>"

L["premium.ownedno"] = "<color=255,106,0>ARC9 Premium</color>: <color=255,100,100> </color>"
L["premium.owned"] = "<color=255,106,0>ARC9 Premium</color>: <color=255,100,100></color>"

L["premium.help"] = "  ARC9 Premium?"
L["premium.help.header"] = "  ARC9 Premium"
L["premium.help.desc"] = "     . ARC9    ,     . ,      ,         !"

L["premium.help.ownedbutnoaccess"] = "   ARC9 Premium,       ?      Diamond Doves Discord,   .\n    , ,      .   \" ,  \" ."

L["premium.content"] = "  <color=255,106,0>ARC9 Premium</color>:"
L["premium.content.list"] = [[
-     (  32)
-     (  10  )
-    *
-       
-    ,     
-  ,   
-     Discord

*  ,     
]]

L["premium.payment.month"] = [[
$%s
 ARC9 Premium  1 .
]]

L["premium.payment.months"] = [[
$%s
 ARC9 Premium  3    <color=100,255,100> %s%%</color>!
]]

L["premium.payment.info"] = [[
 ARC9 Premium      ,  ,   .
  ,      ,        .
          ARC9 Premium  .

  ,    ,    ,    ARC9 Premium,  ,         .
]]

L["premium.purchased"] = "  <color=255,106,0>ARC9 Premium</color>!"
L["premium.purchased.desc"] = [[
    ARC9 Premium!     !

      Email.

        ARC9 Premium, ,       .

           Premium,    Diamond Doves Discord     ,    .
]]

--PATH lua/arc9/common/localization/content_base_ru.lua:
L = {}

//////// Folders
L["folder.arc9"] = "ARC9"
L["folder.arc9.community"] = "Community"

L["attachment.sticker"] = ""

//////// Flat Camo
L["camo_arc9_base_flat_od.printname"] = "O"
L["camo_arc9_base_flat_od.compactname"] = ""
L["camo_arc9_base_flat_od.description"] = "  ."

L["camo_arc9_base_flat_deserttan.printname"] = ""
L["camo_arc9_base_flat_deserttan.compactname"] = ""
L["camo_arc9_base_flat_deserttan.description"] = "  ."

L["camo_arc9_base_flat_arctic.printname"] = " "
L["camo_arc9_base_flat_arctic.compactname"] = ""
L["camo_arc9_base_flat_arctic.description"] = "   ."

L["camo_arc9_base_flat_black.printname"] = ""
L["camo_arc9_base_flat_black.compactname"] = ""
L["camo_arc9_base_flat_black.description"] = "  ."

L["camo_arc9_base_flat_urbangray.printname"] = " "
L["camo_arc9_base_flat_urbangray.compactname"] = ""
L["camo_arc9_base_flat_urbangray.description"] = "   ."

L["camo_arc9_base_flat_forestgreen.printname"] = " "
L["camo_arc9_base_flat_forestgreen.compactname"] = ""
L["camo_arc9_base_flat_forestgreen.description"] = "   ."

L["camo_arc9_base_flat_navy.printname"] = "-"
L["camo_arc9_base_flat_navy.compactname"] = "-"
L["camo_arc9_base_flat_navy.description"] = " - ."

L["camo_arc9_base_flat_mountbattenpink.printname"] = ""
L["camo_arc9_base_flat_mountbattenpink.compactname"] = ""
L["camo_arc9_base_flat_mountbattenpink.description"] = "  .\n    ."

L["camo_arc9_base_flat_fde.printname"] = "FDE"
L["camo_arc9_base_flat_fde.compactname"] = "FDE"
L["camo_arc9_base_flat_fde.description"] = " FDE ."

//////// Flat Colour
L["camo_arc9_base_flat_red.printname"] = ""
L["camo_arc9_base_flat_red.compactname"] = ""
L["camo_arc9_base_flat_red.description"] = "  ."

L["camo_arc9_base_flat_orange.printname"] = ""
L["camo_arc9_base_flat_orange.compactname"] = ""
L["camo_arc9_base_flat_orange.description"] = "  ."

L["camo_arc9_base_flat_yellow.printname"] = ""
L["camo_arc9_base_flat_yellow.compactname"] = ""
L["camo_arc9_base_flat_yellow.description"] = "  ."

L["camo_arc9_base_flat_green.printname"] = ""
L["camo_arc9_base_flat_green.compactname"] = ""
L["camo_arc9_base_flat_green.description"] = "  ."

L["camo_arc9_base_flat_blue.printname"] = ""
L["camo_arc9_base_flat_blue.compactname"] = ""
L["camo_arc9_base_flat_blue.description"] = "  ."

L["camo_arc9_base_flat_purple.printname"] = ""
L["camo_arc9_base_flat_purple.compactname"] = ""
L["camo_arc9_base_flat_purple.description"] = "  ."

L["camo_arc9_base_flat_pink.printname"] = ""
L["camo_arc9_base_flat_pink.compactname"] = ""
L["camo_arc9_base_flat_pink.description"] = "  - ."

L["camo_arc9_base_flat_arc9orange.printname"] = " ARC9"
L["camo_arc9_base_flat_arc9orange.compactname"] = " ARC9"
L["camo_arc9_base_flat_arc9orange.description"] = "     ARC9."

//////// Charms
L["charm_gs_killcounter.printname"] = " "
L["charm_gs_killcounter.compactname"] = " "
L["charm_gs_killcounter.description"] = "      ."

L["charm_gs_clock.printname"] = " "
L["charm_gs_clock.compactname"] = ""
L["charm_gs_clock.description"] = ",   ."

L["charm_gs_sticker.printname"] = "  "
L["charm_gs_sticker.compactname"] = ""
L["charm_gs_sticker.description"] = ",     ."

//////// Stickers, Base
L["sticker_spray.printname"] = "   "
L["sticker_spray.compactname"] = " "
L["sticker_spray.description"] = [[       !
      .

    ARC9.]]

L["sticker_arc9.printname"] = " ARC9 ()"
L["sticker_arc9.compactname"] = "ARC9"
L["sticker_arc9.description"] = [[   ARC9.
: The Villain.

    ARC9.]]

L["sticker_arc9_lowvis.printname"] = " ARC9"
L["sticker_arc9_lowvis.compactname"] = "ARC9"
L["sticker_arc9_lowvis.description"] = [[
: The Villain.

    ARC9.]]

L["sticker_a9k.printname"] = "ARCTICTHRON 9.000 WEAPON BASE"
L["sticker_a9k.compactname"] = "A9K"
L["sticker_a9k.description"] = [[   "arc9"

    ARC9.]]

L["sticker_a9cylo.printname"] = "  ARC9  CyloWalker"
L["sticker_a9cylo.compactname"] = "A9 Cylo"
L["sticker_a9cylo.description"] = [[    / ARC9  CyloWalker ( !)

    ARC9.]]

L["sticker_sus9.printname"] = "Sus 9"
L["sticker_sus9.compactname"] = "Sus 9"
L["sticker_sus9.description"] = [[The impostor could be anywhere among us...
: Darsu.

    ARC9.]]

//////// Stickers, Com. Wave 1
L["sticker_alien_lean.printname"] = "Legalize Alien Lean"
L["sticker_alien_lean.compactname"] = "Alien Lean"
L["sticker_alien_lean.description"] = [[      ,      ...  .
: Opt1ca.

    ARC9.]]

L["sticker_tomatocat.printname"] = " "
L["sticker_tomatocat.compactname"] = " "
L["sticker_tomatocat.description"] = [[  ,      ...     .
: Ender2Point0.

    ARC9.]]

L["sticker_actionbird.printname"] = " "
L["sticker_actionbird.compactname"] = " "
L["sticker_actionbird.description"] = [[   Arctic   .
: CyloWalker.

    ARC9.]]

L["sticker_warcrimes.printname"] = " "
L["sticker_warcrimes.compactname"] = " "
L["sticker_warcrimes.description"] = [[   ,        ?    - ?
: Rimuchii.      Project Sekai.

    ARC9.]]

L["sticker_sillycat.printname"] = "Silly Cat"
L["sticker_sillycat.compactname"] = "Silly Cat"
L["sticker_sillycat.description"] = [[imsillyimsillyimsillyimsillyimsillyimsillyimsillyimsilly
: Stan_Jacobs.

    ARC9.]]

L["sticker_muertosskull.printname"] = "Dia De Los Muertos Calavera"
L["sticker_muertosskull.compactname"] = "Los Muertos"
L["sticker_muertosskull.description"] = [["this should be my final version i think, unless anyone gives me suggestions to change it, the name: "Dia de los muertos calavera" the description: i cant think of one, something about day of the dead skull mexico blah blah blah"
: rooneyviz.

    ARC9.]]

L["sticker_bandaid.printname"] = ""
L["sticker_bandaid.compactname"] = ""
L["sticker_bandaid.description"] = [[   .
: Itzal.

    ARC9.]]

L["sticker_peacedove.printname"] = "    "
L["sticker_peacedove.compactname"] = " "
L["sticker_peacedove.description"] = [[  ,         .
: Xipil.

    ARC9.]]

L["sticker_borntomodify.printname"] = " "
L["sticker_borntomodify.compactname"] = "BTM"
L["sticker_borntomodify.description"] = [[   -    -  ,   ...
: Duck.

    ARC9.]]

L["sticker_cad.printname"] = ""
L["sticker_cad.compactname"] = ""
L["sticker_cad.description"] = [[
: Opt1ca.

    ARC9.]]

L["sticker_fumo.printname"] = ""
L["sticker_fumo.compactname"] = ""
L["sticker_fumo.description"] = [[-    , -...
: Itzal.

    ARC9.]]

L["sticker_hotlead.printname"] = " "
L["sticker_hotlead.compactname"] = " "
L["sticker_hotlead.description"] = [[! !
: Arqu.

    ARC9.]]

L["sticker_steamhappy.printname"] = ":steamhappy:"
L["sticker_steamhappy.compactname"] = ":steamhappy:"
L["sticker_steamhappy.description"] = [[ 
: Steam.

    ARC9.]]

L["sticker_amidstus.printname"] = "Amidst Us"
L["sticker_amidstus.compactname"] = "Amidst Us"
L["sticker_amidstus.description"] = [[  ,     ?!
: Optica.

    ARC9.]]

L["sticker_arcglory.printname"] = "Glory!"
L["sticker_arcglory.compactname"] = "Glory!"
L["sticker_arcglory.description"] = [[   ,   
: Optica.

    ARC9.]]

L["sticker_wp.printname"] = "   !"
L["sticker_wp.compactname"] = "   !"
L["sticker_wp.description"] = [[!
: Fidget.

    ARC9.]]

L["sticker_tonkr.printname"] = "Send It"
L["sticker_tonkr.compactname"] = "Send It"
L["sticker_tonkr.description"] = [[,   . ,   .
: CyloWalker.

    ARC9.]]

L["sticker_s6amblem.printname"] = " 6"
L["sticker_s6amblem.compactname"] = " 6"
L["sticker_s6amblem.description"] = [[  .   !
: CyloWalker.

    ARC9.]]

L["sticker_babies.printname"] = "  "
L["sticker_babies.compactname"] = "  "
L["sticker_babies.description"] = [[          ... .
: Itzal.

    ARC9.]]

L["sticker_drawberf.printname"] = ""
L["sticker_drawberf.compactname"] = ""
L["sticker_drawberf.description"] = [[.
: The Villain.

    ARC9.]]

L["sticker_arcbird.printname"] = " "
L["sticker_arcbird.compactname"] = " "
L["sticker_arcbird.description"] = [[ .
: Nori/Chewable.

    ARC9.]]

--PATH lua/arc9/common/localization/base_uwu.lua:
return gluapack()()
--PATH lua/arc9/common/localization/base_zh-cn.lua:
return gluapack()()
--PATH lua/arc9/common/sh_config.lua:
// So servers don't have to mess with ConVars

ARC9.NoHUD = false
ARC9.NoTPIK = false
ARC9.NoArmorPiercing = false
ARC9.NoBodyPartsDamageMults = false
--PATH lua/arc9/common/sh_truenames.lua:
return gluapack()()
--PATH lua/arc9/common/attachments_bulk/camos_base_flat_color.lua:
return gluapack()()
--PATH lua/arc9/common/attachments_bulk/charms_default.lua:
local ATT = {}

ATT.PrintName = "Baby Crycry"
ATT.CompactName = "BABY"
ATT.Free = true
ATT.Ignore = true -- Remove to use

ATT.Description = [[Baby wants a nap-nap.]]

ATT.MenuCategory = "ARC9 - Charms"

ATT.Model = "models/items/arc9/att_charmbase.mdl"
ATT.BoxModel = "models/items/arc9/att_cardboard_box.mdl"

ATT.CharmModel = "models/props_c17/doll01.mdl"
ATT.CharmBone = "ring3"
ATT.CharmScale = 0.1
ATT.CharmOffset = Vector(0, -0.1, 0.9)
ATT.CharmAngle = Angle(0, 0, 180)

ATT.Category = "charm"

ARC9.LoadAttachment(ATT, "charm_baby")

ATT = {}

ATT.PrintName = "Kill Counter"
ATT.CompactName = "KILLS"
ATT.Icon = Material("entities/arc9_att_charm_gs_killcounter.png", "mips smooth")
ATT.Free = true

ATT.Description = [[Device for tracking your weapon's kill stats.]]

ATT.MenuCategory = "ARC9 - Charms"

ATT.Model = "models/items/arc9/att_screenbase.mdl"
ATT.BoxModel = "models/items/arc9/att_cardboard_box.mdl"

ATT.Category = {"charm", "gunscreen"}


local rtsurf = Material("effects/arc9/gunscreen")

ATT.Hook_OnKill = function(self, ent)
    if SERVER then return end

    -- tracks kills on the basis of weapon class
    local weapon = self:GetClass()
    -- check whether arc9_gunscreen table exists

    if not sql.TableExists("arc9_killcounter") then
        sql.Query("CREATE TABLE arc9_killcounter (weapon TEXT, npckills INTEGER, playerkills INTEGER)")
    end

    local npckills, playerkills = 0, 0

    -- check whether the weapon is already in the table

    if sql.QueryValue("SELECT weapon FROM arc9_killcounter WHERE weapon = '" .. weapon .. "'") then
        npckills = sql.QueryValue("SELECT npckills FROM arc9_killcounter WHERE weapon = '" .. weapon .. "'")
        playerkills = sql.QueryValue("SELECT playerkills FROM arc9_killcounter WHERE weapon = '" .. weapon .. "'")
    else
        sql.Query("INSERT INTO arc9_killcounter (weapon, npckills, playerkills) VALUES ('" .. weapon .. "', 0, 0)")
    end

    if ent:IsNPC() or ent:IsNextBot() then
        npckills = npckills + 1
        sql.Query("UPDATE arc9_killcounter SET npckills = " .. npckills .. " WHERE weapon = '" .. weapon .. "'")
    else
        playerkills = playerkills + 1
        sql.Query("UPDATE arc9_killcounter SET playerkills = " .. playerkills .. " WHERE weapon = '" .. weapon .. "'")
    end

    self.NPCKills = npckills
    self.PlayerKills = playerkills
end

if CLIENT then
    local rtmat = GetRenderTarget("arc9_gunscreen", 256, 256, false)

    ATT.DrawFunc = function(self, model, wm)
        if wm then return end

        render.PushRenderTarget(rtmat, 0, 0, 256, 256)

        render.Clear(0, 0, 0, 0)

        cam.Start2D()

        local text = "KILLS"

        surface.SetFont("ARC9_32_LCD")

        local w, h = surface.GetTextSize(text)

        surface.SetTextPos(128 - w / 2, 32)
        surface.SetTextColor(255, 255, 255, 255)
        surface.DrawText(text)

        local text_pk = "PLY | NPC"

        surface.SetFont("ARC9_32_LCD")

        local wpk, hpk = surface.GetTextSize(text_pk)

        surface.SetTextPos(128 - wpk / 2, 64 + 8)
        surface.SetTextColor(255, 255, 255, 255)
        surface.DrawText(text_pk)

        local text2 = tostring(self.PlayerKills or 0)

        surface.SetFont("ARC9_48_LCD")

        local w2, h2 = surface.GetTextSize(text2)

        surface.SetTextPos(32, 120)
        surface.SetTextColor(255, 255, 255, 255)
        surface.DrawText(text2)

        local text3 = tostring(self.NPCKills or 0)

        surface.SetFont("ARC9_48_LCD")

        local w3, h3 = surface.GetTextSize(text3)

        surface.SetTextPos(256 - w3 - 16 - 5, 120)
        surface.SetTextColor(255, 255, 255, 255)
        surface.DrawText(text3)

        cam.End2D()

        render.PopRenderTarget()

        rtsurf:SetTexture("$basetexture", rtmat)

        model:SetSubMaterial()

        model:SetSubMaterial(2, "effects/arc9/gunscreen")
    end
end

ARC9.LoadAttachment(ATT, "charm_gs_killcounter")


ATT = {}

ATT.PrintName = "Basic Clock"
ATT.CompactName = "CLOCK"
ATT.Icon = Material("entities/arc9_att_charm_gs_clock.png", "mips smooth")
ATT.Free = true

ATT.Description = [[Shows the real-world time.]]

ATT.MenuCategory = "ARC9 - Charms"

ATT.Model = "models/items/arc9/att_screenbase.mdl"
ATT.BoxModel = "models/items/arc9/att_cardboard_box.mdl"

ATT.Category = {"charm", "gunscreen"}


if CLIENT then
    local rtmat = GetRenderTarget("arc9_gunscreen", 256, 256, false)

    ATT.DrawFunc = function(self, model, wm)
        if wm then return end

        render.PushRenderTarget(rtmat, 0, 0, 256, 256)

        render.Clear(0, 0, 0, 0)

        cam.Start2D()

        local text = os.date("%H:%M")

        if CurTime() % 2 < 1 then
            text = string.Replace(text, ":", " ")
        end

        surface.SetFont("ARC9_48_LCD")

        local w, h = surface.GetTextSize(text)

        surface.SetTextPos(128 - w / 2, 128 - h / 2 - 24)
        surface.SetTextColor(255, 255, 255, 255)
        surface.DrawText(text)

        local text_date = os.date("%d %b")

        surface.SetFont("ARC9_32_LCD")

        local w_date, h_date = surface.GetTextSize(text_date)

        surface.SetTextPos(128 - w_date / 2, 128 - h_date / 2 + 24)
        surface.SetTextColor(255, 255, 255, 255)
        surface.DrawText(text_date)

        cam.End2D()

        render.PopRenderTarget()

        rtsurf:SetTexture("$basetexture", rtmat)

        model:SetSubMaterial()

        model:SetSubMaterial(2, "effects/arc9/gunscreen")
    end
end

ARC9.LoadAttachment(ATT, "charm_gs_clock")

ATT = {}

ATT.PrintName = "Sticker Panel"
ATT.CompactName = "STICKER"
ATT.Icon = Material("entities/arc9_att_charm_gs_sticker.png", "mips smooth")
ATT.Free = true

ATT.Description = [[Allows a sticker to be applied to the screen.]]

ATT.MenuCategory = "ARC9 - Charms"

ATT.Model = "models/items/arc9/att_screenbase.mdl"
ATT.BoxModel = "models/items/arc9/att_cardboard_box.mdl"

ATT.Category = {"charm", "gunscreen"}

ATT.Attachments = {
    {
        PrintName = ARC9:GetPhrase("attachment.sticker"),
        StickerModel = "models/items/arc9/sticker_screenbase.mdl",
        Category = "stickers",
        Pos = Vector(0, 0, 0),
        Ang = Angle(0, 0, 0),
        Icon_Offset = Vector(-2, 0, 0)
    }
}

ARC9.LoadAttachment(ATT, "charm_gs_sticker")

--PATH lua/arc9/client/cl_autostats.lua:
local imperial = GetConVar("arc9_imperial"):GetBool()

local hutom = function(i)
	if imperial then 
		impv = 1.0936
		impn = "unit.yard"
	else 
		impv = 1
		impn = "unit.meter"
	end
	return math.Round(i * ARC9.HUToM * impv) .. (ARC9:GetPhrase(impn) or "m") 
end

local hutomm = function(i)
	if imperial then 
		impv = 39.370
		impn = "unit.inch"
	else 
		impv = 1000
		impn = "unit.millimeter"
	end
	return math.Round(i * ARC9.HUToM * impv) .. (ARC9:GetPhrase(impn) or "mm") 
end

local hutoms = function(i) 
	if imperial then 
		impv = 3.2808399
		impn = "unit.footpersecond"
	else 
		impv = 1
		impn = "unit.meterpersecond"
	end
	return math.Round(i * ARC9.HUToM * impv) .. (ARC9:GetPhrase(impn) or "m/s")
end

local hutoms_1 = function(i) 
	if imperial then 
		impv = 3.2808399
		impn = "unit.footpersecond"
	else 
		impv = 1
		impn = "unit.meterpersecond"
	end
	return math.Round(i * ARC9.HUToM * impv, 1) .. (ARC9:GetPhrase(impn) or "m/s")
end

local degtomoa = function(i) return math.Round(i / ARC9.TrueMOAToAcc, 1) .. (ARC9:GetPhrase("unit.moa") or "MOA") end

-- [AutoStatName] = {unit, lower_is_better}
-- unit can be:
--   false - as is (e.g. 30 round capacity)
--   string - suffix (e.g. +1 chamber size)
--   true - true percentage (e.g. 80% move speed)
--   function - return a string to use as the value
ARC9.AutoStatsMains = {
    ["DamageMax"] = {false, false},
    ["DamageMin"] = {false, false},
    ["DamageRand"] = {false, true},
    ["RangeMin"] = {hutom, false},
    ["RangeMax"] = {hutom, false},
    ["Distance"] = {hutom, false},
    ["Num"] = {false, false},
    ["Penetration"] = {hutomm, false},
    ["PenetrationDelta"] = {true, false},
    ["RicochetAngleMax"] = {"", false},
    ["RicochetChance"] = {false, false},
    ["ArmorPiercing"] = {false, false},
    ["EntityMuzzleVelocity"] = {hutoms, false},
    ["PhysBulletMuzzleVelocity"] = {hutoms, false},
    ["PhysBulletDrag"] = {false, true},
    ["PhysBulletGravity"] = {false, true},
    ["ChamberSize"] = {false, false},
    ["ClipSize"] = {false, false},
    ["SupplyLimit"] = {false, false},
    ["SecondarySupplyLimit"] = {false, false},
    ["AmmoPerShot"] = {false, true},
    ["ManualActionChamber"] = {false, false},
    ["TriggerDelay"] = {false, true},
    ["TriggerDelayTime"] = {"s", true},
    ["RPM"] = {"RPM", false},
    ["PushBackForce"] = {hutoms_1, false},
    ["PostBurstDelay"] = {"s", true},
    ["Recoil"] = {false, true},
    ["RecoilPatternDrift"] = {false, true},
    ["RecoilUp"] = {false, true},
    ["RecoilSide"] = {false, true},
    ["RecoilRandomUp"] = {false, true},
    ["RecoilRandomSide"] = {false, true},
    ["RecoilDissipationRate"] = {false, false},
    ["RecoilResetTime"] = {"s", true},
    ["RecoilAutoControl"] = {false, false},
    ["RecoilKick"] = {false, true},
    ["Spread"] = {degtomoa, true},
    ["PelletSpread"] = {degtomoa, true},
    ["FreeAimRadius"] = {"", true},
    ["Sway"] = {false, true},
    ["AimDownSightsTime"] = {"s", true},
    ["SprintToFireTime"] = {"s", true},
    ["ReloadTime"] = {false, true},
    ["DeployTime"] = {false, true},
    ["CycleTime"] = {false, true},
    ["FixTime"] = {false, true},
    ["OverheatTime"] = {false, true},
    ["Speed"] = {true, false},
    ["BashDamage"] = {false, false},
    ["BashRange"] = {"HU", false},
    ["BashLungeRange"] = {"HU", false},
    ["Bash2Damage"] = {false, false},
    ["Bash2Range"] = {"HU", false},
    ["Bash2LungeRange"] = {"HU", false},
    ["HeatPerShot"] = {false, true},
    ["HeatCapacity"] = {false, false},
    ["HeatDissipation"] = {false, false},
    ["MalfunctionMeanShotsToFail"] = {false, false},
    ["ShootVolume"] = {"dB", true},
    ["AlwaysPhysBullet"] = {false, false},
    ["NeverPhysBullet"] = {false, true},
    ["InfiniteAmmo"] = {false, true},
    ["BottomlessClip"] = {false, true},
    ["ShotgunReload"] = {false, false},
    ["HybridReload"] = {false, true},
    ["ManualAction"] = {false, false},
    ["CanFireUnderwater"] = {false, true},
    ["AutoReload"] = {false, true},
    ["AutoBurst"] = {false, true},
    ["RunawayBurst"] = {false, false},
    ["ShootWhileSprint"] = {false, true},
    ["Bash"] = {false, true},
    ["Bash2"] = {false, true},
    ["Overheat"] = {false, false},
    ["Malfunction"] = {false, false},
    ["MalfunctionWait"] = {"s", true},
    ["Bipod"] = {false, true},
    ["NoFlash"] = {false, true},
    ["BulletGuidance"] = {false, true},
    ["BulletGuidanceAmount"] = {false, false},
    ["ExplosionDamage"] = {false, false},
    ["ExplosionRadius"] = {false, false},
    ["HeadshotDamage"] = {true, false},
    ["ChestDamage"] = {true, false},
    ["StomachDamage"] = {true, false},
    ["ArmDamage"] = {true, false},
    ["LegDamage"] = {true, false},
    ["VisualRecoil"] = {false, true},
    ["VisualRecoilUp"] = {false, true},
    ["VisualRecoilSide"] = {false, true},
    ["VisualRecoilRoll"] = {false, true},
    ["VisualRecoilPunch"] = {false, true},
    ["BreathHoldTime"] = {false, false},
    ["RecoilModifierCap"] = {false, true},
    ["BashSpeed"] = {false, false},
    ["Bash2Speed"] = {false, false},
    ["RecoilPerShot"] = {false, true},
}

ARC9.AutoStatsOperations = {
    ["Mult"] = function(a, weapon, stat, unit)
        if unit == true then
            return "" .. math.Round(a * 100, 2) .. "%", "", a < 1
        end

        local neg = false
        if a > 1 then
            a = (a - 1) * 100
        else
            a = (a - 1) * -100
            neg = true
        end
        a = math.Round(a, 2)

        if neg then
            return "-" .. tostring(a) .. "%", "", true
        else
            return "+" .. tostring(a) .. "%", "", false
        end
    end,
    ["Add"] = function(a, weapon, stat, unit)
        local neg = false
        if a < 0 then
            neg = true
            a = a * -1
        end

        local str
        if unit == true then
            str = math.Round(a * 100, 2) .. "%"
        elseif isstring(unit) then
            str = tostring(math.Round(a, 2)) .. unit
        elseif isfunction(unit) then
            str = unit(a)
        else
            str = tostring(math.Round(a, 2))
        end

        if neg then
            return "-" .. str, "", true
        else
            return "+" .. str, "", false
        end
    end,
    ["Override"] = function(a, weapon, stat, unit)
        if isbool(a) then
            if a then
                return ARC9:GetPhrase("autostat.enable.pre") or "", ARC9:GetPhrase("autostat.enable.post") or "", a
            else
                return ARC9:GetPhrase("autostat.disable.pre") or "", ARC9:GetPhrase("autostat.disable.post") or "", a
            end
        end

        local str
        if unit == true then
            str = math.Round(a * 100, 2) .. "%"
        elseif isstring(unit) then
            str = tostring(math.Round(a, 2)) .. unit
        elseif isfunction(unit) then
            str = unit(a)
        else
            str = tostring(math.Round(a, 2))
        end

        return str, "", a <= (weapon[stat] or 0)
    end,
    ["Hook"] = function(a, weapon, stat)
        return "", "", false
    end
}

ARC9.AutoStatsConditions = {
    ["True"] = "When TrueNames Is On",
    ["Silenced"] = "When Silenced",
    ["MidAir"] = "In Mid-Air",
    ["Crouch"] = "While Crouching",
    ["First"] = "On First Shot",
    ["FirstShot"] = "On First Shot",
    ["Last"] = "On Last Shot In Mag",
    ["LastShot"] = "On Last Shot In Mag",
    ["Empty"] = "On Last Shot In Mag",
    ["EvenShot"] = "Every Other Shot",
    ["OddShot"] = "Every Odd Shot",
    ["EvenReload"] = "Every Other Reload",
    ["OddReload"] = "Every Odd Reload",
    ["Sights"] = "In Sights",
    ["Sighted"] = "While Sighted",
    ["Hot"] = "From Heat",
    ["Heated"] = "While Heated",
    ["HipFire"] = "In Hipfire",
    ["Shooting"] = "While Shooting",
    ["Recoil"] = "With Each Shot",
    ["Move"] = "While Moving",
    ["BlindFire"] = "While Blind Firing",
    ["UBGL"] = "In UBGL",
    ["Bipod"] = "On Bipod",
	["Sprint"] = "when Sprinting",
}

function ARC9.GetProsAndCons(atttbl, weapon)
    local prosname = {}
    local prosnum = {}
    local consname = {}
    local consnum = {}

    for stat, value in pairs(atttbl) do
        if !isnumber(value) and !isbool(value) then continue end
        --if isnumber(value) and (!string.StartWith(stat, "Spread")) then value = math.Round(value, 2) end
        local autostat = ""
        local autostatnum = ""
        local canautostat = false
        local neg = false
        local unit = false
        local negisgood = false
        local asmain = ""

        local maxlen = 0

        for main, tbl in pairs(ARC9.AutoStatsMains) do
            if string.len(main) > maxlen and string.StartWith(stat, main) then
                autostat = ARC9:GetPhrase("autostat." .. main) or main
                unit = tbl[1]
                negisgood = tbl[2]
                asmain = main
                canautostat = true
                maxlen = string.len(main)
            end
        end

        if !canautostat then
            continue
        end

        stat = string.sub(stat, string.len(asmain) + 1, string.len(stat))

        local foundop = false
        local asop = ""

        for op, func in pairs(ARC9.AutoStatsOperations) do
            if string.StartWith(stat, op) then
                local pre, post, isneg = func(value, weapon, asmain, unit)
                autostat = autostat .. post
                autostatnum = pre
                neg = isneg
                foundop = true
                asop = op
                break
            end
        end

        if asop == "Hook" then continue end

        if !foundop then
            -- autostat = tostring(value) .. " " .. autostat

            -- if isnumber(value) then neg = value <= (weapon[asmain] or 0) else neg = value end
            local pre, post, isneg = ARC9.AutoStatsOperations.Override(value, weapon, asmain, unit)
            autostat = autostat .. post
            autostatnum = pre
            neg = isneg
            foundop = true
            asop = "Override"
        else
            stat = string.sub(stat, string.len(asop) + 1, string.len(stat))
        end

        if stat == "_Priority" then continue end

        if string.len(stat) > 0 then

            local before = ARC9:GetPhrase("autostat.secondary._beforephrase")
            local div = ARC9:GetPhrase("autostat.secondary._divider")
            if div == true then div = "" end

            for cond, postfix in pairs(ARC9.AutoStatsConditions) do
                if string.StartWith(stat, cond) then
                    local phrase = (ARC9:GetPhrase("autostat.secondary." .. string.lower(cond)) or "")
                    if before then
                        autostat = phrase .. div .. autostat
                    else
                        autostat = autostat .. div .. phrase
                    end
                    break
                end
            end
        end

        if neg and negisgood or !neg and !negisgood then
            table.insert(prosname, autostat)
            table.insert(prosnum, autostatnum)
        else
            table.insert(consname, autostat)
            table.insert(consnum, autostatnum)
        end
    end

    -- custom stats
    if istable(atttbl.CustomPros) then
        for stat, value in pairs(atttbl.CustomPros) do
            table.insert(prosname, stat)
            table.insert(prosnum, value)
        end
    end

    if istable(atttbl.CustomCons) then
        for stat, value in pairs(atttbl.CustomCons) do
            table.insert(consname, stat)
            table.insert(consnum, value)
        end
    end

    return prosname, prosnum, consname, consnum
    -- return pros, cons
end
--PATH lua/arc9/client/cl_pp.lua:
ARC9.Flares = {}

local flaremat = Material("effects/arc9_lensflare", "mips smooth")

hook.Add("PostDrawHUD", "ARC9_SSE_PP", function()
    if !IsValid(LocalPlayer()) then return end
    local wpn = LocalPlayer():GetActiveWeapon()

    if !IsValid(wpn) then return end
    if !wpn.ARC9 then return end

    wpn:HoldBreathPP()
    
    for i, flare in ipairs(ARC9.Flares) do
        cam.Start3D(_, _ , flare.invm and wpn.ViewModelFOV + 16 or _) -- no idea why 16
        local toscreen = flare.pos:ToScreen()
        cam.End3D()

        if toscreen.visible then
            surface.SetMaterial(flaremat)
            surface.SetDrawColor(flare.color)
            local s = ScreenScale(flare.size)
            surface.DrawTexturedRect(toscreen.x - (s / 2), toscreen.y - (s / 2), s, s)
        end
    end

    ARC9.Flares = {}
    wpn.FlaresAlreadyDrawn = {}

    if wpn:GetSight().FlatScope and wpn:GetSight().FlatScopeCC and wpn:GetSightAmount() > 0.75 then
        DrawColorModify(wpn:GetSight().FlatScopeCC)
    end
end)
--PATH lua/arc9/client/cl_settings_menu.lua:
return gluapack()()
--PATH addons/[miecze] mexicano_drzewko/lua/autorun/sh_config.lua:
MX_LSCS = MX_LSCS or {}
MX_LSCS.timertime = 3600
MX_LSCS.howmuchxp = 1

-- Gwne Kategorie z Podkategoriami
MX_LSCS.Drzewko = {
    [1] = {
        name = "HP",   
        icon = "icon_hp.png",
        subcategories = { 
            "HP", 
            "Armor" 
        }
    },
    [2] = {
        name = "Moce",
        icon = "icon_moce.png",
        subcategories = { 
            "Pojemno Mocy",
            "Regeneracja Mocy",
            "Skok", 
            "Adrenalina", 
            "Odrzut", 
            "Przycignicie",
            "Leczenie", 
            "Leczenie innych", 
            "Medytacja",
            "Force Sense", 
            "Grab",  
            "Breach",
            "Rzut Mieczem",
            "Judgement",
        }
    },
    [3] = {
        name = "Style Walki",
        icon = "icon_walki.png",
        subcategories = { 
            "Aggressive", 
            "Agile",
            "Arrogant",
            "Arrogant EXPERT",
            "Blade Dancer Dual",
            "Crescent",
            "Crescent Dual",
            "Ataru",
            "Defensive",
            "Djem So",
            "Double blade staff",
            "Double blade staff Dual",
            "Dual Wield",
            "Form 1 Shii-cho",
            "Form 1 Shii-cho EXPERT",
            "Form 2 Makashi",
            "Form 3 Soresu",
            "Form 4 Ataru",
            "Form 4 Ataru Dual",
            "Form 5 Shien So",
            "Form 6 Niman",
            "Form 7 Vaapad",
            "Form 7 Vaapad Dual",
            "Juggernaut",
            "Juggernaut Dual",
            "Shien So Dual",
            "Form 1 Shii-cho Fast",
            "Form 3 Soresu Dual",
            "Versatile",
            "Visigoth",
            "Warrior",
            "Warrior Dual",
            "Yong Li"

            
        }
    },
}

-- Moce
MX_LSCS.Moce = {
    {
        name = "Pojemno Mocy 1",       
        icon = "icon_leczenie.png",
        cost = 3,
        category = "Moce",        
        subcategory = "Pojemno Mocy",    
        sciezka = "mocpoj1",
        ilosc = 50,
        tier = 1
    },
    {
        name = "Pojemno Mocy 2",       
        icon = "icon_leczenie.png",
        cost = 4,
        category = "Moce",        
        subcategory = "Pojemno Mocy",    
        sciezka = "mocpoj2",
        ilosc = 50,
        tier = 2
    },
    {
        name = "Pojemno Mocy 3",       
        icon = "icon_leczenie.png",
        cost = 5,
        category = "Moce",        
        subcategory = "Pojemno Mocy",    
        sciezka = "mocpoj3",
        ilosc = 50,
        tier = 3
    },
    {
        name = "Pojemno Mocy 4",       
        icon = "icon_leczenie.png",
        cost = 6,
        category = "Moce",        
        subcategory = "Pojemno Mocy",    
        sciezka = "mocpoj4",
        ilosc = 50,
        tier = 4
    },
    {
        name = "Pojemno Mocy 5",       
        icon = "icon_leczenie.png",
        cost = 7,
        category = "Moce",        
        subcategory = "Pojemno Mocy",    
        sciezka = "mocpoj5",
        ilosc = 50,
        tier = 5
    },
    {
        name = "Pojemno Mocy 6",       
        icon = "icon_leczenie.png",
        cost = 8,
        category = "Moce",        
        subcategory = "Pojemno Mocy",    
        sciezka = "mocpoj6",
        ilosc = 50,
        tier = 6
    },

    {
        name = "Regeneracja Mocy 1",       
        icon = "icon_leczenie.png",
        cost = 2,
        category = "Moce",           
        subcategory = "Regeneracja Mocy",     
        sciezka = "mocregen1",
        ilosc = 1,
        tier = 1
    },
    {
        name = "Regeneracja Mocy 2",       
        icon = "icon_leczenie.png",
        cost = 3,
        category = "Moce",           
        subcategory = "Regeneracja Mocy",     
        sciezka = "mocregen2",
        ilosc = 1,
        tier = 2
    },
    {
        name = "Regeneracja Mocy 3",       
        icon = "icon_leczenie.png",
        cost = 4,
        category = "Moce",           
        subcategory = "Regeneracja Mocy",     
        sciezka = "mocregen3",
        ilosc = 1,
        tier = 3
    },
    {
        name = "Regeneracja Mocy 4",       
        icon = "icon_leczenie.png",
        cost = 5,
        category = "Moce",           
        subcategory = "Regeneracja Mocy",     
        sciezka = "mocregen4",
        ilosc = 1,
        tier = 4
    },
    
    

    {
        name = "Judgement 1",       
        icon = "icon_leczenie.png",
        cost = 7,
        category = "Moce",           
        subcategory = "Judgement",     
        sciezka = "item_force_judgementi",
        ilosc = nil,
        tier = 1
    },
    {
        name = "Judgement 2",       
        icon = "icon_leczenie.png",
        cost = 9,
        category = "Moce",           
        subcategory = "Judgement",     
        sciezka = "item_force_judgementii",
        ilosc = nil,
        tier = 2
    },    
    {
        name = "Judgement 3",       
        icon = "icon_leczenie.png",
        cost = 11,
        category = "Moce",           
        subcategory = "Judgement",     
        sciezka = "item_force_judgementiii",
        ilosc = nil,
        tier = 3
    },

    {
        name = "Skok 1",       
        icon = "icon_leczenie.png",
        cost = 2,
        category = "Moce",           
        subcategory = "Skok",     
        sciezka = "item_force_jump",
        ilosc = nil,
        tier = 1
    },
    {
        name = "Skok 2",       
        icon = "icon_leczenie.png",
        cost = 3,
        category = "Moce",           
        subcategory = "Skok",     
        sciezka = "item_force_jumpii",
        ilosc = nil,
        tier = 2
    },
    {
        name = "Skok 3",       
        icon = "icon_leczenie.png",
        cost = 4,
        category = "Moce",           
        subcategory = "Skok",     
        sciezka = "item_force_jumpiii",
        ilosc = nil,
        tier = 3
    },

    {
        name = "Adrenalina 1",       
        icon = "icon_leczenie.png",
        cost = 5,
        category = "Moce",           
        subcategory = "Adrenalina",     
        sciezka = "item_force_adrenaline",
        ilosc = nil,
        tier = 1
    },
    {
        name = "Adrenalina 2",       
        icon = "icon_leczenie.png",
        cost = 8,
        category = "Moce",           
        subcategory = "Adrenalina",     
        sciezka = "item_force_adrenalineii",
        ilosc = nil,
        tier = 2
    },
    {
        name = "Adrenalina 3",       
        icon = "icon_leczenie.png",
        cost = 12,
        category = "Moce",           
        subcategory = "Adrenalina",     
        sciezka = "item_force_adrenalineiii",
        ilosc = nil,
        tier = 3
    },
    {
        name = "Mass Heal",       
        icon = "icon_leczenie.png",
        cost = 15,
        category = "Moce",           
        subcategory = "Leczenie innych",     
        sciezka = "item_force_massheal",
        ilosc = nil,
        tier = 1
    },
    {
        name = "Group Heal",       
        icon = "icon_leczenie.png",
        cost = 30,
        category = "Moce",           
        subcategory = "Leczenie innych",     
        sciezka = "item_force_groupheal",
        ilosc = nil,
        tier = 2
    }, 

    {
        name = "Heal 1",       
        icon = "icon_leczenie.png",
        cost = 2,
        category = "Moce",           
        subcategory = "Leczenie",     
        sciezka = "item_force_heal",
        ilosc = nil,
        tier = 1
    },
    {
        name = "Heal 2",       
        icon = "icon_leczenie.png",
        cost = 3,
        category = "Moce",           
        subcategory = "Leczenie",     
        sciezka = "item_force_healii",
        ilosc = nil,
        tier = 2
    },
    {
        name = "Heal 3",       
        icon = "icon_leczenie.png",
        cost = 4,
        category = "Moce",           
        subcategory = "Leczenie",     
        sciezka = "item_force_healiii",
        ilosc = nil,
        tier = 3
    },
    {
        name = "Better Heal",       
        icon = "icon_leczenie.png",
        cost = 7,
        category = "Moce",           
        subcategory = "Leczenie",     
        sciezka = "item_force_betterheal",
        ilosc = nil,
        tier = 4
    },
    {
        name = "Greater Heal",       
        icon = "icon_leczenie.png",
        cost = 8,
        category = "Moce",           
        subcategory = "Leczenie",     
        sciezka = "item_force_greaterheal",
        ilosc = nil,
        tier = 5
    },
    {
        name = "Grand Heal",       
        icon = "icon_leczenie.png",
        cost = 9,
        category = "Moce",           
        subcategory = "Leczenie",     
        sciezka = "item_force_grandheal",
        ilosc = nil,
        tier = 6
    },

    {
        name = "Push 1",       
        icon = "icon_leczenie.png",
        cost = 2,
        category = "Moce",           
        subcategory = "Odrzut",     
        sciezka = "item_force_push",
        ilosc = nil,
        tier = 1
    },
    {
        name = "Push 2",       
        icon = "icon_leczenie.png",
        cost = 6,
        category = "Moce",           
        subcategory = "Odrzut",     
        sciezka = "item_force_pushii",
        ilosc = nil,
        tier = 2
    },
    {
        name = "Push 3",       
        icon = "icon_leczenie.png",
        cost = 10,
        category = "Moce",           
        subcategory = "Odrzut",     
        sciezka = "item_force_pushiii",
        ilosc = nil,
        tier = 3
    },
    {
        name = "Greater Push",       
        icon = "icon_leczenie.png",
        cost = 30,
        category = "Moce",           
        subcategory = "Odrzut",     
        sciezka = "item_force_greaterpush",
        ilosc = nil,
        tier = 4
    }, 


    {
        name = "Pull 1",       
        icon = "icon_leczenie.png",
        cost = 2,
        category = "Moce",           
        subcategory = "Przycignicie",     
        sciezka = "item_force_pull",
        ilosc = nil,
        tier = 1
    },
    {
        name = "Pull 2",       
        icon = "icon_leczenie.png",
        cost = 6,
        category = "Moce",           
        subcategory = "Przycignicie",     
        sciezka = "item_force_pullii",
        ilosc = nil,
        tier = 2
    },
    {
        name = "Pull 3",       
        icon = "icon_leczenie.png",
        cost = 10,
        category = "Moce",           
        subcategory = "Przycignicie",     
        sciezka = "item_force_pulliii",
        ilosc = nil,
        tier = 3
    },
    {
        name = "Greater Pull",       
        icon = "icon_leczenie.png",
        cost = 30,
        category = "Moce",           
        subcategory = "Przycignicie",     
        sciezka = "item_force_greaterpull",
        ilosc = nil,
        tier = 4
    },

    {
        name = "Medytacja 1",       
        icon = "icon_leczenie.png",
        cost = 1,
        category = "Moce",           
        subcategory = "Medytacja",     
        sciezka = "item_force_meditate",
        ilosc = nil,
        tier = 1
    },
    {
        name = "Medytacja 2",       
        icon = "icon_leczenie.png",
        cost = 3,
        category = "Moce",           
        subcategory = "Medytacja",     
        sciezka = "item_force_meditateii",
        ilosc = nil,
        tier = 2
    }, 

    {
        name = "Basic Sense",       
        icon = "icon_leczenie.png",
        cost = 4,
        category = "Moce",           
        subcategory = "Force Sense",     
        sciezka = "item_force_sense1",
        ilosc = nil,
        tier = 1
    },
    {
        name = "Advanced Sense",       
        icon = "icon_leczenie.png",
        cost = 6,
        category = "Moce",           
        subcategory = "Force Sense",     
        sciezka = "item_force_sense2",
        ilosc = nil,
        tier = 2
    },
    {
        name = "Mastered Sense",       
        icon = "icon_leczenie.png",
        cost = 10,
        category = "Moce",           
        subcategory = "Force Sense",     
        sciezka = "item_force_sense3",
        ilosc = nil,
        tier = 3
    },
    {
        name = "Ultimate Sense",       
        icon = "icon_leczenie.png",
        cost = 20,
        category = "Moce",           
        subcategory = "Force Sense",     
        sciezka = "item_force_sense",
        ilosc = nil,
        tier = 4
    },

    {
        name = "Grab",       
        icon = "icon_leczenie.png",
        cost = 3,
        category = "Moce",           
        subcategory = "Grab",     
        sciezka = "item_force_grab",
        ilosc = nil,
        tier = 1
    },

    {
        name = "Breach",       
        icon = "icon_leczenie.png",
        cost = 15,
        category = "Moce",           
        subcategory = "Breach",     
        sciezka = "item_force_breach",
        ilosc = nil,
        tier = 1
    },

    {
        name = "Rzut Mieczem",       
        icon = "icon_leczenie.png",
        cost = 10,
        category = "Moce",           
        subcategory = "Rzut Mieczem",     
        sciezka = "item_force_throw",
        ilosc = nil,
        tier = 1
    },

    {
        name = "HP 1",
        icon = "icon_regeneracja.png",
        cost = 3,
        category = "HP",
        subcategory = "HP",
        sciezka = "hp1",
        ilosc = 400,
        tier = 1
    },
    {
        name = "HP 2",
        icon = "icon_regeneracja.png",
        cost = 4,
        category = "HP",
        subcategory = "HP",
        sciezka = "hp2",
        ilosc = 400,
        tier = 2
    },
    {
        name = "HP 3",
        icon = "icon_regeneracja.png",
        cost = 5,
        category = "HP",
        subcategory = "HP",
        sciezka = "hp3",
        ilosc = 400,
        tier = 3
    },
    /*{
        name = "HP 4",
        icon = "icon_regeneracja.png",
        cost = 2000,
        category = "HP",
        subcategory = "HP",
        sciezka = "hp4",
        ilosc = 200,
        tier = 4
    },
    {
        name = "HP 5",
        icon = "icon_regeneracja.png",
        cost = 2200,
        category = "HP",
        subcategory = "HP",
        sciezka = "hp5",
        ilosc = 200,
        tier = 5
    },
    {
        name = "HP 6",
        icon = "icon_regeneracja.png",
        cost = 3000,
        category = "HP",
        subcategory = "HP",
        sciezka = "hp6",
        ilosc = 200,
        tier = 6
    },*/

    {
        name = "Pancerz 1",
        icon = "icon_armor.png",
        cost = 1,
        category = "HP",
        subcategory = "Armor",
        sciezka = "armor1",
        ilosc = 25,
        tier = 1
    },
    {
        name = "Pancerz 2",
        icon = "icon_armor.png",
        cost = 2,
        category = "HP",
        subcategory = "Armor",
        sciezka = "armor2",
        ilosc = 25,
        tier = 2
    },
    {
        name = "Pancerz 3",
        icon = "icon_armor.png",
        cost = 3,
        category = "HP",
        subcategory = "Armor",
        sciezka = "armor3",
        ilosc = 25,
        tier = 3
    },
    {
        name = "Pancerz 4",
        icon = "icon_armor.png",
        cost = 4,
        category = "HP",
        subcategory = "Armor",
        sciezka = "armor4",
        ilosc = 25,
        tier = 4
    },
    {
        name = "Aggressive",
        icon = "icon_armor.png",
        cost = 3,
        category = "Style Walki",
        subcategory = "Aggressive",
        sciezka = "item_stance_aggresive",
        ilosc = nil,
        tier = 1
    },
    {
        name = "Agile",
        icon = "icon_armor.png",
        cost = 15,
        category = "Style Walki",
        subcategory = "Agile",
        sciezka = "item_stance_agile",
        ilosc = nil,
        tier = 1
    },
    {
        name = "Arrogant",
        icon = "icon_armor.png",
        cost = 5,
        category = "Style Walki",
        subcategory = "Arrogant",
        sciezka = "item_stance_arrogant",
        ilosc = nil,
        tier = 1
    },
    {
        name = "Arrogant EXPERT",
        icon = "icon_armor.png",
        cost = 6,
        category = "Style Walki",
        subcategory = "Arrogant",
        sciezka = "item_stance_arrogantexperienced",
        ilosc = nil,
        tier = 2 
    },
    
    {
        name = "Blade Dancer Dual",
        icon = "icon_armor.png",
        cost = 7,
        category = "Style Walki",
        subcategory = "Blade Dancer",
        sciezka = "item_stance_dancerdual",
        ilosc = nil,
        tier = 2 
    },
    {
        name = "Crescent",
        icon = "icon_armor.png",
        cost = 5,
        category = "Style Walki",
        subcategory = "Crescent",
        sciezka = "item_stance_crescent",
        ilosc = nil,
        tier = 1 
    },
    {
        name = "Crescent Dual",
        icon = "icon_armor.png",
        cost = 7,
        category = "Style Walki",
        subcategory = "Crescent",
        sciezka = "item_stance_crescentdual",
        ilosc = nil,
        tier = 2 
    },
    {
        name = "Defensive",
        icon = "icon_armor.png",
        cost = 3,
        category = "Style Walki",
        subcategory = "Defensive",
        sciezka = "item_stance_defensive",
        ilosc = nil,
        tier = 1 
    },

    {
        name = "Double blade staff",
        icon = "icon_armor.png",
        cost = 10,
        category = "Style Walki",
        subcategory = "Double blade staff",
        sciezka = "item_stance_saberstaff",
        ilosc = nil,
        tier = 1 
    },
    {
        name = "Double blade staff Dual",
        icon = "icon_armor.png",
        cost = 20,
        category = "Style Walki",
        subcategory = "Double blade staff",
        sciezka = "item_stance_saberstaffdual",
        ilosc = nil,
        tier = 2 
    },
    {
        name = "Dual Wield",
        icon = "icon_armor.png",
        cost = 15,
        category = "Style Walki",
        subcategory = "Dual Wield",
        sciezka = "item_stance_dualwield",
        ilosc = nil,
        tier = 1 
    },
    {
        name = "Form 1 Shii-cho",
        icon = "icon_armor.png",
        cost = 1,
        category = "Style Walki",
        subcategory = "Shii-cho",
        sciezka = "item_stance_shiicho",
        ilosc = nil,
        tier = 1 
    },
    {
        name = "Form 1 Shii-cho EXPERT",
        icon = "icon_armor.png",
        cost = 6,
        category = "Style Walki",
        subcategory = "Shii-cho",
        sciezka = "item_stance_shiichotwo",
        ilosc = nil,
        tier = 2 
    },
    {
        name = "Form 2 Makashi",
        icon = "icon_armor.png",
        cost = 3,
        category = "Style Walki",
        subcategory = "Makashi",
        sciezka = "item_stance_makashi",
        ilosc = nil,
        tier = 1
    },
    {
        name = "Form 3 Soresu",
        icon = "icon_armor.png",
        cost = 3,
        category = "Style Walki",
        subcategory = "Soresu",
        sciezka = "item_stance_soresu",
        ilosc = nil,
        tier = 1 
    },
    {
        name = "Form 4 Ataru",
        icon = "icon_armor.png",
        cost = 5,
        category = "Style Walki",
        subcategory = "Ataru",
        sciezka = "item_stance_ataru",
        ilosc = nil,
        tier = 1 
    },
    {
        name = "Form 4 Ataru Dual",
        icon = "icon_armor.png",
        cost = 8,
        category = "Style Walki",
        subcategory = "Ataru",
        sciezka = "item_stance_atarudual",
        ilosc = nil,
        tier = 2 
    },
    {
        name = "Form 5 Djem So",
        icon = "icon_armor.png",
        cost = 5,
        category = "Style Walki",
        subcategory = "Djem So",
        sciezka = "item_stance_djemso",
        ilosc = nil,
        tier = 1 
    },
    {
        name = "Djem So Dual",
        icon = "icon_armor.png",
        cost = 7,
        category = "Style Walki",
        subcategory = "Djem So",
        sciezka = "item_stance_djemsodual",
        ilosc = nil,
        tier = 2 
    },
    {
        name = "Form 5 Shien So",
        icon = "icon_armor.png",
        cost = 7,
        category = "Style Walki",
        subcategory = "Shien So",
        sciezka = "item_stance_shienso",
        ilosc = nil,
        tier = 1 
    },
    {
        name = "Form 6 Niman",
        icon = "icon_armor.png",
        cost = 5,
        category = "Style Walki",
        subcategory = "Niman",
        sciezka = "item_stance_niman",
        ilosc = nil,
        tier = 1 
    },
    {
        name = "Form 7 Vaapad",
        icon = "icon_armor.png",
        cost = 5,
        category = "Style Walki",
        subcategory = "Vaapad",
        sciezka = "item_stance_vaapad",
        ilosc = nil,
        tier = 1 
    },
    {
        name = "Form 7 Vaapad Dual",
        icon = "icon_armor.png",
        cost = 8,
        category = "Style Walki",
        subcategory = "Vaapad",
        sciezka = "item_stance_vaapaddual",
        ilosc = nil,
        tier = 1
    },
    {
        name = "Juggernaut",
        icon = "icon_armor.png",
        cost = 3,
        category = "Style Walki",
        subcategory = "Juggernaut",
        sciezka = "item_stance_juggernaut",
        ilosc = nil,
        tier = 1 
    },
    {
        name = "Juggernaut Dual",
        icon = "icon_armor.png",
        cost = 4,
        category = "Style Walki",
        subcategory = "Juggernaut",
        sciezka = "item_stance_juggernautdual",
        ilosc = nil,
        tier = 2 
    },
    {
        name = "Shien So Dual",
        icon = "icon_armor.png",
        cost = 7,
        category = "Style Walki",
        subcategory = "Shien So",
        sciezka = "item_stance_shiensodual",
        ilosc = nil,
        tier = 1 
    },
    {
        name = "Form 1 Shii-cho Fast",
        icon = "icon_armor.png",
        cost = 6,
        category = "Style Walki",
        subcategory = "Shii-cho",
        sciezka = "item_stance_shiichofast",
        ilosc = nil,
        tier = 3 
    },
    {
        name = "Form 3 Soresu Dual",
        icon = "icon_armor.png",
        cost = 6,
        category = "Style Walki",
        subcategory = "Soresu",
        sciezka = "item_stance_soresudual",
        ilosc = nil,
        tier = 1 
    },
    {
        name = "Versatile",  -- to powinno byc drogie
        icon = "icon_armor.png",
        cost = 6,
        category = "Style Walki",
        subcategory = "Versatile",
        sciezka = "item_stance_versatile",
        ilosc = nil,
        tier = 1 
    },
    {
        name = "Visigoth",  -- to powinno byc drogie
        icon = "icon_armor.png",
        cost = 6,
        category = "Style Walki",
        subcategory = "Visigoth",
        sciezka = "item_stance_visigoth",
        ilosc = nil,
        tier = 1 
    },
    {
        name = "Warrior",
        icon = "icon_armor.png",
        cost = 4,
        category = "Style Walki",
        subcategory = "Warrior",
        sciezka = "item_stance_warrior",
        ilosc = nil,
        tier = 1 
    },
    {
        name = "Warrior Dual",
        icon = "icon_armor.png",
        cost = 8,
        category = "Style Walki",
        subcategory = "Warrior",
        sciezka = "item_stance_warriordual",
        ilosc = nil,
        tier = 2 
    },
    {
        name = "Yong Li",
        icon = "icon_armor.png",
        cost = 5,
        category = "Style Walki",
        subcategory = "Yong Li",
        sciezka = "item_stance_yongli",
        ilosc = nil,
        tier = 1 
    },
}

--PATH lua/autorun/sh_default-configurations.lua:
return gluapack()()
--PATH addons/[bronie] kajdanki/lua/autorun/sh_handcuffs.lua:
return gluapack()()
--PATH lua/pixelui/core/cl_fonts.lua:
--[[
	PIXEL UI - Copyright Notice
	 2023 Thomas O'Sullivan - All rights reserved

	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program.  If not, see <https://www.gnu.org/licenses/>.
]]

PIXEL.UI.RegisteredFonts = PIXEL.UI.RegisteredFonts or {}
local registeredFonts = PIXEL.UI.RegisteredFonts

do
    PIXEL.UI.SharedFonts = PIXEL.UI.SharedFonts or {}
    local sharedFonts = PIXEL.UI.SharedFonts

    function PIXEL.RegisterFontUnscaled(name, font, size, weight)
        weight = weight or 500

        local identifier = font .. size .. ":" .. weight

        local fontName = "PIXEL:" .. identifier
        registeredFonts[name] = fontName

        if sharedFonts[identifier] then return end
        sharedFonts[identifier] = true

        surface.CreateFont(fontName, {
            font = font,
            size = size,
            weight = weight,
            extended = true,
            antialias = true
        })
    end
end

do
    PIXEL.UI.ScaledFonts = PIXEL.UI.ScaledFonts or {}
    local scaledFonts = PIXEL.UI.ScaledFonts

    function PIXEL.RegisterFont(name, font, size, weight)
        scaledFonts[name] = {
            font = font,
            size = size,
            weight = weight
        }

        PIXEL.RegisterFontUnscaled(name, font, PIXEL.Scale(size), weight)
    end

    hook.Add("OnScreenSizeChanged", "PIXEL.UI.ReRegisterFonts", function()
        for k,v in pairs(scaledFonts) do
            PIXEL.RegisterFont(k, v.font, v.size, v.weight)
        end
    end)
end

do
    local setFont = surface.SetFont
    local function setPixelFont(font)
        local pixelFont = registeredFonts[font]
        if pixelFont then
            setFont(pixelFont)
            return
        end

        setFont(font)
    end

    PIXEL.SetFont = setPixelFont

    local getTextSize = surface.GetTextSize
    function PIXEL.GetTextSize(text, font)
        if font then setPixelFont(font) end
        return getTextSize(text)
    end

    function PIXEL.GetRealFont(font)
        return registeredFonts[font]
    end
end

--PATH lua/pixelui/core/cl_images.lua:
return gluapack()()
--PATH lua/pixelui/drawing/cl_circle.lua:
return gluapack()()
--PATH lua/pixelui/drawing/cl_outlined_box.lua:
--[[
	PIXEL UI - Copyright Notice
	 2023 Thomas O'Sullivan - All rights reserved

	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program.  If not, see <https://www.gnu.org/licenses/>.
--]]

local setDrawColor = surface.SetDrawColor
local drawOutlinedRect = surface.DrawOutlinedRect

function PIXEL.DrawOutlinedBox(x, y, w, h, thickness, col)
    setDrawColor(col.r, col.g, col.b, col.a)
    for i = 0, thickness - 1 do
        drawOutlinedRect(x + i, y + i, w - i * 2, h - i * 2)
    end
end

local ipairs = ipairs
local setTexture = surface.SetTexture
local drawPoly = surface.DrawPoly
local drawRect = surface.DrawRect

local roundedBoxCache = {}
local whiteTexture = surface.GetTextureID("vgui/white")

function PIXEL.DrawOutlinedRoundedBox(borderSize, x, y, w, h, col, thickness)
    thickness = thickness or 1

    setDrawColor(col.r, col.g, col.b, col.a)

    if borderSize <= 0 then
        PIXEL.DrawOutlinedBox(x, y, w, h, thickness, col)
        return
    end

    local fullRight = x + w
    local fullBottom = y + h

    local left, right = x + borderSize, fullRight - borderSize
    local top, bottom = y + borderSize, fullBottom - borderSize

    local halfBorder = borderSize * .6

    local width, height = w - borderSize * 2, h - borderSize * 2

    drawRect(x, top, thickness, height) --Left
    drawRect(x + w - thickness, top, thickness, height) --Right
    drawRect(left, y, width, thickness) --Top
    drawRect(left, y + h - thickness, width, thickness) --Bottom

    local cacheName = borderSize .. x .. y .. w .. h .. thickness
    local cache = roundedBoxCache[cacheName]
    if not cache then
        cache = {
            { --Top Right
                {x = right, y = y}, --Outer
                {x = right + halfBorder, y = top - halfBorder},
                {x = fullRight, y = top},

                {x = fullRight - thickness, y = top}, --Inner
                {x = right + halfBorder - thickness, y = top - halfBorder + thickness},
                {x = right, y = y + thickness}
            },
            { --Bottom Right
                {x = fullRight, y = bottom}, --Outer
                {x = right + halfBorder, y = bottom + halfBorder},
                {x = right, y = fullBottom},

                {x = right, y = fullBottom - thickness}, --Inner
                {x = right + halfBorder - thickness, y = bottom + halfBorder - thickness},
                {x = fullRight - thickness, y = bottom}
            },
            { --Bottom Left
                {x = left, y = fullBottom}, --Outer
                {x = left - halfBorder, y = bottom + halfBorder},
                {x = x, y = bottom},

                {x = x + thickness, y = bottom}, --Inner
                {x = left - halfBorder + thickness, y = bottom + halfBorder - thickness},
                {x = left, y = fullBottom - thickness},
            },
            { --Top Left
                {x = x, y = top}, --Outer
                {x = left - halfBorder, y = top - halfBorder},
                {x = left, y = y},

                {x = left, y = y + thickness}, --Inner
                {x = left - halfBorder + thickness, y = top - halfBorder + thickness},
                {x = x + thickness, y = top}
            }
        }

        roundedBoxCache[cacheName] = cache
    end

    setTexture(whiteTexture)

    for k,v in ipairs(cache) do
        drawPoly(v)
    end
end
--PATH lua/pixelui/drawing/cl_overheads.lua:
return gluapack()()
--PATH lua/pixelui/elements/cl_check_box.lua:
return gluapack()()
--PATH lua/pixelui/elements/cl_frame.lua:
return gluapack()()
--PATH lua/pixelui/elements/cl_label.lua:
return gluapack()()
--PATH lua/pixelui/elements/cl_navbar.lua:
--[[
	PIXEL UI - Copyright Notice
	 2023 Thomas O'Sullivan - All rights reserved

	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program.  If not, see <https://www.gnu.org/licenses/>.
--]]

local PANEL = {}

AccessorFunc(PANEL, "Name", "Name", FORCE_STRING)
AccessorFunc(PANEL, "Color", "Color")

PIXEL.RegisterFont("UI.NavbarItem", "Open Sans SemiBold", 22)

function PANEL:Init()
    self:SetName("N/A")
    self:SetColor(PIXEL.Colors.Primary)

    self.NormalCol = PIXEL.Colors.PrimaryText
    self.HoverCol = PIXEL.Colors.SecondaryText

    self.TextCol = PIXEL.CopyColor(self.NormalCol)
end

function PANEL:GetItemSize()
    PIXEL.SetFont("UI.NavbarItem")
    return PIXEL.GetTextSize(self:GetName())
end

function PANEL:Paint(w, h)
    local textCol = self.NormalCol

    if self:IsHovered() then
        textCol = self.HoverCol
    end

    local animTime = FrameTime() * 12
    self.TextCol = PIXEL.LerpColor(animTime, self.TextCol, textCol)

    PIXEL.DrawSimpleText(self:GetName(), "UI.NavbarItem", w / 2, h / 2, self.TextCol, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
end

vgui.Register("PIXEL.NavbarItem", PANEL, "PIXEL.Button")

PANEL = {}

function PANEL:Init()
    self.Items = {}

    self.SelectionX = 0
    self.SelectionW = 0
    self.SelectionColor = Color(0, 0, 0)

    self.BackgroundCol = PIXEL.OffsetColor(PIXEL.Colors.Background, 10)
end

function PANEL:AddItem(id, name, doClick, order, color)
    local btn = vgui.Create("PIXEL.NavbarItem", self)

    btn:SetName(name:upper())
    btn:SetZPos(order or table.Count(self.Items) + 1)
    btn:SetColor((IsColor(color) and color) or PIXEL.Colors.Primary)
    btn.Function = doClick

    btn.DoClick = function(s)
        self:SelectItem(id)
    end

    self.Items[id] = btn
end

function PANEL:RemoveItem(id)
    local item = self.Items[id]
    if not item then return end

    item:Remove()
    self.Items[id] = nil

    if self.SelectedItem != id then return end
    self:SelectItem(next(self.Items))
end

function PANEL:SelectItem(id)
    local item = self.Items[id]
    if not item then return end

    if self.SelectedItem and self.SelectedItem == id then return end
    self.SelectedItem = id

    for k,v in pairs(self.Items) do
        v:SetToggle(false)
    end

    item:SetToggle(true)
    item.Function(item)
end

function PANEL:PerformLayout(w, h)
    for k,v in pairs(self.Items) do
        v:Dock(LEFT)
        v:SetWide(v:GetItemSize() + PIXEL.Scale(30))
    end
end

function PANEL:Paint(w, h)
    surface.SetDrawColor(self.BackgroundCol)
    surface.DrawRect(0, 0, w, h)

    if not self.SelectedItem then
        self.SelectionX = Lerp(FrameTime() * 10, self.SelectionX, 0)
        self.SelectionW = Lerp(FrameTime() * 10, self.SelectionX, 0)
        self.SelectionColor = PIXEL.LerpColor(FrameTime() * 10, self.SelectionColor, PIXEL.Colors.Primary)
        return
    end

    local selectedItem = self.Items[self.SelectedItem]
    self.SelectionX = Lerp(FrameTime() * 10, self.SelectionX, selectedItem.x)
    self.SelectionW = Lerp(FrameTime() * 10, self.SelectionW, selectedItem:GetWide())
    self.SelectionColor = PIXEL.LerpColor(FrameTime() * 10, self.SelectionColor, selectedItem:GetColor())

    local selectorH = PIXEL.Scale(6)
    surface.SetDrawColor(self.SelectionColor)
    surface.DrawRect(self.SelectionX + 2, h - selectorH, self.SelectionW - 4, selectorH / 2)
end

vgui.Register("PIXEL.Navbar", PANEL, "Panel")
--PATH lua/pixelui/elements/cl_text_entry_internal.lua:
--[[
	PIXEL UI - Copyright Notice
	 2023 Thomas O'Sullivan - All rights reserved

	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program.  If not, see <https://www.gnu.org/licenses/>.
--]]

local PANEL = {}

AccessorFunc(PANEL, "m_bAllowEnter", "EnterAllowed", FORCE_BOOL)
AccessorFunc(PANEL, "m_bUpdateOnType", "UpdateOnType", FORCE_BOOL)
AccessorFunc(PANEL, "m_bNumeric", "Numeric", FORCE_BOOL)
AccessorFunc(PANEL, "m_bHistory", "HistoryEnabled", FORCE_BOOL)
AccessorFunc(PANEL, "m_bDisableTabbing", "TabbingDisabled", FORCE_BOOL)
AccessorFunc(PANEL, "m_txtPlaceholder", "PlaceholderText", FORCE_STRING)

Derma_Install_Convar_Functions(PANEL)

PIXEL.RegisterFont("UI.TextEntry", "Open Sans SemiBold", 18)

function PANEL:Init()
    self:SetHistoryEnabled(false)
    self.History = {}
    self.HistoryPos = 0

    self:SetPaintBorderEnabled(false)
    self:SetPaintBackgroundEnabled(false)

    self:SetEnterAllowed(true)
    self:SetUpdateOnType(false)
    self:SetNumeric(false)
    self:SetAllowNonAsciiCharacters(true)

    self:SetTall(PIXEL.Scale(34))

    self.m_bLoseFocusOnClickAway = true

    self:SetCursor("beam")
    self:SetFontInternal(PIXEL.GetRealFont("UI.TextEntry"))
end

function PANEL:IsEditing()
    return self == vgui.GetKeyboardFocus()
end

function PANEL:OnKeyCodeTyped(code)
    self:OnKeyCode(code)

    if code == KEY_ENTER and not self:IsMultiline() and self:GetEnterAllowed() then
        if IsValid(self.Menu) then self.Menu:Remove() end

        self:FocusNext()
        self:OnEnter()
        self.HistoryPos = 0
    end

    if self.m_bHistory or IsValid(self.Menu) then
        if code == KEY_UP then
            self.HistoryPos = self.HistoryPos - 1
            self:UpdateFromHistory()
        end

        if code == KEY_DOWN or code == KEY_TAB then
            self.HistoryPos = self.HistoryPos + 1
            self:UpdateFromHistory()
        end
    end
end

function PANEL:OnKeyCode(code)
    local parent = self:GetParent()
    if not parent then return end

    if parent.OnKeyCode then parent:OnKeyCode() end
end

function PANEL:UpdateFromHistory()
    if IsValid(self.Menu) then return self:UpdateFromMenu() end
    local pos = self.HistoryPos

    if pos < 0 then
        pos = #self.History
    end

    if pos > #self.History then
        pos = 0
    end

    local text = self.History[pos]
    if not text then
        text = ""
    end

    self:SetText(text)
    self:SetCaretPos(text:len())
    self:OnTextChanged()
    self.HistoryPos = pos
end

function PANEL:UpdateFromMenu()
    local pos = self.HistoryPos
    local num = self.Menu:ChildCount()
    self.Menu:ClearHighlights()

    if pos < 0 then
        pos = num
    end

    if pos > num then
        pos = 0
    end

    local item = self.Menu:GetChild(pos)
    if not item then
        self:SetText("")
        self.HistoryPos = pos
        return
    end

    self.Menu:HighlightItem(item)

    local txt = item:GetText()
    self:SetText(txt)
    self:SetCaretPos(txt:len())
    self:OnTextChanged(true)
    self.HistoryPos = pos
end

function PANEL:OnTextChanged(noMenuRemoval)
    self.HistoryPos = 0

    if self:GetUpdateOnType() then
        self:UpdateConvarValue()
        self:OnValueChange(self:GetText())
    end

    if IsValid(self.Menu) and not noMenuRemoval then
        self.Menu:Remove()
    end

    local tab = self:GetAutoComplete(self:GetText())

    if tab then
        self:OpenAutoComplete(tab)
    end

    self:OnChange()
end

function PANEL:OnChange()
    local parent = self:GetParent()
    if not parent then return end

    if parent.OnChange then parent:OnChange() end
end

function PANEL:OpenAutoComplete(tab)
    if not tab then return end
    if #tab == 0 then return end
    self.Menu = DermaMenu()

    for k, v in pairs(tab) do
        self.Menu:AddOption(v, function()
            self:SetText(v)
            self:SetCaretPos(v:len())
            self:RequestFocus()
        end)
    end

    local x, y = self:LocalToScreen(0, self:GetTall())
    self.Menu:SetMinimumWidth(self:GetWide())
    self.Menu:Open(x, y, true, self)
    self.Menu:SetPos(x, y)
    self.Menu:SetMaxHeight((ScrH() - y) - 10)
end

function PANEL:Think()
    self:ConVarStringThink()
end

function PANEL:OnEnter()
    self:UpdateConvarValue()
    self:OnValueChange(self:GetText())

    local parent = self:GetParent()
    if not parent then return end

    if parent.OnEnter then parent:OnEnter() end
end

function PANEL:UpdateConvarValue()
    self:ConVarChanged(self:GetValue())
end

function PANEL:Paint(w, h)
    self:DrawTextEntryText(color_white, PIXEL.Colors.Primary, PIXEL.Colors.Primary)
end

function PANEL:SetValue(value)
    if self:IsEditing() then return end

    self:SetText(value)
    self:OnValueChange(value)
    self:SetCaretPos(self:GetCaretPos())
end

function PANEL:OnValueChange(value)
    local parent = self:GetParent()
    if not parent then return end

    if parent.OnValueChange then parent:OnValueChange(value) end
end

local numericChars = "1234567890.-"
function PANEL:CheckNumeric(value)
    if not self:GetNumeric() then return false end
    if not string.find(numericChars, value, 1, true) then return true end

    return false
end

function PANEL:AllowInput(value)
    if self:CheckNumeric(value) then return true end

    local parent = self:GetParent()
    if not parent then return end

    if parent.AllowInput then parent:AllowInput() end
end

function PANEL:SetEditable(enabled)
    self:SetKeyboardInputEnabled(enabled)
    self:SetMouseInputEnabled(enabled)
end

function PANEL:OnGetFocus()
    hook.Run("OnTextEntryGetFocus", self)

    local parent = self:GetParent()
    if not parent then return end

    if parent.OnGetFocus then parent:OnGetFocus() end
end

function PANEL:OnLoseFocus()
    self:UpdateConvarValue()
    hook.Call("OnTextEntryLoseFocus", nil, self)

    local parent = self:GetParent()
    if not parent then return end

    if parent.OnLoseFocus then parent:OnLoseFocus() end
end

function PANEL:OnMousePressed(mcode)
    self:OnGetFocus()
end

function PANEL:AddHistory(txt)
    if not txt or txt == "" then return end

    table.RemoveByValue(self.History, txt)
    table.insert(self.History, txt)
end

function PANEL:GetAutoComplete(txt)
    local parent = self:GetParent()
    if not parent then return end

    if parent.GetAutoComplete then parent:GetAutoComplete() end
end

function PANEL:GetInt()
    local num = tonumber(self:GetText())
    if not num then return end

    return math.floor(num + 0.5)
end

function PANEL:GetFloat()
    return tonumber(self:GetText())
end

vgui.Register("PIXEL.TextEntryInternal", PANEL, "TextEntry")
--PATH lua/pixelui/libraries/cl_ui3d2d.lua:
return gluapack()()
--PATH addons/[misc] siadanie/lua/sitanywhere/helpers.lua:
SitAnywhere = SitAnywhere or {}
SitAnywhere.NET = {
	["SitWantedAng"] = 0,
	["SitRequestExit"] = 1,
}

SitAnywhere.ClassBlacklist = {
	["gmod_wire_keyboard"] = true,
	["prop_combine_ball"] = true
}

SitAnywhere.DoNotParent = {
	["yava_chunk"] = true
}
SitAnywhere.ModelBlacklist = {
}

local EMETA = FindMetaTable"Entity"

function SitAnywhere.GetAreaProfile(pos, resolution, simple)
	local filter = player.GetAll()
	local dists = {}
	local distsang = {}
	local ang_smallest_hori = nil
	local smallest_hori = 90000
	local angPerIt = (360 / resolution)
	for I = 0, 360, angPerIt do
		local rad = math.rad(I)
		local dir = Vector(math.cos(rad), math.sin(rad), 0)
		local trace = util.QuickTrace(pos + dir * 20 + Vector(0,0,5), Vector(0,0,-15000), filter)
		trace.HorizontalTrace = util.QuickTrace(pos + Vector(0,0,5), dir * 1000, filter)
		trace.Distance  =  trace.StartPos:Distance(trace.HitPos)
		trace.Distance2 = trace.HorizontalTrace.StartPos:Distance(trace.HorizontalTrace.HitPos)
		trace.ang = I

		if (not trace.Hit or trace.Distance > 14) and (not trace.HorizontalTrace.Hit or trace.Distance2 > 20) then
			if simple then return true end
			table.insert(dists, trace)
		end
		if trace.Distance2 < smallest_hori and (not trace.HorizontalTrace.Hit or trace.Distance2 > 3) then
			smallest_hori = trace.Distance2
			ang_smallest_hori = I
		end
		distsang[I] = trace
	end

	if simple then return false end
	return dists, distsang, ang_smallest_hori, smallest_hori
end

function SitAnywhere.CheckValidAngForSit(pos, surfaceAng, ang)
	local rad = math.rad(ang)
	local dir = Vector(math.cos(rad), math.sin(rad), 0)
	local trace2 = util.TraceLine({
		start = pos - dir * (20 - .5) + surfaceAng:Forward() * 5,
		endpos = pos - dir * (20 - .5) + surfaceAng:Forward() * -160,
		filter = player.GetAll()
	})

	local hor_trace = util.TraceLine({
		start = pos + Vector(0, 0, 5),
		endpos = pos + Vector(0, 0, 5) - dir * 1600,
		filter = player.GetAll()
	})

	return hor_trace.StartPos:Distance(hor_trace.HitPos) > 20 and trace2.StartPos:Distance(trace2.HitPos) > 14
end


local SitOnEntsMode = CreateConVar("sitting_ent_mode","3", {FCVAR_NOTIFY, FCVAR_ARCHIVE, FCVAR_REPLICATED}, "0 = No entities\n1 = World entities only\n2 = Self-Owned, World, Unowned\n3 = Any Entity", 0, 3)
--[[
	0 - Can't sit on any ents
	1 - Can't sit on any player ents
	2 - Can only sit on your own ents
	3 - Any
]]

local blacklist = SitAnywhere.ClassBlacklist
local model_blacklist = SitAnywhere.ModelBlacklist
function SitAnywhere.ValidSitTrace(ply, EyeTrace)
	if not EyeTrace.Hit then return false end
	if EyeTrace.HitPos:Distance(EyeTrace.StartPos) > 100 then return false end
	local t = hook.Run("CheckValidSit", ply, EyeTrace)

	if t == false or t == true then
		return t
	end

	if not EyeTrace.HitWorld and SitOnEntsMode:GetInt() == 0 then return false end
	if not EyeTrace.HitWorld and blacklist[string.lower(EyeTrace.Entity:GetClass())] then return false end
	if not EyeTrace.HitWorld and EyeTrace.Entity:GetModel() and model_blacklist[string.lower(EyeTrace.Entity:GetModel())] then return false end


	if EMETA.CPPIGetOwner and SitOnEntsMode:GetInt() >= 1 then
		if SitOnEntsMode:GetInt() == 1 then
			if not EyeTrace.HitWorld then
				local owner = EyeTrace.Entity:CPPIGetOwner()
				if type(owner) == "Player" and owner ~= nil and owner:IsValid() and owner:IsPlayer() then
					return false
				end
			end
		elseif SitOnEntsMode:GetInt() == 2 then
			if not EyeTrace.HitWorld then
				local owner = EyeTrace.Entity:CPPIGetOwner()
				if type(owner) == "Player" and owner ~= nil and owner:IsValid() and owner:IsPlayer() and owner ~= ply then
					return false
				end
			end
		end
	end
	return true
end

local seatClass = "prop_vehicle_prisoner_pod"
local PMETA = FindMetaTable"Player"
function PMETA:GetSitters()
	local seats, holders = {}, {}

	local function processSeat(seat, depth)
		depth = (depth or 0) + 1
		if IsValid(seat:GetDriver()) and seat:GetDriver() ~= self then
			table.insert(seats, seat)
		end
		for _, v in pairs(seat:GetChildren()) do
			if IsValid(v) and v:GetClass() == seatClass and IsValid(v:GetDriver()) and #v:GetChildren() > 0 and depth <= 128 then
				processSeat(v, depth)
			end
		end
	end

	local plyVehicle = self:GetVehicle()
	if IsValid(plyVehicle) and plyVehicle:GetClass() == seatClass then
		processSeat(plyVehicle)
	end

	for _, v in pairs(self:GetChildren()) do
		if IsValid(v) and v:GetClass() == seatClass then
			processSeat(v)
		end
	end

	for _, v in pairs(ents.FindByClass("sit_holder")) do
		if v.GetTargetPlayer and v:GetTargetPlayer() == self then
			table.insert(holders, v)
			if v.GetSeat and IsValid(v:GetSeat()) then
				processSeat(v:GetSeat())
			end
		end
	end
	return seats, holders
end

function PMETA:IsPlayerSittingOn(ply)
	local seats = ply:GetSitters()
	for _,v in pairs(seats) do
		if IsValid(v:GetDriver()) and v:GetDriver() == self then return true end
	end
	return false
end

function PMETA:GetSitting()
	if not IsValid(self:GetVehicle()) then return false end
	local veh = self:GetVehicle()
	if veh:GetNWBool("playerdynseat", false) then
		local parent = veh:GetParent()
		if IsValid(parent) and parent:GetClass() == "sit_holder" then
			return veh, parent
		else
			return veh
		end
	end
	return false
end

function PMETA:ExitSit()
	if CLIENT then
		if self ~= LocalPlayer() then return end
		net.Start("SitAnywhere")
			net.WriteInt(SitAnywhere.NET.SitRequestExit, 4)
		net.SendToServer()
	else
		local seat, holder = self:GetSitting()
		SafeRemoveEntity(seat)
		SafeRemoveEntity(holder)

		if SitAnywhere.GroundSit and self:GetNWBool("SitGroundSitting", false) then
			self:SetNWBool("SitGroundSitting", false)
		end
	end
end

function EMETA:IsSitAnywhereSeat()
	if self:GetClass() ~= "prop_vehicle_prisoner_pod" then return false end
	if SERVER and self.playerdynseat then return true end
	return self:GetNWBool("playerdynseat", false)
end
--PATH addons/[misc] siadanie/lua/sitanywhere/client/sit.lua:
return gluapack()()
--PATH addons/[misc] siadanie/lua/sitanywhere/ground_sit.lua:
SitAnywhere = SitAnywhere or {}
SitAnywhere.GroundSit = true
local TAG = "SitAnyG_"

hook.Add("SetupMove", TAG .. "SetupMove", function(ply, mv)
	local butts = mv:GetButtons()

	if not ply:GetNWBool(TAG) then
		return
	end

	local getUp = bit.band(butts, IN_JUMP) == IN_JUMP or ply:GetMoveType() ~= MOVETYPE_WALK or ply:InVehicle() or not ply:Alive()

	if getUp then
		ply:SetNWBool(TAG, false)
	end

	local move = bit.band(butts, IN_DUCK) == IN_DUCK

	butts = bit.bxor(bit.bor(butts, bit.bor(IN_JUMP, IN_DUCK)), IN_JUMP)

	if move then
		butts =  bit.bxor(bit.bor(bit.bor(butts, IN_WALK), IN_SPEED), IN_SPEED)

		mv:SetButtons(butts)
		return
	end

	mv:SetButtons(butts)
	mv:SetSideSpeed(0)
	mv:SetForwardSpeed(0)
	mv:SetUpSpeed(0)
end)

hook.Add("CalcMainActivity", TAG .. "CalcMainActivity", function(ply, vel)
	local seq = ply:LookupSequence("pose_ducking_02")
	if ply:GetNWBool(TAG) and seq and vel:Length2DSqr() < 1 then
		return ACT_MP_SWIM, seq
	else
		return
	end
end)


if SERVER then
	local AllowGroundSit = CreateConVar("sitting_allow_ground_sit", "1", {FCVAR_ARCHIVE}, "Allows people to sit on the ground on your server", 0, 1)
	hook.Add("HandleSit", "GroundSit", function(ply, dists, EyeTrace)
		if #dists == 0 and ply:GetInfoNum("sitting_ground_sit", 1) == 1 and AllowGroundSit:GetBool() and ply:EyeAngles().p > 80 then
			local t = hook.Run("OnGroundSit", ply, EyeTrace)
			if t == false then
				return
			end

			if not ply:GetNWBool(TAG) then
				ply:SetNWBool(TAG, true)
				ply.LastSit = CurTime() + 1
				return true
			end
		end
	end)

	concommand.Add("ground_sit", function(ply)
		if AllowGroundSit:GetBool() and (not ply.LastSit or ply.LastSit < CurTime()) then
			ply:SetNWBool(TAG, not ply:GetNWBool(TAG))
			ply.LastSit = CurTime() + 1
		end
	end)
else
	CreateClientConVar("sitting_ground_sit", "1.00", true, true, "Toggles the ability for you to sit on the ground", 0, 1)
end

--PATH lua/slib/vgui/cl_slistpanel.lua:
local font = slib.createFont("Roboto", 14)
local textcolor, neutralcolor, successcolor, failcolor, maincolor_7, maincolor_10, maincolor_15, maincolor_25 = slib.getTheme("textcolor"), slib.getTheme("neutralcolor"), slib.getTheme("successcolor"), slib.getTheme("failcolor"), slib.getTheme("maincolor", 7), slib.getTheme("maincolor", 10), slib.getTheme("maincolor", 15), slib.getTheme("maincolor", 25)

local PANEL = {}

function PANEL:Init()
    self:Dock(TOP)
    self:SetTall(slib.getScaledSize(250, "y"))
    self:DockMargin(slib.getTheme("margin"),0,slib.getTheme("margin"),slib.getTheme("margin"))

    self.frame = vgui.Create("SScrollPanel", self)
    self.frame:Dock(FILL)

    self.frame.Paint = function(s,w,h)
        surface.SetDrawColor(maincolor_10)
        surface.DrawRect(0, 0, w, h)
    end

    self.selected = false

    slib.wrapFunction(self, "SetZPos", nil, function() return self end, true)
    slib.wrapFunction(self, "SetTall", nil, function() return self end, true)
    slib.wrapFunction(self, "DockMargin", nil, function() return self end, true)
    slib.wrapFunction(self, "Dock", nil, function() return self end, true)
end

function PANEL:addEntry(var, toggleable, tab)
    title = var
    if !isstring(var) and IsValid(var) and var:IsPlayer() then title = var:Nick() end

    local selectable = vgui.Create("DButton", self.frame)
    selectable:SetTall(slib.getScaledSize(25, "y"))
    selectable:Dock(TOP)
    selectable:DockMargin(slib.getTheme("margin"),slib.getTheme("margin"),slib.getTheme("margin"),0)
    selectable:SetText("")
    selectable.name = title
    selectable.tab = tab
    selectable.toggleable = toggleable

    selectable.Paint = function(s,w,h)
        if !isstring(var) and !IsValid(var) then s:Remove() return end

        local wantedcolor
        
        if s.toggleable then
            if isfunction(s.toggleCheck) then
                wantedcolor = s.toggleCheck() and successcolor or failcolor
            end
        else
            wantedcolor = neutralcolor
        end

        wantedcolor.a = 40
        if !s.toggleable and self.selected ~= var then
            wantedcolor.a = 0
        end
        
        surface.SetDrawColor(slib.lerpColor(s, wantedcolor))
        surface.DrawRect(0, 0, w, h)

        surface.SetDrawColor(maincolor_25)
        surface.DrawOutlinedRect(0, 0, w, h)


        draw.SimpleText(selectable.name, font, 5, h * .5, textcolor, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
    end

    selectable.DoClick = function()
        self.selected = (self.selected ~= var) and var or nil 
    end

    return self, selectable
end

function PANEL:setTitle(title)
    self.title = title

    if !self.topbar then
        self.topbar = vgui.Create("EditablePanel", self)
        self.topbar:SetTall(slib.getScaledSize(25, "y"))
        self.topbar:Dock(TOP)

        self.topbar.Paint = function(s,w,h)
            surface.SetDrawColor(maincolor_7)
            surface.DrawRect(0, 0, w, h)

            surface.SetDrawColor(maincolor_25)
            surface.DrawRect(0,h-1,w,1)

            draw.SimpleText(self.title, font, slib.getTheme("margin"), h * .5, textcolor, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
        end
    end

    return self
end

function PANEL:addSearchbar()
    self.search = vgui.Create("SSearchBar", self.topbar)
    self.search:Dock(RIGHT)
    :DockMargin(slib.getTheme("margin"),slib.getTheme("margin"),slib.getTheme("margin"),slib.getTheme("margin"))

    self.search.entry.bg = maincolor_15
    self.search.entry.onValueChange = function(newval)
        for k,v in pairs(self.frame:GetCanvas():GetChildren()) do
            v:SetVisible(string.find(string.lower(v.name), string.lower(newval)))

            self.frame:GetCanvas():InvalidateLayout(true)
        end
    end

    self.topbar.OnSizeChanged = function()
        self.search:SetWide(self.topbar:GetWide() * .35)
    end

    return self
end

function PANEL:addDropdown()
    self.dropdown = vgui.Create("SDropDown", self.topbar)
    self.dropdown:Dock(RIGHT)
    :DockMargin(slib.getTheme("margin"),slib.getTheme("margin"),slib.getTheme("margin"),slib.getTheme("margin"))

    self.dropdown.bg = maincolor_15
    
    self.dropdown.onValueChange = function(newtab)
        for k,v in pairs(self.frame:GetCanvas():GetChildren()) do
            v:SetVisible(v.tab == newtab)
            self.frame:GetCanvas():InvalidateLayout(true)
        end
    end

    self.topbar.OnSizeChanged = function()
        self.dropdown:SetWide(self.topbar:GetWide() * .35)
    end

    return self.dropdown
end

function PANEL:addButton(title, func, thnk)
    if !self.bottombar then
		self.bottombar = vgui.Create("EditablePanel", self)
		self.bottombar:Dock(BOTTOM)
		self.bottombar:SetTall(slib.getScaledSize(25,"x"))

		self.bottombar.Paint = function(s,w,h)
			surface.SetDrawColor(maincolor_25)
			surface.DrawRect(0, 0, w, 1)
		end
    end

    local bttn = vgui.Create("SButton", self.bottombar)
    bttn:Dock(LEFT)
    :setTitle(title)
    :DockMargin(slib.getTheme("margin"),slib.getTheme("margin"),0,slib.getTheme("margin"))
    
    bttn.DoClick = function() func(self, bttn) end

    if thnk then
        bttn.Think = function() thnk(self, bttn) end
    end

    return self, bttn
end

function PANEL:Paint(w,h)
    surface.SetDrawColor(maincolor_10)
    surface.DrawRect(0, 0, w, h)
end

vgui.Register("SListPanel", PANEL, "EditablePanel")
--PATH lua/slib/vgui/cl_sscrollpanel.lua:
local PANEL = {}

local elegantcol, maincol, maincol_5 = Color(255,255,255,3), slib.getTheme("maincolor"), slib.getTheme("maincolor", 5)

function PANEL:Init()
    local scr = self:GetVBar()
    scr:SetHideButtons(true)

    scr.Paint = function(_, w, h)
        surface.SetDrawColor(self.scrollbg or maincol)
        surface.DrawRect(0,0,w,h)
    end    
    scr.btnUp.Paint = function(_, w, h)end
    scr.btnDown.Paint = function(_, w, h)end
    scr.btnGrip.Paint = function(_, w, h)
        draw.RoundedBoxEx(h * .5, w * 0.5 - (w * 0.45 / 2), h * 0.03, w * 0.45, h - h * 0.06, elegantcol, true, true, true, true)
    end

    slib.wrapFunction(self, "SetSize", nil, function() return self end, true)
	slib.wrapFunction(self, "Center", nil, function() return self end, true)
	slib.wrapFunction(self, "SetPos", nil, function() return self end, true)
    slib.wrapFunction(self, "Dock", nil, function() return self end, true)
    slib.wrapFunction(self, "DockMargin", nil, function() return self end, true)
    slib.wrapFunction(self, "SetTall", nil, function() return self end, true)
end

function PANEL:Paint(w,h)
    if self.bg then
        surface.SetDrawColor(self.bg)
        surface.DrawRect(0,0,w,h)
    end
end

vgui.Register("SScrollPanel", PANEL, "DScrollPanel")
--PATH addons/[admin] gprotect_1.15.101/lua/g_protect/sh_cppi.lua:
gProtect = gProtect or {}
gProtect.EmptyFuncs = gProtect.EmptyFuncs or {}
CPPI = CPPI or {}

local ENTITY = FindMetaTable("Entity")
local PLAYER = FindMetaTable("Player")



-- Create empty functions to prevent nil errors.
if !ENTITY.CPPIGetOwner then
    function ENTITY:CPPIGetOwner() end
    gProtect.EmptyFuncs["CPPIGetOwner"] = ENTITY.CPPIGetOwner
end

if !ENTITY.CPPISetOwner then
    function ENTITY:CPPISetOwner() end
end

local function overrideCPPI()
    ENTITY.oldCPPIGetOwner = ENTITY.oldCPPIGetOwner or (ENTITY.CPPIGetOwner != gProtect.EmptyFuncs["CPPIGetOwner"] and ENTITY.CPPIGetOwner)
    function ENTITY:CPPIGetOwner()
        local result = gProtect.GetOwner(self)
        
        if isstring(result) and isfunction(ENTITY.oldCPPIGetOwner) then result = self:oldCPPIGetOwner() end

        return SERVER and gProtect.ownershipCache[self] or (isstring(result) and nil or result), 200
    end

    function PLAYER:CPPIGetFriends()
        local friends_tbl = CLIENT and gProtect.BuddiesData or gProtect.TouchPermission
        local sid = self:SteamID()
        local found_friends = {}
        local result = {}

        if friends_tbl[sid] then
            for k, v in pairs(friends_tbl[sid]) do
                if !istable(v) then continue end
                for sid, v in pairs(v) do
                    found_friends[sid] = true
                end
            end
        end

        for k, v in pairs(found_friends) do
            table.insert(result, k)
        end
        
        return result
    end

    if SERVER then
        ENTITY.oldCPPISetOwner = ENTITY.oldCPPISetOwner or ENTITY.CPPISetOwner
        function ENTITY:CPPISetOwner(ply)
            if isfunction(ENTITY.oldCPPISetOwner) then
                self:oldCPPISetOwner(ply)
            end

            if !IsValid(ply) then return end
            gProtect.SetOwner(ply, self)
        end

        function ENTITY:CPPICanTool(ply, tool)            
            return gProtect.HandlePermissions(ply, self, "gmod_tool")
        end
    
        function ENTITY:CPPICanPhysgun(ply)
            if SERVER and !gProtect.HandlePhysgunPermission(ply, self) then return false end

            return gProtect.HandlePermissions(ply, self, "weapon_physgun")
        end
    
        function ENTITY:CPPICanPickup(ply)
            return gProtect.HandlePermissions(ply, self, "weapon_physcannon")
        end
    
        function ENTITY:CPPICanPunt(ply)
            if cfg.enabled and (cfg.DisableGravityGunPunting or (IsValid(ent) and cfg.blockedEntities[ent:GetClass()])) then return false end

            return true
        end
    end
end

timer.Simple(3, function()
    overrideCPPI()
end)
--PATH addons/[admin] gprotect_1.15.101/lua/g_protect/client/cl_blockedmodels.lua:
return gluapack()()
--PATH addons/[misc] smartspawnmanager/lua/autorun/smartspawn/sh_config.lua:
return gluapack()()
--PATH addons/[misc] smartspawnmanager/lua/autorun/smartspawn/plugins/sh_notify.lua:
//
/*
	Shared Notifications
	Smart Like My Shoe
	3/3/2018
*/

local notify = {};
local netMsg = "smart_spawn_notify";

if (SERVER) then 

	/*
		Pooled strings 
	*/
	util.AddNetworkString(netMsg);

	/*
		Sends a net message to the client 
	*/
	function notify:NotifyPlayer(ply, message, duration)
	
		net.Start(netMsg);
		
			net.WriteString(message);
			net.WriteUInt(duration, 32);
		net.Send(ply);
	end

else // CLIENT 

	local smartDerma = include("cl_derma.lua");

	notify.activeNotifications = {};

	function notify:GenerateNotification(text, duration)
		
		local index = 1;
		for i = 1, 30 do 
			if (self.activeNotifications[i] == nil) then 
				self.activeNotifications[i] = true;
				index = i;
				break;
			end 
		end 

		smartDerma:Notification(text, duration, index);
		
		timer.Simple(duration, function()
			if (self.activeNotifications[index]) then 
				self.activeNotifications[index] = nil;
			end
		end);
	end 
	
	function notify.ReceiveNotification(len)
		notify:GenerateNotification(net.ReadString(), net.ReadUInt(32));
	end 
	net.Receive(netMsg, notify.ReceiveNotification);
end

return notify;
--PATH lua/autorun/snx_statuseffects.lua:
return gluapack()()
--PATH lua/autorun/soldier_addon.lua:
return gluapack()()
--PATH addons/[misc] sreward_1.6.31/lua/s_reward/languages/sh_english.lua:
return gluapack()()
--PATH addons/[misc] sreward_1.6.31/lua/s_reward/languages/sh_turkish.lua:
if CLIENT then
    slib.setLang("sreward", "tr", "general", "Genel")
    slib.setLang("sreward", "tr", "submit", "Sun")
    slib.setLang("sreward", "tr", "tasks", "Grevler")
    slib.setLang("sreward", "tr", "referral", "Referans")
    slib.setLang("sreward", "tr", "shop", "Maaza")
    slib.setLang("sreward", "tr", "leaderboard", "Skor Tablosu")
    slib.setLang("sreward", "tr", "coupons", "Kuponlar")

    slib.setLang("sreward", "tr", "main_title", "sReward - dl Sistemi")
    slib.setLang("sreward", "tr", "title_admin", "sReward - Admin")

    slib.setLang("sreward", "tr", "rewards_title", "%s - dller")
    slib.setLang("sreward", "tr", "coupon_title", "Kuponlar")

    slib.setLang("sreward", "tr", "coupon_receive_title", "Yeni kupon!!")
    slib.setLang("sreward", "tr", "coupon_receive", "Yeni bir kupon elde ettin, \n    kupon envanterine gz at!") --- Had to fine tune like that :(

    slib.setLang("sreward", "tr", "copied_clipboard", "Panoya kopyaland!")
    slib.setLang("sreward", "tr", "no_coupons", "Kuponun bulunmamakta!")

    slib.setLang("sreward", "tr", "delete", "Sil")
    slib.setLang("sreward", "tr", "yes", "Evet")
    slib.setLang("sreward", "tr", "no", "Hayr")
    slib.setLang("sreward", "tr", "reffered_me", "Bana referans oldu")

    slib.setLang("sreward", "tr", "are_you_sure", "Emin misin?")
    slib.setLang("sreward", "tr", "manage", "Ynet")

    slib.setLang("sreward", "tr", "tokens", "Jetonlar")
    slib.setLang("sreward", "tr", "select_reward", "dl Se")
    slib.setLang("sreward", "tr", "number", "Say")

    slib.setLang("sreward", "tr", "submit", "Sun")
    slib.setLang("sreward", "tr", "name", "sim")
    slib.setLang("sreward", "tr", "uses", "Kullanlar")
    slib.setLang("sreward", "tr", "used", "Kullanlm")
    slib.setLang("sreward", "tr", "task", "Grev")
    slib.setLang("sreward", "tr", "verify", "Onayla")
    slib.setLang("sreward", "tr", "total_tokens", "Btn Jetonlar")
    slib.setLang("sreward", "tr", "referrals", "Referanslar")

    slib.setLang("sreward", "tr", "rewards", "ddller")
    slib.setLang("sreward", "tr", "price", "cret")
    slib.setLang("sreward", "tr", "imgur_id", "Imgur ID")

    slib.setLang("sreward", "tr", "edit_rewards", "dlleri Dzenle")
    slib.setLang("sreward", "tr", "save", "Kaydet")

    slib.setLang("sreward", "tr", "insert_imgur_id", "Imgur ID'yi Yerletirin")
    slib.setLang("sreward", "tr", "insert_name", "sim Giriniz")
    slib.setLang("sreward", "tr", "insert_price", "Fiyat Giriniz")

    slib.setLang("sreward", "tr", "create_coupon", "Kupon Olutur")
    slib.setLang("sreward", "tr", "coupon_name", "Kupon smi")

    slib.setLang("sreward", "tr", "create_shopitem", "Maaza Eyas Olutur")
    slib.setLang("sreward", "tr", "item_name", "Eya Ad")

    slib.setLang("sreward", "tr", "this_will_cost", "'%s' sana %s jetona mal olacak!")
    slib.setLang("sreward", "tr", "coupon_delete_confirm", "Bu '%s' kuponunu silecek, emin misin?")
    slib.setLang("sreward", "tr", "this_delete", "Bu '%s''y silecek")

    slib.setLang("sreward", "tr", "manage_item", "Eyay Ynet")

    slib.setLang("sreward", "tr", "discord_failed_application_com", "Discord uygulaman bulamadk, alr halde olduundan emin olun!")
    slib.setLang("sreward", "tr", "discord_error_retrieving_data", "Discorddan bilgi edinirken hatayla karlatk, yetkililere ltfen bunu bildiriniz!")
else
    slib.setLang("sreward", "tr", "cooldown", "Onaylanmak iin beklemen lazm, ltfen %s saniye bekleyiniz!")

    slib.setLang("sreward", "tr", "added_queue", "'%s''nn kontrol srasna eklendin, %s saniye ierisinde cevap alacaksn!")

    slib.setLang("sreward", "tr", "added_steamgroup_queue", "Steam Grubuna katlp katlmadnz kontrol ediliyor, %s saniye ierisinde bilgilendirileceksiniz!")
    slib.setLang("sreward", "tr", "didnt_find_steamgroup", "Steam Grubunda sizi bulamadk, ltfen tekrar deneyin!")
    slib.setLang("sreward", "tr", "failed_verification", "'%s' dln onaylayamadk, grevi tamamen bitirdiinizden emin olun.")
    
    slib.setLang("sreward", "tr", "discord_error_retrieving_data", "Discord'a ulaamadk, ltfen daha sonra tekrar deneyiniz!")
    slib.setLang("sreward", "tr", "checking_wait", "'%s' dln kontrol ederken ltfen bekleyiniz!")

    slib.setLang("sreward", "tr", "steam_unsuccessfull", "Steam'a ulaamadk, ltfen daha sonra tekrar deneyiniz!")
    slib.setLang("sreward", "tr", "steam_private", "Steam gruplarnza bakamadk, hesabnzn gizli olmadndan emin olun ve ltfen daha sonra tekrar deneyiniz!!")
    slib.setLang("sreward", "tr", "success_reward", "'%s' dln aldn!")

    slib.setLang("sreward", "tr", "referral_limit", "Maksimum referans limitine ulatn!")
    slib.setLang("sreward", "tr", "referred_person", "%s tarafndan referans gsterildin!")
    slib.setLang("sreward", "tr", "referred_by", "%s senin tarafndan referans edildin!")

    slib.setLang("sreward", "tr", "mysql_successfull", "Veri tabanna baaryla balandk!")
    slib.setLang("sreward", "tr", "mysql_failed", "Veri tabanna balanamadk!")
    slib.setLang("sreward", "tr", "cannot_afford", "Bunu karlayamazsn!")
    slib.setLang("sreward", "tr", "successfull_purchase", "'%s''y baaryla satn aldn!")

    slib.setLang("sreward", "tr", "taken_tokens", "Birisi senden %s jeton ald, Bakiyen toplam %s jeton!")
    slib.setLang("sreward", "tr", "given_tokens", "Birisi sana %s jeton verdi, Bakiyen toplam %s jeton!")
    slib.setLang("sreward", "tr", "given_reward", "Birisi sana '%s' dln verdi!")

    slib.setLang("sreward", "tr", "performed_admin_action", "'%s''ya '%s' miktarnda yetkili eylemi uyguladn")
    slib.setLang("sreward", "tr", "coupon_out_of_stock", "'%s' kuponu elimizde kalmad, ltfen yksek mecralara ulaarak stoumuzu yeniletin!")
end

slib.setLang("sreward", "tr", "on_cooldown", "Bu dl yeniden kullanmak iin %s saniye beklemeniz lazm!")

slib.setLang("sreward", "tr", "max_use_reached", "Bu dln kullanma limitine ulatnz!")

slib.setLang("sreward", "tr", "sr_tokens", "sR Jotenleri")

slib.setLang("sreward", "tr", "darkrp_money", "DarkRP Paras")

slib.setLang("sreward", "tr", "reward_rank", "Rtbe")

slib.setLang("sreward", "tr", "coupon", "Kupon")

slib.setLang("sreward", "tr", "give_weapon", "Silah Ver")

slib.setLang("sreward", "tr", "basewars_money", "Basewars Paras")
slib.setLang("sreward", "tr", "basewars_level", "Basewars Seviyesi")

slib.setLang("sreward", "tr", "vrondakis_level", "Seviye")
slib.setLang("sreward", "tr", "vrondakis_xp", "TP")

slib.setLang("sreward", "tr", "glorified_level", "Seviye")
slib.setLang("sreward", "tr", "glorified_xp", "TP")

slib.setLang("sreward", "tr", "essentials_level", "Seviye")
slib.setLang("sreward", "tr", "essentials_xp", "TP")

slib.setLang("sreward", "tr", "elite_xp", "TP")

slib.setLang("sreward", "tr", "ps1_points", "PS1 Puanlar")

slib.setLang("sreward", "tr", "ps2_standard_points", "PS2 Standart Puanlar")
slib.setLang("sreward", "tr", "ps2_premium_points", "PS2 Premium Puanlar")

slib.setLang("sreward", "tr", "sh_ps_standard_points", "SH PS Standart Puanlar")
slib.setLang("sreward", "tr", "sh_ps_premium_points", "SH PS Premium Puanlar")

slib.setLang("sreward", "tr", "give_tokens", "Jeton Ver")
slib.setLang("sreward", "tr", "give_reward", "dl Ver")
slib.setLang("sreward", "tr", "take_tokens", "Jeton Al")
--PATH addons/[misc] sreward_1.6.31/lua/s_reward/rewards/sh_rank.lua:
return gluapack()()
--PATH addons/[misc] sreward_1.6.31/lua/s_reward/rewards/sh_rank.lua:
sReward.RegisterReward("reward_rank", function(ply, rank)
    slib.setRank(ply, rank)
end, Material("sreward/rank.png", "smooth"))
--PATH addons/[misc] sreward_1.6.31/lua/s_reward/rewards/sh_voidcases.lua:
return gluapack()()
--PATH addons/[misc] sreward_1.6.31/lua/s_reward/rewards/sh_wos.lua:
sReward.RegisterReward("wos_level", function(ply, level)
    if !isfunction(ply.SetSkillLevel) then return end
    local oldLevel = ply:GetSkillLevel()
    ply:SetSkillLevel(oldLevel + level)
end, Material("sreward/level-up.png", "smooth"))

sReward.RegisterReward("wos_xp", function(ply, xp)
    if !isfunction(ply.SetSkillXP) then return end
    local oldXP = ply:GetSkillXP()
    ply:SetSkillXP(oldXP + xp)
end)

sReward.RegisterReward("wos_points", function(ply, points)
    if !isfunction(ply.SetSkillPoints) then return end
    local oldPoints = ply:GetSkillPoints()
    ply:SetSkillPoints(oldPoints + points)
end, Material("sreward/points.png", "smooth"))

sReward.RegisterReward("wos_giveitem", function(ply, item_name)
    if !isfunction(wOS.HandleItemPickup) then return end

    wOS:HandleItemPickup(ply, item_name)
end)
--PATH lua/streamradio_core/_include.lua:
-- 3D Stream Radio. Made By Grocel.

if not StreamRadioLib then return end
local LIB = StreamRadioLib

local loadSH = LIB.LoadSH
local loadCL = LIB.LoadCL
local loadSV = LIB.LoadSV

if not loadSH then return end
if not loadCL then return end
if not loadSV then return end

LIB.DataDirectory = "streamradio"

do
    local status, lib = loadSH("streamradio_core/external/neturl.lua")

    LIB.NetURL = nil

    if status then
        LIB.NetURL = lib
    end
end

loadSH("streamradio_core/api.lua")
loadSH("streamradio_core/string.lua")
loadSH("streamradio_core/string_accents.lua")
loadSH("streamradio_core/util.lua")
loadSH("streamradio_core/url.lua")
loadSH("streamradio_core/hook.lua")
loadSH("streamradio_core/timedpairs.lua")
loadSH("streamradio_core/convar.lua")
loadSH("streamradio_core/language.lua")
loadSH("streamradio_core/bass3.lua")
loadSH("streamradio_core/lib.lua")
loadSH("streamradio_core/enum.lua")
loadSH("streamradio_core/error.lua")
loadSH("streamradio_core/stream.lua")
loadSH("streamradio_core/json.lua")
loadSH("streamradio_core/network.lua")
loadSH("streamradio_core/net.lua")
loadSH("streamradio_core/timer.lua")
loadSH("streamradio_core/tool.lua")
loadSH("streamradio_core/http.lua")
loadSH("streamradio_core/shoutcast.lua")
loadSH("streamradio_core/skin.lua")
loadSH("streamradio_core/models.lua")
loadSH("streamradio_core/interface.lua")
loadSH("streamradio_core/filesystem.lua")
loadSH("streamradio_core/cache.lua")
loadSH("streamradio_core/classes.lua")
loadSH("streamradio_core/properties.lua")
loadSH("streamradio_core/print.lua")
loadSH("streamradio_core/cfchttp.lua")
loadSH("streamradio_core/vr.lua")
loadSH("streamradio_core/wire.lua")

loadSV("streamradio_core/server/sv_lib.lua")
loadSV("streamradio_core/server/sv_resource.lua")
loadSV("streamradio_core/server/sv_playlist_edit.lua")
loadSV("streamradio_core/server/sv_permaprops.lua")
loadSV("streamradio_core/server/sv_whitelist.lua")

loadCL("streamradio_core/client/cl_help.lua")
loadCL("streamradio_core/client/cl_lib.lua")
loadCL("streamradio_core/client/cl_presets.lua")
loadCL("streamradio_core/client/cl_menu.lua")
loadCL("streamradio_core/client/cl_settings.lua")
loadCL("streamradio_core/client/settings/admin.lua")
loadCL("streamradio_core/client/settings/general.lua")
loadCL("streamradio_core/client/settings/vr.lua")
loadCL("streamradio_core/client/cl_skin.lua")
loadCL("streamradio_core/client/cl_surface.lua")
loadCL("streamradio_core/client/cl_playlist_edit.lua")
loadCL("streamradio_core/client/cl_vgui.lua")
loadCL("streamradio_core/client/cl_vgui_editor.lua")
loadCL("streamradio_core/client/cl_whitelist.lua")

StreamRadioLib.Url.Load()
StreamRadioLib.Interface.Load()
StreamRadioLib.Filesystem.Load()

StreamRadioLib.Whitelist.Load()

StreamRadioLib.Cfchttp.Load()
StreamRadioLib.Cache.Load()

return true


--PATH lua/streamradio_core/api.lua:
return gluapack()()
--PATH lua/streamradio_core/timedpairs.lua:
return gluapack()()
--PATH lua/streamradio_core/error.lua:
local StreamRadioLib = StreamRadioLib

StreamRadioLib.Error = StreamRadioLib.Error or {}

local LIB = StreamRadioLib.Error
table.Empty(LIB)

local g_errorListById = {}
local g_errorListByName = {}

local g_emptyDescription = "Error {{ERROR_CODE}} is unknown"
local g_emptyHelpText = [[
There is no help text for error {{ERROR_CODE}} ({{ERROR_NAME}}).

Please report this! Include the URL and the error code in the report!
]]

local g_commonErrorFile = [[
There was no file or content found at the given path.

If you try to play an online file:
	- Do not forget the protocol prefix such as 'http://'.
	- Make sure the file exist at the given URL. It should be downloadable.
	- Make sure the format is supported and the file is not broken. (See below.)

If you try to play a local file:
	- Make sure the file exist at the given path.
	- Make sure the file is readable for Garry's Mod.
	- The path must be relative your "<path_to_game>/garrysmod/sound/" folder. (See below.)
	- The file must be in "<path_to_game>/garrysmod/sound/" folder. (See below.)
	- You can play mounted stuff in "<path_to_game>/garrysmod/sound/".
	- You can not play sound scripts or sound properties.
	- Make sure the format is supported and the file is not broken. (See below.)

Supported formats:
	MP3, OGG, AAC, WAV, WMA, FLAC
	*.WAV files must be not self-looping in game as the API does not support these.

How local or mounted file paths work:
	- If you have a file located "<path_to_game>/garrysmod/sound/mymusic/song.mp3" you access it with these urls:
	* file://mymusic/song.mp3
	* mymusic/song.mp3"

	- For files in "<path_to_game>/garrysmod/sound/filename.mp3" you get them like this:
	* file://filename.mp3
	* filename.mp3

	- Files outside the game folder are forbidden to be accessed by the game.
	- Do not enter absolute paths.
	- Only people who also have the same file localed there, will be able to hear the music too.
	- Create folders if they are missing.
]]

local g_commonErrorFileUrl = "https://steamcommunity.com/workshop/filedetails/discussion/246756300/523897277918001392/"

local g_commonErrorFormat = [[
You are trying to play something that the streaming API of GMod (and so the radio) does not support.

These things will NOT work:
	- HTML pages that play sound.
	- Flash players/games/applications that are playing sound.
	- Anything that requires any kind of login to access.
	- Anything that is not public.
	- Sound scripts or sound properties.
	- Broken files or unsupported formats. (See below.)

These things will work:
	- URLs to sound files (aka. DIRECT download).
	- URLs to playlist files of radio stations. If they do not offer them, you will be not able to play them.
	- URLs inside these playlists files.
	- Local sound files inside your "<path_to_game>/garrysmod/sound/" folder. Examble: "music/hl1_song10.mp3"
	- You may have to install addional codices to your OS.
	- Formats that are listed below.

Supported formats:
	MP3, OGG, AAC, WAV, WMA, FLAC
	*.WAV files must be not self-looping ingame as the API does not support these.
]]

local g_commonErrorFormatUrl = "https://steamcommunity.com/workshop/filedetails/discussion/246756300/523897277918028290/"

local g_commonErrorBrokenUrl = [[
Something went wrong with parsing the URL.
It could have been blocked by the server to prevent abuse.

Please talk to an admin about this before you report this issue.
]]

local function replacePlaceholder(subject, placeholder, value)
	subject = tostring(subject or "")
	placeholder = tostring(placeholder or "")
	value = tostring(value or "")

	return string.Replace(subject, placeholder, value)
end

local function cleanNewLines(str)
	str = string.gsub(str, "\r", "")
	str = string.Trim(str)

	return str
end

local function processErrorInfo(info)
	local id = info.id
	local name = info.name
	local description = info.description or ""
	local helptext = info.helptext or ""
	local helpurl = info.helpurl or ""

	description = replacePlaceholder(description, "{{ERROR_CODE}}", id)
	description = replacePlaceholder(description, "{{ERROR_NAME}}", name)

	helptext = replacePlaceholder(helptext, "{{ERROR_CODE}}", id)
	helptext = replacePlaceholder(helptext, "{{ERROR_NAME}}", name)
	helptext = replacePlaceholder(helptext, "{{ERROR_DESCRIPTION}}", description)
	helptext = replacePlaceholder(helptext, "{{ERROR_HELPURL}}", helpurl)

	helptext = cleanNewLines(helptext)

	info.description = description
	info.helptext = helptext
end

local function createUnknownErrorInfo(idOrName)
	local info = {}

	if isstring(idOrName) then
		info.id = LIB.STREAM_ERROR_UNKNOWN
		info.name = idOrName
	else
		info.id = idOrName
		info.name = "STREAM_ERROR_UNKNOWN"
	end

	info.description = g_emptyDescription
	info.helptext = g_emptyHelpText
	info.helpmenu = true

	processErrorInfo(info)
	return info
end


function LIB.AddStreamErrorCode(data)
	local id = data.id
	local name = data.name
	local description = data.description
	local helptext = data.helptext
	local helpurl = data.helpurl
	local helpmenu = data.helpmenu
	local userdata = data.userdata

	if not id then
		error("id is missing")
	end

	if not name or name == "" then
		error("name is missing or empty")
	end

	if helpmenu == nil then
		helpmenu = true
	end

	id = tonumber(id) or -1
	name = tostring(name)
	name = string.upper(name)

	local info = {
		id = id,
		name = name,
		helpmenu = helpmenu,
	}

	if userdata then
		info.userdata = table.Copy(userdata)
	end

	LIB[name] = id

	g_errorListById[id] = info
	g_errorListByName[name] = info

	LIB.AddStreamDescription(id, description)
	LIB.AddStreamErrorHelp(id, helptext, helpurl)
end

function LIB.AddStreamDescription(idOrName, description)
	local info = LIB.GetStreamErrorInfo(idOrName)
	if not info then
		return
	end

	local id = info.id
	local name = info.name

	description = tostring(description or "")

	if description == "" then
		description = g_emptyDescription
	end

	description = replacePlaceholder(description, "{{ERROR_CODE}}", id)
	description = replacePlaceholder(description, "{{ERROR_NAME}}", name)

	info.description = description
end

function LIB.AddStreamErrorHelp(idOrName, helptext, helpurl)
	local info = LIB.GetStreamErrorInfo(idOrName)
	if not info then
		return
	end

	local id = info.id
	local name = info.name
	local description = info.description

	helptext = tostring(helptext or "")
	helpurl = tostring(helpurl or "")

	if helptext == "" then
		helptext = g_emptyHelpText
	end

	helptext = replacePlaceholder(helptext, "{{ERROR_CODE}}", id)
	helptext = replacePlaceholder(helptext, "{{ERROR_NAME}}", name)
	helptext = replacePlaceholder(helptext, "{{ERROR_DESCRIPTION}}", description)
	helptext = replacePlaceholder(helptext, "{{ERROR_HELPURL}}", helpurl)

	helptext = cleanNewLines(helptext)

	info.helptext = helptext
	info.helpurl = helpurl
end

function LIB.GetStreamErrorInfo(idOrName)
	if not idOrName or idOrName == "" then
		idOrName = LIB.STREAM_ERROR_UNKNOWN
	end

	local errorList = nil

	if isstring(idOrName) then
		errorList = g_errorListByName
	else
		errorList = g_errorListById
	end

	local info = errorList[idOrName]
	if not info then
		info = createUnknownErrorInfo(idOrName)
	end

	return info
end

function LIB.GetStreamErrorId(idOrName)
	local info = LIB.GetStreamErrorInfo(idOrName)
	if not info then
		return nil
	end

	return info.id
end

function LIB.GetStreamErrorName(idOrName)
	local info = LIB.GetStreamErrorInfo(idOrName)
	if not info then
		return nil
	end

	return info.name
end

function LIB.GetStreamErrorDescription(idOrName)
	local info = LIB.GetStreamErrorInfo(idOrName)
	if not info then
		return nil
	end

	return info.description
end

LIB.AddStreamErrorCode({
	id = -1,
	name = "STREAM_ERROR_UNKNOWN",
	description = "Unknown Error",
	helptext = [[
The exact cause of this error is unknown.

This error is usually caused by:
	- Invalid file pathes or URLs without the protocol prefix such as 'http://'.
	- Attempting to play self-looping *.WAV files.
]],
})

LIB.AddStreamErrorCode({
	id = 0,
	name = "STREAM_OK",
	description = "OK",
	helpmenu = false,
	helptext = [[
Everything should be fine. You should not see this.
]],
})

LIB.AddStreamErrorCode({
	id = 1,
	name = "STREAM_ERROR_MEM",
	description = "Memory Error",
	helptext = [[
A memory error is always bad.
You proably ran out of it.
]],
})

LIB.AddStreamErrorCode({
	id = 2,
	name = "STREAM_ERROR_FILEOPEN",
	description = "Can't open the file",
	helptext = g_commonErrorFile,
	helpurl = g_commonErrorFileUrl
})

LIB.AddStreamErrorCode({
	id = 3,
	name = "STREAM_ERROR_DRIVER",
	description = "Can't find a free/valid driver",
	helptext = [[
Something is wrong with your sound hardware or your sound drivers.
]],
})

LIB.AddStreamErrorCode({
	id = 4,
	name = "STREAM_ERROR_BUFLOST",
	description = "The sample buffer was lost",
	helptext = [[
Your sound driver/interface was lost.

To fix it you need to do this:
- Plugin your speakers or head phones.
- Enable the sound device.
- Restart the game. Do not just disconnect!
- Restart your PC, if it still not works.
]],
})

LIB.AddStreamErrorCode({
	id = 5,
	name = "STREAM_ERROR_HANDLE",
	description = "Invalid handle",
	helptext = "",
})

LIB.AddStreamErrorCode({
	id = 6,
	name = "STREAM_ERROR_FORMAT",
	description = "Unsupported sample format",
	helptext = g_commonErrorFormat,
	helpurl = g_commonErrorFormatUrl,
})

LIB.AddStreamErrorCode({
	id = 7,
	name = "STREAM_ERROR_POSITION",
	description = "Invalid position",
	helptext = "",
})

LIB.AddStreamErrorCode({
	id = 8,
	name = "STREAM_ERROR_INIT",
	description = "BASS_Init has not been successfully called",
	helptext = "",
})

LIB.AddStreamErrorCode({
	id = 9,
	name = "STREAM_ERROR_START",
	description = "BASS_Start has not been successfully called",
	helptext = "",
})

LIB.AddStreamErrorCode({
	id = 10,
	name = "STREAM_ERROR_SSL",
	description = "SSL/HTTPS support isn't available",
	helptext =  [[
The SSL handshake for HTTPS did failed to validate the connection.
Please check the URL being legit and your operating system to be up to date.
]],
})

LIB.AddStreamErrorCode({
	id = 11,
	name = "STREAM_ERROR_REINIT",
	description = "Device needs to be reinitialized",
	helptext = "",
})

LIB.AddStreamErrorCode({
	id = 14,
	name = "STREAM_ERROR_ALREADY",
	description = "Already initialized/paused/whatever",
	helptext = "",
})

LIB.AddStreamErrorCode({
	id = 17,
	name = "STREAM_ERROR_NOTAUDIO",
	description = "File does not contain audio",
	helptext = g_commonErrorFormat,
	helpurl = g_commonErrorFormatUrl,
})

LIB.AddStreamErrorCode({
	id = 18,
	name = "STREAM_ERROR_NOCHAN",
	description = "Can't get a free channel",
	helptext = [[
A memory error is always bad.
You proably ran out of it.
]],
})

LIB.AddStreamErrorCode({
	id = 19,
	name = "STREAM_ERROR_ILLTYPE",
	description = "An illegal type was specified",
	helptext = g_commonErrorBrokenUrl,
})

LIB.AddStreamErrorCode({
	id = 20,
	name = "STREAM_ERROR_ILLPARAM",
	description = "An illegal parameter was specified",
	helptext = g_commonErrorBrokenUrl,
})

LIB.AddStreamErrorCode({
	id = 21,
	name = "STREAM_ERROR_NO3D",
	description = "No 3D support",
	helptext = [[
Something is wrong with your sound hardware or your sound drivers.
It does not support 3D world sound.
]],
})

LIB.AddStreamErrorCode({
	id = 22,
	name = "STREAM_ERROR_NOEAX",
	description = "No EAX support",
	helptext = [[
Something is wrong with your sound hardware or your sound drivers.
It does not support EAX-effects.
]],
})

LIB.AddStreamErrorCode({
	id = 23,
	name = "STREAM_ERROR_DEVICE",
	description = "Illegal device number",
	helptext = "",
})

LIB.AddStreamErrorCode({
	id = 24,
	name = "STREAM_ERROR_NOPLAY",
	description = "Not playing",
	helptext = "",
})

LIB.AddStreamErrorCode({
	id = 25,
	name = "STREAM_ERROR_FREQ",
	description = "Illegal sample rate",
	helptext = "",
})

LIB.AddStreamErrorCode({
	id = 27,
	name = "STREAM_ERROR_NOTFILE",
	description = "The stream is not a file stream",
	helptext = g_commonErrorFile,
	helpurl = g_commonErrorFileUrl
})

LIB.AddStreamErrorCode({
	id = 29,
	name = "STREAM_ERROR_NOHW",
	description = "No hardware voices available",
	helptext = [[
Something is wrong with your sound hardware. Out of memory?
]],
})

LIB.AddStreamErrorCode({
	id = 31,
	name = "STREAM_ERROR_EMPTY",
	description = "The MOD music has no sequence data",
	helptext = g_commonErrorFormat,
	helpurl = g_commonErrorFormatUrl,
})

LIB.AddStreamErrorCode({
	id = 32,
	name = "STREAM_ERROR_NONET",
	description = "No internet connection could be opened",
	helptext = [[
You internet connection is not working.
Please check your network devices and your firewall.
]],
})

LIB.AddStreamErrorCode({
	id = 33,
	name = "STREAM_ERROR_CREATE",
	description = "Couldn't create the file",
	helptext = "",
})

LIB.AddStreamErrorCode({
	id = 34,
	name = "STREAM_ERROR_NOFX",
	description = "Effects are not available",
	helptext = [[
Something is wrong with your sound hardware or your sound drivers.
It does not support EAX-effects.
]],
})

LIB.AddStreamErrorCode({
	id = 37,
	name = "STREAM_ERROR_NOTAVAIL",
	description = "Requested data/action is not available",
	helptext = [[
Your sound driver/interface was lost.

To fix it you need to do this:
- Plugin your speakers or head phones.
- Enable the sound device.
- Restart the game. Do not just disconnect!
- Restart your PC, if it still not works.
]],
})

LIB.AddStreamErrorCode({
	id = 38,
	name = "STREAM_ERROR_DECODE",
	description = "The channel is a 'decoding channel'",
	helptext = "",
})

LIB.AddStreamErrorCode({
	id = 39,
	name = "STREAM_ERROR_DX",
	description = "A sufficient DirectX version is not installed",
	helptext = [[
Something is wrong with your sound hardware or your sound drivers.
DirectX seems to be outdated or not installed.
]],
})

LIB.AddStreamErrorCode({
	id = 40,
	name = "STREAM_ERROR_TIMEOUT",
	description = "Connection timedout",
	helptext = [[
The connection seems being slow. Just try again in a few minutes.
If it does not work, the server you are trying to stream from is available.
]],
})

LIB.AddStreamErrorCode({
	id = 41,
	name = "STREAM_ERROR_FILEFORM",
	description = "Unsupported file format",
	helptext = g_commonErrorFormat,
	helpurl = g_commonErrorFormatUrl,
})

LIB.AddStreamErrorCode({
	id = 42,
	name = "STREAM_ERROR_SPEAKER",
	description = "Unavailable speaker",
	helptext = [[
Something is wrong with your sound hardware or your sound drivers.
Do you even have speakers?
]],
})

LIB.AddStreamErrorCode({
	id = 43,
	name = "STREAM_ERROR_VERSION",
	description = "Invalid BASS version (used by add-ons)",
	helptext = "",
})

LIB.AddStreamErrorCode({
	id = 44,
	name = "STREAM_ERROR_CODEC",
	description = "Codec is not available/supported",
	helptext = g_commonErrorFormat,
	helpurl = g_commonErrorFormatUrl,
})

LIB.AddStreamErrorCode({
	id = 45,
	name = "STREAM_ERROR_ENDED",
	description = "The channel/file has ended",
	helptext = "",
})

LIB.AddStreamErrorCode({
	id = 46,
	name = "STREAM_ERROR_BUSY",
	description = "The device is busy",
	helptext = "",
})

LIB.AddStreamErrorCode({
	id = 47,
	name = "STREAM_ERROR_UNSTREAMABLE",
	description = "Unstreamable file",
	helptext = g_commonErrorFormat,
	helpurl = g_commonErrorFormatUrl,
})

LIB.AddStreamErrorCode({
	id = 48,
	name = "STREAM_ERROR_PROTOCOL",
	description = "Unsupported protocol",
	helptext = g_commonErrorBrokenUrl,
})

LIB.AddStreamErrorCode({
	id = 49,
	name = "STREAM_ERROR_DENIED",
	description = "Access denied",
	helptext = [[
Can not access the resource. Login credentials required, but not supported.

CAUTION: Do not try to access private resources! Credentials could leak to other connected players or the server!

Better use public resources only.
]],
})


LIB.AddStreamErrorCode({
	id = 1000,
	name = "STREAM_ERROR_URL_NOT_WHITELISTED",
	description = "This URL is not whitelisted on this server",
	helpurl = "https://steamcommunity.com/workshop/filedetails/discussion/246756300/3884977551668761564/",
	helptext = [[
The server does not allow playback of this URL to prevent abuse.
You can ask an admin to whitelist this URL by adding it to the playlists.

CAUTION: Please don't ask to have the whitelist disabled or removed. It is there for your own security. Ask your admin for details.
]],
})

LIB.AddStreamErrorCode({
	id = 1001,
	name = "STREAM_ERROR_URL_BLOCKED",
	description = "This URL is blocked on this server",
	helpurl = "https://steamcommunity.com/workshop/filedetails/discussion/246756300/3884977551668761564/",
	helptext = [[
The server does not allow playback of this URL to prevent abuse. It has been blocked by external code.

CAUTION: Please don't ask to have this block disabled or removed. It is there for your own security. Ask your admin for details.
]],
})

LIB.AddStreamErrorCode({
	id = 1010,
	name = "STREAM_ERROR_WIRE_ADVOUT_DISABLED",
	description = "Advanced outputs are disabled",
	helptext = "",
})

LIB.AddStreamErrorCode({
	id = 1020,
	name = "STREAM_ERROR_MISSING_GM_BASS3",
	description = "GM_BASS3 is missing",
	helptext = "",
})

LIB.AddStreamErrorCode({
	id = 1030,
	name = "STREAM_ERROR_BAD_DRIVE_LETTER_PATH",
	description = "Drive letter paths are not supported, use relative paths",
	helptext = [[
Do not use drive letter paths. Use relative paths instead.

A relative path never starts with a drive letter such as "C:/" or "D:/".

This is a relative path:
  music/hl1_song3.mp3

This is NOT a relative path:
  C:/Program Files (x86)/Steam/steamapps/common/GarrysMod/garrysmod/sound/music/hl1_song3.mp3
]],
})

LIB.AddStreamErrorCode({
	id = 1100,
	name = "PLAYLIST_ERROR_INVALID_FILE",
	description = "Invalid Playlist",
	helptext = [[
The Playlist file you are trying to load is invalid.

This could be the problem:
	- The playlist could not be found or read.
	- Its format is not supported.
	- It is broken.
	- It is empty.

Supported playlist formats:
	M3U, PLS, VDF, JSON

Playlists are located at "<path_to_game>/garrysmod/data/streamradio/playlists/".

Hint: Use the playlist editor to make playlists.
]],
	helpurl = "https://steamcommunity.com/workshop/filedetails/discussion/246756300/523897277917951293/",
})

LIB.AddStreamErrorCode({
	id = 1200,
	name = "STREAM_SOUND_STOPPED", -- triggered by "stopsound" concommand
	description = "The sound has been stopped",
	helpmenu = false,
	helptext = "",
})


if CLIENT then
	local function ShowErrorInfo( ply, cmd, args )
		local param = args[1]

		if not param or param == "" then
			MsgN("You need to enter a valid error code.")
			return
		end

		local errorcode = tonumber(param) or tostring(param)
		local errorInfo = LIB.GetStreamErrorInfo(errorcode)

		local id = errorInfo.id
		local name = errorInfo.name
		local description = errorInfo.description
		local helptext = errorInfo.helptext
		local helpurl = errorInfo.helpurl or ""

		if helpurl == "" then
			helpurl = "(no url)"
		end

		local format = [[
Getting info for error code "%s":

Id: %i
Name: %s
Description: %s

Help text:
%s

Help URL: %s
]]

		format = cleanNewLines(format)

		local errstr = string.format(
			format,
			errorcode,
			id,
			name,
			description,
			helptext,
			helpurl
		)

		local message = StreamRadioLib.AddonPrefix .. errstr
		MsgN(message)
	end

	concommand.Add( "info_streamradio_errorcode", ShowErrorInfo )
end

return true


--PATH lua/streamradio_core/network.lua:
local StreamRadioLib = StreamRadioLib

StreamRadioLib.Network = StreamRadioLib.Network or {}
StreamRadioLib.Network_Debug = StreamRadioLib.Network_Debug or {}

local LIB = StreamRadioLib.Network
table.Empty(LIB)

local LIBDebug = StreamRadioLib.Network_Debug
table.Empty(LIBDebug)

local LIBUtil = StreamRadioLib.Util

local emptyTableSafe = LIBUtil.EmptyTableSafe

local g_addonprefix = "3DStreamRadio/"
local g_maxIdentifierLen = 44

local g_networkStack = {}

local g_networkMaxStackSize = 4096
local g_networkStackBatchSize = 128

local g_types = {
	["Angle"] = {
		check = function(value)
			return isangle(value)
		end,
		convert = nil,
		dtmaxcount = 32,
		nwGetter = "GetNW2Angle",
		nwSetter = "SetNW2Angle",
	},

	["Bool"] = {
		check = function(value)
			return isbool(value)
		end,
		convert = function(v)
			return tobool(v)
		end,
		dtmaxcount = 32,
		nwGetter = "GetNW2Bool",
		nwSetter = "SetNW2Bool",
	},

	["Entity"] = {
		check = function(value)
			return IsEntity(value)
		end,
		convert = nil,
		dtmaxcount = 32,
		nwGetter = "GetNW2Entity",
		nwSetter = "SetNW2Entity",
	},

	["Float"] = {
		check = function(value)
			return isnumber(value)
		end,
		convert = nil,
		dtmaxcount = 32,
		nwGetter = "GetNW2Float",
		nwSetter = "SetNW2Float",
	},

	["Int"] = {
		check = function(value)
			return isnumber(value)
		end,
		convert = function(v)
			return math.floor(v)
		end,
		dtmaxcount = 32,
		nwGetter = "GetNW2Int",
		nwSetter = "SetNW2Int",
	},

	["String"] = {
		check = function(value)
			return isstring(value)
		end,
		convert = nil,
		dtmaxcount = 0,
		nwGetter = "GetNW2String",
		nwSetter = "SetNW2String",
	},

	["Vector"] = {
		check = function(value)
			return isvector(value)
		end,
		convert = nil,
		dtmaxcount = 32,
		nwGetter = "GetNW2Vector",
		nwSetter = "SetNW2Vector",
	},
}

function LIB.SetupEntityTable(ent)
	if not IsValid(ent) then
		return
	end

	if ent._entityTableSetup then
		return
	end

	ent._entityTableSetup = true

	local entTable = ent:GetTable()

	for datatype, dtd in pairs(g_types) do
		local nwGetter = dtd.nwGetter
		local nwSetter = dtd.nwSetter

		entTable[nwGetter] = ent[nwGetter]
		entTable[nwSetter] = ent[nwSetter]
	end

	entTable.NetworkVar = ent.NetworkVar
	entTable.NWOverflowKill = ent.NWOverflowKill

	entTable.StreamRadioDT = ent.StreamRadioDT or {}
	entTable.StreamRadioNW = ent.StreamRadioNW or {}

	entTable.IsValid = ent.IsValid
	entTable.IsMarkedForDeletion = ent.IsMarkedForDeletion
end

function LIB.TransformNWIdentifier(str)
	str = tostring(str or "")
	assert(str ~= "", "identifier is empty")

	str = g_addonprefix .. str

	local strLen = #str
	assert(strLen < g_maxIdentifierLen, "identifier '" .. str .. "' must shorter than " .. g_maxIdentifierLen .. " chars, got " .. strLen .. " chars")

	return str
end

function LIB.UntransformNWIdentifier(str)
	str = tostring(str or "")
	assert(str ~= "", "identifier is empty")

	local strLen = #str
	assert(strLen < g_maxIdentifierLen, "identifier '" .. str .. "' must shorter than " .. g_maxIdentifierLen .. " chars, got " .. strLen .. " chars")

	str = string.gsub(str, "^" .. string.PatternSafe(g_addonprefix), "", 1)
	return str
end

function LIB.AddNetworkStringRaw(str)
	str = tostring(str or "")
	assert(str ~= "", "identifier is empty")

	local strLen = #str
	assert(strLen < g_maxIdentifierLen, "identifier '" .. str .. "' must shorter than " .. g_maxIdentifierLen .. " chars, got " .. strLen .. " chars")

	local currentId = util.NetworkStringToID(str) or 0

	if CLIENT then
		return currentId
	end

	if currentId ~= 0 then
		return currentId
	end

	util.AddNetworkString(str)

	local newId = util.NetworkStringToID(str) or 0
	assert(newId ~= 0, "Could not add network string for '" .. str .. "'! Is network string table is full?")
	assert(util.NetworkIDToString(newId) == str, "Could not add network string at ID '" .. newId .. "' for '" .. newId .. "'! Is network string table is full?")

	return newId
end

function LIB.AddNetworkString(str)
	str = LIB.TransformNWIdentifier(str)

	local id = LIB.AddNetworkStringRaw(str)
	return id
end

function LIB.NetworkStringToID(str)
	str = LIB.TransformNWIdentifier(str)

	local id = util.NetworkStringToID(str) or 0
	return id
end

function LIB.NetworkIDToString(id)
	id = tonumber(id or 0) or 0
	if id == 0 then
		return nil
	end

	local str = util.NetworkIDToString(id)
	if not str then
		return nil
	end

	str = LIB.UntransformNWIdentifier(str)
	return str
end

local function DTNetworkVarExists(entTable, name)
	local NW = entTable.StreamRadioDT
	if not NW then return false end

	local Names = NW.Names
	if not Names then return false end

	local data = Names[name]
	if not data then return false end
	if not data.datatype then return false end

	return true
end

local function CanAddDTNetworkVar(entTable, datatype, name, ...)
	name = tostring(name or "")
	datatype = tostring(datatype or "")

	if name == "" then return false end
	if not g_types[datatype] then return false end

	local NW = entTable.StreamRadioDT
	if not NW then return false end

	local count = NW.Count or {}
	count = count[datatype] or 0

	local maxcount = g_types[datatype].dtmaxcount or 0

	if count >= maxcount then return false end
	return true
end

do
	local loopThis = function(datatype, dtd)
		local checkfunc = dtd.check
		local convertfunc = dtd.convert
		local nwGetter = dtd.nwGetter
		local nwSetter = dtd.nwSetter

		local nwGetterFunc = function(entTable, key, defaultvalue)
			if not entTable then
				return defaultvalue
			end

			key = LIB.TransformNWIdentifier(key)

			local ent = entTable.Entity

			if not ent then
				return defaultvalue
			end

			if not entTable.IsValid(ent) then
				return defaultvalue
			end

			local getter = entTable[nwGetter]
			if not getter then
				return defaultvalue
			end

			local r = getter(ent, key, defaultvalue)
			if r == nil and defaultvalue ~= nil then
				r = defaultvalue
			end

			return r
		end

		local nwSetterFunc = function(entTable, key, value)
			if CLIENT then
				return
			end

			if not entTable then
				return
			end

			key = LIB.TransformNWIdentifier(key)
			value = convertfunc and convertfunc(value) or value

			assert(checkfunc(value), "invalid datatype of value at '" .. key .. "', '" .. datatype .. "' was expected, got '" .. type(value) .. "'")

			local ent = entTable.Entity

			if not ent then
				return
			end

			if not entTable.IsValid(ent) then
				return
			end

			if entTable.IsMarkedForDeletion(ent) then
				return
			end

			local data = {ent, entTable, entTable[nwSetter], key, value}
			table.insert(g_networkStack, data)
		end

		LIB["GetNW" .. datatype] = nwGetterFunc
		LIB["SetNW" .. datatype] = nwSetterFunc

		dtd.nwSetterFunc = nwSetterFunc
		dtd.nwGetterFunc = nwGetterFunc
	end

	for datatype, dtd in pairs(g_types) do
		loopThis(datatype, dtd)
	end
end

function LIB.GetNWVar(entTable, datatype, key, defaultvalue)
	key = tostring(key or "")
	datatype = tostring(datatype or "")

	assert(g_types[datatype] ~= nil, "argument #2 must be a valid datatype! Got '" .. datatype .. "'")
	assert(key ~= "", "argument #3 is an invalid name!")

	local dtd = g_types[datatype or ""]
	if not dtd then return defaultvalue end
	if not dtd.nwGetterFunc then return defaultvalue end

	local r = dtd.nwGetterFunc(entTable, key, defaultvalue)
	return r
end

function LIB.SetNWVar(entTable, datatype, key, value)
	if CLIENT then
		return
	end

	key = tostring(key or "")
	datatype = tostring(datatype or "")

	assert(g_types[datatype] ~= nil, "argument #2 must be a valid datatype! Got '" .. datatype .. "'")
	assert(key ~= "", "argument #3 is an invalid name!")

	local dtd = g_types[datatype or ""]
	if not dtd then return end
	if not dtd.nwSetterFunc then return end

	dtd.nwSetterFunc(entTable, key, value)
end

function LIB.SetupDataTables(entOrOntTable)
	local ent = nil
	local entTable = nil

	if istable(entOrOntTable) then
		ent = entOrOntTable.Entity
		entTable = entOrOntTable
	else
		ent = entOrOntTable
		entTable = entOrOntTable:GetTable()
	end

	if not entTable then return end
	LIB.SetupEntityTable(ent)

	local NW = entTable.StreamRadioDT
	if not NW then return end

	NW.Setup = true
end

local function pollNWVarsLoopThis(NW, entTable, name, data)
	if not data.callback then return end
	if not data.datatype then return end

	local oldvalue = data.oldvalue
	local newvalue = LIB.GetNWVar(entTable, data.datatype, name)

	if oldvalue == newvalue then return end

	local ent = entTable.Entity

	data.callback(ent, name, oldvalue, newvalue)

	data.oldvalue = newvalue
end

local function pollNWVars(entTable)
	local NW = entTable.StreamRadioNW
	if not NW then return end

	local Names = NW.Names
	if not Names then return end

	for name, data in pairs(Names) do
		pollNWVarsLoopThis(NW, entTable, name, data)
	end
end

local function pollDTVarsLoopThis(NW, entTable, name, data)
	if not data.callback then return end
	if not data.datatype then return end
	if not DTNetworkVarExists(entTable, name) then return end

	local oldvalue = data.oldvalue
	local newvalue = LIB.GetDTNetworkVar(entTable, name)

	if oldvalue == newvalue then return end

	local ent = entTable.Entity

	data.callback(ent, name, oldvalue, newvalue)

	data.oldvalue = newvalue
end

local function pollDTVars(entTable)
	local NW = entTable.StreamRadioDT
	if not NW then return end
	if not NW.Setup then return end

	local Names = NW.Names
	if not Names then return end

	for name, data in pairs(Names) do
		pollDTVarsLoopThis(NW, entTable, name, data)
	end
end

local function pollNwStackKillThis(stackItem)
	local entTable = stackItem[1]
	if not entTable then return end

	local ent = entTable.Entity

	if not entTable.IsValid(ent) then return end
	if entTable._NWOverflowKilled then return end

	entTable.NWOverflowKill(ent)
	entTable._NWOverflowKilled = true
end

local function pollNwStackLoopThis(stackItem)
	local ent = stackItem[1]
	local entTable = stackItem[2]
	local setter = stackItem[3]
	local key = stackItem[4]
	local value = stackItem[5]

	if not ent then return end
	if not setter then return end

	if not entTable then return end
	if not entTable.IsValid(ent) then return end
	if entTable.IsMarkedForDeletion(ent) then return end

	setter(ent, key, value)
end

function LIB.PollNwStack()
	if CLIENT then
		return
	end

	if not StreamRadioLib.HasSpawnedRadios() then
		-- clean up any left overs, just in case
		emptyTableSafe(g_networkStack)
		return
	end

	local count = 0

	for pointer, stackItem in pairs(g_networkStack) do
		g_networkStack[pointer] = nil

		if stackItem then
			-- network entity data chunk wise
			pollNwStackLoopThis(stackItem)

			count = count + 1
			if count >= g_networkStackBatchSize then
				break
			end
		end
	end

	if #g_networkStack > g_networkMaxStackSize then
		-- we have a very high counter

		local count = table.Count(g_networkStack)
		-- actually count them, they can mismatch

		if count > g_networkMaxStackSize then
			-- still too high, kill the overflow by removing affected entities.

			for pointer, stackItem in pairs(g_networkStack) do
				g_networkStack[pointer] = nil

				if count > g_networkMaxStackSize then
					if stackItem then
						pollNwStackKillThis(stackItem)
					end
				end

				count = math.max(count - 1, 0)
			end
		end
	end
end

function LIB.Poll(entTable)
	pollNWVars(entTable)
	pollDTVars(entTable)
end

function LIB.AddDTNetworkVar(entTable, datatype, name, ...)
	name = tostring(name or "")
	datatype = tostring(datatype or "")

	assert(g_types[datatype], "argument #1 is an invalid datatype!")
	assert(name ~= "", "argument #2 is an invalid name!")

	if DTNetworkVarExists(entTable, name) then return true end
	if not CanAddDTNetworkVar(entTable, datatype, name) then return false end

	local NW = entTable.StreamRadioDT
	if not NW then return false end

	local Setup = NW.Setup or false

	NW.Count = NW.Count or {}
	local Count = NW.Count

	local index = (Count[datatype] or 0) + 1

	NW.Names = NW.Names or {}
	local Names = NW.Names

	Names[name] = Names[name] or {}
	local data = Names[name]

	data.datatype = datatype
	data.args = {...}
	data.index = data.index or index

	index = data.index
	Count[datatype] = index

	local ent = entTable.Entity

	if Setup then
		entTable.NetworkVar(ent, datatype, index - 1, name, ...)

		if data.value ~= nil then
			LIB.SetDTNetworkVar(entTable, name, data.value)
			data.value = nil
		end
	end

	return true
end

function LIB.GetDTNetworkVar(entTable, name, defaultvalue)
	if not DTNetworkVarExists(entTable, name) then
		return defaultvalue
	end

	local ent = entTable.Entity

	local getter = entTable["Get" .. name]
	if not getter then return defaultvalue end

	local value = getter(ent, defaultvalue)
	if value == nil then
		value = defaultvalue
	end

	return value
end

function LIB.SetDTNetworkVar(entTable, name, value)
	if CLIENT then return end

	local ent = entTable.Entity

	if not DTNetworkVarExists(entTable, name) then
		return
	end

	local oldvalue = LIB.GetDTNetworkVar(entTable, name)
	if oldvalue == value then return end

	local setter = entTable["Set" .. name]
	if not setter then return end

	setter(ent, value)
end

function LIB.SetDTVarCallback(entTable, name, func)
	name = tostring(name or "")

	assert(name ~= "", "argument #2 is an invalid name!")
	assert(isfunction(func), "argument #3 must be a function!")

	local NW = entTable.StreamRadioDT
	if not NW then return end

	NW.Names = NW.Names or {}
	local Names = NW.Names

	Names[name] = Names[name] or {}
	local data = Names[name]

	data.callback = func
	data.oldvalue = nil
end

function LIB.SetNWVarCallback(entTable, datatype, name, func)
	datatype = tostring(datatype or "")
	name = tostring(name or "")

	assert(g_types[datatype] ~= nil, "argument #2 must be a valid datatype! Got '" .. datatype .. "'")
	assert(name ~= "", "argument #3 is an invalid name!")
	assert(isfunction(func), "argument #4 must be a function!")

	local NW = entTable.StreamRadioNW
	if not NW then return end

	NW.Names = NW.Names or {}
	local Names = NW.Names

	Names[name] = Names[name] or {}
	local data = Names[name]

	data.callback = func
	data.datatype = datatype
	data.oldvalue = nil
end

local function hashToBin(str)
	str = string.gsub(str, "..", function(cc)
		local c = tonumber(cc, 16)

		if c == 0 then
			-- avoid zero termination
			return "\\0"
		end

		return string.char(c)
	end)

	return str
end

function LIB.Hash(str)
	local hash = StreamRadioLib.Util.Hash(str)
	hash = hashToBin(hash)

	return hash
end

StreamRadioLib.Hook.Add("Tick", "Entity_Network_Tick", function()
	if not StreamRadioLib then return end
	if not StreamRadioLib.Loaded then return end
	if not StreamRadioLib.SpawnedRadios then return end

	LIB.PollNwStack()

	for index, ent in pairs(StreamRadioLib.SpawnedRadios) do
		if not ent then
			continue
		end

		local entTable = ent:GetTable()
		if not entTable then
			continue
		end

		if not entTable.IsValid(ent) then
			continue
		end

		LIB.Poll(entTable)
	end
end)

function LIBDebug.DumpDTNetworkStats(ent)
	local entTable = ent:GetTable()
	if not entTable then
		return
	end

	local NW = entTable.StreamRadioDT or {}
	local Count = NW.Count or {}

	MsgN("DumpDTNetworkStats of: " .. tostring(ent))
	MsgN("======================")

	for datatype, dtd in pairs(g_types) do
		local c = Count[datatype] or 0
		local maxc = dtd.dtmaxcount or 0

		local per = 1

		if maxc <= 0 then
			maxc = 0
		else
			per = math.Round(c / maxc, 3)
		end

		per = per * 100

		MsgN(datatype, c .. " / " .. maxc, per .. " %")
	end

	MsgN("======================")
end

function LIBDebug.DumpDTNetworkVars(ent)
	local entTable = ent:GetTable()
	if not entTable then
		return
	end

	local NW = entTable.StreamRadioDT or {}

	MsgN("DumpDTNetworkVars of: " .. tostring(ent))
	MsgN("======================")

	for name, data in pairs(NW.Names) do
		local line = string.format("%s (%s) [%i] | %s", name, data.datatype, data.index, LIB.GetDTNetworkVar(entTable, name))
		MsgN(line)
	end

	MsgN("======================")
end

local function getAddonStringTable()
	local max = 4096
	local result = {}

	for k = 1, max do
		local name = util.NetworkIDToString(k)

		if not name then
			break
		end

		if not string.find(name, "^" .. string.PatternSafe(g_addonprefix)) then
			continue
		end

		result[#result + 1] = {
			index = k,
			name = name,
		}
	end

	return result
end

function LIBDebug.DumpDTNetworkStringTable()
	MsgN("DumpDTNetworkStringTable")
	MsgN("======================")

	local max = 4096
	local stringTable = getAddonStringTable()
	local countAssigned = 0
	local countAddon = #stringTable

	for k = 1, max do
		local name = util.NetworkIDToString(k)

		if not name then
			break
		end

		countAssigned = countAssigned + 1
	end

	for i, value in ipairs(stringTable) do
		local index = value.index
		local name = value.name

		MsgN(index, "\t", name)
	end

	local fractionMax = countAddon / max
	local fractionAssigned = countAddon / countAssigned

	MsgN("======================")
	MsgN(countAddon .. " of " .. max .. " slots total, " .. (math.Round(fractionMax, 3) * 100) .. '%')
	MsgN(countAddon .. " of " .. countAssigned .. " slots assigned, " .. (math.Round(fractionAssigned, 3) * 100) .. '%')
	MsgN("======================")
end

function LIBDebug.DumpDTNetworkStringTableCode()
	MsgN("DumpDTNetworkStringTableCode")
	MsgN("======================")

	MsgN("")
	MsgN("local LIBNetwork = StreamRadioLib.Network")
	MsgN("")
	MsgN("do")
	MsgN("    -- Automaticly generated network string table map")
	MsgN("")

	local stringTable = getAddonStringTable()

	for i, value in ipairs(stringTable) do
		local name = LIB.UntransformNWIdentifier(value.name)

		local code = string.format("    LIBNetwork.AddNetworkString(\"%s\")", name)
		MsgN(code)
	end

	MsgN("end")
	MsgN("")
	MsgN("======================")
end

do
	local concommandFlags = FCVAR_NONE

	if CLIENT then
		concommandFlags = FCVAR_CHEAT
	end

	concommand.Add("debug_streamradio_dump_nwstringtable", function(ply)
		if not StreamRadioLib.Util.IsAdminForCMD(ply) then
			return
		end

		LIBDebug.DumpDTNetworkStringTable()
	end, nil, nil, concommandFlags)

	concommand.Add("debug_streamradio_dump_nwstringtable_code", function(ply)
		if not StreamRadioLib.Util.IsAdminForCMD(ply) then
			return
		end

		LIBDebug.DumpDTNetworkStringTableCode()
	end, nil, nil, concommandFlags)
end

return true


--PATH lua/streamradio_core/tool.lua:
local StreamRadioLib = StreamRadioLib

StreamRadioLib.Tool = StreamRadioLib.Tool or {}

local LIB = StreamRadioLib.Tool
table.Empty(LIB)

local LIBNetwork = StreamRadioLib.Network
local LIBNet = StreamRadioLib.Net

function LIB.GetTool(ply, toolmode)
	if not IsValid(ply) then
		if SERVER then
			return nil
		end

		ply = LocalPlayer()
	end

	if not IsValid(ply) then
		return nil
	end

	local toolobj = ply:GetTool(toolmode)
	if not toolobj then
		return nil
	end

	if toolobj.Mode ~= toolmode then
		return nil
	end

	return toolobj
end

local g_locale_specialcases = {
	["Undone_"] = true,
	["SBoxLimit_"] = true,
	["Cleanup_"] = true,
	["Cleaned_"] = true,
}

function LIB.AddLocale(toolobj, name, translation)
	if SERVER then return end
	assert(toolobj, "ToolOBJ needed #1")

	name = tostring(name or "")
	assert(name ~= "", "name needed #2")

	translation = tostring(translation or "")
	assert(translation ~= "", "translation needed #3")

	local toolmode = toolobj.Mode

	if g_locale_specialcases[name] then
		language.Add(name .. toolmode, translation)
		return
	end

	language.Add("Tool." .. toolmode .. "." .. name, translation)
end

function LIB.GetLocale(toolobj, name)
	if SERVER then return end
	assert(toolobj, "ToolOBJ needed #1")

	name = tostring(name or "")
	assert(name ~= "", "name needed #2")

	local toolmode = toolobj.Mode
	return "#Tool." .. toolmode .. "." .. name
end

function LIB.GetLocaleTranslation(toolobj, name)
	if SERVER then return end
	assert(toolobj, "ToolOBJ needed #1")

	name = tostring(name or "")
	assert(name ~= "", "name needed #2")

	local toolmode = toolobj.Mode
	return language.GetPhrase("#Tool." .. toolmode .. "." .. name)
end

function LIB.AdvWeld( ent, traceEntity, tracePhysicsBone, DOR, collision, AllowWorldWeld, freeze )
	if not SERVER then return end
	if not IsValid(ent) then return end

	if IsValid(traceEntity) then
		if traceEntity:IsNPC() then return end
		if traceEntity:IsPlayer() then return end
	end

	local IsEnt = IsValid(traceEntity) and not traceEntity:IsWorld()
	local phys = ent:GetPhysicsObject()

	if AllowWorldWeld or IsEnt then
		local const = constraint.Weld(ent, traceEntity, 0, tracePhysicsBone, 0, not collision, DOR)

		-- Don't disable collision if it is not attached to anything
		if (not collision and IsValid(const)) then
			if IsValid( phys ) then
				phys:EnableCollisions(collision)
			end

			ent.nocollide = not collision
		end

		if IsValid(phys) then
			phys:EnableMotion(not (freeze or AllowWorldWeld and not IsEnt))
		end

		return const
	else
		if IsValid(phys) then
			phys:EnableMotion(not (freeze or AllowWorldWeld))
		end

		return nil
	end
end

LIB.g_reloadpanels = LIB.g_reloadpanels or {}
local g_reloadpanels = LIB.g_reloadpanels

function LIB.Setup(toolobj)
	local _toolmode = toolobj.Mode

	toolobj.ToolLibLoaded = true

	function toolobj:IsValidTrace(trace)
		if not trace then return false end
		if not trace.Hit then return false end
		if not trace.HitPos then return false end

		local ent = trace.Entity
		if IsValid(ent) then
			if ent:IsPlayer() then return false end

			if SERVER then
				if not util.IsValidPhysicsObject(ent, trace.PhysicsBone) then return false end
			end
		end

		return true
	end

	function toolobj:IsValidRadio(ent)
		if not IsValid(ent) then return false end
		if not ent.__IsRadio then return false end

		local ply = self:GetOwner()
		if not IsValid(ply) then return true end

		local radioOwner = ent:GetRealRadioOwner()

		if not IsValid(radioOwner) then return true end
		if radioOwner ~= ply then return false end

		return true
	end

	function toolobj:IsValidGUIRadio(ent)
		if not self:IsValidRadio(ent) then return false end
		if not ent.HasGUI then return false end
		if not ent:HasGUI() then return false end

		return true
	end

	function toolobj:GetFallbackTrace()
		local ply = self:GetOwner()
		local trace = util.GetPlayerTrace(ply)
		trace.mask = bit.bor( CONTENTS_SOLID, CONTENTS_MOVEABLE, CONTENTS_MONSTER, CONTENTS_WINDOW, CONTENTS_DEBRIS, CONTENTS_GRATE, CONTENTS_AUX )

		local result = util.TraceLine(trace)
		if not self:IsValidTrace(result) then return nil end

		return result
	end

	function toolobj:SetClientInfo( name, var )
		local ply = self:GetOwner()

		if not IsValid(ply) then
			if CLIENT then
				ply = LocalPlayer()
			end
		end

		if not IsValid(ply) then
			return
		end

		var = tostring(var)
		var = string.Replace(var, "\"", "")

		ply:ConCommand(self.Mode .. "_" .. name .. " \"" .. var .. "\"")
	end

	function toolobj:SetClientNumber(name, var)
		self:SetClientInfo(name, tonumber(var) or 0)
	end

	function toolobj:SetClientBool(name, var)
		self:SetClientNumber(name, tobool(var) and 1 or 0)
	end

	function toolobj:GetClientNumberMinMax(name, min, max)
		local var = self:GetClientNumber(name)
		var = math.Clamp(var, min, max)

		return var
	end

	function toolobj:GetClientBool(name)
		local var = self:GetClientNumber(name)
		return tobool(var)
	end

	if SERVER then return end

	function toolobj:AddLabel( panel, name, descbool )
		local label = vgui.Create("DLabel")
		panel:AddPanel( label )

		label:SetDark(true)
		label:SetWrap(true)
		label:SetText(StreamRadioLib.Tool.GetLocale(self, name))

		label:SetAutoStretchVertical(true)
		label:SizeToContents()

		if descbool then
			label:SetTooltip(StreamRadioLib.Tool.GetLocale(self, name .. ".desc"))
		end

		return label
	end

	function toolobj:AddReadOnlyTextBox( panel, name )
		local boxPanel = vgui.Create("DForm")

		boxPanel:SetName(StreamRadioLib.Tool.GetLocale(self, name))

		panel:AddPanel(boxPanel)
		boxPanel:SetCookieName(name)

		local label = vgui.Create( "Streamradio_VGUI_ReadOnlyTextEntry" )
		boxPanel:AddItem( label )

		local desc = StreamRadioLib.Tool.GetLocale(self, name .. ".desc")
		label:SetText(desc)

		label:DockMargin(0, 0, 0, 0)
		label:DockPadding(0, 0, 0, 0)

		return boxPanel, label
	end

	function toolobj:AddWhitelistEnabledLabel( panel, name, descbool )
		local label = StreamRadioLib.Menu.GetWhitelistEnabledLabel(StreamRadioLib.Tool.GetLocale(self, name))
		panel:AddPanel( label )

		if descbool then
			label:SetTooltip(StreamRadioLib.Tool.GetLocale(self, name .. ".desc"))
		end

		return label
	end

	function toolobj:AddImportantLabel( panel, name, descbool )
		local label = StreamRadioLib.Menu.GetImportantLabel(StreamRadioLib.Tool.GetLocale(self, name))
		panel:AddPanel( label )

		if descbool then
			label:SetTooltip(StreamRadioLib.Tool.GetLocale(self, name .. ".desc"))
		end

		return label
	end

	function toolobj:AddButton( panel, name, descbool )
		local button = vgui.Create( "DButton" )
		panel:AddPanel( button )
		button:SetText(StreamRadioLib.Tool.GetLocale(self, name))
		button:SetDark( true )
		button:SizeToContents( )

		if descbool then
			button:SetTooltip(StreamRadioLib.Tool.GetLocale(self, name .. ".desc"))
		end

		return button
	end

	function toolobj:AddColorMixer( panel )
		local ColorMixer = vgui.Create( "DColorMixer" )
		panel:AddPanel( ColorMixer )

		ColorMixer:SetPalette( true )
		ColorMixer:SetAlphaBar( true )
		ColorMixer:SetPaintBackground( true )

		return ColorMixer
	end


	function toolobj:AddNumSlider( panel, command, descbool )
		local numslider = vgui.Create( "DNumSlider" )
		panel:AddPanel( numslider )

		numslider:SetText(StreamRadioLib.Tool.GetLocale(self, command), self.Mode .. "_" .. command)
		numslider:SetDark(true)
		numslider:SetConVar(self.Mode .. "_" .. command)

		if descbool then
			numslider:SetTooltip(StreamRadioLib.Tool.GetLocale(self, command .. ".desc"))
		end

		return numslider
	end

	function toolobj:AddCheckbox( panel, command, descbool )
		local checkbox = panel:CheckBox(StreamRadioLib.Tool.GetLocale(self, command), self.Mode .. "_" .. command)

		if descbool then
			checkbox:SetTooltip(StreamRadioLib.Tool.GetLocale(self, command .. ".desc"))
		end

		return checkbox
	end

	function toolobj:AddComboBox( panel, command, descbool )
		local combobox, label = panel:ComboBox(StreamRadioLib.Tool.GetLocale(self, command), self.Mode .. "_" .. command)

		StreamRadioLib.Menu.PatchComboBox(combobox, label)

		if descbool then
			combobox:SetTooltip(StreamRadioLib.Tool.GetLocale(self, command .. ".desc"))
		end

		return combobox
	end

	function toolobj:AddTextEntry( panel, command, descbool )
		local textentry = panel:TextEntry(StreamRadioLib.Tool.GetLocale(self, command), self.Mode .. "_" .. command)

		if descbool then
			textentry:SetTooltip(StreamRadioLib.Tool.GetLocale(self, command .. ".desc"))
		end

		return textentry
	end

	function toolobj:AddURLTextEntry( panel, command, descbool )
		local bgpanel = vgui.Create( "DPanel" )
		bgpanel:SetPaintBackground( false )

		if descbool then
			bgpanel:SetTooltip(StreamRadioLib.Tool.GetLocale(self, command .. ".desc"))
		end

		panel:AddPanel( bgpanel )

		local label = vgui.Create( "DLabel", bgpanel )
		label:SetText(StreamRadioLib.Tool.GetLocale(self, command))
		label:SetDark( true )
		label:SizeToContents( )
		label:Dock( TOP )

		local URLTextEntry = vgui.Create( "Streamradio_VGUI_URLTextEntry", bgpanel )
		URLTextEntry:SetConVar( self.Mode .. "_" .. command )
		URLTextEntry:Dock( FILL )
		URLTextEntry:DockMargin(0, 5, 0, 0)

		bgpanel:SetTall(78)

		return URLTextEntry
	end

	function toolobj:BuildToolPanel(CPanel)
		-- override this
	end

	function toolobj.BuildCPanel(CPanel)
		g_reloadpanels[_toolmode] = CPanel

		local toplabel = vgui.Create("DLabel")
		toplabel:SetText("#Tool." .. _toolmode .. ".desc")
		toplabel:SetDark(true)
		toplabel:SizeToContents()
		CPanel:AddPanel(toplabel)

		local StreamRadioLib = StreamRadioLib or {}

		if not StreamRadioLib.Loaded then
			if StreamRadioLib.Loader_CreateErrorPanel then
				StreamRadioLib.Loader_CreateErrorPanel(CPanel, "This tool could not be loaded.")
			end

			return
		end

		StreamRadioLib.Timer.Until("ToolReload_" .. _toolmode, 0.1, function()
			local ply = LocalPlayer()
			local this = LIB.GetTool(ply, _toolmode)
			if not this then return end

			local CPanel = g_reloadpanels[_toolmode]
			if not IsValid(CPanel) then return end

			if not this.BuildToolPanel then return end

			this.ToolPanel = CPanel

			local toolpresets = this.Presets or {}
			local Options = toolpresets.Options or StreamRadioLib.GetPresetsTable(_toolmode) or {}
			local CVars = toolpresets.CVars or {}

			if #CVars <= 0 then
				for k, v in pairs(this.ClientConVar or {}) do
					table.insert(CVars, this.Mode .. "_" .. k)
				end
			end

			if not Options.Default then
				Options.Default = {}

				for k, v in pairs(this.ClientConVar or {}) do
					Options.Default[this.Mode .. "_" .. k] = tostring(v)
				end
			end

			if #CVars > 0 then
				CPanel:AddControl("ComboBox", {
					Label = "#Presets",
					MenuButton = "1",
					Folder = this.Mode,
					Options = Options,
					CVars = CVars,
				})
			end

			this:BuildToolPanel(CPanel)

			CPanel:AddPanel(StreamRadioLib.Menu.GetSpacer(5))
			CPanel:AddPanel(StreamRadioLib.Menu.GetFAQButton())
			CPanel:AddPanel(StreamRadioLib.Menu.GetCreditsPanel())

			return true
		end)
	end

	function toolobj:GetPanel()
		return self.ToolPanel
	end

	function toolobj:ReloadPanel()
		local reloadpanel = g_reloadpanels[_toolmode]

		if not IsValid(reloadpanel) then
			reloadpanel = self:GetPanel()
		end

		if not IsValid(reloadpanel) then
			return
		end

		reloadpanel:Clear()
		self.BuildCPanel(reloadpanel)
	end

	toolobj:ReloadPanel()
end

local callback = nil

function LIB.RegisterClientToolHook(tool, toolhook)
	if SERVER then
		LIBNetwork.AddNetworkString("ClientToolHook")
		return
	end

	if callback then return end

	callback = function()
		local ply = LocalPlayer()

		local nwtoolname = net.ReadString()
		local bwhook = net.ReadString()

		local toolobj = LIB.GetTool(ply, nwtoolname)
		if not toolobj then return end

		local func = toolobj[bwhook .. "Client"]
		if not func then return end

		func(toolobj)
	end

	LIBNet.Receive("ClientToolHook", callback)
end

function LIB.CallClientToolHook(tool, toolhook)
	if CLIENT then return end

	local owner = tool:GetOwner()
	local toolname = tool.Mode

	LIBNet.Start("ClientToolHook")
		net.WriteString(toolname)
		net.WriteString(toolhook)
	net.Send(owner)
end

return true


--PATH lua/streamradio_core/models/fallout3_jukebox.lua:
return gluapack()()
--PATH lua/streamradio_core/models/hl2_crtscreen_big.lua:
return gluapack()()
--PATH lua/streamradio_core/models/minecraft_jukebox.lua:
return gluapack()()
--PATH lua/streamradio_core/models/plasma_tv.lua:
local RADIOMDL = RADIOMDL
if not istable( RADIOMDL ) then
	StreamRadioLib.Model.LoadModelSettings()
	return
end

-- 4:3 Plasma TV
RADIOMDL.model = "models/blacknecro/tv_plasma_4_3.mdl"

RADIOMDL.SpawnAng = Angle(0, 0, 0)
RADIOMDL.SpawnFlatOnWall = true
RADIOMDL.SoundPosOffset = Vector(0, 0, 0)
RADIOMDL.SoundAngOffset = Angle(0, 0, 0)


RADIOMDL.DisplayAngles = Angle(0, 90, 90)

                              --      F,      R,      U
RADIOMDL.DisplayOffset    = Vector(0.20, -27.80,  20.90) -- Top Left
RADIOMDL.DisplayOffsetEnd = Vector(0.20,  27.80, -20.90) -- Bottom Right

RADIOMDL.DisplayWidth = 2048
RADIOMDL.DisplayHeight, RADIOMDL.DisplayScale = RADIOMDL:GetDisplayHeight(RADIOMDL.DisplayOffset, RADIOMDL.DisplayOffsetEnd, RADIOMDL.DisplayWidth)

RADIOMDL.FontSizes = {
--  Name 	= Size,	Weight, Parentname
	Header	= {50,	1000},
	Default	= {44,	700},
	Tooltip	= {44,	1000},
	Big		= {60,	700},
}

function RADIOMDL:SetupGUI(ent, gui_controller, mainpanel)
	gui_controller:SetPos(0, 0)
	gui_controller:SetSize(self.DisplayWidth, self.DisplayHeight)

	mainpanel:SetSize(gui_controller:GetClientSize())

	local modelsetup = {}
	if CLIENT then
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/header/text", "font", self.Fonts.Header)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/header/pretext", "font", self.Fonts.Header)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "font", self.Fonts.Default)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "font", self.Fonts.Default)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/header", "font", self.Fonts.Header)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/controls/progressbar/label", "font", self.Fonts.Default)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/button", "font", self.Fonts.Default)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/volume/progressbar/label", "font", self.Fonts.Default)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/textbox", "font", self.Fonts.Big)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/button", "font", self.Fonts.Default)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/textbox", "font", self.Fonts.Big)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/button", "font", self.Fonts.Default)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "tooltip", "font", self.Fonts.Tooltip)
	end

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/header", "sizeh", 75)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/header", "sizeh", 75)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists", "gridsize", {x = 2, y = 10})
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview", "gridsize", {x = 2, y = 10})
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/scrollbar", "sizew", 75)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/scrollbar", "sizew", 75)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/sidebutton", "sizew", 125)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/textbox/scrollbar", "sizew", 75)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/textbox/scrollbar", "sizew", 75)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/button", "sizeh", 100)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/button", "sizew", 100)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/button", "sizew", 100)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "", "cornersize", 0)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "", "borderwidth", 16)

	local shadow = 12
	local padding = 12
	local margin = 12

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "shadowwidth", shadow)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "shadowwidth", shadow)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "padding", padding)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "padding", padding)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "margin", margin)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "margin", margin)

	gui_controller:SetModelSetup(modelsetup)

	mainpanel:ForEachChildRecursive(function(panel, child)
		if child.SetShadowWidth and child:GetShadowWidth() == 5 then
			child:SetShadowWidth(shadow)
		end

		if child.SetPadding and child:GetPadding() == 5 then
			child:SetPadding(padding)
		end

		if child.SetMargin and child:GetMargin() == 5 then
			child:SetMargin(margin)
		end
	end)
end

return true


--PATH lua/streamradio_core/models/portal_speaker_small.lua:
local RADIOMDL = RADIOMDL
if not istable( RADIOMDL ) then
	StreamRadioLib.Model.LoadModelSettings()
	return
end

-- Portal 2 Old Speaker, Small
RADIOMDL.model = "models/props_underground/old_speaker.mdl"

RADIOMDL.NoDisplay = true
RADIOMDL.SpawnAng = Angle( -90, 0, 0 )
RADIOMDL.SpawnFlatOnWall = false
RADIOMDL.SpawnAtOrigin = true
RADIOMDL.SoundPosOffset = Vector( 10.5, 0, -1.9 )
RADIOMDL.SoundAngOffset = Angle( 22.5, 0, 0 )

return true


--PATH lua/streamradio_core/models/portal_turret.lua:
return gluapack()()
--PATH lua/streamradio_core/models/sw_radio.lua:
local RADIOMDL = RADIOMDL
if not istable( RADIOMDL ) then
	StreamRadioLib.Model.LoadModelSettings()
	return
end

-- SligWolf's Radio
RADIOMDL.model = "models/sligwolf/grocel/radio/radio.mdl"

RADIOMDL.SpawnAng = Angle(0, 180, 0)
RADIOMDL.SpawnFlatOnWall = true
RADIOMDL.SoundPosOffset = Vector(0, -3.1, 3.45)
RADIOMDL.SoundAngOffset = Angle(0, 0, 0)

RADIOMDL.DisplayAngles = Angle(0, -90, 90)

                              --       F,     R,    U
RADIOMDL.DisplayOffset    = Vector(-1.45,  5.85, 6.00) -- Top Left
RADIOMDL.DisplayOffsetEnd = Vector(-1.45, -5.85, 0.95) -- Bottom Right

RADIOMDL.DisplayWidth = 768
RADIOMDL.DisplayHeight, RADIOMDL.DisplayScale = RADIOMDL:GetDisplayHeight(RADIOMDL.DisplayOffset, RADIOMDL.DisplayOffsetEnd, RADIOMDL.DisplayWidth)


RADIOMDL.FontSizes = {
--  Name 	= Size,	Weight, Parentname
	Header	= {20,	1000},
	Default	= {19,	700},
	Tooltip	= {15,	800},
	Big		= {22,	700},
}

function RADIOMDL:SetupGUI(ent, gui_controller, mainpanel)
	gui_controller:SetPos(0, 0)
	gui_controller:SetSize(self.DisplayWidth, self.DisplayHeight)

	mainpanel:SetSize(gui_controller:GetClientSize())

	local modelsetup = {}
	if CLIENT then
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/header/text", "font", self.Fonts.Header)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/header/pretext", "font", self.Fonts.Header)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "font", self.Fonts.Default)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "font", self.Fonts.Default)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/header", "font", self.Fonts.Header)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/controls/progressbar/label", "font", self.Fonts.Default)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/button", "font", self.Fonts.Big)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/volume/progressbar/label", "font", self.Fonts.Default)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/textbox", "font", self.Fonts.Big)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/button", "font", self.Fonts.Big)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/textbox", "font", self.Fonts.Big)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/button", "font", self.Fonts.Big)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "tooltip", "font", self.Fonts.Tooltip)
	end

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/header", "sizeh", 40)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/header", "sizeh", 40)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists", "gridsize", {x = 2, y = 6})
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview", "gridsize", {x = 2, y = 6})
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/scrollbar", "sizew", 30)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/scrollbar", "sizew", 30)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/sidebutton", "sizew", 50)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/textbox/scrollbar", "sizew", 30)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/textbox/scrollbar", "sizew", 30)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/button", "sizeh", 45)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/button", "sizew", 35)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/button", "sizew", 35)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "", "cornersize", 0)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "", "borderwidth", 16)

	local shadow = 5
	local padding = 5
	local margin = 5

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "shadowwidth", shadow)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "shadowwidth", shadow)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "padding", padding)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "padding", padding)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "margin", margin)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "margin", margin)

	gui_controller:SetModelSetup(modelsetup)

	mainpanel:ForEachChildRecursive(function(panel, child)
		if child.SetShadowWidth and child:GetShadowWidth() == 5 then
			child:SetShadowWidth(shadow)
		end

		if child.SetPadding and child:GetPadding() == 5 then
			child:SetPadding(padding)
		end

		if child.SetMargin and child:GetMargin() == 5 then
			child:SetMargin(margin)
		end
	end)
end

function RADIOMDL:Initialize(ent)
	if CLIENT then
		ent:InvalidateBoneCache()
		return
	end

	if ent._mdl_skinset then return end

	local color = ColorRand()
	ent:SetColor( color )

	ent._mdl_skinset = true
end

function RADIOMDL:AnimReset(ent)
	if SERVER then return end

	ent:SetPoseParameter("speakers", 0)
	ent:InvalidateBoneCache()
end

function RADIOMDL:WhileLoading(ent)
	if SERVER then return end

	ent:SetPoseParameter("speakers", 0)
	ent:InvalidateBoneCache()
end

RADIOMDL.SpeakerMinFRQ = 20
RADIOMDL.SpeakerMaxFRQ = 2000
RADIOMDL.SpeakerFRQResolution = 12

function RADIOMDL:Speaker(ent, speakerlevel)
	if SERVER then return end

	speakerlevel = speakerlevel or 0

	local soundlevel = 0

	if IsValid(ent.StreamObj) then
		soundlevel = ent.StreamObj:GetAverageLevel() ^ 0.25
	end

	local vol = ent:GetVolume()

	speakerlevel = speakerlevel * vol * 1.5 * soundlevel
	speakerlevel = math.Clamp(speakerlevel, -1, 1)

	ent:SetPoseParameter("speakers", speakerlevel)
	ent:InvalidateBoneCache()
end

return true


--PATH lua/streamradio_core/models/wire_speaker2.lua:
return gluapack()()
--PATH lua/streamradio_core/classes/ui/shadow_panel.lua:
return gluapack()()
--PATH lua/streamradio_core/classes/ui/text.lua:
return gluapack()()
--PATH lua/streamradio_core/classes/ui/radio/list_playlists.lua:
local StreamRadioLib = StreamRadioLib

if not istable(CLASS) then
	StreamRadioLib.ReloadClasses()
	return
end

local BASE = CLASS:GetBaseClass()

function CLASS:Create()
	BASE.Create(self)
end

function CLASS:BuildListInternal()
	if CLIENT then return end
	if not self.Network.Active then return end

	self:ClearData()

	if not self:IsVisible() then
		self:UpdateButtons()
		self:RestoreScrollPos()
		return
	end

	self.PathUid = StreamRadioLib.Util.Uid()
	local uid = self.PathUid

	StreamRadioLib.Filesystem.Find(self.Path.Value, function(success, files)
		if uid ~= self.PathUid then
			return
		end

		self:QueueCall("_BuildListInternalAsyc", uid, files or {})
	end)
end

function CLASS:_BuildListInternalAsyc(uid, files)
	if uid ~= self.PathUid then
		return
	end

	for i, v in ipairs(files) do
		local data = {}

		data.value = v
		data.text = v.file
		data.icon = v.type

		self:AddData(data, true)
	end

	self:UpdateButtons()
	self:QueueCall("RestoreScrollPos")
end

function CLASS:PostDupe(data)
	if StreamRadioLib.Filesystem.Exists(data.Path, StreamRadioLib.TYPE_FOLDER) then
		self:SetPath(data.Path)
	else
		self:SetPath("")
		self:CallHook("OnInvalidDupeFilepath")
	end
end

return true


--PATH lua/streamradio_core/classes/ui/radio/gui_browser.lua:
local StreamRadioLib = StreamRadioLib

if not istable(CLASS) then
	StreamRadioLib.ReloadClasses()
	return
end

local BASE = CLASS:GetBaseClass()

local g_mat_upbutton = StreamRadioLib.GetPNGIcon("door_in")
local g_mat_refresh = StreamRadioLib.GetPNGIcon("arrow_refresh")
local g_mat_toolbutton = StreamRadioLib.GetPNGIcon("wrench")
local g_mat_wirebutton = StreamRadioLib.GetPNGIcon("wiremod", true)

function CLASS:Create()
	BASE.Create(self)

	self.HeaderPanel = self:AddPanelByClassname("shadow_panel", true)
	self.HeaderPanel:SetSize(1, 30)
	self.HeaderPanel:SetName("header")
	self.HeaderPanel:SetNWName("hdr")
	self.HeaderPanel:SetSkinIdentifyer("header")

	self.HeaderPanelTextPre = self.HeaderPanel:AddPanelByClassname("label", true)
	self.HeaderPanelTextPre:SetText("Path: ")
	self.HeaderPanelTextPre:SetSize(1, 30)
	self.HeaderPanelTextPre:SetAlign(TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
	self.HeaderPanelTextPre:SetName("pretext")
	self.HeaderPanelTextPre:SetNWName("ptxt")

	self.HeaderPanelText = self.HeaderPanel:AddPanelByClassname("label", true)
	self.HeaderPanelText:SetShorterAtEnd(false)
	self.HeaderPanelText:SetAlign(TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
	self.HeaderPanelText:SetName("text")
	self.HeaderPanelText:SetNWName("txt")

	self.HeaderPanel.SetTextColor = function(this, color)
		if IsValid(self.HeaderPanelText) then
			self.HeaderPanelText:SetTextColor(color)
		end

		if IsValid(self.HeaderPanelTextPre) then
			self.HeaderPanelTextPre:SetTextColor(color)
		end
	end

	self.HeaderPanel.GetTextColor = function(this)
		if IsValid(self.HeaderPanelText) then
			return self.HeaderPanelText:GetTextColor()
		end

		if IsValid(self.HeaderPanelTextPre) then
			return self.HeaderPanelTextPre:GetTextColor()
		end

		return nil
	end

	self.UpButton = self:AddPanelByClassname("button", true)
	self.UpButton:SetIcon(g_mat_upbutton)
	self.UpButton:SetSize(50, 50)
	self.UpButton:SetName("backbutton")
	self.UpButton:SetNWName("bk")
	self.UpButton:SetSkinIdentifyer("sidebutton")
	self.UpButton:SetTooltip("Go to parent directory")

	self.RefreshButton = self:AddPanelByClassname("button", true)
	self.RefreshButton:SetIcon(g_mat_refresh)
	self.RefreshButton:SetSize(50, 50)
	self.RefreshButton:SetName("refreshbutton")
	self.RefreshButton:SetNWName("rfsh")
	self.RefreshButton:SetSkinIdentifyer("sidebutton")
	self.RefreshButton:SetTooltip("Refresh view")

	self.ToolButton = self:AddPanelByClassname("button", true)
	self.ToolButton:SetIcon(g_mat_toolbutton)
	self.ToolButton:SetSize(50, 50)
	self.ToolButton:SetName("toolbutton")
	self.ToolButton:SetNWName("tool")
	self.ToolButton:SetSkinIdentifyer("sidebutton")
	self.ToolButton:SetTooltip("Play URL from Toolgun")

	self.WireButton = self:AddPanelByClassname("button", true)
	self.WireButton:SetIcon(g_mat_wirebutton)
	self.WireButton:SetSize(50, 50)
	self.WireButton:SetName("wirebutton")
	self.WireButton:SetNWName("wire")
	self.WireButton:SetSkinIdentifyer("sidebutton")
	self.WireButton:SetVisible(StreamRadioLib.Wire.HasWiremod())
	self.WireButton:SetTooltip("Play URL from Wiremod")

	self.ListFiles = self:AddPanelByClassname("radio/list_playlists", true)
	self.ListFiles:SetName("list-playlists")
	self.ListFiles:SetNWName("lstp")
	self.ListFiles:Open()
	self.ListFiles:SetSkinIdentifyer("list")

	self.ListPlaylist = self:AddPanelByClassname("radio/list_playlistview", true)
	self.ListPlaylist:SetName("list-playlistview")
	self.ListPlaylist:SetNWName("lstpv")
	self.ListPlaylist:Close()
	self.ListPlaylist:SetSkinIdentifyer("list")

	self.Errorbox = self:AddPanelByClassname("radio/gui_errorbox", true)
	self.Errorbox:SetName("error")
	self.Errorbox:SetNWName("err")
	self.Errorbox:SetSkinIdentifyer("error")

	if self.Errorbox.RetryButton then
		self.Errorbox.RetryButton:Remove()
		self.Errorbox.RetryButton = nil
	end

	if self.Errorbox.AdminWhitelistButton then
		self.Errorbox.AdminWhitelistButton:Remove()
		self.Errorbox.AdminWhitelistButton = nil
	end

	if IsValid(self.Errorbox.CloseButton) and CLIENT then
		-- The error box is handled on the server, so the client shouldn't touch it.
		self.Errorbox.CloseButton.DoClick = nil
	end

	self.Errorbox.OnCloseClick = function()
		self:GoUpPath()
	end

	self.Errorbox:SetZPos(100)
	self.Errorbox:Close()

	self.SideButtons = {
		self.UpButton,
		self.RefreshButton,
		self.ToolButton,
		self.WireButton,
	}

	self.State = self:CreateListener({
		PlaylistOpened = false,
	}, function(this, k, v)
		if IsValid(self.Errorbox) then
			self.Errorbox:Close()
			self:InvalidateLayout()
		end

		if not v then
			self:CallHook("OnPlaylistClose")

			if IsValid(self.ListPlaylist) then
				self.ListPlaylist:ClearData()
				self.ListPlaylist:Close()
			end

			if IsValid(self.ListFiles) then
				self.ListFiles:ActivateNetworkedMode()
				self.ListFiles:Open()
			end
		else
			self:CallHook("OnPlaylistOpen")

			if IsValid(self.ListFiles) then
				self.ListFiles:ClearData()
				self.ListFiles:Close()
			end

			if IsValid(self.ListPlaylist) then
				self.ListPlaylist:ActivateNetworkedMode()
				self.ListPlaylist:Open()
			end
		end

		self:Refresh()
		self:SetNWBool(k, v)
		self:UpdatePath()

		self:ApplyNetworkVars()
		self:InvalidateLayout()
	end)

	self.ListPlaylist.OnPlayItem = function(this, ...)
		self:UpdatePath()
		return self:CallHook("OnPlayItem", ...)
	end

	self.ListPlaylist.OnPlaylistStartBuild = function(this, ...)
		return self:CallHook("OnPlaylistStartBuild", ...)
	end

	self.ListPlaylist.OnPlaylistEndBuild = function(this, ...)
		return self:CallHook("OnPlaylistEndBuild", ...)
	end

	self.ListPlaylist.OnError = function(this, filename, filetype, ...)
		if IsValid(self.Errorbox) then
			self.Errorbox:SetPlaylistError(filename)
			self:InvalidateLayout()
		end

		return self:CallHook("OnError", filename, filetype, ...)
	end

	self.ListPlaylist.OnErrorRelease = function(this, filename, filetype, ...)
		if IsValid(self.Errorbox) then
			self.Errorbox:Close()
			self:InvalidateLayout()
		end

		return self:CallHook("OnErrorRelease", filename, filetype, ...)
	end

	self.ListPlaylist.OnInvalidDupeFilepath = function(this, filename, filetype, ...)
		self:QueueCall("OnInvalidDupeFilepath")
	end

	self.ListFiles.OnInvalidDupeFilepath = function(this)
		self:QueueCall("OnInvalidDupeFilepath")
	end

	self.ListFiles.OnFileClick = function(this, value, ...)
		if CLIENT then return end

		local r = self:CallHook("OnFileClick", value, ...)
		if r == false then return end

		self.State.PlaylistOpened = true

		if IsValid(self.ListPlaylist) then
			self.ListPlaylist:SetFile(value.path, value.type)
		end
	end

	self.ListFiles.OnPathChange = function(this, ...)
		self:UpdatePath()
		return self:CallHook("OnPathChange", ...)
	end

	self.ListPlaylist.OnPathChange = function(this, ...)
		self:UpdatePath()
		return self:CallHook("OnPathChange", ...)
	end

	self.UpButton.DoClick = function()
		self:GoUpPath()
	end

	self.RefreshButton.DoClick = function()
		self:Refresh()
	end

	self.ToolButton.DoClick = function()
		self:CallHook("OnToolButtonClick")
	end

	self.WireButton.DoClick = function()
		self:CallHook("OnWireButtonClick")
	end

	self:SetEvent("OnClose", "SaveScrollPos", function()
		if IsValid(self.ListPlaylist) then
			self.ListPlaylist:SaveScrollPos()
		end

		if IsValid(self.ListFiles) then
			self.ListFiles:SaveScrollPos()
		end
	end)

	self:UpdatePath()
end

function CLASS:OnInvalidDupeFilepath()
	self.State.PlaylistOpened = false

	if IsValid(self.Errorbox) then
		self.Errorbox:Close()
	end

	self:Refresh()

	self:UpdatePath()
	self:InvalidateLayout()
end

function CLASS:GetHasPlaylist()
	return self._hasplaylist or false
end

function CLASS:SetHasPlaylist(bool)
	self._hasplaylist = bool
end

function CLASS:CloseSingleItem()
	if self:GetHasPlaylist() then return end

	self.State.PlaylistOpened = false
end

function CLASS:UpdatePath()
	if not IsValid(self.UpButton) then return end
	if not IsValid(self.HeaderPanelText) then return end

	local path = self:GetPath()

	self.HeaderPanelText:SetText("/" .. path)
	self.UpButton:SetDisabled(path == "")
end

function CLASS:GetUpButton()
	return self.UpButton
end

function CLASS:GetRefreshButton()
	return self.RefreshButton
end

function CLASS:GetToolButton()
	return self.ToolButton
end

function CLASS:GetWireButton()
	return self.WireButton
end

function CLASS:GetFilesPanel()
	return self.ListFiles
end

function CLASS:GetPlaylistPanel()
	return self.ListPlaylist
end

function CLASS:GetHeaderPanel()
	return self.HeaderPanel
end

function CLASS:GetHeaderTextPanel()
	return self.HeaderPanelText
end

function CLASS:IsPlaylistOpen()
	if self.State.PlaylistOpened then
		return true
	end

	if IsValid(self.ListPlaylist) and self.ListPlaylist:HasError() then
		return true
	end

	return false
end

function CLASS:GetPath()
	if self:IsPlaylistOpen() then
		return self.ListPlaylist:GetFile()
	end

	return self.ListFiles:GetPath()
end

function CLASS:GoUpPath()
	if CLIENT then return end
	if not self.State then return end

	if self:IsPlaylistOpen() then
		self.State.PlaylistOpened = false
		return
	end

	if IsValid(self.ListFiles) then
		self.ListFiles:GoUpPath()
	end
end

function CLASS:Refresh()
	local antiSpamTime = 1

	if IsValid(self.RefreshButton) then
		self.RefreshButton:SetDisabled(true)

		self:TimerOnce("RefreshButtonAntiSpam", antiSpamTime, function()
			if not IsValid(self.RefreshButton) then
				return
			end

			self.RefreshButton:SetDisabled(false)
		end)
	end

	if IsValid(self.Errorbox) and IsValid(self.Errorbox.RetryButton) then
		self.Errorbox.RetryButton:SetDisabled(true)

		self:TimerOnce("RetryButtonAntiSpam", antiSpamTime, function()
			if not IsValid(self.Errorbox) then
				return
			end

			if not IsValid(self.Errorbox.RetryButton) then
				return
			end

			self.Errorbox.RetryButton:SetDisabled(false)
		end)
	end

	if CLIENT then return end

	if IsValid(self.ListPlaylist) and self.ListPlaylist:IsVisible() then
		self.ListPlaylist:Refresh()
	end

	if IsValid(self.ListFiles) and self.ListFiles:IsVisible() then
		self.ListFiles:Refresh()
	end
end

function CLASS:_PerformButtonLayout(buttonx, buttony)
	if not self.SideButtons then return end

	local _, h = self:GetClientSize()
	local buttonw = 0

	for k, v in ipairs(self.SideButtons) do
		if not IsValid(v) then continue end
		if not v.Layout.Visible then continue end

		if buttonw <= 0 then
			buttonw = v:GetWidth()
			break
		end
	end

	local margin = self:GetMargin()

	for k, v in ipairs(self.SideButtons) do
		if not IsValid(v) then continue end
		if not v.Layout.Visible then continue end

		local newbutteny = buttony + (buttonw + margin)
		if newbutteny >= h then
			v:SetPos(0, 0)
			v:SetHeight(0)
			continue
		end

		v:SetPos(buttonx, buttony)
		v:SetSize(buttonw, buttonw)
		buttony = newbutteny
	end

	return buttonw, buttony
end

function CLASS:PerformLayout(...)
	BASE.PerformLayout(self, ...)

	if not IsValid(self.HeaderPanel) then return end
	if not IsValid(self.HeaderPanelText) then return end
	if not IsValid(self.UpButton) then return end
	if not IsValid(self.ToolButton) then return end
	if not IsValid(self.WireButton) then return end
	if not IsValid(self.ListFiles) then return end
	if not IsValid(self.ListPlaylist) then return end
	if not self.SideButtons then return end

	local w, h = self:GetClientSize()
	local headerw, headerh = self.HeaderPanel:GetSize()

	local buttonw = self:_PerformButtonLayout(0, headerh)

	local margin = self:GetMargin()
	local listx = 0

	if buttonw > 0 then
		listx = buttonw + margin
	end

	local listy = headerh + margin

	local listw = w - listx
	local listh = h - listy

	headerw = listw

	self.ListFiles:SetSize(listw, listh)
	self.ListPlaylist:SetSize(listw, listh)

	self.ListFiles:SetPos(listx, listy)
	self.ListPlaylist:SetPos(listx, listy)

	self.HeaderPanel:SetSize(headerw, headerh)
	self.HeaderPanel:SetPos(listx, 0)

	local headeriw, headerih = self.HeaderPanel:GetClientSize()

	self.HeaderPanelTextPre:AutoWidth(headeriw)
	self.HeaderPanelTextPre:SetHeight(headerih)

	local headerprew = self.HeaderPanelTextPre:GetWidth()

	self.HeaderPanelTextPre:SetPos(0, 0)

	self.HeaderPanelText:SetSize(headeriw - headerprew, headerih)
	self.HeaderPanelText:SetPos(headerprew, 0)

	if IsValid(self.Errorbox) then
		self.Errorbox:SetSize(listw, listh)
		self.Errorbox:SetPos(listx, listy)
	end
end

function CLASS:ActivateNetworkedMode()
	BASE.ActivateNetworkedMode(self)
	self.ListFiles:ActivateNetworkedMode()
	self.ListPlaylist:ActivateNetworkedMode()

	if SERVER then
		self:SetNWBool("PlaylistOpened", self.State.PlaylistOpened)
		return
	end

	self:SetNWVarCallback("PlaylistOpened", "Bool", function(this, nwkey, oldvar, newvar)
		self.State.PlaylistOpened = newvar
	end)
end

function CLASS:ApplyNetworkVarsInternal()
	BASE.ApplyNetworkVarsInternal(self)

	self.State.PlaylistOpened = self:GetNWBool("PlaylistOpened", false)
end

function CLASS:PreDupe()
	local data = {}

	data.PlaylistOpened = self.State.PlaylistOpened

	return data
end

function CLASS:PostDupe(data)
	self.State.PlaylistOpened = data.PlaylistOpened
end

return true


--PATH lua/streamradio_core/classes/stream.lua:
return gluapack()()
--PATH lua/streamradio_core/client/cl_help.lua:
local LIBError = StreamRadioLib.Error

local g_helpPanel = StreamRadioLib.g_HelpPanel

if IsValid(g_helpPanel) then
	StreamRadioLib.VR.CloseMenu(g_helpPanel)
	g_helpPanel:Remove()

	g_helpPanel = nil
	StreamRadioLib.g_HelpPanel = nil
end

local function CreateErrorHelpPanel()
	if IsValid( g_helpPanel ) then
		return g_helpPanel
	end

	local ErrorHelpFont = StreamRadioLib.Surface.AddFont(14, 1000, "Lucida Console")
	local HelpPanel = vgui.Create( "DFrame" ) -- The main frame.

	HelpPanel:SetPos( 25, 25 )
	HelpPanel:SetSize( 900, 600 )

	HelpPanel:SetMinWidth( 575 )
	HelpPanel:SetMinHeight( 200 )
	HelpPanel:SetSizable( true )
	HelpPanel:SetDeleteOnClose( false )
	HelpPanel:SetVisible( false )
	HelpPanel:SetTitle( "Stream Radio Error Information" )
	HelpPanel:SetZPos(150)
	HelpPanel:GetParent():SetWorldClicker( true )

	HelpPanel.HelpTextPanel = vgui.Create( "Streamradio_VGUI_ReadOnlyTextEntry", HelpPanel )
	HelpPanel.HelpTextPanel:SetDrawBorder( true )
	HelpPanel.HelpTextPanel:SetPaintBackground( true )
	HelpPanel.HelpTextPanel:SetVerticalScrollbarEnabled( true )
	HelpPanel.HelpTextPanel:SetFont( ErrorHelpFont )
	HelpPanel.HelpTextPanel:SetZPos(100)
	HelpPanel.HelpTextPanel:SetCursor( "beam" )
	HelpPanel.HelpTextPanel:Dock( FILL )

	local ControlPanel = vgui.Create( "DPanel", HelpPanel )
	ControlPanel:SetPaintBackground( false )
	ControlPanel:SetTall( 30 )
	ControlPanel:DockMargin( 0, 5, 0, 0 )
	ControlPanel:SetZPos(200)
	ControlPanel:Dock( BOTTOM )

	local OkButton = vgui.Create( "DButton", ControlPanel )
	OkButton:SetWide( 100 )
	OkButton:SetText( "OK" )
	OkButton:DockMargin( 5, 0, 0, 0 )
	OkButton:SetZPos(300)
	OkButton:Dock( RIGHT )

	OkButton.DoClick = function( self )
		StreamRadioLib.VR.CloseMenu(HelpPanel)
	end

	HelpPanel.CopyButton = vgui.Create( "DButton", ControlPanel )
	HelpPanel.CopyButton:SetWide( 100 )
	HelpPanel.CopyButton:SetText( "Copy to clipboard" )
	HelpPanel.CopyButton:DockMargin( 5, 0, 0, 0 )
	HelpPanel.CopyButton:SetZPos(400)
	HelpPanel.CopyButton:Dock( RIGHT )

	HelpPanel.OnlineHelpButton = StreamRadioLib.Menu.GetLinkButton("View online help")
	HelpPanel.OnlineHelpButton:SetParent(ControlPanel)
	HelpPanel.OnlineHelpButton:SetWide( 175 )
	HelpPanel.OnlineHelpButton:DockMargin( 5, 0, 20, 0 )
	HelpPanel.OnlineHelpButton:SetZPos(500)
	HelpPanel.OnlineHelpButton:Dock( RIGHT )

	HelpPanel.OptionToggleTick = vgui.Create( "DCheckBoxLabel", ControlPanel )
	HelpPanel.OptionToggleTick:SetWide( 125 )
	HelpPanel.OptionToggleTick:SetText( "" )
	HelpPanel.OptionToggleTick:DockMargin( 10, 0, 0, 0 )
	HelpPanel.OptionToggleTick:SetZPos(600)
	HelpPanel.OptionToggleTick:Dock( LEFT )

	g_helpPanel = HelpPanel
	return HelpPanel
end

local function OpenErrorHelpPanel( header, helptext, url, helpurl, userdata )
	header = header or ""
	helptext = helptext or ""
	url = url or ""
	helpurl = helpurl or ""
	userdata = userdata or {}

	local tickboxdata = userdata.userdata or {}
	tickboxdata = tickboxdata.tickbox

	local HelpPanel = CreateErrorHelpPanel()

	if not IsValid( HelpPanel ) then return end
	if not IsValid( HelpPanel.HelpTextPanel ) then return end
	if not IsValid( HelpPanel.CopyButton ) then return end
	if not IsValid( HelpPanel.OnlineHelpButton ) then return end
	if not IsValid( HelpPanel.OptionToggleTick ) then return end

	HelpPanel:SetTitle( "Stream Radio Error Information | " .. header )

	if not StreamRadioLib.VR.IsActive() then
		local X, Y = HelpPanel:GetPos()
		local W, H = HelpPanel:GetSize()

		if X <= 0 then
			X = 25
		end

		if Y <= 0 then
			Y = 25
		end

		W = math.min(ScrW() - 50, W)
		H = math.min(ScrH() - 50, H)

		HelpPanel:SetPos(X, Y)
		HelpPanel:SetSize(W, H)
		HelpPanel:SetSizable(true)
		HelpPanel:SetDraggable(true)
		HelpPanel:GetParent():SetWorldClicker(true)
	else
		HelpPanel:SetPos(0, 0)
		HelpPanel:SetSize(900, 600)
		HelpPanel:SetSizable(false)
		HelpPanel:SetDraggable(false)
		HelpPanel:GetParent():SetWorldClicker(false)
	end

	StreamRadioLib.VR.MenuOpen(
		"StreamRadioErrorInformation",
		HelpPanel,
		true
	)

	if url ~= "" then
		helptext = string.format("%s\n\n%s\n\n%s", header, url, helptext)
	else
		helptext = string.format("%s\n\n%s", header, helptext)
	end

	HelpPanel.HelpTextPanel:SetText( helptext )

	local CopyText = string.gsub( helptext or "", "\n", "\r\n" )
	CopyText = string.Trim( CopyText )
	HelpPanel.CopyButton:SetVisible(CopyText ~= "")

	HelpPanel.CopyButton.DoClick = function( self )
		if ( not IsValid( HelpPanel ) ) then return end
		if ( CopyText == "" ) then return end

		SetClipboardText( CopyText )
	end

	HelpPanel.OnlineHelpButton:SetVisible( helpurl ~= "" )
	HelpPanel.OnlineHelpButton:SetURL( helpurl )

	HelpPanel.OptionToggleTick:SetVisible(tickboxdata ~= nil)

	if tickboxdata then
		HelpPanel.OptionToggleTick:SetText(tickboxdata.text or "???")
		HelpPanel.OptionToggleTick:SetConVar(tickboxdata.cmd or "")
	end

	HelpPanel:InvalidateLayout( true )

	StreamRadioLib.g_HelpPanel = HelpPanel
	return HelpPanel
end

function StreamRadioLib.ShowErrorHelp( errorcode, url )
	local errorInfo = LIBError.GetStreamErrorInfo(errorcode)

	local hasHelpmenu = errorInfo.helpmenu
	if not hasHelpmenu then
		return
	end

	local code = errorInfo.id
	local name = errorInfo.name
	local description = errorInfo.description or ""
	local userdata = errorInfo.userdata

	local header = string.format("Error %i (%s): %s", code, name, description)

	local helptext = errorInfo.helptext or ""
	local helpurl = errorInfo.helpurl or ""

	OpenErrorHelpPanel( header, helptext, url, helpurl, userdata )
end

function StreamRadioLib.ShowPlaylistErrorHelp( )
	StreamRadioLib.ShowErrorHelp(LIBError.PLAYLIST_ERROR_INVALID_FILE)
end

return true


--PATH lua/streamradio_core/client/cl_surface.lua:
return gluapack()()
--PATH lua/streamradio_core/filesystem/addon-web-radio.lua:
return gluapack()()
--PATH lua/streamradio_core/filesystem/json.lua:
return gluapack()()
--PATH addons/[miecze] mexicano_drzewko/lua/autorun/sv_drzewo.lua:
return gluapack()()
--PATH addons/[bronie] kajdanki/lua/autorun/sv_handcuffs.lua:
return gluapack()()
--PATH addons/[chat] talk-modes/lua/talk_modes/vgui/cl_preview.lua:
include("talk_modes/vgui/libs/cl_spheres.lua")

-- This is global which allows us to interact with it anywhere, cl_selection in particular. 
TM_ADMIN_PREVIEW = TM_ADMIN_PREVIEW || {bActive = false, intRange = 300}
local THEME = TalkModes.Client.ActiveTheme

function TalkModes.Client.HUDPaint()
    if TM_ADMIN_PREVIEW.bActive == false then return end
    if TM_ADMIN_PREVIEW.intRange == 0 then return end

    surface.SetFont("TalkModes:Medium")
    local intTextW, intTextH = surface.GetTextSize(string.format(TalkModes.Languages:GetPhrase("PreviewText"), TM_ADMIN_PREVIEW.intRange))
    draw.RoundedBox(6, ScrW()/2 - (intTextW + 24)/2, ScrH() - intTextH + 8 - 24 , intTextW + 24, intTextH + 8, Color(THEME["Hover"].r, THEME["Hover"].g, THEME["Hover"].b, 200))
    draw.SimpleText(string.format(TalkModes.Languages:GetPhrase("PreviewText"), TM_ADMIN_PREVIEW.intRange), "TalkModes:Medium", ScrW()/2, ScrH() - 24, THEME["White"], TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
    surface.SetFont("TalkModes:Small")
    local intTextWw, intTextHh = surface.GetTextSize(TalkModes.Languages:GetPhrase("PreviewHeader"))
    draw.RoundedBoxEx(6, ScrW()/2 - (intTextWw + 24)/2, ScrH() - intTextH + 8 - 24 - intTextHh, intTextWw + 24, intTextHh, Color(THEME["Hover"].r, THEME["Hover"].g, THEME["Hover"].b, 200), true, true, false, false )
    draw.SimpleText(string.format(TalkModes.Languages:GetPhrase("PreviewHeader"), string.upper(input.GetKeyName(TalkModes.Config:GetSetting("General", "Selection Key")))), "TalkModes:Small", ScrW()/2, ScrH() - intTextH + 8 - 24 - intTextHh/2, THEME["White"], TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
end
hook.Add("HUDPaint", "TalkModes.Client.HUDPaint", TalkModes.Client.HUDPaint)

function TalkModes.Client.PostDrawTranslucentRenderables()
    if TM_ADMIN_PREVIEW.bActive == false then return end
    if TM_ADMIN_PREVIEW.intRange == 0 then return end

    render.StartWorldRings()
        render.AddWorldRing(LocalPlayer():GetPos(), TM_ADMIN_PREVIEW.intRange, 10, 50)
    render.FinishWorldRings(THEME["Hover"])
end
hook.Add("PostDrawTranslucentRenderables", "TalkModes.Client.PostDrawTranslucentRenderables", TalkModes.Client.PostDrawTranslucentRenderables)

net.Receive("TalkModes.TriggerPreview", function(_)
    local intRange = net.ReadUInt(12)

    if TM_ADMIN_PREVIEW.bActive == true then 
        TM_ADMIN_PREVIEW.bActive = false
        TM_ADMIN_PREVIEW.intRange = 0
    else 
        TM_ADMIN_PREVIEW.bActive = true 
        TM_ADMIN_PREVIEW.intRange = intRange
    end
end)
--PATH addons/[chat] talk-modes/lua/talk_modes/vgui/libs/cl_circles.lua:
local _R = debug.getregistry()
if (_R.Circles) then return _R.Circles end

local BlurMat = Material("pp/blurscreen")

local rad = math.rad
local cos = math.cos
local sin = math.sin
local min = math.min
local max = math.max

local CIRCLE = {}
CIRCLE.__index = CIRCLE

CIRCLE_FILLED = 0
CIRCLE_OUTLINED = 1
CIRCLE_BLURRED = 2

local function New(type, radius, x, y, ...)
	local circle = setmetatable({}, CIRCLE)

	circle:SetType(tonumber(type))
	circle:SetRadius(tonumber(radius))
	circle:SetPos(tonumber(x), tonumber(y))

	if (type == CIRCLE_OUTLINED) then
		local outline_width = ({...})[1]
		circle:SetOutlineWidth(tonumber(outline_width))
	elseif (type == CIRCLE_BLURRED) then
		local blur_density, blur_quality = unpack({...})
		circle:SetBlurDensity(tonumber(blur_density))
		circle:SetBlurQuality(tonumber(blur_quality))
	end

	return circle
end

local function RotateVertices(vertices, ox, oy, rotation, rotate_uv)
	rotation = rad(rotation)

	local c = cos(rotation)
	local s = sin(rotation)

	for i = 1, #vertices do
		local vertex = vertices[i]
		local vx, vy = vertex.x, vertex.y

		vx = vx - ox
		vy = vy - oy

		vertex.x = ox + (vx * c - vy * s)
		vertex.y = oy + (vx * s + vy * c)

		if (not rotate_uv) then
			local u, v = vertex.u, vertex.v
			u, v = u - 0.5, v - 0.5

			vertex.u = 0.5 + (u * c - v * s)
			vertex.v = 0.5 + (u * s + v * c)
		end
	end
end

local function CalculateVertices(x, y, radius, rotation, start_angle, end_angle, distance, rotate_uv)
	x = tonumber(x) or 0
	y = tonumber(y) or 0
	radius = tonumber(radius) or 16
	rotation = tonumber(rotation) or 0
	start_angle = tonumber(start_angle) or 0
	end_angle = tonumber(end_angle) or 360
	distance = tonumber(distance) or 10

	if (start_angle > end_angle) then
		local tmp = start_angle
		start_angle = end_angle
		end_angle = tmp
	end

	local vertices = {}
	local step = (distance * 360) / (2 * math.pi * radius)

	for a = start_angle, end_angle + step, step do
		a = max(start_angle, min(end_angle, a))
		a = rad(a)

		local c = cos(a)
		local s = sin(a)

		local vertex = {
			x = x + c * radius,
			y = y + s * radius,

			u = 0.5 + c / 2,
			v = 0.5 + s / 2,
		}

		table.insert(vertices, vertex)
	end

	if (end_angle - start_angle ~= 360) then
		table.insert(vertices, 1, {
			x = x, y = y,
			u = 0.5, v = 0.5,
		})
	else
		table.remove(vertices)
	end

	if (rotation ~= 0) then
		RotateVertices(vertices, x, y, rotation, rotate_uv)
	end

	return vertices
end

function CIRCLE:__tostring()
	return string.format("Circle: %p", self)
end

function CIRCLE:Copy()
	return table.Copy(self)
end

function CIRCLE:Calculate()
	local rotate_uv = self:GetRotateMaterial()
	local x, y = self:GetPos()
	local radius = self:GetRadius()
	local rotation = self:GetRotation()
	local start_angle = self:GetStartAngle()
	local end_angle = self:GetEndAngle()
	local distance = self:GetDistance()

	self:SetVertices(CalculateVertices(x, y, radius, rotation, start_angle, end_angle, distance, rotate_uv))

	if (self:GetType() == CIRCLE_OUTLINED) then
		local inner = self:GetChildCircle() or self:Copy()

		inner:SetType(CIRCLE_FILLED)
		inner:SetRadius(self:GetRadius() - self:GetOutlineWidth())
		inner:SetAngles(0, 360)

		inner:SetColor(false)
		inner:SetMaterial(false)
		inner:SetDisableClipping(false)

		self:SetChildCircle(inner)
	end

	self:SetDirty(false)
end

function CIRCLE:__call()
	if (self:GetDirty()) then
		self:Calculate()
	end

	if (IsColor(self:GetColor())) then surface.SetDrawColor(self:GetColor()) end
	if (TypeID(self:GetMaterial()) == TYPE_MATERIAL) then surface.SetMaterial(self:GetMaterial()) end

	local clip = self:GetDisableClipping()
	if (clip) then surface.DisableClipping(true) end

	if (self:GetType() == CIRCLE_OUTLINED) then
		render.ClearStencil()

		render.SetStencilEnable(true)
			render.SetStencilTestMask(0xFF)
			render.SetStencilWriteMask(0xFF)
			render.SetStencilReferenceValue(0x01)

			render.SetStencilCompareFunction(STENCIL_NEVER)
			render.SetStencilFailOperation(STENCIL_REPLACE)
			render.SetStencilZFailOperation(STENCIL_REPLACE)

			self:GetChildCircle()()

			render.SetStencilCompareFunction(STENCIL_GREATER)
			render.SetStencilFailOperation(STENCIL_KEEP)
			render.SetStencilZFailOperation(STENCIL_KEEP)

			surface.DrawPoly(self:GetVertices())
		render.SetStencilEnable(false)
	elseif (self:GetType() == CIRCLE_BLURRED) then
		render.ClearStencil()

		render.SetStencilEnable(true)
			render.SetStencilTestMask(0xFF)
			render.SetStencilWriteMask(0xFF)
			render.SetStencilReferenceValue(0x01)

			render.SetStencilCompareFunction(STENCIL_NEVER)
			render.SetStencilFailOperation(STENCIL_REPLACE)
			render.SetStencilZFailOperation(STENCIL_REPLACE)

			surface.DrawPoly(self:GetVertices())

			render.SetStencilCompareFunction(STENCIL_LESSEQUAL)
			render.SetStencilFailOperation(STENCIL_KEEP)
			render.SetStencilZFailOperation(STENCIL_KEEP)

			surface.SetMaterial(BlurMat)

			local sw, sh = ScrW(), ScrH()

			for i = 1, self:GetBlurQuality() do
				BlurMat:SetFloat("$blur", (i / self:GetBlurQuality()) * self:GetBlurDensity())
				BlurMat:Recompute()

				render.UpdateScreenEffectTexture()
				surface.DrawTexturedRect(0, 0, sw, sh)
			end
		render.SetStencilEnable(false)
	else
		surface.DrawPoly(self:GetVertices())
	end

	if (clip) then surface.DisableClipping(false) end
end

function CIRCLE:Translate(x, y)
	self.m_X = self:GetX() + x
	self.m_Y = self:GetY() + y

	if (self:GetDirty()) then return end

	x = tonumber(x) or 0
	y = tonumber(y) or 0

	for i, v in ipairs(self:GetVertices()) do
		v.x = v.x + x
		v.y = v.y + y
	end

	if (self:GetType() == CIRCLE_OUTLINED) then
		self:GetChildCircle():Translate(x, y)
	end
end

function CIRCLE:Scale(scale)
	self.m_Radius = self:GetRadius() * scale

	if (self:GetDirty()) then return end

	local x, y = self:GetPos()
	scale = tonumber(scale) or 1

	for i, vertex in ipairs(self:GetVertices()) do
		vertex.x = x + ((vertex.x - x) * scale)
		vertex.y = y + ((vertex.y - y) * scale)
	end

	if (self:GetType() == CIRCLE_OUTLINED) then
		self:GetChildCircle():Scale(scale)
	end
end

function CIRCLE:Rotate(degrees)
	self.m_Rotation = self:GetRotation() + degrees

	if (self:GetDirty()) then return end

	local vertices = self:GetVertices()
	local x, y = self:GetPos()
	local rotate_uv = self:GetRotateMaterial()
	degrees = tonumber(degrees) or 0

	RotateVertices(vertices, x, y, degrees, rotate_uv)

	if (self:GetType() == CIRCLE_OUTLINED) then
		self:GetChildCircle():Rotate(degrees)
	end
end

do
	local function AccessorFunc(name, default, dirty, callback)
		local varname = "m_" .. name

		CIRCLE["Get" .. name] = function(self)
			return self[varname]
		end

		CIRCLE["Set" .. name] = function(self, value)
			if (default ~= nil and value == nil) then
				value = default
			end

			if (self[varname] ~= value) then
				if (dirty) then
					self[dirty] = true
				end

				if (isfunction(callback)) then
					value = callback(self, self[varname], value) or value
				end
			end

			self[varname] = value
		end

		CIRCLE[varname] = default
	end

	local function OffsetVerticesX(circle, old, new)
		if (circle:GetDirty() or not circle:GetVertices()) then return end

		for i, vertex in ipairs(circle:GetVertices()) do
			vertex.x = 0 - old + new + old
		end

		if (circle:GetType() == CIRCLE_OUTLINED) then
			OffsetVerticesX(circle:GetChildCircle(), old, new)
		end
	end

	local function OffsetVerticesY(circle, old, new)
		if (circle:GetDirty() or not circle:GetVertices()) then return end

		for i, vertex in ipairs(circle:GetVertices()) do
			vertex.y = 0 - old + new + old
		end

		if (circle:GetType() == CIRCLE_OUTLINED) then
			OffsetVerticesY(circle:GetChildCircle(), old, new)
		end
	end

	local function UpdateRotation(circle, old, new)
		if (circle:GetDirty() or not circle:GetVertices()) then return end

		local vertices = circle:GetVertices()
		local x, y = circle:GetPos()
		local rotation = new - old
		local rotate_uv = circle:GetRotateMaterial()

		RotateVertices(vertices, x, y, rotation, rotate_uv)

		if (circle:GetType() == CIRCLE_OUTLINED) then
			UpdateRotation(circle:GetChildCircle(), old, new)
		end
	end

	-- These are set internally. Only use them if you know what you're doing.
	AccessorFunc("Dirty", true)
	AccessorFunc("Vertices", false)
	AccessorFunc("ChildCircle", false)

	AccessorFunc("Color", false)						-- The colour you want the circle to be. If set to false then surface.SetDrawColor's can be used.
	AccessorFunc("Material", false)						-- The material you want the circle to render. If set to false then surface.SetMaterial can be used.
	AccessorFunc("RotateMaterial", true)				-- Sets whether or not the circle's UV points should be rotated with the vertices.
	AccessorFunc("DisableClipping", false)				-- Sets whether or not to disable clipping when the circle is rendered. Useful for circles that go out of the render bounds.

	AccessorFunc("Type", CIRCLE_FILLED, "m_Dirty") 		-- The circle's type.
	AccessorFunc("X", 0, false, OffsetVerticesX) 		-- The circle's X position relative to the top left of the screen.
	AccessorFunc("Y", 0, false, OffsetVerticesY) 		-- The circle's Y position relative to the top left of the screen.
	AccessorFunc("Radius", 8, "m_Dirty") 				-- The circle's radius.
	AccessorFunc("Rotation", 0, false, UpdateRotation)	-- The circle's rotation, measured in degrees.
	AccessorFunc("StartAngle", 0, "m_Dirty") 			-- The circle's start angle, measured in degrees.
	AccessorFunc("EndAngle", 360, "m_Dirty")			-- The circle's end angle, measured in degrees.
	AccessorFunc("Distance", 10, "m_Dirty")				-- The maximum distance between each of the circle's vertices. Set to false to use segments instead. This should typically be used for large circles in 3D2D.

	AccessorFunc("BlurDensity", 3)						-- The circle's blur density if Type is set to CIRCLE_BLURRED.
	AccessorFunc("BlurQuality", 2)						-- The circle's blur quality if Type is set to CIRCLE_BLURRED.
	AccessorFunc("OutlineWidth", 10, "m_Dirty")			-- The circle's outline width if Type is set to CIRCLE_OUTLINED.

	function CIRCLE:SetPos(x, y)
		self:SetX(x)
		self:SetY(y)
	end

	function CIRCLE:SetAngles(s, e)
		self:SetStartAngle(s)
		self:SetEndAngle(e)
	end

	function CIRCLE:GetPos()
		return self:GetX(), self:GetY()
	end

	function CIRCLE:GetAngles()
		return self:GetStartAngle(), self:GetEndAngle()
	end
end

_R.Circles = {
	New = New,
	RotateVertices = RotateVertices,
	CalculateVertices = CalculateVertices,
}

return _R.Circles

--PATH addons/[chat] talk-modes/lua/talk_modes/vgui/elements/cl_dropdown.lua:
local THEME = TalkModes.Client.ActiveTheme

local PANEL = {}
function PANEL:Init()
    self:SetTextColor(THEME["White"])
    self:SetFont("TalkModes:Small")
end

function PANEL:Paint(intW, intH)
    draw.RoundedBox(6, 0, 0, intW, intH, THEME["Background"])
end

function PANEL:OnSelect()
    self.intW, self.intH = self:GetContentSize()
    self:SetSize(self.intW + 24, self.intH + 4)
end

vgui.Register("TalkModes.Dropdown", PANEL, "DComboBox")
--PATH lua/tfa/enums/sights.lua:
TFA.Enum.SIGHTSPOS_ATTACH = 0
TFA.Enum.SIGHTSPOS_BONE = 1

TFA.Enum.RETICLE_FLAT = bit.lshift(1, 1)
TFA.Enum.RETICLE_MODEL = bit.lshift(1, 2)
TFA.Enum.RETICLE_QUAD = bit.lshift(1, 3)

TFA.Enum.RETICLE_DRAW_ORDER = {
	TFA.Enum.RETICLE_MODEL,
	TFA.Enum.RETICLE_QUAD,
	TFA.Enum.RETICLE_FLAT,
}
--PATH lua/tfa/modules/cl_tfa_commands.lua:
if GetConVar("cl_tfa_inspection_bokeh") == nil then
	CreateClientConVar("cl_tfa_inspection_bokeh", 0, true, false, "Enable inspection bokeh DOF")
end

if GetConVar("cl_tfa_inspection_bokeh_radius") == nil then
	CreateClientConVar("cl_tfa_inspection_bokeh_radius", 0.1, true, false, "Inspection bokeh DOF radius", 0.01, 1)
end

if GetConVar("cl_tfa_inspect_hide_in_screenshots") == nil then
	CreateClientConVar("cl_tfa_inspect_hide_in_screenshots", 0, true, false, "Hide inspection panel in screenshots")
end

if GetConVar("cl_tfa_inspect_hide") == nil then
	CreateClientConVar("cl_tfa_inspect_hide", 0, false, false, "Hide inspection panel")
end

if GetConVar("cl_tfa_inspect_hide_hud") == nil then
	CreateClientConVar("cl_tfa_inspect_hide_hud", 0, true, false, "Hide HUD when inspecting weapon (DLib required)")
end

if GetConVar("cl_tfa_inspect_newbars") == nil then
	CreateClientConVar("cl_tfa_inspect_newbars", 0, true, false, "Use new stat bars in inspection screen")
end

if GetConVar("cl_tfa_inspect_spreadinmoa") == nil then
	CreateClientConVar("cl_tfa_inspect_spreadinmoa", 0, true, false, "Show accuracy in MOA instead of degrees on inspection screen")
end

if GetConVar("cl_tfa_viewbob_intensity") == nil then
	CreateClientConVar("cl_tfa_viewbob_intensity", 1, true, false, "View bob intensity multiplier", 0, 10)
end

if GetConVar("cl_tfa_gunbob_intensity") == nil then
	CreateClientConVar("cl_tfa_gunbob_intensity", 1, true, false, "Gun bob intensity multiplier", 0, 10)
end

if GetConVar("cl_tfa_gunbob_custom") == nil then
	CreateClientConVar("cl_tfa_gunbob_custom", 1, true, false, "Use custom gun bob")
end

if GetConVar("cl_tfa_gunbob_invertsway") == nil then
	CreateClientConVar("cl_tfa_gunbob_invertsway", 0, true, false, "Invert gun sway direction")
end

if GetConVar("cl_tfa_3dscope_quality") == nil then
	CreateClientConVar("cl_tfa_3dscope_quality", 0, true, true, "3D scope quality (0 - Full quality, 1 - Half, 2 - Quarter, 3 - Eighth)", 0, 3)
end

if GetConVar("cl_tfa_3dscope") == nil then
	CreateClientConVar("cl_tfa_3dscope", 1, true, true, "[IGNORED] Enable 3D scopes?")
end

if GetConVar("cl_tfa_scope_sensitivity_3d") == nil then
	CreateClientConVar("cl_tfa_scope_sensitivity_3d", 2, true, true, "3D scope sensitivity (0 - No compensation, 1 - Standard compensation, 2 - 3D compensation, 3 - 3D + FOV compensation)", 0, 3)
end

if GetConVar("cl_tfa_3dscope_overlay") == nil then
	CreateClientConVar("cl_tfa_3dscope_overlay", 0, true, true, "Enable 3D scope shadows?")
end

if GetConVar("cl_tfa_scope_sensitivity_autoscale") == nil then
	CreateClientConVar("cl_tfa_scope_sensitivity_autoscale", 1, true, true, "Compensate sensitivity for FOV?")
end

if GetConVar("cl_tfa_scope_sensitivity") == nil then
	CreateClientConVar("cl_tfa_scope_sensitivity", 100, true, true, "3D scope sensitivity percentage", 0.01, 100)
end

if GetConVar("cl_tfa_ironsights_toggle") == nil then
	CreateClientConVar("cl_tfa_ironsights_toggle", 1, true, true, "Toggle ironsights?")
end

if GetConVar("cl_tfa_ironsights_resight") == nil then
	CreateClientConVar("cl_tfa_ironsights_resight", 1, true, true, "Keep ironsights after reload or sprint?")
end

if GetConVar("cl_tfa_ironsights_responsive") == nil then
	CreateClientConVar("cl_tfa_ironsights_responsive", 0, true, true, "Allow both toggle and held down iron sights")
end

if GetConVar("cl_tfa_ironsights_responsive_timer") == nil then
	CreateClientConVar("cl_tfa_ironsights_responsive_timer", 0.175, true, true, "Time in seconds to determine responsivness time", 0.01, 2)
end

if GetConVar("cl_tfa_laser_trails") == nil then
	CreateClientConVar("cl_tfa_laser_trails", 1, true, true, "Enable laser dot trails?")
end

--Crosshair Params
if GetConVar("cl_tfa_hud_crosshair_length") == nil then
	CreateClientConVar("cl_tfa_hud_crosshair_length", 1, true, false, "Crosshair length")
end

if GetConVar("cl_tfa_hud_crosshair_length_use_pixels") == nil then
	CreateClientConVar("cl_tfa_hud_crosshair_length_use_pixels", 0, true, false, "Should crosshair length use pixels?")
end

if GetConVar("cl_tfa_hud_crosshair_width") == nil then
	CreateClientConVar("cl_tfa_hud_crosshair_width", 1, true, false, "Crosshair width")
end

if GetConVar("cl_tfa_hud_crosshair_enable_custom") == nil then
	CreateClientConVar("cl_tfa_hud_crosshair_enable_custom", 1, true, false, "Enable custom crosshair?")
end

if GetConVar("cl_tfa_hud_crosshair_gap_scale") == nil then
	CreateClientConVar("cl_tfa_hud_crosshair_gap_scale", 1, true, false, "Crosshair gap scale")
end

if GetConVar("cl_tfa_hud_crosshair_dot") == nil then
	CreateClientConVar("cl_tfa_hud_crosshair_dot", 0, true, false, "Enable crosshair dot?")
end

--Crosshair Color
if GetConVar("cl_tfa_hud_crosshair_color_r") == nil then
	CreateClientConVar("cl_tfa_hud_crosshair_color_r", 225, true, false, nil, 0, 255)
end
if GetConVar("cl_tfa_hud_crosshair_color_g") == nil then
	CreateClientConVar("cl_tfa_hud_crosshair_color_g", 225, true, false, nil, 0, 255)
end
if GetConVar("cl_tfa_hud_crosshair_color_b") == nil then
	CreateClientConVar("cl_tfa_hud_crosshair_color_b", 225, true, false, nil, 0, 255)
end
if GetConVar("cl_tfa_hud_crosshair_color_a") == nil then
	CreateClientConVar("cl_tfa_hud_crosshair_color_a", 200, true, false, nil, 0, 255)
end

if GetConVar("cl_tfa_hud_crosshair_color_team") == nil then
	CreateClientConVar("cl_tfa_hud_crosshair_color_team", 1, true, false, "Should crosshair use team color of entity being aimed at?")
end

-- Crosshair Team Color: Friendly
if GetConVar("cl_tfa_hud_crosshair_color_friendly_r") == nil then
	CreateClientConVar("cl_tfa_hud_crosshair_color_friendly_r", 0, true, false, nil, 0, 255)
end
if GetConVar("cl_tfa_hud_crosshair_color_friendly_g") == nil then
	CreateClientConVar("cl_tfa_hud_crosshair_color_friendly_g", 255, true, false, nil, 0, 255)
end
if GetConVar("cl_tfa_hud_crosshair_color_friendly_b") == nil then
	CreateClientConVar("cl_tfa_hud_crosshair_color_friendly_b", 0, true, false, nil, 0, 255)
end

-- Crosshair Team Color: Enemy
if GetConVar("cl_tfa_hud_crosshair_color_enemy_r") == nil then
	CreateClientConVar("cl_tfa_hud_crosshair_color_enemy_r", 255, true, false, nil, 0, 255)
end
if GetConVar("cl_tfa_hud_crosshair_color_enemy_g") == nil then
	CreateClientConVar("cl_tfa_hud_crosshair_color_enemy_g", 0, true, false, nil, 0, 255)
end
if GetConVar("cl_tfa_hud_crosshair_color_enemy_b") == nil then
	CreateClientConVar("cl_tfa_hud_crosshair_color_enemy_b", 0, true, false, nil, 0, 255)
end

--Crosshair Outline
if GetConVar("cl_tfa_hud_crosshair_outline_color_r") == nil then
	CreateClientConVar("cl_tfa_hud_crosshair_outline_color_r", 5, true, false, nil, 0, 255)
end

if GetConVar("cl_tfa_hud_crosshair_outline_color_g") == nil then
	CreateClientConVar("cl_tfa_hud_crosshair_outline_color_g", 5, true, false, nil, 0, 255)
end

if GetConVar("cl_tfa_hud_crosshair_outline_color_b") == nil then
	CreateClientConVar("cl_tfa_hud_crosshair_outline_color_b", 5, true, false, nil, 0, 255)
end

if GetConVar("cl_tfa_hud_crosshair_outline_color_a") == nil then
	CreateClientConVar("cl_tfa_hud_crosshair_outline_color_a", 200, true, false, nil, 0, 255)
end

if GetConVar("cl_tfa_hud_crosshair_outline_width") == nil then
	CreateClientConVar("cl_tfa_hud_crosshair_outline_width", 1, true, false, "Crosshair outline width")
end

if GetConVar("cl_tfa_hud_crosshair_outline_enabled") == nil then
	CreateClientConVar("cl_tfa_hud_crosshair_outline_enabled", 1, true, false, "Enable crosshair outline?")
end

if GetConVar("cl_tfa_hud_crosshair_triangular") == nil then
	CreateClientConVar("cl_tfa_hud_crosshair_triangular", 0, true, false, "Enable triangular Crysis-like crosshair?")
end

if GetConVar("cl_tfa_hud_crosshair_pump") == nil then
	CreateClientConVar("cl_tfa_hud_crosshair_pump", 0, true, false, "Enable pump feedback on crosshair?")
end

if GetConVar("cl_tfa_hud_hitmarker_enabled") == nil then
	CreateClientConVar("cl_tfa_hud_hitmarker_enabled", 1, true, false, "Enable hit marker?")
end

if GetConVar("cl_tfa_hud_hitmarker_fadetime") == nil then
	CreateClientConVar("cl_tfa_hud_hitmarker_fadetime", 0.3, true, false, "Hit marker fade time (in seconds)", 0, 3)
end

if GetConVar("cl_tfa_hud_hitmarker_solidtime") == nil then
	CreateClientConVar("cl_tfa_hud_hitmarker_solidtime", 0.1, true, false, nil, 0, 3)
end

if GetConVar("cl_tfa_hud_hitmarker_scale") == nil then
	CreateClientConVar("cl_tfa_hud_hitmarker_scale", 1, true, false, "Hit marker scale", 0, 5)
end

-- Hitmarker Color
if GetConVar("cl_tfa_hud_hitmarker_color_r") == nil then
	CreateClientConVar("cl_tfa_hud_hitmarker_color_r", 225, true, false, nil, 0, 255)
end
if GetConVar("cl_tfa_hud_hitmarker_color_g") == nil then
	CreateClientConVar("cl_tfa_hud_hitmarker_color_g", 225, true, false, nil, 0, 255)
end
if GetConVar("cl_tfa_hud_hitmarker_color_b") == nil then
	CreateClientConVar("cl_tfa_hud_hitmarker_color_b", 225, true, false, nil, 0, 255)
end
if GetConVar("cl_tfa_hud_hitmarker_color_a") == nil then
	CreateClientConVar("cl_tfa_hud_hitmarker_color_a", 200, true, false, nil, 0, 255)
end

if GetConVar("cl_tfa_hud_hitmarker_3d_all") == nil then
	CreateClientConVar("cl_tfa_hud_hitmarker_3d_all", 0, true, true)
end

if GetConVar("cl_tfa_hud_hitmarker_3d_shotguns") == nil then
	CreateClientConVar("cl_tfa_hud_hitmarker_3d_shotguns", 1, true, true)
end

--Other stuff
if GetConVar("cl_tfa_hud_ammodata_fadein") == nil then
	CreateClientConVar("cl_tfa_hud_ammodata_fadein", 0.2, true, false)
end

if GetConVar("cl_tfa_hud_hangtime") == nil then
	CreateClientConVar("cl_tfa_hud_hangtime", 1, true, true)
end

if GetConVar("cl_tfa_hud_enabled") == nil then
	CreateClientConVar("cl_tfa_hud_enabled", 1, true, false, "Enable 3D2D hud?")
end

if GetConVar("cl_tfa_hud_fallback_enabled") == nil then
	CreateClientConVar("cl_tfa_hud_fallback_enabled", 1, true, false, "Enable basic fallback hud?")
end

if GetConVar("cl_tfa_hud_scale") == nil then
	CreateClientConVar("cl_tfa_hud_scale", 1, true, false, "Size multiplier of HUD elements", .25, 4)
end

if GetConVar("cl_tfa_fx_gasblur") == nil then
	CreateClientConVar("cl_tfa_fx_gasblur", 0, true, true, "Enable muzzle gas blur?")
end

if GetConVar("cl_tfa_fx_muzzlesmoke") == nil then
	CreateClientConVar("cl_tfa_fx_muzzlesmoke", 1, true, true, "Enable muzzle smoke trail?")
end

if GetConVar("cl_tfa_fx_muzzlesmoke_limited") == nil then
	CreateClientConVar("cl_tfa_fx_muzzlesmoke_limited", 1, true, true, "Limit muzzle smoke trails?")
end

if GetConVar("cl_tfa_fx_muzzleflashsmoke") == nil then
	CreateClientConVar("cl_tfa_fx_muzzleflashsmoke", 1, true, true, "Enable muzzleflash smoke?")
end

if GetConVar("cl_tfa_legacy_shells") == nil then
	CreateClientConVar("cl_tfa_legacy_shells", 0, true, true, "Use legacy shells?")
end

if GetConVar("cl_tfa_fx_ejectionsmoke") == nil then
	CreateClientConVar("cl_tfa_fx_ejectionsmoke", 1, true, true, "Enable shell ejection smoke?")
end

if GetConVar("cl_tfa_fx_ejectionlife") == nil then
	CreateClientConVar("cl_tfa_fx_ejectionlife", 15, true, true, "How long shells exist in the world")
end

if GetConVar("cl_tfa_fx_impact_enabled") == nil then
	CreateClientConVar("cl_tfa_fx_impact_enabled", 1, true, true, "Enable custom bullet impact effects?")
end

if GetConVar("cl_tfa_fx_impact_ricochet_enabled") == nil then
	CreateClientConVar("cl_tfa_fx_impact_ricochet_enabled", 1, true, true, "Enable bullet ricochet effect?")
end

if GetConVar("cl_tfa_fx_impact_ricochet_sparks") == nil then
	CreateClientConVar("cl_tfa_fx_impact_ricochet_sparks", 6, true, true, "Enable bullet ricochet sparks?")
end

if GetConVar("cl_tfa_fx_impact_ricochet_sparklife") == nil then
	CreateClientConVar("cl_tfa_fx_impact_ricochet_sparklife", 2, true, true)
end

if GetConVar("cl_tfa_fx_ads_dof") == nil then
	CreateClientConVar("cl_tfa_fx_ads_dof", 0, true, true, "Enable iron sights DoF (Depth of Field)")
end

if GetConVar("cl_tfa_fx_ads_dof_hd") == nil then
	CreateClientConVar("cl_tfa_fx_ads_dof_hd", 0, true, true, "Enable better quality for DoF")
end

--viewbob

if GetConVar("cl_tfa_viewbob_animated") == nil then
	CreateClientConVar("cl_tfa_viewbob_animated", 1, true, false, "Use animated viewbob?")
end

--Viewmodel Mods
if GetConVar("cl_tfa_viewmodel_offset_x") == nil then
	CreateClientConVar("cl_tfa_viewmodel_offset_x", 0, true, false, nil, -2, 2)
end

if GetConVar("cl_tfa_viewmodel_offset_y") == nil then
	CreateClientConVar("cl_tfa_viewmodel_offset_y", 0, true, false, nil, -2, 2)
end

if GetConVar("cl_tfa_viewmodel_offset_z") == nil then
	CreateClientConVar("cl_tfa_viewmodel_offset_z", 0, true, false, nil, -2, 2)
end

if GetConVar("cl_tfa_viewmodel_offset_fov") == nil then
	CreateClientConVar("cl_tfa_viewmodel_offset_fov", 0, true, false, nil, -5, 5)
end

if GetConVar("cl_tfa_viewmodel_multiplier_fov") == nil then
	CreateClientConVar("cl_tfa_viewmodel_multiplier_fov", 1, true, false, nil, 0.75, 2)
end

if GetConVar("cl_tfa_viewmodel_flip") == nil then
	CreateClientConVar("cl_tfa_viewmodel_flip", 0, true, false)
end

if GetConVar("cl_tfa_viewmodel_centered") == nil then
	CreateClientConVar("cl_tfa_viewmodel_centered", 0, true, false)
end

if GetConVar("cl_tfa_viewmodel_nearwall") == nil then
	CreateClientConVar("cl_tfa_viewmodel_nearwall", 1, true, false)
end

if GetConVar("cl_tfa_viewmodel_vp_enabled") == nil then
	CreateClientConVar("cl_tfa_viewmodel_vp_enabled", 1, true, false)
end

if GetConVar("cl_tfa_viewmodel_vp_pitch") == nil then
	CreateClientConVar("cl_tfa_viewmodel_vp_pitch", 1, true, false, nil, 0, 10)
end

if GetConVar("cl_tfa_viewmodel_vp_pitch_is") == nil then
	CreateClientConVar("cl_tfa_viewmodel_vp_pitch_is", 1, true, false, nil, 0, 10)
end

if GetConVar("cl_tfa_viewmodel_vp_vertical") == nil then
	CreateClientConVar("cl_tfa_viewmodel_vp_vertical", 1, true, false, nil, 0, 10)
end

if GetConVar("cl_tfa_viewmodel_vp_vertical_is") == nil then
	CreateClientConVar("cl_tfa_viewmodel_vp_vertical_is", 1, true, false, nil, 0, 10)
end

if GetConVar("cl_tfa_viewmodel_vp_max_vertical") == nil then
	CreateClientConVar("cl_tfa_viewmodel_vp_max_vertical", 1, true, false, nil, 0, 10)
end

if GetConVar("cl_tfa_viewmodel_vp_max_vertical_is") == nil then
	CreateClientConVar("cl_tfa_viewmodel_vp_max_vertical_is", 1, true, false, nil, 0, 10)
end

if GetConVar("cl_tfa_viewmodel_vp_yaw") == nil then
	CreateClientConVar("cl_tfa_viewmodel_vp_yaw", 1, true, false, nil, 0, 10)
end

if GetConVar("cl_tfa_viewmodel_vp_yaw_is") == nil then
	CreateClientConVar("cl_tfa_viewmodel_vp_yaw_is", 1, true, false, nil, 0, 10)
end

if GetConVar("cl_tfa_debug_crosshair") == nil then
	CreateClientConVar("cl_tfa_debug_crosshair", 0, false, false, "Debug crosshair (Admin only)")
end

if GetConVar("cl_tfa_debug_animations") == nil then
	CreateClientConVar("cl_tfa_debug_animations", 0, false, false, "Debug animations (Admin only)")
end

if GetConVar("cl_tfa_debug_rt") == nil then
	CreateClientConVar("cl_tfa_debug_rt", 0, false, false, "Debug RT scopes (Admin only)")
end

if GetConVar("cl_tfa_debug_cache") == nil then
	CreateClientConVar("cl_tfa_debug_cache", 0, false, false, "Disable stat caching (may cause heavy performance impact!)")
end

local function UpdateColorCVars()
	timer.Create("tfa_apply_player_color", 0.5, 1, function()
		RunConsoleCommand("sv_tfa_apply_player_colors")
	end)
end

--Reticule Color
if GetConVar("cl_tfa_reticule_color_r") == nil then
	CreateClientConVar("cl_tfa_reticule_color_r", 255, true, true)
	cvars.AddChangeCallback("cl_tfa_reticule_color_r", UpdateColorCVars, "TFANetworkPlayerColors")
end
if GetConVar("cl_tfa_reticule_color_g") == nil then
	CreateClientConVar("cl_tfa_reticule_color_g", 100, true, true)
	cvars.AddChangeCallback("cl_tfa_reticule_color_g", UpdateColorCVars, "TFANetworkPlayerColors")
end
if GetConVar("cl_tfa_reticule_color_b") == nil then
	CreateClientConVar("cl_tfa_reticule_color_b", 0, true, true)
	cvars.AddChangeCallback("cl_tfa_reticule_color_b", UpdateColorCVars, "TFANetworkPlayerColors")
end

--Laser Color
if GetConVar("cl_tfa_laser_color_r") == nil then
	CreateClientConVar("cl_tfa_laser_color_r", 255, true, true)
	cvars.AddChangeCallback("cl_tfa_laser_color_r", UpdateColorCVars, "TFANetworkPlayerColors")
end
if GetConVar("cl_tfa_laser_color_g") == nil then
	CreateClientConVar("cl_tfa_laser_color_g", 0, true, true)
	cvars.AddChangeCallback("cl_tfa_laser_color_g", UpdateColorCVars, "TFANetworkPlayerColors")
end
if GetConVar("cl_tfa_laser_color_b") == nil then
	CreateClientConVar("cl_tfa_laser_color_b", 0, true, true)
	cvars.AddChangeCallback("cl_tfa_laser_color_b", UpdateColorCVars, "TFANetworkPlayerColors")
end

if GetConVar("cl_tfa_attachments_persist_enabled") == nil then
	CreateClientConVar("cl_tfa_attachments_persist_enabled", 1, true, true, "Should attachments selection persist across different weapons/lives/sessions?")
end

if GetConVar("cl_tfa_hud_keybindhints_enabled") == nil then
	CreateClientConVar("cl_tfa_hud_keybindhints_enabled", "1", true, false, "Enable keybind hints?")
end

if GetConVar("cl_tfa_hud_keybindhints_solidtime") == nil then
	CreateClientConVar("cl_tfa_hud_keybindhints_solidtime", 3, true, false, "How long keybind hint will stay on screen (in seconds)", 0)
end

if GetConVar("cl_tfa_hud_keybindhints_fadeintime") == nil then
	CreateClientConVar("cl_tfa_hud_keybindhints_fadeintime", 1, true, false, "Keybind hint fade-in time (in seconds)", 0.01)
end

if GetConVar("cl_tfa_hud_keybindhints_fadeouttime") == nil then
	CreateClientConVar("cl_tfa_hud_keybindhints_fadeouttime", 4, true, false, "Keybind hint fade-out time (in seconds)", 0.01)
end

--PATH lua/tfa/modules/tfa_matproxies.lua:
local nvec = Vector()

local function SetPlayerColors(ply)
	if not IsValid(ply) then return end

	local _SetNWVector = ply.SetNW2Vector or ply.SetNWVector

	nvec.x = ply:GetInfoNum("cl_tfa_laser_color_r", 255)
	nvec.y = ply:GetInfoNum("cl_tfa_laser_color_g", 0)
	nvec.z = ply:GetInfoNum("cl_tfa_laser_color_b", 0)
	_SetNWVector(ply, "TFALaserColor", nvec)

	nvec.x = ply:GetInfoNum("cl_tfa_reticule_color_r", 255)
	nvec.y = ply:GetInfoNum("cl_tfa_reticule_color_g", 0)
	nvec.z = ply:GetInfoNum("cl_tfa_reticule_color_b", 0)
	_SetNWVector(ply, "TFAReticuleColor", nvec)
end

hook.Add("PlayerSpawn", "TFANetworkColors_Spawn", SetPlayerColors)
concommand.Add("sv_tfa_apply_player_colors", SetPlayerColors)

if not matproxy then return end

matproxy.Add({
	name = "PlayerWeaponColorStatic",
	init = function(self, mat, values)
		self.ResultTo = values.resultvar
	end,
	bind = function(self, mat, ent)
		if (not IsValid(ent)) then return end
		local owner = ent:GetOwner()
		if (not IsValid(owner) or not owner:IsPlayer()) then return end
		local col = owner:GetWeaponColor()
		if (not isvector(col)) then return end
		mat:SetVector(self.ResultTo, col * 1)
	end
})

local cvec = Vector()

matproxy.Add({
	name = "TFALaserColor",
	init = function(self, mat, values)
		self.ResultTo = values.resultvar
	end,
	bind = function(self, mat, ent)
		local owner

		if (IsValid(ent)) then
			owner = ent:GetOwner()

			if not IsValid(owner) then
				owner = ent:GetParent()
			end

			if IsValid(owner) and owner:IsWeapon() then
				owner = owner:GetOwner() or owner:GetOwner()
			end

			if not (IsValid(owner) and owner:IsPlayer()) then
				owner = GetViewEntity()
			end
		else
			owner = GetViewEntity()
		end

		if (not IsValid(owner) or not owner:IsPlayer()) then return end
		local c

		if owner.GetNW2Vector then
			c = owner:GetNW2Vector("TFALaserColor") or cvec
		else
			c = owner:GetNWVector("TFALaserColor") or cvec
		end

		cvec.x = math.sqrt(c.r / 255) --sqrt for gamma
		cvec.y = math.sqrt(c.g / 255)
		cvec.z = math.sqrt(c.b / 255)
		mat:SetVector(self.ResultTo, cvec)
	end
})

local cvec_r = Vector()

matproxy.Add({
	name = "TFAReticuleColor",
	init = function(self, mat, values)
		self.ResultTo = values.resultvar
	end,
	bind = function(self, mat, ent)
		local owner

		if (IsValid(ent)) then
			owner = ent:GetOwner()

			if not IsValid(owner) then
				owner = ent:GetParent()
			end

			if IsValid(owner) and owner:IsWeapon() then
				owner = owner:GetOwner() or owner:GetOwner()
			end

			if not (IsValid(owner) and owner:IsPlayer()) then
				owner = GetViewEntity()
			end
		else
			owner = GetViewEntity()
		end

		if (not IsValid(owner) or not owner:IsPlayer()) then return end
		local c

		if owner.GetNW2Vector then
			c = owner:GetNW2Vector("TFAReticuleColor") or cvec_r
		else
			c = owner:GetNWVector("TFAReticuleColor") or cvec_r
		end

		cvec_r.x = c.r / 255
		cvec_r.y = c.g / 255
		cvec_r.z = c.b / 255
		mat:SetVector(self.ResultTo, cvec_r)
	end
})

matproxy.Add({
	name = "TFA_RTScope",
	init = function(self, mat, values)
		self.RTMaterial = Material("!tfa_rtmaterial")
	end,
	bind = function(self, mat, ent)
		if not self.RTMaterial then
			self.RTMaterial = Material("!tfa_rtmaterial")
		end

		mat:SetTexture("$basetexture", self.RTMaterial:GetTexture("$basetexture"))
	end
})

local Lerp = Lerp
local RealFrameTime = RealFrameTime

local vector_one = Vector(1, 1, 1)

matproxy.Add({
	name = "TFA_CubemapTint",
	init = function(self, mat, values)
		self.ResultVar = values.resultvar or "$envmaptint"
		self.MultVar = values.multiplier
	end,
	bind = function(self, mat, ent)
		local tint = vector_one

		if IsValid(ent) then
			local mult = self.MultVar and mat:GetVector(self.MultVar) or vector_one

			tint = Lerp(RealFrameTime() * 10, mat:GetVector(self.ResultVar), mult * render.GetLightColor(ent:GetPos()))
		end

		mat:SetVector(self.ResultVar, tint)
	end
})

-- VMT Example:
--[[
	$envmapmultiplier	"[1 1 1]" // Lighting will be multiplied by this value

	Proxies
	{
		TFA_CubemapTint
		{
			resultvar	$envmaptint // Write final output to $envmaptint
			multiplier	$envmapmultiplier // Use our value for default envmap tint
		}
	}
]]

--PATH lua/tfa/modules/tfa_netcode.lua:
if SERVER then
	--Pool netstrings
	util.AddNetworkString("tfaSoundEvent")
	util.AddNetworkString("tfaSoundEventStop")
	util.AddNetworkString("tfa_base_muzzle_mp")
	util.AddNetworkString("tfaShotgunInterrupt")
	util.AddNetworkString("tfaRequestFidget")
	util.AddNetworkString("tfaSDLP")
	util.AddNetworkString("tfaArrowFollow")
	util.AddNetworkString("tfaTracerSP")
	util.AddNetworkString("tfaBaseShellSV")
	--util.AddNetworkString("tfaAltAttack")

	util.AddNetworkString("tfaHitmarker")
	util.AddNetworkString("tfaHitmarker3D")
	util.AddNetworkString("tfa_friendly_encounter")

	do
		local old_state = false

		timer.Create("tfa_friendly_encounter", 2, 0, function()
			local new_state = game.GetGlobalState("friendly_encounter") == GLOBAL_ON

			if old_state ~= new_state then
				net.Start("tfa_friendly_encounter")
				net.WriteBool(new_state)
				net.Broadcast()

				old_state = new_state
			end
		end)

		hook.Add("PlayerAuthed", "tfa_friendly_encounter", function()
			old_state = false
		end)
	end

	--Enable CKey Inspection

	net.Receive("tfaRequestFidget",function(length,client)
		local wep = client:GetActiveWeapon()
		if IsValid(wep) and wep.CheckAmmo then wep:CheckAmmo() end
	end)

	--Enable shotgun interruption
	net.Receive("tfaShotgunInterrupt", function(length, client)
		if IsValid(client) and client:IsPlayer() and client:Alive() then
			local ply = client
			local wep = ply:GetActiveWeapon()

			if IsValid(wep) and wep.ShotgunInterrupt then
				wep:ShotgunInterrupt()
			end
		end
	end)

	if game.SinglePlayer() then
		net.Receive("tfaSDLP",function(length,client)
			local bool = net.ReadBool()
			client.TFASDLP = bool
		end)
	end

	--Enable alternate attacks
	--[[
	net.Receive("tfaAltAttack", function(length, client)
		if IsValid(client) and client:IsPlayer() and client:Alive() then
			local ply = client
			wep = ply:GetActiveWeapon()

			if IsValid(wep) and wep.AltAttack then
				wep:AltAttack()
			end
		end
	end)
	]]--
else
	TFA.FriendlyEncounter = false

	net.Receive("tfa_friendly_encounter", function()
		TFA.FriendlyEncounter = net.ReadBool()
	end)

	--Arrow can follow entities clientside too
	net.Receive("tfaArrowFollow",function()
		local ent = net.ReadEntity()
		ent.targent = net.ReadEntity()
		ent.targbone = net.ReadInt( 8 )
		ent.posoff = net.ReadVector(  )
		ent.angoff = net.ReadAngle(  )
		ent:TargetEnt( false )
	end)

	--Receive sound events on client
	net.Receive("tfaSoundEvent", function(length, ply)
		local wep = net.ReadEntity()
		local snd = net.ReadString()
		local shouldPause = net.ReadBool()

		if IsValid(wep) and snd and snd ~= "" then
			wep:EmitSound(snd, nil, nil, nil, nil, shouldPause and SND_SHOULDPAUSE or SND_NOFLAGS)
		end
	end)

	net.Receive("tfaSoundEventStop", function(length, ply)
		local wep = net.ReadEntity()
		local snd = net.ReadString()

		if IsValid(wep) and snd and snd ~= "" then
			wep:StopSound(snd)
		end
	end)

	--Receive muzzleflashes on client
	net.Receive("tfa_base_muzzle_mp", function(length, ply)
		local wep = net.ReadEntity()

		if IsValid(wep) and wep.ShootEffectsCustom then
			wep:ShootEffectsCustom(true)
		end
	end)

	net.Receive("tfaBaseShellSV", function(length, ply)
		local wep = net.ReadEntity()

		if IsValid(wep) and wep.MakeShellBridge then
			wep:MakeShellBridge()
		end
	end)

	net.Receive( "tfaTracerSP", function( length, ply )
		local part = net.ReadString()
		local startPos = net.ReadVector()
		local endPos = net.ReadVector()
		local woosh = net.ReadBool()
		local vent = net.ReadEntity()
		local att = net.ReadInt( 8 )
		if IsValid( vent ) then
			local aP = vent:GetAttachment( att or 1 )
			if aP then
				startPos = aP.Pos
			end
		end
		TFA.ParticleTracer( part, startPos, endPos, woosh, vent, att )
	end)
end

--PATH lua/tfa/3dscoped_base.lua:
return gluapack()()
--PATH lua/tfa/modules/tfa_npc_weaponmenu.lua:
-- AI Options
if CLIENT then
	hook.Add("PopulateMenuBar", "NPCOptions_MenuBar_TFA", function(menubarV)
		local m = menubarV:AddOrGetMenu("#menubar.npcs")
		local wpns = m:AddSubMenu("#tfa.menubar.npcs.weapon")
		wpns:SetDeleteSelf(false)

		wpns:AddCVar("#menubar.npcs.defaultweapon", "gmod_npcweapon", "")
		wpns:AddCVar("#menubar.npcs.noweapon", "gmod_npcweapon", "none")
		wpns:AddSpacer()

		local weaponCats = {}

		for _, wep in pairs(weapons.GetList()) do
			if wep and wep.Spawnable and weapons.IsBasedOn(wep.ClassName, "tfa_gun_base") then
				local cat = wep.Category or "Other"
				weaponCats[cat] = weaponCats[cat] or {}

				table.insert(weaponCats[cat], {
					["class"] = wep.ClassName,
					["title"] = wep.PrintName or wep.ClassName
				})
			end
		end

		local catKeys = table.GetKeys(weaponCats)
		table.sort(catKeys, function(a, b) return a < b end)

		for _, k in ipairs(catKeys) do
			local v = weaponCats[k]
			local wpnSub = wpns:AddSubMenu(k)
			wpnSub:SetDeleteSelf(false)
			table.SortByMember(v, "title", true)

			for _, b in ipairs(v) do
				wpnSub:AddCVar(b.title, "gmod_npcweapon", b.class)
			end
		end
	end)
else
	local npcWepList = list.GetForEdit("NPCUsableWeapons")

	hook.Add("PlayerSpawnNPC", "TFACheckNPCWeapon", function(plyv, npcclassv, wepclassv)
		if type(wepclassv) ~= "string" or wepclassv == "" then return end

		if not npcWepList[wepclassv] then -- do not copy the table
			local wep = weapons.GetStored(wepclassv)

			if wep and (wep.Spawnable and not wep.AdminOnly) and weapons.IsBasedOn(wep.ClassName, "tfa_gun_base") then
				npcWepList[wepclassv] = {
					["class"] = wep.ClassName,
					["title"] = wep.PrintName or wep.ClassName
				}
			end
		end
	end)
end

--PATH lua/tfa/modules/tfa_nzombies.lua:
TFA.NZombies = TFA.NZombies or {}

if TFA.NZombies.Patch == nil then
	TFA.NZombies.Patch = true --Change this if you need to
end

local cv_melee_scaling, cv_melee_basefactor, cv_melee_berserkscale
local nzombies = string.lower(engine.ActiveGamemode() or "") == "nzombies"

if nZombies or NZombies or NZ then
	nzombies = true
end

if nzombies then
	cv_melee_scaling = CreateConVar("sv_tfa_nz_melee_scaling", "1", {FCVAR_SERVER_CAN_EXECUTE, FCVAR_REPLICATED}, "0.5x means if zombies have 4x health, melee does 2x damage")
	cv_melee_basefactor = CreateConVar("sv_tfa_nz_melee_multiplier", "0.65", {FCVAR_SERVER_CAN_EXECUTE, FCVAR_REPLICATED}, "Base damage scale for TFA Melees.")
	cv_melee_berserkscale = CreateConVar("sv_tfa_nz_melee_immunity", "0.67", {FCVAR_SERVER_CAN_EXECUTE, FCVAR_REPLICATED}, "Take X% damage from zombies while you're melee.")
	--cv_melee_juggscale = CreateConVar("sv_tfa_nz_melee_juggernaut", "1.5", {FCVAR_SERVER_CAN_EXECUTE, FCVAR_REPLICATED}, "Do X% damage to zombies while you're jug.")
	hook.Add("TFA_AnimationRate","NZBase",function(wep,act,rate)
		if wep:OwnerIsValid() and wep:GetOwner().HasPerk and wep:GetOwner():HasPerk("speed") and wep.SpeedColaActivities[ act ] then
			rate = rate * wep.SpeedColaFactor
		end
		if wep:OwnerIsValid() and wep:GetOwner().HasPerk and wep:GetOwner():HasPerk("dtap") and wep.DTapActivities[ act ] then
			rate = rate * wep.DTapSpeed
		end
		if wep:OwnerIsValid() and wep:GetOwner().HasPerk and wep:GetOwner():HasPerk("dtap2") and wep.DTapActivities[ act ] then
			rate = rate * wep.DTap2Speed
		end
		return rate
	end)
	hook.Add("TFA_Deploy","NZBase",function(wep)
		local pap = wep:GetPaP()
		wep.OldPaP = pap
		local spd2 = wep:OwnerIsValid() and wep:GetOwner().HasPerk and wep:GetOwner():HasPerk("speed")
		if pap and pap ~= wep.OldPaP then
			if AddPackAPunchName and wep.NZPaPName and not wep.HasAddedNZName then
				AddPackAPunchName( wep.ClassName, wep.NZPaPName )
				wep.HasAddedNZName = true
			end
			if wep.NZPaPName and wep:GetPaP() then
				wep.PrintName = wep.NZPaPName
				wep:SetNW2String("PrintName",wep.NZPaPName)
			end
			local pn = wep:GetNW2String("PrintName")
			if pn and pn ~= "" then
				wep.PrintName = pn
			end
			wep:ClearStatCache()
			timer.Simple(0.1,function()
				if IsValid(wep) then
					wep:ClearStatCache()
				end
			end)
		end
		if spd2 ~= wep.OldSpCola then
			wep:ClearStatCache()
		end
		wep.OldSpCola = spd2
	end)
	hook.Add("TFA_Initialize", "NZBase", function(wep)
		timer.Simple(0.1, function() -- timers for everything YAY
			if not IsValid(wep) then return end

			wep.Primary_TFA.Ammo = game.GetAmmoName(wep:GetPrimaryAmmoType())
			wep:ClearStatCache("Primary.Ammo")
		end)
	end)
end
--[[
local function SpreadFix()

	local GAMEMODE = gmod.GetGamemode() or GAMEMODE
	if not GAMEMODE then return end

	print("[TFA] Patching NZombies")
	if TFA.NZombies.Patch then return end

	local ghosttraceentities = {
		["wall_block"] = true,
		["invis_wall"] = true,
		["player"] = true
	}

	function GAMEMODE:EntityFireBullets(ent, data)
		-- Fire the PaP shooting sound if the weapon is PaP'd
		--print(wep, wep.pap)
		if ent:IsPlayer() and IsValid(ent:GetActiveWeapon()) then
			local wep = ent:GetActiveWeapon()
			if wep.pap and ( not wep.IsMelee ) and ( not wep.IsKnife ) then
				wep:EmitSound("nz/effects/pap_shoot_glock20.wav", 105, 100)
			end
		end

		if ent:IsPlayer() and ent:HasPerk("dtap2") then
			data.Num = data.Num * 2
		end

		-- Perform a trace that filters out entities from the table above
		local tr = util.TraceLine({
			start = data.Src,
			endpos = data.Src + (data.Dir * data.Distance),
			filter = function(entv)
				if ghosttraceentities[entv:GetClass()] and not entv:IsPlayer() then
					return true
				else
					return false
				end
			end
		})

		--PrintTable(tr)
		-- If we hit anything, move the source of the bullets up to that point
		if IsValid(tr.Entity) and tr.Fraction < 1 then
			local tr2 = util.TraceLine({
				start = data.Src,
				endpos = data.Src + (data.Dir * data.Distance),
				filter = function(entv)
					if ghosttraceentities[entv:GetClass()] then
						return false
					else
						return true
					end
				end
			})

			data.Src = tr2.HitPos - data.Dir * 5

			return true
		end

		if ent:IsPlayer() and ent:HasPerk("dtap2") then return true end
	end
end
]]
--
local function MeleeFix()
	hook.Add("EntityTakeDamage", "TFA_MeleeScaling", function(target, dmg)
		if not TFA.NZombies.Patch then return end
		if not nzRound then return end
		local ent = dmg:GetInflictor()

		if not ent:IsWeapon() and ent:IsPlayer() then
			ent = ent:GetActiveWeapon()
		end

		if not IsValid(ent) or not ent:IsWeapon() then return end

		if ent.IsTFAWeapon and (dmg:IsDamageType(DMG_CRUSH) or dmg:IsDamageType(DMG_CLUB) or dmg:IsDamageType(DMG_SLASH)) then
			local scalefactor = cv_melee_scaling:GetFloat()
			local basefactor = cv_melee_basefactor:GetFloat()
			dmg:ScaleDamage(((nzRound:GetZombieHealth() - 75) / 75 * scalefactor + 1) * basefactor)
			--if IsValid(ent:GetOwner()) and ent:GetOwner():IsPlayer() and ent:GetOwner():HasPerk("jugg") then
			--	dmg:ScaleDamage(cv_melee_juggscale:GetFloat())
			--end
		end
	end)

	hook.Add("EntityTakeDamage", "TFA_MeleeReceiveLess", function(target, dmg)
		if not TFA.NZombies.Patch then return end

		if target:IsPlayer() and target.GetActiveWeapon then
			local wep = target:GetActiveWeapon()

			if IsValid(wep) and wep.IsTFAWeapon and (wep.IsKnife or wep.IsMelee or wep.Primary.Reach) then
				dmg:ScaleDamage(cv_melee_berserkscale:GetFloat())
			end
		end
	end)

	hook.Add("EntityTakeDamage", "TFA_MeleePaP", function(target, dmg)
		if not TFA.NZombies.Patch then return end
		local ent = dmg:GetInflictor()

		if IsValid(ent) then
			local wep

			if ent:IsPlayer() then
				wep = ent:GetActiveWeapon()
			elseif ent:IsWeapon() then
				wep = ent
			end

			if IsValid(wep) and wep.IsTFAWeapon and (wep.Primary.Attacks or wep.IsMelee or wep.Primary.Reach) and wep:GetPaP() then
				dmg:ScaleDamage(2)
			end
		end
	end)
end

local function NZPatch()
	if not TFA.NZombies.Patch then return end
	nzombies = string.lower(engine.ActiveGamemode() or "") == "nzombies"

	if nZombies or NZombies or NZ or NZombies then
		nzombies = true
	end

	if nzombies then
		--SpreadFix()
		MeleeFix()
	end
end

hook.Add("InitPostEntity", "TFA_NZPatch", NZPatch)
NZPatch()
--PATH lua/tfa/modules/cl_tfa_attachment_icon.lua:
local padding = TFA.Attachments.UIPadding
local PANEL = {}
PANEL.Wep = nil
PANEL.ID = nil
PANEL.Att = nil --Weapon attachment
PANEL.Attachment = nil --Actual TFA attachment table

function PANEL:Init()
	self.Wep = nil --Weapon Entity
	self.ID = nil --Attachment ID
	self.Att = nil --Attachment Category
	self.Attachment = nil --TFA Attachment Name
	self:SetMouseInputEnabled(true)
	self:SetZPos(500)
end

function PANEL:SetWeapon(wep)
	if IsValid(wep) then
		self.Wep = wep
	end
end

function PANEL:SetGunAttachment(att)
	if att ~= nil then
		self.Att = att
	end
end

function PANEL:SetAttachment(att)
	self.Attachment = att
end

function PANEL:SetID(id)
	if id ~= nil then
		self.ID = id
	end
end

function PANEL:GetSelected()
	if not IsValid(self.Wep) then return false end
	if not self.Att then return end
	if not self.ID then return end
	if not self.Wep.Attachments[self.Att] then return end

	return self.Wep.Attachments[self.Att].sel == self.ID
end

function PANEL:AttachSound(attached)
	if self.Attachment and TFA.Attachments.Atts[self.Attachment] then
		local att = TFA.Attachments.Atts[self.Attachment]

		local snd = attached and att.AttachSound or att.DetachSound

		if snd and IsValid(self.Wep) then
			self.Wep:EmitSound(snd)

			return
		end
	end

	chat.PlaySound()
end

function PANEL:OnMousePressed()
	if not IsValid(self.Wep) or not self.Attachment or self.Attachment == "" then return end

	if self:GetSelected() and self.Wep:CanAttach(self.Attachment, true) then
		self.Wep:SetTFAAttachment(self.Att, -1, true)
		self:AttachSound(false)
	elseif self.Wep.Attachments[self.Att] and self.Wep:CanAttach(self.Attachment) then
		self.Wep:SetTFAAttachment(self.Att, self.ID, true)
		self:AttachSound(true)
	end
end

local function abbrev(str)
	local tbl = string.Explode(" ",str,false)
	local retstr = ""
	for k,v in ipairs(tbl) do
		local tmpstr = utf8.sub(v,1,1)
		retstr = retstr .. ((k == 1) and string.upper(tmpstr) or string.lower(tmpstr))
	end
	return retstr
end

function PANEL:Paint(w, h)
	if not IsValid(self.Wep) then return end
	if self.Attachment == nil then return end
	if not TFA.Attachments.Atts[self.Attachment] then self:SetMouseInputEnabled(false) return end
	local sel = self:GetSelected()
	local col = sel and TFA.Attachments.Colors["active"] or TFA.Attachments.Colors["background"]

	if not sel and not self.Wep:CanAttach(self.Attachment) then
		col = TFA.Attachments.Colors["error"]
	elseif sel and not self.Wep:CanAttach(self.Attachment, true) then
		col = TFA.Attachments.Colors["error_attached"]
	end

	draw.RoundedBox(0, 0, 0, w, h, ColorAlpha(col, self.Wep:GetInspectingProgress() * 225))

	if not TFA.Attachments.Atts[self.Attachment].Icon then
		TFA.Attachments.Atts[self.Attachment].Icon = "entities/tfa_qmark.png"
	end

	if not TFA.Attachments.Atts[self.Attachment].Icon_Cached then
		TFA.Attachments.Atts[self.Attachment].Icon_Cached = Material(TFA.Attachments.Atts[self.Attachment].Icon, "noclamp smooth")
	end

	local attachmentIcon = TFA.Attachments.Atts[self.Attachment].Icon_Cached

	local iconOverride = self.Wep:GetStat("AttachmentIconOverride." .. self.Attachment)
	if iconOverride and type(iconOverride) == "IMaterial" then
		attachmentIcon = iconOverride
	end

	surface.SetDrawColor(ColorAlpha(color_white, self.Wep:GetInspectingProgress() * 255))
	surface.SetMaterial(attachmentIcon)
	surface.DrawTexturedRect(padding, padding, w - padding * 2, h - padding * 2)
	if not TFA.Attachments.Atts[self.Attachment].ShortName then
		TFA.Attachments.Atts[self.Attachment].ShortName = abbrev(language.GetPhrase(TFA.Attachments.Atts[self.Attachment].Name) or "")
		TFA.Attachments.Atts[self.Attachment].ShortNameGenerated = true
	end
	draw.SimpleText(string.upper(TFA.Attachments.Atts[self.Attachment].ShortName) , "TFAAttachmentIconFontTiny", padding / 4, h, ColorAlpha(TFA.Attachments.Colors["primary"], self.Wep:GetInspectingProgress() * (sel and 192 or 64)), TEXT_ALIGN_LEFT, TEXT_ALIGN_BOTTOM)
end

vgui.Register("TFAAttachmentIcon", PANEL, "Panel")

-- cleanup generated shortnames
cvars.AddChangeCallback("gmod_language", function()
	for id, att in pairs(TFA.Attachments.Atts or {}) do
		if att.ShortNameGenerated then
			att.ShortName = nil
			att.ShortNameGenerated = nil
		end
	end
end, "tfa_attachment_clearshortnames")
--PATH lua/tfa/modules/cl_tfa_devtools.lua:
return gluapack()()
--PATH tfa_dev_tools:
		local rshift = bit.rshift
		local band = bit.band
		return function(state)
			return band(rshift(state, 0), 1) == 0 and 0 or 1		end
	
--PATH tfa_dev_tools:
		local rshift = bit.rshift
		local band = bit.band
		return function(state)
			return band(rshift(state, 0), 1) == 0 and 0 or 1, band(rshift(state, 1), 1) == 0 and 0 or 1, band(rshift(state, 2), 1) == 0 and 0 or 1, band(rshift(state, 3), 1) == 0 and 0 or 1, band(rshift(state, 4), 1) == 0 and 0 or 1, band(rshift(state, 5), 1) == 0 and 0 or 1, band(rshift(state, 6), 1) == 0 and 0 or 1, band(rshift(state, 7), 1) == 0 and 0 or 1, band(rshift(state, 8), 1) == 0 and 0 or 1		end
	
--PATH tfa_dev_tools:
		local rshift = bit.rshift
		local band = bit.band
		return function(state)
			return band(rshift(state, 0), 1) == 0 and 0 or 1, band(rshift(state, 1), 1) == 0 and 0 or 1, band(rshift(state, 2), 1) == 0 and 0 or 1, band(rshift(state, 3), 1) == 0 and 0 or 1, band(rshift(state, 4), 1) == 0 and 0 or 1, band(rshift(state, 5), 1) == 0 and 0 or 1, band(rshift(state, 6), 1) == 0 and 0 or 1, band(rshift(state, 7), 1) == 0 and 0 or 1, band(rshift(state, 8), 1) == 0 and 0 or 1, band(rshift(state, 9), 1) == 0 and 0 or 1, band(rshift(state, 10), 1) == 0 and 0 or 1, band(rshift(state, 11), 1) == 0 and 0 or 1, band(rshift(state, 12), 1) == 0 and 0 or 1, band(rshift(state, 13), 1) == 0 and 0 or 1, band(rshift(state, 14), 1) == 0 and 0 or 1, band(rshift(state, 15), 1) == 0 and 0 or 1, band(rshift(state, 16), 1) == 0 and 0 or 1, band(rshift(state, 17), 1) == 0 and 0 or 1, band(rshift(state, 18), 1) == 0 and 0 or 1, band(rshift(state, 19), 1) == 0 and 0 or 1, band(rshift(state, 20), 1) == 0 and 0 or 1, band(rshift(state, 21), 1) == 0 and 0 or 1		end
	
--PATH tfa_dev_tools:
		local rshift = bit.rshift
		local band = bit.band
		return function(state)
			return band(rshift(state, 0), 1) == 0 and 0 or 1, band(rshift(state, 1), 1) == 0 and 0 or 1, band(rshift(state, 2), 1) == 0 and 0 or 1, band(rshift(state, 3), 1) == 0 and 0 or 1, band(rshift(state, 4), 1) == 0 and 0 or 1, band(rshift(state, 5), 1) == 0 and 0 or 1, band(rshift(state, 6), 1) == 0 and 0 or 1, band(rshift(state, 7), 1) == 0 and 0 or 1, band(rshift(state, 8), 1) == 0 and 0 or 1, band(rshift(state, 9), 1) == 0 and 0 or 1, band(rshift(state, 10), 1) == 0 and 0 or 1, band(rshift(state, 11), 1) == 0 and 0 or 1, band(rshift(state, 12), 1) == 0 and 0 or 1, band(rshift(state, 13), 1) == 0 and 0 or 1, band(rshift(state, 14), 1) == 0 and 0 or 1, band(rshift(state, 15), 1) == 0 and 0 or 1, band(rshift(state, 16), 1) == 0 and 0 or 1, band(rshift(state, 17), 1) == 0 and 0 or 1, band(rshift(state, 18), 1) == 0 and 0 or 1, band(rshift(state, 19), 1) == 0 and 0 or 1, band(rshift(state, 20), 1) == 0 and 0 or 1, band(rshift(state, 21), 1) == 0 and 0 or 1, band(rshift(state, 22), 1) == 0 and 0 or 1		end
	
--PATH lua/tfa/modules/cl_tfa_particles_lua.lua:
return gluapack()()
--PATH lua/tfa/modules/cl_tfa_rtbgblur.lua:
local FT = FrameTime

local tfablurintensity = 0

local cv_3dscopes = GetConVar("cl_tfa_3dscope")

local cv_mode = CreateClientConVar("cl_tfa_fx_rtscopeblur_mode", "1", true, false)
local funcs = {}

local cv_blur_passes = CreateClientConVar("cl_tfa_fx_rtscopeblur_passes", "3", true, false)
local cv_blur_intensity = CreateClientConVar("cl_tfa_fx_rtscopeblur_intensity", "4", true, false)
local blurTex = Material("pp/blurscreen")
funcs[1] = function()
	surface.SetDrawColor(color_white)
	render.SetMaterial(blurTex)
	local passes = cv_blur_passes:GetInt()

	for _ = 1, passes do
		render.UpdateScreenEffectTexture()

		blurTex:SetFloat("$blur", tfablurintensity * cv_blur_intensity:GetFloat() / math.sqrt(passes) )
		blurTex:Recompute()

		render.DrawScreenQuad()
	end
end

local blur_mat = Material("pp/bokehblur")
funcs[2] = function()
	render.UpdateScreenEffectTexture()
	render.UpdateFullScreenDepthTexture()

	blur_mat:SetTexture("$BASETEXTURE", render.GetScreenEffectTexture())
	blur_mat:SetTexture("$DEPTHTEXTURE", render.GetResolvedFullFrameDepth())

	blur_mat:SetFloat("$size", tfablurintensity * cv_blur_intensity:GetFloat() * 1.5 )
	blur_mat:SetFloat("$focus", 0)
	blur_mat:SetFloat("$focusradius", 0.25)

	render.SetMaterial(blur_mat)
	render.DrawScreenQuad()
end

hook.Add("PostDrawTranslucentRenderables", "tfa_draw_rt_blur", function()
	if TFA.DrawingRenderTarget then return end

	if not cv_3dscopes:GetBool() then return end

	local mode = cv_mode:GetInt()
	if not isfunction(funcs[mode]) then return end

	local ply = LocalPlayer()
	if not IsValid(ply) or ply:ShouldDrawLocalPlayer() then return end

	local wep = ply:GetActiveWeapon()
	if not IsValid(wep) or not wep.IsTFAWeapon or not wep.GetStat then return end
	if not wep:GetStatL("RTBGBlur") then return end
	if not wep:GetStatL("RTDrawEnabled") and not wep:GetStatL("RTMaterialOverride") and not wep.RTCode then return end

	if wep.GLDeployed and wep:GLDeployed() then
		tfablurintensity = Lerp(FT() * 12.5, tfablurintensity, 0)
	else
		local progress = math.Clamp(wep.CLIronSightsProgress or 0, 0, 1)
		tfablurintensity = Lerp(FT() * 25, tfablurintensity, progress)
	end

	if tfablurintensity > 0.05 then
		funcs[mode]()
	end
end)

hook.Add("NeedsDepthPass", "aaaaaaaaaaaaaaaaaaNeedsDepthPass_TJA_IronSight", function()
	if tfablurintensity > 0.05 and cv_mode:GetInt() == 2 then
		if not cv_3dscopes:GetBool() then return end

		DOFModeHack(true)

		return true
	end
end)
--PATH lua/tfa/modules/cl_tfa_subcategories.lua:
return gluapack()()
--PATH lua/tfa/attbatch/0_base_attachments.lua:
if not TFA_ATTACHMENT_ISUPDATING then TFAUpdateAttachments(false) return end

TFA.Attachments.RegisterFromTable("am_gib", {
	Name = "G.I.B Ammunition",
	ShortName = "GIB",
	Description = {
		TFA.Attachments.Colors["+"], "Always gibs enemies",
		TFA.Attachments.Colors["+"], "10% more damage",
		TFA.Attachments.Colors["-"], "20% more recoil",
		TFA.Attachments.Colors["-"], "10% more spread"
	},
	Icon = "entities/tfa_ammo_gib.png",
	TFADataVersion = TFA.LatestDataVersion,

	WeaponTable = {
		Primary = {
			DamageType = function(wep,stat) return bit.bor( stat or DMG_BULLET, DMG_ALWAYSGIB ) end,
			Damage = function( wep, stat ) return stat * 1.1 end,
			Spread = function( wep, stat ) return stat * 1.1 end,
			IronAccuracy = function( wep, stat ) return stat * 1.1 end,
			KickUp = function( wep, stat ) return stat * 1.2 end,
			KickDown = function( wep, stat ) return stat * 1.2 end
		}
	}
})
TFA.Attachments.RegisterFromTable("am_magnum", {
	Name = "Magnum Ammunition",
	ShortName = "MAG",
	Description = {
		TFA.Attachments.Colors["+"], "10% more damage",
		TFA.Attachments.Colors["-"], "15% more recoil",
		TFA.Attachments.Colors["-"], "10% more spread"
	},
	Icon = "entities/tfa_ammo_magnum.png",
	TFADataVersion = TFA.LatestDataVersion,

	WeaponTable = {
		Primary = {
			Damage = function( wep, stat ) return stat * 1.1 end,
			Spread = function( wep, stat ) return stat * 1.1 end,
			IronAccuracy = function( wep, stat ) return stat * 1.1 end,
			KickUp = function( wep, stat ) return stat * 1.15 end,
			KickDown = function( wep, stat ) return stat * 1.15 end
		}
	}
})
TFA.Attachments.RegisterFromTable("am_match", {
	Name = "Match Ammunition",
	ShortName = "Match",
	Description = {
		TFA.Attachments.Colors["+"], "20% lower spread kick",
		"10% lower recoil",
		TFA.Attachments.Colors["-"], "20% lower spread recovery"
	},
	Icon = "entities/tfa_ammo_match.png",
	TFADataVersion = TFA.LatestDataVersion,

	WeaponTable = {
		Primary = {
			SpreadIncrement = function( wep, stat ) return stat * 0.9 end,
			SpreadRecovery = function( wep, stat ) return stat * 0.8 end,
			KickUp = function( wep, stat ) return stat * 0.9 end,
			KickDown = function( wep, stat ) return stat * 0.9 end
		}
	}
})

TFA.Attachments.RegisterFromTable("sg_frag", {
	Name = "Frag Ammunition",
	ShortName = "Frag",
	Description = {
		TFA.Attachments.Colors["+"], "Explosive Damage",
		"2x damage",
		TFA.Attachments.Colors["-"], "0.5x pellets"
	},
	Icon = "entities/tfa_ammo_fragshell.png",
	TFADataVersion = TFA.LatestDataVersion,

	WeaponTable = {
		["Primary"] = {
			["DamageType"] = function(wep,stat) return bit.bor( stat or 0, DMG_BLAST ) end,
			["Damage"] = function(wep,stat) return stat * 2 end,
			["NumShots"] = function(wep,stat) return stat / 2 end
		}
	}
})
TFA.Attachments.RegisterFromTable("sg_slug", {
	Name = "Slug Ammunition",
	ShortName = "Slug",
	Description = {
		TFA.Attachments.Colors["+"], "Much lower spread",
		TFA.Attachments.Colors["+"], "100m higher range",
		TFA.Attachments.Colors["-"], "30% less damage",
		"One pellet"
	},
	Icon = "entities/tfa_ammo_slug.png",
	TFADataVersion = TFA.LatestDataVersion,

	WeaponTable = {
		Primary = {
			Damage = function( wep, stat ) return wep.Primary_TFA.NumShots * stat * 0.7 end,
			NumShots = function( wep, stat ) return 1, true end,
			Spread = function( wep, stat ) return math.max( stat - 0.015, stat * 0.5 ) end,
			IronAccuracy = function( wep, stat ) return math.max( stat - 0.03, stat * 0.25 ) end,
			Range = function( wep, stat ) return stat + 100 * 39.370 end
		}
	}
})



TFA.Attachments.RegisterFromTable("br_supp", {
	Name = "Suppressor",
	Description = {
		TFA.Attachments.Colors["+"], "Less firing noise",
		TFA.Attachments.Colors["-"], "10% less spread",
		TFA.Attachments.Colors["-"], "5% less damage",
		TFA.Attachments.Colors["-"], "10% less vertical recoil"
	},
	Icon = "entities/tfa_br_supp.png",
	ShortName = "SUPP",
	TFADataVersion = TFA.LatestDataVersion,

	WeaponTable = {
		["ViewModelElements"] = {
			["suppressor"] = {
				["active"] = true
			}
		},
		["WorldModelElements"] = {
			["suppressor"] = {
				["active"] = true
			}
		},
		["Primary"] = {
			["Damage"] = function(wep,stat) return stat * 0.95 end,
			["KickUp"] = function(wep,stat) return stat * 0.9 end,
			["KickDown"] = function(wep,stat) return stat * 0.9 end,
			["Spread"] = function(wep,stat) return stat * 0.9 end,
			["IronAccuracy"] = function(wep,stat) return stat * 0.9 end,
			["Sound"] = function(wep,stat) return wep.Primary.SilencedSound or stat end
		},
		["MuzzleFlashEffect"] = "tfa_muzzleflash_silenced",
		["MuzzleAttachmentMod"] = function(wep,stat) return wep.MuzzleAttachmentSilenced or stat end
	}
})

TFA.Attachments.RegisterFromTable("si_acog", {
	Base = "si_rt_base",
	Name = "ACOG",
	Description = {
		TFA.Attachments.Colors["="], "4x zoom",
		TFA.Attachments.Colors["-"], "20% higher zoom time",
		TFA.Attachments.Colors["-"], "10% slower aimed walking"
	},
	Icon = "entities/tfa_si_acog.png",
	ShortName = "ACOG",
	TFADataVersion = TFA.LatestDataVersion,

	WeaponTable = {
		["ViewModelElements"] = {
			["acog"] = {
				["active"] = true
			},
			["rtcircle_acog"] = {
				["active"] = true
			}
		},
		["WorldModelElements"] = {
			["acog"] = {
				["active"] = true
			}
		},
		["IronSightsPosition"] = function( wep, val ) return wep.IronSightsPos_ACOG or val, true end,
		["IronSightsAngle"] = function( wep, val ) return wep.IronSightsAng_ACOG or val, true end,
		["IronSightsSensitivity"] = function(wep,val) return TFA.CalculateSensitivtyScale( 90 / 4 / 2, wep:GetStatL("Secondary.OwnerFOV"), wep.ACOGScreenScale ) end ,
		["Secondary"] = {
			["OwnerFOV"] = function( wep, val ) return val * 0.7 end
		},
		["IronSightTime"] = function( wep, val ) return val * 1.20 end,
		["IronSightMoveSpeed"] = function(stat) return stat * 0.9 end,
		["RTOpaque"] = true,
		["RTMaterialOverride"] = -1,

		["RTScopeFOV"] = 90 / 4 / 2, -- Default FOV / Scope Zoom / screenscale

		["RTReticleMaterial"] = Material("scope/gdcw_acog"),
		["RTReticleScale"] = 1,
	}
})
TFA.Attachments.RegisterFromTable("si_aimpoint", {
	Name = "Aimpoint",
	Description = {
		TFA.Attachments.Colors["="], "10% higher zoom",
		TFA.Attachments.Colors["-"], "10% higher zoom time"
	},
	Icon = "entities/tfa_si_aimpoint.png",
	ShortName = "AIM",
	TFADataVersion = TFA.LatestDataVersion,

	WeaponTable = {
		["ViewModelElements"] = {
			["aimpoint"] = {
				["active"] = true
			},
			["aimpoint_spr"] = {
				["active"] = true
			}
		},
		["WorldModelElements"] = {
			["aimpoint"] = {
				["active"] = true
			},
			["aimpoint_spr"] = {
				["active"] = true
			}
		},
		["IronSightsPosition"] = function( wep, val ) return wep.IronSightsPos_AimPoint or val, true end,
		["IronSightsAngle"] = function( wep, val ) return wep.IronSightsAng_AimPoint or val, true end,
		["Secondary"] = {
			["OwnerFOV"] = function( wep, val ) return val * 0.9 end
		},
		["IronSightTime"] = function( wep, val ) return val * 1.10 end
	}
})
TFA.Attachments.RegisterFromTable("si_eotech", {
	Name = "EOTech",
	Description = {
		TFA.Attachments.Colors["="], "10% higher zoom",
		TFA.Attachments.Colors["-"], "10% higher zoom time"
	},
	Icon = "entities/tfa_si_eotech.png",
	ShortName = "EOTEK",
	TFADataVersion = TFA.LatestDataVersion,

	WeaponTable = {
		["ViewModelElements"] = {
			["eotech"] = {
				["active"] = true
			}
		},
		["WorldModelElements"] = {
			["eotech"] = {
				["active"] = true
			}
		},
		["IronSightsPosition"] = function( wep, val ) return wep.IronSightsPos_EOTech or val, true end,
		["IronSightsAngle"] = function( wep, val ) return wep.IronSightsAng_EOTech or val, true end,
		["Secondary"] = {
			["OwnerFOV"] = function( wep, val ) return val * 0.9 end
		},
		["IronSightTime"] = function( wep, val ) return val * 1.10 end
	}
})

--PATH addons/[misc] trzecia_osoba/lua/autorun/thirdperson.lua:
return gluapack()()
--PATH lua/autorun/venator_lfs_fix.lua:
return gluapack()()
--PATH lua/autorun/vj_controls.lua:
return gluapack()()
--PATH lua/autorun/vj_files.lua:
/*--------------------------------------------------
	=============== Files ===============
	*** Copyright (c) 2012-2023 by DrVrej, All rights reserved. ***
	No parts of this code or any of its contents may be reproduced, copied, modified or adapted,
	without the prior written consent of the author, unless otherwise indicated for stand-alone materials.
--------------------------------------------------*/
if (!file.Exists("autorun/vj_base_autorun.lua","LUA")) then return end
include('autorun/vj_controls.lua')

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------ Decals ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
game.AddDecal("VJ_AcidSlime1",{"vj_base/decals/vj_acidslime1","vj_base/decals/vj_acidslime2","vj_base/decals/vj_acidslime3","vj_base/decals/vj_acidslime4"})
game.AddDecal("VJ_Blood_Red",{"vj_base/decals/blood/vj_redblood1","vj_base/decals/blood/vj_redblood2","vj_base/decals/blood/vj_redblood3","vj_base/decals/blood/vj_redblood4","vj_base/decals/blood/vj_redblood5","vj_base/decals/blood/vj_redblood6"})
game.AddDecal("VJ_Blood_Yellow",{"vj_base/decals/blood/vj_yellowblood1","vj_base/decals/blood/vj_yellowblood2","vj_base/decals/blood/vj_yellowblood3","vj_base/decals/blood/vj_yellowblood4","vj_base/decals/blood/vj_yellowblood5","vj_base/decals/blood/vj_yellowblood6"})
game.AddDecal("VJ_Blood_Green",{"vj_base/decals/blood/vj_greenblood1","vj_base/decals/blood/vj_greenblood2","vj_base/decals/blood/vj_greenblood3","vj_base/decals/blood/vj_greenblood4","vj_base/decals/blood/vj_greenblood5","vj_base/decals/blood/vj_greenblood6"})
game.AddDecal("VJ_Blood_Orange",{"vj_base/decals/blood/vj_orangeblood1","vj_base/decals/blood/vj_orangeblood2","vj_base/decals/blood/vj_orangeblood3","vj_base/decals/blood/vj_orangeblood4","vj_base/decals/blood/vj_orangeblood5","vj_base/decals/blood/vj_orangeblood6"})
game.AddDecal("VJ_Blood_Blue",{"vj_base/decals/blood/vj_blueblood1","vj_base/decals/blood/vj_blueblood2","vj_base/decals/blood/vj_blueblood3","vj_base/decals/blood/vj_blueblood4","vj_base/decals/blood/vj_blueblood5","vj_base/decals/blood/vj_blueblood6"})
game.AddDecal("VJ_Blood_Purple",{"vj_base/decals/blood/vj_purpleblood1","vj_base/decals/blood/vj_purpleblood2","vj_base/decals/blood/vj_purpleblood3","vj_base/decals/blood/vj_purpleblood4","vj_base/decals/blood/vj_purpleblood5","vj_base/decals/blood/vj_purpleblood6"})
game.AddDecal("VJ_Blood_White",{"vj_base/decals/blood/vj_whiteblood1","vj_base/decals/blood/vj_whiteblood2","vj_base/decals/blood/vj_whiteblood3","vj_base/decals/blood/vj_whiteblood4","vj_base/decals/blood/vj_whiteblood5","vj_base/decals/blood/vj_whiteblood6"})
game.AddDecal("VJ_Blood_Oil",{"vj_base/decals/blood/vj_oilblood1","vj_base/decals/blood/vj_oilblood2","vj_base/decals/blood/vj_oilblood3","vj_base/decals/blood/vj_oilblood4","vj_base/decals/blood/vj_oilblood5","vj_base/decals/blood/vj_oilblood6"})

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------ Model Precaching ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	-- Alien Gibs --
util.PrecacheModel("models/gibs/xenians/mgib_01.mdl")
util.PrecacheModel("models/gibs/xenians/mgib_02.mdl")
util.PrecacheModel("models/gibs/xenians/mgib_03.mdl")
util.PrecacheModel("models/gibs/xenians/mgib_04.mdl")
util.PrecacheModel("models/gibs/xenians/mgib_05.mdl")
util.PrecacheModel("models/gibs/xenians/mgib_06.mdl")
util.PrecacheModel("models/gibs/xenians/sgib_01.mdl")
util.PrecacheModel("models/gibs/xenians/sgib_02.mdl")
util.PrecacheModel("models/gibs/xenians/sgib_03.mdl")
	-- Human Gibs --
util.PrecacheModel("models/gibs/humans/brain_gib.mdl")
util.PrecacheModel("models/gibs/humans/eye_gib.mdl")
util.PrecacheModel("models/gibs/humans/heart_gib.mdl")
util.PrecacheModel("models/gibs/humans/liver_gib.mdl")
util.PrecacheModel("models/gibs/humans/lung_gib.mdl")
util.PrecacheModel("models/gibs/humans/mgib_01.mdl")
util.PrecacheModel("models/gibs/humans/mgib_02.mdl")
util.PrecacheModel("models/gibs/humans/mgib_03.mdl")
util.PrecacheModel("models/gibs/humans/mgib_04.mdl")
util.PrecacheModel("models/gibs/humans/mgib_05.mdl")
util.PrecacheModel("models/gibs/humans/mgib_06.mdl")
util.PrecacheModel("models/gibs/humans/mgib_07.mdl")
util.PrecacheModel("models/gibs/humans/sgib_01.mdl")
util.PrecacheModel("models/gibs/humans/sgib_02.mdl")
util.PrecacheModel("models/gibs/humans/sgib_03.mdl")
	-- Projectiles --
util.PrecacheModel("models/spitball_large.mdl")
util.PrecacheModel("models/spitball_medium.mdl")
util.PrecacheModel("models/spitball_small.mdl")

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------ Fonts ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
if CLIENT then
	surface.CreateFont( "VJFont_Trebuchet24_Large",{
		font = "Trebuchet24",
		size = 34, -- Size
		weight = 600, -- Boldness
		blursize = 0, -- Blurness, should be 1 or 0
		antialias = true, -- Is it smooth?
		italic = false, -- Is it Italic?
	})

	surface.CreateFont( "VJFont_Trebuchet24_MediumLarge",{
		font = "Trebuchet24",
		size = 26, -- Size
		weight = 600, -- Boldness
		blursize = 0, -- Blurness, should be 1 or 0
		antialias = true, -- Is it smooth?
		italic = false, -- Is it Italic?
	})

	surface.CreateFont( "VJFont_Trebuchet24_Medium",{
		font = "Trebuchet24",
		size = 24, -- Size
		weight = 600, -- Boldness
		blursize = 0, -- Blurness, should be 1 or 0
		antialias = true, -- Is it smooth?
		italic = false, -- Is it Italic?
	})

	surface.CreateFont( "VJFont_Trebuchet24_SmallMedium",{
		font = "Trebuchet24",
		size = 17, -- Size
		weight = 600, -- Boldness
		blursize = 0, -- Blurness, should be 1 or 0
		antialias = true, -- Is it smooth?
		italic = false, -- Is it Italic?
	})

	surface.CreateFont( "VJFont_Trebuchet24_Small",{
		font = "Trebuchet24",
		size = 16, -- Size
		weight = 600, -- Boldness
		blursize = 0, -- Blurness, should be 1 or 0
		antialias = true, -- Is it smooth?
		italic = false, -- Is it Italic?
	})

	surface.CreateFont( "VJFont_Trebuchet24_Tiny",{
		font = "Trebuchet24",
		size = 11, -- Size
		weight = 600, -- Boldness
		blursize = 0, -- Blurness, should be 1 or 0
		antialias = true, -- Is it smooth?
		italic = false, -- Is it Italic?
	})

	surface.CreateFont( "VJFont_Trebuchet24_TinyItalic",{
		font = "Trebuchet24",
		size = 11, -- Size
		weight = 600, -- Boldness
		blursize = 0, -- Blurness, should be 1 or 0
		antialias = true, -- Is it smooth?
		italic = true, -- Is it Italic?
	})
end
--PATH lua/autorun/vj_menu_properties.lua:
return gluapack()()
--PATH lua/autorun/vj_menu_spawninfo.lua:
/*--------------------------------------------------
	=============== Spawn Menu Information ===============
	*** Copyright (c) 2012-2023 by DrVrej, All rights reserved. ***
	No parts of this code or any of its contents may be reproduced, copied, modified or adapted,
	without the prior written consent of the author, unless otherwise indicated for stand-alone materials.
--------------------------------------------------*/
if (!file.Exists("autorun/vj_base_autorun.lua","LUA")) then return end
include('autorun/vj_controls.lua')

local vCat = "VJ Base"
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------ Category Information ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	-- ====== Category Information (Many are for popular categories used in both official and unofficial addons ====== --
	-- Steam\appcache\librarycache
VJ.AddCategoryInfo("Alien Swarm", {Icon = "vj_base/icons/alienswarm.png"})
VJ.AddCategoryInfo("Black Mesa", {Icon = "vj_base/icons/blackmesa.png"})
VJ.AddCategoryInfo("Cry Of Fear", {Icon = "vj_base/icons/cryoffear.png"})
VJ.AddCategoryInfo("Dark Messiah", {Icon = "vj_base/icons/darkmessiah.png"})
VJ.AddCategoryInfo("E.Y.E Divine Cybermancy", {Icon = "vj_base/icons/eyedc.png"})
VJ.AddCategoryInfo("Fallout", {Icon = "vj_base/icons/fallout.png"})
VJ.AddCategoryInfo("Killing Floor 1", {Icon = "vj_base/icons/kf1.png"})
VJ.AddCategoryInfo("Left 4 Dead", {Icon = "vj_base/icons/l4d.png"})
VJ.AddCategoryInfo("Mass Effect 3", {Icon = "vj_base/icons/masseffect3.png"})
VJ.AddCategoryInfo("Military", {Icon = "vj_base/icons/mil1.png"})
VJ.AddCategoryInfo("No More Room In Hell", {Icon = "vj_base/icons/nmrih.png"})
VJ.AddCategoryInfo("Star Wars", {Icon = "vj_base/icons/starwars.png"})
VJ.AddCategoryInfo("Zombies", {Icon = "vj_base/icons/zombies.png"})
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------ NPCs ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
VJ.AddNPC("VJ Test NPC", "sent_vj_test", vCat, true)
VJ.AddNPC_HUMAN("Player NPC", "npc_vj_test_humanply", {"weapon_vj_ak47","weapon_vj_glock17","weapon_vj_m16a1","weapon_vj_mp40","weapon_vj_9mmpistol","weapon_vj_357","weapon_vj_ar2","weapon_vj_blaster","weapon_vj_smg1","weapon_vj_spas12","weapon_vj_k3","weapon_vj_crossbow","weapon_vj_ssg08"}, vCat)
VJ.AddNPC("Aerial NPC", "npc_vj_test_aerial", vCat)
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------ Entities ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
VJ.AddEntity("Admin Health Kit","sent_vj_adminhealthkit","DrVrej",true,0,true,vCat)
VJ.AddEntity("Player Spawnpoint","sent_vj_ply_spawnpoint","DrVrej",true,0,true,vCat)
VJ.AddEntity("Fireplace","sent_vj_fireplace","DrVrej",false,0,true,vCat)
VJ.AddEntity("Wooden Board","sent_vj_board","DrVrej",false,0,true,vCat)
VJ.AddEntity("Grenade","obj_vj_grenade","DrVrej",false,0,true,vCat)
VJ.AddEntity("Flare Round","obj_vj_flareround","DrVrej",false,0,true,vCat)
VJ.AddEntity("Flag","prop_vj_flag","DrVrej",false,0,true,vCat)
//VJ.AddEntity("HL2 Grenade","npc_grenade_frag","DrVrej",false,50,true,vCat)
//VJ.AddEntity("Supply Box","item_dynamic_resupply","DrVrej",false,0,true,vCat)
//VJ.AddEntity("Supply Crate","item_ammo_crate","DrVrej",false,0,true,vCat)
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------ Weapons ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	-- ====== Weapons ====== --
VJ.AddWeapon("AK-47","weapon_vj_ak47",false,vCat)
VJ.AddWeapon("Glock 17","weapon_vj_glock17",false,vCat)
VJ.AddWeapon("M16A1","weapon_vj_m16a1",false,vCat)
VJ.AddWeapon("MP 40","weapon_vj_mp40",false,vCat)
VJ.AddWeapon("9mm Pistol","weapon_vj_9mmpistol",false,vCat)
VJ.AddWeapon(".357 Magnum","weapon_vj_357",false,vCat)
VJ.AddWeapon("AR2","weapon_vj_ar2",false,vCat)
VJ.AddWeapon("Blaster","weapon_vj_blaster",false,vCat)
VJ.AddWeapon("VJ NPC Controller","weapon_vj_npccontroller",false,vCat)
VJ.AddWeapon("Flare Gun","weapon_vj_flaregun",false,vCat)
VJ.AddWeapon("SMG1","weapon_vj_smg1",false,vCat)
VJ.AddWeapon("SPAS-12","weapon_vj_spas12",false,vCat)
VJ.AddWeapon("RPG","weapon_vj_rpg",false,vCat)
	-- ====== NPC Weapons ====== --
//VJ.AddNPCWeapon("VJ_Package","weapon_citizenpackage")
//VJ.AddNPCWeapon("VJ_Suitcase","weapon_citizensuitcase")
VJ.AddNPCWeapon("VJ_AK-47","weapon_vj_ak47")
VJ.AddNPCWeapon("VJ_M4A1","weapon_vj_m16a1")
VJ.AddNPCWeapon("VJ_Glock17","weapon_vj_glock17")
VJ.AddNPCWeapon("VJ_MP40","weapon_vj_mp40")
VJ.AddNPCWeapon("VJ_Blaster","weapon_vj_blaster")
VJ.AddNPCWeapon("VJ_AR2","weapon_vj_ar2")
VJ.AddNPCWeapon("VJ_SMG1","weapon_vj_smg1")
VJ.AddNPCWeapon("VJ_9mmPistol","weapon_vj_9mmpistol")
VJ.AddNPCWeapon("VJ_SPAS-12","weapon_vj_spas12")
VJ.AddNPCWeapon("VJ_357","weapon_vj_357")
VJ.AddNPCWeapon("VJ_FlareGun","weapon_vj_flaregun")
VJ.AddNPCWeapon("VJ_RPG","weapon_vj_rpg")
VJ.AddNPCWeapon("VJ_K-3","weapon_vj_k3")
VJ.AddNPCWeapon("VJ_Crossbow","weapon_vj_crossbow")
VJ.AddNPCWeapon("VJ_SSG-08","weapon_vj_ssg08")
VJ.AddNPCWeapon("VJ_Crowbar","weapon_vj_crowbar")
--PATH addons/[fix] wiltos_animation_fix/lua/wos/anim_extension/extensions/wos_aoc.lua:
-- "addons\\wosanim_fixes\\lua\\wos\\anim_extension\\extensions\\wos_aoc.lua"
-- Retrieved by https://github.com/lewisclark/glua-steal
--[[-------------------------------------------------------------------
	wiltOS Animation Extension Register:
		Prints some feedback saying the Animation Extension successfully loaded.
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
-------------------------------------------------------------------]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
----------------------------------------]]--

wOS.AnimExtension.Mounted[ "Age of Chivalry" ] = true
MsgC( Color( 255, 255, 255 ), "[wOS] Successfully mounted animation extension: Age of Chivalry\n" )
--PATH addons/[fix] wiltos_animation_fix/lua/wos/anim_extension/vgui/wiltos_anim_viewer.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/wos/anim_extension/holdtypes/agresif.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/wos/anim_extension/holdtypes/elegant.lua:
return gluapack()()
--PATH lua/wos/anim_extension/holdtypes/form1.lua:
return gluapack()()
--PATH lua/wos/anim_extension/holdtypes/form1.lua:

local DATA = {}
DATA.Name = "form1"
DATA.HoldType = "form1_holdtype"
DATA.BaseHoldType = "melee2"
DATA.Translations = {} 
DATA.Translations[ ACT_MP_STAND_IDLE ] = "shichoo_idle"
DATA.Translations[ ACT_MP_JUMP ] = "jump_melee2"
DATA.Translations[ ACT_MP_WALK ] = "shita_walk"
DATA.Translations[ ACT_MP_RUN ] = "run_shichoo"
wOS.AnimExtension:RegisterHoldtype( DATA )

--PATH lua/wos/anim_extension/holdtypes/g_combo1.lua:
return gluapack()()
--PATH lua/wos/anim_extension/holdtypes/g_combo3.lua:
--[[-------------------------------------------------------------------
	Blade Symphony Judgement - Heavy Hold Type:
		Uses the Heavy variation of the Judgement animations from Blade Symphony to create a variety Hold Type
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
----------------------------- Copyright 2017, David "King David" Wiltos ]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
-- Copyright 2017, David "King David" Wiltos ]]--


local DATA = {}

DATA.Name = "character holdtype"
DATA.HoldType = "g_combo3"
DATA.BaseHoldType = "melee2"
DATA.Translations = {}

DATA.Translations[ ACT_MP_STAND_IDLE ]					= "customcharacter_idle"
DATA.Translations[ ACT_MP_WALK ]						= "walk_charactercustom"
DATA.Translations[ ACT_MP_RUN ]							= "run_charactercustom"
DATA.Translations[ ACT_MP_CROUCH_IDLE ]					= "couch_idle"
DATA.Translations[ ACT_MP_CROUCHWALK ]					= "cwalk_melee1"
DATA.Translations[ ACT_MP_ATTACK_STAND_PRIMARYFIRE ]	= "combo3" 
DATA.Translations[ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE ]	= "combo3" 
--DATA.Translations[ ACT_MP_RELOAD_STAND ]				= IdleActivity + 6
--DATA.Translations[ ACT_MP_RELOAD_CROUCH ]				= IdleActivity + 6
DATA.Translations[ ACT_MP_JUMP ]						= "inair"
--DATA.Translations[ ACT_MP_SWIM ]						= IdleActivity + 9
DATA.Translations[ ACT_LAND ]							= "wos_bs_shared_jump_land"

wOS.AnimExtension:RegisterHoldtype( DATA )
--PATH lua/wos/anim_extension/holdtypes/g_rollleft.lua:
return gluapack()()
--PATH lua/wos/anim_extension/holdtypes/leapattack.lua:
--[[-------------------------------------------------------------------
	Blade Symphony Judgement - Heavy Hold Type:
		Uses the Heavy variation of the Judgement animations from Blade Symphony to create a variety Hold Type
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
----------------------------- Copyright 2017, David "King David" Wiltos ]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
-- Copyright 2017, David "King David" Wiltos ]]--


local DATA = {}

DATA.Name = "character holdtype"
DATA.HoldType = "leapattack"
DATA.BaseHoldType = "melee2"
DATA.Translations = {}

DATA.Translations[ ACT_MP_STAND_IDLE ]					= "customcharacter_idle"
DATA.Translations[ ACT_MP_WALK ]						= "walk_charactercustom"
DATA.Translations[ ACT_MP_RUN ]							= "run_charactercustom"
DATA.Translations[ ACT_MP_CROUCH_IDLE ]					= "couch_idle"
DATA.Translations[ ACT_MP_CROUCHWALK ]					= "cwalk_melee1"
DATA.Translations[ ACT_MP_ATTACK_STAND_PRIMARYFIRE ]	= "leapattack" 
DATA.Translations[ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE ]	= "leapattack" 
--DATA.Translations[ ACT_MP_RELOAD_STAND ]				= IdleActivity + 6
--DATA.Translations[ ACT_MP_RELOAD_CROUCH ]				= IdleActivity + 6
DATA.Translations[ ACT_MP_JUMP ]						= "inair"
--DATA.Translations[ ACT_MP_SWIM ]						= IdleActivity + 9
DATA.Translations[ ACT_LAND ]							= "wos_bs_shared_jump_land"

wOS.AnimExtension:RegisterHoldtype( DATA )
--PATH lua/wos/anim_extension/holdtypes/rollsword.lua:
--[[-------------------------------------------------------------------
	Blade Symphony Judgement - Heavy Hold Type:
		Uses the Heavy variation of the Judgement animations from Blade Symphony to create a variety Hold Type
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
----------------------------- Copyright 2017, David "King David" Wiltos ]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
-- Copyright 2017, David "King David" Wiltos ]]--


local DATA = {}

DATA.Name = "character holdtype"
DATA.HoldType = "rollsword"
DATA.BaseHoldType = "melee2"
DATA.Translations = {}

DATA.Translations[ ACT_MP_STAND_IDLE ]					= "customcharacter_idle"
DATA.Translations[ ACT_MP_WALK ]						= "walk_charactercustom"
DATA.Translations[ ACT_MP_RUN ]							= "run_charactercustom"
DATA.Translations[ ACT_MP_CROUCH_IDLE ]					= "couch_idle"
DATA.Translations[ ACT_MP_CROUCHWALK ]					= "cwalk_melee1"
DATA.Translations[ ACT_MP_ATTACK_STAND_PRIMARYFIRE ]	= "rollsword" 
DATA.Translations[ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE ]	= "rollsword" 
--DATA.Translations[ ACT_MP_RELOAD_STAND ]				= IdleActivity + 6
--DATA.Translations[ ACT_MP_RELOAD_CROUCH ]				= IdleActivity + 6
DATA.Translations[ ACT_MP_JUMP ]						= "wos_judge_a_idle"
--DATA.Translations[ ACT_MP_SWIM ]						= IdleActivity + 9
DATA.Translations[ ACT_LAND ]							= "wos_bs_shared_jump_land"

wOS.AnimExtension:RegisterHoldtype( DATA )
--PATH lua/wos/anim_extension/holdtypes/skyrim_holdtype.lua:
return gluapack()()
--PATH lua/wos/anim_extension/holdtypes/slashdown.lua:
return gluapack()()
--PATH lua/wos/anim_extension/holdtypes/slashdown.lua:
--[[-------------------------------------------------------------------
	Blade Symphony Judgement - Heavy Hold Type:
		Uses the Heavy variation of the Judgement animations from Blade Symphony to create a variety Hold Type
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
----------------------------- Copyright 2017, David "King David" Wiltos ]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
-- Copyright 2017, David "King David" Wiltos ]]--


local DATA = {}

DATA.Name = "character holdtype"
DATA.HoldType = "slashdown"
DATA.BaseHoldType = "melee2"
DATA.Translations = {}

DATA.Translations[ ACT_MP_STAND_IDLE ]					= "customcharacter_idle"
DATA.Translations[ ACT_MP_WALK ]						= "walk_charactercustom"
DATA.Translations[ ACT_MP_RUN ]							= "run_charactercustom"
DATA.Translations[ ACT_MP_CROUCH_IDLE ]					= "couch_idle"
DATA.Translations[ ACT_MP_CROUCHWALK ]					= "cwalk_melee1"
DATA.Translations[ ACT_MP_ATTACK_STAND_PRIMARYFIRE ]	= "slashdown" 
DATA.Translations[ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE ]	= "slashdown" 
--DATA.Translations[ ACT_MP_RELOAD_STAND ]				= IdleActivity + 6
--DATA.Translations[ ACT_MP_RELOAD_CROUCH ]				= IdleActivity + 6
DATA.Translations[ ACT_MP_JUMP ]						= "inair"
--DATA.Translations[ ACT_MP_SWIM ]						= IdleActivity + 9
DATA.Translations[ ACT_LAND ]							= "wos_bs_shared_jump_land"

wOS.AnimExtension:RegisterHoldtype( DATA )
--PATH addons/[miecze] moce i hilty/lua/wos/anim_extension/holdtypes/visigoth.lua:
local DATA = {}
DATA.Name = "Visigoth"
DATA.HoldType = "wos_visigoth_corvinus"
DATA.BaseHoldType = "melee2"
DATA.Translations = {} 

DATA.Translations[ ACT_MP_RUN ] = {
	{ Sequence = "wos_ryoku_r_run", Weight = 1 },
}

DATA.Translations[ ACT_MP_WALK ] = {
	{ Sequence = "walk_knife", Weight = 1 },
}

DATA.Translations[ ACT_MP_SPRINT ] = {
	{ Sequence = "phalanx_r_run", Weight = 1 },
}

DATA.Translations[ ACT_MP_STAND_IDLE ] = {
	{ Sequence = "r_idle_2", Weight = 1 },
}

DATA.Translations[ ACT_MP_JUMP ] = {
	{ Sequence = "wos_bs_shared_jump_descend", Weight = 1 },
}

DATA.Translations[ ACT_MP_CROUCH_IDLE ] = {
	{ Sequence = "couch_idle", Weight = 1 },
}

wOS.AnimExtension:RegisterHoldtype( DATA )
--=====================================================================

--PATH lua/wos/dynabase/loader/loader.lua:
return gluapack()()
--PATH lua/wos/dynabase/core/sh_core.lua:
return gluapack()()
--PATH lua/wos/dynabase/core/sh_model_operations.lua:
return gluapack()()
--PATH lua/autorun/wounded.lua:
return gluapack()()
--PATH lua/xeninui/libs/debug.lua:
CreateClientConVar("xenin_debug_print_file_enabled", "1", true, false)
CreateClientConVar("xenin_debug_print_console_enabled", "0", true, false)

function XeninUI:HasDebugFilePrintEnabled()
  return GetConVar("xenin_debug_print_file_enabled"):GetBool() or ply:IsSuperAdmin()
end

function XeninUI:HasDebugConsolePrintEnabled()
  return GetConVar("xenin_debug_print_console_enabled"):GetBool()
end

function XeninUI:EnsureDebugFileExists()
  local ply = LocalPlayer()

  local path = self.debugPath or "xenin/debug/"
  local time = os.time()
  local date = os.date("%d_%m_%Y_%H_%M_%S", time)
  local realPath = path .. date .. ".txt"

  if (!file.IsDir(path, "DATA")) then
    file.CreateDir(path)
  end

  if (!file.Exists(realPath, "DATA")) then
    local str = "Debug log for " .. ply:Nick() .. " [" .. ply:SteamID() .. "] initialised at " .. os.date("%d/%m/%Y %H:%M:%S", time) .. "\n"
    file.Write(realPath, str)

    ply.debug = realPath
  end
end

hook.Add("InitPostEntity", "XeninUI.Debug", function()
  XeninUI:EnsureDebugFileExists()
end)

function XeninUI:DebugPrint(prefix, ...)
  local rawPrefix = prefix
  local args = {
  ... }
  local ply = LocalPlayer()
  local printEnabled = XeninUI:HasDebugConsolePrintEnabled()
  local fileEnabled = XeninUI:HasDebugFilePrintEnabled()

  if (!printEnabled and !fileEnabled) then return end
  local path = ply.debug
  if (!path) then print("ERROR AT DEBUG PRINT")end
  local time = os.time()
  local date = os.date("%H:%M:%S", time)
  prefix = "[" .. prefix:upper() .. " ENTRANCE AT " .. date .. "]"

  local str = prefix .. "\n	-	"

  for i, v in ipairs(args) do
    if istable(v) then
      local json = util.TableToJSON(v, true)
      local exploded = string.Explode("\n", json)

      for i, v in ipairs(exploded) do
        if (i == 1) then continue end

        exploded[i] = "	-	" .. v
      end

      json = table.concat(exploded, "\n")
      str = str .. "Table: " .. json .. "\n	- "

      continue
    end

    str = str .. v .. "\n	-	"
  end
  str = str:sub(1, str:len() - 3)

  if fileEnabled then
    file.Append(path, str)
  end

  if printEnabled then
    ply.debugTbl = ply.debugTbl or {}
    ply.debugTbl[rawPrefix] = ply.debugTbl[rawPrefix] or {}

    table.insert(ply.debugTbl[rawPrefix], {
      time = CurTime(),
      str = str
    })
  end
end

function XeninUI:DebugQuery(prefix, secs)
  if (!prefix) then
    print("You need a category!")

    return
  end

  secs = secs or 300

  local ply = LocalPlayer()
  if (!ply.debugTbl) then
    print("No debug info at all")

    return
  end
  if (!ply.debugTbl[prefix]) then
    print("No debug info for " .. prefix)

    return
  end

  local tbl = ply.debugTbl[prefix]
  local size = #tbl

  if (size == 0) then
    print("The category exists, but there's no info")

    return
  end

  local curTime = CurTime() - secs
  local infoTbl = {}

  for i = size, 1, -1 do
    if (tbl[i] and tbl[i].time > curTime) then
      table.insert(infoTbl, tbl[i])

      continue
    end

    break
  end

  return infoTbl
end

concommand.Add("xenin_debug_query", function(ply, cmd, args)
  local prefix = args[1]
  local secs = args[2]
  local tbl = XeninUI:DebugQuery(args[1], args[2])

  if tbl then
    local str = ""

    for i, v in ipairs(tbl) do
      str = str .. v.str .. "\n"

      if (i == #tbl) then str = str:sub(1, str:len() - 2)end
    end

    print(str)
    MsgC(XeninUI.Theme.Accent, "Results: ")
    MsgC(XeninUI.Theme.Green, #tbl .. "\n")
  end
end)

--PATH lua/xeninui/libs/network/core.lua:
return gluapack()()
--PATH lua/xeninui/libs/network/core.lua:
do
  local _class_0
  local _base_0 = {
    __name = "XeninUI.Network",
    setPrefix = function(self, prefix)
      self.prefix = prefix
      return self
    end,
    getPrefix = function(self)
      return self.prefix
    end,
    prepare = function(self, str)
      if istable(str) then
        for i, v in ipairs(str) do
          util.AddNetworkString(self:getPrefix() .. v)
        end
      else
        util.AddNetworkString(self:getPrefix() .. str)
      end
    end,
    receiver = function(self, name, func)
      if func == nil then func = function() end
      end
      net.Receive(self:getPrefix() .. name, function(len, ply)
        func(self, ply or LocalPlayer(), len)
      end)
    end,
    send = function(self, name, target, func)
      net.Start(self:getPrefix() .. name)

      if CLIENT then
        target(self)

        net.SendToServer()
      else
        func(self)

        net.Send(target)
      end
    end,
    compress = function(self, data)
      local tbl = false
      if istable(data) then
        data = util.TableToJSON(data)
        tbl = true
      end

      data = util.Compress(data)
      local len = data:len()

      net.WriteUInt(len, 32)
      net.WriteBool(tbl)
      net.WriteData(data, len)
    end,
    decompress = function(self)
      local len = net.ReadUInt(32)
      local tbl = net.ReadBool()
      local data = net.ReadData(len)
      data = util.Decompress(data)

      if tbl then
        data = util.JSONToTable(data)
      end

      return data
    end,
    getNetworkType = function(self, input)
      if isnumber(input) then
        local int, frac = math.modf(input)
        if (frac != 0) then
          return self.FLOAT
        end

        return self.INTEGER
      elseif (isbool(input) or input == nil) then
        return self.BOOL
      elseif isstring(input) then
        return self.STRING
      elseif istable(input) then
        return self.TABLE
      end
    end,
    writeType = function(self, input)
      local type = self:getNetworkType(input)
      net.WriteUInt(type, self.DYNAMIC_DATA_SIZE)

      return type
    end,
    readType = function(self, input)
      return net.ReadUInt(self.DYNAMIC_DATA_SIZE)end,
    write = function(self, input, ...)
      local type = self:writeType(input)
      self:writeFromType(type, input, ...)

      return type
    end,
    read = function(self, ...)
      local type = self:readType()
      return self:readFromType(type, ...)
    end,
    writeFromType = function(self, type, input, ...)
      self.writeTypes[type](input, ...)end,
    readFromType = function(self, type, ...)
      return self.readTypes[type](...)end,
    __type = function(self)
      return self.__name
    end
  }
  _base_0.__index = _base_0
  _class_0 = setmetatable({
    __init = function(self)
      self.TABLE = 4
      self.STRING = 3
      self.BOOL = 2
      self.INTEGER = 1
      self.FLOAT = 0
      self.DYNAMIC_DATA_SIZE = 3
      self:setPrefix("")

      self.writeTypes = {
        [self.FLOAT] = function(i)
          net.WriteFloat(i)end,
        [self.INTEGER] = function(i)
          net.WriteInt(i, 16)end,
        [self.BOOL] = function(i)
          net.WriteBool(i)end,
        [self.STRING] = function(i)
          net.WriteString(i)end,

        [self.TABLE] = function(i)
          net.WriteTable(i)end
      }
      self.readTypes = {
        [self.FLOAT] = function()
          return math.Round(net.ReadFloat(), 5)end,
        [self.INTEGER] = function()
          return net.ReadInt(16)end,
        [self.BOOL] = function()
          return net.ReadBool()end,
        [self.STRING] = function()
          return net.ReadString()end,
        [self.TABLE] = function()
          return net.ReadTable()end
      }
    end,
    __base = _base_0
  }, {
    __index = _base_0,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  XeninUI.Network = _class_0
end

--PATH lua/xeninui/libs/scripts/main.lua:
return gluapack()()
--PATH lua/xeninui/libs/configurator/classes/cache.lua:
do
  local _class_0
  local _base_0 = {
    __name = "XeninUI.Configurator.Cache",
    get = function(self, id)
      return self.cache[id]
    end,
    set = function(self, id, val)
      self.cache[id] = val
    end,
    __type = function(self)
      return self.__name
    end
  }
  _base_0.__index = _base_0
  _class_0 = setmetatable({
    __init = function(self)
      self.cache = {}
    end,
    __base = _base_0
  }, {
    __index = _base_0,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  XeninUI.Configurator.Cache = _class_0
end

--PATH lua/xeninui/libs/configurator/ui/entities/entity.lua:
return gluapack()()
--PATH lua/xeninui/libs/configurator/ui/entities/entity.lua:
local PANEL = {}

function PANEL:Init() end

function PANEL:GetEntities()
  return {
  i }
end

function PANEL:SetScript(script)
  self.script = script
  self.ctr = XeninUI.Configurator:FindControllerByScriptName(script)
end

function PANEL:OnSearch(text)
  XeninUI.Configurator.Network:sendGetEntities(self.BaseEnt, nil, nil, text)
end

function PANEL:SetData(tbl)
  assert(tbl ~= nil, "cannot destructure nil value")
  local __entity, name, script = tbl.__entity, tbl.name, tbl.script

  self:SetScript(script)
  self.Entity = __entity
  self:SetTitle(name)
  self.Navbar:SetVisible(false)
  self.BaseEnt = XeninUI.Configurator.Entities:create(self.Entity)
  XeninUI.Configurator.Network:sendGetEntities(self.BaseEnt)

  self.TopBar = self:Add("Panel")
  self.TopBar:Dock(TOP)
  self.TopBar:DockMargin(0, 16, 0, 0)

  self.Subtitle = self.TopBar:Add("DLabel")
  self.Subtitle:SetFont("Xenin.Configurator.Admin.Panel.Navbar")
  self.Subtitle:SetText("Loading")

  self.Create = self.TopBar:Add("XeninUI.ButtonV2")
  self.Create:Dock(RIGHT)
  self.Create:SetText("Create New")
  self.Create:SetFont("Xenin.Configurator.Admin.Panel.Navbar")
  self.Create:SetRoundness(6)
  self.Create:SetSolidColor(XeninUI.Theme.Primary)
  self.Create:SetHoverColor(XeninUI.Theme.Navbar)
  self.Create:SetTextColor(Color(182, 182, 182))
  self.Create.DoClick = function(pnl)
    local ent = XeninUI.Configurator.Entities:create(self.Entity)
    XeninUI.Configurator.Network:sendCreateEntity(ent)
  end
  self.Save.DoClick = function(pnl)
    for _, row in ipairs(self.Rows) do
      local ent = XeninUI.Configurator.Entities:create(self.Entity)
      local settings = IsValid(row.Settings) and row.Settings:GetSettings()
      if (!settings) then continue end

      for i, v in pairs(settings) do
        ent["set" .. tostring(i)](ent, v)
      end

      ent:save(true)
    end
  end

  hook.Add("XeninUI.Configurator.CreatedEntity", self, function(self, ent)
    local entity = ent:getDatabaseEntity()
    if (entity != self.Entity) then return end

    local id = ent.getId and ent:getId() or #self.Rows + 1
    self:CreateEntity(ent, id)
    self:UpdateTitle(#self.Rows)
  end)
  self.Scroll:DockMargin(0, 16, 0, 0)

  self.Rows = {}

  self.RowController = self.Body:Add("Panel")
  self.RowController:Dock(TOP)
  self.RowController.Think = function(pnl, w, h)
    w = pnl:GetWide()
    h = pnl:GetTall()

    local y = 0
    for i, v in ipairs(self.Rows) do
      if (!IsValid(v)) then continue end

      v:SizeToChildren(false, true)
      local height = v:GetTall() >= 48 and v:GetTall() or 48
      v:SetSize(w, height)
      v:SetPos(0, y)

      y = y + v:GetTall()
    end

    pnl:SizeToChildren(false, true)
  end

  hook.Add("XeninUI.Configurator.GetEntities", self, function(self, entities)
    if entities == nil then entities = {}
    end
    self:UpdateTitle(#entities)

    self.Rows = {}
    for i, v in ipairs(entities) do
      self:CreateEntity(v, i)
    end
  end)
end

function PANEL:UpdateTitle(size)
  size = size or #self.Rows
  if (!IsValid(self.Title)) then return end

  local name = self.Title:GetText()
  name = name:sub(1, 1):lower() .. name:sub(2, #name - 1)
  if (size != 1) then name = name .. "s"
  end

  self.Subtitle:SetText(tostring(size) .. " " .. tostring(name))
end

function PANEL:CreateEntity(entity, id)
  local columns = entity:getColumns()
  local name = entity.__name

  local panel = self.RowController:Add("Xenin.Configurator.Admin.Entity.Row")
  panel:SetEntity(entity)
  panel.OnRemove = function(pnl)
    table.remove(self.Rows, id)

    self:UpdateTitle(#self.Rows - 1)
  end

  local id = table.insert(self.Rows, panel)
  self.Rows[id].RowId = id
end

function PANEL:Paint(w, h)
  self.BaseClass.Paint(self, w, h)

  if (self.Subtitle:GetText() != "Loading") then return end

  XeninUI:DrawLoadingCircle(w / 2, h / 2, h / 4)
end

function PANEL:PerformLayout(w, h)
  self.BaseClass.PerformLayout(self, w, h)

  self.TopBar:SetTall(32)
  self.Subtitle:SizeToContents()
  self.Create:SizeToContentsX(24)
end

vgui.Register("Xenin.Configurator.Admin.Entity", PANEL, "Xenin.Configurator.Admin.Panel")

--PATH lua/xeninui/libs/configurator/ui/entities/entity_grid.lua:
return gluapack()()
--PATH lua/xeninui/libs/configurator/ui/entities/entity_grid.lua:
local PANEL = {}

function PANEL:SetScript(script)
  self.script = script
  self.ctr = XeninUI.Configurator:FindControllerByScriptName(script)
end

function PANEL:Call(id, default, ...)
  local value = self.Template[id] or default

  if isfunction(value) then
    return value(...)
  else
    return value
  end
end

function PANEL:OnSearch(text)
  text = text:lower()

  local panels = self.Layout:GetChildren()
  for i, v in ipairs(panels) do
    local result = v:Search(text)
    v:SetVisible(result)
  end

  self.Layout:InvalidateLayout()
end

function PANEL:SetData(tbl)
  assert(tbl ~= nil, "cannot destructure nil value")
  local __entity, name, script = tbl.__entity, tbl.name, tbl.script

  self:SetScript(script)
  self.Entity = __entity
  self:SetTitle(name)

  self.Navbar:SetVisible(false)
  self.Template = XeninUI.Configurator.Entities:get(self.Entity)
  self.BaseEnt = XeninUI.Configurator.Entities:create(self.Entity)

  self.TopBar = self:Add("Panel")
  self.TopBar:Dock(TOP)
  self.TopBar:DockMargin(0, 16, 0, 8)

  self.Subtitle = self.TopBar:Add("DLabel")
  self.Subtitle:SetFont("Xenin.Configurator.Admin.Panel.Navbar")
  self.Subtitle:SetText("Subtitle")

  self.Save.DoClick = function(pnl)
    for _, row in ipairs(self.Layout:GetChildren()) do
      if (row.StartedActive and !row.Active) then
        row.Entity:delete(true)
        row:DoSaveAnimation(XeninUI.Theme.Red)
        row.StartedActive = false

        continue
      end
      if (!row.Active) then continue end

      local ent = XeninUI.Configurator.Entities:create(self.Entity)
      local settings = IsValid(row.Settings) and row.Settings.Rows:GetSettings()
      if (!settings) then continue end
      for i, v in pairs(settings) do
        ent["set" .. tostring(i)](ent, v)
      end

      row.StartedActive = true
      row:DoSaveAnimation(XeninUI.Theme.Green)
      ent:save(true)
    end
  end

  self.Layout = self.Scroll:Add("DIconLayout")
  self.Layout:Dock(TOP)
  self.Layout:DockMargin(0, 0, 8, 0)
  self.Layout:SetBorder(0)
  self.Layout:SetSpaceY(8)
  self.Layout:SetSpaceX(8)
  self.Layout.Columns = self:Call("gridColumns", 5)
  self.Layout.PerformLayout = function(pnl, w, h)
    local children = pnl:GetChildren()
    local count = pnl.Columns
    local width = w / math.min(count, #children)

    local x = 0
    local y = 0

    local spacingX = pnl:GetSpaceX()
    local spacingY = pnl:GetSpaceY()
    local border = pnl:GetBorder()
    local innerWidth = w - border * 2 - spacingX * (count - 1)

    for i, child in ipairs(children) do
      if (!IsValid(child)) then continue end
      if (!child:IsVisible()) then continue end

      child:SetPos(border + x * innerWidth / count + spacingX * x, border + y * child:GetTall() + spacingY * y)
      child:SetSize(self:Call("gridColumnWidth", function()
        return innerWidth / count
      end, innerWidth, count, w, h, x, y), self:Call("gridColumnHeight", function()
        return innerWidth / count
      end, innerWidth, count, w, h, x, y))

      x = x + 1
      if (x >= count) then
        x = 0
        y = y + 1
      end
    end

    pnl:SizeToChildren(false, true)
  end

  self:CreateContent()
end

XeninUI:CreateFont("Xenin.Configurator.Grid", 12)

local matTick = Material("xenin/tick.png", "smooth")
function PANEL:CreateColumn(data, index)
  local panel = self.Layout:Add("DButton")
  panel:SetText("")
  panel.BackgroundColor = XeninUI.Theme.Background
  panel.OutlineColor = XeninUI.Theme.Navbar
  panel.TextColor = Color(174, 174, 174)
  panel.StartedActive = tobool(data.isActive)
  panel.Search = data.search or function(pnl, text)
    return pnl.Name:find(text)
  end
  panel.Entity = data.isActive or XeninUI.Configurator.Entities:create(self.Entity)
  panel.Name = panel.Entity and panel.Entity.getName and panel.Entity:getName()
  if (!panel.Name) then
    panel.Name = data.name or "Unknown name"
  end
  self:Call("gridSetDefaultData", function() end, panel.Entity, data, index)
  panel.SelectionAlpha = 0
  panel.Paint = function(...)
    self:Call("gridPaint", function(pnl, w, h)
      draw.RoundedBox(6, 0, 0, w, h, pnl.BackgroundColor)

      pnl:DrawSelected(w, h)
    end, ...)
  end
  panel.DrawSelected = function(...)
    self:Call("gridDrawSelected", function(pnl, w, h)
      local alpha = pnl.SelectionAlpha
      if (alpha <= 1) then return end

      local size = h * 0.25
      local x = w / 2 - size / 2
      local y = h / 2 - size / 2
      local col = ColorAlpha(XeninUI.Theme.Accent, alpha / 8)

      local topRight = !pnl.Settings:IsVisible()
      local bottomRight = true
      if pnl.Settings:IsVisible() then
        bottomRight = pnl.Settings:GetTall() < (h * 0.95)
      end
      XeninUI:DrawRoundedBoxEx(6, 0, 0, w, h, col, true, topRight, true, bottomRight)

      if (true) then return end
      XeninUI:MaskInverse(function()
        XeninUI:DrawCircle(w / 2, h / 2, size * 0.85, 30, col)
      end, function()
        XeninUI:DrawCircle(w / 2, h / 2, size, 30, col)
      end)

      surface.SetDrawColor(col)
      surface.SetMaterial(matTick)
      surface.DrawTexturedRect(x + 1, y + 1, size, size)
    end, ...)
  end
  panel.PaintOver = function(pnl, w, h)
    self:Call("gridPaintOver", function(pnl, w, h)
      local topRight = !pnl.Settings:IsVisible()
      local bottomRight = true
      if pnl.Settings:IsVisible() then
        bottomRight = pnl.Settings:GetTall() < (h * 0.95)
      end
      XeninUI:MaskInverse(function()
        XeninUI:DrawRoundedBoxEx(6, 1, 1, w - 2, h - 2, pnl.OutlineColor, true, topRight, true, bottomRight)
      end, function()
        XeninUI:DrawRoundedBoxEx(6, 0, 0, w, h, pnl.OutlineColor, true, topRight, true, bottomRight)
      end)

      if (!IsValid(pnl.Display)) then
        draw.SimpleText("No Image", "Xenin.Configurator.Grid", w / 2, h / 2, Color(174, 174, 174), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
      end



      XeninUI.DrawMultiLine(pnl.Name, "Xenin.Configurator.Grid", w - 16, 16, w / 2, h - 8, pnl.TextColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM)
    end, pnl, w, h)

    if (!pnl.SaveAnimation) then return end

    local size = math.max(w, h)
    XeninUI:Mask(function()
      XeninUI:DrawRoundedBox(6, 0, 0, w, h, color_white)
    end, function()
      XeninUI:DrawCircle(w / 2, h / 2, size * (pnl.SaveAnimation * 1.2), 30, ColorAlpha(pnl.SaveColor, 255 - (pnl.SaveAnimation * 255)))
    end)
  end
  panel.OnCursorEntered = function(...)
    self:Call("gridOnCursorEntered", function(pnl)
      pnl:LerpColor("TextColor", color_white)
      pnl:LerpColor("OutlineColor", ColorAlpha(XeninUI.Theme.Accent, 150))
    end, ...)
  end
  panel.OnCursorExited = function(...)
    if (panel.Settings:IsVisible()) then return end

    self:Call("gridOnCursorExited", function(pnl)
      pnl:LerpColor("TextColor", Color(174, 174, 174))
      pnl:LerpColor("OutlineColor", XeninUI.Theme.Navbar)
    end, ...)
  end
  panel.DoSaveAnimation = function(pnl, color)
    if color == nil then color = XeninUI.Theme.Green
    end
    pnl.SaveColor = color
    pnl.SaveAnimation = 0
    pnl:Lerp("SaveAnimation", 1, 0.7, function()
      pnl.SaveAnimation = nil
    end)
  end
  panel.DoClick = function(pnl)
    self:Call("gridDoClick", function(pnl)
      pnl:SetState(!pnl.Active)
    end, pnl)
  end
  panel.SetState = function(pnl, state)
    local instant = pnl.Active == nil
    pnl.Active = state

    local val = state and 255 or 0
    if instant then
      pnl.SelectionAlpha = val
    else
      pnl:Lerp("SelectionAlpha", val)
    end
  end
  panel:SetState(tobool(data.isActive))

  if (data.display and data.display != "") then
    local isModel = data.display:find(".mdl")
    local panelClass = isModel and "DModelPanel" or "Panel"
    if (isModel and data.isSpawnIcon) then
      panelClass = "SpawnIcon"
    end
    panel.Display = panel:Add(panelClass)
    panel.Display:Dock(FILL)
    panel.Display:SetMouseInputEnabled(false)
    if isModel then
      panel.Display:SetModel(data.display)
      if data.isSpawnIcon then
        panel.Display:DockMargin(8, 8, 8, 8)
      else
        panel.Display.LayoutEntity = function() end
        if IsValid(panel.Display.Entity) then
          local mn, mx = panel.Display.Entity:GetRenderBounds()
          local size = 0
          size = math.max(size, math.abs(mn.x) + math.abs(mx.x))
          size = math.max(size, math.abs(mn.y) + math.abs(mx.y))
          size = math.max(size, math.abs(mn.z) + math.abs(mx.z))
          panel.Display:SetFOV(45)
          panel.Display:SetCamPos(Vector(size, size, size))
          panel.Display:SetLookAt((mn + mx) * 0.5)
          if data.color then
            panel.Display:SetColor(data.color)
          end
        end
      end
    elseif (isstring(data.display) and data.display != "") then
      XeninUI:DownloadIcon(panel.Display, data.display)
      panel.Display.Paint = function(pnl, w, h)
        XeninUI:DrawIcon(8, 8, w - 16, h - 16, pnl)
      end
    end
  end

  panel.Cog = panel:Add("DButton")
  panel.Cog:SetText("")
  XeninUI:DownloadIcon(panel.Cog, "CEIrmnK")
  panel.Cog.Color = Color(174, 174, 174)
  panel.Cog.Paint = function(pnl, w, h)
    XeninUI:DrawIcon(4, 4, w - 8, h - 8, pnl, pnl.Color)
  end
  panel.Cog.OnCursorEntered = function(pnl)
    panel:OnCursorEntered()
    pnl:LerpColor("Color", XeninUI.Theme.Accent)
  end
  panel.Cog.OnCursorExited = function(pnl)
    panel:OnCursorExited()
    pnl:LerpColor("Color", Color(174, 174, 174))
  end
  panel.Cog.DoClick = function(pnl)
    local vis = !panel.Settings:IsVisible()
    panel.Settings:SetVisible(vis)

    if vis then
      panel.Settings.JustOpened = true
      panel.Settings:SetTall(panel.Settings.Rows:GetChildSize())
      local aX, aY = panel:LocalToScreen()
      aX = aX + panel:GetWide()
      panel.Settings:SetPos(aX, aY)
      panel.Settings:MakePopup()
    end
  end

  panel.Settings = vgui.Create("EditablePanel")
  panel.Settings:SetZPos(100)
  panel.Settings:SetDrawOnTop(true)
  panel.Settings:SetVisible(false)
  panel.Settings:SetTall(0)
  panel.Settings:SetWide(self:Call("gridSettingsWidth", 250))
  panel.Settings.Paint = function(pnl, w, h)
    XeninUI:DrawRoundedBoxEx(6, 0, 0, w, h, XeninUI.Theme.Background, false, true, false, true)

    local bottomLeft = panel:GetTall() < (h * 0.95)
    XeninUI:MaskInverse(function()
      XeninUI:DrawRoundedBoxEx(6, 1, 1, w - 2, h - 2, XeninUI.Theme.Background, false, true, bottomLeft, true)
    end, function()
      XeninUI:DrawRoundedBoxEx(6, 0, 0, w, h, panel.OutlineColor, false, true, bottomLeft, true)
    end)
  end
  panel.Settings.Think = function(pnl)

    local focus = pnl:HasHierarchicalFocus()
    if (focus) then return end
    if pnl.JustOpened then
      pnl.JustOpened = false

      return
    end

    pnl:SetVisible(false)
    if (panel:IsHovered() or panel:IsChildHovered()) then return end
    panel:OnCursorExited()
  end

  panel.Settings.Rows = panel.Settings:Add("Xenin.Configurator.Admin.Entity.Row.Settings")
  panel.Settings.Rows:DockMargin(4, 4, 4, 4)
  panel.Settings.Rows:AddSettings(panel.Entity or self.BaseEnt)
  panel.Settings.Rows.Parent = panel
  panel.Settings.Rows:Dock(FILL)
  panel.Settings.Rows.Paint = function() end
  panel.Settings.Rows.GetChildSize = function(pnl)
    local height = 0
    local size = 0
    for i, v in ipairs(pnl.Settings) do
      if (!v:IsVisible()) then continue end

      size = size + 1
      height = height + v:GetTall()
    end
    height = height - (size * 3)

    return height + 8
  end

  panel.OnRemove = function(pnl)
    if (!IsValid(panel.Settings)) then return end

    panel.Settings:Remove()
  end
  panel.PerformLayout = function(pnl, w, h)
    pnl.Cog:SetSize(24, 24)
    pnl.Cog:AlignTop(4)
    pnl.Cog:AlignRight(4)
  end


  self:Call("gridPostInit", function() end, panel)
end

function PANEL:CreateContent()
  local data = self.Template.getAllEntities()
  local content = self.Template.getGridContent()

  for i, v in ipairs(content) do
    local tbl = self:Call("getGridData", function(tbl)
      return tbl end, v)
    if (!tbl) then continue end

    self:CreateColumn(tbl, i)
  end
end

vgui.Register("Xenin.Configurator.Admin.EntityGrid", PANEL, "Xenin.Configurator.Admin.Panel")

--PATH lua/xeninui/libs/configurator/ui/entities/row_settings.lua:
local PANEL = {}

function PANEL:AddSettings(entity)
  self.Entity = entity
  self.Parent = self:GetParent()
  local columns = entity:getColumns()

  for i, v in ipairs(columns) do
    local split = string.Explode("_", v.id)
    local name = ""
    for i, v in ipairs(split) do
      local temp = v:sub(1, 1):upper() .. v:sub(2)
      name = name .. (temp .. (i == #split and "" or " "))
    end

    local funcName = v.id:sub(1, 1):upper() .. v.id:sub(2)
    local value = entity["get" .. tostring(funcName)](entity)

    local label = v.label or ""
    if (v.min or v.max) then
      if (v.min and v.max) then
        label = "Min: " .. tostring(v.min) .. ". Max: " .. tostring(v.max)
      elseif v.min then
        label = "Min: " .. tostring(v.min)
      elseif v.max then
        label = "Max: " .. tostring(v.max)
      end
    end

    local type = "Textentry"
    if (v.type == "list") then
      type = "TextentryList"
    end
    if ((v.validate or label) and type == "Textentry") then
      type = "TextentryWithLabel"
    end

    local detour = v.onChange
    v.onChange = function(row, text)
      self:OnValueChanged()
    end

    if v.isName then
      local detour = v.onChange
      if detour then
        v.onChange = function(row, text)
          local tbl = entity.transformName and entity:transformName(text) or {
          text }
          local name = tbl[1]
          local msg = tbl[2]
          local color = tbl[3]

          self.Parent.Name = name

          if (type == "TextentryWithLabel") then
            row.label:SetText(msg or "")
            row.label:SetTextColor(color or Color(127, 127, 127))
            row.label:SizeToContents()
          end

          detour(row, text)
        end
      else
        v.onChange = function(row, text)
          local tbl = entity.transformName and entity:transformName(text) or {
          text }
          local name = tbl[1]
          local msg = tbl[2]
          local color = tbl[3]

          self.Parent.Name = name

          if (type == "TextentryWithLabel") then
            row.label:SetText(msg or "")
            row.label:SetTextColor(color or Color(127, 127, 127))
            row.label:SizeToContents()
          end
        end
      end
    end

    if (!value and v.min and v.max) then
      value = v.min
    end

    local labelColor
    value = value or (isfunction(v.defaultValue) and v.defaultValue() or v.defaultValue)
    if (entity.transformName and v.isName) then
      local transform = entity:transformName(value)
      label = transform[2]
      labelColor = transform[3]
    end

    self:AddSetting(v.id, name, type, {
      value = value,
      readOnly = v.readOnly,
      onChange = v.onChange,
      number = v.type == "integer" or v.type == "float",
      min = v.min,
      max = v.max,
      hide = v.hide,
      label = label,
      labelColor = labelColor,
      placeholder = v.placeholder
    })
  end
end

function PANEL:OnValueChanged() end

vgui.Register("Xenin.Configurator.Admin.Entity.Row.Settings", PANEL, "Xenin.Configurator.Admin.SettingsBase")

--PATH lua/xeninui/libs/configurator/ui/inputs/textentry.lua:
local x

--PATH lua/xeninui/libs/config/class.lua:
local Config
do
  local _class_0
  local _base_0 = {
    __name = "Config",
    load = function(self)
      if SERVER then
        self:loadServer()
      else
        self:loadClient()
      end
    end,
    loadServer = function(self)
      hook.Add("XeninDB.Connected", "Xenin.Config", function()
        self:loadConfig()
      end)

      local db = file.Read("xenin/mysql.txt")
      MsgC(XeninUI.Theme.Red, "[Xenin Framework] ", color_white, "Using " .. (db and "MySQL" or "SQLite") .. " connection\n")
      if db then
        local tbl = util.JSONToTable(db)
        XeninDB.initialize(tbl)
        self.serverId = tbl.serverId or 1
      else
        XeninDB.initialize({
          EnableMySQL = false,
          Host = "ip",
          Username = "root",
          Password = "password",
          Database_name = "gmod_server",
          Database_port = 3306,
          MultiStatements = false
        })
      end
    end,
    loadConfig = function(self)
      XeninUI.ORM.DB = XeninUI.ORM.ORM("xeninui/server/migrations/")


      timer.Simple(3, function()
        self.db = XeninUI.ORM.DB
        self.builder = XeninUI.ORM.Builder
        local id = self.serverId or 1

        self.db:orm("xenin_framework_settings"):select():where("server_id", "=", self.builder.raw(tostring(id) .. " or NULL")):run():next(function(result)
          for i, v in ipairs(result or {}) do
            local val = v.json and util.JSONToTable(v.value) or v.value

            self:register(v.id, val)
          end

          self.loaded = true

          hook.Run("Xenin.ConfigLoaded")
        end)
      end)
    end,
    loadClient = function(self, selector)
      if selector == nil then selector = "scripts"
      end
      net.Start("Xenin.RequestConfig")
      net.WriteString(selector)
      net.SendToServer()
    end,
    getIndex = function(self, selector)
      local tbl = self.config
      local split = string.Explode(".", selector)

      for i, v in ipairs(split) do
        if (v == "") then continue end
        if (!tbl[v]) then return end

        tbl = tbl[v]
      end

      return tbl
    end,
    save = function(self, scriptId, tbl)
      if tbl == nil then tbl = {}
      end
      if CLIENT then
        tbl = von.serialize(tbl)
        local len = tbl:len()

        net.Start("Xenin.Config")
        net.WriteString(scriptId)
        net.WriteUInt(len, 32)
        net.WriteData(tbl, len)
        net.SendToServer()
      else
        local tbl = XeninUI.Config:get("scripts")[scriptId]
        if (!tbl) then return end

        local id = self.serverId or 1

        for i, v in pairs(tbl) do
          local json = istable(v)
          local val = json and util.TableToJSON(v) or v

          self.db:orm("xenin_framework_settings"):upsert({
            id = tostring(scriptId) .. "." .. tostring(i),
            value = val,
            json = json,
            server_id = id
          }, {
          "id" }):run()
        end
      end
    end,
    get = function(self, selector, default)
      return self:getIndex(selector) or default
    end,
    set = function(self, selector, key, value)
      local tbl = self:getIndex(selector)
      tbl[key] = value

      return self
    end,
    __type = function(self)
      return "XeninUI.Config"end
  }
  _base_0.__index = _base_0
  _class_0 = setmetatable({
    __init = function(self)
      self.config = {}
      self:load()
    end,
    __base = _base_0
  }, {
    __index = _base_0,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  Config = _class_0
end

XeninUI.Config = Config()
XeninUI.Config:set("", "scripts", {})

--PATH lua/xeninui/libs/players/ui/notifications/hud.lua:
local x

--PATH lua/xeninui/libs/players/network/shared.lua:
return gluapack()()
--PATH lua/xeninui/elements/avatar.lua:
return gluapack()()
--PATH lua/xeninui/elements/category.lua:
return gluapack()()
--PATH lua/xeninui/elements/dropdown_player.lua:
return gluapack()()
--PATH lua/xeninui/elements/options.lua:
return gluapack()()
--PATH lua/xeninui/elements/sidebar.lua:
local PANEL = {}

XeninUI:CreateFont("XeninUI.Sidebar.Category.Title", 22)

AccessorFunc(PANEL, "m_body", "Body")
AccessorFunc(PANEL, "m_backgroundColor", "BackgroundColor")

function PANEL:Init()
  self:SetBackgroundColor(XeninUI.Theme.Navbar)

  self.buttons = {}
  self.panels = {}

  self:DockPadding(0, 0, 0, 0)
end

function PANEL:AddCategory(name)
  local panel = self:Add("Panel")
  panel:Dock(TOP)
  panel:DockMargin(0, 8, 0, 8)
  panel:SetTall(25)
  panel.color = Color(202, 202, 202)
  panel.Paint = function(pnl, w, h)
    draw.SimpleText(name, "XeninUI.Sidebar.Category.Title", w / 2, 0, pnl.color, TEXT_ALIGN_CENTER)
    surface.SetFont("XeninUI.Sidebar.Category.Title")
    local tw, th = surface.GetTextSize(name)

    surface.SetDrawColor(pnl.color)
    surface.DrawLine(10, th + 2, w - 10, th + 2)
  end
end

function PANEL:AddTab(name, icon, panelClass, panelFunc)
  local button = self:Add("XeninUI.Sidebar.Category")
  button:Dock(TOP)
  button:SetName(name)
  button:SetIcon(icon)
  button.OnMouseReleased = function(pnl)
    self:SetActive(pnl.Id)
  end
  button.panelClass = panelClass
  button.OnPanelCreated = function(pnl, panel)
    panelFunc(pnl, panel)
  end

  local id = table.insert(self.buttons, button)
  button.Id = id
end

function PANEL:SetActive(id, instant)
  if (self.active == id) then return end
  if (self.active and self.buttons[self.active]) then
    self.buttons[self.active].active = false
    self.buttons[self.active]:OnCursorExited()

    if IsValid(self.panels[self.active]) then
      self.panels[self.active]:SetVisible(false)
    end
  end

  self.active = id
  self.buttons[id].active = true

  if (!IsValid(self.panels[id])) then
    local panel = self:GetBody():Add(self.buttons[id].panelClass)
    panel:Dock(FILL)

    self.panels[id] = panel
    self.buttons[id]:OnPanelCreated(self.panels[id])
  else
    self.panels[id]:SetVisible(true)
  end

  if self.panels[id].OnSwitchedTo then
    self.panels[id]:OnSwitchedTo(self.buttons[id]:GetName())
  end

  if instant then
    self.buttons[id].Color = color_white
    self.buttons[id].Alpha = 255
  else
    self.buttons[id]:LerpColor("Color", color_white)
    self.buttons[id]:Lerp("Alpha", 255)
  end

  self:OnActiveChanged(id)
end

function PANEL:OnActiveChanged(id) end

function PANEL:PerformLayout(w, h)
  local width = 0

  surface.SetFont("XeninUI.Sidebar.Category")
  for i, v in pairs(self.buttons) do
    local tw = surface.GetTextSize(v:GetName())
    tw = tw + 64

    if (tw > width) then
      width = tw
    end

    v:SetTall(48)
  end

  self:SetWide(width)
end

function PANEL:Paint(w, h)
  draw.RoundedBoxEx(6, 0, 0, w, h, self:GetBackgroundColor(), false, false, true, false)
end

vgui.Register("XeninUI.Sidebar", PANEL)


local PANEL = {}

XeninUI:CreateFont("XeninUI.Sidebar.Category", 20)

local matGradientSidebar = Material("xenin/gradient_ltr.png")

AccessorFunc(PANEL, "m_name", "Name")
AccessorFunc(PANEL, "m_icon", "Icon")

function PANEL:Init()
  self.Color = Color(140, 140, 140)
  self.Alpha = 0
  self:SetCursor("hand")
end

function PANEL:OnCursorEntered()
  if self.active then return end

  self:Lerp("Alpha", 255)
  self:LerpColor("Color", Color(200, 200, 200))
end

function PANEL:OnCursorExited()
  if self.active then return end

  self:Lerp("Alpha", 0)
  self:LerpColor("Color", Color(140, 140, 140))
end

function PANEL:Paint(w, h)
  surface.SetMaterial(matGradientSidebar)
  surface.SetDrawColor(ColorAlpha(XeninUI.Theme.Accent, self.Alpha))
  surface.DrawTexturedRect(0, 0, w, h)

  local offset = 16
  if self:GetIcon() then
    surface.SetDrawColor(self.Color)
    surface.SetMaterial(self:GetIcon())
    surface.DrawTexturedRect(10, 10, h - 20, h - 20)

    offset = h
  end

  draw.SimpleText(self:GetName():upper(), "XeninUI.Sidebar.Category", offset, h / 2, self.Color, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
end

vgui.Register("XeninUI.Sidebar.Category", PANEL)

--PATH lua/xeninui/elements/sidebar_player.lua:
return gluapack()()
--PATH lua/xeninui/elements/sidebar_player.lua:
local PANEL = {}

XeninUI:CreateFont("XeninUI.Sidebar.Player.Name", 20)
XeninUI:CreateFont("XeninUI.Sidebar.Player.Job", 16)

function PANEL:Init()
  self:SetColors({
    startColor = Color(208, 62, 106),
    endColor = Color(200, 60, 123)
  }, {
    startColor = Color(251, 211, 50),
    endColor = Color(69, 198, 103)
  })

  self.Avatar = self:Add("XeninUI.Avatar")
  self.Avatar:SetPlayer(LocalPlayer(), 64)
  self.Avatar:SetVertices(30)

  self.Text = self:Add("DPanel")
  self.Text:SetMouseInputEnabled(false)
  self.Text.TextHeight = 0
  self.Text.Paint = function(pnl, w, h)
    local ply = LocalPlayer()

    pnl.TextHeight = 0
    for i, v in pairs(pnl.Rows) do
      XeninUI:DrawShadowText(v.text, v.font, 0, pnl.TextHeight, v.color, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP, 1, 255)

      pnl.TextHeight = pnl.TextHeight + draw.GetFontHeight(v.font) - 2
    end
  end

  local ply = LocalPlayer()
  self:SetRows({
    {
      font = "XeninUI.Sidebar.Player.Name",
      text = ply:Nick(),
      color = color_white
    },
    {
      font = "XeninUI.Sidebar.Player.Job",
      text = ply:GetUserGroup():gsub("^%l", string.upper),
      color = XeninUI.Theme.Green
    }
  })
end

function PANEL:SetColors(startGradient, endGradient)
  self.startGradient = startGradient
  self.endGradient = endGradient
end

function PANEL:SetRows(rows)
  self.Text.Rows = rows
end

function PANEL:Paint(w, h)
  local aX, aY = self:LocalToScreen()
  draw.SimpleLinearGradient(aX, aY, w, h, self.startGradient.startColor, self.startGradient.endColor)

  XeninUI:Mask(function()
    XeninUI:DrawRoundedBox((h - 24) / 2, 12, 12, h - 24, h - 24, color_white)
  end, function()
    draw.SimpleLinearGradient(aX + 12, aY + 12, h - 24, h - 24, self.endGradient.startColor, self.endGradient.endColor, true)
  end)
end

function PANEL:PerformLayout(w, h)
  self.Avatar:SetPos(14, 14)
  self.Avatar:SetSize(h - 28, h - 28)

  self.Text:MoveRightOf(self.Avatar, 10)
  local textH = 1
  for i, v in pairs(self.Text.Rows) do
    textH = textH + draw.GetFontHeight(v.font)
  end
  self.Text:SetTall(textH)
  self.Text:CenterVertical()
  self.Text:SetWide(w - self.Text.x)
end

vgui.Register("XeninUI.Sidebar.Player", PANEL)

--PATH lua/advdupe2/sh_codec.lua:
return gluapack()()
--PATH lua/autorun/client/vj_menu_main_client.lua:
return gluapack()()
--PATH lua/autorun/client/vj_menu_plugins.lua:
return gluapack()()
--PATH lua/autorun/client/vj_menu_plugins.lua:
return gluapack()()
--PATH lua/vgui/bvgui/form.lua:
local PANEL = {}

function PANEL:Init()
	self:SetColumns(bVGUI.COLUMN_LAYOUT_COLUMN_SHRINK, bVGUI.COLUMN_LAYOUT_COLUMN_GROW_COLUMN, bVGUI.COLUMN_LAYOUT_COLUMN_GROW)
end

function PANEL:SetTextSize(textsize)
	self.TextSize = textsize
end

function PANEL:CreateLabel(text, icon)
	if (ispanel(text)) then return text end
	local icon_container
	if (icon) then
		icon_container = vgui.Create("bVGUI.BlankPanel", self)
		icon_container:SetTall(16)
		icon_container.icon = vgui.Create("DImage", icon_container)
		icon_container.icon:SetSize(16,16)
		icon_container.icon:SetImage(icon)
	end

	local label
	if (icon) then
		label = vgui.Create("DLabel", icon_container)
	else
		label = vgui.Create("DLabel", self)
	end
	label:SetFont(bVGUI.FONT(bVGUI.FONT_RUBIK, "REGULAR", self.TextSize or 16))
	label:SetTextColor(bVGUI.COLOR_WHITE)
	label:SetText(text)
	label:SizeToContents()
	label:SetContentAlignment(7)
	label:SetWrap(true)
	label:SetAutoStretchVertical(true)
	if (icon) then
		function label:PerformLayout()
			icon_container:SetSize(16 + 5 + self:GetWide(), self:GetTall())
			self:AlignLeft(16 + 5)
		end
		return icon_container
	else
		return label
	end
end

function PANEL:AddSpacing(h)
	local pnl1 = vgui.Create("bVGUI.BlankPanel", self)
	pnl1:SetSize(0,h)
	local pnl2 = vgui.Create("bVGUI.BlankPanel", self)
	pnl2:SetSize(0,h)
	local pnl3 = vgui.Create("bVGUI.BlankPanel", self)
	pnl3:SetSize(0,h)
	self:AddRow(pnl1,pnl2,pnl3)
end

function PANEL:AddButton(text, btncolor, help, func)
	local btn = vgui.Create("bVGUI.Button", self)
	btn:SetColor(btncolor)
	btn:SetText(text)
	btn:SetTall(25)
	if (func) then
		function btn:DoClick()
			func()
		end
	end

	local l1 = self:CreateLabel(text)
	local l2 = self:CreateLabel(help)

	self:AddRow(l1, btn, l2)

	return l1, btn, l2
end

function PANEL:AddSwitch(text, state, help, func)
	local switch = vgui.Create("bVGUI.Switch", self)
	switch:SetChecked(state)
	switch:SetText("")
	if (func) then
		function switch:OnChange()
			func(switch:GetChecked())
		end
	end

	local l1 = self:CreateLabel(text)
	local l2 = self:CreateLabel(help)

	self:AddRow(l1, switch, l2)

	return l1, switch, l2
end

function PANEL:AddCheckbox(text, state, help, func)
	local switch = vgui.Create("bVGUI.Checkbox_Crossable", self)
	switch:SetChecked(state)
	switch:SetText("")
	if (func) then
		function switch:OnChange()
			func(switch:GetChecked())
		end
	end

	local l1 = self:CreateLabel(text)
	local l2 = self:CreateLabel(help)

	self:AddRow(l1, switch, l2)

	return l1, switch, l2
end

function PANEL:AddComboBox(text, selected, help, func, icon)
	local combobox = vgui.Create("bVGUI.ComboBox", self)
	if (selected) then combobox:SetValue(selected) end
	if (func) then
		function combobox:OnSelect(index, value, data)
			func(index, value, data)
		end
	end

	local l1 = self:CreateLabel(text, icon)
	local l2 = self:CreateLabel(help)

	self:AddRow(l1, combobox, l2)

	return l1, combobox, l2
end

function PANEL:AddTextEntry(text, value, help, func, validation, placeholder, icon)
	local textentry = vgui.Create("bVGUI.TextEntry", self)
	textentry:SetValue(value)
	if (placeholder) then
		textentry:SetPlaceholderText(placeholder)
	end
	local prev_val = value
	function textentry:OnValueChange(val)
		if (validation == nil or validation(val) == true) then
			prev_val = val
			if (func) then func(val) end
		else
			self:SetValue(prev_val)
			self:SetText(prev_val)
			GAS:PlaySound("error")
		end
	end

	local l1 = self:CreateLabel(text, icon)
	local l2 = self:CreateLabel(help)

	self:AddRow(l1, textentry, l2)

	return l1, textentry, l2
end

function PANEL:AddLongTextEntry(...)
	local l1, textentry, l2 = self:AddTextEntry(...)

	textentry:SetMultiline(true)
	textentry:SetContentAlignment(7)
	textentry:SetTall(75)

	return l1, textentry, l2
end

function PANEL:AddNumberEntry(text, value, help, func, allow_negative)
	local textentry = vgui.Create("bVGUI.TextEntry", self)
	textentry:SetNumeric(true)
	textentry:SetValue(value)
	local prev_val = value
	function textentry:OnValueChange(val)
		if (not tonumber(self:GetValue()) or (allow_negative ~= true and tonumber(self:GetValue()) < 0)) then
			self:SetValue(prev_val)
			self:SetText(prev_val)
			GAS:PlaySound("error")
		else
			prev_val = self:GetValue()
			if (func) then func(tonumber(val)) end
		end
	end

	local l1 = self:CreateLabel(text)
	local l2 = self:CreateLabel(help)

	self:AddRow(l1, textentry, l2)

	return l1, textentry, l2
end

function PANEL:AddColorMixer(text, value, help, func, alpha)
	local colormixer = vgui.Create("DColorMixer", self)
	colormixer:SetAlphaBar(alpha == true)
	colormixer:SetPalette(false)
	colormixer:SetTall(120)
	if (value) then
		colormixer:SetColor(value)
	end
	if (func) then
		function colormixer:ValueChanged(col)
			func(col)
		end
	end

	local l1 = self:CreateLabel(text)
	local l2 = self:CreateLabel(help)

	self:AddRow(l1, colormixer, l2)

	return l1, colormixer, l2
end

derma.DefineControl("bVGUI.Form", nil, PANEL, "bVGUI.ColumnLayout")
--PATH lua/vgui/bvgui/infobar.lua:
return gluapack()()
--PATH lua/vgui/bvgui/progressbar.lua:
local PANEL = {}

function PANEL:Init()
	self.Min = 0
	self.Max = 0
	self.Progress = 0
	self.Fraction = 0
	self.Decimals = false

	self.Text = vgui.Create("DLabel", self)
	self.Text:SetText("")
	self.Text:SetTextColor(bVGUI.COLOR_WHITE)
	self.Text:SetFont(bVGUI.FONT(bVGUI.FONT_RUBIK, "BOLD", 14))

	self.ProgressBar_X = -1
	self.ProgressBar_Col = -1
end

function PANEL:Paint(w,h)
	surface.SetDrawColor(bVGUI.COLOR_SLATE)
	surface.DrawRect(0,0,w,h)

	--surface.SetMaterial(bVGUI.MATERIAL_GRADIENT_LIGHT)
	--surface.DrawTexturedRect(0,0,w,h)

	local w_frac = self.Fraction * w
	if (self.ProgressBar_X == -1) then
		self.ProgressBar_X = w_frac
	else
		self.ProgressBar_X = Lerp(FrameTime() * 10, self.ProgressBar_X, w_frac)
	end

	local frac_255 = self.Fraction * 255
	if (self.ProgressBar_Col == -1) then
		self.ProgressBar_Col = frac_255
	else
		self.ProgressBar_Col = Lerp(FrameTime() * 10, self.ProgressBar_Col, frac_255)
	end

	surface.SetDrawColor(255 - self.ProgressBar_Col, self.ProgressBar_Col, 0, 255)
	surface.DrawRect(0, 0, self.ProgressBar_X, h)

	--surface.SetMaterial(bVGUI.MATERIAL_GRADIENT_LIGHT)
	--surface.DrawTexturedRect(0, 0, self.ProgressBar_X, h)

	surface.SetDrawColor(bVGUI.COLOR_BLACK)
	surface.DrawOutlinedRect(0,0,w,h)
end

function PANEL:Think()
	self.Fraction = (self.Progress - self.Min) / (self.Max - self.Min)
	if (self.Decimals == false and tostring(self.Fraction * 100):find("%.")) then
		self.Decimals = true
	end

	if (self.Fraction > 0) then
		if (self.Decimals) then
			local percentage = math.Round(self.Fraction * 100, 1)
			if (percentage % 1 == 0 and self.Fraction ~= 1) then
				percentage = percentage .. ".0"
			end
			self.Text:SetText(percentage .. "%")
		else
			self.Text:SetText(math.Round(self.Fraction * 100, 1) .. "%")
		end
		self.Text:SizeToContents()
		self.Text:Center()
	elseif (self.Text:GetText() ~= "") then
		self.Text:SetText("")
	end
end

derma.DefineControl("bVGUI.ProgressBar", nil, PANEL, "DPanel")
--PATH lua/vgui/bvgui/renderscene.lua:
return gluapack()()
--PATH lua/vgui/bvgui/renderscene.lua:
local IsInspecting = false

local LockView
local ViewOrigin, ViewAngle
local Velocity = Vector(0,0,0)
local CalcView_tbl = {}
hook.Add("CalcView", "bvgui_renderscene_CalcView", function(ply, origin, angles, fov)
	if (IsInspecting) then
		if (not ViewOrigin or not ViewAngle) then
			ViewOrigin, ViewAngle = origin, angles
		end
		CalcView_tbl.origin = ViewOrigin
		CalcView_tbl.angles = ViewAngle
	end

	if (GAS and GAS.Logging and GAS.Logging.Scenes) then
		if (IsInspecting) then
			GAS.Logging.Scenes.ViewOrigin = ViewOrigin
		else
			GAS.Logging.Scenes.ViewOrigin = nil
		end
	end

	if (IsInspecting) then return CalcView_tbl end
end)

local tr = { collisiongroup = COLLISION_GROUP_WORLD }
local function IsInWorld( pos )
	tr.start = pos
	tr.endpos = pos
	return util.TraceLine( tr ).HitWorld
end

hook.Add("CreateMove", "bvgui_renderscene_CreateMove", function(cmd)
	if (not IsInspecting) then
		LockView = nil
		Velocity.x, Velocity.y, Velocity.z = 0,0,0
		return
	end

	if (not LockView) then
		LockView = cmd:GetViewAngles()
	else
		cmd:SetViewAngles(LockView)
	end
	
	cmd:ClearMovement()

	local time = FrameTime()
   
	local sensitivity = 0.022
	ViewAngle:Normalize()
	ViewAngle.p = math.Clamp(ViewAngle.p + (cmd:GetMouseY() * sensitivity), -89, 89)
	ViewAngle.y = ViewAngle.y + (cmd:GetMouseX() * -1 * sensitivity)

	local NewViewOrigin = ViewOrigin + (Velocity * time)
   
	local add = Vector(0,0,0)
	local ang = ViewAngle
	if (cmd:KeyDown(IN_FORWARD)) then add = add + ang:Forward() end
	if (cmd:KeyDown(IN_BACK)) then add = add - ang:Forward() end
	if (cmd:KeyDown(IN_MOVERIGHT)) then add = add + ang:Right() end
	if (cmd:KeyDown(IN_MOVELEFT)) then add = add - ang:Right() end
	if (cmd:KeyDown(IN_JUMP)) then add = add + ang:Up() end
	if (cmd:KeyDown(IN_DUCK)) then add = add - ang:Up() end
   
	add = add:GetNormal() * time * 1000
	if (cmd:KeyDown(IN_SPEED)) then add = add * 2 end

	Velocity = Velocity * 0.95
	ViewOrigin = NewViewOrigin
   
	Velocity = Velocity + add

	cmd:ClearButtons()
end)

local function ResetNoDraw()
	for _,ent in ipairs(ents.GetAll()) do
		if (ent.bVGUI_RenderScene_SetNoDraw) then
			ent.bVGUI_RenderScene_SetNoDraw = nil
			ent:SetNoDraw(false)
		end
	end
end
local function SetNoDraw()
	for _,ent in ipairs(ents.GetAll()) do
		if (ent:GetNoDraw() == false and not ent.bVGUI_RenderScene_ForceDraw) then
			ent.bVGUI_RenderScene_SetNoDraw = true
			ent:SetNoDraw(true)
		end
	end
end
local function CheckNoDraw(ent)
	if (not IsValid(ent)) then return end
	if (IsInspecting) then
		if (ent:GetNoDraw() == false and not ent.bVGUI_RenderScene_ForceDraw) then
			ent.bVGUI_RenderScene_SetNoDraw = true
			ent:SetNoDraw(true)
		end
	else
		if (ent.bVGUI_RenderScene_SetNoDraw) then
			ent.bVGUI_RenderScene_SetNoDraw = nil
			ent:SetNoDraw(false)
		end
	end
end
local function KeepNoDraw(ent)
	CheckNoDraw(ent)
	CheckNoDraw(ent:GetParent())
end
hook.Add("NotifyShouldTransmit", "bvgui_renderscene_KeepNoDraw", KeepNoDraw)

local static = Material("vgui/bvgui/static.vtf")

local PANEL = {}

function PANEL:Init()
	local this = self

	local function find_dframe(pnl)
		if (IsValid(pnl.bVGUI_PinButton)) then
			return pnl
		elseif (IsValid(pnl:GetParent())) then
			return find_dframe(pnl:GetParent())
		end
	end
	self.PvPEventFrame = find_dframe(self:GetParent())

	self.Inspecting = false
	self.Rendering = false
	self.CanRender = true
	self.Origin = Vector(0,0,0)
	self.Angle = Angle(0,0,0)

	self:SetMouseInputEnabled(true)
	self:SetCursor("hand")

	self.RenderView = {
		origin = self.Origin,
		angles = self.Angle,
		drawviewmodel = false,
		fov = 120,
		bloomtone = false,
		aspectratio = 0
	}

	self.Toolbar = vgui.Create("bVGUI.BlankPanel", self)
	self.Toolbar:DockPadding(2,2,2,2)
	self.Toolbar:SetPos(5,5)
	function self.Toolbar:Paint(w,h)
		surface.SetDrawColor(47,79,115,255)
		surface.DrawRect(0,0,w,h)

		surface.SetMaterial(bVGUI.MATERIAL_GRADIENT_LIGHT)
		surface.DrawTexturedRect(0,0,w,h)
	end

	self.InspectBtn = vgui.Create("DImageButton", self.Toolbar)
	self.InspectBtn:Dock(LEFT)
	self.InspectBtn:DockMargin(0,0,5,0)
	self.InspectBtn:SetSize(16,16)
	self.InspectBtn:SetImage("icon16/world.png")
	function self.InspectBtn:DoClick()
		if (IsInspecting and not this.Inspecting) then return end
		if (IsInspecting) then
			IsInspecting = false
			this.Inspecting = false
			if (ViewOrigin and ViewAngle) then
				this:SetOrigin(ViewOrigin)
				this:SetAngle(ViewAngle)
			end
			ResetNoDraw()

			this.PvPEventFrame:SetPos(this.PvPEventFrame.GAS_RenderScene_FramePosX, this.PvPEventFrame.GAS_RenderScene_FramePosY)
			for _,dframe in ipairs(bVGUI.Frames) do
				if (IsValid(dframe) and dframe.GAS_RenderScene_Hidden) then
					dframe:SetVisible(true)
				end
			end
		else
			ViewOrigin, ViewAngle = this.Origin, this.Angle

			SetNoDraw()

			this.PvPEventFrame.bVGUI_PinButton:TogglePin()
			this.PvPEventFrame.GAS_RenderScene_FramePosX, this.PvPEventFrame.GAS_RenderScene_FramePosY = this.PvPEventFrame:GetPos()
			this.PvPEventFrame:SetPos(ScrW() - this.PvPEventFrame:GetWide() - 20, ScrH() - this.PvPEventFrame:GetTall() - 20)
			for _,dframe in ipairs(bVGUI.Frames) do
				if (IsValid(dframe) and dframe ~= this.PvPEventFrame and dframe:IsVisible()) then
					dframe:SetVisible(false)
					dframe.GAS_RenderScene_Hidden = true
				end
			end

			IsInspecting = true
			this.Inspecting = true
		end
		GAS:PlaySound("jump")
	end
	bVGUI.AttachTooltip(self.InspectBtn, {Text = bVGUI.L("inspect")})

	local screenshot = vgui.Create("DImageButton", self.Toolbar)
	screenshot:Dock(LEFT)
	screenshot:SetSize(16,16)
	screenshot:DockMargin(0,0,5,0)
	screenshot:SetImage("icon16/camera.png")
	function screenshot:Capture()
		gui.HideGameUI()
		bVGUI.DestroyTooltip()

		timer.Simple(0, function()
			hook.Add("PostRender", "GAS_RenderScene_Screenshot", function()
				local img = render.Capture({
					format = "png",
					x = 0,
					y = 0,
					w = ScrW(),
					h = ScrH(),
					alpha = false
				})

				local name = "gas_scene_screenshot_" .. os.date("%d_%m_%Y_%H_%M_%S")
				local function screenshot_name(i)
					if (i == nil) then
						if (file.Exists(name, "DATA")) then
							return screenshot_name(2)
						else
							return name
						end
					else
						if (file.Exists(name .. "_" .. i, "DATA")) then
							return screenshot_name(i + 1)
						else
							return name .. "_" .. i
						end
					end
				end
				local screenshot_name = screenshot_name() .. ".png"
				file.Write(screenshot_name, img)

				hook.Remove("PostRender", "GAS_RenderScene_Screenshot")

				bVGUI.RichMessage({
					title = bVGUI.L("screenshot_saved"),
					button = bVGUI.L("ok"),
					textCallback = function(text)
						local full_path = "garrysmod/data/" .. screenshot_name

						text:InsertColorChange(255,255,255,255)
						local t = bVGUI.L("screenshot_saved_to")
						local s,e = t:find("%%s")
						text:AppendText(t:sub(1,s-1))

						text:InsertColorChange(0,255,255,255)
						text:InsertClickableTextStart("CopyFilePath")
						text:AppendText(full_path)
						text:InsertClickableTextEnd()

						text:InsertColorChange(255,255,255,255)
						text:AppendText(t:sub(e+1))

						function text:ActionSignal(signalName, signalValue)
							if (signalName == "TextClicked" and signalValue == "CopyFilePath") then
								GAS:SetClipboardText(full_path)
							end
						end
					end
				})

				if (IsValid(self) and IsValid(this) and this.Inspecting) then
					this.InspectBtn:DoClick()
				end

				GAS:PlaySound("success")
			end)
		end)
	end
	function screenshot:DoClick()
		if (this.Inspecting) then
			self:Capture()
		elseif (not IsInspecting) then
			this.InspectBtn:DoClick()
			self:Capture()
		end
	end
	bVGUI.AttachTooltip(screenshot, {Text = bVGUI.L("screenshot")})

	local reset = vgui.Create("DImageButton", self.Toolbar)
	reset:Dock(LEFT)
	reset:SetSize(16,16)
	reset:SetImage("icon16/arrow_refresh.png")
	function reset:DoClick()
		if (this.OriginalOrigin) then
			this:SetOrigin(Vector(this.OriginalOrigin.x, this.OriginalOrigin.y, this.OriginalOrigin.z))
		end
		if (this.OriginalAngles) then
			this:SetAngle(Angle(this.OriginalAngles.p, this.OriginalAngles.y, this.OriginalAngles.r))
		end
		GAS:PlaySound("delete")
	end
	bVGUI.AttachTooltip(reset, {Text = bVGUI.L("reset")})
end

function PANEL:OnRemove()
	if (self.Inspecting) then
		self.InspectBtn:DoClick()
	end
end

function PANEL:PerformLayout(w,h)
	self.Toolbar:SetSize(w - 10,20)
end

local click_to_render_font = bVGUI.FONT(bVGUI.FONT_CIRCULAR, "REGULAR", 18)
function PANEL:Paint(w,h)
	if (not self.Rendering or IsInspecting) then
		surface.SetDrawColor(255,255,255)
		surface.SetMaterial(static)
		local d = math.max(w,h)
		surface.DrawTexturedRect((w - d) / 2,(h - d) / 2,d,d)

		surface.SetMaterial(bVGUI.MATERIAL_GRADIENT)
		surface.DrawTexturedRect(0,(((SysTime() % 5) / 5) * (h + 30)) - 30,w,30)

		if (self.CanRender and not IsInspecting) then
			draw.SimpleTextOutlined(bVGUI.L("click_to_render"), click_to_render_font, w / 2, (h - 20) / 2, bVGUI.COLOR_WHITE, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 2, bVGUI.COLOR_BLACK)
		end
		if (self.Inspecting) then
			draw.SimpleTextOutlined(bVGUI.L("inspecting"), click_to_render_font, w / 2, (h - 20) / 2, bVGUI.COLOR_RED, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 2, bVGUI.COLOR_BLACK)
		elseif (not self.CanRender) then
			draw.SimpleTextOutlined(bVGUI.L("no_data"), click_to_render_font, w / 2, (h - 20) / 2, bVGUI.COLOR_RED, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 2, bVGUI.COLOR_BLACK)
		end
	else
		local x,y = self:LocalToScreen(0,0)
		self.RenderView.x, self.RenderView.y, self.RenderView.w, self.RenderView.h = x,y,w,h
		render.RenderView(self.RenderView)
	end

	surface.SetDrawColor(0,0,0)
	surface.DrawRect(0,0,5,h)
	surface.DrawRect(0,0,w,5)
	surface.DrawRect(w - 5,0,5,h)
	surface.DrawRect(0,h - 30,w,30)

	self.Toolbar:SetVisible(self.Rendering)
end

function PANEL:SetLabel(txt)
	self.Label = vgui.Create("DLabel", self)
	self.Label:SetFont(bVGUI.FONT(bVGUI.FONT_CIRCULAR, "REGULAR", 16))
	self.Label:SetTextColor(bVGUI.COLOR_WHITE)
	self.Label:SetText(txt)
	self.Label:Dock(FILL)
	self.Label:DockMargin(0,0,0,7.5)
	self.Label:SetContentAlignment(2)
end

function PANEL:SetOrigin(origin)
	self.Origin = origin
	self.RenderView.origin = self.Origin
	if (not self.OriginalOrigin) then
		self.OriginalOrigin = Vector(origin.x,origin.y,origin.z)
	end
end

function PANEL:SetAngle(ang)
	self.Angle = ang
	self.RenderView.angles = self.Angle
	if (not self.OriginalAngles) then
		self.OriginalAngles = Angle(ang.p,ang.y,ang.r)
	end
end

function PANEL:SetRendering(rendering)
	self.Rendering = rendering
	if (self.Rendering and self.OnStartRender) then
		self:OnStartRender()
	elseif (not self.Rendering and self.OnEndRender) then
		self:OnEndRender()
	end

	if (not self.Rendering and self.Inspecting) then
		self.Inspecting = false
		IsInspecting = false
	end
end

function PANEL:SetCanRender(can_render)
	self.CanRender = can_render
	if (not self.CanRender) then
		self:SetCursor("none")
	else
		self:SetCursor("hand")
	end
	if (self.Rendering) then
		self:SetRendering(false)
	end
end

function PANEL:DoClick()
	if (not self.Rendering) then
		if (not self.CanRender) then
			GAS:PlaySound("error")
		else
			self:SetRendering(true)
			GAS:PlaySound("btn_on")
			notification.AddLegacy(bVGUI.L("right_click_to_stop_rendering"), NOTIFY_HINT, 2)
		end
	else
		self.InspectBtn:DoClick()
	end
end

function PANEL:DoRightClick()
	if (self.Rendering) then
		if (self.Inspecting) then
			self.InspectBtn:DoClick()
		end
		self:SetRendering(false)
		GAS:PlaySound("btn_off")
	end
end

function PANEL:OnMousePressed(m)
	self.m_pressing = m
end
function PANEL:OnMouseReleased(m)
	if (self.m_pressing == m) then
		if (m == MOUSE_LEFT) then
			self:DoClick()
		elseif (m == MOUSE_RIGHT) then
			self:DoRightClick()
		end
	end
	self.m_pressing = nil
end

derma.DefineControl("bVGUI.RenderScene", nil, PANEL, "bVGUI.BlankPanel")
--PATH lua/vgui/bvgui/table.lua:
return gluapack()()
--PATH lua/vgui/bvgui/vertical_option_selector.lua:
return gluapack()()
--PATH lua/vgui/openpermissions_scrollpanel.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/gamemode/modules/police/sh_interface.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/gamemode/modules/language/sh_interface.lua:
DarkRP.addLanguage = DarkRP.stub{
    name = "addLanguage",
    description = "Create a language/translation.",
    parameters = {
        {
            name = "Language name",
            description = "The short name of the language (\"en\" is English). Make sure the language name fits a possible value for gmod_language!",
            type = "string",
            optional = false
        },
        {
            name = "Language contents",
            description = "A table that contains the translation sentences. Look at sh_english.lua for an example.",
            type = "table",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.addPhrase = DarkRP.stub{
    name = "addPhrase",
    description = "Add a phrase to the existing translation.",
    parameters = {
        {
            name = "Language name",
            description = "The short name of the language (\"en\" is English). Make sure the language name fits a possible value for gmod_language!",
            type = "string",
            optional = false
        },
        {
            name = "key",
            description = "The name of the translated phrase.",
            type = "string",
            optional = false
        },
        {
            name = "translation",
            description = "The translation of the phrase.",
            type = "string",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.getPhrase = DarkRP.stub{
    name = "getPhrase",
    description = "Get a phrase from the selected language.",
    parameters = {
        {
            name = "key",
            description = "The name of the translated phrase.",
            type = "string",
            optional = false
        },
        {
            name = "Phrase parameters",
            description = "Some phrases need extra information, like in \"PLAYERNAME just won the lottery!\". Not filling in the phrase parameters will cause errors.",
            type = "vararg",
            optional = false
        }
    },
    returns = {
        {
            name = "phrase",
            description = "The formatted phrase.",
            type = "string"
        }
    },
    metatable = DarkRP
}

DarkRP.getPhraseLocalized = DarkRP.stub{
    name = "getPhraseLocalized",
    description = "Translate a phrase using the language setting of a specific player.",
    parameters = {
        {
            name = "ply",
            description = "The player to use the language setting of.",
            type = "Player",
            optional = false
        },
        {
            name = "phraseName",
            description = "The name of the phrase.",
            type = "string",
            optional = false
        },
        {
            name = "Phrase parameters",
            description = "Some phrases need extra information, like in \"PLAYERNAME just won the lottery!\". Not filling in the phrase parameters will cause errors.",
            type = "vararg",
            optional = false
        }
    },
    returns = {
        {
            name = "phrase",
            description = "The formatted phrase.",
            type = "string"
        }
    },
    metatable = DarkRP
}

DarkRP.getMissingPhrases = DarkRP.stub{
    name = "getMissingPhrases",
    description = "Get all the phrases a language is missing.",
    parameters = {
        {
            name = "languageCode",
            description = "The language code of the language. For English this is \"en\".",
            type = "string",
            optional = true
        }
    },
    returns = {
        {
            name = "missingPhrases",
            description = "All the missing phrases formatted in such way that you can copy and paste it in your language file.",
            type = "string"
        }
    },
    metatable = DarkRP
}

DarkRP.addChatCommandsLanguage = DarkRP.stub{
    name = "addChatCommandsLanguage",
    description = "Add a translation table for chat command descriptions. See darkrpmod/lua/darkrp_language/chatcommands.lua for an example.",
    parameters = {
        {
            name = "languageCode",
            description = "The language code of the language. For English this is \"en\".",
            type = "string",
            optional = false
        },
        {
            name = "translations",
            description = "Key-value table with chat command strings as keys and their translation as value.",
            type = "table",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.getChatCommandDescription = DarkRP.stub{
    name = "getChatCommandDescription",
    description = "Get the translated description of a chat command.",
    parameters = {
        {
            name = "command",
            description = "The chat command string.",
            type = "string",
            optional = false
        }
    },
    returns = {
        {
            name = "description",
            description = "The translated chat command description.",
            type = "string"
        }
    },
    metatable = DarkRP
}

--PATH gamemodes/starwarsrp/gamemode/modules/jobs/sh_interface.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/gamemode/modules/tipjar/cl_frame.lua:
local updateModel, getModelValue, onModelUpdate =
    DarkRP.tipJarUIModel.updateModel,
    DarkRP.tipJarUIModel.getModelValue,
    DarkRP.tipJarUIModel.onModelUpdate


--[[-------------------------------------------------------------------------
Donation amount entry
---------------------------------------------------------------------------]]
local DONATE_ENTRY = {}

function DONATE_ENTRY:Init()
    self.BaseClass.Init(self)

    self:SetNumeric(true)
    self:SetSize(290, 70)
    self:SetFont("HUDNumber5")
    self:SetText("")

    onModelUpdate("amount", function(new, _, src)
        if not IsValid(self) or src == self then return end

        local pos = self:GetCaretPos()
        self:SetText(new)
        self:SetCaretPos(math.min(pos, string.len(new)))
    end)

    onModelUpdate("lastTipAmount", function()
        self:SelectAllText()
        self:RequestFocus()
    end)
end

function DONATE_ENTRY:CheckNumeric(value)
    if DarkRP.toInt(value) then return false end

    return true
end

function DONATE_ENTRY:OnChange()
    local value = DarkRP.toInt(self:GetText())

    if not value then return end

    updateModel("amount", value, self)
end

function DONATE_ENTRY:OnEnter()
    updateModel("frameVisible", false)
    updateModel("lastTipAmount", getModelValue("amount"))
end

derma.DefineControl("DarkRP_TipJar_DONATE_ENTRY", "", DONATE_ENTRY, "DTextEntry")

local DONATE_BUTTON = {}

function DONATE_BUTTON:Init()
    self.BaseClass.Init(self)

    self:SetSize(290, 80)
    self:SetText("")

    self.donateLabel = vgui.Create("DLabel", self)
    self.donateLabel:SetFont("HUDNumber5")
    self.donateLabel:SetText(DarkRP.getPhrase("Donate"))
    self.donateLabel:SizeToContents()
    self.donateLabel:SetPos(50, 10)
    self.donateLabel:CenterHorizontal()

    self.amountLabel = vgui.Create("DLabel", self)
    self.amountLabel:SetFont("HUDNumber5")
    self.amountLabel:SetPos(50, 40)

    onModelUpdate("amount", function(new)
        if not IsValid(self) then return end

        self.amountLabel:SetText(DarkRP.formatMoney(new))
        self.amountLabel:SizeToContents()
        self.amountLabel:CenterHorizontal()
    end)
end

function DONATE_BUTTON:DoClick()
    -- updateModel("frameVisible", false)
    updateModel("lastTipAmount", getModelValue("amount"))
end

derma.DefineControl("DarkRP_TipJar_DONATE_BUTTON", "", DONATE_BUTTON, "DButton")


local DONATE_LIST_ITEM = {}

function DONATE_LIST_ITEM:Init()
    self:SetSize(470, 25)
    self:SetPaintBackground(false)

    self.textL = vgui.Create("DLabel", self)
    self.textL:SetFont("DarkRPHUD2")
    self.textL:Dock(LEFT)

    self.textR = vgui.Create("DLabel", self)
    self.textR:SetFont("DarkRPHUD2")
    self.textR:DockMargin(5, 5, 20, 5)
    self.textR:Dock(RIGHT)

    self.donatedColor = Color(50, 130, 50)
    self.activeColor = Color(180, 180, 180)
    self.moneyColor = Color(50, 130, 50)
end

function DONATE_LIST_ITEM:SetActive(name, amount)
    self.textL:SetText(name)
    self.textL:SetTextColor(self.activeColor)
    self.textL:SizeToContents()

    self.textR:SetText(amount)
    self.textR:SetTextColor(self.activeColor)
    self.textR:SizeToContents()
end

function DONATE_LIST_ITEM:SetDonated(name, amount)
    self.textL:SetText(name)
    self.textL:SetTextColor(self.donatedColor)
    self.textL:SizeToContents()

    self.textR:SetText(amount)
    self.textR:SetTextColor(self.moneyColor)
    self.textR:SizeToContents()
end

derma.DefineControl("DarkRP_TipJar_DONATE_LIST_ITEM", "", DONATE_LIST_ITEM, "DPanel")


local DONATE_LIST = {}

function DONATE_LIST:Init()
    self.activeLines = {}
    self.donatedLines = {}

    self:SetSize(480, 465)

    self:SetBackgroundColor(color_transparent)
    self:EnableVerticalScrollbar()
    self:SetSpacing(10)
    self.VBar.Paint = fn.Id
    self.VBar.btnUp.Paint = fn.Id
    self.VBar.btnDown.Paint = fn.Id


    onModelUpdate("activeDonationUpdate", function()
        local tipjar = getModelValue("tipjar")

        if not IsValid(self) then return end
        if not IsValid(tipjar) then return end

        self:RebuildLines(tipjar)
    end)

    onModelUpdate("donatedUpdate", function()
        local tipjar = getModelValue("tipjar")

        if not IsValid(self) then return end
        if not IsValid(tipjar) then return end

        self:RebuildLines(tipjar)

        self:PerformLayout()
        self.VBar:SetScroll(math.huge)
    end)
end

function DONATE_LIST:AddActiveLine(name, amount)
    local line = vgui.Create("DarkRP_TipJar_DONATE_LIST_ITEM", self)
    line:SetActive(name, amount)
    self:AddItem(line)

    table.insert(self.activeLines, line)
end

function DONATE_LIST:AddDonatedLine(name, amount)
    local line = vgui.Create("DarkRP_TipJar_DONATE_LIST_ITEM", self)
    line:SetDonated(name, amount)
    self:AddItem(line)

    table.insert(self.donatedLines, line)
end

function DONATE_LIST:ClearLines()
    for _, line in ipairs(self.activeLines) do
        line:Remove()
    end

    for _, line in ipairs(self.donatedLines) do
        line:Remove()
    end

    table.Empty(self.activeLines)
    table.Empty(self.donatedLines)
end

function DONATE_LIST:RebuildLines(tipjar)
    self:ClearLines()

    for _, donation in ipairs(tipjar.madeDonations) do
        self:AddDonatedLine(donation.name, DarkRP.formatMoney(donation.amount))
    end

    for ply, amount in pairs(tipjar.activeDonations) do
        -- Don't show the owner looking at this page
        if ply == tipjar:Getowning_ent() then continue end

        self.activeLines[ply:Nick()] = DarkRP.formatMoney(amount)
    end

    for name, amount in SortedPairs(self.activeLines) do
        self:AddActiveLine(name, amount)
    end
end

derma.DefineControl("DarkRP_TipJar_DONATE_LIST", "", DONATE_LIST, "DPanelList")


--[[-------------------------------------------------------------------------
Main frame
---------------------------------------------------------------------------]]
local FRAME = {}

function FRAME:Init()
    self:SetTitle("Tipping jar")
    self:SetSize(800, 500)
    self:Center()
    self:SetVisible(true)
    self:MakePopup()
    self:SetDeleteOnClose(false)

    self.donateEntry = vgui.Create("DarkRP_TipJar_DONATE_ENTRY", self)
    self.donateEntry:SetPos(10, 175)

    self.donateButton = vgui.Create("DarkRP_TipJar_DONATE_BUTTON", self)
    self.donateButton:SetPos(10, 245)

    self.donateList = vgui.Create("DarkRP_TipJar_DONATE_LIST", self)
    self.donateList:SetPos(310, 25)


    self:SetSkin(GAMEMODE.Config.DarkRPSkin)
end

function FRAME:OnClose()
    updateModel("frameVisible", false)
end

function FRAME:Think()
    local tipJar = getModelValue("tipjar")

    if not IsValid(tipJar) or
       tipJar:GetPos():DistToSqr(LocalPlayer():GetPos()) > 100 * 100 then
        updateModel("frameVisible", false)
   end
end

derma.DefineControl("DarkRP_TipJar_FRAME", "", FRAME, "DFrame")

onModelUpdate("frameVisible", function(visible)
    local tipjar = getModelValue("tipjar")
    if not IsValid(tipjar) then return end

    if not getModelValue("frame") then
        if not visible then return end

        updateModel("frame", vgui.Create("DarkRP_TipJar_FRAME"))
    end

    local frame = getModelValue("frame")

    frame:SetVisible(visible)

    if visible then
        updateModel("amount", 0)
        frame.donateEntry:SelectAllText()
        frame.donateEntry:RequestFocus()

        local disable = getModelValue("isOwner")
        frame.donateEntry:SetDisabled(disable)
        frame.donateButton:SetDisabled(disable)
    end
end)

function DarkRP.tipJarUI(tipjar)
    updateModel("tipjar", tipjar)
    updateModel("isOwner", tipjar:Getowning_ent() == LocalPlayer())
    updateModel("amount", 0)
    updateModel("frameVisible", true)
end

--PATH gamemodes/starwarsrp/gamemode/modules/money/sh_money.lua:
local pMeta = FindMetaTable("Player")
local entMeta = FindMetaTable("Entity")

function pMeta:canAfford(amount)
    if not amount or self.DarkRPUnInitialized then return false end
    return math.floor(amount) >= 0 and (self:getDarkRPVar("money") or 0) - math.ceil(amount) >= 0
end

function entMeta:isMoneyBag()
    return self.IsSpawnedMoney or self:GetClass() == GAMEMODE.Config.MoneyClass
end

--PATH gamemodes/starwarsrp/gamemode/modules/logging/cl_init.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/gamemode/modules/hud/sh_chatcommands.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/gamemode/modules/hud/cl_hud.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/gamemode/modules/dermaskin/cl_dermaskin.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/gamemode/modules/dermaskin/cl_dermaskin.lua:
-- Skin for DarkRP gui's
SKIN = {}

SKIN.PrintName          = "DarkRP"
SKIN.Author             = "FPtje Falco"
SKIN.DermaVersion       = 1
SKIN.GwenTexture        = Material("darkrp/darkrpderma.png")


SKIN.colTextEntryText               = color_white
SKIN.colTextEntryTextCursor         = color_white

SKIN.colTextEntryTextPlaceholder    = Color(200, 200, 200, 200) -- Unofficial but will probably be named this

SKIN.tex = {}

SKIN.tex.Selection                  = GWEN.CreateTextureBorder(384, 32, 31, 31, 4, 4, 4, 4)

SKIN.tex.Panels = {}
SKIN.tex.Panels.Normal              = GWEN.CreateTextureBorder(256, 0, 63, 63, 16, 16, 16, 16)
SKIN.tex.Panels.Bright              = GWEN.CreateTextureBorder(256 + 64, 0, 63, 63, 16, 16, 16, 16)
SKIN.tex.Panels.Dark                = GWEN.CreateTextureBorder(256, 64, 63, 63, 16, 16, 16, 16)
SKIN.tex.Panels.Highlight           = GWEN.CreateTextureBorder(256 + 64, 64, 63, 63, 16, 16, 16, 16)

SKIN.tex.Button                     = GWEN.CreateTextureBorder(480, 0, 31, 31, 8, 8, 8, 8)
SKIN.tex.Button_Hovered             = GWEN.CreateTextureBorder(480, 32, 31, 31, 8, 8, 8, 8)
SKIN.tex.Button_Dead                = GWEN.CreateTextureBorder(480, 64, 31, 31, 8, 8, 8, 8)
SKIN.tex.Button_Down                = GWEN.CreateTextureBorder(480, 96, 31, 31, 8, 8, 8, 8)
SKIN.tex.Shadow                     = GWEN.CreateTextureBorder(448, 0, 31, 31, 8, 8, 8, 8)

SKIN.tex.Tree                       = GWEN.CreateTextureBorder(256, 128, 127, 127, 16, 16, 16, 16)
SKIN.tex.Checkbox_Checked           = GWEN.CreateTextureNormal(448, 32, 15, 15)
SKIN.tex.Checkbox                   = GWEN.CreateTextureNormal(464, 32, 15, 15)
SKIN.tex.CheckboxD_Checked          = GWEN.CreateTextureNormal(448, 48, 15, 15)
SKIN.tex.CheckboxD                  = GWEN.CreateTextureNormal(464, 48, 15, 15)
--SKIN.tex.RadioButton_Checked      = GWEN.CreateTextureNormal(448, 64, 15, 15)
--SKIN.tex.RadioButton              = GWEN.CreateTextureNormal(464, 64, 15, 15)
--SKIN.tex.RadioButtonD_Checked     = GWEN.CreateTextureNormal(448, 80, 15, 15)
--SKIN.tex.RadioButtonD             = GWEN.CreateTextureNormal(464, 80, 15, 15)
SKIN.tex.TreePlus                   = GWEN.CreateTextureNormal(448, 96, 15, 15)
SKIN.tex.TreeMinus                  = GWEN.CreateTextureNormal(464, 96, 15, 15)
--SKIN.tex.Menu_Strip               = GWEN.CreateTextureBorder(0, 128, 127, 21, 1, 1, 1, 1)
SKIN.tex.TextBox                    = GWEN.CreateTextureBorder(0, 150, 127, 21, 4, 4, 4, 4)
SKIN.tex.TextBox_Focus              = GWEN.CreateTextureBorder(0, 172, 127, 21, 4, 4, 4, 4)
SKIN.tex.TextBox_Disabled           = GWEN.CreateTextureBorder(0, 193, 127, 21, 4, 4, 4, 4)
SKIN.tex.MenuBG_Margin              = GWEN.CreateTextureBorder(128, 128, 127, 63, 24, 8, 8, 8)
SKIN.tex.MenuBG                     = GWEN.CreateTextureBorder(128, 192, 127, 63, 8, 8, 8, 8)
SKIN.tex.MenuBG_Hover               = GWEN.CreateTextureBorder(128, 256, 127, 31, 8, 8, 8, 8)
SKIN.tex.MenuBG_Spacer              = GWEN.CreateTextureNormal(128, 288, 127, 3)
SKIN.tex.Tab_Control                = GWEN.CreateTextureBorder(0, 256, 127, 127, 8, 8, 8, 8)
SKIN.tex.TabB_Active                = GWEN.CreateTextureBorder(0, 416, 63, 31, 8, 8, 8, 8)
SKIN.tex.TabB_Inactive              = GWEN.CreateTextureBorder(0 + 128, 416, 63, 31, 8, 8, 8, 8)
SKIN.tex.TabT_Active                = GWEN.CreateTextureBorder(0, 384, 63, 31, 8, 8, 8, 8)
SKIN.tex.TabT_Inactive              = GWEN.CreateTextureBorder(0 + 128, 384, 63, 31, 8, 8, 8, 8)
SKIN.tex.TabL_Active                = GWEN.CreateTextureBorder(64, 384, 31, 63, 8, 8, 8, 8)
SKIN.tex.TabL_Inactive              = GWEN.CreateTextureBorder(64 + 128, 384, 31, 63, 8, 8, 8, 8)
SKIN.tex.TabR_Active                = GWEN.CreateTextureBorder(96, 384, 31, 63, 8, 8, 8, 8)
SKIN.tex.TabR_Inactive              = GWEN.CreateTextureBorder(96 + 128, 384, 31, 63, 8, 8, 8, 8)
SKIN.tex.Tab_Bar                    = GWEN.CreateTextureBorder(128, 352, 127, 31, 4, 4, 4, 4)

SKIN.tex.Window = {}

SKIN.tex.Window.Normal              = GWEN.CreateTextureBorder(0, 0, 127, 127, 8, 32, 8, 8)
SKIN.tex.Window.Inactive            = GWEN.CreateTextureBorder(128, 0, 127, 127, 8, 32, 8, 8)
SKIN.tex.Window.Close               = GWEN.CreateTextureNormal(0, 224, 24, 24)
SKIN.tex.Window.Close_Hover         = GWEN.CreateTextureNormal(32, 224, 24, 24)
SKIN.tex.Window.Close_Down          = GWEN.CreateTextureNormal(64, 224, 24, 24)
SKIN.tex.Window.Close_Disabled      = GWEN.CreateTextureNormal(96, 224, 24, 24)

SKIN.tex.Window.Maxi                = GWEN.CreateTextureNormal(32 + 96 * 2, 448, 31, 31)
SKIN.tex.Window.Maxi_Hover          = GWEN.CreateTextureNormal(64 + 96 * 2, 448, 31, 31)
SKIN.tex.Window.Maxi_Down           = GWEN.CreateTextureNormal(96 + 96 * 2, 448, 31, 31)

SKIN.tex.Window.Restore             = GWEN.CreateTextureNormal(32 + 96 * 2, 448 + 32, 31, 31)
SKIN.tex.Window.Restore_Hover       = GWEN.CreateTextureNormal(64 + 96 * 2, 448 + 32, 31, 31)
SKIN.tex.Window.Restore_Down        = GWEN.CreateTextureNormal(96 + 96 * 2, 448 + 32, 31, 31)

SKIN.tex.Window.Mini                = GWEN.CreateTextureNormal(32 + 96, 448, 31, 31)
SKIN.tex.Window.Mini_Hover          = GWEN.CreateTextureNormal(64 + 96, 448, 31, 31)
SKIN.tex.Window.Mini_Down           = GWEN.CreateTextureNormal(96 + 96, 448, 31, 31)

SKIN.tex.Scroller = {}
SKIN.tex.Scroller.TrackV                = GWEN.CreateTextureBorder(384, 208, 15, 127, 4, 4, 4, 4)
SKIN.tex.Scroller.ButtonV_Normal        = GWEN.CreateTextureBorder(384 + 16, 208, 15, 127, 4, 4, 4, 4)
SKIN.tex.Scroller.ButtonV_Hover         = GWEN.CreateTextureBorder(384 + 32, 208, 15, 127, 4, 4, 4, 4)
SKIN.tex.Scroller.ButtonV_Down          = GWEN.CreateTextureBorder(384 + 48, 208, 15, 127, 4, 4, 4, 4)
SKIN.tex.Scroller.ButtonV_Disabled      = GWEN.CreateTextureBorder(384 + 64, 208, 15, 127, 4, 4, 4, 4)

SKIN.tex.Scroller.TrackH                = GWEN.CreateTextureBorder(384, 128, 127, 15, 4, 4, 4, 4)
SKIN.tex.Scroller.ButtonH_Normal        = GWEN.CreateTextureBorder(384, 128 + 16, 127, 15, 4, 4, 4, 4)
SKIN.tex.Scroller.ButtonH_Hover         = GWEN.CreateTextureBorder(384, 128 + 32, 127, 15, 4, 4, 4, 4)
SKIN.tex.Scroller.ButtonH_Down          = GWEN.CreateTextureBorder(384, 128 + 48, 127, 15, 4, 4, 4, 4)
SKIN.tex.Scroller.ButtonH_Disabled      = GWEN.CreateTextureBorder(384, 128 + 64, 127, 15, 4, 4, 4, 4)

SKIN.tex.Scroller.LeftButton_Normal     = GWEN.CreateTextureBorder(464, 208, 15, 15, 2, 2, 2, 2)
SKIN.tex.Scroller.LeftButton_Hover      = GWEN.CreateTextureBorder(480, 208, 15, 15, 2, 2, 2, 2)
SKIN.tex.Scroller.LeftButton_Down       = GWEN.CreateTextureBorder(464, 272, 15, 15, 2, 2, 2, 2)
SKIN.tex.Scroller.LeftButton_Disabled   = GWEN.CreateTextureBorder(480 + 48, 272, 15, 15, 2, 2, 2, 2)

SKIN.tex.Scroller.UpButton_Normal       = GWEN.CreateTextureBorder(464, 208 + 16, 15, 15, 2, 2, 2, 2)
SKIN.tex.Scroller.UpButton_Hover        = GWEN.CreateTextureBorder(480, 208 + 16, 15, 15, 2, 2, 2, 2)
SKIN.tex.Scroller.UpButton_Down         = GWEN.CreateTextureBorder(464, 272 + 16, 15, 15, 2, 2, 2, 2)
SKIN.tex.Scroller.UpButton_Disabled     = GWEN.CreateTextureBorder(480 + 48, 272 + 16, 15, 15, 2, 2, 2, 2)

SKIN.tex.Scroller.RightButton_Normal    = GWEN.CreateTextureBorder(464, 208 + 32, 15, 15, 2, 2, 2, 2)
SKIN.tex.Scroller.RightButton_Hover     = GWEN.CreateTextureBorder(480, 208 + 32, 15, 15, 2, 2, 2, 2)
SKIN.tex.Scroller.RightButton_Down      = GWEN.CreateTextureBorder(464, 272 + 32, 15, 15, 2, 2, 2, 2)
SKIN.tex.Scroller.RightButton_Disabled  = GWEN.CreateTextureBorder(480 + 48, 272 + 32, 15, 15, 2, 2, 2, 2)

SKIN.tex.Scroller.DownButton_Normal     = GWEN.CreateTextureBorder(464, 208 + 48, 15, 15, 2, 2, 2, 2)
SKIN.tex.Scroller.DownButton_Hover      = GWEN.CreateTextureBorder(480, 208 + 48, 15, 15, 2, 2, 2, 2)
SKIN.tex.Scroller.DownButton_Down       = GWEN.CreateTextureBorder(464, 272 + 48, 15, 15, 2, 2, 2, 2)
SKIN.tex.Scroller.DownButton_Disabled   = GWEN.CreateTextureBorder(480 + 48, 272 + 48, 15, 15, 2, 2, 2, 2)

SKIN.tex.Menu = {}
SKIN.tex.Menu.RightArrow                = GWEN.CreateTextureNormal(464, 112, 15, 15)

SKIN.tex.Input = {}
SKIN.tex.Input.ListBox                  = GWEN.CreateTextureBorder(256, 256, 63, 127, 8, 8, 8, 8)

SKIN.tex.Input.ComboBox = {}
SKIN.tex.Input.ComboBox.Normal          = GWEN.CreateTextureBorder(384, 336, 127, 31, 8, 8, 32, 8)
SKIN.tex.Input.ComboBox.Hover           = GWEN.CreateTextureBorder(384, 336 + 32, 127, 31, 8, 8, 32, 8)
SKIN.tex.Input.ComboBox.Down            = GWEN.CreateTextureBorder(384, 336 + 64, 127, 31, 8, 8, 32, 8)
SKIN.tex.Input.ComboBox.Disabled        = GWEN.CreateTextureBorder(384, 336 + 96, 127, 31, 8, 8, 32, 8)

SKIN.tex.Input.ComboBox.Button = {}
SKIN.tex.Input.ComboBox.Button.Normal        = GWEN.CreateTextureNormal(496, 272, 15, 15)
SKIN.tex.Input.ComboBox.Button.Hover         = GWEN.CreateTextureNormal(496, 272 + 16, 15, 15)
SKIN.tex.Input.ComboBox.Button.Down          = GWEN.CreateTextureNormal(496, 272 + 32, 15, 15)
SKIN.tex.Input.ComboBox.Button.Disabled      = GWEN.CreateTextureNormal(496, 272 + 48, 15, 15)

SKIN.tex.Input.UpDown = {}
SKIN.tex.Input.UpDown.Up = {}
SKIN.tex.Input.UpDown.Up.Normal             = GWEN.CreateTextureCentered(384, 112, 7, 7)
SKIN.tex.Input.UpDown.Up.Hover              = GWEN.CreateTextureCentered(384 + 8, 112, 7, 7)
SKIN.tex.Input.UpDown.Up.Down               = GWEN.CreateTextureCentered(384 + 16, 112, 7, 7)
SKIN.tex.Input.UpDown.Up.Disabled           = GWEN.CreateTextureCentered(384 + 24, 112, 7, 7)

SKIN.tex.Input.UpDown.Down = {}
SKIN.tex.Input.UpDown.Down.Normal           = GWEN.CreateTextureCentered(384, 120, 7, 7)
SKIN.tex.Input.UpDown.Down.Hover            = GWEN.CreateTextureCentered(384 + 8, 120, 7, 7)
SKIN.tex.Input.UpDown.Down.Down             = GWEN.CreateTextureCentered(384 + 16, 120, 7, 7)
SKIN.tex.Input.UpDown.Down.Disabled         = GWEN.CreateTextureCentered(384 + 24, 120, 7, 7)

SKIN.tex.Input.Slider = {}
SKIN.tex.Input.Slider.H = {}
SKIN.tex.Input.Slider.H.Normal          = GWEN.CreateTextureNormal(416, 32, 15, 15)
SKIN.tex.Input.Slider.H.Hover           = GWEN.CreateTextureNormal(416, 32 + 16, 15, 15)
SKIN.tex.Input.Slider.H.Down            = GWEN.CreateTextureNormal(416, 32 + 32, 15, 15)
SKIN.tex.Input.Slider.H.Disabled        = GWEN.CreateTextureNormal(416, 32 + 48, 15, 15)

SKIN.tex.Input.Slider.V = {}
SKIN.tex.Input.Slider.V.Normal          = GWEN.CreateTextureNormal(416 + 16, 32, 15, 15)
SKIN.tex.Input.Slider.V.Hover           = GWEN.CreateTextureNormal(416 + 16, 32 + 16, 15, 15)
SKIN.tex.Input.Slider.V.Down            = GWEN.CreateTextureNormal(416 + 16, 32 + 32, 15, 15)
SKIN.tex.Input.Slider.V.Disabled        = GWEN.CreateTextureNormal(416 + 16, 32 + 48, 15, 15)

SKIN.tex.Input.ListBox = {}
SKIN.tex.Input.ListBox.Background           = GWEN.CreateTextureBorder(256, 256, 63, 127, 8, 8, 8, 8)
SKIN.tex.Input.ListBox.Hovered          = GWEN.CreateTextureBorder(320, 320, 31, 31, 8, 8, 8, 8)
SKIN.tex.Input.ListBox.EvenLine         = GWEN.CreateTextureBorder(352, 256, 31, 31, 8, 8, 8, 8)
SKIN.tex.Input.ListBox.OddLine          = GWEN.CreateTextureBorder(352, 288, 31, 31, 8, 8, 8, 8)
SKIN.tex.Input.ListBox.EvenLineSelected         = GWEN.CreateTextureBorder(320, 270, 31, 31, 8, 8, 8, 8)
SKIN.tex.Input.ListBox.OddLineSelected          = GWEN.CreateTextureBorder(320, 288, 31, 31, 8, 8, 8, 8)

SKIN.tex.ProgressBar = {}
SKIN.tex.ProgressBar.Back       = GWEN.CreateTextureBorder(384, 0, 31, 31, 8, 8, 8, 8)
SKIN.tex.ProgressBar.Front      = GWEN.CreateTextureBorder(384 + 32, 0, 31, 31, 8, 8, 8, 8)


SKIN.tex.CategoryList = {}
SKIN.tex.CategoryList.Outer     = GWEN.CreateTextureBorder(256, 384, 63, 63, 8, 8, 8, 8)
SKIN.tex.CategoryList.Inner     = GWEN.CreateTextureBorder(256 + 64, 384, 63, 63, 8, 21, 8, 8)
SKIN.tex.CategoryList.Header    = GWEN.CreateTextureBorder(320, 352, 63, 31, 8, 8, 8, 8)

SKIN.tex.Tooltip                = GWEN.CreateTextureBorder(384, 64, 31, 31, 8, 8, 8, 8)

SKIN.Colours = {}

SKIN.Colours.Window = {}
SKIN.Colours.Window.TitleActive         = GWEN.TextureColor(4 + 8 * 0, 508)
SKIN.Colours.Window.TitleInactive       = GWEN.TextureColor(4 + 8 * 1, 508)

SKIN.Colours.Button = {}
SKIN.Colours.Button.Normal              = GWEN.TextureColor(4 + 8 * 2, 508)
SKIN.Colours.Button.Hover               = GWEN.TextureColor(4 + 8 * 3, 508)
SKIN.Colours.Button.Down                = GWEN.TextureColor(4 + 8 * 2, 500)
SKIN.Colours.Button.Disabled            = GWEN.TextureColor(4 + 8 * 3, 500)

SKIN.Colours.Tab = {}
SKIN.Colours.Tab.Active = {}
SKIN.Colours.Tab.Active.Normal          = GWEN.TextureColor(4 + 8 * 4, 508)
SKIN.Colours.Tab.Active.Hover           = GWEN.TextureColor(4 + 8 * 5, 508)
SKIN.Colours.Tab.Active.Down            = GWEN.TextureColor(4 + 8 * 4, 500)
SKIN.Colours.Tab.Active.Disabled        = GWEN.TextureColor(4 + 8 * 5, 500)

SKIN.Colours.Tab.Inactive = {}
SKIN.Colours.Tab.Inactive.Normal        = GWEN.TextureColor(4 + 8 * 6, 508)
SKIN.Colours.Tab.Inactive.Hover         = GWEN.TextureColor(4 + 8 * 7, 508)
SKIN.Colours.Tab.Inactive.Down          = GWEN.TextureColor(4 + 8 * 6, 500)
SKIN.Colours.Tab.Inactive.Disabled      = GWEN.TextureColor(4 + 8 * 7, 500)

SKIN.Colours.Label = {}
SKIN.Colours.Label.Default              = GWEN.TextureColor(4 + 8 * 8, 508)
SKIN.Colours.Label.Bright               = GWEN.TextureColor(4 + 8 * 9, 508)
SKIN.Colours.Label.Dark                 = GWEN.TextureColor(4 + 8 * 8, 500)
SKIN.Colours.Label.Highlight            = GWEN.TextureColor(4 + 8 * 9, 500)

SKIN.Colours.Tree = {}
SKIN.Colours.Tree.Lines                 = GWEN.TextureColor(4 + 8 * 10, 508)
---- !!!
SKIN.Colours.Tree.Normal                = GWEN.TextureColor(4 + 8 * 11, 508)
SKIN.Colours.Tree.Hover                 = GWEN.TextureColor(4 + 8 * 10, 500)
SKIN.Colours.Tree.Selected              = GWEN.TextureColor(4 + 8 * 11, 500)

SKIN.Colours.Properties = {}
SKIN.Colours.Properties.Line_Normal         = GWEN.TextureColor(4 + 8 * 12, 508)
SKIN.Colours.Properties.Line_Selected       = GWEN.TextureColor(4 + 8 * 13, 508)
SKIN.Colours.Properties.Line_Hover          = GWEN.TextureColor(4 + 8 * 12, 500)
SKIN.Colours.Properties.Title               = GWEN.TextureColor(4 + 8 * 13, 500)
SKIN.Colours.Properties.Column_Normal       = GWEN.TextureColor(4 + 8 * 14, 508)
SKIN.Colours.Properties.Column_Selected     = GWEN.TextureColor(4 + 8 * 15, 508)
SKIN.Colours.Properties.Column_Hover        = GWEN.TextureColor(4 + 8 * 14, 500)
SKIN.Colours.Properties.Border              = GWEN.TextureColor(4 + 8 * 15, 500)
SKIN.Colours.Properties.Label_Normal        = GWEN.TextureColor(4 + 8 * 16, 508)
SKIN.Colours.Properties.Label_Selected      = GWEN.TextureColor(4 + 8 * 17, 508)
SKIN.Colours.Properties.Label_Hover         = GWEN.TextureColor(4 + 8 * 16, 500)

SKIN.Colours.Category = {}
SKIN.Colours.Category.Header                = GWEN.TextureColor(4 + 8 * 18, 500)
SKIN.Colours.Category.Header_Closed         = GWEN.TextureColor(4 + 8 * 19, 500)
SKIN.Colours.Category.Line = {}
SKIN.Colours.Category.Line.Text             = GWEN.TextureColor(4 + 8 * 20, 508)
SKIN.Colours.Category.Line.Text_Hover       = GWEN.TextureColor(4 + 8 * 21, 508)
SKIN.Colours.Category.Line.Text_Selected    = GWEN.TextureColor(4 + 8 * 20, 500)
SKIN.Colours.Category.Line.Button           = GWEN.TextureColor(4 + 8 * 21, 500)
SKIN.Colours.Category.Line.Button_Hover     = GWEN.TextureColor(4 + 8 * 22, 508)
SKIN.Colours.Category.Line.Button_Selected  = GWEN.TextureColor(4 + 8 * 23, 508)
SKIN.Colours.Category.LineAlt = {}
SKIN.Colours.Category.LineAlt.Text              = GWEN.TextureColor(4 + 8 * 22, 500)
SKIN.Colours.Category.LineAlt.Text_Hover        = GWEN.TextureColor(4 + 8 * 23, 500)
SKIN.Colours.Category.LineAlt.Text_Selected     = GWEN.TextureColor(4 + 8 * 24, 508)
SKIN.Colours.Category.LineAlt.Button            = GWEN.TextureColor(4 + 8 * 25, 508)
SKIN.Colours.Category.LineAlt.Button_Hover      = GWEN.TextureColor(4 + 8 * 24, 500)
SKIN.Colours.Category.LineAlt.Button_Selected   = GWEN.TextureColor(4 + 8 * 25, 500)

derma.DefineSkin("DarkRP", "The official SKIN for DarkRP", SKIN)

--PATH gamemodes/starwarsrp/gamemode/modules/darkrpmessages/cl_darkrpmessage.lua:
local MotdMessage =
[[


---------------------------------------------------------------------------
            DarkRP Message of the day!
---------------------------------------------------------------------------
]]

local endMOTD = "---------------------------------------------------------------------------\n"

local function drawMOTD(text)
    MsgC(Color(255, 20, 20, 255), MotdMessage, color_white, text, Color(255, 20, 20, 255), endMOTD)
end

local function receiveMOTD(html, len, headers, code)
    if not headers or headers.Status and string.sub(headers.Status, 1, 3) ~= "200" then return end
    drawMOTD(html)
end

local function showMOTD()
    http.Fetch("https://raw.githubusercontent.com/FPtje/DarkRPMotd/master/motd.txt", receiveMOTD, fn.Id)
end
timer.Simple(5, showMOTD)

concommand.Add("DarkRP_motd", showMOTD)

--PATH gamemodes/starwarsrp/gamemode/modules/base/sh_gamemode_functions.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/gamemode/modules/base/sh_createitems.lua:
local plyMeta = FindMetaTable("Player")

-----------------------------------------------------------
-- Job commands --
-----------------------------------------------------------
local function declareTeamCommands(CTeam)
    local k = 0
    for num, v in pairs(RPExtraTeams) do
        if v.command == CTeam.command then
            k = num
        end
    end

    local chatcommandCondition = function(ply)
        local plyTeam = ply:Team()

        if plyTeam == k then return false end
        if CTeam.admin == 1 and not ply:IsAdmin() or CTeam.admin == 2 and not ply:IsSuperAdmin() then return false end
        if isnumber(CTeam.NeedToChangeFrom) and plyTeam ~= CTeam.NeedToChangeFrom then return false end
        if istable(CTeam.NeedToChangeFrom) and not table.HasValue(CTeam.NeedToChangeFrom, plyTeam) then return false end
        if CTeam.customCheck and CTeam.customCheck(ply) == false then return false end
        if ply:isArrested() then return false end
        local numPlayers = team.NumPlayers(k)
        if CTeam.max ~= 0 and ((CTeam.max % 1 == 0 and numPlayers >= CTeam.max) or (CTeam.max % 1 ~= 0 and (numPlayers + 1) / player.GetCount() > CTeam.max)) then return false end
        if ply.LastJob and 10 - (CurTime() - ply.LastJob) >= 0 then return false end
        if ply.LastVoteCop and CurTime() - ply.LastVoteCop < 80 then return false end

        return true
    end

    if CTeam.vote or CTeam.RequiresVote then
        DarkRP.declareChatCommand{
            command = "vote" .. CTeam.command,
            description = "Vote to become " .. CTeam.name .. ".",
            delay = 1.5,
            condition =
                function(ply)
                    if CTeam.RequiresVote and not CTeam.RequiresVote(ply, k) then return false end
                    if CTeam.canStartVote and not CTeam.canStartVote(ply) then return false end

                    return chatcommandCondition(ply)
                end
        }

        DarkRP.declareChatCommand{
            command = CTeam.command,
            description = "Become " .. CTeam.name .. " and skip the vote.",
            delay = 1.5,
            condition =
                function(ply)
                    local requiresVote = CTeam.RequiresVote and CTeam.RequiresVote(ply, k)

                    if requiresVote then return false end
                    if requiresVote ~= false and CTeam.admin == 0 and not ply:IsAdmin() or CTeam.admin == 1 and not ply:IsSuperAdmin() then return false end
                    if CTeam.canStartVote and not CTeam.canStartVote(ply) then return false end

                    return chatcommandCondition(ply)
                end
        }
    else
        DarkRP.declareChatCommand{
            command = CTeam.command,
            description = "Become " .. CTeam.name .. ".",
            delay = 1.5,
            condition = chatcommandCondition
        }
    end
end

local function addTeamCommands(CTeam, max)
    if CLIENT then return end

    local k = 0
    for num, v in pairs(RPExtraTeams) do
        if v.command == CTeam.command then
            k = num
        end
    end

    if CTeam.vote or CTeam.RequiresVote then
        DarkRP.defineChatCommand("vote" .. CTeam.command, function(ply)
            if CTeam.RequiresVote and not CTeam.RequiresVote(ply, k) then
                DarkRP.notify(ply, 1, 4, DarkRP.getPhrase("job_doesnt_require_vote_currently"))

                return ""
            end

            if CTeam.canStartVote and not CTeam.canStartVote(ply) then
                local reason = isfunction(CTeam.canStartVoteReason) and CTeam.canStartVoteReason(ply, CTeam) or CTeam.canStartVoteReason or ""
                DarkRP.notify(ply, 1, 4, DarkRP.getPhrase("unable", "/vote" .. CTeam.command, reason))

                return ""
            end

            if CTeam.admin == 1 and not ply:IsAdmin() then
                DarkRP.notify(ply, 1, 4, DarkRP.getPhrase("need_admin", "/" .. "vote" .. CTeam.command))

                return ""
            elseif CTeam.admin > 1 and not ply:IsSuperAdmin() then
                DarkRP.notify(ply, 1, 4, DarkRP.getPhrase("need_sadmin", "/" .. "vote" .. CTeam.command))

                return ""
            end

            if isnumber(CTeam.NeedToChangeFrom) and ply:Team() ~= CTeam.NeedToChangeFrom then
                DarkRP.notify(ply, 1, 4, DarkRP.getPhrase("need_to_be_before", team.GetName(CTeam.NeedToChangeFrom), CTeam.name))

                return ""
            elseif istable(CTeam.NeedToChangeFrom) and not table.HasValue(CTeam.NeedToChangeFrom, ply:Team()) then
                local teamnames = ""

                for _, b in pairs(CTeam.NeedToChangeFrom) do
                    teamnames = teamnames .. " or " .. team.GetName(b)
                end

                DarkRP.notify(ply, 1, 4, DarkRP.getPhrase("need_to_be_before", string.sub(teamnames, 5), CTeam.name))

                return ""
            end

            if CTeam.customCheck and not CTeam.customCheck(ply) then
                local message = isfunction(CTeam.CustomCheckFailMsg) and CTeam.CustomCheckFailMsg(ply, CTeam) or CTeam.CustomCheckFailMsg or DarkRP.getPhrase("unable", team.GetName(t), "")
                DarkRP.notify(ply, 1, 4, message)

                return ""
            end

            local allowed, time = ply:changeAllowed(k)
            if not allowed then
                local notif = time and DarkRP.getPhrase("have_to_wait", math.ceil(time), "/job, " .. DarkRP.getPhrase("banned_or_demoted")) or DarkRP.getPhrase("unable", team.GetName(k), DarkRP.getPhrase("banned_or_demoted"))
                DarkRP.notify(ply, 1, 4, notif)

                return ""
            end

            if ply:Team() == k then
                DarkRP.notify(ply, 1, 4, DarkRP.getPhrase("unable", CTeam.command, ""))

                return ""
            end

            local numPlayers = team.NumPlayers(k)
            if max ~= 0 and ((max % 1 == 0 and numPlayers >= max) or (max % 1 ~= 0 and (tnumPlayers + 1) / player.GetCount() > max)) then
                DarkRP.notify(ply, 1, 4, DarkRP.getPhrase("team_limit_reached", CTeam.name))

                return ""
            end

            if ply.LastJob and 10 - (CurTime() - ply.LastJob) >= 0 then
                DarkRP.notify(ply, 1, 4, DarkRP.getPhrase("have_to_wait", math.ceil(10 - (CurTime() - ply.LastJob)), GAMEMODE.Config.chatCommandPrefix .. CTeam.command))

                return ""
            end

            ply.LastVoteCop = ply.LastVoteCop or -80

            if CurTime() - ply.LastVoteCop < 80 then
                DarkRP.notify(ply, 1, 4, DarkRP.getPhrase("have_to_wait", math.ceil(80 - (CurTime() - ply:GetTable().LastVoteCop)), GAMEMODE.Config.chatCommandPrefix .. CTeam.command))

                return ""
            end

            DarkRP.createVote(DarkRP.getPhrase("wants_to_be", ply:Nick(), CTeam.name), "job", ply, 20, function(vote, choice)
                local target = vote.target
                if not IsValid(target) then return end

                if choice >= 0 then
                    target:changeTeam(k)
                else
                    DarkRP.notifyAll(1, 4, DarkRP.getPhrase("has_not_been_made_team", target:Nick(), CTeam.name))
                end
            end, nil, nil, {
                targetTeam = k
            })

            ply.LastVoteCop = CurTime()

            return ""
        end)

        local function onJobCommand(ply, hasPriv)
            if hasPriv then
                ply:changeTeam(k)
                return
            end

            local a = CTeam.admin
            if a > 0 and not ply:IsAdmin()
            or a > 1 and not ply:IsSuperAdmin()
            then
                DarkRP.notify(ply, 1, 4, DarkRP.getPhrase("need_admin", CTeam.name))
                return
            end

            if not CTeam.RequiresVote and
                (a == 0 and not ply:IsAdmin()
                or a == 1 and not ply:IsSuperAdmin()
                or a == 2)
            or CTeam.RequiresVote and CTeam.RequiresVote(ply, k)
            then
                DarkRP.notify(ply, 1, 4, DarkRP.getPhrase("need_to_make_vote", CTeam.name))
                return
            end

            ply:changeTeam(k)
        end
        DarkRP.defineChatCommand(CTeam.command, function(ply)
            CAMI.PlayerHasAccess(ply, "DarkRP_GetJob_" .. CTeam.command, fp{onJobCommand, ply})

            return ""
        end)
    else
        DarkRP.defineChatCommand(CTeam.command, function(ply)
            if CTeam.admin == 1 and not ply:IsAdmin() then
                DarkRP.notify(ply, 1, 4, DarkRP.getPhrase("need_admin", "/" .. CTeam.command))

                return ""
            end

            if CTeam.admin > 1 and not ply:IsSuperAdmin() then
                DarkRP.notify(ply, 1, 4, DarkRP.getPhrase("need_sadmin", "/" .. CTeam.command))

                return ""
            end

            ply:changeTeam(k)

            return ""
        end)
    end

    concommand.Add("rp_" .. CTeam.command, function(ply, cmd, args)
        if ply:EntIndex() ~= 0 and not ply:IsAdmin() then
            ply:PrintMessage(HUD_PRINTCONSOLE, DarkRP.getPhrase("need_admin", cmd))
            return
        end

        if CTeam.admin > 1 and not ply:IsSuperAdmin() and ply:EntIndex() ~= 0 then
            ply:PrintMessage(HUD_PRINTCONSOLE, DarkRP.getPhrase("need_sadmin", cmd))
            return
        end

        if CTeam.vote then
            if CTeam.admin >= 1 and ply:EntIndex() ~= 0 and not ply:IsSuperAdmin() then
                ply:PrintMessage(HUD_PRINTCONSOLE, DarkRP.getPhrase("need_sadmin", cmd))
                return
            elseif CTeam.admin > 1 and ply:IsSuperAdmin() and ply:EntIndex() ~= 0 then
                ply:PrintMessage(HUD_PRINTCONSOLE, DarkRP.getPhrase("need_to_make_vote", CTeam.name))
                return
            end
        end

        if not args or not args[1] then
            DarkRP.printConsoleMessage(ply, DarkRP.getPhrase("invalid_x", DarkRP.getPhrase("arguments"), ""))
            return
        end

        local target = DarkRP.findPlayer(args[1])

        if not target then
            DarkRP.printConsoleMessage(ply, DarkRP.getPhrase("could_not_find", tostring(args[1])))
            return
        end

        target:changeTeam(k, true)
        local nick
        if (ply:EntIndex() ~= 0) then
            nick = ply:Nick()
        else
            nick = "Console"
        end
        DarkRP.notify(target, 0, 4, DarkRP.getPhrase("x_made_you_a_y", nick, CTeam.name))
    end)
end

local function addEntityCommands(tblEnt)
    DarkRP.declareChatCommand{
        command = tblEnt.cmd,
        description = "Purchase a " .. tblEnt.name,
        delay = tblEnt.delay or GAMEMODE.Config.EntitySpamTime,
        condition =
            function(ply)
                if not tblEnt.allowPurchaseWhileDead and not ply:Alive() then return false end
                if ply:isArrested() then return false end
                if istable(tblEnt.allowed) and not table.HasValue(tblEnt.allowed, ply:Team()) then return false end
                if not ply:canAfford(tblEnt.price) then return false end
                if tblEnt.customCheck and tblEnt.customCheck(ply) == false then return false end

                return true
            end
    }

    if CLIENT then return end

    -- Default spawning function of an entity
    -- used if tblEnt.spawn is not defined
    local function defaultSpawn(ply, tr, tblE)
        local ent = ents.Create(tblE.ent)

        if not ent:IsValid() then error("Entity '" .. tblE.ent .. "' does not exist or is not valid.") end
        if ent.Setowning_ent then ent:Setowning_ent(ply) end

        ent:SetPos(tr.HitPos)
        -- These must be set before :Spawn()
        ent.SID = ply.SID
        ent.allowed = tblE.allowed
        ent.DarkRPItem = tblE
        ent:Spawn()
        ent:Activate()

        DarkRP.placeEntity(ent, tr, ply)

        local phys = ent:GetPhysicsObject()
        if phys:IsValid() then phys:Wake() end

        return ent
    end

    local function buythis(ply, args)
        if ply:isArrested() then return "" end
        if not tblEnt.allowPurchaseWhileDead and not ply:Alive() then
            DarkRP.notify(ply, 1, 4, DarkRP.getPhrase("must_be_alive_to_do_x", DarkRP.getPhrase("buy_x", tblEnt.name)))
            return ""
        end
        if istable(tblEnt.allowed) and not table.HasValue(tblEnt.allowed, ply:Team()) then
            DarkRP.notify(ply, 1, 4, DarkRP.getPhrase("incorrect_job", tblEnt.name))
            return ""
        end

        if tblEnt.customCheck and not tblEnt.customCheck(ply) then
            local message = isfunction(tblEnt.CustomCheckFailMsg) and tblEnt.CustomCheckFailMsg(ply, tblEnt) or
                tblEnt.CustomCheckFailMsg or
                DarkRP.getPhrase("not_allowed_to_purchase")
            DarkRP.notify(ply, 1, 4, message)
            return ""
        end

        if ply:customEntityLimitReached(tblEnt) then
            DarkRP.notify(ply, 1, 4, DarkRP.getPhrase("limit", tblEnt.name))
            return ""
        end

        local canbuy, suppress, message, price = hook.Call("canBuyCustomEntity", nil, ply, tblEnt)

        local cost = price or tblEnt.getPrice and tblEnt.getPrice(ply, tblEnt.price) or tblEnt.price

        if not ply:canAfford(cost) then
            DarkRP.notify(ply, 1, 4, DarkRP.getPhrase("cant_afford", tblEnt.name))
            return ""
        end

        if canbuy == false then
            if not suppress and message then DarkRP.notify(ply, 1, 4, message) end
            return ""
        end

        ply:addMoney(-cost)

        local trace = {}
        trace.start = ply:EyePos()
        trace.endpos = trace.start + ply:GetAimVector() * 85
        trace.filter = ply

        local tr = util.TraceLine(trace)

        local ent = (tblEnt.spawn or defaultSpawn)(ply, tr, tblEnt)
        ent.onlyremover = not tblEnt.allowTools
        -- Repeat these properties to alleviate work in tblEnt.spawn:
        ent.SID = ply.SID
        ent.allowed = tblEnt.allowed
        ent.DarkRPItem = tblEnt

        hook.Call("playerBoughtCustomEntity", nil, ply, tblEnt, ent, cost)

        if cost == 0 then
            DarkRP.notify(ply, 0, 4, DarkRP.getPhrase("you_got_yourself", tblEnt.name))
        else
            DarkRP.notify(ply, 0, 4, DarkRP.getPhrase("you_bought", tblEnt.name, DarkRP.formatMoney(cost), ""))
        end

        ply:addCustomEntity(tblEnt)
        return ""
    end
    DarkRP.defineChatCommand(tblEnt.cmd, buythis)
end

RPExtraTeams = {}
local jobByCmd = {}
DarkRP.getJobByCommand = function(cmd)
    if not jobByCmd[cmd] then return nil, nil end
    return RPExtraTeams[jobByCmd[cmd]], jobByCmd[cmd]
end
plyMeta.getJobTable = function(ply)
    local tbl = RPExtraTeams[ply:Team()]
    -- don't error when the player has not fully joined yet
    if not tbl and (ply.DarkRPInitialised or ply.DarkRPDataRetrievalFailed) then
        DarkRP.error(
            string.format("There is a player with an invalid team!\n\nThe player's name is %s, their team number is \"%s\", which has the name \"%s\"",
                ply:EntIndex() == 0 and "Console" or IsValid(ply) and ply:Nick() or "unknown",
                ply:Team(),
                team.GetName(ply:Team())),
            1,
            {
                "It is the server owner's responsibility to figure out why that player has no valid team.",
                "This error is very likely to be caused by an earlier error. If you don't see any errors in your own console, look at the server console."
            }
        )
    end
    return tbl
end

function DarkRP.createJob(Name, colorOrTable, model, Description, Weapons, command, maximum_amount_of_this_class, Salary, admin, Vote, Haslicense, NeedToChangeFrom, CustomCheck)
    local tableSyntaxUsed = not IsColor(colorOrTable)

    local CustomTeam = tableSyntaxUsed and colorOrTable or
        {color = colorOrTable, model = model, description = Description, weapons = Weapons, command = command,
            max = maximum_amount_of_this_class, salary = Salary, admin = admin or 0, vote = tobool(Vote), hasLicense = Haslicense,
            NeedToChangeFrom = NeedToChangeFrom, customCheck = CustomCheck
        }
    CustomTeam.name = Name
    CustomTeam.default = DarkRP.DARKRP_LOADING

    -- Disabled job
    if DarkRP.DARKRP_LOADING and DarkRP.disabledDefaults["jobs"][CustomTeam.command] then return end

    local valid, err, hints = DarkRP.validateJob(CustomTeam)
    if not valid then DarkRP.error(string.format("Corrupt team: %s!\n%s", CustomTeam.name or "", err), 2, hints) end

    if not (GM or GAMEMODE):CustomObjFitsMap(CustomTeam) then return end

    local jobCount = #RPExtraTeams + 1

    CustomTeam.team = jobCount

    CustomTeam.salary = math.floor(CustomTeam.salary)

    CustomTeam.customCheck           = CustomTeam.customCheck           and fp{DarkRP.simplerrRun, CustomTeam.customCheck}
    CustomTeam.CustomCheckFailMsg = isfunction(CustomTeam.CustomCheckFailMsg) and fp{DarkRP.simplerrRun, CustomTeam.CustomCheckFailMsg} or CustomTeam.CustomCheckFailMsg
    CustomTeam.CanPlayerSuicide      = CustomTeam.CanPlayerSuicide      and fp{DarkRP.simplerrRun, CustomTeam.CanPlayerSuicide}
    CustomTeam.PlayerCanPickupWeapon = CustomTeam.PlayerCanPickupWeapon and fp{DarkRP.simplerrRun, CustomTeam.PlayerCanPickupWeapon}
    CustomTeam.PlayerDeath           = CustomTeam.PlayerDeath           and fp{DarkRP.simplerrRun, CustomTeam.PlayerDeath}
    CustomTeam.PlayerLoadout         = CustomTeam.PlayerLoadout         and fp{DarkRP.simplerrRun, CustomTeam.PlayerLoadout}
    CustomTeam.PlayerSelectSpawn     = CustomTeam.PlayerSelectSpawn     and fp{DarkRP.simplerrRun, CustomTeam.PlayerSelectSpawn}
    CustomTeam.PlayerSetModel        = CustomTeam.PlayerSetModel        and fp{DarkRP.simplerrRun, CustomTeam.PlayerSetModel}
    CustomTeam.PlayerSpawn           = CustomTeam.PlayerSpawn           and fp{DarkRP.simplerrRun, CustomTeam.PlayerSpawn}
    CustomTeam.PlayerSpawnProp       = CustomTeam.PlayerSpawnProp       and fp{DarkRP.simplerrRun, CustomTeam.PlayerSpawnProp}
    CustomTeam.RequiresVote          = CustomTeam.RequiresVote          and fp{DarkRP.simplerrRun, CustomTeam.RequiresVote}
    CustomTeam.ShowSpare1            = CustomTeam.ShowSpare1            and fp{DarkRP.simplerrRun, CustomTeam.ShowSpare1}
    CustomTeam.ShowSpare2            = CustomTeam.ShowSpare2            and fp{DarkRP.simplerrRun, CustomTeam.ShowSpare2}
    CustomTeam.canStartVote          = CustomTeam.canStartVote          and fp{DarkRP.simplerrRun, CustomTeam.canStartVote}

    jobByCmd[CustomTeam.command] = table.insert(RPExtraTeams, CustomTeam)
    DarkRP.addToCategory(CustomTeam, "jobs", CustomTeam.category)

    team.SetUp(jobCount, Name, CustomTeam.color)

    timer.Simple(0, function()
        declareTeamCommands(CustomTeam)
        addTeamCommands(CustomTeam, CustomTeam.max)
    end)

    -- Precache model here. Not right before the job change is done
    if istable(CustomTeam.model) then
        for _, v in pairs(CustomTeam.model) do util.PrecacheModel(v) end
    else
        util.PrecacheModel(CustomTeam.model)
    end
    return jobCount
end
AddExtraTeam = DarkRP.createJob

local function removeCustomItem(tbl, category, hookName, reloadF4, i)
    local item = tbl[i]
    tbl[i] = nil
    if category then DarkRP.removeFromCategory(item, category) end
    if istable(item) and (item.command or item.cmd) then DarkRP.removeChatCommand(item.command or item.cmd) end
    hook.Run(hookName, i, item)
    if CLIENT and reloadF4 and IsValid(DarkRP.getF4MenuPanel()) then DarkRP.getF4MenuPanel():Remove() end -- Rebuild entire F4 menu frame
end

function DarkRP.removeJob(i)
    local job = RPExtraTeams[i]
    jobByCmd[job.command] = nil

    DarkRP.removeChatCommand("vote" .. job.command)
    removeCustomItem(RPExtraTeams, "jobs", "onJobRemoved", true, i)
end

RPExtraTeamDoors = {}
RPExtraTeamDoorIDs = {}
local maxTeamDoorID = 0
function DarkRP.createEntityGroup(name, ...)
    if DarkRP.DARKRP_LOADING and DarkRP.disabledDefaults["doorgroups"][name] then return end
    RPExtraTeamDoors[name] = {...}
    RPExtraTeamDoors[name].name = name

    maxTeamDoorID = maxTeamDoorID + 1
    RPExtraTeamDoorIDs[name] = maxTeamDoorID
end
AddDoorGroup = DarkRP.createEntityGroup

DarkRP.removeEntityGroup = fp{removeCustomItem, RPExtraTeamDoors, nil, "onEntityGroupRemoved", false}

CustomVehicles = {}
CustomShipments = {}
local shipByName = {}
DarkRP.getShipmentByName = function(name)
    name = string.lower(name or "")

    if not shipByName[name] then return nil, nil end
    return CustomShipments[shipByName[name]], shipByName[name]
end

function DarkRP.createShipment(name, model, entity, price, Amount_of_guns_in_one_shipment, Sold_separately, price_separately, noshipment, classes, shipmodel, CustomCheck)
    local tableSyntaxUsed = istable(model)

    price = tonumber(price)
    local shipmentmodel = shipmodel or "models/Items/item_item_crate.mdl"

    local customShipment = tableSyntaxUsed and model or
        {model = model, entity = entity, price = price, amount = Amount_of_guns_in_one_shipment,
        seperate = Sold_separately, pricesep = price_separately, noship = noshipment, allowed = classes,
        shipmodel = shipmentmodel, customCheck = CustomCheck, weight = 5}

    -- The pains of backwards compatibility when dealing with ancient spelling errors...
    if customShipment.separate ~= nil then
        customShipment.seperate = customShipment.separate
    end
    customShipment.separate = customShipment.seperate

    if customShipment.allowed == nil then
        customShipment.allowed = {}
        for k in pairs(team.GetAllTeams()) do
            table.insert(customShipment.allowed, k)
        end
    end

    customShipment.name = name
    customShipment.default = DarkRP.DARKRP_LOADING
    customShipment.shipmodel = customShipment.shipmodel or shipmentmodel

    if DarkRP.DARKRP_LOADING and DarkRP.disabledDefaults["shipments"][customShipment.name] then return end

    local valid, err, hints = DarkRP.validateShipment(customShipment)
    if not valid then DarkRP.error(string.format("Corrupt shipment: %s!\n%s", name or "", err), 2, hints) end

    customShipment.spawn = customShipment.spawn and fp{DarkRP.simplerrRun, customShipment.spawn}
    customShipment.allowed = isnumber(customShipment.allowed) and {customShipment.allowed} or customShipment.allowed
    customShipment.customCheck = customShipment.customCheck   and fp{DarkRP.simplerrRun, customShipment.customCheck}
    customShipment.CustomCheckFailMsg = isfunction(customShipment.CustomCheckFailMsg) and fp{DarkRP.simplerrRun, customShipment.CustomCheckFailMsg} or customShipment.CustomCheckFailMsg

    if not customShipment.noship then DarkRP.addToCategory(customShipment, "shipments", customShipment.category) end
    if customShipment.separate then DarkRP.addToCategory(customShipment, "weapons", customShipment.category) end

    shipByName[string.lower(name or "")] = table.insert(CustomShipments, customShipment)
    util.PrecacheModel(customShipment.model)
end
AddCustomShipment = DarkRP.createShipment

function DarkRP.removeShipment(i)
    local ship = CustomShipments[i]
    shipByName[ship.name] = nil
    removeCustomItem(CustomShipments, "shipments", "onShipmentRemoved", true, i)
end

function DarkRP.createVehicle(Name_of_vehicle, model, price, Jobs_that_can_buy_it, customcheck)
    local vehicle = istable(Name_of_vehicle) and Name_of_vehicle or
        {name = Name_of_vehicle, model = model, price = price, allowed = Jobs_that_can_buy_it, customCheck = customcheck}

    vehicle.default = DarkRP.DARKRP_LOADING

    if DarkRP.DARKRP_LOADING and DarkRP.disabledDefaults["vehicles"][vehicle.name] then return end

    local found = false
    for k in pairs(DarkRP.getAvailableVehicles()) do
        if string.lower(k) == string.lower(vehicle.name) then found = true break end
    end

    local valid, err, hints = DarkRP.validateVehicle(vehicle)
    if not valid then DarkRP.error(string.format("Corrupt vehicle: %s!\n%s", vehicle.name or "", err), 2, hints) end

    if not found then DarkRP.error("Vehicle invalid: " .. vehicle.name .. ". Unknown vehicle name.", 2) end

    vehicle.customCheck = vehicle.customCheck and fp{DarkRP.simplerrRun, vehicle.customCheck}
    vehicle.CustomCheckFailMsg = isfunction(vehicle.CustomCheckFailMsg) and fp{DarkRP.simplerrRun, vehicle.CustomCheckFailMsg} or vehicle.CustomCheckFailMsg

    table.insert(CustomVehicles, vehicle)
    DarkRP.addToCategory(vehicle, "vehicles", vehicle.category)
end
AddCustomVehicle = DarkRP.createVehicle

DarkRP.removeVehicle = fp{removeCustomItem, CustomVehicles, "vehicles", "onVehicleRemoved", true}

--[[---------------------------------------------------------------------------
Decides whether a custom job or shipmet or whatever can be used in a certain map
---------------------------------------------------------------------------]]
function GM:CustomObjFitsMap(obj)
    if not obj or not obj.maps then return true end

    local map = string.lower(game.GetMap())
    for _, v in pairs(obj.maps) do
        if string.lower(v) == map then return true end
    end
    return false
end

DarkRPEntities = {}
function DarkRP.createEntity(name, entity, model, price, max, command, classes, CustomCheck)
    local tableSyntaxUsed = istable(entity)

    local tblEnt = tableSyntaxUsed and entity or
        {ent = entity, model = model, price = price, max = max,
        cmd = command, allowed = classes, customCheck = CustomCheck}
    tblEnt.name = name
    tblEnt.default = DarkRP.DARKRP_LOADING

    if DarkRP.DARKRP_LOADING and DarkRP.disabledDefaults["entities"][tblEnt.name] then return end

    if isnumber(tblEnt.allowed) then
        tblEnt.allowed = {tblEnt.allowed}
    end

    local valid, err, hints = DarkRP.validateEntity(tblEnt)
    if not valid then DarkRP.error(string.format("Corrupt entity: %s!\n%s", name or "", err), 2, hints) end

    tblEnt.customCheck = tblEnt.customCheck and fp{DarkRP.simplerrRun, tblEnt.customCheck}
    tblEnt.CustomCheckFailMsg = isfunction(tblEnt.CustomCheckFailMsg) and fp{DarkRP.simplerrRun, tblEnt.CustomCheckFailMsg} or tblEnt.CustomCheckFailMsg
    tblEnt.getPrice    = tblEnt.getPrice    and fp{DarkRP.simplerrRun, tblEnt.getPrice}
    tblEnt.getMax      = tblEnt.getMax      and fp{DarkRP.simplerrRun, tblEnt.getMax}
    tblEnt.spawn       = tblEnt.spawn       and fp{DarkRP.simplerrRun, tblEnt.spawn}

    -- if SERVER and FPP then
    --  FPP.AddDefaultBlocked(blockTypes, tblEnt.ent)
    -- end

    table.insert(DarkRPEntities, tblEnt)
    DarkRP.addToCategory(tblEnt, "entities", tblEnt.category)
    timer.Simple(0, function() addEntityCommands(tblEnt) end)
end
AddEntity = DarkRP.createEntity

DarkRP.removeEntity = fp{removeCustomItem, DarkRPEntities, "entities", "onEntityRemoved", true}

-- here for backwards compatibility
DarkRPAgendas = {}

local agendas = {}
-- Returns the agenda managed by the player
plyMeta.getAgenda = fn.Compose{fn.Curry(fn.Flip(fn.GetValue), 2)(DarkRPAgendas), plyMeta.Team}

-- Returns the agenda this player is member of
function plyMeta:getAgendaTable()
    return agendas[self:Team()]
end

DarkRP.getAgendas = fp{fn.Id, agendas}

function DarkRP.createAgenda(Title, Manager, Listeners)
    if DarkRP.DARKRP_LOADING and DarkRP.disabledDefaults["agendas"][Title] then return end

    local agenda = {Manager = Manager, Title = Title, Listeners = Listeners, ManagersByKey = {}}
    agenda.default = DarkRP.DARKRP_LOADING

    local valid, err, hints = DarkRP.validateAgenda(agenda)
    if not valid then DarkRP.error(string.format("Corrupt agenda: %s!\n%s", agenda.Title or "", err), 2, hints) end

    for _, v in pairs(agenda.Listeners) do
        agendas[v] = agenda
    end

    for _, v in pairs(istable(agenda.Manager) and agenda.Manager or {agenda.Manager}) do
        agendas[v] = agenda
        DarkRPAgendas[v] = agenda -- backwards compat
        agenda.ManagersByKey[v] = true
    end

    if SERVER then
        timer.Simple(0, function()
            -- Run after scripts have loaded
            agenda.text = hook.Run("agendaUpdated", nil, agenda, "")
        end)
    end
end
AddAgenda = DarkRP.createAgenda

function DarkRP.removeAgenda(title)
    local agenda
    for k, v in pairs(agendas) do
        if v.Title == title then
            agenda = v
            agendas[k] = nil
        end
    end

    for k, v in pairs(DarkRPAgendas) do
        if v.Title == title then DarkRPAgendas[k] = nil end
    end
    hook.Run("onAgendaRemoved", title, agenda)
end

GM.DarkRPGroupChats = {}
local groupChatNumber = 0
function DarkRP.createGroupChat(funcOrTeam, ...)
    local gm = GM or GAMEMODE
    gm.DarkRPGroupChats = gm.DarkRPGroupChats or {}
    if DarkRP.DARKRP_LOADING then
        groupChatNumber = groupChatNumber + 1
        if DarkRP.disabledDefaults["groupchat"][groupChatNumber] then return end
    end
    -- People can enter either functions or a list of teams as parameter(s)
    if isfunction(funcOrTeam) then
        table.insert(gm.DarkRPGroupChats, fp{DarkRP.simplerrRun, funcOrTeam})
    else
        local teams = {funcOrTeam, ...}
        table.insert(gm.DarkRPGroupChats, function(ply) return table.HasValue(teams, ply:Team()) end)
    end
end
GM.AddGroupChat = function(_, ...) DarkRP.createGroupChat(...) end

DarkRP.removeGroupChat = fp{removeCustomItem, GM.DarkRPGroupChats, nil, "onGroupChatRemoved", false}

DarkRP.getGroupChats = fp{fn.Id, GM.DarkRPGroupChats}

GM.AmmoTypes = {}

function DarkRP.createAmmoType(ammoType, name, model, price, amountGiven, customCheck)
    local gm = GM or GAMEMODE
    gm.AmmoTypes = gm.AmmoTypes or {}
    local ammo = istable(name) and name or {
        name = name,
        model = model,
        price = price,
        amountGiven = amountGiven,
        customCheck = customCheck
    }
    ammo.ammoType = ammoType
    ammo.default = DarkRP.DARKRP_LOADING

    if DarkRP.DARKRP_LOADING and DarkRP.disabledDefaults["ammo"][ammo.name] then return end

    ammo.customCheck = ammo.customCheck and fp{DarkRP.simplerrRun, ammo.customCheck}
    ammo.CustomCheckFailMsg = isfunction(ammo.CustomCheckFailMsg) and fp{DarkRP.simplerrRun, ammo.CustomCheckFailMsg} or ammo.CustomCheckFailMsg
    ammo.id = table.insert(gm.AmmoTypes, ammo)

    DarkRP.addToCategory(ammo, "ammo", ammo.category)
end
GM.AddAmmoType = function(_, ...) DarkRP.createAmmoType(...) end

DarkRP.removeAmmoType = fp{removeCustomItem, GM.AmmoTypes, "ammo", "onAmmoTypeRemoved", true}

local demoteGroups = {}
function DarkRP.createDemoteGroup(name, tbl)
    if DarkRP.DARKRP_LOADING and DarkRP.disabledDefaults["demotegroups"][name] then return end
    if not tbl or not tbl[1] then error("No members in the demote group!") end

    local set = demoteGroups[tbl[1]] or disjoint.MakeSet(tbl[1])
    set.name = name
    for i = 2, #tbl do
        set = (demoteGroups[tbl[i]] or disjoint.MakeSet(tbl[i])) + set
        set.name = name
    end

    for _, teamNr in pairs(tbl) do
        if demoteGroups[teamNr] then
            -- Unify the sets if there was already one there
            demoteGroups[teamNr] = demoteGroups[teamNr] + set
        else
            demoteGroups[teamNr] = set
        end
    end
end

function DarkRP.removeDemoteGroup(name)
    local foundSet
    for k, v in pairs(demoteGroups) do
        local set = disjoint.FindSet(v)
        if set.name == name then
            foundSet = set
            demoteGroups[k] = nil
        end
    end
    hook.Run("onDemoteGroupRemoved", name, foundSet)
end

function DarkRP.getDemoteGroup(teamNr)
    demoteGroups[teamNr] = demoteGroups[teamNr] or disjoint.MakeSet(teamNr)
    return disjoint.FindSet(demoteGroups[teamNr])
end

DarkRP.getDemoteGroups = fp{fn.Id, demoteGroups}

local categories = {
    jobs = {},
    entities = {},
    shipments = {},
    weapons = {},
    vehicles = {},
    ammo = {},
}
local categoriesMerged = false -- whether categories and custom items are merged.

DarkRP.getCategories = fp{fn.Id, categories}

local categoryOrder = function(a, b)
    local aso = a.sortOrder or 100
    local bso = b.sortOrder or 100
    return aso < bso or aso == bso and a.name < b.name
end

local function insertCategory(destination, tbl)
    -- Override existing category of applicable
    for k, cat in pairs(destination) do
        if cat.name ~= tbl.name then continue end

        destination[k] = tbl
        tbl.members = cat.members
        return
    end

    table.insert(destination, tbl)
    local i = #destination

    while i > 1 do
        if categoryOrder(destination[i - 1], tbl) then break end
        destination[i - 1], destination[i] = destination[i], destination[i - 1]
        i = i - 1
    end
end

function DarkRP.createCategory(tbl)
    local valid, err, hints = DarkRP.validateCategory(tbl)
    if not valid then DarkRP.error(string.format("Corrupt category: %s!\n%s", tbl.name or "", err), 2, hints) end
    tbl.members = {}

    local destination = categories[tbl.categorises]
    insertCategory(destination, tbl)

    -- Too many people made the mistake of not creating a category for weapons as well as shipments
    -- when having shipments that can also be sold separately.
    if tbl.categorises == "shipments" then
        insertCategory(categories.weapons, table.Copy(tbl))
    end
end

function DarkRP.addToCategory(item, kind, cat)
    cat = cat or "Other"
    item.category = cat

    -- The merge process will take care of the category:
    if not categoriesMerged then return end

    -- Post-merge: manual insertion into category
    local cats = categories[kind]
    for _, c in ipairs(cats) do
        if c.name ~= cat then continue end

        insertCategory(c.members, item)
        return
    end

    DarkRP.errorNoHalt(string.format([[The category of "%s" ("%s") does not exist!]], item.name, cat), 2, {
        "Make sure the category is created with DarkRP.createCategory.",
        "The category name is case sensitive!",
        "Categories must be created before DarkRP finished loading.",
    })
end

function DarkRP.removeFromCategory(item, kind)
    local cats = categories[kind]
    if not cats then DarkRP.error(string.format("Invalid category kind '%s'.", kind), 2) end
    local cat = item.category
    if not cat then return end
    for _, v in pairs(cats) do
        if v.name ~= item.category then continue end
        for k, mem in pairs(v.members) do
            if mem ~= item then continue end
            table.remove(v.members, k)
            break
        end
        break
    end
end

-- Assign custom stuff to their categories
local function mergeCategories(customs, catKind, path)
    local cats = categories[catKind]
    local catByName = {}
    for _, v in pairs(cats) do catByName[v.name] = v end
    for _, v in pairs(customs) do
        -- Override default thing categories:
        local catName = v.default and (GAMEMODE.Config.CategoryOverride[catKind] or {})[v.name] or v.category or "Other"
        local cat = catByName[catName]
        if not cat then
            DarkRP.errorNoHalt(string.format([[The category of "%s" ("%s") does not exist!]], v.name, catName), 3, {
                "Make sure the category is created with DarkRP.createCategory.",
                "The category name is case sensitive!",
                "Categories must be created before DarkRP finished loading."
            }, path, -1, path)
            cat = catByName.Other
        end

        cat.members = cat.members or {}
        table.insert(cat.members, v)
    end

    -- Sort category members
    for _, v in pairs(cats) do table.sort(v.members, categoryOrder) end
end

hook.Add("loadCustomDarkRPItems", "mergeCategories", function()
    local shipments = fn.Filter(fc{fn.Not, fp{fn.GetValue, "noship"}}, CustomShipments)
    local guns = fn.Filter(fp{fn.GetValue, "separate"}, CustomShipments)

    mergeCategories(RPExtraTeams, "jobs", "your jobs")
    mergeCategories(DarkRPEntities, "entities", "your custom entities")
    mergeCategories(shipments, "shipments", "your custom shipments")
    mergeCategories(guns, "weapons", "your custom weapons")
    mergeCategories(CustomVehicles, "vehicles", "your custom vehicles")
    mergeCategories(GAMEMODE.AmmoTypes, "ammo", "your custom ammo")

    categoriesMerged = true
end)

--PATH addons/!jobs/lua/darkrp_customthings/demotegroups.lua:
return gluapack()()
--PATH lua/weapons/allegiance_tool.lua:

SWEP.PrintName = "Allegiance Tool"
SWEP.Author = "Liam0102"
SWEP.Purpose = "Change the Allegiance of Star Wars Vehicles"
SWEP.Instructions = "Left Click to change Allegiance, Right Click to cycle Allegiances"
SWEP.Category = "Star Wars"
SWEP.Base = "weapon_base"
SWEP.Slot = 3
SWEP.SlotPos = 5
SWEP.DrawAmmo	= false
SWEP.DrawCrosshair = true
SWEP.ViewModel = "models/weapons/c_toolgun.mdl"
SWEP.WorldModel = "models/weapons/w_toolgun.mdl"
SWEP.AnimPrefix = "python"
SWEP.HoldType = "pistol"
SWEP.Spawnable = false
SWEP.AdminSpawnable = false
list.Set("SWVehicles.Weapons", SWEP.PrintName, SWEP);

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = true;
SWEP.Primary.Ammo	= "none"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

function SWEP:Deploy()
	self.Weapon:SendWeaponAnim(ACT_VM_DRAW); -- Animation

	return true
end

function SWEP:Initialize()
	self.Weapon:SetWeaponHoldType(self.HoldType)
	if(SERVER) then
		self:SetNWString("Allegiance",self.Allegiance)
	end
end


if CLIENT then
	
	function SWEP:Initialize()
		surface.CreateFont( "ALLEGIANCE", {
			font = "Arial",
			size = 32,
			weight = 1000,
			blursize = 0,
			scanlines = 0,
			antialias = true,
			underline = false,
			italic = false,
			strikeout = false,
			symbol = false,
			rotary = false,
			shadow = false,
			additive = false,
			outline = true,
		} )
		self.Weapon:SetWeaponHoldType(self.HoldType)
	end
	
	local Allegiance = "";
	local shouldDraw = false;
	function SWEP:Think()
		local p = LocalPlayer();
		Allegiance = self:GetNWString("Allegiance");
		
	end

	local function AllegianceToolHUD()
		local p = LocalPlayer()
		if(IsValid(p:GetActiveWeapon()) and p:GetActiveWeapon():GetClass() == "allegiance_tool") then
			surface.SetTextColor(255,255,255,255);
			surface.SetFont( "ALLEGIANCE" )
			if(SW_GetAllegiance()) then
				local tW,tH = surface.GetTextSize("Old: " .. SW_GetAllegiance())
				surface.SetTextPos(ScrW()- tW,ScrH()/10*1);
				surface.DrawText("Old: " .. SW_GetAllegiance())
			end
			surface.SetTextPos(0,ScrH()/10*1);
			surface.DrawText("New: " .. Allegiance)
		end
	end

	hook.Add("HUDPaint", "AllegianceToolHUD", AllegianceToolHUD)


	function SW_GetAllegiance()
		local p = LocalPlayer();
		local EyeTrace = p:GetEyeTrace();
		if(EyeTrace.Hit) then
			if(IsValid(EyeTrace.Entity)) then
				local e = EyeTrace.Entity;
				local class = e:GetClass();
				if(e.IsSWVehicle) then
					return e.Allegiance;
				end
			end
		end
	end

end

if(SERVER) then

function SWEP:PrimaryAttack()
	local EyeTrace = self.Owner:GetEyeTrace();
	if(EyeTrace.Hit) then
		if(IsValid(EyeTrace.Entity)) then
			local e = EyeTrace.Entity;
			local class = e:GetClass();
			if(e.IsSWVehicle) then
				local distance = (e:GetPos() - self.Owner:GetPos()):Length();
				if(distance <= 300) then
					e.Allegiance = self.Allegiance;
					e:ChangeAllegiance(self.Allegiance);
				end
			end
		end
	end
	return true
end

SWEP.Allegiance = "Rebels";
function SWEP:SecondaryAttack()
	if(self.Allegiance == "Mandalorian") then
		self.Allegiance = "CIS";
	elseif(self.Allegiance == "CIS") then
		self.Allegiance = "Republic";
	elseif(self.Allegiance == "Republic") then
		self.Allegiance = "Rebels";	
	elseif(self.Allegiance == "Rebels") then
		self.Allegiance = "Neutral";
	elseif(self.Allegiance == "Neutral") then
		self.Allegiance = "Empire";
	elseif(self.Allegiance == "Empire") then
		self.Allegiance = "First Order";
	elseif(self.Allegiance == "First Order") then
		self.Allegiance = "Resistance";
	elseif(self.Allegiance == "Resistance") then
		self.Allegiance = "Corruption";
	elseif(self.Allegiance == "Corruption") then
		self.Allegiance = "Mandalorian";
	end
	self:SetNWString("Allegiance",self.Allegiance)
	self:SetNextSecondaryFire(CurTime()+0.3);
	return true
end

end

--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/cl_customize_ui.lua:
local DevMode = false

local ARC9ScreenScale = ARC9.ScreenScale

-- Cycle the selected attachment
function SWEP:CycleSelectedAtt(amt, cyc)
    local activetab = self.CustomizeButtons[self.CustomizeTab + 1]
    if !(activetab.customize or activetab.personalize) then return end

    cyc = cyc or 0
    if #self.AttachmentAddresses <= 0 then return end
    if cyc > #self.AttachmentAddresses then return end

    local addr = self.BottomBarAddress or 1

    local newaddr = addr + amt

    if newaddr < 1 then
        newaddr = #self.AttachmentAddresses
    elseif newaddr > #self.AttachmentAddresses then
        newaddr = 1
    end

    self.BottomBarAddress = newaddr

    self.BottomBarPath = {}

    self.BottomBarMode = 1
    self.BottomBarFolders = {}
    self.BottomBarAtts = {}
    self:CreateHUD_Bottom()

    self.CustomizePanX = 0
    self.CustomizePanY = 0
    self.CustomizePitch = 0

    local slot = self:LocateSlotFromAddress(self.BottomBarAddress)

    if (activetab.customize and self:SlotIsCosmetic(slot)) or (activetab.personalize and !self:SlotIsCosmetic(slot)) or slot.Hidden or self:GetSlotBlocked(slot) then
        self:CycleSelectedAtt(1, cyc + 1)
    end
end

SWEP.CustomizeHUD = nil
SWEP.CustomizeBoxes = nil

SWEP.CustomizeTab = 0

local function swtichtoslotmenu(self)
    if GetConVar("arc9_cust_exit_reset_sel"):GetBool() and self.CustomizeHUD.lowerpanel.Extended then
        self.CustomizeHUD.lowerpanel.Extended = nil
        self.BottomBarMode = 0
        self.BottomBarAddress = nil
        self.BottomBarMode = 0
        self:CreateHUD_Bottom()
    end
end

local deadzonex = GetConVar("arc9_hud_deadzonex")

SWEP.CustomizeButtons = {
    {
        title = "customize.panel.customize",
        func = function(self2)
            if self2.BottomBarCategory == 1 then
                self2.BottomBarAddress = nil
                self2.BottomBarMode = 0
                self2:CreateHUD_Bottom()
            end

            self2.BottomBarCategory = 0

            self2:ClearTabPanel()
            self2:CreateHUD_Bottom()

            swtichtoslotmenu(self2)

            if self2.CustomizeHUD.lowerpanel then
                if self2.CustomizeHUD.lowerpanel.Extended then
                    self2.CustomizeHUD.lowerpanel:MoveTo(ARC9ScreenScale(19) + deadzonex:GetInt(), ScrH() - ARC9ScreenScale(93+73.5), 0.2, 0, 0.5, nil)
                    self2.CustomizeHUD.lowerpanel:SizeTo(ScrW() - ARC9ScreenScale(38) - deadzonex:GetInt()*2, ARC9ScreenScale(74+73.5), 0.2, 0, 0.5, nil)
                else
                    self2.CustomizeHUD.lowerpanel:MoveTo(ARC9ScreenScale(19) + deadzonex:GetInt(), ScrH() - ARC9ScreenScale(93), 0.2, 0, 0.5, nil)
                    self2.CustomizeHUD.lowerpanel:SizeTo(ScrW() - ARC9ScreenScale(38) - deadzonex:GetInt()*2, ARC9ScreenScale(74), 0.2, 0, 0.5, nil)
                end

                self2:ClosePresetMenu()
                self2.CustomizeHUD.lowerpanel:AlphaTo(255, 0.2, 0, nil)
                self2.CustomizeHUD.topright_panel:AlphaTo(255, 0.2, 0, nil)
                self2.CustomizeHUD.topleft_panel:AlphaTo(255, 0.2, 0, nil)
            end
        end,
        customize = true,
        cutcorner = 1
    },
    {
        title = "customize.panel.personalize",
        func = function(self2)
            if self2.BottomBarCategory == 0 then
                self2.BottomBarAddress = nil
                self2.BottomBarMode = 0
                self2:CreateHUD_Bottom()
            end

            self2.BottomBarCategory = 1

            self2:ClearTabPanel()
            self2:CreateHUD_Bottom()

            swtichtoslotmenu(self2)

            if self2.CustomizeHUD.lowerpanel then
                if self2.CustomizeHUD.lowerpanel.Extended then
                    self2.CustomizeHUD.lowerpanel:MoveTo(ARC9ScreenScale(19) + deadzonex:GetInt(), ScrH() - ARC9ScreenScale(93+73.5), 0.2, 0, 0.5, nil)
                    self2.CustomizeHUD.lowerpanel:SizeTo(ScrW() - ARC9ScreenScale(38) - deadzonex:GetInt()*2, ARC9ScreenScale(74+73.5), 0.2, 0, 0.5, nil)
                else
                    self2.CustomizeHUD.lowerpanel:MoveTo(ARC9ScreenScale(19) + deadzonex:GetInt(), ScrH() - ARC9ScreenScale(93), 0.2, 0, 0.5, nil)
                    self2.CustomizeHUD.lowerpanel:SizeTo(ScrW() - ARC9ScreenScale(38) - deadzonex:GetInt()*2, ARC9ScreenScale(74), 0.2, 0, 0.5, nil)
                end

                self2:ClosePresetMenu()
                self2.CustomizeHUD.lowerpanel:AlphaTo(255, 0.2, 0, nil)
                self2.CustomizeHUD.topright_panel:AlphaTo(255, 0.2, 0, nil)
                self2.CustomizeHUD.topleft_panel:AlphaTo(255, 0.2, 0, nil)
            end
        end,
        personalize = true,
        cutcorner = 0
    },
    -- {
    --     title = "STATS",
    --     func = function(self2)
    --         self2:CreateHUD_Stats()

    --         if self2.CustomizeHUD.lowerpanel then
    --             self2.CustomizeHUD.lowerpanel.Extended = nil

    --             self2:ClosePresetMenu()

    --             self2.CustomizeHUD.lowerpanel:MoveTo(ARC9ScreenScale(19), ScrH()-ARC9ScreenScale(93+50), 0.2, 0, 0.5, nil)
    --             self2.CustomizeHUD.lowerpanel:SizeTo(ScrW() - ARC9ScreenScale(38), ARC9ScreenScale(74+50), 0.2, 0, 0.5, nil)

    --             self2.CustomizeHUD.lowerpanel:AlphaTo(255, 0.2, 0, nil)
    --             self2.CustomizeHUD.topright_panel:AlphaTo(255, 0.2, 0, nil)
    --             self2.CustomizeHUD.topleft_panel:AlphaTo(255, 0.2, 0, nil)
    --         end
    --     end
    -- },
    {
        title = "customize.panel.stats",
        func = function(self2)
            self2:CreateHUD_Bench()

            if self2.CustomizeHUD.lowerpanel then
                self2.CustomizeHUD.lowerpanel.Extended = nil

                self2:ClosePresetMenu()

                -- self2.CustomizeHUD.lowerpanel:MoveTo(ARC9ScreenScale(19), ScrH() - ARC9ScreenScale(93-55-22.75), 0.2, 0, 0.5, nil)
                -- self2.CustomizeHUD.lowerpanel:SizeTo(ScrW() - ARC9ScreenScale(38), ARC9ScreenScale(74-55), 0.2, 0, 0.5, nil)

                self2.CustomizeHUD.lowerpanel:MoveTo(ARC9ScreenScale(19) + deadzonex:GetInt(), ScrH()-ARC9ScreenScale(93+50), 0.2, 0, 0.5, nil)
                self2.CustomizeHUD.lowerpanel:SizeTo(ScrW() - ARC9ScreenScale(38) - deadzonex:GetInt()*2, ARC9ScreenScale(74+50), 0.2, 0, 0.5, nil)

                self2.CustomizeHUD.lowerpanel:AlphaTo(255, 0.2, 0, nil)
                self2.CustomizeHUD.topright_panel:AlphaTo(255, 0.2, 0, nil)
                self2.CustomizeHUD.topleft_panel:AlphaTo(255, 0.2, 0, nil)
            end
        end
    },
    {
        title = "customize.panel.trivia",
        func = function(self2)
            self2:CreateHUD_Trivia()

            if self2.CustomizeHUD.lowerpanel then
                self2.CustomizeHUD.lowerpanel.Extended = nil

                self2:ClosePresetMenu()

                self2.CustomizeHUD.lowerpanel:MoveTo(ARC9ScreenScale(19) + deadzonex:GetInt(), ScrH()-ARC9ScreenScale(93+50), 0.2, 0, 0.5, nil)
                self2.CustomizeHUD.lowerpanel:SizeTo(ScrW() - ARC9ScreenScale(38) - deadzonex:GetInt()*2, ARC9ScreenScale(74+50), 0.2, 0, 0.5, nil)

                self2.CustomizeHUD.lowerpanel:AlphaTo(255, 0.2, 0, nil)
                self2.CustomizeHUD.topright_panel:AlphaTo(255, 0.2, 0, nil)
                self2.CustomizeHUD.topleft_panel:AlphaTo(255, 0.2, 0, nil)
            end
        end,
        cutcorner = 2
    },
    {
        title = "customize.panel.inspect",
        func = function(self2, page)
            self2:ClearTabPanel()

            if self2.LastCustomizeTab == page then
                self2.CustomizeTab = 0
                self2.CustomizeButtons[1].func(self2)
            elseif self2.CustomizeHUD.lowerpanel then
                self2.CustomizeHUD.lowerpanel.Extended = nil

                self2:ClosePresetMenu()

                self2.CustomizeHUD.lowerpanel:MoveTo(ARC9ScreenScale(19) + deadzonex:GetInt(), ScrH() - ARC9ScreenScale(93-55-22.75), 0.2, 0, 0.5, nil)
                self2.CustomizeHUD.lowerpanel:SizeTo(ScrW() - ARC9ScreenScale(38) - deadzonex:GetInt()*2, ARC9ScreenScale(74-55), 0.2, 0, 0.5, nil)

                self2.CustomizeAlphaBuffer = math.max(self2.CustomizeAlphaBuffer or 0, CurTime() + 0.5)
            end
        end,
        inspect = true,
        cutcorner = 3
    },
}

SWEP.TabPanel = nil

function SWEP:ClearTabPanel()
    if self.TabPanel then
        self.TabPanel:Remove()
        self.TabPanel = nil
    end

    self:ClearBottomBar()
end

function SWEP:RefreshCustomizeMenu()
end

local mat_3dslot = Material("arc9/ui/3d_slot.png", "mips smooth")
local mat_3dslot_empty = Material("arc9/ui/3d_slot_empty.png", "mips smooth")
local mat_gear = Material("arc9/gear.png", "mips smooth")
local mat_plus = Material("arc9/ui/plus.png")
local mat_dash = Material("arc9/ui/dash.png")
local mat_info = Material("arc9/ui/info.png")

local lmbdown = false
local rmbdown = false

local lastmousex = 0
local lastmousey = 0

local dragging = false
local dragging_r = false

SWEP.CustomizePanX = 0
SWEP.CustomizePanY = 0

SWEP.CustomizePitch = 0
SWEP.CustomizeYaw = 0

SWEP.CustomizeZoom = 0

SWEP.CustomizeHints = {}

local gpX = 0
local gpY = 0

local Press1 = false
local Press2 = false

local Release1 = false
local Release2 = false
local setscroll = 0
hook.Add("StartCommand", "ARC9_GamepadHUD", function(ply, cmd)
    if IsValid(LocalPlayer()) and IsValid(LocalPlayer():GetActiveWeapon()) and LocalPlayer():GetActiveWeapon().ARC9 and LocalPlayer():GetActiveWeapon():GetCustomize() then
        local wpn = LocalPlayer():GetActiveWeapon()

        local pox = math.Round(math.TimeFraction(-32768, 32767, input.GetAnalogValue(ANALOG_JOY_U))-0.5, 1)*2
        local poy = math.Round(math.TimeFraction(-32768, 32767, input.GetAnalogValue(ANALOG_JOY_R))-0.5, 1)*2

        local p1x = math.Round(math.TimeFraction(-32768, 32767, input.GetAnalogValue(ANALOG_JOY_X))-0.5, 1)*2
        local p1y = math.Round(math.TimeFraction(-32768, 32767, input.GetAnalogValue(ANALOG_JOY_Y))-0.5, 1)*2

        if ARC9.ControllerMode() then
            if cmd:KeyDown(IN_JUMP) then
                cmd:RemoveKey(IN_JUMP)
                if !Press1 then
                    gui.InternalMousePressed(MOUSE_LEFT)
                    Press1 = true
                end
                Release1 = true
            else
                if Release1 then
                    gui.InternalMouseReleased(MOUSE_LEFT)
                    Release1 = false
                    Press1 = false
                end
            end
            if cmd:KeyDown(IN_USE) then
                cmd:RemoveKey(IN_USE)
                if !Press2 then
                    gui.InternalMousePressed(MOUSE_RIGHT)
                    Press2 = true
                end
                Release2 = true
            else
                if Release2 then
                    gui.InternalMouseReleased(MOUSE_RIGHT)
                    Release2 = false
                    Press2 = false
                end
            end
        -- end

        -- if true then
            local cx, cy = input.GetCursorPos()

            gpX = ((pox * 160 * (ScrH() / 480)) * RealFrameTime())
            gpY = ((poy * 160 * (ScrH() / 480)) * RealFrameTime())
            input.SetCursorPos(cx+gpX, cy+gpY)
            gpX = 0
            gpY = 0
        end

        if cmd:KeyDown(IN_USE) then
            wpn.CustomizePanX = wpn.CustomizePanX + (p1x * 5 * RealFrameTime())
            wpn.CustomizePanY = wpn.CustomizePanY + (p1y * 5 * RealFrameTime())
        else
            wpn.CustomizePitch = wpn.CustomizePitch - (p1x * 45 * RealFrameTime())
            wpn.CustomizeYaw   = wpn.CustomizeYaw   + (p1y * 1 * RealFrameTime())
        end

        gui.InternalMouseWheeled(setscroll)
        setscroll = 0
    end
end)

local doop = 0
hook.Add("PlayerBindPress", "ARC9_GamepadHUDBinds", function(ply, bind, pressed, code)
    if IsValid(LocalPlayer()) and IsValid(LocalPlayer():GetActiveWeapon()) and LocalPlayer():GetActiveWeapon().ARC9 and LocalPlayer():GetActiveWeapon():GetCustomize() and ARC9.ControllerMode() then
        if bind == "invprev" then
            if doop % 2 == 0 then setscroll = 1 end
            doop = doop + 1
            return true
        elseif bind == "invnext" then
            if doop % 2 == 0 then setscroll = -1 end
            doop = doop + 1
            return true
        end
    end
end)


local ghs = {
    Material("arc9/seasonal/g1.png", "mips smooth"),
    Material("arc9/seasonal/g2.png", "mips smooth"),
    Material("arc9/seasonal/g3.png", "mips smooth"),
    Material("arc9/seasonal/g4.png", "mips smooth"),
    Material("arc9/seasonal/g5.png", "mips smooth"),
    Material("arc9/seasonal/g6.png", "mips smooth"),
}
local bday = {
    Material("arc9/seasonal/birthday1.png", "mips smooth"),
    Material("arc9/seasonal/birthday2.png", "mips smooth"),
    Material("arc9/seasonal/birthday3.png", "mips smooth"),
}
local troll = {
    Material("arc9/seasonal/troll.png", "mips smooth"),
    Material("arc9/seasonal/fuuu.png", "mips smooth")
}
local SeasonalHalloween = {}
local SeasonalHolidays = {}

local hoversound = "arc9/newui/uimouse_hover.ogg"
local clicksound = "arc9/newui/uimouse_click.ogg"
local opensound = "arc9/newui/uimouse_click_forward.ogg"
local backsound = "arc9/newui/uimouse_click_return.ogg"
local popupsound = "arc9/newui/uimouse_click_popup.ogg"
local closesound = "arc9/newui/ui_close.ogg"
local lightonsound = "arc9/newui/ui_light_on.ogg"
local lightoffsound = "arc9/newui/ui_light_off.ogg"
local tabsound = "arc9/newui/uimouse_click_tab.ogg"

function SWEP:CreateCustomizeHUD()
    if !IsValid(self) then return end

    local bg = vgui.Create("DPanel")

    self.CustomizeHUD = bg

    gui.EnableScreenClicker(true)

    surface.PlaySound("arc9/newui/ui_open.ogg") -- w

    gpX = ScrW()/2
    gpY = ScrH()/2

    bg:SetPos(0, 0)
    bg:SetSize(ScrW(), ScrH())

    bg.OnRemove = function(self2)
        if !IsValid(self) then return end
        -- self:SavePreset()
    end

    bg.OnMouseWheeled = function(self2, sd)
        if !IsValid(self) then return end
        if !self2:IsHovered() then return false end -- to prevent wheeling outside area

        self.CustomizeZoom = self.CustomizeZoom - (sd * 2)

        self.CustomizeZoom = math.Clamp(self.CustomizeZoom, -64, 64)
    end

    bg:SetMouseInputEnabled(true)

    table.Empty(SeasonalHalloween)
    table.Empty(SeasonalHolidays)
    if ARC9.ActiveHolidays["Christmas"] then
        bg.Posh = 0
    end

    bg.Paint = function(self2, w, h)
        if !IsValid(self) or LocalPlayer():GetActiveWeapon() != self then
            self2:Remove()
            gui.EnableScreenClicker(false)
            return
        end

        --[[
        if DevMode then
            surface.SetFont("ARC9_10")
            surface.SetTextColor(ARC9.GetHUDColor("fg"))
            surface.SetTextPos((w/2) - 10, ARC9ScreenScale(5))
            surface.DrawText("Developer mode")

            surface.SetFont("ARC9_8")

            surface.SetTextColor(255, 174, 0)
            surface.SetTextPos((w/2) - 10, ARC9ScreenScale(16))
            surface.DrawText("bone pos")
            surface.SetTextColor(230, 166, 255)
            surface.SetTextPos((w/2) - 10, ARC9ScreenScale(23))
            surface.DrawText("icon pos")
            surface.SetTextColor(206, 90, 90)
            surface.SetTextPos((w/2) - 10, ARC9ScreenScale(30))
            surface.DrawText("att pos")

        elseif ARC9.ActiveHolidays["Troll Day"] then
            do  -- nice text
                surface.SetFont("ARC9_10")
                local tx = "problem?"
                local tz = surface.GetTextSize(tx)
                surface.SetTextPos((w/2) - (tz/2)+ARC9ScreenScale(1), ARC9ScreenScale(16+1))
                surface.SetTextColor(ARC9.GetHUDColor("shadow"))
                surface.DrawText(tx)
                surface.SetTextPos((w/2) - (tz/2), ARC9ScreenScale(16))
                surface.SetTextColor(ARC9.GetHUDColor("fg"))
                surface.DrawText(tx)
            end

            surface.SetDrawColor(255, 255, 255, 255 / 64)

            for i, v in ipairs(SeasonalHalloween) do
                if isnumber(v.mat) then continue end -- fuck off
                surface.SetMaterial(v.mat)
                local si = ARC9ScreenScale(32)


                v.x = v.x + (v.px * 2 * FrameTime())
                v.y = v.y + (v.py2 * 2 * FrameTime())
                v.py = math.sin((CurTime() + (i / i)) * math.pi * 0.5) * ARC9ScreenScale(8)

                surface.DrawTexturedRectRotated(v.x + v.px, v.y + v.py, si, si, math.sin((CurTime() + (i / i)) * math.pi) * 15)

                if v.x >= w then
                    v.x = 0
                elseif v.x <= 0 then
                    v.x = w
                end

                if v.y >= h then
                    v.y = 0
                elseif v.y <= 0 then
                    v.y = h
                end
            end

            if table.IsEmpty(SeasonalHalloween) then
                for i=1, 13 do
                    table.insert(SeasonalHalloween,
                        {
                            x = w*math.Rand(0, 1),
                            y = h*math.Rand(0, 1),
                            px = math.Rand(-1, 1),
                            py = 0,
                            py2 = math.Rand(-1, 1),
                            mat = table.Random(troll),
                        }
                   )
                end
            end

        elseif ARC9.ActiveHolidays["Birthday - Arctic"] then

            do  -- nice text
                surface.SetFont("ARC9_10")
                local tx = "Happy Birthday to Arctic!"
                local tz = surface.GetTextSize(tx)
                surface.SetTextPos((w/2) - (tz/2)+ARC9ScreenScale(1), ARC9ScreenScale(16+1))
                surface.SetTextColor(ARC9.GetHUDColor("shadow"))
                surface.DrawText(tx)
                surface.SetTextPos((w/2) - (tz/2), ARC9ScreenScale(16))
                surface.SetTextColor(ARC9.GetHUDColor("fg"))
                surface.DrawText(tx)
            end

            surface.SetDrawColor(255, 255, 255, 255/64)

            for i, v in ipairs(SeasonalHalloween) do
                if isnumber(v.mat) then continue end -- fuck off
                surface.SetMaterial(v.mat)
                local si = ARC9ScreenScale(32)


                v.x = v.x + (v.px * 2 * FrameTime())
                v.y = v.y + (v.py2 * 2 * FrameTime())
                v.py = math.sin((CurTime() + (i / i)) * math.pi * 0.5) * ARC9ScreenScale(8)

                surface.DrawTexturedRectRotated(v.x + v.px, v.y + v.py, si, si, math.sin((CurTime() + (i / i)) * math.pi) * 15)

                if v.y >= h then
                    v.y = 0
                    v.x = w*math.Rand(0, 1)
                elseif v.y <= 0 then
                    v.y = h
                    v.x = w*math.Rand(0, 1)
                end
            end

            if table.IsEmpty(SeasonalHalloween) then
                for i=1, 10 do
                    table.insert(SeasonalHalloween,
                        {
                            x = w*math.Rand(0, 1),
                            y = h*math.Rand(0, 1),
                            px = 0,
                            py = 0,
                            py2 = math.Rand(60, 120),
                            mat = table.Random(bday),
                        }
                   )
                end
            end
        elseif ARC9.ActiveHolidays["Summer Break"] then
            do  -- nice text
                surface.SetFont("ARC9_10")
                local tx = "Summer break!"
                local tz = surface.GetTextSize(tx)
                surface.SetTextPos((w/2) - (tz/2)+ARC9ScreenScale(1), ARC9ScreenScale(16+1))
                surface.SetTextColor(ARC9.GetHUDColor("shadow"))
                surface.DrawText(tx)
                surface.SetTextPos((w/2) - (tz/2), ARC9ScreenScale(16))
                surface.SetTextColor(ARC9.GetHUDColor("fg"))
                surface.DrawText(tx)
            end

            surface.SetDrawColor(255, 255, 127, 255*0.04)
            surface.SetMaterial(Material("arc9/seasonal/sun.png", "mips smooth"))
            local si = ARC9ScreenScale(256)
            surface.DrawTexturedRectRotated(w-ARC9ScreenScale(32), ARC9ScreenScale(32), si, si, CurTime()*3)
        elseif ARC9.ActiveHolidays["Halloween"] then

            do  -- nice text
                surface.SetFont("ARC9_10")
                local tx = "Happy Halloween!"
                local tz = surface.GetTextSize(tx)
                surface.SetTextPos((w/2) - (tz/2)+ARC9ScreenScale(1), ARC9ScreenScale(16+1))
                surface.SetTextColor(ARC9.GetHUDColor("shadow"))
                surface.DrawText(tx)
                surface.SetTextPos((w/2) - (tz/2), ARC9ScreenScale(16))
                surface.SetTextColor(ARC9.GetHUDColor("fg"))
                surface.DrawText(tx)
            end

            surface.SetDrawColor(255, 255, 255, 255/64)

            for i, v in ipairs(SeasonalHalloween) do
                if isnumber(v.mat) then continue end -- fuck off
                surface.SetMaterial(v.mat)
                local si = ARC9ScreenScale(32)


                v.x = v.x + (v.px * 2 * FrameTime())
                v.y = v.y + (v.py2 * 2 * FrameTime())
                v.py = math.sin((CurTime() + (i / i)) * math.pi * 0.5) * ARC9ScreenScale(8)

                surface.DrawTexturedRectRotated(v.x + v.px, v.y + v.py, si, si, math.sin((CurTime() + (i / i)) * math.pi) * 15)

                if v.x >= w then
                    v.x = 0
                elseif v.x <= 0 then
                    v.x = w
                end

                if v.y >= h then
                    v.y = 0
                elseif v.y <= 0 then
                    v.y = h
                end
            end

            if table.IsEmpty(SeasonalHalloween) then
                for i=1, 13 do
                    table.insert(SeasonalHalloween,
                        {
                            x = w*math.Rand(0, 1),
                            y = h*math.Rand(0, 1),
                            px = math.Rand(-1, 1),
                            py = 0,
                            py2 = math.Rand(-1, 1),
                            mat = table.Random(ghs),
                        }
                   )
                end
            end
        elseif ARC9.ActiveHolidays["Christmas"] then

            do  -- nice text
                surface.SetFont("ARC9_10")
                local tx = "Happy Holidays!"
                local tz = surface.GetTextSize(tx)
                surface.SetTextPos((w/2) - (tz/2)+ARC9ScreenScale(1), ARC9ScreenScale(16+1))
                surface.SetTextColor(ARC9.GetHUDColor("shadow"))
                surface.DrawText(tx)
                surface.SetTextPos((w/2) - (tz/2), ARC9ScreenScale(16))
                surface.SetTextColor(ARC9.GetHUDColor("fg"))
                surface.DrawText(tx)
            end

            surface.SetDrawColor(255, 255, 255, 255/32)
            surface.SetMaterial(Material("arc9/seasonal/hills.png", "smooth"))
            bg.Posh = math.Approach(bg.Posh or 0, 2, FrameTime() * (1/20))
            if bg.Posh > 1 then
                bg.Posh = 0
            end
            surface.DrawTexturedRect(
                math.Round(0-(ARC9ScreenScale(1024)*bg.Posh), 0),
                h-ARC9ScreenScale(1024/8*0.75) + ((math.sin(CurTime() * math.pi / 10)) * ARC9ScreenScale(16)),
                ARC9ScreenScale(1024),
                ARC9ScreenScale(1024/8)
           )
            surface.DrawTexturedRect(
                math.Round(0+ARC9ScreenScale(1024)-(ARC9ScreenScale(1024)*bg.Posh), 0),
                h-ARC9ScreenScale(1024/8*0.75) + ((math.sin(CurTime() * math.pi / 10)) * ARC9ScreenScale(16)),
                ARC9ScreenScale(1024),
                ARC9ScreenScale(1024/8)
           )

            for i, v in ipairs(SeasonalHolidays) do
                surface.SetMaterial(Material("arc9/seasonal/snowflake.png", "mips smooth"))
                local si = ARC9ScreenScale(16)

                surface.DrawTexturedRectRotated(v[1], v[2], si, si, v[5] or 0)
                v[1] = math.Approach(v[1], v[1] + v[3], FrameTime() * ARC9ScreenScale(1) * 20 * v[3])
                v[2] = math.Approach(v[2], h, FrameTime() * ARC9ScreenScale(1) * 20 * v[4])
                v[5] = math.Approach(v[5] or 0, 370, FrameTime() * ARC9ScreenScale(1) * 20 * v[4])
                if v[2] >= h then
                    v[2] = ARC9ScreenScale(-16)
                end
                if math.abs(v[1]) >= w then
                    v[2] = ARC9ScreenScale(-16)
                    v[1] = w*math.Rand(0, 1)
                end
                if math.abs(v[5]) >= 360 then
                    v[5] = 0
                end
            end

            if table.IsEmpty(SeasonalHolidays) then
                for i=1, 32 do
                    table.insert(SeasonalHolidays,
                        {
                            [1] = w*math.Rand(0, 1),
                            [2] = -h*math.Rand(0, 0.5),
                            [3] = math.Rand(-4, 4),
                            [4] = math.Rand(0.5, 4),
                            [5] = 0,
                        }
                   )
                end
            end
        end
        ]]

        if ARC9.ControllerMode() then
            surface.SetTextPos(ARC9ScreenScale(4), ARC9ScreenScale(4))
            surface.SetTextColor(ARC9.GetHUDColor("fg"))
            surface.SetFont("ARC9_8")
            surface.DrawText(ARC9:GetPhrase("customize.hint.controller"))

            --[[surface.SetMaterial(Material("arc9/gamepad/corner.png", ""))
            surface.SetDrawColor(255, 255, 255, 255)

            local si = ARC9ScreenScale(6)
            local of = si/2
            local bo = si*2
            surface.DrawTexturedRectRotated(of, of, si, si, 0)
            surface.DrawTexturedRectRotated(of+bo, of, si, si, 270)
            surface.DrawTexturedRectRotated(of+bo, of+bo, si, si, 180)
            surface.DrawTexturedRectRotated(of, of+bo, si, si, 90)

            surface.SetMaterial(Material("arc9/gamepad/pointer.png", ""))
            surface.DrawTexturedRect(si, si, si, si)

            surface.SetMaterial(mat_grad)
            surface.SetDrawColor(0, 0, 0, 250)
            surface.DrawTexturedRect(w - h, 0, h, h)]]--
        end

        local bumpy = {}

        local anyhovered = false

        local function isinaabb(x, y)
            if !self2:IsHovered() then return false end -- to prevent clicking outside area
            if anyhovered then return false end

            local mousex, mousey = input.GetCursorPos()

            local s = ARC9ScreenScale(10) - self.CustomizeZoom * 1.5


            if mousex >= x - s and mousex <= x + s and mousey >= y - (s / 2) and mousey <= y + (s / 2) then
                anyhovered = true
                return true
            else
                return false
            end
        end

        if self.CustomizeButtons[self.CustomizeTab + 1].customize or self.CustomizeButtons[self.CustomizeTab + 1].personalize then

            cam.Start3D(nil, nil, self:WidescreenFix(self:GetViewModelFOV()))

            for _, slot in ipairs(self:GetSubSlotList()) do
                if slot.Hidden then continue end
                if !slot.Pos then continue end
                if !slot.Bone then continue end
                local ms_slot = self:GetFilledMergeSlot(slot.Address)

                if self.BottomBarCategory == 0 and self:SlotIsCosmetic(ms_slot) then continue end
                if self.BottomBarCategory == 1 and !self:SlotIsCosmetic(ms_slot) then continue end

                if !ms_slot.Installed and self:GetSlotBlocked(slot) then continue end

                local atttbl = self:GetFinalAttTable(ms_slot)

                local attpos, attang, icon_offset = self:GetAttachmentPos(slot, false, false, true)
                local attposOffset = attpos

                icon_offset = icon_offset + (atttbl.IconOffset or atttbl.Icon_Offset or vector_origin)

                attposOffset = attposOffset + attang:Right() * icon_offset.y
                attposOffset = attposOffset + attang:Up() * icon_offset.z
                attposOffset = attposOffset + attang:Forward() * icon_offset.x

                local toscreen = attpos:ToScreen()
                local toscreenOffset = attposOffset:ToScreen()

                cam.Start2D()

                local x, y = toscreenOffset.x, toscreenOffset.y
                local xUOS, yUOS = toscreen.x, toscreen.y -- unoffsetted

                local s = ARC9ScreenScale(16) - self.CustomizeZoom * 1.5

                local hoveredslot = false
                ms_slot.fuckinghovered = false

                local dist = 0

                local mousex, mousey = input.GetCursorPos()

                if isinaabb(x, y) then
                    hoveredslot = true
                    dist = math.Distance(x, y, mousex, mousey)

                    for _, bump in ipairs(bumpy) do
                        if isinaabb(bump.x, bump.y) then
                            local d2 = math.Distance(bump.x, bump.y, mousex, mousey)

                            if d2 < dist then
                                hoveredslot = false
                                ms_slot.fuckinghovered = false
                                break
                            end
                        end
                    end
                end

                if mousey > (ScrH() - ARC9ScreenScale(64)) then hoveredslot = false ms_slot.fuckinghovered = false end

                table.insert(bumpy, {x = x, y = y, slot = slot})

                local col = ARC9.GetHUDColor("notoccupied")

                local showname = false

                if hoveredslot or ms_slot.hovered then
                    col = ARC9.GetHUDColor("hi")
                    showname = true
                elseif self.BottomBarAddress == ms_slot.Address then
                    col = ARC9.GetHUDColor("hi")
                elseif slot.Installed then
                    col = ARC9.GetHUDColor("fg")
                end

                if hoveredslot then
                    ms_slot.fuckinghovered = true
                    self.CustomizeLastHoveredSlot2 = ms_slot

                    self.CustomizeHints["customize.hint.select"] = "customize.hint.expand"
                    self.CustomizeHints["customize.hint.random"] = "customize.hint.randomize"
                    if slot.Installed then
                        self.CustomizeHints["customize.hint.deselect"] = "customize.hint.unattach"
                    end
                end

                if DevMode then
                    -- local bonepos = self:GetVM():GetBonePosition(self:GetVM():LookupBone(slot.Bone))
                    local bonepos =  self:GetVM():GetBoneMatrix(self:GetVM():LookupBone(slot.Bone)):GetTranslation()
                    local bonepostoscreen = bonepos:ToScreen()
                    local boneposX, boneposY = bonepostoscreen.x, bonepostoscreen.y

                    surface.SetFont("ARC9_4")

                    -- att

                    surface.SetDrawColor(206, 90, 90)
                    surface.DrawRect(xUOS-5, yUOS-5, 10, 10)

                    surface.SetDrawColor(230, 166, 255)
                    surface.DrawLine(x, y, xUOS, yUOS)
                    surface.DrawRect(x-2.5, y-2.5, 5, 5)

                    surface.SetTextColor(230, 166, 255)
                    surface.SetTextPos(x, y-20)
                    surface.DrawText(slot.PrintName)

                    -- bone
                    surface.SetDrawColor(255, 174, 0)
                    surface.DrawLine(xUOS, yUOS, boneposX, boneposY)
                    surface.DrawRect(boneposX-2.5, boneposY-2.5, 5, 5)

                    surface.SetTextColor(255, 174, 0)
                    surface.SetTextPos(boneposX, boneposY)
                    surface.DrawText(slot.Bone)
                else
                    if ms_slot.SubAttachments then
                        local isparenttosomething = false

                        for _, p in ipairs(ms_slot.SubAttachments) do
                            if p.Installed then isparenttosomething = true end
                        end

                        if isparenttosomething then
                            s = s * 0.6
                            col = ARC9.GetHUDColor("hi", 75)
                        end
                    end

                    x, y = x-s/2, y-s/2

                    surface.SetMaterial(mat_3dslot)
                    surface.SetDrawColor(col)
                    surface.DrawTexturedRect(x, y, s, s)

                    local atttxt = ms_slot.PrintName or "SLOT"

                    if ms_slot.Installed then
                        atttxt = ARC9:GetPhraseForAtt(ms_slot.Installed, "CompactName")
                        atttxt = atttxt or ARC9:GetPhraseForAtt(ms_slot.Installed, "PrintName") or ""

                        surface.SetMaterial(atttbl.Icon or mat_3dslot)
                        surface.SetDrawColor(ARC9.GetHUDColor("fg"))
                        render.SuppressEngineLighting(true)
                        if !atttbl.FullColorIcon then
                            surface.DrawTexturedRect(x + ARC9ScreenScale(1), y + ARC9ScreenScale(1), s - ARC9ScreenScale(2), s - ARC9ScreenScale(2))
                        else
                            surface.DrawTexturedRect(x + ARC9ScreenScale(3), y + ARC9ScreenScale(3), s - ARC9ScreenScale(6), s - ARC9ScreenScale(6))
                        end
                        render.SuppressEngineLighting(false)
                    else
                        if ms_slot.DefaultCompactName then
                            atttxt = ARC9:UseTrueNames() and ms_slot.DefaultCompactName_TrueName or ms_slot.DefaultCompactName
                            atttxt = atttxt or ms_slot.DefaultName_TrueName or ms_slot.DefaultName or ""
                        end

                        if ms_slot.DefaultIcon then
                            surface.SetMaterial(ms_slot.DefaultIcon)
                        elseif GetConVar("arc9_atts_nocustomize"):GetBool() then
                            surface.SetMaterial(mat_dash)
                        else
                            surface.SetMaterial(mat_plus)
                        end

                        surface.SetDrawColor(ARC9.GetHUDColor("fg"))
                        surface.DrawTexturedRect(x + ARC9ScreenScale(1), y + ARC9ScreenScale(1), s - ARC9ScreenScale(2), s - ARC9ScreenScale(2))
                    end

                    if showname then
                        surface.SetFont("ARC9_8")
                        local tw = surface.GetTextSize(atttxt)
                        surface.SetTextColor(ARC9.GetHUDColor("shadow"))
                        surface.SetTextPos(x + (s / 2) - (tw / 2) + 1, y + s + ARC9ScreenScale(1.3)) -- x + s + ARC9ScreenScale(2), y + (s / 2)
                        surface.DrawText(atttxt)
                        surface.SetTextColor(ARC9.GetHUDColor("fg"))
                        surface.SetTextPos(x + (s / 2) - (tw / 2), y + s + ARC9ScreenScale(1)) -- x + s + ARC9ScreenScale(2), y + (s / 2)
                        surface.DrawText(atttxt)
                    end
                end

                if hoveredslot then
                    if IsValid(ms_slot.lowerbutton) then ms_slot.lowerbutton:SetOverrideHovered(true) end

                    if input.IsMouseDown(MOUSE_LEFT) and !lmbdown and (self.BottomBarAddress != slot.Address or self.BottomBarMode != 1) then
                        self.BottomBarMode = 1
                        self.BottomBarAddress = slot.Address
                        self.BottomBarPath = {}
                        self.BottomBarFolders = {}
                        self.BottomBarAtts = {}
                        self:CreateHUD_Bottom()

                        -- self.CustomizePanX = 0
                        -- self.CustomizePanY = 0
                        -- self.CustomizePitch = 0
                        surface.PlaySound(clicksound)

                    elseif input.IsMouseDown(MOUSE_RIGHT) and !rmbdown then
                        if ms_slot.Integral and isstring(ms_slot.Integral) then
                            self:Attach(slot.Address, ms_slot.Integral)
                        else
                            self:DetachAllFromSubSlot(slot.Address)
                        end
                        self.BottomBarPath = {}
                        self.BottomBarFolders = {}
                        self.BottomBarAtts = {}
                        timer.Simple(0, function()
                            if !IsValid(self) then return end
                            self:CreateHUD_Bottom()
                        end)
                    end
                else
                    if IsValid(ms_slot.lowerbutton) then ms_slot.lowerbutton:SetOverrideHovered(false) end
                end

                cam.End2D()
            end

            cam.End3D()

        end

        if dragging then
            self2:SetCursor("sizeall")

            if !input.IsMouseDown(MOUSE_LEFT) then
                dragging = false
            else
                local mousex, mousey = input.GetCursorPos()

                local dx = mousex - lastmousex
                local dy = mousey - lastmousey

                self.CustomizePanX = self.CustomizePanX + (dx / ARC9ScreenScale(32))
                self.CustomizePanY = self.CustomizePanY + (dy / ARC9ScreenScale(32))

                self.CustomizePanX = math.Clamp(self.CustomizePanX, -16, 16)
                self.CustomizePanY = math.Clamp(self.CustomizePanY, -8, 8)
            end
        elseif dragging_r then
            self2:SetCursor("sizewe")

            if !input.IsMouseDown(MOUSE_RIGHT) then
                dragging_r = false
            else
                local mousex, mousey = input.GetCursorPos()

                local dx = mousex - lastmousex
                local dy = mousey - lastmousey

                self.CustomizePitch = self.CustomizePitch - (dx / ARC9ScreenScale(4)) * 3
                -- self.CustomizeYaw = math.Clamp(self.CustomizeYaw + (dy / ARC9ScreenScale(8)) * (math.floor(self.CustomizePitch / 90) % 2 == 0 and 1 or -1), -30, 30)
                self.CustomizeYaw = self.CustomizeYaw + (dy / ARC9ScreenScale(8)) * 3

            end
        elseif input.IsKeyDown(KEY_R) and self2:IsHovered() then
            if self.CustomizeLastHoveredSlot2 then
                if self.CustomizeLastHoveredSlot2.fuckinghovered then return end
            end
            self.CustomizePanX = Lerp(0.25, self.CustomizePanX, 0)
            self.CustomizePanY = Lerp(0.25, self.CustomizePanY, 0)
            self.CustomizePitch = Lerp(0.25, self.CustomizePitch, 0)
            self.CustomizeYaw = Lerp(0.25, self.CustomizeYaw, 0)
            self.CustomizeZoom = Lerp(0.25, self.CustomizeZoom, 0)
        elseif !anyhovered then
            self2:SetCursor("arrow")

            if input.IsMouseDown(MOUSE_LEFT) and !lmbdown and self2:IsHovered() then
                dragging = true
                lastmousex, lastmousey = input.GetCursorPos()
            end
            if input.IsMouseDown(MOUSE_RIGHT) and !rmbdown and self2:IsHovered() then
                dragging_r = true
                lastmousex, lastmousey = input.GetCursorPos()
            end
        elseif anyhovered then
            self2:SetCursor("hand")
        end

        lastmousex, lastmousey = input.GetCursorPos()

        lmbdown = input.IsMouseDown(MOUSE_LEFT)
        rmbdown = input.IsMouseDown(MOUSE_RIGHT)
    end

    self:CreateHUD_RHP()

    bg:MoveToFront()

    local trolling = ""
    if ARC9.ControllerMode() then
        trolling = {
            {
                action = "customize.hint.select",
                glyph = ARC9.GetBindKey("+jump"),
                hidden = true,
            },
            {
                action = "customize.hint.deselect",
                glyph = ARC9.GetBindKey("+use"),
                hidden = true,
            },
            {
                action = "customize.hint.zoom",
                glyph = ARC9.GetBindKey("invprev"),
                glyph2 = ARC9.GetBindKey("invnext"),
                row2 = true,
            },
            {
                action = "customize.hint.pan",
                glyph = ARC9.GetBindKey("+attack"),
                glyph2 = "shared_touch",
                row2 = true,
            },
            {
                action = "customize.hint.rotate",
                glyph = ARC9.GetBindKey("+attack2"),
                glyph2 = "shared_touch",
                row2 = true,
            },
            {
                action = "customize.hint.recenter",
                glyph = ARC9.GetBindKey("+reload"),
                row3 = true,
            },
            {
                action = "customize.hint.cycle",
                glyph = ARC9.GetBindKey("+showscores"),
                row3 = true,
            },
            {
                action = "customize.hint.last",
                glyph = ARC9.GetBindKey("+use"),
                glyph2 = ARC9.GetBindKey("+showscores"),
                row3 = true,
            },
            {
                action = "customize.hint.favorite",
                glyph = ARC9.GetBindKey("impulse 100"),
                hidden = true,
            },
            {
                action = "customize.hint.random",
                glyph = ARC9.GetBindKey("+reload"),
                hidden = true,
            },
        }
    else
        trolling = {
            {
                action = "customize.hint.select",
                glyph = ARC9.GetBindKey("+attack"),
                hidden = true,
            },
            {
                action = "customize.hint.deselect",
                glyph = ARC9.GetBindKey("+attack2"),
                hidden = true,
            },
            {
                action = "customize.hint.zoom",
                glyph = ARC9.GetBindKey("invprev"),
                glyph2 = ARC9.GetBindKey("invnext"),
                row2 = true,
            },
            {
                action = "customize.hint.pan",
                glyph = ARC9.GetBindKey("+attack"),
                glyph2 = "shared_touch",
                row2 = true,
            },
            {
                action = "customize.hint.rotate",
                glyph = ARC9.GetBindKey("+attack2"),
                glyph2 = "shared_touch",
                row2 = true,
            },
            {
                action = "customize.hint.recenter",
                glyph = ARC9.GetBindKey("+reload"),
                row3 = true,
            },
            {
                action = "customize.hint.cycle",
                glyph = ARC9.GetBindKey("+showscores"),
                row3 = true,
            },
            {
                action = "customize.hint.last",
                glyph = ARC9.GetBindKey("+use"),
                glyph2 = ARC9.GetBindKey("+showscores"),
                row3 = true,
            },
            {
                action = "customize.hint.favorite",
                glyph = ARC9.GetBindKey("impulse 100"),
                hidden = true,
            },
            {
                action = "customize.hint.random",
                glyph = ARC9.GetBindKey("+reload"),
                hidden = true,
            },
        }
    end


    local tips = {
        "tips.custombinds",
        "tips.blacklist",
        "tips.hints",
        "tips.lean",
        "tips.discord",
        "tips.arc-9",
        "tips.development",
        "tips.presets",
        -- "tips.tacrp",
        "tips.bugs",
        "tips.official",
        "tips.external",
        "tips.love",
        "tips.tolerance",
        "tips.cyberdemon",
        "tips.tips",
        "tips.settings",
        "tips.description",
    }

    local tipdelay = 8
    local tipalpha = 0
    local tipfade = 0
    local tipcurrent = math.random(0, #tips)
    local tiplast = 0

    local hintspanel = vgui.Create("DPanel", bg)
    -- hintspanel:SetSize(ARC9ScreenScale(225), ARC9ScreenScale(100))
    -- hintspanel:SetPos(-ARC9ScreenScale(170), -ARC9ScreenScale(40)) -- w = scrw-ARC9Scr
    -- hintspanel:MoveTo(0, ARC9ScreenScale(4), 0.4, 0, 0.1, nil)

    self.CustomizeHUD.hintspanel = hintspanel
    hintspanel:SetPos(ARC9ScreenScale(19), ScrH())
    hintspanel:MoveTo(ARC9ScreenScale(19), ScrH() - ARC9ScreenScale(16.5), 0.6, 0, 0.1, nil)
    hintspanel:SetSize(ScrW() - ARC9ScreenScale(38), ARC9ScreenScale(18))
    hintspanel:MoveToBack()

    hintspanel.Paint = function(self2, w, h)
        if !GetConVar("arc9_cust_hints"):GetBool() then return end
        if !IsValid(self) then
            self2:Remove()
            gui.EnableScreenClicker(false)
            return
        end

        if !(self.CustomizeButtons[self.CustomizeTab + 1].customize or self.CustomizeButtons[self.CustomizeTab + 1].personalize) then return end

        surface.SetFont("ARC9_10")
        surface.SetDrawColor(ARC9.GetHUDColor("fg"))
        surface.SetTextColor(ARC9.GetHUDColor("fg"))

        local ToAdd = {}
        local ToAdd2 = {}
        local ToAdd3 = {}
        for _, v in ipairs(trolling) do
            local act, hid = v.action, v.hidden
            if self.CustomizeHints[v.action] == "" then continue end
            if self.CustomizeHints[v.action] then hid = false end
            if hid then continue end
            if ARC9.CTRL_Lookup[v.glyph] then v.glyph = ARC9.CTRL_Lookup[v.glyph] end
            if ARC9.CTRL_ConvertTo[v.glyph] then v.glyph = ARC9.CTRL_ConvertTo[v.glyph] end
            if ARC9.CTRL_Exists[v.glyph] then v.glyph = Material( "arc9/" .. ARC9.GlyphFamilyHUD() .. v.glyph .. ".png", "smooth" ) end
            if v.glyph2 then
                if ARC9.CTRL_Lookup[v.glyph2] then v.glyph2 = ARC9.CTRL_Lookup[v.glyph2] end
                if ARC9.CTRL_ConvertTo[v.glyph2] then v.glyph2 = ARC9.CTRL_ConvertTo[v.glyph2] end
                if ARC9.CTRL_Exists[v.glyph2] then v.glyph2 = Material( "arc9/" .. ARC9.GlyphFamilyHUD() .. v.glyph2 .. ".png", "smooth" ) end
            end

            if v.row3 then
                table.insert(ToAdd3, { v.glyph, ARC9ScreenScale(8) })
                if v.glyph2 then
                    table.insert(ToAdd3, "  ")
                    table.insert(ToAdd3, { v.glyph2, ARC9ScreenScale(8) })
                end
                table.insert(ToAdd3, "  " ..  ARC9:GetPhrase(self.CustomizeHints[v.action] or v.action) .. "    ")
            elseif v.row2 then
                table.insert(ToAdd2, { v.glyph, ARC9ScreenScale(8) })
                if v.glyph2 then
                    table.insert(ToAdd2, "  ")
                    table.insert(ToAdd2, { v.glyph2, ARC9ScreenScale(8) })
                end
                table.insert(ToAdd2, "  " ..  ARC9:GetPhrase(self.CustomizeHints[v.action] or v.action) .. "    ")
            else
                table.insert(ToAdd, { v.glyph, ARC9ScreenScale(8) })
                if v.glyph2 then
                    table.insert(ToAdd, " ")
                    table.insert(ToAdd, { v.glyph2, ARC9ScreenScale(8) })
                end
                table.insert(ToAdd, "  " .. ARC9:GetPhrase(self.CustomizeHints[v.action] or v.action) .. "    ")
            end
        end

        local strreturn = CreateControllerKeyLine({x = self2:GetWide(), y = ARC9ScreenScale(2), size = ARC9ScreenScale(10), font = "ARC9_10", font_keyb = "ARC9_KeybindPreview_Cust" }, Color(255,255,255,175), unpack(ToAdd3)) -- ghost     text only to get width

        if !table.IsEmpty(ToAdd) then
            CreateControllerKeyLine({x = ARC9ScreenScale(8), y = ARC9ScreenScale(2), size = ARC9ScreenScale(10), font = "ARC9_10", font_keyb = "ARC9_KeybindPreview_Cust" }, Color(255,255,255,175), unpack(ToAdd))
            tipalpha = 0
        else
            -- tips
            if GetConVar("arc9_cust_tips"):GetBool() then
                if CurTime() > tiplast then
                    tiplast = CurTime() + tipdelay
                    tipcurrent = tipcurrent + 1
                end

                tipalpha = math.min(tipalpha + FrameTime() * 300, 175)
                tipfade = math.min((tiplast-CurTime()) / tipdelay, 0.025) * 40 * tipalpha
                local tiptext = ARC9:GetPhrase(tips[tipcurrent%(#tips)+1])

                surface.SetMaterial(mat_info)
                surface.SetDrawColor(ARC9.GetHUDColor("fg", tipalpha))
                surface.DrawTexturedRect(ARC9ScreenScale(8), ARC9ScreenScale(2), ARC9ScreenScale(10), ARC9ScreenScale(10))

				-- local btw = surface.GetTextSize(tiptext)
				-- local bw, bh = btw + ARC9ScreenScale(4), ARC9ScreenScale(10)

                -- surface.SetDrawColor(ARC9.GetHUDColor("shadow", (tipalpha * 3)))
                -- surface.DrawRect(ARC9ScreenScale(20), ARC9ScreenScale(1.5), bw, bh)

                surface.SetFont("ARC9_10")
                surface.SetTextPos(ARC9ScreenScale(22), ARC9ScreenScale(2))
                surface.SetTextColor(ARC9.GetHUDColor("fg", tipfade))
                -- surface.DrawText(tiptext)
                ARC9.DrawTextRot(self2, tiptext, ARC9ScreenScale(22), 0, ARC9ScreenScale(22), ARC9ScreenScale(2), w - strreturn - ARC9ScreenScale(32), false)

            end
        end

        CreateControllerKeyLine({x = self2:GetWide() - ARC9ScreenScale(8)-strreturn , y = ARC9ScreenScale(2), size = ARC9ScreenScale(10), font = "ARC9_10", font_keyb = "ARC9_KeybindPreview_Cust" }, Color(255,255,255,175), unpack(ToAdd3))
		
        -- CreateControllerKeyLine({x = self2:GetWide() - ARC9ScreenScale(250)-strreturn , y = ARC9ScreenScale(2), size = ARC9ScreenScale(10), font = "ARC9_10", font_keyb = "ARC9_KeybindPreview_Cust" }, ARC9.GetHUDColor("hint", 255), unpack(ToAdd2))

        table.Empty(self.CustomizeHints)
    end
end

function SWEP:RemoveCustomizeHUD()
    if self.RemovingCustHud then return end

    local bg = self.CustomizeHUD

    local scrh = ScrH()
    local scrw = ScrW()

    local deadzonexx = deadzonex:GetInt()

    if self.CustomizeHUD then
        self.RemovingCustHud = true
        if bg.nameplate then bg.nameplate:MoveTo(0, -ARC9ScreenScale(64), 0.7, 0, 0.05, nil) bg.nameplate:AlphaTo(0, 0.2, 0) end
        if bg.topleft_panel then bg.topleft_panel:MoveTo(-ARC9ScreenScale(70) + deadzonexx, -ARC9ScreenScale(40), 0.7, 0, 0.05, nil) bg.topleft_panel:AlphaTo(0, 0.2, 0) end
        if bg.topright_panel then bg.topright_panel:MoveTo(scrw - deadzonexx, -ARC9ScreenScale(40), 0.7, 0, 0.05, nil) bg.topright_panel:AlphaTo(0, 0.2, 0) end
        if bg.lowerpanel then bg.lowerpanel:MoveTo(ARC9ScreenScale(19) + deadzonexx, scrh, 0.7, 0, 0.05, nil) bg.lowerpanel:AlphaTo(0, 0.2, 0) end
        if bg.hintspanel then bg.hintspanel:MoveTo(ARC9ScreenScale(19) + deadzonexx, scrh, 0.7, 0, 0.05, nil) bg.hintspanel:AlphaTo(0, 0.1, 0) end
        -- if self.TabPanel then self.TabPanel:AlphaTo(0, 0.1, 0) end

        self:ClosePresetMenu()

        gui.EnableScreenClicker(false)

        surface.PlaySound(closesound)

        timer.Simple(0.1, function()
            if !IsValid(self) then return end
            self.CustomizeHUD:Remove()
            self.CustomizeHUD = nil
            self.RemovingCustHud = nil
        end)
    end
end

function SWEP:DrawCustomizeHUD()
    local customize = self:GetCustomize()

    if self.CustomizeHUD and !IsValid(self.CustomizeHUD) then
        self:RemoveCustomizeHUD()
    end

    if customize and !self.CustomizeHUD and !self.RemovingCustHud then
        self:CreateCustomizeHUD()
    elseif !customize and self.CustomizeHUD then
        self:RemoveCustomizeHUD()
    end
end

function SWEP:CreateHUD_RHP()
    local bg = self.CustomizeHUD
    if !IsValid(self) then return end
    if !bg then return end

    local scrh = ScrH()
    local scrw = ScrW()

    local gr_h = scrh
    local gr_w = gr_h

    local nameplate = vgui.Create("DPanel", bg)
    self.CustomizeHUD.nameplate = nameplate
    nameplate:SetPos(0, -ARC9ScreenScale(64)) -- h = ARC9ScreenScale(8)
    nameplate:MoveTo(0, ARC9ScreenScale(8), 1, 0, 0.05, nil)
    nameplate:SetSize(scrw, ARC9ScreenScale(38))
    nameplate:MoveToBack()
    nameplate.Paint = function(self2, w, h)
        if !IsValid(self) then return end

        local redname
        if self.Hook_RedPrintName then redname = self:RunHook("Hook_RedPrintName") end

        -- if (self.CustomizeButtons[self.CustomizeTab + 1] or {}).inspect then return end

        surface.SetFont("ARC9_24")
        local tw = surface.GetTextSize(self.PrintName or "No name ??? wtf")

        surface.SetFont("ARC9_24")
        surface.SetTextPos(w/2 - tw/2, 0)
        surface.SetTextColor(redname and ARC9.GetHUDColor("hi_3d") or ARC9.GetHUDColor("fg"))
        surface.DrawText(self.PrintName or "No name ??? wtf")

        -- class
        surface.SetFont("ARC9_12")
        local tw2 = surface.GetTextSize(self.Class or "No class ??? wtf")

        surface.SetFont("ARC9_12")
        surface.SetTextPos(w/2 - tw2/2, ARC9ScreenScale(25))
        surface.SetTextColor(ARC9.GetHUDColor("fg"))
        surface.DrawText(self.Class or "No class ??? wtf")

        surface.SetDrawColor(ARC9.GetHUDColor("bg"))
        surface.DrawRect(w/2 - tw2/2, ARC9ScreenScale(23), tw2, ARC9ScreenScale(1.5))
    end

    self.CustomizeAlphaBuffer = CurTime() + 1

    local inspectalpha = function(self2, panel, minusnum)
        if self.CustomizeButtons[self.CustomizeTab + 1].inspect then -- probably horrible
            if self2:IsHovered() or (self.CustomizeAlphaBuffer or 0) > CurTime() then
                panel:SetAlpha(math.min(panel:GetAlpha() + 25, 255))
            else
                panel:SetAlpha(math.max(panel:GetAlpha() - minusnum, 0)) -- * number of cust buttons
            end
        end
    end

    local deadzonexx = deadzonex:GetInt()

    local topleft_panel = vgui.Create("DPanel", bg)
    self.CustomizeHUD.topleft_panel = topleft_panel
    topleft_panel:SetPos(-ARC9ScreenScale(70) + deadzonexx, -ARC9ScreenScale(40)) -- w = 0, h = 0
    topleft_panel:MoveTo(deadzonexx, 0.1, 0.4, 0, 0.1, nil)
    topleft_panel:SetSize(ARC9ScreenScale(70+29), ARC9ScreenScale(40))
    topleft_panel:MoveToFront()
    topleft_panel.Paint = function(self2, w, h) end

    local topleft_settings = vgui.Create("ARC9TopButton", topleft_panel)
    topleft_settings:SetPos(ARC9ScreenScale(19), ARC9ScreenScale(19))
    topleft_settings:SetNotif(ARC9.BadPerfromanceSettings())
    topleft_settings.DoClick = function(self2)
        surface.PlaySound(popupsound)
        ARC9_OpenSettings()

        -- self:ToggleCustomize(false)
        -- bg:SetMouseInputEnabled(false)
    end

    local topleft_light = vgui.Create("ARC9TopButton", topleft_panel)
    topleft_light:SetPos(ARC9ScreenScale(47.5), ARC9ScreenScale(19))
    topleft_light:SetIcon(Material("arc9/ui/light.png", "mips smooth"))
    topleft_light:SetIsCheckbox(true)
    topleft_light:SetConVar("arc9_cust_light")
    topleft_light:SetValue(GetConVar("arc9_cust_light"):GetBool())
    local oldlightdoclick = topleft_light.DoClick
    topleft_light.DoClick = function(self2)
        oldlightdoclick(self2)
        surface.PlaySound(self2:GetChecked() and lightonsound or lightoffsound)
    end

    if ARC9.Dev(0) and ARC9.ATTsHaveBeenReloaded then
        local topleft_devreload = vgui.Create("ARC9TopButton", topleft_panel)
        topleft_devreload:SetPos(ARC9ScreenScale(47.5+29), ARC9ScreenScale(19))
        topleft_devreload:SetIcon(Material("arc9/reset.png", "mips smooth"))
        topleft_devreload:SetConVar("arc9_reloadatts")
        local olddevreloaddoclick = topleft_devreload.DoClick
        topleft_devreload.DoClick = function(self2)
            olddevreloaddoclick(self2)
        end
        topleft_devreload.Think = function(self2) if !IsValid(self) then return end inspectalpha(self2, self.CustomizeHUD.topleft_panel, 8) end
    end

    topleft_settings.Think = function(self2) if !IsValid(self) then return end inspectalpha(self2, self.CustomizeHUD.topleft_panel, 8) end
    topleft_light.Think = function(self2) if !IsValid(self) then return end inspectalpha(self2, self.CustomizeHUD.topleft_panel, 8) end

    local topright_panel = vgui.Create("DPanel", bg)
    self.CustomizeHUD.topright_panel = topright_panel
    topright_panel:SetPos(scrw - deadzonexx, -ARC9ScreenScale(40)) -- w = scrw-ARC9ScreenScale(170), h = 0
    topright_panel:MoveTo(scrw - ARC9ScreenScale(170) - deadzonexx, 0, 0.4, 0, 0.1, nil)
    topright_panel:SetSize(ARC9ScreenScale(170), ARC9ScreenScale(40))
    topright_panel:MoveToFront()
    topright_panel.Paint = function(self2, w, h) end

    if self.Attachments[1] and !GetConVar("arc9_atts_nocustomize"):GetBool() then -- no presets if no atts
        local topright_presets = vgui.Create("ARC9TopButton", topright_panel)
        self.CustomizeHUD.topright_panel.topright_presets = topright_presets
        surface.SetFont("ARC9_16")
        local tw = surface.GetTextSize(ARC9:GetPhrase("customize.panel.presets"))
        topright_presets:SetPos(ARC9ScreenScale(123)-(ARC9ScreenScale(28)+tw), ARC9ScreenScale(19))
        topright_presets:SetSize(ARC9ScreenScale(28)+tw, ARC9ScreenScale(21))
        topright_presets:SetIcon(Material("arc9/ui/presets.png", "mips"))
        topright_presets:SetButtonText(ARC9:GetPhrase("customize.panel.presets"))
        topright_presets:SetIsCheckbox(true)
        local oldpresetsdoclick = topright_presets.DoClick
        topright_presets.DoClick = function(self2)
            surface.PlaySound(self2:GetChecked() and backsound or opensound)

            oldpresetsdoclick(self2)

            self.CustomizeHUD.lowerpanel.Extended = nil
            self.BottomBarMode = 0

            self:CreatePresetMenu()
        end

        topright_presets.Think = function(self2) if !IsValid(self) then return end inspectalpha(self2, self.CustomizeHUD.topright_panel, 8) end
    end

    local topright_close = vgui.Create("ARC9TopButton", topright_panel)
    topright_close:SetPos(ARC9ScreenScale(130), ARC9ScreenScale(19))
    topright_close:SetIcon(Material("arc9/ui/close.png", "mips smooth"))
    topright_close.DoClick = function(self2)
        surface.PlaySound(clicksound)
        self:SetCustomize(false)
        net.Start("ARC9_togglecustomize")
        net.WriteBool(false)
        net.SendToServer()
    end

    topright_close.Think = function(self2) if !IsValid(self) then return end inspectalpha(self2, self.CustomizeHUD.topright_panel, 8) end


    local lowerpanel = vgui.Create("DPanel", bg)
    self.CustomizeHUD.lowerpanel = lowerpanel
    lowerpanel:SetPos(ARC9ScreenScale(19) + deadzonexx, scrh) -- h = scrh-ARC9ScreenScale(93)
    -- lowerpanel:MoveTo(ARC9ScreenScale(19), scrh-ARC9ScreenScale(93), 0.6, 0, 0.1, nil) -- CustomizeTab does this for us
    lowerpanel:SetSize(scrw - ARC9ScreenScale(38) - deadzonexx*2, ARC9ScreenScale(74))
    lowerpanel:MoveToBack()

    local hascosmetic = false
    local hasnoncosmetic = false

    for _, slottbl in pairs(self:GetSubSlotList()) do
        if hascosmetic and hasnoncosmetic then break end
        if slottbl.Hidden then continue end
        if self:SlotIsCosmetic(slottbl) then
            hascosmetic = true
        else
            hasnoncosmetic = true
        end
    end

    if !hascosmetic and self.CustomizeButtons[2].personalize then
        table.remove(self.CustomizeButtons, 2)
    end

    if (!hasnoncosmetic) and self.CustomizeButtons[1].customize then  -- NO ATTS CUST PANEL REMOVAL
        table.remove(self.CustomizeButtons, 1)
        self.CustomizeButtons[1].cutcorner = 1
        self.CustomizeTab = 0
    end


    local barlength = -ARC9ScreenScale(1.5)
    local cornercut = ARC9ScreenScale(3.5)
    local inspecttextwidth = 0

    for i, btn in pairs(self.CustomizeButtons) do
        local custtabbtn = vgui.Create("DButton", lowerpanel)
        --
        surface.SetFont("ARC9_12")
        local titlewidth = surface.GetTextSize(ARC9:GetPhrase(btn.title)) + ARC9ScreenScale(12.5)
        --

        if btn.inspect then
            custtabbtn:SetPos(scrw - ARC9ScreenScale(38) - deadzonex:GetInt()*2 - titlewidth, 0)
            inspecttextwidth = titlewidth
        else
            barlength = barlength + titlewidth + ARC9ScreenScale(1.5)
            custtabbtn:SetPos(barlength - titlewidth, 0)
        end

        custtabbtn:SetSize(titlewidth, ARC9ScreenScale(14.5))
        custtabbtn.title = ARC9:GetPhrase(btn.title)
        custtabbtn.page = i - 1
        custtabbtn.func = btn.func
        custtabbtn:SetText("")


        custtabbtn.Paint = function(self2, w, h)
            if !IsValid(self) then return end

            local mainbuttoncolor = ARC9.GetHUDColor("bg")
            local barbuttoncolor = ARC9.GetHUDColor("bg")
            local buttontextcolor = ARC9.GetHUDColor("fg")

            if self.CustomizeTab == self2.page then
                mainbuttoncolor = ARC9.GetHUDColor("hi")
                barbuttoncolor = ARC9.GetHUDColor("hi")
                buttontextcolor = ARC9.GetHUDColor("shadow")
            end

            if self2:IsHovered() then
                barbuttoncolor = ARC9.GetHUDColor("hi")
                if self.CustomizeTab != self2.page then self.CustomizeHints["customize.hint.select"] = "customize.hint.open" end
            end

            surface.SetDrawColor(mainbuttoncolor)
            draw.NoTexture()

            local hcutted = ARC9ScreenScale(11.5)

            if btn.cutcorner == 1 then
                surface.DrawPoly({{x = 0, y = hcutted}, {x = 0, y = cornercut}, {x = cornercut, y = 0}, {x = w, y = 0}, {x = w, y = hcutted}})
            elseif btn.cutcorner == 2 then
                surface.DrawPoly({{x = 0, y = hcutted}, {x = 0, y = 0}, {x = w-cornercut, y = 0}, {x = w, y = cornercut}, {x = w, y = hcutted}})
            elseif btn.cutcorner == 3 then
                surface.DrawPoly({{x = 0, y = hcutted}, {x = 0, y = cornercut}, {x = cornercut, y = 0}, {x = w-cornercut, y = 0}, {x = w, y = cornercut}, {x = w, y = hcutted}})
            else
                surface.DrawPoly({{x = 0, y = hcutted}, {x = 0, y = 0}, {x = w, y = 0}, {x = w, y = hcutted}})
            end

            surface.SetDrawColor(barbuttoncolor)
            surface.DrawRect(0, h - ARC9ScreenScale(1.5), w, h)

            surface.SetFont("ARC9_12")
            local tw = surface.GetTextSize(self2.title)

            surface.SetTextColor(buttontextcolor)
            -- surface.SetTextPos((w - tw) / 2, -ARC9ScreenScale(0.75))
            surface.SetTextPos((w - tw) / 2, 0)
            surface.DrawText(self2.title)
        end
        custtabbtn.Think = function(self2) if !IsValid(self) then return end inspectalpha(self2, self.CustomizeHUD.lowerpanel, 3) end
        custtabbtn.DoClick = function(self2)
            self.LastCustomizeTab = self.CustomizeTab
            self.CustomizeTab = self2.page
            self2.func(self, self2.page)
            surface.PlaySound(tabsound)
        end
        custtabbtn.OnCursorEntered = function(self2)
            surface.PlaySound(hoversound)
        end
        -- custtabbtn.DoRightClick = function(self2)
        --     self.CustomizeTab = 0
        --     self:ClearTabPanel()
        -- end


        lowerpanel.Paint = function(self2, w, h)
            surface.SetDrawColor(ARC9.GetHUDColor("bg"))

            surface.DrawRect(barlength + ARC9ScreenScale(1.5), ARC9ScreenScale(12.75), w - barlength - inspecttextwidth - ARC9ScreenScale(3.2), ARC9ScreenScale(1.75)) -- bar spacer

            draw.NoTexture()

            if self2.Extended then
                surface.DrawPoly({{x = cornercut, y = h},{x = 0, y = h-cornercut}, {x = 0, y = ARC9ScreenScale(15.5+60)}, {x = w*0.5-ARC9ScreenScale(0.75), y = ARC9ScreenScale(15.5+60)}, {x = w*0.5-ARC9ScreenScale(0.75), y = h}})

                surface.DrawRect(0, ARC9ScreenScale(15.5+60-2.5), w*0.5-ARC9ScreenScale(0.5), ARC9ScreenScale(1.5))

                surface.DrawRect(0, ARC9ScreenScale(15.5), w, ARC9ScreenScale(60-3.5))

                surface.SetDrawColor(self2.HasPros and ARC9.GetHUDColor("bg_pro") or ARC9.GetHUDColor("bg"))
                surface.DrawPoly({{x = w*0.5+ARC9ScreenScale(0.75), y = h}, {x = w*0.5+ARC9ScreenScale(0.75), y = ARC9ScreenScale(15.5+60)}, {x = w*0.75-ARC9ScreenScale(0.75), y = ARC9ScreenScale(15.5+60)}, {x = w*0.75-ARC9ScreenScale(0.75), y = h}})

                surface.SetDrawColor(self2.HasPros and ARC9.GetHUDColor("pro") or ARC9.GetHUDColor("bg"))
                surface.DrawRect(w*0.5+ARC9ScreenScale(0.75), ARC9ScreenScale(15.5+60-2.5), w*0.25-ARC9ScreenScale(1), ARC9ScreenScale(1.5))

                surface.SetDrawColor(self2.HasCons and ARC9.GetHUDColor("bg_con") or ARC9.GetHUDColor("bg"))
                surface.DrawPoly({{x = w*0.75+ARC9ScreenScale(0.75), y = h}, {x = w*0.75+ARC9ScreenScale(0.75), y = ARC9ScreenScale(15.5+60)}, {x = w, y = ARC9ScreenScale(15.5+60)}, {x = w, y = h-cornercut}, {x = w-cornercut, y = h}})

                surface.SetDrawColor(self2.HasCons and ARC9.GetHUDColor("con") or ARC9.GetHUDColor("bg"))
                surface.DrawRect(w*0.75+ARC9ScreenScale(1), ARC9ScreenScale(15.5+60-2.5), w*0.25, ARC9ScreenScale(1.5))
            else
                surface.DrawPoly({{x = cornercut, y = h},{x = 0, y = h-cornercut}, {x = 0, y = ARC9ScreenScale(15.5)}, {x = w, y = ARC9ScreenScale(15.5)}, {x = w, y = h-cornercut}, {x = w-cornercut, y = h}})
            end

            -- thingy at bottom
            surface.SetDrawColor(ARC9.GetHUDColor("hi"))
            surface.DrawPoly({{x = cornercut, y = h}, {x = 0, y = h-cornercut}, {x = cornercut, y = h-cornercut*.5}})
            surface.DrawPoly({{x = w, y = h-cornercut}, {x = w-cornercut, y = h}, {x = w-cornercut, y = h-cornercut*.5}})
            surface.DrawPoly({{x = cornercut, y = h-cornercut*.5}, {x = w-cornercut, y = h-cornercut*.5}, {x = w-cornercut, y = h}, {x = cornercut, y = h}, })
        end
    end

    self.CustomizeButtons[self.CustomizeTab + 1].func(self)

    if DevMode then
        self:DevStuffMenu()
    end
end
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/cl_customize_ui_slots.lua:
local mat_plus = Material("arc9/ui/plus.png")
local mat_dash = Material("arc9/ui/dash.png")
local mat_stick = Material("arc9/def_att_icons/sticker.png")

local clicksound = "arc9/newui/uimouse_click.ogg"

local ARC9ScreenScale = ARC9.ScreenScale

function SWEP:SlotIsCosmetic(slottbl)
    if slottbl.CosmeticOnly == nil then
        local hasnoncosmeticslot = false

        local cats = slottbl.Category

        if !istable(cats) then
            cats = {cats}
        end

        for _, cat in ipairs(cats) do
            if !ARC9.CosmeticCategories[cat] or slottbl.ForceNoCosmetics then
                hasnoncosmeticslot = true
                break
            end
        end

        slottbl.CosmeticOnly = !hasnoncosmeticslot

        return !hasnoncosmeticslot
    else
        return slottbl.CosmeticOnly
    end
end

function SWEP:CreateHUD_Slots(scroll)
    local deadzonex = GetConVar("arc9_hud_deadzonex"):GetInt()

    self.CustomizeHUD.lowerpanel:MoveTo(ARC9ScreenScale(19) + deadzonex, ScrH() - ARC9ScreenScale(93), 0.2, 0, 0.5, nil)
    self.CustomizeHUD.lowerpanel:SizeTo(ScrW() - ARC9ScreenScale(38) - deadzonex*2, ARC9ScreenScale(74), 0.2, 0, 0.5, nil)
    self.CustomizeHUD.lowerpanel.Extended = nil

    local spacer = vgui.Create("DPanel", scroll)
    spacer:DockMargin(ARC9ScreenScale(5), 0, 0, 0)
    spacer:Dock(LEFT)
    spacer:SetSize(0, 0)

    scroll:AddPanel(spacer)

    for _, slot in ipairs(self:GetSubSlotList()) do
        if slot.Hidden then continue end
        local ms_slot = self:GetFilledMergeSlot(slot.Address)

        if self.BottomBarCategory == 0 and self:SlotIsCosmetic(ms_slot) then continue end
        if self.BottomBarCategory == 1 and !self:SlotIsCosmetic(ms_slot) then continue end

        if !ms_slot.Installed and self:GetSlotBlocked(slot) then continue end

        local atttbl = self:GetFinalAttTable(ms_slot)

        local atttxt = ms_slot.PrintName or "Slot"

        local slotbtn = vgui.Create("ARC9AttButton", scroll)

        slotbtn:SetCanAttach(true)
        slotbtn:SetEmpty(!ms_slot.Installed)
        slotbtn:SetHasModes(!!atttbl.ToggleStats)
        slotbtn:SetHasSlots(!!atttbl.Attachments)
        slotbtn:SetFullColorIcon(atttbl.FullColorIcon)
        slotbtn:SetSlotDisplay(true)

        -- slotbtn:DockMargin(ARC9ScreenScale(5), 0, 0, 0)
        slotbtn:DockMargin(0, 0, ARC9ScreenScale(4), 0)
        slotbtn:Dock(LEFT)

        scroll:AddPanel(slotbtn)

        slotbtn.slot = ms_slot
        ms_slot.lowerbutton = slotbtn

        if ms_slot.Installed then
            atttxt = ARC9:GetPhraseForAtt(ms_slot.Installed, "CompactName")
            atttxt = atttxt or ARC9:GetPhraseForAtt(ms_slot.Installed, "PrintName") or ""
            slotbtn:SetIcon(atttbl.Icon)
            -- slotbtn:SetTooltip(ARC9:GetPhraseForAtt(ms_slot.Installed, "PrintName").."\n\nLMB - Customisation\nRMB - Remove attachment")
        else
            if ms_slot.DefaultCompactName then
                atttxt = ARC9:UseTrueNames() and ms_slot.DefaultCompactName_TrueName or ms_slot.DefaultCompactName
                atttxt = atttxt or ms_slot.DefaultName_TrueName or ms_slot.DefaultName or ""
            end
            if ms_slot.DefaultIcon then
                slotbtn:SetIcon(ms_slot.DefaultIcon)
            elseif ms_slot.Category == "stickers" then
                slotbtn:SetIcon(mat_stick)
            elseif GetConVar("arc9_atts_nocustomize"):GetBool() then
                slotbtn:SetIcon(mat_dash)
            else
                slotbtn:SetIcon(mat_plus)
            end

            -- slotbtn:SetTooltip(atttxt .. " slot (unoccupied)\n\nLMB - Customisation")
        end

        slotbtn:SetButtonText(atttxt)

        slotbtn.OnMousePressed = function(self2, kc)
            if kc == MOUSE_LEFT then
                surface.PlaySound(clicksound)
                self.BottomBarMode = 1
                self.BottomBarAddress = slot.Address
                self.BottomBarPath = {}
                self.BottomBarFolders = {}
                self.BottomBarAtts = {}
                self:CreateHUD_Bottom()
            elseif kc == MOUSE_RIGHT then
                if ms_slot.Integral and isstring(ms_slot.Integral) then
                    self:Attach(slot.Address, ms_slot.Integral)
                else
                    self:DetachAllFromSubSlot(slot.Address)
                end
                timer.Simple(0, function() self:CreateHUD_Bottom() end)
                -- self:CreateHUD_Bottom()
            end
        end

        slotbtn.Think = function(self2)
            if !IsValid(self) then return end

            -- if slotbtn.OverrideHovered then
            --     self.CustomizeLastHoveredSlot = self2
            --     self.CustomizeLastHoveredSlot.validforrand = true
            -- end

            if self2:IsHovered() then
                self.CustomizeHints["customize.hint.select"] = "customize.hint.expand"
                self.CustomizeHints["customize.hint.random"] = "customize.hint.randomize"
                if self2.slot.Installed then
                    self.CustomizeHints["customize.hint.deselect"] = "customize.hint.unattach"
                end
                self2.slot.hovered = true
                self.CustomizeLastHoveredSlot = self2
            else
                self2.slot.hovered = false
            end
        end
    end
end
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/cl_drawmodel.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/cl_peek.lua:
SWEP.Peeking = false
-- SWEP.CantPeek = false

local lastpressed = false
local arc9_togglepeek_reset = GetConVar("arc9_togglepeek_reset")
local arc9_togglepeek = GetConVar("arc9_togglepeek")

function SWEP:ThinkPeek()
	if !self.dt.InSights then return end

    if arc9_togglepeek_reset:GetBool() and self:GetSightAmount() < 0.5 or self:GetBipod() or self:GetProcessedValue("CantPeek", true) then self.Peeking = false return end
    local binding = input.IsKeyDown(input.GetKeyCode(input.LookupBinding("menu_context") or "???"))

    if arc9_togglepeek:GetBool() then
        if binding and !lastpressed then
            self.Peeking = !self.Peeking
        end
    else
        self.Peeking = binding
    end

    lastpressed = binding
end
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/cl_pipscope.lua:
local rtsize = math.min(1024, ScrW(), ScrH())

local rtmat = GetRenderTarget("arc9_pipscope", rtsize, rtsize, false)
local rtmat_spare = GetRenderTarget("arc9_rtmat_spare", ScrW(), ScrH(), false)

function SWEP:ShouldDoScope()
    if self:GetSight().Disassociate then return false end
	
    return true
end

local arc9_fx_rtvm = GetConVar("arc9_fx_rtvm")

function SWEP:DoRT(fov, atttbl)
    if ARC9.OverDraw then return end

    local rtpos, rtang = self:GetShootPos()

    rtang.r = rtang.r + EyeAngles().z -- lean fix

    local sighttbl = self:GetSight()

    local rtvm = arc9_fx_rtvm:GetBool()

    local rt = {
        x = 0,
        y = 0,
        w = rtsize,
        h = rtsize,
        angles = rtang,
        origin = rtpos,
        drawviewmodel = rtvm or false,
        fov = fov,
        znear = 16,
        zfar = 30000
    }
    
    ARC9.RTScopeRenderFOV = fov

    render.PushRenderTarget(rtmat, 0, 0, rtsize, rtsize)

    if self:ShouldDoScope() then
        ARC9.OverDraw = true
        ARC9.RTScopeRender = rtvm
        render.RenderView(rt)
        ARC9.RTScopeRender = false
        ARC9.OverDraw = false

        cam.Start3D(rtpos, rtang, fov, 0, 0, rtsize, rtsize)
            cam.IgnoreZ(true)
            self:DrawLasers(false, true)
            cam.IgnoreZ(false)
        cam.End3D()
    else
        render.Clear(0, 0, 0, 255, true, true)
    end

    if atttbl.RTScopeFLIR then
        cam.Start3D(rtpos, rtang, fov, 0, 0, rtsize, rtsize, 16, 30000)

        self:DoFLIR(atttbl)

        cam.End3D()
    end

    if atttbl.RTScopeNightVision then
        self:DoNightScopeEffects(atttbl)
    end

    cam.Start3D(rtpos, rtang, fov, 0, 0, rtsize, rtsize, 16, 30000)
        self:DrawLockOnHUD(true)
    cam.End3D()

    self:DoRTScopeEffects()

    render.PopRenderTarget()

    if sighttbl.InvertColors then
        render.PushRenderTarget(rtmat, 0, 0, rtsize, rtsize)
            render.CopyTexture( rtmat, rtmat_spare )

            render.Clear(255, 255, 255, 255, true, true)
            render.OverrideBlend(true, BLEND_ONE, BLEND_ONE, BLENDFUNC_REVERSE_SUBTRACT)

            render.DrawTextureToScreen(rtmat_spare)

            render.OverrideBlend(false)

            if atttbl.RTScopePostInvertFunc then
                atttbl.RTScopePostInvertFunc(self)
            end

        render.PopRenderTarget()
    end
end

local rtsurf = Material("effects/arc9/rt")
local shadow = Material("arc9/shadow.png", "mips smooth")
local shadow2 = Material("arc9/shadow2.png", "mips smooth")

-- local pp_ca_base, pp_ca_r, pp_ca_g, pp_ca_b = Material("pp/arc9/ca_base"), Material("pp/arc9/ca_r"), Material("pp/arc9/ca_g"), Material("pp/arc9/ca_b")

local pp_cc_tab = {
    ["$pp_colour_addr"] = 0,
    ["$pp_colour_addg"] = 0,
    ["$pp_colour_addb"] = 0,
    ["$pp_colour_brightness"] = 0.03,
    ["$pp_colour_contrast"] = 0.92,
    ["$pp_colour_colour"] = 1.1,
    ["$pp_colour_mulr"] = 0,
    ["$pp_colour_mulg"] = 0,
    ["$pp_colour_mulb"] = 0
}

local monochrometable = {
    ["$pp_colour_addr"] = 0,
    ["$pp_colour_addg"] = 0,
    ["$pp_colour_addb"] = 0,
    ["$pp_colour_brightness"] = 0,
    ["$pp_colour_contrast"] = 1,
    ["$pp_colour_colour"] = 0,
    ["$pp_colour_mulr"] = 0,
    ["$pp_colour_mulg"] = 0,
    ["$pp_colour_mulb"] = 0
}

local noise = Material("arc9/nvnoise")

function SWEP:DoNightScopeEffects(atttbl)
    if atttbl.RTScopeNightVisionMonochrome then
        DrawColorModify(monochrometable)
    end

    if !atttbl.RTScopeNightVisionNoPP then
        cam.Start2D()
        surface.SetMaterial(noise)
        surface.SetDrawColor(atttbl.RTScopeNightVisionNoiseColor or color_white)
        surface.DrawTexturedRectRotated((rtsize / 2) + (rtsize * math.Rand(-0.25, 0.25)), (rtsize / 2) + (rtsize * math.Rand(-0.25, 0.25)), rtsize, rtsize, math.Rand(0, 360))
        surface.DrawTexturedRectRotated((rtsize / 2) + (rtsize * math.Rand(-0.5, 0.5)), (rtsize / 2) + (rtsize * math.Rand(-0.5, 0.5)), rtsize * 2, rtsize * 2, math.Rand(0, 360))
        cam.End2D()

        DrawBloom(0, 1, 10, 1, 1, 1, 1, 1, 1)
    end

    if atttbl.RTScopeNightVisionCC then
        DrawColorModify(atttbl.RTScopeNightVisionCC)
    end

    if atttbl.RTScopeNightVisionFunc then
        atttbl.RTScopeNightVisionFunc(self)
    end
end

function SWEP:DoRTScopeEffects()
    if !render.SupportsPixelShaders_2_0() then return end

    local atttbl = ((self:GetSight() or {}).atttbl or {})

    render.UpdateScreenEffectTexture()

    if atttbl.RTScopeNoPP then return end

    -- pp_ca_r:SetTexture("$basetexture", rtmat)
    -- pp_ca_g:SetTexture("$basetexture", rtmat)
    -- pp_ca_b:SetTexture("$basetexture", rtmat)

    -- render.SetMaterial( pp_ca_r )
    -- render.DrawScreenQuad()
    -- render.SetMaterial( pp_ca_g )
    -- render.DrawScreenQuad()
    -- render.SetMaterial( pp_ca_b )
    -- render.DrawScreenQuad()

    -- Color modify
    DrawColorModify( pp_cc_tab )

    -- Sharpen
    -- DrawSharpen(0.05, 12) -- dont work for some reason

    if atttbl.RTScopeCustomPPFunc then
        atttbl.RTScopeCustomPPFunc(self)
    end
    -- if atttbl.RTScopeMotionBlur then
        -- DrawMotionBlur(0.8, 1, 1/35)

        -- It is bad on some maps (gm_eft_customs for example)
        -- Whole screen becomes picture from sights
        -- We should use delayed low fps rendering like on arccw thermals (wait time before next draw call) 
        -- It'll be better for performance and won't cause any issues
    -- end
end

local vec1 = Vector(1, 1, 1)

local arc9_scope_r = GetConVar("arc9_scope_r")
local arc9_scope_g = GetConVar("arc9_scope_g")
local arc9_scope_b = GetConVar("arc9_scope_b")

function SWEP:DoRTScope(model, atttbl, active)
    local pos = model:GetPos()
    local ang = EyeAngles()

    if active then
        if self:ShouldDoScope() then
            self.RenderingRTScope = true
            local sight = self:GetSight()
            local sightpos = sight.ShadowPos or (sight.OriginalSightTable or {}).Pos or sight.Pos or Vector(0, 0, 0)
            sightpos = sightpos * ((sight.slottbl or {}).Scale or 1)

            sightpos.x = -sightpos.x -- to fix pso-like side scopes

            pos = pos + (sightpos.x * ang:Right())
            -- pos = pos + (sightpos.y * ang:Forward())
            pos = pos + (sightpos.z * -ang:Up())

            local screenpos

            if sight.BaseSight then
                screenpos = {
                    visible = true,
                    x = ScrW() / 2,
                    y = ScrH() / 2
                }
            else
                screenpos = pos:ToScreen()
            end

            local shadow_intensity = atttbl.RTScopeShadowIntensity or 10

            local sh_x = ((screenpos.x - (ScrW() / 2)) * shadow_intensity)
            local sh_y = ((screenpos.y - (ScrH() / 2)) * shadow_intensity)

            local ret_x = (screenpos.x - (ScrW() / 2)) * 10
            local ret_y = (screenpos.y - (ScrH() / 2)) * 10

            local sh_s = math.floor(rtsize * 1.3)

            sh_x = sh_x - ((sh_s-rtsize) / 2)
            sh_y = sh_y - ((sh_s-rtsize) / 2)

            ret_x = ret_x - ((sh_s-rtsize) / 2)
            ret_y = ret_y - ((sh_s-rtsize) / 2)

            render.PushRenderTarget(rtmat)


            cam.Start2D()

            local reticle = sight.Reticle or atttbl.RTScopeReticle
            local color = atttbl.RTScopeColor or color_white

            if atttbl.RTScopeColorable then
                color = Color(0, 0, 0)
                color.r = arc9_scope_r:GetInt()
                color.g = arc9_scope_g:GetInt()
                color.b = arc9_scope_b:GetInt()
            end

            -- I'm not sure this is a good feature to add
            -- local drawfunc = nil
            local size = rtsize * (atttbl.RTScopeReticleScale or 1)
            -- if atttbl.RTScopeDefer then
            --     local slot = sight.slottbl
            --     for k, v in pairs(slot.SubAttachments) do
            --         local at = ARC9.Attachments[v.Installed or ""]
            --         if at and (at.RTScopeReticle or at.HoloSightReticle) then
            --             reticle = (at.RTScopeReticle or at.HoloSightReticle)
            --             color = (at.RTScopeColor or at.HoloSightColor)
            --             drawfunc = at.HoloSightFunc
            --             size = (at.HoloSightSize and at.HoloSightSize * 0.5) or size
            --             break
            --         end
            --     end
            -- end

            if reticle then
                -- local rtr_x = (rtsize - size) / 2 - (-ret_x - sh_s / 2 + rtsize / 2) * 0.25
                -- local rtr_y = (rtsize - size) / 2 - (-ret_y - sh_s / 2 + rtsize / 2) * 0.25

                local rtr_x = (rtsize - size) / 2
                local rtr_y = (rtsize - size) / 2

                if atttbl.RTScopeBlackBox != false then
                    surface.SetDrawColor(0, 0, 0)
                    surface.DrawRect(rtr_x - size * 4, rtr_y - size * 8, size * 8, size * 8) -- top
                    surface.DrawRect(rtr_x - size * 8, rtr_y - size * 4, size * 8, size * 8) -- left
                    surface.DrawRect(rtr_x - size * 4, rtr_y + size - 1, size * 8, size * 8) -- bottom
                    surface.DrawRect(rtr_x + size - 1, rtr_y - size * 4, size * 8, size * 8) -- right

                    if atttbl.RTScopeBlackBoxShadow != false then
                        surface.SetMaterial(shadow2)
                        surface.SetDrawColor(0, 0, 0)
                        surface.DrawTexturedRect(rtr_x, rtr_y, size, size)
                    end
                end
                -- surface.DrawTexturedRect((rtsize - size) / 2, (rtsize - size) / 2, size, size)
                -- surface.DrawTexturedRectUV((rtsize - size) / 2, (rtsize - size) / 2, size, size, 1, 0, 0, 1)

                surface.SetDrawColor(color)
                surface.SetMaterial(reticle)
                surface.DrawTexturedRect(rtr_x, rtr_y, size, size)
            end

            if atttbl.RTScopeDrawFunc then
                atttbl.RTScopeDrawFunc(self, rtsize)
            end

            -- if drawfunc then -- doesn't seem to be working
            --     drawfunc(self, pos, model)
            -- end

            if !atttbl.RTScopeNoShadow then
                surface.SetDrawColor(0, 0, 0)
                surface.SetMaterial(shadow)
                surface.DrawTexturedRect(sh_x, sh_y, sh_s, sh_s)

                if !screenpos.visible then
                    surface.SetDrawColor(0, 0, 0)
                    surface.DrawRect(0, 0, rtsize, rtsize)
                else
                    surface.SetDrawColor(0, 0, 0)
                    surface.DrawRect(sh_x - sh_s * 4, sh_y - sh_s * 8, sh_s * 8, sh_s * 8) -- top
                    surface.DrawRect(sh_x - sh_s * 8, sh_y - sh_s * 4, sh_s * 8, sh_s * 8) -- left
                    surface.DrawRect(sh_x - sh_s * 4, sh_y + sh_s, sh_s * 8, sh_s * 8) -- bottom
                    surface.DrawRect(sh_x + sh_s, sh_y - sh_s * 4, sh_s * 8, sh_s * 8) -- right
                end
            end
        else
            render.PushRenderTarget(rtmat)
            cam.Start2D()
        end

        local sd = self:GetSightAmount()

        surface.SetDrawColor(0, 0, 0, 255 * (1 - sd))
        surface.DrawRect(0, 0, rtsize, rtsize)

        cam.End2D()

        render.PopRenderTarget()
        -- if sd > 0 then render.SetToneMappingScaleLinear(render.GetToneMappingScaleLinear()*0.2) end
        if sd > 0.5 then render.SetToneMappingScaleLinear(vec1) end

        rtsurf:SetTexture("$basetexture", rtmat)

        -- model:SetSubMaterial()

        model:SetSubMaterial(atttbl.RTScopeSubmatIndex, "effects/arc9/rt")
    else
        -- model:SetSubMaterial()
        rtsurf:SetTexture("$basetexture", "vgui/black")
        model:SetSubMaterial(atttbl.RTScopeSubmatIndex, "vgui/black")
    end

    -- if atttbl.RTScopeUseSubmatReticle then        gross
    --     atttbl.RTScopeReticle:SetInt("$flags", bit.bor(32768, 2097152))
    --     atttbl.RTScopeReticle:SetVector("$color2", Vector(atttbl.RTScopeColor or color_white))
    --     model:SetSubMaterial(atttbl.RTScopeReticleSubmatIndex, "!"..atttbl.RTScopeReticle:GetName())
    -- end
end

function SWEP:GetCheapScopeScale(scale)
    return 2 / (scale or 0.5)
end

local hascostscoped = false

function SWEP:DoCheapScope(fov, atttbl)
    if !self:ShouldDoScope() then
        render.PushRenderTarget(rtmat, 0, 0, rtsize, rtsize)
        render.Clear(0, 0, 0, 255, true, true)
        render.PopRenderTarget()

        return
    end

    if !hascostscoped then
        self:DoRT(fov, atttbl)
        hascostscoped = true
    end

    ARC9:DrawPhysBullets()

    self:DrawLockOnHUD(true)

    render.UpdateScreenEffectTexture()
    render.UpdateFullScreenDepthTexture()
    local screen = render.GetScreenEffectTexture()

    render.CopyTexture( screen, rtmat_spare )

    local scrw = ScrW()
    local scrh = ScrH()

    scrw = scrw
    scrh = scrh * scrh / scrw

    local s = self:GetCheapScopeScale(atttbl.ScopeScreenRatio)

    local scrx = (ScrW() - scrw * s) / 2
    local scry = (ScrH() - scrh * s) / 2

    -- scrx = scrx + 8
    -- scry = scry + 8

    cam.Start3D()
    if atttbl.RTScopeFLIR then
        self:DoFLIR(atttbl)
    end
    cam.End3D()

    local sighttbl = self:GetSight()

    render.PushRenderTarget(rtmat, 0, 0, rtsize, rtsize)

    -- cam.Start2D()

    render.DrawTextureToScreenRect(screen, scrx, scry, scrw * s, scrh * s)
    -- render.DrawTextureToScreenRect(ITexture tex, number x, number y, number width, number height)
    -- cam.End2D()

    cam.Start3D(nil, nil, fov, 0, 0, rtsize, rtsize)
        cam.IgnoreZ(true)
        self:DrawLasers(false, true)
        cam.IgnoreZ(false)
    cam.End3D()

    if atttbl.RTScopeNightVision then
        self:DoNightScopeEffects(atttbl)
    end

    self:DoRTScopeEffects()

    render.PopRenderTarget()

    render.DrawTextureToScreen(rtmat_spare)
    render.UpdateFullScreenDepthTexture()

    if sighttbl.InvertColors then

        render.PushRenderTarget(rtmat, 0, 0, rtsize, rtsize)

            render.CopyTexture( rtmat, rtmat_spare )

            render.Clear(255, 255, 255, 255, true, true)
            render.OverrideBlend(true, BLEND_ONE, BLEND_ONE, BLENDFUNC_REVERSE_SUBTRACT)

            render.DrawTextureToScreen(rtmat_spare)

            render.OverrideBlend(false)

        render.PopRenderTarget()
    end
end
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/cl_wm.lua:
function SWEP:DrawWorldModel()
    local owner = self:GetOwner()

    if !self.MirrorVMWM or (!IsValid(owner) and self.MirrorVMWMHeldOnly) then
        self:DrawModel()
        return
    end

    self:DrawCustomModel(true)


    if IsValid(owner) and owner:GetActiveWeapon() == self then -- gravgun moment
        self:DoBodygroups(true)
        self:DrawLasers(true)
        self:DoTPIK()
        self:DrawFlashlightsWM()
    end
end

--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/sh_animtranslate.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/sh_cycle.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/sh_deploy.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/sh_elements.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/sh_recoil.lua:
SWEP.RecoilPatternCache = {}

-- Unfortunately, this file is loaded before sh_stats,
-- so we do not know about this function at this time
local swepGetProcessedValue

local isSingleplayer = game.SinglePlayer()

function SWEP:GetRecoilPatternDirection(shot)
    local dir = 0

    local seed = self:GetProcessedValue("RecoilSeed", true) or self:GetClass()

    if isstring(seed) then
        local numseed = 0

        for _, i in ipairs(string.ToTable(seed)) do
            numseed = numseed + string.byte(i)
        end

        numseed = numseed % 16777216

        seed = numseed
    end

    seed = seed + shot

    if self:GetProcessedValue("RecoilLookupTable", true) then
        dir = self:PatternWithRunOff(self:GetProcessedValue("RecoilLookupTable", true), self:GetProcessedValue("RecoilLookupTableOverrun", true) or self:GetProcessedValue("RecoilLookupTable", true), shot)
    else
        if self.RecoilPatternCache[shot] then
            dir = self.RecoilPatternCache[shot]
        else
            self.RecoilPatternCache[1] = 0
            if self.RecoilPatternCache[shot - 1] then
                dir = self.RecoilPatternCache[shot - 1]
                math.randomseed(seed)
                local drift = self:GetValue("RecoilPatternDrift")
                dir = dir + math.Rand(-drift, drift)
                math.randomseed(CurTime() + self:EntIndex())
                self.RecoilPatternCache[shot] = dir
            else
                dir = 0
            end
        end
    end

    dir = self:RunHook("Hook_ModifyRecoilDir", dir) or dir

    return dir
end

local recoilshake = GetConVar("arc9_recoilshake")

function SWEP:ApplyRecoil()
    local rec = self:GetRecoilAmount()

    local rps = self:GetProcessedValue("RecoilPerShot", true)

    rec = math.Clamp(rec + rps, 0, self:GetProcessedValue("RecoilMax", true) or math.huge)

    local recoilup = 0
    local recoilside = 0

    local shot = math.floor(self:GetRecoilAmount()) + 1

    local dir = self:GetRecoilPatternDirection(shot)

    dir = dir - 90

    dir = math.rad(dir)

    recoilup = math.sin(dir)
    recoilside = math.cos(dir)

    local randomrecoilup = util.SharedRandom("arc9_recoil_up_r", -1, 0)
    local randomrecoilside = util.SharedRandom("arc9_recoil_side_r", -1, 1)

    recoilup = recoilup * self:GetProcessedValue("RecoilUp")
    recoilside = recoilside * self:GetProcessedValue("RecoilSide")

    randomrecoilup = randomrecoilup * self:GetProcessedValue("RecoilRandomUp")
    randomrecoilside = randomrecoilside * self:GetProcessedValue("RecoilRandomSide")

    recoilup = recoilup + randomrecoilup
    recoilside = recoilside + randomrecoilside

    local pvrec = self:GetProcessedValue("Recoil")

    recoilup = recoilup * (pvrec or 0)
    recoilside = recoilside * (pvrec or 0)

    self:SetRecoilUp(recoilup)
    self:SetRecoilSide(recoilside)

    -- self:SetRecoilDirection(-90)
    self:SetRecoilAmount(rec)

    self:SetLastRecoilTime(CurTime())

    local pbf = self:GetProcessedValue("PushBackForce", true)

    local owner = self:GetOwner()

    if pbf != 0 then
        owner:SetVelocity(self:GetShootDir():Forward() * -pbf)
    end

    -- local vis_kick = self:GetProcessedValue("RecoilKick")
    -- local vis_shake = 0

    -- vis_kick = vis_kick * rps
    -- vis_shake = vis_kick * rps

    -- local vis_kick_v = vis_kick * 0.5
    -- local vis_kick_h = vis_kick * util.SharedRandom("ARC9_vis_kick_h", -1, 1)
    -- vis_shake = vis_shake * util.SharedRandom("ARC9_vis_kick_shake", -1, 1)

    -- owner:SetViewPunchAngles(Angle(vis_kick_v, vis_kick_h, vis_shake))

    if recoilshake:GetBool() then
        owner:SetFOV(owner:GetFOV() * 0.99, 0)
        owner:SetFOV(0, 60 / (self:GetProcessedValue("RPM")))
    end
end

-- local function lensqr(ang)
--     return (ang[1] ^ 2) + (ang[2] ^ 2) + (ang[3] ^ 2)
-- end
-- :troll:
local function twoLenSqr(ang1, ang2)
    return (ang1[1] ^ 2) + (ang1[2] ^ 2) + (ang1[3] ^ 2) + (ang2[1] ^ 2) + (ang2[2] ^ 2) + (ang2[3] ^ 2)
end

-- scraped from source SDK 2013, just like this viewpunch damping code
-- local PUNCH_DAMPING = 6
local PUNCH_SPRING_CONSTANT = 120
local POS_PUNCH_DAMPING = 20
local POS_PUNCH_CONSTANT = 90

local ang0 = Angle(0, 0, 0)
local vec0 = Vector(0, 0, 0)

do
    local min, max = math.min, math.max

    -- Our math.Clamp is faster because:
    -- 1. it is local (welcome to lua)
    -- 2. min and max inside are local (WELCOME to lua + fake for the original function)
    local function math_Clamp(val, low, high)
        return min(max(val, low), high)
    end

    local VECTOR = FindMetaTable("Vector")
    local vectorSub = VECTOR.Sub
    local vectorAdd = VECTOR.Add
    local vectorMul = VECTOR.Mul

    local ANGLE = FindMetaTable("Angle")
    local angleSub = ANGLE.Sub
    local angleAdd = ANGLE.Add
    local angleMul = ANGLE.Mul

    local function vectorTranspose(ang)
        return Vector(ang[1], ang[2], ang[3])
    end

    local function angleTranspose(vec)
        return Angle(vec[1], vec[2], vec[3])
    end

    local weirdfix = true

    function SWEP:ThinkVisualRecoil()
        --if SERVER and !self.PhysicalVisualRecoil then return end

        local MAGIC1 = 210
        local MAGIC2 = 210
        if weirdfix then
            MAGIC1 = 210 / (engine.TickInterval() / 0.015)
            MAGIC2 = 210 / (engine.TickInterval() / 0.015)
        end

        local ft = FrameTime()

        local springconstant = swepGetProcessedValue(self, "VisualRecoilDampingConst", true) or 120
        local springmagnitude = swepGetProcessedValue(self, "VisualRecoilSpringMagnitude", true) or 1
        local springdamping = swepGetProcessedValue(self, "VisualRecoilSpringPunchDamping", true) or 6

        if self.VisualRecoilThinkFunc then
            springconstant, springmagnitude, springdamping = self.VisualRecoilThinkFunc(springconstant, springmagnitude, springdamping, self:GetRecoilAmount())
        end

        local vpa = self:GetVisualRecoilPos()
        local vpv = self:GetVisualRecoilPosVel()
        local vpc = self:GetVisualRecoilPosAcc()

        vpa = vpa + (vpv * ft) + (vpc * ft * ft * 0.5)
        local vpdrag = -(vpv * vpv:Length() * 0.5)
        local vpreturn = (-vpa * vpa:Length() * springconstant) + (-vpa / vpa:Length() * springmagnitude) + (-vpv * springdamping)
        local new_vpc = vpdrag + vpreturn
        vpv = vpv + ((vpc + new_vpc) * (ft * 0.5))

        for i = 1, 3 do
            vpa[i] = math_Clamp(vpa[i], -MAGIC1, MAGIC1)
            vpv[i] = math_Clamp(vpv[i], -MAGIC1, MAGIC1)
            new_vpc[i] = math_Clamp(new_vpc[i], -MAGIC1, MAGIC1)
        end

        self:SetVisualRecoilPos(vpa)
        self:SetVisualRecoilPosAcc(new_vpc)
        self:SetVisualRecoilPosVel(vpv)

        -- New spring algorithm using the velocity Verlet integration

        local vaa = self:GetVisualRecoilAng()
        local vav = self:GetVisualRecoilVel()
        local vac = self:GetVisualRecoilAcc()

        vaa = vaa + (vav * ft) + (vac * ft * ft * 0.5)
        local vdrag = -(vav * vav:Length() * 0.5)
        local vreturn = (-vaa * vaa:Length() * springconstant) + (-vaa / vaa:Length() * springmagnitude) + (-vav * springdamping)
        local new_vac = vdrag + vreturn
        vav = vav + ((vac + new_vac) * (ft * 0.5))

        for i = 1, 3 do
            vaa[i] = math_Clamp(vaa[i], -MAGIC2, MAGIC2)
            vav[i] = math_Clamp(vav[i], -MAGIC2, MAGIC2)
            new_vac[i] = math_Clamp(new_vac[i], -MAGIC2, MAGIC2)
        end

        self:SetVisualRecoilAng(vaa)
        self:SetVisualRecoilAcc(new_vac)
        self:SetVisualRecoilVel(vav)
    end
end

do
    local weaponGetNextPrimaryFire = FindMetaTable("Weapon").GetNextPrimaryFire
    local swepThinkVisualRecoil = SWEP.ThinkVisualRecoil

    local smolnumber = 1e-5

    function SWEP:ThinkRecoil()
        local ru = self.dt.RecoilUp
        local rs = self.dt.RecoilSide

        swepGetProcessedValue = swepGetProcessedValue or self.GetProcessedValue

		swepThinkVisualRecoil(self)

        if math.abs(ru) < smolnumber and math.abs(rs) < smolnumber and self.dt.RecoilAmount == 0 then return end

        local rdr = swepGetProcessedValue(self, "RecoilDissipationRate", true)
        local ct = CurTime()
        local ft = FrameTime()

        if (weaponGetNextPrimaryFire(self) + swepGetProcessedValue(self, "RecoilResetTime", true)) < ct then
            -- as soon as dissipation kicks in, recoil is clamped to the modifer cap; this is to not break visual recoil
            self:SetRecoilAmount(math.Clamp(self.dt.RecoilAmount - (ft * rdr), 0, swepGetProcessedValue(self, "UseVisualRecoil", true) and math.huge or swepGetProcessedValue(self, "RecoilModifierCap", true)))
            if weaponGetNextPrimaryFire(self) + swepGetProcessedValue(self, "RecoilFullResetTime", true) < ct then
                self:SetRecoilAmount(0)
            end
            -- print(math.Round(rec))
        end

        if math.abs(ru) > smolnumber or math.abs(rs) > smolnumber then
            local new_ru = ru - (ft * ru * 10)
            local new_rs = rs - (ft * rs * 10)

            self:SetRecoilUp(new_ru)
            self:SetRecoilSide(new_rs)
        end

    end
end

local lastrft = 0
local realrecoilconvar = GetConVar("arc9_realrecoil")

function SWEP:DoVisualRecoil()
    if !self:GetProcessedValue("UseVisualRecoil", true) then return end

    if isSingleplayer then self:CallOnClient("DoVisualRecoil") end

    if isSingleplayer or (!isSingleplayer and (SERVER or (CLIENT and IsFirstTimePredicted()))) then
        local mult = self:GetProcessedValue("VisualRecoil")

        local up = self:GetProcessedValue("VisualRecoilUp") * mult

        if self:GetProcessedValue("RecoilLookupTable", true) then
            local dir = self:PatternWithRunOff(self:GetProcessedValue("RecoilLookupTable", true), self:GetProcessedValue("RecoilLookupTableOverrun", true) or self:GetProcessedValue("RecoilLookupTable", true), math.floor(self:GetRecoilAmount()) + 1)
            up = up * self:GetRecoilUp() * -20 * (math.sin(math.rad(dir-90)) * -1)
        end

        local side = self:GetProcessedValue("VisualRecoilSide") * mult * self:GetRecoilSide()
        local roll = self:GetProcessedValue("VisualRecoilRoll") * util.SharedRandom("ARC9VisualRecoil", -1, 1) * 0.1 * mult
        local punch = self:GetProcessedValue("VisualRecoilPunch") * mult

        if self.VisualRecoilDoingFunc then
            up, side, roll, punch = self.VisualRecoilDoingFunc(up, side, roll, punch, self:GetRecoilAmount(), self)
        end

        local fake = 0

        fake = self:GetProcessedValue("VisualRecoilPositionBump", true) or 1.5

        local isRTscoped = CLIENT and self:GetSight() and self:GetSight().atttbl and self:GetSight().atttbl.RTScope -- horible

        local bumpup = (isRTscoped and self:GetProcessedValue("VisualRecoilPositionBumpUpRTScope", true) or self:GetProcessedValue("VisualRecoilPositionBumpUp", true)) or 0.08

        fake = Lerp(self:GetSightDelta(), fake, 1)

        fake = fake * 0.66

        if realrecoilconvar:GetBool() then
            self:SetVisualRecoilAng(self:GetVisualRecoilAng() + Vector(up, side * 15, roll))
            self:SetVisualRecoilPos(self:GetVisualRecoilPos() - ((Vector(0, punch, up * bumpup) * fake) - Vector(side, 0, 0)))
        end

    end
end

local magicmult = 2.5

function SWEP:GetViewModelRecoil(pos, ang, correct)
    correct = correct or 1
    if !isSingleplayer and SERVER then return end
    if !self:GetProcessedValue("UseVisualRecoil", true) then return pos, ang end
    local vrc = self:GetProcessedValue("VisualRecoilCenter", true)

    local vra = self:GetVisualRecoilAng()

    vra = Angle(vra[1], vra[2], vra[3]) * (self.VisualRecoilEmergency or magicmult)

    vra.y = -vra.y

    pos, ang = self:RotateAroundPoint(pos, ang, vrc, self:GetVisualRecoilPos(), vra * correct)

    if ARC9.Dev(2) then
        debugoverlay.Axis(self:GetVM():LocalToWorld(self:GetProcessedValue("VisualRecoilCenter", true)), ang, 2, 0.1, true)
    end

    return pos, ang
end


function SWEP:GetRecoilOffset(pos, ang)
    if !self.PhysicalVisualRecoil or !realrecoilconvar:GetBool() then return pos, ang end
    if !self:GetProcessedValue("UseVisualRecoil", true) then return pos, ang end

    local vrp = self:GetVisualRecoilPos()
    local vra = self:GetVisualRecoilAng()

    vra = Angle(vra[1], vra[2], vra[3]) * magicmult

    local vrc = self:GetProcessedValue("VisualRecoilCenter", true)

    pos, ang = self:RotateAroundPoint2(pos, ang, vrc, vrp, vra)

    return pos, ang
end
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/sh_sway.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/sh_sway.lua:
SWEP.SetBreathDSP = false

local sfxconvar = GetConVar("arc9_breath_sfx")
local slomoconvar = GetConVar("arc9_breath_slowmo")
local togglconvar = GetConVar("arc9_togglebreath")
local ppconvar = GetConVar("arc9_breath_pp")
local hudconvar = GetConVar("arc9_breath_hud")
local swayconvar = GetConVar("arc9_mod_sway")

function SWEP:ThinkHoldBreath()
    if !self:GetOwner():IsPlayer() then return end
    local holdbreathtime = self:GetValue("HoldBreathTime")
    if holdbreathtime <= 0 then return end

    local sfx = sfxconvar:GetBool()

    local target_ts = 1

    if self:HoldingBreath() then
        self:SetBreath(self:GetBreath() - (FrameTime() * 100 / holdbreathtime))
        if self:GetBreath() < 0 then
            self:SetOutOfBreath(true)
            self:SetBreath(0)
            self.IsHoldingBreath = false

            if sfx then
                local soundtab = {
                    name = "breathrunout",
                    sound = self:RandomChoice(self:GetProcessedValue("BreathRunOutSound", true)),
                    channel = ARC9.CHAN_BREATH
                }
                
                self.BreathOutPlayed = true
                self.BreathInPlayed = nil
                if CLIENT then self:PlayTranslatedSound(soundtab) end

                -- if self.SetBreathDSP then
                --     self:GetOwner():SetDSP(0)
                --     self.SetBreathDSP = false
                -- end
            end
        else
            target_ts = Lerp(1 - (self:GetBreath() / 100), 0.33, 0.25)
            if sfx and !self.BreathInPlayed then
            -- if sfx and !self.SetBreathDSP then
                -- self:GetOwner():SetDSP(30)
                -- self.SetBreathDSP = true
                
                self.BreathInPlayed = true
                self.BreathOutPlayed = nil

                local soundtab = {
                    name = "breathin",
                    sound = self:RandomChoice(self:GetProcessedValue("BreathInSound", true)),
                    channel = ARC9.CHAN_BREATH
                }

                if CLIENT then self:PlayTranslatedSound(soundtab) end
            end
        end
    else
        if sfx and !self.BreathOutPlayed and !self:GetOutOfBreath() then
        -- if sfx and self.SetBreathDSP then
            -- self:GetOwner():SetDSP(0)
            -- self.SetBreathDSP = false
            local soundtab = {
                name = "breathout",
                sound = self:RandomChoice(self:GetProcessedValue("BreathOutSound", true)),
                channel = ARC9.CHAN_BREATH
            }

            self.BreathOutPlayed = true
            self.BreathInPlayed = nil

            if CLIENT then self:PlayTranslatedSound(soundtab) end
        end

        self:SetBreath(self:GetBreath() + (FrameTime() * 100 / self:GetProcessedValue("RestoreBreathTime", true)))
        if self:GetBreath() >= 100 then
            self:SetBreath(100)
            self:SetOutOfBreath(false)
        end
    end

    if game.SinglePlayer() and SERVER and slomoconvar:GetBool() then
        local ts = game.GetTimeScale()

        ts = math.Approach(ts, target_ts, FrameTime() / ts / 0.5)
        game.SetTimeScale(ts)
        Entity(1):SetLaggedMovementValue(1 + ((1-ts)*2))
    end
end

function SWEP:CanHoldBreath()
    return self:GetBreath() > 0 and !self:GetOutOfBreath()
end

local lastpressed = false
SWEP.IsHoldingBreath = false

function SWEP:HoldingBreath()
    if self:GetSightAmount() < 0.05 then self.IsHoldingBreath = false return end

    local ownerkeydownspeed = self:GetOwner():KeyDown(IN_SPEED)

    if togglconvar:GetBool() then
        if ownerkeydownspeed and !lastpressed then
            self.IsHoldingBreath = !self.IsHoldingBreath
        end
    else
        self.IsHoldingBreath = ownerkeydownspeed
    end

    lastpressed = ownerkeydownspeed
    
    return self:CanHoldBreath() and self.IsHoldingBreath and (self:GetSightAmount() >= 1) and self:GetValue("HoldBreathTime") > 0
end

local pp_amount = 0

function SWEP:HoldBreathPP()
    if self:GetValue("HoldBreathTime") <= 0 then return end
    if !ppconvar:GetBool() then return end
    local amt_d = (100 - self:GetBreath()) / 100
    local holding = self:HoldingBreath()
    local out = self:GetOutOfBreath()

    local target = 0

    if holding then target = 0.5 end

    pp_amount = math.Approach(pp_amount, target, FrameTime() / 0.25)

    DrawSharpen((0.5 * pp_amount) + (1.2 * amt_d), 2 * pp_amount)

    local tint = Color(253, 255, 255)

    local tab = {
        [ "$pp_colour_addr" ] = (-1 + (tint.r / 255)) * pp_amount,
        [ "$pp_colour_addg" ] = (-1 + (tint.g / 255)) * pp_amount,
        [ "$pp_colour_addb" ] = (-1 + (tint.b / 255)) * pp_amount,
        [ "$pp_colour_brightness" ] = pp_amount * -0.05,
        [ "$pp_colour_contrast" ] = 1 + (0.2 * pp_amount),
        [ "$pp_colour_colour" ] = 1 - (amt_d * 0.25),
        [ "$pp_colour_mulr" ] = 0,
        [ "$pp_colour_mulg" ] = 0,
        [ "$pp_colour_mulb" ] = 0
    }
    DrawColorModify(tab)
end

function SWEP:HoldBreathHUD()
    if self:GetSightAmount() < 1 then return end
    if self:GetValue("HoldBreathTime") <= 0 then return end

    if !hudconvar:GetBool() then return end

    local amt = self:GetBreath() / 100

    if amt == 1 then return end

    local bar_w = ScreenScale(48)
    local bar_h = ScreenScale(4)
    local bar_y = ScreenScale(92)
    -- local ss_x = ScreenScale(1)
    -- local ss_y = ScreenScale(1)

    -- surface.SetDrawColor(ARC9.GetHUDColor("shadow"))
    -- surface.DrawOutlinedRect((ScrW() - bar_w) / 2 + ss_x, ScrH() / 2 + bar_y + ss_y, bar_w, bar_h)
    -- surface.DrawRect((ScrW() - bar_w) / 2 + ss_x, ScrH() / 2 + bar_y + ss_y, bar_w * amt, bar_h)
    local a = (1 - math.max(amt, 0.9)) * 255*10
    surface.SetDrawColor(ARC9.GetHUDColor("shadow", a*0.5))
    surface.DrawRect((ScrW() - bar_w) / 2, ScrH() - bar_y, bar_w, bar_h)
    surface.SetDrawColor(ARC9.GetHUDColor("fg", a))
    surface.DrawOutlinedRect((ScrW() - bar_w) / 2, ScrH() - bar_y, bar_w, bar_h)
    -- surface.SetDrawColor(ARC9.GetHUDColor("hi", a))
    -- surface.DrawRect((ScrW() - bar_w) / 2 + bar_w * amt, ScrH() - bar_y, bar_w * (1-amt), bar_h)
    surface.SetDrawColor(ARC9.GetHUDColor("hi", a))
    surface.DrawRect((ScrW() - bar_w) / 2, ScrH() - bar_y, bar_w * amt, bar_h)

    -- surface.SetTextColor(ARC9.GetHUDColor("fg"))
    -- surface.SetFont("ARC9_12")
    -- local text = "HOLD BREATH (" .. ARC9.GetBindKey("+speed") .. ")"
    -- local tw = surface.GetTextSize(text)
    -- surface.SetTextColor(ARC9.GetHUDColor("shadow"))
    -- surface.SetTextPos((ScrW() - tw) / 2 + ss_x, ScrH() / 2 + ScreenScale(20) + ss_y)
    -- surface.DrawText(text)

    -- surface.SetTextColor(ARC9.GetHUDColor("fg"))
    -- surface.SetTextPos((ScrW() - tw) / 2, ScrH() / 2 + ScreenScale(20))
    -- surface.DrawText(text)
end

function SWEP:GetFreeSwayAmount()
    if !swayconvar:GetBool() then return 0 end
    if !self:GetOwner():IsPlayer() then return 0 end
    local sway = self:GetProcessedValue("Sway")

    sway = math.Max(sway, 0)
    if sway == 0 then return 0 end
    
    if self:HoldingBreath() then return sway * 0.15 end

    if self:GetOutOfBreath() then
        sway = sway + ((1 - self:GetBreath() / 100) * 0.75)
    end

    return sway
end
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/sh_timers.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/sh_ubgl.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/sh_util.lua:
return gluapack()()
--PATH lua/weapons/arccw_base/cl_light.lua:
SWEP.Flashlights = {} -- tracks projectedlights
-- {{att = int, light = ProjectedTexture}}
SWEP.CheapFlashlights = {} -- tracks cheap flashlight models + lights
-- {{att = int, dlight = DynamicLight, vlight = ClientsideModel}}

function SWEP:GetHasFlashlights()
    for i, k in pairs(self.Attachments) do
        if !k.Installed then continue end
        if self:GetBuff_Stat("Flashlight", i) != nil then return true end
    end

    return false
end

function SWEP:CreateFlashlightsVM()
    self:KillFlashlights()
    self.Flashlights = {}

    local total_lights = 0

    for i, k in pairs(self.Attachments) do
        if !k.Installed then continue end
        if self:GetBuff_Stat("Flashlight", i) then
            local newlight = {
                att = i,
                light = ProjectedTexture(),
                bone = self:GetBuff_Stat("FlashlightBone", i) or "laser",
                col = self:GetBuff_Stat("FlashlightColor", i) or Color(255, 255, 255),
                br = self:GetBuff_Stat("FlashlightBrightness", i) or 2
            }
            total_lights = total_lights + 1

            local l = newlight.light
            if !IsValid(l) then continue end

            table.insert(self.Flashlights, newlight)

            l:SetFOV(self:GetBuff_Stat("FlashlightFOV", i) or 50)

            if self:GetBuff_Stat("FlashlightHFOV", i) then
                l:SetHorizontalFOV(self:GetBuff_Stat("FlashlightHFOV", i))
            end

            if self:GetBuff_Stat("FlashlightVFOV", i) then
                l:SetVerticalFOV(self:GetBuff_Stat("FlashlightVFOV", i))
            end

            l:SetFarZ(self:GetBuff_Stat("FlashlightFarZ", i) or 512)
            l:SetNearZ(self:GetBuff_Stat("FlashlightNearZ", i) or 4)

            local atten = self:GetBuff_Stat("FlashlightAttenuationType", i) or ArcCW.FLASH_ATT_LINEAR

            l:SetLinearAttenuation(0)
            l:SetConstantAttenuation(0)
            l:SetQuadraticAttenuation(0)

                if atten == ArcCW.FLASH_ATT_CONSTANT then
                    l:SetConstantAttenuation(100)
                elseif atten == ArcCW.FLASH_ATT_QUADRATIC then
                    l:SetQuadraticAttenuation(100)
                else
                    l:SetLinearAttenuation(100)
                end

            l:SetColor(self:GetBuff_Stat("FlashlightColor", i) or Color(255, 255, 255))
            l:SetTexture(self:GetBuff_Stat("FlashlightTexture", i))
            l:SetBrightness(self:GetBuff_Stat("FlashlightBrightness", i))
            l:SetEnableShadows(true)
            l:Update()

            local g_light = {
                Weapon = self,
                ProjectedTexture = l
            }

            table.insert(ArcCW.FlashlightPile, g_light)
        end
    end

    if total_lights > 2 then -- you are a madman
        for i, k in pairs(self.Flashlights) do
            if k.light:IsValid() then k.light:SetEnableShadows(false) end
        end
    end
end

-- for world model flashlights we will use a cheap solution similar to what HL2 uses
-- throw up a volumetric light model
-- function SWEP:CreateFlashlightsWM()
--     self:KillFlashlights()
--     self.CheapFlashlights = {}
--     for i, k in pairs(self.Attachments) do
--         if !k.Installed then continue end
--         local atttbl = ArcCW.AttachmentTable[k.Installed]

--         if atttbl.Flashlight then
--             local newlight = {
--                 att = i,
--                 vlight = ClientsideModel(ArcCW.VolumetricLightModel),
--                 scale_x = 1,
--                 scale_y = 1,
--                 maxz = atttbl.FlashlightFarZ or 512,
--                 bone = atttbl.FlashlightBone or "laser",
--                 col = Color(255, 255, 255)
--             }

--             local vl = newlight.vlight

--             if !IsValid(vl) then continue end

--             table.insert(self.CheapFlashlights, newlight)

--             local xfov = atttbl.FlashlightHFOV or atttbl.FlashlightFOV or 50
--             local yfov = atttbl.FlashlightVFOV or atttbl.FlashlightFOV or 50

--             local target_x = 128 * (xfov / 90)
--             local target_y = 128 * (yfov / 90)

--             local scale_x = target_x / ArcCW.VolumetricLightX
--             local scale_y = target_y / ArcCW.VolumetricLightY

--             newlight.scale_x = scale_x
--             newlight.scale_y = scale_y

--             vl:SetNoDraw(ArcCW.NoDraw)
--             vl:DrawShadow(false)
--             local col = atttbl.FlashlightColor or Color(255, 255, 255)
--             col = Color(255, 0, 0)
--             newlight.col = col
--             -- vl:SetColor(col)

--             local g_light = {
--                 Model = vl,
--                 Weapon = self
--             }

--             table.insert(ArcCW.CSModelPile, g_light)
--         end
--     end
-- end

function SWEP:KillFlashlights()
    self:KillFlashlightsVM()
    -- self:KillFlashlightsWM()
end

function SWEP:KillFlashlightsVM()
    if !self.Flashlights then return end

    for i, k in pairs(self.Flashlights) do
        if k.light and k.light:IsValid() then
            k.light:Remove()
        end
    end

    self.Flashlights = nil
end

function SWEP:KillFlashlightsWM()
    -- if !self.CheapFlashlights then return end

    -- for i, k in pairs(self.CheapFlashlights) do
    --     if k.vlight and k.vlight:IsValid() then
    --         k.vlight:Remove()
    --     end
    -- end

    -- self.CheapFlashlights = nil
end

-- given fov and distance solve apparent size
local function solvetriangle(angle, dist)
    local a = angle / 2
    local b = dist
    return b * math.tan(a) * 2
end

local flashlight_mat = Material("models/effects/vol_light002")
-- local flashlight_mat = Material("effects/blueblacklargebeam")

function SWEP:DrawFlashlightsWM()
    -- if !self.CheapFlashlights then
    --     self:CreateFlashlightsWM()
    -- end

    local owner = self:GetOwner()

    for i, k in pairs(self.Attachments) do
        if !k.Installed then continue end
        local atttbl = ArcCW.AttachmentTable[k.Installed]

        if !atttbl or !self:GetBuff_Stat("Flashlight", i) then continue end

        local maxz = atttbl.FlashlightFarZ or 512
        local bone = atttbl.FlashlightBone or "laser"
        local col = atttbl.FlashlightColor or Color(255, 255, 255)

        if !k.WElement then continue end
        local model = k.WElement.Model
        if !IsValid(model) then return end

        local pos, ang, dir

        if !model then
            pos = owner:EyePos()
            ang = owner:EyeAngles()
            dir = ang:Forward()
        else
            local att = model:LookupAttachment(bone or "laser")

            att = att == 0 and model:LookupAttachment("muzzle") or att

            if att == 0 then
                pos = model:GetPos()
                ang = IsValid(owner) and owner:EyeAngles() or model:GetAngles()
                dir = ang:Forward()
                dir_2 = ang:Up()
            else
                local attdata  = model:GetAttachment(att)
                pos, ang = attdata.Pos, attdata.Ang
                dir = -ang:Right()
                dir_2 = ang:Up()
            end
        end

        local maxs = Vector(2, 2, 2)
        local mins = -maxs

        -- scale volumetric light
        local tr = util.TraceHull({
            start = pos,
            endpos = pos + (dir * maxz),
            mask = MASK_OPAQUE,
            mins = mins,
            maxs = maxs
        })

        local z = (tr.HitPos - tr.StartPos):Length()
        -- local s_z = z / ArcCW.VolumetricLightZ

        local xfov = atttbl.FlashlightHFOV or atttbl.FlashlightFOV or 50
        local yfov = atttbl.FlashlightVFOV or atttbl.FlashlightFOV or 50

        -- local target_x = 128 * (xfov / 90)
        -- local target_y = 128 * (yfov / 90)

        local target_x = solvetriangle(xfov, z)
        local target_y = target_x

        if xfov != yfov then
            target_y = solvetriangle(yfov, z)
        end

        local vs = EyeAngles():Up()

        local c1 = pos + vs
        local c4 = pos - vs
        local c2 = tr.HitPos + (vs * target_y * 0.75)
        local c3 = tr.HitPos - (vs * target_y * 0.75)

        render.SetMaterial(flashlight_mat)
        render.DrawQuad(c1,c2,c3,c4, col)

        -- local scale = Matrix()
        -- scale:Scale(Vector(s_x, s_y, s_z))

        -- k.vlight:SetPos(pos)
        -- k.vlight:SetAngles(ang + Angle(0, 0, 90))
        -- k.vlight:EnableMatrix("RenderMultiply", scale)
        -- k.vlight:SetColor(Color(255, 0, 0, 255))
        -- k.vlight:SetRenderMode(RENDERMODE_NORMAL)
        -- k.vlight:SetKeyValue("RenderFX", kRenderFxNone)
        -- k.vlight:DrawModel()
        -- place dynamic light to make some light appear

        local dl = DynamicLight(self:EntIndex())

        local delta = (z / maxz)
        delta = math.Clamp(delta, 0, 1)

        if dl then
            dl.pos = tr.HitPos
            dl.r = col.r
            dl.g = col.g
            dl.b = col.b
            dl.brightness = Lerp(delta, atttbl.FlashlightBrightness or 2, 0)
            -- print(z / maxz)
            dl.Decay = 1000 / 1
            dl.dietime = CurTime() + 0.1
            dl.size = xfov * 5
        end
    end
end

function SWEP:DrawFlashlightsVM()
    if !self.Flashlights then
        self:CreateFlashlightsVM()
    end

    local owner = self:GetOwner()

    for i, k in pairs(self.Flashlights) do
        local model = (self.Attachments[k.att].VElement or {}).Model

        local pos, ang

        if !model then
            pos = owner:EyePos()
            ang = owner:EyeAngles()
        else
            local att = model:LookupAttachment(k.bone or "laser")

            att = att == 0 and model:LookupAttachment("muzzle") or att

            if att == 0 then
                pos = model:GetPos()
                ang = owner:EyeAngles()
            else
                local attdata  = model:GetAttachment(att)
                pos, ang = attdata.Pos, attdata.Ang
            end
        end

        local tr = util.TraceLine({
            start = owner:EyePos(),
            endpos = owner:EyePos() - ang:Right() * 128,
            mask = MASK_OPAQUE,
            filter = LocalPlayer(),
        })
        if tr.Fraction < 1 then -- We need to push the flashlight back
            local tr2 = util.TraceLine({
                start = owner:EyePos(),
                endpos = owner:EyePos() + ang:Right() * 128,
                mask = MASK_OPAQUE,
                filter = LocalPlayer(),
            })
            -- push it as back as the area behind us allows
            pos = pos + ang:Right() * 128 * math.min(1 - tr.Fraction, tr2.Fraction)
        end

        ang:RotateAroundAxis(ang:Up(), 90)

        k.light:SetPos(pos)
        k.light:SetAngles(ang)
        k.light:Update()

        -- local col = k.col

        -- local dl = DynamicLight(self:EntIndex())

        -- if dl then
        --     dl.pos = pos
        --     dl.r = col.r
        --     dl.g = col.g
        --     dl.b = col.b
        --     dl.brightness = k.br or 2
        --     -- print(z / maxz)
        --     dl.Decay = 1000 / 0.1
        --     dl.dietime = CurTime() + 0.1
        --     dl.size = (k.br or 2) * 64
        -- end
    end
end

--PATH lua/weapons/arccw_base/sh_anim.lua:
SWEP.Cam_Offset_Ang = nil --Angle(0, 0, 0)

function SWEP:SelectAnimation(anim)
    if self:GetNWState() == ArcCW.STATE_SIGHTS and self.Animations[anim .. "_iron"] then
        anim = anim .. "_iron"
    end

    if self:GetNWState() == ArcCW.STATE_SIGHTS and self.Animations[anim .. "_sights"] then
        anim = anim .. "_sights"
    end

    if self:GetNWState() == ArcCW.STATE_SIGHTS and self.Animations[anim .. "_sight"] then
        anim = anim .. "_sight"
    end

    if self:GetNWState() == ArcCW.STATE_SPRINT and self.Animations[anim .. "_sprint"] and !self:CanShootWhileSprint() then
        anim = anim .. "_sprint"
    end

    if self:InBipod() and self.Animations[anim .. "_bipod"] then
        anim = anim .. "_bipod"
    end

    if self:GetState() == ArcCW.STATE_CUSTOMIZE and self.Animations[anim .. "_inspect"] and ((CLIENT and !ArcCW.ConVars["noinspect"]:GetBool()) or (SERVER and self:GetOwner():GetInfoNum("arccw_noinspect", 0))) then
        anim = anim .. "_inspect"
    end

    if (self:Clip1() == 0 or (self:HasBottomlessClip() and self:Ammo1() == 0)) and self.Animations[anim .. "_empty"] then
        anim = anim .. "_empty"
    end

    if self:GetMalfunctionJam() and self.Animations[anim .. "_jammed"] then
        anim = anim .. "_jammed"
    end

    if self:GetBuff_Override("Override_TriggerDelay", self.TriggerDelay) and self:IsTriggerHeld() and self.Animations[anim .. "_trigger"] then
        anim = anim .. "_trigger"
    end

    if !self.Animations[anim] then return end

    return anim
end

SWEP.LastAnimStartTime = 0
SWEP.LastAnimFinishTime = 0

function SWEP:PlayAnimationEZ(key, mult, priority)
    return self:PlayAnimation(key, mult, true, 0, false, false, priority, false)
end

function SWEP:PlayAnimation(key, mult, pred, startfrom, tt, skipholster, priority, absolute)
    mult = mult or 1
    pred = pred or false
    startfrom = startfrom or 0
    tt = tt or false
    --skipholster = skipholster or false Unused
    priority = priority or false
    absolute = absolute or false
    if !key then return end

    local ct = CurTime()

    if self:GetPriorityAnim() and !priority then return end

    if game.SinglePlayer() and SERVER and pred then
        net.Start("arccw_sp_anim")
        net.WriteString(key)
        net.WriteFloat(mult)
        net.WriteFloat(startfrom)
        net.WriteBool(tt)
        --net.WriteBool(skipholster) Unused
        net.WriteBool(priority)
        net.Send(self:GetOwner())
    end

    local anim = self.Animations[key]
    if !anim then return end
    local tranim = self:GetBuff_Hook("Hook_TranslateAnimation", key)
    if self.Animations[tranim] then
        key = tranim
        anim = self.Animations[tranim]
    --[[elseif self.Animations[key] then -- Can't do due to backwards compatibility... unless you have a better idea?
        anim = self.Animations[key]
    else
        return]]
    end

    if anim.ViewPunchTable and CLIENT then
        for k, v in pairs(anim.ViewPunchTable) do

            if !v.t then continue end

            local st = (v.t * mult) - startfrom

            if isnumber(v.t) and st >= 0 and self:GetOwner():IsPlayer() and (game.SinglePlayer() or IsFirstTimePredicted()) then
                self:SetTimer(st, function() self:OurViewPunch(v.p or Vector(0, 0, 0)) end, id)
            end
        end
    end

    if isnumber(anim.ShellEjectAt) then
        self:SetTimer(anim.ShellEjectAt * mult, function()
            local num = 1
            if self.RevolverReload then
                num = self.Primary.ClipSize - self:Clip1()
            end
            for i = 1,num do
                self:DoShellEject()
            end
        end)
    end

    if !self:GetOwner() then return end
    if !self:GetOwner().GetViewModel then return end
    local vm = self:GetOwner():GetViewModel()

    if !vm then return end
    if !IsValid(vm) then return end

    local seq = anim.Source
    if anim.RareSource and util.SharedRandom("raresource", 0, 1, CurTime()) < (1 / (anim.RareSourceChance or 100)) then
        seq = anim.RareSource
    end
    seq = self:GetBuff_Hook("Hook_TranslateSequence", seq)

    if istable(seq) then
        seq["BaseClass"] = nil
        seq = seq[math.Round(util.SharedRandom("randomseq" .. CurTime(), 1, #seq))]
    end

    if isstring(seq) then
        seq = vm:LookupSequence(seq)
    end

    local time = absolute and 1 or self:GetAnimKeyTime(key)
    --if time == 0 then return end

    local ttime = (time * mult) - startfrom
    if startfrom > (time * mult) then return end

    if tt then
        self:SetNextPrimaryFire(ct + ((anim.MinProgress or time) * mult) - startfrom)
    end

    if anim.LHIK then
        self.LHIKStartTime = ct
        self.LHIKEndTime = ct + ttime

        if anim.LHIKTimeline then
            self.LHIKTimeline = {}

            for i, k in pairs(anim.LHIKTimeline) do
                table.Add(self.LHIKTimeline, {t = (k.t or 0) * mult, lhik = k.lhik or 1})
            end
        else
            self.LHIKTimeline = {
                {t = -math.huge, lhik = 1},
                {t = ((anim.LHIKIn or 0.1) - (anim.LHIKEaseIn or anim.LHIKIn or 0.1)) * mult, lhik = 1},
                {t = (anim.LHIKIn or 0.1) * mult, lhik = 0},
                {t = ttime - ((anim.LHIKOut or 0.1) * mult), lhik = 0},
                {t = ttime - (((anim.LHIKOut or 0.1) - (anim.LHIKEaseOut or anim.LHIKOut or 0.1)) * mult), lhik = 1},
                {t = math.huge, lhik = 1}
            }

            if anim.LHIKIn == 0 then
                self.LHIKTimeline[1].lhik = -math.huge
                self.LHIKTimeline[2].lhik = -math.huge
            end

            if anim.LHIKOut == 0 then
                self.LHIKTimeline[#self.LHIKTimeline - 1].lhik = math.huge
                self.LHIKTimeline[#self.LHIKTimeline].lhik = math.huge
            end
        end
    else
        self.LHIKTimeline = nil
    end

    if anim.LastClip1OutTime then
        self.LastClipOutTime = ct + ((anim.LastClip1OutTime * mult) - startfrom)
    end

    if anim.TPAnim then
        local aseq = self:GetOwner():SelectWeightedSequence(anim.TPAnim)
        if aseq then
            self:GetOwner():AddVCDSequenceToGestureSlot( GESTURE_SLOT_ATTACK_AND_RELOAD, aseq, anim.TPAnimStartTime or 0, true )
            if !game.SinglePlayer() and SERVER then
                net.Start("arccw_networktpanim")
                    net.WriteEntity(self:GetOwner())
                    net.WriteUInt(aseq, 16)
                    net.WriteFloat(anim.TPAnimStartTime or 0)
                net.SendPVS(self:GetOwner():GetPos())
            end
        end
    end

    if !(game.SinglePlayer() and CLIENT) and (game.SinglePlayer() or IsFirstTimePredicted() or self.ReadySoundTableHack) then
        self:PlaySoundTable(anim.SoundTable or {}, 1 / mult, startfrom, key)
        self.ReadySoundTableHack = nil
    end

    if seq then
        vm:SendViewModelMatchingSequence(seq)
        local dur = vm:SequenceDuration()
        vm:SetPlaybackRate(math.Clamp(dur / (ttime + startfrom), -4, 12))
        self.LastAnimStartTime = ct
        self.LastAnimFinishTime = ct + dur
        self.LastAnimKey = key
    end

    -- Grabs the current angle of the cam attachment bone and use it as the common offset for all cambone changes.
    -- Problem: If this animation interrupted a previous animation with cambone movement,
    -- it will start with an incorrect offset and snap at the end.
    -- Therefore this now only ever sets it once.
    local att = self:GetBuff_Override("Override_CamAttachment", self.CamAttachment)
    if att and vm:GetAttachment(att) and (anim.ForceCamReset or self.Cam_Offset_Ang == nil) then
        local ang = vm:GetAttachment(att).Ang
        ang = vm:WorldToLocalAngles(ang)
        self.Cam_Offset_Ang = Angle(ang)
    end

    self:SetNextIdle(CurTime() + ttime)

    return true
end

function SWEP:PlayIdleAnimation(pred)
    local ianim = self:SelectAnimation("idle")
    if self:GetGrenadePrimed() then
        ianim = self:GetGrenadeAlt() and self:SelectAnimation("pre_throw_hold_alt") or self:SelectAnimation("pre_throw_hold")
    end

    -- (key, mult, pred, startfrom, tt, skipholster, ignorereload)
    if self:GetBuff_Override("UBGL_BaseAnims") and self:GetInUBGL()
            and self.Animations.idle_ubgl_empty and self:Clip2() <= 0 then
        ianim = "idle_ubgl_empty"
    elseif self:GetBuff_Override("UBGL_BaseAnims") and self:GetInUBGL() and self.Animations.idle_ubgl then
        ianim = "idle_ubgl"
    end

    if self.LastAnimKey ~= ianim then
        ianim = self:GetBuff_Hook("Hook_IdleReset", ianim) or ianim
    end

    self:PlayAnimation(ianim, 1, pred, nil, nil, nil, true)
end

function SWEP:GetAnimKeyTime(key, min)
    if !self:GetOwner() then return 1 end

    local anim = self.Animations[key]

    if !anim then return 1 end

    if self:GetOwner():IsNPC() then return anim.Time or 1 end

    local vm = self:GetOwner():GetViewModel()

    if !vm or !IsValid(vm) then return 1 end

    local t = anim.Time
    if !t then
        local tseq = anim.Source

        if istable(tseq) then
            tseq["BaseClass"] = nil -- god I hate Lua inheritance
            tseq = tseq[1]
        end

        if !tseq then return 1 end
        tseq = vm:LookupSequence(tseq)

        -- to hell with it, just spits wrong on draw sometimes
        t = vm:SequenceDuration(tseq) or 1
    end

    if min and anim.MinProgress then
        t = anim.MinProgress
    end

    if anim.Mult then
        t = t * anim.Mult
    end

    return t
end

if CLIENT then
    net.Receive("arccw_networktpanim", function()
        local ent = net.ReadEntity()
        local aseq = net.ReadUInt(16)
        local starttime = net.ReadFloat()
        if IsValid(ent) and ent ~= LocalPlayer() and ent:IsPlayer() then
            ent:AddVCDSequenceToGestureSlot( GESTURE_SLOT_ATTACK_AND_RELOAD, aseq, starttime, true )
        end
    end)
end

function SWEP:QueueAnimation() end
function SWEP:NextAnimation() end

--PATH lua/weapons/arccw_base/sh_bash.lua:
function SWEP:CanBackstab(melee2, ent)
    if !self:GetBuff_Override("Override_Backstab", self.Backstab) then return false end
    local reach = 32 + self:GetBuff_Add("Add_MeleeRange") + (melee2 and self.Melee2Range or self.MeleeRange)

    if (!IsValid(ent)) then
        local tr = util.TraceLine({
            start = self:GetOwner():GetShootPos(),
            endpos = self:GetOwner():GetShootPos() + self:GetOwner():GetAimVector() * reach,
            filter = {self:GetOwner()},
            mask = MASK_SHOT_HULL
        })
        if tr.Entity:IsPlayer() or tr.Entity:IsNPC() or tr.Entity:IsNextBot() then
            ent = tr.Entity
        end
    end

    if (!IsValid(ent)) then
        local tr = util.TraceHull({
            start = self:GetOwner():GetShootPos(),
            endpos = self:GetOwner():GetShootPos() + self:GetOwner():GetAimVector() * reach,
            filter = {self:GetOwner()},
            mins = Vector(-16, -16, -8),
            maxs = Vector(16, 16, 8),
            mask = MASK_SHOT_HULL
        })
        if tr.Entity:IsPlayer() or tr.Entity:IsNPC() or tr.Entity:IsNextBot() then
            ent = tr.Entity
        end
    end

    if IsValid(ent) then
        local angle = math.NormalizeAngle(self:GetOwner():GetAngles().y - ent:GetAngles().y)
        return angle <= 90 and angle >= -90
    end

    return false
end

function SWEP:DoLunge(melee2)
    if ArcCW.ConVars["override_lunge_off"]:GetBool() then return end
    local var = self:GetBuff_Override("Override_Lunge", self.Lunge)
    if var == false or var == nil and self.PrimaryBash then return end
    if !self:GetOwner():IsPlayer() or self:GetOwner():Crouching() then return end

    local reach = 32 + self:GetBuff_Add("Add_MeleeRange") + (melee2 and self.Melee2Range or self.MeleeRange)
    local tr = self:GetOwner():GetEyeTrace()
    local tgt = tr.Entity

    if IsValid(tgt) and (tgt:IsPlayer() or tgt:IsNPC() or tgt:IsNextBot()) then

        local dist = (tr.HitPos - tr.StartPos):Length()

        if dist > reach and dist < reach + self:GetBuff("LungeLength") then
            local dir = tr.Normal
            dir.z = math.min(dir.z, 0)
            dir:Normalize()
            self:GetOwner():SetVelocity(dir * (self:GetOwner():IsOnGround() and 5 or 2.5) * dist)
        end
    end
end

function SWEP:Bash(melee2)
    melee2 = melee2 or false
    if self:GetState() == ArcCW.STATE_SIGHTS
            or (self:GetState() == ArcCW.STATE_SPRINT and !self:CanShootWhileSprint())
            or self:GetState() == ArcCW.STATE_CUSTOMIZE then
        return
    end
    if self:GetNextPrimaryFire() > CurTime() or self:GetGrenadePrimed() or self:GetPriorityAnim() then return end

    if !self.CanBash and !self:GetBuff_Override("Override_CanBash") then return end

    self:GetBuff_Hook("Hook_PreBash")

    self.Primary.Automatic = true

    local mult = self:GetBuff_Mult("Mult_MeleeTime")
    local mt = self.MeleeTime * mult

    if melee2 then
        mt = self.Melee2Time * mult
    end

    mt = mt * self:GetBuff_Mult("Mult_MeleeWaitTime")

    local bashanim = "bash"
    local canbackstab = self:CanBackstab(melee2)

    if melee2 then
        bashanim = canbackstab and self:SelectAnimation("bash2_backstab") or self:SelectAnimation("bash2") or bashanim
    else
        bashanim = canbackstab and self:SelectAnimation("bash_backstab") or self:SelectAnimation("bash") or bashanim
    end

    bashanim = self:GetBuff_Hook("Hook_SelectBashAnim", bashanim) or bashanim

    if bashanim and self.Animations[bashanim] then
        if SERVER then self:PlayAnimation(bashanim, mult, true, 0, true) end
    else
        self:ProceduralBash()

        self:MyEmitSound(self.MeleeSwingSound, 75, 100, 1, CHAN_USER_BASE + 1)
    end

    if CLIENT then
        self:OurViewPunch(-self.BashPrepareAng * 0.05)
    end
    self:SetNextPrimaryFire(CurTime() + mt )

    if melee2 then
        if self.HoldtypeActive == "pistol" or self.HoldtypeActive == "revolver" then
            self:GetOwner():DoAnimationEvent(self.Melee2Gesture or ACT_HL2MP_GESTURE_RANGE_ATTACK_GRENADE)
        else
            self:GetOwner():DoAnimationEvent(self.Melee2Gesture or ACT_GMOD_GESTURE_MELEE_SHOVE_2HAND)
        end
    else
        if self.HoldtypeActive == "pistol" or self.HoldtypeActive == "revolver" then
            self:GetOwner():DoAnimationEvent(self.MeleeGesture or ACT_HL2MP_GESTURE_RANGE_ATTACK_GRENADE)
        else
            self:GetOwner():DoAnimationEvent(self.MeleeGesture or ACT_GMOD_GESTURE_MELEE_SHOVE_2HAND)
        end
    end

    local mat = self.MeleeAttackTime

    if melee2 then
        mat = self.Melee2AttackTime
    end

    mat = mat * self:GetBuff_Mult("Mult_MeleeAttackTime") * math.pow(mult, 1.5)

    self:SetTimer(mat or (0.125 * mt), function()
        if !IsValid(self) then return end
        if !IsValid(self:GetOwner()) then return end
        if self:GetOwner():GetActiveWeapon() != self then return end

        if CLIENT then
            self:OurViewPunch(-self.BashAng * 0.05)
        end

        self:MeleeAttack(melee2)
    end)

    self:DoLunge()
end

function SWEP:MeleeAttack(melee2)
    local reach = 32 + self:GetBuff_Add("Add_MeleeRange") + self.MeleeRange
    local dmg = self:GetBuff_Override("Override_MeleeDamage", self.MeleeDamage) or 20

    if melee2 then
        reach = 32 + self:GetBuff_Add("Add_MeleeRange") + self.Melee2Range
        dmg = self:GetBuff_Override("Override_MeleeDamage", self.Melee2Damage) or 20
    end

    dmg = dmg * self:GetBuff_Mult("Mult_MeleeDamage")

    self:GetOwner():LagCompensation(true)

    local filter = {self:GetOwner()}

    table.Add(filter, self.Shields)

    local tr = util.TraceLine({
        start = self:GetOwner():GetShootPos(),
        endpos = self:GetOwner():GetShootPos() + self:GetOwner():GetAimVector() * reach,
        filter = filter,
        mask = MASK_SHOT_HULL
    })

    if (!IsValid(tr.Entity)) then
        tr = util.TraceHull({
            start = self:GetOwner():GetShootPos(),
            endpos = self:GetOwner():GetShootPos() + self:GetOwner():GetAimVector() * reach,
            filter = filter,
            mins = Vector(-16, -16, -8),
            maxs = Vector(16, 16, 8),
            mask = MASK_SHOT_HULL
        })
    end

    -- Backstab damage if applicable
    local backstab = tr.Hit and self:CanBackstab(melee2, tr.Entity)
    if backstab then
        if melee2 then
            local bs_dmg = self:GetBuff_Override("Override_Melee2DamageBackstab", self.Melee2DamageBackstab)
            if bs_dmg then
                dmg = bs_dmg * self:GetBuff_Mult("Mult_MeleeDamage")
            else
                dmg = dmg * self:GetBuff("BackstabMultiplier") * self:GetBuff_Mult("Mult_MeleeDamage")
            end
        else
            local bs_dmg = self:GetBuff_Override("Override_MeleeDamageBackstab", self.MeleeDamageBackstab)
            if bs_dmg then
                dmg = bs_dmg * self:GetBuff_Mult("Mult_MeleeDamage")
            else
                dmg = dmg * self:GetBuff("BackstabMultiplier") * self:GetBuff_Mult("Mult_MeleeDamage")
            end
        end
    end

    -- We need the second part for single player because SWEP:Think is ran shared in SP
    if !(game.SinglePlayer() and CLIENT) then
        if tr.Hit then
            if tr.Entity:IsNPC() or tr.Entity:IsNextBot() or tr.Entity:IsPlayer() then
                self:MyEmitSound(self.MeleeHitNPCSound, 75, 100, 1, CHAN_USER_BASE + 2)
            else
                self:MyEmitSound(self.MeleeHitSound, 75, 100, 1, CHAN_USER_BASE + 2)
            end

            if tr.MatType == MAT_FLESH or tr.MatType == MAT_ALIENFLESH or tr.MatType == MAT_ANTLION or tr.MatType == MAT_BLOODYFLESH then
                local fx = EffectData()
                fx:SetOrigin(tr.HitPos)

                util.Effect("BloodImpact", fx)
            end
        else
            self:MyEmitSound(self.MeleeMissSound, 75, 100, 1, CHAN_USER_BASE + 3)
        end
    end

    if SERVER and IsValid(tr.Entity) and (tr.Entity:IsNPC() or tr.Entity:IsPlayer() or tr.Entity:Health() > 0) then
        local dmginfo = DamageInfo()

        local attacker = self:GetOwner()
        if !IsValid(attacker) then attacker = self end
        dmginfo:SetAttacker(attacker)

        local relspeed = (tr.Entity:GetVelocity() - self:GetOwner():GetAbsVelocity()):Length()

        relspeed = relspeed / 225

        relspeed = math.Clamp(relspeed, 1, 1.5)

        dmginfo:SetInflictor(self)
        dmginfo:SetDamage(dmg * relspeed)
        dmginfo:SetDamageType(self:GetBuff_Override("Override_MeleeDamageType") or self.MeleeDamageType or DMG_CLUB)

        dmginfo:SetDamageForce(self:GetOwner():GetRight() * -4912 + self:GetOwner():GetForward() * 9989)

        SuppressHostEvents(NULL)
        tr.Entity:TakeDamageInfo(dmginfo)
        SuppressHostEvents(self:GetOwner())

        if tr.Entity:GetClass() == "func_breakable_surf" then
            tr.Entity:Fire("Shatter", "0.5 0.5 256")
        end

    end

    if SERVER and IsValid(tr.Entity) then
        local phys = tr.Entity:GetPhysicsObject()
        if IsValid(phys) then
            phys:ApplyForceOffset(self:GetOwner():GetAimVector() * 80 * phys:GetMass(), tr.HitPos)
        end
    end

    self:GetBuff_Hook("Hook_PostBash", {tr = tr, dmg = dmg})

    self:GetOwner():LagCompensation(false)
end
--PATH lua/weapons/arccw_base_melee/shared.lua:
SWEP.Base = "arccw_base"

SWEP.Primary.Ammo = "" -- Prevent base "pistol" ammo type from showing up on the HUD of melee weapons

SWEP.MeleeDamage = 25
SWEP.MeleeDamageBackstab = nil -- If not exists, use multiplier on standard damage
SWEP.MeleeRange = 16
SWEP.MeleeDamageType = DMG_CLUB
SWEP.MeleeTime = 0.5
SWEP.MeleeGesture = nil
SWEP.MeleeAttackTime = 0.2

SWEP.Melee2 = false
SWEP.Melee2Damage = 25
SWEP.Melee2DamageBackstab = nil -- If not exists, use multiplier on standard damage
SWEP.Melee2Range = 16
SWEP.Melee2Time = 0.5
SWEP.Melee2Gesture = nil
SWEP.Melee2AttackTime = 0.2

SWEP.Backstab = false
SWEP.BackstabMultiplier = 2

SWEP.NotForNPCs = true

SWEP.Firemodes = {
    {
        Mode = 1,
        PrintName = "MELEE"
    },
}

SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "melee"

SWEP.Primary.ClipSize = -1

SWEP.Animations = {
    -- ["draw"] = {
    --     Source = "draw",
    --     Time = 0.5,
    -- },
    -- ["ready"] = {
    --     Source = "draw",
    --     Time = 0.5,
    -- },
    -- ["bash"] = {
    --     Source = {"stab", "midslash1", "midslash2", "stab_miss"},
    --     Time = 0.5,
    -- },
    -- ["bash_backstab"] = {
    --     Source = {"stab_backstab"},
    --     Time = 0.5,
    -- },
}

SWEP.IronSightStruct = false

SWEP.BashPreparePos = Vector(0, 0, 0)
SWEP.BashPrepareAng = Angle(0, 0, 0)

SWEP.BashPos = Vector(0, 0, 0)
SWEP.BashAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(0, -1, 0)
SWEP.HolsterAng = Angle(-10, 0, 0)

SWEP.ShootWhileSprint = true

SWEP.SpeedMult = 1

SWEP.Secondary.Automatic = true


--PATH lua/weapons/arccw_cis_se14.lua:
return gluapack()()
--PATH lua/weapons/arccw_dual_e5.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "[ ArcCW ] CIS TFA Weapons"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "Dual E-5"
SWEP.Trivia_Class = "CIS Dual Blaster Carbine"
SWEP.Trivia_Desc = "High tech compact Dual E-5 Blaster Carbine."
SWEP.Trivia_Manufacturer = "Baktoid Combat Automata"
SWEP.Trivia_Calibre = "Medium Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 1

SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/strasser/weapons/c_ddeagle.mdl"
SWEP.WorldModel = "models/arccw/weapons/synbf3/w_scoutblaster.mdl"
SWEP.ViewModelFOV = 90
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

SWEP.IconOverride = "materials/entities/rw_sw_dual_e5.png"

SWEP.DefaultBodygroups = "000000000000"

SWEP.Damage = 30
SWEP.RangeMin = 150
SWEP.DamageMin = 17
SWEP.Range = 350
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400


SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_red"
SWEP.TracerCol = Color(250, 0, 0)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 40

SWEP.Recoil = 0.7
SWEP.RecoilPunch = 1.4
SWEP.RecoilSide = 0.25
SWEP.RecoilRise = 0.31

SWEP.Delay = 60 / 380
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 2
	},
    {
        Mode = 1
    },
    {
        Mode = 0
    },    
}

SWEP.AccuracyMOA = 0.75 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 800 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50


----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100

SWEP.ShootSound = "w/e5.wav"

SWEP.MuzzleFlashColor = Color(255, 0, 0, 50)

SWEP.IronSightStruct = {
    Pos = Vector(0, -4, 1),
    Ang = Angle(0, 0, 0),
     Magnification = 1.2,
     SwitchToSound = "zoom_in/gunfoley_zoomin_blasterheavy_01.mp3",
     ViewModelFOV = 90,
}
SWEP.HoldtypeHolstered = ""
SWEP.HoldtypeActive = "duel"
SWEP.HoldtypeSights = ""


SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, -5, -4)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, -14,-10)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Vector(-25, 0, 0)


SWEP.ReloadPos = Vector(0, -10, -5)

SWEP.CustomizePos = Vector(-0.5, -8, -4.897)
SWEP.CustomizeAng = Angle(30, 0, 0)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 1, 1)
SWEP.DrawCrosshair = true

SWEP.BarrelLength = 60
SWEP.BarrelOffsetSighted = Vector(0, 0, 0)
SWEP.BarrelOffsetHip = Vector(3, 0, -3)
SWEP.DefaultElements = {"e5", "e5+"}

SWEP.AttachmentElements = {
    ["e5"] = {
        VMElements = {
            {
                Model = "models/arccw/kuro/sw_battlefront/weapons/e5_blaster.mdl",
                Bone = "LeftHand_1stP",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(4, -1.5, -1),
                    ang = Angle(-4, -2, 90)
                }
            }
        },
    },
    ["e5+"] = {
         VMElements = {
            {
                Model = "models/arccw/kuro/sw_battlefront/weapons/e5_blaster.mdl",
                Bone = "RightHand_1stP",
                Scale = Vector(1.1, 1.1, 1.1),                
                Offset = {
                    pos = Vector(-4, 1.5, 1),
                    ang = Angle(-4, 178, 90)
                }
            }
        }, 
        WMElements = {
            {
                Model = "models/arccw/kuro/sw_battlefront/weapons/e5_blaster.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(40.5, 10, 20.75),
                    ang = Angle(180, -180, 2)
                }
            },
            {
                Model = "models/arccw/kuro/sw_battlefront/weapons/e5_blaster.mdl",
                Bone = "ValveBiped.Bip01_L_Hand",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(-40, 230, -25),
                    ang = Angle(180, -180, 2)
                }
            },
        },            -- change the world model to something else. Please make sure it's compatible with the last one.
    }
}
WMOverride = "models/arccw/kuro/sw_battlefront/weapons/e5_blaster.mdl"

--SWEP.Attachments 
SWEP.Attachments = {
    [1] = {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"tactical","tac_pistol"},
        Bone = "RightHand_1stP", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(-12, -4, 2.5),
            vang = Angle(170, 0, 0),
        },
    },    
    [2] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = "ammo",
    }
}


SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = {"shoot_lw", "shoot_rw"},
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1.5,
        SoundTable = {
            {
                s = "draw/gunfoley_pistol_draw_var_10.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "holster/gunfoley_pistol_sheathe_var_09.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        Time = 3.35,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PHYSGUN,
        SoundTable = {
            {s = "ArcCW_dc17.reload2", t = 4 / 30}, --s sound file
        },
    },


sound.Add({
    name =          "ArcCW_dc17.reload2",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "weapons/bf3/pistols.wav"
    }),
}
--PATH lua/weapons/arccw_dual_se14.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_a280s.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_a287.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_a620su.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "A-620su"
SWEP.Trivia_Class = "Blaster Carbine"
SWEP.Trivia_Desc = "The A280 blaster rifle was a type of blaster rifle mostly used by Rebel Alliance troopers and New Republic soldiers. There existed two variants of the A280 blaster, the A280C and the A280-CFE, both of which were favored by commandos and special force of the Rebel Alliance."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/galactic/a620su.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "0030100000000000"

SWEP.HideViewmodel = false
SWEP.MirrorVMWM = true
SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/kraken/galactic/v_a280c.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dlt19.mdl"
SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(0.9, 0.5, -2.9),
    ang = Angle(-10, 0, 180),
    scale = 1,
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 15
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 48
SWEP.DamageMin = 28
SWEP.RangeMin = 0
SWEP.Range = 200
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TraceNum = 1
SWEP.Tracer = "tracer_red"
SWEP.TracerCol = Color(250, 0, 0)

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 26

SWEP.Recoil = 0.55
SWEP.RecoilSide = 0.45
SWEP.RecoilRise = 0.78
SWEP.RecoilPunch = 1.1

SWEP.Delay = 60 / 600
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
        PostBurstDelay = 0.1,
    },
    {
		Mode = 2,
        PostBurstDelay = 0.1,
    },
    {
        Mult_RPM = 2,
		Mode = -3,
        PostBurstDelay = 0.1,
    },
	{
		Mode = 0,
   	}
}

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 200
SWEP.MoveDispersion = 100
SWEP.JumpDispersion = 150

-- Speed Mult
SWEP.SpeedMult = 0.9
SWEP.SightedSpeedMult = 0.75
SWEP.ShootSpeedMult = 1.05

-- Sounds & Muzzleflash
SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 125
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.FirstShootSound = "ArcCW_Kraken.SW_A280"
SWEP.ShootSound = "ArcCW_Kraken.SW_A280"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.MuzzleFlashColor = Color(250, 0, 0)
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.GMMuzzleEffect = false

-- Ironsight & Holdtype
SWEP.IronSightStruct = {
    Pos = Vector(-3.05, -4, 1.1),
    Ang = Angle(0, 0, 2.5),
     Magnification = 1.5,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 55,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(4.019, -5.226, -0.805)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CrouchPos = Vector(-4, 0, 0)
SWEP.CrouchAng = Angle(0, 0, -10)

SWEP.HolsterPos = Vector(3, -3, 0)
SWEP.HolsterAng = Angle(-7.036, 30.016, 0)

SWEP.BarrelOffsetSighted = Vector(0, 0, -1)
SWEP.BarrelOffsetHip = Vector(2, 0, -2)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(20, 30.7, 10.3)

-- Attachments 
SWEP.AttachmentElements = {
    ["optic_attach"] = {
        VMBodygroups = {{ind = 3, bg = 1}},
    },
    ["laser_attach"] = {
        VMBodygroups = {{ind = 4, bg = 0}},
    },
    ["foregrip_attach"] = {
        VMBodygroups = {{ind = 5, bg = 1}},
    },
}
SWEP.Attachments = {     
    {
        PrintName = "Optics", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "tag_sling",
        InstalledEles = {"optic_attach"},
        Offset = {
            vpos = Vector(4, 0, 1.5),
            vang = Angle(0, 0, 0),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0)
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "stealth_muzzle"},
        VMScale = Vector(1.2, 1.2, 1.2),
        WMScale = Vector(1.2, 1.2, 1.2),
        Bone = "tag_sling",
        Offset = {
            vpos = Vector(24.5, -0.05, 0.05),
            vang = Angle(0, 0, 0),
        },
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        InstalledEles = {"laser_attach"},
        Bone = "tag_sling",
        Offset = {
            vpos = Vector(13.4, 0.8, 0.3),
            vang = Angle(0, 0, -90),
        },
    },  
    {
        PrintName = "Underbarrel",
        DefaultAttName = "None",
        Slot = {"foregrip"},
        VMScale = Vector(1, 1, 1),
        WMScale = Vector(1, 1, 1),
        Bone = "tag_sling",
        InstalledEles = {"foregrip_attach"},
        Offset = {
            vpos = Vector(13, 0.1, -0.38),
            vang = Angle(0, 0, 0),
        },
    },  
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.6, 0.6, 0.6),
        WMScale = Vector(0.6, 0.6, 0.6),
        Bone = "tag_sling",
        Offset = {
            vpos = Vector(6.6, -0.6, -1.3),
            vang = Angle(0, 0, 0),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        Bone = "tag_sling",
        Offset = {
            vpos = Vector(2.5, -0.6, 0),
            vang = Angle(0, 0, 0),
        },
    },
}

-- Don't touch this unless you know what you're doing
local path = "arccw/kraken/sw_galactic/weapons/a280/handling/"

SWEP.Animations = {
    ["fire"] = {
        Source = "shoot1",
		IKTimeLine = { { t = 0,  lhik = 1, rhik = 1} },
    },
    ["reload"] = {
        Source = "reload_short",
        LHIK = true,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
		MinProgress = 0.9,
        SoundTable = {
			{s = path .. "wpfoly_mike4_reload_lift_v2.ogg", t = 0.1/30},
            {s = "ArcCW_Kraken.Overheat", t = 19/30},
			{s = path .. "wpfoly_mike4_reload_magout_v2.ogg", t = 18/30},
			{s = path .. "wpfoly_mike4_reload_magin_01.ogg", t = 28/30},
			{s = path .. "wpfoly_mike4_reload_magin_v2.ogg", t = 31/30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 32/30},
			{s = path .. "wpfoly_mike4_reload_end_v2.ogg", t = 52/30},
        },
    },
    ["reload_empty"] = {
        Source = "reload",
        LHIK = true,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
		MinProgress = 0.9,
        SoundTable = {
			{s = path .. "wpfoly_mike4_reload_empty_lift_v2.ogg", t = 0.1/30},
			{s = path .. "wpfoly_mike4_reload_empty_magout_v2.ogg", t = 5/30},
            {s = "ArcCW_Kraken.Overheat", t = 6/30},
			{s = path .. "wpfoly_mike4_reload_empty_magin_v2.ogg", t = 31/30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 32/30},
			{s = path .. "wpfoly_mike4_reload_empty_chamber_v2.ogg", t = 53/30},
			{s = path .. "wpfoly_mike4_reload_empty_end_v2.ogg", t = 63/30},
        },
    },
    ["ready"] = {
        Source = "draw",
		MinProgress = 0.6,
        SoundTable = {
            {s = path .. "wpfoly_mike4_raise_first_01.ogg", t = 0.2},
            {s = path .. "wpfoly_mike4_raise_first_02.ogg", t = 0.85},
            {s = path .. "wpfoly_mike4_raise_first_03.ogg", t = 1.3},
        },
    },
    ["draw"] = {
        Source = "draw_short",
		MinProgress = 0.5,
        SoundTable = {
            {s = path .. "wpfoly_mike4_raise_v2.ogg", t = 0.1/30},
        },
    },
    ["holster"] = {
        Source = "holster",
		--Mult = 0.8,
        SoundTable = {
            {s = path .. "wpfoly_mike4_drop_v2.ogg", t = 0.1/30},
        },
    },
    ["idle"] = {
        Source = "idle",
    },
    ["inspect"] = {
        Source = "lookat01",
        LHIK = true,
		MinProgress = 0.9,
        SoundTable = {
            {s = path .. "wfoly_ar_mike4_inspect_01.ogg", t = 0},
			{s = path .. "wfoly_ar_mike4_inspect_02.ogg", t = 1.3},
			{s = path .. "wfoly_ar_mike4_inspect_03.ogg", t = 2.36},
			{s = path .. "wfoly_ar_mike4_inspect_04.ogg", t = 3.6},
			{s = path .. "wfoly_ar_mike4_inspect_05.ogg", t = 4.2},
        },
    },
    ["bash"] = {
        Source = {"melee", "melee2", "melee3"},
    },
    ["changefiremode"] = {
        Source = "semi_on",
        SoundTable = {
            {s = path .. "weap_m4_selector_semi_on_03.ogg", t = 0.1/30},
        },
    },
    ["fix"] = {
        Source = "unjam",
        MinProgress = 0.4,
        FireASAP = true,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 5/30},
			{s = path .. "wpfoly_mike4_reload_empty_lift_v2.ogg", t = 5/30},
            {s = path .. "wpfoly_mike4_jam_bolt.ogg", t = 10/30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 34/30},
			{s = path .. "wpfoly_mike4_reload_empty_chamber_v2.ogg", t = 25/30},
			{s = path .. "wpfoly_mike4_reload_empty_end_v2.ogg", t = 34/30},
        },
    },
    ["enter_bipod"] = {
        Source = "bipod_in",
    },
    ["exit_bipod"] = {
        Source = "bipod_out",
    },
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_bryar_extended.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 2

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "Bryar Extended"
SWEP.Trivia_Class = "Blaster Pistol"
SWEP.Trivia_Desc = "The Bryar pistol was a type of blaster pistol. Models of Bryar pistol included the K-16 Bryar Pistol and MW-20 Bryar pistol"
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/galactic/bryar_extended.png"

-- Base
SWEP.DefaultBodygroups = "011000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/galactic/v_bryar.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(-18, 6.7, -5.75),
    ang = Angle(0, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 10
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 57
SWEP.DamageMin = 43
SWEP.RangeMin = 0
SWEP.Range = 300
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(192, 0, 250)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_purple"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 20

SWEP.Recoil = 1.5
SWEP.RecoilSide = 0.6
SWEP.RecoilRise = 0.9

SWEP.Delay = 60 / 260
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0.5
SWEP.HipDispersion = 100
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "ArcCW_Kraken.SW_BRYAR"
SWEP.ShootSound = "ArcCW_Kraken.SW_BRYAR"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_purple"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(192, 0, 250)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-5.04, -11.296, 1),
    Ang = Angle(0,0,0),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL

SWEP.SprintPos = Vector(2.019, -5.226, -2)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.CustomizePos = Vector(10, -10, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 2)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(-3, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.Attachments = {     
    {
        PrintName = "Sight", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "DC-15SA",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(-0.01, -2.2, -2.5),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
    },  
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "DC-15SA",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(-0.9, -1.4, 3),
            vang = Angle(90, 0, 180),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.5, 0.5, 0.5),
        WMScale = Vector(0.5, 0.5, 0.5),
        Bone = "DC-15SA",
        Offset = {
            vpos = Vector(0.4, -0.5, -3.9),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Bone = "DC-15SA",
        Offset = {
            vpos = Vector(0.5, -1.6, -2.5),
            vang = Angle(90, 0, -90),
        },
    },   
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = false,
    },
    ["idle_iron"] = {
        Source = false,
    },
	["fire"] = {
        Source = {"fire"},
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatFix", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_dc15s.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 -- Change this if you want to select the weapon with other number

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Republic Arsenal"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "DC-15s"
SWEP.Trivia_Class = "Blaster Carbine"
SWEP.Trivia_Desc = "The DC-15S Blaster Carbine, produced by BlasTech Industries, is a semi-automatic and rapid fire blaster which also has a stun feature. As well as a unique fully-foldable stalk. The rifle was used by clone troopers throughout the Clone Wars and became the more favored weapon amongst its more powerful counterpart, the DC-15A Blaster Rifle, due to its compact size and usefulness in close quarter engagements."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Condensed Tibanna-Gas"
SWEP.Trivia_Country = "Galactic Republic"
SWEP.IconOverride = "entities/arccw/kraken/republic-arsenal/dc15s.png"

-- Viewmodel & Entity Properties
SWEP.UseHands = true
SWEP.MirrorVMWM = true
SWEP.NoHideLeftHandInCustomization = false

SWEP.ViewModel = "models/arccw/kraken/republic/v_dc15s.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"
SWEP.ViewModelFOV = 60

SWEP.WorldModelOffset = {
    pos = Vector(-9, 3.5, -4.5),
    ang = Angle(-10, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 18
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatDelayTime = 0.2
SWEP.HeatFix = true

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 44
SWEP.DamageMin = 28
SWEP.RangeMin = 0
SWEP.Range = 230
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TraceNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 250)

SWEP.HullSize = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 40

SWEP.Recoil = 0.65
SWEP.RecoilSide = 0.35
SWEP.RecoilRise = 0.55

SWEP.Delay = 60 / 250
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
		Mode = 2,
    },
	{
		Mode = 0,
   	}
}

SWEP.AccuracyMOA = 5
SWEP.HipDispersion = 200
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.95
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.30

-- Ammo, Sounds & MuzzleEffect
local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0

SWEP.FirstShootSound = "ArcCW_Kraken.SW_DC15A"
SWEP.ShootSound = "ArcCW_Kraken.SW_DC15A"
SWEP.DistantShootSound = "ArcCW_Kraken.StandardCorebass"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"

SWEP.MuzzleEffect = "blaster_muzzle_blue"
SWEP.MuzzleFlashColor = Color(0, 0, 255)

-- Ironsight & Holdtype
SWEP.IronSightStruct = {
    Pos = Vector(-2.816, -1.966, 1.894),
    Ang = Vector(0, 0, 1.513),
     Magnification = 1.1,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 55,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, 2, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(4, -3, -1)
SWEP.SprintAng = Angle(0, 30, -15)

SWEP.CustomizePos = Vector(15, 0, 5)
SWEP.CustomizeAng = Angle(0, 40, 30)

SWEP.HolsterPos = Vector(4, -3, -1)
SWEP.HolsterAng = Angle(0, 30, -15)

-- Attachments 
SWEP.DefaultElements = {}
SWEP.AttachmentElements = {
    ["scope_attach"] = {
        VMBodygroups = {{ind = 3, bg = 1}},
    },
    ["grip_attach"] = {
        VMBodygroups = {{ind = 1, bg = 1}},
    },
    ["vibroknife"] = {
        VMBodygroups = {{ind = 2, bg = 1}},
    },
}

SWEP.Attachments = {
    {
        PrintName = "Sight", 
        DefaultAttName = "DC-15 Holosight",
        Slot = "optic",
        Bone = "DC15",
        InstalledEles = {"scope_attach"},
        Offset = {
            vpos = Vector(0.02, -1.1, 4.9),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "DC15",
        Offset = {
            vpos = Vector(0.02, -0.442, 11.638),
            vang = Angle(90, 0, -90),

        },
    },  
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Bone = "DC15", 
        Offset = {
            vpos = Vector(-0.8, -0.5, 10.5),
            vang = Angle(90, 0, 180),
        },
    },  
    {
        PrintName = "Underbarrel",
        DefaultAttName = "None",
        Slot = {"foregrip", "vibroknife"},
        Bone = "DC15",
        InstalledEles = {"grip_attach"},
        Offset = {
            vpos = Vector(-0.101, 0.15, 5),
            vang = Angle(90, 0, -90),
        },       
    },
    {
        PrintName = "Mode",
        DefaultAttName = "None",
        Slot = {"sw_mode", "sw_mode_rifle"},
    },   
    {
        PrintName = "Ammunition",
        DefaultAttName = "Standard",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = "uc_fg",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "DC15",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(0.95, 0.05, -3.55),
            vang = Angle(90, 0, -90),
        },
    },     
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        Bone = "DC15",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(1, -0.2, -7),
            vang = Angle(90, 0, -90),
        },
    },      
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = false,
    },
    ["fire"] = {
        Source = "fire"
    },
    ["fire_iron"] = {
        Source = "fire"
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1.1,
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_rifle.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_rifle.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        SoundTable = {
            {s = "dc15a_reload1", t = 2 / 10},
            {s = "ArcCW_Kraken.Overheat", t = 5 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 37 / 30},
            {s = "ArcCW_Kraken.Grab", t = 37 / 30},
        },
    },
    ["fix"] = {
        Source = "overheat", 
        Mult = 1.5,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 55 / 30},
            {s = "ArcCW_Kraken.Grab", t = 53 / 30},
        },
    },
}
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_dc15s_grenadier.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 -- Change this if you want to select the weapon with other number

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Republic Arsenal"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "DC-15s Grenadier"
SWEP.Trivia_Class = "Blaster Carbine"
SWEP.Trivia_Desc = "The DC-15S Blaster Carbine, produced by BlasTech Industries, is a semi-automatic and rapid fire blaster which also has a stun feature. As well as a unique fully-foldable stalk. The rifle was used by clone troopers throughout the Clone Wars and became the more favored weapon amongst its more powerful counterpart, the DC-15A Blaster Rifle, due to its compact size and usefulness in close quarter engagements."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Condensed Tibanna-Gas"
SWEP.Trivia_Country = "Galactic Republic"
SWEP.IconOverride = "entities/arccw/kraken/republic-arsenal/dc15s_grenadier.png"

-- Viewmodel & Entity Properties
SWEP.UseHands = true
SWEP.MirrorVMWM = true
SWEP.NoHideLeftHandInCustomization = false

SWEP.ViewModel = "models/arccw/kraken/republic/v_dc15s.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"
SWEP.ViewModelFOV = 60

SWEP.WorldModelOffset = {
    pos = Vector(-9, 3.5, -4.5),
    ang = Angle(-10, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 18
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatDelayTime = 0.2
SWEP.HeatFix = true

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 44
SWEP.DamageMin = 28
SWEP.RangeMin = 0
SWEP.Range = 230
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TraceNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 250)

SWEP.HullSize = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 40

SWEP.Recoil = 0.65
SWEP.RecoilSide = 0.35
SWEP.RecoilRise = 0.55

SWEP.Delay = 60 / 250
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
		Mode = 2,
    },
	{
		Mode = 0,
   	}
}

SWEP.AccuracyMOA = 5
SWEP.HipDispersion = 200
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.95
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.30

-- Ammo, Sounds & MuzzleEffect
local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0

SWEP.FirstShootSound = "ArcCW_Kraken.SW_DC15A"
SWEP.ShootSound = "ArcCW_Kraken.SW_DC15A"
SWEP.DistantShootSound = "ArcCW_Kraken.StandardCorebass"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"

SWEP.MuzzleEffect = "blaster_muzzle_blue"
SWEP.MuzzleFlashColor = Color(0, 0, 255)

-- Ironsight & Holdtype
SWEP.IronSightStruct = {
    Pos = Vector(-2.816, -1.966, 1.894),
    Ang = Vector(0, 0, 1.513),
     Magnification = 1.1,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 55,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, 2, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(4, -3, -1)
SWEP.SprintAng = Angle(0, 30, -15)

SWEP.CustomizePos = Vector(15, 0, 5)
SWEP.CustomizeAng = Angle(0, 40, 30)

SWEP.HolsterPos = Vector(4, -3, -1)
SWEP.HolsterAng = Angle(0, 30, -15)

-- Attachments 
SWEP.DefaultElements = {}
SWEP.AttachmentElements = {
    ["scope_attach"] = {
        VMBodygroups = {{ind = 3, bg = 1}},
    },
    ["grip_attach"] = {
        VMBodygroups = {{ind = 1, bg = 1}},
    },
    ["vibroknife"] = {
        VMBodygroups = {{ind = 2, bg = 1}},
    },
}

SWEP.Attachments = {
    {
        PrintName = "Sight", 
        DefaultAttName = "DC-15 Holosight",
        Slot = "optic",
        Bone = "DC15",
        InstalledEles = {"scope_attach"},
        Offset = {
            vpos = Vector(0.02, -1.1, 4.9),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "DC15",
        Offset = {
            vpos = Vector(0.02, -0.442, 11.638),
            vang = Angle(90, 0, -90),

        },
    },  
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Bone = "DC15", 
        Offset = {
            vpos = Vector(-0.8, -0.5, 10.5),
            vang = Angle(90, 0, 180),
        },
    },  
    {
        PrintName = "Underbarrel",
        DefaultAttName = "None",
        Slot = {"foregrip", "vibroknife", "ubgl_republica"},
        Bone = "DC15",
        InstalledEles = {"grip_attach"},
        Offset = {
            vpos = Vector(-0.101, -0.5, 5),
            vang = Angle(90, 0, -90),
        },       
    },
    {
        PrintName = "Mode",
        DefaultAttName = "None",
        Slot = {"sw_mode", "sw_mode_rifle"},
    },   
    {
        PrintName = "Ammunition",
        DefaultAttName = "Standard",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = "uc_fg",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "DC15",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(0.95, 0.05, -3.55),
            vang = Angle(90, 0, -90),
        },
    },     
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        Bone = "DC15",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(1, -0.2, -7),
            vang = Angle(90, 0, -90),
        },
    },      
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = false,
    },
    ["fire"] = {
        Source = "fire"
    },
    ["fire_iron"] = {
        Source = "fire"
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1.1,
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_rifle.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_rifle.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        SoundTable = {
            {s = "dc15a_reload1", t = 2 / 10},
            {s = "ArcCW_Kraken.Overheat", t = 5 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 37 / 30},
            {s = "ArcCW_Kraken.Grab", t = 37 / 30},
        },
    },
    ["fix"] = {
        Source = "overheat", 
        Mult = 1.5,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 55 / 30},
            {s = "ArcCW_Kraken.Grab", t = 53 / 30},
        },
    },
}
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_dc15sa.lua:
return gluapack()()
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_dc19.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_dc40c.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_dc92.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_dc92.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 2

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "DC-92"
SWEP.Trivia_Class = "Blaster Pistol"
SWEP.Trivia_Desc = "Blaster Pistol designed for civillian purposes. Used mostly by Mercenaries and Bounty Hunters."
SWEP.Trivia_Manufacturer = "Unknown"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/galactic/dc92.png"

-- Base
SWEP.DefaultBodygroups = "010000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/galactic/v_dc92.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(-18, 6.7, -5.75),
    ang = Angle(0, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 9
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 65
SWEP.DamageMin = 39
SWEP.RangeMin = 0
SWEP.Range = 170
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(250, 0, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_red"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 18

SWEP.Recoil = 1.56
SWEP.RecoilSide = 0.69
SWEP.RecoilRise = 0.95

SWEP.Delay = 60 / 280
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
        Mode = -3,
        PostBurstDelay = 0.1,
        RunawayBurst = false,
        Mult_RPM = 2,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0.5
SWEP.HipDispersion = 100
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "ArcCW_Kraken.SW_DC92"
SWEP.ShootSound = "ArcCW_Kraken.SW_DC92"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-5.03, -11.296, 1.4),
    Ang = Angle(0.5,0,0),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL

SWEP.SprintPos = Vector(2.019, -5.226, -2)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.CustomizePos = Vector(10, -10, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 2)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(-3, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.DefaultElements = {}
SWEP.AttachmentElements = {
    ["muzzle_attach"] = {
        VMBodygroups = {{ind = 1, bg = 1}},
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Sight", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "DC-15SA",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(-0.01, -1.92, -1.5),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        Bone = "DC-15SA",
        InstalledEles = {"muzzle_attach"},
        Offset = {
            vpos = Vector(0, -1.29, 4.8),
            vang = Angle(90, 0, -90),
        },
    },  
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "DC-15SA",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(-0.36, -1.2, 3),
            vang = Angle(90, 0, 180),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.5, 0.5, 0.5),
        WMScale = Vector(0.5, 0.5, 0.5),
        Bone = "DC-15SA",
        Offset = {
            vpos = Vector(0.3, 0, -1),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Bone = "DC-15SA",
        Offset = {
            vpos = Vector(0.34, -1.2, -4),
            vang = Angle(90, 0, -90),
        },
    },   
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = false,
    },
    ["idle_iron"] = {
        Source = false,
    },
	["fire"] = {
        Source = {"fire"},
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatFix", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_de18.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 2

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "DE-18"
SWEP.Trivia_Class = "Blaster Pistol"
SWEP.Trivia_Desc = "Blaster Pistol designed originally for military purposes, now modernized and being used by many Bounty Hunters, Civillians and even Mercenaries or Military Corporations in the galaxy."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/galactic/de18.png"

-- Base
SWEP.DefaultBodygroups = "000000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/galactic/v_de18.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(-18, 6.7, -5.75),
    ang = Angle(0, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 6
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 72
SWEP.DamageMin = 39
SWEP.RangeMin = 0
SWEP.Range = 170
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(179, 0, 250)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_purple"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 15

SWEP.Recoil = 2.2
SWEP.RecoilSide = 0.65
SWEP.RecoilRise = 0.85
SWEP.RecoilPunch = 1.5

SWEP.Delay = 60 / 160
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
        Mode = -3,
        PostBurstDelay = 0.1,
        RunawayBurst = false,
        Mult_RPM = 2,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0.5
SWEP.HipDispersion = 100
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "ArcCW_Kraken.SW_DE18"
SWEP.ShootSound = "ArcCW_Kraken.SW_DE18"
SWEP.DistantShootSound = "ArcCW_Kraken.LightCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_purple"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(179, 0, 250)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-5.03, -11.296, 1.45),
    Ang = Angle(0,0,0),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL

SWEP.SprintPos = Vector(2.019, -5.226, -2)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.CustomizePos = Vector(10, -10, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 2)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(-3, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.DefaultElements = {}
SWEP.AttachmentElements = {
    ["muzzle_attach"] = {
        VMBodygroups = {{ind = 1, bg = 1}},
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Sight", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "DC-15SA",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(0.05, -2, -0.2),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        Bone = "DC-15SA",
        InstalledEles = {"muzzle_attach"},
        Offset = {
            vpos = Vector(0, -1.5, 1.8),
            vang = Angle(90, 0, -90),
        },
    },  
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "DC-15SA",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(-0.45, -1.5, -0.35),
            vang = Angle(90, 0, 180),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.5, 0.5, 0.5),
        WMScale = Vector(0.5, 0.5, 0.5),
        Bone = "DC-15SA",
        Offset = {
            vpos = Vector(0.5, -0.37, -4.05),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Bone = "DC-15SA",
        Offset = {
            vpos = Vector(0.6, -0.8, -2),
            vang = Angle(90, 0, -90),
        },
    },   
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = false,
    },
    ["idle_iron"] = {
        Source = false,
    },
	["fire"] = {
        Source = {"fire"},
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_dp24.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3

SWEP.Category = "[ArcCW] Kraken's Republic Arsenal"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "DP-24"
SWEP.Trivia_Class = "Blaster Carbine"
SWEP.Trivia_Desc = "The DP-24 is the Carbine version of the DP-23, a blaster shotgun for short range engagements. The DP-24 carbine has two variants, the standard one and the DP-24c which is a Carbine with more range and less damage. Very useful for Special Forces of the Galactic Republic."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Condensed Tibanna-Gas"
SWEP.Trivia_Country = "Galactic Republic"
SWEP.IconOverride = "entities/arccw/kraken/republic-arsenal/dp24.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "0000000000000000"

SWEP.MirrorVMWM = true
SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/kraken/republic/v_dp24.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"
SWEP.ViewModelFOV = 60

SWEP.WorldModelOffset = {
    pos = Vector(-8, 3.5, -4),
    ang = Angle(-10, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1,
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 25
SWEP.HeatDissipation = 2
SWEP.HeatLockout = true
SWEP.HeatDelayTime = 1
SWEP.HeatFix = true

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 22
SWEP.DamageMin = 19
SWEP.RangeMin = 0
SWEP.Range = 250
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TraceNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 250)

SWEP.HullSize = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 50

SWEP.Recoil = 0.7
SWEP.RecoilSide = 0.3
SWEP.RecoilRise = 0.5

SWEP.Delay = 60 / 500
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
	{
		Mode = 0,
   	}
}

SWEP.AccuracyMOA = 5
SWEP.HipDispersion = 100
SWEP.MoveDispersion = 100
SWEP.JumpDispersion = 150

-- Speed Mult
SWEP.SpeedMult = 0.95
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.30

-- Ammo, Sounds & MuzzleEffect
local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0

SWEP.FirstShootSound = "ArcCW_Kraken.SW_DC15A"
SWEP.ShootSound = "ArcCW_Kraken.SW_DC15A"
SWEP.DistantShootSound = "ArcCW_Kraken.LightCorebass"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"

SWEP.MuzzleEffect = "blaster_muzzle_blue"
SWEP.MuzzleFlashColor = Color(0, 0, 255)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-2.905, -8.275, 1.858),
    Ang = Vector(0, 0, 0),
     Magnification = 1.5,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, 2, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(4, -3, -1)
SWEP.SprintAng = Angle(0, 30, -15)

SWEP.CustomizePos = Vector(15, 0, 5)
SWEP.CustomizeAng = Angle(0, 40, 30)

SWEP.HolsterPos = Vector(4, -3, -1)
SWEP.HolsterAng = Angle(0, 30, -15)

SWEP.DefaultElements = {}
SWEP.AttachmentElements = {
    ["scope_attach"] = {
        VMBodygroups = {{ind = 2, bg = 1}},
    },
}

SWEP.Attachments = {
    {
        PrintName = "Sight", 
        DefaultAttName = "DC-15 Holosight",
        Slot = "optic",
        Bone = "DC15",
        InstalledEles = {"scope_attach"},
        Offset = {
            vpos = Vector(-0.05, -1.35, 4.9),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "DC15",
        Offset = {
            vpos = Vector(0.02, -0.442, 16.9),
            vang = Angle(90, 0, -90),

        },
    },  
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Bone = "DC15", 
        Offset = {
            vpos = Vector(-0.95, -0.5, 10.5),
            vang = Angle(90, 0, 180),
        },
    },  
    {
        PrintName = "Foregrip",
        DefaultAttName = "None",
        Slot = "foregrip",
        Bone = "DC15",
        Offset = {
            vpos = Vector(-0.101, 0.3, 5),
            vang = Angle(90, 0, -90),
        },       
    },
    {
        PrintName = "Mode",
        DefaultAttName = "None",
        Slot = {"sw_mode", "sw_mode_rifle"},
    },   
    {
        PrintName = "Ammunition",
        DefaultAttName = "Standard",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = "uc_fg",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "DC15",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(0.95, 0.05, -3.55),
            vang = Angle(90, 0, -90),
        },
    },     
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        Bone = "DC15",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(1, -0.2, -7),
            vang = Angle(90, 0, -90),
        },
    },      
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = false,
    },
    ["fire"] = {
        Source = "fire"
    },
    ["fire_iron"] = {
        Source = "fire"
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1.1,
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_rifle.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_rifle.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        SoundTable = {
            {s = "dc15a_reload1", t = 2 / 10},
            {s = "ArcCW_Kraken.Overheat", t = 5 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 37 / 30},
            {s = "ArcCW_Kraken.Grab", t = 37 / 30},
        },
    },
    ["fix"] = {
        Source = "overheat", 
        Mult = 1.5,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 55 / 30},
            {s = "ArcCW_Kraken.Grab", t = 53 / 30},
        },
    },
}
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_dp24c.lua:
return gluapack()()
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_dp24c.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3

SWEP.Category = "[ArcCW] Kraken's Republic Arsenal"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "DP-24c"
SWEP.Trivia_Class = "Blaster Carbine"
SWEP.Trivia_Desc = "The DP-24 is the Carbine version of the DP-23, a blaster shotgun for short range engagements. The DP-24 carbine has two variants, the standard one and the DP-24c which is a Carbine with more range and less damage. Very useful for Special Forces of the Galactic Republic."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Condensed Tibanna-Gas"
SWEP.Trivia_Country = "Galactic Republic"
SWEP.IconOverride = "entities/arccw/kraken/republic-arsenal/dp24c.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "000100000000000"

SWEP.MirrorVMWM = true
SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/kraken/republic/v_dp24c.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"
SWEP.ViewModelFOV = 60

SWEP.WorldModelOffset = {
    pos = Vector(-8, 3.5, -4),
    ang = Angle(-10, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1,
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 5
SWEP.HeatDissipation = 2
SWEP.HeatLockout = true
SWEP.HeatDelayTime = 1
SWEP.HeatFix = true

SWEP.NoRandSpread = true
SWEP.CanBash = true

SWEP.ShotgunSpreadPattern = {
    [1] = Angle(0, 0, 0),
    [2] = Angle(0, 1, 0),
    [3] = Angle(0, -1, 0),
    [4] = Angle(2.1, 0, 0),
    [5] = Angle(-2.1, 0, 0),
    [6] = Angle(1.4, 1.2, 0),
    [7] = Angle(-1.4, 1.2, 0),
    [8] = Angle(1.4, -1.2, 0),
    [9] = Angle(-1.4, -1.2, 0),
}

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 19
SWEP.DamageMin = 8
SWEP.RangeMin = 0
SWEP.Range = 120
SWEP.Penetration = 8
SWEP.DamageType = DMG_BUCKSHOT
SWEP.MuzzleVelocity = 9000

SWEP.TraceNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 250)

SWEP.HullSize = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 20

SWEP.Recoil = 2.2
SWEP.RecoilSide = 1
SWEP.RecoilRise = 2
SWEP.MaxRecoilBlowback = 2
SWEP.RecoilPunch = 1.5
SWEP.RecoilVMShake = 2

SWEP.Delay = 60 / 140
SWEP.Num = 9
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
	{
		Mode = 0,
   	}
}

SWEP.AccuracyMOA = 5
SWEP.HipDispersion = 100
SWEP.MoveDispersion = 75
SWEP.JumpDispersion = 150

-- Speed Mult
SWEP.SpeedMult = 0.95
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.30

-- Ammo, Sounds & MuzzleEffect
local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0

SWEP.FirstShootSound = "ArcCW_Kraken.SW_DP23"
SWEP.ShootSound = "ArcCW_Kraken.SW_DP23"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"

SWEP.MuzzleEffect = "blaster_muzzle_blue"
SWEP.MuzzleFlashColor = Color(0, 0, 255)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-3.004, -4.215, 0.1),
    Ang = Vector(0, 0, 0),
     Magnification = 1.5,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "shotgun"
SWEP.HoldtypeSights = "shotgun"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN

SWEP.ActivePos = Vector(-1, 2, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(4, -3, -2)
SWEP.SprintAng = Angle(0, 30, -15)

SWEP.CustomizePos = Vector(15, 0, 5)
SWEP.CustomizeAng = Angle(0, 40, 30)

SWEP.HolsterPos = Vector(4, -3, -2)
SWEP.HolsterAng = Angle(0, 30, -15)

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["scope_attach"] = {
        VMBodygroups = {{ind = 2, bg = 2}, {ind = 1, bg = 1}, {ind = 3, bg = 0}},
    },
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "DC_15X_Rifle",
               Scale = Vector(0, 0, 0),                
               Offset = {
                pos = Vector(0, 15, 0),
                ang = Angle(-90, -90, 0)
               },
               IsMuzzleDevice = true
           }
        }
    }
}

SWEP.Attachments = {
    {
        PrintName = "Optic",
        DefaultAttName = "DC-15 Holosight",
        Slot = {"optic"},
        Bone = "DC_15X_Rifle",
        InstalledEles = {"scope_attach"},
        Offset = {
            vpos = Vector(-0.1, 0, 2.8),
            vang = Angle(0, -90, 0),
        },
        CorrectiveAng = Angle(0, 180, 0),
        CorrectivePos = Vector(0, 0, 0),
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        Bone = "DC_15X_Rifle",
        Offset = {
            vpos = Vector(-1, 14, 0.5),
            vang = Angle(0, -90, -90),
        },
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Standard",
        Slot = {"muzzle", "dlt19_muzzle", "dc15a_muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "DC_15X_Rifle",
        Offset = {
            vpos = Vector(-0.1, 19.8, 0.65),
            vang = Angle(0, -90, 0),
        },
    },
    {
        PrintName = "Foregrip",
        DefaultAttName = "None",
        Slot = {"foregrip"},
        Bone = "DC_15X_Rifle",
        Offset = {
            vpos = Vector(-0.05, 5.2, -1.53),
            vang = Angle(90, -90, -90),   
        }, 
    },
    {
        PrintName = "Mode",
        DefaultAttName = "None",
        Slot = {"sw_mode", "sw_mode_rifle"},
    },   
    {
        PrintName = "Ammunition",
        DefaultAttName = "Standard",
        Slot = {"ammo"}
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "DC_15X_Rifle",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(1.12, -5.1, -0.1),
            vang = Angle(0, -90, 0),
        },
    },
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        Bone = "DC_15X_Rifle",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Offset = {
            vpos = Vector(1.1, -8, 0.25),
            vang = Angle(0, -90, 0),
        },
    },
}

SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["fire"] = {
        Source = "fire"
    },
    ["idle_iron"] = {
        Source = false,
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_rifle.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_rifle.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload",
        LHIK = true,
        Mult = 1.5,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        SoundTable = {
            {s = "arccw/kraken/empire/dlt19/handling/magrelease.wav", t = 0.2 },
            {s = "arccw/kraken/empire/dlt19/handling/magout.wav", t = 0.4 },
            {s = "arccw/kraken/empire/dlt19/handling/mag_fetch.wav", t = 0.6 },   
            {s = "arccw/kraken/empire/dlt19/handling/magin.wav", t = 1.4 },   
            {s = "arccw/kraken/empire/dlt19/handling/boltback.wav", t = 1.6 },   
        },
    },
    ["fix"] = {
        Source = "overheat", 
        Mult = 2.5,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 55 / 30},
            {s = "ArcCW_Kraken.Grab", t = 53 / 30},
        },
    },
}
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_e5bx.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 -- Change this if you want to select the weapon with other number

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Confederacy Arsenal"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "E-5bx"
SWEP.Trivia_Class = "Blaster, Rifle"
SWEP.Trivia_Desc = "The E-5 blaster rifle, also known as Droid blaster, was a bulky blaster rifle manufactured by Baktoid Armor Workshop. It was reverse-engineered from a BlasTech design of the E-series. The E-5 visually resembled a blaster rifle nicknamed 'Beti' from the High Republic Era. The E-5C heavy blaster rifle was identical to the default E-5 blaster rifle, save for an added wooden stock and modified barrel."
SWEP.Trivia_Manufacturer = "Baktoid Armor Workshop"
SWEP.Trivia_Calibre = "Condensed Tibanna-Gas"
SWEP.Trivia_Country = "Confederacy of Independent Systems"
SWEP.IconOverride = "entities/arccw/kraken/republic-arsenal/e5_bx.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "00001000000000"

SWEP.MirrorVMWM = true
SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/kraken/cis/v_e5.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.MirrorWorldModel = nil
SWEP.ViewModelFOV = 65


SWEP.WorldModelOffset = {
    pos = Vector(-8.6, 5.5, -5),
    ang = Angle(-15, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1,
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 20
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatDelayTime = 0.2
SWEP.HeatFix = true

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 54
SWEP.DamageMin = 28
SWEP.RangeMin = 0
SWEP.Range = 300
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TraceNum = 1
SWEP.Tracer = "tracer_red"
SWEP.TracerCol = Color(250, 0, 0)

SWEP.HullSize = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 25

SWEP.Recoil = 0.6
SWEP.RecoilSide = 0.3
SWEP.RecoilRise = 0.6

SWEP.Delay = 60 / 300
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
		Mode = 2,
    },
	{
		Mode = 0,
   	}
}

SWEP.AccuracyMOA = 5
SWEP.HipDispersion = 200
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.95
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.30

-- Ammo, Sounds & MuzzleEffect
local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0

SWEP.FirstShootSound = "ArcCW_Kraken.SW_E5BX"
SWEP.ShootSound = "ArcCW_Kraken.SW_E5BX"
SWEP.DistantShootSound = "ArcCW_Kraken.StandardCorebass"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"

SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-4.851, -1.285, 0.674),
    Ang = Vector(0, 0, 0),
     Magnification = 1.5,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.SprintPos = Vector(2, -1, 0)
SWEP.SprintAng = Angle(-10, 26, 0)

SWEP.CustomizePos = Vector(10, 0, 2)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 3)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(-3, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        VMElements = {
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "dlt34",
                Scale = Vector(0, 0, 0),                
                Offset = {
                    pos = Vector(-2, 2, 20),
                    ang = Angle(90, 0, 0),
                },
                IsMuzzleDevice = true,
            }
         }, 
    },
    ["scope_attach"] = {
        VMBodygroups = {{ind = 1, bg = 1}},
    },
}

SWEP.Attachments = {
    {
        PrintName = "Optic",
        DefaultAttName = "E-5 Holosight",
        Slot = "optic", 
        Bone = "dlt34",
        InstalledEles = {"scope_attach"},
        Offset = {
            vpos = Vector(-0.15, -4.1, 0.8),
            vang = Angle(90, 0, -90),
        },
        CorrectiveAng = Angle(0, 0, 0),
        CorrectivePos = Vector(0, 0, 0),
    },          
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "dlt34",
        Offset = {
            vpos = Vector(-0.15, -1.85, 14.8),
            vang = Angle(90, 0, -90),
        },
    },  
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Bone = "dlt34", 
        Offset = {
            vpos = Vector(-1.05, -1.9, 10),
            vang = Angle(90, 0, -180),
        },
    },  
    {
        PrintName = "Mode",
        DefaultAttName = "None",
        Slot = {"sw_mode", "sw_mode_rifle"},
    },   
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = "uc_fg",
    },   
    {
        PrintName = "Ammunition", 
        DefaultAttName = "Standard",
        Slot = "ammo",
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Charms",
        DefaultAttName = "None",
        Slot = {"charm"},
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Bone = "dlt34",
        Offset = {
            vpos = Vector(0.85, -0.05, 4.3),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Bone = "dlt34",
        Offset = {
            vpos = Vector(1.4, -1.5, 3.25),
            vang = Angle(90, 0, -90),
        },
    },         
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "Neutral"
    },
    ["fire"] = {
        Time = 0.6,
        Source = {"fire"},
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_rifle.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_rifle.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "overheat", 
        Mult = 2.2,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 55 / 30},
            {s = "ArcCW_Kraken.Grab", t = 53 / 30},
        },
    },
    ["fix"] = {
        Source = "overheat", 
        Mult = 2.5,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 55 / 30},
            {s = "ArcCW_Kraken.Grab", t = 53 / 30},
        },
    },
}
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_e5c.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 -- Change this if you want to select the weapon with other number

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Confederacy Arsenal"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "E-5c"
SWEP.Trivia_Class = "Blaster Rifle"
SWEP.Trivia_Desc = "The E-5C heavy blaster rifle, known simply as the E-5C, was a model of heavy blaster rifle. The E-5C was identical to the default E-5 blaster rifle used by the battle droids, save for an added wooden stock and modified barrel. The bounty hunter C-21 Highsinger used an E-5C during the Clone Wars. Hondo Ohnaka's pirates also made use of this weapon, particularly Gwarm. The Heavy Battle Droids employed by the Confederacy of Independent Systems were notorious for using these blasters to rain fire upon the clone troopers of the Galactic Republic. Standard B1-series battle droids were also sometimes equipped with the E-5C as 'E-5C B1 Troopers.'"
SWEP.Trivia_Manufacturer = "Baktoid Armor Workshop"
SWEP.Trivia_Calibre = "Condensed Tibanna-Gas"
SWEP.Trivia_Country = "Confederacy of Independent Systems"
SWEP.IconOverride = "entities/arccw/kraken/republic-arsenal/e5c.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "00001000000000"

SWEP.MirrorVMWM = true
SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/kraken/cis/v_e5c.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dlt19.mdl"

SWEP.MirrorWorldModel = nil
SWEP.ViewModelFOV = 65


SWEP.WorldModelOffset = {
    pos = Vector(-8.6, 5.5, -5),
    ang = Angle(-15, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1,
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 25
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatDelayTime = 0.2
SWEP.HeatFix = true

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 38
SWEP.DamageMin = 20
SWEP.RangeMin = 0
SWEP.Range = 300
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TraceNum = 1
SWEP.Tracer = "tracer_red"
SWEP.TracerCol = Color(250, 0, 0)

SWEP.HullSize = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 50

SWEP.Recoil = 0.5
SWEP.RecoilSide = 0.3
SWEP.RecoilRise = 0.6

SWEP.Delay = 60 / 300
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
		Mode = 2,
    },
	{
		Mode = 0,
   	}
}

SWEP.AccuracyMOA = 5
SWEP.HipDispersion = 200
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200


-- Speed Mult
SWEP.SpeedMult = 0.95
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.30

-- Ammo, Sounds & MuzzleEffect
local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0

SWEP.FirstShootSound = "ArcCW_Kraken.SW_E5C"
SWEP.ShootSound = "ArcCW_Kraken.SW_E5C"
SWEP.DistantShootSound = "ArcCW_Kraken.StandardCorebass"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"

SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-4.851, -1.285, 0.674),
    Ang = Vector(0, 0, 0),
     Magnification = 1.5,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.SprintPos = Vector(2, -1, 0)
SWEP.SprintAng = Angle(-10, 26, 0)

SWEP.CustomizePos = Vector(10, 0, 2)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 3)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(-3, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        VMElements = {
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "dlt34",
                Scale = Vector(0, 0, 0),                
                Offset = {
                    pos = Vector(-2, 2, 24),
                    ang = Angle(90, 0, 0),
                },
                IsMuzzleDevice = true,
            }
         }, 
    },
    ["scope_attach"] = {
        VMBodygroups = {{ind = 1, bg = 1}},
    },
}

SWEP.Attachments = {
    {
        PrintName = "Optic",
        DefaultAttName = "E-5 Holosight",
        Slot = "optic", 
        Bone = "dlt34",
        InstalledEles = {"scope_attach"},
        Offset = {
            vpos = Vector(-0.15, -4.4, 2),
            vang = Angle(90, 0, -90),
        },
        CorrectiveAng = Angle(0, 0, 0),
        CorrectivePos = Vector(0, 0, 0),
    },          
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "dlt34",
        Offset = {
            vpos = Vector(-0.15, -1.45, 24),
            vang = Angle(90, 0, -90),
        },
    },  
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Bone = "dlt34", 
        Offset = {
            vpos = Vector(-1.5, -1.6, 17),
            vang = Angle(90, 0, -180),
        },
    }, 
        {
        PrintName = "Mode",
        DefaultAttName = "None",
        Slot = {"sw_mode", "sw_mode_rifle"},
    },    
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = "uc_fg",
    },   
    {
        PrintName = "Ammunition", 
        DefaultAttName = "Standard",
        Slot = "ammo",
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Charms",
        DefaultAttName = "None",
        Slot = {"charm"},
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Bone = "dlt34",
        Offset = {
            vpos = Vector(0.92, -1.4, 6),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Bone = "dlt34",
        Offset = {
            vpos = Vector(1.2, -1.4, 9),
            vang = Angle(90, 0, -90),
        },
    },         
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "Neutral"
    },
    ["fire"] = {
        Time = 0.6,
        Source = {"fire"},
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_rifle.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_rifle.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "overheat", 
        Mult = 2.2,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 55 / 30},
            {s = "ArcCW_Kraken.Grab", t = 53 / 30},
        },
    },
    ["fix"] = {
        Source = "overheat", 
        Mult = 2.5,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 55 / 30},
            {s = "ArcCW_Kraken.Grab", t = 53 / 30},
        },
    },
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_f10.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_fwmb10.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arccw_k_launcher_plx1.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arccw_k_launcher_rps6.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arccw_k_launcher_rps6.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true

SWEP.Slot = 3

SWEP.Category = "[ArcCW] Kraken's Explosives - Rocket Launchers"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "Republic RPS-6"
SWEP.Trivia_Class = "Rocket Launcher"
SWEP.Trivia_Desc = "The RPS-6 rocket launcher, also known as the Sienar shoulder-launched missile, was a model of missile launcher manufactured by Merr-Sonn Munitions, Inc. and Sienar Fleet Systems."
SWEP.Trivia_Manufacturer = "Sienar Fleet Systems, Merr-Sonn Munitions Inc"
SWEP.Trivia_Calibre = "Rocket"
SWEP.IconOverride = "entities/kraken/explosives/rps6.png"

-- Base
SWEP.DefaultBodygroups = "0000000000000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sw/explosives/v_rps6_republic.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 60

SWEP.WorldModelOffset = {
    pos = Vector(-15, 0, 49),
    ang = Angle(0, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Damage & Tracer
SWEP.ShootEntity = "rocket_rps"
SWEP.MuzzleVelocity = 6000

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 1

SWEP.Recoil = 4.3
SWEP.RecoilSide = 0.550
SWEP.RecoilRise = 2
SWEP.RecoilPunch = 2.5
SWEP.RecoilVMShake = 1.5
SWEP.VisualRecoilMult = 0.7

SWEP.Delay = 60 / 60
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
}

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 200
SWEP.MoveDispersion = 100
SWEP.JumpDispersion = 500

-- Speed Mult
SWEP.SpeedMult = 0.725
SWEP.SightedSpeedMult = 0.70
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.70

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "RPG_Round"
SWEP.ShootVol = 120
SWEP.ShootPitch = 95
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "kraken/launchers/rps/weap_rpapa7_fire_plr_01.ogg"
SWEP.ShootSound = "kraken/launchers/rps/weap_rpapa7_fire_plr_01.ogg"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "muzzleflash_m79"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 137, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-1.04, -5, 0.31),
    Ang = Vector(16, 0, -4),
     Magnification = 4,
     SwitchToSound = "kraken/launchers/rps/wfoly_la_rpapa7_ads_up.ogg",
     SwitchFromSound = "kraken/launchers/rps/wfoly_la_rpapa7_ads_down.ogg",
     ViewModelFOV = 55,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "rpg"
SWEP.HoldtypeSights = "rpg"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN

SWEP.ActivePos = Vector(0, 0, 0)
SWEP.ActiveAng = Angle(16, 0, -5)

SWEP.SprintPos = Vector(4.019, -5.226, -2)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CrouchPos = Vector(-4.5, -7, -3)
SWEP.CrouchAng = Angle(0, 0, -29)

SWEP.CustomizePos = Vector(10, 0, 2)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.Attachments = {
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.6, 0.6, 0.6),
        WMScale = Vector(0.6, 0.6, 0.6),
        Bone = "tag_launcher_offset",
        Offset = {
            vpos = Vector(10, -1.4, 0.25),
            vang = Angle(0, 0, 90),
        },
    }, 
    {
        PrintName = "Ammunition",
        DefaultAttName = "Rocket",
        Slot = {"k_rocket_ammo"}
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(1, 1, 1),
        WMScale = Vector(1, 1, 1),
        Bone = "tag_launcher_offset",
        Offset = {
            vpos = Vector(1.9, -0.42, -2),
            vang = Angle(0, 0, 0),
        },
    }, 
}


-- Animations!
local path = "kraken/launchers/rps/"

SWEP.BulletBones = {
    [1] = "j_mag1",
}

SWEP.Animations = {
	["enter_sights"] = {
		Source = "idle",
	},
    ["fire"] = {
        Source = "shoot1",
    },
    ["dryfire"] = {
        Source = "firemode",
		MinProgress = 0.01,
		FireASAP = true,
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
		MinProgress = 0.95,
        SoundTable = {
			{s = path .. "wfoly_la_rpapa7_reload_raise.ogg", t = 0.1},
			{s = path .. "wfoly_la_rpapa7_reload_load.ogg", t = 0.333},
			{s = path .. "wfoly_la_rpapa7_reload_lower.ogg", t = 1.033},
			{s = path .. "wfoly_la_rpapa7_reload_fast_hip_safetyclick.ogg", t = 1.7},
			{s = path .. "wfoly_la_rpapa7_reload_end.ogg", t = 1.9},
        },
    },
    ["ready"] = {
        Source = "draw",
        SoundTable = {
            {s = path .. "wfoly_la_rpapa7_raise_first.ogg", t = 9/30},
        },
    },
    ["draw"] = {
        Source = "draw_short",
		MinProgress = 0.5,
        SoundTable = {
            {s = path .. "wfoly_la_rpapa7_raise.ogg", t = 0/30},
        },
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {s = path .. "wfoly_la_rpapa7_drop_hip_rattle.ogg", t = 0/30},
        },
    },
    ["idle"] = {
        Source = "idle",
    },
    ["enter_customize"] = {
        Source = "lookat01",
        SoundTable = {
            {s = path .. "wfoly_la_rpapa7_inspect_01.ogg", t = 5/30},
			{s = path .. "wfoly_la_rpapa7_inspect_02.ogg", t = 88/30},
			{s = path .. "wfoly_la_rpapa7_inspect_03.ogg", t = 165/30},
        },
    },
    ["idle_customize"] = {
        Source = "lookat01",
        SoundTable = {
            {s = path .. "wfoly_la_rpapa7_inspect_01.ogg", t = 5/30},
			{s = path .. "wfoly_la_rpapa7_inspect_02.ogg", t = 88/30},
			{s = path .. "wfoly_la_rpapa7_inspect_03.ogg", t = 165/30},
        },
    },
    ["exit_customize"] = {
        Source = "lookat01",
        SoundTable = {
            {s = path .. "wfoly_la_rpapa7_inspect_01.ogg", t = 5/30},
			{s = path .. "wfoly_la_rpapa7_inspect_02.ogg", t = 88/30},
			{s = path .. "wfoly_la_rpapa7_inspect_03.ogg", t = 165/30},
        },
    },
    ["bash"] = {
        Source = "melee_01",
    },
}
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arccw_k_launcher_rps6_empire.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_m45.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 4 

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "'Roba' M-45"
SWEP.Trivia_Class = "Repeating Ion Blaster"
SWEP.Trivia_Desc = "The 'Roba' M-45 repeating ion blaster, manufactured by BlasTech Industries, was a heavy repeating ion blaster that saw use during the Galactic Civil War, typically pintel-mounted on UT-60D U-wing gunships."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/galactic/m45.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "0000000011000000000000"

SWEP.HideViewmodel = false
SWEP.MirrorVMWM = true
SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/kraken/galactic/v_m45.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dlt19.mdl"
SWEP.ViewModelFOV = 70

SWEP.WorldModelOffset = {
    pos = Vector(-9, 3.5, -5),
    ang = Angle(-10, -90, 180),
    scale = 1,
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 45
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatDelayTime = 0.5
SWEP.HeatFix = true

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 34
SWEP.DamageMin = 19
SWEP.RangeMin = 0
SWEP.Range = 500
SWEP.Penetration = 8
SWEP.DamageType = DMG_BLAST
SWEP.MuzzleVelocity = 9000

SWEP.TraceNum = 1
SWEP.Tracer = "tracer_red"
SWEP.TracerCol = Color(250, 0, 0)

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 100

SWEP.Recoil = 0.75
SWEP.RecoilSide = 0.35
SWEP.RecoilRise = 0.65
SWEP.RecoilPunch = 0.5

SWEP.Delay = 60 / 666
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
        PostBurstDelay = 0.1,
    },
    {
		Mode = 2,
        PostBurstDelay = 0.1,
    },
    {
        Mult_RPM = 2,
		Mode = -3,
        PostBurstDelay = 0.1,
    },
	{
		Mode = 0,
   	}
}

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 250
SWEP.MoveDispersion = 200
SWEP.JumpDispersion = 150

-- Speed Mult
SWEP.SpeedMult = 1.10
SWEP.SightedSpeedMult = 0.75
SWEP.ShootSpeedMult = 1.05

-- Sounds & Muzzleflash
SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 125
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.FirstShootSound = "ArcCW_Kraken.SW_M45"
SWEP.ShootSound = "ArcCW_Kraken.SW_M45"
SWEP.DistantShootSound = "ArcCW_Kraken.StandardCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.BulletBones = {
    [17] = "j_b_01",
    [16] = "j_b_02",
	[15] = "j_b_03",
	[14] = "j_b_04",
	[13] = "j_b_05",
	[12] = "j_b_06",
	[11] = "j_b_07",
	[10] = "j_b_08",
	[9] = "j_b_09",
	[8] = "j_b_10",
	[7] = "j_b_11",
	[6] = "j_b_12",
	[5] = "j_b_13",
	[4] = "j_b_14",
	[3] = "j_b_15",
	[2] = "j_b_16",
	[1] = "j_b_17",
}

SWEP.MuzzleFlashColor = Color(250, 0, 0)
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.GMMuzzleEffect = false

-- Ironsight & Holdtype
SWEP.IronSightStruct = {
    Pos = Vector(-4.07, -3, 0.7),
    Ang = Angle(-0.2, 0, -1.5),
     Magnification = 1.5,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 55,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(-2, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, 0, 1.5)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.CrouchPos = Vector(-4, 0, -1)
SWEP.CrouchAng = Angle(0, 0, -10)

SWEP.HolsterPos = Vector(3, 3, 0)
SWEP.HolsterAng = Angle(-7.036, 30.016, 0)

SWEP.BarrelOffsetSighted = Vector(0, 0, -1)
SWEP.BarrelOffsetHip = Vector(2, 0, -2)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(20, 30.7, 10.3)

-- Attachments 
SWEP.AttachmentElements = {
    ["grip_attach"] = {
        VMBodygroups = {{ind = 3, bg = 1}},
    },
    ["laser_attach"] = {
        VMBodygroups = {{ind = 6, bg = 1}},
    },
    ["scope_attach"] = {
        VMBodygroups = {{ind = 8, bg = 0}},
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Optics", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "tag_attachments",
        InstalledEles = {"scope_attach"},
        Offset = {
            vpos = Vector(8, 0, 2.5),
            vang = Angle(0, 0, 0),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0)
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "stealth_muzzle"},
        VMScale = Vector(1.2, 1.2, 1.2),
        WMScale = Vector(1.2, 1.2, 1.2),
        Bone = "tag_attachments",
        Offset = {
            vpos = Vector(44.3, 0, 0.5),
            vang = Angle(0, 0, 0),
        },
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.8, 0.8, 0.8),
        WMScale = Vector(0.8, 0.8, 0.8),
        InstalledEles = {"laser_attach"},
        Bone = "tag_attachments",
        Offset = {
            vpos = Vector(21.1, 0.6, -0.9),
            vang = Angle(0, 0, -90),
        },
    },  
    {
        PrintName = "Underbarrel",
        DefaultAttName = "None",
        Slot = {"foregrip"},
        VMScale = Vector(1, 1, 1),
        WMScale = Vector(1, 1, 1),
        Bone = "tag_attachments",
        InstalledEles = {"grip_attach"},
        Offset = {
            vpos = Vector(16, 0, -1.8),
            vang = Angle(0, 0, 0),
        },
    },  
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.6, 0.6, 0.6),
        WMScale = Vector(0.6, 0.6, 0.6),
        Bone = "tag_attachments",
        Offset = {
            vpos = Vector(6.5, -0.39, 0.85),
            vang = Angle(0, 0, 0),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        Bone = "tag_attachments",
        Offset = {
            vpos = Vector(10.4, -0.7, -0.5),
            vang = Angle(0, 0, 30),
        },
    },
}

-- Don't touch this unless you know what you're doing
local path = "arccw/kraken/sw_galactic/weapons/m45/handling/"

SWEP.Animations = {
    ["fire"] = {
        Source = "shoot1",
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["ready"] = {
        Source = "draw",
		MinProgress = 0.7,
        SoundTable = {
            {s = path .. "wfoly_lm_kilo121_raise_first_raise.ogg", t = 0.1/30},
            {s = path .. "wfoly_lm_kilo121_raise_first_raise_01.ogg", t = 0.1/30},
			{s = path .. "wfoly_lm_kilo121_raise_first_drop.ogg", t = 11/30},
			{s = path .. "wfoly_lm_kilo121_raise_first_rattle.ogg", t = 22/30},
			{s = path .. "wfoly_lm_kilo121_reload_boltopen_01.ogg", t = 30/30},
			{s = path .. "wfoly_lm_kilo121_reload_boltclose_01.ogg", t = 43/30},
			{s = path .. "wfoly_lm_kilo121_raise_first_cloth01.ogg", t = 51/30},
			{s = path .. "wfoly_lm_kilo121_raise_first_end.ogg", t = 59/30},
        },
    },
    ["draw"] = {
        Source = "draw_short",
		MinProgress = 0.5,
        SoundTable = {
            {s = path .. "wfoly_lm_kilo121_raise.ogg", t = 0.1/30},
        },
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {s = path .. "wfoly_lm_kilo121_reload_empty_end.ogg", t = 0.1/30},
        },
    },
    ["idle"] = {
        Source = "idle",
    },
    ["idle_sprint"] = {
        Source = "sprint",
    },
    ["exit_sprint"] = {
        Source = "sprint_out",
		Time = 1.25,
    },
    ["enter_sprint"] = {
        Source = "sprint_in",
		IKTimeLine = { { t = 0,  lhik = 1, rhik = 1} },
		Time = 1.25,
    },
    ["bash"] = {
        Source = {"melee","melee2","melee3"},
    },
    ["fix"] = {
        Source = "jam",
        Mult = 2,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 0.1/30},
            {s = "ArcCW_Kraken.OverheatFix", t = 35/30},
            {s = "ArcCW_Kraken.Grab", t = 36 / 30},
        },
    },
    ["reload"] = {
        Source = "reload_short",
		MinProgress = 0.95,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
			{s = path .. "wfoly_lm_kilo121_reload_raise.ogg", t = 0.1/30},
			{s = path .. "wfoly_lm_kilo121_reload_boltopen_01.ogg", t = 23/30},
            {s = "ArcCW_Kraken.Overheat", t = 23/30},
			{s = path .. "wfoly_lm_kilo121_reload_boltclose_01.ogg", t = 37/30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 37/30},
			{s = path .. "wfoly_lm_kilo121_reload_lower.ogg", t = 44/30},
			{s = path .. "wfoly_lm_kilo121_reload_coveropen_01.ogg", t = 65/30},
			{s = path .. "wfoly_lm_kilo121_reload_magout_01.ogg", t = 86/30},
			{s = path .. "wfoly_lm_kilo121_reload_boxmag.ogg", t = 110/30},
			{s = path .. "wfoly_lm_kilo121_reload_magin_01.ogg", t = 128/30},
			{s = path .. "wfoly_lm_kilo121_reload_click_01.ogg", t = 151/30},
            {s = "ArcCW_Kraken.OverheatFix", t = 180/30},
			{s = path .. "wfoly_lm_kilo121_reload_coverclose_01.ogg", t = 174/30},
			{s = path .. "wfoly_lm_kilo121_reload_end.ogg", t = 201/30},
        },
    },
    ["reload_empty"] = {
        Source = "reload",
		MinProgress = 0.9,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
			{s = path .. "wfoly_lm_kilo121_reload_empty_lift.ogg", t = 0.1/30},
			{s = path .. "wfoly_lm_kilo121_reload_empty_boltopen_01.ogg", t = 23/30},
            {s = "ArcCW_Kraken.Overheat", t = 23/30},
			{s = path .. "wfoly_lm_kilo121_reload_empty_boltclose_01.ogg", t = 37/30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 37/30},
			{s = path .. "wfoly_lm_kilo121_reload_empty_lower.ogg", t = 44/30},
			{s = path .. "wfoly_lm_kilo121_reload_empty_coveropen_01.ogg", t = 65/30},
			{s = path .. "wfoly_lm_kilo121_reload_empty_clean.ogg", t = 83/30},
			{s = path .. "wfoly_lm_kilo121_reload_empty_inspect.ogg", t = 106/30},
			{s = path .. "wfoly_lm_kilo121_reload_empty_magout_01.ogg", t = 114/30},
			{s = path .. "wfoly_lm_kilo121_reload_empty_raise_01.ogg", t = 126/30},
			{s = path .. "wfoly_lm_kilo121_reload_empty_boxmag.ogg", t = 142/30},
			{s = path .. "wfoly_lm_kilo121_reload_empty_magin_01.ogg", t = 155/30},
			{s = path .. "wfoly_lm_kilo121_reload_empty_beltmvmnt.ogg", t = 164/30},
			{s = path .. "wfoly_lm_kilo121_reload_empty_click_01.ogg", t = 176/30},
			{s = path .. "wfoly_lm_kilo121_reload_empty_mvmnt01.ogg", t = 193/30},
			{s = path .. "wfoly_lm_kilo121_reload_empty_coverclose_01.ogg", t = 201/30},
            {s = "ArcCW_Kraken.OverheatFix", t = 210/30},
			{s = path .. "wfoly_lm_kilo121_reload_empty_end.ogg", t = 223/30},
        },
    },
    ["exit_inspect"] = {
        Source = "lookat01",
		MinProgress = 0.9,
        SoundTable = {
            {s = path .. "wfoly_lm_kilo121_inspect_01.ogg", t = 0/30},
			{s = path .. "wfoly_lm_kilo121_inspect_02.ogg", t = 55/30},
			{s = path .. "wfoly_lm_kilo121_inspect_03.ogg", t = 113/30},
        },
    },
    ["enter_bipod"] = {
        Source = "bipod_in",
    },
    ["exit_bipod"] = {
        Source = "bipod_out",
    },
}

--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_md12.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "MD-12"
SWEP.Trivia_Class = "Blaster Scatter"
SWEP.Trivia_Desc = "Blaster Scatter designed originally for military purposes, now modernized and being used by many Bounty Hunters, Civillians and even Mercenaries or Military Corporations in the galaxy."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/galactic/md12.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "00000000000000"

SWEP.UseHands = true
SWEP.MirrorVMWM = true
SWEP.ViewModel = "models/arccw/kraken/galactic/v_md12.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 70

SWEP.WorldModelOffset = {
    pos = Vector(-7, 3, -3),
    ang = Angle(-15, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1.3,
}

-- Damage & Tracer
SWEP.NoRandSpread = true
SWEP.CanBash = true

SWEP.ShotgunSpreadPattern = {
    [1] = Angle(0, 0, 0),
    [2] = Angle(0, 1, 0),
    [3] = Angle(0, -1, 0),
    [4] = Angle(2.1, 0, 0),
    [5] = Angle(-2.1, 0, 0),
    [6] = Angle(1.4, 1.2, 0),
    [7] = Angle(-1.4, 1.2, 0),
    [8] = Angle(1.4, -1.2, 0),
    [9] = Angle(-1.4, -1.2, 0),
}


SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 8
SWEP.HeatDissipation = 7
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 33
SWEP.DamageMin = 25
SWEP.RangeMin = 0
SWEP.Range = 500
SWEP.Penetration = 8
SWEP.DamageType = DMG_BUCKSHOT
SWEP.MuzzleVelocity = 9000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(250, 0, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_red"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 31

SWEP.Recoil = 1.5
SWEP.RecoilSide = 1
SWEP.RecoilRise = 2
SWEP.MaxRecoilBlowback = 2
SWEP.RecoilPunch = 1.9
SWEP.RecoilVMShake = 2

SWEP.Delay = 60 / 180
SWEP.Num = 9
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 2,
    },
    {
        Mode = -3,
        PostBurstDelay = 0.1,
        RunawayBurst = false,
        Mult_RPM = 3,
    },
    {
		Mode = 1,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 150
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 90
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "ArcCW_Kraken.SW_MD12"
SWEP.ShootSound = "ArcCW_Kraken.SW_MD12"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-3.05, -4, 0.8),
    Ang = Vector(4, 0, -2.878),
    Magnification = 1.15,
    SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
    SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
    ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.HoltypeCustomize = "slam"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN

SWEP.ActivePos = Vector(-2, 0, 0)
SWEP.ActiveAng = Angle(0, 0, -2)

SWEP.SprintPos = Vector(4.019, -5.226, -2)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 0, 1)

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "E11S_CONTR",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(-2.4, 13, -5),
                   ang = Angle(-90, -90, 0),
               },
               IsMuzzleDevice = true,
           }
        }, 
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Optics", 
        DefaultAttName = "Iron Sight",
        Slot = "optic",
        Bone = "E11S_CONTR",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(0.0, -1, 1.5),
            vang = Angle(0, -90, 0),
        },
        CorrectiveAng = Angle(0, 180, 0),
        CorrectivePos = Vector(0, 0, -0.01),
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(-0.87, 6, 0.5),
            vang = Angle(-90, -90, 0),
        },
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Standard",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        VMScale = Vector(1.2, 1.2, 1.2),
        WMScale = Vector(1.2, 1.2, 1.2),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(-0, 9, 0.5),
            vang = Angle(0, -90, 0),
        },
    },
    {
        PrintName = "Foregrip",
        DefaultAttName = "Standard",
        Slot = {"foregrip"},
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(0, 3.7, -2.7),
            vang = Angle(0, -90, 0), 
        },
    },  
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(0.82, -2.25, 0.1),
            vang = Angle(0, -90, 0),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(0.8, 0.8, 0.8),
        WMScale = Vector(0.8, 0.8, 0.8),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(1, -6.3, 0),
            vang = Angle(0, -90, 0),
        },
    },   
}
-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
	["fire"] = {
        Source = "shoot",
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arccw_k_nade_blaststick.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arccw_k_nade_impact.lua:
AddCSLuaFile()

SWEP.Base = "arccw_k_nade_base"
SWEP.Spawnable = true

SWEP.Slot = 4

SWEP.Category = "[ArcCW] Kraken's Explosives - Grenades"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "Impact Grenade"
SWEP.Trivia_Class = "Hand Grenade, High Explosive"
SWEP.Trivia_Desc = "An impact grenade was a grenade designed to explode on contact with any object or surface, rather than on a timer or proximity detection. It had a smaller blast radius than devices like the thermal detonator."
SWEP.Trivia_Manufacturer = "BlastTech Industries, Merr Sonn Munitions Inc."
SWEP.Trivia_Calibre = "Contact Explosive"
SWEP.Trivia_Mechanism = "Explosive"
SWEP.Trivia_Country = "Universal"
SWEP.IconOverride = "entities/kraken/explosives/impact.png"

-- Base
SWEP.DefaultBodygroups = "0000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sw/explosives/v_impact.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 60

SWEP.WorldModelOffset = {
    pos = Vector(-15, 6, -2),
    ang = Angle(-10, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1,
}

-- Damage & Tracer
SWEP.ShootEntity = "nade_k_thrown_impact"

SWEP.MuzzleVelocity = 1200
SWEP.MuzzleVelocityAlt = 700

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 1

SWEP.FuseTime = 3.5
SWEP.PullPinTime = 0.5

SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 1,
    },
}

-- Speed Mult
SWEP.SpeedMult = 0.925
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "grenade"

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "grenade"
SWEP.HoldtypeSights = "grenade"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_GRENADE

SWEP.ActivePos = Vector(0, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, -1, -0.3)
SWEP.SprintAng = Angle(3, -5, 0)

SWEP.CrouchPos = Vector(-0.5, -0, -1)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

-- Animations
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["idle_primed"] = {
        Source = "idle_primed"
    },
    ["draw"] = {
        Source = "deploy",
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.Draw", t = 0.1/30},
        },
    },
    ["holster"] = {
        Source = "holster",
		Mult = 0.5,
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.Holster", t = 0.1/30},
        },
    },
    ["pre_throw"] = {
        Source = "pullpin",
        MinProgress = 0.666,
        FireASAP = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.PreThrow", t = 0.1/30},
        },
    },
    ["throw"] = {
        Source = "throw",
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.Throw", t = 0.1/30},
        },
        MinProgress = 0.3
    },
    ["throw_alt"] = {
        Source = "underhand",
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.Throw", t = 0.1/30},
        },
        MinProgress = 0.3
    }
}
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arccw_k_nade_stun.lua:
AddCSLuaFile()

SWEP.Base = "arccw_k_nade_base"
SWEP.Spawnable = true

SWEP.Slot = 4

SWEP.Category = "[ArcCW] Kraken's Explosives - Grenades"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "Stun Grenade"
SWEP.Trivia_Class = "Hand Grenade, Stun"
SWEP.Trivia_Desc = "A stun grenade, also known as a flash grenade, flashbang, thunderflash, or sound bomb, is a non-lethal explosive device used to temporarily disorient an enemy's senses. Upon detonation, a stun grenade produces a blinding flash of light and an extremely loud 'bang'. They are often used in close-quarters combat, door breaching, and riot control, typically to stun enemies or distract them."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Explosive"
SWEP.Trivia_Mechanism = "Stun Effect"
SWEP.Trivia_Country = "Universal"
SWEP.IconOverride = "entities/kraken/explosives/base.png"

-- Base
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sw/explosives/v_grenade_base.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 56

SWEP.WorldModelOffset = {
    pos = Vector(-16, 6, -2),
    ang = Angle(-10, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1,
}


-- Damage & Tracer
SWEP.ShootEntity = "nade_k_thrown_stun"

SWEP.MuzzleVelocity = 900
SWEP.MuzzleVelocityAlt = 500

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 1

SWEP.FuseTime = 3.5
SWEP.PullPinTime = 0.5

SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 1,
    },
}

-- Speed Mult
SWEP.SpeedMult = 0.925
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "grenade"

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "grenade"
SWEP.HoldtypeSights = "grenade"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_GRENADE

SWEP.ActivePos = Vector(0, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, -1, -0.3)
SWEP.SprintAng = Angle(3, -5, 0)

SWEP.CrouchPos = Vector(-0.5, -0, -1)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

-- Animations
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["idle_primed"] = {
        Source = "idle_primed"
    },
    ["draw"] = {
        Source = "deploy",
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.Draw", t = 0.1/30},
        },
    },
    ["holster"] = {
        Source = "holster",
		Mult = 0.5,
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.Holster", t = 0.1/30},
        },
    },
    ["pre_throw"] = {
        Source = "pullpin",
        MinProgress = 0.666,
        FireASAP = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.PreThrow", t = 0.1/30},
        },
    },
    ["throw"] = {
        Source = "throw",
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.Throw", t = 0.1/30},
        },
        MinProgress = 0.3
    },
    ["throw_alt"] = {
        Source = "underhand",
        SoundTable = {
            {s = "ArcCW_Kraken.Explosives.Throw", t = 0.1/30},
        },
        MinProgress = 0.3
    }
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_nt242.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 4 -- Change this if you want to select the weapon with other number

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "NT-242"
SWEP.Trivia_Class = "Sniper"
SWEP.Trivia_Desc = "The NT-242 was a type of sniper rifle. The NT-242 was considered a tank buster by many users and was one of the heaviest longblasters. The NT-242 was powerful at range, and could be modified to have a disruptor shot which could engage vehicles."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/galactic/nt242.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "011200000000000000"

SWEP.HideViewmodel = false
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/galactic/v_nt242.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dlt19.mdl"
SWEP.ViewModelFOV = 70

SWEP.WorldModelOffset = {
    pos = Vector(-1, 0.6, -3),
    ang = Angle(-5, 0, 180),
    scale = 1,
}

-- Damage & Tracer
SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 135
SWEP.DamageMin = 96
SWEP.RangeMin = 0
SWEP.Range = 1200
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TraceNum = 1
SWEP.Tracer = "tracer_purple"
SWEP.TracerCol = Color(150, 0, 250)

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 14

SWEP.Recoil = 2.5
SWEP.RecoilSide = 0.6
SWEP.RecoilRise = 0.8
SWEP.RecoilPunch = 2.5

SWEP.Delay = 60 / 180
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
        PostBurstDelay = 0.1,
    },
	{
		Mode = 0,
   	}
}


SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 250
SWEP.MoveDispersion = 100
SWEP.JumpDispersion = 150

-- Speed Mult
SWEP.SpeedMult = 0.85
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.30

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.FirstShootSound = "ArcCW_Kraken.SW_NT242"
SWEP.ShootSound = "ArcCW_Kraken.SW_NT242"
SWEP.DistantShootSound = "ArcCW_Kraken.StandardCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.MuzzleFlashColor = Color(150, 0, 250)
SWEP.MuzzleEffect = "blaster_muzzle_purple"
SWEP.GMMuzzleEffect = false

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-3.48, -0, 0.5),
    Ang = Vector(3, 0.5, -2),
     Magnification = 1.5,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 55,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN

SWEP.ActivePos = Vector(-1, 2, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(4.019, -5.226, -2)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CrouchPos = Vector(-4, 0, -1)
SWEP.CrouchAng = Angle(0, 0, -10)

SWEP.HolsterPos = Vector(3, 3, 0)
SWEP.HolsterAng = Angle(-7.036, 30.016, 0)

SWEP.BarrelOffsetSighted = Vector(0, 0, -1)
SWEP.BarrelOffsetHip = Vector(2, 0, -2)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(20, 30.7, 10.3)

SWEP.GuaranteeLaser = true

-- Attachments
SWEP.DefaultElements = {}
SWEP.AttachmentElements = {
    ["muzzle_attach"] = {
        VMBodygroups = {{ind = 2, bg = 3}},
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Optics", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "tag_attachments",
        Offset = {
            vpos = Vector(8, -0.0, 2.6),
            vang = Angle(0, 0, 0),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0)
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "stealth_muzzle"},
        Bone = "tag_attachments",
        VMScale = Vector(1.3, 1.3, 1.3),
        WMScale = Vector(1.3, 1.3, 1.3),
        InstalledEles = {"muzzle_attach"},
        Offset = {
            vpos = Vector(43.4, -0.0, 0.5),
            vang = Angle(0, 0, 0),
        },
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(1, 1, 1),
        WMScale = Vector(1, 1, 1),
        Bone = "tag_attachments",
        Offset = {
            vpos = Vector(23, 1, 0.4),
            vang = Angle(0, 0, -90),
        },
    },  
    {
        PrintName = "Underbarrel",
        DefaultAttName = "None",
        Slot = {"foregrip"},
        VMScale = Vector(1.2, 1.2, 1.2),
        WMScale = Vector(1.2, 1.2, 1.2),
        Bone = "tag_attachments",
        InstalledEles = {"grip_attach"},
        Offset = {
            vpos = Vector(20, 0, -0.8),
            vang = Angle(0, 0, 0),
        },
    },  
    {
        PrintName = "Magazine",
        DefaultAttName = "Standard",
        Slot = "bolter_mag",
    },
    {
        PrintName = "Cooling System",
        DefaultAttName = "None",
        Slot = "bolter_cooling",
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.6, 0.6, 0.6),
        WMScale = Vector(0.6, 0.6, 0.6),
        Bone = "tag_attachments",
        Offset = {
            vpos = Vector(4.8, -0.5, -1.1),
            vang = Angle(0, 0, 0),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        Bone = "tag_attachments",
        Offset = {
            vpos = Vector(9, -1, 0.8),
            vang = Angle(0, 0, 30),
        },
    },
}

-- Animations
local path = "arccw/kraken/sw_galactic/handling/nt242/"

SWEP.Animations = {
	["enter_sights"] = {
		Source = "ads_in",
	},
	["exit_sights"] = {
		Source = "ads_out",
	},
    ["fire"] = {
        Source = "shoot1",
        ShellEjectAt = false,
    },
    ["dryfire"] = {
        Source = "dryfire",
		MinProgress = 0.01,
		FireASAP = true,
    },
    ["reload"] = {
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        Source = "reload_short",
        LHIK = true,
		MinProgress = 0.975,
        SoundTable = {
            {s = path .. "wfoly_sn_xmike109_reload_up.ogg", t = 0.0},
            {s = path .. "wfoly_sn_xmike109_reload_magrelease.ogg", t = 0.9},
			{s = path .. "wfoly_sn_xmike109_reload_magout.ogg", t = 1.4},
			{s = path .. "wfoly_sn_xmike109_reload_arm.ogg", t = 2.367},
			{s = path .. "wfoly_sn_xmike109_reload_magin_01.ogg", t = 2.867},
			{s = path .. "wfoly_sn_xmike109_reload_magin_02.ogg", t = 3.1},
			{s = path .. "wfoly_sn_xmike109_reload_end.ogg", t = 3.567},
        },
    },
    ["reload_empty"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
		MinProgress = 0.975,
        SoundTable = {
            {s = path .. "wfoly_sn_xmike109_reload_empty_up.ogg", t = 0.033},
            {s = path .. "wfoly_sn_xmike109_reload_empty_magrelease.ogg", t = 1.05},
			{s = path .. "wfoly_sn_xmike109_reload_empty_magout.ogg", t = 1.45},
			{s = path .. "wfoly_sn_xmike109_reload_empty_arm.ogg", t = 2.2},
			{s = path .. "wfoly_sn_xmike109_reload_empty_magin_01.ogg", t = 2.78},
			{s = path .. "wfoly_sn_xmike109_reload_empty_magin_02.ogg", t = 3.2},
			{s = path .. "wfoly_sn_xmike109_reload_empty_rotate.ogg", t = 3.667},
			{s = path .. "wfoly_sn_xmike109_reload_empty_boltpull.ogg", t = 4.267},
			{s = path .. "wfoly_sn_xmike109_reload_empty_boltrelease.ogg", t = 4.8},
			{s = path .. "wfoly_sn_xmike109_reload_empty_end.ogg", t = 5.1},
        },
    },
    ["ready"] = {
        Source = "draw",
        SoundTable = {
            {s = path .. "wfoly_sn_xmike109_first_raise_up.ogg", t = 0.1},
            {s = path .. "wfoly_sn_xmike109_first_raise_bolt_pull.ogg", t = 0.6},
            {s = path .. "wfoly_sn_xmike109_first_raise_bolt_release.ogg", t = 1.0},
			{s = path .. "wfoly_sn_xmike109_first_raise_end.ogg", t = 36/30},
        },
    },
    ["draw"] = {
        Source = "draw_short",
        MinProgress = 0.3,
        SoundTable = {
            {s = path .. "wfoly_sn_xmike109_first_raise_up.ogg", t = 0/30},
			{s = path .. "wfoly_sn_xmike109_first_raise_end.ogg", t = 10/30},
        },
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {s = path .. "wfoly_sn_xmike109_first_raise_end.ogg", t = 0/30},
        },
    },
    ["idle"] = {
        Source = "idle",
    },
    ["exit_inspect"] = {
        Source = "lookat01",
        LHIK = true,
		MinProgress = 0.9,
        SoundTable = {
            {s = path .. "wfoly_sn_xmike109_inspect_up.ogg", t = 0.1},
			{s = path .. "wfoly_sn_xmike109_inspect_grabrotate.ogg", t = 1.7},
			{s = path .. "wfoly_sn_xmike109_inspect_move.ogg", t = 3.7},
			{s = path .. "wfoly_sn_xmike109_inspect_end.ogg", t = 111/30},
        },
    },
    ["bash"] = {
        Source = {"melee","melee2","melee3"},
        LHIK = true,
    },
    ["enter_bipod"] = {
        Source = "bipod_in",
    },
    ["exit_bipod"] = {
        Source = "bipod_out",
    },
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_nt242x.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 4 

SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "NT-242x"
SWEP.Trivia_Class = "Sniper"
SWEP.Trivia_Desc = "Anti-Tank version of NT-242 Family. The NT-242 was a type of sniper rifle. The NT-242 was considered a tank buster by many users and was one of the heaviest longblasters. The NT-242 was powerful at range, and could be modified to have a disruptor shot which could engage vehicles."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/galactic/nt242x.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "02220000000000000"

SWEP.HideViewmodel = false
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/galactic/v_nt242.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dlt19.mdl"
SWEP.ViewModelFOV = 70

SWEP.WorldModelOffset = {
    pos = Vector(-1, 0.6, -3),
    ang = Angle(-5, 0, 180),
    scale = 1,
}

-- Damage & Tracer
SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 115
SWEP.DamageMin = 90
SWEP.RangeMin = 0
SWEP.Range = 1700
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TraceNum = 1
SWEP.Tracer = "tracer_green"
SWEP.TracerCol = Color(0, 250, 0)

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 5

SWEP.Recoil = 3.5
SWEP.RecoilSide = 0.65
SWEP.RecoilRise = 0.85
SWEP.RecoilPunch = 2.5

SWEP.Delay = 60 / 120
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
        PostBurstDelay = 0.1,
    },
	{
		Mode = 0,
   	}
}


SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 250
SWEP.MoveDispersion = 100
SWEP.JumpDispersion = 150

-- Speed Mult
SWEP.SpeedMult = 0.85
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.30

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.FirstShootSound = "ArcCW_Kraken.SW_NT242"
SWEP.ShootSound = "ArcCW_Kraken.SW_NT242"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.MuzzleFlashColor = Color(0, 250, 0)
SWEP.MuzzleEffect = "blaster_muzzle_green"
SWEP.GMMuzzleEffect = false

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-3.48, -0, 0.5),
    Ang = Vector(3, 0.5, -2),
     Magnification = 1.5,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 55,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN

SWEP.ActivePos = Vector(-1, 2, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(4.019, -5.226, -2)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CrouchPos = Vector(-4, 0, -1)
SWEP.CrouchAng = Angle(0, 0, -10)

SWEP.HolsterPos = Vector(3, 3, 0)
SWEP.HolsterAng = Angle(-7.036, 30.016, 0)

SWEP.BarrelOffsetSighted = Vector(0, 0, -1)
SWEP.BarrelOffsetHip = Vector(2, 0, -2)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(20, 30.7, 10.3)

SWEP.GuaranteeLaser = true

-- Attachments
SWEP.DefaultElements = {}
SWEP.AttachmentElements = {
    ["muzzle_attach"] = {
        VMBodygroups = {{ind = 2, bg = 3}},
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Optics", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "tag_attachments",
        Offset = {
            vpos = Vector(8, -0.0, 2.6),
            vang = Angle(0, 0, 0),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0)
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "stealth_muzzle"},
        Bone = "tag_attachments",
        VMScale = Vector(1.3, 1.3, 1.3),
        WMScale = Vector(1.3, 1.3, 1.3),
        InstalledEles = {"muzzle_attach"},
        Offset = {
            vpos = Vector(51, -0.0, 0.45),
            vang = Angle(0, 0, 0),
        },
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(1, 1, 1),
        WMScale = Vector(1, 1, 1),
        Bone = "tag_attachments",
        Offset = {
            vpos = Vector(23, 1, 0.4),
            vang = Angle(0, 0, -90),
        },
    },  
    {
        PrintName = "Underbarrel",
        DefaultAttName = "None",
        Slot = {"foregrip"},
        VMScale = Vector(1.2, 1.2, 1.2),
        WMScale = Vector(1.2, 1.2, 1.2),
        Bone = "tag_attachments",
        InstalledEles = {"grip_attach"},
        Offset = {
            vpos = Vector(20, 0, -0.8),
            vang = Angle(0, 0, 0),
        },
    },  
    {
        PrintName = "Magazine",
        DefaultAttName = "Standard",
        Slot = "bolter_mag",
    },
    {
        PrintName = "Cooling System",
        DefaultAttName = "None",
        Slot = "bolter_cooling",
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.6, 0.6, 0.6),
        WMScale = Vector(0.6, 0.6, 0.6),
        Bone = "tag_attachments",
        Offset = {
            vpos = Vector(4.8, -0.5, -1.1),
            vang = Angle(0, 0, 0),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        Bone = "tag_attachments",
        Offset = {
            vpos = Vector(9, -1, 0.8),
            vang = Angle(0, 0, 30),
        },
    },
}

-- Animations
local path = "arccw/kraken/sw_galactic/handling/nt242/"

SWEP.Animations = {
	["enter_sights"] = {
		Source = "ads_in",
	},
	["exit_sights"] = {
		Source = "ads_out",
	},
    ["fire"] = {
        Source = "shoot1",
        ShellEjectAt = false,
    },
    ["dryfire"] = {
        Source = "dryfire",
		MinProgress = 0.01,
		FireASAP = true,
    },
    ["reload"] = {
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        Source = "reload_short",
        LHIK = true,
		MinProgress = 0.975,
        SoundTable = {
            {s = path .. "wfoly_sn_xmike109_reload_up.ogg", t = 0.0},
            {s = path .. "wfoly_sn_xmike109_reload_magrelease.ogg", t = 0.9},
			{s = path .. "wfoly_sn_xmike109_reload_magout.ogg", t = 1.4},
			{s = path .. "wfoly_sn_xmike109_reload_arm.ogg", t = 2.367},
			{s = path .. "wfoly_sn_xmike109_reload_magin_01.ogg", t = 2.867},
			{s = path .. "wfoly_sn_xmike109_reload_magin_02.ogg", t = 3.1},
			{s = path .. "wfoly_sn_xmike109_reload_end.ogg", t = 3.567},
        },
    },
    ["reload_empty"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
		MinProgress = 0.975,
        SoundTable = {
            {s = path .. "wfoly_sn_xmike109_reload_empty_up.ogg", t = 0.033},
            {s = path .. "wfoly_sn_xmike109_reload_empty_magrelease.ogg", t = 1.05},
			{s = path .. "wfoly_sn_xmike109_reload_empty_magout.ogg", t = 1.45},
			{s = path .. "wfoly_sn_xmike109_reload_empty_arm.ogg", t = 2.2},
			{s = path .. "wfoly_sn_xmike109_reload_empty_magin_01.ogg", t = 2.78},
			{s = path .. "wfoly_sn_xmike109_reload_empty_magin_02.ogg", t = 3.2},
			{s = path .. "wfoly_sn_xmike109_reload_empty_rotate.ogg", t = 3.667},
			{s = path .. "wfoly_sn_xmike109_reload_empty_boltpull.ogg", t = 4.267},
			{s = path .. "wfoly_sn_xmike109_reload_empty_boltrelease.ogg", t = 4.8},
			{s = path .. "wfoly_sn_xmike109_reload_empty_end.ogg", t = 5.1},
        },
    },
    ["ready"] = {
        Source = "draw",
        SoundTable = {
            {s = path .. "wfoly_sn_xmike109_first_raise_up.ogg", t = 0.1},
            {s = path .. "wfoly_sn_xmike109_first_raise_bolt_pull.ogg", t = 0.6},
            {s = path .. "wfoly_sn_xmike109_first_raise_bolt_release.ogg", t = 1.0},
			{s = path .. "wfoly_sn_xmike109_first_raise_end.ogg", t = 36/30},
        },
    },
    ["draw"] = {
        Source = "draw_short",
        MinProgress = 0.3,
        SoundTable = {
            {s = path .. "wfoly_sn_xmike109_first_raise_up.ogg", t = 0/30},
			{s = path .. "wfoly_sn_xmike109_first_raise_end.ogg", t = 10/30},
        },
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {s = path .. "wfoly_sn_xmike109_first_raise_end.ogg", t = 0/30},
        },
    },
    ["idle"] = {
        Source = "idle",
    },
    ["exit_inspect"] = {
        Source = "lookat01",
        LHIK = true,
		MinProgress = 0.9,
        SoundTable = {
            {s = path .. "wfoly_sn_xmike109_inspect_up.ogg", t = 0.1},
			{s = path .. "wfoly_sn_xmike109_inspect_grabrotate.ogg", t = 1.7},
			{s = path .. "wfoly_sn_xmike109_inspect_move.ogg", t = 3.7},
			{s = path .. "wfoly_sn_xmike109_inspect_end.ogg", t = 111/30},
        },
    },
    ["bash"] = {
        Source = {"melee","melee2","melee3"},
        LHIK = true,
    },
    ["enter_bipod"] = {
        Source = "bipod_in",
    },
    ["exit_bipod"] = {
        Source = "bipod_out",
    },
}

SWEP.Hook_BulletHit = function(wep, data)
    local ent = data.tr.Entity
    util.BlastDamage(wep, wep:GetOwner(), data.tr.HitPos, 96, wep:GetDamage(data.range))
    if ent:IsValid() and ent:GetClass() == "npc_helicopter" then
        data.dmgtype = DMG_AIRBOAT
    end
end
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_rt97h.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 4 

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "RT-97h"
SWEP.Trivia_Class = "Heavy Blaster Rifle"
SWEP.Trivia_Desc = "The RT-97C heavy blaster rifle was a model of heavy blaster rifle that saw use during the Galactic Civil War. It was a versatile heavy rifle, fitted with optics that allowed use at long range. Imperial sandtroopers were known to use them, as were jumptroopers."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/galactic/rt97h.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "00010000000000000"

SWEP.HideViewmodel = false
SWEP.MirrorVMWM = true
SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/kraken/galactic/v_rt97c.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dlt19.mdl"
SWEP.ViewModelFOV = 70

SWEP.WorldModelOffset = {
    pos = Vector(-9, 7, 2),
    ang = Angle(-10, 0, 180),
    scale = 1,
}

-- Overheat
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 55
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

-- Damage & Tracer
SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 44
SWEP.DamageMin = 22
SWEP.RangeMin = 0
SWEP.Range = 700
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TraceNum = 1
SWEP.Tracer = "tracer_red"
SWEP.TracerCol = Color(250, 0, 0)

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 76

SWEP.Recoil = 0.86
SWEP.RecoilSide = 0.45
SWEP.RecoilRise = 0.75
SWEP.RecoilPunch = 0.8

SWEP.Delay = 60 / 450
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
        PostBurstDelay = 0.1,
    },
    {
		Mode = 2,
        PostBurstDelay = 0.1,
    },
    {
        Mult_RPM = 2,
		Mode = -3,
        PostBurstDelay = 0.1,
    },
	{
		Mode = 0,
   	}
}

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 300
SWEP.MoveDispersion = 100
SWEP.JumpDispersion = 150

-- Speed Mult
SWEP.SpeedMult = 0.9
SWEP.SightedSpeedMult = 0.75
SWEP.ShootSpeedMult = 1.05

-- Sounds & Muzzleflash
SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 125
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.FirstShootSound = "ArcCW_Kraken.SW_RT97"
SWEP.ShootSound = "ArcCW_Kraken.SW_RT97"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.MuzzleFlashColor = Color(25, 0, 0)
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.GMMuzzleEffect = false

-- Ironsight & Holdtype
SWEP.IronSightStruct = {
    Pos = Vector(-6.133, -10.502, -7.042),
    Ang = Vector(2.184, 0, 0),
     Magnification = 1.5,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 55,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(-1, 0, -8)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, -2, -8)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.CrouchPos = Vector(-4, 0, -11)
SWEP.CrouchAng = Angle(0, 0, -10)

SWEP.HolsterPos = Vector(3, -3, -8)
SWEP.HolsterAng = Angle(-7.036, 30.016, 0)

SWEP.BarrelOffsetSighted = Vector(0, 0, -1)
SWEP.BarrelOffsetHip = Vector(2, 0, -2)

SWEP.CustomizePos = Vector(10, 0, -9)
SWEP.CustomizeAng = Angle(20, 30.7, 10.3)

-- Attachments 
SWEP.DefaultElements = {}
SWEP.Attachments = {     
    {
        PrintName = "Optics", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(1.9, -0, 5.6),
            vang = Angle(0, 0, 0),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0)
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "stealth_muzzle"},
        VMScale = Vector(1.2, 1.2, 1.2),
        WMScale = Vector(1.2, 1.2, 1.2),
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(40, -0.1, 4.8),
            vang = Angle(0, 0, 0),
        },
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(1, 1, 1),
        WMScale = Vector(1, 1, 1),
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(25, 0.4, 4.7),
            vang = Angle(0, 0, -90),
        },
    },  
    {
        PrintName = "Underbarrel",
        DefaultAttName = "None",
        Slot = {"foregrip"},
        VMScale = Vector(1, 1, 1),
        WMScale = Vector(1, 1, 1),
        Bone = "tag_weapon",
        InstalledEles = {"grip_attach"},
        Offset = {
            vpos = Vector(8, 0.1, 3.8),
            vang = Angle(0, 0, 0),
        },
    },  
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.6, 0.6, 0.6),
        WMScale = Vector(0.6, 0.6, 0.6),
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(2, -1.1, 4.75),
            vang = Angle(0, 0, 0),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(-3, -1.1, 4.65),
            vang = Angle(0, 0, 0),
        },
    },
}

-- Don't touch this unless you know what you're doing
local path = "arccw/kraken/sw_galactic/weapons/cr2/handling/"

SWEP.Animations = {
    ["fire"] = {
        Source = "fire",
    },
    ["reload"] = {
        Source = "reload",
        LHIK = true,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
		MinProgress = 0.925,
        Mult = 0.9,
        SoundTable = {
            {s = "arccw/kraken/sw_galactic/weapons/rt97c/handling/raise_start.wav", t = 0.1},
            {s = "arccw/kraken/sw_galactic/weapons/rt97c/handling/empty_charge.wav", t = 1.1},
			{s = "arccw/kraken/sw_galactic/weapons/rt97c/handling/mag_out.wav", t = 3.5},
            {s = "arccw/kraken/sw_galactic/weapons/rt97c/handling/raise_charge.wav", t = 4.5},
			{s = "arccw/kraken/sw_galactic/weapons/rt97c/handling/mag_in.wav", t = 4.5},
        },
    },
    ["reload_empty"] = {
        Source = "reload_empty",
		MinProgress = 0.925,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        SoundTable = {
            {s = "arccw/kraken/sw_galactic/weapons/rt97c/handling/empty_charge.wav", t = 0.1},
            {s = "arccw/kraken/sw_galactic/weapons/rt97c/handling/raise_start.wav", t = 0.5},
            {s = "arccw/kraken/sw_galactic/weapons/rt97c/handling/empty_charge.wav", t = 1.1},
			{s = "arccw/kraken/sw_galactic/weapons/rt97c/handling/mag_out.wav", t = 3.5},
            {s = "arccw/kraken/sw_galactic/weapons/rt97c/handling/raise_charge.wav", t = 4.5},
			{s = "arccw/kraken/sw_galactic/weapons/rt97c/handling/mag_in.wav", t = 4.5},
            {s = "arccw/kraken/sw_galactic/weapons/rt97c/handling/mag_in.wav", t = 7},
        },
    },
    ["ready"] = {
        Source = "pullout_first",
        LHIK = true,
		MinProgress = 0.85,
		FireASAP = true,
        SoundTable = {
            {s = "arccw/kraken/sw_galactic/weapons/rt97c/handling/raise_start.wav", t = 0.0},
            {s = "arccw/kraken/sw_galactic/weapons/rt97c/handling/raise_charge.wav", t = 0.5},
        },
    },
    ["holster"] = {
        Source = "putaway",
        SoundTable = {
            {s = "wfoly_sm_secho_reload_end.ogg", t = 0/30},
        },
    },
    ["draw"] = {
        Source = "pullout",
        SoundTable = {
            {s = "wfoly_sm_secho_reload_end.ogg", t = 0/30},
        },
    },
    ["idle"] = {
        Source = "idle",
    },
    ["fix"] = {
        Source = "pullout_first",
        SoundTable = {
            {s = "arccw/kraken/sw_galactic/weapons/rt97c/handling/raise_start.wav", t = 0.1},
            {s = "arccw/kraken/sw_galactic/weapons/rt97c/handling/raise_charge.wav", t = 0.6},
            {s = "ArcCW_Kraken.Overheat", t = 0.1},
            {s = "ArcCW_Kraken.OverheatFix", t = 0.9},
        },
    },
    ["idle_sprint"] = {
        Source = "base_sprint_loop",
    },
    ["exit_sprint"] = {
        Source = "base_sprint_out",
		Time = 1.25,
    },
    ["enter_sprint"] = {
        Source = "base_sprint_in",
		Time = 1.25,
    },
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_zerzium.lua:
return gluapack()()
--PATH lua/weapons/arccw_rg4d.lua:
return gluapack()()
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_empire_heavyrepeater.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 4

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Special Forces - Empire"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "Imperial Repeater"
SWEP.Trivia_Class = "Blaster Heavy Repeater"
SWEP.Trivia_Desc = "The Heavy Repeater was a projectile weapon used by Imperial troops. It was an improvement over the earlier Imperial repeater rifle, which was developed by Moff Rebus."
SWEP.Trivia_Manufacturer = "Concordian Crescent Technologies"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/sops/heavyrepeater.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "000000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sops/v_imperial_repeater.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dlt19.mdl"

SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(-9, 5, -5.75),
    ang = Angle(-10, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 20
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 34
SWEP.DamageMin = 22
SWEP.RangeMin = 0
SWEP.Range = 200
SWEP.Penetration = 10
SWEP.DamageType = DMG_BLAST
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(250, 0, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "emg_tracer"
SWEP.HullSize = 1

SWEP.NoRandSpread = true
SWEP.CanBash = true

SWEP.InfiniteAmmo = true
SWEP.BottomlessClip = true

SWEP.Recoil = 1.05
SWEP.RecoilSide = 0.45
SWEP.RecoilRise = 0.90
SWEP.MaxRecoilBlowback = 1
SWEP.RecoilPunch = 1
SWEP.RecoilVMShake = 1

SWEP.Delay = 60 / 320
SWEP.Num = 3
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
        Mode = -3,
        PostBurstDelay = 0.1,
        RunawayBurst = false,
        Mult_RPM = 3,
    },
    {
		Mode = 2,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0.5
SWEP.HipDispersion = 100
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "kraken/sops/fc1.wav"
SWEP.ShootSound = "kraken/sops/fc1.wav"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-4.8, -1.859, -0.341),
    Ang = Vector(0, 0, 0),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "ar2"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.SprintPos = Vector(2, -1, 1)
SWEP.SprintAng = Angle(-10, 26, 0)

SWEP.CustomizePos = Vector(10, 0, 2)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, -1)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(-3, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["scope_attach"] = {
        VMBodygroups = {{ind = 1, bg = 1}},
    },
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "dlt34",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(0, -1, 15),
                   ang = Angle(90, 0, 0),
               },
               IsMuzzleDevice = true,
           }
        }, 
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },      
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["idle_iron"] = {
        Source = false,
    },
	["fire"] = {
        Source = {"shoot"},
    },
    ["fire_iron"] = {
        Source = {"shoot"},
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        Mult = 0.3,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatFix", t = 60 / 30},
            {s = "ArcCW_Kraken.Grab", t = 65 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_empire_stw48.lua:
return gluapack()()
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_galactic_m5d.lua:
return gluapack()()
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_galactic_prototypeblaster.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 4

SWEP.Category = "[ArcCW] Kraken's Special Forces - Galactic"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "Prototype Blaster"
SWEP.Trivia_Class = "Blaster SMG"
SWEP.Trivia_Desc = "Prototype Blaster, designed as a Submachine Gun."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/sops/prototypeblaster.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "000000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sops/v_prototype_blaster.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dlt19.mdl"

SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(-11, 5, -1.5),
    ang = Angle(-15, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 40
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 23
SWEP.DamageMin = 20
SWEP.RangeMin = 0
SWEP.Range = 170
SWEP.Penetration = 10
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(2500, 0, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_red"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 70

SWEP.Recoil = 0.35
SWEP.RecoilSide = 0.2
SWEP.RecoilRise = 0.3
SWEP.MaxRecoilBlowback = 1
SWEP.RecoilPunch = 1
SWEP.RecoilVMShake = 1

SWEP.Delay = 60 / 450
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
		Mode = 2,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 300
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "kraken/sops/prototype.wav"
SWEP.ShootSound = "kraken/sops/prototype.wav"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-4.143, -3.718, 1.156),
    Ang = Vector(1.151, 0, 0),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "ar2"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.SprintPos = Vector(2, -1, 0)
SWEP.SprintAng = Angle(-10, 26, 0)

SWEP.CustomizePos = Vector(10, 0, 2)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 0)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(-3, 0, 0.5)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 0)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "dc15s",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(-0.25, 2, 11.1),
                   ang = Angle(90, 0, 0),
               },
               IsMuzzleDevice = true,
           }
        }, 
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Sight", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "dc15s",
        VMScale = Vector(0.9,0.9,0.9),
        WMScale = Vector(0.9,0.9,0.9),
        Offset = {
            vpos = Vector(-0.18, -1.7, 2),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        VMScale = Vector(1.3,1.3,1.3),
        WMScale = Vector(1.3,1.3,1.3),
        Bone = "dc15s",
        Offset = {
            vpos = Vector(-0.25, 0.18, 11.1),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "dc15s",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Offset = {
            vpos = Vector(-0.7, 0, 8),
            vang = Angle(90, 0, 180),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Bone = "dc15s",
        Offset = {
            vpos = Vector(0.65, 0.2, -6.2),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Bone = "dc15s",
        Offset = {
            vpos = Vector(0.8, 0.2, 0),
            vang = Angle(90, 0, -90),
        },
    },   
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["idle_iron"] = {
        Source = false,
    },
	["fire"] = {
        Source = {"shoot"},
    },
    ["fire_iron"] = {
        Source = {"shoot"},
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        Mult = 1.1,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatFix", t = 60 / 30},
            {s = "ArcCW_Kraken.Grab", t = 65 / 30},
        },
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        Mult = 1.4,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 80 / 30},
            {s = "ArcCW_Kraken.Grab", t = 85 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_galactic_r1ca.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 4

SWEP.Category = "[ArcCW] Kraken's Special Forces - Galactic"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "R1-CA"
SWEP.Trivia_Class = "Blaster Repeater"
SWEP.Trivia_Desc = "A blaster repeater which is a compact, rapid-fire weapon with a sleek design, often featuring a barrel that extends forward. It is known for its high rate of fire and is commonly used by soldiers or bounty hunters in battle. This weapon is a powerful, efficient, and ideal for close to medium-range combat."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/sops/r1ca.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "000000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sops/v_renegade_carbine.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dlt19.mdl"

SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(-9, 5, -5.75),
    ang = Angle(-10, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 15
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 47
SWEP.DamageMin = 12
SWEP.RangeMin = 0
SWEP.Range = 200
SWEP.Penetration = 10
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(250, 0, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_red"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 32

SWEP.Recoil = 0.5
SWEP.RecoilSide = 0.45
SWEP.RecoilRise = 0.90
SWEP.MaxRecoilBlowback = 1
SWEP.RecoilPunch = 1
SWEP.RecoilVMShake = 2

SWEP.Delay = 60 / 200
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
        Mode = -3,
        PostBurstDelay = 0.1,
        RunawayBurst = false,
        Mult_RPM = 3,
    },
    {
		Mode = 2,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 250
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0

SWEP.FirstShootSound = "kraken/sops/renegade.wav"
SWEP.ShootSound = "kraken/sops/renegade.wav"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-4.652, -4.439, 2.99),
    Ang = Vector(0, 0.206, 0),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "ar2"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.SprintPos = Vector(2, -1, 3)
SWEP.SprintAng = Angle(-10, 26, 0)

SWEP.CustomizePos = Vector(10, 0, 2)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 3)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(-3, 0, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "dlt34",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(0, -1, 25),
                   ang = Angle(90, 0, 0),
               },
               IsMuzzleDevice = true,
           }
        }, 
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Sight", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "dlt34",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Offset = {
            vpos = Vector(-0.03, -2.61, 10),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        VMScale = Vector(1, 1, 1),
        WMScale = Vector(1, 1, 1),
        Bone = "dlt34",
        Offset = {
            vpos = Vector(-0.01, -1.6, 27.5),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "dlt34",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Offset = {
            vpos = Vector(-1, -1.7, 17),
            vang = Angle(90, 0, 180),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.6, 0.6, 0.6),
        WMScale = Vector(0.6, 0.6, 0.6),
        Bone = "dlt34",
        Offset = {
            vpos = Vector(-0.01, 1.05, 6.86),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Bone = "dlt34",
        Offset = {
            vpos = Vector(0.9, -1.5, 1.4),
            vang = Angle(90, 0, -90),
        },
    },   
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["idle_iron"] = {
        Source = false,
    },
	["fire"] = {
        Source = {"shoot"},
    },
    ["fire_iron"] = {
        Source = {"shoot"},
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        Mult = 0.3,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatFix", t = 60 / 30},
            {s = "ArcCW_Kraken.Grab", t = 65 / 30},
        },
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        Mult = 0.5,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 110 / 30},
            {s = "ArcCW_Kraken.Grab", t = 115 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_galactic_wookieslug.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3

SWEP.Category = "[ArcCW] Kraken's Special Forces - Galactic"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "Wookiee Slug"
SWEP.Trivia_Class = "Slugthrower Scatter"
SWEP.Trivia_Desc = "The Wookiee Slug-Thrower was a slugthrower scatter that was mass-produced by Wookiee workshops across the planet Kashyyyk around the time of the Clone Wars. Slugthrowers were primitive weapons that used an explosive force (from chemicals or compressed gas) to launch a solid projectile, called a slug, at high velocity."
SWEP.Trivia_Manufacturer = "Wookiee Workshops"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/sops/wookieslug.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "000000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sops/v_wookie_slug.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(-11, 5, -1.5),
    ang = Angle(-15, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 25
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 15
SWEP.DamageMin = 12
SWEP.RangeMin = 0
SWEP.Range = 200
SWEP.Penetration = 10
SWEP.DamageType = DMG_BUCKSHOT
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(250, 0, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_red"
SWEP.HullSize = 1

SWEP.NoRandSpread = true
SWEP.CanBash = true

SWEP.ShotgunSpreadPattern = {
    [1] = Angle(0, 0, 0),
    [2] = Angle(0, 1, 0),
    [3] = Angle(0, -1, 0),
    [4] = Angle(2.1, 0, 0),
    [5] = Angle(-2.1, 0, 0),
    [6] = Angle(1.4, 1.2, 0),
    [7] = Angle(-1.4, 1.2, 0),
    [8] = Angle(1.4, -1.2, 0),
    [9] = Angle(-1.4, -1.2, 0),
}

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 5

SWEP.Recoil = 0.98
SWEP.RecoilSide = 0.2
SWEP.RecoilRise = 0.76
SWEP.MaxRecoilBlowback = 1
SWEP.RecoilPunch = 1.1
SWEP.RecoilVMShake = 1.3

SWEP.Delay = 60 / 120
SWEP.Num = 9
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0.5
SWEP.HipDispersion = 250
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "kraken/sops/wookieslug.wav"
SWEP.ShootSound = "kraken/sops/wookieslug.wav"
SWEP.DistantShootSound = "ArcCW_Kraken.StandardCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-4.191, -1.124, -0.1),
    Ang = Vector(0, 0, 0),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "ar2"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.SprintPos = Vector(2, -1, 0)
SWEP.SprintAng = Angle(-10, 26, 0)

SWEP.CustomizePos = Vector(10, 0, 2)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 0)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(-3, 0, -1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 0)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "dc15s",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(-0.25, 2, 14.1),
                   ang = Angle(90, 0, 0),
               },
               IsMuzzleDevice = true,
           }
        }, 
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    }, 
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["idle_iron"] = {
        Source = false,
    },
	["fire"] = {
        Source = {"shoot"},
    },
    ["fire_iron"] = {
        Source = {"shoot"},
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        Mult = 1.1,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatFix", t = 60 / 30},
            {s = "ArcCW_Kraken.Grab", t = 65 / 30},
        },
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        Mult = 1.4,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 80 / 30},
            {s = "ArcCW_Kraken.Grab", t = 85 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_republic_rx21.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Special Forces - Republic"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "RX-21 'Dawnbreaker'"
SWEP.Trivia_Class = "Blaster-Experimental Rifle"
SWEP.Trivia_Desc = "The RX-21 Rifle, also known as RX-21 blaster, was a experimental blaster rifle wielded by the Task-Force 99 Clone Troopers of the Grand Army of the Galactic Republic during the Clone Wars."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/sops/rx21.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "000000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sops/v_rx21.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dlt19.mdl"

SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(-9, 5, -5.75),
    ang = Angle(-10, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 25
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 37
SWEP.DamageMin = 22
SWEP.RangeMin = 0
SWEP.Range = 400
SWEP.Penetration = 10
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(0, 0, 250)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_blue"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 45

SWEP.Recoil = 0.76
SWEP.RecoilSide = 0.55
SWEP.RecoilRise = 0.90
SWEP.MaxRecoilBlowback = 1
SWEP.RecoilPunch = 1.4
SWEP.RecoilVMShake = 1.5

SWEP.Delay = 60 / 400
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
		Mode = 2,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0.5
SWEP.HipDispersion = 250
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "kraken/sops/rx21.wav"
SWEP.ShootSound = "kraken/sops/rx21.wav"
SWEP.DistantShootSound = "ArcCW_Kraken.StandardCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_blue"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 0, 250)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-4.72, -6.048, -0.009),
    Ang = Vector(2.677, -0.1, 1.039),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "ar2"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.SprintPos = Vector(2, -1, 0)
SWEP.SprintAng = Angle(-10, 26, 0)

SWEP.CustomizePos = Vector(10, 0, 2)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 0)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(-3, 0, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["rx21_powerpack"] = {
        VMBodygroups = {{ind = 1, bg = 1}},
    },
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "dlt34",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(0, -2, 21),
                   ang = Angle(90, 0, 0),
               },
               IsMuzzleDevice = true,
           }
        }, 
    },
}


SWEP.Attachments = {     
    {
        PrintName = "Sight", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "dlt34",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Offset = {
            vpos = Vector(-0.13, -4.3, 0.2),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        InstalledEles = {"muzzle_attach"},
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        VMScale = Vector(1.2,1.2,1.2),
        WMScale = Vector(1.2,1.2,1.2),
        Bone = "dlt34",
        Offset = {
            vpos = Vector(-0.01, -2.3, 23.5),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "dlt34",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Offset = {
            vpos = Vector(-0.9, -1.5, 19.5),
            vang = Angle(90, 0, 180),
        },
    },
    {
        PrintName = "Power Pack",
        DefaultAttName = "None",
        Slot = {"rx21_powerpack"},
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Bone = "dlt34",
        Offset = {
            vpos = Vector(1, -1.2, 2),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Bone = "dlt34",
        Offset = {
            vpos = Vector(1.1, -1.4, -2.2),
            vang = Angle(90, 0, -90),
        },
    },   
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["idle_iron"] = {
        Source = false,
    },
	["fire"] = {
        Source = {"shoot"},
    },
    ["fire_iron"] = {
        Source = {"shoot"},
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        Mult = 0.3,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatFix", t = 60 / 30},
            {s = "ArcCW_Kraken.Grab", t = 65 / 30},
        },
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        Mult = 0.5,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 110 / 30},
            {s = "ArcCW_Kraken.Grab", t = 115 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_republic_z6chaingun.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 4

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Special Forces - Republic"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "Z-6 Chaingun"
SWEP.Trivia_Class = "Blaster Heavy Cannon"
SWEP.Trivia_Desc = "The Chaingun is a large shoulder-worn weapon, which is particularly effective, and indeed intended for attacking infantry, especially droids."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/sops/z6chaingun.png"

-- Base
SWEP.MirrorVMWM = true
SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/kraken/sops/v_z6chaingun.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dlt19.mdl"

SWEP.ViewModelFOV = 70

SWEP.HideViewmodel = false
SWEP.WorldModelOffset = {
    pos = Vector(-5, 12, 4),
    ang = Angle(0, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.7,
}

-- Special properties
SWEP.InfiniteAmmo = true -- weapon can reload for free
SWEP.BottomlessClip = true -- weapon never has to reload

SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 95
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatDelayTime = 0.2
SWEP.HeatFix = true 

SWEP.TriggerDelay = true 

-- Damage & Tracer
SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 25
SWEP.DamageMin = 19
SWEP.RangeMin = 0
SWEP.Range = 400
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 1200

SWEP.TracerNum = 1
SWEP.TracerCol = Color(0, 0, 250)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_blue"
SWEP.HullSize = 1

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 200

SWEP.RecoilSide = 0.2
SWEP.RecoilRise = 0.3
SWEP.Recoil = 0.6

SWEP.Delay = 60 / 225
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 2,
    },
    {
		Mode = 1,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0.5
SWEP.HipDispersion = 250
SWEP.MoveDispersion = 350
SWEP.JumpDispersion = 1000

-- Speed Mult
SWEP.SpeedMult = 0.8
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.8

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 120
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "kraken/sops/z6_chain/fire.wav"
SWEP.ShootSound = "kraken/sops/z6_chain/fire.wav"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "kraken/cgi/dc19/dc19.wav"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_blue"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 0, 250)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-1, -3, -12),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 55,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "rpg"
SWEP.HoldtypeSights = "rpg"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, -2, -11)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, 3, -12)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.CustomizePos = Vector(10, 0, -10)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.HolsterPos = Vector(3, 0, -11)
SWEP.HolsterAng = Angle(-7.036, 30.016, 0)

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "weapon",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(9, -34, 0),
                   ang = Angle(0, 90, 0)
               },
               IsMuzzleDevice = true
           }
        }
    }
}

SWEP.Attachments = {
    {
        PrintName = "Energization",
        DefaultAttName = "Standard",
        Slot = {"ammo", "special_ammo"}
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },   
}

SWEP.Animations = {
    ["trigger"] = {
        Source = "idle",
        Mult = 0.1,
        SoundTable = {
            {
                s = "kraken/sops/z6_chain/trigger.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["idle"] = {
        Source = "idle",
    },
    ["fire"] = {
        Source = "fire"
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_rifle.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_rifle.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["fix"] = {
        Source = "overheat",
        LHIK = true,
        Mult = 2,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2, 
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "kraken/sops/z6_chain/reload1.wav", t = 0.5 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 70 / 30},
            {s = "kraken/sops/z6_chain/reload2.wav", t = 74 / 30},
        },
    },
}


-- Special properties
SWEP.Hook_ModifyRPM = function(wep, delay)
    return delay / Lerp(wep:GetBurstCount() / 15, 1, 3)
end
--PATH lua/weapons/awhg_bobs_gun_base/shared.lua:
return gluapack()()
--PATH addons/[technik] darkrp-city-worker/lua/weapons/cityworker_pliers.lua:
return gluapack()()
--PATH lua/weapons/ce_bcr_config.lua:
return gluapack()()
--PATH lua/weapons/gmod_tool/stools/ledscreen.lua:
TOOL.Category		= "Construction"
TOOL.Name			= "LED screens"
TOOL.Command		= nil
TOOL.ConfigName		= ""

local TextBox = {}
local slider = {}
local slider2 = {}
local slider3 = {}
local frame = {}
TOOL.ClientConVar[ "text" ] = ""
TOOL.ClientConVar[ "type" ] = 1
TOOL.ClientConVar[ "speed" ] = 1.5
TOOL.ClientConVar[ "wide" ] = 6
TOOL.ClientConVar[ "fx" ] = 0
TOOL.ClientConVar[ "wire" ] = 0
TOOL.ClientConVar[ "r"] = 255
TOOL.ClientConVar[ "g" ] = 200
TOOL.ClientConVar[ "b" ] = 0

if (SERVER) then
	CreateConVar('sbox_maxledscreens', 5)
end

cleanup.Register("ledscreens")

TOOL.Information = {
	{ name = "left" },
	{ name = "right" }
}

if (CLIENT) then
	language.Add("Tool.ledscreen.name", "LED screen")
	language.Add("Tool.ledscreen.desc", "Create a LED panel")	

	language.Add("Tool.ledscreen.left", "Spawn a LED panel");
	language.Add("Tool.ledscreen.right", "Update LED panel");
	language.Add("Tool.ledscreen.reload", "Copy LED panel's settings");
	
	language.Add("Undone.ledscreens", "Undone ledscreen")
	language.Add("Undone_ledscreens", "Undone ledscreen")
	language.Add("Cleanup.ledscreens", "ledscreens")
	language.Add("Cleanup_ledscreens", "ledscreens")
	language.Add("Cleaned.ledscreens", "Cleaned up all ledscreens")
	language.Add("Cleaned_ledscreens", "Cleaned up all ledscreens")
	
	language.Add("SBoxLimit.ledscreens", "You've hit the ledscreen limit!")
	language.Add("SBoxLimit_ledscreens", "You've hit the ledscreen limit!")
end

local function GetConvars(self)
	local type = tonumber(self:GetClientInfo("type"))
	if !isnumber(type) then type = 1 end
	
	local speed = tonumber(self:GetClientInfo("speed"))
	if !isnumber(speed) then speed = 1.5 end
	
	local wide = tonumber(self:GetClientInfo("wide"))
	if !isnumber(wide) then wide = 6 end
	
	local fx = tonumber(self:GetClientInfo("fx"))
	if !isnumber(fx) then fx = 0 end
	
	local r, g, b = tonumber(self:GetClientInfo("r")), tonumber(self:GetClientInfo("g")), tonumber(self:GetClientInfo("b"))
	if !isnumber(r) or !isnumber(g) or !isnumber(b) then r, g, b = 255, 200, 100 end
	
	return math.Clamp(type, 1, 4), math.Clamp(speed, 1, 10), math.Clamp(wide, 3, 8), math.Clamp(fx, 0, 1), r, g, b
end

function TOOL:LeftClick(tr)
	if (tr.Entity:GetClass() == "player") then return false end
	if (CLIENT) then return true end

	local Ply = self:GetOwner()
	local centerpos = {
		[3] = {18, 0},
		[4] = {11.5, 6},
		[5] = {18, 6},
		[6] = {36, 6},
		[7] = {42, 6},
		[8] = {48, 6},
	}
	
	local type, speed, wide, fx, r, g, b = GetConvars(self)
	
	local angle = tr.HitNormal:Angle()
	local SpawnPos = tr.HitPos + angle:Right() * centerpos[wide][1] - angle:Up() * centerpos[wide][2]
	
	if not (self:GetWeapon():CheckLimit("ledscreens")) then return false end

	local TextScreen
	if tonumber(self:GetClientInfo("wire")) > 0 then
		TextScreen = ents.Create("gb_rp_sign_wire")
	else
		TextScreen = ents.Create("gb_rp_sign")
	end
	TextScreen:SetPos(SpawnPos)
	TextScreen:Spawn()
	
	angle:RotateAroundAxis(tr.HitNormal:Angle():Right(), -90)
	angle:RotateAroundAxis(tr.HitNormal:Angle():Forward(), 90)
	TextScreen:SetAngles(angle)
	TextScreen:SetText(self:GetClientInfo("text"))
	TextScreen:SetType(type)
	TextScreen:SetSpeed(speed)
	TextScreen:SetWide(wide)
	TextScreen:SetModel("models/squad/sf_plates/sf_plate1x"..wide..".mdl")
	TextScreen:SetTColor(Vector(r/100, g/100, b/100))
	TextScreen:SetFX(fx)
	TextScreen:Activate()
	local Phys = TextScreen:GetPhysicsObject()
	Phys:EnableMotion( false )
	
	undo.Create("ledscreens")

	undo.AddEntity(TextScreen)
	undo.SetPlayer(Ply)
	undo.Finish()

	Ply:AddCount("ledscreens", TextScreen)
	Ply:AddCleanup("ledscreens", TextScreen)

	return true
end

function TOOL:RightClick(tr)
	if (tr.Entity:GetClass() == "player") then return false end
	if (CLIENT) then return true end

	local TraceEnt = tr.Entity
	
	local type, speed, wide, fx, r, g, b = GetConvars(self)
	
	if (TraceEnt:IsValid() and TraceEnt:GetClass() == "gb_rp_sign") then
		TraceEnt:SetText(self:GetClientInfo("text"))
		TraceEnt:SetType(type)
		TraceEnt:SetSpeed(speed)
		TraceEnt:SetWide(wide)
		TraceEnt:SetFX(fx)
		TraceEnt:SetModel("models/squad/sf_plates/sf_plate1x"..wide..".mdl")
		TraceEnt:SetTColor(Vector(r/100, g/100, b/100))
		return true
	end
	
	
end

function TOOL:Reload(tr)

	if !IsValid(tr.Entity) then return false end
	local TraceEnt = tr.Entity
	
	if (TraceEnt:IsValid() and TraceEnt:GetClass() == "gb_rp_sign") then
		if CLIENT or game.SinglePlayer() then
			local color = TraceEnt:GetTColor()
			RunConsoleCommand("ledscreen_text", TraceEnt:GetText())
			RunConsoleCommand("ledscreen_type", TraceEnt:GetType())
			RunConsoleCommand("ledscreen_r", color.x*100)
			RunConsoleCommand("ledscreen_g", color.y*100)
			RunConsoleCommand("ledscreen_b", color.z*100)
			RunConsoleCommand("ledscreen_speed", TraceEnt:GetSpeed())
			RunConsoleCommand("ledscreen_wide", TraceEnt:GetWide())
			RunConsoleCommand("ledscreen_fx", TraceEnt:GetFX())
		end
	end


	return true

end


function TOOL.BuildCPanel(CPanel)
	CPanel:AddControl("Header", {	Text = "#Tool.ledscreen.name" } )
	resetall = vgui.Create("DButton", resetbuttons)
	resetall:SetSize(100, 25)	
	resetall:SetText("Reset all")
	resetall.DoClick = function()
		RunConsoleCommand("ledscreen_text", "")
		RunConsoleCommand("ledscreen_type", 1)
		RunConsoleCommand("ledscreen_r", 255)
		RunConsoleCommand("ledscreen_g", 200)
		RunConsoleCommand("ledscreen_b", 0)
		RunConsoleCommand("ledscreen_speed", 1.5)
		RunConsoleCommand("ledscreen_wide", 6)
		RunConsoleCommand("ledscreen_fx", 0)
		RunConsoleCommand("ledscreen_wire", 0)
		slider:SetValue(1)
		slider2:SetValue(1.5)
		slider3:SetValue(6)
		TextBox:SetValue("")

	end
	CPanel:AddItem(resetall)
	local font = "InfoRUS3"
	frame = vgui.Create( "DPanel" )
	frame:SetSize( CPanel:GetWide(), 50 )
	frame.appr = nil
	frame.Paint = function(self,w,h)
		draw.RoundedBox(0,0,0,w,h,Color(0,0,0))
		surface.SetFont(font)
		local alfa
		if GetConVarNumber("ledscreen_fx") > 0 then
			alfa = math.random(100,220)
		else
			alfa = 255
		end
		self.Text = GetConVarString("ledscreen_text")
		self.Type = GetConVarNumber("ledscreen_type")
		self.Speed = GetConVarNumber("ledscreen_speed")
		self.static = false
		local ww,hh = surface.GetTextSize(self.Text)
		local multiplier = self.Speed * 100
		self.Color = Color(GetConVarNumber("ledscreen_r"),GetConVarNumber("ledscreen_g"),GetConVarNumber("ledscreen_b"), alfa)
		if self.Type == 1 then	
		
			local xs = (math.fmod(SysTime() * multiplier,w+ww)) - ww
			draw.DrawText(self.Text,font,xs,0,self.Color,0)
			
		elseif self.Type == 2 then
					
				if !self.appr or self.appr > ww  then
					self.appr = -w
				else
					self.appr = math.Approach(self.appr, ww+w, FrameTime() * multiplier) 
				end
					
				draw.DrawText(self.Text,font,self.appr * -1,0,self.Color,0)
				
		else
				if !self.appr then
					self.appr = 0
				end
					
					if w > ww then
						if self.Type == 3 then
							if self.appr < w-ww and !self.refl then
								self.appr = math.Approach(self.appr, ww+w, FrameTime() * multiplier) 
							else
								if self.appr <= 0 then
									self.refl = nil
								else
									self.refl = true
									self.appr = math.Approach(self.appr, 0, FrameTime() * multiplier) 
								end
							end
						else
							self.static = true
						end
					else
						if self.appr > w-ww-50 and !self.refl then
							self.appr = math.Approach(self.appr, w-ww-50, FrameTime() * multiplier) 
						else
							if self.appr >= 50 then
								self.refl = nil
							else
								self.refl = true
								self.appr = math.Approach(self.appr, 50, FrameTime() * multiplier) 
							end
						end
					end
					if self.static then
						draw.DrawText(self.Text,font,w/2,0,self.Color,1)
					else
						draw.DrawText(self.Text,font,self.appr,0,self.Color,0)
					end
		end
	end
		
	CPanel:AddItem(frame)

		
	slider = vgui.Create("DNumSlider")
	slider:SetText("Type")
	slider:SetMinMax(1, 4)
	slider:SetDecimals(0)
	slider:SetValue(1)
	slider:SetConVar("ledscreen_type")
	CPanel:AddItem(slider)
	
	slider2 = vgui.Create("DNumSlider")
	slider2:SetText("Speed")
	slider2:SetMinMax(1, 10)
	slider2:SetDecimals(1)
	slider2:SetValue(1)
	slider2:SetConVar("ledscreen_speed")
	CPanel:AddItem(slider2)
	
	slider3 = vgui.Create("DNumSlider")
	slider3:SetText("Wide")
	slider3:SetMinMax(3, 8)
	slider3:SetDecimals(0)
	slider3:SetValue(6)
	slider3:SetConVar("ledscreen_wide")
	CPanel:AddItem(slider3)
		
	TextBox = vgui.Create("DTextEntry")
	TextBox:SetUpdateOnType(true)
	TextBox:SetEnterAllowed(true)
	TextBox:SetConVar("ledscreen_text")
	TextBox:SetValue(GetConVarString("ledscreen_text"))
	CPanel:AddItem(TextBox)
	
	CPanel:AddControl( "CheckBox", { Label = "Flicker effect", Description = "", Command = "ledscreen_fx" } )
	CPanel:AddControl( "CheckBox", { Label = "WireMod support", Description = "", Command = "ledscreen_wire" } )
	
	CPanel:AddControl("Color", {
			Label = "LED color",
			Red = "ledscreen_r",
			Green = "ledscreen_g",
			Blue = "ledscreen_b",
			ShowHSV = 1,
			ShowRGB = 1,
			Multiplier = 255
		})
	
	CPanel:AddControl("Label", {	Text = "Gmod-Best.Ru 2013-2019\nWith <3 from Mac" } )
	
end

--PATH gamemodes/sandbox/entities/weapons/gmod_tool/stools/lvshealthshieldeditor.lua:

TOOL.Category		= "LVS"
TOOL.Name			= "#tool.lvshealthshieldeditor.name"
TOOL.Command		= nil
TOOL.ConfigName		= ""

TOOL.ClientConVar[ "maxshield" ] = 0
TOOL.ClientConVar[ "maxhealth" ] = 5000

if CLIENT then
	language.Add( "tool.lvshealthshieldeditor.name", "Max Health & Shield Editor" )
	language.Add( "tool.lvshealthshieldeditor.desc", "A tool used to edit Max Health & Shield on LVS-Vehicles" )
	language.Add( "tool.lvshealthshieldeditor.0", "Left click on a LVS-Vehicle to set Max Health, Right click to set Max Shield, Reload to reset." )
	language.Add( "tool.lvshealthshieldeditor.1", "Left click on a LVS-Vehicle to set Max Health, Right click to set Max Shield, Reload to reset." )
	language.Add( "tool.lvshealthshieldeditor.maxshield", "Max Shield" )
	language.Add( "tool.lvshealthshieldeditor.maxhealth", "Max Health" )
end

function TOOL:LeftClick( trace )
	local ent = trace.Entity

	if not IsValid( ent ) then return false end

	if not ent.LVS and not ent.LFS then return end

	if not ent.OGMaxHealth then
		ent.OGMaxHealth = ent.MaxHealth
	end

	ent.MaxHealth = self:GetClientNumber( "maxhealth" )
	ent:SetHP( ent.MaxHealth )

	return true
end

function TOOL:RightClick( trace )
	local ent = trace.Entity

	if not IsValid( ent ) then return false end

	if not ent.LVS and not ent.LFS then return end

	if not ent.OGMaxShield then
		ent.OGMaxShield = ent.MaxShield
	end

	ent.MaxShield = self:GetClientNumber( "maxshield" )
	ent:SetShield( ent.MaxShield )

	return true
end

function TOOL:Reload( trace )
	local ent = trace.Entity

	if not IsValid( ent ) then return false end

	if not ent.LVS and not ent.LFS then return end

	if ent.OGMaxHealth then
		ent.MaxHealth = ent.OGMaxHealth
	end

	if ent.OGMaxShield then
		ent.MaxShield = ent.OGMaxShield
	end

	ent:SetHP( ent.MaxHealth )
	ent:SetShield( ent.MaxShield )

	return true
end

function TOOL:Think()
	if SERVER then return end

	local ply = LocalPlayer()
	local tr = ply:GetEyeTrace()

	local ent = tr.Entity
	if not IsValid( ent ) then return end

	if not ent.LVS and not ent.LFS then return end

	local Text = "Health: "..tostring( math.Round( ent:GetHP(), 0 ) ).."/"..tostring( ent.MaxHealth )
	if ent:GetShield() > 0 then
		Text = Text.."\nShield: "..tostring( math.Round( ent:GetShield(), 0 ) ).."/"..tostring( ent.MaxShield )
	end

	AddWorldTip( ent:EntIndex(), Text, SysTime() + 0.05, ent:GetPos(), ent )
end

function TOOL.BuildCPanel( panel )
	panel:AddControl( "Header", { Text = "#tool.lvshealthshieldeditor.name", Description = "#tool.lvshealthshieldeditor.desc" } )

	panel:AddControl( "Slider", 
	{
		Label 	= "#tool.lvshealthshieldeditor.maxhealth",
		Type 	= "Int",
		Min 	= "1",
		Max 	= "50000",
		Command = "lvshealthshieldeditor_maxhealth",
		Help = false
	})

	panel:AddControl( "Slider", 
	{
		Label 	= "#tool.lvshealthshieldeditor.maxshield",
		Type 	= "Int",
		Min 	= "0",
		Max 	= "50000",
		Command = "lvshealthshieldeditor_maxshield",
		Help = false
	})

	panel:AddControl( "Label",  { Text = "NOTE: Value in Edit-Properties menu will still be the same, because they can not be updated after the vehicle is spawned!" } )
end

--PATH addons/[ekonomia] pcasino/lua/weapons/gmod_tool/stools/pcasino_creator.lua:
return gluapack()()
--PATH lua/weapons/gmod_tool/stools/republic_conquest.lua:
TOOL.Category = "Stoneman"
TOOL.Name = "Conquest"

if CLIENT then
	language.Add( "tool.republic_conquest.name", "Conquest" )
	language.Add( "tool.republic_conquest.desc", "Creates objectives for players to do!" )
	language.Add( "tool.republic_conquest.0", "Left Click: Creates a configured objecitve. Right Click: Tie to entity. Reload: Remove from entity." )
end

local ConVarsDefault = TOOL:BuildConVarList()

local iconList = {
    { name = "Blank", icon = "republic_conquest/border.png" },
    { name = "Capture", icon = "republic_conquest/capture.png" },
    { name = "Command Post", icon = "republic_conquest/command_post.png" },
    { name = "Destroy", icon = "republic_conquest/destroy.png" },
    { name = "Defend", icon = "republic_conquest/hold.png" },
}

local function ConquestBuildCPanel()
	local CPanel = controlpanel.Get("republic_conquest")
	if not CPanel then return end
	CPanel:ClearControls()

    CPanel:AddControl( "ComboBox", 
	{ 
		MenuButton = 1,
		Folder = "republic_conquest",
		Options = { [ "#preset.default" ] = ConVarsDefault },
		CVars = table.GetKeys( ConVarsDefault ) 
	}
	)

	CPanel:AddControl("Header", 
	{
		Text = "Republic Conquest",
		Description = "Put down control points for players to conquer!"
	}
	)

	CPanel:AddControl( "slider", 
	{ 
		Label = "Radius:",
	 	Command = "republic_conquest_radius",
		min = "1",
		max = "100000"
	}
	)
    CPanel:ControlHelp("Radius of a circle control point.")

    CPanel:ControlHelp("How long does it take to capture?")
	CPanel:AddControl( "slider", 
	{ 
		Label = "Time:",
	 	Command = "republic_conquest_time",
		min = "1",
		max = "100000"
	}
	)
	CPanel:ControlHelp("How long does it take to capture your control point?")

	CPanel:AddControl( "slider", 
	{ 
		Label = "Expectation:",
		Command = "republic_conquest_expectation",
		min = "1",
		max = "1000"
	}
	)
	CPanel:ControlHelp("How many players does it take to get full capture rate?")

	CPanel:AddControl( "textbox", 
	{ 
		Label = "Model:", 
		Command = "republic_conquest_model"
	} 
	)

	CPanel:AddControl( "checkbox", 
	{ 
		Label = "Use proximity hud?", 
		Command = "republic_conquest_useproximity"
	} 
	)
	CPanel:ControlHelp("Show on hud only if you're close?")

	CPanel:AddControl( "slider",
	{
		Label = "Display distance:",
		Command = "republic_conquest_proximity",
		min = "1",
		max = "100000"
	}
	)

	CPanel:AddControl( "checkbox", 
	{ 
		Label = "Show circle?", 
		Command = "republic_conquest_circle"
	} 
	)
	CPanel:ControlHelp("Show the circle of the control point?")

	CPanel:AddControl( "checkbox", 
	{ 
		Label = "Show prop?", 
		Command = "republic_conquest_model_active"
	} 
	)
	CPanel:ControlHelp("Show prop?")

	CPanel:AddControl( "checkbox", 
	{ 
		Label = "Apply to self?", 
		Command = "republic_conquest_selfapply"
	} 
	)
	CPanel:ControlHelp("Changes right click to apply to self.")

	CPanel:AddControl( "checkbox",
	{
		Label = "Use NPC teams?",
		Command = "republic_conquest_npc_team"
	}
	)
	CPanel:ControlHelp("Use npc teams? (Friendly NPCs is on the player's team?)")

	local matselect = CPanel:MatSelect("republic_conquest_icon", nil, true, 0.25, 0.25)
	for k, v in pairs(iconList) do
		matselect:AddMaterial(v.name, v.icon)
	end
end

function TOOL:BuildCPanel(panel)
	ConquestBuildCPanel(panel)
end

if CLIENT then ConquestBuildCPanel() end

TOOL.ClientConVar[ "radius" ] = "100"
TOOL.ClientConVar[ "time" ] = "500"
TOOL.ClientConVar[ "icon" ] = "blank"
TOOL.ClientConVar[ "circle" ] = "1"
TOOL.ClientConVar[ "model_active" ] = "1"
TOOL.ClientConVar[ "expectation" ] = "1"
TOOL.ClientConVar[ "model" ] = "models/props_c17/oildrum001.mdl"
TOOL.ClientConVar[ "selfapply" ] = "0"
TOOL.ClientConVar[ "useproximity" ] = "0"
TOOL.ClientConVar[ "proximity" ] = "500"
TOOL.ClientConVar[ "npc_team" ] = "1"

function TOOL:LeftClick(tr)
	if not IsFirstTimePredicted() then return end
	self:SetupConquest(tr.HitPos)
end

// Tie to an entity.
function TOOL:RightClick(tr)
	if not IsFirstTimePredicted() or CLIENT then return end
	if self:GetClientInfo("selfapply") == "1" then
		self:SetupConquest(tr.HitPos, self:GetOwner()) 
	else
		if not IsValid(tr.Entity) then return end
		self:SetupConquest(tr.HitPos, tr.Entity)
	end
end

function TOOL:Reload(tr)
	if not IsFirstTimePredicted() or CLIENT then return end
	if self:GetClientInfo("selfapply") == "1" then
		self:RemoveConquest(self:GetOwner())
	else
		if not IsValid(tr.Entity) then return end
		self:RemoveConquest(tr.Entity)
	end
end

function TOOL:SetupConquest(pos, entityToTie)
	if CLIENT then return end
	local data = {
		radius = self:GetClientInfo("radius"),
		owner = self:GetOwner(),
		time = self:GetClientInfo("time"),
		icon = self:GetClientInfo("icon"),
		expectation = self:GetClientInfo("expectation"),
		model = self:GetClientInfo("model"),
		circle = self:GetClientInfo("circle"),
		model_active = self:GetClientInfo("model_active"),
		useproximity = self:GetClientInfo("useproximity"),
		proximity = self:GetClientInfo("proximity"),
		npc_team = self:GetClientInfo("npc_team"),
	}

	RepublicConquest:AddPoint(pos, data, entityToTie)
end

function TOOL:RemoveConquest(ent)
	if CLIENT then return end
	if not IsValid(ent) then return end
	RepublicConquest:RemovePoint(ent)
end

if CLIENT then
	hook.Add( "PostDrawTranslucentRenderables", "RepublicConquest_PreviewToolgunner", function()
        if not IsValid(LocalPlayer():GetActiveWeapon()) then return end
        if LocalPlayer():GetActiveWeapon():GetClass() != "gmod_tool" then return end
        if LocalPlayer():GetWeapon("gmod_tool"):GetMode() == nil then return end
        if LocalPlayer():GetWeapon("gmod_tool"):GetMode() != "republic_conquest" then return end

        local tool = LocalPlayer():GetTool()
        local pos = LocalPlayer():GetEyeTrace().HitPos
		local radius = GetConVar("republic_conquest_radius"):GetInt()
		render.SetColorMaterial()
		render.DrawSphere( pos, radius, 30, 30, Color( 0, 175, 175, 100 ) )

		local proximity = GetConVar("republic_conquest_proximity"):GetInt()
		render.DrawWireframeSphere( pos, proximity, 30, 30, Color( 0, 175, 175, 100 ) )
	end )
end
--PATH addons/[misc] smartspawnmanager/lua/weapons/gmod_tool/stools/smart_category_spawn.lua:
//
/*
	Smart Prop Control - Ghost Zone Tool 
	Smart Like My Shoe 
	3/3/2018
*/


TOOL.Category       = "Smart' s Tools";
TOOL.Name           = "#Category Spawns";
TOOL.Command        = nil;
TOOL.ConfigName     = "";
 
TOOL.ClientConVar["auto_uniqueid"]			 	= "0";
TOOL.ClientConVar["category"]			 		= "Default";
TOOL.ClientConVar["uniqueid"]			 		= "Default";

function TOOL:LeftClick(trace)
	
	if (_G.DarkRP) then 
		local autoGenerateUniqueID = self:GetClientInfo("auto_uniqueid");
		local category = self:GetClientInfo("category");
		local uniqueID = self:GetClientInfo("uniqueid");
		
		hook.Call("smartspawn_addplayerspawn", nil, category, uniqueID, trace.HitPos, autoGenerateUniqueID);
	end
	return true;
end

function TOOL:RightClick(trace)
	
	if (_G.DarkRP) then 
		hook.Call("smartspawn_removeplayerspawnbyposition", nil, trace.HitPos);
	end
	return true;
end 

function TOOL:Reload(trace)
	
end

function TOOL:Deploy()
end 

function TOOL:Holster()
end 

function TOOL:Think()

end 

if (CLIENT) then 

	// Top left hud language strings
	language.Add("Tool.smart_category_spawn.name", "Category Spawn Manager");
    language.Add("Tool.smart_category_spawn.desc", "Manage player spawn locations.");
    language.Add("Tool.smart_category_spawn.0", "Primary: Create spawn location | Secondary: Remove spawn location");
	
	// Undo language 
	//language.Add("Undone_smart_npc", "Undone Smart Npc!");
	
	// Derma utility methods 
	local function MakeLabel(text, font)
	
		font = font || "Trebuchet18";
	
		local l = vgui.Create("DLabel");
		l:SetText(text);
		l:SetFont(font);
		l:SetTextColor(Color(0,0,0,255));
		l:SizeToContents();
		
		return l;
	end
	
	// Control panel (derma)
	local function BuildCPanel(panel)
		panel:ClearControls();
		
		if (_G.DarkRP) then 
			panel:AddItem(MakeLabel("Category"));
			
			local categorySelect = vgui.Create("DComboBox");
			local allCats = {};
			for catID, catTable in next, RPExtraTeams do 
				if (catTable.category) then 
					if (allCats[catTable.category] == nil) then 
						allCats[catTable.category] = true;
					end
				end
			end
			for category, bool in next, allCats do 
				categorySelect:AddChoice(category);
			end
			categorySelect.OnSelect = function(s, index, value, data)
		
				RunConsoleCommand("smart_category_spawn_category", value);
			end
			categorySelect:ChooseOptionID(1);
			panel:AddItem(categorySelect);
			
			panel:AddItem(MakeLabel("Unique ID"));
			
			local uniqueID = vgui.Create("DTextEntry");
			uniqueID:SetText("Some Unique Name");
			uniqueID.OnValueChange = function(s, value)
				RunConsoleCommand("smart_category_spawn_uniqueid", value);
			end
			uniqueID:SetUpdateOnType(true);
			
			panel:AddItem(uniqueID);
			
			local autoUniqueID = vgui.Create("DCheckBoxLabel");
			autoUniqueID:SetText("Automatically generate unique ID");
			autoUniqueID:SetTextColor(color_black);
			autoUniqueID:SetConVar("smart_category_spawn_auto_uniqueid");
			panel:AddItem(autoUniqueID);
		end
	end
	
	// Called when player selects this tool for the first time
    function TOOL.BuildCPanel(panel)
		
        BuildCPanel(panel);
    end
	
	local function UpdateCPanel()
		local panel = controlpanel.Get("smart_category_spawn");
        if (!panel) then 
			return;
		end
        BuildCPanel(panel);
    end
    concommand.Add("smart_category_spawn_tool_updatecpanel", UpdateCPanel);
end
--PATH lua/weapons/gmod_tool/stools/streamradio.lua:
return gluapack()()
--PATH lua/weapons/gmod_tool/stools/streamradio.lua:
TOOL.Category = "Stream Radio"
TOOL.Name = "#Tool." .. TOOL.Mode .. ".name"

TOOL.Information = {
	{ name = "left" },
	{ name = "right" },
	{ name = "reload" }
}

if SERVER then
	CreateConVar( "sbox_max" .. TOOL.Mode, 5 )
end

cleanup.Register( TOOL.Mode )

TOOL.ClientConVar["model"] = "models/sligwolf/grocel/radio/radio.mdl"
TOOL.ClientConVar["streamurl"] = ""
TOOL.ClientConVar["play"] = "1"
TOOL.ClientConVar["3dsound"] = "1"
TOOL.ClientConVar["mute"] = "0"
TOOL.ClientConVar["volume"] = "1"
TOOL.ClientConVar["radius"] = "1200"
TOOL.ClientConVar["playbackloopmode"] = "0"

TOOL.ClientConVar["nodisplay"] = "0"
TOOL.ClientConVar["noinput"] = "0"
TOOL.ClientConVar["nospectrum"] = "0"
TOOL.ClientConVar["noadvwire"] = "1"

TOOL.ClientConVar["freeze"] = "1"
TOOL.ClientConVar["weld"] = "1"
TOOL.ClientConVar["worldweld"] = "0"
TOOL.ClientConVar["nocollide"] = "1"

if StreamRadioLib and StreamRadioLib.Loaded then
	TOOL.ClientConVar["model"] = StreamRadioLib.Util.GetDefaultModel()
	TOOL.ClientConVar["playbackloopmode"] = tostring(StreamRadioLib.PLAYBACK_LOOP_MODE_PLAYLIST)

	StreamRadioLib.Tool.AddLocale(TOOL, "name", "Radio Spawner")
	StreamRadioLib.Tool.AddLocale(TOOL, "desc", "Spawns a Stream Radio")

	StreamRadioLib.Tool.AddLocale(TOOL, "left", "Create a stream radio")
	StreamRadioLib.Tool.AddLocale(TOOL, "right", "Copy the settings of a radio")
	StreamRadioLib.Tool.AddLocale(TOOL, "reload", "Copy the model of an entity, but the most models will not have a display")

	StreamRadioLib.Tool.AddLocale(TOOL, "Undone_", "Undone Stream Radio")
	StreamRadioLib.Tool.AddLocale(TOOL, "SBoxLimit_", "You've hit the Stream Radio limit!")
	StreamRadioLib.Tool.AddLocale(TOOL, "Cleanup_", "Stream Radio")
	StreamRadioLib.Tool.AddLocale(TOOL, "Cleaned_", "Cleaned up all Stream Radios")

	StreamRadioLib.Tool.AddLocale(TOOL, "model", "Model:")
	StreamRadioLib.Tool.AddLocale(TOOL, "modelinfo", "Some models (usually speakers) don't have a display. Use this tool or Wiremod to control those.")
	StreamRadioLib.Tool.AddLocale(TOOL, "modelinfo.desc", "Some models (usually speakers) don't have a display.\nUse this tool or Wiremod to control those.")
	StreamRadioLib.Tool.AddLocale(TOOL, "modelinfo_mp", "Some selectable models might not be available on the server. Those will be replaced by a default model.")
	StreamRadioLib.Tool.AddLocale(TOOL, "modelinfo_mp.desc", "Some selectable models might not be available on the server.\nThose will be replaced by a default model.")
	StreamRadioLib.Tool.AddLocale(TOOL, "play", "Start playback")
	StreamRadioLib.Tool.AddLocale(TOOL, "play.desc", "If set, the radio will try to play a given URL on spawn or apply.\nThe URL can be set by this Tools or via Wiremod.")
	StreamRadioLib.Tool.AddLocale(TOOL, "nodisplay", "Disable display")
	StreamRadioLib.Tool.AddLocale(TOOL, "noadvwire", "Disable advanced wire outputs")
	StreamRadioLib.Tool.AddLocale(TOOL, "noadvwire.desc", "Disables the advanced wire outputs.\nIt is always disabled if Wiremod or GM_BASS3 is not installed on the Server.")
	StreamRadioLib.Tool.AddLocale(TOOL, "noinput", "Disable control")
	StreamRadioLib.Tool.AddLocale(TOOL, "noinput.desc", "Disable the control of the display.\nWiremod controlling will still work.")
	StreamRadioLib.Tool.AddLocale(TOOL, "nospectrum", "Disable spectrum visualization")
	StreamRadioLib.Tool.AddLocale(TOOL, "nospectrum.desc", "Disable rendering of the spectrum visualization on the display.")
	StreamRadioLib.Tool.AddLocale(TOOL, "playbackloopmode", "Loop Playback:")
	StreamRadioLib.Tool.AddLocale(TOOL, "playbackloopmode.desc", "Set what happens after a song ends.")
	StreamRadioLib.Tool.AddLocale(TOOL, "playbackloopmode.option.none", "No loop")
	StreamRadioLib.Tool.AddLocale(TOOL, "playbackloopmode.option.song", "Loop song")
	StreamRadioLib.Tool.AddLocale(TOOL, "playbackloopmode.option.playlist", "Loop playlist")
	StreamRadioLib.Tool.AddLocale(TOOL, "3dsound", "Enable 3D Sound")
	StreamRadioLib.Tool.AddLocale(TOOL, "mute", "Mute Radio")
	StreamRadioLib.Tool.AddLocale(TOOL, "volume", "Volume:")
	StreamRadioLib.Tool.AddLocale(TOOL, "radius", "Radius:")
	StreamRadioLib.Tool.AddLocale(TOOL, "radius.desc", "The radius in units the radio sound volume will drop down to 0% of the volume setting.")
	StreamRadioLib.Tool.AddLocale(TOOL, "streamurl", "Stream URL:")
	StreamRadioLib.Tool.AddLocale(TOOL, "freeze", "Freeze")
	StreamRadioLib.Tool.AddLocale(TOOL, "weld", "Weld")
	StreamRadioLib.Tool.AddLocale(TOOL, "worldweld", "Weld to world")
	StreamRadioLib.Tool.AddLocale(TOOL, "nocollide", "Nocollide")
	StreamRadioLib.Tool.AddLocale(TOOL, "spawnsettings", "Spawn settings:")

	StreamRadioLib.Tool.AddLocale(TOOL, "streamurl_info", "What can I put in as Stream URL?")
	StreamRadioLib.Tool.AddLocale(TOOL, "streamurl_info.desc", StreamRadioLib.STREAM_URL_INFO)

	StreamRadioLib.Tool.AddLocale(TOOL, "mute_volume_info", "NOTE: These are entity options too. So they only affect the radio they are applied on. The global settings for your client are at 'General Settings'.")
	StreamRadioLib.Tool.AddLocale(TOOL, "mute_volume_info.desc", "NOTE: These are entity options too. So they only affect the radio they are applied on. The global settings for your client are at 'General Settings'.")

	StreamRadioLib.Tool.AddLocale(TOOL, "streamurl_whitelist_info", "Whitelist protected server:\nOnly approved Stream URLs will work on this server!")

	StreamRadioLib.Tool.Setup(TOOL)
else
	TOOL.Information = nil

	if CLIENT then
		local StreamRadioLib = StreamRadioLib or {}
		local _mode = TOOL.Mode

		language.Add("Tool." .. _mode .. ".name", "Radio Spawner")
		language.Add("Tool." .. _mode .. ".desc", "Spawns a Stream Radio")
		language.Add("Tool." .. _mode .. ".0", "This tool could not be loaded.")

		function TOOL.BuildCPanel(CPanel)
			if StreamRadioLib.Loader_CreateErrorPanel then
				StreamRadioLib.Loader_CreateErrorPanel(CPanel, "This tool could not be loaded.")
			end
		end
	end
end


function TOOL:BuildToolPanel(CPanel)
	CPanel:PropSelect(
		StreamRadioLib.Tool.GetLocale(self, "model"),
		self.Mode .. "_model",
		StreamRadioLib.Model.RegisteredModels(),
		4
	)

	self:AddLabel( CPanel, "modelinfo", true )

	if game.IsDedicated() then
		self:AddLabel( CPanel, "modelinfo_mp", true )
	end

	CPanel:AddPanel(StreamRadioLib.Menu.GetSpacerLine())

	self:AddURLTextEntry( CPanel, "streamurl", false )
	self:AddWhitelistEnabledLabel( CPanel, "streamurl_whitelist_info", false )

	local _, StreamUrlInfoText = self:AddReadOnlyTextBox( CPanel, "streamurl_info" )
	StreamUrlInfoText:SetTall(245)

	CPanel:AddPanel(StreamRadioLib.Menu.GetSpacerLine())

	self:AddCheckbox( CPanel, "play", true )
	self:AddCheckbox( CPanel, "nodisplay", false )
	self:AddCheckbox( CPanel, "noinput", true )
	self:AddCheckbox( CPanel, "nospectrum", true )
	self:AddCheckbox( CPanel, "noadvwire", true )
	self:AddCheckbox( CPanel, "3dsound", false )

	CPanel:AddPanel(StreamRadioLib.Menu.GetSpacer())

	local iconPlaybackloopmodeNone = StreamRadioLib.GetPNGIconPath("arrow_not_refresh", true)
	local iconPlaybackloopmodeSong = StreamRadioLib.GetPNGIconPath("arrow_refresh")
	local iconPlaybackloopmodePlaylist = StreamRadioLib.GetPNGIconPath("table_refresh")

	local PlaybackLoopModeComboBox = self:AddComboBox(CPanel, "playbackloopmode", true)
	PlaybackLoopModeComboBox:SetSortItems(false)
	PlaybackLoopModeComboBox:AddChoice(StreamRadioLib.Tool.GetLocale(self, "playbackloopmode.option.none"), StreamRadioLib.PLAYBACK_LOOP_MODE_NONE, false, iconPlaybackloopmodeNone)
	PlaybackLoopModeComboBox:AddSpacer()
	PlaybackLoopModeComboBox:AddChoice(StreamRadioLib.Tool.GetLocale(self, "playbackloopmode.option.song"), StreamRadioLib.PLAYBACK_LOOP_MODE_SONG, false, iconPlaybackloopmodeSong)
	PlaybackLoopModeComboBox:AddChoice(StreamRadioLib.Tool.GetLocale(self, "playbackloopmode.option.playlist"), StreamRadioLib.PLAYBACK_LOOP_MODE_PLAYLIST, false, iconPlaybackloopmodePlaylist)

	CPanel:AddPanel(StreamRadioLib.Menu.GetSpacerLine())

	self:AddImportantLabel( CPanel, "mute_volume_info", true )

	CPanel:AddPanel(StreamRadioLib.Menu.GetSpacer())

	self:AddCheckbox( CPanel, "mute", false )

	local VolumeNumSlider = self:AddNumSlider( CPanel, "volume", false )
	VolumeNumSlider:SetMin( 0 )
	VolumeNumSlider:SetMax( 1 )
	VolumeNumSlider:SetDecimals( 2 )

	local RadiusNumSlider = self:AddNumSlider( CPanel, "radius", true )
	RadiusNumSlider:SetMin( 0 )
	RadiusNumSlider:SetMax( 5000 )
	RadiusNumSlider:SetDecimals( 0 )

	CPanel:AddPanel(StreamRadioLib.Menu.GetSpacerLine())

	self:AddLabel( CPanel, "spawnsettings", false )
	self:AddCheckbox( CPanel, "freeze", false )

	local WeldCheckbox = self:AddCheckbox( CPanel, "weld", false )
	local WorldWeldCheckbox = self:AddCheckbox( CPanel, "worldweld", false )
	local NoCollideCheckbox = self:AddCheckbox( CPanel, "nocollide", false )

	WeldCheckbox.OnChange = function( self, state )
		local state = ( state and 1 or 0 )

		if ( state == 0 ) then
			WorldWeldCheckbox:SetValue( 0 )
			NoCollideCheckbox:SetValue( 0 )
		end
	end

	WorldWeldCheckbox.OnChange = function( self, state )
		local state = ( state and 1 or 0 )

		if ( state == 1 ) then
			WeldCheckbox:SetValue( 1 )
		end
	end

	NoCollideCheckbox.OnChange = function( self, state )
		local state = ( state and 1 or 0 )

		if ( state == 1 ) then
			WeldCheckbox:SetValue( 1 )
		end
	end

	CPanel:AddPanel(StreamRadioLib.Menu.GetSpacer(5))
	CPanel:AddPanel(StreamRadioLib.Menu.GetOpenSettingsButton())
	CPanel:AddPanel(StreamRadioLib.Menu.GetOpenAdminSettingsButton())
	CPanel:AddPanel(StreamRadioLib.Menu.GetPlaylistEditorButton())
end

local function CalcSpawnAngle( normal, ply_ang, model )
	local Ang = normal:Angle( )
	local normalz = math.Round( normal.z, 4 )
	local IsWall = false
	local modelsettings = StreamRadioLib.Model.GetModelSettings( model ) or {}
	local angoffset = modelsettings.SpawnAng or Angle()
	local spawnFlatOnWall = modelsettings.SpawnFlatOnWall
	Ang.p = ( Ang.p + 90 ) % 360

	if spawnFlatOnWall and normalz == 0 then
		IsWall = true
	end

	if normalz == 1 then
		Ang.y = ( ply_ang.y + 180 ) % 360
		IsWall = false
	elseif normalz == -1 then
		Ang.y = ply_ang.y
		IsWall = false
	end

	if IsWall then
		Ang.p = 0
	end

	Ang:Normalize( )

	local _, Ang = LocalToWorld(Vector(), angoffset, Vector(), Ang)

	Ang:Normalize( )

	return Ang, IsWall
end

local function CalcSpawnPos( ent, IsWall, hitpos, normal, model )
	local modelsettings = StreamRadioLib.Model.GetModelSettings( model ) or {}
	local spawnAtOrigin = modelsettings.SpawnAtOrigin or false

	if spawnAtOrigin then
		return hitpos
	end

	local angoffset = modelsettings.SpawnAng or Angle()

	local min = ent:OBBMins()
	local max = ent:OBBMaxs()

	local rmin, rmax = ent:GetRotatedAABB( min, max )

	min:Rotate(angoffset)
	max:Rotate(angoffset)

	local size = Vector(
		math.abs( max.x - min.x ),
		math.abs( max.y - min.y ),
		math.abs( max.z - min.z )
	)

	local center = ( rmin + rmax ) / 2

	local Pos = hitpos - center
	local edge

	if IsWall then
		edge = size.x / 2
	else
		edge = size.z / 2
	end

	Pos = Pos + edge * normal

	return Pos
end

function TOOL:GetSettings()
	local settings = {}

	settings.StreamMute = self:GetClientBool("mute")
	settings.StreamVolume = self:GetClientNumberMinMax("volume", 0, 1)
	settings.Radius = self:GetClientNumberMinMax("radius", 0, 5000)
	settings.PlaybackLoopMode = self:GetClientNumber("playbackloopmode", StreamRadioLib.PLAYBACK_LOOP_MODE_NONE)
	settings.Sound3D = self:GetClientBool("3dsound")
	settings.DisableDisplay = self:GetClientBool("nodisplay")
	settings.DisableInput = self:GetClientBool("noinput")
	settings.DisableSpectrum = self:GetClientBool("nospectrum")
	settings.DisableAdvancedOutputs = self:GetClientBool("noadvwire")

	return settings
end

function TOOL:SetSettings(settings)
	local url = settings.StreamUrl or ""

	url = StreamRadioLib.Url.SanitizeUrl(url)

	self:SetClientInfo("streamurl", url)

	self:SetClientBool("mute", settings.StreamMute)
	self:SetClientNumber("volume", settings.StreamVolume or 1)
	self:SetClientNumber("radius", settings.Radius or 1200)
	self:SetClientNumber("playbackloopmode", settings.PlaybackLoopMode or StreamRadioLib.PLAYBACK_LOOP_MODE_NONE)
	self:SetClientBool("3dsound", settings.Sound3D)
	self:SetClientBool("nodisplay", settings.DisableDisplay)
	self:SetClientBool("noinput", settings.DisableInput)
	self:SetClientBool("nospectrum", settings.DisableSpectrum)
	self:SetClientBool("noadvwire", settings.DisableAdvancedOutputs)
end

local _TOOL_Class = TOOL.Mode
local function MakeStreamRadio(ply, Pos, Ang, model, nocollide, Settings)
	if not SERVER then return end
	if IsValid(ply) and not ply:CheckLimit(_TOOL_Class) then return end
	Settings = Settings or {}

	if not StreamRadioLib then return end
	if not StreamRadioLib.SpawnRadio then return end

	local ent = StreamRadioLib.SpawnRadio(ply, model, Pos, Ang, Settings)
	if not IsValid(ent) then return end

	local phys = ent:GetPhysicsObject( )

	if IsValid(phys) then
		phys:EnableCollisions( not nocollide )
	end

	ent.Settings = Settings
	ent.nocollide = nocollide

	if IsValid(ply) then
		ply:AddCount(_TOOL_Class, ent)
		ply:AddCleanup(_TOOL_Class, ent)
	end

	return ent
end

if SERVER then
	duplicator.RegisterEntityClass("sent_" .. TOOL.Mode, MakeStreamRadio, "Pos", "Ang", "Model", "nocollide", "Settings")
end

function TOOL:LeftClick(trace)
	if not self.ToolLibLoaded then return false end
	if not self:IsValidTrace(trace) then return false end

	local ent = trace.Entity
	local ply = self:GetOwner()

	if CLIENT then return true end

	local settings = self:GetSettings()

	if self:IsValidRadio(ent) then
		if not StreamRadioLib.EditRadio(ent, settings) then return false end

		ent:SetToolURL(self:GetClientInfo("streamurl"), self:GetClientBool("play"))
		return true
	end

	if not self:GetSWEP():CheckLimit(self.Mode) then
		return false
	end

	local model = self:GetModel()
	local ang, IsWall = CalcSpawnAngle(trace.HitNormal, ply:GetAngles(), model)

	local nocollide = self:GetClientBool("nocollide")
	local weld = self:GetClientBool("weld")
	local worldweld = self:GetClientBool("worldweld")
	local freeze = self:GetClientBool("freeze")

	nocollide = nocollide and ((weld and IsValid(trace.Entity)) or worldweld)

	local ent = MakeStreamRadio(ply, trace.HitPos, ang, model, nocollide, settings)
	if not IsValid(ent) then return false end

	local pos = CalcSpawnPos(ent, IsWall, trace.HitPos, trace.HitNormal, model)
	ent:SetPos(pos)

	ent:SetToolURL(self:GetClientInfo("streamurl"), self:GetClientBool("play"))

	local const = nil

	if weld or worldweld then
		const = StreamRadioLib.Tool.AdvWeld( ent, trace.Entity, trace.PhysicsBone, true, not nocollide, worldweld, freeze )
	else
		local phys = ent:GetPhysicsObject()

		if IsValid(phys) then
			phys:EnableMotion(not freeze)
		end
	end

	if IsValid(ply) then
		undo.Create(self.Mode)
		undo.AddEntity(ent)

		if IsValid(const) then
			undo.AddEntity(const)
		end

		undo.SetPlayer(ply)
		undo.Finish()
	end

	return true
end

function TOOL:RightClick( trace )
	if not self.ToolLibLoaded then return false end
	if not self:IsValidTrace(trace) then return false end

	local ent = trace.Entity
	if not self:IsValidRadio(ent) then return false end

	if CLIENT then return true end

	self:SetSettings(ent:GetSettings())
	return true
end

function TOOL:Reload( trace )
	if not self.ToolLibLoaded then return false end
	if not self:IsValidTrace(trace) then return false end

	local ent = trace.Entity

	if not IsValid(ent) then return false end
	if ent:IsPlayer() then return false end
	if ent:IsNPC() then return false end
	if ent:GetPhysicsObjectCount() > 1 then return false end -- No ragdolls!

	local model = ent:GetModel()
	if not StreamRadioLib.Util.IsValidModel(model) then return false end

	if CLIENT then return true end

	self:SetClientInfo("model", model)
	return true
end

function TOOL:UpdateGhostStreamRadio( ent, ply, model )
	if not IsValid( ent ) then return end
	if not IsValid( ply ) then return end

	if not self.ToolLibLoaded then return end

	local trace = self:GetFallbackTrace()
	if not trace then return end
	local hitent = trace.Entity

	if self:IsValidRadio(hitent) then
		ent:SetNoDraw(true)
		return
	end

	ent:SetNoDraw(false)

	local Ang, IsWall = CalcSpawnAngle(trace.HitNormal, ply:GetAngles(), model)
	ent:SetAngles(Ang)

	local Pos = CalcSpawnPos(ent, IsWall, trace.HitPos, trace.HitNormal, model)
	ent:SetPos(Pos)
end

function TOOL:Think( )
	if not self.ToolLibLoaded then return end
	local model = self:GetModel()

	if not IsValid(self.GhostEntity) then
		self:MakeGhostEntity(
			Model(model),
			vector_origin,
			angle_zero
		)
	end

	if not IsValid(self.GhostEntity) then
		return
	end

	if self.GhostEntity:GetModel() ~= model then
		self.GhostEntity:SetModel(model)
		self.GhostEntity:DrawShadow(false)
	end

	self:UpdateGhostStreamRadio(self.GhostEntity, self:GetOwner(), model)
end

function TOOL:GetModel( )
	local model = self:GetClientInfo("model")

	if not StreamRadioLib.Util.IsValidModel(model) then
		return StreamRadioLib.Util.GetDefaultModel()
	end

	return model
end

function TOOL:Holster()
	if not self.ToolLibLoaded then return end
	self:ReleaseGhostEntity()
end

function TOOL:Deploy()
end

--PATH lua/weapons/gmod_tool/stools/textscreen.lua:
TOOL.Category = "Construction"
TOOL.Name = "#tool.textscreen.name"
TOOL.Command = nil
TOOL.ConfigName = ""
local textBox = {}
local lineLabels = {}
local labels = {}
local sliders = {}
local rainbowCheckboxes = {}
local textscreenFonts = textscreenFonts
local rainbow_enabled = cvars.Number("ss_enable_rainbow", 1)
local max_characters = cvars.Number("ss_max_characters", 0)

for i = 1, 5 do
	TOOL.ClientConVar["text" .. i] = ""
	TOOL.ClientConVar["size" .. i] = 20
	TOOL.ClientConVar["r" .. i] = 255
	TOOL.ClientConVar["g" .. i] = 255
	TOOL.ClientConVar["b" .. i] = 255
	TOOL.ClientConVar["a" .. i] = 255
	TOOL.ClientConVar["font" .. i] = 1
	TOOL.ClientConVar["rainbow" .. i] = 0
end

cleanup.Register("textscreens")

if (CLIENT) then
	TOOL.Information = {
		{ name = "left" },
		{ name = "right" },
		{ name = "reload" },
	}
	-- Add default english language strings here, in case no localisation exists
	language.Add("tool.textscreen.name", "3D2D Textscreen")
	language.Add("tool.textscreen.desc", "Create a textscreen with multiple lines, font colours and sizes.")
	language.Add("tool.textscreen.left", "Spawn a textscreen.") -- Does not work with capital T in tool. Same with right and reload.
	language.Add("tool.textscreen.right", "Update textscreen with settings.")
	language.Add("tool.textscreen.reload", "Copy textscreen.")
	language.Add("Undone.textscreens", "Undone textscreen")
	language.Add("Undone_textscreens", "Undone textscreen")
	language.Add("Cleanup.textscreens", "Textscreens")
	language.Add("Cleanup_textscreens", "Textscreens")
	language.Add("Cleaned.textscreens", "Cleaned up all textscreens")
	language.Add("Cleaned_textscreens", "Cleaned up all textscreens")
	language.Add("SBoxLimit.textscreens", "You've hit the textscreen limit!")
	language.Add("SBoxLimit_textscreens", "You've hit the textscreen limit!")
end

function TOOL:LeftClick(tr)
	if (tr.Entity:GetClass() == "player") then return false end
	if (CLIENT) then return true end
	local ply = self:GetOwner()

	if hook.Run("PlayerSpawnTextscreen", ply, tr) == false then return false end

	if not (self:GetWeapon():CheckLimit("textscreens")) then return false end
	-- ensure at least 1 line of the textscreen has text before creating entity
	local hasText = false
	for i = 1, 5 do
		local text = self:GetClientInfo("text" .. i) or ""
		if text ~= "" then
			hasText = true
		end
	end
	if not hasText then return false end
	local textScreen = ents.Create("sammyservers_textscreen")
	textScreen:SetPos(tr.HitPos)
	local angle = tr.HitNormal:Angle()
	angle:RotateAroundAxis(tr.HitNormal:Angle():Right(), -90)
	angle:RotateAroundAxis(tr.HitNormal:Angle():Forward(), 90)
	textScreen:SetAngles(angle)
	textScreen:Spawn()
	textScreen:Activate()

	undo.Create("textscreens")
	undo.AddEntity(textScreen)
	undo.SetPlayer(ply)
	undo.Finish()
	ply:AddCount("textscreens", textScreen)
	ply:AddCleanup("textscreens", textScreen)

	for i = 1, 5 do
		local txt = self:GetClientInfo("text" .. i) or ""
		textScreen:SetLine(
			i, -- Line
			max_characters ~= 0 and string.Left(txt, max_characters) or txt, -- text
			Color( -- Color
				tonumber(self:GetClientInfo("r" .. i)) or 255,
				tonumber(self:GetClientInfo("g" .. i)) or 255,
				tonumber(self:GetClientInfo("b" .. i)) or 255,
				tonumber(self:GetClientInfo("a" .. i)) or 255
			),
			tonumber(self:GetClientInfo("size" .. i)) or 20,
			-- font
			tonumber(self:GetClientInfo("font" .. i)) or 1,

			rainbow_enabled == 1 and tonumber(self:GetClientInfo("rainbow" .. i)) or 0
		)
	end

	return true
end

function TOOL:RightClick(tr)
	if (tr.Entity:GetClass() == "player") then return false end
	if (CLIENT) then return true end
	local traceEnt = tr.Entity

	if (IsValid(traceEnt) and traceEnt:GetClass() == "sammyservers_textscreen") then
		for i = 1, 5 do
			local txt = tostring(self:GetClientInfo("text" .. i))
			traceEnt:SetLine(
				i, -- Line
				max_characters ~= 0 and string.Left(txt, max_characters) or txt, -- text
				Color( -- Color
					tonumber(self:GetClientInfo("r" .. i)) or 255,
					tonumber(self:GetClientInfo("g" .. i)) or 255,
					tonumber(self:GetClientInfo("b" .. i)) or 255,
					tonumber(self:GetClientInfo("a" .. i)) or 255
				),
				tonumber(self:GetClientInfo("size" .. i)) or 20,
				-- font
				tonumber(self:GetClientInfo("font" .. i)) or 1,

				rainbow_enabled and tonumber(self:GetClientInfo("rainbow" .. i)) or 0
			)
		end

		traceEnt:Broadcast()

		return true
	end
end

function TOOL:Reload(tr)
	if (SERVER) then return true end
	local traceEnt = tr.Entity
	if (not isentity(traceEnt) or traceEnt:GetClass() ~= "sammyservers_textscreen") then return false end

	for i = 1, 5 do
		local linedata = traceEnt.lines[i]
		RunConsoleCommand("textscreen_r" .. i, linedata.color.r)
		RunConsoleCommand("textscreen_g" .. i, linedata.color.g)
		RunConsoleCommand("textscreen_b" .. i, linedata.color.b)
		RunConsoleCommand("textscreen_a" .. i, linedata.color.a)
		RunConsoleCommand("textscreen_size" .. i, linedata.size)
		RunConsoleCommand("textscreen_text" .. i, linedata.text)
		RunConsoleCommand("textscreen_font" .. i, linedata.font)
		RunConsoleCommand("textscreen_rainbow" .. i, linedata.rainbow)
	end

	return true
end

local conVarsDefault = TOOL:BuildConVarList()

function TOOL.BuildCPanel(CPanel)
	local logo = vgui.Create("DImage", CPanel)
	logo:SetSize(267, 134)
	logo:SetImage("textscreens/logo.png")
	CPanel:AddItem(logo)

	CPanel:AddControl("Header", {
		Text = "#tool.textscreen.name",
		Description = "#tool.textscreen.desc"
	})

	local function TrimFontName(fontnum)
		return string.Left(textscreenFonts[fontnum], 8) == "Screens_" and string.TrimLeft(textscreenFonts[fontnum], "Screens_") or textscreenFonts[fontnum]
	end

	local changefont
	local fontnum = textscreenFonts[GetConVar("textscreen_font1"):GetInt()] ~= nil and GetConVar("textscreen_font1"):GetInt() or 1

	cvars.AddChangeCallback("textscreen_font1", function(convar_name, value_old, value_new)
		fontnum = textscreenFonts[tonumber(value_new)] ~= nil and tonumber(value_new) or 1
		local font = TrimFontName(fontnum)
		changefont:SetText("Change font (" .. font .. ")")
	end)

	local function ResetFont(lines, text)
		if #lines >= 5 then
			fontnum = 1
			for i = 1, 5 do
				RunConsoleCommand("textscreen_font" .. i, 1)
			end
		end
		for k, i in pairs(lines) do
			if text then
				RunConsoleCommand("textscreen_text" .. i, "")
				labels[i]:SetText("")
			end
			labels[i]:SetFont(textscreenFonts[fontnum] .. "_MENU")
		end
	end

	resetall = vgui.Create("DButton", resetbuttons)
	resetall:SetSize(100, 25)
	resetall:SetText("Reset all")

	resetall.DoClick = function()
		local menu = DermaMenu()

		menu:AddOption("Reset colors", function()
			for i = 1, 5 do
				RunConsoleCommand("textscreen_r" .. i, 255)
				RunConsoleCommand("textscreen_g" .. i, 255)
				RunConsoleCommand("textscreen_b" .. i, 255)
				RunConsoleCommand("textscreen_a" .. i, 255)
			end
		end)

		menu:AddOption("Reset sizes", function()
			for i = 1, 5 do
				RunConsoleCommand("textscreen_size" .. i, 20)
				sliders[i]:SetValue(20)
				labels[i]:SetFont(textscreenFonts[fontnum] .. "_MENU")
			end
		end)

		menu:AddOption("Reset textboxes", function()
			for i = 1, 5 do
				RunConsoleCommand("textscreen_text" .. i, "")
				textBox[i]:SetValue("")
			end
		end)

		menu:AddOption("Reset fonts", function()
			ResetFont({1, 2, 3, 4, 5}, false)
		end)

		if rainbow_enabled == 1 then
			menu:AddOption("Reset rainbow", function()
				for i = 1, 5 do
					rainbowCheckboxes[i]:SetValue(0)
				end
			end)
		end

		menu:AddOption("Reset everything", function()
			for i = 1, 5 do
				RunConsoleCommand("textscreen_r" .. i, 255)
				RunConsoleCommand("textscreen_g" .. i, 255)
				RunConsoleCommand("textscreen_b" .. i, 255)
				RunConsoleCommand("textscreen_a" .. i, 255)
				RunConsoleCommand("textscreen_size" .. i, 20)
				sliders[i]:SetValue(20)
				RunConsoleCommand("textscreen_text" .. i, "")
				RunConsoleCommand("textscreen_font" .. i, 1)
				textBox[i]:SetValue("")
				if rainbow_enabled == 1 then
					rainbowCheckboxes[i]:SetValue(0)
				end
			end
			ResetFont({1, 2, 3, 4, 5}, true)
		end)

		menu:Open()
	end

	CPanel:AddItem(resetall)
	resetline = vgui.Create("DButton")
	resetline:SetSize(100, 25)
	resetline:SetText("Reset line")

	resetline.DoClick = function()
		local menu = DermaMenu()

		for i = 1, 5 do
			menu:AddOption("Reset line " .. i, function()
				RunConsoleCommand("textscreen_r" .. i, 255)
				RunConsoleCommand("textscreen_g" .. i, 255)
				RunConsoleCommand("textscreen_b" .. i, 255)
				RunConsoleCommand("textscreen_a" .. i, 255)
				RunConsoleCommand("textscreen_size" .. i, 20)
				sliders[i]:SetValue(20)
				RunConsoleCommand("textscreen_text" .. i, "")
				textBox[i]:SetValue("")
				ResetFont({i}, true)
			end)
		end

		menu:AddOption("Reset all lines", function()
			for i = 1, 5 do
				RunConsoleCommand("textscreen_r" .. i, 255)
				RunConsoleCommand("textscreen_g" .. i, 255)
				RunConsoleCommand("textscreen_b" .. i, 255)
				RunConsoleCommand("textscreen_a" .. i, 255)
				RunConsoleCommand("textscreen_size" .. i, 20)
				sliders[i]:SetValue(20)
				RunConsoleCommand("textscreen_text" .. i, "")
				RunConsoleCommand("textscreen_font" .. i, 1)
				textBox[i]:SetValue("")
			end
			ResetFont({1, 2, 3, 4, 5}, true)
		end)

		menu:Open()
	end

	CPanel:AddItem(resetline)

	-- Change font
	changefont = vgui.Create("DButton")
	changefont:SetSize(100, 25)
	changefont:SetText("Change font (" .. TrimFontName(fontnum) .. ")" )

	changefont.DoClick = function()
		local menu = DermaMenu()

		for i = 1, #textscreenFonts do
			local font = TrimFontName(i)
			menu:AddOption(font, function()
				fontnum = i
				for o = 1, 5 do
					RunConsoleCommand("textscreen_font" .. o, i)
					labels[o]:SetFont(textscreenFonts[fontnum] .. "_MENU")
				end
				changefont:SetText("Change font (" .. font .. ")")
			end)
		end

		menu:Open()
	end

	CPanel:AddItem(changefont)

	CPanel:AddControl("ComboBox", {
		MenuButton = 1,
		Folder = "textscreen",
		Options = {
			["#preset.default"] = conVarsDefault
		},
		CVars = table.GetKeys(conVarsDefault)
	})

	for i = 1, 5 do
		lineLabels[i] = CPanel:AddControl("Label", {
			Text = "Line " .. i,
			Description = "Line " .. i
		})

		lineLabels[i]:SetFont("Default")

		CPanel:AddControl("Color", {
			Label = "Line " .. i .. " font color",
			Red = "textscreen_r" .. i,
			Green = "textscreen_g" .. i,
			Blue = "textscreen_b" .. i,
			Alpha = "textscreen_a" .. i,
			ShowHSV = 1,
			ShowRGB = 1,
			Multiplier = 255
		})

		if rainbow_enabled == 1 then
			rainbowCheckboxes[i] = vgui.Create("DCheckBoxLabel")
			rainbowCheckboxes[i]:SetText("Rainbow Text")
			rainbowCheckboxes[i]:SetTextColor(Color(0,0,0,255))
			rainbowCheckboxes[i]:SetConVar("textscreen_rainbow" .. i)
			rainbowCheckboxes[i]:SetTooltip("Enable for rainbow text")
			rainbowCheckboxes[i]:SetValue(GetConVar("textscreen_rainbow" .. i):GetInt())
			CPanel:AddItem(rainbowCheckboxes[i])
		end

		sliders[i] = vgui.Create("DNumSlider")
		sliders[i]:SetText("Font size")
		sliders[i]:SetMinMax(20, 100)
		sliders[i]:SetDecimals(0)
		sliders[i]:SetValue(GetConVar("textscreen_size" .. i))
		sliders[i]:SetConVar("textscreen_size" .. i)

		CPanel:AddItem(sliders[i])
		textBox[i] = vgui.Create("DTextEntry")
		textBox[i]:SetUpdateOnType(true)
		textBox[i]:SetEnterAllowed(true)
		textBox[i]:SetConVar("textscreen_text" .. i)
		textBox[i]:SetValue(GetConVar("textscreen_text" .. i):GetString())

		textBox[i].OnTextChanged = function()
			labels[i]:SetText(textBox[i]:GetValue())
		end

		if max_characters ~= 0 then
			textBox[i].AllowInput = function()
				if string.len(textBox[i]:GetValue()) >= max_characters then return true end
			end
		end

		CPanel:AddItem(textBox[i])

		labels[i] = CPanel:AddControl("Label", {
			Text = #GetConVar("textscreen_text" .. i):GetString() >= 1 and GetConVar("textscreen_text" .. i):GetString() or "Line " .. i,
			Description = "Line " .. i
		})

		labels[i]:SetFont(textscreenFonts[fontnum] .. "_MENU")
		labels[i]:SetAutoStretchVertical(true)
		labels[i]:SetDisabled(true)
		labels[i]:SetHeight(50)

		labels[i].Think = function()
			labels[i]:SetColor(
				Color(
					GetConVar("textscreen_r" .. i):GetInt(),
					GetConVar("textscreen_g" .. i):GetInt(),
					GetConVar("textscreen_b" .. i):GetInt(),
					GetConVar("textscreen_a" .. i):GetInt()
				)
			)
		end
	end
end

--PATH lua/weapons/gmod_tool/stools/vjstool_bullseye.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/entities/weapons/lockpick/shared.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/entities/weapons/ls_sniper/shared.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/weapons/masita_dc15a_stun.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/weapons/masita_dc15le.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/weapons/masita_dual_dc17ext.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/weapons/masita_westarm5.lua:
return gluapack()()
--PATH lua/weapons/mortar_constructor_dark/shared.lua:
AddCSLuaFile()

SWEP.Base = "mortar_constructor"
SWEP.PrintName = "Mortar Dark"
SWEP.Spawnable = true

SWEP.Author = "DolUnity"
SWEP.Purpose = "Place a Mortar"
SWEP.Instructions = "Place the mortar with attack \nPick it up with duck and use"
SWEP.Category = "DolUnity"
SWEP.Spawnable = true
SWEP.ViewModel = "models/weapons/c_pistol.mdl"
SWEP.UseHands = true
SWEP.DrawAmmo = false

function SWEP:OnSpawn(ent)
    ent:SetSkin(1)
end
--PATH lua/weapons/rw_ammo_distributor.lua:
SWEP.Gun							= ("gun_base")
if (GetConVar(SWEP.Gun.."_allowed")) != nil then
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "tfa_blacklisted" SWEP.PrintName = SWEP.Gun return end
end

SWEP.Base							= "tfa_gun_base"
SWEP.Category						= "TFA StarWars Reworked Other"
SWEP.Manufacturer 					= ""
SWEP.Author							= "ChanceSphere574"


SWEP.PrintName						= "Ammo Crate"
SWEP.Type							= "This is a WIP swep, so you can throw 5 (default) crate of 750 (default) ammo and the swep will be deleted"
SWEP.Slot							= 0
SWEP.SlotPos						= 0

SWEP.VElements = {
	["carte"] = { 
		type = "Model", 
		model = "models/cs574/objects/ammo_box.mdl", 
		bone = "v_scoutblaster_reference001", 
		rel = "", 
		pos = Vector(0, 0, -15), 
		angle = Angle(0, 90, 0), 
		size = Vector(1, 1, 1), 
		color = Color(255, 255, 255, 255), 
		surpresslightning = false, 
		material = "", 
		skin = 0, 
		bodygroup = {}
	},
}

SWEP.WElements = {
	["carte"] = { 
		type = "Model",
		model = "models/cs574/objects/ammo_box.mdl", 
		bone = "ValveBiped.Bip01_R_Hand", 
		rel = "", 
		pos = Vector(-02, 10.5, -06), 
		angle = Angle(0, -05, 06), 
		size = Vector(1.15, 1.15, 1.15), 
		color = Color(255, 255, 255, 255), 
		surpresslightning = false, 
		material = "", 
		skin = 0, 
		bodygroup = {} }
}

function SWEP:Think()
	if (self:Clip1() <= 0) then
		if IsValid(self) and self:OwnerIsValid() and SERVER then
			self:GetOwner():StripWeapon(self:GetClass())
		end
	end
end

SWEP.DrawAmmo						= true
SWEP.data 							= {}
SWEP.data.ironsights				= 0
SWEP.Secondary.IronFOV				= 75
SWEP.FiresUnderwater 				= true
SWEP.Contact						= ""
SWEP.Spawnable						= true
SWEP.AdminSpawnable					= true
SWEP.DrawCrosshair					= false
SWEP.DrawCrosshairIS 				= false
SWEP.IronInSound 					= nil
SWEP.IronOutSound 					= nil
SWEP.CanBeSilenced					= false
SWEP.Silenced 						= false
SWEP.DoMuzzleFlash 					= false
SWEP.SelectiveFire					= false
SWEP.DisableBurstFire				= false
SWEP.OnlyBurstFire					= false
SWEP.DefaultFireMode 				= nil
SWEP.FireModeName 					= nil
SWEP.DisableChambering 				= true

SWEP.Primary.ClipSize				= GetConVar("rw_sw_dispenser_ammo_crate_number"):GetInt()
SWEP.Primary.DefaultClip			= GetConVar("rw_sw_dispenser_ammo_crate_number"):GetInt()
SWEP.Primary.RPM					= 200
SWEP.Primary.RPM_Burst				= 0
SWEP.Primary.Ammo					= "crate"
SWEP.Primary.AmmoConsumption 		= 1
SWEP.Primary.Range 					= 0
SWEP.Primary.RangeFalloff 			= 0
SWEP.Primary.NumShots				= 1
SWEP.Primary.Automatic				= false
SWEP.Primary.RPM_Semi				= 0
SWEP.Primary.BurstDelay				= 0
SWEP.Primary.Sound 					= nil
SWEP.Primary.ReloadSound 			= nil
SWEP.Primary.PenetrationMultiplier 	= 0
SWEP.Primary.Damage					= 0
SWEP.Primary.HullSize 				= 0
SWEP.DamageType 					= 0

SWEP.DoMuzzleFlash 					= false

SWEP.FireModes = {
	"none"
}

SWEP.IronRecoilMultiplier			= 0
SWEP.CrouchRecoilMultiplier			= 0
SWEP.JumpRecoilMultiplier			= 0
SWEP.WallRecoilMultiplier			= 0
SWEP.ChangeStateRecoilMultiplier	= 0
SWEP.CrouchAccuracyMultiplier		= 0
SWEP.ChangeStateAccuracyMultiplier	= 0
SWEP.JumpAccuracyMultiplier			= 0
SWEP.WalkAccuracyMultiplier			= 0
SWEP.NearWallTime 					= 0.25
SWEP.ToCrouchTime 					= 0.1
SWEP.WeaponLength 					= 35
SWEP.SprintFOVOffset 				= 12
SWEP.ProjectileVelocity 			= 300

SWEP.ProjectileEntity 				= "ammo_chargepack"
SWEP.ProjectileModel 				= nil

SWEP.ViewModel						= "models/bf2017/c_scoutblaster.mdl"
SWEP.WorldModel						= "models/bf2017/w_scoutblaster.mdl"
SWEP.ViewModelFOV					= 75
SWEP.ViewModelFlip					= false
SWEP.MaterialTable 					= nil
SWEP.UseHands 						= false
SWEP.HoldType 						= "duel"

SWEP.ShowWorldModel = false

SWEP.BlowbackEnabled 				= true
SWEP.BlowbackVector 				= Vector(0,0,0)
SWEP.BlowbackCurrentRoot			= 0
SWEP.BlowbackCurrent 				= 0
SWEP.BlowbackBoneMods 				= nil
SWEP.Blowback_Only_Iron 			= false
SWEP.Blowback_PistolMode 			= false
SWEP.Blowback_Shell_Enabled 		= false
SWEP.Blowback_Shell_Effect 			= "None"

SWEP.Tracer							= 0
SWEP.TracerName 					= nil
SWEP.TracerCount 					= 1
SWEP.TracerLua 						= false
SWEP.TracerDelay					= 0.01
SWEP.ImpactEffect 					= nil
SWEP.ImpactDecal 					= nil

SWEP.VMPos = Vector(-05, -10, -4)
SWEP.VMAng = Vector(0,0,0)

SWEP.IronSightTime 					= 0.5
SWEP.Primary.KickUp					= 0
SWEP.Primary.KickDown				= 0
SWEP.Primary.KickHorizontal			= 0
SWEP.Primary.StaticRecoilFactor 	= 0
SWEP.Primary.Spread					= 0
SWEP.Primary.IronAccuracy 			= 0
SWEP.Primary.SpreadMultiplierMax 	= 0
SWEP.Primary.SpreadIncrement 		= 0
SWEP.Primary.SpreadRecovery 		= 0
SWEP.DisableChambering 				= true
SWEP.MoveSpeed 						= 0.7
SWEP.IronSightsMoveSpeed 			= 0.7

SWEP.IronSightsPos = Vector(0, 0, 0)
SWEP.IronSightsAng = Vector(0, 0, 0)
SWEP.RunSightsPos = Vector(0, 0, 0)
SWEP.RunSightsAng = Vector(0, 0, 0)
SWEP.InspectPos = Vector(0, 0, 0)
SWEP.InspectAng = Vector(0, 0, 0)

SWEP.ViewModelBoneMods = {
	["v_scoutblaster_reference001"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, -0.3, 0), angle = Angle(0, 0, 0) }
}

SWEP.ThirdPersonReloadDisable		= false
SWEP.Primary.DamageType 			= DMG_BULLET
SWEP.DamageType 					= DMG_BULLET
SWEP.RTScopeAttachment				= -1
SWEP.Scoped_3D 						= false
SWEP.ScopeReticule 					= "" 
SWEP.Secondary.ScopeZoom 			= 0
SWEP.ScopeReticule_Scale 			= {1,1}
if surface then
	SWEP.Secondary.ScopeTable = nil --[[
		{
			scopetex = surface.GetTextureID("scope/gdcw_closedsight"),
			reticletex = surface.GetTextureID("scope/gdcw_acogchevron"),
			dottex = surface.GetTextureID("scope/gdcw_acogcross")
		}
	]]--
end
DEFINE_BASECLASS( SWEP.Base )
--PATH lua/weapons/sswep_mouse.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/entities/weapons/stick_base/shared.lua:
AddCSLuaFile()

if CLIENT then
    SWEP.DrawAmmo = false
    SWEP.DrawCrosshair = false
end

DEFINE_BASECLASS("weapon_cs_base2")

SWEP.Author = "DarkRP Developers"
SWEP.Contact = ""
SWEP.Purpose = ""
SWEP.IconLetter = ""

SWEP.ViewModelFOV = 62
SWEP.ViewModelFlip = false
SWEP.AnimPrefix = "stunstick"

SWEP.UseHands = false

SWEP.AdminOnly = true

SWEP.StickColor = color_white

SWEP.ViewModel = Model("models/weapons/v_stunbaton.mdl")
SWEP.WorldModel = Model("models/weapons/w_stunbaton.mdl")

SWEP.Sound = Sound("weapons/stunstick/stunstick_swing1.wav")

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = 0
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = ""

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = 0
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = ""

function SWEP:SetupDataTables()
    BaseClass.SetupDataTables(self)
    -- Bool 0 = IronsightsPredicted
    -- Bool 1 = Reloading
    self:NetworkVar("Bool", 2, "SeqIdling")
    -- Float 0 = IronsightsTime
    -- Float 1 = LastPrimaryAttack
    -- Float 2 = ReloadEndTime
    -- Float 3 = BurstTime
    self:NetworkVar("Float", 4, "SeqIdleTime")
    self:NetworkVar("Float", 5, "HoldTypeChangeTime")
end

local stunstickMaterials
function SWEP:Initialize()
    self:SetHoldType("normal")

    self.stickRange = 90

    if SERVER then return end

    stunstickMaterials = stunstickMaterials or {}

    local materialName = "darkrp/" .. self:GetClass()
    if stunstickMaterials[materialName] then return end

    CreateMaterial(materialName, "VertexLitGeneric", {
        ["$basetexture"] = "models/debug/debugwhite",
        ["$surfaceprop"] = "metal",
        ["$envmap"] = "env_cubemap",
        ["$envmaptint"] = "[ .5 .5 .5 ]",
        ["$selfillum"] = 0,
        ["$model"] = 1
    }):SetVector("$color2", self.StickColor:ToVector())

    stunstickMaterials[materialName] = true
end

function SWEP:Deploy()
    BaseClass.Deploy(self)
    if SERVER then
        self:SetMaterial("!darkrp/" .. self:GetClass())
    end

    local vm = self:GetOwner():GetViewModel()
    if not IsValid(vm) then return true end

    vm:SendViewModelMatchingSequence(vm:LookupSequence("idle01"))

    return true
end

function SWEP:PreDrawViewModel(vm)
    for i = 9, 15 do
        vm:SetSubMaterial(i, "!darkrp/" .. self:GetClass())
    end
end

function SWEP:ViewModelDrawn(vm)
    if not IsValid(vm) then return end
    vm:SetSubMaterial() -- clear sub-materials
end

function SWEP:ResetStick()
    if not IsValid(self:GetOwner()) then return end
    if SERVER then
        self:SetMaterial() -- clear material
    end
    self:SetSeqIdling(false)
    self:SetSeqIdleTime(0)
    self:SetHoldTypeChangeTime(0)
end

function SWEP:Holster()
    BaseClass.Holster(self)
    self:ResetStick()
    return true
end

function SWEP:Think()
    if self:GetSeqIdling() then
        self:SetSeqIdling(false)

        if not IsValid(self:GetOwner()) then return end
        self:GetOwner():SetAnimation(PLAYER_ATTACK1)
        self:EmitSound(self.Sound)

        local vm = self:GetOwner():GetViewModel()
        if not IsValid(vm) then return end
        vm:SendViewModelMatchingSequence(vm:LookupSequence("attackch"))
        vm:SetPlaybackRate(1 + 1 / 3)
        local duration = vm:SequenceDuration() / vm:GetPlaybackRate()
        local time = CurTime() + duration
        self:SetSeqIdleTime(time)
        self:SetNextPrimaryFire(time)
    end
    if self:GetSeqIdleTime() ~= 0 and CurTime() >= self:GetSeqIdleTime() then
        self:SetSeqIdleTime(0)

        if not IsValid(self:GetOwner()) then return end
        local vm = self:GetOwner():GetViewModel()
        if not IsValid(vm) then return end
        vm:SendViewModelMatchingSequence(vm:LookupSequence("idle01"))
    end
    if self:GetHoldTypeChangeTime() ~= 0 and CurTime() >= self:GetHoldTypeChangeTime() then
        self:SetHoldTypeChangeTime(0)
        self:SetHoldType("normal")
    end
end

function SWEP:PrimaryAttack()
    self:SetHoldType("melee")
    self:SetHoldTypeChangeTime(CurTime() + 0.3)

    self:SetNextPrimaryFire(CurTime() + 0.51) -- Actual delay is set later.

    local vm = self:GetOwner():GetViewModel()
    if IsValid(vm) then
        vm:SendViewModelMatchingSequence(vm:LookupSequence("idle01"))
        self:SetSeqIdling(true)
    end
end

function SWEP:SecondaryAttack()
    -- Do nothing
end

function SWEP:Reload()
    -- Do nothing
end

--PATH gamemodes/starwarsrp/entities/weapons/stunstick/shared.lua:
return gluapack()()
--PATH lua/weapons/tfa_gun_base/cl_init.lua:
return gluapack()()
--PATH lua/weapons/tfa_gun_base/common/ttt.lua:
return gluapack()()
--PATH lua/weapons/tfa_gun_base/client/hud.lua:
return gluapack()()
--PATH lua/weapons/tfa_gun_base/client/fov.lua:
return gluapack()()
--PATH addons/[bronie] kajdanki/lua/weapons/weapon_cuff_shackles.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/weapons/weapon_lscs/shared.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/weapons/weapon_lscs/cl_worldmodel.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/weapons/weapon_lscs/cl_effects.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/weapons/weapon_lscs/cl_effects.lua:
SWEP.BladeData = {
	[SWEP.HAND_RIGHT] = {
	},
	[SWEP.HAND_LEFT] = {
	},
}

function SWEP:CalcTrail( HandID, BladeID, PosData, bladeObject, Mul )
	local DMGActive = self:GetDMGActive()
	local LifeTime = self:GetBladeLifeTime()
	local CurTime = CurTime()

	local length = bladeObject.length * (PosData.length_multiplier or 1)

	local cur_pos = PosData.pos + PosData.dir * length
	local cur_dir = -PosData.dir

	if self:CanDoTrail( HandID, BladeID, 0.02 ) then
		for id, data in pairs( self.BladeData[HandID][BladeID].BladePositions ) do
			if CurTime - data.time > LifeTime then
				self.BladeData[HandID][BladeID].BladePositions[id] = nil
			end
		end

		if DMGActive then
			local data = {
				time = CurTime,
				pos = cur_pos,
				dir = cur_dir,
			}

			table.insert(self.BladeData[HandID][BladeID].BladePositions, data)
			table.sort(self.BladeData[HandID][BladeID].BladePositions, function( a, b ) return a.time > b.time end )
		end

		if Mul == 1 and bladeObject.dynamic_light and LSCS.DynamicLight then
			local dlight = DynamicLight( self:EntIndex() * 1000 + HandID * 10 + BladeID )
			if dlight then
				dlight.pos = cur_pos + cur_dir * length * 0.5
				dlight.r = bladeObject.color_blur.r
				dlight.g = bladeObject.color_blur.g
				dlight.b = bladeObject.color_blur.b
				dlight.brightness = 2
				dlight.Decay = 100
				dlight.Size = 125
				dlight.DieTime = CurTime + 0.2
			end
		end
	end

	render.SetMaterial( bladeObject.material_trail )

	self:DrawTrail( cur_pos, cur_dir, CurTime, LifeTime, length, self.BladeData[HandID][BladeID].BladePositions,  bladeObject.color_core, bladeObject.color_blur, DMGActive )
end

local function OverClocked() -- if someone has host_timescale lower than default 1, chances are he wants to make a screenshot. Lets increase detail to maximum in this case for best looks.
	return LSCS.TimeScale < 0.9
end

function SWEP:DrawTrail( MyPos, MyDir, CurTime, LifeTime, Length, Positions, ColorStart, ColorEnd, DMGActive )
	local prev

	if DMGActive then
		prev = {
			pos = MyPos,
			dir = MyDir,
			time = CurTime
		}
	end

	local LoopStep = OverClocked() and 1 or 2

	local idx = 0
	for _, cur in ipairs( Positions ) do
		if prev then
			local startpos = prev.pos
			local startdir = prev.dir

			local endpos = cur.pos
			local enddir = cur.dir

			local subtract = endpos - startpos

			local direction = subtract:GetNormalized()
			local distance = subtract:Length()

			for i = LoopStep, distance,LoopStep do
				idx = idx + 1

				if idx > self:GetMaxBeamElements() then
					break
				end

				local _pos = startpos + direction * i
				local _dir = startdir + (enddir - startdir) / distance * i
				local _time = prev.time + (cur.time - prev.time) / distance * i
				local _alpha = math.max( (_time + LifeTime - CurTime) / LifeTime, 0)

				local _alpha2 = (math.max(_alpha - 0.8,0) / 0.2) ^ 2
				local inv_alpha2 = math.max(1 - _alpha2,0)

				local R = ColorStart.r * _alpha2 + ColorEnd.r * inv_alpha2
				local G = ColorStart.g * _alpha2 + ColorEnd.g * inv_alpha2
				local B = ColorStart.b * _alpha2 + ColorEnd.b * inv_alpha2
				local A = (ColorStart.a * _alpha2 + ColorEnd.a * inv_alpha2) * _alpha

				render.DrawBeam( _pos, _pos + _dir * Length, 12, 1, 1, Color(R, G, B, A ) )
			end
		end

		prev = {
			pos = cur.pos,
			dir = cur.dir,
			time = cur.time
		}
	end
end

function SWEP:CanDoTrail( HandID, BladeID, Next )
	local Time = CurTime()
	if self.BladeData[HandID][BladeID].BladeNext < Time then
		self.BladeData[HandID][BladeID].BladeNext = Time + Next

		return true
	else
		return false
	end
end

function SWEP:CanDoEffect( HandID, BladeID, Next )
	local Time = CurTime()
	if self.BladeData[HandID][BladeID].NextImpactFX < Time then
		self.BladeData[HandID][BladeID].NextImpactFX = Time + Next

		return true
	else
		return false
	end
end

function SWEP:ObjectImpactEffects( pos, dir )
	local effectdata = EffectData()
		effectdata:SetOrigin( pos )
	util.Effect( "saber_hit_generic", effectdata, true, true )
end

function SWEP:IsMe()
	if not self._IsMe and IsValid( self:GetOwner() ) then
		self._IsMe = self:GetOwner() == LocalPlayer()
	end

	return self._IsMe
end

function SWEP:WallImpactEffects( pos, dir, playsound )
	if playsound then
		local effectdata = EffectData()
			effectdata:SetOrigin( pos )
			effectdata:SetNormal( dir )
		util.Effect( "saber_hitwall_cheap", effectdata, true, true )

		sound.Play(Sound( "saber_hitwall_spark" ), pos, 75)
	else
		local effectdata = EffectData()
			effectdata:SetOrigin( pos )
			effectdata:SetNormal( dir )
		util.Effect( "saber_hitwall", effectdata, true, true )
	end
end

function SWEP:GetMaxBeamElements()
	if OverClocked() then
		return 400
	end
	if self:IsMe() then
		return 200 * LSCS.SaberTrailDetail
	else
		return 25 * LSCS.SaberTrailDetail
	end
end

function SWEP:GetBladeLifeTime()
	if OverClocked() then
		return 0.15
	end
	if self:IsMe() then
		return 0.15 * LSCS.SaberTrailDetail
	else
		return 0.1 * LSCS.SaberTrailDetail
	end
end

function SWEP:DrawBlade( HandID, BladeID, PosData, bladeObject, Mul, HiltAngles )
	local length = bladeObject.length * (PosData.length_multiplier or 1)

	local width = bladeObject.width * (PosData.width_multiplier or 1)
	local actual_width = width + math.Rand(0,bladeObject.widthWiggle)

	local pos = PosData.pos
	local dir = PosData.dir

	local w12 = width * 12
	local w32 = width * 32

	local color_blur = bladeObject.color_blur
	local color_core = bladeObject.color_core

	local Frac = self:DoBladeTrace( HandID, BladeID, pos, dir, length * Mul, width ).Fraction

	local MulxFrac = Mul * Frac

	if bladeObject.mdl then
		self:DrawBladeModel( HandID, BladeID, PosData, bladeObject, MulxFrac, HiltAngles )

		return
	end

	--TODO: call a render function in the blade here & allow returning false to prevent original rendering

	render.SetMaterial( bladeObject.material_glow )
	render.DrawSprite( pos, w32, w32, color_blur )

	-- inefficient pls replace
	for i = 0, math.Round( (length - 1) * MulxFrac, 0 ) do
		render.DrawSprite( pos + dir * i, w12, w12, color_blur ) 
	end

	local EndPos = pos + dir * math.max(length - 0.9,0) * MulxFrac

	render.SetMaterial( bladeObject.material_core )
	render.DrawBeam( pos, EndPos, actual_width , 1, 1, color_core )

	render.SetMaterial( bladeObject.material_core_tip )
	render.DrawBeam( EndPos, EndPos + dir, actual_width , 0.9, 0.1, color_core )
end

function SWEP:DoImpactEffects( HandID, BladeID, bHit, vPos, vDir, hitEnt, ply, min, max )
	local start_pos = ply:GetShootPos()

	if self:IsThrown() then
		start_pos = self:GetProjectile():GetPos()
	end

	local aimDir = ply:GetAimVector()
	local dmgActive = self:GetDMGActive()

	local bHitWall = bHit and not IsValid( hitEnt )
	if self.BladeData[HandID][BladeID].HitWall ~= bHitWall then
		self.BladeData[HandID][BladeID].HitWall = bHitWall

		if bHitWall then
			if dmgActive then
				sound.Play( "saber_lighthit", vPos )
			end
		else
			sound.Play( "saber_hitwall", vPos )
		end
	end

	-- ?option performance setting?
	--[[
	if ply ~= LocalPlayer() then
		if not IsValid( hitEnt ) and bHitWall then
			if self:CanDoEffect( HandID, BladeID, 0.05 ) then
				self:WallImpactEffects(vPos, vDir, true )
			end
		end

		return
	end
	]]

	if self.BladeData[HandID][BladeID].prev_hitpos and self.BladeData[HandID][BladeID].prev_hitnormal then
		local _pos = self.BladeData[HandID][BladeID].prev_hitpos
		local _dir = self.BladeData[HandID][BladeID].prev_hitnormal
		local dir = (vPos - _pos):GetNormalized()

		local dist = math.Round( (vPos - _pos):Length() , 0 )

		if dist > 0 then
			local idx = 0

			for i = 2, dist,2 do
				idx = idx + 1

				local trace = util.TraceHull( {
					start = start_pos,
					endpos = _pos + dir * i + aimDir * 5,
					mins = min,
					maxs = max,
					mask = MASK_SHOT_HULL,
					filter = { self, ply }
				} )

				debugoverlay.SweptBox( start_pos, _pos + dir * i + aimDir * 5, min, max, (start_pos -  (_pos + dir * i + aimDir * 5)):Angle(), 10, Color( 0, 100, 255 ) )

				if trace.Hit and not IsValid( trace.Entity ) then
					if idx < 26 then
						self:WallImpactEffects( trace.HitPos, trace.HitNormal, false )
					end
				end

				if dmgActive then
					self:RegisterHitCL( trace.Entity, trace.HitPos, trace.HitNormal )
				end
			end
		else
			if dmgActive then
				self:RegisterHitCL( hitEnt, vPos, vDir )
			else
				if not IsValid( hitEnt ) then
					self:WallImpactEffects(vPos, vDir, true )
				end
			end
		end
	else
		if not IsValid( hitEnt ) and bHitWall then
			if self:CanDoEffect( HandID, BladeID, self:IsMe() and 0.01 or 0.05 ) then
				self:WallImpactEffects(vPos, vDir, true )
			end
		end
	end

	self.BladeData[HandID][BladeID].prev_hitpos = vPos
	self.BladeData[HandID][BladeID].prev_hitnormal = vDir
end

function SWEP:DoBladeTrace( HandID, BladeID, pos, dir, length, width )
	if not self.BladeData[HandID][BladeID] then
		self.BladeData[HandID][BladeID] = {
			NextImpactFX = 0,
			BladePositions  = {},
			BladeNext = 0,
			HitWall = false,
		}
	end

	local ply = self:GetOwner()

	local max = Vector( width, width, width )
	local min = -max

	ply:LagCompensation( true ) --TODO: test if this makes a difference 

	local trace = util.TraceHull( {
		start = pos,
		endpos = pos + dir * length,
		mins = min,
		maxs = max,
		mask = MASK_SHOT_HULL,
		filter =  {self, ply}
	} )

	ply:LagCompensation( false )

	if trace.Hit and trace.Fraction == 1 then
		trace.Fraction = 0
		trace.HitPos = pos
	end

	if IsValid( trace.Entity ) and not self:GetDMGActive() then
		if self:CanDoEffect( HandID, BladeID, 0.05 ) then
			self:ObjectImpactEffects( trace.HitPos, trace.HitNormal )
		end
	end

	if self:GetDMGActive() then
		debugoverlay.SweptBox( pos, pos + dir * length, min, max, dir:Angle(), 10, Color( 255, 0, 0 ) )
	else
		self.BladeData[HandID][BladeID].prev_hitpos = nil
		self.BladeData[HandID][BladeID].prev_hitnormal = nil
	end

	self:DoImpactEffects( HandID, BladeID, trace.Hit, trace.HitPos, trace.HitNormal, trace.Entity, ply, min, max )

	return trace
end

function SWEP:RegisterHitCL( target, Pos, Dir )
	if not IsValid( target ) then return end

	local ply = self:GetOwner()

	if not IsValid( ply ) then return end

	if ply ~= LocalPlayer() then return end

	local CurTime = CurTime()

	if (target.HitTime or 0) < CurTime then
		target.HitTime = CurTime + 0.15

		net.Start( "lscs_saberdamage" ) 
			net.WriteEntity( target )
			net.WriteVector( Pos )
			net.WriteVector( Dir )
		net.SendToServer()
	end
end
--PATH addons/[miecze] moce i hilty/lua/weapons/weapon_lscs_shockstaff.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/weapons/weapon_lscs_tusken.lua:
AddCSLuaFile()

SWEP.Base = "weapon_lscs"
DEFINE_BASECLASS( "weapon_lscs" )

SWEP.Category		= "[LSCS]"
SWEP.PrintName	= "Tusken Gaffi"
SWEP.Author		= "BadJay707"
SWEP.Slot		= 0
SWEP.SlotPos 	= 3
SWEP.Spawnable	= true
SWEP.AdminOnly	= false

function SWEP:SetupDataTables()
	BaseClass.SetupDataTables( self )

	if SERVER then
		self:SetHiltR("tuskengaffi") 
		self:SetBladeR("tuskengafficrys") 
	end
end
--PATH lua/weapons/weapon_lvsrepair.lua:
AddCSLuaFile()

SWEP.Category				= "[LVS]"
SWEP.Spawnable			= true
SWEP.AdminSpawnable		= false
SWEP.ViewModel			= "models/weapons/c_repairlvs.mdl"
SWEP.WorldModel			= "models/weapons/w_repairlvs.mdl"
SWEP.UseHands				= true

SWEP.HoldType				= "slam"

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip		= -1
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo			= "none"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic		= false
SWEP.Secondary.Ammo		= "none"

SWEP.MaxRange = 250

function SWEP:SetupDataTables()
	self:NetworkVar( "Float",0, "FlameTime" )
end

function SWEP:GetLVS()
	local ply = self:GetOwner()

	if not IsValid( ply ) then return NULL end

	local ent = ply:GetEyeTrace().Entity

	if not IsValid( ent ) then return NULL end

	if ent._lvsRepairToolLabel or ent.LVS then return ent end

	if not ent.GetBase then return NULL end

	ent = ent:GetBase()

	if IsValid( ent ) and ent.LVS then return ent end

	return NULL
end

function SWEP:FindClosest()
	local lvsEnt = self:GetLVS()

	if not IsValid( lvsEnt ) then return NULL end

	local ply = self:GetOwner()

	if ply:InVehicle() then return end

	local ShootPos = ply:GetShootPos()
	local AimVector = ply:GetAimVector()

	local ClosestDist = self.MaxRange
	local ClosestPiece = NULL

	local tableEnts = lvsEnt:GetChildren()

	if isfunction( lvsEnt.GetCrosshairFilterEnts ) then
		tableEnts = lvsEnt:GetCrosshairFilterEnts()
	end

	for _, target in pairs( tableEnts ) do
		if not IsValid( target ) then continue end

		for _, entity in pairs( target:GetChildren() ) do
			if entity:GetClass() ~= "lvs_armor" then continue end

			local boxOrigin = entity:GetPos()
			local boxAngles = entity:GetAngles()
			local boxMins = entity:GetMins()
			local boxMaxs = entity:GetMaxs()

			local HitPos, _, _ = util.IntersectRayWithOBB( ShootPos, AimVector * 1000, boxOrigin, boxAngles, boxMins, boxMaxs )

			if isvector( HitPos ) then
				local Dist = (ShootPos - HitPos):Length()

				if Dist < ClosestDist then
					ClosestDist = Dist
					ClosestPiece = entity
				end
			end
		end
	end

	return ClosestPiece
end

local function IsEngineMode( AimPos, Engine )
	if not IsValid( Engine ) then return false end

	if not isfunction( Engine.GetDoorHandler ) then return (AimPos - Engine:GetPos()):Length() < 25 end

	local DoorHandler = Engine:GetDoorHandler()

	if IsValid( DoorHandler ) then
		if DoorHandler:IsOpen() then
			return (AimPos - Engine:GetPos()):Length() < 50
		end

		return false
	end

	return (AimPos - Engine:GetPos()):Length() < 25
end

if CLIENT then
	SWEP.PrintName		= "Repair Torch"
	SWEP.Author			= "Blu-x92"

	SWEP.Slot				= 5
	SWEP.SlotPos			= 1

	SWEP.Purpose			= "Repair Broken Armor"
	SWEP.Instructions		= "Primary to Repair\nHold Secondary to switch to Armor Repair Mode"
	SWEP.DrawWeaponInfoBox 	= true

	SWEP.WepSelectIcon 			= surface.GetTextureID( "weapons/lvsrepair" )

	local ColorSelect = Color(0,255,255,50)
	local ColorText = Color(255,255,255,255)

	local function DrawText( pos, text, col )
		cam.Start2D()
			local data2D = pos:ToScreen()

			if not data2D.visible then return end

			local font = "TargetIDSmall"

			local x = data2D.x
			local y = data2D.y

			draw.DrawText( text, font, x + 1, y + 1, Color( 0, 0, 0, 120 ), TEXT_ALIGN_CENTER )
			draw.DrawText( text, font, x + 2, y + 2, Color( 0, 0, 0, 50 ), TEXT_ALIGN_CENTER )
			draw.DrawText( text, font, x, y, col or color_white, TEXT_ALIGN_CENTER )
		cam.End2D()
	end

	function SWEP:DrawEffects( weapon, ply )
		local ID = weapon:LookupAttachment( "muzzle" )

		local Muzzle = weapon:GetAttachment( ID )

		if not Muzzle then return end

		local T = CurTime()

		if self:GetFlameTime() < T or (self._NextFX1 or 0) > T then return end

		self._NextFX1 = T + 0.02

		local effectdata = EffectData()
		effectdata:SetOrigin( Muzzle.Pos )
		effectdata:SetAngles( Muzzle.Ang )
		effectdata:SetScale( 0.5 )
		util.Effect( "MuzzleEffect", effectdata, true, true )

		if (self._NextFX2 or 0) > T then return end

		self._NextFX2 = T + 0.06

		local trace = ply:GetEyeTrace()
		local ShootPos = ply:GetShootPos()

		if (ShootPos - trace.HitPos):Length() > self.MaxRange then return end

		local effectdata = EffectData()
			effectdata:SetOrigin( trace.HitPos )
			effectdata:SetNormal( trace.HitNormal * 0.15 )
		util.Effect( "manhacksparks", effectdata, true, true )

		local dlight = DynamicLight( self:EntIndex() )

		if not dlight then return end

		dlight.pos = (trace.HitPos + ShootPos) * 0.5
		dlight.r = 206
		dlight.g = 253
		dlight.b = 255
		dlight.brightness = 3
		dlight.decay = 1000
		dlight.size = 256
		dlight.dietime = CurTime() + 0.1
	end

	function SWEP:PostDrawViewModel( vm, weapon, ply )
		self:DrawEffects( vm, ply )
	end

	function SWEP:DrawWorldModel( flags )
		self:DrawModel( flags )
		self:DrawEffects( self, self:GetOwner() )
	end

	function SWEP:DrawHUD()
		local ply = self:GetOwner()

		if not IsValid( ply ) or not ply:KeyDown( IN_ATTACK2 ) then
			local lvsEnt = self:GetLVS()
			local Pos = ply:GetEyeTrace().HitPos

			if IsValid( lvsEnt ) and (Pos - ply:GetShootPos()):Length() < self.MaxRange and not ply:InVehicle() then
				local Label = lvsEnt._lvsRepairToolLabel or "Frame"

				if isfunction( lvsEnt.GetEngine ) then
					local Engine = lvsEnt:GetEngine()

					local AimPos = ply:GetEyeTrace().HitPos

					local EngineMode = IsEngineMode( AimPos, Engine )

					if IsValid( Engine ) and EngineMode then
						DrawText( AimPos, "Engine\nHealth: "..math.Round(Engine:GetHP()).."/"..Engine:GetMaxHP(), ColorText )
					else
						DrawText( AimPos, Label.."\nHealth: "..math.Round(lvsEnt:GetHP()).."/"..lvsEnt:GetMaxHP(), ColorText )
					end
				else
					DrawText( ply:GetEyeTrace().HitPos, Label.."\nHealth: "..math.Round(lvsEnt:GetHP()).."/"..lvsEnt:GetMaxHP(), ColorText )
				end
			end

			return
		end

		local Target = self:FindClosest()

		if IsValid( Target ) then
			local boxOrigin = Target:GetPos()
			local boxAngles = Target:GetAngles()
			local boxMins = Target:GetMins()
			local boxMaxs = Target:GetMaxs()

			cam.Start3D()
				render.SetColorMaterial()
				render.DrawBox( boxOrigin, boxAngles, boxMins, boxMaxs, ColorSelect )
			cam.End3D()

			DrawText( Target:LocalToWorld( (boxMins + boxMaxs) * 0.5 ), (Target:GetIgnoreForce() / 100).."mm "..Target:GetLabel().."\nHealth: "..math.Round(Target:GetHP()).."/"..Target:GetMaxHP(), ColorText )
		else
			local Pos = ply:GetEyeTrace().HitPos

			if IsValid( self:GetLVS() ) and (Pos - ply:GetShootPos()):Length() < self.MaxRange and not ply:InVehicle() then
				DrawText( Pos, "No Armor", ColorText )
			end
		end
	end
end

function SWEP:Initialize()
	self:SetHoldType( self.HoldType )
end

function SWEP:PrimaryAttack()
	local T = CurTime()

	self:SetNextPrimaryFire( T + 0.15 )

	self:SetFlameTime( T + 0.3 )

	local EngineMode = false
	local ArmorMode = true
	local Target = self:FindClosest()

	local ply = self:GetOwner()

	if IsValid( ply ) and not ply:KeyDown( IN_ATTACK2 ) then
		Target = self:GetLVS()

		if isfunction( Target.GetEngine ) then
			local Engine = Target:GetEngine()

			local AimPos = ply:GetEyeTrace().HitPos

			EngineMode = IsEngineMode( AimPos, Engine )

			if IsValid( Engine ) and EngineMode then
				Target = Engine
			end
		end

		ArmorMode = false
	end

	if not IsValid( Target ) then return end

	local HP = Target:GetHP()
	local MaxHP = Target:GetMaxHP()

	if IsFirstTimePredicted() then
		local trace = ply:GetEyeTrace()

		if HP ~= MaxHP then
			local effectdata = EffectData()
			effectdata:SetOrigin( trace.HitPos )
			effectdata:SetNormal( trace.HitNormal )
			util.Effect( "stunstickimpact", effectdata, true, true )
		end
	end

	if CLIENT then return end

	Target:SetHP( math.min( HP + 15, MaxHP ) )

	if EngineMode and Target:GetDestroyed() then
		Target:SetDestroyed( false )
	end

	if not ArmorMode then return end

	if Target:GetDestroyed() then Target:SetDestroyed( false ) end

	if HP < MaxHP then return end

	Target:OnRepaired()
end

function SWEP:SecondaryAttack()
end

function SWEP:Think()
	local ply = self:GetOwner()

	if not IsValid( ply ) then self:StopSND() return end

	local PlaySound = self:GetFlameTime() >= CurTime() and (ply:GetShootPos() - ply:GetEyeTrace().HitPos):Length() < self.MaxRange

	if PlaySound then
		self:PlaySND()
	else
		self:StopSND()
	end
end

function SWEP:StopSND()
	if CLIENT then return end

	if not self._snd then return end

	self._snd:Stop()
	self._snd = nil
end

function SWEP:PlaySND()
	if CLIENT then return end

	if self._snd then return end

	local ply = self:GetOwner()

	if not IsValid( ply ) then return end

	self._snd = CreateSound( ply, "lvs/weldingtorch_loop.wav" )
	self._snd:PlayEx(1, 70 )
end

function SWEP:OnRemove()
	self:StopSND()
end

function SWEP:OnDrop()
	self:StopSND()
end

function SWEP:Holster( wep )
	self:StopSND()
	return true
end

--PATH gamemodes/starwarsrp/entities/weapons/weapon_m42/shared.lua:
AddCSLuaFile()

if CLIENT then
    SWEP.Author = "DarkRP Developers"
    SWEP.Contact = ""
    SWEP.Purpose = ""
    SWEP.Instructions = "Hold use and left-click to change firemodes."
    SWEP.Slot = 2
    SWEP.SlotPos = 0
    SWEP.IconLetter = "w"

    killicon.AddFont("weapon_m42", "CSKillIcons", SWEP.IconLetter, Color(255, 80, 0, 255))
end

SWEP.Base = "weapon_cs_base2"

SWEP.PrintName = "M4"
SWEP.Spawnable = true
SWEP.AdminOnly = false
SWEP.Category = "DarkRP (Weapon)"

SWEP.ViewModel = "models/weapons/cstrike/c_rif_m4a1.mdl"
SWEP.WorldModel = "models/weapons/w_rif_m4a1.mdl"
SWEP.HoldType = "ar2"
SWEP.LoweredHoldType = "passive"
SWEP.DarkRPViewModelBoneManipulations = {
    ["ValveBiped.Bip01_Spine4"] = {
        scale = Vector(1, 1, 1),
        pos = Vector(2, 0, 0),
        angle = Angle(0, 0, 0)
    },
    ["ValveBiped.Bip01_L_Hand"] = {
        scale = Vector(0.7, 0.7, 0.5),
        pos = Vector(-0.6, -0.6, 0),
        angle = Angle(17, -21, 0)
    },
    ["ValveBiped.Bip01_L_Finger0"] = {
        scale = Vector(1, 1, 1.5),
        pos = Vector(0, 0, 0),
        angle = Angle(0, -2, 0)
    },
    ["ValveBiped.Bip01_L_Finger1"] = {
        scale = Vector(1, 1, 1.5),
        pos = Vector(-0.3, -0.8, 0),
        angle = Angle(0, -10, 0)
    },
    ["ValveBiped.Bip01_L_Finger11"] = {
        scale = Vector(1, 1, 1),
        pos = Vector(0, 0, 0),
        angle = Angle(0, -15, 0)
    },
    ["ValveBiped.Bip01_L_Finger12"] = {
        scale = Vector(1, 1, 1),
        pos = Vector(0, 0, 0),
        angle = Angle(0, -14, 0)
    },
    ["ValveBiped.Bip01_L_Finger2"] = {
        scale = Vector(1, 1, 1.5),
        pos = Vector(-0.6, -1, -0),
        angle = Angle(0, 7, 0)
    },
    ["ValveBiped.Bip01_L_Finger21"] = {
        scale = Vector(1, 1, 1),
        pos = Vector(0, 0, 0),
        angle = Angle(0, -15, 0)
    },
    ["ValveBiped.Bip01_L_Finger22"] = {
        scale = Vector(0.8, 0.8, 1),
        pos = Vector(0, -0.3, 0),
        angle = Angle(0, -36, 0)
    },
    ["ValveBiped.Bip01_L_Finger3"] = {
        scale = Vector(1, 1, 1.5),
        pos = Vector(-0.36, -1.2, -0.2),
        angle = Angle(-6, -2, 0)
    },
    ["ValveBiped.Bip01_L_Finger31"] = {
        scale = Vector(1, 1, 1),
        pos = Vector(0, -0.1, 0),
        angle = Angle(0, -4, 0)
    },
    ["ValveBiped.Bip01_L_Finger32"] = {
        scale = Vector(1, 1, 1),
        pos = Vector(0, -0.2, 0),
        angle = Angle(0, -12, 0)
    },
    ["ValveBiped.Bip01_L_Finger4"] = {
        scale = Vector(1, 1, 1.5),
        pos = Vector(-0.3, -1.2, 0.3),
        angle = Angle(12, -6.2, -4)
    },
    ["ValveBiped.Bip01_L_Finger41"] = {
        scale = Vector(1, 1, 1),
        pos = Vector(0, 0, 0),
        angle = Angle(0, 38, 0)
    },
    ["ValveBiped.Bip01_L_Finger42"] = {
        scale = Vector(1, 1, 1),
        pos = Vector(0, 0, 0),
        angle = Angle(0, 30, 0)
    }
}

SWEP.Weight = 5
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false

SWEP.Primary.Sound = Sound("Weapon_M4A1.Single")
SWEP.Primary.Recoil = 1.25
SWEP.Primary.Unrecoil = 8
SWEP.Primary.Damage = 15
SWEP.Primary.NumShots = 1
SWEP.Primary.Cone   = 0.03
SWEP.Primary.ClipSize = 30
SWEP.Primary.Delay = 0.07
SWEP.Primary.DefaultClip = 30
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "smg1"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

-- Start of Firemode configuration
SWEP.IronSightsPos = Vector(-8.09, -4.5, 0.56)
SWEP.IronSightsAng = Vector(2.75, -3.97, -3.8)
SWEP.IronSightsPosAfterShootingAdjustment = Vector(0.5, 0, 0)
SWEP.IronSightsAngAfterShootingAdjustment = Vector(0, 1.65, 0)

SWEP.MultiMode = true

--PATH gamemodes/starwarsrp/entities/weapons/weapon_mac102/shared.lua:
AddCSLuaFile()

if CLIENT then
    SWEP.Author = "DarkRP Developers"
    SWEP.Slot = 2
    SWEP.SlotPos = 0
    SWEP.IconLetter = "l"

    killicon.AddFont("weapon_mac102", "CSKillIcons", SWEP.IconLetter, Color(255, 80, 0, 255))
end

SWEP.Base = "weapon_cs_base2"

SWEP.PrintName = "Mac10"
SWEP.Spawnable = true
SWEP.AdminOnly = false
SWEP.Category = "DarkRP (Weapon)"

SWEP.ViewModel = "models/weapons/cstrike/c_smg_mac10.mdl"
SWEP.WorldModel = "models/weapons/w_smg_mac10.mdl"

SWEP.Weight = 5
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false

SWEP.HoldType = "pistol"
SWEP.LoweredHoldType = "normal"

SWEP.Primary.Sound = Sound("Weapon_mac10.Single")
SWEP.Primary.Recoil = .8
SWEP.Primary.Damage = 30
SWEP.Primary.NumShots = 1
SWEP.Primary.Cone = 0.02
SWEP.Primary.ClipSize = 25
SWEP.Primary.Delay = 0.09
SWEP.Primary.DefaultClip = 25
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "smg1"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

SWEP.IronSightsPos = Vector(-9.08, -8, 2.6)
SWEP.IronSightsAng = Vector(1.8, -7.06, -6.1)

--PATH gamemodes/starwarsrp/entities/weapons/weapon_mp52/shared.lua:
return gluapack()()
--PATH lua/weapons/weapon_policebaton/cl_init.lua:
return gluapack()()
--PATH lua/weapons/weapon_vj_ar2/shared.lua:
return gluapack()()
--PATH lua/weapons/weapon_vj_glock17/shared.lua:
return gluapack()()
--PATH lua/weapons/weapon_vj_smg1/shared.lua:
if (!file.Exists("autorun/vj_base_autorun.lua","LUA")) then return end
---------------------------------------------------------------------------------------------------------------------------------------------
SWEP.Base 						= "weapon_vj_base"
SWEP.PrintName					= "SMG1"
SWEP.Author 					= "DrVrej"
SWEP.Contact					= "http://steamcommunity.com/groups/vrejgaming"
SWEP.Purpose					= "This weapon is made for Players and NPCs"
SWEP.Instructions				= "Controls are like a regular weapon."
SWEP.Category					= "VJ Base"
	-- Client Settings ---------------------------------------------------------------------------------------------------------------------------------------------
if CLIENT then
SWEP.Slot						= 2 -- Which weapon slot you want your SWEP to be in? (1 2 3 4 5 6) 
SWEP.SlotPos					= 4 -- Which part of that slot do you want the SWEP to be in? (1 2 3 4 5 6)
SWEP.UseHands					= true
end
	-- Main Settings ---------------------------------------------------------------------------------------------------------------------------------------------
SWEP.ViewModel					= "models/weapons/c_smg1.mdl"
SWEP.WorldModel					= "models/weapons/w_smg1.mdl"
SWEP.HoldType 					= "smg"
SWEP.Spawnable					= true
SWEP.AdminSpawnable				= false
	-- NPC Settings ---------------------------------------------------------------------------------------------------------------------------------------------
SWEP.NPC_HasSecondaryFire = true -- Can the weapon have a secondary fire?
SWEP.NPC_SecondaryFireSound = {"weapons/ar2/ar2_altfire.wav"} -- The sound it plays when the secondary fire is used
	-- Primary Fire ---------------------------------------------------------------------------------------------------------------------------------------------
SWEP.Primary.Damage				= 5 -- Damage
SWEP.Primary.ClipSize			= 45 -- Max amount of bullets per clip
SWEP.Primary.Delay				= 0.09 -- Time until it can shoot again
SWEP.Primary.Automatic			= true -- Is it automatic?
SWEP.Primary.Ammo				= "SMG1" -- Ammo type
SWEP.Primary.Sound				= {"vj_weapons/hl2_smg1/smg1_single1.wav","vj_weapons/hl2_smg1/smg1_single2.wav","vj_weapons/hl2_smg1/smg1_single3.wav"}
SWEP.Primary.DistantSound		= {"Weapon_SMG1.NPC_Single"}
SWEP.PrimaryEffects_MuzzleAttachment = 1
SWEP.PrimaryEffects_ShellAttachment = 2
SWEP.PrimaryEffects_ShellType = "VJ_Weapon_PistolShell1"
	-- ====== Secondary Fire Variables ====== --
SWEP.Secondary.Automatic = true -- Is it automatic?
SWEP.Secondary.Ammo = "SMG1_Grenade" -- Ammo type
	-- Reload Settings ---------------------------------------------------------------------------------------------------------------------------------------------
SWEP.HasReloadSound = true -- Does it have a reload sound? Remember even if this is set to false, the animation sound will still play!
SWEP.ReloadSound = {"weapons/smg1/smg1_reload.wav"}
---------------------------------------------------------------------------------------------------------------------------------------------
function SWEP:CustomOnSecondaryAttack()
	local owner = self:GetOwner()
	owner:ViewPunch(Angle(-self.Primary.Recoil *3, 0, 0))
	VJ_EmitSound(self, "weapons/ar2/ar2_altfire.wav", 85)

	local proj = ents.Create(self.NPC_SecondaryFireEnt)
	proj:SetPos(owner:GetShootPos())
	proj:SetAngles(owner:GetAimVector():Angle())
	proj:SetOwner(owner)
	proj:Spawn()
	proj:Activate()
	local phys = proj:GetPhysicsObject()
	if IsValid(phys) then
		phys:Wake()
		phys:SetVelocity(owner:GetAimVector() * 2000)
	end
	return true
end
--PATH gamemodes/starwarsrp/entities/weapons/weaponchecker/shared.lua:
AddCSLuaFile()

if CLIENT then
    SWEP.Slot = 1
    SWEP.SlotPos = 9
    SWEP.DrawAmmo = false
    SWEP.DrawCrosshair = false
end

SWEP.Author = "DarkRP Developers"
SWEP.Instructions = "Left click to weapon check\nRight click to confiscate weapons\nReload to give back the weapons"
SWEP.Contact = ""
SWEP.Purpose = ""
SWEP.IsDarkRPWeaponChecker = true

SWEP.ViewModelFOV = 62
SWEP.ViewModelFlip = false
SWEP.AnimPrefix = "rpg"

SWEP.PrintName = "Weapon Checker"
SWEP.Spawnable = true
SWEP.AdminOnly = true
SWEP.Category = "DarkRP (Utility)"
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = 0
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = ""

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = 0
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = ""

SWEP.MinCheckTime = 5
SWEP.MaxCheckTime = 10

DarkRP.hookStub{
    name = "playerWeaponsChecked",
    description = "Called when a player with a weapon checker has checked another player's weapons. Note: Only called when the player looks at the weapons without confiscating. Please see playerWeaponsConfiscated for when weapons are actually confiscated.",
    parameters = {
        {
            name = "checker",
            description = "The player holding the weapon checker.",
            type = "Player"
        },
        {
            name = "target",
            description = "The player whose weapons have been checked.",
            type = "Player"
        },
        {
            name = "weapons",
            description = "The weapons that have been checked.",
            type = "table"
        },
    },
    returns = {},
    realm = "Shared"
}

DarkRP.hookStub{
    name = "playerWeaponsReturned",
    description = "Called when a player with a weapon checker has returned another player's weapons.",
    parameters = {
        {
            name = "checker",
            description = "The player holding the weapon checker.",
            type = "Player"
        },
        {
            name = "target",
            description = "The player whose weapons have been returned.",
            type = "Player"
        },
        {
            name = "weapons",
            description = "The weapons that have been returned.",
            type = "table"
        },
    },
    returns = {},
    realm = "Server"
}

DarkRP.hookStub{
    name = "playerWeaponsConfiscated",
    description = "Called when a player with a weapon checker has confiscated another player's weapons.",
    parameters = {
        {
            name = "checker",
            description = "The player holding the weapon checker.",
            type = "Player"
        },
        {
            name = "target",
            description = "The player whose weapons have been confiscated.",
            type = "Player"
        },
        {
            name = "weapons",
            description = "The weapons that have been confiscated.",
            type = "table"
        },
    },
    returns = {},
    realm = "Server"
}

function SWEP:SetupDataTables()
    self:NetworkVar("Bool", 0, "IsWeaponChecking")
    self:NetworkVar("Float", 0, "StartCheckTime")
    self:NetworkVar("Float", 1, "EndCheckTime")
    self:NetworkVar("Float", 2, "NextSoundTime")
    self:NetworkVar("Int", 0, "TotalWeaponChecks")
end

function SWEP:Initialize()
    self:SetHoldType("normal")
end

function SWEP:Deploy()
    return true
end

function SWEP:DrawWorldModel()
end

function SWEP:PreDrawViewModel(vm)
    return true
end

function SWEP:GetStrippableWeapons(ent, callback)
    CAMI.PlayerHasAccess(ent, "DarkRP_GetAdminWeapons", function(access)
        for _, v in ipairs(ent:GetWeapons()) do
            local class = v:GetClass()

            if GAMEMODE.Config.weaponCheckerHideDefault and (table.HasValue(GAMEMODE.Config.DefaultWeapons, class) or
                access and table.HasValue(GAMEMODE.Config.AdminWeapons, class) or
                ent:getJobTable() and ent:getJobTable().weapons and table.HasValue(ent:getJobTable().weapons, class)) then
                continue
            end

            if (GAMEMODE.Config.weaponCheckerHideNoLicense and GAMEMODE.NoLicense[class]) or GAMEMODE.Config.noStripWeapons[class] then continue end

            callback(v)
        end
    end)
end

function SWEP:PrimaryAttack()
    if self:GetIsWeaponChecking() then return end
    self:SetNextPrimaryFire(CurTime() + 0.3)

    local Owner = self:GetOwner()

    if not IsValid(Owner) then return end

    Owner:LagCompensation(true)
    local trace = Owner:GetEyeTrace()
    Owner:LagCompensation(false)

    local ent = trace.Entity
    if not IsValid(ent) or not ent:IsPlayer() or ent:GetPos():DistToSqr(Owner:GetPos()) > 10000 then
        return
    end

    self:EmitSound("npc/combine_soldier/gear5.wav", 50, 100)
    self:SetNextSoundTime(CurTime() + 0.3)

    if not IsFirstTimePredicted() then return end

    local weps = {}
    self:GetStrippableWeapons(ent, function(wep)
        table.insert(weps, wep)
    end)

    hook.Call("playerWeaponsChecked", nil, Owner, ent, weps)

    if not CLIENT then return end

    self:PrintWeapons(ent, DarkRP.getPhrase("persons_weapons", ent:Nick()))
end

function SWEP:SecondaryAttack()
    if self:GetIsWeaponChecking() then return end
    self:SetNextSecondaryFire(CurTime() + 0.3)

    local Owner = self:GetOwner()

    if not IsValid(Owner) then return end

    Owner:LagCompensation(true)
    local trace = Owner:GetEyeTrace()
    Owner:LagCompensation(false)

    local ent = trace.Entity
    if not IsValid(ent) or not ent:IsPlayer() or ent:GetPos():DistToSqr(Owner:GetPos()) > 10000 then
        return
    end

    self:SetIsWeaponChecking(true)
    self:SetStartCheckTime(CurTime())
    self:SetEndCheckTime(CurTime() + util.SharedRandom("DarkRP_WeaponChecker" .. self:EntIndex() .. "_" .. self:GetTotalWeaponChecks(), self.MinCheckTime, self.MaxCheckTime))
    self:SetTotalWeaponChecks(self:GetTotalWeaponChecks() + 1)

    self:SetNextSoundTime(CurTime() + 0.5)

    if CLIENT then
        self.Dots = ""
        self.NextDotsTime = CurTime() + 0.5
    end
end

function SWEP:Reload()
    if CLIENT or CurTime() < (self.NextReloadTime or 0) then return end
    self.NextReloadTime = CurTime() + 1

    local Owner = self:GetOwner()

    if not IsValid(Owner) then return end

    local trace = Owner:GetEyeTrace()

    local ent = trace.Entity
    if not IsValid(ent) or not ent:IsPlayer() or ent:GetPos():DistToSqr(Owner:GetPos()) > 10000 then
        return
    end

    if not ent.ConfiscatedWeapons then
        DarkRP.notify(Owner, 1, 4, DarkRP.getPhrase("no_weapons_confiscated", ent:Nick()))
        return
    else
        ent:RemoveAllAmmo()
        for _, v in pairs(ent.ConfiscatedWeapons) do
            local wep = ent:Give(v.class, true)

            -- :Give returns NULL when the player already has the weapon
            wep = IsValid(wep) and wep or ent:GetWeapon(v.class)
            if not IsValid(wep) then continue end

            ent:GiveAmmo(v.primaryAmmoCount, v.primaryAmmoType, true)
            ent:GiveAmmo(v.secondaryAmmoCount, v.secondaryAmmoType, true)

            wep:SetClip1(v.clip1)
            wep:SetClip2(v.clip2)

        end
        DarkRP.notify(Owner, 2, 4, DarkRP.getPhrase("returned_persons_weapons", ent:Nick()))

        hook.Call("playerWeaponsReturned", nil, Owner, ent, ent.ConfiscatedWeapons)
        ent.ConfiscatedWeapons = nil
    end
end

function SWEP:Holster()
    self:SetIsWeaponChecking(false)
    self:SetNextSoundTime(0)
    return true
end

function SWEP:Succeed()
    if not IsValid(self:GetOwner()) then return end
    self:SetIsWeaponChecking(false)

    local trace = self:GetOwner():GetEyeTrace()
    local ent = trace.Entity
    if not IsValid(ent) or not ent:IsPlayer() then return end

    if CLIENT then
        if not IsFirstTimePredicted() then return end
        self:PrintWeapons(ent, DarkRP.getPhrase("confiscated_these_weapons"))
        return
    end

    local stripped = {}

    self:GetStrippableWeapons(ent, function(wep)
        ent:StripWeapon(wep:GetClass())
        stripped[wep:GetClass()] = {
            class = wep:GetClass(),
            primaryAmmoCount = ent:GetAmmoCount(wep:GetPrimaryAmmoType()),
            primaryAmmoType = wep:GetPrimaryAmmoType(),
            secondaryAmmoCount = ent:GetAmmoCount(wep:GetSecondaryAmmoType()),
            secondaryAmmoType = wep:GetSecondaryAmmoType(),
            clip1 = wep:Clip1(),
            clip2 = wep:Clip2()
        }
    end)

    if not ent.ConfiscatedWeapons then
        if next(stripped) ~= nil then ent.ConfiscatedWeapons = stripped end
    else
        -- Merge stripped weapons into confiscated weapons
        for k,v in pairs(stripped) do
            if ent.ConfiscatedWeapons[k] then continue end

            ent.ConfiscatedWeapons[k] = v
        end
    end

    hook.Call("playerWeaponsConfiscated", nil, self:GetOwner(), ent, ent.ConfiscatedWeapons)

    if next(stripped) ~= nil then
        self:EmitSound("npc/combine_soldier/gear5.wav", 50, 100)
        self:SetNextSoundTime(CurTime() + 0.3)
    else
        self:EmitSound("ambient/energy/zap1.wav", 50, 100)
        self:SetNextSoundTime(0)
    end
end

function SWEP:PrintWeapons(ent, weaponsFoundPhrase)
    local Owner = self:GetOwner()

    if not IsValid(Owner) then return end

    local result = {}
    local weps = {}
    self:GetStrippableWeapons(ent, function(wep)
        table.insert(weps, wep)
    end)

    for _, wep in ipairs(weps) do
        table.insert(result, wep:GetPrintName() and language.GetPhrase(wep:GetPrintName()) or wep:GetClass())
    end

    result = table.concat(result, ", ")

    if result == "" then
        Owner:ChatPrint(DarkRP.getPhrase("no_illegal_weapons", ent:Nick()))
        return
    end

    Owner:ChatPrint(weaponsFoundPhrase)
    if string.len(result) >= 126 then
        local amount = math.ceil(string.len(result) / 126)
        for i = 1, amount, 1 do
            Owner:ChatPrint(string.sub(result, (i-1) * 126, i * 126 - 1))
        end
    else
        Owner:ChatPrint(result)
    end
end

function SWEP:Fail()
    self:SetIsWeaponChecking(false)
    self:SetHoldType("normal")
    self:SetNextSoundTime(0)
end

function SWEP:Think()
    local Owner = self:GetOwner()

    if not IsValid(Owner) then return end

    if self:GetIsWeaponChecking() and self:GetEndCheckTime() ~= 0 then
        Owner:LagCompensation(true)
        local trace = Owner:GetEyeTrace()
        Owner:LagCompensation(false)
        if not IsValid(trace.Entity) or trace.HitPos:DistToSqr(Owner:GetShootPos()) > 10000 or not trace.Entity:IsPlayer() then
            self:Fail()
        end
        if self:GetEndCheckTime() <= CurTime() then
            self:Succeed()
        end
    end
    if self:GetNextSoundTime() ~= 0 and CurTime() >= self:GetNextSoundTime() then
        if self:GetIsWeaponChecking() then
            self:SetNextSoundTime(CurTime() + 0.5)
            self:EmitSound("npc/combine_soldier/gear5.wav", 100, 100)
        else
            self:SetNextSoundTime(0)
            self:EmitSound("npc/combine_soldier/gear5.wav", 50, 100)
        end
    end
    if CLIENT and self.NextDotsTime and CurTime() >= self.NextDotsTime then
        self.NextDotsTime = CurTime() + 0.5
        self.Dots = self.Dots or ""
        local len = string.len(self.Dots)
        local dots = {
            [0] = ".",
            [1] = "..",
            [2] = "...",
            [3] = ""
        }
        self.Dots = dots[len]
    end
end

local colorBackground = Color(10, 10, 10, 120)

function SWEP:DrawHUD()
    if self:GetIsWeaponChecking() and self:GetEndCheckTime() ~= 0 then
        self.Dots = self.Dots or ""
        local w = ScrW()
        local h = ScrH()
        local x, y, width, height = w / 2 - w / 10, h / 2, w / 5, h / 15
        local time = self:GetEndCheckTime() - self:GetStartCheckTime()
        local curtime = CurTime() - self:GetStartCheckTime()
        local status = math.Clamp(curtime / time, 0, 1)
        local BarWidth = status * (width - 16)
        local cornerRadius = math.Min(8, BarWidth / 3 * 2 - BarWidth / 3 * 2 % 2)

        draw.RoundedBox(8, x, y, width, height, colorBackground)
        draw.RoundedBox(cornerRadius, x + 8, y + 8, BarWidth, height - 16, Color(0, 0 + (status * 255), 255 - (status * 255), 255))
        draw.DrawNonParsedSimpleText(DarkRP.getPhrase("checking_weapons") .. self.Dots, "Trebuchet24", w / 2, y + height / 2, color_white, 1, 1)
    end
end

--PATH lua/entities/arccw_ammo.lua:
return gluapack()()
--PATH lua/entities/arccw_ammo_buckshot_large.lua:
return gluapack()()
--PATH lua/entities/arccw_ammo_buckshot_large.lua:
AddCSLuaFile()

ENT.Base                      = "arccw_ammo"

ENT.PrintName                 = "Shotgun Ammo (Large)"
ENT.Category                  = "ArcCW - Ammo"

ENT.Spawnable                 = true
ENT.Model                     = "models/items/arccw/shotgun_ammo_closed.mdl"
ENT.Scale = 1.5

ENT.AmmoType = "buckshot"
ENT.AmmoCount = 100

ENT.DetonationDamage = 80
ENT.DetonationRadius = 128
ENT.DetonationSound = "weapons/shotgun/shotgun_fire6.wav"
--PATH lua/entities/arccw_ammo_smg1_grenade.lua:
return gluapack()()
--PATH lua/entities/arccw_ammo_smg1_grenade.lua:
AddCSLuaFile()

ENT.Base                      = "arccw_ammo"

ENT.PrintName                 = "Rifle Grenade"
ENT.Category                  = "ArcCW - Ammo"

ENT.Spawnable                 = true
ENT.Model                     = "models/Items/AR2_Grenade.mdl"
ENT.Health = 15

ENT.AmmoType = "smg1_grenade"
ENT.AmmoCount = 1

ENT.DetonationDamage = 50 -- Per-round damage
ENT.DetonationRadius = 300

function ENT:DetonateRound(attacker)
    local nade = ents.Create("arccw_gl_ammodet")
    nade:SetPos(self:GetPos())
    nade:SetAngles(self:GetAngles() + AngleRand(-10, 10))
    nade:Spawn()
    nade:GetPhysicsObject():AddVelocity(self:GetVelocity() + self:GetForward() * math.random(500, 2000))
    nade:SetOwner(attacker or self.Burner)
    self:Remove()
end

function ENT:Detonate(wet, attacker)
    if wet then
        self:DetonateRound(attacker)
    else
        local e = EffectData()
        e:SetOrigin(self:GetPos())
        util.Effect("Explosion", e)

        util.BlastDamage(self, attacker, self:GetPos(), self.DetonationRadius, self.DetonationDamage)
        self:Remove()
    end
end
--PATH lua/entities/arccw_ammo_sniper.lua:
AddCSLuaFile()

ENT.Base                      = "arccw_ammo"

ENT.PrintName                 = "Sniper Ammo"
ENT.Category                  = "ArcCW - Ammo"

ENT.Spawnable                 = true
ENT.Model                     = "models/items/arccw/sniper_ammo.mdl"

ENT.AmmoType = "SniperPenetratedRound"
ENT.AmmoCount = 10
ENT.MaxHealth = 20
if engine.ActiveGamemode() == "terrortown" then
    ENT.AmmoType = "357"
end

ENT.DetonationDamage = 80
ENT.DetonationRadius = 128
ENT.DetonationSound = "npc/sniper/echo1.wav"
--PATH lua/entities/arccw_att_dropped.lua:
return gluapack()()
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/entities/arccw_fire_ubgl.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1.3/lua/entities/arccw_k_proj_base.lua:
return gluapack()()
--PATH lua/entities/arccw_smoke/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_entity"
ENT.PrintName = "Smoke Cloud"
ENT.Author = ""
ENT.Information = ""
ENT.Spawnable = false
ENT.AdminSpawnable = false

local smokeimages = {"particle/smokesprites_0002", "particle/smokesprites_0003", "particle/smokesprites_0004", "particle/smokesprites_0005", "particle/smokesprites_0006", "particle/smokesprites_0007", "particle/smokesprites_0008", "particle/smokesprites_0009", "particle/smokesprites_0010", "particle/smokesprites_0011", "particle/smokesprites_0012", "particle/smokesprites_0013", "particle/smokesprites_0014", "particle/smokesprites_0015", "particle/smokesprites_0016"}

local function GetSmokeImage()
    return smokeimages[math.random(#smokeimages)]
end

ENT.Particles = nil
ENT.SmokeRadius = 256
ENT.SmokeColor = Color(150, 150, 150)
ENT.BillowTime = 1
ENT.Life = 15

ENT.ArcCWSmoke = true

AddCSLuaFile()

function ENT:Initialize()
    if SERVER then
        self:SetModel( "models/weapons/w_eq_smokegrenade_thrown.mdl" )
        self:SetMoveType( MOVETYPE_NONE )
        self:SetSolid( SOLID_NONE )
        self:DrawShadow( false )
    else
        local emitter = ParticleEmitter(self:GetPos())

        self.Particles = {}

        local amt = 20

        for i = 1, amt do
            local smoke = emitter:Add(GetSmokeImage(), self:GetPos())
            smoke:SetVelocity( VectorRand() * 8 + (Angle(0, i * (360 / amt), 0):Forward() * 400) )
            smoke:SetStartAlpha( 0 )
            smoke:SetEndAlpha( 255 )
            smoke:SetStartSize( 0 )
            smoke:SetEndSize( self.SmokeRadius )
            smoke:SetRoll( math.Rand(-180, 180) )
            smoke:SetRollDelta( math.Rand(-0.2,0.2) )
            smoke:SetColor( self.SmokeColor.r, self.SmokeColor.g, self.SmokeColor.b )
            smoke:SetAirResistance( 75 )
            smoke:SetPos( self:GetPos() )
            smoke:SetCollide( true )
            smoke:SetBounce( 0.2 )
            smoke:SetLighting( false )
            smoke:SetNextThink( CurTime() + FrameTime() )
            smoke.bt = CurTime() + self.BillowTime
            smoke.dt = CurTime() + self.BillowTime + self.Life
            smoke.ft = CurTime() + self.BillowTime + self.Life + math.Rand(2.5, 5)
            smoke:SetDieTime(smoke.ft)
            smoke.life = self.Life
            smoke.billowed = false
            smoke.radius = self.SmokeRadius
            smoke:SetThinkFunction( function(pa)
                if !pa then return end

                local prog = 1
                local alph = 0

                if pa.ft < CurTime() then
                    return
                elseif pa.dt < CurTime() then
                    local d = (CurTime() - pa.dt) / (pa.ft - pa.dt)

                    alph = 1 - d
                elseif pa.bt < CurTime() then
                    alph = 1
                else
                    local d = math.Clamp(pa:GetLifeTime() / (pa.bt - CurTime()), 0, 1)

                    prog = (-d ^ 2) + (2 * d)

                    alph = d
                end

                pa:SetEndSize( pa.radius * prog )
                pa:SetStartSize( pa.radius * prog )

                pa:SetStartAlpha(255 * alph)
                pa:SetEndAlpha(255 * alph)

                pa:SetNextThink( CurTime() + FrameTime() )
            end )

            table.insert(self.Particles, smoke)
        end

        emitter:Finish()
    end

    self.dt = CurTime() + self.Life + self.BillowTime
end

function ENT:Think()

    if SERVER then
        local targets = ents.FindInSphere(self:GetPos(), 256)
        for _, k in pairs(targets) do
            if k:IsNPC() then
                k:SetSchedule(SCHED_STANDOFF)
            end
        end
    end

    if self.dt < CurTime() then
        if SERVER then
            SafeRemoveEntity(self)
        end
    end
end

function ENT:Draw()
    return false
end
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/entities/arccw_ubgl_nade.lua:
AddCSLuaFile()
ENT.Type = "anim"
ENT.Base = "base_entity"
ENT.PrintName = "Base Rifle Grenade"
ENT.Author = ""
ENT.Information = ""
ENT.Spawnable = false

ENT.Ticks = 0
ENT.CollisionGroup = COLLISION_GROUP_PROJECTILE

-- Intentionally not ENT.Damage since ArcCW base overwrites it with weapon damage (for some reason)
ENT.GrenadeDamage = false
ENT.GrenadeRadius = 0
ENT.FuseTime = 10
ENT.DragCoefficient = 1
ENT.DetonateOnImpact = true

ENT.Model = "models/items/ar2_grenade.mdl"
ENT.ExplosionEffect = true
ENT.Scorch = "Scorch"
ENT.SmokeTrail = true

local path = "arccw/rep_ubgl/"
local path1 = "arccw/rep_ubgl/"
ENT.ExplosionSounds = {path .. "explosion-close-01.ogg", path .. "explosion-close-02.ogg"}
ENT.DebrisSounds = {path1 .. "debris-01.ogg", path1 .. "debris-02.ogg", path1 .. "debris-03.ogg", path1 .. "debris-04.ogg", path1 .. "debris-05.ogg"}

if SERVER then
    function ENT:Initialize()
        local pb_vert = 1
        local pb_hor = 1
        self:SetModel(self.Model)
        self:PhysicsInitBox(Vector(-pb_vert, -pb_hor, -pb_hor), Vector(pb_vert, pb_hor, pb_hor))
        local phys = self:GetPhysicsObject()

        if phys:IsValid() then
            phys:Wake()
            phys:SetDragCoefficient(self.DragCoefficient)
            phys:SetBuoyancyRatio(0.1)
        end

        self.SpawnTime = CurTime()
    end

    function ENT:Think()
        if SERVER and CurTime() - self.SpawnTime >= self.FuseTime then
            self:Detonate()
        end
    end
else
    function ENT:Think()
        if self.SmokeTrail then
            if self.Ticks % 5 == 0 then
                local emitter = ParticleEmitter(self:GetPos())
                if not self:IsValid() or self:WaterLevel() > 2 then return end
                if not IsValid(emitter) then return end
                local smoke = emitter:Add("particle/particle_smokegrenade", self:GetPos())
                smoke:SetVelocity(VectorRand() * 25)
                smoke:SetGravity(Vector(math.Rand(-5, 5), math.Rand(-5, 5), math.Rand(-20, -25)))
                smoke:SetDieTime(math.Rand(1.5, 2.0))
                smoke:SetStartAlpha(255)
                smoke:SetEndAlpha(0)
                smoke:SetStartSize(0)
                smoke:SetEndSize(100)
                smoke:SetRoll(math.Rand(-180, 180))
                smoke:SetRollDelta(math.Rand(-0.2, 0.2))
                smoke:SetColor(20, 20, 20)
                smoke:SetAirResistance(5)
                smoke:SetPos(self:GetPos())
                smoke:SetLighting(false)
                emitter:Finish()
            end
            self.Ticks = self.Ticks + 1
        end
    end
end

-- overwrite to do special explosion things
function ENT:DoDetonation()
    local attacker = IsValid(self:GetOwner()) and self:GetOwner() or self
    util.BlastDamage(self, attacker, self:GetPos(), self.GrenadeRadius, self.GrenadeDamage or self.Damage or 0)
end

function ENT:DoImpact(ent)
    local attacker = IsValid(self:GetOwner()) and self:GetOwner() or self
    local dmg = DamageInfo()
    dmg:SetAttacker(attacker)
    dmg:SetInflictor(self)
    dmg:SetDamage(100)
    dmg:SetDamageType(DMG_CRUSH)
    dmg:SetDamageForce(self.GrenadeDir * 5000)
    dmg:SetDamagePosition(self:GetPos())
    ent:TakeDamageInfo(dmg)
end

function ENT:Detonate()
    if not self:IsValid() or self.BOOM then return end
    self.BOOM = true

    if self.ExplosionEffect then
        local effectdata = EffectData()
        effectdata:SetOrigin(self:GetPos())

        if self:WaterLevel() >= 1 then
            util.Effect("WaterSurfaceExplosion", effectdata)
            self:EmitSound("weapons/underwater_explode3.wav", 125, 100, 1, CHAN_AUTO)
        else
            -- util.Effect("Explosion", effectdata)

            -- explosion_HE_m79_fas2
            -- explosion_he_grenade_fas2
            -- explosion_HE_claymore_fas2
            -- explosion_grenade_fas2

            self:EmitSound(self.ExplosionSounds[math.random(1,#self.ExplosionSounds)], 125, 100, 1, CHAN_AUTO)
            ParticleEffect("explosion_HE_m79_fas2", self:GetPos(), Angle(-90, 0, 0))

            --self:EmitSound("phx/kaboom.wav", 125, 100, 1, CHAN_AUTO)

            -- Where is the sound zenith ? ???
        end

        util.ScreenShake(self:GetPos(), 25, 4, 0.75, self.GrenadeRadius * 4)

        if self.GrenadePos == nil then
            self.GrenadePos = self:GetPos()
        end
        if self.GrenadeDir == nil then
            self.GrenadeDir = self:GetVelocity():GetNormalized()
        end

        local trace = util.TraceLine({
            start = self.GrenadePos,
            endpos = self.GrenadePos + self.GrenadeDir * 4,
            mask = MASK_SOLID_BRUSHONLY
        })
        if trace.Hit then
            self:EmitSound(self.DebrisSounds[math.random(1,#self.DebrisSounds)], 85, 100, 1, CHAN_AUTO)
        end
    end

    self:DoDetonation()

    if self.Scorch then
        util.Decal(self.Scorch, self.GrenadePos, self.GrenadePos + self.GrenadeDir * 4, self)
    end

    self:Remove()
end

function ENT:PhysicsCollide(colData, collider)
    self.GrenadeDir = colData.OurOldVelocity:GetNormalized()
    self.GrenadePos = colData.HitPos

    self:DoImpact(colData.HitEntity)

    if self.DetonateOnImpact then
        self:Detonate()
    else
        local effectdata = EffectData()
        effectdata:SetOrigin(self:GetPos())
        effectdata:SetMagnitude(2)
        effectdata:SetScale(1)
        effectdata:SetRadius(2)
        effectdata:SetNormal(self.GrenadeDir)
        util.Effect("Sparks", effectdata)
        self:EmitSound("weapons/rpg/shotdown.wav", 100, 150)
        self:Remove()
    end
end


function ENT:Draw()
    self:DrawModel()
end
--PATH lua/entities/aura_hangar_console/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Hangar Console"
ENT.Category = "Aura's Hangars"

ENT.Spawnable = true
ENT.AdminSpawnable = true
--PATH lua/entities/aura_lvs_9799/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()
end
--PATH lua/entities/aura_lvs_aa-9_liner/cl_init.lua:
return gluapack()()
--PATH lua/entities/aura_lvs_bulwark/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()
end
--PATH lua/entities/aura_lvs_bulwark/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "CSI | Bulwark"
ENT.Category = "Aura's LVS Big Ships"

DEFINE_BASECLASS( "aura_lvs_capital_ship_base_mk2" )

ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Editable = true

ENT.Model 					= "models/salty/cis-bulwark-mk2.mdl"
ENT.AITEAM 					= 1

ENT.Mass 					= 700

ENT.HealthVal 				= 1000000
ENT.MaxHealth  				= ENT.HealthVal
ENT.SPAWNNUMBER				= 1
ENT.SPAWNDELAY				= 3
ENT.SHIPSPAWNPOS 			= {forward = -6000, right = 0, up = 1500}
ENT.ENABLETURRETS 			= false
ENT.SHOOTEFFECT 			= "lvs_capital_red_laser"
ENT.SHOOTSOUND				= Sound("weapons/corvette_fire.mp3")

ENT.PRIMARYDAMAGE			= 50
ENT.SHOOTDELAY1 			= 3
ENT.SEARCHSIZE				= 30000
ENT.LOSE_DIST 				= 31000
ENT.TURRETFORWARDSEARCH 	= 600

ENT.EXPLOSION_SCALE_MIN		= 4
ENT.EXPLOSION_SCALE_MAX		= 7


ENT.TURRETS = 
{
	[1] = Vector(-1000,2900,2550),
	[2] = Vector(-1000,-2900,2550),
	[3] = Vector(2700,0,400),
}

ENT.TURRETANGLES = 
{
	[1] = Angle(90,-90,180),
	[2] = Angle(90,90,180),
	[3] = Angle(180,0,0),
}

ENT.BOMBS = 
{
	{forward = -6000, right = 0, up = 1800},
	{forward = -6000, right = 0, up = 1800},
	{forward = -4000, right = 0, up = 1800},
	{forward = -2000, right = 0, up = 1600},
	{forward = 0, right = 0, up = 1800},
	{forward = 2000, right = 0, up = 1600},
	{forward = 4000, right = 0, up = 1400},
	{forward = 6000, right = 0, up = 1800},
	{forward = -2000, right = 0, up = 1600},
	{forward = -4000, right = 0, up = 1800},
	{forward = -6000, right = 0, up = 1800},
}
--PATH lua/entities/aura_lvs_cargo/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "NEU (team 0) | Cargo"
ENT.Category = "Aura's LVS Big Ships"

DEFINE_BASECLASS( "aura_lvs_capital_ship_base_mk2" )

ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Editable = true

ENT.Model 					= "models/jk3/acship_servius.mdl"
ENT.AITEAM 					= 0

ENT.Mass 					= 700

ENT.HealthVal 				= 30000
ENT.MaxHealth  				= ENT.HealthVal
ENT.SPAWNNUMBER				= 1
ENT.SPAWNDELAY				= 3

ENT.SHIPSPAWNPOS 			= {forward = 0, right = 0, up = -1000}
ENT.ENABLETURRETS 			= false
ENT.SHOOTEFFECT 			= "lvs_capital_blue_laser"
ENT.SHOOTSOUND				= Sound("weapons/corvette_fire.mp3")

ENT.PRIMARYDAMAGE			= 60
ENT.SHOOTDELAY1 			= 3
ENT.SEARCHSIZE				= 30000
ENT.LOSE_DIST 				= 31000
ENT.TURRETFORWARDSEARCH 	= 30600

ENT.EXPLOSION_SCALE_MIN		= 4
ENT.EXPLOSION_SCALE_MAX		= 8

ENT.TURRETS = 
{

}

ENT.TURRETANGLES = 
{

}

ENT.BOMBS = 
{
	{forward = 0, right = 0, up = 0},
	{forward = 700, right = 0, up = 0},
	{forward = 0, right = 0, up = 0},
	{forward = -300, right = 0, up = 0},
}
--PATH lua/entities/aura_lvs_cargo3/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()
end
--PATH lua/entities/aura_lvs_cargo5/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()
end
--PATH lua/entities/aura_lvs_cargo6/shared.lua:
return gluapack()()
--PATH lua/entities/aura_lvs_cargo7/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()
end
--PATH lua/entities/aura_lvs_core/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "CSI | Core Ship"
ENT.Category = "Aura's LVS Big Ships"

DEFINE_BASECLASS( "aura_lvs_capital_ship_base_mk2" )

ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Editable = true

ENT.Model 					= "models/salty/cis-core-ship.mdl"
ENT.AITEAM 					= 1

ENT.Mass 					= 700

ENT.HealthVal 				= 1000000
ENT.MaxHealth  				= ENT.HealthVal
ENT.SPAWNNUMBER				= 1
ENT.SPAWNDELAY				= 3
ENT.SHIPSPAWNPOS 			= {forward = 2000, right = 2300, up = 2800}
ENT.ENABLETURRETS 			= false
ENT.SHOOTEFFECT 			= "lvs_capital_red_laser"
ENT.SHOOTSOUND				= Sound("weapons/mega_turbolaser.mp3")

ENT.PRIMARYDAMAGE			= 50
ENT.SHOOTDELAY1 			= 3
ENT.SEARCHSIZE				= 30000
ENT.LOSE_DIST 				= 31000
ENT.TURRETFORWARDSEARCH 	= 600

ENT.EXPLOSION_SCALE_MIN		= 4
ENT.EXPLOSION_SCALE_MAX		= 7


ENT.TURRETS = 
{

}

ENT.TURRETANGLES = 
{

}

ENT.BOMBS = 
{
	{forward = -1000, right = 0, up = 1800},
	{forward = -400, right = -1000, up = 3800},
	{forward = -500, right = 1000, up = 3800},
	{forward = -700, right = -1000, up = 1800},
	{forward = -400, right = 1000, up = 4800},
	{forward = -600, right = -1000, up = 4600},
	{forward = -100, right = 1000, up = 1600},
	{forward = 0, right = -1000, up = 1800},
	{forward = 0, right = 1000, up = 3800},
	{forward = 100, right = -1000, up = 3600},
	{forward = 400, right = 1000, up = 1600},
	{forward = 600, right = -1000, up = 5400},
	{forward = 800, right = 1000, up = 5400},
	{forward = 1000, right = -1000, up = 1800},
	{forward = 1200, right = 1000, up = 3800},
	{forward = -400, right = 1000, up = 3800},
	{forward = -600, right = 1000, up = 1800},

}
--PATH lua/entities/aura_lvs_cr25/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()
end
--PATH lua/entities/aura_lvs_cr90_rep/cl_init.lua:
return gluapack()()
--PATH lua/entities/aura_lvs_diamond/cl_init.lua:
return gluapack()()
--PATH lua/entities/aura_lvs_hardcell/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "CSI | Hardcell"
ENT.Category = "Aura's LVS Big Ships"

DEFINE_BASECLASS( "aura_lvs_capital_ship_base_mk2" )

ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Editable = true

ENT.Model 					= "models/salty/hardcell-transport5.mdl"
ENT.AITEAM 					= 1

ENT.Mass 					= 700

ENT.HealthVal 				= 300000
ENT.MaxHealth  				= ENT.HealthVal
ENT.SPAWNNUMBER				= 1
ENT.SPAWNDELAY				= 3
ENT.SHIPSPAWNPOS 			= {forward = 0, right = 0, up = -10}
ENT.ENABLETURRETS 			= false
ENT.SHOOTEFFECT 			= "lvs_capital_red_laser"
ENT.SHOOTSOUND				= Sound("weapons/muni_fire.mp3")

ENT.PRIMARYDAMAGE			= 40
ENT.SHOOTDELAY1 			= 1
ENT.SEARCHSIZE				= 30000
ENT.LOSE_DIST 				= 31000
ENT.TURRETFORWARDSEARCH 	= 600

ENT.EXPLOSION_SCALE_MIN		= 4
ENT.EXPLOSION_SCALE_MAX		= 7


ENT.TURRETS = 
{

}

ENT.TURRETANGLES = 
{

}

ENT.BOMBS = 
{
	{forward = 0, right = 0, up = 1800},
	{forward = 0, right = 0, up = 3600},
	{forward = 0, right = 0, up = 1400},
	{forward = 0, right = 0, up = 4800},
	{forward = 0, right = 0, up = 1600},
	{forward = 0, right = 0, up = 400},
}
--PATH lua/entities/aura_lvs_pelta/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()
end
--PATH lua/entities/aura_lvs_satellite_csi_1/cl_init.lua:
return gluapack()()
--PATH lua/entities/aura_lvs_satellite_neu_1/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "NEU (Team 0) | Defense Satellite"
ENT.Category = "Aura's LVS Big Ships"

DEFINE_BASECLASS( "aura_lvs_capital_ship_base_mk2" )

ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Editable = true

ENT.Model 					= "models/fyu/cedi/misc/v4/satellite.mdl"
ENT.AITEAM 					= 0

ENT.Mass 					= 700

ENT.HealthVal 				= 10000
ENT.MaxHealth  				= ENT.HealthVal
ENT.SPAWNNUMBER				= 1
ENT.SPAWNDELAY				= 3

ENT.SHIPSPAWNPOS 			= {forward = 0, right = 0, up = -1000}
ENT.ENABLETURRETS 			= false
ENT.SHOOTEFFECT 			= "lvs_capital_red_laser"
ENT.SHOOTSOUND				= Sound("weapons/corvette_fire.mp3")

ENT.PRIMARYDAMAGE			= 60
ENT.SHOOTDELAY1 			= 1
ENT.SEARCHSIZE				= 30000
ENT.LOSE_DIST 				= 31000
ENT.TURRETFORWARDSEARCH 	= 30600

ENT.EXPLOSION_SCALE_MIN		= 4
ENT.EXPLOSION_SCALE_MAX		= 8

ENT.TURRETS = 
{
	[1] = Vector(0,0,332),
}

ENT.TURRETANGLES = 
{
	[1] = Angle(0,180,0),
}

ENT.BOMBS = 
{
	{forward = 0, right = 0, up = 0},
}
--PATH lua/entities/base_streamradio_gui.lua:
return gluapack()()
--PATH addons/[technik] darkrp-city-worker/lua/entities/cityworker_electric/cl_init.lua:
include( "shared.lua" )

function ENT:Initialize()
    self.emitter = ParticleEmitter( self:GetPos() )
    self.nextEmit = 0
end

function ENT:OnRemove()
    if IsValid( self.emitter ) then
        self.emitter:Finish()
    end
end

function ENT:Think()
    if CurTime() >= self.nextEmit then
        local sparks = EffectData()
		sparks:SetOrigin( self:GetPos() )
		sparks:SetNormal( self:GetAngles():Forward() )
		sparks:SetMagnitude( math.Rand( 1, 4 ) )
        sparks:SetEntity( self )
		--sparks:SetRadius( math.Rand( 3, 5 ) )
		util.Effect( "TeslaHitboxes", sparks, true, true )
        util.Effect( "ElectricSpark", sparks, true, true )

        self:EmitSound( "ambient/energy/spark"..math.random( 1, 6 )..".wav", 55 )

        self.nextEmit = CurTime() + math.Rand( 0.5, 2 )
    end
end
--PATH addons/[technik] darkrp-city-worker/lua/entities/cityworker_hydrant/shared.lua:
ENT.Type            = "anim"
ENT.Base            = "base_gmodentity"

ENT.PrintName       = "Fire Hydrant"
ENT.Category        = "City Worker"
ENT.Author          = "Silhouhat"
ENT.Contact 	    = "contact@silhouhat.com"

ENT.Spawnable   	= false

function ENT:SetupDataTables()
    self:NetworkVar( "Bool", 0, "Leaking" )
end
--PATH addons/[technik] darkrp-city-worker/lua/entities/cityworker_leak/shared.lua:
ENT.Type            = "anim"
ENT.Base            = "base_gmodentity"

ENT.PrintName       = "Leak"
ENT.Category        = "City Worker"
ENT.Author          = "Silhouhat"
ENT.Contact 	    = "contact@silhouhat.com"

ENT.Spawnable   	= false
--PATH gamemodes/starwarsrp/entities/entities/darkrp_billboard/cl_init.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/entities/entities/darkrp_tip_jar/cl_init.lua:
return gluapack()()
--PATH lua/entities/dc17m_at_rocket2/shared.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/entities/dioxis_spawned/shared.lua:
return gluapack()()
--PATH lua/entities/ent_fballoon/cl_init.lua:
return gluapack()()
--PATH lua/entities/ent_wballoon/cl_init.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/entities/entities/fadmin_motd/shared.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/entities/fire_spawned1/shared.lua:
return gluapack()()
--PATH lua/entities/flame.lua:
return gluapack()()
--PATH lua/entities/gmod_contr_spawner/cl_init.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/entities/entities/gunlab/shared.lua:
return gluapack()()
--PATH lua/entities/heart_turbolaser/shared.lua:
ENT.Type = "anim";
ENT.Base = "base_anim";
ENT.PrintName = "heart_turbolaser";
ENT.Author = "drunken hearted";

ENT.Spawnable = false;

function ENT:SetupDataTables()
	self:NetworkVar( "String", "0", "ColR" );
	self:NetworkVar( "String", "1", "ColG" );
	self:NetworkVar( "String", "2", "ColB" );

	self:NetworkVar("Float", "0", "Scale");
end

--PATH lua/entities/imp_speeder.lua:
return gluapack()()
--PATH lua/entities/intercom/shared.lua:
return gluapack()()
--PATH lua/entities/laat_detonator/cl_init.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/entities/entities/lab_base/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Lab"
ENT.Author = "DarkRP Developers"
ENT.Spawnable = false
ENT.CanSetPrice = true

-- These are variables that should be set in entities that base from this
ENT.model = ""
ENT.initialPrice = 0
ENT.labPhrase = ""
ENT.itemPhrase = ""
ENT.noIncome = false
ENT.camMul = -30
ENT.blastRadius = 200
ENT.blastDamage = 200

ENT.RenderGroup = RENDERGROUP_TRANSLUCENT

function ENT:initVars()
    -- Implement this to set the above variables
end

function ENT:SetupDataTables()
    self:NetworkVar("Int", 0, "price")
    self:NetworkVar("Entity", 1, "owning_ent")
end

--PATH gamemodes/starwarsrp/entities/entities/letter/shared.lua:
return gluapack()()
--PATH lua/entities/lvs_armor_bounce.lua:
AddCSLuaFile()

ENT.Type            = "anim"

ENT.PrintName = "88mm Round"
ENT.Author = "Luna"
ENT.Information = "Luna's Vehicle Script"
ENT.Category = "[LVS] - Cars - Items"

ENT.Spawnable		= false
ENT.AdminOnly		= false

ENT.LifeTime = 10

if SERVER then
	function ENT:Initialize()
		self:SetModel( "models/misc/88mm_projectile.mdl" )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:PhysicsInit( SOLID_VPHYSICS)

		self.DieTime = CurTime() + self.LifeTime

		self:SetCollisionGroup( COLLISION_GROUP_WORLD )
	end

	function ENT:Think()
		if self.MarkForRemove then self:Remove() return false end

		self:NextThink( CurTime() + 0.1 )

		if (self.DieTime or 0) > CurTime() then return true end

		self:Remove()

		return false
	end

	
	function ENT:PhysicsCollide( data, physobj )
		self.MarkForRemove = true

		local effectdata = EffectData()
		effectdata:SetOrigin( data.HitPos )
		effectdata:SetNormal( -data.HitNormal )
		effectdata:SetMagnitude( 0.5 )
		util.Effect( "lvs_bullet_impact", effectdata )
	end

	return
end

ENT.MatSmoke = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function ENT:Initialize()
	self.DieTime = CurTime() + self.LifeTime

	self.emitter = ParticleEmitter( self:GetPos(), false )
end

function ENT:Smoke()
	local T = CurTime()

	if (self.DieTime or 0) < T then return end

	if not IsValid( self.emitter ) then return end

	if (self.NextFX or 0) < T then
		self.NextFX = T + 0.02

		local Timed = 1 - (self.DieTime - T) / self.LifeTime
		local Scale = math.max(math.min(2 - Timed * 2,1),0)

		local Pos = self:GetPos() 

		local particle = self.emitter:Add( self.MatSmoke[math.random(1,#self.MatSmoke)], Pos )

		local VecCol = (render.GetLightColor( Pos ) * 0.8 + Vector(0.2,0.2,0.2)) * 255

		if particle then
			particle:SetVelocity( VectorRand() * 10 )
			particle:SetDieTime( math.Rand(0.5,1) )
			particle:SetAirResistance( 100 ) 
			particle:SetStartAlpha( 100 * Scale )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( 10 )
			particle:SetEndSize( 20 )
			particle:SetRollDelta( 1 )
			particle:SetColor( VecCol.r, VecCol.g, VecCol.b )
			particle:SetGravity( Vector( 0, 0, 200 ) )
			particle:SetCollide( false )
		end
	end
end

function ENT:Think()
	self:Smoke()
end

function ENT:OnRemove()
	if not self.emitter then return end

	self.emitter:Finish()
end

function ENT:Draw()
	self:DrawModel()
end

--PATH lua/entities/lvs_av7/shared.lua:
return gluapack()()
--PATH lua/entities/lvs_base/cl_init.lua:
return gluapack()()
--PATH lua/entities/lvs_base_starfighter/cl_hud.lua:
return gluapack()()
--PATH lua/entities/lvs_base_turret/shared.lua:
return gluapack()()
--PATH lua/entities/lvs_base_turret/sh_camera_eyetrace.lua:

function ENT:GetEyeTrace( trace_forward )
	local startpos = self:LocalToWorld( self:OBBCenter() )

	local pod = self:GetDriverSeat()

	if IsValid( pod ) then
		startpos = pod:LocalToWorld( pod:OBBCenter() )
	end

	local AimVector = trace_forward and self:GetForward() or self:GetAimVector()

	local data = {
		start = startpos,
		endpos = (startpos + AimVector * 50000),
		filter = self:GetCrosshairFilterEnts(),
	}

	local trace = util.TraceLine( data )

	return trace
end

function ENT:GetAimVector()
	if self:GetAI() then
		return self:GetAIAimVector()
	end

	local Driver = self:GetDriver()

	if not IsValid( Driver ) then return self:GetForward() end

	if not Driver:lvsMouseAim() then
		if Driver:lvsKeyDown( "FREELOOK" ) then
			local pod = self:GetDriverSeat()

			if not IsValid( pod ) then return Driver:EyeAngles():Forward() end

			if pod:GetThirdPersonMode() then
				return -self:GetForward()
			else
				return Driver:GetAimVector()
			end
		else
			return self:GetForward()
		end
	end

	if SERVER then
		local pod = self:GetDriverSeat()

		if not IsValid( pod ) then return Driver:EyeAngles():Forward() end

		return pod:WorldToLocalAngles( Driver:EyeAngles() ):Forward()
	else
		return Driver:EyeAngles():Forward()
	end
end

--PATH lua/entities/lvs_dwarfdroid/cl_camera.lua:
return gluapack()()
--PATH addons/[tfres] lego vechicles/lua/entities/lvs_eta_advanced_lego/shared.lua:

ENT.Base = "lvs_base_starfighter"

ENT.PrintName = "ETA Lego"
ENT.Author = "Dec/frestylek"
ENT.Information = "Starfighter of the Galactic Republic"
ENT.Category = "[LVS] LEGO"

ENT.VehicleCategory = "Star Wars"
ENT.VehicleSubCategory = "Starfighters"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/lego/lego_jedi_interceptor.mdl"
ENT.GibModels = {
	"models/lego/lego_jedi_interceptor_gib1.mdl",
	"models/lego/lego_jedi_interceptor_gib2_r.mdl",
	"models/lego/lego_jedi_interceptor_gib1.mdl",
}

ENT.TurnRatePitch = 1.5
ENT.TurnRateYaw = 1.5
ENT.TurnRateRoll = 1.5


ENT.AITEAM = 2

ENT.MaxHealth = 1000
ENT.MaxShield = 600

ENT.MaxVelocity = 2850
ENT.MaxThrust = 2850

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3


ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.FlyByAdvance = 0.6
ENT.FlyBySound = "lvs/vehicles/vwing/flyby.wav" 
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

function ENT:OnSetupDataTables()
	self:AddDT( "Bool", "Foils" )
end

function ENT:InitWeapons()
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/mg.png")
	weapon.Ammo = 3000
	weapon.Delay = 0.07
	weapon.HeatRateUp = 0.25
	weapon.HeatRateDown = 0.7
	weapon.Attack = function( ent )

		if not ent:GetFoils() then
			ent:SetHeat(ent:GetHeat() + 0.6 )
		end

		local pod = ent:GetDriverSeat()
		if not IsValid( pod ) then return end

		local fP = {Vector(40,68,-13.5),Vector(40,-68,-23.5),Vector(40,68,-13.5),Vector(40,-68,-23.5)}

		self.NumPrim = self.NumPrim and self.NumPrim + 1 or 1
		if self.NumPrim > 4 then self.NumPrim = 1 end

		local Driver = self:GetDriver()

		local bullet = {}
		bullet.Src 	= ent:LocalToWorld(fP[self.NumPrim])
		bullet.Dir 	= self:GetForward()
		bullet.Spread 	= Vector( 0.025,  0.025, 0 )
		bullet.TracerName = "lvs_laser_green"
		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 80
		bullet.Velocity = 60000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(50,255,50) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_impact", effectdata )
		end
		ent:LVSFireBullet( bullet )

		local effectdata = EffectData()
		effectdata:SetStart( Vector(50,255,50) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( ent:GetForward() )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )

		ent:TakeAmmo()

		self:EmitSound( "VANILLA_VWING_FIRE" )
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")

		if ent.SetFoils then ent:SetFoils( true ) end
	end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )



	local weapon = {}
	weapon.Icon = Material("lvs/weapons/protontorpedo.png")
	weapon.Ammo = 3
	weapon.Delay = 0 -- this will turn weapon.Attack to a somewhat think function
	weapon.HeatRateUp = -0.5 -- cool down when attack key is held. This system fires on key-release.
	weapon.HeatRateDown = 0.25
	weapon.Attack = function( ent )

		if not ent:GetFoils() then
			ent:SetHeat( ent:GetHeat() + 1 )
		end
		local T = CurTime()

		if IsValid( ent._ProtonTorpedo ) then
			if (ent._nextMissleTracking or 0) > T then return end

			ent._nextMissleTracking = T + 0.1 -- 0.1 second interval because those find functions can be expensive

			ent._ProtonTorpedo:FindTarget( ent:GetPos(), ent:GetForward(), 30, 7500 )

			return
		end

		local T = CurTime()

		if (ent._nextMissle or 0) > T then return end

		ent._nextMissle = T + 0.5

		local Driver = self:GetDriver()

		local fP = {Vector(40,68,-13.5),Vector(40,-68,-23.5),Vector(40,68,-13.5),Vector(40,-68,-23.5)}

		self.NumPrim = self.NumPrim and self.NumPrim + 1 or 1
		if self.NumPrim > 4 then self.NumPrim = 1 end

		local projectile = ents.Create( "lvs_concussionmissile" )
		projectile:SetPos( self:LocalToWorld(fP[self.NumPrim]) )
		projectile:SetAngles( ent:GetAngles() )
		projectile:SetParent( ent )
		projectile:Spawn()
		projectile:SetDamage(1200)
		projectile:Activate()
		projectile:SetAttacker( IsValid( Driver ) and Driver or self )
		projectile:SetEntityFilter( ent:GetCrosshairFilterEnts() )

		ent._ProtonTorpedo = projectile

		ent:SetNextAttack( CurTime() + 0.1 ) -- wait 0.1 second before starting to track
	end
	weapon.FinishAttack = function( ent )
		if not IsValid( ent._ProtonTorpedo ) then return end

		local projectile = ent._ProtonTorpedo

		projectile:Enable()
		projectile:EmitSound( "lvs/vehicles/vulturedroid/fire_missile.mp3", 125 )
		ent:TakeAmmo()

		ent._ProtonTorpedo = nil

		local NewHeat = ent:GetHeat() + 0.75

		ent:SetHeat( NewHeat )
		if NewHeat >= 1 then
			ent:SetOverheated( true )
		end
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )
	
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/nos.png")
	weapon.HeatRateUp = 0.1
	weapon.HeatRateDown = 0.1
	weapon.UseableByAI = false
	weapon.Attack = function( ent )
		if ent:GetFoils() == false then return end
		local PhysObj = ent:GetPhysicsObject()
		if not IsValid( PhysObj ) then return end
		local THR = ent:GetThrottle()
		local FT = FrameTime()

		local Vel = ent:GetVelocity():Length()

		PhysObj:ApplyForceCenter( ent:GetForward() * math.Clamp(ent.MaxVelocity + 500 - Vel,0,1) * PhysObj:GetMass() * THR * FT * 150 ) -- increase speed
		PhysObj:AddAngleVelocity( PhysObj:GetAngleVelocity() * FT * 0.5 * THR ) -- increase turn rate
	end
	weapon.StartAttack = function( ent )
		ent.TargetThrottle = 1.3
		ent:EmitSound("lvs/vehicles/generic/boost.wav")
	end
	weapon.FinishAttack = function( ent )
		ent.TargetThrottle = 1
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("buttons/lever5.wav")
	end
	weapon.OnThink = function( ent, active )
		
		if not ent.TargetThrottle then return end

		local Rate = FrameTime() * 0.5

		ent:SetMaxThrottle( ent:GetMaxThrottle() + math.Clamp(ent.TargetThrottle - ent:GetMaxThrottle(),-Rate,Rate) )

		local MaxThrottle = ent:GetMaxThrottle()

		ent:SetThrottle( MaxThrottle )

		if MaxThrottle == ent.TargetThrottle then
			ent.TargetThrottle = nil
		end
	end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat_boost.wav") end

	self:AddWeapon( weapon )
end



ENT.EngineSounds = {
	{
		sound = "VANILLA_VWING_ENGINE",
		sound_int = "lvs/vehicles/vwing/loop_interior.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 90,
	},
	{
		sound = "VANILLA_VWING_HUM",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 90,
	},
}

sound.Add( {
	name = "VANILLA_VWING_ENGINE",
	channel = CHAN_STATIC,
	volume = 1.0,
	level = 125,
	sound = "vanilla/vwing/vanilla_vwing_engine.wav"
} )

sound.Add( {
	name = "VANILLA_VWING_HUM",
	channel = CHAN_STATIC,
	volume = 1.0,
	level = 125,
	sound = "vanilla/vwing/vanilla_vwing_hum.wav"
} )

sound.Add( {
	name = "VANILLA_VWING_FIRE",
	channel = CHAN_WEAPON,
	volume = 0.8,
	level = 125,
	pitch = {95, 98},
	sound = "vanilla/vwing/vanilla_vwing_fire.wav"
} )
--PATH lua/entities/lvs_fakehover_aat/sh_turret.lua:
return gluapack()()
--PATH lua/entities/lvs_item_ammocrate.lua:
AddCSLuaFile()

ENT.Type            = "anim"

ENT.PrintName = "Ammo Crate"
ENT.Information = "Single-Use Ammo Refil Item"
ENT.Author = "Luna"
ENT.Category = "[LVS]"

ENT.Spawnable		= true
ENT.AdminOnly		= false

if SERVER then
	function ENT:SpawnFunction( ply, tr, ClassName )
		if not tr.Hit then return end

		local ent = ents.Create( ClassName )
		ent:SetPos( tr.HitPos + tr.HitNormal * 5 )
		ent:Spawn()
		ent:Activate()

		return ent
	end

	function ENT:Initialize()	
		self:SetModel( "models/items/item_item_crate.mdl" )
		self:PhysicsInit( SOLID_VPHYSICS )
		self:PhysWake()
	end

	function ENT:Think()
		return false
	end

	function ENT:Refil( entity )
		if self.MarkForRemove then return end

		if not IsValid( entity ) then return end

		if not entity.LVS then return end

		if entity:WeaponRestoreAmmo() then
			entity:EmitSound("items/ammo_pickup.wav")

			self.MarkForRemove = true

			SafeRemoveEntityDelayed( self, 0 )
		end
	end

	function ENT:PhysicsCollide( data, physobj )
		self:Refil( data.HitEntity )
	end

	function ENT:OnTakeDamage( dmginfo )
	end
end

if CLIENT then
	function ENT:Draw( flags )
		self:DrawModel( flags )
	end

	function ENT:OnRemove()
	end

	function ENT:Think()
	end
end

--PATH lua/entities/lvs_pro/cl_init.lua:
return gluapack()()
--PATH lua/entities/lvs_repulsorlift_dropship/shared.lua:

ENT.Base = "lvs_base_repulsorlift"

ENT.PrintName = "LAAT/c"
ENT.Author = "Luna"
ENT.Information = "Tank Carrier of the Galactic Republic"
ENT.Category = "[LVS] - Star Wars"

ENT.VehicleCategory = "Star Wars"
ENT.VehicleSubCategory = "Gunships"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/blu/laat_c.mdl"
ENT.GibModels = {
	"models/gibs/helicopter_brokenpiece_01.mdl",
	"models/gibs/helicopter_brokenpiece_02.mdl",
	"models/gibs/helicopter_brokenpiece_03.mdl",
	"models/combine_apc_destroyed_gib02.mdl",
	"models/combine_apc_destroyed_gib04.mdl",
	"models/combine_apc_destroyed_gib05.mdl",
	"models/props_c17/trappropeller_engine.mdl",
	"models/gibs/airboat_broken_engine.mdl",
}

ENT.AITEAM = 2

ENT.MaxVelocity = 2400
ENT.MaxThrust = 2400

ENT.MaxPitch = 40

ENT.ThrustVtol = 50
ENT.ThrustRateVtol = 2

ENT.TurnRatePitch = 0.7
ENT.TurnRateYaw = 0.7
ENT.TurnRateRoll = 0.7

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 4000

ENT.AutomaticFrameAdvance = true

function ENT:OnSetupDataTables()
	self:AddDT( "Entity", "GunnerSeat" )
	self:AddDT( "Entity", "HeldEntity" )
end

function ENT:InitWeapons()
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/dual_mg.png")
	weapon.Ammo = 600
	weapon.Delay = 0.25
	weapon.HeatRateUp = 0
	weapon.HeatRateDown = 1
	weapon.Attack = function( ent )
		if math.abs( ent.frontgunYaw ) > 100 then return end

		local ID_L = self:LookupAttachment( "muzzle_frontgun_left" )
		local ID_R = self:LookupAttachment( "muzzle_frontgun_right" )
		local Muzzle = {
			[1] = self:GetAttachment( ID_L ),
			[2] = self:GetAttachment( ID_R ),
		}

		local NewHeat = ent:GetHeat()

		for id = 1, 2 do
			if id == 1 and ent.frontgunYaw > 5 then continue end
			if id == 2 and ent.frontgunYaw < -5 then continue end

			local att = Muzzle[ id ]

			local bullet = {}
			bullet.Src 	= att.Pos
			bullet.Dir 	= att.Ang:Up()
			bullet.Spread 	= Vector( 0.015,  0.015, 0 )
			bullet.TracerName = "lvs_laser_green"
			bullet.Force	= 10
			bullet.HullSize 	= 25
			bullet.Damage	= 40
			bullet.Velocity = 60000
			bullet.Attacker 	= ent:GetDriver()
			bullet.Callback = function(att, tr, dmginfo)
				local effectdata = EffectData()
					effectdata:SetStart( Vector(50,255,50) ) 
					effectdata:SetOrigin( tr.HitPos )
					effectdata:SetNormal( tr.HitNormal )
				util.Effect( "lvs_laser_impact", effectdata )
			end

			ent:LVSFireBullet( bullet )
			ent:TakeAmmo()

			NewHeat = NewHeat + 0.075
		end

		ent:SetHeat( NewHeat )

		if NewHeat >= 1 then
			ent:SetOverheated( true )
		end

		ent.PrimarySND:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	weapon.OnThink = function( ent, active )
		local trace = ent:GetEyeTrace()

		local AimAngles = ent:WorldToLocalAngles( (trace.HitPos - self:LocalToWorld(  Vector(256,0,36) ) ):GetNormalized():Angle() )

		ent.frontgunYaw = -AimAngles.y

		if math.abs( ent.frontgunYaw ) > 100 then
			ent:SetPoseParameter("frontgun_pitch", 0 )
			ent:SetPoseParameter("frontgun_yaw", 0 )

			return
		end

		ent:SetPoseParameter("frontgun_pitch", -AimAngles.p )
		ent:SetPoseParameter("frontgun_yaw", -AimAngles.y )
	end
	self:AddWeapon( weapon )

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/dropship_grabber.png")
	weapon.Ammo = -1
	weapon.Delay = 1
	weapon.HeatRateUp = 10
	weapon.HeatRateDown = 1
	weapon.StartAttack = function( ent )
		ent:ToggleGrabber()
	end
	self:AddWeapon( weapon )



	local COLOR_RED = Color(255,0,0,255)
	local COLOR_WHITE = Color(255,255,255,255)
	self.RearGunAngleRange = 35

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Ammo = -1
	weapon.Delay = 0.3
	weapon.HeatRateUp = 0.4
	weapon.HeatRateDown = 0.4
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	weapon.Attack = function( ent )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		if ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) > base.RearGunAngleRange then return true end

		local trace = ent:GetEyeTrace()

		local Pos,Ang = WorldToLocal( Vector(0,0,0), (trace.HitPos - self:LocalToWorld( Vector(-400,0,158.5)) ):GetNormalized():Angle(), Vector(0,0,0), self:LocalToWorldAngles( Angle(0,180,0) ) )

		local ID = self:LookupAttachment( "muzzle_reargun" )
		local Muzzle = self:GetAttachment( ID )

		if not Muzzle then return true end

		local bullet = {}
		bullet.Src 	= Muzzle.Pos
		bullet.Dir 	= (trace.HitPos - Muzzle.Pos):GetNormalized()
		bullet.Spread 	= Vector( 0.03,  0.03, 0.03 )
		bullet.TracerName = "lvs_laser_green"
		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 65
		bullet.Velocity = 30000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(50,255,50) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_impact", effectdata )
		end
		ent:LVSFireBullet( bullet )

		if not IsValid( self.SNDTail ) then return end

		self.SNDTail:PlayOnce( 100 + math.Rand(-3,3), 1 )
	end
	weapon.OnThink = function( ent, active )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		if ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) > base.RearGunAngleRange then base:SetPoseParameter("reargun_yaw", 0 ) return end

		local trace = ent:GetEyeTrace()

		local _,Ang = WorldToLocal( Vector(0,0,0), (trace.HitPos - self:LocalToWorld( Vector(-400,0,158.5)) ):GetNormalized():Angle(), Vector(0,0,0), self:LocalToWorldAngles( Angle(0,180,0) ) )

		base:SetPoseParameter("reargun_pitch", -Ang.p )
		base:SetPoseParameter("reargun_yaw", -Ang.y )

	end
	weapon.CalcView = function( ent, ply, pos, angles, fov, pod )
		local base = ent:GetVehicle()

		local view = {}
		view.origin = pos
		view.angles = angles
		view.fov = fov
		view.drawviewer = false

		if not IsValid( base ) then return view end

		local radius = 800
		radius = radius + radius * pod:GetCameraDistance()

		local StartPos = pod:LocalToWorld( pod:OBBCenter() ) + angles :Up() * (250 + radius * pod:GetCameraHeight())
		local EndPos = StartPos - angles:Forward() * radius

		local WallOffset = 4

		local tr = util.TraceHull( {
			start = StartPos,
			endpos = EndPos,
			filter = function( e )
				local c = e:GetClass()
				local collide = not c:StartWith( "prop_physics" ) and not c:StartWith( "prop_dynamic" ) and not c:StartWith( "prop_ragdoll" ) and not e:IsVehicle() and not c:StartWith( "gmod_" ) and not c:StartWith( "player" ) and not e.LVS
				
				return collide
			end,
			mins = Vector( -WallOffset, -WallOffset, -WallOffset ),
			maxs = Vector( WallOffset, WallOffset, WallOffset ),
		} )

		view.drawviewer = true
		view.origin = tr.HitPos

		if tr.Hit and not tr.StartSolid then
			view.origin = view.origin + tr.HitNormal * WallOffset
		end

		return view
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		local RearGunInRange = ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) > base.RearGunAngleRange

		local Col = RearGunInRange and COLOR_RED or COLOR_WHITE

		local Pos2D = ent:GetEyeTrace().HitPos:ToScreen() 

		base:PaintCrosshairCenter( Pos2D, Col )
		base:PaintCrosshairOuter( Pos2D, Col )
		base:LVSPaintHitMarker( Pos2D )
	end
	self:AddWeapon( weapon, 2 )
end

sound.Add( {
	name = "LVS.LAAT.GRABBER",
	channel = CHAN_ITEM,
	volume = 1.0,
	level = 90,
	pitch = 100,
	sound = "lvs/vehicles/laat/door_large_open.wav"
} )

sound.Add( {
	name = "LVS.LAAT.GRABBER_CANTDROP",
	channel = CHAN_ITEM,
	volume = 1.0,
	level = 90,
	pitch = 100,
	sound = "buttons/button8.wav"
} )

ENT.FlyByAdvance = 1
ENT.FlyBySound = "LVS.LAAT.FLYBY" 
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/laat/loop.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
	{
		sound = "^lvs/vehicles/laat/dist.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0.35,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		VolumeMin = 0,
		VolumeMax = 1,
		SoundLevel = 110,
	},
}

function ENT:ResetFilters()
	-- clear the filters, so they can be rebuild
	self.CrosshairFilterEnts = nil
end

function ENT:BuildFilter()
	if not istable( self.CrosshairFilterEnts ) then
		self:GetCrosshairFilterEnts()
	end

	local HeldEnt = self:GetHeldEntity()

	if not IsValid( HeldEnt ) then return end

	if HeldEnt.GetCrosshairFilterEnts then
		for _, ent in pairs( HeldEnt:GetCrosshairFilterEnts() ) do
			table.insert( self.CrosshairFilterEnts, ent )
		end
	else
		table.insert( self.CrosshairFilterEnts , HeldEnt )
	end
end

--PATH lua/entities/lvs_soundemitter.lua:
AddCSLuaFile()

ENT.Type            = "anim"

ENT.Spawnable       = false
ENT.AdminSpawnable  = false
ENT.DoNotDuplicate = true

ENT._LVS = true

function ENT:SetupDataTables()
	self:NetworkVar( "Entity",0, "Base" )

	self:NetworkVar( "Bool",0, "Active" )
	self:NetworkVar( "Bool",1, "ActiveVisible" )
	self:NetworkVar( "Bool",2, "Doppler" )

	self:NetworkVar( "String",1, "Sound")
	self:NetworkVar( "String",2, "SoundInterior")

	self:NetworkVar( "Int",0, "SoundLevel" )

	if SERVER then
		self:SetSoundLevel( 110 )
		self:SetActiveVisible( true )
	end
end

if SERVER then
	util.AddNetworkString( "lvs_soundemitter_playonce" )

	function ENT:Initialize()	
		self:SetMoveType( MOVETYPE_NONE )
		self:SetSolid( SOLID_NONE )
		self:DrawShadow( false )
		debugoverlay.Cross( self:GetPos(), 50, 5, Color( 150, 150, 150 ) )
	end

	function ENT:Think()
		return false
	end

	function ENT:UpdateTransmitState() 
		return TRANSMIT_ALWAYS
	end

	function ENT:PlayOnce( pitch, volume )
		net.Start( "lvs_soundemitter_playonce", true )
			net.WriteEntity( self )
			net.WriteInt( pitch or 100, 9 )
			net.WriteFloat( volume or 1 )
		net.SendPVS( self:GetPos() )
	end

	function ENT:Play()
		self:SetActive( true )
	end

	function ENT:Stop()
		self:SetActive( false )
	end

	return
end

net.Receive( "lvs_soundemitter_playonce", function( len )
	local ent = net.ReadEntity()

	if not IsValid( ent ) or not ent.PlayOnce then return end

	ent:PlayOnce( net.ReadInt( 9 ), net.ReadFloat() )
end )

function ENT:PlayOnce( pitch, volume )
	local ply = LocalPlayer()
	local veh = ply:lvsGetVehicle()

	local snd = self:GetSound()
	local snd_int = self:GetSoundInterior()

	if snd == snd_int then self:EmitSound( snd, self:GetSoundLevel(), pitch, volume, CHAN_WEAPON ) return end

	if IsValid( veh ) and veh == self:GetBase() and ply:GetViewEntity() == ply then
		local pod = ply:GetVehicle()

		if IsValid( pod ) then
			if pod:GetThirdPersonMode() then
				self:EmitSound( snd, self:GetSoundLevel(), pitch, volume, CHAN_WEAPON )
			else
				self:EmitSound( snd_int, self:GetSoundLevel(), pitch, volume, CHAN_WEAPON )
			end
		else
			self:EmitSound( snd, self:GetSoundLevel(), pitch, volume, CHAN_WEAPON )
		end
	else
		self:EmitSound( snd, self:GetSoundLevel(), pitch, volume, CHAN_WEAPON )
	end
end

function ENT:Initialize()
end

function ENT:RemoveSounds()
	if self.snd then
		self.snd:Stop()
		self.snd = nil
	end

	if self.snd_int then
		self.snd_int:Stop()
		self.snd_int = nil
	end
end

function ENT:HandleSounds()
	local ply = LocalPlayer()
	local veh = ply:lvsGetVehicle()
	local base = self:GetBase()

	if self:GetDoppler() and IsValid( base ) then
		local Doppler = base:CalcDoppler( ply )

		if self.snd then self.snd:ChangePitch( 100 * Doppler, 0.5 ) end
		if self.snd_int then self.snd_int:ChangePitch( 100 * Doppler, 0.5 ) end
	end

	if not self.snd_int then return end

	if IsValid( veh ) and veh == base and ply:GetViewEntity() == ply then
		local pod = ply:GetVehicle()

		if IsValid( pod ) then
			if pod:GetThirdPersonMode() then
				if self.snd then self.snd:ChangeVolume( 1 ) end
				if self.snd_int then self.snd_int:ChangeVolume( 0 ) end
			else
				if self.snd then self.snd:ChangeVolume( 0 ) end
				if self.snd_int then self.snd_int:ChangeVolume( 1 ) end
			end
		else
			if self.snd then self.snd:ChangeVolume( 1 ) end
			if self.snd_int then self.snd_int:ChangeVolume( 0 ) end
		end
	else
		if self.snd then self.snd:ChangeVolume( 1 ) end
		if self.snd_int then self.snd_int:ChangeVolume( 0 ) end
	end
end

function ENT:StartSounds()
	local snd = self:GetSound()
	local snd_int = self:GetSoundInterior()

	if snd ~= "" then
		self.snd = CreateSound( self, snd )
		self.snd:SetSoundLevel( self:GetSoundLevel() )
		self.snd:PlayEx(0,100)
	end

	if snd == snd_int or snd_int == "" or LocalPlayer():lvsGetVehicle() ~= self:GetBase() then
		if self.snd then self.snd:ChangeVolume( 1, 0 ) end

		return
	end

	self.snd_int = CreateSound( self, snd_int )
	self.snd_int:SetSoundLevel( self:GetSoundLevel() )
	self.snd_int:PlayEx(0,100)
end

function ENT:StopSounds()
	self.NextActive = CurTime() + 0.12

	if self.snd then
		self.snd:ChangeVolume( 0, 0.1 )
	end

	if self.snd_int then
		self.snd_int:ChangeVolume( 0, 0.1 )
	end

	timer.Simple(0.11, function()
		if not IsValid( self ) then return end
		self:RemoveSounds()
	end)
end

function ENT:OnActiveChanged( Active )
	if Active then
		self:StartSounds()
	else
		self:StopSounds()
	end
end

ENT._oldActive = false
function ENT:Think()
	local Active = self:GetActive() and (self.NextActive or 0) < CurTime()

	if self._oldActive ~= Active then
		self._oldActive = Active
		self:OnActiveChanged( Active )
	end

	if Active then
		self:HandleSounds()
	end
end

function ENT:OnRemove()
	self:RemoveSounds()
end

function ENT:Draw()
end

function ENT:DrawTranslucent()
end

--PATH lua/entities/lvs_starfighter_arc170/cl_init.lua:
return gluapack()()
--PATH lua/entities/lvs_starfighter_engine.lua:
return gluapack()()
--PATH lua/entities/lvs_starfighter_hyenabomber/cl_init.lua:
return gluapack()()
--PATH lua/entities/lvs_starfighter_hyenabomber/shared.lua:
return gluapack()()
--PATH lua/entities/lvs_starfighter_n1/shared.lua:
return gluapack()()
--PATH lua/entities/lvs_sw_transport/cl_init.lua:
return gluapack()()
--PATH lua/entities/lvs_turret_aa/cl_init.lua:
include("shared.lua")

function ENT:CalcViewOverride( ply, pos, angles, fov, pod )

	if self:GetGunnerSeat() == ply:GetVehicle() then
		if pod:GetThirdPersonMode() then
			return pos + self:GetUp() * 100, angles, fov
		end
	end

	return pos, angles, fov
end

function ENT:OnSpawn()
end

function ENT:OnFrame()
end

function ENT:PostDrawTranslucent()
end

function ENT:EngineEffects()
end

function ENT:AnimGunner()
end

function ENT:AnimAstromech()
end

function ENT:AnimCockpit()
end

function ENT:OnStartBoost()
end

function ENT:OnStopBoost()
end

--PATH lua/entities/lvs_turret_av/cl_init.lua:
return gluapack()()
--PATH lua/entities/lvs_vehicle_spammer.lua:
return gluapack()()
--PATH lua/entities/lvs_walker_atrt_flamethrower/shared.lua:
return gluapack()()
--PATH lua/entities/lvs_walker_atrt_flamethrower/cl_legs.lua:

function ENT:OnFrame()
	--self:PredictPoseParamaters()
	self:DamageFX()

	if self:GetIsRagdoll() then 
		self:LegClearAll()

		return
	end

	local Up = self:GetUp()
	local Forward = self:GetForward()
	local Vel = self:GetVelocity()
	
	local Stride = 33
	local Lift = 10
	
	local FT = math.min(FrameTime(),0.08) -- if fps lower than 12, clamp the frametime to avoid spazzing.

	local Rate = FT * 20

	if Vel:Length() < 50 then -- sync with server animation when not moving
		self.Move = self:GetMove()
	else
		self.Move = self.Move and self.Move + self:WorldToLocal( self:GetPos() + Vel ).x * FT * 2.8 or 0
	end
	
	local Cycl1 = self.Move
	local Cycl2 = self.Move + 180
	
	local IsMoving = self:GetIsMoving()
	
	if self:GetIsCarried() then
		self.TRACEPOS1 = self:LocalToWorld( Vector(200,70,180) )
		self.TRACEPOS2 = self:LocalToWorld( Vector(200,-70,180) )
		Cycl1 = 0
		Cycl2 = 0
		IsMoving = true
	end

	local MoveRoll = math.cos( math.rad(self:GetMove()) ) * 2

	-- FRONT LEFT
	local X = 40 + math.cos( math.rad(Cycl1) ) * Stride
	local Z = math.max( math.sin( math.rad(-Cycl1) ), 0) * Lift
	local STARTPOS = self:LocalToWorld( Vector(-22,18,64) )
	self.TRACEPOS1 = self.TRACEPOS1 and self.TRACEPOS1 or STARTPOS
	if Z > 0 or not IsMoving then 
		self.TRACEPOS1 = self.TRACEPOS1 + (STARTPOS + Forward * X - self.TRACEPOS1) * Rate
		self.FSOG1 = false
	else
		self.FSOG1 = true
	end
	--local ENDPOS = util.TraceLine( { start = self.TRACEPOS1 - Up * 50, endpos = self.TRACEPOS1 - Up * 160, filter = function( ent ) if ent == self or ent == self:GetRearEntity() or self.HoverCollisionFilter[ ent:GetCollisionGroup() ] then return false end return true end,} ).HitPos + Up * (45+Z)
	local ENDPOS = util.TraceLine( { start = self.TRACEPOS1 - Up * 50, endpos = self.TRACEPOS1 - Up * 160, filter = function( ent ) if ent == self or self.HoverCollisionFilter[ ent:GetCollisionGroup() ] then return false end return true end,} ).HitPos + Up * (-30+Z)
    
	if self.FSOG1 ~= self.oldFSOG1 then
		self.oldFSOG1 = self.FSOG1
		if self.FSOG1 then
			sound.Play( Sound( "atrt/walk.mp3" ), ENDPOS, SNDLVL_70dB)
			local effectdata = EffectData()
				effectdata:SetOrigin( ENDPOS - Vector(0,0,45) )
			util.Effect( "lvs_walker_stomp", effectdata )
		elseif Vel:Length() < 150 then
			sound.Play( Sound( "atrt/hydraulic"..math.random(1,3)..".mp3" ), ENDPOS, SNDLVL_70dB)
		end
	end
	
	local ATTACHMENTS = {
		Leg1 = {MDL = "models/astartes/atrt/leg3.mdl", Ang = Angle(140,0,0), Pos = Vector(1,-27,4)},
		Leg2 = {MDL = "models/astartes/atrt/leg2.mdl", Ang = Angle(145,0,0), Pos = Vector(2,-33,-1)},
		Foot = {MDL = "models/astartes/atrt/leg0.mdl", Ang = Angle(0,-90,-MoveRoll), Pos = Vector(12,10,-10)}
	}
	self:GetLegEnts( 1, 50, 65, self:LocalToWorldAngles( Angle(90,-10,0) ), STARTPOS, ENDPOS, ATTACHMENTS )
	
	
	-- FRONT RIGHT
	local STARTPOS = self:LocalToWorld( Vector(-22, -18,64) )
	local X = 10 + math.cos( math.rad(Cycl2) ) * Stride
	local Z = math.max( math.sin( math.rad(-Cycl2) ), 0) * Lift
	self.TRACEPOS2 = self.TRACEPOS2 and self.TRACEPOS2 or STARTPOS
	if Z > 0 or not IsMoving then 
		self.TRACEPOS2 = self.TRACEPOS2 + (STARTPOS + Forward * X - self.TRACEPOS2) * Rate
		self.FSOG2 = false
	else
		self.FSOG2 = true
	end
	--local ENDPOS = util.TraceLine( { start = self.TRACEPOS2 - Up * 50, endpos = self.TRACEPOS2 - Up * 160, filter = function( ent ) if ent == self or ent == self:GetRearEntity() or self.HoverCollisionFilter[ ent:GetCollisionGroup() ] then return false end return true end, } ).HitPos + Up * (45+Z)
	local ENDPOS = util.TraceLine( { start = self.TRACEPOS2 - Up * 50, endpos = self.TRACEPOS2 - Up * 160, filter = function( ent ) if ent == self or self.HoverCollisionFilter[ ent:GetCollisionGroup() ] then return false end return true end,} ).HitPos + Up * (-30+Z)
	
	if self.FSOG2 ~= self.oldFSOG2 then
		self.oldFSOG2 = self.FSOG2
		if self.FSOG2 then
			sound.Play( Sound( "atrt/walk.mp3" ), ENDPOS, SNDLVL_70dB)
			local effectdata = EffectData()
				effectdata:SetOrigin( ENDPOS - Vector(0,0,45) )
			util.Effect( "lvs_walker_stomp", effectdata )
		elseif Vel:Length() < 150 then
			sound.Play( Sound( "atrt/hydraulic"..math.random(1,3)..".mp3" ), ENDPOS, SNDLVL_70dB)
		end
	end
	
	local ATTACHMENTS = {
		Leg1 = {MDL = "models/astartes/atrt/leg3.mdl", Ang = Angle(140,0,0), Pos = Vector(1,-27,4)},
		Leg2 = {MDL = "models/astartes/atrt/leg2.mdl", Ang = Angle(145,0,0), Pos = Vector(2,-33,-1)},
		Foot = {MDL = "models/astartes/atrt/leg0.mdl", Ang = Angle(0,-90,-MoveRoll), Pos = Vector(12,10,-10)}
	}
	
	self:GetLegEnts( 2, 50, 65, self:LocalToWorldAngles( Angle(90,10,0) ), STARTPOS, ENDPOS, ATTACHMENTS )
	
end
--PATH lua/entities/lvs_walker_atte/cl_camera.lua:

function ENT:CalcViewDriver( ply, pos, angles, fov, pod )
	local view = {}
	view.origin = pos
	view.angles = angles
	view.fov = fov
	view.drawviewer = false

	if not pod:GetThirdPersonMode() then return view end

	local mn = self:OBBMins()
	local mx = self:OBBMaxs()
	local radius = ( mn - mx ):Length()
	local radius = radius + radius * pod:GetCameraDistance()

	local clamped_angles = pod:WorldToLocalAngles( angles )
	clamped_angles.p = math.max( clamped_angles.p, -20 )
	clamped_angles = pod:LocalToWorldAngles( clamped_angles )

	local StartPos = self:LocalToWorld( self:OBBCenter() ) + clamped_angles:Up() * 100
	local EndPos = StartPos - clamped_angles:Forward() * radius + clamped_angles:Up() * (radius * 0.2 + radius * pod:GetCameraHeight())

	local WallOffset = 4

	local tr = util.TraceHull( {
		start = StartPos,
		endpos = EndPos,
		filter = function( e )
			local c = e:GetClass()
			local collide = not c:StartWith( "prop_physics" ) and not c:StartWith( "prop_dynamic" ) and not c:StartWith( "prop_ragdoll" ) and not e:IsVehicle() and not c:StartWith( "gmod_" ) and not c:StartWith( "lvs_" ) and not c:StartWith( "player" ) and not e.LVS

			return collide
		end,
		mins = Vector( -WallOffset, -WallOffset, -WallOffset ),
		maxs = Vector( WallOffset, WallOffset, WallOffset ),
	} )

	view.angles = angles + Angle(5,0,0)
	view.origin = tr.HitPos
	view.drawviewer = true

	if tr.Hit and  not tr.StartSolid then
		view.origin = view.origin + tr.HitNormal * WallOffset
	end

	return view
end

function ENT:LVSCalcView( ply, pos, angles, fov, pod )
	if self:GetDriver() == ply then
		return self:CalcViewDriver( ply, pos, angles, fov, pod )
	end

	local view = {}
	view.origin = self:LocalToWorld( Vector(0,0,200) )
	view.angles = angles
	view.fov = fov
	view.drawviewer = false

	local mn = self:OBBMins()
	local mx = self:OBBMaxs()
	local radius = ( mn - mx ):Length()
	local radius = radius + radius * pod:GetCameraDistance()

	local TargetOrigin = view.origin + ( view.angles:Forward() * -radius ) + view.angles:Up() * (80 + radius * pod:GetCameraHeight())
	local WallOffset = 4

	local tr = util.TraceHull( {
		start = view.origin,
		endpos = TargetOrigin,
		filter = function( e )
			local c = e:GetClass()
			local collide = not c:StartWith( "prop_physics" ) and not c:StartWith( "prop_dynamic" ) and not c:StartWith( "prop_ragdoll" ) and not e:IsVehicle() and not c:StartWith( "gmod_" ) and not c:StartWith( "lvs_" ) and not c:StartWith( "player" ) and not e.LVS

			return collide
		end,
		mins = Vector( -WallOffset, -WallOffset, -WallOffset ),
		maxs = Vector( WallOffset, WallOffset, WallOffset ),
	} )

	view.origin = tr.HitPos

	if tr.Hit and  not tr.StartSolid then
		view.origin = view.origin + tr.HitNormal * WallOffset
	end

	return view
end
--PATH lua/entities/lvs_walker_atte/cl_prediction.lua:
return gluapack()()
--PATH lua/entities/mediaplayer_tv/shared.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/entities/entities/meteor/shared.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/entities/entities/meteor/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Meteor"
ENT.Author = "Rickster"
ENT.Contact = "Rickyman35@hotmail.com"
ENT.Spawnable = false

--PATH lua/entities/mk4.lua:
AddCSLuaFile()

if SERVER then
	resource.AddFile( "Models/effects/vol_light001" )
end

DEFINE_BASECLASS( "jetpack_base" )

ENT.Spawnable = false
ENT.PrintName = "Infinite Flight"

if CLIENT then
	ENT.MatHeatWave		= Material( "sprites/heatwave" )
	ENT.MatFire			= Material( "effects/fire_cloud1" )


	AccessorFunc( ENT , "NextParticle" , "NextParticle" )
	AccessorFunc( ENT , "LastActive" , "LastActive" )
	AccessorFunc( ENT , "LastFlameTrace" , "LastFlameTrace" )
	AccessorFunc( ENT , "NextFlameTrace" , "NextFlameTrace" )

	ENT.MaxEffectsSize = 0
	ENT.MinEffectsSize = 0



	ENT.JetpackFireBlue = Color( 0 , 0 , 255 , 128 )
	ENT.JetpackFireWhite = Color( 255 , 255 , 255 , 128 )
	ENT.JetpackFireNone = Color( 255 , 255 , 255 , 0 )
	ENT.JetpackFireRed = Color( 255 , 128 , 128 , 255 )

else

	ENT.StandaloneApeShitAngular = Vector( 0 , 10 , 10 )	--do a corkscrew
	ENT.StandaloneApeShitLinear = Vector( 0 , 0 , 0 )

	ENT.StandaloneAngular = vector_origin
	ENT.StandaloneLinear = Vector( 0 , 0 , 0 )

	ENT.ShowPickupNotice = true
	ENT.SpawnOnGroundConVar = CreateConVar(
		"sv_spawnjetpackonground" ,
		"0",
		{
			FCVAR_SERVER_CAN_EXECUTE,
			FCVAR_ARCHIVE
		},
		"When true, it will spawn the jetpack on the ground, otherwise it will try equipping it right away, if you already have one equipped it will not do anything"
	)
end

--use this to calculate the position on the parent because I can't be arsed to deal with source's parenting bullshit with local angles and position
--plus this is also called during that parenting position recompute, so it's perfect

ENT.AttachmentInfo = {
	BoneName = "ValveBiped.Bip01_R_Thigh",
	OffsetVec = Vector( 1 , -0 , 2 ),
	OffsetAng = Angle( 180 , 90 , -91 ),
}

local sv_gravity = GetConVar "sv_gravity"

function ENT:SpawnFunction( ply, tr, ClassName )

	if not tr.Hit then return end

	local SpawnPos = tr.HitPos + tr.HitNormal * 36

	local ent = ents.Create( ClassName )
	ent:SetSlotName( ClassName )	--this is the best place to set the slot, only modify it ingame when it's not equipped
	ent:SetPos( SpawnPos )
	ent:SetAngles( Angle( 90 , 0 , 0 ) )
	ent:Spawn()

	--try equipping it, if we can't we'll just remove it
	if not self.SpawnOnGroundConVar:GetBool() then
		--forced should not be set here, as we still kinda want the equip logic to work as normal
		if not ent:Attach( ply , false ) then
			ent:Remove()
			return
		end
	end

	return ent

end

function ENT:Initialize()
	BaseClass.Initialize( self )
	if SERVER then
		self:SetModel( "models/hunter/plates/plate.mdl" )
		self:SetMaterial ( "Models/effects/vol_light001" )
		self:InitPhysics()

		self:SetMaxHealth( 100 )
		self:SetHealth( self:GetMaxHealth() )

		self:SetInfiniteFuel( true )
		self:SetMaxFuel(150)
		self:SetFuel( self:GetMaxFuel() )
		self:SetFuelDrain(0)	--drain in seconds
		self:SetFuelRecharge( 0 )	--recharge in seconds
		self:SetActive( false )
		self:SetCanStomp( false )
		self:SetDoGroundSlam( false )
		self:SetAirResistance( 3.5 )
		self:SetRemoveGravity( true )
		self:SetJetpackSpeed( 2000 )
		self:SetJetpackStrafeSpeed( 500 )
		self:SetJetpackVelocity( 900 )
		self:SetJetpackStrafeVelocity( 5000 )
	else
		self:SetLastActive( false )
		self:SetNextParticle( 0 )
		self:SetNextFlameTrace( 0 )
		self:SetLastFlameTrace( nil )
	end
end

function ENT:SetupDataTables()
	BaseClass.SetupDataTables( self )

	self:DefineNWVar( "Bool" , "Active" )
	self:DefineNWVar( "Bool" , "GoneApeshit" , true )	--set either when the owner dies with us active, or when we're being shot at
	self:DefineNWVar( "Bool" , "RemoveGravity" )
	self:DefineNWVar( "Bool" , "InfiniteFuel" , true , "Infinite Fuel" )
	self:DefineNWVar( "Bool" , "DoGroundSlam" )
	self:DefineNWVar( "Bool" , "CanStomp" , true , "Can stomp" )

	self:DefineNWVar( "Float" , "Fuel" )
	self:DefineNWVar( "Float" , "MaxFuel" )	--don't modify the max amount, the drain scales anyway, set to -1 to disable the fuel drain
	self:DefineNWVar( "Float" , "FuelDrain" , true , "Seconds to drain fuel" , 1 , 60 ) --how many seconds it's gonna take to drain all the fuel
	self:DefineNWVar( "Float" , "FuelRecharge" , true , "Seconds to recharge the fuel" , 1 , 60 ) --how many seconds it should take to fully recharge this
	self:DefineNWVar( "Float" , "AirResistance" , true , "Air Resistance" , 0 , 10 )
	self:DefineNWVar( "Float" , "GoneApeshitTime" ) --only used if infinite fuel is on

	self:DefineNWVar( "Int" , "Key" )	--override it to disallow people from editing the key since it's unused
	self:DefineNWVar( "Int" , "JetpackSpeed" , true , "Jetpack idle upward speed" , 1 , 1000 )
	self:DefineNWVar( "Int" , "JetpackStrafeSpeed" , true , "Jetpack idle side speed" , 1 , 1000 )
	self:DefineNWVar( "Int" , "JetpackVelocity" , true , "Jetpack active upward speed" , 1 , 2000 )
	self:DefineNWVar( "Int" , "JetpackStrafeVelocity" , true , "Jetpack active side speed" , 1 , 2000 )

end

function ENT:HandleFly( predicted , owner , movedata , usercmd )
	self:SetActive( self:CanFly( owner , movedata ) )

	--we have infinite fuel and the apeshit timeout hasn't been set, do it now
	--this is most useful because I CBA to do that everytime ok?
	--also it's serverside only because we only set the apeshit on the server anyway

	if SERVER then
		if self:GetGoneApeshit() and self:GetGoneApeshitTime() == 0 and self:GetInfiniteFuel() then
			self:SetGoneApeshitTime( CurTime() + 5 )
		end
	end

	--the check below has to be done with prediction on the client!

	if CLIENT and not predicted then
		return
	end

	--fixes a bug where if you set goneapeshit manually via the contextmenu and the physobj is asleep it wouldn't apply the simulated forces
	if SERVER and not predicted and self:GetGoneApeshit() then
		local physobj = self:GetPhysicsObject()
		if IsValid( physobj ) and physobj:IsAsleep() then
			physobj:Wake()
		end
	end

	--if we have an apeshit timeout, calm us down ( this doesn't check for infinite fuel, in case we did this manually )
	if self:GetGoneApeshit() and self:GetGoneApeshitTime() ~= 0 and self:GetGoneApeshitTime() <= CurTime() then
		self:SetGoneApeshit( false )
		self:SetGoneApeshitTime( 0 )
	end
end

function ENT:HandleFuel( predicted )

	--like with normal rules of prediction, we don't want to run on the client if we're not in the simulation

	if not predicted and CLIENT then
		return
	end

	--we set the think rate on the entity to the tickrate on the server, we could've done NextThink() - CurTime(), but it's only a setter, not a getter
	local ft = engine.TickInterval()

	--screw that, during prediction we need to recharge with FrameTime()
	if predicted then
		ft = FrameTime()
	end

	local fueltime = self:GetActive() and self:GetFuelDrain() or self:GetFuelRecharge()

	local fuelrate = self:GetMaxFuel() / ( fueltime / ft )

	if self:GetActive() then
		fuelrate = fuelrate * -1

		if self:GetGoneApeshit() then
			--drain twice as much fuel if we're going craaaazy
			fuelrate = fuelrate * 2
		end

		--don't drain any fuel when infinite fuel is on, but still allow recharge
		if self:GetInfiniteFuel() then
			fuelrate = 0
		end
	else
		--recharge in different ways if we have an owner or not, because players might drop and reequip the jetpack to exploit the recharging
		if IsValid( self:GetControllingPlayer() ) then
			--can't recharge until our owner is on the ground!
			--prevents the player from tapping the jump button to fly and recharge at the same time
			if not self:GetControllingPlayer():OnGround() then
				fuelrate = 0
			end
		else
			--only recharge if our physobj is sleeping and it's valid ( should never be invalid in the first place )
			local physobj = self:GetPhysicsObject()
			if not IsValid( physobj ) or not physobj:IsAsleep() then
				fuelrate = 0
			end
		end
	end

	--holy shit, optimization??
	if fuelrate ~= 0 then
		self:SetFuel( math.Clamp( self:GetFuel() + fuelrate , 0 , self:GetMaxFuel() ) )
	end

	--we exhausted all of our fuel, chill out if we're crazy
	if not self:HasFuel() and self:GetGoneApeshit() then
		self:SetGoneApeshit( false )
	end
end

function ENT:HasFuel()
	return self:GetFuel() > 0
end

function ENT:GetFuelFraction()
	return self:GetFuel() / self:GetMaxFuel()
end

function ENT:CanFly( owner , mv )


	if IsValid( owner ) then

		--don't care about player inputs in this case, the player's jetpack is going craaazy

		if self:GetGoneApeshit() then
			return owner:WaterLevel() == 0 and owner:GetMoveType() == MOVETYPE_WALK and self:HasFuel()
		end

		return ( mv:KeyDown( IN_JUMP ) or mv:KeyDown( IN_DUCK ) or mv:KeyDown( IN_SPEED ) ) and not owner:OnGround() and owner:WaterLevel() == 0 and owner:GetMoveType() == MOVETYPE_WALK and owner:Alive() and self:HasFuel()
	end

	--making it so the jetpack can also fly on its own without an owner ( in the case we want it go go nuts if the player dies or some shit )
	if self:GetGoneApeshit() then
		return self:WaterLevel() == 0 and self:HasFuel()
	end

	return false
end

function ENT:Think()

	--still act if we're not being held by a player
	if not self:IsCarried() then
		self:HandleFly( false )
		self:HandleFuel( false )
	end

	--animation related stuff should be fine to call here



	return BaseClass.Think( self )
end

function ENT:PredictedSetupMove( owner , mv , usercmd )

	self:HandleFly( true , owner , mv , usercmd )
	self:HandleFuel( true )

	if self:GetActive() then

		local vel = mv:GetVelocity()

		if mv:KeyDown( IN_JUMP ) and vel.z < self:GetJetpackSpeed() then

			-- Apply constant jetpack_velocity

			vel.z = vel.z + self:GetJetpackVelocity() * FrameTime()

		elseif mv:KeyDown( IN_SPEED ) and vel.z < 0 then

			-- Apply just the right amount of thrust

			vel.z = math.Approach( vel.z , 0 , self:GetJetpackVelocity() * FrameTime() )

		end



		-- Quickly descend to do a ground slam, don't check for the velocity cap, we want to slam down as fast as we can
		if self:GetCanStomp() then
			self:SetDoGroundSlam( mv:KeyDown( IN_DUCK ) )
		end

		--even if the user can't stomp, we still allow him to go down by crouching

		if mv:KeyDown( IN_DUCK ) then
			vel.z = vel.z - self:GetJetpackVelocity() * FrameTime()
		end

		--
		-- Remove gravity when velocity is supposed to be zero for hover mode
		--

		if vel.z == 0 then

			self:SetRemoveGravity( true )

			vel.z = vel.z + sv_gravity:GetFloat() * 0.5 * FrameTime()

		end

		--
		-- Apply movement velocity
		--

		local move_vel = Vector( 0, 0, 0 )

		local ang = mv:GetMoveAngles()
		ang.p = 0

		move_vel:Add( ang:Right() * mv:GetSideSpeed() )
		move_vel:Add( ang:Forward() * mv:GetForwardSpeed() )

		move_vel:Normalize()
		move_vel:Mul( self:GetJetpackStrafeVelocity() * FrameTime() )

		if vel:Length2D() < self:GetJetpackStrafeSpeed() then

			vel:Add( move_vel )

		end

		--TODO: goneapeshit stuff, do it before air resistance

		if self:GetGoneApeshit() then
			--boost us in the direction the jetpack is facing in the world ( actual third person angles )
			--ragdolling the user and attaching us to the ragdoll would be quite expensive and wouldn't be worth it
			--as cool as that might look, that might also break stuff in other gamemodes

			local addvel = self:GetAngles():Up() * -1 * self:GetJetpackVelocity() * FrameTime()
			vel:Add( addvel )
		end

		--
		-- Apply air resistance
		--
		vel.x = math.Approach( vel.x, 0, FrameTime() * self:GetAirResistance() * vel.x )
		vel.y = math.Approach( vel.y, 0, FrameTime() * self:GetAirResistance() * vel.y )

		--
		-- Write our calculated velocity back to the CMoveData structure
		--
		mv:SetVelocity( vel )

		mv:SetForwardSpeed( 0 )
		mv:SetSideSpeed( 0 )
		mv:SetUpSpeed( 0 )

		-- Removes the crouch button from the movedata, effectively disabling the crouching behaviour

		mv:SetButtons( bit.band( mv:GetButtons(), bit.bnot( IN_DUCK ) ) )

	end
end

function ENT:PredictedThink( owner , movedata )
end

function ENT:PredictedMove( owner , data )
	if self:GetActive() and self:GetGoneApeshit() then
		owner:SetGroundEntity( NULL )
	end
end

function ENT:PredictedFinishMove( owner , movedata )
	if self:GetActive() then

		--
		-- Remove gravity when velocity is supposed to be zero for hover mode
		--
		if self:GetRemoveGravity() then
			local vel = movedata:GetVelocity()

			vel.z = vel.z + sv_gravity:GetFloat() * 0.5 * FrameTime()

			movedata:SetVelocity( vel )

			self:SetRemoveGravity( false )
		end

	end
end

local	SF_PHYSEXPLOSION_NODAMAGE			=	0x0001
local	SF_PHYSEXPLOSION_PUSH_PLAYER		=	0x0002
local	SF_PHYSEXPLOSION_RADIAL				=	0x0004
local	SF_PHYSEXPLOSION_TEST_LOS			=	0x0008
local	SF_PHYSEXPLOSION_DISORIENT_PLAYER	=	0x0010

function ENT:PredictedHitGround( ply , inwater , onfloater , speed )

	local dogroundslam = self:GetDoGroundSlam()
	self:SetDoGroundSlam( false )

	if dogroundslam and speed > 500 then

		self:EmitPESound( "Player.FallDamage" , nil , nil , nil , nil , true )
		--ply:EmitSound( "Player.FallDamage" )
		--self:EmitPESound( "" , nil , nil , nil , nil , true )	--find the sound smod uses when the player hits the ground in smod

		local fraction = self:GetJetpackStrafeVelocity() / speed	--because the fall speed might be higher than the jetpack one

		local effect = EffectData()
		effect:SetEntity( ply )
		effect:SetOrigin( ply:WorldSpaceCenter() )	--apparently the player is considered in the ground in this hook and stuff doesn't spawn
		effect:SetScale( 128 )
		util.Effect( "ThumperDust" , effect , true )	--todo, make our own effect where the particles start from the player and expand in a circle
														--can even copy the code from c_thumper_dust
		if SERVER then
			--TODO: get the code from the sdk and replicate this on my own
			ply:LagCompensation( true )

			--[[
			local physexpl = ents.Create( "env_physexplosion" )

			if IsValid( physexpl ) then
				physexpl:SetPos( ply:WorldSpaceCenter() )
				physexpl:SetKeyValue( "spawnflags" , bit.bor( SF_PHYSEXPLOSION_NODAMAGE , SF_PHYSEXPLOSION_RADIAL , SF_PHYSEXPLOSION_TEST_LOS ) )
				physexpl:SetKeyValue( "magnitude" , 500 * fraction )
				physexpl:SetKeyValue( "radius" , 250 )
				physexpl:Spawn()
				physexpl:Fire( "Explode" , "" , 0 )
				physexpl:Fire( "Kill" , "" , 0.1 )
			end
			]]



			--this is kind of shit but it's needed to make prediction actually work properly on this screenshake shit
			if SERVER and not game.SinglePlayer() then
				SuppressHostEvents( ply )
			end

			util.ScreenShake( self:GetPos() , 1.5 , 250 , 1 , 500 )

			if SERVER and not game.SinglePlayer() then
				SuppressHostEvents( NULL )
			end

			ply:LagCompensation( false )
		end

		ply:AnimRestartGesture( GESTURE_SLOT_JUMP, ACT_LAND, true )
		return true	--override the fall damage and other hooks
	end
end

if SERVER then

	function ENT:OnTakeDamage( dmginfo )
		--we're already dead , might happen if multiple jetpacks explode at the same time
		if self:Health() <= 0 then
			return
		end

		self:TakePhysicsDamage( dmginfo )

		local oldhealth = self:Health()

		local newhealth = math.Clamp( self:Health() - dmginfo:GetDamage() , 0 , self:GetMaxHealth() )
		self:SetHealth( newhealth )

		if self:Health() <= 0 then
			--maybe something is relaying damage to the jetpack instead, an explosion maybe?
			if IsValid( self:GetControllingPlayer() ) then
				self:Remove( true )
			end
			self:Detonate( dmginfo:GetAttacker() )
			return
		end

		--roll a random, if we're not being held by a player and the random succeeds, go apeshit
		if dmginfo:GetDamage() > 3 and not self:GetGoneApeshit() then
			local rand = math.random( 1 , 10 )
			if rand <= 2 then
				if IsValid( self:GetControllingPlayer() ) then
					self:Remove( true )
				end
				self:SetGoneApeshit( true )
			end
		end
	end

	function ENT:OnAttach( ply )
		self:SetDoGroundSlam( false )
		--self:SetSolid( SOLID_BBOX )	--we can still be hit when on the player's back
	end

	function ENT:CanAttach( ply )
		if self:GetGoneApeshit() then
			return false
		end
	end

	function ENT:OnDrop( ply , forced )
		if IsValid( ply ) and not ply:Alive() then
			--when the player dies while still using us, keep us active and let us fly with physics until
			--our fuel runs out
			if self:GetActive() then
				self:SetGoneApeshit( true )
			end
		else
			self:SetActive( false )
		end

	end

	function ENT:OnInitPhysics( physobj )
		if IsValid( physobj ) then
			physobj:SetMass( 75 )
			self:StartMotionController()
		end
		self:SetCollisionGroup( COLLISION_GROUP_NONE )
		--self:SetCollisionGroup( COLLISION_GROUP_WEAPON )	--set to COLLISION_GROUP_NONE to reenable collisions against players and npcs
	end

	function ENT:OnRemovePhysics( physobj )
		self:StopMotionController()
		self:SetCollisionGroup( COLLISION_GROUP_DEBRIS_TRIGGER )
		--self:SetCollisionGroup( COLLISION_GROUP_DEBRIS )
	end

	function ENT:PhysicsSimulate( physobj , delta )

		--no point in applying forces and stuff if something is holding our physobj

		if self:GetActive() and not self:GetBeingHeld() then
			physobj:Wake()
			local force = self.StandaloneLinear
			local angular = self.StandaloneAngular

			if self:GetGoneApeshit() then
				force = self.StandaloneApeShitLinear
				angular = self.StandaloneApeShitAngular
			end

			--yes I know we're technically modifying the variable stored in ENT.StandaloneApeShitLinear and that it might fuck up other jetpacks
			--but it won't because we're simply using it as a cached vector_origin and overriding the z anyway
			force.z = -self:GetJetpackVelocity()

			return angular * physobj:GetMass() , force * physobj:GetMass() , SIM_LOCAL_FORCE
		end
	end

	function ENT:PhysicsCollide( data , physobj )
		--taken straight from valve's code, it's needed since garry overwrote VPhysicsCollision, friction sound is still there though
		--because he didn't override the VPhysicsFriction
		if data.DeltaTime >= 0.05 and data.Speed >= 70 then
			local volume = data.Speed * data.Speed * ( 1 / ( 320 * 320 ) )
			if volume > 1 then
				volume = 1
			end

			--TODO: find a better impact sound for this model
			self:EmitSound( "SolidMetal.ImpactHard" , nil , nil , volume , CHAN_BODY )
		end

		if self:CheckDetonate( data , physobj ) then
			self:Detonate()
		end
	end

	--can't explode on impact if we're not active
	function ENT:CheckDetonate( data , physobj )
		return self:GetActive() and data.Speed > 500 and not self:GetBeingHeld()
	end

	function ENT:Detonate( attacker )
		--you never know!
		if self:IsEFlagSet( EFL_KILLME ) then
			return
		end

		self:Remove()

		local fuel = self:GetFuel()
		local atk = IsValid( attacker ) and attacker or self

		--check how much fuel was left when we impacted
		local dmg = 1.5 * fuel
		local radius = 2.5 * fuel

		util.BlastDamage( self , atk , self:GetPos() , radius , dmg )
		util.ScreenShake( self:GetPos() , 1.5 , dmg , 0.25 , radius * 2 )

		local effect = EffectData()
		effect:SetOrigin( self:GetPos() )
		effect:SetMagnitude( dmg )	--this is actually the force of the explosion
		effect:SetFlags( bit.bor( 0x80 , 0x20 ) ) --NOFIREBALLSMOKE, ROTATE
		util.Effect( "Explosion" , effect )
	end



else

	function ENT:Draw( flags )
		if GetViewEntity() == self:GetOwner() and !self:GetOwner():ShouldDrawLocalPlayer() then return end
		local pos , ang = self:GetCustomParentOrigin()

		--even though the calcabsoluteposition hook should already prevent this, it doesn't on other players
		--might as well not give it the benefit of the doubt in the first place
		if pos and ang then
			self:SetPos( pos )
			self:SetAngles( ang )
			self:SetupBones()
		end

		self:DrawModel( flags )

		local atchpos , atchang = self:GetEffectsOffset()

		local effectsscale = self:GetEffectsScale()

		--technically we shouldn't draw the fire from here, it should be done in drawtranslucent
		--but since we draw from the player and he's not translucent this won't get called despite us being translucent
		--might as well just set us to opaque

		if self:GetActive() then	-- and bit.band( flags , STUDIO_TRANSPARENCY ) ~= 0 then
			self:DrawJetpackFire( atchpos , atchang , effectsscale )
		end

		self:DrawJetpackSmoke( atchpos  , atchang , effectsscale )
	end

	--the less fuel we have, the smaller our particles will be
	function ENT:GetEffectsScale()
		return Lerp( self:GetFuel() / self:GetMaxFuel() , self.MinEffectsSize , self.MaxEffectsSize )
	end

	function ENT:GetEffectsOffset()
		local angup = self:GetAngles():Up()
		return self:GetPos() + angup * 5, angup
	end


	end



	--copied straight from the thruster code
	function ENT:DrawJetpackFire( pos , normal , scale )
		local scroll = 1000 + UnPredictedCurTime() * -10

		--the trace makes sure that the light or the flame don't end up inside walls
		--although it should be cached somehow, and only do the trace every tick

		local tracelength = 148 * scale


		if self:GetNextFlameTrace() < UnPredictedCurTime() or not self:GetLastFlameTrace() then
			local tr = {
				start = pos,
				endpos = pos + normal * tracelength,
				mask = MASK_OPAQUE,
				filter = {
					self:GetControllingPlayer(),
					self
				},
			}

			self:SetLastFlameTrace( util.TraceLine( tr ) )
			self:SetNextFlameTrace( UnPredictedCurTime() +  engine.TickInterval() )
		end

		local traceresult = self:GetLastFlameTrace()

		--what
		if not traceresult then
			return
		end

		-- traceresult.Fraction * ( 60 * scale ) / tracelength


		--TODO: fix the middle segment not being proportional to the tracelength ( and Fraction )

		render.SetMaterial( self.MatFire )

		render.StartBeam( 3 )
			render.AddBeam( pos, 8 * scale , scroll , self.JetpackFireBlue )
			render.AddBeam( pos + normal * 60 * scale , 32 * scale , scroll + 1, self.JetpackFireWhite )
			render.AddBeam( traceresult.HitPos , 32 * scale , scroll + 3, self.JetpackFireNone )
		render.EndBeam()


		render.SetMaterial( self.MatFire )

		render.StartBeam( 3 )
			render.AddBeam( pos, 100 * scale , scroll , self.JetpackFireBlue )
			render.AddBeam( pos + normal * 60 * scale , 40 * scale , scroll + 1, self.JetpackFireWhite )
			render.AddBeam( traceresult.HitPos , 32 * scale , scroll + 3, self.JetpackFireNone )
		render.EndBeam()

		scroll = scroll * 0.5

		render.UpdateRefractTexture()
		render.SetMaterial( self.MatHeatWave )
		render.StartBeam( 3 )
			render.AddBeam( pos, 8 * scale , scroll , self.JetpackFireBlue )
			render.AddBeam( pos + normal * 32 * scale, 32 * scale , scroll + 2, color_white )
			render.AddBeam( traceresult.HitPos, 48 * scale , scroll + 5, self.JetpackFireNone )
		render.EndBeam()


		scroll = scroll * 1.3
		render.SetMaterial( self.MatHeatWave )
		render.StartBeam( 3 )
			render.AddBeam( pos , 8 * scale , scroll, self.JetpackFireBlue )
			render.AddBeam( pos + normal * 60 * scale , 16 * scale , scroll + 1 , self.JetpackFireWhite )
			render.AddBeam( traceresult.HitPos , 16 * scale , scroll + 3 , self.JetpackFireNone )
		render.EndBeam()

		local light = DynamicLight( self:EntIndex() )

		if not light then
			return
		end

		light.Pos = traceresult.HitPos
		light.r = self.JetpackFireRed.r
		light.g = self.JetpackFireRed.g
		light.b = self.JetpackFireRed.b
		light.Brightness = 3
		light.Dir = normal
		light.InnerAngle = -45 --light entities in a cone
		light.OuterAngle = 45 --
		light.Size = 250 * scale -- 125 when the scale is 0.25
		light.Style = 1	--this should do the flicker for us
		light.Decay = 1000
		light.DieTime = UnPredictedCurTime() + 1
	end

	function ENT:DrawJetpackSmoke( pos , normal , scale )

		if not self.JetpackParticleEmitter then
			local emittr = ParticleEmitter( pos )
			if not emittr then
				return
			end
			self.JetpackParticleEmitter = emittr
		end

		--to prevent the smoke from drawing inside of the player when he's looking at a mirror, draw it manually if he's the local player
		--this behaviour is disabled if he's not the one actually using the jetpack ( this also happens when the jetpack is dropped and flies off )

		local particlenodraw = self:IsCarriedByLocalPlayer( true )

		self.JetpackParticleEmitter:SetNoDraw( particlenodraw )

		if self:GetNextParticle() < UnPredictedCurTime() and self:GetActive() then
			local particle = self.JetpackParticleEmitter:Add( "particle/particle_noisesphere", pos )
			if particle then
				--only increase the time on a successful particle
				self:SetNextParticle( UnPredictedCurTime() + 0.01 )
				particle:SetLighting( true )
				particle:SetCollide( true )
				particle:SetBounce( 0.25 )
				particle:SetVelocity( normal * self:GetJetpackSpeed() )
				particle:SetDieTime( 0.1 )
				particle:SetStartAlpha( 15 )
				particle:SetEndAlpha( 0 )
				particle:SetStartSize( 16 * scale )
				particle:SetEndSize( 64 * scale )
				particle:SetRoll( math.Rand( -10 , 10  ) )
				particle:SetRollDelta( math.Rand( -0.2 , 0.2 ) )
				particle:SetColor( 255 , 255 , 255 )
			end
		end

		if particlenodraw then
			self.JetpackParticleEmitter:Draw()
		end
	end



function ENT:HandleMainActivityOverride( ply , velocity )
	if self:GetActive() then
		local vel2d = velocity:Length2D()
		local idealact = ACT_INVALID

		if IsValid( ply:GetActiveWeapon() ) then
			idealact = ACT_MP_SWIM	--vel2d >= 10 and ACT_MP_SWIM or ACT_MP_SWIM_IDLE
		else
			idealact = ACT_HL2MP_IDLE + 9
		end

		if self:GetDoGroundSlam() then
			idealact = ACT_MP_CROUCH_IDLE
		end

		return idealact , ACT_INVALID
	end
end

function ENT:HandleUpdateAnimationOverride( ply , velocity , maxseqgroundspeed )
	if self:GetActive() then
		ply:SetPlaybackRate( 0 )	--don't do the full swimming animation
		return true
	end
end

function ENT:OnRemove()

	if CLIENT then

		--if stopping the soundpatch doesn't work, stop the sound manually
		if self.JetpackSound then
			self.JetpackSound:Stop()
			self.JetpackSound = nil
		else
			self:StopSound( "jetpack.thruster_loop" )
		end


		if self.JetpackParticleEmitter then
			self.JetpackParticleEmitter:Finish()
			self.JetpackParticleEmitter = nil
		end
	end

	BaseClass.OnRemove( self )
end

--PATH lua/entities/mk6.lua:
AddCSLuaFile()

if SERVER then
	resource.AddFile( "materials/entities/jetpack2.png" )
end

DEFINE_BASECLASS( "jetpack_base" )

ENT.Spawnable = false
ENT.PrintName = "Jetpack Infinite Fuel"

if CLIENT then
	ENT.MatHeatWave		= Material( "sprites/heatwave" )
	ENT.MatFire			= Material( "effects/fire_cloud1" )


	AccessorFunc( ENT , "NextParticle" , "NextParticle" )
	AccessorFunc( ENT , "LastActive" , "LastActive" )
	AccessorFunc( ENT , "LastFlameTrace" , "LastFlameTrace" )
	AccessorFunc( ENT , "NextFlameTrace" , "NextFlameTrace" )

	ENT.MaxEffectsSize = 0.25
	ENT.MinEffectsSize = 0.1



	ENT.JetpackFireBlue = Color( 0 , 0 , 255 , 128 )
	ENT.JetpackFireWhite = Color( 255 , 255 , 255 , 128 )
	ENT.JetpackFireNone = Color( 255 , 255 , 255 , 0 )
	ENT.JetpackFireRed = Color( 255 , 128 , 128 , 255 )

else

	ENT.StandaloneApeShitAngular = Vector( 0 , 10 , 10 )	--do a corkscrew
	ENT.StandaloneApeShitLinear = Vector( 0 , 0 , 0 )

	ENT.StandaloneAngular = vector_origin
	ENT.StandaloneLinear = Vector( 0 , 0 , 0 )

	ENT.ShowPickupNotice = true
	ENT.SpawnOnGroundConVar = CreateConVar(
		"sv_spawnjetpackonground" ,
		"0",
		{
			FCVAR_SERVER_CAN_EXECUTE,
			FCVAR_ARCHIVE
		},
		"When true, it will spawn the jetpack on the ground, otherwise it will try equipping it right away, if you already have one equipped it will not do anything"
	)
end

--use this to calculate the position on the parent because I can't be arsed to deal with source's parenting bullshit with local angles and position
--plus this is also called during that parenting position recompute, so it's perfect

ENT.AttachmentInfo = {
	BoneName = "ValveBiped.Bip01_Spine2",
	OffsetVec = Vector( 9 , -6 , -0.2 ),
	OffsetAng = Angle( 180 , 90 , -91 ),
}

sound.Add( {
	name = "jetpack.thruster_loop",
	channel = CHAN_ITEM,
	volume = 1.0,
	level = 75,
	sound = "^thrusters/jet02.wav"
})

local sv_gravity = GetConVar "sv_gravity"

function ENT:SpawnFunction( ply, tr, ClassName )

	if not tr.Hit then return end

	local SpawnPos = tr.HitPos + tr.HitNormal * 36

	local ent = ents.Create( ClassName )
	ent:SetSlotName( ClassName )	--this is the best place to set the slot, only modify it ingame when it's not equipped
	ent:SetPos( SpawnPos )
	ent:SetAngles( Angle( 90 , 0 , 0 ) )
	ent:Spawn()

	--try equipping it, if we can't we'll just remove it
	if not self.SpawnOnGroundConVar:GetBool() then
		--forced should not be set here, as we still kinda want the equip logic to work as normal
		if not ent:Attach( ply , false ) then
			ent:Remove()
			return
		end
	end

	return ent

end

function ENT:Initialize()
	BaseClass.Initialize( self )
	if SERVER then
		self:SetModel( "models/jetpack/jetpack.mdl" )
		self:InitPhysics()

		self:SetMaxHealth( 100 )
		self:SetHealth( self:GetMaxHealth() )

		self:SetInfiniteFuel( true )
		self:SetMaxFuel(150)
		self:SetFuel( self:GetMaxFuel() )
		self:SetFuelDrain(0)	--drain in seconds
		self:SetFuelRecharge( 0 )	--recharge in seconds
		self:SetActive( false )
		self:SetCanStomp( false )
		self:SetDoGroundSlam( false )
		self:SetAirResistance( 3.5 )
		self:SetRemoveGravity( true )
		self:SetJetpackSpeed( 2000 )
		self:SetJetpackStrafeSpeed( 500 )
		self:SetJetpackVelocity( 900 )
		self:SetJetpackStrafeVelocity( 5000 )
	else
		self:SetLastActive( false )
		self:SetNextParticle( 0 )
		self:SetNextFlameTrace( 0 )
		self:SetLastFlameTrace( nil )
	end
end

function ENT:SetupDataTables()
	BaseClass.SetupDataTables( self )

	self:DefineNWVar( "Bool" , "Active" )
	self:DefineNWVar( "Bool" , "GoneApeshit" , true )	--set either when the owner dies with us active, or when we're being shot at
	self:DefineNWVar( "Bool" , "RemoveGravity" )
	self:DefineNWVar( "Bool" , "InfiniteFuel" , true , "Infinite Fuel" )
	self:DefineNWVar( "Bool" , "DoGroundSlam" )
	self:DefineNWVar( "Bool" , "CanStomp" , true , "Can stomp" )

	self:DefineNWVar( "Float" , "Fuel" )
	self:DefineNWVar( "Float" , "MaxFuel" )	--don't modify the max amount, the drain scales anyway, set to -1 to disable the fuel drain
	self:DefineNWVar( "Float" , "FuelDrain" , true , "Seconds to drain fuel" , 1 , 60 ) --how many seconds it's gonna take to drain all the fuel
	self:DefineNWVar( "Float" , "FuelRecharge" , true , "Seconds to recharge the fuel" , 1 , 60 ) --how many seconds it should take to fully recharge this
	self:DefineNWVar( "Float" , "AirResistance" , true , "Air Resistance" , 0 , 10 )
	self:DefineNWVar( "Float" , "GoneApeshitTime" ) --only used if infinite fuel is on

	self:DefineNWVar( "Int" , "Key" )	--override it to disallow people from editing the key since it's unused
	self:DefineNWVar( "Int" , "JetpackSpeed" , true , "Jetpack idle upward speed" , 1 , 1000 )
	self:DefineNWVar( "Int" , "JetpackStrafeSpeed" , true , "Jetpack idle side speed" , 1 , 1000 )
	self:DefineNWVar( "Int" , "JetpackVelocity" , true , "Jetpack active upward speed" , 1 , 3000 )
	self:DefineNWVar( "Int" , "JetpackStrafeVelocity" , true , "Jetpack active side speed" , 1 , 3000 )

end

function ENT:HandleFly( predicted , owner , movedata , usercmd )
	self:SetActive( self:CanFly( owner , movedata ) )

	--we have infinite fuel and the apeshit timeout hasn't been set, do it now
	--this is most useful because I CBA to do that everytime ok?
	--also it's serverside only because we only set the apeshit on the server anyway

	if SERVER then
		if self:GetGoneApeshit() and self:GetGoneApeshitTime() == 0 and self:GetInfiniteFuel() then
			self:SetGoneApeshitTime( CurTime() + 5 )
		end
	end

	--the check below has to be done with prediction on the client!

	if CLIENT and not predicted then
		return
	end

	--fixes a bug where if you set goneapeshit manually via the contextmenu and the physobj is asleep it wouldn't apply the simulated forces
	if SERVER and not predicted and self:GetGoneApeshit() then
		local physobj = self:GetPhysicsObject()
		if IsValid( physobj ) and physobj:IsAsleep() then
			physobj:Wake()
		end
	end

	--if we have an apeshit timeout, calm us down ( this doesn't check for infinite fuel, in case we did this manually )
	if self:GetGoneApeshit() and self:GetGoneApeshitTime() ~= 0 and self:GetGoneApeshitTime() <= CurTime() then
		self:SetGoneApeshit( false )
		self:SetGoneApeshitTime( 0 )
	end
end

function ENT:HandleFuel( predicted )

	--like with normal rules of prediction, we don't want to run on the client if we're not in the simulation

	if not predicted and CLIENT then
		return
	end

	--we set the think rate on the entity to the tickrate on the server, we could've done NextThink() - CurTime(), but it's only a setter, not a getter
	local ft = engine.TickInterval()

	--screw that, during prediction we need to recharge with FrameTime()
	if predicted then
		ft = FrameTime()
	end

	local fueltime = self:GetActive() and self:GetFuelDrain() or self:GetFuelRecharge()

	local fuelrate = self:GetMaxFuel() / ( fueltime / ft )

	if self:GetActive() then
		fuelrate = fuelrate * -1

		if self:GetGoneApeshit() then
			--drain twice as much fuel if we're going craaaazy
			fuelrate = fuelrate * 2
		end

		--don't drain any fuel when infinite fuel is on, but still allow recharge
		if self:GetInfiniteFuel() then
			fuelrate = 0
		end
	else
		--recharge in different ways if we have an owner or not, because players might drop and reequip the jetpack to exploit the recharging
		if IsValid( self:GetControllingPlayer() ) then
			--can't recharge until our owner is on the ground!
			--prevents the player from tapping the jump button to fly and recharge at the same time
			if not self:GetControllingPlayer():OnGround() then
				fuelrate = 0
			end
		else
			--only recharge if our physobj is sleeping and it's valid ( should never be invalid in the first place )
			local physobj = self:GetPhysicsObject()
			if not IsValid( physobj ) or not physobj:IsAsleep() then
				fuelrate = 0
			end
		end
	end

	--holy shit, optimization??
	if fuelrate ~= 0 then
		self:SetFuel( math.Clamp( self:GetFuel() + fuelrate , 0 , self:GetMaxFuel() ) )
	end

	--we exhausted all of our fuel, chill out if we're crazy
	if not self:HasFuel() and self:GetGoneApeshit() then
		self:SetGoneApeshit( false )
	end
end

function ENT:HandleLoopingSounds()

	--create the soundpatch if it doesn't exist, it might happen on the client sometimes since it's garbage collected

	if not self.JetpackSound then
		self.JetpackSound = CreateSound( self, "jetpack.thruster_loop" )
	end

	if self:GetActive() then
		local pitch = 125

		if self:GetGoneApeshit() then
			pitch = 175
		end

		self.JetpackSound:PlayEx( 0.5  , pitch )
	else
		self.JetpackSound:FadeOut( 0.1 )
	end
end

function ENT:HasFuel()
	return self:GetFuel() > 0
end

function ENT:GetFuelFraction()
	return self:GetFuel() / self:GetMaxFuel()
end

function ENT:CanFly( owner , mv )


	if IsValid( owner ) then

		--don't care about player inputs in this case, the player's jetpack is going craaazy

		if self:GetGoneApeshit() then
			return owner:WaterLevel() == 0 and owner:GetMoveType() == MOVETYPE_WALK and self:HasFuel()
		end

		return ( mv:KeyDown( IN_JUMP ) or mv:KeyDown( IN_DUCK ) or mv:KeyDown( IN_SPEED ) ) and not owner:OnGround() and owner:WaterLevel() == 0 and owner:GetMoveType() == MOVETYPE_WALK and owner:Alive() and self:HasFuel()
	end

	--making it so the jetpack can also fly on its own without an owner ( in the case we want it go go nuts if the player dies or some shit )
	if self:GetGoneApeshit() then
		return self:WaterLevel() == 0 and self:HasFuel()
	end

	return false
end

function ENT:Think()

	--still act if we're not being held by a player
	if not self:IsCarried() then
		self:HandleFly( false )
		self:HandleFuel( false )
	end

	--animation related stuff should be fine to call here



	return BaseClass.Think( self )
end

function ENT:PredictedSetupMove( owner , mv , usercmd )

	self:HandleFly( true , owner , mv , usercmd )
	self:HandleFuel( true )

	if self:GetActive() then

		local vel = mv:GetVelocity()

		if mv:KeyDown( IN_JUMP ) and vel.z < self:GetJetpackSpeed() then

			-- Apply constant jetpack_velocity

			vel.z = vel.z + self:GetJetpackVelocity() * FrameTime()

		elseif mv:KeyDown( IN_SPEED ) and vel.z < 0 then

			-- Apply just the right amount of thrust

			vel.z = math.Approach( vel.z , 0 , self:GetJetpackVelocity() * FrameTime() )

		end



		-- Quickly descend to do a ground slam, don't check for the velocity cap, we want to slam down as fast as we can
		if self:GetCanStomp() then
			self:SetDoGroundSlam( mv:KeyDown( IN_DUCK ) )
		end

		--even if the user can't stomp, we still allow him to go down by crouching

		if mv:KeyDown( IN_DUCK ) then
			vel.z = vel.z - self:GetJetpackVelocity() * FrameTime()
		end

		--
		-- Remove gravity when velocity is supposed to be zero for hover mode
		--

		if vel.z == 0 then

			self:SetRemoveGravity( true )

			vel.z = vel.z + sv_gravity:GetFloat() * 0.5 * FrameTime()

		end

		--
		-- Apply movement velocity
		--

		local move_vel = Vector( 0, 0, 0 )

		local ang = mv:GetMoveAngles()
		ang.p = 0

		move_vel:Add( ang:Right() * mv:GetSideSpeed() )
		move_vel:Add( ang:Forward() * mv:GetForwardSpeed() )

		move_vel:Normalize()
		move_vel:Mul( self:GetJetpackStrafeVelocity() * FrameTime() )

		if vel:Length2D() < self:GetJetpackStrafeSpeed() then

			vel:Add( move_vel )

		end

		--TODO: goneapeshit stuff, do it before air resistance

		if self:GetGoneApeshit() then
			--boost us in the direction the jetpack is facing in the world ( actual third person angles )
			--ragdolling the user and attaching us to the ragdoll would be quite expensive and wouldn't be worth it
			--as cool as that might look, that might also break stuff in other gamemodes

			local addvel = self:GetAngles():Up() * -1 * self:GetJetpackVelocity() * FrameTime()
			vel:Add( addvel )
		end

		--
		-- Apply air resistance
		--
		vel.x = math.Approach( vel.x, 0, FrameTime() * self:GetAirResistance() * vel.x )
		vel.y = math.Approach( vel.y, 0, FrameTime() * self:GetAirResistance() * vel.y )

		--
		-- Write our calculated velocity back to the CMoveData structure
		--
		mv:SetVelocity( vel )

		mv:SetForwardSpeed( 0 )
		mv:SetSideSpeed( 0 )
		mv:SetUpSpeed( 0 )

		-- Removes the crouch button from the movedata, effectively disabling the crouching behaviour

		mv:SetButtons( bit.band( mv:GetButtons(), bit.bnot( IN_DUCK ) ) )

	end
end

function ENT:PredictedThink( owner , movedata )
end

function ENT:PredictedMove( owner , data )
	if self:GetActive() and self:GetGoneApeshit() then
		owner:SetGroundEntity( NULL )
	end
end

function ENT:PredictedFinishMove( owner , movedata )
	if self:GetActive() then

		--
		-- Remove gravity when velocity is supposed to be zero for hover mode
		--
		if self:GetRemoveGravity() then
			local vel = movedata:GetVelocity()

			vel.z = vel.z + sv_gravity:GetFloat() * 0.5 * FrameTime()

			movedata:SetVelocity( vel )

			self:SetRemoveGravity( false )
		end

	end
end

local	SF_PHYSEXPLOSION_NODAMAGE			=	0x0001
local	SF_PHYSEXPLOSION_PUSH_PLAYER		=	0x0002
local	SF_PHYSEXPLOSION_RADIAL				=	0x0004
local	SF_PHYSEXPLOSION_TEST_LOS			=	0x0008
local	SF_PHYSEXPLOSION_DISORIENT_PLAYER	=	0x0010

function ENT:PredictedHitGround( ply , inwater , onfloater , speed )

	local dogroundslam = self:GetDoGroundSlam()
	self:SetDoGroundSlam( false )

	if dogroundslam and speed > 500 then

		self:EmitPESound( "Player.FallDamage" , nil , nil , nil , nil , true )
		--ply:EmitSound( "Player.FallDamage" )
		--self:EmitPESound( "" , nil , nil , nil , nil , true )	--find the sound smod uses when the player hits the ground in smod

		local fraction = self:GetJetpackStrafeVelocity() / speed	--because the fall speed might be higher than the jetpack one

		local effect = EffectData()
		effect:SetEntity( ply )
		effect:SetOrigin( ply:WorldSpaceCenter() )	--apparently the player is considered in the ground in this hook and stuff doesn't spawn
		effect:SetScale( 128 )
		util.Effect( "ThumperDust" , effect , true )	--todo, make our own effect where the particles start from the player and expand in a circle
														--can even copy the code from c_thumper_dust
		if SERVER then
			--TODO: get the code from the sdk and replicate this on my own
			ply:LagCompensation( true )

			--[[
			local physexpl = ents.Create( "env_physexplosion" )

			if IsValid( physexpl ) then
				physexpl:SetPos( ply:WorldSpaceCenter() )
				physexpl:SetKeyValue( "spawnflags" , bit.bor( SF_PHYSEXPLOSION_NODAMAGE , SF_PHYSEXPLOSION_RADIAL , SF_PHYSEXPLOSION_TEST_LOS ) )
				physexpl:SetKeyValue( "magnitude" , 500 * fraction )
				physexpl:SetKeyValue( "radius" , 250 )
				physexpl:Spawn()
				physexpl:Fire( "Explode" , "" , 0 )
				physexpl:Fire( "Kill" , "" , 0.1 )
			end
			]]



			--this is kind of shit but it's needed to make prediction actually work properly on this screenshake shit
			if SERVER and not game.SinglePlayer() then
				SuppressHostEvents( ply )
			end

			util.ScreenShake( self:GetPos() , 1.5 , 250 , 1 , 500 )

			if SERVER and not game.SinglePlayer() then
				SuppressHostEvents( NULL )
			end

			ply:LagCompensation( false )
		end

		ply:AnimRestartGesture( GESTURE_SLOT_JUMP, ACT_LAND, true )
		return true	--override the fall damage and other hooks
	end
end

if SERVER then

	function ENT:OnTakeDamage( dmginfo )
		--we're already dead , might happen if multiple jetpacks explode at the same time
		if self:Health() <= 0 then
			return
		end

		self:TakePhysicsDamage( dmginfo )

		local oldhealth = self:Health()

		local newhealth = math.Clamp( self:Health() - dmginfo:GetDamage() , 0 , self:GetMaxHealth() )
		self:SetHealth( newhealth )

		if self:Health() <= 0 then
			--maybe something is relaying damage to the jetpack instead, an explosion maybe?
			if IsValid( self:GetControllingPlayer() ) then
				self:Remove( true )
			end
			self:Detonate( dmginfo:GetAttacker() )
			return
		end

		--roll a random, if we're not being held by a player and the random succeeds, go apeshit
		if dmginfo:GetDamage() > 3 and not self:GetGoneApeshit() then
			local rand = math.random( 1 , 10 )
			if rand <= 2 then
				if IsValid( self:GetControllingPlayer() ) then
					self:Remove( true )
				end
				self:SetGoneApeshit( true )
			end
		end
	end

	function ENT:OnAttach( ply )
		self:SetDoGroundSlam( false )
		--self:SetSolid( SOLID_BBOX )	--we can still be hit when on the player's back
	end

	function ENT:CanAttach( ply )
		if self:GetGoneApeshit() then
			return false
		end
	end

	function ENT:OnDrop( ply , forced )
		if IsValid( ply ) and not ply:Alive() then
			--when the player dies while still using us, keep us active and let us fly with physics until
			--our fuel runs out
			if self:GetActive() then
				self:SetGoneApeshit( true )
			end
		else
			self:SetActive( false )
		end

	end

	function ENT:OnInitPhysics( physobj )
		if IsValid( physobj ) then
			physobj:SetMass( 75 )
			self:StartMotionController()
		end
		self:SetCollisionGroup( COLLISION_GROUP_NONE )
		--self:SetCollisionGroup( COLLISION_GROUP_WEAPON )	--set to COLLISION_GROUP_NONE to reenable collisions against players and npcs
	end

	function ENT:OnRemovePhysics( physobj )
		self:StopMotionController()
		self:SetCollisionGroup( COLLISION_GROUP_DEBRIS_TRIGGER )
		--self:SetCollisionGroup( COLLISION_GROUP_DEBRIS )
	end

	function ENT:PhysicsSimulate( physobj , delta )

		--no point in applying forces and stuff if something is holding our physobj

		if self:GetActive() and not self:GetBeingHeld() then
			physobj:Wake()
			local force = self.StandaloneLinear
			local angular = self.StandaloneAngular

			if self:GetGoneApeshit() then
				force = self.StandaloneApeShitLinear
				angular = self.StandaloneApeShitAngular
			end

			--yes I know we're technically modifying the variable stored in ENT.StandaloneApeShitLinear and that it might fuck up other jetpacks
			--but it won't because we're simply using it as a cached vector_origin and overriding the z anyway
			force.z = -self:GetJetpackVelocity()

			return angular * physobj:GetMass() , force * physobj:GetMass() , SIM_LOCAL_FORCE
		end
	end

	function ENT:PhysicsCollide( data , physobj )
		--taken straight from valve's code, it's needed since garry overwrote VPhysicsCollision, friction sound is still there though
		--because he didn't override the VPhysicsFriction
		if data.DeltaTime >= 0.05 and data.Speed >= 70 then
			local volume = data.Speed * data.Speed * ( 1 / ( 320 * 320 ) )
			if volume > 1 then
				volume = 1
			end

			--TODO: find a better impact sound for this model
			self:EmitSound( "SolidMetal.ImpactHard" , nil , nil , volume , CHAN_BODY )
		end

		if self:CheckDetonate( data , physobj ) then
			self:Detonate()
		end
	end

	--can't explode on impact if we're not active
	function ENT:CheckDetonate( data , physobj )
		return self:GetActive() and data.Speed > 500 and not self:GetBeingHeld()
	end

	function ENT:Detonate( attacker )
		--you never know!
		if self:IsEFlagSet( EFL_KILLME ) then
			return
		end

		self:Remove()

		local fuel = self:GetFuel()
		local atk = IsValid( attacker ) and attacker or self

		--check how much fuel was left when we impacted
		local dmg = 1.5 * fuel
		local radius = 2.5 * fuel

		util.BlastDamage( self , atk , self:GetPos() , radius , dmg )
		util.ScreenShake( self:GetPos() , 1.5 , dmg , 0.25 , radius * 2 )

		local effect = EffectData()
		effect:SetOrigin( self:GetPos() )
		effect:SetMagnitude( dmg )	--this is actually the force of the explosion
		effect:SetFlags( bit.bor( 0x80 , 0x20 ) ) --NOFIREBALLSMOKE, ROTATE
		util.Effect( "Explosion" , effect )
	end



else

	function ENT:Draw( flags )
		if GetViewEntity() == self:GetOwner() and !self:GetOwner():ShouldDrawLocalPlayer() then return end
		local pos , ang = self:GetCustomParentOrigin()

		--even though the calcabsoluteposition hook should already prevent this, it doesn't on other players
		--might as well not give it the benefit of the doubt in the first place
		if pos and ang then
			self:SetPos( pos )
			self:SetAngles( ang )
			self:SetupBones()
		end

		self:DrawModel( flags )

		local atchpos , atchang = self:GetEffectsOffset()

		local effectsscale = self:GetEffectsScale()

		--technically we shouldn't draw the fire from here, it should be done in drawtranslucent
		--but since we draw from the player and he's not translucent this won't get called despite us being translucent
		--might as well just set us to opaque

		if self:GetActive() then	-- and bit.band( flags , STUDIO_TRANSPARENCY ) ~= 0 then
			self:DrawJetpackFire( atchpos , atchang , effectsscale )
		end

		self:DrawJetpackSmoke( atchpos  , atchang , effectsscale )
	end

	--the less fuel we have, the smaller our particles will be
	function ENT:GetEffectsScale()
		return Lerp( self:GetFuel() / self:GetMaxFuel() , self.MinEffectsSize , self.MaxEffectsSize )
	end

	function ENT:GetEffectsOffset()
		local angup = self:GetAngles():Up()
		return self:GetPos() + angup * 5, angup
	end


	end



	--copied straight from the thruster code
	function ENT:DrawJetpackFire( pos , normal , scale )
		local scroll = 1000 + UnPredictedCurTime() * -10

		--the trace makes sure that the light or the flame don't end up inside walls
		--although it should be cached somehow, and only do the trace every tick

		local tracelength = 148 * scale


		if self:GetNextFlameTrace() < UnPredictedCurTime() or not self:GetLastFlameTrace() then
			local tr = {
				start = pos,
				endpos = pos + normal * tracelength,
				mask = MASK_OPAQUE,
				filter = {
					self:GetControllingPlayer(),
					self
				},
			}

			self:SetLastFlameTrace( util.TraceLine( tr ) )
			self:SetNextFlameTrace( UnPredictedCurTime() +  engine.TickInterval() )
		end

		local traceresult = self:GetLastFlameTrace()

		--what
		if not traceresult then
			return
		end

		-- traceresult.Fraction * ( 60 * scale ) / tracelength


		--TODO: fix the middle segment not being proportional to the tracelength ( and Fraction )

		render.SetMaterial( self.MatFire )

		render.StartBeam( 3 )
			render.AddBeam( pos, 8 * scale , scroll , self.JetpackFireBlue )
			render.AddBeam( pos + normal * 60 * scale , 32 * scale , scroll + 1, self.JetpackFireWhite )
			render.AddBeam( traceresult.HitPos , 32 * scale , scroll + 3, self.JetpackFireNone )
		render.EndBeam()


		render.SetMaterial( self.MatFire )

		render.StartBeam( 3 )
			render.AddBeam( pos, 100 * scale , scroll , self.JetpackFireBlue )
			render.AddBeam( pos + normal * 60 * scale , 40 * scale , scroll + 1, self.JetpackFireWhite )
			render.AddBeam( traceresult.HitPos , 32 * scale , scroll + 3, self.JetpackFireNone )
		render.EndBeam()

		scroll = scroll * 0.5

		render.UpdateRefractTexture()
		render.SetMaterial( self.MatHeatWave )
		render.StartBeam( 3 )
			render.AddBeam( pos, 8 * scale , scroll , self.JetpackFireBlue )
			render.AddBeam( pos + normal * 32 * scale, 32 * scale , scroll + 2, color_white )
			render.AddBeam( traceresult.HitPos, 48 * scale , scroll + 5, self.JetpackFireNone )
		render.EndBeam()


		scroll = scroll * 1.3
		render.SetMaterial( self.MatHeatWave )
		render.StartBeam( 3 )
			render.AddBeam( pos , 8 * scale , scroll, self.JetpackFireBlue )
			render.AddBeam( pos + normal * 60 * scale , 16 * scale , scroll + 1 , self.JetpackFireWhite )
			render.AddBeam( traceresult.HitPos , 16 * scale , scroll + 3 , self.JetpackFireNone )
		render.EndBeam()

		local light = DynamicLight( self:EntIndex() )

		if not light then
			return
		end

		light.Pos = traceresult.HitPos
		light.r = self.JetpackFireRed.r
		light.g = self.JetpackFireRed.g
		light.b = self.JetpackFireRed.b
		light.Brightness = 3
		light.Dir = normal
		light.InnerAngle = -45 --light entities in a cone
		light.OuterAngle = 45 --
		light.Size = 250 * scale -- 125 when the scale is 0.25
		light.Style = 1	--this should do the flicker for us
		light.Decay = 1000
		light.DieTime = UnPredictedCurTime() + 1
	end

	function ENT:DrawJetpackSmoke( pos , normal , scale )

		if not self.JetpackParticleEmitter then
			local emittr = ParticleEmitter( pos )
			if not emittr then
				return
			end
			self.JetpackParticleEmitter = emittr
		end

		--to prevent the smoke from drawing inside of the player when he's looking at a mirror, draw it manually if he's the local player
		--this behaviour is disabled if he's not the one actually using the jetpack ( this also happens when the jetpack is dropped and flies off )

		local particlenodraw = self:IsCarriedByLocalPlayer( true )

		self.JetpackParticleEmitter:SetNoDraw( particlenodraw )

		if self:GetNextParticle() < UnPredictedCurTime() and self:GetActive() then
			local particle = self.JetpackParticleEmitter:Add( "particle/particle_noisesphere", pos )
			if particle then
				--only increase the time on a successful particle
				self:SetNextParticle( UnPredictedCurTime() + 0.01 )
				particle:SetLighting( true )
				particle:SetCollide( true )
				particle:SetBounce( 0.25 )
				particle:SetVelocity( normal * self:GetJetpackSpeed() )
				particle:SetDieTime( 0.1 )
				particle:SetStartAlpha( 15 )
				particle:SetEndAlpha( 0 )
				particle:SetStartSize( 16 * scale )
				particle:SetEndSize( 64 * scale )
				particle:SetRoll( math.Rand( -10 , 10  ) )
				particle:SetRollDelta( math.Rand( -0.2 , 0.2 ) )
				particle:SetColor( 255 , 255 , 255 )
			end
		end

		if particlenodraw then
			self.JetpackParticleEmitter:Draw()
		end
	end



function ENT:HandleMainActivityOverride( ply , velocity )
	if self:GetActive() then
		local vel2d = velocity:Length2D()
		local idealact = ACT_INVALID

		if IsValid( ply:GetActiveWeapon() ) then
			idealact = ACT_MP_SWIM	--vel2d >= 10 and ACT_MP_SWIM or ACT_MP_SWIM_IDLE
		else
			idealact = ACT_HL2MP_IDLE + 9
		end

		if self:GetDoGroundSlam() then
			idealact = ACT_MP_CROUCH_IDLE
		end

		return idealact , ACT_INVALID
	end
end

function ENT:HandleUpdateAnimationOverride( ply , velocity , maxseqgroundspeed )
	if self:GetActive() then
		ply:SetPlaybackRate( 0 )	--don't do the full swimming animation
		return true
	end
end

function ENT:OnRemove()

	if CLIENT then

		--if stopping the soundpatch doesn't work, stop the sound manually
		if self.JetpackSound then
			self.JetpackSound:Stop()
			self.JetpackSound = nil
		else
			self:StopSound( "jetpack.thruster_loop" )
		end


		if self.JetpackParticleEmitter then
			self.JetpackParticleEmitter:Finish()
			self.JetpackParticleEmitter = nil
		end
	end

	BaseClass.OnRemove( self )
end

--PATH lua/entities/model_base.lua:
return gluapack()()
--PATH lua/entities/model_base.lua:
AddCSLuaFile()

--[[
	An entity base that allows you to create entity that can be equipped by the player as if they were weapons or powerups, but that can still
	function when not picked up by a player

	For instance you could make a jetpack that flies off when the equipping player dies, or you can make a controllable plane but still allow
	full movement on the player

	This file is licensed under the MIT license, so go nuts.
]]

DEFINE_BASECLASS( "base_entity" )

ENT.UseNWVars = false

ENT.Spawnable = false
ENT.IsPredictedEnt = true
ENT.AttachesToPlayer = true	--whether this entity attaches to the player or not, when true this removes physics and draws the entity on the player

ENT.SaveButtonToCvar = false

if SERVER then
	ENT.DropOnDeath = false
	ENT.ShowPickupNotice = true	--plays the pickup sound and shows the pickup message on the hud
	ENT.DontTransmitToOthers = false --when true, don't transmit to anyone except the owner, this MIGHT conflict with addons that make use of SetPreventTransmit, so mind that!
	ENT.ShouldLagCompensate = true 	--automatically enables/disables lag compensation when physics are created and destroyed, might be annoying for some so disable this if you want
else
	ENT.RenderGroup = RENDERGROUP_OPAQUE
end

ENT.Editable = false

ENT.KeyAllowedKeyboard = 2 ^ 0
ENT.KeyAllowedMouse = 2 ^ 1
ENT.KeyAllowedJoystick = 2 ^ 2

ENT.KeyAllowedAll = bit.bor( ENT.KeyAllowedKeyboard , ENT.KeyAllowedMouse , ENT.KeyAllowedJoystick )

ENT.KeyAllowedFlags = ENT.KeyAllowedAll	--bitflag of the key types you want to use

ENT.HookAlways = 1 --hooks in here always run
ENT.HookEquipped = 2 --hooks in here are only added when the entity is equipped by user, and removed when unequipped
ENT.HookEquippedPrediction = 3 --like above, but on the client, only for the LocalPlayer() equipping this
ENT.HookCallback = 4 --these are callbacks handled with AddCallback, unfortunately we have no way to fully handle these

--example attachment info table, only used if AttachesToPlayer is true
--[[
ENT.AttachmentInfo = {
	BoneName = "ValveBiped.Bip01_Spine2",
	OffsetVec = Vector( 3 , -5.6 , 0 ),
	OffsetAng = Angle( 180 , 90 , -90 ),
}
]]

--[[
	This is a wrapper for NetworkVars/DTVars (same thing) so we can handle their slots properly for child classes instead
	of having to modify them manually everytime something changes in order

	This could be switched to NWVars2 (vinh vars) but then I would have to hack in support for right-click editing, since that's
	based on NetworkVars and some other getters
]]
function ENT:DefineNWVar( dttype , dtname , editable , beautifulname , minval , maxval , customelement , filt )

	if not self.DefinedDTVars[dttype] then
		Error( "Wrong NWVar type " .. ( dttype or "nil" ) )
		return
	end

	local index = -1

	--only do this check for limited dtvars, once we switch to NWVars in :NetworkVar this check will go away
	if not self.UseNWVars then
		local maxindex = self.DefinedDTVars[dttype].Max

		for i = 0 , maxindex - 1 do
			--we either didn't find anything in this slot or we found the requested one again
			--in which case just override it again, someone might want to inherit and add an edit table or something
			if not self.DefinedDTVars[dttype][i] or self.DefinedDTVars[dttype][i] == dtname then
				index = i
				break
			end
		end

		if index == -1 then
			Error( "Not enough slots on "..dttype .. ",	could not add ".. dtname )
			return
		end
	else
		index = dtname:lower()
	end

	self.DefinedDTVars[dttype][index] = dtname

	local edit = nil

	--this used to check if we could actually add the edit table, so we default it to nil to override it again
	--in case of a child class

	if editable then
		edit = {
			KeyName = dtname:lower(),
			Edit = {
				title = beautifulname or dtname,	--doesn't it do this internally already?
				min = minval,
				max = maxval,
				type = customelement or self.DefinedDTVars[dttype].EditableElement,
			}
		}
	end

	self:NetworkVar( dttype , index , dtname , edit )
end

function ENT:SetupDataTables()

	--if the user is in the branch that has the NWVars change then automatically switch to this
	if self.CallNetworkProxies then
		self.UseNWVars = true
	end

	--eventually I'll create more editable elements based on garry's system

	self.DefinedDTVars = {
		Entity = {
			Max = GMOD_MAXDTVARS,
		},
		Float = {
			Max = GMOD_MAXDTVARS,
			EditableElement = "Float",
		},
		Int = {
			Max = GMOD_MAXDTVARS,
			EditableElement = "Int",
		},
		Bool = {
			Max = GMOD_MAXDTVARS,
			EditableElement = "Boolean",
		},
		Vector = {
			Max = GMOD_MAXDTVARS,
		},
		Angle = {
			Max = GMOD_MAXDTVARS,
		},
		String = {
			Max = 4,
			EditableElement = "Generic",
		},
	}

	self:DefineNWVar( "Entity" , "ControllingPlayer" )
	self:DefineNWVar( "Bool" , "BeingHeld" )
	self:DefineNWVar( "String" , "SlotName" )
	self:DefineNWVar( "Float" , "NextFire" ) --similar to primaryattack on a weapon

	--only allow the user to modify the button if the coder wants this entity to have an usable key

	self:DefineNWVar( "Int" , "Key" , true , "Button" , BUTTON_CODE_NONE + 1 , BUTTON_CODE_LAST , "EditKey" )
	self:DefineNWVar( "Bool" , "KeyPressed" )
end

function ENT:Initialize()

	self.HandledHooks = {
		[self.HookAlways] = {},
		[self.HookEquipped] = {},
		[self.HookEquippedPrediction] = {},
		[self.HookCallback] = {}
	}

	self.HookConditions = {
		[self.HookAlways] = function( ent )
			return true
		end,
		[self.HookEquipped] = function( ent )
			return ent:IsCarried()
		end,
		[self.HookEquippedPrediction] = function( ent )
			if SERVER then
				return ent:IsCarried() --self.HookConditions[self.HookEquipped]( self )
			else
				return ent:IsCarriedByLocalPlayer()
			end
		end,
		[self.HookCallback] = function( self )
			return nil --nil means don't handle me
		end,
	}

	--predicted hooks hooking with hookers and futurama memes
	self:InstallHook( "StartCommand" , self.HandlePredictedStartCommand , self.HookEquippedPrediction )
	self:InstallHook( "SetupMove" , self.HandlePredictedSetupMove , self.HookEquippedPrediction )
	self:InstallHook( "Move" , self.HandlePredictedMove , self.HookEquippedPrediction )
	self:InstallHook( "PlayerTick" , self.HandlePredictedThink , self.HookEquippedPrediction )
	self:InstallHook( "FinishMove" , self.HandlePredictedFinishMove , self.HookEquippedPrediction )
	self:InstallHook( "OnPlayerHitGround" , self.HandlePredictedHitGround , self.HookEquippedPrediction )
	self:InstallHook( "PlayerButtonDown" , self.HandlePlayerButtonDown , self.HookEquippedPrediction )
	self:InstallHook( "PlayerButtonUp" , self.HandlePlayerButtonUp , self.HookEquippedPrediction )


	self:InstallHook( "CalcMainActivity" , self.HandleCalcMainActivity , self.HookEquipped )
	self:InstallHook( "UpdateAnimation" , self.HandleUpdateAnimation , self.HookEquipped )
	self:InstallHook( "DoAnimationEvent" , self.HandleAnimationEvent , self.HookEquipped )


	if SERVER then
		self:InstallHook( "SetupPlayerVisibility" , self.HandleEntityVisibility , self.HookAlways )
		self:InstallHook( "EntityRemoved" , self.OnControllerRemoved , self.HookAlways )
		self:InstallHook( "PostPlayerDeath" , self.OnControllerDeath , self.HookAlways )	--using PostPlayerDeath as it's called on all kind of player deaths, even :KillSilent()
		self:InstallHook( "CanEditVariable" , self.HandleCanEditVariable , self.HookAlways )

		--just in case it has been spawned manually and the coder forgot
		if self:GetSlotName() == "" then
			ErrorNoHalt( self:GetClass() .. " was spawned without a slotname!!!!. Defaulting to classname\n" )
			self:SetSlotName( self:GetClass() )
		end

		self:SetUseType( SIMPLE_USE )
		self:SetKey( BUTTON_CODE_NONE )
	else
		self:InstallHook( "PreDrawEffects" , self.DrawFirstPersonInternal , self.HookEquipped )
		self:InstallHook( "PostDrawViewModel" , self.DrawViewModelInternal , self.HookEquipped )
		self:InstallHook( "PostPlayerDraw" , self.DrawOnPlayer , self.HookEquipped )

		self:InstallHook( "NotifyShouldTransmit" , self.HandleFullPacketUpdate , self.HookAlways )

		language.Add( self:GetClass() , self.PrintName )
		language.Add( "dropped_"..self:GetClass() , "Dropped "..self.PrintName )
	end
end

--This is needed mostly for clientside hooks, since IsValid might return false when we're out of PVS with some bad lag
--and when hook.Call tries to call on an invalid entity it removes the hook, so we need to reinstall them when that happens and the entity gets back in the PVS
--prediction and other shit like drawing on a player might fuck up since the hooks got removed
--Now this also works for adding a callback

function ENT:InstallHook( hookname , handler , hooktype )

	if self.HandledHooks[hooktype] == nil then
		hooktype = self.HookAlways
	end

	self.HandledHooks[hooktype][hookname] = handler

	if hooktype == self.HookCallback then
		self:AddCallback( hookname , handler )
	end

end

function ENT:HandleHooks( cleanup )

	--this is direct access to the hook table, but it's not slow at all
	--or at least, it shouldn't be as long as you don't have any ulib shit or some other hook overrides
	local hooktable = hook.GetTable()



	for hookindex , handledshooktab in pairs( self.HandledHooks ) do
		local condition = self.HookConditions[hookindex]( self )

		if condition ~= nil then
			for i , v in pairs( handledshooktab ) do
				if condition and not cleanup then
					if not hooktable[i] or not hooktable[i][self] then
						hook.Add( i , self , v )
					end
				else
					if hooktable[i] and hooktable[i][self] then
						hook.Remove( i , self )
					end
				end
			end
		end
	end

end

function ENT:Think()

	self:HandleHooks()

	if SERVER then

		--check if this guy is still my parent and owner, maybe something is forcibly unparenting us from him, if so, drop
		if self.AttachesToPlayer and self:IsCarried() then
			if not self:IsAttached() then
				self:Remove( true )
			end
		end

		--we have to network this ourselves since it's based on the physics object ( which is mainly serverside )
		--the reason I'm networking this is that due to the gravity gun enabling prediction, it would screw with the manual
		--predictable logic of this entity, so when we try to activate prediction, we check if we're being carried by the gravity gun
		--to prevent disabling it

		--NOTE: this is not as expensive as it looks, it just checks for the FVPHYSICS_PLAYER_HELD flag on our physobj
		self:SetBeingHeld( self:IsPlayerHolding() )
	else
		--calling this in a non-predicted hook is perfectly fine, since we need the entity to enable prediction on its own
		--even when controlling players change

		--Ideally this would be handled on the callback of SetControllingPlayer clientside, but we don't have that yet
		self:HandlePrediction()
		self:HandleButtonBind()
		self:HandleContextMenuButton()
		self:InternalHandleLoopingSounds()
	end

	--set our think rate to be in line with the server tickrate
	--this may also affect animations clientside if they're ran in this hook, considering that also happens in normal source
	--I'd say that's an accurate replication of the issue

	--default behaviour for scripted entities is to think every 200 milliseconds
	--I suppose this should be configurable by child entities

	self:NextThink( CurTime() + engine.TickInterval() )
	return true
end

if SERVER then

	--for map inputs mostly, but other addons may also be using these inputs trough ent:Input or ent:Fire
	--more inputs might come in the future
	--of course child entities are free to call the baseclass function after their own to chain stuff

	function ENT:AcceptInput( inputName, activator, called, data )

		if inputName == "Drop" then
			self:Drop( true )
			return true
		end

		if inputName == "SetSlotName" then
			if self:IsCarried() or not data or #data <= 1 or data == self:GetSlotName() then
				return false
			end

			self:SetSlotName( data )
			return true
		end

	end

	--although we should probably do validity checks on them first, but considering this would *probably* be called from maps it should be ok
	--copied from env_skypaint, allows to have the DT vars set as if they were key values

	function ENT:KeyValue( key, value )

		if self:SetNetworkKeyValue( key, value ) then
			return
		end

	end

	function ENT:ChangeSlot( newslotname )
		local oldslotname = self:GetSlotName()

		if newslotname == oldslotname then
			return false
		end

		local ply = self:GetControllingPlayer()

		--if we have a controlling player and he has an entity in the new slot, abort
		if IsValid( ply ) and IsValid( self.GetOnPlayer( ply , newslotname ) ) then
			--this slot is already occupied!!!
			return false
		end

		if IsValid( ply ) then
			self.SetOnPlayer( ply , oldslotname , NULL )
			self.SetOnPlayer( ply , newslotname , self )
		end

		self:SetSlotName( newslotname )

		return true
	end

	--useful for swapping out two slots at the same time and knowing the other entity,
	--usually in an inventory system
	function ENT:SwapSlotWith( predent )
		local ply = self:GetControllingPlayer()

		if not self:IsCarriedBy( ply ) or not IsValid( predent ) or not predent.IsPredictedEnt
		or not predent:IsCarriedBy( ply ) then
			return false
		end

		local myslot = self:GetSlotName()
		local otherslot = predent:GetSlotName()

		self.SetOnPlayer( ply , otherslot , self )
		self.SetOnPlayer( ply , myslot , predent )

		self:SetSlotName( otherslot )
		predent:SetSlotName( myslot )

		return true
	end

	--override this if you want your equip logic to be different
	function ENT:Use( activator, caller, useType, value )
		if not self:Attach( activator ) then
			self:EmitPESound( "HL2Player.UseDeny" , 150 , nil , 1 , nil , nil , activator )
		end
	end

	function ENT:InitPhysics()
		--don't actually initialize the physics if we're getting removed anyway
		if self:IsEFlagSet( EFL_KILLME ) then
			return
		end


		if self.ShouldLagCompensate then
			self:SetLagCompensated( true )
		end

		self:DoInitPhysics()
		self:OnInitPhysics( self:GetPhysicsObject() )
	end

	function ENT:DoInitPhysics()
		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )
		self:PhysWake()
	end

	function ENT:RemovePhysics()

		if self.AttachesToPlayer and self.ShouldLagCompensate then
			self:SetLagCompensated( false )	--entities that are attached to players will be moved back when the player is, so don't make them lag compensate on their own
		end

		self:OnRemovePhysics( self:GetPhysicsObject() )
		self:DoRemovePhysics()
	end

	function ENT:DoRemovePhysics()
		self:PhysicsDestroy()
		self:SetMoveType( MOVETYPE_NONE )
		self:SetSolid( SOLID_NONE )
	end

	function ENT:OnAttach( ply , forced )
		--override me
	end

	function ENT:CanAttach( ply )
		--override me
	end

	function ENT:OnDrop( ply , forced )
		--override me
	end

	function ENT:CanDrop( ply )
		--override me
	end

	--these two are not necessarely duplicates of the functions above because we may want to modify the mass
	--as soon as the physobj gets created, and that also happens in initialize

	function ENT:OnInitPhysics( physobj )
		--override me
	end

	function ENT:OnRemovePhysics( physobj )
		--override me
	end

	--being attached forcibly is usually something that happens when you want to spawn the player with this item, and you
	--don't want gamemode logic to interfere with it
	function ENT:Attach( activator , forced )

		--we were forced to attach to this player, so drop first to clear out some values
		if forced then
			self:Remove( forced )
		end

		if not IsValid( activator ) or not activator:IsPlayer() then
			return false
		end

		--we're carried in general OR that guy's using that slot already
		if self:IsCarried() or IsValid( self.GetOnPlayer( activator , self:GetSlotName() ) ) then
			return false
		end

		--we can allow the coder or gamemode to only stop the pickup if it's not forced
		if not forced then
			--simulate ourselves being a normal item pickup
			--the reason we're asking this first, is that first we want to make sure the gamemode is OK with us being able to pickup this entity
			local canattach = hook.Run( "PlayerCanPickupItem" , activator , self )

			--THEN we ask the coder if he really wants us to pickup his entity, in case it's out of "ammo", or some other restrictions
			local mycanattach = self:CanAttach( activator )
			if mycanattach == false then
				canattach = mycanattach
			end

			if canattach == false then
				return canattach
			end
		end

		if self.AttachesToPlayer then
			self:RemovePhysics()
			self:SetParent( activator )
			self:SetOwner( activator )
			self:SetTransmitWithParent( true )

			--[[
			if self.DontTransmitToOthers then
				--force a recheck of the transmission, so UpdateTransmitState() is called right away
				self:AddEFlags( EFL_FORCE_CHECK_TRANSMIT )
			else
				self:SetTransmitWithParent( true )
			end
			]]

			self:SetNoDraw( true )
			self:AddEFlags( EFL_NO_PHYSCANNON_INTERACTION )
		end

		self:SendItemMessage( activator , false )

		self.SetOnPlayer( activator , self:GetSlotName() , self )
		self:SetControllingPlayer( activator )

		--if the player has a customized key for this entity, use that instead
		--we do this here so that OnAttach can make use of it

		--this also allows us to prevent the key from another user to be written clientside and override ours
		if self.SaveButtonToCvar then
			local plykey = self:GetControllingPlayerConVarKey()

			if self:IsKeyAllowed( plykey ) and plykey ~= self:GetKey() then
				self:SetKey( plykey )
			end
		end

		--THIS IS VERY SUBJECTIVE
		self:SetKeyPressed( false ) --only reset the button press state when equipped

		self:OnAttach( activator , forced )
		return true
	end

	function ENT:Drop( forced )

		--we can allow the coder to only stop the drop if it's not forced
		if not forced then
			local candrop = self:CanDrop( self:GetControllingPlayer() )

			if candrop == false then
				return candrop
			end
		end

		if self.AttachesToPlayer then
			self:SetParent( NULL )
			self:SetOwner( NULL )
			self:InitPhysics()
			self:SetTransmitWithParent( false )

			--[[
			if self.DontTransmitToOthers then
				--force a recheck during a drop
				self:AddEFlags( EFL_FORCE_CHECK_TRANSMIT )
			else
				self:SetTransmitWithParent( false )
			end
			]]

			self:SetNoDraw( false )
			self:RemoveEFlags( EFL_NO_PHYSCANNON_INTERACTION )
		end

		if not forced and self:IsCarried() then
			self:SendItemMessage( self:GetControllingPlayer() , true )
		end

		--only call OnDrop if we had a player controlling us, don't do it if we were just sweeping up some unclean values
		if self:IsCarried() then
			self:OnDrop( self:GetControllingPlayer() , forced )
			self.SetOnPlayer( self:GetControllingPlayer() , self:GetSlotName() , NULL )
		end

		self:SetControllingPlayer( NULL )
		return true
	end

	function ENT:SendItemMessage( activator , dropped )
		if dropped == nil then
			dropped = false
		end
		--GetShouldPlayPickupSound is actually a Lua table value that is then checked in c++, so it starts out as nil, wow garry
		if self.ShowPickupNotice and ( self:GetShouldPlayPickupSound() == nil or self:GetShouldPlayPickupSound() ) then

			if not dropped then
				self:EmitSound( "HL2Player.PickupWeapon" )
			else
				self:EmitSound( "Weapon_Crowbar.Single" )
			end

			if not activator:IsPlayer() or not activator:IsBot() then
				net.Start( "pe_pickup" )
					net.WriteString( self:GetClass() )
					net.WriteBit( dropped )
				net.Send( activator )
			end
		end
	end

	--we want to get properly dropped when the player entity gets removed ( aka after a disconnect )
	--why not use the disconnect hook? no.

	function ENT:OnControllerRemoved( ent )
		if self:IsCarriedBy( ent ) then
			self:Remove( true )
		end
	end

	function ENT:OnControllerDeath( ply )
		if self.DropOnDeath and self:IsCarriedBy( ply ) then
			self:Remove( true )
		end
	end

	--we're redoing this even though it's hooked up in sandbox because someone might want to use this in another gamemode ( such as ttt or whatever )
	function ENT:HandleCanEditVariable( ent , ply , key , val , editor )
		if ent == self then
			local allow = self:CanPlayerEditVariable( ply , key , val , editor )

			if key == "Key" then
				local btn = tonumber( val )
				if btn and not self:IsKeyAllowed( btn ) then
					allow = false
				end
			end

			--call the editkey hook only if the other one didn't say anything in the matter for this
			if key == "Key" and allow == nil then
				allow = self:CanEditKey( ply , val , editor )
			end

			--we'll only override all the hooks if the answer is yes or no, nil keeps the default behaviour
			if allow ~= nil then
				return allow
			end
		end
	end

	--our key can only be modified by the carrying player or by anyone if it's not carried at all
	function ENT:CanEditKey( ply , val , editor )
		--you could override me if you want to, you could leave your friends behind
		return self:IsCarriedBy( ply ) or not self:IsCarried()
	end

	function ENT:CanPlayerEditVariable( ply , key , val , editor )
		--override me
	end

	--we add this entity's position to the visibility position, but only if it doesn't attach to the player
	function ENT:HandleEntityVisibility( ply , viewent )
		if self:IsCarriedBy( ply ) and not self.AttachesToPlayer and self ~= viewent then --viewents already add themselves to the pvs
			AddOriginToPVS( self:GetPos() )
		end

		--HOW CONVENIENT!!! this hook is called before the client computes what he can see
		--so we can simply use this before this entity gets recomputed for transmission

		--TODO: This will be removed and the ENT:UpdateTransmitState() below will be enabled once Willox is done with TRANSMIT_OWNERONLY
		if self.DontTransmitToOthers and not game.SinglePlayer() then

			local shouldpreventtransmit = false

			if self:IsCarried() then
				shouldpreventtransmit = not self:IsCarriedBy( ply , true )
			end

			self:SetPreventTransmit( ply , shouldpreventtransmit )
		end
	end

	--[[
	function ENT:UpdateTransmitState()


		if self.DontTransmitToOthers and self:IsCarried() then
			return TRANSMIT_OWNERONLY
		end


		--don't return anything, default behaviour
	end
	]]

else

	function ENT:GetConVar()

		--the slotname changed, so we forget this cvar to let another one with the same slot use it
		--and we let the code below create/get one with our slotname
		if self.ConfigurableConVar and self.ConfigurableConVar:GetName() ~= self:GetConVarName() then
			self.ConfigurableConVar = nil
		end

		if not self.ConfigurableConVar then
			--internally this returns the original convar if it was already created, so it's not that big of a deal, this could be done in a better way however
			self.ConfigurableConVar = CreateConVar( self:GetConVarName() , self:GetKey() , FCVAR_ARCHIVE + FCVAR_USERINFO , "Configures the key for "..self:GetSlotName().. " , created by "..self:GetClass() )
		end

		return self.ConfigurableConVar
	end

	function ENT:InternalHandleLoopingSounds( calledinprediction )
		--the calledinprediction variable makes it so HandleLoopingSounds is called from ENT:Think instead
		--and yes, this will never be set at all during singleplayer because there's no prediction

		--if this is set then there's no need to call iscarried checks below, we're always called when that happens
		if calledinprediction and not IsFirstTimePredicted() then
			return
		end

		if game.SinglePlayer() or not self:IsCarried() or not self:IsCarriedByLocalPlayer() or ( self:IsCarriedByLocalPlayer() and calledinprediction ) then
			self:HandleLoopingSounds()
		end
	end

	function ENT:HandleLoopingSounds()
		--override me
	end

	function ENT:IsCarriedByLocalPlayer( checkspectator )
		return self:IsCarriedBy( LocalPlayer() , checkspectator )
	end

	function ENT:ShouldDrawLocalPlayer( checkspectator )
		if checkspectator then
			if LocalPlayer():GetObserverMode() == OBS_MODE_IN_EYE and IsValid( LocalPlayer():GetObserverTarget() ) then
				if LocalPlayer():GetObserverTarget():IsPlayer() then
					return LocalPlayer():GetObserverTarget():ShouldDrawLocalPlayer() --assuming this even works, otherwise just return false
				end
				return false
			end
		end
		return LocalPlayer():ShouldDrawLocalPlayer()
	end

	--immediately make this entity predicted again, if it's equipped by this localplayer
	function ENT:HandleFullPacketUpdate( ent , shouldtransmit )
		if ent == self and shouldtransmit then
			self:HandlePrediction()
		end
	end

	function ENT:HandlePrediction()

		local carried = self:IsCarriedByLocalPlayer()

		--either the gravity gun or some other stuff is carrying me, don't do anything on prediction
		--because they might enable it to carry us around smoothly
		--also don't enable prediction in singleplayer

		if self:GetBeingHeld() or game.SinglePlayer() then
			return
		end

		if self:GetPredictable() ~= carried then
			self:SetPredictable( carried )
		end
	end

	function ENT:HandleButtonBind()
		--did not disable the function call from Think as someone might want to override this

		if self.SaveButtonToCvar then
			--this is a one way server to client saving, the reason I do this is because the user should usually change the value from
			--client to server with the edit system, it still goes to the server, but not to the cvar first, so we save it from the client to the cvar

			--basically we just use the cvar as a way to save the button, but it does come at the cost of not being able to update the cvar and have it update on the
			--entity, this will probably change in the future
			local mykey = self:GetKey()

			--can't use GetControllingPlayerConVarKey as I also need to SetInt on it
			local cv = self:GetConVar()

			if cv then
				if ( mykey ~= cv:GetInt() and self:IsKeyAllowed( mykey ) ) --[[or not self:IsKeyAllowed( cv:GetInt() )]] then
					cv:SetInt( mykey )
				end
			end
		end
	end



	function ENT:CreateContextMenuButton( iconlayout )
		local button = iconlayout:Add( "DPredEnt" )
		button:SetSize( 80 , 80 )
		button:SetClassName( self.PrintName , self:GetSlotName() )
		button:SetMaterial( self.Folder .. ".png" )
		button:SetPredEnt( self )
		--SetClassName
	end

	function ENT:GetContextMenuButton( iconlayout )
		local contextbutton = nil

		for i = 0 , iconlayout:ChildCount() do

			local child = iconlayout:GetChild( i )

			if IsValid( child ) and child:GetName() == "DPredEnt" and child:GetSpawnName() == self:GetSlotName() and child:GetPredEnt() == self then
				contextbutton = child
				break
			end

		end

		return contextbutton
	end

	--forcefully removes it in case it fucks up
	function ENT:RemoveContextMenuButton( iconlayout , buttonpanel )
		if IsValid( buttonpanel ) then
			buttonpanel:Remove()
		end
	end

	function ENT:GetContextMenuLayout()
		if not IsValid( g_ContextMenu ) then
			return
		end

		local iconlayout = nil

		for i = 0 , g_ContextMenu:ChildCount() do

			local child = g_ContextMenu:GetChild( i )

			if IsValid( child ) and child:GetName() == "DIconLayout" then
				iconlayout = child
				break
			end

		end

		return iconlayout
	end

	function ENT:HandleContextMenuButton( docleanup )

		local iconlayout = self:GetContextMenuLayout()

		if not IsValid( iconlayout ) then
			return
		end

		local buttonpanel = self:GetContextMenuButton( iconlayout )

		if IsValid( buttonpanel ) and ( not self:IsCarriedByLocalPlayer() or docleanup )then
			self:RemoveContextMenuButton( iconlayout , buttonpanel )
			iconlayout:InvalidateLayout()
		end

		if not IsValid( buttonpanel ) and self:IsCarriedByLocalPlayer() then
			self:CreateContextMenuButton( iconlayout )
			iconlayout:InvalidateLayout()
		end

	end



	function ENT:DrawFirstPersonInternal()
		if self.AttachesToPlayer and self:IsCarriedByLocalPlayer( true ) and not self:ShouldDrawLocalPlayer( true ) then
			local fov = nil	--TODO: allow changing the FOV
			cam.Start3D( nil , nil , fov , nil , nil , nil , nil , 1 , -1 )	--znear is 1 and zfar is -1
				render.DepthRange( 0 , 0.1 )	--same depth hack valve uses in source!
					self:DrawFirstPerson( self:GetControllingPlayer() )
				render.DepthRange( 0 , 1 )		--they don't even set these back to the original values
			cam.End3D()
		end
	end

	--viewmodels don't draw without an associated weapon ( this is due to garryness, they always do in source )
	function ENT:DrawViewModelInternal( vm , ply , wpn )
		if self.AttachesToPlayer and self:IsCarriedBy( ply , true ) then
			self:DrawOnViewModel( ply , vm , ply:GetHands() ) --this will stay here
		end
	end

	function ENT:DrawFirstPerson( ply )
		--override me
	end

	--mainly used to draw stuff like shields, gloves or whatever on the viewmodel hands

	function ENT:DrawOnViewModel( ply , vm , hands )
		--override me
	end

	--the flags aren't passed yet, maybe in a future update

	function ENT:DrawOnPlayer( ply , flags )
		self:DrawModel( flags )

	end

	function ENT:Draw( flags )
		local pos , ang = self:GetCustomParentOrigin()
		--even though the calcabsoluteposition hook should already prevent this, it doesn't on other players
		--might as well not give it the benefit of the doubt in the first place
		if pos and ang then
			self:SetPos( pos )
			self:SetAngles( ang )
			self:SetupBones()
		end

		self:DrawModel( flags )
	end

end

--these are here to "unify" our two calls to SetNWEntity and GetNWEntity
--these might be called from pe_drop and some other stuff, so we can't rely on the entity itself being present, as lame as that is
--the alternative would be to have these as global, which would be lamer
function ENT.SetOnPlayer( ply , slot , ent )
	ply:SetNW2Entity( slot , ent )
end

function ENT.GetOnPlayer( ply , slot )
	return ply:GetNW2Entity( slot )
end

function ENT:IsAttached()
	local ply = self:GetControllingPlayer()
	return self:GetOwner() == ply and self:GetParent() == ply
end

--LOOK I DON'T CARE, this check is lame as shit but I can't be arsed to add duplicated code
function ENT:IsCarried()
	return self:IsCarriedBy( self:GetControllingPlayer() )
end

function ENT:IsCarriedBy( ply , checkspectator )

	if checkspectator and ply:GetObserverMode() ~= OBS_MODE_NONE then
		return self:IsCarriedBy( ply:GetObserverTarget() )
	end

	return IsValid( ply ) and ply == self:GetControllingPlayer() and self.GetOnPlayer( self:GetControllingPlayer() , self:GetSlotName() ) == self
end

function ENT:IsKeyDown()
	return self:GetKeyPressed()
end

--these functions should totally not be tied to this SENT, but I don't want to go out of my way to add them to an util file
function ENT:IsValidButton( btn )
	return btn > BUTTON_CODE_NONE and btn < BUTTON_CODE_COUNT
end

function ENT:IsKeyboardButton( btn )
	return btn > KEY_FIRST and btn < KEY_COUNT
end

function ENT:IsMouseButton( btn )
	return btn >= MOUSE_FIRST and btn < MOUSE_LAST
end

function ENT:IsJoystickButton( btn )
	return btn >= JOYSTICK_FIRST and btn < JOYSTICK_LAST
end

function ENT:IsKeyAllowed( btn )
	if bit.band( self.KeyAllowedFlags , self.KeyAllowedKeyboard ) == 0 and self:IsKeyboardButton( btn ) then
		return false
	end

	if bit.band( self.KeyAllowedFlags , self.KeyAllowedMouse ) == 0 and self:IsMouseButton( btn ) then
		return false
	end

	if bit.band( self.KeyAllowedFlags , self.KeyAllowedJoystick ) == 0 and self:IsJoystickButton( btn ) then
		return false
	end

	return self:IsValidButton( btn )
end

function ENT:GetConVarName()
	return "prdent_key_"..self:GetSlotName()
end

function ENT:GetControllingPlayerConVarKey()
	local defaultkey = BUTTON_CODE_NONE

	if self:IsCarried() then
		if SERVER then
			return self:GetControllingPlayer():GetInfoNum( self:GetConVarName() , defaultkey )
		else
			--the clientside implementation of GetInfoNum makes a GetConVar lookup everytime, so use the cached one instead
			local cv = self:GetConVar()

			if cv then
				return cv:GetInt()
			end
		end
	end

	return defaultkey
end

function ENT:HandleCalcMainActivity( ply , velocity )
	if self:IsCarriedBy( ply ) then
		local calcideal , calcseqovr = self:HandleMainActivityOverride( ply , velocity )
		if calcideal and calcseqovr then
			return calcideal , calcseqovr
		end
	end
end

function ENT:HandleUpdateAnimation( ply, velocity, maxseqgroundspeed )
	if self:IsCarriedBy( ply ) then
		if self:HandleUpdateAnimationOverride( ply , velocity , maxseqgroundspeed ) then
			return true
		end
	end
end

function ENT:HandleAnimationEvent( ply, event, data )
	if self:IsCarriedBy( ply ) then
		if self:HandleAnimationEventOverride( ply , event , data ) then
			return ACT_INVALID
		end
	end
end

function ENT:HandleMainActivityOverride( ply , velocity )
	--override me
end

function ENT:HandleUpdateAnimationOverride( ply , velocity , maxseqgroundspeed )
	--override me
end

function ENT:HandleAnimationEventOverride( ply , event , data )
	--override me
end

function ENT:HandlePredictedStartCommand( ply , cmd )
	if self:IsCarriedBy( ply ) then
		self:PredictedStartCommand( ply , cmd )
	end
end

function ENT:HandlePlayerButtonDown( ply , btn )
	if self:IsCarriedBy( ply ) then
		self:HandlePlayerButtonInternal( ply , btn , true )
	end
end

function ENT:HandlePlayerButtonUp( ply , btn )
	if self:IsCarriedBy( ply ) then
		self:HandlePlayerButtonInternal( ply , btn , false )
	end
end

function ENT:HandlePlayerButtonInternal( ply , btn , pressed )
	local mykey = self:GetKey()
	if self:IsKeyAllowed( mykey ) and btn == mykey then
		self:SetKeyPressed( pressed )
	end

	self:PredictedPlayerButtonPress( ply , btn , pressed )
end

function ENT:HandlePredictedSetupMove( ply , mv , cmd )
	if self:IsCarriedBy( ply ) then
		if self:PredictedSetupMove( ply , mv , cmd ) then
			return true
		end
	end
end

function ENT:HandlePredictedMove( ply , mv )
	if self:IsCarriedBy( ply ) then
		if self:PredictedMove( ply , mv ) then
			return true
		end
	end
end

function ENT:HandlePredictedThink( ply , mv )
	if self:IsCarriedBy( ply ) then
		if CLIENT then
			self:InternalHandleLoopingSounds( true )
		end
		self:PredictedThink( ply , mv )
	end
end

function ENT:HandlePredictedFinishMove( ply , mv )
	if self:IsCarriedBy( ply ) then
		if self:PredictedFinishMove( ply , mv ) then
			return true
		end
	end
end

function ENT:HandlePredictedHitGround( ply , inwater , onfloater , speed )
	if self:IsCarriedBy( ply ) then
		if self:PredictedHitGround( ply , inwater , onfloater , speed ) then
			return true
		end
	end
end

function ENT:PredictedStartCommand( ply , cmd )
	--override me
end

function ENT:PredictedPlayerButtonPress( ply , btn , pressed )
	--override me
end

function ENT:PredictedSetupMove( ply , mv , cmd )
	--override me
end

function ENT:PredictedMove( ply , mv )
	--override me
end

function ENT:PredictedThink( ply , mv )
	--override me
end

function ENT:PredictedFinishMove( ply , mv )
	--override me
end

function ENT:PredictedHitGround( ply , inwater , onfloater , speed )
	--override me
end

--Allows for predicted movement simulation on non player entities, without disrupting the player movement itself
--FinishMove should be the best place for this, since even in case of fuckups, the rest of the movement should be fine

--[[
	function ENT:PredictedFinishMove( ply , mv )

		local sv = self:BackupMoveData( mv )

		--set the data you want on the movedata, such as the entity origin, speed, angles and stuff

		--run the entity traces

		--set the final position of the entity here with the same way garry does ( see drive.End or whatever it's called )

		--restore the movedata on the player as if nothing happened

		self:RestoreMoveData( mv , sv )


	end
]]


local movedatameta = FindMetaTable( "CMoveData" )

local emptyvalues = {
	[TYPE_VECTOR] = vector_origin * 1,
	[TYPE_ANGLE] = angle_zero * 1,
	[TYPE_NUMBER] = 0,
	[TYPE_ENTITY] = NULL,
}

local methods = {}

--cache the methods we can actually use
for i , v in pairs( movedatameta ) do
	--see if this function has a pattern like "Get*" or whatever
	--then strip out "Get" and add it here
	local functionname = i
	if functionname:find( "^Get" ) then
		local functionnamestripped = functionname:gsub( "^Get" , "" )

		local setter = movedatameta["Set"..functionnamestripped]

		if setter then
			--add the stripped method to the table to reuse later
			methods[#methods + 1] = functionnamestripped
		end
	end
end

function ENT:BackupMoveData( mv )

	if not mv or not movedatameta then
		return
	end

	local sv = {}
	--save the movedata by name on the table, then go trough the metatable to get the setters and set values to empty ones

	for i , v in pairs( methods ) do
		--see if this function has a pattern like "Get*" or whatever
		--then strip out "Get" and add it here

		--we could've cached the functions as well, but just in case someone wants us to use the modified ones
		local getter = movedata["Get"..v]
		local setter = movedata["Set"..v]

		local backupvalue = getter( mv )

		sv[v] = backupvalue

		if emptyvalues[TypeID( backupvalue )] ~= nil then
			setter( mv , emptyvalues[TypeID( backupvalue )] )
		end
	end

	return sv
end

function ENT:RestoreMoveData( mv , sv )
	if not mv or not sv or not movedatameta then
		return
	end

	--restore the values from the table, prevents duplicated code by using the setters from the metatable directly
	for i , v in pairs( sv ) do
		local setter = movedatameta["Set"..i]
		if setter then
			setter( mv , v )
		end
	end
end

--attaches the entity to the player depending on the attachmentinfo table
--you can override this safely as long as you keep the part with ply:SetupBones()
--although you generally should just use the attachment info table instead

function ENT:GetCustomParentOrigin()

	if not self.AttachmentInfo then
		return
	end

	local ply = self:GetControllingPlayer()

	--duplicated check, but people might call this manually in the entity draw hook, so gotta do this
	if not self:IsCarriedBy( ply ) then
		return
	end

	--I put this here because since the entity moves to the player bone matrix, it'll only be updated on the client
	--when the player is actally drawn, or his bones are setup again ( which happens before a draw anyway )
	--this also fixes sounds on the client playing at the last location the LocalPlayer() was drawn

	if CLIENT and self:IsCarriedByLocalPlayer( true ) and not self:ShouldDrawLocalPlayer( true ) then
		ply:SetupBones()
	end

	local boneid = ply:LookupBone( self.AttachmentInfo.BoneName )

	if not boneid then
		return
	end

	local matrix = ply:GetBoneMatrix( boneid )

	if not matrix then
		return
	end

	return LocalToWorld( self.AttachmentInfo.OffsetVec , self.AttachmentInfo.OffsetAng , matrix:GetTranslation() , matrix:GetAngles() )
end

--if we're attached to a player, use custom origin from the function above
--this is called shared, yes it's more expensive than source's normal parenting but it's worth it

function ENT:CalcAbsolutePosition( pos , ang )
	if self.AttachesToPlayer and self:IsCarried() then
		return self:GetCustomParentOrigin()
	end
end

function ENT:EmitPESound( soundname , level , pitch , volume , chan , predicted , activator , worldpos )

	--must've been called manually by some ent:Fire or ent:Input functions
	if IsValid( activator ) and not activator:IsPlayer() then
		activator = NULL
	end

	if not level then
		level = 75
	end

	if not pitch then
		pitch = 100
	end

	if not volume then
		volume = 1
	end

	if not chan then
		chan = CHAN_AUTO
	end

	if game.SinglePlayer() then
		predicted = false
	end

	if not worldpos then
		worldpos = vector_origin
	end

	if SERVER then

		local plys = RecipientFilter()

		if IsValid( activator ) and not predicted and not activator:IsBot() then
			plys:AddPlayer( activator )
		else

			plys:AddPVS( self:GetPos() )

			if predicted and IsValid( self:GetControllingPlayer() ) then
				plys:RemovePlayer( self:GetControllingPlayer() )
			end

		end

		if plys:GetCount() == 0 then
			return
		end

		net.Start( "pe_playsound" )
			net.WriteEntity( self )
			net.WriteString( soundname )
			net.WriteFloat( level )
			net.WriteFloat( pitch )
			net.WriteFloat( volume )
			net.WriteUInt( chan , 8 )
			net.WriteVector( worldpos )
		net.Send( plys )

	else
		if ( predicted and IsFirstTimePredicted() ) or not predicted then
			if worldpos and worldpos ~= vector_origin then
				sound.Play( soundname, worldpos, level, pitch , volume )
			else
				self:EmitSound( soundname , level , pitch , volume , chan )
			end
		end
	end
end

function ENT:OnRemove()
	--if we're being forcibly removed, make sure we're also dropped properly, in case the entity needs to do
	--some stuff on the player before it expires
	if SERVER and self:IsCarried() then
		self:Remove( true )
	end

	if CLIENT then
		self:HandleContextMenuButton( true )
	end

	self:HandleHooks( true ) --remove the hooks immediately instead of relying on garry's "remove if called again"


end

--stuff that should be in an autorun file but that I can't be arsed to split up to

if SERVER then

	util.AddNetworkString( "pe_pickup" )
	util.AddNetworkString( "pe_playsound" )

	--save the function before ENT gets removed during registration
	local GetPredictedEntityOnPlayer = ENT.GetOnPlayer

	concommand.Add( "pe_drop" , function( ply , cmd , args , fullstr )

		if not IsValid( ply ) then
			return
		end

		local nwslot = args[1]

		if not nwslot then
			return
		end

		local slotent = GetPredictedEntityOnPlayer( ply , nwslot )--ply:GetNWEntity( nwslot )

		--user tried to drop an invalid or an entity which is not a predicted entity, or doesn't have a slot assigned

		if not IsValid( slotent ) or not slotent.IsPredictedEnt or slotent:GetSlotName() == "" then
			return
		end

		slotent:Remove( false )

	end)

else

	--tells the hud to show the player the entity pickup
	language.Add( "invalid_entity" , "Invalid Entity" )
	language.Add( "dropped_invalid_entity" , "Dropped Invalid Entity" )

	net.Receive( "pe_pickup" , function( len )
		local str = net.ReadString() or "invalid_entity"
		local dropped = tobool( net.ReadBit() )

		if dropped then
			str = "dropped_" .. str
		end

		gamemode.Call( "HUDItemPickedUp" , str )
	end)

	net.Receive( "pe_playsound" , function( len )
		local ent = net.ReadEntity()

		if not IsValid( ent ) or not ent.EmitPESound then
			return
		end

		local soundname = net.ReadString() --yes I know that I can do util.addnetworkstring to cache it but I cba

		local level = net.ReadFloat()
		local pitch = net.ReadFloat()
		local volume = net.ReadFloat()
		local chan = net.ReadUInt( 8 )
		local pos = net.ReadVector()

		ent:EmitPESound( soundname , level , pitch , volume , chan , false , NULL , pos )
	end)

	--[[
		A DProperty that allows the user to set a preferred key using the same DBinder used in sandbox's tools
	]]

	local DBinderProperty = {}

	function DBinderProperty:Init()
	end

	function DBinderProperty:Setup( vars )

		self:Clear()

		local ctrl = self:Add( "DBinder" )
		ctrl:Dock( FILL )

		self.IsEditing = function( self )
			return ctrl.Trapping
		end

		self.SetValue = function ( self , val )
			ctrl:SetSelected( tonumber( val ) )	--use this instead of setValue to possibly avoid feedback loops
		end

		--DBinder doesn't have an onchange callback, so we must do this little hack to add it
		--[[
		ctrl.SetValue = function( ctrl , val )
			ctrl:SetSelected( val )
			self:ValueChanged( val )
		end
		]]

		ctrl.OnChange = function( ctrl , val )
			self:ValueChanged( val )
		end


	end

	derma.DefineControl( "DProperty_EditKey" , "" , DBinderProperty , "DProperty_Generic" )

	local DPredEnt = {
		matOverlay_Normal = Material( "gui/ContentIcon-normal.png" ),
		matOverlay_Hovered = Material( "gui/ContentIcon-hovered.png" )
	}

	AccessorFunc( DPredEnt, "m_MaxBorder", "MaxBorder" )
	AccessorFunc( DPredEnt, "m_MaterialName", "MaterialName" )
	AccessorFunc( DPredEnt, "m_PredEnt", "PredEnt" )
	AccessorFunc( DPredEnt, "m_Border", "Border" )
	AccessorFunc( DPredEnt, "m_Color", "Color" )
	AccessorFunc( DPredEnt, "m_Type", "ContentType" )
	AccessorFunc( DPredEnt, "m_SpawnName", "SpawnName" )
	AccessorFunc( DPredEnt, "m_NPCWeapon", "NPCWeapon" )
	AccessorFunc( DPredEnt, "m_Image", "Image" )
	AccessorFunc( DPredEnt, "m_Label", "Label" )

	function DPredEnt:Init()

		local w , h = 128, 128
		self:SetSize( w , h )

		self:SetPaintBackground( false )

		self:SetText( "" )
		self:SetDoubleClickingEnabled( false )

		self:SetImage( self:Add( "DImage" ) )
		self:GetImage():SetVisible( false )

		self:SetLabel( self:Add( "DLabel" ) )
		self:GetLabel():Dock( BOTTOM )

		self:GetLabel():SetContentAlignment( 5 )

		self:GetLabel():SetTextColor( Color( 255, 255, 255, 255 ) )
		self:GetLabel():SetExpensiveShadow( 1, Color( 0, 0, 0, 200 ) )

		self:SetBorder( 0 )



	end



	function DPredEnt:PerformLayout( w , h )
		self:SetMaxBorder( w / 16 )
		self:GetImage():SetPos( w / 32 , w / 32 )
		self:GetImage():SetSize( w - w / 16 , h - w / 16 )
		self:GetLabel():SetTall( math.Round( w / 7 ) )
		self:GetLabel():DockMargin( math.Round( w / 32 ) , 0 , math.Round( w / 32 ) , math.Round( w / 21 ) )
	end


	function DPredEnt:SetClassName( name , class )

		self:SetTooltip( name )
		self:GetLabel():SetText( name )
		self:SetSpawnName( class )
	end

	function DPredEnt:SetMaterial( name )

		self:SetMaterialName( name )

		local mat = Material( name )

		-- Look for the old style material
		if not mat or mat:IsError() then

			name = name:Replace( "entities/", "VGUI/entities/" )
			name = name:Replace( ".png", "" )
			mat = Material( name )

		end

		-- Couldn't find any material.. just return
		if not mat or mat:IsError() then
			return
		end

		self:GetImage():SetMaterial( mat )

	end

	function DPredEnt:Think()
		if not IsValid( self:GetPredEnt() ) or not self:GetPredEnt().IsPredictedEnt  then
			self:Remove()
		end
	end

	function DPredEnt:DoRightClick()
		self:OpenMenu()
	end

	function DPredEnt:DoClick()
		RunConsoleCommand( "pe_drop" , self:GetSpawnName() or ""  )
	end

	function DPredEnt:OpenMenu()
		if IsValid( self:GetPredEnt() ) then
			properties.OpenEntityMenu( self:GetPredEnt() )
		end
	end

	function DPredEnt:OnDepressionChanged( b )
	end

	function DPredEnt:Paint( w, h )

		if self.Depressed and not self.Dragging then
			if self:GetBorder() ~= self:GetMaxBorder() then
				self:SetBorder( self:GetMaxBorder() )
				self:OnDepressionChanged( true )
			end
		else
			if self:GetBorder() ~= 0 then
				self:SetBorder( 0 )
				self:OnDepressionChanged( false )
			end
		end

		render.PushFilterMag( TEXFILTER.ANISOTROPIC )
		render.PushFilterMin( TEXFILTER.ANISOTROPIC )

		local bx , by , bw , bh = self:GetBorder(), self:GetBorder(), w - self:GetBorder() * 2 , h - self:GetBorder() * 2


		self:GetImage():PaintAt( bx + self:GetMaxBorder() / 2 , by + self:GetMaxBorder() / 2 , bw - self:GetMaxBorder() , bh - self:GetMaxBorder() )



		render.PopFilterMin()
		render.PopFilterMag()

		surface.SetDrawColor( 255, 255, 255, 255 )

		if not dragndrop.IsDragging() and ( self:IsHovered() or self.Depressed or self:IsChildHovered() ) then

			surface.SetMaterial( self.matOverlay_Hovered )
			self:GetLabel():Hide()

		else

			surface.SetMaterial( self.matOverlay_Normal )
			self:GetLabel():Show()

		end

		surface.DrawTexturedRect( bx , by , bw , bh )

	end

	derma.DefineControl( "DPredEnt" , "ContentIcon for Predicted entities in the context menu" , DPredEnt , "DButton" )

end

--PATH lua/entities/mortar_fire_shell/shared.lua:
return gluapack()()
--PATH lua/entities/mortar_smoke_shell/shared.lua:
return gluapack()()
--PATH addons/[mrs] mc_quests/lua/entities/mqs_ent/cl_init.lua:
return gluapack()()
--PATH addons/[mrs] mc_quests/lua/entities/mqs_npc/shared.lua:
ENT.Type = "ai"
ENT.Base = "base_anim"
ENT.PrintName = "MQS Quest NPC"
ENT.Author = "Mactavish"
ENT.Spawnable = false
ENT.AdminSpawnable = true

function ENT:SetupDataTables()
	self:NetworkVar("String", 0, "Namer")
	self:NetworkVar("Int", 1, "UID")
end
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/entities/nade_k_thrown_blaststick.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/entities/nade_k_thrown_blaststick.lua:
AddCSLuaFile()

ENT.Type = "anim"
ENT.Base = "arc9_nade_base"
ENT.PrintName = "BlastStick Grenade"
ENT.Author = ""
ENT.Information = ""
ENT.Spawnable = false
ENT.AdminSpawnable = false
ENT.CollisionGroup = COLLISION_GROUP_DEBRIS

ENT.Model = "models/arccw/kraken/sw/explosives/world/w_blaststick.mdl"
ENT.Armed = false

ENT.BlastDamage = {
    [0] = 60,
    [1] = 140,
    [2] = 70,
}

function ENT:Initialize()
    if SERVER then
        self:SetModel(self.Model)
        self:SetMoveType(MOVETYPE_VPHYSICS)
        self:SetSolid(SOLID_VPHYSICS)
        self:PhysicsInit(SOLID_VPHYSICS)
        self:SetSkin(self.Skin or 0)

        local phys = self:GetPhysicsObject()
        if phys:IsValid() then
            phys:Wake()
            phys:SetBuoyancyRatio(0)
        end

        self.SpawnTime = CurTime()
        self:SetPhysicsAttacker(self:GetOwner(), 5)
    end
    
    util.PrecacheSound("kraken/shared/beeps4.wav")
    self:EmitSound("kraken/shared/beeps4.wav")
    
end

function ENT:PhysicsCollide(data, physobj)
    local tgt = data.HitEntity
    local dmginfo = DamageInfo()
    dmginfo:SetDamageType(DMG_GENERIC)
    dmginfo:SetDamage(10)
    dmginfo:SetAttacker(self:GetOwner())
    dmginfo:SetInflictor(self)
    dmginfo:SetDamageForce(data.OurOldVelocity * 0.5)
    tgt:TakeDamageInfo(dmginfo)
    if (IsValid(tgt) and (tgt:IsNPC() or tgt:IsPlayer() or tgt:IsNextBot()) and tgt:Health() <= 0) or (not tgt:IsWorld() and not IsValid(tgt)) or string.find(tgt:GetClass(), "breakable") then
        local pos, ang, vel = self:GetPos(), self:GetAngles(), data.OurOldVelocity
        timer.Simple(0, function()
            if IsValid(self) then
                self:SetAngles(ang)
                self:SetPos(pos)
                self:GetPhysicsObject():SetVelocityInstantaneous(vel)
            end
        end)
    else
        self:Detonate(data.HitEntity)
    end
end

function ENT:Think()
    if SERVER and CurTime() - self.SpawnTime >= self.FuseTime then
        self:Detonate()
    end
end

function ENT:Detonate()
    if SERVER then
        local effectdata = EffectData()
            effectdata:SetOrigin( self:GetPos() )

        if self:WaterLevel() >= 1 then
            util.Effect("WaterSurfaceExplosion", effectdata)
            self:EmitSound("weapons/underwater_explode3.wav", 120, 100, 1, CHAN_AUTO)
        else
            local explode = ents.Create( "info_particle_system" )
            explode:SetKeyValue( "effect_name", "grenade_final" )
            explode:SetOwner( self.Owner )
            explode:SetPos( self:GetPos() )
            explode:Spawn()
            explode:Activate()
            explode:Fire( "start", "", 0 )
            explode:Fire( "kill", "", 30 )
            --util.Effect("Explosion", effectdata)
            --util.Effect("hl2mmod_explosion_grenade", effectdata)
            self:EmitSound("ArcCW_Kraken.Explosives.Explosion", 120, 100, 1, CHAN_AUTO)
        end

        local attacker = self

        if self.Owner:IsValid() then
            attacker = self.Owner
        end

        local hit = false
        
    
        local pos = self:GetPos()

        for _, ent in pairs(ents.FindInSphere(pos, 400)) do
           
            local distSqr = ent:GetPos():DistToSqr(pos)
            local f = 1
            if distSqr > 9216 then -- 96 * 96
                f = Lerp((distSqr - 9216) / (122500 - 9216), 1, 0.25)
            end
            local dmginfo = DamageInfo()
            dmginfo:SetDamageType(DMG_BLAST)
            dmginfo:SetAttacker(attacker)
            dmginfo:SetDamage(350 * f)
            dmginfo:SetDamageForce((ent:WorldSpaceCenter() - pos):GetNormalized() * 9001 * f)
            dmginfo:SetInflictor(self)
            ent:TakeDamageInfo(dmginfo)
        end

        self:Remove()
        util.Decal("Scorch", pos, pos - Vector(0, 0, 16))
        util.ScreenShake(self:GetPos(), 25, 4, 1, self.Radius * 4)
    end
end

function ENT:DrawTranslucent()
    self:Draw()
end

function ENT:Draw()
    self:DrawModel()
end
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/entities/nade_k_thrown_incen/shared.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/entities/nade_k_thrown_shock.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/entities/nade_k_thrown_thermal.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/entities/nade_k_thrown_thermalimploder.lua:
AddCSLuaFile()

ENT.Type = "anim"
ENT.Base = "arc9_nade_base"
ENT.PrintName = "Thermal Imploder"
ENT.Author = ""
ENT.Information = ""
ENT.Spawnable = false
ENT.AdminSpawnable = false
ENT.CollisionGroup = COLLISION_GROUP_DEBRIS

ENT.Model = "models/arccw/kraken/sw/explosives/world/w_thermalimploder.mdl"
ENT.FuseTime = 5

ENT.BlastDamage = {
    [0] = 100,
    [1] = 300,
    [2] = 100,
}

AddCSLuaFile()

function ENT:Initialize()
    if SERVER then
        self:SetModel(self.Model)
        self:SetMoveType(MOVETYPE_VPHYSICS)
        self:SetSolid(SOLID_VPHYSICS)
        self:PhysicsInit(SOLID_VPHYSICS)
        self:SetSkin(self.Skin or 0)

        local phys = self:GetPhysicsObject()
        if phys:IsValid() then
            phys:Wake()
            phys:SetBuoyancyRatio(0)
        end

        self.SpawnTime = CurTime()
        self:SetPhysicsAttacker(self:GetOwner(), 10)

        util.PrecacheSound("kraken/explosives/thermalimploder/beeps.wav")
        self:EmitSound("kraken/explosives/thermalimploder/beeps.wav", 90, 100, 1, CHAN_AUTO)
        
    end
end

function ENT:PhysicsCollide(data, physobj)
    if SERVER then
        if data.Speed > 75 then
            self:EmitSound(Sound("kraken/explosives/bounce/bounce" .. math.random(1,16) .. ".wav"))

            local tgt = data.HitEntity
            if IsValid(tgt) and not tgt:IsWorld() and (self.NextHit or 0) < CurTime() then
                self.NextHit = CurTime() + 0.1
                local dmginfo = DamageInfo()
                dmginfo:SetDamageType(DMG_GENERIC)
                dmginfo:SetDamage(10)
                dmginfo:SetAttacker(self:GetOwner())
                dmginfo:SetInflictor(self)
                dmginfo:SetDamageForce(data.OurOldVelocity * 0.5)
                tgt:TakeDamageInfo(dmginfo)
                if (IsValid(tgt) and (tgt:IsNPC() or tgt:IsPlayer() or tgt:IsNextBot()) and tgt:Health() <= 0) or (not tgt:IsWorld() and not IsValid(tgt)) or string.find(tgt:GetClass(), "breakable") then
                    local pos, ang, vel = self:GetPos(), self:GetAngles(), data.OurOldVelocity
                    timer.Simple(0, function()
                        if IsValid(self) then
                            self:SetAngles(ang)
                            self:SetPos(pos)
                            self:GetPhysicsObject():SetVelocityInstantaneous(vel)
                        end
                    end)
                end
            end
        elseif data.Speed > 25 then
            self:EmitSound(Sound("kraken/explosives/bounce/bounce" .. math.random(1,16) .. ".wav"))
        end
    end
    if data.Speed < 15 then
        self:SetMoveType(MOVETYPE_NONE)
        self:EmitSound(Sound("kraken/explosives/thermalimploder/charged.wav"))
    end
end

function ENT:Think()
    if SERVER and CurTime() - self.SpawnTime >= self.FuseTime then
        self:Detonate()
    end
end

function ENT:Detonate()
    if SERVER then
        local effectdata = EffectData()
            effectdata:SetOrigin( self:GetPos() )

        if self:WaterLevel() >= 1 then
            util.Effect("WaterSurfaceExplosion", effectdata)
            self:EmitSound("weapons/underwater_explode3.wav", 120, 100, 1, CHAN_AUTO)
        else
            local explode = ents.Create( "info_particle_system" )
            explode:SetKeyValue( "effect_name", "pyro_explode" )
            explode:SetOwner( self.Owner )
            explode:SetPos( self:GetPos() )
            explode:Spawn()
            explode:Activate()
            explode:Fire( "start", "", 0 )
            explode:Fire( "kill", "", 30 )
            --util.Effect("Explosion", effectdata)
            --util.Effect("hl2mmod_explosion_grenade", effectdata)
            util.ScreenShake(self:GetPos(), 25, 6, 2, self.Radius * 5)
            self:EmitSound("kraken/explosives/thermalimploder/pre_explosion_a01.wav", 120, 100, 1, CHAN_AUTO)
            self:EmitSound("kraken/explosives/thermalimploder/explosion_cercana_0" .. math.random(1,3) .. "_a01.wav", 120, 100, 1, CHAN_AUTO)
            
        end

        local attacker = self

        if self.Owner:IsValid() then
            attacker = self.Owner
        end

        local hit = false
        
        local pos = self:GetPos()

        for _, ent in pairs(ents.FindInSphere(pos, 600)) do
           
            local distSqr = ent:GetPos():DistToSqr(pos)
            local f = 1
            if distSqr > 9216 then -- 96 * 96
                f = Lerp((distSqr - 9216) / (12500 - 9216), 1, 0.25)
            end
            local dmginfo = DamageInfo()
            dmginfo:SetDamageType(DMG_BLAST)
            dmginfo:SetAttacker(attacker)
            dmginfo:SetDamage(450 * f)
            dmginfo:SetDamageForce((ent:WorldSpaceCenter() - pos):GetNormalized() * 9001 * f)
            dmginfo:SetInflictor(self)
            ent:TakeDamageInfo(dmginfo)
        end
        self:Remove()
        util.Decal("Scorch", pos, pos - Vector(0, 0, 100))
    end
end

function ENT:DrawTranslucent()
    self:Draw()
end

function ENT:Draw()
    self:DrawModel()
end
--PATH lua/entities/nmg_eksoan_class_4ts_power_gen/cl_init.lua:
include("shared.lua")

local Color_White = Color( 201, 201, 201, 230)
local Color_Outline = Color(25,25,25,100)
local Color_BlackT = Color(0, 0, 0, 230)

local function R4V3NGaming_OutlinedBox(x, y, w, h, thickness, col)
	surface.SetDrawColor(col.r, col.g, col.b, col.a)
	for i = 0, thickness - 1 do
		surface.DrawOutlinedRect(x + i, y + i, w - i * 2, h - i * 2)
	end
end

function ENT:Draw()
	self:DrawModel()

	local Ang = self:GetAngles()
	local Pos = self:GetPos()

	cam.Start3D2D(Pos + Ang:Up() * 20.45 + Ang:Forward() * 13.5 + Ang:Right() * 3.4, Ang, 0.07)
		surface.SetDrawColor(Color_BlackT)
		surface.DrawRect(0, 0, -85, -85)
		R4V3NGaming_OutlinedBox(0, 0, -85, -85, 5, Color_White)

		local Energy = self:GetEnergy()
		local Perc = math.ceil((Energy / 75) * 100)
		draw.SimpleTextOutlined(Perc .. "%", "DermaLarge", -40, -40, Color_White, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 1, Color_Outline)
	cam.End3D2D()
end
--PATH lua/entities/nmg_ewhb-12_heavy_repeating_blaster/cl_init.lua:
include("shared.lua")

function ENT:Initialize()
	self.MuzzleAttachment = self:LookupAttachment("muzzle")
	self.shootPos = self:GetShootPos()
end

local Color_White = Color( 201, 201, 201, 230)
local Color_Outline = Color(25,25,25,100)
local Color_BlackT = Color(0, 0, 0, 230)

local function R4V3NGaming_OutlinedBox(x, y, w, h, thickness, col)
	surface.SetDrawColor(col.r, col.g, col.b, col.a)
	for i = 0, thickness - 1 do
		surface.DrawOutlinedRect(x + i, y + i, w - i * 2, h - i * 2)
	end
end

function ENT:Draw()
	self:DrawModel()

	if (self:GetTurretBase()) and (IsValid(self:GetTurretBase())) then

		local Ang = self:GetTurretBase():GetAngles()
		local Pos = self:GetTurretBase():GetPos()
		local Ammo = self:GetTAmmo()
		local Perc = math.ceil((Ammo * 100) / 500)
		Ang:RotateAroundAxis(self:GetTurretBase():GetAngles():Up(), 180)

		cam.Start3D2D(Pos + Ang:Up() * 20.45 + Ang:Forward() * -15.55 + Ang:Right() * 76.6, Ang, 0.07 )

			surface.SetDrawColor(Color_Outline)
			surface.DrawRect(0, 0, -85, -85)
			surface.SetDrawColor(Color_BlackT)
			surface.DrawRect(0, 0, -85, -85 * (Perc / 100))
			R4V3NGaming_OutlinedBox(0, 0, -85, -85, 5, Color_White)
			draw.SimpleTextOutlined(Perc .. "%", "DermaLarge", -40, -40,  Color_White, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 1, Color_Outline )

		cam.End3D2D()
	end
end
--PATH lua/entities/npc_vj_magna_guard_swrc/shared.lua:
ENT.Base 			= "npc_vj_creature_base" -- List of all base types: https://github.com/DrVrej/VJ-Base/wiki/Base-Types
ENT.Type 			= "ai"
ENT.PrintName 		= ""
ENT.Author 			= "Orion, Sirius, Zmaj"
ENT.Contact 		= "http://steamcommunity.com/groups/vrejgaming"
ENT.Purpose 		= "NPC/SNPC Battles or any other things"
ENT.Instructions 	= "Click on the spawnicon to spawn it."
ENT.Category		= "[HC] NPC's"

if (CLIENT) then
	local Name = ""
	local LangName = "npc_vj_vulture"
	language.Add(LangName, Name)
	killicon.Add(LangName,"",Color(255,0,0,0))
	language.Add("#"..LangName, Name)
	killicon.Add("#"..LangName,"",Color(255,0,0,0))
end
--PATH lua/entities/npc_vj_sbdnew_wounded/shared.lua:
ENT.Base 			= "npc_vj_creature_base" -- List of all base types: https://github.com/DrVrej/VJ-Base/wiki/Base-Types
ENT.Type 			= "ai"
ENT.PrintName 		= "  "
ENT.Author 			= "Orion, Sirius, Zmaj"
ENT.Contact 		= "http://steamcommunity.com/groups/vrejgaming"
ENT.Purpose 		= "NPC/SNPC Battles or any other things"
ENT.Instructions 	= "Click on the spawnicon to spawn it."
ENT.Category		= "[HC] NPC's"

if (CLIENT) then
	local Name = "SBD"
	local LangName = "npc_vj_sbdnew"
	language.Add(LangName, Name)
	killicon.Add(LangName,"",Color(255,0,0,0))
	language.Add("#"..LangName, Name)
	killicon.Add("#"..LangName,"",Color(255,0,0,0))
end
--PATH lua/entities/npc_vj_test_aerial/shared.lua:
return gluapack()()
--PATH lua/entities/obj_vj_rcgg_rocket_swrc1/shared.lua:
return gluapack()()
--PATH addons/[ekonomia] pcasino/lua/entities/pcasino_blackjack_panel/cl_init.lua:
include("shared.lua")


function ENT:Initialize()
	self.table = self:GetParent()
	self.hasInitialized = true
end

local surface_setdrawcolor = surface.SetDrawColor
local surface_drawrect = surface.DrawRect
local draw_simpletext = draw.SimpleText
local black = Color(0, 0, 0, 155)
local white = Color(255, 255, 255, 100)
local gold = Color(255, 200, 0, 100)
local edge = -235
function ENT:Draw()
end
function ENT:DrawTranslucent()
	if self:GetPos():DistToSqr(LocalPlayer():GetPos()) > 25000 then return end
	if not self.table.data then return end

	if not self.hasInitialized then
		self:Initialize()
	end

	local pos = self:GetPos()
	local ang = self:GetAngles()

	cam.Start3D2D(pos + (ang:Up()*5.95), ang, 0.05)
		if self:GetStage() == 1 then -- Changing bet buttons
			local button = self:GetCurrentPad(self:WorldToLocal(LocalPlayer():GetEyeTrace().HitPos))

			-- Previous bet step
			surface_setdrawcolor(black)
			surface_drawrect(edge + 5, -edge - 150, 90, 65)
			-- Border
			surface_setdrawcolor(button == "bet_lower" and gold or white)
			surface_drawrect(edge + 0, -edge - 155, 100, 5)
			surface_drawrect(edge + 0, -edge - 150, 5, 65)
			surface_drawrect(edge + 95, -edge - 150, 5, 65)
			surface_drawrect(edge + 0, -edge - 85, 100, 5)
			-- Left arrow
			draw_simpletext("<", "pCasino.Entity.Arrows", edge + 50, -edge - 120,  button == "bet_lower" and gold or white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
	

			-- Current bet
			surface_setdrawcolor(black)
			surface_drawrect(edge + 115, -edge - 150, 240, 65)
			-- Border
			surface_setdrawcolor(white)
			surface_drawrect(edge + 110, -edge - 155, 250, 5)
			surface_drawrect(edge + 110, -edge - 150, 5, 65)
			surface_drawrect(edge + 355, -edge - 150, 5, 65)
			surface_drawrect(edge + 110, -edge - 85, 250, 5)
			-- Current Bid
			draw_simpletext(PerfectCasino.Config.FormatMoney(self.table.currentBid), "pCasino.Entity.Bid", edge + 235, -edge - 118, white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
	

			-- Next bet step
			-- Box
			surface_setdrawcolor(black)
			surface_drawrect(edge + 375, -edge - 150, 90, 65)
			-- Border
			surface_setdrawcolor(button == "bet_raise" and gold or white)
			surface_drawrect(edge + 370, -edge - 155, 100, 5)
			surface_drawrect(edge + 370, -edge - 150, 5, 65)
			surface_drawrect(edge + 465, -edge - 150, 5, 65)
			surface_drawrect(edge + 370, -edge - 85, 100, 5)
			-- Right arrow
			draw_simpletext(">", "pCasino.Entity.Arrows", edge + 420, -edge - 120, button == "bet_raise" and gold or white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
	
	
			-- Place bet
			surface_setdrawcolor(black)
			surface_drawrect(edge, -edge - 70, 465, 65)
			-- Border
			surface_setdrawcolor(button == "bet_place" and gold or white)
			surface_drawrect(edge, -edge - 75, 470, 5)
			surface_drawrect(edge, -edge - 70, 5, 65)
			surface_drawrect(edge + 465, -edge - 70, 5, 65)
			surface_drawrect(edge, -edge - 5, 470, 5)
			-- Current Bid
			draw_simpletext(PerfectCasino.Translation.UI.PlaceBet, "pCasino.Entity.Bid", edge + 235, -edge - 38, button == "bet_place" and gold or white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
		elseif (self:GetStage() == 2) and (self:GetUser() == LocalPlayer()) then -- Waiting for your turn
			surface_setdrawcolor(black)
			surface_drawrect(edge, -edge - 70, 465, 65)
			-- Border
			surface_setdrawcolor(white)
			surface_drawrect(edge, -edge - 75, 470, 5)
			surface_drawrect(edge, -edge - 70, 5, 65)
			surface_drawrect(edge + 465, -edge - 70, 5, 65)
			surface_drawrect(edge, -edge - 5, 470, 5)
			-- Waiting
			draw_simpletext(PerfectCasino.Translation.UI.Waiting, "pCasino.Entity.Bid", edge + 235, -edge - 38, white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
		elseif (self:GetStage() == 3) and (self:GetUser() == LocalPlayer()) then -- Active turn
			if not self.table.curHands[self.order] then return end

			local activeHandData = self.table.curHands[self.order][self:GetHand()]
			if not activeHandData then return end
			local button = self:GetCurrentPad(self:WorldToLocal(LocalPlayer():GetEyeTrace().HitPos))

			----| Hit
			surface_setdrawcolor(black)
			surface_drawrect(edge + 5, -edge - 70, 220, 65)
			-- Border
			surface_setdrawcolor(button == "action_hit" and gold or white)
			surface_drawrect(edge, -edge - 75, 230, 5)
			surface_drawrect(edge, -edge - 70, 5, 65)
			surface_drawrect(edge + 225, -edge - 70, 5, 65)
			surface_drawrect(edge, -edge - 5, 230, 5)
			-- Hit
			draw_simpletext(PerfectCasino.Translation.UI.Hit, "pCasino.Entity.Bid", edge + 115, -edge - 38, button == "action_hit" and gold or white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)



			----| Stand
			surface_setdrawcolor(black)
			surface_drawrect(edge + 245, -edge - 70, 220, 65)
			-- Border
			surface_setdrawcolor(button == "action_stand" and gold or white)
			surface_drawrect(edge + 240, -edge - 75, 230, 5)
			surface_drawrect(edge + 240, -edge - 70, 5, 65)
			surface_drawrect(edge + 240 + 225, -edge - 70, 5, 65)
			surface_drawrect(edge + 240, -edge - 5, 230, 5)
			-- Stand
			draw_simpletext(PerfectCasino.Translation.UI.Stand, "pCasino.Entity.Bid", edge + 355, -edge - 38, button == "action_stand" and gold or white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
	

			-- Can't double a hand if it's not the first action
			if #activeHandData <= 2 then
				----| Double down
				surface_setdrawcolor(black)
				surface_drawrect(edge + 5, -edge - 150, 220, 65)
				-- Border
				surface_setdrawcolor(button == "action_double" and gold or white)
				surface_drawrect(edge, -edge - 155, 230, 5)
				surface_drawrect(edge, -edge - 150, 5, 65)
				surface_drawrect(edge + 225, -edge - 150, 5, 65)
				surface_drawrect(edge, -edge - 85, 230, 5)
				-- Double down
				draw_simpletext(PerfectCasino.Translation.UI.DoubleDown, "pCasino.Entity.Bid", edge + 115, -edge - 118, button == "action_double" and gold or white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
			end	

			if (#activeHandData <= 2) and activeHandData[2] and (PerfectCasino.Cards:GetValue(activeHandData[1]) == PerfectCasino.Cards:GetValue(activeHandData[2])) then
				----| Split
				surface_setdrawcolor(black)
				surface_drawrect(edge + 245, -edge - 150, 220, 65)
				-- Border
				surface_setdrawcolor(button == "action_split" and gold or white)
				surface_drawrect(edge + 240, -edge - 155, 230, 5)
				surface_drawrect(edge + 240, -edge - 150, 5, 65)
				surface_drawrect(edge + 240 + 225, -edge - 150, 5, 65)
				surface_drawrect(edge + 240, -edge - 85, 230, 5)
				-- Split
				draw_simpletext(PerfectCasino.Translation.UI.Split, "pCasino.Entity.Bid", edge + 355, -edge - 118, button == "action_split" and gold or white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
			end

			----| CurHand Stats
			surface_setdrawcolor(black)
			surface_drawrect(edge + 5, -edge + 10, 460, 65)
			-- Border
			surface_setdrawcolor(white)
			surface_drawrect(edge, -edge + 5, 470, 5)
			surface_drawrect(edge, -edge + 10, 5, 65)
			surface_drawrect(edge + 465, -edge + 10, 5, 65)
			surface_drawrect(edge, -edge + 75, 470, 5)
			-- Current Hand
			draw_simpletext(string.format(PerfectCasino.Translation.UI.CurrentHand, PerfectCasino.UI.NumberSuffix(self:GetHand())), "pCasino.Entity.Bid", edge + 235, -edge + 7, white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
			-- Hand V
			local total = PerfectCasino.Cards:GetHandValue(activeHandData)
			local valueState = ((total > 21) and string.format(PerfectCasino.Translation.UI.Bust, total)) or ((total == 21) and string.format(PerfectCasino.Translation.UI.Blackjack, total)) or total
			draw_simpletext(string.format(PerfectCasino.Translation.UI.CurrentHandTotalValue, valueState), "pCasino.Entity.Bid", edge + 235, -edge + 77, white, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM)
		end
	cam.End3D2D()
end
--PATH addons/[ekonomia] pcasino/lua/entities/pcasino_blackjack_table/cl_init.lua:
include("shared.lua")


local preset = {
	{p = 0.7, a = -30, o = 0.9},
	{p = 0.1, a = -16, o = 1.8},
	{p = 0, a = 16, o = 3},
	{p = 0.3, a = 35, o = 4.1},
}
function ENT:Initialize()
	-- Rebuild the panels table client side, without needing to do any extra networking.
	self.panels = {}
	for k, v in ipairs(self:GetChildren()) do
		if v:GetClass() == "pcasino_blackjack_panel" then
			table.insert(self.panels, v)
		end
	end
	-- Flip the table
	self.panels = table.Reverse(self.panels)
	for k, v in pairs(self.panels) do
		v.order = k
	end

	self.currentBid = 0
	self.active = false
	self.currentBets = {}
	self.currentCards = {}
	self.curHands = {}

	self.hasInitialized = true
end

function ENT:PostData()
	if not self.hasInitialized then
		self:Initialize()
	end
	
	self.currentBid = self.data.bet.default
end
function ENT:OnRemove()
	self:ClearBets()
end

local surface_setdrawcolor = surface.SetDrawColor
local surface_drawrect = surface.DrawRect
local draw_simpletext = draw.SimpleText
local black = Color(0, 0, 0, 200)
local white = Color(255, 255, 255, 100)
function ENT:DrawTranslucent()
	if self:GetPos():DistToSqr(LocalPlayer():GetPos()) > 25000 then return end

	-- We can piggyback off the distance check to only request the entities data when it's needed :D
	if (not self.data) and (not PerfectCasino.Cooldown.Check(self:EntIndex(), 5)) then
		PerfectCasino.Core.RequestConfigData(self)
		return
	end

	if not self.data then return end

	if not (self:GetStartRoundIn() == -1) then
		local pos = self:GetPos()
		local ang = self:GetAngles()
		ang:RotateAroundAxis(ang:Forward(), 90)
		ang:RotateAroundAxis(ang:Right(), -90)
		cam.Start3D2D(pos + (ang:Up()*-22) + (ang:Right()*-19.7) + (ang:Forward()*-4.5), ang, 0.05)
			
			-- Previous bet step
			surface_setdrawcolor(black)
			surface_drawrect(5, 5, 190, 65)
			-- Border
			surface_setdrawcolor(white)
			surface_drawrect(0, 0, 200, 5)
			surface_drawrect(0, 5, 5, 65)
			surface_drawrect(195, 5, 5, 65)
			surface_drawrect(0, 70, 200, 5)

			local text = string.format(PerfectCasino.Translation.UI.Start, self.data.general.betPeriod - (os.time() - self:GetStartRoundIn())) 
			draw_simpletext(text, "pCasino.Entity.Bid", 100, 37, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

		cam.End3D2D()
	end

	if not self.currentCards or not self.currentCards[0] then return end

	for k, v in pairs(self.currentCards) do
		for i, h in pairs(v) do
			local masterCard = h[1]

			local ang = masterCard:GetAngles()
			ang:RotateAroundAxis(ang:Right(), -90)
			ang:RotateAroundAxis(ang:Up(), 90)

			local pos = masterCard:GetPos() + (ang:Forward()*-2.4) + (ang:Right()*1.2)
			
			cam.Start3D2D(pos, ang, 0.04)
				-- Main Box
				surface_setdrawcolor(black)
				surface_drawrect(-20, -20, 40, 40)
				-- Border
				surface_setdrawcolor(white)
				surface_drawrect(-20, -20, 2, 38)-- Left border
				surface_drawrect(-18, -20, 38, 2)-- Top border
				surface_drawrect(18, -18, 2, 38) -- Right border
				surface_drawrect(-20, 18, 38, 2)

				draw_simpletext(PerfectCasino.Cards:GetHandValue(self.curHands[k][i]), "pCasino.Header.Static", -1, 0, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
			cam.End3D2D()
		end 
	end
end

-- Chip code
function ENT:AddBet(pad, amount)
	self.currentBets[pad] = self.currentBets[pad] or {}

	local chips = PerfectCasino.Chips:GetFromNumber(amount)

	local ang = self:GetAngles()
	for k=#PerfectCasino.Chips.Types, 0, -1 do -- Run it in reverse, putting the highest chips at the bottom
		if not chips[k] then continue end
		for i=1, chips[k] do
			local plaque = k >= 11 -- There are 11 normal skins, so anything over 10 (11-1, due to skins starting at 0) we use the big plaque models

			local chip = ClientsideModel(plaque and "models/freeman/owain_casino_plaque.mdl" or "models/freeman/owain_casino_chip.mdl")
			table.insert(self.currentBets[pad], chip)
			chip:SetParent(self)
			chip:SetSkin(plaque and k-11 or k)
			chip:SetPos(self:GetPos() + ((self:GetUp()*15.8) + (self:GetUp() * (#self.currentBets[pad]*0.3))) + ((self:GetForward()*8) + ((self:GetForward()*-10) * preset[pad].p)) + ((self:GetRight() * -13) * (pad - 2.5)))
			chip:SetAngles(ang)
		end
	end
end
function ENT:ClearBets()
	for _, pad in pairs(self.currentBets) do
		for k, v in pairs(pad) do
			if not IsValid(v) then continue end
			v:Remove()
		end
	end

	self.currentBets = {}
end

-- Card code
function ENT:AddCard(pad, hand, face)
	self.currentCards[pad] = self.currentCards[pad] or {}
	self.currentCards[pad][hand] = self.currentCards[pad][hand] or {}

	local ang = self:GetAngles()
	ang:RotateAroundAxis(ang:Right(), 90)
	--ang:RotateAroundAxis(ang:Up(), 90)
	ang:RotateAroundAxis(ang:Forward(), preset[pad] and preset[pad].a or 0)

	
	local card = ClientsideModel("models/freeman/owain_playingcards.mdl")
	table.insert(self.currentCards[pad][hand], card)
	card:SetParent(self)

	if face then 
		local skin, bodygroup = PerfectCasino.Cards:GetFaceData(face)
		card:SetBodygroup(1, bodygroup)
		card:SetSkin(skin)
		card:SetAngles(ang)
	else
		ang:RotateAroundAxis(ang:Right(), 180)
		ang:RotateAroundAxis(ang:Forward(), 180)
		card:SetAngles(ang)
	end
		

	if pad == 0 then -- Dealers hand
		card:SetPos(self:GetPos() + (self:GetUp()*15.8) + (self:GetForward()*-7) + (self:GetRight()*10) + ((self:GetRight()*-3) * #self.currentCards[pad][hand]))
	else -- Players hand
		-- If there is no existing card, set the basis for the positions of them
		if #self.currentCards[pad][hand] == 1 then
			-- Then positioning for the cards is rather complex to understand on 1 line, so I've decided to comment it out to save myself the pain
			card:SetPos(self:GetPos() -- The table's position
				+ (self:GetUp()*15.8) -- Take it to the hight of the table playing area
				+ (self:GetForward()*2) -- Bring it closer to the edge of the mat
				+ ((self:GetForward()*-9) * (preset[pad].p + ((#self.currentCards[pad][hand]-1)*0.1))) -- Shift the cards up or down the X axist to align with the pads better
				+ ((self:GetRight()*-10) * ((preset[pad].o - 2.7))) -- Move the cards across the Y axis so they are next to their pads
			)
	
		-- Move the cards to the right based on what hand it is. This is done after the first move as we need it's new position to calculate the movement
			card:SetPos(card:GetPos() -- It's current position
				+ ((-card:GetRight()*4) * (hand-1))
			)
		else -- Otherwise we can juse the existing card to position the rest of them
			local baseCard = self.currentCards[pad][hand][#self.currentCards[pad][hand] - 1]
	
			card:SetPos(baseCard:GetPos() -- The base card's position
				+ (self:GetUp()*(#self.currentCards[pad][hand]*0.02))  -- Make each card in that hand higher than the last, so they don't overlap and give glitchy artifacts
				+ (-baseCard:GetRight() * 0.6) -- Shift the card slightly to the right
				+ (baseCard:GetUp() * 0.5) -- Move the card slightly up
			)
		end
	end
end

function ENT:ClearCards()
	for _, pad in pairs(self.currentCards) do
		for k, h in ipairs(pad) do
			for _, c in ipairs(h) do
				if not IsValid(c) then continue end
				c:Remove()
			end
		end
	end

	self.currentCards = {}
end

function ENT:OnRemove()
	self:ClearBets()
	self:ClearCards()
end

net.Receive("pCasino:Blackjack:Bet:Change", function()
	local entity = net.ReadEntity()
	if not IsValid(entity) then return end
	if not entity.data then return end

	local newBet = net.ReadUInt(32)
	entity.currentBid = newBet
end)

net.Receive("pCasino:Blackjack:Bet:Place", function()
	local entity = net.ReadEntity()
	if not IsValid(entity) then return end
	if not entity.data then return end
	if entity:GetPos():DistToSqr(LocalPlayer():GetPos()) > 100000 then return end

	local pad = net.ReadUInt(3)
	local betAmount = net.ReadUInt(32)

	entity:AddBet(pad, betAmount)
end)
net.Receive("pCasino:Blackjack:Clear", function()
	local entity = net.ReadEntity()
	if not IsValid(entity) then return end

	entity:ClearBets()
	entity:ClearCards()

	entity.curHands = {}
end)

net.Receive("pCasino:Blackjack:StartingCards", function()
	local entity = net.ReadEntity()
	if not IsValid(entity) then return end
	if not entity.data then return end
	if entity:GetPos():DistToSqr(LocalPlayer():GetPos()) > 100000 then return end

	local hands = net.ReadTable()
	local dealersHand = net.ReadTable()

	for i, p in pairs(hands) do
		entity.curHands[i] = {} -- Build the pad

		for ih, h in ipairs(p) do
			entity.curHands[i][ih] = {} -- Build the hand

			for _, c in ipairs(h.cards) do
				table.insert(entity.curHands[i][ih], c) -- Add the card to the hand

				entity:AddCard(i, ih, c) -- Add a visual card to the table
			end
		end
	end

	entity.curHands[0] = {}
	entity.curHands[0][1] = {}
	for k, c in pairs(dealersHand) do
		entity:AddCard(0, 1, c)
		table.insert(entity.curHands[0][1], c)
	end
	entity:AddCard(0, 1) -- The dealer's blind card
end)
net.Receive("pCasino:Blackjack:NewCard", function()
	local entity = net.ReadEntity()
	if not IsValid(entity) then return end
	if not entity.data then return end
	if entity:GetPos():DistToSqr(LocalPlayer():GetPos()) > 100000 then return end

	local pad = net.ReadUInt(3)
	local hand = net.ReadUInt(3)
	local card = net.ReadString()

	if (not entity.curHands) or (not entity.curHands[pad]) or (not entity.curHands[pad][hand]) then return end

	table.insert(entity.curHands[pad][hand], card) -- Add the card to the hand
	entity:AddCard(pad, hand, card) -- Add a visual card to the table
end)
net.Receive("pCasino:Blackjack:Split", function()
	local entity = net.ReadEntity()
	if not IsValid(entity) then return end
	if not entity.data then return end
	if entity:GetPos():DistToSqr(LocalPlayer():GetPos()) > 100000 then return end

	local pad = net.ReadUInt(3)
	local hands = net.ReadTable()

	-- Clear the existing cards to rebuild them
	for k, v in pairs(entity.currentCards[pad]) do
		for n, m in pairs(v) do
			m:Remove()
		end
	end

	-- Reset then sub tables
	entity.curHands[pad] = {}

	entity.currentCards[pad] = {}

	for i, h in ipairs(hands) do
		entity.curHands[pad][i] = {}
		for _, c in ipairs(h.cards) do
			table.insert(entity.curHands[pad][i], c) -- Add the card to the hand

			entity:AddCard(pad, i, c)
		end
	end
end)
net.Receive("pCasino:Blackjack:DealerCards", function()
	local entity = net.ReadEntity()
	if not IsValid(entity) then return end
	if not entity.data then return end
	if entity:GetPos():DistToSqr(LocalPlayer():GetPos()) > 100000 then return end

	local dealersCards = net.ReadTable()

	-- Remove the blind card
	if (not entity.currentCards) or (not entity.currentCards[0]) or (not entity.currentCards[0][1]) or (not entity.currentCards[0][1][2]) then return end

	entity.currentCards[0][1][2]:Remove()
	entity.currentCards[0][1][2] = nil
	for i, c in ipairs(dealersCards) do
		if i == 1 then continue end -- We already have the first card placed
		timer.Simple(i-2, function()
			entity:AddCard(0, 1, c)
			table.insert(entity.curHands[0][1], c) -- Add the card to the hand
		end)
	end
end)
--PATH addons/[ekonomia] pcasino/lua/entities/pcasino_sign_interior_standing/shared.lua:
return gluapack()()
--PATH addons/[ekonomia] pcasino/lua/entities/pcasino_sign_interior_wall/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Sign Interior Wall"
ENT.Author = "Owain Owjo & The One Free-Man"
ENT.Category = "pCasino"
ENT.Spawnable = false
ENT.AdminSpawnable = false

PerfectCasino.Core.RegisterEntity("pcasino_sign_interior_wall", {
	-- General data
	general = {
		text = {d = "Roulette Tables", t = "string"} -- The text to show
	}
},
"models/freeman/owain_interiorsign_wall.mdl")
--PATH addons/[ekonomia] pcasino/lua/entities/pcasino_sign_plaque/shared.lua:
return gluapack()()
--PATH lua/entities/pfx1_03.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Fire Embers"
ENT.Category         = "PPE: Fire & Smoke"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[1]embers"
--PATH lua/entities/pfx1_06.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Flamethrower 1"
ENT.Category         = "PPE: Fire & Smoke"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[1]flamethrower_basic"
--PATH lua/entities/pfx1_08~.lua:
return gluapack()()
--PATH lua/entities/pfx1_08~.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Fire [Blue]"
ENT.Category         = "PPE: Fire & Smoke"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[1]_campfire_blue"
--PATH lua/entities/pfx1_0c~.lua:
return gluapack()()
--PATH lua/entities/pfx2_06.lua:
return gluapack()()
--PATH lua/entities/pfx2_06~.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Dripping blood [Alien]"
ENT.Category         = "PPE: Other"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[2]blood_leak_alien"
--PATH lua/entities/pfx4_02.lua:
return gluapack()()
--PATH lua/entities/pfx4_04_s.lua:
return gluapack()()
--PATH lua/entities/pfx4_05.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Electric Arcs"
ENT.Category         = "PPE: Tech"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[4]arcs_electric_1"
--PATH lua/entities/pfx6_00.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Basic Gunfire"
ENT.Category         = "PPE: Weapons"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[6]gunfire_generic"
--PATH lua/entities/pfx6_02b.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "AR2 Tracer"
ENT.Category         = "PPE: Weapons"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[6]bullet_tracer_ar2"
--PATH lua/entities/pfx7_00.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Dusty Wind"
ENT.Category         = "PPE: Weather"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[7]dusty_wind1"
--PATH lua/entities/pfx7_04.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Fog 2"
ENT.Category         = "PPE: Weather"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[7]area_of_fog"
--PATH lua/entities/pfxcom1.lua:
return gluapack()()
--PATH lua/entities/portals_in.lua:
AddCSLuaFile()
DEFINE_BASECLASS("portals_base")

ENT.Base = "portals_base"



ENT.Spawnable = true
ENT.Editable = true

ENT.BaseColor = Color(255, 136, 0)

ENT.ExitType = "portals_out"

function ENT:Initialize()
	BaseClass.Initialize(self)

	self.Filter = {}
end

local defaultSound = GetConVar("porte_default_sound")

function ENT:SetupDataTables()
	self:NetworkVar("String", 0, "Group", {
		KeyName = "group",
		Edit = {
			title = "Groupe de Porte",
			order = 0,
			type = "Generic"
		}
	})

	self:NetworkVar("String", 1, "TeleportSound", {
		KeyName = "sound",
		Edit = {
			title = "Sound Effect",
			order = 1,
			type = "Generic"
		}
	})

	self:NetworkVar("Vector", 0, "PortalColor", {
		KeyName = "portalcolor",
		Edit = {
			title = "Light",
			order = 1,
			type = "VectorColor"
		}
	})

	self:SetTeleportSound(defaultSound:GetString())
	self:SetPortalColor(self.BaseColor:ToVector())
end

local allow = GetConVar("portals_allow_custom_colors")

function ENT:GetCustomColor()
	return allow:GetBool() and self:GetPortalColor():ToColor() or self.BaseColor
end

if SERVER then
	function ENT:StartTouch(ent)
		if self.Filter[ent] or self:GetPhysicsObject():HasGameFlag(FVPHYSICS_PLAYER_HELD) or not self:IsValidEntity(ent) then
			return
		end

		local exits = {}

		for _, v in ipairs(ents.FindByClass(self.ExitType)) do
			if v != self and v:GetGroup() == self:GetGroup() then
				table.insert(exits, v)
			end
		end

		local exit = exits[math.random(1, #exits)]

		if not IsValid(exit) then
			return
		end

		ent:ForcePlayerDrop()

		if ent:IsPlayer() then
			local ang = exit:LocalToWorldAngles(self:WorldToLocalAngles(ent:EyeAngles()))

			ang.p = math.Clamp(math.NormalizeAngle(ang.p), -89, 89)
			ang.r = 0

			ent:SetPos(exit:WorldSpaceCenter())
			ent:SetAngles(ang)
			ent:SetEyeAngles(ang)

			ent:SetVelocity(-ent:GetVelocity())

			ent:ScreenFade(SCREENFADE.IN, self:GetCustomColor(), 0.5, 0)
		else
			local ang = exit:LocalToWorldAngles(self:WorldToLocalAngles(ent:GetAngles()))
			local rot = exit:LocalToWorldAngles(-self:GetAngles())

			local vel = ent:GetVelocity()

			vel:Rotate(rot)

			ent:SetPos(exit:WorldSpaceCenter())
			ent:SetAngles(ang)

			local phys = ent:GetPhysicsObject()

			if IsValid(phys) then
				phys:SetVelocity(vel)
			end
		end

		self:TeleportEffect()
		exit:TeleportEffect(ent)

		if exit.Filter then
			exit.Filter[ent] = true
		end
	end

	function ENT:EndTouch(ent)
		self.Filter[ent] = nil
	end
end

--PATH lua/entities/portals_twoway.lua:
return gluapack()()
--PATH lua/entities/portals_twoway.lua:
AddCSLuaFile()
DEFINE_BASECLASS("portals_in")

ENT.Base = "portals_in"
ENT.RenderGroup = RENDERGROUP_STATIC

ENT.PrintName = "Porte - TP"
ENT.Category = "Aura's LVS Big Ships"

ENT.Spawnable = true

ENT.BaseColor = Color(255, 255, 255)

ENT.ExitType = "portals_twoway"

--PATH lua/entities/republic_control_point.lua:
AddCSLuaFile()

ENT.Type = "anim"
ENT.Base = "base_gmodentity"

-- ENT.Category = "Republic Bases"
ENT.PrintName = "Control Point Base"
ENT.Spawnable = true

ENT.Author = "Stoneman"
ENT.PointCache = {}

if SERVER then
    util.AddNetworkString("RepublicConquest_ControlPointCaptured")
end

// Non SBTM
ENT.TeamEntities = {} -- Entities inside the control point per team.

function ENT:Initialize()
    // Invisible model
    self:SetModel("models/hunter/blocks/cube025x025x025.mdl")
    self:ManipulateBoneScale(0, Vector(0, 0, 0))
    self:SetCollisionGroup(COLLISION_GROUP_IN_VEHICLE)
    self:SetMoveType(MOVETYPE_NONE)
    self:SetSolid(SOLID_BBOX)

    RepublicConquest.Point[self] = table.Count(RepublicConquest.Point) + 1

    if SERVER then
        self:SetTrigger(true)
    end
end

function ENT:CreateFakeProp(model)
    local prop = ents.Create("prop_physics")
    if not model then
        model = "models/props_c17/oildrum001.mdl"
    end
    prop:SetModel(model)
    prop:SetPos(self:GetPos())
    prop:SetAngles(self:GetAngles())
    prop:SetMoveType(MOVETYPE_VPHYSICS)
    prop:SetSolid(SOLID_VPHYSICS)
    prop:SetCollisionGroup(COLLISION_GROUP_NONE)
    prop:PhysicsInit(SOLID_VPHYSICS)
    local phys = prop:GetPhysicsObject()
    if IsValid(phys) then
        phys:EnableMotion(false)
        phys:Wake()
    end
    prop:Spawn()
    prop:Activate()
    
    RepublicConquest:TieToEntity(prop, self, true)
end

function ENT:OnRemove()
    if SERVER then
        if self:GetTiedEntity() then
            if self:GetTiedEntity().CreatedByControlPoint == self then
                self:GetTiedEntity():Remove()
            end
        end
    end

    RepublicConquest.Point[self] = nil
end

// Tag the entity as a tie when we copy.
function ENT:PreEntityCopy()
    // We need to tag both entity and the control point with a unique identifier so we can tie them together when they are pasted.
    duplicator.StoreEntityModifier(self, "TiedControlPoint", {self:EntIndex()})
    duplicator.StoreEntityModifier(self:GetTiedEntity(), "TiedControlPoint", {self:EntIndex()})
end

function ENT:PostEntityPaste(ply, ent, createdEntities)
    timer.Simple(0, function()
        // Check if both the control point and tied entity have matching TiedControlPoint data.
        local dupedIndex = ent.TiedControlPoint[1]

        // If dupedIndex is nil, then we don't have a tied entity.
        if not dupedIndex then return end

        local newTiedEntity
        for _, entity in pairs(createdEntities) do
            if entity:GetClass() == "republic_control_point" then continue end
            local propIndex = entity.EntityMods.TiedControlPoint[1]

            // If the index matches, we have found the tied entity.
            if propIndex == dupedIndex then
                newTiedEntity = entity
                break
            end
        end

        local model = "models/props_c17/oildrum001.mdl"
        if newTiedEntity then
            model = newTiedEntity:GetModel()
        end

        local data = {
            radius = self:GetPointRadius(),
            owner = self:GetOwner(),
            time = self:GetTimeToCapture(),
            icon = self:GetPointIcon(),
            expectation = self:GetPlayerExpectation(),
            model = model,
            circle = self:GetPointCircle(),
            model_active = self:GetPointModelActive(),
            useproximity = self:GetUseProximity(),
            proximity = self:GetProximityDistance(),
        }

        // Re-run creation.
        RepublicConquest:AddPoint(self:GetPos(), data, newTiedEntity)
        
        self:Remove()
    end)
end

duplicator.RegisterEntityModifier("TiedControlPoint", function(ply, ent, data)
    ent.TiedControlPoint = data
end)

function ENT:CreateCustomCollision()
    local points = {}
    local radius = self:GetPointRadius()
    local height = 360  -- Total height of the cylinder
    local numPoints = 12  -- Reduced from 16 for optimization
    local topBottomOffset = height / 2

    -- Create bottom circle
    for i = 0, numPoints do
        local angle = math.rad((i / numPoints) * 360)
        local x = math.cos(angle) * radius
        local y = math.sin(angle) * radius
        table.insert(points, Vector(x, y, -topBottomOffset))
    end

    -- Create top circle
    for i = 0, numPoints do
        local angle = math.rad((i / numPoints) * 360)
        local x = math.cos(angle) * radius
        local y = math.sin(angle) * radius
        table.insert(points, Vector(x, y, topBottomOffset))
    end

    self:PhysicsInitConvex(points)
    self:EnableCustomCollisions(true)
end

function ENT:SetupDataTables()
    // Creation Data (Unchanged):
    self:NetworkVar("Float", 0, "PointRadius")
    self:NetworkVar("Vector", 0, "PointPosition")
    self:NetworkVar("String", 0, "PointIcon")
    self:NetworkVar("Int", 0, "PlayerExpectation")
    self:NetworkVar("Bool", 0, "PointModelActive")
    self:NetworkVar("Bool", 1, "PointCircle")
    self:NetworkVar("Bool", 2, "UseProximity")
    self:NetworkVar("Float", 1, "ProximityDistance")
    self:NetworkVar("Entity", 0, "TiedEntity")
    self:NetworkVar("String", 1, "PointModel")
    self:NetworkVar("Bool", 3, "UseNPCTeam")

    // Capture Data:
    self:NetworkVar("Int", 1, "TeamOwner")
    self:NetworkVar("Float", 2, "Progress")
    self:NetworkVar("Float", 3, "TimeToCapture")
    self:NetworkVar("Int", 2, "TeamProgressing")
    self:NetworkVar("Bool", 4, "Contested")

    self:SetTeamOwner(1) -- Set the owner to neutral.
    self:SetProgress(0) -- Starts at 0 progress.
    self:SetTeamProgressing(1) -- Starts at none.
    self:SetContested(false) -- Not contested.
end

function ENT:IsFriendlyNPC(ent)
    if not ent:IsNPC() then return false end
    if not self:GetUseNPCTeam() then return false end
    local anyPlayer = Entity(1)

    -- Use pcall to safely call Disposition
    local success, disposition = pcall(function()
        return ent:Disposition(anyPlayer)
    end)

    -- If pcall failed or disposition is not set, return false
    if not success or not disposition then return false end

    -- Check disposition
    return disposition == D_LI or disposition == D_NU
end

function ENT:GetControlTeam(ent)
    if RepublicConquest.SBTM then
        return self:Team()
    else
        // We don't use SBTM. So we use set teams. 1 = Neutral, 2 = Player, 3 = NPC.
        if ent:IsPlayer() then
            return 2
        elseif ent:IsNPC() then
            if self:IsFriendlyNPC(ent) then
                return 2
            end
            
            return 3
        end
    end

    return nil
end

function ENT:StartTouch(ent)
    local entTeam = self:GetControlTeam(ent)
    // If a player is in a team..
    if entTeam then
        // Add them to their team table!
        self.TeamEntities[entTeam] = (self.TeamEntities[entTeam] or 0) + 1
    end

    if ent:IsPlayer() then
        ent:SetNWEntity("Conquest_ControlPoint", self)
    end
end

function ENT:EndTouch(ent)
    local entTeam = self:GetControlTeam(ent)
    // If a player is in a team..
    if entTeam and self.TeamEntities[entTeam] then
        // Remove them from their team table!
        self.TeamEntities[entTeam] = self.TeamEntities[entTeam] - 1

        // Cleaning up the table.
        if self.TeamEntities[entTeam] <= 0 then
            self.TeamEntities[entTeam] = nil
        end
    end

    if ent:IsPlayer() then
        if ent:GetNWEntity("Conquest_ControlPoint") == self then
            ent:SetNWEntity("Conquest_ControlPoint", ent)
        end
    end
end

function ENT:GetPointColor()
    return RepublicConquest.Teams[self:GetTeamOwner()].Color
end

function ENT:GetProgressorColor()
    return RepublicConquest.Teams[self:GetTeamProgressing()].Color
end

if SERVER then
    function ENT:ControlPointProgress()
        if not IsValid(self) then return end
        // Debouncing..
        if CurTime() - (self.LastProgressUpdate or 0) < 0.25 then return end
        self.LastProgressUpdate = CurTime()

        // Contesting
        self:SetContested(table.Count(self.TeamEntities) > 1)

        // If there are absolutely no teams inside the control point and there's progress, start decreasing it.
        if table.IsEmpty(self.TeamEntities) and self:GetProgress() > 0 then
            self:UpdateCaptureProgress(false)
        end

        /////// Capturing -- Add progress when a team is inside. ///////
        // If there's a team inside the control point, start increasing progress.
        if table.Count(self.TeamEntities) == 1 then
            // There's only one team inside the control point.
            local captureTeam = next(self.TeamEntities) -- Since this is the only team inside, next will return the only team key inside.
            
            // If there was already progress, we have to de-progress it to 0 first before we can start progressing again.
            if self:GetTeamProgressing() ~= captureTeam then
                // Deprogress!
                self:UpdateCaptureProgress(false)

                if self:GetProgress() <= 0 then
                    // Change team.
                    self:SetTeamProgressing(captureTeam)
                end
            else
                // If we already own the point, do nothing.
                if self:GetTeamOwner() ~= captureTeam then
                    // Progress!
                    self:SetTeamProgressing(captureTeam)
                    self:UpdateCaptureProgress(true, captureTeam)

                    if self:GetProgress() >= 1 then
                        self:CaptureControlPoint(captureTeam)
                    end
                end
            end
        end
    end

    function ENT:UpdateCaptureProgress(capture, capturingTeam)
        if not IsValid(self) then return end

        local timeToCapture = self:GetTimeToCapture()
        local progress = self:GetProgress()
        local progressPerSecond = 0.25 / timeToCapture

        // Progress per second goes down if player expectation isn't matched.
        // If expectation is 10, and there's 1 player, we're at 10% of the rate.
        
        if capture then
            local playerExpectation = self:GetPlayerExpectation()
            local playerCount = self.TeamEntities[capturingTeam]
            local newProgressPerSecond = progressPerSecond * (playerCount / playerExpectation)
            // Cap the progress per second to 100% max rate.
            newProgressPerSecond = math.Clamp(newProgressPerSecond, 0, progressPerSecond)
            self:SetProgress(math.Clamp(progress + newProgressPerSecond, 0, 1))
        else
            self:SetProgress(math.Clamp(progress - progressPerSecond, 0, 1))
        end
    end

    function ENT:CaptureControlPoint(team)
        // Set the team owner to the team.
        self:SetTeamOwner(team)
        self:SetProgress(0)
        self:SetTeamProgressing(1)

        net.Start("RepublicConquest_ControlPointCaptured")
        net.Broadcast()
    end

    function ENT:Think()
        self:ControlPointProgress()
        self:NextThink(CurTime() + 0.25)
        return true
    end
end

local function Draw3DCircle(pos, rad, clr, detail, thick)
    local AlphaMask = Color(0, 0, 0, 0)
	render.SetStencilEnable(true)
	render.SetStencilWriteMask( 0xFF )
	render.SetStencilTestMask( 0xFF )
	render.SetStencilReferenceValue( 0 )
	render.SetStencilCompareFunction( STENCIL_ALWAYS )
	render.SetStencilPassOperation( STENCIL_KEEP )
	render.SetStencilFailOperation( STENCIL_KEEP )
	render.SetStencilZFailOperation( STENCIL_KEEP )
	render.SetColorMaterial()
	render.ClearStencil()
	-- All
	render.SetStencilReferenceValue(7)
	render.SetStencilZFailOperation(STENCILOPERATION_REPLACE)
	render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_ALWAYS)
	render.DrawSphere(pos, -rad, detail, detail, AlphaMask)
	-- Under
	render.SetStencilReferenceValue(7)
	render.SetStencilZFailOperation(STENCILOPERATION_DECR)
	render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_ALWAYS)
	render.DrawSphere(pos, rad, detail, detail, AlphaMask)
	-- Inner
	render.SetStencilReferenceValue(7)
	render.SetStencilZFailOperation(STENCILOPERATION_INCR)
	render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_ALWAYS)
	render.DrawSphere(pos, -math.max(rad - thick, 0), detail, detail, AlphaMask)
	render.SetStencilZFailOperation(STENCILOPERATION_DECR)
	-- Overall
	render.SetStencilReferenceValue(7)
	render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_ALWAYS)
	render.DrawSphere(pos, math.max(rad - thick, 0), detail, detail, AlphaMask)
	render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_EQUAL)

	cam.IgnoreZ(true)
	render.SetStencilReferenceValue(7)
	render.DrawSphere(pos, rad + thick, detail, detail, clr)
	render.DrawSphere(pos, -rad, detail, detail, clr)
	cam.IgnoreZ(false)
	render.SetStencilEnable(false)
end

function ENT:GeneratePoints()
    local points = {}
    local radius = self:GetPointRadius()
    local height = 360  -- Total height of the cylinder
    local numPoints = 12  -- Reduced from 16 for optimization
    local topBottomOffset = height / 2

    -- Create bottom circle
    for i = 0, numPoints do
        local angle = math.rad((i / numPoints) * 360)
        local x = math.cos(angle) * radius
        local y = math.sin(angle) * radius
        table.insert(points, Vector(x, y, -topBottomOffset))
    end

    -- Create top circle
    for i = 0, numPoints do
        local angle = math.rad((i / numPoints) * 360)
        local x = math.cos(angle) * radius
        local y = math.sin(angle) * radius
        table.insert(points, Vector(x, y, topBottomOffset))
    end

    return points
end

function ENT:DrawPointCache()
    if not self.PointCache then return end
    for i = 1, #self.PointCache do
        local nextPoint = self.PointCache[i + 1] or self.PointCache[1]
        render.DrawLine(self:GetPos() + self.PointCache[i], self:GetPos() + nextPoint, 0.1, Color(255, 0, 0), false)
    end
end

function ENT:Draw()
    if self:GetPointCircle() then
        Draw3DCircle(self:GetPos(), self:GetPointRadius(), Color(0, 255, 0), 50, 10)
    end
    self:DrawModel()

    // Check if you have toolgun on
    if not IsValid(LocalPlayer():GetActiveWeapon()) then return end
    if LocalPlayer():GetActiveWeapon():GetClass() != "gmod_tool" then return end

    if table.IsEmpty(self.PointCache) then
        self.PointCache = self:GeneratePoints()
    end

    self:DrawPointCache()
end

--PATH lua/entities/roy_eta2_lvs/cl_init.lua:
return gluapack()()
--PATH lua/entities/rw_sw_dispencer/shared.lua:
return gluapack()()
--PATH lua/entities/rw_sw_dispencer_allammo/cl_init.lua:
include('shared.lua')

function ENT:Draw()
	self:DrawModel()
end
--PATH lua/entities/rw_sw_dispencer_rocket/cl_init.lua:
include('shared.lua')

function ENT:Draw()
	self:DrawModel()
end
--PATH lua/entities/rw_sw_dispencer_rocket/shared.lua:
return gluapack()()
--PATH lua/entities/sammyservers_textscreen/shared.lua:
return gluapack()()
--PATH lua/entities/sent_vj_fireplace.lua:
/*--------------------------------------------------
	*** Copyright (c) 2012-2023 by DrVrej, All rights reserved. ***
	No parts of this code or any of its contents may be reproduced, copied, modified or adapted,
	without the prior written consent of the author, unless otherwise indicated for stand-alone materials.
--------------------------------------------------*/
AddCSLuaFile()
if (!file.Exists("autorun/vj_base_autorun.lua","LUA")) then return end

ENT.Base 			= "base_gmodentity"
ENT.Type 			= "anim"
ENT.PrintName 		= "Fireplace"
ENT.Author 			= "DrVrej"
ENT.Contact 		= "http://steamcommunity.com/groups/vrejgaming"
ENT.Purpose 		= "Gives a warm feeling, especially in snowy maps."
ENT.Instructions 	= "Don't change anything."
ENT.Category		= "VJ Base"

ENT.Spawnable = true
ENT.AdminOnly = false
---------------------------------------------------------------------------------------------------------------------------------------------
if CLIENT then
	ENT.NextActivationCheckT = 0
	ENT.NextFireLightT = 0
	ENT.DoneFireParticles = false
	
	function ENT:Draw()
		self:DrawModel()
	end
	
	function ENT:Think()
		if CurTime() > self.NextActivationCheckT then
			if self:GetNW2Bool("VJ_FirePlace_Activated") == true then
				if self.DoneFireParticles == false then
					self.DoneFireParticles = true
					ParticleEffectAttach("env_fire_tiny_smoke",PATTACH_ABSORIGIN_FOLLOW,self,0)
					ParticleEffectAttach("env_embers_large",PATTACH_ABSORIGIN_FOLLOW,self,0)
				end
				if CurTime() > self.NextFireLightT then
					local FireLight1 = DynamicLight(self:EntIndex())
					if (FireLight1) then
						FireLight1.Pos = self:GetPos() +self:GetUp() * 15
						FireLight1.R = 255
						FireLight1.G = 100
						FireLight1.B = 0
						FireLight1.Brightness = 2
						FireLight1.Size = 400
						FireLight1.Decay = 400
						FireLight1.DieTime = CurTime() + 1
					end
					self.NextFireLightT = CurTime() + 0.2
				end
			else
				self.DoneFireParticles = false
			end
			self.NextActivationCheckT = CurTime() + 0.1
		end
	end
end
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
if !SERVER then return end

ENT.FirePlaceOn = false

---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:Initialize()
	self:SetNW2Bool("VJ_FirePlace_Activated", false)
	self:SetModel("models/vj_props/fireplace.mdl")
	self:PhysicsInit(SOLID_VPHYSICS)
	self:SetMoveType(MOVETYPE_NONE)
	self:SetSolid(SOLID_VPHYSICS)
	self:SetUseType(SIMPLE_USE)
	
	self:SetCollisionBounds(Vector(25,25,25),Vector(-25,-25,1))
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:Think()
	if self.FirePlaceOn == false then
		VJ_STOPSOUND(self.firesd)
		self:StopParticles()
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:Use(activator, caller)
	if self.FirePlaceOn == false then
		self:SetNW2Bool("VJ_FirePlace_Activated", true)
		self.FirePlaceOn = true
		self:EmitSound(Sound("ambient/fire/mtov_flame2.wav"), 60, 100)
		self.firesd = CreateSound(self, "ambient/fire/fire_small_loop1.wav")
		self.firesd:SetSoundLevel(60)
		self.firesd:PlayEx(1,100)
		activator:PrintMessage(HUD_PRINTTALK, "#vjbase.print.fireplace.activated") 
	else
		self:SetNW2Bool("VJ_FirePlace_Activated", false)
		self.FirePlaceOn = false
		self:StopParticles()
		VJ_STOPSOUND(self.firesd)
		activator:PrintMessage(HUD_PRINTTALK, "#vjbase.print.fireplace.deactivated")
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:OnTakeDamage(dmginfo)
	return false
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:Touch(entity)
	if (IsValid(entity) && entity:GetPos():Distance(self:GetPos()) <= 38 && self.FirePlaceOn == true) && (entity:IsNPC() or entity:IsPlayer()) then
		entity:Ignite(math.Rand(3,5))
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:PhysicsCollide(data, physobj)
	//self:EmitSound("physics/cardboard/cardboard_box_impact_soft"..math.random(1,5)..".wav")
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:OnRemove()
	self:StopParticles()
	VJ_STOPSOUND(self.firesd)
end
--PATH addons/[miecze] moce i hilty/lua/entities/sf_rock/shared.lua:
ENT.Type 				= "anim"  
ENT.PrintName			= "Boulder" 
ENT.Author				= "Solace"  
ENT.Spawnable			= false
ENT.AdminSpawnable		= false


local modelList = {
"models/props_wasteland/rockgranite03a.mdl",
"models/props_wasteland/rockgranite03b.mdl",
"models/props_wasteland/rockgranite03c.mdl"
}

if SERVER then
	AddCSLuaFile( "shared.lua" )
	
	function ENT:Initialize()
		self:SetModel(table.Random( modelList ))

		self:PhysicsInit( SOLID_VPHYSICS ) 	
		self:SetSolid( SOLID_VPHYSICS ) 
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetCollisionGroup ( COLLISION_GROUP_INTERACTIVE )
		
		self.DieTime = CurTime() + 5

		local phys = self:GetPhysicsObject()
		phys:EnableGravity( false )
		phys:EnableDrag( false )
		phys:Wake()
		phys:SetAngleVelocity(Vector(math.Rand(0,180), math.Rand(0,180), math.Rand(0,180)))
		
		util.SpriteTrail( self, 0, Color( 255, 255, 255, 40 ), false, 36, 0, 0.3, 0.03125, "trails/smoke" )
	end
	
	function ENT:PhysicsCollide( data, phys )
		local ent = data.HitEntity
		local phys = self:GetPhysicsObject()
		local speed = phys:GetVelocity():LengthSqr()
		self.DamageCooldown = (self.DamageCooldown or CurTime() - 0.01)
		if speed > 40000 then
			self:EmitSound("physics/concrete/boulder_impact_hard1.wav", 90, math.random( 80, 120 ))
			if self.DamageCooldown < CurTime() then
				ent:TakeDamage( 1500, self:GetOwner(), self)
				self.DamageCooldown = CurTime() + 0.1
			end
		end
	end
	
	function ENT:Think()
		if self.IsThrown and self.DieTime <= CurTime() then
			self:Remove()
		end
	end
end
--PATH gamemodes/starwarsrp/entities/entities/spawned_ammo/shared.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/entities/entities/spawned_shipment/shared.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/entities/entities/spawned_weapon/shared.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/entities/tfa_battlefront_ent_nade_incendiary.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/entities/tfa_battlefront_ent_nade_poison.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/entities/tfa_battlefront_ent_nade_smoke.lua:
ENT.Type = "anim"
ENT.Base = "arccw_thr"
ENT.PrintName = "explosive Grenade"
ENT.Author = ""
ENT.Information = ""
ENT.Spawnable = false
ENT.AdminSpawnable = false 

ENT.BounceSound = Sound("TFA_CSGO_SmokeGrenade.Bounce")
ENT.ExplodeSound = Sound("weapons/tfa_starwars/Smoke_Explosive_Puff_01.wav")

AddCSLuaFile()

function ENT:Initialize()
	if SERVER then
		self:SetModel("models/weapons/tfa_starwars/w_smoke.mdl") 
		self:PhysicsInit(SOLID_VPHYSICS)
		self:SetMoveType(MOVETYPE_VPHYSICS)
		self:SetSolid(SOLID_VPHYSICS)
		self:SetCollisionGroup(COLLISION_GROUP_DEBRIS)
		
		local phys = self:GetPhysicsObject()
		if phys:IsValid() then
			phys:Wake()
			phys:SetBuoyancyRatio(0)
		end
		
		self.Delay = CurTime() + 2
		self.NextParticle = 0
		self.ParticleCount = 0
		self.First = true
		self.IsDetonated = false
	end
	self:EmitSound("TFA_CSGO_SmokeGrenade.Throw")
end

function ENT:PhysicsCollide(data, physobj)
	if SERVER then
		self.HitP = data.HitPos
		self.HitN = data.HitNormal

		if self:GetVelocity():Length() > 60 then
			self:EmitSound(self.BounceSound)
		end
		
		if self:GetVelocity():Length() < 5 then
			self:SetMoveType(MOVETYPE_NONE)
		end
		
		for k, v in pairs( ents.FindInSphere( self:GetPos(), 155 ) ) do
			if v:GetClass() == "tfa_csgo_fire_1" or v:GetClass() == "tfa_csgo_fire_2" and self.IsDetonated == false then
				self:Detonate(self,self:GetPos())
				self.IsDetonated = true
			end
		end
			
	end
end

function ENT:Think()
	if SERVER then	
		if CurTime() > self.Delay then
			if self.IsDetonated == false then
				self:Detonate(self,self:GetPos())
				self.IsDetonated = true
			end
		end
	end
	
	if self.IsDetonated then
		for k, v in pairs( ents.FindInSphere( self:GetPos(), 155 ) ) do
			if (v:GetClass("tfa_csgo_fire_1") or v:GetClass("tfa_csgo_fire_2")) and v:IsValid() then
				v:SetNWBool("extinguished",true)
			end
			if v:GetNWBool("extinguished",true) and self.ParticleCreated == false then
				ParticleEffect( "extinguish_fire", self:GetPos(), self:GetAngles() )
				self.ExtinguishParticleCreated = true
			end
		end
	end
end

function ENT:Detonate(self,pos)
	self.ParticleCreated = false
	self.ExtinguishParticleCreated = false
	if SERVER then
		if not self:IsValid() then return end
		self:SetNWBool("IsDetonated",true)
		self:EmitSound(self.ExplodeSound)
		local gas = EffectData()
		gas:SetOrigin(pos)
		gas:SetEntity(self.Owner) //i dunno, just use it!
		util.Effect("tfa_csgo_smokenade", gas)
	end
	if self.ParticleCreated != true then
		ParticleEffectAttach("explosion_child_smoke03e",PATTACH_ABSORIGIN_FOLLOW,self,0)
		ParticleEffectAttach("explosion_child_core06b",PATTACH_POINT_FOLLOW,self,0)
		ParticleEffectAttach("explosion_child_smoke07b",PATTACH_ABSORIGIN_FOLLOW,self,0)
		ParticleEffectAttach("explosion_child_smoke07c",PATTACH_POINT_FOLLOW,self,0)
		ParticleEffectAttach("explosion_child_distort01c",PATTACH_POINT_FOLLOW,self,0)
		self.ParticleCreated = true
	end
	for k, v in pairs( ents.FindInSphere( self:GetPos(), 155 ) ) do
		if (v:GetClass("tfa_csgo_fire_1") or v:GetClass("tfa_csgo_fire_2")) and v:IsValid() then
			v:SetNWBool("extinguished",true)
		end
		if v:GetNWBool("extinguished",true) and self.ParticleCreated == false then
			ParticleEffect( "extinguish_fire", self:GetPos(), self:GetAngles() )
			self.ExtinguishParticleCreated = true
		end
	end
	
	self:SetMoveType( MOVETYPE_NONE )
	
	if SERVER then
		SafeRemoveEntityDelayed(self,20)
	end
	
end

function ENT:Draw()
	if CLIENT then
		self:DrawModel()
	end
end
--PATH lua/entities/tfa_thrown_blade/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()
end
--PATH lua/entities/turbolaser/cl_init.lua:
return gluapack()()
--PATH lua/entities/turbolaser/cl_init.lua:
include("shared.lua")
util.PrecacheModel("models/kingpommes/starwars/venator/vanilla/turbolaser_bolt.mdl")

function ENT:Initialize()
    self.bolt = ClientsideModel("models/kingpommes/starwars/venator/vanilla/turbolaser_bolt.mdl",RENDERGROUP_BOTH)
    if self:GetColour() == "Blue" then
        self.bolt:SetSkin(0)
    elseif self:GetColour() == "Red" then
        self.bolt:SetSkin(1)
    elseif self:GetColour() == "Green" then
        self.bolt:SetSkin(2)
    elseif self:GetColour() == "Orange" then
        self.bolt:SetSkin(3)
    elseif self:GetColour() == "Yellow" then
        self.bolt:SetSkin(4)
    elseif self:GetColour() == "Pink" then
        self.bolt:SetSkin(5)
    elseif self:GetColour() == "Black" then
        self.bolt:SetSkin(6)
    end
end

function ENT:Draw()
    --self:DrawModel()
end

function ENT:Think()
    self.bolt:SetPos(self:GetPos())
    self.bolt:SetAngles(self:GetAngles())
    if ! self:IsValid() then
        self.bolt:Remove()
    end
end

function ENT:OnRemove()
    self.bolt:Remove()
end

language.Add("turbolaser", "Turbolaser")

/*
    - Fixed a bug where an error would be displayed.
*/

--PATH lua/entities/unitys-lvs-tx-2112/cl_init.lua:
include("shared.lua")
include("cl_lights.lua")

ENT.Overlay = Material("yeetcat/tx2112-overlay.png", "smooth")

function ENT:DamageFX()
    self.nextDFX = self.nextDFX or 0

    if self.nextDFX < CurTime() then
        self.nextDFX = CurTime() + 0.05

        local HP = self:GetHP()
        local MaxHP = self:GetMaxHP()

        if HP > MaxHP * 0.75 then return end

        local effectdata = EffectData()
        effectdata:SetOrigin(self:LocalToWorld(Vector(30,-43,83)))
        effectdata:SetEntity(self)
        util.Effect("lvs_engine_blacksmoke", effectdata)

        if HP <= MaxHP * 0.6 then
            local effectdata = EffectData()
            effectdata:SetOrigin(self:LocalToWorld(Vector(-128,15,90)))
            effectdata:SetNormal(self:GetUp())
            effectdata:SetMagnitude(math.Rand(0.5,1.5))
            effectdata:SetEntity(self)
            util.Effect("lvs_exhaust_fire", effectdata)

            local effectdata = EffectData()
            effectdata:SetOrigin(self:LocalToWorld(Vector(-128,-15,90)))
            effectdata:SetNormal(self:GetUp())
            effectdata:SetMagnitude(math.Rand(0.5,1.5))
            effectdata:SetEntity(self)
            util.Effect("lvs_exhaust_fire", effectdata)
        end


        if HP <= MaxHP * 0.5 then
            local effectdata = EffectData()
            effectdata:SetOrigin(self:LocalToWorld(Vector(30,-54,83)))
            effectdata:SetNormal(self:GetUp())
            effectdata:SetMagnitude(math.Rand(0.5,3))
            effectdata:SetEntity(self)
            util.Effect("lvs_exhaust_fire", effectdata)
        end
    end
end

function ENT:OnFrame()
    self:DamageFX()
    self:EngineFX()
end

function ENT:EngineFX()
    local VelL = self:WorldToLocal(self:GetPos() + self:GetVelocity())
    local r = math.Clamp(math.abs(VelL.x / self.MaxVelocityX),0,1)

    local effectdata = EffectData()
    effectdata:SetOrigin(self:LocalToWorld(Vector(-128,15,100)))
    effectdata:SetNormal(self:GetUp())
    effectdata:SetMagnitude(r)
    effectdata:SetEntity(self)
    util.Effect("unitys_engine", effectdata)

    effectdata:SetOrigin(self:LocalToWorld(Vector(-128,-15,100)))
    util.Effect("unitys_engine", effectdata)
end

function ENT:CalcViewOverride(ply, pos, angles, fov, pod)
    if ply == self:GetDriver() and pod:GetThirdPersonMode() then
        return self:GetPos(), angles, fov
    end
    if ply == self:GetDriver() and not pod:GetThirdPersonMode() then
        return self:LocalToWorld(Vector(88,37.19,81)), angles, fov
    end

    local GunnerPod = self:GetGunnerSeat()
    if pod == GunnerPod then
        if not self.TurretId then
            self.TurretId = self:LookupBone("turret")
        end
        if not self.BarrelId then
            self.BarrelId = self:LookupBone("barrel")
        end
        local turretOrigin, _ = self:GetBonePosition(self.TurretId)
        local barrelOrigin, barrelAngle = self:GetBonePosition(self.BarrelId)

        if pod:GetThirdPersonMode() then
            return turretOrigin + self:GetUp() * 20, angles + Angle(6), fov
        end
        local newPos = LocalToWorld(Vector(0, 8, -25), Angle(), barrelOrigin, barrelAngle)

        local HP = self:GetHP()
        local MaxHP = self:GetMaxHP()

        if HP <= MaxHP * 0.5 then
            local t = self:GetBarrelTrace()
            angles = (t.HitPos - barrelOrigin):Angle()
        end

        return newPos, angles, fov
    end

    return pos, angles, fov
end

function ENT:DrawGunnerOverlay()
    if LocalPlayer():GetVehicle() ~= self:GetGunnerSeat() then return end

    if LocalPlayer():GetVehicle():GetThirdPersonMode() then return end

    local HP = self:GetHP()
    local MaxHP = self:GetMaxHP()

    if HP <= MaxHP * 0.5 then
        DrawMaterialOverlay("effects/tvscreen_noise002a", 1)
    end


    surface.SetMaterial(self.Overlay)
    surface.SetDrawColor(255,255,255,255)
    surface.DrawTexturedRect(0,0,ScrW(), ScrH())
end

--PATH lua/entities/v-wing.lua:
ENT.RenderGroup = RENDERGROUP_BOTH
ENT.Base = "fighter_base"
ENT.Type = "vehicle"

ENT.PrintName = "V-Wing"
ENT.Author = "Liam0102"
ENT.Category = "Star Wars Vehicles: Republic"
ENT.AutomaticFrameAdvance = true
ENT.Spawnable = false;
ENT.AdminSpawnable = false;

ENT.EntModel = "models/vwing/vwing1.mdl"
ENT.Vehicle = "VWing"
ENT.StartHealth = 1500;
ENT.Allegiance = "Rebels";
list.Set("SWVehicles", ENT.PrintName, ENT);
if SERVER then

ENT.FireSound = Sound("weapons/xwing_shoot.wav");
ENT.NextUse = {Wings = CurTime(),Use = CurTime(),Fire = CurTime(),};


AddCSLuaFile();
function ENT:SpawnFunction(pl, tr)
	local e = ents.Create("v-wing");
	e:SetPos(tr.HitPos + Vector(0,0,0));
	e:SetAngles(Angle(0,pl:GetAimVector():Angle().Yaw,0));
	e:Spawn();
	e:Activate();
	return e;
end

function ENT:Initialize()


	self:SetNWInt("Health",self.StartHealth);
	
	self.WeaponLocations = {
		Left = self:GetPos()+self:GetForward()*100+self:GetUp()*70+self:GetRight()*-70,
		Right = self:GetPos()+self:GetForward()*100+self:GetUp()*70+self:GetRight()*70,
	}
	self.WeaponsTable = {};
	self.BoostSpeed = 1500;
	self.ForwardSpeed = 2250;
	self.UpSpeed = 600;
	self.AccelSpeed = 8;
	self.CanStandby = false;
	self.CanBack = false;
	self.CanRoll = false;
	self.CanStrafe = true;
	self.Cooldown = 2;
	self.HasWings = true;
	self.CanShoot = true;
	self.Bullet = CreateBulletStructure(75,"green");
	self.FireDelay = 0.15;
	self.AlternateFire = true;
	self.FireGroup = {"Left","Right",};


	//self.ExitModifier = {x=0,y=225,z=100};
	
	self.BaseClass.Initialize(self);
end

function ENT:Think()

	if(self.Inflight) then
		if(self.Wings) then
			self.CanShoot = true;
			self.CanStrafe = true;
			self.CanRoll = false;
		else
			self.CanShoot = false;
			self.CanRoll = true;
			self.CanStrafe = false;
		end
	end

	self.BaseClass.Think(self);
end


end

if CLIENT then
	
	ENT.CanFPV = false;
	ENT.Sounds={
		Engine=Sound("ambient/atmosphere/ambience_base.wav"),
	}
	
	function ENT:Initialize()
		self.Emitter = ParticleEmitter(self:GetPos());
		self.BaseClass.Initialize(self);
	end
	
    ENT.ViewDistance = 700;
    ENT.ViewHeight = 200;
	
	function ENT:Effects()
	
		self.ThrusterLocations = {
			self:GetPos()+self:GetUp()*77.5+self:GetForward()*-110,
			self:GetPos()+self:GetUp()*47.5+self:GetForward()*-110,
		}
		local p = LocalPlayer();
		local roll = math.Rand(-45,45);
		local normal = (self.Entity:GetForward() * -1):GetNormalized();
		local id = self:EntIndex();
		for k,v in pairs(self.ThrusterLocations) do

			local heatwv = self.Emitter:Add("sprites/heatwave",v);
			heatwv:SetVelocity(normal*2);
			heatwv:SetDieTime(0.1);
			heatwv:SetStartAlpha(255);
			heatwv:SetEndAlpha(255);
			heatwv:SetStartSize(13);
			heatwv:SetEndSize(10);
			heatwv:SetColor(255,255,255);
			heatwv:SetRoll(roll);
			
			local blue = self.FXEmitter:Add("sprites/bluecore",v)
			blue:SetVelocity(normal)
			blue:SetDieTime(0.05)
			blue:SetStartAlpha(255)
			blue:SetEndAlpha(255)
			blue:SetStartSize(13)
			blue:SetEndSize(10)
			blue:SetRoll(roll)
			blue:SetColor(255,255,255)
			
			local dynlight = DynamicLight(id + 4096 * k);
			dynlight.Pos = v;
			dynlight.Brightness = 5;
			dynlight.Size = 150;
			dynlight.Decay = 1024;
			dynlight.R = 100;
			dynlight.G = 100;
			dynlight.B = 255;
			dynlight.DieTime = CurTime()+1;

		end
	end
	
	function ENT:Think()
	
		self.BaseClass.Think(self)
		
		local p = LocalPlayer();
		local Flying = self:GetNWBool("Flying".. self.Vehicle);
		local TakeOff = self:GetNWBool("TakeOff");
		local Land = self:GetNWBool("Land");
		if(Flying) then
			if(!TakeOff and !Land) then
				self:Effects();
			end
		end
		
	end
	
	function VWingReticle()
		
		local p = LocalPlayer();
		local Flying = p:GetNWBool("FlyingVWing");
		local self = p:GetNWEntity("VWing");
		if(Flying and IsValid(self)) then
			SW_HUD_DrawHull(1500);
			SW_WeaponReticles(self);
			SW_HUD_DrawOverheating(self);

			SW_HUD_Compass(self);
			SW_HUD_DrawSpeedometer();
		end
	end
	hook.Add("HUDPaint", "VWingReticle", VWingReticle)

end
--PATH lua/entities/x-wing.lua:
return gluapack()()
--PATH lua/entities/y-wing.lua:
return gluapack()()
--PATH lua/effects/fxbase.lua:
-- based on nomad's tracer by Chad Barrett --
-- edited for the use with SciFiWeapons by Darken217 --

AddCSLuaFile()
if ( CLIENT ) then
TRACER_FLAG_USEATTACHMENT	= 0x0002
end
EFFECT.Speed	= 6500
EFFECT.Length	= 64
EFFECT.Normal 	= Vector( 0, 0, 0 )

function EFFECT:GetTracerOrigin( data )
	if ( CLIENT ) then
		local vOrigin = data:GetStart()

		if ( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then
			local entParent = data:GetEntity()
			
			if ( !IsValid( entParent ) ) then 
				return vOrigin 
			end
			
			if ( !game.SinglePlayer() && entParent:IsEFlagSet( EFL_DORMANT ) ) then 
				return vOrigin 
			end
			
			if( entParent:IsWeapon() && entParent:IsCarriedByLocalPlayer() ) then
				local entPlayer = entParent:GetOwner()
				if ( IsValid( entPlayer ) ) then
					local entViewModel = entPlayer:GetViewModel()
					if ( IsValid( entViewModel ) && !LocalPlayer():ShouldDrawLocalPlayer() ) then
						entParent = entViewModel
					else 					
						if ( entParent.WorldModel ) then
							entParent:SetModel( entParent.WorldModel )
						end
					end
				end
			end

			local attachment = entParent:GetAttachment( data:GetAttachment() )
			if ( attachment ) then
				vOrigin = attachment.Pos
			end

		end
		
		return vOrigin
	end
end

function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data )
	self.EndPos = data:GetOrigin()
	self.Parent = data:GetEntity()
	
--	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos )

	local diff = ( self.EndPos - self.StartPos )
	
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	
	if ( !self.LifeTime ) then
		self.LifeTime = ( diff:Length() + self.Length ) / self.Speed
	else
		self.LifeTime = CurTime() + self.LifeTime
	end
	
end

function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	
	return self.LifeTime > 0

end

function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	
	startDistance = math.max( 0, startDistance )
	endDistance = math.max( 0, endDistance )

	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	
end
--PATH lua/effects/arc9_tracer.lua:
EFFECT.StartPos = Vector(0, 0, 0)
EFFECT.EndPos = Vector(0, 0, 0)
EFFECT.StartTime = 0
EFFECT.LifeTime = 0.2
EFFECT.LifeTime2 = 0.2
EFFECT.DieTime = 0
EFFECT.Color = Color(255, 255, 255)
EFFECT.Speed = 15000
EFFECT.Size = 1

--local head = Material("effects/whiteflare")
local tracer = Material("arc9/tracer")
--local smoke = Material("effects/smoke")
local smoke = Material("effects/fas_smoke_beam")

function EFFECT:Init(data)
    local hit = data:GetOrigin()
    local wep = data:GetEntity()

    if !IsValid(wep) then return end
    if !wep.ARC9 then return end

    local speed = data:GetScale()
    local start = (wep.GetTracerOrigin and wep:GetTracerOrigin()) or data:GetStart()

    if speed > 0 then
        self.Speed = speed
    end
	
    self.LifeTime = (hit - start):Length() / self.Speed
    self.StartTime = UnPredictedCurTime()
    self.DieTime = UnPredictedCurTime() + math.max(self.LifeTime, self.LifeTime2)

    self.StartPos = start
    self.EndPos = hit

    -- Sometimes it freaks out and, I dunno, gets invalid
    if wep.GetProcessedValue then
        self.Color = wep:GetProcessedValue("TracerColor")

        self.Size = wep:GetProcessedValue("TracerSize")
    end
end

function EFFECT:Think()
    return self.DieTime > UnPredictedCurTime()
end

local function LerpColor(d, col1, col2)
    local r = Lerp(d, col1.r, col2.r)
    local g = Lerp(d, col1.g, col2.g)
    local b = Lerp(d, col1.b, col2.b)
    local a = Lerp(d, col1.a, col2.a)
    return Color(r, g, b, a)
end

function EFFECT:Render()
    local d = (UnPredictedCurTime() - self.StartTime) / self.LifeTime
    local d2 = (UnPredictedCurTime() - self.StartTime) / self.LifeTime2
    local startpos = self.StartPos + (d * 0.1 * (self.EndPos - self.StartPos))
    local endpos = self.StartPos + (d * (self.EndPos - self.StartPos))
    local size = self.Size

    local col = LerpColor(d, self.Color, Color(0, 0, 0, 0))
    local col2 = LerpColor(d2, Color(155, 155, 155, 155), Color(0, 0, 0, 0))

    --render.SetMaterial(head)
    --render.DrawSprite(endpos, size * 2, size * 2, col)

    render.SetMaterial(tracer)
    render.DrawBeam(startpos, endpos, size, 0, 1, col)

    render.SetMaterial(smoke)
    render.DrawBeam(startpos, endpos, size * d2, 0, 1, col2)
end

--PATH lua/effects/arccw_flashexplosion.lua:
return gluapack()()
--PATH lua/effects/arccw_ricochet.lua:
EFFECT.StartPos = Vector(0, 0, 0)
EFFECT.EndPos = Vector(0, 0, 0)
EFFECT.StartTime = 0
EFFECT.LifeTime = 0.2
EFFECT.DieTime = 0
EFFECT.Color = Color(255, 255, 255)
-- EFFECT.Speed = 500

local head = Material("effects/whiteflare")
local tracer = Material("trails/smoke")

function EFFECT:Init(data)

    local start = data:GetStart()
    local hit = data:GetOrigin()

    -- self.LifeTime = (hit - start):Length() / self.Speed

    self.LifeTime = 0.25

    self.StartTime = UnPredictedCurTime()
    self.DieTime = UnPredictedCurTime() + self.LifeTime

    self.StartPos = start
    self.EndPos = hit
end

function EFFECT:Think()
    return self.DieTime > UnPredictedCurTime()
end

local function LerpColor(d, col1, col2)
    local r = Lerp(d, col1.r, col2.r)
    local g = Lerp(d, col1.g, col2.g)
    local b = Lerp(d, col1.b, col2.b)
    local a = Lerp(d, col1.a, col2.a)
    return Color(r, g, b, a)
end

function EFFECT:Render()
    local d = (UnPredictedCurTime() - self.StartTime) / self.LifeTime
    -- local endpos = self.StartPos + (d * (self.EndPos - self.StartPos))
    local endpos = self.EndPos
    local size = 1

    local col = LerpColor(d, self.Color, Color(0, 0, 0, 0))

    render.SetMaterial(head)
    render.DrawSprite(endpos, size, size, col)

    render.SetMaterial(tracer)
    render.DrawBeam(endpos, self.StartPos, size * 0.75, 0, 1, col)
end
--PATH lua/effects/astra_beam_noattach.lua:
return gluapack()()
--PATH lua/effects/astw2_muzzleflash_swrc_blue_sniper/init.lua:
return gluapack()()
--PATH lua/effects/astw2_muzzleflash_swrc_conc_rifle/init.lua:
local AddVel = Vector()

function EFFECT:Init(data)
    local quality = GetConVar("astw2_quality"):GetInt()
    if GetConVar("astw2_force_effect_minlevel_1"):GetBool() and quality == 0 then
        quality = 1
    end

    if quality == 0 then return end

    self.WeaponEnt = data:GetEntity()
    if !IsValid(self.WeaponEnt) then return end
    self.Owner = self.WeaponEnt:GetOwner()
    if !IsValid(self.Owner) then return end
    local dir = data:GetNormal()
    local scale = self.WeaponEnt.Primary.Damage * self.WeaponEnt.Primary.Num
    scale = scale * 0.02

    self.vOffset = self.WeaponEnt:GetBorePos()

    AddVel = self.WeaponEnt.Owner:GetVelocity()

    local emitter = ParticleEmitter(self.vOffset)

    if !self.WeaponEnt.Suppressed then
        local particle = emitter:Add("effects/swrc/Radial_sparks", self.vOffset)

        if (particle) then
            particle:SetVelocity(AddVel)
            particle:SetLifeTime(0)
            particle:SetDieTime(math.Rand(0.07 ,0.1))
            particle:SetStartAlpha(255)
            particle:SetEndAlpha(155)
            particle:SetStartSize(math.Rand(5, 10))
            particle:SetEndSize(scale * math.Rand(40, 60))
            particle:SetLighting(false)
            particle:SetRoll(math.random(0, 0))
            particle:SetColor(255, 225, 155)
        end
    end

    local particlecount = quality * 2


    if quality >= 3 then
        local particle = emitter:Add("sprites/heatwave", self.vOffset)

        if (particle) then
            particle:SetVelocity((dir * 25) + 1.05 * AddVel)
            particle:SetLifeTime(0)
            particle:SetDieTime(0.1)
            particle:SetStartAlpha(255)
            particle:SetEndAlpha(0)
            particle:SetStartSize(math.Rand(80, 100))
            particle:SetEndSize(0)
            particle:SetRoll(math.Rand(0, 360))
            particle:SetRollDelta(math.Rand(-2, 2))
            particle:SetAirResistance(5)
            particle:SetGravity(Vector(0, 0, 40))
            particle:SetColor(255, 255, 255)
        end
    end

    emitter:Finish()
end

function EFFECT:Think()
    return false
end

function EFFECT:Render()
end
--PATH lua/effects/astw2_muzzleflash_swrc_green/init.lua:
return gluapack()()
--PATH lua/effects/atrt_flamethrower_explosion/init.lua:
return gluapack()()
--PATH lua/effects/atrt_flamethrower_explosion/init.lua:
local FlameMat = {}
FlameMat[1] = "effects/muzzleflash2"
FlameMat[2] = "effects/muzzleflash3"

function EFFECT:Init(data)
    sound.Play("ambient/fire/ignite.wav", self:GetPos(), 54, math.random(82, 112))

    local FlameEmitter = ParticleEmitter(data:GetOrigin())
    for i = 0, 10 do
        if not FlameEmitter then return end

        local FlameParticle = FlameEmitter:Add(FlameMat[math.random(1, #FlameMat)], data:GetOrigin())
        if FlameParticle then
            FlameParticle:SetVelocity(VectorRand() * 250)
            FlameParticle:SetLifeTime(0)
            FlameParticle:SetDieTime(0.5)
            FlameParticle:SetStartAlpha(210)
            FlameParticle:SetEndAlpha(0)
            FlameParticle:SetStartSize(0)
            FlameParticle:SetEndSize(64)
            FlameParticle:SetRoll(math.Rand(-210, 210))
            FlameParticle:SetRollDelta(math.Rand(-3.2, 3.2))
            FlameParticle:SetAirResistance(350)
            FlameParticle:SetGravity(Vector(0, 0, 64))
        end
    end

    FlameEmitter:Finish()
end

function EFFECT:Think()
    return false
end

function EFFECT:Render()
end
--PATH lua/effects/ca3_tracer_noattach.lua:
AddCSLuaFile()
AddCSLuaFile( "effects/fxbase.lua" )
include( "effects/fxbase.lua" )

EFFECT.Speed	= 6500 --16000
EFFECT.Length	= 64

function EFFECT:Init( data )

	self.StartPos = data:GetStart() --self:GetTracerOrigin( data )
	self.EndPos = data:GetOrigin()
	self.Parent = data:GetEntity()
	
	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos )

	local diff = ( self.EndPos - self.StartPos )
	
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	
	if ( !self.LifeTime ) then
		self.LifeTime = ( diff:Length() + self.Length ) / self.Speed
	else
		self.LifeTime = CurTime() + self.LifeTime
	end
	
end

function EFFECT:Think()
	
	util.ParticleTracerEx( 
		"ngen_tracer", 	--particle system
		self.StartPos, 	--startpos
		self.EndPos, 	--endpos
		true, 			--do whiz effect
		-1, 			--entity index
		-1  			--attachment
	)
	
	return false
	
end

--PATH lua/effects/fxbase.lua:
return gluapack()()
--PATH lua/effects/cod2019_tracer_2/init.lua:
PrecacheParticleSystem("mw2019_tracer_2")
EFFECT.TracerName = "mw2019_tracer_2"
EFFECT.Color = Color(255, 255, 255)

function EFFECT:Init(data)
    self.WeaponEnt = data:GetEntity()
    --print(self.ParticleName)
    if not IsValid(self.WeaponEnt) then return end
    self.Attachment = data:GetAttachment() or 1
    --self.Position = self:GetTracerShootPos(data:GetStart(), self.WeaponEnt, self.Attachment)
	self.Position = self:GetTracerShootPos(data:GetStart(), data:GetEntity(), self.Attachment)

    if IsValid(self.WeaponEnt.Owner) then
        if self.WeaponEnt.Owner == LocalPlayer() then
            if not self.WeaponEnt.Owner:GetViewEntity() then
                ang = self.WeaponEnt.Owner:EyeAngles()
                ang:Normalize()
                --ang.p = math.max(math.min(ang.p,55),-55)
                self.Forward = ang:Forward()
            else
                self.WeaponEnt = self.WeaponEnt.Owner:GetViewModel()
            end
            --ang.p = math.max(math.min(ang.p,55),-55)
        else
            ang = self.WeaponEnt.Owner:EyeAngles()
            ang:Normalize()
            self.Forward = ang:Forward()
        end
    end

    self.EndPos = data:GetOrigin()
    -- util.ParticleTracerEx(self.ParticleName, self.StartPos, self.EndPos, false, self:EntIndex(), self.Attachment)
    local pcf = CreateParticleSystem(self.WeaponEnt, self.TracerName, PATTACH_ABSORIGIN, self.Attachment)
    if IsValid(pcf) then
        pcf:SetControlPoint(0,self.Position)
        pcf:SetControlPoint(1,self.EndPos)
        -- if self.GetProcessedValue then
		-- local color = self.WeaponEnt:GetProcessedValue("TracerColor")
		-- pcf:SetControlPoint(2, Vector(color.r, color.g, color.b))
        -- end
        pcf:StartEmission()
    end
    timer.Simple(1.2, function()
        if IsValid(pcf) then
            pcf:StopEmissionAndDestroyImmediately()
        end
    end)
end

function EFFECT:Think()
    return false
end

function EFFECT:Render()
    if self.InValid then return false end
end
--PATH lua/effects/cryon_hull.lua:
return gluapack()()
--PATH lua/effects/cryon_hull.lua:
local mat_ice = Material( "models/elemental/frozen_alpha" )

local icegibs = {
	"models/props_wasteland/rockgranite03b.mdl",
	"models/props_wasteland/rockgranite03c.mdl",
	"models/props_wasteland/rockgranite03a.mdl",
	"models/props_wasteland/rockgranite02c.mdl",
	"models/props_wasteland/rockgranite02b.mdl",
	"models/props_wasteland/rockgranite02a.mdl",
}

EFFECT.Childs = {}

function EFFECT:Init( data )

	self.Time = data:GetScale() -- 2
	self.LifeTime = CurTime() + self.Time
	
	local ent = data:GetEntity()
	
	if ( !IsValid( ent ) ) then return end
	if ( !ent:GetModel() ) then return end
	
	self.Childs = {}
	
	self.ParentEntity = ent
	self:SetModel( ent:GetModel() )	
	self:SetPos( ent:GetPos() )
	self:SetAngles( ent:GetAngles() )
	self:SetParent( ent )
	
end

function EFFECT:OnRemove()
	
	for k,v in pairs( self.Childs ) do
		if ( v ) then
			v:Remove()
		end
	end

end

function EFFECT:Think( )

	if ( !IsValid( self.ParentEntity ) ) then 
		self:OnRemove()

		return false 
	end
	
	local bFrozen = self.ParentEntity:GetNWBool( "bliz_frozen" )

	if ( !self.HasBeenFrozen ) then
		self.HasBeenFrozen = bFrozen
	end

	if ( !bFrozen && self.HasBeenFrozen ) then
		self:OnRemove()
		
		return false
	end

	if ( self.LifeTime > CurTime() ) then
		return true
	end
	
	self:OnRemove()

	return false
	
end

local fFraction, iBoneCount, iBoneMax, sMin, sMax
local vShatter = Vector( 0, 0, 0 )

function EFFECT:Render()
	
	local parent = self:GetParent()

	if ( !IsValid( parent ) ) then
		self:OnRemove()
		return
	end

	fFraction = ( self.LifeTime - CurTime() ) / self.Time
	fFraction = math.Clamp( fFraction, 0, 0.4 )

	iBoneCount = parent:GetBoneCount()
	sMin, sMax = parent:GetModelBounds()
	iBoneMax = math.min( GetConVar( "sfw_fx_maxexpensive" ):GetInt() * 4, iBoneCount )
	
	for bone = 0 + iBoneMax / 4, iBoneMax do
		if ( !parent:GetBoneName( bone ) ) then continue end
		
		local bOrigin, bRotation = parent:GetBonePosition( bone )
		
		if ( !isvector( bOrigin ) ) then continue end
		
		local rng = math.random( 0.04, 0.08 )
		
		local gibScale = Vector( rng, rng, rng )
		local gibScaleFactor = ( sMin - sMax ):Length() * ( bone / 24 ) / ( iBoneMax / 16 )
		local gibScaleFinal = math.max( gibScaleFactor * 0.005, 0.1 ) * ( 0.8 + fFraction )
		
		if ( !self.Childs[ bone ] ) then
			self.Childs[ bone ] = ClientsideModel(  icegibs[ math.random( 1, #icegibs ) ] , RENDERGROUP_BOTH )
		end
		
		local gib = self.Childs[ bone ]
		if ( IsValid( gib ) ) then
			local vShatter = vShatter || Vector( 0, 0, 0 )
			if ( fFraction < 0.3 ) then
				vShatter = VectorRand() * ( 0.3 - fFraction )
			end
			
			gib:SetPos( bOrigin + vShatter )
			gib:SetAngles( bRotation )
			gib:SetMaterial( "models/elemental/frozen_alpha" )
			gib:SetModelScale( gibScaleFinal )
			gib:SetCollisionBounds( gibScale * -1, gibScale )
			gib:DrawModel()
		end

--		debugoverlay.Line( bOrigin, parent:GetPos(), 0.1, Color( 255, 0, 255, 255 ), true )
	end
	
end
--PATH lua/effects/csgo_muzzle_assaultrifle_comp/init.lua:
local ang

EFFECT.WeaponEnt = nil

local lighconvar = GetConVar("arc9_muzzle_light")
local otherconvar = GetConVar("arc9_muzzle_others")

EFFECT.ParticleName = "weapon_muzzle_flash_assaultrifle_comp"

function EFFECT:Init(data)
	self.WeaponEnt = data:GetEntity()
	if not IsValid(self.WeaponEnt) then return end
	
    if !otherconvar:GetBool() and LocalPlayer() != self.WeaponEnt:GetOwner() then
        self:Remove()
        return
    end	

	self.Attachment = data:GetAttachment()
	self.Position = self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)

	if IsValid(self.WeaponEnt.Owner) then
		if self.WeaponEnt.Owner == LocalPlayer() then
			if not self.WeaponEnt:IsFirstPerson() then
				ang = self.WeaponEnt.Owner:EyeAngles()
				ang:Normalize()
				--ang.p = math.max(math.min(ang.p,55),-55)
				self.Forward = ang:Forward()
			else
				self.WeaponEnt = self.WeaponEnt.Owner:GetViewModel()
			end
			--ang.p = math.max(math.min(ang.p,55),-55)
		else
			ang = self.WeaponEnt.Owner:EyeAngles()
			ang:Normalize()
			self.Forward = ang:Forward()
		end
	end

	self.Forward = self.Forward or data:GetNormal()
	self.Angle = self.Forward:Angle()
	
	if !self.WeaponEnt:GetProcessedValue("Silencer") and !self.WeaponEnt:GetProcessedValue("NoFlash", true) and lighconvar:GetBool() then
		local dlight = DynamicLight(self.WeaponEnt:EntIndex())
		if (dlight) then
			dlight.pos = self.Position + self.Angle:Up() * 3 + self.Angle:Right() * -2
			dlight.r = 255
			dlight.g = 192
			dlight.b = 64
			dlight.brightness = 5
			dlight.Size = math.Rand(32, 64)
			dlight.Decay = math.Rand(32, 64) / 0.05
			dlight.DieTime = CurTime() + 0.05
		end
	end

	local pcf = CreateParticleSystem(self.WeaponEnt, self.ParticleName, PATTACH_POINT_FOLLOW, self.Attachment)
	if IsValid(pcf) then
		pcf:StartEmission()
	end
	timer.Simple(3.0, function()
		if IsValid(pcf) then
			pcf:StopEmissionAndDestroyImmediately()
		end
	end)
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end
--PATH lua/effects/csgo_muzzle_huntingrifle/init.lua:
local ang

EFFECT.WeaponEnt = nil

local lighconvar = GetConVar("arc9_muzzle_light")
local otherconvar = GetConVar("arc9_muzzle_others")

EFFECT.ParticleName = "weapon_muzzle_flash_huntingrifle"

function EFFECT:Init(data)
	self.WeaponEnt = data:GetEntity()
	if not IsValid(self.WeaponEnt) then return end

    if !otherconvar:GetBool() and LocalPlayer() != self.WeaponEnt:GetOwner() then
        self:Remove()
        return
    end	

	self.Attachment = data:GetAttachment()
	self.Position = self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)

	if IsValid(self.WeaponEnt.Owner) then
		if self.WeaponEnt.Owner == LocalPlayer() then
			if not self.WeaponEnt:IsFirstPerson() then
				ang = self.WeaponEnt.Owner:EyeAngles()
				ang:Normalize()
				--ang.p = math.max(math.min(ang.p,55),-55)
				self.Forward = ang:Forward()
			else
				self.WeaponEnt = self.WeaponEnt.Owner:GetViewModel()
			end
			--ang.p = math.max(math.min(ang.p,55),-55)
		else
			ang = self.WeaponEnt.Owner:EyeAngles()
			ang:Normalize()
			self.Forward = ang:Forward()
		end
	end

	self.Forward = self.Forward or data:GetNormal()
	self.Angle = self.Forward:Angle()
	
	if !self.WeaponEnt:GetProcessedValue("Silencer") and !self.WeaponEnt:GetProcessedValue("NoFlash", true) and lighconvar:GetBool() then
		local dlight = DynamicLight(self.WeaponEnt:EntIndex())
		if (dlight) then
			dlight.pos = self.Position + self.Angle:Up() * 3 + self.Angle:Right() * -2
			dlight.r = 255
			dlight.g = 192
			dlight.b = 64
			dlight.brightness = 5
			dlight.Size = math.Rand(32, 64)
			dlight.Decay = math.Rand(32, 64) / 0.05
			dlight.DieTime = CurTime() + 0.05
		end
	end

	local pcf = CreateParticleSystem(self.WeaponEnt, self.ParticleName, PATTACH_POINT_FOLLOW, self.Attachment)
	if IsValid(pcf) then
		pcf:StartEmission()
	end
	timer.Simple(3.0, function()
		if IsValid(pcf) then
			pcf:StopEmissionAndDestroyImmediately()
		end
	end)
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end
--PATH lua/effects/csgo_muzzle_smg/init.lua:
local ang

EFFECT.WeaponEnt = nil

local lighconvar = GetConVar("arc9_muzzle_light")
local otherconvar = GetConVar("arc9_muzzle_others")

EFFECT.ParticleName = "weapon_muzzle_flash_smg"

function EFFECT:Init(data)
	self.WeaponEnt = data:GetEntity()
	if not IsValid(self.WeaponEnt) then return end
	
    if !otherconvar:GetBool() and LocalPlayer() != self.WeaponEnt:GetOwner() then
        self:Remove()
        return
    end	

	self.Attachment = data:GetAttachment()
	self.Position = self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)

	if IsValid(self.WeaponEnt.Owner) then
		if self.WeaponEnt.Owner == LocalPlayer() then
			if not self.WeaponEnt:IsFirstPerson() then
				ang = self.WeaponEnt.Owner:EyeAngles()
				ang:Normalize()
				--ang.p = math.max(math.min(ang.p,55),-55)
				self.Forward = ang:Forward()
			else
				self.WeaponEnt = self.WeaponEnt.Owner:GetViewModel()
			end
			--ang.p = math.max(math.min(ang.p,55),-55)
		else
			ang = self.WeaponEnt.Owner:EyeAngles()
			ang:Normalize()
			self.Forward = ang:Forward()
		end
	end

	self.Forward = self.Forward or data:GetNormal()
	self.Angle = self.Forward:Angle()
	
	if !self.WeaponEnt:GetProcessedValue("Silencer") and !self.WeaponEnt:GetProcessedValue("NoFlash", true) and lighconvar:GetBool() then
		local dlight = DynamicLight(self.WeaponEnt:EntIndex())
		if (dlight) then
			dlight.pos = self.Position + self.Angle:Up() * 3 + self.Angle:Right() * -2
			dlight.r = 255
			dlight.g = 192
			dlight.b = 64
			dlight.brightness = 5
			dlight.Size = math.Rand(32, 64)
			dlight.Decay = math.Rand(32, 64) / 0.05
			dlight.DieTime = CurTime() + 0.05
		end
	end

	local pcf = CreateParticleSystem(self.WeaponEnt, self.ParticleName, PATTACH_POINT_FOLLOW, self.Attachment)
	if IsValid(pcf) then
		pcf:StartEmission()
	end
	timer.Simple(3.0, function()
		if IsValid(pcf) then
			pcf:StopEmissionAndDestroyImmediately()
		end
	end)
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end
--PATH lua/effects/csgo_nade_flashbang_light/init.lua:
return gluapack()()
--PATH lua/effects/effect_astw2_swrc_impact_trandoshan/init.lua:
return gluapack()()
--PATH lua/effects/effect_sw_laser_green_sniper/init.lua:
TRACER_FLAG_USEATTACHMENT	= 0x0002
SOUND_FROM_WORLD			= 0
CHAN_STATIC					= 6

EFFECT.Speed				= 8000
EFFECT.Length				= 600
--EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 250

local MaterialMain			= Material( "effects/sw_laser_green_main" )
local MaterialFront			= Material( "effects/sw_laser_green_front" )

function EFFECT:GetTracerOrigin(data)
	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart()

	-- use attachment?
	if (bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT) then
		local entity = data:GetEntity()
		if (not IsValid(entity)) then return start end
		if (not game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT)) then return start end

		if (entity:IsWeapon() and entity:IsCarriedByLocalPlayer()) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			-- use the view model
			local pl = entity:GetOwner()

			if (IsValid(pl)) then
				local vm = pl:GetViewModel()

				if (IsValid(vm) and not LocalPlayer():ShouldDrawLocalPlayer()) then
					entity = vm
					-- HACK: fix the model in multiplayer
				else
					if (entity.WorldModel) then
						entity:SetModel(entity.WorldModel)
					end
				end
			end
		end

		local attachment = entity:GetAttachment(data:GetAttachment())

		if (attachment) then
			start = attachment.Pos
		end
	end

	return start
end

function EFFECT:Init(data)
	self.StartPos = self:GetTracerOrigin(data)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	local diff = self.EndPos - self.StartPos
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = (diff:Length() + self.Length) / self.Speed
	-- whiz by sound
	local weapon = data:GetEntity()

	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()

	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 8, 8, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 10, 0, 1, color_white)
end
--PATH lua/effects/effect_sw_laser_purple_akimbo_pu/init.lua:
return gluapack()()
--PATH lua/effects/effect_sw_laser_white/init.lua:
return gluapack()()
--PATH lua/effects/effect_sw_laser_yellow_akimbo_pu/init.lua:
return gluapack()()
--PATH lua/effects/effect_zeus_muzzleflash/init.lua:
AddCSLuaFile()

EFFECT.Author = "BFG"
EFFECT.Life = 0
function EFFECT:Init(fxdata)
	self.attachment = fxdata:GetAttachment()
	self.Ent = fxdata:GetEntity()
	self.Position = fxdata:GetStart()
	self.StartPos = self:GetTracerShootPos( self.Position, self.Ent, self.attachment )
	//util.Effect(self.StartPos, self.size or 60, self.size or 60, Color(200,200,255))
	//self.Life = 0
end

function EFFECT:Render()
	render.SetMaterial(Material("sprites/glow04_noz"))
	render.DrawSprite( self.StartPos, self.size or 60, self.size or 60, Color(180,180,255))
end

function EFFECT:Think()
	self.Life = self.Life + FrameTime() * 4
	self.size = 60 * ( 1 - self.Life )	
	return (self.Life < 1)	
end
--PATH lua/effects/emg_tracer.lua:
AddCSLuaFile()
AddCSLuaFile( "effects/fxbase.lua" )
include( "effects/fxbase.lua" )

EFFECT.ParticleCast = false
EFFECT.Time = nil

EFFECT.Speed = 32000
function EFFECT:Think()

	if ( !self.ParticleCast ) then
		util.ParticleTracerEx( 
			"emg_tracer", 	--particle system
			self.StartPos, 	--startpos
			self.EndPos, 	--endpos
			false, 			--do whiz effect
			-1, 			--entity index
			-1  			--attachment
		)
		
		self.ParticleCast = true
	end
	
	if ( !self.Time ) then	
		self.Time = self.LifeTime + CurTime()
	end
	
	local Fraction = math.max( 0, ( self.Time - CurTime() ) / self.LifeTime )
	
	local difforigin = self.EndPos - self.StartPos
	local lightorigin = self.StartPos + ( difforigin * ( 1 - Fraction ) ) 

	local mLight = DynamicLight( -1 )
	if ( mLight ) then
		mLight.pos = lightorigin
		mLight.r = 255
		mLight.g = 0
		mLight.b = 10
		mLight.brightness = 0.4 + 0.2 * Fraction
		mLight.Size = 128 + 64 * Fraction
		mLight.Decay = 1024 + 1024 * Fraction
		mLight.Style = 1
		mLight.DieTime = CurTime() + 1
	end
	
	return ( self.Time > CurTime() ) 
	
end

--PATH lua/effects/fxbase.lua:
return gluapack()()
--PATH lua/effects/fxbase.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/effects/force_blast_effect.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/effects/force_block_active.lua:
--DO NOT EDIT OR REUPLOAD THIS FILE

function EFFECT:Init( data )
	self.Ent = data:GetEntity()
	self.Pos = data:GetOrigin()
	
	self.mat = Material( "effects/select_ring" )
	
	self.LifeTime = 0.2
	self.DieTime = CurTime() + self.LifeTime

	if not IsValid( self.Ent ) then return end

	self.Model = ClientsideModel( self.Ent:GetModel(), RENDERGROUP_TRANSLUCENT )
	self.Model:SetMaterial("models/alyx/emptool_glow")
	self.Model:SetColor( Color(0,70,150,255) )
	self.Model:SetParent( self.Ent, 0 )
	self.Model:SetMoveType( MOVETYPE_NONE )
	self.Model:SetLocalPos( Vector( 0, 0, 0 ) )
	self.Model:SetLocalAngles( Angle( 0, 0, 0 ) )
	self.Model:AddEffects( EF_BONEMERGE )

	for i = 0,self.Ent:GetBoneCount() do
		self.Model:ManipulateBoneScale( i, Vector(1,1,1) * (1 + math.abs( math.cos( CurTime() * 5 ) ) * 0.2 ) )
	end

	for i = 0, self.Ent:GetNumBodyGroups() do
		self.Model:SetBodygroup(i, self.Ent:GetBodygroup(i))
	end
end

function EFFECT:Think()
	if self.DieTime < CurTime() or not IsValid( self.Ent ) or not self.Ent:Alive() then 
		if IsValid( self.Model ) then
			self.Model:Remove()
		end

		return false
	end
	
	return true
end

function EFFECT:Render()
	if IsValid( self.Ent ) then
		local Pos = self.Ent:GetPos() + Vector(0,0,40)

		local Scale = (self.DieTime - CurTime()) / self.LifeTime

		if IsValid( self.Model ) then
			local A = math.abs( math.cos( CurTime() * 5 ) )
			local InvA = 1 - A

			local r = 0
			local g = 127 * A + 50 * InvA
			local b = 255 * A + 255 * InvA
			local a = 255 * A + 255 * InvA

			self.Model:SetColor( Color(r,g,b,a) )
		end
	end
end

--PATH addons/[miecze] moce i hilty/lua/effects/force_cleave_sparkle.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/effects/force_judgementiii.lua:

function EFFECT:Init( data )
	self.Ent = data:GetEntity()

	self.LifeTime = 0.2
	self.DieTime = CurTime() + self.LifeTime

	if IsValid( self.Ent ) then
		local Dir = self.Ent:GetAimVector()
		local StartPos = self.Ent:GetShootPos() - Dir * 25
		local EndPos = StartPos + Dir * 625
		self:SetRenderBoundsWS( StartPos, EndPos )
	end
end

function EFFECT:Think()
	if self.DieTime < CurTime() or not IsValid( self.Ent ) then 
		return false
	end

	return true
end

local BeamMat = Material( "trails/electric" )
local mat = Material( "sprites/light_glow02_add" )

function EFFECT:Render()
	if IsValid( self.Ent ) then

		local boneID = self.Ent:LookupBone( "ValveBiped.Bip01_L_Hand" )

		if boneID then
			local T = CurTime() * 10

			local X = math.cos( T ) * math.cos( T * 10 ) * 4
			local Y = math.sin( T ) * math.cos( T * 10 ) * 4
			local pos, ang = self.Ent:GetBonePosition( boneID )
			local StartPos = pos + ang:Up() * 2 + ang:Forward() * 5 + ang:Right() * 2

			if not self.TargetPos then
				self.TargetPos = self.Ent:GetEyeTrace().HitPos
	
				local dlight = DynamicLight( self.Ent:EntIndex() + math.random(0,99) )
				if dlight then
					dlight.pos = StartPos
					dlight.r = 255 --EDT
					dlight.g = 255 --EDT
					dlight.b = 255 --EDT
					dlight.brightness = 3
					dlight.Decay = 2000
					dlight.Size = 150
					dlight.DieTime = CurTime() + 0.1
				end
			end


			local Dir = ((self.TargetPos - StartPos):Angle() + Angle(X,Y,0)):Forward()
			local EndPos = StartPos + Dir * math.random(200,600)

			local trace = util.TraceLine( { start = StartPos, endpos = EndPos, filter = self.Ent} )

			if (self.HitFX or 0) < CurTime() then
				self.HitFX = CurTime() + 0.01

				if trace.Hit then
					local effectdata = EffectData()
						effectdata:SetOrigin( trace.HitPos + trace.HitNormal )
						effectdata:SetNormal( -trace.HitNormal )
					util.Effect( "force_judgementiii_hit", effectdata )

					if math.random(1,3) == 3 then

						local dlight = DynamicLight( self.Ent:EntIndex() + math.random(100,9999) )
						if dlight then
							dlight.pos = trace.HitPos + trace.HitNormal
							dlight.r = 255 --EDT
							dlight.g = 255 --EDT
							dlight.b = 255 --EDT
							dlight.brightness = 3
							dlight.Decay = 2000
							dlight.Size = 100
							dlight.DieTime = CurTime() + 0.01
						end

						self:EmitSound("lscs/force/lightninghit"..math.random(1,3)..".mp3")
					end
				end
			end

			render.SetMaterial( mat )
			render.DrawSprite( StartPos, 64, 64, Color( 255, 255, 255) ) --Elden Cikan Yes
			render.DrawSprite( StartPos, 16, 16, Color( 255, 255, 255, 255) ) --Bilmiyorum

			local BeamStart = StartPos
			local BeamPrevious = BeamStart
			local BeamEnd = trace.HitPos
			local BeamSub = BeamEnd - BeamStart
			local BeamDir = BeamSub:GetNormalized()
			local BeamDistance = (BeamSub):Length()
			local SegmentLength = 50

			render.SetMaterial( BeamMat )

			render.DrawBeam( BeamStart, BeamEnd, 18, 0, 1, Color( 255, 255, 255) ) --Az Elektrik

			for SegmentStart = 0, BeamDistance, SegmentLength do
				local SegmentEnd = BeamPrevious + (BeamDir:Angle() + Angle(math.Rand(-8,8),math.Rand(-8,8),0)):Forward() * SegmentLength

				local Width = (SegmentStart / BeamDistance)
				if SegmentStart + SegmentLength >= BeamDistance then
					SegmentEnd = BeamEnd
				end

				render.DrawBeam( BeamPrevious, SegmentEnd, 16 * (1 - Width), Width, Width + 0.15, Color( 255, 255 + 150 * Width, 255, 255 ) ) --Etraftaki Cok Fazla Elektrik

				local BranchEnd1 = SegmentEnd + (BeamDir:Angle() + Angle(math.Rand(-20,20),math.Rand(-20,20),0)):Forward() * SegmentLength * 0.5

				render.DrawBeam( SegmentEnd, BranchEnd1, math.Rand(8,16) * (1 - Width), 0, 0.2, Color( 255, 255, 255, 255 ) ) --Aradakilerin yarisi 
				render.DrawBeam( BranchEnd1, BranchEnd1 + (BeamDir:Angle() + Angle(math.Rand(-6,6),math.Rand(-6,6),0)):Forward() * SegmentLength * 1.5, math.Rand(4,8) * (1 - Width), 0, 1.5, Color( 255, 255, 255) ) --Kalanlar

				BeamPrevious = SegmentEnd
			end
		end
	end
end

--PATH addons/[miecze] moce i hilty/lua/effects/force_lightning_hit.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/effects/force_lightningi.lua:

function EFFECT:Init( data )
	self.Ent = data:GetEntity()

	self.LifeTime = 0.2
	self.DieTime = CurTime() + self.LifeTime

	if IsValid( self.Ent ) then
		local Dir = self.Ent:GetAimVector()
		local StartPos = self.Ent:GetShootPos() - Dir * 25
		local EndPos = StartPos + Dir * 625
		self:SetRenderBoundsWS( StartPos, EndPos )
	end
end

function EFFECT:Think()
	if self.DieTime < CurTime() or not IsValid( self.Ent ) then 
		return false
	end

	return true
end

local BeamMat = Material( "trails/electric" )
local mat = Material( "sprites/light_glow02_add" )

function EFFECT:Render()
	if IsValid( self.Ent ) then

		local boneID = self.Ent:LookupBone( "ValveBiped.Bip01_L_Hand" )

		if boneID then
			local T = CurTime() * 10

			local X = math.cos( T ) * math.cos( T * 10 ) * 4
			local Y = math.sin( T ) * math.cos( T * 10 ) * 4
			local pos, ang = self.Ent:GetBonePosition( boneID )
			local StartPos = pos + ang:Up() * 2 + ang:Forward() * 5 + ang:Right() * 2

			if not self.TargetPos then
				self.TargetPos = self.Ent:GetEyeTrace().HitPos
	
				local dlight = DynamicLight( self.Ent:EntIndex() + math.random(0,99) )
				if dlight then
					dlight.pos = StartPos
					dlight.r = 255 --EDT
					dlight.g = 255 --EDT
					dlight.b = 255 --EDT
					dlight.brightness = 3
					dlight.Decay = 2000
					dlight.Size = 150
					dlight.DieTime = CurTime() + 0.1
				end
			end


			local Dir = ((self.TargetPos - StartPos):Angle() + Angle(X,Y,0)):Forward()
			local EndPos = StartPos + Dir * math.random(200,600)

			local trace = util.TraceLine( { start = StartPos, endpos = EndPos, filter = self.Ent} )

			if (self.HitFX or 0) < CurTime() then
				self.HitFX = CurTime() + 0.01

				if trace.Hit then
					local effectdata = EffectData()
						effectdata:SetOrigin( trace.HitPos + trace.HitNormal )
						effectdata:SetNormal( -trace.HitNormal )
					util.Effect( "force_lightningi_hit", effectdata )

					if math.random(1,3) == 3 then

						local dlight = DynamicLight( self.Ent:EntIndex() + math.random(100,9999) )
						if dlight then
							dlight.pos = trace.HitPos + trace.HitNormal
							dlight.r = 255 --EDT
							dlight.g = 255 --EDT
							dlight.b = 255 --EDT
							dlight.brightness = 3
							dlight.Decay = 2000
							dlight.Size = 100
							dlight.DieTime = CurTime() + 0.01
						end

						self:EmitSound("lscs/force/lightninghit"..math.random(1,3)..".mp3")
					end
				end
			end

			render.SetMaterial( mat )
			render.DrawSprite( StartPos, 64, 64, Color( 255, 255, 255) ) --Elden Cikan Yes
			render.DrawSprite( StartPos, 16, 16, Color( 255, 255, 255, 255) ) --Bilmiyorum

			local BeamStart = StartPos
			local BeamPrevious = BeamStart
			local BeamEnd = trace.HitPos
			local BeamSub = BeamEnd - BeamStart
			local BeamDir = BeamSub:GetNormalized()
			local BeamDistance = (BeamSub):Length()
			local SegmentLength = 50

			render.SetMaterial( BeamMat )

			render.DrawBeam( BeamStart, BeamEnd, 18, 0, 1, Color( 255, 255, 255) ) --Az Elektrik

			for SegmentStart = 0, BeamDistance, SegmentLength do
				local SegmentEnd = BeamPrevious + (BeamDir:Angle() + Angle(math.Rand(-8,8),math.Rand(-8,8),0)):Forward() * SegmentLength

				local Width = (SegmentStart / BeamDistance)
				if SegmentStart + SegmentLength >= BeamDistance then
					SegmentEnd = BeamEnd
				end

				render.DrawBeam( BeamPrevious, SegmentEnd, 16 * (1 - Width), Width, Width + 0.15, Color( 255, 255 + 150 * Width, 255, 255 ) ) --Etraftaki Cok Fazla Elektrik

				local BranchEnd1 = SegmentEnd + (BeamDir:Angle() + Angle(math.Rand(-20,20),math.Rand(-20,20),0)):Forward() * SegmentLength * 0.5

				render.DrawBeam( SegmentEnd, BranchEnd1, math.Rand(8,16) * (1 - Width), 0, 0.2, Color( 255, 255, 255, 255 ) ) --Aradakilerin yarisi 
				render.DrawBeam( BranchEnd1, BranchEnd1 + (BeamDir:Angle() + Angle(math.Rand(-6,6),math.Rand(-6,6),0)):Forward() * SegmentLength * 1.5, math.Rand(4,8) * (1 - Width), 0, 1.5, Color( 255, 255, 255) ) --Kalanlar

				BeamPrevious = SegmentEnd
			end
		end
	end
end

--PATH addons/[miecze] moce i hilty/lua/effects/force_lightningii.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/effects/force_lightningx_hit.lua:
--DO NOT EDIT OR REUPLOAD THIS FILE

local DecalMat = Material( util.DecalMaterial( "FadingScorch" ) )
function EFFECT:Init( data )
	self.Pos = data:GetOrigin()

	self.mat = Material( "sprites/light_glow02_add" )
	
	self.LifeTime = 0.5
	self.DieTime = CurTime() + self.LifeTime
	self.DieTimeGlow = CurTime() + 0.2

	local Col = self.Col
	local Pos = self.Pos
	local Dir = data:GetNormal()
	
	local emitter = ParticleEmitter( Pos, false )

	local trace = util.TraceLine( {
		start = Pos - Dir * 5,
		endpos = Pos + Dir * 5,
	} )

	if trace.Hit and not trace.HitNonWorld then
		util.DecalEx( DecalMat, trace.Entity, trace.HitPos + trace.HitNormal, trace.HitNormal, Color(255,255,255,255), math.Rand(0.4,0.8), math.Rand(0.4,0.8) )
	end

	for i = 0, 3 do
		local particle = emitter:Add( "sprites/rico1", Pos )
		
		local vel = VectorRand() * 100 + Dir * math.Rand(120,140)
		
		if particle then
			particle:SetVelocity( vel )
			particle:SetAngles( vel:Angle() + Angle(0,90,0) )
			particle:SetDieTime( math.Rand(1,2) )
			particle:SetStartAlpha( math.Rand( 200, 255 ) )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( 1 )
			particle:SetEndSize( 0.5 )
			particle:SetRoll( math.Rand(-100,100) )
			particle:SetRollDelta( math.Rand(-100,100) )
			particle:SetCollide( true )
			particle:SetBounce( 0.5 )
			particle:SetAirResistance( 0 )
			particle:SetColor( 255, 255, 255 )
			particle:SetGravity( Vector(0,0,-600) )
		end
	end

	self.Emitter = emitter
end

function EFFECT:Think()
	if self.DieTime < CurTime() then 
		if self.Emitter then
			self.Emitter:Finish()
		end

		if self.snd then
			self.snd:Stop()
		end

		return false
	end

	return true
end

local Mat = Material("particle/particle_glow_05_addnofog")
function EFFECT:Render()
	local Scale = (self.DieTimeGlow - CurTime()) / 0.2
	if Scale > 0 then
		render.SetMaterial( self.mat )
		render.DrawSprite( self.Pos, 24 * Scale, 24 * Scale, Color( 255, 0, 0, 255) ) -- DETRLECEK RENK
	end
end

--PATH addons/[miecze] moce i hilty/lua/effects/force_pull.lua:
--DO NOT EDIT OR REUPLOAD THIS FILE


EFFECT.mat = Material( "particle/warp1_warp" )
EFFECT.mat2 = Material( "effects/select_ring" )
EFFECT.mat3 = Material( "particle/smokesprites_0001" )

function EFFECT:Init( data )
	self.Ent = data:GetEntity()

	self.LifeTime = 0.4
	self.DieTime = CurTime() + self.LifeTime

	if not IsValid( self.Ent ) then self.Ready = true return end

	self.Pos = self.Ent:GetShootPos()
	self.Dir = data:GetNormal()
	self.mat3 = Material( "particle/smokesprites_000"..math.random(1,9) )

	self.Ready = true
end

function EFFECT:Think()
	if not self.Ready then return true end

	if self.DieTime < CurTime() or not IsValid( self.Ent ) then 
		return false
	end

	return true
end

function EFFECT:Render()
	if not self.Ready or not IsValid( self.Ent ) then return end

	local Scale = (self.DieTime - CurTime()) / self.LifeTime
	local InvScale =  (1 - Scale)

	render.SetMaterial( self.mat3 )
	render.DrawSprite( self.Pos + self.Dir * 200 * Scale, 100 * InvScale, 100 * InvScale, Color( 150,200,255,50 ) )

	for i = 1, 3 do
		local Scale = (self.DieTime - CurTime()) / self.LifeTime / 3 * i

		local Pos = self.Pos + self.Dir * 200 * Scale
		render.SetMaterial( self.mat )
		render.DrawSprite( Pos, 150 *  Scale, 150 *  Scale, Color( 255,255,255,255 ) )
	end
end

--PATH lua/effects/gravrifle_tracer.lua:
AddCSLuaFile()
AddCSLuaFile( "effects/fxbase.lua" )
include( "effects/fxbase.lua" )

EFFECT.ParticleCast = false
EFFECT.Time = nil

EFFECT.Speed = 24000
function EFFECT:Think()

	if ( !self.ParticleCast ) then
		util.ParticleTracerEx( 
			"gravrifle_tracer", 	--particle system
			self.StartPos, 	--startpos
			self.EndPos, 	--endpos
			false, 			--do whiz effect
			-1, 			--entity index
			-1  			--attachment
		)
		
		self.ParticleCast = true
	end
	
	if ( !self.Time ) then	
		self.Time = self.LifeTime + CurTime()
	end
	
	local Fraction = math.max( 0, ( self.Time - CurTime() ) / self.LifeTime )
	
	local difforigin = self.EndPos - self.StartPos
	local lightorigin = self.StartPos + ( difforigin * ( 1 - Fraction ) ) 

	local mLight = DynamicLight( -1 )
	if ( mLight ) then
		mLight.pos = lightorigin
		mLight.r = 130
		mLight.g = 120
		mLight.b = 255
		mLight.brightness = 3 * Fraction
		mLight.Size = 180 + 200 * Fraction
		mLight.Decay = 1024
		mLight.Style = 1
		mLight.DieTime = CurTime() + 1
	end
	
	return ( self.Time > CurTime() ) 
	
end

--PATH lua/effects/lvs_bullet_impact_ap.lua:
return gluapack()()
--PATH lua/effects/lvs_bullet_impact_ap.lua:

EFFECT.DustMat = {
	"effects/lvs_base/particle_debris_01",
	"effects/lvs_base/particle_debris_02",
}

EFFECT.SmokeMat = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

EFFECT.SparkSurface = {
	["chainlink"] = true,
	["canister"] = true,
	["metal_barrel"] = true,
	["metalvehicle"] = true,
	["metal"] = true,
	["metalgrate"] = true,
	["rubbertire"] = true,
}

EFFECT.DustSurface = {
	["sand"] = true,
	["dirt"] = true,
	["grass"] = true,
	["antlionsand"] = true,
}

EFFECT.SmokeSurface = {
	["concrete"] = true,
	["tile"] = true,
	["plaster"] = true,
	["boulder"] = true,
	["plastic"] = true,
	["default"] = true,
	["glass"] = true,
	["brick"] = true,
}

function EFFECT:Init( data )
	local pos = data:GetOrigin()

	local bullet_dir = data:GetStart()
	local dir = data:GetNormal()
	local magnitude = data:GetMagnitude()

	local ent = data:GetEntity()
	local surface = data:GetSurfaceProp()
	local surfaceName = util.GetSurfacePropName( surface )

	local emitter = ParticleEmitter( pos, false )

	local VecCol = (render.GetLightColor( pos ) * 0.8 + Vector(0.17,0.15,0.1)) * 255

	local DieTime = math.Rand(0.8,1.4)

	for i = 1, 60 * magnitude do
		local spark = emitter:Add("effects/spark", pos + dir * 8)

		if not spark then continue end

		spark:SetStartAlpha( 255 )
		spark:SetEndAlpha( 0 )
		spark:SetCollide( true )
		spark:SetBounce( math.Rand(0,1) )
		spark:SetColor( 255, 255, 255 )
		spark:SetGravity( Vector(0,0,-600) )
		spark:SetEndLength(0)

		local size = math.Rand(4, 6) * magnitude
		spark:SetEndSize( size )
		spark:SetStartSize( size )

		spark:SetStartLength( math.Rand(20,40) * magnitude )
		spark:SetDieTime( math.Rand(0.4, 1.2) )
		spark:SetVelocity( (dir * math.Rand(300, 600) + VectorRand() * 300) * magnitude )
	end

	local flash = emitter:Add( "effects/yellowflare",pos )

	if flash then
		flash:SetPos( pos + dir * 15 )
		flash:SetStartAlpha( 200 )
		flash:SetEndAlpha( 0 )
		flash:SetColor( 255,255,255 )
		flash:SetEndSize( 0 )
		flash:SetDieTime( 0.075 )
		flash:SetStartSize( 300 * magnitude ^ 2 )
	end

	if self.SparkSurface[ surfaceName ] then
		if IsValid( ent ) and ent.LVS then
			if (90 - math.deg( math.acos( math.Clamp( -dir:Dot( bullet_dir ) ,-1,1) ) )) > 10 then
				local effectdata = EffectData()
				effectdata:SetOrigin( pos )
				util.Effect( "cball_explode", effectdata, true, true )

				local Ax = math.acos( math.Clamp( dir:Dot( bullet_dir ) ,-1,1) )
				local Fx = math.cos( Ax )

				local effectdata = EffectData()
					effectdata:SetOrigin( pos )
					effectdata:SetNormal( (bullet_dir - dir * Fx * 2):GetNormalized() * 0.75 )
				util.Effect( "manhacksparks", effectdata, true, true )

				local effectdata = EffectData()
					effectdata:SetOrigin( pos )
					effectdata:SetNormal( -bullet_dir * 0.75 )
				util.Effect( "manhacksparks", effectdata, true, true )
			end
		else
			local effectdata = EffectData()
			effectdata:SetOrigin( pos )
			util.Effect( "cball_explode", effectdata, true, true )

			local effectdata = EffectData()
				effectdata:SetOrigin( pos )
				effectdata:SetNormal( dir )
			util.Effect( "manhacksparks", effectdata, true, true )

			local effectdata = EffectData()
				effectdata:SetOrigin( pos )
				effectdata:SetNormal( -bullet_dir )
			util.Effect( "manhacksparks", effectdata, true, true )
		end
	end

	if self.SmokeSurface[ surfaceName ] then
		for i = 1, 24 do
			local particle = emitter:Add( self.SmokeMat[ math.random(1, #self.SmokeMat ) ], pos )

			if not particle then continue end

			particle:SetStartAlpha( math.Rand(33, 66) )
			particle:SetEndAlpha( 0 )
			particle:SetColor( math.min( VecCol.r, 255 ), math.min( VecCol.g, 255 ), math.min( VecCol.b, 255 ) )
			particle:SetGravity( Vector(0,0,-math.Rand(33, 66)) )
			particle:SetRollDelta( math.random(0, 0.5 * math.pi) )
			particle:SetAirResistance( 175 )

			particle:SetStartSize( 15 )
			particle:SetDieTime( math.Rand(0.5, 1) )
			particle:SetEndSize( math.Rand(45, 90) )
			particle:SetVelocity( dir * math.Rand(40, 200) + VectorRand() * 150)
		end

		for i = 1,15 do
			local particle = emitter:Add("effects/fleck_cement" .. math.random(1, 2), pos + dir * 8)

			if not particle then continue end

			particle:SetStartAlpha( 255 )
			particle:SetEndAlpha( 0 )
			particle:SetCollide( true )
			particle:SetBounce( math.Rand(0,1) )
			particle:SetColor( math.min( VecCol.r, 255 ), math.min( VecCol.g, 255 ), math.min( VecCol.b, 255 ) )
			particle:SetGravity(Vector(0,0,-600))
			particle:SetRollDelta( math.random(0, 0.5*math.pi) )

			particle:SetEndSize( 2 )
			particle:SetStartSize( 2 )

			particle:SetDieTime( math.Rand(1, 2) )
			particle:SetVelocity( dir * math.Rand(40, 200) + VectorRand() * 500 )
		end
	end

	if not self.DustSurface[ surfaceName ] then return end

	for i = 1, 10 do
		for i = 1, 15 do
			local particle = emitter:Add( self.SmokeMat[ math.random(1, #self.SmokeMat ) ], pos )

			if not particle then continue end

			particle:SetStartAlpha( math.Rand(40, 80) )
			particle:SetEndAlpha(0)
			particle:SetColor( math.min( VecCol.r, 255 ), math.min( VecCol.g, 255 ), math.min( VecCol.b, 255 ) )
			particle:SetGravity( Vector(0,0,-math.Rand(75, 150)) )
			particle:SetRollDelta( math.random(0, 0.5*math.pi) )
			particle:SetAirResistance( 175 )

			particle:SetStartSize( 5 )
			particle:SetDieTime( math.Rand(0.5, 1) )
			particle:SetEndSize( math.Rand(15, 30) )
			particle:SetVelocity( (dir * math.Rand(80, 400) + VectorRand() * 100) * 1.5 )
		end
    
		for n = 0,6 do
			local particle = emitter:Add( self.DustMat[ math.random(1,#self.DustMat) ] , pos )

			if not particle then continue end

			particle:SetVelocity( (dir * 50 * i + VectorRand() * 50) )
			particle:SetDieTime( (i / 8) * DieTime )
			particle:SetAirResistance( 10 ) 
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 5 )
			particle:SetEndSize( 10 * i )
			particle:SetRollDelta( math.Rand(-1,1) )
			particle:SetColor( math.min( VecCol.r, 255 ), math.min( VecCol.g, 255 ), math.min( VecCol.b, 255 ) )
			particle:SetGravity( Vector(0,0,-600) )
			particle:SetCollide( false )
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--PATH lua/effects/lvs_concussion_explosion.lua:
return gluapack()()
--PATH lua/effects/lvs_engine_blacksmoke.lua:
return gluapack()()
--PATH lua/effects/lvs_exhaust.lua:

local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	local Pos = data:GetOrigin()
	local Dir = data:GetNormal()
	local Ent = data:GetEntity()
	local Scale = data:GetMagnitude()

	if not IsValid( Ent ) then return end

	local Vel = Ent:GetVelocity()

	local emitter = Ent:GetParticleEmitter( Pos )

	if not IsValid( emitter ) then return end

	local particle = emitter:Add( Materials[ math.random(1, #Materials ) ], Pos )

	if not particle then return end

	local Col = 100 - 60 * Scale

	particle:SetVelocity( Vel + Dir * (100 + 50 * Scale) )
	particle:SetDieTime( 0.4 - 0.3 * Scale )
	particle:SetAirResistance( 400 ) 
	particle:SetStartAlpha( 80 )
	particle:SetStartSize( 2 )
	particle:SetEndSize( 10 + 20 * Scale )
	particle:SetRoll( math.Rand( -1, 1 ) )
	particle:SetRollDelta( math.Rand( -1, 1 ) * 2 )
	particle:SetColor( Col, Col, Col )
	particle:SetGravity( Vector( 0, 0, 10 ) )
	particle:SetCollide( false )
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--PATH lua/effects/lvs_explosion.lua:
return gluapack()()
--PATH lua/effects/lvs_firetrail.lua:

local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	self.Entity = data:GetEntity()
	self.Scale = data:GetScale()
	self.DieTime = CurTime() + data:GetMagnitude()
	self.Pos = data:GetStart()
	
	if not IsValid( self.Entity ) then return end

	self.Emitter = ParticleEmitter( self.Entity:LocalToWorld( self.Pos ), false )
end


function EFFECT:Think()
	if IsValid( self.Entity ) then
		local Pos = self.Entity:LocalToWorld( self.Pos )

		local T = CurTime()

		if (self.nextDFX or 0) < T then
			self.nextDFX = T + 0.05

			if self.Emitter then
				local particle = self.Emitter:Add( Materials[ math.random(1, #Materials ) ], Pos )

				if particle then
					particle:SetVelocity( VectorRand() * 100 * self.Scale )
					particle:SetDieTime( 3 )
					particle:SetAirResistance( 0 )
					particle:SetStartAlpha( 150 )
					particle:SetStartSize( 150 * self.Scale )
					particle:SetEndSize( math.Rand(200,300) * self.Scale )
					particle:SetRoll( math.Rand(-1,1) * 100 )
					particle:SetColor( 40,40,40 )
					particle:SetGravity( Vector( 0, 0, 0 ) )
					particle:SetCollide( false )
				end

				local particle = self.Emitter:Add( "effects/lvs_base/fire", Pos )

				if particle then
					particle:SetVelocity( VectorRand() * 100 * self.Scale )
					particle:SetDieTime( math.random(40,80) / 100 )
					particle:SetAirResistance( 0 ) 
					particle:SetStartAlpha( 255 )
					particle:SetStartSize( 130 * self.Scale )
					particle:SetEndSize( math.Rand(50,100) * self.Scale )
					particle:SetRoll( math.Rand(-1,1) * 180 )
					particle:SetColor( 255,255,255 )
					particle:SetGravity( Vector( 0, 0, 70 ) )
					particle:SetCollide( false )
				end

				for i = 0,3 do
					local particle = self.Emitter:Add( "effects/lvs_base/flamelet"..math.random(1,5), Pos + VectorRand() * 100 * self.Scale )

					if particle then
						particle:SetVelocity( VectorRand() * 100 * self.Scale )
						particle:SetDieTime( math.random(30,60) / 100 )
						particle:SetAirResistance( 0 ) 
						particle:SetStartAlpha( 255 )
						particle:SetStartSize( 70 * self.Scale )
						particle:SetEndSize( math.Rand(25,80) * self.Scale )
						particle:SetRoll( math.Rand(-1,1) * 180 )
						particle:SetColor( 255,255,255 )
						particle:SetGravity( Vector( 0, 0, 40 ) )
						particle:SetCollide( false )
					end
				end
			end
		end

		if self.DieTime < CurTime() then 
			if self.Emitter then
				self.Emitter:Finish()
			end

			return false
		end

		return true
	end

	if self.Emitter then
		self.Emitter:Finish()
	end

	return false
end

function EFFECT:Render()
end

--PATH lua/effects/lvs_laat_wing_projector.lua:
return gluapack()()
--PATH lua/effects/lvs_laser_blue_long.lua:

EFFECT.MatBeam = Material( "effects/spark" )
EFFECT.MatSprite = Material( "sprites/light_glow02_add" )

function EFFECT:Init( data )
	local pos  = data:GetOrigin()
	local dir = data:GetNormal()

	self.ID = data:GetMaterialIndex()

	self:SetRenderBoundsWS( pos, pos + dir * 50000 )
end

function EFFECT:Think()
	if not LVS:GetBullet( self.ID ) then return false end

	return true
end

function EFFECT:Render()
	local bullet = LVS:GetBullet( self.ID )

	local endpos = bullet:GetPos()
	local dir = bullet:GetDir()

	local len = 2500 * bullet:GetLength()

	render.SetMaterial( self.MatSprite ) 
	render.DrawBeam( endpos - dir * len * 2, endpos + dir * len * 2, 200, 1, 0, Color( 0, 0, 255, 255 ) )

	render.SetMaterial( self.MatBeam )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 45, 1, 0, Color( 0, 0, 255, 255 ) )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 15, 1, 0, Color( 255, 255, 255, 255 ) )
end

--PATH lua/effects/lvs_laser_impact.lua:
EFFECT.GlowMat = Material( "sprites/light_glow02_add" )

function EFFECT:Init( data )
	self.Pos = data:GetOrigin()
	self.Dir = data:GetNormal()
	self.Col = data:GetStart() or Vector(255,100,0)

	self.LifeTime = 0.2
	self.DieTime = CurTime() + self.LifeTime

	local trace = util.TraceLine( {
		start = self.Pos - self.Dir,
		endpos = self.Pos + self.Dir,
		mask = MASK_SOLID_BRUSHONLY,
	} )

	self.Flat = trace.Hit and not trace.HitSky

	local Col = self.Col
	local Pos = self.Pos

	local emitter = ParticleEmitter( Pos, false )

	for i = 0, 10 do
		local particle = emitter:Add( "sprites/light_glow02_add", Pos )

		local vel = VectorRand() * 200 + self.Dir  * 80

		if not particle then continue end

		particle:SetVelocity( vel )
		particle:SetAngles( vel:Angle() + Angle(0,90,0) )
		particle:SetDieTime( math.Rand(0.2,0.4) )
		particle:SetStartAlpha( 255 )
		particle:SetEndAlpha( 0 )
		particle:SetStartSize( math.Rand(12,24) )
		particle:SetEndSize( 0 )
		particle:SetRoll( math.Rand(-100,100) )
		particle:SetRollDelta( math.Rand(-100,100) )
		particle:SetColor( Col.x,Col.y,Col.z )
		particle:SetGravity( Vector(0,0,-600) )

		particle:SetAirResistance( 0 )

		particle:SetCollide( true )
		particle:SetBounce( 0.5 )
	end

	emitter:Finish()
end

function EFFECT:Think()
	if self.DieTime < CurTime() then return false end

	return true
end

function EFFECT:Render()
	local Scale = (self.DieTime - CurTime()) / self.LifeTime

	local S1 = 200 * Scale
	local S2 = 50 * Scale

	if self.Flat then
		cam.Start3D2D( self.Pos + self.Dir, self.Dir:Angle() + Angle(90,0,0), 1 )
			surface.SetMaterial( self.GlowMat )
			surface.SetDrawColor( self.Col.x, self.Col.y, self.Col.z, 255 )
			surface.DrawTexturedRectRotated( 0, 0, S1 , S1 , 0 )

			surface.SetDrawColor( 255, 255, 255, 255 )
			surface.DrawTexturedRectRotated( 0, 0, S2 , S2 , 0 )
		cam.End3D2D()
	end

	render.SetMaterial( self.GlowMat )
	render.DrawSprite( self.Pos + self.Dir, S1, S1, Color( self.Col.x, self.Col.y, self.Col.z, 255 ) )
	render.DrawSprite( self.Pos + self.Dir, S2, S2, Color( 255, 255, 255, 255) )
end

--PATH lua/effects/lvs_muzzle.lua:

function EFFECT:Init( data )
	local Pos = data:GetOrigin()
	local Dir = data:GetNormal()
	local Ent = data:GetEntity()
	local Vel = Dir * 10

	if IsValid( Ent ) then
		Vel = Ent:GetVelocity()
	end

	local emitter = ParticleEmitter( Pos, false )

	if not IsValid( emitter ) then return end

	for i = 0, 12 do
		local particle = emitter:Add( "effects/muzzleflash2", Pos + Dir * i * 0.7 * math.random(1,2) * 0.5 )
		local Size = 1

		if not particle then continue end

		particle:SetVelocity( Dir * 800 + Vel )
		particle:SetDieTime( 0.05 )
		particle:SetStartAlpha( 255 * Size )
		particle:SetStartSize( math.max( math.random(10,24) - i * 0.5,0.1 ) * Size )
		particle:SetEndSize( 0 )
		particle:SetRoll( math.Rand( -1, 1 ) )
		particle:SetColor( 255, 255, 255 )
		particle:SetCollide( false )
	end

	emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--PATH lua/effects/lvs_physics_dust.lua:
local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

local MatDebris = {
	"effects/lvs_base/particle_debris_01",
	"effects/lvs_base/particle_debris_02",
}

function EFFECT:Init( data )
	local Pos = data:GetOrigin()
	local Ent = data:GetEntity()

	if not IsValid( Ent ) then return end

	local Dir = Ent:GetForward()

	local emitter = Ent:GetParticleEmitter( Ent:GetPos() )

	local VecCol = render.GetLightColor( Pos + Vector(0,0,10) ) * 0.5 + Vector(0.3,0.25,0.15)

	if emitter and emitter.Add then
		for i = 1, 3 do
			local particle = emitter:Add( MatDebris[math.random(1,#MatDebris)], Pos + VectorRand(-10,10) )
			if particle then
				particle:SetVelocity( Vector(0,0,150) - Dir * 150 )
				particle:SetDieTime( 0.2 )
				particle:SetAirResistance( 60 ) 
				particle:SetStartAlpha( 255 )
				particle:SetEndAlpha( 255 )
				particle:SetStartSize( 15 )
				particle:SetEndSize( 50 )
				particle:SetRoll( math.Rand(-1,1) * 100 )
				particle:SetColor( VecCol.x * 130,VecCol.y * 100,VecCol.z * 60 )
				particle:SetGravity( Vector( 0, 0, -600 ) )
				particle:SetCollide( false )
			end
		end

		local Right = Ent:GetRight() 
		Right.z = 0
		Right:Normalize()

		for i = -1,1,2 do
			local particle = emitter:Add( Materials[math.random(1,#Materials)], Pos + Vector(0,0,10)  )
			if particle then
				particle:SetVelocity( -Dir * 400 + Right * 150 * i )
				particle:SetDieTime( math.Rand(0.5,1) )
				particle:SetAirResistance( 150 ) 
				particle:SetStartAlpha( 50 )
				particle:SetStartSize( -80 )
				particle:SetEndSize( 400 )
				particle:SetColor( VecCol.x * 255,VecCol.y * 255,VecCol.z * 255 )
				particle:SetGravity( Vector( 0, 0, 100 ) )
				particle:SetCollide( false )
			end
		end
	end
end


function EFFECT:Think()
	return false
end

function EFFECT:Render()
end
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/effects/masita_dioxis/init.lua:
--Thanks Inconceivable/Generic Default
function EFFECT:Init(data)
	self.Entity = data:GetEntity()
	pos = data:GetOrigin()
	self.Emitter = ParticleEmitter(pos)
	for i=1, 25 do
		local particle = self.Emitter:Add( "tfa_csgo/particle/particle_smokegrenade", pos)
		if (particle) then
			particle:SetVelocity( VectorRand():GetNormalized()*math.Rand(150, 300) )
			if i <= 5 then 
				particle:SetDieTime( 35 )
			else
				particle:SetDieTime( math.Rand( 30,35 ) )
			end
			particle:SetStartAlpha( math.Rand( 116, 216 ) )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( 116 )
			particle:SetEndSize( 346 )
			particle:SetRoll( math.Rand(0, 360) )
			particle:SetRollDelta( math.Rand(-1, 1)/3 )
			particle:SetColor( 95, 125, 60 ) 
			particle:SetAirResistance( 82 ) 
			//particle:SetGravity( Vector(math.Rand(-30, 30),math.Rand(-30, 30), -200 )) 	
			particle:SetCollide( true )
			particle:SetBounce( 1 )
		end
	end

end

function EFFECT:Think()
return false
end

function EFFECT:Render()

end
--PATH lua/effects/fxbase.lua:
-- based on nomad's tracer by Chad Barrett --
-- edited for the use with SciFiWeapons by Darken217 --

AddCSLuaFile()
if ( CLIENT ) then
TRACER_FLAG_USEATTACHMENT	= 0x0002
end
EFFECT.Speed	= 6500
EFFECT.Length	= 64
EFFECT.Normal 	= Vector( 0, 0, 0 )

function EFFECT:GetTracerOrigin( data )
	if ( CLIENT ) then
		local vOrigin = data:GetStart()

		if ( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then
			local entParent = data:GetEntity()
			
			if ( !IsValid( entParent ) ) then 
				return vOrigin 
			end
			
			if ( !game.SinglePlayer() && entParent:IsEFlagSet( EFL_DORMANT ) ) then 
				return vOrigin 
			end
			
			if( entParent:IsWeapon() && entParent:IsCarriedByLocalPlayer() ) then
				local entPlayer = entParent:GetOwner()
				if ( IsValid( entPlayer ) ) then
					local entViewModel = entPlayer:GetViewModel()
					if ( IsValid( entViewModel ) && !LocalPlayer():ShouldDrawLocalPlayer() ) then
						entParent = entViewModel
					else 					
						if ( entParent.WorldModel ) then
							entParent:SetModel( entParent.WorldModel )
						end
					end
				end
			end

			local attachment = entParent:GetAttachment( data:GetAttachment() )
			if ( attachment ) then
				vOrigin = attachment.Pos
			end

		end
		
		return vOrigin
	end
end

function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data )
	self.EndPos = data:GetOrigin()
	self.Parent = data:GetEntity()
	
--	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos )

	local diff = ( self.EndPos - self.StartPos )
	
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	
	if ( !self.LifeTime ) then
		self.LifeTime = ( diff:Length() + self.Length ) / self.Speed
	else
		self.LifeTime = CurTime() + self.LifeTime
	end
	
end

function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	
	return self.LifeTime > 0

end

function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	
	startDistance = math.max( 0, startDistance )
	endDistance = math.max( 0, endDistance )

	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	
end
--PATH lua/effects/nio_tracer_legacy.lua:
AddCSLuaFile()
AddCSLuaFile( "effects/fxbase.lua" )
include( "effects/fxbase.lua" )

EFFECT.Speed	= 13000
EFFECT.Length	= 64
EFFECT.Trace	= Material( "effects/gunshiptracer" )
EFFECT.Halo		= Material( "effects/combine_halo" )
EFFECT.FlyBy	= "weapons/neutrino/flyby.wav"

function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data )
	self.EndPos = data:GetOrigin()
	self.Parent = data:GetEntity()
	
	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos )

	local diff = ( self.EndPos - self.StartPos )
	
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = ( diff:Length() + self.Length ) / self.Speed

end

function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	
	startDistance = math.max( 0, startDistance )
	endDistance = math.max( 0, endDistance )
	
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance * 2
	
	render.SetMaterial( self.Halo )
	render.DrawSprite( endPos, 18, 18, Color( 85, 255, 0, 255 ) )

	render.SetMaterial( self.Trace )
	render.DrawBeam( startPos, endPos, 64, 0, 1, Color( 85, 255, 0, 255 ) )
end
--PATH lua/effects/nrg_tracer.lua:
AddCSLuaFile()
AddCSLuaFile( "effects/fxbase.lua" )
include( "effects/fxbase.lua" )

EFFECT.ParticleCast = false
EFFECT.Time = nil

EFFECT.Speed = 12000
function EFFECT:Think()

	if ( !self.ParticleCast ) then
		util.ParticleTracerEx( 
			"tbolt_tracer", 	--particle system
			self.StartPos, 	--startpos
			self.EndPos, 	--endpos
			false, 			--do whiz effect
			-1, 			--entity index
			-1  			--attachment
		)
		
		self.ParticleCast = true
	end
	
	if ( !self.Time ) then	
		self.Time = self.LifeTime + CurTime()
	end
	
	local Fraction = math.max( 0, ( self.Time - CurTime() ) / self.LifeTime )
	
	local difforigin = self.EndPos - self.StartPos
	local lightorigin = self.StartPos + ( difforigin * ( 1 - Fraction ) ) 

	local mLight = DynamicLight( -1 )
	if ( mLight ) then
		mLight.pos = lightorigin
		mLight.r = 110
		mLight.g = 160
		mLight.b = 255
		mLight.brightness = 3 * Fraction
		mLight.Size = 180 + 200 * Fraction
		mLight.Decay = 1024
		mLight.Style = 1
		mLight.DieTime = CurTime() + 1
	end
	
	return ( self.Time > CurTime() ) 
	
end

--PATH lua/effects/fxbase.lua:
return gluapack()()
--PATH lua/effects/pulsar_tracer_red.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/effects/rb655_force_repulse_out.lua:
return gluapack()()
--PATH lua/effects/rw_sw_dual_laser_orange.lua:
TRACER_FLAG_USEATTACHMENT 	= 0x0002
SOUND_FROM_WORLD			= 0
CHAN_STATIC 				= 6

EFFECT.Speed 				= 16384
EFFECT.Length 				= 95

local MaterialMain 			= Material("effects/sw_l/rw_sw_laser_m_orange")
local MaterialFront 		= Material("effects/sw_l/rw_sw_laser_f_orange")
local DynamicTracer 		= GetConVar("cl_dynamic_tracer")

function EFFECT:Init(data)
	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.WeaponEntOG = data:GetEntity()
	self.Attachment = data:GetAttachment()
	local owent
	if IsValid(self.WeaponEnt) then
		owent = self.WeaponEnt.Owner or self.WeaponEnt:GetOwner()
		if not IsValid(owent) then
			owent = self.WeaponEnt:GetParent()
		end
	end
	if IsValid(owent) and owent:IsPlayer() then
		if owent ~= LocalPlayer() or owent:ShouldDrawLocalPlayer() then
			self.WeaponEnt = owent:GetActiveWeapon()
			if not IsValid(self.WeaponEnt) then return end
		else
			self.WeaponEnt = owent:GetViewModel()
			local theirweapon = owent:GetActiveWeapon()
			if IsValid(theirweapon) and theirweapon.ViewModelFlip or theirweapon.ViewModelFlipped then
				self.Flipped = true
			end
			if not IsValid(self.WeaponEnt) then return end
		end
	end
	if IsValid(self.WeaponEntOG) and self.WeaponEntOG.MuzzleAttachment then
		self.Attachment = self.WeaponEnt:LookupAttachment(self.WeaponEntOG.MuzzleAttachment)
		if not self.Attachment or self.Attachment <= 0 then
			self.Attachment = 1
		end
		if self.WeaponEntOG.Akimbo then
			if game.SinglePlayer() then
				self.WeaponEntOG.AnimCycle = self.WeaponEntOG:GetNW2Int("AnimCycle") or 0
			end
			self.Attachment = 1 + self.WeaponEntOG.AnimCycle
		end
	end
	local angpos
	if IsValid(self.WeaponEnt) then
		angpos = self.WeaponEnt:GetAttachment(self.Attachment)
	end
	if not angpos or not angpos.Pos then
		angpos = {
			Pos = bvec,
			Ang = uAng
		}
	end
	if self.Flipped then
		local tmpang = (self.Dir or angpos.Ang:Forward()):Angle()
		local localang = self.WeaponEnt:WorldToLocalAngles(tmpang)
		localang.y = localang.y + 180
		localang = self.WeaponEnt:LocalToWorldAngles(localang)
		self.Dir = localang:Forward()
	end
	if IsValid(owent) and self.Position:Distance(owent:GetShootPos()) > 72 then
		self.WeaponEnt = nil
	end
	
	self.StartPos = self:GetTracerShootPos(self.WeaponEnt and angpos.Pos or self.Position, self.WeaponEnt, self.Attachment)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	self.Normal = (self.EndPos - self.StartPos):GetNormalized()
	self.StartTime = 0
	local diff = self.EndPos - self.StartPos
	self.LifeTime = (diff:Length() - self.Length/2 ) / self.Speed
	self.data = data
	self.rot = nil
	weapon = data:GetEntity()
	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	if DynamicTracer:GetBool() then
		local spawn = util.CRC(tostring(self:GetPos()))
		local dlight = DynamicLight(self:EntIndex() + spawn)
		local endDistance = self.Speed * self.StartTime
		local endPos = self.StartPos + self.Normal * endDistance
		if (dlight) then
			dlight.pos = endPos
			dlight.r = 255
			dlight.g = 90
			dlight.b = 0
			dlight.brightness = 3
			dlight.Decay = 1500
			dlight.Size = 300
			dlight.nomodel = 1
			dlight.style = 6
			dlight.DieTime = CurTime() + 3
		end
	end
	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 9, 9, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 7, 0, 0, color_white)
end
--PATH lua/effects/rw_sw_dual_laser_redpink.lua:
TRACER_FLAG_USEATTACHMENT 	= 0x0002
SOUND_FROM_WORLD			= 0
CHAN_STATIC 				= 6

EFFECT.Speed 				= 16384
EFFECT.Length 				= 95

local MaterialMain			= Material( "effects/sw_l/rw_sw_laser_m_redpink" )
local MaterialFront			= Material( "effects/sw_l/rw_sw_laser_f_redpink" )
local DynamicTracer 		= GetConVar("cl_dynamic_tracer")

function EFFECT:Init(data)
	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.WeaponEntOG = data:GetEntity()
	self.Attachment = data:GetAttachment()
	local owent
	if IsValid(self.WeaponEnt) then
		owent = self.WeaponEnt.Owner or self.WeaponEnt:GetOwner()
		if not IsValid(owent) then
			owent = self.WeaponEnt:GetParent()
		end
	end
	if IsValid(owent) and owent:IsPlayer() then
		if owent ~= LocalPlayer() or owent:ShouldDrawLocalPlayer() then
			self.WeaponEnt = owent:GetActiveWeapon()
			if not IsValid(self.WeaponEnt) then return end
		else
			self.WeaponEnt = owent:GetViewModel()
			local theirweapon = owent:GetActiveWeapon()
			if IsValid(theirweapon) and theirweapon.ViewModelFlip or theirweapon.ViewModelFlipped then
				self.Flipped = true
			end
			if not IsValid(self.WeaponEnt) then return end
		end
	end
	if IsValid(self.WeaponEntOG) and self.WeaponEntOG.MuzzleAttachment then
		self.Attachment = self.WeaponEnt:LookupAttachment(self.WeaponEntOG.MuzzleAttachment)
		if not self.Attachment or self.Attachment <= 0 then
			self.Attachment = 1
		end
		if self.WeaponEntOG.Akimbo then
			if game.SinglePlayer() then
				self.WeaponEntOG.AnimCycle = self.WeaponEntOG:GetNW2Int("AnimCycle") or 0
			end
			self.Attachment = 1 + self.WeaponEntOG.AnimCycle
		end
	end
	local angpos
	if IsValid(self.WeaponEnt) then
		angpos = self.WeaponEnt:GetAttachment(self.Attachment)
	end
	if not angpos or not angpos.Pos then
		angpos = {
			Pos = bvec,
			Ang = uAng
		}
	end
	if self.Flipped then
		local tmpang = (self.Dir or angpos.Ang:Forward()):Angle()
		local localang = self.WeaponEnt:WorldToLocalAngles(tmpang)
		localang.y = localang.y + 180
		localang = self.WeaponEnt:LocalToWorldAngles(localang)
		self.Dir = localang:Forward()
	end
	if IsValid(owent) and self.Position:Distance(owent:GetShootPos()) > 72 then
		self.WeaponEnt = nil
	end
	
	self.StartPos = self:GetTracerShootPos(self.WeaponEnt and angpos.Pos or self.Position, self.WeaponEnt, self.Attachment)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	self.Normal = (self.EndPos - self.StartPos):GetNormalized()
	self.StartTime = 0
	local diff = self.EndPos - self.StartPos
	self.LifeTime = (diff:Length() - self.Length/2 ) / self.Speed
	self.data = data
	self.rot = nil
	weapon = data:GetEntity()
	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	if DynamicTracer:GetBool() then
		local spawn = util.CRC(tostring(self:GetPos()))
		local dlight = DynamicLight(self:EntIndex() + spawn)
		local endDistance = self.Speed * self.StartTime
		local endPos = self.StartPos + self.Normal * endDistance
		if (dlight) then
			dlight.pos = endPos
			dlight.r = 255
			dlight.g = 0
			dlight.b = 50
			dlight.brightness = 3
			dlight.Decay = 1500
			dlight.Size = 300
			dlight.nomodel = 1
			dlight.style = 6
			dlight.DieTime = CurTime() + 3
		end
	end
	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 9, 9, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 7, 0, 0, color_white)
end
--PATH lua/effects/rw_sw_impact_aqua.lua:
local MaterialGlow		= Material( "effects/sw_i/sw_laser_bit_aqua" );
function EFFECT:Init( data )
	local bit_amount = GetConVar("rw_sw_bit_amount"):GetInt()
	local smoke_amount = GetConVar("rw_sw_smoke_amount"):GetInt()
	local duration = GetConVar("rw_sw_impact_duration"):GetInt()
	self.Position = data:GetOrigin();
	self.Normal = data:GetNormal();
	self.LifeTime = duration;
	local emitter = ParticleEmitter( self.Position );
	if( emitter ) then
		for i = 1, bit_amount do
			local particle = emitter:Add( MaterialGlow, self.Position + self.Normal * 2 );
			particle:SetVelocity( ( self.Normal + VectorRand() * 0.75 ):GetNormal() * math.Rand( 75, 125 ) );
			particle:SetDieTime( math.Rand( 0.5, 1.25 ) );
			particle:SetStartAlpha( 255 );
			particle:SetEndAlpha( 0 );
			particle:SetStartSize( math.Rand( 4, 8 ) );
			particle:SetEndSize( 0 );
			particle:SetRoll( 0 );
			particle:SetGravity( Vector( 0, 0, -250 ) );
			particle:SetCollide( true );
			particle:SetBounce( 0.3 );
			particle:SetAirResistance( 5 );
		end
		emitter:Finish();
	end
	local emitter_s = ParticleEmitter( self.Position );
	if( emitter_s ) then
		for i = 1, smoke_amount do
			local smokeTexture	= "effects/smoke"
			local particle_s = emitter_s:Add(smokeTexture, self.Position+self.Normal*2);
			particle_s:SetVelocity((self.Normal+VectorRand()*0.10):GetNormal()*math.Rand(400, 900));
			particle_s:SetDieTime(math.Rand(2.1, 2.7));
			particle_s:SetStartAlpha(50);
			particle_s:SetEndAlpha(0);
			particle_s:SetStartSize(math.Rand(8, 16));
			particle_s:SetEndSize(math.Rand(0, 4));
			particle_s:SetGravity(Vector(math.Rand(0, 500), math.Rand(250, 1000), math.Rand(-250, 250)));
			particle_s:SetRoll(math.Rand(0, 360));
			particle_s:SetRollDelta(math.Rand(-0.5, 0.5));
			local colour = math.Rand(110, 130);
			particle_s:SetColor(colour, colour, colour, 100);
			particle_s:SetCollide(true);
			particle_s:SetAirResistance(2000);
		end
		emitter_s:Finish();
	end
end
function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime();
	return self.LifeTime > 0;
end
function EFFECT:Render()
	local size = GetConVar("rw_sw_impact_size"):GetInt()
	local duration = GetConVar("rw_sw_impact_duration"):GetInt()
	local frac = math.max( 0, self.LifeTime / duration);
	local rgb = 255 * frac;
	local color = Color( rgb, rgb, rgb, 255 );
	render.SetMaterial( MaterialGlow );
	render.DrawQuadEasy( self.Position + self.Normal, self.Normal, size, size, color );
end
--PATH lua/effects/rw_sw_impact_black.lua:
return gluapack()()
--PATH lua/effects/rw_sw_impact_red.lua:
return gluapack()()
--PATH lua/effects/rw_sw_laser_green.lua:
return gluapack()()
--PATH lua/effects/rw_sw_laser_green.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002
SOUND_FROM_WORLD			= 0
CHAN_STATIC					= 6

EFFECT.Speed				= 16384
EFFECT.Length				= 95

local MaterialMain			= Material("effects/sw_laser_green_main")
local MaterialFront			= Material("effects/sw_laser_green_front")
local DynamicTracer 		= GetConVar("cl_dynamic_tracer")

function EFFECT:GetTracerOrigin(data)
	local start = data:GetStart()
	if (bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT) then
		local entity = data:GetEntity()
		if (not IsValid(entity)) then return start end
		if (not game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT)) then return start end
		if (entity:IsWeapon() and entity:IsCarriedByLocalPlayer()) then
			local pl = entity:GetOwner()
			if (IsValid(pl)) then
				local vm = pl:GetViewModel()
				if (IsValid(vm) and not LocalPlayer():ShouldDrawLocalPlayer()) then
					entity = vm
				else
					if (entity.WorldModel) then
						entity:SetModel(entity.WorldModel)
					end
				end
			end
		end
		local attachment = entity:GetAttachment(data:GetAttachment())
		if (attachment) then
			start = attachment.Pos
		end
	end
	return start
end

function EFFECT:Init(data)
	self.StartPos = self:GetTracerOrigin(data)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	local diff = self.EndPos - self.StartPos
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = (diff:Length() - self.Length/2 ) / self.Speed 	--self.LifeTime = (diff:Length() - (self.Length/2) ) / self.Speed
	local weapon = data:GetEntity()
	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	if DynamicTracer:GetBool() then
		local spawn = util.CRC(tostring(self:GetPos()))
		local dlight = DynamicLight(self:EntIndex() + spawn)
		local endDistance = self.Speed * self.StartTime
		local endPos = self.StartPos + self.Normal * endDistance
		if (dlight) then
			dlight.pos = endPos
			dlight.r = 0
			dlight.g = 255
			dlight.b = 0
			dlight.brightness = 2
			dlight.Decay = 1500
			dlight.Size = 300
			dlight.nomodel = 1
			dlight.style = 6
			dlight.DieTime = CurTime() + 3
		end
	end
	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 9, 9, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 7, 0, 0, color_white)
end
--PATH lua/effects/rw_sw_laser_white.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002
SOUND_FROM_WORLD			= 0
CHAN_STATIC					= 6

EFFECT.Speed				= 16384
EFFECT.Length				= 95

local MaterialMain			= Material( "effects/sw_laser_white_main" )
local MaterialFront			= Material( "effects/sw_laser_white_front" )
local DynamicTracer 		= GetConVar("cl_dynamic_tracer")

function EFFECT:GetTracerOrigin(data)
	local start = data:GetStart()
	if (bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT) then
		local entity = data:GetEntity()
		if (not IsValid(entity)) then return start end
		if (not game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT)) then return start end
		if (entity:IsWeapon() and entity:IsCarriedByLocalPlayer()) then
			local pl = entity:GetOwner()
			if (IsValid(pl)) then
				local vm = pl:GetViewModel()
				if (IsValid(vm) and not LocalPlayer():ShouldDrawLocalPlayer()) then
					entity = vm
				else
					if (entity.WorldModel) then
						entity:SetModel(entity.WorldModel)
					end
				end
			end
		end
		local attachment = entity:GetAttachment(data:GetAttachment())
		if (attachment) then
			start = attachment.Pos
		end
	end
	return start
end

function EFFECT:Init(data)
	self.StartPos = self:GetTracerOrigin(data)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	local diff = self.EndPos - self.StartPos
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = (diff:Length() - self.Length/2 ) / self.Speed 	--self.LifeTime = (diff:Length() - (self.Length/2) ) / self.Speed
	local weapon = data:GetEntity()
	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	if DynamicTracer:GetBool() then
		local spawn = util.CRC(tostring(self:GetPos()))
		local dlight = DynamicLight(self:EntIndex() + spawn)
		local endDistance = self.Speed * self.StartTime
		local endPos = self.StartPos + self.Normal * endDistance
		if (dlight) then
			dlight.pos = endPos
			dlight.r = 255
			dlight.g = 255
			dlight.b = 255
			dlight.brightness = 2
			dlight.Decay = 1500
			dlight.Size = 300
			dlight.nomodel = 1
			dlight.style = 6
			dlight.DieTime = CurTime() + 3
		end
	end
	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 9, 9, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 7, 0, 0, color_white)
end
--PATH lua/effects/rw_sw_muzzleflash_green.lua:
return gluapack()()
--PATH lua/effects/rw_sw_muzzleflash_red.lua:
return gluapack()()
--PATH lua/effects/rw_sw_muzzleflash_red.lua:
EFFECT.Life = 0.12
EFFECT.XFlashSize = 0.55
EFFECT.FlashSize = 0.5
EFFECT.SmokeSize = 0
EFFECT.SparkSize = 1.25
EFFECT.HeatSize = 2.5
EFFECT.Color = Color(255,0,0)
EFFECT.ColorSprites = true

local AddVel = Vector()
local ang

function EFFECT:Init(data)
	self.WeaponEnt = data:GetEntity()
	if not IsValid(self.WeaponEnt) then return end
	self.Attachment = data:GetAttachment()
	self.Position = self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)

	if IsValid(self.WeaponEnt:GetOwner()) then
		if self.WeaponEnt:GetOwner() == LocalPlayer() then
			if self.WeaponEnt:GetOwner():ShouldDrawLocalPlayer() then
				ang = self.WeaponEnt:GetOwner():EyeAngles()
				ang:Normalize()
				--ang.p = math.max(math.min(ang.p,55),-55)
				self.Forward = ang:Forward()
			else
				self.WeaponEnt = self.WeaponEnt:GetOwner():GetViewModel()
			end
			--ang.p = math.max(math.min(ang.p,55),-55)
		else
			ang = self.WeaponEnt:GetOwner():EyeAngles()
			ang:Normalize()
			self.Forward = ang:Forward()
		end
	end

	self.Forward = self.Forward or data:GetNormal()
	self.Angle = self.Forward:Angle()
	self.Right = self.Angle:Right()
	self.vOffset = self.Position
	local dir = self.Forward
	local ownerent = self.WeaponEnt:GetOwner()

	if not IsValid(ownerent) then
		ownerent = LocalPlayer()
	end

	AddVel = ownerent:GetVelocity()
	self.vOffset = self.Position
	AddVel = AddVel * 0.05
	local dot = dir:GetNormalized():Dot(GetViewEntity():EyeAngles():Forward())
	local halofac = math.abs(dot)
	local epos = ownerent:GetShootPos()
	local dlight = DynamicLight(ownerent:EntIndex())

	if (dlight) then
		dlight.pos = epos + ownerent:EyeAngles():Forward() * self.vOffset:Distance(epos) --self.vOffset - ownerent:EyeAngles():Right() * 5 + 1.05 * ownerent:GetVelocity() * FrameTime()
		dlight.r = self.Color.r
		dlight.g = self.Color.g
		dlight.b = self.Color.b
		dlight.brightness = 4.5
		dlight.decay = 200 / self.Life
		dlight.size = self.FlashSize * 150
		dlight.dietime = CurTime() + self.Life
	end

	self.Dist = self.vOffset:Distance(epos)
	self.DLight = dlight
	self.DieTime = CurTime() + self.Life
	self.OwnerEnt = ownerent
	local emitter = ParticleEmitter(self.vOffset)
	local sval = 1 - math.random(0, 1) * 2

	if self.WeaponEnt.XTick == nil then
		self.WeaponEnt.XTick = 0
	end

	self.WeaponEnt.XTick = 1 - self.WeaponEnt.XTick

	if self.WeaponEnt.XTick == 1 and self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.XFlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(3 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			particle:SetEndSize(15 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
		--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
		--particle:SetEndSize( 0 )
	elseif self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			particle:SetStartSize(2 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			particle:SetEndSize(6 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
	end

	local flashCount = math.Round(self.FlashSize * 8)

	for i = 1, flashCount do
		local particle = emitter:Add(self.ColorSprites and "effects/scotchmuzzleflashw" or "effects/scotchmuzzleflash4", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 300 * (0.2 + (i / flashCount) * 0.8) * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(math.Rand(128, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			local szsc = 1 + (flashCount - i) * math.pow(1 / flashCount * 0.9,0.8)
			particle:SetStartSize(1.25 * math.Rand(1, 1.5) * szsc * self.FlashSize)
			particle:SetEndSize(6 * math.Rand(0.75, 1) * szsc * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	for _ = 1, flashCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 6 * self.FlashSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 1)
			particle:SetStartAlpha(math.Rand(40, 140))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(2 * math.Rand(1, 1.5) * self.FlashSize)
			particle:SetEndSize(20 * math.Rand(0.5, 1) * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(30, 60)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			--TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	local glowCount = math.ceil(self.FlashSize * 3)

	for i = 1, glowCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + dir * 0.9 * i)

		if (particle) then
			--particle:SetVelocity(dir * 32 )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(255 * (1 - halofac))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.2 * self.FlashSize)
			particle:SetEndSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.6 * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	local smokeCount = math.ceil(self.SmokeSize * 6)

	for _ = 0, smokeCount do
		local particle = emitter:Add("particles/smokey", self.vOffset + dir * math.Rand(3, 14))

		if (particle) then
			particle:SetVelocity(VectorRand() * 10 * self.SmokeSize + dir * math.Rand(35, 50) * self.SmokeSize + 1.05 * AddVel)
			particle:SetDieTime(math.Rand(0.6, 1) * self.Life * 6)
			particle:SetStartAlpha(math.Rand(12, 24))
			particle:SetEndAlpha(0)
			particle:SetStartSize(math.Rand(5, 7) * self.SmokeSize)
			particle:SetEndSize(math.Rand(15, 20) * self.SmokeSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.Rand(-0.8, 0.8))
			particle:SetLighting(true)
			particle:SetAirResistance(20)
			particle:SetGravity(Vector(0, 0, 60))
			particle:SetColor(255, 255, 255)
		end
	end

	local sparkcount = math.Round(math.random(8, 12) * self.SparkSize)

	for _ = 0, sparkcount do
		local particle = emitter:Add("effects/yellowflare", self.Position)

		if (particle) then
			particle:SetVelocity( VectorRand() * 30 * self.SparkSize)
			particle:SetVelocity(particle:GetVelocity() + 1.15 * AddVel )
			particle:SetVelocity( particle:GetVelocity() + dir * math.Rand(80, 100) * (1-math.abs(math.max(particle:GetVelocity():GetNormalized():Dot(-dir),0))) * self.SparkSize )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * math.Rand(0.9,1.1))
			particle:SetStartAlpha(255)
			particle:SetEndAlpha(0)
			particle:SetStartSize(0.6)
			particle:SetEndSize(1)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetGravity(vector_origin)
			particle:SetAirResistance(1)
			particle:SetStartLength(0.1)
			particle:SetEndLength(0.05)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, math.random(192, 225), math.random(140, 192))
			end

			particle:SetVelocityScale(true)
			local sl = self.SparkSize

			particle:SetThinkFunction(function(pa)
				math.randomseed(SysTime())
				local spd = pa:GetVelocity():Length()*12
				pa.ranvel = pa.ranvel or VectorRand() * spd
				pa.ranvel:Add(VectorRand() * spd * math.sqrt(FrameTime()))
				pa:SetVelocity(pa:GetVelocity() + pa.ranvel * sl * FrameTime() )
				pa:SetNextThink(CurTime())
			end)

			particle:SetNextThink(CurTime() + 0.01)
		end
	end

	if TFA.GetGasEnabled() then
		local particle = emitter:Add("sprites/heatwave", self.vOffset + dir*2)

		if (particle) then
			particle:SetVelocity(dir * 25 * self.HeatSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life)
			particle:SetStartAlpha(math.Rand(200, 225))
			particle:SetEndAlpha(0)
			particle:SetStartSize(math.Rand(3, 5) * self.HeatSize)
			particle:SetEndSize(math.Rand(8, 12) * self.HeatSize)
			particle:SetRoll(math.Rand(0, 360))
			particle:SetRollDelta(math.Rand(-2, 2))
			particle:SetAirResistance(5)
			particle:SetGravity(Vector(0, 0, 40))
			particle:SetColor(255, 255, 255)
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	if CurTime() > self.DieTime then
		return false
	elseif self.DLight and IsValid(self.OwnerEnt) then
			self.DLight.pos = self.OwnerEnt:GetShootPos() + self.OwnerEnt:EyeAngles():Forward() * self.Dist
	end

	return true
end

function EFFECT:Render()
end
--PATH lua/effects/rw_sw_stunwave_orange.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/effects/saber_hit_generic.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/effects/saber_hitwall_cheap.lua:

local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

local DecalMat = Material( util.DecalMaterial( "FadingScorch" ) )
function EFFECT:Init( data )
	self.Pos = data:GetOrigin()
	self.Col = data:GetStart() or Vector(255,100,0)
	
	self.mat = Material( "sprites/light_glow02_add" )
	
	self.LifeTime = 0.2
	self.DieTime = CurTime() + self.LifeTime

	local Col = self.Col
	local Pos = self.Pos
	local Dir = data:GetNormal()

	--[[
	local trace = util.TraceLine( {
		start = Pos + Dir * 5,
		endpos = Pos - Dir * 5,
	} )

	if trace.Hit and not trace.HitNonWorld then
		util.DecalEx( DecalMat, trace.Entity, trace.HitPos + trace.HitNormal, trace.HitNormal, Color(255,255,255,255), 0.3, 0.3 )
	end
	]]

	local emitter = ParticleEmitter( Pos, false )

	for i = 0,2 do
		local particle = emitter:Add( Materials[ math.random(1,table.Count( Materials )) ], Pos )
		
		local vel = VectorRand() * 100 + Dir * 40
		
		if particle then			
			particle:SetVelocity( vel )
			particle:SetDieTime( 0.5 )
			particle:SetAirResistance( 1000 ) 
			particle:SetStartAlpha( 50 )
			particle:SetStartSize( 2 )
			particle:SetEndSize( 6 )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( 40,40,40 )
			particle:SetGravity( Dir * 10 )
			particle:SetCollide( false )
		end
	end

	for i = 0, 3 do
		local particle = emitter:Add( "sprites/rico1", Pos )
		
		local vel = VectorRand() * 100 + Dir * 40
		
		if particle then
			particle:SetVelocity( vel )
			particle:SetAngles( vel:Angle() + Angle(0,90,0) )
			particle:SetDieTime( 0.5 )
			particle:SetStartAlpha( math.Rand( 200, 255 ) )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( 1 )
			particle:SetEndSize( 0.25 )
			particle:SetRoll( math.Rand(-100,100) )
			particle:SetRollDelta( math.Rand(-100,100) )
			particle:SetCollide( true )
			particle:SetBounce( 0.5 )
			particle:SetAirResistance( 0 )
			particle:SetColor( 255, 150, 0 )
			particle:SetGravity( Vector(0,0,-600) )
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	if self.DieTime < CurTime() then 
		return false
	end

	return true
end

local mat = Material( "sprites/light_glow02_add" )
function EFFECT:Render()
	local Scale = (self.DieTime - CurTime()) / self.LifeTime
	render.SetMaterial( mat )
	render.DrawSprite( self.Pos, 12, 12, Color( 255 * Scale, 100 * Scale, 0, 255) ) 
end


--PATH lua/effects/sw_explosion.lua:

local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	local Pos = data:GetOrigin()
	
	self:Explosion( Pos )
	
	sound.Play( "ambient/explosions/explode_4.wav", Pos, 95, 200, 0.5 )
end

function EFFECT:Explosion( pos )
	local emitter = ParticleEmitter( pos, false )
	
	for i = 0,20 do
		local particle = emitter:Add( Materials[math.random(1,table.Count( Materials ))], pos )
		
		if particle then
			particle:SetVelocity( VectorRand() * 800 )
			particle:SetDieTime( math.Rand(1,2) )
			particle:SetAirResistance( math.Rand(1000,1500) ) 
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( math.Rand(5,15) )
			particle:SetEndSize( math.Rand(30,50) )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( 20,20,20 )
			particle:SetGravity( Vector( 0, 0, 100 ) )
			particle:SetCollide( false )
		end
	end
	
	for i = 0, 20 do
		local particle = emitter:Add( "sprites/rico1", pos )
		
		local vel = VectorRand() * 800
		
		if particle then
			particle:SetVelocity( vel )
			particle:SetAngles( vel:Angle() + Angle(0,90,0) )
			particle:SetDieTime( math.Rand(0.1,0.15) )
			particle:SetStartAlpha( math.Rand( 200, 255 ) )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( math.Rand(6,12) )
			particle:SetEndSize( 0 )
			particle:SetRoll( math.Rand(-100,100) )
			particle:SetRollDelta( math.Rand(-100,100) )
			particle:SetColor( 255, 255, 255 )

			particle:SetAirResistance( 0 )
		end
	end
	
	for i = 0, 40 do
		local particle = emitter:Add( "sprites/flamelet"..math.random(1,5), pos )
		
		if particle then
			particle:SetVelocity( VectorRand() * 300 )
			particle:SetDieTime( 0.14 )
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 5 )
			particle:SetEndSize( math.Rand(10,20) )
			particle:SetEndAlpha( 100 )
			particle:SetRoll( math.Rand( -1, 1 ) )
			particle:SetColor( 200,150,150 )
			particle:SetCollide( false )
		end
	end
	
	emitter:Finish()
	
	local dlight = DynamicLight( math.random(0,9999) )
	if dlight then
		dlight.pos = pos
		dlight.r = 255
		dlight.g = 180
		dlight.b = 100
		dlight.brightness = 8
		dlight.Decay = 2000
		dlight.Size = 100
		dlight.DieTime = CurTime() + 0.1
	end
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--PATH lua/tfa/muzzleflash_base.lua:
return gluapack()()
--PATH lua/tfa/muzzleflash_base.lua:
local vector_origin = Vector()

EFFECT.Life = 0.1
EFFECT.XFlashSize = 1
EFFECT.FlashSize = 1
EFFECT.SmokeSize = 1
EFFECT.SparkSize = 1
EFFECT.HeatSize = 1
EFFECT.Color = Color(255, 192, 64)
EFFECT.ColorSprites = false
EFFECT.UseDynamicLight = true

local AddVel = Vector()
local ang

function EFFECT:Init(data)
	self.WeaponEnt = data:GetEntity()
	if not IsValid(self.WeaponEnt) then return end
	self.Attachment = data:GetAttachment()
	self.Position = self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)

	if IsValid(self.WeaponEnt:GetOwner()) then
		if self.WeaponEnt:GetOwner() == LocalPlayer() then
			if self.WeaponEnt:GetOwner():ShouldDrawLocalPlayer() then
				ang = self.WeaponEnt:GetOwner():EyeAngles()
				ang:Normalize()
				--ang.p = math.max(math.min(ang.p,55),-55)
				self.Forward = ang:Forward()
			else
				self.WeaponEnt = self.WeaponEnt.OwnerViewModel
			end
			--ang.p = math.max(math.min(ang.p,55),-55)
		else
			ang = self.WeaponEnt:GetOwner():EyeAngles()
			ang:Normalize()
			self.Forward = ang:Forward()
		end
	end

	self.Forward = self.Forward or data:GetNormal()
	self.Angle = self.Forward:Angle()
	self.Right = self.Angle:Right()
	self.vOffset = self.Position
	local dir = self.Forward
	local ownerent = self.WeaponEnt:GetOwner()

	if not IsValid(ownerent) then
		ownerent = LocalPlayer()
	end

	AddVel = ownerent:GetVelocity()
	self.vOffset = self.Position
	AddVel = AddVel * 0.05
	local dot = dir:GetNormalized():Dot(GetViewEntity():EyeAngles():Forward())
	local halofac = math.abs(dot)
	local epos = ownerent:EyePos()

	local dlight
	if self.UseDynamicLight then
		dlight = DynamicLight(ownerent:EntIndex())

		if (dlight) then
			dlight.pos = epos + ownerent:EyeAngles():Forward() * self.vOffset:Distance(epos) --self.vOffset - ownerent:EyeAngles():Right() * 5 + 1.05 * ownerent:GetVelocity() * FrameTime()
			dlight.r = self.Color.r
			dlight.g = self.Color.g
			dlight.b = self.Color.b
			dlight.brightness = 4.5
			dlight.decay = 200 / self.Life
			dlight.size = self.FlashSize * 96
			dlight.dietime = CurTime() + self.Life
		end
	end

	self.Dist = self.vOffset:Distance(epos)
	self.DLight = dlight
	self.DieTime = CurTime() + self.Life
	self.OwnerEnt = ownerent
	local emitter = ParticleEmitter(self.vOffset)
	local sval = 1 - math.random(0, 1) * 2

	if self.WeaponEnt.XTick == nil then
		self.WeaponEnt.XTick = 0
	end

	self.WeaponEnt.XTick = 1 - self.WeaponEnt.XTick

	if self.WeaponEnt.XTick == 1 and self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.XFlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(3 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			particle:SetEndSize(15 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
		--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
		--particle:SetEndSize( 0 )
	elseif self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			particle:SetStartSize(2 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			particle:SetEndSize(6 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
	end

	local flashCount = math.Round(self.FlashSize * 8)

	for i = 1, flashCount do
		local particle = emitter:Add(self.ColorSprites and "effects/scotchmuzzleflashw" or "effects/scotchmuzzleflash4", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 300 * (0.2 + (i / flashCount) * 0.8) * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(math.Rand(128, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			local szsc = 1 + (flashCount - i) * math.pow(1 / flashCount * 0.9,0.8)
			particle:SetStartSize(1.25 * math.Rand(1, 1.5) * szsc * self.FlashSize)
			particle:SetEndSize(6 * math.Rand(0.75, 1) * szsc * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	for _ = 1, flashCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 6 * self.FlashSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 1)
			particle:SetStartAlpha(math.Rand(40, 140))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(2 * math.Rand(1, 1.5) * self.FlashSize)
			particle:SetEndSize(20 * math.Rand(0.5, 1) * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(30, 60)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			--TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	local glowCount = math.ceil(self.FlashSize * 3)

	for i = 1, glowCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + dir * 0.9 * i)

		if (particle) then
			--particle:SetVelocity(dir * 32 )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(255 * (1 - halofac))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.2 * self.FlashSize)
			particle:SetEndSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.6 * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	if TFA.GetMZFSmokeEnabled() then
		local smokeCount = math.ceil(self.SmokeSize * 6)

		for _ = 0, smokeCount do
			local particle = emitter:Add("particles/smokey", self.vOffset + dir * math.Rand(3, 14))

			if (particle) then
				particle:SetVelocity(VectorRand() * 10 * self.SmokeSize + dir * math.Rand(35, 50) * self.SmokeSize + 1.05 * AddVel)
				particle:SetDieTime(math.Rand(0.6, 1) * self.Life * 6)
				particle:SetStartAlpha(math.Rand(12, 24))
				particle:SetEndAlpha(0)
				particle:SetStartSize(math.Rand(5, 7) * self.SmokeSize)
				particle:SetEndSize(math.Rand(15, 20) * self.SmokeSize)
				particle:SetRoll(math.rad(math.Rand(0, 360)))
				particle:SetRollDelta(math.Rand(-0.8, 0.8))
				particle:SetLighting(true)
				particle:SetAirResistance(20)
				particle:SetGravity(Vector(0, 0, 60))
				particle:SetColor(255, 255, 255)
			end
		end
	end

	local sparkcount = math.Round(math.random(8, 12) * self.SparkSize)

	for _ = 0, sparkcount do
		local particle = emitter:Add("effects/yellowflare", self.Position)

		if (particle) then
			particle:SetVelocity( VectorRand() * 30 * self.SparkSize)
			particle:SetVelocity(particle:GetVelocity() + 1.15 * AddVel )
			particle:SetVelocity( particle:GetVelocity() + dir * math.Rand(80, 100) * (1-math.abs(math.max(particle:GetVelocity():GetNormalized():Dot(-dir),0))) * self.SparkSize )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * math.Rand(0.9,1.1))
			particle:SetStartAlpha(255)
			particle:SetEndAlpha(0)
			particle:SetStartSize(0.6)
			particle:SetEndSize(1)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetGravity(vector_origin)
			particle:SetAirResistance(1)
			particle:SetStartLength(0.1)
			particle:SetEndLength(0.05)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, math.random(192, 225), math.random(140, 192))
			end

			particle:SetVelocityScale(true)
			local sl = self.SparkSize

			particle:SetThinkFunction(function(pa)
				math.randomseed(SysTime())
				local spd = pa:GetVelocity():Length()*12
				pa.ranvel = pa.ranvel or VectorRand() * spd
				pa.ranvel:Add(VectorRand() * spd * math.sqrt(FrameTime()))
				pa:SetVelocity(pa:GetVelocity() + pa.ranvel * sl * FrameTime() )
				pa:SetNextThink(CurTime())
			end)

			particle:SetNextThink(CurTime() + 0.01)
		end
	end

	if TFA.GetGasEnabled() then
		local particle = emitter:Add("sprites/heatwave", self.vOffset + dir*2)

		if (particle) then
			particle:SetVelocity(dir * 25 * self.HeatSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life)
			particle:SetStartAlpha(math.Rand(200, 225))
			particle:SetEndAlpha(0)
			particle:SetStartSize(math.Rand(3, 5) * self.HeatSize)
			particle:SetEndSize(math.Rand(8, 12) * self.HeatSize)
			particle:SetRoll(math.Rand(0, 360))
			particle:SetRollDelta(math.Rand(-2, 2))
			particle:SetAirResistance(5)
			particle:SetGravity(Vector(0, 0, 40))
			particle:SetColor(255, 255, 255)
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	if CurTime() > (self.DieTime or 0) then
		return false
	elseif self.DLight and IsValid(self.OwnerEnt) then
		self.DLight.pos = self.OwnerEnt:EyePos() + self.OwnerEnt:EyeAngles():Forward() * self.Dist
	end

	return true
end

function EFFECT:Render()
end
--PATH lua/effects/tfa_muzzleflash_fubar_blu/init.lua:
return gluapack()()
--PATH lua/effects/tfa_muzzleflash_fubar_blu/init.lua:
local function rvec(vec)
	vec.x=math.Round(vec.x)
	vec.y=math.Round(vec.y)
	vec.z=math.Round(vec.z)
	return vec
end

local blankvec = Vector(0,0,0)

local function partfunc(self)
	if IsValid(self.FollowEnt) then
		if self.Att then
			local angpos = self.FollowEnt:GetAttachment(self.Att)
			if angpos and angpos.Pos then
				self:SetPos(angpos.Pos)
				self:SetNextThink(CurTime())
			end
		end
	end
end
				
function EFFECT:Init( data )
	
	self.StartPacket = data:GetStart()
	self.Attachment = data:GetAttachment()

	local AddVel = vector_origin
	
	if LocalPlayer then
		if IsValid(LocalPlayer()) then
			AddVel = LocalPlayer():GetVelocity()
		end
	end
	
	if AddVel == vector_origin then
		AddVel = Entity(1):GetVelocity()
	end
	
	self.Position = data:GetOrigin()
	self.Forward = data:GetNormal()
	self.Angle = self.Forward:Angle()
	self.Right = self.Angle:Right()
	
	local wepent = Entity(math.Round(self.StartPacket.z))
	
	if IsValid(wepent) then
		if wepent.IsFirstPerson and !wepent:IsFirstPerson() then
			data:SetEntity(wepent)
			self.Position = blankvec
		end
	end
	
	local ownerent = player.GetByID(math.Round(self.StartPacket.x))
	local serverside = false
	if math.Round(self.StartPacket.y)==1 then
		serverside = true
	end
	
	local ent = data:GetEntity()
	
	if serverside then
		if IsValid(ownerent) then
			if LocalPlayer() == ownerent then
				return
			end
			ent = ownerent:GetActiveWeapon()
			AddVel = ownerent:GetVelocity()
		end
	end
	
	if (!self.Position) or ( rvec(self.Position) == blankvec ) then
		self.WeaponEnt = data:GetEntity()
		self.Attachment = data:GetAttachment()
		if self.WeaponEnt and IsValid(self.WeaponEnt) then
			local rpos = self.WeaponEnt:GetAttachment(self.Attachment)
			if rpos and rpos.Pos then
				self.Position = rpos.Pos
				if data:GetNormal()==vector_origin then
					self.Forward = rpos.Ang:Up()
					self.Angle = self.Forward:Angle()
					self.Right = self.Angle:Right()
				end
			end
		end
	end
	
	self.vOffset = self.Position
	dir = self.Forward
	AddVel = AddVel * 0.05

	if IsValid(ent) then
		dlight = DynamicLight(ent:EntIndex())
	else
		dlight = DynamicLight(0)	
	end
	
    if (dlight) then
        dlight.Pos              = self.Position + dir * 1 - dir:Angle():Right()*5
        dlight.r                = 16
        dlight.g                = 64
        dlight.b                = 255
        dlight.Brightness = 6.0
        dlight.size     = 110
        dlight.DieTime  = CurTime() + 0.03
   end
	
	ParticleEffectAttach("tfa_muzzle_fubar_blu",PATTACH_POINT_FOLLOW,ent,data:GetAttachment())
	
	--[[
	local emitter = ParticleEmitter( self.vOffset )
		for i=0, 6 do
			local particle = emitter:Add( "particles/flamelet"..math.random(1,5), self.vOffset + (dir * 1.7 * i))
			if (particle) then
				particle:SetVelocity((dir * 19 * i) + 1.05 * AddVel )
				particle:SetLifeTime( 0 )
				particle:SetDieTime( 0.1 )
				particle:SetStartAlpha( math.Rand( 200, 255 ) )
				particle:SetEndAlpha( 0 )
				particle:SetStartSize( math.max(7 - 0.65 * i,1) )
				particle:SetEndSize( 0 )
				particle:SetRoll( math.Rand(0, 360) )
				particle:SetRollDelta( math.Rand(-40, 40) )
				particle:SetColor( 255 , 218 , 97 )
				particle:SetLighting(false)
				particle.FollowEnt = data:GetEntity()
				particle.Att = self.Attachment
				particle:SetThinkFunction( partfunc )
				particle:SetNextThink(CurTime())
			end
		end
		
		for i=0, 5 do
		
			local particle = emitter:Add( "particles/smokey", self.vOffset + dir * math.Rand(6, 10 ))
			if (particle) then
				particle:SetVelocity(VectorRand() * 5 + dir * math.Rand(27,33) + 1.05 * AddVel )
				particle:SetLifeTime( 0 )
				particle:SetDieTime( math.Rand( 0.5, 0.5 ) )
				particle:SetStartAlpha( math.Rand( 5, 15 ) )
				particle:SetEndAlpha( 0 )
				particle:SetStartSize( math.Rand(8,10) )
				particle:SetEndSize( math.Rand(2,5) )
				particle:SetRoll( math.Rand(0, 360) )
				particle:SetRollDelta( math.Rand(-0.8, 0.8) )
				
				particle:SetAirResistance( 10 ) 
 				 
 				particle:SetGravity( Vector( 0, 0, 60 ) ) 
				
				particle:SetColor( 255 , 255 , 255 ) 
			end
			
		end
		
		if GetTFAGasEnabled() then
			for i=0, 2 do
				local particle = emitter:Add( "sprites/heatwave", self.vOffset + (dir * i) )
				if (particle) then
					particle:SetVelocity((dir * 25 * i) + 1.05 * AddVel )
					particle:SetLifeTime( 0 )
					particle:SetDieTime( math.Rand( 0.05, 0.15 ) )
					particle:SetStartAlpha( math.Rand( 200, 225 ) )
					particle:SetEndAlpha( 0 )
					particle:SetStartSize( math.Rand(3,5) )
					particle:SetEndSize( math.Rand(8,10) )
					particle:SetRoll( math.Rand(0, 360) )
					particle:SetRollDelta( math.Rand(-2, 2) )
					
					particle:SetAirResistance( 5 ) 
					
					particle.FollowEnt = data:GetEntity()
					particle.Att = self.Attachment
					particle:SetThinkFunction( partfunc )
					 
					particle:SetGravity( Vector( 0, 0, 40 ) ) 
					
					particle:SetColor( 255 , 255 , 255 ) 
				end
			end
		end
		
	emitter:Finish() 
	]]--
end 

function EFFECT:Think( )
	return false
end

function EFFECT:Render()
end

 
--PATH lua/tfa/muzzleflash_base.lua:
return gluapack()()
--PATH lua/effects/tfa_muzzleflash_incendiary/init.lua:
return gluapack()()
--PATH lua/effects/tfa_muzzleflash_incendiary/init.lua:
include("tfa/muzzleflash_base.lua")

EFFECT.Life = 0.125
EFFECT.XFlashSize = 0
EFFECT.FlashSize = 1
EFFECT.SmokeSize = 2
EFFECT.SparkSize = 2
EFFECT.HeatSize = 2
EFFECT.Color = Color(255, 128, 64)
EFFECT.ColorSprites = false

--PATH lua/effects/tfa_muzzleflash_pistol/init.lua:
include("tfa/muzzleflash_base.lua")

EFFECT.Life = 0.07
EFFECT.XFlashSize = 0.5
EFFECT.FlashSize = 0.8
EFFECT.SmokeSize = 1
EFFECT.SparkSize = 1
EFFECT.HeatSize = 1
EFFECT.Color = Color(255, 225, 128)
EFFECT.ColorSprites = false

--PATH lua/effects/tfa_muzzleflash_revolver/init.lua:
return gluapack()()
--PATH lua/effects/tfa_muzzleflash_silenced/init.lua:
include("tfa/muzzleflash_base.lua")

EFFECT.Life = 0.1
EFFECT.XFlashSize = 0
EFFECT.FlashSize = 0.1
EFFECT.SmokeSize = 2
EFFECT.SparkSize = 1
EFFECT.HeatSize = 1
EFFECT.Color = Color(255, 225, 128)
EFFECT.ColorSprites = false
EFFECT.UseDynamicLight = false


--PATH lua/tfa/muzzleflash_base.lua:
return gluapack()()
--PATH lua/effects/tfa_tracer_fubar_blu/init.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/effects/tracer_orange/init.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/effects/tracer_yellow/init.lua:
EFFECT.Mat = Material("effects/laser_tracer")
EFFECT.Speed = 1024 * 15
EFFECT.TracerLength = 5

local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()

	if IsValid(self.WeaponEnt) and self.WeaponEnt.GetMuzzleAttachment then
		self.Attachment = self.WeaponEnt:GetMuzzleAttachment()
	end

	-- Keep the start and end pos - we're going to interpolate between them
    self.StartPos = self:GetTracerShootPos(self.Position, self.WeaponEnt, self.Attachment)
    self.EndPos = data:GetOrigin()

	self.Dir = self.EndPos - self.StartPos

	self:SetRenderBoundsWS( self.StartPos, self.EndPos )

    self.StartTime = 0
	self.TracerTime = math.min( 1, self.StartPos:Distance( self.EndPos ) / 7000 ) * 1
	self.Length = 0.33

	-- Die when it reaches its target
	self.DieTime = CurTime() + self.TracerTime

	local Dir = self.Dir:GetNormalized()

	local emitter = ParticleEmitter( self.StartPos, false )

	for i = 0, 5 do
		local particle = emitter:Add( Materials[math.random(1,table.Count( Materials ))], self.StartPos )

		local rCol = 255

		if particle then
			particle:SetVelocity( Dir * math.Rand(100,500) + VectorRand() * math.Rand(0,10) )
			particle:SetDieTime( math.Rand(0.05,0.2) )
			particle:SetAirResistance( math.Rand(50,100) )
			particle:SetStartAlpha( 5 )
			particle:SetStartSize( 2 )
			particle:SetEndSize( math.Rand(5,10) )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( rCol, rCol, rCol )
			particle:SetGravity( VectorRand() * 200 + Vector(0,0, -500) )
			particle:SetCollide( false )
		end
	end

	emitter:Finish()
end

local hitColor = Vector(218, 165, 18)

function EFFECT:Think()
    self.StartTime = self.StartTime + FrameTime()

	if CurTime() > self.DieTime then
		local effectdata = EffectData()
			effectdata:SetStart( hitColor )
			effectdata:SetOrigin( self.EndPos )
			effectdata:SetNormal( self.Dir:GetNormalized() )
		util.Effect( "laser_hit", effectdata )

		return false
	end

	return true
end

local mainColor = Color(218, 165, 18)
local innerColor = Color(192, 192, 192)

function EFFECT:Render()
	local fDelta = ( self.DieTime - CurTime() ) / self.TracerTime
	fDelta = math.Clamp( fDelta, 0, 1 ) ^ 2

	local sinWave = math.sin( fDelta * math.pi )

	local Pos1 = self.EndPos - self.Dir * ( fDelta - sinWave * self.Length )

	render.SetMaterial( self.Mat )
	render.DrawBeam( Pos1,
		self.EndPos - self.Dir * ( fDelta + sinWave * self.Length ),
        8, 5, 0, mainColor
    )

	render.DrawBeam( Pos1,
		self.EndPos - self.Dir * ( fDelta + sinWave * self.Length ),
        2, 5, 0, innerColor
    )

    if --[[DynamicTracer:GetBool()]] true then
    local spawn = util.CRC(tostring(self:GetPos()))
    local dlight = DynamicLight(self:EntIndex() + spawn)
    local endDistance = self.Speed * self.StartTime
    local endPos = self.StartPos + self.Dir:GetNormalized() * endDistance

    if (dlight) then
        dlight.pos = endPos
        dlight.r = 218
        dlight.g = 165
        dlight.b = 18
        dlight.brightness = 7
        dlight.Decay = 1000
        dlight.Size = 500
        dlight.DieTime = CurTime() + 3
    end
end
end
--PATH lua/effects/vp_dissolve.lua:
local mGlobal = Material( "models/elemental/vapored" )
local cmd_sunbeams = GetConVar( "sfw_fx_individualsunbeams" )

-- local mGlobalRaw = file.Read( "materials/models/elemental/vapored.vmt", "GAME" )
-- mGlobalRaw:lower()

-- local tMaterialCache = mGlobal:GetKeyValues()
-- local tMaterialReference = {}

-- for key, value in pairs( tMaterialCache ) do
	-- if !( string.find( mGlobalRaw, key:lower(), 1, false ) ) then
		-- print("filtering out", key )
		-- continue
	-- end
	
	-- tMaterialReference[ key ] = value
-- end

function EFFECT:Init( data )

	self.Time = 1.05
	self.LifeTime = CurTime() + self.Time

	self.mOverlay = mGlobal --CreateMaterial( "vapor_dissolve_overlay", "VertexLitGeneric", tMaterialReference )

	local ent = data:GetEntity()
	
	if ( !IsValid( ent ) ) then return end
	if ( !ent:GetModel() ) then return end
	
	self.ParentEntity = ent
	
	self:SetModel( ent:GetModel() )	
	self:SetPos( ent:GetPos() )
	self:SetAngles( ent:GetAngles() )
	self:SetParent( ent )
	self.Flags = data:GetFlags()
	
	self.ParentEntity.RenderOverride = self.RenderParent
	self.ParentEntity.SpawnEffect = self
	
	if ( GetConVar( "sfw_fx_particles" ):GetBool() ) then
		ParticleEffectAttach( "vp_dissolve", PATTACH_ABSORIGIN_FOLLOW, ent, -1 )
	else
		ParticleEffectAttach( "vp_dissolve_cheap", PATTACH_ABSORIGIN_FOLLOW, ent, -1 ) 
	end
	
	self.ParentEntity:SetMaterial( "dev/hide" )

end

function EFFECT:Think( )

	if ( !IsValid( self.ParentEntity ) ) then return false end
	
	local PPos = self.ParentEntity:GetPos()
	self:SetPos( PPos + (EyePos() - PPos):GetNormal() )
	
	if ( self.LifeTime > CurTime() ) then
		return true
	end
	
	self.ParentEntity.RenderOverride = nil
	self.ParentEntity.SpawnEffect = nil
			
	return false
	
end

function EFFECT:Render()

	if ( self.Flags == 8 ) then
		self:RenderOverlay( self.ParentEntity )
	end

end

function EFFECT:RenderParent()
	
	self.SpawnEffect:RenderOverlay( self )

end

function EFFECT:RenderOverlay( entity )

	render.SetColorModulation( 1, 2, 3 )
	render.MaterialOverride( self.mOverlay )
	
	local fFraction = ( self.LifeTime - 0.1 - CurTime() ) / self.Time
	local fColFrac = ( fFraction - 0.5 ) * 2
	
	fFraction = math.Clamp( fFraction, 0, 1 )
	fColFrac =  math.Clamp( fColFrac, 0, 1 )
	
	local fFractionReversed = ( 1 - fFraction )

	local EyeNormal = entity:GetPos() - EyePos()
	local Distance = EyeNormal:Length()
	EyeNormal:Normalize()
	
	local Pos = EyePos() + EyeNormal * Distance * 0.01

--	local iFrames = math.Clamp( 24 - ( 24 * fColFrac ), 1, 24 )
--	iFrames = math.Round( iFrames, 0 )
	
--	self.mOverlay:SetInt( "$frame", iFrames )
	
	local evilmath = 2 * 2 ^ ( fFractionReversed * 2 - fFraction )
	evilmath = evilmath * 0.125

	self.mOverlay:SetFloat( "$FleshBorderWidth", 6 * evilmath )
	self.mOverlay:SetFloat( "$FleshBorderSoftness", 0.5 * fFraction )
	self.mOverlay:SetFloat( "$FleshGlossBrightness", 12 * fFractionReversed )
	self.mOverlay:SetVector( "$selfillumtint", Vector( 2.2, 2.3, 4 ) * fFraction )

	local mn, mx = entity:GetRenderBounds()
	local Up = (mx-mn):GetNormal()
	local Bottom =  entity:EyePos() + mn
	local Top = entity:EyePos() + mx

	local Lerped = LerpVector( fFraction, Top, Bottom )
	
	local normal = Up 
	local distance = normal:Dot( Lerped )
	
	local mLight = DynamicLight( self.ParentEntity:EntIndex() * -1 )
	if ( mLight ) then 
		mLight.pos = Lerped
		mLight.r = 0
		mLight.g = 20
		mLight.b = 255
		mLight.brightness = 3 * fFraction
		mLight.Size = 180 + 400 * fFraction
		mLight.Decay = 1024
		mLight.Style = 1
		mLight.DieTime = CurTime() + 1
	end
	
	entity:DrawModel()
	
	render.SetColorModulation( 1, 1, 1 )
	render.MaterialOverride()
	
	local bSunBeams = cmd_sunbeams:GetBool()
	if ( !bSunBeams ) then return end 
	
	local screen = Lerped
	local vNormal = screen - EyePos()
	
	local dot = ( vNormal:Dot( EyeVector() ) - 0.8 ) * 5
	if ( dot <= 0 ) then return end

	screen = screen + ( vNormal * 16384 )
	screen = screen:ToScreen()
	
	local glowSize = math.max( 0.05 * fFraction, 0.001 ) -- math.max( mn:Length() * 0.0005, 0.01 )
	
	local w, h = ScrW(), ScrH()

	local glowX, glowY = screen.x, screen.y
	DrawSunbeams( 0.85, 0.4 * ( 1 - fFraction ), glowSize, glowX / w, glowY / h )
	
end
--PATH lua/effects/zulu_tracer.lua:
return gluapack()()
--PATH lua/effects/zulu_tracer_noattach.lua:
AddCSLuaFile()
AddCSLuaFile( "effects/fxbase.lua" )
include( "effects/fxbase.lua" )

EFFECT.ParticleCast = false
EFFECT.Time = nil
EFFECT.Speed = 12000
EFFECT.Length	= 64

function EFFECT:Init( data )

	self.StartPos = data:GetStart() --self:GetTracerOrigin( data )
	self.EndPos = data:GetOrigin()
	self.Parent = data:GetEntity()
	
	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos )

	local diff = ( self.EndPos - self.StartPos )
	
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	
	if ( !self.LifeTime ) then
		self.LifeTime = ( diff:Length() + self.Length ) / self.Speed
	else
		self.LifeTime = CurTime() + self.LifeTime
	end
	
end

function EFFECT:Think()
	
	if ( !self.ParticleCast ) then
		util.ParticleTracerEx( 
			"_wraithgun_beam", 	--particle system
			self.StartPos, 	--startpos
			self.EndPos, 	--endpos
			false, 			--do whiz effect
			-1, 			--entity index
			-1  			--attachment
		)
		
		self.ParticleCast = true
	end
	
	if ( !self.Time ) then	
		self.Time = self.LifeTime + CurTime()
	end
	
	local Fraction = math.max( 0, ( self.Time - CurTime() ) / self.LifeTime )
	
	local difforigin = self.EndPos - self.StartPos
	local lightorigin = self.StartPos + ( difforigin * ( 1 - Fraction ) ) 

	local mLight = DynamicLight( -1 )
	if ( mLight ) then
		mLight.pos = lightorigin
		mLight.r = 120
		mLight.g = 130
		mLight.b = 255
		mLight.brightness = 4 * Fraction
		mLight.Size = 180 + 200 * Fraction
		mLight.Decay = 1024
		mLight.Style = 1
		mLight.DieTime = CurTime() + 1
	end

	return ( self.Time > CurTime() )
	
end

--PATH lua/prone/cl_prone.lua:
hook.Add("EntityNetworkedVarChanged", "prone.DetectProneStateChanges", function(ply, nwVarName, oldVal, newVal)
	if nwVarName == "prone.AnimationState" then
		if newVal == PRONE_GETTINGDOWN or newVal == PRONE_GETTINGUP then
			ply:AnimRestartMainSequence()
			ply:SetCycle(0)
			ply:SetPlaybackRate(1)
		elseif newVal == PRONE_NOTINPRONE then
			ply:ResetHull()
		end
	end
end)

-- Called to inform the player that they can't get up.
local lastGetUpPrintTime = 0		-- Last time a print was made.
local getUpWarningPrintDelay = 2	-- Time it takes before allowing another print.
function prone.CantGetUpWarning()
	local ct = CurTime()

	if lastGetUpPrintTime < ct then
		chat.AddText(Color(210, 10, 10), "There is not enough room to get up here.")
		lastGetUpPrintTime = ct + getUpWarningPrintDelay
	end
end

--------------------
-- prone.SetImpulse
--------------------
-- Desc:		This is the proper, predicted, way to toggle prone.
-- Arg One:		CUserCmd object, to set the impulse on.
function prone.SetImpulse(cmd)
	cmd:SetImpulse(PRONE_IMPULSE)
end

-----------------
-- prone.Request
-----------------
-- Desc:		Begins sending a prone impulse to the server.
local SendImpulse = false
function prone.Request()
	SendImpulse = true
end
concommand.Add("prone", function()
	prone.Request()
end)

-------------------
-- Bind key handler
-------------------
local function boolToNumString(bool)
	return bool and "1" or "0"
end
local bindkey_enabled = CreateClientConVar("prone_bindkey_enabled", boolToNumString(prone.Config.DefaultBindKey_Enabled), true, false, "Disable this to disable the prone bind key from working.")
local bindkey_key = CreateClientConVar("prone_bindkey_key", tostring(prone.Config.DefaultBindKey), true, false, "Don't directly change this convar. Use the command prone_config.")
local bindkey_doubletap = CreateClientConVar("prone_bindkey_doubletap", boolToNumString(prone.Config.DefaultBindKey_DoubleTap), true, false, "Enable to make them double tap the bind key to go prone.")
local jumptogetup = CreateClientConVar("prone_jumptogetup", "1", boolToNumString(prone.Config.DefaultJumpToGetUp), false, "If enabled you can press the jump key to get up.")
local jumptogetup_doubletap = CreateClientConVar("prone_jumptogetup_doubletap", boolToNumString(prone.Config.DefaultJumpToGetUp_DoubleTap), true, false, "If enabled you must double press jump to get up.")

local key_waspressed = false
local last_prone_request = 0
local doubletap_shouldsend = true
local doubletap_keypress_resettime = false
hook.Add("CreateMove", "prone.ReadBindKeys", function(cmd)
	local ply = LocalPlayer()
	if not IsValid(ply) then
		return
	end

	if SendImpulse then
		prone.SetImpulse(cmd)

		if cmd:TickCount() ~= 0 then
			SendImpulse = false
		end
	end

	if (system.IsLinux() or system.HasFocus()) and bindkey_enabled:GetBool() and ply:OnGround() and not vgui.GetKeyboardFocus() and not gui.IsGameUIVisible() and not gui.IsConsoleVisible() then
		if input.IsKeyDown(bindkey_key:GetInt()) then
			key_waspressed = true

			-- If doubletap is enabled they have a second to double click the bind key.
			doubletap_keypress_resettime = CurTime() + .66
		else
			if key_waspressed then
				if last_prone_request < CurTime() then
					doubletap_shouldsend = not doubletap_shouldsend

					if not bindkey_doubletap:GetBool() or doubletap_shouldsend then
						prone.Request()

						last_prone_request = CurTime() + 1.25
					end
				end

				key_waspressed = false
			end
		end

		if doubletap_keypress_resettime ~= false and doubletap_keypress_resettime < CurTime() then
			doubletap_keypress_resettime = false
			doubletap_shouldsend = true
		end
	end
end)

-- If they enable jump to get up then read that here.
local jumptogetup_presstime = 0
hook.Add("KeyPress", "Prone.JumpToGetUp", function(ply, key)
	if IsFirstTimePredicted() and ply == LocalPlayer() and ply:IsProne() and jumptogetup:GetBool() and key == IN_JUMP then
		if not jumptogetup_doubletap:GetBool() then
			prone.Request()
		else
			if jumptogetup_presstime > CurTime() then
				prone.Request()
			else
				jumptogetup_presstime = CurTime() + 1.25
			end
		end
	end
end)

-------------------
-- View Transitions
-------------------

-- Addons should use the prone.ShouldChangeCalcView and prone.ShouldChangeCalcViewModelView hooks instead of this cvar.
local enabledViewTransitions = CreateClientConVar("prone_disabletransitions", "0", true, false, "Disables the slide down and up of the get up/down animations.")

do
	local headPos, headAng
	hook.Add("CalcView", "prone.ViewTransitions", function(ply, pos)
		if ply ~= LocalPlayer() or enabledViewTransitions:GetBool() then
			return
		end

		local result = hook.Run("prone.ShouldChangeCalcView", ply)
		if result == false then
			return
		end

		local proneState = ply:GetProneAnimationState()
		if proneState ~= PRONE_GETTINGDOWN and proneState ~= PRONE_GETTINGUP then
			headPos = nil
			return
		end

		headPos, headAng = ply:GetBonePosition(ply:LookupBone("ValveBiped.Bip01_Head1"))
		return {origin = headPos}
	end)
	hook.Add("CalcViewModelView", "prone.ViewTransitions", function()
		local localply = LocalPlayer()

		if enabledViewTransitions:GetBool() then
			return
		end

		local result = hook.Run("prone.ShouldChangeCalcViewModelView", localply)
		if result == false then
			return
		end

		local proneState = localply:GetProneAnimationState()
		if proneState ~= PRONE_GETTINGDOWN and proneState ~= PRONE_GETTINGUP then
			headPos = nil
			return
		end

		if headPos then
			return headPos
		end
	end)
end

-------------------------------------------------
-- A derma panel for configuring your prone keys.
-------------------------------------------------
concommand.Add("prone_config", function()
	local frame = vgui.Create("DFrame")
	frame:SetSize(200, 210)
	frame:Center()
	frame:SetTitle("Prone Mod Config")
	frame:MakePopup()

	local bindkey_enabled_checkbox = vgui.Create("DCheckBoxLabel", frame)
	bindkey_enabled_checkbox:SetText("Enable bind key")
	bindkey_enabled_checkbox:SetPos(10, 30)
	bindkey_enabled_checkbox:SetValue(bindkey_enabled:GetInt())
	function bindkey_enabled_checkbox:OnChange(bool)
		RunConsoleCommand("prone_bindkey_enabled", bool and "1" or "0")
	end

	local bindkey_double_checkbox = vgui.Create("DCheckBoxLabel", frame)
	bindkey_double_checkbox:SetText("Double tap bind key")
	bindkey_double_checkbox:SetPos(10, 50)
	bindkey_double_checkbox:SetValue(bindkey_doubletap:GetInt())
	function bindkey_double_checkbox:OnChange(bool)
		RunConsoleCommand("prone_bindkey_doubletap", bool and "1" or "0")
	end

	local jump_getup = vgui.Create("DCheckBoxLabel", frame)
	jump_getup:SetText("Press jump to get up")
	jump_getup:SetPos(10, 70)
	jump_getup:SetValue(jumptogetup:GetInt())
	function jump_getup:OnChange(bool)
		RunConsoleCommand("prone_jumptogetup", bool and "1" or "0")
	end

	local jump_getup_double = vgui.Create("DCheckBoxLabel", frame)
	jump_getup_double:SetText("Double tap jump to get up")
	jump_getup_double:SetPos(10, 90)
	jump_getup_double:SetValue(jumptogetup_doubletap:GetInt())
	function jump_getup_double:OnChange(bool)
		RunConsoleCommand("prone_jumptogetup_doubletap", bool and "1" or "0")
	end

	local bindkey_desc = vgui.Create("DLabel", frame)
	bindkey_desc:SetText("Prone bind key:")
	bindkey_desc:SizeToContents()
	bindkey_desc:SetPos(10, 110)

	local binder = vgui.Create("DBinder", frame)
	binder:SetSize(150, 50)
	binder:SetPos(25, 130)
	binder:CenterHorizontal()
	binder:SetValue(bindkey_key:GetInt())
	function binder:OnChange(num)
		RunConsoleCommand("prone_bindkey_key", num)
		self:SetText(input.GetKeyName(num))
	end

	local resetbutton = vgui.Create("DButton", frame)
	resetbutton:SetText("Reset settings")
	resetbutton:SetPos(0, 190)
	resetbutton:SetSize(200, 20)
	function resetbutton:DoClick()
		RunConsoleCommand("prone_bindkey_enabled", "1")
		RunConsoleCommand("prone_bindkey_key", tostring(prone.Config.DefaultBindKey))
		RunConsoleCommand("prone_bindkey_doubletap", "1")
		RunConsoleCommand("prone_jumptogetup", "1")
		RunConsoleCommand("prone_jumptogetup_doubletap", "1")
		frame:Remove()
	end
end)
--PATH lua/rd_claim_boards/sh_config_wrapper.lua:
-- Battalions (Sequential)
RDV.CLAIMBOARDS.CFG.BATTALIONS_S = RDV.CLAIMBOARDS.CFG.BATTALIONS_S or {}
-- Battalions (Non Sequential)
RDV.CLAIMBOARDS.CFG.BATTALIONS = RDV.CLAIMBOARDS.CFG.BATTALIONS or {}
-- Battalion Count
RDV.CLAIMBOARDS.CFG.BATTALION_C = RDV.CLAIMBOARDS.CFG.BATTALION_C or 0

local CATS = {}

function RDV.CLAIMBOARDS.GetBattalionCount()
    return RDV.CLAIMBOARDS.CFG.BATTALION_C
end

function RDV.CLAIMBOARDS.GetBattalions()
    return RDV.CLAIMBOARDS.CFG.BATTALIONS_S
end

function RDV.CLAIMBOARDS.Config()
    RDV.CLAIMBOARDS.CORE = {
        AddBattalion = function(self, NAME, JOBS, COL)
            if !NAME or !istable(JOBS) then return end

            local LIST = {Jobs = {}, SJobs = {}, Col = Color(255,255,255)}
            
            for i = 1, #JOBS do
                if !CATS[JOBS[i]] then
                    LIST.Jobs[JOBS[i]] = true
                    continue
                end

                if !RPExtraTeams then continue end

                for k, v in ipairs(RPExtraTeams) do
                    if v.category == JOBS[i] then
                        LIST.Jobs[v.name] = true

                        table.insert(LIST.SJobs, v.name)
                    end
                end
            end

            if COL then
                LIST.Col = COL
            end
            
            LIST.SJobs = JOBS
        
            LIST.NAME = NAME

            local KEY = table.insert(RDV.CLAIMBOARDS.CFG.BATTALIONS_S, LIST)

            LIST.KEY = KEY
            
            RDV.CLAIMBOARDS.CFG.BATTALIONS[NAME] = LIST

            RDV.CLAIMBOARDS.CFG.BATTALION_C = RDV.CLAIMBOARDS.CFG.BATTALION_C + 1
        end,
        SetCustomHeaders = function(self, bool)
            RDV.CLAIMBOARDS.CFG.CustomHeaders = bool
        end,
        SetDefaultHeaders = function(self, tab)
            RDV.CLAIMBOARDS.CFG.DefaultHeaders = tab
        end,
        SetAdmins = function(self, tab)
            if !istable(tab) then return end

            local LIST = {}

            for i = 1, #tab do
                LIST[tab[i]] = true
            end

            RDV.CLAIMBOARDS.CFG.ADMINS = LIST
        end,
        SetArrest = function(self, val)
            RDV.CLAIMBOARDS.CFG.ARREST = val
        end,
        SetDeath = function(self, val)
            RDV.CLAIMBOARDS.CFG.DEATH = val
        end,
        SetPrefix = function(self, prefix)
            if !prefix or !prefix.Appension or !prefix.Color then 
                return 
            end

            RDV.CLAIMBOARDS.CFG.Prefix = prefix
        end,
        SetCommands = function(self, com)
            if !com.Unclaim or !com.UnclaimAll then
                return
            end

            RDV.CLAIMBOARDS.CFG.COMMANDS = com
        end,
    }

    return RDV.CLAIMBOARDS.CORE
end

if RPExtraTeams then
    for k, v in ipairs(RPExtraTeams) do
        CATS[v.category] = true
    end
end
--PATH lua/rd_claim_boards/core/languages/sh_ru.lua:
return gluapack()()
--PATH lua/rd_claim_boards/core/languages/sh_ru.lua:
RDV.LIBRARY.AddLang("ru", {
    CLAIMB_GetForceUnclaimed = "      %s.",
    CLAIMB_YouForceUnclaimed = "   ,   %s.",
    CLAIMB_YouUnclaimed = "      .",
    CLAIMB_RateLimited = "   , !",
    CLAIMB_UpdateSuccessful = "   .",
    CLAIMB_UpdateNoPerms = "      .",
    CLAIMB_OpenLabel = "",
    CLAIMB_ClosedLabel = "",
    CLAIMB_CBLabel = "  ",
    CLAIMB_SaveLabel = "",
    CLAIMB_moreInformation = ",   .",
    CLAIMB_battalionLabel = "",
    CLAIMB_unclaimLabel = "",
    CLAIMB_statusLabel = "",
    CLAIMB_claimedByLabel = "",
    CLAIMB_openToAll = "  ",
    CLAIMB_AOSOnEntry = "AOS  ",
    CLAIMB_UnclaimedLabel = "",
})
--PATH addons/[tfres] datapad/lua/tfres/datapad/apps/zezw.lua:
return gluapack()()
--PATH addons/[tfres] datapad/lua/tfres/datapad/apps/test.lua:
local APP = {}

APP.Name = "Test"                   -- Nazwa
APP.Restricted = true               -- Dosownie nic nie zmienia
APP.Category = {}     -- Kategoria joba ktra ma dostp
APP.Rank = true                     -- Czy jest od oficera

APP.Derma = function(parrent)
    local x,y = parrent:GetWide(),parrent:GetTall()
	local pan = vgui.Create("DPanel",parrent)
    pan:SetSize(x,y)
    pan:Center()
    pan:SetBackgroundColor(Color(0,0,0))
    local label = vgui.Create("DLabel",pan)
	label:SetText("To jest strona testowa")
	label:SizeToContents()
	label:Center()
    label:SetTextColor(Color(0,0,0))

end

return APP
--PATH addons/[tfres] datapad/lua/tfres/datapad/apps/zezw.lua:
return gluapack()()
--PATH lua/tfres/library/sh_core_lib.lua:

local global = tfres.Global

if SERVER then
    util.AddNetworkString("tfres::Networking")
end

function hex2rgb(hex)
    hex = hex:gsub("#","")
    return Color(tonumber("0x"..hex:sub(1,2)), tonumber("0x"..hex:sub(3,4)), tonumber("0x"..hex:sub(5,6)))
end

function global:SaveData(addon,name,data)
    if !isstring(data) and istable(data) then
        data = util.TableToJSON(data)
    end
    file.CreateDir("tfres/" .. addon)
    file.Write("tfres/" .. addon .. "/" .. name .. ".json",data)
end

function global:LoadData(addon,name)
    local data = file.Read("tfres/" .. addon .. "/" .. name .. ".json","DATA")
    if !data then
        return
    end
    data = util.JSONToTable(data) or data
    return data
end

function global:SQL(query)
    sql.Query(query)
end

local function compressdata(data)
    data = util.TableToJSON(data)
    local compressed_message = util.Compress( data )
	local bytes_amount = #compressed_message
    return compressed_message,bytes_amount
end

function global:NetSend(name,info,ply)
    local data, bytes = compressdata(info)
    net.Start("tfres::Networking")
        net.WriteString(name)
        net.WriteUInt( bytes, 16 )
        net.WriteData( data, bytes )
    net.Send(ply)
end

function global:NetBroadcast(name,info,ply)
    local data, bytes = compressdata(info)
    net.Start("tfres::Networking")
        net.WriteString(name)
        net.WriteUInt( bytes, 16 )
        net.WriteData( data, bytes )
    net.Broadcast()
end


function global:NetServer(name,info)
    local data, bytes = compressdata(info)
    net.Start("tfres::Networking")
        net.WriteString(name)
        net.WriteUInt( bytes, 16 )
        net.WriteData( data, bytes )
    net.SendToServer()
end

global.Networks = global.Networks or {}
global.NetworksBypass = global.NetworksBypass or {}

function global:RegisterNetwork(name,func,bypass)  
    global.Networks[name] = func
    if bypass then
        global.NetworksBypass[name] = true 
    end
end


function global:GetNet(name)
    return global.Networks[name] ~= nil
end

function global:Log(addon, ...)
    print("[tfres]",addon, ...)
end

function global:Error(addon, ...)
    local traceback = debug.traceback()
    print("[tfres]",addon, ... , traceback)
end

net.Receive("tfres::Networking",function(len,ply)
    local name = net.ReadString()
    if SERVER then
        if !global.NetworksBypass[name] then
            if !ply then return end
            if ply.tfres_net and ply.tfres_net > CurTime() then return end
            ply.tfres_net = CurTime() + 0.1
        else
        end
    end
    
    if !global:GetNet(name) then global:Error("Networking","No network name:" .. name .. " in realm: " .. (SERVER and "SERVER" or "CLIENT")) return end
    local bytes = net.ReadUInt(16)
    local compress = net.ReadData(bytes)
    local data = util.Decompress(compress)
    local tbl = util.JSONToTable(data)
    global.Networks[name](tbl,ply)
end)