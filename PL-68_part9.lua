--Stealed clientside server code by exechack.cc
--Hostname: [PL] [PixelMod] PelugeRP SWRP | .gg/pixelmod - Part 9/10 - 06/04/2025


--PATH lua/arccw/shared/arccw_kraken_sw_effects.lua:
game.AddParticles( "particles/dc17_muzzleparticle.pcf" )
game.AddParticles( "particles/dc17_muzzleparticlemasita.pcf" )
game.AddParticles( "particles/muzzleflashes_test.pcf" )
game.AddParticles( "particles/muzzleflashes_test_b.pcf" )

game.AddParticles("particles/muzzleflash_dragonsbreath.pcf")
PrecacheParticleSystem("muzzleflash_dragonbreath")
game.AddParticles("particles/uo_explosions_fas2.pcf")
PrecacheParticleSystem("explosion_HE_m79_fas2")
PrecacheParticleSystem("explosion_he_grenade_fas2")
PrecacheParticleSystem("explosion_HE_claymore_fas2")
PrecacheParticleSystem("explosion_grenade_fas2")

-- Some Explosives
game.AddParticles( "particles/swbf/astw2_swbf_explosions.pcf" )
game.AddParticles( "particles/swbf/astw2_star_wars_battlefront_muzzle_effects.pcf" )
game.AddParticles( "particles/swbf/astw2_swbf_flamethrower.pcf" )
game.AddParticles( "particles/swbf/astw2_swbf_rocket_fx.pcf" )
game.AddParticles( "particles/swbf/astw2_swbf_impact_fx.pcf" )
game.AddParticles( "particles/swbf/astw2_swbf_pickup_effects.pcf" )
game.AddParticles( "particles/swbf/astw2_swbf_tracer.pcf" )
game.AddParticles( "particles/swbf/swbf_commandpost_fx.pcf" )

--EXPLOSION EFFECTS
PrecacheParticleSystem( "astw2_swbf_explosion_cis_launcher" )
PrecacheParticleSystem( "astw2_swbf_explosion_cis_rocket" )
PrecacheParticleSystem( "astw2_swbf_explosion_cis_wristrocket" )
PrecacheParticleSystem( "astw2_swbf_explosion_concussion_grenade" )
PrecacheParticleSystem( "astw2_swbf_explosion_emp" )
PrecacheParticleSystem( "astw2_swbf_explosion_imp_launcher" )
PrecacheParticleSystem( "astw2_swbf_explosion_imp_rocket" )
PrecacheParticleSystem( "astw2_swbf_explosion_reb_rocket" )
PrecacheParticleSystem( "astw2_swbf_explosion_rep_rocket" )
PrecacheParticleSystem( "astw2_swbf_explosion_thermal_detonator" )
PrecacheParticleSystem( "astw2_swbf_explosion_thermal_detonator2" )
PrecacheParticleSystem( "astw2_swbf_explosion_rep_emp_rocket" )
PrecacheParticleSystem( "astw2_swbf_explosion_death_droid" )

--MUZZLE EFFECTS
PrecacheParticleSystem( "astw2_swbf_muzzle_tor_rifle" )
PrecacheParticleSystem( "astw2_swbf_muzzle_sth_rifle" )
PrecacheParticleSystem( "astw2_swbf_muzzle_cis_blaster" )
PrecacheParticleSystem( "astw2_swbf_muzzle_cis_pistol" )
PrecacheParticleSystem( "astw2_swbf_muzzle_cis_sniper" )
PrecacheParticleSystem( "astw2_swbf_muzzle_cis_bulldog" )
PrecacheParticleSystem( "astw2_swbf_muzzle_imp_blaster" )
PrecacheParticleSystem( "astw2_swbf_muzzle_imp_pistol" )
PrecacheParticleSystem( "astw2_swbf_muzzle_imp_shotgun" )
PrecacheParticleSystem( "astw2_swbf_muzzle_imp_sniper" )
PrecacheParticleSystem( "astw2_swbf_muzzle_reb_blaster" )
PrecacheParticleSystem( "astw2_swbf_muzzle_reb_pistol" )
PrecacheParticleSystem( "astw2_swbf_muzzle_reb_sniper" )
PrecacheParticleSystem( "astw2_swbf_muzzle_reb_shotgun" )
PrecacheParticleSystem( "astw2_swbf_muzzle_reb_bowcaster" )
PrecacheParticleSystem( "astw2_swbf_muzzle_rep_blaster" )
PrecacheParticleSystem( "astw2_swbf_muzzle_rep_pistol" )
PrecacheParticleSystem( "astw2_swbf_muzzle_rep_sniper" )
PrecacheParticleSystem( "astw2_swbf_muzzle_tus_rifle" )

--TRAIL EFFECTS
PrecacheParticleSystem( "astw2_swbf_rocket_fx_generic" )
PrecacheParticleSystem( "astw2_swbf_rocket_fx_all" )
PrecacheParticleSystem( "astw2_swbf_rocket_fx_cis" )
PrecacheParticleSystem( "astw2_swbf_rocket_fx_imp" )
PrecacheParticleSystem( "astw2_swbf_rocket_fx_rep" )

--IMPACT EFFECTS
PrecacheParticleSystem( "astw2_swbf_blaster_bolt_impact" )
PrecacheParticleSystem( "astw2_swbf_blaster_bolt_impact_yellow" )
PrecacheParticleSystem( "astw2_swbf_blaster_bolt_impact_heavy" )

--MISC EFFECTS
PrecacheParticleSystem( "astw2_swbf_flamethrower_fx" )
PrecacheParticleSystem( "astw2_swbf_pickup_ammo" )
PrecacheParticleSystem( "astw2_swbf_pickup_bacta" )
PrecacheParticleSystem( "astw2_swbf_pickup_dual" )
PrecacheParticleSystem( "astw2_swbf_pickup_energy" )
PrecacheParticleSystem( "astw2_swbf_pickup_rage" )
PrecacheParticleSystem( "astw2_swbf_pickup_rally" )

--COMMAND POST EFFECTS
PrecacheParticleSystem( "swbf_command_post_ally" )
PrecacheParticleSystem( "swbf_command_post_friendly" )
PrecacheParticleSystem( "swbf_command_post_enemy" )
PrecacheParticleSystem( "swbf_command_post_neutral" )
PrecacheParticleSystem( "swbf_command_post_unoccupied" )

--TRACER EFFECTS
PrecacheParticleSystem( "astw2_swbf_tracer_arc_caster" )
PrecacheParticleSystem( "astw2_swbf_tracer_blaster_blue" )
PrecacheParticleSystem( "astw2_swbf_tracer_blaster_green" )
PrecacheParticleSystem( "astw2_swbf_tracer_blaster_orange" )
PrecacheParticleSystem( "astw2_swbf_tracer_blaster_purple" )
PrecacheParticleSystem( "astw2_swbf_tracer_blaster_red" )
PrecacheParticleSystem( "astw2_swbf_tracer_blaster_yellow" )
PrecacheParticleSystem( "astw2_swbf_tracer_sniper_blue" )
PrecacheParticleSystem( "astw2_swbf_tracer_sniper_crimson" )
PrecacheParticleSystem( "astw2_swbf_tracer_sniper_green" )
PrecacheParticleSystem( "astw2_swbf_tracer_sniper_red" )
PrecacheParticleSystem( "astw2_swbf_tracer_sniper_yellow" )
PrecacheParticleSystem( "astw2_swbf_tracer_sniper_teal" )
-- Kraken's
game.AddParticles( "particles/BlasterBlue.pcf" )
game.AddParticles( "particles/BlasterGreen.pcf" )
game.AddParticles( "particles/BlasterPurple.pcf" )
game.AddParticles( "particles/BlasterRed.pcf" )
game.AddParticles( "particles/BlasterYellow.pcf" )

-- Sci-Fi
game.AddParticles( "particles/bloomtest.pcf" )
game.AddParticles( "particles/boxglove_fx.pcf" )
game.AddParticles( "particles/corrosion_fx.pcf" )
game.AddParticles( "particles/cryo_fx.pcf" )
game.AddParticles( "particles/darkling_fx.pcf" )
game.AddParticles( "particles/fallingstar_fx.pcf" )
game.AddParticles( "particles/gravrifle_fx.pcf" )
game.AddParticles( "particles/hellfire_fx.pcf" )
game.AddParticles( "particles/hwave_fx.pcf" )
game.AddParticles( "particles/lanka_fx.pcf" )
game.AddParticles( "particles/ngen_fx.pcf" )
game.AddParticles( "particles/nio_fx.pcf" )
game.AddParticles( "particles/pulsar_fx.pcf" )
game.AddParticles( "particles/pulsar_fx_red.pcf" )
game.AddParticles( "particles/spectra_fx.pcf" )
game.AddParticles( "particles/stinger_fx.pcf" )
game.AddParticles( "particles/storm_fx.pcf" )
game.AddParticles( "particles/tbolt_fx_reborn.pcf" )
game.AddParticles( "particles/trace_fx.pcf" )
game.AddParticles( "particles/umbra_fx.pcf" )
game.AddParticles( "particles/underscore_fx.pcf" )
game.AddParticles( "particles/vapor_fx.pcf" )
game.AddParticles( "particles/veho_fx.pcf" )
game.AddParticles( "particles/shitsonfireyo.pcf" )


-- Particles Sci-Fi
PrecacheParticleSystem( "shitsonfireyo" )

-- Particle systems --
PrecacheParticleSystem( "_ghost_upgrade" )
PrecacheParticleSystem( "_wraithgun_muzzle" )
PrecacheParticleSystem( "_wraithgun_tracer" )
PrecacheParticleSystem( "_wraithgun_hit" )
PrecacheParticleSystem( "_wrath_hit_sparks" )
PrecacheParticleSystem( "_wrath_tracer" )
PrecacheParticleSystem( "aeblast_muzzle" )
PrecacheParticleSystem( "aquamarine_charge" )
PrecacheParticleSystem( "aquamarine_tracer" )
PrecacheParticleSystem( "asa6_hit" )
PrecacheParticleSystem( "asa6_tracer" )
PrecacheParticleSystem( "astra_beam" )
PrecacheParticleSystem( "astra_beam_lightning_1" )
PrecacheParticleSystem( "astra_bolt" )
PrecacheParticleSystem( "astra_hit" )
PrecacheParticleSystem( "astra_hit_heavy" )
PrecacheParticleSystem( "astra_muzzle" )
PrecacheParticleSystem( "astra_muzzle_heavy" )
PrecacheParticleSystem( "astra_muzzle_lightning" )
PrecacheParticleSystem( "blade_glow" )
PrecacheParticleSystem( "blade_hit" )
PrecacheParticleSystem( "bloom_beam_0" )
PrecacheParticleSystem( "bloom_halo_0" )
PrecacheParticleSystem( "celest_dissolve" )
PrecacheParticleSystem( "celest_wrath_core" )
PrecacheParticleSystem( "celest_wrath_core_charging" )
PrecacheParticleSystem( "celest_wrath_dissolve" )
PrecacheParticleSystem( "celest_wrath_explode" )
PrecacheParticleSystem( "celest_wrath_hit" )
PrecacheParticleSystem( "celest_wrath_muzzle" )
PrecacheParticleSystem( "celest_wrath_nade" )
PrecacheParticleSystem( "celest_wrath_pulse" )
PrecacheParticleSystem( "celest_wrath_tracer" )
PrecacheParticleSystem( "corro_muzzle" )
PrecacheParticleSystem( "corro_proc" )
PrecacheParticleSystem( "corro_tracer" )
PrecacheParticleSystem( "corruptor_impact" )
PrecacheParticleSystem( "corruptor_muzzle" )
PrecacheParticleSystem( "corruptor_tracer" )
PrecacheParticleSystem( "crsv_dissolve" )
PrecacheParticleSystem( "crsv_dissolve_cheap" )
PrecacheParticleSystem( "cryo_explosion_large" )
PrecacheParticleSystem( "cryo_ragshatter" )
PrecacheParticleSystem( "cryo_ragshatter_frags" )
PrecacheParticleSystem( "drake_hit" )
PrecacheParticleSystem( "drake_muzzle" )
PrecacheParticleSystem( "drake_tracer" )
PrecacheParticleSystem( "ember_hit_entity" )
PrecacheParticleSystem( "ember_hit_nothing" )
PrecacheParticleSystem( "ember_hit_world" )
PrecacheParticleSystem( "ember_laser" )
PrecacheParticleSystem( "ember_laser_underwater" )
PrecacheParticleSystem( "ember_muzzle" )
PrecacheParticleSystem( "ember_muzzle_turnoff" )
PrecacheParticleSystem( "ember_muzzle_turnon" )
PrecacheParticleSystem( "ember_underwater_bubbles" )
PrecacheParticleSystem( "emg_tracer" )
PrecacheParticleSystem( "emg_hit" )
PrecacheParticleSystem( "eml_dps_shock" )
PrecacheParticleSystem( "eml_generic_blast" )
PrecacheParticleSystem( "eml_generic_crsv" )
PrecacheParticleSystem( "eml_generic_crsv_splat" )
PrecacheParticleSystem( "eml_generic_cryo" )
PrecacheParticleSystem( "eml_generic_cryo_ground" )
PrecacheParticleSystem( "eml_generic_heat" )
PrecacheParticleSystem( "eml_generic_shock" )
PrecacheParticleSystem( "eml_generic_cryo_small" )
PrecacheParticleSystem( "eml_muzzle_cryo" )
PrecacheParticleSystem( "eml_tracer_cryo" )
PrecacheParticleSystem( "event_onwater_remove" )
PrecacheParticleSystem( "fathom_blast" )
PrecacheParticleSystem( "fathom_cloud" )
PrecacheParticleSystem( "fathom_death" )
PrecacheParticleSystem( "fathom_muzzle" )
PrecacheParticleSystem( "flare_halo_0" )
PrecacheParticleSystem( "flathr" )
PrecacheParticleSystem( "fstar_charge" )
PrecacheParticleSystem( "fstar_hit" )
PrecacheParticleSystem( "fstar_freeze_catch" )
PrecacheParticleSystem( "fstar_freeze_release" )
PrecacheParticleSystem( "fstar_muzzle" )
PrecacheParticleSystem( "fstar_muzzle_altfire" )
PrecacheParticleSystem( "fstar_tracer" )
PrecacheParticleSystem( "fstar_secfire" )
PrecacheParticleSystem( "fstar_sfire_hit_swave" )
PrecacheParticleSystem( "gravrifle_blast" )
PrecacheParticleSystem( "gravrifle_blast_parentable" )
PrecacheParticleSystem( "gravrifle_blast_smoke" )
PrecacheParticleSystem( "gravrifle_charge" )
PrecacheParticleSystem( "gravrifle_dissolve" )
PrecacheParticleSystem( "gravrifle_hit" )
PrecacheParticleSystem( "gravrifle_nade" )
PrecacheParticleSystem( "gravrifle_tracer" )
PrecacheParticleSystem( "grinder_muzzle" )
PrecacheParticleSystem( "gunsmoke" )
PrecacheParticleSystem( "hellfire_muzzle" )
PrecacheParticleSystem( "hellfire_muzzle_smoke" )
PrecacheParticleSystem( "hellfire_tracer" )
PrecacheParticleSystem( "hellfire_blast" )
PrecacheParticleSystem( "hellnade_fragments" )
PrecacheParticleSystem( "hellnade_heat" )
PrecacheParticleSystem( "hellnade_shockwave" )
PrecacheParticleSystem( "hornet_blast" )
PrecacheParticleSystem( "hornet_blast_charged" )
PrecacheParticleSystem( "hornet_blast_cheap" )
PrecacheParticleSystem( "hornet_trail" )
PrecacheParticleSystem( "hornet_trail_cheaper" )
PrecacheParticleSystem( "hwave_charge" )
PrecacheParticleSystem( "hwave_charged" )
PrecacheParticleSystem( "hwave_debris_small" )
PrecacheParticleSystem( "hwave_hit" )
PrecacheParticleSystem( "hwave_hit_fleks" )
PrecacheParticleSystem( "hwave_muzzle" )
PrecacheParticleSystem( "hwave_muzzle_embers" )
PrecacheParticleSystem( "hwave_muzzle_finish" )
PrecacheParticleSystem( "hwave_tracer" )
PrecacheParticleSystem( "hwave_tracer_cheap" )
PrecacheParticleSystem( "ice_crystals" )
PrecacheParticleSystem( "ice_crystals_2" )
PrecacheParticleSystem( "ice_crystals_3" )
PrecacheParticleSystem( "ice_freezing" )
PrecacheParticleSystem( "ice_freezing_shortlt" )
PrecacheParticleSystem( "ice_freezing_release" )
PrecacheParticleSystem( "ice_impact" )
PrecacheParticleSystem( "ice_impact_heavy" )
PrecacheParticleSystem( "ice_tracer_smoke" )
PrecacheParticleSystem( "ice_muzzle_small" )
PrecacheParticleSystem( "ice_sfire_charge" )
PrecacheParticleSystem( "item_flare" )
PrecacheParticleSystem( "item_orb_battery" )
PrecacheParticleSystem( "item_orb_health" )
PrecacheParticleSystem( "item_orb_upgrade" )
PrecacheParticleSystem( "item_pfx_battery" )
PrecacheParticleSystem( "item_pfx_health" )
PrecacheParticleSystem( "item_pfx_upgrade" )
PrecacheParticleSystem( "item_pkin_amb" )
PrecacheParticleSystem( "item_pkin_break" )
PrecacheParticleSystem( "item_upg_break" )
--PrecacheParticleSystem( "jotunn_bolt_break" )
--PrecacheParticleSystem( "jotunn_bolt_impact" )
PrecacheParticleSystem( "jotunn_charge_init" )
PrecacheParticleSystem( "jotunn_charging" )
PrecacheParticleSystem( "jotunn_muzzle" )
PrecacheParticleSystem( "lanka_hit_riv" )
PrecacheParticleSystem( "lapis_vent" )
PrecacheParticleSystem( "meridian_tracer" )
PrecacheParticleSystem( "moby_hit" )
PrecacheParticleSystem( "moby_muzzle" )
PrecacheParticleSystem( "moby_tracer" )
PrecacheParticleSystem( "ngen_core_playerfx" )
PrecacheParticleSystem( "ngen_core_small" )
PrecacheParticleSystem( "ngen_core_small_cheap" )
PrecacheParticleSystem( "ngen_explosion" )
PrecacheParticleSystem( "ngen_explosion_energy" )
PrecacheParticleSystem( "ngen_hit" )
PrecacheParticleSystem( "ngen_hit_lgtning" )
PrecacheParticleSystem( "ngen_hit_sparks_2" )
PrecacheParticleSystem( "ngen_missile_smoke" )
PrecacheParticleSystem( "ngen_muzzle" )
PrecacheParticleSystem( "ngen_muzzle_2" )
PrecacheParticleSystem( "ngen_muzzle_3" )
PrecacheParticleSystem( "ngen_muzzle_4" )
PrecacheParticleSystem( "ngen_muzzle_4_shotgun" )
PrecacheParticleSystem( "ngen_muzzle_4_simplified" )
PrecacheParticleSystem( "ngen_muzzle_charge" )
PrecacheParticleSystem( "ngen_muzzle_embers_overheat" )
PrecacheParticleSystem( "ngen_tracer" )
PrecacheParticleSystem( "nio_beam" )
PrecacheParticleSystem( "nio_muzzle" )
PrecacheParticleSystem( "nio_impact" )
PrecacheParticleSystem( "nio_dissolve" )
PrecacheParticleSystem( "nio_dissolve_cheap" )
PrecacheParticleSystem( "nio_charge" )
PrecacheParticleSystem( "nrg_hit" )
PrecacheParticleSystem( "nrg_tracer" )
PrecacheParticleSystem( "onwater_bubbles" )
PrecacheParticleSystem( "panda_charge" )
PrecacheParticleSystem( "panda_charged" )
PrecacheParticleSystem( "panda_hit" )
PrecacheParticleSystem( "panda_muzzle" )
PrecacheParticleSystem( "panda_tracer" )
PrecacheParticleSystem( "pele_hit")
PrecacheParticleSystem( "pele_muzzle")
PrecacheParticleSystem( "pele_tracer")
PrecacheParticleSystem( "pest_muzzle" )
PrecacheParticleSystem( "pest_hit" )
PrecacheParticleSystem( "phasma_absorb" )
PrecacheParticleSystem( "phasma_blade_enable" )
PrecacheParticleSystem( "phasma_blade_enable_sparks" )
PrecacheParticleSystem( "phasma_blade_disable" )
PrecacheParticleSystem( "phasma_blade_sparks" )
PrecacheParticleSystem( "phasma_blast" )
PrecacheParticleSystem( "phasma_core" )
PrecacheParticleSystem( "phasma_initial_mist" )
PrecacheParticleSystem( "phasma_trail" )
PrecacheParticleSystem( "phasma_w_blade_enable" )
PrecacheParticleSystem( "phasma_w_initial_mist" )
PrecacheParticleSystem( "phasma_w_trail" )
PrecacheParticleSystem( "prisma_core" )
PrecacheParticleSystem( "pulsar_charge" )
PrecacheParticleSystem( "pulsar_charge_fail" )
PrecacheParticleSystem( "pulsar_beam_red" )
PrecacheParticleSystem( "pulsar_hit_weak" )
PrecacheParticleSystem( "pulsar_muzzle" )
PrecacheParticleSystem( "pyro_dissolve" )
PrecacheParticleSystem( "pyro_dissolve_ash_0" )
PrecacheParticleSystem( "pyro_dissolve_ash_3" )
PrecacheParticleSystem( "pyro_dissolve_cheap" )
PrecacheParticleSystem( "pyro_dissolve_ash_cheap" )
PrecacheParticleSystem( "pyro_explode" )
PrecacheParticleSystem( "pyro_nade" )
PrecacheParticleSystem( "saphyre_absorb" )
PrecacheParticleSystem( "saphyre_hit" )
PrecacheParticleSystem( "saphyre_hit_fleks" )
PrecacheParticleSystem( "saphyre_muzzle" )
PrecacheParticleSystem( "saphyre_muzzle_embers" )
PrecacheParticleSystem( "saphyre_muzzle_flames_0a" )
PrecacheParticleSystem( "saphyre_tracer" )
PrecacheParticleSystem( "sentinel_hit" )
PrecacheParticleSystem( "sentinel_muzzle" )
PrecacheParticleSystem( "seraph_hit" )
PrecacheParticleSystem( "seraph_muzzle" )
PrecacheParticleSystem( "seraph_tracer" )
PrecacheParticleSystem( "shk_hit" )
PrecacheParticleSystem( "shk_muzzle" )
PrecacheParticleSystem( "shk_tracer" )
PrecacheParticleSystem( "spectra_blast" )
PrecacheParticleSystem( "spectra_charging" )
PrecacheParticleSystem( "spectra_core" )
PrecacheParticleSystem( "spectra_core_crsv" )
PrecacheParticleSystem( "spectra_core_evensmaller" )
PrecacheParticleSystem( "spectra_core_fire" )
PrecacheParticleSystem( "spectra_core_ice" )
PrecacheParticleSystem( "spectra_core_small" )
PrecacheParticleSystem( "spectra_explode" )
PrecacheParticleSystem( "spectra_fmchange" )
PrecacheParticleSystem( "spectra_hit" )
PrecacheParticleSystem( "spectra_muzzle" )
PrecacheParticleSystem( "spectra_muzzle_2" )
PrecacheParticleSystem( "spectra_muzzle_old" )
PrecacheParticleSystem( "spectra_muzzle_overheat" )
PrecacheParticleSystem( "spectra_tracer" )
PrecacheParticleSystem( "spr_explosion" )
PrecacheParticleSystem( "spr_explosion_large" )
PrecacheParticleSystem( "spr_explosion_large_flash_noz" )
PrecacheParticleSystem( "spr_explosion_large_smoshroom" )
PrecacheParticleSystem( "spr_hit" )
PrecacheParticleSystem( "spr_muzzle" )
PrecacheParticleSystem( "spr_nade_tick" )
PrecacheParticleSystem( "spr_tracer" )
PrecacheParticleSystem( "stinger_muzzle" )
PrecacheParticleSystem( "stinger_core_small" )
PrecacheParticleSystem( "stinger_explode" )
PrecacheParticleSystem( "stinger_muzzle_2" )
PrecacheParticleSystem( "stinger_core_small_2" )
PrecacheParticleSystem( "stinger_explode_2" )
PrecacheParticleSystem( "supra_c_hit" )
PrecacheParticleSystem( "supra_charging" )
PrecacheParticleSystem( "supra_mirv" )
PrecacheParticleSystem( "supra_nade" )
PrecacheParticleSystem( "supra_p_hit" )
PrecacheParticleSystem( "storm_muzzle" )
PrecacheParticleSystem( "storm_muzzle_cheap" )
PrecacheParticleSystem( "tbolt_muzzle" )
PrecacheParticleSystem( "tbolt_hit" )
PrecacheParticleSystem( "tbolt_tracer" )
PrecacheParticleSystem( "tbolt_tracer_cheap" )
PrecacheParticleSystem( "trace_muzzle" )
PrecacheParticleSystem( "trace_trace" )
PrecacheParticleSystem( "trace_projectile" )
PrecacheParticleSystem( "trace_projectile_pws" )
PrecacheParticleSystem( "trace_sparks_new" )
PrecacheParticleSystem( "umbra_ammo" )
PrecacheParticleSystem( "umbra_ammo_pickup" )
PrecacheParticleSystem( "umbra_ammo_consumed" )
PrecacheParticleSystem( "umbra_cast" )
PrecacheParticleSystem( "umbra_core" )
PrecacheParticleSystem( "umbra_darken" )
PrecacheParticleSystem( "umbra_darken_stackup" )
PrecacheParticleSystem( "umbra_hit" )
PrecacheParticleSystem( "umbra_muzzle" )
PrecacheParticleSystem( "umbra_muzzle_embers" )
PrecacheParticleSystem( "umbra_muzzle_vented" )
PrecacheParticleSystem( "umbra_ptru" )
PrecacheParticleSystem( "umbra_shutdown_flecks" )
PrecacheParticleSystem( "umbra_succumb" )
PrecacheParticleSystem( "vapor" )
PrecacheParticleSystem( "vapor_cheap" )
PrecacheParticleSystem( "vapor_charge_glow" )
PrecacheParticleSystem( "vapor_charge_secfire" )
PrecacheParticleSystem( "vapor_collapse" )
PrecacheParticleSystem( "vapor_collapse_cheap" )
PrecacheParticleSystem( "vapor_muzzle" )
PrecacheParticleSystem( "vapor_muzzle_altfire" )
PrecacheParticleSystem( "vapor_muzzle_evensmaller" )
PrecacheParticleSystem( "vapor_muzzle_small" )
PrecacheParticleSystem( "vectra_charged" )
PrecacheParticleSystem( "vectra_charging" )
PrecacheParticleSystem( "vp_binary_muzzle" )
PrecacheParticleSystem( "vp_binary_tracer" )
PrecacheParticleSystem( "vp_dissolve" )
PrecacheParticleSystem( "vp_dissolve_cheap" )
PrecacheParticleSystem( "vsecfire_shockwave" )
PrecacheParticleSystem( "vh_muzzle" )
PrecacheParticleSystem( "vh_tracer_old" )
PrecacheParticleSystem( "vh_hit" )
PrecacheParticleSystem( "xplo_tracer" )
PrecacheParticleSystem( "xplo_hit" )
PrecacheParticleSystem( "xplo_hit_cheap" )
PrecacheParticleSystem( "zeala_charged" )
PrecacheParticleSystem( "zeala_charging" )
PrecacheParticleSystem( "zeala_burst" )
PrecacheParticleSystem( "zeala_muzzle" )
PrecacheParticleSystem( "zeala_nade" )
PrecacheParticleSystem( "zeala_vortex" )
PrecacheParticleSystem( "zeala_vortex_cheap" )

PrecacheParticleSystem("wpn_muzzleflash_mgl_FULL")
PrecacheParticleSystem("tfa_apex_tracer_anvil")
PrecacheParticleSystem("tfa_apex_tracer_ar")
PrecacheParticleSystem("tfa_apex_tracer_hmg")
PrecacheParticleSystem("tfa_apex_tracer_hmg_rampage")
PrecacheParticleSystem("tfa_apex_tracer_pistol")
PrecacheParticleSystem("tfa_apex_tracer_shotgun")
PrecacheParticleSystem("tfa_apex_tracer_smg")
PrecacheParticleSystem("tfa_apex_tracer_sniper")
PrecacheParticleSystem("tfa_apex_lstar_explode_core")
PrecacheParticleSystem("tfa_apex_arcstar_explode")
PrecacheParticleSystem("tfa_apex_frag_explode")
PrecacheParticleSystem("grenade_final")
PrecacheParticleSystem("tfa_apex_arcstar_impact")
PrecacheParticleSystem("tfa_apex_bocek_impact")
PrecacheParticleSystem("tfa_apex_bocek_trail")
PrecacheParticleSystem("tfa_apex_bullet_trail")
PrecacheParticleSystem("tfa_apex_bullet_energy_trail")
PrecacheParticleSystem("tfa_apex_bullet_sent_trail")

-- Kraken's
PrecacheParticleSystem( "blaster_muzzle_blue" )
PrecacheParticleSystem( "blaster_muzzle_red" )
PrecacheParticleSystem( "blaster_muzzle_green" )
PrecacheParticleSystem( "blaster_muzzle_purple" )

-- Other's
PrecacheParticleSystem( "wpn_muzzleflash_dc17_red" )
PrecacheParticleSystem( "wpn_muzzleflash_dc17_purple" )
PrecacheParticleSystem( "wpn_muzzleflash_dc17_green" )
PrecacheParticleSystem( "wpn_muzzleflash_dc17_orange" )
PrecacheParticleSystem( "wpn_muzzleflash_dc17" )
PrecacheParticleSystem( "wpn_muzzleflash_dc17_red" )
PrecacheParticleSystem( "muzzleflash_smg" )
PrecacheParticleSystem( "muzzleflash_smg_bizon" )
PrecacheParticleSystem( "muzzleflash_shotgun" )
PrecacheParticleSystem( "muzzleflash_slug" )
PrecacheParticleSystem( "muzzleflash_slug_flame" )
PrecacheParticleSystem( "muzzleflash_pistol" )
PrecacheParticleSystem( "muzzleflash_pistol_cleric" )
PrecacheParticleSystem( "muzzleflash_pistol_deagle" )
PrecacheParticleSystem( "muzzleflash_suppressed" )
PrecacheParticleSystem( "muzzleflash_mp5" )
PrecacheParticleSystem( "muzzleflash_MINIMI" )
PrecacheParticleSystem( "muzzleflash_m79" )
PrecacheParticleSystem( "muzzleflash_m14" )
PrecacheParticleSystem( "muzzleflash_ak47" )
PrecacheParticleSystem( "muzzleflash_ak74" )
PrecacheParticleSystem( "muzzleflash_m82" )
PrecacheParticleSystem( "muzzleflash_m3" )
PrecacheParticleSystem( "muzzleflash_famas" )
PrecacheParticleSystem( "muzzleflash_g3" )
PrecacheParticleSystem( "muzzleflash_1" )
PrecacheParticleSystem( "muzzleflash_3" )
PrecacheParticleSystem( "muzzleflash_4" )
PrecacheParticleSystem( "muzzleflash_5" )
PrecacheParticleSystem( "muzzleflash_6" )
--PATH lua/arccw/shared/sh_effects.lua:
return gluapack()()
--PATH lua/arccw/shared/sh_effects.lua:
game.AddParticles( "particles/muzzleflashes_test.pcf" )
game.AddParticles( "particles/muzzleflashes_test_b.pcf" )
PrecacheParticleSystem( "muzzleflash_smg" )
PrecacheParticleSystem( "muzzleflash_smg_bizon" )
PrecacheParticleSystem( "muzzleflash_shotgun" )
PrecacheParticleSystem( "muzzleflash_slug" )
PrecacheParticleSystem( "muzzleflash_slug_flame" )
PrecacheParticleSystem( "muzzleflash_pistol" )
PrecacheParticleSystem( "muzzleflash_pistol_cleric" )
PrecacheParticleSystem( "muzzleflash_pistol_deagle" )
PrecacheParticleSystem( "muzzleflash_suppressed" )
PrecacheParticleSystem( "muzzleflash_mp5" )
PrecacheParticleSystem( "muzzleflash_MINIMI" )
PrecacheParticleSystem( "muzzleflash_m79" )
PrecacheParticleSystem( "muzzleflash_m14" )
PrecacheParticleSystem( "muzzleflash_ak47" )
PrecacheParticleSystem( "muzzleflash_ak74" )
PrecacheParticleSystem( "muzzleflash_m82" )
PrecacheParticleSystem( "muzzleflash_m3" )
PrecacheParticleSystem( "muzzleflash_famas" )
PrecacheParticleSystem( "muzzleflash_g3" )
PrecacheParticleSystem( "muzzleflash_1" )
PrecacheParticleSystem( "muzzleflash_3" )
PrecacheParticleSystem( "muzzleflash_4" )
PrecacheParticleSystem( "muzzleflash_5" )
PrecacheParticleSystem( "muzzleflash_6" )
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/15a_foregrip.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/15s_mag_drum.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/15s_stock_extended.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/15s_stock_skeleton.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/15s_stock_skeleton.lua:
att.PrintName = "15a Skeleton Stock"
att.Description = "Extended Stock for DC-15s. Improves the recoil."
att.Icon = Material("interfaz/armas/swrp_att_dlt20_stock.png")
att.Desc_Pros = {}
att.Desc_Cons = {}
att.Desc_Neutrals = {}

att.Slot = {"15s_stock"}
att.ActivateElements = {"15s_stock_extended"}

att.Mult_Damage = 1
att.Mult_SightTime = 1.15
att.Mult_Sway = 0.75
att.Mult_SpeedMult = 1.1
att.Mult_DrawTime = 1
att.Mult_HolsterTime = 1.05
att.Mult_HipDispersion = 0.75
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/arccw/shared/attachments/a180_grip.lua:
att.PrintName = "Tactical Grip"
att.Icon = Material("entities/kraken/sops/atts/a180grip.png", "mips smooth")
att.Description = "Improves recoil at the cost of aim time."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.AutoStats = true
att.Slot = "a180_grip"
att.ActivateElements = {"a180_grip"}

att.Mult_Recoil = 0.9
att.Mult_SightTime = 1.1
att.Mult_MoveSpeed = 0.95
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/ammo_hailfire.lua:
att.PrintName = "Hail-Fire Module"
att.Icon = Material("interfaz/armas/sw_fullauto.png")
att.Description = "Higher fire-ratio at the cost of low damage."
att.Override_MuzzleEffect = "wpn_muzzleflash_dc17_green"
att.Override_Tracer = "tracer_green"
att.Desc_Pros = {
}
att.Desc_Cons = {
}

att.NotForNPCs = true
att.AutoStats = true
att.Slot = "ammo"

att.Mult_ShootPitch = 1.2
att.Reload = 1
att.Mult_DamageMin = 0.75
att.Mult_Recoil = 1.2
att.Mult_SightTime = 1
att.Mult_RPM = 1.38
att.Mult_Damage = 0.74
att.Mult_MuzzleVelocity = 0.7
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/ammo_le_mod.lua:
att.PrintName = "LE Mod"
att.Icon = Material("entities/acwatt_go_ammo_blanks.png", "mips smooth")
att.Description = "Long range mod"
att.Desc_Pros = {
}
att.Desc_Cons = {
}

att.AutoStats = true
att.Slot = "ammo"
att.MagReducer = true
att.Reload = 1
att.Mult_DamageMin = 1.35
att.Mult_Recoil = 1.1
att.Mult_SightTime = 1
att.Mult_RPM = 0.5

att.NotForNPCs = true
att.Mult_Damage = 1.8
att.Mult_MuzzleVelocity = 1.1
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/arccw/shared/attachments/ammunition_heatfs.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/cr2_barrel_extended.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/cr2_stock.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/cr2_stock.lua:
att.PrintName = "CR-2 Stock"
att.PrintName = "Extended Stock for CR-2."
att.Icon = Material("interfaz/armas/swrp_att_dlt20_stock.png")
att.Description = ""
att.Desc_Pros = {}
att.Desc_Cons = {}
att.Desc_Neutrals = {}

att.Slot = {"cr2_stock"}
att.ActivateElements = {"cr2_stock"}

att.Mult_Damage = 1.05
att.Mult_SightTime = 1.05
att.Mult_Sway = 1.2
att.Mult_SpeedMult = 1.5
att.Mult_DrawTime = 0.65
att.Mult_HolsterTime = 1.05
att.Mult_HipDispersion = 1.30
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/default.lua:

/*

    Take a look at
    https://github.com/HaodongMo/ArcCW/wiki/Attachment-Parameters
    for descriptions on these

*/

att.PrintName = ""
att.AbbrevName = "" -- Shown in lists, cust2 only
att.Icon = nil
att.Description = ""
att.Desc_Pros = {}
att.Desc_Cons = {}
att.Desc_Neutrals = {}
att.Slot = ""

att.SortOrder = 0

att.Spawnable = false -- generate entity
att.AdminOnly = false -- see above
att.Ignore = true
att.InvAtt = nil -- use this other attachment in inventory
att.Free = false -- attachment is always available, and doesn't need to be picked up or unlocked
att.IgnorePickX = false -- will not increment the Pick X counter
att.Hidden = false
att.HideIfBlocked = false -- if the attachment cannot be attached due to flag reasons, do not show up
att.HideIfUnavailable = false -- if the attachment is not owned, do not show up even if "Hide Unowned Attachments" is off
att.NoRandom = false -- will not be randomly rolled
att.RandomWeight = 1 -- random rolling weight, defaults to 1

att.NotForNPCs = false

att.AddPrefix = ""
att.AddSuffix = ""

att.ToggleLockDefault = false -- if true then lock attachment from switching stats through bind (use on stocks/colored stuff) 

att.ToggleStats = {
    -- {
    --     PrintName = "Red",
    --     AutoStatName = "On",
    --     NoAutoStat = false,
    --     Laser = true,
    --     LaserColor = Color(255, 0, 0),
    --     Mult_HipDispersion = 0.75,
    --     AdditionalSights = {
    --         {
    --             Pos = Vector(-2, 10, -4), -- relative to where att.Model is placed
    --             Ang = Angle(0, 0, -45),
    --             GlobalPos = false,
    --             GlobalAng = true,
    --             Magnification = 1
    --         }
    --     },
    -- },
    -- {
    --     PrintName = "Blue",
    --     AutoStats = true,
    --     Laser = true,
    --     LaserColor = Color(0, 0, 255),
    --     Mult_HipDispersion = 0.75,
    --     AdditionalSights = {
    --         {
    --             Pos = Vector(-2, 10, -4), -- relative to where att.Model is placed
    --             Ang = Angle(0, 0, -45),
    --             GlobalPos = false,
    --             GlobalAng = true,
    --             Magnification = 1
    --         }
    --     },
    -- },
    -- {
    --     PrintName = "Off",
    --     Laser = false,
    --     Mult_HipDispersion = 1,
    -- }
}

att.KeepBaseIrons = false
att.BaseIronsFirst = false

att.GivesFlags = {}
att.RequireFlags = {}
att.ExcludeFlags = {}

-- any strings present in data will be added to weapon flags
att.Hook_ExtraFlags = function(wep, data) end

-- Do not use right now.
att.SubSlots = {
    {
        PrintName = "Optic",
        Slot = {"optic", "optic_lp"}, -- OR
        Slot = "optic",
        DefaultAttName = "Iron Sights",
        DefaultAttIcon = Material(""),
        MergeSlots = {}, -- mergeslots are relative to att.SubSlots, so this entry would be [1], then [2], etc
        -- bone/wmbone is inherited
        ExtraSightDist = 0,
        Offset = { -- inherits from base slot
            vpos = Vector(0, 0, 0),
            vang = Angle(0, 0, 0),
            wpos = Vector(0, 0, 0),
            wang = Angle(0, 0, 0)
        },
        SlideAmount = {
            vmin = Vector(0, 0, 0),
            vmax = Vector(0, 0, 0),
            wmin = Vector(0, 0, 0),
            wmax = Vector(0, 0, 0),
        },
    }
    -- CorrectiveAng/Pos is inherited from base slot
    -- everything else is the same as normal slots
}

att.Max = nil -- the maximum number of this attachment that can be attached.

att.Model = ""
att.HideModel = false
att.ModelBodygroups = ""
att.ModelSkin = 0
att.ModelScale = Vector(1, 1, 1)
att.ModelOffset = Vector(0, 0, 0)
att.OffsetAng = Angle(0, 0, 0)
att.ModelIsShield = false
att.ShieldResistance = nil -- amount of penetration to get through one unit of shield
att.ShieldBone = "ValveBiped.Bip01_R_Hand"

att.Charm = false
att.CharmBone = "Charm"
att.CharmModel = ""
att.CharmOffset = Vector(0, 0, 0)
att.CharmScale = Vector(1, 1, 1)
att.CharmSkin = 0
att.CharmBodygroups = ""

att.Health = 0 -- for breakable attachments

att.ShieldCorrectAng = Angle(0, 0, 0)
att.ShieldCorrectPos = Vector(0, 0, 0)

-- amount of damage done to this attachment
-- attachments which are even a bit damaged are not returned
att.DamageOnShoot = 0
att.DamageOnReload = 0
att.DamagePerSecond = 0

-- {slot = int, atthp = float, dmg = DamageInfo}
att.Hook_PlayerTakeDamage = function(wep, data) end

-- {slot = int, oldhp = float, dmg = float}
att.Hook_AttTakeDamage = function(wep, data) end

-- {slot = int, dmg = float}
att.Hook_AttDestroyed = function(wep, data) end

att.VMColor = Color(255, 255, 255)
att.WMColor = Color(255, 255, 255)
att.VMMaterial = ""
att.WMMaterial = ""

att.DroppedModel = nil
att.LHIKHide = false -- use this to just hide the left hand
att.LHIK = false -- use this model for left hand IK
att.LHIK_Animation = false
att.LHIK_GunDriver = ""
att.LHIK_CamDriver = ""

att.Override_NoHideLeftHandInCustomization = nil

att.ActivateElements = {}

att.MountPositionOverride = nil -- set between 0 to 1 to always mount in a certain position

att.AdditionalSights = {
    {
        Pos = Vector(0, 0, 0), -- relative to where att.Model is placed
        Ang = Angle(0, 0, 0),
        GlobalPos = false, -- solver will not correct position relative to att.Model position
        GlobalAng = false, -- solver will not correct angle
        ViewModelFOV = 45,
        ScrollFunc = ArcCW.SCROLL_ZOOM,
        ZoomLevels = 6,
        ZoomSound = "weapons/arccw/fiveseven/fiveseven_slideback.wav",
        NVScope = nil, -- enables night vision effects for scope
        NVScopeColor = Color(0, 255, 100),
        NVFullColor = false, -- night vision scope is true full color
        Thermal = true,
        ThermalScopeColor = Color(255, 255, 255),
        ThermalHighlightColor = Color(255, 255, 255),
        ThermalFullColor = false,
        ThermalScopeSimple = false,
        ThermalNoCC = false,
        ThermalBHOT = false, -- invert bright/dark
        IgnoreExtra = false, -- ignore gun-determined extra sight distance
        Contrast = 1, -- allows you to adjust the values for contrast and brightness when either NVScope or Thermal is enabled.
        Brightness = 0,
        SpecialScopeFunction = function(screen) end -- perform whatever screen space effects you like here, copy SWEP:FormThermalImaging and SWEP:FormNightVision for examples
    }
}

att.UBGL = false -- is underbarrel grenade launcher
att.UBGL_Icon = nil -- set to a IMaterial to replace icon in HUD


att.UBGL_Automatic = false
att.UBGL_ClipSize = 1
att.UBGL_Ammo = "smg1_grenade"
att.UBGL_RPM = 300

-- Use animations on the weapon itself, useful for weapon-specific UBGL
att.UBGL_BaseAnims = false

-- wep: weapon
-- ubgl: UBGL attachment slot.
att.UBGL_Fire = function(wep, ubgl) end
att.UBGL_Reload = function(wep, ubgl) end

att.Silencer = false

att.Bipod = false
att.Bipod_Icon = nil -- set to a IMaterial to replace icon in HUD
att.Mult_BipodRecoil = 0.25
att.Mult_BipodDispersion = 0.1
att.Override_InBipodPos = nil

att.Override_AlwaysPhysBullet = nil
att.Override_NeverPhysBullet = nil

att.Override_AmmoPerShot = 1
att.Override_InfiniteAmmo = nil
att.Override_BottomlessClip = nil

att.MagExtender = false
att.MagReducer = false
att.OverrideClipSize = nil
att.Add_ClipSize = 0
att.BaseClipSize = nil -- currently only used to make autostats treat this as the "base" clip size for pros/cons

att.Override_FuseTime = nil

att.Laser = false
att.LaserStrength = 1
att.LaserBone = "laser"
att.LaserColor = Color(255, 0, 0)

att.Flashlight = false
att.FlashlightFOV = 50
att.FlashlightHFOV = nil -- horizontal FOV
att.FlashlightVFOV = nil -- vertical FOV
-- basically, use HFOV + VFOV if you want it to be non square
att.FlashlightFarZ = 512 -- how far it goes
att.FlashlightNearZ = 4 -- how far away it starts
att.FlashlightAttenuationType = ArcCW.FLASH_ATT_LINEAR -- LINEAR, CONSTANT, QUADRATIC are available
att.FlashlightColor = Color(255, 255, 255)
att.FlashlightTexture = ""
att.FlashlightBrightness = 1
att.FlashlightBone = "laser"

att.Holosight = false
att.HolosightReticle = nil
att.HolosightFlare = nil
att.HolosightSize = nil
att.HolosightBone = "holosight"
att.HolosightPiece = nil -- the lens of the holo sight, if applicable
att.HolosightMagnification = 1 -- magnify the lens by this much
att.HolosightBlackbox = false
att.HolosightNoHSP = false -- for this holosight ignore HSP
att.HolosightConstDist = nil -- constant holosight distance, mainly for scopes with range finder

att.Colorable = false -- automatically use the player's color option
att.HolosightColor = Color(255, 255, 255)

att.Override_Ammo = "ar2" -- overrides the ammo type with this one

att.Override_Firemodes = {}

-- you can use _Priority to determine the priority of overrides.
-- append it to the end of an Override_ stat to set this.
-- for example, att.Override_Firemodes_Priority = 2
-- higher priority = will be chosen over lower priority
-- default priority for all stats is 1.

-- all hooks will work when applied to the SWEP table as well
-- e.g. SWEP.Hook_FireBullets

-- use A_Hook_[Add_Whatever] to hook into additive hooks.
-- {buff = string buff, add = num add}
-- return table

-- use O_Hook_[Override_Whatever] to hook into override hooks.
-- {buff = string buff, current = any override, winningslot = int slot}

-- use M_Hook_[Mult_Whatever] to hook into multiply hooks.
-- {buff = string buff, mult = num mult}

-- all hooks, mults, and adds will work on fire modes

-- called when the active sight is changed
-- return to change activesight
-- {active = int activesight, asight = table}
att.Hook_SwitchActiveSights = function(wep, data) end

-- Allows you to directly edit the burst count
att.Hook_GetBurstCount = function(wep, burstcount) end

-- Allows you to directly edit how long a burst is
att.Hook_GetBurstLength = function(wep, length) end

-- Allows you to directly edit whether the weapon is reloading/inoperable
att.Hook_GetReloading = function(wep, reloading) end

-- Directly modify dispersion
att.Hook_ModDispersion = function(wep, dispersion) end

-- Allows you to change the weapon's name
-- string name
att.Hook_NameChange = function(wep, name) end

-- allows you to do whatever you like to the weapon VMs
-- {vm = vm, eles = ae}
att.Hook_ModifyBodygroups = function(wep, data) end

-- modify the attachment however you like; only called for the particular attachment
-- {vm = vm, element = VElement / WElement, slottbl = slottbl, wm = false/true}
att.Hook_ModifyAttBodygroups = function(wep, data) end

-- allows you to return a shotgun spread offset
-- {n = int number, ang = angle offset}
att.Hook_ShotgunSpreadOffset = function(wep, data) end

-- done before playing an effect
-- return false to prevent playing
-- fx: {eff = effect name, fx = EffectData()}
att.Hook_PreDoEffects = function(wep, fx) end

-- return true = compatible
-- return false = incompatible
-- data = {slot = string or table, att = string}
att.Hook_Compatible = function(wep, data) end

-- called before the bullet is made.
att.Hook_PostFireBullets = function(wep) end

-- hook that lets you change the values of the bullet before it's fired.
att.Hook_FireBullets = function(wep, bullettable) end

-- called after all other primary attack functions. Do stuff here.
att.Hook_PostFireBullets = function(wep) end

-- return true to prevent fire
att.Hook_ShouldNotFire = function(wep) end

-- return true to prevent fire, bashing, anything involving the fire button
att.Hook_ShouldNotFireFirst = function(wep) end

-- return true to prevent ads
att.Hook_ShouldNotSight = function(wep) end

-- return anything to select this reload animation. Bear in mind that not all guns have the same animations, so check first.
att.Hook_SelectReloadAnimation = function(wep, curanim) end

-- return anything to multiply reload time by that much
att.Hook_MultReload = function(wep, mult) end

-- data has entries:
-- number count, how much ammo to add with this insert
-- string anim, which animation to play
-- bool empty, whether we are reloading from empty
att.Hook_SelectInsertAnimation = function(wep, data) end

-- return to override fire animation
att.Hook_SelectFireAnimation = function(wep, curanim) end

-- return string to change played anim
-- string anim, animation we are attempting to play
-- return false to block animation
-- return nil to do nothing
att.Hook_TranslateAnimation = function(wep, anim) end

-- directly changes source sequence to play
-- seq and return can either be string or table
att.Hook_TranslateSequence = function(wep, seq) end

-- called when the vm is about to play an idle animation
-- return a value to override ianim
att.Hook_IdleReset = function(wep, ianim) end

-- allows any sound to be translated to any other
att.Hook_TranslateSound = function(wep, soundname) end

-- directly changes sequence to play
-- return "DoNotPlayIdle" to stop idle animation
att.Hook_LHIK_TranslateAnimation = function(wep, anim) end

-- att.Hook_TranslateAnimation = function(wep, anim)
--     if anim == "reload" then
--         return "reload_soh"
--     elseif anim == "reload_empty" then
--         return "reload_empty_soh"
--     end
-- end

-- anim is string
att.Hook_SelectBashAnim = function(wep, anim) end

att.Hook_SelectFixAnim = function(wep, anim) end

att.Hook_PreBash = function(wep) end

-- data = {tr = tr, dmg = dmg}
att.Hook_PostBash = function(wep, data) end

-- Called just before a physbullet will call FireBullets
-- data.bullet - physbullet info; data.tr - trace info
att.Hook_PhysBulletHit = function(wep, data) end

-- data has entries:
-- number range, the distance the bullet had to travel
-- number damage, the calculated damage the bullet will do
-- number penleft, the amount of penetration the bullet still possesses
-- enum dmgtype, the DMG_ enum of the damagetype
-- table tr, the trace result
-- entity att, the attacker (?)
-- DamageInfo dmg, the damage info

-- changes to dmg may be overwritten later, so set damage and dmgtype instead
att.Hook_BulletHit = function(wep, data) end

-- called right after BulletHit, no further changes can be applied to damage
att.Hook_PostBulletHit = function(wep, data) end

-- return true to prevent reloading
att.Hook_PreReload = function(wep) end

att.Hook_PostReload = function(wep) end

-- return true to prevent firemode change
att.Hook_ChangeFiremode = function(wep) end

-- return true to ignore current bullets in clip when reloading
att.Hook_ReloadDumpClip = function(wep) end

att.Hook_GetVisualBullets = function(wep) end

att.Hook_GetVisualClip = function(wep) end

-- modify what the event system be do
-- the event is a table containing stuff that it does
-- sh_timers last stuff timers are stupid lets not
-- please dont return anything people kinda would wanna run events i'd imagine
att.Hook_PrePlayEvent = function(wep, event) end
att.Hook_PostPlayEvent = function(wep, event) end

-- return to set mag capacity
att.Hook_GetCapacity = function(wep, cap) end

-- return false to suppress shoot sound
-- string sound = default sound
att.Hook_GetShootSound = function(wep, sound) end
att.Hook_GetShootDrySound = function(wep, sound) end
att.Hook_GetDistantShootSound = function(wep, sound) end

-- return a string to change the default attachment name and icon for that slot
-- int slot = slot of attachment to name/set icon
att.Hook_GetDefaultAttName = function(wep, slot) end
att.Hook_GetDefaultAttIcon = function(wep, slot) end

-- or just add more!
-- data has entries:
-- string sound
-- number volume
-- number pitch
att.Hook_AddShootSound = function(wep, data) end
--    att.Hook_AddShootSound = function(wep, data)
--      wep:MyEmitSound("weapons/pistol/pistol_fire2.wav", data.volume, data.pitch, 1, CHAN_WEAPON - 1)
--    end

-- allows you to modify the weapon's rate of fire
att.Hook_ModifyRPM = function(wep, delay) end

-- return a table containing Recoil, RecoilSide, VisualRecoilMult to multiply them
-- Alternatively, edit the values in rec without returning, which supports multiple hooks changing the value
att.Hook_ModifyRecoil = function(wep, rec) end

-- run in Think()
att.Hook_Think = function(wep) end

-- thinking hook for att
att.DrawFunc = function(wep, element, wm) end

-- after ADS starts or ends
att.Hook_SightToggle = function(wep, enter) end

att.Override_Trivia_Class = nil -- "Submachine Gun"
att.Override_Trivia_Desc = nil -- "Ubiquitous 9mm SMG. Created as a response to the need for a faster-firing and more reliable submachine gun than existing options at the time."
att.Override_Trivia_Manufacturer = nil -- "Auschen Waffenfabrik"
att.Override_Trivia_Calibre = nil -- "9x21mm Jager"
att.Override_Trivia_Mechanism = nil -- "Roller-Delayed Blowback"
att.Override_Trivia_Country = nil -- "Austria"
att.Override_Trivia_Year = nil -- 1968

att.Mult_Damage = 1
att.Mult_DamageMin = 1
att.Mult_DamageRand = 1
att.Mult_DamageNPC = 1 -- damage WHEN USED BY NPCS not when used against them
att.Mult_Range = 1
att.Mult_Penetration = 1
att.Override_DamageType = nil
att.Override_DamageTypeHandled = nil
att.Override_ShootEntity = nil
att.Mult_MuzzleVelocity = 1

att.Override_BodyDamageMults = nil

att.Override_ShotgunSpreadPattern = {}
att.Override_ShotgunSpreadPatternOverrun = {}

att.Override_NoRandSpread = false -- disable (random) spread modification after bullet table override

att.Mult_MeleeTime = 1
att.Mult_MeleeDamage = 1
att.Add_MeleeRange = 0
att.Mult_MeleeAttackTime = 1
att.Override_MeleeDamageType = nil

att.Override_Lunge = nil
att.Add_LungeLength = 0
att.Mult_LungeLength = 1

-- jam/heat related buffs
att.Override_Jamming = nil
att.Mult_HeatCapacity = 1
att.Mult_FixTime = 1
att.Mult_HeatDissipation = 1
att.Mult_HeatDelayTime = 1
att.Override_HeatFix = nil
att.Override_HeatLockout = nil
att.Hook_Overheat = function(wep, heat) end
att.Hook_PostOverheat = function(wep) end
-- Return true to not do animation/heat locking
att.Hook_OnOverheat = function(wep) end
att.HeatOverflow = nil

-- malfunction related buffs
att.Override_Malfunction = nil
att.Override_MalfunctionTakeRound = nil
att.Override_MalfunctionJam = nil
att.Mult_MalfunctionMean = 1
att.Mult_MalfunctionVariance = 1
att.Mult_MalfunctionFixTime = 1

-- Called every time malfunction is checked. return true to cause malfunction
att.Hook_Malfunction = function(wep, count) end
-- Called when a malfunction is about to happen. return true to stop malfunction
att.Hook_OnMalfunction = function(wep, count) end
-- Called after a malfunction has occurred.
att.Hook_PostMalfunction = function(wep) end

att.Override_Tracer = nil -- tracer effect name
att.Override_TracerNum = nil
-- att.Override_TracerCol = nil
-- att.Mult_TracerWidth = 1
att.TracerFinalMag = nil

att.Override_PhysTracerProfile = nil -- color for phys tracer.
-- there are 8 options:
-- 0 = normal
-- 1 = red
-- 2 = green
-- 3 = blue
-- 4 = yellow
-- 5 = violet
-- 6 = cyan
-- 7 = black/invisible

att.Override_CanBash = nil

att.Override_ShotgunReload = nil
att.Override_HybridReload = nil

att.Override_AutoReload = nil

att.Override_ManualAction = nil

att.Override_CanFireUnderwater = nil

att.Override_ChamberSize = nil
att.Add_ChamberSize = nil

att.Mult_Recoil = 1
att.Mult_RecoilSide = 1
att.Mult_VisualRecoilMult = 1

att.Mult_Sway = 1

att.Override_ShootWhileSprint = nil

att.Mult_RPM = 1

att.Add_Num = nil
att.Mult_Num = nil
att.Override_Num = nil

att.Mult_AccuracyMOA = 1
att.Mult_HipDispersion = 1
att.Mult_SightsDispersion = 1

att.Mult_ShootVol = 1
att.Mult_ShootPitch = 1

att.Mult_GlintMagnitude = 1

att.Override_MuzzleEffect = nil
att.Override_FastMuzzleEffect = nil
att.Override_GMMuzzleEffect = nil

att.Override_ShellEffect = nil
att.Override_ShellMaterial = nil

att.Override_MuzzleEffectAttachment = nil
att.Override_CaseEffectAttachment = nil

att.Mult_SpeedMult = 1
att.Mult_SightedSpeedMult = 1
att.Mult_ShootSpeedMult = 1

att.Override_HoldtypeHolstered = nil
att.Override_HoldtypeActive = nil
att.Override_HoldtypeSights = nil

att.Override_AnimShoot = nil

att.Override_HolsterPos = nil
att.Override_HolsterAng = nil

att.Add_BarrelLength = 0

att.Override_BarrelOffsetSighted = nil
att.Override_BarrelOffsetHip = nil

att.Mult_ReloadTime = 1
att.Mult_DrawTime = 1
att.Mult_SightTime = 1
att.Mult_CycleTime = 1

att.AttachSound = nil
att.DetachSound = nil
att.ToggleSound = nil

-- free aim related buffs
att.Override_FreeAimAngle = nil
att.Mult_FreeAimAngle = nil
att.Add_FreeAimAngle = nil
att.Override_NeverFreeAim = nil
att.Override_AlwaysFreeAim = nil

att.Hook_OnDeploy = function(wep) end
att.Hook_OnHolster = function(wep) end
att.Hook_OnHolsterEnd = function(wep) end

-- bool dodefault - set false to not do default throwing behavior
-- vector force
-- string shootentity
-- number/nil fusetime
att.Hook_Throw = function(wep, data) end
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/arccw/shared/attachments/mode_overpressure.lua:
att.PrintName = "Overpressure Mode"
att.Icon = Material("entities/arccw/kraken/republic-arsenal/atts/powerpack.png")
att.Description = "Set the weapon overpressurized mode."

att.Slot = "sw_mode_universal"

att.Override_MuzzleEffect = "blaster_muzzle_green"
att.Override_Tracer = "tracer_green"
att.Mult_RPM = 2
att.Mult_HeatGain = 1.5
att.MuzzleFlashColor = Color(0, 250, 0)

att.Mult_Recoil = 1.15
att.Mult_RecoilSide = 1.05
att.Mult_VisualRecoilMult = 1.5

att.Desc_Pros = {}
att.Desc_Cons = {}

att.NotForNPCs = true
att.AutoStats = true

--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/arccw/shared/attachments/mode_scatter_pistol.lua:
att.PrintName = "Scatter Mode"
att.Icon = Material("entities/arccw/kraken/republic-arsenal/atts/scatter.png")
att.Description = "Set the weapon mode to Scatter. Turns your weapon into a shotgun."

att.Slot = "sw_mode_pistol"

att.Desc_Pros = {}
att.Desc_Cons = {}

att.Override_DamageType = DMG_BUCKSHOT
att.Add_Num = 4
att.Mult_Range = 1.25

att.Mult_AccuracyMOA = 25
att.Mult_HipDispersion = 2
att.Mult_SightsDispersion = 2

att.Mult_Damage = 0.9
att.Mult_DamageMin = 0.9
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/arccw/shared/attachments/mode_supersonic.lua:
att.PrintName = "Super-Sonic Mode"
att.Icon = Material("entities/arccw/kraken/republic-arsenal/atts/supersonic.png")
att.Description = "Set the weapon mode to Super-Sonic Mode."

att.Desc_Pros = {}
att.Desc_Cons = {}

att.NotForNPCs = true
att.AutoStats = true

att.Slot = "sw_mode_sniper"

att.Override_MuzzleEffect = "blaster_muzzle_green"
att.Override_Tracer = "nio_tracer"
att.Override_DamageType = DMG_BLAST
att.Override_AmmoPerShot = 5
att.Mult_RPM = 0.35

att.Mult_Recoil = 1.5
att.Mult_RecoilSide = 1.5
att.Mult_VisualRecoilMult = 1.5


--PATH lua/arccw/shared/attachments/muzzle_a280_mod.lua:
att.PrintName = "A280 Barrel Mod"
att.Description = "Bulky and heavy, but provides better ballistic performance.\n\n\"By the time you figured it out, it would be too late.\""

att.AutoStats = true
att.Slot = {"muzzle"}

att.SortOrder = 150

att.Model = "models/atts/a280_default_barrel.mdl"
att.ModelOffset = Vector(0, 0, 0)
att.OffsetAng = Angle(0, 0, 0)

att.Silencer = false
att.IsMuzzleDevice = false

att.Mult_ShootPitch = 1.1
att.Mult_ShootVol = 1

att.Add_BarrelLength = 6
att.Mult_SightTime = 1.15
att.Mult_HipDispersion = 1.2
att.Mult_Sway = 1.15
att.Mult_Range = 1.1
--PATH lua/arccw/shared/attachments/muzzle_a280cfe_default_mod.lua:
att.PrintName = "A280-CFE Standard Barrel"
att.Description = "Bulky and heavy, but provides better ballistic performance.\n\n\"By the time you figured it out, it would be too late.\""

att.AutoStats = true
att.Slot = {"muzzle"}

att.SortOrder = 150

att.Model = "models/atts/a280cfe_defaultbarrel.mdl"
att.ModelOffset = Vector(0, 0, 0)
att.OffsetAng = Angle(0, 0, 0)

att.Silencer = false
att.IsMuzzleDevice = false

att.Mult_ShootPitch = 1.1
att.Mult_ShootVol = 1


att.Mult_RecoilSide = 0.75

att.Mult_ShootSpeedMult = 1.05
att.Mult_Sway = 1

att.Add_BarrelLength = 6
att.Mult_SightTime = 1.1
att.Mult_HipDispersion = 1.1
att.Mult_Range = 1
--PATH lua/arccw/shared/attachments/muzzle_dc15a_mod.lua:
return gluapack()()
--PATH lua/arccw/shared/attachments/optic_dlt19_scope.lua:
return gluapack()()
--PATH lua/arccw/shared/attachments/optic_s5_scope.lua:
att.PrintName = "S5 Magnifying Optic"
att.Icon = Material("entities/dlt19x_icon.png")
att.Description = "High-magnification sniper rifle scope for long range combat."

att.SortOrder = 9

att.Desc_Pros = {
    "autostat.holosight",
    "autostat.zoom",
}
att.Desc_Cons = {
}
att.AutoStats = true
att.Slot = "optic"

att.Model = "models/atts/s5_default_scope.mdl"
att.ModelOffset = Vector(0, 0, -0)
att.AdditionalSights = {
    {
        Pos = Vector(0, 9, -1.2),
        Ang = Angle(0, 0, 0),
        Magnification = 1.5,
        ScrollFunc = ArcCW.SCROLL_ZOOM,
        ZoomLevels = 10,
        ZoomSound = "weapons/arccw/fiveseven/fiveseven_slideback.wav",
        IgnoreExtra = true
    }
}

att.ScopeGlint = false

att.Holosight = true
att.HolosightReticle = Material("scope/star_ret.png", "smooth")
att.HolosightNoFlare = true
att.HolosightSize = 13
att.HolosightBone = "holosight"
att.HolosightPiece = "models/atts/s5_default_scope_hsp.mdl"
att.Colorable = false

att.HolosightMagnification = 0
att.HolosightBlackbox = true

att.HolosightConstDist = 64

att.HolosightMagnificationMin = 2
att.HolosightMagnificationMax = 3
att.HoloSightColorable = false

att.Mult_SightTime = 1.35
att.Mult_SightedSpeedMult = 0.8
att.Mult_SpeedMult = 0.9
--PATH lua/arccw/shared/attachments/optic_valken38_scope.lua:
att.PrintName = "Valken 38x Magnifying Optic"
att.Icon = Material("entities/dlt19x_icon.png")
att.Description = "High-magnification sniper rifle scope for long range combat."

att.SortOrder = 9

att.Desc_Pros = {
    "autostat.holosight",
    "autostat.zoom",
}
att.Desc_Cons = {
}
att.AutoStats = true
att.Slot = "optic"

att.Model = "models/atts/valken_scope.mdl"
att.ModelOffset = Vector(0, 0, -0)
att.AdditionalSights = {
    {
        Pos = Vector(-0.01, 9, -1.8),
        Ang = Angle(0, 0, 0),
        Magnification = 1.5,
        ScrollFunc = ArcCW.SCROLL_ZOOM,
        ZoomLevels = 10,
        ZoomSound = "weapons/arccw/fiveseven/fiveseven_slideback.wav",
        IgnoreExtra = true
    }
}

att.ScopeGlint = false

att.Holosight = true
att.HolosightReticle = Material("scope/star_ret.png", "smooth")
att.HolosightNoFlare = true
att.HolosightSize = 7.6
att.HolosightBone = "holosight"
att.HolosightPiece = "models/atts/valken_scope_hsp.mdl"
att.Colorable = false

att.HolosightMagnification = 0
att.HolosightBlackbox = true

att.HolosightConstDist = 64

att.HolosightMagnificationMin = 2
att.HolosightMagnificationMax = 3
att.HoloSightColorable = false

att.Mult_SightTime = 1.35
att.Mult_SightedSpeedMult = 0.8
att.Mult_SpeedMult = 0.9
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/arccw/shared/attachments/perk_clonearf.lua:
return gluapack()()
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/arccw/shared/attachments/perk_clonemedic.lua:
return gluapack()()
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/arccw/shared/attachments/perk_clonetrooper.lua:
return gluapack()()
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/arccw/shared/attachments/perk_comando.lua:
att.PrintName = "Clone Commando Training"

att.Icon = Material("entities/arccw/kraken/republic-arsenal/atts/commando.png")
att.Description = [[Clone commandos, also known as Republic commandos while serving under the Galactic Republic, were elite clone troopers that served in the Grand Army of the Republic's Special Operations Brigade during the Clone Wars. A result of the Kaminoans' genetic experimentation with the Jango Fett template, they were special forces soldiers noted for their training and elite status in the clone army.]]
att.Desc_Pros = {}
att.Desc_Cons = {}
att.Desc_Neutrals = {}
att.Slot = {"perk"}

att.AutoStats = true
att.NotForNPC = true

att.Mult_MoveSpeed = 1.1
att.Mult_JumpDispersion = 0.97

att.Mult_AccuracyMOA = 0.90
att.Mult_HipDispersion = 0.90
att.Mult_MoveDispersion = 0.90

att.Mult_FixTime = 0.75
att.Mult_HeatDelayTime = 0.75

att.Mult_DrawTime = 0.7
att.Mult_HolsterTime = 0.9
att.Mult_SightTime = 0.7
att.Mult_SpeedMult = 1.10

att.Mult_SightedSpeedMult = 1.1
att.Mult_ReloadTime = 0.90

att.Mult_Recoil = 0.80
att.Mult_RecoilSide = 0.80
att.Mult_VisualRecoilMult = 0.7
att.Mult_Sway = 0.87

att.Mult_Damage = 1.10
att.Mult_DamageMin = 1.25


--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/perk_ondamove.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/perk_pointman.lua:
att.PrintName = "Pointman"

att.Icon = Material("interfaz/iconos/kraken/jedi juns sharpshooter/3178788454_3701931000.png")
att.Description = "Firearms and dexterity training for quick response in breaching situations. Drills in confined spaces allow you to more effectively handle long weapons in close quarters.\n\nThe pointman is always the first to enter, and the first to identify and disable threats."
att.Desc_Pros = {
    "Reduces barrel length for CQB situations."
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "perk"
att.SortOrder = 7

att.AutoStats = true
att.Add_BarrelLength = -10
att.M_Hook_Mult_RPM = function(wep, data)
    if wep:GetCurrentFiremode().Mode == 1 then
        data.mult = data.mult * 1.15
    end
end

att.NotForNPCs = true
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/special_poison.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/st_dc15.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/arccw/shared/attachments/sw_mag_dc15a_100drum.lua:
return gluapack()()
--PATH lua/arccw/shared/attachments/sw_perk_standardtraining.lua:
att.PrintName = "Standard Training"

att.Icon = Material("", "smooth mips")
att.Description = [[The most basic training for weapon handling.
You perform at the core level now...]]
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
	"Maybe training will pay off..",
}
att.Slot = {"perk"}

att.AutoStats = true
att.NotForNPC = true

att.Mult_MoveSpeed = 1.1
att.Mult_JumpDispersion = 0.85

att.Mult_AccuracyMOA = 0.95
att.Mult_HipDispersion = 0.95
att.Mult_MoveDispersion = 0.95

att.Mult_DrawTime = 0.9
att.Mult_HolsterTime = 0.9
att.Mult_SightTime = 0.9

att.Mult_SpeedMult = 1.05
att.Mult_SightedSpeedMult = 1.1

att.Mult_ReloadTime = 0.95

att.Mult_Recoil = 0.85
att.Mult_RecoilSide = 0.85
att.Mult_VisualRecoilMult = 0.8
att.Mult_Sway = 0.9

--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/arccw/shared/attachments/sw_stun10.lua:
att.PrintName = "Stun Rounds - 10s"
att.AbbrevName = "Stun Rounds - 10s"
att.Icon = Material("entities/arccw/kraken/republic-arsenal/atts/stun10.png")
att.Description = "Replace the main-fire for stun rounds."

att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = {"sw_ammo"}

att.AutoStats = true
att.Override_AmmoPerShot = 5
att.Override_Tracer = "effect_sw_laser_blue_stun"
att.Hook_BulletHit = function(wep, data)
	GMSERV:AddStatus(data.tr.Entity, data.att, "stun", 10, 1, true) --Entity,Owner,Status Effect Type (Yes, you can add the others),Duration, Damage, ParticleEffect
end
att.Hook_GetShootSound = function(wep, sound)
    return false
end
att.Hook_AddShootSound = function(wep, data)
    wep:MyEmitSound("everfall/weapons/republic/stun.wav", data.volume, data.pitch, 1, CHAN_WEAPON - 1)
end
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/arccw/shared/attachments/ubgl_dc15.lua:
att.PrintName = "Republic Underbarrel GL"
att.AbbrevName = "DX-203 UBGL"
att.Icon = Material("entities/arccw/kraken/republic-arsenal/ubgl.png", "mips smooth")
att.Description = "Single-shot underbarrel grenade launcher. Able to fire several basic grenade types."

att.SortOrder = -100000

att.AutoStats = true
att.Desc_Pros = {
}
att.Slot = "ubgl_republica"

att.LHIK = true

att.ModelOffset = Vector(0, 0, 0)
att.Model = "models/arccw/kraken/atts/rep_ubgl.mdl"

att.SelectUBGLSound =  ""
att.ExitUBGLSound = ""

att.UBGL = true

att.UBGL_PrintName = "UBGL"
att.UBGL_Automatic = false
att.UBGL_MuzzleEffect = "blaster_muzzle_blue"
att.UBGL_Ammo = "smg1_grenade"
att.UBGL_RPM = 120
att.UBGL_Recoil = 2

-- ??
att.UBGL_Capacity = 1
att.UBGL_ClipSize = 1

att.LHIK_GunDriver = 2
att.LHIK_CamDriver = 3

local function Ammo(wep)
    return (wep:GetOwner():GetAmmoCount("smg1_grenade"))
end

att.Hook_LHIK_TranslateAnimation = function(wep, key)
    if key == "idle" then
        if wep:GetInUBGL() then
            return "idle_armed"
        else
            return "idle"
        end
    end
end

att.Hook_ShouldNotSight = function(wep)
    if wep:GetInUBGL() then
        return true
    end
end

att.Hook_OnSelectUBGL = function(wep)
    wep:SetNextSecondaryFire(CurTime() + 0.7)
    if (game.SinglePlayer() and SERVER) or (!game.SinglePlayer() and CLIENT and IsFirstTimePredicted()) then
        wep:DoLHIKAnimation("to_armed", 0.7)
        wep:PlaySoundTable({
            {s = "arccw/rep_ubgl/rattle_b2i_rifle.ogg", t = 0},
            {s = "arccw/rep_ubgl/raise.ogg", t = 0.2},
            {s = "arccw/rep_ubgl/grab.ogg", t = 0.5},
        })
    end
end

att.Hook_OnDeselectUBGL = function(wep)
    wep:SetNextSecondaryFire(CurTime() + 0.7)
    if (game.SinglePlayer() and SERVER) or (!game.SinglePlayer() and CLIENT and IsFirstTimePredicted()) then
        wep:DoLHIKAnimation("to_idle", 0.7)
        wep:PlaySoundTable({
            {s = "arccw/rep_ubgl/rattle_b2i_rifle.ogg", t = 0},
            {s = "arccw/rep_ubgl/shoulder.ogg", t = 0.4},
        })
    end
end

att.UBGL_Fire = function(wep, ubgl)
    if wep:Clip2() <= 0 then return end

    local owner = wep:GetOwner()
    local class = wep:GetBuff_Override("UBGL_Entity") or "arccw_ubgl_he"

    if class == "BUCKSHOT" then
        local dir = (owner:EyeAngles() + wep:GetFreeAimOffset()):Forward()

        local bullet = {
            DamageMax = 18,
            DamageMin = 6,
            Range = 50,
            RangeMin = 5,
            DamageType = DMG_BUCKSHOT + DMG_BULLET,
            Penleft = 0,
            Penetration = 0,
            Num = 1,
            Damaged = {},
            Weapon = wep,
        }

        local data = {
            Attacker = owner,
            Dir        = dir,
            Src        = wep:GetShootSrc(),
            Spread     = Vector(0, 0, 0),
            Damage     = 0,
            Num        = 1,
            Force      = 5,
            HullSize   = 4,
            Weapon     = wep,
            Callback = function(attacker, tr, dmg)
                -- HACK: Pass a fake bullet table instead of ourselves so we don't use the weapon's attributes unintentionally
                bullet.Travelled = (tr.HitPos - tr.StartPos):Length()
                ArcCW:BulletCallback(att, tr, dmg, bullet)
            end
        }

        if wep:GetOwner():IsPlayer() then
            for n = 1, 20 do
                local dirry = Vector(dir.x, dir.y, dir.z)
                math.randomseed(math.Round(util.SharedRandom(n, -1337, 1337, !game.SinglePlayer() and wep:GetOwner():GetCurrentCommand():CommandNumber() or CurTime()) * (wep:EntIndex() % 30241)))
                wep:ApplyRandomSpread(dirry, ArcCW.MOAToAcc * 50)
                data.Dir = dirry
                if GetConVar("arccw_bullet_enable"):GetBool() then
                    ArcCW:ShootPhysBullet(wep, data.Src, (250 / ArcCW.HUToM) * data.Dir:GetNormalized(), 0, bullet)
                else
                    owner:FireBullets(data, true)
                end
            end
        else
            data.Spread = Vector(ArcCW.MOAToAcc * 50, ArcCW.MOAToAcc * 50, 0)
            data.Num = 20
            owner:FireBullets(data, true)
        end
        wep:MyEmitSound(")^/arccw/rep_ubgl/gl_fire_buck.ogg", 100, 100, 1, CHAN_WEAPON )
        wep:MyEmitSound(")^/arccw/rep_ubgl/gl_fire_buck_dist.ogg", 149, 100, 0.5, CHAN_WEAPON + 1)
    else
        local proj = wep:FireRocket(class, 2500)
        if SERVER then
            proj.Damage = 130 -- lower than the m79 (200) for balance reasons
        end
        wep:MyEmitSound(")^/arccw/rep_ubgl/40mm/fire-0" .. math.random(1, 6) .. ".ogg", 100, 100, 1, CHAN_WEAPON)
        wep:MyEmitSound(")^/arccw/rep_ubgl/40mm/fire-dist-0" .. math.random(1, 6) .. ".ogg", 149, 100, 0.5, CHAN_BODY)
        wep:MyEmitSound(")^/arccw/rep_ubgl/40mm/mech-0" .. math.random(1, 6) .. ".ogg", 149, 100, 0.5, CHAN_AUTO)
    end

    if game.SinglePlayer() and SERVER or (!game.SinglePlayer() and CLIENT and IsFirstTimePredicted()) then
        wep:DoEffects()
        wep:DoLHIKAnimation("fire")
    end
    wep:SetClip2(wep:Clip2() - 1)
    wep:DoEffects()
end

local casing = {"arccw/rep_ubgl/40mm/casing-40mm-01.ogg", "arccw/rep_ubgl/40mm/casing-40mm-02.ogg", "arccw/rep_ubgl/40mm/casing-40mm-03.ogg", "arccw/rep_ubgl/40mm/casing-40mm-04.ogg", "arccw/rep_ubgl/40mm/casing-40mm-05.ogg", "arccw/rep_ubgl/40mm/casing-40mm-06.ogg"}

att.UBGL_Reload = function(wep, ubgl)
    if wep:Clip2() >= 1 then return end
    if Ammo(wep) <= 0 then return end

    wep:SetNextSecondaryFire(CurTime() + 2.75)

    local holy = (game.SinglePlayer() and SERVER) or (!game.SinglePlayer() and CLIENT and IsFirstTimePredicted())
    if holy then
        wep:DoLHIKAnimation("reload", 2.75)
        wep:PlaySoundTable({
            {s = { "arccw/rep_ubgl/rattle1.ogg", "arccw/rep_ubgl/rattle2.ogg", "arccw/rep_ubgl/rattle3.ogg" }, t = 0},
            {s = "arccw/rep_ubgl/40mm/203open.ogg", t = 0.2},
            {s = casing, t = 0.7},
            {s = "arccw/rep_ubgl/magpouch_replace_small.ogg", t = 0.9},
            {s = "arccw/rep_ubgl/40mm/203insert.ogg", t = 1.2},
            {s = "arccw/rep_ubgl/shoulder.ogg", t = 1.5},
            {s = "arccw/rep_ubgl/40mm/203close.ogg", t = 1.7},
            {s = "arccw/rep_ubgl/shoulder.ogg", t = 2.3},
        })
    end

    local reserve = Ammo(wep)
    reserve = reserve + wep:Clip2()
    local clip = 1
    local load = math.Clamp(clip, 0, reserve)
    if wep:GetOwner():GetAmmoCount("smg1_grenade") then
        wep:GetOwner():RemoveAmmo(1, "smg1_grenade")
    end
    wep:SetClip2(load)
end

att.Mult_SightTime = 1.2
att.Mult_SpeedMult = 0.9
att.Mult_SightedSpeedMult = 0.85

att.ToggleLockDefault = true
att.ToggleStats = {
    {
        PrintName = "High Explosive",
        UBGL_Entity = "arccw_ubgl_he"
    },
    {
        PrintName = "Flashbang",
        UBGL_Entity = "arccw_ubgl_flash"
    },
    {
        PrintName = "Incendiary",
        UBGL_Entity = "arccw_ubgl_incendiary"
    },
}
--PATH lua/arccw/client/cl_languages/en.lua:
return gluapack()()
--PATH lua/arccw/shared/sh_move.lua:
return gluapack()()
--PATH lua/arccw/shared/sh_move.lua:

function ArcCW.Move(ply, mv, cmd)
    local wpn = ply:GetActiveWeapon()

    if !wpn.ArcCW then return end

    local s = 1

    local sm = Lerp( ArcCW.ConVars["mult_movespeed"]:GetFloat(), 1, math.Clamp(wpn.SpeedMult * wpn:GetBuff_Mult("Mult_SpeedMult") * wpn:GetBuff_Mult("Mult_MoveSpeed"), 0, 1) )

    -- look, basically I made a bit of an oopsy and uh this is the best way to fix that
    s = s * sm

    local basespd = (Vector(cmd:GetForwardMove(), cmd:GetUpMove(), cmd:GetSideMove())):Length()
    basespd = math.min(basespd, mv:GetMaxClientSpeed())

    local shotdelta = 0 -- how close should we be to the shoot speed mult
    local shottime = wpn:GetNextPrimaryFireSlowdown() - CurTime()

    local blocksprint = false

    if wpn:GetNWState() == ArcCW.STATE_SIGHTS or wpn:GetTriggerDelta() > 0 or
        wpn:GetNWState() == ArcCW.STATE_CUSTOMIZE then
        blocksprint = true
        s = s * Lerp( ArcCW.ConVars["mult_movespeedads"]:GetFloat() * (1-wpn:GetSightDelta()), 1, math.Clamp(wpn:GetBuff("SightedSpeedMult") * wpn:GetBuff_Mult("Mult_SightedMoveSpeed"), 0, 1) )
    elseif shottime > 0 or wpn:GetGrenadePrimed() then
        blocksprint = true

        if wpn:CanShootWhileSprint() then
            blocksprint = false
        end
    end

    if blocksprint then
        basespd = math.min(basespd, ply:GetWalkSpeed())
    end

    if wpn:GetInBipod() then
        s = 0.0001
    end

    if shottime > 0 then
        -- full slowdown for duration of firing
        shotdelta = 1
    else
        -- recover from firing slowdown after shadow duration
        local delay = wpn:GetFiringDelay()
        local aftershottime = -shottime / delay
        shotdelta = math.Clamp(1 - aftershottime, 0, 1)
    end
    local shootmove = Lerp( ArcCW.ConVars["mult_movespeedfire"]:GetFloat(), 1, math.Clamp(wpn:GetBuff("ShootSpeedMult"), 0.0001, 1) )
    s = s * Lerp(shotdelta, 1, shootmove)

    mv:SetMaxSpeed(basespd * s)
    mv:SetMaxClientSpeed(basespd * s)
    ply.ArcCW_LastTickSpeedMult = s -- in case other addons need it
end

hook.Add("SetupMove", "ArcCW_SetupMove", ArcCW.Move)

local limy_p = 45
local limy_n = -45
local limp_p = 30
local limp_n = -30

function ArcCW.CreateMove(cmd)
    local ply = LocalPlayer()
    local wpn = ply:GetActiveWeapon()

    if !wpn.ArcCW then return end

    if wpn:GetInBipod() and wpn:GetBipodAngle() then
        --[[]
        if !wpn:GetBipodAngle() then
            wpn:SetBipodPos(wpn:GetOwner():EyePos())
            wpn:SetBipodAngle(wpn:GetOwner():EyeAngles())
        end
        ]]

        local bipang = wpn:GetBipodAngle()
        local ang = cmd:GetViewAngles()

        local dy = math.AngleDifference(ang.y, bipang.y)
        local dp = math.AngleDifference(ang.p, bipang.p)

        if dy > limy_p then
            ang.y = bipang.y + limy_p
        elseif dy < limy_n then
            ang.y = bipang.y + limy_n
        end

        if dp > limp_p then
            ang.p = bipang.p + limp_p
        elseif dp < limp_n then
            ang.p = bipang.p + limp_n
        end

        cmd:SetViewAngles(ang)
    end
end

hook.Add("CreateMove", "ArcCW_CreateMove", ArcCW.CreateMove)

local function tgt_pos(ent, head)
    local mins, maxs = ent:WorldSpaceAABB()
    local pos = ent:WorldSpaceCenter()
    pos.z = pos.z + (maxs.z - mins.z) * 0.2 -- Aim at chest level
    if head and ent:GetAttachment(ent:LookupAttachment("eyes")) ~= nil then
        pos = ent:GetAttachment(ent:LookupAttachment("eyes")).Pos
    end
    return pos
end

local lst = SysTime()

function ArcCW.StartCommand(ply, ucmd)
    -- Sprint will not interrupt a runaway burst
    local wep = ply:GetActiveWeapon()
    if ply:Alive() and IsValid(wep) and wep.ArcCW and wep:GetBurstCount() > 0
            and ucmd:KeyDown(IN_SPEED) and wep:GetCurrentFiremode().RunawayBurst
            and !wep:CanShootWhileSprint() then
        ucmd:SetButtons(ucmd:GetButtons() - IN_SPEED)
    end

    -- Holster code
    if IsValid(wep) and wep.ArcCW and wep:GetHolster_Time() != 0 and wep:GetHolster_Time() <= CurTime() and IsValid(wep:GetHolster_Entity()) then
        wep:SetHolster_Time(-math.huge)
        ucmd:SelectWeapon(wep:GetHolster_Entity())
    end


    -- Aim assist
    if CLIENT and IsValid(wep) and wep.ArcCW
            and (wep:GetBuff("AimAssist", true) or (ArcCW.ConVars["aimassist"]:GetBool() and ply:GetInfoNum("arccw_aimassist_cl", 0) == 1))  then
        local cone = wep:GetBuff("AimAssist", true) and wep:GetBuff("AimAssist_Cone") or ArcCW.ConVars["aimassist_cone"]:GetFloat()
        local dist = wep:GetBuff("AimAssist", true) and wep:GetBuff("AimAssist_Distance") or ArcCW.ConVars["aimassist_distance"]:GetFloat()
        local inte = wep:GetBuff("AimAssist", true) and wep:GetBuff("AimAssist_Intensity") or ArcCW.ConVars["aimassist_intensity"]:GetFloat()
        local head = wep:GetBuff("AimAssist", true) and wep:GetBuff("AimAssist_Head") or ArcCW.ConVars["aimassist_head"]:GetBool()

        -- Check if current target is beyond tracking cone
        local tgt = ply.ArcCW_AATarget
        if IsValid(tgt) and (tgt_pos(tgt, head) - ply:EyePos()):Cross(ply:EyeAngles():Forward()):Length() > cone * 2 then ply.ArcCW_AATarget = nil end -- lost track

        -- Try to seek target if not exists
        tgt = ply.ArcCW_AATarget
        if !IsValid(tgt) or (tgt.Health and tgt:Health() <= 0) or util.QuickTrace(ply:EyePos(), tgt_pos(tgt, head) - ply:EyePos(), ply).Entity ~= tgt then
            local min_diff
            ply.ArcCW_AATarget = nil
            for _, ent in ipairs(ents.FindInCone(ply:EyePos(), ply:EyeAngles():Forward(), dist, math.cos(math.rad(cone)))) do
                if ent == ply or (!ent:IsNPC() and !ent:IsNextBot() and !ent:IsPlayer()) or ent:Health() <= 0
                        or (ent:IsPlayer() and ent:Team() ~= TEAM_UNASSIGNED and ent:Team() == ply:Team()) then continue end
                local tr = util.TraceLine({
                    start = ply:EyePos(),
                    endpos = tgt_pos(ent, head),
                    mask = MASK_SHOT,
                    filter = ply
                })
                if tr.Entity ~= ent then continue end
                local diff = (tgt_pos(ent, head) - ply:EyePos()):Cross(ply:EyeAngles():Forward()):Length()
                if !ply.ArcCW_AATarget or diff < min_diff then
                    ply.ArcCW_AATarget = ent
                    min_diff = diff
                end
            end
        end

        -- Aim towards target
        tgt = ply.ArcCW_AATarget
        if wep:GetState() ~= ArcCW.STATE_CUSTOMIZE and wep:GetState() ~= ArcCW.STATE_SPRINT and IsValid(tgt) then
            local ang = ucmd:GetViewAngles()
            local pos = tgt_pos(tgt, head)
            local tgt_ang = (pos - ply:EyePos()):Angle()
            local ang_diff = (pos - ply:EyePos()):Cross(ply:EyeAngles():Forward()):Length()
            if ang_diff > 0.1 then
                ang = LerpAngle(math.Clamp(inte / ang_diff, 0, 1), ang, tgt_ang)
                ucmd:SetViewAngles(ang)
            end
        end
    end

    if CLIENT and IsValid(wep) and wep.ArcCW then
        local ang2 = ucmd:GetViewAngles()
        local ft = (SysTime() - (lst or SysTime())) * GetConVar("host_timescale"):GetFloat()

        local recoil = Angle()
        recoil = recoil + (wep:GetBuff_Override("Override_RecoilDirection") or wep.RecoilDirection) * wep.RecoilAmount
        recoil = recoil + (wep:GetBuff_Override("Override_RecoilDirectionSide") or wep.RecoilDirectionSide) * wep.RecoilAmountSide
        ang2 = ang2 - (recoil * ft * 30)
        ucmd:SetViewAngles(ang2)

        local r = wep.RecoilAmount
        local rs = wep.RecoilAmountSide
        wep.RecoilAmount = math.Approach(wep.RecoilAmount, 0, ft * 20 * r)
        wep.RecoilAmountSide = math.Approach(wep.RecoilAmountSide, 0, ft * 20 * rs)
    end
    lst = SysTime()
end

hook.Add("StartCommand", "ArcCW_StartCommand", ArcCW.StartCommand)
--PATH lua/arccw/shared/sh_penetration.lua:
local mth      = math
local m_rand   = mth.Rand
local m_lerp   = Lerp

local function draw_debug()
    return (CLIENT or game.SinglePlayer()) and ArcCW.ConVars["dev_shootinfo"]:GetInt() >= 2
end

function ArcCW:GetRicochetChance(penleft, tr)
    if !ArcCW.ConVars["enable_ricochet"]:GetBool() then return 0 end
    local degree = tr.HitNormal:Dot((tr.StartPos - tr.HitPos):GetNormalized())

    local ricmult = ArcCW.PenTable[tr.MatType] or 1

    -- 0 at 1
    -- 100 at 0

    local c = Lerp(degree, math.min(penleft * ricmult * 2, 45), 0)

    -- c = c * ArcCW.ConVars["ricochet_mult"]:GetFloat()

    -- c = 100

    return math.Clamp(c, 0, 100)
end

function ArcCW:IsPenetrating(ptr, ptrent)
    if ptrent:IsWorld() then
        return ptr.Contents != CONTENTS_EMPTY
    elseif IsValid(ptrent) then

        local withinbounding = false
        local hboxset = ptrent:GetHitboxSet()
        local hitbone = ptrent:GetHitBoxBone(ptr.HitBox, hboxset)
        if hitbone then
            -- If we hit a hitbox, compare against that hitbox only
            local mins, maxs = ptrent:GetHitBoxBounds(ptr.HitBox, hboxset)
            local bonepos, boneang = ptrent:GetBonePosition(hitbone)
            mins = mins * 1.1
            maxs = maxs * 1.1
            local lpos = WorldToLocal(ptr.HitPos, ptr.HitNormal:Angle(), bonepos, boneang)

            withinbounding = lpos:WithinAABox(mins, maxs)
            if draw_debug() then
                debugoverlay.BoxAngles(bonepos, mins, maxs, boneang, 5, Color(255, 255, 255, 10))
            end
        elseif util.PointContents(ptr.HitPos) != CONTENTS_EMPTY then
            -- Otherwise default to rotated OBB
            local mins, maxs = ptrent:OBBMins(), ptrent:OBBMaxs()
            withinbounding = ptrent:WorldToLocal(ptr.HitPos):WithinAABox(mins, maxs)
            if draw_debug() then
                debugoverlay.BoxAngles(ptrent:GetPos(), mins, maxs, ptrent:GetAngles(), 5, Color(255, 255, 255, 10))
            end
        end
        if draw_debug() then
            debugoverlay.Cross(ptr.HitPos, withinbounding and 4 or 6, 5, withinbounding and Color(255, 255, 0) or Color(128, 255, 0), true)
        end


        return withinbounding
    end
    return false
end

function ArcCW:DoPenetration(tr, damage, bullet, penleft, physical, alreadypenned)
    local hitpos, startpos = tr.HitPos, tr.StartPos
    local dir    = (hitpos - startpos):GetNormalized()

    -- Added in e5adb54: "temporarily disable visual pen bullet until a solution is found"
    -- i don't remember the issue though
    -- if CLIENT then
    --     return
    -- end

    if tr.HitSky then return end

    if penleft <= 0 then return end

    alreadypenned = alreadypenned or {}

    local skip = false

    local trent = tr.Entity

    local penmult     = ArcCW.PenTable[tr.MatType] or 1
    local pentracelen = 4
    local curr_ent    = trent
    local startpen = penleft

    if !tr.HitWorld then penmult = penmult * 1.5 end

    if trent.mmRHAe then penmult = trent.mmRHAe end

    penmult = penmult * m_rand(0.9, 1.1) * m_rand(0.9, 1.1)

    local endpos = hitpos

    local td  = {}
    td.start  = endpos
    td.endpos = endpos + (dir * pentracelen)
    td.mask   = MASK_SHOT

    local ptr = util.TraceLine(td)

    local ptrent = ptr.Entity

    if ArcCW:GetRicochetChance(penleft, tr) > math.random(0, 100) then
        local degree = tr.HitNormal:Dot((tr.StartPos - tr.HitPos):GetNormalized())
        if degree == 0 or degree == 1 then return end
        sound.Play(ArcCW.RicochetSounds[math.random(#ArcCW.RicochetSounds)], tr.HitPos)
        if (tr.Normal:Length() == 0) then return end
        -- ACT3_ShootPBullet(tr.HitPos, ((2 * degree * tr.HitNormal) + tr.Normal) * (vel * math.Rand(0.25, 0.75)), owner, inflictor, bulletid, false, 1, penleft, dist)
        -- return

        dir = (2 * degree * tr.HitNormal) + tr.Normal
        ang = dir:Angle()
        ang = ang + (AngleRand() * (1 - degree) * 15 / 360)
        dir = ang:Forward()

        local d = math.Rand(0.25, 0.95)

        penleft = penleft * d

        skip = true
    end

    if !ArcCW.ConVars["enable_penetration"]:GetBool() then return end

    local factor = 1
    while !skip and penleft > 0 and ArcCW:IsPenetrating(ptr, ptrent) and ptr.Fraction < 1 and ptrent == curr_ent do
        penleft = penleft - (pentracelen * penmult) * factor

        -- Prevent extremely long penetrations (such as with glass)
        factor = factor * 1.05

        td.start  = endpos
        td.endpos = endpos + (dir * pentracelen)
        td.mask   = MASK_SHOT

        ptr = util.TraceLine(td)

        -- This is never called because curr_ent is never updated, genius
        -- Damage is handled in abullet.Callback anyways
        --[[]
        if ptrent != curr_ent then
            ptrent = ptr.Entity

            curr_ent = ptrent

            local ptrhp  = ptr.HitPos
            -- local dist   = (ptrhp - tr.StartPos):Length() * ArcCW.HUToM
            local pdelta = penleft / bullet.Penetration

            local dmg = DamageInfo()
            dmg:SetDamageType(bullet.DamageType)
            dmg:SetDamage(damage * pdelta)
            dmg:SetDamagePosition(ptrhp)

            if IsValid(ptrent) and !alreadypenned[ptrent:EntIndex()] then ptrent:TakeDamageInfo(dmg) end

            penmult = ArcCW.PenTable[ptr.MatType] or 1

            if !ptr.HitWorld then penmult = penmult * 1.5 end

            if ptrent.mmRHAe then penmult = ptrent.mmRHAe end

            penmult = penmult * m_rand(0.9, 1.1) * m_rand(0.9, 1.1)

            debugoverlay.Line(endpos, endpos + (dir * pentracelen), 10, Color(0, 0, 255), true)
        end
        ]]

        if draw_debug() then
            local pdeltap = penleft / bullet.Penetration
            local colorlr = m_lerp(pdeltap, 0, 255)

            debugoverlay.Line(endpos, endpos + (dir * pentracelen), 10, Color(255, colorlr, colorlr), true)
        end

        endpos = endpos + (dir * pentracelen)

        dir = dir + (VectorRand() * 0.025 * penmult)
    end

    if penleft > 0 then
        if (dir:Length() == 0) then return end

        -- Recover penetration lost from extra distance in the trace
        --penleft = penleft + ptr.Fraction * pentracelen / penmult

        if draw_debug() then
            debugoverlay.Text(endpos + Vector(0, 0, 2), "(" .. math.Round(penleft, 2) .. "mm)", 5)
        end

        local pdelta = penleft / bullet.Penetration

        local attacker = bullet.Attacker

        if !IsValid(attacker) then
            attacker = game.GetWorld()
        end

        if physical then
            if !ptr.HitWorld then
                alreadypenned[ptrent:EntIndex()] = true
            end

            local newbullet = {}
            newbullet.DamageMin = bullet.DamageMin or 1
            newbullet.DamageMax = bullet.DamageMax or 10
            newbullet.Range = bullet.Range or 100
            newbullet.DamageType = bullet.DamageType or DMG_BULLET
            newbullet.Penleft = penleft
            newbullet.Penetration = bullet.Penetration
            newbullet.Num = bullet.Num or 1
            newbullet.Pos = endpos
            local spd = bullet.Vel:Length()
            newbullet.Attacker = bullet.Attacker
            newbullet.Vel = dir * spd * (penleft / startpen)
            newbullet.Drag = bullet.Drag or 1
            newbullet.Travelled = bullet.Travelled + (endpos - hitpos):Length()
            newbullet.Damaged = alreadypenned
            newbullet.Profile = bullet.Profile or 1
            newbullet.Gravity = bullet.Gravity or 1
            newbullet.StartTime = bullet.StartTime or CurTime()
            newbullet.PhysBulletImpact = bullet.PhysBulletImpact or true
            newbullet.Weapon = bullet.Weapon

            if bit.band( util.PointContents( endpos ), CONTENTS_WATER ) == CONTENTS_WATER then
                newbullet.Underwater = true
            end

            table.insert(ArcCW.PhysBullets, newbullet)

            ArcCW:SendBullet(newbullet)
        else
            local abullet = {}
            abullet.Attacker = owner
            abullet.Dir      = dir
            abullet.Src      = endpos
            abullet.Spread   = Vector(0, 0, 0)
            abullet.Damage   = 0
            abullet.Num      = 1
            abullet.Force    = 0
            abullet.Distance = 33000
            abullet.Tracer   = 0
            --abullet.IgnoreEntity = ptr.Entity
            abullet.Callback = function(att, btr, dmg)
                local dist = bullet.Travelled * ArcCW.HUToM
                bullet.Travelled = bullet.Travelled + (btr.HitPos - endpos):Length()

                if alreadypenned[btr.Entity:EntIndex()] then
                    dmg:SetDamage(0)
                else
                    dmg:SetDamageType(bullet.DamageType)
                    dmg:SetDamage(bullet.Weapon:GetDamage(dist, true) * pdelta, true)
                end

                if draw_debug() then
                    local e = endpos + dir * (btr.HitPos - endpos):Length()
                    debugoverlay.Line(endpos, e, 10, Color(150, 150, 150), true)
                    debugoverlay.Cross(e, 3, 10, alreadypenned[btr.Entity:EntIndex()] and Color(0, 128, 255) or Color(255, 128, 0), true)
                    debugoverlay.Text(e, math.Round(penleft, 1) .. "mm", 10)
                end
                if (CLIENT or game.SinglePlayer()) and ArcCW.ConVars["dev_shootinfo"]:GetInt() >= 1 and IsValid(btr.Entity) and !alreadypenned[btr.Entity:EntIndex()] then
                    local str = string.format("%ddmg/%dm(%d%%)", math.floor(bullet.Weapon:GetDamage(dist)), dist, math.Round((1 - bullet.Weapon:GetRangeFraction(dist)) * 100))
                    debugoverlay.Text(btr.Entity:WorldSpaceCenter(), str, 5)
                end

                alreadypenned[btr.Entity:EntIndex()] = true

                ArcCW:DoPenetration(btr, damage, bullet, penleft, false, alreadypenned)

                -- if !game.SinglePlayer() and CLIENT then
                    local fx = EffectData()
                    fx:SetStart(tr.HitPos)
                    fx:SetOrigin(btr.HitPos)
                    util.Effect("arccw_ricochet", fx)
                -- end
            end

            attacker:FireBullets(abullet)
        end

        --[[
        local atk = bullet.Attacker

        local supbullet = {}
            supbullet.Src      = hitpos
            supbullet.Dir      = -dir
            supbullet.Damage   = 0
            supbullet.Distance = 8
            supbullet.Tracer   = 0
            supbullet.Force    = 0

            attacker:FireBullets(supbullet, true)
        ]]

    end
end

function ArcCW:BulletCallback(att, tr, dmg, bullet, phys)

    local wep = phys and bullet.Weapon or bullet
    local hitpos, hitnormal = tr.HitPos, tr.HitNormal
    local trent = tr.Entity

    local dist = (phys and bullet.Travelled or (hitpos - tr.StartPos):Length() ) * ArcCW.HUToM
    local pen  = IsValid(wep) and wep:GetBuff("Penetration") or bullet.Penleft

    if ArcCW.ConVars["dev_shootinfo"]:GetInt() >= 1 then
        debugoverlay.Cross(hitpos, 1, 5, SERVER and Color(255, 0, 0) or Color(0, 0, 255), true)
    end

    local randfactor = IsValid(wep) and wep:GetBuff("DamageRand") or 0
    local mul = 1
    if randfactor > 0 then
        mul = mul * math.Rand(1 - randfactor, 1 + randfactor)
    end

    local delta = !IsValid(wep) and math.Clamp(bullet.Travelled / (bullet.Range / ArcCW.HUToM), 0, 1) or wep:GetRangeFraction(dist)
    local calc_damage = (!IsValid(wep) and Lerp(delta, bullet.DamageMax, bullet.DamageMin) or wep:GetDamage(dist, true)) * mul
    local dmgtyp = !IsValid(wep)  and bullet.DamageType or wep:GetBuff_Override("Override_DamageType", wep.DamageType) or DMG_BULLET

    local hit   = {}
    hit.att     = att
    hit.tr      = tr
    hit.dmg     = dmg
    hit.range   = dist
    hit.damage  = calc_damage
    hit.dmgtype = dmgtyp
    hit.penleft = pen

    if IsValid(wep) then
        hit = wep:GetBuff_Hook("Hook_BulletHit", hit)

        if !hit then return end
    end

    if bullet.Damaged and bullet.Damaged[tr.Entity:EntIndex()] then
        dmg:SetDamage(0)
    else
        dmg:SetDamageType(hit.dmgtype)
        dmg:SetDamage(hit.damage)
    end

    local dmgtable
    if phys and IsValid(bullet.Weapon) then
        dmgtable = bullet.Weapon:GetBuff_Override("Override_BodyDamageMults", bullet.Weapon.BodyDamageMults)
    elseif IsValid(wep) then
        dmgtable = wep:GetBuff_Override("Override_BodyDamageMults", wep.BodyDamageMults)
    else
        dmgtable = bullet.BodyDamageMults
    end

    if dmgtable then
        local hg = tr.HitGroup
        local gam = ArcCW.LimbCompensation[engine.ActiveGamemode()] or ArcCW.LimbCompensation[1]
        if dmgtable[hg] then
            dmg:ScaleDamage(dmgtable[hg])

            -- cancelling gmod's stupid default values (but only if we have a multiplier)
            if ArcCW.ConVars["bodydamagemult_cancel"]:GetBool() and gam[hg] then dmg:ScaleDamage(gam[hg]) end
        end
    end

    if IsValid(att) and att:IsNPC() then
        dmg:ScaleDamage(wep:GetBuff_Mult("Mult_DamageNPC") or 1)
    end

    local effect = phys and bullet.ImpactEffect or (IsValid(wep) and wep:GetBuff_Override("Override_ImpactEffect", wep.ImpactEffect))
    local decal  = phys and bullet.ImpactDecal or (IsValid(wep) and wep:GetBuff_Override("Override_ImpactDecal", wep.ImpactDecal))

    -- Do our handling of damage types, if not ignored by the gun or some attachment
    if IsValid(wep) and !wep:GetBuff_Override("Override_DamageTypeHandled", wep.DamageTypeHandled) then
        local _, maxrng = wep:GetMinMaxRange()
        -- ignite target
        if dmg:IsDamageType(DMG_BURN) then
            if maxrng <= hit.range then
                dmg:SetDamageType(DMG_BULLET)
            else
                effect = "arccw_incendiaryround"
                decal  = "FadingScorch"

                if SERVER then
                    if vFireInstalled then
                        CreateVFire(trent, hitpos, hitnormal, hit.damage * 0.02)
                    else
                        trent:Ignite(1, 0)
                    end
                end
            end
        end
        -- explode target
        if dmg:IsDamageType(DMG_BLAST) then
            if dmg:GetDamage() >= 200 then
                effect = "Explosion"
                decal  = "Scorch"
            else
                effect = "arccw_incendiaryround"
                decal  = "FadingScorch"
            end
            dmg:ScaleDamage(0.5) -- half applied as explosion and half done to hit target
            util.BlastDamageInfo(dmg, tr.HitPos, math.Clamp(dmg:GetDamage(), 48, 256))
            dmg:SetDamageType(dmg:GetDamageType() - DMG_BLAST)
        end
        -- damage helicopters
        if dmg:IsDamageType(DMG_BULLET) and !dmg:IsDamageType(DMG_AIRBOAT)
                and IsValid(hit.tr.Entity) and hit.tr.Entity:GetClass() == "npc_helicopter" then
            dmg:SetDamageType(dmg:GetDamageType() + DMG_AIRBOAT)
            dmg:ScaleDamage(0.1) -- coostimizable?
        elseif dmg:GetDamageType() != DMG_BLAST and IsValid(hit.tr.Entity) and hit.tr.Entity:GetClass() == "npc_combinegunship" then
            dmg:SetDamageType(DMG_BLAST)
            dmg:ScaleDamage(0.05)
            -- there is a damage threshold of 50 for damaging gunships
            if dmg:GetDamage() < 50 and dmg:GetDamage() / 200 >= math.random() then
                dmg:SetDamage(50)
            end
        end

        -- pure DMG_BUCKSHOT do not create blood decals, somehow
        if dmg:GetDamageType() == DMG_BUCKSHOT then
            dmg:SetDamageType(dmg:GetDamageType() + DMG_BULLET)
        end
    end

    if SERVER and IsValid(wep) then wep:TryBustDoor(trent, dmg) end

    -- INCONSISTENCY: For physbullet, the entire bullet is copied; hitscan bullets reset some attributes in SWEP:DoPenetration (most notably damage)
    -- For now, we just reset some changes as a temporary workaround
    if !IsValid(wep) then
        bullet.Damage = calc_damage
        bullet.DamageType = dmgtyp
        ArcCW:DoPenetration(tr, hit.damage, bullet, bullet.Penleft, true, bullet.Damaged)
    else
        wep:DoPenetration(tr, hit.penleft, { [trent:EntIndex()] = true })
    end

    if effect then
        local ed = EffectData()
        ed:SetOrigin(hitpos)
        ed:SetNormal(hitnormal)
        util.Effect(effect, ed)
    end

    if decal then
        util.Decal(decal, tr.StartPos, hitpos - (hitnormal * 16), wep:GetOwner())
    end

    if (CLIENT or game.SinglePlayer()) and (!phys or SERVER) and ArcCW.ConVars["dev_shootinfo"]:GetInt() >= 1 then
        local str = string.format("%ddmg/%dm(%d%%)", math.floor(dmg:GetDamage()), dist, math.Round((1 - delta) * 100))
        debugoverlay.Text(hitpos, str, 10)
        print(str)
    end

    if IsValid(wep) then
        wep:GetBuff_Hook("Hook_PostBulletHit", hit)
    end
end
--PATH lua/arccw/shared/sh_util.lua:
return gluapack()()
--PATH lua/arccw/client/cl_convars.lua:
return gluapack()()
--PATH lua/arccw/client/cl_warnings.lua:
ArcCW.IncompatibleAddons = {
    -- My Hands 8.1
    ["847269692"] = "Causes viewmodel flickering, double viewmodel, may crash when customization menu opens",

    -- My Hands 8
    ["1890577397"] = "Causes viewmodel flickering, double viewmodel, may crash when customization menu opens",

    -- Quick Weapon Menu
    ["306149085"] = "Makes the customize menu mouse unable to appear.",

    -- Neurotec
    ["541434990"] = "Neurotec is ancient, half the base is missing, and it flat-out doesn't work. Causes all sorts of problems. For the love of god, let go.",

    -- Improved Combine NPCs
    ["476997621"] = "Causes issues with arms.",

    -- Realistic Bullet Overhaul
    ["1588705429"] = "Causes damage calculation to not work properly.",

    -- Quake/Half Life View bobbing
    ["378401390"] = "Causes most animations to not play properly.",

    -- Thirteen's Physgun Glow
    ["111249028"] = "Causes LHIK animations to flicker and not work properly.",

    -- Viewmodel Lagger
    ["1146104662"] = "Misaligns viewmodel in sights.",

    -- Viewmodel Lagger (fixed)
    ["2566560460"] = "Misaligns viewmodel in sights.",

    -- VTools
    ["DisplayDistancePlane"] = "Tool contains faulty hook, which has been removed to keep ArcCW functional.",
}

local t = ArcCW.GetTranslation

local function ScreenScaleMulti(input)
    return ScreenScale(input) * ArcCW.ConVars["hud_size"]:GetFloat()
end

function ArcCW.MakeIncompatibleWindow(tbl)
    local startTime = CurTime()

    local window = vgui.Create( "DFrame" )
    window:SetSize( ScrW() * 0.6, ScrH() * 0.6)
    window:Center()
    window:SetTitle("")
    window:SetDraggable(false)
    window:SetVisible(true)
    window:ShowCloseButton(false)
    window:MakePopup()
    window.Paint = function(self, w, h)
        surface.SetDrawColor(0, 0, 0, 200)
        surface.DrawRect(0, 0, w, h)
    end

    local title = vgui.Create("DLabel", window)
    title:SetSize(ScreenScaleMulti(256), ScreenScaleMulti(26))
    title:Dock(TOP)
    title:SetFont("ArcCW_24")
    title:SetText(t("incompatible.title"))
    title:DockMargin(ScreenScaleMulti(16), 0, ScreenScaleMulti(16), ScreenScaleMulti(8))

    local desc = vgui.Create("DLabel", window)
    desc:SetSize(ScreenScaleMulti(256), ScreenScaleMulti(12))
    desc:Dock(TOP)
    desc:DockMargin(ScreenScaleMulti(4), 0, ScreenScaleMulti(4), 0)
    desc:SetFont("ArcCW_12")
    desc:SetText(t("incompatible.line1"))
    desc:SetContentAlignment(5)

    local desc2 = vgui.Create("DLabel", window)
    desc2:SetSize(ScreenScaleMulti(256), ScreenScaleMulti(12))
    desc2:Dock(TOP)
    desc2:DockMargin(ScreenScaleMulti(4), 0, ScreenScaleMulti(4), ScreenScaleMulti(4))
    desc2:SetFont("ArcCW_12")
    desc2:SetText(t("incompatible.line2"))
    desc2:SetContentAlignment(5)

    local neverAgain = vgui.Create("DButton", window)
    neverAgain:SetSize(ScreenScaleMulti(256), ScreenScaleMulti(20))
    neverAgain:SetText("")
    neverAgain:Dock(BOTTOM)
    neverAgain:DockMargin(ScreenScaleMulti(48), ScreenScaleMulti(2), ScreenScaleMulti(48), ScreenScaleMulti(2))
    neverAgain.OnMousePressed = function(spaa, kc)
        if CurTime() > startTime + 10 then
            local simpleTbl = {}
            for _, v in pairs(tbl) do simpleTbl[tostring(v.wsid)] = true end
            file.Write("arccw_incompatible.txt", util.TableToJSON(simpleTbl))
            window:Close()
            window:Remove()
            chat.AddText(Color(255,0,0),t("incompatible.never.confirm"))
        end
    end
    neverAgain.Paint = function(spaa, w, h)
        local Bfg_col = Color(255, 255, 255, 255)
        local Bbg_col = Color(0, 0, 0, 200)

        if CurTime() > startTime + 10 and spaa:IsHovered() then
            Bbg_col = Color(255, 100, 100, 100)
            Bfg_col = Color(255, 255, 255, 255)
        end

        surface.SetDrawColor(Bbg_col)
        surface.DrawRect(0, 0, w, h)

        local txt = (CurTime() > startTime + 10) and (spaa:IsHovered() and t("incompatible.never.hover") or t("incompatible.never")) or t("incompatible.wait", {time = math.ceil(startTime + 10 - CurTime())})
        surface.SetTextColor(Bfg_col)
        surface.SetTextPos(ScreenScaleMulti(8), ScreenScaleMulti(2))
        surface.SetFont("ArcCW_12")
        surface.DrawText(txt)
    end

    local addonList = vgui.Create("DScrollPanel", window)
    addonList:SetText("")
    addonList:Dock(FILL)
    addonList.Paint = function(span, w, h) end
    local sbar = addonList:GetVBar()
    sbar.Paint = function() end
    sbar.btnUp.Paint = function(span, w, h) end
    sbar.btnDown.Paint = function(span, w, h) end
    sbar.btnGrip.Paint = function(span, w, h)
        surface.SetDrawColor(255, 255, 255, 255)
        surface.DrawRect(0, 0, w, h)
    end


    local accept = vgui.Create("DButton", window)
    accept:SetSize(ScreenScaleMulti(256), ScreenScaleMulti(20))
    accept:SetText("")
    accept:Dock(BOTTOM)
    accept:DockMargin(ScreenScaleMulti(48), ScreenScaleMulti(2), ScreenScaleMulti(48), ScreenScaleMulti(2))
    accept.OnMousePressed = function(spaa, kc)
        if CurTime() > startTime + 5 then
            window:Close()
            window:Remove()
        end
    end
    accept.Paint = function(spaa, w, h)
        local Bfg_col = Color(255, 255, 255, 255)
        local Bbg_col = Color(0, 0, 0, 200)

        if CurTime() > startTime + 5 and spaa:IsHovered() then
            Bbg_col = Color(255, 255, 255, 100)
            Bfg_col = Color(0, 0, 0, 255)
        end

        surface.SetDrawColor(Bbg_col)
        surface.DrawRect(0, 0, w, h)

        local txt = t("incompatible.confirm") .. ((CurTime() > startTime + 5) and "" or (" - " .. t("incompatible.wait", {time = math.ceil(startTime + 5 - CurTime())})))
        surface.SetTextColor(Bfg_col)
        surface.SetTextPos(ScreenScaleMulti(8), ScreenScaleMulti(2))
        surface.SetFont("ArcCW_12")
        surface.DrawText(txt)
    end

    for _, addon in pairs(tbl) do
        local addonBtn = vgui.Create("DButton", window)
        addonBtn:SetSize(ScreenScaleMulti(256), ScreenScaleMulti(28))
        addonBtn:Dock(TOP)
        addonBtn:DockMargin(ScreenScaleMulti(36), ScreenScaleMulti(2), ScreenScaleMulti(36), ScreenScaleMulti(2))
        addonBtn:SetFont("ArcCW_12")
        addonBtn:SetText("")
        addonBtn:SetContentAlignment(5)
        addonBtn.Paint = function(spaa, w, h)
            local Bfg_col = Color(255, 255, 255, 255)
            local Bbg_col = Color(0, 0, 0, 200)

            if spaa:IsHovered() then
                Bbg_col = Color(255, 255, 255, 100)
                Bfg_col = Color(0, 0, 0, 255)
            end

            surface.SetDrawColor(Bbg_col)
            surface.DrawRect(0, 0, w, h)

            local txt = addon.title
            surface.SetTextColor(Bfg_col)
            surface.SetTextPos(ScreenScaleMulti(18), ScreenScaleMulti(2))
            surface.SetFont("ArcCW_12")
            surface.DrawText(txt)

            local txt2 = ArcCW.IncompatibleAddons[tostring(addon.wsid)]
            surface.SetTextColor(Bfg_col)
            surface.SetTextPos(ScreenScaleMulti(18), ScreenScaleMulti(16))
            surface.SetFont("ArcCW_8")
            surface.DrawText(txt2)
        end
        addonBtn.OnMousePressed = function(spaa, kc)
            if addon.nourl then return end
            gui.OpenURL("https://steamcommunity.com/sharedfiles/filedetails/?id=" .. tostring(addon.wsid))
        end
    end
end

hook.Add("InitPostEntity", "ArcCW_CheckContent", function()
    for _, k in pairs(weapons.GetList()) do
        if weapons.IsBasedOn(k.ClassName, "arccw_base") and k.ClassName != "arccw_base" then
            return
        end
    end
    chat.AddText(Color(255,255,255), "You have installed the ArcCW base but have no weapons installed. Search the workshop for some!") -- Perhaps you want to install the CS+ pack?")
    --chat.AddText(Color(255,255,255), "https://steamcommunity.com/sharedfiles/filedetails/?id=2131058270")
end)
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/autorun/arccw_kraken_ammo.lua:
if CLIENT then
    matproxy.Add( {
        name = "ArcCW_DC15AMMO",
        init = function( self, mat, values )
            self.ResultTo = values.resultvar
            self.Prefix = values.prefixstring
        end,
        bind = function( self, mat, ent )
                local Place = self.ResultTo
                local texture

                if LocalPlayer():GetActiveWeapon() then
                    local OurWeapon = LocalPlayer():GetActiveWeapon()
                    if OurWeapon.ArcCW then
                        local KnowYourPlace = string.sub(string.reverse(OurWeapon:Clip1()), Place, Place)

                        if OurWeapon.BottomlessClip == true then
                            KnowYourPlace = string.sub(string.reverse(OurWeapon:Ammo1()), Place, Place)
                        end

                        if (OurWeapon:GetClass() == "arccw_apex_eva" and OurWeapon:GetMaxClip1() == 16) or (OurWeapon:GetClass() == "arccw_apex_mozambique" and OurWeapon:GetMaxClip1() == 12) then
                            KnowYourPlace = string.sub(string.reverse(math.ceil(OurWeapon:Clip1() / 2)), Place, Place)
                        end

                        local digits = string.format( tonumber(KnowYourPlace) or 0 )


                        texture = self.Prefix .. digits
                    end
                end

                if texture then
                    mat:SetTexture( "$basetexture", texture )
                end
        end
    } )
    matproxy.Add( {
        name = "ArcCW_CISAMMO",
        init = function( self, mat, values )
            self.ResultTo = values.resultvar
            self.Prefix = values.prefixstring
        end,
        bind = function( self, mat, ent )
                local Place = self.ResultTo
                local texture

                if LocalPlayer():GetActiveWeapon() then
                    local OurWeapon = LocalPlayer():GetActiveWeapon()
                    if OurWeapon.ArcCW then
                        local KnowYourPlace = string.sub(string.reverse(OurWeapon:Clip1()), Place, Place)

                        if OurWeapon.BottomlessClip == true then
                            KnowYourPlace = string.sub(string.reverse(OurWeapon:Ammo1()), Place, Place)
                        end

                        if (OurWeapon:GetClass() == "arccw_apex_eva" and OurWeapon:GetMaxClip1() == 16) or (OurWeapon:GetClass() == "arccw_apex_mozambique" and OurWeapon:GetMaxClip1() == 12) then
                            KnowYourPlace = string.sub(string.reverse(math.ceil(OurWeapon:Clip1() / 2)), Place, Place)
                        end

                        local digits = string.format( tonumber(KnowYourPlace) or 0 )


                        texture = self.Prefix .. digits
                    end
                end

                if texture then
                    mat:SetTexture( "$basetexture", texture )
                end
        end
    } )
    matproxy.Add( {
		name = "ArcCW_DC17MAMMO",
		init = function( self, mat, values )
			self.ResultTo = values.resultvar
			self.Prefix = values.prefixstring
		end,
		bind = function( self, mat, ent )
				local Place = self.ResultTo
				local texture
				
				if LocalPlayer():GetActiveWeapon() then
					local OurWeapon = LocalPlayer():GetActiveWeapon()
					local KnowYourPlace = string.sub(string.reverse(OurWeapon:Clip1()), Place, Place)
					local digits = string.format( tonumber(KnowYourPlace) or 0 )

					texture = self.Prefix .. digits
				end
				
				if texture then
					mat:SetTexture( "$basetexture", texture )
				else end
		end
	} )
end


--PATH lua/autorun/aussi_cgi104th_arms.lua:
return gluapack()()
--PATH lua/autorun/aussi_droid_pms.lua:
list.Set( "PlayerOptionsModel", "B1 Battle Droid (CGI)", "models/aussiwozzi/cgi/b1droids/b1_battledroid_pm.mdl" )
player_manager.AddValidModel( "B1 Battle Droid (CGI)", "models/aussiwozzi/cgi/b1droids/b1_battledroid_pm.mdl" )

list.Set( "PlayerOptionsModel", "B1 Battle Droid | Republic Commando (CGI)", "models/aussiwozzi/cgi/b1droids/b1_battledroid_rc_pm.mdl" )
player_manager.AddValidModel( "B1 Battle Droid | Republic Commando (CGI)", "models/aussiwozzi/cgi/b1droids/b1_battledroid_rc_pm.mdl" )

list.Set( "PlayerOptionsModel", "B1 Battle Droid Commander (CGI)", "models/aussiwozzi/cgi/b1droids/b1_battledroid_commander_pm.mdl" )
player_manager.AddValidModel( "B1 Battle Droid Commander (CGI)", "models/aussiwozzi/cgi/b1droids/b1_battledroid_commander_pm.mdl" )

list.Set( "PlayerOptionsModel", "B1 Rocket Droid (CGI)", "models/aussiwozzi/cgi/b1droids/b1_battledroid_rocket_pm.mdl" )
player_manager.AddValidModel( "B1 Rocket Droid (CGI)", "models/aussiwozzi/cgi/b1droids/b1_battledroid_rocket_pm.mdl" )

list.Set( "PlayerOptionsModel", "B1 Battle Droid Pilot (CGI)", "models/aussiwozzi/cgi/b1droids/b1_battledroid_pilot_pm.mdl" )
player_manager.AddValidModel( "B1 Battle Droid Pilot (CGI)", "models/aussiwozzi/cgi/b1droids/b1_battledroid_pilot_pm.mdl" )

list.Set( "PlayerOptionsModel", "B1 Battle Droid AAT Driver (CGI)", "models/aussiwozzi/cgi/b1droids/b1_battledroid_aat_pm.mdl" )
player_manager.AddValidModel( "B1 Battle Droid AAT Driver (CGI)", "models/aussiwozzi/cgi/b1droids/b1_battledroid_aat_pm.mdl" )

list.Set( "PlayerOptionsModel", "B1 Battle Droid Geonosis (CGI)", "models/aussiwozzi/cgi/b1droids/b1_battledroid_geonosis_pm.mdl" )
player_manager.AddValidModel( "B1 Battle Droid Geonosis (CGI)", "models/aussiwozzi/cgi/b1droids/b1_battledroid_geonosis_pm.mdl" )

list.Set( "PlayerOptionsModel", "B1 Battle Droid (CGI)", "models/aussiwozzi/cgi/b1droids/b1_battledroid_pm.mdl" )
player_manager.AddValidModel( "B1 Battle Droid (CGI)", "models/aussiwozzi/cgi/b1droids/b1_battledroid_pm.mdl" )

list.Set( "PlayerOptionsModel", "B1 Battle Droid Heavy (CGI)", "models/aussiwozzi/cgi/b1droids/b1_battledroid_heavy_pm.mdl" )
player_manager.AddValidModel( "B1 Battle Droid Heavy (CGI)", "models/aussiwozzi/cgi/b1droids/b1_battledroid_heavy_pm.mdl" )

list.Set( "PlayerOptionsModel", "B1 Battle Droid Marine (CGI)", "models/aussiwozzi/cgi/b1droids/b1_battledroid_marine_pm.mdl" )
player_manager.AddValidModel( "B1 Battle Droid Marine (CGI)", "models/aussiwozzi/cgi/b1droids/b1_battledroid_marine_pm.mdl" )

list.Set( "PlayerOptionsModel", "B1 Battle Droid OOM-10 (CGI)", "models/aussiwozzi/cgi/b1droids/b1_battledroid_oom10_pm.mdl" )
player_manager.AddValidModel( "B1 Battle Droid OOM-10 (CGI)", "models/aussiwozzi/cgi/b1droids/b1_battledroid_oom10_pm.mdl" )

list.Set( "PlayerOptionsModel", "B1 Battle Droid Security (CGI)", "models/aussiwozzi/cgi/b1droids/b1_battledroid_security_pm.mdl" )
player_manager.AddValidModel( "B1 Battle Droid Security (CGI)", "models/aussiwozzi/cgi/b1droids/b1_battledroid_security_pm.mdl" )

list.Set( "PlayerOptionsModel", "B1 Battle Droid Point Rain (CGI)", "models/aussiwozzi/cgi/b1droids/b1_battledroid_pointrain_pm.mdl" )
player_manager.AddValidModel( "B1 Battle Droid Point Rain (CGI)", "models/aussiwozzi/cgi/b1droids/b1_battledroid_pointrain_pm.mdl" )

list.Set( "PlayerOptionsModel", "B1 Battle Droid Snow Camo (CGI)", "models/aussiwozzi/cgi/b1droids/b1_battledroid_snow_pm.mdl" )
player_manager.AddValidModel( "B1 Battle Droid Snow Camo (CGI)", "models/aussiwozzi/cgi/b1droids/b1_battledroid_snow_pm.mdl" )

list.Set( "PlayerOptionsModel", "B1 Battle Droid Training (CGI)", "models/aussiwozzi/cgi/b1droids/b1_battledroid_training_pm.mdl" )
player_manager.AddValidModel( "B1 Battle Droid Training (CGI)", "models/aussiwozzi/cgi/b1droids/b1_battledroid_training_pm.mdl" )

list.Set( "PlayerOptionsModel", "B2 Super Battle Droid (CGI)", "models/aussiwozzi/cgi/b1droids/b2_battledroid_pm.mdl" )
player_manager.AddValidModel( "B2 Super Battle Droid (CGI)", "models/aussiwozzi/cgi/b1droids/b2_battledroid_pm.mdl" )

list.Set( "PlayerOptionsModel", "B2 Super Battle Droid Training (CGI)", "models/aussiwozzi/cgi/b1droids/b2_battledroid_training_pm.mdl" )
player_manager.AddValidModel( "B2 Super Battle Droid Training (CGI)", "models/aussiwozzi/cgi/b1droids/b2_battledroid_training_pm.mdl" )

list.Set( "PlayerOptionsModel", "B2 Super Battle Droid Camo (CGI)", "models/aussiwozzi/cgi/b1droids/b2_battledroid_camo_pm.mdl" )
player_manager.AddValidModel( "B2 Super Battle Droid Camo (CGI)", "models/aussiwozzi/cgi/b1droids/b2_battledroid_camo_pm.mdl" )

list.Set( "PlayerOptionsModel", "B2 Super Battle Droid Cannon (CGI)", "models/aussiwozzi/cgi/b1droids/b2_battledroid_cannon_pm.mdl" )
player_manager.AddValidModel( "B2 Super Battle Droid Cannon (CGI)", "models/aussiwozzi/cgi/b1droids/b2_battledroid_cannon_pm.mdl" )

list.Set( "PlayerOptionsModel", "B2 Super Battle Droid Snow (CGI)", "models/aussiwozzi/cgi/b1droids/b2_battledroid_snow_pm.mdl" )
player_manager.AddValidModel( "B2 Super Battle Droid Snow (CGI)", "models/aussiwozzi/cgi/b1droids/b2_battledroid_snow_pm.mdl" )

list.Set( "PlayerOptionsModel", "B2 Super Battle Droid Rocket (CGI)", "models/aussiwozzi/cgi/b1droids/b2_battledroid_rocket_pm.mdl" )
player_manager.AddValidModel( "B2 Super Battle Droid Rocket (CGI)", "models/aussiwozzi/cgi/b1droids/b2_battledroid_rocket_pm.mdl" )

--PATH addons/[admin] awarn3/lua/localizations/it.lua:
local language_code = "IT"

AWarn.Localization:RegisterLanguage(language_code, "Italiano")

//Credit: https://www.gmodstore.com/users/blasteralpha

AWarn.Localization:AddDefinition(language_code, "welcome1", "Benvenuto in AWarn3!")
AWarn.Localization:AddDefinition(language_code, "insufficientperms", "Permessi insufficienti per eseguire questo comando.")
AWarn.Localization:AddDefinition(language_code, "insufficientperms2", "Permessi insufficienti per visualizzare gli avvertimenti di questo giocatore.")
AWarn.Localization:AddDefinition(language_code, "commandnonexist", "Questo comando non esiste.")
AWarn.Localization:AddDefinition(language_code, "invalidtargetid", "Bersaglio o ID non valido.")
AWarn.Localization:AddDefinition(language_code, "invalidtarget", "Bersaglio non valido.")
AWarn.Localization:AddDefinition(language_code, "reasonrequired", " richiesta una ragione per l'avvertimento.")
AWarn.Localization:AddDefinition(language_code, "remove1activewarn", "Hai rimosso 1 avvertimento attivo da")
AWarn.Localization:AddDefinition(language_code, "deletedwarningid", "ID avvertimento eliminato")
AWarn.Localization:AddDefinition(language_code, "removeallwarnings", "Hai rimosso tutti gli avvertimenti da")
AWarn.Localization:AddDefinition(language_code, "deletedwarningsfor", "Eliminati tutti gli avvertimenti per")
AWarn.Localization:AddDefinition(language_code, "cantopenconsole", "Non puoi aprire il menu dalla console del server.")
AWarn.Localization:AddDefinition(language_code, "invalidoption", "Opzione non valida.")
AWarn.Localization:AddDefinition(language_code, "invalidoptionvaluetype", "Tipo di valore dell'opzione non valido.")
AWarn.Localization:AddDefinition(language_code, "optionsloaded", "Opzioni caricate!")
AWarn.Localization:AddDefinition(language_code, "nopunishment", "Nessuna punizione per questo numero di avvertimenti.")
AWarn.Localization:AddDefinition(language_code, "punishmentsloaded", "Punizioni caricate!")
AWarn.Localization:AddDefinition(language_code, "playernotallowedwarn", "Questo giocatore non pu essere avvertito.")
AWarn.Localization:AddDefinition(language_code, "warnmessage1", "Sei stato avvertito da %s per %s.")
AWarn.Localization:AddDefinition(language_code, "warnmessage2", "Hai avvertito %s per %s.")
AWarn.Localization:AddDefinition(language_code, "warnmessage3", "%s  stato avvertito da %s per %s.")
AWarn.Localization:AddDefinition(language_code, "warnmessage4", "Sei stato avvertito da %s.")
AWarn.Localization:AddDefinition(language_code, "warnmessage5", "Hai avvertito %s.")
AWarn.Localization:AddDefinition(language_code, "warnmessage6", "%s  stato avvertito da %s.")
AWarn.Localization:AddDefinition(language_code, "joinmessage1", "si  unito al server con avvertimenti.")
AWarn.Localization:AddDefinition(language_code, "joinmessage2", "Il loro ultimo avvertimento  stato il:")
AWarn.Localization:AddDefinition(language_code, "joinmessage3", "Bentornato sul server! Sembra che tu sia stato avvertito in passato.")
AWarn.Localization:AddDefinition(language_code, "joinmessage4", "Puoi visualizzare i tuoi avvertimenti in qualsiasi momento digitando")
AWarn.Localization:AddDefinition(language_code, "joinmessage5", "Il giocatore si sta unendo con avvertimenti attivi:")
AWarn.Localization:AddDefinition(language_code, "closemenu", "Chiudi Menu")
AWarn.Localization:AddDefinition(language_code, "searchplayers", "Cerca Giocatori")
AWarn.Localization:AddDefinition(language_code, "viewwarnings", "Avvertimenti")
AWarn.Localization:AddDefinition(language_code, "configuration", "Configurazione")
AWarn.Localization:AddDefinition(language_code, "clientoptions", "Opzioni Utente")
AWarn.Localization:AddDefinition(language_code, "serveroptions", "Opzioni Server")
AWarn.Localization:AddDefinition(language_code, "colorcustomization", "Personalizzazione Colore")
AWarn.Localization:AddDefinition(language_code, "colorselection", "Selezione Colore")
AWarn.Localization:AddDefinition(language_code, "languageconfiguration", "Personalizzazione Lingua")
AWarn.Localization:AddDefinition(language_code, "selectlanguage", "Seleziona una Lingua")
AWarn.Localization:AddDefinition(language_code, "enablekickpunish", "Abilita Punizione di Espulsione")
AWarn.Localization:AddDefinition(language_code, "enablebanpunish", "Abilita Punizione di Ban")
AWarn.Localization:AddDefinition(language_code, "enabledecay", "Abilita Decadimento degli Avvertimenti Attivi")
AWarn.Localization:AddDefinition(language_code, "resetafterban", "Reimposta gli Avvertimenti Attivi dopo il Ban")
AWarn.Localization:AddDefinition(language_code, "allowwarnadmins", "Permetti di Avvertire gli Amministratori")
AWarn.Localization:AddDefinition(language_code, "clientjoinmessage", "Mostra il numero di avvertimenti al giocatore al momento dell'accesso")
AWarn.Localization:AddDefinition(language_code, "adminjoinmessage", "Mostra un messaggio agli amministratori quando un giocatore si unisce con avvertimenti")
AWarn.Localization:AddDefinition(language_code, "pressenter", "Premi Invio per Salvare la Modifica")
AWarn.Localization:AddDefinition(language_code, "entertosave", "Invio per Salvare")
AWarn.Localization:AddDefinition(language_code, "chatprefix", "Prefisso Chat")
AWarn.Localization:AddDefinition(language_code, "warningdecayrate", "Velocit di Decadimento degli Avvertimenti")
AWarn.Localization:AddDefinition(language_code, "serverlanguage", "Lingua del Server")
AWarn.Localization:AddDefinition(language_code, "punishmentsconfiguration", "Configurazione Punizioni")
AWarn.Localization:AddDefinition(language_code, "addpunishment", "Aggiungi Punizione")
AWarn.Localization:AddDefinition(language_code, "warnings", "Avvertimenti")
AWarn.Localization:AddDefinition(language_code, "punishtype", "Tipo di Punizione")
AWarn.Localization:AddDefinition(language_code, "punishlength", "Durata della Punizione")
AWarn.Localization:AddDefinition(language_code, "playermessage", "Messaggio al Giocatore")
AWarn.Localization:AddDefinition(language_code, "playername", "Nome Giocatore")
AWarn.Localization:AddDefinition(language_code, "messagetoplayer", "Messaggio al Giocatore")
AWarn.Localization:AddDefinition(language_code, "servermessage", "Messaggio del Server")
AWarn.Localization:AddDefinition(language_code, "messagetoserver", "Messaggio al Server")
AWarn.Localization:AddDefinition(language_code, "deletewarning", "Elimina Avvertimento")
AWarn.Localization:AddDefinition(language_code, "punishaddmenu", "Menu Aggiunta Punizione")
AWarn.Localization:AddDefinition(language_code, "inminutes", "In Minuti")
AWarn.Localization:AddDefinition(language_code, "0equalperma", "0 = Permanente")
AWarn.Localization:AddDefinition(language_code, "use%", "Usa %s per mostrare il nome del giocatore")
AWarn.Localization:AddDefinition(language_code, "setdefault", "Imposta come Predefinito")
AWarn.Localization:AddDefinition(language_code, "showingownwarnings", "Visualizzazione dei Propri Avvertimenti")
AWarn.Localization:AddDefinition(language_code, "warnedby", "Avvertito Da")
AWarn.Localization:AddDefinition(language_code, "warningserver", "Server di Avvertimento")
AWarn.Localization:AddDefinition(language_code, "warningreason", "Motivo dell'Avvertimento")
AWarn.Localization:AddDefinition(language_code, "warningdate", "Data dell'Avvertimento")
AWarn.Localization:AddDefinition(language_code, "nothing", "NESSUNO")
AWarn.Localization:AddDefinition(language_code, "submit", "Invia")
AWarn.Localization:AddDefinition(language_code, "connectedplayers", "Giocatori Connessi")
AWarn.Localization:AddDefinition(language_code, "displaywarningsfor", "Visualizzazione degli Avvertimenti per")
AWarn.Localization:AddDefinition(language_code, "activewarnings", "Avvertimenti Attivi")
AWarn.Localization:AddDefinition(language_code, "selectedplayernowarnings", "Il giocatore selezionato non ha avvertimenti registrati.")
AWarn.Localization:AddDefinition(language_code, "selectplayerseewarnings", "Seleziona un giocatore per vedere i suoi avvertimenti.")
AWarn.Localization:AddDefinition(language_code, "warnplayer", "Avverti Giocatore")
AWarn.Localization:AddDefinition(language_code, "reduceactiveby1", "Riduci gli avvertimenti attivi di 1")
AWarn.Localization:AddDefinition(language_code, "playerwarningmenu", "Menu di Avvertimento del Giocatore")
AWarn.Localization:AddDefinition(language_code, "playersearchmenu", "Menu di Ricerca Giocatore")
AWarn.Localization:AddDefinition(language_code, "warningplayer", "Giocatore da Avvertire")
AWarn.Localization:AddDefinition(language_code, "excludeplayers", "Escludi giocatori senza precedenti di avvertimenti")
AWarn.Localization:AddDefinition(language_code, "searchforplayers", "Cerca giocatori per nome o SteamID64")
AWarn.Localization:AddDefinition(language_code, "name", "Nome")
AWarn.Localization:AddDefinition(language_code, "lastplayed", "Ultimo Giocato")
AWarn.Localization:AddDefinition(language_code, "lastwarned", "Ultimo Avvertimento")
AWarn.Localization:AddDefinition(language_code, "never", "Mai")
AWarn.Localization:AddDefinition(language_code, "playerid", "ID Giocatore")
AWarn.Localization:AddDefinition(language_code, "lookupplayerwarnings", "Cerca gli avvertimenti di questo giocatore")
AWarn.Localization:AddDefinition(language_code, "servername", "Nome del Server")
AWarn.Localization:AddDefinition(language_code, "punishmentoptions", "Punizioni")
AWarn.Localization:AddDefinition(language_code, "kickpunishdescription", "Se abilitato, AWarn3 pu espellere i giocatori dal server come punizione.")
AWarn.Localization:AddDefinition(language_code, "banpunishdescription", "Se abilitato, AWarn3 pu bannare i giocatori dal server come punizione.")
AWarn.Localization:AddDefinition(language_code, "enabledecaydescription", "Se abilitato, gli avvertimenti attivi decadranno col tempo.")
AWarn.Localization:AddDefinition(language_code, "reasonrequireddescription", "Se abilitato, gli amministratori dovranno fornire una ragione per il loro avvertimento.")
AWarn.Localization:AddDefinition(language_code, "resetafterbandescription", "Se abilitato, gli avvertimenti attivi di un utente si resetteranno a 0 dopo essere stati bannati da AWarn3.")
AWarn.Localization:AddDefinition(language_code, "logevents", "Registra gli Eventi di Avvertimento.")
AWarn.Localization:AddDefinition(language_code, "logeventsdescription", "Se abilitato, le azioni all'interno di AWarn3 saranno registrate in un file di testo.")
AWarn.Localization:AddDefinition(language_code, "allowwarnadminsdescription", "Se abilitato, gli amministratori potranno avvertire altri amministratori.")
AWarn.Localization:AddDefinition(language_code, "clientjoinmessagedescription", "Se abilitato, gli utenti che si uniscono al server vedranno un messaggio in chat se hanno avvertimenti.")
AWarn.Localization:AddDefinition(language_code, "adminjoinmessagedescription", "Se abilitato, gli amministratori del server vedranno quando un giocatore con avvertimenti si unisce.")
AWarn.Localization:AddDefinition(language_code, "chatprefixdescription", "Il comando chat utilizzato per i comandi AWarn3. Predefinito: !warn")
AWarn.Localization:AddDefinition(language_code, "warningdecayratedescription", "Il tempo (in minuti) che un giocatore deve essere connesso affinch un avvertimento attivo decada.")
AWarn.Localization:AddDefinition(language_code, "servernamedescription", "Il nome di questo server. Utile per configurazioni con pi server.")
AWarn.Localization:AddDefinition(language_code, "selectlanguagedescription", "Questa  la lingua in cui verranno visualizzati i messaggi del server.")
AWarn.Localization:AddDefinition(language_code, "theme", "Tema Interfaccia")
AWarn.Localization:AddDefinition(language_code, "themeselect", "Seleziona Tema")
AWarn.Localization:AddDefinition(language_code, "punishgroup", "Gruppo di Punizione")
AWarn.Localization:AddDefinition(language_code, "grouptoset", "Gruppo da Impostare")
AWarn.Localization:AddDefinition(language_code, "viewnotes", "Visualizza Note del Giocatore")
AWarn.Localization:AddDefinition(language_code, "playernotes", "Note del Giocatore")
AWarn.Localization:AddDefinition(language_code, "interfacecustomizations", "Personalizzazioni Interfaccia")
AWarn.Localization:AddDefinition(language_code, "enableblur", "Abilita Sfocatura dello Sfondo")
AWarn.Localization:AddDefinition(language_code, "chooseapreset", "Scegli un preset (Opzionale)")
AWarn.Localization:AddDefinition(language_code, "warningpresets", "Preset")
AWarn.Localization:AddDefinition(language_code, "addeditpreset", "Aggiungi/Modifica Preset")
AWarn.Localization:AddDefinition(language_code, "presetname", "Nome del Preset")
AWarn.Localization:AddDefinition(language_code, "presetreason", "Ragione del Preset")
--PATH addons/[admin] awarn3/lua/localizations/pt-br.lua:
local language_code = "PT-BR"

AWarn.Localization:RegisterLanguage( language_code, "Portugus brasileiro" )

-- Credit: https://www.gmodstore.com/users/saigonosamurai

AWarn.Localization:AddDefinition( language_code, "welcome1", 					"Bem-vindo ao AWarn3!" )
AWarn.Localization:AddDefinition( language_code, "insufficientperms", 			"Voc no tem permisso para executar este comando." )
AWarn.Localization:AddDefinition( language_code, "insufficientperms2", 			"Voc no tem permisso para ver as advertncias deste jogador." )
AWarn.Localization:AddDefinition( language_code, "commandnonexist", 			"Este comando no existe." )
AWarn.Localization:AddDefinition( language_code, "invalidtargetid", 			"ID ou alvo invlido." )
AWarn.Localization:AddDefinition( language_code, "invalidtarget", 				"Alvo invlido." )
AWarn.Localization:AddDefinition( language_code, "reasonrequired", 				"Um motivo para a advertncia  necessrio." )
AWarn.Localization:AddDefinition( language_code, "remove1activewarn", 			"Voc removeu uma advertncia ativa de" )
AWarn.Localization:AddDefinition( language_code, "deletedwarningid", 			"ID de advertncia apagado" )
AWarn.Localization:AddDefinition( language_code, "removeallwarnings", 			"Voc limpou as advertncias de" )
AWarn.Localization:AddDefinition( language_code, "deletedwarningsfor", 			"Todas advertncias apagadas para" )
AWarn.Localization:AddDefinition( language_code, "cantopenconsole", 			"Voc no pode abrir o menu pelo console." )
AWarn.Localization:AddDefinition( language_code, "invalidoption", 				"Opo invlida." )
AWarn.Localization:AddDefinition( language_code, "invalidoptionvaluetype",		"Tipo de valor invlido para opo." )
AWarn.Localization:AddDefinition( language_code, "optionsloaded",				"Opes carregadas!" )
AWarn.Localization:AddDefinition( language_code, "nopunishment",				"Sem punio para esta quantidade de advertncias." )
AWarn.Localization:AddDefinition( language_code, "punishmentsloaded",			"Punies carregadas!" )
AWarn.Localization:AddDefinition( language_code, "playernotallowedwarn",		"Este jogador no pode ser advertido." )
AWarn.Localization:AddDefinition( language_code, "warnmessage1",				"Voc foi advertido por %s pelo motivo %s." )
AWarn.Localization:AddDefinition( language_code, "warnmessage2",				"Voc advertiu %s por %s" )
AWarn.Localization:AddDefinition( language_code, "warnmessage3",				"%s foi advertido por %s pelo motivo %s" )
AWarn.Localization:AddDefinition( language_code, "warnmessage4",				"Voc foi advertido por %s." )
AWarn.Localization:AddDefinition( language_code, "warnmessage5",				"Voc foi advertido %s." )
AWarn.Localization:AddDefinition( language_code, "warnmessage6",				"%s foi advertido por %s." )
AWarn.Localization:AddDefinition( language_code, "joinmessage1",				"entrou no servidor com advertncias." )
AWarn.Localization:AddDefinition( language_code, "joinmessage2",				"Sua ltima advertncia foi em:" )
AWarn.Localization:AddDefinition( language_code, "joinmessage3",				"Bem vindo de volta! Parece que voc foi advertido anteriormente." )
AWarn.Localization:AddDefinition( language_code, "joinmessage4",				"Voc pode ver suas advertncias digitando" )
AWarn.Localization:AddDefinition( language_code, "joinmessage5",				"Um jogador est entrando com advertncias ativas: " )
AWarn.Localization:AddDefinition( language_code, "clientjoinmessage",			"Exibir contagem de advertncias para o jogador ao entrar" )
AWarn.Localization:AddDefinition( language_code, "adminjoinmessage",			"Exibir mensagem aos administradores quando um jogador com advertncias entrar" )
AWarn.Localization:AddDefinition( language_code, "closemenu",					"Fechar menu" )
AWarn.Localization:AddDefinition( language_code, "searchplayers",				"Procurar jogadores" )
AWarn.Localization:AddDefinition( language_code, "viewwarnings",				"Ver advertncias" )
AWarn.Localization:AddDefinition( language_code, "configuration",				"Configurao" )
AWarn.Localization:AddDefinition( language_code, "clientoptions",				"Opes de usurio" )
AWarn.Localization:AddDefinition( language_code, "serveroptions",				"Opes do servidor" )
AWarn.Localization:AddDefinition( language_code, "colorcustomization",			"Customizao de cores" )
AWarn.Localization:AddDefinition( language_code, "colorselection",				"Seleo de cores" )
AWarn.Localization:AddDefinition( language_code, "languageconfiguration",		"Customizao de linguagem" )
AWarn.Localization:AddDefinition( language_code, "selectlanguage",				"Selecionar idioma" )
AWarn.Localization:AddDefinition( language_code, "enablekickpunish",			"Habilitar punio por kick" )
AWarn.Localization:AddDefinition( language_code, "enablebanpunish",				"Habilitar punio por ban" )
AWarn.Localization:AddDefinition( language_code, "enabledecay",					"Habilitar expirao de advertncias ativas" )
AWarn.Localization:AddDefinition( language_code, "resetafterban",				"Expirar advertncias ativas ps banimento" )
AWarn.Localization:AddDefinition( language_code, "allowwarnadmins",				"Habilitar advertncias em admins" )
AWarn.Localization:AddDefinition( language_code, "pressenter",					"Enter para salvar mudanas" )
AWarn.Localization:AddDefinition( language_code, "entertosave",					"Enter para salvar" )
AWarn.Localization:AddDefinition( language_code, "chatprefix",					"Prefixo de chat" )
AWarn.Localization:AddDefinition( language_code, "warningdecayrate",			"Taxa de expirao de advertncias (em minutos)" )
AWarn.Localization:AddDefinition( language_code, "serverlanguage",				"Idioma do servidor" )
AWarn.Localization:AddDefinition( language_code, "punishmentsconfiguration",	"Configurao de punies" )
AWarn.Localization:AddDefinition( language_code, "addpunishment",				"Adicionar punio" )
AWarn.Localization:AddDefinition( language_code, "warnings",					"Advertncias" )
AWarn.Localization:AddDefinition( language_code, "punishtype",					"Tipo de punio" )
AWarn.Localization:AddDefinition( language_code, "punishlength",				"Durao da punio" )
AWarn.Localization:AddDefinition( language_code, "playermessage",				"Mensagem do jogador" )
AWarn.Localization:AddDefinition( language_code, "playername",					"Nome do jogador" )
AWarn.Localization:AddDefinition( language_code, "messagetoplayer",				"Mensagem para o jogador" )
AWarn.Localization:AddDefinition( language_code, "servermessage",				"Mensagem do servidor" )
AWarn.Localization:AddDefinition( language_code, "messagetoserver",				"Mensagem para o servidor" )
AWarn.Localization:AddDefinition( language_code, "deletewarning",				"Apagar advertncia" )
AWarn.Localization:AddDefinition( language_code, "punishaddmenu",				"Menu de adio de punies" )
AWarn.Localization:AddDefinition( language_code, "inminutes",					"Em minutos" )
AWarn.Localization:AddDefinition( language_code, "0equalperma",					"0 = Permanente" )
AWarn.Localization:AddDefinition( language_code, "use%",						"Use %s para ver o nome do jogador" )
AWarn.Localization:AddDefinition( language_code, "setdefault",					"Usar padro" )
AWarn.Localization:AddDefinition( language_code, "showingownwarnings",			"Mostrando suas advertncias" )
AWarn.Localization:AddDefinition( language_code, "warnedby",					"Advertido por" )
AWarn.Localization:AddDefinition( language_code, "warningserver",				"Advertido em" )
AWarn.Localization:AddDefinition( language_code, "warningreason",				"Motivo da advertncia" )
AWarn.Localization:AddDefinition( language_code, "warningdate",					"Data da advertncia" )
AWarn.Localization:AddDefinition( language_code, "nothing",						"NADA" )
AWarn.Localization:AddDefinition( language_code, "submit",						"Enviar" )
AWarn.Localization:AddDefinition( language_code, "connectedplayers",			"Jogadores conectados" )
AWarn.Localization:AddDefinition( language_code, "displaywarningsfor",			"Mostrando advertncias de" )
AWarn.Localization:AddDefinition( language_code, "activewarnings",				"Advertncias ativas" )
AWarn.Localization:AddDefinition( language_code, "selectedplayernowarnings",	"Este jogador no possui advertncias." )
AWarn.Localization:AddDefinition( language_code, "selectplayerseewarnings",		"Selecione um jogador para ver suas advertncias." )
AWarn.Localization:AddDefinition( language_code, "warnplayer",					"Advertir jogador" )
AWarn.Localization:AddDefinition( language_code, "reduceactiveby1",				"Reduzir advertncias ativas em 1" )
AWarn.Localization:AddDefinition( language_code, "playerwarningmenu",			"Player Warning Menu" )
AWarn.Localization:AddDefinition( language_code, "playersearchmenu",			"Menu de busca" )
AWarn.Localization:AddDefinition( language_code, "warningplayer",				"Jogador advertido" )
AWarn.Localization:AddDefinition( language_code, "excludeplayers",				"Excluir jogadores sem advertncias" )
AWarn.Localization:AddDefinition( language_code, "searchforplayers",			"Procurar jogadores por nome ou SteamID64" )
AWarn.Localization:AddDefinition( language_code, "name",						"Nome" )
AWarn.Localization:AddDefinition( language_code, "lastplayed",					"Visto por ltimo" )
AWarn.Localization:AddDefinition( language_code, "lastwarned",					"ltima advertncia" )
AWarn.Localization:AddDefinition( language_code, "never",						"Nunca" )
AWarn.Localization:AddDefinition( language_code, "playerid",					"ID do jogador" )
AWarn.Localization:AddDefinition( language_code, "lookupplayerwarnings",		"Procurar por advertncias do jogador" )
AWarn.Localization:AddDefinition( language_code, "servername",					"Nome do servidor" )

AWarn.Localization:AddDefinition( language_code, "punishmentoptions",			"Punies" )
AWarn.Localization:AddDefinition( language_code, "kickpunishdescription",		"Se habilitado, o AWarn3 poder expulsar jogadores como punio." )
AWarn.Localization:AddDefinition( language_code, "banpunishdescription",		"Se habilitado, o AWarn3 poder banir jogadores como punio." )
AWarn.Localization:AddDefinition( language_code, "enabledecaydescription",		"Se habilitado, advertncias ativas iro expirar com o tempo." )
AWarn.Localization:AddDefinition( language_code, "reasonrequireddescription",	"Se habilitado, administradores devero fornecer uma razo para a advertncia." )
AWarn.Localization:AddDefinition( language_code, "resetafterbandescription",	"Se habilitado, a users active warnings will reset to 0 aps ser banido pelo AWarn3." )
AWarn.Localization:AddDefinition( language_code, "logevents",					"Registrar Eventos de Advertncias." )
AWarn.Localization:AddDefinition( language_code, "logeventsdescription",		"Se habilitado, aes do AWarn3 sero registradas para um arquivo de texto." )
AWarn.Localization:AddDefinition( language_code, "allowwarnadminsdescription",	"Se habilitado, administradores podero advertir outros administradores." )
AWarn.Localization:AddDefinition( language_code, "clientjoinmessagedescription","Se habilitado, jogadores, ao entrar no servidor, sero avisados sobre suas advertncias." )
AWarn.Localization:AddDefinition( language_code, "adminjoinmessagedescription",	"Se habilitado, administradores no servidor vero quando algum jogador com advertncias entrar." )
AWarn.Localization:AddDefinition( language_code, "chatprefixdescription",		"O comando padro do AWarn3 usado para o menu de comandos. Padro: !warn" )
AWarn.Localization:AddDefinition( language_code, "warningdecayratedescription",	"O tempo (em minutos) que um jogador precisa estar conectado para que uma advertncia ativa expire." )
AWarn.Localization:AddDefinition( language_code, "servernamedescription",		"O nome deste servidor. Isto  til para configuraes mltiplas de servidores" )
AWarn.Localization:AddDefinition( language_code, "selectlanguagedescription",	"Este  o idioma em que as mensagens sero exibidas no servidor." )
AWarn.Localization:AddDefinition( language_code, "theme",						"Tema da Interface" )
AWarn.Localization:AddDefinition( language_code, "themeselect",					"Selecione o Tema" )
AWarn.Localization:AddDefinition( language_code, "punishgroup",					"Grupo de Punio" )
AWarn.Localization:AddDefinition( language_code, "grouptoset",					"Grupo para Definir" )
AWarn.Localization:AddDefinition( language_code, "viewnotes",					"Ver Notas de Jogador" )
AWarn.Localization:AddDefinition( language_code, "playernotes",					"Notas do Jogador" )

AWarn.Localization:AddDefinition( language_code, "interfacecustomizations",		"Customizaes da Interface" )
AWarn.Localization:AddDefinition( language_code, "enableblur",					"Habilitar desfoque do fundo" )
AWarn.Localization:AddDefinition( language_code, "chooseapreset",				"Selecionar predefinio (Opcional)" )
AWarn.Localization:AddDefinition( language_code, "warningpresets",				"Predefinies" )
AWarn.Localization:AddDefinition( language_code, "addeditpreset",				"Adicionar/Editar predefinies" )
AWarn.Localization:AddDefinition( language_code, "presetname",					"Nome da predefinio" )
AWarn.Localization:AddDefinition( language_code, "presetreason",				"Razo da predefinio" )

--PATH addons/[admin] awarn3/lua/localizations/pt.lua:
return gluapack()()
--PATH addons/[admin] awarn3/lua/localizations/ru.lua:
return gluapack()()
--PATH addons/[admin] awarn3/lua/localizations/tr.lua:
return gluapack()()
--PATH addons/[admin] awarn3/lua/includes/awarn3_concommands.lua:
AddCSLuaFile()
--[[
      __          __              ____  
     /\ \        / /             |___ \ 
    /  \ \  /\  / /_ _ _ __ _ __   __) |
   / /\ \ \/  \/ / _` | '__| '_ \ |__ < 
  / ____ \  /\  / (_| | |  | | | |___) |
 /_/    \_\/  \/ \__,_|_|  |_| |_|____/ 

	AWarn3 by Mr.President
]]

MsgC( AWARN3_STATECOLOR, "[AWarn3] ", AWARN3_WHITE, "Loading ConCommands Module\n" )

local AWarn3Commands = {}

function AWarn:RegisterConCommand( CCTbl )
	AWarn3Commands[ CCTbl.command ] = CCTbl
end

function AWarn:GetConCommand( command )
	return AWarn3Commands[ command ]
end

local function AutoComplete()
	local tbl = {}
	for k, v in pairs( AWarn3Commands ) do
		table.insert( tbl, "awarn " .. k )
	end
	return tbl
end

concommand.Add( "awarn", function( pl, cmd, args )
	if AWarn3Commands[ args[1] ] then
		if not AWarn3Commands[ args[1] ].permissioncheck( pl ) then
			MsgC( AWARN3_STATECOLOR, "[AWarn3] ", AWARN3_WHITE, AWarn.Localization:GetTranslation( "insufficientperms" ) .. "\n")
			return 
		end
		local new_args = table.Copy( args )
		table.remove( new_args, 1 )
		if #new_args < AWarn3Commands[ args[1] ].requiredargs then
			MsgC( AWARN3_STATECOLOR, "[AWarn3] ", AWARN3_WHITE, AWarn.Localization:GetTranslation( "insufficientperms" ) .. "\n")
			MsgC( AWARN3_WARNING, AWarn3Commands[ args[1] ].help .. "\n")
		else
			AWarn3Commands[ args[1] ].commandfunction( pl, new_args )
		end
	else
		MsgC( AWARN3_STATECOLOR, "[AWarn3] ", AWARN3_WHITE, AWarn.Localization:GetTranslation( "commandnonexist" ) .. "\n")
	end
end, AutoComplete )


local CC = {}
CC.command = "warn"
CC.help = "Warn a player. Usage is :: awarn warn <player name> <reason>"
CC.requiredargs = 1
CC.permissioncheck = function( pl )
	if SERVER then
		return AWarn:CheckPermission( pl, "awarn_warn" )
	else
		return true
	end
end
CC.commandfunction = function( pl, args )
	local target_pl = AWarn:GetIDFromNameOrSteamID( args[1] )
	local WarningReason = table.concat( args, " ", 2, #args )
	if WarningReason == "" then WarningReason = nil end
	if target_pl == "0" then
		MsgC( AWARN3_STATECOLOR, "[AWarn3] ", AWARN3_WHITE, AWarn.Localization:GetTranslation( "invalidtargetid" ) .. "\n")
		return
	end
	if target_pl == nil then
		MsgC( AWARN3_STATECOLOR, "[AWarn3] ", AWARN3_WHITE, AWarn.Localization:GetTranslation( "invalidtarget" ) .. "\n")
		return
	end
	
	
	if SERVER then
		if IsValid( pl ) then
			if not WarningReason and AWarn:GetOption( "awarn_reasonrequired" ) then
				MsgC( AWARN3_STATECOLOR, "[AWarn3] ", AWARN3_WHITE, AWarn.Localization:GetTranslation( "reasonrequired" ) .. "\n")
				AWarn:SendChatMessage( { AWarn.Localization:GetTranslation( "reasonrequired" ) }, pl )
				return
			end
			AWarn:CreateWarningID( target_pl, AWarn:SteamID64( pl ), WarningReason )
		else
			if not WarningReason and AWarn:GetOption( "awarn_reasonrequired" ) then
				MsgC( AWARN3_STATECOLOR, "[AWarn3] ", AWARN3_WHITE, AWarn.Localization:GetTranslation( "reasonrequired" ) .. "\n")
				return
			end
			AWarn:CreateWarningID( target_pl, "[CONSOLE]", WarningReason )
		end
	else
		--Clientside Execution
		AWarn:CreateWarningID( target_pl, LocalPlayer():SteamID64(), WarningReason )
	end
end
AWarn:RegisterConCommand( CC )



local CC = {}
CC.command = "removewarn"
CC.help = "Removes a single active warning from a player. Usage is :: awarn removewarn <player name>"
CC.requiredargs = 1
CC.permissioncheck = function( pl )
	if SERVER then
		return AWarn:CheckPermission( pl, "awarn_remove" )
	else
		return true
	end
end
CC.commandfunction = function( pl, args )
	local target_pl = AWarn:GetIDFromNameOrSteamID( args[1] )
	if target_pl == nil then
		MsgC( AWARN3_STATECOLOR, "[AWarn3] ", AWARN3_WHITE, AWarn.Localization:GetTranslation( "invalidtarget" ) .. "\n")
		return
	end
	if target_pl == "0" then
		MsgC( AWARN3_STATECOLOR, "[AWarn3] ", AWARN3_WHITE, AWarn.Localization:GetTranslation( "invalidtargetid" ) .. "\n")
		return
	end
	
	
	if SERVER then
		if IsValid( pl ) then
			AWarn:SendChatMessage( { AWarn.Localization:GetTranslation( "remove1activewarn" ) .. " ", Color(255,0,0), target_pl }, pl )
		else
			MsgC( AWARN3_STATECOLOR, "[AWarn3] ", AWARN3_WHITE, AWarn.Localization:GetTranslation( "remove1activewarn" ) .. " ", Color(255,0,0), target_pl, "\n")
		end
		AWarn:AddActiveWarning( target_pl, -1 )		
	else
		--ClientsideExecution
		AWarn:AddActiveWarning( target_pl, -1 )
	end
	
end
AWarn:RegisterConCommand( CC )


local CC = {}
CC.command = "deletewarnings"
CC.help = " Deletes all warnings from a player. Usage is :: awarn deletewarnings <player name>"
CC.requiredargs = 1
CC.permissioncheck = function( pl )
	if SERVER then
		return AWarn:CheckPermission( pl, "awarn_delete" )
	else
		return true
	end
end
CC.commandfunction = function( pl, args )
	local target_pl = AWarn:GetIDFromNameOrSteamID( args[1] )
	if target_pl == nil then
		MsgC( AWARN3_STATECOLOR, "[AWarn3] ", AWARN3_WHITE, AWarn.Localization:GetTranslation( "invalidtarget" ) .. "\n")
		return
	end
	if target_pl == "0" then
		MsgC( AWARN3_STATECOLOR, "[AWarn3] ", AWARN3_WHITE, AWarn.Localization:GetTranslation( "invalidtargetid" ) .. "\n")
		return
	end
	
	if SERVER then
		if IsValid( pl ) then
			AWarn:SendChatMessage( { AWarn.Localization:GetTranslation( "removeallwarnings" ) .. " ", Color(255,0,0), target_pl }, pl )
		else
			MsgC( AWARN3_STATECOLOR, "[AWarn3] ", AWARN3_WHITE, AWarn.Localization:GetTranslation( "removeallwarnings" ) .. " ", Color(255,0,0), target_pl, "\n")
		end
		AWarn:DeleteAllPlayerWarnings( target_pl )
	else
		--ClientsideExecution
		AWarn:DeleteAllPlayerWarnings( target_pl )
	end
end
AWarn:RegisterConCommand( CC )


local CC = {}
CC.command = "menu"
CC.help = " Opens the AWarn3 Menu for viewing warnings."
CC.requiredargs = 0
CC.permissioncheck = function( pl )
	return true
end
CC.commandfunction = function( pl, args )
	if SERVER then
		if IsValid( pl ) then
			AWarn:OpenMenu( pl )
		else
			MsgC( AWARN3_STATECOLOR, "[AWarn3] ", AWARN3_WHITE, AWarn.Localization:GetTranslation( "cantopenconsole" ) .."\n")
		end
	else
		--ClientsideExecution
		AWarn:OpenMenu()
	end
end
AWarn:RegisterConCommand( CC )


local CC = {}
CC.command = "resettodefault"
CC.help = " Deletes ALL data and resets AWarn3 to factory settings. WARNING: This can not be undone and deletes EVERYTHING."
CC.requiredargs = 0
CC.permissioncheck = function( pl )
	return true
end
CC.commandfunction = function( pl, args )
	if SERVER then
		if IsValid( pl ) then
			if pl:IsListenServerHost() then
				AWarn:ResetToDefaults()
			else
				MsgC( AWARN3_STATECOLOR, "[AWarn3] ", AWARN3_WHITE, "This can only be run on the server console.\n")
			end
		else
			AWarn:ResetToDefaults()
		end
	else
		MsgC( AWARN3_STATECOLOR, "[AWarn3] ", AWARN3_WHITE, "This can only be run on the server console.\n")
	end
end
AWarn:RegisterConCommand( CC )
--PATH addons/[admin] awarn3/lua/includes/awarn3_themes.lua:
return gluapack()()
--PATH lua/autorun/bigboss.lua:
return gluapack()()
--PATH addons/[misc] bodygroupr/lua/bodyman/bodyman_client.lua:
include("bodyman/bodyman_config.lua")



function BODYMAN:UseEnglish()
	BODYMAN.HelpText = BODYMAN.HelpText_En
	BODYMAN.ClosetHelpText = BODYMAN.ClosetHelpText_En
	BODYMAN.strings = BODYMAN.strings_en
	BODYMAN.ClosetName = BODYMAN.ClosetName_En
	BODYMAN.CurrentLang = "En"
end

function BODYMAN:UseFrench()
	BODYMAN.HelpText = BODYMAN.HelpText_Fr
	BODYMAN.ClosetHelpText = BODYMAN.ClosetHelpText_Fr
	BODYMAN.strings = BODYMAN.strings_fr
	BODYMAN.ClosetName = BODYMAN.ClosetName_Fr
	BODYMAN.CurrentLang = "Fr"
end

function BODYMAN:UseGerman()
	BODYMAN.HelpText = BODYMAN.HelpText_De
	BODYMAN.ClosetHelpText = BODYMAN.ClosetHelpText_De
	BODYMAN.strings = BODYMAN.strings_de
	BODYMAN.ClosetName = BODYMAN.ClosetName_De
	BODYMAN.CurrentLang = "De"
end

BODYMAN.CurrentLang = "En"
BODYMAN:UseEnglish() -- default to english


if BODYMAN.French == true then
	BODYMAN:UseFrench()
end

if BODYMAN.German == true then
	BODYMAN:UseGerman()
end

surface.CreateFont("Bodygroups_Small", {
	font = "Roboto",
	size = 18,
	antialias = true,
	weight = 800
})

surface.CreateFont("Bodygroups_Medium", {
	font = "Roboto",
	size = 24,
	antialias = true,
	weight = 800
})

surface.CreateFont("Bodygroups_Large", {
	font = "Roboto",
	size = 42,
	antialias = true,
	weight = 800
})

function InverseLerp( pos, p1, p2 )

	local range = 0
	range = p2-p1

	if range == 0 then return 1 end

	return ((pos - p1)/range)

end

include("bodyman/arizard_derma.lua")

function BODYMAN:Chat( msg )
	chat.AddText(HexColor("#3498db"), "[bodyGroupr] ", Color(255,255,255), msg)
end

net.Receive("bodyman_chatprint", function()
	local msg = net.ReadString()
	BODYMAN:Chat( msg )
	-- 76561198045938915
end)

BODYMAN.MenuIsOpen = false
BODYMAN.Menu = nil

timer.Create("IsBodyGrouprMenuStillValid", 3, 0, function()
	if BODYMAN.MenuIsOpen == true and BODYMAN.ClosetsOnly == true then
		if not BODYMAN:CloseEnoughCloset( LocalPlayer() ) then
			if IsValid(BODYMAN.Menu) then
				BODYMAN.Menu:Close()
			end
		end
	end
end)

function BODYMAN:OpenMenu()

	self.MenuIsOpen = true

	if self.ClosetsOnly == true then
		if self:CloseEnoughCloset( LocalPlayer() ) == false then
			return false
		end
	end

	local frame = vgui.Create("arizard_window")
	frame:SetSize( ScrW()*.75, ScrH()*.85 )
	frame:Center()
	frame:SetPrimaryColor( HexColor("#3498db") )
	frame:SetSecondaryColor( HexColor("#ecf0f1", 4) )
	frame:SetTitle("bodyGroupr")
	frame:MakePopup()

	self.Menu = frame

	function frame:OnClose()
		BODYMAN.MenuIsOpen = false
	end

	local pmodel = vgui.Create("DModelPanel", frame)
	pmodel:SetSize( pmodel:GetParent():GetWide()*(2/3) - 8, pmodel:GetParent():GetTall() - 40 )
	pmodel:SetPos( 4, 32 )

	pmodel:SetModel( LocalPlayer():GetModel() )

	pmodel:SetLookAt( Vector(0,0,72/2) )
	pmodel:SetCamPos( Vector(64,0,72/2))
	--pmodel:SetLookAng( Angle(0,0,0) )

	pmodel.Entity:SetEyeTarget( pmodel.Entity:GetPos() + Vector(200,0,64) )

	pmodel:SetAmbientLight( Color(10,15,50) )
	pmodel:SetDirectionalLight( BOX_TOP, Color(220,190,100) )

	pmodel.rot = 110
	pmodel.fov = 20
	pmodel:SetFOV( pmodel.fov )
	pmodel.dragging = false -- left click
	pmodel.dragging2 = false -- right click
	pmodel.ux = 0
	pmodel.uy = 0
	pmodel.spinmul = 0.4
	pmodel.zoommul = 0.09

	pmodel.xmod = 0
	pmodel.ymod = 0

	BODYMAN.ClientModelPanel = pmodel

	pmodel.Entity:SetSkin( LocalPlayer():GetSkin() )

	-- set pmodel's bodygroups
	local curgroups = LocalPlayer():GetBodyGroups()
	--PrintTable( curgroups )

	for k,v in pairs( curgroups ) do
		local ent = pmodel.Entity
		local cur_bgid = LocalPlayer():GetBodygroup( v.id )
		ent:SetBodygroup( v.id, cur_bgid )
	end

	function pmodel.Entity:GetPlayerColor()
		return LocalPlayer():GetPlayerColor()
	end

	function pmodel:PaintOver( w, h )
		--surface.SetDrawColor( Color(255,255,255) )
		--surface.DrawOutlinedRect(0,0,w,h)
		ArizardShadowText(BODYMAN.HelpText, "Bodygroups_Medium", 0,0, Color(255,255,255), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP, 1 )
	end

	function pmodel:LayoutEntity( ent )

		local newrot = self.rot
		local newfov = self:GetFOV()

		if self.dragging == true then
			newrot = self.rot + (gui.MouseX() - self.ux)*self.spinmul
			newfov = self.fov + (self.uy - gui.MouseY()) * self.zoommul
			if newfov < 20 then newfov = 20 end
			if newfov > 75 then newfov = 75 end
		end

		local newxmod, newymod = self.xmod, self.ymod

		if self.dragging2 == true then
			newxmod = self.xmod + (self.ux - gui.MouseX())*0.02
			newymod = self.ymod + (self.uy - gui.MouseY())*0.02
		end

		newxmod = math.Clamp( newxmod, -16, 16 )
		newymod = math.Clamp( newymod, -16, 16 )

		ent:SetAngles( Angle(0,0,0) )
		self:SetFOV( newfov )

		-- calculate if we should look at the face
		local height = 72/2
		-- fov between 20 and 75,
		-- height between 72/2 and 72
		local frac = InverseLerp( newfov, 75, 20 )
		height = Lerp( frac, 72/2, 64 )

		-- calculate look ang
		local norm = (self:GetCamPos() - Vector(0,0,64))
		norm:Normalize()
		local lookAng = norm:Angle()

		self:SetLookAt( Vector(0,0,height-(2*frac) ) - Vector( 0, 0, newymod*2*(1-frac) ) - lookAng:Right()*newxmod*2*(1-frac) )
		self:SetCamPos( Vector( 64*math.sin( newrot * (math.pi/180)), 64*math.cos( newrot * (math.pi/180)), height + 4*(1-frac)) - Vector( 0, 0, newymod*2*(1-frac) ) - lookAng:Right()*newxmod*2*(1-frac) )

	end

	function pmodel:OnMousePressed( k )
		self.ux = gui.MouseX()
		self.uy = gui.MouseY()
		self.dragging = (k == MOUSE_LEFT) or false 
		self.dragging2 = (k == MOUSE_RIGHT) or false 
	end

	function pmodel:OnMouseReleased( k )
		if self.dragging == true then
			self.rot = self.rot + (gui.MouseX() - self.ux)*self.spinmul
			self.fov = self.fov + (self.uy - gui.MouseY()) * self.zoommul
			self.fov = math.Clamp( self.fov, 20, 75 )
		end

		if self.dragging2 == true then
			self.xmod = self.xmod + (self.ux - gui.MouseX())*0.02
			self.ymod = self.ymod + (self.uy - gui.MouseY())*0.02

			self.xmod = math.Clamp( self.xmod, -16, 16 )
			self.ymod = math.Clamp( self.ymod, -16, 16 )
		end

		self.dragging = false 
		self.dragging2 = false
	end

	function pmodel:OnCursorExited()
		if self.dragging == true or self.dragging2 == true then
			self:OnMouseReleased()
		end
	end

	-- now for the controls
	local cpan = vgui.Create("DPanel", frame)
	cpan:SetSize( cpan:GetParent():GetWide()*(1/3)-4, cpan:GetParent():GetTall() - 44 )
	cpan:SetPos( 4+4+cpan:GetParent():GetWide()*(2/3)-8, 32)
	function cpan:Paint() end

	local cpanscroll = vgui.Create("DScrollPanel", cpan)
	cpanscroll:SetSize( cpanscroll:GetParent():GetWide(), cpanscroll:GetParent():GetTall() - 32 )
	cpanscroll:SetPos(0,0)

	function cpanscroll:Paint(w,h)
		-- surface.SetDrawColor(Color(255,0,0))
		-- surface.DrawRect(0,0,w,h)
	end

	-- style the scroll button:
	local sbar = cpanscroll:GetVBar()
	sbar:SetWide( 6 )
	function sbar:Paint( w, h )
	end
	function sbar.btnUp:Paint( w, h )
	end
	function sbar.btnDown:Paint( w, h )
	end
	function sbar.btnGrip:Paint( w, h )
		draw.RoundedBox((w-1)/2, 1,0,w-1,h,Color(0,0,0,200))
	end

	local cpanlist = vgui.Create("DIconLayout", cpanscroll)
	cpanlist:SetSize( cpanscroll:GetWide()-8, cpanscroll:GetTall() - 8 )
	cpanlist:SetPos( 4, 4 )
	cpanlist:SetSpaceX( 4 )
	cpanlist:SetSpaceY( 4 )

	langselect = vgui.Create("DComboBox", cpan)
	langselect:SetSize(cpanscroll:GetWide(), 28)
	langselect:SetPos(0,cpanscroll:GetTall()+4)

	langselect:AddChoice("Polski",BODYMAN.UseEnglish,BODYMAN.CurrentLang == "En")
	langselect:AddChoice("Francais",BODYMAN.UseFrench,BODYMAN.CurrentLang == "Fr")
	langselect:AddChoice("Deutsche",BODYMAN.UseGerman,BODYMAN.CurrentLang == "De")

	function langselect:OnSelect(index, value, data)
		data()
		BODYMAN:RefreshAppearanceMenu( )
	end

	self.cpanlist = cpanlist
	self.cpanscroll = cpanscroll



	self:RefreshAppearanceMenu( )
	
end

function BODYMAN:RefreshAppearanceMenu( )

	local cpanlist, cpanscroll = self.cpanlist, self.cpanscroll

	if ( not IsValid( cpanlist ) ) or ( not IsValid( cpanscroll ) ) then return end

	-- reload the bodygropes
	self.ClientModelPanel.Entity:SetSkin( LocalPlayer():GetSkin() )

	local job = LocalPlayer():getJobTable()

	-- set pmodel's bodygroups
	local curgroups = LocalPlayer():GetBodyGroups()
	--PrintTable( curgroups )
	local bgroups = job.bodygroups or {}

	for k,v in pairs( curgroups ) do
		local ent = self.ClientModelPanel.Entity
		local cur_bgid = LocalPlayer():GetBodygroup( v.id )

		if bgroups[v.name] then
			if not table.HasValue(bgroups[v.name], cur_bgid) then
				cur_bgid = table.Random(bgroups[v.name])
			end
		end

		ent:SetBodygroup( v.id, cur_bgid )
	end

	self.ClientModelPanel.Entity:SetEyeTarget( self.ClientModelPanel.Entity:GetPos() + Vector(200,0,64) )

	cpanlist:Clear()

	local title = cpanlist:Add( "DLabel" )
	title:SetText( BODYMAN.strings.Appearance )
	title:SetFont("Bodygroups_Large")
	title:SetTextColor( HexColor("#ffffff") )
	title:SizeToContents()
	title:SetWide( cpanscroll:GetWide() )
	title:SetExpensiveShadow(1,Color(0,0,0))

	-- -- thiccnes sliders
	-- local thicctitle = cpanlist:Add("DLabel")
	-- thicctitle:SetText( BODYMAN.strings.Physique)
	-- thicctitle:SetFont("Bodygroups_Medium")
	-- thicctitle:SetTextColor( HexColor("#eeeeee") )
	-- thicctitle:SizeToContents()
	-- thicctitle:SetWide( cpanscroll:GetWide() )
	-- thicctitle:SetExpensiveShadow(1,Color(0,0,0))
	--[[
	local bones = {
		["Chest"] = {"ValveBiped.Bip01_Spine2","ValveBiped.Bip01_R_Trapezius","ValveBiped.Bip01_L_Trapezius"},
		["Gut"] = {"ValveBiped.Bip01_Spine","ValveBiped.Bip01_Spine1","ValveBiped.Bip01_Pelvis"},
		["Forearms"] = {"ValveBiped.Bip01_R_Forearm","ValveBiped.Bip01_L_Forearm"},
		["Biceps"] = {"ValveBiped.Bip01_R_Bicep","ValveBiped.Bip01_L_Bicep","ValveBiped.Bip01_R_Shoulder","ValveBiped.Bip01_R_Shoulder","ValveBiped.Bip01_R_UpperArm","ValveBiped.Bip01_L_UpperArm","ValveBiped.Bip01_R_Clavicle","ValveBiped.Bip01_L_Clavicle"},
		["Thighs"] = {"ValveBiped.Bip01_R_Thigh","ValveBiped.Bip01_L_Thigh"},
		["Calves"] = {"ValveBiped.Bip01_R_Calf","ValveBiped.Bip01_L_Calf"},
	}

	local bonescales = {
		["Chest"] = 1,
		["Gut"] = 1,
		["Forearms"] = 1,
		["Biceps"] = 1,
		["Thighs"] = 1,
		["Calves"] = 1,
	}

	bonescales = BODYMAN:GetBoneScales(LocalPlayer())

	local preview = self.ClientModelPanel.Entity
	for k,v in pairs(bones) do
		local slid = cpanlist:Add("DNumSlider")
		slid:SetText(k)
		slid:SetWide(cpanscroll:GetWide()-16)
		slid:SetMin(0.75)
		slid:SetMax(1.25)
		slid:SetValue(bonescales[k])
		slid.v = v

		function slid:OnValueChanged(val)
			for _, v2 in pairs(self.v) do
				local bid = preview:LookupBone(v2)
				if bid then
					preview:ManipulateBoneScale(bid,Vector(1,1,1)*val)
				end
				BODYMAN:CopyBoneScales(preview, LocalPlayer())
				BODYMAN:SendBoneScales(LocalPlayer())
			end
		end

		slid:OnValueChanged(bonescales[k])
	end ]]

	-- do models
	local playermodels = job.model

	if type( playermodels ) == "table" then
		local modeltitle = cpanlist:Add("DLabel")
		modeltitle:SetText( BODYMAN.strings.Playermodels )
		modeltitle:SetFont("Bodygroups_Medium")
		modeltitle:SetTextColor( HexColor("#eeeeee") )
		modeltitle:SizeToContents()
		modeltitle:SetWide( cpanscroll:GetWide() )
		modeltitle:SetExpensiveShadow(1,Color(0,0,0))

		for k=1,#playermodels do
			local mdl = playermodels[k]

			local btn = cpanlist:Add( "arizard_button" )
			btn:SetWide( (cpanlist:GetWide()-8)/2 - 8 )
			btn:SetTall( 28 )

			-- reduce the filepath to it's model name, without extension
			local args = string.Split( mdl, "/" )
			local mdlname = args[ #args ]
			mdlname = string.sub( mdlname, 1, -5)

			btn:SetText( mdlname )
			btn.mdlpath = mdl
			btn.mdlidx = k

			btn:SetColors( HexColor("#2980b9"), HexColor("#3498db"))

			function btn:DoClick()
				BODYMAN.ClientModelPanel:SetModel( self.mdlpath )

				net.Start("bodyman_model_change")
				net.WriteInt( self.mdlidx, 8 )
				net.SendToServer()

				BODYMAN:RefreshAppearanceMenu( )
			end
		end

	end

	-- do skins
	
	local skintable = {}
	local vipskintable = {}

	if job.skins then
		skintable = table.Copy( job.skins )
	else
		skintable = {}
		for i=0,LocalPlayer():SkinCount()-1 do
			table.insert( skintable, i )
		end
	end

	if job.vipskins then
		vipskintable = table.Copy(job.vipskins)
		if BODYMAN:IsVip(LocalPlayer()) then
			for k,v in ipairs(vipskintable) do
				table.insert(skintable,v)
			end
		end
	end
	
	
	if skintable ~= {} then
		local skintitle = cpanlist:Add("DLabel")
		skintitle:SetText( BODYMAN.strings.Skins )
		skintitle:SetFont("Bodygroups_Medium")
		skintitle:SetTextColor( HexColor("#eeeeee") )
		skintitle:SizeToContents()
		skintitle:SetWide( cpanscroll:GetWide() )
		skintitle:SetExpensiveShadow(1,Color(0,0,0))

		for k,i in ipairs(skintable) do
			if BODYMAN:HasSkin( LocalPlayer(), i ) then
				local btn = cpanlist:Add( "arizard_button" )
				btn:SetSize( cpanlist:GetWide()/4 - 16, 28 )
				btn:SetText( tostring(i) )
				btn.skinNumber = i

				btn:SetColors( HexColor("#2980b9"), HexColor("#3498db"))

				function btn:DoClick()
					print("Attempting to switch skin", self.skinNumber)
					BODYMAN.ClientModelPanel.Entity:SetSkin( self.skinNumber )

					net.Start("skins_change")
					net.WriteInt(self.skinNumber, 8)
					net.SendToServer()
				end
			end
		end

		local spacer = cpanlist:Add("DPanel")
		spacer:SetSize(cpanlist:GetWide(), 2)
		function spacer:Paint() end
	end

	local allowedbodygroups = {}
	
	if job.bodygroups then
		allowedbodygroups = job.bodygroups 
	else
		local ply = LocalPlayer()
		for i = 2, #ply:GetBodyGroups() do
			local bg = ply:GetBodyGroups()[i]
			if bg then
				for k,v in pairs( bg ) do
					if k == "name" then
						allowedbodygroups[v] = {}
						for k2, v2 in pairs( bg["submodels"] ) do
							table.insert( allowedbodygroups[v], k2 )
						end
					end
				end	
			end
		end

		--PrintTable( allowedbodygroups )
	end

	local vipallowedbodygroups = {}
	
	if job.vipbodygroups then
		vipallowedbodygroups = job.vipbodygroups

	end

	if allowedbodygroups ~= {} then
		local bgtitle = cpanlist:Add("DLabel")
		bgtitle:SetText( BODYMAN.strings.Bodygroups )
		bgtitle:SetFont("Bodygroups_Medium")
		bgtitle:SetTextColor( HexColor("#eeeeee") )
		bgtitle:SizeToContents()
		bgtitle:SetWide( cpanscroll:GetWide() )
		bgtitle:SetExpensiveShadow(1,Color(0,0,0))

		for bgname, bgtable in pairs( allowedbodygroups ) do
			local bglabel = cpanlist:Add("DLabel")
			bglabel:SetFont("Bodygroups_Small")
			bglabel:SetText(string.upper(bgname))
			bglabel:SetTextColor( HexColor("#dddddd") )
			bglabel:SizeToContents()
			bglabel:SetWide( cpanscroll:GetWide() )
			bglabel:SetExpensiveShadow(1,Color(0,0,0))

			for _,i in ipairs(bgtable) do

				if BODYMAN:HasBodyGroup( LocalPlayer(), bgname, i ) then

					local btn = cpanlist:Add( "arizard_button" )
					btn:SetSize( cpanlist:GetWide()/4 - 16, 28 )
					btn:SetText( tostring(i) )
					btn.bg_name = bgname
					btn.bg_num = i

					btn:SetColors( HexColor("#2980b9"), HexColor("#3498db"))

					function btn:DoClick()
						local ent = BODYMAN.ClientModelPanel.Entity
						local bgid = ent:FindBodygroupByName( self.bg_name )
						if bgid ~= -1 then
							ent:SetBodygroup( bgid, self.bg_num )

							net.Start("bodygroups_change")
							net.WriteTable( { bgid, self.bg_num } )
							net.SendToServer()
						end
					end

				end
			end

			local spacer = cpanlist:Add("DPanel")
			spacer:SetSize(cpanlist:GetWide(), 2)
			function spacer:Paint() end

		end

		local spacer = cpanlist:Add("DPanel")
		spacer:SetSize(cpanlist:GetWide(), 2)
		function spacer:Paint() end
	end
end

concommand.Add("bodyman_openmenu", function(ply, cmd, args)
	if BODYMAN:CanAccessCommand(ply, cmd) then
		BODYMAN:OpenMenu()
	end
end)

-- add to context menu
list.Set( "DesktopWindows", "BodyManEditor", {

	icon = "icon16/user_gray.png",
	title = "bodyGroupr",
	width = 100,
	height = 100,
	onewindow = true,
	init = function( icon, window )
		window:Close()		
		RunConsoleCommand("bodyman_openmenu")
	end

	}
)

--if LocalPlayer():IsSuperAdmin() then
list.Set( "DesktopWindows", "BodyManAdmin", {

	icon = "icon16/user_gray.png",
	title = "bodyGroupr Admin Menu",
	width = 100,
	height = 100,
	onewindow = true,
	init = function( icon, window )
		window:Close()
		RunConsoleCommand("bodyman_adminmenu")
	end

	}
)
--end

function BODYMAN:AdminMenu()
	local frame = vgui.Create("arizard_window")
	frame:SetSize( 456, 300 ) -- usable: 348 x 556
	frame:Center()
	frame:SetPrimaryColor( HexColor("#3498db") )
	frame:SetSecondaryColor( HexColor("#ecf0f1", 4) )
	frame:SetTitle("bodyGroupr Admin Menu")
	frame:MakePopup()

	frame.scr = vgui.Create("DScrollPanel", frame)
	frame.scr:SetSize( frame:GetWide() - 8, frame:GetTall()-44 )
	frame.scr:SetPos(4,32)

	frame.scr.list = vgui.Create("DIconLayout", frame.scr)
	frame.scr.list:SetSize( frame.scr:GetWide()-8, frame.scr:GetTall() - 8 )
	frame.scr.list:SetPos( 4, 4 )
	frame.scr.list:SetSpaceX( 4 )
	frame.scr.list:SetSpaceY( 4 )

	-- style the scroll button:
	local sbar = frame.scr:GetVBar()
	sbar:SetWide( 6 )
	function sbar:Paint( w, h )
	end
	function sbar.btnUp:Paint( w, h )
	end
	function sbar.btnDown:Paint( w, h )
	end
	function sbar.btnGrip:Paint( w, h )
		draw.RoundedBox((w-1)/2, 1,0,w-1,h,Color(0,0,0,200))
	end

	local commandbuttons = {
		["bodyman_saveclosets"] = BODYMAN.strings.Save.." "..BODYMAN.ClosetName,
		["bodyman_loadclosets"] = (BODYMAN.French and "Restaurer uniquement les "..BODYMAN.ClosetName.."s sauvegardes" or BODYMAN.strings.Load.." "..BODYMAN.ClosetName),
		["bodyman_removeclosets"] = BODYMAN.strings.Remove_All.." "..BODYMAN.ClosetName.."s "..BODYMAN.strings.Without_Saving,
		["bodyman_spawncloset"] = BODYMAN.strings.Spawn_a.." "..BODYMAN.ClosetName,
	}

	for cmd, desc in pairs( commandbuttons ) do
		local b = frame.scr.list:Add("arizard_button")
		b:SetSize( frame.scr.list:GetWide(), 28 )
		b:SetText( desc )

		b.cmd = cmd

		function b:DoClick()
			RunConsoleCommand( self.cmd )
		end
	end


end
concommand.Add("bodyman_adminmenu", function(ply, cmd, args)
	if BODYMAN:CanAccessCommand(ply, cmd) then
		BODYMAN:AdminMenu()
	end
end)


--PATH lua/autorun/bx_inf.lua:
player_manager.AddValidModel( "pm_droid_cis_bx", "models/bx/pm_droid_cis_bx.mdl" )
player_manager.AddValidModel( "pm_droid_cis_bx_captain", "models/bx_captain/pm_droid_cis_bx_captain.mdl" )
player_manager.AddValidModel( "pm_droid_cis_bx_senate", "models/bx_senate/pm_droid_cis_bx_senate.mdl" )
player_manager.AddValidModel( "pm_droid_cis_bx_citadel", "models/bx_citadel/pm_droid_cis_bx_citadel.mdl" )
player_manager.AddValidModel( "pm_droid_cis_bx_training", "models/bx_training/pm_droid_cis_bx_training.mdl" )
--PATH lua/autorun/cgi_civilian_npcs.lua:
return gluapack()()
--PATH lua/autorun/cgi_civilian_npcs.lua:
-----------------------------------------------------------------
local NPC = {
	Name = "Assassin Male (Friendly)",
	Class = "npc_citizen",
	Category = "CGI Civilian Pack",
	Model = "models/assassin/npc_civ_assassin_human_male_f.mdl",
	KeyValues = { citizentype = CT_UNIQUE }
}
list.Set( "NPC", "npc_cgi_assassin_male_f", NPC )

local NPC = {
	Name = "Assassin Male (Hostile)",
	Class = "npc_combine_s",
	Category = "CGI Civilian Pack",
	Model = "models/assassin/npc_civ_assassin_human_male_h.mdl",
}
list.Set( "NPC", "npc_cgi_assassin_male_h", NPC )
-----------------------------------------------------------------
local NPC = {
	Name = "Assassin Female (Friendly)",
	Class = "npc_citizen",
	Category = "CGI Civilian Pack",
	Model = "models/assassin/npc_civ_assassin_human_female_f.mdl",
	KeyValues = { citizentype = CT_UNIQUE }
}
list.Set( "NPC", "npc_cgi_assassin_female_f", NPC )

local NPC = {
	Name = "Assassin Female (Hostile)",
	Class = "npc_combine_s",
	Category = "CGI Civilian Pack",
	Model = "models/assassin/npc_civ_assassin_human_female_h.mdl",
}
list.Set( "NPC", "npc_cgi_assassin_female_h", NPC )
-----------------------------------------------------------------
local NPC = {
	Name = "Bandit Male (Friendly)",
	Class = "npc_citizen",
	Category = "CGI Civilian Pack",
	Model = "models/bandit/npc_civ_bandit_human_male_f.mdl",
	KeyValues = { citizentype = CT_UNIQUE }
}
list.Set( "NPC", "npc_cgi_bandit_male_f", NPC )

local NPC = {
	Name = "Bandit Male (Hostile)",
	Class = "npc_combine_s",
	Category = "CGI Civilian Pack",
	Model = "models/bandit/npc_civ_bandit_human_male_h.mdl",
}
list.Set( "NPC", "npc_cgi_bandit_male_h", NPC )
-----------------------------------------------------------------
local NPC = {
	Name = "Bandit Female (Friendly)",
	Class = "npc_citizen",
	Category = "CGI Civilian Pack",
	Model = "models/bandit/npc_civ_bandit_human_female_f.mdl",
	KeyValues = { citizentype = CT_UNIQUE }
}
list.Set( "NPC", "npc_cgi_bandit_female_f", NPC )

local NPC = {
	Name = "Bandit Female (Hostile)",
	Class = "npc_combine_s",
	Category = "CGI Civilian Pack",
	Model = "models/bandit/npc_civ_bandit_human_female_h.mdl",
}
list.Set( "NPC", "npc_cgi_bandit_female_h", NPC )
-----------------------------------------------------------------
local NPC = {
	Name = "Dweller Male (Friendly)",
	Class = "npc_citizen",
	Category = "CGI Civilian Pack",
	Model = "models/dweller/npc_civ_dweller_human_male_f.mdl",
	KeyValues = { citizentype = CT_UNIQUE }
}
list.Set( "NPC", "npc_cgi_dweller_male_f", NPC )

local NPC = {
	Name = "Dweller Male (Hostile)",
	Class = "npc_combine_s",
	Category = "CGI Civilian Pack",
	Model = "models/dweller/npc_civ_dweller_human_male_h.mdl",
}
list.Set( "NPC", "npc_cgi_dweller_male_h", NPC )
-----------------------------------------------------------------
local NPC = {
	Name = "Dweller Female (Friendly)",
	Class = "npc_citizen",
	Category = "CGI Civilian Pack",
	Model = "models/dweller/npc_civ_dweller_human_female_f.mdl",
	KeyValues = { citizentype = CT_UNIQUE }
}
list.Set( "NPC", "npc_cgi_dweller_female_f", NPC )

local NPC = {
	Name = "Dweller Female (Hostile)",
	Class = "npc_combine_s",
	Category = "CGI Civilian Pack",
	Model = "models/dweller/npc_civ_dweller_human_female_h.mdl",
}
list.Set( "NPC", "npc_cgi_dweller_female_h", NPC )
-----------------------------------------------------------------
local NPC = {
	Name = "Formal Male (Friendly)",
	Class = "npc_citizen",
	Category = "CGI Civilian Pack",
	Model = "models/formal/npc_civ_formal_human_male_f.mdl",
	KeyValues = { citizentype = CT_UNIQUE }
}
list.Set( "NPC", "npc_cgi_formal_male_f", NPC )

local NPC = {
	Name = "Formal Male (Hostile)",
	Class = "npc_combine_s",
	Category = "CGI Civilian Pack",
	Model = "models/formal/npc_civ_formal_human_male_h.mdl",
}
list.Set( "NPC", "npc_cgi_formal_male_h", NPC )
-----------------------------------------------------------------
local NPC = {
	Name = "Formal Female (Friendly)",
	Class = "npc_citizen",
	Category = "CGI Civilian Pack",
	Model = "models/formal/npc_civ_formal_human_female_f.mdl",
	KeyValues = { citizentype = CT_UNIQUE }
}
list.Set( "NPC", "npc_cgi_formal_female_f", NPC )

local NPC = {
	Name = "Formal Female (Hostile)",
	Class = "npc_combine_s",
	Category = "CGI Civilian Pack",
	Model = "models/formal/npc_civ_formal_human_female_h.mdl",
}
list.Set( "NPC", "npc_cgi_formal_female_h", NPC )
-----------------------------------------------------------------
local NPC = {
	Name = "Merc Male (Friendly)",
	Class = "npc_citizen",
	Category = "CGI Civilian Pack",
	Model = "models/merc/npc_civ_merc_human_male_f.mdl",
	KeyValues = { citizentype = CT_UNIQUE }
}
list.Set( "NPC", "npc_cgi_merc_male_f", NPC )

local NPC = {
	Name = "Merc Male (Hostile)",
	Class = "npc_combine_s",
	Category = "CGI Civilian Pack",
	Model = "models/merc/npc_civ_merc_human_male_h.mdl",
}
list.Set( "NPC", "npc_cgi_merc_male_h", NPC )
-----------------------------------------------------------------
local NPC = {
	Name = "Merc Female (Friendly)",
	Class = "npc_citizen",
	Category = "CGI Civilian Pack",
	Model = "models/merc/npc_civ_merc_human_female_f.mdl",
	KeyValues = { citizentype = CT_UNIQUE }
}
list.Set( "NPC", "npc_cgi_merc_female_f", NPC )

local NPC = {
	Name = "Merc Female (Hostile)",
	Class = "npc_combine_s",
	Category = "CGI Civilian Pack",
	Model = "models/merc/npc_civ_merc_human_female_h.mdl",
}
list.Set( "NPC", "npc_cgi_merc_female_h", NPC )
-----------------------------------------------------------------
local NPC = {
	Name = "Guard Male (Friendly)",
	Class = "npc_citizen",
	Category = "CGI Civilian Pack",
	Model = "models/guard/npc_civ_guard_human_male_f.mdl",
	KeyValues = { citizentype = CT_UNIQUE }
}
list.Set( "NPC", "npc_cgi_guard_male_f", NPC )

local NPC = {
	Name = "Guard Male (Hostile)",
	Class = "npc_combine_s",
	Category = "CGI Civilian Pack",
	Model = "models/guard/npc_civ_guard_human_male_h.mdl",
}
list.Set( "NPC", "npc_cgi_guard_male_h", NPC )
-----------------------------------------------------------------
local NPC = {
	Name = "Guard Female (Friendly)",
	Class = "npc_citizen",
	Category = "CGI Civilian Pack",
	Model = "models/guard/npc_civ_guard_human_female_f.mdl",
	KeyValues = { citizentype = CT_UNIQUE }
}
list.Set( "NPC", "npc_cgi_guard_female_f", NPC )

local NPC = {
	Name = "Guard Female (Hostile)",
	Class = "npc_combine_s",
	Category = "CGI Civilian Pack",
	Model = "models/guard/npc_civ_guard_human_female_h.mdl",
}
list.Set( "NPC", "npc_cgi_guard_female_h", NPC )
-----------------------------------------------------------------
local NPC = {
	Name = "Noble Male (Friendly)",
	Class = "npc_citizen",
	Category = "CGI Civilian Pack",
	Model = "models/noble/npc_civ_noble_human_male_f.mdl",
	KeyValues = { citizentype = CT_UNIQUE }
}
list.Set( "NPC", "npc_cgi_noble_male_f", NPC )

local NPC = {
	Name = "Noble Male (Hostile)",
	Class = "npc_combine_s",
	Category = "CGI Civilian Pack",
	Model = "models/noble/npc_civ_noble_human_male_h.mdl",
}
list.Set( "NPC", "npc_cgi_noble_male_h", NPC )
-----------------------------------------------------------------
local NPC = {
	Name = "Noble Female (Friendly)",
	Class = "npc_citizen",
	Category = "CGI Civilian Pack",
	Model = "models/noble/npc_civ_noble_human_female_f.mdl",
	KeyValues = { citizentype = CT_UNIQUE }
}
list.Set( "NPC", "npc_cgi_noble_female_f", NPC )

local NPC = {
	Name = "Noble Female (Hostile)",
	Class = "npc_combine_s",
	Category = "CGI Civilian Pack",
	Model = "models/noble/npc_civ_noble_human_female_h.mdl",
}
list.Set( "NPC", "npc_cgi_noble_female_h", NPC )
-----------------------------------------------------------------
local NPC = {
	Name = "Renegade Male (Friendly)",
	Class = "npc_citizen",
	Category = "CGI Civilian Pack",
	Model = "models/renegade/npc_civ_renegade_human_male_f.mdl",
	KeyValues = { citizentype = CT_UNIQUE }
}
list.Set( "NPC", "npc_cgi_renegade_male_f", NPC )

local NPC = {
	Name = "Renegade Male (Hostile)",
	Class = "npc_combine_s",
	Category = "CGI Civilian Pack",
	Model = "models/renegade/npc_civ_renegade_human_male_h.mdl",
}
list.Set( "NPC", "npc_cgi_renegade_male_h", NPC )
-----------------------------------------------------------------
local NPC = {
	Name = "Renegade Female (Friendly)",
	Class = "npc_citizen",
	Category = "CGI Civilian Pack",
	Model = "models/renegade/npc_civ_renegade_human_female_f.mdl",
	KeyValues = { citizentype = CT_UNIQUE }
}
list.Set( "NPC", "npc_cgi_renegade_female_f", NPC )

local NPC = {
	Name = "Renegade Female (Hostile)",
	Class = "npc_combine_s",
	Category = "CGI Civilian Pack",
	Model = "models/renegade/npc_civ_renegade_human_female_h.mdl",
}
list.Set( "NPC", "npc_cgi_renegade_female_h", NPC )
-----------------------------------------------------------------
local NPC = {
	Name = "Resident Male (Friendly)",
	Class = "npc_citizen",
	Category = "CGI Civilian Pack",
	Model = "models/resident/npc_civ_resident_human_male_f.mdl",
	KeyValues = { citizentype = CT_UNIQUE }
}
list.Set( "NPC", "npc_cgi_resident_male_f", NPC )

local NPC = {
	Name = "Resident Male (Hostile)",
	Class = "npc_combine_s",
	Category = "CGI Civilian Pack",
	Model = "models/resident/npc_civ_resident_human_male_h.mdl",
}
list.Set( "NPC", "npc_cgi_resident_male_h", NPC )
-----------------------------------------------------------------
local NPC = {
	Name = "Resident Female (Friendly)",
	Class = "npc_citizen",
	Category = "CGI Civilian Pack",
	Model = "models/resident/npc_civ_resident_human_female_f.mdl",
	KeyValues = { citizentype = CT_UNIQUE }
}
list.Set( "NPC", "npc_cgi_resident_female_f", NPC )

local NPC = {
	Name = "Resident Female (Hostile)",
	Class = "npc_combine_s",
	Category = "CGI Civilian Pack",
	Model = "models/resident/npc_civ_resident_human_female_h.mdl",
}
list.Set( "NPC", "npc_cgi_resident_female_h", NPC )
-----------------------------------------------------------------
local NPC = {
	Name = "Smuggler Male (Friendly)",
	Class = "npc_citizen",
	Category = "CGI Civilian Pack",
	Model = "models/smuggler/npc_civ_smuggler_human_male_f.mdl",
	KeyValues = { citizentype = CT_UNIQUE }
}
list.Set( "NPC", "npc_cgi_smuggler_male_f", NPC )

local NPC = {
	Name = "Smuggler Male (Hostile)",
	Class = "npc_combine_s",
	Category = "CGI Civilian Pack",
	Model = "models/smuggler/npc_civ_smuggler_human_male_h.mdl",
}
list.Set( "NPC", "npc_cgi_smuggler_male_h", NPC )
-----------------------------------------------------------------
local NPC = {
	Name = "Smuggler Female (Friendly)",
	Class = "npc_citizen",
	Category = "CGI Civilian Pack",
	Model = "models/smuggler/npc_civ_smuggler_human_female_f.mdl",
	KeyValues = { citizentype = CT_UNIQUE }
}
list.Set( "NPC", "npc_cgi_smuggler_female_f", NPC )

local NPC = {
	Name = "Smuggler Female (Hostile)",
	Class = "npc_combine_s",
	Category = "CGI Civilian Pack",
	Model = "models/smuggler/npc_civ_smuggler_human_female_h.mdl",
}
list.Set( "NPC", "npc_cgi_smuggler_female_h", NPC )

local NPC = {
	Name = "Gundark Male (Friendly)",
	Class = "npc_citizen",
	Category = "CGI Civilian Pack",
	Model = "models/gundark/npc_civ_gundark_costume_male_f.mdl",
	KeyValues = { citizentype = CT_UNIQUE }
}
list.Set( "NPC", "npc_cgi_gundark_male_f", NPC )

local NPC = {
	Name = "Gundark Male (Hostile)",
	Class = "npc_combine_s",
	Category = "CGI Civilian Pack",
	Model = "models/gundark/npc_civ_gundark_costume_male_h.mdl",
}
list.Set( "NPC", "npc_cgi_gundark_male_h", NPC )
-----------------------------------------------------------------
local NPC = {
	Name = "Gundark Female (Friendly)",
	Class = "npc_citizen",
	Category = "CGI Civilian Pack",
	Model = "models/gundark/npc_civ_gundark_costume_female_f.mdl",
	KeyValues = { citizentype = CT_UNIQUE }
}
list.Set( "NPC", "npc_cgi_gundark_female_f", NPC )

local NPC = {
	Name = "Gundark Female (Hostile)",
	Class = "npc_combine_s",
	Category = "CGI Civilian Pack",
	Model = "models/gundark/npc_civ_gundark_costume_female_h.mdl",
}
list.Set( "NPC", "npc_cgi_gundark_female_h", NPC )

local NPC = {
	Name = "Wampa Male (Friendly)",
	Class = "npc_citizen",
	Category = "CGI Civilian Pack",
	Model = "models/wampa/npc_civ_wampa_costume_male_f.mdl",
	KeyValues = { citizentype = CT_UNIQUE }
}
list.Set( "NPC", "npc_cgi_wampa_male_f", NPC )

local NPC = {
	Name = "Wampa Male (Hostile)",
	Class = "npc_combine_s",
	Category = "CGI Civilian Pack",
	Model = "models/wampa/npc_civ_wampa_costume_male_h.mdl",
}
list.Set( "NPC", "npc_cgi_wampa_male_h", NPC )
-----------------------------------------------------------------
local NPC = {
	Name = "Wampa Female (Friendly)",
	Class = "npc_citizen",
	Category = "CGI Civilian Pack",
	Model = "models/wampa/npc_civ_wampa_costume_female_f.mdl",
	KeyValues = { citizentype = CT_UNIQUE }
}
list.Set( "NPC", "npc_cgi_wampa_female_f", NPC )

local NPC = {
	Name = "Wampa Female (Hostile)",
	Class = "npc_combine_s",
	Category = "CGI Civilian Pack",
	Model = "models/wampa/npc_civ_wampa_costume_female_h.mdl",
}
list.Set( "NPC", "npc_cgi_wampa_female_h", NPC )
-----------------------------------------------------------------
local NPC = {
	Name = "Festive Male (Friendly)",
	Class = "npc_citizen",
	Category = "CGI Civilian Pack",
	Model = "models/festive/npc_civ_festive_human_male_f.mdl",
	KeyValues = { citizentype = CT_UNIQUE }
}
list.Set( "NPC", "npc_cgi_festive_male_f", NPC )

local NPC = {
	Name = "Festive Male (Hostile)",
	Class = "npc_combine_s",
	Category = "CGI Civilian Pack",
	Model = "models/festive/npc_civ_festive_human_male_h.mdl",
}
list.Set( "NPC", "npc_cgi_festive_male_h", NPC )
-----------------------------------------------------------------
local NPC = {
	Name = "Festive Female (Friendly)",
	Class = "npc_citizen",
	Category = "CGI Civilian Pack",
	Model = "models/festive/npc_civ_festive_human_female_f.mdl",
	KeyValues = { citizentype = CT_UNIQUE }
}
list.Set( "NPC", "npc_cgi_festive_female_f", NPC )

local NPC = {
	Name = "Festive Female (Hostile)",
	Class = "npc_combine_s",
	Category = "CGI Civilian Pack",
	Model = "models/festive/npc_civ_festive_human_female_h.mdl",
}
list.Set( "NPC", "npc_cgi_festive_female_h", NPC )
--PATH lua/autorun/coolhitmarker.lua:
return gluapack()()
--PATH lua/autorun/crewman.lua:
return gluapack()()
--PATH addons/[opt] decals/lua/decals/util/cl_util.lua:
return gluapack()()
--PATH addons/[opt] decals/lua/decals/vgui/slider.lua:
local PANEL = {}

AccessorFunc( PANEL, "Color", "Color" )
AccessorFunc( PANEL, "SliderColor", "SliderColor" )

function PANEL:Init()
    self.Label:Hide()
    self.TextArea:Hide()

    self:SetColor( Color( 150, 150, 150 ) )
    self:SetSliderColor( color_white )

    self.TextArea:SetFont "Decals.Title"
    self.TextArea:SetTextColor( color_white )
    self.TextArea:DockMargin( 10, 0, 0, 0 )

    self.Slider.OnMousePressed = function( s, mouse )
        if mouse == MOUSE_RIGHT then
            self:OnMousePressed( mouse )
        else
            s:SetDragging( true )
            s:MouseCapture( true )

            local x, y = s:CursorPos()
            s:OnCursorMoved( x, y )
        end
    end

    self.Slider.Knob.Paint = function( s, w, h )
        Decals.Draw.Circle( h / 4, h / 4, ( h + 1 ) / 2, self:GetSliderColor() )
    end

    self.Slider.Paint = function( s, w, h )
        draw.RoundedBox( 8, 0, h / 4, w, h / 2, self:GetColor() )
    end
end

function PANEL:OnMousePressed( mouse )
    if mouse == MOUSE_RIGHT then
        if self.TextArea:IsVisible() then
            self.TextArea:Hide()

            self.Slider:SetWide( self:GetWide() )
        else
            self.TextArea:Show()

            self.Slider:StretchToParent( 0, 0, 0, 0 )
        end
    end
end

vgui.Register( "Decals.Slider", PANEL, "DNumSlider" )

--PATH addons/!discordintegration/lua/autorun/discord_integration.lua:
if SERVER and Discord and (type(Discord) ~= 'table' or not Discord.Integration) then
    print('--------------------------------------------------------------------------')
    print('                                WARNING!!!                                ')
    print('                                                                          ')
    print('       Possible collision with Discord Integration and another addon.     ')
    print('       Expect things being possibly broken.                               ')
    print('       Cause: Global variable Discord already in use.                     ')
    print('--------------------------------------------------------------------------')
end

file.CreateDir('discord_integration')

Discord = type(Discord) == 'table' and Discord or {}
Discord.Integration = true
Discord.Modules = {}

function Discord:Log(...)
    MsgC(Color(255, 0, 130), 'Discord -> ', color_white, ..., '\n')
end

function Discord:Error(...)
    MsgC(Color(255, 0, 0), 'Discord Error -> ', color_white, ..., '\n')
end

local val = file.Exists('discord_integration/debug.txt', 'DATA') and tonumber(file.Read('discord_integration/debug.txt', 'DATA')) or 0 -- Because FCVAR_ARCHIVE is shit on server
local discord_debug = (SERVER and CreateConVar or CreateClientConVar)('discord_debug', val, FCVAR_ARCHIVE, 'Enable debug logs for Discord Integration?')
cvars.AddChangeCallback('discord_debug', function(convar, old, new)
    if tonumber(new) then
        file.Write('discord_integration/debug.txt', new)
    end
end, 'save_val')
function Discord:Debug(...)
    if not (discord_debug:GetInt() > 0) then return end
    MsgC(Color(255, 130, 130), 'Discord Debug -> ', color_white, ..., '\n')
end

function Discord:LoadFiles(prefix, files, preload, skipPreload)
    for _, data in ipairs(files) do
        local realm = data[1]
        local filename = data[2]

        if realm == 'sv' and not SERVER then continue end
        Discord:Debug('Loading ' .. filename .. ' in the realm ' .. realm .. '...')

        if SERVER then
            if realm == 'sh' or realm == 'cl' then
                if not skipPreload then AddCSLuaFile('discord/' .. prefix .. filename) end
            elseif realm == 'sv' then
                include('discord/' .. prefix .. filename)
            end
        else
            if realm == 'cl' then
                include('discord/' .. prefix .. filename)
            end
        end

        if not preload and realm == 'sh' then
            include('discord/' .. prefix .. filename)
        end
    end
end

local function getRealmOnly(files, realm)
    local res = {}

    for _, data in ipairs(files) do
        if data[1] == realm then table.insert(res, data) end
    end

    return res
end

function Discord:PreloadModules()
    Discord:Debug('Preloading modules...')

    local _, modules = file.Find('discord/modules/*', 'LUA')
    for _, module in ipairs(modules) do
        Discord:Debug('Loading info for the module "' .. module .. '"...')

        local path = 'discord/modules/' .. module
        local exists = function(filename) return file.Exists(path .. '/' .. filename, 'LUA') end
        if not exists('sh_module.lua') then
            Discord:Debug('Skipping preloading the module "' .. module .. '" because sh_module.lua doesn\'t exist for it.')
            continue
        end

        include(path .. '/sh_module.lua')

        if SERVER and not Discord.Config.EnabledModules[Discord.MODULE.DisplayName] then
            Discord:Debug('Skipping preloading the module "' .. Discord.MODULE.DisplayName .. '" because it\'s disabled.')
            continue
        end

        Discord.MODULE._filename = module
        Discord.Modules[Discord.MODULE.DisplayName] = Discord.MODULE

        if SERVER then
            if Discord.MODULE.Dependencies then
                Discord:LoadFiles('modules/' .. module .. '/', getRealmOnly(Discord.MODULE.Dependencies, 'sh'), true)
                Discord:LoadFiles('modules/' .. module .. '/', getRealmOnly(Discord.MODULE.Dependencies, 'cl'), true)
            end

            AddCSLuaFile(path .. '/sh_module.lua')
            if exists('cl_module.lua') then AddCSLuaFile(path .. '/cl_module.lua') end

            if Discord.MODULE.PostLoad then
                Discord:LoadFiles('modules/' .. module .. '/', getRealmOnly(Discord.MODULE.PostLoad, 'sh'), true)
                Discord:LoadFiles('modules/' .. module .. '/', getRealmOnly(Discord.MODULE.PostLoad, 'cl'), true)
            end
        end

        Discord:Debug('Preloaded the module "' .. Discord.MODULE.DisplayName .. '"')
    end

    Discord.MODULE = nil
    Discord:Debug('Finished preloading!')
end

function Discord:LoadModules()
    Discord:Log('Loading modules...')

    for DisplayName, MODULE in pairs(Discord.Modules) do
        Discord:Debug('Loading the module "' .. DisplayName .. '"...')

        if MODULE.Dependencies then
            Discord:LoadFiles('modules/' .. MODULE._filename .. '/', MODULE.Dependencies, nil, true)
        end

        local path = 'discord/modules/' .. MODULE._filename
        local exists = function(filename) return file.Exists(path .. '/' .. filename, 'LUA') end
        if SERVER then
            if exists('sv_module.lua') then include(path .. '/sv_module.lua') end
        else
            if exists('cl_module.lua') then include(path .. '/cl_module.lua') end
        end

        if MODULE.PostLoad then
            Discord:LoadFiles('modules/' .. MODULE._filename .. '/', MODULE.PostLoad, nil, true)
        end

        Discord:Log('Loaded the module "' .. DisplayName .. '"')
    end

    Discord:Log('Finished loading.')
end
hook.Add('Discord_Backend_Connected', 'LoadModules', Discord.LoadModules)

function Discord:Load()
    Discord:Log('Loading...')

    local _, modules = file.Find('discord/modules/*', 'LUA')
    local none = true
    if SERVER then
        for module, enabled in pairs(Discord.Config.EnabledModules) do
            if enabled then
                none = false
                break
            end
        end
    else
        if #modules > 0 then
            none = false
        end
    end

    if none then
        Discord:Log('Warning! No modules are enabled, and this addon will be pointless. Aborting loading.')
        return
    end

    Discord:Log('Loading core files...')
    local core = {
        {'sh', 'oop.lua'},
        {'sh', 'classes/eventemitter.lua'},
        {'sv', 'classes/api.lua'},
        {'cl', 'classes/cl_connector.lua'},
        {'cl', 'classes/cl_api.lua'},
        {'cl', 'classes/rpc.lua'},

        {'sv', 'transports/basetransport.lua'},
        {'sv', 'transports/http.lua'},
        {'sv', 'transports/websocket.lua'},

        {'sh', 'util.lua'},

        {'sh', 'api_op.lua'},
        {'sv', 'backend_client.lua'},
        {'sv', 'backend.lua'},

        {'cl', 'cl_backend.lua'},
    }
    Discord:LoadFiles('core/', core)
    Discord:PreloadModules()

    Discord:Log('Finished loading core, waiting for backend connection to load modules...')
end

if SERVER then
    include('discord_config.lua')
    AddCSLuaFile('discord_lang.lua')

    if not Discord.Config then
        RunConsoleCommand('sv_hibernate_think', 1)
        timer.Create('Discord_Config_Error', 15, 0, function()
            Discord:Error('Config failed to load, this addon WON\'T work until the following error is fixed:')
            include('discord_config.lua')
        end)
        return
    end
end

include('discord_lang.lua')

if SERVER and not Discord.Lang then
    RunConsoleCommand('sv_hibernate_think', 1)
    timer.Create('Discord_Language_Error', 15, 0, function()
        Discord:Error('Language file failed to load, this addon won\'t work PROPERLY until the following error is fixed:')
        include('discord_lang.lua')
    end)
end

Discord:Load()
--PATH addons/!discordintegration/lua/discord/core/classes/rpc.lua:
local RPC = {}

function RPC:Constructor()
    self.port = 6463
    self.discovered = false
end

function RPC:Init()
    Discord:Debug('Searching for Discord RPC...')
    self:Discover()
end

function RPC:GetURL(endpoint, ...)
    -- Dear Garry's Mod, thank you for blocking private subnet ips because they have no type of use.
    -- Also thank you for ignoring the easy workarounds because clearly you're supposed to be able to bypass this!
    return ('http://rpc.garrysmod.site:%s/' .. (endpoint or '')):format(self.port, ...)
end

function RPC:Discover()
    if self.port > 6472 then return Discord:Debug('RPC not found.') end
    if self.discovered then return Discord:Debug('Already discovered.') end

    Discord:Debug('RPC is trying port ' .. self.port .. '...')
    http.Fetch(self:GetURL(), function(body, size, headers, code)
        self.discovered = true

        Discord:Debug('RPC found at port ' .. self.port .. '!')
        self:emit('discovered')
    end, function(err)
        Discord:Debug('Failed to find RPC at port ' .. self.port .. ': ' .. err)

        self.port = self.port + 1
        self:Discover()
    end)
end

function RPC:API(data, clientid, callback)
    if not self.discovered then return callback('RPC isn\'t discovered.') end

    HTTP({
        url = self:GetURL('rpc?v=1&client_id=%s', clientid),
        method = 'POST',

        type = 'application/json',
        headers = {
            ['Content-Type'] = 'application/json',
        },

        body = util.TableToJSON(data),

        success = function(code, body, headers)
            if code == 200 then
                local response = util.JSONToTable(body)
                if not response then return callback('Failed, malformed json: ' .. body) end

                if response.data and (not response.data.code or not tonumber(response.data.code)) then
                    callback(nil, response.data)
                else
                    callback('Failed with the error: ' .. body)
                end
            else
                callback('Failed with the error: ' .. code .. ' - ' .. body)
            end
        end,

        failed = function(err)
            callback('Failed with the error: ' .. err)
        end,
    })
end

function RPC:SetPresence(data, clientid, callback)
    self:API({
        cmd = 'SET_ACTIVITY',
        nonce = 'SET_ACTIVITY_' .. os.time(),
        args = {
            activity = data,
            pid = GetProcessID and GetProcessID() or 3287,
        },
    }, clientid,
    function(err)
        if err then
            Discord:Log(err)
            return
        end

        if callback then callback() end
    end)
end

function RPC:Request(scopes, clientid, callback)
    self:API({
        cmd = 'AUTHORIZE',
        nonce = 'AUTHORIZE_' .. os.time(),
        args = {
            scopes = scopes,
            client_id = clientid,
        },
    }, clientid, callback)
end

Discord.OOP:Register('RPC', RPC, 'EventEmitter')
--PATH addons/!discordintegration/lua/discord/core/cl_backend.lua:
if Discord.Backend then
    if os.time() < Discord.Backend.LastRefresh + 5 then
        Discord:Log('Preventing additional lua refresh that happened inside 5 seconds after last refresh.')
        return
    end

    if Discord.Backend.API then
        Discord.Backend.API:Destroy()
    end
end

Discord.Backend = {
    LastRefresh = os.time(),
}

local function RequestNewKey()
    Discord:Debug('Requesting new key...')
    net.Start('Discord_GetKey')
    net.SendToServer()
end

hook.Add('Think', 'Discord_GetKey', function()
    hook.Remove('Think', 'Discord_GetKey')

    RequestNewKey()
end)

function Discord.Backend:Connect()
    if not self.API then
        self.API = Discord.OOP:New('API')
        self.API:Init()

        self.API:once('open', function()
            hook.Run('Discord_Backend_Connected')
        end)

        self.API:on('request_key', function()
            RequestNewKey()
        end)

        self.API:on('payload_' .. Discord.OP.CONSOLE_MESSAGE, function(data)
            Discord:Log(data)
        end)
    end

    Discord:Debug('Connecting to the backend...')
    self.API:Connect()
end

function Discord:RPCInit()
    if not self.RPC then
        self.RPC = Discord.OOP:New('RPC')
        self.RPC:Init()
    end
end

net.Receive('Discord_GetKey', function(len)
    Discord:Debug('Received cl key')
    Discord.Backend.Key = net.ReadString()

    local extra = net.ReadBit()
    if extra then
        Discord.Backend = table.Merge(Discord.Backend, {
            HTTP_URL = net.ReadString(),
            Connector_URL = net.ReadString(),
            WebSocket_URL = net.ReadString(),
            EventSource_URL = net.ReadString(),
        })

        Discord.Config = util.JSONToTable(util.Decompress(net.ReadData(net.ReadUInt(16))))
    end

    Discord.Backend:Connect()
    Discord:RPCInit()
end)

concommand.Add('discord_reload', function()
    Discord:Log('Reloading...')
    RequestNewKey()
end)
--PATH lua/autorun/drew.lua:
return gluapack()()
--PATH lua/autorun/drew.lua:
player_manager.AddValidModel( "Drew", "models/player/curse/crm/drew/crm_drew.mdl" )
list.Set( "PlayerOptionsModel", "Drew", "models/player/curse/crm/drew/crm_drew.mdl" )
player_manager.AddValidHands( "Drew", "models/player/curse/crm/drew/crm_drew_arms.mdl", 0, "00000000" )
--PATH lua/autorun/ds3_tridroid_autorun.lua:
/*--------------------------------------------------
	=============== Autorun File ===============
	*** Copyright (c) 2012-2018 by Mayhem, All rights reserved. ***
	No parts of this code or any of its contents may be reproduced, copied, modified or adapted,
	without the prior written consent of the author, unless otherwise indicated for stand-alone materials.
--------------------------------------------------*/
------------------ Addon Information ------------------
local PublicAddonName = "Tri Droid"
local AddonName = "Tri Droid"
local AddonType = "SNPC"
local AutorunFile = "autorun/ds3_tridroid_autorun.lua"
local ConvarList_sundowner = {}
local NPC_MetaTable = FindMetaTable("NPC")
-------------------------------------------------------
local VJExists = file.Exists("lua/autorun/vj_base_autorun.lua","GAME")
-- Options -------------------------------------------------------
ConvarList_sundowner["ThemeOn_sundowner"] = 1 -- Theme On or Off
ConvarList_sundowner["vj_npc_ng_sundowner_1"] = 1 -- Journey: 1 (Base Game)
ConvarList_sundowner["vj_npc_ng_sundowner_2"] = 0 -- Journey: 2
ConvarList_sundowner["vj_npc_ng_sundowner_3"] = 0 -- Journey: 3
ConvarList_sundowner["vj_npc_ng_sundowner_4"] = 0 -- Journey: 4
ConvarList_sundowner["vj_npc_ng_sundowner_5"] = 0 -- Journey: 5
ConvarList_sundowner["vj_npc_ng_sundowner_6"] = 0 -- Journey: 6
ConvarList_sundowner["vj_npc_ng_sundowner_7"] = 0 -- Journey: 7
ConvarList_sundowner["vj_npc_ng_sundowner_8"] = 0 -- Journey: 8
ConvarList_sundowner["vj_weapon_trail_sundowner"] = 0 -- Sword Trail
ConvarList_sundowner["vj_damage_percentage_sundowner"] = 100 -- Damage Percentage
---------------------------------------------------------------------------------------------------------------------------
for k, v in pairs(ConvarList_sundowner) do
	if !ConVarExists(k) then CreateConVar(k, v, {FCVAR_ARCHIVE}) end
end
-------------------------------------------------------
if VJExists == true then
	include('autorun/vj_controls.lua')

	local vCat = "MGR"
	VJ.AddNPC("Tri Droid","npc_vj_tridroid",vCat)
	VJ.AddNPC("Tri Droid (Friendly)","npc_vj_tridroid_f",vCat)
	VJ.AddNPC("Homing Droid","npc_vj_homing",vCat)
	VJ.AddNPC("Homing Droid (Friendly)","npc_vj_homing_f",vCat)
	
	function GenerateNewFontStyle()
	if !CLIENT then return end
		surface.CreateFont("Dark_Font", {
			font = "Adobe Garamond Pro",
			size = 40,
			shadow = true,
			additive = false
		})
	end
	GenerateNewFontStyle()
-- !!!!!! DON'T TOUCH ANYTHING BELOW THIS !!!!!! -------------------------------------------------------------------------------------------------------------------------
	AddCSLuaFile(AutorunFile)
	VJ.AddAddonProperty(AddonName,AddonType)
else
	if (CLIENT) then
		chat.AddText(Color(0,200,200),PublicAddonName,
		Color(0,255,0)," was unable to install, you are missing ",
		Color(255,100,0),"VJ Base!")
	end
	timer.Simple(1,function()
		if not VJF then
			if (CLIENT) then
				VJF = vgui.Create("DFrame")
				VJF:SetTitle("VJ Base is not installed")
				VJF:SetSize(900,800)
				VJF:SetPos((ScrW()-VJF:GetWide())/2,(ScrH()-VJF:GetTall())/2)
				VJF:MakePopup()
				VJF.Paint = function()
					draw.RoundedBox(8,0,0,VJF:GetWide(),VJF:GetTall(),Color(200,0,0,150))
				end
				local VJURL = vgui.Create("DHTML")
				VJURL:SetParent(VJF)
				VJURL:SetPos(VJF:GetWide()*0.005, VJF:GetTall()*0.03)
				local x,y = VJF:GetSize()
				VJURL:SetSize(x*0.99,y*0.96)
				VJURL:SetAllowLua(true)
				VJURL:OpenURL("https://sites.google.com/site/vrejgaming/vjbasemissing")
			elseif (SERVER) then
				timer.Create("VJBASEMissing",5,0,function() print("VJ Base is Missing! Download it from the workshop!") end)
			end
		end
	end)
end

game.AddParticles("particles/ds_artorias_fx.pcf")
game.AddParticles("particles/ds3_fx.pcf")
game.AddParticles("particles/abyss_watcher.pcf")
game.AddParticles("particles/danksouls.pcf")
game.AddParticles("particles/ds3_bosssteps.pcf")
local particlename = {
	"ds3_boss_dissolve",
	"dskart_death",
	"ds3_boss_dissolve_cheap",
	"ds3_gundyr_eyes",

	"abyss_watcher_big_fire_impact_attack",
	"abyss_watcher_big_impact_attack",
	"abyss_watcher_circular_attack",
	"abyss_watcher_dirt_kickup",
	"abyss_watcher_fire_circular_attack",
	"abyss_watcher_fire_jab",
	"abyss_watcher_fire_thrust_pillar",
	"abyss_watcher_impact_sparks",
	"abyss_watcher_sword_flame_attachment",
	"abyss_watcher_sword_flame_vox",
	"abyss_watcher_thrust",

	"ds3_watcher_swing",

	"ds3_bossfs_land",
	"ds3_bossfs_water",
	"ds3_bossfs_water_nowarp"

}
for _,v in ipairs(particlename) do PrecacheParticleSystem(v) end
-- Menu Language -------------------------------------------------------------------------------------------------------------------------
if (CLIENT) then
	language.Add("vjbase.menugeneral.default", "Default")
	language.Add("vjbase.menugeneral.ng_sundowner_1", "NG+1 - (Base Game)")
	language.Add("vjbase.menugeneral.ng_sundowner_2", "NG+2 - Champion sundowner")
	language.Add("vjbase.menugeneral.ng_sundowner_3", "NG+3 - Champion sundowner")
	language.Add("vjbase.menugeneral.ng_sundowner_4", "NG+4 - Champion sundowner")
	language.Add("vjbase.menugeneral.ng_sundowner_5", "NG+5 - Champion sundowner")
	language.Add("vjbase.menugeneral.ng_sundowner_6", "NG+6 - Champion sundowner")
	language.Add("vjbase.menugeneral.ng_sundowner_7", "NG+7 - Champion sundowner")
	language.Add("vjbase.menugeneral.ng_sundowner_8", "NG+8 - Champion sundowner")
end
---------------------------------------------------------------------------------------------------------------------------------------------
function NPC_MetaTable:VJ_DoSelectNewGamePlus_sundowner()
	if GetConVarNumber("vj_npc_ng_sundowner_1") == 1 then self.SelectedNewGamePlus_sundowner = 0 return 0 end -- Journey 1
	if GetConVarNumber("vj_npc_ng_sundowner_2") == 1 then self.SelectedNewGamePlus_sundowner = 1 return 1 end -- Journey 2
	if GetConVarNumber("vj_npc_ng_sundowner_3") == 1 then self.SelectedNewGamePlus_sundowner = 2 return 2 end -- Journey 3
	if GetConVarNumber("vj_npc_ng_sundowner_4") == 1 then self.SelectedNewGamePlus_sundowner = 3 return 3 end -- Journey 4
	if GetConVarNumber("vj_npc_ng_sundowner_5") == 1 then self.SelectedNewGamePlus_sundowner = 4 return 4 end -- Journey 5
	if GetConVarNumber("vj_npc_ng_sundowner_6") == 1 then self.SelectedNewGamePlus_sundowner = 5 return 5 end -- Journey 6
	if GetConVarNumber("vj_npc_ng_sundowner_7") == 1 then self.SelectedNewGamePlus_sundowner = 6 return 6 end -- Journey 7
	if GetConVarNumber("vj_npc_ng_sundowner_8") == 1 then self.SelectedNewGamePlus_sundowner = 7 return 7 end -- Journey 8
	return 1
end
---------------------------------------------------------------------------------------------------------------------------------------------
function NPC_MetaTable:VJ_GetNewGamePlusValue_Damage_sundowner(BaseDamage)
	if self.SelectedNewGamePlus_sundowner == 0 then
		return BaseDamage -- Journey 1
	elseif self.SelectedNewGamePlus_sundowner == 1 then
		return BaseDamage*1.1769041769 -- Journey 2
	elseif self.SelectedNewGamePlus_sundowner == 2 then
		return BaseDamage*1.49385749386 -- Journey 3
	elseif self.SelectedNewGamePlus_sundowner == 3 then
		return BaseDamage*1.66584766585 -- Journey 4
	elseif self.SelectedNewGamePlus_sundowner == 4 then
		return BaseDamage*1.84766584767 -- Journey 5
	elseif self.SelectedNewGamePlus_sundowner == 5 then
		return BaseDamage*2.22358722359 -- Journey 6
	elseif self.SelectedNewGamePlus_sundowner == 6 then
		return BaseDamage*2.41523341523 -- Journey 7
	elseif self.SelectedNewGamePlus_sundowner == 7 then
		return BaseDamage*2.79606879607 -- Journey 8
	end
	return BaseDamage
end
---------------------------------------------------------------------------------------------------------------------------------------------
function NPC_MetaTable:VJ_GetNewGamePlusValue_Health_sundowner(BaseHP)
	self:VJ_DoSelectNewGamePlus_sundowner()
	if self.SelectedNewGamePlus_sundowner == 0 then
		return BaseHP*3.4155754652 -- Journey 1
	elseif self.SelectedNewGamePlus_sundowner == 1 then
		return BaseHP*4.31771192281 -- Journey 2
	elseif self.SelectedNewGamePlus_sundowner == 2 then
		return BaseHP*4.74913852516 -- Journey 3
	elseif self.SelectedNewGamePlus_sundowner == 3 then
		return BaseHP*4.96485182633 -- Journey 4
	elseif self.SelectedNewGamePlus_sundowner == 4 then
		return BaseHP*5.18125430737 -- Journey 5
	elseif self.SelectedNewGamePlus_sundowner == 5 then
		return BaseHP*5.61268090972 -- Journey 6
	elseif self.SelectedNewGamePlus_sundowner == 6 then
		return BaseHP*5.82839421089 -- Journey 7
	elseif self.SelectedNewGamePlus_sundowner == 7 then
		return BaseHP*6.04479669194 -- Journey 8
	end
	return BaseHP
end
---------------------------------------------------------------------------------------------------------------------------------------------
local function VJ_DS3_NEWGAME_OPTIONS_CHAMPION_sundowner(Panel)
	if !game.SinglePlayer() then
		if !LocalPlayer():IsAdmin() or !LocalPlayer():IsSuperAdmin() then
			Panel:AddControl( "Label", {Text = "You are not an admin!"})
			Panel:ControlHelp("Notice: Only admins can change this settings.")
			return
		end
	end

	local vj_sundowner_reset = {Options = {}, CVars = {}, Label = "Reset Everything:", MenuButton = "0"}
	vj_sundowner_reset.Options["#vjbase.menugeneral.default"] = {
	ThemeOn_sundowner = "1", vj_weapon_trail_sundowner = "0", vj_damage_percentage_sundowner = "100",	vj_npc_ng_sundowner_1 = "1",		vj_npc_ng_sundowner_2 = "0",		vj_npc_ng_sundowner_3 = "0",		vj_npc_ng_sundowner_4 = "0",		vj_npc_ng_sundowner_5 = "0",		vj_npc_ng_sundowner_6 = "0",		vj_npc_ng_sundowner_7 = "0",		vj_npc_ng_sundowner_8 = "0",
	}

	local vj_newgameplus_sundowner = {Options = {}, CVars = {}, Label = "Adjust NG+:", MenuButton = "0"}
	vj_newgameplus_sundowner.Options["#vjbase.menugeneral.ng_sundowner_1"] = {
	vj_npc_ng_sundowner_1 = "1",		vj_npc_ng_sundowner_2 = "0",		vj_npc_ng_sundowner_3 = "0",		vj_npc_ng_sundowner_4 = "0",		vj_npc_ng_sundowner_5 = "0",		vj_npc_ng_sundowner_6 = "0",		vj_npc_ng_sundowner_7 = "0",		vj_npc_ng_sundowner_8 = "0",	}

	vj_newgameplus_sundowner.Options["#vjbase.menugeneral.ng_sundowner_2"] = {
	vj_npc_ng_sundowner_1 = "0",		vj_npc_ng_sundowner_2 = "1",		vj_npc_ng_sundowner_3 = "0",		vj_npc_ng_sundowner_4 = "0",		vj_npc_ng_sundowner_5 = "0",		vj_npc_ng_sundowner_6 = "0",		vj_npc_ng_sundowner_7 = "0",		vj_npc_ng_sundowner_8 = "0",	}

	vj_newgameplus_sundowner.Options["#vjbase.menugeneral.ng_sundowner_3"] = {
	vj_npc_ng_sundowner_1 = "0",		vj_npc_ng_sundowner_2 = "0",		vj_npc_ng_sundowner_3 = "1",		vj_npc_ng_sundowner_4 = "0",		vj_npc_ng_sundowner_5 = "0",		vj_npc_ng_sundowner_6 = "0",		vj_npc_ng_sundowner_7 = "0",		vj_npc_ng_sundowner_8 = "0",	}

	vj_newgameplus_sundowner.Options["#vjbase.menugeneral.ng_sundowner_4"] = {
	vj_npc_ng_sundowner_1 = "0",		vj_npc_ng_sundowner_2 = "0",		vj_npc_ng_sundowner_3 = "0",		vj_npc_ng_sundowner_4 = "1",		vj_npc_ng_sundowner_5 = "0",		vj_npc_ng_sundowner_6 = "0",		vj_npc_ng_sundowner_7 = "0",		vj_npc_ng_sundowner_8 = "0",	}

	vj_newgameplus_sundowner.Options["#vjbase.menugeneral.ng_sundowner_5"] = {
	vj_npc_ng_sundowner_1 = "0",		vj_npc_ng_sundowner_2 = "0",		vj_npc_ng_sundowner_3 = "0",		vj_npc_ng_sundowner_4 = "0",		vj_npc_ng_sundowner_5 = "1",		vj_npc_ng_sundowner_6 = "0",		vj_npc_ng_sundowner_7 = "0",		vj_npc_ng_sundowner_8 = "0",	}

	vj_newgameplus_sundowner.Options["#vjbase.menugeneral.ng_sundowner_6"] = {
	vj_npc_ng_sundowner_1 = "0",		vj_npc_ng_sundowner_2 = "0",		vj_npc_ng_sundowner_3 = "0",		vj_npc_ng_sundowner_4 = "0",		vj_npc_ng_sundowner_5 = "0",		vj_npc_ng_sundowner_6 = "1",		vj_npc_ng_sundowner_7 = "0",		vj_npc_ng_sundowner_8 = "0",	}

	vj_newgameplus_sundowner.Options["#vjbase.menugeneral.ng_sundowner_7"] = {
	vj_npc_ng_sundowner_1 = "0",		vj_npc_ng_sundowner_2 = "0",		vj_npc_ng_sundowner_3 = "0",		vj_npc_ng_sundowner_4 = "0",		vj_npc_ng_sundowner_5 = "0",		vj_npc_ng_sundowner_6 = "0",		vj_npc_ng_sundowner_7 = "1",		vj_npc_ng_sundowner_8 = "0",	}

	vj_newgameplus_sundowner.Options["#vjbase.menugeneral.ng_sundowner_8"] = {
	vj_npc_ng_sundowner_1 = "0",		vj_npc_ng_sundowner_2 = "0",		vj_npc_ng_sundowner_3 = "0",		vj_npc_ng_sundowner_4 = "0",		vj_npc_ng_sundowner_5 = "0",		vj_npc_ng_sundowner_6 = "0",		vj_npc_ng_sundowner_7 = "0",		vj_npc_ng_sundowner_8 = "1",	}

	Panel:AddControl("ComboBox", vj_sundowner_reset)
	Panel:AddControl("ComboBox", vj_newgameplus_sundowner)
	
	Panel:AddControl( "Label", {Text = "Toggle Theme:"})
	Panel:AddControl("Checkbox", {Label = "Turn on/off the theme.", Command = "ThemeOn_sundowner"})

	Panel:AddControl( "Label", {Text = "Sword Trail:"})
	Panel:ControlHelp("Enabling this setting will allow Champion sundowner to utilize sword trails.")
	Panel:AddControl("Checkbox", {Label = "This may impact performance.", Command = "vj_weapon_trail_sundowner"})

	Panel:AddControl( "Label", {Text = "Damage Scale:"})
	Panel:ControlHelp("Adjust this value for a percentage damage decrease.")
	Panel:AddControl("Slider", {Label = "Damage Percentage:", Command = "vj_damage_percentage_sundowner"})
	Panel:ControlHelp("1 = 1% of total damage will be dealt to the player.")
	Panel:ControlHelp("100 = Full damage will be dealt to the player.")
end

function VJ_ADDTOMENU_DARKSOULS3_sundowner()
	spawnmenu.AddToolMenuOption("DrVrej", "MGR", "Champion sundowner NG+", "Champion sundowner NG+", "", "", VJ_DS3_NEWGAME_OPTIONS_CHAMPION_sundowner, {})
end
	hook.Add("PopulateToolMenu", "VJ_ADDTOMENU_DARKSOULS3_sundowner", VJ_ADDTOMENU_DARKSOULS3_sundowner)

--PATH addons/!whitelist/lua/autorun/e.lua:
return gluapack()()
--PATH lua/autorun/effects_drak_precache.lua:
return gluapack()()
--PATH lua/autorun/eng_npc.lua:
local NPC = {
	Name = "Coruscant Engineer (Friendly)",
	Class = "npc_citizen",
	Category = "CGI Coruscant Engineer",
	Model = "models/npc_eng_gen/npc_coruscant_eng_gen_f.mdl",
	KeyValues = { citizentype = CT_UNIQUE }
}
list.Set( "NPC", "npc_coruscant_eng_gen_f", NPC )


local NPC = {
	Name = "Coruscant Engineer (Hostile)",
	Class = "npc_combine_s",
	Category = "CGI Coruscant Engineer",
	Model = "models/npc_eng_gen/npc_coruscant_eng_gen_h.mdl"
}
list.Set( "NPC", "npc_coruscant_eng_gen_h", NPC )

local NPC = {
	Name = "Fixer Engineer (Friendly)",
	Class = "npc_citizen",
	Category = "CGI Coruscant Engineer",
	Model = "models/npc_eng_fixer/npc_coruscant_eng_fixer_f.mdl",
	KeyValues = { citizentype = CT_UNIQUE }
}
list.Set( "NPC", "npc_coruscant_eng_fixer_f", NPC )


local NPC = {
	Name = "Fixer Engineer (Hostile)",
	Class = "npc_combine_s",
	Category = "CGI Coruscant Engineer",
	Model = "models/npc_eng_fixer/npc_coruscant_eng_fixer_h.mdl"
}
list.Set( "NPC", "npc_coruscant_eng_fixer_h", NPC )

local NPC = {
	Name = "Bio Engineer (Friendly)",
	Class = "npc_citizen",
	Category = "CGI Coruscant Engineer",
	Model = "models/npc_eng_bio/npc_coruscant_eng_bio_f.mdl",
	KeyValues = { citizentype = CT_UNIQUE }
}
list.Set( "NPC", "npc_coruscant_eng_bio_f", NPC )


local NPC = {
	Name = "Bio Engineer (Hostile)",
	Class = "npc_combine_s",
	Category = "CGI Coruscant Engineer",
	Model = "models/npc_eng_bio/npc_coruscant_eng_bio_h.mdl"
}
list.Set( "NPC", "npc_coruscant_eng_bio_h", NPC )


--PATH lua/autorun/eng_pm.lua:
player_manager.AddValidModel( "pm_coruscant_eng_gen", "models/eng_gen/pm_coruscant_eng_gen.mdl" )
player_manager.AddValidModel( "pm_coruscant_eng_fixer", "models/eng_fixer/pm_coruscant_eng_fixer.mdl" )
player_manager.AddValidModel( "pm_coruscant_eng_bio", "models/eng_bio/pm_coruscant_eng_bio.mdl" )
--PATH lua/autorun/fpsfog.lua:
return gluapack()()
--PATH lua/gmodadminsuite/sh_core.lua:
return gluapack()()
--PATH lua/gmodadminsuite/thirdparty/spon.lua:
return gluapack()()
--PATH lua/gmodadminsuite/lang/chinese.lua:
return {
    Name = "Chinese",
    Flag = "flags16/cn.png",
    Phrases = function()
        return {
            open_menu = "",
            menu_nopermission = "GmodAdminSuite",
            menu_unknown_module = "",
            menu_disabled_module = "",
            menu_module_nopermission = "",
            open_gas = "GmodAdminSuite",
            module_shortcut = "",
            module_reset_data = "/",
            module_shortcut_info = [[
                GmodAdminSuite

                %s
                %s

                
                %s

                KEY
            %s]],
            close = "",
            wiki = "",
            licensee = "",
            support = "",
            module_shop = "",
            welcome = "",
            operator = "",
            script_page = "",
            no_modules_available = "",
            no_modules_available_info = [[
                GmodAdminSuite
		        
            ]],
            custom_ellipsis = "...",
            usergroup_ellipsis = "...",
            steamid_ellipsis = "SteamID...",
            enter_steamid_ellipsis = "SteamID...",
            by_distance = "",
            by_usergroup = "",
            by_team = "",
            by_name = "",
            right_click_to_focus = "",
            unknown = "",
            utilities = "",
            player_management = "",
            administration = "",
            s_second = "1",
            s_seconds = "%d",
            s_minute = "1",
            s_minutes = "%d",
            s_hour = "1",
            s_hours = "%d",
            second_ago = "1",
            seconds_ago = "%d",
            minute_ago = "1",
            minutes_ago = "%d",
            hour_ago = "1",
            hours_ago = "%d",
            just_now = "",
            click_to_focus = "",
            add_steamid = "SteamID",
            copied = "",
            settings = "",
            add_steamid_help = [[
                SteamIDSteamID64
                SteamID%s
                SteamID64%s
            ]],

            setting_default_module = "",
            setting_default_module_tip = "GmodAdminSuite",
            none = "",
            general = "",
            localization = "",
            setting_menu_voicechat = "GAS",
            setting_menu_voicechat_tip = "GmodAdminSuite",
            use_gas_language = "GmodAdminSuite",
            default_format = "",
            short_date_format = "",
            long_date_format = "",
            short_date_format_tip = "\n\n",
            long_date_format_tip = "",
            permissions = "",
            module_enable_switch_tip = "/",
            enabled = "",
            modules = "",
            permissions_help = [[
                GmodAdminSuiteOpenPermissionsBillyGAS
		
                OpenPermissions
                "!openpermissions""openpermissions"

                OpenPermissions""
            ]],
            website = "",
            fun = "",

            bvgui_copied = "",
            bvgui_open_context_menu = "",
            bvgui_open_steam_profile = "Steam",
            bvgui_right_click_to_focus = "",
            bvgui_click_to_focus = "",
            bvgui_unknown = "",
            bvgui_no_data = "",
            bvgui_no_results_found = "",
            bvgui_done = "",
            bvgui_enter_text_ellipsis = "...",
            bvgui_loading_ellipsis = "...",
            bvgui_pin_tip = "ESC",
            bvgui_click_to_render = "",
            bvgui_teleport = "",
            bvgui_inspecting = "",
            bvgui_inspect = "",
            bvgui_screenshot = "",
            bvgui_ok = "",
            bvgui_screenshot_saved = "",
            bvgui_screenshot_saved_to = "%s",
            bvgui_reset = "",
            bvgui_right_click_to_stop_rendering = "",

            settings_player_popup_close = "\n",
            settings_player_popup_close_tip = ""
        }
    end
}

--PATH lua/gmodadminsuite/lang/french.lua:
return gluapack()()
--PATH lua/gmodadminsuite/modules/commands/lang/french.lua:
return gluapack()()
--PATH addons/[gas] gmodadminsuite-jobwhitelist-1.3.4/lua/gmodadminsuite/modules/jobwhitelist/lang/polish.lua:
return {
	Name = "Polish",
	Flag = "flags16/pl.png",
	Phrases = function() return {

		module_name = "Billy's Whitelist",

		insufficient_permissions_jobwhitelist = "Whitelista/Czarna Lista nie jest wlczona dla tej pracy,\noraz nie posiadasz wystarczajcych permisji do wlczenia jej.",
		no_data                               = "Brak danych",
		type                                  = "Typ",
		value                                 = "Warto",
		name                                  = "Nazwa",
		added_by                              = "Dodano przez",
		click_delete_entry_tip                = "Kliknij na pozycje, by j usun!",
		copied                                = "Skopiowano!",
		delete_entry                          = "Usu Pozycj",
		add_player                            = "Dodaj Gracza",
		add_usergroup                         = "Dodaj Rang",
		add_lua_function                      = "Dodaj funkcj Lua",
		lua_function                          = "Funkcja Lua",
		script_page                           = "Strona Skryptu",
		wiki                                  = "Wikipedia",
		jobs                                  = "Prace",
		whitelist                             = "Whitelista",
		blacklist                             = "Blacklista",
		settings                              = "Ustawienia",
		enable_whitelist                      = "Wcz Whiteliste",
		enable_blacklist                      = "Wcz Czarn List",
		default_whitelisted                   = "Dodany do Whitelisty domylnie",
		default_blacklisted                   = "Dodany do Czarnej Listy domylnie",
		disable_autoswitch                    = "Wycz Automatyczn Zmian dla tej Pracy",
		players                               = "Gracze",
		job                                   = "Praca",
		usergroup                             = "Ranga",
		distance                              = "Dystans",
		click_for_options_tip                 = "Kliknij po Wicej!",
		refreshing_ellipsis                   = "Odwieanie...",
		refreshing_in_1_second                = "Odwieanie za 1 sekund",
		refreshing_in_seconds                 = "Odwieanie w %s sekundy",
		operator                              = "SuperAdministrator",
		OperatorsSkipWhitelists_help          = "Jeli to jest wczone, SuperAdministratorzy omijaj Whiteliste.",
		OperatorsSkipBlacklists_help          = "Jeli to jest wczone, SuperAdministratorzy omijaj Czarn List.",
		ShowUnjoinableJobs_help               = "Jeli wyczone, Gracze nie widz prac w F4 w ktrych s na Czarnej Licie/nie maj Whitelisty.\nJeli wczone, widz wszystkie prace.",
		ContextMenu_help                      = "Jeli wczone, Gracze mog uywa Whitelisty w Context Menu (pod C) Zalecane!\nJeli wyczone, ta opcja jest niedostpna.",
		off                                   = "Wyczone",
		FunctionMenuKey_help                  = "Pozwala doda klawisz Funkcyjny do Menu Whitelisty (F1/F2/F3/F4)",
		AutoSwitch_help                       = "Jeli wczone, kiedy Gracz otrzymuje Whitelist do danej pracy, automatycznie zostanie w ni zmieniony. (Dziaa tylko ze SteamID)",
		SwitchJobOnUnwhitelist_help           = "Jeli wczone, kiedy Whitelista zostanie odebrana od Gracza do danej pracy, automatycznie zostanie zmieniony w podstawow prac. (Dziaa tylko ze SteamID)",
		SwitchJobOnBlacklist_help             = "Jeli wczone, kiedy Gracz zostaje dodany do Czarnej Listy danej pracy, automatycznie zostanie zmieniony w podstawow prac. (Dziaa tylko ze SteamID)",
		NotWhitelistedMsg_help                = "Wiadomo, ktr zobaczy Gracz kiedy nie ma dostpu do danej pracy, kiedy prbuje do niej doczy.",
		BlacklistedMsg_help                   = "Wiadomo, ktr zobaczy Gracz kiedy znajduje si na Czarnej Licie danej pracy, oraz prbuje do niej doczy.",
		NotifyWhitelisted_help                = "Wcz by powiadamia Graczy, jeli dostali Whitelist do danej pracy. (Dziaa tylko ze SteamID)",
		NotifyWhitelisted_Msg_help            = "Wiadomo, ktr zobaczy Gracz kiedy otrzyma Whitelist do danej pracy.",
		NotifyUnwhitelisted_help              = "Wcz by powiadamia Graczy, jeli odebrano Whitelist do danej pracy. (Dziaa tylko ze SteamID)",
		NotifyUnwhitelisted_Msg_help          = "Wiadomo, ktr zobaczy Gracz kiedy zostanie odebrana Whitelista do danej pracy.",
		NotifyBlacklisted_help                = "Wcz by powiadamia Graczy, jeli zostali dodani na Czarn List danej pracy. (Dziaa tylko ze SteamID)",
		NotifyBlacklisted_Msg_help            = "Wiadomo, ktr zobaczy Gracz kiedy zostanie dodany do Czarnej Listy danej pracy.",
		NotifyUnblacklisted_help              = "Wcz by powiadamia Graczy, jeli zostali usunici z Czarnej Listy danej pracy. (Dziaa tylko ze SteamID)",
		NotifyUnblacklisted_Msg_help          = "Wiadomo, ktr zobaczy Gracz kiedy zostanie usunity z Czarnej Listy danej pracy.",
		permissions                           = "Uprawnienia",
		modify_whitelist                      = "Edytuj Whiteliste",
		modify_blacklist                      = "Edytuj Czarn List",
		enable_disable_whitelist              = "Wcz/Wycz Whiteliste",
		enable_disable_blacklist              = "Wcz/Wycz Czarn List",
		job_category                          = "Kategoria",
		steamid                               = "SteamID",
		all_jobs                              = "Wszystkie Prace",
		save                                  = "Zapisz",
		all_jobs_in_category                  = "Wszystkie Prace w Kategorii",
		job_categories                        = "Kategorie",
		usergroups                            = "Rangi",
		steamids                              = "SteamID",
		lua_functions                         = "Funkcje Lua",
		usergroup_ellipsis                    = "Ranga...",
		steamid_ellipsis                      = "SteamID...",
		enter_steamid_ellipsis                = "Wpisz SteamID...",
		resets                                = "Zaawansowane",
		enable_buttons                        = "Odblokuj przyciski",
		reset_config                          = "Zresetuj Konfig",
		done_exclamation                      = "Gotowe!",
		reset_permissions_config              = "Zresetuj konfig Uprawnie",
		disable_all_whitelists                = "Wycz wszystkie Whitelisty",
		disable_all_blacklists                = "Wycz wszystkie Czarne Listy",
		destroy_whitelist                     = "Zniszcz Dane Whitelisty...",
		destroy_blacklist                     = "Zniszcz Dane Czarnych List...",
		destroy_all_data                      = "Zniszcz wszystkie Dane",
		destroy_all_data_help                 = "Usu Dane Whitelisty i Czarnej Listy, wycz Whiteliste i Czarn Liste, lecz nie resetuj konfiguracji.",
		reset_everything                      = "Zresetuj wszystko (!)",
		reset_everything_help                 = "Usu Dane Whitelisty i Czarnej Listy, wycz Whiteliste i Czarn Liste, i resetuje konfiguracje.",
		disable_buttons                       = "Zablokuj przyciski",
		open_menu                             = "Otwrz Menu",
		add_to_whitelist                      = "Dodaj do Whitelisty",
		loading_ellipsis                      = "Wczytywanie...",
		no_whitelists_available               = "Brak dostpnych Whitelist!",
		add_to_blacklist                      = "Dodaj do Czarnej Listy",
		no_blacklists_available               = "Brak dostpnych Czarnych List!",
		click_to_focus                        = "Kliknij by przypi",
		right_click_to_focus                  = "Prawy Przycisk by przypi",
		copy_steamid                          = "Skopiuj SteamID",
		copy_steamid64                        = "Skopiuj SteamID64",
		copy                                  = "Skopiuj",
		default_team_error                    = "Nie moesz uywa Whitelisty/Czarnej Listy, bo jest to domylna praca.",
		saved_exclamation                     = "Zapisano!",
		whitelisted                           = "Dodano do Whitelisty",
		blacklisted                           = "Dodano do Czarnej Listy",
		choose_faction                        = "Wybierz frakcj",
		faction_not_permitted                 = "(Nie masz uprawnie, by doczy do tej Frakcji)",
		factions                              = "Frakcje",
		new_faction                           = "Nowa Frakcja",
		destroy_faction_data                  = "Usu dane Frakcji",
		destroy_faction_data_help             = "Usu wszystkie dane Frakcji (np. jakie Frakcje wybrali Gracze)",
		reset_factions_config                 = "Zresetuj konfig Frakcji",
		logo_url                              = "Link do Logo... (PNG)",
		faction_name                          = "Nazwa frakcji",
		faction_name_tip                      = "Nazwa tej frakcji",
		description                           = "Opis",
		faction_description_tip               = "Gracze zobacz opis po najechaniu na Frakcj",
		ShowIfNotPermitted                    = "Poka ignorujc uprawnienia Gracza",
		ShowIfNotPermitted_help               = "Jeli Gracz nie ma uprawnie by doczy do Frakcji, powinna by ona pokazana?",
		SetTeam                               = "Praca Gracza",
		SetTeam_help                          = "W jak prac powinien zamieni si Gracz po wybraniu tej Frakcji?",
		WhitelistedTo                         = "Dodaj Whiteliste do",
		WhitelistedTo_help                    = "Do jakich prac Gracz powinien mie Whitelist w tej Frakcji?",
		BlacklistedFrom                       = "Dodaj do Czarnej Listy",
		BlacklistedFrom_help                  = "W jakich pracach Gracz powinien by na Czarnej Licie w tej Frakcji?",
		delete_faction_confirm                = "Jeste pewien, e chcesz usun te Frakcj?",
		confirm_action                        = "Potwierd",
		yes                                   = "Tak",
		no                                    = "Nie",
		save_faction                          = "Zapisz Frakcj",
		delete_faction                        = "Usu Frakcj",
		factions_ShowOnFirstJoin              = "Poka na pierwszym doczeniu",
		factions_ShowOnFirstJoin_help         = "Poka wybr Frakcji, kiedy Gracz doczy pierwszy raz?",
		factions_ShowOnEveryJoin              = "Poka na kadym doczeniu",
		factions_ShowOnEveryJoin_help         = "Poka wybr Frakcji za kadym razem, kiedy Gracz doczy?",
		factions_ShowOnEverySpawn             = "Poka na kadym respawnie",
		factions_ShowOnEverySpawn_help        = "Poka wybr Frakcji za kadym razem, kiedy Gracz si zrespi?",
		factions_HelpText                     = "Wskazwka",
		factions_HelpText_help                = "Wywietlony tekst, kiedy adna Frakcja nie jest najechana myszk",
		factions_OnPopupSound                 = "Dwik otwarcia",
		factions_OnPopupSound_help            = "Dwik do odtworzenia, kiedy Menu wybrania Frakcji jest otwarte",
		factions_OnHoverSound                 = "Dwik najechania",
		factions_OnHoverSound_help            = "Dwik do odtworzenia, kiedy Frakcja jest najechana myszk",
		factions_OnSelectionSound             = "Dwik wybrania",
		factions_OnSelectionSound_help        = "Dwik do odtworzenia, kiedy Frakcja jest wybrana",
		factions_PermissionDeniedSound        = "Dwik braku Uprawnie",
		factions_PermissionDeniedSound_help   = "Dwik do odtworzenia, kiedy wybrana Frakcja jest niedostpna",
		enable_factions                       = "Wcz Frakcje",
		edit_factions                         = "Edytuj Frakcje",
		chat_command                          = "Komenda Chatu",
		console_command                       = "Komenda w Konsoli",
		blank_to_disable                      = "Zostaw puste by wyczy",
		add_to_all_whitelists                 = "DODAJ do wszystkich Whitelist",
		add_to_all_blacklists                 = "DODAJ do wszystkich Czarnych List",
		remove_from_all_whitelists            = "USU z wszystkich Whitelist",
		remove_from_all_blacklists            = "USU z wszystkich Czarnych List",
		bulk_actions                          = "Masowe Akcje",
		add                                   = "Dodaj",
		remove                                = "Usu",
		remove_player                         = "Usu Gracza",
		remove_usergroup                      = "Usu Rang",
		remove_lua_function                   = "Usu funkcj Lua",
		convert_old_data                      = "Importuj dane starej Whitelisty",
		offline                               = "Offline",
		add_usergroup                         = "Dodaj Rang",
		no_permission_action                  = "Nie masz uprawnie do wykonania tej Akcji!",

} end }
--PATH addons/[gas] gmodadminsuite-logging-2.4.8/lua/gmodadminsuite/modules/logging/lang/english.lua:
return gluapack()()
--PATH lua/gmodadminsuite/modules/playerdatabase/lang/english.lua:
return {
	Name = "English",
	Flag = "flags16/gb.png",
	Phrases = function() return {

		module_name = "Player Database",

		right_click_to_focus    = "Right click to focus",
		steamid                 = "SteamID",
		name                    = "Name",
		usergroup               = "Usergroup",
		ip_address              = "IP Address",
		last_seen               = "Last Seen",
		copy_steamid            = "Copy SteamID",
		copy_steamid64          = "Copy SteamID64",
		copy_usergroup          = "Copy Usergroup",
		copy_ip_address         = "Copy IP Address",
		copy_name               = "Copy Name",
		copy_steam_profile_link = "Copy Steam Profile Link",
		search                  = "Search",
		country                 = "Country",
		copy_country            = "Copy Country",
		search_usergroup        = "Search Usergroup",
		search_ip_address       = "Search IP Address",
		search_country          = "Search Country",
		search_name             = "Search Name",
		none                    = "< none >",
		cancel                  = "Cancel",
		steamid                 = "SteamID",

} end }
--PATH lua/gmodadminsuite/modules/secondaryusergroups/lang/english.lua:
return gluapack()()
--PATH lua/gmodadminsuite/sh_offline_player_data.lua:
AddCSLuaFile()

GAS.OfflinePlayerData = {callbacks = {}, data = {}}

if (CLIENT) then
	local function L(phrase, ...)
		if (#({...}) == 0) then
			return GAS:Phrase(phrase)
		else
			return GAS:PhraseFormat(phrase, ...)
		end
	end

	GAS:netReceive("offline_player_data", function()
		local account_id = net.ReadUInt(31)
		local nick = net.ReadString()
		local usergroup = net.ReadString()
		GAS.OfflinePlayerData.data[account_id] = {nick = nick, usergroup = usergroup}
		
		if (GAS.OfflinePlayerData.callbacks[account_id]) then
			for i,v in ipairs(GAS.OfflinePlayerData.callbacks[account_id]) do
				table.remove(GAS.OfflinePlayerData.callbacks[account_id], i)
				v(true, GAS.OfflinePlayerData.data[account_id])
			end
		end
	end)

	GAS:netReceive("offline_player_data_failed", function()
		local account_id = net.ReadUInt(31)
		GAS.OfflinePlayerData.data[account_id] = false

		if (GAS.OfflinePlayerData.callbacks[account_id]) then
			for i,v in ipairs(GAS.OfflinePlayerData.callbacks[account_id]) do
				table.remove(GAS.OfflinePlayerData.callbacks[account_id], i)
				v(false)
			end
		end
	end)

	GAS:InitPostEntity(function()
		if (system.GetCountry() and #system.GetCountry() > 0) then
			GAS:netStart("offline_player_data_country_code")
				net.WriteString(system.GetCountry())
			net.SendToServer()
		end
	end)
else
	GAS:untimer("offline_player_data_update")

	local cached_offline_data = {}

	GAS_OfflinePlayerData_CountryCodes = GAS_OfflinePlayerData_CountryCodes or {}
	function GAS.OfflinePlayerData:Update(ply)
		GAS.Database:Prepare("REPLACE INTO gas_offline_player_data (`server_id`, `account_id`, `nick`, `usergroup`, `ip_address`, `country_code`, `last_seen`) VALUES(?,?,?,?,?,?,CURRENT_TIMESTAMP())", {GAS.ServerID, ply:AccountID(), utf8.force(ply:Nick()), ply:GetUserGroup(), (ply:IPAddress():gsub(":%d+$","")), GAS_OfflinePlayerData_CountryCodes[ply] or NULL})
	end

	local function sql_init()
		GAS.Database:ServerID(function()
			local function update_data()
				GAS.Database:BeginTransaction()
				for _,ply in ipairs(player.GetHumans()) do
					local data_hash = util.CRC(ply:Nick() .. ply:GetUserGroup() .. ply:IPAddress() .. (GAS_OfflinePlayerData_CountryCodes[ply] or ""))
					if (data_hash ~= cached_offline_data[ply]) then
						cached_offline_data[ply] = data_hash
						GAS.OfflinePlayerData:Update(ply)
					end
				end
				GAS.Database:CommitTransaction()
			end
			update_data()
			GAS:timer("offline_player_data_update", 60, 0, update_data)
		end)
	end
	if (GAS.Database.MySQLDatabase) then
		GAS.Database:Query([[

			CREATE TABLE IF NOT EXISTS `gas_offline_player_data` (
				`server_id` int(11) NOT NULL,
				`account_id` int(11) UNSIGNED NOT NULL,
				`nick` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL,
				`usergroup` varchar(255) CHARACTER SET utf8 COLLATE utf8_unicode_ci NOT NULL,
				`ip_address` varchar(15) CHARACTER SET ascii NOT NULL,
				`country_code` char(3) CHARACTER SET ascii COLLATE ascii_general_ci DEFAULT NULL,
				`last_seen` timestamp NOT NULL,
				PRIMARY KEY (`server_id`, `account_id`)
			);

		]], function()

			GAS.Database:Query("SHOW COLUMNS FROM `gas_offline_player_data` WHERE `Field`='country_code'", function(rows)
				if (not rows or #rows == 0) then
					GAS.Database:Query("ALTER TABLE `gas_offline_player_data` ADD `country_code` CHAR(3) CHARACTER SET ascii COLLATE ascii_general_ci DEFAULT NULL AFTER `ip_address`, ADD INDEX (`country_code`), ADD INDEX (`usergroup`), ADD INDEX (`ip_address`)", sql_init)
				else
					sql_init()
				end
			end)

		end)
	else
		GAS.Database:Query([[

			CREATE TABLE IF NOT EXISTS "gas_offline_player_data" (
				"server_id" INTEGER NOT NULL,
				"account_id" INTEGER NOT NULL,
				"nick" TEXT NOT NULL,
				"usergroup" TEXT NOT NULL,
				"ip_address" TEXT NOT NULL,
				"country_code" TEXT DEFAULT NULL,
				"last_seen" INTEGER NOT NULL,
				PRIMARY KEY ("server_id", "account_id")
			);

			CREATE INDEX IF NOT EXISTS gas_opd_usergroup_index ON gas_offline_player_data ("usergroup");
			CREATE INDEX IF NOT EXISTS gas_opd_country_code_index ON gas_offline_player_data ("country_code");
			CREATE INDEX IF NOT EXISTS gas_opd_ip_address_index ON gas_offline_player_data ("ip_address");

		]], function()

			GAS.Database:Query("PRAGMA table_info(`gas_offline_player_data`)", function(rows)
				local found = false
				for _,row in ipairs(rows) do
					if (row.name == "country_code") then
						found = true
						break
					end
				end
				if (not found) then
					GAS.Database:Query("ALTER TABLE `gas_offline_player_data` ADD COLUMN `country_code` TEXT DEFAULT NULL", sql_init)
				else
					sql_init()
				end
			end)

		end)
	end

	GAS:netInit("offline_player_data")
	GAS:netInit("offline_player_data_failed")

	GAS:netReceive("offline_player_data", function(ply)
		local account_id = net.ReadUInt(31)
		local target_ply = player.GetByAccountID(account_id)
		if (IsValid(target_ply)) then
			GAS:netStart("offline_player_data")
				net.WriteUInt(account_id, 31)
				net.WriteString(target_ply:Nick())
				net.WriteString(target_ply:GetUserGroup())
			net.Send(ply)
		else
			GAS.Database:Prepare("SELECT `nick`, `usergroup` FROM gas_offline_player_data WHERE `server_id`=? AND `account_id`=?", {GAS.ServerID, account_id}, function(rows)
				if (not rows or #rows == 0) then
					GAS:netStart("offline_player_data_failed")
						net.WriteUInt(account_id, 31)
					net.Send(ply)
				else
					GAS:netStart("offline_player_data")
						net.WriteUInt(account_id, 31)
						net.WriteString(rows[1].nick)
						net.WriteString(rows[1].usergroup)
					net.Send(ply)
				end
			end)
		end
	end)

	GAS:netInit("offline_player_data_country_code")
	GAS:netReceive("offline_player_data_country_code", function(ply)
		local country_code = net.ReadString()
		if (GAS_OfflinePlayerData_CountryCodes[ply]) then return end
		if (#country_code > 0 and #country_code <= 3) then
			GAS_OfflinePlayerData_CountryCodes[ply] = country_code
			GAS.Database:Prepare("UPDATE gas_offline_player_data SET `country_code`=? WHERE `account_id`=?", {country_code:upper(), ply:AccountID()})
		end
	end)

	GAS:hook("onPlayerChangedName", "offline_player_data:ChangeName", function(ply, _, name)
		GAS.Database:Prepare("UPDATE gas_offline_player_data SET `nick`=? WHERE `account_id`=?", {name, ply:AccountID()})
	end)
end

function GAS.OfflinePlayerData:SteamID64(steamid64, callback)
	print("deprecated", steamid64)
	debug.Trace()
	return GAS.OfflinePlayerData:AccountID(GAS:SteamID64ToAccountID(steamid64), callback)
end

function GAS.OfflinePlayerData:AccountID(account_id, callback)
	local ply = player.GetByAccountID(account_id)
	if (IsValid(ply)) then
		GAS.OfflinePlayerData.data[account_id] = {nick = ply:Nick(), usergroup = ply:GetUserGroup()}
		callback(true, GAS.OfflinePlayerData.data[account_id])
	else
		if (CLIENT) then
			if (GAS.OfflinePlayerData.data[account_id] ~= nil) then
				if (GAS.OfflinePlayerData.data[account_id] == false) then
					callback(false)
				else
					callback(true, GAS.OfflinePlayerData.data[account_id])
				end
			else
				GAS.OfflinePlayerData.callbacks[account_id] = GAS.OfflinePlayerData.callbacks[account_id] or {}
				table.insert(GAS.OfflinePlayerData.callbacks[account_id], callback)
				GAS:netStart("offline_player_data")
					net.WriteUInt(account_id, 31)
				net.SendToServer()
			end
		else
			GAS.Database:Prepare("SELECT `nick`, `usergroup` FROM gas_offline_player_data WHERE `server_id`=? AND `account_id`=?", {GAS.ServerID, account_id}, function(rows)
				if (#rows == 0) then
					callback(false)
				else
					callback(true, {nick = rows[1].nick, usergroup = rows[1].usergroup})
				end
			end)
		end
	end
end
--PATH lua/gmodadminsuite/modules/commands/_gas_info.lua:
return gluapack()()
--PATH lua/gmodadminsuite/modules/commands/sh_init.lua:
if (SERVER) then
	AddCSLuaFile("cl_commands.lua")
end

GAS.Commands = {}

GAS.Commands.ACTION_COMMANDS_MENU   = 0
GAS.Commands.ACTION_COMMAND         = 1
GAS.Commands.ACTION_CHAT            = 2
GAS.Commands.ACTION_WEBSITE         = 3
GAS.Commands.ACTION_TELEPORT        = 4
GAS.Commands.ACTION_LUA_FUNCTION_SV = 5
GAS.Commands.ACTION_LUA_FUNCTION_CL = 6
GAS.Commands.ACTION_GAS_MODULE      = 7

GAS:hook("gmodadminsuite:LoadModule:commands", "LoadModule:commands", function()
	if (SERVER) then
		include("gmodadminsuite/modules/commands/sv_commands.lua")
		include("gmodadminsuite/modules/commands/sv_permissions.lua")
	else
		include("gmodadminsuite/modules/commands/cl_commands.lua")
	end
end)
--PATH addons/[gas] gmodadminsuite-jobwhitelist-1.3.4/lua/gmodadminsuite/modules/jobwhitelist/_gas_info.lua:
return {
	DefaultEnabled = true,
	Name = "Billy's Whitelist",
	Category = GAS.MODULE_CATEGORY_PLAYER_MANAGEMENT,
	Wiki = "https://gmodsto.re/bwhitelist-wiki",
	Icon = "icon16/vcard_edit.png",
	DarkRP = true,
	GmodStore = "6017",
	License = '{"licensee":"76561198930387092","keys":{"xeon-de":"LXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX","xeon-us":"LXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"}}'
}
--PATH addons/[gas] gmodadminsuite-jobwhitelist-1.3.4/lua/gmodadminsuite/modules/jobwhitelist/sh_init.lua:
return gluapack()()
--PATH lua/gmodadminsuite/modules/playerdatabase/sh_init.lua:
if (SERVER) then
	AddCSLuaFile("gmodadminsuite/modules/playerdatabase/sh_playerdatabase.lua")
end

GAS:hook("gmodadminsuite:LoadModule:playerdatabase", "LoadModule:playerdatabase", function()
	include("gmodadminsuite/modules/playerdatabase/sh_playerdatabase.lua")
end)
--PATH lua/gmodadminsuite/cl_selection_prompts.lua:
local function L(phrase, ...)
	if (#({...}) == 0) then
		return GAS:Phrase(phrase)
	else
		return GAS:PhraseFormat(phrase, nil, ...)
	end
end

GAS.SelectionPrompts = {}

function GAS.SelectionPrompts:PromptTeam(callback, _menu, muted)
	if (not muted) then GAS:PlaySound("btn_light") end

	local menu = _menu or DermaMenu()

	if (DarkRP) then
		local categories = {}
		for i,c in ipairs(DarkRP.getCategories().jobs) do
			if (GAS:table_IsEmpty(c.members)) then continue end
			table.insert(categories, {members = c.members, name = c.name, color = c.color})
		end
		table.SortByMember(categories, "name", true)
		for i,v in ipairs(categories) do
			local submenu, _submenu = menu:AddSubMenu(v.name)
			bVGUI_DermaMenuOption_ColorIcon(_submenu, v.color)

			local teams = {}
			for i,t in ipairs(v.members) do
				table.insert(teams, {index = t.team, name = t.name})
			end
			table.SortByMember(teams, "name", true)
			for i,v in ipairs(teams) do
				bVGUI_DermaMenuOption_ColorIcon(submenu:AddOption(v.name, function()
					callback(v.index)
					if (not muted) then GAS:PlaySound("btn_heavy") end
				end), team.GetColor(v.index))
			end
		end
	else
		local teams = {}
		for i,t in ipairs(team.GetAllTeams()) do
			table.insert(teams, {index = i, name = t.Name})
		end
		table.SortByMember(teams, "name", true)
		for i,v in ipairs(teams) do
			bVGUI_DermaMenuOption_ColorIcon(menu:AddOption(v.name, function()
				callback(v.index)
				if (not muted) then GAS:PlaySound("btn_heavy") end
			end), team.GetColor(v.index))
		end
	end

	if (not _menu) then	menu:Open() end
end

function GAS.SelectionPrompts:PromptLuaFunction(callback, _menu, muted)
	if (not muted) then GAS:PlaySound("btn_light") end

	local menu = _menu or DermaMenu()
	local lua_function_names = table.GetKeys(GAS.LuaFunctions)
	table.sort(lua_function_names)
	for i,lua_function_name in ipairs(lua_function_names) do
		bVGUI_DermaMenuOption_GreenToRed(i, #lua_function_names, menu:AddOption(lua_function_name, function()
			callback(lua_function_name, GAS.LuaFunctions[lua_function_name])
			if (not muted) then GAS:PlaySound("btn_heavy") end
		end))
	end
	if (not _menu) then	menu:Open() end
end

function GAS.SelectionPrompts:PromptUsergroup(callback, _menu, muted)
	if (not muted) then GAS:PlaySound("btn_light") end

	local menu = _menu or DermaMenu()
	menu:AddOption(L"custom_ellipsis", function()
		bVGUI.StringQuery(L"add_usergroup", nil, L"usergroup_ellipsis", function(usergroup)
			callback(usergroup)
		end)
	end):SetIcon("icon16/pencil.png")
	menu:AddSpacer()
	local usergroups = {}
	for _,ply in ipairs(player.GetHumans()) do
		for v in pairs(OpenPermissions:GetUserGroups(ply)) do
			usergroups[v] = true
		end
	end
	usergroups = table.GetKeys(usergroups)
	table.sort(usergroups)
	for i,v in ipairs(usergroups) do
		bVGUI_DermaMenuOption_GreenToRed(i, #usergroups, menu:AddOption(v, function()
			callback(v)
			if (not muted) then GAS:PlaySound("btn_heavy") end
		end))
	end
	if (not _menu) then	menu:Open() end
end

function GAS.SelectionPrompts:PromptSteamID64(callback, _menu, muted)
	print("PromptSteamID64 is deprecated")
	GAS.SelectionPrompts:PromptAccountID(function(account_id, ...)
		callback(GAS:AccountIDToSteamID64(account_id, ...))
	end, _menu, play_sound)
end

function GAS.SelectionPrompts:PromptAccountID(callback, _menu, muted, filter)
	if (not muted) then GAS:PlaySound("btn_light") end

	local menu = _menu or DermaMenu()
	menu:AddOption(L"steamid_ellipsis", function()
		bVGUI.StringQuery(L"add_steamid", L("add_steamid_help", LocalPlayer():SteamID(), LocalPlayer():SteamID64()), L"enter_steamid_ellipsis", function(text)
			if (text:find("^STEAM_%d:%d:%d+$")) then
				local ply = player.GetBySteamID(text)
				if (IsValid(ply)) then
					callback(GAS:SteamIDToAccountID(text), ply)
				else
					callback(GAS:SteamIDToAccountID(text))
				end
			elseif (text:find("^7656119%d+$")) then
				local ply = player.GetBySteamID64(text)
				if (IsValid(ply)) then
					callback(GAS:SteamID64ToAccountID(text), ply)
				else
					callback(GAS:SteamID64ToAccountID(text))
				end
			end
		end, function(text)
			if (text:find("^STEAM_%d:%d:%d+$") or text:find("^7656119%d+$")) then
				return true
			end
		end)
	end):SetIcon("materials/gmodadminsuite/steam.png")
	menu:AddSpacer()

	local distance_submenu, pnl = menu:AddSubMenu(L"by_distance") pnl:SetIcon("icon16/world.png")
	local usergroups_submenu, pnl = menu:AddSubMenu(L"by_usergroup") pnl:SetIcon("icon16/group.png")
	local jobs_submenu, pnl = menu:AddSubMenu(L"by_team") pnl:SetIcon("icon16/user_suit.png")
	local players_submenu, pnl = menu:AddSubMenu(L"by_name") pnl:SetIcon("icon16/emoticon_grin.png")

	local stuff_to_add = {
		usergroups = {},
		jobs = {},
		players = {},
		distances = {}
	}
	for _,ply in ipairs(player.GetHumans()) do
		if (filter and filter[ply]) then continue end
		
		table.insert(stuff_to_add.players, {account_id = ply:AccountID(), nick = ply:Nick(), ply = ply})
		table.insert(stuff_to_add.distances, {distance = ply:GetPos():DistToSqr(LocalPlayer():GetPos()), account_id = ply:AccountID(), nick = ply:Nick(), ply = ply})

		local team_name = team.GetName(ply:Team())
		stuff_to_add.jobs[team_name] = stuff_to_add.jobs[team_name] or {}
		table.insert(stuff_to_add.jobs[team_name], {account_id = ply:AccountID(), nick = ply:Nick(), ply = ply})

		for v in pairs(OpenPermissions:GetUserGroups(ply)) do
			stuff_to_add.usergroups[v] = stuff_to_add.usergroups[v] or {}
			table.insert(stuff_to_add.usergroups[v], {account_id = ply:AccountID(), nick = ply:Nick(), ply = ply})
		end
	end

	local usergroups = table.GetKeys(stuff_to_add.usergroups)
	table.sort(usergroups)
	local jobs = table.GetKeys(stuff_to_add.jobs)
	table.sort(jobs)
	local players = stuff_to_add.players
	table.SortByMember(players, "nick")
	local distances = stuff_to_add.distances
	table.SortByMember(distances, "distance")

	local function PlayerInfoOverlay(option, ply)
		function option:OnCursorEntered()
			if (not IsValid(ply)) then return end
			bVGUI.PlayerTooltip.Create({
				canfocus = false,
				player = ply,
				copiedphrase = L"copied",
				focustip = L"right_click_to_focus",
				creator = self
			})
		end
		function option:OnCursorExited()
			bVGUI.PlayerTooltip.Close()
		end
		option.OnMouseReleased_Old = option.OnMouseReleased
		function option:OnMouseReleased(mouse)
			if (mouse == MOUSE_RIGHT) then
				bVGUI.PlayerTooltip.Focus()
			end
			option:OnMouseReleased_Old(mouse)
		end
	end
	for _,ply in ipairs(distances) do
		local option = distance_submenu:AddOption(ply.nick, function()
			if (not muted) then GAS:PlaySound("btn_heavy") end
			callback(ply.account_id, ply.ply)
		end)
		bVGUI_DermaMenuOption_ColorIcon(option, team.GetColor(ply.ply:Team()))
		PlayerInfoOverlay(option, ply.ply)
	end
	for _,ply in ipairs(players) do
		local option = players_submenu:AddOption(ply.nick, function()
			if (not muted) then GAS:PlaySound("btn_heavy") end
			callback(ply.account_id, ply.ply)
		end)
		bVGUI_DermaMenuOption_ColorIcon(option, team.GetColor(ply.ply:Team()))
		PlayerInfoOverlay(option, ply.ply)
	end
	for i,usergroup in ipairs(usergroups) do
		local submenu, _ = usergroups_submenu:AddSubMenu(usergroup)
		bVGUI_DermaMenuOption_GreenToRed(i, #usergroups, _)
		table.SortByMember(stuff_to_add.usergroups[usergroup], "nick")
		for _,ply in ipairs(stuff_to_add.usergroups[usergroup]) do
			local option = submenu:AddOption(ply.nick, function()
				if (not muted) then GAS:PlaySound("btn_heavy") end
				callback(ply.account_id, ply.ply)
			end)
			bVGUI_DermaMenuOption_ColorIcon(option, team.GetColor(ply.ply:Team()))
			PlayerInfoOverlay(option, ply.ply)
		end
	end
	for _,job in ipairs(jobs) do
		local submenu, submenu_option = jobs_submenu:AddSubMenu(job)
		bVGUI_DermaMenuOption_ColorIcon(submenu_option, team.GetColor(GAS:TeamFromName(job)))
		table.SortByMember(stuff_to_add.jobs[job], "nick")
		for _,ply in ipairs(stuff_to_add.jobs[job]) do
			local option = submenu:AddOption(ply.nick, function()
				if (not muted) then GAS:PlaySound("btn_heavy") end
				callback(ply.account_id, ply.ply)
			end)
			bVGUI_DermaMenuOption_ColorIcon(option, team.GetColor(ply.ply:Team()))
			PlayerInfoOverlay(option, ply.ply)
		end
	end

	if (not _menu) then	menu:Open() end
end
--PATH addons/[admin] gprotect_1.15.101/lua/autorun/gprotect_loader.lua:
return gluapack()()
--PATH lua/autorun/gunner.lua:
player_manager.AddValidModel( "navy gunner", 		"models/navy/gnavygunner.mdl" );
list.Set( "PlayerOptionsModel", "navy gunner", 	"models/navy/gnavygunner.mdl" );
--PATH lua/autorun/hondo_addon.lua:
return gluapack()()
--PATH lua/autorun/hondo_addon.lua:
player_manager.AddValidModel( "Hondo Ohnaka", "models/player/ohanak_gang/pm_pirate_hondo.mdl" );
list.Set( "PlayerOptionsModel",  "Hondo Ohnaka", "models/player/ohanak_gang/pm_pirate_hondo.mdl" );


--PATH lua/autorun/jawacustom.lua:
return gluapack()()
--PATH lua/autorun/jawacustom.lua:
player_manager.AddValidModel( "Jawa",		"models/jajoff/sw/jawacustom.mdl" );
list.Set( "PlayerOptionsModel", "Jawa",		"models/jajoff/sw/jawacustom.mdl" );
--PATH lua/autorun/jawamechanic.lua:
return gluapack()()
--PATH lua/autorun/kiryu_jedi.lua:
return gluapack()()
--PATH lua/autorun/layout.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/autorun/lscs_crafting.lua:

local meta = FindMetaTable( "Player" )

if SERVER then
	util.AddNetworkString( "lscs_craft_saber" )

	function meta:lscsCraftSaber( dont_mess_with_pickup_notifications )
		local HiltR, HiltL = self:lscsGetHilt()
		local BladeR, BladeL = self:lscsGetBlade()

		-- allow updating but don't allow spawning if the gamemode forbids it
		local SWEP = self:GetWeapon( "weapon_lscs" )
		local OldBP

		if IsValid( SWEP ) then
			OldBP = SWEP:GetBlockPoints()
		else
			if hook.Run( "PlayerGiveSWEP", self, "weapon_lscs", weapons.Get( "weapon_lscs" ) ) == false then
				self:ChatPrint("[LSCS] - You don't have permission to spawn this SWEP.")

				return
			end
		end

		self:StripWeapon( "weapon_lscs" )

		if not dont_mess_with_pickup_notifications then self:SetSuppressPickupNotices( true ) end
		self:Give("weapon_lscs")
		if not dont_mess_with_pickup_notifications then self:SetSuppressPickupNotices( false) end

		self:SelectWeapon( "weapon_lscs" )

		self:EmitSound("lscs/equip.mp3")

		local weapon = self:GetWeapon( "weapon_lscs" )

		if IsValid( weapon ) then
			weapon:SetHiltR( HiltR or "" )
			weapon:SetHiltL( HiltL or "" )

			if HiltR and HiltR ~= "" then
				weapon:SetBladeR( BladeR or "" )
			end
			if HiltL and HiltL ~= "" then
				weapon:SetBladeL( BladeL or "" )
			end

			if OldBP then weapon:SetBlockPoints( OldBP ) end
		end

		hook.Run( "LSCS:OnPlayerCraftedSaber", self, weapon )
	end

	net.Receive( "lscs_craft_saber", function( len, ply )
		ply:lscsCraftSaber()
	end )
else
	function meta:lscsCraftSaber()
		net.Start( "lscs_craft_saber" )
		net.SendToServer()
	end
end

--PATH addons/[miecze] moce i hilty/lua/includes/circles/circles.lua:
if SERVER then return false end

local _R = debug.getregistry()
if _R.Circles then return _R.Circles end

local CIRCLE = {}
CIRCLE.__index = CIRCLE

CIRCLE_FILLED = 0
CIRCLE_OUTLINED = 1
CIRCLE_BLURRED = 2

local New do
	local err_number = "bad argument #%i to 'New' (number expected, got %s)"

	function New(t, r, x, y, ...)
		assert(isnumber(t), string.format(err_number, 1, type(t)))
		assert(isnumber(r), string.format(err_number, 2, type(r)))
		assert(isnumber(x), string.format(err_number, 3, type(x)))
		assert(isnumber(y), string.format(err_number, 4, type(y)))

		local circle = setmetatable({}, CIRCLE)

		circle:SetType(t)
		circle:SetRadius(r)
		circle:SetX(x)
		circle:SetY(y)

		circle:SetVertices({Count = 0})

		if t == CIRCLE_OUTLINED then
			local outline_width = ...
			assert(outline_width == nil or isnumber(outline_width), string.format(err_number, 5, type(outline_width)))

			circle:SetOutlineWidth(outline_width)
		elseif t == CIRCLE_BLURRED then
			local blur_layers, blur_density = ...
			assert(blur_layers == nil or isnumber(blur_layers), string.format(err_number, 5, type(blur_layers)))
			assert(blur_density == nil or isnumber(blur_density), string.format(err_number, 6, type(blur_density)))

			circle:SetBlurLayers(blur_layers)
			circle:SetBlurDensity(blur_density)
		end

		return circle
	end
end

local RotateVertices do
	local err_table = "bad argument #1 to 'RotateVertices' (table expected, got %s)"
	local err_number = "bad argument #%i to 'RotateVertices' (number expected, got %s)"

	function RotateVertices(vertices, ox, oy, rotation, rotate_uv)
		assert(istable(vertices), string.format(err_table, type(vertices)))
		assert(isnumber(ox), string.format(err_number, 2, type(ox)))
		assert(isnumber(oy), string.format(err_number, 3, type(oy)))
		assert(isnumber(rotation), string.format(err_number, 4, type(rotation)))

		local rotation = math.rad(rotation)
		local c = math.cos(rotation)
		local s = math.sin(rotation)

		for i = 1, vertices.Count or #vertices do
			local vertex = vertices[i]
			local vx, vy = vertex.x, vertex.y

			vx = vx - ox
			vy = vy - oy

			vertex.x = ox + (vx * c - vy * s)
			vertex.y = oy + (vx * s + vy * c)

			if rotate_uv == false then
				local u, v = vertex.u, vertex.v
				u, v = u - 0.5, v - 0.5

				vertex.u = 0.5 + (u * c - v * s)
				vertex.v = 0.5 + (u * s + v * c)
			end
		end
	end
end

local CalculateVertices do
	local err_number = "bad argument #%i to 'CalculateVertices' (number expected, got %s)"

	function CalculateVertices(x, y, radius, rotation, start_angle, end_angle, distance, rotate_uv)
		assert(isnumber(x), string.format(err_number, 1, type(x)))
		assert(isnumber(y), string.format(err_number, 2, type(y)))
		assert(isnumber(radius), string.format(err_number, 3, type(radius)))
		assert(isnumber(rotation), string.format(err_number, 4, type(rotation)))
		assert(isnumber(start_angle), string.format(err_number, 5, type(start_angle)))
		assert(isnumber(end_angle), string.format(err_number, 6, type(end_angle)))
		assert(isnumber(distance), string.format(err_number, 7, type(distance)))

		local vertices = {Count = 0}
		local step = distance / radius

		local rad_start_angle = math.rad(start_angle)
		local rad_end_angle = math.rad(end_angle)
		local rad_rotation = math.rad(rotation)

		for a = rad_start_angle, rad_end_angle + step, step do
			a = math.min(a, rad_end_angle)

			local c = math.cos(a + rad_rotation)
			local s = math.sin(a + rad_rotation)

			local vertex = {
				x = x + c * radius,
				y = y + s * radius,
			}

			if rotate_uv == false then
				vertex.u = 0.5 + math.cos(a) / 2
				vertex.v = 0.5 + math.sin(a) / 2
			else
				vertex.u = 0.5 + c / 2
				vertex.v = 0.5 + s / 2
			end

			vertices.Count = vertices.Count + 1
			vertices[vertices.Count] = vertex
		end

		if end_angle - start_angle ~= 360 then
			table.insert(vertices, 1, {
				x = x, y = y,
				u = 0.5, v = 0.5,
			})

			vertices.Count = vertices.Count + 1
		else
			table.remove(vertices)
			vertices.Count = vertices.Count - 1
		end

		return vertices
	end
end

function CIRCLE:__tostring()
	return string.format("Circle: %p", self)
end

function CIRCLE:Copy()
	return table.Copy(self)
end

function CIRCLE:IsValid()
	return (
		not self.m_Dirty and
		self.m_Vertices.Count >= 3 and
		self.m_Radius >= 1 and
		self.m_Distance >= 1
	)
end

function CIRCLE:Calculate()
	local rotate_uv = self.m_RotateMaterial

	local radius = self.m_Radius
	local x, y = self.m_X, self.m_Y

	local rotation = self.m_Rotation
	local start_angle = self.m_StartAngle
	local end_angle = self.m_EndAngle

	local distance = self.m_Distance

	assert(radius >= 1, string.format("circle radius should be >= 1 (%.4f)", radius))
	assert(distance >= 1, string.format("circle distance should be >= 1 (%.4f)", distance))

	self:SetVertices(CalculateVertices(x, y, radius, rotation, start_angle, end_angle, distance, rotate_uv))

	if self.m_Type == CIRCLE_OUTLINED then
		local inner = self.m_ChildCircle or self:Copy()
		local inner_r = radius - self.m_OutlineWidth

		inner:SetType(CIRCLE_FILLED)

		inner:SetPos(x, y)
		inner:SetRadius(inner_r)
		inner:SetRotation(rotation)
		inner:SetAngles(start_angle, end_angle)
		inner:SetDistance(distance)

		inner:SetColor(false)
		inner:SetMaterial(false)

		inner:SetShouldRender(inner_r >= 1)
		inner:SetDirty(inner.m_ShouldRender)

		self:SetShouldRender(inner_r < radius)
		self:SetChildCircle(inner)
	elseif self.m_ChildCircle then
		self.m_ChildCircle = nil
	end

	self:SetDirty(false)

	return self
end

do
	local blur = Material("pp/blurscreen")

	function CIRCLE:__call()
		if self.m_Dirty then self:Calculate() end

		if not self:IsValid() then return false end
		if not self.m_ShouldRender then return false end

		do
			local col, mat = self.m_Color, self.m_Material

			if IsColor(col) then
				if col.a <= 0 then return end
				surface.SetDrawColor(col.r, col.g, col.b, col.a)
			end

			if mat == true then
				draw.NoTexture()
			elseif TypeID(mat) == TYPE_MATERIAL then
				surface.SetMaterial(mat)
			end
		end

		if self.m_Type == CIRCLE_OUTLINED then
			render.ClearStencil()

			render.SetStencilEnable(true)
				render.SetStencilTestMask(0xFF)
				render.SetStencilWriteMask(0xFF)
				render.SetStencilReferenceValue(0x01)

				render.SetStencilCompareFunction(STENCIL_NEVER)
				render.SetStencilFailOperation(STENCIL_REPLACE)
				render.SetStencilZFailOperation(STENCIL_REPLACE)

				self.m_ChildCircle()

				render.SetStencilCompareFunction(STENCIL_GREATER)
				render.SetStencilFailOperation(STENCIL_KEEP)
				render.SetStencilZFailOperation(STENCIL_KEEP)

				surface.DrawPoly(self.m_Vertices)
			render.SetStencilEnable(false)
		elseif self.m_Type == CIRCLE_BLURRED then
			render.ClearStencil()

			render.SetStencilEnable(true)
				render.SetStencilTestMask(0xFF)
				render.SetStencilWriteMask(0xFF)
				render.SetStencilReferenceValue(0x01)

				render.SetStencilCompareFunction(STENCIL_NEVER)
				render.SetStencilFailOperation(STENCIL_REPLACE)
				render.SetStencilZFailOperation(STENCIL_REPLACE)

				surface.DrawPoly(self.m_Vertices)

				render.SetStencilCompareFunction(STENCIL_LESSEQUAL)
				render.SetStencilFailOperation(STENCIL_KEEP)
				render.SetStencilZFailOperation(STENCIL_KEEP)

				surface.SetMaterial(blur)

				local sw, sh = ScrW(), ScrH()

				for i = 1, self.m_BlurLayers do
					blur:SetFloat("$blur", (i / self.m_BlurLayers) * self.m_BlurDensity)
					blur:Recompute()

					render.UpdateScreenEffectTexture()
					surface.DrawTexturedRect(0, 0, sw, sh)
				end
			render.SetStencilEnable(false)
		else
			surface.DrawPoly(self.m_Vertices)
		end

		return true
	end

	CIRCLE.Draw = CIRCLE.__call
end

do
	local err_number = "bad argument #%i to 'Translate' (number expected, got %s)"

	function CIRCLE:Translate(x, y)
		assert(isnumber(x), string.format(err_number, 1, type(x)))
		assert(isnumber(y), string.format(err_number, 2, type(y)))

		if x ~= 0 or y ~= 0 then
			self.m_X = self.m_X + x
			self.m_Y = self.m_Y + y

			if self:IsValid() then
				for i = 1, self.m_Vertices.Count do
					local vertex = self.m_Vertices[i]

					vertex.x = vertex.x + x
					vertex.y = vertex.y + y
				end

				if self.m_Type == CIRCLE_OUTLINED and self.m_ChildCircle then
					self.m_ChildCircle:Translate(x, y)
				end
			end
		end

		return self
	end
end

do
	local err_number = "bad argument #1 to 'Scale' (number expected, got %s)"

	function CIRCLE:Scale(scale)
		assert(isnumber(scale), string.format(err_number, type(scale)))

		if scale ~= 1 then
			self.m_Radius = self.m_Radius * scale

			if self:IsValid() then
				local x, y = self.m_X, self.m_Y

				for i = 1, self.m_Vertices.Count do
					local vertex = self.m_Vertices[i]

					vertex.x = x + (vertex.x - x) * scale
					vertex.y = y + (vertex.y - y) * scale
				end

				if self.m_Type == CIRCLE_OUTLINED and self.m_ChildCircle then
					self.m_ChildCircle:Scale(scale)
				end
			end
		end

		return self
	end
end

do
	local err_number = "bad argument #1 to 'Rotate' (number expected, got %s)"

	function CIRCLE:Rotate(rotation)
		assert(isnumber(rotation), string.format(err_number, type(rotation)))

		if rotation ~= 0 then
			self.m_Rotation = self.m_Rotation + rotation

			if self:IsValid() then
				local x, y = self.m_X, self.m_Y
				local vertices = self.m_Vertices
				local rotate_uv = self.m_RotateMaterial

				RotateVertices(vertices, x, y, rotation, rotate_uv)

				if self.m_Type == CIRCLE_OUTLINED and self.m_ChildCircle then
					self.m_ChildCircle:Rotate(rotation)
				end
			end
		end

		return self
	end
end

do
	local function AccessorFunc(name, default, dirty, callback)
		local varname = "m_" .. name

		CIRCLE["Get" .. name] = function(self)
			return self[varname]
		end

		CIRCLE["Set" .. name] = function(self, value)
			if default ~= nil and value == nil then
				value = default
			end

			if self[varname] ~= value then
				if dirty then
					self[dirty] = true
				end

				if callback ~= nil then
					local new = callback(self, self[varname], value)
					value = new ~= nil and new or value
				end

				self[varname] = value
			end

			return self
		end

		CIRCLE[varname] = default
	end

	local function OffsetVerticesX(circle, old, new)
		circle:Translate(new - old, 0)

		if circle.m_Type == CIRCLE_OUTLINED and circle.m_ChildCircle then
			circle.m_ChildCircle:Translate(new - old, 0)
		end
	end

	local function OffsetVerticesY(circle, old, new)
		circle:Translate(0, new - old)

		if circle.m_Type == CIRCLE_OUTLINED and circle.m_ChildCircle then
			circle.m_ChildCircle:Translate(0, new - old)
		end
	end

	local function UpdateRotation(circle, old, new)
		circle:Rotate(new - old)

		if circle.m_Type == CIRCLE_OUTLINED and circle.m_ChildCircle then
			circle.m_ChildCircle:Rotate(new - old)
		end
	end

	-- These are set internally. Only use them if you know what you're doing.
	AccessorFunc("Dirty", true)
	AccessorFunc("Vertices", false)
	AccessorFunc("ChildCircle", false)
	AccessorFunc("ShouldRender", true)

	AccessorFunc("Color", false)						-- The colour you want the circle to be. If set to false then surface.SetDrawColor's can be used.
	AccessorFunc("Material", false)						-- The material you want the circle to render. If set to false then surface.SetMaterial can be used.
	AccessorFunc("RotateMaterial", true)				-- Sets whether or not the circle's UV points should be rotated with the vertices.

	AccessorFunc("Type", CIRCLE_FILLED, "m_Dirty")		-- The circle's type.
	AccessorFunc("X", 0, false, OffsetVerticesX)		-- The circle's X position relative to the top left of the screen.
	AccessorFunc("Y", 0, false, OffsetVerticesY)		-- The circle's Y position relative to the top left of the screen.
	AccessorFunc("Radius", 8, "m_Dirty")				-- The circle's radius.
	AccessorFunc("Rotation", 0, false, UpdateRotation)	-- The circle's rotation, measured in degrees.
	AccessorFunc("StartAngle", 0, "m_Dirty")			-- The circle's start angle, measured in degrees.
	AccessorFunc("EndAngle", 360, "m_Dirty")			-- The circle's end angle, measured in degrees.
	AccessorFunc("Distance", 10, "m_Dirty")				-- The maximum distance between each of the circle's vertices. This should typically be used for large circles in 3D2D.

	AccessorFunc("BlurLayers", 3)						-- The circle's blur layers if Type is set to CIRCLE_BLURRED.
	AccessorFunc("BlurDensity", 2)						-- The circle's blur density if Type is set to CIRCLE_BLURRED.
	AccessorFunc("OutlineWidth", 10, "m_Dirty")			-- The circle's outline width if Type is set to CIRCLE_OUTLINED.

	function CIRCLE:SetPos(x, y)
		x = tonumber(x) or self.m_X
		y = tonumber(y) or self.m_Y

		if self:IsValid() then
			self:Translate(x - self.m_X, y - self.m_Y)
		else
			self.m_X = x
			self.m_Y = y
		end

		return self
	end

	function CIRCLE:SetAngles(s, e)
		s = tonumber(s) or self.m_StartAngle
		e = tonumber(e) or self.m_EndAngle

		self:SetDirty(self.m_Dirty or s ~= self.m_StartAngle or e ~= self.m_EndAngle)

		self.m_StartAngle = s
		self.m_EndAngle = e

		return self
	end

	function CIRCLE:GetPos()
		return self.m_X, self.m_Y
	end

	function CIRCLE:GetAngles()
		return self.m_StartAngle, self.m_EndAngle
	end
end

_R.Circles = {
	_MT = CIRCLE,

	New = New,
	RotateVertices = RotateVertices,
	CalculateVertices = CalculateVertices,
}

return _R.Circles
--PATH addons/[miecze] moce i hilty/lua/lscs/autorun/lscs_player.lua:
local meta = FindMetaTable( "Player" )

function meta:lscsGetForce()
	return self:GetNWFloat( "lscs_force_mana", self:lscsGetMaxForce() ) -- gay
end

function meta:lscsGetMaxForce()
	return self:GetNWFloat( "lscs_force_mana_max", 100 ) -- gay
end

function meta:lscsGetShootPos()
	local attachment = self:GetAttachment( self:LookupAttachment( "eyes" ) )

	if attachment then
		return attachment.Pos
	else
		return self:GetShootPos()
	end
end

function meta:lscsGetViewOrigin()
	local angles = self:EyeAngles()
	local pos = self:lscsGetShootPos()

	local clamped_angles = Angle( math.max( angles.p, -60 ), angles.y, angles.r )

	local endpos = pos - clamped_angles:Forward() * 100 + clamped_angles:Up() * 12

	local trace = util.TraceHull({
		start = pos,
		endpos = endpos,
		mask = MASK_SOLID_BRUSHONLY,
		mins = Vector(-5,-5,-5),
		maxs = Vector(5,5,5),
		filter = { self },
	})

	return trace.HitPos
end

if SERVER then
	util.AddNetworkString( "lscs_sync_combo_data" )

	function meta:lscsIsValid()
		local HiltR, HiltL = self:lscsGetHilt()
		local BladeR, BladeL = self:lscsGetBlade()

		return (HiltR and BladeR and HiltR ~= "" and BladeR ~= "") or (HiltL and BladeL and HiltL ~= "" and BladeL ~= "")
	end

	function meta:lscsSetForceRegenAmount( num )
		if self._lscsOldForceRegen then
			self._lscsOldForceRegen = num

			return
		end

		if not num or not isnumber( num ) or num == 1 then

			self._lscsForceRegenAmount = nil

			return
		end

		self._lscsForceRegenAmount = num
	end

	function meta:lscsGetForceRegenAmount()
		return self._lscsForceRegenAmount or 1
	end

	function meta:lscsGetForceAllowed()
		return self:lscsGetMaxForce() * self:lscsGetForceRegenAmount() > 0
	end

	function meta:lscsSetForceAllowed( allow )
		self:SetNWBool( "lscs_force_allow_useage", allow )

		if allow then
			if self._lscsOldForceRegen then
				local OldForceRegen = self._lscsOldForceRegen
				self._lscsOldForceRegen = nil
				self:lscsSetForceRegenAmount( OldForceRegen )
			end

			if self._lscsOldForceMax then
				local OldForceMax = self._lscsOldForceMax
				self._lscsOldForceMax = nil
				self:lscsSetMaxForce( OldForceMax )
			end

			if self._lscsOldForce then
				local OldForce = self._lscsOldForce
				self._lscsOldForce = nil
				self:lscsSetForce( OldForce )
			end

			self._oldlscsForceAllowed = allow

			return
		end

		if self._oldlscsForceAllowed == false then return end

		self._oldlscsForceAllowed = false

		local OldForceRegen = self:lscsGetForceRegenAmount()
		local OldForceMax = self:lscsGetMaxForce()
		local OldForce = self:lscsGetForce()

		self:lscsSetForce( 0 )
		self:lscsSetMaxForce( 0 )
		self:lscsSetForceRegenAmount( 0 )

		self._lscsOldForceRegen = OldForceRegen
		self._lscsOldForceMax = OldForceMax
		self._lscsOldForce = OldForce
	end

	function meta:lscsSetForce( num )
		self:SetNWFloat( "lscs_force_mana", num )
	end

	function meta:lscsSetMaxForce( num )
		if self._lscsOldForceMax then
			self._lscsOldForceMax = num

			return
		end

		self:SetNWFloat( "lscs_force_mana_max", num )
	end

	function meta:lscsTakeForce( Amount )
		if not Amount then Amount = 0 end

		self._lscsNextForceRegen = CurTime() + 2

		local Force = self:lscsGetForce() - Amount

		self:lscsSetForce( math.max( Force, 0 ) )
	end

	function meta:lscsSendComboDataTo( ply )
		if not IsValid( ply ) then return end

		local stances = self.m_lscs_combo or {}

		if table.IsEmpty( stances ) then return end

		net.Start( "lscs_sync_combo_data" )
			net.WriteEntity( self )
			net.WriteInt( #stances, 32 )
			for _, comboname in ipairs( stances ) do
				net.WriteString( comboname )
			end
		net.Send( ply )
	end

	hook.Add( "LSCS:OnPlayerFullySpawned", "sync_combo_data", function( ply )
		for id, other_ply in ipairs( player.GetAll() ) do
			timer.Simple( id * 0.25, function()
				if not IsValid( other_ply ) or not IsValid( ply ) then return end
				other_ply:lscsSendComboDataTo( ply )
			end )
		end
	end )

	hook.Add( "PlayerSpawn", "!!!!!lscs_auto_equip", function( ply )
		if not ply:lscsIsValid() then return end

		ply:lscsCraftSaber( true )

		local SWEP = ply:GetWeapon( "weapon_lscs" )

		if not IsValid( SWEP ) then return end

		SWEP:SetBlockPoints( 999999 )
	end )
else
	function meta:lscsGetForceAllowed()
		return self:GetNWBool( "lscs_force_allow_useage", true )
	end

	net.Receive( "lscs_sync_combo_data", function( len )
		local ply = net.ReadEntity()

		if not IsValid( ply ) then return end

		local num = net.ReadInt( 32 )

		local stances = {}
		for i = 1, num do
			table.insert( stances, net.ReadString() )
		end

		ply.m_lscs_combo = stances
	end )
end

function meta:lscsKeyDown( IN_KEY )
	if not self.lscs_cmd then self.lscs_cmd = {} end

	return self.lscs_cmd[ IN_KEY ]
end

function meta:lscsGetInventory()
	if not self.m_inventory_lscs then self.m_inventory_lscs = {} end
	return self.m_inventory_lscs
end

function meta:lscsGetInventoryItem( index )
	return LSCS:ClassToItem( self:lscsGetInventory()[ index ] )
end

function meta:lscsGetEquipped()
	if not self.m_equipped_lscs then self.m_equipped_lscs = {} end

	return self.m_equipped_lscs
end

function meta:lscsGetForceAbilities()
	if not self.m_equipped_force_lscs then self.m_equipped_force_lscs = {} end

	return self.m_equipped_force_lscs
end

function meta:lscsGetCombo( num )
	if not istable( self.m_lscs_combo ) or table.IsEmpty( self.m_lscs_combo ) then self.m_lscs_combo = { [1] = "default" } end

	if num then
		local combo = LSCS:GetStance( self.m_lscs_combo[ num ] )

		if combo then
			return combo
		else
			return LSCS:GetStance( "default" )
		end
	else
		return self.m_lscs_combo
	end
end

function meta:lscsGetHilt()
	return self.m_lscs_hilt_right, self.m_lscs_hilt_left
end

function meta:lscsGetBlade()
	return self.m_lscs_blade_right, self.m_lscs_blade_left
end

function meta:lscsBuildPlayerInfo()
	local inventory = self:lscsGetInventory()
	local equipped = self:lscsGetEquipped()
	local forcepowers = self:lscsGetForceAbilities()

	table.Empty( forcepowers ) -- all gone poof

	local stances = {}
	local hilt_right
	local hilt_left
	local blade_right
	local blade_left

	for index, item in pairs( inventory ) do
		local eq = equipped[ index ]

		if not isbool( eq ) then continue end

		local object = LSCS:ClassToItem( item )

		if not object then continue end

		local type = object.type
		local ID = object.id

		if type == "stance" then
			table.insert( stances, ID )
			continue
		end
		if type == "hilt" then
			if eq == true then
				if not hilt_right then
					hilt_right = ID
				end
			else
				if not hilt_left then
					hilt_left = ID
				end
			end
			continue
		end
		if type == "crystal" then
			if eq == true then
				if not blade_right then
					blade_right = ID
				end
			else
				if not blade_left then
					blade_left = ID
				end
			end
			continue
		end
		if type == "force" then
			local data = {}
			data.inventoryID = index
			data.item = object
			if CLIENT then data.icon = object.icon end

			table.insert( forcepowers, data )
			continue
		end
	end

	table.SortByMember( forcepowers, "inventoryID", true )

	self.m_lscs_combo = stances

	LSCS:SetBlade( self, blade_right, blade_left )
	LSCS:SetHilt( self, hilt_right, hilt_left )

	if SERVER then
		if self._lscsNetworkingReady then
			self:SendLua( "LSCS:RefreshMenu() LocalPlayer():lscsBuildPlayerInfo()" )
		end

		for _, ply in pairs( player.GetAll() ) do
			if ply == self then continue end

			self:lscsSendComboDataTo( ply )
		end

		local wep = self:GetWeapon( "weapon_lscs" )

		if IsValid( wep ) then
			wep:SetActive( false )
		end
	else
		LSCS:RefreshMenu()
	end
end

-- clear all items of this type in this hand
function meta:lscsClearEquipped( type, hand )
	local inventory = self:lscsGetInventory()
	local equipped = self:lscsGetEquipped()

	for index, item in pairs( inventory ) do
		local eq = equipped[ index ]

		local object = LSCS:ClassToItem( item )

		if not object then continue end

		local _type = object.type

		if isbool( hand ) then
			if _type == type and hand == eq then
				self:lscsEquipItem( index, nil )
			end
		else
			if _type == type then
				self:lscsEquipItem( index, nil )
			end
		end
	end
end

hook.Add( "StartCommand", "!!!!lscs_syncedinputs", function( ply, cmd )
	if not ply.lscs_cmd then ply.lscs_cmd = {} end

	-- doing it like this works better than calling ply:KeyDown() directly in the SWEP. prediction lag compensation cancer

	ply.lscs_cmd[ IN_ATTACK ] = cmd:KeyDown( IN_ATTACK )
	ply.lscs_cmd[ IN_FORWARD ] = cmd:KeyDown( IN_FORWARD )
	ply.lscs_cmd[ IN_MOVELEFT ] = cmd:KeyDown( IN_MOVELEFT )
	ply.lscs_cmd[ IN_BACK ] = cmd:KeyDown( IN_BACK )
	ply.lscs_cmd[ IN_MOVERIGHT ] = cmd:KeyDown( IN_MOVERIGHT )
	ply.lscs_cmd[ IN_SPEED ] = cmd:KeyDown( IN_SPEED )
	ply.lscs_cmd[ IN_JUMP ] = cmd:KeyDown( IN_JUMP )
end )

--PATH addons/[miecze] moce i hilty/lua/lscs/autorun/lscs_soundscripts_vader.lua:
return gluapack()()
--PATH lua/lscs/combos/advanced_form3.lua:
COMBO.id = "form3b"
COMBO.PrintName = "Advanced:Soresu(III)"
COMBO.Author = "Storm"
COMBO.Description = "Way of the Mynock."

COMBO.DeflectBullets = true
COMBO.AutoBlock = true

COMBO.BlockDistanceNormal = 60 -- distance of crosshair to block pos until  a normal block is detected with this stance. Avoid using this. Only uncomment if you really need it.
COMBO.BlockDistancePerfect = 30 -- distance of crosshair to block pos until  a perfect block is detected with this stance. Avoid using this. Only uncomment if you really need it.
COMBO.MaxBlockPoints = 130 -- use this to make op boss saber stances. Avoid using this. Only uncomment if you really need it.
COMBO.BPDrainPerHit = 15

COMBO.DamageMultiplier = 1

COMBO.LeftSaberActive = false

COMBO.HoldType = "form3_holdtype"

COMBO.Attacks = {
	["SLAM"] = {
		AttackAnim = "slashdown",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:Freeze( true )
			ply:SetVelocity( Vector(0,0,200) )
			ply:lscsSuppressFalldamage( CurTime() + 5 )

			timer.Simple( 0.5, function()
				if IsValid( weapon ) and IsValid( ply ) then
					ply:SetVelocity( Vector(0,0,-1500) )
				end
			end)
		end,
		FinishAttack = function( weapon, ply )
			ply:Freeze( false )
		end,
		Delay = 0.0,
		Duration = 1.5,
	},
	["FRONT_DASH"] = {
		AttackAnim = "combo4",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1600 )
			else
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 600 + Vector(0,0,40) )
			end
		end,

		FinishAttack = function( weapon, ply ) end,
		Delay = 0.2,
		Duration = 0.6,
	 },
	["BACKFLIP"] = {
		AttackAnim = "rollback",
		BeginAttack = function( weapon, ply )  
			weapon:SetDMGActive( false )

			ply:SetVelocity( Vector(0,0,250) - Angle(0,ply:EyeAngles().y,0):Forward() * 50 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.5,
	},
	["ROLL_RIGHT"] = {
		AttackAnim = "rollright",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) + Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["ROLL_LEFT"] = {
		AttackAnim = "rollleft",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) - Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["____"] = {
		AttackAnim = "sore_atk_w_65s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.65,
	},
	["-45-"] = {
		AttackAnim = "sore_atk_w_65s",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()

		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.65,
	},
	["+45+"] = {
		AttackAnim = "sore_atk_w_65s",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.65,
	},
	["W_S_"] = {
		AttackAnim = "sore_atk_w_65s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.7, Vector(250,0,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.7, 0.2, Vector(100,0,0) )
			ply:lscsSetTimedMove( 3, CurTime() + 0.9, 0.4, Vector(0,0,0) )

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
			timer.Simple(0.6, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 1,
	},
	["__S_"] = {
		AttackAnim = "sore_atk_s_65s",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.65,
	},
	["_A__"] = {
		AttackAnim = "soresu2_atk1_weighed_65s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.65,
	},
	["___D"] = {
		AttackAnim = "soresu2_atk2_weighed_65s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.65,
	},
	["W__D"] = { 
		AttackAnim = "sore_atk_d_65s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.65,
	},
	["WA__"] = {
		AttackAnim = "sore_atk_a_65s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.65,
	},
	["__SD"] = {
		AttackAnim = "soresu2_atk6_weighed_65s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.65,
	},
	["_AS_"] = {
		AttackAnim = "soresu2_atk5_weighed_65s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.65,
	},
	["W___"] = {
		AttackAnim = "sore_atk_w_65s",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1000 )
			end
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.65,
	},
}

--PATH addons/[miecze] moce i hilty/lua/lscs/combos/contention.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/combos/crescent.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/combos/default.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/combos/faststyle.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/combos/lusma.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/combos/lusmadual.lua:
COMBO.id = "soresudual"
COMBO.PrintName = "Lus-ma {Dual Wield}"
COMBO.Author = "Midnight"
COMBO.Description = "Lus-ma was not part of the classic combat forms of the Jedi, but its lightsaber moves and ideals are akin to those of Form III."

COMBO.DeflectBullets = true
COMBO.AutoBlock = true

COMBO.LeftSaberActive = true

COMBO.HoldType = "wos-meleeheavy-type"

COMBO.DamageMultiplier = 1
COMBO.MaxBlockPoints = 150
COMBO.BPDrainPerHit = 35
COMBO.BlockDistanceNormal = 50 -- distance of crosshair to block pos until  a normal block is detected with this stance. Avoid using this. Only uncomment if you really need it.
COMBO.BlockDistancePerfect = 15 -- distance of crosshair to block pos until  a perfect block is detected with this stance. Avoid using this. Only uncomment if you really need it.


COMBO.Attacks = {
	["SLAM"] = {
		AttackAnim = "judge_a_s1_t1",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:Freeze( true )
			ply:SetVelocity( Vector(0,0,200) )
			ply:lscsSuppressFalldamage( CurTime() + 5 )

			timer.Simple( 0.25, function()
				if IsValid( weapon ) and IsValid( ply ) then
					ply:SetVelocity( Vector(0,0,-1500) )
				end
			end)
		end,
		FinishAttack = function( weapon, ply )
			ply:Freeze( false )
		end,
		Delay = 0.0,
		Duration = 1.5,
	},
	["FRONT_DASH"] = {
		AttackAnim = "judge_b_s3_t2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
			timer.Simple(0.6, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)

			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1600 )
			else
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 200 + Vector(0,0,40) )
			end
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 1.3,
	 },
	["BACKFLIP"] = {
		AttackAnim = "rollback",
		BeginAttack = function( weapon, ply )  
			weapon:SetDMGActive( false )

			ply:SetVelocity( Vector(0,0,250) - Angle(0,ply:EyeAngles().y,0):Forward() * 100 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.5,
	},
	["ROLL_RIGHT"] = {
		AttackAnim = "",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) + Angle(0,ply:EyeAngles().y,0):Right() * 100 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["ROLL_LEFT"] = {
		AttackAnim = "",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) - Angle(0,ply:EyeAngles().y,0):Right() * 100 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["____"] = {
		AttackAnim = "b_c1_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 2, CurTime() + 0.3, 0.3, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.25,
		Duration = 0.5,
	},
	["-45-"] = {
		AttackAnim = "phalanx_h_s1_t1",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.8,
	},
	["+45+"] = {
		AttackAnim = "vanguard_b_s1_t3",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.8,
	},
	["W_S_"] = {
		AttackAnim = "h_right_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.7, Vector(250,0,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.7, 0.2, Vector(100,0,0) )
			ply:lscsSetTimedMove( 3, CurTime() + 0.9, 0.7, Vector(0,0,0) )

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
			timer.Simple(0.8, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 1.6,
	},
	["__S_"] = {
		AttackAnim = "h_right_t2",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.3,
	},
	["_A__"] = {
		AttackAnim = "judge_b_left_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(0,-100,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.3, 0.3, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.01,
		Duration = 0.5,
	},
	["___D"] = {
		AttackAnim = "judge_b_s2_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(0,100,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.3, 0.3, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.01,
		Duration = 0.6,
	},
	["W__D"] = {
		AttackAnim = "vanguard_b_s3_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.4, Vector(1,1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.01,
		Duration = 0.8,
	},
	["WA__"] = {
		AttackAnim = "vanguard_b_s3_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(25,-25,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.01,
		Duration = 0.5,
	},
	["__SD"] = {
		AttackAnim = "judge_h_s1_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-1,1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.7,
	},
	["_AS_"] = {
		AttackAnim = "vanguard_b_s1_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-1,-1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.01,
		Duration = 0.8,
	},
	["W___"] = {
		AttackAnim = "judge_b_s1_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1000 )
			end
			ply:lscsSetTimedMove( 1, CurTime(), 0.4, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.01,
		Duration = 0.4,
	},
}
LSCS:Reload()
--PATH lua/lscs/combos/master_form4.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/combos/shienso.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/combos/sumadual.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/combos/warriordual.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/combos/yongli.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/content/force_choke.lua:
local force = {}
force.PrintName = "Choke"
force.Author = "htvgamer1000"
force.Description = "Use the force to choke your target"
force.id = "choke"
force.OnClk =  function( ply, TIME )
    if not IsValid( ply.ChokeTarget ) then return end
    if ply.ChokeTarget:IsPlayer() and not ply.ChokeTarget:Alive() then ply.ChokeTarget = nil return end
    local vec = ( ( ply:EyePos() + ply:GetAimVector()*ply.ChokeDistance  ) - ply.ChokeTarget:GetPos() )
    local vec2 = ( ( ply:EyePos() + ply:GetAimVector()*2*ply.ChokeDistance  ) - ply.ChokeTarget:GetPos() )

    if ply.ChokeTarget:IsPlayer() or ply.ChokeTarget:IsNPC() then
        ply.ChokeTarget:SetLocalVelocity( vec*10 )
        local dmg = DamageInfo()
        dmg:SetDamage( 5 ) --0.21
        dmg:SetDamageType( DMG_CRUSH )
        dmg:SetAttacker( ply )
        dmg:SetInflictor( ply )
        ply.ChokeTarget:TakeDamageInfo( dmg )
    else
        local phys = ply.ChokeTarget:GetPhysicsObject()
        phys:SetVelocity( vec*10 )
    end

    ply:lscsTakeForce( 1 )

    if ply:lscsGetForce() < 1 then
        local ed = EffectData()
        ed:SetOrigin( ply.ChokeTarget:GetPos() + Vector( 0, 0, 36 ) )
        ed:SetRadius( 128 )
        util.Effect( "rb655_force_repulse_out", ed, true, true )
        if ply.ChokeTarget:IsPlayer() then
            if timer.Exists("force_whirlwind_p1_" .. ply.ChokeTarget:SteamID64()) then
                timer.Remove("force_whirlwind_p1_" .. ply.ChokeTarget:SteamID64())
            end
            ply.ChokeTarget:SetNW2Float( "wOS_Hates_Devs.WhirlwindCooldown", CurTime() + 5 )
        end
        ply.ChokeTarget = nil
    end

    if not ply:KeyReleased( IN_ATTACK2 ) then return end

    local ed = EffectData()
    ed:SetOrigin( ply.ChokeTarget:GetPos() + Vector( 0, 0, 36 ) )
    ed:SetRadius( 128 )
    util.Effect( "rb655_force_repulse_out", ed, true, true )
    if ply.ChokeTarget:IsPlayer() or ply.ChokeTarget:IsNPC() then
        ply.ChokeTarget:SetLocalVelocity( vec2*10 )
    else
        local phys = ply.ChokeTarget:GetPhysicsObject()
        phys:SetVelocity( vec2*10 )
    end
    if ply.ChokeTarget:IsPlayer() then
        if timer.Exists("force_whirlwind_p1_" .. ply.ChokeTarget:SteamID64()) then
            timer.Remove("force_whirlwind_p1_" .. ply.ChokeTarget:SteamID64())
        end
        ply.ChokeTarget:SetNW2Float( "wOS_Hates_Devs.WhirlwindCooldown", CurTime() + 5 )
    end
    ply.ChokeTarget = nil
end
force.StartUse = function( ply )
    if ply:lscsGetForce() < 1 then return end
    if IsValid( ply.ChokeTarget ) then return end
    local tr = util.TraceLine( util.GetPlayerTrace( ply ) )
    local dist = tr.HitPos:Distance( ply:GetPos() )
    if not tr.Entity then return end
    if tr.LFS then return end
    if string.match(tr.Entity:GetClass(), "_pod") then return end
    if dist >= 400 then return end
    ply.ChokeTarget = tr.Entity
    ply.ChokeDistance = dist

    return true
end
force.StopUse = function( ply )
    if not IsValid( ply.ChokeTarget ) then return end
    local ed = EffectData()
    ed:SetOrigin( ply.ChokeTarget:GetPos() + Vector( 0, 0, 36 ) )
    ed:SetRadius( 128 )
    util.Effect( "rb655_force_repulse_out", ed, true, true )

    ply.ChokeTarget = nil
end
LSCS:RegisterForce( force )

--PATH addons/[miecze] moce i hilty/lua/lscs/content/force_choke_vader.lua:
local force = {}
force.PrintName = "Sleep"
force.Author = "htvgamer1000"
force.Description = "Use the force to put your target to sleep"
force.id = "chokev"
force.OnClk =  function( ply, TIME )
    if not IsValid( ply.ChokevTarget ) then return end
    if ply.ChokevTarget:IsPlayer() and not ply.ChokevTarget:Alive() then ply.ChokevTarget = nil return end
    local vec = ( ( ply:EyePos() + ply:GetAimVector()*ply.ChokevDistance  ) - ply.ChokevTarget:GetPos() )
    local vec2 = ( ( ply:EyePos() + ply:GetAimVector()*2*ply.ChokevDistance  ) - ply.ChokevTarget:GetPos() )

    if ply.ChokevTarget:IsPlayer() or ply.ChokevTarget:IsNPC() then
        ply.ChokevTarget:SetLocalVelocity( vec*10 )
        local dmg = DamageInfo()
        dmg:SetDamage( 100 ) --0.21
        dmg:SetDamageType( DMG_CRUSH )
        dmg:SetAttacker( ply )
        dmg:SetInflictor( ply )
        ply.ChokevTarget:TakeDamageInfo( dmg )
    else
        local phys = ply.ChokevTarget:GetPhysicsObject()
        phys:SetVelocity( vec*10 )
    end

    ply:lscsTakeForce( 1 )

    if ply:lscsGetForce() < 1 then
        local ed = EffectData()
        ed:SetOrigin( ply.ChokevTarget:GetPos() + Vector( 0, 0, 36 ) )
        ed:SetRadius( 128 )
        util.Effect( "rb655_force_repulse_out", ed, true, true )
        if ply.ChokevTarget:IsPlayer() then
            if timer.Exists("force_whirlwind_p1_" .. ply.ChokevTarget:SteamID64()) then
                timer.Remove("force_whirlwind_p1_" .. ply.ChokevTarget:SteamID64())
            end
            ply.ChokevTarget:SetNW2Float( "wOS_Hates_Devs.WhirlwindCooldown", CurTime() + 5 )
        end
        ply.ChokevTarget = nil
    end

    if not ply:KeyReleased( IN_ATTACK2 ) then return end

    local ed = EffectData()
    ed:SetOrigin( ply.ChokevTarget:GetPos() + Vector( 0, 0, 36 ) )
    ed:SetRadius( 128 )
    util.Effect( "rb655_force_repulse_out", ed, true, true )
    if ply.ChokevTarget:IsPlayer() or ply.ChokevTarget:IsNPC() then
        ply.ChokevTarget:SetLocalVelocity( vec2*10 )
    else
        local phys = ply.ChokevTarget:GetPhysicsObject()
        phys:SetVelocity( vec2*10 )
    end
    if ply.ChokevTarget:IsPlayer() then
        if timer.Exists("force_whirlwind_p1_" .. ply.ChokevTarget:SteamID64()) then
            timer.Remove("force_whirlwind_p1_" .. ply.ChokevTarget:SteamID64())
        end
        ply.ChokevTarget:SetNW2Float( "wOS_Hates_Devs.WhirlwindCooldown", CurTime() + 5 )
    end
    ply.ChokevTarget = nil
end
force.StartUse = function( ply )
    if ply:lscsGetForce() < 1 then return end
    if IsValid( ply.ChokevTarget ) then return end
    local tr = util.TraceLine( util.GetPlayerTrace( ply ) )
    local dist = tr.HitPos:Distance( ply:GetPos() )
    if not tr.Entity then return end
    if tr.LFS then return end
    if string.match(tr.Entity:GetClass(), "_pod") then return end
    if dist >= 400 then return end
    ply.ChokevTarget = tr.Entity
    ply.ChokevDistance = dist

    return true
end
force.StopUse = function( ply )
    if not IsValid( ply.ChokevTarget ) then return end
    local ed = EffectData()
    ed:SetOrigin( ply.ChokevTarget:GetPos() + Vector( 0, 0, 36 ) )
    ed:SetRadius( 128 )
    util.Effect( "rb655_force_repulse_out", ed, true, true )

    ply.ChokevTarget = nil
end
LSCS:RegisterForce( force )

--PATH addons/[miecze] moce i hilty/lua/lscs/content/force_drain.lua:
local force = {}
force.PrintName = "Drain Life Essense"
force.Author = "Midnight"
force.Description = "A Dark Side ability that drains a target's health to restore your own."
force.id = "drain"
force.StartUse = function(ply)
    local Time = CurTime()

    if (ply._lscsNextForceReplenish or 0) > Time then return end
    ply._lscsNextForceReplenish = Time + 2

    local tr = util.TraceLine({
        start = ply:GetShootPos(),
        endpos = ply:GetShootPos() + ply:GetAimVector() * 500, -- That number defines how far away someone can be before this shit don't work
        filter = ply
    }) -- I copied and pasted this from another force power lmao

    local target = tr.Entity

   
    if IsValid(target) and target:IsPlayer() and target:Health() > 0 then -- Ima be real I had help with this
        if ply:lscsGetForce() < 10 then return end -- Erm that number changes how much force someone NEEDS to use the power
        ply:lscsTakeForce(10) -- Real shit idk how much I should make this cost
        local damage = 25  -- If you change that funny number you can make it damage people more
        local heal = math.min(damage, target:Health()) -- It takes that funny number up there and slaps it onto your health, unless you have max health, then it doesn't work.

        local d = DamageInfo() -- DAMAGEDAMAGEAMDAMGEM
        d:SetDamage(damage)
        d:SetAttacker(ply)
        d:SetInflictor(ply)
        d:SetDamageType(DMG_DROWN) 
        d:SetDamagePosition(target:GetPos())
        target:TakeDamageInfo(d)

        ply:SetHealth(math.min(ply:Health() + heal, ply:GetMaxHealth()))

        ply:EmitSound("lscs/force/drain.mp3") -- The fuck am I doing
        target:EmitSound("lscs/force/drain.mp3")

        LSCS:PlayVCDSequence( ply, "gesture_becon", 0.8 )

        local effectdata = EffectData() -- Funny effect I stole from replenish
        effectdata:SetOrigin(ply:GetPos())
        effectdata:SetEntity(ply)
        util.Effect("force_replenish", effectdata, true, true)

        -- This does the same thing as that^ except to the person you're looking at
        local targetEffect = EffectData()
        targetEffect:SetOrigin(target:GetPos())
        targetEffect:SetEntity(target)
        util.Effect("force_replenish", targetEffect, true, true)
    else -- Ngl I had a plan but I forgot the plan
    end
end

LSCS:RegisterForce(force)

local force = {}
force.PrintName = "Life Steal"
force.Author = "Midnight"
force.Description = "A Dark Side ability that continuously drains a target's health, while restoring your own."
force.id = "lifesteal"

-- AHHHHHHHH
local function DrainTarget(ply, target)
    if not IsValid(target) or not target:IsPlayer() then return end

    local damage = 5  -- Change this if you want to up the damage
    local heal = math.min(damage, target:Health())

    local d = DamageInfo()
    d:SetDamage(damage)
    d:SetAttacker(ply)
    d:SetInflictor(ply)
    d:SetDamageType(DMG_DROWN)
    d:SetDamagePosition(target:GetPos())
    target:TakeDamageInfo(d)

    ply:SetHealth(math.min(ply:Health() + heal, ply:GetMaxHealth()))

    ply:EmitSound("lscs/force/drain.mp3")
    target:EmitSound("lscs/force/drain.mp3")

    local effectdata = EffectData() -- user bitch
    effectdata:SetOrigin(ply:GetPos())
    effectdata:SetEntity(ply)
    util.Effect("force_replenish", effectdata, true, true)

    local targetEffect = EffectData() -- Targeted bitch
    targetEffect:SetOrigin(target:GetPos())
    targetEffect:SetEntity(target)
    util.Effect("force_replenish", targetEffect, true, true)
end

force.OnClk = function(ply, TIME)
    if not ply._lscsLifeStealTime then return end

    -- This makes sure the bitch has enough force
    if ply:lscsGetForce() < 1 then
        ply._lscsLifeStealTime = nil
        ply._lscsLifeStealStartTime = nil
        return
    end

    ply:lscsTakeForce(1) -- YEAH IT COSTS 1 SO WHAT?

    if ply._lscsLifeStealStartTime < TIME then
        LSCS:PlayVCDSequence(ply, "gesture_becon", 0.8)
    end

    local tr = util.TraceLine({
        start = ply:GetShootPos(),
        endpos = ply:GetShootPos() + ply:GetAimVector() * 500,
        filter = ply
    })

    local target = tr.Entity

    if IsValid(target) and target:IsPlayer() and target:Health() > 0 then
        DrainTarget(ply, target)
    else
        ply._lscsLifeStealTime = nil
        ply._lscsLifeStealStartTime = nil
    end
end

force.Equip = function(ply) end
force.UnEquip = function(ply) end

force.StartUse = function(ply)
    local Time = CurTime()

    -- COOLDOWN or smth I forgot
    if (ply._lscsLifeStealTime or 0) > Time then
        ply._lscsLifeStealTime = nil
        ply._lscsLifeStealStartTime = nil
        return
    end

    -- Check if the player has enough Force to activate
    if ply:lscsGetForce() < 10 then return end

    local CanDo = (ply._lscsNextForce or 0) < Time and (ply._lscsLifeStealTime or 0) < Time
    if not CanDo then return end

    ply._lscsNextForce = Time + 2  -- Cooldown between uses

    ply:EmitSound("lscs/force/drain.mp3")

    -- Lmao the fee to use the power yep
    ply:lscsTakeForce(10)

    if not ply._lscsLifeStealTime then
        ply._lscsLifeStealTime = CurTime() + 3.5  -- Duration of effect
        ply._lscsLifeStealStartTime = CurTime() + 0.15

        LSCS:PlayVCDSequence(ply, "gesture_signal_forward", 0.1)
    end
end

force.StopUse = function(ply)
    ply._lscsLifeStealTime = nil
    ply._lscsLifeStealStartTime = nil
end

LSCS:RegisterForce(force)

--PATH addons/[miecze] moce i hilty/lua/lscs/content/force_ignite.lua:
return gluapack()()
--PATH lua/lscs/content/force_judgement.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/content/force_meditation.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/content/force_revive.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/content/force_shrinkother.lua:
local force = {}
force.PrintName = "Shrink Other"
force.Author = "Midnight"
force.Description = "Shrink your target using the force. Why you might ask? Just for funnies"
force.id = "shrinkother" -- lowercase only

force.StartUse = function(ply)
    if ply:lscsGetForce() < 10 then return end -- Check if the player has enough Force points

    -- Perform a trace to find the target
    local tr = ply:GetEyeTrace()
    local target = tr.Entity

    -- Ensure the target is a valid player or NPC
    if IsValid(target) and (target:IsPlayer() or target:IsNPC()) then
        ply:lscsTakeForce(10) -- Deduct Force points required to use the power

        target:SetModelScale(0.5, 1) -- Scale the target's model up to 200%
        ply:EmitSound("npc/combine_gunship/ping_search.wav") -- Play sound effect
        LSCS:PlayVCDSequence(ply, "gesture_signal_halt", 0) -- Play animation

        -- Optional: Reset the target's scale after 10 seconds
        timer.Create("ResetModelScale_" .. target:EntIndex(), 10, 1, function()
            if IsValid(target) then
                target:SetModelScale(1, 1) -- Reset to normal size
            end
        end)
    end
end

force.StopUse = function(ply)
    -- Called when the force power key is released
end

LSCS:RegisterForce(force)

--PATH addons/[miecze] moce i hilty/lua/lscs/content/hilts_crazy.lua:
 local hilt = {}
hilt.PrintName = "Annabelle"
hilt.Author = "Ibeany"
hilt.id = "annabelle"
hilt.mdl = "models/lscs/weapons/w_annabelle.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(15, 0, 0),
            ang = Angle(180, 0, 0),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(15, -2, 0),
            ang = Angle(-180, 0, 180),
        },
    },
    GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(3.75,-0.6,2.5) ),
                dir = ent:LocalToWorldAngles( Angle(95,180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Stunbaton"
hilt.Author = "Ibeany"
hilt.id = "stunbaton"
hilt.mdl = "models/lscs/weapons/w_stunbaton.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, -6.5),
            ang = Angle(-90, -90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, 6.5),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(-10,1,1) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Inconspicuous Briefcase"
hilt.Author = "Ibeany"
hilt.id = "case"
hilt.mdl = "models/lscs/weapons/gman_briefcase.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(18, -1, 0),
            ang = Angle(-90, 90, -90),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(18, -1, 0),
            ang = Angle(90, -90, 90),
        },
    },
    GetBladePos = function( ent ) 
         local blades = {
                 [1] = {
                pos = ent:LocalToWorld( Vector(0,0,10) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,.1) ):Up(),
            },
       [2] = {
                pos = ent:LocalToWorld( Vector(0,0,5) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,.1) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Pistol"
hilt.Author = "Ibeany"
hilt.id = "pistol"
hilt.mdl = "models/lscs/weapons/w_pistol.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(5.5, -2, -3),
            ang = Angle(180, 0, 0),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(5.5, -1, 3),
            ang = Angle(-180, 0, 180),
        },
    },
    GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(2,0,0) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Crowbar"
hilt.Author = "Uptxred"
hilt.id = "crowbar"
hilt.mdl = "models/lscs/weapons/w_crowbar.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -2.5, -7.8),
            ang = Angle(-90, -90, -140),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1, 0),
            ang = Angle(90, 90, 90),
        },
    },
    GetBladePos = function( ent ) 
        local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(5,0,0) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

local hilt = {}
hilt.PrintName = "Crossbow"
hilt.Author = "Uptxred"
hilt.id = "Crossbow"
hilt.mdl = "models/lscs/weapons/w_crossbow.mdl"
hilt.info = {
    ParentData = {
        ["RH"] = {
            bone = "ValveBiped.Bip01_R_Hand",
            pos = Vector(3.75, -1.5, 0),
            ang = Angle(90,0,0),
        },
        ["LH"] = {
            bone = "ValveBiped.Bip01_L_Hand",
            pos = Vector(3.75, -1.5, 0),
            ang = Angle(90,0,0),
        },
    },
    GetBladePos = function( ent ) 
               local blades = {
            [1] = {
                pos = ent:LocalToWorld( Vector(-3,0,0) ),
                dir = ent:LocalToWorldAngles( Angle(90,180,0) ):Up(),
            },
        }

        return blades
    end,
}
LSCS:RegisterHilt( hilt )

--PATH addons/[miecze] moce i hilty/lua/lscs/content/hilts_swtor.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/lscs/content/hilts_swtor.lua:
toCreate = { -- dont remove
	["Antique Socorro [Dorn]"] = {
		mdl = "models/swtor/arsenic/lightsabers/antiquesocorrolightsaberdorn.mdl",
		pData = {
			["RHpos"] = Vector(3.75, -1.5, 0),
			["RHang"] = Angle(-90, -90, -90),
			["LHpos"] = Vector(3.75, -1, 0),
			["LHang"] = Angle(90, 90, 90),
		},
	}, -- That is default example for needing to edit pos / ang, most dont need it. 
	["Antique Socorro [Aurek]"] = {
		mdl = "models/swtor/arsenic/lightsabers/antiquesocorrolightsabercresh.mdl",
	},
	["Arakyd"] = {
		mdl = "models/swtor/arsenic/lightsabers/arakydsaber.mdl",
	},
	["Ardent Defender"] = {
		mdl = "models/swtor/arsenic/lightsabers/ardentdefender'slightsaber.mdl",
	},
	["Ashara"] = {
		mdl = "models/swtor/arsenic/lightsabers/ashara'slightsaber.mdl",
	},
	["Challenger"] = {
		mdl = "models/swtor/arsenic/lightsabers/challenger'slightsaber.mdl",
	},
	["Chrysopaz"] = {
		mdl = "models/swtor/arsenic/lightsabers/chrysopazlightsaber.mdl",
	},
	["Corusca"] = {
		mdl = "models/swtor/arsenic/lightsabers/coruscalightsaber.mdl",
	},
	["Defender"] = {
		mdl = "models/swtor/arsenic/lightsabers/defender'slightsaber.mdl",
	},
	["Derelict"] = {
		mdl = "models/swtor/arsenic/lightsabers/derelictlightsaber.mdl",
	},
	["Dragonpearl"] = {
		mdl = "models/swtor/arsenic/lightsabers/dragonpearllightsaber.mdl",
	},
	["Eternal Commander"] = {
		mdl = "models/swtor/arsenic/lightsabers/eternalcommandermk-4lightsaber.mdl",
	},
	["Exarch 2"] = {
		mdl = "models/swtor/arsenic/lightsabers/exarch'smk-2lightsaber.mdl",
	},
	["Executioner"] = {
		mdl = "models/swtor/arsenic/lightsabers/executioner'slightsaber.mdl",
	},
	["Fearless Retaliator"] = {
		mdl = "models/swtor/arsenic/lightsabers/fearlessretaliator'slightsaber.mdl",
	},
	["Frontier Hunter"] = {
		mdl = "models/swtor/arsenic/lightsabers/frontierhunter'slightsaber.mdl",
	},
	["Iokath"] = {
		mdl = "models/swtor/arsenic/lightsabers/geminimk-4lightsaber.mdl",
	},
	["Hiridu"] = {
		mdl = "models/swtor/arsenic/lightsabers/hiridulightsaber.mdl",
	},
	["Inscrutable"] = {
		mdl = "models/swtor/arsenic/lightsabers/inscrutablelightsaber.mdl",
	},
	["Instigator"] = {
		mdl = "models/swtor/arsenic/lightsabers/instigator'slightsaber.mdl",
	},
	["Mytag"] = {
		mdl = "models/swtor/arsenic/lightsabers/mytaglightsaber.mdl",
	},
	["Nova"] = {
		mdl = "models/swtor/arsenic/lightsabers/novalightsaber.mdl",
	},
	["Outlander"] = {
		mdl = "models/swtor/arsenic/lightsabers/outlanderlightsaber.mdl",
	},
	["Outlander 2"] = {
		mdl = "models/swtor/arsenic/lightsabers/outlanderlightsaber2.mdl",
	},
	["Overseer"] = {
		mdl = "models/swtor/arsenic/lightsabers/overseer'slightsaber.mdl",
	},
	["Pitiless Raider"] = {
		mdl = "models/swtor/arsenic/lightsabers/pitilessraiderlightsaber.mdl",
	},
	["Praetorian"] = {
		mdl = "models/swtor/arsenic/lightsabers/praetorian'slightsaber.mdl",
	},
	["Prismatic"] = {
		mdl = "models/swtor/arsenic/lightsabers/prismaticlightsaber.mdl",
	},
	["Revanite 2"] = {
		mdl = "models/swtor/arsenic/lightsabers/revanite'smk-1lightsaber.mdl",
	},
	["Righteous Prime"] = {
		mdl = "models/swtor/arsenic/lightsabers/righteousprimevallightsaber.mdl",
	},
	["Satele Shan"] = {
		mdl = "models/swtor/arsenic/lightsabers/sateleshan'ssparringlightsaber.mdl",
	},
	["Stronghold Defender"] = {
		mdl = "models/swtor/arsenic/lightsabers/strongholddefender'slightsaber.mdl",
	},
	["Thermal"] = {
		mdl = "models/swtor/arsenic/lightsabers/thermallightsabermk-3.mdl",
	},
	["Thexan"] = {
		mdl = "models/swtor/arsenic/lightsabers/thexan'slightsaber.mdl",
	},
	["Tythonian"] = {
		mdl = "models/swtor/arsenic/lightsabers/tythonianforce-master'slightsaber.mdl",
	},
	["Vindicator"] = {
		mdl = "models/swtor/arsenic/lightsabers/vindicator'slightsaber.mdl",
	},
} -- dont remove


local Author = "Midnight" -- Feel free to change i dont care
local Usum = "1"
for k,v in pairs(toCreate) do
	local hilt = {}
	hilt.PrintName = k or Usum -- avoid conflict if someone fucks it up
	hilt.Author = Author
	hilt.id = k or Usum -- as said above
	hilt.mdl = v.mdl or "models/lscs/weapons/katarn.mdl" -- as said above
	hilt.info = {
		ParentData = {
			["RH"] = {
				bone = "ValveBiped.Bip01_R_Hand",
				pos = Vector(3.75, -1.5, -6.5), -- RightHandpos if needs editing.
				ang = Angle(-90, -90, -90), -- RightHandang if needs editing
			},
			["LH"] = {
				bone = "ValveBiped.Bip01_L_Hand",
				pos = Vector(3.75, -1, 6.5), -- same for left
				ang = Angle(90, 90, 90),
			},
		},
		GetBladePos = function( ent ) 

			local blades = {}
		
			for k,v in ipairs(ent:GetAttachments()) do -- loop through attachments credit to rubat
				if string.StartWith(v.name, "blade") then -- Waiting for string.StartsWith (Only on dev branch as of 28/01)
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward()}) -- chad status
				end
				if string.StartWith(v.name, "quillon") then
					table.insert(blades, {pos = ent:GetAttachment(v.id).Pos, dir = ent:GetAttachment(v.id).Ang:Forward(), length_multiplier = 0.15,})
				end
			end
		
			return blades
		end,
	}
	print("registered " .. k)
	
	if v.pData then
		hilt.info.ParentData["RH"].pos = v.pData["RHpos"]
		hilt.info.ParentData["RH"].ang = v.pData["RHang"]
		
		hilt.info.ParentData["LH"].pos = v.pData["LHpos"]
		hilt.info.ParentData["LH"].ang = v.pData["LHang"]
	end
	LSCS:RegisterHilt( hilt ) -- register the hilt
	Usum = Usum .. "1"
	
	
	
end
print("Extra Sabers Loaded - You're welcome. And this took like an hour total effort.")
--PATH addons/[miecze] moce i hilty/lua/lscs/content/lscs_forcepowers.lua:
local force = {}
force.PrintName = "Throw"
force.Author = "Blu-x92 / Luna"
force.Description = "Throw your Lightsaber"
force.id = "throw"
force.StartUse = function( ply )
	if ply:InVehicle() then return end

	local CurSWEP = ply:GetActiveWeapon()
	local SWEP = ply:GetWeapon( "weapon_lscs" )

	if IsValid( CurSWEP ) then
		if CurSWEP.LSCS then
			SWEP = CurSWEP
		end
	end

	if not IsValid( SWEP ) then return end
	if SWEP:IsBrokenSaber() then return end

	if (ply._lscsNextThrow or 0) > CurTime() then return end

	ply._lscsNextThrow = CurTime() + 1

	if IsValid( ply._lscsThrownSaber ) then
		if not ply._lscsThrownSaber.Returning then
			ply._lscsThrownSaber:ResetProgress()
			ply._lscsThrownSaber.Returning = true
		end
	else
		if ply:lscsGetForce() < 10 then return end

		if ply:GetActiveWeapon() ~= SWEP then
			ply:SelectWeapon( "weapon_lscs" )
		end

		LSCS:PlayVCDSequence( ply, "zombie_attack_02", 0.3 )

		local proj = ents.Create("lscs_projectile")
		proj:SetPos( ply:GetShootPos() - Vector(0,0,20) )
		proj:SetSWEP( SWEP )
		proj:Spawn()
		proj:Activate()

		ply:EmitSound("npc/zombie/claw_miss1.wav")

		SWEP:SetHoldType( "magic" )

		ply._lscsThrownSaber = proj
	end
end
force.StopUse = function( ply )
	if IsValid( ply._lscsThrownSaber ) then
		ply._lscsThrownSaber:ResetProgress()
		ply._lscsThrownSaber.Returning = true
	end
end

LSCS:RegisterForce( force )


local force = {}
force.PrintName = "Jump"
force.Author = "Blu-x92 / Luna"
force.Description = "Force Assisted Jump"
force.id = "jump"
force.OnClk =  function( ply, TIME )
	if not ply._lscsAssistedJump then return end

	if ply:OnGround() then
		ply._lscsCanForceJump = true
		ply._lscsPlayedJumpSound = false
		ply._lscsJumpForceTaken = nil
	end

	local JUMP = ply:KeyDown( IN_JUMP ) and not ply:InVehicle() and RPExtraTeams[ply:Team()].jedi

	if JUMP then
		local wep = ply:GetActiveWeapon()
		if IsValid( wep ) and wep.LSCS then
			if wep:IsComboActive() then JUMP = false end
		end
	end

	if JUMP ~= ply._lscsOldJump then
		ply._lscsOldJump = JUMP
		if JUMP then
			ply._lscsJumpTime = TIME + 0.1
		else
			if not ply:OnGround() then
				ply._lscsCanForceJump = false
			end
		end
	end

	if JUMP and ply:lscsGetForce() > 0 and (ply._lscsJumpForceTaken or 0) < 35 and ply._lscsCanForceJump and (ply._lscsJumpTime or 0) < TIME and not ply:OnGround() then
		ply:lscsSuppressFalldamage( TIME + 5 )
		ply:SetVelocity( Vector(0,0,150) + Angle(0,ply:EyeAngles().y,0):Forward() * 5 )
		ply:lscsTakeForce( 4 )
		ply._lscsJumpForceTaken = ply._lscsJumpForceTaken and ply._lscsJumpForceTaken + 2.5 or 0

		if not ply._lscsPlayedJumpSound then
			ply._lscsPlayedJumpSound = true

			net.Start( "lscs_start_jump" )
			net.Send( ply )

			ply:EmitSound("lscs/force/jump.mp3")
		end
	end
end
force.Equip = function( ply ) ply._lscsAssistedJump = true end
force.UnEquip = function( ply ) ply._lscsAssistedJump = false end
force.StartUse = function( ply )
	if ply._lscsForceJumpTime then
		ply._lscsForceJumpTime = nil
	else
		if ply:InVehicle() then return end

		ply._lscsForceJumpTime = CurTime() + 2
	end
end
force.StopUse = function( ply )
	ply._lscsForceJumpTime = nil
end
LSCS:RegisterForce( force )

local force = {}
force.PrintName = "Jump II"
force.Author = "Valkorius"
force.Description = "Force Assisted Jump"
force.id = "jumpii"
force.OnClk =  function( ply, TIME )
	if not ply._lscsAssistedJump then return end

	if ply:OnGround() then
		ply._lscsCanForceJump = true
		ply._lscsPlayedJumpSound = false
		ply._lscsJumpForceTaken = nil
	end

	local JUMP = ply:KeyDown( IN_JUMP ) and not ply:InVehicle() and RPExtraTeams[ply:Team()].jedi

	if JUMP then
		local wep = ply:GetActiveWeapon()
		if IsValid( wep ) and wep.LSCS then
			if wep:IsComboActive() then JUMP = false end
		end
	end

	if JUMP ~= ply._lscsOldJump then
		ply._lscsOldJump = JUMP
		if JUMP then
			ply._lscsJumpTime = TIME + 0.1
		else
			if not ply:OnGround() then
				ply._lscsCanForceJump = false
			end
		end
	end

	if JUMP and ply:lscsGetForce() > 0 and (ply._lscsJumpForceTaken or 0) < 35 and ply._lscsCanForceJump and (ply._lscsJumpTime or 0) < TIME and not ply:OnGround() then
		ply:lscsSuppressFalldamage( TIME + 5 )
		ply:SetVelocity( Vector(0,0,150) + Angle(0,ply:EyeAngles().y,0):Forward() * 5 )
		ply:lscsTakeForce( 2.5 )
		ply._lscsJumpForceTaken = ply._lscsJumpForceTaken and ply._lscsJumpForceTaken + 2.5 or 0

		if not ply._lscsPlayedJumpSound then
			ply._lscsPlayedJumpSound = true

			net.Start( "lscs_start_jump" )
			net.Send( ply )

			ply:EmitSound("lscs/force/jump.mp3")
		end
	end
end
force.Equip = function( ply ) ply._lscsAssistedJump = true end
force.UnEquip = function( ply ) ply._lscsAssistedJump = false end
force.StartUse = function( ply )
	if ply._lscsForceJumpTime then
		ply._lscsForceJumpTime = nil
	else
		if ply:InVehicle() then return end

		ply._lscsForceJumpTime = CurTime() + 2
	end
end
force.StopUse = function( ply )
	ply._lscsForceJumpTime = nil
end
LSCS:RegisterForce( force )

local force = {}
force.PrintName = "Jump III"
force.Author = "Valkorius"
force.Description = "Force Assisted Jump"
force.id = "jumpiii"
force.OnClk =  function( ply, TIME )
	if not ply._lscsAssistedJump then return end

	if ply:OnGround() then
		ply._lscsCanForceJump = true
		ply._lscsPlayedJumpSound = false
		ply._lscsJumpForceTaken = nil
	end

	local JUMP = ply:KeyDown( IN_JUMP ) and not ply:InVehicle() and RPExtraTeams[ply:Team()].jedi

	if JUMP then
		local wep = ply:GetActiveWeapon()
		if IsValid( wep ) and wep.LSCS then
			if wep:IsComboActive() then JUMP = false end
		end
	end

	if JUMP ~= ply._lscsOldJump then
		ply._lscsOldJump = JUMP
		if JUMP then
			ply._lscsJumpTime = TIME + 0.1
		else
			if not ply:OnGround() then
				ply._lscsCanForceJump = false
			end
		end
	end

	if JUMP and ply:lscsGetForce() > 0 and (ply._lscsJumpForceTaken or 0) < 35 and ply._lscsCanForceJump and (ply._lscsJumpTime or 0) < TIME and not ply:OnGround() then
		ply:lscsSuppressFalldamage( TIME + 5 )
		ply:SetVelocity( Vector(0,0,150) + Angle(0,ply:EyeAngles().y,0):Forward() * 5 )
		ply:lscsTakeForce( 1.25 )
		ply._lscsJumpForceTaken = ply._lscsJumpForceTaken and ply._lscsJumpForceTaken + 2.5 or 0

		if not ply._lscsPlayedJumpSound then
			ply._lscsPlayedJumpSound = true

			net.Start( "lscs_start_jump" )
			net.Send( ply )

			ply:EmitSound("lscs/force/jump.mp3")
		end
	end
end
force.Equip = function( ply ) ply._lscsAssistedJump = true end
force.UnEquip = function( ply ) ply._lscsAssistedJump = false end
force.StartUse = function( ply )
	if ply._lscsForceJumpTime then
		ply._lscsForceJumpTime = nil
	else
		if ply:InVehicle() then return end

		ply._lscsForceJumpTime = CurTime() + 2
	end
end
force.StopUse = function( ply )
	ply._lscsForceJumpTime = nil
end
LSCS:RegisterForce( force )


local force = {}
force.PrintName = "Push"
force.Author = "Blu-x92 / Luna"
force.Description = "Push things around"
force.id = "push"
force.StartUse = function( ply )
	if ply:lscsGetForce() < 20 then return end

	local Time = CurTime()

	local CanPush = (ply._lscsNextForce or 0) < Time

	if not CanPush then return end

	ply._lscsNextForce = Time + 1

	ply:EmitSound("lscs/force/push.mp3")
	ply:lscsTakeForce( 10 ) --Push gcnn tkettii force miktar

	local AimVector = ply:GetAimVector()
	local MyPos = ply:GetShootPos()

	LSCS:PlayVCDSequence( ply, "gesture_item_throw", 0.5 )

	local effectdata = EffectData()
		effectdata:SetOrigin( MyPos )
		effectdata:SetNormal( AimVector )
		effectdata:SetEntity( ply )
	util.Effect( "force_push", effectdata, true, true )

	for _, Ent in pairs( ents.FindInSphere( MyPos, 800 ) ) do
		local Sub = (Ent.GetShootPos and Ent:GetShootPos() or Ent:GetPos()) - MyPos
		local ToTarget = Sub:GetNormalized()

		if math.deg( math.acos( math.Clamp( AimVector:Dot( ToTarget ) ,-1,1) ) ) < 30 then
			local Dist = Sub:Length()

			if IsValid( Ent ) and Dist < 800 then
				local Vel = Sub:GetNormalized() * 500 + Vector(0,0,50) -- +dan nceki say itilme mesafesini belirliyor. Vector iindeki saylardan sonuncusu dikey yn belirtir.

				LSCS:ForceApply( Ent, Vel, ply )
			end
		end
	end
end
LSCS:RegisterForce( force )

local force = {}
force.PrintName = "Push II"
force.Author = "Valkorius"
force.Description = "Push things around even more"
force.id = "pushii"
force.StartUse = function( ply )
	if ply:lscsGetForce() < 20 then return end

	local Time = CurTime()

	local CanPush = (ply._lscsNextForce or 0) < Time

	if not CanPush then return end

	ply._lscsNextForce = Time + 1

	ply:EmitSound("lscs/force/push.mp3")
	ply:lscsTakeForce( 20 ) --Push gcnn tkettii force miktar

	local AimVector = ply:GetAimVector()
	local MyPos = ply:GetShootPos()

	LSCS:PlayVCDSequence( ply, "gesture_item_throw", 0.5 )

	local effectdata = EffectData()
		effectdata:SetOrigin( MyPos )
		effectdata:SetNormal( AimVector )
		effectdata:SetEntity( ply )
	util.Effect( "force_push", effectdata, true, true )

	for _, Ent in pairs( ents.FindInSphere( MyPos, 800 ) ) do
		local Sub = (Ent.GetShootPos and Ent:GetShootPos() or Ent:GetPos()) - MyPos
		local ToTarget = Sub:GetNormalized()

		if math.deg( math.acos( math.Clamp( AimVector:Dot( ToTarget ) ,-1,1) ) ) < 30 then
			local Dist = Sub:Length()

			if IsValid( Ent ) and Dist < 800 then
				local Vel = Sub:GetNormalized() * 1000 + Vector(0,0,50) -- +dan nceki say itilme mesafesini belirliyor. Vector iindeki saylardan sonuncusu dikey yn belirtir.

				LSCS:ForceApply( Ent, Vel, ply )
			end
		end
	end
end
LSCS:RegisterForce( force )

local force = {}
force.PrintName = "Push III"
force.Author = "Valkorius"
force.Description = "Push things around even even more"
force.id = "pushiii"
force.StartUse = function( ply )
	if ply:lscsGetForce() < 20 then return end

	local Time = CurTime()

	local CanPush = (ply._lscsNextForce or 0) < Time

	if not CanPush then return end

	ply._lscsNextForce = Time + 1

	ply:EmitSound("lscs/force/push.mp3")
	ply:lscsTakeForce( 30 ) --Push gcnn tkettii force miktar

	local AimVector = ply:GetAimVector()
	local MyPos = ply:GetShootPos()

	LSCS:PlayVCDSequence( ply, "gesture_item_throw", 0.5 )

	local effectdata = EffectData()
		effectdata:SetOrigin( MyPos )
		effectdata:SetNormal( AimVector )
		effectdata:SetEntity( ply )
	util.Effect( "force_push", effectdata, true, true )

	for _, Ent in pairs( ents.FindInSphere( MyPos, 800 ) ) do
		local Sub = (Ent.GetShootPos and Ent:GetShootPos() or Ent:GetPos()) - MyPos
		local ToTarget = Sub:GetNormalized()

		if math.deg( math.acos( math.Clamp( AimVector:Dot( ToTarget ) ,-1,1) ) ) < 30 then
			local Dist = Sub:Length()

			if IsValid( Ent ) and Dist < 800 then
				local Vel = Sub:GetNormalized() * 2000 + Vector(0,0,50) -- +dan nceki say itilme mesafesini belirliyor. Vector iindeki saylardan sonuncusu dikey yn belirtir.

				LSCS:ForceApply( Ent, Vel, ply )
			end
		end
	end
end
LSCS:RegisterForce( force )


local force = {}
force.PrintName = "Pull"
force.Author = "Blu-x92 / Luna"
force.Description = "Pull things towards yourself"
force.id = "pull"
force.StartUse = function( ply )
	if ply:lscsGetForce() < 20 then return end

	local Time = CurTime()

	local CanPush = (ply._lscsNextForce or 0) < Time

	if not CanPush then return end

	ply._lscsNextForce = Time + 1

	ply:EmitSound("lscs/force/pull.mp3")
	ply:lscsTakeForce( 10 ) --Pullun ald force miktar

	local AimVector = ply:GetAimVector()
	local MyPos = ply:GetShootPos()

	LSCS:PlayVCDSequence( ply, "gesture_becon", 0.8 )

	local effectdata = EffectData()
		effectdata:SetOrigin( MyPos )
		effectdata:SetNormal( AimVector )
		effectdata:SetEntity( ply )
	util.Effect( "force_pull", effectdata, true, true )

	for _, Ent in pairs( ents.FindInSphere( MyPos, 200 ) ) do --ekme yarap
		local Sub = (Ent.GetShootPos and Ent:GetShootPos() or Ent:GetPos()) - MyPos
		local ToTarget = Sub:GetNormalized()

		if math.deg( math.acos( math.Clamp( AimVector:Dot( ToTarget ) ,-1,1) ) ) < 20 then
			local Dist = Sub:Length()

			if IsValid( Ent ) and Dist < 800 then
				local Vel = -Sub:GetNormalized() * 500 + Vector(0,0,50) -- + dan nceki ksm ekme kudreti

				LSCS:ForceApply( Ent, Vel, ply )
			end
		end
	end
end
LSCS:RegisterForce( force )

local force = {}
force.PrintName = "Pull II"
force.Author = "Valkorius"
force.Description = "Pull things towards yourself even more"
force.id = "pullii"
force.StartUse = function( ply )
	if ply:lscsGetForce() < 20 then return end

	local Time = CurTime()

	local CanPush = (ply._lscsNextForce or 0) < Time

	if not CanPush then return end

	ply._lscsNextForce = Time + 1

	ply:EmitSound("lscs/force/pull.mp3")
	ply:lscsTakeForce( 20 ) --Pullun ald force miktar

	local AimVector = ply:GetAimVector()
	local MyPos = ply:GetShootPos()

	LSCS:PlayVCDSequence( ply, "gesture_becon", 0.8 )

	local effectdata = EffectData()
		effectdata:SetOrigin( MyPos )
		effectdata:SetNormal( AimVector )
		effectdata:SetEntity( ply )
	util.Effect( "force_pull", effectdata, true, true )

	for _, Ent in pairs( ents.FindInSphere( MyPos, 500 ) ) do --ekme yarap
		local Sub = (Ent.GetShootPos and Ent:GetShootPos() or Ent:GetPos()) - MyPos
		local ToTarget = Sub:GetNormalized()

		if math.deg( math.acos( math.Clamp( AimVector:Dot( ToTarget ) ,-1,1) ) ) < 20 then
			local Dist = Sub:Length()

			if IsValid( Ent ) and Dist < 800 then
				local Vel = -Sub:GetNormalized() * 750 + Vector(0,0,50) -- + dan nceki ksm ekme kudreti

				LSCS:ForceApply( Ent, Vel, ply )
			end
		end
	end
end
LSCS:RegisterForce( force )

local force = {}
force.PrintName = "Pull III"
force.Author = "Valkorius"
force.Description = "Pull things towards yourself even even more"
force.id = "pulliii"
force.StartUse = function( ply )
	if ply:lscsGetForce() < 20 then return end

	local Time = CurTime()

	local CanPush = (ply._lscsNextForce or 0) < Time

	if not CanPush then return end

	ply._lscsNextForce = Time + 1

	ply:EmitSound("lscs/force/pull.mp3")
	ply:lscsTakeForce( 30 ) --Pullun ald force miktar

	local AimVector = ply:GetAimVector()
	local MyPos = ply:GetShootPos()

	LSCS:PlayVCDSequence( ply, "gesture_becon", 0.8 )

	local effectdata = EffectData()
		effectdata:SetOrigin( MyPos )
		effectdata:SetNormal( AimVector )
		effectdata:SetEntity( ply )
	util.Effect( "force_pull", effectdata, true, true )

	for _, Ent in pairs( ents.FindInSphere( MyPos, 800 ) ) do --ekme yarap
		local Sub = (Ent.GetShootPos and Ent:GetShootPos() or Ent:GetPos()) - MyPos
		local ToTarget = Sub:GetNormalized()

		if math.deg( math.acos( math.Clamp( AimVector:Dot( ToTarget ) ,-1,1) ) ) < 20 then
			local Dist = Sub:Length()

			if IsValid( Ent ) and Dist < 800 then
				local Vel = -Sub:GetNormalized() * 1250 + Vector(0,0,50) -- + dan nceki ksm ekme kudreti

				LSCS:ForceApply( Ent, Vel, ply )
			end
		end
	end
end
LSCS:RegisterForce( force )


local force = {}
force.PrintName = "Sense [Ultimate]"
force.Author = "Blu-x92 / Luna"
force.Description = "Augmented Vision. See through the lies of the Jedi and through walls"
force.id = "sense"
force.OnClk =  function( ply, TIME )
	if not ply:GetNWBool( "_lscsForceSense", false ) then return end

	if not ply:Alive() or ply:GetObserverMode() ~= OBS_MODE_NONE then
		ply:SetNWBool( "_lscsForceSense", false )
		return
	end

	ply:lscsTakeForce()

	if (ply._lscsSenseTime or 0) < TIME then
		ply:SetNWBool( "_lscsForceSense", false )
	end
end
force.UnEquip = function( ply ) ply:SetNWBool( "_lscsForceSense", false ) end
force.StartUse = function( ply )
	local Time = CurTime()

	local CanDo = (ply._lscsNextForce or 0) < Time

	if not CanDo then return end

	ply._lscsNextForce = Time + 1

	if ply:GetNWBool( "_lscsForceSense", false ) then
		ply:SetNWBool( "_lscsForceSense", false )
	else
		if ply:lscsGetForce() >= 12 then
			ply:SetNWBool( "_lscsForceSense", true )
			ply._lscsSenseTime = CurTime() + 20

			ply:lscsTakeForce( 12 )
			ply:EmitSound("lscs/force/sense.mp3")
		end
	end

end
LSCS:RegisterForce( force )




local force = {}
force.PrintName = "Heal"
force.Author = "Blu-x92 / Luna"
force.Description = "Heal yourself using the Force"
force.id = "heal"
force.StartUse = function( ply )
	local Time = CurTime()

	local CanDo = (ply._lscsNextForce or 0) < Time

	if not CanDo then return end

	ply._lscsNextForce = Time + 2
	

	local available = ply:lscsGetForce()
	local need = ply:GetMaxHealth() - ply:Health()

	if need > 0 and available >= 5 then
		local take = math.min( need, available, 25 )

		ply:lscsTakeForce( take )
		ply:SetHealth( math.min(ply:Health() + take ) )

		ply:EmitSound("lscs/force/heal.mp3")

		local effectdata = EffectData()
			effectdata:SetOrigin( ply:GetPos() )
			effectdata:SetEntity( ply )
		util.Effect( "force_heal", effectdata, true, true )
	end
end
LSCS:RegisterForce( force )

local force = {}
force.PrintName = "Heal II"
force.Author = "Valkorius"
force.Description = "Heal yourself using the Force even more"
force.id = "healii"
force.StartUse = function( ply )
	local Time = CurTime()

	local CanDo = (ply._lscsNextForce or 0) < Time

	if not CanDo then return end

	ply._lscsNextForce = Time + 2
	

	local available = ply:lscsGetForce()
	local need = ply:GetMaxHealth() - ply:Health()

	if need > 0 and available >= 5 then
		local take = math.min( need, available, 40 )

		ply:lscsTakeForce( take )
		ply:SetHealth( math.min(ply:Health() + take ) )

		ply:EmitSound("lscs/force/heal.mp3")

		local effectdata = EffectData()
			effectdata:SetOrigin( ply:GetPos() )
			effectdata:SetEntity( ply )
		util.Effect( "force_heal", effectdata, true, true )
	end
end
LSCS:RegisterForce( force )

local force = {}
force.PrintName = "Heal III"
force.Author = "Valkorius"
force.Description = "Heal yourself using the Force even even more"
force.id = "healiii"
force.StartUse = function( ply )
	local Time = CurTime()

	local CanDo = (ply._lscsNextForce or 0) < Time

	if not CanDo then return end

	ply._lscsNextForce = Time + 2
	

	local available = ply:lscsGetForce()
	local need = ply:GetMaxHealth() - ply:Health()

	if need > 0 and available >= 5 then
		local take = math.min( need, available, 55 )

		ply:lscsTakeForce( take )
		ply:SetHealth( math.min(ply:Health() + take ) )

		ply:EmitSound("lscs/force/heal.mp3")

		local effectdata = EffectData()
			effectdata:SetOrigin( ply:GetPos() )
			effectdata:SetEntity( ply )
		util.Effect( "force_heal", effectdata, true, true )
	end
end
LSCS:RegisterForce( force )

local force = {}
force.PrintName = "Replenish"
force.Author = "Blu-x92 / Luna"
force.Description = "A Dark Side ability that regains Force from Health"
force.id = "replenish"
force.StartUse = function( ply )
	local Time = CurTime()

	if (ply._lscsNextForceReplenish or 0) > Time then return end

	ply._lscsNextForceReplenish = Time + 2

	local available = math.max( ply:Health() - 1, 0 )

	local need = ply:lscsGetMaxForce() - ply:lscsGetForce()

	if available > 1 then
		if need > 0 then
			local take = math.min( need, available, 50 )

			ply:SetHealth( ply:Health() - take )
			ply:lscsSetForce( math.min(ply:lscsGetForce() + take, ply:lscsGetMaxForce()) )

			ply:EmitSound("lscs/force/replenish.mp3")

			local effectdata = EffectData()
				effectdata:SetOrigin( ply:GetPos() )
				effectdata:SetEntity( ply )
			util.Effect( "force_replenish", effectdata, true, true )
		end
	else
		if need > 0 then
			ply:EmitSound("lscs/force/replenish.mp3")

			local d = DamageInfo()
			d:SetDamage( 1 )
			d:SetAttacker( ply )
			d:SetDamageType( DMG_DROWN ) 
			d:SetDamagePosition( ply:GetShootPos() )
			ply:TakeDamageInfo( d )
		end
	end
end
LSCS:RegisterForce( force )



local force = {}
force.PrintName = "Immunity"
force.Author = "Blu-x92 / Luna"
force.Description = "Incoming Force Power[Lightning, Push, Pull] attacks are absorbed and regain Force Points. Also gives a permanent immunity against push/pull as long your own Force Points are above 50% even when this Power is not activated."
force.id = "immunity"
force.OnClk =  function( ply, TIME )
	if not ply:GetNWBool( "_lscsForceProtect", false ) then return end

	if not ply:Alive() or ply:GetObserverMode() ~= OBS_MODE_NONE then
		ply:SetNWBool( "_lscsForceProtect", false )
		return
	end

	local effectdata = EffectData()
		effectdata:SetOrigin( ply:GetPos() )
		effectdata:SetEntity( ply )
	util.Effect( "force_block_active", effectdata, true, true )

	ply:lscsTakeForce()

	if (ply._lscsBlockTime or 0) < TIME then
		ply:SetNWBool( "_lscsForceProtect", false )
	end
end
force.Equip = function( ply ) ply._lscsForceResistant = true end
force.UnEquip = function( ply ) ply._lscsForceResistant = nil ply:GetNWBool( "_lscsForceProtect", false ) end
force.StartUse = function( ply )
	local Time = CurTime()

	local CanDo = (ply._lscsNextForce or 0) < Time

	if not CanDo then return end

	ply._lscsNextForce = Time + 1

	if ply:GetNWBool( "_lscsForceProtect", false ) then
		ply:SetNWBool( "_lscsForceProtect", false )
	else
		if ply:lscsGetForce() < 20 then return end

		ply:SetNWBool( "_lscsForceProtect", true )
		ply._lscsBlockTime = CurTime() + 20

		ply:EmitSound("lscs/force/protect.mp3")

		ply:lscsTakeForce( 20 )
	end

end
LSCS:RegisterForce( force )

local function ForceFry( ply, TIME )
	local effectdata = EffectData()
		effectdata:SetOrigin( ply:GetPos() )
		effectdata:SetEntity( ply )
	util.Effect( "force_lightning", effectdata, true, true )

	local MyPos = ply:GetShootPos()
	local AimVector = ply:GetAimVector()
	local Force = AimVector * 100

	for _, victim in pairs( ents.FindInSphere( MyPos, 700 ) ) do
		local TargetPos = victim.GetShootPos and victim:GetShootPos() or victim:GetPos()
		local Sub = TargetPos - MyPos
		local ToTarget = Sub:GetNormalized()

		if math.deg( math.acos( math.Clamp( AimVector:Dot( ToTarget ) ,-1,1) ) ) < 14 then
			if util.TraceLine( {start = MyPos,endpos = victim:LocalToWorld( victim:OBBCenter() ),mask = MASK_SHOT,filter = ply,} ).Entity ~= victim then continue end

			local Dist = Sub:Length()

			if IsValid( victim ) and Dist < 700 then
				if victim:IsPlayer() then
					if hook.Run( "LSCS:PlayerCanManipulate", ply, victim, true ) then continue end
				end

				if victim:GetClass() == "prop_ragdoll" then
					victim:Fire("StartRagdollBoogie")

					if (victim._lscsBoogieTime or 0) < TIME then
						victim._lscsBoogieTime = TIME + 6

						for i = 1, 70 do
							if math.random(1,5) == 1 then continue end

							timer.Simple( i * 0.1, function()
								if not IsValid( victim ) then return end

								local effect = EffectData()
								effect:SetEntity( victim )
								effect:SetMagnitude(30)
								effect:SetScale(30)
								effect:SetRadius(30)
								util.Effect("TeslaHitBoxes", effect)
								victim:EmitSound("Weapon_StunStick.Activate")
							end )
						end
					end
				end

				local DMGtrace = util.TraceHull( {
					start = MyPos,
					endpos = MyPos + AimVector * 800,
					filter = ply,
					mins = Vector( -20, -20, -20 ),
					maxs = Vector( 20, 20, 20 ),
					mask = MASK_SHOT_HULL,
					filter = function( ent ) return ent == victim end
				} )

				local DmgSub = TargetPos - DMGtrace.HitPos
				local DmgPos = DMGtrace.HitPos + DmgSub:GetNormalized() * math.min(DmgSub:Length(),20) + VectorRand(-5,5)

				local dmginfo = DamageInfo()
				dmginfo:SetDamage( 5 )
				dmginfo:SetAttacker( ply )
				dmginfo:SetInflictor( ply ) 
				dmginfo:SetDamageType( bit.bor( DMG_SHOCK, DMG_BULLET ) )
				dmginfo:SetDamagePosition( DmgPos )
				dmginfo:SetDamageForce( Force ) 
				victim:TakeDamageInfo( dmginfo )
			end
		end
	end
end

local function ForceJFry( ply, TIME )
	local effectdata = EffectData()
		effectdata:SetOrigin( ply:GetPos() )
		effectdata:SetEntity( ply )
	util.Effect( "force_judgement", effectdata, true, true )

	local MyPos = ply:GetShootPos()
	local AimVector = ply:GetAimVector()
	local Force = AimVector * 100

	for _, victim in pairs( ents.FindInSphere( MyPos, 700 ) ) do
		local TargetPos = victim.GetShootPos and victim:GetShootPos() or victim:GetPos()
		local Sub = TargetPos - MyPos
		local ToTarget = Sub:GetNormalized()

		if math.deg( math.acos( math.Clamp( AimVector:Dot( ToTarget ) ,-1,1) ) ) < 14 then
			if util.TraceLine( {start = MyPos,endpos = victim:LocalToWorld( victim:OBBCenter() ),mask = MASK_SHOT,filter = ply,} ).Entity ~= victim then continue end

			local Dist = Sub:Length()

			if IsValid( victim ) and Dist < 700 then
				if victim:IsPlayer() then
					if hook.Run( "LSCS:PlayerCanManipulate", ply, victim, true ) then continue end
				end

				if victim:GetClass() == "prop_ragdoll" then 
					victim:Fire("StartRagdollBoogie")

					if (victim._lscsBoogieTime or 0) < TIME then
						victim._lscsBoogieTime = TIME + 6

						for i = 1, 70 do
							if math.random(1,5) == 1 then continue end

							timer.Simple( i * 0.1, function()
								if not IsValid( victim ) then return end

								local effect = EffectData()
								effect:SetEntity( victim )
								effect:SetMagnitude(30)
								effect:SetScale(30)
								effect:SetRadius(30)
								util.Effect("TeslaHitBoxes", effect)
								victim:EmitSound("Weapon_StunStick.Activate")
							end )
						end
					end
				end

				local DMGtrace = util.TraceHull( {
					start = MyPos,
					endpos = MyPos + AimVector * 800,
					filter = ply,
					mins = Vector( -20, -20, -20 ),
					maxs = Vector( 20, 20, 20 ),
					mask = MASK_SHOT_HULL,
					filter = function( ent ) return ent == victim end
				} )

				local DmgSub = TargetPos - DMGtrace.HitPos
				local DmgPos = DMGtrace.HitPos + DmgSub:GetNormalized() * math.min(DmgSub:Length(),20) + VectorRand(-5,5)

				local dmginfo = DamageInfo()
				dmginfo:SetDamage( 2 )
				dmginfo:SetAttacker( ply )
				dmginfo:SetInflictor( ply ) 
				dmginfo:SetDamageType( bit.bor( DMG_SHOCK, DMG_BULLET ) )
				dmginfo:SetDamagePosition( DmgPos )
				dmginfo:SetDamageForce( Force ) 
				victim:TakeDamageInfo( dmginfo )
			end
		end
	end
end

local function ForceJIIFry( ply, TIME )
	local effectdata = EffectData()
		effectdata:SetOrigin( ply:GetPos() )
		effectdata:SetEntity( ply )
	util.Effect( "force_judgementii", effectdata, true, true )

	local MyPos = ply:GetShootPos()
	local AimVector = ply:GetAimVector()
	local Force = AimVector * 100

	for _, victim in pairs( ents.FindInSphere( MyPos, 700 ) ) do
		local TargetPos = victim.GetShootPos and victim:GetShootPos() or victim:GetPos()
		local Sub = TargetPos - MyPos
		local ToTarget = Sub:GetNormalized()

		if math.deg( math.acos( math.Clamp( AimVector:Dot( ToTarget ) ,-1,1) ) ) < 14 then
			if util.TraceLine( {start = MyPos,endpos = victim:LocalToWorld( victim:OBBCenter() ),mask = MASK_SHOT,filter = ply,} ).Entity ~= victim then continue end

			local Dist = Sub:Length()

			if IsValid( victim ) and Dist < 700 then
				if victim:IsPlayer() then
					if hook.Run( "LSCS:PlayerCanManipulate", ply, victim, true ) then continue end
				end

				if victim:GetClass() == "prop_ragdoll" then 
					victim:Fire("StartRagdollBoogie")

					if (victim._lscsBoogieTime or 0) < TIME then
						victim._lscsBoogieTime = TIME + 6

						for i = 1, 70 do
							if math.random(1,5) == 1 then continue end

							timer.Simple( i * 0.1, function()
								if not IsValid( victim ) then return end

								local effect = EffectData()
								effect:SetEntity( victim )
								effect:SetMagnitude(30)
								effect:SetScale(30)
								effect:SetRadius(30)
								util.Effect("TeslaHitBoxes", effect)
								victim:EmitSound("Weapon_StunStick.Activate")
							end )
						end
					end
				end

				local DMGtrace = util.TraceHull( {
					start = MyPos,
					endpos = MyPos + AimVector * 800,
					filter = ply,
					mins = Vector( -20, -20, -20 ),
					maxs = Vector( 20, 20, 20 ),
					mask = MASK_SHOT_HULL,
					filter = function( ent ) return ent == victim end
				} )

				local DmgSub = TargetPos - DMGtrace.HitPos
				local DmgPos = DMGtrace.HitPos + DmgSub:GetNormalized() * math.min(DmgSub:Length(),20) + VectorRand(-5,5)

				local dmginfo = DamageInfo()
				dmginfo:SetDamage( 4 )
				dmginfo:SetAttacker( ply )
				dmginfo:SetInflictor( ply ) 
				dmginfo:SetDamageType( bit.bor( DMG_SHOCK, DMG_BULLET ) )
				dmginfo:SetDamagePosition( DmgPos )
				dmginfo:SetDamageForce( Force ) 
				victim:TakeDamageInfo( dmginfo )
			end
		end
	end
end

local function ForceJIIIFry( ply, TIME )
	local effectdata = EffectData()
		effectdata:SetOrigin( ply:GetPos() )
		effectdata:SetEntity( ply )
	util.Effect( "force_judgementiii", effectdata, true, true )

	local MyPos = ply:GetShootPos()
	local AimVector = ply:GetAimVector()
	local Force = AimVector * 100

	for _, victim in pairs( ents.FindInSphere( MyPos, 700 ) ) do
		local TargetPos = victim.GetShootPos and victim:GetShootPos() or victim:GetPos()
		local Sub = TargetPos - MyPos
		local ToTarget = Sub:GetNormalized()

		if math.deg( math.acos( math.Clamp( AimVector:Dot( ToTarget ) ,-1,1) ) ) < 14 then
			if util.TraceLine( {start = MyPos,endpos = victim:LocalToWorld( victim:OBBCenter() ),mask = MASK_SHOT,filter = ply,} ).Entity ~= victim then continue end

			local Dist = Sub:Length()

			if IsValid( victim ) and Dist < 700 then
				if victim:IsPlayer() then
					if hook.Run( "LSCS:PlayerCanManipulate", ply, victim, true ) then continue end
				end

				if victim:GetClass() == "prop_ragdoll" then 
					victim:Fire("StartRagdollBoogie")

					if (victim._lscsBoogieTime or 0) < TIME then
						victim._lscsBoogieTime = TIME + 6

						for i = 1, 70 do
							if math.random(1,5) == 1 then continue end

							timer.Simple( i * 0.1, function()
								if not IsValid( victim ) then return end

								local effect = EffectData()
								effect:SetEntity( victim )
								effect:SetMagnitude(30)
								effect:SetScale(30)
								effect:SetRadius(30)
								util.Effect("TeslaHitBoxes", effect)
								victim:EmitSound("Weapon_StunStick.Activate")
							end )
						end
					end
				end

				local DMGtrace = util.TraceHull( {
					start = MyPos,
					endpos = MyPos + AimVector * 800,
					filter = ply,
					mins = Vector( -20, -20, -20 ),
					maxs = Vector( 20, 20, 20 ),
					mask = MASK_SHOT_HULL,
					filter = function( ent ) return ent == victim end
				} )

				local DmgSub = TargetPos - DMGtrace.HitPos
				local DmgPos = DMGtrace.HitPos + DmgSub:GetNormalized() * math.min(DmgSub:Length(),20) + VectorRand(-5,5)

				local dmginfo = DamageInfo()
				dmginfo:SetDamage( 6 )
				dmginfo:SetAttacker( ply )
				dmginfo:SetInflictor( ply ) 
				dmginfo:SetDamageType( bit.bor( DMG_SHOCK, DMG_BULLET ) )
				dmginfo:SetDamagePosition( DmgPos )
				dmginfo:SetDamageForce( Force ) 
				victim:TakeDamageInfo( dmginfo )
			end
		end
	end
end

local function ForceLIFry( ply, TIME )
	local effectdata = EffectData()
		effectdata:SetOrigin( ply:GetPos() )
		effectdata:SetEntity( ply )
	util.Effect( "force_lightningi", effectdata, true, true )

	local MyPos = ply:GetShootPos()
	local AimVector = ply:GetAimVector()
	local Force = AimVector * 100

	for _, victim in pairs( ents.FindInSphere( MyPos, 700 ) ) do
		local TargetPos = victim.GetShootPos and victim:GetShootPos() or victim:GetPos()
		local Sub = TargetPos - MyPos
		local ToTarget = Sub:GetNormalized()

		if math.deg( math.acos( math.Clamp( AimVector:Dot( ToTarget ) ,-1,1) ) ) < 14 then
			if util.TraceLine( {start = MyPos,endpos = victim:LocalToWorld( victim:OBBCenter() ),mask = MASK_SHOT,filter = ply,} ).Entity ~= victim then continue end

			local Dist = Sub:Length()

			if IsValid( victim ) and Dist < 700 then
				if victim:IsPlayer() then
					if hook.Run( "LSCS:PlayerCanManipulate", ply, victim, true ) then continue end
				end

				if victim:GetClass() == "prop_ragdoll" then 
					victim:Fire("StartRagdollBoogie")

					if (victim._lscsBoogieTime or 0) < TIME then
						victim._lscsBoogieTime = TIME + 6

						for i = 1, 70 do
							if math.random(1,5) == 1 then continue end

							timer.Simple( i * 0.1, function()
								if not IsValid( victim ) then return end

								local effect = EffectData()
								effect:SetEntity( victim )
								effect:SetMagnitude(30)
								effect:SetScale(30)
								effect:SetRadius(30)
								util.Effect("TeslaHitBoxes", effect)
								victim:EmitSound("Weapon_StunStick.Activate")
							end )
						end
					end
				end

				local DMGtrace = util.TraceHull( {
					start = MyPos,
					endpos = MyPos + AimVector * 800,
					filter = ply,
					mins = Vector( -20, -20, -20 ),
					maxs = Vector( 20, 20, 20 ),
					mask = MASK_SHOT_HULL,
					filter = function( ent ) return ent == victim end
				} )

				local DmgSub = TargetPos - DMGtrace.HitPos
				local DmgPos = DMGtrace.HitPos + DmgSub:GetNormalized() * math.min(DmgSub:Length(),20) + VectorRand(-5,5)

				local dmginfo = DamageInfo()
				dmginfo:SetDamage( 3 )
				dmginfo:SetAttacker( ply )
				dmginfo:SetInflictor( ply ) 
				dmginfo:SetDamageType( bit.bor( DMG_SHOCK, DMG_BULLET ) )
				dmginfo:SetDamagePosition( DmgPos )
				dmginfo:SetDamageForce( Force ) 
				victim:TakeDamageInfo( dmginfo )
			end
		end
	end
end

local function ForceLIIFry( ply, TIME )
	local effectdata = EffectData()
		effectdata:SetOrigin( ply:GetPos() )
		effectdata:SetEntity( ply )
	util.Effect( "force_lightningii", effectdata, true, true )

	local MyPos = ply:GetShootPos()
	local AimVector = ply:GetAimVector()
	local Force = AimVector * 100

	for _, victim in pairs( ents.FindInSphere( MyPos, 700 ) ) do
		local TargetPos = victim.GetShootPos and victim:GetShootPos() or victim:GetPos()
		local Sub = TargetPos - MyPos
		local ToTarget = Sub:GetNormalized()

		if math.deg( math.acos( math.Clamp( AimVector:Dot( ToTarget ) ,-1,1) ) ) < 14 then
			if util.TraceLine( {start = MyPos,endpos = victim:LocalToWorld( victim:OBBCenter() ),mask = MASK_SHOT,filter = ply,} ).Entity ~= victim then continue end

			local Dist = Sub:Length()

			if IsValid( victim ) and Dist < 700 then
				if victim:IsPlayer() then
					if hook.Run( "LSCS:PlayerCanManipulate", ply, victim, true ) then continue end
				end

				if victim:GetClass() == "prop_ragdoll" then 
					victim:Fire("StartRagdollBoogie")

					if (victim._lscsBoogieTime or 0) < TIME then
						victim._lscsBoogieTime = TIME + 6

						for i = 1, 70 do
							if math.random(1,5) == 1 then continue end

							timer.Simple( i * 0.1, function()
								if not IsValid( victim ) then return end

								local effect = EffectData()
								effect:SetEntity( victim )
								effect:SetMagnitude(30)
								effect:SetScale(30)
								effect:SetRadius(30)
								util.Effect("TeslaHitBoxes", effect)
								victim:EmitSound("Weapon_StunStick.Activate")
							end )
						end
					end
				end

				local DMGtrace = util.TraceHull( {
					start = MyPos,
					endpos = MyPos + AimVector * 800,
					filter = ply,
					mins = Vector( -20, -20, -20 ),
					maxs = Vector( 20, 20, 20 ),
					mask = MASK_SHOT_HULL,
					filter = function( ent ) return ent == victim end
				} )

				local DmgSub = TargetPos - DMGtrace.HitPos
				local DmgPos = DMGtrace.HitPos + DmgSub:GetNormalized() * math.min(DmgSub:Length(),20) + VectorRand(-5,5)

				local dmginfo = DamageInfo()
				dmginfo:SetDamage( 6 )
				dmginfo:SetAttacker( ply )
				dmginfo:SetInflictor( ply ) 
				dmginfo:SetDamageType( bit.bor( DMG_SHOCK, DMG_BULLET ) )
				dmginfo:SetDamagePosition( DmgPos )
				dmginfo:SetDamageForce( Force ) 
				victim:TakeDamageInfo( dmginfo )
			end
		end
	end
end

local function ForceLIIIFry( ply, TIME )
	local effectdata = EffectData()
		effectdata:SetOrigin( ply:GetPos() )
		effectdata:SetEntity( ply )
	util.Effect( "force_lightningiii", effectdata, true, true )

	local MyPos = ply:GetShootPos()
	local AimVector = ply:GetAimVector()
	local Force = AimVector * 100

	for _, victim in pairs( ents.FindInSphere( MyPos, 700 ) ) do
		local TargetPos = victim.GetShootPos and victim:GetShootPos() or victim:GetPos()
		local Sub = TargetPos - MyPos
		local ToTarget = Sub:GetNormalized()

		if math.deg( math.acos( math.Clamp( AimVector:Dot( ToTarget ) ,-1,1) ) ) < 14 then
			if util.TraceLine( {start = MyPos,endpos = victim:LocalToWorld( victim:OBBCenter() ),mask = MASK_SHOT,filter = ply,} ).Entity ~= victim then continue end

			local Dist = Sub:Length()

			if IsValid( victim ) and Dist < 700 then
				if victim:IsPlayer() then
					if hook.Run( "LSCS:PlayerCanManipulate", ply, victim, true ) then continue end
				end

				if victim:GetClass() == "prop_ragdoll" then 
					victim:Fire("StartRagdollBoogie")

					if (victim._lscsBoogieTime or 0) < TIME then
						victim._lscsBoogieTime = TIME + 6

						for i = 1, 70 do
							if math.random(1,5) == 1 then continue end

							timer.Simple( i * 0.1, function()
								if not IsValid( victim ) then return end

								local effect = EffectData()
								effect:SetEntity( victim )
								effect:SetMagnitude(30)
								effect:SetScale(30)
								effect:SetRadius(30)
								util.Effect("TeslaHitBoxes", effect)
								victim:EmitSound("Weapon_StunStick.Activate")
							end )
						end
					end
				end

				local DMGtrace = util.TraceHull( {
					start = MyPos,
					endpos = MyPos + AimVector * 800,
					filter = ply,
					mins = Vector( -20, -20, -20 ),
					maxs = Vector( 20, 20, 20 ),
					mask = MASK_SHOT_HULL,
					filter = function( ent ) return ent == victim end
				} )

				local DmgSub = TargetPos - DMGtrace.HitPos
				local DmgPos = DMGtrace.HitPos + DmgSub:GetNormalized() * math.min(DmgSub:Length(),20) + VectorRand(-5,5)

				local dmginfo = DamageInfo()
				dmginfo:SetDamage( 10 )
				dmginfo:SetAttacker( ply )
				dmginfo:SetInflictor( ply ) 
				dmginfo:SetDamageType( bit.bor( DMG_SHOCK, DMG_BULLET ) )
				dmginfo:SetDamagePosition( DmgPos )
				dmginfo:SetDamageForce( Force ) 
				victim:TakeDamageInfo( dmginfo )
			end
		end
	end
end

local function ForceLIVFry( ply, TIME )
	local effectdata = EffectData()
		effectdata:SetOrigin( ply:GetPos() )
		effectdata:SetEntity( ply )
	util.Effect( "force_lightningiv", effectdata, true, true )

	local MyPos = ply:GetShootPos()
	local AimVector = ply:GetAimVector()
	local Force = AimVector * 100

	for _, victim in pairs( ents.FindInSphere( MyPos, 700 ) ) do
		local TargetPos = victim.GetShootPos and victim:GetShootPos() or victim:GetPos()
		local Sub = TargetPos - MyPos
		local ToTarget = Sub:GetNormalized()

		if math.deg( math.acos( math.Clamp( AimVector:Dot( ToTarget ) ,-1,1) ) ) < 14 then
			if util.TraceLine( {start = MyPos,endpos = victim:LocalToWorld( victim:OBBCenter() ),mask = MASK_SHOT,filter = ply,} ).Entity ~= victim then continue end

			local Dist = Sub:Length()

			if IsValid( victim ) and Dist < 700 then
				if victim:IsPlayer() then
					if hook.Run( "LSCS:PlayerCanManipulate", ply, victim, true ) then continue end
				end

				if victim:GetClass() == "prop_ragdoll" then 
					victim:Fire("StartRagdollBoogie")

					if (victim._lscsBoogieTime or 0) < TIME then
						victim._lscsBoogieTime = TIME + 6

						for i = 1, 70 do
							if math.random(1,5) == 1 then continue end

							timer.Simple( i * 0.1, function()
								if not IsValid( victim ) then return end

								local effect = EffectData()
								effect:SetEntity( victim )
								effect:SetMagnitude(30)
								effect:SetScale(30)
								effect:SetRadius(30)
								util.Effect("TeslaHitBoxes", effect)
								victim:EmitSound("Weapon_StunStick.Activate")
							end )
						end
					end
				end

				local DMGtrace = util.TraceHull( {
					start = MyPos,
					endpos = MyPos + AimVector * 800,
					filter = ply,
					mins = Vector( -20, -20, -20 ),
					maxs = Vector( 20, 20, 20 ),
					mask = MASK_SHOT_HULL,
					filter = function( ent ) return ent == victim end
				} )

				local DmgSub = TargetPos - DMGtrace.HitPos
				local DmgPos = DMGtrace.HitPos + DmgSub:GetNormalized() * math.min(DmgSub:Length(),20) + VectorRand(-5,5)

				local dmginfo = DamageInfo()
				dmginfo:SetDamage( 15 )
				dmginfo:SetAttacker( ply )
				dmginfo:SetInflictor( ply ) 
				dmginfo:SetDamageType( bit.bor( DMG_SHOCK, DMG_BULLET ) )
				dmginfo:SetDamagePosition( DmgPos )
				dmginfo:SetDamageForce( Force ) 
				victim:TakeDamageInfo( dmginfo )
			end
		end
	end
end

local function ForceLXFry( ply, TIME )
	local effectdata = EffectData()
		effectdata:SetOrigin( ply:GetPos() )
		effectdata:SetEntity( ply )
	util.Effect( "force_lightningx", effectdata, true, true )

	local MyPos = ply:GetShootPos()
	local AimVector = ply:GetAimVector()
	local Force = AimVector * 100

	for _, victim in pairs( ents.FindInSphere( MyPos, 700 ) ) do
		local TargetPos = victim.GetShootPos and victim:GetShootPos() or victim:GetPos()
		local Sub = TargetPos - MyPos
		local ToTarget = Sub:GetNormalized()

		if math.deg( math.acos( math.Clamp( AimVector:Dot( ToTarget ) ,-1,1) ) ) < 14 then
			if util.TraceLine( {start = MyPos,endpos = victim:LocalToWorld( victim:OBBCenter() ),mask = MASK_SHOT,filter = ply,} ).Entity ~= victim then continue end

			local Dist = Sub:Length()

			if IsValid( victim ) and Dist < 700 then
				if victim:IsPlayer() then
					if hook.Run( "LSCS:PlayerCanManipulate", ply, victim, true ) then continue end
				end

				if victim:GetClass() == "prop_ragdoll" then 
					victim:Fire("StartRagdollBoogie")

					if (victim._lscsBoogieTime or 0) < TIME then
						victim._lscsBoogieTime = TIME + 6

						for i = 1, 70 do
							if math.random(1,5) == 1 then continue end

							timer.Simple( i * 0.1, function()
								if not IsValid( victim ) then return end

								local effect = EffectData()
								effect:SetEntity( victim )
								effect:SetMagnitude(30)
								effect:SetScale(30)
								effect:SetRadius(30)
								util.Effect("TeslaHitBoxes", effect)
								victim:EmitSound("Weapon_StunStick.Activate")
							end )
						end
					end
				end

				local DMGtrace = util.TraceHull( {
					start = MyPos,
					endpos = MyPos + AimVector * 800,
					filter = ply,
					mins = Vector( -20, -20, -20 ),
					maxs = Vector( 20, 20, 20 ),
					mask = MASK_SHOT_HULL,
					filter = function( ent ) return ent == victim end
				} )

				local DmgSub = TargetPos - DMGtrace.HitPos
				local DmgPos = DMGtrace.HitPos + DmgSub:GetNormalized() * math.min(DmgSub:Length(),20) + VectorRand(-5,5)

				local dmginfo = DamageInfo()
				dmginfo:SetDamage( 100 )
				dmginfo:SetAttacker( ply )
				dmginfo:SetInflictor( ply ) 
				dmginfo:SetDamageType( bit.bor( DMG_SHOCK, DMG_BULLET ) )
				dmginfo:SetDamagePosition( DmgPos )
				dmginfo:SetDamageForce( Force ) 
				victim:TakeDamageInfo( dmginfo )
			end
		end
	end
end

local force = {}
force.PrintName = "Lightning"
force.Author = "Blu-x92 / Luna"
force.Description = "A Dark Side ability that fires Lightning Bolts out of your Hand"
force.id = "lightning"
force.OnClk =  function( ply, TIME )
	if not ply._lscsLightningTime then return end

	ply:lscsTakeForce( 2 )

	ForceFry( ply, TIME )

	if ply._lscsLightningStartTime < TIME then
		LSCS:PlayVCDSequence( ply, "gesture_item_give", 0.7 )
	end

	if ply._lscsLightningTime < TIME or ply:lscsGetForce() <= 0 or not ply:Alive() or ply:GetObserverMode() ~= OBS_MODE_NONE then
		ply._lscsLightningTime = nil
		ply._lscsLightningStartTime = nil
	end
end
force.Equip = function( ply ) end
force.UnEquip = function( ply ) end
force.StartUse = function( ply )
	local Time = CurTime()

	if (ply._lscsLightningTime or 0) > Time then
		ply._lscsLightningTime = nil
		ply._lscsLightningStartTime = nil

		return
	end

	if ply:lscsGetForce() < 10 then return end

	local CanDo = (ply._lscsNextForce or 0) < Time and (ply._lscsLightningTime or 0) < Time

	if not CanDo then return end

	ply._lscsNextForce = Time + 2

	ply:EmitSound("lscs/force/lightning.mp3")

	ply:lscsTakeForce( 5 )

	ForceFry( ply, Time )

	if not ply._lscsLightningTime then
		ply._lscsLightningTime = CurTime() + 3.5
		ply._lscsLightningStartTime = CurTime() + 0.15

		LSCS:PlayVCDSequence( ply, "gesture_signal_forward", 0.1 )
	end
end
force.StopUse = function( ply )
	ply._lscsLightningTime = nil
end
LSCS:RegisterForce( force )

local force = {}
force.PrintName = "Judgement"
force.Author = "Kaan"
force.Description = "A Light Side ability that fires Lightning Bolts out of your Hand"
force.id = "judgementi"
force.OnClk =  function( ply, TIME )
	if not ply._lscsJudgementTime then return end

	ply:lscsTakeForce( 4 )

	ForceJFry( ply, TIME )

	if ply._lscsJudgementStartTime < TIME then
		LSCS:PlayVCDSequence( ply, "gesture_item_give", 0.7 )
	end

	if ply._lscsJudgementTime < TIME or ply:lscsGetForce() <= 0 or not ply:Alive() or ply:GetObserverMode() ~= OBS_MODE_NONE then
		ply._lscsJudgementTime = nil
		ply._lscsJudgementStartTime = nil
	end
end
force.Equip = function( ply ) end
force.UnEquip = function( ply ) end
force.StartUse = function( ply )
	local Time = CurTime()

	if (ply._lscsJudgementTime or 0) > Time then
		ply._lscsJudgementTime = nil
		ply._lscsJudgementStartTime = nil

		return
	end

	if ply:lscsGetForce() < 10 then return end

	local CanDo = (ply._lscsNextForce or 0) < Time and (ply._lscsJudgementTime or 0) < Time

	if not CanDo then return end

	ply._lscsNextForce = Time + 2

	ply:EmitSound("lscs/force/lightning.mp3")

	ply:lscsTakeForce( 3 )

	ForceJFry( ply, Time )

	if not ply._lscsJudgementTime then
		ply._lscsJudgementTime = CurTime() + 3.5
		ply._lscsJudgementStartTime = CurTime() + 0.15

		LSCS:PlayVCDSequence( ply, "gesture_signal_forward", 0.1 )
	end
end
force.StopUse = function( ply )
	ply._lscsJudgementTime = nil
end
LSCS:RegisterForce( force )

local force = {}
force.PrintName = "Judgement II"
force.Author = "Valkorius"
force.Description = "A light side ability that fires green lightning bolts out of your hand"
force.id = "judgementii"
force.OnClk =  function( ply, TIME )
	if not ply._lscsJudgementiiTime then return end

	ply:lscsTakeForce( 6 )

	ForceJIIFry( ply, TIME )

	if ply._lscsJudgementiiStartTime < TIME then
		LSCS:PlayVCDSequence( ply, "gesture_item_give", 0.7 )
	end

	if ply._lscsJudgementiiTime < TIME or ply:lscsGetForce() <= 0 or not ply:Alive() or ply:GetObserverMode() ~= OBS_MODE_NONE then
		ply._lscsJudgementiiTime = nil
		ply._lscsJudgementiiStartTime = nil
	end
end
force.Equip = function( ply ) end
force.UnEquip = function( ply ) end
force.StartUse = function( ply )
	local Time = CurTime()

	if (ply._lscsJudgementiiTime or 0) > Time then
		ply._lscsJudgementiiTime = nil
		ply._lscsJudgementiiStartTime = nil

		return
	end

	if ply:lscsGetForce() < 10 then return end

	local CanDo = (ply._lscsNextForce or 0) < Time and (ply._lscsJudgementiiTime or 0) < Time

	if not CanDo then return end

	ply._lscsNextForce = Time + 2

	ply:EmitSound("lscs/force/lightning.mp3")

	ply:lscsTakeForce( 4 )

	ForceJIIFry( ply, Time )

	if not ply._lscsJudgementiiTime then
		ply._lscsJudgementiiTime = CurTime() + 3.5
		ply._lscsJudgementiiStartTime = CurTime() + 0.15

		LSCS:PlayVCDSequence( ply, "gesture_signal_forward", 0.1 )
	end
end
force.StopUse = function( ply )
	ply._lscsJudgementiiTime = nil
end
LSCS:RegisterForce( force )

local force = {}
force.PrintName = "Judgement III"
force.Author = "Valkorius"
force.Description = "A light side ability that fires cyan lightning bolts out of your Hand III"
force.id = "judgementiii"
force.OnClk =  function( ply, TIME )
	if not ply._lscsJudgementiiiTime then return end

	ply:lscsTakeForce( 8 )

	ForceJIIIFry( ply, TIME )

	if ply._lscsJudgementiiiStartTime < TIME then
		LSCS:PlayVCDSequence( ply, "gesture_item_give", 0.7 )
	end

	if ply._lscsJudgementiiiTime < TIME or ply:lscsGetForce() <= 0 or not ply:Alive() or ply:GetObserverMode() ~= OBS_MODE_NONE then
		ply._lscsJudgementiiiTime = nil
		ply._lscsJudgementiiiStartTime = nil
	end
end
force.Equip = function( ply ) end
force.UnEquip = function( ply ) end
force.StartUse = function( ply )
	local Time = CurTime()

	if (ply._lscsJudgementiiiTime or 0) > Time then
		ply._lscsJudgementiiiTime = nil
		ply._lscsJudgementiiiStartTime = nil

		return
	end

	if ply:lscsGetForce() < 10 then return end

	local CanDo = (ply._lscsNextForce or 0) < Time and (ply._lscsJudgementiiiTime or 0) < Time

	if not CanDo then return end

	ply._lscsNextForce = Time + 2

	ply:EmitSound("lscs/force/lightning.mp3")

	ply:lscsTakeForce( 5 )

	ForceJIIIFry( ply, Time )

	if not ply._lscsJudgementiiiTime then
		ply._lscsJudgementiiiTime = CurTime() + 3.5
		ply._lscsJudgementiiiStartTime = CurTime() + 0.15

		LSCS:PlayVCDSequence( ply, "gesture_signal_forward", 0.1 )
	end
end
force.StopUse = function( ply )
	ply._lscsJudgementiiiTime = nil
end
LSCS:RegisterForce( force )

local force = {}
force.PrintName = "Lightning II"
force.Author = "Valkorius"
force.Description = "Lightning II"
force.id = "Lightningii"
force.OnClk =  function( ply, TIME )
	if not ply._lscsLightningiiTime then return end

	ply:lscsTakeForce( 4 )

	ForceLIIFry( ply, TIME )

	if ply._lscsLightningiiStartTime < TIME then
		LSCS:PlayVCDSequence( ply, "gesture_item_give", 0.7 )
	end

	if ply._lscsLightningiiTime < TIME or ply:lscsGetForce() <= 0 or not ply:Alive() or ply:GetObserverMode() ~= OBS_MODE_NONE then
		ply._lscsLightningiiTime = nil
		ply._lscsLightningiiStartTime = nil
	end
end
force.Equip = function( ply ) end
force.UnEquip = function( ply ) end
force.StartUse = function( ply )
	local Time = CurTime()

	if (ply._lscsLightningiiTime or 0) > Time then
		ply._lscsLightningiiTime = nil
		ply._lscsLightningiiStartTime = nil

		return
	end

	if ply:lscsGetForce() < 10 then return end

	local CanDo = (ply._lscsNextForce or 0) < Time and (ply._lscsLightningiiTime or 0) < Time

	if not CanDo then return end

	ply._lscsNextForce = Time + 2

	ply:EmitSound("lscs/force/lightning.mp3")

	ply:lscsTakeForce( 3 )

	ForceLIIFry( ply, Time )

	if not ply._lscsLightningiiTime then
		ply._lscsLightningiiTime = CurTime() + 3.5
		ply._lscsLightningiiStartTime = CurTime() + 0.15

		LSCS:PlayVCDSequence( ply, "gesture_signal_forward", 0.1 )
	end
end
force.StopUse = function( ply )
	ply._lscsLightningiiTime = nil
end
LSCS:RegisterForce( force )

local force = {}
force.PrintName = "Lightning III"
force.Author = "Valkorius"
force.Description = "Lightning III"
force.id = "Lightningiii"
force.OnClk =  function( ply, TIME )
	if not ply._lscsLightningiiiTime then return end

	ply:lscsTakeForce( 3 )

	ForceLIIIFry( ply, TIME )

	if ply._lscsLightningiiiStartTime < TIME then
		LSCS:PlayVCDSequence( ply, "gesture_item_give", 0.7 )
	end

	if ply._lscsLightningiiiTime < TIME or ply:lscsGetForce() <= 0 or not ply:Alive() or ply:GetObserverMode() ~= OBS_MODE_NONE then
		ply._lscsLightningiiiTime = nil
		ply._lscsLightningiiiStartTime = nil
	end
end
force.Equip = function( ply ) end
force.UnEquip = function( ply ) end
force.StartUse = function( ply )
	local Time = CurTime()

	if (ply._lscsLightningiiiTime or 0) > Time then
		ply._lscsLightningiiiTime = nil
		ply._lscsLightningiiiStartTime = nil

		return
	end

	if ply:lscsGetForce() < 10 then return end

	local CanDo = (ply._lscsNextForce or 0) < Time and (ply._lscsLightningiiiTime or 0) < Time

	if not CanDo then return end

	ply._lscsNextForce = Time + 2

	ply:EmitSound("lscs/force/lightning.mp3")

	ply:lscsTakeForce( 3 )

	ForceLIIIFry( ply, Time )

	if not ply._lscsLightningiiiTime then
		ply._lscsLightningiiiTime = CurTime() + 3.5
		ply._lscsLightningiiiStartTime = CurTime() + 0.15

		LSCS:PlayVCDSequence( ply, "gesture_signal_forward", 0.1 )
	end
end
force.StopUse = function( ply )
	ply._lscsLightningiiiTime = nil
end
LSCS:RegisterForce( force )

local force = {}
force.PrintName = "Lightning IV"
force.Author = "Valkorius"
force.Description = "Lightning IV"
force.id = "Lightningiv"
force.OnClk =  function( ply, TIME )
	if not ply._lscsLightningivTime then return end

	ply:lscsTakeForce( 4 )

	ForceLIVFry( ply, TIME )

	if ply._lscsLightningivStartTime < TIME then
		LSCS:PlayVCDSequence( ply, "gesture_item_give", 0.7 )
	end

	if ply._lscsLightningivTime < TIME or ply:lscsGetForce() <= 0 or not ply:Alive() or ply:GetObserverMode() ~= OBS_MODE_NONE then
		ply._lscsLightningivTime = nil
		ply._lscsLightningivStartTime = nil
	end
end
force.Equip = function( ply ) end
force.UnEquip = function( ply ) end
force.StartUse = function( ply )
	local Time = CurTime()

	if (ply._lscsLightningivTime or 0) > Time then
		ply._lscsLightningivTime = nil
		ply._lscsLightningivStartTime = nil

		return
	end

	if ply:lscsGetForce() < 10 then return end

	local CanDo = (ply._lscsNextForce or 0) < Time and (ply._lscsLightningivTime or 0) < Time

	if not CanDo then return end

	ply._lscsNextForce = Time + 2

	ply:EmitSound("lscs/force/lightning.mp3")

	ply:lscsTakeForce( 4 )

	ForceLIVFry( ply, Time )

	if not ply._lscsLightningivTime then
		ply._lscsLightningivTime = CurTime() + 3.5
		ply._lscsLightningivStartTime = CurTime() + 0.15

		LSCS:PlayVCDSequence( ply, "gesture_signal_forward", 0.1 )
	end
end
force.StopUse = function( ply )
	ply._lscsLightningivTime = nil
end
LSCS:RegisterForce( force )

local force = {}
force.PrintName = "Lightning X"
force.Author = "Valkorius"
force.Description = "Lightning X"
force.id = "Lightningx"
force.OnClk =  function( ply, TIME )
	if not ply._lscsLightningxTime then return end

	ply:lscsTakeForce( 1 )

	ForceLXFry( ply, TIME )

	if ply._lscsLightningxStartTime < TIME then
		LSCS:PlayVCDSequence( ply, "gesture_item_give", 0.7 )
	end

	if ply._lscsLightningxTime < TIME or ply:lscsGetForce() <= 0 or not ply:Alive() or ply:GetObserverMode() ~= OBS_MODE_NONE then
		ply._lscsLightningxTime = nil
		ply._lscsLightningxStartTime = nil
	end
end
force.Equip = function( ply ) end
force.UnEquip = function( ply ) end
force.StartUse = function( ply )
	local Time = CurTime()

	if (ply._lscsLightningxTime or 0) > Time then
		ply._lscsLightningxTime = nil
		ply._lscsLightningxStartTime = nil

		return
	end

	if ply:lscsGetForce() < 10 then return end

	local CanDo = (ply._lscsNextForce or 0) < Time and (ply._lscsLightningxTime or 0) < Time

	if not CanDo then return end

	ply._lscsNextForce = Time + 1

	ply:EmitSound("lscs/force/lightning.mp3")

	ply:lscsTakeForce( 0 )

	ForceLXFry( ply, Time )

	if not ply._lscsLightningxTime then
		ply._lscsLightningxTime = CurTime() + 3.5
		ply._lscsLightningxStartTime = CurTime() + 0.15

		LSCS:PlayVCDSequence( ply, "gesture_signal_forward", 0.1 )
	end
end
force.StopUse = function( ply )
	ply._lscsLightningxTime = nil
end
LSCS:RegisterForce( force )

if SERVER then
	hook.Add( "LSCS:PlayerCanManipulate", "!!!lscs_forceblocking", function( ply, target_ent, ignore_passive )
		if not target_ent.IsPlayer or not target_ent:IsPlayer() then return end

		if target_ent:GetNWBool( "_lscsForceProtect", false ) then
			target_ent:lscsSetForce( math.min(target_ent:lscsGetForce() + 15, target_ent:lscsGetMaxForce()) )

			local effectdata = EffectData()
				effectdata:SetOrigin( target_ent:GetPos() )
				effectdata:SetEntity( target_ent )
			util.Effect( "force_block", effectdata, true, true )

			target_ent:EmitSound("lscs/force/block.mp3")
			LSCS:PlayVCDSequence( target_ent, "walk_magic" )

			return true
		end

		if ignore_passive then return end

		if target_ent._lscsForceResistant and target_ent:lscsGetForce() > 50 then
			LSCS:PlayVCDSequence( target_ent, "walk_magic" )

			return true
		end
	end )
else
	local zoom_mat = Material( "vgui/zoom" )
	local warp = Material("effects/tp_eyefx/tpeye3")

	hook.Add( "HUDPaint", "!lscs_senseoverlay", function()
		local ply = LocalPlayer()

		if not ply:GetNWBool( "_lscsForceSense", false ) then return end

		local X = ScrW()
		local Y = ScrH()

		surface.SetDrawColor( Color(255,255,255,255) )
		surface.SetMaterial( zoom_mat ) 
		surface.DrawTexturedRectRotated( X + X * 0.5, Y * 0.5, X, Y, 0 )
		surface.DrawTexturedRectRotated( X + X * 0.5, Y + Y * 0.5, Y, X, 270 )
		surface.DrawTexturedRectRotated( X * 0.5, Y * 0.5, Y, X, 90 )
		surface.DrawTexturedRectRotated( X * 0.5, Y + Y * 0.5, X, Y, 180 )
	
		surface.SetMaterial( warp ) 
		surface.DrawTexturedRect( 0, 0, X, Y )
	end )

	hook.Add( "HUDPaint", "!lscs_protectoverlay", function()
		local ply = LocalPlayer()

		if not ply:GetNWBool( "_lscsForceProtect", false ) then return end

		local X = ScrW()
		local Y = ScrH()
	
		surface.SetDrawColor(0, 127, 255, 25)
		surface.DrawRect( 0, 0, X, Y )
	end )

	
	local function StencilMagic( renderfunction, Col )
		render.SetStencilWriteMask( 0xFF )
		render.SetStencilTestMask( 0xFF )
		render.ClearStencil()

		render.SetStencilEnable( true )
		render.SetStencilReferenceValue( 1 )
		render.SetStencilCompareFunction( STENCIL_ALWAYS )
		render.SetStencilPassOperation( STENCILOPERATION_REPLACE )
		render.SetStencilZFailOperation( STENCILOPERATION_REPLACE )

		renderfunction()

		render.SetStencilCompareFunction( STENCIL_EQUAL )
		render.ClearBuffersObeyStencil(Col.r, Col.g, Col.b, Col.a , false)

		render.SetStencilEnable( false )
	end

	hook.Add("PostDrawOpaqueRenderables", "!!!!lscs_playertrackerwallhack", function( bDrawingDepth, bDrawingSkybox, isDraw3DSkybox )
		if isDraw3DSkybox then return end

		local ply = LocalPlayer()

		if not ply:GetNWBool( "_lscsForceSense", false ) then return end

		local ply = LocalPlayer()

		StencilMagic( 
			function()
				for _, ent in pairs( ents.GetAll() ) do
					if ent == ply then continue end

					if not ent.IsNPC or not ent.IsNextBot or not ent.IsPlayer then continue end

					if not ent:IsNPC() and not ent:IsNextBot() and not ent:IsPlayer() then continue end

					if ent.Alive and not ent:Alive() then continue end -- doesnt do shit on npc's ...
					if ent.Health and ent:Health() <= 0 then continue end -- doesnt do shit on npc's ...
					if ent.GetMoveType and ent:GetMoveType() == MOVETYPE_NONE then continue end -- this works for npc's

					ent:DrawModel()
				end
			end,
			Color(255,200,0,255)
		)
	end)
end
--PATH addons/[miecze] moce i hilty/lua/lscs/content/training_saber_blade.lua:
local blade = {}
blade.PrintName = "Training Saber Blade" -- nice name in the menu
blade.Author = "Colt"
blade.Spawnable = false
blade.id = "trainingsaberblade" -- internal ID. Always lower case.
blade.color_blur = Color(135,135,135, 0)
blade.color_core = Color(135,135,135, 0)
--blade.mdl = "models/lscs/weapons/nanosword_bladefx.mdl" -- use a model as blade?
--blade.mdl_poseparameter = "blade_retract" -- pose parameter to retract the blade. Should go from 0-1
blade.length = 0 -- blade length
blade.width = 0 -- width
blade.widthWiggle = 0.6 -- how much "noise" the blade has idling
blade.material_core_tip = Material( "lscs/effects/lightsaber_tip" ) -- material of the inner cores blade-tip
blade.material_glow = Material( "lscs/effects/lightsaber_glow" ) -- glow sprite effect
blade.material_trail = Material( "lscs/effects/lightsaber_trail" ) -- what material to use for the trail
blade.dynamic_light = true -- show dynamic light?
blade.no_trail = false -- disable trail?
blade.sounds = {
	Attack = "nanosword_hup",
	Attack1 = "nanosword_hup",
	Attack2 = "nanosword_hup",
	Attack3 = "nanosword_hup",
	Activate = "nanosword_turnon",
	Disable = "nanosword_turnoff",
	Idle =  "nanosword_idle",
}
LSCS:RegisterBlade( blade ) -- register it to the system. This will also register a new entity
--PATH addons/[miecze] moce i hilty/lua/lscs/content/vader_blade.lua:
local blade = {}
blade.PrintName = "Vader"
blade.Author = "Skip"
blade.id = "vader"
blade.color_blur = Color(200,0,0)
blade.color_core = Color(255,255,255)
blade.length = 45
blade.width = 1.5
blade.widthWiggle = 0.2
blade.material_core_tip = Material( "lscs/effects/lightsaber_tip" )
blade.material_core = Material( "lscs/effects/lightsaber_core" )
blade.material_glow = Material( "lscs/effects/lightsaber_glow" )
blade.material_trail = Material( "lscs/effects/lightsaber_trail" )
blade.dynamic_light = true
blade.no_trail = false
blade.sounds = {
	Attack = "saber_hup",
	Attack1 = "saber_spin1",
	Attack2 = "saber_spin2",
	Attack3 = "saber_spin3",
	Activate = "vader_saber_on",
	Disable = "saber_turnoff",
	Idle =  "saber_idle4",
}
LSCS:RegisterBlade( blade )
--PATH lua/lvs_framework/autorun/cl_hud.lua:
return gluapack()()
--PATH lua/lvs_framework/autorun/cl_hud.lua:

--LVS.HudForceDefault = true

LVS.HudEditors = LVS.HudEditors or {}
LVS.HudEditorsHide = {}

local function ResetFrame( id )
	if not LVS.HudEditors[ id ] then return end

	LVS.HudEditors[ id ].w = LVS.HudEditors[ id ].DefaultWidth
	LVS.HudEditors[ id ].h = LVS.HudEditors[ id ].DefaultHeight
	LVS.HudEditors[ id ].X = LVS.HudEditors[ id ].DefaultX
	LVS.HudEditors[ id ].Y = LVS.HudEditors[ id ].DefaultY
	LVS.HudEditorsHide[ id ] = nil
end

local function MakeFrame( id, X, Y, w, h, minw, minh, text )
	local Frame = vgui.Create("DFrame")
	Frame:SetSize( w, h )
	Frame:SetPos( X, Y )
	Frame:SetTitle( text )
	Frame:SetScreenLock( true )
	Frame:MakePopup()
	Frame:SetSizable( true )
	Frame:SetMinWidth( minw )
	Frame:SetMinHeight( minh )
	Frame.id = id
	Frame.OnClose = function( self )
		ResetFrame( self.id )
	end
	Frame.Paint = function(self, w, h )
		surface.SetDrawColor(0,0,0,150)
		surface.DrawRect(0, 0, w, h)

		surface.SetDrawColor(80,80,80,255)
		surface.DrawRect(0, 0, 2, h)
		surface.DrawRect(w - 2, 0, 2, h)
		surface.DrawRect(0, 0, w, 2)
		surface.DrawRect(0, h - 2, w, 2)

		if not LVS.HudEditors[ self.id ] then return end

		local Width = self:GetWide()
		local Height = self:GetTall()

		LVS.HudEditors[ self.id ].w = Width
		LVS.HudEditors[ self.id ].h = Height

		LVS.HudEditors[ self.id ].X = math.min( self:GetX(), ScrW() - Width )
		LVS.HudEditors[ self.id ].Y = math.min( self:GetY(), ScrH() - Height )

		if self:IsDragging() or input.IsMouseDown( MOUSE_LEFT ) then return end

		local Ratio = LVS.HudEditors[ self.id ].DefaultHeight / LVS.HudEditors[ self.id ].DefaultWidth

		if math.Round( Height / Width, 2 ) ~= math.Round( Ratio ,2 ) then
			local NewHeight = Width * Ratio

			self:SetHeight( NewHeight )

			LVS.HudEditors[ self.id ].h = NewHeight
		end
	end

	local DCheckbox = vgui.Create( "DCheckBoxLabel", Frame )
	DCheckbox:Dock( RIGHT )
	DCheckbox:DockMargin( 0, 0, 0, 0 )
	DCheckbox:SetText("Hide")	
	DCheckbox:SizeToContents()
	DCheckbox.id = id
	DCheckbox:SetChecked( LVS.HudEditorsHide[ id ] == true )
	DCheckbox.OnChange = function( self, bVal )
		if not self.id then return end

		if bVal then LVS.HudEditorsHide[ self.id ] = true return end

		LVS.HudEditorsHide[ self.id ] = nil
	end

	LVS.HudEditors[ id ].Frame = Frame

	return Frame
end

local ScreenWidth = ScrW()
local ScreenHeight = ScrH()

local function SaveEditors()
	if LVS.HudForceDefault then return end

	if ScreenWidth ~= ScrW() or ScreenHeight ~= ScrH() then return end -- player changed resolution while ingame... don't save because everything is fucked up now...

	local SaveString = ""
	for id, data in pairs( LVS.HudEditors ) do
		local w = data.w
		local h = data.h

		local X = math.min( data.X / ScrW(), 1 )
		local Y = math.min( data.Y / ScrH(), 1 )

		local hide = LVS.HudEditorsHide[ id ] and "?" or " "

		SaveString = SaveString..id.."~"..hide.."~"..w.."#"..h.."/"..X.."#"..Y.."\n"
	end

	file.Write( "lvs_hud_settings.txt", SaveString )
end

local function LoadEditors()
	if LVS.HudForceDefault then return end

	local LoadString = file.Read( "lvs_hud_settings.txt" )

	if not LoadString then return end

	for _, garbage in pairs( string.Explode( "\n", LoadString ) ) do
		local data1 = string.Explode( "~", garbage )

		if not data1[3] then continue end

		local data2 =  string.Explode( "/", data1[3] )

		local size = string.Explode( "#", data2[1] )
		local pos = string.Explode( "#", data2[2] )

		local ID = data1[1]

		if not LVS.HudEditors[ ID ] or not size[1] or not size[2] or not pos[1] or not pos[2] then continue end

		LVS.HudEditors[ ID ].w = math.max( LVS.HudEditors[ ID ].minw, size[1] )
		LVS.HudEditors[ ID ].h = math.max( LVS.HudEditors[ ID ].minh, size[2] )
		LVS.HudEditors[ ID ].X = math.min( pos[1] * ScrW(), ScrW() - size[1] )
		LVS.HudEditors[ ID ].Y = math.min( pos[2] * ScrH(), ScrH() - size[2] )

		if data1[2] == "?" then
			LVS.HudEditorsHide[ ID ] = true
		end
	end
end

function LVS:AddHudEditor( id, X, Y, w, h, minw, minh, text, func )
	LVS.HudEditors[ id ] = {
		DefaultX = X,
		DefaultY = Y,
		DefaultWidth = w,
		DefaultHeight = h,
		X = X,
		Y = Y,
		w = w,
		h = h,
		minw = minw,
		minh = minh,
		text = text,
		func = func,
	}
end

hook.Add( "OnContextMenuOpen", "!!!!!LVS_hud", function()
	if not IsValid( LocalPlayer():lvsGetVehicle() ) then return end

	if not GetConVar( "lvs_edit_hud" ):GetBool() then return end

	LVS:OpenEditors()

	return false
end )

hook.Add( "InitPostEntity", "!!!lvs_load_hud", function()
	LoadEditors()
end )

function LVS:OpenEditors()
	for id, editor in pairs( LVS.HudEditors ) do
		if IsValid( editor.Frame ) then continue end

		MakeFrame( id, editor.X, editor.Y, editor.w, editor.h, editor.minw, editor.minh, editor.text )
	end

	local T = CurTime()
	local ply = LocalPlayer()
	local pod = ply:GetVehicle()

	ply.SwitcherTime = T + 9999

	if not IsValid( pod ) then return end

	pod._SelectActiveTime = T + 9999
end

function LVS:CloseEditors()
	SaveEditors()

	for id, editor in pairs( LVS.HudEditors ) do
		if not IsValid( editor.Frame ) then continue end
		editor.Frame:Remove()
	end

	local T = CurTime()
	local ply = LocalPlayer()
	local pod = ply:GetVehicle()

	ply.SwitcherTime = T

	if not IsValid( pod ) then return end

	pod._SelectActiveTime = T
end

hook.Add( "OnContextMenuClose", "!!!!!LVS_hud", function()
	LVS:CloseEditors()
end )

function LVS:DrawDiamond( X, Y, radius, perc )
	if perc <= 0 then return end

	local segmentdist = 90

	draw.NoTexture()

	for a = 90, 360, segmentdist do
		local Xa = math.Round( math.sin( math.rad( -a ) ) * radius, 0 )
		local Ya = math.Round( math.cos( math.rad( -a ) ) * radius, 0 )

		local C = math.sqrt( radius ^ 2 + radius ^ 2 )

		if a == 90 then
			C = C * math.min(math.max(perc - 0.75,0) / 0.25,1)
		elseif a == 180 then
			C = C * math.min(math.max(perc - 0.5,0) / 0.25,1)
		elseif a == 270 then
			C = C * math.min(math.max(perc - 0.25,0) / 0.25,1)
		elseif a == 360 then
			C = C * math.min(math.max(perc,0) / 0.25,1)
		end

		if C > 0 then
			local AxisMoveX = math.Round( math.sin( math.rad( -a + 135) ) * (C + 3) * 0.5, 0 )
			local AxisMoveY =math.Round( math.cos( math.rad( -a + 135) ) * (C + 3) * 0.5, 0 )

			surface.DrawTexturedRectRotated(X - Xa - AxisMoveX, Y - Ya - AxisMoveY,3, math.ceil( C ), a - 45)
		end
	end
end

local function PaintIdentifier( ent )
	if not LVS.ShowIdent or LVS:IsIndicatorForced() then return end

	local VehicleIdentifierRange = ent.VehicleIdentifierRange
	local MyPos = ent:GetPos()
	local MyTeam = ent:GetAITEAM()

	for _, v in pairs( LVS:GetVehicles() ) do
		if not IsValid( v ) or v == ent then continue end

		local rPos = v:LocalToWorld( v:OBBCenter() )

		local Pos = rPos:ToScreen()
		local Dist = (MyPos - rPos):Length()

		if Dist > VehicleIdentifierRange or util.TraceLine( {start = ent:LocalToWorld( ent:OBBCenter() ),endpos = rPos,mask = MASK_NPCWORLDSTATIC,} ).Hit then continue end

		local Alpha = 255 * (1 - (Dist / VehicleIdentifierRange) ^ 2)
		local Team = v:GetAITEAM()
		local IndicatorColor = Color( 255, 0, 0, Alpha )

		if Team == 0 then
			if MyTeam == 0 then continue end

			IndicatorColor = Color( 0, 255, 0, Alpha )
		else
			if Team == 1 or Team == 2 then
				if Team ~= MyTeam and MyTeam ~= 0 then
					IndicatorColor = Color( 255, 0, 0, Alpha )
				else
					IndicatorColor = Color( 0, 127, 255, Alpha )
				end
			end
		end

		if Team > 3 then continue end

		v:LVSHudPaintVehicleIdentifier( Pos.x, Pos.y, IndicatorColor )
	end
end

hook.Add( "HUDPaint", "!!!!!LVS_hud", function()
	local ply = LocalPlayer()

	if ply:GetViewEntity() ~= ply then return end

	local Pod = ply:GetVehicle()
	local Parent = ply:lvsGetVehicle()

	if not IsValid( Pod ) or not IsValid( Parent ) then
		ply._lvsoldPassengers = {}

		return
	end

	local X = ScrW()
	local Y = ScrH()

	PaintIdentifier( Parent )
	Parent:LVSHudPaint( X, Y, ply )

	local base = Pod:lvsGetWeapon()
	if IsValid( base ) then
		local weapon = base:GetActiveWeapon()
		if weapon and weapon.HudPaint then
			weapon.HudPaint( base, X, Y, ply )
		end
	else
		local weapon = Parent:GetActiveWeapon()
		if ply == Parent:GetDriver() and weapon and weapon.HudPaint then
			weapon.HudPaint( Parent, X, Y, ply )
		end
	end

	for id, editor in pairs( LVS.HudEditors ) do
		if LVS.HudEditorsHide[ id ] then continue end

		local ScaleX = editor.w / editor.DefaultWidth
		local ScaleY = editor.h / editor.DefaultHeight

		local PosX = editor.X / ScaleX
		local PosY = editor.Y / ScaleY

		local Width = editor.w / ScaleX
		local Height = editor.h / ScaleY

		local ScrW = X / ScaleX
		local ScrH = Y / ScaleY

		if ScaleX == 1 and ScaleY == 1 then
			editor:func( Parent, PosX, PosY, Width, Height, ScrW, ScrH, ply )
		else
			local m = Matrix()
			m:Scale( Vector( ScaleX, ScaleY, 1 ) )

			cam.PushModelMatrix( m )
				editor:func( Parent, PosX, PosY, Width, Height, ScrW, ScrH, ply )
			cam.PopModelMatrix()
		end
	end
end )
--PATH lua/lvs_framework/autorun/lvs_hookers.lua:
return gluapack()()
--PATH lua/lvs_framework/autorun/lvs_pod.lua:

local meta = FindMetaTable( "Vehicle" )

if CLIENT then
	function meta:lvsGetPodIndex()
		local id = self:GetNWInt( "pPodIndex", -1 )

		if id ~= -1 then return id end

		-- code below is bandaid fix for ent:GetNWInt taking up to 5 minutes to update on client...

		local col = self:GetColor()
		local id_by_color = col.r

		-- 255 or 0 is suspicous...
		if id_by_color == 255 or id_by_color == 0 then return -1 end

		-- lets just assume its right... right?
		if id_by_color == col.g and id_by_color == col.b then
			return id_by_color
		end

		return -1
	end

	function meta:GetCameraHeight()
		if not self._lvsCamHeight then
			self._lvsCamHeight = 0

			net.Start("lvs_camera")
				net.WriteEntity( self )
			net.SendToServer()
		end

		return self._lvsCamHeight
	end

	function meta:SetCameraHeight( newheight )
		self._lvsCamHeight = newheight
	end

	function meta:lvsGetWeapon()
		if self._lvsWeaponEntChecked then
			return self._lvsWeaponEnt
		end

		local found = false

		for _, ent in ipairs( self:GetChildren() ) do
			if not ent.LVS_GUNNER then continue end

			self._lvsWeaponEntChecked = true
			self._lvsWeaponEnt = ent

			found = true

			break
		end

		return found and self._lvsWeaponEnt or NULL
	end

	net.Receive( "lvs_select_weapon", function( length)
		local ply = LocalPlayer()
		local vehicle = ply:lvsGetVehicle()

		if not IsValid( vehicle ) or vehicle:GetDriver() ~= ply then return end

		vehicle._SelectActiveTime = CurTime() + 2
	end)

	
	net.Receive( "lvs_camera", function( length, ply )
		local pod = net.ReadEntity()

		if not IsValid( pod ) then return end

		pod:SetCameraHeight( net.ReadFloat() )
	end)

	return
end

function meta:lvsGetPodIndex()
	return self:GetNWInt( "pPodIndex", -1 )
end

function meta:GetCameraHeight()
	return (self._lvsCamHeight or 0)
end

util.AddNetworkString( "lvs_select_weapon" )
util.AddNetworkString( "lvs_camera" )

net.Receive( "lvs_select_weapon", function( length, ply )
	if not IsValid( ply ) then return end

	local ID = net.ReadInt( 5 )
	local Increment = net.ReadBool()

	local base = ply:lvsGetWeaponHandler()

	if not IsValid( base ) then return end

	if Increment then
		base:SelectWeapon( base:GetSelectedWeapon() + ID )
	else
		base:SelectWeapon( ID )
	end
end)

net.Receive( "lvs_camera", function( length, ply )
	if not IsValid( ply ) then return end

	local pod = net.ReadEntity()

	if not IsValid( pod ) then return end

	net.Start("lvs_camera")
		net.WriteEntity( pod )
		net.WriteFloat( pod:GetCameraHeight() )
	net.Send( ply )
end)

function meta:SetCameraHeight( newheight )
	self._lvsCamHeight = newheight

	net.Start("lvs_camera")
		net.WriteEntity( self )
		net.WriteFloat( newheight )
	net.Broadcast()
end

function meta:lvsAddWeapon( ID )
	if IsValid( self._lvsWeaponEnt ) then
		return self._lvsWeaponEnt
	end

	local weapon = ents.Create( "lvs_base_gunner" )

	if not IsValid( weapon ) then return NULL end

	weapon:SetPos( self:LocalToWorld( Vector(0,0,33.182617) ) ) -- location exactly where ply:GetShootPos() is. This will make AI-Tracing easier.
	weapon:SetAngles( self:LocalToWorldAngles( Angle(0,90,0) ) )
	weapon:SetOwner( self )
	weapon:Spawn()
	weapon:Activate()
	weapon:SetParent( self )
	weapon:SetPodIndex( ID )
	weapon:SetDriverSeat( self )

	self._lvsWeaponEnt = weapon

	weapon:SetSelectedWeapon( 1 )

	return weapon
end

function meta:lvsGetWeapon()
	return self._lvsWeaponEnt
end

function meta:lvsSetPodIndex( index )
	-- garbage networking
	self:SetNWInt( "pPodIndex", index )

	self:SetMaterial( "null" )

	-- more reliable networking, lol
	self:SetColor( Color( index, index, index, 0 ) )
end

--PATH lua/autorun/includes/modules/inputhook.lua:
local IsValid = IsValid
local pairs = pairs
local RealTime = RealTime
local type = type
local IsKeyDown = input.IsKeyDown
local IsMouseDown = input.IsMouseDown
local IsGameUIVisible = gui.IsGameUIVisible
local IsConsoleVisible = gui.IsConsoleVisible

_G.inputhook = {}

local HoldTime = 0.3

local LastPress = nil
local LastKey = nil
local KeyControls = {}

local function getEventArgs( a, b, c )
	if c == nil then
		return a, b
	else
		return b, c
	end
end

local function InputThink()

	if IsGameUIVisible() or IsConsoleVisible() then return end

	local dispatch, down, held, downFunc

	for key, handles in pairs( KeyControls ) do
		for name, tbl in pairs( handles ) do

			dispatch = false
			downFunc = tbl.Mouse and IsMouseDown or IsKeyDown

			if tbl.Enabled then

				-- Key hold (repeat press)
				if tbl.LastPress and tbl.LastPress + HoldTime < RealTime() then
					dispatch = true
					down = true
					held = true

					tbl.LastPress = RealTime()
				end

				-- Key release
				if not downFunc( key ) then
					dispatch = true
					down = false

					tbl.Enabled = false
				end

			else

				-- Key press
				if downFunc( key ) then
					dispatch = true
					down = true

					tbl.Enabled = true
					tbl.LastPress = RealTime()
				end

			end

			if dispatch then
				-- Use same behavior as the hook system
				if type(name) == 'table' then
					if IsValid(name) then
						tbl.Toggle( name, down, held, key )
					else
						handles[ name ] = nil
					end
				else
					tbl.Toggle( down, held, key )
				end
			end

		end
	end

end
hook.Add( "Think", "InputManagerThink", InputThink )

---
-- Adds a callback to be dispatched when a key is pressed.
--
-- @param key		`KEY_` enum.
-- @param name		Unique identifier or a valid object.
-- @param onToggle	Callback function.
--
function inputhook.Add( key, name, onToggle, isMouse )

	if not (key and onToggle) then return end

	if not KeyControls[ key ] then
		KeyControls[ key ] = {}
	end

	KeyControls[ key ][ name ] = {
		Enabled = false,
		LastPress = 0,
		Toggle = onToggle,
		Mouse = isMouse
	}

end

function inputhook.AddKeyPress( key, name, onToggle )

	inputhook.Add( key, name, function( a, b, c )
		local down, held = getEventArgs(a, b, c)

		-- ignore if key down, but held OR key is not down
		if down then
			if held then return end
		else
			return
		end

		onToggle( a, b, c )
	end )

end

function inputhook.AddKeyRelease( key, name, onToggle )

	inputhook.Add( key, name, function( a, b, c )
		local down, held = getEventArgs(a, b, c)

		-- ignore if key is down
		if down then return end

		onToggle( a, b, c )
	end )

end

---
-- Removes a registered key callback.
--
-- @param key	`KEY_` enum.
-- @param name	Unique identifier or a valid object.
--
function inputhook.Remove( key, name )

	if not KeyControls[ key ] then return end

	KeyControls[ key ][ name ] = nil

end

--PATH lua/mediaplayer/controls/dmediaplayerhtml.lua:
--
-- DMediaPlayerHTML
--
-- Improves upon the Cinema HTML control by adding:
-- Window object callbacks, HTML and JS console filtering, URL polling,
-- simulated mouse clicks, and proper fullscreen resizing.
--
-- Cinema HTML control reference:
-- https://github.com/pixeltailgames/cinema/blob/master/cinema/gamemode/modules/scoreboard/controls/cl_html.lua
--

local PANEL = {}

DEFINE_BASECLASS( "Panel" )

local DEBUG = false

local JS_CallbackHack = [[(function(){
	var funcname = '%s';
	window[funcname] = function(){
		_gm[funcname].apply(_gm,arguments);
	}
})();]]

local FilterCVar = CreateClientConVar( "js_console_filter", 0, true, false )

local FILTER_ALL = 0
local FILTER_NONE = 1

--[[---------------------------------------------------------

-----------------------------------------------------------]]

function PANEL:Init()

	self.JS = {}
	self.Callbacks = {}
	self.MouseActions = {}

	self.URL = "data:text/html,"

	hook.Add( "HUDPaint", self, function() self:HUDPaint() end )

end


function PANEL:OnDocumentReady( url )

	--
	-- Implement a console - because awesomium doesn't provide it for us anymore
	--
	local console_funcs = {'log','error','debug','warn','info'}
	for _, func in pairs(console_funcs) do
		self:AddFunction( "console", func, function(param)
			self:ConsoleMessage( param, func )
		end )
	end

	self:AddFunction( "gmod", "getUrl", function( url )
		self:SetURL( url )
	end )

end

function PANEL:Think()

	if self:IsLoading() then

		-- Call started loading
		if not self._loading then

			-- Get the page URL
			self:FetchPageURL()

			self._loading = true
			self:OnStartLoading()

		end

	else

		-- Call finished loading
		if self._loading then

			-- Get the page URL
			self:FetchPageURL()

			-- Hack to add window object callbacks
			if self.Callbacks.window then
				for funcname, callback in pairs(self.Callbacks.window) do
					self:RunJavascript( JS_CallbackHack:format(funcname) )
				end
			end

			self._loading = nil
			self:OnFinishLoading()

		end

		-- Run queued javascript
		if self.JS then
			for k, v in pairs( self.JS ) do
				self:RunJavascript( v )
			end
			self.JS = nil
		end

	end

	-- HACK: Poll page for URL change
	if not self._nextUrlPoll or self._nextUrlPoll < RealTime() then
		self:FetchPageURL()
		self._nextUrlPoll = RealTime() + 1
	end

end

function PANEL:FetchPageURL()
	local js = [[
		if (typeof gmod === 'object' && typeof gmod.getUrl === 'function') {
			gmod.getUrl(window.location.href);
		}
	]]
	self:RunJavascript(js)
end

function PANEL:GetURL()
	return self.URL
end

function PANEL:SetURL( url )
	local current = self.URL

	if current ~= url then
		self:OnURLChanged( url, current )
	end

	self.URL = url
end

function PANEL:OnURLChanged( new, old )
	if FilterCVar:GetInt() > FILTER_ALL then
		print( "URL Changed: " .. tostring(new) )
	end
end


--[[---------------------------------------------------------
	Awesomium Override Functions
-----------------------------------------------------------]]

function PANEL:SetSize( w, h, fullscreen )

	local keyboardEnabled = self:IsKeyboardInputEnabled()
	local mouseEnabled = self:IsMouseInputEnabled()

	if fullscreen then

		-- Cache fullscreen size
		local cw, ch = self:GetSize()
		self._OrigSize = { w = cw, h = ch }

		-- Render before the HUD
		self:ParentToHUD()

	elseif self._OrigSize then

		-- Restore cached size
		w = self._OrigSize.w
		h = self._OrigSize.h
		self._OrigSize = nil

		-- Reparent due to hud parented panels sometimes being inaccessible
		-- from Lua.
		self:SetParent( vgui.GetWorldPanel() )

	else
		self._OrigSize = nil
	end

	self:SetKeyBoardInputEnabled( keyboardEnabled )
	self:SetMouseInputEnabled( mouseEnabled )

	if not (w and h) then return end

	BaseClass.SetSize( self, w, h )

end

function PANEL:OpenURL( url )

	if DEBUG then
		print("DMediaPlayerHTML.OpenURL", url)
	end

	self:SetURL( url )

	BaseClass.OpenURL( self, url )

end

function PANEL:SetHTML( html )

	if DEBUG then
		print("DMediaPlayerHTML.SetHTML")
		print(html)
	end

	BaseClass.SetHTML( self, html )

end


--[[---------------------------------------------------------
	Window loading events
-----------------------------------------------------------]]

--
-- Called when the page begins loading
--
function PANEL:OnStartLoading()

end

--
-- Called when the page finishes loading all assets
--
function PANEL:OnFinishLoading()

end


--[[---------------------------------------------------------
	Lua => JavaScript queue

	This code only runs when the page is finished loading;
	this means all assets (images, CSS, etc.) must load first!
-----------------------------------------------------------]]

function PANEL:QueueJavascript( js )

	--
	-- Can skip using the queue if there's nothing else in it
	--
	if not ( self.JS or self:IsLoading() ) then
		return self:RunJavascript( js )
	end

	self.JS = self.JS or {}

	table.insert( self.JS, js )
	self:Think()

end

PANEL.QueueJavaScript = PANEL.QueueJavascript
PANEL.Call = PANEL.QueueJavascript


--[[---------------------------------------------------------
	Handle console logging from JavaScript
-----------------------------------------------------------]]

PANEL.ConsoleColors = {
	["default"]	= Color(255,160,255),
	["text"]	= Color(255,255,255),
	["error"]	= Color(235,57,65),
	["warn"]	= Color(227,181,23),
	["info"]	= Color(100,173,229),
}

function PANEL:ConsoleMessage( ... )

	local filterLevel = FilterCVar:GetInt()

	local args = {...}
	local msg = args[1]

	-- Three arguments are passed in if an error occured
	if #args == 3 and filterLevel > FILTER_ALL then

		local script = args[2]
		local linenum = args[3]
		local col = self.ConsoleColors.error

		local out = {
			"[JavaScript]",
			msg,
			",",
			script,
			":",
			linenum,
			"\n"
		}

		MsgC( col, table.concat(out, " ") )

	else

		if not isstring( msg ) then
			msg = "*js variable* (" .. type(msg) .. ": " .. tostring(msg) .. ")"
		end

		-- Run Lua from JavaScript console logging (POTENTIALLY HARMFUL!)
		--[[if msg:StartWith( "RUNLUA:" ) then
			local strLua = msg:sub( 8 )

			SELF = self
			RunString( strLua )
			SELF = nil

			return
		end]]

		-- Play a sound from JavaScript console logging
		if msg:StartWith( "PLAY:" ) then
			local soundpath = msg:sub( 7 )
			surface.PlaySound( soundpath )
			return
		end

		if filterLevel == FILTER_ALL then return end

		local func = args[2]

		-- Output console message with prefix
		local prefixColor = self.ConsoleColors.default
		local prefix = "[HTML"
		if func and func:len() > 0 and func ~= "log" then
			if self.ConsoleColors[func] then
				prefixColor = self.ConsoleColors[func]
			end
			prefix = prefix .. ":" .. func:upper()
		end
		prefix = prefix .. "] "

		MsgC( prefixColor, prefix )
		MsgC( self.ConsoleColors.text, msg, "\n" )

	end

end


--[[---------------------------------------------------------
	JavaScript callbacks
-----------------------------------------------------------]]

local JSObjects = {
	window	= "_gm",
	this	= "_gm",
	_gm		= "window"
}

--
-- Called by the engine when a callback function is called
--
function PANEL:OnCallback( obj, func, args )

	-- Hack for adding window callbacks
	obj = JSObjects[obj] or obj

	if not self.Callbacks[ obj ] then return end

	--
	-- Use AddFunction to add functions to this.
	--
	local f = self.Callbacks[ obj ][ func ]

	if ( f ) then
		return f( unpack( args ) )
	end

end

--
-- Add a function to Javascript
--
function PANEL:AddFunction( obj, funcname, func )

	-- Hack for adding window callbacks
	-- obj = JSObjects[obj] or obj

	if obj == "this" then
		obj = "window"
	end

	-- Create the `object` if it doesn't exist
	if not self.Callbacks[ obj ] then
		self:NewObject( obj )
		self.Callbacks[ obj ] = {}
	end

	-- This creates the function in javascript (which redirects to c++ which calls OnCallback here)
	self:NewObjectCallback( JSObjects[obj] or obj, funcname )

	-- Store the function so OnCallback can find it and call it
	self.Callbacks[ obj ][ funcname ] = func

end


--[[---------------------------------------------------------
	Scrolling
-----------------------------------------------------------]]

local JS_RemoveScrollbars = "document.body.style.overflow = 'hidden';"
local JS_ScrollBy = "window.scrollBy(0, %d);"

function PANEL:RemoveScrollbars()
	self:QueueJavascript(JS_RemoveScrollbars)
end

function PANEL:Scroll( amount )
	self:QueueJavascript( JS_ScrollBy:format(amount) )
end


--[[---------------------------------------------------------
	Compatibility functions
-----------------------------------------------------------]]

function PANEL:OpeningURL( url )
end

function PANEL:FinishedURL( url )
end


--[[---------------------------------------------------------
	Simulated mouse clicks
-----------------------------------------------------------]]

function PANEL:HUDPaint()
	self:HandleMouseActions()
end

function PANEL:InjectMouseClick( x, y )
	if self._handlingMouseAction then
		return
	end

	local w, h = self:GetSize()
	table.insert( self.MouseActions, {
		x = math.Round(x * w),
		y = math.Round(y * h),
		tick = 0
	} )
end

function PANEL:HandleMouseActions()
	if #self.MouseActions == 0 then
		return
	end

	local action = self.MouseActions[1]
	action.tick = action.tick + 1

	if action.tick == 1 then
		-- show cursor
		self._handlingMouseAction = true
		self:SetZPos( 32767 )
		self:MoveToCursor( action.x, action.y )
		self:MakePopup()
		gui.EnableScreenClicker( true )
		gui.InternalCursorMoved( 0, 0 )
	elseif action.tick == 2 then
		local cx, cy = input.GetCursorPos()
		gui.InternalCursorMoved( cx, cy )
	elseif action.tick == 3 then
		-- simulate click; need to wait at least one frame
		gui.InternalMousePressed( MOUSE_LEFT )
		gui.InternalMouseReleased( MOUSE_LEFT )
	elseif action.tick > 3 then
		-- hide cursor
		gui.EnableScreenClicker( false )
		self:SetKeyboardInputEnabled( false )
		self:SetMouseInputEnabled( false )
		self:SetZPos( -32768 )
		table.remove( self.MouseActions, 1 )
		self._handlingMouseAction = nil
	end
end

function PANEL:MoveToCursor( xoffset, yoffset )
	xoffset = xoffset or 0
	yoffset = yoffset or 0

	local cx, cy = input.GetCursorPos()
	self:SetPos( cx - xoffset, cy - yoffset )
end

derma.DefineControl( "DMediaPlayerHTML", "", PANEL, "Awesomium" )

--PATH lua/mediaplayer/sh_mediaplayer.lua:
if SERVER then
	include "players/components/vote.lua"
	include "players/components/voteskip.lua"
end

--[[---------------------------------------------------------
	Media Player Types
-----------------------------------------------------------]]

MediaPlayer.Type = {}

local function setBaseClass( name, tbl )
	local classname = "mp_" .. name

	if MediaPlayer.Type[name] ~= nil then
		if MediaPlayer.DEBUG then
			Msg("Media player type '" .. name .. "' is already registered. ")
			Msg("Clearing baseclass...\n")
		end

		-- HACK: removes registered baseclass if it already exists to avoid Lua
		-- refresh table.Merge errors...
		local _, BaseClassTable = debug.getupvalue(baseclass.Get, 1)
		BaseClassTable[classname] = nil
	end

	baseclass.Set( classname, tbl )
end

---
-- Registers a media player type.
--
-- @param tbl	Media player type table.
--
function MediaPlayer.Register( tbl )

	local name = tbl.Name

	if not name then
		ErrorNoHalt("MediaPlayer.Register - Must include name property\n")
		debug.Trace()
		return
	end

	name = name:lower() -- always use lowercase names
	tbl.Name = name
	tbl.__index = tbl

	-- Set base meta table
	local base = tbl.Base or "base"
	if base and name ~= "base" then
		base = base:lower()

		if not MediaPlayer.Type[base] then
			ErrorNoHalt("MediaPlayer.Register - Invalid base name: " .. base .. "\n")
			debug.Trace()
			return
		end

		base = MediaPlayer.Type[base]

		setmetatable(tbl, {
			__index = base,
			__tostring = base.__tostring
		})
	end

	-- Store media player type as a base class
	setBaseClass( name, tbl )

	-- Save player type
	MediaPlayer.Type[name] = tbl

	if MediaPlayer.DEBUG then
		Msg( "MediaPlayer.Register\t" .. name .. "\n" )
	end

end

function MediaPlayer.IsValidType( type )
	return MediaPlayer.Type[type] ~= nil
end

-- Load players
do
	local path = "players/"
	local players = {
		"base", -- MUST LOAD FIRST!
		"entity"
	}

	for _, player in ipairs(players) do
		local clfile = path .. player .. "/cl_init.lua"
		local svfile = path .. player .. "/init.lua"

		MEDIAPLAYER = {}

		if SERVER then
			AddCSLuaFile(clfile)
			include(svfile)
		else
			include(clfile)
		end

		MediaPlayer.Register( MEDIAPLAYER )
		MEDIAPLAYER = nil
	end
end


--[[---------------------------------------------------------
	Media Player Helpers
-----------------------------------------------------------]]

MediaPlayer.List = MediaPlayer.List or {}
MediaPlayer._count = MediaPlayer._count or 0

---
-- Creates a media player object.
--
-- @param id		Media player ID.
-- @param type?		Media player type (defaults to 'base').
-- @return table	Media player object.
--
function MediaPlayer.Create( id, type )
	-- Inherit media player type
	local PlayerType = MediaPlayer.Type[type]
	PlayerType = PlayerType or MediaPlayer.Type.base

	-- Create media player object
	local mp = setmetatable( {}, { __index = PlayerType } )

	-- Assign unique ID
	if id then
		mp.id = id
	elseif SERVER then
		MediaPlayer._count = MediaPlayer._count + 1
		mp.id = MediaPlayer._count
	else
		mp.id = id or -1
	end

	mp:Init()

	-- Add to media player list
	MediaPlayer.List[mp.id] = mp

	if MediaPlayer.DEBUG then
		print( "Created Media Player", mp, mp.Name, type )
	end

	return mp
end

---
-- Destroys the given media player object.
--
-- @param table		Media player object.
--
function MediaPlayer.Destroy( mp )
	-- TODO: does this need anything else?
	MediaPlayer.List[mp.id] = nil

	if MediaPlayer.DEBUG then
		print( "Destroyed Media Player '" .. tostring(mp.id) .. "'" )
	end
end

---
-- Gets the media player associated with the given ID.
--
-- @param id		Media player ID.
-- @return table 	Media player object.
--
function MediaPlayer.GetById( id )
	local mp = MediaPlayer.List[id]
	if mp then
		return mp
	else
		-- Since entity indexes can change, let's iterate the list just to
		-- be sure...
		for _, mp in pairs(MediaPlayer.List) do
			if mp:GetId() == id then
				return mp
			end
		end
	end
end

---
-- Gets all active media players.
--
-- @return table	Array of all active media players.
--
function MediaPlayer.GetAll()
	local tbl = {}

	for _, mp in pairs( MediaPlayer.List ) do
		table.insert( tbl, mp )
	end

	return tbl
end

---
-- Gets the media player associated with the given object.
--
-- @param obj Any object.
--
function MediaPlayer.GetByObject( obj )
	local mp = nil

	if isentity(obj) and obj.IsMediaPlayerEntity then
		mp = obj:GetMediaPlayer()
	elseif istable(obj) and obj.IsMediaPlayer then
		mp = obj
	elseif isstring(obj) then
		mp = MediaPlayer.GetById(obj)
	end

	return mp
end


--[[---------------------------------------------------------
	Media Player Think Loop
-----------------------------------------------------------]]

MediaPlayer.ThinkInterval = 0.2 -- seconds

local function MediaPlayerThink()
	for id, mp in pairs( MediaPlayer.List ) do
		local succ, err = pcall(mp.Think, mp)
		if not succ then
			ErrorNoHalt(err .. "\n")

			-- TODO: recreate mediaplayer object instead
			mp:Remove()
		end
	end
end

if timer.Exists( "MediaPlayerThink" ) then
	timer.Destroy( "MediaPlayerThink" )
end

-- TODO: only start timer when at least one mediaplayer is created; stop it when
-- there are none left.
timer.Create( "MediaPlayerThink", MediaPlayer.ThinkInterval, 0, MediaPlayerThink )
timer.Start( "MediaPlayerThink" )

--PATH lua/mediaplayer/services/base/cl_init.lua:
include "shared.lua"

function SERVICE:Volume( volume )
	if volume then
		self._volume = tonumber(volume) or self._volume
	end
	return self._volume
end

function SERVICE:IsPaused()
	return self._PauseTime ~= nil
end

function SERVICE:Stop()
	self._playing = false
	self:emit('stop')
end

function SERVICE:PlayPause()
	if self:IsPlaying() then
		self:Pause()
	else
		self:Play()
	end
end

function SERVICE:Sync()
	-- Implement this in timed services
end

function SERVICE:NetWriteRequest()
	-- Send any additional net data here
end

function SERVICE:OnMousePressed( x, y )
end

function SERVICE:OnMouseWheeled( scrollDelta )
end

function SERVICE:IsMouseInputEnabled()
	return false
end

--PATH lua/mediaplayer/services/twitch/cl_init.lua:
return gluapack()()
--PATH lua/mediaplayer/services/twitchstream/shared.lua:
return gluapack()()
--PATH lua/mediaplayer/services/html5_video.lua:
SERVICE.Name	= "HTML5 Video"
SERVICE.Id		= "h5v"
SERVICE.Base	= "res"

SERVICE.FileExtensions = {
	'webm',
	-- 'mp4',	-- not yet supported by Awesomium
	-- 'ogg'	-- already registered as audio, need a work-around :(
}

DEFINE_BASECLASS( "mp_service_base" )

if CLIENT then
	
	local MimeTypes = {
		webm = "video/webm",
		mp4 = "video/mp4",
		ogg = "video/ogg"
	}

	local EmbedHTML = [[
<video id="player" autoplay loop style="
		width: 100%%;
		height: 100%%;">
	<source src="%s" type="%s">
</video>
]]

	local JS_Volume = [[(function () {
	var elem = document.getElementById('player');
	if (elem) {
		elem.volume = %s;
	}
}());]]

	function SERVICE:GetHTML()
		local url = self.url

		local path = self.urlinfo.path
		local ext = path:match("[^/]+%.(%S+)$")

		local mime = MimeTypes[ext]

		return EmbedHTML:format(url, mime)
	end

	function SERVICE:Volume( volume )
		local origVolume = volume

		volume = BaseClass.Volume( self, volume )

		if origVolume and ValidPanel( self.Browser ) then
			self.Browser:RunJavascript(JS_Volume:format(volume))
		end
	end

end
--PATH lua/mediaplayer/cl_idlescreen.lua:
local DefaultIdlescreen = [[
<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>MediaPlayer Idlescreen</title>
	<style type="text/css">
	html, body {
		margin: 0;
		padding: 0;
		width: 100%%;
		height: 100%%;
	}
	html {
		background: #fff;
	}
	body {
		overflow: hidden;
		display: -webkit-box;
		display: -moz-box;
		display: box;
		-webkit-box-orient: horizontal;
		-moz-box-orient: horizontal;
		-box-orient: horizontal;
		-webkit-box-pack: center;
		-webkit-box-align: center;
		background: -webkit-radial-gradient(center, ellipse cover,
			transparent 0%%, rgba(0, 0, 0, 0.7) 100%%);
	}
	h1 {
		margin: 0;
		padding: 0;
	}
	.background {
		position: absolute;
		display: block;
		width: 100%%;
		z-index: -1;
		-webkit-filter: blur(8px);
		-webkit-transform: scale(1.2);
		opacity: 0.66;
	}
	.content {
		color: rgba(255, 255, 255, 0.66);
		font-family: sans-serif;
		font-size: 1.5em;
		text-align: center;
		-webkit-box-flex: 1;
		-moz-box-flex: 1;
		box-flex: 1;
	}

	.metastream {
		display: block;
		max-width: 80%%;
		font-size: 18pt;
		font-weight: bold;
		margin: 20px auto 0 auto;
		padding: 16px 24px;
		text-align: center;
		text-decoration: none;
		color: white;
		line-height: 28pt;
		letter-spacing: 0.5px;
		text-shadow: 1px 1px 1px rgba(0,0,0,0.2);
		border-radius: 4px;
		background: -webkit-linear-gradient(
			-20deg,
			#20202f 0%%,
			#273550 40%%,
			#416081 100%%
		);
	}
	.metastream-link {
		color: #f98673;
		text-decoration: underline;
	}
	</style>
</head>
<body>
	<img src="asset://mapimage/gm_construct" class="background">
	<div class="content">
		<h1>No media playing</h1>
		<p>Hold %s while looking at the media player to reveal the queue menu.</p>

		<div class="metastream">
			Hey Media Player fans! The creator of this mod is making something new.
			Check out <span class="metastream-link">getmetastream.com</span>!
		</div>
	</div>
</body>
</html>
]]

local function GetIdlescreenHTML()
	local contextMenuBind = input.LookupBinding( "+menu_context" ) or "C"
	contextMenuBind = contextMenuBind:upper()
	return DefaultIdlescreen:format( contextMenuBind )
end

function MediaPlayer.GetIdlescreen()

	if not MediaPlayer._idlescreen then
		local browser = vgui.Create( "DMediaPlayerHTML" )
		browser:SetPaintedManually(true)
		browser:SetKeyBoardInputEnabled(false)
		browser:SetMouseInputEnabled(false)
		browser:SetPos(0,0)

		local resolution = MediaPlayer.Resolution()
		browser:SetSize( resolution * 16/9, resolution )

		-- TODO: set proper browser size

		MediaPlayer._idlescreen = browser

		local setup = hook.Run( "MediaPlayerSetupIdlescreen", browser )
		if not setup then
			MediaPlayer._idlescreen:SetHTML( GetIdlescreenHTML() )
		end
	end

	return MediaPlayer._idlescreen

end

--PATH lua/autorun/menubar/mp_options.lua:
hook.Add( "PopulateMenuBar", "MediaPlayerOptions_MenuBar", function( menubar )

	local m = menubar:AddOrGetMenu( "  Media Player" )

	m:AddCVar( "Fullscreen", "mediaplayer_fullscreen", "1", "0" )

	m:AddSpacer()

	m:AddOption( "Turn Off All", function()
		for _, mp in ipairs(MediaPlayer.GetAll()) do
			MediaPlayer.RequestListen( mp )
		end

		MediaPlayer.HideSidebar()
	end )

end )

--PATH lua/mp_menu/icons.lua:
return gluapack()()
--PATH lua/mp_menu/queue.lua:
local math = math
local ceil = math.ceil
local clamp = math.Clamp

local surface = surface
local color_white = color_white

local PANEL = {}

function PANEL:Init()

	self.Header = vgui.Create( "MP.QueueHeader", self )
	self.Header:Dock( TOP )

	self.List = vgui.Create( "MP.QueueList", self )
	self.List:Dock( FILL )

end

function PANEL:OnQueueChanged( queue )

	self.List:Clear()

	for _, media in pairs(queue) do
		local item = vgui.Create( "MP.MediaItem" )
		item:SetMedia( media )

		self.List:AddItem( item )
	end

end

derma.DefineControl( "MP.Queue", "", PANEL, "Panel" )


local QUEUE_HEADER = {}

QUEUE_HEADER.BgColor = Color( 7, 21, 33 )

QUEUE_HEADER.Height = 43
QUEUE_HEADER.Padding = 10

function QUEUE_HEADER:Init()

	self:SetTall( self.Height )

	self.Label = vgui.Create( "DLabel", self )
	self.Label:SetText( "NEXT UP" )
	self.Label:SetFont( "MP.QueueHeader" )

	self.AddVidBtn = vgui.Create( "MP.AddVideoButton", self )

end

function QUEUE_HEADER:Paint( w, h )

	surface.SetDrawColor( self.BgColor )
	surface.DrawRect( 0, 0, w, h )

end

function QUEUE_HEADER:PerformLayout()

	self.Label:CenterVertical()
	self.Label:AlignLeft( self.Padding )

	self.AddVidBtn:InvalidateLayout()
	self.AddVidBtn:CenterVertical()
	self.AddVidBtn:AlignRight( self.Padding )

end

derma.DefineControl( "MP.QueueHeader", "", QUEUE_HEADER, "Panel" )


local ADD_VIDEO_BTN = {}

local AddEnabledColor = Color( 232, 78, 64 )
local AddEnabledHoverColor = Color( 252, 98, 84 )

local AddDisabledColor = Color( 140, 140, 140 )

ADD_VIDEO_BTN.Color = AddEnabledColor
ADD_VIDEO_BTN.HoverColor = AddEnabledHoverColor

function ADD_VIDEO_BTN:Init()

	self.BtnLbl = vgui.Create( "DLabel", self )
	self.BtnLbl:SetText( "Button" )

	self:SetLabelSpacing( 4 )
	self:SetPadding( 4 )

	self.BtnLbl:SetFont( "MP.QueueHeader" )
	self.BtnLbl:SetText( "ADD MEDIA" )
	self.BtnLbl:SetTextColor( color_white )

	self:SetIcon( "mp-plus" )

end

function ADD_VIDEO_BTN:SetLocked( locked )

	if locked and not hook.Run( MP.EVENTS.UI.PRIVILEGED_PLAYER ) then
		self:SetDisabled( true )
		self.Color = AddDisabledColor
		self.HoverColor = AddDisabledColor
		self:SetIcon( "mp-lock" )
	end

end

function ADD_VIDEO_BTN:Paint( w, h )

	local col

	if self:IsHovered() then
		col = self.HoverColor
	else
		col = self.Color
	end

	surface.SetDrawColor( col )
	surface.DrawRect( 0, 0, w, h )

end

function ADD_VIDEO_BTN:DoClick()
	hook.Run( MP.EVENTS.UI.OPEN_REQUEST_MENU )
end

derma.DefineControl( "MP.AddVideoButton", "", ADD_VIDEO_BTN, "DIconLabeledButton" )


local QUEUE_LIST = {}

function QUEUE_LIST:Init()

	self.BaseClass.Init( self )

	self:SetSpacing( 1 )

	-- TODO: Replace with custom scrollbar
	self:EnableVerticalScrollbar()

end

derma.DefineControl( "MP.QueueList", "", QUEUE_LIST, "DPanelList" )


local MEDIA_ITEM = {}

MEDIA_ITEM.Height = 64

MEDIA_ITEM.BgColor = Color( 13, 41, 62 )
MEDIA_ITEM.HPadding = 12
MEDIA_ITEM.VPadding = 8
MEDIA_ITEM.BtnSpacing = 4

MEDIA_ITEM.TrackbarProgressColor = Color( 28, 100, 157 )
MEDIA_ITEM.TrackbarHeight = 2

MEDIA_ITEM.TitleMaxWidth = 335

MEDIA_ITEM.KnobSize = 8

function MEDIA_ITEM:Init()

	self.MediaTitle = vgui.Create( "MP.MediaTitle", self )
	self.MediaTime = vgui.Create( "MP.MediaTime", self )
	self.FavBtn = vgui.Create( "MP.FavoriteButton", self )
	self.AddedByLbl = vgui.Create( "MP.AddedBy", self )

	self.BtnList = vgui.Create( "DHorizontalList", self )
	self.BtnList:SetSpacing( self.BtnSpacing )

end

function MEDIA_ITEM:SetMedia( media )

	self.MediaTitle:SetText( media:Title() )
	self.MediaTime:SetMedia( media )
	self.AddedByLbl:SetPlayer( media:GetOwner(), media:OwnerName(), media:OwnerSteamID() )

	self.FavBtn:SetMedia( media )

	hook.Run( MP.EVENTS.UI.SETUP_MEDIA_PANEL, self, media )

	-- Detect if player has privileges to remove media from queue
	local privileged = hook.Run( MP.EVENTS.UI.PRIVILEGED_PLAYER )
	if privileged or media:IsOwner( LocalPlayer() ) then
		self.RemoveBtn = vgui.Create( "MP.RemoveButton" )
		self:AddButton( self.RemoveBtn )
	end

	-- apply media for all buttons
	for _, btn in pairs( self.BtnList:GetItems() ) do
		if ValidPanel(btn) and isfunction(btn.SetMedia) then
			btn:SetMedia( media )
		end
	end

end

function MEDIA_ITEM:AddButton( panel )
	self.BtnList:AddItem( panel )
end

function MEDIA_ITEM:Paint( w, h )

	surface.SetDrawColor( self.BgColor )
	surface.DrawRect( 0, 0, w, h )

end

function MEDIA_ITEM:PerformLayout()

	local w = self:GetWide()

	self:SetTall( self.Height )

	self.MediaTitle:SizeToContents()
	self.MediaTitle:AlignLeft( self.HPadding )
	self.MediaTitle:AlignTop( self.VPadding )

	self.MediaTime:InvalidateLayout()
	self.MediaTime:AlignLeft( self.HPadding )
	self.MediaTime:AlignBottom( self.VPadding - 3 )

	self.FavBtn:Hide()
	self.FavBtn:AlignTop( self.VPadding )
	self.FavBtn:AlignRight( self.HPadding )

	self.BtnList:InvalidateLayout(true)
	self.BtnList:AlignBottom( self.VPadding )
	self.BtnList:AlignRight( self.HPadding )

	local maxAddedByWidth = ( self.BtnList:GetPos() - 8 ) -
			( self.MediaTime:GetPos() + self.MediaTime:GetWide() + self.HPadding )

	self.AddedByLbl:SetMaxWidth( maxAddedByWidth )
	self.AddedByLbl:AlignBottom( self.VPadding )
	self.AddedByLbl:MoveLeftOf( self.BtnList, 8 )

	local maxTitleWidth = self.FavBtn:GetPos() -
		( self.MediaTitle:GetPos() + 5 )

	if self.MediaTitle:GetWide() > maxTitleWidth then
		self.MediaTitle:SetWide( maxTitleWidth )
	end

end

derma.DefineControl( "MP.MediaItem", "", MEDIA_ITEM, "Panel" )

--PATH addons/[miecze] moce i hilty/lua/memetispowers/sh_cloak.lua:
hook.Add("PlayerPostThink", "CloakingDevice", function(ply)
	if not ply:GetNWBool("IsCloaked", false) then return end
	if not IsValid(ply:GetActiveWeapon()) then return end

	local weapon = ply:GetActiveWeapon()
	
	local current_alpha = ply:GetColor().a
	local new_alpha = math.max(ply:GetVelocity():Length() - 70, 0)
	new_alpha = math.Approach(current_alpha, new_alpha, 500 * FrameTime())
	
    ply:RemoveAllDecals()
    ply:DrawShadow(false)
    ply:SetDSP(14)

    ply:SetRenderMode(RENDERMODE_TRANSCOLOR)
	weapon:SetRenderMode(RENDERMODE_TRANSCOLOR)
    ply:SetColor(Color(255, 255, 255, new_alpha))
	local weapon_alpha = new_alpha < 70 and new_alpha or 0
	weapon:SetColor(Color(255, 255, 255, weapon_alpha))

	if not SERVER then return end
	ply:SetNoTarget(new_alpha < 70)
end)

hook.Add("PostEntityTakeDamage", "Cloak_OnDamageHook", function(ent)
	if not IsValid(ent) then return end
	if ent:IsPlayer() then
		if ent:GetNWBool("IsCloaked", false) then
            ent:EndCloak()
        end
	end
end)

hook.Add("LSCS:EntityFireBullets", "Cloak_OnFireHook", function(ent, data)
	if not IsValid(ent) then return end
	local ply = ent:IsPlayer() and ent or ent:GetOwner()
	if not IsValid(ply) or not ply:IsPlayer() then return end
	if ply:GetNWBool("IsCloaked", false) then
		ply:EndCloak()
	end
end)

hook.Add("PlayerDeath", "Cloak_OnDeathHook", function(ply)
    if not IsValid(ply) then return end
    if ply:GetNWBool("IsCloaked", false) then
        ply:EndCloak()
    end
end)

local pMeta = FindMetaTable("Player")
function pMeta:EndCloak()
	if not IsValid(self) then return end
	local weapon = self:GetActiveWeapon()
	self:SetNWBool("IsCloaked", false)
	self.LSCS_Cloak = false
	timer.Simple(0.2, function()
		if SERVER then
			self:SetNoTarget(false)
		end
		self:SetColor(Color(255, 255, 255, 255))
        if IsValid(weapon) then weapon:SetColor(Color(255, 255, 255, 255)) end
		self:SetDSP(0)
		self:DrawShadow(true)
	end)
end
--PATH addons/[miecze] moce i hilty/lua/memetispowers/sh_rebuke.lua:
return gluapack()()
--PATH addons/[ui] msd_ui/lua/msd/sh_config.lua:
return gluapack()()
--PATH addons/[ui] msd_ui/lua/msd/sh_language.lua:
-- 
-- 
-- By MacTavish <3
-- 
-- 
-- 
local files = file.Find("msd/language/*", "LUA")

for k, v in ipairs(files) do
	if (SERVER) then
		include("msd/language/" .. v)
		AddCSLuaFile("msd/language/" .. v)
		MsgC(Color(174, 0, 255), "[MSD] " .. v .. " language found\n")
	else
		include("msd/language/" .. v)
	end
end

function MSD.GetPhrase(name, ...)
	local lang = MSD.Language[MSD.Config.Language] or MSD.Language["en"]
	local prase = lang[name]

	if not prase then
		prase = MSD.Language["en"][name]
	end

	if not prase then return name end

	return string.format(prase, ...)
end
--PATH addons/[ui] msd_ui/lua/msd/language/de.lua:
return gluapack()()
--PATH addons/[ui] msd_ui/lua/msd/language/fr.lua:
return gluapack()()
--PATH addons/[ui] msd_ui/lua/msd/ui/elements.lua:
function MSD.WorkSpacePanel(parent, title, wd, hd, a_ignore)
	if not wd or not hd then
		wd, hd = 1.1, 1.3
	end

	local panel = vgui.Create("DPanel")

	if not a_ignore then
		panel:SetAlpha(0)
		panel:AlphaTo(255, 0.3)
	end

	panel.Paint = function(self, w, h)
		draw.RoundedBox(MSD.Config.Rounded, 0, 0, w, h, MSD.Theme["d"])
		MSD.Blur(self, 3, 5, 255, 50, w, h)
	end

	panel.Close = function()
		panel:AlphaTo(0, 0.3, 0, function()
			panel:Remove()
		end)
	end

	panel.PerformLayout = function(self)
		local children = self:GetChildren()

		for k, v in pairs(children) do
			v:InvalidateLayout()
		end
	end

	parent:AddToWorkSpace(panel)
	local child = vgui.Create("DPanel", panel)
	child:SetSize(math.Clamp(panel:GetWide() / wd, 500, 900), panel:GetTall() / hd)
	child:Center()

	child.Paint = function(self, w, h)
		draw.RoundedBox(MSD.Config.Rounded, 0, 0, w, h, MSD.Theme["d"])
		draw.DrawText(title, "MSDFont.25", 10, 10, color_white, TEXT_ALIGN_LEFT)
	end

	child.PerformLayout = function(self)
		child:Center()

		if child.clsBut then
			child.clsBut:SetPos(child:GetWide() - 38, 5)
		end
	end

	child.clsBut = MSD.IconButton(child, MSD.Icons48.cross, child:GetWide() - 34, 10, 25, nil, MSD.Config.MainColor["r"], function()
		panel.Close()
	end)

	return panel, child
end

function MSD.IconButton(parent, mat, x, y, s, color, color2, func)
	local button = vgui.Create("DButton")

	if x and y then
		button:SetParent(parent)
		button:SetPos(x, y)
	end

	if x == "static" then
		button.StaticScale = {
			w = s,
			fixed_h = s,
			minw = s,
			minh = s
		}
	end

	button:SetSize(s, s)
	button:SetText("")
	button.hovered = false
	button.alpha = 0
	button.mat = mat

	button.Paint = function(self, w, h)
		if self.hover or self.hovered then
			self.alpha = Lerp(FrameTime() * 5, self.alpha, 1)
		else
			self.alpha = Lerp(FrameTime() * 5, self.alpha, 0)
		end

		MSD.DrawTexturedRect(0, 0, w, h, self.mat, MSD.ColorAlpha(color or MSD.Text.l, 255 - self.alpha * 255))

		if self.alpha > 0 then
			MSD.DrawTexturedRect(0, 0, w, h, self.mat, MSD.ColorAlpha(color2 or MSD.Config.MainColor["p"], self.alpha * 255))
		end

		return true
	end

	button.DoClick = func

	button.OnCursorEntered = function(self)
		self.hover = true
	end

	button.OnCursorExited = function(self)
		self.hover = false
	end

	button.DoRightClick = func

	if not x or not y then
		parent:AddItem(button)
	end

	return button
end

function MSD.IconButtonText(parent, text, mat, x, y, s, color, color2, func)
	local button = vgui.Create("DButton")

	if x and y then
		button:SetParent(parent)
		button:SetPos(x, y)
	end

	if x == "static" then
		button.StaticScale = {
			w = s * 2,
			fixed_h = s + 32,
			minw = s * 2,
			minh = s + 16
		}
	end

	button:SetSize(s, s + 32)
	button:SetText(text)
	button.hovered = false
	button.alpha = 0
	button.mat = mat

	button.Paint = function(self, w, h)
		if self.hover or self.hovered then
			self.alpha = Lerp(FrameTime() * 5, self.alpha, 1)
		else
			self.alpha = Lerp(FrameTime() * 5, self.alpha, 0)
		end

		MSD.DrawTexturedRect(w / 2 - s / 2, 0, s, s, self.mat, MSD.ColorAlpha(color or MSD.Text.d, 255 - self.alpha * 255))

		if self.alpha > 0 then
			MSD.DrawTexturedRect(w / 2 - s / 2, 0, s, s, self.mat, MSD.ColorAlpha(color2 or MSD.Config.MainColor["p"], self.alpha * 255))
		end

		draw.DrawText(MSD.TextWrap(self:GetText(), "MSDFont.16", w - 4), "MSDFont.16", w / 2, s, color or MSD.Text.d, TEXT_ALIGN_CENTER)

		return true
	end

	button.DoClick = func

	button.OnCursorEntered = function(self)
		self.hover = true
	end

	button.OnCursorExited = function(self)
		self.hover = false
	end

	button.DoRightClick = func

	if not x or not y then
		parent:AddItem(button)
	end

	return button
end

function MSD.IconButtonBG(parent, mat, x, y, s, color, color2, func)
	local button = vgui.Create("DButton")
	button:SetSize(s, s)

	if x then
		button:SetParent(parent)
		button:SetPos(x, y)
	end

	button:SetText("")
	button.hovered = false
	button.alpha = 0
	button.mat = mat

	button.Paint = function(self, w, h)
		if self.hover or self.hovered then
			self.alpha = Lerp(FrameTime() * 5, self.alpha, 1)
		else
			self.alpha = Lerp(FrameTime() * 5, self.alpha, 0)
		end

		draw.RoundedBox(MSD.Config.Rounded, 0, 0, w, h, MSD.Theme.d)

		if self.alpha > 0 then
			draw.RoundedBox(MSD.Config.Rounded, 0, 0, w, h, MSD.ColorAlpha(MSD.Config.MainColor["p"], 255 * self.alpha))
		end

		MSD.DrawTexturedRect(w / 2 - 12, h / 2 - 12, 24, 24, self.mat, color_white)

		return true
	end

	button.DoClick = func

	button.OnCursorEntered = function(self)
		self.hover = true
	end

	button.OnCursorExited = function(self)
		self.hover = false
	end

	button.DoRightClick = func

	if not x then
		parent:AddItem(button)
	end

	return button
end

function MSD.MenuButton(parent, mat, x, y, sw, sh, text, func, rfunc, small)
	local button = vgui.Create("DButton")
	button:SetSize(sw, sh)

	if x then
		button:SetParent(parent)
		button:SetPos(x, y)
	end

	button:SetText("")
	button.hovered = false
	button.alpha = 0
	button.mat = mat

	button.Paint = function(self, w, h)
		local icon_size = small and 16 or h - 20
		if self.hovered then
			draw.RoundedBox(MSD.Config.Rounded, 0, 0, w, h, MSD.Theme["d"])
		end

		if self.hover then
			self.alpha = Lerp(FrameTime() * 5, self.alpha, 1)
		else
			self.alpha = Lerp(FrameTime() * 5, self.alpha, 0)
		end
		local rf = MSD.Config.Rounded
		if self.alpha > 0.01 then
			draw.RoundedBox(rf, rf, rf, math.max((w - rf * 2) * self.alpha, icon_size + 12 - rf), h - rf * 2, MSD.ColorAlpha(MSD.Config.MainColor["p"], 255 * self.alpha))
		end

		MSD.DrawTexturedRect(small and h / 2 - rf or 10, small and h / 2 - rf or 10, icon_size, icon_size, self.mat, color_white)
		draw.DrawText(text, "MSDFont.22", 55, 12, color_white, TEXT_ALIGN_LEFT)

		return true
	end

	button.DoClick = func

	button.OnCursorEntered = function(self)
		self.hover = true
	end

	button.OnCursorExited = function(self)
		self.hover = false
	end

	button.DoRightClick = func

	if not x then
		parent:AddItem(button)
	end

	return button
end

function MSD.MenuButtonTop(parent, mat, x, y, sw, sh, text, func, rfunc, small)
	local button = vgui.Create("DButton")

	if sw == "auto" and text ~= "" then
		surface.SetFont("MSDFont.22")
		local tw = surface.GetTextSize(text)
		button:SetSize(70 + tw, sh)
	elseif sw == "auto" and text == "" then
		button:SetSize(sh, sh)
	else
		button:SetSize(sw, sh)
	end

	if x then
		button:SetParent(parent)
		button:SetPos(x, y)
	end

	button:SetText("")
	button.hovered = false
	button.alpha = 0
	button.mat = mat

	button.Paint = function(self, w, h)
		local icon_size = small and 16 or h - 20
		local rf = MSD.Config.Rounded

		if self.hovered then
			draw.RoundedBox(rf, 0, 0, w, h, MSD.Theme["d"])
		end

		if self.hover then
			self.alpha = Lerp(FrameTime() * 7, self.alpha, 1)
		else
			self.alpha = Lerp(FrameTime() * 7, self.alpha, 0)
		end

		if self.alpha > 0.01 then
			draw.RoundedBoxEx(rf, rf, h - 5, w - rf * 2, 5 + rf, MSD.ColorAlpha(MSD.Config.MainColor["p"], 255 * self.alpha), true, true, false, false)
		end

		MSD.DrawTexturedRect(small and h / 2 - rf or 10, small and h / 2 - rf or 10, icon_size, icon_size, self.mat, color_white)
		draw.DrawText(text, "MSDFont.22", 55, 12, color_white, TEXT_ALIGN_LEFT)

		return true
	end

	button.DoClick = func

	button.OnCursorEntered = function(self)
		self.hover = true
	end

	button.OnCursorExited = function(self)
		self.hover = false
	end

	button.DoRightClick = func

	if not x then
		parent:AddItem(button)
	end

	return button
end

function MSD.Header(parent, text, back, icon, align)
	local panel = vgui.Create("DPanel")

	panel.StaticScale = {
		w = 1,
		fixed_h = 50,
		minw = 250,
		minh = 50
	}

	panel.Paint = function(self, w, h)
		draw.RoundedBox(MSD.Config.Rounded, 0, 0, w, h, MSD.Theme["l"])
		draw.DrawText(text, "MSDFont.25", align and 50 or w / 2, 12, color_white, align and TEXT_ALIGN_LEFT or TEXT_ALIGN_CENTER)
	end

	parent:AddItem(panel)

	if back then
		MSD.IconButton(panel, icon or MSD.Icons48.back, 13, 13, 24, nil, nil, back)
	end

	return panel
end

function MSD.InfoHeader(parent, text, wd)
	local panel = vgui.Create("DPanel")
	wd = wd or 1
	panel.StaticScale = {
		w = wd,
		fixed_h = 25,
		minw = 250,
		minh = 25
	}

	panel.Paint = function(self, w, h)
		draw.RoundedBox(MSD.Config.Rounded, 0, 0, w, h, MSD.Theme["l"])
		draw.DrawText(text, "MSDFont.20", 5, h / 2 - 11, color_white, TEXT_ALIGN_LEFT)
	end

	parent:AddItem(panel)

	return panel
end

function MSD.InfoText(parent, text)
	local panel = vgui.Create("DPanel")

	panel.StaticScale = {
		w = 1,
		fixed_h = 25,
		minw = 250,
		minh = 25
	}

	panel.Paint = function(self, w, h)
		local ts, _, th = MSD.TextWrap(text, "MSDFont.18", w - 10)
		draw.DrawText(ts, "MSDFont.18", 5, 5, MSD.Text.d, TEXT_ALIGN_LEFT)

		if th > h then
			self.StaticScale.fixed_h = th + 10
		end
	end

	parent:AddItem(panel)

	return panel
end

function MSD.TextEntry(parent, x, y, w, h, text, label, value, func, auto_update, focuse_update, multi, num)
	local Entry = vgui.Create("DTextEntry")

	if x and y then
		Entry:SetParent(parent)
		Entry:SetPos(x, y)
	end

	if x == "static" then
		Entry.StaticScale = {
			w = w,
			fixed_h = h,
			minw = 50,
			minh = h
		}
	else
		Entry:SetSize(w, h)
	end

	Entry:SetNumeric(num or false)
	Entry:SetText("")
	Entry:SetFont("MSDFont.22")
	Entry:SetMultiline(multi or false)
	Entry.alpha = 0
	Entry:SetDrawLanguageID(false)

	Entry.Paint = function(self, wd, hd)
		if self:HasFocus() then
			self.alpha = Lerp(FrameTime() * 5, self.alpha, 255)
		else
			self.alpha = Lerp(FrameTime() * 5, self.alpha, 0)
		end
		local rf = MSD.Config.Rounded
		draw.RoundedBox(rf, 0, 0, wd, hd, MSD.Theme["l"])
		draw.RoundedBox(0, rf, hd - 1, wd - rf * 2, 1, MSD.ColorAlpha(MSD.Text["n"], 255 - self.alpha))
		draw.RoundedBox(0, rf, hd - 1, wd - rf * 2, 1, MSD.ColorAlpha(MSD.Config.MainColor["p"], self.alpha))

		if self:GetValue() == "" then
			draw.SimpleText(text, "MSDFont.22", 3, multi and 1 or hd / 2 - 10, MSD.ColorAlpha(MSD.Text["d"], 120), TEXT_ALIGN_LEFT)
		end

		if label and not self.error then
			draw.SimpleText(label, "MSDFont.16", 3, 0, MSD.ColorAlpha(MSD.Text["d"], 120), TEXT_ALIGN_LEFT)
		end

		if self.error then
			draw.SimpleText(self.error, "MSDFont.16", 3, 0, MSD.Config.MainColor["r"], TEXT_ALIGN_LEFT)
		end

		self:DrawTextEntryText(self.error and MSD.Config.MainColor["rd"] or MSD.Text["l"], MSD.Config.MainColor["p"], MSD.Text["d"])
	end

	Entry.OnEnter = func

	if focuse_update then
		Entry.OnFocusChanged = function(self, gained)
			if not gained then
				func(self, self:GetValue())
			end
		end
	end

	Entry:SetText(value or "")

	if auto_update then
		Entry:SetUpdateOnType(true)

		function Entry:OnValueChange(vl)
			if func then
				func(self, vl)
			end
		end
	end

	if not x or not y then
		parent:AddItem(Entry)
	end

	return Entry
end

function MSD.VectorDisplay(parent, x, y, w, h, text, vector, func)
	local Entry = vgui.Create("DButton")
	Entry:SetText("")
	if x and y then
		Entry:SetParent(parent)
		Entry:SetPos(x, y)
	end

	if x == "static" then
		Entry.StaticScale = { w = w, fixed_h = h, minw = 50, minh = h }
	else
		Entry:SetSize(w, h)
	end
	Entry.vector = vector or Vector(0, 0, 0)
	Entry.Paint = function(self, sw, sh)
		draw.RoundedBox(MSD.Config.Rounded, 0, 0, sw, sh, MSD.Theme["l"])
		draw.RoundedBox(0, MSD.Config.Rounded, sh - 1, sw - MSD.Config.Rounded * 2, 1, MSD.Text["n"])

		if text then
			draw.SimpleText(text, "MSDFont.16", 3, 0, MSD.ColorAlpha(MSD.Text["d"], 120), TEXT_ALIGN_LEFT)
		end

		draw.SimpleText("x: " .. self.vector.x .. " y: " .. self.vector.y .. " z: " .. self.vector.z, "MSDFont.22", 3, h / 2 - 10, MSD.Text["d"], TEXT_ALIGN_LEFT)
	end
	Entry.DoClick = function(self)

		if self.rebuild or self.disabled then return end
		self.rebuild = true

		if IsValid(self.cpanel) then
			self.cpanel:Remove()
			self.cpanel = nil
			self:SizeTo(self:GetWide(), h, 0.2, 0, -1, function()
				Entry.StaticScale = { w = w, fixed_h = h, minw = 50, minh = h}
				parent:Rebuild()
				self.rebuild = nil
			end)
			return
		end

		Entry.StaticScale = {
			w = w,
			fixed_h = h + 50,
			minw = 50,
			minh = h + 50
		}
		parent:Rebuild()
		self:SetSize(self:GetWide(), h)
		self:SizeTo(self:GetWide(), h + 50, 0.2, 0, -1, function()
			self.rebuild = nil
		end)
		local mpw = self:GetWide()
		self.cpanel = vgui.Create("DPanel", self)
		self.cpanel:SetSize(mpw, 50)
		self.cpanel:SetPos(0, h)
		self.cpanel.Paint = function() end

		self.x = MSD.TextEntry(self.cpanel, 0, 0, mpw / 3, 45, "", "X", self.vector.x, function(sp, value)
			value = tonumber(value) or 0
			self.vector.x = value
			func(self.vector, self)
		end, true, nil, false, true)

		self.y = MSD.TextEntry(self.cpanel, mpw / 3, 0, mpw / 3, 45, "", "Y", self.vector.y, function(sp, value)
			value = tonumber(value) or 0
			self.vector.y = value
			func(self.vector, self)
		end, true, nil, false, true)

		self.z = MSD.TextEntry(self.cpanel, mpw - mpw / 3, 0, mpw / 3, 45, "", "Z", self.vector.z, function(sp, value)
			value = tonumber(value) or 0
			self.vector.z = value
			func(self.vector, self)
		end, true, nil, false, true)
	end

	if not x or not y then
		parent:AddItem(Entry)
	end

	return Entry
end

function MSD.AngleDisplay(parent, x, y, w, h, text, angle, func)
	local Entry = vgui.Create("DButton")
	Entry:SetText("")
	if x and y then
		Entry:SetParent(parent)
		Entry:SetPos(x, y)
	end

	if x == "static" then
		Entry.StaticScale = { w = w, fixed_h = h, minw = 50, minh = h }
	else
		Entry:SetSize(w, h)
	end

	Entry.angle = angle or Angle(0, 0, 0)
	Entry.Paint = function(self, sw, sh)
		draw.RoundedBox(MSD.Config.Rounded, 0, 0, sw, h, MSD.Theme["l"])
		draw.RoundedBox(0, MSD.Config.Rounded, sh - 1, sw - MSD.Config.Rounded * 2, 1, MSD.Text["n"])

		if text then
			draw.SimpleText(text, "MSDFont.16", 3, 0, MSD.ColorAlpha(MSD.Text["d"], 120), TEXT_ALIGN_LEFT)
		end

		draw.SimpleText("p: " .. self.angle.p .. " y: " .. self.angle.y .. " r: " .. self.angle.r, "MSDFont.22", 3, h / 2 - 10, MSD.Text["d"], TEXT_ALIGN_LEFT)
	end
	Entry.DoClick = function(self)

		if self.rebuild or self.disabled then return end
		self.rebuild = true

		if IsValid(self.cpanel) then
			self.cpanel:Remove()
			self.cpanel = nil
			self:SizeTo(self:GetWide(), h, 0.2, 0, -1, function()
				Entry.StaticScale = { w = w, fixed_h = h, minw = 50, minh = h}
				parent:Rebuild()
				self.rebuild = nil
			end)
			return
		end

		Entry.StaticScale = {
			w = w,
			fixed_h = h + 50,
			minw = 50,
			minh = h + 50
		}
		parent:Rebuild()
		self:SetSize(self:GetWide(), h)
		self:SizeTo(self:GetWide(), h + 50, 0.2, 0, -1, function()
			self.rebuild = nil
		end)
		local mpw = self:GetWide()
		self.cpanel = vgui.Create("DPanel", self)
		self.cpanel:SetSize(mpw, 50)
		self.cpanel:SetPos(0, h)
		self.cpanel.Paint = function() end

		self.x = MSD.TextEntry(self.cpanel, 0, 0, mpw / 3, 45, "", "X", self.angle.p, function(sp, value)
			value = tonumber(value) or 0
			self.angle.p = value
			func(self.angle, self)
		end, true, nil, false, true)

		self.y = MSD.TextEntry(self.cpanel, mpw / 3, 0, mpw / 3, 45, "", "Y", self.angle.y, function(sp, value)
			value = tonumber(value) or 0
			self.angle.y = value
			func(self.angle, self)
		end, true, nil, false, true)

		self.z = MSD.TextEntry(self.cpanel, mpw - mpw / 3, 0, mpw / 3, 45, "", "Z", self.angle.r, function(sp, value)
			value = tonumber(value) or 0
			self.angle.r = value
			func(self.angle, self)
		end, true, nil, false, true)
	end

	if not x or not y then
		parent:AddItem(Entry)
	end

	return Entry
end

function MSD.ColorSelectBut(parent, x, y, w, h, color, func)
	local button = vgui.Create("DButton")
	button:SetText("")

	if x and y then
		button:SetParent(parent)
		button:SetPos(x, y)
	end

	if x == "static" then
		button.StaticScale = {
			w = w,
			fixed_h = h,
			minw = 10,
			minh = h
		}
	else
		button:SetSize(w, h)
	end

	button.alpha = 0

	button.Paint = function(self, wd, hd)
		draw.RoundedBox(MSD.Config.Rounded, 0, 0, wd, hd, color)

		if (self.hover or self.hovered) and not self.disabled then
			self.alpha = Lerp(FrameTime() * 5, self.alpha, 1)
		else
			self.alpha = Lerp(FrameTime() * 5, self.alpha, 0)
		end

		return true
	end

	button.OnCursorEntered = function(self)
		self.hover = true
	end

	button.OnCursorExited = function(self)
		self.hover = false
	end

	button.DoClick = function(self)
		func(self)
	end

	if not x or not y then
		parent:AddItem(button)
	end

	return button
end

function MSD.Binder(parent, x, y, w, h, text, var, func)
	local binder = vgui.Create("DBinder")

	if x and y then
		binder:SetParent(parent)
		binder:SetPos(x, y)
	end

	if x == "static" then
		binder.StaticScale = {
			w = w,
			fixed_h = h,
			minw = 150,
			minh = h
		}
	else
		binder:SetSize(w, h)
	end

	binder:SetValue(var)
	binder.alpha = 0

	binder.Paint = function(self, wd, hd)
		local rf = MSD.Config.Rounded
		draw.RoundedBox(rf, 0, 0, wd, hd, MSD.Theme["l"])

		if (self.hover or self.hovered or self.Trapping) and not self.disabled then
			self.alpha = Lerp(FrameTime() * 5, self.alpha, 1)
		else
			self.alpha = Lerp(FrameTime() * 5, self.alpha, 0)
		end

		draw.DrawText(text, "MSDFont.22", 5, hd / 2 - 11, MSD.ColorAlpha(MSD.Config.MainColor["p"], self.alpha * 255), TEXT_ALIGN_LEFT)
		draw.DrawText(text, "MSDFont.22", 5, hd / 2 - 11, MSD.ColorAlpha(self.disabled and MSD.Text["n"] or MSD.Text["s"], 255 - self.alpha * 255), TEXT_ALIGN_LEFT)
		draw.DrawText(string.upper(self:GetText()), "MSDFont.22", wd - wd / 3 / 2, hd / 2 - 11, MSD.ColorAlpha(MSD.Config.MainColor["p"], self.alpha * 255), TEXT_ALIGN_CENTER)
		draw.DrawText(string.upper(self:GetText()), "MSDFont.22", wd - wd / 3 / 2, hd / 2 - 11, MSD.ColorAlpha(self.disabled and MSD.Text["n"] or MSD.Text["s"], 255 - self.alpha * 255), TEXT_ALIGN_CENTER)
		draw.RoundedBox(0, rf, hd - 1, (wd / 3) * 2 - 5 - rf, 1, MSD.ColorAlpha(MSD.Text["n"], 255 - self.alpha * 255))
		draw.RoundedBox(0, rf, hd - 1, (wd / 3) * 2 - 5 - rf, 1, MSD.ColorAlpha(MSD.Config.MainColor["p"], self.alpha * 255))
		draw.RoundedBox(0, wd - wd / 3, hd - 1, wd / 3 - rf, 1, MSD.ColorAlpha(MSD.Text["n"], 255 - self.alpha * 255))
		draw.RoundedBox(0, wd - wd / 3, hd - 1, wd / 3 - rf, 1, MSD.ColorAlpha(MSD.Config.MainColor["p"], self.alpha * 255))

		return true
	end

	binder.OnCursorEntered = function(self)
		self.hover = true
	end

	binder.OnCursorExited = function(self)
		self.hover = false
	end

	function binder:OnChange(num)
		if num > 106 and num < 114 then
			binder:SetValue(var)
		else
			func(num)
		end
	end

	if not x or not y then
		parent:AddItem(binder)
	end
end

function MSD.ButtonScr(parent, x, y, w, h, text, func, al_left)
	local button = vgui.Create("DButton")
	button:SetText(text)

	if x and y then
		button:SetParent(parent)
		button:SetPos(x, y)
	end

	if x == "static" then
		button.StaticScale = {
			w = w,
			h_w = true,
			minw = 150
		}
	else
		button:SetSize(w, h)
	end

	button.alpha = 0

	button.Paint = function(self, wd, hd)
		draw.RoundedBox(MSD.Config.Rounded, 0, 0, wd, hd, MSD.Theme["l"])

		if (self.hover or self.hovered) and not self.disabled then
			self.alpha = Lerp(FrameTime() * 5, self.alpha, 1)
		else
			self.alpha = Lerp(FrameTime() * 5, self.alpha, 0)
		end

		draw.DrawText(MSD.TextWrap(self:GetText(), "MSDFont.18", w - 20), "MSDFont.18", al_left and 5 or wd / 2, hd / 2 - 11, MSD.ColorAlpha(MSD.Config.MainColor["p"], self.alpha * 255), al_left and TEXT_ALIGN_LEFT or TEXT_ALIGN_CENTER)
		draw.DrawText(MSD.TextWrap(self:GetText(), "MSDFont.18", w - 20), "MSDFont.18", al_left and 5 or wd / 2, hd / 2 - 11, MSD.ColorAlpha(self.disabled and MSD.Text["n"] or MSD.Text["s"], 255 - self.alpha * 255), al_left and TEXT_ALIGN_LEFT or TEXT_ALIGN_CENTER)
		draw.RoundedBox(MSD.Config.Rounded, 0, hd - 1, wd, 1, MSD.ColorAlpha(MSD.Text["l"], 255 - self.alpha * 255))
		draw.RoundedBox(MSD.Config.Rounded, 0, hd - 1, wd, 1, MSD.ColorAlpha(MSD.Config.MainColor["p"], self.alpha * 255))

		return true
	end

	button.OnCursorEntered = function(self)
		self.hover = true
	end

	button.OnCursorExited = function(self)
		self.hover = false
	end

	button.DoClick = function(self)
		func(self)
	end

	if not x or not y then
		parent:AddItem(button)
	end

	return button
end

function MSD.Button(parent, x, y, w, h, text, func, al_left)
	local button = vgui.Create("DButton")
	button:SetText(text)

	if x and y then
		button:SetParent(parent)
		button:SetPos(x, y)
	end

	if x == "static" then
		button.StaticScale = {
			w = w,
			fixed_h = h,
			minw = 150,
			minh = h
		}
	else
		button:SetSize(w, h)
	end

	button.alpha = 0

	button.Paint = function(self, wd, hd)
		draw.RoundedBox(MSD.Config.Rounded, 0, 0, wd, hd, MSD.Theme["l"])

		if (self.hover or self.hovered) and not self.disabled then
			self.alpha = Lerp(FrameTime() * 5, self.alpha, 1)
		else
			self.alpha = Lerp(FrameTime() * 5, self.alpha, 0)
		end

		draw.DrawText(self:GetText(), "MSDFont.22", al_left and 5 or wd / 2, hd / 2 - 11, MSD.ColorAlpha(MSD.Config.MainColor["p"], self.alpha * 255), al_left and TEXT_ALIGN_LEFT or TEXT_ALIGN_CENTER)
		draw.DrawText(self:GetText(), "MSDFont.22", al_left and 5 or wd / 2, hd / 2 - 11, MSD.ColorAlpha(self.disabled and MSD.Text["n"] or MSD.Text["s"], 255 - self.alpha * 255), al_left and TEXT_ALIGN_LEFT or TEXT_ALIGN_CENTER)
		draw.RoundedBox(0, MSD.Config.Rounded, hd - 1, wd - MSD.Config.Rounded * 2, 1, MSD.ColorAlpha(MSD.Text["n"], 255 - self.alpha * 255))
		draw.RoundedBox(0, MSD.Config.Rounded, hd - 1, wd - MSD.Config.Rounded * 2, 1, MSD.ColorAlpha(MSD.Config.MainColor["p"], self.alpha * 255))

		return true
	end

	button.OnCursorEntered = function(self)
		self.hover = true
	end

	button.OnCursorExited = function(self)
		self.hover = false
	end

	button.DoClick = function(self)
		func(self)
	end

	if not x or not y then
		parent:AddItem(button)
	end

	return button
end

function MSD.ButtonSimple(parent, x, y, w, h, text, fsize, func)
	local button = vgui.Create("DButton")
	button:SetText(text)

	if x and y then
		button:SetParent(parent)
		button:SetPos(x, y)
	end

	if x == "static" then
		button.StaticScale = {
			w = w,
			fixed_h = h,
			minw = 150,
			minh = h
		}
	else
		button:SetSize(w, h)
	end

	button.Paint = function(self, wd, hd)
		if self.Check and self.Check() and not self.disabled then
			draw.RoundedBox(MSD.Config.Rounded, 0, 0, wd, hd, MSD.Theme["d"])
		end

		if (self.hover or self.hovered) and not self.disabled then
			draw.DrawText(self:GetText(), "MSDFont." .. fsize, 5, hd / 2 - fsize / 2, MSD.Config.MainColor["p"], TEXT_ALIGN_LEFT)
		else
			draw.DrawText(self:GetText(), "MSDFont." .. fsize, 5, hd / 2 - fsize / 2, self.disabled and MSD.Text["n"] or MSD.Text["s"], TEXT_ALIGN_LEFT)
		end
		return true
	end

	button.OnCursorEntered = function(self)
		self.hover = true
	end

	button.OnCursorExited = function(self)
		self.hover = false
	end

	button.DoClick = function(self)
		func(self)
	end

	if not x or not y then
		parent:AddItem(button)
	end

	return button
end

function MSD.NumberWang(parent, x, y, w, h, min, max, val, label, func)
	local button = vgui.Create("DNumberWang")
	button:SetValue(val)

	if x and y then
		button:SetParent(parent)
		button:SetPos(x, y)
	end

	if x == "static" then
		button.StaticScale = {
			w = w,
			fixed_h = h,
			minw = 50,
			minh = h
		}
	else
		button:SetSize(w, h)
	end

	button.alpha = 0
	button:SetFont("MSDFont.22")
	button:SetMin(min)
	button:SetMax(max)

	button.Paint = function(self, wd, hd)
		if self:HasFocus() then
			self.alpha = Lerp(FrameTime() * 5, self.alpha, 255)
		else
			self.alpha = Lerp(FrameTime() * 5, self.alpha, 0)
		end

		draw.RoundedBox(MSD.Config.Rounded, 0, 0, wd, hd, MSD.Theme["l"])
		draw.RoundedBox(0, MSD.Config.Rounded, hd - 1, wd - MSD.Config.Rounded * 2, 1, MSD.ColorAlpha(MSD.Text["n"], 255 - self.alpha))
		draw.RoundedBox(0, MSD.Config.Rounded, hd - 1, wd - MSD.Config.Rounded * 2, 1, MSD.ColorAlpha(MSD.Config.MainColor["p"], self.alpha))

		if label and not self.error then
			draw.SimpleText(label, "MSDFont.16", 3, 0, MSD.ColorAlpha(MSD.Text["d"], 120), TEXT_ALIGN_LEFT)
		end

		if self.error then
			draw.SimpleText(self.error, "MSDFont.16", 3, 0, MSD.Config.MainColor["r"], TEXT_ALIGN_LEFT)
		end

		self:DrawTextEntryText(self.error and MSD.Config.MainColor["rd"] or MSD.Text["l"], MSD.Config.MainColor["p"], MSD.Text["d"])

		return true
	end

	button.OnValueChanged = function(self)
		func(self)
	end

	if not x or not y then
		parent:AddItem(button)
	end

	return button
end

function MSD.ButtonIcon(parent, x, y, w, h, text, icon, func, func2, color, color2, drawf)
	local button = vgui.Create("DButton")
	button:SetText(text)

	if x and y then
		button:SetParent(parent)
		button:SetPos(x, y)
	end

	if x == "static" then
		button.StaticScale = {
			w = w,
			fixed_h = h,
			minw = 50,
			minh = h
		}
	else
		button:SetSize(w, h)
	end

	button.alpha = 0

	button.Paint = function(self, wd, hd)
		draw.RoundedBox(MSD.Config.Rounded, 0, 0, wd, hd, MSD.Theme["l"])

		if drawf then drawf(self, wd, hd) end

		if (self.hover or self.hovered) and not self.disabled then
			self.alpha = Lerp(FrameTime() * 5, self.alpha, 1)
		else
			self.alpha = Lerp(FrameTime() * 5, self.alpha, 0)
		end

		draw.DrawText(self:GetText(), "MSDFont.22", 48, hd / 2 - 11, MSD.ColorAlpha(MSD.Config.MainColor["p"], self.alpha * 255), TEXT_ALIGN_LEFT)
		draw.DrawText(self:GetText(), "MSDFont.22", 48, hd / 2 - 11, MSD.ColorAlpha(self.disabled and MSD.Text["n"] or MSD.Text["s"], 255 - self.alpha * 255), TEXT_ALIGN_LEFT)
		draw.RoundedBox(0, MSD.Config.Rounded, hd - 1, wd - MSD.Config.Rounded * 2, 1, MSD.ColorAlpha(color or MSD.Text["n"], 255 - self.alpha * 255))
		draw.RoundedBox(0, MSD.Config.Rounded, hd - 1, wd - MSD.Config.Rounded * 2, 1, MSD.ColorAlpha(color2 or MSD.Config.MainColor["p"], self.alpha * 255))
		MSD.DrawTexturedRect(12, hd / 2 - 12, 24, 24, icon, MSD.ColorAlpha(color or MSD.Text["l"], 255 - self.alpha * 255))
		MSD.DrawTexturedRect(12, hd / 2 - 12, 24, 24, icon, MSD.ColorAlpha(color2 or MSD.Config.MainColor["p"], self.alpha * 255))

		return true
	end

	if func then
		button.OnCursorEntered = function(self)
			self.hover = true
		end

		button.OnCursorExited = function(self)
			self.hover = false
		end

		button.DoClick = function(self)
			func(self)
		end
	end

	if func2 then
		button.DoRightClick = function(self)
			func2(self)
		end
	end

	if not x or not y then
		parent:AddItem(button)
	end

	return button
end

function MSD.ButtonIconText(parent, x, y, w, h, text, text2, icon, func, func2, color)
	local button = vgui.Create("DButton")
	button:SetText(text)

	if x and y then
		button:SetParent(parent)
		button:SetPos(x, y)
	end

	if x == "static" then
		button.StaticScale = {
			w = w,
			fixed_h = h,
			minw = 50,
			minh = h
		}
	else
		button:SetSize(w, h)
	end

	button.alpha = 0
	button.text = text2

	button.Paint = function(self, wd, hd)
		draw.RoundedBox(MSD.Config.Rounded, 0, 0, wd, hd, MSD.Theme["l"])

		if (self.hover or self.hovered) and not self.disabled then
			self.alpha = Lerp(FrameTime() * 5, self.alpha, 1)
		else
			self.alpha = Lerp(FrameTime() * 5, self.alpha, 0)
		end

		draw.DrawText(self.text, "MSDFont.22", wd - 5, hd / 2 - 11, self.disabled and MSD.Text["n"] or MSD.Text["s"], TEXT_ALIGN_RIGHT)
		draw.DrawText(self:GetText(), "MSDFont.22", 48, hd / 2 - 11, MSD.ColorAlpha(MSD.Config.MainColor["p"], self.alpha * 255), TEXT_ALIGN_LEFT)
		draw.DrawText(self:GetText(), "MSDFont.22", 48, hd / 2 - 11, MSD.ColorAlpha(self.disabled and MSD.Text["n"] or MSD.Text["s"], 255 - self.alpha * 255), TEXT_ALIGN_LEFT)
		draw.RoundedBox(0, MSD.Config.Rounded, hd - 1, wd - MSD.Config.Rounded * 2, 1, MSD.ColorAlpha(color or MSD.Text["n"], 255 - self.alpha * 255))
		draw.RoundedBox(0, MSD.Config.Rounded, hd - 1, wd - MSD.Config.Rounded * 2, 1, MSD.ColorAlpha(MSD.Config.MainColor["p"], self.alpha * 255))
		MSD.DrawTexturedRect(12, hd / 2 - 12, 24, 24, icon, MSD.ColorAlpha(color or MSD.Text["l"], 255 - self.alpha * 255))
		MSD.DrawTexturedRect(12, hd / 2 - 12, 24, 24, icon, MSD.ColorAlpha(MSD.Config.MainColor["p"], self.alpha * 255))

		return true
	end

	if func then
		button.OnCursorEntered = function(self)
			self.hover = true
		end

		button.OnCursorExited = function(self)
			self.hover = false
		end

		button.DoClick = function(self)
			func(self)
		end
	end

	if func2 then
		button.DoRightClick = function(self)
			func2(self)
		end
	end

	if not x or not y then
		parent:AddItem(button)
	end

	return button
end

function MSD.VolumeSlider(parent, x, y, w, h, text, var, func, cl)
	local button = vgui.Create("DButton")
	button:SetText("")

	if x and y then
		button:SetParent(parent)
		button:SetPos(x, y)
	end

	if x == "static" then
		button.StaticScale = {
			w = w,
			fixed_h = h,
			minw = 50,
			minh = h
		}
	else
		button:SetSize(w, h)
	end

	button.var = var or 1
	button.value = var or 1
	button.alpha = 0
	button.disabled = false

	button.Paint = function(self, wd, hd)
		draw.RoundedBox(MSD.Config.Rounded, 0, 0, wd, hd, MSD.Theme["l"])

		if (self.hover or self.hovered) and not self.disabled then
			self.alpha = Lerp(FrameTime() * 5, self.alpha, 1)
		else
			self.alpha = Lerp(FrameTime() * 5, self.alpha, 0)
		end

		draw.DrawText(text, "MSDFont.22", 3, hd / 2 - 11, MSD.ColorAlpha(MSD.Config.MainColor["p"], self.alpha * 255), TEXT_ALIGN_LEFT)
		draw.DrawText(text, "MSDFont.22", 3, hd / 2 - 11, MSD.ColorAlpha(self.disabled and MSD.Text["n"] or MSD.Text["s"], 255 - self.alpha * 255), TEXT_ALIGN_LEFT)
		self.var = Lerp(FrameTime() * 7, self.var, self.value)
		draw.RoundedBox(MSD.Config.Rounded, wd - wd / 2 + 10, hd / 2 - 10, wd / 2 - 20, 20, MSD.Theme["d"])

		if self.disabled then
			draw.DrawText(MSD.GetPhrase("disabled"), "MSDFont.16", wd - (wd / 2) / 2, hd / 2 - 8, MSD.Text["n"], TEXT_ALIGN_CENTER)
		else
			draw.RoundedBox(MSD.Config.Rounded, wd - wd / 2 + 10, hd / 2 - 10,  math.max((wd / 2 - 19) * self.var, 16), 20, cl or MSD.Config.MainColor["p"])
			draw.DrawText(math.Round(self.value * 100) .. "%", "MSDFont.16", wd - (wd / 2) / 2, hd / 2 - 8, MSD.Text["s"], TEXT_ALIGN_CENTER)
		end
	end

	button.OnCursorEntered = function(self)
		self.hover = true
	end

	button.OnCursorExited = function(self)
		self.hover = false
	end

	button.DoClick = function(self)
		if self.disabled then return end
		local wd = self:GetWide()
		local mx, my = gui.MousePos()
		mx, my = self:ScreenToLocal(mx, my)

		if mx < wd - wd / 2 + 10 then
			self.value = 0
		elseif mx > wd - 10 then
			self.value = 1
		else
			mx = mx - ((wd - wd / 2) + 10)
			mx = mx / ((wd / 2) - 20)
			self.value = mx
		end

		self.value = math.Round(self.value, 2)
		func(self, self.value)
	end

	if not x or not y then
		parent:AddItem(button)
	end

	return button
end

function MSD.VolumeScale(parent, x, y, w, h, text, var, func, cl)
	local button = vgui.Create("DButton")
	button:SetText("")

	if x and y then
		button:SetParent(parent)
		button:SetPos(x, y)
	end

	if x == "static" then
		button.StaticScale = {
			w = w,
			fixed_h = h,
			minw = 50,
			minh = h
		}
	else
		button:SetSize(w, h)
	end

	button.var = var or 1
	button.value = var or 1
	button.alpha = 0
	button.disabled = false

	button.Paint = function(self, wd, hd)
		draw.RoundedBox(MSD.Config.Rounded, 0, 0, wd, hd, MSD.Theme["l"])

		if (self.hover or self.hovered) and not self.disabled then
			self.alpha = Lerp(FrameTime() * 5, self.alpha, 1)
		else
			self.alpha = Lerp(FrameTime() * 5, self.alpha, 0)
		end

		draw.DrawText(text, "MSDFont.22", 3, hd / 2 - 11, MSD.ColorAlpha(MSD.Config.MainColor["p"], self.alpha * 255), TEXT_ALIGN_LEFT)
		draw.DrawText(text, "MSDFont.22", 3, hd / 2 - 11, MSD.ColorAlpha(self.disabled and MSD.Text["n"] or MSD.Text["s"], 255 - self.alpha * 255), TEXT_ALIGN_LEFT)
		self.var = Lerp(FrameTime() * 7, self.var, self.value)
		draw.RoundedBox(MSD.Config.Rounded, wd - wd / 2 + 10, hd / 2 - 10, wd / 2 - 20, 20, MSD.Theme["d"])

		if self.disabled then
			draw.DrawText(MSD.GetPhrase("disabled"), "MSDFont.16", wd - (wd / 2) / 2, hd / 2 - 8, MSD.Text["n"], TEXT_ALIGN_CENTER)
		else
			draw.RoundedBox(MSD.Config.Rounded, wd - wd / 2 + 10, hd / 2 - 10, (wd / 2 - 19) * ( self.var / 2), 20, cl or MSD.Config.MainColor["p"])
			draw.DrawText(math.Round(self.value * 100) .. "%", "MSDFont.16", wd - (wd / 2) / 2, hd / 2 - 8, MSD.Text["s"], TEXT_ALIGN_CENTER)
		end
	end

	button.OnCursorEntered = function(self)
		self.hover = true
	end

	button.OnCursorExited = function(self)
		self.hover = false
	end

	button.DoClick = function(self)
		if self.disabled then return end
		local wd = self:GetWide()
		local mx, my = gui.MousePos()
		mx, my = self:ScreenToLocal(mx, my)

		if mx < wd - wd / 2 + 10 then
			self.value = 1
		elseif mx > wd - 10 then
			self.value = 2
		else
			mx = mx - ((wd - wd / 2) + 10)
			mx = mx / ((wd / 2) - 20) * 2
			self.value = math.Clamp(mx, 0.01, 2)
		end

		self.value = math.Round(self.value, 2)
		func(self, self.value)
	end

	if not x or not y then
		parent:AddItem(button)
	end

	return button
end

function MSD.BoolSlider(parent, x, y, w, h, text, var, func)
	local button = vgui.Create("DButton")
	button:SetText("")

	if x and y then
		button:SetParent(parent)
		button:SetPos(x, y)
	end

	if x == "static" then
		button.StaticScale = {
			w = w,
			fixed_h = h,
			minw = 50,
			minh = h
		}
	else
		button:SetSize(w, h)
	end

	button.var = var or false
	button.pos = var and 1 or 0
	button.alpha = 0
	button.disabled = false

	button.Paint = function(self, wd, hd)
		draw.RoundedBox(MSD.Config.Rounded, 0, 0, wd, hd, MSD.Theme["l"])

		if (self.hover or self.hovered) and not self.disabled then
			self.alpha = Lerp(FrameTime() * 5, self.alpha, 1)
		else
			self.alpha = Lerp(FrameTime() * 5, self.alpha, 0)
		end

		draw.DrawText(text, "MSDFont.22", 3, hd / 2 - 11, MSD.ColorAlpha(MSD.Config.MainColor["p"], self.alpha * 255), TEXT_ALIGN_LEFT)
		draw.DrawText(text, "MSDFont.22", 3, hd / 2 - 11, MSD.ColorAlpha(self.disabled and MSD.Text["n"] or MSD.Text["s"], 255 - self.alpha * 255), TEXT_ALIGN_LEFT)

		if self.var then
			self.pos = Lerp(0.1, self.pos, 1)
		else
			self.pos = Lerp(0.1, self.pos, 0)
		end

		draw.RoundedBox(MSD.Config.Rounded, wd - 75, hd / 2 - 10, 68, 20, MSD.Theme["d"])

		if self.disabled then
			draw.DrawText(MSD.GetPhrase("disabled"), "MSDFont.16", wd - 40, hd / 2 - 8, MSD.Text["n"], TEXT_ALIGN_CENTER)
		else
			draw.DrawText(MSD.GetPhrase("off"), "MSDFont.16", wd - 25, hd / 2 - 8, MSD.ColorAlpha(MSD.Text["s"], 255 - self.pos * 255), TEXT_ALIGN_CENTER)
			draw.DrawText(MSD.GetPhrase("on"), "MSDFont.16", wd - 60, hd / 2 - 8, MSD.ColorAlpha(MSD.Text["s"], self.pos * 255), TEXT_ALIGN_CENTER)
			draw.RoundedBox(MSD.Config.Rounded, wd - 75 + self.pos * 35, hd / 2 - 10, 34, 20, MSD.ColorAlpha(MSD.Config.MainColor["p"], self.pos * 255))
			draw.RoundedBox(MSD.Config.Rounded, wd - 75 + self.pos * 35, hd / 2 - 10, 34, 20, MSD.ColorAlpha(MSD.Text["n"], 255 - self.pos * 255))
		end
	end

	button.OnCursorEntered = function(self)
		self.hover = true
	end

	button.OnCursorExited = function(self)
		self.hover = false
	end

	button.DoClick = function(self)
		if self.disabled then return end
		self.var = not self.var
		func(self, self.var)
	end

	if not x or not y then
		parent:AddItem(button)
	end

	return button
end

function MSD.DTextSlider(parent, x, y, w, h, text1, text2, var, func)
	local button = vgui.Create("DButton")
	button:SetText("")

	if x and y then
		button:SetParent(parent)
		button:SetPos(x, y)
	end

	if x == "static" then
		button.StaticScale = {
			w = w,
			fixed_h = h,
			minw = 50,
			minh = h
		}
	else
		button:SetSize(w, h)
	end

	button.var = var or false
	button.pos = var and 1 or 0
	button.alpha = 0
	button.disabled = false

	button.Paint = function(self, wd, hd)
		draw.RoundedBox(MSD.Config.Rounded, 0, 0, wd, hd, MSD.Theme["l"])

		if (self.hover or self.hovered) and not self.disabled then
			self.alpha = Lerp(FrameTime() * 5, self.alpha, 1)
		else
			self.alpha = Lerp(FrameTime() * 5, self.alpha, 0)
		end

		draw.DrawText(self.var and text1 or text2, "MSDFont.22", 3, hd / 2 - 10, MSD.ColorAlpha(MSD.Config.MainColor["p"], self.alpha * 255), TEXT_ALIGN_LEFT)
		draw.DrawText(self.var and text1 or text2, "MSDFont.22", 3, hd / 2 - 10, MSD.ColorAlpha(self.disabled and MSD.Text["n"] or MSD.Text["s"], 255 - self.alpha * 255), TEXT_ALIGN_LEFT)

		if self.var then
			self.pos = Lerp(0.1, self.pos, 1)
		else
			self.pos = Lerp(0.1, self.pos, 0)
		end

		draw.RoundedBox(MSD.Config.Rounded, wd - 75, hd / 2 - 10, 68, 20, MSD.Theme["d"])
		draw.RoundedBox(MSD.Config.Rounded, wd - 75 + self.pos * 35, hd / 2 - 10, 34, 20, MSD.Config.MainColor["p"])
	end

	button.OnCursorEntered = function(self)
		self.hover = true
	end

	button.OnCursorExited = function(self)
		self.hover = false
	end

	button.DoClick = function(self)
		if self.disabled then return end
		self.var = not self.var
		func(self, self.var)
	end

	if not x or not y then
		parent:AddItem(button)
	end

	return button
end

function MSD.ComboBox(parent, x, y, w, h, label, val)
	local ComboBox = vgui.Create("DComboBox")

	if x and y then
		ComboBox:SetParent(parent)
		ComboBox:SetPos(x, y)
	end

	if x == "static" then
		ComboBox.StaticScale = {
			w = w,
			fixed_h = h,
			minw = 50,
			minh = h
		}
	else
		ComboBox:SetSize(w, h)
	end

	ComboBox:SetValue(val)
	ComboBox:SetFont("MSDFont.22")
	ComboBox.alpha = 0
	ComboBox.disabled = false
	ComboBox:SetTextColor(MSD.Text["s"])

	ComboBox.Paint = function(self, wd, hd)
		if ( self:IsMenuOpen() or self.pressed ) and not self.disabled then
			self.alpha = Lerp(FrameTime() * 5, self.alpha, 255)
		else
			self.alpha = Lerp(FrameTime() * 5, self.alpha, 0)
		end

		draw.RoundedBox(MSD.Config.Rounded, 0, 0, wd, hd, MSD.Theme["l"])
		draw.RoundedBox(0, MSD.Config.Rounded, hd - 1, wd - MSD.Config.Rounded * 2, 1, MSD.ColorAlpha(self.disabled and MSD.Text["n"] or MSD.Text["s"], 255 - self.alpha))
		draw.RoundedBox(0, MSD.Config.Rounded, hd - 1, wd - MSD.Config.Rounded * 2, 1, MSD.ColorAlpha(MSD.Config.MainColor["p"], self.alpha))
		draw.SimpleText(self:GetText(), "MSDFont.22", 3, hd / 2 - 10, self.disabled and MSD.Text["n"] or MSD.Text["d"], TEXT_ALIGN_LEFT)

		if label and not self.error then
			draw.SimpleText(label, "MSDFont.16", 3, 0, MSD.ColorAlpha(MSD.Text["d"], 120), TEXT_ALIGN_LEFT)
		end

		return true
	end

	ComboBox.OnCursorEntered = function(self)
		self.pressed = true
	end

	ComboBox.OnCursorExited = function(self)
		self.pressed = false
	end

	function ComboBox:OpenMenu(pControlOpener)
		if (pControlOpener and pControlOpener == self.TextEntry) then return end
		if (self.disabled) then return end
		if (#self.Choices == 0) then return end

		if (IsValid(self.Menu)) then
			self.Menu:Remove()
			self.Menu = nil
		end

		self.Menu = MSD.MenuOpen(false, self)

		for k, v in pairs(self.Choices) do
			self.Menu:AddOption(v, function()
				self:ChooseOption(v, k)
			end)
		end

		local mx, my = self:LocalToScreen(0, self:GetTall())
		self.Menu:SetMinimumWidth(self:GetWide())
		self.Menu:Open(mx, my, false, self)
	end

	if not x or not y then
		parent:AddItem(ComboBox)
	end

	return ComboBox
end

function MSD.BigButton(parent, x, y, w, h, text, icon, func, color, text2, func2, text3, func3)
	local button = vgui.Create("DButton")
	button:SetText("")

	if x and y then
		button:SetParent(parent)
		button:SetPos(x, y)
	end

	if x == "static" then
		button.StaticScale = {
			w = w,
			fixed_h = h,
			minw = 50,
			minh = h
		}
	else
		button:SetSize(w, h)
	end

	button.alpha = 0
	button.color_idle = color_white

	button.Paint = function(self, wd, hd)
		if self.hover and not self.disable then
			self.alpha = Lerp(FrameTime() * 5, self.alpha, 1)
		else
			self.alpha = Lerp(FrameTime() * 5, self.alpha, 0)
		end

		draw.RoundedBox(MSD.Config.Rounded, 0, 0, wd, hd, MSD.Theme["d"])

		if func3 then func3(self, wd, hd) end

		MSD.DrawTexturedRect(wd / 2 - 24, hd / 2 - 36, 48, 48, icon, MSD.ColorAlpha(self.color_idle, 255 - self.alpha * 255))
		draw.DrawText(text, "MSDFont.25", wd / 2, hd / 2 + 10, MSD.ColorAlpha(self.color_idle, 255 - self.alpha * 255), TEXT_ALIGN_CENTER)

		if self.alpha > 0.01 then
			MSD.DrawTexturedRect(wd / 2 - 24, hd / 2 - 36, 48, 48, icon, MSD.ColorAlpha(color or MSD.Config.MainColor["p"], self.alpha * 255))
			draw.DrawText(text, "MSDFont.25", wd / 2, hd / 2 + 10, MSD.ColorAlpha(color or MSD.Config.MainColor["p"], self.alpha * 255), TEXT_ALIGN_CENTER)
		end

		if text2 then
			draw.DrawText("id: " .. text2, "MSDFont.20", 10, 10, MSD.Text.d, TEXT_ALIGN_LEFT)
		end

		if text3 then
			draw.DrawText(text3, "MSDFont.20", wd / 2, hd - 20, MSD.Text.n, TEXT_ALIGN_CENTER)
		end
	end

	button.OnCursorEntered = function(self)
		self.hover = true
	end

	button.OnCursorExited = function(self)
		self.hover = false
	end

	button.DoClick = function(self)
		if self.disable then return end
		func(self)
	end

	button.DoRightClick = function(self)
		if self.disable or not func2 then return end
		func2(self)
	end

	if not x or not y then
		parent:AddItem(button)
	end

	return button
end

function MSD.ColorSelector(parent, x, y, w, h, text, color, func, alpha_chl)
	color = table.Copy(color)
	local button = vgui.Create("DButton")
	button:SetText(text)

	if x and y then
		button:SetParent(parent)
		button:SetPos(x, y)
	end

	if x == "static" then
		button.StaticScale = {
			w = w,
			fixed_h = h,
			minw = 50,
			minh = h
		}
	else
		button:SetSize(w, h)
	end
	button.alpha = 0
	button.color = color
	button.Paint = function(self, sw, sh)
		draw.RoundedBox(MSD.Config.Rounded, 0, 0, sw, sh, MSD.Theme["l"])

		if (self.hover or self.hovered) and not self.disabled then
			self.alpha = Lerp(FrameTime() * 5, self.alpha, 1)
		else
			self.alpha = Lerp(FrameTime() * 5, self.alpha, 0)
		end

		draw.DrawText(self:GetText(), "MSDFont.22", 5, h / 2 - 11, MSD.ColorAlpha(MSD.Config.MainColor["p"], self.alpha * 255), TEXT_ALIGN_LEFT)
		draw.DrawText(self:GetText(), "MSDFont.22", 5, h / 2 - 11, MSD.ColorAlpha(self.disabled and MSD.Text["n"] or MSD.Text["s"], 255 - self.alpha * 255), TEXT_ALIGN_LEFT)

		if not self.disabled then draw.RoundedBox(MSD.Config.Rounded, sw - sw / 8, 0, sw / 8, h-1, button.color) end

		return true
	end
	button.OnCursorEntered = function(self)
		self.hover = true
	end
	button.OnCursorExited = function(self)
		self.hover = false
	end
	button.DoClick = function(self)

		if self.rebuild or self.disabled then return end

		self.rebuild = true

		if IsValid(self.cpanel) then
			self.cpanel:Remove()
			self.cpanel = nil
			self:SizeTo(self:GetWide(), h, 0.2, 0, -1, function()
				button.StaticScale = {
					w = w,
					fixed_h = h,
					minw = 50,
					minh = h
				}
				parent:Rebuild()
				self.rebuild = nil
			end)
			return
		end

		local UpdateColors, SetColors
		button.StaticScale = {
			w = w,
			fixed_h = h + 200,
			minw = 50,
			minh = h + 200
		}
		parent:Rebuild()
		self:SetSize(self:GetWide(), h)
		self:SizeTo(self:GetWide(), h + 200, 0.2, 0, -1, function()
			self.rebuild = nil
		end)

		self.cpanel = vgui.Create("DPanel", self)
		self.cpanel:SetSize(self:GetWide(), 200)
		self.cpanel:SetPos(0, h)
		self.cpanel.Paint = function() end

		self.red = MSD.TextEntry(self.cpanel, 235, 5, 50, 60, "", MSD.GetPhrase("red"), 0, function(sp, value)
			value = tonumber(value) or 0
			local col = math.Clamp(value,0,255)
			self.color = Color(col, self.color.g, self.color.b)
			SetColors(self.color, {[sp] = true})
		end, true, nil, false, true)

		self.green = MSD.TextEntry(self.cpanel, 235, 70, 50, 60, "", MSD.GetPhrase("green"), 0, function(sp, value)
			value = tonumber(value) or 0
			local col = math.Clamp(value,0,255)
			self.color = Color(self.color.r, col, self.color.b)
			SetColors(self.color, {[sp] = true})
		end, true, nil, false, true)

		self.blue = MSD.TextEntry(self.cpanel, 235, 135, 50, 60, "", MSD.GetPhrase("blue"), 0, function(sp, value)
			value = tonumber(value) or 0
			local col = math.Clamp(value,0,255)
			self.color = Color(self.color.r, self.color.g, col)
			SetColors(self.color, {[sp] = true})
		end, true, nil, false, true)

		self.HSV = vgui.Create("DColorCube", self.cpanel)
		self.HSV:SetPos(alpha_chl and 55 or 40, 5)
		self.HSV:SetSize(alpha_chl and 175 or 190, 190)
		self.HSV:SetColor(self.color)
		self.HSV.OnUserChanged = function(pn, col)
			SetColors(col, {[pn] = true, [self.RGB] = true})
		end

		if alpha_chl then
			self.AlphaBar = vgui.Create( "DAlphaBar", self.cpanel)
			self.AlphaBar:SetPos( 30, 5 )
			self.AlphaBar:SetSize( 20, 190 )
			self.AlphaBar:SetValue( button.color.a / 255 )
			self.AlphaBar.OnChange = function(pn, al)
				button.color.a = al * 255
				UpdateColors(button.color)
			end
		end

		self.RGB = vgui.Create("DRGBPicker", self.cpanel)
		self.RGB:SetPos(5, 5)
		self.RGB:SetSize(alpha_chl and 20 or 30, 190)
		self.RGB.OnChange = function(pn, col)
			local oc = ColorToHSV(col)
			local _, s, v = ColorToHSV(self.HSV:GetRGB())
			col = HSVToColor(oc, s, v)
			self.HSV:SetColor(col)
			SetColors(col, {[pn] = true, [self.HSV] = true})
		end

		local rwd_set = vgui.Create("MSDPanelList", self.cpanel)
		rwd_set:SetSize(self.cpanel:GetWide() - 290, self.cpanel:GetTall() - 10)
		rwd_set:SetPos(290, 5)
		rwd_set:EnableVerticalScrollbar()
		rwd_set:EnableHorizontal(true)
		rwd_set:SetSpacing(1)
		rwd_set:SetPadding(1)
		rwd_set.IgnoreVbar = true

		for _, cl in pairs(MSD.ColorPresets) do
			MSD.ColorSelectBut(rwd_set, "static", nil, 8, 25, cl, function()
				SetColors(cl, {})
			end)
		end

		function UpdateColors(col)
			button.color = col
			func(self, col)
		end

		function SetColors(col, ignore)
			local sh = ColorToHSV( col )
			if not ignore[self.RGB] then self.RGB.LastY = ( 1 - sh / 360 ) * self.RGB:GetTall() end
			if not ignore[self.HSV] then self.HSV:SetColor( col ) end
			if not ignore[self.red] then self.red:SetText(col.r) end
			if not ignore[self.green] then self.green:SetText(col.g) end
			if not ignore[self.blue] then self.blue:SetText(col.b) end
			if self.AlphaBar and not ignore[self.AlphaBar] then self.AlphaBar:SetValue( col.a / 255 ) end
			UpdateColors(col)
		end

		SetColors(self.color, {})
	end

	if not x or not y then
		parent:AddItem(button)
	end

	return button
end

function MSD.VectorSelectorList(parent, text, vector, showa, angle, texta, copy_but, func)
	local vecd, amgl
	vecd = MSD.VectorDisplay(parent, "static", nil, 1, 50, text, vector, function(vec)
		func(vec, showa and amgl.angle)
	end)
	if showa then
		amgl = MSD.AngleDisplay(parent, "static", nil, 1, 50, texta, angle, function(ang)
			func(vecd.vector, ang)
		end)
	end

	if copy_but then
		MSD.Button(parent, "static", nil, 3, 50, MSD.GetPhrase("set_pos_self"), function()
			local vec = LocalPlayer():GetPos() vecd.vector = vec
			if showa then local ang = Angle(0, LocalPlayer():GetAngles().y, 0) amgl.angle = ang end
			func(vecd.vector, showa and amgl.angle)
		end)

		MSD.Button(parent, "static", nil, 3, 50, MSD.GetPhrase("set_pos_aim"), function()
			local vec = LocalPlayer():GetEyeTrace().HitPos
			if not vec then return end
			vecd.vector = vec
			if showa then local ang = Angle(0, LocalPlayer():GetAngles().y, 0) amgl.angle = ang end
			func(vecd.vector, showa and amgl.angle)
		end)

		MSD.Button(parent, "static", nil, 3, 50, MSD.GetPhrase("copy_from_ent"), function()
			local vec = LocalPlayer():GetEyeTrace().Entity
			if not vec then return end
			vecd.vector = vec:GetPos()
			if showa then local ang = vec:GetAngles() amgl.angle = ang end
			func(vecd.vector, showa and amgl.angle)
		end)
	end

end

function MSD.NPCModelFrame(parent, x, y, w, h, model, anim)
	if not model then
		model = "models/Humans/Group01/Male_01.mdl"
	end

	if ScrH() > 1000 then
		modelsize = 500
	end

	local icon = vgui.Create("DModelPanel")

	if x and y then
		icon:SetParent(parent)
		icon:SetPos(x, y)
	end

	if x == "static" then
		icon.StaticScale = {
			w = w,
			fixed_h = h,
			minw = 50,
			minh = h
		}
	else
		icon:SetSize(w, h)
	end

	icon:SetFOV(20)
	icon:SetCamPos(Vector(0, 0, 0))
	icon:SetDirectionalLight(BOX_RIGHT, Color(255, 160, 80, 255))
	icon:SetDirectionalLight(BOX_LEFT, Color(80, 160, 255, 255))
	icon:SetAmbientLight(Vector(-64, -64, -64))
	icon:SetAnimated(true)
	icon.Angles = Angle(0, 0, 0)
	icon:SetLookAt(Vector(-100, 0, -22))
	icon:SetModel(model)
	icon.Entity:ResetSequence(anim or 1)
	icon.Entity:SetPos(Vector(-100, 0, -61))
	function icon:DragMousePress()
		self.PressX, self.PressY = gui.MousePos()
		self.Pressed = true
	end
	function icon:DoDoubleClick()
		if icon:GetFOV() < 10 then
			icon:SetFOV(50)
		else
			icon:SetFOV(icon:GetFOV() - 5)
		end
	end
	function icon:DragMouseRelease()
		self.Pressed = false
	end
	function icon:LayoutEntity(ent)
		if (self.bAnimated) then
			self:RunAnimation()
		end

		if (self.Pressed) then
			local mx = gui.MousePos()
			self.Angles = self.Angles - Angle(0, (self.PressX or mx) - mx, 0)
			self.PressX, self.PressY = gui.MousePos()
		end

		ent:SetAngles(self.Angles)
	end

	function icon:UpdateModelValue(value)
		if value == "" then return end
		icon:SetModel(value)

		if icon.Entity then
			icon.Entity:ResetSequence("idle")
			icon.Entity:SetPos(Vector(-100, 0, -61))
		end
	end

	if not x or not y then
		parent:AddItem(icon)
	end

	return icon
end

function MSD.BigModelButton(parent, x, y, wd, hd, text, icon, func, text2, tr, color, func2)
	local pnl = vgui.Create("DPanel")
	if x and y then
		pnl:SetParent(parent)
		pnl:SetPos(x, y)
	end
	if x == "static" then
		pnl.StaticScale = { w = wd, fixed_h = hd, minw = 150, minh = hd }
	else
		pnl:SetSize(wd, hd)
	end
	pnl.Paint = function()
		if not IsValid(pnl.Icon.Entity) then return end
		local ent_color = pnl.Icon:GetColor()
		ent_color.a = pnl:GetAlpha()
	end
	pnl.SetCustomModel = function(mdl)
		pnl.Icon:SetModel( mdl )
		pnl.Iconmdl = mdl
		local mn, mx = pnl.Icon.Entity:GetRenderBounds()
		local size = 0
		size = math.max(size, math.abs(mn.x) + math.abs(mx.x))
		size = math.max(size, math.abs(mn.y) + math.abs(mx.y))
		size = math.max(size, math.abs(mn.z) + math.abs(mx.z))
		pnl.Icon:SetFOV(90 - size)
		pnl.Icon:SetCamPos(Vector(size, size + 5, 23))
		pnl.Icon:SetLookAt((mn + mx) * 0.95)
	end

	pnl.Icon = vgui.Create("DModelPanel", pnl)
	pnl.Icon:SetModel("")
	pnl.Icon:SetMouseInputEnabled(false)
	function pnl.Icon:LayoutEntity(Entity)
		return
	end

	local button = vgui.Create("DButton", pnl)
	button:SetText("")
	button.alpha = 0
	button.color_idle = color_white
	button.text = text
	button.Paint = function(self, w, h)
		if self.hover and not self.disable then
			self.alpha = Lerp(FrameTime() * 7, self.alpha, 1)
		else
			self.alpha = Lerp(FrameTime() * 7, self.alpha, 0)
		end
		local mida = pnl.Iconmdl and not tr
		draw.RoundedBox(0, 0, 0, w, h, MSD.Theme["d"])

		if not pnl.Iconmdl then
			MSD.DrawTexturedRect(w / 2 - 24, h / 2 - 36, 48, 48, icon, MSD.ColorAlpha(self.color_idle, 255 - self.alpha * 255))
		else
			draw.RoundedBox(0, 0, 0, w * self.alpha, h, MSD.Theme["l"])
		end
		draw.DrawText(button.text, "MSDFont.25", w / 2, mida and h / 2 - 12 or h - 30, MSD.ColorAlpha(self.color_idle, 255 - self.alpha * 255), mida and TEXT_ALIGN_LEFT or TEXT_ALIGN_CENTER)
		if text2 then draw.DrawText(text2, "MSDFont.21", w / 2, h / 2 + 12 , self.color_idle, TEXT_ALIGN_LEFT) end

		if self.alpha > 0.01 then
			if not pnl.Iconmdl then MSD.DrawTexturedRect(w / 2 - 24, h / 2 - 36, 48, 48, icon, MSD.ColorAlpha(color or MSD.Config.MainColor["p"], self.alpha * 255)) end
			draw.DrawText(button.text, "MSDFont.25", w / 2, mida and h / 2 - 12 or h - 30, MSD.ColorAlpha(color or MSD.Config.MainColor["p"], self.alpha * 255), mida and TEXT_ALIGN_LEFT or TEXT_ALIGN_CENTER)
		end
	end
	button.OnCursorEntered = function(self) self.hover = true end
	button.OnCursorExited = function(self) self.hover = false end
	button.DoClick = function(self) if self.disable then return end func(self) end
	button.DoRightClick = function(self) if self.disable or not func2 then return end func2(self) end
	pnl.button = button
	function pnl:PerformLayout()
		self.button:StretchToParent( 0, 0, 0, 0 )
		local mida = pnl.Iconmdl and not tr
		if not mida then
			self.Icon:StretchToParent( 5, 5, 5, 5 )
		else
			self.Icon:StretchToParent( 5, 5, self:GetWide() / 2, 5 )
		end
	end
	if not x or not y then parent:AddItem(pnl) end
	return pnl
end
--PATH addons/[ui] msd_ui/lua/msd/ui/msdcontext.lua:
local ScrW, ScrH = ScrW, ScrH
local Ln = MSD.GetPhrase
local logo = Material("msd/macnco.png", "smooth")
CreateClientConVar("mmd_lastscr", 0, true, false)

function MSD.AdminAccess(ply)
	if MQS then
		return MQS.IsEditor(ply)
	end
	if MRS then
		return MRS.IsAdministrator(ply)
	end
	return ply:IsSuperAdmin()
end

function MSD.OpenMenuManager(parrent, mod_open)
	if not MSD.AdminAccess(LocalPlayer()) then return end

	if IsValid(MSD.SetupMenu) then
		if not MSD.SetupMenu:IsVisible() then
			MSD.SetupMenu:AlphaTo(255, 0.4)
			MSD.SetupMenu:Show()
			MSD.SetupMenu:Center()
			return
		end
		if parrent then
			MSD.SetupMenu:Center()
			return
		else
			MSD.SetupMenu:Close()
		end
	end

	local pnl_w, pnl_h = ScrW(), ScrH()
	pnl_w, pnl_h = pnl_w - pnl_w / 4, pnl_h - pnl_h / 6
	local panel, setbut

	if parrent then
		panel = parrent:Add("MSDSimpleFrame")
	else
		panel = vgui.Create("MSDSimpleFrame")
		panel:MakePopup()
	end

	panel:SetSize(pnl_w, pnl_h)
	panel:Center()
	panel:SetAlpha(0)
	panel:AlphaTo(255, 0.3)

	panel.Paint = function(self, w, h)
		MSD.DrawBG(self, w, h)

		draw.RoundedBox(MSD.Config.Rounded, 0, 0, w, 50, MSD.Theme["d"])
		draw.RoundedBox(MSD.Config.Rounded, 0, 52, w, h - 52, MSD.Theme["l"])
	end

	panel.clsBut = MSD.IconButton(panel, MSD.Icons48.cross, panel:GetWide() - 34, 10, 25, nil, MSD.Config.MainColor.p, function()
		if panel.OnPress then
			panel.OnPress()

			return
		end

		panel:AlphaTo(0, 0.4, 0, function()
			panel:Close()
		end)
	end)

	function panel:OnClose()
		if panel.ModuleSwitch then panel.ModuleSwitch() panel.ModuleSwitch = nil end
		MSD.SetupMenu = nil
	end

	if not parrent then
		panel.clsHide = MSD.IconButton(panel, MSD.Icons48.dot, panel:GetWide() - 64, 10, 25, nil, MSD.Config.MainColor.p, function()
			if panel.OnPress then
				panel.OnPress()

				return
			end

			panel:AlphaTo(0, .4, 0, function()
				MSD.SetupMenu:Hide()
			end)
		end)
	end

	panel.Menu = vgui.Create("MSDPanelList", panel)
	panel.Menu:SetSize(panel:GetWide() / 2, 50)
	panel.Menu:SetPos(0, 0)
	--panel.Menu:EnableVerticalScrollbar()
	panel.Menu:EnableHorizontal(true)
	panel.Menu:SetSpacing(2)
	panel.Menu.IgnoreVbar = true
	panel.Menu.Paint = function() end
	panel.Menu.Deselect = function(but)
		if not but then return end
		but.hovered = true

		for k, v in pairs(panel.Menu:GetItems()) do
			if v and v:IsValid() and v ~= but then
				v.hovered = false
			end
		end
	end

	function panel.ReOpenCanvas()
		if IsValid(panel.Canvas) then panel.Canvas:Remove() end
		panel.Canvas = vgui.Create("DPanel", panel)
		panel.Canvas:SetSize(panel:GetWide(), panel:GetTall() - 52)
		panel.Canvas:SetPos(0, 52)
		panel.Canvas.Paint = function() end
	end

	local cnv = GetConVar("mmd_lastscr")

	function panel.OpenSettings()
		cnv:SetInt(-1)
		panel.ReOpenCanvas()
		panel.Menu.Deselect(setbut)
		MSD.OpenSettingsMenu(panel.Canvas, panel)
	end

	for id, mod in ipairs(MSD.Modules) do
		local button = MSD.MenuButtonTop(panel.Menu, mod.icon, nil, nil, "auto", 50, mod.name, function(self)
			if panel.ModuleSwitch then panel.ModuleSwitch() panel.ModuleSwitch = nil end
			cnv:SetInt(id)
			panel.ReOpenCanvas()
			panel.Menu.Deselect(self)
			mod.menu(panel.Canvas, panel)
		end)

		if (mod_open and id == mod_open) or (cnv:GetInt() == 0 and id == 1) or cnv:GetInt() == id then
			panel.ReOpenCanvas()
			panel.Menu.Deselect(button)
			mod.menu(panel.Canvas, panel)
		end
	end

	setbut = MSD.MenuButtonTop(panel.Menu, MSD.Icons48.cog, nil, nil, "auto", 50, "", function(self)
		panel.OpenSettings()
	end)

	if cnv:GetInt() == -1 and not mod_open then
		panel.OpenSettings()
	end

	MSD.SetupMenu = panel

	return panel
end

function MSD.OpenSettingsMenu(panel)

	oldcfg = MSD.Config

	panel.Canvas = vgui.Create("MSDPanelList", panel)
	panel.Canvas:SetSize(panel:GetWide() / 2 - 5, panel:GetTall())
	panel.Canvas:SetPos(panel:GetWide() / 2 + 5, 0)
	panel.Canvas:EnableVerticalScrollbar()
	panel.Canvas:EnableHorizontal(true)
	panel.Canvas:SetSpacing(2)
	panel.Canvas.IgnoreVbar = true
	panel.Canvas.Paint = function() end

	panel.Settings = vgui.Create("MSDPanelList", panel)
	panel.Settings:SetSize(panel:GetWide() / 2, panel:GetTall())
	panel.Settings:SetPos(0, 0)
	panel.Settings:EnableVerticalScrollbar()
	panel.Settings:EnableHorizontal(true)
	panel.Settings:SetSpacing(2)
	panel.Settings.IgnoreVbar = true
	panel.Settings.Paint = function() end

	panel.Settings.Update = function()
		panel.Settings:Clear()

		MSD.Header(panel.Settings, Ln("set_ui"))
		local combo = MSD.ComboBox(panel.Settings, "static", nil, 1, 50, "Language:", Ln("none"))

		combo.OnSelect = function(self, index, text, data)
			MSD.Config.Language = data
			panel.Settings.Update()
		end

		for k, v in pairs(MSD.Language) do
			combo:AddChoice(v.lang_name, k)
		end

		combo:SetValue(Ln("lang_name"))
		local sld1

		local function sliderCL(cl)
			local c = math.Clamp(math.Round(cl * 255), 30, 250)
			MSD.Config.BgrColor = Color(c, c, c)
		end

		MSD.DTextSlider(panel.Settings, "static", nil, 1, 50, Ln("set_ui_blur"), Ln("set_ui_mono"), MSD.Config.Blur, function(self, value)
			MSD.Config.Blur = value
			if value then
				sld1.value = 1
				sliderCL(sld1.value)
			else
				sld1.value = 0.18
				sliderCL(sld1.value)
			end
		end)

		sld1 = MSD.VolumeSlider(panel.Settings, "static", nil, 1, 50, Ln("set_ui_brightness"), MSD.Config.BgrColor.r / 255, function(self, var)
			sliderCL(var)
		end)

		MSD.ColorSelector(panel.Settings, "static", nil, 1, 50, Ln("set_ui_color"), MSD.Config.MainColor.p, function(self, color)
			MSD.Config.MainColor.p = color
		end)

		MSD.DTextSlider(panel.Settings, "static", nil, 1, 50, Ln("border_rounded"), Ln("border_square"), MSD.Config.Rounded == 8, function(self, value)
			if value then
				MSD.Config.Rounded = 8
			else
				MSD.Config.Rounded = 0
			end
		end)

		if LocalPlayer():IsSuperAdmin() then
			MSD.BigButton(panel.Settings, "static", nil, 2, 80, Ln("upl_changes"), MSD.Icons48.save, function()
				MSD.SaveConfig()
				panel.Settings.Update()
			end)

			MSD.BigButton(panel.Settings, "static", nil, 2, 80, Ln("res_changes"), MSD.Icons48.cross, function()
				MSD.Config = oldcfg
				panel.Settings.Update()
			end)
		end
	end

	panel.Settings.Update()

	local pnl = vgui.Create("DPanel")

	pnl.StaticScale = {
		w = 1,
		h = 1,
		minw = 150,
		minh = 150
	}

	pnl.Paint = function(self, w, h)
		MSD.DrawTexturedRect(w / 2 - 128, h / 2 - 128, 256, 236, logo, MSD.Text["l"])
		draw.DrawText("MSD UI version - " .. MSD.Version, "MSDFont.25", w / 2, h / 2 + 130, MSD.Text["l"], TEXT_ALIGN_CENTER)
	end

	panel.Canvas:AddItem(pnl)
end
--PATH lua/autorun/mvp_phands_clones2.lua:
return gluapack()()
--PATH lua/mvp/core/logger/sh_logger.lua:
mvp = mvp or {}
mvp.logger = mvp.logger or {}

mvp.logger.list = {}
mvp.logger.isReady = mvp.logger.isReady or false

function mvp.logger.Register(logger)
    if (not logger.isLogger) then
        error("Logger must be a logger!")
    end

    local success = pcall(function()
        logger:Init()
    end)

    if (not success) then
        error("Logger failed to initialize!")
    end

    mvp.logger.list[#mvp.logger.list + 1] = logger

    mvp.logger.isReady = true

    return logger
end

function mvp.logger.Log(level, caller, ...)
    if (not isnumber(level)) then
        level = mvp.LOG[level] or mvp.LOG.INFO
    end

    local args = {...}

    for _, logger in ipairs(mvp.logger.list) do
        pcall(function()
            logger:Log(level, caller, unpack(args))
        end)
        
        if (level == mvp.LOG.ERROR) then
            pcall(function()
                local trace = mvp.utils.GetTrace()

                logger:Log(mvp.LOG.DEBUG, caller, trace)
            end)
        end
    end
end
--PATH lua/mvp/thirdparty/cl_spoly.lua:
--[[
MIT License

Copyright (c) 2023 Aleksandrs Filipovskis

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
--]]


local STATUS_IDLE = 0
local STATUS_BUSY = 1

spoly = spoly or {}
spoly.materials = spoly.materials or {}
spoly.queue = spoly.queue or {}
spoly.status = STATUS_IDLE

local spoly = spoly
local materials = spoly.materials
local queue = spoly.queue
local queued = {}

local SIZE = 2048
-- MATERIAL_RT_DEPTH_SEPARATE makes stencils possible to work
local RT = GetRenderTargetEx ('onyx_spoly_rt', SIZE, SIZE, 0, MATERIAL_RT_DEPTH_SEPARATE, bit.band(16, 1024), 0, IMAGE_FORMAT_DEFAULT)
local CAPTURE_DATA = {
    x = 0,
    y = 0,
    w = SIZE,
    h = SIZE,
    format = 'png',
    alpha = true
}

file.CreateDir('spoly')

do
    local colorTag = Color(92, 192, 254)
    local colorError = Color(254, 92, 92)
    local tag = '[SPoly] '

    function spoly.Print(text, ...)
        MsgC(colorTag, tag, color_white, string.format(text, ...), '\n')
    end

    function spoly.PrintError(text, ...)
        MsgC(colorTag, tag, colorError, '[ERROR] ', color_white, string.format(text, ...), '\n')
    end
end

--[[------------------------------
Either render.PushFilterMin and render.PushFilterMag don't work with materials created with Lua
Idk what shader parameter is missing, I couldn't find it even by comparing materials' KeyValues
--------------------------------]]
function spoly.Render(id, funcDraw)
    local path = 'spoly/' .. id .. '.png'
    local start = SysTime()

    spoly.status = STATUS_BUSY

    render.PushRenderTarget(RT)
    
        render.Clear(0, 0, 0, 0)
        
        cam.Start2D()
            surface.SetDrawColor(color_white)
            draw.NoTexture()
            local success, errorText = pcall(funcDraw, SIZE, SIZE)
        cam.End2D()

        local content = render.Capture(CAPTURE_DATA)

        file.Delete(path)
        file.Write(path, content)
    
    render.PopRenderTarget()

    materials[id] = Material('data/' .. path, 'mips')

    spoly.status = STATUS_IDLE

    local endtime = SysTime()
    local delta = tostring(math.Round(endtime - start, 3))

    if (not success) then
        spoly.PrintError('Failed to render \'%s\', error text: %s', id, errorText)
    else
        spoly.Print('Rendered \'%s\' in %ss', id, delta)
    end

    return function(x, y, w, h, color)
        spoly.Draw(id, x, y, w, h, color)
    end
end

function spoly.Generate(id, funcDraw)
    assert(isstring(id), Format('bad argument #1 to \'spoly.Generate\' (expected string, got %s)', type(id)))
    assert(isfunction(funcDraw), Format('bad argument #2 to \'spoly.Generate\' (expected function, got %s)', type(funcDraw)))
    
    if (materials[id]) then return end
    if (queued[id]) then return end

    local path = 'spoly/' .. id .. '.png'
    if (file.Exists(path, 'DATA')) then
        materials[id] = Material('data/' .. path, 'mips smooth')
        return
    end

    queued[id] = true

    table.insert(queue, {
        id = id,
        funcDraw = funcDraw
    })
end

do
    local thinkRate = 1 / 10
    local nextThink = 0
    hook.Add('Think', 'spoly.QueueController', function()
        if (spoly.status == STATUS_IDLE and queue[1] and nextThink <= CurTime()) then
            nextThink = CurTime() + thinkRate
    
            local data = table.remove(queue, 1)
    
            spoly.Render(data.id, data.funcDraw)
        end
    end)
end

do
    local SetDrawColor = surface.SetDrawColor
    local SetMaterial = surface.SetMaterial
    local DrawTexturedRect = surface.DrawTexturedRect
    local DrawTexturedRectRotated = surface.DrawTexturedRectRotated

    local PushFilterMag = render.PushFilterMag
    local PushFilterMin = render.PushFilterMin
    local PopFilterMag = render.PopFilterMag
    local PopFilterMin = render.PopFilterMin

    -- calling this really often so trying to optimize as much as possible
    function spoly.Draw(id, x, y, w, h, color)
        local material = materials[id]
        if (not material) then return end
    
        if (color) then
            SetDrawColor(color)
        end
    
        SetMaterial(material)
        
        -- PushFilterMag(TEXFILTER.ANISOTROPIC)
        -- PushFilterMin(TEXFILTER.ANISOTROPIC)
    
        DrawTexturedRect(x, y, w, h)
    
        -- PopFilterMag()
        -- PopFilterMin()
    end

    function spoly.DrawRotated(id, x, y, w, h, rotation, color)
        local material = materials[id]
        if (not material) then return end
    
        if (color) then
            SetDrawColor(color)
        end
    
        SetMaterial(material)
        
        -- PushFilterMag(TEXFILTER.ANISOTROPIC)
        -- PushFilterMin(TEXFILTER.ANISOTROPIC)
    
        DrawTexturedRectRotated(x, y, w, h, rotation)
    
        -- PopFilterMag()
        -- PopFilterMin()
    end
end
--PATH lua/mvp/thirdparty/cl_threegrid.lua:
return gluapack()()
--PATH lua/mvp/thirdparty/sh_cami.lua:
--[[
CAMI - Common Admin Mod Interface.
Copyright 2020 CAMI Contributors

Makes admin mods intercompatible and provides an abstract privilege interface
for third party addons.

Follows the specification on this page:
https://github.com/glua/CAMI/blob/master/README.md

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
]]

-- Version number in YearMonthDay format.
local version = 20211019

if CAMI and CAMI.Version >= version then return end

CAMI = CAMI or {}
CAMI.Version = version


--- @class CAMI_USERGROUP
--- defines the charactaristics of a usergroup
--- @field Name string @The name of the usergroup
--- @field Inherits string @The name of the usergroup this usergroup inherits from
--- @field CAMI_Source string @The source specified by the admin mod which registered this usergroup (if any, converted to a string)

--- @class CAMI_PRIVILEGE
--- defines the charactaristics of a privilege
--- @field Name string @The name of the privilege
--- @field MinAccess "'user'" | "'admin'" | "'superadmin'" @Default group that should have this privilege
--- @field Description string | nil @Optional text describing the purpose of the privilege
local CAMI_PRIVILEGE = {}
--- Optional function to check if a player has access to this privilege
--- (and optionally execute it on another player)
---
---  **Warning**: This function may not be called by all admin mods
--- @param actor GPlayer @The player
--- @param target GPlayer | nil @Optional - the target
--- @return boolean @If they can or not
--- @return string | nil @Optional reason
function CAMI_PRIVILEGE:HasAccess(actor, target)
end

--- Contains the registered CAMI_USERGROUP usergroup structures.
--- Indexed by usergroup name.
--- @type CAMI_USERGROUP[]
local usergroups = CAMI.GetUsergroups and CAMI.GetUsergroups() or {
    user = {
        Name = "user",
        Inherits = "user",
        CAMI_Source = "Garry's Mod",
    },
    admin = {
        Name = "admin",
        Inherits = "user",
        CAMI_Source = "Garry's Mod",
    },
    superadmin = {
        Name = "superadmin",
        Inherits = "admin",
        CAMI_Source = "Garry's Mod",
    }
}

--- Contains the registered CAMI_PRIVILEGE privilege structures.
--- Indexed by privilege name.
--- @type CAMI_PRIVILEGE[]
local privileges = CAMI.GetPrivileges and CAMI.GetPrivileges() or {}

--- Registers a usergroup with CAMI.
---
--- Use the source parameter to make sure CAMI.RegisterUsergroup function and
--- the CAMI.OnUsergroupRegistered hook don't cause an infinite loop
--- @param usergroup CAMI_USERGROUP @The structure for the usergroup you want to register
--- @param source any @Identifier for your own admin mod. Can be anything.
--- @return CAMI_USERGROUP @The usergroup given as an argument
function CAMI.RegisterUsergroup(usergroup, source)
    if source then
        usergroup.CAMI_Source = tostring(source)
    end
    usergroups[usergroup.Name] = usergroup

    hook.Call("CAMI.OnUsergroupRegistered", nil, usergroup, source)
    return usergroup
end

--- Unregisters a usergroup from CAMI. This will call a hook that will notify
--- all other admin mods of the removal.
---
---  **Warning**: Call only when the usergroup is to be permanently removed.
---
--- Use the source parameter to make sure CAMI.UnregisterUsergroup function and
--- the CAMI.OnUsergroupUnregistered hook don't cause an infinite loop
--- @param usergroupName string @The name of the usergroup.
--- @param source any @Identifier for your own admin mod. Can be anything.
--- @return boolean @Whether the unregistering succeeded.
function CAMI.UnregisterUsergroup(usergroupName, source)
    if not usergroups[usergroupName] then return false end

    local usergroup = usergroups[usergroupName]
    usergroups[usergroupName] = nil

    hook.Call("CAMI.OnUsergroupUnregistered", nil, usergroup, source)

    return true
end

--- Retrieves all registered usergroups.
--- @return CAMI_USERGROUP[] @Usergroups indexed by their names.
function CAMI.GetUsergroups()
    return usergroups
end

--- Receives information about a usergroup.
--- @param usergroupName string
--- @return CAMI_USERGROUP | nil @Returns nil when the usergroup does not exist.
function CAMI.GetUsergroup(usergroupName)
    return usergroups[usergroupName]
end

--- Checks to see if potentialAncestor is an ancestor of usergroupName.
--- All usergroups are ancestors of themselves.
---
--- Examples:
--- * `user` is an ancestor of `admin` and also `superadmin`
--- * `admin` is an ancestor of `superadmin`, but not `user`
--- @param usergroupName string @The usergroup to query
--- @param potentialAncestor string @The ancestor to query
--- @return boolean @Whether usergroupName inherits potentialAncestor.
function CAMI.UsergroupInherits(usergroupName, potentialAncestor)
    repeat
        if usergroupName == potentialAncestor then return true end

        usergroupName = usergroups[usergroupName] and
                         usergroups[usergroupName].Inherits or
                         usergroupName
    until not usergroups[usergroupName] or
          usergroups[usergroupName].Inherits == usergroupName

    -- One can only be sure the usergroup inherits from user if the
    -- usergroup isn't registered.
    return usergroupName == potentialAncestor or potentialAncestor == "user"
end

--- Find the base group a usergroup inherits from.
---
--- This function traverses down the inheritence chain, so for example if you have
--- `user` -> `group1` -> `group2`
--- this function will return `user` if you pass it `group2`.
---
---  **NOTE**: All usergroups must eventually inherit either user, admin or superadmin.
--- @param usergroupName string @The name of the usergroup
--- @return "'user'" | "'admin'" | "'superadmin'" @The name of the root usergroup
function CAMI.InheritanceRoot(usergroupName)
    if not usergroups[usergroupName] then return end

    local inherits = usergroups[usergroupName].Inherits
    while inherits ~= usergroups[usergroupName].Inherits do
        usergroupName = usergroups[usergroupName].Inherits
    end

    return usergroupName
end

--- Registers an addon privilege with CAMI.
---
---  **Warning**: This should only be used by addons. Admin mods must *NOT*
---  register their privileges using this function.
--- @param privilege CAMI_PRIVILEGE
--- @return CAMI_PRIVILEGE @The privilege given as argument.
function CAMI.RegisterPrivilege(privilege)
    privileges[privilege.Name] = privilege

    hook.Call("CAMI.OnPrivilegeRegistered", nil, privilege)

    return privilege
end

--- Unregisters a privilege from CAMI.
--- This will call a hook that will notify any admin mods of the removal.
---
---  **Warning**: Call only when the privilege is to be permanently removed.
--- @param privilegeName string @The name of the privilege.
--- @return boolean @Whether the unregistering succeeded.
function CAMI.UnregisterPrivilege(privilegeName)
    if not privileges[privilegeName] then return false end

    local privilege = privileges[privilegeName]
    privileges[privilegeName] = nil

    hook.Call("CAMI.OnPrivilegeUnregistered", nil, privilege)

    return true
end

--- Retrieves all registered privileges.
--- @return CAMI_PRIVILEGE[] @All privileges indexed by their names.
function CAMI.GetPrivileges()
    return privileges
end

--- Receives information about a privilege.
--- @param privilegeName string
--- @return CAMI_PRIVILEGE | nil
function CAMI.GetPrivilege(privilegeName)
    return privileges[privilegeName]
end

-- Default access handler
local defaultAccessHandler = {["CAMI.PlayerHasAccess"] =
    function(_, actorPly, privilegeName, callback, targetPly, extraInfoTbl)
        -- The server always has access in the fallback
        if not IsValid(actorPly) then return callback(true, "Fallback.") end

        local priv = privileges[privilegeName]

        local fallback = extraInfoTbl and (
            not extraInfoTbl.Fallback and actorPly:IsAdmin() or
            extraInfoTbl.Fallback == "user" and true or
            extraInfoTbl.Fallback == "admin" and actorPly:IsAdmin() or
            extraInfoTbl.Fallback == "superadmin" and actorPly:IsSuperAdmin())


        if not priv then return callback(fallback, "Fallback.") end

        local hasAccess =
            priv.MinAccess == "user" or
            priv.MinAccess == "admin" and actorPly:IsAdmin() or
            priv.MinAccess == "superadmin" and actorPly:IsSuperAdmin()

        if hasAccess and priv.HasAccess then
            hasAccess = priv:HasAccess(actorPly, targetPly)
        end

        callback(hasAccess, "Fallback.")
    end,
    ["CAMI.SteamIDHasAccess"] =
    function(_, _, _, callback)
        callback(false, "No information available.")
    end
}

--- @class CAMI_ACCESS_EXTRA_INFO
--- @field Fallback "'user'" | "'admin'" | "'superadmin'" @Fallback status for if the privilege doesn't exist. Defaults to `admin`.
--- @field IgnoreImmunity boolean @Ignore any immunity mechanisms an admin mod might have.
--- @field CommandArguments table @Extra arguments that were given to the privilege command.

--- Checks if a player has access to a privilege
--- (and optionally can execute it on targetPly)
---
--- This function is designed to be asynchronous but will be invoked
---  synchronously if no callback is passed.
---
---  **Warning**: If the currently installed admin mod does not support
---                 synchronous queries, this function will throw an error!
--- @param actorPly GPlayer @The player to query
--- @param privilegeName string @The privilege to query
--- @param callback fun(hasAccess: boolean, reason: string|nil) @Callback to receive the answer, or nil for synchronous
--- @param targetPly GPlayer | nil @Optional - target for if the privilege effects another player (eg kick/ban)
--- @param extraInfoTbl CAMI_ACCESS_EXTRA_INFO | nil @Table of extra information for the admin mod
--- @return boolean | nil @Synchronous only - if the player has the privilege
--- @return string | nil @Synchronous only - optional reason from admin mod
function CAMI.PlayerHasAccess(actorPly, privilegeName, callback, targetPly,
extraInfoTbl)
    local hasAccess, reason = nil, nil
    local callback_ = callback or function(hA, r) hasAccess, reason = hA, r end

    hook.Call("CAMI.PlayerHasAccess", defaultAccessHandler, actorPly,
        privilegeName, callback_, targetPly, extraInfoTbl)

    if callback ~= nil then return end

    if hasAccess == nil then
        local err = [[The function CAMI.PlayerHasAccess was used to find out
        whether Player %s has privilege "%s", but an admin mod did not give an
        immediate answer!]]
        error(string.format(err,
            actorPly:IsPlayer() and actorPly:Nick() or tostring(actorPly),
            privilegeName))
    end

    return hasAccess, reason
end

--- Get all the players on the server with a certain privilege
--- (and optionally who can execute it on targetPly)
---
---  **NOTE**: This is an asynchronous function!
--- @param privilegeName string @The privilege to query
--- @param callback fun(players: GPlayer[]) @Callback to receive the answer
--- @param targetPly GPlayer | nil @Optional - target for if the privilege effects another player (eg kick/ban)
--- @param extraInfoTbl CAMI_ACCESS_EXTRA_INFO | nil @Table of extra information for the admin mod
function CAMI.GetPlayersWithAccess(privilegeName, callback, targetPly,
extraInfoTbl)
    local allowedPlys = {}
    local allPlys = player.GetAll()
    local countdown = #allPlys

    local function onResult(ply, hasAccess, _)
        countdown = countdown - 1

        if hasAccess then table.insert(allowedPlys, ply) end
        if countdown == 0 then callback(allowedPlys) end
    end

    for _, ply in ipairs(allPlys) do
        CAMI.PlayerHasAccess(ply, privilegeName,
            function(...) onResult(ply, ...) end,
            targetPly, extraInfoTbl)
    end
end

--- @class CAMI_STEAM_ACCESS_EXTRA_INFO
--- @field IgnoreImmunity boolean @Ignore any immunity mechanisms an admin mod might have.
--- @field CommandArguments table @Extra arguments that were given to the privilege command.

--- Checks if a (potentially offline) SteamID has access to a privilege
--- (and optionally if they can execute it on a target SteamID)
---
---  **NOTE**: This is an asynchronous function!
--- @param actorSteam string | nil @The SteamID to query
--- @param privilegeName string @The privilege to query
--- @param callback fun(hasAccess: boolean, reason: string|nil) @Callback to receive  the answer
--- @param targetSteam string | nil @Optional - target SteamID for if the privilege effects another player (eg kick/ban)
--- @param extraInfoTbl CAMI_STEAM_ACCESS_EXTRA_INFO | nil @Table of extra information for the admin mod
function CAMI.SteamIDHasAccess(actorSteam, privilegeName, callback,
targetSteam, extraInfoTbl)
    hook.Call("CAMI.SteamIDHasAccess", defaultAccessHandler, actorSteam,
        privilegeName, callback, targetSteam, extraInfoTbl)
end

--- Signify that your admin mod has changed the usergroup of a player. This
--- function communicates to other admin mods what it thinks the usergroup
--- of a player should be.
---
--- Listen to the hook to receive the usergroup changes of other admin mods.
--- @param ply GPlayer @The player for which the usergroup is changed
--- @param old string @The previous usergroup of the player.
--- @param new string @The new usergroup of the player.
--- @param source any @Identifier for your own admin mod. Can be anything.
function CAMI.SignalUserGroupChanged(ply, old, new, source)
    hook.Call("CAMI.PlayerUsergroupChanged", nil, ply, old, new, source)
end

--- Signify that your admin mod has changed the usergroup of a disconnected
--- player. This communicates to other admin mods what it thinks the usergroup
--- of a player should be.
---
--- Listen to the hook to receive the usergroup changes of other admin mods.
--- @param steamId string @The steam ID of the player for which the usergroup is changed
--- @param old string @The previous usergroup of the player.
--- @param new string @The new usergroup of the player.
--- @param source any @Identifier for your own admin mod. Can be anything.
function CAMI.SignalSteamIDUserGroupChanged(steamId, old, new, source)
    hook.Call("CAMI.SteamIDUsergroupChanged", nil, steamId, old, new, source)
end
--PATH lua/mvp/core/ui/cl_animations.lua:
return gluapack()()
--PATH lua/mvp/core/ui/cl_scale.lua:
return gluapack()()
--PATH lua/mvp/core/notification/cl_notification.lua:
return gluapack()()
--PATH lua/mvp/core/notification/cl_notification.lua:
mvp = mvp or {}
mvp.notification = mvp.notification or {}

mvp.notification.list = mvp.notification.list or {}
mvp.notification.currentNotification = mvp.notification.currentNotification or nil

local spacing = mvp.ui.Scale(15)
local roundness = mvp.ui.ScaleWithFactor(16)
local iconSize = mvp.ui.Scale(50)

local POSITION_MAP = {
    ["tl"] = function(sx, sy)
        return 0 + spacing, 0 + spacing, -sx, -sy
    end,
    ["tc"] = function(sx, sy)
        return ScrW() * .5 - sx * .5, 0 + spacing, ScrW() * .5 - sx * .5, -sy
    end,
    ["tr"] = function(sx, sy)
        return ScrW() - sx - spacing, 0 + spacing, ScrW(), -sy
    end,
    ["cl"] = function(sx, sy)
        return 0 + spacing, ScrH() * .5 - sy * .5, -sx, ScrH() * .5 - sy * .5
    end,
    ["cc"] = function(sx, sy)
        return ScrW() * .5 - sx * .5, ScrH() * .5 + sy, ScrW() * .5 - sx * .5, ScrH() 
    end,
    ["cr"] = function(sx, sy)
        return ScrW() - sx - spacing, ScrH() * .5 - sy * .5, ScrW(), ScrH() * .5 - sy * .5
    end,
    ["bl"] = function(sx, sy)
        return 0 + spacing, ScrH() - sy - spacing, -sx - spacing, ScrH()
    end,
    ["bc"] = function(sx, sy)
        return ScrW() * .5 - sx * .5, ScrH() - sy - spacing, ScrW() * .5 - sx * .5, ScrH()
    end,
    ["br"] = function(sx, sy)
        return ScrW() - sx - spacing, ScrH() - sy - spacing, ScrW(), ScrH()
    end
}
local TYPE_MAP = {
    [mvp.NOTIFICATION.INFO] = {
        color = mvp.colors.Blue,
        icon = Material("mvp/terminal/notifications/info.png", "smooth")
    },
    [mvp.NOTIFICATION.WARN] = {
        color = mvp.colors.Yellow,
        icon = Material("mvp/terminal/notifications/warn.png", "smooth")
    },
    [mvp.NOTIFICATION.ERROR] = {
        color = mvp.colors.Red,
        icon = Material("mvp/terminal/notifications/error.png", "smooth")
    },
    
    [mvp.NOTIFICATION.SUCCESS] = {
        color = mvp.colors.Green,
        icon = Material("mvp/terminal/notifications/success.png", "smooth")
    },
    [mvp.NOTIFICATION.FAIL] = {
        color = mvp.colors.Red,
        icon = Material("mvp/terminal/notifications/error.png", "smooth")
    }
}

function mvp.notification.ProccesQueue()
    local inQueue = #mvp.notification.list

    if (inQueue == 0) then
        return -- No notifications to show
    end

    if (inQueue == 1) then
        mvp.notification.currentNotification = mvp.notification.list[1]
        mvp.notification.currentNotification:Show()
    else
        if (IsValid(mvp.notification.currentNotification)) then
            return -- We are already showing a notification
        end

        mvp.notification.currentNotification = mvp.notification.list[1]
        mvp.notification.currentNotification:Show()
    end
end

function mvp.notification.Add( notificationType, title, text, duration )
    local useNotifications = mvp.config.Get("useNotifications", true)

    if (isstring(notificationType)) then
        notificationType = TYPE_MAP[notificationType]
    end
    local notificationData = TYPE_MAP[notificationType]
    local color = notificationData.color
    local icon = notificationData.icon

    if (not useNotifications) then
        local tag = mvp.config.Get("tag", "[Terminal]")

        return chat.AddText(mvp.colors.Accent, tag, " ", color, title, " ", mvp.colors.Text, text)
    end

    duration = duration or 5

    local notificationPosition = mvp.config.Get("notificationsPosition", "bc")
    local position = POSITION_MAP[notificationPosition]

    local notificationPanel = vgui.Create("DPanel")
    local sizeX, sizeY = mvp.ui.Scale(450), mvp.ui.Scale(100)

    surface.SetFont(mvp.q.Font(26, 600))
    local titleWidth, _ = surface.GetTextSize(title)
    titleWidth = titleWidth + iconSize + spacing * 3
    
    surface.SetFont(mvp.q.Font(21, 600))
    local textWidth, _ = surface.GetTextSize(text)
    textWidth = textWidth + iconSize + spacing * 3

    sizeX = math.max(titleWidth, textWidth, sizeX)
    
    notificationPanel:SetSize(sizeX, sizeY)

    local x, y, sx, sy = position(sizeX, sizeY)
    notificationPanel:SetPos(sx, sy)
    
    function notificationPanel:Paint(w, h)
        draw.RoundedBox(roundness, 0, 0, w, h, mvp.colors.Background)
        
        if (self.startTime) then
            local timePassed = CurTime() - self.startTime
            local progress = w * (timePassed / duration)

            draw.RoundedBox(roundness, 0, 0, progress, h, ColorAlpha(color, 5))
        end

        surface.SetDrawColor(color)
        surface.SetMaterial(icon)
        surface.DrawTexturedRect(spacing, h * .5 - iconSize * .5, iconSize, iconSize)

        draw.SimpleText(title, mvp.q.Font(26, 600), spacing + iconSize + spacing, h * .5 - 10, mvp.colors.Text, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
        draw.SimpleText(text, mvp.q.Font(21, 400), spacing + iconSize + spacing, h * .5 + 10, mvp.colors.Text, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
    end
    function notificationPanel:Show()
        self:MoveTo(x, y, 0.5, 0, 0.5, function(_, pnl)
            pnl.startTime = CurTime()
            self:MoveTo(sx, sy, 0.5, duration or 1, 0.5, function(_, pnl)
                pnl:Remove()
                table.remove(mvp.notification.list, 1)
                mvp.notification.ProccesQueue()
            end)
        end)
    end

    table.insert(mvp.notification.list, notificationPanel)
    mvp.notification.ProccesQueue()
end

net.Receive("mvp.notification", function()
    local type = net.ReadUInt(8)
    local title = net.ReadString()
    local text = net.ReadString()
    local duration = net.ReadUInt(8)

    mvp.notification.Add(type, title, text, duration)
end)
--PATH lua/mvp/core/sh_language.lua:
mvp = mvp or {}
mvp.language = mvp.language or {}

mvp.language.list = mvp.language.list or {}
mvp.language.codes = mvp.language.codes or {}

local LANGUAGE_DEFAULT_FALLBACK = "en"
local LANGUAGE_CODES_URL = ""

function mvp.language.Register(id, langTable)
    if (not mvp.language.list[id]) then
        mvp.language.list[id] = langTable

        mvp.q.LogInfo("Language", "Registered new language " .. id)

        return mvp.language.list[id]
    end

    local storedLanguage = mvp.language.list[id]

    for k, v in pairs(langTable) do
        storedLanguage[k] = v
    end

    mvp.language.list[id] = storedLanguage

    return mvp.language.list[id]
end

function mvp.language.Get(id)
    return mvp.language.list[id]
end

function mvp.language.GetPhrase(id, ...)
    local lang = mvp.language.list[mvp.config.Get("language", LANGUAGE_DEFAULT_FALLBACK)]
    local phrase = lang[id]

    if (not phrase) then        
        lang = mvp.language.list[LANGUAGE_DEFAULT_FALLBACK]
        phrase = lang[id]

        if not phrase then
            return "notfound#" .. id
        end

        mvp.q.LogDebug("Language", "Phrase " .. id .. " not found in " .. mvp.config.Get("language", LANGUAGE_DEFAULT_FALLBACK) .. " falling back to " .. LANGUAGE_DEFAULT_FALLBACK)
    end

    if (type(phrase) == "function") then
        return phrase(...)
    else
        -- replace {{lang:(.*)}} with the language phrase
        phrase = string.gsub(phrase, "{{lang:(.-)}}", function(match)
            return mvp.language.GetPhrase(match)
        end)
    end

    return string.format(phrase, ...)
end

function mvp.language.LoadFromFolder(path)
    mvp.loader.LoadFolder(path, false, true)
end

--[[
    Language codes
]]--
function mvp.language.FetchCodes()
    http.Fetch(LANGUAGE_CODES_URL, function(body)
        local data = util.JSONToTable(body)
        if not data then return end

        mvp.language.codes = data

        mvp.logger.Log(mvp.LOG.DEBUG, "Language", "Fetched language " .. table.Count(data) .. " codes")
    end)
end
function mvp.language.GetCode(id)
    return mvp.language.codes[id]
end
function mvp.language.GetCodes()
    return mvp.language.codes
end

function mvp.language.Init()
    -- mvp.language.FetchCodes()
    mvp.q.LogInfo("Language", "Loading languages...")

    mvp.language.LoadFromFolder("mvp/languages/")

    mvp.q.LogInfo("Language", "Loaded languages!")
end
--PATH lua/mvp/core/credits/sh_contributors.lua:
mvp = mvp or {}
mvp.credits = mvp.credits or {}

mvp.credits.contributorsList = {}

function mvp.credits.AddContributor(steamId, name, role)
    mvp.credits.contributorsList[#mvp.credits.contributorsList + 1] = {
        name = name, 
        role = role, 
        steamId = steamId
    }
end

function mvp.credits.GetContributors()
    return mvp.credits.contributorsList
end
--PATH lua/mvp/credits/sh_contributors.lua:
mvp = mvp or {}
mvp.credits = mvp.credits or {}

mvp.credits.AddContributor("76561198144964099", "Kot", "Founder of Multiverse, Developer")
mvp.credits.AddContributor("76561198105599682", "Ben_Bro", "Founder of Multiverse, Spiritual guide")

-- https://steamcommunity.com/profiles/76561198070574536
mvp.credits.AddContributor("76561198070574536", "Redwood", "Tester")
-- https://steamcommunity.com/profiles/76561198316204509
mvp.credits.AddContributor("76561198316204509", "DurtyStone", "Tester")
--PATH lua/mvp/credits/sh_icons.lua:
mvp = mvp or {}
mvp.credits = mvp.credits or {}

-- <a href="https://www.flaticon.com/free-icons/cross" title="cross icons">Cross icons created by Freepik - Flaticon</a>
mvp.credits.AddIcon(Material("mvp/terminal/close.png", "smooth mips"), "Cross", "Freepik - Flaticon", "https://www.flaticon.com/authors/freepik")
-- <a href="https://www.flaticon.com/free-icons/arrow" title="arrow icons">Arrow icons created by Freepik - Flaticon</a>
mvp.credits.AddIcon(Material("mvp/terminal/vgui/arrow.png", "smooth mips"), "Arrow", "Freepik - Flaticon", "https://www.flaticon.com/authors/freepik")
-- <a href="https://www.flaticon.com/free-icons/undo" title="undo icons">Undo icons created by Frey Wazza - Flaticon</a>
mvp.credits.AddIcon(Material("mvp/terminal/vgui/undo.png", "smooth mips"), "Undo", "Frey Wazza - Flaticon", "https://www.flaticon.com/authors/frey-wazza")
-- <a href="https://www.flaticon.com/free-icons/link" title="link icons">Link icons created by Creaticca Creative Agency - Flaticon</a>
mvp.credits.AddIcon(Material("mvp/terminal/vgui/link.png", "smooth mips"), "Link", "Creaticca Creative Agency - Flaticon", "https://www.flaticon.com/authors/creaticca-creative-agency")
-- <a href="https://www.flaticon.com/free-icons/dashboard" title="dashboard icons">Dashboard icons created by Pixel perfect - Flaticon</a>
mvp.credits.AddIcon(Material("mvp/terminal/icons/dashboard.png", "smooth mips"), "Dashboard", "Pixel perfect - Flaticon", "https://www.flaticon.com/authors/pixel-perfect")
-- <a href="https://www.flaticon.com/free-icons/cog" title="cog icons">Cog icons created by Freepik - Flaticon</a>
mvp.credits.AddIcon(Material("mvp/terminal/icons/settings.png", "smooth mips"), "Cog", "Freepik - Flaticon", "https://www.flaticon.com/authors/freepik")
-- <a href="https://www.flaticon.com/free-icons/extensible-markup-language" title="extensible markup language icons">Extensible markup language icons created by Freepik - Flaticon</a>
mvp.credits.AddIcon(Material("mvp/terminal/icons/language.png", "smooth mips"), "Extensible markup language", "Freepik - Flaticon", "https://www.flaticon.com/authors/freepik")
-- <a href="https://www.flaticon.com/free-icons/feedback" title="feedback icons">Feedback icons created by Freepik - Flaticon</a>
mvp.credits.AddIcon(Material("mvp/terminal/icons/feedback.png", "smooth mips"), "Feedback", "Freepik - Flaticon", "https://www.flaticon.com/authors/freepik")
-- <a href="https://www.flaticon.com/free-icons/copyright" title="copyright icons">Copyright icons created by Those Icons - Flaticon</a>
mvp.credits.AddIcon(Material("mvp/terminal/icons/credits.png", "smooth mips"), "Copyright", "Those Icons - Flaticon", "https://www.flaticon.com/authors/those-icons")
-- <a href="https://www.flaticon.com/free-icons/right" title="right icons">Right icons created by Pixel perfect - Flaticon</a>
mvp.credits.AddIcon(Material("mvp/terminal/icons/check.png", "smooth mips"), "Check", "Pixel perfect - Flaticon", "https://www.flaticon.com/authors/pixel-perfect")
-- <div> Icons made by <a href="https://www.flaticon.com/authors/hight-quality-icons" title="Hight Quality Icons"> Hight Quality Icons </a> from <a href="https://www.flaticon.com/" title="Flaticon">www.flaticon.com'</a></div>
mvp.credits.AddIcon(Material("mvp/terminal/icons/steam.png", "smooth mips"), "Steam", "Hight Quality Icons - Flaticon", "https://www.flaticon.com/authors/hight-quality-icons")
-- <div> Icons made by <a href="https://www.flaticon.com/authors/pixel-perfect" title="Pixel perfect"> Pixel perfect </a> from <a href="https://www.flaticon.com/" title="Flaticon">www.flaticon.com'</a></div>
mvp.credits.AddIcon(Material("mvp/terminal/icons/github.png", "smooth mips"), "Github", "Pixel perfect - Flaticon", "https://www.flaticon.com/authors/pixel-perfect")
-- <div> Icons made by <a href="https://www.flaticon.com/authors/pixel-perfect" title="Pixel perfect"> Pixel perfect </a> from <a href="https://www.flaticon.com/" title="Flaticon">www.flaticon.com'</a></div>
mvp.credits.AddIcon(Material("mvp/terminal/icons/store.png", "smooth mips"), "Store", "Pixel perfect - Flaticon", "https://www.flaticon.com/authors/pixel-perfect")
-- <div> Icons made by <a href="https://www.freepik.com" title="Freepik"> Freepik </a> from <a href="https://www.flaticon.com/" title="Flaticon">www.flaticon.com'</a></div>
mvp.credits.AddIcon(Material("mvp/terminal/icons/permissions.png", "smooth mips"), "Key", "Freepik - Flaticon", "https://www.flaticon.com/authors/freepik")
-- <div> Icons made by <a href="https://www.freepik.com" title="Freepik"> Freepik </a> from <a href="https://www.flaticon.com/" title="Flaticon">www.flaticon.com'</a></div>
mvp.credits.AddIcon(Material("mvp/terminal/icons/warning.png", "smooth mips"), "Warning", "Freepik - Flaticon", "https://www.flaticon.com/authors/freepik")
-- <a href="https://www.flaticon.com/free-icons/packaging" title="packaging icons">Packaging icons created by sonnycandra - Flaticon</a>
mvp.credits.AddIcon(Material("mvp/terminal/icons/package.png", "smooth mips"), "Package", "sonnycandra - Flaticon", "https://www.flaticon.com/authors/sonnycandra")
-- <a href="https://www.flaticon.com/free-icons/save" title="save icons">Save icons created by Yogi Aprelliyanto - Flaticon</a>
mvp.credits.AddIcon(Material("mvp/terminal/icons/save.png", "smooth mips"), "Save", "Yogi Aprelliyanto - Flaticon", "https://www.flaticon.com/authors/yogi-aprelliyanto")


-- <div> Icons made by <a href="https://www.flaticon.com/authors/freepik" title="Freepik"> Freepik </a> from <a href="https://www.flaticon.com/" title="Flaticon">www.flaticon.com'</a></div>
-- Success

-- <div> Icons made by <a href="https://www.flaticon.com/authors/freepik" title="Freepik"> Freepik </a> from <a href="https://www.flaticon.com/" title="Flaticon">www.flaticon.com'</a></div>
-- Warn

-- <div> Icons made by <a href="https://www.flaticon.com/authors/freepik" title="Freepik"> Freepik </a> from <a href="https://www.flaticon.com/" title="Flaticon">www.flaticon.com'</a></div>
-- Error

-- <a href="https://www.flaticon.com/free-icons/info" title="info icons">Info icons created by Freepik - Flaticon</a>
-- info
--PATH lua/mvp/core/package/sh_package.meta.lua:
--- @classmod mvp.meta.package

mvp = mvp or {}
mvp.meta = mvp.meta or {}

mvp.meta.package = {}

mvp.meta.package.__proto = mvp.meta.package

mvp.meta.package.__proto.isPackage = true
mvp.meta.package.__proto.isLoaded = false

function mvp.meta.package:New()
    local o = table.Copy(self.__proto)

    setmetatable(o, self)
    o.__index = self

    local cwd = debug.getinfo(2, "S").short_src

    -- addons/mvp_terminal/lua/mvp/packages/{{cwd}}/sh_package.lua
    -- lua/mvp/packages/{{cwd}}/sh_package.lua

    -- match the package folder
    local packageFolder = string.match(cwd, "mvp/packages/([^/]+)/sh_package%.lua")
    o:SetCWD(packageFolder)
    o:SetID(packageFolder)

    if (mvp.config.Get("debug")) then
        for i = 1, 5 do
            local info = debug.getinfo(i, "S")
            if (info) then
                print(i, info.short_src, info.linedefined, info.name)
            end
        end
    end

    return o
end

--[[
    Getters and Setters for simple package information
]]--  
AccessorFunc(mvp.meta.package, "_id", "ID", FORCE_STRING)

mvp.meta.package.__proto._name = "Unnamed Package"
AccessorFunc(mvp.meta.package, "_name", "Name", FORCE_STRING)

mvp.meta.package.__proto._description = "Missing description"
AccessorFunc(mvp.meta.package, "_description", "Description", FORCE_STRING)

mvp.meta.package.__proto._author = "Unknown"
AccessorFunc(mvp.meta.package, "_author", "Author", FORCE_STRING)

mvp.meta.package.__proto._version = "0.0.0"
AccessorFunc(mvp.meta.package, "_version", "Version", FORCE_STRING)

mvp.meta.package.__proto._license = "Unknown"
AccessorFunc(mvp.meta.package, "_license", "License", FORCE_STRING)

mvp.meta.package.__proto._icon = nil
AccessorFunc(mvp.meta.package, "_icon", "Icon")

AccessorFunc(mvp.meta.package, "_cwd", "CWD", FORCE_STRING)

--[[
    Meta functions
]]--
function mvp.meta.package:__tostring()
    return string.format("Package %s (%s)", self:GetName(), self:GetID())
end

function mvp.meta.package:__eq(other)
    return self:GetID() == other:GetID()
end

--[[
    Dependencies
]]--
mvp.meta.package.__proto._dependencies = {}
function mvp.meta.package:AddDependency(id)
    self._dependencies = self._dependencies or {}
    
    self._dependencies[#self._dependencies + 1] = id
end
function mvp.meta.package:GetDependencies()
    return self._dependencies
end

--[[
    Package functions
]]--
mvp.meta.package.__proto._files = {}
function mvp.meta.package:AddFile(path)
    local cwd = "packages/" .. self:GetCWD()
    local fullPath = cwd .. "/" .. path

    self._files[#self._files + 1] = fullPath
end
function mvp.meta.package:AddFolder(path, recursive)
    local cwd = "packages/" .. self:GetCWD()
    local fullPath = cwd .. "/" .. path

    local files, folders = file.Find(mvp.loader.relativePath .. fullPath .. "/*", "LUA")

    for _, file in ipairs(files) do
        self:AddFile(path .. "/" .. file)
    end

    if (recursive) then
        for _, folder in ipairs(folders) do
            self:AddFolder(path .. "/" .. folder, true)
        end
    end
end

--[[
    Configuration functions
]]--
function mvp.meta.package:AddConfigsFolder(path)
    if (not path) then
        path = "configs"
    end

    if (string.StartsWith(path, "/")) then
        path = string.sub(path, 2)
    end

    self:AddFolder(path, true)
end
--PATH lua/mvp/packages/radialmenu/sh_package.lua:
local P = mvp.meta.package:New()

P:SetIcon(Material("mvp/radialmenu/package_icon.png", "smooth"))
P:SetName("Radial Menus")
P:SetVersion("1.0.2")
P:SetDescription("Enables developers to create radial menus for their needs.")
P:SetAuthor("Kot")

P:AddFolder("languages")
P:AddFolder("ui")
P:AddFile("cl_radialmenu.meta.lua")
P:AddFile("cl_credits.lua")

mvp.package.Register(P)
--PATH lua/mvp/packages/radialmenu/ui/cl_wheel.lua:
local P = mvp.package.Get()

-- Helper functions
local function drawCircle(x, y, r, step, cache)
    local positions = {}
    for i = 0, 360, step do
        table.insert(positions, {
            x = x + math.cos(math.rad(i)) * r,
            y = y + math.sin(math.rad(i)) * r
        })
    end
    return (cache and positions) or surface.DrawPoly(positions)
end
local function drawSubSection(cx, cy, radius, thickness, startang, endang, roughness, cache)
    local triarc = {}
    -- local deg2rad = math.pi / 180
    -- Define step
    local roughness = math.max(roughness or 1, 1)
    local step = roughness
    -- Correct start/end ang
    local startang, endang = startang or 0, endang or 0
    if startang > endang then step = math.abs(step) * -1 end
    -- Create the inner circle's points.
    local inner = {}
    local r = radius - thickness
    for deg = startang, endang, step do
        local rad = math.rad(deg)
        -- local rad = deg2rad * deg
        local ox, oy = cx + (math.cos(rad) * r), cy + (-math.sin(rad) * r)
        table.insert(inner, {
            x = ox,
            y = oy,
            u = (ox - cx) / radius + .5,
            v = (oy - cy) / radius + .5,
        })
    end

    -- Create the outer circle's points.
    local outer = {}
    for deg = startang, endang, step do
        local rad = math.rad(deg)
        -- local rad = deg2rad * deg
        local ox, oy = cx + (math.cos(rad) * radius), cy + (-math.sin(rad) * radius)
        table.insert(outer, {
            x = ox,
            y = oy,
            u = (ox - cx) / radius + .5,
            v = (oy - cy) / radius + .5,
        })
    end

    -- Triangulize the points.
    for tri = 1, #inner * 2 do -- twice as many triangles as there are degrees.
        local p1, p2, p3
        p1 = outer[math.floor(tri / 2) + 1]
        p3 = inner[math.floor((tri + 1) / 2) + 1]
        if tri % 2 == 0 then --if the number is even use outer.
            p2 = outer[math.floor((tri + 1) / 2)]
        else
            p2 = inner[math.floor((tri + 1) / 2)]
        end

        table.insert(triarc, {p1, p2, p3})
    end

    if cache then
        return triarc
    else
        for k, v in pairs(triarc) do
            surface.DrawPoly(v)
        end
    end
end
local w, h = ScrW, ScrH

local LMBIcon = Material("mvp/radialmenu/lmb.png", "mips smooth")
local RMBIcon = Material("mvp/radialmenu/rmb.png", "mips smooth")

function P.ShowRadialMenu(sections)
    if (not sections) or (#sections == 0) then 
        return mvp.q.LogError("Radial Menu", "Tried to create a radial menu with no sections")
    end

    local scale = h() / 900
    local calculated = 325 * scale
    local rad = calculated * 0.4

    local sectionSize = 360 / #sections

    local originW, originH = w() * .5, h() * .5

    if (IsValid(P.activeRadialMenu)) then
        P.activeRadialMenu:Remove()
    end

    local radialMenu = vgui.Create("DButton")
    radialMenu:SetSize(w(), h())
    radialMenu:SetPos(0, 0)
    radialMenu:MakePopup()
    radialMenu:SetCursor("hand")

    radialMenu.selectedArea = 0
    radialMenu.selectedText = ""

    function radialMenu:Think()
        if (sections[self.selectedArea + 1]) then 
            self.selectedOption = sections[self.selectedArea + 1]
        end

        self:CalculateIconsPosition()
    end

    function radialMenu:CalculateIconsPosition()
        self.icons = {}
        for k, v in pairs(sections) do
            local ang = (k - 1) * sectionSize
            local radians = math.rad(ang)

            local iconType = "icon"

            if (v._isModel) then
                iconType = "model"
            elseif (v._icon == nil or (type(v._icon) == "IMaterial" and v._icon:IsError())) then
                iconType = "text" 
            end

            local iconSize = 64 * scale -- assume "icon" size
            local iconSizeMult = 1
            local isSectionSelected = self.selectedArea and self.selectedArea == k - 1

            if (iconType == "model") then
                iconSize = 64 * scale
            elseif (iconType == "text") then
                iconSize = 64 * scale
            end

            if (isSectionSelected) then
                iconSizeMult = 1.2
            end

            local r = calculated - rad * .5
            local s, c = math.sin(radians) * r, math.cos(radians) * r
            local x, y = originW - iconSize * .5 + s, originH - iconSize * .5 - c

            self.icons[k] = {
                x = x,
                y = y,
                s = s,
                c = c,
                size = iconSize,
                sizeMult = iconSizeMult,
                entityLayoutFunc = v._entLayoutFunc,
                type = iconType
            }
        end
    end

    -- prepare panels for "model" icons
    radialMenu:CalculateIconsPosition()
    for k, v in pairs(radialMenu.icons) do
        if (v.type == "model") then
            local modelPanel = vgui.Create("DModelPanel", radialMenu)
            modelPanel:SetSize(v.size, v.size)
            modelPanel:SetPos(v.x, v.y)
            modelPanel:SetModel(sections[k]._icon)
            modelPanel:SetMouseInputEnabled(false)
            -- modelPanel:SetFOV(30)

            modelPanel.LayoutEntity = function(self, ent)
                if (self:GetParent().selectedArea == k - 1) then
                    ent:SetAngles(Angle(0, RealTime() * 100, 0))
                else
                    ent:SetAngles(Angle(0, 180, 0))
                end

                local headBone = ent:LookupBone("ValveBiped.Bip01_Head1")

                if (headBone) then
                    local headPos = ent:GetBonePosition(headBone)
                    modelPanel:SetCamPos(headPos - Vector(23, 23, 0))
                    modelPanel:SetLookAt(headPos - Vector(0, 0, 10))
                end

                if (v.entityLayoutFunc) then
                    v.entityLayoutFunc(ent)
                end
            end
        end
    end

    function radialMenu:DrawRadialMenu(w, h)
        local cursorAng = 360 - (math.deg(math.atan2(gui.MouseX() - originW, gui.MouseY() - originH)) + 180)
        local selectedArea = math.abs(cursorAng + sectionSize * .5) / sectionSize
        selectedArea = math.floor(selectedArea)

        if (selectedArea >= #sections) then
            selectedArea = 0
        end
        self.selectedArea = selectedArea

        self.cursorColor = mvp.utils.LerpColor(FrameTime() * 5, self.cursorColor or mvp.colors.Accent, self.selectedOption._color or mvp.colors.Accent)

        local selectedAng = selectedArea * sectionSize
        local outerArcScale = 4

        draw.NoTexture()

        surface.SetDrawColor(self.selectedOption._color or mvp.colors.Accent)
        drawSubSection(originW, originH, calculated + outerArcScale, outerArcScale, 90 - selectedAng - sectionSize * .5, 90 - selectedAng + sectionSize * .5, 1, false)

        surface.SetDrawColor(ColorAlpha(mvp.colors.Background, 60))
        drawSubSection(originW, originH, calculated, rad, 90 - selectedAng - sectionSize * .5, 90 - selectedAng + sectionSize * .5, 1, false)

        surface.SetDrawColor(ColorAlpha(mvp.colors.Background, 100))
        drawCircle(originW, originH, calculated - rad, 1, false)
        drawCircle(originW, originH, calculated, 1, false)

        for k, v in pairs(self.icons) do
            local iconType = v.type

            if (iconType == "model") then
                continue
            end
            local sectionDetails = sections[k]

            local x, y = v.x, v.y
            local iconSize = v.size
            local iconSizeMult = v.sizeMult

            draw.NoTexture()

            if (iconType == "icon") then
                surface.SetDrawColor(mvp.colors.Text)
                surface.SetMaterial(sectionDetails._icon)
                surface.DrawTexturedRect(x, y, iconSize, iconSize)
            else -- text
                local s, c = v.s, v.c
                draw.SimpleText(sectionDetails._name, mvp.q.Font(22 * iconSizeMult, 700), originW + s, originH - c, mvp.colors.Text, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
            end

            if (sectionDetails._overlayIcon) then
                surface.SetDrawColor(mvp.colors.Text)
                surface.SetMaterial(sectionDetails._overlayIcon)
                surface.DrawTexturedRect(x, y, iconSize * .75, iconSize * .75)
            end
        end

        draw.NoTexture()
        surface.SetDrawColor(self.cursorColor)

        local innerArcScale = 6
        drawSubSection(originW, originH, calculated - rad + innerArcScale * 2, innerArcScale, -cursorAng + 90 - sectionSize * .5, -cursorAng + 90 + sectionSize * .5, 1, false)
    end

    function radialMenu:Paint(w, h)
        self:DrawRadialMenu(w, h)

        if (not self.selectedOption) then
            draw.SimpleText(mvp.q.Lang("radialmenu.select_option"), mvp.q.Font(24, 700), originW, originH, mvp.colors.Text, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

            return true
        end

        local selectedOption = self.selectedOption
        local textOffset = 0

        local originW, originH = w * .5, h * .5 - 35

        if (not selectedOption._isModel and selectedOption._icon and not selectedOption._icon:IsError()) then
            local iconSize = 64 * scale * 1.5

            surface.SetDrawColor(mvp.colors.Text)
            surface.SetMaterial(selectedOption._icon)
            surface.DrawTexturedRect(originW - iconSize * .5, originH - iconSize * .5, iconSize, iconSize)

            textOffset = iconSize * .5 + 20
        end

        if (selectedOption._description) then
            textOffset = textOffset == 0 and 15 or textOffset
            draw.SimpleText(selectedOption._description, mvp.q.Font(24, 500), originW, originH + textOffset, mvp.colors.Text, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

        end

        draw.SimpleText(selectedOption._name, mvp.q.Font(32, 700), originW, originH - textOffset, mvp.colors.Text, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

        local mouseButtonIconSize = 32
        
        surface.SetDrawColor(mvp.colors.Text)
        surface.SetMaterial(LMBIcon)
        surface.DrawTexturedRect(originW - 50 - mouseButtonIconSize * .5, originH + 50 - mouseButtonIconSize * .5 + textOffset, mouseButtonIconSize, mouseButtonIconSize)

        draw.SimpleText(mvp.q.LangFallback("radialmenu.select", "Select"), mvp.q.Font(24, 600), originW - 50, originH + 50 + textOffset + mouseButtonIconSize, mvp.colors.Text, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

        surface.SetMaterial(RMBIcon)
        surface.DrawTexturedRect(originW + 50 - mouseButtonIconSize * .5, originH + 50 - mouseButtonIconSize * .5 + textOffset, mouseButtonIconSize, mouseButtonIconSize)

        draw.SimpleText(mvp.q.LangFallback("radialmenu.cancel", "Cancel"), mvp.q.Font(24, 600), originW + 50, originH + 50 + textOffset + mouseButtonIconSize, mvp.colors.Text, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

        return true
    end

    function radialMenu:DoClick()
        if (not self.selectedOption) then return end

        self.selectedOption:Click()
        self:Remove()
    end

    function radialMenu:DoRightClick()
        self:Remove()
    end

    P.activeRadialMenu = radialMenu
end
--PATH lua/mvp/packages/simpledefcons/sh_package.lua:
return gluapack()()
--PATH lua/mvp/packages/simpledefcons/manage/cl_manage.lua:
return gluapack()()
--PATH lua/mvp/packages/simpledefcons/manage/sh_manage.lua:
local P = mvp.package.Get()
P.manage = P.manage or {}

function P.manage.CheckPermissions(ply, defconId)
    local playerTeam = ply:Team()
    local teamsPermission = mvp.config.Get("simpledefcons.allowedJobs") or {}

    defconId = defconId or "menu"

    if (mvp.permissions.Check(ply, "mvp.simpledefcons.bypass")) then
        return true
    end

    local override = hook.Run("mvp.simpledefcons.CustomPermissions", ply, defconId)

    if (override ~= nil) then
        return override -- If the hook returns a value, use it
    end

    return teamsPermission[team.GetName(playerTeam)] or false
end
--PATH lua/mvp/gamemodes/nutscript.lua:
local gm = mvp.meta.gamemode:New()

gm:SetName("NutScript")
gm:SetDescription("Support for NutScript gamemode.")
gm:SetAuthor("Kot")
gm:SetVersion("1.0.0")
gm:SetLicense("MIT")

function gm:GetMoney(ply)
    return ply:getMoney() or 0
end

function gm:CanAfford(ply, sum)
    return ply:getChar():hasMoney(amount) 
end

function gm:AddMoney(ply, sum)
    return ply:getChar():giveMoney(amount)
end

function gm:TakeMoney(ply, sum)
    return ply:getChar():takeMoney(amount)
end

function gm:FormatMoney(ply, sum)
    return nut.currency.get(amount)
end

mvp.gamemode.Register(gm)
--PATH lua/mvp/vgui/button/cl_image_button.lua:
local PANEL = {}

DEFINE_BASECLASS("mvp.Button")

function PANEL:Init()
    self:SetText("")

    self.image = Material("error")
    
    self.colors = self.colors or {}
    self.colors.Icon = Color(187, 187, 187)
    self.colors.IconHover = Color(255, 255, 255)

    self.iconColor = self.colors.Icon

    self.iconSize = 16
end

function PANEL:SetImage(image)
    self.image = image
end

function PANEL:SetIconSize(size)
    self.iconSize = size
end

function PANEL:Paint(w, h)
    BaseClass.Paint(self, w, h)

    surface.SetDrawColor(self.iconColor)
    surface.SetMaterial(self.image)
    
    local iconSize = self.iconSize
    local iconX = (w - iconSize) / 2
    local iconY = (h - iconSize) / 2

    surface.DrawTexturedRect(iconX, iconY, iconSize, iconSize)
end

function PANEL:OnCursorEntered()
    BaseClass.OnCursorEntered(self)
    
    self:LerpColor("iconColor", self.colors.IconHover, .2)
end

function PANEL:OnCursorExited()
    BaseClass.OnCursorExited(self)
    
    self:LerpColor("iconColor", self.colors.Icon, .2)
end

function PANEL:PerformLayout(w, h)
    self.iconSize = h * .5
end

vgui.Register("mvp.ImageButton", PANEL, "mvp.Button")
--PATH lua/mvp/menus/admin/cl_settings.lua:
return gluapack()()
--PATH lua/ncs_shared/currencies/sh_currencies.lua:
return gluapack()()
--PATH lua/ncs_shared/currencies/currencies/sh_darkrp.lua:
return gluapack()()
--PATH lua/ncs_shared/currencies/currencies/sh_helix.lua:
return gluapack()()
--PATH lua/ncs_shared/currencies/currencies/sh_nmoney2.lua:
NCS_SHARED.RegisterCurrency("nmoney2", {
    addMoney = function(P, AMOUNT)
        AMOUNT = tonumber(AMOUNT)

        local MONEY = tonumber(P:GetNWString( "WalletMoney", "0" ))

        P:SetNWString( "WalletMoney", tostring((MONEY + AMOUNT)) )
    end,
    canAfford = function(P, AMOUNT)
        AMOUNT = tonumber(AMOUNT)

        local MONEY = P:GetNWString( "WalletMoney", "0" )

        return tonumber(MONEY) >= AMOUNT
    end,
    getMoney = function(P)
        return tonumber(P:GetNWString( "WalletMoney", "0" ))
    end,
    formatMoney = function(AMOUNT)
        AMOUNT = tonumber(AMOUNT)

        return string.Comma(AMOUNT)
    end,
})
--PATH lua/ncs_shared/vgui/cl_imgur.lua:
return gluapack()()
--PATH lua/effect/trail.bone_set.lua:
WeaponTrail.BoneSet = {}

function WeaponTrail:AddBone(data)
	WeaponTrail.BoneSet[data.Number] = data
end

local bone = {
	Number = 0,
	BoneName = "ValveBiped.Bip01_R_Hand",
	AddAngle = Angle(0,0,0),
	AngleType = 0, -- 0 = GetUp(), 1 = GetRight(), 2 = GetForward()
	Trail_Time = 0.1 -- Default 0.1 Longer this time, longer is the trajectory.
}
WeaponTrail:AddBone(bone)
local bone = {
	Number = 1,
	BoneName = "R_Weapon",
	AddAngle = Angle(0,0,0),
	AngleType = 0, -- 0 = GetUp(), 1 = GetRight(), 2 = GetForward()
	Trail_Time = 0.2 -- Default 0.1 Longer this time, longer is the trajectory.
}
WeaponTrail:AddBone(bone)
local bone = {
	Number = 2,
	BoneName = "R_Weapon001",
	AddAngle = Angle(0,0,0),
	AngleType = 0, -- 0 = GetUp(), 1 = GetRight(), 2 = GetForward()
	Trail_Time = 0.5 -- Default 0.1 Longer this time, longer is the trajectory.
}
WeaponTrail:AddBone(bone)
local bone = {
	Number = 3,
	BoneName = "R_Weapon",
	AddAngle = Angle(0,0,0),
	AngleType = 1, -- 0 = GetUp(), 1 = GetRight(), 2 = GetForward()
	Trail_Time = 0.2 -- Default 0.1 Longer this time, longer is the trajectory.
}
WeaponTrail:AddBone(bone)
local bone = {
	Number = 4,
	BoneName = "L_Weapon001",
	AddAngle = Angle(0,0,180),
	AngleType = 0, -- 0 = GetUp(), 1 = GetRight(), 2 = GetForward()
	Trail_Time = 0.5 -- Default 0.1 Longer this time, longer is the trajectory.
}
WeaponTrail:AddBone(bone)
local bone = {
	Number = 5,
	BoneName = "R_Weapon",
	AddAngle = Angle(180,0,0),
	AngleType = 2, -- 0 = GetUp(), 1 = GetRight(), 2 = GetForward()
	Trail_Time = 0.2 -- Default 0.1 Longer this time, longer is the trajectory.
}
WeaponTrail:AddBone(bone)
local bone = {
	Number = 6,
	BoneName = "R_Weapon",
	AddAngle = Angle(0,0,180),
	AngleType = 0, -- 0 = GetUp(), 1 = GetRight(), 2 = GetForward()
	Trail_Time = 0.2 -- Default 0.1 Longer this time, longer is the trajectory.
}
WeaponTrail:AddBone(bone)

--PATH lua/autorun/nyssa_addon.lua:
player_manager.AddValidModel( "Nyssa Delacor", "models/player/jedi/nyssa_delacor.mdl" );
list.Set( "PlayerOptionsModel",  "Nyssa Delacor", "models/player/jedi/nyssa_delacor.mdl" );


--PATH addons/[lib] onyx_framework_2/lua/onyx/util.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

05/06/2022

--]]

local zeroFn = function() end

onyx.ZeroFn = zeroFn
onyx.IncludeClient = CLIENT and include or AddCSLuaFile
onyx.IncludeServer = SERVER and include or zeroFn
onyx.IncludeShared = function(path)
    AddCSLuaFile(path)
    return include(path)
end

do
    local Explode = string.Explode
    local Left = string.Left
    onyx.Include = function(path)
        local parts = Explode('/', path)
        local prefix = Left(parts[#parts], 2)

        if prefix then
            if prefix == 'sv' then
                return onyx.IncludeServer(path)
            elseif prefix == 'cl' then
                return onyx.IncludeClient(path)
            elseif prefix == 'sh' then
                return onyx.IncludeShared(path)
            end
        end
    end
end

do
    local Find = file.Find
    local ipairs = ipairs
    local GetExtensionFromFilename = string.GetExtensionFromFilename

    local function IncludeFolder(path, recursive)
        local files, folders = Find(path .. '*', 'LUA')

        for _, name in ipairs(files) do
            if GetExtensionFromFilename(name) == 'lua' then
                onyx.Include(path .. name)
            end
        end

        if recursive then
            for _, name in ipairs(folders) do
                IncludeFolder(path .. name .. '/', recursive)
            end
        end
    end
    onyx.IncludeFolder = IncludeFolder
end

function onyx:Config(key)
    local tSequence = string.Explode('.', key)
    local iSequence = #tSequence
    local previousTbl = self.cfg

    for i = 1, iSequence do
        local keyPart = tSequence[i]
        if previousTbl[keyPart] then
            if i == iSequence then
                return previousTbl[keyPart]
            else
                previousTbl = previousTbl[keyPart]
            end
        end
    end

    return fallback
end

do
    local accent = Color(174, 0, 255)
    local white = color_white
    local red = Color(255, 73, 73)
    local green = Color(121, 255, 68)
    local orange = Color(255, 180, 68)
    local blue = Color(68, 149, 255)

    local function format(text, ...)
        for _, arg in ipairs({...}) do
            if isentity(arg) and arg:IsPlayer() then
                arg = arg:Name() .. " (" .. arg:SteamID() .. ")"
            else
                arg = tostring(arg)
            end
    
            text = string.gsub(text, "#", arg, 1)
        end
    
        return text
    end

    local function printWPrefix(color, prefix, text, ...)
        MsgC(
            white, '(', accent, 'ONYX', white, ') ',
            white, '(', color, prefix, white, ') ',
            format(text, ...),
            '\n'
        )
    end

    function onyx:Print(text, ...)
        MsgC(
            white, '(', accent, 'ONYX', white, ') ',
            format(text, ...),
            '\n'
        )
    end

    function onyx:PrintError(text, ...)
        printWPrefix(red, 'ERROR', text, ...)
    end

    function onyx:PrintWarning(text, ...)
        printWPrefix(orange, 'WARNING', text, ...)
    end

    function onyx:PrintSuccess(text, ...)
        printWPrefix(green, 'SUCCESS', text, ...)
    end
    
    do

        local cvDebug = CreateConVar('sh_onyx_debug', '0', FCVAR_REPLICATED)

        function onyx:PrintDebug(text, ...)
            if (cvDebug:GetBool()) then
                printWPrefix(blue, 'DEBUG', text, ...)
            end
        end
    end
end
--PATH addons/[lib] onyx_framework_2/lua/onyx/init.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

05/06/2022

--]]

local Run = hook.Run
local IncludeFolder = onyx.IncludeFolder

if (SERVER) then
    resource.AddWorkshop('852839002')
end

Run('PreOnyxLoad')

-- non recursive
IncludeFolder('onyx/framework/')
IncludeFolder('onyx/ui/')

-- init modules
do
    local Find = file.Find
    local path = 'onyx/modules/'
    local _, folders = Find(path .. '*', 'LUA')
    for _, name in ipairs(folders) do
        onyx.Include(path .. name .. '/sh_init.lua')
    end
end

Run('PostOnyxLoad')
--PATH addons/[lib] onyx_framework_2/lua/onyx/framework/libs/thirdparty/sh_pon.lua:
return gluapack()()
--PATH addons/[lib] onyx_framework_2/lua/onyx/framework/libs/thirdparty/data/utf8_chunk_4.lua:
return {[9425] = 9399,[9426] = 9400,[9427] = 9401,[9428] = 9402,[9429] = 9403,[9430] = 9404,[9431] = 9405,[9432] = 9406,[9433] = 9407,[9434] = 9408,[9435] = 9409,[9436] = 9410,[9437] = 9411,[9438] = 9412,[9439] = 9413,[9440] = 9414,[9441] = 9415,[9442] = 9416,[9443] = 9417,[9444] = 9418,[9445] = 9419,[9446] = 9420,[9447] = 9421,[9448] = 9422,[9449] = 9423,[11312] = 11264,[11313] = 11265,[11314] = 11266,[11315] = 11267,[11316] = 11268,[11317] = 11269,[11318] = 11270,[11319] = 11271,[11320] = 11272,[11321] = 11273,[11322] = 11274,[11323] = 11275,[11324] = 11276,[11325] = 11277,[11326] = 11278,[11327] = 11279,[11328] = 11280,[11329] = 11281,[11330] = 11282,[11331] = 11283,[11332] = 11284,[11333] = 11285,[11334] = 11286,[11335] = 11287,[11336] = 11288,[11337] = 11289,[11338] = 11290,[11339] = 11291,[11340] = 11292,[11341] = 11293,[11342] = 11294,[11343] = 11295,[11344] = 11296,[11345] = 11297,[11346] = 11298,[11347] = 11299,[11348] = 11300,[11349] = 11301,[11350] = 11302,[11351] = 11303,[11352] = 11304,[11353] = 11305,[11354] = 11306,[11355] = 11307,[11356] = 11308,[11357] = 11309,[11358] = 11310,[11361] = 11360,[11365] = 570,[11366] = 574,[11368] = 11367,[11370] = 11369,[11372] = 11371,[11382] = 11381,[11393] = 11392,[11395] = 11394,[11397] = 11396,[11399] = 11398,[11401] = 11400,[11403] = 11402,[11405] = 11404,[11407] = 11406,[11409] = 11408,[11411] = 11410,[11413] = 11412,[11415] = 11414,[11417] = 11416,[11419] = 11418,[11421] = 11420,[11423] = 11422,[11425] = 11424,[11427] = 11426,[11429] = 11428,[11431] = 11430,[11433] = 11432,[11435] = 11434,[11437] = 11436,[11439] = 11438,[11441] = 11440,[11443] = 11442,[11445] = 11444,[11447] = 11446,[11449] = 11448,[11451] = 11450,[11453] = 11452,[11455] = 11454,[11457] = 11456,[11459] = 11458,[11461] = 11460,[11463] = 11462,[11465] = 11464,[11467] = 11466,[11469] = 11468,[11471] = 11470,[11473] = 11472,[11475] = 11474,[11477] = 11476,[11479] = 11478,[11481] = 11480,[11483] = 11482,[11485] = 11484,[11487] = 11486,[11489] = 11488,[11491] = 11490,[11520] = 4256,[11521] = 4257,[11522] = 4258,[11523] = 4259,[11524] = 4260,[11525] = 4261,[11526] = 4262,[11527] = 4263,[11528] = 4264,[11529] = 4265,[11530] = 4266,[11531] = 4267,[11532] = 4268,[11533] = 4269,[11534] = 4270,[11535] = 4271,[11536] = 4272,[11537] = 4273,[11538] = 4274,[11539] = 4275,[11540] = 4276,[11541] = 4277,[11542] = 4278,[11543] = 4279,[11544] = 4280,[11545] = 4281,[11546] = 4282,[11547] = 4283,[11548] = 4284,[11549] = 4285,[11550] = 4286,[11551] = 4287,[11552] = 4288,[11553] = 4289,[11554] = 4290,[11555] = 4291,[11556] = 4292,[11557] = 4293,[65345] = 65313,[65346] = 65314,[65347] = 65315,[65348] = 65316,[65349] = 65317,[65350] = 65318,[65351] = 65319,[65352] = 65320,[65353] = 65321,[65354] = 65322,[65355] = 65323,[65356] = 65324,[65357] = 65325,[65358] = 65326,[65359] = 65327,[65360] = 65328,[65361] = 65329,[65362] = 65330,[65363] = 65331,[65364] = 65332,[65365] = 65333,[65366] = 65334,[65367] = 65335,[65368] = 65336,[65369] = 65337,[65370] = 65338,[66600] = 66560,[66601] = 66561,[66602] = 66562,[66603] = 66563,[66604] = 66564,[66605] = 66565,[66606] = 66566,[66607] = 66567,[66608] = 66568,[66609] = 66569,[66610] = 66570,[66611] = 66571,[66612] = 66572,[66613] = 66573,[66614] = 66574,[66615] = 66575,[66616] = 66576,[66617] = 66577,[66618] = 66578,[66619] = 66579,[66620] = 66580,[66621] = 66581,[66622] = 66582,[66623] = 66583,[66624] = 66584,[66625] = 66585,[66626] = 66586,[66627] = 66587,[66628] = 66588,[66629] = 66589,[66630] = 66590,[66631] = 66591,[66632] = 66592,[66633] = 66593,[66634] = 66594,[66635] = 66595,[66636] = 66596,[66637] = 66597,[66638] = 66598,[66639] = 66599,}
--PATH addons/[lib] onyx_framework_2/lua/onyx/framework/libs/sh_addon.lua:
return gluapack()()
--PATH addons/[lib] onyx_framework_2/lua/onyx/framework/libs/sh_netvar.lua:
return gluapack()()
--PATH addons/[lib] onyx_framework_2/lua/onyx/framework/libs/sh_util.lua:
return gluapack()()
--PATH addons/[lib] onyx_framework_2/lua/onyx/framework/core/cl_npc_label.lua:
return gluapack()()
--PATH addons/[lib] onyx_framework_2/lua/onyx/framework/core/cl_npc_label.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

30/12/2023

--]]
--PATH addons/[lib] onyx_framework_2/lua/onyx/ui/libs/thirdparty/cl_ui3d2d.lua:
return gluapack()()
--PATH addons/[lib] onyx_framework_2/lua/onyx/ui/libs/cl_spoly.lua:
--[[
MIT License

Copyright (c) 2023 Aleksandrs Filipovskis

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
--]]

local STATUS_IDLE = 0
local STATUS_BUSY = 1

onyx.spoly = onyx.spoly or {}
onyx.spoly.materials = onyx.spoly.materials or {}
onyx.spoly.queue = onyx.spoly.queue or {}
onyx.spoly.status = STATUS_IDLE

local spoly = onyx.spoly
local materials = spoly.materials
local queue = spoly.queue
local queued = {}

local SIZE = 2048
-- MATERIAL_RT_DEPTH_SEPARATE makes stencils possible to work
local RT = GetRenderTargetEx ('onyx_spoly_rt', SIZE, SIZE, 0, MATERIAL_RT_DEPTH_SEPARATE, bit.band(16, 1024), 0, IMAGE_FORMAT_DEFAULT)
local CAPTURE_DATA = {
    x = 0,
    y = 0,
    w = SIZE,
    h = SIZE,
    format = 'png',
    alpha = true
}

file.CreateDir('spoly')

do
    local colorTag = Color(92, 192, 254)
    local colorError = Color(254, 92, 92)
    local tag = '[SPoly] '

    function spoly.Print(text, ...)
        MsgC(colorTag, tag, color_white, string.format(text, ...), '\n')
    end

    function spoly.PrintError(text, ...)
        MsgC(colorTag, tag, colorError, '[ERROR] ', color_white, string.format(text, ...), '\n')
    end
end

--[[------------------------------
Either render.PushFilterMin and render.PushFilterMag don't work with materials created with Lua
Idk what shader parameter is missing, I couldn't find it even by comparing materials' KeyValues
--------------------------------]]
function spoly.Render(id, funcDraw)
    local path = 'spoly/' .. id .. '.png'
    local start = SysTime()

    spoly.status = STATUS_BUSY

    render.PushRenderTarget(RT)

        render.Clear(0, 0, 0, 0)

        cam.Start2D()
            surface.SetDrawColor(color_white)
            draw.NoTexture()
            local success, errorText = pcall(funcDraw, SIZE, SIZE)
        cam.End2D()

        local content = render.Capture(CAPTURE_DATA)

        file.Delete(path)
        file.Write(path, content)

    render.PopRenderTarget()

    materials[id] = Material('data/' .. path, 'mips')

    spoly.status = STATUS_IDLE

    local endtime = SysTime()
    local delta = tostring(math.Round(endtime - start, 3))

    if (not success) then
        spoly.PrintError('Failed to render \'%s\', error text: %s', id, errorText)
    else
        spoly.Print('Rendered \'%s\' in %ss', id, delta)
    end
end

function spoly.Generate(id, funcDraw)
    assert(isstring(id), Format('bad argument #1 to \'spoly.Generate\' (expected string, got %s)', type(id)))
    assert(isfunction(funcDraw), Format('bad argument #2 to \'spoly.Generate\' (expected function, got %s)', type(funcDraw)))

    if (materials[id]) then return end
    if (queued[id]) then return end

    local path = 'spoly/' .. id .. '.png'
    if (file.Exists(path, 'DATA')) then
        materials[id] = Material('data/' .. path, 'mips')
        if (not materials[id]:IsError()) then
            return
        end
    end

    queued[id] = true

    table.insert(queue, {
        id = id,
        funcDraw = funcDraw
    })
end

do
    local thinkRate = 1 / 10
    local nextThink = 0
    hook.Add('Think', 'spoly.QueueController', function()
        if (spoly.status == STATUS_IDLE and queue[1] and nextThink <= CurTime()) then
            nextThink = CurTime() + thinkRate

            local data = table.remove(queue, 1)

            spoly.Render(data.id, data.funcDraw)
        end
    end)
end

do
    local SetDrawColor = surface.SetDrawColor
    local SetMaterial = surface.SetMaterial
    local DrawTexturedRect = surface.DrawTexturedRect
    local DrawTexturedRectRotated = surface.DrawTexturedRectRotated

    local PushFilterMag = render.PushFilterMag
    local PushFilterMin = render.PushFilterMin
    local PopFilterMag = render.PopFilterMag
    local PopFilterMin = render.PopFilterMin

    -- calling this really often so trying to optimize as much as possible
    function spoly.Draw(id, x, y, w, h, color)
        local material = materials[id]
        if (not material) then return end

        if (color) then
            SetDrawColor(color)
        end

        SetMaterial(material)

        PushFilterMag(TEXFILTER.ANISOTROPIC)
        PushFilterMin(TEXFILTER.ANISOTROPIC)

        DrawTexturedRect(x, y, w, h)

        PopFilterMag()
        PopFilterMin()
    end

    function spoly.DrawRotated(id, x, y, w, h, rotation, color)
        local material = materials[id]
        if (not material) then return end

        if (color) then
            SetDrawColor(color)
        end

        SetMaterial(material)

        PushFilterMag(TEXFILTER.ANISOTROPIC)
        PushFilterMin(TEXFILTER.ANISOTROPIC)

        DrawTexturedRectRotated(x, y, w, h, rotation)

        PopFilterMag()
        PopFilterMin()
    end
end
--PATH addons/[lib] onyx_framework_2/lua/onyx/ui/libs/cl_trait.lua:
return gluapack()()
--PATH addons/[lib] onyx_framework_2/lua/onyx/ui/libs/cl_wimg.lua:
return gluapack()()
--PATH addons/[lib] onyx_framework_2/lua/onyx/ui/traits/cl_smooth_scroll.lua:
-- I don't remember where did I get it
-- Credits to someone

local TRAIT = {}

local Approach = math.Approach
local abs = math.abs
local Clamp = math.Clamp
local RealFrameTime = RealFrameTime

function TRAIT:Init()
    self.Current = 0
end

function TRAIT:SetScroll(scrll)
	if (not self.Enabled) then self.Scroll = 0 return end

	self.Scroll = Clamp(scrll, 0, self.CanvasSize)

	self:InvalidateLayout()
end

function TRAIT:Think()
    local current = self.Current
    local target = self.Scroll

	self.Current = Approach(current, target, 10 * abs(target - current) * RealFrameTime())

    if current ~= target then
        local parent = self:GetParent()
        local func = parent.OnVScroll
        if func then
        	func(parent, self:GetOffset())
        end
    end
end

function TRAIT:GetOffset()
    if not self.Enabled then
        return 0
    end

    return self.Current * -1
end

onyx.trait.Register("smoothscroll", TRAIT)
--PATH addons/[lib] onyx_framework_2/lua/onyx/ui/elements/cl_combo.lua:
return gluapack()()
--PATH addons/[lib] onyx_framework_2/lua/onyx/ui/elements/cl_navbar.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

31/12/2023

--]]

local colorSecondary = onyx:Config('colors.secondary')
local colorAccent = onyx:Config('colors.accent')
local colorGray = Color(197, 197, 197)
local colorGradient = onyx.LerpColor(.5, colorAccent, colorSecondary)

do
    local PANEL = {}

    AccessorFunc(PANEL, 'm_Name', 'Name')
    AccessorFunc(PANEL, 'm_Font', 'Font')
    AccessorFunc(PANEL, 'm_iRoundness', 'Roundness')
    AccessorFunc(PANEL, 'm_iIconSize', 'IconSize')
    AccessorFunc(PANEL, 'm_iIconMargin', 'IconMargin')
    AccessorFunc(PANEL, 'm_bMasking', 'Masking')
    AccessorFunc(PANEL, 'm_matMaterial', 'Material')
    AccessorFunc(PANEL, 'm_wimgObject', 'WebImage')

    function PANEL:Init()
        self:SetWide(onyx.ScaleWide(120))
        self:SetName('Tab')
        self:SetFont(onyx.Font('Comfortaa Bold@16'))
        self:SetRoundness(8)
        self:SetIconSize(onyx.ScaleTall(14))
        self:SetIconMargin(onyx.ScaleTall(5))
        self:Import('click')
        self.animActiveFraction = 0
    end

    function PANEL:Paint(w, h)
        local x0, y0 = w * .5, h * .5
        local textColor = self:IsHovered() and color_white or colorGray
        local animActiveFraction = self.animActiveFraction
        local screenX, screenY = self:LocalToScreen(0, 0)

        -- unactive text
        if (animActiveFraction < 1) then
            self:DrawContent(x0, y0, ColorAlpha(textColor, (1 - animActiveFraction) * 255))
        end

        -- active text
        if (animActiveFraction > 0) then
            local animHeight = h * animActiveFraction
            local animHeightHalf = animHeight * .5

            render.SetScissorRect(screenX, screenY + h * .5 - animHeightHalf, screenX + w, screenY + h * .5 + animHeightHalf, true)
                self:DrawContent(x0, y0, colorAccent)
            render.SetScissorRect(0, 0, 0, 0, false)
        end
    end

    function PANEL:DrawContent(x0, y0, color)
        local name = self.m_Name
        local font = self.m_Font
        local material = self.m_matMaterial
        local webimage = self.m_wimgObject
        local iconSize = self.m_iIconSize
        local iconMargin = self.m_iIconMargin

        if (material or webimage) then
            local textW = onyx.GetTextSize(name, font)
            local totalW = textW + iconSize + iconMargin
            local x = x0 - totalW * .5

            if (material) then
                onyx.DrawMaterial(material, x, y0 - iconSize * .5, iconSize, iconSize, color)
            else
                webimage:Draw(x, y0 - iconSize * .5, iconSize, iconSize, color)
            end

            draw.SimpleText(name, font, x + iconSize + iconMargin, y0, color, 0, 1)
        else
            draw.SimpleText(name, font, x0, y0, color, 1, 1)
        end
    end

    function PANEL:SetupTab(data)
        self:SetName(data.name)
        self:SetMaterial(data.material)

        if (data.icon) then
            self:SetWebImage(onyx.wimg.Simple(data.icon, 'smooth mips'))
        elseif (data.wimg) then
            self:SetWebImage(data.wimg)
        end
    end

    function PANEL:SizeToContents(space)
        local space = space or 0
        local textW = onyx.GetTextSize(self.m_Name, self.m_Font)
        local totalW = textW + space

        if (self:HasIcon()) then
            totalW = totalW + self:GetIconSize() + self:GetIconMargin()
        end

        self:SetWide(totalW)
    end

    function PANEL:HasIcon()
        return (self.m_matMaterial ~= nil)
    end

    function PANEL:SetActive(bActiveBool)
        self.active = bActiveBool

        onyx.anim.Create(self, .33, {
            index = 1,
            target = {
                animActiveFraction = (bActiveBool and 1 or 0)
            }
        })
    end

    function PANEL:PerformLayout(w, h)
        if (self.m_bMasking) then
            self.mask = onyx.CalculateRoundedBoxEx(self.m_iRoundness, 0, 0, w, h, false, false, true)
        end
    end

    onyx.gui.Register('onyx.Navbar.Tab', PANEL)
end

do
    local PANEL = {}

    AccessorFunc(PANEL, 'm_pnlContainer', 'Container')
    AccessorFunc(PANEL, 'm_pnlActiveTab', 'ActiveTab')
    AccessorFunc(PANEL, 'm_iRoundness', 'Roundness')
    AccessorFunc(PANEL, 'm_bKeepTabContent', 'KeepTabContent')
    AccessorFunc(PANEL, 'm_iSpace', 'Space')

    function PANEL:Init()
        self.tabs = {}
        self:SetRoundness(0)
        self:SetSpace(0)
        self.animLineCurrent = 0
        self.animLineTarget = 0

        self.animLineX = 0
        self.animLineW = 0
    end

    function PANEL:AddTab(data)
        local tab = self:Add('onyx.Navbar.Tab')
        tab:Dock(LEFT)
        tab:DockMargin(0, 0, self.m_iSpace, 0)
        tab:SetupTab(data)
        tab.DoClick = function(panel)
            self:SelectTab(panel)
        end

        tab.tabData = data
        tab.tabIndex = table.insert(self.tabs, tab)
        tab.cornerTab = tab.tabIndex == 1
        tab:SetMasking(tab.cornerTab)
        tab:SetRoundness(self:GetRoundness())

        self:Call('OnTabAdded', nil, tab)

        return tab
    end

    function PANEL:GetTabs()
        return self.tabs
    end

    function PANEL:ChooseTab(index, force)
        local tab = self.tabs[index]
        assert(IsValid(tab), 'tried to choose invalid tab')
        self:SelectTab(tab, force)
    end

    function PANEL:SelectTab(tab, force)
        local shouldKeepTabContent = self.m_bKeepTabContent
        local container = self:GetContainer()
        assert(IsValid(container), string.format('Invalid container (%s) linked to the NavBar', tostring(container)))

        local data = tab.tabData

        if (data.onClick and not data.onClick()) then
            return
        end

        local currentActiveTab = self:GetActiveTab()
        if (IsValid(currentActiveTab)) then
            if (currentActiveTab == tab and not force) then
                return
            end

            currentActiveTab:SetActive(false)
        end

        self:SetActiveTab(tab)
        tab:SetActive(true)

        if (IsValid(currentActiveTab) and IsValid(currentActiveTab.content)) then
            if (shouldKeepTabContent) then
                currentActiveTab.content:Hide()
            else
                currentActiveTab.content:Remove()
            end
        end

        if (IsValid(tab.content)) then
            tab.content:Show()
        else
            tab.content = container:Add(data.class)
            tab.content:Dock(FILL)
            tab.content.tab = tab

            if (data.onBuild) then
                data.onBuild(tab.content)
            end
        end

        self:Call('OnTabSelected', nil, tab, tab.content)

        self.animLineTarget = tab.tabIndex

        if (not self.animLineStart) then
            self.animLineCurrent = self.animLineTarget
            self.animLineX = tab:GetPos()
            self.animLineW = tab:GetWide()
        else
            onyx.anim.Create(self, .33, {
                index = 1,
                easing = 'inOutSine',
                target = {
                    animLineCurrent = self.animLineTarget,
                    animLineX = tab:GetPos(),
                    animLineW = tab:GetWide()
                }
            })
        end

        self.animLineStart = self.animLineCurrent
    end

    function PANEL:PaintOver(w, h)
        local current = self.animLineCurrent
        if (current <= 0) then return end

        local target = self.animLineTarget
        if (target <= 0) then return end

        local gradientHeight = h * .25

        local x = self.animLineX
        local wide = self.animLineW
        if (wide == 0 and current == target) then
            local tab = self:GetChild(target - 1)

            x = tab:GetPos()
            wide = tab:GetWide()
        end

        surface.SetDrawColor(colorAccent)
        surface.DrawRect(x, h - 2, wide, 2)

        onyx.DrawMatGradient(x, h - gradientHeight, wide, gradientHeight, TOP, ColorAlpha(colorGradient, 25))
    end

    onyx.gui.Register('onyx.Navbar', PANEL)
end

-- ANCHOR Test

-- onyx.gui.Test('onyx.Frame', .65, .65, function(self, w, h)
--     self:MakePopup()

--     local content = self:Add('Panel')
--     content:DockPadding(10, 10, 10, 10)
--     content:Dock(FILL)

--     -- local sidebar = self:Add('onyx.Sidebar')
--     local navbar = content:Add('onyx.Navbar')
--     navbar:SetTall(48)
--     navbar:Dock(TOP)
--     navbar.Paint = function(panel, w, h)
--         draw.RoundedBox(8, 0, 0, w, h, colorSecondary)
--     end

--     local container = content:Add('Panel')
--     container:Dock(FILL)

--     navbar:SetContainer(container)
--     navbar:AddTab({
--         name = 'DASHBOARD',
--         desc = 'Main things',
--         class = 'DButton',
--         onSelected = function(panel)
--             panel:SetText('Meow')
--         end
--     })
--     navbar:AddTab({
--         name = 'JOBS',
--         desc = 'Choose your destiny',
--         material = Material('ut_darkrp/ui/box.png', 'mips smooth'),
--         class = 'DButton',
--     })
--     navbar:AddTab({
--         name = 'SHOP',
--         desc = 'Find items you need',
--         material = Material('ut_darkrp/ui/hat.png', 'mips smooth'),
--         class = 'DButton',
--     })
--     navbar:AddTab({
--         name = 'SETTINGS',
--         desc = 'Configure the game as you wish',
--         material = Material('ut_darkrp/ui/gear.png', 'mips smooth'),
--         class = 'DButton',
--     })
-- end)
--PATH addons/[lib] onyx_framework_2/lua/onyx/ui/elements/cl_rounded_avatar.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

30/04/2023

--]]

local PANEL = {}

function PANEL:Init()
    self.avatar = self:Add('AvatarImage')
    self.avatar:Dock(FILL)
    self.avatar:SetPaintedManually(true)

    self:Combine(self.avatar, 'SetPlayer')
    self:Combine(self.avatar, 'SetSteamID')
end

function PANEL:PerformLayout(w, h)
    self.mask = onyx.CalculateCircle(w * .5, h * .5, math.Round(h * .5) - 1, 24)
end

function PANEL:Paint(w, h)
    local mask = self.mask
    if (mask) then
        onyx.MaskFn(function()
            onyx.DrawPoly(mask)
        end, function()
            self.avatar:PaintManual()
        end)
    end
end

onyx.gui.Register('onyx.RoundedAvatar', PANEL)
--PATH addons/[lib] onyx_framework_2/lua/onyx/ui/elements/cl_scrollpanel_canvas.lua:
return gluapack()()
--PATH addons/[lib] onyx_framework_2/lua/onyx/ui/elements/cl_settings.lua:
return gluapack()()
--PATH addons/[ui] onyx_f4/lua/onyx/modules/f4/languages/cl_danish.lua:
return gluapack()()
--PATH addons/[ui] onyx_f4/lua/onyx/modules/f4/core/cl_core.lua:
return gluapack()()
--PATH addons/[ui] onyx_f4/lua/onyx/modules/f4/cfg/cl_ranks.lua:
--[[

Contact: filipovskis@proton.me
GitHub: https://github.com/filipovskis
Date: 29/09/2024

This code was written by Aleksandrs Filipovskis. Contact via email or GitHub.

--]]

--[[
    **WARNING**
    All defined ranks are considered admins.
--]]

onyx.f4.ranks = {}

onyx.f4:DefineRank('superadmin', {
    name = 'Super-Administrator',
    color = Color(255, 71, 71)
})
onyx.f4:DefineRank('admin', {
    name = 'Administrator',
    color = Color(249, 97, 97)
})
onyx.f4:DefineRank('moderator', {
    name = 'Moderator',
    color = Color(49, 222, 49)
})
onyx.f4:DefineRank('support', {
    name = 'Support',
    color = Color(17, 142, 220)
})

--PATH addons/[ui] onyx_f4/lua/onyx/modules/f4/ui/cl_item.lua:
return gluapack()()
--PATH addons/[ui] onyx_hud/lua/onyx/modules/hud/languages/cl_french.lua:
-- With the help of chatGPT & verified by native speaker

local LANG = {}

LANG[ 'hud_status_wanted' ] = 'Recherch'
LANG[ 'hud_status_speaking' ] = 'Parle'
LANG[ 'hud_status_typing' ] = 'Tape'
LANG[ 'props' ] = 'Objets'
LANG[ 'close' ] = 'Fermer'
LANG[ 'alert' ] = 'Alerte'
LANG[ 'message' ] = 'Message'
LANG[ 'unknown' ] = 'Inconnu'
LANG[ 'accept' ] = 'Accepter'
LANG[ 'deny' ] = 'Refuser'
LANG[ 'none' ] = 'Aucun'
LANG[ 'add' ] = 'Ajouter'
LANG[ 'remove' ] = 'Retirer'
LANG[ 'jobs' ] = 'Mtiers'
LANG[ 'door' ] = 'Porte'
LANG[ 'vehicle' ] = 'Vhicule'
LANG[ 'door_groups' ] = 'Groupes de portes'
LANG[ 'display' ] = 'Affichage'
LANG[ 'general' ] = 'Gnral'
LANG[ 'speedometer' ] = 'Vitesse'
LANG[ 'fuel' ] = 'Carburant'
LANG[ 'vote' ] = 'Vote'
LANG[ 'question' ] = 'Question'

LANG[ 'timeout_title' ] = 'CONNEXION PERDUE'
LANG[ 'timeout_info' ] = 'Le serveur est actuellement indisponible, nous sommes dsols'
LANG[ 'timeout_status' ] = 'Vous serez reconnect dans %d secondes'

LANG[ 'hud.theme.default.name' ] = 'Par Dfaut'
LANG[ 'hud.theme.forest.name' ] = 'Fort'
LANG[ 'hud.theme.violet_night.name' ] = 'Nuit Violette'
LANG[ 'hud.theme.rustic_ember.name' ] = 'Braise Rustique'
LANG[ 'hud.theme.green_apple.name' ] = 'Pomme Verte'
LANG[ 'hud.theme.lavender.name' ] = 'Lavande'
LANG[ 'hud.theme.elegance.name' ] = 'lgance'
LANG[ 'hud.theme.mint_light.name' ] = 'Menthe'
LANG[ 'hud.theme.gray.name' ] = 'Gris'
LANG[ 'hud.theme.rose_garden.name' ] = 'Jardin de Roses'
LANG[ 'hud.theme.ocean_wave.name' ] = 'Vague Ocanique'
LANG[ 'hud.theme.sky_blue.name' ] = 'Bleu Ciel'
LANG[ 'hud.theme.golden_dawn.name' ] = 'Aube Dore'

LANG[ 'hud_help_type' ] = 'Tapez'
LANG[ 'hud_help_to' ] = 'pour ouvrir les paramtres'

LANG[ 'door_purchase' ] = 'Acheter {object}'
LANG[ 'door_sell' ] = 'Vendre {object}'
LANG[ 'door_addowner' ] = 'Ajouter un propritaire'
LANG[ 'door_rmowner' ] = 'Retirer un propritaire'
LANG[ 'door_rmowner_help' ] = 'Choisissez le joueur  qui vous souhaitez retirer la proprit'
LANG[ 'door_addowner_help' ] = 'Choisissez le joueur  qui vous souhaitez accorder la proprit'
LANG[ 'door_title' ] = 'Dfinir le titre'
LANG[ 'door_title_help' ] = 'Quel titre voulez-vous dfinir ?'
LANG[ 'door_admin_disallow' ] = 'Interdire la proprit'
LANG[ 'door_admin_allow' ] = 'Autoriser la proprit'
LANG[ 'door_admin_edit' ] = 'Modifier l\'accs'
LANG[ 'door_owned' ] = 'Proprit Prive'
LANG[ 'door_unowned' ] = ' Vendre'

LANG[ 'hud_door_help' ] = 'Appuyez sur {bind} pour acheter pour {price}'
LANG[ 'hud_door_owner' ] = 'Propritaire : {name}'
LANG[ 'hud_door_allowed' ] = 'Autoris  possder'
LANG[ 'hud_door_coowners' ] = 'Copropritaires'
LANG[ 'hud_and_more' ] = 'et plus...'

LANG[ 'reconnect_u' ] = 'RECONNECTER'
LANG[ 'disconnect_u' ] = 'DCONNECTER'
LANG[ 'settings_u' ] = 'PARAMTRES'
LANG[ 'configuration_u' ] = 'CONFIGURATION'
LANG[ 'introduction_u' ] = 'INTRODUCTION'

LANG[ 'seconds_l' ] = 'secondes'
LANG[ 'minutes_l' ] = 'minutes'

LANG[ 'hud.timeout.name' ] = 'Dure du Timeout'
LANG[ 'hud.timeout.desc' ] = 'Combien de secondes avant la reconnexion automatique'

LANG[ 'hud.alert_queue.name' ] = 'File d\'attente des alertes'
LANG[ 'hud.alert_queue.desc' ] = 'Les alertes doivent-elles tre mises en file d\'attente ?'

LANG[ 'hud.props_counter.name' ] = 'Compteur d\'Objets'
LANG[ 'hud.props_counter.desc' ] = 'Afficher le compteur d\'objets'

LANG[ 'hud.main_avatar_mode.name' ] = 'Type d\'Avatar Principal'
LANG[ 'hud.main_avatar_mode.desc' ] = 'Choisissez le type'

LANG[ 'hud.voice_avatar_mode.name' ] = 'Type d\'Avatar Vocal'
LANG[ 'hud.voice_avatar_mode.desc' ] = 'Choisissez le type'

LANG[ 'hud.restrict_themes.name' ] = 'Restreindre les Thmes'
LANG[ 'hud.restrict_themes.desc' ] = 'Restreindre les joueurs  choisir des thmes'

LANG[ 'hud.speedometer_mph.name' ] = 'Utiliser les Miles'
LANG[ 'hud.speedometer_mph.desc' ] = 'Changer les units en miles par heure'

LANG[ 'hud.speedometer_max_speed.name' ] = 'Vitesse Maximale par Dfaut'
LANG[ 'hud.speedometer_max_speed.desc' ] = 'La vitesse maximale pour le compteur de vitesse'

LANG[ 'hud.wpnsel_sounds.name' ] = 'Sons de slection d\'armes'
LANG[ 'hud.wpnsel_sounds.desc' ] = 'Activer les sons de l\'interface de slection d\'armes'

LANG[ 'hud_should_draw' ] = 'L\'lment doit tre dessin'
LANG[ 'hud.main.name' ] = 'HUD Principal'
LANG[ 'hud.ammo.name' ] = 'Munitions'
LANG[ 'hud.agenda.name' ] = 'Agenda'
LANG[ 'hud.alerts.name' ] = 'Alertes'
LANG[ 'hud.pickup_history.name' ] = 'Historique de Ramassage'
LANG[ 'hud.level.name' ] = 'Niveau'
LANG[ 'hud.voice.name' ] = 'Panneaux de Voix'
LANG[ 'hud.overhead_health.name' ] = 'Sant Surleve 3D2D'
LANG[ 'hud.overhead_armor.name' ] = 'Armure Surleve 3D2D'
LANG[ 'hud.vehicle.name' ] = 'HUD Vhicule'

LANG[ 'hud.theme.name' ] = 'Thme'
LANG[ 'hud.theme.desc' ] = 'Choisissez le thme du HUD'

LANG[ 'hud.scale.name' ] = 'chelle'
LANG[ 'hud.scale.desc' ] = 'Ajustez l\'chelle du HUD'

LANG[ 'hud.roundness.name' ] = 'Arrondi'
LANG[ 'hud.roundness.desc' ] = 'Ajustez l\'arrondi du HUD'

LANG[ 'hud.margin.name' ] = 'Marge'
LANG[ 'hud.margin.desc' ] = 'La distance entre le HUD et les bords'

LANG[ 'hud.icons_3d.name' ] = 'Modles 3D'
LANG[ 'hud.icons_3d.desc' ] = 'Rendre les icnes de modles en 3D'

LANG[ 'hud.compact.name' ] = 'Mode Compact'
LANG[ 'hud.compact.desc' ] = 'Activer le mode compact'

LANG[ 'hud.speedometer_blur.name' ] = 'Flou du Compteur de Vitesse'
LANG[ 'hud.speedometer_blur.desc' ] = 'Activer le flou pour le compteur de vitesse'

LANG[ 'hud.3d2d_max_details.name' ] = 'Dtails 3D2D Maximum'
LANG[ 'hud.3d2d_max_details.desc' ] = 'La quantit maximale d\'informations dtailles  rendre'
LANG[ 'hud_lockdown' ] = 'CONFINEMENT'
LANG[ 'hud_lockdown_help' ] = 'Veuillez retourner chez vous !'

LANG[ 'hud_wanted' ] = 'RECHERCH'
LANG[ 'hud_wanted_help' ] = 'Raison : {reason}'

LANG[ 'hud_arrested' ] = 'ARRT'
LANG[ 'hud_arrested_help' ] = 'Vous serez libr dans {time}'

onyx.lang:AddPhrases( 'french', LANG )
--PATH addons/[ui] onyx_hud/lua/onyx/modules/hud/languages/cl_polish.lua:
return gluapack()()
--PATH addons/[ui] onyx_hud/lua/onyx/modules/hud/core/cl_core.lua:
return gluapack()()
--PATH addons/[ui] onyx_hud/lua/onyx/modules/hud/core/cl_fonts.lua:
return gluapack()()
--PATH addons/[ui] onyx_hud/lua/onyx/modules/hud/core/cl_fonts.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

17/08/2024

--]]

onyx.hud.fonts = onyx.hud.fonts or {}

local function font2D( name, size, postfix )
    local family = 'Comfortaa'
    local finalFont = family
    local scaleInt = onyx.hud.GetScale()
    local updatedSize = math.ceil( ( size * scaleInt ) / 900 * ScrH() )
    local fontName = 'onyx.hud.' .. name

    if ( postfix ) then
        finalFont = finalFont .. ' ' .. postfix
    end

    surface.CreateFont( fontName, {
        font = finalFont,
        size = updatedSize,
        extended = true
    } )
    
    onyx.hud.fonts[ name ] = fontName
end

local function font3D2D( name, family, size )
    local realName = 'onyx.hud.' .. name

    surface.CreateFont( realName, {
        font = family,
        size = size,
        extended = true
    } )

    surface.CreateFont( realName .. '.Blur', {
        font = family,
        size = size,
        blursize = 2,
        extended = true
    } )

    return realName
end
onyx.hud.CreateFont3D2D = font3D2D

function onyx.hud.BuildFonts()
    onyx.hud.builtFonts = true

    font2D( 'ExtraTiny', 14 )
    font2D( 'ExtraTinyBold', 14, 'Bold' )

    font2D( 'Tiny', 16 )
    font2D( 'TinyBold', 16, 'Bold' )

    font2D( 'Small', 18 )
    font2D( 'SmallBold', 18, 'Bold' )

    font2D( 'Medium', 22 )
    font2D( 'MediumBold', 22, 'Bold' )

    font2D( 'Big', 28 )
    font2D( 'BigBold', 28, 'Bold' )

    font2D( 'Name', 20, 'Bold' )
    font2D( 'AmmoClip', 40, 'Bold' )
    font2D( 'AmmoRemaining', 28 )

    font2D( 'Speedometer', 80 )
end

onyx.WaitForGamemode( 'onyx.hud.BuildFonts', onyx.hud.BuildFonts )
--PATH addons/[ui] onyx_hud/lua/onyx/modules/hud/elements/cl_door_menu.lua:
return gluapack()()
--PATH addons/[ui] onyx_hud/lua/onyx/modules/hud/elements/cl_votes.lua:
return gluapack()()
--PATH addons/[ui] onyx_scoreboard/lua/onyx/modules/scoreboard/languages/cl_english.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

02/03/2024

--]]

local LANG = {}

-- Phrases
LANG['copied_clipboard'] = 'Copied to clipboard'
LANG['scoreboard_search'] = 'Search... (Name/SteamID)'
LANG['you'] = 'You'
LANG['friend'] = 'Friend'
LANG['addon_return_u'] = 'RETURN'

-- Columns
LANG['scoreboard_col_team'] = 'Team'
LANG['scoreboard_col_job'] = 'Job'
LANG['scoreboard_col_money'] = 'Money'
LANG['scoreboard_col_rank'] = 'Rank'
LANG['scoreboard_col_karma'] = 'Karma'
LANG['scoreboard_col_playtime'] = 'Playtime'
LANG['scoreboard_col_health'] = 'Health'
LANG['scoreboard_col_level'] = 'Level'
LANG['scoreboard_col_none'] = 'None'
LANG['scoreboard_col_gang'] = 'Gang'
LANG['scoreboard_col_ashop_badges'] = 'Badges'
LANG['scoreboard_col_faction'] = 'Faction'

-- Name Effects
LANG['scoreboard_eff_default'] = 'Default'
LANG['scoreboard_eff_glow'] = 'Glow'
LANG['scoreboard_eff_rainbow'] = 'Rainbow'
LANG['scoreboard_eff_scanning_vertical'] = 'Scanning (Vertical)'
LANG['scoreboard_eff_scanning_horizontal'] = 'Scanning (Horizontal)'
LANG['scoreboard_eff_gradient_invert'] = 'Gradient (Invert Color)'
LANG['scoreboard_eff_wavy_dual'] = 'Wavy (Dual Color)'

-- Buttons
LANG['scoreboard_btn_profile'] = 'Open Profile'
LANG['scoreboard_btn_freeze'] = 'Freeze'
LANG['scoreboard_btn_goto'] = 'Goto'
LANG['scoreboard_btn_bring'] = 'Bring'
LANG['scoreboard_btn_return'] = 'Return'
LANG['scoreboard_btn_respawn'] = 'Respawn'
LANG['scoreboard_btn_slay'] = 'Slay'
LANG['scoreboard_btn_spectate'] = 'Spectate'

-- Words
LANG['rank_id'] = 'Rank Identifier'
LANG['name'] = 'Name'
LANG['effect'] = 'Effect'
LANG['color'] = 'Color'
LANG['preview'] = 'Preview'
LANG['creation'] = 'Creation'
LANG['save'] = 'Save'
LANG['dead'] = 'Dead'
LANG['create_new'] = 'Create New'
LANG['column'] = 'Column'

-- Settings
LANG['addon_settings_u'] = 'SETTINGS'
LANG['scoreboard_ranks_u'] = 'RANKS'
LANG['scoreboard_columns_u'] = 'COLUMNS'

LANG['scoreboard.title.name'] = 'Title'
LANG['scoreboard.title.desc'] = 'Input the title for the frame'

LANG['scoreboard.group_teams.name'] = 'Group Teams'
LANG['scoreboard.group_teams.desc'] = '(DarkRP) Group teams by job categories'

LANG['scoreboard.colored_players.name'] = 'Colorized Gradient'
LANG['scoreboard.colored_players.desc'] = 'Show colorized gradient on player line'

LANG['scoreboard.blur.name'] = 'Blur Theme'
LANG['scoreboard.blur.desc'] = 'Enable blur theme'

LANG['scoreboard.scale.name'] = 'Frame Size Scale'
LANG['scoreboard.scale.desc'] = 'Scale the scoreboard\'s frame size'

onyx.lang:AddPhrases('english', LANG)
--PATH addons/[ui] onyx_scoreboard/lua/onyx/modules/scoreboard/languages/cl_french.lua:
--[[

Author: VeaTime
Steam Profile: https://steamcommunity.com/id/VeaTime/

07/03/2024

--]]

local LANG = {}

-- Phrases
LANG['copied_clipboard'] = 'Copier dans le presse-papier'
LANG['scoreboard_search'] = 'Recherche... (Nom/SteamID)'
LANG['you'] = 'Toi'
LANG['friend'] = 'Amie'

-- Columns
LANG['scoreboard_col_team'] = 'Team'
LANG['scoreboard_col_job'] = 'Mtier'
LANG['scoreboard_col_money'] = 'Argent'
LANG['scoreboard_col_rank'] = 'Rank'
LANG['scoreboard_col_karma'] = 'Karma'
LANG['scoreboard_col_playtime'] = 'Playtime'
LANG['scoreboard_col_health'] = 'Sant'
LANG['scoreboard_col_level'] = 'Niveau'
LANG['scoreboard_col_none'] = 'Rien'
LANG['scoreboard_col_gang'] = 'Gang'
LANG['scoreboard_col_ashop_badges'] = 'Badges'

-- Name Effects
LANG['scoreboard_eff_default'] = 'Dfaut'
LANG['scoreboard_eff_glow'] = 'Briller'
LANG['scoreboard_eff_rainbow'] = 'Arc en ciel'

-- Buttons
LANG['scoreboard_btn_profile'] = 'Ouvrir le profile'
LANG['scoreboard_btn_freeze'] = 'Freeze'
LANG['scoreboard_btn_goto'] = 'Goto'
LANG['scoreboard_btn_bring'] = 'Bring'
LANG['scoreboard_btn_return'] = 'Return'
LANG['scoreboard_btn_respawn'] = 'Respawn'
LANG['scoreboard_btn_slay'] = 'Slay'

-- Words
LANG['rank_id'] = 'Rank Identifier'
LANG['name'] = 'Nom'
LANG['effect'] = 'Effet'
LANG['color'] = 'Couleur'
LANG['preview'] = 'Aperu'
LANG['creation'] = 'Creation'
LANG['save'] = 'Sauvegarder'
LANG['dead'] = 'Mort'
LANG['create_new'] = 'Crer un nouveau'
LANG['column'] = 'Colonne'

-- Settings
LANG['addon_settings_u'] = 'PARAMTRES'
LANG['scoreboard_ranks_u'] = 'RANKS'
LANG['scoreboard_columns_u'] = 'COLONNES'

LANG['scoreboard.title.name'] = 'Titre'
LANG['scoreboard.title.desc'] = 'Saisissez le titre'

LANG['scoreboard.group_teams.name'] = 'Group Teams'
LANG['scoreboard.group_teams.desc'] = '(DarkRP) Group teams par catgories de mtier'

LANG['scoreboard.colored_players.name'] = 'Dgrad coloris'
LANG['scoreboard.colored_players.desc'] = 'Afficher le dgrad coloris sur la ligne du joueur'

LANG['scoreboard.blur.name'] = 'Theme Blur'
LANG['scoreboard.blur.desc'] = 'Activer le theme blur'

onyx.lang:AddPhrases('french', LANG)
--PATH addons/[ui] onyx_scoreboard/lua/onyx/modules/scoreboard/languages/cl_german.lua:
--[[

bersetzer: thestarhd
G-Profile: https://www.gmodstore.com/users/76561198801156110

12.03.2024 - German Translation

--]]

local LANG = {}

-- Phrasen
LANG['copied_clipboard'] = 'In die Zwischenablage kopiert'
LANG['scoreboard_search'] = 'Suchen... (Name/SteamID)'
LANG['you'] = 'Du'
LANG['friend'] = 'Freund'
LANG['addon_return_u'] = 'ZURCK'

-- Spalten
LANG['scoreboard_col_team'] = 'Team'
LANG['scoreboard_col_job'] = 'Job'
LANG['scoreboard_col_money'] = 'Geld'
LANG['scoreboard_col_rank'] = 'Rang'
LANG['scoreboard_col_karma'] = 'Karma'
LANG['scoreboard_col_playtime'] = 'Spielzeit'
LANG['scoreboard_col_health'] = 'Gesundheit'
LANG['scoreboard_col_level'] = 'Level'
LANG['scoreboard_col_none'] = 'Keiner'
LANG['scoreboard_col_gang'] = 'Gang'
LANG['scoreboard_col_ashop_badges'] = 'Abzeichen'

-- Namen-Effekte
LANG['scoreboard_eff_default'] = 'Standard'
LANG['scoreboard_eff_glow'] = 'Leuchten'
LANG['scoreboard_eff_rainbow'] = 'Regenbogen'
LANG['scoreboard_eff_scanning_vertical'] = 'Scannen (Vertikal)'
LANG['scoreboard_eff_scanning_horizontal'] = 'Scannen (Horizontal)'
LANG['scoreboard_eff_gradient_invert'] = 'Gradient (Farben umkehren)'
LANG['scoreboard_eff_wavy_dual'] = 'Wellenfrmig (Zweifarbig)'

-- Tasten
LANG['scoreboard_btn_profile'] = 'Profil ffnen'
LANG['scoreboard_btn_freeze'] = 'Einfrieren'
LANG['scoreboard_btn_goto'] = 'Gehen zu'
LANG['scoreboard_btn_bring'] = 'Bringen'
LANG['scoreboard_btn_return'] = 'Zurck'
LANG['scoreboard_btn_respawn'] = 'Wiederbeleben'
LANG['scoreboard_btn_slay'] = 'Tten'
LANG['scoreboard_btn_spectate'] = 'Zuschauen'

-- Wrter
LANG['rank_id'] = 'Rang-Identifikator'
LANG['name'] = 'Name'
LANG['effect'] = 'Effekt'
LANG['color'] = 'Farbe'
LANG['preview'] = 'Vorschau'
LANG['creation'] = 'Erstellung'
LANG['save'] = 'Speichern'
LANG['dead'] = 'Tot'
LANG['create_new'] = 'Neu erstellen'
LANG['column'] = 'Spalte'

-- Einstellungen
LANG['addon_settings_u'] = 'EINSTELLUNGEN'
LANG['scoreboard_ranks_u'] = 'RNGE'
LANG['scoreboard_columns_u'] = 'SPALTEN'

LANG['scoreboard.title.name'] = 'Titel'
LANG['scoreboard.title.desc'] = 'Gib den Titel fr den Rahmen ein'

LANG['scoreboard.group_teams.name'] = 'Teamgruppen'
LANG['scoreboard.group_teams.desc'] = '(DarkRP) Gruppiere Teams nach Jobkategorien'

LANG['scoreboard.colored_players.name'] = 'Farbverlauf'
LANG['scoreboard.colored_players.desc'] = 'Zeige farbigen Verlauf auf Spielerzeile'

LANG['scoreboard.blur.name'] = 'Unschrfe-Design'
LANG['scoreboard.blur.desc'] = 'Aktiviere Unschrfe-Design'

LANG['scoreboard.scale.name'] = 'Rahmengre skalieren'
LANG['scoreboard.scale.desc'] = 'Skaliere die Rahmengre des Scoreboards'

onyx.lang:AddPhrases('german', LANG)
--PATH addons/[ui] onyx_scoreboard/lua/onyx/modules/scoreboard/languages/cl_spanish.lua:
--[[

Author: Goran
Steam Profile:

03/07/2024

--]]

local LANG = {}

-- Phrases
LANG['copied_clipboard'] = 'Copiado al portapapeles'
LANG['scoreboard_search'] = 'Buscar... (Nombre/SteamID)'
LANG['you'] = 'T'
LANG['friend'] = 'Amigo'

-- Columns
LANG['scoreboard_col_team'] = 'Equipo'
LANG['scoreboard_col_job'] = 'Trabajo'
LANG['scoreboard_col_money'] = 'Dinero'
LANG['scoreboard_col_rank'] = 'Rango'
LANG['scoreboard_col_karma'] = 'Karma'
LANG['scoreboard_col_playtime'] = 'Tiempo de juego'
LANG['scoreboard_col_health'] = 'Salud'
LANG['scoreboard_col_level'] = 'Nivel'
LANG['scoreboard_col_none'] = 'Nada'
LANG['scoreboard_col_gang'] = 'Gang'

-- Name Effects
LANG['scoreboard_eff_default'] = 'Por Defecto'
LANG['scoreboard_eff_glow'] = 'Brillo'
LANG['scoreboard_eff_rainbow'] = 'Arcoris'

-- Buttons
LANG['scoreboard_btn_profile'] = 'Abrir Perfil'
LANG['scoreboard_btn_freeze'] = 'Congelar'
LANG['scoreboard_btn_goto'] = 'Ir'
LANG['scoreboard_btn_bring'] = 'Traer'
LANG['scoreboard_btn_return'] = 'Regresar'
LANG['scoreboard_btn_respawn'] = 'Regenerar'
LANG['scoreboard_btn_slay'] = 'Asesinar'

-- Words
LANG['rank_id'] = 'ID de rango'
LANG['name'] = 'Nombre'
LANG['effect'] = 'Efecto'
LANG['color'] = 'Color'
LANG['preview'] = 'Previsualizacin'
LANG['creation'] = 'Creacin'
LANG['save'] = 'Guardar'
LANG['dead'] = 'Muerto'
LANG['create_new'] = 'Crear nuevo'
LANG['column'] = 'Columna'

-- Settings
LANG['addon_settings_u'] = 'AJUSTES'
LANG['scoreboard_ranks_u'] = 'RANGOS'
LANG['scoreboard_columns_u'] = 'COLUMNAS'

LANG['scoreboard.title.name'] = 'Ttulo'
LANG['scoreboard.title.desc'] = 'Ingresa el ttulo del cuadro'

LANG['scoreboard.group_teams.name'] = 'Agrupar por equipo'
LANG['scoreboard.group_teams.desc'] = '(DarkRP) Agrupa los equipos por categora de trabajo'

LANG['scoreboard.colored_players.name'] = 'Gradiente coloreado'
LANG['scoreboard.colored_players.desc'] = 'Mostrar gradiente coloreado en la lnea del jugador'

LANG['scoreboard.blur.name'] = 'Tema Difuminado'
LANG['scoreboard.blur.desc'] = 'Habilitar Tema Difuminado'

onyx.lang:AddPhrases('spanish', LANG)
--PATH addons/[ui] onyx_scoreboard/lua/onyx/modules/scoreboard/core/columns/cl_columns.lua:
return gluapack()()
--PATH addons/[ui] onyx_scoreboard/lua/onyx/modules/scoreboard/core/integrations/sh_brick_gangs.lua:
return gluapack()()
--PATH addons/[ui] onyx_scoreboard/lua/onyx/modules/scoreboard/ui/cl_player.lua:
return gluapack()()
--PATH addons/[ui] onyx_scoreboard/lua/onyx/modules/scoreboard/ui/cl_rank_editor.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

04/03/2024

--]]

local COLOR_PRIMARY = onyx:Config('colors.primary')
local COLOR_SECONDARY = onyx:Config('colors.secondary')
local COLOR_TERTIARY = onyx:Config('colors.tertiary')
local COLOR_ACCENT = onyx:Config('colors.accent')

local PANEL = {}

function PANEL:Init()
    self.list = self:Add('onyx.ScrollPanel')

    self.grid = self.list:Add('onyx.Grid')
    self.grid:SetColumnCount(2)
    self.grid:SetSpace(onyx.ScaleTall(5))

    self.editor = self:Add('onyx.ScrollPanel')
    self.editor:Hide()

    self:InitEditor(self.editor)
    self:LoadRanks()

    hook.Add('onyx.scoreboard.SyncedRanks', self, function()
        self.grid:Clear()
        self:LoadRanks()
    end)
end

function PANEL:ShowEditor()
    self.editor:Show()
    self.editor:SetAlpha(0)
    self.editor:AlphaTo(255, .1)

    self.list:Hide()
end

function PANEL:HideEditor()
    self.list:Show()
    self.list:SetAlpha(0)
    self.list:AlphaTo(255, .1)

    self.editor:Hide()
end

function PANEL:PerformLayout(w, h)
    self.list:Dock(FILL)
    self.editor:Dock(FILL)
end

function PANEL:LoadRanks()
    local btnCreate = self.grid:Add('onyx.Button')
    btnCreate:SetText(onyx.utf8.upper(onyx.lang:Get('create_new')))
    btnCreate:SetTall(onyx.ScaleTall(40))
    btnCreate:SetColorIdle(COLOR_SECONDARY)
    btnCreate:SetColorHover(COLOR_TERTIARY)
    btnCreate.DoClick = function(panel)
        self:LoadEditorRank()
        self:ShowEditor()
    end

    self.grid:AddItem(btnCreate)

    for uniqueID, data in pairs(onyx.scoreboard.ranks) do
        local name = data.name
        local title = uniqueID .. (name ~= '' and string.format(' (%s)', name) or '')

        local btnRank = self.grid:Add('onyx.Button')
        btnRank:SetText(title)
        btnRank:SetTall(onyx.ScaleTall(40))
        btnRank:SetColorIdle(COLOR_SECONDARY)
        btnRank:SetColorHover(COLOR_TERTIARY)
        btnRank.DoClick = function(panel)
            self:LoadEditorRank(data, uniqueID)
            self:ShowEditor()
        end
        self.grid:AddItem(btnRank)
    end
end

function PANEL:LoadEditorRank(data, uniqueID)
    local fields = self.fields
    if (istable(data)) then
        -- load
        self.editor.header:SetText(data.name)
        self.btnDelete:Show()
        self.btnDelete.DoClick = function(panel)
            net.Start('onyx.scoreboard:DeleteRank')
                net.WriteString(uniqueID)
            net.SendToServer()

            self:HideEditor()
        end

        fields['uniqueID'].input:SetDisabled(true)
        fields['uniqueID'].input:SetValue(uniqueID)
        fields['name'].input:SetValue(data.name)
        fields['color'].input.picker:SetColor(data.color)

        local option, index = fields['effect'].input:FindOptionByData(data.effectID)
        if (option) then
            fields['effect'].input:ChooseOptionID(index)
        end
    else
        -- reset
        self.editor.header:SetText(onyx.utf8.upper(onyx.lang:Get('creation')))
        self.btnDelete:Hide()

        fields['uniqueID'].input:SetDisabled(false)
        fields['uniqueID'].input:SetValue('')
        fields['name'].input:SetValue('')
        fields['color'].input.picker:SetColor(color_white)
        fields['effect'].input:Reset()
    end
end

function PANEL:InitEditor(editor)
    local header = editor:Add('onyx.Label')
    header:SetTall(onyx.ScaleTall(40))
    header:SetText('')
    header:Dock(TOP)
    header:CenterText()
    header.Paint = function(panel, w, h)
        draw.RoundedBox(8, 0, 0, w, h, COLOR_SECONDARY)
    end
    editor.header = header

    local btnBack = header:Add('onyx.ImageButton')
    btnBack:SetWide(header:GetTall())
    btnBack:Dock(LEFT)
    btnBack:SetImageScale(.75)
    btnBack:SetURL('https://i.imgur.com/B9XOMVX.png', 'smooth mips')
    btnBack.DoClick = function()
        self:HideEditor()
    end

    self.btnDelete = header:Add('onyx.ImageButton')
    self.btnDelete:SetWide(header:GetTall())
    self.btnDelete:Dock(RIGHT)
    self.btnDelete:SetImageScale(.75)
    self.btnDelete:SetURL('https://i.imgur.com/nmT20xe.png', 'smooth mips')

    self.fields = {}
    self:CreateField(editor, 'uniqueID', onyx.utf8.upper(onyx.lang:Get('rank_id')), function(container)
        local entry = container:Add('onyx.TextEntry')
            entry:SetPlaceholderText('admin')
            entry.textEntry:SetMaximumCharCount(32)
        return entry
    end)

    self:CreateField(editor, 'name', onyx.utf8.upper(onyx.lang:Get('name')), function(container)
        local entry = container:Add('onyx.TextEntry')
            entry:SetPlaceholderText('Administrator')
            entry.textEntry:SetMaximumCharCount(32)
        return entry
    end)

    self:CreateField(editor, 'effect', onyx.utf8.upper(onyx.lang:Get('effect')), function(container)
        local combo = container:Add('onyx.ComboBox')
            for _, data in ipairs(onyx.scoreboard.nameEffects) do
                combo:AddOption(onyx.lang:Get(data.name), data.id)
            end
        return combo
    end)

    self:CreateField(editor, 'color', onyx.utf8.upper(onyx.lang:Get('color')), function(container)
        local panel = container:Add('Panel')

        local picker = panel:Add('DColorMixer')
        picker:Dock(FILL)
        picker:SetAlphaBar(false)
        picker:SetPalette(false)
        panel.picker = picker

        return panel
    end, 150)

    self:CreateField(editor, 'preview', onyx.utf8.upper(onyx.lang:Get('preview')), function(container)
        local name = LocalPlayer():Name()
        local preview = container:Add('onyx.Panel')
            preview.Paint = function(panel, w, h)
                local effectID = self.fields.effect.input:GetOptionData()
                local effectData = onyx.scoreboard:FindNameEffect(effectID or '')
                local color = self.fields.color.input.picker:GetColor()

                draw.RoundedBox(8, 0, 0, w, h, COLOR_SECONDARY)
                draw.RoundedBox(8, 1, 1, w - 2, h - 2, COLOR_PRIMARY)

                if (effectData) then
                    local realX, realY = panel:LocalToScreen(0, 0)
                    local x, y = onyx.ScaleTall(10), h * .5

                    effectData.func(name, x, y, color, 0, 1, realX + x, realY + y)
                end
            end
        return preview
    end)

    self.btnSave = editor:Add('onyx.Button')
    self.btnSave:SetText(onyx.utf8.upper(onyx.lang:Get('save')))
    self.btnSave:Dock(TOP)
    self.btnSave.DoClick = function(panel)
        local fields = self.fields
        local uniqueID = fields['uniqueID'].input:GetValue():Trim()
        local name = fields['name'].input:GetValue():Trim()
        local effect = fields['effect'].input:GetOptionData()
        local color = fields['color'].input.picker:GetColor()

        if (utf8.len(uniqueID) < 1 or utf8.len(uniqueID) > 32) then
            fields['uniqueID'].input:Highlight(Color(255, 0, 0), 1)
            return
        end

        if (utf8.len(name) > 32) then
            fields['name'].input:Highlight(Color(255, 0, 0), 1)
            return
        end

        net.Start('onyx.scoreboard:ReplaceRank')
            net.WriteString(uniqueID)
            net.WriteString(name)
            net.WriteString(effect)
            net.WriteColor(Color(color.r, color.g, color.b)) -- DColorMixer doesn't return Color object...
        net.SendToServer()

        self:HideEditor()
    end
end

function PANEL:CreateField(editor, key, title, buildFunc, size)
    local font = onyx.Font('Comfortaa SemiBold@14')
    local margin = onyx.ScaleTall(7.5)

    local field = editor:Add('Panel')
    field:Dock(TOP)
    field:SetTall(onyx.ScaleTall(size or 70))
    field.Paint = function(panel, w, h)
        draw.RoundedBox(8, 0, 0, w, h, COLOR_PRIMARY)
    end

    local header = field:Add('Panel')
    header:SetTall(onyx.ScaleTall(25))
    header:Dock(TOP)
    header.Paint = function(panel, w, h)
        draw.RoundedBoxEx(8, 0, 0, w, h, COLOR_SECONDARY, true, true)
        draw.SimpleText(title, font, onyx.ScaleTall(10), h * .5, color_white, 0, 1)
    end

    local container = field:Add('Panel')
    container:DockMargin(margin, margin, margin, margin)
    container:Dock(FILL)

    self.fields[key] = field

    if (isfunction(buildFunc)) then
        local panel = buildFunc(container)
        assert(panel, string.format('Invalid panel created (%s)', tostring(panel)))
        panel:Dock(FILL)

        field.input = panel
    end
end

onyx.gui.Register('onyx.scoreboard.RankEditor', PANEL)

-- if (IsValid(DebugPanel)) then
--     DebugPanel:Remove()
-- end

-- DebugPanel = onyx.scoreboard.OpenAdminSettings(2)
--PATH addons/[gas] gmodadminsuite-config-master/lua/openpermissions_lua_functions.lua:
--[[

	    __                   ______                 __  _                 
	   / /   __  ______ _   / ____/_  ______  _____/ /_(_)___  ____  _____
	  / /   / / / / __ `/  / /_  / / / / __ \/ ___/ __/ / __ \/ __ \/ ___/
	 / /___/ /_/ / /_/ /  / __/ / /_/ / / / / /__/ /_/ / /_/ / / / (__  ) 
	/_____/\__,_/\__,_/  /_/    \__,_/_/ /_/\___/\__/_/\____/_/ /_/____/  
	                                                                      

	Welcome to the Lua functions config.
	OpenPermissions has been designed to be as customizable as possible.
	In this configuration, you can define custom Lua functions which OpenPermissions can use.

	These Lua functions can be used as Access Groups, which allow you to assign permissions to people
	who successfully pass your own custom Lua code.

]]

return {
	["example_function"] = function(ply, permission_id)
		if (ply:SteamID() == "STEAM_0:1:40314158" or ply:SteamID64() == "76561198112561190") then
			return true -- allow!
		elseif (ply:SteamID() == "STEAM_0:1:7099") then
			return false -- disallow!
		else
			return -- ignore!
		end
	end,
}

--PATH addons/[ekonomia] pcasino/lua/perfectcasino/core/sh_cooldown.lua:
-- A cooldown lib I stole from my community's lib
PerfectCasino.Cooldown.Timers = PerfectCasino.Cooldown.Timers or {}

function PerfectCasino.Cooldown.Check(id, time, ply)
	if not id then return true end
	if not time then return true end

	if not PerfectCasino.Cooldown.Timers[id] then
		PerfectCasino.Cooldown.Timers[id] = {}
		PerfectCasino.Cooldown.Timers[id].global = 0
	end

	if ply then
		if not PerfectCasino.Cooldown.Timers[id][ply:SteamID64()] then
			PerfectCasino.Cooldown.Timers[id][ply:SteamID64()] = 0
		end

		if PerfectCasino.Cooldown.Timers[id][ply:SteamID64()] > CurTime() then return true end

		PerfectCasino.Cooldown.Timers[id][ply:SteamID64()] = CurTime() + time

		return false
	else
		if PerfectCasino.Cooldown.Timers[id].global > CurTime() then return true end

		PerfectCasino.Cooldown.Timers[id].global = CurTime() + time

		return false
	end
end

function PerfectCasino.Cooldown.Get(id, ply)
	if not id then return 0 end
	if not time then return 0 end

	if not PerfectCasino.Cooldown.Timers[id] then return 0 end

	-- The correct returns
	if ply and PerfectCasino.Cooldown.Timers[id][ply:SteamID64()] then return PerfectCasino.Cooldown.Timers[id][ply:SteamID64()] end
	if not ply and PerfectCasino.Cooldown.Timers[id].global then return PerfectCasino.Cooldown.Timers[id].global end

	-- Failsafe
	return 0
end


function PerfectCasino.Cooldown.Reset(id, ply)
	if not id then return end

	if not PerfectCasino.Cooldown.Timers[id] then return end

	if ply then
		if not PerfectCasino.Cooldown.Timers[id][ply:SteamID64()] then return end
		PerfectCasino.Cooldown.Timers[id][ply:SteamID64()] = 0
	else
		PerfectCasino.Cooldown.Timers[id].global = 0
	end
end
--PATH lua/autorun/pommes_patrol_seat.lua:
return gluapack()()
--PATH lua/autorun/portals_autorun.lua:
return gluapack()()
--PATH lua/autorun/proto.lua:
player_manager.AddValidModel( "Translator Protocol", "models/translator/pm_protocol_translator.mdl" )
player_manager.AddValidModel( "Inventory Protocol", "models/inventory/pm_protocol_inventory.mdl" )
player_manager.AddValidModel( "Vendor Protocol", "models/vendor/pm_protocol_vendor.mdl" )
player_manager.AddValidModel( "Guard Protocol", "models/guard/pm_protocol_guard.mdl" )


















































--PATH addons/[bronie] kajdanki/lua/autorun/przeszukanie_config.lua:
----
--Tutaj wpisz bronie ktrych ma nie zabiera podczas przeszukania:
----

print([[
--------------------------------------------------------------------
______                            _    _                     _      
| ___ \                          | |  (_)                   (_)     
| |_/ / __ _______  ___ _____   _| | _____      ____ _ _ __  _  ___ 
|  __/ '__|_  / _ \/ __|_  / | | | |/ / \ \ /\ / / _` | '_ \| |/ _ \
| |  | |   / /  __/\__ \/ /| |_| |   <| |\ V  V / (_| | | | | |  __/
\_|  |_|  /___\___||___/___|\__,_|_|\_\_| \_/\_/ \__,_|_| |_|_|\___|

						Handcuffs edit
						by Darkness
						Kocha Darknessa ~frestylek 
--------------------------------------------------------------------
]])

przeszukanie_config = {}
przeszukanie_config.safeWeapons = {

	["mvp_perfecthands"] = true,
	["weapon_handcuffed"] = true,
	["gmod_tool"] = true,
	["weapon_physgun"] = true,
	["weapon_physcannon"] = true,
	["darkness_pda"] = true
	
}
--PATH lua/autorun/rd_function_lib_init.lua:
RDV = RDV or {}
RDV.LIBRARY = RDV.LIBRARY or {}
RDV.LIBRARY.Mysql = RDV.LIBRARY.Mysql or {
    module = "sqlite",
    CFG = {},
}


local rootDir = "reality_development"

local function AddFile(File, dir)
    local fileSide = string.lower(string.Left(File , 3))

    if SERVER and fileSide == "sv_" then
        include(dir..File)
    elseif fileSide == "sh_" then
        if SERVER then 
            AddCSLuaFile(dir..File)
        end
        include(dir..File)
    elseif fileSide == "cl_" then
        if SERVER then 
            AddCSLuaFile(dir..File)
        elseif CLIENT then
            include(dir..File)
        end
    end
end

local function IncludeDir(dir)
    dir = dir .. "/"
    local File, Directory = file.Find(dir.."*", "LUA")

    for k, v in ipairs(File) do
        if string.EndsWith(v, ".lua") then
            AddFile(v, dir)
        end
    end
    
    for k, v in ipairs(Directory) do
        IncludeDir(dir..v)
    end

end
IncludeDir(rootDir)

hook.Run("RDV_LIB_Loaded")
--PATH lua/reality_development/cl_theme.lua:
RDV.LIBRARY.THEME = {
    YELLOW = Color(252,180,9,255),
    GREY = Color(122,132,137, 180),
}
--PATH lua/reality_development/client/vgui/cl_frame.lua:
return gluapack()()
--PATH lua/reality_development/client/vgui/cl_scroll.lua:
local PANEL = {}

function PANEL:Init()
    local VBAR = self:GetVBar()

    function VBAR:Paint(w, h)
        surface.SetDrawColor(Color(49,56,58,255))
        surface.DrawRect( 0, 0, w, h )
    end

    local W, H = VBAR:GetSize()

    VBAR:SetWide(W * 0.5)
    VBAR:SetHideButtons(true)

    local GRIP = VBAR:GetChildren()[3]

    function GRIP:Paint(w, h)
        surface.SetDrawColor(Color(124,137,140,255))
        surface.DrawRect( 0, 0, w, h )
    end
end

vgui.Register("RDV_LIBRARY_SCROLL", PANEL, "DScrollPanel")
--PATH lua/reality_development/client/vgui/cl_textbutton.lua:
local PANEL = {}

function PANEL:Init()
    self.HOVERED = false
    self:SetFont("RDV_LIB_FRAME_TITLE")
    self:SetTextColor(color_white)
end

function PANEL:Paint(w, h)
    local COL

    if !self.HOVERED then
        COL = RDV.LIBRARY.GetConfigOption("LIBRARY_outlineTheme")
    else
        COL = RDV.LIBRARY.GetConfigOption("LIBRARY_hoverTheme")
    end

    surface.SetDrawColor(COL)
    surface.DrawOutlinedRect( 0, 0, w, h )
end
function PANEL:OnCursorEntered()
    surface.PlaySound(RDV.LIBRARY.GetConfigOption("LIBRARY_hoverSound"))

    self:SetTextColor(RDV.LIBRARY.GetConfigOption("LIBRARY_hoverTheme"))
    self.HOVERED = true
end

function PANEL:OnCursorExited()
    self:SetTextColor(color_white)
    self.HOVERED = false
end


vgui.Register("RDV_LIBRARY_TextButton", PANEL, "DButton")
--PATH lua/reality_development/libs/characters/list/sh_aden.lua:
return gluapack()()
--PATH lua/autorun/rsb.lua:
player_manager.AddValidModel( "navy rsb", 		"models/navy/gnavyrsb.mdl" );
list.Set( "PlayerOptionsModel", "navy rsb", 	"models/navy/gnavyrsb.mdl" );
--PATH lua/autorun/rw_cvars_dispencer.lua:
CreateConVar("rw_sw_dispenser_health", "950", 8192, "The amount of health of all dispencer")
CreateConVar("rw_sw_dispenser_timer", "2", 8192, "The cooldown between you can take ammo")
CreateConVar("rw_sw_dispenser_ammo_basic_count", "750", 8192, "The amount of basic ammo")
CreateConVar("rw_sw_dispenser_allammo_multiplier", "3", 8192, "The number of ammo given according to this multiplier of the clipsize")
CreateConVar("rw_sw_dispenser_ammo_crate_number", "5", 8192, "The number of ammo create you can throw with the swep")
CreateConVar("rw_sw_dispenser_heal_amount", "50", 8192, "The amount of heal and armor a dispencer can give")
CreateConVar("rw_sw_dispenser_max_armor", "200", 8192, "The limit of armor a dispencer can give")
--PATH addons/[admin] sam-160/lua/sam/libs/sh_mp.lua:
return gluapack()()
--PATH addons/[admin] sam-160/lua/sam/libs/sh_sfs.lua:
return gluapack()()
--PATH addons/[admin] sam-160/lua/sam/libs/sh_netstream.lua:
return gluapack()()
--PATH addons/[admin] sam-160/lua/sam/libs/sh_async_netstream.lua:
return gluapack()()
--PATH addons/[admin] sam-160/lua/sam_languages/english.lua:
return {
	You = "You",
	Yourself = "Yourself",
	Themself = "Themself",
	Everyone = "Everyone",

	cant_use_as_console = "You need to be a player to use {S Red} command!",
	no_permission = "You don't have permission to use '{S Red}'!",

	cant_target_multi_players = "You can't target multiple players using this command!",
	invalid_id = "Invalid id ({S Red})!",
	cant_target_player = "You can't target {S Red}!",
	cant_target_self = "You can't target your self using {S Red} command!",
	player_id_not_found = "Player with id {S Red} is not found!",
	found_multi_players = "Found multiple players: {T}!",
	cant_find_target = "Can't find a player to target ({S Red})!",

	invalid = "Invalid {S} ({S_2 Red})",
	default_reason = "none",

	menu_help = "Open admin mod menu.",

	-- Chat Commands
	pm_to = "PM to {T}: {V}",
	pm_from = "PM from {A}: {V}",
	pm_help = "Send a personal message (PM) to a player.",

	to_admins = "{A} to admins: {V}",
	asay_help = "Send a message to admins.",

	mute = "{A} muted {T} for {V}. ({V_2})",
	mute_help = "Stop player(s) from sending messages in chat.",

	unmute = "{A} unmuted {T}.",
	unmute_help = "Unmute player(s).",

	you_muted = "You are muted.",

	gag = "{A} gagged {T} for {V}. ({V_2})",
	gag_help = "Stop player(s) from speaking.",

	ungag = "{A} ungagged {T}.",
	ungag_help = "Ungag player(s).",

	-- Fun Commands
	slap = "{A} slapped {T}.",
	slap_damage = "{A} slapped {T} with {V} damage.",
	slap_help = "Slap asses.",

	slay = "{A} slayed {T}.",
	slay_help = "Slay player(s).",

	set_hp = "{A} set the hp for {T} to {V}.",
	hp_help = "Set health for player(s).",

	set_armor = "{A} set the armor for {T} to {V}.",
	armor_help = "Set armor for player(s).",

	ignite = "{A} ignited {T} for {V}.",
	ignite_help = "Ignite player(s).",

	unignite = "{A} extinguished {T}.",
	unignite_help = "Extinguish player(s).",

	god = "{A} enabled god mode for {T}.",
	god_help = "Enable god mode for player(s).",

	ungod = "{A} disabled god mode for {T}.",
	ungod_help = "Disable god mode for player(s).",

	freeze = "{A} froze {T}.",
	freeze_help = "Freeze player(s).",

	unfreeze = "{A} unfroze {T}.",
	unfreeze_help = "Unfreeze player(s).",

	cloak = "{A} cloaked {T}.",
	cloak_help = "Cloak player(s).",

	uncloak = "{A} uncloaked {T}.",
	uncloak_help = "Uncloak player(s).",

	jail = "{A} jailed {T} for {V}. ({V_2})",
	jail_help = "Jail player(s).",

	unjail = "{A} unjailed {T}.",
	unjail_help = "Unjail player(s).",

	strip = "{A} stripped weapons from {T}.",
	strip_help = "Strip weapons from player(s).",

	respawn = "{A} respawned {T}.",
	respawn_help = "Respawn player(s).",

	setmodel = "{A} set the model for {T} to {V}.",
	setmodel_help = "Change player(s)'s model.",

	giveammo = "{A} gave {T} {V} ammo.",
	giveammo_help = "Give player(s) ammo.",

	scale = "{A} set model scale for {T} to {V}.",
	scale_help = "Scale player(s).",

	freezeprops = "{A} froze all props.",
	freezeprops_help = "Freezes all props on the map.",

	-- Teleport Commands
	dead = "You are dead!",
	leave_car = "Leave the vehicle first!",

	bring = "{A} teleported {T}.",
	bring_help = "Bring a player.",

	goto = "{A} teleported to {T}.",
	goto_help = "Goto a player.",

	no_location = "No previous location to return {T} to.",
	returned = "{A} returned {T}.",
	return_help = "Return a player to where he was.",

	-- User Management Commands
	setrank = "{A} set the rank for {T} to {V} for {V_2}.",
	setrank_help = "Set a player's rank.",
	setrankid_help = "Set a player's rank by his steamid/steamid64.",

	addrank = "{A} created a new rank {V}.",
	addrank_help = "Create a new rank.",

	removerank = "{A} removed rank {V}.",
	removerank_help = "Remove a rank.",

	super_admin_access = "superadmin has access to everything!",

	giveaccess = "{A} granted access {V} to {T}.",
	givepermission_help = "Give permission to rank.",

	takeaccess = "{A} taken access {V} from {T}.",
	takepermission_help = "Take permission from rank.",

	renamerank = "{A} renamed rank {T} to {V}.",
	renamerank_help = "Rename rank.",

	changeinherit = "{A} changed the rank to inherit from for {T} to {V}.",
	changeinherit_help = "Change the rank to inherit from.",

	rank_immunity = "{A} changed rank {T}'s immunity to {V}.",
	changerankimmunity_help = "Change rank immunity.",

	rank_ban_limit = "{A} changed rank {T}'s ban limit to {V}.",
	changerankbanlimit_help = "Change rank ban limit.",

	changeranklimit = "{A} changed {V} limit for {T} to {V_2}.",
	changeranklimit_help = "Change rank limits.",

	-- Utility Commands
	map_change = "{A} changing the map to {V} in 10 seconds.",
	map_change2 = "{A} changing the map to {V} with gamemode {V_2} in 10 seconds.",
	map_help = "Change current map and gamemode.",

	map_restart = "{A} restarting the map in 10 seconds.",
	map_restart_help = "Restart current map.",

	mapreset = "{A} reset the map.",
	mapreset_help = "Reset the map.",

	kick = "{A} kicked {T} Reason: {V}.",
	kick_help = "Kick a player.",

	ban = "{A} banned {T} for {V} ({V_2}).",
	ban_help = "Ban a player.",

	banid = "{A} banned ${T} for {V} ({V_2}).",
	banid_help = "Ban a player using his steamid.",

	-- ban message when admin name doesn't exists
	ban_message = [[


		You are banned by: {S}

		Reason: {S_2}

		You will be unbanned in: {S_3}]],

	-- ban message when admin name exists
	ban_message_2 = [[


		You are banned by: {S} ({S_2})

		Reason: {S_3}

		You will be unbanned in: {S_4}]],

	unban = "{A} unbanned {T}.",
	unban_help = "Unban a player using his steamid.",

	noclip = "{A} has toggled noclip for {T}.",
	noclip_help = "Toggle noclip on player(s).",

	cleardecals = "{A} cleared ragdolls and decals for all players.",
	cleardecals_help = "Clear ragdolls and decals for all players.",

	stopsound = "{A} stopped all sounds.",
	stopsound_help = "Stop all sounds for all players.",

	not_in_vehicle = "You are not in a vehicle!",
	not_in_vehicle2 = "{S Blue} is not in a vehicle!",
	exit_vehicle = "{A} forced {T} to get out from a vehicle.",
	exit_vehicle_help = "Force a player out of a vehicle.",

	time_your = "Your total time is {V}.",
	time_player = "{T} total time is {V}.",
	time_help = "Check a player's time.",

	admin_help = "Activate admin mode.",
	unadmin_help = "Deactivate admin mode.",

	buddha = "{A} enabled buddha mode for {T}.",
	buddha_help = "Make player(s) godmoded when their health is 1.",

	unbuddha = "{A} disabled buddha mode for {T}.",
	unbuddha_help = "Disable buddha mode for player(s).",

	give = "{A} gave {T} {V}.",
	give_help = "Give player(s) weapon/entity",

	-- DarkRP Commands
	arrest = "{A} arrested {T} forever.",
	arrest2 = "{A} arrested {T} for {V} seconds.",
	arrest_help = "Arrest player(s).",

	unarrest = "{A} unarrested {T}.",
	unarrest_help = "Unarrest player(s).",

	setmoney = "{A} set money for {T} to {V}.",
	setmoney_help = "Set money for a player.",

	addmoney = "{A} added {V} for {T}.",
	addmoney_help = "Add money for a player.",

	door_invalid = "invalid door to sell.",
	door_no_owner = "no one owns this door.",

	selldoor = "{A} sold a door/vehicle for {T}.",
	selldoor_help = "Unown the door/vehicle you are looking at.",

	sellall = "{A} sold every door/vehicle for {T}.",
	sellall_help = "Sell every door/vehicle owned for a player.",

	s_jail_pos = "{A} set a new jail position.",
	setjailpos_help = "Resets all jail positions and sets a new one at your location.",

	a_jail_pos = "{A} added a new jail position.",
	addjailpos_help = "Adds a jail position at your current location.",

	setjob = "{A} set {T}'s job to {V}.",
	setjob_help = "Change a player's job.",

	shipment = "{A} spawned {V} shipment.",
	shipment_help = "Spawn a shipment.",

	forcename = "{A} set the name for {T} to {V}.",
	forcename_taken = "Name already taken. ({V})",
	forcename_help = "Force name for a player.",

	report_claimed = "{A} claimed a report submitted by {T}.",
	report_closed = "{A} closed a report submitted by {T}.",
	report_aclosed = "Your report is closed. (Time expired)",

	rank_expired = "{V} rank for {T} expired.",

	-- TTT Commands
	setslays = "{A} set amount of auto-slays for {T} to {V}.",
	setslays_help = "Set amount of rounds to auto-slay a player for.",

	setslays_slayed = "{T} got auto-slayed, slays left: {V}.",

	removeslays = "{A} removed auto-slays for {T}.",
	removeslays_help = "Remove auto-slays for a player."
}
--PATH addons/[admin] sam-160/lua/sam/ranks/sh_ranks.lua:
if SAM_LOADED then return end

SAM_IMMUNITY_SUPERADMIN = 100
SAM_IMMUNITY_ADMIN = 50
SAM_IMMUNITY_USER = 1

function sam.ranks.get_ranks()
	return sam.get_global("Ranks", {})
end

function sam.ranks.get_rank(rank)
	local ranks = sam.ranks.get_ranks()
	return ranks[rank]
end

function sam.ranks.is_rank(rank)
	if sam.ranks.get_rank(rank) then
		return true
	else
		return false
	end
end

function sam.ranks.is_default_rank(rank)
	return rank == "superadmin" or rank == "admin" or rank == "user"
end

function sam.ranks.inherits_from(rank, rank_2)
	if rank == rank_2 then
		return true
	end

	while true do
		rank = sam.ranks.get_rank(rank)

		if rank then
			local inherits_from = rank.inherit
			if inherits_from == rank_2 then
				return true
			end

			rank = rank.inherit
		else
			return false
		end
	end
end

function sam.ranks.has_permission(rank, permission)
	while true do
		if rank == "superadmin" then
			return true
		end

		rank = sam.ranks.get_rank(rank)

		if rank then
			local rank_permission = rank.data.permissions[permission]
			if rank_permission ~= nil then
				return rank_permission
			end

			rank = rank.inherit
		else
			return false
		end
	end
end

function sam.ranks.get_limit(rank, limit_type)
	while true do
		if rank == "superadmin" then return -1 end

		rank = sam.ranks.get_rank(rank)

		if rank then
			local limit = rank.data.limits[limit_type]
			if limit ~= nil then
				return limit
			end

			rank = rank.inherit
		else
			return cvars.Number("sbox_max" .. limit_type, 0)
		end
	end
end

function sam.ranks.get_immunity(rank)
	rank = sam.ranks.get_rank(rank)
	return rank and rank.immunity or false
end

function sam.ranks.can_target(rank_1, rank_2)
	rank_1, rank_2 = sam.ranks.get_rank(rank_1), sam.ranks.get_rank(rank_2)
	if not rank_1 or not rank_2 then
		return false
	end
	return rank_1.immunity >= rank_2.immunity
end

function sam.ranks.get_ban_limit(rank)
	rank = sam.ranks.get_rank(rank)
	return rank and rank.ban_limit or false
end

if CLIENT then
	hook.Add("SAM.ChangedGlobalVar", "SAM.Ranks.CheckLoadedRanks", function(key, value)
		if key == "Ranks" then
			hook.Call("SAM.LoadedRanks", nil, value)
			hook.Remove("SAM.ChangedGlobalVar", "SAM.Ranks.CheckLoadedRanks")
		end
	end)
end

--PATH addons/[admin] sam-160/lua/sam/config/cl_config.lua:
return gluapack()()
--PATH addons/[admin] sam-160/lua/sam/command/sh_command.lua:
if SAM_LOADED then return end

local sam = sam
local istable, isstring = sam.istable, sam.isstring

local commands = {}
local arguments = {}

do
	local command = {}

	local current_category = "other"
	function command.set_category(category)
		if isstring(category) then
			current_category = category
		end
	end

	function command.get_commands()
		return commands
	end

	function command.get_command(name)
		for i = 1, #commands do
			local cmd = commands[i]
			if cmd.name == name then
				return cmd, i
			end

			local aliases = cmd.aliases
			for i2 = 1, #aliases do
				local alias = aliases[i2]
				if alias == name then
					return cmd, i
				end
			end
		end
		return false
	end

	function command.remove_command(name)
		local cmd, index = command.get_command(name)
		if index then
			table.remove(commands, index)
			hook.Call("SAM.CommandRemoved", nil, cmd.name, cmd, index)
			return index
		end
		return false
	end

	function command.get_arguments()
		return arguments
	end

	do
		local argument_methods = {
			OnExecute = function(self, func)
				if isfunction(func) and SERVER then
					self.on_execute = func
				end
				return self
			end,
			Menu = function(self, func)
				if isfunction(func) and CLIENT then
					self.menu = func
				end
				return self
			end,
			AutoComplete = function(self, func)
				if isfunction(func) and CLIENT then
					self.auto_complete = func
				end
				return self
			end,
			End = function(self)
				if SERVER then
					arguments[self.name] = self.on_execute
				else
					arguments[self.name] = self
				end
			end
		}

		local argument_meta = {__index = argument_methods}
		function command.new_argument(name)
			if isstring(name) then
				return setmetatable({name = name}, argument_meta)
			end
		end
	end

	if CLIENT then
		function command.run_commands(to_run)
			local time = 0
			for i = 1, #to_run do
				timer.Simple(time, function()
					RunConsoleCommand("sam", unpack(to_run[i]))
				end)
				time = time + 0.76
			end
		end
	end

	--
	-- Methods
	--
	local Command_Methods = {}
	local Command_meta = {__index = Command_Methods}

	function command.new(cmd)
		if not isstring(cmd) then return end

		local new_command = setmetatable({}, Command_meta)
		new_command.can_console_run = true
		new_command.args = {}
		new_command.name = cmd:lower()
		new_command.aliases = {}
		new_command.category = current_category

		return new_command
	end

	local AddMethod = function(name, func)
		Command_Methods[name] = func
	end

	AddMethod("Aliases", function(self, ...)
		for k, v in ipairs({...}) do
			table.insert(self.aliases, v)
		end
		return self
	end)

	AddMethod("AddArg", function(self, name, data)
		if not isstring(name) then return end
		if not istable(data) then
			data = {}
		end
		data.name = name
		table.insert(self.args, data)
		return self
	end)

	AddMethod("DisallowConsole", function(self, disallow)
		self.can_console_run = isbool(disallow) and disallow or false
		return self
	end)

	AddMethod("SetCategory", function(self, category)
		if isstring(category) then
			self.category = category
		end
		return self
	end)

	AddMethod("Help", function(self, help)
		if isstring(help) then
			self.help = sam.language.get(help) or help
		end
		return self
	end)

	AddMethod("OnExecute", function(self, func)
		if isfunction(func) and SERVER then
			self.on_execute = func
		end
		return self
	end)

	AddMethod("SetPermission", function(self, perm, default_rank)
		if isstring(perm) then
			self.permission = perm
			self.default_rank = default_rank
		end
		return self
	end)

	AddMethod("GetRestArgs", function(self, get)
		if not isbool(get) then
			get = true
		end
		self.get_rest_args = get
		return self
	end)

	AddMethod("MenuHide", function(self, should_hide)
		if isbool(should_hide) then
			self.menu_hide = should_hide
		else
			self.menu_hide = true
		end
		return self
	end)

	AddMethod("DisableNotify", function(self, disable)
		if isbool(disable) then
			self.disable_notify = disable
		else
			self.disable_notify = true
		end
		return self
	end)

	AddMethod("End", function(self)
		local name = self.name
		if SERVER and not self.on_execute then
			sam.print("need an OnExecute function for the command!")
			debug.Trace()
			return
		end

		if self.permission then
			sam.permissions.add(self.permission, "Commands - " .. self.category, self.default_rank)
		end

		local _, index = command.get_command(name)
		if index then
			commands[index] = self
			hook.Call("SAM.CommandModified", nil, name, self, index)
		else
			hook.Call("SAM.CommandAdded", nil, name, self, table.insert(commands, self))
		end
	end)

	AddMethod("GetRequiredArgs", function(self)
		local required_args = {}
		local args = self.args
		for i = 1, #args do
			local v = args[i]
			if not v.optional then
				table.insert(required_args, v)
			end
		end
		return required_args
	end)

	AddMethod("GetOptionalArgs", function(self)
		local optional_args = {}
		local args = self.args
		for i = 1, #args do
			local v = args[i]
			if v.optional then
				table.insert(optional_args, v)
			end
		end
		return optional_args
	end)

	AddMethod("ArgsToString", function(self, return_table)
		local str_table = {}
		local args = self.args
		for i = 1, #self.args do
			local v = args[i]
			if not v.optional then
				table.insert(str_table, "<" .. (v.hint or v.name) .. ">")
			else
				table.insert(str_table, "[" .. (v.hint or v.name) .. "]")
			end
		end
		return return_table and str_table or table.concat(str_table, " ")
	end)

	AddMethod("HasArg", function(self, arg)
		local args = self.args
		for i = 1, #self.args do
			if args[i].name == arg then
				return true
			end
		end
		return false
	end)

	command.add_method = AddMethod

	sam.command = command
end

sam.__commands = commands
sam.__arguments = arguments
--PATH addons/[lib] sui/lua/sui/libs/bshadows.lua:
return gluapack()()
--PATH addons/[lib] sui/lua/sui/vgui/sui_label_panel.lua:
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local LABEL_FONT = SUI.CreateFont("LabelPanel", "Roboto", 18)

local PANEL = {}

local add = function(s, c)
	if IsValid(s.pnl) then
		s.pnl:Remove()
	end

	local pnl = vgui.Create(c, s)
	s.pnl = pnl

	return pnl
end

function PANEL:Init()
	self.title = ""

	local label = self:Add(NAME .. ".Label")
	label:Dock(LEFT)
	self.label = label

	self:SetFont(LABEL_FONT)

	self:Dock(TOP)
	self:InvalidateLayout(true)
	self.Add = add
end

function PANEL:SetPanel(pnl)
	if IsValid(self.pnl) then
		self.pnl:Remove()
	end

	pnl:SetParent(self)
	self.pnl = pnl
end

function PANEL:SetLabel(lbl)
	self.title = lbl
	self:InvalidateLayout(true)
end

function PANEL:SetFont(font)
	self.font = font
	self.label:SetFont(font)
end

function PANEL:PerformLayout(w, h)
	local label = self.label
	local pnl = self.pnl

	local pnl_w, pnl_h = 0, 0
	if pnl then
		pnl_w, pnl_h = pnl:GetSize()
	end

	label:SetWide(w - pnl_w - 4)
	label:SetText(sui.wrap_text(self.title, self.font, w - pnl_w - 4))

	local _, _h = label:GetTextSize()
	self:SetTall(math.max(_h, pnl_h))

	if pnl then
		pnl:SetPos(w - pnl_w, h / 2 - pnl_h / 2)
	end
end

sui.register("LabelPanel", PANEL, "PANEL")
--PATH addons/[lib] sui/lua/sui/vgui/sui_toggle_button.lua:
local Lerp = Lerp
local FrameTime = FrameTime

local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name
local TDLib = sui.TDLib

local Panel = {}

sui.scaling_functions(Panel)

function Panel:Init()
	self:ScaleInit()

	local rounded_box = {}
	local switch_circle = {}
	function self:Paint(w, h)
		local is_checked = self:GetChecked()

		local _h = SUI.Scale(14)
		TDLib.RoundedBox(rounded_box, _h, 0, h / 2 - _h / 2, w, _h, is_checked and SUI.GetColor("toggle_button_active") or SUI.GetColor("toggle_button"))

		local size = h - 2
		do
			local pos = is_checked and (w - (size / 2)) or (h / 2 - 1)
			if self.pos then
				self.pos = Lerp(FrameTime() * 12, self.pos, pos)
			else
				self.pos = pos
			end
		end

		TDLib.DrawCircle(switch_circle, self.pos, h / 2, size / 2, is_checked and SUI.GetColor("toggle_button_switch_active") or SUI.GetColor("toggle_button_switch"))
	end

	self:SetSize(34, 20)
end

sui.register("ToggleButton", Panel, "DCheckBox")
--PATH addons/[admin] sam-160/lua/sui/vgui/sam_player_line.lua:
return gluapack()()
--PATH addons/[admin] sam-160/lua/sam/menu/tabs/config.lua:
if SAM_LOADED then return end

local sam = sam
local config = sam.config

local tabs = {}
if CLIENT then
	function config.add_tab(name, func, check, pos)
		local tab = {
			name = name,
			func = func,
			check = check,
			pos = pos
		}
		for k, v in ipairs(tabs) do
			if v.name == name then
				tabs[k] = tab
				return
			end
		end
		table.insert(tabs, tab)
	end
end

for _, f in ipairs(file.Find("sam/menu/tabs/config/*.lua", "LUA")) do
	sam.load_file("sam/menu/tabs/config/" .. f, "cl_")
end

if SERVER then return end

local SUI = sam.SUI
local GetColor = SUI.GetColor
local Line = sui.TDLib.LibClasses.Line

sam.menu.add_tab("https://raw.githubusercontent.com/Srlion/Addons-Data/main/icons/sam/config.png", function(column_sheet)
	local tab_body = column_sheet:Add("Panel")
	tab_body:Dock(FILL)
	tab_body:DockMargin(0, 1, 0, 0)

	do
		local title = tab_body:Add("SAM.Label")
		title:Dock(TOP)
		title:DockMargin(10, 10, 0, 0)
		title:SetFont(SAM_TAB_TITLE_FONT)
		title:SetText("Config")
		title:SetTextColor(GetColor("menu_tabs_title"))
		title:SizeToContents()

		local total = tab_body:Add("SAM.Label")
		total:Dock(TOP)
		total:DockMargin(10, 6, 0, 0)
		total:SetFont(SAM_TAB_DESC_FONT)
		total:SetText("Some settings may require a server restart")
		total:SetTextColor(GetColor("menu_tabs_title"))
		total:SetPos(10, SUI.Scale(40))
		total:SizeToContents()
	end

	local body = tab_body:Add("Panel")
	body:Dock(FILL)
	body:DockMargin(10, 5, 10, 10)

	Line(body, nil, 0, 0, 0, 10)

	local sheet = body:Add("SAM.PropertySheet")
	sheet:Dock(FILL)
	sheet:InvalidateParent(true)
	sheet:InvalidateLayout(true)

	local sheets = {}
	for _, v in SortedPairsByMemberValue(tabs, "pos") do
		sheets[v.name] = sheet:AddSheet(v.name, v.func)
	end

	local tab_scroller = sheet.tab_scroller:GetCanvas()
	function tab_body.Think()
		for _, v in ipairs(tabs) do
			local tab = sheets[v.name]
			if v.check and not v.check() then
				if tab:IsVisible() then
					tab:SetVisible(false)
					if sheet:GetActiveTab() == tab then
						sheet:SetActiveTab(sheet.tabs[1])
					end
					tab_scroller:InvalidateLayout()
				end
			elseif not tab:IsVisible() then
				tab:SetVisible(true)
				tab_scroller:InvalidateLayout()
			end
		end
	end

	return tab_body
end, function()
	return LocalPlayer():HasPermission("manage_config")
end, 5)
--PATH addons/[admin] sam-160/lua/sam/modules/darkrp.lua:
if SAM_LOADED then return end

local add = not GAMEMODE and hook.Add or function(_, _, fn)
	fn()
end

add("PostGamemodeLoaded", "SAM.DarkRP", function()
	if not DarkRP then return end

	local sam, command, language = sam, sam.command, sam.language

	command.set_category("DarkRP")

	command.new("arrest")
		:SetPermission("arrest", "superadmin")

		:AddArg("player")
		:AddArg("number", {hint = "time", optional = true, min = 0, default = 0, round = true})

		:Help("arrest_help")

		:OnExecute(function(ply, targets, time)
			if time == 0 then
				time = math.huge
			end

			for i = 1, #targets do
				local v = targets[i]
				if v:isArrested() then
					v:unArrest()
				end
				v:arrest(time, ply)
			end

			if time == math.huge then
				sam.player.send_message(nil, "arrest", {
					A = ply, T = targets
				})
			else
				sam.player.send_message(nil, "arrest2", {
					A = ply, T = targets, V = time
				})
			end
		end)
	:End()

	command.new("unarrest")
		:SetPermission("unarrest", "superadmin")

		:AddArg("player", {optional = true})

		:Help("unarrest_help")

		:OnExecute(function(ply, targets)
			for i = 1, #targets do
				targets[i]:unArrest()
			end

			sam.player.send_message(nil, "unarrest", {
				A = ply, T = targets
			})
		end)
	:End()

	command.new("setmoney")
		:SetPermission("setmoney", "superadmin")

		:AddArg("player", {single_target = true})
		:AddArg("number", {hint = "amount", min = 0, round = true})

		:Help("setmoney_help")

		:OnExecute(function(ply, targets, amount)
			local target = targets[1]

			amount = hook.Call("playerWalletChanged", GAMEMODE, target, amount - target:getDarkRPVar("money"), target:getDarkRPVar("money")) or amount

			DarkRP.storeMoney(target, amount)
			target:setDarkRPVar("money", amount)

			sam.player.send_message(nil, "setmoney", {
				A = ply, T = targets, V = amount
			})
		end)
	:End()

	command.new("addmoney")
		:SetPermission("addmoney", "superadmin")

		:AddArg("player", {single_target = true})
		:AddArg("number", {hint = "amount", min = 0, round = true})

		:Help("addmoney_help")

		:OnExecute(function(ply, targets, amount)
			targets[1]:addMoney(amount)

			sam.player.send_message(nil, "addmoney", {
				A = ply, T = targets, V = DarkRP.formatMoney(amount)
			})
		end)
	:End()

	command.new("selldoor")
		:SetPermission("selldoor", "superadmin")

		:Help("selldoor_help")

		:OnExecute(function(ply)
			local ent = ply:GetEyeTrace().Entity
			if not IsValid(ent) or not ent.keysUnOwn then
				return ply:sam_send_message("door_invalid")
			end
			local door_owner = ent:getDoorOwner()
			if not IsValid(door_owner) then
				return ply:sam_send_message("door_no_owner")
			end
			ent:keysUnOwn(ply)

			sam.player.send_message(nil, "selldoor", {
				A = ply, T = {door_owner, admin = ply}
			})
		end)
	:End()

	command.new("sellall")
		:SetPermission("sellall", "superadmin")

		:AddArg("player", {single_target = true})

		:Help("sellall_help")

		:OnExecute(function(ply, targets, amount)
			targets[1]:keysUnOwnAll()

			sam.player.send_message(nil, "sellall", {
				A = ply, T = targets
			})
		end)
	:End()

	command.new("setjailpos")
		:SetPermission("setjailpos", "superadmin")

		:Help("setjailpos_help")

		:OnExecute(function(ply)
			DarkRP.storeJailPos(ply, false)

			sam.player.send_message(nil, "s_jail_pos", {
				A = ply
			})
		end)
	:End()

	command.new("addjailpos")
		:SetPermission("addjailpos", "superadmin")

		:Help("addjailpos_help")

		:OnExecute(function(ply)
			DarkRP.storeJailPos(ply, true)

			sam.player.send_message(nil, "a_jail_pos", {
				A = ply
			})
		end)
	:End()

	local RPExtraTeams = RPExtraTeams
	local job_index = nil

	command.new("setjob")
		:SetPermission("setjob", "admin")

		:AddArg("player")
		:AddArg("text", {hint = "job", check = function(job)
			job = job:lower()

			for i = 1, #RPExtraTeams do
				local v = RPExtraTeams[i]
				if v.name:lower() == job or v.command:lower() == job then
					job_index = v.team
					return true
				end
			end

			return false
		end})

		:Help("setjob_help")

		:OnExecute(function(ply, targets, job)
			for i = 1, #targets do
				targets[i]:changeTeam(job_index, true, true, true)
			end

			sam.player.send_message(nil, "setjob", {
				A = ply, T = targets, V = job
			})
		end)
	:End()

	do
		local get_shipment = function(name)
			local found, key = DarkRP.getShipmentByName(name)
			if found then return found, key end

			name = name:lower()

			local shipments = CustomShipments
			for i = 1, #shipments do
				local shipment = shipments[i]
				if shipment.entity == name then
					return DarkRP.getShipmentByName(shipment.name)
				end
			end

			return false
		end

		local place_entity = function(ent, tr, ply)
			local ang = ply:EyeAngles()
			ang.pitch = 0
			ang.yaw = ang.yaw - 90
			ang.roll = 0
			ent:SetAngles(ang)

			local flush_point = tr.HitPos - (tr.HitNormal * 512)
			flush_point = ent:NearestPoint(flush_point)
			flush_point = ent:GetPos() - flush_point
			flush_point = tr.HitPos + flush_point
			ent:SetPos(flush_point)
		end

		command.new("shipment")
			:SetPermission("shipment", "superadmin")

			:AddArg("text", {hint = "weapon", check = get_shipment})

			:Help("shipment_help")

			:OnExecute(function(ply, weapon_name)
				local trace = {}
				trace.start = ply:EyePos()
				trace.endpos = trace.start + ply:GetAimVector() * 85
				trace.filter = ply
				local tr = util.TraceLine(trace)

				local shipment_info, shipment_key = get_shipment(weapon_name)

				local crate = ents.Create(shipment_info.shipmentClass or "spawned_shipment")
				crate.SID = ply.SID

				crate:Setowning_ent(ply)
				crate:SetContents(shipment_key, shipment_info.amount)

				crate:SetPos(Vector(tr.HitPos.x, tr.HitPos.y, tr.HitPos.z))

				crate.nodupe = true
				crate.ammoadd = shipment_info.spareammo
				crate.clip1 = shipment_info.clip1
				crate.clip2 = shipment_info.clip2

				crate:Spawn()
				crate:SetPlayer(ply)

				place_entity(crate, tr, ply)

				local phys = crate:GetPhysicsObject()
				phys:Wake()

				if shipment_info.weight then
					phys:SetMass(shipment_info.weight)
				end

				sam.player.send_message(nil, "shipment", {
					A = ply, V = weapon_name
				})
			end)
		:End()
	end

	sam.command.new("forcename")
		:SetPermission("forcename", "superadmin")

		:AddArg("player")
		:AddArg("text", {hint = "name"})

		:Help("forcename_help")

		:OnExecute(function(ply, targets, name)
			local target = targets[1]

			DarkRP.retrieveRPNames(name, function(taken)
				if not IsValid(target) then return end

				if taken then
					ply:sam_send_message("forcename_taken", {
						V = name
					})
					return
				end

				sam.player.send_message(nil, "forcename", {
					A = ply, T = targets, V = name
				})

				DarkRP.storeRPName(target, name)
				target:setDarkRPVar("rpname", name)
			end)
		end)
	:End()
end)
--PATH addons/[admin] sam-160/lua/sam/modules/murder.lua:
return gluapack()()
--PATH addons/[admin] sam-160/lua/sam/modules/support_cami.lua:
return gluapack()()
--PATH addons/[admin] sam-160/lua/sam/modules/util.lua:
if SAM_LOADED then return end

local sam, command, language = sam, sam.command, sam.language

command.set_category("Utility")

command.new("map")
	:SetPermission("map", "admin")

	:AddArg("map")
	:AddArg("text", {hint = "gamemode", optional = true, check = sam.is_valid_gamemode})

	:Help("map_help")

	:OnExecute(function(ply, map, gamemode)
		if not gamemode then
			sam.player.send_message(nil, "map_change", {
				A = ply, V = map
			})
		else
			sam.player.send_message(nil, "map_change2", {
				A = ply, V = map, V_2 = gamemode
			})
			RunConsoleCommand("gamemode", gamemode)
		end

		if #player.GetHumans() == 0 then
			RunConsoleCommand("changelevel", map)
		else
			timer.Create("SAM.Command.Map", 10, 1, function()
				RunConsoleCommand("changelevel", map)
			end)
		end
	end)
:End()

command.new("maprestart")
	:SetPermission("maprestart", "admin")

	:Help("map_restart_help")

	:OnExecute(function(ply)
		if #player.GetHumans() == 0 then
			RunConsoleCommand("changelevel", game.GetMap())
		else
			timer.Create("SAM.Command.MapRestart", 10, 1, function()
				RunConsoleCommand("changelevel", game.GetMap())
			end)

			sam.player.send_message(nil, "map_restart", {
				A = ply
			})
		end
	end)
:End()

command.new("mapreset")
	:SetPermission("mapreset", "admin")

	:Help("mapreset_help")

	:OnExecute(function(ply)
		game.CleanUpMap()

		sam.player.send_message(nil, "mapreset", {
			A = ply
		})
	end)
:End()

command.new("kick")
	:SetPermission("kick", "admin")

	:AddArg("player", {single_target = true})
	:AddArg("text", {hint = "reason", optional = true, default = sam.language.get("default_reason")})

	:GetRestArgs()

	:Help("kick_help")

	:OnExecute(function(ply, targets, reason)
		local target = targets[1]
		target:Kick(reason)

		sam.player.send_message(nil, "kick", {
			A = ply, T = target:Name(), V = reason
		})
	end)
:End()

command.new("ban")
	:SetPermission("ban", "admin")

	:AddArg("player", {single_target = true})
	:AddArg("length", {optional = true, default = 0})
	:AddArg("text", {hint = "reason", optional = true, default = sam.language.get("default_reason")})

	:GetRestArgs()

	:Help("ban_help")

	:OnExecute(function(ply, targets, length, reason)
		local target = targets[1]
		if ply:GetBanLimit() ~= 0 then
			if length == 0 then
				length = ply:GetBanLimit()
			else
				length = math.Clamp(length, 1, ply:GetBanLimit())
			end
		end
		target:sam_ban(length, reason, ply:SteamID())

		sam.player.send_message(nil, "ban", {
			A = ply, T = target:Name(), V = sam.format_length(length), V_2 = reason
		})
	end)
:End()

command.new("banid")
	:SetPermission("banid", "admin")

	:AddArg("steamid")
	:AddArg("length", {optional = true, default = 0})
	:AddArg("text", {hint = "reason", optional = true, default = sam.language.get("default_reason")})

	:GetRestArgs()

	:Help("banid_help")

	:OnExecute(function(ply, promise, length, reason)
		local a_steamid, a_name, a_ban_limit = ply:SteamID(), ply:Name(), ply:GetBanLimit()

		promise:done(function(data)
			local steamid, target = data[1], data[2]

			if a_ban_limit ~= 0 then
				if length == 0 then
					length = a_ban_limit
				else
					length = math.Clamp(length, 1, a_ban_limit)
				end
			end

			if target then
				target:sam_ban(length, reason, a_steamid)

				sam.player.send_message(nil, "ban", {
					A = a_name, T = target:Name(), V = sam.format_length(length), V_2 = reason
				})
			else
				sam.player.ban_id(steamid, length, reason, a_steamid)

				sam.player.send_message(nil, "banid", {
					A = a_name, T = steamid, V = sam.format_length(length), V_2 = reason
				})
			end
		end)
	end)
:End()

command.new("unban")
	:SetPermission("unban", "admin")

	:AddArg("steamid", {allow_higher_target = true})

	:Help("unban_help")

	:OnExecute(function(ply, steamid, reason)
		sam.player.unban(steamid, ply:SteamID())

		sam.player.send_message(nil, "unban", {
			A = ply, T = steamid
		})
	end)
:End()

do
	command.new("noclip")
		:SetPermission("noclip", "admin")

		:AddArg("player", {optional = true})

		:Help("noclip_help")

		:OnExecute(function(ply, targets)
			local id
			for i = 1, #targets do
				local v = targets[i]
				v:SetMoveType(v:GetMoveType() == MOVETYPE_WALK and MOVETYPE_NOCLIP or MOVETYPE_WALK)
				if v == ply then
					id = i
				end
			end

			if id then
				table.remove(targets, id)
				if #targets == 0 then return end
			end

			sam.player.send_message(nil, "noclip", {
				A = ply, T = targets
			})
		end)
	:End()

	sam.permissions.add("can_noclip", nil, "admin")

	hook.Add("PlayerNoClip", "SAM.CanNoClip", function(ply)
		if ply:HasPermission("can_noclip") then
			return true
		end
	end)
end

do
	local config = sam.config

	sam.permissions.add("can_physgun_players", nil, "admin")

	if CLIENT then
		local add_setting = function(body, title, key)
			local setting = body:Add("SAM.LabelPanel")
			setting:Dock(TOP)
			setting:SetLabel(title)

			local enable = setting:Add("SAM.ToggleButton")
			enable:SetConfig(key, true)

			return setting
		end

		config.add_menu_setting("Physgun", function(body)
			local setting_body

			do
				local p = add_setting(body, "Physgun (Enable/Disable all physgun features except picking up players)", "Physgun.Enabled")
				p:DockMargin(8, 6, 8, 0)
			end

			setting_body = body:Add("Panel")
			setting_body:Dock(TOP)
			setting_body:DockMargin(8, 6, 8, 0)
			setting_body:DockPadding(8, 0, 8, 0)

			add_setting(setting_body, "No fall damage on drop", "Physgun.NoFallDamageOnDrop")
			add_setting(setting_body, "Right click to freeze players", "Physgun.RightClickToFreeze")
			add_setting(setting_body, "Reset Velocity to fix some issues when players fall", "Physgun.ResetVelocity")

			function setting_body:PerformLayout()
				setting_body:SizeToChildren(false, true)
			end
		end)
	end

	local freeze_player = function(ply)
		if SERVER then
			ply:Lock()
		end
		ply:SetMoveType(MOVETYPE_NONE)
		ply:SetCollisionGroup(COLLISION_GROUP_WORLD)
	end

	sam.hook_first("PhysgunPickup", "SAM.CanPhysgunPlayer", function(ply, target)
		if sam.type(target) == "Player" and ply:HasPermission("can_physgun_players") and ply:CanTarget(target) then
			freeze_player(target)
			return true
		end
	end)

	local load_phygun_settings = function()
		hook.Remove("PhysgunDrop", "SAM.PhysgunDrop")
		hook.Remove("OnPlayerHitGround", "SAM.PhysgunDropOnPlayerHitGround")

		if config.get("Physgun.Enabled", true) == false then
			return
		end

		local right_click_to_freeze = config.get("Physgun.RightClickToFreeze", true)
		local reset_velocity = config.get("Physgun.ResetVelocity", true)
		hook.Add("PhysgunDrop", "SAM.PhysgunDrop", function(ply, target)
			if sam.type(target) ~= "Player" then return end

			if right_click_to_freeze and ply:KeyPressed(IN_ATTACK2) then
				freeze_player(target)

				if SERVER then
					target:sam_set_nwvar("frozen", true)
					target:sam_set_exclusive("frozen")
				end
			else
				if reset_velocity then
					target:SetLocalVelocity(Vector(0, 0, 0))
				end

				if SERVER then
					target:UnLock()
					target:sam_set_nwvar("frozen", false)
					target:sam_set_exclusive(nil)

					if target.sam_has_god_mode then
						target:GodEnable()
					end

					target.sam_physgun_drop_was_frozen = not target:IsOnGround()
				end

				target:SetMoveType(MOVETYPE_WALK)
				target:SetCollisionGroup(COLLISION_GROUP_PLAYER)
			end
		end)

		if config.get("Physgun.NoFallDamageOnDrop", true) then
			hook.Add("OnPlayerHitGround", "SAM.PhysgunDropOnPlayerHitGround", function(ply)
				if ply.sam_physgun_drop_was_frozen then
					ply.sam_physgun_drop_was_frozen = false
					return true
				end
			end)
		end
	end

	config.hook({"Physgun.Enabled", "Physgun.RightClickToFreeze", "Physgun.ResetVelocity", "Physgun.NoFallDamageOnDrop"}, load_phygun_settings)
end

do
	command.new("cleardecals")
		:SetPermission("cleardecals", "admin")
		:Help("cleardecals_help")

		:OnExecute(function(ply)
			sam.netstream.Start(nil, "cleardecals")

			sam.player.send_message(nil, "cleardecals", {
				A = ply
			})
		end)
	:End()

	if CLIENT then
		sam.netstream.Hook("cleardecals", function()
			game.RemoveRagdolls()
			RunConsoleCommand("r_cleardecals")
		end)
	end
end

do
	command.new("stopsound")
		:SetPermission("stopsound", "admin")
		:Help("stopsound_help")

		:OnExecute(function(ply)
			sam.netstream.Start(nil, "stopsound")

			sam.player.send_message(nil, "stopsound", {
				A = ply
			})
		end)
	:End()

	if CLIENT then
		sam.netstream.Hook("stopsound", function()
			RunConsoleCommand("stopsound")
		end)
	end
end

command.new("exit")
	:SetPermission("exit_vehicle", "admin")

	:AddArg("player", {single_target = true})

	:Help("exit_vehicle_help")

	:OnExecute(function(ply, targets)
		local target = targets[1]

		if not target:InVehicle() then
			if ply == target then
				return ply:sam_send_message("not_in_vehicle")
			else
				return ply:sam_send_message("not_in_vehicle2", {
					S = target:Name()
				})
			end
		end

		target:ExitVehicle()

		sam.player.send_message(nil, "exit_vehicle", {
			A = ply, T = targets
		})
	end)
:End()

command.new("time")
	:SetPermission("time", "user")

	:AddArg("player", {single_target = true, optional = true})

	:Help("time_help")

	:OnExecute(function(ply, targets)
		if ply == targets[1] then
			sam.player.send_message(ply, "time_your", {
				V = sam.reverse_parse_length(targets[1]:sam_get_play_time() / 60)
			})
		else
			sam.player.send_message(ply, "time_player", {
				T = targets, V = sam.reverse_parse_length(targets[1]:sam_get_play_time() / 60)
			})
		end
	end)
:End()

command.new("admin")
	:SetPermission("admin_mode", "admin")

	:Help("admin_help")

	:OnExecute(function(ply)
		ply:sam_cloak()
		ply:GodEnable()
		ply:SetMoveType(MOVETYPE_NOCLIP)
	end)
:End()

command.new("unadmin")
	:SetPermission("admin_mode", "admin")

	:Help("unadmin_help")

	:OnExecute(function(ply)
		ply:sam_uncloak()
		ply:GodDisable()
		ply:SetMoveType(MOVETYPE_WALK)
	end)
:End()

do
	command.new("buddha")
		:SetPermission("buddha", "admin")

		:AddArg("player", {optional = true})

		:Help("buddha_help")

		:OnExecute(function(ply, targets)
			for i = 1, #targets do
				targets[i].sam_buddha = true
			end

			sam.player.send_message(nil, "buddha", {
				A = ply, T = targets
			})
		end)
	:End()

	command.new("unbuddha")
		:SetPermission("buddha", "admin")

		:AddArg("player", {optional = true})

		:Help("unbuddha_help")

		:OnExecute(function(ply, targets)
			for i = 1, #targets do
				targets[i].sam_buddha = nil
			end

			sam.player.send_message(nil, "unbuddha", {
				A = ply, T = targets
			})
		end)
	:End()

	if SERVER then
		hook.Add("EntityTakeDamage", "SAM.BuddhaMode", function(ply, info)
			if ply.sam_buddha and ply:Health() - info:GetDamage() <= 0 then
				ply:SetHealth(1)
				return true
			end
		end)
	end
end

command.new("give")
	:SetPermission("give", "superadmin")

	:AddArg("player")
	:AddArg("text", {hint = "weapon/entity"})

	:Help("give_help")

	:OnExecute(function(ply, targets, weapon)
		for i = 1, #targets do
			targets[i]:Give(weapon)
		end

		sam.player.send_message(nil, "give", {
			A = ply, T = targets, V = weapon
		})
	end)
:End()

-- do
-- 	if CLIENT then
-- 		sam.netstream.Hook("GetFriends", function()
-- 			local friends = {}
-- 			local humans = player.GetHumans()
-- 			for i = 1, #humans do
-- 				local human = humans[i]
-- 				if human:GetFriendStatus() == "friend" then
-- 					table.insert(friends, human)
-- 				end
-- 			end
-- 			netstream.Start("GetFriends", friends)
-- 		end)
-- 	else
-- 		hook.Add("SAM.AuthedPlayer", "GetPlayerFriends", function(ply)
-- 			timer.Simple(0, function()
-- 				ply.sam_requesting_friends = true
-- 				netstream.Start(ply, "GetFriends")
-- 			end)
-- 		end)

-- 		local invalid_friends = function(ply, friends, new_list)
-- 			if not sam.istable(friends) then return true end

-- 			local count = #friends
-- 			local max_players = game.MaxPlayers()
-- 			for k, friend in pairs(friends) do
-- 				if not sam.isnumber(k) then return true end
-- 				if not sam.isentity(friend) then return true end
-- 				if k > max_players then return true end
-- 				if k > count then return true end

-- 				if IsValid(friend) then
-- 					table.insert(new_list, friend)
-- 				end
-- 			end
-- 		end

-- 		sam.netstream.Hook("GetFriends", function(ply, friends)
-- 			local new_list = {}
-- 			if invalid_friends(ply, friends, new_list) then
-- 				ply.sam_friends_invalid = true
-- 				return
-- 			end
-- 			ply.sam_friends = new_list
-- 		end, function()
-- 			return ply.sam_requesting_friends
-- 		end)
-- 	end

-- 	command.new("friends")
-- 		:SetPermission("friends", "superadmin")

-- 		:AddArg("player", {single_target = true})

-- 		:Help(language.get("friends_help"))

-- 		:OnExecute(function(ply, targets)
-- 			local target = targets[1]
-- 			target.sam_friends_requests = target.sam_friends_requests or {}
-- 			target.sam_friends_requests[ply] = true
-- 		end)
-- 	:End()
-- end
--PATH lua/autorun/savage.lua:
return gluapack()()
--PATH addons/[lib] sui/lua/sui/libs/gif_loader.lua:
return gluapack()()
--PATH addons/[lib] sui/lua/sui/libs/png_encoder.lua:
return gluapack()()
--PATH addons/[lib] sui/lua/sui/vgui/sui_scroll_panel.lua:
return gluapack()()
--PATH addons/[lib] sui/lua/sui/vgui/sui_slider.lua:
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name
local TDLib = sui.TDLib

local Panel = {}

sui.scaling_functions(Panel)

AccessorFunc(Panel, "m_bValue", "Value", FORCE_NUMBER)
AccessorFunc(Panel, "m_bMin", "Min", FORCE_NUMBER)
AccessorFunc(Panel, "m_bMax", "Max", FORCE_NUMBER)
AccessorFunc(Panel, "m_bDecimals", "Decimals", FORCE_NUMBER)


AccessorFunc(Panel, "m_fSlideX", "SlideX")
AccessorFunc(Panel, "m_fSlideY", "SlideY")

AccessorFunc(Panel, "m_iLockX", "LockX")
AccessorFunc(Panel, "m_iLockY", "LockY")

AccessorFunc(Panel, "Dragging", "Dragging")

function Panel:Init()
	self:ScaleInit()

	self:SetSlideX(0.5)
	self:SetSlideY(0.5)

	self:SetMouseInputEnabled(true)
	self:SetMin(0)
	self:SetMax(10)
	self:SetValue(1)
	self:SetDecimals(1)

	self:SetSize(100, 12)

	self.rounded_box = {}

	self.Knob = vgui.Create("DButton", self)
	self.Knob:SetText("")
	self.Knob:SetSize(15, 15)
	self.Knob:NoClipping(true)
	self.Knob.Paint = self.KnobPaint
	self.Knob.OnCursorMoved = function(panel, x, y)
		x, y = panel:LocalToScreen(x, y)
		x, y = self:ScreenToLocal(x, y)
		self:OnCursorMoved(x, y)
	end
	self.Knob.circle = {}

	self:SetLockY(0.5)
end

function Panel:IsEditing()
	return self.Dragging or self.Knob.Depressed
end

function Panel:SetEnabled(b)
	self.Knob:SetEnabled(b)
	FindMetaTable("Panel").SetEnabled(self, b) -- There has to be a better way!
end

function Panel:OnCursorMoved(x, y)
	if (not self.Dragging and not self.Knob.Depressed) then return end

	local w, h = self:GetSize()
	local iw, ih = self.Knob:GetSize()

	w = w - iw
	h = h - ih

	x = x - iw * 0.5
	y = y - ih * 0.5

	x = math.Clamp(x, 0, w) / w
	y = math.Clamp(y, 0, h) / h

	if self.m_iLockX then x = self.m_iLockX end
	if self.m_iLockY then y = self.m_iLockY end

	x, y = self:TranslateValues(x, y)

	self:SetSlideX(x)
	self:SetSlideY(y)

	self:InvalidateLayout()
end

function Panel:OnMousePressed(mcode)
	if not self:IsEnabled() then return true end

	-- When starting dragging with not pressing on the knob.
	self.Knob.Hovered = true

	self:SetDragging(true)
	self:MouseCapture(true)

	local x, y = self:CursorPos()
	self:OnCursorMoved(x, y)
end

function Panel:OnMouseReleased(mcode)
	-- This is a hack. Panel.Hovered is not updated when dragging a panel (Source's dragging, not Lua Drag'n'drop)
	self.Knob.Hovered = vgui.GetHoveredPanel() == self.Knob

	self:SetDragging(false)
	self:MouseCapture(false)
end

function Panel:SetMinMax(min, max)
	self:SetMin(min)
	self:SetMax(max)
end

function Panel:TranslateValues(x, y)
	self:SetValue(self:GetMin() + (x * self:GetRange()))
	return self:GetFraction(), y
end

function Panel:GetFraction()
	return (self:GetValue() - self:GetMin()) / self:GetRange()
end

function Panel:SetValue(val)
	val = math.Clamp(val, self:GetMin(), self:GetMax())
	val = math.Round(val, self:GetDecimals())

	self.m_bValue = val
	self:SetSlideX((val - self:GetMin()) / self:GetRange())

	self:OnValueChanged(val)
end

function Panel:OnValueChanged(val)
end

function Panel:GetRange()
	return self:GetMax() - self:GetMin()
end

function Panel:Paint(w, h)
	local _h = SUI.Scale(2)
	TDLib.RoundedBox(self.rounded_box, 3, 0, h / 2 - _h / 2, w, _h, SUI.GetColor("slider_track"))
end

function Panel:KnobPaint(w, h)
	if self.Depressed then
		TDLib.DrawCircle(self.circle, w / 2, h / 2, h / 1.1, SUI.GetColor("slider_pressed"))
	elseif self.Hovered then
		TDLib.DrawCircle(self.circle, w / 2, h / 2, h / 1.1, SUI.GetColor("slider_hover"))
	end

	TDLib.DrawCircle(self.circle, w / 2, h / 2, h / 2, SUI.GetColor("slider_knob"))
end

function Panel:PerformLayout(w, h)
	local knob_size = SUI.Scale(12)
	self.Knob:SetSize(knob_size, knob_size)

	w = w - knob_size
	h = h - knob_size
	self.Knob:SetPos((self.m_fSlideX or 0) * w, (self.m_fSlideY or 0) * h)
end

function Panel:SetSlideX(i)
	self.m_fSlideX = i
	self:InvalidateLayout()
end

function Panel:SetSlideY(i)
	self.m_fSlideY = i
	self:InvalidateLayout()
end

function Panel:GetDragging()
	return self.Dragging or self.Knob.Depressed
end

sui.register("Slider", Panel, "Panel")

--PATH addons/[lib] sui/lua/sui/vgui/sui_zcollapse_category.lua:
local sui = sui

local draw_material = sui.draw_material

local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local GetColor = SUI.GetColor

local RoundedBox = sui.TDLib.LibClasses.RoundedBox
local TextColor = sui.TDLib.LibClasses.TextColor

local TABS_FONT = SUI.CreateFont("CategoryListTabs", "Roboto Bold", 13)
local ITEMS_FONT = SUI.CreateFont("CategoryListItems", "Roboto Medium", 14)

local Panel = {}

local item_OnRemove = function(s)
	local parent = s.parent

	local items = parent.items
	for k, v in ipairs(items) do
		if v == s then
			table.remove(items, k)
			break
		end
	end

	if #items == 0 then
		local category = s.category
		category:Remove()
		parent.categories[category.name] = nil
	end
end

local item_DoClick = function(s)
	local parent = s.parent
	parent:select_item(s)
end

function Panel:Init()
	local categories = {}
	local items = {}

	self.categories = categories
	self.items = items

	self:SetVBarPadding(1)

	local get_category = function(name)
		local category = categories[name]
		if category then return category end

		local expanded = false

		category = self:Add("Panel")
		category:Dock(TOP)
		category:DockMargin(0, 0, 0, 3)
		category.name = name

		local header = category:Add("DButton")
		header:Dock(TOP)
		header:DockMargin(0, 0, 0, 3)
		header:SetFont(TABS_FONT)
		header:SetContentAlignment(4)
		header:SetTextInset(6, 0)
		header:SetText(name)
		header:SizeToContentsY(SUI.Scale(14))

		local cur_col
		local cur_col_text = Color(GetColor("collapse_category_header_text"):Unpack())
		function header:Paint(w, h)
			if expanded then
				cur_col = GetColor("collapse_category_header_active")
				cur_col_text = GetColor("collapse_category_header_text_active")
			elseif self.Hovered then
				cur_col = GetColor("collapse_category_header_hover")
				cur_col_text = GetColor("collapse_category_header_text_hover")
			else
				cur_col = GetColor("collapse_category_header")
				cur_col_text = GetColor("collapse_category_header_text")
			end

			RoundedBox(self, "Background", 3, 0, 0, w, h, cur_col)
			TextColor(self, cur_col_text)
		end

		local image = header:Add(NAME .. ".Image")
		image:Dock(FILL)
		image:SetImage("https://raw.githubusercontent.com/Srlion/Addons-Data/main/icons/sui/arrow.png")

		function image:Draw(w, h)
			local size = SUI.ScaleEven(10)
			draw_material(nil, w - (size / 2) - 6, h / 2, size, cur_col_text, expanded and 180)
		end

		local current_h
		function category.RefreshHeight()
			local h
			if expanded then
				local _
				_, h = category:ChildrenSize()
				if self.searching and h == header:GetTall() then
					h = 0
				end
			else
				h = header:GetTall()
			end

			if current_h == h then return end

			if h > 0 then
				category:SetVisible(true)
			end

			current_h = h

			category:Stop()
			category:SizeTo(-1, h, 0.2, 0, -1, function()
				if h == 0 then
					category:SetVisible(false)
				end
			end)
		end

		function category.SetExpanded(_, set_expanded)
			if expanded == set_expanded then return end

			if sam.isbool(set_expanded) then
				expanded = set_expanded
			else
				expanded = not expanded
			end

			category.RefreshHeight()

			if expanded then
				self:OnCategoryExpanded(category)
			end

			self:InvalidateLayout(true)
		end
		header.DoClick = category.SetExpanded

		category:SetTall(header:GetTall())
		categories[name] = category

		return category
	end

	function self:add_item(name, category_name)
		local category = get_category(category_name)

		local item = category:Add("DButton")
		item:Dock(TOP)
		item:DockMargin(0, 0, 0, 3)
		item:SetFont(ITEMS_FONT)
		item:SetText(name)
		item:SizeToContentsY(SUI.Scale(3 * 2))
		item.name = name
		item.parent = self
		item.category = category

		local cur_col
		local cur_col_text = Color(GetColor("collapse_category_item_text"):Unpack())
		function item:Paint(w, h)
			if self.selected then
				cur_col = GetColor("collapse_category_item_active")
				cur_col_text = GetColor("collapse_category_item_text_active")
			elseif self.Hovered then
				cur_col = GetColor("collapse_category_item_hover")
				cur_col_text = GetColor("collapse_category_item_text_hover")
			else
				cur_col = GetColor("collapse_category_item")
				cur_col_text = GetColor("collapse_category_item_text")
			end

			RoundedBox(self, "Background", 4, 0, 0, w, h, cur_col)
			TextColor(self, cur_col_text)
		end

		item.DoClick = item_DoClick
		item.OnRemove = item_OnRemove

		table.insert(items, item)

		return item
	end
end

function Panel:OnCategoryExpanded(category)
end

function Panel:select_item(item)
	if self.selected_item ~= item then
		if IsValid(self.selected_item) then
			self.selected_item.selected = false
		end
		item.selected = true
		self.selected_item = item
		self:item_selected(item)
	end
end

function Panel:item_selected()
end

function Panel:Search(text, names)
	local items = self.items
	self.searching = true
	for i = 1, #items do
		local item = items[i]
		local category = item.category
		category:SetExpanded(true)

		if not names then
			if item.name:find(text, nil, true) then
				item:SetVisible(true)
			else
				item:SetVisible(false)
			end
		else
			local found = false
			for _, name in ipairs(item.names) do
				if name:find(text, nil, true) then
					found = true
					item:SetVisible(true)
				end
			end
			if not found then
				item:SetVisible(false)
			end
		end

		if text == "" then
			category:SetExpanded(false)
		end

		category:RefreshHeight()
		category:InvalidateLayout(true)
	end
	self.searching = false
end

sui.register("CollapseCategory", Panel, NAME .. ".ScrollPanel")
--PATH addons/[chat] scb-29/lua/scb/libs/sh_types.lua:
if SCB_LOADED then return end

-- https://gist.github.com/CapsAdmin/0d9c1e77d0fc22d910e182bfeb9812e5
local getmetatable = getmetatable

do
	local types = {
		["string"] = "",
		["boolean"] = true,
		["number"] = 0,
		["function"] = function() end,
		["thread"] = coroutine.create(getmetatable),
		["Color"] = Color(0, 0, 0),
	}

	for k, v in pairs(types) do
		if not getmetatable(v) then
			debug.setmetatable(v, {MetaName = k})
		else
			getmetatable(v).MetaName = k
		end
	end
end

function scb.type(value)
	if value == nil then
		return "nil"
	end
	local meta = getmetatable(value)
	if meta then
		meta = meta.MetaName
		if meta then
			return meta
		end
	end
	return "table"
end

do
	local function add(name)
		local new_name = name
		if name == "bool" then
			new_name = "boolean"
		end
		scb["is" .. name:lower()] = function(value)
			local meta = getmetatable(value)
			if meta and meta.MetaName == new_name then
				return true
			else
				return false
			end
		end
	end

	add("string")
	add("number")
	add("bool")
	add("function")

	add("Angle")
	add("Vector")
	add("Panel")
	add("Matrix")
end

function scb.isentity(value)
	local meta = getmetatable(value)
	if meta then
		if meta.MetaName == "Entity" then
			return true
		end
		meta = meta.MetaBaseClass
		if meta then
			return meta.MetaName == "Entity"
		end
	end
	return false
end
scb.IsEntity = scb.isentity

local type = scb.type
function scb.istable(value)
	return type(value) == "table"
end
--PATH addons/[chat] scb-29/lua/scb/libs/message_pack/sh_messagepack.lua:
return gluapack()()
--PATH addons/[chat] scb-29/lua/sh_scb_config.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/autorun/sh_arc9_autorun.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/autorun/sh_arc9_autorun.lua:
AddCSLuaFile()

ARC9 = {}

ARC9.Overrun = false

local searchdir = "arc9/"

for _, v in pairs(file.Find(searchdir .. "common/*", "LUA")) do
    include(searchdir .. "common/" .. v)
    AddCSLuaFile(searchdir .. "common/" .. v)
end

for _, v in pairs(file.Find(searchdir .. "shared/*", "LUA")) do
    include(searchdir .. "shared/" .. v)
    AddCSLuaFile(searchdir .. "shared/" .. v)
end

for _, v in pairs(file.Find(searchdir .. "client/*", "LUA")) do
    AddCSLuaFile(searchdir .. "client/" .. v)
    if CLIENT then
        include(searchdir .. "client/" .. v)
    end
end

if SERVER then
    for _, v in pairs(file.Find(searchdir .. "server/*", "LUA")) do
        include(searchdir .. "server/" .. v)
    end
end
--PATH lua/arc9/common/localization/content_base_en.lua:
return gluapack()()
--PATH lua/arc9/common/localization/content_base_uwu.lua:
return gluapack()()
--PATH lua/arc9/common/sh_common.lua:
return gluapack()()
--PATH lua/arc9/shared/sh_0_precache.lua:
-- credits : feusg for some things

local function CacheAModel(mdl)
    if SERVER then
        if util.IsValidModel(tostring(mdl)) then
            local cmdl = ents.Create("prop_dynamic")
            cmdl:SetModel(mdl)
            cmdl:Spawn()
            cmdl:Remove()
        end
    end
end

function ARC9.CacheAttsModels()
    if SERVER then
        if !ARC9.AttMdlPrecached then
            print("ARC9: Starting caching all attachments models assets.")
            for _, mdl in ipairs(ARC9.ModelToPrecacheList) do
                CacheAModel(mdl)
            end

            ARC9.AttMdlPrecached = true
            print("ARC9: Done caching attachments models. Pretty heavy isn't it?")
        end
    end
end

ARC9.PrecachedWepSounds = {}

local WepPossibleSfx = {
    "BreathInSound",
    "BreathOutSound",
    "BreathRunOutSound",
    "DropMagazineSounds",
    "FirstShootSound",
    "FirstShootSoundSilenced",
    "FirstDistantShootSound",
    "FirstDistantShootSoundSilenced",
    "ShootSound",
    "LayerSound",
    "ShootSoundSilenced",
    "LayerSoundSilenced",
    "ShootSoundIndoor",
    "LayerSoundIndoor",
    "ShootSoundSilencedIndoor",
    "LayerSoundSilencedIndoor",
    "DistantShootSound",
    "DistantShootSoundSilenced",
    "DistantShootSoundIndoor",
    "DistantShootSoundSilencedIndoor",
    "ShootSoundTail",
    "ShootSoundTailIndoor",
    "FiremodeSound",
    "ToggleAttSound",
    "DryFireSound",
    "EnterSightsSound",
    "ExitSightsSound",
    "MeleeHitSound",
    "MeleeHitWallSound",
    "MeleeSwingSound",
    "BackstabSound",
    "TriggerDownSound",
    "TriggerUpSound",
    "ShellSounds",
    "RicochetSounds",
}

local function CacheASound(str)
    local ex = string.GetExtensionFromFilename(str)

    if ex == "ogg" or ex == "wav" or ex == "mp3" then
        if SERVER then
            local cmdl = ents.Create("prop_dynamic")
            str = string.Replace(str, "sound\\", "")
            str = string.Replace(str, "sound/", "" )
            cmdl:EmitSound(str, 0, 100, 0.001, CHAN_WEAPON)
            cmdl:Remove()
        else
            if IsValid(LocalPlayer()) then
                LocalPlayer():EmitSound(str, 75, 100, 0.001, CHAN_WEAPON)
            end
        end
    end
end

function ARC9.CacheWepSounds(wep, class)
    if !ARC9.PrecachedWepSounds[class] then
        local SoundsToPrecacheList = {}

        for i, posiblesfx in ipairs(WepPossibleSfx) do
            local sfx = wep[posiblesfx]

            if istable(sfx) then
                for _, sfxinside in ipairs(sfx) do
                    table.insert(SoundsToPrecacheList, sfxinside)
                end
            elseif isstring(sfx) then
                table.insert(SoundsToPrecacheList, sfx)
            end
        end

        for i, sfx in ipairs(SoundsToPrecacheList) do
            timer.Simple(i * 0.01, function()
                CacheASound(sfx)
            end)
        end
        
        ARC9.PrecachedWepSounds[class] = true
    end
end

function ARC9.CacheWeaponsModels()
    if !ARC9.WepMdlPrecached then
        print("ARC9: Precaching all weapon models!")

        for i, wep in ipairs(weapons.GetList()) do
            if weapons.IsBasedOn(wep.ClassName, "arc9_base") then
                if wep.ViewModel then
                    CacheAModel(wep.ViewModel)
                end
            end
        end

        ARC9.WepMdlPrecached = true
        print("ARC9: Finished caching all weapon models, pretty heavy!")
    end
end

function ARC9.CacheAllSounds()
    for i, wep in ipairs(weapons.GetList()) do
        if weapons.IsBasedOn(wep.ClassName, "arc9_base") then
            if wep.ViewModel then
                ARC9.CacheWepSounds(wep, wep.ClassName)
            end
        end
    end
end

timer.Simple(1, function() 
    if SERVER then
        if GetConVar("arc9_precache_wepmodels_onstartup"):GetBool() then
            ARC9.CacheWeaponsModels()
        end
        
        if GetConVar("arc9_precache_attsmodels_onstartup"):GetBool() then
            ARC9.CacheAttsModels()
        end
    else
        RunConsoleCommand("arc9_dev_benchgun", "0") -- meow
    end

    if GetConVar("arc9_precache_allsounds_onstartup"):GetBool() then
        ARC9.CacheAllSounds()
    end
end)


concommand.Add("arc9_precache_allsounds", ARC9.CacheAllSounds)
concommand.Add("arc9_precache_wepmodels", ARC9.CacheWeaponsModels)
concommand.Add("arc9_precache_attsmodels", ARC9.CacheAttsModels)


--PATH lua/arc9/shared/sh_atts.lua:
ARC9.Attachments = {}
ARC9.Attachments_Index = {}

ARC9.Attachments_Count = 0

ARC9.Attachments_Bits = 16

ARC9.ModelToPrecacheList = {}

local fullreload

local defaulticon = Material("arc9/logo/logo_lowvis.png", "mips smooth")

function ARC9.LoadAttachment(atttbl, shortname, id)
    if hook.Run("ARC9_LoadAttachment", atttbl, shortname, id) then return end
    if atttbl.Ignore then return end
    shortname = shortname or "default"

    if !id then
        ARC9.Attachments_Count = ARC9.Attachments_Count + 1
    end

    atttbl.ShortName = shortname
    atttbl.ID = id or ARC9.Attachments_Count
    atttbl.Icon = atttbl.Icon or defaulticon

    -- for stat, val in ipairs(atttbl) do
    --     local stat2 = string.Replace(stat, "Override", "")
    --     atttbl[stat2] = val
    -- end

    if atttbl.Model then
        table.insert(ARC9.ModelToPrecacheList, atttbl.Model)
    end

    ARC9.Attachments[shortname] = atttbl
    ARC9.Attachments_Index[atttbl.ID] = shortname

    if GetConVar("arc9_atts_generateentities"):GetBool() and !atttbl.DoNotRegister and !atttbl.InvAtt and !atttbl.Free then
        local attent = {}
        attent.Base = "arc9_att_base"
        attent.Icon = atttbl.Icon or defaulticon
        if CLIENT and attent.Icon then
            attent.IconOverride = string.Replace( attent.Icon:GetTexture( "$basetexture" ):GetName() .. ".png", "0001010", "" )
        end
        attent.PrintName = atttbl.PrintName or shortname
        attent.Spawnable = true
        attent.AdminOnly = atttbl.AdminOnly or false
        attent.Model = atttbl.BoxModel or "models/items/arc9/att_plastic_box.mdl"
        attent.AttToGive = shortname
        attent.GiveAttachments = {
            [shortname] = 1
        }
        attent.Category =  atttbl.MenuCategory or "ARC9 - Attachments"

        if atttbl.MenuCategory and !list.HasEntry("ContentCategoryIcons", atttbl.MenuCategory) then
            list.Set("ContentCategoryIcons", atttbl.MenuCategory, "arc9/icon_16.png")
        end

        scripted_ents.Register(attent, "arc9_att_" .. shortname)
    end

    if !fullreload then -- not full loading means individual att file was updated. thats a dev! recaching gun for him so he dont have to reattach attahment!
        if game.SinglePlayer() then
            if IsValid(Entity(1)) then
                local wep = Entity(1):GetActiveWeapon()

                if IsValid(wep) and wep.ARC9 then
                    timer.Simple(0, function() wep:PostModify(true) end)
                end
            end
        end
    end
end

function ARC9.LoadAtts()
    fullreload = true
    ARC9.Attachments_Count = 0
    local Attachments_BulkCount = 0
    local Attachments_RegularCount = 0
    local Attachments_LuaCount = 0
    ARC9.Attachments = {}
    ARC9.Attachments_Index = {}

    local searchdir = "arc9/common/attachments/"
    local searchdir_bulk = "arc9/common/attachments_bulk/"

    local files = file.Find(searchdir .. "*.lua", "LUA")

    for _, filename in pairs(files) do
        if filename == "default.lua" then continue end
        
        AddCSLuaFile(searchdir .. filename)

        local shortname = string.lower(string.sub(filename, 1, -5))
        if string.match(shortname, "[^%w_]") then
            ErrorNoHalt("ARC9: Refusing to load attachment with invalid name \"" .. tostring(shortname) .. "\"!\n")
            continue
        end

        Attachments_LuaCount = Attachments_LuaCount + 1
        ARC9.Attachments_Count = ARC9.Attachments_Count + 1
        local attid = ARC9.Attachments_Count

        ATT = {}

        include(searchdir .. filename)

        ARC9.LoadAttachment(ATT, shortname, attid)
    end

    Attachments_RegularCount = Attachments_LuaCount

    local bulkfiles = file.Find(searchdir_bulk .. "/*.lua", "LUA")

    for _, filename in pairs(bulkfiles) do
        if filename == "default.lua" then continue end

        AddCSLuaFile(searchdir_bulk .. filename)

        Attachments_LuaCount = Attachments_LuaCount + 1
        Attachments_BulkCount = Attachments_BulkCount + 1
        
        include(searchdir_bulk .. filename)
    end

    print("ARC9 Registered " .. tostring(ARC9.Attachments_Count) .. " attachments. (" .. Attachments_LuaCount .. " lua files total, " .. Attachments_BulkCount .. " bulk/" .. Attachments_RegularCount .. " regular)")

    ARC9.Attachments_Bits = math.min(math.ceil(math.log(ARC9.Attachments_Count + 1, 2)), 32)

    if game.SinglePlayer() then
        if IsValid(Entity(1)) then
            local wep = Entity(1):GetActiveWeapon()

            if IsValid(wep) and wep.ARC9 then
                timer.Simple(0, function() wep:PostModify(true) end)
            end
        end
    end

    fullreload = nil
end

function ARC9.GetAttTable(name)
    local shortname = name
    if isnumber(shortname) then
        shortname = ARC9.Attachments_Index[name]
    end

    if ARC9.Attachments[shortname] then
        return ARC9.Attachments[shortname]
    else
        return nil
    end
end

local arc9_atts_anarchy = GetConVar("arc9_atts_anarchy")

function ARC9.GetAttsForCats(cats)
    if !istable(cats) then
        cats = {cats}
    end

    local atts = {}

    for i, k in pairs(ARC9.Attachments) do
        if ARC9.Blacklist[k] then continue end
        local attcats = k.Category

        if attcats == "*" then
            table.insert(atts, k.ShortName)
            continue
        end

        if !istable(attcats) then
            attcats = {attcats}
        end

        for _, cat in pairs(cats) do
            if arc9_atts_anarchy:GetBool() then
                table.insert(atts, k.ShortName)
                break
            else
                if table.HasValue(attcats, cat) then
                    table.insert(atts, k.ShortName)
                    break
                end
            end
        end
    end

    return atts
end

ARC9.AttMaterialIndex = true

if file.Exists("wmsm/playerdata.txt", "DATA") then
    ARC9.AttMaterialIndex = false
end

function ARC9.GetFoldersForAtts(atts)

    local folders = {}
    for i, k in pairs(atts) do
        local atttbl = ARC9.Attachments[k]
        if !atttbl then continue end
        if !atttbl.Folder then
            folders[atttbl.ShortName] = true
        else
            local names = string.Explode("/", atttbl.Folder)
            local cur = folders
            for _, v in ipairs(names) do
                cur[v] = cur[v] or {}
                cur = cur[v]
            end
            cur[atttbl.ShortName] = true
        end
    end

    return folders
end

hook.Add("OnReloaded", "ARC9_ReloadAtts", ARC9.LoadAtts)

local arc9_atts_max = GetConVar("arc9_atts_max")

function ARC9.GetMaxAtts()
    return arc9_atts_max:GetInt()
end

if CLIENT then

concommand.Add("arc9_reloadatts", function()
    if !LocalPlayer():IsSuperAdmin() then return end

	ARC9.ATTsHaveBeenReloaded = true
    net.Start("arc9_reloadatts")
    net.SendToServer()
end)

net.Receive("arc9_reloadatts", function(len, ply)
    ARC9.LoadAtts()
end)

elseif SERVER then

net.Receive("arc9_reloadatts", function(len, ply)
    if !ply:IsSuperAdmin() then return end

    ARC9.LoadAtts()

    net.Start("arc9_reloadatts")
    net.Broadcast()

    ARC9.InvalidateAll()
    net.Start("ARC9_InvalidateAll_ToClients")
    net.Broadcast()
end)

end

-- local CT = 0

-- hook.Add("OnReloaded", "ARC9_OnReloaded", function()
--     if CT == CurTime() then return end

--     ARC9.LoadAtts()

--     CT = CurTime()
-- end)

ARC9.LoadAtts()
--PATH lua/arc9/common/attachments_bulk/camos_base_flat_color.lua:
local ATT = {}

ATT.PrintName = "Red"
ATT.CompactName = "Red"
ATT.Icon = Material("models/weapons/arc9/camo/arc9_flatcamo/flat_red.png")
ATT.Category = "universal_camo"
ATT.Description = [[Basic red color.]]
ATT.MenuCategory = "ARC9 - Camos"
ATT.CustomCamoTexture = "models/weapons/arc9/camo/arc9_flatcamo/vtf/flat_red"
ATT.CustomCamoScale = 1
ATT.SortOrder = 10
ATT.Folder = ARC9:GetPhrase("folder.arc9")

ARC9.LoadAttachment(ATT, "camo_arc9_base_flat_red")

ATT = {}

ATT.PrintName = "Orange"
ATT.CompactName = "Orange"
ATT.Icon = Material("models/weapons/arc9/camo/arc9_flatcamo/flat_orange.png")
ATT.Category = "universal_camo"
ATT.Description = [[Basic orange color.]]
ATT.MenuCategory = "ARC9 - Camos"
ATT.CustomCamoTexture = "models/weapons/arc9/camo/arc9_flatcamo/vtf/flat_orange"
ATT.CustomCamoScale = 1
ATT.SortOrder = 12
ATT.Folder = ARC9:GetPhrase("folder.arc9")

ARC9.LoadAttachment(ATT, "camo_arc9_base_flat_orange")

ATT = {}

ATT.PrintName = "Yellow"
ATT.CompactName = "Yellow"
ATT.Icon = Material("models/weapons/arc9/camo/arc9_flatcamo/flat_yellow.png")
ATT.Category = "universal_camo"
ATT.Description = [[Basic yellow color.]]
ATT.MenuCategory = "ARC9 - Camos"
ATT.CustomCamoTexture = "models/weapons/arc9/camo/arc9_flatcamo/vtf/flat_yellow"
ATT.CustomCamoScale = 1
ATT.SortOrder = 13
ATT.Folder = ARC9:GetPhrase("folder.arc9")

ARC9.LoadAttachment(ATT, "camo_arc9_base_flat_yellow")

ATT = {}

ATT.PrintName = "Green"
ATT.CompactName = "Green"
ATT.Icon = Material("models/weapons/arc9/camo/arc9_flatcamo/flat_green.png")
ATT.Category = "universal_camo"
ATT.Description = [[Basic green color.]]
ATT.MenuCategory = "ARC9 - Camos"
ATT.CustomCamoTexture = "models/weapons/arc9/camo/arc9_flatcamo/vtf/flat_green"
ATT.CustomCamoScale = 1
ATT.SortOrder = 14
ATT.Folder = ARC9:GetPhrase("folder.arc9")

ARC9.LoadAttachment(ATT, "camo_arc9_base_flat_green")

ATT = {}

ATT.PrintName = "Blue"
ATT.CompactName = "Blue"
ATT.Icon = Material("models/weapons/arc9/camo/arc9_flatcamo/flat_blue.png")
ATT.Category = "universal_camo"
ATT.Description = [[Basic blue color.]]
ATT.MenuCategory = "ARC9 - Camos"
ATT.CustomCamoTexture = "models/weapons/arc9/camo/arc9_flatcamo/vtf/flat_blue"
ATT.CustomCamoScale = 1
ATT.SortOrder = 15
ATT.Folder = ARC9:GetPhrase("folder.arc9")

ARC9.LoadAttachment(ATT, "camo_arc9_base_flat_blue")

ATT = {}

ATT.PrintName = "Purple"
ATT.CompactName = "Purple"
ATT.Icon = Material("models/weapons/arc9/camo/arc9_flatcamo/flat_purple.png")
ATT.Category = "universal_camo"
ATT.Description = [[Basic purple color.]]
ATT.MenuCategory = "ARC9 - Camos"
ATT.CustomCamoTexture = "models/weapons/arc9/camo/arc9_flatcamo/vtf/flat_purple"
ATT.CustomCamoScale = 1
ATT.SortOrder = 16
ATT.Folder = ARC9:GetPhrase("folder.arc9")

ARC9.LoadAttachment(ATT, "camo_arc9_base_flat_purple")

ATT = {}

ATT.PrintName = "Pink"
ATT.CompactName = "Pink"
ATT.Icon = Material("models/weapons/arc9/camo/arc9_flatcamo/flat_pink.png")
ATT.Category = "universal_camo"
ATT.Description = [[Eye searingly bright pink color.]]
ATT.MenuCategory = "ARC9 - Camos"
ATT.CustomCamoTexture = "models/weapons/arc9/camo/arc9_flatcamo/vtf/flat_pink"
ATT.CustomCamoScale = 1
ATT.SortOrder = 17
ATT.Folder = ARC9:GetPhrase("folder.arc9")

ARC9.LoadAttachment(ATT, "camo_arc9_base_flat_pink")

ATT = {}

ATT.PrintName = "ARC9 Orange"
ATT.CompactName = "ARC9 Orange"
ATT.Icon = Material("models/weapons/arc9/camo/arc9_flatcamo/flat_arc9orange.png")
ATT.Category = "universal_camo"
ATT.Description = [[The perfect shade of orange for that cute little ARC9 Logo sticker.]]
ATT.MenuCategory = "ARC9 - Camos"
ATT.CustomCamoTexture = "models/weapons/arc9/camo/arc9_flatcamo/vtf/flat_arc9orange"
ATT.CustomCamoScale = 1
ATT.SortOrder = 11
ATT.Folder = ARC9:GetPhrase("folder.arc9")

ARC9.LoadAttachment(ATT, "camo_arc9_base_flat_arc9orange")
--PATH lua/arc9/shared/sh_npc.lua:
return gluapack()()
--PATH lua/arc9/client/cl_bind.lua:
return gluapack()()
--PATH lua/arc9/client/cl_blacklist.lua:
ARC9.Blacklist = {}

-- CLIENT

net.Receive("arc9_sendblacklist", function(len, ply)

    ARC9.Blacklist = {}

    local count = net.ReadUInt(32)

    for i = 1, count do
        local attid = net.ReadUInt(ARC9.Attachments_Bits)

        local atttbl = ARC9.GetAttTable(attid)

        if !atttbl then continue end

        local shortname = atttbl.ShortName

        ARC9.Blacklist[shortname] = true
    end
end)

function ARC9:SendClientBlacklist()
    net.Start("arc9_sendblacklist")

    net.WriteUInt(table.Count(ARC9.Blacklist), 32)

    for attname, i in pairs(ARC9.Blacklist) do
        if !i then continue end
        local atttbl = ARC9.GetAttTable(attname)

        local id = atttbl.ID

        net.WriteUInt(id, ARC9.Attachments_Bits)
    end

    net.SendToServer()
end

function ARC9:AddAttToBlacklist(att)
    ARC9.Blacklist[att] = true
end

function ARC9:RemoveAttFromBlacklist(att)
    ARC9.Blacklist[att] = false
end

concommand.Add("arc9_blacklist_show", function()
    for i, k in pairs(ARC9.Blacklist) do
        print(i)
    end
end)

concommand.Add("arc9_blacklist_add", function(ply, cmd, args)
    if !ply:IsAdmin() then return end

    for _, i in ipairs(args) do
        local atttbl = ARC9.GetAttTable(i)

        if !atttbl then
            print("WARNING! ", i, " is not a valid attachment! Make sure it's spelled correctly!")
            continue
        end

        ARC9:AddAttToBlacklist(i)
    end

    ARC9:SendClientBlacklist()
end)

concommand.Add("arc9_blacklist_remove", function(ply, cmd, args)
    if !ply:IsAdmin() then return end

    for _, i in ipairs(args) do
        local atttbl = ARC9.GetAttTable(i)

        if !atttbl then
            print("WARNING! ", i, " is not a valid attachment! Make sure it's spelled correctly!")
            continue
        end

        ARC9:RemoveAttFromBlacklist(i)
    end

    ARC9:SendClientBlacklist()
end)

concommand.Add("arc9_blacklist_clear", function()
    if !ply:IsAdmin() then return end

    ARC9.Blacklist = {}

    ARC9:SendClientBlacklist()
end)

concommand.Add("arc9_blacklist_send", function()
    if !ply:IsAdmin() then return end

    ARC9:SendClientBlacklist()
end)

local srf      = surface

local blacklistWindow = nil
local blacklistTbl    = {}
local filter          = ""
local onlyblacklisted = false
local internalName    = false
local dragMode = nil

local color_bred = Color(150, 50, 50, 255)
local color_lred = Color(125, 25, 25, 150)
local color_dred = Color(75, 0, 0, 150)
local color_dtbl = Color(0, 0, 0, 200)

local arc9_hud_scale = GetConVar("arc9_hud_scale")
if !ARC9.ScreenScale then ARC9.ScreenScale = function(size) return size * (ScrW() / 640) * arc9_hud_scale:GetFloat() * 0.9 end end -- idk
local ARC9ScreenScale = ARC9.ScreenScale

local arc9logo_layer1 = Material("arc9/logo/logo_bottom.png", "mips smooth")
local arc9logo_layer2 = Material("arc9/logo/logo_middle.png", "mips smooth")

local function SaveBlacklist()
    net.Start("arc9_sendblacklist")

    net.WriteUInt(table.Count(blacklistTbl), 32)

    for attname, i in pairs(blacklistTbl) do
        if !i then continue end
        local atttbl = ARC9.GetAttTable(attname)

        local id = atttbl.ID

        net.WriteUInt(id, ARC9.Attachments_Bits)
    end

    net.SendToServer()
end

local function CreateAttButton(parent, attName, attTbl)
    local attBtn = vgui.Create("DButton", parent)
    attBtn:SetFont("ARC9_8")
    attBtn:SetText("")
    attBtn:SetSize(ARC9ScreenScale(256), ARC9ScreenScale(16))
    attBtn:Dock(TOP)
    attBtn:DockMargin(ARC9ScreenScale(4), ARC9ScreenScale(1), ARC9ScreenScale(4), ARC9ScreenScale(1))
    attBtn:SetContentAlignment(5)

    attBtn.Paint = function(spaa, w, h)
        local blisted = blacklistTbl[attName]
        if blisted == nil then blisted = ARC9.Blacklist[attName] end

        local hovered = spaa:IsHovered()
        local blackhov = blisted and hovered

        local Bfg_col = blackhov and color_bred or blisted and color_bred or hovered and color_black or color_white
        local Bbg_col = blackhov and color_lred or blisted and color_dred or hovered and color_white or color_dtbl

        srf.SetDrawColor(Bbg_col)
        srf.DrawRect(0, 0, w, h)

        local img = attTbl.Icon
        if img then
            srf.SetDrawColor(Bfg_col)
            srf.SetMaterial(img)
            srf.DrawTexturedRect(ARC9ScreenScale(2), 0, h, h)
        end

        local txt = attTbl.PrintName
        if internalName or !txt then txt = attName end
        srf.SetTextColor(Bfg_col)
        srf.SetTextPos(ARC9ScreenScale(20), ARC9ScreenScale(2))
        srf.SetFont("ARC9_12")
        srf.DrawText(txt)

        local listed   = (blacklistTbl[attName] and !ARC9.Blacklist[attName])
        local unlisted = (ARC9.Blacklist[attName] and !blacklistTbl[attName])
        local saved = (listed) and " [not saved]" or ""
        srf.SetTextColor(Bfg_col)
        srf.SetTextPos(spaa:GetWide() - ARC9ScreenScale(36), ARC9ScreenScale(4))
        srf.SetFont("ARC9_8")
        srf.DrawText(saved)
    end

    -- In addition to clicking on a button, you can drag over all of them! -- this not work correctly!!!!!!!!!!!!!!!!!!!
    attBtn.OnMousePressed = function(spaa, kc)
        blacklistTbl[attName] = !blacklistTbl[attName] and !blacklistTbl[attName]
        dragMode = blacklistTbl[attName]
        hook.Add("Think", "ARC9_Blacklist", function()
            if !input.IsMouseDown(MOUSE_LEFT) then
                dragMode = nil
                hook.Remove("Think", "ARC9_Blacklist")
            end
        end)
    end
    attBtn.OnCursorEntered = function(spaa, kc)
        if dragMode != nil and input.IsMouseDown(MOUSE_LEFT) then
            blacklistTbl[attName] = dragMode
        end
    end

    return attBtn
end

local clicksound = "arc9/newui/uimouse_click_return.ogg"
local arc9_hud_darkmode = GetConVar("arc9_hud_darkmode")

function ARC9_BlacklistMenu()
    if blacklistWindow then blacklistWindow:Remove() end

    local bg = vgui.Create("DFrame")
    bg:SetPos(0, 0)
    bg:SetSize(ScrW(), ScrH())
    bg:SetTitle("")
    bg:SetDraggable(false)
    bg:ShowCloseButton(false)        -- set to false when done please!!
    bg:SetAlpha(0)
    bg:AlphaTo(255, 0.2, 0, nil)
    bg:SetBackgroundBlur(true)
    bg:MakePopup()

    bg.Paint = function(self2, w, h)
        if arc9_hud_darkmode:GetBool() then
            surface.SetDrawColor(58, 58, 58, 206)
        else
            surface.SetDrawColor(20, 20, 20, 224)
        end
        surface.DrawRect(0, 0, w, h)
    end
    

    blacklistTbl = {}

    blacklistTbl = table.Copy(ARC9.Blacklist)

    blacklistWindow = vgui.Create("DFrame", bg)
    blacklistWindow:SetSize(ScrW() * 0.45, ScrH() * 0.9)
    blacklistWindow:Center()
    blacklistWindow:SetTitle("")
    blacklistWindow:SetDraggable(false)
    blacklistWindow:SetVisible(true)
    blacklistWindow:ShowCloseButton(false )
    blacklistWindow:MakePopup()
    blacklistWindow:SetAlpha(0)
    blacklistWindow:AlphaTo(255, 0.2, 0, nil)

    blacklistWindow.OnRemove = function() bg:Remove() end
    
    local cornercut = ARC9ScreenScale(3.5)
    local buttontalling = 0
    local talll = ARC9ScreenScale(50)

    blacklistWindow.Paint = function(self, w, h)
        draw.NoTexture()

        srf.SetDrawColor(ARC9.GetHUDColor("bg"))
        srf.DrawPoly({{x = cornercut, y = h}, {x = 0, y = h-cornercut}, {x = 0, y = ARC9ScreenScale(24+2)}, {x = w, y = ARC9ScreenScale(24+2)}, {x = w, y = h-cornercut}, {x = w-cornercut, y = h}}) -- left bottom panel
        -- srf.DrawPoly({{x = w-ARC9ScreenScale(98,4), y = h}, {x = w-ARC9ScreenScale(98,4), y = ARC9ScreenScale(25.7)}, {x = w, y = ARC9ScreenScale(25.7)}, {x = w, y = h-cornercut}, {x = w-cornercut, y = h}}) -- right panel
        srf.DrawPoly({{x = 0, y = ARC9ScreenScale(24)},{x = 0, y = cornercut},{x = cornercut, y = 0}, {x = w-cornercut, y = 0}, {x = w, y = cornercut}, {x = w, y = ARC9ScreenScale(24)}}) -- top panel

        srf.SetDrawColor(ARC9.GetHUDColor("hi"))
        srf.DrawPoly({{x = cornercut, y = h}, {x = 0, y = h-cornercut}, {x = cornercut, y = h-cornercut*.5}})
        srf.DrawPoly({{x = w, y = h-cornercut}, {x = w-cornercut, y = h}, {x = w-cornercut, y = h-cornercut*.5}})
        srf.DrawPoly({{x = cornercut, y = h-cornercut*.5}, {x = w-cornercut, y = h-cornercut*.5}, {x = w-cornercut, y = h}, {x = cornercut, y = h}, })

        do
            local x, y, s = ARC9ScreenScale(4), ARC9ScreenScale(2), ARC9ScreenScale(20)
            srf.SetDrawColor(255, 255, 255)
            srf.SetMaterial(arc9logo_layer1)
            srf.DrawTexturedRect(x, y, s, s)
        
            srf.SetDrawColor(ARC9.GetHUDColor("hi"))
            srf.SetMaterial(arc9logo_layer2)
            srf.DrawTexturedRect(x, y, s, s)
        end


        srf.SetFont("ARC9_16")
        srf.SetTextColor(ARC9.GetHUDColor("fg"))
        srf.SetTextPos(ARC9ScreenScale(30), ARC9ScreenScale(4))
        srf.DrawText(ARC9:GetPhrase("blacklist.title"))
    end

    -- local title = vgui.Create("DLabel", blacklistWindow)
    -- title:SetSize(ARC9ScreenScale(256), ARC9ScreenScale(26))
    -- title:Dock(TOP)
    -- title:SetFont("ARC9_24")
    -- title:SetText("ARC9 Blacklist")
    -- title:DockMargin(ARC9ScreenScale(16), 0, ARC9ScreenScale(16), ARC9ScreenScale(8))

    local close = vgui.Create("ARC9TopButton", blacklistWindow)
    close:SetPos(blacklistWindow:GetWide() - ARC9ScreenScale(21+2), ARC9ScreenScale(2))
    close:SetIcon(Material("arc9/ui/close.png", "mips smooth"))
    close.DoClick = function(self2)
        surface.PlaySound(clicksound)
        blacklistWindow:AlphaTo(0, 0.1, 0, nil)
        bg:AlphaTo(0, 0.1, 0, function()
            bg:Remove()
            blacklistWindow:Remove()
        end)
    end

    bg.OnMousePressed = function(self2, keycode)
        close.DoClick()
    end

    local desc = vgui.Create("DLabel", blacklistWindow)
    desc:SetSize(ARC9ScreenScale(256), ARC9ScreenScale(12))
    desc:Dock(TOP)
    desc:DockMargin(ARC9ScreenScale(4), ARC9ScreenScale(19), ARC9ScreenScale(4), ARC9ScreenScale(2))
    desc:SetFont("ARC9_12")
    desc:SetColor(ARC9.GetHUDColor("fg"))
    desc:SetText(ARC9:GetPhrase("blacklist.desc"))
    desc:SetContentAlignment(5)

    local attList = vgui.Create("ARC9ScrollPanel", blacklistWindow)
    attList:SetText("")
    attList:Dock(FILL)
    attList:DockMargin(ARC9ScreenScale(14), 0, ARC9ScreenScale(16), ARC9ScreenScale(28))
    attList:SetContentAlignment(5)
    attList.Paint = function(span, w, h) end

    local sbar = attList:GetVBar()
    sbar.Paint = function() end
    sbar.btnUp.Paint = function(span, w, h) end
    sbar.btnDown.Paint = function(span, w, h) end
    sbar.btnGrip.Paint = function(span, w, h)
        srf.SetDrawColor(color_white)
        srf.DrawRect(0, 0, w, h)
    end

    local FilterPanel = vgui.Create("DPanel", blacklistWindow)
    FilterPanel:Dock(TOP)
    FilterPanel:DockMargin(ARC9ScreenScale(16), ARC9ScreenScale(2), ARC9ScreenScale(16), ARC9ScreenScale(2))
    FilterPanel:SetSize(ARC9ScreenScale(256), ARC9ScreenScale(12))
    FilterPanel:SetPaintBackground(false)

    local FilterLabel = vgui.Create("DLabel", FilterPanel)
    FilterLabel:Dock(LEFT)
    FilterLabel:SetWidth(ARC9ScreenScale(36))
    FilterLabel:DockMargin(ARC9ScreenScale(2), ARC9ScreenScale(2), ARC9ScreenScale(2), ARC9ScreenScale(2))
    FilterLabel:SetFont("ARC9_12")
    FilterLabel:SetColor(ARC9.GetHUDColor("fg"))
    FilterLabel:SetText(ARC9:GetPhrase("blacklist.filter"))

    local FilterButton = vgui.Create("DButton", FilterPanel)
    FilterButton:SetFont("ARC9_8")
    FilterButton:SetText("")
    FilterButton:SetSize(ARC9ScreenScale(48), ARC9ScreenScale(12))
    FilterButton:Dock(RIGHT)
    FilterButton:DockMargin(ARC9ScreenScale(1), 0, 0, 0)
    FilterButton:SetContentAlignment(5)

    FilterButton.OnMousePressed = function(spaa, kc)
        onlyblacklisted = !onlyblacklisted

        attList:GenerateButtonsToList()
    end

    FilterButton.Paint = function(spaa, w, h)
        local hovered = spaa:IsHovered()

        local Bfg_col = hovered and color_black or color_white
        local Bbg_col = hovered and color_white or color_dtbl

        srf.SetDrawColor(Bbg_col)
        srf.DrawRect(0, 0, w, h)

        spaa:SetTextColor(Bfg_col)
        spaa:SetText(onlyblacklisted and ARC9:GetPhrase("blacklist.blisted") or ARC9:GetPhrase("blacklist.all"))
    end

    local NameButton = vgui.Create("DButton", FilterPanel)
    NameButton:SetFont("ARC9_8")
    NameButton:SetText("")
    NameButton:SetSize(ARC9ScreenScale(24), ARC9ScreenScale(12))
    NameButton:Dock(RIGHT)
    NameButton:DockMargin(ARC9ScreenScale(1), 0, 0, 0)
    NameButton:SetContentAlignment(5)

    NameButton.OnMousePressed = function(spaa, kc)
        internalName = !internalName
        attList:GenerateButtonsToList()
    end

    NameButton.Paint = function(spaa, w, h)
        local hovered = spaa:IsHovered()

        local Bfg_col = hovered and color_black or color_white
        local Bbg_col = hovered and color_white or color_dtbl

        srf.SetDrawColor(Bbg_col)
        srf.DrawRect(0, 0, w, h)

        spaa:SetTextColor(Bfg_col)
        spaa:SetText(internalName and ARC9:GetPhrase("blacklist.id") or ARC9:GetPhrase("blacklist.name"))
    end

    local FilterEntry = vgui.Create("DTextEntry", FilterPanel)
    FilterEntry:Dock(FILL)
    FilterEntry:SetValue(filter)
    FilterEntry:SetFont("ARC9_12")
    FilterEntry.OnChange = function( self )
        filter = self:GetValue():lower()

        attList:GenerateButtonsToList()
    end

    local savebtntext = ARC9:GetPhrase("customize.presets.save")
    local savebtn = vgui.Create("ARC9TopButton", blacklistWindow)
    surface.SetFont("ARC9_16")
    local tw = surface.GetTextSize(savebtntext)
    savebtn:SetPos(blacklistWindow:GetWide()/2-(ARC9ScreenScale(29)+tw)/2, blacklistWindow:GetTall() - ARC9ScreenScale(26))
    -- savebtn:Dock(BOTTOM)
    -- savebtn:DockMargin(blacklistWindow:GetWide()/2-ARC9ScreenScale(29)-tw, 0, blacklistWindow:GetWide()/2-ARC9ScreenScale(40), ARC9ScreenScale(4))
    savebtn:SetSize(ARC9ScreenScale(29)+tw, ARC9ScreenScale(22))
    savebtn:SetButtonText(savebtntext, "ARC9_16")
    savebtn:SetIcon(Material("arc9/ui/apply.png", "mips smooth"))
    savebtn.DoClick = function(self2)
        surface.PlaySound(clicksound)

        SaveBlacklist()
        blacklistWindow:Close()
        blacklistWindow:Remove()
    end
    
    -- Perhaps unoptimized, but it's client
    -- client_side_calculations_is_not_expensive.png
    function attList:GenerateButtonsToList()
        self:GetCanvas():Clear()

        for attName, attTbl in SortedPairsByMemberValue(ARC9.Attachments, "PrintName") do
            if attTbl.Hidden then continue end

            if attTbl.Blacklisted then blacklistTbl[attName] = true end

            if onlyblacklisted and !(attTbl.Blacklisted or blacklistTbl[attName]) then continue end
            if filter != "" and !(string.find((attTbl.PrintName and attTbl.PrintName or attName):lower(), filter) or string.find((attName):lower(), filter)) then continue end

            --if attTbl.Slot == "charm" then continue end why the fuck would you do this

            CreateAttButton(self, attName, attTbl)
        end
    end

    attList:GenerateButtonsToList()
end

concommand.Add("arc9_blacklist", function()
    if LocalPlayer():IsAdmin() then ARC9_BlacklistMenu() end
end)
--PATH lua/arc9/client/cl_matproxy.lua:
return gluapack()()
--PATH lua/arc9/client/cl_npc.lua:
local arc9_npc_give_weapons = GetConVar("arc9_npc_give_weapons")

function ARC9.AttemptGiveNPCWeapon()
    if !arc9_npc_give_weapons:GetBool() then return end
    local wpn = LocalPlayer():GetActiveWeapon()

    if !wpn.ARC9 then return end

    local tr = LocalPlayer():GetEyeTrace()

    if tr.Entity:IsValid() and tr.Entity:IsNPC() then
        net.Start("arc9_givenpcweapon")
        net.WriteEntity(tr.Entity)
        net.SendToServer()
    end
end
--PATH lua/arc9/client/cl_rendertarget.lua:
local ARC9_cheapscopes = GetConVar("ARC9_cheapscopes")

hook.Add("PreRender", "ARC9_PreRender", function()
    local wpn = LocalPlayer():GetActiveWeapon()

    if !wpn.ARC9 then return end

    wpn:RunHook("Hook_DoRT")

    if ARC9_cheapscopes:GetBool() then return end

    local atttbl = wpn:IsScoping()

    if atttbl then
        wpn:DoRT(wpn:GetRTScopeFOV(), atttbl)
    end
end)

hook.Add("PreDrawViewModels", "ARC9_PreDrawViewModels", function()
    if !ARC9_cheapscopes:GetBool() then return end

    local wpn = LocalPlayer():GetActiveWeapon()

    if !wpn.ARC9 then return end

    local atttbl = wpn:IsScoping()

    if atttbl then
        local fov = wpn:GetRTScopeFOV()

        fov = wpn:WidescreenFix(wpn:GetViewModelFOV())

        wpn:DoCheapScope(fov, atttbl)
    end
end)
--PATH lua/arc9/client/cl_settings_menu.lua:
--[[
    type,
        label - pure text
        bool
        button:
            content - text in button
            func - function(self2) end
        slider:
            min
            max
            decimals
            convar2 - same as convar, but only for input, not follow always
            func - function(self2) end   after action
        color
        coloralpha - with transparency slider
        input - text input, NOT IMPLEMENTED
        combo - dropdown menu:
            content - {{"1table of thingies", "stibb"}, {"2there", "yolo"}, {"3for some reason you need put number at start so it will be properly sorted", "foog"}, {"4though it will be not drawn in ui", "booglybop"}}
    title,
    convar to follow, (without arc9_; color selectors will automatically use _r/_g/_b)
    description to show on right
]]--

ARC9.LanguagesTable = {
{"0GMod Language", ""},
{"1English", "en"},
{"2Deutsch", "de"},
{"2Espaol", "es-es"},
{"2", "ru"},
{"2Svenska", "sv-se"},
{"2", "zh-cn"},

{"9UwU :3", "uwu"},
}

ARC9.BadPerfromanceSettings = function() return BRANCH != "x86-64" or GetConVar("mat_queue_mode"):GetInt() == 0 or GetConVar("cl_threaded_bone_setup"):GetInt() < 1 end

ARC9.SettingsTable = {
    -- {
    --     TabName = "Tab name 1",
    --     { type = "label", text = "Header" },
    --     { type = "bool", text = "Booling", convar = "cust_blur", desc = "TEST DESCRIPTION" },
    --     { type = "slider", text = "Booling 2", min = -2, max = 2, desc = "f DESCRIPTION" },
    --     { type = "slider", text = "Slide me", min = -45, max = 45, convar = "fov", desc = "balls" },
    --     { type = "combo", text = "Yayay", convar = "arccw_attinv_loseondie", content = {"1table of thingies", "2there", "3ooo"}, desc = "hhhhhhhhhhhhhhhhh" },
    --     { type = "button", text = "Uhhh", content = "Boop", func = function(self2) print("wa") end, desc = "TEST DESCRIPTION" },
    --     { type = "color", text = "Coloringa", convar = "reflex", desc = "This color is very important. \n\nClient-only.\nConvar: arc9_sdfjidojgoidfjgoidfg_r/g/b/a" },
    --     -- { type = "coloralpha", text = "Color alpha", desc = "g" },
    --     -- { type = "input", text = "Color alpha", desc = "g" },
    -- },
    {
        TabName = "settings.tabname.general",

        { type = "label", text = "settings.general.client" },
        { type = "bool", text = "settings.hud_game.hud_arc9.title", convar = "hud_arc9", desc = "settings.hud_game.hud_arc9.desc" },
        { type = "bool", text = "settings.crosshair.cross_enable.title", convar = "cross_enable", desc = "settings.crosshair.cross_enable.desc" },
        { type = "bool", text = "settings.tpik.title", convar = "tpik", desc = "settings.tpik.desc"},
        -- { type = "combo", text = "settings.truenames.title", convar = "truenames", content = {
        --     {"1Use Default", "2"},
        --     {"2Disabled", "0"},
        --     {"3Enabled", "1"},
        -- }, desc = "settings.truenames.desc"},
        -- { type = "bool", text = "settings.aimassist.enable.title", convar = "aimassist_cl", desc = "settings.aimassist.enable_client.desc"},
		{ type = "combo", text = "settings.language_id.title", convar = "language", desc = "settings.language_id.desc", content = ARC9.LanguagesTable, func = function(self2)
            RunConsoleCommand("arc9_reloadlangs")
        end},
        { type = "button", text = "settings.resetsettings.cl.title", content = "settings.reset", func = function(self2)
            RunConsoleCommand("arc9_settings_reset_client")
        end},

        { sv = true, type = "label", text = "settings.general.server" },
        { type = "bool", text = "settings.hud_game.hud_force_disable.title", convar = "hud_force_disable", desc = "settings.hud_game.hud_force_disable.desc" },

        { sv = true, type = "bool", text = "settings.attachments.free_atts.title", convar = "free_atts", desc = "settings.attachments.free_atts.desc"},
        { sv = true, type = "bool", text = "settings.gameplay.infinite_ammo.title", convar = "infinite_ammo", desc = "settings.gameplay.infinite_ammo.desc" },
        { sv = true, type = "slider", text = "settings.gameplay.mult_defaultammo.title", convar = "mult_defaultammo", min = 0, max = 16, decimals = 0, desc = "settings.gameplay.mult_defaultammo.desc" },
        { sv = true, type = "bool", text = "settings.truenames.title", convar = "truenames_default", desc = "settings.truenames.desc" },
        -- { sv = true, type = "combo", text = "settings.truenames_default.title", convar = "truenames_default", content = {
        --     {"1Disabled", "0"},
        --     {"2Enabled", "1"},
        -- }, desc = "settings.truenames_default.desc"},
        -- { sv = true, type = "bool", text = "settings.truenames_enforced.title", convar = "truenames_enforced", desc = "settings.truenames_enforced.desc"},
        { type = "bool", text = "settings.aimassist.enable.title", convar = "aimassist", desc = "settings.aimassist.enable_general.desc"},
        { sv = true, type = "button", text = "settings.resetsettings.sv.title", content = "settings.reset", func = function(self2)
            RunConsoleCommand("arc9_settings_reset_server")
        end},

    },
    {
        TabName = "settings.tabname.performance",
        Warning = ARC9.BadPerfromanceSettings,
        { type = "label", text = "badconf.warning", desc = "badconf.warning.desc", important = true, showfunc = ARC9.BadPerfromanceSettings },
        { type = "label", text = "badconf.x64.title", desc = "badconf.x64.desc", showfunc = function() return BRANCH != "x86-64" end },
        { type = "label", text = "badconf.multicore.title", desc = "badconf.multicore.desc", showfunc = function() return GetConVar("mat_queue_mode"):GetInt() == 0 or GetConVar("cl_threaded_bone_setup"):GetInt() < 1 end },
        { type = "label", text = "", showfunc = ARC9.BadPerfromanceSettings },
        { type = "label", text = "", showfunc = ARC9.BadPerfromanceSettings },

        { type = "label", text = "settings.performance.important" },
        { type = "bool", text = "settings.cheapscopes.title", convar = "cheapscopes", desc = "settings.cheapscopes.desc"},
        { type = "bool", text = "settings.tpik.title", convar = "tpik", desc = "settings.tpik.desc"},
        { type = "bool", text = "settings.allflash.title", convar = "allflash", desc = "settings.allflash.desc"},
        { type = "bool", text = "settings.fx_rtvm.title", convar = "fx_rtvm", desc = "settings.fx_rtvm.desc"},


        { type = "label", text = "settings.performance.blur.title" },
        { type = "bool", text = "settings.cust_blur.title", convar = "cust_blur", desc = "settings.cust_blur.desc"},
        { type = "bool", text = "settings.fx_reloadblur.title", convar = "fx_reloadblur", desc = "settings.fx_reloadblur.desc"},
        { type = "bool", text = "settings.fx_animblur.title", convar = "fx_animblur", desc = "settings.fx_animblur.desc"},
        { type = "bool", text = "settings.fx_rtblur.title", convar = "fx_rtblur", desc = "settings.fx_rtblur.desc"},
        { type = "bool", text = "settings.fx_adsblur.title", convar = "fx_adsblur", desc = "settings.fx_adsblur.desc"},

        { type = "label", text = "settings.performance.shelleject.title" },
        { type = "bool", text = "settings.eject_fx.title", convar = "eject_fx", desc = "settings.eject_fx.desc"},
        { type = "slider", text = "settings.eject_time.title", convar = "eject_time", min = -1, max = 60, decimals = 0, desc = "settings.eject_time.desc"},

        { type = "label", text = "settings.performance.fx.title" },
        { type = "bool", text = "settings.muzzle_light.title", convar = "muzzle_light", desc = "settings.muzzle_light.desc"},
        { type = "bool", text = "settings.muzzle_others.title", convar = "muzzle_others", desc = "settings.muzzle_others.desc"},
    },
    {
        TabName = "settings.tabname.optics",
        -- { type = "bool", text = "settings.cheapscopes.title", convar = "cheapscopes", desc = "settings.cheapscopes.desc"},

        { type = "label", text = "settings.optics.control" },
        { type = "slider", text = "settings.optics.sensmult.title", min = 0.1, max = 1, decimals = 1, convar = "mult_sens", desc = "settings.optics.sensmult.desc" },
        { type = "bool", text = "settings.optics.compensate_sens.title", convar = "compensate_sens", desc = "settings.optics.compensate_sens.desc" },
        { type = "bool", text = "settings.optics.toggleads.title", convar = "toggleads", desc = "settings.optics.toggleads.desc" },
        { type = "bool", text = "settings.optics.dtap_sights.title", convar = "dtap_sights", desc = "settings.optics.dtap_sights.desc" },

        { type = "label", text = "settings.optics.color" },
        { type = "color", text = "settings.optics.reflex.title", convar = "reflex", desc = "settings.optics.reflex.desc" },
        { type = "color", text = "settings.optics.scope.title", convar = "scope", desc = "settings.optics.scope.desc" },

        { type = "label", text = "settings.tabname.performance" },
        { type = "bool", text = "settings.cheapscopes.title", convar = "cheapscopes", desc = "settings.cheapscopes.desc"},
        { type = "bool", text = "settings.fx_rtvm.title", convar = "fx_rtvm", desc = "settings.fx_rtvm.desc"},
        { type = "bool", text = "settings.fx_rtblur.title2", convar = "fx_rtblur", desc = "settings.fx_rtblur.desc"},
    },
    {
        TabName = "settings.tabname.crosshair",
        { type = "label", text = "settings.crosshair.crosshair" },
        { type = "bool", text = "settings.crosshair.cross_enable.title", convar = "cross_enable", desc = "settings.crosshair.cross_enable.desc" },
        { type = "coloralpha", text = "settings.crosshair.cross.title", convar = "cross", desc = "settings.crosshair.cross.desc"},
        { type = "slider", text = "settings.crosshair.cross_size_mult.title", min = 0.01, max = 10, decimals = 2, convar = "cross_size_mult", desc = "settings.crosshair.cross_size_mult.desc" },
        { type = "slider", text = "settings.crosshair.cross_size_dot.title", min = 0.01, max = 10, decimals = 2, convar = "cross_size_dot", desc = "settings.crosshair.cross_size_dot.desc" },
        { type = "slider", text = "settings.crosshair.cross_size_prong.title", min = 0.01, max = 10, decimals = 2, convar = "cross_size_prong", desc = "settings.crosshair.cross_size_prong.desc" },
        { type = "bool", text = "settings.crosshair.crosshair_static.title", convar = "crosshair_static", desc = "settings.crosshair.crosshair_static.desc" },
        { type = "bool", text = "settings.crosshair.crosshair_force.title", convar = "crosshair_force", desc = "settings.crosshair.crosshair_force.desc" },
        { type = "bool", text = "settings.crosshair.crosshair_target.title", convar = "crosshair_target", desc = "settings.crosshair.crosshair_target.desc" },
        { type = "bool", text = "settings.crosshair.crosshair_peeking.title", convar = "crosshair_peek", desc = "settings.crosshair.crosshair_peeking.desc" },
    },
    {
        TabName = "settings.tabname.hud_cust",
        { type = "label", text = "settings.hud_cust.hud" },
        -- crazy hacks to make hud scale work "almost dynamicly"
        { type = "slider", text = "settings.hud_cust.hud_scale.title", min = 0.5, max = 1.5, decimals = 2, desc = "settings.hud_cust.hud_scale.desc", convar2 = "hud_scale", func = function(self2, self3, settingspanel)
            if IsValid(LocalPlayer()) then -- uncust the gun
                local wep = LocalPlayer():GetActiveWeapon()
                if IsValid(wep) and wep.ARC9 then
                    if wep.CustomizeHUD then
                        wep:SetCustomize(false)
                        net.Start("ARC9_togglecustomize")
                        net.WriteBool(false)
                        net.SendToServer()
                    end
                end
            end

            RunConsoleCommand("arc9_hud_scale", self3:GetValue())

            settingspanel:Remove() -- rebuilding
            timer.Simple(0, function()
                ARC9.Regen() -- reload fonts with new scale
                ARC9_OpenSettings()
            end)
        end },
        -- { type = "input", text = "Font", convar = "font", desc = "Font replacement for ARC9. Set empty to use default font." },
        -- { type = "slider", min = -16, max = 16, decimals = 0, text = "Font Add Size", convar = "font_addsize", desc = "Increase text size.", func = function(self2, self3, settingspanel)
        --     timer.Simple(0, function()
        --         ARC9.Regen() -- reload fonts with new scale
        --     end)
        -- end },

        { type = "slider", min = 0, max = 1000, decimals = 0, text = "settings.hud_cust.hud_deadzonex.title", convar = "hud_deadzonex", desc = "settings.hud_cust.hud_deadzonex.desc" },

        { type = "color", text = "settings.hud_cust.hud_color.title", convar = "hud_color", desc = "settings.hud_cust.hud_color.desc"},
        { type = "bool", text = "settings.hud_cust.hud_darkmode.title", convar = "hud_darkmode", desc = "settings.hud_cust.hud_darkmode.desc"},
        { type = "bool", text = "settings.hud_cust.hud_holiday.title", convar = "hud_holiday", desc = "settings.hud_cust.hud_holiday.desc"},
        -- { type = "input", text = "Language", convar = "language", desc = "Language pack to use for ARC9. Leave blank for game default." },
        { type = "bool", text = "settings.hud_cust.cust_light.title", convar = "cust_light", desc = "settings.hud_cust.cust_light.desc"},
        { type = "slider", min = -20, max = 30, decimals = 1, text = "settings.hud_cust.cust_light_brightness.title", convar = "cust_light_brightness", desc = "settings.hud_cust.cust_light_brightness.desc" },

        { type = "label", text = "settings.hud_cust.customization" },
        -- { type = "bool", text = "Background Blur", convar = "cust_blur", desc = "Blurs customization background.\n\nRequires DX9."},
        { type = "bool", text = "settings.hud_cust.cust_hints.title", convar = "cust_hints", desc = "settings.hud_cust.cust_hints.desc"},
        { type = "bool", text = "settings.hud_cust.cust_tips.title", convar = "cust_tips", desc = "settings.hud_cust.cust_tips.desc"},
        -- { type = "bool", text = "settings.hud_cust.cust_roll_unlock.title", convar = "cust_roll_unlock", desc = "settings.hud_cust.cust_roll_unlock.desc"},
        { type = "bool", text = "settings.hud_cust.cust_exit_reset_sel.title", convar = "cust_exit_reset_sel", desc = "settings.hud_cust.cust_exit_reset_sel.desc"},
        { type = "bool", text = "settings.hud_cust.imperial.title", convar = "imperial", desc = "settings.hud_cust.imperial.desc"},
    },
    {
        TabName = "settings.tabname.hud_game",
        { type = "label", text = "settings.hud_game.lcd" },
        { type = "bool", text = "settings.hud_game.hud_force_disable.title", convar = "hud_force_disable", desc = "settings.hud_game.hud_force_disable.desc" },
        { type = "bool", text = "settings.hud_game.hud_arc9.title", convar = "hud_arc9", desc = "settings.hud_game.hud_arc9.desc" },
        { type = "bool", text = "settings.hud_game.hud_always.title", convar = "hud_always", desc = "settings.hud_game.hud_always.desc" },
        { type = "bool", text = "settings.hud_game.hud_compact.title", convar = "hud_compact", desc = "settings.hud_game.hud_compact.desc" },
        { type = "bool", text = "settings.hud_game.hud_nohints.title", convar = "hud_nohints", desc = "settings.hud_game.hud_nohints.desc" },
        { type = "bool", text = "settings.hud_game.hud_keephints.title", convar = "hud_keephints", desc = "settings.hud_game.hud_keephints.desc" },

        { type = "label", text = "settings.hud_game.killfeed" },
        { type = "bool", text = "settings.hud_game.killfeed_enable.title", convar = "killfeed_enable", desc = "settings.hud_game.killfeed_enable.desc" },
        { type = "bool", text = "settings.hud_game.killfeed_dynamic.title", convar = "killfeed_dynamic", desc = "settings.hud_game.killfeed_dynamic.desc" },
        { type = "bool", text = "settings.hud_game.killfeed_colour.title", convar = "killfeed_colour", desc = "settings.hud_game.killfeed_colour.desc" },

        { type = "label", text = "settings.hud_game.breath" },
        { type = "bool", text = "settings.hud_game.breath_hud.title", convar = "breath_hud", desc = "settings.hud_game.breath_hud.desc" },
        { type = "bool", text = "settings.hud_game.breath_pp.title", convar = "breath_pp", desc = "settings.hud_game.breath_pp.desc" },

        { type = "label", text = "settings.hud_game.centerhint" },
        { type = "bool", text = "settings.hud_game.centerhint_reload.title", convar = "center_reload_enable", desc = "settings.hud_game.centerhint_reload.desc" },
        { type = "slider", min = 0, max = 1, decimals = 2, text = "settings.hud_game.centerhint_reload_percent.title", convar = "center_reload", desc = "settings.hud_game.centerhint_reload_percent.desc" },
        { type = "bool", text = "settings.hud_game.centerhint_bipod.title", convar = "center_bipod", desc = "settings.hud_game.centerhint_bipod.desc" },
        { type = "bool", text = "settings.hud_game.centerhint_jammed.title", convar = "center_jam", desc = "settings.hud_game.centerhint_jammed.desc" },
        { type = "bool", text = "settings.hud_game.centerhint_firemode.title", convar = "center_firemode", desc = "settings.hud_game.centerhint_firemode.desc" },
        { type = "slider", min = 0, max = 2, decimals = 2, text = "settings.hud_game.centerhint_firemode_time.title", convar = "center_firemode_time", desc = "settings.hud_game.centerhint_firemode_time.desc" },
        { type = "bool", text = "settings.hud_game.centerhint_overheat.title", convar = "center_overheat", desc = "settings.hud_game.centerhint_overheat.desc" },

        { type = "label", text = "settings.hud_game.hud_glyph" },
        -- { type = "bool", text = "settings.hud_game.hud_glyph_dark.title", convar = "glyph_dark", desc = "settings.hud_game.hud_glyph_dark.desc" },
        -- { type = "slider", min = 0.5, max = 2, decimals = 2, text = "settings.hud_game.hud_glyph_size.title", convar = "glyph_size", desc = "settings.hud_game.hud_glyph_size.desc" },
		
        { type = "combo", text = "settings.hud_game.hud_glyph_type_hud.title", convar = "glyph_family_hud", desc = "settings.hud_game.hud_glyph_type_hud.desc", content = {
            {"1" .. ARC9:GetPhrase("settings.hud_game.hud_glyph_light"), "light"},
            {"2" .. ARC9:GetPhrase("settings.hud_game.hud_glyph_dark"), "dark"},
            {"3" .. ARC9:GetPhrase("settings.hud_game.hud_glyph_knockout"), "knockout"},
			},
        },
		
        { type = "combo", text = "settings.hud_game.hud_glyph_type_cust.title", convar = "glyph_family_cust", desc = "settings.hud_game.hud_glyph_type_cust.desc", content = {
            {"1" .. ARC9:GetPhrase("settings.hud_game.hud_glyph_light"), "light"},
            {"2" .. ARC9:GetPhrase("settings.hud_game.hud_glyph_dark"), "dark"},
            {"3" .. ARC9:GetPhrase("settings.hud_game.hud_glyph_knockout"), "knockout"},
			},
        },
    },
    {
        TabName = "settings.tabname.npc",
        sv = true,
        { type = "label", text = "settings.npc.weapons" },
        { type = "bool", text = "settings.npc.npc_equality.title", convar = "npc_equality", desc = "settings.npc.npc_equality.desc" },
        { type = "slider", text = "settings.npc.npc_spread.title", min = 0, max = 10, decimals = 1, convar = "npc_spread", desc = "settings.npc.npc_spread.desc"},
        { type = "bool", text = "settings.npc.npc_atts.title", convar = "npc_atts", desc = "settings.npc.npc_atts.desc" },
        { type = "bool", text = "settings.npc.npc_autoreplace.title", convar = "npc_autoreplace", desc = "settings.npc.npc_autoreplace.desc" },
        { type = "bool", text = "settings.npc.replace_spawned.title", convar = "replace_spawned", desc = "settings.npc.replace_spawned.desc" },
        { type = "bool", text = "settings.npc.npc_give_weapons.title", convar = "npc_give_weapons", desc = "settings.npc.npc_give_weapons.desc" },
    },
    {
        TabName = "settings.tabname.gameplay",
        { type = "label", text = "settings.gameplay.controls" },
        { type = "bool", text = "settings.gameplay.toggleads.title", convar = "toggleads", desc = "settings.gameplay.toggleads.desc" },
        { type = "bool", text = "settings.gameplay.autolean.title", convar = "autolean", desc = "settings.gameplay.autolean.desc" },
        { type = "bool", text = "settings.gameplay.autoreload.title", convar = "autoreload", desc = "settings.gameplay.autoreload.desc" },
        { type = "bool", text = "settings.gameplay.togglelean.title", convar = "togglelean", desc = "settings.gameplay.togglelean.desc" },
        { type = "bool", text = "settings.gameplay.togglepeek.title", convar = "togglepeek", desc = "settings.gameplay.togglepeek.desc" },
        { type = "bool", text = "settings.gameplay.togglepeek_reset.title", convar = "togglepeek_reset", desc = "settings.gameplay.togglepeek_reset.desc" },
        { type = "bool", text = "settings.gameplay.togglebreath.title", convar = "togglebreath", desc = "settings.gameplay.togglebreath.desc" },

        { sv = true, type = "label", text = "settings.gameplay.mechanics" },
        { sv = true, type = "bool", text = "settings.gameplay.infinite_ammo.title", convar = "infinite_ammo", desc = "settings.gameplay.infinite_ammo.desc" },
        { sv = true, type = "bool", text = "settings.gameplay.realrecoil.title", convar = "realrecoil", desc = "settings.gameplay.realrecoil.desc" },
        { sv = true, type = "bool", text = "settings.gameplay.lean.title", convar = "lean", desc = "settings.gameplay.lean.desc" },
        { sv = true, type = "bool", text = "settings.gameplay.mod_sway.title", convar = "mod_sway", desc = "settings.gameplay.mod_sway.desc" },
        { sv = true, type = "bool", text = "settings.gameplay.mod_freeaim.title", convar = "mod_freeaim", desc = "settings.gameplay.mod_freeaim.desc" },
        { sv = true, type = "bool", text = "settings.gameplay.mod_bodydamagecancel.title", convar = "mod_bodydamagecancel", desc = "settings.gameplay.mod_bodydamagecancel.desc" },
        { sv = true, type = "bool", text = "settings.gameplay.breath_slowmo.title", convar = "breath_slowmo", desc = "settings.gameplay.breath_slowmo.desc" },
        { sv = true, type = "bool", text = "settings.gameplay.manualbolt.title", convar = "manualbolt", desc = "settings.gameplay.manualbolt.desc" },
        { sv = true, type = "bool", text = "settings.gameplay.never_ready.title", convar = "never_ready", desc = "settings.gameplay.never_ready.desc" },
        { sv = true, type = "bool", text = "settings.gameplay.recoilshake.title", convar = "recoilshake", desc = "settings.gameplay.recoilshake.desc" },
        { sv = true, type = "bool", text = "settings.gameplay.equipment_generate_ammo.title", convar = "equipment_generate_ammo", desc = "settings.gameplay.equipment_generate_ammo.desc" },
        -- { type = "bool", text = "", convar = "nearwall", desc = "" },
        -- random jams
        -- overheating
    },
    {
        TabName = "settings.tabname.visuals",
        { type = "label", text = "settings.visuals.viewmodel" },
        { type = "combo", text = "settings.visuals.vm_bobstyle.title", convar = "vm_bobstyle", content = {
            {"1Bread & Darsu", "0"},
            {"2Fesiug", "1"},
            {"3Arctic", "2"},
            {"4Darsu", "3"},
            {"5Bread (exaggerated)", "4"},
            {"6Half-Life 2", "-1"},
        },
        desc = "settings.visuals.vm_bobstyle.desc" },
        -- { type = "slider", text = "Bob Style", convar = "vm_bobstyle", min = 0, max = 2, decimals = 0, desc = "Select different bobbing styles, to the flavor of different members of the ARC9 team.\n\n0: Darsu\n 1: Fesiug\n2: Arctic" },
        { type = "slider", text = "settings.visuals.fov.title", convar = "fov", min = -40, max = 40, decimals = 0, desc = "settings.visuals.fov.desc"},
        { type = "slider", min = -16, max = 16, decimals = 1, text = "settings.visuals.vm_addx.title", convar = "vm_addx", desc = "settings.visuals.vm_addx.desc" },
        { type = "slider", min = -16, max = 16, decimals = 1, text = "settings.visuals.vm_addy.title", convar = "vm_addy", desc = "settings.visuals.vm_addy.desc" },
        { type = "slider", min = -16, max = 16, decimals = 1, text = "settings.visuals.vm_addz.title", convar = "vm_addz", desc = "settings.visuals.vm_addz.desc" },

        { type = "label", text = "settings.visuals.cambob" },
        { type = "bool", text = "settings.visuals.vm_cambob.title", convar = "vm_cambob", desc = "settings.visuals.vm_cambob.desc" },
        { type = "bool", text = "settings.visuals.vm_cambobwalk.title", convar = "vm_cambobwalk", desc = "settings.visuals.vm_cambobwalk.desc" },
        { type = "slider", text = "settings.visuals.vm_cambobintensity.title", convar = "vm_cambobintensity", min = 0, max = 3, decimals = 2, desc = "settings.visuals.vm_cambobintensity.desc"},

        { type = "label", text = "settings.visuals.tpik" },
        { type = "bool", text = "settings.visuals.tpik.title", convar = "tpik", desc = "settings.visuals.tpik.desc" },
        { type = "bool", text = "settings.visuals.tpik_others.title", convar = "tpik_others", desc = "settings.visuals.tpik_others.desc" },
        { type = "slider", text = "settings.visuals.tpik_framerate.title", convar = "tpik_framerate", min = 0, max = 200, decimals = 0, desc = "settings.visuals.tpik_framerate.desc" },
    },
    {
        TabName = "settings.tabname.bullets",
        sv = true,
        { type = "label", text = "settings.bullets.bullets"},
        { type = "bool", text = "settings.bullets.bullet_physics.title", convar = "bullet_physics", desc = "settings.bullets.bullet_physics.desc" },
        { type = "slider", text = "settings.bullets.bullet_gravity.title", convar = "bullet_gravity", min = 0, max = 10, decimals = 1, desc = "settings.bullets.bullet_gravity.desc" },
        { type = "slider", text = "settings.bullets.bullet_drag.title", convar = "bullet_drag", min = 0, max = 10, decimals = 1, desc = "settings.bullets.bullet_drag.desc" },
        { type = "bool", text = "settings.bullets.ricochet.title", convar = "ricochet", desc = "settings.bullets.ricochet.desc" },
        { type = "bool", text = "settings.bullets.mod_penetration.title", convar = "mod_penetration", desc = "settings.bullets.mod_penetration.desc" },
        { type = "slider", text = "settings.bullets.bullet_lifetime.title", convar = "bullet_lifetime", min = 0, max = 120, decimals = 0, desc = "settings.bullets.bullet_lifetime.desc" },
        { type = "bool", text = "settings.bullets.bullet_imaginary.title", convar = "bullet_imaginary", desc = "settings.bullets.bullet_imaginary.desc" },
    },
    {
        TabName = "settings.tabname.attachments",
        { sv = true, type = "label", text = "settings.attachments.customization"},
        { sv = true, type = "bool", text = "settings.attachments.atts_nocustomize.title", convar = "atts_nocustomize", desc = "settings.attachments.atts_nocustomize.desc"},
        { type = "slider", text = "settings.attachments.atts_max.title", convar = "atts_max", min = 0, max = 250, decimals = 0, desc = "settings.attachments.atts_max.desc"},
        { type = "bool", text = "settings.attachments.autosave.title", convar = "autosave", desc = "settings.attachments.autosave.desc"},
        -- { type = "bool", text = "Total Anarchy", convar = "atts_anarchy", desc = "Allows any attachment to be attached to any slot.\nVERY laggy.\nWill not work properly with 99% of weapons and attachments.\nPlease don't turn this on.\n\nThis is a server variable."},
        { sv = true, type = "button", text = "settings.attachments.blacklist.title", content = "settings.attachments.blacklist.open", func = function(self2)
            RunConsoleCommand("arc9_blacklist")
        end},
        { sv = true, type = "label", text = "settings.attachments.inventory"},
        { sv = true, type = "bool", text = "settings.attachments.free_atts.title", convar = "free_atts", desc = "settings.attachments.free_atts.desc"},
        { sv = true, type = "bool", text = "settings.attachments.atts_lock.title", convar = "atts_lock", desc = "settings.attachments.atts_lock.desc"},
        { sv = true, type = "bool", text = "settings.attachments.atts_loseondie.title", convar = "atts_loseondie", desc = "settings.attachments.atts_loseondie.desc"},
        { sv = true, type = "bool", text = "settings.attachments.atts_generateentities.title", convar = "atts_generateentities", desc = "settings.attachments.atts_generateentities.desc"},
    },
    {
        TabName = "settings.tabname.modifiers",
        sv = true,
        { type = "label", text = "settings.modifiers.quick.title", desc = "settings.modifiers.quick.desc"},
        { type = "slider", min = 0, max = 10, decimals = 1, text = "settings.mod_damage.title", convar = "mod_damage" },
        { type = "slider", min = 0, max = 10, decimals = 1, text = "settings.mod_spread.title", convar = "mod_spread" },
        { type = "slider", min = 0, max = 10, decimals = 1, text = "settings.mod_recoil.title", convar = "mod_recoil" },
        { type = "slider", min = 0, max = 10, decimals = 1, text = "settings.mod_visualrecoil.title", convar = "mod_visualrecoil" },
        { type = "slider", min = 0, max = 10, decimals = 1, text = "settings.mod_adstime.title", convar = "mod_adstime" },
        { type = "slider", min = 0, max = 10, decimals = 1, text = "settings.mod_sprinttime.title", convar = "mod_sprinttime" },
        { type = "slider", min = 0, max = 10, decimals = 1, text = "settings.mod_damagerand.title", convar = "mod_damagerand" },
        { type = "slider", min = 0, max = 10, decimals = 1, text = "settings.mod_muzzlevelocity.title", convar = "mod_muzzlevelocity" },
        { type = "slider", min = 0, max = 10, decimals = 1, text = "settings.mod_rpm.title", convar = "mod_rpm" },
        { type = "slider", min = 0, max = 10, decimals = 1, text = "settings.mod_headshotdamage.title", convar = "mod_headshotdamage" },
        { type = "slider", min = 0, max = 100, decimals = 1, text = "settings.mod_malfunction.title", convar = "mod_malfunction" },
        -- { type = "slider", text = "Damage", convar = "wawa", min = 0, max = 10, decimals = 0, desc = "The     Damage\n\nThis is a server variable."},

        -- { type = "button", text = "Advanced modifiers", content = "Open panel", func = function(self2)
        --     -- RunConsoleCommand("arc9_reloadatts")
        --     print("lol")
        --     -- put here default derma panel with stuff from fesiug's spawmenu modifier panel
        -- end},
    },
    {
        TabName = "settings.tabname.controller",
        { type = "label", text = "settings.tabname.controller", desc = "settings.controller.misc.desc"},
        { type = "bool", text = "settings.controller.controller.title", convar = "controller", desc = "settings.controller.controller.desc"},
		{ type = "bool", text = "settings.aimassist.enable.title", convar = "aimassist_cl", desc = "settings.aimassist.enable_client.desc"},
		{ type = "slider", text = "settings.optics.sensmult.title", min = 0.1, max = 1, decimals = 1, convar = "mult_sens", desc = "settings.optics.sensmult.desc" },
        -- { type = "combo", text = "settings.controller.glyphs.title", convar = "glyph_type", desc = "settings.controller.glyphs.desc", content = {
            -- {"1Xbox", "xbox"},
            -- {"2PlayStation", "ps"},
            -- {"3Nintendo Switch", "switch"},
			-- },
        -- },
        -- { type = "bool", text = "settings.controller.controller_rumble.title", convar = "controller_rumble", desc = "settings.controller.controller_rumble.desc"},
        -- { type = "button", text = "settings.controller.controller_config.title", desc = "settings.controller.controller_config.desc", content = "settings.controller.controller_config.content", func = function(self2)
        --     -- RunConsoleCommand("arc9_reloadatts")
        --     print("lol")
        --     -- put here default derma panel with stuff from fesiug's spawmenu controller panel
        -- end},
    },
    {
        TabName = "settings.tabname.aimassist",
        { type = "label", text = "settings.general.client", desc = "settings.tabname.aimassist.desc" },
        { type = "bool", text = "settings.aimassist.enable.title", convar = "aimassist_cl", desc = "settings.aimassist.enable_client.desc"},
        -- { type = "bool", text = "settings.aimassist.lockon.title", convar = "aimassist_lockon_cl", desc = "settings.aimassist.lockon.desc"},
        { type = "slider", text = "settings.optics.sensmult.title", min = 0.1, max = 1, decimals = 2, convar = "aimassist_multsens", desc = "settings.aimassist.sensmult.desc" },

        { type = "label", text = "settings.general.server" },
        { type = "bool", text = "settings.aimassist.enable.title", convar = "aimassist", desc = "settings.aimassist.enable.desc"},
        -- { type = "bool", text = "settings.aimassist.lockon_allow.title", convar = "aimassist_lockon", desc = "settings.aimassist.lockon_allow.desc"},
        { type = "slider", min = 0.1, max = 2, decimals = 1, text = "settings.aimassist.intensity.title", convar = "aimassist_intensity", desc = "settings.aimassist.intensity.desc" },
        { type = "slider", min = 0.1, max = 10, decimals = 1, text = "settings.aimassist.cone.title", convar = "aimassist_cone", desc = "settings.aimassist.cone.desc" },
        { type = "bool", text = "settings.aimassist.head.title", convar = "aimassist_head", desc = "settings.aimassist.head.desc"},

    },
    {
        TabName = "settings.tabname.caching",
        { type = "label", text = "settings.caching.title", desc = "settings.caching.desc" },
        { type = "bool", text = "settings.caching.precache_sounds_onfirsttake.title", convar = "precache_sounds_onfirsttake", desc = "settings.caching.precache_sounds_onfirsttake.desc"},
        { type = "bool", text = "settings.caching.precache_attsmodels_onfirsttake.title", convar = "precache_attsmodels_onfirsttake", desc = "settings.caching.precache_attsmodels_onfirsttake.desc"},
        { type = "bool", text = "settings.caching.precache_wepmodels_onfirsttake.title", convar = "precache_wepmodels_onfirsttake", desc = "settings.caching.precache_wepmodels_onfirsttake.desc"},
        { type = "bool", text = "settings.caching.precache_allsounds_onstartup.title", convar = "precache_allsounds_onstartup", desc = "settings.caching.precache_allsounds_onstartup.desc"},
        { type = "bool", text = "settings.caching.precache_attsmodels_onstartup.title", convar = "precache_attsmodels_onstartup", desc = "settings.caching.precache_attsmodels_onstartup.desc"},
        { type = "bool", text = "settings.caching.precache_wepmodels_onstartup.title", convar = "precache_wepmodels_onstartup", desc = "settings.caching.precache_wepmodels_onstartup.desc"},

        { type = "button", text = "settings.caching.precache_allsounds.title", content = "settings.developer.cache", func = function(self2)
            RunConsoleCommand("arc9_precache_allsounds")
        end},
        { type = "button", text = "settings.caching.precache_attsmodels.title", content = "settings.developer.cache", func = function(self2)
            RunConsoleCommand("arc9_precache_attsmodels")
        end},
        { type = "button", text = "settings.caching.precache_wepmodels.title", content = "settings.developer.cache", func = function(self2)
            RunConsoleCommand("arc9_precache_wepmodels")
        end},
    },
    {
        TabName = "settings.tabname.developer",
        sv = true,
        { type = "label", text = "settings.developer.developer"},
        { type = "bool", text = "settings.developer.dev_always_ready.title", convar = "dev_always_ready", desc = "settings.developer.dev_always_ready.desc"},
        { type = "bool", text = "settings.developer.dev_benchgun.title", convar = "dev_benchgun", desc = "settings.developer.dev_benchgun.desc"},
        { type = "bool", text = "settings.developer.dev_crosshair.title", convar = "dev_crosshair", desc = "settings.developer.dev_crosshair.desc"},
        { type = "bool", text = "settings.developer.dev_show_shield.title", convar = "dev_show_shield", desc = "settings.developer.dev_show_shield.desc"},
        { type = "bool", text = "settings.developer.dev_greenscreen.title", convar = "dev_greenscreen", desc = "settings.developer.dev_greenscreen.desc"},
        { type = "bool", text = "settings.developer.dev_show_affectors.title", convar = "dev_show_affectors", desc = "settings.developer.dev_show_affectors.desc"},
        { type = "button", text = "settings.developer.reloadatts.title", content = "settings.developer.reload", func = function(self2)
            RunConsoleCommand("arc9_reloadatts")
        end},
        { type = "button", text = "settings.developer.reloadlangs.title", content = "settings.developer.reload", func = function(self2)
            RunConsoleCommand("arc9_reloadlangs")
        end},
        { type = "button", text = "settings.developer.dev_listmyatts.title", content = "settings.developer.print", func = function(self2)
            RunConsoleCommand("arc9_dev_listmyatts")
        end},
        { type = "button", text = "settings.developer.dev_listanims.title", content = "settings.developer.print", func = function(self2)
            RunConsoleCommand("arc9_dev_listanims")
        end},
        { type = "button", text = "settings.developer.dev_listbones.title", content = "settings.developer.print", func = function(self2)
            RunConsoleCommand("arc9_dev_listbones")
        end},
        { type = "button", text = "settings.developer.dev_listbgs.title", content = "settings.developer.print", func = function(self2)
            RunConsoleCommand("arc9_dev_listbgs")
        end},
        { type = "button", text = "settings.developer.dev_listatts.title", content = "settings.developer.print", func = function(self2)
            RunConsoleCommand("arc9_dev_listatts")
        end},
        { type = "button", text = "settings.developer.dev_listmats.title", content = "settings.developer.print", func = function(self2)
            RunConsoleCommand("arc9_dev_listsubmats")
        end},
        { type = "button", text = "settings.developer.dev_export.title", content = "settings.developer.print", func = function(self2)
            RunConsoleCommand("arc9_dev_export")
        end},
        { type = "button", text = "settings.developer.dev_getjson.title", content = "settings.developer.print", func = function(self2)
            RunConsoleCommand("arc9_dev_getjson")
        end},
        { type = "button", text = "settings.developer.presets_clear.title", content = "settings.developer.clear", desc = "settings.developer.presets_clear.desc", func = function(self2)
            RunConsoleCommand("arc9_presets_clear")
        end},
    },
}

local ARC9ScreenScale = ARC9.ScreenScale
-- local mat_icon = Material("arc9/arc9_logo_ui.png", "mips smooth")
local arc9logo_layer1 = Material("arc9/logo/logo_bottom.png", "mips smooth")
local arc9logo_layer2 = Material("arc9/logo/logo_middle.png", "mips smooth")
local mat_Notif = Material("arc9/ui/info.png", "mips")
local color_Notif = Color(255, 50, 50)

local function DrawSettings(bg, page)
    local cornercut = ARC9ScreenScale(3.5)

    local buttontalling = 0
    local activedesc = ""
    local activecvar = ""

    local sheet = vgui.Create("ARC9ColumnSheet", bg)
    sheet:Dock(FILL)
    sheet:DockMargin(0, 0, ARC9ScreenScale(100), ARC9ScreenScale(1.7))
    sheet.Navigation:DockMargin(-120, 0, 0, ARC9ScreenScale(5)) -- idk why -120
    sheet.Navigation:SetWidth(ARC9ScreenScale(100))

    for k, v in pairs(ARC9.SettingsTable) do
        local newpanel = vgui.Create("DPanel", sheet)
        newpanel:Dock(FILL)
        newpanel.Paint = function(self, w, h) draw.RoundedBox(0, 0, 0, w, h, ARC9.GetHUDColor("bg")) end
        local newpanelscroll = vgui.Create("ARC9ScrollPanel", newpanel)
        newpanelscroll:Dock(FILL)
        newpanelscroll:DockMargin(ARC9ScreenScale(4), ARC9ScreenScale(4), ARC9ScreenScale(4), 0)

        for k2, v2 in ipairs(v) do
            if v2.showfunc and !v2.showfunc() then continue end
            
            local elpanel = vgui.Create("DPanel", newpanelscroll)

            elpanel:SetTall(ARC9ScreenScale(v2.type == "label" and 14 or 21))
            elpanel:DockMargin(0, (k2 != 1 and v2.type == "label") and ARC9ScreenScale(4) or 0, 0, 0)
            elpanel:Dock(TOP)

            local noperms = !game.SinglePlayer() and !LocalPlayer():IsListenServerHost() and !LocalPlayer():IsAdmin()
                    and v2.convar and ARC9.ConVarData["arc9_" .. v2.convar] and !ARC9.ConVarData["arc9_" .. v2.convar].client

            elpanel.Paint = function(self2, w, h)
                if v2.type == "label" and v2.text != "" then
                    surface.SetDrawColor(0, 0, 0, 75)
                    if v2.important then surface.SetDrawColor(233, 21, 21, 171) end
                    surface.DrawRect(0, 0, w, h)
                end
                -- desc!!!!!!!!

                if self2:IsHovered() and activedesc != (ARC9:GetPhrase(v2.desc) or v2.desc or "") then
                    activedesc = (ARC9:GetPhrase(v2.desc) or v2.desc or "")
                    activecvar = v2.convar and ("arc9_" .. v2.convar) or ""
                    if bg.desc then bg.desc:Remove() end

                    local desc = vgui.Create("ARC9ScrollPanel", bg)
                    desc:SetPos(bg:GetWide() - ARC9ScreenScale(97.5), ARC9ScreenScale(35))
                    desc:SetSize(ARC9ScreenScale(93), bg:GetTall() - ARC9ScreenScale(40))
                    desc.Paint = function(self2, w, h)
                        -- surface.SetDrawColor(144, 0, 0, 100)
                        -- surface.DrawRect(0, 0, w, h)
                    end
                    bg.desc = desc

                    local descmultiline = ARC9MultiLineText(activedesc, desc:GetWide() - ARC9ScreenScale(1), "ARC9_8")
                    for i, text in ipairs(descmultiline) do
                        local desc_line = vgui.Create("DPanel", desc)
                        desc_line:SetSize(desc:GetWide(), ARC9ScreenScale(8))
                        desc_line:Dock(TOP)
                        desc_line.Paint = function(self2, w, h)
                            surface.SetFont("ARC9_8")
                            surface.SetTextColor(ARC9.GetHUDColor("fg"))
                            surface.SetTextPos(ARC9ScreenScale(2), 0)
                            surface.DrawText(text)
                        end
                    end
                end

                local txt = ARC9:GetPhrase(v2.text) or ARC9:GetPhrase("settings" .. "." .. (v2.convar or "") .. ".title") or v2.text or ""

                surface.SetFont("ARC9_12_Slim")
                local tw, th = surface.GetTextSize(txt)
                if noperms then
                    surface.SetTextColor(ARC9.GetHUDColor("unowned"))
                else
                    surface.SetTextColor(ARC9.GetHUDColor("fg"))
                end

                surface.SetTextPos(ARC9ScreenScale(4), h/2 - th/2)
                surface.DrawText(txt)
            end

            local elpw, elph = bg:GetWide() - ARC9ScreenScale(232), ARC9ScreenScale(21)

            if v2.type == "label" then
                -- woopsie
            elseif v2.type == "bool" then
                local newel = vgui.Create("ARC9Checkbox", elpanel)
                newel:SetPos(elpw+ARC9ScreenScale(5), ARC9ScreenScale(4))
                if v2.convar then newel:SetConVar("arc9_" .. v2.convar) end
                if noperms then newel:SetEnabled(false) end
            elseif v2.type == "slider" then
                local newel = vgui.Create("ARC9NumSlider", elpanel)
                newel:SetPos(ARC9ScreenScale(23), ARC9ScreenScale(6))
                newel:SetSize(elpw, 30)
                newel:SetDecimals(v2.decimals or 0)
                newel:SetMin(v2.min or 0)
                newel:SetMax(v2.max or 255)
                if v2.convar then newel:SetConVar("arc9_" .. v2.convar) end
                if v2.convar2 then newel:SetValue(GetConVar("arc9_" .. v2.convar2):GetFloat()) end
                if noperms then newel:SetEnabled(false) end

                local oldmousereleased = newel.Slider.OnMouseReleased
                newel.Slider.OnMouseReleased = function(self2, kc)
                    oldmousereleased(self2, kc)
                    if v2.func then v2.func(self2, newel, bg) end
                end
            elseif v2.type == "color" then
                local newel = vgui.Create("ARC9ColorButton", elpanel)
                newel:SetPos(elpw-ARC9ScreenScale(65), ARC9ScreenScale(6))

                local cvar = "arc9_" .. (v2.convar or "ya_dumbass")
                newel:CustomSetConvar(cvar)

                if GetConVar(cvar .. "_r") then
                    newel.rgbcolor = Color(GetConVar(cvar .. "_r"):GetInt() or 255, GetConVar(cvar .. "_g"):GetInt() or 0, GetConVar(cvar .. "_b"):GetInt() or 0)
                else
                    newel.rgbcolor = Color(255, 0, 0)
                    print("you are dumb, missing color convar")
                end

                if noperms then newel:SetEnabled(false) end
            elseif v2.type == "coloralpha" then
                local newel = vgui.Create("ARC9ColorButton", elpanel)
                newel:SetPos(elpw-ARC9ScreenScale(65), ARC9ScreenScale(6))
                newel:EnableAlpha()

                local cvar = "arc9_" .. (v2.convar or "ya_dumbass")
                newel:CustomSetConvar(cvar)

                if GetConVar(cvar .. "_a") then
                    newel.rgbcolor = Color(GetConVar(cvar .. "_r"):GetInt() or 255, GetConVar(cvar .. "_g"):GetInt() or 0, GetConVar(cvar .. "_b"):GetInt() or 0, GetConVar(cvar .. "_a"):GetInt() or 255)
                else
                    newel.rgbcolor = Color(255, 0, 0)
                    print("you are dumb, missing color convar (or its _alpha)")
                end

                if noperms then newel:SetEnabled(false) end
            elseif v2.type == "input" then
                local newel = vgui.Create("DTextEntry", elpanel)
                newel:SetPos(elpw-ARC9ScreenScale(65), ARC9ScreenScale(6))
                newel:SetText(v2.text)
            elseif v2.type == "combo" then
                local newel = vgui.Create("ARC9ComboBox", elpanel)
                newel:SetPos(elpw-ARC9ScreenScale(65), ARC9ScreenScale(6))
                newel:CustomSetConvar("arc9_" .. v2.convar)

                local cvdata = GetConVar("arc9_" .. v2.convar):GetString()

                for _, choice in pairs(v2.content) do
                    if tostring(choice[2]) == cvdata then
                        newel:AddChoice(choice[1], choice[2], true)
                    else
                        newel:AddChoice(choice[1], choice[2])
                    end
                end

                local oldCloseMenu = newel.CloseMenu
                newel.CloseMenu = function(self2)
                    oldCloseMenu(self2, kc)
                    if true and v2.func then v2.func(self2) end
                end

                if noperms then newel:SetEnabled(false) end
            elseif v2.type == "button" then
                local newel = vgui.Create("ARC9Button", elpanel)
                newel:SetPos(elpw-ARC9ScreenScale(65), ARC9ScreenScale(6))
                newel.text = ARC9:GetPhrase(v2.content)

                local oldmousepressed = newel.OnMousePressed
                newel.OnMousePressed = function(self2, kc)
                    oldmousepressed(self2, kc)
                    if kc == MOUSE_LEFT and v2.func then v2.func(self2) end
                end

                if noperms then newel:SetEnabled(false) end
            end
        end

        local thatsheet = sheet:AddSheet(v.TabName, newpanel)
        thatsheet.PageID = k

        thatsheet.Button:DockMargin(0, 0, ARC9ScreenScale(1.5), ARC9ScreenScale(1.7))
        thatsheet.Button:SetTall(ARC9ScreenScale(19))
        thatsheet.Button:SetText("")

        thatsheet.Button.Paint = function(self2, w, h)
            local mainbuttoncolor = ARC9.GetHUDColor("bg")
            local barbuttoncolor = ARC9.GetHUDColor("bg")
            local buttontextcolor = ARC9.GetHUDColor("fg")

            if sheet:GetActiveButton() == self2 then
                mainbuttoncolor = ARC9.GetHUDColor("hi")
                barbuttoncolor = ARC9.GetHUDColor("hi")
                buttontextcolor = ARC9.GetHUDColor("shadow")
            end

            if v.Warning and v.Warning() then
                barbuttoncolor = color_Notif
            end

            if self2:IsHovered() then
                barbuttoncolor = ARC9.GetHUDColor("hi")
            end

            surface.SetDrawColor(barbuttoncolor)
            surface.DrawRect(0, 0, ARC9ScreenScale(1.7), h)
            surface.SetDrawColor(mainbuttoncolor)
            surface.DrawRect(ARC9ScreenScale(3.4), 0, w-ARC9ScreenScale(3.4), h)

            surface.SetFont("ARC9_12")
            local tw = surface.GetTextSize(ARC9:GetPhrase(v.TabName) or v.TabName)

            surface.SetTextColor(buttontextcolor)
            surface.SetTextPos((w - tw) / 2 + ARC9ScreenScale(1.7), ARC9ScreenScale(3))
            surface.DrawText(ARC9:GetPhrase(v.TabName) or v.TabName)


            if v.Warning and v.Warning() then
                surface.SetDrawColor(color_Notif)
                surface.SetMaterial(mat_Notif)
                surface.DrawTexturedRect(ARC9ScreenScale(8), h / 2 - h / 6, h / 3, h / 3)
            end
        end

        thatsheet.Button.DoClickOld = thatsheet.Button.DoClick
        thatsheet.Button.DoClick = function(self2)
            self2:DoClickOld()
            ARC9.SettingsActiveTab = k
        end

        buttontalling = buttontalling + ARC9ScreenScale(19+1.7)
    end

    bg.Paint = function(self2, w, h)
        draw.NoTexture()

        surface.SetDrawColor(ARC9.GetHUDColor("bg"))
        local talll = sheet.Navigation:GetTall() + ARC9ScreenScale(6.7)
        surface.DrawPoly({{x = cornercut, y = h}, {x = 0, y = h-cornercut}, {x = 0, y = h-math.max(ARC9ScreenScale(5), talll-buttontalling)}, {x = ARC9ScreenScale(98,4), y = h-math.max(ARC9ScreenScale(5), talll-buttontalling)}, {x = ARC9ScreenScale(98,4), y = h}}) -- left bottom panel
        surface.DrawPoly({{x = w-ARC9ScreenScale(98,4), y = h}, {x = w-ARC9ScreenScale(98,4), y = ARC9ScreenScale(25.7)}, {x = w, y = ARC9ScreenScale(25.7)}, {x = w, y = h-cornercut}, {x = w-cornercut, y = h}}) -- right panel
        surface.DrawPoly({{x = 0, y = ARC9ScreenScale(24)},{x = 0, y = cornercut},{x = cornercut, y = 0}, {x = w-cornercut, y = 0}, {x = w, y = cornercut}, {x = w, y = ARC9ScreenScale(24)}}) -- top panel

        surface.SetDrawColor(ARC9.GetHUDColor("hi"))
        surface.DrawPoly({{x = cornercut, y = h}, {x = 0, y = h-cornercut}, {x = cornercut, y = h-cornercut*.5}})
        surface.DrawPoly({{x = w, y = h-cornercut}, {x = w-cornercut, y = h}, {x = w-cornercut, y = h-cornercut*.5}})
        surface.DrawPoly({{x = cornercut, y = h-cornercut*.5}, {x = w-cornercut, y = h-cornercut*.5}, {x = w-cornercut, y = h}, {x = cornercut, y = h}, })


        -- surface.SetDrawColor(ARC9.GetHUDColor("fg"))
        -- surface.SetMaterial(mat_icon)
        -- surface.DrawTexturedRect(ARC9ScreenScale(4), ARC9ScreenScale(2), ARC9ScreenScale(20), ARC9ScreenScale(20))

        -- ARC9.DrawColoredARC9Logo(ARC9ScreenScale(4), ARC9ScreenScale(2), ARC9ScreenScale(20), ARC9.GetHUDColor("hi"))

        -- function ARC9.DrawColoredARC9Logo(x, y, s, col)
        do
            local x, y, s = ARC9ScreenScale(4), ARC9ScreenScale(2), ARC9ScreenScale(20)
            surface.SetDrawColor(255, 255, 255)
            surface.SetMaterial(arc9logo_layer1)
            surface.DrawTexturedRect(x, y, s, s)

            surface.SetDrawColor(ARC9.GetHUDColor("hi"))
            surface.SetMaterial(arc9logo_layer2)
            surface.DrawTexturedRect(x, y, s, s)
        end

        surface.SetFont("ARC9_8_Slim")
        surface.SetTextColor(ARC9.GetHUDColor("fg"))
        surface.SetTextPos(w-ARC9ScreenScale(96), ARC9ScreenScale(26))
        surface.DrawText(activedesc != "" and ARC9:GetPhrase("settings.desc") or "") -- no title if no desc

        if activecvar != "" then -- display the cvar at the bottom of the description page
            local freshcvar = ""
            local cvarrealm = nil

            if !GetConVar(activecvar) and GetConVar(activecvar .. "_r") then
                freshcvar = activecvar .. "_r/_g/_b" .. (GetConVar(activecvar .. "_a") and "/_a" or "")
            else
                freshcvar = activecvar .. " " .. (GetConVar(activecvar):GetString() or "")
            end

            if !GetConVar(activecvar) and GetConVar(activecvar .. "_r") then -- also display the default value of said cvar

                if GetConVar(activecvar .. "_a") then ifalpha = "," .. GetConVar(activecvar .. "_a"):GetDefault() else ifalpha = "" end -- check if an alpha convar also exists

                if string.len(ARC9:GetPhrase("settings.default_convar")) > 17 then -- if the string is over 17 characters long, then make it two value displays
                    defaultvalue = GetConVar(activecvar .. "_r"):GetDefault() .. "," .. GetConVar(activecvar .. "_g"):GetDefault() .. ","
                    defaultvalue2 = GetConVar(activecvar .. "_b"):GetDefault() .. ifalpha
                else -- otherwise, only use one
                    defaultvalue = GetConVar(activecvar .. "_r"):GetDefault() .. "," .. GetConVar(activecvar .. "_g"):GetDefault() .. "," .. GetConVar(activecvar .. "_b"):GetDefault() .. ifalpha
                    defaultvalue2 = ""
                end

                if !game.SinglePlayer() and !LocalPlayer():IsListenServerHost() then
                    if ARC9.ConVarData[activecvar .. "_r"].client then
                        cvarrealm = "settings.convar_client"
                    else
                        cvarrealm = "settings.convar_server"
                    end
                end
            else
                defaultvalue = GetConVar(activecvar):GetDefault()
                defaultvalue2 = ""

                if !game.SinglePlayer() and !LocalPlayer():IsListenServerHost() then
                    if ARC9.ConVarData[activecvar].client then
                        cvarrealm = "settings.convar_client"
                    else
                        cvarrealm = "settings.convar_server"
                    end
                end
            end

            local bump = cvarrealm and ARC9ScreenScale(37.5) or ARC9ScreenScale(30)
            surface.SetTextColor(ARC9.GetHUDColor("hint"))

            surface.SetTextColor(ARC9.GetHUDColor("fg"))
            surface.SetTextPos(w-ARC9ScreenScale(90), h-bump)
            surface.DrawText(freshcvar)
            bump = bump - ARC9ScreenScale(7.5)

            surface.SetTextColor(ARC9.GetHUDColor("hint"))
            if cvarrealm then
                surface.SetTextPos(w-ARC9ScreenScale(90), h-bump)
                surface.DrawText(ARC9:GetPhrase(cvarrealm))
                bump = bump - ARC9ScreenScale(7.5)
            end

            surface.SetTextPos(w-ARC9ScreenScale(90), h-bump)
            surface.DrawText(ARC9:GetPhrase("settings.default_convar") .. ": " .. defaultvalue)
            bump = bump - ARC9ScreenScale(7.5)

            surface.SetTextPos(w-ARC9ScreenScale(90), h-bump)
            surface.DrawText(defaultvalue2)
        end

        surface.SetFont("ARC9_16")
        surface.SetTextColor(ARC9.GetHUDColor("fg"))
        surface.SetTextPos(ARC9ScreenScale(30), ARC9ScreenScale(4))
        surface.DrawText(ARC9:GetPhrase("settings.title"))
    end

    if page then
        for k, v in pairs(sheet.Items) do
            if v.PageID == page then
                v.Button:DoClick()
            end
        end
    end
end

local hoversound = "arc9/newui/uimouse_hover.ogg"
local clicksound = "arc9/newui/uimouse_click_return.ogg"

local arc9_hud_darkmode = GetConVar("arc9_hud_darkmode")

function ARC9_OpenSettings(page)
    page = page or ARC9.SettingsActiveTab
    local bg = vgui.Create("DFrame")
    bg:SetPos(0, 0)
    bg:SetSize(ScrW(), ScrH())
    bg:SetTitle("")
    bg:SetDraggable(false)
    bg:ShowCloseButton(false)        -- set to false when done please!!
    bg:SetAlpha(0)
    bg:AlphaTo(255, 0.2, 0, nil)
    bg:SetBackgroundBlur(true)
    -- bg:MakePopup()

    bg.Paint = function(self2, w, h)
        if arc9_hud_darkmode:GetBool() then
            surface.SetDrawColor(58, 58, 58, 206)
        else
            surface.SetDrawColor(20, 20, 20, 224)
        end
        surface.DrawRect(0, 0, w, h)
    end

    local panel = vgui.Create("DFrame", bg)
    -- panel:SetSize(ARC9ScreenScale(330), ARC9ScreenScale(242))
    panel:SetSize(ScrH()*1.25, ScrH()*0.75)
    panel:MakePopup()
    panel:SetAlpha(0)
    panel:AlphaTo(255, 0.2, 0, nil)
    panel:Center()
    panel:SetTitle("")
    panel:DockPadding(0, ARC9ScreenScale(25.7), 0, 0)
    panel:ShowCloseButton(false)
    DrawSettings(panel, page)

    panel.OnRemove = function() bg:Remove() end


    -- do only if april fools
    local day = tonumber(os.date("%d"))
    local month = tonumber(os.date("%m"))

    if month == 4 and day == 1 then
        local m9k = vgui.Create("ARC9TopButton", panel)
        m9k:SetPos(panel:GetWide() - ARC9ScreenScale(21*4 + 11), ARC9ScreenScale(2))
        m9k:SetIcon(Material("arc9/ui/w9k.png", "mips smooth"))
        m9k.DoClick = function(self2)
            surface.PlaySound(clicksound)
            gui.OpenURL("https://steamcommunity.com/sharedfiles/filedetails/?id=128089118")
        end
    end

    local discord = vgui.Create("ARC9TopButton", panel)
    discord:SetPos(panel:GetWide() - ARC9ScreenScale(21*3 + 8), ARC9ScreenScale(2))
    discord:SetIcon(Material("arc9/ui/discord.png", "mips smooth"))
    discord.DoClick = function(self2)
        surface.PlaySound(clicksound)
        gui.OpenURL("https://discord.gg/wkafWps44a")
    end

    local steam = vgui.Create("ARC9TopButton", panel)
    steam:SetPos(panel:GetWide() - ARC9ScreenScale(21*2 + 5), ARC9ScreenScale(2))
    steam:SetIcon(Material("arc9/ui/steam.png", "mips smooth"))
    steam.DoClick = function(self2)
        surface.PlaySound(clicksound)
        gui.OpenURL("https://steamcommunity.com/sharedfiles/filedetails/?id=2910505837")
    end

    local close = vgui.Create("ARC9TopButton", panel)
    close:SetPos(panel:GetWide() - ARC9ScreenScale(21+2), ARC9ScreenScale(2))
    close:SetIcon(Material("arc9/ui/close.png", "mips smooth"))
    close.DoClick = function(self2)
        surface.PlaySound(clicksound)
        -- print(ARC9.SettingsActiveTab)
        panel:AlphaTo(0, 0.1, 0, nil)
        bg:AlphaTo(0, 0.1, 0, function()
            bg:Remove()
            panel:Remove()
        end)
    end

    bg.OnMousePressed = function(self2, keycode)
        close.DoClick()
    end

    -- timer.Simple(33, function()
    --     bg:Remove()
    --     panel:Remove()
    -- end)
end
--PATH lua/arc9/client/cl_tpik.lua:
return gluapack()()
--PATH lua/arc9/client/cl_vgui_elements.lua:
local ARC9ScreenScale = ARC9.ScreenScale
local hoversound = "arc9/newui/uimouse_hover.ogg"
local clicksound = "arc9/newui/uimouse_click_forward.ogg"
local ARC9TopButton = {}
ARC9TopButton.Color = ARC9.GetHUDColor("fg")
ARC9TopButton.ColorClicked = ARC9.GetHUDColor("hi")
ARC9TopButton.ColorNotif = Color(255, 50, 50)
ARC9TopButton.Icon = Material("arc9/ui/settings.png", "mips")
ARC9TopButton.MatIdle = Material("arc9/ui/topbutton.png", "mips")
ARC9TopButton.MatHovered = Material("arc9/ui/topbutton_hover.png", "mips")
ARC9TopButton.MatIdleL = Material("arc9/ui/topbutton_l.png", "mips")
ARC9TopButton.MatHoveredL = Material("arc9/ui/topbutton_hover_l.png", "mips")
ARC9TopButton.MatIdleM = Material("arc9/ui/topbutton_m.png", "mips")
ARC9TopButton.MatHoveredM = Material("arc9/ui/topbutton_hover_m.png", "mips")
ARC9TopButton.MatIdleR = Material("arc9/ui/topbutton_r.png", "mips")
ARC9TopButton.MatHoveredR = Material("arc9/ui/topbutton_hover_r.png", "mips")
ARC9TopButton.MatNotif = Material("arc9/ui/info.png", "mips")

local function syncconvar(self, val)

    if LocalPlayer():IsAdmin() and ARC9.ShouldNetworkConVar(LocalPlayer(), self.m_strConVar) then
        ARC9.NetworkConVar(self.m_strConVar, tostring(val))
    else
        if not self.m_strConVar or #self.m_strConVar < 2 then return end
        RunConsoleCommand(self.m_strConVar, tostring(val))
    end
end

local function syncconvardelayed(self, val)

    if LocalPlayer():IsAdmin() and ARC9.ShouldNetworkConVar(LocalPlayer(), self.m_strConVar) then
        timer.Create("cvarsend_" .. self.m_strConVar, 0.5, 1, function()
            ARC9.NetworkConVar(self.m_strConVar, tostring(val))
        end)
    else
        if not self.m_strConVar or #self.m_strConVar < 2 then return end
        RunConsoleCommand(self.m_strConVar, tostring(val))
    end
end

function ARC9TopButton:Init()
    self:SetText("")
    self:SetSize(ARC9ScreenScale(21), ARC9ScreenScale(21))
    self.DarkMode = GetConVar("arc9_hud_darkmode"):GetBool()
end

function ARC9TopButton:Paint(w, h)
    local color = self.DarkMode and ARC9.GetHUDColor("bg") or self.Color
    local iconcolor = self.Color
    local icon = self.Icon
    local text = self.ButtonText
    local mat = self.MatIdle
    local matl = self.MatIdleL
    local matm = self.MatIdleM
    local matr = self.MatIdleR

    if self:IsHovered() then
        color = ARC9.GetHUDColor("hi")
        mat = self.MatHovered
        matl = self.MatHoveredL
        matm = self.MatHoveredM
        matr = self.MatHoveredR
    end

    if self:IsDown() or (self.Checkbox and self:GetChecked()) then
        iconcolor = ARC9.GetHUDColor("hi")
    end

    if self.Notif then
        surface.SetDrawColor(self.ColorNotif, 255)
        surface.SetMaterial(mat)
        surface.DrawTexturedRect(0, 0, w, h)
    end

    surface.SetDrawColor(color)

    -- wide button
    if text then
        surface.SetMaterial(matl)
        for _=1, (self.DarkMode and 4 or 1) do surface.DrawTexturedRect(0, 0, h / 2, h) end
        surface.SetMaterial(matm)
        for _=1, (self.DarkMode and 4 or 1) do surface.DrawTexturedRect(h / 2, 0, w - h, h) end
        surface.SetMaterial(matr)
        for _=1, (self.DarkMode and 4 or 1) do surface.DrawTexturedRect(w - h / 2, 0, h / 2, h) end
        surface.SetFont(self.Font or "ARC9_16")
        local tw = surface.GetTextSize(text)
        surface.SetTextColor(iconcolor)
        surface.SetTextPos(h, h / 8)
        surface.DrawText(text)
    else
        surface.SetMaterial(mat)
        for _=1, (self.DarkMode and 4 or 1) do surface.DrawTexturedRect(0, 0, w, h) end
    end

    surface.SetDrawColor(iconcolor)
    surface.SetMaterial(icon)
    surface.DrawTexturedRect(h / 5, h / 5, h - h / 2.5, h - h / 2.5)

    if self.Notif then
        surface.SetDrawColor(self.ColorNotif)
        surface.SetMaterial(self.MatNotif)
        surface.DrawTexturedRect(w - h / 3, 0, h / 3, h / 3)
    end
end

function ARC9TopButton:OnCursorEntered()
    surface.PlaySound(hoversound)
end

function ARC9TopButton:SetIcon(mat)
    self.Icon = mat
end

function ARC9TopButton:SetNotif(val)
    self.Notif = val
end

function ARC9TopButton:SetButtonText(text, font)
    self.ButtonText = text
    self.Font = font
end

function ARC9TopButton:SetIsCheckbox(bool)
    self.Checkbox = bool
end

vgui.Register("ARC9TopButton", ARC9TopButton, "DCheckBox") -- DButton
local ARC9AttButton = {}
ARC9AttButton.Color = ARC9.GetHUDColor("fg")
ARC9AttButton.ColorBlock = ARC9.GetHUDColor("con")
ARC9AttButton.Icon = Material("arc9/ui/settings.png", "mips")
ARC9AttButton.MatIdle = Material("arc9/ui/att.png", "mips")
ARC9AttButton.MatEmpty = Material("arc9/ui/att_empty.png", "mips")
-- ARC9AttButton.MatHover = Material("arc9/ui/att_hover.png", "mips")
ARC9AttButton.MatBlock = Material("arc9/ui/att_block.png", "mips")
ARC9AttButton.MatMarkerInstalled = Material("arc9/ui/mark_installed.png", "mips smooth")
ARC9AttButton.MatMarkerLock = Material("arc9/ui/mark_lock.png", "mips smooth")
ARC9AttButton.MatMarkerLinked = Material("arc9/ui/mark_linked.png", "mips smooth")
ARC9AttButton.MatMarkerModes = Material("arc9/ui/mark_modes.png", "mips smooth")
ARC9AttButton.MatMarkerSlots = Material("arc9/ui/mark_slots.png", "mips smooth")
ARC9AttButton.MatMarkerFavorite = Material("arc9/ui/mark_favorite.png", "mips smooth")

function ARC9AttButton:Init()
    self:SetText("")
    self:SetSize(ARC9ScreenScale(42.7), ARC9ScreenScale(42.7 + 14.6))
end

function ARC9AttButton:Paint(w, h)
    local color = self.Color
    local iconcolor = self.Color
    local textcolor = self.Color
    local markercolor = self.Color
    local icon = self.Icon or ARC9TopButton.MatIdle
    local text = self.ButtonText
    local colorclicked = ARC9.GetHUDColor("hi")
    local colorgrey = ARC9.GetHUDColor("unowned")
    local mat = self.MatIdle
    local matmarker = nil
    local favmarker = nil
    local att = self.att

    local qty = ARC9:PlayerGetAtts(LocalPlayer(), att)
    local free_or_lock = false

    if self:IsHovered() or self.OverrideHovered then
        textcolor = colorclicked
    end

    if self.HasModes then
        matmarker = self.MatMarkerModes
    elseif self.HasSlots then
        matmarker = self.MatMarkerSlots
    end

    if self.Empty then
        mat = self.MatEmpty
    elseif not self.CanAttach and not self.Installed then
        if self.MissingDependents then
            matmarker = self.MatMarkerLinked
        else
            matmarker = self.MatMarkerLock
        end
        mat = self.MatBlock
        textcolor = self.ColorBlock
        iconcolor = self.ColorBlock
        markercolor = self.ColorBlock
    elseif self:IsDown() or self.Installed then
        -- mat = self.MatHover
        color = colorclicked
        matmarker = self.MatMarkerInstalled
        markercolor = colorclicked
    elseif qty == 0 and not self.Installed and not self.SlotDisplay then
        color = (self:IsHovered() or self.OverrideHovered) and self.Color or colorgrey
        textcolor = color
        iconcolor = colorgrey
    end

    if ARC9.Favorites[att] then
        favmarker = self.MatMarkerFavorite
    end

    surface.SetDrawColor(color)
    surface.SetMaterial(mat)
    surface.DrawTexturedRect(0, 0, w, w)
    -- icon
    render.SuppressEngineLighting(true)
    surface.SetDrawColor(iconcolor)
    surface.SetMaterial(icon)
    render.SetAmbientLight(255, 255, 255)

    if not self.FullColorIcon then
        surface.DrawTexturedRect(ARC9ScreenScale(2), ARC9ScreenScale(2), w - ARC9ScreenScale(4), w - ARC9ScreenScale(4))
    else
        surface.DrawTexturedRect(ARC9ScreenScale(4), ARC9ScreenScale(4), w - ARC9ScreenScale(8), w - ARC9ScreenScale(8))
    end

    render.SuppressEngineLighting(false)
    render.SetLightingMode(0)

    if matmarker then
        surface.SetDrawColor(markercolor)
        surface.SetMaterial(matmarker)
        surface.DrawTexturedRect(ARC9ScreenScale(3), w - ARC9ScreenScale(11), ARC9ScreenScale(8), ARC9ScreenScale(8))
        -- surface.DrawTexturedRect(0, 0, w, w)
    end

    if favmarker then
        surface.SetDrawColor(markercolor)
        surface.SetMaterial(favmarker)
        surface.DrawTexturedRect(w - ARC9ScreenScale(11), ARC9ScreenScale(3), ARC9ScreenScale(8), ARC9ScreenScale(8))
    end

    if self.FolderContain then
        surface.SetFont("ARC9_12")
        local tww = surface.GetTextSize(self.FolderContain)
        surface.SetTextColor(iconcolor)
        surface.SetTextPos((w - tww) / 2, h - ARC9ScreenScale(28))
        surface.DrawText(self.FolderContain)
    end

    -- text
    surface.SetFont("ARC9_9")
    local tw = surface.GetTextSize(text)
    surface.SetTextColor(textcolor)

    -- print(textcolor)

    if tw > w then
        ARC9.DrawTextRot(self, text, 0, h - ARC9ScreenScale(13.5), 0, h - ARC9ScreenScale(13.5), w, false)
    else
        surface.SetTextPos((w - tw) / 2, h - ARC9ScreenScale(13.5))
        surface.DrawText(text)
        -- markup.Parse("<font=ARC9_9>" .. text):Draw((w - tw) / 2, h - ARC9ScreenScale(13.5), TEXT_ALIGN_LEFT, TEXT_ALIGN_LEFT)
    end

    if att then
        local atttbl = ARC9.GetAttTable(att)

        if atttbl.Free or GetConVar("arc9_free_atts"):GetBool() then
            free_or_lock = true
        end

        if GetConVar("arc9_atts_lock"):GetBool() then
            free_or_lock = true
        end

        if not free_or_lock and (qty > 0 or self.Installed) then

            local qtext = "x" .. tostring(qty)

            surface.SetFont("ARC9_9")
            local qtw = surface.GetTextSize(qtext)
            surface.SetTextColor(textcolor)

            surface.SetTextPos(w - qtw - ARC9ScreenScale(4), ARC9ScreenScale(1))
            surface.DrawText(qtext)
        end

        if self.Installed or qty > 0 then
        else
            surface.SetMaterial( ARC9AttButton.MatMarkerLock )
            surface.SetDrawColor( 255, 255, 255, 32 )

            local size = ARC9ScreenScale(14)
            surface.DrawTexturedRect(ARC9ScreenScale(21.5) - size/2, ARC9ScreenScale(21.5) - size/2, size, size )
        end
    end
end

function ARC9AttButton:OnCursorEntered()
    surface.PlaySound(hoversound)
end

function ARC9AttButton:SetIcon(mat)
    self.Icon = mat
end

function ARC9AttButton:SetButtonText(text)
    self.ButtonText = text
end

function ARC9AttButton:SetEmpty(bool)
    self.Empty = bool
end

function ARC9AttButton:SetOverrideHovered(bool)
    self.OverrideHovered = bool
end

function ARC9AttButton:SetInstalled(bool)
    self.Installed = bool
end

function ARC9AttButton:SetCanAttach(bool)
    self.CanAttach = bool
end

function ARC9AttButton:SetMissingDependents(bool)
    self.MissingDependents = bool
end


function ARC9AttButton:SetSlotDisplay(bool)
    self.SlotDisplay = bool
end


function ARC9AttButton:SetFolderContain(num)
    self.FolderContain = num
end

function ARC9AttButton:SetHasModes(bool)
    self.HasModes = bool
end

function ARC9AttButton:SetHasSlots(bool)
    self.HasSlots = bool
end

function ARC9AttButton:SetFullColorIcon(bool)
    self.FullColorIcon = bool
end

vgui.Register("ARC9AttButton", ARC9AttButton, "DCheckBox") -- DButton
local ARC9ScrollPanel = {}

function ARC9ScrollPanel:Init()
    self.VBar:SetHideButtons(true)
    self.VBar:SetWide(ARC9ScreenScale(2))
    self.VBar:SetAlpha(0) -- to prevent blinking
    self.VBar:AlphaTo(255, 0.2, 0, nil)

    self.VBar.Paint = function(panel, w, h)
        surface.SetDrawColor(ARC9.GetHUDColor("bg"))
        surface.DrawRect(0, 0, w, h)
    end

    self.VBar.btnGrip.Paint = function(panel, w, h)
        surface.SetDrawColor(ARC9.GetHUDColor("fg"))
        surface.DrawRect(0, 0, w, h)
    end

    local smoothdlta = 0

    self.VBar.AddScroll = function(self2, dlta)
        local OldScroll = self2:GetScroll()
        dlta = dlta * 35
        smoothdlta = Lerp(0.08, smoothdlta, dlta)
        self2:SetScroll(self2:GetScroll() + smoothdlta)

        return OldScroll ~= self2:GetScroll()
    end
end

function ARC9ScrollPanel:Paint(w, h)
end

vgui.Register("ARC9ScrollPanel", ARC9ScrollPanel, "DScrollPanel")
local ARC9HorizontalScroller = {}

local circlemat = Material("arc9/circle.png", "smooth mips")
local circlefillmat = Material("arc9/circlefill.png", "smooth mips")

function ARC9HorizontalScroller:Init()
    local smoothdlta = 0

    self.OnMouseWheeled = function(self2, dlta)
        dlta = dlta * -55
        smoothdlta = Lerp(0.08, smoothdlta, dlta)
        self2.OffsetX = self2.OffsetX + smoothdlta
        self2:InvalidateLayout(true)

        return true
    end
end

function ARC9HorizontalScroller:Think()
    local wep = LocalPlayer():GetActiveWeapon()

    if not IsValid(wep) then return end

    wep.LastScroll = self.OffsetX
end

function ARC9HorizontalScroller:RefreshScrollBar(bar)
    local width = self:GetWide()
    local contentswidth = self.pnlCanvas:GetWide()

    if contentswidth > width then
        -- Create a panel centered in the bottom middle of bar
        -- This will be the scroll bar
        -- Drag the scroll bar to scroll the contents
        -- Width should be the ratio of the width of the bar to the width of the contents

        if IsValid(self.ScrollBarParent) then
            self.ScrollBarParent:Remove()
            self.ScrollBarParent = nil
        end

        self.ScrollBarParent = vgui.Create("DPanel", bar)
        self.ScrollBarParent:SetSize(bar:GetWide(), ARC9ScreenScale(5))
        self.ScrollBarParent:SetPos(0, 0)
        self.ScrollBarParent.Paint = function(panel, w, h)
        end

        local scrollbar = vgui.Create("DPanel", self.ScrollBarParent)
        scrollbar:SetSize(self.ScrollBarParent:GetWide() * (width / contentswidth), ARC9ScreenScale(1))
        scrollbar:SetPos(0, 0)
        scrollbar.Paint = function(panel, w, h)
            surface.SetDrawColor(ARC9.GetHUDColor("hi"))
            surface.DrawRect(0, 0, w, ARC9ScreenScale(1))
        end

        scrollbar.Think = function(panel)
            local x, y = self.pnlCanvas:GetPos()
            local width = self:GetWide()
            local contentswidth = self.pnlCanvas:GetWide()
            local scrollwidth = self.ScrollBarParent:GetWide()
            local scrollpos = math.Clamp(-x / (contentswidth - width), 0, 1)
            local scrollx = scrollpos * (scrollwidth - scrollbar:GetWide())

            panel:SetPos(scrollx, y)
        end

        self.Dragging = false

        self.ScrollBarParent.Think = function(panel)
            -- Scroll functionality
            local scrollwidth = self.ScrollBarParent:GetWide()
            local contentswidth = self.pnlCanvas:GetWide()
            local width = self:GetWide()

            local mx, my = input.GetCursorPos()
            local px, py = panel:LocalToScreen(0, 0)
            local pw, ph = panel:GetSize()

            if input.IsMouseDown(MOUSE_LEFT) then
                if not self.Dragging then
                    if mx > px and mx < px + pw and my > py and my < py + ph then
                        self.Dragging = true
                    end
                end
            else
                self.Dragging = false
            end

            if self.Dragging then
                local scrollpos = math.Clamp((mx - px - (scrollbar:GetWide() / 2)) / (scrollwidth - scrollbar:GetWide()), 0, 1)
                local scrollx = scrollpos * (contentswidth - width)
                self:SetScroll(scrollx)
            else
                self:SetScroll(self.OffsetX)
            end
        end

        self.ScrollBarParent:MoveToFront()
    else
        if IsValid(self.ScrollBarParent) then
            self.ScrollBarParent:Remove()
            self.ScrollBarParent = nil
        end
    end
end

vgui.Register("ARC9HorizontalScroller", ARC9HorizontalScroller, "DHorizontalScroller")
local ARC9ColumnSheet = {}

function ARC9ColumnSheet:Init()
    self.Navigation = vgui.Create("ARC9ScrollPanel", self)
    self.Navigation:Dock(LEFT)
    self.Navigation:SetWidth(100)
    self.Navigation:DockMargin(10, 10, 10, 0)
    self.Content = vgui.Create("Panel", self)
    self.Content:Dock(FILL)
    self.Items = {}
end

vgui.Register("ARC9ColumnSheet", ARC9ColumnSheet, "DColumnSheet")
local ARC9Checkbox = {}
ARC9Checkbox.Color = ARC9.GetHUDColor("fg")
ARC9Checkbox.ColorClicked = ARC9.GetHUDColor("hi")
ARC9Checkbox.MatIdle = Material("arc9/ui/checkbox.png", "mips")
ARC9Checkbox.MatSel = Material("arc9/ui/checkbox_sel.png", "mips")
ARC9Checkbox.MatToggled = Material("arc9/ui/checkbox_toggled.png", "mips")

function ARC9Checkbox:Init()
    self:SetSize(ARC9ScreenScale(13), ARC9ScreenScale(13))
end

function ARC9Checkbox:Paint(w, h)
    local color = self.Color
    local color2 = ARC9.GetHUDColor("hi")
    surface.SetDrawColor(color)
    surface.SetMaterial(self.MatIdle)
    surface.DrawTexturedRect(0, 0, w, w)

    if self:GetChecked() then
        surface.SetDrawColor(color2)
        surface.SetMaterial(self.MatToggled)
        surface.DrawTexturedRect(0, 0, w, w)
    end

    if self:IsHovered() and self:IsEnabled() then
        surface.SetDrawColor(color2)
        surface.SetMaterial(self.MatSel)
        surface.DrawTexturedRect(0, 0, w, w)
    end
end

ARC9Checkbox.ConVarChanged = syncconvar

vgui.Register("ARC9Checkbox", ARC9Checkbox, "DCheckBox")
local ARC9NumSlider = {}
ARC9NumSlider.Color = ARC9.GetHUDColor("fg")
ARC9NumSlider.ColorClicked = ARC9.GetHUDColor("hi")

function ARC9NumSlider:Init()
    local color = self.Color
    local color2 = ARC9.GetHUDColor("hi")
    local color3 = ARC9.GetHUDColor("hint")
    self.Slider.Knob:SetSize(ARC9ScreenScale(1.7), ARC9ScreenScale(7))

    self.Slider.Knob.Paint = function(panel, w, h)
        surface.SetDrawColor(color)
        surface.DrawRect(0, 0, w, h)
    end

    self.Slider.Paint = function(panel, w, h)
        surface.SetDrawColor(color3)
        surface.DrawRect(0, h / 3, w, h / 4)
        surface.SetDrawColor(color)
        surface.DrawRect(0, h / 3, w * self.Scratch:GetFraction(), h / 4)
    end

    self.Scratch.ConVarChanged = syncconvardelayed
    self.TextArea.ConVarChanged = syncconvardelayed

    self.TextArea:SetWide(ARC9ScreenScale(20))
    self.TextArea:DockMargin(ARC9ScreenScale(3), 0, 0, 0)
    self.TextArea:SetHighlightColor(color2)
    self.TextArea:SetCursorColor(color2)
    self.TextArea:SetTextColor(color)
    self.TextArea:SetFont("ARC9_10_Slim")
    -- self.TextArea.Paint = function(panel, w, h)
    --     surface.SetFont("ARC9_10_Slim")
    --     local text = panel:GetValue() or "Owo"
    --     local tw = surface.GetTextSize(text)
    --     surface.SetTextColor(color)
    --     surface.SetTextPos(w-tw, ARC9ScreenScale(0))
    --     surface.DrawText(text)
    -- end
end


vgui.Register("ARC9NumSlider", ARC9NumSlider, "DNumSlider")
local ARC9ComboBox = {}
ARC9ComboBox.Color = ARC9.GetHUDColor("fg")
ARC9ComboBox.ColorClicked = ARC9.GetHUDColor("hi")
ARC9ComboBox.MatIdle = Material("arc9/ui/dd.png", "mips")
ARC9ComboBox.MatSel = Material("arc9/ui/dd_sel.png", "mips")
ARC9ComboBox.MatOpened = Material("arc9/ui/dd_opened.png", "mips")
ARC9ComboBox.MatOpenedSel = Material("arc9/ui/dd_opened_sel.png", "mips")
ARC9ComboBox.MatSingle = Material("arc9/ui/dd_option.png", "mips")
ARC9ComboBox.MatSingleSel = Material("arc9/ui/dd_option_sel.png", "mips")
ARC9ComboBox.MatLast = Material("arc9/ui/dd_option_last.png", "mips")
ARC9ComboBox.MatLastSel = Material("arc9/ui/dd_option_last_sel.png", "mips")

function ARC9ComboBox:Init()
    self:SetSize(ARC9ScreenScale(84), ARC9ScreenScale(13))
    self.DropButton:Remove()
end

-- to fix button we removed
function ARC9ComboBox:PerformLayout()
    DButton.PerformLayout(self, w, h)
end

function ARC9ComboBox:OnSelect(index, value, data)
    self.text = self:GetText()

    if self.Convar then
        if LocalPlayer():IsAdmin() and ARC9.ShouldNetworkConVar(LocalPlayer(), self.Convar) then
            ARC9.NetworkConVar(self.Convar, tostring(data))
        else
            RunConsoleCommand(self.Convar, data)
        end
    end

    self:SetText("")
end

function ARC9ComboBox:CustomSetConvar(cvar)
    self.Convar = cvar
end

function ARC9ComboBox:SetOptions(opt)
    self.IndexToOptions = opt
end

function ARC9ComboBox:OnMenuOpened(menu)
    menu.Paint = function(panel, w, h) end
    menu:SetAlpha(0)
    menu:AlphaTo(255, 0.1, 0, nil)

    -- local mat = self.MatIdle
    for i = 1, menu:ChildCount() do
        local child = menu:GetChild(i)

        child.PerformLayout = function(self22, w22, h22)
            DButton.PerformLayout(self22, w22, h22)
        end

        child:SetSize(ARC9ScreenScale(84), ARC9ScreenScale(13))
        child.id = i
        child.last = i == menu:ChildCount()
        child.text = child:GetText()
        child:SetText("")

        child.Paint = function(self2, w, h)
            local mat = self.MatSingle
            local mat2 = self.MatSingleSel
            local mat3 = self.MatLast
            local mat4 = self.MatLastSel
            local color = self.Color
            local color2 = ARC9.GetHUDColor("hi")

            if self2:IsDown() then
                color = color2
            end

            surface.SetDrawColor(color)
            surface.SetMaterial(self2.last and mat3 or mat)
            surface.DrawTexturedRect(0, 0, w, h)
            local active = self:GetSelectedID() == self2.id

            if active or self2:IsHovered() then
                surface.SetDrawColor(color2)
                surface.SetMaterial(self2.last and mat4 or mat2)
                surface.DrawTexturedRect(0, 0, w, h)
            end

            surface.SetFont("ARC9_10")
            surface.SetTextColor(active and color2 or color)
            surface.SetTextPos(ARC9ScreenScale(4), ARC9ScreenScale(1))
            surface.DrawText(string.sub(child.text or "Owo", 2))
        end
    end
end

function ARC9ComboBox:Paint(w, h)
    local color = self.Color
    local color2 = ARC9.GetHUDColor("hi")
    local mat = self.MatIdle
    local mat2 = self.MatSel
    local mat3 = self.MatOpened
    local mat4 = self.MatOpenedSel
    surface.SetDrawColor(color)
    surface.SetMaterial(self:IsMenuOpen() and mat3 or mat)
    surface.DrawTexturedRect(0, 0, w, h)

    if self:IsHovered() then
        surface.SetDrawColor(color2)
        surface.SetMaterial(self:IsMenuOpen() and mat4 or mat2)
        surface.DrawTexturedRect(0, 0, w, h)
    end

    surface.SetFont("ARC9_10")
    surface.SetTextColor(color)
    surface.SetTextPos(ARC9ScreenScale(4), ARC9ScreenScale(1))
    surface.DrawText(string.sub(self.text or "unselected", 2))
end

vgui.Register("ARC9ComboBox", ARC9ComboBox, "DComboBox")
local ARC9Button = {}
ARC9Button.Color = ARC9.GetHUDColor("fg")
ARC9Button.ColorClicked = ARC9.GetHUDColor("hi")
ARC9Button.MatIdle = Material("arc9/ui/button.png", "mips")
ARC9Button.MatSel = Material("arc9/ui/button_sel.png", "mips")

function ARC9Button:Init()
    self:SetSize(ARC9ScreenScale(84), ARC9ScreenScale(13))
    self.text = self:GetText()
    self:SetText("")
end

function ARC9Button:Paint(w, h)
    local color = self.Color
    local color2 = ARC9.GetHUDColor("hi")

    if self:IsDown() then
        color = color2
    end

    surface.SetDrawColor(color)
    surface.SetMaterial(self.MatIdle)
    surface.DrawTexturedRect(0, 0, w, h)

    if self:IsHovered() then
        surface.SetDrawColor(color2)
        surface.SetMaterial(self.MatSel)
        surface.DrawTexturedRect(0, 0, w, h)
    end

    local text = self.text or ""
    surface.SetFont("ARC9_10")
    local tw = surface.GetTextSize(text)
    surface.SetTextColor(color)
    surface.SetTextPos(w / 2 - tw / 2, ARC9ScreenScale(1.5))
    surface.DrawText(text)
end

vgui.Register("ARC9Button", ARC9Button, "DButton")
local ARC9ColorPanel = {}
ARC9ColorPanel.Color = ARC9.GetHUDColor("fg")
ARC9ColorPanel.ColorClicked = ARC9.GetHUDColor("hi")
ARC9ColorPanel.MatIdle = Material("arc9/ui/colorpanel.png", "mips")
ARC9ColorPanel.MatIdle2 = Material("arc9/ui/colorpanel2.png", "mips")
ARC9ColorPanel.MatCubeR = Material("arc9/ui/colorcube_r")
ARC9ColorPanel.MatCubeD = Material("arc9/ui/colorcube_d")
ARC9ColorPanel.MatCubeF = Material("arc9/ui/colorcube_full")
ARC9ColorPanel.MatSelect = Material("arc9/ui/circle128.png", "mips smooth")
ARC9ColorPanel.MatSelect2 = Material("arc9/ui/circle128_2.png", "mips smooth")

function ARC9ColorPanel:Init()
    self:SetSize(ARC9ScreenScale(84), ARC9ScreenScale(96)) --108
    self:MakePopup()
    self:SetDraggable(true)
    self:SetAlpha(0)
    self:AlphaTo(255, 0.15, 0, nil)
    self:ShowCloseButton(false)
    self.hsvHUE, self.hsvSAT, self.hsvVAL = ColorToHSV(self.startcolor or Color(255, 0, 0))

    self.hsvHUEonly = {
        r = self.hsvHUE,
        g = 1,
        b = 1
    }

    self.ResultColor = self.startcolor or Color(255, 0, 0)
    local huepanel = vgui.Create("DPanel", self)
    huepanel:SetPos(ARC9ScreenScale(2.7), self:GetTall() - ARC9ScreenScale(13))
    huepanel:SetSize(ARC9ScreenScale(79), ARC9ScreenScale(10.5))
    huepanel:NoClipping(true)
    huepanel.LastX = 0
    self.huepanel = huepanel -- for later integration

    huepanel.OnCursorMoved = function(self2, x, y)
        if not input.IsMouseDown(MOUSE_LEFT) then return end
        x = math.Clamp(x, 0, self2:GetWide())
        self2.LastX = x
        self.hsvHUE = (x / self2:GetWide()) * 360
        self.ResultColor = HSVToColor(self.hsvHUE, self.hsvSAT, self.hsvVAL)
        self.hsvHUEonly = HSVToColor(self.hsvHUE, 1, 1)
    end

    huepanel.OnMousePressed = function(self2, mcode)
        self2:MouseCapture(true)
        self2:OnCursorMoved(self2:CursorPos())
        self2:SetCursor("blank")
    end

    huepanel.OnMouseReleased = function(self2, mcode)
        self2:MouseCapture(false)
        self2:OnCursorMoved(self2:CursorPos())
        self2:SetCursor("none")
    end

    huepanel.Paint = function(self2, w, h)
        surface.SetDrawColor(255, 255, 255, 255)
        surface.DrawRect(self2.LastX - ARC9ScreenScale(0.5), -ARC9ScreenScale(1), ARC9ScreenScale(1), h + ARC9ScreenScale(2))
    end

    local cube = vgui.Create("DPanel", self)
    cube:SetPos(ARC9ScreenScale(2.5), ARC9ScreenScale(2.5))
    cube:SetSize(ARC9ScreenScale(79), ARC9ScreenScale(79))
    cube:NoClipping(true)
    self.cube = cube -- for later integration
    cube.LastX = 0
    cube.LastY = 0

    cube.Paint = function(self2, w, h)
        surface.SetDrawColor(255, 255, 255, 255)
        surface.SetMaterial(self.MatCubeF)
        surface.DrawTexturedRect(0, 0, w, h)
        surface.SetDrawColor(self.hsvHUEonly, 255)
        surface.SetMaterial(self.MatCubeR)
        surface.DrawTexturedRect(0, 0, w, h)
        surface.SetDrawColor(0, 0, 0, 255)
        surface.SetMaterial(self.MatCubeD)
        surface.DrawTexturedRect(0, 0, w, h)
        surface.SetDrawColor(255, 255, 255, 255)
        surface.SetMaterial(self.MatSelect)
        surface.DrawTexturedRect(self2.LastX - ARC9ScreenScale(4), self2.LastY - ARC9ScreenScale(4), ARC9ScreenScale(8), ARC9ScreenScale(8))
        surface.SetDrawColor(self.ResultColor, 255)
        surface.SetMaterial(self.MatSelect2)
        surface.DrawTexturedRect(self2.LastX - ARC9ScreenScale(4), self2.LastY - ARC9ScreenScale(4), ARC9ScreenScale(8), ARC9ScreenScale(8))
    end

    cube.OnCursorMoved = function(self2, x, y)
        if not input.IsMouseDown(MOUSE_LEFT) then return end
        x = math.Clamp(x, 0, self2:GetWide())
        y = math.Clamp(y, 0, self2:GetTall())
        self2.LastX = x
        self2.LastY = y
        self.hsvSAT = x / self2:GetWide()
        self.hsvVAL = 1 - y / self2:GetTall()
        self.ResultColor = HSVToColor(self.hsvHUE, self.hsvSAT, self.hsvVAL)
    end

    cube.OnMousePressed = function(self2, mcode)
        self2:MouseCapture(true)
        self2:OnCursorMoved(self2:CursorPos())
        self2:SetCursor("blank")
    end

    cube.OnMouseReleased = function(self2, mcode)
        self2:MouseCapture(false)
        self2:OnCursorMoved(self2:CursorPos())
        self2:SetCursor("none")
    end
end

function ARC9ColorPanel:Paint(w, h)
    local color = self.Color
    surface.SetDrawColor(color)
    surface.SetMaterial(self.MatIdle)
    surface.DrawTexturedRect(0, 0, w, h)
end

function ARC9ColorPanel:UpdateColor(clr)
    local hsvh, hsvs, hsvv = ColorToHSV(clr)
    self.hsvHUE, self.hsvSAT, self.hsvVAL = hsvh, hsvs, hsvv
    self.hsvHUEonly = HSVToColor(hsvh, 1, 1)
    self.ResultColor = clr
    self.cube.LastX = self.cube:GetWide() * hsvs
    self.cube.LastY = self.cube:GetTall() * (1 - hsvv)
    self.huepanel.LastX = self.huepanel:GetWide() * hsvh / 360

    if self.Alpha then
        self.Alpha = clr.a
        self.alphapanel.LastX = self.alphapanel:GetWide() * clr.a / 255
    end
end

function ARC9ColorPanel:EnableAlpha()
    self.Alpha = 255
    self:SetSize(ARC9ScreenScale(84), ARC9ScreenScale(108)) --108
    self.huepanel:SetPos(ARC9ScreenScale(2.7), self:GetTall() - ARC9ScreenScale(13))
    self.MatIdle = self.MatIdle2
    local alphapanel = vgui.Create("DPanel", self)
    alphapanel:SetPos(ARC9ScreenScale(2.7), self:GetTall() - ARC9ScreenScale(25.05))
    alphapanel:SetSize(ARC9ScreenScale(79), ARC9ScreenScale(10.5))
    alphapanel:NoClipping(true)
    alphapanel.LastX = ARC9ScreenScale(79)
    self.alphapanel = alphapanel -- for later integration

    alphapanel.OnCursorMoved = function(self2, x, y)
        if not input.IsMouseDown(MOUSE_LEFT) then return end
        x = math.Clamp(x, 0, self2:GetWide())
        self2.LastX = x
        self.Alpha = (x / self2:GetWide()) * 255
    end

    alphapanel.OnMousePressed = function(self2, mcode)
        self2:MouseCapture(true)
        self2:OnCursorMoved(self2:CursorPos())
        self2:SetCursor("blank")
    end

    alphapanel.OnMouseReleased = function(self2, mcode)
        self2:MouseCapture(false)
        self2:OnCursorMoved(self2:CursorPos())
        self2:SetCursor("none")
    end

    alphapanel.Paint = function(self2, w, h)
        surface.SetDrawColor(self.ResultColor, 255)
        surface.SetMaterial(self.MatCubeR)
        surface.DrawTexturedRect(0, 0, w, h)
        surface.SetDrawColor(255, 255, 255, 255)
        surface.DrawRect(self2.LastX - ARC9ScreenScale(0.5), -ARC9ScreenScale(1), ARC9ScreenScale(1), h + ARC9ScreenScale(2))
    end
end

vgui.Register("ARC9ColorPanel", ARC9ColorPanel, "DFrame")
local ARC9ColorButton = {}
ARC9ColorButton.Color = ARC9.GetHUDColor("fg")
ARC9ColorButton.ColorClicked = ARC9.GetHUDColor("hi")
ARC9ColorButton.MatIdle = Material("arc9/ui/button_color.png", "mips")
ARC9ColorButton.MatSel = Material("arc9/ui/button_sel.png", "mips")
ARC9ColorButton.MatIcon = Material("arc9/ui/paint.png", "mips smooth")

function ARC9ColorButton:Init()
    self:SetSize(ARC9ScreenScale(84), ARC9ScreenScale(13))
    self:SetText("")
end

function ARC9ColorButton:DoClick()
    local bg = vgui.Create("DFrame")
    bg:SetPos(0, 0)
    bg:SetSize(ScrW(), ScrH())
    bg:SetTitle("")
    bg:SetDraggable(false)
    bg:ShowCloseButton(false)
    bg:SetBackgroundBlur(true)
    bg:MakePopup()
    bg.ParentButton = self
    local newel = vgui.Create("ARC9ColorPanel", bg)

    if self.AlphaEnabled then
        newel:EnableAlpha()
    end

    newel:SetPos(self:LocalToScreen(self:GetX() - ARC9ScreenScale(103), self:GetY() - ARC9ScreenScale(48)))
    newel:UpdateColor(self.rgbcolor)
    newel:ShowCloseButton(false)

    bg.Paint = function(self2, w, h)
        surface.SetDrawColor(0, 0, 0, 0)
        surface.DrawRect(0, 0, w, h)

        if not IsValid(self2.ParentButton) then
            bg:Remove()
            newel:Remove()
        end
    end

    bg.OnMousePressed = function(self2, keycode)
        if newel.Alpha then
            newel.ResultColor.a = newel.Alpha
        end

        if LocalPlayer():IsAdmin() and ARC9.ShouldNetworkConVar(LocalPlayer(), self.m_strConVar) then
            timer.Create("cvarsend_" .. self.Convar, 0.5, 1, function()
                ARC9.NetworkConVar(self.Convar .. "_r", tostring(self.rgbcolor.r))
                ARC9.NetworkConVar(self.Convar .. "_g", tostring(self.rgbcolor.g))
                ARC9.NetworkConVar(self.Convar .. "_b", tostring(self.rgbcolor.b))
                if newel.Alpha then
                    ARC9.NetworkConVar(self.Convar .. "_a", tostring(self.rgbcolor.a))
                end
            end)
        else
            self.rgbcolor = newel.ResultColor
            RunConsoleCommand(self.Convar .. "_r", self.rgbcolor.r)
            RunConsoleCommand(self.Convar .. "_g", self.rgbcolor.g)
            RunConsoleCommand(self.Convar .. "_b", self.rgbcolor.b)

            if newel.Alpha then
                RunConsoleCommand(self.Convar .. "_a", self.rgbcolor.a)
            end
        end

        -- self:ApplyConvar or something idk ()
        newel:Remove()
        bg:Remove()
    end
end

function ARC9ColorButton:EnableAlpha()
    self.AlphaEnabled = true
end

function ARC9ColorButton:CustomSetConvar(cvar)
    self.Convar = cvar
end

function ARC9ColorButton:Paint(w, h)
    local color = self.Color
    local color2 = ARC9.GetHUDColor("hi")
    local color3 = self.rgbcolor or self.Color

    if self:IsDown() then
        color = color2
    end

    surface.SetDrawColor(color3)
    surface.SetMaterial(self.MatIdle)
    surface.DrawTexturedRect(0, 0, w, h)
    surface.SetDrawColor(color)
    surface.SetMaterial(self.MatIcon)
    surface.DrawTexturedRect(w / 2 - h * 0.35, h / 2 - h * 0.35, h * 0.7, h * 0.7)

    if self:IsHovered() then
        surface.SetDrawColor(color2)
    end

    surface.SetMaterial(self.MatSel)
    surface.DrawTexturedRect(0, 0, w, h)
end

vgui.Register("ARC9ColorButton", ARC9ColorButton, "DButton")
--PATH lua/arc9/client/cl_warnings.lua:
return gluapack()()
--PATH addons/[misc] szachy/lua/chess/sh_player_ext.lua:

local PLAYER = FindMetaTable( "Player" )
if not PLAYER then return end

function PLAYER:GetChessElo()
	return self:GetNWInt( "ChessElo", 1400 ) or 1400
end
function PLAYER:GetDraughtsElo()
	return self:GetNWInt( "DraughtsElo", 1400 ) or 1400
end
if CLIENT then return end
function PLAYER:SetChessElo( num )
	self:SetNWInt( "ChessElo", num or Chess_GetElo(ply:SteamID()) or 1400 )
	Chess_SetElo( self:SteamID(), num, false )
end
function PLAYER:SetDraughtsElo( num )
	self:SetNWInt( "DraughtsElo", num or Chess_GetElo(ply:SteamID(), true) or 1400 )
	Chess_SetElo( self:SteamID(), num, true )
end

function PLAYER:RefreshChessElo()
	-- Convert old PData stuff
	if self:GetPData("ChessElo") then
		Chess_SetElo( self:SteamID(), self:GetPData("ChessElo"), false )
		self:RemovePData("ChessElo")
	end
	if self:GetPData("DraughtsElo") then
		Chess_SetElo( self:SteamID(), self:GetPData("DraughtsElo"), true )
		self:RemovePData("DraughtsElo")
	end
	
	self:SetChessElo( Chess_GetElo(self:SteamID()) or 1400)
	self:SetDraughtsElo( Chess_GetElo(self:SteamID(), true) or 1400)
end
hook.Add( "PlayerInitialSpawn", "Chess InitialSpawn InitElo", function(ply)
	ply:RefreshChessElo()
end)

function PLAYER:ExpectedChessWin( against )
	return (1/ (1+( 10^( (against:GetChessElo() - self:GetChessElo())/400 ) )) )
end
function PLAYER:ExpectedDraughtsWin( against )
	return (1/ (1+( 10^( (against:GetDraughtsElo() - self:GetDraughtsElo())/400 ) )) )
end

function PLAYER:GetChessKFactor() --Imitating FIDE's K-factor ranges
	local games = tonumber(self:GetPData( "ChessGamesPlayed", 0 )) or 0
	if games<30 then
		self:SetPData( "ChessEloKFactor", 15 )
		return 30
	end
	local k = self:GetChessElo()>=2400 and 10 or self:GetPData( "ChessEloKFactor", 15 ) or 15
	self:SetPData( "ChessEloKFactor", k )
	return k
end
function PLAYER:GetDraughtsKFactor() --Imitating FIDE's K-factor ranges
	local games = self:GetPData( "DraughtsGamesPlayed", 0 )
	if games<30 then
		self:SetPData( "DraughtsEloKFactor", 15 )
		return 30
	end
	local k = self:GetDraughtsElo()>=2400 and 10 or self:GetPData( "DraughtsEloKFactor", 15 ) or 15
	self:SetPData( "DraughtsEloKFactor", k )
	return k
end

function PLAYER:DoChessElo( score, against )
	local mod = math.ceil(self:GetChessKFactor() * (score - self:ExpectedChessWin(against)))
	local NewElo = math.floor( self:GetChessElo() + mod )
	
	self:SetChessElo( NewElo )
	
	if IsValid(against) then
		mod = mod*(-1)
		local NewElo = math.floor( against:GetChessElo() + mod )
		
		against:SetChessElo( NewElo )
		local rank,count = Chess_GetRank(against)
		against:ChatPrint( "Your chess Elo rating changed by "..tostring(mod).." to "..tostring(NewElo).."!" ..(rank and " You are #"..tostring(rank).." on this server." or "")  )
	end
	local rank,count = Chess_GetRank(self)
	self:ChatPrint( "Your chess Elo rating changed by "..tostring(mod).." to "..tostring(NewElo).."!" ..(rank and " You are #"..tostring(rank).." on this server." or "") )
	
	Chess_UpdateElo( self )
end
function PLAYER:ChessWin( against )
	if not IsValid(against) then return end
	
	self:DoChessElo(1, against)
end
function PLAYER:ChessDraw( against ) self:DoChessElo(0.5, against) end

function PLAYER:DoDraughtsElo( score, against )
	local mod = math.ceil(self:GetDraughtsKFactor() * (score - self:ExpectedDraughtsWin(against)))
	local NewElo = math.floor( self:GetDraughtsElo() + mod )
	
	self:SetDraughtsElo( NewElo )
	
	if IsValid(against) then
		mod = mod*(-1)
		local NewElo = math.floor( against:GetDraughtsElo() + mod )
		
		against:SetDraughtsElo( NewElo )
		local rank = Chess_GetRank(self, "Draughts")
		against:ChatPrint( "Your draughts Elo rating changed by "..tostring(mod).." to "..tostring(NewElo).."!" ..(rank and " You are #"..tostring(rank).." on this server." or "") )
	end
	local rank = Chess_GetRank(self, "Draughts")
	self:ChatPrint( "Your draughts Elo rating changed by "..tostring(mod).." to "..tostring(NewElo).."!" ..(rank and " You are #"..tostring(rank).." on this server." or "") )
	
	Chess_UpdateElo( self )
end
function PLAYER:DraughtsWin( against ) self:DoDraughtsElo(1, against) end
function PLAYER:DraughtsDraw( against ) self:DoDraughtsElo(0.5, against) end

--PATH addons/[misc] szachy/lua/chess/cl_top.lua:
return gluapack()()
--PATH addons/[miecze] mexicano_drzewko/lua/autorun/sh_config.lua:
return gluapack()()
--PATH lua/pixelui/elements/cl_category.lua:
return gluapack()()
--PATH lua/pixelui/elements/cl_category.lua:
--[[
	PIXEL UI - Copyright Notice
	 2023 Thomas O'Sullivan - All rights reserved

	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program.  If not, see <https://www.gnu.org/licenses/>.
--]]

local PANEL = {}

AccessorFunc(PANEL, "Title", "Title", FORCE_STRING)

PIXEL.RegisterFont("UI.CategoryHeader", "Open Sans Bold", 19)

function PANEL:Init()
    self.ArrowRotation = 0

    self.BackgroundCol = PIXEL.OffsetColor(PIXEL.Colors.Background, 6)
end

function PANEL:DoClick()
    self:GetParent():Toggle()
end

local lerp = Lerp
function PANEL:Paint(w, h)
    PIXEL.DrawRoundedBox(PIXEL.Scale(4), 0, 0, w, h, self.BackgroundCol)
    PIXEL.DrawSimpleText(self.Title, "UI.CategoryHeader", PIXEL.Scale(10), h / 2, PIXEL.Colors.PrimaryText, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)

    self.ArrowRotation = lerp(FrameTime() * 10, self.ArrowRotation, self:GetParent():GetExpanded() and 0 or 90)

    local arrowSize = h * .45
    PIXEL.DrawImageRotated(w - h * .3 - PIXEL.Scale(4), h / 2, arrowSize, arrowSize, self.ArrowRotation, "https://pixel-cdn.lythium.dev/i/5r7ovslav", PIXEL.Colors.PrimaryText)
end

vgui.Register("PIXEL.CategoryHeader", PANEL, "PIXEL.Button")

PANEL = {}

AccessorFunc(PANEL, "m_bSizeExpanded", "Expanded", FORCE_BOOL)
AccessorFunc(PANEL, "m_iContentHeight", "StartHeight")
AccessorFunc(PANEL, "m_fAnimTime", "AnimTime")
AccessorFunc(PANEL, "m_bDrawBackground", "PaintBackground", FORCE_BOOL)
AccessorFunc(PANEL, "m_iPadding", "Padding")
AccessorFunc(PANEL, "m_pList", "List")

function PANEL:Init()
    self.Header = vgui.Create("PIXEL.CategoryHeader", self)

    self:SetTitle("PIXEL Category")

    self:SetExpanded(true)
    self:SetMouseInputEnabled(true)

    self:SetAnimTime(0.2)
    self.SlideAnimation = Derma_Anim("Anim", self, self.AnimSlide)

    self.BackgroundCol = PIXEL.OffsetColor(PIXEL.Colors.Background, 2)

    self:InvalidateLayout(true)
end

function PANEL:UnselectAll()
    local children = self:GetChildren()
    for k, v in pairs(children) do
        if v.SetSelected then
            v:SetSelected(false)
        end
    end
end

function PANEL:Think()
    self.SlideAnimation:Run()
end

function PANEL:SetTitle(title)
    self.Header:SetTitle(title)
end

function PANEL:Paint(w, h)
    PIXEL.DrawRoundedBox(PIXEL.Scale(4), 0, 0, w, h, self.BackgroundCol)
end

function PANEL:SetContents(contents)
    self.Contents = contents
    self.Contents:SetParent(self)
    self.Contents:Dock(FILL)

    local margin = PIXEL.Scale(8)
    self.Contents:DockMargin(margin, margin, margin, margin)

    if not self:GetExpanded() then
        self.OldHeight = self:GetTall()
    elseif self:GetExpanded() and IsValid(self.Contents) and self.Contents:GetTall() < 1 then
        self.Contents:SizeToChildren(false, true)
        self.OldHeight = self.Contents:GetTall()
        self:SetTall(self.OldHeight)
    end

    self:InvalidateLayout(true)
end

function PANEL:SetExpanded(expanded)
    self.m_bSizeExpanded = tobool(expanded)

    if not self:GetExpanded() then
        if not self.SlideAnimation.Finished and self.OldHeight then return end
        self.OldHeight = self:GetTall()
    end
end

function PANEL:Toggle()
    self:SetExpanded(not self:GetExpanded())

    self.SlideAnimation:Start(self:GetAnimTime(), {From = self:GetTall()})

    self:InvalidateLayout(true)

    self:OnToggle(self:GetExpanded())
end

function PANEL:OnToggle(expanded) end

function PANEL:DoExpansion(b)
    if self:GetExpanded() == b then return end
    self:Toggle()
end

function PANEL:LayoutContent(w, h) end

function PANEL:PerformLayout(w, h)
    self.Header:Dock(TOP)
    self.Header:SetTall(PIXEL.Scale(26))

    if IsValid(self.Contents) then
        if self:GetExpanded() then
            self.Contents:InvalidateLayout(true)
            self.Contents:SetVisible(true)
        else
            self.Contents:SetVisible(false)
        end
    end

    if self:GetExpanded() then
        if IsValid(self.Contents) and #self.Contents:GetChildren() > 0 then self.Contents:SizeToChildren(false, true) end
        self:SizeToChildren(false, true)
    else
        if IsValid(self.Contents) and not self.OldHeight then self.OldHeight = self.Contents:GetTall() end
        self:SetTall(self.Header:GetTall())
    end

    self.SlideAnimation:Run()

    self:LayoutContent(w, h)
end

function PANEL:OnMousePressed(mcode)
    if not self:GetParent().OnMousePressed then return end
    return self:GetParent():OnMousePressed(mcode)
end

function PANEL:AnimSlide(anim, delta, data)
    self:InvalidateLayout()
    self:InvalidateParent()

    if anim.Started then
        if not IsValid(self.Contents) and (self.OldHeight or 0) < self.Header:GetTall() then
            self.OldHeight = 0
            for id, pnl in pairs(self:GetChildren()) do
                self.OldHeight = self.OldHeight + pnl:GetTall()
            end
        end

        if self:GetExpanded() then
            data.To = math.max(self.OldHeight, self:GetTall())
        else
            data.To = self:GetTall()
        end
    end

    if IsValid(self.Contents) then self.Contents:SetVisible(true) end

    self:GetParent():InvalidateLayout()
    self:GetParent():GetParent():InvalidateLayout()

    self:SetTall(Lerp(delta, data.From, data.To))
end

vgui.Register("PIXEL.Category", PANEL, "Panel")

--PATH lua/pixelui/elements/cl_color_picker.lua:
return gluapack()()
--PATH lua/pixelui/elements/cl_labelled_checkbox.lua:
--[[
	PIXEL UI - Copyright Notice
	 2023 Thomas O'Sullivan - All rights reserved

	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program.  If not, see <https://www.gnu.org/licenses/>.
--]]

local PANEL = {}

function PANEL:Init()
    self.Checkbox = vgui.Create("PIXEL.Checkbox", self)

    self.Checkbox.OnToggled = function(s, enabled)
        self:OnToggled(enabled)
    end

    self.LabelHolder = vgui.Create("Panel", self)
    self.Label = vgui.Create("PIXEL.Label", self.LabelHolder)
    self.Label:SetAutoWidth(true)
    self.Label:SetAutoHeight(true)

    self.LabelHolder.PerformLayout = function(s, w, h)
        self.Label:CenterVertical()
        s:SizeToChildren(true, true)
        self:SizeToChildren(true, true)
    end
end

function PANEL:PerformLayout(w, h)
    self.Checkbox:Dock(LEFT)
    self.Checkbox:SetWide(h)
    self.Checkbox:DockMargin(0, 0, PIXEL.Scale(6), 0)

    self.LabelHolder:Dock(LEFT)
end

function PANEL:OnToggled(enabled) end

function PANEL:SetText(text) self.Label:SetText(text) end
function PANEL:GetText() return self.Label:GetText() end

function PANEL:SetFont(font) self.Label:SetFont(font) end
function PANEL:GetFont() return self.Label:GetFont() end

function PANEL:SetTextColor(col) self.Label:SetTextColor(col) end
function PANEL:GetTextColor() return self.Label:GetTextColor() end

function PANEL:SetAutoWrap(enabled) self.Label:SetAutoWrap(enabled) end
function PANEL:GetAutoWrap() return self.Label:GetAutoWrap() end

vgui.Register("PIXEL.LabelledCheckbox", PANEL, "Panel")
--PATH lua/pixelui/elements/cl_scrollpanel.lua:
return gluapack()()
--PATH lua/pixelui/menus/cl_message_popup.lua:
--[[
	PIXEL UI - Copyright Notice
	 2023 Thomas O'Sullivan - All rights reserved

	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program.  If not, see <https://www.gnu.org/licenses/>.
--]]

local PANEL = {}

AccessorFunc(PANEL, "Text", "Text", FORCE_STRING)
AccessorFunc(PANEL, "ButtonText", "ButtonText", FORCE_STRING)

PIXEL.RegisterFont("UI.Message", "Open Sans SemiBold", 18)

function PANEL:Init()
    self:SetDraggable(true)
    self:SetSizable(true)

    self:SetMinWidth(PIXEL.Scale(240))
    self:SetMinHeight(PIXEL.Scale(80))

    self.Message = vgui.Create("PIXEL.Label", self)
    self.Message:SetTextAlign(TEXT_ALIGN_CENTER)
    self.Message:SetFont("UI.Message")

    self.ButtonHolder = vgui.Create("Panel", self)

    self.Button = vgui.Create("PIXEL.TextButton", self.ButtonHolder)
    self.Button.DoClick = function(s, w, h)
        self:Close(true)
    end
end

function PANEL:LayoutContent(w, h)
    self.Message:SetSize(self.Message:CalculateSize())
    self.Message:Dock(TOP)
    self.Message:DockMargin(0, 0, 0, PIXEL.Scale(8))

    self.Button:SizeToText()
    self.ButtonHolder:Dock(TOP)
    self.ButtonHolder:SetTall(self.Button:GetTall())
    self.Button:CenterHorizontal()

    if self.ButtonHolder:GetWide() < self.Button:GetWide() then
        self.ButtonHolder:SetWide(self.Button:GetWide())
    end

    if self:GetWide() < PIXEL.Scale(240) then
        self:SetWide(PIXEL.Scale(240))
        self:Center()
    end

    if self.HasSized and self.HasSized > 1 then return end
    self.HasSized = (self.HasSized or 0) + 1

    self:SizeToChildren(true, true)
    self:Center()
end

function PANEL:SetText(text) self.Message:SetText(text) end
function PANEL:GetText(text) return self.Message:GetText() end

function PANEL:SetButtonText(text) self.Button:SetText(text) end
function PANEL:GetButtonText(text) return self.Button:GetText() end

vgui.Register("PIXEL.Message", PANEL, "PIXEL.Frame")

PIXEL.UI.Overrides.Derma_Message = PIXEL.UI.Overrides.Derma_Message or Derma_Message

Derma_Message = PIXEL.UI.CreateToggleableOverride(PIXEL.UI.Overrides.Derma_Message, function(text, title, buttonText)
    buttonText = buttonText or "OK"

    local msg = vgui.Create("PIXEL.Message")
    msg:SetTitle(title)
    msg:SetText(text)
    msg:SetButtonText(buttonText)

    msg:MakePopup()
    msg:DoModal()

    return msg
end, PIXEL.UI.ShouldOverrideDermaPopups)
--PATH lua/pixelui/menus/cl_string_request_popup.lua:
return gluapack()()
--PATH lua/autorun/sh_unitys_smokescreens.lua:
return gluapack()()
--PATH lua/autorun/slaver_npc.lua:
return gluapack()()
--PATH lua/autorun/slaver_npc.lua:
local NPC = {
	Name = "zygerrian Guard (Friendly)",
	Class = "npc_citizen",
	Category = "CGI Zygerrian Slavers",
	Model = "models/npc/zygerrian/npc_zygerrian_guard_f.mdl",
	KeyValues = { citizentype = CT_UNIQUE }
}
list.Set( "NPC", "npc_zygerrian_guard_f", NPC )


local NPC = {
	Name = "zygerrian Guard (Hostile)",
	Class = "npc_combine_s",
	Category = "CGI Zygerrian Slavers",
	Model = "models/npc/zygerrian/npc_zygerrian_guard_h.mdl",
}
list.Set( "NPC", "npc_zygerrian_guard_h", NPC )




--PATH lua/slib/sh_util.lua:
return gluapack()()
--PATH lua/slib/sh_util.lua:
slib = slib or {}
slib.panels = slib.panels or {}
slib.cachedAvatars = slib.cachedAvatars or {}
slib.generalCooldowns = slib.generalCooldowns or {}

slib.config = {scale = {x = 1, y = 1}}

slib.getStatement = function(val)
    if isbool(val) then return "bool" end
    if isnumber(val) then return "int" end
    if istable(val) and val.r and val.g and val.b then return "color" end
    if istable(val) then return "table" end
    if isfunction(val) then return "function" end
    if isstring(val) then return "string" end

    return "bool"
end

local callNum = 1
local loadedCalls = {}

local function loadFile(folder, file)
    if string.StartWith(file, "sv_") or string.find(folder, "server") then
        if SERVER then
            include(folder .. file)
            loaded = true
        end
    elseif string.StartWith(file, "sh_") or string.find(folder, "shared") then
        AddCSLuaFile(folder .. file)
        include(folder .. file)
        loaded = true
    elseif string.StartWith(file, "cl_") or string.find(folder, "client") then
        AddCSLuaFile(folder .. file)
        if CLIENT then include(folder .. file) loaded = true end
    end

    if loaded then
        print("[slib] Loaded "..folder..file)

        return folder..file
    end
end

slib.loadFolder = function(folder, subdirectories, firstload, lastload, call)
    local files, directories = file.Find(folder .. "*", "LUA")
    loadedCalls[callNum] = loadedCalls[callNum] or {}

    if firstload then
        for k,v in pairs(firstload) do
            local result = loadFile(v[1], v[2])
            if !result then continue end
            loadedCalls[callNum][result] = true
        end
    end

    if lastload then
        for k,v in pairs(lastload) do
            loadedCalls[callNum][v[1]..v[2]] = true
        end
    end

    for k, v in pairs(files) do
        if loadedCalls[callNum][folder..v] then continue end
        loadFile(folder, v)
    end

    if subdirectories then
        for k,v in pairs(directories) do
            slib.loadFolder(folder..v.."/", true, nil, nil, call and call or callNum)
        end
    end

    if lastload then
        for k,v in pairs(lastload) do
            loadFile(v[1], v[2])
        end
    end

    if call then return end
    callNum = callNum + 1
end

slib.getCooldown = function(var)
    if !slib.generalCooldowns[var] then return true end
    
    return slib.generalCooldowns[var] and CurTime() >= slib.generalCooldowns[var]
end

slib.getTimeLeft = function(var)
    return slib.generalCooldowns[var] and slib.generalCooldowns[var] - CurTime() or 0
end

slib.setCooldown = function(var, cd)
    slib.generalCooldowns[var] = CurTime() + cd
end

slib.oldFunctions = {}

slib.wrapFunction = function(element, funcname, pre, post, returnresult)
    if !slib.oldFunctions[funcname.."Old"] then
        slib.oldFunctions[funcname.."Old"] = element[funcname]
    end

    element[funcname] = function(...)
        local result 
        
        if pre then
            local callback = pre(...)
            result = returnresult and callback or result
        end

        if isfunction(slib.oldFunctions[funcname.."Old"]) then
            result = slib.oldFunctions[funcname.."Old"](...) or result
        end 

        if post then
            local callback = post(...)
            result = returnresult and callback or result
        end

        return result
    end
end

slib.lang = slib.lang or {}

slib.setLang = function(addon, lang, id, str)
    slib.lang[addon] = slib.lang[addon] or {}
    slib.lang[addon][lang] = slib.lang[addon][lang] or {}

    slib.lang[addon][lang][id] = str
end

slib.getLang = function(addon, lang, id, ...)
    local args = {...}
    local unformatted = slib.lang[addon] and slib.lang[addon][lang] and slib.lang[addon][lang][id]

    if !unformatted then unformatted = slib.lang[addon] and slib.lang[addon]["en"] and slib.lang[addon]["en"][id] or id end

    return table.IsEmpty(args) and unformatted or string.format(unformatted, ...)
end

slib.notify = function(str, ply)
    str = tostring(str)
    if SERVER then
        net.Start("slib.msg")
        net.WriteString(str)
        net.Send(ply)
    elseif CLIENT then
        print(str)
        notification.AddLegacy(str, 0, 5)
    end
end

local function differenciate(a, b)
    if !(isstring(a) == isstring(b)) or isbool(a) or isbool(b) then
        return tostring(a), tostring(b)
    end

    return a, b
end

slib.sortAlphabeticallyByKeyValues = function(tbl, ascending)
    local normaltable = {}
    local cleantable = {}
    
    for k,v in pairs(tbl) do
        table.insert(normaltable, k)
    end

    if ascending then
        table.sort(normaltable, function(a, b) a, b = differenciate(a, b) return a < b end)
    else
        table.sort(normaltable, function(a, b) a, b = differenciate(a, b) return a > b end)
    end

    for k,v in pairs(normaltable) do
        cleantable[v] = k
    end

    return cleantable
end

slib.sortAlphabeticallyByValue = function(tbl, ascending, keyvalue)
    if keyvalue then
        tbl = table.Copy(tbl)
    end

    if ascending then
        table.sort(tbl, function(a, b) a, b = differenciate(a, b) return a < b end)
    else
        table.sort(tbl, function(a, b) a, b = differenciate(a, b) return a > b end)
    end

    local cleantable = {}

    for k, v in pairs(tbl) do
        cleantable[v] = k
    end

    return keyvalue and cleantable or tbl
end

slib.sid64ToPly = slib.sid64ToPly or {}

if SERVER then
    slib.playerCache = slib.playerCache or player.GetAll()

    util.AddNetworkString("slib.msg")

    local punished = {}
    slib.punish = function(ply, type, msg, duration)
        local sid = ply:SteamID()

        if punished[sid] then return end
        punished[sid] = true

        if type == 1 then
            ply:Kick(msg)
        elseif type == 2 then
            if duration == nil then duration = 0 end
            if sAdmin then
                RunConsoleCommand("sa","banid", ply:SteamID64(), duration, msg)
            elseif ULib then
                ULib.ban(ply, duration, msg)
            elseif sam then
                RunConsoleCommand("sam","banid", sid, duration, msg)
            elseif xAdmin then
                if xAdmin.Config then
                    if xAdmin.Config.MajorVersion == 1 then
                        RunConsoleCommand("xadmin_ban", sid, duration, msg)
                    else
                        RunConsoleCommand("xadmin","ban", sid, duration, msg)
                    end
                end
            elseif SERVERGUARD then
                RunConsoleCommand("serverguard","ban", sid, duration, msg)
            else
                ply:Ban(duration, true)
            end
        end
    end

    slib.isBanned = function(sid64, callback)
        local sid32 = util.SteamIDFrom64(sid64)

        if sAdmin and sAdmin.isBanned then
            return sAdmin.isBanned(sid64)
        elseif sam and sam.player and sam.player.is_banned then
            return sam.player.is_banned(sid32, callback)
        elseif ulx and ULib and ULib.bans then
            return tobool(ULib.bans[sid32])
        elseif xAdmin and xAdmin.Admin and xAdmin.Admin.Bans then
            local data = xAdmin.Admin.Bans[sid64]
            local endtime = data.StartTime + (data.Length * 60)

            return data and (tonumber(endtime) <= os.time()) or false
        end
    end

    slib.setRank = function(ply, rank)
        local sid64 = ply:SteamID64()

        if sAdmin then
            RunConsoleCommand("sa", "setrankid", sid64, rank)
        elseif sam then
            RunConsoleCommand("sam", "setrankid", sid64, rank)
        elseif ulx then
            RunConsoleCommand("ulx", "adduserid", ply:SteamID(), rank)
        elseif xAdmin then
            RunConsoleCommand("xadmin", "setgroup", ply:Nick(), rank) -- yes
        end
    end

    hook.Add("PlayerInitialSpawn", "slib.reconnected", function(ply)
        local sid = ply:SteamID()
        if punished[sid] then
            punished[sid] = nil
        end
    end)

    hook.Add("PlayerInitialSpawn", "slib.FullLoaded", function( ply )
        table.insert(slib.playerCache, ply)
        local sid64 = ply:SteamID64()
        slib.sid64ToPly[sid64] = ply

        local id = sid64.."_slib"
        hook.Add( "SetupMove", id, function( self, mv, cmd )
            if self == ply and not cmd:IsForced() then
                hook.Run("slib.FullLoaded", ply)
                hook.Remove("SetupMove", id)
            end
        end )
    end)

    hook.Add("PlayerDisconnected", "slib.handleDisconnect", function(ply)
        table.RemoveByValue(slib.playerCache, ply)
    end)
end

if CLIENT then
    local blur = Material("pp/blurscreen")

    slib.DrawBlur = function(panel, amount)
        local x, y = panel:LocalToScreen(0, 0)
        local scrW, scrH = ScrW(), ScrH()
        surface.SetDrawColor(255, 255, 255)
        surface.SetMaterial(blur)
        for i = 1, 3 do
            blur:SetFloat("$blur", (i / 3) * (amount or 6))
            blur:Recompute()
            render.UpdateScreenEffectTexture()
            surface.DrawTexturedRect(x * -1, y * -1, scrW, scrH)
        end
    end

    slib.getScaledSize = function(num, axis, scale)
        scale = scale or {x = 1, y = 1}

        if axis == "x" then
            num = ScrW() * (num/1920)

            num = num * scale.x
        end
    
        if axis == "y" or axis == nil then
            num = ScrH() * (num/1080)

            num = num * scale.y
        end
        
        return math.Round(num)
    end

    slib.cachedFonts = slib.cachedFonts or {}

    slib.createFont = function(fontname, size, thickness, ignorescale)
        size = size or 13
        thickness = thickness or 500
        local identifier = string.gsub(fontname, " ", "_")

        if !fontname or !size or !thickness then return end

        local name = "slib."..identifier..size.."."..thickness
        
        if ignorescale then name = "real_"..name end
        
        if slib.cachedFonts[name] then return name end

        surface.CreateFont( name, {
            font = fontname,
            size = ignorescale and size or slib.getScaledSize(size, "y"),
            weight = thickness,
        })

        slib.cachedFonts[name] = true

        return name
    end

    slib.colorCached = {}

    slib.lerpColor = function(identifier, wantedcolor, multiplier, nolerp)
        wantedcolor = table.Copy(wantedcolor)
        slib.colorCached[identifier] = slib.colorCached[identifier] or wantedcolor
        multiplier = multiplier or 1
        local basespeed = (RealFrameTime() * 3)
        local speed = basespeed * multiplier

        if minspeed then speed = minspeed > speed and minspeed or speed end
        
        for k,v in pairs(slib.colorCached[identifier]) do
            local percentageleft = math.abs(wantedcolor[k] - v)

            slib.colorCached[identifier][k] = math.Approach(v, wantedcolor[k], speed * (nolerp and 100 or percentageleft))
        end

        return slib.colorCached[identifier]
    end

    slib.numCached = {}
    slib.lerpNum = function(identifier, wantednum, multiplier, nolerp)
        slib.numCached[identifier] = slib.numCached[identifier] or wantednum
        multiplier = multiplier or 1
        local basespeed = (RealFrameTime() * 3)
        local speed = basespeed * multiplier

        local percentageleft = math.abs(wantednum - slib.numCached[identifier])

        slib.numCached[identifier] = math.Approach(slib.numCached[identifier], wantednum, speed * (nolerp and 100 or percentageleft))

        return math.Round(slib.numCached[identifier])
    end

    slib.drawTooltip = function(str, parent, align)
        local font = slib.createFont("Roboto", 13)
        local cursortposx, cursortposy = input.GetCursorPos()
        cursortposx = cursortposx + 15
        local x, y = cursortposx, cursortposy
       
        surface.SetFont(font)
        local strw, strh = surface.GetTextSize(str)
       
        local w = strw + slib.getScaledSize(6, "x")

        if align == 1 then
            local parentparent = parent:GetParent()
            if !IsValid(parentparent) then return end
            local posx, posy = parent:GetPos()
            x, y = parentparent:LocalToScreen(posx, posy)
            y = y + parent:GetTall()

            x = x + parent:GetWide() * .5

            x = x - w * .5
        end

        local tooltip = vgui.Create("EditablePanel")
        tooltip:SetMouseInputEnabled(false)
        tooltip:SetPos(x, y)
        tooltip:SetSize(w, slib.getScaledSize(22, "y"))
        tooltip:MakePopup()
    
        tooltip.Paint = function(s,w,h)
            if !parent:IsHovered() and !s:IsHovered() or !s:HasFocus() and !parent.clickable then s:Remove() end
    
            surface.SetDrawColor(slib.getTheme("maincolor", 10))
            surface.DrawRect(0, 0, w, h)
    
            surface.SetDrawColor(120, 120, 120, 200)
            surface.DrawOutlinedRect(0, 0, w, h)
    
            draw.SimpleText(str, font, slib.getScaledSize(3, "x"), h * .5, slib.getTheme("textcolor"), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
        end

        return tooltip
    end

    slib.createTooltip = function(str, parent)
        if !str or !parent then return end

        surface.SetFont(parent.font)
        local textw, texth = surface.GetTextSize(parent.name)


        local tooltipbutton = vgui.Create("DButton", parent)
		tooltipbutton:SetText("")
		tooltipbutton:Dock(LEFT)
		tooltipbutton:DockMargin(textw + slib.getScaledSize(6,"x"),slib.getScaledSize(5,"x"),0,slib.getScaledSize(5,"x"))
        tooltipbutton:SetWide(slib.getScaledSize(25, "y") - (slib.getScaledSize(5,"x") + slib.getScaledSize(5,"x")))
        tooltipbutton.bg = slib.getTheme("maincolor")
        
        tooltipbutton.DoClick = function()
            tooltipbutton.clicked = !tooltipbutton.clicked
        end

		tooltipbutton.Paint = function(s,w,h)
            draw.RoundedBox(h * .5, 0, 0, w, h, s.bg)

			draw.SimpleText("?", slib.createFont("Roboto", 14), w * .5, h * .5, slib.getTheme("textcolor", -50), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

            if s.clickable and !s.clicked and IsValid(s.tooltip) then
                s.tooltip:Remove()
            end

            if s:IsHovered() then
                if IsValid(s.tooltip) then return end
                s.tooltip = slib.drawTooltip(str, tooltipbutton)
            else
                s.clicked = nil
			end
        end
        
        return tooltipbutton
    end

    slib.theme = slib.theme or {}

    slib.setTheme = function(var, val)
        slib.theme[var] = val
    end

    slib.getTheme = function(var, offset)
        local val = slib.theme[var]

        if istable(val) then
            val = table.Copy(val)
            
            if offset then
                for k,v in pairs(val) do
                    val[k] = v + offset
                end

                if val.r and val.g and val.b and val.a then
                    for k,v in pairs(val) do
                        val[k] = math.Clamp(v, 0, 255)
                    end
                end
            end 
        end

        return val
    end

    slib.isValidSID64 = function(sid64)
        return util.SteamIDFrom64(sid64) != "STEAM_0:0:0"
    end

    local loading_ico = Material("slib/load.png", "smooth")

    local matCache = {}
    local fetched = {}
    
    file.CreateDir("slib")
    
    local proxy = ""--"https://proxy.duckduckgo.com/iu/?u=" -- Disabled for now, it doesn't work
    slib.ImgurGetMaterial = function(id) -- RETURN THE LOADING MATERIAL UNTIL IT IS FOUND!!!
        if !matCache[id] then
            local link = proxy.."https://i.imgur.com/"..id..".png"

            if file.Exists("slib/"..id..".png", "DATA") then
                matCache[id] = Material("data/slib/"..id..".png", "noclamp smooth")

                if matCache[id]:IsError() then
                    file.Delete("slib/"..id..".png")

                    if !fetched[link] then
                        slib.ImgurGetMaterial(id)
                    end
                end
            else
                if fetched[link] then return loading_ico, true end
                
                fetched[link] = true
                
                http.Fetch(link,
                    function(body)
                        file.Write("slib/"..id..".png", body)
                        matCache[id] = Material("data/slib/"..id..".png", "noclamp smooth")
                    end
                )
            end
        else
            return matCache[id]
        end
        
        return loading_ico, true
    end

    local cachedNames = {}
    local requestedNames = {}

    slib.findName = function(sid64, rtrn_sid64)
        if cachedNames[sid64] then return cachedNames[sid64] end

        local servercheck = player.GetBySteamID64(sid64)
        local steamcheck = false

        if servercheck then
            cachedNames[sid64] = servercheck:Nick()
        else
            if requestedNames[sid64] then return rtrn_sid64 and sid64 end
            requestedNames[sid64] = true
            local start = "<title>Steam Community :: "
            local theEnd = '<link rel="shortcut icon" href="/favicon.ico" type="image/'

            http.Fetch("http://steamcommunity.com/profiles/"..sid64,
                function(data)
                    local nameStart = select(1, string.find(data, start))
                    local nameEnd = select(1, string.find(data, theEnd))

                    if !nameStart or !nameEnd then return end

                    nameStart = nameStart + #start
                    nameEnd = nameEnd - 12

                    local nick = string.sub(data, nameStart, nameEnd)

                    cachedNames[sid64] = nick
                end
            )

            if !rtrn_sid64 then
                cachedNames[sid64] = "N/A"
            end
        end

        return rtrn_sid64 and sid64 or cachedNames[sid64]
    end

    local function saveImageFromURL(url, path, cb)
        http.Fetch(url, function(data)
            file.Write(path, data)

            if cb then
                cb()
            end
        end)
    end

    local fetchingAvatar = {}
    local default_ico = Material("slib/default_steam.png", "smooth")

    slib.findAvatar = function(sid64, medium)
        if !sid64 then return end
        
        local path = "slib/avatars/"..sid64..(medium and "_medium" or "_full")..".jpg"
        local size = medium and "medium" or "full"

        slib.cachedAvatars[size] = slib.cachedAvatars[size] or {}

        if !slib.cachedAvatars[size][sid64] or slib.cachedAvatars[size][sid64]:IsError() then
            if file.Exists(path, "DATA") then
                slib.cachedAvatars[size][sid64] = Material("data/"..path, "smooth noclamp")

                return slib.cachedAvatars[size][sid64]
            end

            local start = "https://avatars.cloudflare.steamstatic.com/"
            local theEnd = '">'

            if !fetchingAvatar[sid64] then
                http.Fetch( "http://steamcommunity.com/profiles/"..sid64,
                    function(data)
                        local avatarStart = select(1, string.find(data, start))
                        
                        if !avatarStart then return end

                        local avatarEnd = avatarStart + select(1, string.find(string.sub(data, avatarStart, #data), theEnd))

                        if !avatarEnd then return end

                        local imgLink = string.sub(data, avatarStart, avatarEnd - 2)

                        if medium then
                            imgLink = string.Replace(imgLink, "_full", "_medium")
                        end

                        saveImageFromURL(imgLink, path, function()
                            file.CreateDir("slib/avatars/")
                            slib.cachedAvatars[size][sid64] = Material("data/"..path, "smooth noclamp")
                        end)

                        cachedNames[sid64] = nick
                    end
                )

                fetchingAvatar[sid64] = true
            end

            return default_ico
        end

        return slib.cachedAvatars[size][sid64]
    end

    local storedImages = file.Find("slib/avatars/*.jpg", "DATA")

    for k,v in ipairs(storedImages) do
        if os.time() - file.Time("slib/avatars/"..v, "DATA") >= 259200 then
            file.Delete("slib/avatars/"..v)
        end
    end

    hook.Add("OnEntityCreated", "slib.CacheSid64ToPly", function(ent)
        if ent:IsPlayer() and !ent:IsBot() then
            local sid64 = ent:SteamID64()
            
            if !sid64 then return end

            slib.sid64ToPly[sid64] = ent
        end
    end)

    net.Receive("slib.msg", function(_, ply)
        slib.notify(net.ReadString())
    end)
end

hook.Run("slib:loadBase")
hook.Run("slib:loadedUtils")
--PATH lua/slib/vgui/cl_scollapsiblepanel.lua:
local PANEL = {}

local font, font_smaller = slib.createFont("Roboto", 16), slib.createFont("Roboto", 14)
local textcolor, textcolor_min55, shade_5, shade_10 = slib.getTheme("textcolor"), slib.getTheme("textcolor", -55), slib.getTheme("maincolor", 5), slib.getTheme("maincolor", 10)
local margin = slib.getTheme("margin")

function PANEL:Init()
    self.collapsed = true
    self.defaultH = slib.getScaledSize(24, "y")
    self.halfTall = slib.getScaledSize(8, "y")
    self:SetTall(self.defaultH)
    self:SetText("")

    self.button = vgui.Create("SButton", self)
    :SetTall(self.defaultH)
    :Dock(TOP)

    self.button.Paint = function(s,w,h)
        surface.SetDrawColor(shade_5)
        surface.DrawRect(0,h - 2,w,2)
    end

    self.button.DoClick = function()
        self.collapsed = !self.collapsed

        if self.onClicked then if self.onClicked() == true then return end end
        self:SizeTo(-1, self:getChildsHeight(), .3)
    end

    slib.wrapFunction(self, "Dock", nil, function() return self end, true)
    slib.wrapFunction(self, "DockMargin", nil, function() return self end, true)
    slib.wrapFunction(self, "SetZPos", nil, function() return self end, true)
    slib.wrapFunction(self, "SetTall", nil, function() return self end, true)
    slib.wrapFunction(self, "SetWide", nil, function() return self end, true)
    slib.wrapFunction(self, "SetPos", nil, function() return self end, true)
end

function PANEL:getChildCount()
    local count = 0

    for k,v in ipairs(self:GetChildren()) do
        if v:IsVisible() and v != self.button then
            count = count + 1
        end
    end

    return count
end

function PANEL:getChildsHeight()
    local height = self.defaultH

    if self.collapsed then
        for k,v in ipairs(self:GetChildren()) do
            if v == self.button or !v:IsVisible() then continue end
            local l, t, r, b = v:GetDockMargin()
            height = height + v:GetTall() + b + t
        end
    end

    return height + ((self.collapsed and height > self.defaultH) and margin or 0)
end

function PANEL:setTitle(str)
    self.title = str

    return self
end

function PANEL:ForceSize(add_tall)
    self:SizeTo(-1, self:getChildsHeight() + (add_tall or 0), .3)
end

function PANEL:forceCollapse()
    self:InvalidateChildren()
    self:SetTall(select(2, self:ChildrenSize()) + margin)

    return self
end

function PANEL:Paint(w, h)
    surface.SetDrawColor(self.bg or shade_10)
    surface.DrawRect(0,0,w,h)

    surface.SetDrawColor(shade_10)
    surface.DrawRect(0,0,w,self.defaultH)
    surface.DrawRect(w-1,0,1,h)
    surface.DrawRect(0,0,1,h)

    draw.SimpleText(self.title, font, w * .5, self.defaultH * .5, textcolor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
    draw.SimpleText(self.collapsed and "-" or "+", font, w - margin - self.halfTall, self.defaultH * .5, textcolor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

    if self.collapsed and self:getChildCount() <= 0 then 
        local offset = self:GetTall() - self.defaultH
        draw.SimpleText(self.emptyMsg or "", font_smaller, w * .5, self.defaultH + offset * .5, textcolor_min55, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
    end
end

vgui.Register("SCollapsiblePanel", PANEL, "EditablePanel")
--PATH lua/slib/vgui/cl_splayerpanel.lua:
return gluapack()()
--PATH lua/slib/vgui/cl_stableviewer.lua:
return gluapack()()
--PATH lua/slib/vgui/cl_stextentry.lua:
local PANEL = {}

local accentcolor, textcolor, textcolor_30, textcolor_80 = slib.getTheme("accentcolor"), slib.getTheme("textcolor"), slib.getTheme("textcolor", -30), slib.getTheme("textcolor", -80)

function PANEL:Init()
    slib.wrapFunction(self, "Dock", nil, function() return self end, true)
    slib.wrapFunction(self, "SetNumeric", nil, function() return self end, true)
    slib.wrapFunction(self, "DockMargin", nil, function() return self end, true)
    slib.wrapFunction(self, "SetTextColor", nil, function() return self end, true)
    slib.wrapFunction(self, "SetDrawLanguageID", nil, function() return self end, true)
    slib.wrapFunction(self, "SetFont", nil, function() return self end, true)
    slib.wrapFunction(self, "SetTall", nil, function() return self end, true)
    slib.wrapFunction(self, "SetValue", nil, function() return self end, true)

    self.font = slib.createFont("Roboto", 15)
    self.placeholder = "Search..."

    self:SetDrawLanguageID(false)
    :SetTall(slib.getScaledSize(25, "y"))
    :SetFont(self.font)
    :SetTextColor(textcolor_80)
    :SetValue(self.placeholder)
end

function PANEL:Paint(w,h)
    local val = self:GetValue()
    local wantedcolor = accentcolor
    wantedcolor.a = self:HasFocus() and 120 or 20

    if self.bg then
        surface.SetDrawColor(self.bg)
        surface.DrawRect(0, 0, w, h)
    end
    
    if !self.sideline then
        surface.SetDrawColor(slib.lerpColor(self, wantedcolor))
        surface.DrawRect(0, !self.accentlinetop and h - 1 or 0, w, 1)
    end

    self:DrawTextEntryText(val == self.placeholder and textcolor_30 or textcolor, accentcolor, textcolor)
end

function PANEL:OnGetFocus()
    local val = self:GetValue()
    if val == self.placeholder then
        self:SetValue("")
    end
end

function PANEL:AccentLineTop(bool)
    self.accentlinetop = bool
end

function PANEL:SetRefreshRate(rate)
    self.refreshrate = rate
end

function PANEL:AccentSideLine(bool)
    self.sideline = bool
end

function PANEL:OnTextChanged()
    local newvalue = self:GetValue()

    timer.Create(tostring(self), self.refreshrate or .3, 1, function()
        if !IsValid(self) then return end
        if isfunction(self.onValueChange) then
            self.onValueChange(newvalue)
        end
    end)
end

function PANEL:SetPlaceholder(str)
    self.placeholder = str
    self:SetValue(self.placeholder)

    return self
end

function PANEL:OnLoseFocus()
    timer.Simple(.1, function()
        if !IsValid(self) then return end
        local val = self:GetValue()
        if !val or val == "" then
            self:SetValue(self.placeholder)
        end
    end)
end

vgui.Register("STextEntry", PANEL, "DTextEntry")
--PATH addons/[admin] gprotect_1.15.101/lua/g_protect/languages/sh_english.lua:
return gluapack()()
--PATH addons/[admin] gprotect_1.15.101/lua/g_protect/languages/sh_french.lua:
if SERVER then
	slib.setLang("gprotect", "fr", "colliding-too-much", "%s's entits sont trop en collision!")
	slib.setLang("gprotect", "fr", "props-colliding-too-much", "Les props de %s entrent trop en collision avec un total de %s collisions")
	slib.setLang("gprotect", "fr", "too-many-obstructs", "%s's entits fait obstruction  trop de mauvaises entits!")
	slib.setLang("gprotect", "fr", "blacklisted-multiple", "Vous avez russi  ajouter un modles %s aux modles bloqus!")
	slib.setLang("gprotect", "fr", "unblacklisted-multiple", "Vous avez russi  supprimer les modles %s des modles bloqus!")
	slib.setLang("gprotect", "fr", "blacklisted-multiple-ent", "Vous avez russi  ajouter %s ents aux entits figurant sur la liste noire!")
	slib.setLang("gprotect", "fr", "unblacklisted-multiple-ent", "Vous avez russi  supprimer %s ents des entits figurant sur la liste noire!")
	slib.setLang("gprotect", "fr", "added-blacklist", "Vous avez russi  ajouter %s aux modles bloqus!")
	slib.setLang("gprotect", "fr", "removed-blacklist", "Vous avez russi  supprimer %s des modles bloqus!")
	slib.setLang("gprotect", "fr", "added-blacklist-ent", "Vous avez ajout avec succs %s  la liste noire des entits!")
	slib.setLang("gprotect", "fr", "removed-blacklist-ent", "Vous avez russi  supprimer %s de la liste noire des entits!")
	slib.setLang("gprotect", "fr", "attempted-unfreeze-all", "%s a essay de tout dcongeler aprs avoir engendr un dupe!")
	slib.setLang("gprotect", "fr", "attempted-upscaled-ent", "%s a essay de spawner une entit trop grosse avec adv dupe 2!")
	slib.setLang("gprotect", "fr", "attempted-rope-spawning", "%s a essay de spawner des cordes en utilisant adv dupe 2!")
	slib.setLang("gprotect", "fr", "attempted-no-gravity", "%s a essay de spawner des accessoires sans gravit en utilisant adv dupe 2!")
	slib.setLang("gprotect", "fr", "attempted-trail", "%s a essay de spawn un props avec des trails advanced dupe 2!")
	slib.setLang("gprotect", "fr", "attempted-advdupe-out-of-bounds", "%s a essay de gnrer des entits hors limites en utilisant adv dupe 2!")
	slib.setLang("gprotect", "fr", "attempted-advdupe-weird-angles", "%s a essay de gnrer des entits avec des angles tranges en utilisant adv dupe 2!")
	slib.setLang("gprotect", "fr", "attempted-instacrash-server", "%s peut avoir tent d'instant-crash le server!")

	slib.setLang("gprotect", "fr", "model-restricted", "Ce modle a t restreint!")
	slib.setLang("gprotect", "fr", "classname-restricted", "Cette classe dentit a t restreinte!")
	slib.setLang("gprotect", "fr", "attempted-blacklistedmaterial", "%s a essay d'utiliser un mazteriaux blacklist avec le fading door!")
	slib.setLang("gprotect", "fr", "attempted-blackout", "%s a tent lexploit blackout!")
	slib.setLang("gprotect", "fr", "spam-spawning", "%s essaie de spam le spawn des entites / props.")

	slib.setLang("gprotect", "fr", "too-complex-model", "Ce Model a t restreint, il est trop compliqu!")
	slib.setLang("gprotect", "fr", "too-big-prop", "Votre props est trop grand alors nous lavons enlev!")
	slib.setLang("gprotect", "fr", "successfull-fpp-blockedmodels", "Vous avez russi  transfrer les modles bloqus de FPP  gProtect!")
	slib.setLang("gprotect", "fr", "successfull-fpp-grouptools", "Vous avez russi  transfrer les grouptools de FPP  gProtect!")
	slib.setLang("gprotect", "fr", "unsuccessfull-transfer", "Il semble y avoir un problme lors du transfert des donnes! (MySQL nest pas pris en charge)")

	slib.setLang("gprotect", "fr", "blocked-secondaryusergroup", "Bloqu en raison du usergroup secondaire!")
	slib.setLang("gprotect", "fr", "blocked-usergroup", "Bloqu en raison du usergroup!")
	slib.setLang("gprotect", "fr", "blocked-teamname", "Bloqu en raison du nom du mtier!")
	slib.setLang("gprotect", "fr", "blocked-sid", "Bloqu  cause du SteamID!")
	
	slib.setLang("gprotect", "fr", "you-ghosted-props", "Vous avez mis en fantome %s's props!")
	slib.setLang("gprotect", "fr", "you-frozen-props", "Vous avez freeze %s's props!")
	slib.setLang("gprotect", "fr", "you-removed-props", "Vous avez supprim %s's props!")
	slib.setLang("gprotect", "fr", "you-removed-ents", "Vous avez retir les entits de %s !")

	slib.setLang("gprotect", "fr", "props-ghosted", "Vos props ont t mis en fantmes!")
	slib.setLang("gprotect", "fr", "props-frozen", "Vos props ont t gels!")
	slib.setLang("gprotect", "fr", "props-removed", "Vos props ont t enlevs!")
	slib.setLang("gprotect", "fr", "ents-removed", "Vos entits ont t supprimes !")

	slib.setLang("gprotect", "fr", "everyones-props-ghosted", "Quelquun a mis en fantme tout les props de tout le monde!")
	slib.setLang("gprotect", "fr", "everyones-props-frozen", "Quelquun a gel tous les props!")
	slib.setLang("gprotect", "fr", "disconnected-ents-removed", "Vous avez supprim toutes les entits des joueurs dconnects!")
	
	slib.setLang("gprotect", "fr", "spawn-to-close", "Votre prop ne peux pas tre spawn dans quelqu'un !")
	slib.setLang("gprotect", "fr", "entity-ghosted", "Votre entit a t mis en fantme!")

	slib.setLang("gprotect", "fr", "ratelimited_toolgun", "Cet outil a un taux limite, veuillez patienter!")
	slib.setLang("gprotect", "fr", "too_many_obstructs_purchase", "Nous avons supprim l'entit et vous avons rembours, il y a trop d'obstructions !")

	slib.setLang("gprotect", "fr", "insufficient-permission", "Vous navez pas le privilge de le faire!")
	slib.setLang("gprotect", "fr", "spawn-to-close", "Votre props ne peut pas tre spawner  lintrieur de quelquun!")
	slib.setLang("gprotect", "fr", "entity-ghosted", "Votre entit a t mis en fantme!")
	
	slib.setLang("gprotect", "fr", "mysql_successfull", "Nous nous sommes connects avec succs  la base de donnes!")
    slib.setLang("gprotect", "fr", "mysql_failed", "Nous n'avons pas russi  nous connecter  la base de donnes!")
elseif CLIENT then
	slib.setLang("gprotect", "fr", "title", "gProtect - Paramtres")
	slib.setLang("gprotect", "fr", "buddies-title", "gProtect - Ami(e)(s)")

	slib.setLang("gprotect", "fr", "world", "Monde")
	slib.setLang("gprotect", "fr", "disconnected", "Dconnect")
	slib.setLang("gprotect", "fr", "toolgun-name", "Props blacklist")
	slib.setLang("gprotect", "fr", "toolgun-desc", "Grer les modles bloqus")
	slib.setLang("gprotect", "fr", "toolgun-leftclick", "Ajouter aux modles sur la liste noire")
	slib.setLang("gprotect", "fr", "toolgun-rightclick", "Supprimer des modles sur la liste noire")
	slib.setLang("gprotect", "fr", "toolgun-help", "Tirer sur un props avec loutil")
	slib.setLang("gprotect", "fr", "remove-on-blacklist", "Supprimer le props sur la liste noire")
	slib.setLang("gprotect", "fr", "player-list", "Liste des joueurs")
	
	slib.setLang("gprotect", "fr", "submit", "Soumettre")
	slib.setLang("gprotect", "fr", "input_number", "Input number")

	slib.setLang("gprotect", "fr", "toolgun", "Toolgun")
	slib.setLang("gprotect", "fr", "physgun", "Physgun")
	slib.setLang("gprotect", "fr", "gravity-gun", "Gravity Gun")
	slib.setLang("gprotect", "fr", "canproperty", "Peut acheter")
	slib.setLang("gprotect", "fr", "canuse", "Peut utiliser")

	slib.setLang("gprotect", "fr", "add-blocked-models", "Ajouter aux modles bloqus")
	slib.setLang("gprotect", "fr", "remove-blocked-models", "Supprimer des modles bloqus")

	slib.setLang("gprotect", "fr", "add-blacklisted-ents", "Ajouter aux entits sur liste noire")
	slib.setLang("gprotect", "fr", "remove-blacklisted-ents", "Supprimer des entits inscrites sur la liste noire")
	slib.setLang("gprotect", "fr", "copy-clipboard", "Copier dans le Presse-papiers")

	slib.setLang("gprotect", "fr", "general", "Gnral")
	slib.setLang("gprotect", "fr", "ghosting", "Fantomes")
	slib.setLang("gprotect", "fr", "damage", "Dommages")
	slib.setLang("gprotect", "fr", "anticollide", "Anti collision")
	slib.setLang("gprotect", "fr", "spamprotection", "protection contre le spam")
	slib.setLang("gprotect", "fr", "spawnrestriction", "Restriction du spawn")
	slib.setLang("gprotect", "fr", "toolgunsettings", "Paramtres du Toolgun")
	slib.setLang("gprotect", "fr", "physgunsettings", "Paramtres du Physgun")
	slib.setLang("gprotect", "fr", "gravitygunsettings", "Paramtres du Gravgun")
	slib.setLang("gprotect", "fr", "canpropertysettings", "Paramtres propritaire")
	slib.setLang("gprotect", "fr", "canusesettings", "Peut utiliser les paramtres")
	slib.setLang("gprotect", "fr", "advdupe2", "Adv Dupe 2")
	slib.setLang("gprotect", "fr", "miscs", "Divers")

	slib.setLang("gprotect", "fr", "ghost-props", "Props fantmes")
	slib.setLang("gprotect", "fr", "remove-props", "Supprimer les props")
	slib.setLang("gprotect", "fr", "freeze-props", "Freeze Props")
	slib.setLang("gprotect", "fr", "remove-entities", "Enlever entites")
	slib.setLang("gprotect", "fr", "highlight-ents", "Mettre en surbrillance les entits")
	slib.setLang("gprotect", "fr", "unhighlight-ents", "Enlever la surbrillance des entits")

	slib.setLang("gprotect", "fr", "ghost-everyones-props", "Mettre en fantome tout les props de tout le monde")
	slib.setLang("gprotect", "fr", "freeze-everyones-props", "Freeze les props de tout le monde")
	slib.setLang("gprotect", "fr", "remove-disconnected-props", "Supprimer les props des joueurs dconnects")

	slib.setLang("gprotect", "fr", "general_remDiscPlyEnt", "Supprimer les entits des joueurs dconncter")
	slib.setLang("gprotect", "fr", "general_remDiscPlyEnt_tooltip", "Cela supprime les entits des joueurs dconnects avec une minuterie(Si -1 il sera dsactiv.)")
	slib.setLang("gprotect", "fr", "general_remDiscPlyEntSpecific", "Supprimer les entits de joueurs dconnects spcifiques")
	slib.setLang("gprotect", "fr", "general_remDiscPlyEntSpecific_tooltip", "Heure spcifique pour la suppression des entits, si rien n'est spcifi, elle utilisera celle par dfaut spcifie ci-dessus. Faire -1 pour le nom de classe l'ignorera compltement")
	slib.setLang("gprotect", "fr", "general_blacklist", "Liste noire")
	slib.setLang("gprotect", "fr", "general_blacklist_tooltip", "Cest l qu'il faut ajouter des noms de classe qui doivent tre protgs par gnralement tous les modules.")
	slib.setLang("gprotect", "fr", "general_protectedFrozenEnts", "Les entits geles et protges")
	slib.setLang("gprotect", "fr", "general_protectedFrozenEnts_tooltip", "Il sagit de la liste des entits  protger")
	slib.setLang("gprotect", "fr", "general_protectedFrozenGroup", "Groupe gel et protg")
	slib.setLang("gprotect", "fr", "general_protectedFrozenGroup_tooltip", "Il sagit du groupe de collision pour mettre des entits geles!")

	slib.setLang("gprotect", "fr", "general_remOutOfBounds", "Supprimer le chronomtre hors limites")
	slib.setLang("gprotect", "fr", "general_remOutOfBounds_tooltip", "Cela supprimera les entits qui sont en dehors de la carte (Si -1, il sera dsactiv)")
	slib.setLang("gprotect", "fr", "general_remOutOfBoundsWhitelist", "Supprimer la liste blanche hors limites")
	slib.setLang("gprotect", "fr", "general_remOutOfBoundsWhitelist_tooltip", "Les entits de cette liste seront supprimes si elles sont hors limites.")

	slib.setLang("gprotect", "fr", "general_blacklist", "Liste noire")
	slib.setLang("gprotect", "fr", "general_blacklist_tooltip", "C'est l que s'ajoutent les noms de classe qui doivent tre protgs par gnralement tous les modules.")
	slib.setLang("gprotect", "fr", "general_protectedFrozenEnts", "Entits geles protges")
	slib.setLang("gprotect", "fr", "general_protectedFrozenEnts_tooltip", "Voici la liste des entits  protger pendant le gel")
	slib.setLang("gprotect", "fr", "general_protectedFrozenGroup", "Groupe congel protg")
	slib.setLang("gprotect", "fr", "general_protectedFrozenGroup_tooltip", "C'est le groupe de collision pour mettre les entits figes dans!")

	slib.setLang("gprotect", "fr", "ghosting_enabled", "Activ")
	slib.setLang("gprotect", "fr", "ghosting_enabled_tooltip", "Activer le module fantme?")
	slib.setLang("gprotect", "fr", "ghosting_ghostColor", "Couleur fantme")
	slib.setLang("gprotect", "fr", "ghosting_ghostColor_tooltip", "Slectionner une couleur pour les entits fantmes")
	slib.setLang("gprotect", "fr", "ghosting_antiObscuring", "Anti-obscurcissement")
	slib.setLang("gprotect", "fr", "ghosting_antiObscuring_tooltip", "Cela empchera les accessoires dtre unghosted alors quils obscurcissent un objet, Il suffit dajouter des entits qui ne devraient pas tre masques!")
	slib.setLang("gprotect", "fr", "ghosting_onPhysgun", "Mettre en fantomes avec le physgun?")
	slib.setLang("gprotect", "fr", "ghosting_onPhysgun_tooltip", "Cela mettra en fontome les entits que sont pris avec le physgun.")
	slib.setLang("gprotect", "fr", "ghosting_useBlacklist", "Utiliser la liste noiret")
	slib.setLang("gprotect", "fr", "ghosting_useBlacklist_tooltip", "Cette option mettra en fantme les lments figurant sur la liste noire si le module est activ.")
	slib.setLang("gprotect", "fr", "ghosting_entities", "Entits")
	slib.setLang("gprotect", "fr", "ghosting_entities_tooltip", "Les noms de classe dans cette liste seront fantmes, sa ne vas pas modifier la liste noire utilise par dautres modules.")
	slib.setLang("gprotect", "fr", "ghosting_forceUnfrozen", "Forcer les entits fantmes dgels")
	slib.setLang("gprotect", "fr", "ghosting_forceUnfrozen_tooltip", "Cela forcera les entits fantmes qui ne sont pas geles.")
	slib.setLang("gprotect", "fr", "ghosting_forceUnfrozenEntities", "Forcer la liste blanche des ents dgels fantmes")
	slib.setLang("gprotect", "fr", "ghosting_forceUnfrozenEntities_tooltip", "Les entits de cette liste seront fantmes si elles ne sont pas figes.")
	slib.setLang("gprotect", "fr", "ghosting_enableMotion", "Activer le mouvement en mode fantme")
	slib.setLang("gprotect", "fr", "ghosting_fenableMotion_tooltip", "Si activ, la rmanence ne dsactivera pas le mouvement pour les entits.")

	slib.setLang("gprotect", "fr", "damage_enabled", "Activ")
	slib.setLang("gprotect", "fr", "damage_enabled_tooltip", "Activer le module de dgts?")
	slib.setLang("gprotect", "fr", "damage_useBlacklist", "Utiliser la liste noire")
	slib.setLang("gprotect", "fr", "damage_useBlacklist_tooltip", "Cette option considrera la liste noire gnrale comme une entite sur liste noire dans ce module!")
	slib.setLang("gprotect", "fr", "damage_entities", "Entits inscrites sur liste noire")
	slib.setLang("gprotect", "fr", "damage_entities_tooltip", "Les noms de classe de cette liste n'infligeront pas de dgts si la dsactivation des dgats sont cochs, ce qui ne modifiera pas la liste noire utilisable par dautres modules.")
	slib.setLang("gprotect", "fr", "damage_blacklistedEntPlayerDamage", "Dsactiver les dgts des entites sur la liste noire")
	slib.setLang("gprotect", "fr", "damage_blacklistedEntPlayerDamage_tooltip", "Si cela est coch, les joueurs ne recevront pas de dommages de la part dentits figurant sur la liste noire.")
	slib.setLang("gprotect", "fr", "damage_vehiclePlayerDamage", "Dsactiver les dommages causs par le vhicule")
	slib.setLang("gprotect", "fr", "damage_vehiclePlayerDamage_tooltip", "Si cela est coch, les joueurs ne recevront pas de dommages par les vhicules.")
	slib.setLang("gprotect", "fr", "damage_worldPlayerDamage", "Dsactiver les dgts du monde")
	slib.setLang("gprotect", "fr", "damage_worldPlayerDamage_tooltip", "Si cela est coch, les joueurs peuvent recevoir des dommages de la part dentits figurant sur la liste noire.")
	slib.setLang("gprotect", "fr", "damage_immortalEntities", "Entits immortelles")
	slib.setLang("gprotect", "fr", "damage_immortalEntities_tooltip", "Les noms de classe de cette liste ne seront pas endommags, sauf si le joueur est dans le groupe de contournement!")
	slib.setLang("gprotect", "fr", "damage_bypassGroups", "Groupes de contournement")
	slib.setLang("gprotect", "fr", "damage_bypassGroups_tooltip", "Ajouter des groupes dutilisateurs dans cette liste pour contourner les restrictions de dgts, '*' signifie tout le monde!")
	slib.setLang("gprotect", "fr", "damage_canDamageWorldEntities", "Peut endommager les entits du monde")
	slib.setLang("gprotect", "fr", "damage_canDamageWorldEntities_tooltip", "Les groupes qui se trouvent dans cette liste peuvent endommager les entits du monde, '*' signifie tout le monde!")

	slib.setLang("gprotect", "fr", "anticollide_enabled", "Activ")
	slib.setLang("gprotect", "fr", "anticollide_enabled_tooltip", "Activer le module anti-collision ?")
	slib.setLang("gprotect", "fr", "anticollide_notifyStaff", "Informer le personnel")
	slib.setLang("gprotect", "fr", "anticollide_notifyStaff_tooltip", "Les dtections devraient-elles en informer le personnel? NB: Cela peut tre utilis pour piss le personnel.")
	slib.setLang("gprotect", "fr", "anticollide_protectDarkRPEntities", "Protger les entits DarkRP")
	slib.setLang("gprotect", "fr", "anticollide_protectDarkRPEntities_tooltip", "Devrions-nous protger les entits DarkRP? (0 = Dsactiv, 1 = Mettre en fantme, 2 = Freeze, 3 = Supprimer, 4 = Supprimer et rembourser)")
	slib.setLang("gprotect", "fr", "anticollide_DRPentitiesThreshold", "Seuil des entits DRP")
	slib.setLang("gprotect", "fr", "anticollide_DRPentitiesThreshold_tooltip", "Combien de collisions un props peut avoir avant dtre dclenche dans les 1 seconde?")
	slib.setLang("gprotect", "fr", "anticollide_DRPentitiesException", "Exception des entits DRP")
	slib.setLang("gprotect", "fr", "anticollide_DRPentitiesException_tooltip", "Quelles collisions ignorons-nous? (0 = Aucune, 1 = Pas le mme propritaire, 2 = Aucun propritaire)")
	slib.setLang("gprotect", "fr", "anticollide_protectSpawnedEntities", "Protger les entits spawner")
	slib.setLang("gprotect", "fr", "anticollide_protectSpawnedEntities_tooltip", "Devrions-nous protger les entits spawner? (0 = Disactiv 1 = Mettre en fantme, 2 = Freeze, 3 = Supprimer")
	slib.setLang("gprotect", "fr", "anticollide_entitiesThreshold", "Seuil des entits spawner")
	slib.setLang("gprotect", "fr", "anticollide_entitiesThreshold_tooltip", "Combien de collisions un props peut-il avoir avant dtre dclenche en moins dune seconde?")
	slib.setLang("gprotect", "fr", "anticollide_entitiesException", "Exception sur les entits spawner")
	slib.setLang("gprotect", "fr", "anticollide_entitiesException_tooltip", "Quelles collisions ignorons-nous? (0 = Aucune, 1 = Pas le mme propritaire, 2 = Aucun propritaire)")
	slib.setLang("gprotect", "fr", "anticollide_protectSpawnedProps", "Protger les props spawner")
	slib.setLang("gprotect", "fr", "anticollide_protectSpawnedProps_tooltip", "Devrions-nous protger les props spawer ? (0 = Dsactiv, 1 = Ghost, 2 = Freeze, 3 = Remove")
	slib.setLang("gprotect", "fr", "anticollide_propsThreshold", "Seuil des props spawner")
	slib.setLang("gprotect", "fr", "anticollide_propsThreshold_tooltip", "Combien de collisions un props peut avoir avant dtre dclenche dans les 1 seconde?")
	slib.setLang("gprotect", "fr", "anticollide_propsException", "Exception des props spawner")
	slib.setLang("gprotect", "fr", "anticollide_propsException_tooltip", "Quelles collisions ignorons-nous? (0 = Aucune, 1 = Pas le mme propritaire, 2 = Aucun propritaire)")
	slib.setLang("gprotect", "fr", "anticollide_useBlacklist", "Utiliser la liste noire")
	slib.setLang("gprotect", "fr", "anticollide_useBlacklist_tooltip", "Les entits figurant sur la liste noire seront fantmes si les collisions sont trop leve si cela est activ.")
	slib.setLang("gprotect", "fr", "anticollide_playerPropAction", "Action d'accessoires spcifiques au joueur")
	slib.setLang("gprotect", "fr", "anticollide_playerPropAction_tooltip", "Quelle action faisons-nous une fois le seuil atteint ? (0 = Dsactiv, 1 = Fantme, 2 = Geler, 3 = Supprimer, 4 = Fantme & Unghost)")
	slib.setLang("gprotect", "fr", "anticollide_playerPropThreshold", "Seuil d'accessoires spcifiques au joueur")
	slib.setLang("gprotect", "fr", "anticollide_playerPropThreshold_tooltip", "Il s'agit du nombre maximal de collisions que les accessoires d'un joueur peuvent avoir par seconde, cela ciblera tous leurs accessoires ! Cela n'enregistre que leurs propres accessoires comme une collision.")
	slib.setLang("gprotect", "fr", "anticollide_useBlacklist", "Utiliser la liste noire")
	slib.setLang("gprotect", "fr", "anticollide_useBlacklist_tooltip", "Les entits sur liste noire seront fantmes si elles se heurtent trop si cela est activ.")
	slib.setLang("gprotect", "fr", "anticollide_ghostEntities", "Entitis")
	slib.setLang("gprotect", "fr", "anticollide_ghostEntities_tooltip", "Les noms de classe de cette liste seront masqus s'ils se heurtent trop.")
	slib.setLang("gprotect", "fr", "anticollide_specificEntities", "Entits spcifiques")
	slib.setLang("gprotect", "fr", "anticollide_specificEntities_tooltip", "Ajoutez des noms de classe ici pour tablir des rgles spcifiques pour eux, ce qui signifie que le nombre ici sera leur seuil, tout ce qui est en dessous de 0 les comptera comme contournement.")
	slib.setLang("gprotect", "fr", "anticollide_squaredPhysicsMaxSize", "Squared physics max size")
	slib.setLang("gprotect", "fr", "anticollide_squaredPhysicsMaxSize_tooltip", "Il s'agit d'une protection globale qui transformera automatiquement les botes de collision complexes et plus petites en carrs, ce qui est efficace pour empcher les sphres de taille moyenne de provoquer un dcalage.")
	slib.setLang("gprotect", "fr", "anticollide_squaredPhysicsEnts", "Entits de physique dans la zone")
	slib.setLang("gprotect", "fr", "anticollide_squaredPhysicsEnts_tooltip", "Il s'agit d'une fonction anti-collision globale, qui rend les entits endormies aprs avoir atteint le seuil dfini (le seuil est effac toutes les 1 seconde)")


	slib.setLang("gprotect", "fr", "spamprotection_enabled", "Activ")
	slib.setLang("gprotect", "fr", "spamprotection_enabled_tooltip", "Activer le module contre la protection des spams ?")
	slib.setLang("gprotect", "fr", "spamprotection_threshold", "Seuil")
	slib.setLang("gprotect", "fr", "spamprotection_threshold_tooltip", "Si vous spawner ces nombreux props  la fois, alors il seront effacer   moins que le dlai dfini ci-dessous sois termine.")
	slib.setLang("gprotect", "fr", "spamprotection_delay", "Delai")
	slib.setLang("gprotect", "fr", "spamprotection_delay_tooltip", "Cette minuterie effacera le seuil ci-dessus.")
	slib.setLang("gprotect", "fr", "spamprotection_action", "Punition")
	slib.setLang("gprotect", "fr", "spamprotection_action_tooltip", "Cela dcidera de la faon de traiter avec les spammeurs! (1 = Dsactiver le spawning, 2 = mettre en fantme entites / props)")
	slib.setLang("gprotect", "fr", "spamprotection_notifyStaff", "Informer le personnel")
	slib.setLang("gprotect", "fr", "spamprotection_notifyStaff_tooltip", "Les dtections devraient-elles en informer le personnel? NB: Cela peut tre utilis pour piss le personnel.")
	slib.setLang("gprotect", "fr", "spamprotection_protectProps", "Protger les props")
	slib.setLang("gprotect", "fr", "spamprotection_protectProps_tooltip", "Cela protgera les props contre le spawn spam.")
	slib.setLang("gprotect", "fr", "spamprotection_protectEntities", "Protger les entits")
	slib.setLang("gprotect", "fr", "spamprotection_protectEntities_tooltip", "Cela protgera les entits contre le spawn spam.")

	slib.setLang("gprotect", "fr", "spawnrestriction_enabled", "Activ")
	slib.setLang("gprotect", "fr", "spawnrestriction_enabled_tooltip", "Activer le module rstriction contre les spawns?")
	slib.setLang("gprotect", "fr", "spawnrestriction_propSpawnPermission", "Permission pour spawn un props")
	slib.setLang("gprotect", "fr", "spawnrestriction_propSpawnPermission_tooltip", "Cela limitera totalement le spawn de props! (Ajouter des groupes dutilisateurs ici pour leur permettre, * signifie tout le monde!)")
	slib.setLang("gprotect", "fr", "spawnrestriction_SENTSpawnPermission", "Permission de spawn les entits")
	slib.setLang("gprotect", "fr", "spawnrestriction_SENTSpawnPermission_tooltip", "Cela limitera totalement le spawn d'entites! (Ajouter des groupes dutilisateurs ici pour leur permettre, * signifie tout le monde!)")
	slib.setLang("gprotect", "fr", "spawnrestriction_SWEPSpawnPermission", "Permission pour spawn les Armes")
	slib.setLang("gprotect", "fr", "spawnrestriction_SWEPSpawnPermission_tooltip", "Cela limitera totalement le spawn d'arme! (Ajouter des groupes dutilisateurs ici pour leur permettre, * signifie tout le monde!)")
	slib.setLang("gprotect", "fr", "spawnrestriction_vehicleSpawnPermission", "Permission pour spawn les vhicules")
	slib.setLang("gprotect", "fr", "spawnrestriction_vehicleSpawnPermission_tooltip", "Cela limitera totalement le spawn de vhicules! (Ajouter des groupes dutilisateurs ici pour leur permettre, * signifie tout le monde!)")
	slib.setLang("gprotect", "fr", "spawnrestriction_NPCSpawnPermission", "Permission pour spawn de NPC")
	slib.setLang("gprotect", "fr", "spawnrestriction_NPCSpawnPermission_tooltip", "Cela limitera totalement le spawn de NPC! (Ajouter des groupes dutilisateurs ici pour leur permettre, * signifie tout le monde!)")
	slib.setLang("gprotect", "fr", "spawnrestriction_ragdollSpawnPermission", "permission pour spawn des RAGDOLL")
	slib.setLang("gprotect", "fr", "spawnrestriction_ragdollSpawnPermission_tooltip", "Cela limitera totalement le spawn de RAGDOLL! (Ajouter des groupes dutilisateurs ici pour leur permettre, * signifie tout le monde!)")
	slib.setLang("gprotect", "fr", "spawnrestriction_effectSpawnPermission", "Permission pour spawn des effets")
	slib.setLang("gprotect", "fr", "spawnrestriction_effectSpawnPermission_tooltip", "Cela limitera totalement le spawn d'effets! (Ajouter des groupes dutilisateurs ici pour leur permettre, * signifie tout le monde!)")
	slib.setLang("gprotect", "fr", "spawnrestriction_blockedEntities", "Entites bloqus")
	slib.setLang("gprotect", "fr", "spawnrestriction_blockedEntities_tooltip", "Placez les noms de classe dentits qui ne devraient jamais tre spawn ici!")
	slib.setLang("gprotect", "fr", "spawnrestriction_blockedEntitiesIsBlacklist", "Les classes bloques sont une liste noire")
	slib.setLang("gprotect", "fr", "spawnrestriction_blockedEntitiesIsBlacklist_tooltip", "Si coch, il empchera les classes dans la liste des classes bloqus de spawn, sinon vous pouvez spawn ces classes.")
	slib.setLang("gprotect", "fr", "spawnrestriction_blockedModels", "Modles bloqus")
	slib.setLang("gprotect", "fr", "spawnrestriction_blockedModels_tooltip", "placer le model du props que vous voulez pas qui spawn et il ne pourrat plus tre spawn par personne!")
	slib.setLang("gprotect", "fr", "spawnrestriction_blockedModelsisBlacklist", "Les modles bloqus sont une liste noire")
	slib.setLang("gprotect", "fr", "spawnrestriction_blockedModelsisBlacklist_tooltip", "Si coch, il empchera les models dans la liste noir de spawner")
	slib.setLang("gprotect", "fr", "spawnrestriction_blockedModelsVehicleBypass", "Gnrer des modles bloqus par contournement de vhicule")
	slib.setLang("gprotect", "fr", "spawnrestriction_blockedModelsVehicleBypass_tooltip", "Si coch, les vhicules ignoreront la liste des modles bloqus.")
	slib.setLang("gprotect", "fr", "spawnrestriction_bypassGroups", "Groupes de contournement")
	slib.setLang("gprotect", "fr", "spawnrestriction_bypassGroups_tooltip", "Ces groupes seront en mesure de contourner les entites et les modles bloqus.")
	slib.setLang("gprotect", "fr", "spawnrestriction_maxPropModelComplexity", "Complexit maximale du modle d'hlice")
	slib.setLang("gprotect", "fr", "spawnrestriction_maxPropModelComplexity_tooltip", "Cela empchera de gnrer des modles avec des formes complexes, la valeur recommande est 10. (0 = dsactiv)")
	slib.setLang("gprotect", "fr", "spawnrestriction_maxModelSize", "Taille maximale du modle")
	slib.setLang("gprotect", "fr", "spawnrestriction_maxModelSize_tooltip", "Si cest au-dessus de 0, il supprimera les plus grands props juste aprs quils soient spawner.")

	slib.setLang("gprotect", "fr", "toolgunsettings_enabled", "Activ")
	slib.setLang("gprotect", "fr", "toolgunsettings_enabled_tooltip", "Activer le module paramtres du toolsgun ?")
	slib.setLang("gprotect", "fr", "toolgunsettings_targetWorld", "Peut cibler des entits mondiales")
	slib.setLang("gprotect", "fr", "toolgunsettings_targetWorld_tooltip", "Cela signifie qu'ils peuvent cibler les entits et les props du de la map! (Ajouter des groupes dutilisateurs ici pour leur permettre, * signifie tout le monde!)")
	slib.setLang("gprotect", "fr", "toolgunsettings_targetPlayerOwned", "Peut cibler les entits dtenues par le joueur")
	slib.setLang("gprotect", "fr", "toolgunsettings_targetPlayerOwned_tooltip", "Cela signifie quils peuvent cibler les entits et les props des joueurs! (Ajouter des groupes dutilisateurs ici pour leur permettre, * signifie tout le monde!)")
	slib.setLang("gprotect", "fr", "toolgunsettings_targetPlayerOwnedProps", "Peut cibler les accessoires appartenant au joueur")
	slib.setLang("gprotect", "fr", "toolgunsettings_targetPlayerOwnedProps_tooltip", "Cela signifie qu'ils peuvent cibler les accessoires des joueurs ! (Ajoutez des groupes d'utilisateurs ici pour les autoriser, * signifie tout le monde !)")
	slib.setLang("gprotect", "fr", "toolgunsettings_targetVehiclePermission", "Autorisation du vhicule cible")
	slib.setLang("gprotect", "fr", "toolgunsettings_targetVehiclePermission_tooltip", "Si des personnes font partie des groupes d'utilisateurs de cette liste, elles peuvent utiliser le pistolet  outils sur les vhicules !")

	slib.setLang("gprotect", "fr", "toolgunsettings_restrictTools", "Outils restreints")
	slib.setLang("gprotect", "fr", "toolgunsettings_restrictTools_tooltip", "Les outils ici ne seront pas utilisables par nimporte qui, sauf ceux dans loption bypassGroups ci-dessous.")
	slib.setLang("gprotect", "fr", "toolgunsettings_groupToolRestrictions", "Rstriction des tools par groupe")
	slib.setLang("gprotect", "fr", "toolgunsettings_groupToolRestrictions_tooltip", "Configurer les restrictions doutils par outil.")
	slib.setLang("gprotect", "fr", "toolgunsettings_bypassGroups", "Groupes de contournement")
	slib.setLang("gprotect", "fr", "toolgunsettings_bypassGroups_tooltip", "Les groupes ici contourneront les restrictions d'outils des listes ci-dessus !")
	slib.setLang("gprotect", "fr", "toolgunsettings_entityTargetability", "Cible des entits")
	slib.setLang("gprotect", "fr", "toolgunsettings_entityTargetability_tooltip", "Cette option permet de restreindre l'utilisation du toolsgun sur certaine entits!")
	slib.setLang("gprotect", "fr", "toolgunsettings_bypassGroups", "Groupes de contournement")
	slib.setLang("gprotect", "fr", "toolgunsettings_bypassGroups_tooltip", "Les groupes ici contourneront la liste de restriction doutils den haut!")
	slib.setLang("gprotect", "fr", "toolgunsettings_bypassTargetabilityTools", "Contourner les outils de ciblage")
	slib.setLang("gprotect", "fr", "toolgunsettings_bypassTargetabilityTools_tooltip", "Les outils de cette liste contourneront les paramtres de ciblage !")
	slib.setLang("gprotect", "fr", "toolgunsettings_bypassTargetabilityGroups", "Ignorer les groupes de ciblage")
	slib.setLang("gprotect", "fr", "toolgunsettings_bypassTargetabilityGroups_tooltip", "Les groupes de cette liste contourneront les paramtres de ciblage !")
	slib.setLang("gprotect", "fr", "toolgunsettings_antiSpam", "Anti spam")
	slib.setLang("gprotect", "fr", "toolgunsettings_antiSpam_tooltip", "Ajoutez des outils ici et spcifiez combien de fois ils peuvent utiliser l'outil par seconde !")



	slib.setLang("gprotect", "fr", "physgunsettings_enabled", "Activ")
	slib.setLang("gprotect", "fr", "physgunsettings_enabled_tooltip", "Activer le module paramtres du physgun ?")
	slib.setLang("gprotect", "fr", "physgunsettings_targetWorld", "Peut cibler des entits mondiales")
	slib.setLang("gprotect", "fr", "physgunsettings_targetWorld_tooltip", "Cela signifie quils peuvent cibler les entits et les props de la map! (Ajouter des groupes dutilisateurs ici pour leur permettre, * signifie tout le monde!)")
	slib.setLang("gprotect", "fr", "physgunsettings_targetPlayerOwned", "Peut cibler les entits dtenues par le joueur")
	slib.setLang("gprotect", "fr", "physgunsettings_targetPlayerOwned_tooltip", "Cela signifie quils peuvent cibler les entits et les props des joueurs! (Ajouter des groupes dutilisateurs ici pour leur permettre, * signifie tout le monde!)")
	slib.setLang("gprotect", "fr", "physgunsettings_targetPlayerOwnedProps", "Peut cibler les accessoires appartenant au joueur")
	slib.setLang("gprotect", "fr", "physgunsettings_targetPlayerOwnedProps_tooltip", "Cela signifie qu'ils peuvent cibler les accessoires des joueurs ! (Ajoutez des groupes d'utilisateurs ici pour les autoriser, * signifie tout le monde !)")
	slib.setLang("gprotect", "fr", "physgunsettings_DisableReloadUnfreeze", "Dsactiver le rechargement")
	slib.setLang("gprotect", "fr", "physgunsettings_DisableReloadUnfreeze_tooltip", "Empche les joueurs de unfreeze leurs props en appuyant sur 'recharger' avec le physgun en main.")
	slib.setLang("gprotect", "fr", "physgunsettings_PickupVehiclePermission", "Permission de prendre les vhicules")
	slib.setLang("gprotect", "fr", "physgunsettings_PickupVehiclePermission_tooltip", "Si des personnes sont dans les groupes dutilisateurs de cette liste, elles peuvent prendres les vhicules avec le physgun!")
	slib.setLang("gprotect", "fr", "physgunsettings_StopMotionOnDrop", "Stop motion on drop")
	slib.setLang("gprotect", "fr", "physgunsettings_StopMotionOnDrop_tooltip", "Cela permettra dviter prop-pushing / prop-killing.")
	slib.setLang("gprotect", "fr", "physgunsettings_blockMultiplePhysgunning", "Bloquer le physgunning multiple")
	slib.setLang("gprotect", "fr", "physgunsettings_blockMultiplePhysgunning_tooltip", "Cela bloquera une entit qui est physgunned dtre physgunned par quelquun dautre!")
	slib.setLang("gprotect", "fr", "physgunsettings_maxDropObstructs", "Seuil dobstruction maximale")
	slib.setLang("gprotect", "fr", "physgunsettings_maxDropObstructs_tooltip", "Cest le seuil du nombre dobstructures des entits inscrites sur la liste noire jusqu ce quil dclenche!")
	slib.setLang("gprotect", "fr", "physgunsettings_maxDropObstructsAction", "Action maximale de dclenchement dobstruction")
	slib.setLang("gprotect", "fr", "physgunsettings_maxDropObstructsAction_tooltip", "Cest la faon de menacer les dclencheurs (1 = mettre en fantme, 2 = Freeze, 3 = Supprimer)")
	slib.setLang("gprotect", "fr", "physgunsettings_blockedEntities", "Entits bloques")
	slib.setLang("gprotect", "fr", "physgunsettings_blockedEntities_tooltip", "Ajouter des entits dans cette liste et elle ne sera pas physgunable par toute personne qui nest pas dans le groupe de contournement.")
	slib.setLang("gprotect", "fr", "physgunsettings_bypassGroups", "Groupes de contournement")
	slib.setLang("gprotect", "fr", "physgunsettings_bypassGroups_tooltip", "Ajouter des groupes dutilisateurs dans cette liste pour contourner les entits bloques, '*' signifie tout le monde!")

	slib.setLang("gprotect", "fr", "gravitygunsettings_enabled", "Activ")
	slib.setLang("gprotect", "fr", "gravitygunsettings_enabled_tooltip", "Activer le module de rglages du Gravity GUN?")
	slib.setLang("gprotect", "fr", "gravitygunsettings_targetWorld", "Peut cibler des entits mondiales")
	slib.setLang("gprotect", "fr", "gravitygunsettings_targetWorld_tooltip", "Cela signifie quils peuvent cibler les entits et les props de la map! (Ajouter des groupes dutilisateurs ici pour leur permettre, * signifie tout le monde!)")
	slib.setLang("gprotect", "fr", "gravitygunsettings_targetPlayerOwned", "Peut cibler les entits dtenues par les joueur")
	slib.setLang("gprotect", "fr", "gravitygunsettings_targetPlayerOwned_tooltip", "Cela signifie quils peuvent cibler les entits et les props des joueurs! (Ajouter des groupes dutilisateurs ici pour leur permettre, * signifie tout le monde!)")
	slib.setLang("gprotect", "fr", "gravitygunsettings_targetPlayerOwnedProps", "Peut cibler les accessoires appartenant au joueur")
	slib.setLang("gprotect", "fr", "gravitygunsettings_targetPlayerOwnedProps_tooltip", "Cela signifie qu'ils peuvent cibler les accessoires des joueurs ! (Ajoutez des groupes d'utilisateurs ici pour les autoriser, * signifie tout le monde !)")
	slib.setLang("gprotect", "fr", "gravitygunsettings_DisableGravityGunPunting", "Dsactiver le lazer du clique droit")
	slib.setLang("gprotect", "fr", "gravitygunsettings_DisableGravityGunPunting_tooltip", "C'est le lazer du gravity gun.")
	slib.setLang("gprotect", "fr", "gravitygunsettings_blockedEntities", "Entits bloques")
	slib.setLang("gprotect", "fr", "gravitygunsettings_blockedEntities_tooltip", "Ajouter des entits dans cette liste et il ne pourrat pas tre pris avec le gravity-GUN par toute personne qui nest pas dans le groupe de contournement.")
	slib.setLang("gprotect", "fr", "gravitygunsettings_bypassGroups", "Groupes de contournement")
	slib.setLang("gprotect", "fr", "gravitygunsettings_bypassGroups_tooltip", "Ajouter des groupes dutilisateurs dans cette liste pour contourner les entits bloques, '*' signifie tout le monde!")

	slib.setLang("gprotect", "fr", "canpropertysettings_enabled", "Activ")
	slib.setLang("gprotect", "fr", "canpropertysettings_enabled_tooltip", "Activer le module paramtres de la proprit?")
	slib.setLang("gprotect", "fr", "canpropertysettings_targetWorld", "Peut cibler des entits mondiales")
	slib.setLang("gprotect", "fr", "canpropertysettings_targetWorld_tooltip", "Cela signifie quils peuvent cibler les entits et les props du monde! (Ajouter des groupes dutilisateurs ici pour leur permettre, * signifie tout le monde!)")
	slib.setLang("gprotect", "fr", "canpropertysettings_targetPlayerOwned", "Peut cibler les entits dtenues par le joueur")
	slib.setLang("gprotect", "fr", "canpropertysettings_targetPlayerOwned_tooltip", "Cela signifie quils peuvent cibler les entits et les props des joueurs! (Ajouter des groupes dutilisateurs ici pour leur permettre, * signifie tout le monde!)")
	slib.setLang("gprotect", "fr", "canpropertysettings_targetPlayerOwnedProps", "Peut cibler les accessoires appartenant au joueur")
	slib.setLang("gprotect", "fr", "canpropertysettings_targetPlayerOwnedProps_tooltip", "Cela signifie qu'ils peuvent cibler les accessoires des joueurs ! (Ajoutez des groupes d'utilisateurs ici pour les autoriser, * signifie tout le monde !)")
	slib.setLang("gprotect", "fr", "canpropertysettings_blockedProperties", "Proprits bloques")
	slib.setLang("gprotect", "fr", "canpropertysettings_blockedProperties_tooltip", "Ajouter des proprits  cette liste")
	slib.setLang("gprotect", "fr", "canpropertysettings_blockedPropertiesisBlacklist", "Les proprits bloques sont inscrites sur la liste noire")
	slib.setLang("gprotect", "fr", "canpropertysettings_blockedPropertiesisBlacklist_tooltip", "Si coch, il empchera les proprites prsente dans la liste noire d'tre utilise.")
	slib.setLang("gprotect", "fr", "canpropertysettings_blockedEntities", "Entits bloques")
    slib.setLang("gprotect", "fr", "canpropertysettings_blockedEntities_tooltip", "Ajoutez des entits  cela et il ne sera pas possible de les cibler par quiconque sauf les personnes du groupe de contournement!")
	slib.setLang("gprotect", "fr", "canpropertysettings_bypassGroups", "Groupes de contournement")
	slib.setLang("gprotect", "fr", "canpropertysettings_bypassGroups_tooltip", "Les groupes ici contourneront la liste de restriction de proprit den haut!")

	slib.setLang("gprotect", "fr", "canusesettings_enabled", "Activ")
	slib.setLang("gprotect", "fr", "canusesettings_enabled_tooltip", "Activer le module de paramtres peut utiliser ?")
	slib.setLang("gprotect", "fr", "canusesettings_targetWorld", "Peut cibler des entits mondiales")
	slib.setLang("gprotect", "fr", "canusesettings_targetWorld_tooltip", "Cela signifie qu'ils peuvent cibler des entits mondiales ! (Ajoutez des groupes d'utilisateurs ici pour les autoriser, * signifie tout le monde !)")
	slib.setLang("gprotect", "fr", "canusesettings_targetPlayerOwned", "Peut cibler des entits appartenant  des joueurs")
	slib.setLang("gprotect", "fr", "canusesettings_targetPlayerOwned_tooltip", "Cela signifie qu'ils peuvent cibler des entits de joueurs ! (Ajoutez des groupes d'utilisateurs ici pour les autoriser, * signifie tout le monde !)")
	slib.setLang("gprotect", "fr", "canusesettings_targetPlayerOwnedProps", "Peut cibler les accessoires appartenant au joueur")
	slib.setLang("gprotect", "fr", "canusesettings_targetPlayerOwnedProps_tooltip", "Cela signifie qu'ils peuvent cibler les accessoires des joueurs ! (Ajoutez des groupes d'utilisateurs ici pour les autoriser, * signifie tout le monde !)")
	slib.setLang("gprotect", "fr", "canusesettings_blockedEntities", "Entits bloques")
	slib.setLang("gprotect", "fr", "canusesettings_blockedEntities_tooltip", "Ajoutez des entits  cela et il ne pourra pas tre utilis par quiconque ne faisant pas partie du groupe de contournement.")
	slib.setLang("gprotect", "fr", "canusesettings_blockedEntitiesisBlacklist", "Les entits bloques sont sur liste noire")
	slib.setLang("gprotect", "fr", "canusesettings_blockedEntitiesisBlacklist_tooltip", "Si coch, cela empchera l'utilisation des entits de la liste, sinon vous ne pourrez utiliser que ces entits.")
	slib.setLang("gprotect", "fr", "canusesettings_bypassGroups", "Groupes de contournement")
	slib.setLang("gprotect", "fr", "canusesettings_bypassGroups_tooltip", "Ajoutez des groupes d'utilisateurs dans cette liste pour contourner les entits bloques, '*' signifie tout le monde !")

	slib.setLang("gprotect", "fr", "advdupe2_enabled", "Activ")
	slib.setLang("gprotect", "fr", "advdupe2_enabled_tooltip", "Les dtections devraient-elles en informer le personnel? NB: Cela peut tre utilis pour piss le personnel.")
	slib.setLang("gprotect", "fr", "advdupe2_notifyStaff", "Informer le personnel")
	slib.setLang("gprotect", "fr", "advdupe2_notifyStaff_tooltip", "Les dtections devraient-elles en informer le personnel? NB: Cela peut tre utilis pour piss le personnel.")
	slib.setLang("gprotect", "fr", "advdupe2_PreventRopes", "prvient le spawn de corde")
	slib.setLang("gprotect", "fr", "advdupe2_PreventRopes_tooltip", "prvient les cordes de spawner! (1 = Prvenir le spawn, 2 = Spawn But Fix)")
	slib.setLang("gprotect", "fr", "advdupe2_PreventScaling", "prvient la mise  lchelle")
	slib.setLang("gprotect", "fr", "advdupe2_PreventScaling_tooltip", "Empcher les props haut trop grand de spawner. (1 = Prvenir le spawn, 2 = Spawn But Fix)")
	slib.setLang("gprotect", "fr", "advdupe2_PreventNoGravity", "Prvenir laucune gravit")
	slib.setLang("gprotect", "fr", "advdupe2_PreventNoGravity_tooltip", "Prvenir les props qui spawn sans gravit. (1 = Prvenir le spawn, 2 = Spawn But Fix)")
	slib.setLang("gprotect", "fr", "advdupe2_PreventTrail", "Empcher les tranes")
	slib.setLang("gprotect", "fr", "advdupe2_PreventTrail_tooltip", "Empcher les accessoires de frai avec des sentiers. (1 = empcher le frai, 2 = frayer mais rparer)")
	slib.setLang("gprotect", "fr", "advdupe2_PreventUnreasonableValues", "Empcher les valeurs draisonnables")
	slib.setLang("gprotect", "fr", "advdupe2_PreventUnreasonableValues_tooltip", "Empcher les entits avec des valeurs draisonnables, c'est--dire la position et/ou les angles.")	
	slib.setLang("gprotect", "fr", "advdupe2_PreventUnfreezeAll", "Prvenir lors d'un unfreeze gnral")
	slib.setLang("gprotect", "fr", "advdupe2_PreventUnfreezeAll_tooltip", "prviens les gens lorsqu'il unfreeze tous les props. (1 = Prvenir le spawn, 2 = Spawn But Fix)")
	slib.setLang("gprotect", "fr", "advdupe2_BlacklistedCollisionGroups", "Groupes de collision sur liste noire")
	slib.setLang("gprotect", "fr", "advdupe2_BlacklistedCollisionGroups_tooltip", "Cela protge contre les props que vous ne pouvez pas cibler. NB:Les valeurs doivent tre collision ENUMs")
	slib.setLang("gprotect", "fr", "advdupe2_WhitelistedConstraints", "Contraintes sur la liste blanche")
	slib.setLang("gprotect", "fr", "advdupe2_WhitelistedConstraints_tooltip", "Il sagit dviter toute contrainte indsirable dtre spawn.")
	slib.setLang("gprotect", "fr", "advdupe2_DelayBetweenUse", "Dlai entre les utilisations")
	slib.setLang("gprotect", "fr", "advdupe2_DelayBetweenUse_tooltip", "Cela empchera les gens de spammer l'outil, vitant ainsi les dcalages. (0 = dsactiv)")

	slib.setLang("gprotect", "fr", "miscs_enabled", "Activ")
	slib.setLang("gprotect", "fr", "miscs_enabled_tooltip", "Activer le module divers?")
	slib.setLang("gprotect", "fr", "miscs_ClearDecals", "Minuterie du Clear decals")
	slib.setLang("gprotect", "fr", "miscs_ClearDecals_tooltip", "Minuterie en secondes qui effacera les decals pour tous les joueurs sur une minuterie :)")
	slib.setLang("gprotect", "fr", "miscs_blacklistedFadingDoorMats_punishment", "Paillassons dcolors sur liste noire de punition")
	slib.setLang("gprotect", "fr", "miscs_blacklistedFadingDoorMats_punishment_tooltip", "Int cela punira les gens pour avoir essay d'utiliser des fading door sur liste noire (0 = rien, 1 = notifier, 2 = kick, 3 = ban).")
	slib.setLang("gprotect", "fr", "miscs_blacklistedFadingDoorMats", "fading door sur liste noire")
	slib.setLang("gprotect", "fr", "miscs_blacklistedFadingDoorMats_tooltip", "Ajoutez de mauvais matriaux dans cette liste, 'pp/copy' et 'dev/upscale' par exemple.")	
	slib.setLang("gprotect", "fr", "miscs_NoBlackoutGlitch", "Prvenir lexploi blackout")
	slib.setLang("gprotect", "fr", "miscs_NoBlackoutGlitch_tooltip", "Int cela permettra dempcher lexploit 'pp/copy'(1 = Prvenir, 2 = kick, 3 = ban).")
	slib.setLang("gprotect", "fr", "miscs_FadingDoorLag", "Prvenir les lags du fading doors")
	slib.setLang("gprotect", "fr", "miscs_FadingDoorLag_tooltip", "Cela empchera les gens de crash le serveur avec l'outil fading door.")
	slib.setLang("gprotect", "fr", "miscs_DisableMotion", "Dsactiver le mouvement")
	slib.setLang("gprotect", "fr", "miscs_DisableMotion_tooltip", "Cela dsactivera la requte pour toutes les entits inscrites sur la liste noire.")
	slib.setLang("gprotect", "fr", "miscs_DisableMotion", "Dsactiver le mouvement")
	slib.setLang("gprotect", "fr", "miscs_DisableMotion_tooltip", "Cela dsactivera le mouvement pour toutes les entits sur liste noire.")
	slib.setLang("gprotect", "fr", "miscs_DisableMotionEntities", "Dsactiver les entits de mouvement")
	slib.setLang("gprotect", "fr", "miscs_DisableMotionEntities_tooltip", "Les entits de cette liste ne peuvent pas tre dgeles.")
	slib.setLang("gprotect", "fr", "miscs_freezeOnSpawn", "Geler au frai")
	slib.setLang("gprotect", "fr", "miscs_freezeOnSpawn_tooltip", "Cela permettra de freeze les porps lors du spawn")
	slib.setLang("gprotect", "fr", "miscs_precisionMoveFix", "Empcher les abus de mouvement de prcision")
	slib.setLang("gprotect", "fr", "miscs_precisionMoveFix_tooltip", "Empche le mode de dplacement d'tre abus, pourrait tre utilis pour contourner l'anti-obscurcissement et autres.")	
	slib.setLang("gprotect", "fr", "miscs_preventFadingDoorAbuse", "Prvenir labus du fading door")
	slib.setLang("gprotect", "fr", "miscs_preventFadingDoorAbuse_tooltip", "Cela permettra dviter dobscurcir les gens avec le fading door")
	slib.setLang("gprotect", "fr", "miscs_preventSpawnNearbyPlayer", "Prvient le joueur  proximit du spawn")
	slib.setLang("gprotect", "fr", "miscs_preventSpawnNearbyPlayer_tooltip", "Si quelquun est plus proche de la position de spawn que de cette valeur, il ne spawn pas (0 Dsactiv)")
	slib.setLang("gprotect", "fr", "miscs_DRPEntForceOwnership", "Forcer la proprit sur les entits DarkRP")
	slib.setLang("gprotect", "fr", "miscs_DRPEntForceOwnership_tooltip", "Cela forcera la proprit dentites achets dans le F4")
	slib.setLang("gprotect", "fr", "miscs_DRPMaxObstructsOnPurchaseEnts", "Max obstrue  l'achat pour DarkRP Ents")
	slib.setLang("gprotect", "fr", "miscs_DRPMaxObstructsOnPurchaseEnts_tooltip", "Cela empchera de gnrer beaucoup d'entits DRP les unes  l'intrieur des autres !")
	slib.setLang("gprotect", "fr", "miscs_DRPObstructsFilter", "Max obstrue le filtre des entits DarkRP")
	slib.setLang("gprotect", "fr", "miscs_DRPObstructsFilter_tooltip", "C'est le filtre pour le maximum d'obstructions (1 = Entits DRP, 2 = Props)")
end

slib.setLang("gprotect", "fr", "insufficient-permission", "Vous n'avez pas le privilge de le faire!")
--PATH addons/[misc] smartspawnmanager/lua/autorun/smartspawn_loader.lua:
//
/*
	Smart Spawn Loader
	5/12/2018
	Author: Smart ( Badass Development )
*/

include("smartspawn/sh_config.lua");
if (SERVER) then 
	
	AddCSLuaFile();
	AddCSLuaFile("smartspawn/cl_main.lua");
	AddCSLuaFile("smartspawn/cl_menu.lua");
	AddCSLuaFile("smartspawn/plugins/cl_derma.lua");
	AddCSLuaFile("smartspawn/plugins/sh_notify.lua");
	AddCSLuaFile("smartspawn/sh_config.lua");

	include("smartspawn/sv_main.lua");
else 

	include("smartspawn/cl_main.lua");
end
--PATH addons/[misc] smartspawnmanager/lua/autorun/smartspawn/plugins/cl_derma.lua:
return gluapack()()
--PATH addons/[misc] sreward_1.6.31/lua/s_reward/core/cl_sreward.lua:
sReward = sReward or {}
sReward.data = sReward.data or {}
sReward.data["referrals"] = sReward.data["referrals"] or {}
sReward.data["coupons"] = sReward.data["coupons"] or {}
sReward.data["rewards"] = sReward.data["rewards"] or {}
sReward.data["shop"] = sReward.data["shop"] or {}

local receivedNet

sReward.couponNameToKey = sReward.couponNameToKey or {}

local sreward_menu

local white, textcolor, sidebarbttncolor, textcolor_min10, textcolor_min50, accentcolor, maincolor, maincolor_5, maincolor_7, maincolor_10, maincolor_12, maincolor_15, maincolor_90, successcolor, margin = Color(255,255,255), slib.getTheme("textcolor"), slib.getTheme("sidebarbttncolor"), slib.getTheme("textcolor", -10), slib.getTheme("textcolor", -50), slib.getTheme("accentcolor"), slib.getTheme("maincolor"), slib.getTheme("maincolor", 5), slib.getTheme("maincolor", 7), slib.getTheme("maincolor", 10), slib.getTheme("maincolor", 12), slib.getTheme("maincolor", 15), slib.getTheme("maincolor", 90), slib.getTheme("successcolor"), slib.getTheme("margin")
local failcolor = slib.getTheme("failcolor")

local maincolor_a100 = table.Copy(maincolor)
maincolor_a100.a = 100

local outline = Color(255,255,255,3)

local overlineFont = slib.createFont("Roboto", 13)

local hovercolor = slib.getTheme("hovercolor")
local reward_ico, task_ico, tokens_ico, referral_ico, copy_ico, coupon_ico, smiley_ico, buy_ico, admin_ico, return_ico = Material("sreward/giftbox.png", "smooth"), Material("sreward/checklist.png", "smooth"), Material("sreward/tokens.png", "smooth"), Material("sreward/referring.png", "smooth"), Material("sreward/copy.png", "smooth"), Material("sreward/coupon.png", "smooth"), Material("sreward/smiley.png", "smooth"), Material("sreward/buy.png", "smooth"), Material("sreward/admin.png", "smooth"), Material("sreward/back.png", "smooth")
local settings_ico, delete_ico = Material("sreward/gear.png", "smooth"), Material("sreward/delete.png", "smooth")
local accept_ico = Material("sreward/accept.png", "smooth")
local shadow_col = Color(0,0,0,100)

local friend_ico, foryou_ico = Material("sreward/friend.png", "smooth"), Material("sreward/for-you.png", "smooth")

sReward.GetTokens = function(ply)
    local sid = ply:SteamID()
    return sReward.data[sid] and sReward.data[sid].tokens or 0
end

local function addIconButton(selcol, icon, func, parent)
    local bttn = vgui.Create("SButton", parent)
    bttn:SetWide(bttn:GetTall())
    bttn.DoClick = function()
        func()
    end

    local hovcol = table.Copy(selcol or white)

    bttn.Paint = function(s,w,h)
        hovcol.a = bttn.hovopacity or hovercolor.a
        
        local icosize = h * .7
        local shadowsize = h * .71

        local wantedCol = s:IsHovered() and (selcol or white) or hovcol

        surface.SetDrawColor(slib.lerpColor(s, wantedCol))
        surface.SetMaterial(icon)
        surface.DrawTexturedRect(w * .5 - icosize * .5, h * .5 - icosize * .5, icosize, icosize)

        if s.shadow then
            surface.SetDrawColor(shadow_col)
            surface.SetMaterial(icon)
            surface.DrawTexturedRect(w * .5 - shadowsize * .5, h * .5 - shadowsize * .5, shadowsize, shadowsize)
        end
    end

    return bttn
end

local function checkRewards(data)
    if !data or table.IsEmpty(data.reward) then slib.notify(sReward.config["prefix"]..slib.getLang("sreward", sReward.config["language"], "no_rewards")) return end
    
    local close = vgui.Create("SButton")
    close:SetSize(ScrW(), ScrH())
    close:MakePopup()
    close.Paint = function(s,w,h) end

    close.DoClick = function()
        close:Remove()
    end

    local rewards = vgui.Create("SFrame", close)
    :SetSize(slib.getScaledSize(300, "x"),slib.getScaledSize(200, "y"))
    :setTitle(slib.getLang("sreward", sReward.config["language"], "rewards_title", data.name))
    :Center()
    :addCloseButton()
    :MakePopup()
    :setBlur(true)

    rewards.OnRemove = function()
        close:Remove()
    end

    local canvas = vgui.Create("SScrollPanel", rewards.frame)
    canvas:Dock(FILL)
    canvas:GetCanvas():DockPadding(margin,0,margin,margin)

    for k,v in pairs(data.reward) do
        local reward = vgui.Create("EditablePanel", canvas)
        reward:Dock(TOP)
        reward:DockMargin(0,margin,0,0)
        reward:SetTall(slib.getScaledSize(25, "y"))

        local icon = sReward.Rewards[k]
        local hasIcon = icon and type(icon) == "IMaterial"

        reward.Paint = function(s,w,h)
            surface.SetDrawColor(maincolor_7)
            surface.DrawRect(0,0,w,h)

            local icosize, gap = h * .7, h * .15

            if hasIcon then
                surface.SetDrawColor(white)
                surface.SetMaterial(icon)
                surface.DrawTexturedRect(gap, gap, icosize, icosize)
            end

            draw.SimpleText(slib.getLang("sreward", sReward.config["language"], k), slib.createFont("Roboto", 16), hasIcon and (gap + gap + icosize + margin) or margin, h * .5, textcolor, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
            draw.SimpleText(isnumber(v) and ("x"..string.Comma(v)) or v, slib.createFont("Roboto", 16), w - margin, h * .5, textcolor_min50, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)
        end
    end
end

sReward.addStoreItem = function(canvas, data, row, column)
    local item = vgui.Create("EditablePanel", canvas)
    item.name = data.name
    item.data = data

    local showcase_size = 0

    item.InvalidateLayout = function()
        local addgap = math.floor(margin * 4 / 3)
        local shopitem_wide = math.ceil(((canvas:GetWide() - margin) / 3)) - addgap
        local shopitem_tall = shopitem_wide + slib.getScaledSize(31, "y")
        local fullwidth = shopitem_wide + margin
        showcase_size = shopitem_wide * .9

        item:SetSize(shopitem_wide, shopitem_tall)
        item:SetPos(margin + column * (shopitem_wide + addgap), margin + row * (shopitem_tall + margin))

        for k,v in ipairs(item:GetChildren()) do
            local showcase_size = item:GetWide()
            local gap = showcase_size * .05
            v:SetPos(v.right and (showcase_size - v:GetWide() - gap) or gap,gap)

            v.shadow = true
            v.hovopacity = 120
        end
    end

    item.InvalidateLayout()

    item.Paint = function(s,w,h)
        local gap = showcase_size * .05
        surface.SetDrawColor(maincolor_7)
        surface.DrawRect(0,0,w,h)

        surface.SetDrawColor(maincolor)
        surface.DrawRect(gap, h * .9, showcase_size, 1)
        
        local ico, loading = slib.ImgurGetMaterial(data.imgurid)
        
        if !loading then
            surface.SetDrawColor(white)
            surface.SetMaterial(ico)
            surface.DrawTexturedRect(gap, gap, showcase_size, showcase_size)
        else
            s.rotation = s.rotation or 0
            s.rotation = s.rotation + 1

            local icosize = showcase_size * .5

            surface.SetDrawColor(white)
            surface.SetMaterial(ico)
            surface.DrawTexturedRectRotated(w * .5, gap + showcase_size * .5, icosize, icosize, -s.rotation)
        end

        draw.SimpleText(data.name, slib.createFont("Roboto", 14), w * .5, gap + showcase_size + margin, textcolor_min10, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
        draw.SimpleText(data.price.." TKN", slib.createFont("Roboto", 13), w * .5, h - margin, successcolor, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM)
    end

    local bttnsize = slib.getScaledSize(20, "y")
    item.addButton = function(selcol, icon, func, right)
        local showcase_size = item:GetWide()
        local gap = showcase_size * .05
        local bttn = addIconButton(selcol, icon, func, item)
        bttn:SetPos(right and (showcase_size - bttnsize - gap) or gap,gap)
        bttn:SetSize(bttnsize, bttnsize)
        bttn.right = right
    end

    return item
end

local topcolors = {
    [1] = Color(212, 175, 55),
    [2] = Color(211, 211, 211),
    [3] = Color(205, 127, 50)
}

sReward.addMultibox = function(parent, data)
    local panel = vgui.Create("EditablePanel", parent)
    panel:DockMargin(0,margin,0,0)
    panel:SetTall(slib.getScaledSize(35, "y"))
    panel:Dock(TOP)
    panel.name = data[1].val
    
    panel.Paint = function(s,w,h)
        local icosize = h * .6
        surface.SetDrawColor(maincolor_7)
        surface.DrawRect(0,0,w,h)

        local xoffset = s.avatar and h - 2 + margin or margin

        for k,v in ipairs(data) do
            panel.name = isfunction(v.val) and v.val() or v.val
            draw.SimpleText(v.title, overlineFont, xoffset + (w * v.offset), h * .5 - margin * .5, textcolor_min50, TEXT_ALIGN_LEFT, TEXT_ALIGN_BOTTOM)
            draw.SimpleText(panel.name, slib.createFont("Roboto", 15), xoffset + (w * v.offset), h * .5 - margin * .5, isFriend and successcolor or textcolor, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
        end
    end

    panel.addAvatar = function(ply)
        panel.avatar = vgui.Create( "AvatarImage", panel )
        panel.avatar:SetSize( panel:GetTall() - 4, panel:GetTall() - 4 )
        panel.avatar:SetPos( 2, 2 )
        panel.avatar:SetPlayer( ply, 64 )
    end

    panel.addButton = function(title, func)
        local bttn = vgui.Create("SButton", panel)
        bttn:Dock(RIGHT)
        bttn:DockMargin(0,margin + margin,margin,margin + margin)
        bttn:setTitle(title)
        bttn.DoClick = function()
            func(ply)
        end

        return bttn
    end

    return panel
end

local function createCouponBox(parent, title, code)
    local couponbox = vgui.Create("EditablePanel", parent)
    couponbox:Dock(TOP)
    couponbox:SetTall(slib.getScaledSize(50, "y"))
    couponbox.Paint = function(s,w,h)
        surface.SetDrawColor(maincolor_10)
        surface.DrawRect(0,0,w,h)

        draw.SimpleText(title, slib.createFont("Roboto", 16), margin, h * .25, topcolors[index] or textcolor, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
    end

    local codebox = vgui.Create("STextEntry", couponbox)
    codebox:AccentLineTop(true)
    codebox:SetValue(code)
    codebox:Dock(BOTTOM)
    codebox:SetDisabled(true)
    codebox.bg = maincolor_5

    local bttnsize = slib.getScaledSize(20, "y")
    local gap = slib.getScaledSize(2.5, "y")

    local copy = addIconButton(nil, copy_ico, function() SetClipboardText(code) end, couponbox)
    copy:Dock(RIGHT)
    copy:DockMargin(0, gap, gap, gap)
    copy:SetSize(bttnsize, bttnsize)

    local delete = addIconButton(failcolor, delete_ico, function()
        local popup = vgui.Create("SPopupBox")
        :setTitle(slib.getLang("sreward", sReward.config["language"], "are_you_sure"))
        :setBlur(true)
        :addChoise(slib.getLang("sreward", sReward.config["language"], "no"))
        :addChoise(slib.getLang("sreward", sReward.config["language"], "yes"), function()
            local data = file.Read("sreward/data/coupons.json", "DATA")
            if data then data = util.JSONToTable(data) else data = {} end
        
            data[code] = nil
        
            file.Write("sreward/data/coupons.json", util.TableToJSON(data))
    
            couponbox:Remove()
        end)
        :setText(slib.getLang("sreward", sReward.config["language"], "this_delete", title))
    end, couponbox)
    delete:Dock(RIGHT)
    delete:DockMargin(gap, gap, -gap, gap)
    delete:SetSize(bttnsize, bttnsize)

    return couponbox
end

local function receiveCoupon(title, code)
    local close = vgui.Create("SButton")
    close:SetSize(ScrW(), ScrH())
    close:MakePopup()
    close.Paint = function(s,w,h) end

    close.DoClick = function()
        close:Remove()
    end

    local coupon = vgui.Create("SFrame", close)
    :SetSize(slib.getScaledSize(260, "x"),slib.getScaledSize(150, "y"))
    :setTitle(slib.getLang("sreward", sReward.config["language"], "coupon_receive_title"))
    :Center()
    :addCloseButton()
    :MakePopup()
    :setBlur(true)

    local icosize = coupon.frame:GetTall() * .4
    local parse = markup.Parse("<colour="..textcolor_min10.r..","..textcolor_min10.g..","..textcolor_min10.b..","..textcolor_min10.a.."><font="..slib.createFont("Roboto", 16)..">"..slib.getLang("sreward", sReward.config["language"], "coupon_receive").."</font></colour>", coupon.frame:GetWide())
    coupon.frame.PaintOver = function(s,w,h)
        local x, y = w * .5 - icosize * .5, h * .3 - icosize * .5
        surface.SetDrawColor(successcolor)
        surface.SetMaterial(smiley_ico)
        surface.DrawTexturedRect(x, y, icosize, icosize)

        parse:Draw(w * .5, h * .75, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
    end

    coupon.OnRemove = function()
        close:Remove()
    end

    file.CreateDir("sreward/data")
    local data = file.Read("sreward/data/coupons.json", "DATA")
    if data then data = util.JSONToTable(data) else data = {} end

    data[code] = {title = title, index = table.Count(data)}

    file.Write("sreward/data/coupons.json", util.TableToJSON(data))

end

local function openCoupons()
    local data = file.Read("sreward/data/coupons.json", "DATA")
    if data then data = util.JSONToTable(data) else data = {} end

    if table.IsEmpty(data) then
        slib.notify(sReward.config["prefix"]..slib.getLang("sreward", sReward.config["language"], "no_coupons"))
    return end

    local close = vgui.Create("SButton")
    close:SetSize(ScrW(), ScrH())
    close:MakePopup()
    close.Paint = function(s,w,h) end

    close.DoClick = function()
        close:Remove()
    end

    local couponframe = vgui.Create("SFrame", close)
    :SetSize(slib.getScaledSize(300, "x"),slib.getScaledSize(285, "y"))
    :setTitle(slib.getLang("sreward", sReward.config["language"], "coupon_title"))
    :Center()
    :addCloseButton()
    :MakePopup()
    :setBlur(true)

    local scroller = vgui.Create("SScrollPanel", couponframe.frame)
    scroller:Dock(FILL)
    scroller:GetCanvas():DockPadding(margin,0,margin,margin)

    for code, v in pairs(data) do
        local couponbox = createCouponBox(scroller, v.title, code)
        couponbox:DockMargin(0,margin,0,0)
        couponbox:SetZPos(v.index)
    end

    couponframe.OnRemove = function()
        close:Remove()
    end
end

sReward.openRewards = function(x, y)
    net.Start("sR:NetworkingHandeler")
    net.WriteUInt(0,3)
    net.WriteBool(true)
    net.SendToServer()

    sreward_menu = vgui.Create("SFrame")
    :SetSize(slib.getScaledSize(sReward.config["size"].w, "x"),slib.getScaledSize(sReward.config["size"].h, "y"))
    :setTitle(slib.getLang("sreward", sReward.config["language"], "main_title"))
    :Center()
    :addCloseButton()
    :MakePopup()

    sreward_menu.PaintOver = function(s,w,h)
        if s.nextThink and s.nextThink > CurTime() then return end

        s.nextThink = CurTime() + .5

        s.admin:SetVisible(sReward.HasPermission(LocalPlayer(), "sReward_AdminMenu"))
        if IsValid(s.topbar) then s.topbar:InvalidateLayout() end
    end

    if sReward.config["enabled_tabs"]["tasks"] then
        sreward_menu:addTab(slib.getLang("sreward", sReward.config["language"], "tasks"), "sreward/tabs/tasks.png")
    end

    if sReward.config["enabled_tabs"]["referral"] then
        sreward_menu:addTab(slib.getLang("sreward", sReward.config["language"], "referral"), "sreward/tabs/referral.png")
    end

    if sReward.config["enabled_tabs"]["shop"] then
        sreward_menu:addTab(slib.getLang("sreward", sReward.config["language"], "shop"), "sreward/tabs/shop.png")
    end

    if sReward.config["enabled_tabs"]["leaderboard"] then
        sreward_menu:addTab(slib.getLang("sreward", sReward.config["language"], "leaderboard"), "sreward/tabs/leaderboard.png")
    end

    sreward_menu:setActiveTab()
    
    if isnumber(x) and isnumber(y) then
        sreward_menu:SetPos(x,y)
    end

    sreward_menu.OnRemove = function()
        if sreward_menu.changing then return end
        net.Start("sR:NetworkingHandeler")
        net.WriteUInt(0,3)
        net.WriteBool(false)
        net.SendToServer()
    end

    local topbttnsize = sreward_menu.close:GetTall()
    local bttngap = sreward_menu.topbar:GetTall() - topbttnsize

    sreward_menu.topbar:DockPadding(0,0,topbttnsize * .85,0)

    local admin = vgui.Create("SButton", sreward_menu.topbar)
    admin:Dock(RIGHT)
    admin:DockMargin(-3, bttngap / 2, margin / 2, bttngap / 2)
    admin:SetWide(topbttnsize)
    admin:SetVisible(sReward.HasPermission(LocalPlayer(), "sReward_AdminMenu"))
    
    admin.DoClick = function()
        sreward_menu.changing = true
        sReward.openAdminmenu(sreward_menu)
    end

    admin.Paint = function(s,w,h)
        local icosize = h * .6
        local wantedCol = s:IsHovered() and white or hovercolor

        surface.SetDrawColor(slib.lerpColor(s, wantedCol))
        surface.SetMaterial(admin_ico)
        surface.DrawTexturedRect(w * .5 - icosize * .5, h * .5 - icosize * .5, icosize, icosize)
    end

    sreward_menu.admin = admin

    local coupons = vgui.Create("SButton", sreward_menu.topbar)
    coupons:Dock(RIGHT)
    coupons:DockMargin(0, bttngap / 2, margin / 2, bttngap / 2)
    coupons:SetWide(topbttnsize)
    
    coupons.DoClick = function()
        openCoupons()
    end

    coupons.Paint = function(s,w,h)
        local icosize = h * .7
        local wantedCol = s:IsHovered() and white or hovercolor

        surface.SetDrawColor(slib.lerpColor(s, wantedCol))
        surface.SetMaterial(coupon_ico)
        surface.DrawTexturedRect(w * .5 - icosize * .5, h * .5 - icosize * .5, icosize, icosize)
    end

    -- Referral tab
    if IsValid(sreward_menu.tab[slib.getLang("sreward", sReward.config["language"], "referral")]) then
        local gradient_d = surface.GetTextureID("vgui/gradient_down")
        local podium = vgui.Create("EditablePanel", sreward_menu.tab[slib.getLang("sreward", sReward.config["language"], "referral")])
        podium:Dock(FILL)
        podium:DockMargin(margin, margin, margin, margin)
        podium:SetTall(sreward_menu.tab[slib.getLang("sreward", sReward.config["language"], "referral")]:GetTall() * .69)
        podium.Paint = function(s,w,h)
            local data = sReward.data["referral_top3"]

            local first, second, third = data and data[1] and data[1].amount or 0, data and data[2] and data[2].amount or 0, data and data[3] and data[3].amount or 0

            surface.SetDrawColor(maincolor_7)
            surface.DrawRect(0,0,w,h)

            draw.SimpleText(slib.getLang("sreward", sReward.config["language"], "top_3"), slib.createFont("Roboto", 24), w * .5, margin, white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
            
            if first <= 0 then
                draw.SimpleText(slib.getLang("sreward", sReward.config["language"], "no_data"), slib.createFont("Roboto", 18), w * .5, h * .5, textcolor_min50, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
            return end

            local wide = w * .2
            local medal_size = wide * .3
            local max_h = h * .8
            local gap = w * .1
            local second_p, third_p = second / first, third / first

            surface.SetDrawColor(topcolors[2])
            surface.SetTexture(gradient_d)
            surface.DrawTexturedRect(w * .5 - wide * 1.5 - gap,h - max_h * second_p - 4,wide,max_h * second_p)
            surface.DrawOutlinedRect(w * .5 - wide * 1.5 - gap,h - max_h * second_p - 4,wide,max_h * second_p)

            surface.SetDrawColor(topcolors[1])
            surface.SetTexture(gradient_d)
            surface.DrawTexturedRect(w * .5 - wide * .5,h - max_h - 4,wide,max_h)
            surface.DrawOutlinedRect(w * .5 - wide * .5,h - max_h - 4,wide,max_h)

            surface.SetDrawColor(topcolors[3])
            surface.SetTexture(gradient_d)
            surface.DrawTexturedRect(w * .5 + wide * .5 + gap,h - max_h * third_p - 4,wide,max_h * third_p)
            surface.DrawOutlinedRect(w * .5 + wide * .5 + gap,h - max_h * third_p - 4,wide,max_h * third_p)

            local score_h = slib.getScaledSize(18, "y")

            draw.SimpleText(first, slib.createFont("Roboto", 19), w * .5, h - max_h - margin * 2, topcolors[1], TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM)
            draw.SimpleText(second, slib.createFont("Roboto", 19), w * .5 - wide - gap, h - max_h * second_p - margin * 2, topcolors[2], TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM)
            draw.SimpleText(third, slib.createFont("Roboto", 19), w * .5 + wide + gap, h - max_h * third_p - margin * 2, topcolors[3], TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM)

            
            draw.SimpleText(slib.findName(data[1].sid64), slib.createFont("Roboto", 19), w * .5, h - max_h - margin * 2 - score_h, white, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM)
            draw.SimpleText(data[2] and slib.findName(data[2].sid64) or "N/A", slib.createFont("Roboto", 19), w * .5 - wide - gap, h - max_h * second_p - margin * 2 - score_h, white, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM)
            draw.SimpleText(data[3] and slib.findName(data[3].sid64) or "N/A", slib.createFont("Roboto", 19), w * .5 + wide + gap, h - max_h * third_p - margin * 2 - score_h, white, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM)
        end

        local referral_info = vgui.Create("EditablePanel", sreward_menu.tab[slib.getLang("sreward", sReward.config["language"], "referral")])
        referral_info:SetTall(slib.getScaledSize(92, "y"))
        referral_info:Dock(BOTTOM)

        local rewardbttn_h = referral_info:GetTall() * .6

        local box_w = (sreward_menu.tab[slib.getLang("sreward", sReward.config["language"], "referral")]:GetWide() - margin * 2) * .5

        local referral_rewards = vgui.Create("EditablePanel", referral_info)
        referral_rewards:Dock(LEFT)
        referral_rewards:DockMargin(margin,0,margin * .5,margin)
        referral_rewards:DockPadding(0,slib.getScaledSize(10, "y"), 0,0)
        referral_rewards:SetWide(box_w)
        referral_rewards.Paint = function(s,w,h)
            surface.SetDrawColor(maincolor_7)
            surface.DrawRect(0,0,w,h)

            draw.SimpleText(slib.getLang("sreward", sReward.config["language"], "rewards"), slib.createFont("Roboto", 19), w * .5, margin, white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
        end

        local rewardBtn_size = box_w * .3
        local width_left = box_w - (rewardBtn_size * 2)

        local referrer_reward = vgui.Create("SButton", referral_rewards)
        referrer_reward:Dock(LEFT)
        referrer_reward:DockMargin(width_left * .33, 0, width_left * .33,0)
        referrer_reward:SetWide(rewardBtn_size)
        referrer_reward.col = table.Copy(color_white)
        referrer_reward.Paint = function(s,w,h)
            local ico_size = h * .45
            s.col.a = slib.lerpNum(s, s:IsHovered() and 30 or 255)
            surface.SetDrawColor(s.col)
            surface.SetMaterial(foryou_ico)
            surface.DrawTexturedRect(w * .5 - ico_size * .5,h * .5 - ico_size * .5,ico_size,ico_size)

            draw.SimpleText(slib.getLang("sreward", sReward.config["language"], "you"), slib.createFont("Roboto", 16), w * .5, h - margin, white, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM)
        end

        referrer_reward.DoClick = function()
            checkRewards({name = slib.getLang("sreward", sReward.config["language"], "referral"),reward = sReward.config["give_referral_reward"]})
        end

        local referred_reward = vgui.Create("SButton", referral_rewards)
        referred_reward:Dock(LEFT)
        referred_reward:SetWide(rewardBtn_size)
        referred_reward.col = table.Copy(color_white)
        referred_reward.Paint = function(s,w,h)
            local ico_size = h * .45
            s.col.a = slib.lerpNum(s, s:IsHovered() and 30 or 255)
            surface.SetDrawColor(s.col)
            surface.SetMaterial(friend_ico)
            surface.DrawTexturedRect(w * .5 - ico_size * .5,h * .5 - ico_size * .5,ico_size,ico_size)

            draw.SimpleText(slib.getLang("sreward", sReward.config["language"], "friend"), slib.createFont("Roboto", 16), w * .5, h - margin, white, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM)
        end

        referred_reward.DoClick = function()
            checkRewards({name = slib.getLang("sreward", sReward.config["language"], "referral"),reward = sReward.config["receive_referral_reward"]})
        end

        local box_size = referral_info:GetTall() * .28

        local referral_font = slib.createFont("Roboto", 17)

        local referral_setting = vgui.Create("EditablePanel", referral_info)
        referral_setting:Dock(LEFT)
        referral_setting:DockMargin(margin * .5,0,0,margin)
        referral_setting:SetWide(box_w)

        local sid = LocalPlayer():SteamID()

        referral_setting.Paint = function(s,w,h)
            local icosize, gap = h * .28

            surface.SetDrawColor(maincolor_7)
            surface.DrawRect(0,0,w,h)

            local txt = (sReward.data[sid] and sReward.data[sid]["total_referrals"] or 0).." "..slib.getLang("sreward", sReward.config["language"], "referrals")

            surface.SetFont(referral_font)
            local txt_w = surface.GetTextSize(txt)

            surface.SetDrawColor(white)
            surface.SetMaterial(referral_ico)
            surface.DrawTexturedRect(w * .5 - icosize * .5 - txt_w * .5 - (margin * .5), margin, icosize, icosize)
        
            draw.SimpleText(txt, referral_font, w * .5 + icosize * .5 + (margin * .5), icosize * .5 + margin, white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        
            draw.SimpleText(slib.getLang("sreward", sReward.config["language"], "referr_with_code"), referral_font, w * .5, h - margin - box_size - margin, white, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM)
        end

        local referral_id = vgui.Create("STextEntry", referral_setting)
        referral_id:Dock(BOTTOM)
        referral_id:DockMargin(margin,0, margin, margin)
        referral_id:SetTall(box_size)
        referral_id:SetPlaceholder("SteamID64")
        referral_id.bg = maincolor_15

        local referr_id = vgui.Create("SButton", referral_id)
        referr_id:Dock(RIGHT)
        referr_id:SetWide(box_size)
        referr_id.col = table.Copy(color_white)
        referr_id.Paint = function(s,w,h)
            local ico_size = h * .5
            s.col.a = slib.lerpNum(s, s:IsHovered() and 255 or 30)

            surface.SetDrawColor(s.col)
            surface.SetMaterial(accept_ico)
            surface.DrawTexturedRect(w * .5 - ico_size * .5,h * .5 - ico_size * .5,ico_size,ico_size)
        end

        referr_id.DoClick = function()
            local sid64 = referral_id:GetText()
            if !sid64 or #sid64 ~= 17 or !isnumber(tonumber(sid64)) then slib.notify(sReward.config["prefix"]..slib.getLang("sreward", sReward.config["language"], "invalid_sid64")) return end
            if sid64 == LocalPlayer():SteamID64() then slib.notify(sReward.config["prefix"]..slib.getLang("sreward", sReward.config["language"], "cannot_referr_yourself")) return end

            net.Start("sR:NetworkingHandeler")
            net.WriteUInt(2,3)
            net.WriteString(sid64)
            net.SendToServer()
        end
    end

    if IsValid(sreward_menu.tab[slib.getLang("sreward", sReward.config["language"], "shop")]) then
        local shop_stats = vgui.Create("EditablePanel", sreward_menu.tab[slib.getLang("sreward", sReward.config["language"], "shop")])
        shop_stats:Dock(TOP)
        shop_stats:SetTall(slib.getScaledSize(25, "y"))
        shop_stats:SetWide(sreward_menu.tab[slib.getLang("sreward", sReward.config["language"], "shop")]:GetWide())
        shop_stats.Paint = function(s,w,h)
            local icosize, gap = h * .7, h * .15

            surface.SetDrawColor(maincolor_10)
            surface.DrawRect(0,0,w,h)

            surface.SetDrawColor(white)
            surface.SetMaterial(tokens_ico)
            surface.DrawTexturedRect(gap, gap, icosize, icosize)

            draw.SimpleText(string.Comma(sReward.GetTokens(LocalPlayer())).." "..slib.getLang("sreward", sReward.config["language"], "tokens"), slib.createFont("Roboto", 16), gap + icosize + margin, h * .5, white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
        end

        local shopcanvas = vgui.Create("SScrollPanel", sreward_menu.tab[slib.getLang("sreward", sReward.config["language"], "shop")])
        shopcanvas:Dock(FILL)
        local innercanvasshop = shopcanvas:GetCanvas()
        innercanvasshop:DockPadding(margin,0,margin,margin)

        local shop_search = vgui.Create("SSearchBar", shop_stats)
        shop_search:Dock(RIGHT)
        shop_search:SetWide(shop_stats:GetWide() * .5)
        shop_search:DockMargin(0,0,0,0)
        shop_search.bg = maincolor_15
        shop_search:addIcon()

        local store_canvas

        sreward_menu.rebuildStore = function(str)
            local addgap = margin * 1.33333333333
            local shopitem_wide = math.ceil((innercanvasshop:GetWide() / 3)) - addgap
            local shopitem_tall = shopitem_wide + slib.getScaledSize(31, "y")
            local fullwidth = shopitem_wide + margin

            store_canvas = innercanvasshop

            local iteration = 0
            local yiteration = 0
            for k,v in pairs(innercanvasshop:GetChildren()) do
                v:Remove()
            end

            local fulltbl = table.Copy(sReward.config["shop"])
            for k,v in SortedPairs(fulltbl) do fulltbl[k].id = k end
            for k,v in SortedPairs(sReward.data["shop"]) do if !istable(v) then continue end table.insert(fulltbl, v) end
            
            table.sort(fulltbl, function(a, b) return tonumber(a.price) > tonumber(b.price) end)

            for k,v in SortedPairs(fulltbl) do
                if str and !string.find(string.lower(v.name), string.lower(str)) or !v.enabled then continue end
                yiteration = iteration > 2 and yiteration + 1 or yiteration
                iteration = iteration > 2 and 0 or iteration

                local item = sReward.addStoreItem(innercanvasshop, v, yiteration, iteration)
                item.addButton(nil, reward_ico, function() checkRewards(item.data) end)
                item.addButton(nil, buy_ico, function()
                    local popup = vgui.Create("SPopupBox")
                    :setTitle(slib.getLang("sreward", sReward.config["language"], "are_you_sure"))
                    :setBlur(true)
                    :addChoise(slib.getLang("sreward", sReward.config["language"], "no"))
                    :addChoise(slib.getLang("sreward", sReward.config["language"], "yes"), function()
                        net.Start("sR:NetworkingHandeler")
                        net.WriteUInt(3,3)
                        net.WriteUInt(v.svid or v.id, 6)
                        net.WriteBool(tobool(v.svid))
                        net.SendToServer()
                    end)
                    :setText(slib.getLang("sreward", sReward.config["language"], "this_will_cost", item.data.name, item.data.price))
                end, true)

                item.InvalidateLayout()

                iteration = iteration + 1
            end
        end

        innercanvasshop.OnSizeChanged = function()
            local width = innercanvasshop:GetWide()
            if innercanvasshop.oldWide == width then return end
            innercanvasshop.oldWide = width

            if !IsValid(store_canvas) then return end
            for k,v in ipairs(store_canvas:GetChildren()) do
                v.InvalidateLayout()
            end  
        end

        sreward_menu.rebuildStore()

        shop_search.entry.onValueChange = function(newval)
            sreward_menu.rebuildStore(newval)
        end
    end

    if IsValid(sreward_menu.tab[slib.getLang("sreward", sReward.config["language"], "tasks")]) then
        local taskscanvas = vgui.Create("SScrollPanel", sreward_menu.tab[slib.getLang("sreward", sReward.config["language"], "tasks")])
        taskscanvas:Dock(FILL)
        taskscanvas:GetCanvas():DockPadding(margin,0,margin,margin)

        for k,v in ipairs(sReward.config["rewards"]) do
            if !v.enabled then continue end
            
            local data = sReward.config["rewards"][k]
            
            local task = sReward.addMultibox(taskscanvas, {
                [1] = {
                    title = slib.getLang("sreward", sReward.config["language"], "name"),
                    val = data.name,
                    offset = 0
                },
                [2] = {
                    title = slib.getLang("sreward", sReward.config["language"], "uses"),
                    val = function() return (!data.maxuse or data.maxuse <= 0 and "") or (sReward.data["rewards"][k] and sReward.data["rewards"][k].used or 0).."/"..data.maxuse end,
                    offset = 0.3
                },
                [3] = {
                    title = slib.getLang("sreward", sReward.config["language"], "task"),
                    val = "",
                    offset = 0.6
                }
            })

            local verify = task.addButton(slib.getLang("sreward", sReward.config["language"], "verify"), function()
                if data.maxuse and data.maxuse > 0 and (sReward.data["rewards"][k] and sReward.data["rewards"][k].used or 0) >= data.maxuse then
                    slib.notify(sReward.config["prefix"]..slib.getLang("sreward", sReward.config["language"], "max_use_reached"))
                return end 
                
                if data.cooldown and data.cooldown > 0 and os.time() < ((sReward.data["rewards"][k] and sReward.data["rewards"][k].cd or -data.cooldown) + data.cooldown) then
                    slib.notify(sReward.config["prefix"]..slib.getLang("sreward", sReward.config["language"], "on_cooldown", math.Round((sReward.data["rewards"][k].cd + data.cooldown) - os.time(), 1)))
                return end 
        
                net.Start("sR:NetworkingHandeler")
                net.WriteUInt(1,3)
                net.WriteUInt(k, 4)
                net.SendToServer()
            end)

            local nextThink
            verify.Think = function()
                if nextThink and nextThink > CurTime() then return end
        
                local title
        
                if data.cooldown and data.cooldown > 0 and os.time() < ((sReward.data["rewards"][k] and sReward.data["rewards"][k].cd or -data.cooldown) + data.cooldown) then
                    local timeleft = math.Round((sReward.data["rewards"][k].cd + data.cooldown) - os.time(), 1)
                    local hours = math.floor( timeleft / 3600 )
                    local minutes = math.floor( ( timeleft / 60 ) % 60 )
                    local seconds = math.floor( timeleft % 60 )
        
                    title = string.format("%2i:%02i:%02i", hours, minutes, seconds)
                end
        
                if data.maxuse and data.maxuse > 0 and (sReward.data["rewards"][k] and sReward.data["rewards"][k].used or 0) >= data.maxuse then
                    title = slib.getLang("sreward", sReward.config["language"], "used")
                end
                
                if title then
                    verify:SetMouseInputEnabled(!title)
                    verify:setTitle(title)
                end
        
                nextThink = CurTime() + 1
            end

            local gap = margin * 2.3

            local rewards = addIconButton(nil, reward_ico, function() checkRewards(data) end, task)
            rewards:Dock(RIGHT)
            rewards:DockMargin(gap, gap, margin, gap)

            local tasks = addIconButton(nil, task_ico, function()
                if !data.instructionFunc then return end
                data.instructionFunc()
            end, task)
            tasks:Dock(LEFT)
            tasks:DockMargin(task:GetWide() * .6 + margin, gap * 2, margin, 0)
            
            tasks.PaintOver = function(s,w,h)    
                if s:IsHovered() and !IsValid(s.tooltip) then
                    s.tooltip = slib.drawTooltip(data.instruction, s, 1)
                end
            end

            task.OnSizeChanged = function()
                tasks:DockMargin(task:GetWide() * .6 + margin, gap * 2, margin, 0)
            end
        end
    end

    if IsValid(sreward_menu.tab[slib.getLang("sreward", sReward.config["language"], "leaderboard")]) then
        local leaderboardcanvas = vgui.Create("SScrollPanel", sreward_menu.tab[slib.getLang("sreward", sReward.config["language"], "leaderboard")])
        leaderboardcanvas:Dock(FILL)
        leaderboardcanvas:GetCanvas():DockPadding(margin,0,margin,margin)

        sreward_menu.RebuildLeaderboard = function()
            for k,v in pairs(leaderboardcanvas:GetCanvas():GetChildren()) do
                v:Remove()
            end

            if sReward.data["leaderboard"] then
                for k,v in ipairs(sReward.data["leaderboard"]) do
                    local ply = sReward.addMultibox(leaderboardcanvas, {
                        [1] = {
                            title = slib.getLang("sreward", sReward.config["language"], "name"),
                            val = function() return slib.findName(v.sid64) end,
                            offset = 0
                        },
                        [2] = {
                            title = slib.getLang("sreward", sReward.config["language"], "total_tokens"),
                            val = v.tokens,
                            offset = 0.4
                        }
                    })

                    ply.PaintOver = function(s,w,h)
                        draw.SimpleText("#"..k, slib.createFont("Roboto", 18), w - margin, h * .5, topcolors[k] or textcolor_min50, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)
                    end
                end
            end
        end

        sreward_menu.RebuildLeaderboard()
    end
end

concommand.Add("sreward_menu", sReward.openRewards)

local intToString = {
    [1] = {id = "rewards", instructions = {["jsontable"] = true}},
    [2] = {id = "total_referrals", instructions = {["player"] = true, ["int"] = true, ["plydata"] = true}},
    [3] = {id = "leaderboard", instructions = {["jsontable"] = true}, func = function()
        if IsValid(sreward_menu) and sreward_menu.RebuildLeaderboard then
            sreward_menu.RebuildLeaderboard()
        end
    end},
    [4] = {id = "tokens", instructions = {["player"] = true, ["int"] = true, ["plydata"] = true}},
    [5] = {id = "coupons", instructions = {["jsontable"] = true}, func = function(data)
        for k,v in pairs(sReward.data["coupons"]) do
            if !istable(v) then continue end
            sReward.couponNameToKey[v.name] = k
        end

        if IsValid(sreward_admin) and sreward_admin.RebuildCoupons then
            sreward_admin.RebuildCoupons()
        end
    end},
    [6] = {id = "shop", instructions = {["jsontable"] = true}, func = function()
        if IsValid(sreward_admin) and sreward_admin.rebuildStore then
            sreward_admin.rebuildStore()
        end

        if IsValid(sreward_menu) and sreward_menu.rebuildStore then
            sreward_menu.rebuildStore()
        end
    end},
    [7] = {id = "referral_top3", instructions = {["jsontable"] = true}}
}

timer.Create("sR:AutoClaimReward", 3, 0, function()
    if !receivedNet then return end

    for k,v in ipairs(sReward.config["rewards"]) do
        local lply = LocalPlayer()

        if !v.enabled or !v.auto_claim or !IsValid(lply) then continue end

        local plyData = sReward.data["rewards"][k]

        if v.customCheck and !v.customCheck(lply) then continue end
        if v.maxuse and v.maxuse > 0 and (plyData and plyData.used or 0) >= v.maxuse then continue end
        if v.cooldown and v.cooldown > 0 and os.time() < ((plyData and plyData.cd or -data.cooldown) + data.cooldown) then continue end

        net.Start("sR:NetworkingHandeler")
        net.WriteUInt(1,3)
        net.WriteUInt(k, 4)
        net.SendToServer()
    end
end)

net.Receive("sR:NetworkingHandeler", function()
    local action = net.ReadUInt(2)

    if action == 1 then
        local type = net.ReadUInt(4)
        local str = intToString[type]
        if !str or !str.id then return end

        local val
        local structure = {str.id}

        if str.instructions then
            if str.instructions["key"] then
                structure[2] = net.ReadUInt(4)
            end
    
            if str.instructions["player"] then
                local ply = net.ReadUInt(16)
                if !ply then return end
                ply = Entity(ply)
    
                local sid = IsValid(ply) and ply:SteamID()
    
                if !sid then return end

                if str.instructions["plydata"] then
                    structure[1] = sid
                    structure[2] = str.id
                end
            end
    
            if str.instructions["jsontable"] then
                val = util.JSONToTable(net.ReadString())
            end
    
            if str.instructions["int"] then
                val = net.ReadUInt(32)
            end
        end

        local lastStep = sReward.data
        
        local tblCount = #structure
        for i=1, tblCount do
            local key = structure[i]
            local isEnd = i >= tblCount
            lastStep[key] = isEnd and val or lastStep[key] or {}

            lastStep = !isEnd and lastStep[key]
        end
    
        if isfunction(str.func) then
            str.func(val)
        end

        receivedNet = true
    elseif action == 2 then
        local data = net.ReadString()
        data = util.JSONToTable(data)

        receiveCoupon(data.title, data.code)
    end
end)
--PATH addons/[misc] sreward_1.6.31/lua/s_reward/core/sh_sreward.lua:
return gluapack()()
--PATH addons/[misc] sreward_1.6.31/lua/s_reward/languages/sh_english.lua:
if CLIENT then
    slib.setLang("sreward", "en", "general", "General")
    slib.setLang("sreward", "en", "tasks", "Tasks")
    slib.setLang("sreward", "en", "referral", "Referral")
    slib.setLang("sreward", "en", "shop", "Shop")
    slib.setLang("sreward", "en", "leaderboard", "Leaderboard")
    slib.setLang("sreward", "en", "coupons", "Coupons")

    slib.setLang("sreward", "en", "main_title", "sReward - Reward System")
    slib.setLang("sreward", "en", "title_admin", "sReward - Admin")

    slib.setLang("sreward", "en", "rewards_title", "%s - Rewards")
    slib.setLang("sreward", "en", "coupon_title", "Coupons")

    slib.setLang("sreward", "en", "coupon_receive_title", "New coupon!")
    slib.setLang("sreward", "en", "coupon_receive", "You have received a new coupon, \n    check your coupon inventory!") --- Had to fine tune like that :(

    slib.setLang("sreward", "en", "copied_clipboard", "Copied to clipboard!")
    slib.setLang("sreward", "en", "no_coupons", "You have no coupons!")
    slib.setLang("sreward", "en", "no_rewards", "There are no rewards!")

    slib.setLang("sreward", "en", "delete", "Delete")
    slib.setLang("sreward", "en", "yes", "Yes")
    slib.setLang("sreward", "en", "no", "No")

    slib.setLang("sreward", "en", "top_3", "Top 3")

    slib.setLang("sreward", "en", "you", "You")
    slib.setLang("sreward", "en", "friend", "Friend")

    slib.setLang("sreward", "en", "referr_with_code", "Referr with code")

    slib.setLang("sreward", "en", "are_you_sure", "Are you sure?")
    slib.setLang("sreward", "en", "manage", "Manage")

    slib.setLang("sreward", "en", "tokens", "Tokens")
    slib.setLang("sreward", "en", "select_reward", "Select Reward")
    slib.setLang("sreward", "en", "number", "Number")

    slib.setLang("sreward", "en", "submit", "Submit")
    slib.setLang("sreward", "en", "name", "Name")
    slib.setLang("sreward", "en", "uses", "Uses")
    slib.setLang("sreward", "en", "used", "Used")
    slib.setLang("sreward", "en", "task", "Task")
    slib.setLang("sreward", "en", "verify", "Verify")
    slib.setLang("sreward", "en", "total_tokens", "Total Tokens")
    slib.setLang("sreward", "en", "referrals", "Referrals")

    slib.setLang("sreward", "en", "rewards", "Rewards")
    slib.setLang("sreward", "en", "price", "Price")
    slib.setLang("sreward", "en", "imgur_id", "Imgur ID")

    slib.setLang("sreward", "en", "edit_rewards", "Edit Rewards")
    slib.setLang("sreward", "en", "save", "Save")

    slib.setLang("sreward", "en", "insert_imgur_id", "Insert Imgur ID")
    slib.setLang("sreward", "en", "insert_name", "Insert Name")
    slib.setLang("sreward", "en", "insert_price", "Insert Price")

    slib.setLang("sreward", "en", "create_coupon", "Create Coupon")
    slib.setLang("sreward", "en", "coupon_name", "Coupon Name")

    slib.setLang("sreward", "en", "create_shopitem", "Create Shop Item")
    slib.setLang("sreward", "en", "item_name", "Item Name")

    slib.setLang("sreward", "en", "this_will_cost", "'%s' will cost you %s tokens!")
    slib.setLang("sreward", "en", "coupon_delete_confirm", "This will delete coupon '%s'?")
    slib.setLang("sreward", "en", "this_delete", "This will delete '%s'")
    slib.setLang("sreward", "en", "no_data", "No data")

    slib.setLang("sreward", "en", "manage_item", "Manage Item")

    slib.setLang("sreward", "en", "discord_failed_application_com", "We failed communicating with your discord application, make sure it is running!")
    slib.setLang("sreward", "en", "discord_error_retrieving_data", "We encountered an issue while retrieving data from discord, please inform staff about this!")
    slib.setLang("sreward", "en", "discord_failed_application_com_web", "We failed communicating with your discord application, fallback to web based verification!")
else
    slib.setLang("sreward", "en", "cooldown", "You are on a verification cooldown, please wait %s seconds!")

    slib.setLang("sreward", "en", "added_queue", "You have been added to the queue for '%s' checkup, you will receive a response within %s seconds!")

    slib.setLang("sreward", "en", "added_steamgroup_queue", "You have been added to the queue for steamgroup check, you will receive a response within %s seconds!")
    slib.setLang("sreward", "en", "didnt_find_steamgroup", "We could not find you in the steamgroup, please try again!")
    slib.setLang("sreward", "en", "failed_verification", "Looks like we failed to verify reward '%s', make sure to complete the task properly.")
    slib.setLang("sreward", "en", "discord_verification_cooldown", "You are on a verification cooldown, please wait until the other request has completed!")
    
    slib.setLang("sreward", "en", "discord_claimed_by_others", "This discord account has been used by another steam account to claim a discord reward!")
    slib.setLang("sreward", "en", "discord_error_retrieving_data", "We were unsuccessfull in contacting discord, please try again later!")
    slib.setLang("sreward", "en", "checking_wait", "Please wait while we verify reward '%s' for you!")

    slib.setLang("sreward", "en", "steam_unsuccessfull", "We were unsuccessfull in contacting steam, please try again later!")
    slib.setLang("sreward", "en", "steam_private", "We failed checking your steam groups, make sure that your profile is public so we can check!")
    slib.setLang("sreward", "en", "success_reward", "You have received the '%s' reward!")

    slib.setLang("sreward", "en", "already_referred", "You have already referred this person!")
    slib.setLang("sreward", "en", "referral_limit", "You have reached the max referral limit!")
    slib.setLang("sreward", "en", "referred_person", "You have received a reward for setting %s as your referee!")
    slib.setLang("sreward", "en", "referred_by", "You have received a reward for referring %s!")
    slib.setLang("sreward", "en", "referring_person", "You have received a reward for referring a person!")
    slib.setLang("sreward", "en", "cannot_referr_again", "You cannot referr this person again!")
    slib.setLang("sreward", "en", "raferring_ratelimit", "You have been ratelimited, wait for your first referral request to finish!")

    slib.setLang("sreward", "en", "mysql_successfull", "We have successfully connected to the database!")
    slib.setLang("sreward", "en", "mysql_failed", "We have failed connecting to the database!")
    
    slib.setLang("sreward", "en", "discord_webserver_failed", "We failed communicating with the discord webserver, please try again later!")
    slib.setLang("sreward", "en", "discord_webserver_started", "A verification link has been generated, authorize the application to verify your discord!")

    slib.setLang("sreward", "en", "cannot_afford", "You cannot afford this!")
    slib.setLang("sreward", "en", "successfull_purchase", "You have succesfully purchased '%s'!")

    slib.setLang("sreward", "en", "taken_tokens", "Someone has taken %s tokens from you, Your new balance is %s!")
    slib.setLang("sreward", "en", "given_tokens", "Someone has given %s tokens to you, Your new balance is %s!")
    slib.setLang("sreward", "en", "given_reward", "Someone has given you the reward '%s'!")
    slib.setLang("sreward", "en", "you_got_tokens", "You have received %s tokens, Your new balance is %s!")

    slib.setLang("sreward", "en", "performed_admin_action", "You have performed admin action towards '%s' with value of '%s'")
    slib.setLang("sreward", "en", "coupon_out_of_stock", "We are currently out of stock for '%s' coupons, please contact higher ups so we can restock!")
end

slib.setLang("sreward", "en", "on_cooldown", "You are on a cooldown wait %s seconds to use this reward again!")

slib.setLang("sreward", "en", "max_use_reached", "You have reached the max use limit of this reward!")

slib.setLang("sreward", "en", "sr_tokens", "sR Tokens")

slib.setLang("sreward", "en", "darkrp_money", "DarkRP Money")

slib.setLang("sreward", "en", "reward_rank", "Rank")

slib.setLang("sreward", "en", "coupon", "Coupon")

slib.setLang("sreward", "en", "give_weapon", "Give Weapon")

slib.setLang("sreward", "en", "basewars_money", "Basewars Money")
slib.setLang("sreward", "en", "basewars_level", "Basewars Level")

slib.setLang("sreward", "en", "vrondakis_level", "Level")
slib.setLang("sreward", "en", "vrondakis_xp", "XP")

slib.setLang("sreward", "en", "glorified_level", "Level")
slib.setLang("sreward", "en", "glorified_xp", "XP")

slib.setLang("sreward", "en", "essentials_level", "Level")
slib.setLang("sreward", "en", "essentials_xp", "XP")

slib.setLang("sreward", "en", "elite_xp", "XP")
slib.setLang("sreward", "en", "elevel_xp", "XP")

slib.setLang("sreward", "en", "elevel_xp", "XP")

slib.setLang("sreward", "en", "wos_level", "wOS Level")
slib.setLang("sreward", "en", "wos_xp", "wOS XP")
slib.setLang("sreward", "en", "wos_points", "wOS Points")
slib.setLang("sreward", "en", "wos_giveitem", "wOS Give item")

slib.setLang("sreward", "en", "zpn_candy", "ZPN Candy")

slib.setLang("sreward", "en", "voidcases_giveitem", "VoidCases Item")

slib.setLang("sreward", "en", "ps1_points", "PS1 Points")

slib.setLang("sreward", "en", "ps2_standard_points", "PS2 Standard Points")
slib.setLang("sreward", "en", "ps2_premium_points", "PS2 Premium Points")

slib.setLang("sreward", "en", "sh_ps_standard_points", "SH PS Standard Points")
slib.setLang("sreward", "en", "sh_ps_premium_points", "SH PS Premium Points")

slib.setLang("sreward", "en", "give_tokens", "Give Tokens")
slib.setLang("sreward", "en", "give_reward", "Give Reward")
slib.setLang("sreward", "en", "take_tokens", "Take Tokens")

slib.setLang("sreward", "en", "invalid_sid64", "Invalid SteamID64")
slib.setLang("sreward", "en", "cannot_referr_yourself", "You cannot referr yourself!")
--PATH addons/[misc] sreward_1.6.31/lua/s_reward/rewards/sh_elitexpsystem.lua:
sReward.RegisterReward("elite_xp", function(ply, xp)
    if !isfunction(EliteXP.CheckXP) then return end
    EliteXP.CheckXP(ply, xp)
end)

------ ADD BADGE? 76561198196280105
--PATH addons/[misc] sreward_1.6.31/lua/s_reward/rewards/sh_perp.lua:
sReward.RegisterReward("perp_cash", function(ply, amount)
    if !isfunction(ply.AddCash) then return end
    ply:AddCash(amount)
end, Material("sreward/money.png", "smooth"))
--PATH addons/[misc] sreward_1.6.31/lua/s_reward/rewards/sh_tokens.lua:
sReward.RegisterReward("sr_tokens", function(ply, tokens)
    sReward.GiveTokens(ply, tokens)
end, Material("sreward/tokens.png", "smooth"))

--76561198196280112
--PATH lua/autorun/streamradio_loader.lua:
-- 3D Stream Radio. Made By Grocel.
AddCSLuaFile()

local g_addonBrokenError = nil

if SERVER then
	g_addonBrokenError = "Addon loadup is broken on SERVER! To many addons?"
else
	g_addonBrokenError = "Addon loadup is broken on CLIENT! To many addons?"
end

local function initStreamRadioLibGlobal()
	_G.StreamRadioLib = _G.StreamRadioLib or {}
	local lib = _G.StreamRadioLib

	table.Empty(lib)

	lib.Loaded = nil
	lib.Errors = {g_addonBrokenError}

	-- this is the failback content for tools and menus
	lib.Loader_CreateErrorPanel = function(CPanel, message)
		if not IsValid(CPanel) then
			return
		end

		local lib = _G.StreamRadioLib or {}
		if lib.Loaded then
			return
		end

		local addonPrefix = tostring(lib.AddonPrefix or "")
		addonPrefix = string.Trim(addonPrefix)

		if addonPrefix ~= "" then
			local prefixlabel = vgui.Create("DLabel")

			prefixlabel:SetDark(true)
			prefixlabel:SetHighlight(false)
			prefixlabel:SetWrap(true)
			prefixlabel:SetText(addonPrefix)

			prefixlabel:SetAutoStretchVertical(true)
			prefixlabel:SizeToContents()

			CPanel:AddPanel(prefixlabel)
		end

		local errors = lib.Errors or {}

		for i, thiserr in ipairs(errors) do
			thiserr = tostring(thiserr or "")
			thiserr = string.Trim(thiserr)

			if thiserr == "" then
				continue
			end

			local errorlabel = vgui.Create("DLabel")

			errorlabel:SetDark(false)
			errorlabel:SetHighlight(true)
			errorlabel:SetWrap(true)
			errorlabel:SetText(i .. ". " .. thiserr)
			errorlabel:SetTooltip(thiserr)

			errorlabel:SetAutoStretchVertical(true)
			errorlabel:SizeToContents()

			CPanel:AddPanel(errorlabel)
		end

		message = tostring(message or "")
		message = string.Trim(message)

		if message ~= "" then
			local messagelabel = vgui.Create("DLabel")

			messagelabel:SetDark(false)
			messagelabel:SetHighlight(true)
			messagelabel:SetWrap(true)
			messagelabel:SetText(message)
			messagelabel:SetTooltip(message)

			messagelabel:SetAutoStretchVertical(true)
			messagelabel:SizeToContents()

			CPanel:AddPanel(messagelabel)
		end
	end

	-- this is the failback error message for radio entity spawn
	lib.Loader_ShowSpawnError = function(message)
		local lib = _G.StreamRadioLib or {}
		if lib.Loaded then
			return
		end

		local addonPrefix = tostring(lib.AddonPrefix or "")
		addonPrefix = string.Trim(addonPrefix)

		local errors = lib.Errors or {}

		local errorString = table.concat(errors, "\n\n")
		errorString = string.Trim(errorString)

		message = tostring(message or "")
		message = string.Trim(message)

		local err = string.format("%s\n\n%s\n\n%s", addonPrefix, errorString, message)

		ErrorNoHaltWithStack(err)
	end
end

do
	initStreamRadioLibGlobal()

	local status, loaded = xpcall(function()
		AddCSLuaFile("streamradio_core/_load.lua")
		return include("streamradio_core/_load.lua")
	end, ErrorNoHaltWithStack)

	if not _G.StreamRadioLib then
		initStreamRadioLibGlobal()
	end

	if not status then
		_G.StreamRadioLib.Loaded = nil
	end

	if not loaded then
		_G.StreamRadioLib.Loaded = nil
	end

	local errors = _G.StreamRadioLib.Errors or {}

	local errorString = tostring(errors[1] or "")
	errorString = string.Trim(errorString)

	if errorString ~= "" then
		_G.StreamRadioLib.Loaded = nil
	end

	if errorString == g_addonBrokenError then
		-- something went horribly wrong, so tell the user about it.

		error(g_addonBrokenError)
		return
	end
end

--PATH lua/streamradio_core/_load.lua:
-- 3D Stream Radio. Made By Grocel.

local LIB = StreamRadioLib
if not LIB then
	return
end

LIB.Loaded = nil
LIB.Errors = {}

local function getVersion()
	local versiondata = file.Read("data_static/streamradio/version.txt", "GAME") or ""
	versiondata = string.Explode("[\r\n|\r|\n]", versiondata, true) or {}

	local Version = string.Trim(tostring(versiondata[1] or ""))
	local VersionTime = tonumber(string.Trim(versiondata[2] or "")) or -1

	if Version == "" then
		Version = "UNKNOWN"
	end

	return Version, VersionTime
end

local g_version, g_versionTime = getVersion()

local AddonTitle = ( "3D Stream Radio (ver. " .. g_version .. ")" )
local AddonPrefix = ( AddonTitle .. ":\n" )

LIB.AddonTitle = AddonTitle
LIB.AddonPrefix = AddonPrefix

function LIB.GetVersion()
	return g_version
end

function LIB.GetVersionTime()
	return g_versionTime
end

local g_loader_ok = true

local g_loaded_cs = {}
local g_loaded_lua = {}
local g_exists_lua = {}
local g_errors = {}
local g_maxErrors = 32

local function appendError(err)
	local liberrors = LIB.Errors
	if not liberrors then
		return
	end

	err = tostring(err or "")
	err = string.Trim(err or "")
	if err == "" then
		return
	end

	if g_errors[err] then
		return
	end

	local count = #liberrors

	if count >= g_maxErrors then
		return
	end

	table.insert(liberrors, err)
	g_errors[err] = true
end

local function throwError(err)
	err = tostring(err or "")
	err = string.Trim(err or "")
	if err == "" then
		return
	end

	local addonPrefix = LIB.AddonPrefix or ""

	appendError(err)

	g_loader_ok = false
	LIB.Loaded = nil

	ErrorNoHaltWithStack(addonPrefix .. err .. "\n")
end

local function registerErrorFeedbackHook()
	if SERVER then
		util.AddNetworkString("3DStreamRadio_LoadError")

		hook.Add("PlayerInitialSpawn", "3DStreamRadio_LoadError", function(ply)
			if not IsValid(ply) then
				return
			end

			if LIB.Loaded then
				return
			end

			local errors = LIB.Errors or {}
			if table.IsEmpty(errors) then
				return
			end

			local count = #errors

			net.Start("3DStreamRadio_LoadError")
				net.WriteUInt(count, 8)

				for i, err in ipairs(errors) do
					net.WriteString(err)
				end
			net.Send(ply)
		end)
	else
		net.Receive("3DStreamRadio_LoadError", function()
			local count = net.ReadUInt(8)

			for i = 1, count do
				local err = net.ReadString()
				appendError(err)
			end
		end)
	end
end

local function luaExists(lua)
	lua = tostring(lua or "")
	lua = string.lower(lua or "")

	if lua == "" then
		return false
	end

	if g_exists_lua[lua] ~= nil then
		return g_exists_lua[lua] or false
	end

	local exists = file.Exists(lua, "LUA")

	if not exists then
		g_exists_lua[lua] = false
		return false
	end

	g_exists_lua[lua] = true
	return true
end

local function saveCSLuaFile(lua, force)
	lua = tostring(lua or "")
	lua = string.lower(lua or "")

	if lua == "" then
		return false
	end

	if force then
		g_loaded_cs[lua] = nil
	end

	if g_loaded_cs[lua] ~= nil then
		return g_loaded_cs[lua] or false
	end

	local status = xpcall(function()
		if CLIENT then
			return
		end

		if not luaExists(lua) then
			error("Couldn't AddCSLuaFile file '" .. lua .. "' (File not found)")
		end

		AddCSLuaFile(lua)
	end, throwError)

	if not status then
		g_loaded_cs[lua] = false
		return false
	end

	g_loaded_cs[lua] = true
	return true
end

local function saveInclude(lua, force)
	lua = tostring(lua or "")
	lua = string.lower(lua or "")

	if lua == "" then
		return nil
	end

	if force then
		g_loaded_lua[lua] = nil
	end

	if g_loaded_lua[lua] then
		-- Prevent loading twice
		return true, g_loaded_lua[lua]
	end

	local status, result = xpcall(function()
		if SERVER then
			-- Too slow on clientside on some servers
			-- See: https://github.com/Facepunch/garrysmod-issues/issues/5674

			if not luaExists(lua) then
				error("Couldn't include file '" .. lua .. "' (File not found)")
				return nil
			end
		end

		local r = include(lua)

		if not r then
			error("Couldn't include file '" .. lua .. "' (Error during execution or file not found)")
			return nil
		end

		return r
	end, throwError)

	if not status then
		g_loaded_lua[lua] = nil
		return nil
	end

	g_loaded_lua[lua] = result
	return status, result
end

function LIB.SaveCSLuaFile(lua, force)
	return saveCSLuaFile(lua, force)
end

function LIB.LoadSH(lua, force)
	if not saveCSLuaFile(lua) then return end
	return saveInclude(lua, force)
end

function LIB.LoadCL(lua, force)
	if SERVER then
		return saveCSLuaFile(lua)
	end

	return saveInclude(lua, force)
end

function LIB.LoadSV(lua, force)
	if CLIENT then return true end
	return saveInclude(lua, force)
end

local g_loadTime = 0

local function loadAddon()
	local loadStartTime = SysTime()

	local VERSION = VERSION or 0
	local versionError = nil

	if VERSION > 5 then
		-- Sometimes the version is not known, yet.

		if CLIENT then
			local NEED_VERSION = 241029

			if VERSION < NEED_VERSION then
				versionError = string.format("Your GMod-Client (version: %s) is too old!\nPlease update the GMod-Client to version %s or newer!", VERSION, NEED_VERSION)
			end
		else
			local NEED_VERSION = 241029

			if VERSION < NEED_VERSION then
				versionError = string.format("The GMod-Server (version: %s) is too old!\nPlease update the GMod-Server to version %s or newer!\nTell an Admin!", VERSION, NEED_VERSION)
			end
		end
	end

	if versionError then
		throwError(versionError)
	else
		LIB.Loaded = true
		LIB.Loading = true

		local status, loaded = LIB.LoadSH("streamradio_core/_include.lua")

		if not status then
			g_loader_ok = false
		end

		if not loaded then
			g_loader_ok = false
		end
	end

	if not g_loader_ok then
		LIB.Loaded = nil
	end

	LIB.Loading = nil

	g_loadTime = SysTime() - loadStartTime
end

local g_colDefault = Color(255, 255, 255)
local g_colError = Color(255, 128, 128)
local g_colOk = Color(100, 200, 100)
local g_colCL = Color(255, 222, 137)
local g_colSV = Color(137, 222, 255)

local function printAddon()
	local errors = LIB.Errors
	if not errors then
		return
	end

	local realmname = "CLIENT"
	local realmcol = g_colCL
	if SERVER then
		realmname = "SERVER"
		realmcol = g_colSV
	end

	local loadTimeString = string.format("Took %0.3f sec.", g_loadTime)
	local border = "##########################################################################################"

	MsgN()
	MsgN()
	MsgC(realmcol, border)
	MsgN()
	MsgN()

	MsgC(g_colDefault, "    ", LIB.AddonTitle, " ")

	if not LIB.Loaded then
		if table.IsEmpty(errors) then
			appendError(string.format("Error loading addon on the %s!", realmname))
		end

		MsgC(g_colError, "could not be loaded on the " .. realmname .. ". " .. loadTimeString)
		MsgN()
		MsgN()

		MsgC(realmcol, border)
		MsgN()
		MsgN()

		MsgC(g_colError, "Errors:")
		MsgN()

		for i, thiserr in ipairs(errors) do
			thiserr = tostring(thiserr or "")
			thiserr = string.Trim(thiserr)

			if thiserr == "" then
				continue
			end

			MsgC(g_colDefault, i .. ": ", g_colError, thiserr)
			MsgN()
		end
	else
		MsgC(g_colOk, "is loaded on the " .. realmname .. ". " .. loadTimeString)
		MsgN()
	end

	MsgN()
	MsgC(realmcol, border)
	MsgN()
	MsgN()
end

loadAddon()
printAddon()
registerErrorFeedbackHook()

return LIB.Loaded

--PATH lua/streamradio_core/bass3.lua:
return gluapack()()
--PATH lua/streamradio_core/http.lua:
local StreamRadioLib = StreamRadioLib

StreamRadioLib.Http = StreamRadioLib.Http or {}

local LIB = StreamRadioLib.Http
table.Empty(LIB)

local g_emptyFunction = function() end
local g_request_quene = {}

local function callcallbacks(rq, ...)
	if not rq then return end

	if not rq.quene then return end
	if not rq.started then return end

	local tmp = rq.quene

	rq.quene = nil
	rq.started = nil

	for i, func in ipairs(tmp) do
		if not isfunction(func) then continue end
		func(...)
	end
end

local function cleanDoneQuene()
	for k, rq in pairs(g_request_quene) do
		if not rq.quene then
			g_request_quene[k] = nil
			continue
		end

		if not rq.started then
			g_request_quene[k] = nil
			continue
		end
	end
end

local function request(url, callback, parameters, method, headers, body, type)
	url = url or ""
	url = StreamRadioLib.Url.SanitizeUrl(url)

	callback = callback or g_emptyFunction
	parameters = parameters or {}
	method = method or ""

	if method == "" then
		method = "GET"
	end

	local requestdata = {
		url = url,
		method = method,
		parameters = parameters,
		headers = headers,
		body = body,
		type = type,
	}

	local requestname = StreamRadioLib.JSON.Encode(requestdata)
	requestname = StreamRadioLib.Util.Hash(requestdata)

	local rq = g_request_quene[requestname] or {}
	g_request_quene[requestname] = rq

	rq.quene = rq.quene or {}
	table.insert(rq.quene, callback)

	if rq.started then
		return
	end

	local failed = false

	requestdata.failed = function(err)
		callcallbacks(rq, false, {
			err = err or "",
			code = -1,
			body = "",
			len = 0,
			headers = {},

			requestdata = {
				url = requestdata.url,
				method = requestdata.method,
				parameters = requestdata.parameters,
				headers = requestdata.headers,
				body = requestdata.body,
				type = requestdata.type,
			},
		})

		cleanDoneQuene()
		failed = true
	end

	requestdata.success = function(code, body, headers)
		code = code or -1
		body = body or ""

		local success = true

		if code < 0 then
			success = false
		end

		if code >= 400 then
			success = false
		end

		callcallbacks(rq, success, {
			code = code or -1,
			body = body,
			len = #body,
			headers = headers or {},

			requestdata = {
				url = requestdata.url,
				method = requestdata.method,
				parameters = requestdata.parameters,
				headers = requestdata.headers,
				body = requestdata.body,
				type = requestdata.type,
			},
		})

		cleanDoneQuene()
		failed = false
	end

	rq.started = true

	local success = HTTP(requestdata)

	if not success and not failed then
		requestdata.failed("HTTP failed")
	end
end

function LIB.RequestRaw(url, callback, body, method, headers, type)
	type = type or ""

	if type == "" then
		type = "text/plain; charset=utf-8"
	end

	request(url, callback, nil, method, headers, body, type)
end

function LIB.Request(url, callback, parameters, method, headers)
	request(url, callback, parameters, method, headers)
end

function LIB.RequestRawHeader(url, callback, body, headers, type)
	callback = callback or g_emptyFunction

	LIB.RequestRaw(url, function(success, data)
		data.body = nil
		callback(success, data)
	end, "HEAD", body, headers, type)
end

function LIB.RequestHeader(url, callback, parameters, headers)
	callback = callback or g_emptyFunction

	LIB.Request(url, function(success, data)
		data.body = nil
		callback(success, data)
	end, "HEAD", parameters, headers)
end

return true


--PATH lua/streamradio_core/models.lua:
local StreamRadioLib = StreamRadioLib

StreamRadioLib.Model = StreamRadioLib.Model or {}

local LIB = StreamRadioLib.Model
table.Empty(LIB)

local Models = {}

local LuaModelDirectory = "streamradio_core/models"

local function AddCommonFunctions()
	if not RADIOMDL then return end

	RADIOMDL.DISPLAY_POS_TOP = 1;
	RADIOMDL.DISPLAY_POS_RIGHT = 2;
	RADIOMDL.DISPLAY_POS_FRONT = 3;

	function RADIOMDL:GetDisplaySize(vecTL, vecBR, displayPosMode)
		displayPosMode = displayPosMode or self.DISPLAY_POS_FRONT

		local def = vecTL - vecBR

		local x = 0
		local y = 0

		if displayPosMode == self.DISPLAY_POS_TOP then
			x = math.abs(def.y)
			y = math.abs(def.x)
		elseif displayPosMode == self.DISPLAY_POS_RIGHT then
			x = math.abs(def.x)
			y = math.abs(def.z)
		elseif displayPosMode == self.DISPLAY_POS_FRONT then
			x = math.abs(def.y)
			y = math.abs(def.z)
		end

		return x, y
	end

	function RADIOMDL:GetDisplayHeight(vecTL, vecBR, w, displayPosMode)
		local dx, dy = self:GetDisplaySize(vecTL, vecBR, displayPosMode)
		local h = w * (dy / dx)

		return h, dx / w
	end

	function RADIOMDL:GetDisplayWidth(vecTL, vecBR, h, displayPosMode)
		local dx, dy = self:GetDisplaySize(vecTL, vecBR, displayPosMode)
		local w = h * (dx / dy)

		return w, dy / h
	end

	function RADIOMDL:InitializeFonts(ent, model)
		if not CLIENT then return end
		if not self.FontSizes then return end

		self.Fonts = {}

		for name, values in pairs(self.FontSizes) do
			self.Fonts[name] = StreamRadioLib.Surface.AddFont(values[1], values[2], values[3], values[4])
		end
	end
end

local function AddModel(script)
	script = script or ""
	if script == "" then return false end

	-- Special model scripts are handled differently
	if script[1] == "_" then return false end

	local scriptfile = LuaModelDirectory .. "/" .. script

	RADIOMDL = nil
	RADIOMDL = {}

	AddCommonFunctions()

	local loaded = StreamRadioLib.LoadSH(scriptfile, true)

	local modelname = string.lower(string.Trim(RADIOMDL.model or ""))

	if modelname == "" then
		RADIOMDL = nil
		return false
	end

	Models[modelname] = RADIOMDL
	RADIOMDL = nil

	return loaded
end

local function AddMultiModels(script, modellist)
	script = script or ""
	modellist = modellist or {}

	if ( script == "" ) then return false end

	-- Special model scripts are handled here
	if ( script[1] ~= "_" ) then return false end

	local scriptfile = LuaModelDirectory .. "/" .. script

	StreamRadioLib.SaveCSLuaFile(scriptfile, true)

	RADIOMDL = nil
	for _, modelname in ipairs( modellist ) do
		modelname = string.lower( string.Trim( modelname or "" ) )

		if modelname == "" then
			RADIOMDL = nil
			continue
		end

		RADIOMDL = nil
		RADIOMDL = {}
		RADIOMDL.modelname = modelname

		local loaded = StreamRadioLib.LoadSH(scriptfile, true)

		if not loaded then
			RADIOMDL = nil
			continue
		end

		modelname = string.lower( string.Trim( RADIOMDL.modelname or "" ) )
		if modelname == "" then
			RADIOMDL = nil
			continue
		end

		Models[modelname] = RADIOMDL
		RADIOMDL = nil
	end

	return true
end

function LIB.LoadModelSettings()
	local files = file.Find( LuaModelDirectory .. "/*", "LUA" )
	Models = {}

	for _, f in ipairs( files or {} ) do
		AddModel(f)
	end

	local nm_modelpath = "models/nickmaps/speakers"
	local nm_speakers = file.Find( nm_modelpath .. "/*.mdl", "GAME" )

	for index, modelname in ipairs( nm_speakers ) do
		nm_speakers[index] = nm_modelpath .. "/" .. modelname
	end

	AddMultiModels( "_nm_speakers.lua", nm_speakers )

	for index, ent in pairs(StreamRadioLib.SpawnedRadios or {}) do
		if not IsValid(ent) then continue end
		ent:SetUpModel()
	end
end

function LIB.GetModelSettings(model, setting)
	if not model then return end
	local modeldata = Models[model] or Models["default"] or {}
	if not setting then return table.Copy(modeldata) end

	return table.Copy(modeldata[setting] or {})
end

function LIB.RegisteredModels( )
	local ToolModels = {}

	for model, setting in pairs(Models) do
		if model == "default" then continue end
		if not StreamRadioLib.Util.IsValidModelFile(model) then continue end
		if setting.HiddenInTool then continue end

		ToolModels[model] = setting.tool or {}
	end

	return ToolModels
end

LIB.LoadModelSettings( )

return true


--PATH lua/streamradio_core/models/csgo_italy_radio.lua:
return gluapack()()
--PATH lua/streamradio_core/models/portal_speaker_big.lua:
local RADIOMDL = RADIOMDL
if not istable( RADIOMDL ) then
	StreamRadioLib.Model.LoadModelSettings()
	return
end

-- Portal 2 Old Speaker, Big
RADIOMDL.model = "models/props_underground/old_speaker_big.mdl"

RADIOMDL.NoDisplay = true
RADIOMDL.SpawnAng = Angle( -90, 0, 0 )
RADIOMDL.SpawnFlatOnWall = false
RADIOMDL.SpawnAtOrigin = true
RADIOMDL.SoundPosOffset = Vector( 35.5, 1.40, 5.2 )
RADIOMDL.SoundAngOffset = Angle( 22.5, 0, 0 )

return true


--PATH lua/streamradio_core/models/sw_gramophone.lua:
local RADIOMDL = RADIOMDL
if not istable( RADIOMDL ) then
	StreamRadioLib.Model.LoadModelSettings()
	return
end

-- SligWolf's Gramophone
RADIOMDL.model = "models/sligwolf/grocel/radio/gramophone.mdl"

RADIOMDL.SpawnAng = Angle(0, 0, 0)
RADIOMDL.SpawnFlatOnWall = false
RADIOMDL.SoundPosOffset = Vector(-8, 0, 13.5)
RADIOMDL.SoundAngOffset = Angle(-10, 0, 0)

RADIOMDL.DisplayAngles = Angle(0, 90, 90)

                              --      F,     R,    U
RADIOMDL.DisplayOffset    = Vector(6.35, -5.85, 6.15) -- Top Left
RADIOMDL.DisplayOffsetEnd = Vector(6.35,  5.85, 2.35) -- Bottom Right

RADIOMDL.DisplayWidth = 1024
RADIOMDL.DisplayHeight, RADIOMDL.DisplayScale = RADIOMDL:GetDisplayHeight(RADIOMDL.DisplayOffset, RADIOMDL.DisplayOffsetEnd, RADIOMDL.DisplayWidth)


RADIOMDL.FontSizes = {
--  Name 	= Size,	Weight, Parentname
	Header	= {23,	1000},
	Default	= {25,	700},
	Tooltip	= {22,	1000},
	Big		= {30,	700},
}

function RADIOMDL:SetupGUI(ent, gui_controller, mainpanel)
	gui_controller:SetPos(0, 0)
	gui_controller:SetSize(self.DisplayWidth, self.DisplayHeight)

	mainpanel:SetSize(gui_controller:GetClientSize())

	local modelsetup = {}
	if CLIENT then
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/header/text", "font", self.Fonts.Header)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/header/pretext", "font", self.Fonts.Header)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "font", self.Fonts.Default)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "font", self.Fonts.Default)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/header", "font", self.Fonts.Header)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/controls/progressbar/label", "font", self.Fonts.Default)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/button", "font", self.Fonts.Default)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/volume/progressbar/label", "font", self.Fonts.Default)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/textbox", "font", self.Fonts.Default)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/button", "font", self.Fonts.Default)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/textbox", "font", self.Fonts.Default)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/button", "font", self.Fonts.Default)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "tooltip", "font", self.Fonts.Tooltip)
	end

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/header", "sizeh", 40)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/header", "sizeh", 40)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists", "gridsize", {x = 2, y = 5})
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview", "gridsize", {x = 2, y = 5})
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/scrollbar", "sizew", 30)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/scrollbar", "sizew", 30)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/sidebutton", "sizew", 60)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/textbox/scrollbar", "sizew", 30)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/textbox/scrollbar", "sizew", 30)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/button", "sizeh", 50)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/button", "sizew", 40)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/button", "sizew", 40)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "", "cornersize", 0)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "", "borderwidth", 32)

	gui_controller:SetModelSetup(modelsetup)
end

RADIOMDL.Sounds = {
	Noise = "",
}

function RADIOMDL:Initialize(ent)
	if CLIENT then
		ent:InvalidateBoneCache()
		return
	end

	if ent._mdl_skinset then return end

	local spin = math.random( 0, 360 )
	ent:SetPoseParameter( "spin_speaker", spin )
	ent:RegisterDupePose( "spin_speaker" )

	local skinid = math.random( 0, 3 )
	ent:SetSkin( skinid )

	ent._mdl_skinset = true
end

function RADIOMDL:AnimReset(ent)
	local sequence = ent:LookupSequence( "idle" )
	ent:SetAnim( sequence, 0, 1 )
end

function RADIOMDL:WhileLoading(ent)
	if SERVER then return end

	local sequence = ent:LookupSequence( "idle" )
	ent:SetAnim( sequence, 0, 1 )
end

function RADIOMDL:OnPlay(ent, stream)
	if SERVER then return end

	local sequence = ent:LookupSequence( "playidle" )
	ent:SetAnim( sequence, 0, 1 )

	ent:SetPoseParameter( "move_needle", 0 )
	ent:InvalidateBoneCache()
end

function RADIOMDL:OnError(ent, stream)
	if SERVER then return end

	local sequence = ent:LookupSequence( "idle" )
	ent:SetAnim( sequence, 0, 1 )

	ent:SetPoseParameter( "move_needle", 0 )
	ent:InvalidateBoneCache()
end

function RADIOMDL:OnStop(ent, stream)
	if SERVER then return end

	local sequence = ent:LookupSequence( "idle" )
	ent:SetAnim( sequence, 0, 1 )

	ent:SetPoseParameter( "move_needle", 0 )
	ent:InvalidateBoneCache()
end

function RADIOMDL:Think(ent)
	if SERVER then return end

	local spin = ent:GetPoseParameter( "spin_speaker" ) or 0

	spin = spin * 360

	spin = spin + 28
	spin = math.NormalizeAngle( -spin )

	ent.SoundAngOffset = Angle( ent.SoundAngOffset.p, spin, ent.SoundAngOffset.r )

	local armpos = 0

	if not ent.StreamObj:IsEndless() then
		armpos = ent.StreamObj:GetTime() / ent.StreamObj:GetLength()
	end

	ent:SetPoseParameter( "move_needle", armpos )
	ent:InvalidateBoneCache()
end

return true


--PATH lua/streamradio_core/models/wire_monitor_small.lua:
return gluapack()()
--PATH lua/streamradio_core/models/wire_monitor_small.lua:
local RADIOMDL = RADIOMDL
if not istable( RADIOMDL ) then
	StreamRadioLib.Model.LoadModelSettings()
	return
end

-- Wire Monitor, Small
-- Addon: https://steamcommunity.com/sharedfiles/filedetails/?id=160250458
RADIOMDL.model = "models/kobilica/wiremonitorsmall.mdl"

RADIOMDL.SpawnAng = Angle(0, 0, 0)
RADIOMDL.SpawnFlatOnWall = true
RADIOMDL.SoundPosOffset = Vector(0.25, 0, 4.5)
RADIOMDL.SoundAngOffset = Angle(0, 0, 0)

RADIOMDL.DisplayAngles = Angle(0, 90, 90)

                              --      F,     R,    U
RADIOMDL.DisplayOffset    = Vector(0.25, -4.30, 9.30) -- Top Left
RADIOMDL.DisplayOffsetEnd = Vector(0.25,  4.30, 0.70) -- Bottom Right


RADIOMDL.DisplayWidth = 700
RADIOMDL.DisplayHeight, RADIOMDL.DisplayScale = RADIOMDL:GetDisplayHeight(RADIOMDL.DisplayOffset, RADIOMDL.DisplayOffsetEnd, RADIOMDL.DisplayWidth)

RADIOMDL.FontSizes = {
--  Name 	= Size,	Weight, Parentname
	Header	= {25,	1000},
	Small	= {18,	700},
	Default	= {23,	700},
	Tooltip	= {23,	800},
	Big		= {25,	700},
}

function RADIOMDL:SetupGUI(ent, gui_controller, mainpanel)
	gui_controller:SetPos(0, 0)
	gui_controller:SetSize(self.DisplayWidth, self.DisplayHeight)

	mainpanel:SetSize(gui_controller:GetClientSize())

	local modelsetup = {}
	if CLIENT then
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/header/text", "font", self.Fonts.Header)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/header/pretext", "font", self.Fonts.Header)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "font", self.Fonts.Default)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "font", self.Fonts.Default)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/header", "font", self.Fonts.Header)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/controls/progressbar/label", "font", self.Fonts.Small)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/button", "font", self.Fonts.Big)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/volume/progressbar/label", "font", self.Fonts.Default)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/textbox", "font", self.Fonts.Big)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/button", "font", self.Fonts.Big)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/textbox", "font", self.Fonts.Big)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/button", "font", self.Fonts.Big)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "tooltip", "font", self.Fonts.Tooltip)
	end

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/header", "sizeh", 50)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/header", "sizeh", 50)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists", "gridsize", {x = 1, y = 7})
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview", "gridsize", {x = 1, y = 7})
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/scrollbar", "sizew", 30)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/scrollbar", "sizew", 30)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/sidebutton", "sizew", 50)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/textbox/scrollbar", "sizew", 30)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/textbox/scrollbar", "sizew", 30)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/button", "sizeh", 45)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/button", "sizew", 45)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/button", "sizew", 45)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "", "cornersize", 0)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "", "borderwidth", 16)

	local shadow = 5
	local padding = 5
	local margin = 5

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "shadowwidth", shadow)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "shadowwidth", shadow)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "padding", padding)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "padding", padding)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "margin", margin)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "margin", margin)

	gui_controller:SetModelSetup(modelsetup)

	mainpanel:ForEachChildRecursive(function(panel, child)
		if child.SetShadowWidth and child:GetShadowWidth() == 5 then
			child:SetShadowWidth(shadow)
		end

		if child.SetPadding and child:GetPadding() == 5 then
			child:SetPadding(padding)
		end

		if child.SetMargin and child:GetMargin() == 5 then
			child:SetMargin(margin)
		end
	end)
end

return true


--PATH lua/streamradio_core/classes.lua:
return gluapack()()
--PATH lua/streamradio_core/classes/ui/shadow_panel.lua:
local StreamRadioLib = StreamRadioLib

if not istable(CLASS) then
	StreamRadioLib.ReloadClasses()
	return
end

local BASE = CLASS:GetBaseClass()

function CLASS:Create()
	BASE.Create(self)

	self.CanHaveLabel = true

	self.Layout.Padding = 5
	self.Layout.ShadowWidth = 5
	self.Layout.Background = true

	self.SkinMap["color_foreground"] = {
		set = "SetTextColor",
		get = "GetTextColor",
	}

	self.SkinMap["color_icon"] = {
		set = "SetIconColor",
		get = "GetIconColor",
	}

	self.SkinMap["color_shadow"] = {
		set = "SetShadowColor",
		get = "GetShadowColor",
	}

	if not SERVER then
		self.Colors.Shadow = Color(64,64,64)
	end

	self.SkinAble = true
end

function CLASS:CreateText(class)
	if not self.CanHaveLabel then return nil end

	if IsValid(self.TextPanel) then
		return self.TextPanel
	end

	self.TextPanel = self:AddPanelByClassname(class or "label", true)
	self.TextPanel:SetPos(0, 0)
	self.TextPanel:SetAlign(TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
	self.TextPanel:SetName("label")
	self.TextPanel:SetNWName("lbl")
	self.TextPanel:SetSkinIdentifyer("label")

	self.TextPanel.OnTextChange = function(pnl)
		if not IsValid(self) then return end
		self:CallHook("OnTextChange")
	end

	self.TextPanel.OnFontChange = function(pnl)
		if not IsValid(self) then return end

		self:InvalidateLayout()
		self:CallHook("OnFontChange")
	end

	self.TextPanel.OnAlignChange = function(pnl)
		if not IsValid(self) then return end

		self:InvalidateLayout()
		self:CallHook("OnAlignChange")
	end

	self:InvalidateLayout()
	return self.TextPanel
end

function CLASS:Render()
	if not self.Layout.Background then
		BASE.Render(self)
		return
	end

	local x, y = self:GetRenderPos()
	local w, h = self:GetSize()
	local shadowWidth = self:GetShadowWidth()

	local colMain = self.Colors.Main or color_white

	if shadowWidth <= 0 then
		surface.SetDrawColor(colMain:Unpack())
		surface.DrawRect(x, y, w, h)

		BASE.Render(self)
		return
	end

	local sx, sy = x + shadowWidth, y + shadowWidth
	local sw, sh = w - shadowWidth, h - shadowWidth

	local colShadow = self.Colors.Shadow or color_black

	surface.SetDrawColor(colShadow:Unpack())
	surface.DrawRect(sx, sy, sw, sh)
	surface.SetDrawColor(colMain:Unpack())
	surface.DrawRect(x, y, sw, sh)

	BASE.Render(self)
end

function CLASS:PerformLayout(...)
	BASE.PerformLayout(self, ...)

	if not self.CanHaveLabel then
		return
	end

	local text_panel = self.TextPanel
	if not IsValid(text_panel) then
		return
	end

	local w, h = self:GetClientSize()
	text_panel:SetSize(w, h)
end

function CLASS:SetShadowColor(color)
	if SERVER then return end

	color = color or {}
	color = Color(
		color.r or 0,
		color.g or 0,
		color.b or 0,
		color.a or 0
	)

	self.Colors.Shadow = color
end

function CLASS:GetShadowColor()
	if SERVER then return end

	local col = self.Colors.Shadow
	return col
end

function CLASS:GetShadowWidth()
	if not self.Layout.Background then
		return 0
	end

	return self.Layout.ShadowWidth or 0
end

function CLASS:SetShadowWidth(width)
	self.Layout.ShadowWidth = width or 0
end

function CLASS:GetClientSize()
	local w, h = BASE.GetClientSize(self)
	local s = self:GetShadowWidth()

	w = w - s
	h = h - s

	if w < 0 then
		w = 0
	end

	if h < 0 then
		h = 0
	end

	return w, h
end

function CLASS:GetClientWidth()
	local w = BASE.GetClientWidth(self)
	local s = self:GetShadowWidth()

	w = w - s

	if w < 0 then
		w = 0
	end

	return w
end

function CLASS:GetClientHeight()
	local h = BASE.GetClientHeight(self)
	local s = self:GetShadowWidth()

	h = h - s

	if h < 0 then
		h = 0
	end

	return h
end

function CLASS:SetSizeWithoutShadow(w, h)
	w = w or 0
	h = h or 0
	local s = self:GetShadowWidth()

	w = w + s
	h = h + s
	return self:SetSize(w, h)
end

function CLASS:SetWidthWithoutShadow(w)
	w = w or 0
	local s = self:GetShadowWidth()

	w = w + s
	return self:SetWidth(w)
end

function CLASS:SetHeightWithoutShadow(h)
	h = h or 0
	local s = self:GetShadowWidth()

	h = h + s
	return self:SetTall(h)
end

function CLASS:IsInBounds(x, y)
	if not BASE.IsInBounds(self, x, y) then return false end

	local w, h = self:GetSize()
	local s = self:GetShadowWidth()

	if x > (w - s) then return false end
	if y > (h - s) then return false end

	return true
end

function CLASS:SetPaintBackground(bool)
	self.Layout.Background = bool or false
end

function CLASS:GetPaintBackground(bool)
	return self.Layout.Background or false
end

function CLASS:GetTextAlign(...)
	return self:GetAlign(...)
end

function CLASS:SetTextAlign(...)
	return self:SetAlign(...)
end

function CLASS:GetAlign(...)
	if not IsValid(self.TextPanel) then
		return TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER
	end

	return self.TextPanel:GetAlign(...)
end

function CLASS:SetAlign(...)
	return self:CreateText():SetAlign(...)
end

function CLASS:SetText(...)
	return self:CreateText():SetText(...)
end

function CLASS:GetText(...)
	if not IsValid(self.TextPanel) then
		return ""
	end

	return self.TextPanel:GetText(...)
end

function CLASS:SetFont(...)
	return self:CreateText():SetFont(...)
end

function CLASS:GetFont(...)
	if not IsValid(self.TextPanel) then
		return ""
	end

	return self.TextPanel:GetFont(...)
end

function CLASS:SetTextColor(...)
	return self:CreateText():SetColor(...)
end

function CLASS:GetTextColor(...)
	if not IsValid(self.TextPanel) then
		return self:GetColor(...)
	end

	return self.TextPanel:GetColor(...)
end

function CLASS:OnModelSetup(setup)
	BASE.OnModelSetup(self, setup)

	if setup.shadowwidth then
		self:SetShadowWidth(setup.shadowwidth)
	end

	if setup.font then
		self:SetFont(setup.font)
	end
end

return true


--PATH lua/streamradio_core/classes/ui/label_fade.lua:
local StreamRadioLib = StreamRadioLib

if not istable(CLASS) then
	StreamRadioLib.ReloadClasses()
	return
end

local BASE = CLASS:GetBaseClass()

function CLASS:Create()
	BASE.Create(self)

	self.Clickable = false

	if CLIENT then
		self.TextData.FadeTime = 1
		self.TextData.StayTime = 10
		self.TextData.TextIndex = 0

		self.TextData = self.TextData + function(this, k, v)
			if k == "FadeTime" then
				self:Reset()
			end

			if k == "StayTime" then
				self:Reset()
			end

			if k == "TextIndex" then
				self:SwitchText()
			end
		end

		self:StartFastThink()
	end

	self.TextList = {}
	self:SetSkinAble(false)

	self:Reset()
	self:SwitchText()
end

function CLASS:SwitchText()
	if SERVER then return end

	local textlist = self.TextList or {}
	local count = #textlist

	if count <= 0 then
		count = 1
	end

	local index = self.TextData.TextIndex % count + 1
	self:SetText(textlist[index])
end

function CLASS:CalcTime()
	local textlist = self.TextList or {}
	local count = #textlist

	if count <= 1 then return end

	local thistime = RealTime()
	local oldlt = self._lt or thistime
	self._lt = thistime

	self.TickTime = thistime - oldlt
	self.ObjectTime = self.ObjectTime or 0

	self.ObjectTime = self.ObjectTime + self.TickTime
end

function CLASS:GetIndex()
	if SERVER then return end

	local textlist = self.TextList or {}
	local count = #textlist

	if count <= 0 then
		count = 1
	end

	local time = self.ObjectTime or 0

	local fadetime = self.TextData.FadeTime
	local staytime = self.TextData.StayTime
	local totaltime = fadetime * 2 + staytime

	local index = math.floor(time / totaltime) % count
	return index
end

function CLASS:GetPhase()
	if SERVER then return end

	local time = self.ObjectTime or 0

	local fadetime = self.TextData.FadeTime
	local staytime = self.TextData.StayTime

	local totaltime = fadetime * 2 + staytime

	time = time % totaltime

	local fadeinend = fadetime
	local fadeoutstart = fadeinend + staytime

	if time < fadeinend then
		return math.Clamp(time / fadetime, 0, 1)
	end

	if time >= fadeinend and time < fadeoutstart then
		return 1
	end

	if time >= fadeoutstart and time < totaltime then
		return math.Clamp(1 - (time - fadeoutstart) / fadetime, 0, 1)
	end

	return 0
end

function CLASS:ResetTime()
	self.ObjectTime = self.TextData.FadeTime
end

function CLASS:Reset()
	self.ObjectTime = self.TextData.FadeTime
	self.TextData.TextIndex = 0
	self:SwitchText()
end

function CLASS:ClearList()
	self.TextList = nil
	self:Reset()
end

function CLASS:AddToList(text)
	if SERVER then return end

	self.TextList = self.TextList or {}

	text = tostring(text or "")
	table.insert(self.TextList, text)

	self:SwitchText()
end

function CLASS:SetList(textlist)
	if SERVER then return end

	self.TextList = textlist or {}
	self:SwitchText()
end

function CLASS:ShouldPerformRerender()
	if SERVER then return false end

	local phase = self:GetPhase()
	if phase >= 1 then return false end
	if phase <= 0 then return false end

	return true
end

if CLIENT then
	function CLASS:FastThink()
		self.fastThinkRate = 0.25

		if not self:IsSeen() then return end
		if not self:IsVisible() then return end

		self.fastThinkRate = 0.1

		self:CalcTime()
		self.TextData.TextIndex = self:GetIndex()

		if not self:ShouldPerformRerender() then return end
		self.fastThinkRate = 0

		self:PerformRerender(true)
	end
end

function CLASS:Render()
	local x, y = self:GetRenderPos()
	local w, h = self:GetSize()

	local colText = self:GetTextColor()
	local cR, cG, cB, cA = colText:Unpack()

	local phase = self:GetPhase()
	cA = cA * phase

	local font = self.TextData.Font

	surface.SetFont(font)
	surface.SetTextColor(cR, cG, cB, cA)

	self:DrawText(self.InternalText, x, y, w, h)
end

return true


--PATH lua/streamradio_core/classes/ui/image.lua:
local StreamRadioLib = StreamRadioLib

if not istable(CLASS) then
	StreamRadioLib.ReloadClasses()
	return
end

local BASE = CLASS:GetBaseClass()
local changehooks = {
	Material = "OnMaterialChange",
	AlignX = "OnAlignChange",
	AlignY = "OnAlignChange",
}

function CLASS:Create()
	BASE.Create(self)

	self.Clickable = false

	if not SERVER then
		self.ImageData = self:CreateListener({
			Material = nil,
			AlignX = TEXT_ALIGN_CENTER,
			AlignY = TEXT_ALIGN_CENTER,
			SizeW = 16,
			SizeH = 16,
		}, function(this, k)
			self:InvalidateLayout()

			local hookname = changehooks[k]
			if not hookname then return end

			self:CallHook(hookname)
		end)

		self.Colors.Main = Color(255,255,255)
	end

	self:SetSkinAble(false)
end

function CLASS:Render()
	local mat = self.ImageData.Material
	if not mat then return end

	local x, y = self:GetRenderPos()
	local w, h = self:GetSize()

	local tx, ty = x, y
	local tsw, tsh = self:GetTextureSize()
	local xalign, yalign = self.ImageData.AlignX, self.ImageData.AlignY
	local colMain = self.Colors.Main or color_white

	if ( xalign == TEXT_ALIGN_CENTER ) then
		tx = x + w / 2 - tsw / 2
	elseif ( xalign == TEXT_ALIGN_RIGHT ) then
		tx = x + w - tsw
	end

	if ( yalign == TEXT_ALIGN_CENTER ) then
		ty = y + h / 2 - tsh / 2
	elseif ( yalign == TEXT_ALIGN_BOTTOM ) then
		ty = y + h - tsh
	end

	surface.SetDrawColor( colMain:Unpack() )
	surface.SetMaterial( mat )
	surface.DrawTexturedRectUV( tx, ty, tsw, tsh, 0, 0, 1, 1 )
end

function CLASS:GetMaterial()
	if SERVER then return end
	return self.ImageData.Material
end

function CLASS:SetMaterial(mat)
	if SERVER then return end
	self.ImageData.Material = mat
end

function CLASS:GetMaterialName()
	if SERVER then return end
	local mat = self.ImageData.Material
	if not mat then
		return nil
	end

	return self.ImageData.Material:GetName()
end

function CLASS:SetTexture(mat, ...)
	if SERVER then return end
	if not mat then
		return self:SetMaterial(nil)
	end

	self:SetMaterial(Material(mat, ...))
end

function CLASS:GetTextureSize()
	if SERVER then return end
	return self.ImageData.SizeW or 0, self.ImageData.SizeH or 0
end

function CLASS:SetTextureSize(w, h)
	if SERVER then return end
	w = w or 0
	h = h or 0

	if w < 0 then
		w = 0
	end

	if h < 0 then
		h = 0
	end

	self.ImageData.SizeW = w
	self.ImageData.SizeH = h
end

function CLASS:TextureSizeToPanel()
	if SERVER then return end
	self:SetTextureSize(self:GetSize())
	self:InvalidateLayout()
end

function CLASS:TextureFitToPanel()
	if SERVER then return end
	local mat = self.ImageData.Material

	if not mat then
		return
	end

	local dw, dh = self:GetSize()

	if dw > dh then
		dw = dh
	end

	if dh > dw then
		dh = dw
	end

	local w = mat:Width()
	local h = mat:Height()
	local diff = 0

	if ( w > dw and h > dh ) then
		if ( w > dw ) then
			diff = dw / w
			w = w * diff
			h = h * diff
		end

		if ( h > dh ) then
			diff = dh / h
			w = w * diff
			h = h * diff
		end
	end

	if ( w < dw ) then
		diff = dw / w
		w = w * diff
		h = h * diff
	end

	if ( h < dh ) then
		diff = dh / h
		w = w * diff
		h = h * diff
	end

	self:SetTextureSize(w, h)
	self:InvalidateLayout()
end

function CLASS:TextureSizeToTexture()
	if SERVER then return end

	local mat = self.ImageData.Material

	if not mat then
		return
	end

	local tw, th = mat:Width(), mat:Height()
	self:SetTextureSize(tw, th)
	self:InvalidateLayout()
end

function CLASS:SetAlign(alignX, alignY)
	if SERVER then return end
	self.ImageData.AlignX = alignX or self.ImageData.AlignX or TEXT_ALIGN_CENTER
	self.ImageData.AlignY = alignY or self.ImageData.AlignY or TEXT_ALIGN_CENTER
end

function CLASS:GetAlign()
	if SERVER then return end
	return self.ImageData.AlignX or TEXT_ALIGN_CENTER, self.ImageData.AlignY or TEXT_ALIGN_CENTER
end

function CLASS:IsVisibleSimple()
	if CLIENT and not self.ImageData.Material then
		return false
	end

	return BASE.IsVisibleSimple(self)
end

function CLASS:IsVisible()
	if CLIENT and not self.ImageData.Material then
		return false
	end

	return BASE.IsVisible(self)
end

return true


--PATH lua/streamradio_core/classes/ui/scrollbar.lua:
return gluapack()()
--PATH lua/streamradio_core/classes/ui/tooltip.lua:
return gluapack()()
--PATH lua/streamradio_core/classes/ui/list.lua:
return gluapack()()
--PATH lua/streamradio_core/classes/ui/list_files.lua:
local StreamRadioLib = StreamRadioLib

if not istable(CLASS) then
	StreamRadioLib.ReloadClasses()
	return
end

local BASE = CLASS:GetBaseClass()

function CLASS:Create()
	BASE.Create(self)

	self.Scollposes = StreamRadioLib.Util.CreateCacheArray(128)

	self.Path = self:CreateListener({
		Value = nil,
	}, function(this, k, v_new, v_old)
		if k ~= "Value" then return end

		local v = tostring(v_new or "")
		v = string.gsub(v, "[\\/]+", "/")
		v = string.TrimRight(v, "/")

		v_old = tostring(v_old or "")
		v_old = string.gsub(v_old, "[\\/]+", "/")
		v_old = string.TrimRight(v_old, "/")

		if v_old ~= v then
			self:SaveScrollPos(v_old)
		end

		if v_new ~= v then
			self.Path.Value = v
			return
		end

		self:SetNWString("Path", v)

		self:BuildList()
		self:CallHook("OnPathChange")
	end)

	self:SetEvent("OnClose", "SaveScrollPos", "SaveScrollPos")
	self:BuildList()
end

function CLASS:SetIDIcon(ID, icon)
	-- Dummy
end

function CLASS:GetIDIcon(ID)
	return StreamRadioLib.Filesystem.GetIcon(ID)
end

function CLASS:OnItemClickInternal(button, value, buttonindex, ListX, ListY, i)
	if CLIENT and self.Network.Active then return end

	if value.isfolder then
		local shouldswitch = self:CallHook("OnFolderClick", value)
		if shouldswitch == false then
			return
		end

		self.Path.Value = value.path
		return
	end

	self:CallHook("OnFileClick", value)
end

function CLASS:BuildList()
	if CLIENT and self.Network.Active then return end
	self:QueueCall("BuildListInternal")
end

function CLASS:BuildListInternal()
	-- override me
end

function CLASS:GetUpPath()
	return string.GetPathFromFilename(self.Path.Value or "") or ""
end

function CLASS:GoUpPath()
	if CLIENT and self.Network.Active then return end
	self:SetPath(self:GetUpPath())
end

function CLASS:GetPath()
	return self.Path.Value or ""
end

function CLASS:SetPath(path)
	if CLIENT and self.Network.Active then return end
	self.Path.Value = path or ""
end

function CLASS:Refresh()
	self:SaveScrollPos()

	self:ClearData()
	self:BuildList()

	self:CallHook("OnRefresh")
end

function CLASS:SaveScrollPos(path)
	if CLIENT and self.Network.Active then return end
	if not IsValid(self.ScrollBar) then return end

	local dd = self.ScrollBar.DupeData or {}
	local dupescroll = dd.Scroll or 0

	path = path or self:GetPath()
	self.Scollposes:Set(path, self.ScrollBar.Scroll.Pos or dupescroll)
end

function CLASS:RestoreScrollPos()
	if CLIENT and self.Network.Active then return end
	if not IsValid(self.ScrollBar) then return end

	local dd = self.ScrollBar.DupeData or {}
	local dupescroll = dd.Scroll or 0

	local path = self:GetPath()
	self.ScrollBar.Scroll.Pos = self.Scollposes:Get(path) or dupescroll
end

function CLASS:ActivateNetworkedMode()
	BASE.ActivateNetworkedMode(self)
	if SERVER then
		self:SetNWString("Path", self.Path.Value or "")
		self:BuildList()
		return
	end

	self:SetNWVarCallback("Path", "String", function(this, nwkey, oldvar, newvar)
		self.Path.Value = newvar
	end)

	self.Path.Value = self:GetNWString("Path", "")
end

function CLASS:PreDupe()
	local data = {}

	data.Path = self:GetPath()

	return data
end

function CLASS:PostDupe(data)
	self:SetPath(data.Path)
end

return true


--PATH lua/streamradio_core/classes/ui/radio/gui_errorbox.lua:
return gluapack()()
--PATH lua/streamradio_core/classes/ui/radio/gui_errorbox.lua:
local StreamRadioLib = StreamRadioLib

if not istable(CLASS) then
	StreamRadioLib.ReloadClasses()
	return
end

local LIBError = StreamRadioLib.Error

local BASE = CLASS:GetBaseClass()

local g_mat_help = StreamRadioLib.GetPNGIcon("help")
local g_mat_cross = StreamRadioLib.GetPNGIcon("cross")
local g_mat_arrow_refresh = StreamRadioLib.GetPNGIcon("arrow_refresh")
local g_mat_shield_add = StreamRadioLib.GetPNGIcon("shield_add")

function CLASS:Create()
	BASE.Create(self)

	self.Error = 0
	self.URL = ""

	self.BodyPanelText = self:AddPanelByClassname("textview", true)
	self.BodyPanelText:SetAlign(TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
	self.BodyPanelText:SetName("textbox")
	self.BodyPanelText:SetNWName("txt")
	self.BodyPanelText:SetSkinIdentifyer("textbox")

	self.HelpButton = self:AddPanelByClassname("button", true)
	self.HelpButton:SetSize(40, 40)
	self.HelpButton:SetIcon(g_mat_help)
	self.HelpButton:SetDrawAlpha(0.5)
	self.HelpButton:SetTooltip("Help")
	self.HelpButton:SetName("help")
	self.HelpButton:SetNWName("hlp")
	self.HelpButton:SetSkinIdentifyer("button")
	self.HelpButton.DoClick = function()
		self:CallHook("OnHelp")
		if SERVER then return end

		StreamRadioLib.ShowErrorHelp( self.Error, self.URL )
	end

	self.CloseButton = self:AddPanelByClassname("button", true)
	self.CloseButton:SetSize(40, 40)
	self.CloseButton:SetIcon(g_mat_cross)
	self.CloseButton:SetDrawAlpha(0.5)
	self.CloseButton:SetTooltip("Close")
	self.CloseButton:SetName("close")
	self.CloseButton:SetNWName("cls")
	self.CloseButton:SetSkinIdentifyer("button")
	self.CloseButton.DoClick = function()
		self:Close()
		self:CallHook("OnCloseClick")
	end

	self.RetryButton = self:AddPanelByClassname("button", true)
	self.RetryButton:SetSize(40, 40)
	self.RetryButton:SetIcon(g_mat_arrow_refresh)
	self.RetryButton:SetDrawAlpha(0.5)
	self.RetryButton:SetTooltip("Retry")
	self.RetryButton:SetName("retry")
	self.RetryButton:SetNWName("rty")
	self.RetryButton:SetSkinIdentifyer("button")
	self.RetryButton.DoClick = function()
		self:CallHook("OnRetry")
	end

	self.AdminWhitelistButton = self:AddPanelByClassname("button", true)
	self.AdminWhitelistButton:SetSize(40, 40)
	self.AdminWhitelistButton:SetIcon(g_mat_shield_add)
	self.AdminWhitelistButton:SetDrawAlpha(0.5)
	self.AdminWhitelistButton:SetTooltip("Add to quick whitelist (admin only)")
	self.AdminWhitelistButton:SetName("whitelist")
	self.AdminWhitelistButton:SetNWName("wl")
	self.AdminWhitelistButton:SetSkinIdentifyer("button")
	self.AdminWhitelistButton.DoClick = function()
		self:CallHook("OnWhitelist")
	end

	self:SetEvent("OnClose", "HideAdminWhitelistButton", "HideAdminWhitelistButton")

	self.SideButtons = {
		self.CloseButton,
		self.RetryButton,
		self.HelpButton,
		self.AdminWhitelistButton,
	}

	self:HideAdminWhitelistButton()
end

function CLASS:HideAdminWhitelistButton()
	self:SetAdminWhitelistButtonVisible(false)
end

function CLASS:SetAdminWhitelistButtonVisible(visible)
	local adminWhitelistButton = self.AdminWhitelistButton

	if not IsValid(adminWhitelistButton) then
		return
	end

	local oldVisible = adminWhitelistButton.Layout.Visible
	if oldVisible == visible then
		return
	end

	adminWhitelistButton:SetVisible(visible)

	self:InvalidateLayout(true, false)
end

function CLASS:ResetLayout()
	if IsValid(self.BodyPanelText) then
		self.BodyPanelText:SetVisible(true)
	end

	if IsValid(self.HelpButton) then
		self.HelpButton:SetVisible(true)
	end

	self:SetPaintBackground(true)
end

function CLASS:SetPlaylistError(url)
	self:ResetLayout()

	url = tostring(url or "")

	self.Error = LIBError.PLAYLIST_ERROR_INVALID_FILE
	self.URL = url

	local errorInfo = LIBError.GetStreamErrorInfo(self.Error)

	local code = errorInfo.id
	local name = errorInfo.name
	local hasHelpmenu = errorInfo.helpmenu

	local text

	if url ~= "" then
		text = string.format("Error: %i (%s)\n\nCould not open playlist:\n%s\n\nMake sure the file is valid and not Empty\n\nClick the '?' button for more details.", code, name, url)
	else
		text = string.format("Error: %i (%s)\n\nCould not open playlist!\n\nMake sure the file is valid and not Empty\n\nClick the '?' button for more details.", code, name)
	end

	if IsValid(self.BodyPanelText) then
		self.BodyPanelText:SetText(text)
	end

	if IsValid(self.HelpButton) then
		self.HelpButton:SetVisible(hasHelpmenu)
	end

	self:Open()
end

function CLASS:SetSoundKilledError()
	self:ResetLayout()

	self.Error = LIBError.STREAM_SOUND_STOPPED
	self.URL = ""

	if IsValid(self.BodyPanelText) then
		self.BodyPanelText:SetVisible(false)
	end

	if IsValid(self.HelpButton) then
		self.HelpButton:SetVisible(false)
	end

	self:SetPaintBackground(false)
	self:Open()
end

function CLASS:SetErrorCode(err, url)
	err = tonumber(err or 0) or 0
	url = tostring(url or "")

	if err == LIBError.STREAM_SOUND_STOPPED then
		self:SetSoundKilledError()
		return
	end

	if err == LIBError.PLAYLIST_ERROR_INVALID_FILE then
		self:SetSoundKilledError()
		return
	end

	self:ResetLayout()

	self.Error = err
	self.URL = url

	local errorInfo = LIBError.GetStreamErrorInfo(err)

	local code = errorInfo.id
	local name = errorInfo.name
	local description = errorInfo.description or ""
	local hasHelpmenu = errorInfo.helpmenu

	local text

	if url ~= "" then
		text = string.format("Error: %i (%s)\n\nCould not play stream:\n%s\n\n%s\n\nClick the '?' button for more details.", code, name, url, description)
	else
		text = string.format("Error: %i (%s)\n\nCould not play stream!\n\n%s\n\nClick the '?' button for more details.", code, name, description)
	end

	if IsValid(self.BodyPanelText) then
		self.BodyPanelText:SetText(text)
	end

	if IsValid(self.HelpButton) then
		self.HelpButton:SetVisible(hasHelpmenu)
	end

	if err ~= LIBError.STREAM_OK then
		self:Open()
	else
		self:Close()
	end
end

function CLASS:_PerformButtonLayout(buttonx, buttony)
	if not self.SideButtons then return end

	local _, h = self:GetClientSize()
	local buttonw = 0

	for k, v in ipairs(self.SideButtons) do
		if not IsValid(v) then continue end
		if not v.Layout.Visible then continue end

		if buttonw <= 0 then
			buttonw = v:GetWidth()
			break
		end
	end

	local margin = self:GetMargin()

	for k, v in ipairs(self.SideButtons) do
		if not IsValid(v) then continue end
		if not v.Layout.Visible then continue end

		local newbutteny = buttony + (buttonw + margin)
		if newbutteny >= h then
			v:SetPos(0, 0)
			v:SetHeight(0)
			continue
		end

		v:SetPos(buttonx, buttony)
		v:SetSize(buttonw, buttonw)
		buttony = newbutteny
	end

	return buttonw, buttony
end

function CLASS:PerformLayout(...)
	BASE.PerformLayout(self, ...)

	local w, h = self:GetClientSize()

	local margin = self:GetMargin()

	if IsValid(self.BodyPanelText) and self.BodyPanelText.Layout.Visible then
		self.BodyPanelText:SetPos(0, 0)
		self.BodyPanelText:SetSize(w, h)
	end

	self:_PerformButtonLayout(margin, margin)
end

return true


--PATH lua/streamradio_core/classes/rendertarget.lua:
return gluapack()()
--PATH lua/streamradio_core/properties.lua:

local StreamRadioLib = StreamRadioLib

StreamRadioLib.properties = StreamRadioLib.properties or {}

local LIB = StreamRadioLib.properties
table.Empty(LIB)

local LIBNet = StreamRadioLib.Net
local LIBError = StreamRadioLib.Error
local LIBUtil = StreamRadioLib.Util
local LIBUrl = StreamRadioLib.Url

local g_mainOptionAdded = false
local g_subOptions = {}
local g_nameprefix = "3dstreamradio_properties_"

local g_mode_play = 0
local g_mode_pause = 1
local g_mode_stop = 2
local g_mode_previous_track = 3
local g_mode_next_track = 4
local g_mode_rewind = 5
local g_mode_fastforward = 6

local g_mode_mute = 0
local g_mode_unmute = 1
local g_mode_volume_up = 2
local g_mode_volume_down = 3

if SERVER then
	LIBNet.Receive("properties", function(len, client)
		if not IsValid(client) then return end

		local name = net.ReadString()
		if not name then return end

		local subOption = g_subOptions[name]
		if not subOption then return end
		if not subOption.Receive then return end

		subOption:Receive(len, client)
	end)
end

function LIB.GetName(identifier)
	identifier = g_nameprefix .. tostring(identifier or "")
	identifier = string.lower(identifier)

	return identifier
end

function LIB.Get(identifier)
	identifier = LIB.GetName(identifier)

	return properties.List[identifier] or g_subOptions[identifier]
end

function LIB.Add(identifier, propertyData)
	identifier = LIB.GetName(identifier)

	return properties.Add(identifier, propertyData)
end

function LIB.CanProperty(identifier, ent, ply )
	if not IsValid( ent ) then return false end
	if not ent.__IsRadio then return false end

	identifier = LIB.GetName(identifier)
	if not gamemode.Call( "CanProperty", ply, identifier, ent ) then return false end

	return true
end

function LIB.CanBeTargeted(ent, ply)
	if not IsValid( ent ) then return false end
	if not ent.__IsRadio then return false end
	if not properties.CanBeTargeted( ent, ply ) then return false end

	return true
end

function LIB.CheckFilter(identifier, ent, ply)
	local propertyData = LIB.Get(identifier)

	if not propertyData then
		return true
	end

	if not propertyData.Filter then
		return true
	end

	return propertyData:Filter(ent, ply)
end

function LIB.CheckFilters(identifiers, ent, ply)
	for i, identifier in ipairs(identifiers) do
		if LIB.CheckFilter(identifier, ent, ply) then
			return true
		end
	end

	return false
end

local g_meta = {
	MsgStart = function(self)
		LIBNet.Start("properties")
		net.WriteString(self.InternalName)
	end,

	MsgEnd = function(self)
		net.SendToServer()
	end
}

g_meta.__index = g_meta

local function addMainOption()
	if g_mainOptionAdded then
		return
	end

	LIB.Add("radio_options", {
		MenuLabel = "Radio Options",
		Order = 10000,
		MenuIcon = "3dstreamradio/icon16/format_radio.png",

		Filter = function( self, ent, ply )
			if not LIB.CanBeTargeted( ent, ply ) then return false end
			return true
		end,

		MenuOpen = function( self, option, ent, tr )
			local ply = LocalPlayer()
			if not self:Filter(ent, ply) then return end

			local submenuPanel = option:AddSubMenu()

			submenuPanel:SetMinimumWidth(215)

			for k, subOption in SortedPairsByMemberValue( g_subOptions, "Order" ) do
				if not subOption.Filter then continue end
				if not subOption:Filter(ent, ply) then continue end

				if subOption.PrependSpacer then
					submenuPanel:AddSpacer()
				end

				local label = subOption.MenuLabel or subOption.InternalName

				local optionPanel = submenuPanel:AddOption(
					label,
					function(panel)
						if not subOption:Filter(ent, ply) then
							return
						end

						subOption:Action(ent, tr)

						panel:Think()
					end
				)

				if subOption.OnCreate then
					subOption:OnCreate(submenuPanel, optionPanel)
				end

				if subOption.MenuIcon then
					optionPanel:SetImage(subOption.MenuIcon)
				end

				if subOption.MenuOpen then
					subOption:MenuOpen(optionPanel, ent, tr)
				end

				optionPanel._oldThink = optionPanel.Think
				optionPanel.Think = function(panel, ...)
					if not subOption.Think then
						return
					end

					if not subOption:Filter(ent, ply) then
						return
					end

					subOption:Think(panel, ent)

					if panel._oldThink then
						return panel:_oldThink(...)
					end
				end
			end
		end,

		Action = function( self, ent )
		end,

		Receive = function( self, length, ply )
		end
	})

	g_mainOptionAdded = true
end

function LIB.AddSubOption(identifier, propertyData)
	addMainOption()

	identifier = LIB.GetName(identifier)

	propertyData = table.Copy(propertyData)
	propertyData.InternalName = identifier

	setmetatable(propertyData, g_meta)

	g_subOptions[identifier] = propertyData
end

local function g_emptyFunction()
end

local g_titleOnCreate = function( self, submenuPanel, optionPanel )
	optionPanel.OnMousePressed = g_emptyFunction
	optionPanel.OnMouseReleased = g_emptyFunction
	optionPanel.DoClickInternal = g_emptyFunction

	optionPanel:SetEnabled(false)
	optionPanel:SetTextInset(2, 0)
	optionPanel:SetContentAlignment(5)
end

local g_VolumeMenuOpen = function( self, optionPanel, ent )
	optionPanel.OnMousePressed = g_emptyFunction
	optionPanel.OnMouseReleased = g_emptyFunction
	optionPanel.DoClickInternal = g_emptyFunction

	optionPanel:SetTextInset(10, 0)
	optionPanel:DockPadding(5, 5, 5, 5)

	local ply = LocalPlayer()

	local upButton = vgui.Create( "DButton", optionPanel )
	optionPanel._upButton = upButton

	upButton:Dock(RIGHT)
	upButton:SetImage(StreamRadioLib.GetPNGIconPath("sound_add"))
	upButton:SetText("")
	upButton:DockMargin(5, 0, 0, 0)
	upButton:SetTooltip("Increase volume")

	upButton.DoClick = function(panel)
		if not self.VolumeUp then
			return
		end

		if not self:Filter(ent, ply) then
			return
		end

		self:VolumeUp(ent)
		panel:Think()
	end

	local downButton = vgui.Create( "DButton", optionPanel )
	optionPanel._downButton = downButton

	downButton:Dock(RIGHT)
	downButton:SetImage(StreamRadioLib.GetPNGIconPath("sound_delete"))
	downButton:SetText("")
	downButton:DockMargin(5, 0, 0, 0)
	downButton:SetTooltip("Decrease volume")

	downButton.DoClick = function(panel)
		if not self.VolumeDown then
			return
		end

		if not self:Filter(ent, ply) then
			return
		end

		self:VolumeDown(ent)
		panel:Think()
	end

	local muteButton = vgui.Create( "DButton", optionPanel )
	optionPanel._muteButton = muteButton

	muteButton:Dock(RIGHT)
	muteButton:SetImage(StreamRadioLib.GetPNGIconPath("sound_mute"))
	muteButton:SetText("")
	muteButton:DockMargin(0, 0, 0, 0)
	muteButton:SetTooltip("Mute")

	muteButton.DoClick = function(panel)
		if not self.Mute then
			return
		end

		if not self:Filter(ent, ply) then
			return
		end

		self:Mute(ent)
		panel:Think()
	end

	local unmuteButton = vgui.Create( "DButton", optionPanel )
	optionPanel._unmuteButton = unmuteButton

	unmuteButton:Dock(RIGHT)
	unmuteButton:SetImage(StreamRadioLib.GetPNGIconPath("sound"))
	unmuteButton:SetText("")
	unmuteButton:DockMargin(0, 0, 0, 0)
	unmuteButton:SetTooltip("Unmute")

	unmuteButton.DoClick = function(panel)
		if not self.Unmute then
			return
		end

		if not self:Filter(ent, ply) then
			return
		end

		self:Unmute(ent)
		panel:Think()
	end

	-- bypass hardcoded size in internal PerformLayout
	optionPanel._SetSize = optionPanel.SetSize

	optionPanel.SetSize = function(panel, x, y)
		y = 40
		local buttonSize = y - 10

		upButton:SetSize(buttonSize, buttonSize)
		downButton:SetSize(buttonSize, buttonSize)
		muteButton:SetSize(buttonSize, buttonSize)
		unmuteButton:SetSize(buttonSize, buttonSize)

		return panel:_SetSize(x, y)
	end
end

local g_PlaylistControlsMenuOpen = function( self, optionPanel, ent )
	optionPanel.OnMousePressed = g_emptyFunction
	optionPanel.OnMouseReleased = g_emptyFunction
	optionPanel.DoClickInternal = g_emptyFunction

	optionPanel:SetTextInset(5, 0)
	optionPanel:DockPadding(5, 5, 5, 5)

	local ply = LocalPlayer()

	local playButton = vgui.Create( "DButton", optionPanel )
	optionPanel._playButton = playButton

	playButton:Dock(LEFT)
	playButton:SetImage(StreamRadioLib.GetPNGIconPath("control_play"))
	playButton:SetText("")
	playButton:DockMargin(0, 0, 0, 0)
	playButton:SetTooltip("Play")

	playButton.DoClick = function(panel)
		if not self.Play then
			return
		end

		if not self:Filter(ent, ply) then
			return
		end

		self:Play(ent)
		panel:Think()
	end

	local pauseButton = vgui.Create( "DButton", optionPanel )
	optionPanel._pauseButton = pauseButton

	pauseButton:Dock(LEFT)
	pauseButton:SetImage(StreamRadioLib.GetPNGIconPath("control_pause"))
	pauseButton:SetText("")
	pauseButton:DockMargin(0, 0, 0, 0)
	pauseButton:SetTooltip("Pause")

	pauseButton.DoClick = function(panel)
		if not self.Pause then
			return
		end

		if not self:Filter(ent, ply) then
			return
		end

		self:Pause(ent)
		panel:Think()
	end

	local stopButton = vgui.Create( "DButton", optionPanel )
	optionPanel._stopButton = stopButton

	stopButton:Dock(LEFT)
	stopButton:SetImage(StreamRadioLib.GetPNGIconPath("control_stop"))
	stopButton:SetText("")
	stopButton:DockMargin(5, 0, 0, 0)
	stopButton:SetTooltip("Stop")

	stopButton.DoClick = function(panel)
		if not self.Stop then
			return
		end

		if not self:Filter(ent, ply) then
			return
		end

		self:Stop(ent)
		panel:Think()
	end

	local previousTrackButton = vgui.Create( "DButton", optionPanel )
	optionPanel._previousTrackButton = previousTrackButton

	previousTrackButton:Dock(LEFT)
	previousTrackButton:SetImage(StreamRadioLib.GetPNGIconPath("control_start"))
	previousTrackButton:SetText("")
	previousTrackButton:DockMargin(5, 0, 0, 0)
	previousTrackButton:SetTooltip("Previous track")

	previousTrackButton.DoClick = function(panel)
		if not self.PreviousTrack then
			return
		end

		if not self:Filter(ent, ply) then
			return
		end

		self:PreviousTrack(ent)
		panel:Think()
	end

	local nextTrackButton = vgui.Create( "DButton", optionPanel )
	optionPanel._nextTrackButton = nextTrackButton

	nextTrackButton:Dock(LEFT)
	nextTrackButton:SetImage(StreamRadioLib.GetPNGIconPath("control_end"))
	nextTrackButton:SetText("")
	nextTrackButton:DockMargin(5, 0, 0, 0)
	nextTrackButton:SetTooltip("Next track")

	nextTrackButton.DoClick = function(panel)
		if not self.NextTrack then
			return
		end

		if not self:Filter(ent, ply) then
			return
		end

		self:NextTrack(ent)
		panel:Think()
	end

	local rewindButton = vgui.Create( "DButton", optionPanel )
	optionPanel._rewindButton = rewindButton

	rewindButton:Dock(LEFT)
	rewindButton:SetImage(StreamRadioLib.GetPNGIconPath("control_rewind"))
	rewindButton:SetText("")
	rewindButton:DockMargin(5, 0, 0, 0)
	rewindButton:SetTooltip("Rewind 10 seconds")

	rewindButton.DoClick = function(panel)
		if not self.Rewind then
			return
		end

		if not self:Filter(ent, ply) then
			return
		end

		self:Rewind(ent)
		panel:Think()
	end

	local fastForwardButton = vgui.Create( "DButton", optionPanel )
	optionPanel._fastForwardButton = fastForwardButton

	fastForwardButton:Dock(LEFT)
	fastForwardButton:SetImage(StreamRadioLib.GetPNGIconPath("control_fastforward"))
	fastForwardButton:SetText("")
	fastForwardButton:DockMargin(5, 0, 0, 0)
	fastForwardButton:SetTooltip("Fast forward 10 seconds")

	fastForwardButton.DoClick = function(panel)
		if not self.FastForward then
			return
		end

		if not self:Filter(ent, ply) then
			return
		end

		self:FastForward(ent)
		panel:Think()
	end

	-- bypass hardcoded size in internal PerformLayout
	optionPanel._SetSize = optionPanel.SetSize

	optionPanel.SetSize = function(panel, x, y)
		y = 40
		local buttonSize = y - 10

		playButton:SetSize(buttonSize, buttonSize)
		pauseButton:SetSize(buttonSize, buttonSize)
		stopButton:SetSize(buttonSize, buttonSize)
		previousTrackButton:SetSize(buttonSize, buttonSize)
		nextTrackButton:SetSize(buttonSize, buttonSize)
		rewindButton:SetSize(buttonSize, buttonSize)
		fastForwardButton:SetSize(buttonSize, buttonSize)

		return panel:_SetSize(x, y)
	end
end

LIB.AddSubOption("clientside_title", {
	MenuLabel = "Clientside Options",
	Order = 100,
	PrependSpacer = true,

	Filter = function( self, ent, ply )
		if not LIB.CanBeTargeted( ent, ply ) then return false end

		local allowed = LIB.CheckFilters(
			{
				"copy_url",
				"error_info",
				"clientside_mute",
				"clientside_unmute",
				"clientside_volume",
			},
			ent,
			ply
		)

		return allowed
	end,

	Action = function( self, ent )
	end,

	OnCreate = g_titleOnCreate,
})

LIB.AddSubOption("copy_url", {
	MenuLabel = "Copy Stream URL to clipboard",
	Order = 110,
	MenuIcon = StreamRadioLib.GetPNGIconPath("page_copy"),
	PrependSpacer = true,

	Filter = function( self, ent, ply )
		if not LIB.CanBeTargeted( ent, ply ) then return false end

		local url = ent:GetStreamURL()
		if url == "" then return false end

		return true
	end,

	Action = function( self, ent )
		local url = ent:GetStreamURL()
		SetClipboardText(url)
	end,
})

LIB.AddSubOption("error_info", {
	MenuLabel = "Error",
	Order = 111,
	MenuIcon = StreamRadioLib.GetPNGIconPath("error"),

	Filter = function( self, ent, ply )
		if not LIB.CanBeTargeted( ent, ply ) then return false end

		local stream = ent:GetStreamObject()
		if not stream then return false end
		if not stream:HasError() then return false end

		return true
	end,

	Action = function( self, ent )
		local stream = ent:GetStreamObject()

		if stream:IsKilled() then
			stream:ReviveStream()
			return
		end

		local err = stream:GetError()
		local url = stream:GetURL()

		StreamRadioLib.ShowErrorHelp(err, url)
	end,

	Think = function( self, optionPanel, ent )
		local stream = ent:GetStreamObject()

		if stream:IsKilled() then
			local label = string.format("%s: %s", self.MenuLabel, "Sound stopped!")
			local tooltip = "The sound has been stopped. Click here to restart."

			optionPanel:SetText(label)
			optionPanel:SetTooltip(tooltip)
			return
		end

		local err = stream:GetError()
		local url = stream:GetURL()

		local errorInfo = LIBError.GetStreamErrorInfo(err)
		local errorName = errorInfo.name
		local errorDescription = errorInfo.description
		local hasHelpmenu = errorInfo.helpmenu

		local label = string.format("%s: %i (%s)", self.MenuLabel, err, errorName)

		local tooltip = ""

		if hasHelpmenu then
			tooltip = string.format("Error %i (%s): %s\n\nCan not play this URL:\n%s\n\nClick for more details.", err, errorName, errorDescription, url)
		else
			tooltip = string.format("Error %i (%s): %s\n\nCan not play this URL:\n%s", err, errorName, errorDescription, url)
		end

		optionPanel:SetText(label)
		optionPanel:SetTooltip(tooltip)
	end,
})

LIB.AddSubOption("reset_gui", {
	MenuLabel = "Reset GUI",
	Order = 112,
	MenuIcon = StreamRadioLib.GetPNGIconPath("lightning"),

	Filter = function( self, ent, ply )
		if not LIB.CanBeTargeted( ent, ply ) then return false end
		if ent.DisplayLess then return false end

		return true
	end,

	Action = function( self, ent )
		ent:RemoveGui()
	end,
})

LIB.AddSubOption("clientside_volume", {
	MenuLabel = "Volume",
	Order = 120,

	Filter = function( self, ent, ply )
		if not LIB.CanBeTargeted( ent, ply ) then return false end
		return true
	end,

	Action = function( self, ent )
	end,

	Mute = function( self, ent )
		ent:SetCLMute(true)
	end,

	Unmute = function( self, ent )
		ent:SetCLMute(false)
	end,

	VolumeUp = function( self, ent )
		local volume = ent:GetCLVolume()

		volume = math.Clamp(volume + 0.2, 0, 1)
		volume = math.Round(volume, 2)

		ent:SetCLVolume(volume)
	end,

	VolumeDown = function( self, ent )
		local volume = ent:GetCLVolume()

		volume = math.Clamp(volume - 0.2, 0, 1)
		volume = math.Round(volume, 2)

		ent:SetCLVolume(volume)
	end,

	Think = function( self, optionPanel, ent )
		local volume = ent:GetCLVolume()
		local isMuted = ent:GetCLMute()

		local label = string.format("%s: %3i%%", self.MenuLabel, volume * 100)

		optionPanel:SetText(label)

		local upButton = optionPanel._upButton
		local downButton = optionPanel._downButton
		local muteButton = optionPanel._muteButton
		local unmuteButton = optionPanel._unmuteButton

		if IsValid(upButton) then
			upButton:SetEnabled(volume < 1)
		end

		if IsValid(downButton) then
			downButton:SetEnabled(volume > 0)
		end

		if IsValid(muteButton) then
			muteButton:SetVisible(not isMuted)
		end

		if IsValid(unmuteButton) then
			unmuteButton:SetVisible(isMuted)
		end
	end,

	MenuOpen = g_VolumeMenuOpen,
})

LIB.AddSubOption("serverside_title", {
	MenuLabel = "Entity Options",
	Order = 200,
	PrependSpacer = true,

	Filter = function( self, ent, ply )
		if not LIB.CanBeTargeted( ent, ply ) then return false end

		local allowed = LIB.CheckFilters(
			{
				"serverside_volume",
			},
			ent,
			ply
		)

		return allowed
	end,

	Action = function( self, ent )
	end,

	OnCreate = g_titleOnCreate,
})

LIB.AddSubOption("playlist_controls", {
	MenuLabel = "",
	Order = 210,

	Filter = function( self, ent, ply )
		if not LIB.CanBeTargeted( ent, ply ) then return false end
		if not LIB.CanProperty("playlist_controls", ent, ply ) then return false end

		local stream = ent:GetStreamObject()
		if not IsValid(stream) then
			return false
		end

		local hasPlaylist = ent:GetHasPlaylist()
		local url = ent:GetStreamURL()

		if not hasPlaylist and url == "" then
			return false
		end

		return true
	end,

	Action = function( self, ent )
	end,

	DoControl = function( self, ent, mode )
		self:MsgStart()
			net.WriteEntity( ent )
			net.WriteUInt( mode, 4 )
		self:MsgEnd()
	end,

	Play = function( self, ent )
		local stream = ent:GetStreamObject()

		if stream:IsKilled() then
			stream:ReviveStream()
		end

		self:DoControl(ent, g_mode_play)
	end,

	Pause = function( self, ent )
		self:DoControl(ent, g_mode_pause)
	end,

	Stop = function( self, ent )
		self:DoControl(ent, g_mode_stop)
	end,

	PreviousTrack = function( self, ent )
		self:DoControl(ent, g_mode_previous_track)
	end,

	NextTrack = function( self, ent )
		self:DoControl(ent, g_mode_next_track)
	end,

	Rewind = function( self, ent )
		self:DoControl(ent, g_mode_rewind)
	end,

	FastForward = function( self, ent )
		self:DoControl(ent, g_mode_fastforward)
	end,

	Think = function( self, optionPanel, ent )
		local stream = ent:GetStreamObject()
		if not IsValid(stream) then return end

		local isPlayMode = stream:IsPlayMode()
		local isStopMode = stream:IsStopMode()

		if stream:IsKilled() then
			isPlayMode = false
			isStopMode = true
		end

		local isEndless = stream:IsEndless()

		local hasPlaylist = ent:GetHasPlaylist()

		local playButton = optionPanel._playButton
		local pauseButton = optionPanel._pauseButton
		local stopButton = optionPanel._stopButton
		local previousTrackButton = optionPanel._previousTrackButton
		local nextTrackButton = optionPanel._nextTrackButton
		local rewindButton = optionPanel._rewindButton
		local fastForwardButton = optionPanel._fastForwardButton

		if IsValid(stopButton) then
			stopButton:SetEnabled(not isStopMode)
		end

		if IsValid(playButton) then
			playButton:SetVisible(not isPlayMode)
		end

		if IsValid(pauseButton) then
			pauseButton:SetVisible(isPlayMode)
		end

		if IsValid(previousTrackButton) then
			previousTrackButton:SetEnabled(hasPlaylist)
		end

		if IsValid(nextTrackButton) then
			nextTrackButton:SetEnabled(hasPlaylist)
		end

		if IsValid(rewindButton) then
			rewindButton:SetEnabled(not isEndless)
		end

		if IsValid(fastForwardButton) then
			fastForwardButton:SetEnabled(not isEndless)
		end
	end,

	MenuOpen = g_PlaylistControlsMenuOpen,

	Receive = function( self, length, ply )
		local ent = net.ReadEntity()
		local mode = net.ReadUInt(4)

		if not self:Filter( ent, ply ) then return end

		local stream = ent:GetStreamObject()

		if mode == g_mode_play then
			local hasEnded = stream:HasEnded()
			local isPauseMode = stream:IsPauseMode()

			if isPauseMode and not hasEnded then
				stream:Play(hasEnded)
			else
				ent:PlayFromCurrentPlaylistItem()
			end
		elseif mode == g_mode_pause then
			stream:Pause()
		elseif mode == g_mode_stop then
			stream:Stop()
		elseif mode == g_mode_previous_track then
			ent:PlayPreviousPlaylistItem()
		elseif mode == g_mode_next_track then
			ent:PlayNextPlaylistItem()
		elseif mode == g_mode_rewind then
			local length = stream:GetMasterLength()

			if length > 0 then
				local time = stream:GetMasterTime()
				local newtime = math.Clamp(time - 10, 0, length - 0.1)

				stream:SetTime(newtime, true)
			end
		elseif mode == g_mode_fastforward then
			local length = stream:GetMasterLength()

			if length > 0 then
				local time = stream:GetMasterTime()
				local newtime = math.Clamp(time + 10, 0, length - 0.1)

				stream:SetTime(newtime, true)
			end
		end
	end
})

LIB.AddSubOption("serverside_volume", {
	MenuLabel = "Volume",
	Order = 220,

	Filter = function( self, ent, ply )
		if not LIB.CanBeTargeted( ent, ply ) then return false end
		if not LIB.CanProperty("serverside_volume", ent, ply ) then return false end

		return true
	end,

	Action = function( self, ent )
	end,

	DoControl = function( self, ent, mode )
		self:MsgStart()
			net.WriteEntity( ent )
			net.WriteUInt( mode, 4 )
		self:MsgEnd()
	end,

	Mute = function( self, ent )
		self:DoControl(ent, g_mode_mute)
	end,

	Unmute = function( self, ent )
		self:DoControl(ent, g_mode_unmute)
	end,

	VolumeUp = function( self, ent )
		self:DoControl(ent, g_mode_volume_up)
	end,

	VolumeDown = function( self, ent )
		self:DoControl(ent, g_mode_volume_down)
	end,

	Think = function( self, optionPanel, ent )
		local volume = ent:GetVolume()
		local isMuted = ent:GetSVMute()

		local label = string.format("%s: %3i%%", self.MenuLabel, volume * 100)

		optionPanel:SetText(label)

		local upButton = optionPanel._upButton
		local downButton = optionPanel._downButton
		local muteButton = optionPanel._muteButton
		local unmuteButton = optionPanel._unmuteButton

		if IsValid(upButton) then
			upButton:SetEnabled(volume < 1)
		end

		if IsValid(downButton) then
			downButton:SetEnabled(volume > 0)
		end

		if IsValid(muteButton) then
			muteButton:SetVisible(not isMuted)
		end

		if IsValid(unmuteButton) then
			unmuteButton:SetVisible(isMuted)
		end
	end,

	MenuOpen = g_VolumeMenuOpen,

	Receive = function( self, length, ply )
		local ent = net.ReadEntity()
		local mode = net.ReadUInt(4)

		if not self:Filter( ent, ply ) then return end

		if mode == g_mode_mute then
			ent:SetSVMute(true)
		elseif mode == g_mode_unmute then
			ent:SetSVMute(false)
		elseif mode == g_mode_volume_up then
			local volume = ent:GetVolume()

			volume = math.Clamp(volume + 0.2, 0, 1)
			volume = math.Round(volume, 2)

			ent:SetVolume(volume)
		elseif mode == g_mode_volume_down then
			local volume = ent:GetVolume()

			volume = math.Clamp(volume - 0.2, 0, 1)
			volume = math.Round(volume, 2)

			ent:SetVolume(volume)
		end
	end
})

LIB.AddSubOption("admin_title", {
	MenuLabel = "Admin Options",
	Order = 300,
	PrependSpacer = true,

	Filter = function( self, ent, ply )
		if not LIBUtil.IsAdmin( ply ) then return false end
		if not LIB.CanBeTargeted( ent, ply ) then return false end

		local url = ent:GetStreamURL()
		if url ~= "" then
			local context = StreamRadioLib.Whitelist.BuildContext(ent, ply)

			-- Trigger updating the cache in the background if needed
			StreamRadioLib.Whitelist.IsAllowedAsync(url, context)
		end

		local allowed = LIB.CheckFilters(
			{
				"admin_whitelist_add",
				"admin_whitelist_remove",
			},
			ent,
			ply
		)

		return allowed
	end,

	Action = function( self, ent )
	end,

	OnCreate = g_titleOnCreate,
})

LIB.AddSubOption("admin_whitelist_add", {
	MenuLabel = "Add to quick whitelist",
	Order = 310,
	MenuIcon = StreamRadioLib.GetPNGIconPath("shield_add"),
	PrependSpacer = true,

	Filter = function( self, ent, ply )
		if not LIBUtil.IsAdmin( ply ) then return false end
		if not LIB.CanBeTargeted( ent, ply ) then return false end
		if not StreamRadioLib.IsUrlWhitelistEnabled() then return false end

		local url = ent:GetStreamURL()
		if url == "" then return false end

		if LIBUrl.IsOfflineURL(url) then
			return false
		end

		local context = StreamRadioLib.Whitelist.BuildContext(ent, ply)
		local result, blockedByHook = StreamRadioLib.Whitelist.IsAllowedSync(url, context)

		if blockedByHook then return false end
		if result then return false end

		return true
	end,

	Action = function( self, ent )
		local url = ent:GetStreamURL()
		StreamRadioLib.Whitelist.QuickWhitelistAdd(url)

		-- Trigger updating the cache in the background if needed
		local context = StreamRadioLib.Whitelist.BuildContext(ent)
		StreamRadioLib.Whitelist.IsAllowedAsync(url, context)
	end,
})

LIB.AddSubOption("admin_whitelist_remove", {
	MenuLabel = "Remove from quick whitelist",
	Order = 320,
	MenuIcon = StreamRadioLib.GetPNGIconPath("shield_delete"),
	PrependSpacer = true,

	Filter = function( self, ent, ply )
		if not LIBUtil.IsAdmin( ply ) then return false end
		if not LIB.CanBeTargeted( ent, ply ) then return false end
		if not StreamRadioLib.IsUrlWhitelistEnabled() then return false end

		local url = ent:GetStreamURL()
		if url == "" then return false end

		if LIBUrl.IsOfflineURL(url) then
			return false
		end

		local context = StreamRadioLib.Whitelist.BuildContext(ent, ply)
		local result, blockedByHook = StreamRadioLib.Whitelist.IsAllowedSync(url, context)

		if blockedByHook then return false end
		if not result then return false end

		return true
	end,

	Action = function( self, ent )
		local url = ent:GetStreamURL()
		StreamRadioLib.Whitelist.QuickWhitelistRemove(url)

		-- Trigger updating the cache in the background if needed
		local context = StreamRadioLib.Whitelist.BuildContext(ent)
		StreamRadioLib.Whitelist.IsAllowedAsync(url, context)
	end,
})

return true


--PATH lua/streamradio_core/cfchttp.lua:
local StreamRadioLib = StreamRadioLib

StreamRadioLib.Cfchttp = StreamRadioLib.Cfchttp or {}

local LIB = StreamRadioLib.Cfchttp
table.Empty(LIB)

local g_emptyFunction = function() end

-- API Wrapper for CFC HTTP Whitelist
-- https://github.com/CFC-Servers/cfc_cl_http_whitelist

function LIB.IsInstalled()
	return istable(CFCHTTP)
end

function LIB.CanCheckWhitelist()
	if not LIB.IsInstalled() then
		return false
	end

	if not isfunction(CFCHTTP.GetOptionsForURL) then
		return false
	end

	return true
end

function LIB.CanLog()
	if not LIB.IsInstalled() then
		return false
	end

	if not isfunction(CFCHTTP.GetOptionsForURL) then
		return false
	end

	if not isfunction(CFCHTTP.LogRequest) then
		return false
	end

	return true
end

local function logUrl(url, options)
	if not LIB.CanLog() then
		return
	end

	-- Reimplemented as in:
	-- https://github.com/CFC-Servers/cfc_cl_http_whitelist/blob/265ce54eea0f386c6eb0390fe31f329f905b9d1f/lua/cfc_http_restrictions/wraps/playURL.lua#L15C1-L19C48

	local stack = string.Split( debug.traceback(), "\n" )

	local isAllowed = options and options.allowed
	local noisy = options and options.noisy

	local logData = {
		noisy = noisy,
		method = "GET",
		fileLocation = stack[4],
		urls = {
			{
				url = url,
				status = isAllowed and "allowed" or "blocked"
			}
		},
	}

	CFCHTTP.LogRequest(logData)
end

function LIB.LogRequestForURL(url)
	if not LIB.CanLog() then
		return
	end

	local options = CFCHTTP.GetOptionsForURL(url)

	logUrl(url, options)
end

function LIB.IsAllowedSync(url, logFailure)
	if not LIB.CanCheckWhitelist() then
		return true
	end

	if StreamRadioLib.Url.IsOfflineURL(url) then
		-- Offline file paths are always safe to use
		return true
	end

	local options = CFCHTTP.GetOptionsForURL(url)
	local isAllowed = options and options.allowed

	if isAllowed then
		return true
	end

	if logFailure then
		logUrl(url, options)
	end

	return false
end

function LIB.IsAllowedAsync(url, callback, logFailure)
	url = tostring(url or "")
	callback = callback or g_emptyFunction

	local result = LIB.IsAllowedSync(url, logFailure)
	callback(result)
end

local function addCfcErrorCodes()
	-- Handle CFC HTTP Whitelist custom error cases

	if CFCHTTP.BASS_ERROR_BLOCKED_URI then
		StreamRadioLib.Error.AddStreamErrorCode({
			id = CFCHTTP.BASS_ERROR_BLOCKED_URI,
			name = "STREAM_ERROR_CFCHTTP_BLOCKED_URI",
			description = "[CFC HTTP Whitelist] URI has been blocked",
			helpurl = "https://steamcommunity.com/workshop/filedetails/discussion/246756300/3884977551668766829/",
			helptext = [[
On this server you are protected by CFC HTTP Whitelist.

This URL has been blocked by CFC HTTP Whitelist to prevent abuse.

You can whitelist the URL (or its domain) for your client in the CFC HTTP Whitelist settings.
BE CAREFUL WITH WHAT YOU WHITELIST! Only whitelist URLs you trust! See your console for details.

You can also ask an admin to whitelist the URL in general in their CFC HTTP Whitelist config.
Keep in mind that there probably is a reason why it has not been whitelisted on this server yet.
]],
		})
	end

	if CFCHTTP.BASS_ERROR_BLOCKED_CONTENT then
		StreamRadioLib.Error.AddStreamErrorCode({
			id = CFCHTTP.BASS_ERROR_BLOCKED_CONTENT,
			name = "STREAM_ERROR_CFCHTTP_BLOCKED_CONTENT",
			description = "[CFC HTTP Whitelist] Content has been blocked",
			helpurl = "https://steamcommunity.com/workshop/filedetails/discussion/246756300/3884977551668766829/",
			helptext = [[
On this server you are protected by CFC HTTP Whitelist.

This content has been blocked by CFC HTTP Whitelist to prevent abuse.
The content you are trying to play from contains one or more URLs that have not been whitelisted yet.

You can whitelist the URLs (or their domains) for your client in the CFC HTTP Whitelist settings.
BE CAREFUL WITH WHAT YOU WHITELIST! Only whitelist URLs you trust! See your console for details.

You can also ask an admin to whitelist the content in general in their CFC HTTP Whitelist config.
Keep in mind that there probably is a reason why it has not been whitelisted on this server yet.
]],
		})
	end
end

function LIB.Load()
	if not LIB.IsInstalled() then
		return
	end

	addCfcErrorCodes()
end

return true


--PATH lua/streamradio_core/client/cl_presets.lua:
return gluapack()()
--PATH lua/streamradio_core/client/cl_menu.lua:
local StreamRadioLib = StreamRadioLib

StreamRadioLib.Menu = StreamRadioLib.Menu or {}

local LIB = StreamRadioLib.Menu
table.Empty(LIB)

function LIB.GetLinkButton(text, urlStr)
	text = tostring(text or "")

	local button = vgui.Create("DButton")

	button.SetURL = function(this, url)
		url = tostring(url or "")
		url = string.Trim(url)

		this._url = url

		if url == "" then
			button:SetTooltip(text)
			return
		end

		button:SetTooltip(text .. "\n\nURL: " .. url .. "\n\nRight click to copy the URL to clipboard.")
	end

	button.GetURL = function(this)
		local url = tostring(this._url or "")
		return url
	end

	button:SetURL(urlStr)

	button.DoClick = function(this)
		local url = this:GetURL()

		if url == "" then
			return
		end

		this._infoWasPressed = true

		gui.OpenURL(url)
	end

	button.DoRightClick = function(this)
		local url = this:GetURL()

		if url == "" then
			return
		end

		SetClipboardText(url)
	end

	local oldThink = button.Think
	local infoRed = Color(160, 0, 0)

	button.Think = function(this)
		if oldThink then
			oldThink(this)
		end

		local lastGameMenuVisible = this._gameMenuVisible
		local gameMenuVisible = gui.IsGameUIVisible()
		this._gameMenuVisible = gameMenuVisible

		if lastGameMenuVisible == gameMenuVisible then
			return
		end

		local addInfo = gameMenuVisible and this._infoWasPressed

		this:SetDisabled(addInfo)

		if addInfo then
			if StreamRadioLib.VR.IsActive(ply) then
				this:SetText(text .. "\n[Please confirm on monitor]")
			else
				this:SetText(text .. "\n[Please confirm]")
			end

			this:SetTextColor(infoRed)
		else
			this._infoWasPressed = nil

			this:SetTextColor(nil)
			this:SetText(text)
			this:SetDark(true)
		end

		StreamRadioLib.VR.RenderMenu(this)
	end

	button:Think()
	button:SetImage("icon16/world_go.png")
	button:SetTall(35)

	return button
end

function LIB.GetAdminButton(label, ignoreVR)
	local button = vgui.Create("DButton")

	local function handleAdmin(this)
		local lastIsAdmin = this._isAdmin

		local isAdmin = StreamRadioLib.Util.IsAdmin()
		this._isAdmin = isAdmin

		return lastIsAdmin == isAdmin, isAdmin
	end

	local function handleVR(this)
		if not ignoreVR then
			return false, false
		end

		local lastIsVR = this._isVR

		local isVR = StreamRadioLib.VR.IsActive()
		this._isVR = isVR

		return lastIsVR == isVR, isVR
	end

	local oldThink = button.Think
	button.Think = function(this)
		if oldThink then
			oldThink(this)
		end

		local changeAdmin, isAdmin = handleAdmin(this)
		local changeVR, isVR = handleVR(this)

		if not changeAdmin and not changeVR then
			return
		end

		local locked = isVR or not isAdmin

		this:SetDisabled(locked)

		local tooltip = label
		local text = label

		if locked then
			tooltip = tooltip .. " (not available)"

			if not isAdmin then
				tooltip = tooltip .. "\n - You must be an admin!"
				text = text .. " (Admin only!)"
			end

			if isVR then
				tooltip = tooltip .. "\n - You must not be in VR!"
				text = text .. " (Not in VR!)"
			end
		end

		this:SetTooltip(tooltip)
		this:SetText(text)

		StreamRadioLib.VR.RenderMenu(this)
	end

	button:Think()

	return button
end

function LIB.AddDangerButton(label, data)
	local button = LIB.GetAdminButton(label)

	local message = tostring(data.message or "")
	local icon = data.icon or "icon16/error.png"

	if message ~= "" then
		message = message .. "\nThis can not be undone!"
	end

	button.DoClick = function(this)
		Derma_Query(message, label, "Yes", function()
			RunConsoleCommand(data.cmd)
		end, "No" )
	end

	button:SetImage(icon)

	return button
end

function LIB.GetLabel(text)
	local label = vgui.Create("DLabel")

	label:SetText(text)
	label:SetTooltip(text)

	label:SetWrap(true)
	label:SetDark(true)

	label:SetAutoStretchVertical(true)
	label:SizeToContents()

	return label
end

function LIB.GetWarnLabel(text)
	local label = LIB.GetLabel(text)

	label:SetDark(false)
	label:SetHighlight(true)

	return label
end

function LIB.GetImportantLabel(text)
	local label = LIB.GetLabel(text)

	local skindata = label:GetSkin()

	label:SetTextColor(skindata.Colours.Tree.Hover)

	return label
end


function LIB.GetWhitelistEnabledLabel(text)
	local label = LIB.GetImportantLabel(text)

	local function handleWhitelistEnabled(this)
		local lastisUrlWhitelistEnabled = this._isUrlWhitelistEnabled

		local isUrlWhitelistEnabled = StreamRadioLib.IsUrlWhitelistEnabled() or StreamRadioLib.Cfchttp.CanCheckWhitelist()
		this._isUrlWhitelistEnabled = isUrlWhitelistEnabled

		return lastisUrlWhitelistEnabled == isUrlWhitelistEnabled, isUrlWhitelistEnabled
	end

	local timerName = "GetWhitelistEnabledLabelThink_" .. tostring(label)

	StreamRadioLib.Timer.Interval(timerName, 1, 0, function()
		-- We use this timer as think is not called on label:SetVisible(false).

		if not IsValid(label) then
			StreamRadioLib.Timer.Remove(timerName)
			return
		end

		local changeisWhitelistEnabled, isUrlWhitelistEnabled = handleWhitelistEnabled(label)

		if not changeisWhitelistEnabled then
			return
		end

		if isUrlWhitelistEnabled then
			label:SetVisible(true)
		else
			label:SetVisible(false)
		end

		local parent = label:GetParent()
		if IsValid(parent) then
			parent:InvalidateLayout()
			StreamRadioLib.VR.RenderMenu(parent)
		end

		label:InvalidateLayout()
		StreamRadioLib.VR.RenderMenu(label)
	end)

	return label
end

function LIB.GetCreditsPanel()
	local credits = LIB.GetLabel(StreamRadioLib.AddonPrefix .. "Made by Grocel")
	return credits
end

function LIB.GetVRInfoPanel()
	local vrinfo = LIB.GetLabel("Powered by VRMod!\n  - VRMod is made by Catse\n  - VR Headset required!\n  - VR is optional, this addon works without VR.")
	return vrinfo
end

function LIB.GetVRErrorPanel()
	local vrinfo = LIB.GetWarnLabel((StreamRadioLib.AddonPrefix or "") .. "\nVRMod is not loaded.\n  - Install VRMod to enable VR support.\n  - VR Headset required!\n  - VR is optional, this addon works without VR.")
	return vrinfo
end

function LIB.GetSpacer(height)
	height = tonumber(height or 0) or 0

	if height <= 0 then
		height = 10
	end

	local spacer = vgui.Create("DPanel")

	spacer:SetMouseInputEnabled(false)
	spacer:SetPaintBackgroundEnabled(false)
	spacer:SetPaintBorderEnabled(false)
	spacer:SetPaintBackground(false)

	spacer:DockMargin(0, 0, 0, 0)
	spacer:DockPadding(0, 0, 0, 0)

	spacer:SetHeight(height)

	return spacer
end

function LIB.GetSpacerLine()
	local spacer = vgui.Create("DPanel")

	spacer.Paint = function( p, w, h )
		derma.SkinHook( "Paint", "MenuSpacer", p, w, h )
	end

	spacer:DockMargin(0, 0, 0, 0)
	spacer:DockPadding(0, 0, 0, 0)

	spacer:SetHeight(1)

	return spacer
end

function LIB.GetFAQButton()
	local button = LIB.GetLinkButton("Show FAQ (Workshop)", "https://steamcommunity.com/workshop/filedetails/discussion/246756300/368542844488661960/")
	return button
end

function LIB.GetWhitelistFAQButton()
	local button = LIB.GetLinkButton("Show Whitelist Info (Workshop)", "https://steamcommunity.com/workshop/filedetails/discussion/246756300/3884977551668761564/")
	return button
end

function LIB.GetCFCWhitelistFAQButton()
	local button = LIB.GetLinkButton("Show CFC HTTP Whitelist Info (Workshop)", "https://steamcommunity.com/workshop/filedetails/discussion/246756300/3884977551668766829/")
	return button
end

function LIB.GetVRFAQButton()
	local button = LIB.GetLinkButton("Show VR FAQ (Workshop)", "https://steamcommunity.com/workshop/filedetails/discussion/246756300/2247805152838837222/")
	return button
end

function LIB.GetVRAddonButton()
	local button = LIB.GetLinkButton("Download VRMod (Workshop)", "https://steamcommunity.com/sharedfiles/filedetails/?id=1678408548")
	return button
end

function LIB.GetVRAddonPanelButton()
	local button = vgui.Create("DButton")

	local maintext = "Show VRMod Panel"

	button.DoClick = function(this)
		RunConsoleCommand("vrmod")
	end

	button:SetTooltip(maintext)
	button:SetText(maintext)

	return button
end

function LIB.GetPlaylistEditorButton()
	local button = LIB.GetAdminButton("Show Playlist Editor")

	button.DoClick = function(this)
		RunConsoleCommand("cl_streamradio_playlisteditor")
	end

	return button
end

function LIB.GetOpenToolButton()
	local button = vgui.Create("DButton")

	local maintext = "Stream Radio Tool"

	button.DoClick = function(this)
		spawnmenu.ActivateTool("streamradio", false)

		local parent = this:GetParent()
		if IsValid(parent) then
			parent:InvalidateLayout()
			StreamRadioLib.VR.RenderMenu(parent)
		end
	end

	button:SetTooltip(maintext)
	button:SetText(maintext)

	return button
end

function LIB.GetOpenSettingsButton()
	local button = vgui.Create("DButton")

	local maintext = "General Settings"

	button.DoClick = function(this)
		spawnmenu.ActivateTool("StreamRadioSettingsPanel_general", true)

		local parent = this:GetParent()
		if IsValid(parent) then
			parent:InvalidateLayout()
			StreamRadioLib.VR.RenderMenu(parent)
		end
	end

	button:SetTooltip(maintext)
	button:SetText(maintext)

	return button
end

function LIB.GetOpenAdminSettingsButton()
	local button = LIB.GetAdminButton("Admin Settings", true)

	button.DoClick = function(this)
		spawnmenu.ActivateTool("StreamRadioSettingsPanel_admin", true)

		local parent = this:GetParent()
		if IsValid(parent) then
			parent:InvalidateLayout()
			StreamRadioLib.VR.RenderMenu(parent)
		end
	end

	return button
end

function LIB.PatchComboBox(combobox, label)
	local parent = label:GetParent()

	if IsValid(parent) then
		parent:SetTall(35)
	end

	local updateIcon = function()
		local index = combobox:GetSelectedID()

		if not combobox.ChoiceIcons then
			return
		end

		combobox:SetIcon(combobox.ChoiceIcons[index])
	end

	local oldSetText = combobox.SetText
	combobox.SetText = function(this, ...)
		if oldSetText then
			oldSetText(this, ...)
		end

		StreamRadioLib.Timedcall(updateIcon)
	end

	StreamRadioLib.Timedcall(updateIcon)
	return combobox
end

return true


--PATH lua/streamradio_core/client/settings/general.lua:
return gluapack()()
--PATH lua/streamradio_core/client/cl_vgui.lua:
return gluapack()()
--PATH lua/streamradio_core/interfaces/online.lua:
local RADIOIFACE = RADIOIFACE
if not istable( RADIOIFACE ) then
	StreamRadioLib.Interface.Load()
	return
end

RADIOIFACE.name = "Online"
RADIOIFACE.priority = -100000
RADIOIFACE.online = true
RADIOIFACE.cache = false

RADIOIFACE.downloadTimeout = 0
RADIOIFACE.downloadFirst = false
RADIOIFACE.allowCaching = true

local LIBUrl = StreamRadioLib.Url

function RADIOIFACE:CheckURL(url)
	if LIBUrl.IsOfflineURL(url) then
		return false
	end

	return true
end

function RADIOIFACE:Convert(url, callback)
	callback(self, true, url)
	return
end

return true


--PATH lua/streamradio_core/filesystem/_generic.lua:
local RADIOFS = RADIOFS
if not istable( RADIOFS ) then
	StreamRadioLib.Filesystem.Load()
	return
end

RADIOFS.name = "generic"
RADIOFS.type = ":generic"
RADIOFS.icon = StreamRadioLib.GetPNGIcon("table_sound", true)

RADIOFS.priority = -1
RADIOFS.loadToWhitelist = true

function RADIOFS:Find(globalpath, vfolder)
	return nil
end

function RADIOFS:Delete(globalpath, vpath, callback)
	return false
end

function RADIOFS:Exists(globalpath, vpath)
	return false
end

return true


--PATH lua/streamradio_core/filesystem/vdf.lua:
local RADIOFS = RADIOFS
if not istable( RADIOFS ) then
	StreamRadioLib.Filesystem.Load()
	return
end

RADIOFS.name = "VDF"
RADIOFS.type = "vdf"
RADIOFS.extension = "vdf"
RADIOFS.icon = StreamRadioLib.GetPNGIcon("table_sound", true)

RADIOFS.priority = 1000
RADIOFS.loadToWhitelist = true

function RADIOFS:Read(globalpath, vpath, callback)
	file.AsyncRead(globalpath, "DATA", function(fileName, gamePath, status, data)
		if status ~= FSASYNC_OK then
			callback(false, nil)
			return
		end

		local RawPlaylist = string.Trim(data or "")
		if RawPlaylist == "" then
			callback(true, {})
			return
		end

		local Playlist = util.KeyValuesToTable(RawPlaylist, false, true) or {}

		callback(true, Playlist)
	end)

	return true
end

function RADIOFS:Write(globalpath, vpath, data, callback)
	if not self:CreateDirectoryForFile(globalpath) then
		callback(false)
		return false
	end

	local f = file.Open(globalpath, "w", "DATA")
	if not f then
		callback(false)
		return false
	end

	local DataString = util.TableToKeyValues(data)
	DataString = string.Trim(DataString)
	DataString = DataString .. "\n\n"

	f:Write(DataString)
	f:Close()

	callback(true)
	return true
end

return true


--PATH addons/[miecze] mexicano_drzewko/lua/autorun/sv_timer.lua:
if not SERVER then return end

MX_CatJedi = "JEDI"

timer.Create("MX_LSCS.Timer", MX_LSCS.timertime, 0, function()
    for _, ply in ipairs(player.GetAll()) do
        
        if not IsValid(ply) then continue end 
        
        
        local teamData = RPExtraTeams[ply:Team()]
        if teamData and (teamData.category == MX_CatJedi or teamData.jedi == true) then 
            
            ply:addPunkty(MX_LSCS.howmuchxp)
        end
    end
end)
--PATH addons/[chat] talk-modes/lua/talk_modes/language/sh_spanish.lua:
--[[-------------------------------------------

    Talk Modes - whisper/talk/yell 

    Licensed to 76561198327810923
	Version: 1.1.1

	By: SaturdaysHeroes & Djuk
	Special thanks to CupCakeR

--]]-------------------------------------------

local LANGUAGE = {}
LANGUAGE["General"] = "General"
LANGUAGE["Theme"] = "Tema"
LANGUAGE["Modes"] = "Modos"
LANGUAGE["Whisper"] = "Susurro"
LANGUAGE["Whisper_Desc"] = "Qu distancia debe alcanzar Whisper?"
LANGUAGE["Yell"] = "Grito"
LANGUAGE["Yell_Desc"] = "Qu distancia debe alcanzar Yell?"
LANGUAGE["Talk"] = "Hablar"
LANGUAGE["Talk_Desc"] = "A qu distancia debe llegar Talk?"
LANGUAGE["3D Voice"] = "Voz 3D"
LANGUAGE["3D Voice_Desc"] = "Se debe activar 3D Voice?"
LANGUAGE["Language"] = "Idioma"
LANGUAGE["Language_Desc"] = "Qu idioma se debe usar?"
LANGUAGE["Selection Key"] = "Clave de seleccin"
LANGUAGE["Selection Key_Desc"] = "Qu tecla debera abrir el men de seleccin?"
LANGUAGE["Talking Dead"] = "Hablando muerta"
LANGUAGE["Talking Dead_Desc"] = "Deberan las personas fallecidas poder hablar?"
LANGUAGE["Selection Menu Position"] = "Posicin del men de seleccin"
LANGUAGE["Selection Menu Position_Desc"] = "Dnde debe ubicarse el men?"
LANGUAGE["Save"] = "Salvar"
LANGUAGE["Reset"] = "Reiniciar"
LANGUAGE["Preview"] = "Preestreno"
LANGUAGE["PreviewHeader"] = "PRESIONE [%s] PARA SALIR DE LA VISTA PREVIA"
LANGUAGE["PreviewText"] = "RANGO ACTUALMENTE PREVIO: %s UNIDADES"
LANGUAGE["Background"] = "Antecedentes"
LANGUAGE["Background_Desc"] = "Qu color debe usarse para el fondo?"
LANGUAGE["Foreground"] = "Primer plano"
LANGUAGE["Foreground_Desc"] = "Qu color debe usarse para el primer plano?"
LANGUAGE["Hover"] = "Acento"
LANGUAGE["Hover_Desc"] = "Qu color debe usarse para el acento?"
LANGUAGE["White"] = "Blanco"
LANGUAGE["White_Desc"] = "Qu color debe usarse como blanco?"
LANGUAGE["Gray"] = "Gris"
LANGUAGE["Gray_Desc"] = "Qu color debe usarse como gris?"
LANGUAGE["WelcomeMessage"] = "Este servidor est utilizando la secuencia de comandos de los modos de conversacin, mantenga presionado %s para seleccionar su modo de conversacin."
LANGUAGE["Turn Off"] = "Apagar"
LANGUAGE["Using Mode"] = "Modo activo"
LANGUAGE["Auto-Hide"] = "Auto Hide"
LANGUAGE["Auto-Hide_Desc"] = "Should selection menu automatically hide when unused?"
LANGUAGE["Mode Change Message"] = "Mode Notification"
LANGUAGE["Mode Change Message_Desc"] = "Should players be notified when their talk mode is changed?"

TalkModes.Languages:Register("Espaol", LANGUAGE)
--PATH addons/[chat] talk-modes/lua/talk_modes/vgui/elements/cl_colorpicker.lua:
local circles = include("talk_modes/vgui/libs/cl_circles.lua")
local THEME = TalkModes.Client.ActiveTheme

local PANEL = {}
AccessorFunc(PANEL, "value", "Value")
function PANEL:Init()
    self.R = self:Add("TalkModes.Slider")
    self.R:SetColor(Color(192, 57, 43))
    self.R:SetPos(6, 60)
    self.R:SetMinMax(0, 255)
    self.G = self:Add("TalkModes.Slider")
    self.G:SetColor(Color(39, 174, 96))
    self.G:SetPos(6, 80)
    self.G:SetMinMax(0, 255)
    self.B = self:Add("TalkModes.Slider")
    self.B:SetColor(Color(41, 128, 185))
    self.B:SetPos(6, 100)
    self.B:SetMinMax(0, 255)

    self.preview = self:Add("DPanel")
    self.preview:SetSize(56, 56)
    self.preview:SetPos(300, 60)
    self.preview.Paint = function(_, intW, intH)
        surface.SetDrawColor(Color(20, 20, 20))
        surface.DrawRect(0, 0, intW, intH)
        surface.SetDrawColor(self:GetValue())
        surface.DrawRect(2, 2, intW-4, intH-4)
    end
end
function PANEL:UpdateColors()
    self.R:SetValue(self:GetValue().r)
    self.G:SetValue(self:GetValue().g)
    self.B:SetValue(self:GetValue().b)
end

function PANEL:Think()
    self:SetValue(Color(self.R:GetValue(), self.G:GetValue(), self.B:GetValue()))
end
vgui.Register("TalkModes.ColorPicker", PANEL, "EditablePanel")

--PATH addons/[chat] talk-modes/lua/talk_modes/vgui/elements/cl_settingsbase.lua:
local circles = include("talk_modes/vgui/libs/cl_circles.lua")
local THEME = TalkModes.Client.ActiveTheme
local SETTING_TYPES = {
    ["Language"] = "String",
    ["Selection Key"] = "UInt",
	["3D Voice"] = "Bool",
	["Talking Dead"] = "Bool",
    ["Selection Menu Position"] = "String",
    ["Auto-Hide"] = "Bool",
    ["Whisper"] = "UInt",
    ["Talk"] = "UInt",
    ["Yell"] = "UInt",
    ["White"] = "Color",
    ["Gray"] = "Color",
    ["Background"] = "Color",
    ["Foreground"] = "Color",
    ["Hover"] = "Color",
    ["Mode Change Message"] = "Bool"
}

local PANEL = {}
AccessorFunc(PANEL, "page_name", "PageName")
function PANEL:Init()
    self.tblSettings = {}
    self.docker = self:GetParent()
    self.base = self.docker:GetParent()

    self.scroll = self:Add("DScrollPanel")
    self.scroll:Dock(FILL)
    self.scroll:DockMargin(6, 6, 6, 0)
    self.scroll.Paint = function(this, intW, intH)
        draw.RoundedBox(2, 0, 0, intW, intH, THEME["Background"])
    end

    self.scroll.bar = self.scroll:GetVBar()
    self.scroll.bar:SetWidth(4)
    self.scroll.bar.Paint = function(this, intW, intH)
        draw.RoundedBox(2, 0, 0, intW, intH, THEME["Background"])
    end
    self.scroll.bar.btnGrip:SetCursor("Hand")
    self.scroll.bar.btnGrip.Paint = function(this, intW, intH)
        draw.RoundedBox(2, 0, 0, intW, intH, THEME["Hover"])
    end
    self.scroll.bar.btnUp.Paint = nil
    self.scroll.bar.btnDown.Paint = nil

    self.footer = self:Add("DPanel")
    self.footer:Dock(BOTTOM)
    self.footer:SetHeight(36)
    self.footer.Paint = function(self, intW, intH)
        draw.RoundedBoxEx(6, 0, 0, intW, intH, THEME["Background"], false, false, false, true)
    end

    self.save = self.footer:Add("DButton")
    self.save:SetSize(150, 28)
    self.save:SetText("")
    self.save.Alpha = 90
    self.save.Paint = function(self, intW, intH)
        self.Alpha = Lerp(FrameTime() * 8, self.Alpha, self:IsHovered() && 255 || 90)
        draw.RoundedBox(6, 0, 0, intW, intH, Color(39, 174, 96, self.Alpha))
        draw.SimpleText(string.upper(TalkModes.Languages:GetPhrase("Save")), "TalkModes:Small", intW/2, intH/2, THEME["White"], TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
    end
    self.save.DoClick = function()
        self.tblUpdatedSettings = {}
        self.tblUpdatedSettings[self:GetPageName()] = {}
        for k, v in SortedPairs(self.tblSettings) do 
            local child = v:GetChildren()[1]
            self.tblUpdatedSettings[self:GetPageName()][v.strSetting] = child:GetValue()
        end
        
        for i, v in SortedPairs(self.tblUpdatedSettings[self:GetPageName()]) do 
            net.Start("TalkModes.Config.UpdateSetting")
                net.WriteString(self:GetPageName()..":"..i)
                net["Write"..SETTING_TYPES[i]](v, 32)
            net.SendToServer()
        end
    end

    self.reset = self.footer:Add("DButton")
    self.reset:SetSize(150, 28)
    self.reset:SetText("")
    self.reset.Alpha = 90
    self.reset.Paint = function(self, intW, intH)
        self.Alpha = Lerp(FrameTime() * 8, self.Alpha, self:IsHovered() && 255 || 90)
        draw.RoundedBox(6, 0, 0, intW, intH, Color(243, 156, 18, self.Alpha))
        draw.SimpleText(string.upper(TalkModes.Languages:GetPhrase("Reset")), "TalkModes:Small", intW/2, intH/2, THEME["White"], TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
    end
    self.reset.DoClick = function()
        net.Start("TalkModes.Config.ResetSettings")
        net.SendToServer()
        self.base:Close()
    end
    
    self.footer.PerformLayout = function(this, intW, intH)
        self.reset:SetPos(intW/2 - self.reset:GetWide() - 2, 4)
        self.save:SetPos(intW/2 + 2, 4)
    end
end

function PANEL:Paint(intW, intH)
    draw.RoundedBoxEx(6, 0, 0, intW, intH, THEME["Foreground"], false, false, false, true)
end

function PANEL:RefreshSettings()
    if (self.tblSettings) then
        for _,v in SortedPairs(self.tblSettings) do
            v:Remove()
        end
    end
    self.tblSettings = {}

    self.tblServerSettings = {}
    for k, v in SortedPairs(TalkModes.Config:GetTable(self:GetPageName())) do
        self.tblServerSettings[k] = v
    end

    for a, b in SortedPairs(self.tblDefaultSettings) do
        for c, d in SortedPairs(self.tblServerSettings) do
            if (a == c) then
                self.tblDefaultSettings[a].uValue = d
            end
        end
    end
    for k, v in SortedPairs(self.tblDefaultSettings) do
        self:AddSetting(v.strType, k, v.strDesc, v.uValue, v.tblData)
    end
end

function PANEL:AddSetting(strType, strTitle, strDesc, uValue, tblData)
    self.settingsPanel = self.scroll:Add("EditablePanel")
    self.settingsPanel:Dock(TOP)
    self.settingsPanel:DockMargin(6, 6, 6, 0)
    self.settingsPanel:SetKeyboardInputEnabled(true)
    self.settingsPanel.strSetting = strTitle
    this = self.settingsPanel
    this.Paint = function(this, intW, intH)
        draw.RoundedBox(6, 0, 0, intW, intH, THEME["Foreground"])
        draw.SimpleText(TalkModes.Languages:GetPhrase(strTitle), "TalkModes:Medium", 6, 6, THEME["White"])
        local _, intH = surface.GetTextSize(TalkModes.Languages:GetPhrase(strTitle))
        draw.SimpleText(TalkModes.Languages:GetPhrase(strDesc), "TalkModes:Small", 6, 6 + intH, THEME["Gray"])
    end

    if (strType == "tText") then
        this:SetHeight(100)
        this.textEntry = this:Add("TalkModes.TextEntry")
        this.textEntry:SetPos(8, 100 - 32 - 6)
        this.textEntry:SetSize(128, 32)
        this.textEntry:SetValue(uValue)
    end

    if (strType == "tSwitch") then
        this:SetHeight(100)
        this.switch = this:Add("TalkModes.Switch")
        this.switch:SetPos(12, 100 - 6 - 32)
        this.switch:SetValue(uValue)
    end

    if (strType == "tColor") then
        this:SetHeight(125)
        this.colorPicker = this:Add("TalkModes.ColorPicker")
        this.colorPicker:Dock(FILL)
        this.colorPicker:SetValue(uValue)
        this.colorPicker:UpdateColors()
    end

    if (strType == "tDropdown") then
        this:SetHeight(100)
        this.dropdown = this:Add("TalkModes.Dropdown")
        this.dropdown:SetPos(8, 100 - 6 - 32)
        this.dropdown:SetValue(uValue)
        this.dropdown.intW, this.dropdown.intH = this.dropdown:GetContentSize()
        this.dropdown:SetSize(this.dropdown.intW + 24, this.dropdown.intH + 4)
        for k, _ in pairs(tblData) do
            this.dropdown:AddChoice(k, v)
        end
    end

    if (strType == "tBinder") then
        this:SetHeight(100)
        this.binder = this:Add("TalkModes.Binder")
        this.binder:SetSize(64, 24)
        this.binder:SetPos(8, 100 - 6 - 32)
        this.binder:SetValue(uValue)
    end
    
    if (strType == "tSlider") then
        this:SetHeight(100)
        this.slider = this:Add("TalkModes.PreviewSlider")
        this.slider:Dock(FILL)
        this.slider.slider:SetMinMax(0, 2000)
        this.slider:SetValue(uValue)
        this.slider:RefreshValue()
    end

    self.tblSettings[#self.tblSettings + 1] = this
end
vgui.Register("TalkModes.SettingsBase", PANEL, "EditablePanel")



--PATH addons/[chat] talk-modes/lua/talk_modes/vgui/libs/cl_spheres.lua:
local color_mask2 = Color(0, 0, 0, 0)

local function drawStencilSphere( pos, ref, compare_func, radius, color, detail )
    render.SetStencilReferenceValue( ref )
    render.SetStencilCompareFunction( compare_func )
    render.DrawSphere(pos, radius, detail, detail, color)
end

function render.StartWorldRings()
    render.WORLD_RINGS = {}
    cam.IgnoreZ(false)
    render.SetStencilEnable(true)
    render.SetStencilTestMask(255)
    render.SetStencilWriteMask(255)
    render.ClearStencil()
    render.SetColorMaterial()
end

function render.AddWorldRing(pos, radius, thicc, detail)
    detail = detail or 25
    thicc = thicc or 10
    local z = {detail=detail, thicc=thicc, pos=pos, outer_r=radius, inner_r=math.max(radius-thicc,0)}
    table.insert(render.WORLD_RINGS, z)
end

function render.FinishWorldRings(color)
    local ply = LocalPlayer()
    local zones = render.WORLD_RINGS
   
    render.SetStencilZFailOperation( STENCILOPERATION_REPLACE )
   
    for i, zone in ipairs(zones) do
        local outer_r = zone.radius
        drawStencilSphere(zone.pos, 1, STENCILCOMPARISONFUNCTION_ALWAYS, -zone.outer_r, color_mask2, zone.detail ) -- big, inside-out
    end
    render.SetStencilZFailOperation( STENCILOPERATION_DECR )
    for i, zone in ipairs(zones) do
        local outer_r = zone.radius
        drawStencilSphere(zone.pos, 1, STENCILCOMPARISONFUNCTION_ALWAYS, zone.outer_r, color_mask2, zone.detail ) -- big
    end
    render.SetStencilZFailOperation( STENCILOPERATION_INCR )
    for i, zone in ipairs(zones) do
        drawStencilSphere(zone.pos, 1, STENCILCOMPARISONFUNCTION_ALWAYS, -zone.inner_r, color_mask2, zone.detail ) -- small, inside-out
    end
    render.SetStencilZFailOperation( STENCILOPERATION_DECR )
    for i, zone in ipairs(zones) do
        drawStencilSphere(zone.pos, 1, STENCILCOMPARISONFUNCTION_ALWAYS, zone.inner_r, color_mask2, zone.detail ) -- small
    end
    render.SetStencilCompareFunction( STENCILCOMPARISONFUNCTION_EQUAL )
   
    local cam_pos = ply:EyePos()
    local cam_angle = ply:EyeAngles()
    local cam_normal = cam_angle:Forward()
    cam.IgnoreZ(true)
    render.SetStencilReferenceValue( 1 )
    render.DrawQuadEasy(cam_pos + cam_normal * 10, -cam_normal, 10000, 10000, color, cam_angle.roll)
    cam.IgnoreZ(false)
    render.SetStencilEnable(false)
end
--PATH lua/autorun/textscreens_util.lua:
local function checkAdmin(ply)
	-- The server console always has access. `ply` is NULL in this case
	local isConsole = ply == nil or ply == NULL
	if isConsole then
		return true
	end
	local canAdmin = hook.Run("TextscreensCanAdmin", ply) -- run custom hook function to check admin
	if canAdmin == nil then -- if hook hasn't returned anything, default to super admin check
		canAdmin = ply:IsSuperAdmin()
	end
	return canAdmin
end

-- allow servers to disable rainbow effect for everyone
CreateConVar("ss_enable_rainbow", 1, {FCVAR_NOTIFY, FCVAR_REPLICATED}, "Determines whether rainbow textscreens will render for all clients. When disabled, rainbow screens will render as solid white.", 0, 1)

-- allow servers to restrict the number of characters per line for everyone
CreateConVar("ss_max_characters", 0, {FCVAR_NOTIFY, FCVAR_REPLICATED}, "Determines the maximum number of characters per line for all clients. When set to 0, the maximum number of characters is infinite.", 0)

if SERVER then
	AddCSLuaFile()
	AddCSLuaFile("textscreens_config.lua")
	include("textscreens_config.lua")
	CreateConVar("sbox_maxtextscreens", "1", {FCVAR_NOTIFY, FCVAR_REPLICATED}, "Determines the maximum number of textscreens users can spawn.")

	--local rainbow_enabled = cvars.Number('ss_enable_rainbow', 1)

	local function StringRandom(int)
		math.randomseed(os.time())
		local s = ""

		for i = 1, int do
			s = s .. string.char(math.random(65, 90))
		end

		return s
	end

	local textscreens = {}

	local function SpawnPermaTextscreens()
		print("[3D2D Textscreens] Spawning textscreens...")
		textscreens = file.Read("sammyservers_textscreens.txt", "DATA")
		if not textscreens or textscreens == "" then
			textscreens = {}
			print("[3D2D Textscreens] Spawned 0 textscreens for map " .. game.GetMap())
			return
		end
		textscreens = util.JSONToTable(textscreens)

		local existingTextscreens = {}
		for k,v in pairs(ents.FindByClass("sammyservers_textscreen")) do
			if not v.uniqueName then continue end
			existingTextscreens[v.uniqueName] = true
		end

		local count = 0
		for k, v in pairs(textscreens) do
			if v.MapName ~= game.GetMap() then continue end
			if existingTextscreens[v.uniqueName] then continue end

			local textScreen = ents.Create("sammyservers_textscreen")
			textScreen:SetPos(Vector(v.posx, v.posy, v.posz))
			textScreen:SetAngles(Angle(v.angp, v.angy, v.angr))
			textScreen.uniqueName = v.uniqueName
			textScreen:Spawn()
			textScreen:Activate()
			textScreen:SetMoveType(MOVETYPE_NONE)

			for lineNum, lineData in pairs(v.lines or {}) do
				textScreen:SetLine(lineNum, lineData.text, Color(lineData.color.r, lineData.color.g, lineData.color.b, lineData.color.a), lineData.size, lineData.font, lineData.rainbow or 0)
			end

			textScreen:SetIsPersisted(true)
			count = count + 1
		end

		print("[3D2D Textscreens] Spawned " .. count .. " textscreens for map " .. game.GetMap())
	end

	hook.Add("InitPostEntity", "loadTextScreens", function()
		timer.Simple(10, SpawnPermaTextscreens)
	end)

	hook.Add("PostCleanupMap", "loadTextScreens", SpawnPermaTextscreens)

	-- If a player, use ChatPrint method, else print directly to server console
	local function printMessage(ply, msg)
		local isConsole = ply == nil or ply == NULL
		if isConsole then
			print(msg)
		else
			ply:ChatPrint(msg)
		end
	end
	concommand.Add("SS_TextScreen", function(ply, cmd, args)
		if not checkAdmin(ply) or not args or not args[1] or not args[2] or not (args[1] == "delete" or args[1] == "add") then
			printMessage(ply, "not authorised, or bad arguments")
			return
		end
		local ent = Entity(args[2])
		if not IsValid(ent) or ent:GetClass() ~= "sammyservers_textscreen" then return false end

		if args[1] == "add" then
			local pos = ent:GetPos()
			local ang = ent:GetAngles()
			local toAdd = {}
			toAdd.posx = pos.x
			toAdd.posy = pos.y
			toAdd.posz = pos.z
			toAdd.angp = ang.p
			toAdd.angy = ang.y
			toAdd.angr = ang.r
			-- So we can reference it easily later because EntIndexes are so unreliable
			toAdd.uniqueName = StringRandom(10)
			toAdd.MapName = game.GetMap()
			toAdd.lines = ent.lines
			table.insert(textscreens, toAdd)
			file.Write("sammyservers_textscreens.txt", util.TableToJSON(textscreens))
			ent:SetIsPersisted(true)

			return printMessage(ply, "Textscreen made permanent and saved.")
		else
			for k, v in pairs(textscreens) do
				if v.uniqueName == ent.uniqueName then
					textscreens[k] = nil
				end
			end

			ent:Remove()
			file.Write("sammyservers_textscreens.txt", util.TableToJSON(textscreens))

			return printMessage(ply, "Textscreen removed and is no longer permanent.")
		end
	end)

	-- Add to pocket blacklist for DarkRP
	-- Not using gamemode == "darkrp" because there are lots of flavours of darkrp
	hook.Add("loadCustomDarkRPItems", "sammyservers_pocket_blacklist", function()
		GAMEMODE.Config.PocketBlacklist["sammyservers_textscreen"] = true
	end)
end

if CLIENT then
	include("textscreens_config.lua")

	properties.Add("addPermaScreen", {
		MenuLabel = "Make perma textscreen",
		Order = 2001,
		MenuIcon = "icon16/transmit.png",
		Filter = function(self, ent, ply)
			if not IsValid(ent) or ent:GetClass() ~= "sammyservers_textscreen" then return false end
			if ent:GetIsPersisted() then return false end

			return checkAdmin(ply)
		end,
		Action = function(self, ent)
			if not IsValid(ent) then return false end

			return RunConsoleCommand("SS_TextScreen", "add", ent:EntIndex())
		end
	})

	properties.Add("removePermaScreen", {
		MenuLabel = "Remove perma textscreen",
		Order = 2002,
		MenuIcon = "icon16/transmit_delete.png",
		Filter = function(self, ent, ply)
			if not IsValid(ent) or ent:GetClass() ~= "sammyservers_textscreen" then return false end
			if not ent:GetIsPersisted() then return false end

			return checkAdmin(ply)
		end,
		Action = function(self, ent)
			if not IsValid(ent) then return end

			return RunConsoleCommand("SS_TextScreen", "delete", ent:EntIndex())
		end
	})
end

--PATH lua/autorun/tfa_base_autorun.lua:
if SERVER then AddCSLuaFile() end

TFA = TFA or {}

local version = 4.793
local version_string = "4.7.9.3"
local changelog = [[
	* Fixed suppressed guns emitting light when shooting
	* Added toggles for FOV sprint modifier and first draw animation
	* Added multiplier settings for recoil and knockback (which is no longer controlled by force multiplier)
]]

local function testFunc()
end

local my_path = debug.getinfo(testFunc)
if my_path and type(my_path) == "table" and my_path.short_src then
	my_path = my_path["short_src"]
else
	my_path = "legacy"
end

local official_modules_sorted = {
	"tfa_commands.lua",
	"cl_tfa_commands.lua", -- we need to load clientside convars before anything else

	"tfa_envcheck.lua",

	"tfa_data.lua",
	"tfa_ammo.lua",
	"tfa_attachments.lua",
	"tfa_ballistics.lua",
	"tfa_bodygroups.lua",

	"tfa_darkrp.lua",
	"tfa_effects.lua",
	"tfa_functions.lua",
	"tfa_hooks.lua",
	"tfa_keybinds.lua",
	"tfa_keyvalues.lua",
	"tfa_matproxies.lua",
	"tfa_melee_autorun.lua",
	"tfa_meta.lua",
	"tfa_netcode.lua",
	"tfa_small_entities.lua",
	"tfa_npc_teamcolor.lua",
	"tfa_npc_weaponmenu.lua",
	"tfa_nzombies.lua",
	"tfa_particles.lua",
	"tfa_snd_timescale.lua",
	"tfa_soundscripts.lua",
	"tfa_tttpatch.lua",

	"sv_tfa_settingsmenu.lua", -- TFA.BASE_LOAD_COMPLETE server

	"cl_tfa_attachment_icon.lua",
	"cl_tfa_attachment_panel.lua",
	"cl_tfa_attachment_tip.lua",
	"cl_tfa_changelog.lua",

	"cl_tfa_devtools.lua",
	"cl_tfa_fonts.lua",
	"cl_tfa_hitmarker.lua",
	"cl_tfa_inspection.lua",
	"cl_tfa_materials.lua",
	"cl_tfa_models.lua",
	"cl_tfa_particles_lua.lua",
	"cl_tfa_projtex.lua",
	"cl_tfa_rendertarget.lua",
	"cl_tfa_rtbgblur.lua",
	"cl_tfa_settingsmenu.lua",
	"cl_tfa_vgui.lua",
	"cl_tfa_vm_blur.lua",
	"cl_tfa_stencilsights.lua",
	"cl_tfa_subcategories.lua", -- TFA.BASE_LOAD_COMPLETE client
}

local official_modules = {}

for _, modulename in ipairs(official_modules_sorted) do
	official_modules[modulename] = true
end

TFA_BASE_VERSION = version
TFA_BASE_VERSION_STRING = version_string
TFA_BASE_VERSION_CHANGES = changelog
TFA_FILE_PATH = my_path

TFA.BASE_LOAD_COMPLETE = false

TFA.Enum = TFA.Enum or {}

local flist = file.Find("tfa/enums/*.lua","LUA")

for _, filename in pairs(flist) do
	local typev = "SHARED"

	if filename:StartWith("cl_") then
		typev = "CLIENT"
	elseif filename:StartWith("sv_") then
		typev = "SERVER"
	end

	if SERVER and typev ~= "SERVER" then
		AddCSLuaFile("tfa/enums/" .. filename)
	end

	if SERVER and typev ~= "CLIENT" or CLIENT and typev ~= "SERVER" then
		include("tfa/enums/" .. filename)
	end
end

hook.Run("TFABase_PreEarlyInit")

for _, filename in ipairs(official_modules_sorted) do
	if filename:StartWith("cl_") then
		if SERVER then
			AddCSLuaFile("tfa/modules/" .. filename)
		else
			include("tfa/modules/" .. filename)
		end
	elseif filename:StartWith("sv_") then
		if SERVER then
			include("tfa/modules/" .. filename)
		end
	else
		if SERVER then
			AddCSLuaFile("tfa/modules/" .. filename)
		end

		include("tfa/modules/" .. filename)
	end
end

hook.Run("TFABase_EarlyInit")
hook.Run("TFABase_PreInit")

flist = file.Find("tfa/modules/*.lua", "LUA")
local toload = {}
local toload2 = {}

for _, filename in pairs(flist) do
	if not official_modules[filename] then
		local typev = "SHARED"

		if filename:StartWith("cl_") then
			typev = "CLIENT"
		elseif filename:StartWith("sv_") then
			typev = "SERVER"
		end

		if SERVER and typev ~= "SERVER" then
			AddCSLuaFile("tfa/modules/" .. filename)
		end

		if SERVER and typev == "SERVER" or CLIENT and typev == "CLIENT" then
			table.insert(toload2, filename)
		elseif typev == "SHARED" then
			table.insert(toload, filename)
		end
	end
end

local yell = #toload ~= 0 or #toload2 ~= 0

table.sort(toload)
table.sort(toload2)

for _, filename in ipairs(toload) do
	include("tfa/modules/" .. filename)
	print("[TFA Base] [!] Loaded unofficial module " .. string.sub(filename, 1, -5) .. ".")
end

for _, filename in ipairs(toload2) do
	include("tfa/modules/" .. filename)
	print("[TFA Base] [!] Loaded unofficial module " .. string.sub(filename, 1, -5) .. ".")
end

hook.Run("TFABase_Init")
hook.Run("TFABase_PreFullInit")

flist = file.Find("tfa/external/*.lua", "LUA")
toload = {}
toload2 = {}

for _, filename in pairs(flist) do
	local typev = "SHARED"

	if filename:StartWith("cl_") then
		typev = "CLIENT"
	elseif filename:StartWith("sv_") then
		typev = "SERVER"
	end

	if SERVER and typev ~= "SERVER" then
		AddCSLuaFile("tfa/external/" .. filename)
	end

	if SERVER and typev == "SERVER" or CLIENT and typev == "CLIENT" then
		table.insert(toload2, filename)
	elseif typev == "SHARED" then
		table.insert(toload, filename)
	end
end

table.sort(toload)
table.sort(toload2)

for _, filename in ipairs(toload) do
	include("tfa/external/" .. filename)
end

for _, filename in ipairs(toload2) do
	include("tfa/external/" .. filename)
end

if yell then
	print("[TFA Base] [!] Some of files not belonging to TFA Base were loaded from tfa/modules/ directory")
	print("[TFA Base] This behavior is kept for backward compatiblity and using this is highly discouraged!")
	print("[TFA Base] Files loaded this way have no pre-defined sorting applied and result of execution of those files is undefined.")
	print("[TFA Base] If you are author of these files, please consider moving your modules to tfa/external/ as soon as possible.")
end

hook.Run("TFABase_FullInit")

if not VLL2_FILEDEF then
	TFAUpdateAttachments(false)
end

hook.Run("TFABase_LateInit")
--PATH lua/tfa/enums/idle.lua:
return gluapack()()
--PATH lua/tfa/modules/tfa_data.lua:
return gluapack()()
--PATH lua/tfa/modules/tfa_ballistics.lua:
return gluapack()()
--PATH lua/tfa/modules/tfa_keybinds.lua:
return gluapack()()
--PATH lua/tfa/modules/tfa_particles.lua:
return gluapack()()
--PATH lua/tfa/modules/tfa_particles.lua:
TFA.Particles = TFA.Particles or {}
TFA.Particles.FlareParts = {}
TFA.Particles.VMAttachments = {}

TFA.Particles.PCFParticles = TFA.Particles.PCFParticles or {}

TFA.Particles.PCFParticles["tfa_muzzle_rifle"] = "tfa_muzzleflashes"
TFA.Particles.PCFParticles["tfa_muzzle_sniper"] = "tfa_muzzleflashes"
TFA.Particles.PCFParticles["tfa_muzzle_energy"] = "tfa_muzzleflashes"
TFA.Particles.PCFParticles["tfa_muzzle_energy"] = "tfa_muzzleflashes"
TFA.Particles.PCFParticles["tfa_muzzle_gauss"] = "tfa_muzzleflashes"

-- TFA.Particles.PCFParticles["weapon_muzzle_smoke_long"] = "csgo_fx"
-- TFA.Particles.PCFParticles["weapon_muzzle_smoke"] = "csgo_fx"

TFA.Particles.PCFParticles["tfa_ins2_weapon_muzzle_smoke"] = "tfa_ins2_muzzlesmoke"
TFA.Particles.PCFParticles["tfa_ins2_weapon_shell_smoke"] = "tfa_ins2_shellsmoke"
TFA.Particles.PCFParticles["tfa_bullet_smoke_tracer"] = "tfa_ballistics"
TFA.Particles.PCFParticles["tfa_bullet_fire_tracer"] = "tfa_ballistics"
TFA.Particles.PCFParticles["tfa_ins2_shell_eject"] = "tfa_ins2_ejectionsmoke"

--legacy
TFA.Particles.PCFParticles["smoke_trail_tfa"] = "tfa_smoke"
TFA.Particles.PCFParticles["smoke_trail_controlled"] = "tfa_smoke"

TFA.Particles.SmokeLightingMin = Vector(0.15, 0.15, 0.15)
TFA.Particles.SmokeLightingMax = Vector(0.75, 0.75, 0.75)
TFA.Particles.SmokeLightingClamp = 1

local addedparts = {}
local cachedparts = {}

function TFA.Particles.Initialize()
	for k, v in pairs(TFA.Particles.PCFParticles) do
		if not addedparts[v] then
			game.AddParticles("particles/" .. v .. ".pcf")
			addedparts[v] = true
		end

		if not cachedparts[k] and not string.find(k, "DUMMY") then
			PrecacheParticleSystem(k)
			cachedparts[k] = true
		end
	end
end

hook.Add("InitPostEntity", "TFA.Particles.Initialize", TFA.Particles.Initialize)
TFA.Particles.Initialize()

--PATH lua/tfa/modules/cl_tfa_attachment_panel.lua:
if SERVER then
	AddCSLuaFile()
	return
end

local dimensions, padding
local tooltip_mincount = 1

local PANEL = {}

PANEL.HasInitialized = false
PANEL.Wep = nil
PANEL.Att = nil
PANEL.x = -1
PANEL.y = -1
PANEL.AttachmentTable = {}
PANEL.AttachmentIcons = {}
PANEL.VAtt = 0

function PANEL:Init()
	self.HasInitialized = false
	self.Wep = nil
	self.Att = nil
	self.x = -1
	self.y = -1
	self.AttachmentTable = {}
	self.AttachmentIcons = {}
	self:SetMouseInputEnabled(true)
end

function PANEL:Initialize()
	if not IsValid(self.Wep) then return false end

	if not self.Att then return end

	self.AttachmentTable = self.Wep.Attachments[ self.VAtt ]
	self.VGUIAttachmentTable = self.Wep.VGUIAttachments[ self.VAtt ]

	dimensions = math.Round(TFA.ScaleH(TFA.Attachments.IconSize))
	padding = math.Round(TFA.ScaleH(TFA.Attachments.UIPadding))

	local attCnt = #self.VGUIAttachmentTable.atts
	local truewidth = dimensions * attCnt + padding * ( math.max(0,attCnt-1) + 2 )
	local finalwidth = math.max( truewidth, dimensions * tooltip_mincount + padding * ( math.max(0,tooltip_mincount-1) + 2 ) )

	self:SetSize( finalwidth, dimensions + padding * 2 ) --+ tooltipheightmax + padding * 2 )
	self:DockPadding( 0, 0, 0, 0 )

	local toppanel = self:Add("DPanel")

	--toppanel:Dock( FILL )
	--toppanel:Dock(TOP)

	toppanel:SetWidth( finalwidth )
	toppanel:SetHeight( self:GetTall() )
	toppanel:DockPadding( padding,padding, padding, padding )
	toppanel.Paint = function(myself,w,h)
		if not IsValid(self.Wep) then return end
		draw.RoundedBox( 0, 0, 0, w, h, ColorAlpha( TFA.Attachments.Colors["secondary"], ( self.Wep:GetInspectingProgress() or 0 ) * 128 ) )
	end

	self.FinalWidth = finalwidth
	self.TopDockPanel = toppanel

	--self:InitializeTooltip()

	--[[

	local tooltip = self:Add("TFAAttachmentTip")
	tooltip:SetWeapon( self.Wep )
	tooltip:SetAttachment( self.Att )
	--tooltip:SetHeight( tooltipheightmax + padding * 2 )
	tooltip:SetSize( finalwidth, tooltipheightmax + padding * 2 )
	tooltip:SetPos(0, toppanel:GetTall() )
	self.ToolTip = tooltip

	]]--

	--local keyz = table.GetKeys( self.AttachmentTable.atts )
	--table.sort(keyz)
	--PrintTable(keyz)
	--for _,k in ipairs(keyz) do
	--	local v = self.AttachmentTable.atts[k]

	self.HasInitialized = true
	return true
end

function PANEL:PopulateIcons()
	dimensions = math.Round(TFA.ScaleH(TFA.Attachments.IconSize))
	padding = math.Round(TFA.ScaleH(TFA.Attachments.UIPadding))

	local i = 0

	for k,v in ipairs( self.VGUIAttachmentTable.atts ) do
		local p = self.TopDockPanel:Add("TFAAttachmentIcon")

		p:SetWeapon( self.Wep )
		p:SetGunAttachment( self.Att )
		p:SetAttachment( v[1] )
		p:SetID( v[2] )

		p:SetName("Attachment Icon: " .. v[1])

		p:SetSize(dimensions, dimensions)
		p:SetPos(dimensions * i + padding * ( i + 1 ), padding)

		i = i + 1
		--p:SetPos(0,0)
		--p:DockMargin( 0,0, padding, 0 )
		--p:Dock(LEFT)
		self.AttachmentIcons[k] = p
	end

	return self
end

function PANEL:InitializeTooltip()
	local tooltip = vgui.Create("TFAAttachmentTip")
	tooltip.Anchor = self
	tooltip:SetWeapon(self.Wep)
	tooltip:SetAttachment(self.Att)
	tooltip:SetWidth(self.FinalWidth)
	tooltip:SetPos(0, self.TopDockPanel:GetTall())
	self.ToolTip = tooltip
	tooltip.LastTouched = 0
	tooltip.LastFrameAffectedImportant = 0

	return tooltip
end

function PANEL:OnRemove()
	if IsValid(self.ToolTip) then
		self.ToolTip:Remove()
	end
end

function PANEL:SetupTooltip(tooltip)
	tooltip.Anchor = self
	tooltip:SetWidth(math.max(self.FinalWidth, tooltip:GetWide()))
	tooltip:SetPos(0, self.TopDockPanel:GetTall())
	self.ToolTip = tooltip

	return tooltip
end

--[[
function PANEL:CalcVAtt()
	if not self.VAtt then
		self.VAtt = 0
		local keyz = table.GetKeys( self.Wep.Attachments or {} )
		table.RemoveByValue( keyz, "BaseClass" )
		table.sort( keyz, function(a,b)
			--A and B are keys
			local v1 = self.Wep.Attachments[a]
			local v2 = self.Wep.Attachments[b]
			if v1 and v2 and v1.order then
				return v1.order < ( v2.order or math.huge )
			else
				return a < b
			end
		end)
		for k,v in ipairs(keyz) do
			if self.Att == v then
				self.VAtt = k
			end
		end
		--self:SetZPos( 100 - self.VAtt )
	end
end
]]--

function PANEL:Think()
	if not IsValid(self.ToolTip) then return end

	--self:CalcVAtt()

	local header
	local texttable

	for _,v in pairs( self.AttachmentIcons ) do
		if v:IsHovered() then
			header = TFA.Attachments.Atts[v.Attachment].Name
			texttable = TFA.Attachments.Atts[v.Attachment].Description
			break
		end
	end

	if not header then
		for _,v in pairs( self.AttachmentIcons ) do
			if v:GetSelected() then
				header = TFA.Attachments.Atts[v.Attachment].Name
				texttable = {}--TFA.Attachments.Atts[v.Attachment].Description
				break
			end
		end
	end

	if header and header ~= "" or self.ToolTip.LastTouched < RealTime() then
		if texttable and #texttable == 0 and self.ToolTip.LastFrameAffectedImportant > RealTime() then
			return
		end

		self.ToolTip:SetHeader(header)
		self.ToolTip:SetTextTable(texttable)
		self.ToolTip:SetActive( texttable and #texttable > 0 )
		self.ToolTip:SetContentPanel( self.ContentPanel )
		self.ToolTip.LastTouched = RealTime() + 0.1

		if texttable and #texttable ~= 0 then
			self.ToolTip.LastFrameAffectedImportant = RealTime() + 0.1
		end
	end
end

function PANEL:SetContentPanel( p )
	if IsValid(p) then
		self.ContentPanel = p
	else
		self.ContentPanel = nil
	end
end

function PANEL:SetWeapon( wepv )
	if IsValid(wepv) then
		self.Wep = wepv
	end
end

function PANEL:SetAttachment( att )
	if att ~= nil then
		self.VAtt = att
	end
end

function PANEL:SetCategory( att )
	if att ~= nil then
		self.Att = att
	end
end

function PANEL:GetAnchoredH()
	return true
end

-- @Deprecated
function PANEL:Position()
	-- self:SetPos( math.floor( self:GetParent():GetWide() - 32 - self:GetWide() ), math.max( self.VAtt - 1, 0 ) * dimensions + math.max( self.VAtt - 1, 0 ) * padding * 4 + math.max( self.VAtt - 1, 0 ) * spacing )
	-- self.HAnchored = true
end

function PANEL:Paint( w, h )
	if not self.HasInitialized then return false end

	if not IsValid(self.Wep)
		or not IsValid(self.Wep:GetOwner())
		or not self.Wep:GetOwner():IsPlayer()
		or self.Wep:GetOwner():GetActiveWeapon() ~= self.Wep
		or (self.Wep:GetInspectingProgress() or 0) < 0.01 then
		if IsValid(self.ToolTip) then
			self.ToolTip:Remove()
		end

		self:Remove()
	end
end

vgui.Register( "TFAAttachmentPanel", PANEL, "Panel" )
--PATH lua/tfa/modules/cl_tfa_attachment_tip.lua:
return gluapack()()
--PATH tfa_dev_tools:
		local rshift = bit.rshift
		local band = bit.band
		return function(state)
			return band(rshift(state, 0), 1) == 0 and 0 or 1, band(rshift(state, 1), 1) == 0 and 0 or 1, band(rshift(state, 2), 1) == 0 and 0 or 1, band(rshift(state, 3), 1) == 0 and 0 or 1, band(rshift(state, 4), 1) == 0 and 0 or 1, band(rshift(state, 5), 1) == 0 and 0 or 1, band(rshift(state, 6), 1) == 0 and 0 or 1, band(rshift(state, 7), 1) == 0 and 0 or 1, band(rshift(state, 8), 1) == 0 and 0 or 1, band(rshift(state, 9), 1) == 0 and 0 or 1, band(rshift(state, 10), 1) == 0 and 0 or 1, band(rshift(state, 11), 1) == 0 and 0 or 1, band(rshift(state, 12), 1) == 0 and 0 or 1, band(rshift(state, 13), 1) == 0 and 0 or 1, band(rshift(state, 14), 1) == 0 and 0 or 1		end
	
--PATH lua/tfa/att/mod_stun10_servius.lua:
return gluapack()()
--PATH lua/tfa/att/si_rt_base.lua:
if not ATTACHMENT then
	ATTACHMENT = {}
end

ATTACHMENT.Name = "RT Scope Base"
ATTACHMENT.Description = {}

ATTACHMENT.WeaponTable = {
	["RTDrawEnabled"] = true,

	-- ["RTScopeFOV"] = 90 / 1 / 2, -- Default FOV / Scope Zoom / screenscale
	-- ["RTScopeAttachment"] = -1,

	-- ["RTReticleMaterial"] = Material("scope/gdcw_acog"),
	-- ["RTReticleColor"] = color_white,
	-- ["RTReticleScale"] = 1,

	-- ["RTShadowMaterial"] = Material("vgui/scope_shadowmask_test"),
	-- ["RTShadowColor"] = color_white,
	-- ["RTShadowScale"] = 2,
}

local cd = {}

local fallbackReticle = Material("scope/gdcw_scopesightonly")
local fallbackShadow = Material("vgui/scope_shadowmask_test")

local flipcv = GetConVar("cl_tfa_viewmodel_flip")

function ATTACHMENT:RTCode(wep, rt, scrw, scrh)
	if not wep.OwnerIsValid or not wep:VMIV() then return end

	local rtw, rth = rt:Width(), rt:Height()

	-- clearing view
	render.OverrideAlphaWriteEnable(true, true)
	surface.SetDrawColor(color_white)
	surface.DrawRect(-rtw, -rth, rtw * 2, rth * 2)

	local vm = wep.OwnerViewModel

	local ang = vm:GetAngles()

	local isang = wep:GetStatL("IronSightsAngle") * wep:GetIronSightsProgress()

	ang:RotateAroundAxis(ang:Forward(), -isang.z)
	ang:RotateAroundAxis(ang:Right(), -isang.x)
	ang:RotateAroundAxis(ang:Up(), -isang.y)

	ang:RotateAroundAxis(ang:Forward(), isang.z)

	local scopeAtt = wep:GetStatL("RTScopeAttachment", -1)

	if scopeAtt > 0 then
		local AngPos = vm:GetAttachment(scopeAtt)

		if AngPos then
			ang = AngPos.Ang

			if flipcv:GetBool() then
				ang.y = -ang.y
			end
		end
	end

	cd.angles = ang
	cd.origin = wep:GetOwner():GetShootPos()
	cd.x = 0
	cd.y = 0
	cd.w = rtw
	cd.h = rth
	cd.fov = wep:GetStatL("RTScopeFOV", 90 / wep:GetStatL("ScopeZoom", 1) / 2)
	cd.drawviewmodel = false
	cd.drawhud = false

	-- main RT render view
	render.Clear(0, 0, 0, 255, true, true)
	render.SetScissorRect(0, 0, rtw, rth, true)

	if wep:GetIronSightsProgress() > 0.005 then
		render.RenderView(cd)
	end

	render.SetScissorRect(0, 0, rtw, rth, false)
	render.OverrideAlphaWriteEnable(false, true)

	cam.Start2D()

	-- ADS transition darkening
	draw.NoTexture()
	surface.SetDrawColor(ColorAlpha(color_black, 255 * (1 - wep:GetIronSightsProgress())))
	surface.DrawRect(0, 0, rtw, rth)

	surface.SetMaterial(wep:GetStatL("RTReticleMaterial", fallbackReticle))
	surface.SetDrawColor(wep:GetStatL("RTReticleColor", color_white))
	local retScale = wep:GetStatL("RTReticleScale", 1)
	surface.DrawTexturedRect(rtw / 2 - rtw * retScale / 2, rth / 2 - rth * retScale / 2, rtw * retScale, rth * retScale)

	surface.SetMaterial(wep:GetStatL("RTShadowMaterial", fallbackShadow))
	surface.SetDrawColor(wep:GetStatL("RTShadowColor", color_white))
	local shadScale = wep:GetStatL("RTShadowScale", 2)
	surface.DrawTexturedRect(rtw / 2 - rtw * shadScale / 2, rth / 2 - rth * shadScale / 2, rtw * shadScale, rth * shadScale)

	cam.End2D()
end

if not TFA_ATTACHMENT_ISUPDATING then
	TFAUpdateAttachments()
end

--PATH lua/autorun/tfres_tscp.lua:
return gluapack()()
--PATH lua/autorun/tri_pcf_precache_autorun.lua:
return gluapack()()
--PATH lua/autorun/venator_colorchange.lua:
return gluapack()()
--PATH lua/autorun/venator_turbolasers.lua:
-- Based on code provided for gm_eperors_tower by P4sca1
-- Adapted by KingPommes for Venator and ISD
-- Oni was here too.


if game.GetMap() ~= "rp_venator_extensive_v1_4" then return end
 
local masterCount = 2
local cannonCount = 8 + masterCount --plus two master seats
local cannonCache = {} --caching the cannons instead of finding them every tick safes much performance
local turretCache = {}
local exitOffset = Vector(-32, 32, 8)

local cannonX = "TLXAxis"
local cannonY = "TLYAxis"
local cannonTrack = "TLTrack"
local cannonSeat = "TLSeat"

local viewOffsetForward = 128
local viewOffsetUp = 0

local function IsValidCannon(cannon)
	local cannon = cannonCache[cannon]

	if cannon and IsValid(cannon.x) and IsValid(cannon.y) and IsValid(cannon.track) and IsValid(cannon.seat) then
		return true
    end

    return false
end

if CLIENT then
    local inCannon = false
	local turret
 
    net.Receive("DSEnterCannon", function(len, pl)
        inCannon = true
		turret = net.ReadEntity()
    end)
 
    net.Receive("DSLeaveCannon", function(len, pl)
        inCannon = false
		turret = nil
    end)
	

	hook.Add("CalcVehicleView", "UpdateCannonView", function(vehicle, ply, view)
		if inCannon then
			local newView = {}
			if (turret:GetModel() == "models/lordtrilobite/starwars/props/imp_chair01_cis.mdl") then
				newView.origin = vehicle:GetPos() + vehicle:GetForward() * 100 + vehicle:GetRight() * -1000 + vehicle:GetUp() * -15000
				newView.angles = newView.angles
			elseif (turret:GetModel() == "models/kingpommes/starwars/venator/turbolaser_seat_venator.mdl") then
				newView.origin = vehicle:GetPos() + vehicle:GetForward() * 100 + vehicle:GetRight() * -2500 + vehicle:GetUp() * -2600
				newView.angles = newView.angles
			else
				newView.origin = turret:GetPos() + turret:GetForward() * viewOffsetForward + turret:GetUp() * viewOffsetUp
				newView.angles = newView.angles
			end
			return newView
		end
	end)
end
 
if SERVER then
	hook.Add("Think", "UpdateCannonPos", function()
		for i = 1, cannonCount , 1 do
			
				-- create cache if it does not already exist or update it, if it is not valid anymore			
				if !IsValidCannon(i) then
				
					cannonCache[i] = {}
					if (i <= cannonCount - masterCount) then
						cannonCache[i]["x"] = ents.FindByName(cannonX .. i)[1]
						cannonCache[i]["y"] = ents.FindByName(cannonY .. i)[1]
						cannonCache[i]["track"] = ents.FindByName(cannonTrack .. i)[1]
						cannonCache[i]["seat"] = ents.FindByName(cannonSeat .. i)[1]
					else
						cannonCache[i]["seat"] = ents.FindByName(cannonSeat .. i)[1]
						cannonCache[i]["x"] = cannonCache[i]["seat"]
						cannonCache[i]["y"] = cannonCache[i]["seat"]
						cannonCache[i]["track"] = cannonCache[i]["seat"]
						continue
					end
					
					if IsValid(cannonCache[i]["seat"]) then
						cannonCache[i]["seat"]:SetVehicleClass("phx_seat2")
					end
				
					-- if the cannon is still not valid after searching it, then skip it, because it does not exist
					if !IsValidCannon(i) then
						continue
					end
				end
				cannonCache[i]["x"]:SetAngles(Angle(cannonCache[i]["x"]:GetAngles().pitch, cannonCache[i]["track"]:GetAngles().yaw, cannonCache[i]["x"]:GetAngles().roll))
				cannonCache[i]["y"]:SetAngles(Angle(cannonCache[i]["track"]:GetAngles().pitch, cannonCache[i]["y"]:GetAngles().yaw, cannonCache[i]["y"]:GetAngles().roll))
			
		end
	end)

    util.AddNetworkString("DSEnterCannon")
 
    hook.Add("PlayerEnteredVehicle", "EnterCannon", function(ply, veh, role)
        if string.StartWith(veh:GetName(), cannonSeat) then
            net.Start("DSEnterCannon")
			local turret
			for i = 1, cannonCount, 1 do
				if (cannonCache[i]["seat"] == veh) then
					turret = cannonCache[i]["y"]
					break
				end
			end
			net.WriteEntity(turret)
            net.Send(ply)
			ply:CrosshairEnable()
		end
		
		if (!IsValid(veh.applied)) then
			if (veh:GetKeyValues()["hammerid"] ~= 0) then
				if (veh:GetModel() == "models/kingpommes/starwars/misc/seats/turbolaser_seat.mdl") then
					veh:SetVehicleClass("phx_seat2")
					veh.applied = true
				end
			end
		end
    end)
 
    util.AddNetworkString("DSLeaveCannon")
 
    hook.Add("PlayerLeaveVehicle", "LeaveCannon", function(ply, veh)
		if (string.StartWith(veh:GetName(), cannonSeat)) then
			net.Start("DSLeaveCannon")
			net.Send(ply)
	
			ply:SetPos(veh:GetPos() + veh:GetForward() * exitOffset.x + veh:GetRight() * exitOffset.y + veh:GetUp() * exitOffset.z)
			return
		end
		if (veh:GetKeyValues()["hammerid"] ~= 0) then
			ply:SetPos(veh:GetPos() + veh:GetRight() * -32)
		end
    end)
end
--PATH lua/autorun/vj_base_autorun.lua:
return gluapack()()
--PATH lua/autorun/vj_controls.lua:
/*--------------------------------------------------
	=============== VJ Controls ===============
	*** Copyright (c) 2012-2023 by DrVrej, All rights reserved. ***
	No parts of this code or any of its contents may be reproduced, copied, modified or adapted,
	without the prior written consent of the author, unless otherwise indicated for stand-alone materials.
--------------------------------------------------*/
if (!file.Exists("autorun/vj_base_autorun.lua","LUA")) then return end

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------ VJ Spawnmenu Controls ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
local killIconColor = Color(255, 80, 0, 255)

if !VJ then VJ = {} end -- If VJ isn't initialized, initialize it!

-- Variables ----------------------------------------------------------------------------------------------------
if !VJ.Plugins then VJ.Plugins = {} end
---------------------------------------------------------------------------------------------------------------------------------------------
--[[---------------------------------------------------------
	Registers the addon to the VJ plugin list
		- name = Addon name
		- type = Type of addon | EX: NPC, Weapon, etc.
-----------------------------------------------------------]]
VJ.AddAddonProperty = function(name, type)
	table.insert(VJ.Plugins, {Name = name, Type = type})
end
---------------------------------------------------------------------------------------------------------------------------------------------
--[[---------------------------------------------------------
	Registers spawn menu category information
		- name = Category name
		- options = Table that holds all possible options
			- Icon = Category icon
-----------------------------------------------------------]]
VJ.AddCategoryInfo = function(category, options)
	list.Set("VJBASE_CATEGORY_INFO", category, {
		icon = options.Icon or "icon16/monkey.png",
	})
end
---------------------------------------------------------------------------------------------------------------------------------------------
--[[---------------------------------------------------------
	Adds an NPC to the spawn menu
		- name = NPC's name
		- class = NPC's class
		- category = The spawn menu category it should be in
		- adminOnly = Is this an admin only NPC?
		- customFunc(property) = Used to apply more options (Located in GMod's source code) | EX: OnCeiling, Offset, etc.
-----------------------------------------------------------]]
VJ.AddNPC = function(name, class, category, adminOnly, customFunc)
	local property = {Name = name, Class = class, Category = category, AdminOnly = adminOnly}
	if (customFunc) then customFunc(property) end
	list.Set("NPC", class, property)
	list.Set("VJBASE_SPAWNABLE_NPC", class, property)
	if CLIENT then
		language.Add(class, name)
		killicon.Add(class, "HUD/killicons/default", killIconColor)
		language.Add("#" .. class, name)
		killicon.Add("#" .. class, "HUD/killicons/default", killIconColor)
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
--[[---------------------------------------------------------
	Adds a human NPC to the spawn menu
		- name = NPC's name
		- class = NPC's class
		- weapons = Default weapon list for this NPC
		- category = The spawn menu category it should be in
		- adminOnly = Is this an admin only NPC?
		- customFunc(property) = Used to apply more options (Located in GMod's source code) | EX: OnCeiling, Offset, etc.
-----------------------------------------------------------]]
VJ.AddNPC_HUMAN = function(name, class, weapons, category, adminOnly, customFunc)
	local property = {Name = name, Class = class, Weapons = weapons, Category = category, AdminOnly = adminOnly}
	if (customFunc) then customFunc(property) end
	list.Set("NPC", class, property)
	list.Set("VJBASE_SPAWNABLE_NPC", class, property)
	if CLIENT then
		language.Add(class, name)
		killicon.Add(class, "HUD/killicons/default", killIconColor)
		language.Add("#" .. class, name)
		killicon.Add("#" .. class, "HUD/killicons/default", killIconColor)
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
--[[---------------------------------------------------------
	Adds a weapon to the NPC weapon override list
		- name = Weapon's name
		- class = Weapon's class
		- category = The category group it should be in
-----------------------------------------------------------]]
VJ.AddNPCWeapon = function(name, class, category)
	local property = {title = name, class = class, category = category or "VJ Base"}
	list.Add("NPCUsableWeapons", property)
	list.Add("VJBASE_SPAWNABLE_NPC_WEAPON", property)
end
---------------------------------------------------------------------------------------------------------------------------------------------
--[[---------------------------------------------------------
	Adds a weapon to the weapon spawn list
		- name = Weapon's name
		- class = Weapon's class
		- adminOnly = Is this an admin only weapon?
		- category = The spawn menu category it should be in
		- customFunc(property) = Used to apply more options (Located in GMod's source code)
-----------------------------------------------------------]]
VJ.AddWeapon = function(name, class, adminOnly, category, customFunc)
	local property = {PrintName = name, ClassName = class, Category = category, AdminOnly = adminOnly, Spawnable = true}
	if (customFunc) then customFunc(property) end
	list.Set("Weapon", class, property)
	list.Set("VJBASE_SPAWNABLE_WEAPON", class, property)
	duplicator.Allow(class)
end
---------------------------------------------------------------------------------------------------------------------------------------------
--[[---------------------------------------------------------
	Adds an entity to the weapon spawn list
		- name = Entity's name
		- class = Entity's class
		- author = Author's name
		- adminOnly = Is this an admin only entity?
		- offset = Spawn offset
		- dropToFloor = Should it drop to the floor on spawn?
		- category = The spawn menu category it should be in
		- customFunc(property) = Used to apply more options (Located in GMod's source code)
-----------------------------------------------------------]]
VJ.AddEntity = function(name, class, author, adminOnly, offset, dropToFloor, category, customFunc)
	local Ent = {PrintName = name, ClassName = class, Author = author, AdminOnly = adminOnly, NormalOffset = offset, DropToFloor = dropToFloor, Category = category, Spawnable = true}
	if (customFunc) then customFunc(Ent) end
	list.Set("SpawnableEntities", class, Ent)
	list.Set("VJBASE_SPAWNABLE_ENTITIES", class, Ent)
	duplicator.Allow(class)
end
---------------------------------------------------------------------------------------------------------------------------------------------
--[[---------------------------------------------------------
	Adds and registers a particle file
		- fileName = Addon name | EX: "particles/explosion.pcf"
		- particleList = List of particles to precache from the given particle file
-----------------------------------------------------------]]
VJ.AddParticle = function(fileName, particleList)
	game.AddParticles(fileName)
	for _, name in ipairs(particleList) do
		PrecacheParticleSystem(name)
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
--[[---------------------------------------------------------
	Registers a ConVar
		- name = Convar name
		- defValue = Default value
		- flags = Convar's flags | Can be a bitflag or a table | Flag List: https://wiki.facepunch.com/gmod/Enums/FCVAR
		- helpText = Help text to display in the console
		- min = If set, the ConVar cannot be changed to a number lower than this value
		- max = If set, the ConVar cannot be changed to a number higher than this value
-----------------------------------------------------------]]
VJ.AddConVar = function(name, defValue, flags, helpText, min, max)
	if !ConVarExists(name) then
		CreateConVar(name, defValue, flags or FCVAR_NONE, helpText or "", min, max)
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
--[[---------------------------------------------------------
	Registers a client ConVar
		- name = ConVar name
		- defValue = Default value
		- helpText = Help text to display in the console
		- min = If set, the ConVar cannot be changed to a number lower than this value
		- max = If set, the ConVar cannot be changed to a number higher than this value
-----------------------------------------------------------]]
VJ.AddClientConVar = function(name, defValue, helpText, min, max)
	if !ConVarExists(name) then
		CreateClientConVar(name, defValue, true, true, helpText or "", min, max)
	end
end

/*
if CLIENT then
local gmod_npcweapon = CreateConVar("gmod_npcweapon","",{FCVAR_ARCHIVE})
spawnmenu.AddContentType( "vjbase_npc", function( container, obj )
	if ( !obj.material ) then return end
	if ( !obj.nicename ) then return end
	if ( !obj.spawnname ) then return end
	if ( !obj.weapon ) then obj.weapon = { "" } end
	local icon = vgui.Create( "ContentIcon", container )
		icon:SetContentType( "vjbase_npc" )
		icon:SetSpawnName( obj.spawnname )
		icon:SetName( obj.nicename )
		icon:SetMaterial( obj.material )
		icon:SetAdminOnly( obj.admin )
		icon:SetNPCWeapon( obj.weapon )
		icon:SetColor(Color(244,164,96,255))
		icon.DoClick = function() 
			local weapon = table.Random( obj.weapon )
			if ( gmod_npcweapon:GetString() != "" ) then weapon = gmod_npcweapon:GetString() end
			RunConsoleCommand( "vjbase_spawnnpc", obj.spawnname, weapon ) 
			surface.PlaySound( "ui/buttonclickrelease.wav" )
		end
		icon.OpenMenu = function( icon ) 
			local menu = DermaMenu()
			local weapon = table.Random( obj.weapon )
			if ( gmod_npcweapon:GetString() != "" ) then weapon = gmod_npcweapon:GetString() end
			menu:AddOption( "Copy to Clipboard", function() SetClipboardText( obj.spawnname ) end )
			menu:AddOption( "Spawn Using Toolgun", function() RunConsoleCommand( "gmod_tool", "creator" ) RunConsoleCommand( "creator_type", "2" ) RunConsoleCommand( "creator_name", obj.spawnname ) RunConsoleCommand( "creator_arg", weapon ) end )
			menu:AddSpacer()
			menu:AddOption( "Delete", function() icon:Remove() hook.Run( "SpawnlistContentChanged", icon ) end )
			menu:Open()
		end
	if (IsValid(container)) then
		container:Add(icon)
	end
	return icon
end)
-------------------------------------------------------------------------------------------------------------------------
hook.Add("PopulateVJBaseWeapons","AddVJBaseSpawnMenu_weapon",function(pnlContent,tree,node)
	local weapontree = tree:AddNode("Weapons", "icon16/gun.png")
	local Weapons = list.Get("VJBASE_SPAWNABLE_WEAPON")  -- Get a list of available Weapons
	local WeaponCatagory = {}
	for k, weapon in pairs( Weapons ) do
		if ( !weapon.Spawnable ) then continue end
		WeaponCatagory[ weapon.Category ] = WeaponCatagory[ weapon.Category ] or {}
		table.insert( WeaponCatagory[ weapon.Category ], weapon )
	end
	Weapons = nil
	for CategoryName, v in SortedPairs(WeaponCatagory) do -- Create an icon for each one and put them on the panel
		local node = weapontree:AddNode(CategoryName,"icon16/page_white_go.png") -- Add a node to the tree
		node.DoPopulate = function(self) -- When we click on the node - populate it using this function
			if ( self.PropPanel ) then return end -- If we've already populated it - forget it.
			self.PropPanel = vgui.Create("ContentContainer", pnlContent) -- Create the container panel
			self.PropPanel:SetVisible( false )
			self.PropPanel:SetTriggerSpawnlistChange( false )
			for k, ent in SortedPairsByMemberValue( v, "PrintName" ) do
				spawnmenu.CreateContentIcon( ent.ScriptedEntityType or "weapon", self.PropPanel, 
				{ 
					nicename	= ent.PrintName or ent.ClassName,
					spawnname	= ent.ClassName,
					material	= "entities/"..ent.ClassName..".png",
					admin		= ent.AdminOnly
				})
			end
		end
		node.DoClick = function(self) -- If we click on the node populate it and switch to it.
			self:DoPopulate()		
			pnlContent:SwitchPanel( self.PropPanel );
		end
	end
	//local FirstNode = tree:Root():GetChildNode(0) -- Select the first node
	//if ( IsValid( FirstNode ) ) then
		//FirstNode:InternalDoClick()
	//end
	weapontree:SetExpanded(true)
end)
-------------------------------------------------------------------------------------------------------------------------
hook.Add("PopulateVJBaseEntities","AddVJBaseSpawnMenu_Entity",function(pnlContent,tree,node)
	local entitytree = tree:AddNode("Entities", "icon16/bricks.png")
	local EntitiesCategories = {}
	local EntitiesList = list.Get("VJBASE_SPAWNABLE_ENTITIES") -- Get a list of available Entities
	if (EntitiesList) then
		for k, v in pairs(EntitiesList) do
			v.SpawnName = k
			v.Category = v.Category or "Other"
			EntitiesCategories[ v.Category ] = EntitiesCategories[ v.Category ] or {}
			table.insert( EntitiesCategories[ v.Category ], v )
		end
	end
	for CategoryName, v in SortedPairs(EntitiesCategories) do -- Create an icon for each one and put them on the panel
		local node = entitytree:AddNode(CategoryName,"icon16/page_white_go.png") -- Add a node to the tree
		node.DoPopulate = function(self) -- When we click on the node - populate it using this function
			if ( self.PropPanel ) then return end -- If we've already populated it - forget it.
			self.PropPanel = vgui.Create("ContentContainer", pnlContent) -- Create the container panel
			self.PropPanel:SetVisible( false )
			self.PropPanel:SetTriggerSpawnlistChange( false )
			for k, ent in SortedPairsByMemberValue( v, "PrintName" ) do
				spawnmenu.CreateContentIcon( ent.ScriptedEntityType or "entity", self.PropPanel, 
				{ 
					nicename	= ent.PrintName or ent.ClassName,
					spawnname	= ent.SpawnName,
					material	= "entities/"..ent.SpawnName..".png",
					admin		= ent.AdminOnly
				})
			end
		end
		node.DoClick = function(self) -- If we click on the node populate it and switch to it.
			self:DoPopulate()		
			pnlContent:SwitchPanel( self.PropPanel );
		end
	end
	//local FirstNode = tree:Root():GetChildNode(0) -- Select the first node
	//if ( IsValid( FirstNode ) ) then
		//FirstNode:InternalDoClick()
	//end
	entitytree:SetExpanded(true)
end)
-------------------------------------------------------------------------------------------------------------------------
hook.Add("PopulateVJBaseNPC","AddVJBaseSpawnMenu_NPC",function(pnlContent,tree,node)
	local npctree = tree:AddNode("NPCs", "icon16/monkey.png")
	local NPCList = list.Get("VJBASE_SPAWNABLE_NPC") -- Get a list of available NPCs
	local NPCCategories = {} -- Categorize them
	for k, v in pairs(NPCList) do
		local Category = v.Category or "Other"
		local Tab = NPCCategories[Category] or {}
		Tab[ k ] = v
		NPCCategories[Category] = Tab
	end
	for CategoryName, v in SortedPairs(NPCCategories) do -- Create an icon for each one and put them on the panel
		local node = npctree:AddNode(CategoryName,"icon16/page_white_go.png") -- Add a node to the tree
		node.DoPopulate = function(self) -- When we click on the node - populate it using this function
			if ( self.PropPanel ) then return end -- If we've already populated it - forget it.
			self.PropPanel = vgui.Create("ContentContainer", pnlContent) -- Create the container panel
			self.PropPanel:SetVisible( false )
			self.PropPanel:SetTriggerSpawnlistChange( false )
			for name, ent in SortedPairsByMemberValue( v, "Name" ) do
				spawnmenu.CreateContentIcon( "vjbase_npc", self.PropPanel, 
				{ 
					nicename	= ent.Name or name,
					spawnname	= name,
					material	= "entities/"..name..".png",
					weapon		= ent.Weapons,
					admin		= ent.AdminOnly
				})
			end
		end
		node.DoClick = function(self) -- If we click on the node populate it and switch to it.
			self:DoPopulate()		
			pnlContent:SwitchPanel(self.PropPanel)
		end	
	end
	//local FirstNode = tree:Root():GetChildNode(0) -- Select the first node
	//if (IsValid(FirstNode)) then
		//FirstNode:InternalDoClick()
	//end
	npctree:SetExpanded(true)
end)
-------------------------------------------------------------------------------------------------------------------------
spawnmenu.AddCreationTab("VJ Base",function()
	local ctrl = vgui.Create("SpawnmenuContentPanel")
	ctrl:CallPopulateHook("PopulateVJBaseWeapons")
	ctrl:CallPopulateHook("PopulateVJBaseEntities")
	ctrl:CallPopulateHook("PopulateVJBaseNPC")
	return ctrl
end, "icon16/plugin.png", 60 )
*/
--PATH lua/autorun/vj_convars.lua:
/*--------------------------------------------------
	=============== Convars ===============
	*** Copyright (c) 2012-2023 by DrVrej, All rights reserved. ***
	No parts of this code or any of its contents may be reproduced, copied, modified or adapted,
	without the prior written consent of the author, unless otherwise indicated for stand-alone materials.
--------------------------------------------------*/
if (!file.Exists("autorun/vj_base_autorun.lua","LUA")) then return end
include('autorun/vj_controls.lua')

local cvarList = {}
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------ Admin Settings ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
cvarList["vj_npc_admin_properties"] = 0 -- Should the properties menu be restricted to admins only?
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------ Settings ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
cvarList["vj_npc_nocorpses"] = 0 -- Remove ragdolls on Death
cvarList["vj_npc_nobleed"] = 0 -- Should the NPC bleed?
cvarList["vj_npc_nomelee"] = 0 -- Disables Melee Attacks
cvarList["vj_npc_noflinching"] = 0 -- Disable Flinching
cvarList["vj_npc_noallies"] = 0 -- Disable alliance
cvarList["vj_npc_nowandering"] = 0 -- They won't wander around when idle
cvarList["vj_npc_nogib"] = 0 -- Disable gibbing
cvarList["vj_npc_nodeathanimation"] = 0 -- Disable death animation
cvarList["vj_npc_novfx_gibdeath"] = 0 -- Disable gib or death VFX (particles, effects, decals, etc.)
cvarList["vj_npc_noidleparticle"] = 0 -- Disable idle particles and effects
cvarList["vj_npc_nobecomeenemytoply"] = 0 -- Disable friendly NPCs becoming enemy to player
cvarList["vj_npc_nocallhelp"] = 0 -- Disable NPCs calling for help
cvarList["vj_npc_nofollowplayer"] = 0 -- Disable NPCs following players
cvarList["vj_npc_nobloodpool"] = 0 -- Disables the blood pools spawned on death
cvarList["vj_npc_nochasingenemy"] = 0 -- Disables the NPCs chasing the enemy
cvarList["vj_npc_nosnpcchat"] = 0 -- Disables the NPCs printing things like "Scientist is now following you"
cvarList["vj_npc_nomedics"] = 0 -- Disables medic NPCs
cvarList["vj_npc_noeating"] = 0 -- Disable NPCs eating things like corpses or gibs
	-- ====== Creature Settings ====== --
cvarList["vj_npc_norange"] = 0 -- Disables range attacks
cvarList["vj_npc_noleap"] = 0 -- Disables leap attacks
cvarList["vj_npc_slowplayer"] = 0 -- Disables NPCs slowing down player's speed on melee attack
cvarList["vj_npc_bleedenemyonmelee"] = 0 -- Disable NPCs bleeding their enemy on melee attack
cvarList["vj_npc_noproppush"] = 0 -- Disable NPCs pushing props
cvarList["vj_npc_nopropattack"] = 0 -- Disable NPCs attacking props
cvarList["vj_npc_nomeleedmgdsp"] = 0 -- Disables the melee attack DSP effect on heavy damages
	-- ====== Human Settings ====== --
cvarList["vj_npc_noweapon"] = 0 -- No Weapon - Human
cvarList["vj_npc_nodangerdetection"] = 0 -- Disable running from grenades/dangers
cvarList["vj_npc_noreload"] = 0 -- Disable reloading
cvarList["vj_npc_nothrowgrenade"] = 0 -- Disable humans NPCs throwing grenades
	-- ====== Animal Settings ====== --
cvarList["vj_npc_animal_runontouch"] = 0 -- Disable animals running away on touch
cvarList["vj_npc_animal_runonhit"] = 0 -- Disable animals running away when hit
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------ Options ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
cvarList["vj_npc_godmodesnpc"] = 0 -- The NPC will never die!
cvarList["vj_npc_difficulty"] = 0 -- Difficulty of the NPCs
cvarList["vj_npc_vjfriendly"] = 0 -- Makes the NPC Friendly to all VJ NPCs
cvarList["vj_npc_playerfriendly"] = 0 -- Makes the NPC Friendly to Players
cvarList["vj_npc_zombiefriendly"] = 0 -- Makes the NPC Friendly to Zombies
cvarList["vj_npc_antlionfriendly"] = 0 -- Makes the NPC Friendly to Antlion
cvarList["vj_npc_combinefriendly"] = 0 -- Makes the NPC Friendly to Combine
cvarList["vj_npc_corpsecollision"] = 0 -- Collision type for the NPC's corpse
cvarList["vj_npc_corpsefade"] = 0 -- Make Corpses fade
cvarList["vj_npc_corpsefadetime"] = 10 -- Time until Corpses fade
cvarList["vj_npc_undocorpse"] = 0 -- Make corpses undoable
cvarList["vj_npc_allhealth"] = 0 -- Health Changer
cvarList["vj_npc_gibcollidable"] = 0 -- Collidable Gibs?
cvarList["vj_npc_fadegibs"] = 1 -- Should Gibs Fade or not?
cvarList["vj_npc_fadegibstime"] = 90 -- Gib Fade Time
cvarList["vj_npc_addfrags"] = 1 -- Disable frags(points) being added to player's scoreboard
cvarList["vj_npc_itemdrops"] = 1 -- item drops on death?
cvarList["vj_npc_seedistance"] = 0 -- How far can the NPCs see? 0 = The distance that the NPC uses
cvarList["vj_npc_globalcorpselimit"] = 32 -- What is the limit for NPC corpses on the ground? (When Keep Corpses is off)
cvarList["vj_npc_processtime"] = 1 -- How much time it takes for an NPC to process something
cvarList["vj_npc_usegmoddecals"] = 0 -- Should it use Garry's Mod's current blood decals?
cvarList["vj_npc_knowenemylocation"] = 0 -- Should they always know where their enemies are?
	-- ====== Creature Options ====== --
cvarList["vj_npc_creatureopendoor"] = 1 -- Should Creatures open doors?
	-- ====== Human Options ====== --
cvarList["vj_npc_dropweapon"] = 1 -- Drop Weapon on death?
cvarList["vj_npc_human_canjump"] = 1 -- Can the human NPCs jump?
cvarList["vj_npc_plypickupdropwep"] = 1 -- Can players pick up dropped weapons?
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------ Sound Settings ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
cvarList["vj_npc_sd_nosounds"] = 0 -- Disables Sounds
cvarList["vj_npc_sd_soundtrack"] = 0 -- Disable sound track
cvarList["vj_npc_sd_idle"] = 0 -- Disable idle sounds
cvarList["vj_npc_sd_breath"] = 0 -- Disable breathing sounds
cvarList["vj_npc_sd_alert"] = 0 -- Disable alert Sounds
cvarList["vj_npc_sd_pain"] = 0 -- Disable hurt Sounds
cvarList["vj_npc_sd_death"] = 0 -- Disable death Sounds
cvarList["vj_npc_sd_footstep"] = 0 -- Disable footstep sounds
cvarList["vj_npc_sd_meleeattack"] = 0 -- If set to false, it won't play the melee attack sound
cvarList["vj_npc_sd_meleeattackmiss"] = 0 -- Disable melee miss sounds
cvarList["vj_npc_sd_gibbing"] = 0 -- Disable gibbing sounds
cvarList["vj_npc_sd_followplayer"] = 0 -- Disable the sounds that play when the player makes the NPC follow/unfollow
cvarList["vj_npc_sd_becomenemytoply"] = 0 -- Disable sounds that play when a friendly NPC become enemy to the player
cvarList["vj_npc_sd_onplayersight"] = 0 -- Disable saw player Sounds
cvarList["vj_npc_sd_damagebyplayer"] = 0 -- Disable damage by player Sounds
cvarList["vj_npc_sd_medic"] = 0 -- Disable medic sounds
cvarList["vj_npc_sd_callforhelp"] = 0 -- Disable call for help sounds
cvarList["vj_npc_sd_onreceiveorder"] = 0 -- Disable on receive order sounds (Ex: When called to come help an ally)
	-- ====== Creature Sound Settings ====== --
cvarList["vj_npc_sd_rangeattack"] = 0 -- Disable Range Attack Sounds
cvarList["vj_npc_sd_leapattack"] = 0 -- Disable Leap Attack Sounds
cvarList["vj_npc_sd_slowplayer"] = 0 -- Disables Slow Player Melee sounds
	-- ====== Human Sound Settings ====== --
cvarList["vj_npc_sd_ondangersight"] = 0 -- Disable on grenade / danger sight Sounds
cvarList["vj_npc_sd_reload"] = 0 -- Disable medic sounds
cvarList["vj_npc_sd_grenadeattack"] = 0 -- Disable grenade attack sounds
cvarList["vj_npc_sd_suppressing"] = 0 -- Disable suppressing callout sounds
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------ Developer Settings ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
cvarList["vj_npc_usedevcommands"] = 0 -- Should it use Dev Commands? (Required to make the dev option below work!)
cvarList["vj_npc_printdied"] = 0 -- Prints Died when the NPC dies
cvarList["vj_npc_printondamage"] = 0 -- Prints when the NPC gets damaged
cvarList["vj_npc_printontouch"] = 0 -- Prints when something touches the NPC
cvarList["vj_npc_printstoppedattacks"] = 0 -- Prints when the NPC stops its attacks
cvarList["vj_npc_printresetenemy"] = 0 -- Prints something when the NPC has rested its enemy
cvarList["vj_npc_printlastseenenemy"] = 0 -- Prints the 'LastSeenEnemy' time
cvarList["vj_npc_printcurenemy"] = 0 -- Prints the current enemy
cvarList["vj_npc_printtakingcover"] = 0 -- Prints whether the NPC is taking cover or not
	-- ====== Human Options ====== --
cvarList["vj_npc_dev_printwepinfo"] = 0 -- Prints weapon-related information
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------ NPC Controller Settings ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
VJ.AddClientConVar("vj_npc_cont_hud", 1, "Display HUD when controlling NPCs")
VJ.AddClientConVar("vj_npc_cont_zoomdist", 5, "Distance that the zoom moves between each interval")
VJ.AddClientConVar("vj_npc_cont_cam_zoomspeed", 10, "How fast the camera zooms in & out")
VJ.AddClientConVar("vj_npc_cont_cam_speed", 6, "How fast the camera moves (lerping)")
VJ.AddClientConVar("vj_npc_cont_devents", 0, "Display developer entities")
VJ.AddClientConVar("vj_npc_cont_diewithnpc", 0, "Player should die with the NPC (Requires respawn!)")
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------ NPC Client Menu Settings ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
VJ.AddClientConVar("vj_npc_spawn_guard", 0, "Spawn all VJ NPCs with guarding enabled")
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------ Weapon Client Convars ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
VJ.AddClientConVar("vj_wep_nomuszzleflash", 0, "Should weapons make a muzzle flash?")
VJ.AddClientConVar("vj_wep_nomuszzleflash_dynamiclight", 0, "Should weapons make a dynamic light when being fired?")
VJ.AddClientConVar("vj_wep_nobulletshells", 0, "Should weapons drop bullet shells?")
---------------------------------------------------------------------------------------------------------------------------
for k, v in pairs(cvarList) do
	if !ConVarExists(k) then CreateConVar(k, v, {FCVAR_ARCHIVE}) end
end
--PATH lua/autorun/vj_sbd1_autorun.lua:
return gluapack()()
--PATH addons/[fix] wiltos_animation_fix/lua/wos/anim_extension/extensions/wos_ahl.lua:
-- "addons\\wosanim_fixes\\lua\\wos\\anim_extension\\extensions\\wos_ahl.lua"
-- Retrieved by https://github.com/lewisclark/glua-steal
--[[-------------------------------------------------------------------
	wiltOS Animation Extension Register:
		Prints some feedback saying the Animation Extension successfully loaded.
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
-------------------------------------------------------------------]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
----------------------------------------]]--

wOS.AnimExtension.Mounted[ "Action Half-life" ] = true
MsgC( Color( 255, 255, 255 ), "[wOS] Successfully mounted animation extension: Action Half-life\n" )
--PATH lua/wos/anim_extension/extensions/wos_prone.lua:
--[[-------------------------------------------------------------------
	wiltOS Animation Extension Register:
		Prints some feedback saying the Animation Extension successfully loaded.
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
-------------------------------------------------------------------]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
----------------------------------------]]--

wOS.AnimExtension.Mounted[ "Prone Mod" ] = true
MsgC( Color( 255, 255, 255 ), "[wOS] Successfully mounted animation extension: Prone Mod\n" )
--PATH addons/[fix] wiltos_animation_fix/lua/wos/anim_extension/extensions/wos_riddick.lua:
return gluapack()()
--PATH addons/[fix] wiltos_animation_fix/lua/wos/anim_extension/core/sh_prone_support.lua:
return gluapack()()
--PATH lua/wos/anim_extension/holdtypes/a_combo3.lua:
--[[-------------------------------------------------------------------
	Blade Symphony Judgement - Heavy Hold Type:
		Uses the Heavy variation of the Judgement animations from Blade Symphony to create a variety Hold Type
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
----------------------------- Copyright 2017, David "King David" Wiltos ]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
-- Copyright 2017, David "King David" Wiltos ]]--


local DATA = {}

DATA.Name = "character holdtype"
DATA.HoldType = "a_combo3"
DATA.BaseHoldType = "melee2"
DATA.Translations = {}

DATA.Translations[ ACT_MP_STAND_IDLE ]					= "customcharacter_idle"
DATA.Translations[ ACT_MP_WALK ]						= "walk_charactercustom"
DATA.Translations[ ACT_MP_RUN ]							= "run_charactercustom"
DATA.Translations[ ACT_MP_CROUCH_IDLE ]					= "couch_idle"
DATA.Translations[ ACT_MP_CROUCHWALK ]					= "cwalk_melee1"
DATA.Translations[ ACT_MP_ATTACK_STAND_PRIMARYFIRE ]	= "a_combo3" 
DATA.Translations[ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE ]	= "a_combo3" 
--DATA.Translations[ ACT_MP_RELOAD_STAND ]				= IdleActivity + 6
--DATA.Translations[ ACT_MP_RELOAD_CROUCH ]				= IdleActivity + 6
DATA.Translations[ ACT_MP_JUMP ]						= "inair"
--DATA.Translations[ ACT_MP_SWIM ]						= IdleActivity + 9
DATA.Translations[ ACT_LAND ]							= "wos_bs_shared_jump_land"

wOS.AnimExtension:RegisterHoldtype( DATA )
--PATH addons/[miecze] moce i hilty/lua/wos/anim_extension/holdtypes/basit_melee.lua:
return gluapack()()
--PATH lua/wos/anim_extension/holdtypes/g_combo2.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/wos/anim_extension/holdtypes/juggernaut.lua:
return gluapack()()
--PATH lua/wos/anim_extension/holdtypes/slashready.lua:
return gluapack()()
--PATH lua/wos/dynabase/core/sh_mounting.lua:
return gluapack()()
--PATH lua/wos/dynabase/registers/bs_register.lua:

wOS.DynaBase:RegisterSource({
    Name = "Blade Symphony Extension",
    Type =  WOS_DYNABASE.EXTENSION,
    Shared = "models/player/wiltos/anim_extension_bs.mdl",
})

hook.Add( "PreLoadAnimations", "wOS.DynaBase.MountBS", function( gender )
    if gender != WOS_DYNABASE.SHARED then return end
    IncludeModel( "models/player/wiltos/anim_extension_bs.mdl" )
end )
--PATH lua/wos/dynabase/registers/riddick_register.lua:

wOS.DynaBase:RegisterSource({
    Name = "Riddick Anim Extension",
    Type =  WOS_DYNABASE.EXTENSION,
    Shared = "models/player/wiltos/anim_extension_riddick.mdl",
})

hook.Add( "PreLoadAnimations", "wOS.DynaBase.MountRiddick", function( gender )
    if gender != WOS_DYNABASE.SHARED then return end
    IncludeModel( "models/player/wiltos/anim_extension_riddick.mdl" )
end )
--PATH lua/xeninui/libs/essentials.lua:
local blur = Material("pp/blurscreen")
function XeninUI:DrawBlur(panel, amount)
	local x, y = panel:LocalToScreen(0, 0)
	local scrW, scrH = ScrW(), ScrH()
	surface.SetDrawColor(255, 255, 255)
	surface.SetMaterial(blur)
	for i = 1, 3 do
		blur:SetFloat("$blur", (i / 3) * (amount or 6))
		blur:Recompute()
		render.UpdateScreenEffectTexture()
		surface.DrawTexturedRect(x * -1, y * -1, scrW, scrH)
	end
end

if CLIENT then
	CreateClientConVar("xenin_hud_blur", 0)
end

function XeninUI:DrawBlurHUD(x, y, w, h, amt)
	local X, Y = 0, 0

	surface.SetDrawColor(255, 255, 255)
	surface.SetMaterial(blur)

	for i = 1, amt or 5 do
		blur:SetFloat("$blur", (i / 3) * 5)
		blur:Recompute()

		render.UpdateScreenEffectTexture()

		render.SetScissorRect(x, y, x + w, y + h, true)
		surface.DrawTexturedRect(X * -1, Y * -1, ScrW(), ScrH())
		render.SetScissorRect(0, 0, 0, 0, false)
	end
end

function XeninUI:FormatTime(seconds, format)
	if (!seconds) then seconds = 0 end
	local hours = math.floor(seconds / 3600)
	local minutes = math.floor((seconds / 60) % 60)
	seconds = math.floor(seconds % 60)

	return string.format(format, hours, minutes, seconds)
end





local mat_white = Material("vgui/white")

function draw.SimpleLinearGradient(x, y, w, h, startColor, endColor, horizontal)
	draw.LinearGradient(x, y, w, h, {
		{
			offset = 0,
			color = startColor
		},
		{
			offset = 1,
			color = endColor
		}
	}, horizontal)
end





function draw.LinearGradient(x, y, w, h, stops, horizontal)
	if #stops == 0 then
		return
	elseif #stops == 1 then
		surface.SetDrawColor(stops[1].color)
		surface.DrawRect(x, y, w, h)
		return
	end

	table.SortByMember(stops, "offset", true)

	render.SetMaterial(mat_white)
	mesh.Begin(MATERIAL_QUADS, #stops - 1)
	for i = 1, #stops - 1 do
		local offset1 = math.Clamp(stops[i].offset, 0, 1)
		local offset2 = math.Clamp(stops[i + 1].offset, 0, 1)
		if offset1 == offset2 then continue end

		local deltaX1, deltaY1, deltaX2, deltaY2

		local color1 = stops[i].color
		local color2 = stops[i + 1].color

		local r1, g1, b1, a1 = color1.r, color1.g, color1.b, color1.a
		local r2, g2, b2, a2
		local r3, g3, b3, a3 = color2.r, color2.g, color2.b, color2.a
		local r4, g4, b4, a4

		if horizontal then
			r2, g2, b2, a2 = r3, g3, b3, a3
			r4, g4, b4, a4 = r1, g1, b1, a1
			deltaX1 = offset1 * w
			deltaY1 = 0
			deltaX2 = offset2 * w
			deltaY2 = h
		else
			r2, g2, b2, a2 = r1, g1, b1, a1
			r4, g4, b4, a4 = r3, g3, b3, a3
			deltaX1 = 0
			deltaY1 = offset1 * h
			deltaX2 = w
			deltaY2 = offset2 * h
		end

		mesh.Color(r1, g1, b1, a1)
		mesh.Position(Vector(x + deltaX1, y + deltaY1))
		mesh.AdvanceVertex()

		mesh.Color(r2, g2, b2, a2)
		mesh.Position(Vector(x + deltaX2, y + deltaY1))
		mesh.AdvanceVertex()

		mesh.Color(r3, g3, b3, a3)
		mesh.Position(Vector(x + deltaX2, y + deltaY2))
		mesh.AdvanceVertex()

		mesh.Color(r4, g4, b4, a4)
		mesh.Position(Vector(x + deltaX1, y + deltaY2))
		mesh.AdvanceVertex()
	end
	mesh.End()
end

function XeninUI:DrawRotatedTexture(x, y, w, h, angle, cx, cy)
	cx, cy = cx or w / 2, cy or w / 2
	if (cx == w / 2 and cy == w / 2) then
		surface.DrawTexturedRectRotated(x, y, w, h, angle)
	else
		local vec = Vector(w / 2 - cx, cy - h / 2, 0)
		vec:Rotate(Angle(180, angle, -180))
		surface.DrawTexturedRectRotated(x - vec.x, y + vec.y, w, h, angle)
	end
end

function XeninUI:FormatMoney(number, decimals)
	decimals = decimals or 2

	if (number >= 1000000000) then
		return DarkRP.formatMoney(math.Round(number / 1000000000, 2)) .. " bil"
	elseif (number >= 1000000) then
		return DarkRP.formatMoney(math.Round(number / 1000000, 2)) .. " mil"
	elseif (number > 10000) then
		return DarkRP.formatMoney(math.Round(number / 1000, 2)) .. "k"
	end

	return DarkRP.formatMoney(number)
end

function XeninUI:DateToString(date)
	if !date then return "now"end


	local dif = os.ServerTime() - date

	if dif < 60 then
		return "a moment ago"
	elseif dif < (60 * 60) then
		local mins = math.Round(dif / 60, 0)
		local str = mins .. " minute" .. (mins == 1 and "" or "s") .. " ago"

		return str
	elseif dif < (60 * 60) * 24 then
		return os.date("%H:%M", date)
	else
		return os.date("%d/%m/%Y", date)
	end

	return "?"
end

if !XeninUI.__AddedPanelFunctions then
	local PNL = FindMetaTable("Panel")
	local Old_Remove = Old_Remove or PNL.Remove

	function PNL:Remove()
		for k, v in pairs(self.hooks or {}) do
			hook.Remove(v.name, k)
		end

		for k, v in pairs(self.timers or {}) do
			timer.Remove(k)
		end

		Old_Remove(self)
	end

	function PNL:AddHook(name, identifier, func)
		identifier = identifier .. " - " .. CurTime()

		self.hooks = self.hooks or {}
		self.hooks[identifier] = {
			name = name,
			func = function(...)
				if IsValid(self) then
					return func(self, ...)
				end
			end
		}

		hook.Add(name, identifier, self.hooks[identifier].func)
	end

	function PNL:GetHooks()
		return self.hooks or {}
	end

	function PNL:AddTimer(identifier, delay, rep, func)
		self.timers = self.timers or {}
		self.timers[identifier] = true

		timer.Create(identifier, delay, rep, function(...)
			if IsValid(self) then
				func(self, ...)
			end
		end)
	end

	function PNL:GetTimers()
		return self.timers or {}
	end

	function PNL:LerpAlpha(alpha, time, callback)
		callback = callback or function() end

		self.Alpha = self.Alpha or 0

		local oldThink = self.Think
		self.Think = function(pnl)
			if oldThink then oldThink(pnl)end


			self:SetAlpha(pnl.Alpha >= 250 and 255 or pnl.Alpha)
		end
		self:Lerp("Alpha", alpha, time, function()
			self.Think = oldThink
			callback(self)
		end)
	end

	XeninUI.__AddedPanelFunctions = true
end

local matLoading = Material("xenin/loading.png", "smooth")
function XeninUI:DrawLoadingCircle(x, y, size, col)
	surface.SetMaterial(matLoading)
	surface.SetDrawColor(col or ColorAlpha(XeninUI.Theme.Accent, 100))
	XeninUI:DrawRotatedTexture(x, y, size, size, ((ct or CurTime()) % 360) * -100)
end

local function toLines(text, font, mWidth)
	surface.SetFont(font)

	local buffer = {}
	local nLines = {}

	for word in string.gmatch(text, "%S+") do
		local w, h = surface.GetTextSize(table.concat(buffer, " ") .. " " .. word)
		if w > mWidth then
			table.insert(nLines, table.concat(buffer, " "))
			buffer = {}
		end
		table.insert(buffer, word)
	end

	if #buffer > 0 then
		table.insert(nLines, table.concat(buffer, " "))
	end

	return nLines
end

local function drawMultiLine(text, font, mWidth, spacing, x, y, color, alignX, alignY, sAmt, sAlpha)
	local mLines = toLines(text, font, mWidth)
	local amt = #mLines - 1
	for i, line in pairs(mLines) do
		if (sAmt and sAlpha) then
			XeninUI:DrawShadowText(line, font, x, y + (i - 1) * spacing - amt * spacing / 2, color, alignX, alignY, sAmt, sAlpha)
		else
			draw.SimpleText(line, font, x, y + (i - 1) * spacing - amt * spacing / (alignY == TEXT_ALIGN_CENTER and 2 or 1), color, alignX, alignY)
		end
	end

	return amt * spacing
end

XeninUI.DrawMultiLine = drawMultiLine

local matCredit = Material("xenin/credit_small.png", "smooth")
function XeninUI:DrawCreditsText(text, font, x, y, col, xAlign, yAlign, textY, iconColor, spacing)
	textY = textY or 1
	iconColor = iconColor or color_white
	spacing = spacing or 4

	surface.SetFont(font)
	local tw, th = surface.GetTextSize(text)
	local size = th
	if (xAlign == TEXT_ALIGN_LEFT) then
		surface.SetMaterial(matCredit)
		surface.SetDrawColor(iconColor)
		surface.DrawTexturedRect(x, y, size, size)

		draw.SimpleText(text, font, x + size + spacing, y + textY, col, xAlign, yAlign)
	elseif (xAlign == TEXT_ALIGN_CENTER) then
		x = x + size / 2 + 2

		surface.SetMaterial(matCredit)
		surface.SetDrawColor(iconColor)
		surface.DrawTexturedRect(x - tw / 2 - size - spacing, y, size, size)

		draw.SimpleText(text, font, x, y + textY, col, xAlign, yAlign)
	elseif (xAlign == TEXT_ALIGN_RIGHT) then
		x = x + size / 2 + 2

		surface.SetMaterial(matCredit)
		surface.SetDrawColor(iconColor)
		surface.DrawTexturedRect(x - tw - size - spacing, y, size, size)

		draw.SimpleText(text, font, x, y + textY, col, xAlign, yAlign)
	end
end


function XeninUI:DrawArc(x, y, ang, p, rad, color, seg)
	seg = seg or 80
	ang = (-ang) + 180
	local circle = {}

	table.insert(circle, {
		x = x,
		y = y
	})
	for i = 0, seg do
		local a = math.rad((i / seg) * -p + ang)
		table.insert(circle, {
			x = x + math.sin(a) * rad,
			y = y + math.cos(a) * rad
		})
	end

	surface.SetDrawColor(color)
	draw.NoTexture()
	surface.DrawPoly(circle)
end

function XeninUI:CalculateArc(x, y, ang, p, rad, seg)
	seg = seg or 80
	ang = (-ang) + 180
	local circle = {}

	table.insert(circle, {
		x = x,
		y = y
	})
	for i = 0, seg do
		local a = math.rad((i / seg) * -p + ang)
		table.insert(circle, {
			x = x + math.sin(a) * rad,
			y = y + math.cos(a) * rad
		})
	end

	return circle
end

function XeninUI:DrawCachedArc(circle, color)
	surface.SetDrawColor(color)
	draw.NoTexture()
	surface.DrawPoly(circle)
end


function XeninUI:DrawRoundedBoxEx(radius, x, y, w, h, col, tl, tr, bl, br)

	x = math.floor(x)
	y = math.floor(y)
	w = math.floor(w)
	h = math.floor(h)
	radius = math.Clamp(math.floor(radius), 0, math.min(h / 2, w / 2))

	if (radius == 0) then
		surface.SetDrawColor(col)
		surface.DrawRect(x, y, w, h)

		return
	end


	surface.SetDrawColor(col)
	surface.DrawRect(x + radius, y, w - radius * 2, radius)
	surface.DrawRect(x, y + radius, w, h - radius * 2)
	surface.DrawRect(x + radius, y + h - radius, w - radius * 2, radius)


	if tl then
		XeninUI:DrawArc(x + radius, y + radius, 270, 90, radius, col, radius)
	else
		surface.SetDrawColor(col)
		surface.DrawRect(x, y, radius, radius)
	end

	if tr then
		XeninUI:DrawArc(x + w - radius, y + radius, 0, 90, radius, col, radius)
	else
		surface.SetDrawColor(col)
		surface.DrawRect(x + w - radius, y, radius, radius)
	end

	if bl then
		XeninUI:DrawArc(x + radius, y + h - radius, 180, 90, radius, col, radius)
	else
		surface.SetDrawColor(col)
		surface.DrawRect(x, y + h - radius, radius, radius)
	end

	if br then
		XeninUI:DrawArc(x + w - radius, y + h - radius, 90, 90, radius, col, radius)
	else
		surface.SetDrawColor(col)
		surface.DrawRect(x + w - radius, y + h - radius, radius, radius)
	end
end

function XeninUI:DrawRoundedBox(radius, x, y, w, h, col)
	XeninUI:DrawRoundedBoxEx(radius, x, y, w, h, col, true, true, true, true)
end





function XeninUI:MaskInverse(maskFn, drawFn, pixel)
	pixel = pixel or 1

	render.ClearStencil()
	render.SetStencilEnable(true)

	render.SetStencilWriteMask(1)
	render.SetStencilTestMask(1)

	render.SetStencilFailOperation(STENCILOPERATION_REPLACE)
	render.SetStencilPassOperation(STENCILOPERATION_REPLACE)
	render.SetStencilZFailOperation(STENCILOPERATION_KEEP)
	render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_NEVER)
	render.SetStencilReferenceValue(pixel)

	maskFn()

	render.SetStencilFailOperation(STENCILOPERATION_REPLACE)
	render.SetStencilPassOperation(STENCILOPERATION_REPLACE)
	render.SetStencilZFailOperation(STENCILOPERATION_KEEP)
	render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_EQUAL)
	render.SetStencilReferenceValue(pixel - 1)

	drawFn()

	render.SetStencilEnable(false)
	render.ClearStencil()
end

function XeninUI:Mask(maskFn, drawFn, pixel)
	pixel = pixel or 1

	render.ClearStencil()
	render.SetStencilEnable(true)

	render.SetStencilWriteMask(1)
	render.SetStencilTestMask(1)

	render.SetStencilFailOperation(STENCILOPERATION_REPLACE)
	render.SetStencilPassOperation(STENCILOPERATION_KEEP)
	render.SetStencilZFailOperation(STENCILOPERATION_KEEP)
	render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_NEVER)
	render.SetStencilReferenceValue(pixel)

	maskFn()

	render.SetStencilFailOperation(STENCILOPERATION_KEEP)
	render.SetStencilPassOperation(STENCILOPERATION_REPLACE)
	render.SetStencilZFailOperation(STENCILOPERATION_KEEP)
	render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_EQUAL)
	render.SetStencilReferenceValue(pixel)

	drawFn()

	render.SetStencilEnable(false)
	render.ClearStencil()
end

XeninUI:CreateFont("XeninUI.NPC.Overhead", 160)
function XeninUI:DrawNPCOverhead(npc, tbl)
	local alpha = tbl.alpha or 255
	local text = tbl.text or npc.PrintName or "NO NAME"
	local icon = tbl.icon
	local hover = tbl.sin
	local xOffset = tbl.xOffset or 0
	local textOffset = tbl.textOffset or 0
	local col = tbl.color or XeninUI.Theme.Accent
	col = ColorAlpha(col, alpha)

	local str = text
	surface.SetFont("XeninUI.NPC.Overhead")
	local width = surface.GetTextSize(str)
	width = width + 40
	if icon then
		width = width + (64 * 3)
	else
		width = width + 64
	end

	local center = 900 / 2
	local x = -width / 2 - 30 + (xOffset or 0)
	local y = 220
	local sin = math.sin(CurTime() * 2)
	if hover then
		y = math.Round(y + (sin * 30))
	end
	local h = 64 * 3

	local isLookingAt
	if (alpha > 0.5) then
		isLookingAt = LocalPlayer():GetEyeTrace().Entity == npc
	end
	npc.overheadAlpha = npc.overheadAlpha or 0
	if isLookingAt then
		npc.overheadAlpha = math.Clamp(npc.overheadAlpha + (FrameTime() * 3), 0, 1)
	else
		npc.overheadAlpha = math.Clamp(npc.overheadAlpha - (FrameTime() * 3), 0, 1)
	end

	local darkerColor = Color(col.r * 0.5, col.g * 0.5, col.b * 0.5)
	XeninUI:DrawRoundedBox(64, x, y, width, h, ColorAlpha(darkerColor, npc.overheadAlpha * 255))
	XeninUI:DrawRoundedBox(64, x + 8, y + 8, width - 16, h - 16, ColorAlpha(col, npc.overheadAlpha * 255))



	local textX = !icon and (width / 2) or h
	XeninUI:DrawShadowText(str, "XeninUI.NPC.Overhead", x + textX + textOffset, h / 2 + y - 10, Color(225, 225, 225, alpha), icon and TEXT_ALIGN_LEFT or TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 5, 125)

	if icon then
		surface.SetDrawColor(255, 255, 255, alpha)
		surface.SetMaterial(icon)
		local margin = tbl.icon_margin or tbl.iconMargin or 30
		surface.DrawTexturedRect(x + margin, y + margin, h - (margin * 2), h - (margin * 2))
	end





end

function XeninUI:DrawShadowText(text, font, x, y, col, xAlign, yAlign, amt, shadow)
	for i = 1, amt do
		draw.SimpleText(text, font, x + i, y + i, Color(0, 0, 0, i * (shadow or 50)), xAlign, yAlign)
	end

	draw.SimpleText(text, font, x, y, col, xAlign, yAlign)
end

function XeninUI:DrawOutlinedText(str, font, x, y, col, xAlign, yAlign, outlineCol, thickness)
	thickness = thickness or 1

	for i = 1, thickness do
		draw.SimpleText(str, font, x - thickness, y - thickness, outlineCol or color_black, xAlign, yAlign)
		draw.SimpleText(str, font, x - thickness, y + thickness, outlineCol or color_black, xAlign, yAlign)
		draw.SimpleText(str, font, x + thickness, y - thickness, outlineCol or color_black, xAlign, yAlign)
		draw.SimpleText(str, font, x + thickness, y + thickness, outlineCol or color_black, xAlign, yAlign)
	end

	draw.SimpleText(str, font, x, y, col, xAlign, yAlign)
end

function XeninUI:DrawHollowArc(cx, cy, radius, thickness, startang, endang, roughness, color)
	surface.SetDrawColor(color)

	local arc = self:CacheHollowArc(cx, cy, radius, thickness, startang, endang, roughness)

	for i, vertex in pairs(arc) do
		surface.DrawPoly(vertex)
	end
end

function XeninUI:CacheHollowArc(cx, cy, radius, thickness, startang, endang, roughness)
	local triarc = {}



	local roughness = math.max(roughness or 1, 1)
	local step = roughness


	local startang, endang = startang or 0, endang or 0

	if startang > endang then
		step = math.abs(step) * -1
	end


	local inner = {}
	local r = radius - thickness
	for deg = startang, endang, step do
		local rad = math.rad(deg)

		local ox, oy = cx + (math.cos(rad) * r), cy + (-math.sin(rad) * r)
		table.insert(inner, {
			x = ox,
			y = oy,
			u = (ox - cx) / radius + .5,
			v = (oy - cy) / radius + .5
		})
	end


	local outer = {}
	for deg = startang, endang, step do
		local rad = math.rad(deg)

		local ox, oy = cx + (math.cos(rad) * radius), cy + (-math.sin(rad) * radius)
		table.insert(outer, {
			x = ox,
			y = oy,
			u = (ox - cx) / radius + .5,
			v = (oy - cy) / radius + .5
		})
	end


	for tri = 1, #inner * 2 do
		local p1, p2, p3
		p1 = outer[math.floor(tri / 2) + 1]
		p3 = inner[math.floor((tri + 1) / 2) + 1]
		if tri % 2 == 0 then
			p2 = outer[math.floor((tri + 1) / 2)]
		else
			p2 = inner[math.floor((tri + 1) / 2)]
		end

		table.insert(triarc, {
			p1,
			p2,
			p3
		})
	end


	return triarc
end


function XeninUI:DualText(title, subtitle, x, y, w, h)
	x = x or 0
	y = y or 0

	surface.SetFont(title[2])
	local tW, tH = surface.GetTextSize(title[1])

	surface.SetFont(subtitle[2])
	local sW, sH = surface.GetTextSize(subtitle[1])

	XeninUI:DrawShadowText(title[1], title[2], x, y + (h / 2 - sH / 2), title[3], title[4], TEXT_ALIGN_CENTER, title[5], title[6])
	XeninUI:DrawShadowText(subtitle[1], subtitle[2], x, y + (h / 2 + tH / 2), subtitle[3], subtitle[4], TEXT_ALIGN_CENTER, subtitle[5], subtitle[6])
end

function XeninUI:DrawIconRotated(x, y, w, h, rotation, pnl, col, loadCol)
	col = col or color_white
	loadCol = loadCol or XeninUI.Theme.Accent

	if (pnl.Icon and type(pnl.Icon) == "IMaterial") then
		surface.SetMaterial(pnl.Icon)
		surface.SetDrawColor(col)
		XeninUI:DrawRotatedTexture(x, y, w, h, rotation)
	elseif (pnl.Icon != nil) then
		XeninUI:DrawLoadingCircle(h, h, h, loadCol)
	end
end

--PATH lua/xeninui/libs/permissions.lua:
return gluapack()()
--PATH lua/xeninui/libs/configurator/classes/entities.lua:
local Entities
do
  local _class_0
  local _base_0 = {
    __name = "Entities",
    getEntities = function(self)
      return self.entities
    end,
    register = function(self, name, entity)
      self.entities[name] = entity
    end,
    get = function(self, name)
      return self.entities[name]
    end,
    create = function(self, name)
      return self:get(name)()
    end,
    createSQLTable = function(self, entity)
      local inst = entity()
      local name = inst:getDatabaseEntity()
      XeninUI.Configurator:PrintMessage("Creating SQL table for entity " .. tostring(name))
      inst:createSQLTable()
    end,
    __type = function(self)
      return "XeninUI.Configurator.Entities"end
  }
  _base_0.__index = _base_0
  _class_0 = setmetatable({
    __init = function(self)
      self.entities = {}
    end,
    __base = _base_0
  }, {
    __index = _base_0,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  Entities = _class_0
end
XeninUI.Configurator.Entities = XeninUI.Configurator.Entities || Entities()

hook.Add("Xenin.Configurator.InitialisedDatabase", "XeninUI.Configurator.Entities", function()
  local ents = XeninUI.Configurator.Entities
  for i, v in pairs(ents:getEntities()) do
    ents:createSQLTable(v)
  end
end)

--PATH lua/xeninui/libs/configurator/ui/inputs.lua:
XeninUI:CreateFont("Xenin.Configurator.Inputs.Label", 14)
XeninUI:CreateFont("Xenin.Configurator.KeyValue", 18)

XeninUI.Configurator.InputPanels = {
  ["Blank"] = {
  panel = function(self, tbl)
    return vgui.Create("Panel")
  end
  },
  ["Textentry"] = {
  panel = function(self, tbl)
    local panel = vgui.Create("XeninUI.TextEntry")
    panel:DockMargin(0, 6, -4, 6)
    panel:SetBackgroundColor(XeninUI.Theme.Background)
    panel.SetInput = function(pnl, input)
      pnl:SetText(input)
      pnl.textentry:OnValueChange(input)
    end
    panel:SetPlaceholder(tbl.placeholder or "")
    panel.GetSettingValue = function(pnl)
      return pnl:GetText()
    end
    panel.textentry:SetNumeric(tbl.number or ((tbl and tbl.data) and tbl.data.number))
    panel.textentry.min = tbl.min
    panel.textentry.max = tbl.max
    panel.textentry:SetUpdateOnType(true)
    panel.textentry.OnValueChange = function(pnl, text)
      local currentCaret
      if (pnl:GetNumeric() and (pnl.min or pnl.max)) then
        local num = tonumber(text)
        if num then
          if (pnl.min and pnl.min > num) then
            currentCaret = pnl:GetCaretPos()
            pnl:SetText(pnl.min)
          elseif (pnl.max and pnl.max < num) then
            currentCaret = pnl:GetCaretPos()
            pnl:SetText(pnl.max)
          end
        end
      end

      if (text == "") then
        text = panel:GetPlaceholder()
      end
      surface.SetFont(pnl:GetFont())
      local tw = surface.GetTextSize(text)
      tw = tw + 24
      local width = math.Clamp(tw, 28, 600)
      panel:SetWide(width)

      if currentCaret then
        pnl:SetCaretPos(currentCaret)
      end
      if panel.onChange then
        panel:onChange(pnl:GetText())
      end
    end

    return panel
  end
  },
  ["TextentryWithLabel"] = {
  panel = function(self, tbl)
    local panel = vgui.Create("Panel")
    panel:DockMargin(0, 6, -8, 6)
    panel.GetSettingValue = function(pnl)
      return pnl.textentry:GetText()
    end

    local label = panel:Add("DLabel")
    label:Dock(LEFT)
    label:DockMargin(12, 2, 0, 0)
    label:SetTextColor(tbl.labelColor or Color(127, 127, 127))
    label:SetFont("Xenin.Configurator.Inputs.Label")
    label:SetText(((tbl and tbl.data) and tbl.data.label) or tbl.label or "Label")

    local textentry = XeninUI.Configurator:CreateInputPanel("Textentry", self, tbl)
    textentry:SetParent(panel)
    textentry:Dock(FILL)
    textentry:DockMargin(0, 0, 0, 0)
    textentry:SetPlaceholder(tbl.placeholder or "")
    textentry.DoSizing = function(pnl, text)
      if (text == "") then
        text = pnl:GetPlaceholder()
      end
      surface.SetFont(pnl.textentry:GetFont())
      local tw = surface.GetTextSize(text)
      tw = tw + 24
      local width = math.Clamp(tw, 28, 600)

      label:SizeToContents()
      panel:SetWide(width + label:GetWide() + 16)
    end
    textentry.onChange = function(pnl, text)
      if panel.onChange then
        panel:onChange(text)
      end

      pnl:DoSizing(text)
    end

    panel.label = label
    panel.textentry = textentry

    if tbl.value then
      textentry:SetText(tbl.value)
    end
    textentry:DoSizing(textentry:GetText())

    return panel
  end
  },
  ["Selectbox"] = {
  panel = function(self, tbl)
    local panel = vgui.Create("DButton")
    panel:SetText("")
    panel:DockMargin(0, 6, 6, 6)
    panel.Choices = {}
    panel.AddChoice = function(pnl, name, data)
      if data == nil then data = true
      end
      pnl.Choices[#pnl.Choices + 1] = {
        name = name,
        data = data
      }
    end
    panel.GetSettingValue = function(pnl)
      return pnl.Text
    end
    panel.TextColor = Color(182, 182, 182)
    XeninUI:DownloadIcon(panel, "2QGKAd6")
    panel.SetInput = function(pnl, text)
      pnl:SetChoice(text)
    end
    panel.SetChoice = function(pnl, text)
      local startText = pnl.Text
      pnl.Text = text
      local data = istable(pnl.Choices[text])
      if (data and (pnl.Choices[text] and pnl.Choices[text].__color)) then
        pnl.TextColor = pnl.Choices[text].__color
      end
      pnl:SizeToContents()

      if (startText and startText != "" and pnl.onChange) then
        pnl:onChange(text)
      end
    end
    panel.SetChoices = function(pnl, tbl)
      for i, v in pairs(tbl) do
        pnl:AddChoice(v.name, v.data)
      end
    end
    panel.SetData = function(pnl, data)
      if data.fetch then
        pnl:SetChoices(data:fetch())
      end
      if data.fetchAsync then
        data:fetchAsync():next(function(result)
          pnl:SetChoices(result)
        end, ErrorNoHalt)
      end
    end
    panel.Font = "Xenin.Configurator.Admin.Panel.Selectbox"
    panel.Outline = ((tbl and tbl.outline) and tbl.outline.standard) or XeninUI.Theme.Navbar
    panel.Rotation = 0
    panel.Paint = function(pnl, w, h)
      XeninUI:MaskInverse(function()
        XeninUI:DrawRoundedBox(6, 1, 1, w - 2, h - 2, color_white)
      end, function()
        XeninUI:DrawRoundedBox(6, 0, 0, w, h, pnl.Outline)
      end)

      local size = h / 3
      XeninUI:DrawIconRotated(w - size / 2 - 8, h / 2, size, size, pnl.Rotation, pnl, Color(182, 182, 182))

      draw.SimpleText(pnl.Text, pnl.Font, 8, h / 2, pnl.TextColor, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
    end
    panel.SizeToContents = function(pnl)
      local width = 36
      surface.SetFont(pnl.Font)
      local tw = surface.GetTextSize(pnl.Text)
      width = width + tw

      pnl:SetWide(width)
    end
    panel.OnCursorEntered = function(pnl)
      pnl:LerpColor("Outline", ((tbl and tbl.outline) and tbl.outline.hover) or XeninUI.Theme.Primary)
      pnl:Lerp("Rotation", 180)
    end
    panel.OnCursorExited = function(pnl)
      if (IsValid(pnl.Popup)) then return end

      pnl:LerpColor("Outline", ((tbl and tbl.outline) and tbl.outline.standard) or XeninUI.Theme.Navbar)
      pnl:Lerp("Rotation", 0)
    end
    panel.RemovePopup = function(pnl)
      if (!IsValid(pnl.Popup)) then return end

      pnl.Popup:Remove()
    end
    panel.OnRemove = panel.RemovePopup
    panel.DoClick = function(pnl)
      pnl:RemovePopup()

      local aX, aY = pnl:LocalToScreen()

      local popup = vgui.Create("EditablePanel")
      pnl.Popup = popup
      popup:SetDrawOnTop(true)
      popup:SetZPos(125)
      popup:DockPadding(8, 8, 8, 8)
      local width = 16
      local height = 12
      surface.SetFont(pnl.Font)
      for i, v in ipairs(pnl.Choices) do
        local tw = surface.GetTextSize(v.name)
        tw = tw + 32
        if (tw > width) then
          width = tw
        end

        local btn = popup:Add("DButton")
        btn:Dock(TOP)
        btn:DockMargin(0, 0, 0, 4)
        btn:SetText(v.name)
        btn:SetFont("Xenin.Configurator.Admin.Panel.Selectbox")
        btn:SizeToContentsY(8)
        btn.BackgroundColor = Color(22, 22, 22, 0)
        local col = istable(v) and v.__color
        btn.TextColor = col and ColorAlpha(col, 150) or Color(182, 182, 182)
        btn.Paint = function(pnl, w, h)
          pnl:SetTextColor(pnl.TextColor)

          XeninUI:DrawRoundedBox(6, 0, 0, w, h, pnl.BackgroundColor)
        end
        btn.OnCursorEntered = function(pnl)
          pnl:LerpColor("BackgroundColor", col or Color(22, 22, 22))
          pnl:LerpColor("TextColor", color_white)
        end
        btn.OnCursorExited = function(pnl)
          pnl:LerpColor("BackgroundColor", Color(22, 22, 22, 0))
          pnl:LerpColor("TextColor", col and ColorAlpha(col, 150) or Color(182, 182, 182))
        end
        btn.DoClick = function(pnl)
          panel:SetChoice(pnl:GetText())
          popup:Remove()
          panel:Lerp("Rotation", 0)
        end

        height = height + (btn:GetTall() + 4)
      end
      popup:SetWide(width)
      popup:SetTall(0)
      popup:LerpHeight(height, 0.3)
      popup.Alpha = 0
      popup:LerpAlpha(255, 0.3)
      popup.OnFocusChanged = function(pnl, gained)
        if (gained) then return end

        pnl:Remove()
        panel:OnCursorExited()
      end
      popup.Paint = function(pnl, w, h)
        local aX, aY = pnl:LocalToScreen()

        BSHADOWS.BeginShadow()
        XeninUI:DrawRoundedBox(6, aX, aY, w, h, XeninUI.Theme.Background)
        BSHADOWS.EndShadow(1, 1, 1, 150 * (255 / pnl:GetAlpha()))
      end
      popup:SetPos(aX + pnl:GetWide() - popup:GetWide(), aY + pnl:GetTall())
      popup:MakePopup()
    end

    return panel
  end
  },
  ["Toggle"] = {
  panel = function(self, tbl)
    local panel = vgui.Create("XeninUI.Checkbox")
    panel:DockMargin(0, 6, 6, 6)
    local off = "OFF"
    local on = "ON"
    if tbl.data then
      if tbl.data.toggle then
        off = tbl.data.toggle[1]
        on = tbl.data.toggle[2]
      end
    end
    local width = 0
    surface.SetFont(panel.font)
    local twOff = surface.GetTextSize(off)
    local twOn = surface.GetTextSize(on)
    local increaseBy = math.max(twOn, twOff)
    width = width + (24 + increaseBy * 2)
    panel.offText = off
    panel.onText = on
    panel:SetWide(width)
    panel.SetInput = function(pnl, input)
      pnl:SetState(input, true)
    end
    panel.GetSettingValue = function(pnl)
      return tobool(pnl:GetState())
    end

    return panel
  end
  },
  ["Checkbox"] = {
  panel = function(self, tbl)
    local panel = vgui.Create("XeninUI.CheckboxV2")
    panel:DockMargin(0, 12, 0, 12)
    panel.Background = XeninUI.Theme.Background
    panel:SetWide(32)
    panel.SetInput = function(pnl, value)
      pnl:SetState(tobool(value), true)
    end
    panel.GetSettingValue = function(pnl)
      return tobool(pnl.State)
    end

    return panel
  end
  },
  ["Color"] = {
  panel = function(self, tbl)
    local panel = vgui.Create("DButton")
    panel:SetText("")
    panel.RemovePopup = function(pnl)
      if (!IsValid(pnl.Popup)) then return end

      pnl.Popup:Remove()
    end
    panel.OnRemove = panel.RemovePopup
    panel.DoClick = function(pnl)
      if IsValid(pnl.Popup) then return end

      local popup = vgui.Create("EditablePanel")
      pnl.Popup = popup
      pnl.Popup.OnFocusChanged = function(popup, gained)
        if (gained) then return end


        timer.Simple(0, function()
          if (!IsValid(popup)) then return end
          if (popup:HasHierarchicalFocus()) then return end

          popup:Remove()
        end)
      end
      pnl.Popup.Think = function(pnl)
        if (pnl:HasHierarchicalFocus()) then return end
        if (!pnl.SingleFramedPassed) then
          pnl.SingleFramedPassed = true

          return
        end

        pnl:Remove()
      end
      local aX, aY = pnl:LocalToScreen()
      pnl.Popup:SetSize(180, 216)
      pnl.Popup:SetPos(aX - pnl.Popup:GetWide() + 48, aY + 48)
      pnl.Popup:SetDrawOnTop(true)
      pnl.Popup:MakePopup()
      pnl.Popup.Paint = function(pnl, w, h)
        XeninUI:DrawRoundedBoxEx(6, 0, 0, w, h, XeninUI.Theme.Primary, false, false, true, true)
      end
      pnl.Popup:DockPadding(8, 8, 8, 8)

      local top = pnl.Popup:Add("Panel")
      pnl.Popup.Top = top
      top:Dock(TOP)
      top:SetTall(36)
      top.PerformLayout = function(pnl, w, h)
        local width = w / 3 - 2

        for i, v in ipairs(pnl:GetChildren()) do
          v:SetWide(width)
        end
      end
      top.SetColor = function(pnl, color)
        local children = pnl:GetChildren()
        assert(color ~= nil, "cannot destructure nil value")
        local r, g, b = color.r, color.g, color.b

        children[1]:SetValue(r)
        children[2]:SetValue(g)
        children[3]:SetValue(b)

        panel.Color = Color(r, g, b)
      end
      top.GetColor = function(pnl)
        local children = pnl:GetChildren()

        return Color(children[1]:GetValue(), children[2]:GetValue(), children[3]:GetValue())
      end

      local function color(i, val)
        local _panel = top:Add("DPanel")
        _panel:Dock(LEFT)
        _panel:DockMargin(0, 0, 4, 0)
        _panel.Paint = function(pnl, w, h)
          local col
          if (i == 1) then
            col = XeninUI.Theme.Red
          elseif (i == 2) then
            col = XeninUI.Theme.Green
          elseif (i == 3) then
            col = XeninUI.Theme.Blue
          end

          XeninUI:DrawRoundedBox(6, 0, 0, w, h, col)
        end

        _panel.Textentry = _panel:Add("XeninUI.TextEntry")
        local textentry = _panel.Textentry
        textentry:Dock(FILL)
        textentry:DockMargin(1, 1, 1, 1)
        textentry.textentry:SetNumeric(true)
        textentry.textentry:SetUpdateOnType(true)
        textentry.textentry.OnValueChange = function(s, text)
          pnl.Popup.Picker:SetColor(top:GetColor())

          if s:HasFocus() then
            s:SetCaretPos(#s:GetText())
          end
        end
        _panel.SetValue = function(pnl, value)
          textentry:SetText(value)
        end
        _panel.GetValue = function(pnl)
          return tonumber(textentry:GetText()) or 0
        end
      end

      for i = 1, 3 do
        color(i)end

      pnl.Popup.Picker = pnl.Popup:Add("DColorMixer")
      local picker = pnl.Popup.Picker
      picker:SetPalette(false)
      picker:SetAlphaBar(false)
      picker:SetWangs(false)
      picker:Dock(FILL)
      picker:DockMargin(0, 8, 0, 0)
      picker.OnChange = function(pnl, color)
        local r = math.Round(color.r)
        local g = math.Round(color.g)
        local b = math.Round(color.b)

        top:SetColor(color)

        if panel.onChange then
          panel:onChange(color)
        end
      end
      picker.ValueChanged = picker.OnChange
      picker:SetColor(panel.Color)
    end
    panel:SetWide(48)
    panel.Color = Color(180, 180, 180)
    panel.Paint = function(pnl, w, h)
      local size = h / 4

      XeninUI:DrawCircle(h / 2, h / 2, size, 30, pnl.Color)
    end
    panel.SetInput = function(pnl, input)
      if isstring(input) then
        pnl.Color = XeninUI:HexToRGB("#" .. input)
      else
        pnl.Color = input
      end
    end
    panel.GetSettingValue = function(pnl)
      return pnl.Color
    end

    return panel
  end
  },
  ["Popup"] = {
  panel = function(self, tbl)
    local panel = vgui.Create("DButton")
    panel:SetText("")
    panel:DockMargin(0, 8, 6, 8)
    panel:SetWide(32)
    XeninUI:DownloadIcon(panel, "CEIrmnK")
    panel.Data = {}
    panel.GetSettingValue = function(pnl)
      return pnl.Data end
    panel.SetInput = function(pnl, value) end
    panel.Color = Color(180, 180, 180)
    panel.Paint = function(pnl, w, h)
      XeninUI:DrawIcon(4, 4, w - 8, h - 8, pnl, pnl.Color)
    end
    panel.OnCursorEntered = function(pnl, w, h)
      pnl:LerpColor("Color", color_white)
    end
    panel.OnCursorExited = function(pnl, w, h)
      pnl:LerpColor("Color", Color(180, 180, 180))
    end
    panel.RemovePopup = function(pnl)
      if (!IsValid(pnl.Popup)) then return end

      pnl.Popup:Remove()
    end
    panel.OnRemove = panel.RemovePopup
    panel.DoClick = function(pnl)
      pnl:RemovePopup()
    end

    return panel
  end
  },
  ["Range"] = {
  panel = function(self)
    local panel = vgui.Create("Panel")
    panel:DockMargin(0, 6, 6, 6)
    panel.SizeToContents = function(pnl)
      local h = pnl:GetTall()
      pnl.Min:SetTall(h)
      pnl.Separator:SetTall(h)
      pnl.Max:SetTall(h)


      local tw = 0
      surface.SetFont(pnl.Min.textentry:GetFont())
      tw = surface.GetTextSize(pnl.Min:GetText())
      tw = tw + 24
      tw = math.Clamp(tw, 28, 250)
      pnl.Min:SetWide(tw)


      tw = 0
      surface.SetFont(pnl.Max.textentry:GetFont())

      tw = surface.GetTextSize(pnl.Max:GetText())
      tw = tw + 24
      tw = math.Clamp(tw, 28, 250)
      pnl.Max:SetWide(tw)

      pnl.Separator:SizeToContents()

      local width = 0
      width = width + pnl.Min:GetWide()
      width = width + (8 + pnl.Separator:GetWide() + 8)
      width = width + pnl.Max:GetWide()

      pnl:SetWide(width)

      pnl.Min:SetPos(0, 0)
      pnl.Separator:SetPos(pnl.Min:GetWide() + 8, 9)
      pnl.Max:SetPos(pnl.Separator.x + pnl.Separator:GetWide() + 8, 0)
    end
    panel.PerformLayout = panel.SizeToContents

    panel.Min = panel:Add("XeninUI.TextEntry")
    panel.Min.textentry:SetUpdateOnType(true)
    panel.Min.textentry.OnValueChange = function(pnl)
      panel:SizeToContents()end

    panel.Separator = panel:Add("DLabel")
    panel.Separator:SetText("to")
    panel.Separator:SetFont("Xenin.Configurator.Inputs.Label")
    panel.Separator:SetContentAlignment(2)

    panel.Max = panel:Add("XeninUI.TextEntry")
    panel.Max.textentry:SetUpdateOnType(true)
    panel.Max.textentry.OnValueChange = function(pnl)
      panel:SizeToContents()end

    panel:SizeToContents()

    return panel
  end
  },
  ["TextentryList"] = {
  panel = function(self, tbl, extra)
    local split = {}
    if istable(tbl.value) then
      split = tbl.value
    else

      local value = string.Trim(tbl.value or "")
      split = util.JSONToTable(value)

      if (!split) then
        split = string.Explode(",", value)
      end
      if (value == "" or !split) then
        split = {}
      end
    end

    local panel = vgui.Create("DLabel")
    panel:DockMargin(0, 0, 8, 0)
    panel:SetFont("Xenin.Configurator.Inputs.Label")
    panel.SetTableData = function(pnl, data)
      local amt = #data
      tbl.dataRows = data

      pnl:SetAmount(amt)
    end
    panel.GetSettingValue = function(pnl)
      return tbl.dataRows
    end
    panel.SetAmount = function(pnl, amt)
      local suffix = "result" .. (amt != 1 and "s" or "")
      pnl:SetText(tostring(amt) .. " " .. tostring(suffix))
      pnl:SizeToContents()
    end
    panel.OnCursorEntered = function(pnl)
      pnl:SetCursor("hand")
    end
    panel.OnCursorExited = function(pnl)
      pnl:SetCursor("blank")
    end
    panel.RemovePopup = function(pnl)
      if (!IsValid(pnl.Popup)) then return end

      pnl.Popup:Remove()
    end
    panel.OnRemove = panel.RemovePopup
    panel.DoClick = function(pnl)
      local popup = vgui.Create("XeninUI.Configurator.DataPopup")
      pnl.Popup = popup
      popup:SetData(tbl, extra)
    end
    panel:SetTableData(split)

    return panel
  end
  },
  ["Key"] = {
  panel = function(self, tbl)
    local panel = vgui.Create("Panel")
    panel:DockMargin(0, 8, 6, 8)
    panel.Key = tbl.defaultValue
    panel.Font = "Xenin.Configurator.Inputs.Label"
    panel:SetCursor("hand")
    panel.Paint = function(pnl, w, h)
      local code = input.GetKeyName(pnl.Key) or "NONE"
      draw.SimpleText(code:upper(), pnl.Font, w / 2, h / 2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

      XeninUI:MaskInverse(function()
        XeninUI:DrawRoundedBox(6, 1, 1, w - 2, h - 2, color_white)
      end, function()
        XeninUI:DrawRoundedBox(6, 0, 0, w, h, pnl.Active and XeninUI.Theme.Accent or XeninUI.Theme.Primary)
      end)
    end
    panel.OnMousePressed = function(pnl)
      pnl.Active = true
      pnl:RequestFocus()
    end
    panel.OnFocusChanged = function(pnl, gained)
      pnl.Active = gained
    end
    panel.OnKeyCodeReleased = function(pnl, keyCode)
      if (!pnl.Active) then return end

      pnl.Key = keyCode == KEY_ESCAPE and KEY_NONE or keyCode
      pnl:SizeToContentsX()
      pnl:KillFocus()
      pnl.Active = nil
    end
    panel.GetSettingValue = function(pnl)
      return pnl.Key
    end
    panel.SizeToContentsX = function(pnl)
      local code = input.GetKeyName(pnl.Key) or "NONE"
      local font = pnl.Font
      local tw = surface.GetTextSize(code:upper())

      pnl:SetWide(tw + 16)
    end
    panel:SizeToContentsX()

    return panel
  end
  },
  ["KeyValue"] = {
  panel = function(self, tbl)
    local panel = vgui.Create("Panel")
    XeninUI:DownloadIcon(panel, "2QGKAd6")
    panel.ArrowColor = Color(180, 180, 180)
    panel.Rotation = 0
    panel:SetCursor("hand")
    panel.Paint = function(pnl, w, h)
      local size = 48 / 3
      XeninUI:DrawIconRotated(w - size, size + size / 2, size, size, pnl.Rotation, pnl, pnl.ArrowColor)
    end
    panel.SetExpanded = function(pnl, state)
      pnl.Active = state
      pnl:Lerp("Rotation", state and 180 or 0, 0.4)

      if (!IsValid(pnl.SettingsDropdown) and state) then
        pnl:CreateDropdown()
      end

      pnl:SetHeight(state)
    end
    panel.SetHeight = function(pnl, state)
      local parent = pnl:GetParent()
      local height = 48
      if state then height = height + pnl.SettingsDropdown:GetHeight()
      end
      pnl.Think = function()

        parent:GetParent():GetParent():GetParent():InvalidateLayout(true)
      end
      parent:EndAnimations()
      parent:Lerp("Height", height, 0.4)
      parent:LerpHeight(height, 0.4, function()
        if (!IsValid(pnl)) then return end

        pnl.Think = function() end
      end)
    end
    panel.OnCursorEntered = function(pnl)
      pnl:LerpColor("ArrowColor", color_white)
    end
    panel.OnCursorExited = function(pnl)
      if (pnl.Active) then return end

      pnl:LerpColor("ArrowColor", Color(180, 180, 180))
    end
    panel.OnMousePressed = function(pnl)
      pnl:SetExpanded(!pnl.Active)
    end
    panel.CreateDropdown = function(pnl)
      local settings = pnl:Add("Panel")
      pnl.SettingsDropdown = settings
      settings:Dock(FILL)
      settings:DockMargin(0, 48, 0, 8)
      settings.GetHeight = function(pnl)
        local h = 48
        for i, v in ipairs(pnl.Rows) do
          h = h + (v:GetTall() + 4)
        end

        return h
      end

      settings.Content = settings:Add("Panel")
      settings.Content:Dock(FILL)
      settings.Content:DockMargin(0, 0, 0, 8)

      settings.Rows = {}

      settings.Bottom = settings:Add("Panel")
      settings.Bottom:Dock(BOTTOM)
      settings.Bottom:SetTall(32)

      settings.New = settings.Bottom:Add("XeninUI.ButtonV2")
      settings.New:Dock(RIGHT)
      settings.New:SetText("Create New")
      settings.New:SetFont("Xenin.Configurator.KeyValue")
      settings.New:SizeToContentsX(24)
      settings.New:SetRoundness(6)
      settings.New:SetSolidColor(XeninUI.Theme.Primary)
      settings.New:SetHoverColor(XeninUI.Theme.Green)
      settings.New.DoClick = function(pnl)
        settings:CreateRow(nil, tbl.data.right.default)

        settings:GetParent():SetHeight(true)
      end

      settings.SetData = function(pnl, data)
        for i, v in pairs(data) do
          pnl:CreateRow(i, v)
        end
      end

      settings.CreateRow = function(pnl, i, v)
        local col = XeninUI.Theme.Navbar
        local row = settings.Content:Add("Panel")
        row:Dock(TOP)
        row:DockMargin(0, 0, 0, 4)
        row:SetTall(40)
        row.Think = function(pnl)
          pnl.Delete:SetVisible(pnl:IsHovered() or pnl:IsChildHovered())
        end
        row.Paint = function(pnl, w, h)
          XeninUI:DrawRoundedBox(6, 0, 0, w, h, col)
        end

        local left = tbl.data.left or {}
        row.Left = XeninUI.Configurator:CreateInputPanel(left.type, self, tbl)
        row.Left:SetParent(row)
        row.Left:Dock(LEFT)
        row.Left:DockMargin(0, 0, 0, 0)
        if (left.type == "Textentry") then
          row.Left:SetPlaceholder(left.placeholder or "")
          row.Left:SetInput(i or "")
          row.Left:SetTextColor(Color(180, 180, 180))
          local paint = row.Left.Paint
          row.Left.OutlineColor = XeninUI.Theme.Primary
          row.Left.Paint = function(pnl, w, h)
            if paint then paint(pnl, w, h)end

            XeninUI:MaskInverse(function()
              XeninUI:DrawRoundedBoxEx(6, 1, 1, w - 2, h - 2, pnl.OutlineColor, true, false, true, false)
            end, function()
              XeninUI:DrawRoundedBoxEx(6, 0, 0, w, h, pnl.textentry:HasFocus() and XeninUI.Theme.Accent or pnl.OutlineColor, true, false, true, false)
            end)
          end
        end
        if row.Left.SetData then
          row.Left:SetData(tbl.data.left)
          row.Left:SetInput(i or tbl.data.left.default)
        end
        if row.Left.SetBackgroundColor then
          row.Left:SetBackgroundColor(col)
        end

        local right = tbl.data.right or {}
        row.Right = XeninUI.Configurator:CreateInputPanel(right.type, self, right)
        row.Right:SetParent(row)
        row.Right:Dock(RIGHT)
        row.Right:DockMargin(0, 0, 0, 0)
        if (right.type == "Textentry") then
          if right.placeholder then
            row.Right:SetPlaceholder(right.placeholder)
          end
          row.Right:SetInput(tostring(v))
          if right.readOnly then
            row.Right:SetEnabled(false)
            row.Right.textentry:SetEnabled(false)
            row.Right.textentry:SetCursor("no")
          end
          if right.number then
            row.Right:SetNumeric(true)
          end
        elseif (right.type == "TextentryWithLabel") then
          row.Right.textentry:SetPlaceholder(right.placeholder or "")
          row.Right.textentry:SetText(v or right.default or "")
          row.Right.textentry:DoSizing(row.Right.textentry:GetText())
        end

        if row.Right.SetBackgroundColor then
          row.Right:SetBackgroundColor(col)
        end

        row.Right:SetVisible(!right.hide)

        row.Delete = row:Add("DButton")
        row.Delete:SetVisible(false)
        row.Delete:Dock(RIGHT)
        row.Delete:SetText("")
        row.Delete.Paint = function(pnl, w, h)
          XeninUI:DrawRoundedBox(6, 4, 4, w - 8, h - 8, XeninUI.Theme.Red)

          surface.SetMaterial(XeninUI.Materials.CloseButton)
          surface.SetDrawColor(color_white)
          local size = h * 0.35
          surface.DrawTexturedRect(w / 2 - size / 2, h / 2 - size / 2, size, size)
        end
        row.Delete.DoClick = function(pnl, w, h)
          for i, v in ipairs(settings.Rows) do
            if (tobool(v != row)) then continue end

            table.remove(settings.Rows, i)
          end

          row:Remove()
          settings:GetParent():SetHeight(true)
        end
        row.Delete:SetWide(40)

        row.GetSettingValue = function(pnl)
          return {
            key = pnl.Left:GetSettingValue(),
            value = pnl.Right:GetSettingValue()
          }
        end

        table.insert(pnl.Rows, row)
      end

      settings:SetData(tbl.value)
    end
    panel:SetWide(600)
    panel.GetSettingValue = function(pnl)
      if (!IsValid(pnl.SettingsDropdown)) then
        pnl:CreateDropdown()
      end

      local tbl = {}

      for i, v in ipairs(pnl.SettingsDropdown.Rows) do
        local rowTbl = v:GetSettingValue()
        tbl[rowTbl.key] = rowTbl.value
      end

      return tbl
    end

    return panel
  end
  },
  ["SliderPad"] = {
  panel = function(self, tbl)
    local panel = vgui.Create("XeninUI.SliderPad")
    panel:DockMargin(0, 8, 0, 8)
    panel.GetSettingValue = function(pnl)
      return pnl:GetValue()
    end
    panel.Textentry:SetWide(((tbl and tbl.data) and tbl.data.textWidth) or 40)

    panel:SetMin(((tbl and tbl.data) and tbl.data.min) or 0)
    panel:SetMax(((tbl and tbl.data) and tbl.data.max) or 10)
    panel:SetValue(tbl.value)
    panel:SetWide(((tbl and tbl.data) and tbl.data.width) or 200)
    panel:SetColor(((tbl and tbl.data) and tbl.data.color) or XeninUI.Theme.Accent)

    return panel
  end
  },
  ["ListDropdownDarkRPCategories"] = {
  panel = function(self, tbl)
    local panel = vgui.Create("Panel")
    XeninUI:DownloadIcon(panel, "2QGKAd6")
    panel.ArrowColor = Color(180, 180, 180)
    panel.Rotation = 0
    panel:SetCursor("hand")
    panel.Paint = function(pnl, w, h)
      local size = 48 / 3
      XeninUI:DrawIconRotated(w - size, size + size / 2, size, size, pnl.Rotation, pnl, pnl.ArrowColor)
    end
    panel.SetExpanded = function(pnl, state)
      pnl.Active = state
      pnl:Lerp("Rotation", state and 180 or 0, 0.4)

      if (!IsValid(pnl.SettingsDropdown) and state) then
        pnl:CreateDropdown()
      end

      pnl:SetHeight(state)
    end
    panel.SetHeight = function(pnl, state)
      local parent = pnl:GetParent()
      local height = 48
      if state then height = height + pnl.SettingsDropdown:GetHeight()
      end
      pnl.Think = function()

        parent:GetParent():GetParent():GetParent():InvalidateLayout(true)
      end
      parent:EndAnimations()
      parent:Lerp("Height", height, 0.4)
      parent:LerpHeight(height, 0.4, function()
        if (!IsValid(pnl)) then return end

        pnl.Think = function() end
      end)
    end
    panel.OnCursorEntered = function(pnl)
      pnl:LerpColor("ArrowColor", color_white)
    end
    panel.OnCursorExited = function(pnl)
      if (pnl.Active) then return end

      pnl:LerpColor("ArrowColor", Color(180, 180, 180))
    end
    panel.OnMousePressed = function(pnl)
      pnl:SetExpanded(!pnl.Active)
    end
    panel.CreateDropdown = function(pnl)
      local settings = pnl:Add("Panel")
      pnl.SettingsDropdown = settings
      settings:Dock(FILL)
      settings:DockMargin(0, 48, 0, 8)
      settings.GetHeight = function(pnl)
        local h = 48
        for i, v in ipairs(pnl.Rows) do
          h = h + (v:GetTall() + 4)
        end

        return h
      end

      settings.Content = settings:Add("Panel")
      settings.Content:Dock(FILL)
      settings.Content:DockMargin(0, 0, 0, 8)

      settings.Rows = {}

      settings.Bottom = settings:Add("Panel")
      settings.Bottom:Dock(BOTTOM)
      settings.Bottom:SetTall(32)

      settings.New = settings.Bottom:Add("XeninUI.ButtonV2")
      settings.New:Dock(RIGHT)
      settings.New:SetText("Add New")
      settings.New:SetFont("Xenin.Configurator.KeyValue")
      settings.New:SizeToContentsX(24)
      settings.New:SetRoundness(6)
      settings.New:SetSolidColor(XeninUI.Theme.Primary)
      settings.New:SetHoverColor(XeninUI.Theme.Green)
      settings.New.DoClick = function(btn)
        local existingCategories = pnl:GetSettingValue()
        local allCategories = DarkRP.getCategories().jobs
        local categories = {}
        for i, v in ipairs(allCategories) do
          if (existingCategories[v.name]) then continue end

          table.insert(categories, v)
        end

        local options = XeninUI.Options(pnl)
        for i, v in ipairs(categories) do
          options:addButton({
            text = v.name,
            onClick = function()
              settings:CreateRow(v.name)
              settings:GetParent():SetHeight(true)
            end
          })
        end
        options:create()
      end

      settings.SetData = function(pnl, data)
        for i, v in pairs(data) do
          print(i, v)
          pnl:CreateRow(i)
        end
      end
      settings.CreateRow = function(pnl, name)
        local col = XeninUI.Theme.Navbar
        local row = settings.Content:Add("Panel")
        row:Dock(TOP)
        row:DockMargin(0, 0, 0, 4)
        row:SetTall(40)
        row.Think = function(pnl)
          pnl.Delete:SetVisible(pnl:IsHovered() or pnl:IsChildHovered())
        end
        row.Paint = function(pnl, w, h)
          XeninUI:DrawRoundedBox(6, 0, 0, w, h, col)
        end

        row.Left = row:Add("DLabel")
        row.Left:Dock(LEFT)
        row.Left:DockMargin(12, 0, 0, 0)
        row.Left:SetFont("XeninUI.TextEntry")
        row.Left:SetText(name)
        row.Left:SetTextColor(Color(180, 180, 180))
        row.Left:SizeToContentsX()

        row.Delete = row:Add("DButton")
        row.Delete:SetVisible(false)
        row.Delete:Dock(RIGHT)
        row.Delete:SetText("")
        row.Delete.Paint = function(pnl, w, h)
          XeninUI:DrawRoundedBox(6, 4, 4, w - 8, h - 8, XeninUI.Theme.Red)

          surface.SetMaterial(XeninUI.Materials.CloseButton)
          surface.SetDrawColor(color_white)
          local size = h * 0.35
          surface.DrawTexturedRect(w / 2 - size / 2, h / 2 - size / 2, size, size)
        end
        row.Delete.DoClick = function(pnl, w, h)
          for i, v in ipairs(settings.Rows) do
            if (tobool(v != row)) then continue end

            table.remove(settings.Rows, i)
          end

          row:Remove()
          settings:GetParent():SetHeight(true)
        end
        row.Delete:SetWide(40)

        row.GetSettingValue = function(pnl)
          return {
            key = pnl.Left:GetText(),
            value = true
          }
        end

        table.insert(pnl.Rows, row)
      end

      settings:SetData(tbl.value)
    end
    panel:SetWide(600)
    panel.GetSettingValue = function(pnl)
      if (!IsValid(pnl.SettingsDropdown)) then
        pnl:CreateDropdown()
      end

      local tbl = {}

      for i, v in ipairs(pnl.SettingsDropdown.Rows) do
        local rowTbl = v:GetSettingValue()
        tbl[rowTbl.key] = rowTbl.value
      end

      return tbl
    end

    return panel
  end
  }
}

function XeninUI.Configurator:CreateInputPanel(panel, bindTo, tbl, extra)
  if extra == nil then extra = {}
  end
  return self.InputPanels[panel].panel(bindTo, tbl, extra)
end

local PANEL = {}

XeninUI:CreateFont("Xenin.Configurator.Admin.Data.Title", 22)
XeninUI:CreateFont("Xenin.Configurator.Admin.Data.Button", 16)
XeninUI:CreateFont("Xenin.Configurator.Admin.Data.Row", 16)

function PANEL:Init()
  self:SetSize(ScrW(), ScrH())
  self:SetBackgroundWidth(500)
  self:SetBackgroundHeight(500)
  self:MakePopup()

  self.Body = self:Add("Panel")
  self.Body:Dock(FILL)
  self.Body:DockPadding(16, 16, 16, 16)

  self.Top = self.Body:Add("Panel")
  self.Top:Dock(TOP)
  self.Top:SetTall(28)

  self.Title = self.Top:Add("DLabel")
  self.Title:Dock(LEFT)
  self.Title:SetFont("Xenin.Configurator.Admin.Data.Title")

  self.Save = self.Top:Add("XeninUI.ButtonV2")
  self.Save:Dock(RIGHT)
  self.Save:SetFont("Xenin.Configurator.Admin.Data.Button")
  self.Save:SetText("Save Rows")
  self.Save:SizeToContentsX(16)
  self.Save:SetRoundness(6)
  self.Save:SetSolidColor(XeninUI.Theme.Blue)
  self.Save.DoClick = function(pnl)
    self:OnSave(self.Results)
  end

  self.Create = self.Top:Add("XeninUI.ButtonV2")
  self.Create:Dock(RIGHT)
  self.Create:DockMargin(0, 0, 8, 0)
  self.Create:SetFont("Xenin.Configurator.Admin.Data.Button")
  self.Create:SetText("Create New")
  self.Create:SizeToContentsX(16)
  self.Create:SetRoundness(6)
  self.Create:SetSolidColor(XeninUI.Theme.Primary)
  self.Create.DoClick = function(pnl)
    local newId = #self.Results + 1

    self:CreateRow(newId, "")
    self:SetResultsTitle()
  end

  self.Scroll = self.Body:Add("XeninUI.Scrollpanel.Wyvern")
  self.Scroll:Dock(FILL)
  self.Scroll:DockMargin(0, 16, 0, 0)
end

function PANEL:Add(pnl)
  return self.background:Add(pnl)
end

function PANEL:SetData(data, extra)
  self.Results = data.dataRows
  self.Data = data
  self.Extra = extra

  self:SetTitle(extra.name)
  self:CreateRows(self.Results)
end

function PANEL:SetResultsTitle()
  local amt = #self.Results
  local str = "row" .. (amt != 1 and "s" or "")
  self.Title:SetText(amt .. " " .. str)
  self.Title:SizeToContents()
end

function PANEL:CreateRows(data)
  for i, v in ipairs(data) do
    self:CreateRow(i, v)
  end

  self:SetResultsTitle()
end

function PANEL:CreateRow(id, val)
  local row = self.Scroll:Add("DPanel")
  row:Dock(TOP)
  row:DockMargin(0, 0, 8, 4)
  row:SetTall(36)
  row.Id = id
  row.Color = id % 2 == 0 and XeninUI.Theme.Primary or XeninUI.Theme.Navbar
  row.Paint = function(pnl, w, h)
    XeninUI:DrawRoundedBox(6, 0, 0, w, h, pnl.Color)

    draw.SimpleText("#" .. tostring(pnl.Id), "Xenin.Configurator.Admin.Data.Row", 8, h / 2, Color(174, 174, 174), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)

    pnl.Delete:SetVisible(pnl:IsHovered() or pnl:IsChildHovered())
  end

  row.Delete = row:Add("DButton")
  row.Delete:Dock(LEFT)
  row.Delete:SetWide(40)
  row.Delete:SetText("")
  row.Delete.Paint = function(pnl, w, h)
    XeninUI:DrawRoundedBoxEx(6, 0, 0, w, h, XeninUI.Theme.Red, true, false, true, false)

    surface.SetMaterial(XeninUI.Materials.CloseButton)
    surface.SetDrawColor(color_white)
    local size = h * 0.4
    surface.DrawTexturedRect(w / 2 - size / 2, h / 2 - size / 2, size, size)
  end
  row.Delete.DoClick = function(pnl, w, h)
    table.remove(self.Results, row.Id)
    row:Remove()

    local index = 1
    for i, v in ipairs(self.Scroll:GetCanvas():GetChildren()) do
      if (!IsValid(v)) then continue end

      v.Id = index
      v.Input.textentry:OnValueChange(v.Input:GetText())

      index = index + 1
    end

    self:SetResultsTitle()
  end

  row.Input = row:Add("XeninUI.TextEntry")
  row.Input:Dock(RIGHT)
  row.Input:SetBackgroundColor(row.Color)
  row.Input:SetFont("Xenin.Configurator.Admin.Data.Row")
  row.Input:SetPlaceholder("Value")
  row.Input.textentry:SetUpdateOnType(true)
  row.Input.textentry.OnValueChange = function(pnl, text)
    surface.SetFont(pnl:GetFont())
    local text = pnl:GetText()
    self.Results[row.Id] = text
    if (text == "") then text = row.Input:GetPlaceholder()end
    local tw = surface.GetTextSize(text)
    tw = tw + 24
    local width = math.Clamp(tw, 28, 600)
    row.Input:SetWide(width)
  end
  row.Input:SetText(val)
  row.Input.textentry:OnValueChange(val)
end

function PANEL:OnSave(data)
  self.Extra.parent.Input:SetTableData(data)
end

vgui.Register("XeninUI.Configurator.DataPopup", PANEL, "XeninUI.Popup")

--PATH lua/xeninui/libs/configurator/ui/inputs/blank.lua:
local x

--PATH lua/xeninui/libs/configurator/ui/inputs/textentry.lua:
return gluapack()()
--PATH lua/xeninui/libs/players/controller.lua:
return gluapack()()
--PATH lua/xeninui/elements/animated_texture.lua:
return gluapack()()
--PATH lua/xeninui/elements/avatar.lua:
local PANEL = {}

AccessorFunc(PANEL, "vertices", "Vertices", FORCE_NUMBER)
AccessorFunc(PANEL, "rotation", "Rotation", FORCE_NUMBER)

function PANEL:Init()
  self.rotation = 0
  self.vertices = 4
  self.scaler = 1
  self.avatar = vgui.Create("AvatarImage", self)
  self.avatar:SetPaintedManually(true)
end

function PANEL:CalculatePoly(w, h)
  local poly = {}

  local x = w / 2
  local y = h / 2 * self.scaler
  local radius = h / 2

  table.insert(poly, {
    x = x,
    y = y
  })

  for i = 0, self.vertices do
    local a = math.rad((i / self.vertices) * -360) + self.rotation
    table.insert(poly, {
      x = x + math.sin(a) * radius,
      y = y + math.cos(a) * (radius * self.scaler)
    })
  end

  local a = math.rad(0)
  table.insert(poly, {
    x = x + math.sin(a) * radius,
    y = y + math.cos(a) * (radius * self.scaler)
  })
  self.data = poly
end

function PANEL:PerformLayout(w, actualH)
  local h = self:GetTall()
  if (self.scaler < 1) then
    h = h * self.scaler
  end

  self.avatar:SetPos(0, h - actualH)
  self.avatar:SetSize(self:GetWide(), actualH)
  self:CalculatePoly(self:GetWide(), self:GetTall())
end

function PANEL:SetPlayer(ply, size)
  self.avatar:SetPlayer(ply, size)
end

function PANEL:SetSteamID(sid64, size)
  self.avatar:SetSteamID(sid64, size)
end
function PANEL:DrawPoly(w, h)
  if (!self.data) then
    self:CalculatePoly(w, h)
  end

  surface.DrawPoly(self.data)
end

function PANEL:Paint(w, h)
  render.ClearStencil()
  render.SetStencilEnable(true)

  render.SetStencilWriteMask(1)
  render.SetStencilTestMask(1)

  render.SetStencilFailOperation(STENCILOPERATION_REPLACE)
  render.SetStencilPassOperation(STENCILOPERATION_ZERO)
  render.SetStencilZFailOperation(STENCILOPERATION_ZERO)
  render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_NEVER)
  render.SetStencilReferenceValue(1)

  draw.NoTexture()
  surface.SetDrawColor(color_white)
  self:DrawPoly(w, h)

  render.SetStencilFailOperation(STENCILOPERATION_ZERO)
  render.SetStencilPassOperation(STENCILOPERATION_REPLACE)
  render.SetStencilZFailOperation(STENCILOPERATION_ZERO)
  render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_EQUAL)
  render.SetStencilReferenceValue(1)

  self.avatar:PaintManual()

  render.SetStencilEnable(false)
  render.ClearStencil()
end
vgui.Register("XeninUI.Avatar", PANEL)

--PATH lua/xeninui/elements/button.lua:
return gluapack()()
--PATH lua/xeninui/elements/colormixer.lua:
return gluapack()()
--PATH lua/xeninui/elements/popup.lua:
local PANEL = {}

AccessorFunc(PANEL, "m_bgWidth", "BackgroundWidth")
AccessorFunc(PANEL, "m_bgHeight", "BackgroundHeight")

function PANEL:Init()
  self.background = vgui.Create("XeninUI.Frame", self)
  self.background.Paint = function(pnl, w, h)
    local x, y = pnl:LocalToScreen(0, 0)

    BSHADOWS.BeginShadow()
    draw.RoundedBox(6, x, y, w, h, XeninUI.Theme.Background)
    BSHADOWS.EndShadow(1, 2, 2, 150, 0, 0)
  end
  self.background.closeBtn.DoClick = function(pnl)
    self:Remove()
  end
end

function PANEL:Paint(w, h)
  surface.SetDrawColor(20, 20, 20, 160)
  surface.DrawRect(0, 0, w, h)
end

function PANEL:PerformLayout(w, h)
  self.background:SetSize(self:GetBackgroundWidth(), self:GetBackgroundHeight())
  self.background:Center()
end

function PANEL:SetTitle(str)
  self.background:SetTitle(str)
end

vgui.Register("XeninUI.Popup", PANEL, "EditablePanel")

--PATH lua/xeninui/elements/purchase_confirmation.lua:
return gluapack()()
--PATH lua/xeninui/elements/query.lua:
local PANEL = {}

AccessorFunc(PANEL, "custom_width", "CustomWidth", FORCE_NUMBER)

XeninUI:CreateFont("XeninUI.Query.Text", 18)
XeninUI:CreateFont("XeninUI.Query.Button", 18)
XeninUI:CreateFont("XeninUI.Query.Option", 20)

function PANEL:Init()
  self.onAccept = function() end
  self.onDecline = function() end

  self.background.text = self.background:Add("DLabel")
  self.background.text:SetText("XD")
  self.background.text:SetFont("XeninUI.Query.Text")
  self.background.text:SetContentAlignment(8)
  self.background.text:SetTextColor(Color(200, 200, 200))

  self.background.input = self.background:Add("XeninUI.TextEntry")
  self.background.input:SetVisible(false)

  self.background.option = self.background:Add("DButton")
  self.background.option:SetVisible(false)
  self.background.option:SetText("")
  self.background.option.Paint = function(pnl, w, h)
    XeninUI:DrawRoundedBox(6, 0, 0, w, h, XeninUI.Theme.Navbar)

    local text = pnl.Text or "None Selected"
    XeninUI:DrawShadowText(text, "XeninUI.Query.Option", w / 2, h / 2, Color(184, 184, 184), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 1, 150)
  end
  self.background.option.DoClick = function(pnl)
    if IsValid(pnl.Dropdown) then return end

    pnl.Dropdown = vgui.Create("XeninUI.PlayerDropdown")
    pnl.Dropdown:SetParentPanel(pnl)
    pnl.Dropdown:SetData(self.optionData)
    pnl.Dropdown:SetDrawOnTop(true)
    local x, y = pnl:LocalToScreen()
    pnl.Dropdown:SetPos(x, y + pnl:GetTall())
    pnl.Dropdown:MakePopup()
    pnl.Dropdown.OnSelected = function(dropdown, sid64)

      if (!sid64) then return end
      local ply = player.GetBySteamID64(sid64)
      pnl.Text = ply:Nick()

      self.background.option.sid64 = sid64
    end
  end
  self.background.option.OnRemove = function(pnl)
    if IsValid(pnl.Dropdown) then
      pnl.Dropdown:Remove()
    end
  end

  self.background.accept = self.background:Add("DButton")
  self.background.accept:SetText("Accept")
  self.background.accept:SetFont("XeninUI.Query.Button")
  self.background.accept:SetTextColor(Color(21, 21, 21))
  self.background.accept.Paint = function(pnl, w, h)
    draw.RoundedBox(6, 0, 0, w, h, XeninUI.Theme.Green)
  end
  self.background.accept.DoClick = function(pnl)
    self:onAccept(pnl, self.background.input:GetText(), self.background.option.sid64)
    self:Remove()
  end

  self.background.decline = self.background:Add("DButton")
  self.background.decline:SetText("Decline")
  self.background.decline:SetFont("XeninUI.Query.Button")
  self.background.decline:SetTextColor(Color(145, 145, 145))
  self.background.decline.Paint = function(pnl, w, h)
    draw.RoundedBox(6, 0, 0, w, h, XeninUI.Theme.Navbar)
    draw.RoundedBox(6, 2, 2, w - 4, h - 4, XeninUI.Theme.Background)
  end
  self.background.decline.DoClick = function(pnl)
    self:onDecline(pnl, self.background.input:GetText(), self.background.option.sid64)
    self:Remove()
  end
end

function PANEL:PerformLayout(w, h)
  if (!self:GetCustomWidth()) then
    surface.SetFont(self.background.text:GetFont())
    local tw = surface.GetTextSize(self.background.text:GetText())
    self:SetBackgroundWidth(tw + 32)
  else
    self:SetBackgroundWidth(self:GetCustomWidth())
  end

  self.BaseClass.PerformLayout(self, w, h)

  self.background.text:SetWide(self.background:GetWide())
  self.background.text:SizeToContentsY()
  self.background.text:SetPos(0, 56)

  self.background.accept:SizeToContentsX(32)
  self.background.accept:SizeToContentsY(16)
  self.background.decline:SizeToContentsX(32)
  self.background.decline:SizeToContentsY(16)

  if self.background.input:IsVisible() then
    self.background.input:SetSize(math.max(self.background.accept:GetWide() + self.background.decline:GetWide() + 8, self.background:GetWide() * 0.75), 32)
    self.background.input:SetPos(0, 88)
    self.background.input:CenterHorizontal()
  end

  if self.background.option:IsVisible() then
    self.background.option:SetSize(math.max(self.background.accept:GetWide() + self.background.decline:GetWide() + 8, self.background:GetWide() * 0.75), 32)

    local inputVisible = self.background.input:IsVisible()
    self.background.option:SetPos(0, 88 + (inputVisible and 44 or 0))
    self.background.option:CenterHorizontal()
  end

  local y = self.background:GetTall() - self.background.accept:GetTall() - 16
  self.background.accept:SetPos(self.background:GetWide() / 2 - self.background.accept:GetWide() / 2 - self.background.decline:GetWide() / 2 - 4, y)
  self.background.decline:SetPos(self.background:GetWide() / 2 + self.background.accept:GetWide() / 2 - self.background.decline:GetWide() / 2 + 4, y)
end

function PANEL:SetInput(str, placeholder, numeric)
  self.background.input:SetVisible(true)
  self.background.input:SetText(str)
  self.background.input:SetPlaceholder(placeholder)
  self.background.input.textentry:SetNumeric(numeric)
end

function PANEL:SetOption(tbl)
  self.background.option:SetVisible(true)
  self.optionData = tbl
end

function PANEL:SetText(text)
  self.background.text:SetText(text)
end

function PANEL:SetAccept(text, func)
  self.background.accept:SetText(text)
  self.onAccept = func
end

function PANEL:SetDecline(text, func)
  self.background.decline:SetText(text)
  self.onDecline = func
end

vgui.Register("XeninUI.Query", PANEL, "XeninUI.Popup")

function XeninUI:SimpleQuery(title, text, yesText, yesFunc, noText, noFunc)
  local queryMenu = vgui.Create("XeninUI.Query")
  queryMenu:SetSize(ScrW(), ScrH())
  queryMenu:SetBackgroundHeight(140)

  queryMenu:SetTitle(title or "Title")
  queryMenu:SetText(text or "Text")

  queryMenu:SetAccept(yesText or "Yes", yesFunc or (function() end))
  queryMenu:SetDecline(noText or "No", noFunc or (function() end))

  queryMenu:MakePopup()

  return queryMenu
end

--PATH lua/xeninui/elements/query_single_button.lua:
return gluapack()()
--PATH lua/xeninui/elements/sidebar.lua:
return gluapack()()
--PATH lua/xeninui/elements/sidebar_v2.lua:
return gluapack()()
--PATH lua/xeninui/elements/slider.lua:
return gluapack()()
--PATH lua/xeninui/elements/textentry.lua:
XeninUI:CreateFont("XeninUI.TextEntry", 18)

local PANEL = {}

AccessorFunc(PANEL, "m_backgroundColor", "BackgroundColor")
AccessorFunc(PANEL, "m_rounded", "Rounded")
AccessorFunc(PANEL, "m_placeholder", "Placeholder")
AccessorFunc(PANEL, "m_textColor", "TextColor")
AccessorFunc(PANEL, "m_placeholderColor", "PlaceholderColor")
AccessorFunc(PANEL, "m_iconColor", "IconColor")

function PANEL:Init()
	self:SetBackgroundColor(XeninUI.Theme.Navbar)
	self:SetRounded(6)
	self:SetPlaceholder("")
	self:SetTextColor(Color(205, 205, 205))
	self:SetPlaceholderColor(Color(120, 120, 120))
	self:SetIconColor(self:GetTextColor())

	self.textentry = vgui.Create("DTextEntry", self)
	self.textentry:Dock(FILL)
	self.textentry:DockMargin(8, 8, 8, 8)
	self.textentry:SetFont("XeninUI.TextEntry")
	self.textentry:SetDrawLanguageID(false)
	self.textentry.Paint = function(pnl, w, h)
		local col = self:GetTextColor()

		pnl:DrawTextEntryText(col, col, col)

		if (#pnl:GetText() == 0) then
			draw.SimpleText(self:GetPlaceholder() or "", pnl:GetFont(), 3, pnl:IsMultiline() and 8 or h / 2, self:GetPlaceholderColor(), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
		end
	end
	self.textentry.OnValueChange = function(pnl, text)
		self:OnValueChange(text)
	end
end

function PANEL:SetNumeric(bool)
	self.textentry:SetNumeric(true)end
function PANEL:GetNumeric()
	return self.textentry:GetNumeric()end
function PANEL:SetUpdateOnType(bool)
	self.textentry:SetUpdateOnType(true)end
function PANEL:GetUpdateOnType()
	return self.textentry:GetUpdateOnType()end
function PANEL:OnValueChanged() end

function PANEL:SetFont(str)
	self.textentry:SetFont(str)
end

function PANEL:GetFont()
	return self.textentry:GetFont()
end

function PANEL:GetText()
	return self.textentry:GetText()
end

function PANEL:SetText(str)
	self.textentry:SetText(str)
end

function PANEL:SetMultiLine(state)
	self:SetMultiline(state)
	self.textentry:SetMultiline(state)
end

function PANEL:SetLabel(label, left, textColor, offset)
	if offset == nil then offset = 0
	end
	if IsValid(self.label) then self.label:Remove()end

	self.label = self:Add("DLabel")
	self.label:Dock(left and LEFT or RIGHT)
	self.label:DockMargin(left and 10 or -5, 10, (left and -9 or 8) - offset, 10)
	self.label:SetText(label)
	self.label:SetTextColor(textColor or ColorAlpha(self:GetTextColor(), 175))
	self.label:SetFont(self.textentry:GetFont())
	self.label:SizeToContentsX()
end

function PANEL:SetIcon(icon, left)
	if (!IsValid(self.icon)) then
		self.icon = vgui.Create("DButton", self)
		self.icon:SetText("")
		self.icon:Dock(left and LEFT or RIGHT)
		self.icon:DockMargin(left and 10 or -5, 10, left and 0 or 10, 10)
		self.icon.Paint = function(pnl, w, h)
			surface.SetDrawColor(self:GetIconColor())
			surface.SetMaterial(pnl.mat)
			surface.DrawTexturedRect(0, 0, w, h)
		end
		self.icon.DoClick = function(pnl)
			self.textentry:RequestFocus()
		end
	end

	self.icon.mat = icon
end

function PANEL:PerformLayout(w, h)
	if IsValid(self.icon) then
		self.icon:SetWide(self.icon:GetTall())
	end
end

function PANEL:OnMousePressed()
	self.textentry:RequestFocus()
end

function PANEL:Paint(w, h)
	draw.RoundedBox(self:GetRounded(), 0, 0, w, h, self:GetBackgroundColor())
end

vgui.Register("XeninUI.TextEntry", PANEL)

--PATH lua/autorun/zyg_captain_addon.lua:
player_manager.AddValidModel( "Zygerrian Empire Captain", "models/player/zygerrian/zygerrian_cpt.mdl" );
list.Set( "PlayerOptionsModel",  "Zygerrian Empire Captain", "models/player/zygerrian/zygerrian_cpt.mdl" );


--PATH lua/autorun/client/cl_alydusfortificationbuildertablet_meta.lua:
--[[
 - Fortification Builder Tablet
 - 
 - /lua/autorun/client/cl_alydusfortificationbuildertablet_meta.lua
 -
 - Primary meta functions utilised by /lua/weapons/alydus_fortificationbuildertablet.lua
 - 
 - Feel free to modify, but please leave appropriate credit.
 - Do not reupload this (modified or original) to this workshop, however you may ruin modified versions on your servers.
 - Assets included for fortifications Alydus does not own the rights to, so do as you wish, but its suggested you also leave appropriate credit.
 -
 - Thanks so much for the support with the addon since it's creation in 2018.
 -
 --]]

 local ply = FindMetaTable("Player")

--[[
 -
 - Player:ShouldDrawAlydusFortification
 -
 - Determines if the player should be drawing a fortification
 -
 --]]
 function ply:CanDrawAlydusFortification()
    -- Check if player is valid, a player and alive
    if !IsValid(self) or !self:IsPlayer() or !self:Alive() then
        return false
    end

    -- Check if player is crouching or moving
    if self:Crouching() or self:GetVelocity():Length() > 25 then
        return false
    end

    -- Check if the player is too far away from potentially placing a fortification
    if self:GetPos():DistToSqr(self:GetEyeTrace().HitPos) > (250 ^ 2) then
        return false
    end

    -- Check if player has an active weapon and it is the fortification builder tablet
    if !IsValid(self:GetActiveWeapon()) or self:GetActiveWeapon():GetClass() != "alydus_fortificationbuildertablet" then
        return false
    end

    -- Check if tablet is booting up
    if self:GetActiveWeapon():GetIsBootingUp() == true then
        return false
    end

    return true
 end

--[[
 -
 - Player:CanSelectNextAlydusFortification
 -
 - Determines if the player can select the next fortification
 -
 --]]
 function ply:CanSelectNextAlydusFortification()
    -- Check if player is valid, a player and alive
    if !IsValid(self) or !self:IsPlayer() or !self:Alive() then
        return false
    end

    -- Check if player is crouching or moving
    if self:Crouching() or self:GetVelocity():Length() > 25 then
        return false
    end

    -- Check if the player is too far away from potentially placing a fortification
    if self:GetPos():DistToSqr(self:GetEyeTrace().HitPos) > (250 ^ 2) then
        return false
    end

    return true
 end

--[[
 -
 - Player:CanSelectPreviousAlydusFortification
 -
 - Determines if the player can select the previous fortification
 -
 --]]
 function ply:CanSelectPreviousAlydusFortification()
    -- Check if player is valid, a player and alive
    if !IsValid(self) or !self:IsPlayer() or !self:Alive() then
        return false
    end

    -- Check if player is crouching or moving
    if self:Crouching() or self:GetVelocity():Length() > 25 then
        return false
    end

    -- Check if the player is too far away from potentially placing a fortification
    if self:GetPos():DistToSqr(self:GetEyeTrace().HitPos) > (250 ^ 2) then
        return false
    end

    return true
 end
--PATH lua/autorun/client/cl_permaload.lua:
return gluapack()()
--PATH lua/autorun/client/tfa_shared_convars.lua:
return gluapack()()
--PATH lua/vgui/bvgui/categories.lua:
--/// bVGUI.Categories ///--

local PANEL = {}

function PANEL:Init()
	self.Categories = {}
	self.Items = {}

	self:Dock(LEFT)

	self.CategoriesContainer = vgui.Create("bVGUI.ScrollPanel", self)
	self.CategoriesContainer:Dock(FILL)

	self.DrawBackground = true
end

function PANEL:SetDrawBackground(draw_background)
	self.DrawBackground = draw_background
end

function PANEL:Paint(w,h)
	if (self.DrawBackground) then
		surface.SetDrawColor(bVGUI.COLOR_SLATE)
		surface.DrawRect(0,0,w,h)
	end

	self:LoadingPaint(w,h)
end

function PANEL:AddCategory(category_name, category_col)
	local this = self

	local category = vgui.Create("bVGUI.CategoriesCategory", self.CategoriesContainer)
	self.Categories[category_name] = category
	category:SetColor(category_col)
	category:SetText(category_name)
	category.ExistingItems = {}

	function category:AddItem(item_name, func, col, icon)
		if (category.ExistingItems[item_name]) then return end
		category.ExistingItems[item_name] = true
		local item = vgui.Create("bVGUI.CategoriesItem", self.ItemsContainer)
		table.insert(this.Items, item)
		item.ItemFunction = func
		item.Category = category
		item:SetText(item_name)
		if (col) then
			item:SetColor(col)
		else
			item:SetColor(category_col)
		end
		if (icon) then
			item:SetIcon(icon)
		end
		self.ItemsContainer:SizeToChildren(false, true)
		self.ItemsContainer:InvalidateParent(true)

		return item
	end

	function category:AddPlayer(ply, func, col, icon)
		local item = category:AddItem(ply:SteamID(), func, col, icon)
		if (not item) then return end
		item:SetAccountID(ply:AccountID())
	end

	function category:AddSteamID(steamid, func, col, icon)
		local item = category:AddItem(steamid, func, col, icon)
		if (not item) then return end
		print("deprecated AddSteamID", steamid)
		debug.Trace()
		item:SetAccountID(GAS:SteamIDToAccountID(steamid))
	end

	function category:AddAccountID(account_id, func, col, icon)
		local item = category:AddItem(GAS:AccountIDToSteamID(account_id), func, col, icon)
		if (not item) then return end
		item:SetAccountID(account_id)
	end

	function category:Clear()
		self.ExistingItems = {}
		local new_items = {}
		for i,v in pairs(this.Items) do
			if (v.Category == self) then
				v:Remove()
			else
				table.insert(new_items, v)
			end
		end
		this.Items = new_items
	end

	return category
end

function PANEL:RemoveItem(item)
	local item_category = item.Category

	item_category.ExistingItems[item.ItemName] = nil
	for i,v in ipairs(self.Items) do
		if (v == item) then
			table.remove(self.Items, i)
			break
		end
	end
	item:Remove()

	timer.Simple(0, function()
		if (item_category.Collapsed) then
			item_category.ItemsContainer:Stop()
			local y = 0
			for _,v in ipairs(item_category.ItemsContainer:GetChildren()) do
				y = y + v:GetTall()
			end
			item_category.ItemsContainer:SizeTo(item_category.ItemsContainer:GetWide(), y, 0.5)
		end
	end)
end

function PANEL:Clear()
	for _,v in ipairs(self.Items) do
		v:Remove()
	end
	for _,v in pairs(self.Categories) do
		v:Remove()
	end
	self.Categories = {}
	self.Items = {}
	self.CategoriesContainer:SetTall(0)
	self:InvalidateLayout(true)
	self.CategoriesContainer:InvalidateLayout(true)
end

function PANEL:EnableSearchBar(search_phrase)
	self.SearchBarContainer = vgui.Create("bVGUI.BlankPanel", self)
	self.SearchBarContainer:Dock(BOTTOM)
	self.SearchBarContainer:DockPadding(5,5,5,5)
	self.SearchBarContainer:SetTall(32)
	function self.SearchBarContainer:Paint(w,h)
		surface.SetDrawColor(bVGUI.COLOR_SLATE)
		surface.DrawRect(0,0,w,h)
	end

	self.SearchBarContainer.SearchBar = vgui.Create("bVGUI.TextEntry", self.SearchBarContainer)
	self.SearchBarContainer.SearchBar:Dock(FILL)
	self.SearchBarContainer.SearchBar:SetPlaceholderText(search_phrase or "Search...")
	function self.SearchBarContainer.SearchBar:OnChange()
		local search_text = self:GetText():lower()
		if (#search_text == 0) then
			for _,v in ipairs(self:GetParent():GetParent().Items) do
				v:SetVisible(true)
			end
		else
			for _,v in ipairs(self:GetParent():GetParent().Items) do
				if (v:GetText():lower():find(search_text,1,true)) then
					v:SetVisible(true)
				else
					v:SetVisible(false)
				end
			end
		end
		for _,v in pairs(self:GetParent():GetParent().Categories) do
			v.ItemsContainer:InvalidateLayout(true)
			v.ItemsContainer:SizeToChildren(false, true)
			v.ItemsContainer:InvalidateParent(true)
		end
	end
end

function PANEL:AddItem(item_name, func, col, icon)
	local item = vgui.Create("bVGUI.CategoriesItem", self)
	table.insert(self.Items, item)
	item.ItemFunction = func
	item.Category = category
	item:SetText(item_name)
	if (col) then
		item:SetColor(col)
	else
		item:SetColor(category_col)
	end
	if (icon) then
		item:SetIcon(icon)
	end

	return item
end

function PANEL:ClearActive()
	for _,v in ipairs(self.Items) do
		v:SetActive(false)
	end
end

derma.DefineControl("bVGUI.Categories", nil, PANEL, "bVGUI.LoadingPanel")

--/// bVGUI.CategoriesCategory ///--

local PANEL = {}

function PANEL:Init()
	self:SetTall(35)
	self:Dock(TOP)

	self.Collapsed = true
	self:SetCursor("up")

	self.CategoryColor = Color(0,0,0)
	self.CategoryName = ""

	self.CategoryNameLabel = vgui.Create("DLabel", self)
	self.CategoryNameLabel:SetFont(bVGUI.FONT(bVGUI.FONT_CIRCULAR, "REGULAR", 16))
	self.CategoryNameLabel:SetText("")

	self.ItemsContainer = vgui.Create("DPanel", self:GetParent())
	self.ItemsContainer:SetTall(0)
	self.ItemsContainer:Dock(TOP)
	self.ItemsContainer.Category = self
	function self.ItemsContainer:Paint(w,h)
		surface.SetDrawColor(255,255,255,200)
		surface.SetMaterial(bVGUI.MATERIAL_GRADIENT_LIGHT_LARGE)
		surface.DrawTexturedRect(0,0,w,h)
	end
end

function PANEL:Paint(w,h)
	surface.SetDrawColor(self.CategoryColor)
	surface.DrawRect(0,0,w,h)

	surface.SetMaterial(bVGUI.MATERIAL_GRADIENT_LIGHT)
	surface.DrawTexturedRect(0,0,w,h)
end

function PANEL:SetColor(col)
	self.CategoryColor = col
	
	if (bVGUI.ColorShouldUseBlackText(col)) then
		self.CategoryNameLabel:SetTextColor(bVGUI.COLOR_BLACK)
	else
		self.CategoryNameLabel:SetTextColor(bVGUI.COLOR_WHITE)
	end
end
function PANEL:SetText(text)
	self.CategoryName = text
	self.CategoryNameLabel:SetText(self.CategoryName)
	self.CategoryNameLabel:SizeToContentsY()
	self.CategoryNameLabel:SetWide(self:GetParent():GetWide() - 5 - 10 - 10)
	self.CategoryNameLabel:CenterVertical()
	self.CategoryNameLabel:AlignLeft(5 + 10)
end
function PANEL:GetText()
	return self.CategoryName
end

function PANEL:OnMouseReleased(m)
	if (m ~= MOUSE_LEFT) then return end
	if (self.Collapsed) then
		self.Collapsed = not self.Collapsed
		self:SetCursor("hand")
		self.ItemsContainer:Stop()
		self.ItemsContainer:SizeTo(self.ItemsContainer:GetWide(), 0, 0.5)
	else
		self.Collapsed = not self.Collapsed
		self:SetCursor("up")
		self.ItemsContainer:Stop()
		local y = 0
		for _,v in ipairs(self.ItemsContainer:GetChildren()) do
			y = y + v:GetTall()
		end
		self.ItemsContainer:SizeTo(self.ItemsContainer:GetWide(), y, 0.5)
	end
end

function PANEL:PerformLayout()
	self.CategoryNameLabel:SizeToContentsY()
	self.CategoryNameLabel:SetWide(self:GetParent():GetWide() - 5 - 10 - 10)
	self.CategoryNameLabel:CenterVertical()
	self.CategoryNameLabel:AlignLeft(5 + 10)
end

derma.DefineControl("bVGUI.CategoriesCategory", nil, PANEL, "DPanel")

--/// bVGUI.CategoriesItem ///--

local PANEL = {}

function PANEL:Init()
	self:SetCursor("hand")
	self:SetTall(35)
	self:Dock(TOP)
	self:InvalidateParent(true)

	self.ItemName = ""
	self.ItemColor = bVGUI.COLOR_BLACK
	self.ItemColorDark = bVGUI.COLOR_BLACK

	self.ItemNameLabel = vgui.Create("DLabel", self)
	self.ItemNameLabel:SetFont(bVGUI.FONT(bVGUI.FONT_CIRCULAR, "REGULAR", 16))
	self.ItemNameLabel:SetText("")
	self.ItemNameLabel:SetTextColor(bVGUI.COLOR_WHITE)

	self.CurrentBarX = 0
	self.Ceil = false
	self.AnimTime = CurTime()
end

function PANEL:SetIcon(path)
	self.Icon = vgui.Create("DImage", self)
	self.Icon:SetImage(path)
	self.Icon:SetSize(16, 16)
	self.Icon:AlignLeft(5 + 10)
	self.Icon:CenterVertical()

	self.ItemNameLabel:AlignLeft(5 + 10 + 16 + 5)
end

function PANEL:Paint(w,h)
	if (self:IsActive()) then
		self.CurrentBarX = Lerp(FrameTime() * 10, self.CurrentBarX, w)
	else
		self.CurrentBarX = Lerp(FrameTime() * 10, self.CurrentBarX, 5)
	end

	surface.SetDrawColor(self.ItemColor)
	surface.DrawRect(0, 0, 5, h)
	if (self.Ceil) then
		surface.SetDrawColor(self.ItemColorDark)
		surface.DrawRect(5, 0, math.ceil(self.CurrentBarX) - 5, h)
	else
		surface.SetDrawColor(self.ItemColorDark)
		surface.DrawRect(5, 0, math.floor(self.CurrentBarX) - 5, h)
	end
end

function PANEL:SetColor(col)
	self.ItemColor = col
	self.ItemColorDark = bVGUI.DarkenColor(self.ItemColor, 0.35)
end
function PANEL:SetText(text)
	self.ItemName = text
	self.ItemNameLabel:SetText(self.ItemName)
	self.ItemNameLabel:SizeToContentsY()
	self.ItemNameLabel:SetWide(self:GetParent():GetWide() - 5 - 10 - 10)
	self.ItemNameLabel:CenterVertical()
	self.ItemNameLabel:AlignLeft(5 + 10)
end
function PANEL:GetText()
	return self.ItemName
end

function PANEL:GetCategories()
	if (self:GetParent().Items) then
		return self:GetParent()
	elseif (self:GetParent():GetParent():GetParent():GetParent().Items) then
		return self:GetParent():GetParent():GetParent():GetParent()
	end
end

function PANEL:UpdateActiveState(active, forced_active)
	for _,v in pairs(self:GetCategories().Items) do
		v.Active = false
		v.AnimTime = CurTime()
		v.Ceil = false
	end
	self.AnimTime = CurTime()
	self.Active = active or false
	self.ForcedActive = forced_active or false
	self.Ceil = active or forced_active or false
end

function PANEL:IsActive()
	return self.Active or self.ForcedActive or false
end

function PANEL:SetForcedActive(forced_active)
	self:UpdateActiveState(self.Active, forced_active)
end

function PANEL:SetActive(active)
	self:UpdateActiveState(active, self.ForcedActive)
end

function PANEL:OnMouseReleased(m)
	if (m == MOUSE_LEFT) then
		self:SetActive(true)
		if (self.ItemFunction) then
			if (self.AccountID) then
				self.ItemFunction(self.AccountID)
			else
				self.ItemFunction()
			end
		end
	elseif (m == MOUSE_RIGHT and self.AccountID) then
		bVGUI.PlayerTooltip.Focus()
	end
end

function PANEL:PerformLayout()
	self.ItemNameLabel:SizeToContentsY()
	self.ItemNameLabel:CenterVertical()

	local item_name_label_left = 5 + 10
	local item_name_label_wide = self:GetParent():GetWide() - 5 - 10 - 10
	if (IsValid(self.AvatarImage)) then
		self.AvatarImage:AlignLeft(5)
		self.AvatarImage:CenterVertical()
		item_name_label_left = item_name_label_left + 35
		item_name_label_wide = item_name_label_wide - 35
	end
	if (IsValid(self.Icon)) then
		item_name_label_left = item_name_label_left + 16 + 10
		item_name_label_wide = item_name_label_wide - (16 + 10)
	end
	self.ItemNameLabel:AlignLeft(item_name_label_left)
	self.ItemNameLabel:SetWide(item_name_label_wide)
end

function PANEL:SetAccountID(account_id)
	self.AccountID = account_id
	self.AvatarImage = vgui.Create("AvatarImage", self)
	self.AvatarImage:SetSize(35,35)
	self.AvatarImage:SetSteamID(GAS:AccountIDToSteamID64(account_id), 32)
	self.AvatarImage:SetMouseInputEnabled(false)
	local this = self
	GAS.OfflinePlayerData:AccountID(account_id, function(success, data)
		if (not success) then
			this:SetText(GAS:AccountIDToSteamID(account_id))
		else
			this:SetText(data.nick)
		end
	end)
end

function PANEL:SetSteamID64(steamid64)
	print("SetSteamID64 deprecated", steamid64)
	return self:SetAccountID(GAS:SteamID64ToAccountID(steamid64))
end

function PANEL:OnCursorEntered()
	if (self.AccountID) then
		bVGUI.PlayerTooltip.Create({
			account_id = self.AccountID,
			focustip = bVGUI.L("right_click_to_focus"),
			copiedphrase = bVGUI.L("copied"),
			creator = self
		})
	end
end
function PANEL:OnCursorExited()
	if (self.AccountID) then
		bVGUI.PlayerTooltip.Close()
	end
end

derma.DefineControl("bVGUI.CategoriesItem", nil, PANEL, "DPanel")
--PATH lua/vgui/bvgui/form.lua:
return gluapack()()
--PATH lua/vgui/bvgui/option_selector.lua:
local PANEL = {}

function PANEL:Init()
	self.Color = bVGUI.BUTTON_COLOR_BLUE
	self.DarkColor = bVGUI.DarkenColor(self.Color, 0.5)

	self.SelectedX = bVGUI.Lerp(0,0,.5)
	self.SelectedWidth = bVGUI.Lerp(0,0,.5)

	self.ButtonLabels = {}
	self.TotalWidth = 0
	self.ButtonCount = 0
	self.Selected = 1

	self.ClickableArea = vgui.Create("bVGUI.BlankPanel", self)
	self.ClickableArea:SetMouseInputEnabled(true)
	self.ClickableArea:SetCursor("hand")
	function self.ClickableArea:OnMouseReleased(m)
		self:GetParent():OnMouseReleased(m)
	end
end

function PANEL:SetColor(col)
	self.Color = col
	self.DarkColor = bVGUI.DarkenColor(self.Color, 0.5)
end

local grey_col = Color(150,150,150)
local dark_grey_col = bVGUI.DarkenColor(grey_col, 0.5)
function PANEL:Paint(w,h)
	if (IsValid(self.HelpLabel)) then
		h = 26
	end

	self.SelectedX:DoLerp()
	self.SelectedWidth:DoLerp()

	draw.RoundedBoxEx(4,0,0,self.TotalWidth,h - 4,grey_col,true,true)
	draw.RoundedBoxEx(4,0,h - 4,self.TotalWidth,4,grey_col,false,false,true,true)

	if (self.LerpedColor == nil) then
		self.LerpedColor = Color(self.Color.r, self.Color.g, self.Color.b)
	else
		self.LerpedColor.r = Lerp(FrameTime() * 10, self.LerpedColor.r, self.Color.r)
		self.LerpedColor.g = Lerp(FrameTime() * 10, self.LerpedColor.g, self.Color.g)
		self.LerpedColor.b = Lerp(FrameTime() * 10, self.LerpedColor.b, self.Color.b)
	end

	if (self.LerpDarkColor == nil) then
		self.LerpDarkColor = Color(self.DarkColor.r, self.DarkColor.g, self.DarkColor.b)
	else
		self.LerpDarkColor.r = Lerp(FrameTime() * 10, self.LerpDarkColor.r, self.DarkColor.r)
		self.LerpDarkColor.g = Lerp(FrameTime() * 10, self.LerpDarkColor.g, self.DarkColor.g)
		self.LerpDarkColor.b = Lerp(FrameTime() * 10, self.LerpDarkColor.b, self.DarkColor.b)
	end

	draw.RoundedBoxEx(4, self.SelectedX:GetValue(), 0, self.SelectedWidth:GetValue(), h, self.LerpedColor, self.Selected == 1, self.Selected == self.ButtonCount, false, false)

	surface.SetDrawColor(dark_grey_col)
	surface.DrawRect(0,h - 4,self.TotalWidth,4)

	surface.SetDrawColor(self.LerpDarkColor)
	surface.DrawRect(self.SelectedX:GetValue(), h - 4, self.SelectedWidth:GetValue(), 4)
end

function PANEL:AddButton(text, col)
	self.ButtonCount = self.ButtonCount + 1
	local btn = vgui.Create("DLabel", self)
	btn.BtnIndex = table.insert(self.ButtonLabels, btn)
	btn.BtnColor = col
	btn:SetTextColor(bVGUI.COLOR_WHITE)
	btn:SetFont(bVGUI.FONT(bVGUI.FONT_RUBIK, "REGULAR", 14))
	btn:SetContentAlignment(5)
	btn:SetText(text)
	self:InvalidateLayout(true)
end

function PANEL:PerformLayout(w,h)
	local x = 5
	for i,v in ipairs(self.ButtonLabels) do
		if (i == self.Selected) then
			self.SelectedX:SetTo((v:GetPos()) - 5)
			self.SelectedWidth:SetTo(v:GetWide() + 10)
		end
		v:SizeToContentsX()
		if (IsValid(self.HelpLabel)) then
			v:SetTall(26 - 4)
		else
			v:SetTall(h - 4)
		end
		v:AlignLeft(x)
		x = x + v:GetWide() + 10
	end
	self.TotalWidth = x - 5
	if (IsValid(self.Label)) then
		self.Label:AlignLeft(self.TotalWidth + 10)
	end
	if (IsValid(self.HelpLabel)) then
		local h = self.HelpLabel:GetTall() + 30
		if (self:GetTall() ~= h) then
			self:SetTall(h)
		end
	end
	self.ClickableArea:SetSize(self.TotalWidth, 26)
end

function PANEL:SetSelectedButton(index)
	self.Selected = index
	self:InvalidateLayout(true)
end
function PANEL:GetSelectedButton()
	return self.ButtonLabels[self.Selected]:GetText(), self.ButtonLabels[self.Selected]
end

function PANEL:OnMouseReleased(m)
	if (m == MOUSE_LEFT) then
		local x,y = self:ScreenToLocal(gui.MousePos())
		for i,v in ipairs(self.ButtonLabels) do
			local btn_x, btn_y, btn_w = v:GetBounds()
			if (y <= 25 and x >= btn_x - 5 and x <= btn_x + btn_w + 5) then
				self:SetSelectedButton(i)
				if (v.BtnColor ~= nil) then
					self:SetColor(v.BtnColor)
				end
				if (self.OnChange) then
					self:OnChange()
				end
				break
			end
		end
	end
end

function PANEL:SetText(text)
	self.Label = vgui.Create("DLabel", self)
	self.Label:SetContentAlignment(4)
	self.Label:SetFont(bVGUI.FONT(bVGUI.FONT_CIRCULAR, "REGULAR", 16))
	self.Label:SetTextColor(bVGUI.COLOR_WHITE)
	self.Label:SetText(text)
	self.Label:SizeToContentsX()
	self.Label:SetTall(21)
end

function PANEL:SetHelpText(text)
	self.HelpLabel = vgui.Create("DLabel", self)
	self.HelpLabel:SetContentAlignment(4)
	self.HelpLabel:SetFont(bVGUI.FONT(bVGUI.FONT_CIRCULAR, "REGULAR", 16))
	self.HelpLabel:SetTextColor(bVGUI.COLOR_WHITE)
	self.HelpLabel:SetText(text)
	self.HelpLabel:SetWide(500)
	self.HelpLabel:SetWrap(true)
	self.HelpLabel:SetAutoStretchVertical(true)
	self.HelpLabel:AlignTop(30)
	self.HelpLabel:SetTextColor(Color(200,200,200))
	function self.HelpLabel:PerformLayout()
		self:InvalidateParent(true)
	end
end

function PANEL:GetValue()
	return self.ButtonLabels[self.Selected]:GetText()
end
function PANEL:SetValue(val)
	for i,v in ipairs(self.ButtonLabels) do
		if (v:GetText() == val) then
			self:SetSelectedButton(i)
			self.SelectedX:SetValue(self.SelectedX.to)
			self.SelectedWidth:SetValue(self.SelectedWidth.to)
			break
		end
	end
end

function PANEL:SizeToButtons()
	local w = 0
	for i,v in ipairs(self.ButtonLabels) do
		w = w + v:GetWide() + 10
	end
	self:SetWide(w)
end

derma.DefineControl("bVGUI.OptionSelector", nil, PANEL, "bVGUI.BlankPanel")
--PATH lua/vgui/bvgui/switch.lua:
local PANEL = {}

local on_color  = Color(76,218,100)
local off_color = Color(216,75,75)
local switch_width = 40
local switch_height = 20
local label_margin = 7

local function Circle( x, y, radius, seg )
	local cir = {}

	table.insert( cir, { x = x, y = y, u = 0.5, v = 0.5 } )
	for i = 0, seg do
		local a = math.rad( ( i / seg ) * -360 )
		table.insert( cir, { x = x + math.sin( a ) * radius, y = y + math.cos( a ) * radius, u = math.sin( a ) / 2 + 0.5, v = math.cos( a ) / 2 + 0.5 } )
	end

	local a = math.rad( 0 )
	table.insert( cir, { x = x + math.sin( a ) * radius, y = y + math.cos( a ) * radius, u = math.sin( a ) / 2 + 0.5, v = math.cos( a ) / 2 + 0.5 } )

	return cir 
end

function PANEL:Init()
	self.LeftCircle = false
	self.RightCircle = false

	self.Active = false
	self.ColorInterpolation = bVGUI.LerpColor(off_color, off_color, .25)
	self.SwitchInterpolation = bVGUI.Lerp(switch_height / 2, switch_height / 2, .25)

	self.Label = vgui.Create("DLabel", self)
	self.Label:SetContentAlignment(4)
	self.Label:SetFont(bVGUI.FONT(bVGUI.FONT_CIRCULAR, "REGULAR", 16))
	self.Label:SetTextColor(bVGUI.COLOR_WHITE)
	self:SetText("Switch")

	self.ClickableArea = vgui.Create("bVGUI.BlankPanel", self)
	self.ClickableArea:SetMouseInputEnabled(true)
	self.ClickableArea:SetCursor("hand")
	function self.ClickableArea:OnMouseReleased(m)
		if (m ~= MOUSE_LEFT) then return end
		local checked = not self:GetParent().Active
		self:GetParent():SetChecked(checked, true)
		if (GAS) then
			if (checked) then
				GAS:PlaySound("btn_on")
			else
				GAS:PlaySound("btn_off")
			end
		end
		if (self:GetParent().OnChange) then
			self:GetParent():OnChange()
		end
	end
end

function PANEL:PerformLayout()
	self.ClickableArea:SetSize(switch_width + label_margin + self.Label:GetWide() + label_margin, switch_height)
end

function PANEL:SetText(text)
	self.Text = text

	self.Label:SetText(text)
	self.Label:SizeToContents()
	self.Label:AlignLeft(switch_width + label_margin)
	self.Label:SizeToContents()

	self:SetSize(switch_width + label_margin + self.Label:GetWide(), switch_height)

	self.Label:CenterVertical()
end
function PANEL:GetText(text)
	return self.Text
end

function PANEL:Paint(w)
	if !self.LeftCircle or !self.RightCircle then
		self.LeftCircle = Circle(switch_height / 2, switch_height / 2, switch_height / 2,20)
		self.RightCircle = Circle(switch_width - switch_height / 2, switch_height / 2, switch_height / 2,20)
	end

	self.ColorInterpolation:DoLerp()
	self.SwitchInterpolation:DoLerp()

	surface.SetDrawColor(self.ColorInterpolation:GetColor())
	draw.NoTexture()
	surface.DrawPoly(self.LeftCircle)
	surface.DrawPoly(self.RightCircle)
	
	surface.DrawRect(switch_height / 2, 0, switch_width - switch_height, switch_height)

	surface.SetDrawColor(255, 255, 255)
	surface.DrawPoly(Circle(self.SwitchInterpolation:GetValue(), switch_height / 2, switch_height / 2 - 2,20))
end

function PANEL:SetChecked(active, animate)
	if (self.Disabled) then return end
	self.Active = active
	local from
	local to
	if (active) then
		from = switch_height / 2
		to = switch_width - (switch_height / 2)
	else
		from = switch_width - (switch_height / 2)
		to = switch_height / 2
	end
	if (animate) then
		self.SwitchInterpolation:SetTo(to)
		self.ColorInterpolation:SetTo(active and on_color or off_color)
	else
		self.SwitchInterpolation = bVGUI.Lerp(to, to, .25)
		if (active) then
			self.ColorInterpolation = bVGUI.LerpColor(on_color, on_color, .25)
		else
			self.ColorInterpolation = bVGUI.LerpColor(off_color, off_color, .25)
		end
	end
end
function PANEL:GetChecked()
	return self.Active
end

function PANEL:SetHelpText(text)
	self.HelpLabel = vgui.Create("DLabel", self)
	self.HelpLabel:SetTextColor(Color(200,200,200))
	self.HelpLabel:SetAutoStretchVertical(true)
	self.HelpLabel:SetWrap(true)
	self.HelpLabel:SetFont(bVGUI.FONT(bVGUI.FONT_RUBIK, "REGULAR", 16))
	self.HelpLabel:AlignTop(switch_height + 10)
	self.HelpLabel:SetText(text)
	function self.HelpLabel:PerformLayout()
		local w = math.min(500, self:GetParent():GetWide())
		if (self:GetWide() ~= w) then
			self:SetWide(w)
		end
		self:GetParent():SetSize(switch_width + label_margin + self:GetParent().Label:GetWide(), switch_height + 10 + self:GetTall())
	end
end

function PANEL:SetDisabled(disabled)
	self.Disabled = disabled
	if (self.Disabled) then
		self.ColorInterpolation:SetColor(Color(165,165,165))
		self.Label:SetTextColor(Color(180,180,180))
		self.ClickableArea:SetCursor("no")
	else
		self.ClickableArea:SetCursor("hand")
		self.Label:SetTextColor(bVGUI.COLOR_WHITE)
		if (self:GetChecked()) then
			self.ColorInterpolation:SetColor(on_color)
		else
			self.ColorInterpolation:SetColor(off_color)
		end
	end
end
function PANEL:GetDisabled()
	return self.Disabled
end

derma.DefineControl("bVGUI.Switch", nil, PANEL, "bVGUI.BlankPanel")
--PATH lua/vgui/bvgui/textentry.lua:
local PANEL = {}

function PANEL:Init()
	self:SetFont(bVGUI.FONT(bVGUI.FONT_CIRCULAR, "REGULAR", 14))
	self:ApplySchemeSettings()
	self:SetTextColor(bVGUI.COLOR_BLACK)
end

local focused_col = Color(0,120,255,255)
function PANEL:Paint(w,h)
	surface.SetDrawColor(255,255,255,255)
	surface.DrawRect(0,0,w,h)
	
	if (self._Valid) then
		surface.SetDrawColor(0,255,0,100)
		surface.DrawRect(0,0,w,h)
	elseif (self._Invalid) then
		surface.SetDrawColor(255,0,0,100)
		surface.DrawRect(0,0,w,h)
	end

	if (self:HasFocus()) then
		surface.SetDrawColor(0,120,255,255)
		surface.DrawOutlinedRect(0,0,w,h)
	end
	if (self:GetPlaceholderText() and #string.Trim(self:GetText()) == 0) then
		local oldtext = self:GetText()
		self:SetText(self:GetPlaceholderText())
		self:DrawTextEntryText(self:GetPlaceholderColor(), self:GetHighlightColor(), self:GetCursorColor())
		self:SetText(oldtext)
	else
		self:DrawTextEntryText(self:GetTextColor(), self:GetHighlightColor(), self:GetCursorColor())
	end
end

function PANEL:OnGetFocus()
	self.StoredValue = self:GetValue()
end

function PANEL:OnLoseFocus()
	if (self.OnValueChange and self:GetValue() ~= self.StoredValue) then
		self:OnValueChange(self:GetValue())
	end
end

function PANEL:SetInvalid(invalid)
	self._Invalid = invalid
	self._Valid = nil
end

function PANEL:SetValid(valid)
	self._Valid = valid
	self._Invalid = nil
end

function PANEL:ResetValidity()
	self._Valid, self._Invalid = nil
end

derma.DefineControl("bVGUI.TextEntry", nil, PANEL, "DTextEntry")

local PANEL = {}

function PANEL:Init()
	self.TextEntry = vgui.Create("bVGUI.TextEntry", self)
	self.TextEntry:SetWide(350)
end

function PANEL:SetLabel(text)
	self.Label = vgui.Create("DLabel", self)
	self.Label:SetContentAlignment(4)
	self.Label:SetFont(bVGUI.FONT(bVGUI.FONT_CIRCULAR, "REGULAR", 16))
	self.Label:SetTextColor(bVGUI.COLOR_WHITE)
	self.Label:SetText(text)
	self.Label:SizeToContents()

	self:PerformSizing()
end

function PANEL:SetHelpText(text)
	self.HelpLabel = vgui.Create("DLabel", self)
	self.HelpLabel:SetContentAlignment(4)
	self.HelpLabel:SetFont(bVGUI.FONT(bVGUI.FONT_RUBIK, "REGULAR", 16))
	self.HelpLabel:SetTextColor(bVGUI.COLOR_WHITE)
	self.HelpLabel:SetText(text)
	self.HelpLabel:SetWide(500)
	self.HelpLabel:SetWrap(true)
	self.HelpLabel:SetAutoStretchVertical(true)
	self.HelpLabel:SetTextColor(Color(200,200,200))
	function self.HelpLabel:PerformLayout()
		self:GetParent():PerformSizing()
		self:InvalidateParent(true)
	end
end

function PANEL:PerformSizing()
	local y = self.TextEntry:GetTall()
	if (IsValid(self.Label)) then
		y = y + self.Label:GetTall() + 10
	end
	if (IsValid(self.HelpLabel)) then
		y = y + self.HelpLabel:GetTall() + 10
	end
	self:SetTall(y)
end

function PANEL:PerformLayout()
	self.Label:AlignTop(0)
	self.HelpLabel:AlignBottom(0)
	self.TextEntry:AlignTop(self.Label:GetTall() + 10)
end

derma.DefineControl("bVGUI.TextEntryContainer", nil, PANEL, "bVGUI.BlankPanel")
--PATH addons/[gas] gmodadminsuite-logging-2.4.8/lua/vgui/gas_logging_advanced_search_item.lua:
local function L(phrase, ...)
	if (#({...}) == 0) then
		return GAS:Phrase(phrase, "logging")
	else
		return GAS:PhraseFormat(phrase, "logging", ...)
	end
end

local PANEL = {}

function PANEL:Init()
	self:SetMouseInputEnabled(true)
	self:SetCursor("hand")
	self:Dock(TOP)
	self:SetTall(32 + 3 + 3)
	self:DockPadding(3,3,3,3)
	self:DockMargin(0,0,0,5)

	self.Color = Color(255,255,255)

	self.Label = vgui.Create("DLabel", self)
	self.Label:SetFont(bVGUI.FONT(bVGUI.FONT_RUBIK, "REGULAR", 14))
	self.Label:Dock(FILL)
	self.Label:SetContentAlignment(5)
	self.Label:SetTextColor(bVGUI.COLOR_WHITE)
	self.Label:DockMargin(5,0,5,0)
end

function PANEL:SetAccountID(account_id)
	local steamid64 = GAS:AccountIDToSteamID64(account_id)

	self.AccountID = account_id

	self.AvatarImage = vgui.Create("AvatarImage", self)
	self.AvatarImage:SetMouseInputEnabled(false)
	self.AvatarImage:Dock(LEFT)
	self.AvatarImage:SetSize(32,32)
	self.AvatarImage:SetSteamID(steamid64, 32)
	self.Label:SetContentAlignment(4)

	self:UpdateTooltip()
end

function PANEL:SetColor(col)
	self.Color = col
end

function PANEL:SetTextColor(col)
	self.Label:SetTextColor(col)
	self:UpdateTooltip()
end

function PANEL:SetValue(val)
	self.Value = val
	self.Label:SetText(val)
	self:UpdateTooltip()
end

function PANEL:SetText(text)
	self.Label:SetText(text)
	self:UpdateTooltip()
end

function PANEL:GetValue()
	return self.Value
end

function PANEL:UpdateTooltip()
	if (self.AccountID ~= nil) then
		bVGUI.UnattachTooltip(self)
		bVGUI.PlayerTooltip.Attach(self, {
			account_id = self.AccountID,
			creator = self,
			focustip = L"right_click_to_focus",
		})
	else
		bVGUI.AttachTooltip(self, {
			Text = self.Label:GetText(),
			TextColor = self.Label:GetTextColor()
		})
	end
end

function PANEL:OnMouseReleased(m)
	if (m == MOUSE_LEFT) then
		GAS:PlaySound("delete")
		self:GetParent():RemoveItem(self)
	elseif (m == MOUSE_RIGHT and self.AccountID ~= nil) then
		bVGUI.PlayerTooltip.Focus()
	end
end

function PANEL:Paint(w,h)
	surface.SetDrawColor(bVGUI.COLOR_DARK_GREY)
	surface.DrawRect(0,0,w,h)

	surface.SetDrawColor(self.Color)
	for i=0,2 do
		surface.DrawOutlinedRect(i,i,w - (i * 2),h - (i * 2))
	end
end

derma.DefineControl("GAS.Logging.AdvancedSearchItem", nil, PANEL, "bVGUI.BlankPanel")
--PATH addons/[gas] gmodadminsuite-logging-2.4.8/lua/vgui/gas_logging_entity_display.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/gamemode/libraries/sh_cami.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/gamemode/libraries/fn.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/gamemode/modules/money/sh_interface.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/gamemode/modules/money/sh_interface.lua:
DarkRP.PLAYER.canAfford = DarkRP.stub{
    name = "canAfford",
    description = "Whether the player can afford the given amount of money",
    parameters = {
        {
            name = "amount",
            description = "The amount of money",
            type = "number",
            optional = false
        }
    },
    returns = {
        {
            name = "answer",
            description = "Whether the player can afford it",
            type = "boolean"
        }
    },
    metatable = DarkRP.PLAYER
}

DarkRP.ENTITY.isMoneyBag = DarkRP.stub{
    name = "isMoneyBag",
    description = "Whether this entity is a money bag",
    parameters = {

    },
    returns = {
        {
            name = "answer",
            description = "Whether this entity is a money bag.",
            type = "boolean"
        }
    },
    metatable = DarkRP.ENTITY
}

--PATH gamemodes/starwarsrp/gamemode/modules/jobs/sh_interface.lua:
DarkRP.hookStub{
    name = "OnPlayerChangedTeam",
    description = "When your team (job) is changed.",
    parameters = {
        {
            name = "ply",
            description = "The player that changed team. Clientside this hook is only called for the LocalPlayer.",
            type = "Player"
        },
        {
            name = "before",
            description = "The team before the change.",
            type = "number"
        },
        {
            name = "after",
            description = "The team after the change.",
            type = "number"
        }
    },
    returns = {

    }
}

--PATH gamemodes/starwarsrp/gamemode/modules/hitmenu/sh_interface.lua:
DarkRP.PLAYER.isHitman = DarkRP.stub{
    name = "isHitman",
    description = "Whether this player is a hitman.",
    parameters = {
    },
    returns = {
        {
            name = "answer",
            description = "Whether this player is a hitman.",
            type = "boolean"
        }
    },
    metatable = DarkRP.PLAYER
}

DarkRP.PLAYER.hasHit = DarkRP.stub{
    name = "hasHit",
    description = "Whether this hitman has a hit.",
    parameters = {
    },
    returns = {
        {
            name = "answer",
            description = "Whether this player has a hit.",
            type = "boolean"
        }
    },
    metatable = DarkRP.PLAYER
}

DarkRP.PLAYER.getHitTarget = DarkRP.stub{
    name = "getHitTarget",
    description = "Get the target of a hitman.",
    parameters = {
    },
    returns = {
        {
            name = "target",
            description = "The target of the hit.",
            type = "Player"
        }
    },
    metatable = DarkRP.PLAYER
}

DarkRP.PLAYER.getHitPrice = DarkRP.stub{
    name = "getHitPrice",
    description = "Get the price the hitman demands for his work.",
    parameters = {
    },
    returns = {
        {
            name = "price",
            description = "The price of the next hit.",
            type = "number"
        }
    },
    metatable = DarkRP.PLAYER
}

DarkRP.addHitmanTeam = DarkRP.stub{
    name = "addHitmanTeam",
    description = "Make this team a hitman.",
    parameters = {
        {
            name = "team number",
            description = "The number of the team (e.g. TEAM_MOB)",
            type = "number",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.getHitmanTeams = DarkRP.stub{
    name = "getHitmanTeams",
    description = "Get all the hitman teams.",
    parameters = {
    },
    returns = {
        {
            name = "tbl",
            description = "A table in which the keys are TEAM_ numbers and the values are just true.",
            type = "table"
        }
    },
    metatable = DarkRP
}

DarkRP.hookStub{
    name = "canRequestHit",
    description = "Whether someone can request a hit.",
    parameters = {
        {
            name = "hitman",
            description = "The hitman performing the hit",
            type = "Player"
        },
        {
            name = "customer",
            description = "The customer for the current hit.",
            type = "Player"
        },
        {
            name = "target",
            description = "The target of the current hit",
            type = "Player"
        },
        {
            name = "price",
            description = "The agreed upon price.",
            type = "number"
        }
    },
    returns = {
        {
            name = "canRequest",
            description = "A yes or no as to whether the hit can be requested.",
            type = "boolean"
        },
        {
            name = "message",
            description = "The message that is shown when they can't request the hit.",
            type = "string"
        },
        {
            name = "price",
            description = "An override for the price of the hit.",
            type = "number"
        }
    }
}

DarkRP.hookStub{
    name = "onHitAccepted",
    description = "When a hitman accepts a hit.",
    parameters = {
        {
            name = "hitman",
            description = "The hitman performing the hit.",
            type = "Player"
        },
        {
            name = "target",
            description = "The target of the current hit.",
            type = "Player"
        },
        {
            name = "customer",
            description = "The customer of the current hit.",
            type = "Player"
        }
    },
    returns = {

    }
}

DarkRP.hookStub{
    name = "onHitCompleted",
    description = "When a hitman finishes a hit.",
    parameters = {
        {
            name = "hitman",
            description = "The hitman performing the hit.",
            type = "Player"
        },
        {
            name = "target",
            description = "The target of the current hit.",
            type = "Player"
        },
        {
            name = "customer",
            description = "The customer of the current hit.",
            type = "Player"
        }
    },
    returns = {

    }
}

DarkRP.hookStub{
    name = "onHitFailed",
    description = "When a hit fails for some reason.",
    parameters = {
        {
            name = "hitman",
            description = "The hitman performing the hit.",
            type = "Player"
        },
        {
            name = "target",
            description = "The target of the current hit.",
            type = "Player"
        },
        {
            name = "reason",
            description = "why the hit failed.",
            type = "string"
        }
    },
    returns = {

    }
}

--PATH gamemodes/starwarsrp/gamemode/modules/f1menu/cl_interface.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/gamemode/modules/doorsystem/sh_interface.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/gamemode/modules/base/cl_interface.lua:
DarkRP.PLAYER.isInRoom = DarkRP.stub{
    name = "isInRoom",
    description = "Whether the player is in the same room as the LocalPlayer.",
    parameters = {},
    returns = {
        {
            name = "inRoom",
            description = "Whether the player is in the same room.",
            type = "boolean"
        }
    },
    metatable = DarkRP.PLAYER
}

DarkRP.deLocalise = DarkRP.stub{
    name = "deLocalise",
    description = "Makes sure the string will not be localised when drawn or printed.",
    parameters = {
        {
            name = "text",
            description = "The text to delocalise.",
            type = "string",
            optional = false
        }
    },
    returns = {
        {
            name = "text",
            description = "The delocalised text.",
            type = "string"
        }
    },
    metatable = DarkRP
}

DarkRP.textWrap = DarkRP.stub{
    name = "textWrap",
    description = "Wrap a text around when reaching a certain width.",
    parameters = {
        {
            name = "text",
            description = "The text to wrap.",
            type = "string",
            optional = false
        },
        {
            name = "font",
            description = "The font of the text.",
            type = "string",
            optional = false
        },
        {
            name = "width",
            description = "The maximum width in pixels.",
            type = "number",
            optional = false
        }
    },
    returns = {
        {
            name = "text",
            description = "The wrapped string.",
            type = "string"
        }
    },
    metatable = DarkRP
}

DarkRP.setPreferredJobModel = DarkRP.stub{
    name = "setPreferredJobModel",
    description = "Set the model preferred by the player (if the job allows multiple models).",
    parameters = {
        {
            name = "teamNr",
            description = "The team number of the job.",
            type = "number",
            optional = false
        },
        {
            name = "model",
            description = "The preferred model for the job.",
            type = "string",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.getPreferredJobModel = DarkRP.stub{
    name = "getPreferredJobModel",
    description = "Get the model preferred by the player (if the job allows multiple models).",
    parameters = {
        {
            name = "teamNr",
            description = "The team number of the job.",
            type = "number",
            optional = false
        }
    },
    returns = {
        {
            name = "model",
            description = "The preferred model for the job.",
            type = "string"
        }
    },
    metatable = DarkRP
}

DarkRP.hookStub{
    name = "teamChanged",
    description = "When your team is changed.",
    deprecated = "Use the OnPlayerChangedTeam hook instead.",
    parameters = {
        {
            name = "before",
            description = "The team before the change.",
            type = "number"
        },
        {
            name = "after",
            description = "The team after the change.",
            type = "number"
        }
    },
    returns = {

    }
}

--PATH gamemodes/starwarsrp/gamemode/libraries/disjointset.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/gamemode/modules/workarounds/sh_workarounds.lua:
-- Shared part

function DarkRP.getAvailableVehicles()
    local vehicles = list.Get("Vehicles")
    for _, v in pairs(list.Get("SCarsList")) do
        vehicles[v.PrintName] = {
            Name = v.PrintName,
            Class = v.ClassName,
            Model = v.CarModel
        }
    end

    return vehicles
end

local function argError(Val, iArg, sType)
    error(string.format("bad argument #%u to '%s' (%s expected, got %s)", iArg, debug.getinfo(2, "n").name, sType, type(Val)), 3)
end

if not DarkRP.disabledDefaults["workarounds"]["os.date() Windows crash"] and system.IsWindows() then
    local osdate = os.date
    local replace = function(txt)
        if txt == "%%" then return txt end -- Edge case, %% is allowed
        return ""
    end

    function os.date(format, time, ...)
        if (isstring(format) or isnumber(format)) then
            format = string.gsub(format, "%%[^aAbBcdHIjmMpSUwWxXyYz]", replace)
        elseif (format ~= nil) then
            argError(Val, 1, "string")
        end

        if (not (time == nil or isnumber(time)) and (not isstring(time) or tonumber(time) == nil)) then
            argError(Val, 2, "number")
        end

        return osdate(format, time, ...)
    end
end

timer.Simple(3, function()
    if DarkRP.disabledDefaults["workarounds"]["SkidCheck"] then return end

    -- Malicious addons that kicks players this one person doesn't like.
    if not istable(Skid) then return end
    Skid.Check = fn.Id
    hook.Remove("CheckPassword", "Skid.CheckPassword")

    MsgC(Color(0, 255, 0), "SkidCheck", color_white, " has been ", Color(255, 0, 0), "DISABLED\n", color_white, [[
    SkidCheck was detected on this server and has been disabled.

    SkidCheck is a ban list addon made by HeX as an attempt to get the people he doesn't like
    banned from as many servers as possible.

    You have probably installed this addon thinking that it would get rid of cheaters, and sure,
    it might get rid of some, but that's only to make you want to download this.

    SkidCheck would ban me (FPtje, developer of DarkRP) from your server because I have a
    workshop addon that he doesn't like and because I know how to throw a prop around
        (type /credits yourname in chat for the full story on that)
    It doesn't just ban /me/ for that, it bans EVERYONE who is subscribed to the addon.

    Can you imagine trying an addon out and getting on this list /just/ because you have
    it installed? That's SkidCheck for you.

    It also bans people who have a VAC ban (even if gotten from another game), people from
    arbitrary groups, /friends/ of people he doesn't like and many, many more.

    I'm not pulling this out of my ass either, you can check everything here:
    https://forum.facepunch.com//f/gmoddev/nujl/PSA-Hex-SkidCheck-global-banlist-is-a-thing-and-people-actually-use-it/1/

    On a somewhat unrelated note, HeX has been known to be malicious for quite some time:
    He used to have an anticheat (called HAC) on his server, which not only misfired from
    time to time, but actively used exploits to fuck "cheaters" up as much as possible,
    doing malicious shit ranging from unbinding keys to removing every friend they had in
    their friends list.

    That too can be fact checked right here:
    https://forum.facepunch.com//f/gmoddev/lrbf/So-hac-got-released/1/

    DO NOT trust this guy to decide who gets banned from your server. In fact,
    DO NOT EVER TRUST ANYONE with that power. No one ever should have the power
    to decide who gets banned and who doesn't over the servers that decide to install
    their addon.
]])
end)

if SERVER and not DarkRP.disabledDefaults["workarounds"]["Error on edict limit"] then
    -- https://github.com/FPtje/DarkRP/issues/2640
    local entsCreate = ents.Create
    local entsCreateError = [[
    Unable to create entity.

    The server has come to a point where it has become impossible to create new
    entities. The entity limit has been hit. Try cleaning up the server or
    changing level. In the meantime, expect lots of errors coming from a lot of
    addons.

    If you do decide to send a bug report to ANY addon, please include this
    message.]]

    local function varArgsLen(...)
        return {...}, select("#", ...)
    end

    function ents.Create(name, ...)
        local res, len = varArgsLen(entsCreate(name, ...))

        if res[1] == NULL and ents.GetEdictCount() >= 8176 then
            DarkRP.error(entsCreateError, 2, {string.format("Affected entity: '%s'", name)})
        end

        return unpack(res, 1, len)
    end
end

--[[---------------------------------------------------------------------------
Generic InitPostEntity workarounds
---------------------------------------------------------------------------]]
hook.Add("InitPostEntity", "DarkRP_Workarounds", function()
    if CLIENT then
        if not DarkRP.disabledDefaults["workarounds"]["White flashbang flashes"] then
            -- Removes the white flashes when the server lags and the server has flashbang. Workaround because it's been there for fucking years
            hook.Remove("HUDPaint","drawHudVital")
        end

        -- Fuck up APAnti
        if not DarkRP.disabledDefaults["workarounds"]["APAnti"] then
            net.Receivers.sblockgmspawn = nil
            hook.Remove("PlayerBindPress", "_sBlockGMSpawn")
        end
        return
    end
    local commands = concommand.GetTable()
    if not DarkRP.disabledDefaults["workarounds"]["Durgz witty sayings"] and commands["durgz_witty_sayings"] then
        game.ConsoleCommand("durgz_witty_sayings 0\n") -- Deals with the cigarettes exploit. I'm fucking tired of them. I hate having to fix other people's mods, but this mod maker is retarded and refuses to update his mod.
    end

    -- Remove ULX /me command. (the /me command is the only thing this hook does)
    if not DarkRP.disabledDefaults["workarounds"]["ULX /me command"] then
        hook.Remove("PlayerSay", "ULXMeCheck")
    end

    -- why can people even save multiplayer games?
    -- Lag exploit
    if not DarkRP.disabledDefaults["workarounds"]["gm_save"] then
        concommand.Remove("gm_save")
    end

    -- Remove that weird rooftop spawn in rp_downtown_v4c_v2
    if not DarkRP.disabledDefaults["workarounds"]["rp_downtown_v4c_v2 rooftop spawn"] and
    game.GetMap() == "rp_downtown_v4c_v2" then
        for _, v in ipairs(ents.FindByClass("info_player_terrorist")) do
            v:Remove()
        end
    end
end)

--[[---------------------------------------------------------------------------
Fuck up APAnti. These hooks send unnecessary net messages.
---------------------------------------------------------------------------]]
if not DarkRP.disabledDefaults["workarounds"]["APAnti"] then
    timer.Simple(3, function()
        hook.Remove("Move", "_APA.Settings.AllowGMSpawn")
        hook.Remove("PlayerSpawnObject", "_APA.Settings.AllowGMSpawn")
    end)
end

--[[---------------------------------------------------------------------------
Wire field generator exploit
---------------------------------------------------------------------------]]
if SERVER and not DarkRP.disabledDefaults["workarounds"]["Wire field generator exploit fix"] then
    hook.Add("OnEntityCreated", "DRP_WireFieldGenerator", function(ent)
        timer.Simple(0, function()
            if IsValid(ent) and ent:GetClass() == "gmod_wire_field_device" then
                local TriggerInput = ent.TriggerInput
                function ent:TriggerInput(iname, value)
                    if iname == "Distance" and isnumber(value) then
                        value = math.min(value, 400)
                    end
                    TriggerInput(self, iname, value)
                end
            end
        end)
    end)
end

--[[---------------------------------------------------------------------------
Door tool is shitty
Let's fix that huge class exploit
---------------------------------------------------------------------------]]
if not DarkRP.disabledDefaults["workarounds"]["Door tool class fix"] then
    hook.Add("InitPostEntity", "FixDoorTool", function()
        local oldFunc = makedoor
        if isfunction(oldFunc) then
            function makedoor(ply, trace, ang, model, open, close, autoclose, closetime, class, hardware, ...)
                if class ~= "prop_dynamic" and class ~= "prop_door_rotating" then return end

                oldFunc(ply, trace, ang, model, open, close, autoclose, closetime, class, hardware, ...)
            end
        end
    end)

    local allowedDoors = {
        ["prop_dynamic"] = true,
        ["prop_door_rotating"] = true,
        [""] = true
    }

    hook.Add("CanTool", "DoorExploit", function(ply, trace, tool)
        if not IsValid(ply) or not ply:IsPlayer() or not IsValid(ply:GetActiveWeapon()) or not ply:GetActiveWeapon().GetToolObject or not ply:GetActiveWeapon():GetToolObject() then return end

        tool = ply:GetActiveWeapon():GetToolObject()
        if not allowedDoors[string.lower(tool:GetClientInfo("door_class") or "")] then
            return false
        end
    end)
end
--[[---------------------------------------------------------------------------
Anti crash exploit
---------------------------------------------------------------------------]]
if SERVER and not DarkRP.disabledDefaults["workarounds"]["Constraint crash exploit fix"] then
    hook.Add("PropBreak", "drp_AntiExploit", function(attacker, ent)
        if IsValid(ent) and ent:GetPhysicsObject():IsValid() then
            constraint.RemoveAll(ent)
        end
    end)
end

--[[---------------------------------------------------------------------------
Actively deprecate commands
---------------------------------------------------------------------------]]
if SERVER and not DarkRP.disabledDefaults["workarounds"]["Deprecated console commands"] then
    local deprecated = {
        {command = "rp_removeletters",      alternative = "removeletters"},
        {command = "rp_setname",            alternative = "forcerpname"},
        {command = "rp_unlock",             alternative = "forceunlock"},
        {command = "rp_lock",               alternative = "forcelock"},
        {command = "rp_removeowner",        alternative = "forceremoveowner"},
        {command = "rp_addowner",           alternative = "forceown"},
        {command = "rp_unownall",           alternative = "forceunownall"},
        {command = "rp_unown",              alternative = "forceunown"},
        {command = "rp_own",                alternative = "forceown"},
        {command = "rp_tellall",            alternative = "admintellall"},
        {command = "rp_tell",               alternative = "admintell"},
        {command = "rp_teamunban",          alternative = "teamunban"},
        {command = "rp_teamban",            alternative = "teamban"},
        {command = "rp_setsalary",          alternative = "setmoney"},
        {command = "rp_setmoney",           alternative = "setmoney"},
        {command = "rp_revokelicense",      alternative = "unsetlicense"},
        {command = "rp_givelicense",        alternative = "setlicense"},
        {command = "rp_unlockdown",         alternative = "unlockdown"},
        {command = "rp_lockdown",           alternative = "lockdown"},
        {command = "rp_unarrest",           alternative = "unarrest"},
        {command = "rp_arrest",             alternative = "arrest"},
        {command = "rp_cancelvote",         alternative = "forcecancelvote"},
    }

    local lastDeprecated = 0
    local function msgDeprecated(cmd, ply)
        if CurTime() - lastDeprecated < 0.5 then return end
        lastDeprecated = CurTime()

        DarkRP.notify(ply, 1, 4, ("This command has been deprecated. Please use 'DarkRP %s' or '/%s' instead."):format(cmd.alternative, cmd.alternative))
    end

    for _, cmd in pairs(deprecated) do
        concommand.Add(cmd.command, fp{msgDeprecated, cmd})
    end
end


--[[-------------------------------------------------------------------------
CAC tends to kick innocent people when they use the x86_64 branch. Since the
author is unable to maintain it, it is better to disable the addon altogether.
---------------------------------------------------------------------------]]
local disableCacMsg = [[CAC was detected on this server and has been disabled.
It turns out there is a trivial and very well known way for cheats to bypass
CAC. Worse yet, CAC tends to kick innocent players who are using the 64 bits
branch of GMod.

The author of the addon does not maintain CAC anymore, so this is to prevent
further damage and to warn you of this situation.

If you wish to leave CAC enabled, please open

addons\darkrpmodification\lua\darkrp_config\disabled_defaults.lua

Head to the section about disabled workarounds and make sure the following line is there:
["disable CAC"]                                  = true,
]]
if SERVER and not DarkRP.disabledDefaults["workarounds"]["disable CAC"] then
    timer.Create("disable CAC", 2, 1, function()
        if not CAC then return end

        --remove CAC's hooks
        hook.Remove("CheckPassword"      , "CAC.CheckPassword")
        hook.Remove("Initialize"         , "CAC.LuaWhitelistController.261b4998")
        hook.Remove("OnNPCKilled"        , "CAC.Aimbotdetector")
        hook.Remove("PlayerDeath"        , "CAC.AimbotDetector")
        hook.Remove("PlayerInitialSpawn" , "CAC.PlayerMonitor.PlayerConnected")
        hook.Remove("PlayerSay"          , "CAC.ChatCommands")
        hook.Remove("SetupMove"          , "CAC.MoveHandler")
        hook.Remove("ShutDown"           , "CAC")
        hook.Remove("Think"              , "CAC.DelayedCalls")
        hook.Remove("Tick"               , "CAC.PlayerMonitor.ProcessQueue")
        hook.Remove("player_disconnect"  , "CAC.PlayerMonitor.PlayerDisconnected")

        --remove CAC's timers
        timer.Remove("CAC.AdminUIBootstrapper")
        timer.Remove("CAC.DataUpdater")
        timer.Remove("CAC.IncidentController")
        timer.Remove("CAC.LivePlayerSessionController")
        timer.Remove("CAC.SettingsSaver")

        --remove CAC's net receivers
        net.Receivers[CAC.Identifiers.MultiplexedDataChannelName] = nil
        net.Receivers[CAC.Identifiers.AdminChannelName] = nil

        for k,v in pairs(CAC) do
            if istable(CAC[k]) and CAC[k].dtor then CAC[k]:dtor() end
        end

        CAC = nil

        MsgC(Color(0, 255, 0), "Cake Anticheat (CAC)", color_white, " has been ", Color(255, 0, 0), "DISABLED\n", Color(253, 151, 31), disableCacMsg)
    end)
end

--PATH gamemodes/starwarsrp/gamemode/modules/voting/cl_voting.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/gamemode/modules/medic/sh_init.lua:
local plyMeta = FindMetaTable("Player")
plyMeta.isMedic = fn.Compose{fn.Curry(fn.GetValue, 2)("medic"), plyMeta.getJobTable}

--PATH gamemodes/starwarsrp/gamemode/modules/cppi/sh_cppi.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/gamemode/modules/base/sh_simplerr.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/gamemode/modules/base/sh_playerclass.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/gamemode/modules/base/cl_drawfunctions.lua:
-- concatenate a space to avoid the text being parsed as valve string
local function safeText(text)
    return string.match(text, "^#([a-zA-Z_]+)$") and text .. " " or text
end

DarkRP.deLocalise = safeText

function draw.DrawNonParsedText(text, font, x, y, color, xAlign)
    return draw.DrawText(safeText(text), font, x, y, color, xAlign)
end

function draw.DrawNonParsedSimpleText(text, font, x, y, color, xAlign, yAlign)
    return draw.SimpleText(safeText(text), font, x, y, color, xAlign, yAlign)
end

function draw.DrawNonParsedSimpleTextOutlined(text, font, x, y, color, xAlign, yAlign, outlineWidth, outlineColor)
    return draw.SimpleTextOutlined(safeText(text), font, x, y, color, xAlign, yAlign, outlineWidth, outlineColor)
end

function surface.DrawNonParsedText(text)
    return surface.DrawText(safeText(text))
end

function chat.AddNonParsedText(...)
    local tbl = {...}
    for i = 2, #tbl, 2 do
        tbl[i] = safeText(tbl[i])
    end
    return chat.AddText(unpack(tbl))
end

--PATH gamemodes/starwarsrp/gamemode/config/jobrelated.lua:
-- People often copy jobs. When they do, the GM table does not exist anymore.
-- This line makes the job code work both inside and outside of gamemode files.
-- You should not copy this line into your code.
local GAMEMODE = GAMEMODE or GM
--[[--------------------------------------------------------
Default teams. Please do not edit this file. Please use the darkrpmod addon instead.
--------------------------------------------------------]]
TEAM_CITIZEN = DarkRP.createJob("Citizen", {
    color = Color(20, 150, 20, 255),
    model = {
        "models/player/Group01/Female_01.mdl",
        "models/player/Group01/Female_02.mdl",
        "models/player/Group01/Female_03.mdl",
        "models/player/Group01/Female_04.mdl",
        "models/player/Group01/Female_06.mdl",
        "models/player/group01/male_01.mdl",
        "models/player/Group01/Male_02.mdl",
        "models/player/Group01/male_03.mdl",
        "models/player/Group01/Male_04.mdl",
        "models/player/Group01/Male_05.mdl",
        "models/player/Group01/Male_06.mdl",
        "models/player/Group01/Male_07.mdl",
        "models/player/Group01/Male_08.mdl",
        "models/player/Group01/Male_09.mdl"
    },
    description = [[The Citizen is the most basic level of society you can hold besides being a hobo. You have no specific role in city life.]],
    weapons = {},
    command = "citizen",
    max = 0,
    salary = GAMEMODE.Config.normalsalary,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "Citizens",
})

TEAM_POLICE = DarkRP.createJob("Civil Protection", {
    color = Color(25, 25, 170, 255),
    model = {"models/player/police.mdl", "models/player/police_fem.mdl"},
    description = [[The protector of every citizen that lives in the city.
        You have the power to arrest criminals and protect innocents.
        Hit a player with your arrest baton to put them in jail.
        Bash a player with a stunstick and they may learn to obey the law.
        The Battering Ram can break down the door of a criminal, with a warrant for their arrest.
        The Battering Ram can also unfreeze frozen props (if enabled).
        Type /wanted <name> to alert the public to the presence of a criminal.]],
    weapons = {"arrest_stick", "unarrest_stick", "weapon_glock2", "stunstick", "door_ram", "weaponchecker"},
    command = "cp",
    max = 4,
    salary = GAMEMODE.Config.normalsalary * 1.45,
    admin = 0,
    vote = true,
    hasLicense = true,
    ammo = {
        ["pistol"] = 60,
    },
    category = "Civil Protection",
})

TEAM_GANG = DarkRP.createJob("Gangster", {
    color = Color(75, 75, 75, 255),
    model = {
        "models/player/Group03/Female_01.mdl",
        "models/player/Group03/Female_02.mdl",
        "models/player/Group03/Female_03.mdl",
        "models/player/Group03/Female_04.mdl",
        "models/player/Group03/Female_06.mdl",
        "models/player/group03/male_01.mdl",
        "models/player/Group03/Male_02.mdl",
        "models/player/Group03/male_03.mdl",
        "models/player/Group03/Male_04.mdl",
        "models/player/Group03/Male_05.mdl",
        "models/player/Group03/Male_06.mdl",
        "models/player/Group03/Male_07.mdl",
        "models/player/Group03/Male_08.mdl",
        "models/player/Group03/Male_09.mdl"},
    description = [[The lowest person of crime.
        A gangster generally works for the Mobboss who runs the crime family.
        The Mob boss sets your agenda and you follow it or you might be punished.]],
    weapons = {},
    command = "gangster",
    max = 3,
    salary = GAMEMODE.Config.normalsalary,
    admin = 0,
    vote = false,
    hasLicense = false,
    category = "Gangsters",
})

TEAM_MOB = DarkRP.createJob("Mob boss", {
    color = Color(25, 25, 25, 255),
    model = "models/player/gman_high.mdl",
    description = [[The Mob boss is the boss of the criminals in the city.
        With their power they coordinate the gangsters and form an efficient crime organization.
        They have the ability to break into houses by using a lockpick.
        The Mob boss posesses the ability to unarrest you.]],
    weapons = {"lockpick", "unarrest_stick"},
    command = "mobboss",
    max = 1,
    salary = GAMEMODE.Config.normalsalary * 1.34,
    admin = 0,
    vote = false,
    hasLicense = false,
    category = "Gangsters",
})

TEAM_GUN = DarkRP.createJob("Gun Dealer", {
    color = Color(255, 140, 0, 255),
    model = "models/player/monk.mdl",
    description = [[A Gun Dealer is the only person who can sell guns to other people.
        Make sure you aren't caught selling illegal firearms to the public! You might get arrested!]],
    weapons = {},
    command = "gundealer",
    max = 2,
    salary = GAMEMODE.Config.normalsalary,
    admin = 0,
    vote = false,
    hasLicense = false,
    category = "Citizens",
})

TEAM_MEDIC = DarkRP.createJob("Medic", {
    color = Color(47, 79, 79, 255),
    model = "models/player/kleiner.mdl",
    description = [[With your medical knowledge you work to restore players to full health.
        Without a medic, people cannot be healed.
        Left click with the Medical Kit to heal other players.
        Right click with the Medical Kit to heal yourself.]],
    weapons = {"med_kit"},
    command = "medic",
    max = 3,
    salary = GAMEMODE.Config.normalsalary,
    admin = 0,
    vote = false,
    hasLicense = false,
    medic = true,
    category = "Citizens",
})

TEAM_CHIEF = DarkRP.createJob("Civil Protection Chief", {
    color = Color(20, 20, 255, 255),
    model = "models/player/combine_soldier_prisonguard.mdl",
    description = [[The Chief is the leader of the Civil Protection unit.
        Coordinate the police force to enforce law in the city.
        Hit a player with arrest baton to put them in jail.
        Bash a player with a stunstick and they may learn to obey the law.
        The Battering Ram can break down the door of a criminal, with a warrant for their arrest.
        Type /wanted <name> to alert the public to the presence of a criminal.
        Type /jailpos to set the Jail Position]],
    weapons = {"arrest_stick", "unarrest_stick", "weapon_deagle2", "stunstick", "door_ram", "weaponchecker"},
    command = "chief",
    max = 1,
    salary = GAMEMODE.Config.normalsalary * 1.67,
    admin = 0,
    vote = false,
    hasLicense = true,
    chief = true,
    NeedToChangeFrom = TEAM_POLICE,
    ammo = {
        ["pistol"] = 60,
    },
    category = "Civil Protection",
})

TEAM_MAYOR = DarkRP.createJob("Mayor", {
    color = Color(150, 20, 20, 255),
    model = "models/player/breen.mdl",
    description = [[The Mayor of the city creates laws to govern the city.
    If you are the mayor you may create and accept warrants.
    Type /wanted <name>  to warrant a player.
    Type /jailpos to set the Jail Position.
    Type /lockdown initiate a lockdown of the city.
    Everyone must be inside during a lockdown.
    The cops patrol the area.
    /unlockdown to end a lockdown]],
    weapons = {},
    command = "mayor",
    max = 1,
    salary = GAMEMODE.Config.normalsalary * 1.89,
    admin = 0,
    vote = true,
    hasLicense = false,
    mayor = true,
    category = "Civil Protection",
})

TEAM_HOBO = DarkRP.createJob("Hobo", {
    color = Color(80, 45, 0, 255),
    model = "models/player/corpse1.mdl",
    description = [[The lowest member of society. Everybody laughs at you.
        You have no home.
        Beg for your food and money
        Sing for everyone who passes to get money
        Make your own wooden home somewhere in a corner or outside someone else's door]],
    weapons = {"weapon_bugbait"},
    command = "hobo",
    max = 5,
    salary = 0,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    hobo = true,
    category = "Citizens",
})

if not DarkRP.disabledDefaults["modules"]["hungermod"] then
    TEAM_COOK = DarkRP.createJob("Cook", {
        color = Color(238, 99, 99, 255),
        model = "models/player/mossman.mdl",
        description = [[As a cook, it is your responsibility to feed the other members of your city.
            You can spawn a microwave and sell the food you make:
            /buymicrowave]],
        weapons = {},
        command = "cook",
        max = 2,
        salary = 45,
        admin = 0,
        vote = false,
        hasLicense = false,
        cook = true
    })
end

-- Compatibility for when default teams are disabled
TEAM_CITIZEN = TEAM_CITIZEN  or -1
TEAM_POLICE  = TEAM_POLICE   or -1
TEAM_GANG    = TEAM_GANG     or -1
TEAM_MOB     = TEAM_MOB      or -1
TEAM_GUN     = TEAM_GUN      or -1
TEAM_MEDIC   = TEAM_MEDIC    or -1
TEAM_CHIEF   = TEAM_CHIEF    or -1
TEAM_MAYOR   = TEAM_MAYOR    or -1
TEAM_HOBO    = TEAM_HOBO     or -1
TEAM_COOK    = TEAM_COOK     or -1

-- Door groups
AddDoorGroup("Cops and Mayor only", TEAM_CHIEF, TEAM_POLICE, TEAM_MAYOR)
AddDoorGroup("Gundealer only", TEAM_GUN)


-- Agendas
DarkRP.createAgenda("Gangster's agenda", TEAM_MOB, {TEAM_GANG})
DarkRP.createAgenda("Police agenda", {TEAM_MAYOR, TEAM_CHIEF}, {TEAM_POLICE})

-- Group chats
DarkRP.createGroupChat(function(ply) return ply:isCP() end)
DarkRP.createGroupChat(TEAM_MOB, TEAM_GANG)
DarkRP.createGroupChat(function(listener, ply) return not ply or ply:Team() == listener:Team() end)

-- Initial team when first spawning
GAMEMODE.DefaultTeam = TEAM_CITIZEN

-- Teams that belong to Civil Protection
GAMEMODE.CivilProtection = {
    [TEAM_POLICE] = true,
    [TEAM_CHIEF] = true,
    [TEAM_MAYOR] = true,
}

-- Hitman team
DarkRP.addHitmanTeam(TEAM_MOB)

-- Demote groups
DarkRP.createDemoteGroup("Cops", {TEAM_POLICE, TEAM_CHIEF})
DarkRP.createDemoteGroup("Gangsters", {TEAM_GANG, TEAM_MOB})

-- Default categories
DarkRP.createCategory{
    name = "Citizens",
    categorises = "jobs",
    startExpanded = true,
    color = Color(0, 107, 0, 255),
    canSee = fp{fn.Id, true},
    sortOrder = 100,
}

DarkRP.createCategory{
    name = "Civil Protection",
    categorises = "jobs",
    startExpanded = true,
    color = Color(25, 25, 170, 255),
    canSee = fp{fn.Id, true},
    sortOrder = 101,
}

DarkRP.createCategory{
    name = "Gangsters",
    categorises = "jobs",
    startExpanded = true,
    color = Color(75, 75, 75, 255),
    canSee = fp{fn.Id, true},
    sortOrder = 101,
}

DarkRP.createCategory{
    name = "Other",
    categorises = "jobs",
    startExpanded = true,
    color = Color(0, 107, 0, 255),
    canSee = fp{fn.Id, true},
    sortOrder = 255,
}

--PATH addons/!jobs/lua/darkrp_modules/extraf4tab/cl_fancytab.lua:
--[[---------------------------------------------------------------------------
F4 menu tab modification module.
---------------------------------------------------------------------------]]

if true then return end -- REMOVE THIS LINE TO ENABLE THIS MODULE

local url = "https://darkrp.miraheze.org/wiki/Main_Page"
local tabName = "MOTD"

local function createF4MenuTab()
    -- DarkRP.switchTabOrder(2, 3) -- Remove the "--" in this line if you want to move the third tab to the left of the second tab!
    -- DarkRP.removeF4MenuTab("Ammo") -- Remove the "--" in this line if you want to remove the Ammo tab!

    local webPage = vgui.Create("F1HTML")
    webPage:OpenURL(url)
    DarkRP.addF4MenuTab(tabName, webPage)
end
hook.Add("F4MenuTabs", "MyCustomF4MenuTab", createF4MenuTab)

--PATH addons/!jobs/lua/darkrp_customthings/jobs.lua:
--[[---------------------------------------------------------------------------
DarkRP custom jobs
---------------------------------------------------------------------------
This file contains your custom jobs.
This file should also contain jobs from DarkRP that you edited.

Note: If you want to edit a default DarkRP job, first disable it in darkrp_config/disabled_defaults.lua
      Once you've done that, copy and paste the job to this file and edit it.

The default jobs can be found here:
https://github.com/FPtje/DarkRP/blob/master/gamemode/config/jobrelated.lua

For examples and explanation please visit this wiki page:
https://darkrp.miraheze.org/wiki/DarkRP:CustomJobFields

Add your custom jobs under the following line:
---------------------------------------------------------------------------]]


TEAM_KADET = DarkRP.createJob("Kadet", {
    color = Color(255, 255, 255, 255),
    model = {"models/cadet_blue/pm_training_cadet_alpha.mdl"},
    description = "Kadet to najniszy stopie w Wielkiej Armii Republiki. S to wieo zrekrutowani klony, ktre przechodz podstawowe szkolenie. Ucz si taktyki, poj i podstawowych informacji, aby w potem sta si penoprawnymi onierzami Republiki.",
    weapons = {"arccw_k_dc15s_train"},
    command = "KADET",
    max = 0,
    lvl = "global",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "Podstawowe",
    sortOrder = 1,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(100)
        ply:SetHealth(100)
        ply:SetArmor(50)
        ply:SetMaxArmor(50)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
---------------------------------- Joby Podstawowe --------------------------------------
TEAM_KADETA = DarkRP.createJob("Clone Trooper", {
    color = Color(255, 255, 255, 255),
    model = {"models/aussiwozzi/cgi/base/unassigned_trp.mdl"},
    description = "Clone Trooperzy stanowi trzon si zbrojnych Wielkiej Armii Republiki.",
    weapons = {"arccw_k_dc15s","arccw_k_dc17"},
    command = "KADETA",
    max = 0,
    wl = true,
    lvl = "global",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "Podstawowe",
    sortOrder = 2,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(150)
        ply:SetHealth(150)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_KADETB = DarkRP.createJob("Pilot Clone Trooper", {
    color = Color(255, 255, 255, 255),
    model = {"models/aussiwozzi/cgi/base/unassigned_pilot.mdl"},
    description = "Piloci Republiki, operujcy myliwcami i transportowcami, kluczowi w bitwach i wsparciu powietrznym.",
    weapons = {"arccw_k_dc17","weapon_extinguisher","weapon_extinguisher", "weapon_lvsrepair"},
    command = "KADETB",
    max = 3,
    wl = true,
    lvl = "global",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "Podstawowe",
    sortOrder = 3,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(200)
        ply:SetHealth(200)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_KADETC = DarkRP.createJob("Inynier Clone Trooper", {
    color = Color(255, 255, 255, 255),
    model = {"models/aussiwozzi/cgi/base/unassigned_engineer.mdl"},
    description = "Clone Trooperzy stanowi trzon si zbrojnych Wielkiej Armii Republiki.",
    weapons = {"arccw_k_dc17","arccw_k_sb2","weapon_armorkit","weapon_lvsrepair", "alydus_fortificationbuildertablet"},
    command = "KADETC",
    max = 3,
    wl = true,
    lvl = "global",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "Podstawowe",
    sortOrder = 4,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(200)
        ply:SetHealth(200)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_KADETD = DarkRP.createJob("Cikozbrojny Clone Trooper", {
    color = Color(255, 255, 255, 255),
    model = {"models/aussiwozzi/cgi/base/unassigned_heavy.mdl"},
    description = "Clone Trooperzy stanowi trzon si zbrojnych Wielkiej Armii Republiki.",
    weapons = {"arccw_k_dc15a","arccw_k_nade_detonite"},
    command = "KADETD",
    max = 3,
    wl = true,
    lvl = "global",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "Podstawowe",
    sortOrder = 5,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(200)
        ply:SetHealth(200)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_KADETE = DarkRP.createJob("ARF Clone Trooper", {
    color = Color(255, 255, 255, 255),
    model = {"models/aussiwozzi/cgi/base/unassigned_arf.mdl"},
    description = "Clone Trooperzy stanowi trzon si zbrojnych Wielkiej Armii Republiki.",
    weapons = {"arccw_k_dc17","masita_valken38x","arccw_k_nade_smoke","arccw_k_nade_decoy"},
    command = "KADETE",
    max = 3,
    wl = true,
    lvl = "global",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "Podstawowe",
    sortOrder = 6,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(200)
        ply:SetHealth(200)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_KADETF = DarkRP.createJob("Droid Astromechaniczny",  {
    color = Color(60, 150, 135),
    model = {"models/ace/sw/r2.mdl", "models/ace/sw/r4.mdl", "models/ace/sw/r5.mdl"},
    description = "Droid Astromechaniczny gwnie wykorzystywany do drobnych napraw i porachunkw gangw wok miasta.",
    weapons = {"weapon_armorkit","weapon_lvsrepair","f187cutter"},
    command = "KADETF",
    max = 3,
    lvl = "global",
    salary = 10,
    admin = 0,
    vote = false,
    vip = true,
    hasLicense = false,
    candemote = false,
    category = "Podstawowe",
    sortOrder = 7,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(100)
        ply:SetHealth(100)
        ply:SetArmor(50)
        ply:SetMaxArmor(50)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_KADETG = DarkRP.createJob("Droidy",  {
    color = Color(60, 150, 135),
    model = {"models/inventory/pm_protocol_inventory.mdl", "models/translator/pm_protocol_translator.mdl", "models/vendor/pm_protocol_vendor.mdl"},
    description = "Droidy wszelkiej maci wykorzystywane przez Republik wszdzie tam, gdzie tania sia robocza moga sta si jeszcze tasza.",
    weapons = {"weapon_extinguisher","gmod_camera","weapon_armorkit", "weapon_physcannon"},
    command = "KADETG",
    max = 4,
    lvl = "global",
    salary = 10,
    admin = 0,
    vote = false,
    vip = true,
    hasLicense = false,
    candemote = false,
    category = "Podstawowe",
    sortOrder = 8,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(100)
        ply:SetHealth(100)
        ply:SetArmor(50)
        ply:SetMaxArmor(50)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_KADETH = DarkRP.createJob("Pracownik Kantyny", {
    color = Color(255, 255, 255, 255),
    model = {"models/bride/pm_civ_bride_costume_female.mdl"},
    description = "Lokalny zakontraktowany pracownik kantyny podajcy najsmaczniejsze przysmaki na jakie sta dowdztwo (papka odywcza)",
    weapons = {""},
    command = "KADETH",
    max = 1,
    vip = true,
    lvl = "global",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "Podstawowe",
    sortOrder = 9,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(100)
        ply:SetHealth(100)
        ply:SetArmor(50)
        ply:SetMaxArmor(50)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
---------------------------------- Joby RC --------------------------------------
TEAM_RCA = DarkRP.createJob("Republic Commando", {
    color = Color(130, 130, 130),
    model = {"models/aussiwozzi/cgi/commando/rc_atin.mdl", "models/aussiwozzi/cgi/commando/rc_corr.mdl", "models/aussiwozzi/cgi/commando/rc_darman.mdl", "models/aussiwozzi/cgi/commando/rc_fi.mdl"},
    description = "Elitarne oddziay klonw wyszkolone do misji specjalnych, sabotau i skomplikowanych operacji wojskowych. Posuguj si oni zaawansowanym uzbrojeniem i sprztem.",
    weapons = {"arccw_k_dc17m_rifle_republic","arccw_k_dc17m_sniper_republic","arccw_k_dc17m_shotgun_republic","masita_dc17m_launcher","arccw_k_dc15sa","arccw_k_nade_thermalimploder","arccw_k_nade_stun","arccw_k_nade_smoke","weapon_bactainjector","weapon_armorkit","climb_swep2"},
    command = "RCA",
    max = 10,
    wl = true,
    vip = true,
    lvl = "poz_rc",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "Republic Commando",
    sortOrder = 1,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(250)
        ply:SetHealth(250)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_RCB = DarkRP.createJob("Dowdca Republic Commando", {
    color = Color(130, 130, 130),
    model = {"models/aussiwozzi/cgi/commando/rc_atin.mdl", "models/aussiwozzi/cgi/commando/rc_corr.mdl", "models/aussiwozzi/cgi/commando/rc_darman.mdl", "models/aussiwozzi/cgi/commando/rc_fi.mdl", "models/aussiwozzi/cgi/commando/rc_niner.mdl"},
    description = "Elitarne oddziay klonw wyszkolone do misji specjalnych, sabotau i skomplikowanych operacji wojskowych. Posuguj si oni zaawansowanym uzbrojeniem i sprztem.",
    weapons = {"arccw_k_dc17m_rifle_republic","arccw_k_dc17m_sniper_republic","arccw_k_dc17m_shotgun_republic","arccw_k_dc17m_sniper_republic","masita_dc17m_launcher","masita_dc17m_launcher","arccw_k_dc15sa","arccw_k_nade_thermalimploder","arccw_k_nade_stun","arccw_k_nade_smoke","weapon_bactainjector","weapon_armorkit","climb_swep2"},
    command = "RCB",
    max = 2,
    wl = true,
    vip = true,
    lvl = "poz_rc",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "Republic Commando",
    sortOrder = 2,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(250)
        ply:SetHealth(250)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
---------------------------------- Joby Sztab Wyszy ----------------------------
TEAM_SWA = DarkRP.createJob("Podpukownik", {
    color = Color(130, 130, 130),
    model = {"models/aldmor/tc13_adiutant/adiutant.mdl"},
    description = "-",
    weapons = {"arccw_k_dc17","weapon_cuff_elastic", "weapon_armorkit"},
    command = "SWA",
    max = 1,
    wl = true,
    lvl = "global",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "Sztab Wyszy",
    sortOrder = 1,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(250)
        ply:SetHealth(250)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_SWB = DarkRP.createJob("Pukownik", {
    color = Color(130, 130, 130),
    model = {"models/aldmor/tc13_marshall/marshall.mdl"},
    description = "-",
    weapons = {"arccw_k_dc17","weapon_cuff_elastic", "weapon_armorkit"},
    command = "SWB",
    max = 1,
    wl = true,
    lvl = "global",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "Sztab Wyszy",
    sortOrder = 2,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(250)
        ply:SetHealth(250)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_SWC = DarkRP.createJob("Genera", {
    color = Color(130, 130, 130),
    model = {"models/aldmor/tc13_general_2/general.mdl"},
    description = "-",
    weapons = {"arccw_k_dc17","weapon_cuff_elastic", "weapon_armorkit"},
    command = "SWC",
    max = 1,
    wl = true,
    lvl = "global",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "Sztab Wyszy",
    sortOrder = 3,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(250)
        ply:SetHealth(250)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
---------------------------------- Joby 104th --------------------------------------
TEAM_104A = DarkRP.createJob("Piechur 104th", {
    color = Color(130, 116, 116),
    model = {"models/aussiwozzi/cgi/base/104th_trooper.mdl"},
    description = "Elitarny oddzia klonw. Specjalizowali si w operacjach taktycznych, misjach zwiadowczych.",
    weapons = {"arccw_k_dc15a","arccw_k_dc15s","arccw_k_dc17","weapon_grapplehook","arccw_k_nade_smoke"},
    command = "104A",
    max = 0,
    wl = true,
    lvl = "poz_104",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "104th Batalion Wilczego Stada",
    sortOrder = 1,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(200)
        ply:SetHealth(200)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_104B = DarkRP.createJob("Pilot 104th", {
    color = Color(130, 116, 116),
    model = {"models/aussiwozzi/cgi/base/104th_pilot.mdl"},
    description = "Elitarny oddzia klonw. Specjalizowali si w operacjach taktycznych, misjach zwiadowczych.",
    weapons = {"arccw_k_dc15a","arccw_k_dc15s","arccw_k_dc17","weapon_grapplehook","weapon_lvsrepair","arccw_k_nade_smoke"},
    command = "104B",
    max = 5,
    wl = true,
    lvl = "poz_104",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "104th Batalion Wilczego Stada",
    sortOrder = 2,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(150)
        ply:SetHealth(150)
        ply:SetArmor(50)
        ply:SetMaxArmor(50)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_104C = DarkRP.createJob("Medyk 104th", {
    color = Color(130, 116, 116),
    model = {"models/aussiwozzi/cgi/base/104th_medic.mdl"},
    description = "Elitarny oddzia klonw. Specjalizowali si w operacjach taktycznych, misjach zwiadowczych.",
    weapons = {"arccw_k_dc15a","arccw_k_dc15s","arccw_k_dc17","weapon_grapplehook","weapon_bactainjector","weapon_bactanade","weapon_ncs_defib","weapon_armorkit","arccw_k_nade_smoke"},
    command = "104C",
    max = 5,
    wl = true,
    lvl = "poz_104",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "104th Batalion Wilczego Stada",
    sortOrder = 3,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(200)
        ply:SetHealth(200)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_104D = DarkRP.createJob("ARF 104th", {
    color = Color(130, 116, 116),
    model = {"models/aussiwozzi/cgi/base/104th_arf.mdl"},
    description = "Elitarny oddzia klonw. Specjalizowali si w operacjach taktycznych, misjach zwiadowczych.",
    weapons = {"arccw_k_dc15a","arccw_k_dc15s","arccw_k_dc17","weapon_grapplehook","arccw_k_dc15x","arccw_k_nade_smoke"},
    command = "104D",
    max = 4,
    wl = true,
    lvl = "poz_104",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "104th Batalion Wilczego Stada",
    sortOrder = 4,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(200)
        ply:SetHealth(200)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_104E = DarkRP.createJob("Flame Trooper 104th", {
    color = Color(130, 116, 116),
    model = {"models/aussiwozzi/cgi/base/104th_evo.mdl"},
    description = "Elitarny oddzia klonw. Specjalizowali si w operacjach taktycznych, misjach zwiadowczych.",
    weapons = {"arccw_k_dc15a","arccw_k_dc15s","arccw_k_dc17","weapon_grapplehook","arccw_k_nade_smoke"},
    command = "104E",
    max = 4,
    wl = true,
    lvl = "poz_104",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "104th Batalion Wilczego Stada",
    sortOrder = 5,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(200)
        ply:SetHealth(200)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_104F = DarkRP.createJob("BARC Trooper 104th", {
    color = Color(130, 116, 116),
    model = {"models/aussiwozzi/cgi/base/104th_barc.mdl"},
    description = "Elitarny oddzia klonw. Specjalizowali si w operacjach taktycznych, misjach zwiadowczych.",
    weapons = {"arccw_k_dc15a","arccw_k_dc15s","arccw_k_dc17","weapon_grapplehook","arccw_k_republic_e9","arccw_k_nade_smoke"},
    command = "104F",
    max = 4,
    wl = true,
    lvl = "poz_104",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "104th Batalion Wilczego Stada",
    sortOrder = 6,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(200)
        ply:SetHealth(200)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_104G = DarkRP.createJob("Klon Asasyn 104th", {
    color = Color(130, 116, 116),
    model = {"models/aussiwozzi/cgi/base/captain_breaker.mdl"},
    description = "Elitarny oddzia klonw. Specjalizowali si w operacjach taktycznych, misjach zwiadowczych.",
    weapons = {"arccw_k_dc15a","arccw_k_dc15s","arccw_k_dc17","weapon_grapplehook","weapon_lscs","arccw_k_nade_smoke"},
    command = "104G",
    max = 4,
    wl = true,
    vip = true,
    lvl = "poz_104",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "104th Batalion Wilczego Stada",
    sortOrder = 7,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(200)
        ply:SetHealth(200)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_104H = DarkRP.createJob("ARC 104th", {
    color = Color(130, 116, 116),
    model = {"models/aussiwozzi/cgi/base/104th_arc.mdl"},
    description = "Elitarny oddzia klonw. Specjalizowali si w operacjach taktycznych, misjach zwiadowczych.",
    weapons = {"arccw_k_dc15a","arccw_k_dc15s","arccw_k_dc17ext_akimbo","weapon_grapplehook","weapon_bactainjector","weapon_bactanade","arccw_k_westarm5","weapon_ncs_defib","alydus_fortificationbuildertablet","jet_mk1","weapon_armorkit"},
    command = "104H",
    max = 2,
    wl = true,
    lvl = "poz_104",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "104th Batalion Wilczego Stada",
    sortOrder = 8,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(250)
        ply:SetHealth(250)
        ply:SetArmor(150)
        ply:SetMaxArmor(150)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_104I = DarkRP.createJob("Oficer 104th", {
    color = Color(130, 116, 116),
    model = {"models/aussiwozzi/cgi/base/104th_officer.mdl"},
    description = "Elitarny oddzia klonw. Specjalizowali si w operacjach taktycznych, misjach zwiadowczych.",
    weapons = {"arccw_k_dc15a","arccw_k_dc15s","arccw_k_dc17ext_akimbo","weapon_grapplehook","arccw_k_nade_smoke"},
    command = "104I",
    max = 4,
    wl = true,
    lvl = "poz_104",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "104th Batalion Wilczego Stada",
    sortOrder = 9,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(200)
        ply:SetHealth(200)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_104J = DarkRP.createJob("Oficer Wykonawczy 104th", {
    color = Color(130, 116, 116),
    model = {"models/aussiwozzi/cgi/base/104th_boost.mdl"},
    description = "Elitarny oddzia klonw. Specjalizowali si w operacjach taktycznych, misjach zwiadowczych.",
    weapons = {"arccw_k_dc15a","arccw_k_dc15s","arccw_k_dc17s_dual","weapon_grapplehook","arccw_k_nade_smoke","weapon_bactainjector","weapon_bactanade","weapon_armorkit"},
    command = "104J",
    max = 1,
    wl = true,
    lvl = "poz_104",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "104th Batalion Wilczego Stada",
    sortOrder = 10,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(200)
        ply:SetHealth(200)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_104K = DarkRP.createJob("Dowdca 104th", {
    color = Color(130, 116, 116),
    model = {"models/aussiwozzi/cgi/base/104th_wolffe.mdl"},
    description = "Elitarny oddzia klonw. Specjalizowali si w operacjach taktycznych, misjach zwiadowczych.",
    weapons = {"arccw_k_dc15a","arccw_k_dc15s","arccw_k_dc17s_dual","weapon_grapplehook","arccw_k_nade_smoke","weapon_bactainjector","weapon_bactanade","weapon_armorkit"},
    command = "104K",
    max = 1,
    wl = true,
    lvl = "poz_104",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "104th Batalion Wilczego Stada",
    sortOrder = 11,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(200)
        ply:SetHealth(200)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
---------------------------------- Joby 501st --------------------------------------
TEAM_501A = DarkRP.createJob("Piechur 501st", {
    color = Color(48, 118, 230),
    model = {"models/aussiwozzi/cgi/base/501st_trooper.mdl"},
    description = "To jeden z najbardziej rozpoznawalnych oddziaw wojskowych w galaktyce. Pierwotnie utworzony jako elitarna jednostka klonw podczas Wojny, legion szybko zyska reputacj skutecznej i bezwzgldnej siy uderzeniowej.",
    weapons = {"arccw_k_dc15a","arccw_k_dc15s","arccw_k_dc17","weapon_shield_activator","arccw_k_nade_c25"},
    command = "501A",
    max = 0,
    wl = true,
    lvl = "poz_501",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "501st Legion",
    sortOrder = 1,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(200)
        ply:SetHealth(200)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_501B = DarkRP.createJob("Pilot 501st", {
    color = Color(48, 118, 230),
    model = {"models/aussiwozzi/cgi/base/501st_pilot.mdl"},
    description = "To jeden z najbardziej rozpoznawalnych oddziaw wojskowych w galaktyce. Pierwotnie utworzony jako elitarna jednostka klonw podczas Wojny, legion szybko zyska reputacj skutecznej i bezwzgldnej siy uderzeniowej.",
    weapons = {"arccw_k_dc15a","arccw_k_dc15s","arccw_k_dc17","weapon_shield_activator","arccw_k_nade_c25"},
    command = "501B",
    max = 5,
    wl = true,
    lvl = "poz_501",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "501st Legion",
    sortOrder = 2,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(150)
        ply:SetHealth(150)
        ply:SetArmor(50)
        ply:SetMaxArmor(50)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_501C = DarkRP.createJob("Medyk 501st", {
    color = Color(48, 118, 230),
    model = {"models/aussiwozzi/cgi/base/501st_medic.mdl"},
    description = "To jeden z najbardziej rozpoznawalnych oddziaw wojskowych w galaktyce. Pierwotnie utworzony jako elitarna jednostka klonw podczas Wojny, legion szybko zyska reputacj skutecznej i bezwzgldnej siy uderzeniowej.",
    weapons = {"arccw_k_dc15a","arccw_k_dc15s","arccw_k_dc17","weapon_shield_activator","weapon_bactainjector","weapon_bactanade","weapon_ncs_defib","weapon_armorkit","arccw_k_nade_c25"},
    command = "501C",
    max = 5,
    wl = true,
    lvl = "poz_501",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "501st Legion",
    sortOrder = 3,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(200)
        ply:SetHealth(200)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_501D = DarkRP.createJob("Strzelec Wyborowy 501st", {
    color = Color(48, 118, 230),
    model = {"models/aussiwozzi/cgi/base/501st_torrent.mdl"},
    description = "To jeden z najbardziej rozpoznawalnych oddziaw wojskowych w galaktyce. Pierwotnie utworzony jako elitarna jednostka klonw podczas Wojny, legion szybko zyska reputacj skutecznej i bezwzgldnej siy uderzeniowej.",
    weapons = {"arccw_k_dc15a","arccw_k_dc15s","arccw_k_dc17","weapon_shield_activator","arccw_sops_galactic_iondisruptor","arccw_k_nade_c25"},
    command = "501D",
    max = 4,
    wl = true,
    lvl = "poz_501",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "501st Legion",
    sortOrder = 4,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(200)
        ply:SetHealth(200)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_501E = DarkRP.createJob("Egzoszkielet 501st", {
    color = Color(48, 118, 230),
    model = {"models/aussiwozzi/cgi/base/501st_atoa3.mdl"},
    description = "To jeden z najbardziej rozpoznawalnych oddziaw wojskowych w galaktyce. Pierwotnie utworzony jako elitarna jednostka klonw podczas Wojny, legion szybko zyska reputacj skutecznej i bezwzgldnej siy uderzeniowej.",
    weapons = {"arccw_k_dc15a","arccw_k_dc15s","arccw_k_dc17","weapon_shield_activator","arccw_k_nade_c25"},
    command = "501E",
    max = 4,
    wl = true,
    lvl = "poz_501",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "501st Legion",
    sortOrder = 5,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(200)
        ply:SetHealth(200)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_501F = DarkRP.createJob("ARC 501st", {
    color = Color(48, 118, 230),
    model = {"models/aussiwozzi/cgi/base/501st_arc.mdl"},
    description = "To jeden z najbardziej rozpoznawalnych oddziaw wojskowych w galaktyce. Pierwotnie utworzony jako elitarna jednostka klonw podczas Wojny, legion szybko zyska reputacj skutecznej i bezwzgldnej siy uderzeniowej.",
    weapons = {"arccw_k_dc15a","arccw_k_dc15s","arccw_k_dc17ext_akimbo","weapon_grapplehook","weapon_bactainjector","weapon_bactanade","arccw_k_westarm5","weapon_ncs_defib","alydus_fortificationbuildertablet","jet_mk1","weapon_armorkit","arccw_k_nade_c25"},
    command = "501F",
    max = 2,
    wl = true,
    lvl = "poz_501",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "501st Legion",
    sortOrder = 6,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(250)
        ply:SetHealth(250)
        ply:SetArmor(150)
        ply:SetMaxArmor(150)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_501G = DarkRP.createJob("Jet 501st", {
    color = Color(48, 118, 230),
    model = {"models/aussiwozzi/cgi/base/501st_jet_trooper.mdl"},
    description = "To jeden z najbardziej rozpoznawalnych oddziaw wojskowych w galaktyce. Pierwotnie utworzony jako elitarna jednostka klonw podczas Wojny, legion szybko zyska reputacj skutecznej i bezwzgldnej siy uderzeniowej.",
    weapons = {"arccw_k_dc15a","arccw_k_dc15s","arccw_k_dc17","weapon_shield_activator","jet_mk1","arccw_k_nade_c25"},
    command = "501G",
    max = 4,
    wl = true,
    vip = true,
    lvl = "poz_501",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "501st Legion",
    sortOrder = 7,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(200)
        ply:SetHealth(200)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_501H = DarkRP.createJob("332nd Szturmowiec 501st", {
    color = Color(48, 118, 230),
    model = {"models/aussiwozzi/cgi/base/501st_vaughn.mdl"},
    description = "To jeden z najbardziej rozpoznawalnych oddziaw wojskowych w galaktyce. Pierwotnie utworzony jako elitarna jednostka klonw podczas Wojny, legion szybko zyska reputacj skutecznej i bezwzgldnej siy uderzeniowej.",
    weapons = {"arccw_k_dc15a","arccw_k_dc15s","arccw_k_dc17","weapon_shield_activator","arccw_k_dc19","arccw_k_nade_c25"},
    command = "501H",
    max = 4,
    wl = true,
    vip = false,
    lvl = "poz_501",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "501st Legion",
    sortOrder = 8,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(200)
        ply:SetHealth(200)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(255)
    end
})
TEAM_501I = DarkRP.createJob("Oficer 501st", {
    color = Color(48, 118, 230),
    model = {"models/aussiwozzi/cgi/base/501st_officer.mdl"},
    description = "To jeden z najbardziej rozpoznawalnych oddziaw wojskowych w galaktyce. Pierwotnie utworzony jako elitarna jednostka klonw podczas Wojny, legion szybko zyska reputacj skutecznej i bezwzgldnej siy uderzeniowej.",
    weapons = {"arccw_k_dc15a","arccw_k_dc15s","arccw_k_dc17ext_akimbo","weapon_shield_activator","arccw_k_nade_c25"},
    command = "501I",
    max = 4,
    wl = true,
    lvl = "poz_501",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "501st Legion",
    sortOrder = 9,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(200)
        ply:SetHealth(200)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_501J = DarkRP.createJob("Oficer Wykonawczy 501st", {
    color = Color(48, 118, 230),
    model = {"models/aussiwozzi/cgi/base/501st_officer.mdl"},
    description = "To jeden z najbardziej rozpoznawalnych oddziaw wojskowych w galaktyce. Pierwotnie utworzony jako elitarna jednostka klonw podczas Wojny, legion szybko zyska reputacj skutecznej i bezwzgldnej siy uderzeniowej.",
    weapons = {"arccw_k_dc15a","arccw_k_dc15s","arccw_k_dc17s_dual","weapon_shield_activator","arccw_k_nade_c25","weapon_bactainjector","weapon_bactanade","weapon_armorkit"},
    command = "501J",
    max = 1,
    wl = true,
    lvl = "poz_501",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "501st Legion",
    sortOrder = 10,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(200)
        ply:SetHealth(200)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_501K = DarkRP.createJob("Dowdca 501st", {
    color = Color(48, 118, 230),
    model = {"models/aussiwozzi/cgi/base/501st_raffle.mdl"},
    description = "To jeden z najbardziej rozpoznawalnych oddziaw wojskowych w galaktyce. Pierwotnie utworzony jako elitarna jednostka klonw podczas Wojny, legion szybko zyska reputacj skutecznej i bezwzgldnej siy uderzeniowej.",
    weapons = {"arccw_k_dc15a","arccw_k_dc15s","arccw_k_dc17s_dual","weapon_shield_activator","arccw_k_nade_c25","weapon_bactainjector","weapon_bactanade","weapon_armorkit"},
    command = "501K",
    max = 1,
    wl = true,
    lvl = "poz_501",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "501st Legion",
    sortOrder = 11,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(200)
        ply:SetHealth(200)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
---------------------------------- Joby CG --------------------------------------
TEAM_CGA = DarkRP.createJob("Piechur CG",  {
    color = Color(170, 50, 50),
    model = {"models/aussiwozzi/cgi/base/cg_trooper.mdl"},
    description = "Elitarna formacja klonw odpowiedzialna za bezpieczestwo w placwce, zajmuj si te ochron Senatu i najwyszych rang oficjeli Republiki. Ich obowizki obejmoway take egzekwowanie prawa.",
    weapons = {"arccw_k_dc15a","arccw_k_dc15s","arccw_k_dc17","arccw_k_dc15s_stun","weapon_cuff_elastic","weapon_policebaton","arccw_k_nade_stun"},
    command = "CGA",
    max = 0,
    wl = true,
    lvl = "poz_cg",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "Gwardia Coruscant",
    sortOrder = 1,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(230)
        ply:SetHealth(230)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(255)
    end
})
TEAM_CGB = DarkRP.createJob("ARC CG",  {
    color = Color(170, 50, 50),
    model = {"models/aussiwozzi/cgi/base/cg_arc.mdl"},
    description = "Elitarna formacja klonw odpowiedzialna za bezpieczestwo w placwce, zajmuj si te ochron Senatu i najwyszych rang oficjeli Republiki. Ich obowizki obejmoway take egzekwowanie prawa.",
    weapons = {"arccw_k_dc15a","arccw_k_dc15s","arccw_k_dc17ext_akimbo","weapon_grapplehook","weapon_bactainjector","weapon_bactanade","arccw_k_westarm5","weapon_ncs_defib","alydus_fortificationbuildertablet","jet_mk1","arccw_k_dc15s_stun","weapon_cuff_elastic","weapon_policebaton","weapon_armorkit"},
    command = "CGB",
    max = 2,
    wl = true,
    lvl = "poz_cg",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "Gwardia Coruscant",
    sortOrder = 2,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(250)
        ply:SetHealth(250)
        ply:SetArmor(150)
        ply:SetMaxArmor(150)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(255)
    end
})
TEAM_CGC = DarkRP.createJob("Tracker CG",  {
    color = Color(170, 50, 50),
    model = {"models/aussiwozzi/cgi/base/cg_tracker.mdl"},
    description = "Elitarna formacja klonw odpowiedzialna za bezpieczestwo w placwce, zajmuj si te ochron Senatu i najwyszych rang oficjeli Republiki. Ich obowizki obejmoway take egzekwowanie prawa.",
    weapons = {"arccw_k_dc15a","arccw_k_dc15s","arccw_k_dc17","arccw_k_dc15s_stun","weapon_cuff_elastic","weapon_policebaton","arccw_sops_republic_t702","arccw_k_nade_stun"},
    command = "CGC",
    max = 4,
    wl = true,
    lvl = "poz_cg",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "Gwardia Coruscant",
    sortOrder = 3,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(230)
        ply:SetHealth(230)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(255)
    end
})
TEAM_CGD = DarkRP.createJob("Pilot CG",  {
    color = Color(170, 50, 50),
    model = {"models/aussiwozzi/cgi/base/cg_pilot.mdl"},
    description = "Elitarna formacja klonw odpowiedzialna za bezpieczestwo w placwce, zajmuj si te ochron Senatu i najwyszych rang oficjeli Republiki. Ich obowizki obejmoway take egzekwowanie prawa.",
    weapons = {"arccw_k_dc15a","arccw_k_dc15s","arccw_k_dc17","arccw_k_dc15s_stun","weapon_cuff_elastic","weapon_policebaton","arccw_k_nade_stun"},
    command = "CGD",
    max = 5,
    wl = true,
    lvl = "poz_cg",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "Gwardia Coruscant",
    sortOrder = 4,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(180)
        ply:SetHealth(180)
        ply:SetArmor(50)
        ply:SetMaxArmor(50)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(255)
    end
})
TEAM_CGE = DarkRP.createJob("Medyk CG",  {
    color = Color(170, 50, 50),
    model = {"models/aussiwozzi/cgi/base/cg_medic.mdl"},
    description = "Elitarna formacja klonw odpowiedzialna za bezpieczestwo w placwce, zajmuj si te ochron Senatu i najwyszych rang oficjeli Republiki. Ich obowizki obejmoway take egzekwowanie prawa.",
    weapons = {"arccw_k_dc15a","arccw_k_dc15s","arccw_k_dc17","arccw_k_dc15s_stun","weapon_cuff_elastic","weapon_policebaton","weapon_bactainjector","weapon_bactanade","weapon_ncs_defib","weapon_armorkit","arccw_k_nade_stun"},
    command = "CGE",
    max = 5,
    wl = true,
    lvl = "poz_cg",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "Gwardia Coruscant",
    sortOrder = 5,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(230)
        ply:SetHealth(230)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(255)
    end
})
TEAM_CGF = DarkRP.createJob("Shock CG",  {
    color = Color(170, 50, 50),
    model = {"models/aussiwozzi/cgi/base/cg_riot.mdl"},
    description = "Elitarna formacja klonw odpowiedzialna za bezpieczestwo w placwce, zajmuj si te ochron Senatu i najwyszych rang oficjeli Republiki. Ich obowizki obejmoway take egzekwowanie prawa.",
    weapons = {"arccw_k_dc15a","arccw_k_dc15s","arccw_k_dc17","arccw_k_dc15s_stun","weapon_cuff_elastic","weapon_policebaton","weapon_lscs_shockstaff","arccw_k_nade_stun"},
    command = "CGF",
    max = 4,
    wl = true,
    vip = true,
    lvl = "poz_cg",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "Gwardia Coruscant",
    sortOrder = 6,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(230)
        ply:SetHealth(230)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(255)
    end
})
TEAM_CGG = DarkRP.createJob("Infiltrator CG",  {
    color = Color(170, 50, 50),
    model = {"models/aussiwozzi/cgi/base/cg_tops.mdl"},
    description = "Elitarna formacja klonw odpowiedzialna za bezpieczestwo w placwce, zajmuj si te ochron Senatu i najwyszych rang oficjeli Republiki. Ich obowizki obejmoway take egzekwowanie prawa.",
    weapons = {"arccw_k_dc15a","arccw_k_dc15s","arccw_k_dc17","arccw_k_dc15s_stun","weapon_cuff_elastic","weapon_policebaton","cloaking-3","arccw_k_nade_stun"},
    command = "CGG",
    max = 4,
    wl = true,
    lvl = "poz_cg",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "Gwardia Coruscant",
    sortOrder = 7,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(230)
        ply:SetHealth(230)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(255)
    end
})
TEAM_CGH = DarkRP.createJob("Korpus Ochrony CG",  {
    color = Color(170, 50, 50),
    model = {"models/aussiwozzi/cgi/base/cg_raffle.mdl"},
    description = "Elitarna formacja klonw odpowiedzialna za bezpieczestwo w placwce, zajmuj si te ochron Senatu i najwyszych rang oficjeli Republiki. Ich obowizki obejmoway take egzekwowanie prawa.",
    weapons = {"arccw_k_dc15a","arccw_k_dc15s","arccw_k_dc17","arccw_k_dc15s_stun","weapon_cuff_elastic","weapon_policebaton","arccw_k_coruscantguardshield","arccw_k_nade_stun"},
    command = "CGH",
    max = 4,
    wl = true,
    lvl = "poz_cg",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "Gwardia Coruscant",
    sortOrder = 8,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(230)
        ply:SetHealth(230)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(255)
    end
})
TEAM_CGI = DarkRP.createJob("Massif CG",  {
    color = Color(170, 50, 50),
    model = {"models/mrpounder1/player/massif.mdl"},
    description = "Elitarna formacja klonw odpowiedzialna za bezpieczestwo w placwce, zajmuj si te ochron Senatu i najwyszych rang oficjeli Republiki. Ich obowizki obejmoway take egzekwowanie prawa.",
    weapons = {"weapon_drakamassif"},
    command = "CGI",
    max = 5,
    wl = true,
    vip = true,
    lvl = "poz_cg",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "Gwardia Coruscant",
    sortOrder = 9,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(230)
        ply:SetHealth(230)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(255)
    end
})
TEAM_CGJ = DarkRP.createJob("Oficer CG",  {
    color = Color(170, 50, 50),
    model = {"models/aussiwozzi/cgi/base/cg_officer.mdl","models/aussiwozzi/cgi/base/cg_thire.mdl","models/aussiwozzi/cgi/base/cg_riot_officer.mdl"},
    description = "Elitarna formacja klonw odpowiedzialna za bezpieczestwo w placwce, zajmuj si te ochron Senatu i najwyszych rang oficjeli Republiki. Ich obowizki obejmoway take egzekwowanie prawa.",
    weapons = {"arccw_k_dc15a","arccw_k_dc15s","arccw_k_dc17ext_akimbo","arccw_k_dc15s_stun","weapon_cuff_elastic","weapon_policebaton","arccw_k_nade_stun"},
    command = "CGJ",
    max = 5,
    wl = true,
    lvl = "poz_cg",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "Gwardia Coruscant",
    sortOrder = 10,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(230)
        ply:SetHealth(230)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(255)
    end
})
TEAM_CGK = DarkRP.createJob("Oficer Wykonawczy CG",  {
    color = Color(170, 50, 50),
    model = {"models/aussiwozzi/cgi/base/cg_thorn.mdl"},
    description = "Elitarna formacja klonw odpowiedzialna za bezpieczestwo w placwce, zajmuj si te ochron Senatu i najwyszych rang oficjeli Republiki. Ich obowizki obejmoway take egzekwowanie prawa.",
    weapons = {"arccw_k_dc15a","arccw_k_dc15s","arccw_k_dc17s_dual","arccw_k_dc15s_stun","weapon_cuff_elastic","weapon_policebaton","arccw_k_nade_stun","weapon_bactainjector","weapon_bactanade","weapon_armorkit"},
    command = "CGHK",
    max = 1,
    wl = true,
    lvl = "poz_cg",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "Gwardia Coruscant",
    sortOrder = 11,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(230)
        ply:SetHealth(230)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(255)
    end
})
TEAM_CGL = DarkRP.createJob("Dowdca CG",  {
    color = Color(170, 50, 50),
    model = {"models/aussiwozzi/cgi/base/cg_fox.mdl"},
    description = "Elitarna formacja klonw odpowiedzialna za bezpieczestwo w placwce, zajmuj si te ochron Senatu i najwyszych rang oficjeli Republiki. Ich obowizki obejmoway take egzekwowanie prawa.",
    weapons = {"arccw_k_dc15a","arccw_k_dc15s","arccw_k_dc17s_dual","arccw_k_dc15s_stun","weapon_cuff_elastic","weapon_policebaton","arccw_k_nade_stun","weapon_bactainjector","weapon_bactanade","weapon_armorkit"},
    command = "CGL",
    max = 1,
    wl = true,
    lvl = "poz_cg",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "Gwardia Coruscant",
    sortOrder = 12,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(230)
        ply:SetHealth(230)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(255)
    end
})
---------------------------------- Joby Doom --------------------------------------
TEAM_DOOMA = DarkRP.createJob("Piechur DOOM",  {
    color = Color(4, 67, 19),
    model = {"models/aussiwozzi/cgi/base/doom_trooper.mdl"},
    description = "Doom Unit to specjalistyczna jednostka klonw suca w Wielkiej Armii Republiki podczas Wojen Klonw. Oddzia ten by pod dowdztwem Mistrza Jedi Dassa Jennira, ktry by jednym z Jedi walczcych na frontach galaktycznego konfliktu. Doom Unit wyrniaa si zarwno zaawansowanym wyszkoleniem, jak i skutecznoci w prowadzeniu dziaa inynieryjnych.",
    weapons = {"arccw_k_dc15a","arccw_k_dc15s","arccw_k_dc17","alydus_fortificationbuildertablet","weapon_lvsrepair","arccw_k_nade_flashbang"},
    command = "DOOMA",
    max = 0,
    wl = true,
    lvl = "poz_doom",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "DOOM UNIT",
    sortOrder = 1,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(200)
        ply:SetHealth(200)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_DOOMB = DarkRP.createJob("Pilot DOOM",  {
    color = Color(4, 67, 19),
    model = {"models/aussiwozzi/cgi/base/doom_pilot.mdl"},
    description = "Doom Unit - to specjalistyczna jednostka klonw suca w Wielkiej Armii Republiki podczas Wojen Klonw. Oddzia ten by pod dowdztwem Mistrza Jedi Dassa Jennira, ktry by jednym z Jedi walczcych na frontach galaktycznego konfliktu. Doom Unit wyrniaa si zarwno zaawansowanym wyszkoleniem, jak i skutecznoci w prowadzeniu dziaa inynieryjnych.",    
    weapons = {"arccw_k_dc15a","arccw_k_dc15s","arccw_k_dc17","alydus_fortificationbuildertablet","weapon_lvsrepair","arccw_k_nade_flashbang"},
    command = "DOOMB",
    max = 5,
    wl = true,
    lvl = "poz_doom",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "DOOM UNIT",
    sortOrder = 2,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(150)
        ply:SetHealth(150)
        ply:SetArmor(50)
        ply:SetMaxArmor(50)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_DOOMC = DarkRP.createJob("Medyk DOOM",  {
    color = Color(4, 67, 19),
    model = {"models/aussiwozzi/cgi/base/doom_medic.mdl"},
    description = "Doom Unit - to specjalistyczna jednostka klonw suca w Wielkiej Armii Republiki podczas Wojen Klonw. Oddzia ten by pod dowdztwem Mistrza Jedi Dassa Jennira, ktry by jednym z Jedi walczcych na frontach galaktycznego konfliktu. Doom Unit wyrniaa si zarwno zaawansowanym wyszkoleniem, jak i skutecznoci w prowadzeniu dziaa inynieryjnych.",
    weapons = {"arccw_k_dc15a","arccw_k_dc15s","arccw_k_dc17","weapon_bactainjector","weapon_bactanade","weapon_ncs_defib","alydus_fortificationbuildertablet","weapon_lvsrepair","weapon_armorkit","arccw_k_nade_flashbang"},
    command = "DOOMC",
    max = 5,
    wl = true,
    lvl = "poz_doom",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "DOOM UNIT",
    sortOrder = 3,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(200)
        ply:SetHealth(200)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_DOOMD = DarkRP.createJob("Grenadier DOOM",  {
    color = Color(4, 67, 19),
    model = {"models/aussiwozzi/cgi/base/doom_hrs.mdl"},
    description = "Doom Unit - to specjalistyczna jednostka klonw suca w Wielkiej Armii Republiki podczas Wojen Klonw. Oddzia ten by pod dowdztwem Mistrza Jedi Dassa Jennira, ktry by jednym z Jedi walczcych na frontach galaktycznego konfliktu. Doom Unit wyrniaa si zarwno zaawansowanym wyszkoleniem, jak i skutecznoci w prowadzeniu dziaa inynieryjnych.",    
    weapons = {"arccw_k_dc15a","arccw_k_dc15s","arccw_k_dc17","alydus_fortificationbuildertablet","arccw_k_launcher_smartlauncher","mortar_constructor","mortar_range_finder","weapon_lvsrepair","arccw_k_nade_flashbang"},
    command = "DOOMD",
    max = 4,
    wl = true,
    lvl = "poz_doom",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "DOOM UNIT",
    sortOrder = 4,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(200)
        ply:SetHealth(200)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_DOOME = DarkRP.createJob("ARC DOOM",  {
    color = Color(4, 67, 19),
    model = {"models/aussiwozzi/cgi/base/doom_arc.mdl"},
    description = "Doom Unit - to specjalistyczna jednostka klonw suca w Wielkiej Armii Republiki podczas Wojen Klonw. Oddzia ten by pod dowdztwem Mistrza Jedi Dassa Jennira, ktry by jednym z Jedi walczcych na frontach galaktycznego konfliktu. Doom Unit wyrniaa si zarwno zaawansowanym wyszkoleniem, jak i skutecznoci w prowadzeniu dziaa inynieryjnych.",    
    weapons = {"arccw_k_dc15a","arccw_k_dc15s","arccw_k_dc17ext_akimbo","weapon_grapplehook","weapon_bactainjector","weapon_bactanade","arccw_k_westarm5","weapon_ncs_defib","alydus_fortificationbuildertablet","jet_mk1","weapon_armorkit"},
    command = "DOOME",
    max = 2,
    wl = true,
    lvl = "poz_doom",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "DOOM UNIT",
    sortOrder = 5,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(250)
        ply:SetHealth(250)
        ply:SetArmor(150)
        ply:SetMaxArmor(150)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_DOOMF = DarkRP.createJob("Juggernaut DOOM",  {
    color = Color(4, 67, 19),
    model = {"models/lucky/gg/917th/917th_apes3.mdl"},
    description = "Doom Unit - to specjalistyczna jednostka klonw suca w Wielkiej Armii Republiki podczas Wojen Klonw. Oddzia ten by pod dowdztwem Mistrza Jedi Dassa Jennira, ktry by jednym z Jedi walczcych na frontach galaktycznego konfliktu. Doom Unit wyrniaa si zarwno zaawansowanym wyszkoleniem, jak i skutecznoci w prowadzeniu dziaa inynieryjnych.",    
    weapons = {"arccw_k_dc15a","arccw_k_dc15s","arccw_k_dc17","alydus_fortificationbuildertablet","arccw_sops_republic_z6chaingun","weapon_lvsrepair","arccw_k_nade_flashbang"},
    command = "DOOMF",
    max = 4,
    wl = true,
    vip = true,
    lvl = "poz_doom",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "DOOM UNIT",
    sortOrder = 6,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(250)
        ply:SetHealth(250)
        ply:SetArmor(200)
        ply:SetMaxArmor(200)
        ply:SetWalkSpeed(140)
        ply:SetRunSpeed(220)
    end
})
TEAM_DOOMG = DarkRP.createJob("Inynier DOOM",  {
    color = Color(4, 67, 19),
    model = {"models/aussiwozzi/cgi/base/doom_barc.mdl"},
    description = "Doom Unit - to specjalistyczna jednostka klonw suca w Wielkiej Armii Republiki podczas Wojen Klonw. Oddzia ten by pod dowdztwem Mistrza Jedi Dassa Jennira, ktry by jednym z Jedi walczcych na frontach galaktycznego konfliktu. Doom Unit wyrniaa si zarwno zaawansowanym wyszkoleniem, jak i skutecznoci w prowadzeniu dziaa inynieryjnych.",    
    weapons = {"arccw_k_dc15a","arccw_k_dc15s","arccw_k_dc17","alydus_fortificationbuildertablet","weapon_extinguisher","weapon_lvsrepair","arccw_k_nade_flashbang"},
    command = "DOOMG",
    max = 4,
    wl = true,
    lvl = "poz_doom",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "DOOM UNIT",
    sortOrder = 7,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(200)
        ply:SetHealth(200)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_DOOMH = DarkRP.createJob("Operator DOOM",  {
    color = Color(4, 67, 19),
    model = {"models/aussiwozzi/cgi/base/doom_demo.mdl"},
    description = "Doom Unit - to specjalistyczna jednostka klonw suca w Wielkiej Armii Republiki podczas Wojen Klonw. Oddzia ten by pod dowdztwem Mistrza Jedi Dassa Jennira, ktry by jednym z Jedi walczcych na frontach galaktycznego konfliktu. Doom Unit wyrniaa si zarwno zaawansowanym wyszkoleniem, jak i skutecznoci w prowadzeniu dziaa inynieryjnych.",    
    weapons = {"arccw_k_dc15a","arccw_k_dc15s","arccw_k_dc17","alydus_fortificationbuildertablet","weapon_lvsrepair","arccw_k_nade_flashbang"},
    command = "DOOMH",
    max = 4,
    wl = true,
    lvl = "poz_doom",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "DOOM UNIT",
    sortOrder = 8,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(200)
        ply:SetHealth(200)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_DOOMI = DarkRP.createJob("Oficer DOOM",  {
    color = Color(4, 67, 19),
    model = {"models/aussiwozzi/cgi/base/doom_officer.mdl"},
    description = "Doom Unit - to specjalistyczna jednostka klonw suca w Wielkiej Armii Republiki podczas Wojen Klonw. Oddzia ten by pod dowdztwem Mistrza Jedi Dassa Jennira, ktry by jednym z Jedi walczcych na frontach galaktycznego konfliktu. Doom Unit wyrniaa si zarwno zaawansowanym wyszkoleniem, jak i skutecznoci w prowadzeniu dziaa inynieryjnych.",    
    weapons = {"arccw_k_dc15a","arccw_k_dc15s","arccw_k_dc17ext_akimbo","alydus_fortificationbuildertablet","weapon_lvsrepair","arccw_k_nade_flashbang"},
    command = "DOOMI",
    max = 5,
    wl = true,
    lvl = "poz_doom",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "DOOM UNIT",
    sortOrder = 9,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(200)
        ply:SetHealth(200)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_DOOMJ = DarkRP.createJob("Oficer Wykonawczy DOOM",  {
    color = Color(4, 67, 19),
    model = {"models/aussiwozzi/cgi/base/doom_sydney.mdl"},
    description = "Doom Unit - to specjalistyczna jednostka klonw suca w Wielkiej Armii Republiki podczas Wojen Klonw. Oddzia ten by pod dowdztwem Mistrza Jedi Dassa Jennira, ktry by jednym z Jedi walczcych na frontach galaktycznego konfliktu. Doom Unit wyrniaa si zarwno zaawansowanym wyszkoleniem, jak i skutecznoci w prowadzeniu dziaa inynieryjnych.",    
    weapons = {"arccw_k_dc15a","arccw_k_dc15s","arccw_k_dc17s_dual","alydus_fortificationbuildertablet","weapon_lvsrepair","arccw_k_nade_flashbang","weapon_bactainjector","weapon_bactanade","weapon_armorkit"},
    command = "DOOMJ",
    max = 1,
    wl = true,
    lvl = "poz_doom",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "DOOM UNIT",
    sortOrder = 10,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(200)
        ply:SetHealth(200)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_DOOMK = DarkRP.createJob("Dowdca DOOM",  {
    color = Color(4, 67, 19),
    model = {"models/aussiwozzi/cgi/base/doom_commander.mdl"},
    description = "Doom Unit - to specjalistyczna jednostka klonw suca w Wielkiej Armii Republiki podczas Wojen Klonw. Oddzia ten by pod dowdztwem Mistrza Jedi Dassa Jennira, ktry by jednym z Jedi walczcych na frontach galaktycznego konfliktu. Doom Unit wyrniaa si zarwno zaawansowanym wyszkoleniem, jak i skutecznoci w prowadzeniu dziaa inynieryjnych.",    
    weapons = {"arccw_k_dc15a","arccw_k_dc15s","arccw_k_dc17s_dual","alydus_fortificationbuildertablet","weapon_lvsrepair","arccw_k_nade_flashbang","weapon_bactainjector","weapon_bactanade","weapon_armorkit"},
    command = "DOOMK",
    max = 1,
    wl = true,
    lvl = "poz_doom",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "DOOM UNIT",
    sortOrder = 11,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(200)
        ply:SetHealth(200)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
---------------------------------- Joby RSB --------------------------------------
TEAM_RSBA = DarkRP.createJob("Dyrektor RSB",  {
    color = Color(85, 19, 63),
    model = {"models/navy/gnavykrennic.mdl"},
    description = "Organ zajmujca si wywiadem, kontrwywiadem i operacjami specjalnymi. Ich zadaniem jest zwalczanie szpiegw Separatystw, wykrywanie zdrad i eliminowanie zagroe wewntrznych oraz nadzorowanie armi.",
    weapons = {"arccw_k_dc17","weapon_cuff_elastic","weapon_armorkit"},
    command = "RSBA",
    max = 1,
    wl = true,
    lvl = "poz_rsb",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "RSB",
    sortOrder = 1,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(200)
        ply:SetHealth(200)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_RSBB = DarkRP.createJob("Agent RSB",  {
    color = Color(85, 19, 63),
    model = {"models/navy/gnavyrsb.mdl"},
    description = "Organ zajmujca si wywiadem, kontrwywiadem i operacjami specjalnymi. Ich zadaniem jest zwalczanie szpiegw Separatystw, wykrywanie zdrad i eliminowanie zagroe wewntrznych oraz nadzorowanie armi.",
    weapons = {"arccw_k_dc17","weapon_cuff_elastic", "weapon_armorkit"},
    command = "RSBB",
    max = 4,
    wl = true,
    lvl = "poz_rsb",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "RSB",
    sortOrder = 2,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(200)
        ply:SetHealth(200)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_RSBC = DarkRP.createJob("Asystent RSB",  {
    color = Color(85, 19, 63),
    model = {"models/navy/gnavyrsb.mdl"},
    description = "Organ zajmujca si wywiadem, kontrwywiadem i operacjami specjalnymi. Ich zadaniem jest zwalczanie szpiegw Separatystw, wykrywanie zdrad i eliminowanie zagroe wewntrznych oraz nadzorowanie armi.",
    weapons = {"arccw_k_dc17","weapon_cuff_elastic", "weapon_armorkit"},
    command = "RSBC",
    max = 4,
    wl = true,
    lvl = "poz_rsb",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "RSB",
    sortOrder = 3,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(200)
        ply:SetHealth(200)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
---------------------------------- Joby Jedi --------------------------------------
TEAM_JEDIA = DarkRP.createJob("Adept Jedi",  {
    color = Color(23, 192, 214),
    model = {"models/jazzmcfly/jka/younglings/jka_young_anikan.mdl","models/jazzmcfly/jka/younglings/jka_young_shak.mdl","models/jazzmcfly/jka/younglings/jka_young_female.mdl"},
    description = "Obrocy pokoju i sprawiedliwoci w galaktyce. Jedi s uytkownikami Mocy, wyszkolonymi w walce mieczem wietlnym i dyplomacji.",
    weapons = {"weapon_lscs"},
    command = "JEDIA",
    max = 0,
    lvl = "poz_jedi",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "Jedi",
    sortOrder = 1,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(100)
        ply:SetHealth(100)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
    TEAM_JEDIB = DarkRP.createJob("Padawan Jedi [None VIP]",  {
    color = Color(23, 192, 214),
    model = {"models/player/curse/jedi/padawan/jedi_padawan.mdl"},
    description = "Obrocy pokoju i sprawiedliwoci w galaktyce. Jedi s uytkownikami Mocy, wyszkolonymi w walce mieczem wietlnym i dyplomacji.",
    weapons = {"weapon_lscs"},
    command = "JEDIB",
    max = 5,
    wl = true,
    jedi = true,
    lvl = "poz_jedi",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "Jedi",
    sortOrder = 2,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(300)
        ply:SetHealth(300)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_JEDIC = DarkRP.createJob("Padawan Jedi",  {
    color = Color(23, 192, 214),
    model = {"models/player/curse/jedi/padawan/jedi_padawan.mdl"},
    description = "Obrocy pokoju i sprawiedliwoci w galaktyce. Jedi s uytkownikami Mocy, wyszkolonymi w walce mieczem wietlnym i dyplomacji.",
    weapons = {"weapon_lscs"},
    command = "JEDIC",
    max = 8,
    wl = true,
    vip = true,
    jedi = true,
    lvl = "poz_jedi",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "Jedi",
    sortOrder = 3,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(600)
        ply:SetHealth(600)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_JEDID = DarkRP.createJob("Rycerz Jedi",  {
    color = Color(23, 192, 214),
    model = {"models/player/curse/jedi/knight/jedi_knight.mdl","models/player/curse/jedi/armored/jedi_armored.mdl"},
    description = "Obrocy pokoju i sprawiedliwoci w galaktyce. Jedi s uytkownikami Mocy, wyszkolonymi w walce mieczem wietlnym i dyplomacji.",
    weapons = {"weapon_lscs"},
    command = "JEDID",
    max = 5,
    wl = true,
    vip = true,
    jedi = true,
    lvl = "poz_jedi",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "Jedi",
    sortOrder = 4,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(800)
        ply:SetHealth(800)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_JEDIE = DarkRP.createJob("Protektor Jedi",  {
    color = Color(23, 192, 214),
    model = {"models/player/curse/jedi/knight/jedi_knight.mdl","models/player/curse/jedi/armored/jedi_armored.mdl"},
    description = "Obrocy pokoju i sprawiedliwoci w galaktyce. Jedi s uytkownikami Mocy, wyszkolonymi w walce mieczem wietlnym i dyplomacji.",
    weapons = {"weapon_lscs"},
    command = "JEDIE",
    max = 3,
    wl = true,
    vip = true,
    jedi = true,
    lvl = "poz_jedi",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "Jedi",
    sortOrder = 5,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(1000)
        ply:SetHealth(1000)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_JEDIF = DarkRP.createJob("Mistrz Jedi",  {
    color = Color(23, 192, 214),
    model = {"models/player/curse/jedi/knight/jedi_knight.mdl","models/player/curse/jedi/armored/jedi_armored.mdl"},
    description = "Obrocy pokoju i sprawiedliwoci w galaktyce. Jedi s uytkownikami Mocy, wyszkolonymi w walce mieczem wietlnym i dyplomacji.",
    weapons = {"weapon_lscs"},
    command = "JEDIF",
    max = 2,
    wl = true,
    vip = true,
    jedi = true,
    lvl = "poz_jedi",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "Jedi",
    sortOrder = 6,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(1200)
        ply:SetHealth(1200)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_JEDIG = DarkRP.createJob("Stranik wiatynny Jedi",  {
    color = Color(23, 192, 214),
    model = {"models/player/curse/jedi/templeguard/templeguard.mdl"},
    description = "Obrocy pokoju i sprawiedliwoci w galaktyce. Jedi s uytkownikami Mocy, wyszkolonymi w walce mieczem wietlnym i dyplomacji.",
    weapons = {"weapon_lscs","weapon_cuff_elastic","weapon_policebaton"},
    command = "JEDIG",
    max = 3,
    wl = true,
    vip = true,
    jedi = true,
    lvl = "poz_jedi",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "Jedi",
    sortOrder = 7,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(1500)
        ply:SetHealth(1500)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_JEDIH = DarkRP.createJob("Oficer Stray witynnej",  {
    color = Color(23, 192, 214),
    model = {"models/player/curse/jedi/templeguard/templeguard.mdl"},
    description = "Obrocy pokoju i sprawiedliwoci w galaktyce. Jedi s uytkownikami Mocy, wyszkolonymi w walce mieczem wietlnym i dyplomacji.",
    weapons = {"weapon_lscs","weapon_cuff_elastic","weapon_policebaton"},
    command = "JEDIH",
    max = 2,
    wl = true,
    vip = true,
    jedi = true,
    lvl = "poz_jedi",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "Jedi",
    sortOrder = 8,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(1500)
        ply:SetHealth(1500)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_JEDII = DarkRP.createJob("Wielki Mistrz Jedi",  {
    color = Color(23, 192, 214),
    model = {"models/helios/custom/jerkai_t4lk.mdl","models/helios/custom/jerkai_templeguard_004a.mdl","models/helios/custom/jerkai_bathrobes.mdl"},
    description = "Obrocy pokoju i sprawiedliwoci w galaktyce. Jedi s uytkownikami Mocy, wyszkolonymi w walce mieczem wietlnym i dyplomacji.",
    weapons = {"weapon_lscs"},
    command = "JEDII",
    max = 1,
    wl = true,
    vip = true,
    jedi = true,
    lvl = "poz_jedi",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "Jedi",
    sortOrder = 9,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(2500)
        ply:SetHealth(2500)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
---------------------------------- Joby Jedi Kanoniczne --------------------------------------
TEAM_JEDIKA = DarkRP.createJob("Obi-Wan Kenobi",  {
    color = Color(23, 192, 214),
    model = {"models/player/generalkenobi/cgikenobi.mdl","models/player/jedi/obi_kenobi_s7.mdl"},
    description = "Obrocy pokoju i sprawiedliwoci w galaktyce. Jedi s uytkownikami Mocy, wyszkolonymi w walce mieczem wietlnym i dyplomacji.",
    weapons = {"weapon_lscs"},
    command = "JEDIKA",
    max = 1,
    wl = true,
    vip = true,
    jedi = true,
    lvl = "poz_jedi",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "Jedi Kanoniczni",
    sortOrder = 1,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(2500)
        ply:SetHealth(2500)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_JEDIKB = DarkRP.createJob("Ayala Secura",  {
    color = Color(23, 192, 214),
    model = {"models/player/jedi/aayla_secura_s7.mdl"},
    description = "Obrocy pokoju i sprawiedliwoci w galaktyce. Jedi s uytkownikami Mocy, wyszkolonymi w walce mieczem wietlnym i dyplomacji.",
    weapons = {"weapon_lscs"},
    command = "JEDIKB",
    max = 1,
    wl = true,
    vip = true,
    jedi = true,
    lvl = "poz_jedi",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "Jedi Kanoniczni",
    sortOrder = 2,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(2500)
        ply:SetHealth(2500)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_JEDIKC = DarkRP.createJob("Ki-Adi-Mundi",  {
    color = Color(23, 192, 214),
    model = {"models/player/jedi/ki_adi_s7.mdl"},
    description = "Obrocy pokoju i sprawiedliwoci w galaktyce. Jedi s uytkownikami Mocy, wyszkolonymi w walce mieczem wietlnym i dyplomacji.",
    weapons = {"weapon_lscs"},
    command = "JEDIKC",
    max = 1,
    wl = true,
    vip = true,
    jedi = true,
    lvl = "poz_jedi",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "Jedi Kanoniczni",
    sortOrder = 3,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(2500)
        ply:SetHealth(2500)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_JEDIKD = DarkRP.createJob("Kit Fisto",  {
    color = Color(23, 192, 214),
    model = {"models/player/jedi/kit_fisto.mdl"},
    description = "Obrocy pokoju i sprawiedliwoci w galaktyce. Jedi s uytkownikami Mocy, wyszkolonymi w walce mieczem wietlnym i dyplomacji.",
    weapons = {"weapon_lscs"},
    command = "JEDIKD",
    max = 1,
    wl = true,
    vip = true,
    jedi = true,
    lvl = "poz_jedi",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "Jedi Kanoniczni",
    sortOrder = 4,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(2500)
        ply:SetHealth(2500)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_JEDIKE = DarkRP.createJob("Luminara Unduli",  {
    color = Color(23, 192, 214),
    model = {"models/player/jedi/luminara_s7.mdl"},
    description = "Obrocy pokoju i sprawiedliwoci w galaktyce. Jedi s uytkownikami Mocy, wyszkolonymi w walce mieczem wietlnym i dyplomacji.",
    weapons = {"weapon_lscs"},
    command = "JEDIKE",
    max = 1,
    wl = true,
    vip = true,
    jedi = true,
    lvl = "poz_jedi",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "Jedi Kanoniczni",
    sortOrder = 5,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(2500)
        ply:SetHealth(2500)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_JEDIKF = DarkRP.createJob("Mace Windu",  {
    color = Color(23, 192, 214),
    model = {"models/player/jedi/mace_windu_s7.mdl"},
    description = "Obrocy pokoju i sprawiedliwoci w galaktyce. Jedi s uytkownikami Mocy, wyszkolonymi w walce mieczem wietlnym i dyplomacji.",
    weapons = {"weapon_lscs"},
    command = "JEDIKF",
    max = 1,
    wl = true,
    vip = true,
    jedi = true,
    lvl = "poz_jedi",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "Jedi Kanoniczni",
    sortOrder = 6,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(2500)
        ply:SetHealth(2500)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_JEDIKG = DarkRP.createJob("Plo Koon",  {
    color = Color(23, 192, 214),
    model = {"models/player/jedi/plo_koon_s7.mdl"},
    description = "Obrocy pokoju i sprawiedliwoci w galaktyce. Jedi s uytkownikami Mocy, wyszkolonymi w walce mieczem wietlnym i dyplomacji.",
    weapons = {"weapon_lscs"},
    command = "JEDIKG",
    max = 1,
    wl = true,
    vip = true,
    jedi = true,
    lvl = "poz_jedi",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "Jedi Kanoniczni",
    sortOrder = 7,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(2500)
        ply:SetHealth(2500)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_JEDIKH = DarkRP.createJob("Quinlan Vos",  {
    color = Color(23, 192, 214),
    model = {"models/player/jedi/quinlan_vos_s7.mdl"},
    description = "Obrocy pokoju i sprawiedliwoci w galaktyce. Jedi s uytkownikami Mocy, wyszkolonymi w walce mieczem wietlnym i dyplomacji.",
    weapons = {"weapon_lscs"},
    command = "JEDIKH",
    max = 1,
    wl = true,
    vip = true,
    jedi = true,
    lvl = "poz_jedi",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "Jedi Kanoniczni",
    sortOrder = 8,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(2500)
        ply:SetHealth(2500)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_JEDIKI = DarkRP.createJob("Anakin Skywalker",  {
    color = Color(23, 192, 214),
    model = {"models/player/sample/anakin/anakins7.mdl"},
    description = "Obrocy pokoju i sprawiedliwoci w galaktyce. Jedi s uytkownikami Mocy, wyszkolonymi w walce mieczem wietlnym i dyplomacji.",
    weapons = {"weapon_lscs"},
    command = "JEDIKI",
    max = 1,
    wl = true,
    vip = true,
    jedi = true,
    lvl = "poz_jedi",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "Jedi Kanoniczni",
    sortOrder = 9,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(2500)
        ply:SetHealth(2500)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_JEDIKJ = DarkRP.createJob("Ahsoka Tano",  {
    color = Color(23, 192, 214),
    model = {"models/plo/ahsoka/ahsoka_s7.mdl"},
    description = "Obrocy pokoju i sprawiedliwoci w galaktyce. Jedi s uytkownikami Mocy, wyszkolonymi w walce mieczem wietlnym i dyplomacji.",
    weapons = {"weapon_lscs"},
    command = "JEDIKJ",
    max = 1,
    wl = true,
    vip = true,
    jedi = true,
    lvl = "poz_jedi",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "Jedi Kanoniczni",
    sortOrder = 10,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(2500)
        ply:SetHealth(2500)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
---------------------------------- Joby CIS --------------------------------------
TEAM_CISA = DarkRP.createJob("Droid B1",  {
    color = Color(23, 192, 214),
    model = {"models/aussiwozzi/cgi/b1droids/b1_battledroid_pm.mdl"},
    description = "Separatyci, ktrzy przeciwstawili si Republice Galaktycznej, tworzc potn armie droidw bojowych. Znani z liczebnoci i zaawansowanej technologii.",
    weapons = {"arccw_k_e5", "weapon_armorkit", "arccw_k_nade_impact"},
    command = "CISA",
    max = 0,
    wl = true,
    vip = true,
    lvl = "poz_cis",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "CIS",
    sortOrder = 1,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(200)
        ply:SetHealth(200)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_CISB = DarkRP.createJob("Droid B1 Heavy",  {
    color = Color(23, 192, 214),
    model = {"models/aussiwozzi/cgi/b1droids/b1_battledroid_heavy_pm.mdl"},
    description = "Separatyci, ktrzy przeciwstawili si Republice Galaktycznej, tworzc potn armie droidw bojowych. Znani z liczebnoci i zaawansowanej technologii.",
    weapons = {"arccw_k_z4","arccw_k_sg6", "weapon_armorkit", "arccw_k_nade_impact", "arccw_k_launcher_e60r"},
    command = "CISB",
    max = 5,
    wl = true,
    vip = true,
    lvl = "poz_cis",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "CIS",
    sortOrder = 2,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(200)
        ply:SetHealth(200)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_CISC = DarkRP.createJob("Droid B1 Oficer",  {
    color = Color(23, 192, 214),
    model = {"models/aussiwozzi/cgi/b1droids/b1_battledroid_commander_pm.mdl"},
    description = "Separatyci, ktrzy przeciwstawili si Republice Galaktycznej, tworzc potn armie droidw bojowych. Znani z liczebnoci i zaawansowanej technologii.",
    weapons = {"arccw_k_e5","arccw_k_e5s", "weapon_armorkit", "arccw_k_nade_impact", "arccw_e5s"},
    command = "CISC",
    max = 2,
    wl = true,
    vip = true,
    lvl = "poz_cis",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "CIS",
    sortOrder = 3,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(200)
        ply:SetHealth(200)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_CISD = DarkRP.createJob("Droid B2",  {
    color = Color(23, 192, 214),
    model = {"models/aussiwozzi/cgi/b1droids/b2_battledroid_pm.mdl"},
    description = "Separatyci, ktrzy przeciwstawili si Republice Galaktycznej, tworzc potn armie droidw bojowych. Znani z liczebnoci i zaawansowanej technologii.",
    weapons = {"arccw_k_b2hand", "weapon_armorkit"},
    command = "CISD",
    max = 3,
    wl = true,
    vip = true,
    lvl = "poz_cis",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "CIS",
    sortOrder = 4,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(200)
        ply:SetHealth(200)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_CISE = DarkRP.createJob("Droid B2 Rocket",  {
    color = Color(23, 192, 214),
    model = {"models/aussiwozzi/cgi/b1droids/b2_battledroid_rocket_pm.mdl"},
    description = "Separatyci, ktrzy przeciwstawili si Republice Galaktycznej, tworzc potn armie droidw bojowych. Znani z liczebnoci i zaawansowanej technologii.",
    weapons = {"arccw_k_b2hand", "weapon_armorkit"},
    command = "CISE",
    max = 3,
    wl = true,
    vip = true,
    lvl = "poz_cis",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "CIS",
    sortOrder = 5,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(200)
        ply:SetHealth(200)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_CISF = DarkRP.createJob("Droid B2 Cannon",  {
    color = Color(23, 192, 214),
    model = {"models/aussiwozzi/cgi/b1droids/b2_battledroid_cannon_pm.mdl"},
    description = "Separatyci, ktrzy przeciwstawili si Republice Galaktycznej, tworzc potn armie droidw bojowych. Znani z liczebnoci i zaawansowanej technologii.",
    weapons = {"arccw_k_b2hand", "weapon_armorkit"},
    command = "CISF",
    max = 3,
    wl = true,
    vip = true,
    lvl = "poz_cis",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "CIS",
    sortOrder = 6,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(200)
        ply:SetHealth(200)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_CISG = DarkRP.createJob("Droid B2 Snow",  {
    color = Color(23, 192, 214),
    model = {"models/aussiwozzi/cgi/b1droids/b2_battledroid_snow_pm.mdl"},
    description = "Separatyci, ktrzy przeciwstawili si Republice Galaktycznej, tworzc potn armie droidw bojowych. Znani z liczebnoci i zaawansowanej technologii.",
    weapons = {"arccw_k_b2hand", "weapon_armorkit"},
    command = "CISG",
    max = 3,
    wl = true,
    vip = true,
    lvl = "poz_cis",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "CIS",
    sortOrder = 7,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(200)
        ply:SetHealth(200)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_CISH = DarkRP.createJob("Droid B2 Camo",  {
    color = Color(23, 192, 214),
    model = {"models/aussiwozzi/cgi/b1droids/b2_battledroid_camo_pm.mdl"},
    description = "Separatyci, ktrzy przeciwstawili si Republice Galaktycznej, tworzc potn armie droidw bojowych. Znani z liczebnoci i zaawansowanej technologii.",
    weapons = {"arccw_k_b2hand", "weapon_armorkit"},
    command = "CISH",
    max = 3,
    wl = true,
    vip = true,
    lvl = "poz_cis",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "CIS",
    sortOrder = 8,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(200)
        ply:SetHealth(200)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_CISI = DarkRP.createJob("Droid BX",  {
    color = Color(23, 192, 214),
    model = {"models/bx/pm_droid_cis_bx.mdl"},
    description = "Separatyci, ktrzy przeciwstawili si Republice Galaktycznej, tworzc potn armie droidw bojowych. Znani z liczebnoci i zaawansowanej technologii.",
    weapons = {"arccw_k_e5bx", "weapon_armorkit", "arccw_k_rg4d", "weapon_medkitn", "cloaking-3"},
    command = "CISI",
    max = 2,
    wl = true,
    vip = true,
    lvl = "poz_cis",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "CIS",
    sortOrder = 9,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(200)
        ply:SetHealth(200)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_CISJ = DarkRP.createJob("Magnaguard",  {
    color = Color(23, 192, 214),
    model = {"models/tfa/comm/gg/pm_sw_magna_guard_combined.mdl"},
    description = "Separatyci, ktrzy przeciwstawili si Republice Galaktycznej, tworzc potn armie droidw bojowych. Znani z liczebnoci i zaawansowanej technologii.",
    weapons = {"weapon_lscs_magnastaff"},
    command = "CISJ",
    max = 1,
    wl = true,
    vip = true,
    lvl = "poz_cis",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "CIS",
    sortOrder = 10,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(200)
        ply:SetHealth(200)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_CISK = DarkRP.createJob("Tactical Droid",  {
    color = Color(23, 192, 214),
    model = {"models/helios/kalani15.mdl"},
    description = "Separatyci, ktrzy przeciwstawili si Republice Galaktycznej, tworzc potn armie droidw bojowych. Znani z liczebnoci i zaawansowanej technologii.",
    weapons = {"arccw_k_e5bx", "weapon_armorkit", "weapon_medkit"},
    command = "CISK",
    max = 1,
    wl = true,
    vip = true,
    lvl = "poz_cis",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "CIS",
    sortOrder = 11,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(200)
        ply:SetHealth(200)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_CISL = DarkRP.createJob("Genera Grievous",  {
    color = Color(23, 192, 214),
    model = {"models/aussisengels/grievous/general_grievous.mdl"},
    description = "Separatyci, ktrzy przeciwstawili si Republice Galaktycznej, tworzc potn armie droidw bojowych. Znani z liczebnoci i zaawansowanej technologii.",
    weapons = {"weapon_lscs"},
    command = "CISL",
    max = 1,
    wl = true,
    jedi = true,
    vip = true,
    lvl = "poz_cis",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "CIS",
    sortOrder = 12,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(200)
        ply:SetHealth(200)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})

---------------------------------- EVENT OMGGGG --------------------------------------

TEAM_FLOTA = DarkRP.createJob("Flota",  {
    color = Color(22, 46, 72),
    model = {"models/navy/gnavycrewman.mdl", "models/navy/gnavyadmiral.mdl", "models/navy/gnavyarmand.mdl", "models/navy/gnavydao.mdl", "models/navy/gnavyengineer.mdl", "models/navy/gnavygunner.mdl", "models/navy/gnavykilian.mdl", "models/navy/gnavykrennic.mdl", "models/navy/gnavymedic.mdl", "models/navy/gnavyofficer.mdl"},
    description = "Oficerowie Floty WAR (Wielkiej Armii Republiki) peni kluczow rol w dowodzeniu jednostkami kosmicznymi i logistycznym wsparciu operacji wojskowych. S odpowiedzialni za koordynacj flotylli gwiezdnych niszczycieli, transportowcw oraz myliwcw, zapewniajc skuteczne dziaania zarwno w przestrzeni kosmicznej, jak i w operacjach desantowych.",
    weapons = {"masita_dc17", "weapon_armorkit", "arccw_k_nade_impact", "weapon_cuff_elastic", "weapon_policebaton", "arccw_k_dc17_stun"},
    command = "FLOTA",
    max = 10,
    jedi = true,
    wl = true,
    lvl = "global",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "Eventowe",
    sortOrder = 1,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(200)
        ply:SetHealth(200)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_SENAT = DarkRP.createJob("Senator",  {
    color = Color(144, 145, 189),
    model = {"models/formal/pm_civ_formal_human_female.mdl", "models/formal/pm_civ_formal_human_male.mdl"},
    description = "Przedstawiciele planet i systemw w Senacie Galaktycznym, ksztatujcy prawo i polityk Republiki.",
    weapons = {"arccw_k_defender"},
    command = "SENATOR",
    max = 1,
    jedi = false,
    wl = true,
    lvl = "global",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "Eventowe",
    sortOrder = 2,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(200)
        ply:SetHealth(200)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_SENATA = DarkRP.createJob("Siy Bezpieczestwa Coruscant",  {
    color = Color(145, 145, 190),
    model = {"models/guard/pm_protocol_guard.mdl"},
    description = "Droidy 501-Z stanowi istotny element si bezpieczestwa Coruscant, zapewniajc skuteczne egzekwowanie prawa w gigantycznej metropolii, zaprogramowane do bezstronnej i precyzyjnej pracy, odgrywaj kluczow rol w utrzymaniu porzdku.",
    weapons = {"arccw_sops_galactic_dt40","weapon_cuff_elastic","weapon_policebaton","weapon_armorkit", "arccw_k_dc17_stun"},
    command = "DROIDSTRAZNIK",
    max = 4,
    jedi = false,
    wl = true,
    lvl = "global",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "Eventowe",
    sortOrder = 3,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(200)
        ply:SetHealth(200)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_YODA = DarkRP.createJob("Yoda",  {
    color = Color(192, 192, 192),
    model = {"models/tfa/comm/gg/pm_sw_yodanojig.mdl"},
    description = "Obrocy pokoju i sprawiedliwoci w galaktyce. Jedi s uytkownikami Mocy, wyszkolonymi w walce mieczem wietlnym i dyplomacji.",
    weapons = {"weapon_lscs"},
    command = "YODA",
    max = 1,
    jedi = true,
    wl = true,
    lvl = "global",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "Eventowe",
    sortOrder = 4,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(200)
        ply:SetHealth(200)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_MAUL = DarkRP.createJob("Maul",  {
    color = Color(192, 192, 192),
    model = {"models/maul.mdl"},
    description = "Sithowie to uytkownicy mocy ktrzy przeszli na ciemn stron mocy aby niszczy i podbija.",
    weapons = {"weapon_lscs"},
    command = "MAUL",
    max = 1,
    jedi = true,
    wl = true,
    lvl = "global",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "Eventowe",
    sortOrder = 5,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(200)
        ply:SetHealth(200)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_SAVAGE = DarkRP.createJob("Savage",  {
    color = Color(192, 192, 192),
    model = {"models/savage.mdl"},
    description = "Sithowie to uytkownicy mocy ktrzy przeszli na ciemn stron mocy aby niszczy i podbija.",
    weapons = {"weapon_lscs"},
    command = "SAVAGE",
    max = 1,
    jedi = true,
    wl = true,
    lvl = "global",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "Eventowe",
    sortOrder = 6,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(200)
        ply:SetHealth(200)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_VENTRESS = DarkRP.createJob("Ventress",  {
    color = Color(192, 192, 192),
    model = {"models/player/dathomir/pm_nightsister_ventress.mdl"},
    description = "Sithowie to uytkownicy mocy ktrzy przeszli na ciemn stron mocy aby niszczy i podbija.",
    weapons = {"weapon_lscs"},
    command = "VENTRESS",
    max = 1,
    jedi = true,
    wl = true,
    lvl = "global",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "Eventowe",
    sortOrder = 7,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(200)
        ply:SetHealth(200)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
---------------------------------- Joby Cywilne --------------------------------------
TEAM_CYWILA = DarkRP.createJob("Cywil",  {
    color = Color(60, 150, 135),
    model = {"models/resident/pm_civ_resident_human_male.mdl", "models/formal/pm_civ_formal_human_male.mdl", "models/formal/pm_civ_formal_human_female.mdl"},
    description = "Mieszkaniec okolicznych miast i wsi.",
    weapons = {"weapon_waterballoon"},
    command = "CYWILA",
    max = 0,
    lvl = "global",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "Cywile",
    sortOrder = 1,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(200)
        ply:SetHealth(200)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_CYWILB = DarkRP.createJob("Przemytnik",  {
    color = Color(60, 150, 135),
    model = {"models/smuggler/pm_civ_smuggler_human_male.mdl"},
    description = "Lokalny rzezimieszek specjalizujcy si w sztuce przemytu.",
    weapons = {"weapon_fists","mvp_perfecthands","arccw_k_smuggler"},
    command = "CYWILB",
    max = 2,
    lvl = "global",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "Cywile",
    sortOrder = 2,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(200)
        ply:SetHealth(200)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_CYWILC = DarkRP.createJob("Inynier",  {
    color = Color(60, 150, 135),
    model = {"models/eng_fixer/pm_coruscant_eng_fixer.mdl"},
    description = "Lokalny pracownik stoczni.",
    weapons = {"weapon_lvsrepair","weapon_armorkit","weapon_extinguisher","alydus_fortificationbuildertablet"},
    command = "CYWILC",
    max = 2,
    lvl = "global",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "Cywile",
    sortOrder = 3,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(200)
        ply:SetHealth(200)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_CYWILGANG = DarkRP.createJob("Gang Ohnaka",  {
    color = Color(60, 150, 135),
    model = {"models/player/ohanak_gang/pm_pirate_soldier.mdl", "models/player/ohanak_gang/pm_pirate_jiro.mdl", "models/player/ohanak_gang/pm_pirate_craggy.mdl", "models/player/ohanak_gang/pm_pirate_grunt.mdl", "models/player/ohanak_gang/pm_pirate_marauder.mdl"},
    description = "S przebiegli i podstpni, a co najwaniejsze, gupi - Gang Ohnaka, znany rwnie jako Gang Hondo s grup piratw dowodzon przez Hondo Ohnak.",
    weapons = {"arccw_k_dl18", "arccw_k_charriccarbine", "arccw_k_nade_decoy", "arccw_k_nade_shock"},
    command = "Gang",
    max = 4,
    vip = true,
    lvl = "global",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "Cywile",
    sortOrder = 4,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(200)
        ply:SetHealth(200)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_CYWILKOT = DarkRP.createJob("Zygerriaski owca Niewolnikw",  {
    color = Color(60, 150, 135),
    model = {"models/player/zygerrian/zygerrian_soldier.mdl", "models/player/zygerrian/zygerrian_slave_lord.mdl", "models/player/zygerrian/zygerrian_pitboss.mdl", "models/player/zygerrian/zygerrian_cpt.mdl"},
    description = "Niewolnictwo to naturalny porzdek rzeczy. Sabi nie zasuguj na nic wicej, jak tylko klcze przed silnymi, zmuszeni do suenia nam  Zygerrianie to humanoidalny gatunek kotowatych pochodzcy z Zygerrii. Zbudowali potne imperium niewolnicze, ktre zostao zniszczone przez Jedi i Republik. Podczas Wojen Klonw otwarcie wznowili handel niewolnikami i, sprzymierzajc si z Konfederacj Niezalenych Systemw, aktywnie odbudowuj swoje imperium.",
    weapons = {"arccw_k_zerzium", "arccw_k_dc17_stun", "weapon_cuff_elastic", "arccw_k_nade_stun", "arccw_k_nade_smoke"},
    command = "Koty",
    max = 4,
    vip = true,
    lvl = "global",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "Cywile",
    sortOrder = 5,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(200)
        ply:SetHealth(200)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_CYWILE = DarkRP.createJob("Rebeliant",  {
    color = Color(60, 150, 135),
    model = {"models/enforcer/pm_civ_enforcer_costume_male.mdl"},
    description = "Lokalny mieszkaniec sprzeciwiajcy si skorumpowanej wadzy Republiki w galaktyce",
    weapons = {"arccw_k_dc40c"},
    command = "CYWILE",
    max = 2,
    lvl = "global",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "Cywile",
    sortOrder = 6,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(200)
        ply:SetHealth(200)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_CYWILF = DarkRP.createJob("Stra Miasta",  {
    color = Color(60, 150, 135),
    model = {"models/guard/pm_civ_guard_human_female.mdl", "models/guard/pm_civ_guard_human_male.mdl"},
    description = "Paowanie stoczniowcw i pilnowanie porzdku w miecie pynie w twojej krwi.",
    weapons = {"arccw_k_dc17_stun", "weapon_policebaton", "weapon_cuff_elastic"},
    command = "CYWILF",
    max = 1,
    lvl = "global",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "Cywile",
    sortOrder = 7,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(200)
        ply:SetHealth(200)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_CYWILG = DarkRP.createJob("Burmistrz",  {
    color = Color(60, 150, 135),
    model = {"models/noble/pm_civ_noble_human_male.mdl"},
    description = "'Demokratycznie' wybrany przedstawiciel lokalnego miasta penicy swoj 50 kadencj.",
    weapons = {"arccw_k_defender"},
    command = "CYWILG",
    max = 1,
    lvl = "global",
    salary = 10,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false,
    category = "Cywile",
    sortOrder = 8,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(200)
        ply:SetHealth(200)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_CYWILH = DarkRP.createJob("Death Watch",  {
    color = Color(60, 150, 135),
    model = {"models/dw_grunt/pm_deathwatch_grunt.mdl","models/dw_nightowl/pm_deathwatch_nightowl.mdl"},
    description = "Death Watch, znany jako Kyr'tsad w Mando'a, by odamem terrorystw Mandalorian, ktrzy sprzeciwiali si pacyfistycznemu rzdowi Mandalore.",
    weapons = {"mvp_perfecthands", "arccw_k_m45", "arccw_k_westar35_akimbo", "jet_mk1", "weapon_armorkit"},
    command = "CYWILH",
    max = 8,
    lvl = "global",
    salary = 10,
    admin = 0,
    vote = false,
    vip = true,
    wl = true,
    hasLicense = false,
    candemote = false,
    category = "Cywile",
    sortOrder = 8,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(200)
        ply:SetHealth(200)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})

---------------------------------- Prace Prywatne --------------------------------------
TEAM_PJSTORM = DarkRP.createJob("Storm: [DOOM]",  {
    color = Color(4, 67, 19),
    model = {"models/aussiwozzi/cgi/base/doom_demo.mdl"},
    description = "Wierny Klon Demokratycznej Armii Republiki",
    weapons = {"mvp_perfecthands", "arccw_k_z6adv", "masita_dual_dc17", "arccw_k_launcher_rps6", "weapon_armorkit"},
    command = "PJStorm",
    max = 1,
    lvl = "poz_doom",
    salary = 10,
    admin = 0,
    vote = false,
    wl = true,
    hasLicense = false,
    candemote = false,
    category = "Prace Prywatne",
    sortOrder = 1,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(300)
        ply:SetHealth(300)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_PJCRIS = DarkRP.createJob("Cristopher: [104th]",  {
    color = Color(130, 116, 116),
    model = {"models/player/curse/crm/drew/crm_drew.mdl"},
    description = "Klon o niezachwianej odwadze i niezawodnym geniuszu inynieryjnym. Zawsze gotw do dziaania, nie boi si adnego wyzwania. Jego umiejtnoci techniczne s niezrwnane, a precyzyjno i skuteczno w rozwizywaniu problemw nie maj sobie rwnych.",
    weapons = {"mvp_perfecthands", "masita_nt242", "arccw_k_nade_blaststick", "jet_mk5", "masita_westarm5_alpha","arccw_k_nade_flashbang","arccw_k_nade_c25","arccw_k_nade_bacta","masita_repshield","arccw_k_nade_smoke","arccw_sops_galactic_emprifle","weapon_lvsrepair","weapon_armorkit","weapon_extinguisher_infinite","weapon_bactainjector","alydus_fortificationbuildertablet"},
    command = "PJCristopher",
    max = 1,
    lvl = "poz_104",
    salary = 10,
    admin = 0,
    vote = false,
    wl = true,
    hasLicense = false,
    candemote = false,
    category = "Prace Prywatne",
    sortOrder = 2,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(300)
        ply:SetHealth(300)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_PJHOWL = DarkRP.createJob("Howl: [CG]",  {
    color = Color(170, 50, 50),
    model = {"models/player/gingers_captain_kagi/gingers_captain_kagi.mdl"},
    description = "Operator Ognia CG",
    weapons = {"arccw_k_dc15s_stun","arccw_k_dc17_stun","weapon_cuff_elastic","weapon_policebaton", "weapon_armorkit","arccw_k_sb2","arccw_sops_republic_773firepuncher","arccw_k_dc17s_dual"},
    command = "PJHowl",
    max = 1,
    lvl = "poz_cg",
    salary = 10,
    admin = 0,
    vote = false,
    wl = true,
    hasLicense = false,
    candemote = false,
    category = "Prace Prywatne",
    sortOrder = 3,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(300)
        ply:SetHealth(300)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_PJMATEUSZ = DarkRP.createJob("Mini Adam: [Jedi]",  {
    color = Color(170, 50, 50),
    model = {"models/player/plo/cgi/jedi/ewok_luciuss.mdl"},
    description = "Wierny Jedi",
    weapons = {"weapon_lscs"},
    command = "PJMateusz",
    max = 1,
    lvl = "poz_jedi",
    salary = 10,
    admin = 0,
    jedi = true,
    vote = false,
    wl = true,
    hasLicense = false,
    candemote = false,
    category = "Prace Prywatne",
    sortOrder = 4,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(1500)
        ply:SetHealth(1500)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_PJSNIPERGHOST = DarkRP.createJob("Yue Atukirina: [Jedi]",  {
    color = Color(170, 50, 50),
    model = {"models/player/jedi/nyssa_delacor.mdl"},
    description = "Pochodzca z planety Kalevala oraz wraliwa na moc Yue ocalona z niewoli piratw pod dowdctwem Honda Ohnaki",
    weapons = {"weapon_lscs"},
    command = "PJsniperghost",
    max = 1,
    lvl = "poz_jedi",
    salary = 10,
    admin = 0,
    jedi = true,
    vote = false,
    wl = true,
    hasLicense = false,
    candemote = false,
    category = "Prace Prywatne",
    sortOrder = 5,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(1500)
        ply:SetHealth(1500)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_PJANTO = DarkRP.createJob("2133 Ator: [104th]",  {
    color = Color(130, 116, 116),
    model = {"models/aussiwozzi/cgi/base/104th_trooper.mdl","models/aussiwozzi/cgi/base/104th_ARF.mdl"},
    description = "Wierny klon.",
    weapons = {"mvp_perfecthands","arccw_k_launcher_rps6","arccw_k_dc15s_grenadier","arccw_k_dc17","weapon_armorkit"},
    command = "PJanto",
    max = 1,
    lvl = "poz_104",
    salary = 10,
    admin = 0,
    vote = false,
    wl = true,
    hasLicense = false,
    candemote = false,
    category = "Prace Prywatne",
    sortOrder = 6,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(300)
        ply:SetHealth(300)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_PJPLACEK = DarkRP.createJob("Plackowska Jawa [Jedi]",  {
    color = Color(130, 116, 116),
    model = {"models/jajoff/sw/blizz.mdl","models/jajoff/sw/jawa.mdl","models/jajoff/sw/jawa02.mdl","models/jajoff/sw/jawachef.mdl","models/jajoff/sw/jawacustom.mdl","models/jajoff/sw/jawamechanic.mdl","models/jajoff/sw/jawamwarrior.mdl"},
    description = "May Mody Prawdziwy Zomiarz ",
    weapons = {"weapon_lscs"},
    command = "PJPlacek",
    max = 1,
    lvl = "poz_jedi",
    salary = 10,
    admin = 0,
    modelScale = 0.6,
    jedi = true,
    vote = false,
    wl = true,
    hasLicense = false,
    candemote = false,
    category = "Prace Prywatne",
    sortOrder = 7,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(1500)
        ply:SetHealth(1500)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
        timer.Simple(1,function()
            ply:SetViewOffset(Vector(0,0,64/2))
            ply:SetViewOffsetDucked(Vector(0,0,28/2))
        end)
    end
})
TEAM_PJIGORSCP = DarkRP.createJob("Biay Jedi: [Jedi]",  {
    color = Color(170, 50, 50),
    model = {"models/jedigrey/jedigrey.mdl"},
    description = "Szuka prawdy",
    weapons = {"weapon_lscs"},
    command = "PJigorscp",
    max = 1,
    lvl = "poz_jedi",
    salary = 10,
    admin = 0,
    jedi = true,
    vote = false,
    wl = true,
    hasLicense = false,
    candemote = false,
    category = "Prace Prywatne",
    sortOrder = 8,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(1500)
        ply:SetHealth(1500)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})
TEAM_PJMAJONEZ = DarkRP.createJob("Kellana Rin: [Jedi]",  {
    color = Color(170, 50, 50),
    model = {"models/player/atlas/starwars/atlas.mdl"},
    description = "Wierny Jedi walczcy zawsze do koca ",
    weapons = {"weapon_lscs"},
    command = "PJMajonez",
    max = 1,
    lvl = "poz_jedi",
    salary = 10,
    admin = 0,
    jedi = true,
    vote = false,
    wl = true,
    hasLicense = false,
    candemote = false,
    category = "Prace Prywatne",
    sortOrder = 9,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(1500)
        ply:SetHealth(1500)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})

TEAM_PJMATIUS = DarkRP.createJob("[PJ] Matius",  {
    color = Color(170, 50, 50),
    model = {"models/drm/wuthering_waves/zani/zani.mdl"},
    description = "Marek owca Szparek",
    weapons = {"weapon_lscs", "masita_dc15a_heavy"},
    command = "PJMatius",
    max = 1,
    lvl = "global",
    salary = 10,
    admin = 0,
    jedi = true,
    vote = false,
    wl = true,
    hasLicense = false,
    candemote = false,
    category = "Prace Prywatne",
    sortOrder = 10,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(1500)
        ply:SetHealth(1500)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})

TEAM_PJSLEEPY = DarkRP.createJob("Kuba [Jedi]",  {
    color = Color(130, 116, 116),
    model = {"models/player/griffbo/JKRevanGOH.mdl"},
    description = "urodzony w bogatej rodzinie ale brakowao mu przyjaci. w zakonie jedi pozna padawana Hadesa i zostali najlepszymi przyjacimi.  Zosta pokonany przez bardzo silnego sitha ,Znikn na 4 lata wrci silniejszy i pokona tego sitha co zagraa ycie innym jedi.",
    weapons = {"weapon_lscs"},
    command = "PJSleepy",
    max = 1,
    lvl = "poz_jedi",
    salary = 10,
    admin = 0,
    jedi = true,
    vote = false,
    wl = true,
    hasLicense = false,
    candemote = false,
    category = "Prace Prywatne",
    sortOrder = 11,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(1500)
        ply:SetHealth(1500)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})

TEAM_PJGUDIS = DarkRP.createJob("Kayn MoeLester [CT]",  {
    color = Color(130, 116, 116),
    model = {"models/wf/arfeagle/arfeagle.mdl"},
    description = "dowiadczony onierz Republiki, ktry posiada umiejtnoci w eksploracji wrogiego terytorium oraz precyzyjnym uyciu materiaw wybuchowych. Charakteryzuje si niestandardowym, czarnym pancerzem , co odrnia go od standardowych klonw.",
    weapons = {"arccw_k_dc17sa_dual","arccw_k_nade_thermalimploder","jet_mk5","masita_valken38x"," arccw_k_dc15s","arccw_k_nade_decoy","arccw_k_nade_smoke"},
    command = "PJGudis",
    max = 1,
    lvl = "global",
    salary = 10,
    admin = 0,
    vote = false,
    wl = true,
    hasLicense = false,
    candemote = false,
    category = "Prace Prywatne",
    sortOrder = 12,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(300)
        ply:SetHealth(300)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})

TEAM_PJBART = DarkRP.createJob("Pawlik [104th]",  {
    color = Color(130, 116, 116),
    model = {"models/artel/assasin_cgi/assasin_cgi.mdl"},
    description = "onierz do zada specjalnych z oddziau 104th ktry dysponuje duo wiedz w walce, zwiadzie, kamuflau oraz specjalizacji broni. Nie boi si niczego a jego opancerzenie zostao opracowane wraz z Mandolorianami gdzie wczeniej zosta u nich wyszkolony, lecz po czasie wrci do Wielkiej Armii Republiki. Jednostka specjalna 104th.",
    weapons = {"arccw_k_nade_flashbang","arccw_k_nade_impact","arccw_k_nade_thermite","arccw_k_dc17s_dual","arccw_k_westarm5","arccw_k_launcher_rps6", "weapon_armorkit","arccw_sops_republic_t702"},
    command = "PJBartek",
    max = 1,
    lvl = "poz_104",
    salary = 10,
    admin = 0,
    vote = false,
    wl = true,
    hasLicense = false,
    candemote = false,
    category = "Prace Prywatne",
    sortOrder = 13,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(300)
        ply:SetHealth(300)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})

TEAM_PJMEX = DarkRP.createJob("[PJ] Mexico",  {
    color = Color(200, 200, 200),
    model = {"models/player/mexicano/kiryu_jedi.mdl"},
    description = "Free Mexico",
    weapons = {"weapon_lscs", "arccw_k_caradune"},
    command = "PJMx",
    max = 1,
    lvl = "poz_jedi",
    salary = 10,
    admin = 0,
    vote = false,
    wl = true,
	jedi = true,
    hasLicense = false,
    candemote = false,
    category = "Prace Prywatne",
    sortOrder = 14,
    PlayerSpawn = function(ply)
        ply:SetMaxHealth(1500)
        ply:SetHealth(1500)
        ply:SetArmor(100)
        ply:SetMaxArmor(100)
        ply:SetWalkSpeed(160)
        ply:SetRunSpeed(240)
    end
})

GAMEMODE.DefaultTeam = TEAM_KADET
--PATH addons/!jobs/lua/darkrp_customthings/shipments.lua:
return gluapack()()
--PATH addons/!jobs/lua/darkrp_customthings/vehicles.lua:
--[[---------------------------------------------------------------------------
DarkRP custom vehicles
---------------------------------------------------------------------------

This file contains your custom vehicles.
This file should also contain vehicles from DarkRP that you edited.

For examples and explanation please visit this wiki page:
https://darkrp.miraheze.org/wiki/DarkRP:Vehicles

If you want to keep the vehicle code and not comment it out you can add a vehicle to the "DarkRP.disabledDefaults["vehicles"]" section
in the disabled_defaults.lua in the "darkrp_config" folder

Add vehicles under the following line:
---------------------------------------------------------------------------]]

--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/shared.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/cl_customize_ui.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/cl_laser.lua:
local defaulttracemat = Material("arc9/laser2")
local defaultflaremat = Material("sprites/light_glow02_add", "mips smooth")
local lasercolorred = Color(255, 0, 0)
local lasercolor200 = Color(200, 200, 200)

function SWEP:DrawLaser(pos, dir, atttbl, behav)
    behav = behav or false
    local strength = atttbl.LaserStrength or 1
    local flaremat = atttbl.LaserFlareMat or defaultflaremat
    local lasermat = atttbl.LaserTraceMat or defaulttracemat
    local owner = self:GetOwner()

    local dist = 5000

    local tr = util.TraceLine({
        start = pos,
        endpos = pos + (dir * 15000),
        mask = MASK_SHOT,
        filter = owner
    })

    if tr.StartSolid then return end

    local width = math.Rand(0.1, 0.5) * strength

    local hit = tr.Hit
    local hitpos = tr.HitPos

    if tr.HitSky then
        hit = false
        hitpos = pos + (dir * dist)
    end

    local truedist = math.min((tr.Fraction or 1) * 15000, dist)
    local fraction = truedist / dist

    local laspos = pos + (dir * truedist)

    if self.LaserAlwaysOnTargetInPeek and owner == LocalPlayer() then
        local sightamount = self:GetSightAmount()
        if sightamount > 0 and self.Peeking then

            local fuckingreloadprocess
            local fuckingreloadprocessinfluence = 1

            if self:GetReloading() then
                if !self:GetProcessedValue("ShotgunReload", true) then
                    fuckingreloadprocess = math.Clamp((self:GetReloadFinishTime() - CurTime()) / (self.ReloadTime * self:GetAnimationTime(self:GetIKAnimation())), 0, 1)

                    if fuckingreloadprocess <= 0.2 then
                        fuckingreloadprocessinfluence = 1 - (fuckingreloadprocess * 5)
                    elseif fuckingreloadprocess >= 0.9 then
                        fuckingreloadprocessinfluence = (fuckingreloadprocess - 0.9) * 10
                    else
                        fuckingreloadprocessinfluence = 0
                    end
                end
            end

            local trrr = util.TraceLine({
                start = self:GetShootPos(),
                endpos = self:GetShootPos() + (self:GetShootDir():Forward() * 15000),
                mask = MASK_SHOT,
                filter = owner
            })

            local realhitpos = trrr.HitPos
            laspos = LerpVector(sightamount*fuckingreloadprocessinfluence, laspos, realhitpos)
            hitpos = LerpVector(sightamount*fuckingreloadprocessinfluence, hitpos, realhitpos)
        end
    end

    local color = atttbl.LaserColor or lasercolorred
	local colorplayer = !owner:IsNPC() and owner:GetWeaponColor():ToColor()

	if (atttbl.LaserColorPlayer or atttbl.LaserPlayerColor) then color = colorplayer or color end

    if !behav then
        render.SetMaterial(lasermat)
        render.DrawBeam(pos, laspos, width * 0.2, 0, fraction, lasercolor200)
        render.DrawBeam(pos, laspos, width, 0, fraction, color)
    end

    if hit then
        local rad = math.Rand(4, 6) * strength * math.max(fraction * 7, 1)
        local dotcolor = color
        local whitedotcolor = lasercolor200

        dotcolor.a = 255 - math.min(fraction * 30, 250)
        whitedotcolor.a = 255 - math.min(fraction * 25, 250)

        render.SetMaterial(flaremat)

        render.DrawSprite(hitpos, rad, rad, dotcolor)
        render.DrawSprite(hitpos, rad * 0.4, rad * 0.3, whitedotcolor)
    end
end

function SWEP:DrawLasers(wm, behav)
    local owner = self:GetOwner()
    if !wm and !IsValid(owner) then return end
    if !wm and owner:IsNPC() then return end

    local mdl = self.VModel

    if wm then
        mdl = self.WModel
    end

    if !mdl then
        self:KillModel()
        self:SetupModel(wm)

        mdl = self.VModel

        if wm then
            mdl = self.WModel
        end
    end

    for _, model in ipairs(mdl) do
        local slottbl = model.slottbl
        local atttbl = self:GetFinalAttTable(slottbl)

        if atttbl.Laser then
            local pos, ang = self:GetAttachmentPos(slottbl, wm, false)
            model:SetPos(pos)
            model:SetAngles(ang)

            local a

            if atttbl.LaserAttachment then
                a = model:GetAttachment(atttbl.LaserAttachment)
            else
                a = {
                    Pos = model:GetPos(),
                    Ang = model:GetAngles()
                }

                a.Ang:RotateAroundAxis(a.Ang:Up(), -90)
            end

            if !a then return end

            local lasercorrectionangle = model.LaserCorrectionAngle
            local lasang = a.Ang

            if lasercorrectionangle then
                local up, right, forward = lasang:Up(), lasang:Right(), lasang:Forward()

                lasang:RotateAroundAxis(up, lasercorrectionangle.p)
                lasang:RotateAroundAxis(right, lasercorrectionangle.y)
                lasang:RotateAroundAxis(forward, lasercorrectionangle.r)
            end

			local color = atttbl.LaserColor or lasercolorred
			local colorplayer = !owner:IsNPC() and owner:GetWeaponColor():ToColor()

			if (atttbl.LaserColorPlayer or atttbl.LaserPlayerColor) then color = colorplayer or color end
			
            self:DrawLightFlare(a.Pos, lasang, color, wm and 5 or 10, (slottbl.Address or 0) + 69, !wm)

            if !wm or owner == LocalPlayer() or wm and owner:IsNPC() then
                if behav then
                    self:DrawLaser(a.Pos, self:GetShootDir():Forward(), atttbl, behav)
                else
                    self:DrawLaser(a.Pos, -lasang:Right(), atttbl, behav)
                end
            else
                self:DrawLaser(a.Pos, self:GetShootDir():Forward(), atttbl, behav)
            end
        end
    end
end
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/cl_sight_autosolve.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/cl_vm.lua:
local vignette = Material("arc9/bgvignette.png", "mips smooth")
-- local vignette2 = Material("arc9/bgvignette2.png", "mips smooth")


local adsblur = Material("pp/arc9/adsblur")
local function arc9toytown(amount) -- cool ass blur
    if amount > 0 then
        local scrw, scrh = ScrW(), ScrH()
        cam.Start2D()
            surface.SetMaterial(adsblur)
            surface.SetDrawColor(255, 255, 255, 255)

            for i = 1, 5 * amount do -- 5 looking pretty cool
                render.CopyRenderTargetToTexture(render.GetScreenEffectTexture())
                surface.DrawTexturedRect(scrw*.5-scrh*.5, scrh*.58, scrh, scrh*0.42)
            end
        cam.End2D()
    end
end

local bluramt = 0
-- please cache fucking convars
local arc9_fx_rtblur = GetConVar("arc9_fx_rtblur")
local arc9_fx_animblur = GetConVar("arc9_fx_animblur")
local arc9_fx_reloadblur = GetConVar("arc9_fx_reloadblur")
local arc9_cust_blur = GetConVar("arc9_cust_blur")
local arc9_hud_darkmode = GetConVar("arc9_hud_darkmode")
local arc9_dev_greenscreen = GetConVar("arc9_dev_greenscreen")
local arc9_cust_light = GetConVar("arc9_cust_light")
local arc9_cust_light_brightness = GetConVar("arc9_cust_light_brightness")
local arc9_dev_benchgun = GetConVar("arc9_dev_benchgun")
local arc9_fx_adsblur = GetConVar("arc9_fx_adsblur")


function SWEP:PreDrawViewModel()
    if ARC9.RTScopeRender then -- basically a copy of code in that func for rt barrels but without useless stuff and bad stuff, and also offset of cam in scope
        self:DoBodygroups(false)
        local vm = self:GetVM()
        if self.HasSightsPoseparam then
            vm:SetPoseParameter("sights", self:GetSightAmount())
        end
        self:SetFiremodePose()
        vm:InvalidateBoneCache()

        local vmpso, vmagn, spso = self.LastViewModelPos, self.LastViewModelAng, self:GetSightPositions()
        
        vmpso = vmpso - vmagn:Forward() * (spso.y - 15) -- i sure do hope fixed number will be good (clueless)
        vmpso = vmpso - vmagn:Up() * spso.z
        vmpso = vmpso - vmagn:Right() * spso.x

        cam.Start3D(vmpso, nil, ARC9.RTScopeRenderFOV * 0.85, nil, nil, nil, nil, 3, 100040)

        return
    end

    if ARC9.PresetCam then
        self:DoBodygroups(false)
        return
    end

    local getsights = self:GetSight()
    local sightamount = self:GetSightAmount()

    local blurtarget = 0

    local blurenable = arc9_fx_rtblur:GetBool()

    local shouldrtblur = sightamount > 0 and blurenable and !self.Peeking and getsights.atttbl and getsights.atttbl.RTScope and !getsights.Disassociate and !getsights.atttbl.RTCollimator and !getsights.atttbl.RTScopeNoBlur

    if shouldrtblur then
        blurtarget = 2 * sightamount
    end

    if (arc9_fx_reloadblur:GetBool() and self:GetReloading()) or (arc9_fx_animblur:GetBool() and self:GetReadyTime() >= CurTime()) then
        blurtarget = 1.5
        shouldrtblur = true
    end

    local custdelta = self.CustomizeDelta

    if custdelta > 0 then
        if arc9_cust_blur:GetBool() then
            blurtarget = 5 * custdelta
        end

        local scrw, scrh = ScrW(), ScrH()

        cam.Start2D()
            surface.SetDrawColor(15, 15, 15, 180 * custdelta)
            surface.DrawRect(0, 0, scrw, scrh)
            surface.SetDrawColor(0, 0, 0, 255 * custdelta)
            if !arc9_hud_darkmode:GetBool() then
                surface.SetMaterial(vignette)
                surface.DrawTexturedRect(0, 0, scrw, scrh)
            end

            if arc9_dev_greenscreen:GetBool() then
                -- print(GetConVar("mat_bloom_scalefactor_scalar"):SetFloat())
                surface.SetDrawColor(0, 255, 0, 255 * custdelta)
                surface.DrawRect(0, 0, scrw, scrh)
            end
        cam.End2D()
    end

    if (shouldrtblur and blurenable) or (custdelta > 0 and blurtarget > 0) then
        DrawBokehDOF(bluramt, 1, 0)
    end

    bluramt = math.Approach(bluramt, blurtarget, FrameTime() * 10)

    if arc9_cust_light:GetBool() and self:GetCustomize() then
        -- render.SuppressEngineLighting(true)
        -- render.ResetModelLighting(0.6, 0.6, 0.6)
        -- render.SetModelLighting(BOX_TOP, 4, 4, 4)
        local light = DynamicLight(self:EntIndex(), true)
        light.pos = EyePos() + (EyeAngles():Up() * 12)
        light.r = 255
        light.g = 255
        light.b = 255
        light.brightness = 0.2 * (arc9_cust_light_brightness:GetFloat())
        light.Decay = 1000
        light.Size = 500
        light.DieTime = CurTime() + 0.1
    -- else
    --     render.SuppressEngineLighting(false)
    --     render.ResetModelLighting(1,1,1)
    end

    self:DoPoseParams()
    self:DoBodygroups(false)

    local bipodamount = self:GetBipodAmount()
    local vm = self:GetVM()

    if self.HasSightsPoseparam then
        vm:SetPoseParameter("sights", math.max(sightamount, bipodamount, custdelta))
    end

    local bonemods = self:GetValue("BoneMods")

    if bonemods then for _, k in pairs(bonemods) do
        local boneindex = vm:LookupBone(i)

        if !boneindex then continue end

        vm:ManipulateBonePosition(boneindex, k.pos or vector_origin)
        vm:ManipulateBoneAngles(boneindex, k.ang or angle_zero)
        vm:ManipulateBoneScale(boneindex, k.scale or vector_origin)
    end end
    

    local vmfov = self:GetViewModelFOV()

    self.ViewModelFOV = vmfov

    if !arc9_dev_benchgun:GetBool() then
        cam.Start3D(nil, nil, self:WidescreenFix(vmfov), nil, nil, nil, nil, 0.5, 10000)
    end

    -- self:DrawCustomModel(true, EyePos() + EyeAngles():Forward() * 16, EyeAngles())

    vm:SetSubMaterial()

    for ind = 0, 31 do
        local val = self:GetProcessedValue("SubMaterial" .. ind, true)
        if val then
            vm:SetSubMaterial(ind, val)
        end
    end

    self.RenderingRTScope = false 
    if self:GetHolsterTime() < CurTime() and self.RTScope and sightamount > 0 then
        self:DoRTScope(vm, self:GetTable(), sightamount > 0)
    end

    vm:SetMaterial(self:GetProcessedValue("Material", true))

    cam.IgnoreZ(true)

    self:SetFiremodePose()
    
    if self.HasSightsPoseparam then
        vm:SetPoseParameter("sights", math.max(sightamount, bipodamount, custdelta))
    end

    vm:InvalidateBoneCache()
    
    if sightamount > 0.75 and getsights.FlatScope and !getsights.FlatScopeKeepVM then
        render.SetBlend(0)
    end
end

function SWEP:ViewModelDrawn()
    self:DrawCustomModel(false)
    cam.IgnoreZ(true)
    self:DoRHIK()
    if ARC9.RTScopeRender then return end
    self:PreDrawThirdArm()
    self:DrawFlashlightsVM()

    self:DrawLasers(false)
    self:GetVM():SetMaterial("")
	for ind = 0, 31 do
		self:GetVM():SetSubMaterial(ind, "")
	end
end

function SWEP:PostDrawViewModel()
    local inrt = ARC9.RTScopeRender

    local newmzpcfs = {}

    for _, pcf in ipairs(self.MuzzPCFs) do
        if IsValid(pcf) then
            pcf:Render()
            table.insert(newmzpcfs, pcf)
        end
    end

    if !inrt then self.MuzzPCFs = newmzpcfs end

    cam.Start3D()
        cam.IgnoreZ(false)
        local newpcfs = {}

        for _, pcf in ipairs(self.PCFs) do
            if IsValid(pcf) then
                pcf:Render()
                table.insert(newpcfs, pcf)
            end
        end

        if !inrt then self.PCFs = newpcfs end

        local newfx = {}

        for _, fx in ipairs(self.ActiveEffects) do
            if IsValid(fx) then
                if !fx.VMContext then continue end
                fx:DrawModel()
                table.insert(newfx, fx)
            end
        end

        if !inrt then self.ActiveEffects = newfx end
    cam.End3D()

    if ARC9.PresetCam then return end

    cam.IgnoreZ(false)
    render.SetBlend(1)

    if !arc9_dev_benchgun:GetBool() then
        cam.End3D()
    end

    if inrt then return end

    self.RenderingHolosight = false
    cam.Start3D(nil, nil, self:WidescreenFix(self:GetViewModelFOV()), nil, nil, nil, nil, 1, 10000)
    if self.VModel then
        for _, model in ipairs(self.VModel) do
            local slottbl = model.slottbl
            local atttbl = self:GetFinalAttTable(slottbl)

            if atttbl.HoloSight then
                -- cam.IgnoreZ(true)
                self:DoHolosight(model, atttbl)
                -- cam.IgnoreZ(false)
            end
        end
    end
    cam.End3D()

    if arc9_fx_adsblur:GetBool() and self:GetSight().Blur != false and !self.Peeking then arc9toytown(self:GetSightAmount()) end -- cool ass blur
    -- render.UpdateFullScreenDepthTexture()
end
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/cl_vmposition.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/sh_bipod.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/sh_blindfire.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/sh_ccip.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/sh_ccip.lua:
local ARC9_bullet_drag = GetConVar("ARC9_bullet_drag")
local ARC9_bullet_gravity = GetConVar("ARC9_bullet_gravity")

function SWEP:GetCCIP(pos, ang)
    -- get calculated point of impact

    local sp, sa = self:GetShootPos()

    pos = pos or sp
    ang = ang or sa

    local v = self:GetProcessedValue("PhysBulletMuzzleVelocity", true)
    local g = self:GetProcessedValue("PhysBulletGravity", true)
    local d = self:GetProcessedValue("PhysBulletDrag", true)

    local vel = ang:Forward() * v
    local maxiter = 100
    local timestep = 1 / 15

    for i = 1, maxiter do
        local dir = vel:GetNormalized()
        local spd = vel:Length() * timestep
        local drag = d * spd * spd * (1 / 150000) * ARC9_bullet_drag:GetFloat()
        local gravity = timestep * g * ARC9_bullet_gravity:GetFloat() * 600

        if spd <= 0.001 then return nil end

        local newpos = pos + (vel * timestep)
        local newvel = vel - (dir * drag) - Vector(0, 0, gravity)

        local tr = util.TraceLine({
            start = pos,
            endpos = newpos,
            filter = self:GetOwner(),
            mask = MASK_SHOT
        })

        if tr.HitSky then
            return nil
        elseif tr.Hit then
            return tr, i * timestep
        else
            pos = newpos
            vel = newvel
        end
    end

    return nil
end
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/sh_inspect.lua:
function SWEP:ThinkInspect()
	if self.NoInspect then return end
    if self:StillWaiting() or self:GetInSights() or self:GetBipod() or self:GetReloading() then return end
    if self.NextUBGLSwitch and self.NextUBGLSwitch > CurTime() then return end
    if self:GetUBGL() and !self:HasAnimation("inspect_ubgl") then return end

    local owner = self:GetOwner()
    
    -- self:PlayAnimation("inspect", 1, true)
    if (owner:KeyDown(IN_USE) and owner:KeyDown(IN_RELOAD)) or owner:KeyDown(ARC9.IN_INSPECT) then
        if !self:HasAnimation("enter_inspect") then
            self:PlayAnimation("inspect", 1, true)
            return
        end

        if self:GetInspecting() then
            self:PlayAnimation("idle_inspect", 1, true)
        else
            self:SetInspecting(true)
            self:PlayAnimation("enter_inspect", 1, true)
        end
    elseif self:GetInspecting() then
        self:SetInspecting(false)
        self:PlayAnimation("exit_inspect", 1, true)
    end
end
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/sh_melee.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/sh_melee.lua:
local bodyDamageCancel = GetConVar("arc9_mod_bodydamagecancel")
local cancelmults = ARC9.CancelMultipliers[engine.ActiveGamemode()] or ARC9.CancelMultipliers[1]

local vmaxs, vmins = Vector(2, 2, 2), Vector(-2, -2, -2)

function SWEP:MeleeAttack(bypass, bash2)
    if !bypass then
		if !self:GetProcessedValue("BashCancelsReload", true) and self:StillWaiting() then return end
        if !self:GetProcessedValue("BashWhileSprint", true) and self:SprintLock() then return end
    end

	self:CancelReload()
	
    self:CallOnClient("CallNonTPIKAnim", "AnimMelee")

    local soundtab1 = {
        name = "meleeswing",
        sound = self:RandomChoice(self:GetProcessedValue("MeleeSwingSound", true)),
        channel = ARC9.CHAN_MELEE
    }

    self:PlayTranslatedSound(soundtab1)

    local owner = self:GetOwner()
    local backstab = false

    local prefix = "Bash"

    if bash2 then
        prefix = "Bash2"
    end

    local range = self:GetProcessedValue(prefix .. "LungeRange")

    local tr = util.TraceHull({
        start = owner:EyePos(),
        endpos = owner:EyePos() + (owner:GetAimVector() * range),
        mask = MASK_SHOT,
        filter = {owner, self:GetShieldEntity(), self.ShieldProp},
        maxs = vmaxs,
        mins = vmins
    })

    if tr.Hit then
        if tr.Entity:IsPlayer() or tr.Entity:IsNPC() or tr.Entity:IsNextBot() then
            self:SetLungeEntity(tr.Entity)

            local dot = owner:EyeAngles():Forward():Dot(tr.Entity:EyeAngles():Forward())

            backstab = dot > 0
        end
    end

    if backstab then
        prefix = "Backstab"
    end

	local bashspeed = self:GetProcessedValue("BashSpeed")

    self:SetFreeAimAngle(angle_zero)

    self:SetLastMeleeTime(CurTime())

    self:SetNextPrimaryFire(CurTime() + (self:GetProcessedValue("Pre" .. prefix .. "Time") / bashspeed) + (self:GetProcessedValue("Post" .. prefix .. "Time") / bashspeed))

	self.SetNextAiming = CurTime() + (self:GetProcessedValue("Pre" .. prefix .. "Time") / bashspeed) + (self:GetProcessedValue("Post" .. prefix .. "Time") / bashspeed)

    self:SetBash2(bash2)

    if backstab and self:HasAnimation("backstab") then
        self:PlayAnimation("backstab", 1 / bashspeed, false)
    elseif bash2 and self:HasAnimation("bash2") then
        self:PlayAnimation("bash2", 1 / bashspeed, false)
    elseif self:HasAnimation("bash") then
        self:PlayAnimation("bash", 1 / bashspeed, false)
    else
        if game.SinglePlayer() and SERVER then
            self:CallOnClient("MeleeAttack", "true")
        elseif CLIENT then
            self:PlayThirdArmAnim(self:GetProcessedValue("BashThirdArmAnimation", true), false)

            if game.SinglePlayer() and CLIENT then
                return
            end
        end
    end

    if !backstab then
        self:SetInMeleeAttack(true)
    else
        self:MeleeAttackShoot(bash2, true)
    end

	self.RecentMelee = true

end

local vmaxs2, vmins2 = Vector(2, 2, 2), Vector(-2, -2, -2)

function SWEP:MeleeAttackShoot(bash2, backstab)
    local owner = self:GetOwner()

    local prefix = "Bash"

    if bash2 then
        prefix = "Bash2"
    end

    if backstab then
        prefix = "Backstab"
    end

    local tr = util.TraceHull({
        start = owner:EyePos(),
        endpos = owner:EyePos() + (owner:EyeAngles():Forward() * self:GetProcessedValue(prefix .. "Range")),
        mask = MASK_SHOT + 8,
        filter = {owner, self:GetShieldEntity(), self.ShieldProp},
        maxs = vmaxs2,
        mins = vmins2
    })

    self:RunHook("Hook_Bash", tr)

    if tr.Hit then
        if tr.Entity:IsPlayer() or tr.Entity:IsNPC() or tr.Entity:IsNextBot() then
            if backstab then
                local soundtab = {
                    name = "backstab",
                    sound = self:RandomChoice(self:GetProcessedValue("BackstabSound", true)),
                    channel = ARC9.CHAN_MELEE
                }

                self:PlayTranslatedSound(soundtab)
            else
                local soundtab = {
                    name = "meleehit",
                    sound = self:RandomChoice(self:GetProcessedValue("MeleeHitSound", true)),
                    channel = ARC9.CHAN_MELEE
                }

                self:PlayTranslatedSound(soundtab)
            end

            if IsFirstTimePredicted() then
                local fx = EffectData()
                fx:SetStart(tr.StartPos)
                fx:SetOrigin(tr.HitPos)
                fx:SetEntity(tr.Entity)
                fx:SetSurfaceProp(tr.SurfaceProps)
                fx:SetHitBox(tr.HitBox)
                util.Effect("BloodImpact", fx, true)
            end
        else
            local soundtab1 = {
                name = "meleehitwall",
                sound = self:RandomChoice(self:GetProcessedValue("MeleeHitWallSound", true)),
                channel = ARC9.CHAN_MELEE
            }

            self:PlayTranslatedSound(soundtab1)

            util.Decal(self:GetProcessedValue(prefix .. "Decal"), tr.HitPos + (tr.HitNormal * 8), tr.HitPos - (tr.HitNormal * 8), owner)

            if self:GetProcessedValue(prefix .. "Impact") and IsFirstTimePredicted() then
                local fx = EffectData()
                fx:SetStart(tr.StartPos)
                fx:SetOrigin(tr.HitPos)
                fx:SetEntity(tr.Entity)
                fx:SetSurfaceProp(tr.SurfaceProps)
                fx:SetHitBox(tr.HitBox)
                util.Effect("Impact", fx, true)
            end
        end

        if self:HasAnimation("impact") then
            self:PlayAnimation(bash2 and "impact2" or "impact", 1, false)
        end

        if SERVER then
            local dmg = DamageInfo()

            dmg:SetDamage(self:GetProcessedValue(prefix .. "Damage"))
            dmg:SetDamageForce(owner:GetAimVector() * 16000)
            dmg:SetDamagePosition(tr.HitPos)
            dmg:SetDamageType(self:GetProcessedValue(prefix .. "DamageType"))
            dmg:SetAttacker(owner)
            dmg:SetInflictor(self)

            local data = {tr = tr, dmg = dmg}
            self:RunHook("Hook_BashHit", data)

            -- do not need to worry about limb damage because hull traces only returns generic hitgroup
            tr.Entity:DispatchTraceAttack(dmg, tr) -- hits breakable glass surfaces, unlike TakeDamageInfo
        end
    end

    self:SetInMeleeAttack(false)
    self:SetLungeEntity(NULL)
end

local PlayerKeyDown = FindMetaTable("Player").KeyDown

function SWEP:ThinkMelee()
	-- if self:StillWaiting() then return end
	local owner = self:GetOwner()
	local m1 = PlayerKeyDown(owner, IN_ATTACK)
	local m2 = PlayerKeyDown(owner, IN_ATTACK2)
	local marc = owner:KeyPressed(ARC9.IN_MELEE)
    
    if !(m1 or m2 or marc) and !self:GetInMeleeAttack() then return end

    if !self.ShootWhileSprint and self:GetIsSprinting() then return end

    local bashsped = self:GetProcessedValue("BashSpeed", true)

    local prebash = self:GetProcessedValue("PreBashTime", true) / bashsped
	local b2 = false

    if self:GetBash2() and self:GetProcessedValue("SecondaryBash", true) then
        prebash = self:GetProcessedValue("PreBash2Time", true) / bashsped
    end

    if !self:GetGrenadePrimed() then
		if m2 then b2 = true else b2 = false end
		
		waituntilbashagain = self:GetLastMeleeTime() + prebash + self:GetProcessedValue("PostBashTime", true) <= CurTime()
		
        if self:GetProcessedValue("PrimaryBash", true) and m1 and waituntilbashagain then
			if self:GetSafe() then
				self:ToggleSafety(false)
			else
				self:MeleeAttack(nil, b2)
			end
        end

        if self:GetProcessedValue("SecondaryBash", true) and m2 and waituntilbashagain then
            if self:GetSafe() then
				self:ToggleSafety(false)
			else
				self:MeleeAttack(nil, b2)
			end
        end

        if self:GetProcessedValue("Bash", true) and marc and !self:GetInSights() and waituntilbashagain then
            if self:GetSafe() then
				self:ToggleSafety(false)
			else
				self:MeleeAttack()
			end
        end

    end

    if self:GetInMeleeAttack() and self:GetLastMeleeTime() + prebash <= CurTime() then
        self:MeleeAttackShoot(self:GetBash2(), false)
    end
end
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/weapons/arc9_base/sh_subatts.lua:
SWEP.AttachmentAddresses = {}
SWEP.ElementTablesCache = nil

function SWEP:LocateSlotFromAddress(address)
    return self.AttachmentAddresses[address]
end

function SWEP:BuildAttachmentAddresses()
    self.AttachmentAddresses = {}

    for c, i in ipairs(self:GetSubSlotList()) do
        i.Address = c

        self.AttachmentAddresses[c] = i
    end

    for _, i in ipairs(self.Attachments) do
        self:BuildParentAddresses(i)
    end
end

function SWEP:BuildParentAddresses(parenttbl)
    for _, i in ipairs(parenttbl.SubAttachments or {}) do
        i.ParentAddress = parenttbl.Address
        self:BuildParentAddresses(i)
    end
end

function SWEP:AttTreeToList(tree)
    if !istable(tree) then return {} end
    local atts = {}

    atts = {tree}

    if tree.SubAttachments then
        for _, sub in ipairs(tree.SubAttachments) do
            table.Add(atts, self:AttTreeToList(sub))
        end
    end

    return atts
end

function SWEP:GetSubSlotList()
    local atts = {}

    for _, i in ipairs(self.Attachments or {}) do
        table.Add(atts, self:AttTreeToList(i))
    end

    return atts
end

function SWEP:GetAttachmentList()
    local atts = {}

    for _, i in ipairs(self:GetSubSlotList()) do
        if i.Installed then
            table.insert(atts, i.Installed)
        end
    end

    return atts
end

function SWEP:GetAttachmentElements()
    if self.ElementTablesCache then return self.ElementTablesCache end

    local eletables = {}

    local eles = self:GetElements()

    for i, _ in pairs(eles) do
        local ele = self.AttachmentElements[i]

        if !ele then continue end

        table.insert(eletables, ele)
    end

    for _, slot in ipairs(self:GetSubSlotList()) do
        local atttbl = self:GetFinalAttTable(slot)

        if atttbl.Element then
            table.insert(eletables, atttbl.Element)
        end
    end

    self.ElementTablesCache = eletables

    return eletables
end

-- tbl: The table we are installing on to the gun
-- parenttbl: The parent of the table we are installing on to
function SWEP:BuildSubAttachmentTree(tbl, parenttbl)
    if !tbl.Installed then return {} end

    local atttbl = ARC9.GetAttTable(tbl.Installed)

    tbl.ToggleNum = tbl.ToggleNum or 1

    local subatts = {}

    if atttbl and atttbl.Attachments then
        subatts = table.Copy(atttbl.Attachments)

        for i, k in ipairs(tbl.SubAttachments or {}) do
            if !subatts[i] then continue end
            subatts[i].Bone = parenttbl.Bone
            local att_pos = parenttbl.Pos or Vector()
            local att_ang = parenttbl.Ang or Angle()

            local og_addr = parenttbl.OriginalAddress

            if og_addr then
                local eles = self:GetAttachmentElements()

                for _, eletable in pairs(eles) do
                    if !eletable then continue end

                    local mods = eletable.AttPosMods or {}

                    if mods[og_addr] then
                        att_pos = mods[og_addr].Pos or att_pos
                        att_ang = mods[og_addr].Ang or att_ang
                    end
                end
            end

            local scale =  parenttbl.Scale or 1

            subatts[i].Scale = (subatts[i].Scale or 1) * scale

            local pos = Vector(0, 0, 0)
            pos:Set(att_pos)

            local off_ang = Angle(0, 0, 0)
            local forward, up, right = off_ang:Forward(), off_ang:Up(), off_ang:Right()

            forward:Rotate(-att_ang)
            up:Rotate(-att_ang)
            right:Rotate(-att_ang)

            subatts[i].Pos = subatts[i].Pos * (subatts[i].Scale or 1)

            pos = pos + (forward * -subatts[i].Pos.x)
            pos = pos + (right * -subatts[i].Pos.y)
            pos = pos + (up * -subatts[i].Pos.z)

            subatts[i].Pos = pos
            subatts[i].Ang = att_ang + subatts[i].Ang
            subatts[i].Ang:Normalize()
            subatts[i].Installed = tbl.SubAttachments[i].Installed
            if subatts[i].Installed then
                local satttbl = ARC9.GetAttTable(subatts[i].Installed)

                if !satttbl then
                    subatts[i].Installed = nil
                end
            end
            subatts[i].ExtraSightDistance = (subatts[i].ExtraSightDistance or 0) + (parenttbl.ExtraSightDistance or 0)
            -- subatts[i].MergeSlots = subatts[i].MergeSlots
            subatts[i].ToggleNum = tbl.SubAttachments[i].ToggleNum or 1
            subatts[i].CorrectiveAng = parenttbl.CorrectiveAng
            subatts[i].LaserCorrectionAngle = parenttbl.LaserCorrectionAngle
            subatts[i].ParentTable = parenttbl
            if parenttbl.DuplicateModels then
                subatts[i].DuplicateModels = table.Copy(parenttbl.DuplicateModels)

                for j, dupli in pairs(subatts[i].DuplicateModels) do
                    dupli.Scale = (dupli.Scale or 1) * (atttbl.Attachments[i].Scale or 1)
                    dupli.Pos = Vector(0, 0, 0)
                    dupli.Ang = Angle(0, 0, 0)

                    dupli.Pos:Set(parenttbl.DuplicateModels[j].Pos or parenttbl.Pos or Vector(0, 0, 0))
                    dupli.Ang:Set(parenttbl.DuplicateModels[j].Ang or parenttbl.Ang or Angle(0, 0, 0))

                    local pos2 = dupli.Pos

                    local off_ang2 = Angle(0, 0, 0)
                    local forward2, up2, right2 = off_ang2:Forward(), off_ang2:Up(), off_ang2:Right()

                    forward2:Rotate(-att_ang)
                    up2:Rotate(-att_ang)
                    right2:Rotate(-att_ang)

                    local newpos2 = Vector()
                    newpos2:Set(atttbl.Attachments[i].Pos or Vector(0, 0, 0))
                    newpos2 = newpos2 * (atttbl.Attachments[i].Scale or 1)

                    pos2 = pos2 + (forward2 * -newpos2.x)
                    pos2 = pos2 + (right2 * -newpos2.y)
                    pos2 = pos2 + (up2 * -newpos2.z)

                    dupli.Pos = pos2
                    dupli.Ang = att_ang + (atttbl.Attachments[i].Ang or Angle(0, 0, 0))
                    dupli.Ang:Normalize()
                end
            end
            if subatts[i].Installed then
                subatts[i].SubAttachments = self:BuildSubAttachmentTree(k, subatts[i])
            end
        end
    end

    return subatts
end

-- Call this after changing the attachment structure
function SWEP:BuildSubAttachments(tbl)
    for i, k in ipairs(self.Attachments) do
        k.OriginalAddress = i
        k.SubAttachments = {}
    end

    for i, k in ipairs(tbl) do
        if !self.Attachments[i] then print("Invalid attachment structure!") return end
        if ARC9.Blacklist[k.Installed] then continue end
        self.Attachments[i].Installed = k.Installed

        if !k.Installed then continue end

        local atttbl = ARC9.GetAttTable(k.Installed)
        self.Attachments[i].ToggleNum = k.ToggleNum or 1

        if atttbl then
            if atttbl.Attachments then
                self.Attachments[i].SubAttachments = self:BuildSubAttachmentTree(k, self.Attachments[i])
            end
        end
    end

    self:BuildAttachmentAddresses()
    self:BuildMergeSlots(self.Attachments)
end

-- Checks if the subatt tree is illegal
-- i.e. if it attempts to place attachments the player does not actually own
function SWEP:ValidateInventoryForNewTree(tree)
    local count = self:CountAttsInTree(tree)

    local currcount = self:CountAttsInTree(self.Attachments)

    for att, attc in pairs(count) do
        local atttbl = ARC9.GetAttTable(att)

        if atttbl.Free then continue end

        local has = (currcount[att] or 0) + ARC9:PlayerGetAtts(self:GetOwner(), att)
        local need = attc

        if has >= need then
            continue
        end

        return false
    end

    return true
end

-- Gets rid of invalid attachments
function SWEP:PruneAttachments()
    for _, slot in ipairs(self:GetSubSlotList()) do
        -- if !slot.Installed then continue end

        if !ARC9.Attachments[slot.Installed] then
            slot.Installed = nil
            continue
        end

        local atttbl = ARC9.GetAttTable(slot.Installed)

        if !atttbl or self:SlotInvalid(slot) then
            ARC9:PlayerGiveAtt(self:GetOwner(), slot.Installed, 1)
            slot.Installed = false
            slot.SubAttachments = nil
        end

        if slot.MergeSlotAddresses then
            for _, msa in ipairs(slot.MergeSlotAddresses) do
                local mslottbl = self:LocateSlotFromAddress(msa)

                if !mslottbl then continue end

                if mslottbl.Installed then
                    ARC9:PlayerGiveAtt(self:GetOwner(), slot.Installed, 1)
                    slot.Installed = false
                    slot.SubAttachments = nil
                end
            end
        end
    end
end

-- Try our best to fill any empty Integral slots
function SWEP:FillIntegralSlots()
    for _, slot in ipairs(self:GetSubSlotList()) do
        if !slot.Integral or slot.Installed then continue end

        if isstring(slot.Integral) and ARC9:PlayerGetAtts(self:GetOwner(), slot.Integral) > 0 then
            slot.Installed = slot.Integral
            ARC9:PlayerTakeAtt(self:GetOwner(), slot.Installed, 1)
        else
            local att = self:FirstAttForSlot(slot)
            if att then
                slot.Installed = att
                ARC9:PlayerTakeAtt(self:GetOwner(), slot.Installed, 1)
            end
        end
    end
end
--PATH lua/weapons/arccw_b2_blaster.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "[ ArcCW ] CIS TFA Weapons"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "B2 Blaster"
SWEP.Trivia_Class = "CIS B2 Hand-Blaster"
SWEP.Trivia_Desc = "CIS B2 Combat Hand-Blaster"
SWEP.Trivia_Manufacturer = "Baktoid Combat Automata"
SWEP.Trivia_Calibre = "Medium Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 1

SWEP.UseHands = false

SWEP.ViewModel = "models/arccw/bf2017/c_scoutblaster.mdl"
SWEP.WorldModel = "models/arccw/bf2017/w_scoutblaster.mdl"
SWEP.ViewModelFOV = 70
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

SWEP.IconOverride = "materials/entities/rw_sw_b2rp_blaster.png"

SWEP.DefaultBodygroups = "000000000000"

SWEP.Damage = 45
SWEP.RangeMin = 145
SWEP.DamageMin = 17
SWEP.Range = 325
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400

SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_red"
SWEP.TracerCol = Color(250, 0, 0)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 35

SWEP.Recoil = 0.7
SWEP.RecoilPunch = 0.8
SWEP.RecoilSide = 0.25
SWEP.RecoilRise = 0.31

SWEP.Delay = 60 / 260
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 1
	},
}

SWEP.AccuracyMOA = 1 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 350 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50

SWEP.NoFlash = nil -- disable light flash
SWEP.MuzzleEffect = nil
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false --
SWEP.MuzzleFlashColor = Color(255, 0, 0)


----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100

SWEP.ShootSound = "w/b2_blaster.wav"

SWEP.IronSightStruct = {
    Pos = Vector(-3.8, -8, 1.7),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "zoom_in/gunfoley_zoomin_blasterheavy_01.mp3",
     ViewModelFOV = 60,
}
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "pistol"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(3, -6, -1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(5, -9, 0)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Vector(0, 0, 0)

SWEP.CustomizePos = Vector(0.824, -9, 0.897)
SWEP.CustomizeAng = Angle(0, 0, 0)


SWEP.DefaultElements = {"b2handblaster"}

SWEP.AttachmentElements = {
    ["b2handblaster"] = {
        VMElements = {
            {
                Model = "models/arccw/cs574/weapons/b2_hand.mdl",
                Bone = "v_scoutblaster_reference001",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(0, 0, 0),
                    ang = Angle(0, 180, 0)
                }
            }
        },
        WMElements = {
            {
                Model = "models/arccw/cs574/weapons/b2_hand.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(40, 20, -15.3),
                    ang = Angle(-15, -90, 180)
                }
            },
        },
    }
}

WMOverride = "models/arccw/cs574/weapons/b2_hand.mdl" -- change the world model to something else. Please make sure it's compatible with the last one.

--SWEP.Attachments 
SWEP.Attachments = {
    [1] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = "b2attachments",
    }
}


SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = "fire"
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "draw/gunfoley_blaster_draw_var_04.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "draw/gunfoley_blaster_draw_var_08.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
 --       Time = 3.35,
        SoundTable = {
            {s = "ArcCW_dc17.reload2", t = 4 / 30}, --s sound file
        },
    },


sound.Add({
    name =          "ArcCW_dc17.reload2",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "weapons/bf3/pistols.wav"
    }),
}
--PATH lua/weapons/arccw_base/cl_crosshair.lua:
local size = 0
local clump_inner = Material("arccw/hud/clump_inner.png", "mips smooth")
local clump_outer = Material("arccw/hud/clump_outer.png", "mips smooth")
local aimtr_result = {}
local aimtr = {}
local square_mat = Material("color")

function SWEP:ShouldDrawCrosshair()
    if ArcCW.ConVars["override_crosshair_off"]:GetBool() then return false end
    if !ArcCW.ConVars["crosshair"]:GetBool() then return false end
    if self:GetReloading() then return false end
    if self:BarrelHitWall() > 0 then return false end
    local asight = self:GetActiveSights()

    if !self:GetOwner():ShouldDrawLocalPlayer()
            and self:GetState() == ArcCW.STATE_SIGHTS and !asight.CrosshairInSights then
        return false
    end

    if self:GetNWState() == ArcCW.STATE_SPRINT and !self:CanShootWhileSprint() then return false end
    if self:GetCurrentFiremode().Mode == 0 then return false end
    if self:GetBuff_Hook("Hook_ShouldNotFire") then return false end
    if self:GetNWState() == ArcCW.STATE_CUSTOMIZE then return false end
    if self:GetNWState() == ArcCW.STATE_DISABLE then return false end
    return true
end

local cr_main = Color( 0, 255, 0 )
local cr_shad = Color( 0, 0, 0, 127 )

local gaA = 0
local gaD = 0

function SWEP:GetFOVAcc( acc, disp )
    cam.Start3D()
        local lool = ( EyePos() + ( EyeAngles():Forward() ) + ( ( ArcCW.MOAToAcc * (acc or self:GetBuff("AccuracyMOA")) ) * EyeAngles():Up() ) ):ToScreen()
        local lool2 = ( EyePos() + ( EyeAngles():Forward() ) + ( ( (disp or self:GetDispersion()) * ArcCW.MOAToAcc / 10 ) * EyeAngles():Up() ) ):ToScreen()
    cam.End3D()

    local gau = 0
    gau = ( (ScrH() / 2) - lool.y )
    gaA = math.Approach(gaA, gau, (ScrH() / 2) * FrameTime())
    gau = 0
    gau = ( (ScrH() / 2) - lool2.y )
    gaD = math.Approach(gaD, gau, (ScrH() / 2) * FrameTime())

    return gaA, gaD
end

function SWEP:DrawDevCrosshair(x, y)
    surface.SetDrawColor(255, 50, 50, 255)

    surface.DrawLine(x, y - 256, x, y + 256)
    surface.DrawLine(x - 256, y, x + 256, y)


    local gA, gD = self:GetFOVAcc( self:GetBuff("AccuracyMOA"), self:GetDispersion() )
    surface.DrawCircle(x, y, gA + gD, 255, 255, 255, 155)
    surface.DrawCircle(x, y, gA, 255, 255, 0, 55)

    draw.SimpleTextOutlined(math.Round(self:GetDispersion(), 1) .. " MOA", "ArcCW_24_Unscaled", x - gA - gD - 16, y, color_white, TEXT_ALIGN_RIGHT, TEXT_ALIGN_BOTTOM, 1, Color(0, 0, 0))
    draw.SimpleTextOutlined(math.Round(self:GetBuff("AccuracyMOA"), 1) .. " MOA", "ArcCW_24_Unscaled", x - gA - gD - 16, y, Color(255, 255, 0), TEXT_ALIGN_RIGHT, TEXT_ALIGN_TOP, 1, Color(0, 0, 0))


    local dist = self:GetOwner():GetEyeTrace().HitPos:Distance(self:GetOwner():GetShootPos()) * ArcCW.HUToM
    local rf = self:GetRangeFraction(dist)

    local dmg = math.floor(self:GetDamage(dist))
    draw.SimpleTextOutlined(dmg .. " damage", "ArcCW_24_Unscaled", x + 256, y, color_white, TEXT_ALIGN_RIGHT, TEXT_ALIGN_BOTTOM, 1, Color(0, 0, 0))
    draw.SimpleTextOutlined(math.Round(dist, 1) .. "m", "ArcCW_24_Unscaled", x + 256 - 64, y, color_white, TEXT_ALIGN_RIGHT, TEXT_ALIGN_TOP, 1, Color(0, 0, 0))
    draw.SimpleTextOutlined(math.Round(rf * 100) .. "%", "ArcCW_24_Unscaled", x + 256, y, color_white, TEXT_ALIGN_RIGHT, TEXT_ALIGN_TOP, 1, Color(0, 0, 0))

end

function SWEP:DoDrawCrosshair(x, y)
    local ply = LocalPlayer()
    local pos = ply:EyePos()
    local ang = ply:EyeAngles() - self:GetOurViewPunchAngles() + self:GetFreeAimOffset()

    if self:GetBuff_Hook("Hook_PreDrawCrosshair") then return end

    local static = ArcCW.ConVars["crosshair_static"]:GetBool()

    local prong_dot = ArcCW.ConVars["crosshair_dot"]:GetBool()
    local prong_top = ArcCW.ConVars["crosshair_prong_top"]:GetBool()
    local prong_left = ArcCW.ConVars["crosshair_prong_left"]:GetBool()
    local prong_right = ArcCW.ConVars["crosshair_prong_right"]:GetBool()
    local prong_down = ArcCW.ConVars["crosshair_prong_bottom"]:GetBool()

    local prong_len = ArcCW.ConVars["crosshair_length"]:GetFloat()
    local prong_wid = ArcCW.ConVars["crosshair_thickness"]:GetFloat()
    local prong_out = ArcCW.ConVars["crosshair_outline"]:GetInt()
    local prong_tilt = ArcCW.ConVars["crosshair_tilt"]:GetBool()

    local clr = Color(ArcCW.ConVars["crosshair_clr_r"]:GetInt(),
            ArcCW.ConVars["crosshair_clr_g"]:GetInt(),
            ArcCW.ConVars["crosshair_clr_b"]:GetInt())
    if ArcCW.ConVars["ttt_rolecrosshair"] and ArcCW.ConVars["ttt_rolecrosshair"]:GetBool() then
        if GetRoundState() == ROUND_PREP or GetRoundState() == ROUND_POST then
            clr = Color(255, 255, 255)
        elseif ply.GetRoleColor and ply:GetRoleColor() then
            clr = ply:GetRoleColor() -- TTT2 feature
        elseif ply:IsActiveTraitor() then
            clr = Color(255, 50, 50)
        elseif ply:IsActiveDetective() then
            clr = Color(50, 50, 255)
        else
            clr = Color(50, 255, 50)
        end
    end
    if ArcCW.ConVars["crosshair_aa"]:GetBool() and ply.ArcCW_AATarget != nil and ArcCW.ConVars["aimassist"]:GetBool() and ArcCW.ConVars["aimassist_cl"]:GetBool() then
            -- whooie
        clr = Color(255, 0, 0)
    end
    clr.a = ArcCW.ConVars["crosshair_clr_a"]:GetInt()

    local outlineClr = Color(ArcCW.ConVars["crosshair_outline_r"]:GetInt(),
            ArcCW.ConVars["crosshair_outline_g"]:GetInt(),
            ArcCW.ConVars["crosshair_outline_b"]:GetInt(),
            ArcCW.ConVars["crosshair_outline_a"]:GetInt())

    local gA, gD = self:GetFOVAcc( self:GetBuff("AccuracyMOA"), self:GetDispersion() )
    local gap = (static and 8 or gA + gD) * ArcCW.ConVars["crosshair_gap"]:GetFloat()

    gap = gap + ( ScreenScale(8) * math.Clamp(self.RecoilAmount, 0, 1) )

    local prong = ScreenScale(prong_len)
    local p_w = ScreenScale(prong_wid)
    local p_w2 = p_w + prong_out

    local sp
    if self:GetOwner():ShouldDrawLocalPlayer() then
        local tr = util.GetPlayerTrace(self:GetOwner())
        local trace = util.TraceLine( tr )

        cam.Start3D()
        local coords = trace.HitPos:ToScreen()
        coords.x = math.Round(coords.x)
        coords.y = math.Round(coords.y)
        cam.End3D()
        sp = { visible = true, x = coords.x, y = coords.y }
    end

    cam.Start3D()
    sp = (pos + (ang:Forward() * 3200)):ToScreen()
    cam.End3D()

    if ArcCW.ConVars["crosshair_trueaim"]:GetBool() then
        aimtr.start = self:GetShootSrc()
    else
        aimtr.start = pos
    end

    aimtr.endpos = aimtr.start + ((ply:EyeAngles() + self:GetFreeAimOffset()):Forward() * 100000)
    aimtr.filter = {ply}
    aimtr.output = aimtr_result

    table.Add(aimtr.filter, ArcCW:GetVehicleFilter(ply) or {})

    util.TraceLine(aimtr)

    cam.Start3D()
    local w2s = aimtr_result.HitPos:ToScreen()
    w2s.x = math.Round(w2s.x)
    w2s.y = math.Round(w2s.y)
    cam.End3D()

    sp.x = w2s.x sp.y = w2s.y
    x, y = sp.x, sp.y

    if ArcCW.ConVars["dev_crosshair"]:GetBool() and LocalPlayer():IsAdmin() then
        self:DrawDevCrosshair(x, y)
    end

    local st = self:GetSightTime() / 2

    if self:ShouldDrawCrosshair() then
        self.CrosshairDelta = math.Approach(self.CrosshairDelta or 0, 1, FrameTime() * 1 / st)
    else
        self.CrosshairDelta = math.Approach(self.CrosshairDelta or 0, 0, FrameTime() * 1 / st)
    end

    if ArcCW.ConVars["crosshair_equip"]:GetBool() and (self:GetBuff("ShootEntity", true) or self.PrimaryBash) then
        prong = ScreenScale(prong_wid)
        p_w = ScreenScale(prong_wid)
        p_w2 = p_w + prong_out
    end

    if prong_dot then
        surface.SetDrawColor(outlineClr.r, outlineClr.g, outlineClr.b, outlineClr.a * self.CrosshairDelta)
        surface.DrawRect(x - p_w2 / 2, y - p_w2 / 2, p_w2, p_w2)

        surface.SetDrawColor(clr.r, clr.g, clr.b, clr.a * self.CrosshairDelta)
        surface.DrawRect(x - p_w / 2, y - p_w / 2, p_w, p_w)
    end


    size = math.Approach(size, gap, FrameTime() * 32 * gap)
    gap = size
    if !static then gap = gap * self.CrosshairDelta end
    gap = math.max(4, gap)

    local num = self:GetBuff("Num")
    if ArcCW.ConVars["crosshair_shotgun"]:GetBool() and num > 1 then
        prong = ScreenScale(prong_wid)
        p_w = ScreenScale(prong_len)
        p_w2 = p_w + prong_out
    end

    local prong2 = prong + prong_out
    if prong_tilt then
        local angle = (prong_left and prong_top and prong_right and prong_down) and 45 or 30
        local rad = math.rad(angle)
        local dx = gap * math.cos(rad) + prong * math.cos(rad) / 2
        local dy = gap * math.sin(rad) + prong * math.sin(rad) / 2
        surface.SetMaterial(square_mat)
        -- Shade
        surface.SetDrawColor(outlineClr.r, outlineClr.g, outlineClr.b, outlineClr.a * self.CrosshairDelta)
        if prong_left and prong_top then
            surface.DrawTexturedRectRotated(x - dx, y - dy, prong2, p_w2, -angle)
            surface.DrawTexturedRectRotated(x + dx, y - dy, prong2, p_w2, angle)
        elseif prong_left or prong_top then
            surface.DrawRect(x - p_w2 / 2, y - gap - prong2 + prong_out / 2, p_w2, prong2)
        end
        if prong_right and prong_down then
            surface.DrawTexturedRectRotated(x + dx, y + dy, prong2, p_w2, -angle)
            surface.DrawTexturedRectRotated(x - dx, y + dy, prong2, p_w2, angle)
        elseif prong_right or prong_down then
            surface.DrawRect(x - p_w2 / 2, y + gap - prong_out / 2, p_w2, prong2)
        end
        -- Fill
        surface.SetDrawColor(clr.r, clr.g, clr.b, clr.a * self.CrosshairDelta)
        if prong_left and prong_top then
            surface.DrawTexturedRectRotated(x - dx, y - dy, prong, p_w, -angle)
            surface.DrawTexturedRectRotated(x + dx, y - dy, prong, p_w, angle)
        elseif prong_left or prong_top then
            surface.DrawRect(x - p_w / 2, y - gap - prong, p_w, prong)
        end
        if prong_right and prong_down then
            surface.DrawTexturedRectRotated(x + dx, y + dy, prong, p_w, -angle)
            surface.DrawTexturedRectRotated(x - dx, y + dy, prong, p_w, angle)
        elseif prong_right or prong_down then
            surface.DrawRect(x - p_w / 2, y + gap, p_w, prong)
        end
    else
        -- Shade
        surface.SetDrawColor(outlineClr.r, outlineClr.g, outlineClr.b, outlineClr.a * self.CrosshairDelta)
        if prong_left then
            surface.DrawRect(x - gap - prong2 + prong_out / 2, y - p_w2 / 2, prong2, p_w2)
        end
        if prong_right then
            surface.DrawRect(x + gap - prong_out / 2, y - p_w2 / 2, prong2, p_w2)
        end
        if prong_top then
            surface.DrawRect(x - p_w2 / 2, y - gap - prong2 + prong_out / 2, p_w2, prong2)
        end
        if prong_down then
            surface.DrawRect(x - p_w2 / 2, y + gap - prong_out / 2, p_w2, prong2)
        end
        -- Fill
        surface.SetDrawColor(clr.r, clr.g, clr.b, clr.a * self.CrosshairDelta)
        if prong_left then
            surface.DrawRect(x - gap - prong, y - p_w / 2, prong, p_w)
        end
        if prong_right then
            surface.DrawRect(x + gap, y - p_w / 2, prong, p_w)
        end
        if prong_top then
            surface.DrawRect(x - p_w / 2, y - gap - prong, p_w, prong)
        end
        if prong_down then
            surface.DrawRect(x - p_w / 2, y + gap, p_w, prong)
        end
    end

    if ArcCW.ConVars["crosshair_clump"]:GetBool() and (ArcCW.ConVars["crosshair_clump_always"]:GetBool() or num > 1) then
        local acc = math.max(1, gA)
        if ArcCW.ConVars["crosshair_clump_outline"]:GetBool() then
            surface.SetMaterial(clump_outer)

            for i=1, prong_out do
                surface.DrawCircle(x-1, y-0, acc + math.ceil(i*0.5) * (i % 2 == 1 and 1 or -1), outlineClr.r, outlineClr.g, outlineClr.b, outlineClr.a * self.CrosshairDelta)
            end
            surface.DrawCircle(x-1, y-0, acc, outlineClr.r, outlineClr.g, outlineClr.b, outlineClr.a * self.CrosshairDelta)
        end

        surface.DrawCircle(x-1, y-0, acc, clr.r, clr.g, clr.b, clr.a * self.CrosshairDelta)
    end

    self:GetBuff_Hook("Hook_PostDrawCrosshair", w2s)

    return true
end
--PATH lua/weapons/arccw_base/sh_anim.lua:
return gluapack()()
--PATH lua/weapons/arccw_base/sh_heat.lua:
return gluapack()()
--PATH lua/weapons/arccw_base/sh_heat.lua:
SWEP.NextHeatDissipateTime = 0
SWEP.Heat = 0

function SWEP:GetMaxHeat()
    return self:GetBuff("HeatCapacity")
end

function SWEP:AddHeat(a)
    local single = game.SinglePlayer()
    a = tonumber(a)

    if !(self.Jamming or self:GetBuff_Override("Override_Jamming")) then return end

    if single and self:GetOwner():IsValid() and SERVER then self:CallOnClient("AddHeat", a) end
    -- if !single and !IsFirstTimePredicted() then return end

    local max = self:GetBuff("HeatCapacity")
    local mult = 1 * self:GetBuff_Mult("Mult_FixTime")
    local heat = self:GetHeat()
    local anim = self:SelectAnimation("fix")
    anim = self:GetBuff_Hook("Hook_SelectFixAnim", anim) or anim
    local amount = a or 1
    local t = CurTime() + self:GetAnimKeyTime(anim) * mult
    self.Heat = math.max(0, heat + amount * ArcCW.ConVars["mult_heat"]:GetFloat())

    self.NextHeatDissipateTime = CurTime() + (self:GetBuff("HeatDelayTime"))
    local overheat = self.Heat >= max
    if overheat then
        local h = self:GetBuff_Hook("Hook_Overheat", self.Heat)
        if h == true then overheat = false end
    end
    if overheat then
        self.Heat = math.min(self.Heat, max)
        if self:GetBuff_Override("Override_HeatFix", self.HeatFix) then
            self.NextHeatDissipateTime = t
        elseif self:GetBuff_Override("Override_HeatLockout", self.HeatLockout) then
            self.NextHeatDissipateTime = t
        end
    elseif !self:GetBuff_Override("Override_HeatOverflow", self.HeatOverflow) then
        self.Heat = math.min(self.Heat, max)
    end

    if single and CLIENT then return end

    self:SetHeat(self.Heat)

    if overheat then

        local ret = self:GetBuff_Hook("Hook_OnOverheat")
        if ret then return end

        if anim then
            self:PlayAnimation(anim, mult, true, 0, true)
            self:SetPriorityAnim(t)
            self:SetNextPrimaryFire(t)

            if self:GetBuff_Override("Override_HeatFix", self.HeatFix) then
                self:SetTimer(t - CurTime(),
                function()
                    self:SetHeat(0)
                end)
            end
        end

        if self.HeatLockout or self:GetBuff_Override("Override_HeatLockout") then
            self:SetHeatLocked(true)
        end

        self:GetBuff_Hook("Hook_PostOverheat")
    end
end

function SWEP:DoHeat()
    if self.NextHeatDissipateTime > CurTime() then return end

    --local diss = self.HeatDissipation or 2
    --diss = diss * self:GetBuff_Mult("Mult_HeatDissipation")
    local diss = self:GetBuff("HeatDissipation") or 2
    local ft = FrameTime()
    self.Heat = self:GetHeat() - (ft * diss)

    self.Heat = math.max(self.Heat, 0)

    self:SetHeat(self.Heat)

    if self.Heat <= 0 and self:GetHeatLocked() then
        self:SetHeatLocked(false)
    end
end

function SWEP:HeatEnabled()
    return self.Jamming or self:GetBuff_Override("Override_Jamming")
end

function SWEP:MalfunctionEnabled()
    local cvar = ArcCW.ConVars["malfunction"]:GetInt()
    return cvar == 2 or (cvar == 1 and self:GetBuff_Override("Override_Malfunction", self.Malfunction))
end

function SWEP:GetMalfunctionAnimation()
    local anim = self:SelectAnimation("unjam")
    if !self.Animations[anim] then
        anim = self:SelectAnimation("fix")
        anim = self:GetBuff_Hook("Hook_SelectFixAnim", anim) or anim
    end
    if !self.Animations[anim] then anim = self:SelectAnimation("cycle") end
    if !self.Animations[anim] then anim = nil end
    return anim
end

function SWEP:DoMalfunction(post)

    if !IsFirstTimePredicted() then return end
    if !self:MalfunctionEnabled() then return false end
    local shouldpost = self:GetBuff_Override("Override_MalfunctionPostFire", self.MalfunctionPostFire)
    if post != shouldpost then return false end

    -- Auto calculated malfunction mean
    if self.MalfunctionMean == nil then
        local mm
        if self.Jamming then mm = self.HeatCapacity * 4
        else mm = self.Primary.ClipSize * 8 end

        if self.ManualAction then
            -- Manual guns are less likely to jam
            mm = mm * 2
        else
            -- Burst and semi only guns are less likely to jam
            local a, b = false, false
            for k, v in pairs(self.Firemodes) do
                if !v.Mode then continue end
                if v.Mode == 2 then a = true
                elseif v.Mode < 0 then b = true end
            end
            if !a and b then
                mm = mm * 1.25
            elseif !a and !b then
                mm = mm * 1.5
            end
        end
        self.MalfunctionMean = mm
    end

    local cvar = math.max(ArcCW.ConVars["mult_malfunction"]:GetFloat(), 0.00000001)
    local mean = self:GetBuff("MalfunctionMean") / cvar
    local var = mean * math.Clamp(self:GetBuff("MalfunctionVariance") * math.max(1, math.sqrt(cvar)), 0, 1)
    local count = (self.ShotsSinceMalfunction or 0)

    if !self.NextMalfunction then
        math.randomseed(math.Round(util.SharedRandom(count, -1337, 1337, !game.SinglePlayer() and self:GetOwner():GetCurrentCommand():CommandNumber() or CurTime()) * (self:EntIndex() % 30241)))
        self.NextMalfunction = math.ceil(math.sqrt(-2 * var * math.log(math.random())) * math.cos(2 * math.pi * math.random()))
    end

    local ret = self:GetBuff_Hook("Hook_Malfunction", count, true)
    if ret != nil then return ret end

    -- if self:Clip1() <= 1 then return false end -- Don't fucking

    --print(mean, var, count, self.NextMalfunction)
    if count >= self.NextMalfunction + mean then
        local ret2 = self:GetBuff_Hook("Hook_OnMalfunction", count, true)
        if ret2 then return false end

        self:MyEmitSound(self:GetBuff_Override("Override_MalfunctionSound") or self.MalfunctionSound, 75, 100, 1, CHAN_ITEM)

        local wait = self:GetBuff("MalfunctionWait")
        self:SetNextPrimaryFire(CurTime() + wait)

        local anim = self:GetMalfunctionAnimation()
        if !anim or self:GetBuff_Override("Override_MalfunctionJam", self.MalfunctionJam) then
            self:SetMalfunctionJam(true)
        else
            self:SetTimer(wait,
            function()
                self:MalfunctionClear()
            end)
        end

        self:GetBuff_Hook("Hook_PostMalfunction")
        self.ShotsSinceMalfunction = 0
        self.NextMalfunction = nil

        self:SetBurstCount(0)

        return true
    else
        self.ShotsSinceMalfunction = (self.ShotsSinceMalfunction or 0) + 1
        return false
    end
end

function SWEP:MalfunctionClear()

    if self:GetBuff_Override("Override_MalfunctionTakeRound", self.MalfunctionTakeRound) then
        self:TakePrimaryAmmo(self:GetBuff("AmmoPerShot"))
    end

    local anim = self:GetMalfunctionAnimation()
    if anim then
        self:PlayAnimation(anim, self:GetBuff_Mult("Mult_MalfunctionFixTime"), true, 0, true)
        local wait = self:GetAnimKeyTime(anim) - 0.01
        self:SetTimer(wait,
        function()
            self:SetMalfunctionJam(false)
            self:PlayIdleAnimation(true)
        end)
        return true
    else
        self:SetMalfunctionJam(false)
        return false
    end
end
--PATH lua/weapons/arccw_base/sh_ttt.lua:
function SWEP:OnRestore()
end

function SWEP:GetHeadshotMultiplier(victim, dmginfo)
    return 2.5 -- Hey hey hey, don't forget about me!!!
end

function SWEP:IsEquipment()
    return WEPS.IsEquipment(self)
end

SWEP.IsSilent = false

-- The OnDrop() hook is useless for this as it happens AFTER the drop. OwnerChange
-- does not occur when a drop happens for some reason. Hence this thing.
function SWEP:PreDrop()
    if self.Throwing then
        if self:GetGrenadePrimed() then
            self:Throw()
        end
    else
        if SERVER and IsValid(self:GetOwner()) and self.Primary.Ammo != "none" then
            local ammo = self:Ammo1()

            -- Do not drop ammo if we have another gun that uses this type
            for _, w in ipairs(self:GetOwner():GetWeapons()) do
                if IsValid(w) and w != self and w:GetPrimaryAmmoType() == self:GetPrimaryAmmoType() then
                ammo = 0
                end
            end

            self.StoredAmmo = ammo

            if ammo > 0 then
                self:GetOwner():RemoveAmmo(ammo, self.Primary.Ammo)
            end
        end
    end

    net.Start("arccw_togglecustomize")
        net.WriteBool(false)
    net.Send(self:GetOwner())
    self:ToggleCustomizeHUD(false)
end

function SWEP:DampenDrop()
    -- For some reason gmod drops guns on death at a speed of 400 units, which
    -- catapults them away from the body. Here we want people to actually be able
    -- to find a given corpse's weapon, so we override the velocity here and call
    -- this when dropping guns on death.
    local phys = self:GetPhysicsObject()
    if IsValid(phys) then
        phys:SetVelocityInstantaneous(Vector(0,0,-75) + phys:GetVelocity() * 0.001)
        phys:AddAngleVelocity(phys:GetAngleVelocity() * -0.99)
    end
end

SWEP.StoredAmmo = 0

-- Picked up by player. Transfer of stored ammo and such.
function SWEP:Equip(newowner)
    if SERVER then
        if self:IsOnFire() then
            self:Extinguish()
        end

        self.fingerprints = self.fingerprints or {}

        if !table.HasValue(self.fingerprints, newowner) then
            table.insert(self.fingerprints, newowner)
        end
    end

    if SERVER and IsValid(newowner) and self.StoredAmmo > 0 and self.Primary.Ammo != "none" then
        local ammo = newowner:GetAmmoCount(self.Primary.Ammo)
        local given = math.min(self.StoredAmmo, self.Primary.ClipMax - ammo)

        newowner:GiveAmmo( given, self.Primary.Ammo)
        self.StoredAmmo = 0
    end
end

function SWEP:WasBought(buyer)
    if self.TTT_DoNotAttachOnBuy then return end

    for i, k in pairs(self.Attachments) do
        k.RandomChance = 100
    end
    -- if ArcCW.ConVars["ttt_atts"]:GetBool() then
    --     self:NPC_SetupAttachments()
    -- end
end

function SWEP:TTT_PostAttachments()
    self.IsSilent = self:GetBuff_Override("Silencer")

    if !self.IsSilent then
        self.IsSilent = true
    end
end

function SWEP:TTT_Init()
    if engine.ActiveGamemode() != "terrortown" then return end

    if SERVER then
        self.fingerprints = {}
    end

    if self.Throwing then
        self.Primary.ClipMax = 0
    end

    if ArcCW.ConVars["ttt_atts"]:GetBool() then
        if SERVER then
            self:NPC_SetupAttachments()
        end
    elseif !IsValid(self:GetOwner()) then
        -- If attachments aren't randomized, client will not need to ask for att info.
        self.CertainAboutAtts = true
    end

    if self.ForgetDefaultBehavior then return end

    self.Primary.ClipMax = ArcCW.TTTAmmoToClipMax[self.Primary.Ammo] or self.RegularClipSize * 2 or self.Primary.ClipSize * 2

    -- This will overwrite mag reducers, so give it a bit of time
    timer.Simple(0.1, function()
        if !IsValid(self) then return end
        self:SetClip1(self:GetCapacity() or self.RegularClipSize or self.Primary.ClipSize)
        self.Primary.DefaultClip = self.ForceDefaultAmmo or self.ForceDefaultClip or self:GetCapacity()
    end)

    if self.Throwing and self.Primary.Ammo and !self.ForceDefaultClip then
        self.Primary.Ammo = "none"
        self.Primary.DefaultClip = 0
        self:SetClip1(-1)
        self.Singleton = true
    end
end

--- TTT2 uses this to populate custom convars in the equip menu
function SWEP:AddToSettingsMenu(parent)
end
--PATH lua/weapons/arccw_dual_rg4d.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "[ ArcCW ] CIS TFA Weapons"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "Dual RG-4D"
SWEP.Trivia_Class = "CIS Dual Blaster Pistol"
SWEP.Trivia_Desc = "High tech compact Dual RG-4D Blaster Pistol."
SWEP.Trivia_Manufacturer = "Baktoid Combat Automata"
SWEP.Trivia_Calibre = "Medium Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 1

SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/strasser/weapons/c_ddeagle.mdl"
SWEP.WorldModel = "models/arccw/weapons/synbf3/w_scoutblaster.mdl"
SWEP.ViewModelFOV = 90
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

SWEP.IconOverride = "materials/entities/rw_sw_dual_rg4d.png"

SWEP.DefaultBodygroups = "000000000000"

SWEP.Damage = 30
SWEP.RangeMin = 120
SWEP.DamageMin = 22
SWEP.Range = 320
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400

SWEP.NoHideLeftHandInCustomization = true

SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_red"
SWEP.TracerCol = Color(250, 0, 0)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 20*2

SWEP.Recoil = 0.7
SWEP.RecoilPunch = 1.4
SWEP.RecoilSide = 0.25
SWEP.RecoilRise = 0.31

SWEP.Delay = 60 / 380
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 2
	},
    {
        Mode = 1
    },
    {
        Mode = 0
    },    
}

SWEP.AccuracyMOA = 0.75 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 800 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50


----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100

SWEP.ShootSound = "w/rg4d.wav"

SWEP.MuzzleFlashColor = Color(255, 0, 0, 50)

SWEP.IronSightStruct = {
    Pos = Vector(0, -4, 1),
    Ang = Angle(0, 0, 0),
     Magnification = 1.2,
     SwitchToSound = "zoom_in/gunfoley_zoomin_blasterheavy_01.mp3",
     ViewModelFOV = 90,
}
SWEP.HoldtypeHolstered = ""
SWEP.HoldtypeActive = "duel"
SWEP.HoldtypeSights = ""


SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, -5, -4)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, -14,-10)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Vector(-25, 0, 0)

SWEP.ReloadPos = Vector(0, -10, -5)

SWEP.CustomizePos = Vector(-0.5, -8, -4.897)
SWEP.CustomizeAng = Angle(30, 0, 0)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 1, 1)
SWEP.DrawCrosshair = true

SWEP.BarrelLength = 60
SWEP.BarrelOffsetSighted = Vector(0, 0, 0)
SWEP.BarrelOffsetHip = Vector(3, 0, -3)
SWEP.DefaultElements = {"rg4d", "rg4d+"}

SWEP.AttachmentElements = {
    ["rg4d"] = {
        VMElements = {
            {
                Model = "models/arccw/kuro/sw_battlefront/weapons/rg4d_blaster.mdl",
                Bone = "LeftHand_1stP",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(7.5, -0.5, -1),
                    ang = Angle(-5, -2, 90)
                }
            }
        },
    },
    ["rg4d+"] = {
         VMElements = {
            {
                Model = "models/arccw/kuro/sw_battlefront/weapons/rg4d_blaster.mdl",
                Bone = "RightHand_1stP",
                Scale = Vector(1.1, 1.1, 1.1),                
                Offset = {
                    pos = Vector(-7.5, 0.5, 1),
                    ang = Angle(0, 178, 90)
                }
            }
        }, 
        WMElements = {
            {
                Model = "models/arccw/kuro/sw_battlefront/weapons/rg4d_blaster.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(90.5, 10, 20.75),
                    ang = Angle(180, -180, 2)
                }
            },
            {
                Model = "models/arccw/kuro/sw_battlefront/weapons/rg4d_blaster.mdl",
                Bone = "ValveBiped.Bip01_L_Hand",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(10, 230, -25),
                    ang = Angle(180, -180, 2)
                }
            },
        },            -- change the world model to something else. Please make sure it's compatible with the last one.
    }
}
WMOverride = "models/arccw/kuro/sw_battlefront/weapons/rg4d_blaster.mdl"

--SWEP.Attachments 
SWEP.Attachments = {
    [1] = {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"tactical","tac_pistol"},
        Bone = "RightHand_1stP", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(-12, -5, 1.5),
            vang = Angle(175, 0, 0),
        },
    },    
    [2] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = "ammo",
    }
}


SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = {"shoot_lw", "shoot_rw"},
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1.5,
        SoundTable = {
            {
                s = "draw/gunfoley_pistol_draw_var_10.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "holster/gunfoley_pistol_sheathe_var_09.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        Time = 3.35,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PHYSGUN,
        SoundTable = {
            {s = "ArcCW_dc17.reload2", t = 4 / 30}, --s sound file
        },
    },


sound.Add({
    name =          "ArcCW_dc17.reload2",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "weapons/bf3/pistols.wav"
    }),
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_a274su.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "A-274su"
SWEP.Trivia_Class = "Blaster Carbine"
SWEP.Trivia_Desc = "The A280 blaster rifle was a type of blaster rifle mostly used by Rebel Alliance troopers and New Republic soldiers. There existed two variants of the A280 blaster, the A280C and the A280-CFE, both of which were favored by commandos and special force of the Rebel Alliance."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/galactic/a274su.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "0040101000000000"

SWEP.HideViewmodel = false
SWEP.MirrorVMWM = true
SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/kraken/galactic/v_a280c.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dlt19.mdl"
SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(0.9, 0.5, -2.9),
    ang = Angle(-10, 0, 180),
    scale = 1,
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 25
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 22
SWEP.DamageMin = 20
SWEP.RangeMin = 0
SWEP.Range = 240
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TraceNum = 1
SWEP.Tracer = "tracer_red"
SWEP.TracerCol = Color(250, 0, 0)

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 45

SWEP.Recoil = 0.87
SWEP.RecoilSide = 0.45
SWEP.RecoilRise = 0.78
SWEP.RecoilPunch = 1.1

SWEP.Delay = 60 / 700
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
        PostBurstDelay = 0.1,
    },
    {
		Mode = 2,
        PostBurstDelay = 0.1,
    },
    {
        Mult_RPM = 2,
		Mode = -3,
        PostBurstDelay = 0.1,
    },
	{
		Mode = 0,
   	}
}

SWEP.AccuracyMOA = 1
SWEP.HipDispersion = 300
SWEP.MoveDispersion = 100
SWEP.JumpDispersion = 150

-- Speed Mult
SWEP.SpeedMult = 0.9
SWEP.SightedSpeedMult = 0.75
SWEP.ShootSpeedMult = 1.05

-- Sounds & Muzzleflash
SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 125
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.FirstShootSound = "ArcCW_Kraken.SW_A280"
SWEP.ShootSound = "ArcCW_Kraken.SW_A280"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.MuzzleFlashColor = Color(250, 0, 0)
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.GMMuzzleEffect = false

-- Ironsight & Holdtype
SWEP.IronSightStruct = {
    Pos = Vector(-3.05, -4, 1.1),
    Ang = Angle(0, 0, 2.5),
     Magnification = 1.5,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 55,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(4.019, -5.226, -0.805)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CrouchPos = Vector(-4, 0, 0)
SWEP.CrouchAng = Angle(0, 0, -10)

SWEP.HolsterPos = Vector(3, -3, 0)
SWEP.HolsterAng = Angle(-7.036, 30.016, 0)

SWEP.BarrelOffsetSighted = Vector(0, 0, -1)
SWEP.BarrelOffsetHip = Vector(2, 0, -2)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(20, 30.7, 10.3)

-- Attachments 
SWEP.AttachmentElements = {
    ["optic_attach"] = {
        VMBodygroups = {{ind = 3, bg = 1}},
    },
    ["laser_attach"] = {
        VMBodygroups = {{ind = 4, bg = 0}},
    },
    ["foregrip_attach"] = {
        VMBodygroups = {{ind = 5, bg = 1}},
    },
}
SWEP.Attachments = {     
    {
        PrintName = "Optics", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "tag_sling",
        InstalledEles = {"optic_attach"},
        Offset = {
            vpos = Vector(4, 0, 1.5),
            vang = Angle(0, 0, 0),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0)
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "stealth_muzzle"},
        VMScale = Vector(1.2, 1.2, 1.2),
        WMScale = Vector(1.2, 1.2, 1.2),
        Bone = "tag_sling",
        Offset = {
            vpos = Vector(24.5, -0.05, 0.05),
            vang = Angle(0, 0, 0),
        },
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        InstalledEles = {"laser_attach"},
        Bone = "tag_sling",
        Offset = {
            vpos = Vector(13.4, 0.8, 0.3),
            vang = Angle(0, 0, -90),
        },
    },  
    {
        PrintName = "Underbarrel",
        DefaultAttName = "None",
        Slot = {"foregrip"},
        VMScale = Vector(1, 1, 1),
        WMScale = Vector(1, 1, 1),
        Bone = "tag_sling",
        InstalledEles = {"foregrip_attach"},
        Offset = {
            vpos = Vector(13, 0.1, -0.38),
            vang = Angle(0, 0, 0),
        },
    },  
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.6, 0.6, 0.6),
        WMScale = Vector(0.6, 0.6, 0.6),
        Bone = "tag_sling",
        Offset = {
            vpos = Vector(6.6, -0.6, -1.3),
            vang = Angle(0, 0, 0),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        Bone = "tag_sling",
        Offset = {
            vpos = Vector(2.5, -0.6, 0),
            vang = Angle(0, 0, 0),
        },
    },
}

-- Don't touch this unless you know what you're doing
local path = "arccw/kraken/sw_galactic/weapons/a280/handling/"

SWEP.Animations = {
    ["fire"] = {
        Source = "shoot1",
		IKTimeLine = { { t = 0,  lhik = 1, rhik = 1} },
    },
    ["reload"] = {
        Source = "reload_short",
        LHIK = true,
		MinProgress = 0.9,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
			{s = path .. "wpfoly_mike4_reload_lift_v2.ogg", t = 0.1/30},
            {s = "ArcCW_Kraken.Overheat", t = 19/30},
			{s = path .. "wpfoly_mike4_reload_magout_v2.ogg", t = 18/30},
			{s = path .. "wpfoly_mike4_reload_magin_01.ogg", t = 28/30},
			{s = path .. "wpfoly_mike4_reload_magin_v2.ogg", t = 31/30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 32/30},
			{s = path .. "wpfoly_mike4_reload_end_v2.ogg", t = 52/30},
        },
    },
    ["reload_empty"] = {
        Source = "reload",
        LHIK = true,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
		MinProgress = 0.9,
        SoundTable = {
			{s = path .. "wpfoly_mike4_reload_empty_lift_v2.ogg", t = 0.1/30},
			{s = path .. "wpfoly_mike4_reload_empty_magout_v2.ogg", t = 5/30},
            {s = "ArcCW_Kraken.Overheat", t = 6/30},
			{s = path .. "wpfoly_mike4_reload_empty_magin_v2.ogg", t = 31/30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 32/30},
			{s = path .. "wpfoly_mike4_reload_empty_chamber_v2.ogg", t = 53/30},
			{s = path .. "wpfoly_mike4_reload_empty_end_v2.ogg", t = 63/30},
        },
    },
    ["ready"] = {
        Source = "draw",
		MinProgress = 0.6,
        SoundTable = {
            {s = path .. "wpfoly_mike4_raise_first_01.ogg", t = 0.2},
            {s = path .. "wpfoly_mike4_raise_first_02.ogg", t = 0.85},
            {s = path .. "wpfoly_mike4_raise_first_03.ogg", t = 1.3},
        },
    },
    ["draw"] = {
        Source = "draw_short",
		MinProgress = 0.5,
        SoundTable = {
            {s = path .. "wpfoly_mike4_raise_v2.ogg", t = 0.1/30},
        },
    },
    ["holster"] = {
        Source = "holster",
		--Mult = 0.8,
        SoundTable = {
            {s = path .. "wpfoly_mike4_drop_v2.ogg", t = 0.1/30},
        },
    },
    ["idle"] = {
        Source = "idle",
    },
    ["inspect"] = {
        Source = "lookat01",
        LHIK = true,
		MinProgress = 0.9,
        SoundTable = {
            {s = path .. "wfoly_ar_mike4_inspect_01.ogg", t = 0},
			{s = path .. "wfoly_ar_mike4_inspect_02.ogg", t = 1.3},
			{s = path .. "wfoly_ar_mike4_inspect_03.ogg", t = 2.36},
			{s = path .. "wfoly_ar_mike4_inspect_04.ogg", t = 3.6},
			{s = path .. "wfoly_ar_mike4_inspect_05.ogg", t = 4.2},
        },
    },
    ["bash"] = {
        Source = {"melee", "melee2", "melee3"},
    },
    ["changefiremode"] = {
        Source = "semi_on",
        SoundTable = {
            {s = path .. "weap_m4_selector_semi_on_03.ogg", t = 0.1/30},
        },
    },
    ["fix"] = {
        Source = "unjam",
        MinProgress = 0.4,
        FireASAP = true,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 5/30},
			{s = path .. "wpfoly_mike4_reload_empty_lift_v2.ogg", t = 5/30},
            {s = path .. "wpfoly_mike4_jam_bolt.ogg", t = 10/30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 34/30},
			{s = path .. "wpfoly_mike4_reload_empty_chamber_v2.ogg", t = 25/30},
			{s = path .. "wpfoly_mike4_reload_empty_end_v2.ogg", t = 34/30},
        },
    },
    ["enter_bipod"] = {
        Source = "bipod_in",
    },
    ["exit_bipod"] = {
        Source = "bipod_out",
    },
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_a280c.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_a287.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "A-287"
SWEP.Trivia_Class = "Blaster Rifle"
SWEP.Trivia_Desc = "The A280 blaster rifle was a type of blaster rifle mostly used by Rebel Alliance troopers and New Republic soldiers. There existed two variants of the A280 blaster, the A280C and the A280-CFE, both of which were favored by commandos and special force of the Rebel Alliance."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/galactic/a287.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "001000000000000"

SWEP.HideViewmodel = false
SWEP.MirrorVMWM = true
SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/kraken/galactic/v_a280.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dlt19.mdl"
SWEP.ViewModelFOV = 70

SWEP.WorldModelOffset = {
    pos = Vector(0.9, 0.5, -2.9),
    ang = Angle(-10, 0, 180),
    scale = 1,
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 25
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 44
SWEP.DamageMin = 25
SWEP.RangeMin = 0
SWEP.Range = 540
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TraceNum = 1
SWEP.Tracer = "tracer_red"
SWEP.TracerCol = Color(250, 0, 0)

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 26

SWEP.Recoil = 0.65
SWEP.RecoilSide = 0.45
SWEP.RecoilRise = 0.75
SWEP.RecoilPunch = 1.1

SWEP.Delay = 60 / 430
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
        PostBurstDelay = 0.1,
    },
    {
		Mode = 2,
        PostBurstDelay = 0.1,
    },
    {
        Mult_RPM = 2,
		Mode = -3,
        PostBurstDelay = 0.1,
    },
	{
		Mode = 0,
   	}
}

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 250
SWEP.MoveDispersion = 100
SWEP.JumpDispersion = 150

-- Speed Mult
SWEP.SpeedMult = 0.9
SWEP.SightedSpeedMult = 0.75
SWEP.ShootSpeedMult = 1.05

-- Sounds & Muzzleflash
SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 125
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.FirstShootSound = "ArcCW_Kraken.SW_A280"
SWEP.ShootSound = "ArcCW_Kraken.SW_A280"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.MuzzleFlashColor = Color(250, 0, 0)
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.GMMuzzleEffect = false

-- Ironsight & Holdtype
SWEP.IronSightStruct = {
    Pos = Vector(-2.373, -3, 0),
    Ang = Vector(0, 0.1, -3),
     Magnification = 1.5,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 55,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, 0, -1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, -2, 0)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.CrouchPos = Vector(-4, 0, 0)
SWEP.CrouchAng = Angle(0, 0, -10)

SWEP.HolsterPos = Vector(3, -3, 0)
SWEP.HolsterAng = Angle(-7.036, 30.016, 0)

SWEP.BarrelOffsetSighted = Vector(0, 0, -1)
SWEP.BarrelOffsetHip = Vector(2, 0, -2)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(20, 30.7, 10.3)

-- Attachments 
SWEP.DefaultElements = {}
SWEP.AttachmentElements = {
    ["optic_attach"] = {
        VMBodygroups = {{ind = 3, bg = 1}},
    },
    ["laser_attach"] = {
        VMBodygroups = {{ind = 4, bg = 1}},
    },
    ["foregrip_attach"] = {
        VMBodygroups = {{ind = 5, bg = 1}},
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Optics", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "tag_attachments",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        InstalledEles = {"optic_attach"},
        Offset = {
            vpos = Vector(8.5, -0, 2),
            vang = Angle(0, 0, 0),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0)
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "stealth_muzzle"},
        VMScale = Vector(1.2, 1.2, 1.2),
        WMScale = Vector(1.2, 1.2, 1.2),
        Bone = "tag_attachments",
        Offset = {
            vpos = Vector(26, -0.1, 0.25),
            vang = Angle(0, 0, 0),
        },
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        InstalledEles = {"laser_attach"},
        VMScale = Vector(0.6, 0.6, 0.6),
        WMScale = Vector(0.6, 0.6, 0.6),
        Bone = "tag_attachments",
        Offset = {
            vpos = Vector(13.5, 0.6, 0.5),
            vang = Angle(0, 0, -90),
        },
    },  
    {
        PrintName = "Underbarrel",
        DefaultAttName = "A-280 Foregrip",
        Slot = {"foregrip"},
        VMScale = Vector(0.8, 0.8, 0.8),
        WMScale = Vector(0.8, 0.8, 0.8),
        InstalledEles = {"foregrip_attach"},
        Bone = "tag_attachments",
        Offset = {
            vpos = Vector(13.4, 0.1, -0.3),
            vang = Angle(0, 0, 0),
        },
    },  
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.5, 0.5, 0.5),
        WMScale = Vector(0.5, 0.5, 0.5),
        Bone = "tag_attachments",
        Offset = {
            vpos = Vector(5.55, -1.0, -1.34),
            vang = Angle(0, 0, 0),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(0.8, 0.8, 0.8),
        WMScale = Vector(0.8, 0.8, 0.8),
        Bone = "tag_attachments",
        Offset = {
            vpos = Vector(2.5, -0.5, 0.09),
            vang = Angle(0, 0, 0),
        },
    },
}

-- Don't touch this unless you know what you're doing
local path = "arccw/kraken/sw_galactic/weapons/a280/handling_2/"

SWEP.Animations = {
    ["fire"] = {
        Source = "shoot1",
    },
    ["reload"] = {
        Source = "reload_short",
        LHIK = true,
		MinProgress = 0.9,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = path .. "wfoly_plr_ar_falima_reload_start.ogg", t = 0.033},
            {s = "ArcCW_Kraken.Overheat", t = 0.67},
            {s = path .. "wfoly_plr_ar_falima_reload_magout_01.ogg", t = 0.65},
            {s = path .. "wfoly_plr_ar_falima_reload_arm.ogg", t = 0.75},
            {s = path .. "wfoly_plr_ar_falima_reload_elbow.ogg", t = 1.45},
			{s = path .. "wfoly_plr_ar_falima_reload_magin_v2_01.ogg", t = 1.5},
			{s = path .. "wfoly_plr_ar_falima_reload_magin_v2_02.ogg", t = 1.75},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 1.6},
			{s = path .. "wfoly_plr_ar_falima_reload_end.ogg", t = 2.06},
        },
    },
    ["reload_empty"] = {
        Source = "reload",
        LHIK = true,
		MinProgress = 0.9,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = path .. "wfoly_plr_ar_falima_reload_empty_start.ogg", t = 0},
            {s = path .. "wfoly_plr_ar_falima_reload_empty_rotate.ogg", t = 0.46},
            {s = path .. "wfoly_plr_ar_falima_reload_empty_magout_01.ogg", t = 0.73},
            {s = path .. "wfoly_plr_ar_falima_reload_empty_shake.ogg", t = 0.93},
            {s = path .. "wfoly_plr_ar_falima_reload_empty_arm.ogg", t = 1.63},
			{s = path .. "wfoly_plr_ar_falima_reload_empty_magin_v2_01.ogg", t = 1.83},
			{s = path .. "wfoly_plr_ar_falima_reload_empty_magin_v2_02.ogg", t = 2.1},
            {s = path .. "wfoly_plr_ar_falima_reload_empty_elbow.ogg", t = 2.2},
			{s = path .. "wfoly_plr_ar_falima_reload_empty_boltopen_01.ogg", t = 2.66},
            {s = path .. "wfoly_plr_ar_falima_reload_empty_boltclose_01.ogg", t = 2.96},
            {s = path .. "wfoly_plr_ar_falima_reload_empty_end.ogg", t = 3},
        },
    },
    ["ready"] = {
        Source = "draw_short",
        LHIK = true,
		MinProgress = 0.5,
        SoundTable = {
            {s = path .. "wfoly_plr_ar_falima_raise_start.ogg", t = 0/30},
			{s = path .. "wfoly_plr_ar_falima_raise_settle.ogg", t = 0/30},
        },
    },
    ["draw"] = {
        Source = "draw_short",
        LHIK = true,
		MinProgress = 0.5,
        SoundTable = {
            {s = path .. "wfoly_plr_ar_falima_raise_start.ogg", t = 0/30},
			{s = path .. "wfoly_plr_ar_falima_raise_settle.ogg", t = 0/30},
        },
    },
    ["holster"] = {
        Source = "holster",
        LHIK = true,
        SoundTable = {
            {s = path .. "wfoly_plr_ar_falima_drop_down.ogg", t = 0/30},
        },
    },
    ["idle"] = {
        Source = "idle",
    },
    ["idle_sprint"] = {
        Source = "sprint",
    },
    ["exit_sprint"] = {
        Source = "sprint_out",
        Time = 1.25,
    },
    ["enter_sprint"] = {
        Source = "sprint_in",
        Time = 1.25,
    },
    ["exit_inspect"] = {
        Source = "lookat01",
		MinProgress = 0.9,
        SoundTable = {
            {s = path .. "wfoly_ar_falima_inspect_01.ogg", t = 0},
			{s = path .. "wfoly_ar_falima_inspect_02.ogg", t = 1.3},
			{s = path .. "wfoly_ar_falima_inspect_03.ogg", t = 2.36},
			{s = path .. "wfoly_ar_falima_inspect_04.ogg", t = 3.6},
			{s = path .. "wfoly_ar_falima_inspect_05.ogg", t = 4.1},
        },
    },
    ["bash"] = {
        Source = {"melee","melee2","melee3"},
    },
    ["changefiremode"] = {
        Source = "semi_on",
        SoundTable = {
            {s = path .. "weap_ar_falima_selector_off.ogg", t = 0/30},
        },
    },
    ["enter_bipod"] = {
        Source = "bipod_in",
    },
    ["exit_bipod"] = {
        Source = "bipod_out",
    },
}

--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_b2hand.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_bowcaster.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_caradune.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_caradune.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 2

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "Cara Dune Blaster"
SWEP.Trivia_Class = "Blaster Pistol"
SWEP.Trivia_Desc = "Blaster Pistol designed originally for military purposes, now modernized and being used by many Bounty Hunters, Civillians and even Mercenaries or Military Corporations in the galaxy."
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/galactic/caradune.png"

-- Base
SWEP.DefaultBodygroups = "000000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/galactic/v_carablaster.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(-18.5, 6, -5.4),
    ang = Angle(0, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 15
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 29
SWEP.DamageMin = 21
SWEP.RangeMin = 0
SWEP.Range = 250
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(250, 0, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_red"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 25

SWEP.Recoil = 0.55
SWEP.RecoilSide = 0.2
SWEP.RecoilRise = 0.2

SWEP.Delay = 60 / 380
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
        Mode = -3,
        PostBurstDelay = 0.1,
        RunawayBurst = false,
        Mult_RPM = 2,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0.5
SWEP.HipDispersion = 100
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "ArcCW_Kraken.SW_CARADUNE"
SWEP.ShootSound = "ArcCW_Kraken.SW_CARADUNE"
SWEP.DistantShootSound = "ArcCW_Kraken.StandardCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-5.04, -11.296, 1.4),
    Ang = Angle(0,0,0),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL

SWEP.SprintPos = Vector(2.019, -5.226, -2)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.CustomizePos = Vector(10, -10, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 2)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(-3, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.DefaultElements = {}
SWEP.AttachmentElements = {
    ["muzzle_attach"] = {
        VMBodygroups = {{ind = 1, bg = 1}},
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Sight", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "DC-15SA",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(-0.01, -1.9, -4),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        Bone = "DC-15SA",
        InstalledEles = {"muzzle_attach"},
        Offset = {
            vpos = Vector(0, -1.47, 1.95),
            vang = Angle(90, 0, -90),
        },
    },  
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "DC-15SA",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(-0.42, -1.4, 0),
            vang = Angle(90, 0, 180),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.5, 0.5, 0.5),
        WMScale = Vector(0.5, 0.5, 0.5),
        Bone = "DC-15SA",
        Offset = {
            vpos = Vector(0.5, 0.1, -3.9),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Bone = "DC-15SA",
        Offset = {
            vpos = Vector(0.55, -1.1, -2.5),
            vang = Angle(90, 0, -90),
        },
    },   
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = false,
    },
    ["idle_iron"] = {
        Source = false,
    },
	["fire"] = {
        Source = {"fire"},
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_cr2hp.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_cycler.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 4 -- Change this if you want to select the weapon with other number

SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "Cycler"
SWEP.Trivia_Class = "Double-Barrel Sniper"
SWEP.Trivia_Desc = "Cycler rifles were crude yet reliable slugthrower rifles designed to fire solid projectiles. They could hit targets at extreme ranges and penetrate energy shields. Used primarily by primitive cultures and hunters, they were strong enough to tear whole limbs from a body."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/galactic/cycler.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "0101000000000000"

SWEP.HideViewmodel = false
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/galactic/v_cycler.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"
SWEP.ViewModelFOV = 70

SWEP.WorldModelOffset = {
    pos = Vector(-1, 0.6, -3),
    ang = Angle(-5, 0, 180),
    scale = 1,
}

-- Damage & Tracer
SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 190
SWEP.DamageMin = 95
SWEP.RangeMin = 0
SWEP.Range = 700
SWEP.Penetration = 8
SWEP.DamageType = DMG_BUCKSHOT
SWEP.MuzzleVelocity = 9000

SWEP.TraceNum = 1
SWEP.Tracer = "tracer_orange"
SWEP.TracerCol = Color(250, 242, 0)

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 2

SWEP.Recoil = 3
SWEP.RecoilSide = 1.5
SWEP.RecoilRise = 2
SWEP.MaxRecoilBlowback = 2
SWEP.RecoilPunch = 1.5
SWEP.RecoilVMShake = 2

SWEP.Delay = 60 / 120
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
        PostBurstDelay = 0.1,
    },
	{
		Mode = 0,
   	}
}


SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 100
SWEP.MoveDispersion = 75
SWEP.JumpDispersion = 150

-- Speed Mult
SWEP.SpeedMult = 0.85
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.30

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100

SWEP.FirstShootSound = "ArcCW_Kraken.SW_CYCLERO"
SWEP.ShootSound = "ArcCW_Kraken.SW_CYCLERO"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.MuzzleFlashColor = Color(250, 242, 0)
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.GMMuzzleEffect = false

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-3.05, -0, 0.5),
    Ang = Vector(0.5, 0, -2),
     Magnification = 1.5,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 55,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN

SWEP.ActivePos = Vector(-1, 2, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(4.019, -5.226, 0)
SWEP.SprintAng = Angle(5, 0, 0)

SWEP.CrouchPos = Vector(-4, 0, -1)
SWEP.CrouchAng = Angle(0, 0, -10)

SWEP.HolsterPos = Vector(3, 3, 0)
SWEP.HolsterAng = Angle(-7.036, 30.016, 0)

SWEP.BarrelOffsetSighted = Vector(0, 0, -1)
SWEP.BarrelOffsetHip = Vector(2, 0, -2)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(20, 30.7, 10.3)

SWEP.GuaranteeLaser = true

-- Attachments
SWEP.DefaultElements = {}
SWEP.AttachmentElements = {
    ["scope_attach"] = {
        VMBodygroups = {{ind = 3, bg = 0}, {ind = 5, bg = 1}},
    },
    ["grip_attach"] = {
        VMBodygroups = {{ind = 4, bg = 1}},
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Optics", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "tag_scope",
        InstalledEles = {"scope_attach"},
        Offset = {
            vpos = Vector(4, 0, -0.1),
            vang = Angle(0, 0, 0),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0)
    },
    {
        PrintName = "Internal Compression",
        DefaultAttName = "None",
        Slot = {"muzzle", "stealth_muzzle"},
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(1, 1, 1),
        WMScale = Vector(1, 1, 1),
        Bone = "tag_scope",
        Offset = {
            vpos = Vector(18, 0.4, -0.6),
            vang = Angle(0, 0, -90),
        },
    },  
    {
        PrintName = "Underbarrel",
        DefaultAttName = "None",
        Slot = {"foregrip"},
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Bone = "tag_rail",
        InstalledEles = {"grip_attach"},
        Offset = {
            vpos = Vector(0, 0, -2.8),
            vang = Angle(0, 0, 0),
        },
    },  
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.6, 0.6, 0.6),
        WMScale = Vector(0.6, 0.6, 0.6),
        Bone = "tag_rail",
        Offset = {
            vpos = Vector(-3.4, -0.8, -1.1),
            vang = Angle(0, 0, 0),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        Bone = "tag_rail",
        Offset = {
            vpos = Vector(0.8, -0.6, -1.1),
            vang = Angle(0, 0, 0),
        },
    },
}

-- Animations
local path = "arccw/kraken/sw_galactic/weapons/tuskencyclerrifle/handling/"

SWEP.Animations = {
    ["fire"] = {
        Source = "shoot1",
		IKTimeLine = { { t = 0,  lhik = 1, rhik = 1} },
    },
    ["fire_sight"] = {
        Source = "shoot1_scope",
		IKTimeLine = { { t = 0,  lhik = 1, rhik = 1} },
    },
    ["reload"] = {
        Source = "reload_short",
		MinProgress = 0.8,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SHOTGUN,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 0.25},
			{s = path .. "wfoly_plr_sh_charlie725_reload_start.ogg", t = 0.0},
			{s = path .. "wfoly_plr_sh_charlie725_reload_open_01.ogg", t = 0.2},
            {s = path .. "wfoly_plr_sh_charlie725_reload_swing.ogg", t = 0.567},
			{s = path .. "wfoly_plr_sh_charlie725_reload_shellin_01.ogg", t = 1.267},
			{s = path .. "wfoly_plr_sh_charlie725_reload_close_01.ogg", t = 1.733},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 1.74},
			{s = path .. "wfoly_plr_sh_charlie725_reload_end.ogg", t = 2.2},
        },
    },
    ["reload_empty"] = {
        Source = "reload",
		MinProgress = 0.8,
        LHIK = true,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SHOTGUN,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 0.25},
			{s = path .. "wfoly_plr_sh_charlie725_reload_empty_start.ogg", t = 0.0},
			{s = path .. "wfoly_plr_sh_charlie725_reload_empty_open_01.ogg", t = 0.2},
            {s = path .. "wfoly_plr_sh_charlie725_reload_empty_swing.ogg", t = 0.7},
			{s = path .. "wfoly_plr_sh_charlie725_reload_empty_shellsin_v2_01.ogg", t = 1.167},
			{s = path .. "wfoly_plr_sh_charlie725_reload_empty_shellsin_v2_02.ogg", t = 1.5},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 2.05},
			{s = path .. "wfoly_plr_sh_charlie725_reload_empty_close_01.ogg", t = 2.0},
			{s = path .. "wfoly_plr_sh_charlie725_reload_empty_end.ogg", t = 2.333},
        },
    },
    ["ready"] = {
        Source = "draw",
		MinProgress = 0.8,
        LHIK = true,
        SoundTable = {
            {s = path .. "wfoly_plr_sh_charlie725_raise_first_start.ogg", t = 0.1},
			{s = path .. "wfoly_plr_sh_charlie725_raise_first_close_01.ogg", t = 0.25},
			{s = path .. "wfoly_plr_sh_charlie725_raise_first_end.ogg", t = 0.633},
        },
    },
    ["draw"] = {
        Source = "draw_short",
		MinProgress = 0.3,
        LHIK = true,
        SoundTable = {
            {s = path .. "wfoly_plr_sh_charlie725_raise_up.ogg", t = 0/30},
        },
    },
    ["holster"] = {
        Source = "holster",
        LHIK = true,
        SoundTable = {
            {s = path .. "wfoly_plr_sh_charlie725_drop_down.ogg", t = 0/30},
        },
    },
    ["idle"] = {
        Source = "idle",
    },
    ["idle_sprint"] = {
        Source = "sprint",
    },
    ["exit_sprint"] = {
        Source = "sprint_out",
		Time = 1.25,
    },
    ["enter_sprint"] = {
        Source = "sprint_in",
		IKTimeLine = { { t = 0,  lhik = 1, rhik = 1} },
		Time = 1.25,
    },
    ["exit_inspect"] = {
        Source = "lookat01",
		MinProgress = 0.9,
        SoundTable = {
            {s = path .. "wfoly_sh_charlie725_inspect_01.ogg", t = 0.033},
			{s = path .. "wfoly_sh_charlie725_inspect_02.ogg", t = 1.5},
			{s = path .. "wfoly_sh_charlie725_inspect_03.ogg", t = 2.5},
			{s = path .. "wfoly_sh_charlie725_inspect_04.ogg", t = 3.667},
			{s = path .. "wfoly_sh_charlie725_inspect_05.ogg", t = 4.367},
        },
    },
    ["bash"] = {
        Source = {"melee","melee2","melee3"},
        LHIK = true,
    },
    ["changefiremode"] = {
        Source = "firemode",
        SoundTable = {
            {s = path .. "weap_charlie725_fire_first_plr_01.ogg", t = 0/30},
        },
    },
    ["enter_bipod"] = {
        Source = "bipod_in",
    },
    ["exit_bipod"] = {
        Source = "bipod_out",
    },
}
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_dc15a_stun.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 -- Change this if you want to select the weapon with other number

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Republic Arsenal"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "DC-15a Stun"
SWEP.Trivia_Class = "Blaster Rifle"
SWEP.Trivia_Desc = "The DC-15A blaster rifle, known simply as the DC-15 blaster rifle, was a heavy blaster rifle manufactured by BlasTech Industries, as part of the DC-15 family. It was one of the standard-issue weapons of the Galactic Republic's clone troopers, an army of cloned soldiers in the Grand Army of the Republic, during the Clone Wars against the Confederacy of Independent Systems."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Condensed Tibanna-Gas"
SWEP.Trivia_Country = "Galactic Republic"
SWEP.IconOverride = "entities/arccw/kraken/republic-arsenal/dc15a_stun.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "00001000000000"

SWEP.MirrorVMWM = true
SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/kraken/republic/v_dc15a.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dlt19.mdl"
SWEP.MirrorWorldModel = "models/arccw/kraken/republic/v_dc15a_mirror.mdl"
SWEP.ViewModelFOV = 60

SWEP.WorldModelOffset = {
    pos = Vector(-13, 5, -5),
    ang = Angle(-15, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1,
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 25
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatDelayTime = 0.2
SWEP.HeatFix = true

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 38
SWEP.DamageMin = 20
SWEP.RangeMin = 0
SWEP.Range = 300
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TraceNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 250)

SWEP.HullSize = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 70

SWEP.Recoil = 0.2
SWEP.RecoilSide = 0.3
SWEP.RecoilRise = 0.4

SWEP.Delay = 60 / 300
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
		Mode = 2,
    },
	{
		Mode = 0,
   	}
}

SWEP.AccuracyMOA = 5
SWEP.HipDispersion = 200
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.95
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.30

-- Ammo, Sounds & MuzzleEffect
local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0

SWEP.FirstShootSound = "ArcCW_Kraken.SW_DC15A"
SWEP.ShootSound = "ArcCW_Kraken.SW_DC15A"
SWEP.DistantShootSound = "ArcCW_Kraken.StandardCorebass"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"

SWEP.MuzzleEffect = "blaster_muzzle_blue"
SWEP.MuzzleFlashColor = Color(0, 0, 255)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-4.599, -17.477, 2.947),
    Ang = Vector(0.122, 0.15, 0),
     Magnification = 1.5,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, 0, 2)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(4, -3, -1)
SWEP.SprintAng = Angle(0, 30, -15)

SWEP.CustomizePos = Vector(15, -5, 5)
SWEP.CustomizeAng = Angle(0, 40, 30)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Angle(0, 30, -15)

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        VMElements = {
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "Barrel",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(0, 30, 0),
                    ang = Angle(0, -90, 0)
                },
                IsMuzzleDevice = true
            },
        },
    },
    ["scope_attach"] = {
        VMBodygroups = {{ind = 1, bg = 1}, {ind = 4, bg = 0}},
    },
    ["grip_attach"] = {
        VMBodygroups = {{ind = 3, bg = 1}},
    },
    ["vibroknife"] = {
        VMBodygroups = {{ind = 5, bg = 1}},
    },
}

SWEP.Attachments = {
    {
        PrintName = "Optic",
        DefaultAttName = "DC-15 Holosight",
        Slot = "optic", 
        Bone = "Barrel",
        InstalledEles = {"scope_attach"},
        Offset = {
            vpos = Vector(0.66, 9.4, 2.5),
            vang = Angle(0, -90, 0),
        },
        CorrectiveAng = Angle(0, 180, 0),
        CorrectivePos = Vector(0, 0, 0),
    },          
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "Barrel",
        Offset = {
            vpos = Vector(0.66, 31.5, 0.9),
            vang = Angle(0, -90, 0),
        },
    },  
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Bone = "Barrel", 
        Offset = {
            vpos = Vector(-0.6, 25, 0.9),
            vang = Angle(-90, -90, 0),
        },
    },  
    {
        PrintName = "Foregrip",
        DefaultAttName = "None",
        Slot = {"foregrip"},
        Bone = "Barrel",
        InstalledEles = {"grip_attach"},
        Offset = {
            vpos = Vector(0.66, 6, -0.7),
            vang = Angle(0, -90, 0),
        },
    },    
    {
        PrintName = "Underbarrel",
        DefaultAttName = "None",
        Slot = {"vibroknife"},    
    },
    {
        PrintName = "Mode",
        DefaultAttName = "None",
        Slot = {"sw_mode", "sw_mode_rifle"},
    },   
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = "uc_fg",
    },   
    {
        PrintName = "Ammunition", 
        DefaultAttName = "Standard",
        Slot = {"ammo", "sw_ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Charms",
        DefaultAttName = "None",
        Slot = {"charm"},
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Bone = "Barrel",
        Offset = {
            vpos = Vector(1.7, 7, 1.8),
            vang = Angle(0, -90, 0),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        Bone = "dc15a_DC15_mat",
        Offset = {
            vpos = Vector(1.2, -9, 0.7),
            vang = Angle(0, -90, 0),
        },
    },         
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "Neutral"
    },
    ["fire"] = {
        Time = 1,
        Source = {"shoot", "shoot2"},
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_rifle.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_rifle.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "arccw/kraken/republic/reload_basic.wav", t = 2 / 10},
            {s = "ArcCW_Kraken.Overheat", t = 5 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 65 / 30},
            {s = "ArcCW_Kraken.Grab", t = 70 / 30},
        },
    },
    ["fix"] = {
        Source = "overheat", 
        Mult = 4.5,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 55 / 30},
            {s = "ArcCW_Kraken.Grab", t = 53 / 30},
        },
    },
}
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_dc15a_train.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 -- Change this if you want to select the weapon with other number

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Republic Arsenal"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "DC-15a Training"
SWEP.Trivia_Class = "Blaster Rifle"
SWEP.Trivia_Desc = "The DC-15A blaster rifle, known simply as the DC-15 blaster rifle, was a heavy blaster rifle manufactured by BlasTech Industries, as part of the DC-15 family. It was one of the standard-issue weapons of the Galactic Republic's clone troopers, an army of cloned soldiers in the Grand Army of the Republic, during the Clone Wars against the Confederacy of Independent Systems."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Condensed Tibanna-Gas"
SWEP.Trivia_Country = "Galactic Republic"
SWEP.IconOverride = "entities/arccw/kraken/republic-arsenal/dc15a_training.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "00001000000000"

SWEP.MirrorVMWM = true
SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/kraken/republic/v_dc15a.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dlt19.mdl"
SWEP.MirrorWorldModel = "models/arccw/kraken/republic/v_dc15a_mirror.mdl"
SWEP.ViewModelFOV = 60

SWEP.WorldModelOffset = {
    pos = Vector(-13, 5, -5),
    ang = Angle(-15, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1,
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 25
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatDelayTime = 0.2
SWEP.HeatFix = true

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 1
SWEP.DamageMin = 1
SWEP.RangeMin = 0
SWEP.Range = 300
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TraceNum = 1
SWEP.Tracer = "tracer_orange"
SWEP.TracerCol = Color(250, 120, 0)

SWEP.HullSize = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 70

SWEP.Recoil = 0.2
SWEP.RecoilSide = 0.3
SWEP.RecoilRise = 0.4

SWEP.Delay = 60 / 300
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
		Mode = 2,
    },
	{
		Mode = 0,
   	}
}

SWEP.AccuracyMOA = 5
SWEP.HipDispersion = 200
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.95
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.30

-- Ammo, Sounds & MuzzleEffect
local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0

SWEP.FirstShootSound = "ArcCW_Kraken.SW_DC15A"
SWEP.ShootSound = "ArcCW_Kraken.SW_DC15A"
SWEP.DistantShootSound = "ArcCW_Kraken.StandardCorebass"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"

SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.MuzzleFlashColor = Color(250, 120, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-4.599, -17.477, 2.947),
    Ang = Vector(0.122, 0.15, 0),
     Magnification = 1.5,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, 0, 2)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(4, -3, -1)
SWEP.SprintAng = Angle(0, 30, -15)

SWEP.CustomizePos = Vector(15, -5, 5)
SWEP.CustomizeAng = Angle(0, 40, 30)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Angle(0, 30, -15)

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        VMElements = {
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "Barrel",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(0, 30, 0),
                    ang = Angle(0, -90, 0)
                },
                IsMuzzleDevice = true
            },
        },
    },
    ["scope_attach"] = {
        VMBodygroups = {{ind = 1, bg = 1}, {ind = 4, bg = 0}},
    },
    ["grip_attach"] = {
        VMBodygroups = {{ind = 3, bg = 1}},
    },
    ["vibroknife"] = {
        VMBodygroups = {{ind = 5, bg = 1}},
    },
}

SWEP.Attachments = {
    {
        PrintName = "Optic",
        DefaultAttName = "DC-15 Holosight",
        Slot = "optic", 
        Bone = "Barrel",
        InstalledEles = {"scope_attach"},
        Offset = {
            vpos = Vector(0.66, 9.4, 2.5),
            vang = Angle(0, -90, 0),
        },
        CorrectiveAng = Angle(0, 180, 0),
        CorrectivePos = Vector(0, 0, 0),
    },          
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "Barrel",
        Offset = {
            vpos = Vector(0.66, 31.5, 0.9),
            vang = Angle(0, -90, 0),
        },
    },  
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Bone = "Barrel", 
        Offset = {
            vpos = Vector(-0.6, 25, 0.9),
            vang = Angle(-90, -90, 0),
        },
    },  
    {
        PrintName = "Foregrip",
        DefaultAttName = "None",
        Slot = {"foregrip"},
        Bone = "Barrel",
        InstalledEles = {"grip_attach"},
        Offset = {
            vpos = Vector(0.66, 6, -0.7),
            vang = Angle(0, -90, 0),
        },
    },  
    {
        PrintName = "Underbarrel",
        DefaultAttName = "None",
        Slot = {"vibroknife"},    
    },  
    {
        PrintName = "Mode",
        DefaultAttName = "None",
        Slot = {"sw_mode", "sw_mode_rifle"},
    },   
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = "uc_fg",
    },   
    {
        PrintName = "Ammunition", 
        DefaultAttName = "Standard",
        Slot = "ammo",
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Charms",
        DefaultAttName = "None",
        Slot = {"charm"},
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Bone = "Barrel",
        Offset = {
            vpos = Vector(1.7, 7, 1.8),
            vang = Angle(0, -90, 0),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        Bone = "dc15a_DC15_mat",
        Offset = {
            vpos = Vector(1.2, -9, 0.7),
            vang = Angle(0, -90, 0),
        },
    },         
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "Neutral"
    },
    ["fire"] = {
        Time = 1,
        Source = {"shoot", "shoot2"},
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_rifle.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_rifle.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "arccw/kraken/republic/reload_basic.wav", t = 2 / 10},
            {s = "ArcCW_Kraken.Overheat", t = 5 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 65 / 30},
            {s = "ArcCW_Kraken.Grab", t = 70 / 30},
        },
    },
    ["fix"] = {
        Source = "overheat", 
        Mult = 4.5,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 55 / 30},
            {s = "ArcCW_Kraken.Grab", t = 53 / 30},
        },
    },
}
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_dc15le.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 -- Change this if you want to select the weapon with other number

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Republic Arsenal"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "DC-15le"
SWEP.Trivia_Class = "Blaster Rifle"
SWEP.Trivia_Desc = "The DC-15LE was a blaster rifle and variant of the standard DC-15A blaster rifle, which could be modified for long-range engagements or to fire explosive blaster bolts."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Condensed Tibanna-Gas"
SWEP.Trivia_Country = "Galactic Republic"
SWEP.IconOverride = "entities/arccw/kraken/republic-arsenal/dc15le.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "00101000000000"

SWEP.MirrorVMWM = true
SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/kraken/republic/v_dc15a.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dlt19.mdl"
SWEP.MirrorWorldModel = "models/arccw/kraken/republic/v_dc15a_mirror.mdl"
SWEP.ViewModelFOV = 60

SWEP.WorldModelOffset = {
    pos = Vector(-13, 5, -5),
    ang = Angle(-15, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1,
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 15
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatDelayTime = 0.2
SWEP.HeatFix = true

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 55
SWEP.DamageMin = 20
SWEP.RangeMin = 0
SWEP.Range = 425
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TraceNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 250)

SWEP.HullSize = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 40

SWEP.Recoil = 0.75
SWEP.RecoilSide = 0.3
SWEP.RecoilRise = 0.4

SWEP.Delay = 60 / 220
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
		Mode = 2,
    },
	{
		Mode = 0,
   	}
}

SWEP.AccuracyMOA = 5
SWEP.HipDispersion = 200
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.95
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.30

-- Ammo, Sounds & MuzzleEffect
local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0

SWEP.FirstShootSound = "ArcCW_Kraken.SW_DC15A"
SWEP.ShootSound = "ArcCW_Kraken.SW_DC15A"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"

SWEP.MuzzleEffect = "blaster_muzzle_blue"
SWEP.MuzzleFlashColor = Color(0, 0, 250)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-4.599, -17.477, 2.947),
    Ang = Vector(0.122, 0.15, 0),
     Magnification = 1.5,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, 0, 2)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(4, -3, -1)
SWEP.SprintAng = Angle(0, 30, -15)

SWEP.CustomizePos = Vector(15, -5, 5)
SWEP.CustomizeAng = Angle(0, 40, 30)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Angle(0, 30, -15)

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        VMElements = {
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "Barrel",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(0, 30, 0),
                    ang = Angle(0, -90, 0)
                },
                IsMuzzleDevice = true
            },
        },
    },
    ["scope_attach"] = {
        VMBodygroups = {{ind = 1, bg = 1}, {ind = 4, bg = 0}},
    },
    ["grip_attach"] = {
        VMBodygroups = {{ind = 3, bg = 1}},
    },
    ["muzzle_attach"] = {
        VMBodygroups = {{ind = 2, bg = 0}},
    },
    ["vibroknife"] = {
        VMBodygroups = {{ind = 5, bg = 1}},
    },
}

SWEP.Attachments = {
    {
        PrintName = "Optic",
        DefaultAttName = "DC-15 Holosight",
        Slot = "optic", 
        Bone = "Barrel",
        InstalledEles = {"scope_attach"},
        Offset = {
            vpos = Vector(0.66, 9.4, 2.5),
            vang = Angle(0, -90, 0),
        },
        CorrectiveAng = Angle(0, 180, 0),
        CorrectivePos = Vector(0, 0, 0),
    },          
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "Barrel",
        InstalledEles = {"muzzle_attach"},
        Offset = {
            vpos = Vector(0.66, 31.5, 0.9),
            vang = Angle(0, -90, 0),
        },
    },  
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Bone = "Barrel", 
        Offset = {
            vpos = Vector(-0.6, 25, 0.9),
            vang = Angle(-90, -90, 0),
        },
    },  
    {
        PrintName = "Foregrip",
        DefaultAttName = "None",
        Slot = {"foregrip"},
        Bone = "Barrel",
        InstalledEles = {"grip_attach"},
        Offset = {
            vpos = Vector(0.66, 6, -0.7),
            vang = Angle(0, -90, 0),
        },
    },
    {
        PrintName = "Mode",
        DefaultAttName = "None",
        Slot = {"sw_mode", "sw_mode_rifle"},
    },   
    {
        PrintName = "Underbarrel",
        DefaultAttName = "None",
        Slot = {"vibroknife"},    
    },    
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = "uc_fg",
    },   
    {
        PrintName = "Ammunition", 
        DefaultAttName = "Standard",
        Slot = "ammo",
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Charms",
        DefaultAttName = "None",
        Slot = {"charm"},
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Bone = "Barrel",
        Offset = {
            vpos = Vector(1.7, 7, 1.8),
            vang = Angle(0, -90, 0),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        Bone = "dc15a_DC15_mat",
        Offset = {
            vpos = Vector(1.2, -9, 0.7),
            vang = Angle(0, -90, 0),
        },
    },         
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "Neutral"
    },
    ["fire"] = {
        Time = 1,
        Source = {"shoot", "shoot2"},
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_rifle.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_rifle.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "arccw/kraken/republic/reload_basic.wav", t = 2 / 10},
            {s = "ArcCW_Kraken.Overheat", t = 5 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 65 / 30},
            {s = "ArcCW_Kraken.Grab", t = 70 / 30},
        },
    },
    ["fix"] = {
        Source = "overheat", 
        Mult = 4.5,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 55 / 30},
            {s = "ArcCW_Kraken.Grab", t = 53 / 30},
        },
    },
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_dh17.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_dl18e.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_dlt16.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 4 

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "DLT-16"
SWEP.Trivia_Class = "Prototype Heavy Rifle"
SWEP.Trivia_Desc = "Before the DLT-19, the DLT-16 existed as a prototype of a Heavy Rifle for Infantry usage. This weapon, like many others, continued to use bullet casings, however, it had a special system that when they were hammered, the explosion of the tibanna gas was compressed and transformed into a blaster projectile. The DLT-19 heavy blaster rifle was a model of heavy blaster rifle manufactured by BlasTech Industries. They were used by regular stormtroopers and Heavy Weapons Stormtroopers of the Galactic Empire, but they also saw use by other parties, including the Alliance to Restore the Republic and certain bounty hunters."
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.IconOverride = "entities/kraken/galactic/dlt16.png"

-- Base
SWEP.DefaultBodygroups = "000010000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/galactic/v_dlt16.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dlt19.mdl"

SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(-1, 1, -2.4),
    ang = Angle(-5, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 60
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 34
SWEP.DamageMin = 23
SWEP.RangeMin = 0
SWEP.Range = 370
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(250, 100, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_orange"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 100

SWEP.Recoil = 0.74
SWEP.RecoilSide = 0.34
SWEP.RecoilRise = 0.98
SWEP.MaxRecoilBlowback = 2
SWEP.RecoilPunch = 1
SWEP.RecoilVMShake = 2

SWEP.Delay = 60 / 700
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
		Mode = 2,
    },
    {
        Mode = -3,
        PostBurstDelay = 0.1,
        RunawayBurst = false,
        Mult_RPM = 2,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 250
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.86
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "ArcCW_Kraken.SW_DLT16"
SWEP.ShootSound = "ArcCW_Kraken.SW_DLT16"
SWEP.DistantShootSound = "ArcCW_Kraken.StandardCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 100, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-3.65, -2, 1.3),
    Ang = Angle(1.8, 0.3 , 4.25),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "shotgun"
SWEP.HoldtypeSights = "ar2"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(-2, 2, -0.5)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(4.019, -5.226, -0.805)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(8, 0, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 2)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.BarrelOffsetSighted = Vector(0, 0, -1)
SWEP.BarrelOffsetHip = Vector(2, 0, -2)

SWEP.HolsterPos = Vector(4, -3, 0)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.DefaultElements = {}
SWEP.AttachmentElements = {
    ["muzzle_attach"] = {
        VMBodygroups = {{ind = 3, bg = 3}},
    },
    ["laser_attach"] = {
        VMBodygroups = {{ind = 6, bg = 1}},
    },
    ["grip_attach"] = {
        VMBodygroups = {{ind = 5, bg = 1}},
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Sight", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "j_lever",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(2.5, -0.5, -0),
            vang = Angle(180, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        Bone = "tag_attachments",
        InstalledEles = {"muzzle_attach"},
        Offset = {
            vpos = Vector(36, -0.05, 0),
            vang = Angle(0, 0, 0),
        },
    },  
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "tag_attachments",
        InstalledEles = {"laser_attach"},
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(27, 1, 0),
            vang = Angle(0, 0, -90),
        },
    },
    {
        PrintName = "Foregrip", 
        DefaultAttName = "None",
        Slot = "foregrip",
        Bone = "tag_attachments",
        InstalledEles = {"grip_attach"},
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Offset = {
            vpos = Vector(15.8, 0, -0.8),
            vang = Angle(0, -0, 0),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.5, 0.5, 0.5),
        WMScale = Vector(0.5, 0.5, 0.5),
        Bone = "tag_attachments",
        Offset = {
            vpos = Vector(0.2, 0.1, -2.3),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Bone = "tag_attachments",
        Offset = {
            vpos = Vector(0.45, -0.65, -2.5),
            vang = Angle(90, 0, -90),
        },
    },   
}

-- Don't touch this unless you know what you're doing
local path = "arccw/kraken/sw_galactic/weapons/dlt19/handling/"

SWEP.Animations = {
    ["fire"] = {
        Source = "shoot1",
		IKTimeLine = { { t = 0,  lhik = 1, rhik = 1} },
    },
    ["reload_empty"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2, 
        LHIK = true,
		MinProgress = 0.95,
        SoundTable = {
			{s = path .. "wfoly_plr_lm_mgolf34_reload_empty_start.ogg", t = 0.1/30},
            {s = "ArcCW_Kraken.Overheat", t = 28/30},
			{s = path .. "wfoly_plr_lm_mgolf34_reload_empty_boltopen_01.ogg", t = 28/30},
			{s = path .. "wfoly_plr_lm_mgolf34_reload_empty_boltclose_01.ogg", t = 41/30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 41/30},
			{s = path .. "wfoly_plr_lm_mgolf34_reload_empty_open.ogg", t = 51/30},
			{s = path .. "wfoly_plr_lm_mgolf34_reload_empty_coveropen_01.ogg", t = 56/30},
			{s = path .. "wfoly_plr_lm_mgolf34_reload_empty_adjust.ogg", t = 69/30},
			{s = path .. "wfoly_plr_lm_mgolf34_reload_empty_drumoff_01.ogg", t = 99/30},
			{s = path .. "wfoly_plr_lm_mgolf34_reload_empty_rattle.ogg", t = 109/30},
			{s = path .. "wfoly_plr_lm_mgolf34_reload_empty_drumon_01.ogg", t = 148/30},
			{s = path .. "wfoly_plr_lm_mgolf34_reload_empty_hands.ogg", t = 172/30},
			{s = path .. "wfoly_plr_lm_mgolf34_reload_empty_belt_01.ogg", t = 189/30},
			{s = path .. "wfoly_plr_lm_mgolf34_reload_empty_coverclose_01.ogg", t = 231/30},
			{s = path .. "wfoly_plr_lm_mgolf34_reload_empty_end.ogg", t = 232/30},
			{s = path .. "wfoly_plr_lm_mgolf34_reload_empty_hands.ogg", t = 250/30},
			{s = path .. "wfoly_plr_lm_mgolf34_reload_empty_pull.ogg", t = 255/30},
        },
    },
    ["reload"] = {
        Source = "jam_fix",
        LHIK = true,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2, 
        SoundTable = {
			{s = path .. "wfoly_plr_lm_mgolf34_reload_empty_start.ogg", t = 0.1/30},
            {s = "ArcCW_Kraken.Overheat", t = 12/30},
			{s = path .. "wfoly_plr_lm_mgolf34_reload_empty_boltopen_01.ogg", t = 12/30},
			{s = path .. "wfoly_plr_lm_mgolf34_reload_empty_boltclose_01.ogg", t = 24/30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 24/30},
            {s = path .. "wfoly_plr_lm_mgolf34_reload_fast_end.ogg", t = 24/30},
        },
    },
    ["ready"] = {
        Source = "draw",
        LHIK = true,
		MinProgress = 0.7,
        SoundTable = {
            {s = path .. "wfoly_plr_lm_mgolf34_raise_first_pull.ogg", t = 0.1/30},
            {s = path .. "wfoly_plr_lm_mgolf34_raise_first_start.ogg", t = 6/30},
			{s = path .. "wfoly_plr_lm_mgolf34_raise_first_boltopen_01.ogg", t = 31/30},
			{s = path .. "wfoly_plr_lm_mgolf34_raise_first_boltclose_01.ogg", t = 40/30},
			{s = path .. "wfoly_plr_lm_mgolf34_raise_first_end.ogg", t = 56/30},
        },
    },
    ["draw"] = {
        Source = "draw_short",
        LHIK = true,
		MinProgress = 0.5,
        SoundTable = {
            {s = path .. "wfoly_plr_lm_mgolf34_raise_up.ogg", t = 10/30},
            {s = path .. "wfoly_plr_lm_mgolf34_raise_settle.ogg", t = 34/30},
        },
    },
    ["holster"] = {
        Source = "holster",
        LHIK = true,
        SoundTable = {
            {s = path .. "wfoly_plr_lm_mgolf34_reload_raise.ogg", t = 0.1/30},
            {s = path .. "wfoly_plr_lm_mgolf34_reload_open.ogg", t = 10/30},
        },
    },
    ["idle"] = {
        Source = "idle",
    },
    ["exit_inspect"] = {
        Source = "lookat01",
        LHIK = true,
        SoundTable = {
            {s = path .. "wfoly_lm_mgolf34_inspect_01.ogg", t = 0.1/30},
			{s = path .. "wfoly_lm_mgolf34_inspect_02.ogg", t = 54/30},
			{s = path .. "wfoly_lm_mgolf34_inspect_03.ogg", t = 120/30},
        },
    },
    ["bash"] = {
        LHIK = true,
        Source = {"melee","melee2","melee3"},
    },
    ["fix"] = {
        Mult = 2,
        LHIK = true,
        Source = "jam",
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 0.1/30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 10/30},
            {s = "ArcCW_Kraken.Grab", t = 11 / 30},
        },
    },
    ["enter_bipod"] = {
        Source = "bipod_in",
    },
    ["exit_bipod"] = {
        Source = "bipod_out",
    },
}

--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_dlt20c.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "DLT-20c"
SWEP.Trivia_Class = "Blaster Light Carbine"
SWEP.Trivia_Desc = "The DLT-20A blaster rifle, also known as the DLT-20A laser rifle, was a model of blaster rifle and longblaster produced by BlasTech Industries. Members of the Galactic Empire's Stormtrooper Corps sometimes used DLT-20As instead of their standard issue E-11 medium blaster rifles. IG-assassin droid IG-11 carried this model of rifle, without the scope attached. Another type of rifle, the pulse cannon, utilized the frame assembly of a DLT-20A. Han Solo used a DLT-20A as a sniper rifle during the Battle of Vrogas Vas."
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.IconOverride = "entities/kraken/galactic/dlt20c.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "01000000000000"

SWEP.UseHands = true
SWEP.MirrorVMWM = true
SWEP.ViewModel = "models/arccw/kraken/galactic/v_dlt20a.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 70

SWEP.WorldModelOffset = {
    pos = Vector(-7, 3, -3),
    ang = Angle(-15, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1,
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 20
SWEP.HeatDissipation = 7
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 36
SWEP.DamageMin = 22
SWEP.RangeMin = 0
SWEP.Range = 500
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(0, 250, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_green"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 31

SWEP.Recoil = 0.75
SWEP.RecoilSide = 0.3
SWEP.RecoilRise = 0.75

SWEP.Delay = 60 / 350
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
		Mode = 2,
    },
    {
        Mode = -3,
        Mult_RPM = 3,
        PostBurstDelay = 0.1,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 150
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0

SWEP.FirstShootSound = "ArcCW_Kraken.SW_DLT20"
SWEP.ShootSound = "ArcCW_Kraken.SW_DLT20"
SWEP.DistantShootSound = "ArcCW_Kraken.StandardCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_green"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 250, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-2.994, 0, 0.004),
    Ang = Vector(2.042, 0, 0),
    Magnification = 1.15,
    SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
    SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
    ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(-1, 2, -1)
SWEP.ActiveAng = Angle(2, 0, -2)

SWEP.SprintPos = Vector(4.019, -5.226, -3)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.HolsterPos = Vector(0, 0, 0)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 0, 1)

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "E11S_CONTR",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(-2.4, 20, 0),
                   ang = Angle(-90, -90, 0),
               },
               IsMuzzleDevice = true,
           }
        }, 
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Optics", 
        DefaultAttName = "Iron Sight",
        Slot = "optic",
        Bone = "E11S_CONTR",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(0.1, 1, 2.4),
            vang = Angle(0, -90, 0),
        },
        CorrectiveAng = Angle(0, 180, 0),
        CorrectivePos = Vector(0, 0, -0.05),
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(-0.8, 8.5, 0.9),
            vang = Angle(-90, -90, 0),
        },
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Standard",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        VMScale = Vector(1.5, 1.5, 1.5),
        WMScale = Vector(1.5, 1.5, 1.5),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(-0.1, 17.7, 0.9),
            vang = Angle(0, -90, 0),
        },
    },  
    {
        PrintName = "Foregrip", 
        DefaultAttName = "None",
        Slot = "foregrip",
        Bone = "E11S_CONTR",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Offset = {
            vpos = Vector(0., 6, 0.2),
            vang = Angle(5, -90, 0),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(0.8, -0.2, -0.8),
            vang = Angle(0, -90, 0),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(0.8, 0.8, 0.8),
        WMScale = Vector(0.8, 0.8, 0.8),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(0.9, -0.33, 0.2),
            vang = Angle(0, -90, 0),
        },
    },   
}
-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
	["fire"] = {
        Source = false,
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_e5.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 -- Change this if you want to select the weapon with other number

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Confederacy Arsenal"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "E-5"
SWEP.Trivia_Class = "Blaster, Rifle"
SWEP.Trivia_Desc = "The E-5 blaster rifle, also known as Droid blaster, was a bulky blaster rifle manufactured by Baktoid Armor Workshop. It was reverse-engineered from a BlasTech design of the E-series. The E-5 visually resembled a blaster rifle nicknamed 'Beti' from the High Republic Era. The E-5C heavy blaster rifle was identical to the default E-5 blaster rifle, save for an added wooden stock and modified barrel."
SWEP.Trivia_Manufacturer = "Baktoid Armor Workshop"
SWEP.Trivia_Calibre = "Condensed Tibanna-Gas"
SWEP.Trivia_Country = "Confederacy of Independent Systems"
SWEP.IconOverride = "entities/arccw/kraken/republic-arsenal/e5.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "00001000000000"

SWEP.MirrorVMWM = true
SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/kraken/cis/v_e5.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.MirrorWorldModel = nil
SWEP.ViewModelFOV = 65


SWEP.WorldModelOffset = {
    pos = Vector(-8.6, 5.5, -5),
    ang = Angle(-15, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1,
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 25
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatDelayTime = 0.2
SWEP.HeatFix = true

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 38
SWEP.DamageMin = 20
SWEP.RangeMin = 0
SWEP.Range = 300
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TraceNum = 1
SWEP.Tracer = "tracer_red"
SWEP.TracerCol = Color(250, 0, 0)

SWEP.HullSize = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 50

SWEP.Recoil = 0.5
SWEP.RecoilSide = 0.3
SWEP.RecoilRise = 0.6

SWEP.Delay = 60 / 300
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
		Mode = 2,
    },
	{
		Mode = 0,
   	}
}

SWEP.AccuracyMOA = 5
SWEP.HipDispersion = 200
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.95
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.30

-- Ammo, Sounds & MuzzleEffect
local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_ITEM)
    end
end

SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0

SWEP.FirstShootSound = "ArcCW_Kraken.SW_E5"
SWEP.ShootSound = "ArcCW_Kraken.SW_E5"
SWEP.DistantShootSound = "ArcCW_Kraken.StandardCorebass"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"

SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-4.851, -1.285, 0.674),
    Ang = Vector(0, 0, 0),
     Magnification = 1.5,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.SprintPos = Vector(2, -1, 0)
SWEP.SprintAng = Angle(-10, 26, 0)

SWEP.CustomizePos = Vector(10, 0, 2)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 3)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(-3, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        VMElements = {
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "dlt34",
                Scale = Vector(0, 0, 0),                
                Offset = {
                    pos = Vector(-2, 2, 20),
                    ang = Angle(90, 0, 0),
                },
                IsMuzzleDevice = true,
            }
         }, 
    },
    ["scope_attach"] = {
        VMBodygroups = {{ind = 1, bg = 1}},
    },
}

SWEP.Attachments = {
    {
        PrintName = "Optic",
        DefaultAttName = "E-5 Holosight",
        Slot = "optic", 
        Bone = "dlt34",
        InstalledEles = {"scope_attach"},
        Offset = {
            vpos = Vector(-0.15, -4.1, 0.8),
            vang = Angle(90, 0, -90),
        },
        CorrectiveAng = Angle(0, 0, 0),
        CorrectivePos = Vector(0, 0, 0),
    },          
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "dlt34",
        Offset = {
            vpos = Vector(-0.15, -1.85, 14.8),
            vang = Angle(90, 0, -90),
        },
    },  
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Bone = "dlt34", 
        Offset = {
            vpos = Vector(-1.05, -1.9, 10),
            vang = Angle(90, 0, -180),
        },
    },  
    {
        PrintName = "Mode",
        DefaultAttName = "None",
        Slot = {"sw_mode", "sw_mode_rifle"},
    },   
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = "uc_fg",
    },   
    {
        PrintName = "Ammunition", 
        DefaultAttName = "Standard",
        Slot = "ammo",
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Charms",
        DefaultAttName = "None",
        Slot = {"charm"},
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Bone = "dlt34",
        Offset = {
            vpos = Vector(0.85, -0.05, 4.3),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Bone = "dlt34",
        Offset = {
            vpos = Vector(1.4, -1.5, 3.25),
            vang = Angle(90, 0, -90),
        },
    },         
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "Neutral"
    },
    ["fire"] = {
        Time = 0.6,
        Source = {"fire"},
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_rifle.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_rifle.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "overheat", 
        Mult = 2.2,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 55 / 30},
            {s = "ArcCW_Kraken.Grab", t = 53 / 30},
        },
    },
    ["fix"] = {
        Source = "overheat", 
        Mult = 2.5,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 55 / 30},
            {s = "ArcCW_Kraken.Grab", t = 53 / 30},
        },
    },
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_e9.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_el16hfe.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "EL-16HFE"
SWEP.Trivia_Class = "Blaster Carabine"
SWEP.Trivia_Desc = "The EL-16 blaster rifle was a blaster rifle manufactured by BlasTech Industries. A Heavy Field Edition of the EL-16, the EL-16HFE blaster rifle, was also used by the Resistance. The EL-16 was outdated by the time of the First Order's rise to power. One was given to Finn by Han Solo, but he lost it when Maz's castle was destroyed. He got a new one of the same model at the Resistance base on D'Qar. Both it and the EL-16HFE were utilized during the Battle of Crait."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/galactic/el16hfe.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "01000000000000"

SWEP.UseHands = true
SWEP.MirrorVMWM = true
SWEP.ViewModel = "models/arccw/kraken/galactic/v_el16.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 70

SWEP.WorldModelOffset = {
    pos = Vector(-7, 3, -3),
    ang = Angle(-15, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1,
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 15
SWEP.HeatDissipation = 7
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 42
SWEP.DamageMin = 29
SWEP.RangeMin = 0
SWEP.Range = 290
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(0, 250, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_green"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 35

SWEP.Recoil = 0.86
SWEP.RecoilSide = 0.40
SWEP.RecoilRise = 0.63

SWEP.Delay = 60 / 270
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
		Mode = 2,
    },
    {
        Mode = -3,
        Mult_RPM = 3,
        PostBurstDelay = 0.1,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 100
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 90
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "ArcCW_Kraken.SW_EL16"
SWEP.ShootSound = "ArcCW_Kraken.SW_EL16"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_green"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 250, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-3.027, -2, -1.03),
    Ang = Vector(2.8, 0, -0.5),
    Magnification = 1.15,
    SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
    SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
    ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.HoltypeCustomize = "slam"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, 0, -2)
SWEP.ActiveAng = Angle(2, 0, 0)

SWEP.SprintPos = Vector(4.019, -5.226, -0.805)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(10, 0, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 0, 1)

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "E11S_CONTR",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(-2.4, 16, -2),
                   ang = Angle(-90, -90, 0),
               },
               IsMuzzleDevice = true,
           }
        }, 
    },
    ["muzzle_attach"] = {
        VMBodygroups = {{ind = 1, bg = 3}},
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Optics", 
        DefaultAttName = "Iron Sight",
        Slot = "optic",
        Bone = "E11S_CONTR",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(0.1, 0, 3.7),
            vang = Angle(0, -90, 0),
        },
        CorrectiveAng = Angle(0, 180, 0),
        CorrectivePos = Vector(0, 0, -0.01),
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(-0.8, 8.5, 0.5),
            vang = Angle(-90, -90, 0),
        },
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Standard",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        VMScale = Vector(1.5, 1.5, 1.5),
        WMScale = Vector(1.5, 1.5, 1.5),
        InstalledEles = {"muzzle_attach"},
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(-0, 10.9, 1.2),
            vang = Angle(0, -90, 0),
        },
    },  
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(1.3, -6, 0.5),
            vang = Angle(0, -90, 0),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(0.8, 0.8, 0.8),
        WMScale = Vector(0.8, 0.8, 0.8),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(1.3, -2, 0.4),
            vang = Angle(0, -90, 0),
        },
    },   
}
-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
	["fire"] = {
        Source = false,
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatFix", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_glie44_e.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 2

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "GLIE-44e"
SWEP.Trivia_Class = "Blaster Pistol"
SWEP.Trivia_Desc = "The Glie-44 blaster pistol was a blaster pistol manufactured by Eirriss Ryloth Defense Tech and named after Twi'lek freedom fighter Gobi Glie. The blaster had a lightweight, rugged construction. The pistol had a power cartridge as ammunition and a reactant gas port cap in its stock. General Leia Organa also uses the Glie-44 as she prefers compact hand weapons."
SWEP.Trivia_Manufacturer = "Eirriss Ryloth Defense Tech"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/galactic/glie44e.png"

-- Base
SWEP.DefaultBodygroups = "010000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/galactic/v_glie44.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(-18, 6.7, -5.75),
    ang = Angle(0, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 8
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 35
SWEP.DamageMin = 28
SWEP.RangeMin = 0
SWEP.Range = 300
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(0, 0, 250)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_blue"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 12

SWEP.Recoil = 0.77
SWEP.RecoilSide = 0.6
SWEP.RecoilRise = 0.9

SWEP.Delay = 60 / 170
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
        Mode = -3,
        PostBurstDelay = 0.1,
        RunawayBurst = false,
        Mult_RPM = 2,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0.5
SWEP.HipDispersion = 100
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "ArcCW_Kraken.SW_GLIE44"
SWEP.ShootSound = "ArcCW_Kraken.SW_GLIE44"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_blue"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 0, 250)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-5.025, -11.296, 1.3),
    Ang = Angle(0.5,0,0),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL

SWEP.SprintPos = Vector(2.019, -5.226, -2)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.CustomizePos = Vector(10, -10, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 2)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(-3, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.DefaultElements = {}
SWEP.AttachmentElements = {}
SWEP.Attachments = {     
    {
        PrintName = "Sight", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "DC-15SA",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(-0.01, -2.1, -3),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Internal Compression",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
    },  
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "DC-15SA",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(-0.7, -1.25, 1.3),
            vang = Angle(90, 0, 180),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.5, 0.5, 0.5),
        WMScale = Vector(0.5, 0.5, 0.5),
        Bone = "DC-15SA",
        Offset = {
            vpos = Vector(0.8, -1.2, -2),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(0.8, 0.8, 0.8),
        WMScale = Vector(0.8, 0.8, 0.8),
        Bone = "DC-15SA",
        Offset = {
            vpos = Vector(0.79, -1.3, -4),
            vang = Angle(90, 0, -90),
        },
    },   
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = false,
    },
    ["idle_iron"] = {
        Source = false,
    },
	["fire"] = {
        Source = {"fire"},
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatFix", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_relbv15.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "Relby V-15"
SWEP.Trivia_Class = "Blaster Carbine"
SWEP.Trivia_Desc = "The Relby V-15 Targeting Rifle is a blaster featured in Star Wars Battlefront, it is one of the four weapons added in the Outer Rim expansion pack. It is also the weapon of choice for the Trandoshan Bounty Hunter Bossk."
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Calibre = "Merr. Sonn. Munitions Inc."
SWEP.IconOverride = "entities/kraken/galactic/relbv15.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "00000000000000"

SWEP.UseHands = true
SWEP.MirrorVMWM = true
SWEP.ViewModel = "models/arccw/kraken/galactic/v_relby_v15.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 70

SWEP.WorldModelOffset = {
    pos = Vector(-7, 3, -3),
    ang = Angle(-15, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1,
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 5
SWEP.HeatDissipation = 7
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 97
SWEP.DamageMin = 56
SWEP.RangeMin = 0
SWEP.Range = 500
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(0, 250, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_green"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 20

SWEP.Recoil = 1.2
SWEP.RecoilSide = 0.54
SWEP.RecoilRise = 0.97
SWEP.MaxRecoilBlowback = 2
SWEP.RecoilPunch = 1.5
SWEP.RecoilVMShake = 2

SWEP.Delay = 60 / 190
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
        Mode = -3,
        Mult_RPM = 3,
        PostBurstDelay = 0.1,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 150
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 90
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "ArcCW_Kraken.SW_RELBY"
SWEP.ShootSound = "ArcCW_Kraken.SW_RELBY"
SWEP.DistantShootSound = "ArcCW_Kraken.StandardCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_green"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 250, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-3.043, 0, 1.55),
    Ang = Vector(2, -0.3, -2),
    Magnification = 1.15,
    SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
    SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
    ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN

SWEP.ActivePos = Vector(-2, 2, 0)
SWEP.ActiveAng = Angle(0, 0.3, -4)

SWEP.SprintPos = Vector(4.019, -5.226, -0.805)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(10, 4, 2)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 0, 1)

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "E11S_CONTR",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(-2.4, 14, 0),
                   ang = Angle(-90, -90, 0),
               },
               IsMuzzleDevice = true,
           }
        }, 
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Optics", 
        DefaultAttName = "Iron Sight",
        Slot = "optic",
        Bone = "E11S_CONTR",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(0.1, -0.4, 1.1),
            vang = Angle(0, -90, 0),
        },
        CorrectiveAng = Angle(0, 180, 0),
        CorrectivePos = Vector(0, 0, -0.01),
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(-0.8, 8.45, -0.2),
            vang = Angle(-90, -90, 0),
        },
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Standard",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        VMScale = Vector(1.1, 1.1, 1.1),
        WMScale = Vector(1.1, 1.1, 1.1),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(0, 14, -0.6),
            vang = Angle(0, -90, 0),
        },
    },  
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.5, 0.5, 0.5),
        WMScale = Vector(0.5, 0.5, 0.5),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(0.65, 1, -1.8),
            vang = Angle(0, -90, 0),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(0.8, 0.8, 0.8),
        WMScale = Vector(0.8, 0.8, 0.8),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(0.5, -4, -0.25),
            vang = Angle(0, -90, 0),
        },
    },   
}
-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
	["fire"] = {
        Source = "shoot",
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatFix", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_republic_e9.lua:
return gluapack()()
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_rg4d.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 1 -- Change this if you want to select the weapon with other number

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Confederacy Arsenal"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "RG-4D"
SWEP.Trivia_Class = "Blaster, Pistol"
SWEP.Trivia_Desc = "The RG-4D was a model of blaster pistol. During the Clone Wars, spaceport police droids were equipped with RG-4Ds. In addition, some OOM command battle droids of the Separatist Droid Army made use of the RG-4D."
SWEP.Trivia_Manufacturer = "Baktoid Armor Workshop"
SWEP.Trivia_Calibre = "Condensed Tibanna-Gas"
SWEP.Trivia_Country = "Confederacy of Independent Systems"
SWEP.IconOverride = "entities/arccw/kraken/republic-arsenal/rg4d.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "00000000000000"

SWEP.MirrorVMWM = true
SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/kraken/cis/v_rg4d.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(-14, 6.7, -7.65),
    ang = Angle(0, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 15
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatDelayTime = 0.5
SWEP.HeatFix = true

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 25
SWEP.DamageMin = 23
SWEP.RangeMin = 0
SWEP.Range = 180
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 9000

SWEP.TraceNum = 1
SWEP.Tracer = "tracer_red"
SWEP.TracerCol = Color(250, 0, 0)

SWEP.HullSize = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 30

SWEP.Recoil = 0.7
SWEP.RecoilSide = 0.2
SWEP.RecoilRise = 0.9

SWEP.Delay = 60 / 300
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
	{
		Mode = 0,
   	}
}

SWEP.AccuracyMOA = 5
SWEP.HipDispersion = 200
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.95
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.30

-- Ammo, Sounds & MuzzleEffect
local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_ITEM)
    end
end

SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0

SWEP.FirstShootSound = "ArcCW_Kraken.SW_RG4D"
SWEP.ShootSound = "ArcCW_Kraken.SW_RG4D"
SWEP.DistantShootSound = "ArcCW_Kraken.LightCorebass"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"

SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-6.134, -8.313, 2.319),
    Ang = Vector(0, 0, 0),
     Magnification = 1.5,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL

SWEP.SprintPos = Vector(-3, -6, -5)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.CustomizePos = Vector(10, -5, 2)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 3)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(-3, 0, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "a180",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(-2, 2, 15),
                   ang = Angle(90, 0, -90),
               },
               IsMuzzleDevice = true,
           }
        }, 
    },
    ["scope_attach"] = {
        VMBodygroups = {{ind = 1, bg = 1}},
    },
}

-- Attachments
SWEP.Attachments = {     
    {
        PrintName = "E-5 Holosight", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "a180",
        InstalledEles = {"scope_attach"},
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(0.3, -2, 1.9),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        Bone = "a180",
        Offset = {
            vpos = Vector(0.3, -1.2, 13.4),
            vang = Angle(90, 0, -90),
        },
    },  
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "a180",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(-0.2, -1.25, 10),
            vang = Angle(90, 0, 180),
        },
    },
    {
        PrintName = "Mode",
        DefaultAttName = "None",
        Slot = {"sw_mode", "sw_mode_pistol"},
    },   
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },     
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.5, 0.5, 0.5),
        WMScale = Vector(0.5, 0.5, 0.5),
        Bone = "a180",
        Offset = {
            vpos = Vector(0.88, 0, 1.2),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Bone = "a180",
        Offset = {
            vpos = Vector(0.7, -0.1, 4),
            vang = Angle(90, 0, -90),
        },
    },   
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["idle_iron"] = {
        Source = false,
    },
	["fire"] = {
        Source = {"shoot"},
        Mult = 2,
    },
    ["fire_iron"] = {
        Source = {"shoot"},
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatFix", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        Mult = 1.5,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}


--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_rt97c.lua:
return gluapack()()
--PATH addons/[bronie] arccw-galactic-expansion-v1.0/lua/weapons/arccw_k_smuggler.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 2

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Galactic Expansion v2"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "Smuggler Blaster"
SWEP.Trivia_Class = "Blaster Pistol"
SWEP.Trivia_Desc = "Blaster Pistol designed originally for military purposes, now modernized and being used by many Bounty Hunters, Civillians and even Mercenaries or Military Corporations in the galaxy."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/galactic/smuggler.png"

-- Base
SWEP.DefaultBodygroups = "000000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/galactic/v_smuggler_blaster.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(-18.5, 6, -5.4),
    ang = Angle(0, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 15
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 21
SWEP.DamageMin = 21
SWEP.RangeMin = 0
SWEP.Range = 200
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(250, 0, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_red"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 30

SWEP.Recoil = 0.75
SWEP.RecoilSide = 0.2
SWEP.RecoilRise = 0.2

SWEP.Delay = 60 / 350
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
		Mode = 2,
    },
    {
        Mode = -3,
        PostBurstDelay = 0.1,
        RunawayBurst = false,
        Mult_RPM = 2,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0.5
SWEP.HipDispersion = 100
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "ArcCW_Kraken.SW_SMUGGLER"
SWEP.ShootSound = "ArcCW_Kraken.SW_SMUGGLER"
SWEP.DistantShootSound = "ArcCW_Kraken.StandardCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-5.04, -11.296, 1.4),
    Ang = Angle(0,0,0),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL

SWEP.SprintPos = Vector(2.019, -5.226, -2)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.CustomizePos = Vector(10, -10, 0)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 2)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(-3, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.DefaultElements = {}
SWEP.AttachmentElements = {
    ["muzzle_attach"] = {
        VMBodygroups = {{ind = 1, bg = 1}},
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Sight", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "DC-15SA",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(-0.01, -2, -3),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        Bone = "DC-15SA",
        InstalledEles = {"muzzle_attach"},
        Offset = {
            vpos = Vector(0, -1.75, 3.4),
            vang = Angle(90, 0, -90),
        },
    },  
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "DC-15SA",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(-0.3, -1.7, 2.3),
            vang = Angle(90, 0, 180),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.5, 0.5, 0.5),
        WMScale = Vector(0.5, 0.5, 0.5),
        Bone = "DC-15SA",
        Offset = {
            vpos = Vector(0.2, 0.1, -2.3),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Bone = "DC-15SA",
        Offset = {
            vpos = Vector(0.45, -0.65, -2.5),
            vang = Angle(90, 0, -90),
        },
    },   
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = false,
    },
    ["idle_iron"] = {
        Source = false,
    },
	["fire"] = {
        Source = {"fire"},
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatFix", t = 42 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_westarm5.lua:
return gluapack()()
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/weapons/arccw_k_z4.lua:
return gluapack()()
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_empire_dlt34.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 4

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Special Forces - Empire"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "DLT-34"
SWEP.Trivia_Class = "Blaster Heavy Repeater"
SWEP.Trivia_Desc = "The DLT-34 heavy blaster rifle was a model of heavy blaster rifle manufactured by BlasTech Industries. They were used by regular stormtroopers and Heavy Weapons Stormtroopers of the Galactic Empire, but they also saw use by other parties, including the Alliance to Restore the Republic and certain bounty hunters."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/sops/dlt34.png"


-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "000000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sops/v_dlt34.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dlt19.mdl"

SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(-9, 5, -5.75),
    ang = Angle(-10, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 60
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 22
SWEP.DamageMin = 19
SWEP.RangeMin = 0
SWEP.Range = 600
SWEP.Penetration = 10
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(250, 0, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_red"
SWEP.HullSize = 1

SWEP.InfiniteAmmo = true
SWEP.BottomlessClip = true

SWEP.Recoil = 0.6
SWEP.RecoilSide = 0.3
SWEP.RecoilRise = 0.7
SWEP.MaxRecoilBlowback = 1
SWEP.RecoilPunch = 1
SWEP.RecoilVMShake = 1

SWEP.Delay = 60 / 600
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
		Mode = 2,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0.5
SWEP.HipDispersion = 100
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "kraken/sops/dlt34.wav"
SWEP.ShootSound = "kraken/sops/dlt34.wav"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-4.745, -9.119, 1.550),
    Ang = Vector(2.677, 0, 0),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "ar2"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.SprintPos = Vector(2, -1, 3)
SWEP.SprintAng = Angle(-10, 26, 0)

SWEP.CustomizePos = Vector(10, 0, 2)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 3)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(-3, 0, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.BipodDispersion = 1
SWEP.BipodRecoil = 1

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 1, 1)

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "dlt34",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(0, 0, 34),
                   ang = Angle(90, 0, 0),
               },
               IsMuzzleDevice = true,
           }
        }, 
    },
    ["specialforces_bipod"] = {
        VMBodygroups = {{ind = 3, bg = 1}},
    },
    ["specialforces_bipod_hidden"] = {
        VMBodygroups = {{ind = 3, bg = 2}},
    },
    ["muzzle_attach"] = {
        VMBodygroups = {{ind = 2, bg = 1}},
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Sight", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "dlt34",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Offset = {
            vpos = Vector(-0.1, -2.4, 6),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        InstalledEles = {"muzzle_attach"},
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        VMScale = Vector(1.2,1.2,1.2),
        WMScale = Vector(1.2,1.2,1.2),
        Bone = "dlt34",
        Offset = {
            vpos = Vector(-0.1, -0.9, 29.3),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "dlt34",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Offset = {
            vpos = Vector(-0.7, -1, 27),
            vang = Angle(90, 0, 180),
        },
    },
    {
        PrintName = "Underbarrel",
        DefaultAttName = "Bipod",
        InstalledEles = {"specialforces_bipod_hidden"},
        Slot = {"foregrip", "specialforces_bipod"},
        Bone = "dlt34",
        Offset = {
            vpos = Vector(-0.01, -0.3, 15),
            vang = Angle(90, 0, -90),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Bone = "dlt34",
        Offset = {
            vpos = Vector(0.7, -1.2, 2),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Bone = "dlt34",
        Offset = {
            vpos = Vector(0.8, -0.82, -1),
            vang = Angle(90, 0, -90),
        },
    },   
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["idle_iron"] = {
        Source = "idle",
    },
	["fire"] = {
        Source = {"shoot"},
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        Mult = 0.3,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatFix", t = 60 / 30},
            {s = "ArcCW_Kraken.Grab", t = 65 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_empire_ee4.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3

SWEP.Category = "[ArcCW] Kraken's Special Forces - Empire"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "EE-4"
SWEP.Trivia_Class = "Blaster Carbine"
SWEP.Trivia_Desc = "The EE-4 carbine, also known as the EE-4 blaster rifle, was a powerful medium-ranged blaster carbine model that was manufactured by BlasTech Industries during the reign of the Galactic Empire. Successor to the EE-3 carbine rifle, the EE-4's shorter and stubbier barrel allowed the blaster rifle to fire more effectively at close range with spread shots but at the cost of a reduced accuracy at range compared to its predecessor."
SWEP.IconOverride = "entities/kraken/sops/ee4.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "001111"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sops/v_ee4.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dlt19.mdl"

SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(-11, 6, -4.56),
    ang = Angle(-10, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 25
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 37
SWEP.DamageMin = 22
SWEP.RangeMin = 0
SWEP.Range = 400
SWEP.Penetration = 10
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(250, 0, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_red"
SWEP.HullSize = 1

SWEP.InfiniteAmmo = true
SWEP.BottomlessClip = true

SWEP.Recoil = 0.5
SWEP.RecoilSide = 0.2
SWEP.RecoilRise = 0.5
SWEP.MaxRecoilBlowback = 1
SWEP.RecoilPunch = 1
SWEP.RecoilVMShake = 1

SWEP.Delay = 60 / 270
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
        Mode = -3,
        PostBurstDelay = 0.1,
        RunawayBurst = false,
        Mult_RPM = 3,
    },
    {
		Mode = 2,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 250
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "kraken/sops/ee4.wav"
SWEP.ShootSound = "kraken/sops/ee4.wav"
SWEP.DistantShootSound = "ArcCW_Kraken.StandardCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-5.07, -1.859, 2.362),
    Ang = Vector(0, 0, 0),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "smg"
SWEP.HoldtypeSights = "smg"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.SprintPos = Vector(2, -1, 3)
SWEP.SprintAng = Angle(-10, 26, 0)

SWEP.CustomizePos = Vector(10, 0, 2)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 3)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(-3, 0, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments

SWEP.Attachments = {     
    {
        PrintName = "Sight", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "ee4",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Offset = {
            vpos = Vector(-0.03, -1.82, 5.7),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        VMScale = Vector(1.4,1.4,1.4),
        WMScale = Vector(1.4,1.4,1.4),
        Bone = "ee4",
        Offset = {
            vpos = Vector(-0.01, -0.7, 12.3),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "ee4",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Offset = {
            vpos = Vector(-0.9, -0.9, 9),
            vang = Angle(90, 0, 180),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Bone = "ee4",
        Offset = {
            vpos = Vector(0.86, -0.4, -0.39),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Bone = "ee4",
        Offset = {
            vpos = Vector(1.17, -0.7, 5.6),
            vang = Angle(90, 0, -90),
        },
    },   
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["idle_iron"] = {
        Source = false,
    },
	["fire"] = {
        Source = {"shoot"},
    },
    ["fire_iron"] = {
        Source = {"shoot"},
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        LHIK = true,
        Mult = 1,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatFix", t = 40 / 30},
            {s = "ArcCW_Kraken.Grab", t = 40 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_empire_stw48.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Special Forces - Empire"
SWEP.Credits = "Kraken"
SWEP.PrintName = "STW-48"
SWEP.Trivia_Class = "Blaster Rifle"
SWEP.Trivia_Desc = "This is the ST-W48. The weapon could be used in a blaster rifle configuration or a blaster carbine configuration where the stock was removed for use in confined spaces. Each ST-W48 had a quarrel-bolt launcher installed below its barrel that used enhanced bowcaster technology for a powerful explosive attack. The rifle's power cell cartridge was located around the mid-point of the weapon's length, above the trigger. The weapon had an auto fire mode that provided a high rate of fire."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/sops/stw48.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "001000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sops/v_stw48.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(-11, 5, -1.5),
    ang = Angle(-15, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 34
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 34
SWEP.DamageMin = 29
SWEP.RangeMin = 0
SWEP.Range = 200
SWEP.Penetration = 10
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(2500, 0, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_red"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 50

SWEP.Recoil = 0.76
SWEP.RecoilSide = 0.2
SWEP.RecoilRise = 0.90
SWEP.MaxRecoilBlowback = 1
SWEP.RecoilPunch = 1.4
SWEP.RecoilVMShake = 1.5

SWEP.Delay = 60 / 400
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
		Mode = 2,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0.5
SWEP.HipDispersion = 250
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "kraken/sops/stw48.wav"
SWEP.ShootSound = "kraken/sops/stw48.wav"
SWEP.DistantShootSound = "ArcCW_Kraken.StandardCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-4.191, -1.124, 0.264),
    Ang = Vector(2.74, 0, 0),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "ar2"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.SprintPos = Vector(2, -1, 0)
SWEP.SprintAng = Angle(-10, 26, 0)

SWEP.CustomizePos = Vector(10, 0, 2)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 0)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(-3, 0, 0.5)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 0)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "dc15s",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(-0.25, 2, 11.1),
                   ang = Angle(90, 0, 0),
               },
               IsMuzzleDevice = true,
           }
        }, 
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Sight", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "dc15s",
        VMScale = Vector(0.9,0.9,0.9),
        WMScale = Vector(0.9,0.9,0.9),
        Offset = {
            vpos = Vector(-0.18, -1.7, 2),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        VMScale = Vector(1.3,1.3,1.3),
        WMScale = Vector(1.3,1.3,1.3),
        Bone = "dc15s",
        Offset = {
            vpos = Vector(-0.25, 0.18, 11.1),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "dc15s",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Offset = {
            vpos = Vector(-0.7, 0, 8),
            vang = Angle(90, 0, 180),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Bone = "dc15s",
        Offset = {
            vpos = Vector(0.65, 0.2, -6.2),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Bone = "dc15s",
        Offset = {
            vpos = Vector(0.8, 0.2, 0),
            vang = Angle(90, 0, -90),
        },
    },   
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["idle_iron"] = {
        Source = false,
    },
	["fire"] = {
        Source = {"shoot"},
    },
    ["fire_iron"] = {
        Source = {"shoot"},
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        Mult = 1.1,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatFix", t = 60 / 30},
            {s = "ArcCW_Kraken.Grab", t = 65 / 30},
        },
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        Mult = 1.4,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 80 / 30},
            {s = "ArcCW_Kraken.Grab", t = 85 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_empire_tl40.lua:
return gluapack()()
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_galactic_a180.lua:
return gluapack()()
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_galactic_a180.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 2

SWEP.Category = "[ArcCW] Kraken's Special Forces - Galactic"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "A-180"
SWEP.Trivia_Class = "Blaster Pistol"
SWEP.Trivia_Desc = "The A-180 blaster, also known as the A180 pistol, was a modular blaster manufactured by BlasTech Industries. It was a highly versatile design with multiple configurations that could be easily reconfigured from a blaster pistol to a blaster rifle, a sniper rifle/longblaster, or an portable ion launcher depending on the situation."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/sops/a180.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "000000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sops/v_a180.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(-14, 6.7, -7.65),
    ang = Angle(0, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 10
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 33
SWEP.DamageMin = 24
SWEP.RangeMin = 0
SWEP.Range = 135
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(2500, 0, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_red"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 15

SWEP.Recoil = 1
SWEP.RecoilSide = 0.6
SWEP.RecoilRise = 0.9

SWEP.Delay = 60 / 260
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 100
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "kraken/sops/a180.wav"
SWEP.ShootSound = "kraken/sops/a180.wav"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-6.14, 0, 4.006),
    Ang = Vector(0, 0, 0),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL

SWEP.SprintPos = Vector(-3, -6, -5)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.CustomizePos = Vector(10, -5, 2)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 3)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(-3, 0, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "a180",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(-2, 2, 8),
                   ang = Angle(90, 0, -90),
               },
               IsMuzzleDevice = true,
           }
        }, 
    },
    ["a180_barrele"] = {
        VMBodygroups = {{ind = 1, bg = 1}},
        AttPosMods = {
            [2] = {
                vpos = Vector(0.3, -0.5, 11.8),
            },
        }
    },
    ["a180_grip"] = {
        VMBodygroups = {
            {ind = 2, bg = 1},
        },
    },
}

-- Attachments
SWEP.Attachments = {     
    {
        PrintName = "Sight", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "a180",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(0.3, -1.2, 1.3),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        Bone = "a180",
        Offset = {
            vpos = Vector(0.3, -0.5, 9.8),
            vang = Angle(90, 0, -90),
        },
    },  
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "a180",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(-0.3, -0.49, 4),
            vang = Angle(90, 0, 180),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    }, 
    {
        PrintName = "Barrel",
        DefaultAttName = "None",
        Slot = "a180_barrele",
    },    
    {
        PrintName = "Grip",
        DefaultAttName = "None",
        Slot = "a180_grip",
    },     
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.5, 0.5, 0.5),
        WMScale = Vector(0.5, 0.5, 0.5),
        Bone = "a180",
        Offset = {
            vpos = Vector(1, -0.9, -1.4),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Bone = "a180",
        Offset = {
            vpos = Vector(0.9, -0.5, 1),
            vang = Angle(90, 0, -90),
        },
    },   
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["idle_iron"] = {
        Source = false,
    },
	["fire"] = {
        Source = {"shoot"},
        Mult = 2,
    },
    ["fire_iron"] = {
        Source = {"shoot"},
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatFix", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        Mult = 1.5,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}


--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_galactic_b0l3.lua:
return gluapack()()
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_galactic_b1na.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 4

SWEP.Category = "[ArcCW] Kraken's Special Forces - Galactic"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "B1-NA"
SWEP.Trivia_Class = "Blaster Repeater"
SWEP.Trivia_Desc = "A blaster repeater which is a compact, rapid-fire weapon with a sleek design, often featuring a barrel that extends forward. It is known for its high rate of fire and is commonly used by soldiers or bounty hunters in battle. This weapon is a powerful, efficient, and ideal for close to medium-range combat."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/sops/b1na.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "000000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sops/v_b1na.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dlt19.mdl"

SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(-9, 5, -5.75),
    ang = Angle(-10, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 35
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 25
SWEP.DamageMin = 22
SWEP.RangeMin = 0
SWEP.Range = 270
SWEP.Penetration = 10
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(250, 0, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_red"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 65

SWEP.Recoil = 0.5
SWEP.RecoilSide = 0.45
SWEP.RecoilRise = 0.90
SWEP.MaxRecoilBlowback = 1
SWEP.RecoilPunch = 1
SWEP.RecoilVMShake = 2

SWEP.Delay = 60 / 700
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
        Mode = -3,
        PostBurstDelay = 0.1,
        RunawayBurst = false,
        Mult_RPM = 3,
    },
    {
		Mode = 2,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 250
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "kraken/sops/b1na.wav"
SWEP.ShootSound = "kraken/sops/b1na.wav"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-4.842, -2.648, 2.9),
    Ang = Vector(0, 0, 0),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "ar2"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.SprintPos = Vector(2, -1, 3)
SWEP.SprintAng = Angle(-10, 26, 0)

SWEP.CustomizePos = Vector(10, 0, 2)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 3)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(-3, 0, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "dlt34",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(0, -1, 25),
                   ang = Angle(90, 0, 0),
               },
               IsMuzzleDevice = true,
           }
        }, 
    },
}

SWEP.Attachments = {     
    {
        PrintName = "Sight", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "dlt34",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Offset = {
            vpos = Vector(-0.1, -2, 6),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        InstalledEles = {"muzzle_attach"},
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        VMScale = Vector(1.4,1.4,1.4),
        WMScale = Vector(1.4,1.4,1.4),
        Bone = "dlt34",
        Offset = {
            vpos = Vector(-0.1, -1, 26.5),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "dlt34",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Offset = {
            vpos = Vector(-1.1, -1.3, 21),
            vang = Angle(90, 0, 180),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Bone = "dlt34",
        Offset = {
            vpos = Vector(0.9, -1, 0),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Bone = "dlt34",
        Offset = {
            vpos = Vector(1.17, -1., 5.5),
            vang = Angle(90, 0, -90),
        },
    },   
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["idle_iron"] = {
        Source = false,
    },
	["fire"] = {
        Source = {"shoot"},
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        Mult = 0.3,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatFix", t = 60 / 30},
            {s = "ArcCW_Kraken.Grab", t = 65 / 30},
        },
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        Mult = 0.5,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 110 / 30},
            {s = "ArcCW_Kraken.Grab", t = 115 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_galactic_galaar15c.lua:
return gluapack()()
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_galactic_m5d.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 2

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Special Forces - Galactic"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "M5-D"
SWEP.Trivia_Class = "Blaster Pistol"
SWEP.Trivia_Desc = "Heavy-Powered blaster produced by BlastTech Industries for the galactic citizens."
SWEP.Trivia_Manufacturer = "Unknown"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/sops/m5d.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "000000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sops/v_m5d.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(-14, 6.7, -7.65),
    ang = Angle(0, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 10
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 26
SWEP.DamageMin = 22
SWEP.RangeMin = 0
SWEP.Range = 240
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(250, 0, 0)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_red"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 18

SWEP.Recoil = 1.4
SWEP.RecoilSide = 0.2
SWEP.RecoilRise = 0.4

SWEP.Delay = 60 / 120
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
		Mode = 2,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 200
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "kraken/sops/m5d.wav"
SWEP.ShootSound = "kraken/sops/m5d.wav"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_red"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-5.989, 1.11, 3.4),
    Ang = Vector(1.8, 0.389, 0),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL

SWEP.SprintPos = Vector(-3, -6, -5)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.CustomizePos = Vector(10, -5, 2)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 3)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(-3, 0, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "a180",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(0, 4, 10),
                   ang = Angle(90, 0, -90),
               },
               IsMuzzleDevice = true,
           }
        }, 
    },
}

-- Attachments
SWEP.Attachments = {     
    {
        PrintName = "Sight", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "a180",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(0.28, -1.2, 1),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        Bone = "a180",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Offset = {
            vpos = Vector(0.25, -0.72, 5.9),
            vang = Angle(90, 0, -90),
        },
    },  
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "a180",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(-0.25, -0.44, 5),
            vang = Angle(90, 0, 180),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.5, 0.5, 0.5),
        WMScale = Vector(0.5, 0.5, 0.5),
        Bone = "a180",
        Offset = {
            vpos = Vector(0.65, -0.3, 2.5),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Bone = "a180",
        Offset = {
            vpos = Vector(0.6, -0.75, -0.7),
            vang = Angle(90, 0, -90),
        },
    },   
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["idle_iron"] = {
        Source = false,
    },
	["fire"] = {
        Source = {"shoot"},
        Mult = 2,
    },
    ["fire_iron"] = {
        Source = {"shoot"},
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatFix", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        Mult = 1.5,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}

--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_galactic_prototypeblaster.lua:
return gluapack()()
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_republic_md12x.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Special Forces - Republic"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "MD-12x"
SWEP.Trivia_Class = "Blaster-Experimental Shotgun"
SWEP.Trivia_Desc = "The MD-12x heavy shotgun, also known as MD-12 shotgun, was a heavy blaster shotgun wielded by the Clone Trooper 'Hunter' of the Grand Army of the Galactic Republic during the Clone Wars."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/sops/md12x.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "000000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sops/v_md12.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dlt19.mdl"

SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(-9, 5, -5),
    ang = Angle(-15, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Damage & Tracer
SWEP.NoRandSpread = true
SWEP.CanBash = true

SWEP.ShotgunSpreadPattern = {
    [1] = Angle(0, 0, 0),
    [2] = Angle(0, 1, 0),
    [3] = Angle(0, -1, 0),
    [4] = Angle(2.1, 0, 0),
    [5] = Angle(-2.1, 0, 0),
    [6] = Angle(1.4, 1.2, 0),
    [7] = Angle(-1.4, 1.2, 0),
    [8] = Angle(1.4, -1.2, 0),
    [9] = Angle(-1.4, -1.2, 0),
}

SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 10
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 13
SWEP.DamageMin = 11
SWEP.RangeMin = 0
SWEP.Range = 120
SWEP.Penetration = 10
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(0, 0, 250)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_blue"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 22

SWEP.Recoil = 1.9
SWEP.RecoilSide = 1
SWEP.RecoilRise = 2
SWEP.MaxRecoilBlowback = 2
SWEP.RecoilPunch = 1
SWEP.RecoilVMShake = 1

SWEP.Delay = 60 / 400
SWEP.Num = 9
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
		Mode = 2,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0.5
SWEP.HipDispersion = 250
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "kraken/sops/scatterpistol.wav"
SWEP.ShootSound = "kraken/sops/scatterpistol.wav"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_blue"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 0, 250)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-4.94, -6.048, 1.6),
    Ang = Vector(2.677, -0.336, 1.039),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "ar2"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN

SWEP.SprintPos = Vector(2, -1, 3)
SWEP.SprintAng = Angle(-10, 26, 0)

SWEP.CustomizePos = Vector(10, 0, 2)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 0)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(-3, 0, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "dlt34",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(0, -2, 21),
                   ang = Angle(90, 0, 0),
               },
               IsMuzzleDevice = true,
           }
        }, 
    },
}


SWEP.Attachments = {     
    {
        PrintName = "Sight", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "dlt34",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        InstalledEles = {"scope_attach"},
        Offset = {
            vpos = Vector(-0.09, -3.35, 6),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Internal Compression",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "dlt34",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Offset = {
            vpos = Vector(-1.44, -1, 14),
            vang = Angle(90, 0, 180),
        },
    },
    {
        PrintName = "Underbarrel",
        DefaultAttName = "None",
        Slot = {"foregrip"},
        Bone = "dlt34",
        Offset = {
            vpos = Vector(-0.01, 2.6, 13),
            vang = Angle(90, 0, -90),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Bone = "dlt34",
        Offset = {
            vpos = Vector(1.3, -1.33, 4.6),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(1,1,1),
        WMScale = Vector(1,1,1),
        Bone = "dlt34",
        Offset = {
            vpos = Vector(1.36, -1.44, -1),
            vang = Angle(90, 0, -90),
        },
    },   
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["idle_iron"] = {
        Source = false,
    },
	["fire"] = {
        Source = {"shoot"},
    },
    ["fire_iron"] = {
        Source = {"shoot"},
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        Mult = 0.3,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatFix", t = 60 / 30},
            {s = "ArcCW_Kraken.Grab", t = 65 / 30},
        },
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        Mult = 0.5,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 110 / 30},
            {s = "ArcCW_Kraken.Grab", t = 115 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_republic_rx21.lua:
return gluapack()()
--PATH addons/[bronie] arccw-special-forces-v3-1/lua/weapons/arccw_sops_republic_x11.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 2

-- Trivia
SWEP.Category = "[ArcCW] Kraken's Special Forces - Republic"
SWEP.Credits = "Kraken (Discord: @elbestiamasita)"
SWEP.PrintName = "X-11"
SWEP.Trivia_Class = "Blaster Pistol"
SWEP.Trivia_Desc = "The X-11 hand blaster, also known as X-11 blaster pistol, was a heavy blaster pistol wielded by the Clone Trooper 'Echo' of the Grand Army of the Galactic Republic during the Clone Wars."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.IconOverride = "entities/kraken/sops/x11.png"

-- Viewmodel & Entity Properties
SWEP.DefaultBodygroups = "000000000000"
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sops/v_x11.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_e11.mdl"

SWEP.ViewModelFOV = 65

SWEP.WorldModelOffset = {
    pos = Vector(-14, 6.7, -7.65),
    ang = Angle(0, 0, -180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Damage & Tracer
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 10
SWEP.HeatDissipation = 5
SWEP.HeatLockout = true
SWEP.HeatFix = true
SWEP.HeatDelayTime = 0.5

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1.25,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.Damage = 32
SWEP.DamageMin = 24
SWEP.RangeMin = 0
SWEP.Range = 220
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 2000

SWEP.TracerNum = 1
SWEP.TracerCol = Color(0, 0, 250)
SWEP.TracerWidth = 1
SWEP.Tracer = "tracer_blue"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 18

SWEP.Recoil = 0.9
SWEP.RecoilSide = 0.6
SWEP.RecoilRise = 0.9

SWEP.Delay = 60 / 280
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
	{
		Mode = 0,
   	}
}

local s = "ArcCW_Kraken.OverheatWarn"
local p = {
    [5] = 70,
    [4] = 70,
    [3] = 70,
    [2] = 80,
    [1] = 90,
    [0] = 100,
}
SWEP.Hook_AddShootSound = function(wep, data)
    local pitch = p[wep:Clip1()]
    if pitch then
        wep:MyEmitSound(s, 100, pitch, 0.5, CHAN_AUTO)
    end
end

SWEP.AccuracyMOA = 0
SWEP.HipDispersion = 100
SWEP.MoveDispersion = 150 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 0.955
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "kraken/sops/x11.wav"
SWEP.ShootSound = "kraken/sops/x11.wav"
SWEP.DistantShootSound = "ArcCW_Kraken.HeavyCorebass"
SWEP.ShootSoundSilenced = "ArcCW_Kraken.RifleSupp"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "blaster_muzzle_blue"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 0, 250)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-6.101, -5.169, 3.193),
    Ang = Vector(0, 0, 0),
     Magnification = 1.5,
     SwitchToSound = "arccw/kraken/interaction/zoom-in.wav",
     SwitchFromSound = "arccw/kraken/interaction/zoom-out.wav",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"
SWEP.HoltypeCustomize = "slam"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL

SWEP.SprintPos = Vector(-3, -6, -5)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.CustomizePos = Vector(10, -5, 2)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)

SWEP.CrouchPos = Vector(-3, 0, 3)
SWEP.CrouchAng = Angle(0, 0, 0)

SWEP.ActivePos = Vector(-3, 0, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.DefaultElements = {"muzzle"}
SWEP.AttachmentElements = {
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "a180",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(0.25, -1, 10),
                   ang = Angle(90, 0, -90),
               },
               IsMuzzleDevice = true,
           }
        }, 
    },
}

-- Attachments
SWEP.Attachments = {     
    {
        PrintName = "Sight", 
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "a180",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Offset = {
            vpos = Vector(0.31, -1.9, 1.2),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 0, 0),
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        Bone = "a180",
        Offset = {
            vpos = Vector(0.25, -1.2, 8.6),
            vang = Angle(90, 0, -90),
        },
    },  
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "a180",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(-0.3, -0.2, 7),
            vang = Angle(90, 0, 180),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "None",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = "charm",
        VMScale = Vector(0.8, 0.8, 0.8),
        WMScale = Vector(0.8, 0.8, 0.8),
        Bone = "a180",
        Offset = {
            vpos = Vector(0.8, 0.6, 6),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = "killcounter",
        VMScale = Vector(0.9, 0.9, 0.9),
        WMScale = Vector(0.9, 0.9, 0.9),
        Bone = "a180",
        Offset = {
            vpos = Vector(1, -1, 6.7),
            vang = Angle(90, 0, -90),
        },
    },   
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["idle_iron"] = {
        Source = false,
    },
	["fire"] = {
        Source = {"shoot"},
        Mult = 2,
    },
    ["fire_iron"] = {
        Source = {"shoot"},
    },
    ["fix"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatFix", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        LHIK = true,
        Mult = 1.5,
        SoundTable = {
            {s = "ArcCW_Kraken.Overheat", t = 1 / 30},
            {s = "ArcCW_Kraken.OverheatReplenished", t = 45 / 30},
            {s = "ArcCW_Kraken.Grab", t = 43 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/empire/draw_pistol.wav",
                p = 100,
                v = 100,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
}
--PATH lua/weapons/ce_bcr_config.lua:
AddCSLuaFile()


-- Per Person Setting

CreateClientConVar("bc2_ShowCloakCharge", 1, false, false, "")

-- Visual

CreateConVar("bc2_CloakType", "Transparent", FCVAR_ARCHIVE, "")
CreateConVar("bc2_CloakMode", "Timer", FCVAR_ARCHIVE, "")
CreateConVar("bc2_CloakUntilVel", 75, FCVAR_ARCHIVE, "")
CreateConVar("bc2_MinimumVisibility", 0, FCVAR_ARCHIVE, "")
CreateConVar("bc2_CloakMaterial", "", FCVAR_ARCHIVE, "")
CreateConVar("bc2_ChargeGainMultiplier", 1, FCVAR_ARCHIVE, "")
CreateConVar("bc2_ChargeLossMultiplier", 1, FCVAR_ARCHIVE, "")
CreateConVar("bc2_MaxCharge1", 10, FCVAR_ARCHIVE, "")
CreateConVar("bc2_MaxCharge2", 20, FCVAR_ARCHIVE, "")
CreateConVar("bc2_MaxCharge3", 30, FCVAR_ARCHIVE, "")
CreateConVar("bc2_MinimumNPCVisibility", 70, FCVAR_ARCHIVE, "")
CreateConVar("bc2_UncloakInVehicle", 1, FCVAR_ARCHIVE, "")
CreateConVar("bc2_CloakOverlay", "", FCVAR_ARCHIVE, "")
CreateConVar("bc2_MinimumIDVisibility", 70, FCVAR_ARCHIVE, "")
CreateConVar("bc2_CloakFireMode", 3, FCVAR_ARCHIVE, "")
CreateConVar("bc2_LoseChargeAmountFire", 5, FCVAR_ARCHIVE, "")
CreateConVar("bc2_TempDisableTimeFire", 2, FCVAR_ARCHIVE, "")
CreateConVar("bc2_CloakDamageMode", 3, FCVAR_ARCHIVE, "")
CreateConVar("bc2_LoseChargeAmountHurt", 5, FCVAR_ARCHIVE, "")
CreateConVar("bc2_TempDisableTimeHurt", 2, FCVAR_ARCHIVE, "")
CreateConVar("bc2_CloakEffectOn", "", FCVAR_ARCHIVE, "")
CreateConVar("bc2_CloakEffectOff", "", FCVAR_ARCHIVE, "")
CreateConVar("bc2_ToggleTime", 3, FCVAR_ARCHIVE, "")

-- Audio

CreateConVar("bc2_DistortSound", 14, FCVAR_ARCHIVE, "")
CreateConVar("bc2_EnableSound", "npc/sniper/reload1.wav", FCVAR_ARCHIVE, "")
CreateConVar("bc2_DisableSound", "AlyxEMP.Discharge", FCVAR_ARCHIVE, "")
CreateConVar("bc2_ForceDisableSound", "npc/roller/mine/combine_mine_deactivate1.wav", FCVAR_ARCHIVE, "")
CreateConVar("bc2_ToggleFailureSound", "npc/roller/mine/combine_mine_deploy1.wav", FCVAR_ARCHIVE, "")
CreateConVar("bc2_FootstepVolume", 0, FCVAR_ARCHIVE, "")
CreateConVar("bc2_TauntSound", "", FCVAR_ARCHIVE, "")
CreateConVar("bc2_TauntVolume", 1, FCVAR_ARCHIVE, "")
CreateConVar("bc2_TauntDelay", 4, FCVAR_ARCHIVE, "")

hook.Add( "PopulateToolMenu", "ce_bc2_configmenu", function()
	spawnmenu.AddToolMenuOption( "Utilities", "JustCrimson", "ce_bc2_config", "Better Cloaking Config", "", "", function( panel )
		panel:ClearControls()
		local CloakTypeBox = panel:ComboBox("Cloak Type", "bc2_CloakType")
		
		CloakTypeBox:AddChoice("Transparent")
		CloakTypeBox:AddChoice("Material")
		
		local CloakModeBox = panel:ComboBox("Cloak Mode", "bc2_CloakMode")
		CloakModeBox:AddChoice("Timer")
		CloakModeBox:AddChoice("Charge")

		panel:TextEntry("Movement Sensitivity", "bc2_CloakUntilVel"):SetNumeric(true)

		panel:TextEntry("Toggle Time", "bc2_ToggleTime"):SetNumeric(true)

		panel:NumSlider("Minimum Visibility", "bc2_MinimumVisibility", 0, 255, 0)

		panel:TextEntry("Cloak Material", "bc2_CloakMaterial")

		local SoundDistortBox = panel:ComboBox("Sound Distortion", "bc2_DistortSound")
		SoundDistortBox:AddChoice("None", 0)
		SoundDistortBox:AddChoice("Light", 14)
		SoundDistortBox:AddChoice("Medium", 15)
		SoundDistortBox:AddChoice("Heavy", 16)

		panel:TextEntry("Enable Sound", "bc2_EnableSound")
		panel:TextEntry("Disable Sound", "bc2_DisableSound")
		panel:TextEntry("Toggle Fail Sound", "bc2_ToggleFailureSound")
		panel:TextEntry("Force Disable Sound", "bc2_ForceDisableSound")


		panel:NumSlider("Visibility For NPC Target", "bc2_MinimumNPCVisibility", 0, 255, 0)
		panel:NumSlider("Visibility To Show ID", "bc2_MinimumIDVisibility", 0, 255, 0)

		panel:NumSlider("Footstep Volume", "bc2_FootstepVolume", 0, 1, 2)

		panel:CheckBox("Uncloak In Vehicle", "bc2_UncloakInVehicle")

		panel:TextEntry("Cloak Overlay", "bc2_CloakOverlay")

		local CloakShootMode = panel:ComboBox("Shooting While Cloaked Mode", "bc2_CloakFireMode")
		CloakShootMode:AddChoice("Disable Cloak", 1)
		CloakShootMode:AddChoice("Lose Charge", 2)
		CloakShootMode:AddChoice("Temp Disable", 3)
		CloakShootMode:AddChoice("Nothing", 4)

		panel:TextEntry("Shooting Lose Charge Amount", "bc2_LoseChargeAmountFire"):SetNumeric(true)
		panel:TextEntry("Shooting Temp Disable Time", "bc2_TempDisableTimeFire"):SetNumeric(true)

		panel:TextEntry("Cloak 1 Max Charge", "bc2_MaxCharge1"):SetNumeric(true)
		panel:TextEntry("Cloak 2 Max Charge", "bc2_MaxCharge2"):SetNumeric(true)
		panel:TextEntry("Cloak 3 Max Charge", "bc2_MaxCharge3"):SetNumeric(true)

		panel:TextEntry("Charge Gain Multiplier", "bc2_ChargeGainMultiplier"):SetNumeric(true)
		panel:TextEntry("Charge Loss Multiplier", "bc2_ChargeLossMultiplier"):SetNumeric(true)

		local CloakDamageMode = panel:ComboBox("Damaged While Cloaked Mode", "bc2_CloakDamageMode")
		CloakDamageMode:AddChoice("Disable Cloak", 1)
		CloakDamageMode:AddChoice("Lose Charge", 2)
		CloakDamageMode:AddChoice("Temp Disable", 3)
		CloakDamageMode:AddChoice("Nothing", 4)
		
		panel:TextEntry("Damaged Lose Charge Amount", "bc2_LoseChargeAmountHurt"):SetNumeric(true)
		panel:TextEntry("Damaged Temp Disable Time", "bc2_TempDisableTimeHurt"):SetNumeric(true)

		panel:TextEntry("Cloak Enable Effect", "bc2_CloakEffectOn")
		panel:TextEntry("Cloak Disable Effect", "bc2_CloakEffectOff")

		panel:TextEntry("Taunt Sound", "bc2_TauntSound")
		panel:NumSlider("Taunt Volume", "bc2_TauntVolume", 0, 1, 2)
		panel:TextEntry("Taunt Delay", "bc2_TauntDelay"):SetNumeric(true)

	end )
end )

cloakconfig = {}

-- Visual
cloakconfig["CloakType"] = GetConVar("bc2_CloakType"):GetString()
cloakconfig["CloakMode"] = GetConVar("bc2_CloakMode"):GetString()
cloakconfig["CloakUntilVel"] = GetConVar("bc2_CloakUntilVel"):GetInt()
cloakconfig["MinimumVisibility"] = GetConVar("bc2_MinimumVisibility"):GetInt()
cloakconfig["CloakMaterial"] = GetConVar("bc2_CloakMaterial"):GetString()
cloakconfig["ChargeGainMultiplier"] = GetConVar("bc2_ChargeGainMultiplier"):GetFloat()
cloakconfig["ChargeLossMultiplier"] = GetConVar("bc2_ChargeLossMultiplier"):GetFloat()
cloakconfig["MaxCharge0"] = 0
cloakconfig["MaxCharge1"] = GetConVar("bc2_MaxCharge1"):GetInt()
cloakconfig["MaxCharge2"] = GetConVar("bc2_MaxCharge2"):GetInt()
cloakconfig["MaxCharge3"] = GetConVar("bc2_MaxCharge3"):GetInt()
cloakconfig["MinimumNPCVisibility"] = GetConVar("bc2_MinimumNPCVisibility"):GetInt()
cloakconfig["UncloakInVehicle"] = GetConVar("bc2_UncloakInVehicle"):GetBool()
cloakconfig["CloakOverlay"] = GetConVar("bc2_CloakOverlay"):GetString()
cloakconfig["MinimumIDVisibility"] = GetConVar("bc2_MinimumIDVisibility"):GetInt()
cloakconfig["CloakFireMode"] = GetConVar("bc2_CloakFireMode"):GetInt()
cloakconfig["LoseChargeAmountFire"] = GetConVar("bc2_LoseChargeAmountFire"):GetFloat()
cloakconfig["TempDisableTimeFire"] = GetConVar("bc2_TempDisableTimeFire"):GetFloat()
cloakconfig["CloakDamageMode"] = GetConVar("bc2_CloakDamageMode"):GetInt()
cloakconfig["LoseChargeAmountHurt"] = GetConVar("bc2_LoseChargeAmountHurt"):GetFloat()
cloakconfig["TempDisableTimeHurt"] = GetConVar("bc2_TempDisableTimeHurt"):GetFloat()
cloakconfig["CloakEffectOn"] = GetConVar("bc2_CloakEffectOn"):GetString()
cloakconfig["CloakEffectOff"] = GetConVar("bc2_CloakEffectOff"):GetString()
cloakconfig["ToggleTime"] = GetConVar("bc2_ToggleTime"):GetFloat()
-- Audio
cloakconfig["DistortSound"] = GetConVar("bc2_DistortSound"):GetInt()
cloakconfig["EnableSound"] = GetConVar("bc2_EnableSound"):GetString()
cloakconfig["DisableSound"] = GetConVar("bc2_DisableSound"):GetString()
cloakconfig["ForceDisableSound"] = GetConVar("bc2_ForceDisableSound"):GetString()
cloakconfig["ToggleFailureSound"] = GetConVar("bc2_ToggleFailureSound"):GetString()
cloakconfig["FootstepVolume"] = GetConVar("bc2_FootstepVolume"):GetFloat()
cloakconfig["TauntSound"] = GetConVar("bc2_TauntSound"):GetString()
cloakconfig["TauntVolume"] = GetConVar("bc2_TauntVolume"):GetFloat()
cloakconfig["TauntDelay"] = GetConVar("bc2_TauntDelay"):GetFloat()




for k,v in pairs(cloakconfig) do
    cvars.AddChangeCallback(k, function(convarName, oldValue, newValue) 

            tableCV[convarName] = newValue


    end)
end
--PATH lua/weapons/cloaking-1/shared.lua:
AddCSLuaFile()
include("weapons/ce_bcr_config.lua")



//----------------------------------
// SWEP Info
//----------------------------------
SWEP.Author                 =   "Temporary Solutions"
SWEP.PrintName              =   "Cloaking - " .. cloakconfig.MaxCharge1 .. " Seconds"
SWEP.Base                   =   "weapon_base"
SWEP.Instructions           =   [[Left-Click: Toggle Cloak
Right-Click: N/A]]
SWEP.Spawnable              =   true
SWEP.AdminSpawnable         =   true
SWEP.AdminOnly 				= 	false
//----------------------------------
// SWEP Models
//----------------------------------
SWEP.ViewModelFlip          =   false
SWEP.UseHands               =   false
SWEP.ViewModel              =   "models/weapons/v_hands.mdl"
SWEP.WorldModel             =   ""
SWEP.HoldType               =   "normal"
//----------------------------------
// SWEP Slot Properties
//----------------------------------
SWEP.AutoSwitchTo           =   true
SWEP.AutoSwithFrom          =   true
SWEP.Slot                   =   5
SWEP.SlotPos                =   121
//----------------------------------
// SWEP Weapon Properties
//----------------------------------
SWEP.DrawAmmo               =   false
SWEP.DrawCrosshair          =   false
SWEP.m_WeaponDeploySpeed 	= 	100
SWEP.OnRemove = onDeathDropRemove
SWEP.OnDrop = onDeathDropRemove

SWEP.Primary.ClipSize       =   0
SWEP.Primary.DefaultClip    =   0
SWEP.Primary.Ammo           =   "none"
SWEP.Primary.Automatic      =   false
 
SWEP.Secondary.ClipSize     =   -1
SWEP.Secondary.DefaultClip  =   -1
SWEP.Secondary.Ammo         =   "none"
SWEP.Secondary.Automatic    =   false

--[[
	Hey me, don't forget if you're going to copy paste this for the other 3 sweps you need to:
	Change cloakconfig.MaxCharge1
	Edit SWEP:Equip, The Timers, and HudDraw
	And change ce_bc2_1
]]--

function SWEP:Initialize()
    self:SetHoldType(self.HoldType)

    sound.Add({
	name = "CloakTauntSound",
	channel = CHAN_STATIC,
	volume = cloakconfig.TauntVolume,
	level = 70,
	pitch = { 95, 100 },
	sound = cloakconfig.TauntSound})
end


local function Cloak(ply)
	local plyVelocity = ply:GetVelocity()
    local plyWeapon = ply:GetActiveWeapon()
    local col = ply:GetColor()
    ply:SetNWBool("HideHUD", true)

    local untilVelAlpha = math.max(0, plyVelocity:Length() - cloakconfig.CloakUntilVel) 	-- Keeps player completly cloaked until they meet a set velocity.
    local approachAlpha = math.Approach(col.a, untilVelAlpha, 500 * FrameTime()) 	-- Gradually get to the alpha (Instead of snapping to it).
    approachAlpha = math.max(approachAlpha, cloakconfig.MinimumVisibility) 	-- If the alpha is being set below the set minimum, just use the minimum.

    --[[
    	This is a fix for most weapons not going invisible unless the
    	alpha is 0. I don't think I can fix this as
    	it probably has to do with the weapon's models or textures.
    --]]
    local wepAlpha = 0
    
    if untilVelAlpha >= 70 then
    	wepAlpha = untilVelAlpha
   	else
   		wepAlpha = 0
   	end

   	if cloakconfig.CloakEffectOn != "" then
   		local effectpos = ply:GetPos()
		local effectdata = EffectData()
		effectdata:SetOrigin(effectpos)
		effectdata:SetNormal(Vector(0, 0, 0))
		util.Effect(cloakconfig.CloakEffectOn, effectdata)
	end


	ply:RemoveAllDecals()
	ply:DrawShadow(false)
	ply:SetDSP(cloakconfig.DistortSound)

	if cloakconfig.CloakType == "Transparent" then
		ply:SetRenderMode(RENDERMODE_TRANSALPHA)
		ply:SetColor(Color(255, 255, 255, approachAlpha))
		plyWeapon:SetRenderMode(RENDERMODE_TRANSALPHA)
		plyWeapon:SetColor(Color(255, 255, 255, wepAlpha))
	elseif cloakconfig.CloakType == "Material" then
		ply:SetMaterial(cloakconfig.CloakMaterial, true)
		plyWeapon:SetMaterial(cloakconfig.CloakMaterial, true)
	end

	if SERVER then
		if approachAlpha < cloakconfig.MinimumNPCVisibility then
			ply:SetNoTarget(true)
		else
			ply:SetNoTarget(false)
		end
	end
end



local function Uncloak(ply, forced, debug, holdcharge)
	--print(debug)
	if forced and cloakconfig.ForceDisableSound ~= "" and ply.CloakActive then
		ply:EmitSound(cloakconfig.ForceDisableSound)
		--print("1 1")
	elseif cloakconfig.DisableSound ~= ""  and debug ~= "Equip" and ply.CloakActive then
		ply:EmitSound(cloakconfig.DisableSound)
		--print("1 2")
	end
	ply:SetNWBool("HideHUD", false)
	ply.CloakActive = false
	ply:SetDSP(0)
    ply:DrawShadow(true)
    ply:SetRenderMode(RENDERMODE_NORMAL)
    ply:SetColor(Color(255, 255, 255, 255))
    ply:SetMaterial("")

    if SERVER then
    	ply:SetNoTarget(false)
    end

    if not holdcharge then
   		ply:SetNWFloat("CloakCharge", cloakconfig.MaxCharge1)
   	end

    timer.Simple(cloakconfig.ToggleTime, function()
		ply.AllowedToggle = true
	end)

    if cloakconfig.CloakEffectOff ~= "" then
   		local effectpos = ply:GetPos()
		local effectdata = EffectData()
		effectdata:SetOrigin(effectpos)
		effectdata:SetNormal(Vector(0, 0, 0))
		util.Effect(cloakconfig.CloakEffectOff, effectdata)
	end

    for k, v in pairs(ply:GetWeapons()) do 	-- Uncloaks previously cloaked weapons
    	if IsValid(v) then
    		v:SetRenderMode(RENDERMODE_NORMAL)
   	 		v:SetColor(Color(255, 255, 255, 255))
   	 	end
   	end
end



local DontSpam = 0
function SWEP:PrimaryAttack()
	local ply = self:GetOwner()

	if ply.CloakActive == nil then
		ply.CloakActive = false
	elseif ply.AllowedToggle == nil then
		ply.AllowedToggle = true
	end

	if DontSpam < CurTime() then
		if SERVER then
			if not ply.CloakActive and ply.AllowedToggle then
				ply.CloakActive = true
				ply.AllowedToggle = false
				if cloakconfig.EnableSound != "" then
   					ply:EmitSound(cloakconfig.EnableSound)
   				end
			elseif ply.CloakActive then
				if cloakconfig.CloakMode == "Charge" then
					Uncloak(ply, false, "Primary", true)
				else
					Uncloak(ply, false, "Primary")
				end
			else
				if cloakconfig.ToggleFailureSound != "" then
				ply:EmitSound(cloakconfig.ToggleFailureSound)
				end
			end
		end
		DontSpam = CurTime() + 0.5
	end
end



function SWEP:CanSecondaryAttack()	
	return false
end



function SWEP:Reload()
	ply = self:GetOwner()
	if (self.nextreload or 0) <= CurTime() and cloakconfig.TauntSound != "" then
    	self.nextreload = CurTime() + cloakconfig.TauntDelay
		ply:EmitSound("CloakTauntSound")
	end
end



function SWEP:Deploy()
	self.Owner:DrawViewModel(false)
end



function SWEP:Equip()
	local ply = self.Owner

	--(Removes Other Cloaks)--
	if ply:HasWeapon("cloaking-infinite") then
		ply:StripWeapon("cloaking-infinite")
	elseif ply:HasWeapon("cloaking-2") then
		ply:StripWeapon("cloaking-2")
	elseif ply:HasWeapon("cloaking-3") then
		ply:StripWeapon("cloaking-3")
	end

	Uncloak(ply, false, "Equip")

	if cloakconfig.CloakMode == "Rechage" then
		self.Owner.CloakCharge = cloakconfig.MaxCharge1
	end
end



hook.Add("PlayerPostThink", "ce_bc2_1_ThinkHook", function(ply)
	if ply.CloakActive then
		Cloak(ply)
	end

	if not ply.LastCharge then
		ply.LastCharge = CurTime()
	end

	if SERVER and ply:HasWeapon("cloaking-1") then
		if cloakconfig.CloakMode == "Charge" and cloakconfig.MaxCharge1 != 0 then
			if ply.LastCharge + (1 * cloakconfig.ChargeLossMultiplier) <= CurTime() and ply:GetNWFloat("CloakCharge") > 0 and ply.CloakActive then 	-- Depletes Charge
				ply:SetNWFloat("CloakCharge", ply:GetNWFloat("CloakCharge") - 1)
				ply.LastCharge = CurTime()
			elseif ply.LastCharge + (1 * cloakconfig.ChargeGainMultiplier) <= CurTime() and ply:GetNWFloat("CloakCharge") < cloakconfig.MaxCharge1 and !ply.CloakActive and !ply.CloakPause then 	-- Adds Charge
				ply:SetNWFloat("CloakCharge", ply:GetNWFloat("CloakCharge") + 1)
				ply.LastCharge = CurTime()
			elseif ply.CloakActive and ply:GetNWFloat("CloakCharge") == 0 then	-- Uncloaks when out of charge
				Uncloak(ply, true, "Charge", true)
			end
		end
	end

	-- Its like charge, without the recharge
	if ply:HasWeapon("cloaking-1") then
		if cloakconfig.CloakMode == "Timer" and cloakconfig.MaxCharge1 != 0 then
			if ply.LastCharge + 1 <= CurTime() and ply:GetNWFloat("CloakCharge") > 0 and ply.CloakActive then
				ply:SetNWFloat("CloakCharge", ply:GetNWFloat("CloakCharge") - 1)
				ply.LastCharge = CurTime()
			elseif ply.CloakActive and ply:GetNWFloat("CloakCharge") == 0 then
				Uncloak(ply, true, "Timer")
				ply:SetNWFloat("CloakCharge", cloakconfig.MaxCharge1)
			end
		end
	end
		-- Copy pasted as an attempted bugfix for some weapons being a pain in the ass
	local plyVelocity = ply:GetVelocity()
    local plyWeapon = ply:GetActiveWeapon()
    local col = ply:GetColor()

    local untilVelAlpha = math.max(0, plyVelocity:Length() - cloakconfig.CloakUntilVel) 	-- Keeps player completly cloaked until they meet a set velocity.
    local approachAlpha = math.Approach(col.a, untilVelAlpha, 500 * FrameTime()) 	-- Gradually get to the alpha (Instead of snapping to it).
    approachAlpha = math.max(approachAlpha, cloakconfig.MinimumVisibility) 	-- If the alpha is being set below the set minimum, just use the minimum.

    --[[
    	This is a fix for most weapons not going invisible unless the
    	alpha is 0. I don't think I can fix this as
    	it probably has to do with the weapon's models or textures.
    --]]
    local wepAlpha = 0
    
    if untilVelAlpha >= 70 then
    	wepAlpha = untilVelAlpha
   	else
   		wepAlpha = 0
   	end

   	if cloakconfig.CloakType == "Transparent" and ply.CloakActive then
		plyWeapon:SetRenderMode(RENDERMODE_TRANSALPHA)
		plyWeapon:SetColor(Color(255, 255, 255, wepAlpha))
	elseif cloakconfig.CloakType == "Material" and ply.CloakActive then
		plyWeapon:SetMaterial(cloakconfig.CloakMaterial, true)
	end
end)



hook.Add("EntityFireBullets", "ce_bc2_1_UncloakOnFire", function(ent, bullet)
	if IsValid(ent) and ent:IsPlayer() and ent.CloakActive then
		if cloakconfig.CloakFireMode == 1 then
			Uncloak(ent, true, "Fired")
		elseif cloakconfig.CloakFireMode == 2 then
			if cloakconfig.CloakMode == "Charge" then
				ent:SetNWFloat("CloakCharge", ent:GetNWFloat("CloakCharge") - cloakconfig.LoseChargeAmountFire)
			elseif cloakconfig.CloakMode == "Timer" then
				print("Yeah you probably shouldn't set a charge option if you're using the timer mode.\nDefaulting to Option 1")
				GetConVar("bc2_CloakFireMode"):SetInt(1)
				Uncloak(ent, true, "Fired2")
			end
		elseif cloakconfig.CloakFireMode == 3 and ent:Alive() then
			Uncloak(ent, true, "Fired3", true)
			ent.AllowedToggle = false
			ent.CloakPause = true
			timer.Simple(cloakconfig.TempDisableTimeFire, function()
				if IsValid(ent) and not ent.DidSomethingStupid then
					ent.CloakActive = true
				end
			ent.AllowedToggle = true
			ent.DidSomethingStupid = false
			ent.CloakPause = false
			end)
		end
	end
end)



hook.Add("EntityTakeDamage", "ce_bc2_1_UncloakOnDamage", function(ent, dmginfo)
	if IsValid(ent) and ent:IsPlayer() and ent.CloakActive then
		if cloakconfig.CloakDamageMode == 1 then
			Uncloak(ent, true, "Damage")
		elseif cloakconfig.CloakDamageMode == 2 then
			if cloakconfig.CloakMode == "Charge" then
				ent:SetNWFloat("CloakCharge", ent:GetNWFloat("CloakCharge") - cloakconfig.LoseChargeAmountHurt)
			elseif cloakconfig.CloakMode == "Timer" then
				print("Yeah you probably shouldn't set a charge option if you're using the timer mode.\nDefaulting to Option 1")
				GetConVar("bc2_CloakDamageMode"):SetInt(1)
				Uncloak(ent, true, "Damage2")
			end
		elseif cloakconfig.CloakDamageMode == 3 and ent:Alive() then
			Uncloak(ent, true, "Damage3", true)
			ent.AllowedToggle = false
			ent.CloakPause = true
			timer.Simple(cloakconfig.TempDisableTimeHurt, function()
				if IsValid(ent) and not ent.DidSomethingStupid then
					ent.CloakActive = true
				end
			ent.AllowedToggle = true
			ent.DidSomethingStupid = false
			ent.CloakPause = false
			end)
		end
	end
end)



hook.Add("PlayerFootstep", "ce_bc2_1_SilentSteps", function(ply, pos, foot, sound, volume, rf)
    if ply.CloakActive then
    	ply:EmitSound(sound, 20, nil, cloakconfig.FootstepVolume, 4)
   		return true
	else
    	return false
 	end
end)



hook.Add("HUDDrawTargetID", "ce_bc2_1_HidePlayerID", function()
	if CLIENT then
    	local gplytr = util.GetPlayerTrace(LocalPlayer())
    	local ent = util.TraceLine(gplytr).Entity
    	local col = 255
    	if IsValid(ent) then
    		col = ent:GetColor()
    	end

    	if ent:IsPlayer() and IsValid(ent) then
    		if cloakconfig.CloakType == "Transparent" and ent.CloakActive and col.a < cloakconfig.MinimumIDVisibility then
        		return false
        	elseif cloakconfig.CloakType == "Material" and ent.CloakActive then
           		return false
           	else
           		return
        	end
        end
	end
end)



hook.Add("HUDPaint", "ce_bc2_1_DrawThings", function()
	local ply = LocalPlayer()
	if IsValid(ply) and ply:Alive() and IsValid(ply:GetActiveWeapon()) then

		local activeweapon = ply:GetActiveWeapon():GetClass()

		if ply.CloakActive and cloakconfig.CloakOverlay ~= "" then
			surface.SetDrawColor(255, 255, 255, 255)
			surface.SetMaterial(Material(cloakconfig.CloakOverlay))
			surface.DrawTexturedRect( 0, 0, ScrW(), ScrH())
		end

		if ply:HasWeapon("cloaking-1") and GetConVar("bc2_ShowCloakCharge"):GetBool() and (activeweapon == "cloaking-1" or ply:GetNWFloat("CloakCharge") != cloakconfig.MaxCharge1) and cloakconfig.MaxCharge1 != 0 then
			draw.SimpleText(ply:GetNWFloat("CloakCharge"), "DermaLarge", ScrW()/2 - 25, 900, Color(255, 255, 255, 255), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
		end
	end
end)



hook.Add("HUDShouldDraw", "DarkRP_HideDarkPlayerID", function(hudName)
    if hudName ~= "DarkRP_EntityDisplay" then return end

    local playersToDraw = {}
    for _,ply in pairs(player.GetAll()) do
        if IsValid(ply) and not ply:GetNWBool("HideHUD") then
            table.insert(playersToDraw, ply)
        end
    end
    return true, playersToDraw
end)



hook.Add("PlayerEnteredVehicle", "ce_bc2_1_UncloakEnteringVehicle", function(ply, veh, seat)
	if ply.CloakActive and cloakconfig.UncloakInVehicle then
		Uncloak(ply, false, "Vehicle")
	end
end)


-- Accidents
local function onDemote(source, demoted, reason)
	if demoted.CloakActive then
	Uncloak(demoted, false, "Demoted")
	demoted.DidSomethingStupid = true
	end
end

local function UncloakOnAccident(ply)
	Uncloak(ply, false, "Accident")
	ply.DidSomethingStupid = true
end

hook.Add("PlayerDeath", "ce_bc2_1_Death" , UncloakOnAccident)
hook.Add("playerAFKDemoted", "ce_bc2_1_AFK" , UncloakOnAccident)
hook.Add("onPlayerDemoted", "ce_bc2_1_Demoted" , onDemote)
hook.Add("playerArrested", "ce_bc2_1_Arrested" , UncloakOnAccident)
hook.Add("playerStarved", "ce_bc2_1_Starved" , UncloakOnAccident)
hook.Add("OnPlayerChangedTeam", "ce_bc2_1_ChangedTeam" , UncloakOnAccident)
--PATH lua/weapons/cloaking-3/shared.lua:
return gluapack()()
--PATH lua/weapons/cloaking-infinite/shared.lua:
return gluapack()()
--PATH lua/weapons/deployable_force_shield_augment_wep.lua:
return gluapack()()
--PATH lua/weapons/dual_base/shared.lua:
return gluapack()()
--PATH lua/weapons/f187cutter.lua:
AddCSLuaFile()

SWEP.Category = "[LVS]"
SWEP.Spawnable			= true
SWEP.AdminSpawnable		= false
SWEP.ViewModel			= "models/f137/f187_cutter.mdl"
SWEP.WorldModel			= "models/f137/w_repairtorch.mdl"
SWEP.UseHands				= true

SWEP.HoldType				= "slam"

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip		= -1
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo			= "none"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic		= false
SWEP.Secondary.Ammo		= "none"

SWEP.MaxRange = 100

function SWEP:SetupDataTables()
	self:NetworkVar( "Float",0, "FlameTime" )
end

function SWEP:GetLVS()
	local ply = self:GetOwner()

	if not IsValid( ply ) then return NULL end

	local ent = ply:GetEyeTrace().Entity

	if not IsValid( ent ) then return NULL end

	if ent.LVS then return ent end

	if not ent.GetBase then return NULL end

	ent = ent:GetBase()

	if IsValid( ent ) and ent.LVS then return ent end

	return NULL
end

function SWEP:FindClosest()
	local lvsEnt = self:GetLVS()

	if not IsValid( lvsEnt ) then return NULL end

	local ply = self:GetOwner()

	if ply:InVehicle() then return end

	local ShootPos = ply:GetShootPos()
	local AimVector = ply:GetAimVector()

	local ClosestDist = self.MaxRange
	local ClosestPiece = NULL

	for _, entity in pairs( lvsEnt:GetChildren() ) do
		if entity:GetClass() ~= "lvs_wheeldrive_armor" then continue end

		local boxOrigin = entity:GetPos()
		local boxAngles = entity:GetAngles()
		local boxMins = entity:GetMins()
		local boxMaxs = entity:GetMaxs()

		local HitPos, _, _ = util.IntersectRayWithOBB( ShootPos, AimVector * 1000, boxOrigin, boxAngles, boxMins, boxMaxs )

		if isvector( HitPos ) then
			local Dist = (ShootPos - HitPos):Length()

			if Dist < ClosestDist then
				ClosestDist = Dist
				ClosestPiece = entity
			end
		end
	end

	return ClosestPiece
end

function SWEP:Initialize()
	self:SetHoldType( self.HoldType )
end

function SWEP:PrimaryAttack()
	local T = CurTime()

	self:SetNextPrimaryFire(T + 0.15)
	self:SetFlameTime(T + 0.3)

	local ply = self:GetOwner()

	if not IsValid(ply) then return end

	local trace = ply:GetEyeTrace()
	local target = trace.Entity
	local distance = trace.HitPos:Distance(ply:GetShootPos())

	if distance > self.MaxRange then return end

	local lvsTarget = self:GetLVS()
	if IsValid(lvsTarget) and distance <= self.MaxRange then
		local HP = lvsTarget:GetHP()
		local MaxHP = lvsTarget:GetMaxHP()

		if IsFirstTimePredicted() then
			if HP ~= MaxHP then
				local effectdata = EffectData()
				effectdata:SetOrigin(trace.HitPos)
				effectdata:SetNormal(trace.HitNormal)
				util.Effect("stunstickimpact", effectdata, true, true)
			end
		end

		if SERVER then
			lvsTarget:SetHP(math.min(HP + 7, MaxHP))

			if lvsTarget.GetDestroyed and lvsTarget:GetDestroyed() then
				lvsTarget:SetDestroyed(false)
			end

			if lvsTarget.OnRepaired then
				lvsTarget:OnRepaired()
			end
		end

		return
	end

	if IsValid(target) and distance <= self.MaxRange then
		if target:IsPlayer() or target:IsNPC() or target:GetClass() == "prop_physics" then
			if SERVER then
				if target:IsPlayer() and target:Nick() == "P1-R8" then
					-- Heal player P1-R8
					target:SetHealth(math.min(target:Health() + 10, target:GetMaxHealth()))
					target:SetArmor(math.min(target:Armor() + 5, 100))

					-- Healing visual effect
					local effectdata = EffectData()
					effectdata:SetOrigin(target:GetPos())
					effectdata:SetNormal(Vector(0, 0, 1))
					util.Effect("stunstickimpact", effectdata, true, true)
				else
					-- Default damage behavior
					local dmginfo = DamageInfo()
					dmginfo:SetDamage(2)
					dmginfo:SetDamageType(DMG_BURN)
					dmginfo:SetAttacker(ply)
					dmginfo:SetInflictor(self)
					target:TakeDamageInfo(dmginfo)
				end
			end
		end
	end
end

function SWEP:SecondaryAttack()
end

function SWEP:Think()
	local ply = self:GetOwner()

	if not IsValid( ply ) then self:StopSND() return end

	local PlaySound = self:GetFlameTime() >= CurTime() and (ply:GetShootPos() - ply:GetEyeTrace().HitPos):Length() < self.MaxRange

	if PlaySound then
		self:PlaySND()
	else
		self:StopSND()
	end
end

function SWEP:StopSND()
	if CLIENT then return end

	if not self._snd then return end

	self._snd:Stop()
	self._snd = nil
end

function SWEP:PlaySND()
	if CLIENT then return end

	if self._snd then return end

	local ply = self:GetOwner()

	if not IsValid( ply ) then return end

	self._snd = CreateSound( ply, "lvs/weldingtorch_loop.wav" )
	self._snd:PlayEx(1, 70 )
end

function SWEP:OnRemove()
	self:StopSND()
end

function SWEP:OnDrop()
	self:StopSND()
end

function SWEP:Holster( wep )
	self:StopSND()
	return true
end

--PATH lua/weapons/gas_weapon_hands.lua:
AddCSLuaFile()

SWEP.PrintName = "Hands"
SWEP.Slot = 0
SWEP.SlotPos = 0

SWEP.DrawAmmo = false

SWEP.Spawnable = false

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

SWEP.DrawCrosshair = false

SWEP.WorldModel = ""

SWEP.Instructions = "You are temporarily restricted to this weapon only."

function SWEP:Initialize()
	self:SetHoldType("normal")
end

function SWEP:Deploy()
	if (CLIENT or not IsValid(self:GetOwner())) then return true end
	self:GetOwner():DrawWorldModel(false)
	return true
end

function SWEP:PreDrawViewModel()
	return true
end

function SWEP:PrimaryAttack() end
function SWEP:SecondaryAttack() end
function SWEP:Reload() end
--PATH lua/weapons/gmod_tool/stools/advdupe2.lua:
--[[
	Title: Adv. Dupe 2 Tool

	Desc: Defines the AD2 tool and assorted functionalities.

	Author: TB

	Version: 1.0
]]

TOOL.Category = "Construction"
TOOL.Name = "#Tool.advdupe2.name"
cleanup.Register( "AdvDupe2" )
require( "controlpanel" )

if(SERVER) then
	CreateConVar("sbox_maxgmod_contr_spawners",5)

	local phys_constraint_system_types = {
		Weld          = true,
		Rope          = true,
		Elastic       = true,
		Slider        = true,
		Axis          = true,
		AdvBallsocket = true,
		Motor         = true,
		Pulley        = true,
		Ballsocket    = true,
		Winch         = true,
		Hydraulic     = true,
		WireMotor     = true,
		WireHydraulic = true
	}
	--Orders constraints so that the dupe uses as little constraint systems as possible
	local function GroupConstraintOrder( ply, constraints )
		--First separate the nocollides, sorted, and unsorted constraints
		local sorted, unsorted = {}, {}
		for k, v in pairs(constraints) do
			if phys_constraint_system_types[v.Type] then
				sorted[#sorted+1] = v
			else
				unsorted[#unsorted+1] = v
			end
		end

		local sortingSystems = {}
		local fullSystems = {}
		local function buildSystems(input)
			while next(input) ~= nil do
				for k, v in pairs(input) do
					for systemi, system in pairs(sortingSystems) do
						for _, target in pairs(system) do
							for x = 1, 4 do
								if v.Entity[x] then
									for y = 1, 4 do
										if target.Entity[y] and v.Entity[x].Index == target.Entity[y].Index then
											system[#system + 1] = v
											if #system == 100 then
												fullSystems[#fullSystems + 1] = system
												table.remove(sortingSystems, systemi)
											end
											input[k] = nil
											goto super_loopbreak
										end
									end
								end
							end
						end
					end
				end

				--Normally skipped by the goto unless no cluster is found. If so, make a new one.
				local k = next(input)
				sortingSystems[#sortingSystems + 1] = {input[k]}
				input[k] = nil

				::super_loopbreak::
			end
		end
		buildSystems(sorted)

		local ret = {}
		for _, system in pairs(fullSystems) do
			for _, v in pairs(system) do
				ret[#ret + 1] = v
			end
		end
		for _, system in pairs(sortingSystems) do
			for _, v in pairs(system) do
				ret[#ret + 1] = v
			end
		end
		for k, v in pairs(unsorted) do
			ret[#ret + 1] = v
		end

		if #fullSystems ~= 0 then
			ply:ChatPrint("DUPLICATOR: WARNING, Number of constraints exceeds 100: (".. #ret .."). Constraint sorting might not work as expected.")
		end

		return ret
	end

	local function CreationConstraintOrder( constraints )
		local ret = {}
		for k, v in pairs( constraints ) do
			ret[#ret + 1] = k
		end
		table.sort(ret)
		for i = 1, #ret do
			ret[i] = constraints[ret[i]]
		end
		return ret
	end

	local function GetSortedConstraints( ply, constraints )
		if ply:GetInfo("advdupe2_sort_constraints") ~= "0" then
			return GroupConstraintOrder( ply, constraints )
		else
			return CreationConstraintOrder( constraints )
		end
	end

	local areacopy_classblacklist = {
		gmod_anchor = true
	}

	local function PlayerCanDupeCPPI(ply, ent)
		if not AdvDupe2.duplicator.IsCopyable(ent) or areacopy_classblacklist[ent:GetClass()] then return false end
		return ent:CPPIGetOwner()==ply
	end

	-- Code from WireLib.CanTool
	local zero = Vector(0, 0, 0)
	local norm = Vector(1, 0, 0)

	local tr = { ---@type TraceResult
		Hit = true, HitNonWorld = true, HitNoDraw = false, HitSky = false, AllSolid = true,
		HitNormal = zero, Normal = norm,

		Fraction = 1, FractionLeftSolid = 0,
		HitBox = 0, HitGroup = 0, HitTexture = "**studio**",
		MatType = 0, PhysicsBone = 0, SurfaceProps = 0, DispFlags = 0, Contents = 0,

		Entity = NULL, HitPos = zero, StartPos = zero,
	}

	local function PlayerCanDupeTool(ply, ent)
		if not AdvDupe2.duplicator.IsCopyable(ent) or areacopy_classblacklist[ent:GetClass()] then return false end

		local pos = ent:GetPos()
		tr.Entity, tr.HitPos, tr.StartPos = ent, pos, pos

		return hook.Run( "CanTool", ply, tr, "advdupe2" ) ~= false
	end

	--Find all the entities in a box, given the adjacent corners and the player
	local function FindInBox(min, max, ply)
		local PPCheck = (tobool(ply:GetInfo("advdupe2_copy_only_mine")) and ply.CPPIGetOwner~=nil) and PlayerCanDupeCPPI or PlayerCanDupeTool
		local EntTable = {}
		for _, ent in ents.Iterator() do
			local pos = ent:GetPos()
			if (pos.X>=min.X) and (pos.X<=max.X) and
				 (pos.Y>=min.Y) and (pos.Y<=max.Y) and
				 (pos.Z>=min.Z) and (pos.Z<=max.Z) and PPCheck( ply, ent ) then
				EntTable[ent:EntIndex()] = ent
			end
		end

		return EntTable
	end

	--[[
		Name: GetDupeAngleOffset
		Desc: Retrieves duplication angle offsets from player
		Returns: <angle> Created angle
	]]
	local function GetDupeAngleOffset(ply)
		local p = math.Clamp(ply:GetInfoNum("advdupe2_offset_pitch", 0), -180, 180)
		local y = math.Clamp(ply:GetInfoNum("advdupe2_offset_yaw"  , 0), -180, 180)
		local r = math.Clamp(ply:GetInfoNum("advdupe2_offset_roll" , 0), -180, 180)
		return Angle(p, y, r)
	end

	--[[
		Name: GetDupeElevation
		Desc: Retrieves duplication Z elevation
		Returns: <number> Dupe elevation
	]]
	local function GetDupeElevation(ply)
		local con = ply:GetInfoNum("advdupe2_offset_z", 0)
		local enz = (tonumber(ply.AdvDupe2.HeadEnt.Z) or 0)
		return math.Clamp(con + enz, -32000, 32000)
	end

	--[[
		Name: LeftClick
		Desc: Defines the tool's behavior when the player left-clicks.
		Params: <trace> trace
		Returns: <boolean> success
	]]
	function TOOL:LeftClick( trace )
		if(not trace) then return false end

		local ply = self:GetOwner()
		local dupe = ply.AdvDupe2

		if not (dupe and dupe.Entities) then return false end

		if(dupe.Pasting or dupe.Downloading) then
			AdvDupe2.Notify(ply,"Advanced Duplicator 2 is busy.",NOTIFY_ERROR)
			return false
		end

		dupe.Angle = GetDupeAngleOffset(ply)
		dupe.Position = Vector(trace.HitPos)
		dupe.Position.z = dupe.Position.z + GetDupeElevation(ply)

		if(tobool(ply:GetInfo("advdupe2_offset_world"))) then
			dupe.Angle = dupe.Angle - dupe.Entities[dupe.HeadEnt.Index].PhysicsObjects[0].Angle
		end

		dupe.Pasting = true
		AdvDupe2.Notify(ply,"Pasting...")
		local origin
		if(tobool(ply:GetInfo("advdupe2_original_origin"))) then
			origin = dupe.HeadEnt.Pos
		end

		AdvDupe2.InitPastingQueue(ply, dupe.Position, dupe.Angle, origin,
			tobool(ply:GetInfo("advdupe2_paste_constraints")),
			tobool(ply:GetInfo("advdupe2_paste_parents")),
			tobool(ply:GetInfo("advdupe2_paste_disparents")),
			tobool(ply:GetInfo("advdupe2_paste_protectoveride")))

		return true
	end

	--[[
		Name: RightClick
		Desc: Defines the tool's behavior when the player right-clicks.
		Params: <trace> trace
		Returns: <boolean> success
	]]
	function TOOL:RightClick( trace )
		local ply = self:GetOwner()
		local dupe = ply.AdvDupe2

		if not dupe then dupe = {}; ply.AdvDupe2 = dupe end

		if(dupe.Pasting or dupe.Downloading) then
			AdvDupe2.Notify(ply,"Advanced Duplicator 2 is busy.", NOTIFY_ERROR)
			return false
		end

		--Set Area Copy on or off
		if( ply:KeyDown(IN_SPEED) and not ply:KeyDown(IN_WALK) ) then
			if(self:GetStage()==0) then
				AdvDupe2.DrawSelectBox(ply)
				self:SetStage(1)
				return false
			elseif(self:GetStage()==1) then
				AdvDupe2.RemoveSelectBox(ply)
				self:SetStage(0)
				return false
			end
		end

		if(not trace or not trace.Hit) then return false end

		local Entities, Constraints, AddOne
		local HeadEnt = {}
		--If area copy is on
		if(self:GetStage()==1) then
			local area_size = math.Clamp(tonumber(ply:GetInfo("advdupe2_area_copy_size")) or 50, 0, 30720)
			local Pos = trace.HitNonWorld and trace.Entity:GetPos() or trace.HitPos
			local T = (Vector(area_size,area_size,area_size)+Pos)
			local B = (Vector(-area_size,-area_size,-area_size)+Pos)

			local Ents = FindInBox(B,T, ply)
			local _, Ent = next(Ents)
			if not Ent then
				self:SetStage(0)
				AdvDupe2.RemoveSelectBox(ply)
				return true
			end

			Ent = trace.HitNonWorld and trace.Entity or Ent
			HeadEnt.Index = Ent:EntIndex()
			HeadEnt.Pos = Ent:GetPos()

			Entities, Constraints = AdvDupe2.duplicator.AreaCopy(ply, Ents, HeadEnt.Pos, tobool(ply:GetInfo("advdupe2_copy_outside")))

			self:SetStage(0)
			AdvDupe2.RemoveSelectBox(ply)
		elseif trace.HitNonWorld then	--Area Copy is off
			-- Filter duplicator blocked entities out.
			if not AdvDupe2.duplicator.IsCopyable( trace.Entity ) then
				return false
			end

			--If Alt is being held, add a prop to the dupe
			if(ply:KeyDown(IN_WALK) and dupe.Entities~=nil and next(dupe.Entities)~=nil) then
				Entities = dupe.Entities
				Constraints = dupe.Constraints
				HeadEnt = dupe.HeadEnt

				AdvDupe2.duplicator.Copy( ply, trace.Entity, Entities, Constraints, HeadEnt.Pos)

				--Only add the one ghost
				AddOne = Entities[trace.Entity:EntIndex()]
			else
				Entities = {}
				Constraints = {}
				HeadEnt.Index = trace.Entity:EntIndex()
				HeadEnt.Pos = trace.HitPos

				AdvDupe2.duplicator.Copy( ply, trace.Entity, Entities, Constraints, trace.HitPos )
			end
		else --Non valid entity or clicked the world
			if dupe.Entities then
				--clear the dupe
				net.Start("AdvDupe2_RemoveGhosts")
				net.Send(ply)
				dupe.Entities = nil
				dupe.Constraints = nil
				net.Start("AdvDupe2_ResetDupeInfo")
				net.Send(ply)
				AdvDupe2.ResetOffsets(ply)
				return true
			else
				--select all owned props
				Entities = {}
				local PPCheck = (tobool(ply:GetInfo("advdupe2_copy_only_mine")) and CPPI~=nil) and PlayerCanDupeCPPI or PlayerCanDupeTool
				for _, ent in ents.Iterator() do
					if PPCheck( ply, ent ) then
						Entities[ent:EntIndex()] = ent
					end
				end

				local _, Ent = next(Entities)
				if not Ent then
				net.Start("AdvDupe2_RemoveGhosts")
				net.Send(ply)
					return true
				end

				HeadEnt.Index = Ent:EntIndex()
				HeadEnt.Pos = Ent:GetPos()

				Entities, Constraints = AdvDupe2.duplicator.AreaCopy(ply, Entities, HeadEnt.Pos, tobool(ply:GetInfo("advdupe2_copy_outside")))
			end
		end

		if not HeadEnt.Z then
			local WorldTrace = util.TraceLine({
				mask   = MASK_NPCWORLDSTATIC,
				start  = HeadEnt.Pos + Vector(0,0,1),
				endpos = HeadEnt.Pos-Vector(0,0,50000)
			})

			HeadEnt.Z = WorldTrace.Hit and math.abs(HeadEnt.Pos.Z - WorldTrace.HitPos.Z) or 0
		end

		dupe.HeadEnt = HeadEnt
		dupe.Entities = Entities
		dupe.Constraints = GetSortedConstraints(ply, Constraints)
		dupe.Revision = AdvDupe2.CodecRevision

		net.Start("AdvDupe2_SetDupeInfo")
			net.WriteString("")
			net.WriteString(ply:Nick())
			net.WriteString(os.date("%d %B %Y"))
			net.WriteString(os.date("%I:%M %p"))
			net.WriteString("")
			net.WriteString("")
			net.WriteString(table.Count(dupe.Entities))
			net.WriteString(#dupe.Constraints)
		net.Send(ply)

		if AddOne then
			AdvDupe2.SendGhost(ply, AddOne)
		else
			AdvDupe2.SendGhosts(ply)
		end

		AdvDupe2.ResetOffsets(ply)

		return true
	end

	--Checks table, re-draws loading bar, and recreates ghosts when tool is pulled out
	function TOOL:Deploy()
		local ply = self:GetOwner()
		local dupe = ply.AdvDupe2

		if not dupe then dupe = {}; ply.AdvDupe2 = dupe end

		if(not dupe.Entities) then return end

		net.Start("AdvDupe2_StartGhosting")
		net.Send(ply)

		if(dupe.Queued) then
			AdvDupe2.InitProgressBar(ply, "Queued: ")
			return
		end

		if(dupe.Pasting) then
			AdvDupe2.InitProgressBar(ply, "Pasting: ")
			return
		else
			if(dupe.Uploading) then
				AdvDupe2.InitProgressBar(ply, "Opening: ")
				return
			elseif(dupe.Downloading) then
				AdvDupe2.InitProgressBar(ply, "Saving: ")
				return
			end
		end

	end

	--Removes progress bar
	function TOOL:Holster()
		AdvDupe2.RemoveProgressBar(self:GetOwner())
	end

	--[[
		Name: Reload
		Desc: Creates an Advance Contraption Spawner.
		Params: <trace> trace
		Returns: <boolean> success
	]]
	function TOOL:Reload( trace )
		if(not trace.Hit) then return false end

		local ply = self:GetOwner()
		local dupe = ply.AdvDupe2

		if not dupe then dupe = {}; ply.AdvDupe2 = dupe end

		if(self:GetStage()==1) then
			local areasize = math.Clamp(tonumber(ply:GetInfo("advdupe2_area_copy_size")) or 50, 0, 30720)
			net.Start("AdvDupe2_CanAutoSave")
				net.WriteVector(trace.HitPos)
				net.WriteFloat(areasize)
				if(trace.Entity) then
					net.WriteUInt(trace.Entity:EntIndex(), 16)
				else
					net.WriteUInt(0, 16)
				end
			net.Send(ply)
			self:SetStage(0)
			AdvDupe2.RemoveSelectBox(ply)
			dupe.TempAutoSavePos = trace.HitPos
			dupe.TempAutoSaveSize = areasize
			dupe.TempAutoSaveOutSide = tobool(ply:GetInfo("advdupe2_copy_outside"))
			return true
		end

		--If a contraption spawner was clicked then update it with the current settings
		if(trace.Entity:GetClass()=="gmod_contr_spawner") then
			local delay = tonumber(ply:GetInfo("advdupe2_contr_spawner_delay"))
			local undo_delay = tonumber(ply:GetInfo("advdupe2_contr_spawner_undo_delay"))
			local min
			local max
			if(not delay) then
				delay = tonumber(GetConVarString("AdvDupe2_MinContraptionSpawnDelay")) or 0.2
			else
				if(not game.SinglePlayer()) then
					min = tonumber(GetConVarString("AdvDupe2_MinContraptionSpawnDelay")) or 0.2
					if (delay < min) then
						delay = min
					end
				elseif(delay<0) then
					delay = 0
				end
			end

			if(not undo_delay) then
				undo_delay = tonumber(GetConVarString("AdvDupe2_MinContraptionUndoDelay"))
			else
				if(not game.SinglePlayer()) then
					min = tonumber(GetConVarString("AdvDupe2_MinContraptionUndoDelay")) or 0.1
					max = tonumber(GetConVarString("AdvDupe2_MaxContraptionUndoDelay")) or 60
					if(undo_delay < min) then
						undo_delay = min
					elseif(undo_delay > max) then
						undo_delay = max
					end
				elseif(undo_delay < 0) then
					undo_delay = 0
				end
			end

			trace.Entity:GetTable():SetOptions(
				ply, delay, undo_delay,
				tonumber(ply:GetInfo("advdupe2_contr_spawner_key")),
				tonumber(ply:GetInfo("advdupe2_contr_spawner_undo_key")),
				tonumber(ply:GetInfo("advdupe2_contr_spawner_disgrav")) or 0,
				tonumber(ply:GetInfo("advdupe2_contr_spawner_disdrag")) or 0,
				tonumber(ply:GetInfo("advdupe2_contr_spawner_addvel")) or 1 )

			return true
		end

		--Create a contraption spawner
		if dupe and dupe.Entities then
			local headent = dupe.Entities[dupe.HeadEnt.Index]
			local Pos, Ang

			if(headent) then
				if(tobool(ply:GetInfo("advdupe2_original_origin"))) then
					Pos = dupe.HeadEnt.Pos + headent.PhysicsObjects[0].Pos
					Ang = headent.PhysicsObjects[0].Angle
				else
					local EntAngle = headent.PhysicsObjects[0].Angle
					if(tobool(ply:GetInfo("advdupe2_offset_world"))) then EntAngle = Angle(0,0,0) end
					trace.HitPos.Z = trace.HitPos.Z + GetDupeElevation(ply)
					Pos, Ang = LocalToWorld(headent.PhysicsObjects[0].Pos, EntAngle, trace.HitPos, GetDupeAngleOffset(ply))
				end
			else
				AdvDupe2.Notify(ply, "Invalid head entity to spawn contraption spawner.")
				return false
			end

			if(headent.Class=="gmod_contr_spawner") then
				AdvDupe2.Notify(ply, "Cannot make a contraption spawner from a contraption spawner.")
				return false
			end


			local spawner = MakeContraptionSpawner(
				ply, Pos, Ang, dupe.HeadEnt.Index,
				table.Copy(dupe.Entities),
				table.Copy(dupe.Constraints),
				tonumber(ply:GetInfo("advdupe2_contr_spawner_delay")),
				tonumber(ply:GetInfo("advdupe2_contr_spawner_undo_delay")), headent.Model,
				tonumber(ply:GetInfo("advdupe2_contr_spawner_key")),
				tonumber(ply:GetInfo("advdupe2_contr_spawner_undo_key")),
				tonumber(ply:GetInfo("advdupe2_contr_spawner_disgrav")) or 0,
				tonumber(ply:GetInfo("advdupe2_contr_spawner_disdrag")) or 0,
				tonumber(ply:GetInfo("advdupe2_contr_spawner_addvel")) or 1,
				tonumber(ply:GetInfo("advdupe2_contr_spawner_hideprops")) or 0)

			ply:AddCleanup( "AdvDupe2", spawner )
			undo.Create("gmod_contr_spawner")
				undo.AddEntity( spawner )
				undo.SetPlayer( ply )
			undo.Finish()

			return true
		end
	end

	--Called to clean up the tool when pasting is finished or undo during pasting
	function AdvDupe2.FinishPasting(Player, Paste)
		Player.AdvDupe2.Pasting=false
		AdvDupe2.RemoveProgressBar(Player)
		if(Paste) then AdvDupe2.Notify(Player,"Finished Pasting!") end
	end

	--function for creating a contraption spawner
	function MakeContraptionSpawner( ply, Pos, Ang, HeadEnt, EntityTable, ConstraintTable, delay, undo_delay, model, key, undo_key, disgrav, disdrag, addvel, hideprops)

		if not ply:CheckLimit("gmod_contr_spawners") then return nil end

		if(not game.SinglePlayer()) then
			if(table.Count(EntityTable)>tonumber(GetConVarString("AdvDupe2_MaxContraptionEntities"))) then
				AdvDupe2.Notify(ply,"Contraption Spawner exceeds the maximum amount of "..GetConVarString("AdvDupe2_MaxContraptionEntities").." entities for a spawner!",NOTIFY_ERROR)
				return false
			end
			if(#ConstraintTable>tonumber(GetConVarString("AdvDupe2_MaxContraptionConstraints"))) then
				AdvDupe2.Notify(ply,"Contraption Spawner exceeds the maximum amount of "..GetConVarString("AdvDupe2_MaxContraptionConstraints").." constraints for a spawner!",NOTIFY_ERROR)
				return false
			end
		end

		local spawner = ents.Create("gmod_contr_spawner")
		if not IsValid(spawner) then return end

		spawner:SetPos(Pos)
		spawner:SetAngles(Ang)
		spawner:SetModel(model)
		spawner:SetRenderMode(RENDERMODE_TRANSALPHA)
		spawner:SetCreator(ply)
		spawner:Spawn()

		duplicator.ApplyEntityModifiers(ply, spawner)

		if IsValid(spawner:GetPhysicsObject()) then
			spawner:GetPhysicsObject():EnableMotion(false)
		end

		local min
		local max
		if(not delay) then
			delay = tonumber(GetConVarString("AdvDupe2_MinContraptionSpawnDelay")) or 0.2
		else
			if(not game.SinglePlayer()) then
				min = tonumber(GetConVarString("AdvDupe2_MinContraptionSpawnDelay")) or 0.2
				if (delay < min) then
					delay = min
				end
			elseif(delay<0) then
				delay = 0
			end
		end

		if(not undo_delay) then
			undo_delay = tonumber(GetConVarString("AdvDupe2_MinContraptionUndoDelay"))
		else
			if(not game.SinglePlayer()) then
				min = tonumber(GetConVarString("AdvDupe2_MinContraptionUndoDelay")) or 0.1
				max = tonumber(GetConVarString("AdvDupe2_MaxContraptionUndoDelay")) or 60
				if(undo_delay < min) then
					undo_delay = min
				elseif(undo_delay > max) then
					undo_delay = max
				end
			elseif(undo_delay < 0) then
				undo_delay = 0
			end
		end

		-- Set options
		spawner:SetPlayer(ply)
		spawner:GetTable():SetOptions(ply, delay, undo_delay, key, undo_key, disgrav, disdrag, addvel, hideprops)

		local tbl = {
			ply        = ply,
			delay      = delay,
			undo_delay = undo_delay,
			disgrav    = disgrav,
			disdrag    = disdrag,
			addvel     = addvel,
			hideprops  = hideprops
		}
		table.Merge(spawner:GetTable(), tbl)
		spawner:SetDupeInfo(HeadEnt, EntityTable, ConstraintTable)
		spawner:AddGhosts(ply)

		ply:AddCount("gmod_contr_spawners", spawner)
		ply:AddCleanup("gmod_contr_spawner", spawner)
		return spawner
	end

	duplicator.RegisterEntityClass("gmod_contr_spawner", MakeContraptionSpawner,
		"Pos", "Ang", "HeadEnt", "EntityTable", "ConstraintTable", "delay",
		"undo_delay", "model", "key", "undo_key", "disgrav", "disdrag", "addvel", "hideprops")

	function AdvDupe2.InitProgressBar(ply,label)
		net.Start("AdvDupe2_InitProgressBar")
			net.WriteString(label)
		net.Send(ply)
	end

	function AdvDupe2.DrawSelectBox(ply)
		net.Start("AdvDupe2_DrawSelectBox")
		net.Send(ply)
	end

	function AdvDupe2.RemoveSelectBox(ply)
		net.Start("AdvDupe2_RemoveSelectBox")
		net.Send(ply)
	end

	function AdvDupe2.UpdateProgressBar(ply,percent)
		net.Start("AdvDupe2_UpdateProgressBar")
			net.WriteFloat(percent)
		net.Send(ply)
	end

	function AdvDupe2.RemoveProgressBar(ply)
		net.Start("AdvDupe2_RemoveProgressBar")
		net.Send(ply)
	end

	--Reset the offsets of height, pitch, yaw, and roll back to default
	function AdvDupe2.ResetOffsets(ply, keep)

		if(not keep) then
			ply.AdvDupe2.Name = nil
		end
		net.Start("AdvDupe2_ResetOffsets")
		net.Send(ply)
	end

	net.Receive("AdvDupe2_CanAutoSave", function(len, ply, len2)

		local desc = net.ReadString()
		local ent = net.ReadInt(16)
		local dupe = ply.AdvDupe2

		if(ent~=0) then
			dupe.AutoSaveEnt = ent
			if(ply:GetInfo("advdupe2_auto_save_contraption")=="1") then
				dupe.AutoSaveEnt = ents.GetByIndex( dupe.AutoSaveEnt )
			end
		else
			if(ply:GetInfo("advdupe2_auto_save_contraption")=="1") then
				AdvDupe2.Notify(ply, "No entity selected to auto save contraption.", NOTIFY_ERROR)
				return
			end
			dupe.AutoSaveEnt = nil
		end

		dupe.AutoSavePos = dupe.TempAutoSavePos
		dupe.AutoSaveSize = dupe.TempAutoSaveSize
		dupe.AutoSaveOutSide = dupe.TempAutoSaveOutSide
		dupe.AutoSaveContr = ply:GetInfo("advdupe2_auto_save_contraption")=="1"
		dupe.AutoSaveDesc = desc

		local time = math.Clamp(tonumber(ply:GetInfo("advdupe2_auto_save_time")) or 2, 2, 30)
		if(game.SinglePlayer()) then
			dupe.AutoSavePath = net.ReadString()
		end

		AdvDupe2.Notify(ply, "Your area will be auto saved every "..(time*60).." seconds.")
		local name = "AdvDupe2_AutoSave_"..ply:UniqueID()
		if(timer.Exists(name)) then
			timer.Adjust(name, time*60, 0)
			return
		end
		timer.Create(name, time*60, 0, function()
			if(not IsValid(ply)) then
				timer.Remove(name)
				return
			end

			local dupe = ply.AdvDupe2
			if(dupe.Downloading) then
				AdvDupe2.Notify(ply, "Skipping auto save, tool is busy.", NOTIFY_ERROR)
				return
			end

			local Tab = {Entities={}, Constraints={}, HeadEnt={}}

			if(dupe.AutoSaveContr) then
				if(not IsValid(dupe.AutoSaveEnt)) then
					timer.Remove(name)
					AdvDupe2.Notify(ply, "Head entity for auto save no longer valid; stopping auto save.", NOTIFY_ERROR)
					return
				end

				Tab.HeadEnt.Index = dupe.AutoSaveEnt:EntIndex()
				Tab.HeadEnt.Pos = dupe.AutoSaveEnt:GetPos()

				local WorldTrace = util.TraceLine({
					mask   = MASK_NPCWORLDSTATIC,
					start  = Tab.HeadEnt.Pos + Vector(0,0,1),
					endpos = Tab.HeadEnt.Pos - Vector(0,0,50000)
				})

				Tab.HeadEnt.Z = WorldTrace.Hit and math.abs(Tab.HeadEnt.Pos.Z - WorldTrace.HitPos.Z) or 0
				AdvDupe2.duplicator.Copy( ply, dupe.AutoSaveEnt, Tab.Entities, Tab.Constraints, Tab.HeadEnt.Pos )
			else
				local i = dupe.AutoSaveSize
				local Pos = dupe.AutoSavePos
				local T = Vector( i, i, i); T:Add(Pos)
				local B = Vector(-i,-i,-i); B:Add(Pos)

				local Entities = FindInBox(B,T, ply)
				local _, HeadEnt = next(Entities)
				if not HeadEnt then
					AdvDupe2.Notify(ply, "Area Auto Save copied 0 entities; be sure to turn it off.", NOTIFY_ERROR)
					return
				end

				if(dupe.AutoSaveEnt and Entities[dupe.AutoSaveEnt]) then
					Tab.HeadEnt.Index = dupe.AutoSaveEnt
				else
					Tab.HeadEnt.Index = HeadEnt:EntIndex()
				end
				Tab.HeadEnt.Pos = HeadEnt:GetPos()

				local WorldTrace = util.TraceLine({
					mask   = MASK_NPCWORLDSTATIC,
					start  = Tab.HeadEnt.Pos + Vector(0,0,1),
					endpos = Tab.HeadEnt.Pos - Vector(0,0,50000)
				})

				Tab.HeadEnt.Z = WorldTrace.Hit and math.abs(Tab.HeadEnt.Pos.Z - WorldTrace.HitPos.Z) or 0
				Tab.Entities, Tab.Constraints = AdvDupe2.duplicator.AreaCopy(ply, Entities, Tab.HeadEnt.Pos, dupe.AutoSaveOutSide)
			end
			Tab.Constraints = GetSortedConstraints(ply, Tab.Constraints)
			Tab.Description = dupe.AutoSaveDesc

			AdvDupe2.Encode( Tab, AdvDupe2.GenerateDupeStamp(ply), function(data)
				AdvDupe2.SendToClient(ply, data, 1)
			end)
			dupe.FileMod = CurTime()+tonumber(GetConVarString("AdvDupe2_FileModificationDelay"))
		end)
		timer.Start(name)
	end)

	concommand.Add("AdvDupe2_SetStage", function(ply, cmd, args)
		ply:GetTool("advdupe2"):SetStage(1)
	end)

	concommand.Add("AdvDupe2_RemoveAutoSave", function(ply, cmd, args)
		timer.Remove("AdvDupe2_AutoSave_"..ply:UniqueID())
	end)

	concommand.Add("AdvDupe2_SaveMap", function(ply, cmd, args)
		if(not ply:IsAdmin()) then
			AdvDupe2.Notify(ply, "You do not have permission to this function.", NOTIFY_ERROR)
			return
		end

		local Entities = {}
		for _, v in ents.Iterator() do
			if not v:CreatedByMap() and AdvDupe2.duplicator.IsCopyable(v) then
				Entities[v:EntIndex()] = v
			end
		end

		local _, HeadEnt = next(Entities)
		if not HeadEnt then return end

		local Tab = {Entities={}, Constraints={}, HeadEnt={}, Description=""}
		Tab.HeadEnt.Index = HeadEnt:EntIndex()
		Tab.HeadEnt.Pos = HeadEnt:GetPos()

		local WorldTrace = util.TraceLine({
			mask   = MASK_NPCWORLDSTATIC,
			start  = Tab.HeadEnt.Pos + Vector(0,0,1),
			endpos = Tab.HeadEnt.Pos - Vector(0,0,50000)
		})

		Tab.HeadEnt.Z = WorldTrace.Hit and math.abs(Tab.HeadEnt.Pos.Z - WorldTrace.HitPos.Z) or 0
		Tab.Entities, Tab.Constraints = AdvDupe2.duplicator.AreaCopy(ply, Entities, Tab.HeadEnt.Pos, true)
		Tab.Constraints = GetSortedConstraints(ply, Tab.Constraints)

		Tab.Map = true
		AdvDupe2.Encode( Tab, AdvDupe2.GenerateDupeStamp(ply), function(data)
			if #data > AdvDupe2.MaxDupeSize then
				AdvDupe2.Notify(ply, "Copied duplicator filesize is too big!",NOTIFY_ERROR)
				return 
			end
			if(not file.IsDir("advdupe2_maps", "DATA")) then
				file.CreateDir("advdupe2_maps")
			end
			file.Write("advdupe2_maps/"..args[1]..".txt", data)
			AdvDupe2.Notify(ply, "Map save, saved successfully.")
		end)
	end)
end

if(CLIENT) then

	function TOOL:LeftClick(trace)
		if(trace and AdvDupe2.HeadGhost) then
			return true
		end
		return false
	end

	function TOOL:RightClick(trace)
		if( self:GetOwner():KeyDown(IN_SPEED) and not self:GetOwner():KeyDown(IN_WALK) ) then
			return false
		end
		return true
	end

	--Removes progress bar and removes ghosts when tool is put away
	function TOOL:ReleaseGhostEntity()
		AdvDupe2.RemoveGhosts()
		AdvDupe2.RemoveSelectBox()
		if(AdvDupe2.Rotation) then
			hook.Remove("PlayerBindPress", "AdvDupe2_BindPress")
			hook.Remove("CreateMove", "AdvDupe2_MouseControl")
		end
		return
	end

	function TOOL:Reload( trace )
		if(trace and (AdvDupe2.HeadGhost or self:GetStage() == 1)) then
			return true
		end
		return false
	end

	--Take control of the mouse wheel bind so the player can modify the height of the dupe
	local function MouseWheelScrolled(ply, bind, pressed)

		if(bind == "invprev") then
			if(ply:GetTool("advdupe2"):GetStage() == 1) then
				local size = math.min(tonumber(ply:GetInfo("advdupe2_area_copy_size")) + 25, 30720)
				RunConsoleCommand("advdupe2_area_copy_size",size)
			else
				local Z = tonumber(ply:GetInfo("advdupe2_offset_z")) + 5
				RunConsoleCommand("advdupe2_offset_z",Z)
			end
			return true
		elseif(bind == "invnext") then
			if(ply:GetTool("advdupe2"):GetStage() == 1) then
				local size = math.max(tonumber(ply:GetInfo("advdupe2_area_copy_size")) - 25, 25)
				RunConsoleCommand("advdupe2_area_copy_size",size)
			else
				local Z = tonumber(ply:GetInfo("advdupe2_offset_z")) - 5
				RunConsoleCommand("advdupe2_offset_z",Z)
			end
			return true
		end

		GAMEMODE:PlayerBindPress(ply, bind, pressed)
	end

	local YawTo = 0
	local BsAng = Angle()

	local function GetRotationSign(ply)
		local VY = tonumber(ply:GetInfo("advdupe2_offset_yaw")) or 0
		BsAng:Zero(); BsAng:RotateAroundAxis(BsAng:Up(), VY)
		local PR = ply:GetRight()
		local DP = BsAng:Right():Dot(PR)
		local DR = BsAng:Forward():Dot(PR)
		if(math.abs(DR) > math.abs(DP)) then -- Roll priority
			if(DR >= 0) then return -1, 1 else return  1, -1 end
		else -- Pitch axis takes priority. Normal X-Y map
			if(DP >= 0) then return  1, 1 else return -1, -1 end
		end
	end

	local function MouseControl( cmd )
		local ply = LocalPlayer()
		local X =  cmd:GetMouseX() / 20
		local Y = -cmd:GetMouseY() / 20
		local ru = ply:KeyDown(IN_SPEED)
		local mm = input.IsMouseDown(MOUSE_MIDDLE)

		if(mm) then
			if(ru) then
				YawTo = 0 -- Reset total integrated yaw
				RunConsoleCommand("advdupe2_offset_pitch", 0)
				RunConsoleCommand("advdupe2_offset_yaw"  , 0)
				RunConsoleCommand("advdupe2_offset_roll" , 0)
			else
				if(Y ~= 0) then
					local VR = tonumber(ply:GetInfo("advdupe2_offset_roll"))  or 0
					local VP = tonumber(ply:GetInfo("advdupe2_offset_pitch")) or 0
					local SP, SR, P, R = GetRotationSign(ply)
					if(SP ~= SR) then
						P = math.NormalizeAngle(VP + X * SR)
						R = math.NormalizeAngle(VR + Y * SP)
					else
						P = math.NormalizeAngle(VP + Y * SP)
						R = math.NormalizeAngle(VR + X * SR)
					end
					RunConsoleCommand("advdupe2_offset_pitch", P)
					RunConsoleCommand("advdupe2_offset_roll" , R)
				end
			end
		else
			if(X ~= 0) then
				VY = tonumber(ply:GetInfo("advdupe2_offset_yaw")) or 0
				if(ru) then
					YawTo = YawTo + X -- Integrate the mouse on the X value from the mouse
					RunConsoleCommand("advdupe2_offset_yaw", math.SnapTo(math.NormalizeAngle(YawTo), 45))
				else
					YawTo = VY + X -- Update the last yaw with the current value from the mouse
					RunConsoleCommand("advdupe2_offset_yaw", math.NormalizeAngle(YawTo))
				end
			end
		end
	end

	--Checks binds to modify dupes position and angles
	function TOOL:Think()

		if AdvDupe2.HeadGhost then
			AdvDupe2.UpdateGhosts()
		end

		if(LocalPlayer():KeyDown(IN_USE)) then
			if(not AdvDupe2.Rotation) then
				hook.Add("PlayerBindPress", "AdvDupe2_BindPress", MouseWheelScrolled)
				hook.Add("CreateMove", "AdvDupe2_MouseControl", MouseControl)
				AdvDupe2.Rotation = true
			end
		else
			if(AdvDupe2.Rotation) then
				AdvDupe2.Rotation = false
				hook.Remove("PlayerBindPress", "AdvDupe2_BindPress")
				hook.Remove("CreateMove", "AdvDupe2_MouseControl")
			end
		end
	end

	--Hinder the player from looking to modify offsets with the mouse
	function TOOL:FreezeMovement()
		return AdvDupe2.Rotation
	end

	language.Add( "Tool.advdupe2.name",	"Advanced Duplicator 2" )
	language.Add( "Tool.advdupe2.desc",	"Duplicate things." )
	language.Add( "Tool.advdupe2.0",	"Primary: Paste, Secondary: Copy, Secondary+World: Select/Deselect All, Secondary+Shift: Area copy." )
	language.Add( "Tool.advdupe2.1",	"Primary: Paste, Secondary: Copy an area, Reload: Autosave an area, Secondary+Shift: Cancel." )
	language.Add( "Undone_AdvDupe2",	"Undone AdvDupe2 paste" )
	language.Add( "Cleanup_AdvDupe2",	"AdvDupe2 Duplications" )
	language.Add( "Cleaned_AdvDupe2",	"Cleaned up all AdvDupe2 Duplications" )
	language.Add( "SBoxLimit_AdvDupe2",	"You've reached the AdvDupe2 Duplicator limit!" )

	CreateClientConVar("advdupe2_offset_world", 0, false, true)
	CreateClientConVar("advdupe2_offset_z", 0, false, true)
	CreateClientConVar("advdupe2_offset_pitch", 0, false, true)
	CreateClientConVar("advdupe2_offset_yaw", 0, false, true)
	CreateClientConVar("advdupe2_offset_roll", 0, false, true)
	CreateClientConVar("advdupe2_original_origin", 0, false, true)
	CreateClientConVar("advdupe2_paste_constraints", 1, false, true)
	CreateClientConVar("advdupe2_sort_constraints", 1, true, true)
	CreateClientConVar("advdupe2_paste_parents", 1, false, true)
	CreateClientConVar("advdupe2_paste_unfreeze", 0, false, true)
	CreateClientConVar("advdupe2_preserve_freeze", 0, false, true)
	CreateClientConVar("advdupe2_copy_outside", 0, false, true)
	CreateClientConVar("advdupe2_copy_only_mine", 1, false, true)
	CreateClientConVar("advdupe2_limit_ghost", 100, false, true)
	CreateClientConVar("advdupe2_area_copy_size", 300, false, true)
	CreateClientConVar("advdupe2_auto_save_contraption", 0, false, true)
	CreateClientConVar("advdupe2_auto_save_overwrite", 1, false, true)
	CreateClientConVar("advdupe2_auto_save_time", 2, false, true)

	--Contraption Spawner
	CreateClientConVar("advdupe2_contr_spawner_key", -1, false, true)
	CreateClientConVar("advdupe2_contr_spawner_undo_key", -1, false, true)
	CreateClientConVar("advdupe2_contr_spawner_delay", 0, false, true)
	CreateClientConVar("advdupe2_contr_spawner_undo_delay", 10, false, true)
	CreateClientConVar("advdupe2_contr_spawner_disgrav", 0, false, true)
	CreateClientConVar("advdupe2_contr_spawner_disdrag", 0, false, true)
	CreateClientConVar("advdupe2_contr_spawner_addvel", 1, false, true)
	CreateClientConVar("advdupe2_contr_spawner_hideprops", 0, false, true)

	--Experimental
	CreateClientConVar("advdupe2_paste_disparents", 0, false, true)
	CreateClientConVar("advdupe2_paste_protectoveride", 1, false, true)
	CreateClientConVar("advdupe2_debug_openfile", 1, false, true)

	local function BuildCPanel(CPanel)
		CPanel:ClearControls()

		local FileBrowser = vgui.Create("advdupe2_browser")
		CPanel:AddItem(FileBrowser)
		FileBrowser:SetSize(CPanel:GetWide(), 405)
		AdvDupe2.FileBrowser = FileBrowser

		local Check = vgui.Create("DCheckBoxLabel")

		Check:SetText( "Paste at original position" )
		Check:SetDark(true)
		Check:SetConVar( "advdupe2_original_origin" )
		Check:SetValue( 0 )
		Check:SetToolTip("Paste at the position originally copied")
		CPanel:AddItem(Check)

		Check = vgui.Create("DCheckBoxLabel")
		Check:SetText( "Paste with constraints" )
		Check:SetDark(true)
		Check:SetConVar( "advdupe2_paste_constraints" )
		Check:SetValue( 1 )
		Check:SetToolTip("Paste with or without constraints")
		CPanel:AddItem(Check)

		Check = vgui.Create("DCheckBoxLabel")
		Check:SetText( "Paste with parenting" )
		Check:SetDark(true)
		Check:SetConVar( "advdupe2_paste_parents" )
		Check:SetValue( 1 )
		Check:SetToolTip("Paste with or without parenting")
		CPanel:AddItem(Check)

		local Check_1 = vgui.Create("DCheckBoxLabel")
		local Check_2 = vgui.Create("DCheckBoxLabel")

		Check_1:SetText( "Unfreeze all after paste" )
		Check_1:SetDark(true)
		Check_1:SetConVar( "advdupe2_paste_unfreeze" )
		Check_1:SetValue( 0 )
		Check_1.OnChange = function()
			if(Check_1:GetChecked() and Check_2:GetChecked()) then
				Check_2:SetValue(0)
			end
		end
		Check_1:SetToolTip("Unfreeze all props after pasting")
		CPanel:AddItem(Check_1)

		Check_2:SetText( "Preserve frozen state after paste" )
		Check_2:SetDark(true)
		Check_2:SetConVar( "advdupe2_preserve_freeze" )
		Check_2:SetValue( 0 )
		Check_2.OnChange = function()
			if(Check_2:GetChecked() and Check_1:GetChecked()) then
				Check_1:SetValue(0)
			end
		end
		Check_2:SetToolTip("Makes props have the same frozen state as when they were copied")
		CPanel:AddItem(Check_2)

		Check = vgui.Create("DCheckBoxLabel")
		Check:SetText( "Area copy constrained props outside of box" )
		Check:SetDark(true)
		Check:SetConVar( "advdupe2_copy_outside" )
		Check:SetValue( 0 )
		Check:SetToolTip("Copy entities outside of the area copy that are constrained to entities insde")
		CPanel:AddItem(Check)

		Check = vgui.Create("DCheckBoxLabel")
		Check:SetText( "World/Area copy only your own props" )
		Check:SetDark(true)
		Check:SetConVar( "advdupe2_copy_only_mine" )
		Check:SetValue( 1 )
		Check:SetToolTip("Copy entities outside of the area copy that are constrained to entities insde")
		CPanel:AddItem(Check)

		Check = vgui.Create("DCheckBoxLabel")
		Check:SetText( "Sort constraints by their connections" )
		Check:SetDark(true)
		Check:SetConVar( "advdupe2_sort_constraints" )
		Check:SetValue( GetConVarNumber("advdupe2_sort_constraints") )
		Check:SetToolTip( "Orders constraints so that they build a rigid constraint system." )
		CPanel:AddItem(Check)

		local NumSlider = vgui.Create( "DNumSlider" )
		NumSlider:SetText( "Ghost Percentage:" )
		NumSlider.Label:SetDark(true)
		NumSlider:SetMin( 0 )
		NumSlider:SetMax( 100 )
		NumSlider:SetDecimals( 0 )
		NumSlider:SetConVar( "advdupe2_limit_ghost" )
		NumSlider:SetToolTip("Change the percent of ghosts to spawn")
		--If these funcs are not here, problems occur for each
		local func = NumSlider.Slider.OnMouseReleased
		NumSlider.Slider.OnMouseReleased = function(self, mcode) func(self, mcode) AdvDupe2.StartGhosting() end
		local func2 = NumSlider.Slider.Knob.OnMouseReleased
		NumSlider.Slider.Knob.OnMouseReleased = function(self, mcode) func2(self, mcode) AdvDupe2.StartGhosting() end
		local func3 = NumSlider.Wang.Panel.OnLoseFocus
		NumSlider.Wang.Panel.OnLoseFocus = function(txtBox) func3(txtBox) AdvDupe2.StartGhosting() end
		CPanel:AddItem(NumSlider)

		NumSlider = vgui.Create( "DNumSlider" )
		NumSlider:SetText( "Area Copy Size:" )
		NumSlider.Label:SetDark(true)
		NumSlider:SetMin( 0 )
		NumSlider:SetMax( 30720 )
		NumSlider:SetDecimals( 0 )
		NumSlider:SetConVar( "advdupe2_area_copy_size" )
		NumSlider:SetToolTip("Change the size of the area copy")
		CPanel:AddItem(NumSlider)

		local Category1 = vgui.Create("DCollapsibleCategory")
		CPanel:AddItem(Category1)
		Category1:SetLabel("Offsets")
		Category1:SetExpanded(0)

		local parent = FileBrowser:GetParent():GetParent():GetParent():GetParent()
		--[[Offsets]]--
		local CategoryContent1 = vgui.Create( "DPanelList" )
		CategoryContent1:SetAutoSize( true )
		CategoryContent1:SetDrawBackground( false )
		CategoryContent1:SetSpacing( 1 )
		CategoryContent1:SetPadding( 2 )
		CategoryContent1.OnMouseWheeled = function(self, dlta) parent:OnMouseWheeled(dlta) end		--Fix the damned mouse not scrolling when it's over the catagories

		Category1:SetContents( CategoryContent1 )

		NumSlider = vgui.Create( "DNumSlider" )
		NumSlider:SetText( "Height Offset" )
		NumSlider.Label:SetDark(true)
		NumSlider:SetMin( -2500 )
		NumSlider:SetMax( 2500 )
		NumSlider:SetDefaultValue( 0 )
		NumSlider:SetDecimals( 3 )
		NumSlider:SetConVar("advdupe2_offset_z")
		NumSlider:SetToolTip("Changes the dupe Z offset")
		CategoryContent1:AddItem(NumSlider)

		Check = vgui.Create("DCheckBoxLabel")
		Check:SetText( "Use World Angles" )
		Check:SetDark(true)
		Check:SetConVar( "advdupe2_offset_world" )
		Check:SetValue( 0 )
		Check:SetToolTip("Use world angles for the offset instead of the main entity")
		CategoryContent1:AddItem(Check)

		NumSlider = vgui.Create( "DNumSlider" )
		NumSlider:SetText( "Pitch Offset" )
		NumSlider.Label:SetDark(true)
		NumSlider:SetMin( -180 )
		NumSlider:SetMax( 180 )
		NumSlider:SetDefaultValue( 0 )
		NumSlider:SetDecimals( 3 )
		NumSlider:SetToolTip("Changes the dupe pitch offset")
		NumSlider:SetConVar("advdupe2_offset_pitch")
		CategoryContent1:AddItem(NumSlider)

		NumSlider = vgui.Create( "DNumSlider" )
		NumSlider:SetText( "Yaw Offset" )
		NumSlider.Label:SetDark(true)
		NumSlider:SetMin( -180 )
		NumSlider:SetMax( 180 )
		NumSlider:SetDefaultValue( 0 )
		NumSlider:SetDecimals( 3 )
		NumSlider:SetToolTip("Changes the dupe yaw offset")
		NumSlider:SetConVar("advdupe2_offset_yaw")
		CategoryContent1:AddItem(NumSlider)

		NumSlider = vgui.Create( "DNumSlider" )
		NumSlider:SetText( "Roll Offset" )
		NumSlider.Label:SetDark(true)
		NumSlider:SetMin( -180 )
		NumSlider:SetMax( 180 )
		NumSlider:SetDefaultValue( 0 )
		NumSlider:SetDecimals( 3 )
		NumSlider:SetToolTip("Changes the dupe roll offset")
		NumSlider:SetConVar("advdupe2_offset_roll")
		CategoryContent1:AddItem(NumSlider)

		local Btn = vgui.Create("DButton")
		Btn:SetText("Reset")
		Btn.DoClick = function()
			RunConsoleCommand("advdupe2_offset_z", 0)
			RunConsoleCommand("advdupe2_offset_pitch", 0)
			RunConsoleCommand("advdupe2_offset_yaw", 0)
			RunConsoleCommand("advdupe2_offset_roll", 0)
		end
		CategoryContent1:AddItem(Btn)


		--[[Dupe Information]]--
		local Category2 = vgui.Create("DCollapsibleCategory")
		CPanel:AddItem(Category2)
		Category2:SetLabel("Dupe Information")
		Category2:SetExpanded(0)

		local CategoryContent2 = vgui.Create( "DPanelList" )
		CategoryContent2:SetAutoSize( true )
		CategoryContent2:SetDrawBackground( false )
		CategoryContent2:SetSpacing( 3 )
		CategoryContent2:SetPadding( 2 )
		Category2:SetContents( CategoryContent2 )
		CategoryContent2.OnMouseWheeled = function(self, dlta) parent:OnMouseWheeled(dlta) end

		AdvDupe2.Info = {}

		local lbl = vgui.Create( "DLabel" )
		lbl:SetText(AdvDupe2.InfoText.File or "File: ")
		lbl:SetDark(true)
		CategoryContent2:AddItem(lbl)
		AdvDupe2.Info.File = lbl

		lbl = vgui.Create( "DLabel" )
		lbl:SetText(AdvDupe2.InfoText.Creator or "Creator:")
		lbl:SetDark(true)
		CategoryContent2:AddItem(lbl)
		AdvDupe2.Info.Creator = lbl

		lbl = vgui.Create( "DLabel" )
		lbl:SetText(AdvDupe2.InfoText.Date or "Date:")
		lbl:SetDark(true)
		CategoryContent2:AddItem(lbl)
		AdvDupe2.Info.Date = lbl

		lbl = vgui.Create( "DLabel" )
		lbl:SetText(AdvDupe2.InfoText.Time or "Time:")
		lbl:SetDark(true)
		CategoryContent2:AddItem(lbl)
		AdvDupe2.Info.Time = lbl

		lbl = vgui.Create( "DLabel" )
		lbl:SetText(AdvDupe2.InfoText.Size or "Size:")
		lbl:SetDark(true)
		CategoryContent2:AddItem(lbl)
		AdvDupe2.Info.Size = lbl

		lbl = vgui.Create( "DLabel" )
		lbl:SetText(AdvDupe2.InfoText.Desc or "Desc:")
		lbl:SetDark(true)
		CategoryContent2:AddItem(lbl)
		AdvDupe2.Info.Desc = lbl

		lbl = vgui.Create( "DLabel" )
		lbl:SetText(AdvDupe2.InfoText.Entities or "Entities:")
		lbl:SetDark(true)
		CategoryContent2:AddItem(lbl)
		AdvDupe2.Info.Entities = lbl

		lbl = vgui.Create( "DLabel" )
		lbl:SetText(AdvDupe2.InfoText.Constraints or "Constraints:")
		lbl:SetDark(true)
		CategoryContent2:AddItem(lbl)
		AdvDupe2.Info.Constraints = lbl

	--[[Contraption Spawner]]--
		local Category3 = vgui.Create("DCollapsibleCategory")
		CPanel:AddItem(Category3)
		Category3:SetLabel("Contraption Spawner")
		Category3:SetExpanded(0)

		local CategoryContent3 = vgui.Create( "DPanelList" )
		CategoryContent3:SetAutoSize( true )
		CategoryContent3:SetDrawBackground( false )
		CategoryContent3:SetSpacing( 3 )
		CategoryContent3:SetPadding( 2 )
		Category3:SetContents( CategoryContent3 )
		CategoryContent3.OnMouseWheeled = function(self, dlta) parent:OnMouseWheeled(dlta) end

		local ctrl = vgui.Create( "CtrlNumPad" )
		ctrl:SetConVar1( "advdupe2_contr_spawner_key" )
		ctrl:SetConVar2( "advdupe2_contr_spawner_undo_key" )
		ctrl:SetLabel1( "Spawn Key")
		ctrl:SetLabel2( "Undo Key" )
		CategoryContent3:AddItem(ctrl)

		NumSlider = vgui.Create( "DNumSlider" )
		NumSlider:SetText( "Spawn Delay" )
		NumSlider.Label:SetDark(true)
		if(game.SinglePlayer()) then
			NumSlider:SetMin( 0 )
		else
			local min = tonumber(GetConVarString("AdvDupe2_MinContraptionSpawnDelay")) or 0.2
			if(tonumber(LocalPlayer():GetInfo("advdupe2_contr_spawner_delay"))<min) then
				RunConsoleCommand("advdupe2_contr_spawner_delay", tostring(min))
			end
			NumSlider:SetMin( min )
		end
		NumSlider:SetMax(60)
		NumSlider:SetDecimals( 1 )
		NumSlider:SetConVar("advdupe2_contr_spawner_delay")
		CategoryContent3:AddItem(NumSlider)

		NumSlider = vgui.Create( "DNumSlider" )
		NumSlider:SetText( "Undo Delay" )
		NumSlider.Label:SetDark(true)
		if(game.SinglePlayer()) then
			NumSlider:SetMin( 0 )
			NumSlider:SetMax( 60 )
		else
			local min = tonumber(GetConVarString("AdvDupe2_MinContraptionUndoDelay")) or 10
			local max = tonumber(GetConVarString("AdvDupe2_MaxContraptionUndoDelay")) or 60
			if(tonumber(LocalPlayer():GetInfo("advdupe2_contr_spawner_undo_delay")) < min) then
				RunConsoleCommand("advdupe2_contr_spawner_undo_delay", tostring(min))
			elseif(tonumber(LocalPlayer():GetInfo("advdupe2_contr_spawner_undo_delay")) > max) then
				RunConsoleCommand("advdupe2_contr_spawner_undo_delay", tostring(max))
			end
			NumSlider:SetMin( min )
			NumSlider:SetMax( max )
		end
		NumSlider:SetDecimals( 1 )
		NumSlider:SetConVar("advdupe2_contr_spawner_undo_delay")
		CategoryContent3:AddItem(NumSlider)

		Check = vgui.Create("DCheckBoxLabel")
		Check:SetText( "Disable gravity for all spawned props" )
		Check:SetDark(true)
		Check:SetConVar( "advdupe2_contr_spawner_disgrav" )
		Check:SetValue( 0 )
		CategoryContent3:AddItem(Check)

		Check = vgui.Create("DCheckBoxLabel")
		Check:SetText( "Disable drag for all spawned props" )
		Check:SetDark(true)
		Check:SetConVar( "advdupe2_contr_spawner_disdrag" )
		Check:SetValue( 0 )
		CategoryContent3:AddItem(Check)

		Check = vgui.Create("DCheckBoxLabel")
		Check:SetText( "Add spawner's velocity to contraption" )
		Check:SetDark(true)
		Check:SetConVar( "advdupe2_contr_spawner_addvel" )
		Check:SetValue( 1 )
		CategoryContent3:AddItem(Check)

		Check = vgui.Create("DCheckBoxLabel")
		Check:SetText( "Disable drawing spawner props" )
		Check:SetDark(true)
		Check:SetConVar( "advdupe2_contr_spawner_hideprops" )
		Check:SetValue( 0 )
		CategoryContent3:AddItem(Check)

		--[[Area Auto Save]]--
		local Category4 = vgui.Create("DCollapsibleCategory")
		CPanel:AddItem(Category4)
		Category4:SetLabel("Area Auto Save")
		Category4:SetExpanded(0)

		local CategoryContent4 = vgui.Create( "DPanelList" )
		CategoryContent4:SetAutoSize( true )
		CategoryContent4:SetDrawBackground( false )
		CategoryContent4:SetSpacing( 3 )
		CategoryContent4:SetPadding( 2 )
		Category4:SetContents( CategoryContent4 )
		CategoryContent4.OnMouseWheeled = function(self, dlta) parent:OnMouseWheeled(dlta) end

		Check = vgui.Create("DCheckBoxLabel")
		Check:SetText( "Only copy contraption" )
		Check:SetDark(true)
		Check:SetConVar( "advdupe2_auto_save_contraption" )
		Check:SetValue( 0 )
		Check:SetToolTip("Only copy a contraption instead of an area")
		CategoryContent4:AddItem(Check)

		Check = vgui.Create("DCheckBoxLabel")
		Check:SetText( "Overwrite File" )
		Check:SetDark(true)
		Check:SetConVar( "advdupe2_auto_save_overwrite" )
		Check:SetValue( 1 )
		Check:SetToolTip("Overwrite the file instead of creating a new one everytime")
		CategoryContent4:AddItem(Check)

		NumSlider = vgui.Create( "DNumSlider" )
		NumSlider:SetText( "Minutes to Save:" )
		NumSlider.Label:SetDark(true)
		NumSlider:SetMin( 2 )
		NumSlider:SetMax( 30 )
		NumSlider:SetDecimals( 0 )
		NumSlider:SetConVar( "advdupe2_auto_save_time" )
		NumSlider:SetToolTip("Interval time to save in minutes")
		CategoryContent4:AddItem(NumSlider)

		local pnl = vgui.Create("Panel")
		pnl:SetWide(CPanel:GetWide()-40)
		pnl:SetTall(75)
		pnl:SetPos(0, 50)
		CategoryContent4:AddItem(pnl)

		local label = vgui.Create("DLabel", pnl)
		label:SetText("Directory: ")
		label:SizeToContents()
		label:SetDark(true)
		label:SetPos(5,7)

		AdvDupe2.AutoSavePath = ""
		local txtbox = vgui.Create("DTextEntry", pnl)
		txtbox:SetWide(pnl:GetWide()-100)
		txtbox:SetPos(60, 5)
		txtbox:SetUpdateOnType(true)
		txtbox.OnTextChanged = function(self)
			self:SetValue(AdvDupe2.AutoSavePath)
		end

		local btn = vgui.Create("DImageButton", pnl)
		local x, y = txtbox:GetPos()
		btn:SetPos(x + txtbox:GetWide() + 5, 7)
		btn:SetMaterial("icon16/folder_explore.png")
		btn:SizeToContents()
		btn:SetToolTip("Browse")
		btn.DoClick = function()
			local ScrollBar = parent.VBar
			ScrollBar:AnimateTo(0, 1, 0, 0.2)

			FileBrowser.Submit:SetMaterial("icon16/disk.png")
			FileBrowser.Submit:SetTooltip("Directory for Area Auto Save")
			if(FileBrowser.FileName:GetValue()=="Folder_Name...") then
				FileBrowser.FileName:SetValue("File_Name...")
			end
			FileBrowser.Desc:SetVisible(true)
			FileBrowser.Info:SetVisible(false)
			FileBrowser.FileName:SetVisible(true)
			FileBrowser.FileName:SelectAllOnFocus(true)
			FileBrowser.FileName:OnMousePressed()
			FileBrowser.FileName:RequestFocus()
			FileBrowser.Expanding=true
			FileBrowser:Slide(true)
			FileBrowser.Submit.DoClick = function()
				local name = FileBrowser.FileName:GetValue()
				if(name=="" or name=="File_Name...") then
					AdvDupe2.Notify("Name field is blank.", NOTIFY_ERROR)
					FileBrowser.FileName:SelectAllOnFocus(true)
					FileBrowser.FileName:OnGetFocus()
					FileBrowser.FileName:RequestFocus()
					return
				end
				local desc = FileBrowser.Desc:GetValue()
				if(desc=="Description...") then desc="" end

				if(not IsValid(FileBrowser.Browser.pnlCanvas.m_pSelectedItem) or FileBrowser.Browser.pnlCanvas.m_pSelectedItem.Derma.ClassName~="advdupe2_browser_folder") then
					AdvDupe2.Notify("Folder to save Area Auto Save not selected.", NOTIFY_ERROR)
					return
				end

				FileBrowser.AutoSaveNode = FileBrowser.Browser.pnlCanvas.m_pSelectedItem
				txtbox:SetValue(FileBrowser:GetFullPath(FileBrowser.Browser.pnlCanvas.m_pSelectedItem)..name)
				AdvDupe2.AutoSavePath = txtbox:GetValue()
				txtbox:SetToolTip(txtbox:GetValue())
				AdvDupe2.AutoSaveDesc = desc

				FileBrowser:Slide(false)
				ScrollBar:AnimateTo(ScrollBar.CanvasSize, 1, 0, 0.2)

				RunConsoleCommand("AdvDupe2_SetStage")
				hook.Add("HUDPaint", "AdvDupe2_DrawSelectionBox", AdvDupe2.DrawSelectionBox)
			end
			FileBrowser.FileName.OnEnter = function()
				FileBrowser.FileName:KillFocus()
				FileBrowser.Desc:SelectAllOnFocus(true)
				FileBrowser.Desc.OnMousePressed()
				FileBrowser.Desc:RequestFocus()
			end
			FileBrowser.Desc.OnEnter = FileBrowser.Submit.DoClick
		end

		btn = vgui.Create("DButton", pnl)
		btn:SetSize(50, 35)
		btn:SetPos(pnl:GetWide()/4-10, 30)
		btn:SetText("Show")
		btn.DoClick = function()
			if(AdvDupe2.AutoSavePos) then
				RunConsoleCommand("advdupe2_area_copy_size", AdvDupe2.AutoSaveSize)
				LocalPlayer():SetEyeAngles( (AdvDupe2.AutoSavePos - LocalPlayer():GetShootPos()):Angle() )
				RunConsoleCommand("AdvDupe2_SetStage")
				hook.Add("HUDPaint", "AdvDupe2_DrawSelectionBox", AdvDupe2.DrawSelectionBox)
			end
		end

		btn = vgui.Create("DButton", pnl)
		btn:SetSize(50, 35)
		btn:SetPos((pnl:GetWide()/4)*3-40, 30)
		btn:SetText("Turn Off")
		btn:SetDisabled(true)
		btn.DoClick = function(self)
			RunConsoleCommand("AdvDupe2_RemoveAutoSave")
			self:SetDisabled(true)
			AdvDupe2.AutoSavePos = nil
		end
		AdvDupe2.OffButton = btn


		--[[Experimental Section]]--
		local Category5 = vgui.Create("DCollapsibleCategory")
		CPanel:AddItem(Category5)
		Category5:SetLabel("Experimental Section")
		Category5:SetExpanded(0)

		local CategoryContent5 = vgui.Create( "DPanelList" )
		CategoryContent5:SetAutoSize( true )
		CategoryContent5:SetDrawBackground( false )
		CategoryContent5:SetSpacing( 3 )
		CategoryContent5:SetPadding( 2 )
		Category5:SetContents( CategoryContent5 )
		CategoryContent5.OnMouseWheeled = function(self, dlta) parent:OnMouseWheeled(dlta) end

		Check = vgui.Create("DCheckBoxLabel")
		Check:SetText( "Disable parented props physics interaction" )
		Check:SetDark(true)
		Check:SetConVar( "advdupe2_paste_disparents" )
		Check:SetValue( 0 )
		CategoryContent5:AddItem(Check)

		Check = vgui.Create("DCheckBoxLabel")
		Check:SetText( "Disable Dupe Spawn Protection" )
		Check:SetDark(true)
		Check:SetConVar( "advdupe2_paste_protectoveride" )
		Check:SetValue( 1 )
		Check:SetToolTip("Check this if you things don't look right after pasting.")
		CategoryContent5:AddItem(Check)

		Check = vgui.Create("DCheckBoxLabel")
		Check:SetText( "Open file after Saving" )
		Check:SetDark(true)
		Check:SetConVar( "advdupe2_debug_openfile" )
		Check:SetValue( 1 )
		Check:SetToolTip("Check this if you want your files to be opened after saving them.")
		CategoryContent5:AddItem(Check)

		--[[Save Map]]--
		if(LocalPlayer():IsAdmin()) then
			local Category6 = vgui.Create("DCollapsibleCategory")
			CPanel:AddItem(Category6)
			Category6:SetLabel("Save Map")
			Category6:SetExpanded(0)

			local CategoryContent6 = vgui.Create( "DPanelList" )
			CategoryContent6:SetAutoSize( true )
			CategoryContent6:SetDrawBackground( false )
			CategoryContent6:SetSpacing( 3 )
			CategoryContent6:SetPadding( 2 )
			Category6:SetContents( CategoryContent6 )
			CategoryContent6.OnMouseWheeled = function(self, dlta) parent:OnMouseWheeled(dlta) end

			pnl = vgui.Create("Panel")
			pnl:SetWide(CPanel:GetWide()-40)
			pnl:SetTall(75)
			pnl:SetPos(0, 50)
			CategoryContent6:AddItem(pnl)

			label = vgui.Create("DLabel", pnl)
			label:SetText("File Name: ")
			label:SizeToContents()
			label:SetDark(true)
			label:SetPos(5,7)

			AdvDupe2.AutoSavePath = ""

			local txtbox2 = vgui.Create("DTextEntry", pnl)
			txtbox2:SetWide(pnl:GetWide()-100)
			txtbox2:SetPos(60, 5)

			local btn2 = vgui.Create("DImageButton", pnl)
			x, y = txtbox2:GetPos()
			btn2:SetPos(x + txtbox2:GetWide() + 5, 7)
			btn2:SetMaterial("icon16/disk.png")
			btn2:SizeToContents()
			btn2:SetToolTip("Save Map")
			btn2.DoClick = 	function()
				if(txtbox2:GetValue()=="") then return end
				RunConsoleCommand("AdvDupe2_SaveMap", txtbox2:GetValue())
			end
			txtbox2.OnEnter = function()
				btn2:DoClick()
			end
		end
	end

	function TOOL.BuildCPanel(panel)
		panel:ClearControls()
		panel:AddControl("Header", {
			Text = "Advanced Duplicator 2",
			Description = "Duplicate stuff."
		})
		local function tryToBuild()
			local CPanel = controlpanel.Get("advdupe2")
			if CPanel and CPanel:GetWide()>16 then
				BuildCPanel(CPanel)
			else
				timer.Simple(0.1,tryToBuild)
			end
		end
		tryToBuild()
	end

	local StColor  = {r=130, g=25, b=40, a=255}
	local NoColor  = {r=25, g=100, b=40, a=255}
	local CurColor = {r=25, g=100, b=40, a=255}
	local CWhite   = Color(255,255,255,255)
	surface.CreateFont ("AD2Font", {font="Arial", size=40, weight=1000}) ---Remember to use gm_clearfonts
	surface.CreateFont ("AD2TitleFont", {font="Arial", size=24, weight=1000})

	function TOOL:DrawToolScreen()
		if(not AdvDupe2) then return true end

		local text = "Ready"
		local state, co = false
		local ply = LocalPlayer()

		if(AdvDupe2.Preview) then
			text = "Preview"
		end
		if(AdvDupe2.ProgressBar.Text) then
			state = true
			text = AdvDupe2.ProgressBar.Text
		end

		cam.Start2D()

			surface.SetDrawColor(32, 32, 32, 255)
			surface.DrawRect(0, 0, 256, 256)

			if(state) then
				co = StColor
			else
				co = NoColor
			end

			local rate = FrameTime() * 160
			CurColor.r = math.Approach( CurColor.r, co.r, rate )
			CurColor.g = math.Approach( CurColor.g, co.g, rate )

			surface.SetDrawColor(CurColor)
			surface.DrawRect(13, 13, 230, 230)

			surface.SetTextColor( 255, 255, 255, 255 )

			draw.SimpleText("Advanced Duplicator 2", "AD2TitleFont", 128, 50, CWhite, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
			draw.SimpleText(text, "AD2Font", 128, 128, CWhite, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
			if(state) then
				draw.RoundedBox( 6, 32, 178, 192, 28, Color( 255, 255, 255, 150 ) )
				draw.RoundedBox( 6, 34, 180, 188*(AdvDupe2.ProgressBar.Percent / 100), 24, Color( 0, 255, 0, 255 ) )
			elseif(ply:KeyDown(IN_USE)) then
				local font, align = "AD2TitleFont", TEXT_ALIGN_BOTTOM
				draw.SimpleText("H: "..ply:GetInfo("advdupe2_offset_z")    , font, 20,  210, CWhite, TEXT_ALIGN_LEFT , align)
				draw.SimpleText("P: "..ply:GetInfo("advdupe2_offset_pitch"), font, 236, 210, CWhite, TEXT_ALIGN_RIGHT, align)
				draw.SimpleText("Y: "..ply:GetInfo("advdupe2_offset_yaw")  , font, 20 , 240, CWhite, TEXT_ALIGN_LEFT , align)
				draw.SimpleText("R: "..ply:GetInfo("advdupe2_offset_roll") , font, 236, 240, CWhite, TEXT_ALIGN_RIGHT, align)
			end

		cam.End2D()
	end


	local function FindInBox(min, max, ply)
		local EntTable = {}
		for _,ent in ents.Iterator() do
			local pos = ent:GetPos()
			if (pos.X>=min.X) and (pos.X<=max.X) and (pos.Y>=min.Y) and (pos.Y<=max.Y) and (pos.Z>=min.Z) and (pos.Z<=max.Z) then
				--if(ent:GetClass()~="C_BaseFlexclass") then
					EntTable[ent:EntIndex()] = ent
				--end
			end
		end

		return EntTable
	end


	local GreenSelected = Color(0, 255, 0, 255)
	function AdvDupe2.DrawSelectionBox()

		local TraceRes = util.TraceLine(util.GetPlayerTrace(LocalPlayer()))
		local i = math.Clamp(tonumber(LocalPlayer():GetInfo("advdupe2_area_copy_size")) or 50, 0, 30720)

		--Bottom Points
		local B1 = (Vector(-i,-i,-i) + TraceRes.HitPos)
		local B2 = (Vector(-i, i,-i) + TraceRes.HitPos)
		local B3 = (Vector( i, i,-i) + TraceRes.HitPos)
		local B4 = (Vector( i,-i,-i) + TraceRes.HitPos)

		--Top Points
		local T1 = (Vector(-i,-i, i) + TraceRes.HitPos):ToScreen()
		local T2 = (Vector(-i, i, i) + TraceRes.HitPos):ToScreen()
		local T3 = (Vector( i, i, i) + TraceRes.HitPos):ToScreen()
		local T4 = (Vector( i,-i, i) + TraceRes.HitPos):ToScreen()

		if(not AdvDupe2.LastUpdate or CurTime()>=AdvDupe2.LastUpdate) then

			if AdvDupe2.ColorEntities then
				for k,v in pairs(AdvDupe2.EntityColors)do
					local ent = AdvDupe2.ColorEntities[k]
					if(IsValid(ent)) then
						AdvDupe2.ColorEntities[k]:SetColor(v)
					end
				end
			end

			local Entities = FindInBox(B1, (Vector(i,i,i)+TraceRes.HitPos), LocalPlayer())
			AdvDupe2.ColorEntities = Entities
			AdvDupe2.EntityColors = {}
			for k,v in pairs(Entities)do
				AdvDupe2.EntityColors[k] = v:GetColor()
				v:SetColor(GreenSelected)
			end
			AdvDupe2.LastUpdate = CurTime()+0.25

		end

		local tracedata = {}
		tracedata.mask = MASK_NPCWORLDSTATIC
		local WorldTrace

		tracedata.start = B1+Vector(0,0,i*2)
		tracedata.endpos = B1
		WorldTrace = util.TraceLine( tracedata )
		B1 = WorldTrace.HitPos:ToScreen()
		tracedata.start = B2+Vector(0,0,i*2)
		tracedata.endpos = B2
		WorldTrace = util.TraceLine( tracedata )
		B2 = WorldTrace.HitPos:ToScreen()
		tracedata.start = B3+Vector(0,0,i*2)
		tracedata.endpos = B3
		WorldTrace = util.TraceLine( tracedata )
		B3 = WorldTrace.HitPos:ToScreen()
		tracedata.start = B4+Vector(0,0,i*2)
		tracedata.endpos = B4
		WorldTrace = util.TraceLine( tracedata )
		B4 = WorldTrace.HitPos:ToScreen()

		surface.SetDrawColor( 0, 255, 0, 255 )

		--Draw Sides
		surface.DrawLine(B1.x, B1.y, T1.x, T1.y)
		surface.DrawLine(B2.x, B2.y, T2.x, T2.y)
		surface.DrawLine(B3.x, B3.y, T3.x, T3.y)
		surface.DrawLine(B4.x, B4.y, T4.x, T4.y)

		--Draw Bottom
		surface.DrawLine(B1.x, B1.y, B2.x, B2.y)
		surface.DrawLine(B2.x, B2.y, B3.x, B3.y)
		surface.DrawLine(B3.x, B3.y, B4.x, B4.y)
		surface.DrawLine(B4.x, B4.y, B1.x, B1.y)

		--Draw Top
		surface.DrawLine(T1.x, T1.y, T2.x, T2.y)
		surface.DrawLine(T2.x, T2.y, T3.x, T3.y)
		surface.DrawLine(T3.x, T3.y, T4.x, T4.y)
		surface.DrawLine(T4.x, T4.y, T1.x, T1.y)

	end

	net.Receive("AdvDupe2_DrawSelectBox", function()
		hook.Add("HUDPaint", "AdvDupe2_DrawSelectionBox", AdvDupe2.DrawSelectionBox)
	end)

	function AdvDupe2.RemoveSelectBox()
		hook.Remove("HUDPaint", "AdvDupe2_DrawSelectionBox")
		if AdvDupe2.ColorEntities then
			for k,v in pairs(AdvDupe2.EntityColors)do
				if(not IsValid(AdvDupe2.ColorEntities[k])) then
					AdvDupe2.ColorEntities[k]=nil
				else
					AdvDupe2.ColorEntities[k]:SetColor(v)
				end
			end
			AdvDupe2.ColorEntities={}
			AdvDupe2.EntityColors={}
		end
	end
	net.Receive("AdvDupe2_RemoveSelectBox",function()
		AdvDupe2.RemoveSelectBox()
	end)

	function AdvDupe2.InitProgressBar(label)
		AdvDupe2.ProgressBar = {}
		AdvDupe2.ProgressBar.Text = label
		AdvDupe2.ProgressBar.Percent = 0
		AdvDupe2.BusyBar = true
	end
	net.Receive("AdvDupe2_InitProgressBar", function()
		AdvDupe2.InitProgressBar(net.ReadString())
	end)

	net.Receive("AdvDupe2_UpdateProgressBar", function()
		AdvDupe2.ProgressBar.Percent = net.ReadFloat()
	end)

	function AdvDupe2.RemoveProgressBar()
		AdvDupe2.ProgressBar = {}
		AdvDupe2.BusyBar = false
		if(AdvDupe2.Ghosting) then
			AdvDupe2.InitProgressBar("Ghosting: ")
			AdvDupe2.BusyBar = false
			AdvDupe2.ProgressBar.Percent = AdvDupe2.CurrentGhost/AdvDupe2.TotalGhosts*100
		end
	end
	net.Receive("AdvDupe2_RemoveProgressBar", function()
		AdvDupe2.RemoveProgressBar()
	end)

	net.Receive("AdvDupe2_ResetOffsets", function()
		RunConsoleCommand("advdupe2_original_origin", "0")
		RunConsoleCommand("advdupe2_paste_constraints","1")
		RunConsoleCommand("advdupe2_offset_z","0")
		RunConsoleCommand("advdupe2_offset_pitch","0")
		RunConsoleCommand("advdupe2_offset_yaw","0")
		RunConsoleCommand("advdupe2_offset_roll","0")
		RunConsoleCommand("advdupe2_paste_parents","1")
		RunConsoleCommand("advdupe2_paste_disparents","0")
	end)

	net.Receive("AdvDupe2_ReportModel", function()
		print("Advanced Duplicator 2: Invalid Model: "..net.ReadString())
	end)

	net.Receive("AdvDupe2_ReportClass", function()
		print("Advanced Duplicator 2: Invalid Class: "..net.ReadString())
	end)

	net.Receive("AdvDupe2_ResetDupeInfo", function()
		if not AdvDupe2.Info then return end
		AdvDupe2.Info.File:SetText("File:")
		AdvDupe2.Info.Creator:SetText("Creator:")
		AdvDupe2.Info.Date:SetText("Date:")
		AdvDupe2.Info.Time:SetText("Time:")
		AdvDupe2.Info.Size:SetText("Size:")
		AdvDupe2.Info.Desc:SetText("Desc:")
		AdvDupe2.Info.Entities:SetText("Entities:")
		AdvDupe2.Info.Constraints:SetText("Constraints:")
	end)

	net.Receive("AdvDupe2_CanAutoSave", function()
		if(AdvDupe2.AutoSavePath~="") then
			AdvDupe2.AutoSavePos = net.ReadVector()
			AdvDupe2.AutoSaveSize = net.ReadFloat()
			local ent = net.ReadUInt(16)
			AdvDupe2.OffButton:SetDisabled(false)
			net.Start("AdvDupe2_CanAutoSave")
				net.WriteString(AdvDupe2.AutoSaveDesc)
				net.WriteInt(ent, 16)
				if(game.SinglePlayer()) then
					net.WriteString(string.sub(AdvDupe2.AutoSavePath, 10, #AdvDupe2.AutoSavePath))
				end
			net.SendToServer()
		else
			AdvDupe2.Notify("Select a directory for the Area Auto Save.", NOTIFY_ERROR)
		end
	end)

	net.Receive("AdvDupe2_SetDupeInfo", function(len, ply, len2)
		if AdvDupe2.Info then
			AdvDupe2.Info.File:SetText("File: "..net.ReadString())
			AdvDupe2.Info.Creator:SetText("Creator: "..net.ReadString())
			AdvDupe2.Info.Date:SetText("Date: "..net.ReadString())
			AdvDupe2.Info.Time:SetText("Time: "..net.ReadString())
			AdvDupe2.Info.Size:SetText("Size: "..net.ReadString())
			AdvDupe2.Info.Desc:SetText("Desc: "..net.ReadString())
			AdvDupe2.Info.Entities:SetText("Entities: "..net.ReadString())
			AdvDupe2.Info.Constraints:SetText("Constraints: "..net.ReadString())
		else
			AdvDupe2.InfoText.File = "File: "..net.ReadString()
			AdvDupe2.InfoText.Creator = "Creator: "..net.ReadString()
			AdvDupe2.InfoText.Date = "Date: "..net.ReadString()
			AdvDupe2.InfoText.Time = "Time: "..net.ReadString()
			AdvDupe2.InfoText.Size = "Size: "..net.ReadString()
			AdvDupe2.InfoText.Desc = "Desc: "..net.ReadString()
			AdvDupe2.InfoText.Entities = "Entities: "..net.ReadString()
			AdvDupe2.InfoText.Constraints = "Constraints: "..net.ReadString()
		end
	end)
end

--PATH lua/weapons/gmod_tool/stools/heart_turbolaser_tool.lua:
return gluapack()()
--PATH addons/[misc] smartspawnmanager/lua/weapons/gmod_tool/stools/smart_player_spawn.lua:
return gluapack()()
--PATH lua/weapons/gmod_tool/stools/streamradio_gui_color_global.lua:
return gluapack()()
--PATH lua/weapons/gmod_tool/stools/streamradio_gui_color_individual.lua:
return gluapack()()
--PATH lua/weapons/gmod_tool/stools/streamradio_gui_skin.lua:
TOOL.Category = "Stream Radio"
TOOL.Name = "#Tool." .. TOOL.Mode .. ".name"

TOOL.Information = {
	{ name = "left" },
	{ name = "right" },
	{ name = "reload" }
}

if StreamRadioLib and StreamRadioLib.Loaded then
	StreamRadioLib.Tool.RegisterClientToolHook(TOOL, "LeftClick")
	StreamRadioLib.Tool.RegisterClientToolHook(TOOL, "RightClick")
	StreamRadioLib.Tool.RegisterClientToolHook(TOOL, "Reload")
	StreamRadioLib.Tool.RegisterClientToolHook(TOOL, "Deploy")

	StreamRadioLib.Tool.AddLocale(TOOL, "name", "Radio Skin Duplicator")
	StreamRadioLib.Tool.AddLocale(TOOL, "desc", "Change, Copy or Save the skin of radios")

	StreamRadioLib.Tool.AddLocale(TOOL, "left", "Apply skin to the radio")
	StreamRadioLib.Tool.AddLocale(TOOL, "right", "Copy skin from the radio")
	StreamRadioLib.Tool.AddLocale(TOOL, "reload", "Reset the skin to default")

	StreamRadioLib.Tool.AddLocale(TOOL, "list", "List of saved skins:")

	StreamRadioLib.Tool.AddLocale(TOOL, "file.text.desc", "Enter the name of your skin here.\nPress 'Save' to save it to your hard disk.")

	StreamRadioLib.Tool.AddLocale(TOOL, "file.button.delete", "Delete")
	StreamRadioLib.Tool.AddLocale(TOOL, "file.button.delete.desc", "Delete the selected skin file from your hard disk.")
	StreamRadioLib.Tool.AddLocale(TOOL, "file.button.delete.error.empty", "You need to enter or select something to delete.")
	StreamRadioLib.Tool.AddLocale(TOOL, "file.button.delete.error.notfound", "The skin file does not exist.")
	StreamRadioLib.Tool.AddLocale(TOOL, "file.button.delete.error.protected", "The skin file is protected and can not be deleted.")

	StreamRadioLib.Tool.AddLocale(TOOL, "file.button.save", "Save")
	StreamRadioLib.Tool.AddLocale(TOOL, "file.button.save.desc", "Save skin to the filename as given above to your hard disk.")
	StreamRadioLib.Tool.AddLocale(TOOL, "file.button.save.error.protected", "The skin file is protected and can not be overwritten.")

	StreamRadioLib.Tool.AddLocale(TOOL, "file.button.open", "Open")
	StreamRadioLib.Tool.AddLocale(TOOL, "file.button.open.desc", "Open selected skin file.\nYou can also double click on the file to open it.")
	StreamRadioLib.Tool.AddLocale(TOOL, "file.button.open.error.empty", "You need to enter or select something to open.")
	StreamRadioLib.Tool.AddLocale(TOOL, "file.button.open.error.notfound", "The skin file does not exist.")

	StreamRadioLib.Tool.AddLocale(TOOL, "file.delete", "Delete skin?")
	StreamRadioLib.Tool.AddLocale(TOOL, "file.delete.desc", "Do you want to delete this skin file from your hard disk?")
	StreamRadioLib.Tool.AddLocale(TOOL, "file.delete.yes", "Yes, delete it.")
	StreamRadioLib.Tool.AddLocale(TOOL, "file.delete.no", "No, don't delete it.")

	StreamRadioLib.Tool.AddLocale(TOOL, "file.save", "Overwrite skin?")
	StreamRadioLib.Tool.AddLocale(TOOL, "file.save.desc", "Do you want to overwrite this skin file?")
	StreamRadioLib.Tool.AddLocale(TOOL, "file.save.yes", "Yes, overwrite it.")
	StreamRadioLib.Tool.AddLocale(TOOL, "file.save.no", "No, don't overwrite it.")

	StreamRadioLib.Tool.Setup(TOOL)
else
	TOOL.Information = nil

	if CLIENT then
		local StreamRadioLib = StreamRadioLib or {}
		local _mode = TOOL.Mode

		language.Add("Tool." .. _mode .. ".name", "Radio Skin Duplicator")
		language.Add("Tool." .. _mode .. ".desc", "Change, Copy or Save the skin of radios")
		language.Add("Tool." .. _mode .. ".0", "This tool could not be loaded.")

		function TOOL.BuildCPanel(CPanel)
			if StreamRadioLib.Loader_CreateErrorPanel then
				StreamRadioLib.Loader_CreateErrorPanel(CPanel, "This tool could not be loaded.")
			end
		end
	end
end

local function getnewname()
	local newnamebase = "newskin"
	local newname = newnamebase
	local count = 2

	while true do
		if not StreamRadioLib.Skin.IsValidSkinFile(newname) then
			return newname
		end

		if count >= 100 then
			return ""
		end

		newname = newnamebase .. count
		count = count + 1
	end
end

function TOOL:IsValid()
	return IsValid(self:GetSWEP())
end

function TOOL:AddSkinList( panel )
	local listpanel = vgui.Create( "DListView" )
	panel:AddPanel(listpanel)

	listpanel:SetMultiSelect(false)

	local col1 = listpanel:AddColumn("No.")
	listpanel:AddColumn("Name")
	local col3 = listpanel:AddColumn("Open")

	col1:SetFixedWidth(30)
	col3:SetFixedWidth(40)

	listpanel:SetTall(200)
	listpanel:SortByColumn(1)
	return listpanel
end

function TOOL:AddFileControlPanel( panel )
	local bgpanel = vgui.Create( "DPanel" )
	panel:AddPanel(bgpanel)

	bgpanel:SetPaintBackground(false)

	local buttonpanel = vgui.Create( "DPanel", bgpanel)
	buttonpanel:Dock(BOTTOM)
	buttonpanel:SetPaintBackground(false)
	buttonpanel:SetHeight(25)

	local buttondelete = vgui.Create( "DButton", buttonpanel)
	buttondelete:Dock(LEFT)
	buttondelete:SetText(StreamRadioLib.Tool.GetLocale(self, "file.button.delete"))
	buttondelete:SetWide(70)
	buttondelete:SetTooltip(StreamRadioLib.Tool.GetLocale(self, "file.button.delete.desc"))

	local buttonsave = vgui.Create( "DButton", buttonpanel)
	buttonsave:Dock(RIGHT)
	buttonsave:SetText(StreamRadioLib.Tool.GetLocale(self, "file.button.save"))
	buttonsave:SetWide(70)
	buttonsave:SetTooltip(StreamRadioLib.Tool.GetLocale(self, "file.button.save.desc"))

	local buttonopen = vgui.Create( "DButton", buttonpanel)
	buttonopen:Dock(FILL)
	buttonopen:DockMargin(5, 0, 5, 0)
	buttonopen:SetText(StreamRadioLib.Tool.GetLocale(self, "file.button.open"))
	buttonopen:SetTooltip(StreamRadioLib.Tool.GetLocale(self, "file.button.open.desc"))

	local text = vgui.Create( "DTextEntry", bgpanel)
	text:DockMargin(0, 0, 0, 5)
	text:Dock(FILL)

	text:SetHistoryEnabled(false)
	text:SetAllowNonAsciiCharacters(false)
	text:SetEnterAllowed(true)
	text:SetMultiline(false)
	text:SetUpdateOnType(true)
	text:SetTooltip(StreamRadioLib.Tool.GetLocale(self, "file.text.desc"))

	bgpanel:SetHeight(55)

	local deletefile = function(name)
		local ok = StreamRadioLib.Skin.Delete(name)

		if bgpanel.OnDeleted then
			bgpanel:OnDeleted(name, ok)
		end
	end

	local openfile = function(name)
		local data = StreamRadioLib.Skin.Open(name)
		local ok = true

		if not data then
			ok = false
		else
			self:SetSkin(data)
		end

		if bgpanel.OnOpened then
			bgpanel:OnOpened(name, ok)
		end
	end

	local savefile = function(name)
		local data = self:GetSkin()
		local ok = StreamRadioLib.Skin.Save(name, data)

		if bgpanel.OnSaved then
			bgpanel:OnSaved(name, ok)
		end
	end

	local checkfile = function(filename)
		filename = StreamRadioLib.Skin.SanitizeName(filename)

		buttondelete:SetEnabled(true)
		buttonopen:SetEnabled(true)
		buttonsave:SetEnabled(true)

		buttondelete:SetTooltip(StreamRadioLib.Tool.GetLocale(self, "file.button.delete.desc"))
		buttonopen:SetTooltip(StreamRadioLib.Tool.GetLocale(self, "file.button.open.desc"))
		buttonsave:SetTooltip(StreamRadioLib.Tool.GetLocale(self, "file.button.save.desc"))

		if filename == "" then
			buttondelete:SetEnabled(false)
			buttonopen:SetEnabled(false)

			buttondelete:SetTooltip(StreamRadioLib.Tool.GetLocale(self, "file.button.delete.error.empty"))
			buttonopen:SetTooltip(StreamRadioLib.Tool.GetLocale(self, "file.button.open.error.empty"))

			return
		end

		if not StreamRadioLib.Skin.IsValidSkinFile(filename) then
			buttondelete:SetEnabled(false)
			buttonopen:SetEnabled(false)

			buttondelete:SetTooltip(StreamRadioLib.Tool.GetLocale(self, "file.button.delete.error.notfound"))
			buttonopen:SetTooltip(StreamRadioLib.Tool.GetLocale(self, "file.button.open.error.notfound"))
		end

		if filename == "default" then
			buttondelete:SetEnabled(false)
			buttonsave:SetEnabled(false)

			buttondelete:SetTooltip(StreamRadioLib.Tool.GetLocale(self, "file.button.delete.error.protected"))
			buttonsave:SetTooltip(StreamRadioLib.Tool.GetLocale(self, "file.button.save.error.protected"))
		end
	end

	text.OnValueChange = function(this, value)
		checkfile(value)
	end

	bgpanel.SetFile = function(this, filename)
		if not IsValid(text) then return end

		local filename = StreamRadioLib.Skin.SanitizeName(filename)

		if filename == "" then
			filename = getnewname()
		end

		checkfile(filename)
		text:SetText(filename)
	end

	bgpanel.GetFile = function(this)
		if not IsValid(text) then return end

		local name = StreamRadioLib.Skin.SanitizeName(text:GetText())
		return name
	end

	bgpanel.OpenFile = function()
		if not IsValid(self) then return end
		if not IsValid(text) then return end
		if not IsValid(bgpanel) then return end

		local name = bgpanel:GetFile()
		checkfile(name)

		openfile(name)
	end

	buttondelete.DoClick = function()
		if not IsValid(self) then return end
		if not IsValid(text) then return end
		if not IsValid(bgpanel) then return end

		local name = bgpanel:GetFile()
		checkfile(name)

		Derma_Query(
			StreamRadioLib.Tool.GetLocaleTranslation(self, "file.delete.desc"),
			StreamRadioLib.Tool.GetLocaleTranslation(self, "file.delete"),
			StreamRadioLib.Tool.GetLocaleTranslation(self, "file.delete.yes"),
			function()
				if not IsValid(self) then return end
				if not IsValid(panel) then return end
				if not IsValid(text) then return end
				if not IsValid(bgpanel) then return end

				deletefile(name)
			end,
			StreamRadioLib.Tool.GetLocaleTranslation(self, "file.delete.no")
		)
	end

	buttonopen.DoClick = function()
		bgpanel:OpenFile()
	end

	buttonsave.DoClick = function()
		if not IsValid(self) then return end
		if not IsValid(text) then return end
		if not IsValid(bgpanel) then return end

		local name = bgpanel:GetFile()
		checkfile(name)

		if name == "" then
			name = getnewname()
		end

		if StreamRadioLib.Skin.IsValidSkinFile(name) then
			Derma_Query(
				StreamRadioLib.Tool.GetLocaleTranslation(self, "file.save.desc"),
				StreamRadioLib.Tool.GetLocaleTranslation(self, "file.save"),
				StreamRadioLib.Tool.GetLocaleTranslation(self, "file.save.yes"),
				function()
					if not IsValid(self) then return end
					if not IsValid(panel) then return end
					if not IsValid(text) then return end
					if not IsValid(bgpanel) then return end

					savefile(name)
				end,
				StreamRadioLib.Tool.GetLocaleTranslation(self, "file.save.no")
			)

			return
		end

		savefile(name)
	end

	return bgpanel
end

function TOOL:RefreshList()
	if not IsValid(self.filelistpanel) then return end

	local skinlist = StreamRadioLib.Skin.GetList()

	self.filelistpanel:Clear()
	self.filelistpanel._filemap = {}

	for i, name in ipairs(skinlist) do
		if IsValid(self.filelistpanel._filemap[name]) then
			continue
		end

		local line = self.filelistpanel:AddLine(i, name, "")
		line:SetSortValue(1, i)
		line:SetSortValue(3, 0)

		self.filelistpanel._filemap[name] = line
	end

	if not IsValid(self.filecontrolpanel) then return end
	timer.Simple(0.1, function()
		if not IsValid(self) then return end
		if not IsValid(self.filecontrolpanel) then return end

		self:MakeFileAsOpen(self.OpenName)
	end)
end


function TOOL:MakeFileAsOpen(name)
	name = StreamRadioLib.Skin.SanitizeName(name)

	if IsValid(self.filecontrolpanel) and name ~= "" then
		self.filecontrolpanel:SetFile(name)
	end

	self.OpenName = name

	if not IsValid(self.filelistpanel) then return end
	if not self.filelistpanel._filemap then return end

	local openline = self.filelistpanel._filemap[name]
	if not IsValid(openline) then return end

	if IsValid(self._oldopenline) then
		self._oldopenline:SetColumnText(3, "")
		self._oldopenline:SetSortValue(3, 0)

		local column = self._oldopenline.Columns[3]
		if IsValid(column) then
			column:SetColor(Color(0, 0, 0, 255))
			column:SetBGColor(Color(255, 255, 255, 255))
			column:SetPaintBackgroundEnabled(true)
		end
	end

	openline:SetColumnText(3, "Open")
	openline:SetSortValue(3, 1)

	local column = openline.Columns[3]
	if IsValid(column) then
		column:SetColor(Color(0, 0, 0, 255))
		column:SetBGColor(Color(0, 192, 0, 255))
		column:SetPaintBackgroundEnabled(true)
	end

	self._oldopenline = openline

	self.filelistpanel:ClearSelection()
	self.filelistpanel:SelectItem(openline)
end

function TOOL:BuildToolPanel( CPanel )
	self:AddLabel(CPanel, "list")

	self.filelistpanel = self:AddSkinList(CPanel)
	local listpanel = self.filelistpanel
	local filepanel = nil

	listpanel.OnRowSelected = function(this, LineID, Line)
		if not IsValid(Line) then return end
		if not IsValid(filepanel) then return end

		local name = Line:GetColumnText(2)
		filepanel:SetFile(name)
	end

	listpanel.DoDoubleClick = function(this, LineID, Line)
		if not IsValid(Line) then return end
		if not IsValid(filepanel) then return end

		local name = Line:GetColumnText(2)
		filepanel:SetFile(name)
		filepanel:OpenFile()
	end

	listpanel:SelectFirstItem()

	self.filecontrolpanel = self:AddFileControlPanel(CPanel)
	filepanel = self.filecontrolpanel

	filepanel.OnOpened = function(this, name, ok)
		if not ok then return end
		self:MakeFileAsOpen(name)
	end

	filepanel.OnDeleted = function(this, name, ok)
		if not ok then
			return
		end

		self:RefreshList()
	end

	filepanel.OnSaved = function(this, name, ok)
		if not ok then
			return
		end

		local data = StreamRadioLib.Skin.Open(name)

		if not data then
			return
		end

		self:SetSkin(data)
		self:RefreshList()
	end

	self:RefreshList()

	filepanel:SetFile("default")
	filepanel:OpenFile()

	self.filelistpanel:SelectFirstItem()
end

function TOOL:SetSkin(skindata)
	self.skin = table.Copy(skindata or {})

	local name = StreamRadioLib.Skin.SanitizeName(self.skin.name)

	if name == "" then
		name = getnewname()
	end

	self:MakeFileAsOpen(name)
end

function TOOL:GetSkin()
	return self.skin or StreamRadioLib.Skin.GetDefaultSkin()
end

function TOOL:GetAimedGui(trace)
	if not self.ToolLibLoaded then return end

	trace = trace or self:GetFallbackTrace()

	if not trace then return end
	if not trace.Hit then return end

	local ent = trace.Entity

	if not self:IsValidGUIRadio(ent) then return end

	local entgui = ent:GetGUI()
	if not IsValid(entgui) then return end

	return entgui, ent
end

function TOOL:LeftClick(trace)
	if not self.ToolLibLoaded then return end
	local entgui = self:GetAimedGui(trace)
	if not IsValid(entgui) then return false end

	if CLIENT then return true end

	StreamRadioLib.Tool.CallClientToolHook(self, "LeftClick")
	return true
end

function TOOL:LeftClickClient()
	if not self.ToolLibLoaded then return end
	local entgui = self:GetAimedGui()
	if not IsValid(entgui) then return false end

	entgui:SetSkinOnServer(self:GetSkin(), false)
end

function TOOL:RightClick(trace)
	if not self.ToolLibLoaded then return end
	local entgui = self:GetAimedGui(trace)
	if not IsValid(entgui) then return false end

	if CLIENT then return true end

	StreamRadioLib.Tool.CallClientToolHook(self, "RightClick")
	return true
end

function TOOL:RightClickClient()
	if not self.ToolLibLoaded then return end
	local entgui = self:GetAimedGui()
	if not IsValid(entgui) then return false end

	self:SetSkin(entgui:GetSkin())
end

function TOOL:Reload(trace)
	if not self.ToolLibLoaded then return end
	local entgui = self:GetAimedGui(trace)
	if not IsValid(entgui) then return false end

	if CLIENT then return true end

	StreamRadioLib.Tool.CallClientToolHook(self, "Reload")
	return true
end

function TOOL:ReloadClient()
	if not self.ToolLibLoaded then return end
	local entgui = self:GetAimedGui()
	if not IsValid(entgui) then return false end

	entgui:SetSkinOnServer(StreamRadioLib.Skin.GetDefaultSkin(), false)
end

function TOOL:Deploy()
	if not self.ToolLibLoaded then return end
	StreamRadioLib.Tool.CallClientToolHook(self, "Deploy")
end

function TOOL:DeployClient()
	if not self.ToolLibLoaded then return end
	self:RefreshList()
end

--PATH lua/weapons/gmod_tool/stools/turbolaser.lua:
return gluapack()()
--PATH lua/weapons/gmod_tool/stools/vjstool_npcmover.lua:
return gluapack()()
--PATH lua/weapons/gmod_tool/stools/vjstool_npcrelationship.lua:
return gluapack()()
--PATH lua/weapons/jet_mk2.lua:

AddCSLuaFile()

SWEP.ViewModel = Model( "models/weapons/c_arms_animations.mdl" )
SWEP.WorldModel = ""

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic		= false
SWEP.Primary.Ammo			= "none"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= false
SWEP.Secondary.Ammo			= "none"

SWEP.PrintName	= "Jump Pack"
SWEP.Category	= "Star Wars Jetpacks"
SWEP.Purpose    = "LMB - Equip/Unequip\n\nSPACE - Fly up\n\nCTRL - Fly down\n\nSHIFT - Hover"

SWEP.Slot		= 4
SWEP.SlotPos	= 1

SWEP.DrawAmmo		= false
SWEP.DrawCrosshair	= false
SWEP.Spawnable		= true
SWEP.AdminOnly		= false

if SERVER then
	SWEP.AutoSwitchTo		= false
	SWEP.AutoSwitchFrom		= false
end

function SWEP:SetupDataTables()
	self:NetworkVar( "Int", 0, "Fuel" )
	if ( SERVER ) then
		self:SetFuel(100)
	end
end

function SWEP:Initialize()
	self:SetHoldType( "normal" )
end



function SWEP:Reload()
end

function SWEP:PrimaryAttack()
	if CLIENT then return end
	local ply = self:GetOwner()
	local ex = ply:GetNWEntity('Jetted')
	if IsValid(ex) then
		ex:Remove()
		ply:SetNWEntity('Jetted',NULL)
		ply.LastJetExecuted = CurTime()
	else
		if !ply:IsOnGround() then return end
		if (ply.LastJetExecuted or 0)+1 >= CurTime() then return end
		local jp = ents.Create('mk2')
		jp:SetSlotName('mk2')
		jp:Spawn()
		jp:Attach(ply)
		ply.Jetted = jp
		ply:SetNWEntity('Jetted',jp)
	end
	ply:EmitSound('buttons/button14.wav')
end

local skinint = 1

function SWEP:SecondaryAttack()
	if CLIENT then return end
	local ply = self:GetOwner()
	local ex = ply:GetNWEntity('Jetted')
	if !IsValid(ex) then return end
	skinint = (skinint + 1)%3
	ex:SetSkin(skinint)
	ply:EmitSound('buttons/button16.wav')
end

function SWEP:Deploy()
	return true
end

function SWEP:Equip()

end

function SWEP:ShouldDropOnDie() return false end


if SERVER then return end

--function SWEP:DrawHUD() end
--function SWEP:PrintWeaponInfo( x, y, alpha ) end

--function SWEP:HUDShouldDraw( name )
	--if ( name == "CHudWeaponSelection" ) then return true end
	--if ( name == "CHudChat" ) then return true end
	--return false
--end
--PATH gamemodes/starwarsrp/entities/weapons/ls_sniper/cl_init.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/entities/weapons/ls_sniper/cl_init.lua:
include("shared.lua")
local deltas = {-44, -34, -24, -14, 44, 34, 24, 14}
function SWEP:DrawHUD()
    if self:GetScopeLevel() < 2 then return end

    --Width hairs
    draw.RoundedBox(1, ScrW() / 2 - 54, ScrH() / 2, 50, 1, color_black)
    draw.RoundedBox(1, ScrW() / 2 + 4, ScrH() / 2, 50, 1, color_black)

    draw.RoundedBox(1, ScrW() / 2, ScrH() / 2 - 54, 1, 50, color_black)
    draw.RoundedBox(1, ScrW() / 2, ScrH() / 2 + 4, 1, 50, color_black)

    for _, v in ipairs(deltas) do
        draw.RoundedBox(1, ScrW() / 2 + v, ScrH() / 2 - 5, 1, 11, color_black)
        draw.RoundedBox(1, ScrW() / 2 - 5, ScrH() / 2 + v, 11, 1, color_black)
    end
end

--PATH gamemodes/starwarsrp/entities/weapons/ls_sniper/shared.lua:
AddCSLuaFile()

if SERVER then
    AddCSLuaFile("cl_init.lua")
end

if CLIENT then
    SWEP.Author = "DarkRP Developers"
    SWEP.Slot = 0
    SWEP.SlotPos = 0
    SWEP.IconLetter = "n"

    killicon.AddFont("ls_sniper", "CSKillIcons", SWEP.IconLetter, Color(200, 200, 200, 255))
end

DEFINE_BASECLASS("weapon_cs_base2")

SWEP.PrintName = "Silenced Sniper"
SWEP.Spawnable = true
SWEP.AdminOnly = false
SWEP.Category = "DarkRP (Weapon)"

SWEP.ViewModel = "models/weapons/cstrike/c_snip_g3sg1.mdl"
SWEP.WorldModel = "models/weapons/w_snip_g3sg1.mdl"

SWEP.Weight = 3

SWEP.HoldType = "ar2"
SWEP.LoweredHoldType = "passive"

SWEP.Primary.Sound = Sound("Weapon_M4A1.Silenced")
SWEP.Primary.Damage = 100
SWEP.Primary.Recoil = 0.03
SWEP.Primary.NumShots = 1
SWEP.Primary.Cone = 0.0001 - .05
SWEP.Primary.ClipSize = 25
SWEP.Primary.Delay = 0.7
SWEP.Primary.DefaultClip = 75
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "smg1"
SWEP.IronSightsPos = Vector(0, 0, 0) -- this is just to make it disappear so it doesn't show up whilst scoped

function SWEP:SetupDataTables()
    BaseClass.SetupDataTables(self)
    -- Int 0 = BurstBulletNum
    -- Int 1 = TotalUsedMagCount
    self:NetworkVar("Int", 2, "ScopeLevel")
end

function SWEP:Deploy()
    self:GetOwner():SetFOV(0, 0)

    self:SetScopeLevel(0)

    return BaseClass.Deploy(self)
end

function SWEP:Holster()
    self:GetOwner():SetFOV(0, 0)

    self:SetScopeLevel(0)

    return BaseClass.Holster(self)
end

local zoomFOV = {0, 0, 25, 5}
function SWEP:SecondaryAttack()
    if not self.IronSightsPos then return end

    self:SetNextSecondaryFire(CurTime() + 0.1)

    self:SetScopeLevel((self:GetScopeLevel() + 1) % 4)
    self:SetIronsights(self:GetScopeLevel() > 0)

    self:GetOwner():SetFOV(zoomFOV[self:GetScopeLevel() + 1], 0)
end

function SWEP:Reload()
    self:GetOwner():SetFOV(0, 0)

    self:SetScopeLevel(0)

    return BaseClass.Reload(self)
end

--PATH addons/[bronie] republic-essentials-v2d/lua/weapons/masita_dc15a.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 -- Change this if you want to select the weapon with other number

-- Trivia
SWEP.Category = "[ArcCW] Republic Essentials - Masita"
SWEP.Credits = "Kraken/Masita"
SWEP.PrintName = "DC-15a"
SWEP.Trivia_Class = "Blaster Rifle"
SWEP.Trivia_Desc = "The DC-15A blaster rifle, known simply as the DC-15 blaster rifle, was a heavy blaster rifle manufactured by BlasTech Industries, as part of the DC-15 family. It was one of the standard-issue weapons of the Galactic Republic's clone troopers, an army of cloned soldiers in the Grand Army of the Republic, during the Clone Wars against the Confederacy of Independent Systems."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/masita/dc15a.png"

-- Viewmodel & Entity Properties
SWEP.UseHands = true
SWEP.NoHideLeftHandInCustomization = true
SWEP.ViewModel = "models/servius/weapons/viewmodels/c_dc15a.mdl"
SWEP.WorldModel = "models/servius/weapons/worldmodels/w_dc-15a.mdl"
SWEP.ViewModelFOV = 56

SWEP.DefaultBodygroups = "010"
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.009
}

-- Damage & Tracer
SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 1.5,
    [HITGROUP_CHEST] = 1,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 36
SWEP.RangeMin = 243
SWEP.DamageMin = 24
SWEP.Range = 510
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400

SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1
SWEP.TracerNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 250)

SWEP.HullSize = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 55

SWEP.Recoil = 0.43
SWEP.RecoilSide = 0.23
SWEP.RecoilRise = 0.63
SWEP.Delay = 60 / 324
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 2
	},
    {
        Mode = 1
    },
    {
		Mode = -2
	},
    {
        Mode = 0
    },            
}

SWEP.AccuracyMOA = 0.50
SWEP.HipDispersion = 500
SWEP.MoveDispersion = 50

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 125
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

SWEP.ShootSound = "armas/disparos/dc15.wav"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 0, 255)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-4.66, -12.75, 2.529),
    Ang = Angle(0, 0, 0),
     Magnification = 1.5,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, 2, 3)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(7, 0, -4)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(15, -5, 1)
SWEP.CustomizeAng = Angle(15, 40, 30)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 1, 1)

SWEP.Bipod_Integral = true 
SWEP.BipodDispersion = 1
SWEP.BipodRecoil = 1 

-- Attachments
SWEP.DefaultElements = {"dc15"}
SWEP.AttachmentElements = {
    ["dc15"] = {
        WMElements = {
            {
                Model = "models/servius/weapons/worldmodels/w_dc-15a.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1.1, 1.1, 1.1),
                WBodygroups = {{ind = 0, bg = 0}},
                Offset = {
                    pos = Vector(-550, 0, 470),
                    ang = Angle(-15, 0, 180)
                }
            },
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(4150, 0, -1100),
                    ang = Angle(-15, 0, 100)
                },
                IsMuzzleDevice = true
            },
        },
    },
}
WMOverride = "models/servius/weapons/worldmodels/w_dc-15a.mdl"

SWEP.Attachments = {
    {
        PrintName = "Sight",
        DefaultAttName = "Standard", 
        Slot = "optic", 
        WMScale = Vector(111, 111, 111),
        Bone = "dc15a_DC15_mat",
        Offset = {
            vpos = Vector(0.110, -3.771, 2.1),
            vang = Angle(0, -90, 0),
            wpos = Vector(420, 50, -450),
            wang = Angle(-15, 0, 180)
        },
        CorrectiveAng = Angle(0, 180, 0),
        CorrectivePos = Vector(0, 0, 0),
    },          
    {
        PrintName = "Magazine Capacity",
        DefaultAttName = "Standard",
        Slot = {"dc15a_magazine_75"},
        WMScale = Vector(111, 111, 111),
        Bone = "dc15a_DC15_mat",
        Offset = {
            vpos = Vector(0, -3.7, 0.5),
            vang = Angle(0, 0, 90),
            wpos = Vector(550, 115, -250),
            wang = Angle(-15, -90, -90)
        },
    },      
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = "uc_fg",
    },   
    {
        PrintName = "Ammo", 
        DefaultAttName = "Standard",
        Slot = "ammo",
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Charms",
        DefaultAttName = "None",
        Slot = {"charm"},
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(111, 111, 111),
        Bone = "dc15a_DC15_mat",
        Offset = {
            vpos = Vector(1.3, -6.739, 0.504),
            vang = Angle(0, -90, 0),
            wpos = Vector(115, 180, -125),
            wang = Angle(-10 , 0, 180)
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        WMScale = Vector(111, 111, 111),
        Bone = "dc15a_DC15_mat",
        Offset = {
            vpos = Vector(1.1, -9, 0.7),
            vang = Angle(0, -90, 0),
            wpos = Vector(-100, 180, -75),
            wang = Angle(-15 , 0, 180)
        },
    },         
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "Neutral"
    },
    ["fire"] = {
        Time = 2.3,
        Source = {"shoot", "shoot2"},
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "armasclasicas/wpn_empire_lgequip.wav",
                p = 100, 
                v = 75,
                t = 0, 
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "armasclasicas/wpn_empire_medequip.wav",
                p = 100,
                v = 75,
                t = 0,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "dc15a_reload1", t = 2 / 10},
            {s = "everfall/weapons/miscellaneous/reload/reset/overheatactivecoolingsuccess_var_03.mp3", t = 2 },
            {s = "everfall/weapons/miscellaneous/reload/overheat/overheat_overheated_large_var_03.mp3", t = 2 / 30},
        },
    },


sound.Add({
    name =          "dc15a_reload1",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "armas/misc/dc17s_reload.wav"
    }),
}
--PATH addons/[bronie] republic-essentials-v2d/lua/weapons/masita_dc15a_modular.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 -- Change this if you want to select the weapon with other number

-- Trivia
SWEP.Category = "[ArcCW] Republic Essentials - Masita"
SWEP.Credits = "Kraken/Masita"
SWEP.PrintName = "Modular DC-15a"
SWEP.Trivia_Class = "Blaster Rifle"
SWEP.Trivia_Desc = "The DC-15A blaster rifle, known simply as the DC-15 blaster rifle, was a heavy blaster rifle manufactured by BlasTech Industries, as part of the DC-15 family. It was one of the standard-issue weapons of the Galactic Republic's clone troopers, an army of cloned soldiers in the Grand Army of the Republic, during the Clone Wars against the Confederacy of Independent Systems."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/masita/dc15a_modular.png"

-- Viewmodel & Entity Properties
SWEP.MirrorVMWM = true
SWEP.NoHideLeftHandInCustomization = false
SWEP.UseHands = true
SWEP.ViewModel = "models/everfall/weapons/viewmodels/c_dc15a.mdl"
SWEP.WorldModel = "models/everfall/weapons/worldmodels/w_dc15a.mdl"

SWEP.DefaultBodygroups = "000000000000000"

SWEP.ViewModelFOV = 50
SWEP.WorldModelOffset = {
    pos = Vector(-13, 6, -4.5),
    ang = Angle(-10, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
}

-- Damage & Tracer
SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 1.5,
    [HITGROUP_CHEST] = 1,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 32
SWEP.RangeMin = 207
SWEP.DamageMin = 24
SWEP.Range = 301
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400

SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1
SWEP.TracerNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 250)

SWEP.HullSize = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 50

SWEP.Recoil = 0.55
SWEP.RecoilSide = 0.23
SWEP.RecoilRise = 0.63
SWEP.Delay = 60 / 324
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 2
	},
    {
        Mode = 1
    },
    {
        Mode = 0
    },            
}

SWEP.AccuracyMOA = 0.50
SWEP.HipDispersion = 500
SWEP.MoveDispersion = 50

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 125
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

SWEP.ShootSound = "armas/disparos/dc15.wav"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 0, 255)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-4.987, -14, 0.939),
    Ang = Angle(0, 0, 0),
     Magnification = 1.4,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 55,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, 0, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(4.019, -5.226, -6)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(15, -5, -1.321)
SWEP.CustomizeAng = Angle(18.2, 39.4, 14.8)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 1, 1)

SWEP.Bipod_Integral = true 
SWEP.BipodDispersion = 1
SWEP.BipodRecoil = 1 

-- Attachments
SWEP.AttachmentElements = {
    ["15a_rangefinder"] = {
        VMBodygroups = {{ind = 6, bg = 2}},
    },
    ["15a_barrel_up"] = {
        VMBodygroups = {{ind = 3, bg = 1}},
    },
    ["15a_barrel_short"] = {
        NameChange = "Short DC-15a",
        VMBodygroups = {{ind = 3, bg = 2}},
        AttPosMods = {
            [2] = {
                vpos = Vector(00, -1.3, 25.7),
            },
        }
    },
    ["15a_barrel_extended"] = {
        NameChange = "Extended DC-15a",
        VMBodygroups = {{ind = 3, bg = 3}},
        AttPosMods = {
            [2] = {
                vpos = Vector(00, -1.3, 31.7),
            },
        }
    },
    ["15a_barrel_longrange"] = {
        NameChange = "DC-15x",
        VMBodygroups = {{ind = 3, bg = 4}},
        AttPosMods = {
            [2] = {
                vpos = Vector(00, -1.3, 31.7),
            },
        }
    },
    ["15a_foregrip"] = {
        VMBodygroups = {
            {ind = 5, bg = 1},
            {ind = 6, bg = 2}
        },
    },
    ["15a_top_short"] = {
        VMBodygroups = {{ind = 7, bg = 1}},
    },
    ["15a_top_closecombat"] = {
        NameChange = "Close-quarter DC-15a",
        VMBodygroups = {{ind = 7, bg = 2}},
    },
    ["15a_top_stabilizer"] = {
        NameChange = "DC-15le",
        VMBodygroups = {{ind = 8, bg = 1}},
    },
    ["15a_stock_short"] = {
        NameChange = "Skeleton DC-15a",
        VMBodygroups = {{ind = 10, bg = 1}},
    },
}

SWEP.Attachments = {
    [1] = {
        PrintName = "Long-Range Scope",
        DefaultAttName = "Standard", 
        Slot = "optic", 
        Bone = "dc-15a",
        Offset = {
            vpos = Vector(0, -2.2, 2.2),
            vang = Angle(90, 0, -90),
        },
        CorrectiveAng = Angle(0, 0, 0),
        CorrectivePos = Vector(0, 0, 0),
    },     
    [2] = {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "dc-15a",
        Offset = {
            vpos = Vector(00, -1.3, 30.5),
            vang = Angle(90, 0, -90),

        },
    },       
    [3] = {
        PrintName = "Barrel",
        DefaultAttName = "None",
        Slot = "15a_barrel",
    },   
    [4] = {
        PrintName = "Foregrip",
        DefaultAttName = "None",
        Slot = {"15a_foregrip", "foregrip"},
        Bone = "dc-15a",
        InstalledEles = {"15a_rangefinder"},
        Offset = {
            vpos = Vector(0.1, 0, 11),
            vang = Angle(90, 0, -90),

        },
    },  
    [5] = {
        PrintName = "Top",
        DefaultAttName = "None",
        Slot = "15a_top",
    },  
    [6] = {
        PrintName = "Mag",
        DefaultAttName = "None",
        Slot = {"dc15a_magazine_75"},
        Bone = "dc-15a",
        Offset = {
            vpos = Vector(-0.7, -0.6, 2.5),
            vang = Angle(0, 0, 0),
        },
    },  
    [7] = {
        PrintName = "Stock",
        DefaultAttName = "None",
        Slot = "15a_stock",
    },  
    [8] = {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = "uc_fg",
    },   
    [9] = {
        PrintName = "Ammo", 
        DefaultAttName = "Standard",
        Slot = "ammo",
    },
    [10] = {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    [11] = {
        PrintName = "Charms",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "dc-15a",
        Offset = {
            vpos = Vector(0.830, -1.83, 10.273),
            vang = Angle(90, 0, -90),
        },
    },    
    [12] = {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        Bone = "dc-15a",
        Offset = {
            vpos = Vector(0.830, -1.1, -1),
            vang = Angle(90, 0, -90),
        },
    },         
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "Idle"
    },
    ["fire"] = {
        Source = "shoot"
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "armasclasicas/wpn_empire_lgequip.wav",
                p = 100, 
                v = 75,
                t = 0, 
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "armasclasicas/wpn_empire_medequip.wav",
                p = 100,
                v = 75,
                t = 0,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "everfall/weapons/miscellaneous/reload/reset/overheatactivecoolingsuccess_var_03.mp3", t = 2.2 },
            {s = "everfall/weapons/miscellaneous/reload/overheat/overheat_overheated_large_var_03.mp3", t = 0.1 / 30},
        },
    },
}
--PATH addons/[bronie] republic-essentials-v2d/lua/weapons/masita_dc15s_stun.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 -- Change this if you want to select the weapon with other number

-- Trivia
SWEP.Category = "[ArcCW] Republic Essentials - Masita"
SWEP.Credits = "Kraken/Masita"
SWEP.PrintName = "Stun DC-15s"
SWEP.Trivia_Class = "Blaster Carabine"
SWEP.Trivia_Desc = "The DC-15A blaster carbine, also referred to as the DC-15S blaster, was a blaster carbine model used by the Grand Army of the Republic. It was part of the DC-15 family. While smaller than the larger DC-15A blaster rifle, both could be referred to as blaster rifles. It was one of the most common weapons issued to clone troopers during the Clone Wars and were used during many battles."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/masita/dc15s_stun.png"

-- Viewmodel & Entity Properties
SWEP.UseHands = true
SWEP.MirrorVMWM = true
SWEP.NoHideLeftHandInCustomization = true

SWEP.ViewModel = "models/servius/starwars/c_dc15s.mdl"
SWEP.WorldModel = "models/servius/starwars/w_dc15s.mdl"
SWEP.ViewModelFOV = 58
SWEP.WorldModelOffset = {
    pos = Vector(-9, 3.5, -4.5),
    ang = Angle(-10, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
}

-- Damage & Tracer
SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 1.6,
    [HITGROUP_CHEST] = 1.2,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 37
SWEP.RangeMin = 198
SWEP.DamageMin = 21
SWEP.Range = 399
SWEP.Penetration = 1.1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400
SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1
SWEP.TracerNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 250)
SWEP.HullSize = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 34

SWEP.Recoil = 0.67
SWEP.RecoilSide = 0.34
SWEP.RecoilRise = 0.53
SWEP.Delay = 60 / 255

SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 1
    },
    {
        Mode = 2
    },
    {
        Mode = 0
    },         
}

SWEP.AccuracyMOA = 0.5 
SWEP.HipDispersion = 490
SWEP.MoveDispersion = 60

-- Sounds & Muzzleflash
SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 125
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

SWEP.ShootSound = "armas/disparos/dc15s.wav"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 0, 250)

-- Ironsight & Holdtype
SWEP.IronSightStruct = {
    Pos = Vector(-2.837, 0.619, 1.656),
    Ang = Angle(0, 0, 0),
     Magnification = 1.3,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 55,
}

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "smg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SMG1

SWEP.ActivePos = Vector(0, 2, 0.5)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(7, 0, 0)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(10, -5, 1)
SWEP.CustomizeAng = Angle(15, 40, 30)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments 
SWEP.Attachments = {
    {
        PrintName = "Sight", 
        DefaultAttName = "Standard", 
        Slot = "optic",
        Bone = "DC15",
        Offset = {
            vpos = Vector(0, -1.6, -0.5),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Grip",
        DefaultAttName = "None",
        Slot = "foregrip",
        Bone = "DC15",
        Offset = {
            vpos = Vector(-0.101, 2.378, 6.164),
            vang = Angle(90, 0, -90),
        },
        SlideAmount = {
        vmin = Vector(-0.2, 0, 5.100),
        vmax = Vector(-0.2, 0, 9),
        },          
    },
    {
        PrintName = "Stock",
        DefaultAttName = "None",
        Bone = "DC15",
        Slot = "stock",
        Offset = {
            vpos = Vector(0, 0.5, -9.1),
            vang = Angle(0, 0, -90),
        },
    }, 
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.7, 0.7, 0.7),
        Bone = "DC15", 
        Offset = {
            vpos = Vector(0.8, -0.5, 10),
            vang = Angle(90, 0, 0),
        },
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "DC15",
        Offset = {
            vpos = Vector(0.1, -0.442, 11.638),
            vang = Angle(90, 0, -90),

        },
    },    
    {
        PrintName = "Ammo",
        DefaultAttName = "Standard",
        Slot = {"ammo", "sw_ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = "uc_fg",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "DC15",
        VMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(0.9, -0.7, 5.7),
            vang = Angle(90, 0, -90),
        },
    },     
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        Bone = "DC15",
        Offset = {
            vpos = Vector(0.8, -0.2, -5),
            vang = Angle(90, 0, -90),
        },
    },      
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = false,
    },
    ["fire"] = {
        Source = "fire"
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1.4,
        SoundTable = {
            {
                s = "w/dc15s/overheat_manualcooling_resetfoley_generic_var_01.mp3",
                p = 100,
                v = 75,
                t = 0,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "w/dc15s/gunfoley_blaster_sheathe_var_03.mp3",
                p = 100, 
                v = 75, 
                t = 0,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        SoundTable = {
            {s = "dc15s_1", t = 1.68 / 60},
            {s = "everfall/weapons/miscellaneous/reload/overheat/overheat_manualcooling_var_02.mp3", t = 0.1},
        },
    },

sound.Add({
    name =          "dc15s_1",
    channel =       CHAN_ITEM,
    volume =        1.5,
    sound =             "armasclasicas/wpn_empire_medreload.wav"
    }),

}
--PATH addons/[bronie] republic-essentials-v2d/lua/weapons/masita_dc17m.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/weapons/masita_iqa11.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/weapons/masita_iqa11.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 -- Change this if you want to select the weapon with other number

-- Trivia
SWEP.Category = "[ArcCW] Republic Essentials - Masita"
SWEP.Credits = "Kraken/Masita"
SWEP.PrintName = "IQA-11"
SWEP.Trivia_Class = "Blaster Sniper Rifle"
SWEP.Trivia_Desc = "The IQA-11 Blaster Rifle was a model of sniper rifle with a sleek and inexpensive design that made it a weapon of choice for mercenaries and bounty hunters who sought reliability over longer ranges. The rifle could receive modifications, such as an extended barrel and a dual zoom scope. During the Clone Wars, the bounty hunter Rumi Paramita used an IQA-11 while defending Felucian farmers from the Ohnaka Gang. A Mon Calamari also utilized the weapon during the Imperial Era."
SWEP.Trivia_Manufacturer = "Unknown"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/masita/iqa11.png"

SWEP.UseHands = true

SWEP.ViewModel = "models/servius/weapons/viewmodels/c_iqa11.mdl"
SWEP.WorldModel = "models/servius/weapons/worldmodels/w_iqa-11.mdl"
SWEP.ViewModelFOV = 70
SWEP.MirrorVMWM = false
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.009
}

SWEP.DefaultBodygroups = "000000000000"
-- Damage & Tracer
SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 150
SWEP.RangeMin = 200
SWEP.DamageMin = 63
SWEP.Range = 950
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400


SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tracer_red"
SWEP.TracerCol = Color(250, 0, 0)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 10

SWEP.Recoil = 1.2
SWEP.RecoilSide = 0.2
SWEP.RecoilRise = 0.18

SWEP.Delay = 60 / 210
SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 1
    },
    {
        Mode = 0
    },         
}

SWEP.AccuracyMOA = 0.1 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 530 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50

SWEP.NoFlash = nil -- disable light flash
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17_red"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(255, 0, 0)


-- Properties
SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 120
SWEP.ShootPitchVariation = 0.05
SWEP.ShootPitch = 70

SWEP.ShootSound = "armas/disparos/iqa11.mp3"
SWEP.ShootSoundSilenced = "armas/disparos/silenced_sniper.mp3"

SWEP.IronSightStruct = {
    Pos = Vector(-3.49, -3.547, 2.612),
    Ang = Angle(0, 0, 0),
     Magnification = 1.2,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 50,
}
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN
SWEP.ManualAction = true

SWEP.ActivePos = Vector(0, 0, 2)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(7, 0, -4)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(9.824, 2, -2.897)
SWEP.CustomizeAng = Angle(12.149, 30.547, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)


SWEP.DefaultElements = {}
SWEP.AttachmentElements = {}

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 1, 1)

SWEP.Bipod_Integral = true
SWEP.BipodDispersion = 1
SWEP.BipodRecoil = 1 

--SWEP.Attachments 
SWEP.DefaultElements = {"iqa11"}
SWEP.AttachmentElements = {
    ["iqa11"] = {
        WMElements = {
            {
                Model = "models/servius/weapons/viewmodels/c_iqa11.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1.1, 1.1, 1.1),
                WBodygroups = {{ind = 1, bg = 1}},
                Offset = {
                    pos = Vector(-800, 500, -500),
                    ang = Angle(-15, 0, 180)
                }
            },
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(4700, 80, -1500),
                    ang = Angle(0, 0, 100)
                },
                IsMuzzleDevice = true
            },
        },
    },
}
WMOverride = "models/servius/weapons/viewmodels/c_iqa11.mdl"
SWEP.Attachments = {
    {
        PrintName = "Sight", -- print name
        DefaultAttName = "Standard", -- used to display the "no attachment" text
        Slot = "optic",
        WMScale = Vector(111, 111, 111),
        Bone = "IQA11_mesh", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(0.032, -1.043, 1.723),
            vang = Angle(0, -90, 0),
            wpos = Vector(650, 85, -510),
            wang = Angle(-15, 0, 180)
        },
        CorrectiveAng = Angle(0, 180, 0),
        CorrectivePos = Vector(0, 0, 0),
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Standard",
        Slot = {"muzzle", "dlt19_muzzle", "dc15a_muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        WMScale = Vector(111, 111, 111),
        Bone = "IQA11_mesh",
        Offset = {
            vpos = Vector(0.059, 33.666, 0.86),
            vang = Angle(0, -90, 0),
            wpos = Vector(4700, 80, -1500),
            wang = Angle(-15, 0, -90)
        },
    },
    {
        PrintName = "Tactical", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = {"tactical","tac_pistol"},
        WMScale = Vector(111, 111, 111),
        Bone = "IQA11_mesh", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.7, 9.63, 1.113),
            vang = Angle(0, -90, 90),
            wpos = Vector(2000, 150, -750),
            wang = Angle(-15, 0, -90)
        },
    },    
    {
        PrintName = "Grip", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = {"foregrip", "bipod"},
        WMScale = Vector(111, 111, 111),
        Bone = "IQA11_mesh", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(-0.222, 9.911, 0),
            vang = Angle(0, -90, 0),
            wang = Angle(165, 180, 0),
        },
        SlideAmount = {
            vmin = Vector(-0, 9.9, 0),
            vmax = Vector(-0, 3.5, 0),
            wmin = Vector(1600, 80, -550), 
            wmax = Vector(1600, 80, -550)   -- how far this attachment can slide in both directions.
        },  
    }, 
    {
        PrintName = "Ammo", -- print name
        DefaultAttName = "Standard", -- used to display the "no attachment" text
        Slot = "ammo",
    },  
    {
        PrintName = "Perk", -- print name
        DefaultAttName = "Standard", -- used to display the "no attachment" text
        Slot = "perk",
    },
    {
        PrintName = "Charm", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = {"charm"},
        WMScale = Vector(111, 111, 111),
        Bone = "IQA11_mesh", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.546, -0.829, 0.085),
            vang = Angle(0, -90, 0),
            wpos = Vector(900, 145, -420),
            wang = Angle(-10 , 0, -180)
        },
    },          
}
SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["cycle"] = {
        Source = "Pump",
        SoundTable = {
                {s = "everfall/weapons/handling/reload_gentle/locknload/023d-00000922.mp3", t = 1 / 60},
        },
    },
    ["fire"] = {
        Source = "Shoot"
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "draw/gunfoley_blaster_dc17m_draw_var_03.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 100, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "holster/gunfoley_blaster_sheathe_var_04.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2, 
        SoundTable = {
            {s = "ArcCW_dp24.reload2", t = 4 / 30}, --s sound file
        },
    },


sound.Add({
    name =          "ArcCW_dp24.reload2",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "armasclasicas/wpn_republic_medreload.wav"
    }),
}
--PATH addons/[bronie] republic-essentials-v2d/lua/weapons/masita_sb2.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/entities/weapons/pocket/cl_menu.lua:
return gluapack()()
--PATH lua/weapons/sswep_mouse.lua:
if SERVER then AddCSLuaFile() end

if CLIENT then

	SWEP.PrintName		= "Mouse Droid SWEP"
	SWEP.Author			= "Benjita09"
	SWEP.Slot			= 0
	SWEP.SlotPos		= 1
	
end

SWEP.Category				= "Star Wars Sound SWEP"
SWEP.ViewModelFlip			= false
SWEP.ViewModelFOV			= 60

SWEP.Spawnable				= true
SWEP.AdminOnly				= false
SWEP.UseHands				= false

SWEP.ViewModel				= "models/weapons/c_arms_hev.mdl"
SWEP.WorldModel				= ""

SWEP.Weight			  		= 1
SWEP.AutoSwitchTo			= true
SWEP.AutoSwitchFrom			= true

SWEP.Primary.Recoil			= 0
SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic		= false
SWEP.Primary.Ammo		    = "none"
SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= false
SWEP.Secondary.Ammo			= "none"

function SWEP:Initialize()
	timer.Simple(0.2, function()
		self:SetHoldType("idle")
	end)
	self:SetHoldType("idle")
end


local a = "weapons/mouse/mousedroid1.mp3"
local b = "weapons/mouse/mousedroid2.mp3"
local c = "weapons/mouse/mousedroid3.mp3" 

function SWEP:PrimaryAttack()
	self:EmitSound(a)
end

function SWEP:SecondaryAttack()
	self:EmitSound(b)
end

function SWEP:Reload()
	self:EmitSound(c)
end

--PATH gamemodes/starwarsrp/entities/weapons/stunstick/shared.lua:
AddCSLuaFile()

if CLIENT then
    SWEP.Slot = 0
    SWEP.SlotPos = 5
    SWEP.RenderGroup = RENDERGROUP_BOTH

    killicon.AddAlias("stunstick", "weapon_stunstick")

    CreateMaterial("darkrp/stunstick_beam", "UnlitGeneric", {
        ["$basetexture"] = "sprites/lgtning",
        ["$additive"] = 1
    })
end

DEFINE_BASECLASS("stick_base")

SWEP.Instructions = "Left click to discipline\nRight click to kill\nHold reload to threaten"
SWEP.IsDarkRPStunstick = true

SWEP.PrintName = "Stun Stick"
SWEP.Spawnable = true
SWEP.Category = "DarkRP (Utility)"

SWEP.StickColor = Color(0, 0, 255)

function SWEP:Initialize()
    BaseClass.Initialize(self)

    self.Hit = {
        Sound("weapons/stunstick/stunstick_impact1.wav"),
        Sound("weapons/stunstick/stunstick_impact2.wav")
    }

    self.FleshHit = {
        Sound("weapons/stunstick/stunstick_fleshhit1.wav"),
        Sound("weapons/stunstick/stunstick_fleshhit2.wav")
    }
end

function SWEP:SetupDataTables()
    BaseClass.SetupDataTables(self)
    -- Float 0 = IronsightsTime
    -- Float 1 = LastPrimaryAttack
    -- Float 2 = ReloadEndTime
    -- Float 3 = BurstTime
    -- Float 4 = SeqIdleTime
    -- Float 5 = HoldTypeChangeTime
    self:NetworkVar("Float", 6, "LastReload")
end

function SWEP:Think()
    BaseClass.Think(self)
    if self.WaitingForAttackEffect and self:GetSeqIdleTime() ~= 0 and CurTime() >= self:GetSeqIdleTime() - 0.35 then
        self.WaitingForAttackEffect = false

        local Owner = self:GetOwner()

        local effectData = EffectData()
        effectData:SetOrigin(Owner:GetShootPos() + (Owner:EyeAngles():Forward() * 45))
        effectData:SetNormal(Owner:EyeAngles():Forward())
        util.Effect("StunstickImpact", effectData)
    end
end

function SWEP:DoFlash(ply)
    if not IsValid(ply) or not ply:IsPlayer() then return end

    ply:ScreenFade(SCREENFADE.IN, color_white, 1.2, 0)
end

local stunstickMaterial = Material("effects/stunstick")
local stunstickBeam     = Material("!darkrp/stunstick_beam")
local colorSprite       = Color(180, 180, 180)
function SWEP:PostDrawViewModel(vm)
    if self:GetSeqIdleTime() ~= 0 or self:GetLastReload() >= CurTime() - 0.1 then
        local attachment = vm:GetAttachment(1)
        local pos = attachment.Pos
        cam.Start3D(EyePos(), EyeAngles())
            render.SetMaterial(stunstickMaterial)
            render.DrawSprite(pos, 12, 12, colorSprite)
            for i = 1, 3 do
                local randVec = VectorRand() * 3
                local offset = (attachment.Ang:Forward() * randVec.x) + (attachment.Ang:Right() * randVec.y) + (attachment.Ang:Up() * randVec.z)
                render.SetMaterial(stunstickBeam)
                render.DrawBeam(pos, pos + offset, 3.25 - i, 1, 1.25, colorSprite)
                pos = pos + offset
            end
        cam.End3D()
    end
end

local light_glow02_add = Material("sprites/light_glow02_add")
function SWEP:DrawWorldModelTranslucent()
    if CurTime() <= self:GetLastReload() + 0.1 then
        local bone = self:GetOwner():LookupBone("ValveBiped.Bip01_R_Hand")
        if not bone then self:DrawModel() return end
        local bonePos, boneAng = self:GetOwner():GetBonePosition(bone)
        if bonePos then
            local pos = bonePos + (boneAng:Up() * -16) + (boneAng:Right() * 3) + (boneAng:Forward() * 6.5)
            render.SetMaterial(light_glow02_add)
            render.DrawSprite(pos, 32, 32, color_white)
        end
    end
    self:DrawModel()
end

local entMeta = FindMetaTable("Entity")
function SWEP:DoAttack(dmg)
    if CLIENT then return end

    local Owner = self:GetOwner()

    if not IsValid(Owner) then return end

    Owner:LagCompensation(true)
    local trace = util.QuickTrace(Owner:EyePos(), Owner:GetAimVector() * 90, {Owner})
    Owner:LagCompensation(false)

    local ent = trace.Entity
    if IsValid(ent) and ent.onStunStickUsed then
        ent:onStunStickUsed(Owner)
        return
    elseif IsValid(ent) and ent:GetClass() == "func_breakable_surf" then
        ent:Fire("Shatter")
        Owner:EmitSound(self.Hit[math.random(#self.Hit)])
        return
    end

    self.WaitingForAttackEffect = true

    ent = Owner:getEyeSightHitEntity(
        self.stickRange,
        15,
        fn.FAnd{
            fp{fn.Neq, Owner},
            fc{IsValid, entMeta.GetPhysicsObject},
            entMeta.IsSolid
        }
    )

    if not IsValid(ent) then return end
    if ent:IsPlayer() and not ent:Alive() then return end

    if not ent:isDoor() then
        ent:SetVelocity((ent:GetPos() - Owner:GetPos()) * 7)
    end

    if dmg > 0 then
        ent:TakeDamage(dmg, Owner, self)
    end

    if ent:IsPlayer() or ent:IsNPC() or ent:IsVehicle() then
        self:DoFlash(ent)
        Owner:EmitSound(self.FleshHit[math.random(#self.FleshHit)])
    else
        Owner:EmitSound(self.Hit[math.random(#self.Hit)])
        if FPP and FPP.plyCanTouchEnt(Owner, ent, "EntityDamage") then
            if ent.SeizeReward and not ent.beenSeized and not ent.burningup and Owner:isCP() and ent.Getowning_ent and Owner ~= ent:Getowning_ent() then
                local amount = isfunction(ent.SeizeReward) and ent:SeizeReward(Owner, dmg) or ent.SeizeReward

                Owner:addMoney(amount)
                DarkRP.notify(Owner, 1, 4, DarkRP.getPhrase("you_received_x", DarkRP.formatMoney(amount), DarkRP.getPhrase("bonus_destroying_entity")))
                ent.beenSeized = true
            end
            local health = math.max(ent:Health(), ent:GetMaxHealth())
            health = health == 0 and 1000 or health

            local dmgToTake = GAMEMODE.Config.stunstickdamage <= 1 and GAMEMODE.Config.stunstickdamage * health or GAMEMODE.Config.stunstickdamage
            -- Ceil because health is an integer value
            dmgToTake = math.max(0, math.ceil(dmgToTake - dmg))
            ent:TakeDamage(dmgToTake, Owner, self) -- for illegal entities
        end
    end
end

function SWEP:PrimaryAttack()
    BaseClass.PrimaryAttack(self)
    self:SetNextSecondaryFire(self:GetNextPrimaryFire())
    self:DoAttack(0)
end

function SWEP:SecondaryAttack()
    BaseClass.PrimaryAttack(self)
    self:SetNextSecondaryFire(self:GetNextPrimaryFire())
    self:DoAttack(10)
end

function SWEP:Reload()
    self:SetHoldType("melee")
    self:SetHoldTypeChangeTime(CurTime() + 0.1)

    if self:GetLastReload() + 0.1 > CurTime() then self:SetLastReload(CurTime()) return end
    self:SetLastReload(CurTime())
    self:EmitSound("weapons/stunstick/spark" .. math.random(1, 3) .. ".wav")
end

--PATH lua/weapons/tfa_gun_base/common/ttt.lua:
SWEP.HeadshotMultiplier = 2.7
SWEP.StoredAmmo = 0
SWEP.IsDropped = false
SWEP.DeploySpeed = 1.4
SWEP.fingerprints = {}

-- crosshair
if CLIENT then
	-- luacheck: globals LANG Key
	local SafeTranslation = function(x) return x end
	local GetPTranslation = LANG and LANG.GetParamTranslation or SafeTranslation

	-- Many non-gun weapons benefit from some help
	local help_spec = {
		text = "",
		font = "TabLarge",
		xalign = TEXT_ALIGN_CENTER
	}

	function SWEP:DrawHelp()
		local data = self.HUDHelp
		local translate = data.translatable
		local primary = data.primary
		local secondary = data.secondary

		if translate then
			primary = primary and GetPTranslation(primary, data.translate_params)
			secondary = secondary and GetPTranslation(secondary, data.translate_params)
		end

		help_spec.pos = {ScrW() / 2.0, ScrH() - 40}
		help_spec.text = secondary or primary
		draw.TextShadow(help_spec, 2)

		-- if no secondary exists, primary is drawn at the bottom and no top line
		-- is drawn
		if secondary then
			help_spec.pos[2] = ScrH() - 60
			help_spec.text = primary
			draw.TextShadow(help_spec, 2)
		end
	end

	local function SafeKey(binding, default)
		local b = input.LookupBinding(binding)
		if not b then return default end

		return string.upper(b)
	end

	local Key = Key or SafeKey

	-- mousebuttons are enough for most weapons
	local default_key_params = {
		primaryfire = Key("+attack", "LEFT MOUSE"),
		secondaryfire = Key("+attack2", "RIGHT MOUSE"),
		usekey = Key("+use", "USE")
	}

	function SWEP:AddHUDHelp(primary_text, secondary_text, translate, extra_params)
		extra_params = extra_params or {}

		self.HUDHelp = {
			primary = primary_text,
			secondary = secondary_text,
			translatable = translate,
			translate_params = table.Merge(extra_params, default_key_params)
		}
	end
end

function SWEP:GetHeadshotMultiplier(victim, dmginfo)
	return self.HeadshotMultiplier or 2
end

function SWEP:IsEquipment()
	-- luacheck: globals WEPS
	if WEPS and WEPS.IsEquipment then
		local val = WEPS.IsEquipment(self)

		if val ~= nil then
			return val
		else
			return false
		end
	else
		return false
	end
end

-- The OnDrop() hook is useless for this as it happens AFTER the drop. OwnerChange
-- does not occur when a drop happens for some reason. Hence this thing.
function SWEP:PreDrop()
	if not IsValid(self) then return end
	if not self.Ammo1 then return end

	if SERVER and IsValid(self:GetOwner()) and self.Primary_TFA.Ammo ~= "none" then
		local ammo = self:Ammo1()

		-- Do not drop ammo if we have another gun that uses this type
		for _, w in pairs(self:GetOwner():GetWeapons()) do
			if IsValid(w) and w ~= self and w:GetPrimaryAmmoType() == self:GetPrimaryAmmoType() then
				ammo = 0
			end
		end

		self.StoredAmmo = ammo

		if ammo > 0 then
			self:GetOwner():RemoveAmmo(ammo, self.Primary_TFA.Ammo)
		end
	end
end

function SWEP:DampenDrop()
	if not IsValid(self) then return end
	-- For some reason gmod drops guns on death at a speed of 400 units, which
	-- catapults them away from the body. Here we want people to actually be able
	-- to find a given corpse's weapon, so we override the velocity here and call
	-- this when dropping guns on death.
	local phys = self:GetPhysicsObject()

	if IsValid(phys) then
		phys:SetVelocityInstantaneous(Vector(0, 0, -75) + phys:GetVelocity() * 0.001)
		phys:AddAngleVelocity(phys:GetAngleVelocity() * -0.99)
	end
end

local SF_WEAPON_START_CONSTRAINED = 1

-- Picked up by player. Transfer of stored ammo and such.
function SWEP:EquipTTT(newowner)
	if engine.ActiveGamemode() ~= "terrortown" then return end

	if SERVER then
		if self:IsOnFire() then
			self:Extinguish()
		end

		self.fingerprints = self.fingerprints or {}

		if not table.HasValue(self.fingerprints, newowner) then
			table.insert(self.fingerprints, newowner)
		end

		if self:HasSpawnFlags(SF_WEAPON_START_CONSTRAINED) then
			-- If this weapon started constrained, unset that spawnflag, or the
			-- weapon will be re-constrained and float
			local flags = self:GetSpawnFlags()
			local newflags = bit.band(flags, bit.bnot(SF_WEAPON_START_CONSTRAINED))
			self:SetKeyValue("spawnflags", newflags)
		end
	end

	if not self.Ammo1 then return end

	if SERVER and IsValid(newowner) and self.StoredAmmo > 0 and self.Primary_TFA.Ammo ~= "none" then
		local ammo = newowner:GetAmmoCount(self.Primary_TFA.Ammo)
		self.Primary_TFA.ClipMax = self.Primary_TFA.ClipMax or (math.abs(self.Primary_TFA.ClipSize) * 4)
		local given = math.min(self.StoredAmmo, self.Primary_TFA.ClipMax - ammo)
		newowner:GiveAmmo(given, self.Primary_TFA.Ammo)
		self.StoredAmmo = 0
	end
end

-- We were bought as special equipment, some weapons will want to do something
-- extra for their buyer
function SWEP:WasBought(buyer)
end

function SWEP:DyingShot()
	local fired = false
	-- if self:GetIronSightsProgress() and self:GetIronSightsProgress() > 0.01  then
	self:SetIronSightsRaw(false)
	if self:GetNextPrimaryFire() > CurTime() then return fired end

	-- Owner should still be alive here
	if IsValid(self:GetOwner()) then
		local punch = self.Primary_TFA.Recoil or 5
		-- Punch view to disorient aim before firing dying shot
		local eyeang = self:GetOwner():EyeAngles()
		eyeang.pitch = eyeang.pitch - math.Rand(-punch, punch)
		eyeang.yaw = eyeang.yaw - math.Rand(-punch, punch)
		self:GetOwner():SetEyeAngles(eyeang)
		MsgN(self:GetOwner():Nick() .. " fired his DYING SHOT")
		self:GetOwner().dying_wep = self
		self:PrimaryAttack()
		fired = true
	end
	-- end

	return fired
end
--PATH lua/weapons/tfa_gun_base/client/laser.lua:
return gluapack()()
--PATH lua/weapons/tfa_nade_base.lua:
return gluapack()()
--PATH lua/weapons/tfa_swsft_base_servius/shared.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/entities/weapons/unarrest_stick/shared.lua:
return gluapack()()
--PATH lua/weapons/weapon_bactanade.lua:
AddCSLuaFile()

SWEP.VElements = {
	["element_name"] = { type = "Model", model = "models/riddickstuff/bactagrenade/bactanade.mdl", bone = "ValveBiped.Grenade_body", rel = "", pos = Vector(0, 0, 0), angle = Angle(0, 180, 0), size = Vector(0.69, 0.69, 0.69), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}
SWEP.WElements = {
	["element_name"] = { type = "Model", model = "models/riddickstuff/bactagrenade/bactanade.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(2.825, 2.743, 0), angle = Angle(0, -150.155, 0), size = Vector(0.82, 0.82, 0.82), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}
SWEP.HoldType = "grenade"
SWEP.ViewModelFOV = 50
SWEP.ViewModelFlip = false
SWEP.UseHands = true
SWEP.ViewModel = "models/weapons/c_grenade.mdl"
SWEP.WorldModel = "models/weapons/w_pistol.mdl"
SWEP.ShowViewModel = true
SWEP.ShowWorldModel = false
SWEP.ViewModelBoneMods = {
	["ValveBiped.Grenade_body"] = { scale = Vector(0.333, 0.333, 0.333), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_R_Forearm"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(18.888, -10, 43.333) }
}

SWEP.PrintName				= "Bacta Grenade"
SWEP.Author					= "robotboy655 & Riddick"
SWEP.Purpose			= "Once every fifteen seconds, Instantaneously heal a group of people by up to 50% of their max health!"

SWEP.Slot					= 5
SWEP.SlotPos				= 4

SWEP.Spawnable				= true

SWEP.Primary.ClipSize		= 200
SWEP.Primary.DefaultClip	= 200
SWEP.Primary.Automatic		= false
SWEP.Primary.Ammo			= "none"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= false
SWEP.Secondary.Ammo			= "none"


SWEP.HealAmount				= 100	-- initial heal amount
SWEP.MaxAmmo				= 200	-- Maxumum ammo


local HealSound = Sound( "HealthKit.Touch" )
local DenySound = Sound( "WallHealth.Deny" )

function SWEP:Initialize()
	
	self:SetHoldType( "grenade" )
	--self.Owner:GetViewModel( ):SetMaterial( "materials/reskin/healthkit01.vtf" )
	if ( CLIENT ) then 
		// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )
		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		// init view model bone build function
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				// Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end
			end
		end
		end 
	
	
	 

end

function SWEP:PrimaryAttack()

self.Weapon:SetNextPrimaryFire(CurTime() + 15)
self.Weapon:SendWeaponAnim( ACT_VM_THROW )
self.Owner:DoAttackEvent()
timer.Simple( 1, function() if IsValid( self.Owner ) then if self.Owner:Alive() then if self.Weapon == self.Owner:GetActiveWeapon() then self.Weapon:SendWeaponAnim( ACT_VM_DRAW ) end end end end )
//timer.Simple(1, function()self.Weapon:SendWeaponAnim(ACT_VM_DRAW) end)

//self.Owner:SetAnimation(ACT_PLAYER_ATTACK2)

if (SERVER) then
local ent = ents.Create ( "sent_bactagrenade" );
		ent:Spawn(); 
		ent:SetPos ( self.Owner:EyePos() + ( self.Owner:GetAimVector() * 16 ) );
		ent:SetAngles( self.Owner:EyeAngles() + Angle( 0, 0, 0 ) )
		ent:SetOwner( self.Owner )
		local phys = ent:GetPhysicsObject(); 
		phys:SetVelocity ( self.Owner:GetAimVector():GetNormalized() * 1000 )
//timer.Simple(0.157, function() if self:IsValid() then self:ThrowBactaGrenade() end end)
end

end

--[[
function SWEP:PrimaryAttack()

	if ( CLIENT ) then return end

	local tr = util.TraceLine( {
		start = self.Owner:GetShootPos(),
		endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * 128,
		filter = self.Owner
	} )

	local ent = tr.Entity
	
	local need = self.HealAmount
	if ( IsValid( ent ) ) then need = math.min( ent.var - ent:Health(), self.HealAmount ) end

	if ( IsValid( ent ) && self:Clip1() >= need && ( ent:IsPlayer() || ent:IsNPC() ) && ent:Health() < ent.var ) then

		self:TakePrimaryAmmo( need )

		ent:SetHealth( math.min( ent.var, ent:Health() + need ) )
		ent:EmitSound( HealSound )

		self:SendWeaponAnim( ACT_VM_PRIMARYATTACK )

		self:SetNextPrimaryFire( CurTime() + self:SequenceDuration() + 0 )
		self.Owner:SetAnimation( PLAYER_ATTACK1 )

		-- Even though the viewmodel has looping IDLE anim at all times, we need this to make fire animation work in multiplayer
		timer.Create( "weapon_idle" .. self:EntIndex(), self:SequenceDuration(), 1, function() if ( IsValid( self ) ) then self:SendWeaponAnim( ACT_VM_IDLE ) end end )
		
		timer.Simple(0.157, function() if self:IsValid() then self:ThrowBactaGrenade() end end)

	else

		self.Owner:EmitSound( DenySound )
		self:SetNextPrimaryFire( CurTime() + 1 )

	end

end
]]--

function SWEP:Reload()

return false
end

function SWEP:SecondaryAttack()

	return false

end

function SWEP:ThrowBactaGrenade()

	//Safeguard
	if !self || !self.Owner then return end

	//Create grenade
	local grenadeobj = ents.Create("sent_bactagrenade")
	grenadeobj:SetPos( self.Owner:GetShootPos() + Vector(0,0,-9.2) )
	grenadeobj:SetAngles( self.Owner:GetAimVector():Angle() )
	grenadeobj:SetPhysicsAttacker(self.Owner)
	grenadeobj:SetOwner(self.Owner)
	grenadeobj:Spawn()

	//Throw it
	grenadeobj:GetPhysicsObject():ApplyForceCenter( self.Owner:GetAimVector() * math.random(4620,4820) + Vector(0, 0, math.random(100,120)) )

	//Play throwing sound
	self.Owner:EmitSound( "weapons/ar2/ar2_reload_rotate.wav", 40, 100 )

end



function SWEP:OnRemove()

	timer.Stop( "medkit_ammo" .. self:EntIndex() )
	timer.Stop( "weapon_idle" .. self:EntIndex() )
	self:Holster()

end

function SWEP:Holster()
	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	

	timer.Stop( "weapon_idle" .. self:EntIndex() )
	
	return true

end

function SWEP:CustomAmmoDisplay()

	self.AmmoDisplay = self.AmmoDisplay or {} 
	self.AmmoDisplay.Draw = true
	self.AmmoDisplay.PrimaryClip = self:Clip1()

	return self.AmmoDisplay

end

if CLIENT then
	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)
		if (!self.vRenderOrder) then
			
			// we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}
			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end
		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then
				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()
			end
			
		end
		
	end
	/**************************
		Global utility code
	**************************/

	// Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	// Does not copy entities of course, only copies their reference.
	// WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy( tab )
		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end
	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then
			self.wRenderOrder = {}
			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end
		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			// when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then
				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()
			end
			
		end
		
	end
	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)
			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end
	function SWEP:CreateModels( tab )
		if (!tab) then return end
		// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			// !! WORKAROUND !! //
			// We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			// !! ----------- !! //
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				// !! WORKAROUND !! //
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				// !! ----------- !! //
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

--PATH addons/[bronie] kajdanki/lua/weapons/weapon_cuff_base.lua:
-------------------------------------
---------------- Cuffs --------------
-------------------------------------
-- Copyright (c) 2015 Nathan Healy --
-------- All rights reserved --------
-------------------------------------
-- weapon_cuff_base.lua     SHARED --
--                                 --
-- Base swep for handcuffs.        --
-------------------------------------

AddCSLuaFile()

SWEP.Base = "weapon_base"

SWEP.Category = "Handcuffs"
SWEP.Author = "my_hat_stinks"
SWEP.Instructions = ""

SWEP.Spawnable = false
SWEP.AdminOnly = false
SWEP.AdminSpawnable = false

SWEP.Slot = 3
SWEP.PrintName = "UnnamedHandcuff"

SWEP.ViewModelFOV = 60
SWEP.Weight = 5
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false

SWEP.WorldModel = "models/weapons/w_toolgun.mdl"
SWEP.ViewModel = "models/weapons/c_bugbait.mdl"
SWEP.UseHands = true

SWEP.Primary.Recoil = 1
SWEP.Primary.Damage = 5
SWEP.Primary.NumShots = 1
SWEP.Primary.Cone = 0
SWEP.Primary.Delay = 0.25

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "none"
SWEP.Primary.ClipMax = -1

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"
SWEP.Secondary.ClipMax = -1

SWEP.DeploySpeed = 1.5

SWEP.Spawnable = false
SWEP.AdminSpawnable = false
SWEP.AdminOnly = false

SWEP.PrimaryAnim = ACT_VM_PRIMARYATTACK
SWEP.ReloadAnim = ACT_VM_RELOAD
SWEP.HoldType = "slam"

SWEP.Spawnable = false
SWEP.AdminSpawnable = false
SWEP.AdminOnly = false

//
// Handcuff Vars
SWEP.CuffTime = 1.0 // Seconds to handcuff
SWEP.CuffSound = Sound( "buttons/lever7.wav" )

SWEP.CuffMaterial = "phoenix_storms/metalfloor_2-3"
SWEP.CuffRope = "cable/cable2"

SWEP.CuffStrength = 1
SWEP.CuffRegen = 1
SWEP.RopeLength = 0

SWEP.CuffReusable = false // Can reuse (ie, not removed on use)
SWEP.CuffRecharge = 1 // Time before re-use

SWEP.CuffBlindfold = false
SWEP.CuffGag = false

SWEP.CuffStrengthVariance = 0 // Randomise strangth
SWEP.CuffRegenVariance = 0 // Randomise regen

if SERVER then

	hook.Add("PlayerUse", "NoUseHeheheh", function(ply)
	
		if ply:IsHandcuffed() then return false end
	
	end)



end

//
// Network Vars
function SWEP:SetupDataTables()
	self:NetworkVar( "Bool", 0, "IsCuffing" )
	self:NetworkVar( "Entity", 0, "Cuffing" )
	self:NetworkVar( "Float", 0, "CuffTime" )
end

//
// Standard SWEP functions
function SWEP:PrimaryAttack()
	if self:GetIsCuffing() then return end
	
	self:SetNextPrimaryFire( CurTime() + self.Primary.Delay )
	self:SetNextSecondaryFire( CurTime() + self.Primary.Delay )
	
	if CLIENT then return end
	if self:GetCuffTime()>CurTime() then return end // On cooldown
	
	local tr = self:TargetTrace()
	if not tr then return end
	
	self:SetCuffTime( CurTime() + self.CuffTime )
	self:SetIsCuffing( true )
	self:SetCuffing( tr.Entity )
	
	sound.Play( self.CuffSound, self.Owner:GetShootPos(), 75, 100, 1 )
end
function SWEP:SecondaryAttack()
end
function SWEP:Reload()
end

function SWEP:Initialize()
	self:SetHoldType( self.HoldType )
	
	if engine.ActiveGamemode()=="dayz" then self.CuffReusable = false end
end
function SWEP:Holster()
	if CLIENT and IsValid(self.Owner) and self.Owner==LocalPlayer() then
		local vm = self.Owner:GetViewModel()
		if not IsValid(vm) then return end
		
		vm:SetMaterial( "" )
	end
	if IsValid(self.cmdl_RightCuff) then self.cmdl_RightCuff:Remove() end
	if IsValid(self.cmdl_LeftCuff) then self.cmdl_LeftCuff:Remove() end
	
	return true
end
SWEP.OnRemove = SWEP.Holster

//
// Handcuff
function SWEP:DoHandcuff( target )
	if not (target and IsValid(target)) then return end
	if target:IsHandcuffed() then return end
	if not IsValid(self.Owner) then return end
	
	local cuff = target:Give( "weapon_handcuffed" )
	cuff:SetCuffStrength( self.CuffStrength + (math.Rand(-self.CuffStrengthVariance,self.CuffStrengthVariance)) )
	cuff:SetCuffRegen( self.CuffRegen + (math.Rand(-self.CuffRegenVariance,self.CuffRegenVariance)) )
	
	cuff:SetCuffMaterial( self.CuffMaterial )
	cuff:SetRopeMaterial( self.CuffRope )
	
	cuff:SetKidnapper( self.Owner )
	cuff:SetRopeLength( self.RopeLength )
	
	cuff:SetCanBlind( self.CuffBlindfold )
	cuff:SetCanGag( self.CuffGag )
	
	cuff.CuffType = self:GetClass() or ""
	
	hook.Call( "OnHandcuffed", GAMEMODE, self.Owner, target, cuff )
	
	if not self.CuffReusable then
		if IsValid(self.Owner) then self.Owner:ConCommand( "lastinv" ) end
		self:Remove()
	end
end

//
// Think
function SWEP:Think()
	if SERVER then
		if self:GetIsCuffing() then
			local tr = self:TargetTrace()
			if (not tr) or tr.Entity~=self:GetCuffing() then
				self:SetIsCuffing(false)
				self:SetCuffTime( 0 )
				return
			end
			
			if CurTime()>self:GetCuffTime() then
				self:SetIsCuffing( false )
				self:SetCuffTime( CurTime() + self.CuffRecharge )
				self:DoHandcuff( self:GetCuffing() )
			end
		end
	end
end

//
// Get Target
function SWEP:TargetTrace()
	if not IsValid(self.Owner) then return end
	
	local tr = util.TraceLine( {start=self.Owner:GetShootPos(), endpos=(self.Owner:GetShootPos() + (self.Owner:GetAimVector()*50)), filter={self, self.Owner}} )
	if IsValid(tr.Entity) and tr.Entity:IsPlayer() and tr.Entity~=self.Owner and not tr.Entity:IsHandcuffed() then
		if hook.Run( "CuffsCanHandcuff", self.Owner, tr.Entity )==false then return end
		return tr
	end
end

//
// HUD
local Col = {
	Text = Color(255,255,255), TextShadow = Color(0,0,0),
	
	BoxOutline = Color(0,0,0), BoxBackground = Color(255,255,255,20), BoxLeft = Color(255,0,0), BoxRight = Color(0,255,0),
}
local matGrad = Material( "gui/gradient" )
function SWEP:DrawHUD()
	if not self:GetIsCuffing() then
		if self:GetCuffTime()<=CurTime() then return end
		
		local w,h = (ScrW()/2), (ScrH()/2)
		
		surface.SetDrawColor( Col.BoxOutline )
		surface.DrawOutlinedRect( w-101, h+54, 202, 22 )
		surface.SetDrawColor( Col.BoxBackground )
		surface.DrawRect( w-100, h+55, 200, 20 )
		
		local CuffingPercent = math.Clamp( ((self:GetCuffTime()-CurTime())/self.CuffRecharge), 0, 1 )
		render.SetScissorRect( w-100, h+55, (w-100)+(CuffingPercent*200), h+75, true )
			surface.SetDrawColor( Col.BoxRight )
			surface.DrawRect( w-100,h+55, 200,20 )
			
			surface.SetMaterial( matGrad )
			surface.SetDrawColor( Col.BoxLeft )
			surface.DrawTexturedRect( w-100,h+55, 200,20 )
		render.SetScissorRect( 0,0,0,0, false )
		
		return
	end
	
	local w,h = (ScrW()/2), (ScrH()/2)
	
	draw.SimpleText( "Unieszkodliwanie celu...", "HandcuffsText", w+1, h+31, Col.TextShadow, TEXT_ALIGN_CENTER )
	draw.SimpleText( "Unieszkodliwanie celu...", "HandcuffsText", w, h+30, Col.Text, TEXT_ALIGN_CENTER )
	
	surface.SetDrawColor( Col.BoxOutline )
	surface.DrawOutlinedRect( w-101, h+54, 202, 22 )
	surface.SetDrawColor( Col.BoxBackground )
	surface.DrawRect( w-100, h+55, 200, 20 )
	
	local CuffingPercent = math.Clamp( 1-((self:GetCuffTime()-CurTime())/self.CuffTime), 0, 1 )
	
	render.SetScissorRect( w-100, h+55, (w-100)+(CuffingPercent*200), h+75, true )
		surface.SetDrawColor( Col.BoxRight )
		surface.DrawRect( w-100,h+55, 200,20 )
		
		surface.SetMaterial( matGrad )
		surface.SetDrawColor( Col.BoxLeft )
		surface.DrawTexturedRect( w-100,h+55, 200,20 )
	render.SetScissorRect( 0,0,0,0, false )
end

//
// Rendering
local renderpos = {
	left = {pos=Vector(0,0,0), vel=Vector(0,0,0), gravity=1, ang=Angle(0,30,90)},
	right = {bone = "ValveBiped.Bip01_R_Hand", pos=Vector(3.2,2.1,0.4), ang=Angle(-2,0,80), scale = Vector(0.045,0.045,0.03)},
	rope = {l = Vector(0,0,2.0), r = Vector(2.3,-1.9,2.7)},
}
local CuffMdl = "models/hunter/tubes/tube2x2x1.mdl"
local RopeCol = Color(255,255,255)
function SWEP:ViewModelDrawn( vm )
	if not IsValid(vm) then return end
	
	vm:SetMaterial( "engine/occlusionproxy" )
	
	if not IsValid(self.cmdl_LeftCuff) then
		self.cmdl_LeftCuff = ClientsideModel( CuffMdl, RENDER_GROUP_VIEW_MODEL_OPAQUE )
		self.cmdl_LeftCuff:SetNoDraw( true )
		self.cmdl_LeftCuff:SetParent( vm )
		
		renderpos.left.pos = self.Owner:GetPos()
	end
	if not IsValid(self.cmdl_RightCuff) then
		self.cmdl_RightCuff = ClientsideModel( CuffMdl, RENDER_GROUP_VIEW_MODEL_OPAQUE )
		self.cmdl_RightCuff:SetNoDraw( true )
		self.cmdl_RightCuff:SetParent( vm )
	end
	
	-- local lpos, lang = self:GetBonePos( renderpos.left.bone, vm )
	local rpos, rang = self:GetBonePos( renderpos.right.bone, vm )
	if not (rpos and rang) then return end
	
	// Right
	local fixed_rpos = rpos + (rang:Forward()*renderpos.right.pos.x) + (rang:Right()*renderpos.right.pos.y) + (rang:Up()*renderpos.right.pos.z)
	self.cmdl_RightCuff:SetPos( fixed_rpos )
	local u,r,f = rang:Up(), rang:Right(), rang:Forward() // Prevents moving axes
	rang:RotateAroundAxis( u, renderpos.right.ang.y )
	rang:RotateAroundAxis( r, renderpos.right.ang.p )
	rang:RotateAroundAxis( f, renderpos.right.ang.r )
	self.cmdl_RightCuff:SetAngles( rang )
	
	local matrix = Matrix()
	matrix:Scale( renderpos.right.scale )
	self.cmdl_RightCuff:EnableMatrix( "RenderMultiply", matrix )
	
	self.cmdl_RightCuff:SetMaterial( self.CuffMaterial )
	self.cmdl_RightCuff:DrawModel()
	
	// Left
	if CurTime()>(renderpos.left.NextThink or 0) then
		local dist = renderpos.left.pos:Distance( fixed_rpos )
		if dist>100 then
			renderpos.left.pos = fixed_rpos
			renderpos.left.vel = Vector(0,0,0)
		elseif dist > 10 then
			local target = (fixed_rpos - renderpos.left.pos)*0.3
			renderpos.left.vel.x = math.Approach( renderpos.left.vel.x, target.x, 1 )
			renderpos.left.vel.y = math.Approach( renderpos.left.vel.y, target.y, 1 )
			renderpos.left.vel.z = math.Approach( renderpos.left.vel.z, target.z, 3 )
		end
		
		renderpos.left.vel.x = math.Approach( renderpos.left.vel.x, 0, 0.5 )
		renderpos.left.vel.y = math.Approach( renderpos.left.vel.y, 0, 0.5 )
		renderpos.left.vel.z = math.Approach( renderpos.left.vel.z, 0, 0.5 )
		-- if renderpos.left.vel:Length()>10 then renderpos.left.vel:Mul(0.1) end
		
		local targetZ = ((fixed_rpos.z - 10) - renderpos.left.pos.z) * renderpos.left.gravity
		renderpos.left.vel.z = math.Approach( renderpos.left.vel.z, targetZ, 3 )
		
		renderpos.left.pos:Add( renderpos.left.vel )
		
		-- renderpos.left.NextThink = CurTime()+0.01
	end
	
	self.cmdl_LeftCuff:SetPos( renderpos.left.pos )
	self.cmdl_LeftCuff:SetAngles( renderpos.left.ang )
	
	-- self.cmdl_LeftCuff:SetAngles( rang )
	local matrix = Matrix()
	matrix:Scale( renderpos.right.scale )
	self.cmdl_LeftCuff:EnableMatrix( "RenderMultiply", matrix )
	
	self.cmdl_LeftCuff:SetMaterial( self.CuffMaterial )
	self.cmdl_LeftCuff:DrawModel()
	
	// Rope
	if not self.RopeMat then self.RopeMat = Material(self.CuffRope) end
	
	render.SetMaterial( self.RopeMat )
	render.DrawBeam( renderpos.left.pos + renderpos.rope.l,
		rpos + (rang:Forward()*renderpos.rope.r.x) + (rang:Right()*renderpos.rope.r.y) + (rang:Up()*renderpos.rope.r.z),
		0.7, 0, 5, RopeCol )
end

SWEP.wrender = {
	left = {pos=Vector(0,0,0), vel=Vector(0,0,0), gravity=1, ang=Angle(0,30,90)},
	right = {bone = "ValveBiped.Bip01_R_Hand", pos=Vector(2.95,2.5,-0.2), ang=Angle(30,0,90), scale = Vector(0.044,0.044,0.044)},
	rope = {l = Vector(0,0,2), r = Vector(3,-1.65,1)},
}
function SWEP:DrawWorldModel()
	if not IsValid(self.Owner) then return end
	local wrender = self.wrender
	
	if not IsValid(self.cmdl_LeftCuff) then
		self.cmdl_LeftCuff = ClientsideModel( CuffMdl, RENDER_GROUP_VIEW_MODEL_OPAQUE )
		self.cmdl_LeftCuff:SetNoDraw( true )
	end
	if not IsValid(self.cmdl_RightCuff) then
		self.cmdl_RightCuff = ClientsideModel( CuffMdl, RENDER_GROUP_VIEW_MODEL_OPAQUE )
		self.cmdl_RightCuff:SetNoDraw( true )
	end
	
	local rpos, rang = self:GetBonePos( wrender.right.bone, self.Owner )
	if not (rpos and rang) then return end
	
	// Right
	local fixed_rpos = rpos + (rang:Forward()*wrender.right.pos.x) + (rang:Right()*wrender.right.pos.y) + (rang:Up()*wrender.right.pos.z)
	self.cmdl_RightCuff:SetPos( fixed_rpos )
	local u,r,f = rang:Up(), rang:Right(), rang:Forward() // Prevents moving axes
	rang:RotateAroundAxis( u, wrender.right.ang.y )
	rang:RotateAroundAxis( r, wrender.right.ang.p )
	rang:RotateAroundAxis( f, wrender.right.ang.r )
	self.cmdl_RightCuff:SetAngles( rang )
	
	local matrix = Matrix()
	matrix:Scale( wrender.right.scale )
	self.cmdl_RightCuff:EnableMatrix( "RenderMultiply", matrix )
	
	self.cmdl_RightCuff:SetMaterial( self.CuffMaterial )
	self.cmdl_RightCuff:DrawModel()
	
	// Left
	if CurTime()>(wrender.left.NextThink or 0) then
		local dist = wrender.left.pos:Distance( fixed_rpos )
		if dist>100 then
			wrender.left.pos = fixed_rpos
			wrender.left.vel = Vector(0,0,0)
		elseif dist > 10 then
			local target = (fixed_rpos - wrender.left.pos)*0.3
			wrender.left.vel.x = math.Approach( wrender.left.vel.x, target.x, 1 )
			wrender.left.vel.y = math.Approach( wrender.left.vel.y, target.y, 1 )
			wrender.left.vel.z = math.Approach( wrender.left.vel.z, target.z, 3 )
		end
		
		wrender.left.vel.x = math.Approach( wrender.left.vel.x, 0, 0.5 )
		wrender.left.vel.y = math.Approach( wrender.left.vel.y, 0, 0.5 )
		wrender.left.vel.z = math.Approach( wrender.left.vel.z, 0, 0.5 )
		-- if wrender.left.vel:Length()>10 then wrender.left.vel:Mul(0.1) end
		
		local targetZ = ((fixed_rpos.z - 10) - wrender.left.pos.z) * wrender.left.gravity
		wrender.left.vel.z = math.Approach( wrender.left.vel.z, targetZ, 3 )
		
		wrender.left.pos:Add( wrender.left.vel )
		
		-- wrender.left.NextThink = CurTime()+0
	end
	
	self.cmdl_LeftCuff:SetPos( wrender.left.pos )
	self.cmdl_LeftCuff:SetAngles( wrender.left.ang )
	
	local matrix = Matrix()
	matrix:Scale( wrender.right.scale )
	self.cmdl_LeftCuff:EnableMatrix( "RenderMultiply", matrix )
	
	self.cmdl_LeftCuff:SetMaterial( self.CuffMaterial )
	self.cmdl_LeftCuff:DrawModel()
	
	// Rope
	if not self.RopeMat then self.RopeMat = Material(self.CuffRope) end
	
	render.SetMaterial( self.RopeMat )
	render.DrawBeam( wrender.left.pos + wrender.rope.l,
		rpos + (rang:Forward()*wrender.rope.r.x) + (rang:Right()*wrender.rope.r.y) + (rang:Up()*wrender.rope.r.z),
		0.7, 0, 5, RopeCol )
end

//
// Bones
function SWEP:GetBonePos( bonename, vm )
	local bone = vm:LookupBone( bonename )
	if not bone then return end
	
	local pos,ang = Vector(0,0,0),Angle(0,0,0)
	local matrix = vm:GetBoneMatrix( bone )
	if matrix then
		pos = matrix:GetTranslation()
		ang = matrix:GetAngles()
	end
	
	if self.ViewModelFlip then ang.r = -ang.r end
	
	-- if pos.x==0 and pos.y==0 and pos.z==0 then print( bonename, vm ) end
	return pos, ang
end

--PATH addons/[bronie] kajdanki/lua/weapons/weapon_cuff_tactical.lua:
-------------------------------------
---------------- Cuffs --------------
-------------------------------------
-- Copyright (c) 2015 Nathan Healy --
-------- All rights reserved --------
-------------------------------------
-- weapon_cuff_tactical.lua SHARED --
--                                 --
-- Quick-restraint handcuffs.      --
-------------------------------------

AddCSLuaFile()

SWEP.Base = "weapon_cuff_base"

SWEP.Category = "Handcuffs"
SWEP.Author = "my_hat_stinks"
SWEP.Instructions = "Fast-action but weak restraint."

SWEP.Spawnable = true
SWEP.AdminOnly = true
SWEP.AdminSpawnable = true

SWEP.Slot = 3
SWEP.PrintName = "Tactical Restraint"

//
// Handcuff Vars
SWEP.CuffTime = 0.1 // Seconds to handcuff
SWEP.CuffSound = Sound( "buttons/lever7.wav" )

SWEP.CuffMaterial = "phoenix_storms/bluemetal"
SWEP.CuffRope = "cable/blue"
SWEP.CuffStrength = 0.55
SWEP.CuffRegen = 0.8
SWEP.RopeLength = 0

SWEP.CuffReusable = true
SWEP.CuffRecharge = 20 // Time before re-use

SWEP.CuffBlindfold = false
SWEP.CuffGag = false

SWEP.CuffStrengthVariance = 0.1 // Randomise strangth
SWEP.CuffRegenVariance = 0.3 // Randomise regen

--PATH lua/weapons/weapon_fireballoon/shared.lua:
if (SERVER) then --the init.lua stuff goes in here
 
   AddCSLuaFile ("shared.lua");
 
   SWEP.Weight = 5;
   SWEP.AutoSwitchTo = false;
   SWEP.AutoSwitchFrom = false;
 
end
 
if (CLIENT) then --the cl_init.lua stuff goes in here
 
   SWEP.PrintName = "Fire Balloons";
   SWEP.Slot = 4;
   SWEP.SlotPos = 4;
   SWEP.DrawAmmo = true;
   SWEP.DrawCrosshair = false;
 
end

SWEP.Instructions = "Left click throws fire balloons, these extinguish fires. Right click to rapid fire balloons.";
SWEP.Category = "Sgt. Ownage"
 
SWEP.Spawnable = true;
SWEP.AdminSpawnable = false;
 
SWEP.ViewModel = "models/weapons/c_bugbait.mdl";
SWEP.WorldModel = "models/weapons/w_bugbait.mdl";
SWEP.ViewModelFOV = 54
SWEP.HoldType = "grenade"
SWEP.UseHands = true
SWEP.ShowViewModel = true
SWEP.ShowWorldModel = false
SWEP.ViewModelBoneMods = {
    ["ValveBiped.cube3"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(-30, 0, 0), angle = Angle(0, 0, 0) }
}

SWEP.Primary.ClipSize = 100;
SWEP.Primary.DefaultClip = 100;
SWEP.Primary.Automatic = false;
SWEP.Primary.Ammo = "balloons";
SWEP.Primary.Delay = 0.75


SWEP.Secondary.ClipSize = -1;
SWEP.Secondary.DefaultClip = -1;
SWEP.Secondary.Automatic = true;
SWEP.Secondary.Ammo = "none";
SWEP.Secondary.Delay = 0

function SWEP:Reload()
	return false
end

function SWEP:Think()
	if CLIENT then
		if self.Weapon:GetNWBool("HideBalloon", false) then
			self.Weapon.VElements["balloon_view"].color = Color( 0, 0, 0, 0)
			self.Weapon.WElements["balloon_world"].color = Color( 0, 0, 0, 0)
		else
			self.Weapon.VElements["balloon_view"].color = Color( 0, 0, 0, 255)
			self.Weapon.WElements["balloon_world"].color = Color( 0, 0, 0, 255)
		end
	end
	
	if self.Owner:KeyDown(1) then
		if self.Weapon:Clip1() > 0 and self.Weapon:GetNextPrimaryFire() <= CurTime() and not self.Weapon:GetNWBool("HideBalloon", false) then
			self.Weapon:SendWeaponAnim( ACT_VM_HAULBACK )
			local p = self.Weapon:GetNWInt("Force", 0)
			self.Weapon:SetNWInt("Force", math.Clamp(p + 1, 0, 200))
			if p > 50 then
				EmitSound( Sound( "buttons/blip1.wav" ), self.Owner:GetPos(), 1, CHAN_AUTO, 1, 25, 0, p - 25 )
			end
		end
	end
	if self.Owner:KeyReleased(1) then
		if self.Weapon:Clip1() > 0 and self.Weapon:GetNextPrimaryFire() <= CurTime() and not self.Weapon:GetNWBool("HideBalloon", false) then
		self.Weapon:SetNextPrimaryFire(CurTime() + self.Primary.Delay * 1.25)
		self:SetClip1(self:Clip1() - 1)
			if SERVER then
				local balloon = ents.Create("ent_fballoon") 
				local vec = Vector(0, 0, 8)
				if self.Owner:Crouching() then vec = Vector(0, 0, 4) end
				balloon:SetPos((self.Owner:EyePos() - vec) + (self.Owner:GetForward() * 16)) 
				balloon:SetAngles(Angle(math.random(0, 360),math.random(0, 360),0))
				balloon:SetColor( Color(0, 0, 0, 255) )
				balloon:Spawn()
				local balloonphys = balloon:GetPhysicsObject()
				balloonphys:Wake()
				--print(self.Weapon:GetNWInt("Force", 0))
				balloonphys:SetVelocity(self.Owner:GetAimVector():GetNormalized() * 50 * (10 + self.Weapon:GetNWInt("Force", 0)))
				self.Weapon:SetNWInt("Force", 0)
				balloonphys:SetBuoyancyRatio( 0.03 )
				self.Owner:SetAnimation( PLAYER_ATTACK1 )
				self.Weapon:SendWeaponAnim(ACT_VM_IDLE)
				self.Weapon:SetNWBool("HideBalloon", true)
				timer.Simple(0.1, function() if not IsValid(self) or not IsValid(self.Owner) then return end self.Weapon:SendWeaponAnim( ACT_VM_THROW ) end) 
				timer.Simple(0.5, function() if not IsValid(self) or not IsValid(self.Owner) then return end self.Weapon:SetNWBool("HideBalloon", false) self.Weapon:SendWeaponAnim(ACT_VM_DRAW) end)
				if self.Weapon:Clip1() <= 0 then
					self.Owner:StripWeapon("weapon_fireballoon")
				end
			end
		end
	end
	--return false
end

function SWEP:PrimaryAttack()
	return false
end

function SWEP:SecondaryAttack()
	if self.Weapon:Clip1() > 0 and self.Weapon:GetNextPrimaryFire() <= CurTime() and not self.Weapon:GetNWBool("HideBalloon", false) then
		self.Weapon:SetNextPrimaryFire(CurTime() + self.Primary.Delay )
		self:SetClip1(self:Clip1() - 1)
			if SERVER then
				local balloon = ents.Create("ent_fballoon") 
				local vec = Vector(0, 0, 8)
				if self.Owner:Crouching() then vec = Vector(0, 0, 4) end
				balloon:SetPos((self.Owner:EyePos() - vec) + (self.Owner:GetForward() * 16)) 
				balloon:SetAngles(Angle(math.random(0, 360),math.random(0, 360),0))
				balloon:SetColor( Color(0, 0, 0, 255) )
				balloon:Spawn()
				local balloonphys = balloon:GetPhysicsObject()
				balloonphys:Wake()
				balloonphys:SetVelocity(self.Owner:GetAimVector():GetNormalized() * 1000)
				balloonphys:SetBuoyancyRatio( 0.03 )
				self.Owner:SetAnimation( PLAYER_ATTACK1 )
				self.Weapon:SendWeaponAnim( ACT_VM_THROW )
				self.Weapon:SetNWBool("HideBalloon", true)
				timer.Simple(0.5, function() if not IsValid(self) or not IsValid(self.Owner) then return end self.Weapon:SetNWBool("HideBalloon", false) self.Weapon:SendWeaponAnim(ACT_VM_IDLE) end)
				if self.Weapon:Clip1() <= 0 then
					self.Owner:StripWeapon("weapon_fireballoon")
				end
			end
		return true
	end
end

/********************************************************
	SWEP Construction Kit base code
		Created by Clavus
	Available for public use, thread at:
	   facepunch.com/threads/1032378
	   
	   
	DESCRIPTION:
		This script is meant for experienced scripters 
		that KNOW WHAT THEY ARE DOING. Don't come to me 
		with basic Lua questions.
		
		Just copy into your SWEP or SWEP base of choice
		and merge with your own code.
		
		The SWEP.VElements, SWEP.WElements and
		SWEP.ViewModelBoneMods tables are all optional
		and only have to be visible to the client.
********************************************************/

function SWEP:Initialize()

self:SetHoldType(self.HoldType)

	if CLIENT then
	
		// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		// init view model bone build function
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				// Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end
			end
		end
		
	end

end

function SWEP:Holster()
	
	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	
	return true
end

function SWEP:OnRemove()
	self:Holster()
end

if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			// we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			// when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			// !! WORKAROUND !! //
			// We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			// !! ----------- !! //
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				// !! WORKAROUND !! //
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				// !! ----------- !! //
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

	/**************************
		Global utility code
	**************************/

	// Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	// Does not copy entities of course, only copies their reference.
	// WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end

SWEP.VElements = {
	["balloon_view"] = { type = "Model", model = "models/maxofs2d/balloon_classic.mdl", bone = "ValveBiped.cube", rel = "", pos = Vector(-9.87, -7.792, 28.57), angle = Angle(3.506, 8.182, 68.96), size = Vector(0.5, 0.5, 0.4), color = Color(0,0,0,255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}
SWEP.WElements = {
    ["balloon_world"] = { type = "Model", model = "models/maxofs2d/balloon_classic.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(2.596, 3.635, -5.715), angle = Angle(0, 0, 0), size = Vector(0.5, 0.5, 0.4), color = Color(0,0,0,255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}
--PATH gamemodes/starwarsrp/entities/weapons/weapon_glock2/shared.lua:
AddCSLuaFile()

if CLIENT then
    SWEP.Author = "DarkRP Developers"
    SWEP.Instructions = "Shoot with it"
    SWEP.Slot = 1
    SWEP.SlotPos = 0
    SWEP.IconLetter = "c"

    killicon.AddFont("weapon_glock2", "CSKillIcons", SWEP.IconLetter, Color(255, 80, 0, 255))
end

SWEP.Base = "weapon_cs_base2"

SWEP.PrintName = "Glock"
SWEP.Spawnable = true
SWEP.AdminOnly = false
SWEP.Category = "DarkRP (Weapon)"

SWEP.ViewModel = "models/weapons/cstrike/c_pist_glock18.mdl"
SWEP.WorldModel = "models/weapons/w_pist_glock18.mdl"
SWEP.HoldType = "pistol"
SWEP.LoweredHoldType = "normal"

SWEP.Weight = 5
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false

SWEP.Primary.Sound = Sound("Weapon_Glock.Single")
SWEP.Primary.Recoil = 2
SWEP.Primary.Unrecoil = 6
SWEP.Primary.Damage = 10
SWEP.Primary.NumShots = 1
SWEP.Primary.Cone = 0.05
SWEP.Primary.ClipSize = 20
SWEP.Primary.Delay = 0.06
SWEP.Primary.DefaultClip = 20
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "pistol"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

--Start of Firemode configuration
SWEP.IronSightsPos = Vector(-5.77, -6.6, 2.7)
SWEP.IronSightsAng = Vector(0.9, 0, 0)

--PATH lua/weapons/weapon_grapplehook_mk2.lua:
AddCSLuaFile()

CreateConVar("grapple_distance", -1, bit.bor(FCVAR_GAMEDLL, FCVAR_NOTIFY, FCVAR_SERVER_CAN_EXECUTE),"max distance which its allowed to fire")
CreateConVar("grapple_latch_speed", 5000, bit.bor(FCVAR_GAMEDLL, FCVAR_NOTIFY, FCVAR_SERVER_CAN_EXECUTE),"speed at which the rope flies to its target")
CreateConVar("grapple_speed_mk2", 1000, bit.bor(FCVAR_GAMEDLL, FCVAR_NOTIFY, FCVAR_SERVER_CAN_EXECUTE),"speed at which the player gets pulled to the destination")
CreateConVar("grapple_damage_min", 15, bit.bor(FCVAR_GAMEDLL, FCVAR_NOTIFY, FCVAR_SERVER_CAN_EXECUTE),"how much damage should it do minimal to hooked objects")
CreateConVar("grapple_damage_max", 25, bit.bor(FCVAR_GAMEDLL, FCVAR_NOTIFY, FCVAR_SERVER_CAN_EXECUTE),"how much damage should it do maximal to hooked objects")
CreateConVar("grapple_damage_enable", 1, bit.bor(FCVAR_GAMEDLL, FCVAR_NOTIFY, FCVAR_SERVER_CAN_EXECUTE),"should hooked objects take damage?")
CreateConVar("grapple_play_sounds", 1, bit.bor(FCVAR_GAMEDLL, FCVAR_NOTIFY, FCVAR_SERVER_CAN_EXECUTE),"should hooked objects and the weapon make sounds?")
CreateConVar("grapple_ignore_sky", 1, bit.bor(FCVAR_GAMEDLL, FCVAR_NOTIFY, FCVAR_SERVER_CAN_EXECUTE),"can the grapple hook onto the sky?")

if CLIENT then
	SWEP.DrawWeaponInfoBox	= false
	SWEP.BounceWeaponIcon	= false 

	killicon.Add("weapon_grapplehook_mk2","effects/killicons/weapon_grapplehook",Color(255,255,255))
	SWEP.WepSelectIcon	= surface.GetTextureID("hud/swepicons/weapon_grapplehook/icon")
end

SWEP.Author			= ""
SWEP.Contact		= ""
SWEP.Purpose		= "A Grappling Hook"
SWEP.Instructions	= "Left click to fire"

SWEP.Category			= "Team Fortress 2"
SWEP.PrintName			= "Grappling Hook MK2"
SWEP.Slot				= 3
SWEP.SlotPos			= 2
SWEP.DrawAmmo			= false
SWEP.DrawCrosshair		= true
SWEP.ViewModelFOV = 70
SWEP.ViewModelFlip = false
SWEP.UseHands = true
SWEP.ViewModel = "models/weapons/c_pistol.mdl"
SWEP.WorldModel = "models/weapons/w_pistol.mdl"
SWEP.ShowViewModel = true
SWEP.ShowWorldModel = true

SWEP.HoldType			= "pistol"

SWEP.Spawnable			= true
SWEP.AdminSpawnable		= true
SWEP.AdminOnly          = false

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

local sndGrappleHit		= Sound("weapons/grappling_hook_impact_default.wav")
local sndGrappleHitFlesh= Sound("weapons/grappling_hook_impact_flesh.wav")
local sndGrappleShoot	= Sound("weapons/grappling_hook_shoot.wav")
local sndGrappleReel	= Sound("weapons/grappling_hook_reel_start.wav")
local sndGrappleAbort	= Sound("weapons/grappling_hook_reel_stop.wav")

SWEP.ViewModelBoneMods = {
	["ValveBiped.Bip01_R_UpperArm"] = { scale = Vector(1, 1, 1), pos = Vector(9.892, -0.811, 2.532), angle = Angle(-10.782, -7.685, 14.444) },
	["ValveBiped.square"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.clip"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_L_UpperArm"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, -30), angle = Angle(0, 0, 0) }
}

SWEP.VElements = {
	["v_element"] = { type = "Model", model = "models/weapons/c_models/c_grappling_hook/c_grappling_hook.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3.032, 1.476, -1.58), angle = Angle(0, 0, 177.921), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["v_element2"] = { type = "Model", model = "models/props_c17/pulleywheels_large01.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(9.571, 3.808, -1.502), angle = Angle(-1.657, 89.515, 0), size = Vector(0.09, 0.15, 0.15), color = Color(255, 255, 255, 255), surpresslightning = false, material = "mm_materials/zinc01_low2", skin = 0, bodygroup = {} },
	["v_element3"] = { type = "Model", model = "models/props_c17/pulleywheels_large01.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(9.571, 3.808, -1.502), angle = Angle(-1.657, 89.515, 45), size = Vector(0.09, 0.15, 0.15), color = Color(255, 255, 255, 255), surpresslightning = false, material = "mm_materials/zinc01_low2", skin = 0, bodygroup = {} }
}

SWEP.WElements = {
	["w_element"] = { type = "Model", model = "models/weapons/c_models/c_grappling_hook/c_grappling_hook.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3.709, 1.886, -2), angle = Angle(0, 0, 180), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

function SWEP:Initialize()
	nextshottime = CurTime()
	self:SetHoldType(self.HoldType)
	self:SetWeaponHoldType(self.HoldType)
	self.zoomed = false
	self.initialhit = false
	self.Tr = nil
	
	self.Idle = 0
	self.IdleTimer = CurTime() + 1
	
	if CLIENT then
	
		-- Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )
        self:SetWeaponHoldType( self.HoldType )
		
		self:CreateModels(self.VElements) -- create viewmodels
		self:CreateModels(self.WElements) -- create worldmodels
		
		-- init view model bone build function
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				-- Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					-- we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					-- ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					-- however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end
			end
		end
		
	end

end

----------------------------------------------------
if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			-- we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				--model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			-- when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				--model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			

			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r -- Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				-- make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			-- !! WORKAROUND !! --
			-- We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			-- !! ----------- !! --
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				-- !! WORKAROUND !! --
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				-- !! ----------- !! --
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end


	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v)
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end
----------------------------------------------------

function SWEP:Deploy()
	self:SendWeaponAnim(ACT_VM_DRAW)

	
	self.Idle = 0
	self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
	return true
end

function SWEP:Think()
	if (!self.Owner || self.Owner == NULL) then return end
	
	if ( self.Owner:KeyPressed( IN_ATTACK ) ) then
		self:StartAttack()
		self.VElements["v_element"].material = "models/weapons/c_items/c_grappling_hook_alphatest"
	elseif ( self.Owner:KeyDown( IN_ATTACK ) && inRange ) then
		self:UpdateAttack()
	elseif ( self.Owner:KeyReleased( IN_ATTACK ) && inRange ) then
		self:EndAttack( true )
		self.VElements["v_element"].material = "models/weapons/c_items/c_grappling_hook2"
	end
	
	if self.Idle == 0 and self.IdleTimer <= CurTime() then
		if SERVER then
			self.Weapon:SendWeaponAnim( ACT_VM_IDLE )
		end
		self.Idle = 1
	end
end

function SWEP:DoTrace( endpos )
	local trace = {}
	trace.start = self.Owner:GetShootPos()
	trace.endpos = trace.start + (self.Owner:GetAimVector() * 32768) --14096 is length modifier.
	trace.mins = Vector(-2,-2,-2)
	trace.maxs = Vector(2,2,2)
	if(endpos) then trace.endpos = (endpos - self.Tr.HitNormal * 7) end
	trace.filter = { self.Owner, self.Weapon }
		
	self.Tr = nil
	self.Tr = util.TraceHull( trace )
end

function SWEP:StartAttack()
	-- Get begining and end poins of trace.
	local gunPos = self.Owner:GetShootPos() -- Start of distance trace.
	local disTrace = self.Owner:GetEyeTrace() -- Store all results of a trace in disTrace.
	local hitPos = disTrace.HitPos -- Stores Hit Position of disTrace.
	
	-- Calculate Distance
	-- Thanks to rgovostes for this code.
	local x = (gunPos.x - hitPos.x)^2;
	local y = (gunPos.y - hitPos.y)^2;
	local z = (gunPos.z - hitPos.z)^2;
	local distance = math.sqrt(x + y + z);
	
	-- Only latches if distance is less than distance CVAR, or CVAR negative
	local distanceCvar = GetConVarNumber("grapple_distance")
	inRange = false
	if distanceCvar < 0 or distance <= distanceCvar then
		inRange = true
	end
	
	if inRange then
		if (SERVER) then
			if (!self.Beam) then -- If the beam does not exist, draw the beam.
				-- grapple_beam
				self.Beam = ents.Create( "trace2" )
					self.Beam:SetPos( self.Owner:GetShootPos() )
				self.Beam:Spawn()
			end
			self.Beam:SetParent( self.Owner )
			self.Beam:SetOwner( self.Owner )
		end
		
		self:DoTrace()
		self.speed = GetConVarNumber("grapple_latch_speed") -- Rope latch speed. Was 3000.
		self.startTime = CurTime()
		self.endTime = CurTime() + self.speed
		self.dt = -1
		
		if (SERVER && self.Beam) then
			self.Beam:GetTable():SetEndPos( self.Tr.HitPos )
		end
		
		self:UpdateAttack()
		
		if GetConVarNumber("grapple_play_sounds") == 1 then
			self.Weapon:EmitSound( sndGrappleShoot,75 )
		end
	else
		if GetConVarNumber("grapple_play_sounds") == 1 then
			self.Weapon:EmitSound( sndGrappleAbort,70 )
		end
	end
end

function SWEP:UpdateAttack()
	if self.Tr == nil then return false end
	if !endpos then endpos = self.Tr.HitPos end

	if GetConVarNumber("grapple_ignore_sky") == 1 then
		if self.Tr.HitSky then self:EndAttack( false ) return false end
	end
	
	if (SERVER && self.Beam) then
		self.Beam:GetTable():SetEndPos( endpos )
	end

	lastpos = endpos
	
	if IsValid(self.Tr.Entity) then
		endpos = self.Tr.Entity:NearestPoint(self.Tr.HitPos)
		if SERVER then
			self.Beam:GetTable():SetEndPos( endpos )
			if GetConVarNumber("grapple_damage_enable") == 1 then
				if self.dt == 0 then
					if timer.TimeLeft( "hurtent" .. self:EntIndex() ) == nil then
						if self.Tr.Entity:IsPlayer() then
							if !self.Tr.Entity:Alive() then
								self:DoTrace()
							end
						end
						
						if self.Tr.Entity:IsNPC() then
							if self.Tr.Entity:Health() < 0 then
								self:DoTrace()
							end
						end
					
						local dmgInfo = DamageInfo()
						dmgInfo:SetAttacker(self.Owner)
						dmgInfo:SetInflictor(self)
						dmgInfo:SetDamageType(DMG_SLASH)
						dmgInfo:SetDamage(math.random(GetConVarNumber("grapple_damage_min"),GetConVarNumber("grapple_damage_max")))
						dmgInfo:SetDamagePosition(self.Tr.HitPos)
						dmgInfo:SetDamageForce(self.Owner:GetAimVector()*-5000)
						self.Tr.Entity:TakeDamageInfo(dmgInfo)
						if GetConVarNumber("grapple_play_sounds") == 1 then
							self.Tr.Entity:EmitSound( "weapons/xbow_hit2.wav",75 ,math.random(95,105) ,1 )
							if self.Tr.Entity:IsPlayer() or self.Tr.Entity:IsNPC() or self.Tr.Entity.Type == "nextbot" then
								self.Tr.Entity:EmitSound( sndGrappleHitFlesh,75 ,math.random(95,105) ,1 )
							end
						end
						if self.Tr.Entity:GetPhysicsObject() then
							local hitphys = self.Tr.Entity:GetPhysicsObject()
							if IsValid(hitphys) then

								if self.initialhit == false then
									hitphys:AddVelocity(self.Owner:GetAimVector()*50000/hitphys:GetMass())
								else
									hitphys:AddVelocity(self.Owner:GetAimVector()*-50000/hitphys:GetMass())
								end
								self.initialhit = true
							end
						end
						timer.Create( "hurtent" .. self:EntIndex(), 0.5, 1, function() end )
					end
				end
			end
		end	
	end

	local vVel = (endpos - self.Owner:GetShootPos())
	local Distance = endpos:Distance(self.Owner:GetShootPos())
	local et = (self.startTime + (Distance/self.speed))
	
	if self.dt != 0 then
		self.dt = (et - CurTime()) / (et - self.startTime)
		self.VElements["v_element2"].angle = Angle(-1.657, 89.516, -270*CurTime())
		self.VElements["v_element3"].angle = Angle(-1.657, 89.516, 45-270*CurTime())
	end
	if self.dt < 0 then
		if GetConVarNumber("grapple_play_sounds") == 1 then
			self.Weapon:EmitSound( sndGrappleHit )
			sound.Play(sndGrappleHit, self.Tr.HitPos)
		end
		self.dt = 0
	end

	if self.dt == 0 then
		self.VElements["v_element2"].angle = Angle(-1.657, 89.516, 0.8*Distance)
		self.VElements["v_element3"].angle = Angle(-1.657, 89.516, 45+0.8*Distance)
		if GetConVarNumber("grapple_play_sounds") == 1 then
			self.ReelIn = CreateSound(self.Owner, "weapons/grappling_hook_reel_start.wav")
			self.ReelIn:Play()
		end
		zVel = self.Owner:GetVelocity().z
		vVel = vVel:GetNormalized()*(math.Clamp(Distance,0,GetConVarNumber("grapple_speed_mk2")))
		if SERVER then
			local gravity = GetConVarNumber("sv_Gravity")
			vVel:Add(Vector(0,0,(gravity/100)*1.5)) -- Player speed. DO NOT MESS WITH THIS VALUE!
			if zVel < 0 then
				vVel:Sub(Vector(0,0,zVel/10))
			end

			self.Owner:SetLocalVelocity(vVel)
		end
	end
	endpos = nil
end

function SWEP:EndAttack( shutdownsound )
	if ( shutdownsound ) then
		if GetConVarNumber("grapple_play_sounds") == 1 then
			self.Weapon:EmitSound( sndGrappleAbort,70 )
			if self.ReelIn then
				self.ReelIn:Stop()
			end
		end
	end
	
	self.initialhit = false
	
	if ( CLIENT ) then return end
	if ( !self.Beam ) then return end
	
	self.Beam:Remove()
	self.Beam = nil
end

function SWEP:Holster()
	self:EndAttack( false )
	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	return true
end

function SWEP:OnRemove()
	self:EndAttack( false )
	return true
end

function SWEP:OnDrop()
	self:Holster()
end

function SWEP:PrimaryAttack()
	self.Weapon:SendWeaponAnim(ACT_VM_RELOAD)
	self.Owner:SetAnimation(PLAYER_ATTACK1)
	
	self.Idle = 0
	self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end

function SWEP:SecondaryAttack()
end
--PATH lua/weapons/weapon_hl2brokenbottle/shared.lua:
return gluapack()()
--PATH lua/weapons/weapon_hl2hook/shared.lua:

AddCSLuaFile()

SWEP.PrintName				= "Hook"
SWEP.Author				= "Dr. Towers"
SWEP.Instructions			= "Primary attack: Swing - Secondary attack : Push (Pulls instead of pushing back on primary attack)"
SWEP.Category				= "HL2 Melee Pack"

SWEP.Slot				= 1
SWEP.SlotPos				= 0

SWEP.Spawnable				= true

SWEP.ViewModel				= Model( "models/weapons/HL2meleepack/v_hook.mdl" )
SWEP.WorldModel				= Model( "models/weapons/HL2meleepack/w_hook.mdl" )
SWEP.ViewModelFOV			= 67
SWEP.UseHands				= true

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo		= "none"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= true
SWEP.Secondary.Ammo		= "none"

SWEP.DrawAmmo			= false

SWEP.HitDistance		= 40
SWEP.HitInclination		= 0.4
SWEP.HitPushback		= -1000
SWEP.HitRate			= 1.25
SWEP.MinDamage			= 34
SWEP.MaxDamage			= 55

local SwingSound = Sound( "WeaponFrag.Roll" )
local HitSoundWorld = Sound( "Canister.ImpactHard" )
local HitSoundBody = Sound( "Flesh.Break" )
local PushSoundBody = Sound( "Flesh.ImpactSoft" )

function SWEP:Initialize()

	self:SetHoldType( "melee2" )
end

function SWEP:PrimaryAttack()

	self.Owner:SetAnimation( PLAYER_ATTACK1 )

	local vm = self.Owner:GetViewModel()
	
	self:EmitSound( SwingSound )
	self.Weapon:SetNextPrimaryFire( CurTime() + self.HitRate )
	self.Weapon:SetNextSecondaryFire( CurTime() + self.HitRate )

	vm:SendViewModelMatchingSequence( vm:LookupSequence( "misscenter1" ) )

	timer.Create("hitdelay", 0.4, 1, function() self:Hitscan() end)

	timer.Start( "hitdelay" )

end

function SWEP:SecondaryAttack()

	self.Weapon:SetNextPrimaryFire( CurTime() + 0.35 )
	self.Weapon:SetNextSecondaryFire( CurTime() + 1.0 )

	self:EmitSound( SwingSound )

	local vm = self.Owner:GetViewModel()
	vm:SendViewModelMatchingSequence( vm:LookupSequence( "pushback" ) )

	local tr = util.TraceLine( {
		start = self.Owner:GetShootPos(),
		endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * 1.5 * 40,
		filter = self.Owner,
		mask = MASK_SHOT_HULL
	} )

	if ( tr.Hit ) then
	self:EmitSound( PushSoundBody )
	if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") or string.find(tr.Entity:GetClass(),"prop_physics") then
	tr.Entity:SetVelocity( self.Owner:GetAimVector() * Vector( 1, 1, 0 ) * 500 )
	end
	end

end

function SWEP:OnDrop()

	
end

function SWEP:Hitscan()

//This function calculate the trajectory

	for i=0, 170 do

	local tr = util.TraceLine( {
		start = (self.Owner:GetShootPos() - (self.Owner:EyeAngles():Up() * 10)),
		endpos = (self.Owner:GetShootPos() - (self.Owner:EyeAngles():Up() * 10)) + ( self.Owner:EyeAngles():Up() * ( self.HitDistance * 0.7 * math.cos(math.rad(i)) ) ) + ( self.Owner:EyeAngles():Forward() * ( self.HitDistance * 1.5 * math.sin(math.rad(i)) ) ) + ( self.Owner:EyeAngles():Right() * self.HitInclination * self.HitDistance * math.cos(math.rad(i)) ),
		filter = self.Owner,
		mask = MASK_SHOT_HULL
	} )

//This if shot the bullets

	if ( tr.Hit ) then
		
		local strikevector = ( self.Owner:EyeAngles():Up() * ( self.HitDistance * 0.5 * math.cos(math.rad(i)) ) ) + ( self.Owner:EyeAngles():Forward() * ( self.HitDistance * 1.5 * math.sin(math.rad(i)) ) ) + ( self.Owner:EyeAngles():Right() * self.HitInclination * self.HitDistance * math.cos(math.rad(i)) )

		bullet = {}
		bullet.Num    = 1
		bullet.Src    = (self.Owner:GetShootPos() - (self.Owner:EyeAngles():Up() * 15))
		bullet.Dir    = strikevector:GetNormalized()
		bullet.Spread = Vector(0, 0, 0)
		bullet.Tracer = 0
		bullet.Force  = 5
		bullet.Hullsize = 0
		bullet.Distance = self.HitDistance * 1.5
		bullet.Damage = math.random( 34, 50 )
		self.Owner:FireBullets(bullet)

		//local vPoint = (self.Owner:GetShootPos() - (self.Owner:EyeAngles():Up() * 10))
		//local effectdata = EffectData()
		//effectdata:SetOrigin( vPoint )
		//util.Effect( "BloodImpact", effectdata )

		self:EmitSound( SwingSound )

		//vm:SendViewModelMatchingSequence( vm:LookupSequence( "hitcenter1" ) )

		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") then
			self:EmitSound( HitSoundBody )
			tr.Entity:SetVelocity( self.Owner:GetAimVector() * Vector( 1, 1, 0 ) * self.HitPushback )
		else
			self:EmitSound( HitSoundWorld )
		end
//if break
		break
//if end
		//else vm:SendViewModelMatchingSequence( vm:LookupSequence( "misscenter1" ) )
		end
end

end

function SWEP:Deploy()

	local vm = self.Owner:GetViewModel()
	vm:SendViewModelMatchingSequence( vm:LookupSequence( "draw" ) )
	
	self.Weapon:SetNextPrimaryFire( CurTime() + 0.5 )
	self.Weapon:SetNextSecondaryFire( CurTime() + 0.5 )
	
	return true
end

function SWEP:Holster()

	return true
end

function SWEP:OnRemove()
	
	timer.Remove("hitdelay")
	return true
end
--PATH lua/weapons/weapon_hl2pan/shared.lua:
return gluapack()()
--PATH lua/weapons/weapon_hl2pickaxe/shared.lua:

AddCSLuaFile()

SWEP.PrintName				= "Pickaxe"
SWEP.Author				= "Dr. Towers"
SWEP.Instructions			= "Primary attack: Swing - Secondary attack : Push"
SWEP.Category				= "HL2 Melee Pack"

SWEP.Slot				= 1
SWEP.SlotPos				= 0

SWEP.Spawnable				= true

SWEP.ViewModel				= Model( "models/weapons/HL2meleepack/v_pickaxe.mdl" )
SWEP.WorldModel				= Model( "models/weapons/HL2meleepack/w_pickaxe.mdl" )
SWEP.ViewModelFOV			= 67
SWEP.UseHands				= true

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo		= "none"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= true
SWEP.Secondary.Ammo		= "none"

SWEP.DrawAmmo			= false

SWEP.HitDistance		= 40
SWEP.HitInclination		= 0.4
SWEP.HitPushback		= 1000
SWEP.HitRate			= 1.35
SWEP.MinDamage			= 34
SWEP.MaxDamage			= 50

local SwingSound = Sound( "WeaponFrag.Roll" )
local HitSoundWorld = Sound( "Canister.ImpactHard" )
local HitSoundBody = Sound( "Flesh.ImpactHard" )
local PushSoundBody = Sound( "Flesh.ImpactSoft" )

function SWEP:Initialize()

	self:SetHoldType( "melee2" )
end

function SWEP:PrimaryAttack()

	self.Owner:SetAnimation( PLAYER_ATTACK1 )

	local vm = self.Owner:GetViewModel()
	
	self:EmitSound( SwingSound )
	self.Weapon:SetNextPrimaryFire( CurTime() + self.HitRate )
	self.Weapon:SetNextSecondaryFire( CurTime() + self.HitRate )

	vm:SendViewModelMatchingSequence( vm:LookupSequence( "misscenter1" ) )

	timer.Create("hitdelay", 0.4, 1, function() self:Hitscan() end)

	timer.Start( "hitdelay" )

end

function SWEP:SecondaryAttack()

	self.Weapon:SetNextPrimaryFire( CurTime() + 0.35 )
	self.Weapon:SetNextSecondaryFire( CurTime() + 1.0 )

	self:EmitSound( SwingSound )

	local vm = self.Owner:GetViewModel()
	vm:SendViewModelMatchingSequence( vm:LookupSequence( "pushback" ) )

	local tr = util.TraceLine( {
		start = self.Owner:GetShootPos(),
		endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * 1.5 * 40,
		filter = self.Owner,
		mask = MASK_SHOT_HULL
	} )

	if ( tr.Hit ) then
	self:EmitSound( PushSoundBody )
	if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") or string.find(tr.Entity:GetClass(),"prop_physics") then
	tr.Entity:SetVelocity( self.Owner:GetAimVector() * Vector( 1, 1, 0 ) * 500 )
	end
	end

end

function SWEP:OnDrop()

	
end

function SWEP:Hitscan()

//This function calculate the trajectory

	for i=0, 170 do

	local tr = util.TraceLine( {
		start = (self.Owner:GetShootPos() - (self.Owner:EyeAngles():Up() * 10)),
		endpos = (self.Owner:GetShootPos() - (self.Owner:EyeAngles():Up() * 10)) + ( self.Owner:EyeAngles():Up() * ( self.HitDistance * 0.7 * math.cos(math.rad(i)) ) ) + ( self.Owner:EyeAngles():Forward() * ( self.HitDistance * 1.5 * math.sin(math.rad(i)) ) ) + ( self.Owner:EyeAngles():Right() * self.HitInclination * self.HitDistance * math.cos(math.rad(i)) ),
		filter = self.Owner,
		mask = MASK_SHOT_HULL
	} )

//This if shot the bullets

	if ( tr.Hit ) then
		
		local strikevector = ( self.Owner:EyeAngles():Up() * ( self.HitDistance * 0.5 * math.cos(math.rad(i)) ) ) + ( self.Owner:EyeAngles():Forward() * ( self.HitDistance * 1.5 * math.sin(math.rad(i)) ) ) + ( self.Owner:EyeAngles():Right() * self.HitInclination * self.HitDistance * math.cos(math.rad(i)) )

		
		bullet = {}
		bullet.Num    = 1
		bullet.Src    = (self.Owner:GetShootPos() - (self.Owner:EyeAngles():Up() * 15))
		bullet.Dir    = strikevector:GetNormalized()
		bullet.Spread = Vector(0, 0, 0)
		bullet.Tracer = 0
		bullet.Force  = 15
		bullet.Hullsize = 0
		bullet.Distance = self.HitDistance * 1.5
		bullet.Damage = math.random( 34, 50 )
		self.Owner:FireBullets(bullet)

		//local vPoint = (self.Owner:GetShootPos() - (self.Owner:EyeAngles():Up() * 10))
		//local effectdata = EffectData()
		//effectdata:SetOrigin( vPoint )
		//util.Effect( "BloodImpact", effectdata )

		self:EmitSound( SwingSound )

		//vm:SendViewModelMatchingSequence( vm:LookupSequence( "hitcenter1" ) )

		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") then
			self:EmitSound( HitSoundBody )
			tr.Entity:SetVelocity( self.Owner:GetAimVector() * Vector( 1, 1, 0 ) * self.HitPushback )
		else
			self:EmitSound( HitSoundWorld )
		end
//if break
		break
//if end
		//else vm:SendViewModelMatchingSequence( vm:LookupSequence( "misscenter1" ) )
		end
end

end

function SWEP:Deploy()

	local vm = self.Owner:GetViewModel()
	vm:SendViewModelMatchingSequence( vm:LookupSequence( "draw" ) )
	
	self.Weapon:SetNextPrimaryFire( CurTime() + 0.5 )
	self.Weapon:SetNextSecondaryFire( CurTime() + 0.5 )
	
	return true
end

function SWEP:Holster()

	return true
end

function SWEP:OnRemove()
	
	timer.Remove("hitdelay")
	return true
end
--PATH gamemodes/starwarsrp/entities/weapons/weapon_keypadchecker/cl_init.lua:
include("shared.lua")

local DrawData = {}
local KeypadCheckerHalos

net.Receive("DarkRP_keypadData", function(len)
    DrawData = net.ReadTable()
    hook.Add("PreDrawHalos", "KeypadCheckerHalos", KeypadCheckerHalos)
end)

local lineMat = Material("cable/chain")
local textCol = Color(0, 0, 0, 120)
local haloCol = Color(0, 255, 0, 255)

function SWEP:DrawHUD()
    local screenCenter = ScrH() / 2
    draw.WordBox(2, 10, screenCenter, DarkRP.getPhrase("keypad_checker_shoot_keypad"), "UiBold", textCol, color_white)
    draw.WordBox(2, 10, screenCenter + 20, DarkRP.getPhrase("keypad_checker_shoot_entity"), "UiBold", textCol, color_white)
    draw.WordBox(2, 10, screenCenter + 40, DarkRP.getPhrase("keypad_checker_click_to_clear"), "UiBold", textCol, color_white)

    local eyePos = EyePos()
    local eyeAngles = EyeAngles()

    local entMessages = {}
    for k,v in ipairs(DrawData or {}) do
        if not IsValid(v.ent) or not IsValid(v.original) then continue end
        entMessages[v.ent] = (entMessages[v.ent] or 0) + 1
        local obbCenter = v.ent:OBBCenter()
        local pos = v.ent:LocalToWorld(obbCenter):ToScreen()

        local name = v.name and ": " .. v.name:gsub("onDown", DarkRP.getPhrase("keypad_on")):gsub("onUp", DarkRP.getPhrase("keypad_off")) or ""

        draw.WordBox(2, pos.x, pos.y + entMessages[v.ent] * 16, (v.delay and v.delay .. " " .. DarkRP.getPhrase("seconds") .. " " or "") .. v.type .. name, "UiBold", textCol, color_white)

        cam.Start3D(eyePos, eyeAngles)
            render.SetMaterial(lineMat)
            render.DrawBeam(v.original:GetPos(), v.ent:GetPos(), 2, 0.01, 20, haloCol)
        cam.End3D()
    end
end

KeypadCheckerHalos = function()
    local drawEnts = {}
    local i = 1
    for k,v in ipairs(DrawData) do
        if not IsValid(v.ent) then continue end

        drawEnts[i] = v.ent
        i = i + 1
    end

    if table.IsEmpty(drawEnts) then return end
    halo.Add(drawEnts, haloCol, 5, 5, 5, nil, true)
end

function SWEP:SecondaryAttack()
    DrawData = {}
    hook.Remove("PreDrawHalos", "KeypadCheckerHalos")
end

--PATH addons/[miecze] moce i hilty/lua/weapons/weapon_lscs/sh_animations.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/weapons/weapon_lscs_electrostaff.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/weapons/weapon_lscs_mandostaff.lua:
AddCSLuaFile()

SWEP.Base = "weapon_lscs"
DEFINE_BASECLASS( "weapon_lscs" )

SWEP.Category		= "[LSCS]"
SWEP.PrintName	= "Mandalorian Royal Staff"
SWEP.Author		= "BadJay707"
SWEP.Slot		= 0
SWEP.SlotPos 	= 3
SWEP.HoldType = "melee2"
SWEP.Spawnable	= true
SWEP.AdminOnly	= false

function SWEP:SetupDataTables()
	BaseClass.SetupDataTables( self )

	if SERVER then
		self:SetHiltR("mandostaff") 
		self:SetBladeR("mandostaffcrys") 
	end
end
--PATH lua/weapons/weapon_policebaton/cl_init.lua:
include("shared.lua")

	
/* 
---------------------------------------------------------------------------------------------------------------------------------------------
				DrawCircles
---------------------------------------------------------------------------------------------------------------------------------------------
*/
local selectedItem = 0;
local simpleEnemy = false;
local lastDraw = CurTime()-5;
local attime = 0.5;
function SWEP:DrawCircles(sx,sy,id)
		if not self.drawMenu then return end;
		if lastDraw + attime > CurTime() then return end;
		local circleTable;
		local w = 20;
		local h = w;
		
		if !circleTable then
			circleTable = {};
			for k = 0, 30 do
				local vx, vy = math.cos((math.pi * 2) * k / 30), math.sin((math.pi * 2) * k /30);
				table.insert(circleTable, {x=sx+w*vx, y=sy+h*vy});
			end
		end
	
		local mx, my = gui.MousePos();
		
		local p1 = (sx-mx)*(sx-mx);
		local p2 = (sy-my)*(sy-my);
		local d = math.sqrt(p1 + p2);
		col = Color(15,50,55,180);
		local textColor = Color(255,255,255,255);
		if d<=w then 
			col = Color(50,150,50,200); 
			selectedItem = id;
			textColor = Color(220,225,125,255);
		elseif id == selectedItem then
			selectedItem = 0;
		end
		surface.SetDrawColor(col);
		surface.DrawPoly(circleTable);
		
		surface.SetFont( "HUDNumber5" );
		
		surface.SetTextColor( 2, 2, 2, 255 );
		
		local text = self.menuButtons[id].buttonText;
		if self.menuButtons[id].left then
			surface.SetTextPos(sx-w - surface.GetTextSize(text)- 10,sy-20);
			surface.DrawText(text);
			surface.SetTextPos(sx-w - surface.GetTextSize(text)- 10,sy-22);
			surface.SetTextColor( textColor );
			surface.DrawText(text);
		else
			surface.SetTextPos(sx+w+10,sy-15);
			surface.DrawText(text);
			surface.SetTextPos(sx+w+10,sy-17);
			surface.SetTextColor( textColor );
			surface.DrawText(text);
		end

	
		
		

		
end

/* 
---------------------------------------------------------------------------------------------------------------------------------------------
				GUIMousePressed
---------------------------------------------------------------------------------------------------------------------------------------------
*/

hook.Add("GUIMousePressed","ChoiseCircle",function(mouseCode,aimVector)
	if mouseCode == MOUSE_LEFT then
		if lastDraw + attime > CurTime() then return end;
		if selectedItem != 0 and simpleEnemy == false then
			GAMEMODE:AddNotify("No target!", 1, 4);
			surface.PlaySound("buttons/lightswitch2.wav");
		end
		if selectedItem != 0 and simpleEnemy != false then
			lastDraw = CurTime();
			if selectedItem == 1 or selectedItem == 3 then 
				net.Start("batonsendfunc") net.WriteInt(selectedItem,3) net.WriteEntity(simpleEnemy) net.SendToServer();
			else
				local weap = LocalPlayer():GetActiveWeapon();
				if weap:GetClass() != "weapon_policebaton" then return end;
				local warn = "wanted";
				if selectedItem == 4 then
					warn = "warrant";
				end
				weap:CreateDFrame(warn,simpleEnemy);
			end
		end
	end
end)

/* 
---------------------------------------------------------------------------------------------------------------------------------------------
				Find Enemy
---------------------------------------------------------------------------------------------------------------------------------------------
*/

function SWEP:FindEnemy()
	local enemy = false;
	local enemyTable = {};
	local shootPos = LocalPlayer():GetShootPos();
	local aimVec = LocalPlayer():GetAimVector();
	for k,v in pairs(player.GetAll()) do 
		local hisPos = v:GetShootPos();
		if hisPos:DistToSqr(shootPos) < 320000 then
            local pos =  hisPos - shootPos;
            local unitPos = pos:GetNormalized();
            if unitPos:Dot(aimVec) > 0.99 then
                local trace = util.QuickTrace(shootPos, pos, LocalPlayer());
                if trace.Hit and trace.Entity ~= v then break end;
				table.insert(enemyTable,v);
            end
		end	
	end
	
	local dist = 999999;
	
	for k,v in pairs(enemyTable) do
		local curDist = v:GetPos():Distance(LocalPlayer():GetPos());
		if  curDist < dist then
			dist = curDist;
			enemy = v;
		end
	end

	local traceEnt = LocalPlayer():GetEyeTrace().Entity;
	if IsValid(traceEnt) and traceEnt:IsPlayer() or traceEnt:isDoor() then
		enemy = traceEnt;
	end

	return enemy;
end

/* 
---------------------------------------------------------------------------------------------------------------------------------------------
				Wanted / Warrant reason menu
---------------------------------------------------------------------------------------------------------------------------------------------
*/


function SWEP:CreateDFrame(warn,enemy)
	if IsValid(self.DermaPanel) then self.DermaPanel:Remove() end
	if not IsValid(enemy) then return end;
	if not enemy:IsPlayer() then
		if enemy:isDoor() then 
			local owner = enemy:getDoorOwner();
				if owner != nil and IsValid(owner) and owner:IsPlayer() then
					enemy = owner;
				else
					return
				end
		else
			return
		end
	end 
	self.DermaPanel = vgui.Create( "DFrame" );
	self.DermaPanel:SetPos( ScrW()/2 - 130, ScrH()/2 - 60);
	self.DermaPanel:SetSize( 260, 120 );
	self.DermaPanel:SetTitle( warn..":"..enemy:Nick() );
	self.DermaPanel:SetDraggable( true );
	self.DermaPanel:MakePopup();
	self.DermaPanel:SetSkin("DarkRP");
	
	local DLabel = vgui.Create( "DLabel", self.DermaPanel );
	DLabel:SetPos( 10, 25 );
	DLabel:SetSize( 100, 40 );
	DLabel:SetText( "Reason for "..warn..":");
	
	
	
	local function SendMessage(reason)
		RunConsoleCommand("say","/"..warn.." "..enemy:Nick().." "..reason);
		self.DermaPanel:Remove();
	end
	
	local TextEntry = vgui.Create( "DTextEntry", self.DermaPanel);
	TextEntry:SetPos( 10, 50 );
	TextEntry:SetSize( 240, 30 );
	TextEntry:SetText("Reason:");
	TextEntry:SetTextColor(Color(255,255,255));
	TextEntry.OnGetFocus = function() TextEntry:SetText("") end
	TextEntry.OnEnter = function() SendMessage(TextEntry:GetText()); end

	local DButton = vgui.Create( "DButton",self.DermaPanel)
	DButton:SetPos( 190, 85 )
	DButton:SetText( "Ok" )
	DButton:SetSize( 60, 30 )
	DButton.DoClick = function() SendMessage(TextEntry:GetText()); end
	
	
end

/* 
---------------------------------------------------------------------------------------------------------------------------------------------
				Draw Hud
---------------------------------------------------------------------------------------------------------------------------------------------
*/
local function isVisible(enemy)
	if enemy == LocalPlayer() then return false end;
	if LocalPlayer():GetShootPos():Distance(enemy:GetPos()) > 1500 then return false end;
	local trdata = {};
	trdata.start = LocalPlayer():GetShootPos();
	trdata.endpos = enemy:GetPos() +Vector(0,0,40);
	trdata.mask = CONTENTS_SOLID;
	trdata.filter = LocalPlayer();
	local res = util.TraceLine(trdata);
	if res.Hit then return false end;
	return true;
end

/* 
---------------------------------------------------------------------------------------------------------------------------------------------
				Draw Hud
---------------------------------------------------------------------------------------------------------------------------------------------
*/
function SWEP:DrawHUD()

   
	
	draw.RoundedBox(1, ScrW() / 2 - 26, ScrH() / 2, 22, 1, color_black);
    draw.RoundedBox(1, ScrW() / 2 + 4, ScrH() / 2, 22, 1, color_black);
	
	if lastDraw + attime > CurTime() then return end; 
	draw.NoTexture()
	local scrW,scrH = ScrW(), ScrH();
	local sx, sy = scrW / 2 - 50, scrH / 2;
	 self:DrawCircles(sx,sy,1);
	 sx, sy = scrW / 2 + 50, scrH / 2;
	 self:DrawCircles(sx,sy,2);
	 sx, sy = scrW / 2, scrH / 2 - 50;
	 self:DrawCircles(sx,sy,3);
	 sx, sy = scrW / 2, scrH / 2 + 50;
	 self:DrawCircles(sx,sy,4);
	
	if self.drawMenu then
		simpleEnemy = self:FindEnemy();
		if simpleEnemy != false then
			surface.SetFont( "HUDNumber5" );
			surface.SetTextColor( 2, 2, 2, 255 );
			target = "Door";
			if simpleEnemy:IsPlayer()  then
				target = simpleEnemy:Nick();
			else
				local owner = simpleEnemy:getDoorOwner();
				if owner != nil and IsValid(owner) and owner:IsPlayer() then
					target = "Door - "..owner:Nick();
				end
			end
			local text = "Target: "..target;
			surface.SetTextPos(ScrW()/2 - surface.GetTextSize(text)/2,ScrH()/2 - 120);
			surface.DrawText(text);
			surface.SetTextColor( 255, 255, 255, 255 );
			surface.SetTextPos(ScrW()/2 - surface.GetTextSize(text)/2,ScrH()/2 - 122);
			surface.DrawText(text);
		end	
	end
	
	
	

 
 
	for k,v in pairs(player.GetAll()) do 
		if v:GetNWInt("batonstuntime",0) + self.stunTime > CurTime() then
			if isVisible(v) then 
				local ang = (LocalPlayer():EyePos() - v:EyePos()):Angle();
				ang.p = 0;
				cam.Start3D();
				cam.Start3D2D( v:EyePos() + LocalPlayer():GetRight()*-20 - Vector(0,0,10), ang + Angle(0,90,90), 0.15 );

					draw.SimpleText("Hold R to interact!", "TargetID",41,1, Color(25,25,25));
					draw.SimpleText("Hold R to interact!", "TargetID",40,0, Color(255,255,255));
						
				cam.End3D2D();
				cam.End3D();		
			end
		end	 
	end 	
end





--PATH gamemodes/starwarsrp/entities/weapons/weapon_pumpshotgun2/shared.lua:
AddCSLuaFile()

if CLIENT then
    SWEP.Author = "DarkRP Developers"
    SWEP.Slot = 2
    SWEP.SlotPos = 0
    SWEP.IconLetter = "k"

    killicon.AddFont("weapon_pumpshotgun2", "CSKillIcons", SWEP.IconLetter, Color(255, 80, 0, 255))
end

DEFINE_BASECLASS("weapon_cs_base2")

SWEP.PrintName = "Pump Shotgun"
SWEP.Spawnable = true
SWEP.AdminOnly = false
SWEP.Category = "DarkRP (Weapon)"

SWEP.ViewModel = "models/weapons/cstrike/c_shot_m3super90.mdl"
SWEP.WorldModel = "models/weapons/w_shot_m3super90.mdl"

SWEP.Weight = 5
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false

SWEP.HoldType = "shotgun"
SWEP.LoweredHoldType = "normal"

SWEP.Primary.Sound = Sound("Weapon_M3.Single")
SWEP.Primary.Recoil = 1.5
SWEP.Primary.Damage = 20
SWEP.Primary.NumShots = 8
SWEP.Primary.Cone = 0.08
SWEP.Primary.ClipSize = 8
SWEP.Primary.Delay = 0.95
SWEP.Primary.DefaultClip = 8
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "buckshot"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

SWEP.IronSightsPos = Vector(-7.64, -8, 3.56)
SWEP.IronSightsAng = Vector(-0.1, 0.02, 0)

function SWEP:SetupDataTables()
    BaseClass.SetupDataTables(self)
    -- Float 0 = IronsightsTime
    -- Float 1 = LastPrimaryAttack
    -- Float 2 = ReloadEndTime
    -- Float 3 = BurstTime
    self:NetworkVar("Float", 4, "QueuedAttackTime")
    -- Bool 0 = IronsightsPredicted
    -- Bool 1 = Reloading
    self:NetworkVar("Bool", 2, "AttackQueued")
end

function SWEP:Deploy()
    self:SetAttackQueued(false)

    return BaseClass.Deploy(self)
end

function SWEP:Holster()
    self:SetAttackQueued(false)

    return BaseClass.Holster(self)
end

function SWEP:PrimaryAttack()
    if self:GetAttackQueued() then return end

    if self:GetReloading() then
        self:SetAttackQueued(true) -- this way it doesn't interupt the reload animation
        return
    end

    BaseClass.PrimaryAttack(self)
end

function SWEP:Reload()
    -- Already reloading
    if self:GetReloading() then return end

    -- Start reloading if we can
    if self:Clip1() < self.Primary.ClipSize and self:GetOwner():GetAmmoCount(self.Primary.Ammo) > 0 then
        self:SetReloading(true)
        self:SetReloadEndTime(CurTime() + 0.3)
        self:SendWeaponAnim(ACT_VM_RELOAD)
        self:SetIronsights(false)
        self:SetHoldType(self.HoldType)
        self:GetOwner():SetAnimation(PLAYER_RELOAD)
        self:SetHoldType("normal")
    end
end

function SWEP:Think()
    self:CalcViewModel()
    if self:GetReloadEndTime() ~= 0 and CurTime() >= self:GetReloadEndTime() then
        -- Finished reload -
        if self:Clip1() >= self.Primary.ClipSize or self:GetOwner():GetAmmoCount(self.Primary.Ammo) <= 0 then
            self:SetReloading(false)
            self:SetReloadEndTime(0)
            self:SetAttackQueued(false)
            return
        end

        if self:GetAttackQueued() then
            self:SendWeaponAnim(ACT_SHOTGUN_RELOAD_FINISH)
            self:SetReloading(false)
            self:SetReloadEndTime(0)
            self:SetAttackQueued(false)
            self:SetQueuedAttackTime(CurTime() + 0.8)
            return
        end

        -- Next cycle
        self:SetReloadEndTime(CurTime() + 0.3)
        self:SendWeaponAnim(ACT_VM_RELOAD)

        -- Add ammo
        self:GetOwner():RemoveAmmo(1, self.Primary.Ammo, false)
        self:SetClip1(self:Clip1() + 1)

        -- Finish filling, final pump
        if self:Clip1() >= self.Primary.ClipSize or self:GetOwner():GetAmmoCount(self.Primary.Ammo) <= 0 then
            self:SendWeaponAnim(ACT_SHOTGUN_RELOAD_FINISH)
        end
    end
    if self:GetQueuedAttackTime() ~= 0 and CurTime() >= self:GetQueuedAttackTime() then
        self:SetQueuedAttackTime(0)
        self:PrimaryAttack()
    end
end

--PATH lua/weapons/weapon_vj_spas12/shared.lua:
if (!file.Exists("autorun/vj_base_autorun.lua","LUA")) then return end
---------------------------------------------------------------------------------------------------------------------------------------------
SWEP.Base = "weapon_vj_base"
SWEP.PrintName = "SPAS-12"
SWEP.Author = "DrVrej"
SWEP.Contact = "http://steamcommunity.com/groups/vrejgaming"
SWEP.Purpose = "This weapon is made for Players and NPCs"
SWEP.Instructions = "Controls are like a regular weapon."
SWEP.Category = "VJ Base"
	-- Client Settings ---------------------------------------------------------------------------------------------------------------------------------------------
if CLIENT then
	SWEP.Slot = 3 -- Which weapon slot you want your SWEP to be in? (1 2 3 4 5 6) 
	SWEP.SlotPos = 4 -- Which part of that slot do you want the SWEP to be in? (1 2 3 4 5 6)
	SWEP.UseHands = true
end
	-- NPC Settings ---------------------------------------------------------------------------------------------------------------------------------------------
SWEP.NPC_NextPrimaryFire = 0.9 -- Next time it can use primary fire
SWEP.NPC_CustomSpread = 2.5 -- This is added on top of the custom spread that's set inside the SNPC! | Starting from 1: Closer to 0 = better accuracy, Farther than 1 = worse accuracy
SWEP.NPC_ExtraFireSound = {"vj_weapons/perform_shotgunpump.wav"} -- Plays an extra sound after it fires (Example: Bolt action sound)
SWEP.NPC_FiringDistanceScale = 0.5 -- Changes how far the NPC can fire | 1 = No change, x < 1 = closer, x > 1 = farther
	-- Main Settings ---------------------------------------------------------------------------------------------------------------------------------------------
SWEP.ViewModel = "models/weapons/c_shotgun.mdl"
SWEP.WorldModel = "models/weapons/w_shotgun.mdl"
SWEP.HoldType = "shotgun"
SWEP.Spawnable = true
SWEP.AdminSpawnable = false
	-- Primary Fire ---------------------------------------------------------------------------------------------------------------------------------------------
SWEP.Primary.Damage = 4 -- Damage
SWEP.Primary.PlayerDamage = "Double" -- Only applies for players | "Same" = Same as self.Primary.Damage, "Double" = Double the self.Primary.Damage OR put a number to be different from self.Primary.Damage
SWEP.Primary.Force = 1 -- Force applied on the object the bullet hits
SWEP.Primary.NumberOfShots = 7 -- How many shots per attack?
SWEP.Primary.ClipSize = 6 -- Max amount of bullets per clip
SWEP.Primary.Cone = 12 -- How accurate is the bullet? (Players)
SWEP.Primary.Delay = 0.8 -- Time until it can shoot again
SWEP.Primary.Automatic = true -- Is it automatic?
SWEP.Primary.Ammo = "Buckshot" -- Ammo type
SWEP.Primary.Sound = {"vj_weapons/hl2_shotgun/shotgun_single1.wav"}
SWEP.Primary.DistantSound = {"vj_weapons/hl2_shotgun/shotgun_single_dist.wav"}
SWEP.PrimaryEffects_MuzzleAttachment = 1
SWEP.PrimaryEffects_ShellAttachment = 2
SWEP.PrimaryEffects_ShellType = "VJ_Weapon_ShotgunShell1"
	-- ====== Secondary Fire Variables ====== --
SWEP.Secondary.Automatic = true -- Is it automatic?
SWEP.Secondary.Ammo = "Buckshot" -- Ammo type
	-- Reload Settings ---------------------------------------------------------------------------------------------------------------------------------------------
SWEP.HasReloadSound = true -- Does it have a reload sound? Remember even if this is set to false, the animation sound will still play!
SWEP.ReloadSound = {"weapons/shotgun/shotgun_reload1.wav","weapons/shotgun/shotgun_reload2.wav","weapons/shotgun/shotgun_reload3.wav"}
SWEP.Reload_TimeUntilAmmoIsSet = 0.3 -- Time until ammo is set to the weapon
---------------------------------------------------------------------------------------------------------------------------------------------
function SWEP:CustomOnPrimaryAttack_AfterShoot()
	local owner = self:GetOwner()
	if IsValid(owner) && owner:IsPlayer() then
		timer.Simple(0.2, function()
			if IsValid(self) && IsValid(owner) && owner:IsPlayer() then
				self:EmitSound(Sound("weapons/shotgun/shotgun_cock.wav"), 80, 100)
				local animTime = VJ_GetSequenceDuration(owner:GetViewModel(), ACT_SHOTGUN_PUMP)
				self:SendWeaponAnim(ACT_SHOTGUN_PUMP)
				self.NextIdleT = CurTime() + animTime
				self.NextReloadT = CurTime() + animTime
			end
		end)
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
function SWEP:CustomOnSecondaryAttack()
	if self:Clip1() > 1 then
		self.Primary.Delay = 1
		self.Primary.Cone = 20
		self.Primary.NumberOfShots = 14
		self.Primary.TakeAmmo = 2
		self.NextIdle_PrimaryAttack = 1
		self.AnimTbl_PrimaryFire = {ACT_VM_SECONDARYATTACK}
	end
	self:PrimaryAttack()
	self.Primary.Delay = 0.8
	self.Primary.Cone = 12
	self.Primary.NumberOfShots = 7
	self.Primary.TakeAmmo = 1
	self.NextIdle_PrimaryAttack = 0.8
	self.AnimTbl_PrimaryFire = {ACT_VM_PRIMARYATTACK}
	
	self:SetNextSecondaryFire(CurTime() + 1)
	return false
end
---------------------------------------------------------------------------------------------------------------------------------------------
function SWEP:CustomOnReload_Finish()
	local owner = self:GetOwner()
	if !owner:IsPlayer() then return true end
	self:GetOwner():RemoveAmmo(1, self.Primary.Ammo)
	self:SetClip1(self:Clip1() + 1)
	if self.Primary.ClipSize > self:Clip1() then
		timer.Simple(0.1, function()
			if IsValid(self) && IsValid(self:GetOwner()) then
				self.Reloading = false
				self:Reload()
			end
		end)
	end
	return false
end
--PATH lua/entities/ammo_chargepack.lua:
AddCSLuaFile()
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.PrintName = "Tibanna Charge Pack"
ENT.Category = "Osmonium Armory"
ENT.Editable = true
ENT.Spawnable = true
ENT.AdminOnly = false
ENT.UseTimer = CurTime()

ENT.Model = "models/cs574/objects/ammo_box.mdl"

function ENT:SpawnFunction( ply, tr, ClassName )
if ( !tr.Hit ) then return end
    local SpawnPos = tr.HitPos + tr.HitNormal * 10
    pAngle = ply:GetAngles()
    pAngle.pitch = pAngle.pitch
    pAngle.roll = pAngle.roll 
    pAngle.yaw = pAngle.yaw + 180
    local ent = ents.Create( ClassName ) 
    ent:SetPos( SpawnPos - Vector(0,0,-10) )
    ent:SetAngles( pAngle )
    ent:Spawn()
    ent:Activate()
    return ent	
end

function ENT:Draw()
    self:DrawModel()
end

function ENT:Initialize()
    if SERVER then
        self:SetModel( "models/cs574/objects/ammo_box.mdl" )
        self:SetMoveType( MOVETYPE_VPHYSICS )
        self:SetSolid( SOLID_VPHYSICS )
        self:PhysicsInit( SOLID_VPHYSICS )
        self:DrawShadow( true )

        local phys = self:GetPhysicsObject()
		if (phys:IsValid()) then
			phys:Wake()
		end
        self:SetTrigger(true)
        
    end
end

function ENT:Use( activator, caller )
	local dispencer_ammo_basic_count = GetConVar("rw_sw_dispenser_ammo_basic_count"):GetInt()
    if self.UseTimer <= CurTime() and activator:IsPlayer() then
        activator:GiveAmmo(dispencer_ammo_basic_count, "ar2", false )
        self:Remove()
    end
end

function ENT:PhysicsCollide( data, phys )
end
--PATH lua/entities/arccw_ammo_pistol.lua:
AddCSLuaFile()

ENT.Base                      = "arccw_ammo"

ENT.PrintName                 = "Pistol Ammo"
ENT.Category                  = "ArcCW - Ammo"

ENT.Spawnable                 = true
ENT.Model                     = "models/items/arccw/pistol_ammo.mdl"

ENT.AmmoType = "pistol"
ENT.AmmoCount = 40

ENT.DetonationDamage = 10
ENT.DetonationRadius = 256
ENT.DetonationSound = "weapons/pistol/pistol_fire3.wav"
--PATH lua/entities/arccw_ammo_smg1_grenade_large.lua:
AddCSLuaFile()

ENT.Base                      = "arccw_ammo"

ENT.PrintName                 = "Rifle Grenade Box"
ENT.Category                  = "ArcCW - Ammo"

ENT.Spawnable                 = true
ENT.Model                     = "models/items/arccw/riflegrenade_ammo.mdl"
ENT.Health = 70

ENT.AmmoType = "smg1_grenade"
ENT.AmmoCount = 5

ENT.DetonationDamage = 100 -- Per-round damage
ENT.DetonationRadius = 300

function ENT:DetonateRound(attacker)
    local nade = ents.Create("arccw_gl_ammodet")
    nade:SetPos(self:GetPos())
    local v = self:GetUp():Angle() + AngleRand(-60, 60)
    nade:SetAngles(v)
    nade:Spawn()
    nade:GetPhysicsObject():AddVelocity(self:GetVelocity() + self:GetForward() * math.random(2000, 3000))
    nade:SetOwner(attacker or self.Burner)

    self.AmmoCount = self.AmmoCount - 1

    self:GetPhysicsObject():AddVelocity(VectorRand() * math.random(5, 10) * self:GetPhysicsObject():GetMass())
    self:GetPhysicsObject():AddAngleVelocity(VectorRand() * math.random(60, 300))

    self:EmitSound("weapons/ar2/ar2_altfire.wav", 80, 150)
end

function ENT:Detonate(wet, attacker)
    if wet then
        for i = 1, math.random(1, 3) do
            self:DetonateRound(attacker)
        end
    end

    local e = EffectData()
    e:SetOrigin(self:GetPos())
    util.Effect("Explosion", e)

    util.BlastDamage(self, attacker, self:GetPos(), self.DetonationRadius, self.DetonationDamage * (wet and 1 or 2))
    self:Remove()
end
--PATH lua/entities/arccw_ammo_smg1_large.lua:
return gluapack()()
--PATH lua/entities/arccw_gl_ammodet.lua:
ENT.Type                  = "anim"
ENT.Base                  = "base_entity"
ENT.PrintName             = "HE Round"
ENT.Author                = ""
ENT.Information           = ""

ENT.Spawnable             = false


AddCSLuaFile()

ENT.Model = "models/items/ar2_grenade.mdl"
ENT.Ticks = 0
ENT.FuseTime = 10

function ENT:Draw()
    self:DrawModel()
end

ENT.Ticks = 0

function ENT:Detonate()
    if !self:IsValid() then return end
    local effectdata = EffectData()
        effectdata:SetOrigin( self:GetPos() )

    if self:WaterLevel() >= 1 then
        util.Effect( "WaterSurfaceExplosion", effectdata )
        self:EmitSound("weapons/underwater_explode3.wav", 125, 100, 1, CHAN_AUTO)
    else
        util.Effect( "Explosion", effectdata)
        self:EmitSound("phx/kaboom.wav", 125, 100, 1, CHAN_AUTO)
    end

    local attacker = self

    if self:GetOwner():IsValid() then
        attacker = self:GetOwner()
    end

    util.BlastDamage(self, attacker, self:GetPos(), 300, 50)

    self:FireBullets({
        Attacker = attacker,
        Damage = 0,
        Tracer = 0,
        Distance = 20000,
        Dir = self:GetVelocity(),
        Src = self:GetPos(),
        Callback = function(att, tr, dmg)
            util.Decal("Scorch", tr.StartPos, tr.HitPos - (tr.HitNormal * 16), self)
        end
    })

    self:Remove()
end

if CLIENT then
    function ENT:Think()
        if self.Ticks % 2 == 0 then
            local emitter = ParticleEmitter(self:GetPos())

            if !self:IsValid() or self:WaterLevel() > 2 then return end
            if !IsValid(emitter) then return end

            local smoke = emitter:Add("particle/particle_smokegrenade", self:GetPos())
            smoke:SetVelocity( VectorRand() * 25 )
            smoke:SetGravity( Vector(math.Rand(-5, 5), math.Rand(-5, 5), math.Rand(-20, -25)) )
            smoke:SetDieTime( math.Rand(1.5, 2.0) )
            smoke:SetStartAlpha( 255 )
            smoke:SetEndAlpha( 0 )
            smoke:SetStartSize( 0 )
            smoke:SetEndSize( 100 )
            smoke:SetRoll( math.Rand(-180, 180) )
            smoke:SetRollDelta( math.Rand(-0.2,0.2) )
            smoke:SetColor( 20, 20, 20 )
            smoke:SetAirResistance( 5 )
            smoke:SetPos( self:GetPos() )
            smoke:SetLighting( false )
            emitter:Finish()
        end

        self.Ticks = self.Ticks + 1
    end
else

    function ENT:Initialize()
        local pb_vert = 1
        local pb_hor = 1
        self:SetModel(self.Model)
        self:PhysicsInitBox( Vector(-pb_vert,-pb_hor,-pb_hor), Vector(pb_vert,pb_hor,pb_hor) )

        local phys = self:GetPhysicsObject()
        if phys:IsValid() then
            phys:Wake()
        end

        self.SpawnTime = CurTime()

        timer.Simple(0.1, function()
            if !IsValid(self) then return end
            self:SetCollisionGroup(COLLISION_GROUP_PROJECTILE)
        end)
    end

    function ENT:Think()
        if SERVER and CurTime() - self.SpawnTime >= self.FuseTime then
            self:Detonate()
        end
    end

    function ENT:PhysicsCollide(colData, collider)
        self:Detonate()
    end

end
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/entities/arccw_ubgl_he.lua:
return gluapack()()
--PATH addons/[bronie] krakens-republic-arsenal-v1.4/lua/entities/arccw_ubgl_incendiary.lua:
AddCSLuaFile()

ENT.Base = "arccw_ubgl_he"
ENT.PrintName = "40mm Incendiary"

ENT.GrenadeDamage = 50
ENT.GrenadeRadius = 150

function ENT:DoDetonation()
    local attacker = IsValid(self:GetOwner()) and self:GetOwner() or self
    util.BlastDamage(self, attacker, self:GetPos(), self.GrenadeRadius, self.GrenadeDamage)
    self:EmitSound("ambient/fire/gascan_ignite1.wav", 100, 100, 1)

    for i = 1, 5 do
        local cloud = ents.Create("arccw_fire_ubgl")
        cloud.FireTime = 20

        if !IsValid(cloud) then return end

        local vel = Vector(math.Rand(-1, 1), math.Rand(-1, 1), math.Rand(-1, 1)) * 1500

        cloud.Order = i
        cloud:SetPos(self:GetPos() - (self:GetVelocity() * FrameTime()) * 3 + VectorRand())
        cloud:SetAbsVelocity(vel + self:GetVelocity())
        cloud:SetOwner(self:GetOwner())
        cloud:Spawn()
    end
end

--[[att.Hook_FireBullets = function(wep, data)  this thing doesn't actually call firebullets lol
    wep:EmitSound("DB_ADD") -- lua/arccw/shared/sh_0_uc.lua
  end]]
--PATH lua/entities/aura_lvs_aa-9_liner/shared.lua:
return gluapack()()
--PATH lua/entities/aura_lvs_arquitens/cl_init.lua:
return gluapack()()
--PATH lua/entities/aura_lvs_captor/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "CSI | Captor"
ENT.Category = "Aura's LVS Big Ships"

DEFINE_BASECLASS( "aura_lvs_capital_ship_base_mk2" )

ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Editable = true

ENT.Model 					= "models/npc/starwars/cis/captor/captor.mdl"
ENT.AITEAM 					= 1

ENT.Mass 					= 700

ENT.HealthVal 				= 1000000
ENT.MaxHealth  				= ENT.HealthVal
ENT.SPAWNNUMBER				= 1
ENT.SPAWNDELAY				= 3
ENT.SHIPSPAWNPOS 			= {forward = 7000, right = 0, up = -400}
ENT.ENABLETURRETS 			= false
ENT.SHOOTEFFECT 			= "lvs_capital_red_laser"
ENT.SHOOTSOUND				= Sound("weapons/canon.wav")

ENT.PRIMARYDAMAGE			= 40
ENT.SHOOTDELAY1 			= 3
ENT.SEARCHSIZE				= 30000
ENT.LOSE_DIST 				= 31000
ENT.TURRETFORWARDSEARCH 	= 600

ENT.EXPLOSION_SCALE_MIN		= 4
ENT.EXPLOSION_SCALE_MAX		= 7


ENT.TURRETS = 
{
	[1] = Vector(10000,-1000,90),
	[2] = Vector(10000,1000,90),
	[3] = Vector(-2000,0,-1950),
	[4] = Vector(-3800,0,1290),
	[5] = Vector(2050,0,1980),
}

ENT.TURRETANGLES = 
{
	[1] = Angle(90,-90,180),
	[2] = Angle(90,90,180),
	[3] = Angle(180,0,0),
	[4] = Angle(0,0,0),
	[5] = Angle(-7,180,0),
}

ENT.BOMBS = 
{
	{forward = -6000, right = 0, up = 1800},
	{forward = -6000, right = 2000, up = 1800},
	{forward = -6000, right = 0, up = 1800},
	{forward = -6000, right = -2000, up = 1800},
	{forward = -4000, right = 0, up = 1800},
	{forward = -4000, right = 2000, up = 1800},
	{forward = -2000, right = 0, up = 1600},
	{forward = 0, right = 0, up = 1800},
	{forward = 2000, right = 0, up = 1600},
	{forward = 2000, right = 2000, up = 1600},
	{forward = 4000, right = 0, up = 1400},
	{forward = 6000, right = 0, up = 1800},
	{forward = -2000, right = 0, up = 1600},
	{forward = -2000, right = -2000, up = 1600},
	{forward = -4000, right = 0, up = 1800},
	{forward = -6000, right = 0, up = 1800},
}
--PATH lua/entities/aura_lvs_cargo2/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()
end
--PATH lua/entities/aura_lvs_cargo2/shared.lua:
return gluapack()()
--PATH lua/entities/aura_lvs_cargo6/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()
end
--PATH lua/entities/aura_lvs_cargo6/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "NEU (team 0) | Cargo 6"
ENT.Category = "Aura's LVS Big Ships"

DEFINE_BASECLASS( "aura_lvs_capital_ship_base_mk2" )

ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Editable = true

ENT.Model 					= "models/props/daru/daru_mozu.mdl"
ENT.AITEAM 					= 0

ENT.Mass 					= 700

ENT.HealthVal 				= 100000
ENT.MaxHealth  				= ENT.HealthVal
ENT.SPAWNNUMBER				= 1
ENT.SPAWNDELAY				= 3

ENT.SHIPSPAWNPOS 			= {forward = 0, right = 0, up = -1000}
ENT.ENABLETURRETS 			= false
ENT.SHOOTEFFECT 			= "lvs_capital_red_laser"
ENT.SHOOTSOUND				= Sound("weapons/9799_fire.mp3")

ENT.PRIMARYDAMAGE			= 80
ENT.SHOOTDELAY1 			= 0.6
ENT.SEARCHSIZE				= 30000
ENT.LOSE_DIST 				= 31000
ENT.TURRETFORWARDSEARCH 	= 30600

ENT.EXPLOSION_SCALE_MIN		= 4
ENT.EXPLOSION_SCALE_MAX		= 8

ENT.TURRETS = 
{
	[1] = Vector(-1700,0,890),
}

ENT.TURRETANGLES = 
{
	[1] = Angle(0,180,0),
}

ENT.BOMBS = 
{
	{forward = 0, right = 0, up = 700},
	{forward = 700, right = 0, up = 700},
	{forward = 1000, right = 0, up = 700},
	{forward = 0, right = 0, up = 700},
	{forward = -700, right = 0, up = 700},
	{forward = -1100, right = 0, up = 900},
}
--PATH lua/entities/aura_lvs_diamond/shared.lua:
return gluapack()()
--PATH lua/entities/aura_lvs_display_panel/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()
end
--PATH lua/entities/aura_lvs_geo_cruiser/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()
end
--PATH lua/entities/aura_lvs_gozanti/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "CSI | Gozanti"
ENT.Category = "Aura's LVS Big Ships"

DEFINE_BASECLASS( "aura_lvs_capital_ship_base_mk2" )

ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Editable = true

ENT.Model 					= "models/npc/starwars/cis/gozanti/gozanti.mdl"
ENT.AITEAM 					= 1

ENT.Mass 					= 700

ENT.HealthVal 				= 200000
ENT.MaxHealth  				= ENT.HealthVal
ENT.SPAWNNUMBER				= 1
ENT.SPAWNDELAY				= 3

ENT.SHIPSPAWNPOS 			= {forward = 0, right = 0, up = -1000}
ENT.ENABLETURRETS 			= false
ENT.SHOOTEFFECT 			= "lvs_capital_red_laser"
ENT.SHOOTSOUND				= Sound("weapons/corvette_fire.mp3")

ENT.PRIMARYDAMAGE			= 60
ENT.SHOOTDELAY1 			= 3
ENT.SEARCHSIZE				= 30000
ENT.LOSE_DIST 				= 31000
ENT.TURRETFORWARDSEARCH 	= 30600

ENT.EXPLOSION_SCALE_MIN		= 4
ENT.EXPLOSION_SCALE_MAX		= 8

ENT.TURRETS = 
{
	[1] = Vector(-1500,-40,500),
	[2] = Vector(-1500,-40,-350),
}

ENT.TURRETANGLES = 
{
	[1] = Angle(0,180,0),
	[2] = Angle(0,180,180),
}

ENT.BOMBS = 
{
	{forward = 300, right = 0, up = 0},
	{forward = 1200, right = 0, up = 0},
	{forward = 0, right = 0, up = 0},
	{forward = -300, right = 0, up = 0},
	{forward = -1200, right = 0, up = 0},
}
--PATH lua/entities/aura_lvs_hardcell/shared.lua:
return gluapack()()
--PATH lua/entities/aura_lvs_lucrehulk/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "CSI | Lucrehulk"
ENT.Category = "Aura's LVS Big Ships"

DEFINE_BASECLASS( "aura_lvs_capital_ship_base_mk2" )

ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Editable = true

ENT.Model 					= "models/salty/lucrehulk.mdl"
ENT.AITEAM 					= 1

ENT.Mass 					= 700

ENT.HealthVal 				= 1000000
ENT.MaxHealth  				= ENT.HealthVal
ENT.SPAWNNUMBER				= 1
ENT.SPAWNDELAY				= 3
ENT.SHIPSPAWNPOS 			= {forward = 5000, right = 1000, up = 1800}
ENT.ENABLETURRETS 			= false
ENT.SHOOTEFFECT 			= "lvs_capital_red_laser"
ENT.SHOOTSOUND				= Sound("weapons/mega_turbolaser.mp3")

ENT.PRIMARYDAMAGE			= 50
ENT.SHOOTDELAY1 			= 3
ENT.SEARCHSIZE				= 30000
ENT.LOSE_DIST 				= 31000
ENT.TURRETFORWARDSEARCH 	= 600

ENT.EXPLOSION_SCALE_MIN		= 4
ENT.EXPLOSION_SCALE_MAX		= 7


ENT.TURRETS = 
{

}

ENT.TURRETANGLES = 
{

}

ENT.BOMBS = 
{
	{forward = -1000, right = 0, up = 1800},
	{forward = -400, right = -1000, up = 1800},
	{forward = -500, right = 1000, up = 1800},
	{forward = -700, right = -1000, up = 1800},
	{forward = -400, right = 1000, up = 1800},
	{forward = -600, right = -1000, up = 1600},
	{forward = -100, right = 1000, up = 1600},
	{forward = 0, right = -1000, up = 1800},
	{forward = 0, right = 1000, up = 1800},
	{forward = 100, right = -1000, up = 1600},
	{forward = 400, right = 1000, up = 1600},
	{forward = 600, right = -1000, up = 1400},
	{forward = 800, right = 1000, up = 1400},
	{forward = 1000, right = -1000, up = 1800},
	{forward = 1200, right = 1000, up = 1800},
	{forward = -400, right = 1000, up = 1800},
	{forward = -600, right = 1000, up = 1800},

}
--PATH lua/entities/aura_lvs_munificent_mk2/shared.lua:
return gluapack()()
--PATH lua/entities/aura_lvs_recusant/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "CSI | Recusant"
ENT.Category = "Aura's LVS Big Ships"

DEFINE_BASECLASS( "aura_lvs_capital_ship_base_mk2" )

ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Editable = true

ENT.Model 					= "models/salty/recusant-class-destroyer.mdl"
ENT.AITEAM 					= 1

ENT.Mass 					= 700

ENT.HealthVal 				= 1000000
ENT.MaxHealth  				= ENT.HealthVal
ENT.SPAWNNUMBER				= 1
ENT.SPAWNDELAY				= 3
ENT.SHIPSPAWNPOS 			= {forward = -600, right = 1300, up = 1500}
ENT.ENABLETURRETS 			= false
ENT.SHOOTEFFECT 			= "lvs_capital_red_laser"
ENT.SHOOTSOUND				= Sound("weapons/mega_turbolaser.mp3")

ENT.PRIMARYDAMAGE			= 50
ENT.SHOOTDELAY1 			= 3
ENT.SEARCHSIZE				= 30000
ENT.LOSE_DIST 				= 31000
ENT.TURRETFORWARDSEARCH 	= 600

ENT.EXPLOSION_SCALE_MIN		= 4
ENT.EXPLOSION_SCALE_MAX		= 7


ENT.TURRETS = 
{
	[1] = Vector(-6000,430,2500),
	[2] = Vector(-6000,-430,2500),
	[3] = Vector(-1210,450,1500),
	[4] = Vector(-1210,-440,1500),
}

ENT.TURRETANGLES = 
{
	[1] = Angle(90,-90,180),
	[2] = Angle(90,90,180),
	[3] = Angle(70,-90,180),
	[4] = Angle(70,90,180),
}

ENT.BOMBS = 
{
	{forward = -6000, right = 0, up = 1800},
	{forward = -6000, right = 0, up = 1800},
	{forward = -4000, right = 0, up = 1800},
	{forward = -2000, right = 0, up = 1600},
	{forward = 0, right = 0, up = 1800},
	{forward = 2000, right = 0, up = 1600},
	{forward = 4000, right = 0, up = 1400},
	{forward = 6000, right = 0, up = 1800},
	{forward = -2000, right = 0, up = 1600},
	{forward = -4000, right = 0, up = 1800},
	{forward = -6000, right = 0, up = 1800},
}
--PATH addons/[misc] bodygroupr/lua/entities/bodyman_closet/cl_init.lua:
include("shared.lua")

function ENT:Draw()
    self:DrawModel()
end

surface.CreateFont( "nogger123", {
	font = CloseCaption_Bold,
	size = 55,
	weight = 1000
})


function ENT:Draw()
	self:DrawModel()
  
	local ply = LocalPlayer()
	local pos = self:GetPos()
	local eyePos = ply:GetPos()
	local dist = pos:Distance(eyePos)
	local alpha = math.Clamp(1500 - dist * 2.7, 0, 255)
  
	if (alpha <= 0) then return end
  
	local angle = self:GetAngles()
	local eyeAngle = ply:EyeAngles()
  
	angle:RotateAroundAxis(angle:Forward(), 90)
	angle:RotateAroundAxis(angle:Right(), -90)
  
	cam.Start3D2D(pos + self:GetUp() * 80, Angle(0, eyeAngle.y - 90, 100), 0.05)
	XeninUI:DrawNPCOverhead(self, {
	  alpha = alpha,
	  text = "Szafa z ubraniami",
	  sin = true,
	  textOffset = 0,
	  color = Color(38, 181, 110)
	})
	cam.End3D2D()
  end

--PATH addons/[misc] bodygroupr/lua/entities/bodyman_closet/shared.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/entities/boulder/cl_init.lua:
return gluapack()()
--PATH addons/[technik] darkrp-city-worker/lua/entities/cityworker_electric/shared.lua:
return gluapack()()
--PATH addons/[technik] darkrp-city-worker/lua/entities/cityworker_leak/cl_init.lua:
include( "shared.lua" )

function ENT:Initialize()
    self.emitter = ParticleEmitter( self:GetPos() )
    self.color = HSVToColor( math.random( 0, 360 ), math.Rand( 0.2, 0.6 ), math.Rand( 0, 0.3 ) )

    self.nextEmit = 0

    self.sound = CreateSound( self, "ambient/gas/steam2.wav")
    self.sound:SetSoundLevel( 53 )
    self.sound:Play()
end

function ENT:OnRemove()
    if IsValid( self.sound ) then
        self.sound:Stop()
    end
end

function ENT:Think()
    if LocalPlayer():GetPos():Distance( self:GetPos() ) > 1024 then return end
    if CurTime() > self.nextEmit then
        local smokemat = math.random( 1, 16 )
		smokemat = "particle/smokesprites_00"..( smokemat < 10 and "0"..smokemat or smokemat )

        local v = Vector( 0, 250, 0 )
        v:Rotate( self:GetAngles() )

        local smoke = self.emitter:Add( smokemat, self:LocalToWorld( Vector( 0, 0, 1 ) ) )
        smoke:SetVelocity( v )
        smoke:SetDieTime( 0.5 )
        smoke:SetStartAlpha( self.color.a )
        smoke:SetEndAlpha( 0 )
        smoke:SetAngles( AngleRand() )
        smoke:SetStartSize( math.Rand( 4, 6 ) )
        smoke:SetEndSize( math.Rand( 10, 13 ) )
        smoke:SetGravity( Vector( 0, 0, 10 ) )
        smoke:SetColor( self.color.r, self.color.g, self.color.b )
        smoke:SetAirResistance( 50 )

        self.nextEmit = CurTime() + 0.01
    end
end
--PATH gamemodes/starwarsrp/entities/entities/darkrp_cheque/cl_init.lua:
return gluapack()()
--PATH lua/entities/dc17m_at_rocket2/cl_init.lua:
 include('shared.lua')     
 //[[---------------------------------------------------------     
 //Name: Draw     Purpose: Draw the model in-game.     
 //Remember, the things you render first will be underneath!  
 //-------------------------------------------------------]]  
 function ENT:Draw()      
 // self.BaseClass.Draw(self)  
 -- We want to override rendering, so don't call baseclass.                                   
 // Use this when you need to add to the rendering.        
 self.Entity:DrawModel()       // Draw the model.   
 end
 
   function ENT:Initialize()
	pos = self:GetPos()
	self.emitter = ParticleEmitter( pos )
 end
 
 function ENT:Think()
	
	pos = self:GetPos()
		for i=0, (10) do
			local particle = self.emitter:Add( "particle/smokesprites_000"..math.random(1,9), pos + (self:GetForward() * -100 * i))
			if (particle) then
				particle:SetVelocity((self:GetForward() * -2000) )
				particle:SetDieTime( math.Rand( 1.5, 3 ) )
				particle:SetStartAlpha( math.Rand( 5, 8 ) )
				particle:SetEndAlpha( 0 )
				particle:SetStartSize( math.Rand( 40, 50 ) )
				particle:SetEndSize( math.Rand( 130, 150 ) )
				particle:SetRoll( math.Rand(0, 360) )
				particle:SetRollDelta( math.Rand(-1, 1) )
				particle:SetColor( 200 , 200 , 200 ) 
 				particle:SetAirResistance( 200 ) 
 				particle:SetGravity( Vector( 100, 0, 0 ) ) 	
			end
		
		end
end

--PATH addons/[opt] decals/lua/entities/decal/cl_init.lua:
return gluapack()()
--PATH addons/[opt] decals/lua/entities/decal/shared.lua:
ENT.Base = "base_gmodentity"
ENT.Type = "anim"
ENT.PrintName = "Decal"
ENT.Category = "Decals"
ENT.Author = "Beast"
ENT.Spawnable = true
ENT.AdminSpawnable = true

function ENT:SetupDataTables()
    self:NetworkVar( "String", 0, "URL" )
    self:NetworkVar( "Int", 0, "Opacity" )
    self:NetworkVar( "Vector", 0, "DecalColor" )
    self:NetworkVar( "Vector", 1, "Scale" )
end

--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/entities/dioxis_spawned/cl_init.lua:
return gluapack()()
--PATH lua/entities/droid_tri.lua:
ENT.RenderGroup = RENDERGROUP_BOTH
ENT.Base = "fighter_base"
ENT.Type = "vehicle"

ENT.PrintName = "Droid Tri-Fighter"
ENT.Author = "Liam0102"
ENT.Category = "Star Wars Vehicles: CIS"
ENT.AutomaticFrameAdvance = true
ENT.Spawnable = false;
ENT.AdminSpawnable = false;

ENT.EntModel = "models/tri/tri1.mdl"
ENT.Vehicle = "DroidTri"
ENT.Allegiance = "CIS";
ENT.StartHealth = 750;
list.Set("SWVehicles", ENT.PrintName, ENT);
if SERVER then

ENT.FireSound = Sound("weapons/tie_shoot.wav");
ENT.NextUse = {FireMode = CurTime(),Use = CurTime(),Fire = CurTime(),FireBlast=CurTime()};


AddCSLuaFile();
function ENT:SpawnFunction(pl, tr)
	local e = ents.Create("droid_tri");
	e:SetPos(tr.HitPos + Vector(0,0,10));
	e:SetAngles(Angle(0,pl:GetAimVector():Angle().Yaw,0));
	e:Spawn();
	e:Activate();
	return e;
end

function ENT:Initialize()

	self:SetNWInt("Health",self.StartHealth);
	
	self.WeaponLocations = {	
		BottomLeft = self:GetPos()+self:GetForward()*102+self:GetUp()*43+self:GetRight()*-87,
		BottomRight = self:GetPos()+self:GetForward()*102+self:GetUp()*43+self:GetRight()*84,
		TopMiddle = self:GetPos()+self:GetForward()*102+self:GetUp()*195+self:GetRight()*-3,
	}
	self.WeaponsTable = {};
	self.BoostSpeed = 2250;
	self.ForwardSpeed = 1500;
	self.UpSpeed = 550;
	self.AccelSpeed = 9;
	self.CanStandby = true;
	self.CanBack = true;
	self.CanRoll = false;
	self.CanStrafe = true;
	self.Cooldown = 2;
	
	self.CanShoot = true;
	self.Bullet = CreateBulletStructure(50,"red");
	self.FireDelay = 0.2;
	
	self.BaseClass.Initialize(self);
end

function ENT:Think()
	
	
	
	if(self.Inflight) then
		if(IsValid(self.Pilot)) then
			if(self.Pilot:KeyDown(IN_ATTACK2)) then
				local pos = self:GetPos()+self:GetForward()*185+self:GetUp()*95+self:GetRight()*-3;
				self:FireBlast(pos,false,8,600,false,20);
			end

		end
	end
	
	self.BaseClass.Think(self);

end

end

if CLIENT then

	function ENT:Draw() self:DrawModel() end
	
	ENT.EnginePos = {}
	ENT.Sounds={
		Engine=Sound("vehicles/droid/droid_fly.wav"),
	}
	
	function ENT:Initialize()
		self.Emitter = ParticleEmitter(self:GetPos());
		self.BaseClass.Initialize(self);
	end
	
	ENT.ViewDistance = 700;
    ENT.ViewHeight = 200;
	
	function ENT:FlightEffects()
		local normal = (self:GetForward() * -1):GetNormalized()
		local roll = math.Rand(-90,90)
		local p = LocalPlayer()		
		local FWD = self:GetForward();
		local id = self:EntIndex();
		
		self.EnginePos = {
			self:GetPos()+self:GetForward()*-170+self:GetUp()*75+self:GetRight()*-30,
			self:GetPos()+self:GetForward()*-170+self:GetUp()*130+self:GetRight()*-3,
			self:GetPos()+self:GetForward()*-170+self:GetUp()*75+self:GetRight()*27,
		}

		for k,v in pairs(self.EnginePos) do
			
			local blue = self.FXEmitter:Add("sprites/bluecore",v+FWD*-5)
			blue:SetVelocity(normal)
			blue:SetDieTime(0.05)
			blue:SetStartAlpha(255)
			blue:SetEndAlpha(255)
			blue:SetStartSize(20)
			blue:SetEndSize(10)
			blue:SetRoll(roll)
			blue:SetColor(255,255,255)
			
			local dynlight = DynamicLight(id + 4096*k);
			dynlight.Pos = v+FWD*-25;
			dynlight.Brightness = 5;
			dynlight.Size = 100;
			dynlight.Decay = 1024;
			dynlight.R = 100;
			dynlight.G = 100;
			dynlight.B = 255;
			dynlight.DieTime = CurTime()+1;
			
		end
	
	end
	
	
	function ENT:Think()
	
		self.BaseClass.Think(self)
		
		local p = LocalPlayer();
		local Flying = self:GetNWBool("Flying".. self.Vehicle);
		local TakeOff = self:GetNWBool("TakeOff");
		local Land = self:GetNWBool("Land");
		if(Flying) then
			if(!TakeOff and !Land) then
				self:FlightEffects();
			end
		end
		
	end

	function DroidTriReticle()
		
		local p = LocalPlayer();
		local Flying = p:GetNWBool("FlyingDroidTri");
		local self = p:GetNWEntity("DroidTri");
		if(Flying and IsValid(self)) then
			SW_HUD_DrawHull(750);
			SW_WeaponReticles(self);
			SW_HUD_DrawOverheating(self);
			SW_BlastIcon(self);
			SW_HUD_Compass(self);
			SW_HUD_DrawSpeedometer();
		end
	end
	hook.Add("HUDPaint", "DroidTriReticle", DroidTriReticle)

end
--PATH lua/entities/ent_baby_explosive2/cl_init.lua:
include("shared.lua")

function ENT:Initialize() end

function ENT:Draw()
	self:DrawModel()
end
--PATH addons/[misc] szachy/lua/entities/ent_chess_board.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/entities/ent_holocron_sith.lua:
return gluapack()()
--PATH addons/[tfres] frest_levels/lua/entities/f_leaderboard/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Leaderboard"
ENT.Category = "[fstands] Levels"
ENT.Author = "frestylek"
ENT.Purpose = ""
ENT.Information = ""

ENT.Spawnable = true
--PATH gamemodes/starwarsrp/entities/entities/fadmin_jail/shared.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/entities/g125_projectile/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.PrintName = "Fuel Rod Projectile"
ENT.Author = ""
ENT.Information = ""
ENT.Spawnable = false
ENT.AdminSpawnable = false

ENT.Model = "models/arccw/kraken/sw/explosives/world/w_impact.mdl"
ENT.FuseTime = 7
ENT.ArmTime = 0
ENT.ImpactFuse = false

AddCSLuaFile()

function ENT:Initialize()
    if SERVER then
		ParticleEffectAttach( "astw2_halo_ce_fuel_rod_trail", PATTACH_POINT_FOLLOW, self, 0 )
		-- util.SpriteTrail( self, 0, Color(255,255,255,200), false, 16, 4, 0.3, 0.01, "effects/halo_ce/shadow_beam_contrail" )
		-- util.SpriteTrail( self, 0, Color(125,255,45,200), false, 24, 4, 0.16, 0.01, "effects/halo_ce/c_gun_turret_contrail" )
        self:SetModel( self.Model )
        self:SetMoveType( MOVETYPE_VPHYSICS )
        self:SetSolid( SOLID_VPHYSICS )
        self:PhysicsInit( SOLID_VPHYSICS )
        self:SetCollisionGroup( COLLISION_GROUP_PROJECTILE )
        self:DrawShadow( true )

        local phys = self:GetPhysicsObject()
        if phys:IsValid() then
            phys:Wake()
		phys:SetMass(1)
            phys:SetBuoyancyRatio(0)
        end

        self.kt = CurTime() + self.FuseTime
        self.at = CurTime() + self.ArmTime
			self.bt = CurTime() + 1
	self.motorsound = CreateSound( self, "halo/combat_evolved/weapons/plasma_grenade_plasma_projectile_plas_grenlp1.wav")

    end
	if CLIENT then
	ParticleEffectAttach( "astw2_halo_ce_fuel_rod_trail", PATTACH_POINT_FOLLOW, self, 0 )
	end
end

function ENT:OnRemove()
    if SERVER then
        if self.motorsound:IsPlaying() then self.motorsound:Stop() end
    end
end

function ENT:Arm()
    if SERVER then
        self.motorsound:Play()
    end
end

function ENT:PhysicsCollide(data, physobj)
if SERVER then
		if data.Speed > 25 then
           self:Detonate()
		end
		end
	if self.at <= CurTime() and self.ImpactFuse then
            self:Detonate()


        end
		local effectdata = EffectData()
            effectdata:SetOrigin( self:GetPos() )
        util.Effect( "StunstickImpact", effectdata)
end


function ENT:ClientThink()
	
	do --Projectile Simulating Inclination Angles
		self:SetAngles( self:GetVelocity():Angle() + Angle(90,0,-90) )	
	end
	
     
    return 0.3
end

function ENT:Think()
    if SERVER then self:NextThink( self:ServerThink() or 0.3 ) end
    if CLIENT then self:SetNextClientThink( self:ClientThink() or 0.3 ) end
    return true
end


function ENT:ServerThink()

        if CurTime() >= self.at then
            local targets = ents.FindInSphere(self:GetPos(), 16)
            for _, k in pairs(targets) do
                if k:IsPlayer() or k:IsNPC() then
                    if self:Visible( k ) and k:Health() > 0 then
                        self:Detonate()
                    end
                elseif (k:IsValid() and scripted_ents.IsBasedOn( k:GetClass(), "base_nextbot" )) then
                    self:Detonate()
                end
            end
        end

        if CurTime() >= self.kt then
            self:Detonate()
        end
    return 0.2
end


function ENT:Detonate()
    if SERVER then
        if !self:IsValid() then return end
        local effectdata = EffectData()
            effectdata:SetOrigin( self:GetPos() )

        if self:WaterLevel() >= 1 then
            util.Effect( "WaterSurfaceExplosion", effectdata )
        else
          ParticleEffect( "astw2_halo_2_fuel_rod_explosion", self:GetPos(), self:GetAngles() )
	self:EmitSound( "halo/combat_evolved/weapons/fuelrod_expl_" .. math.random(1,3) .. ".ogg", 100, 100, 1, CHAN_WEAPON )
	util.ScreenShake(self:GetPos(),5000,100,0.5,1024)
        end

        local attacker = self

        if self.Owner:IsValid() then
            attacker = self.Owner
        end

        util.BlastDamage(self, attacker, self:GetPos(), 250, 125)

        self:Remove()
    end
end

function ENT:Draw()
    if CLIENT then
        -- self:DrawModel()


    end
end
--PATH lua/entities/gb_rp_sign/shared.lua:
return gluapack()()
--PATH lua/entities/hmp_concussionmissile.lua:
AddCSLuaFile()

ENT.Base = "lvs_protontorpedo"

ENT.Type            = "anim"

ENT.PrintName = "HMP Concussion Missile"
ENT.Author = "Luna"
ENT.Information = "sprengt dir ein zweites arschloch"
ENT.Category = "[LVS]"

ENT.Spawnable		= true
ENT.AdminOnly		= true

ENT.ExplosionEffect = "hmp_concussion_explosion"
ENT.GlowColor = Color( 255,255,255 )

if SERVER then
	function ENT:GetDamage() return
		(self._dmg or 400)
	end

	function ENT:GetRadius() 
		return (self._radius or 100)
	end

	return
end

ENT.GlowMat = Material( "sprites/light_glow02_add" )

function ENT:Enable()	
	if self.IsEnabled then return end

	self.IsEnabled = true

	self.snd = CreateSound(self, "npc/combine_gunship/gunship_crashing1.wav")
	self.snd:SetSoundLevel( 80 )
	self.snd:Play()

	local effectdata = EffectData()
		effectdata:SetOrigin( self:GetPos() )
		effectdata:SetEntity( self )
	util.Effect( "hmp_concussion_trail", effectdata )
end

function ENT:Draw()
	if not self:GetActive() then return end

	self:DrawModel()

	render.SetMaterial( self.GlowMat )

	local pos = self:GetPos()
	local dir = self:GetForward()

	for i = 0, 30 do
		local Size = ((15 - i) / 30) ^ 2 * 128

		render.DrawSprite( pos - dir * i * 7, Size, Size, self.GlowColor )
	end
end
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/entities/kraken_proj_base.lua:
return gluapack()()
--PATH lua/entities/laat_hatch/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel() 
end
--PATH lua/entities/landspeeder.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/entities/lscs_hilt_base.lua:
return gluapack()()
--PATH lua/entities/lvs_armor_penetrate.lua:
AddCSLuaFile()

ENT.Type            = "anim"

ENT.RenderGroup = RENDERGROUP_BOTH 

ENT.LifeTime = 15

if SERVER then
	local CountTotal = {}

	function ENT:Initialize()
		CountTotal[ self:EntIndex() ] = true

		local Num = table.Count( CountTotal )

		if (Num > 30 and math.random(1,2) == 1) or Num > 60 then
			self:Remove()

			return
		end

		self:SetMoveType( MOVETYPE_NONE )
		self:SetSolid( SOLID_NONE )
		self:DrawShadow( false )
		self.DieTime = CurTime() + self.LifeTime
	end

	function ENT:OnRemove()
		CountTotal[ self:EntIndex() ] = nil
	end

	function ENT:Think()
		self:NextThink( CurTime() + 0.1 )

		if not IsValid( self:GetParent() ) then self:Remove() return end

		if (self.DieTime or 0) > CurTime() then return true end

		self:Remove()

		return false
	end

	return
end

ENT.GlowMat1 = Material( "particle/particle_ring_wave_8" )
ENT.GlowMat2 = Material( "sprites/light_glow02_add" )
ENT.DecalMat = Material( "particle/particle_noisesphere" )
ENT.MatSmoke = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

local CountTotal = {}

function ENT:Initialize()
	CountTotal[ self:EntIndex() ] = true

	self.RandomAng = math.random(0,360)
	self.DieTime = CurTime() + self.LifeTime

	local Pos = self:GetPos()
	local Dir = self:GetUp()

	self.emitter = ParticleEmitter( Pos, false )

	self:EmitSound( "lvs/armor_pen_"..math.random(1,3)..".wav", 95 )
end

function ENT:Smoke()
	local T = CurTime()

	if (self.DieTime or 0) < T then return end

	if not IsValid( self.emitter ) then return end

	if (self.NextFX or 0) < T then
		self.NextFX = T + 0.2 + table.Count( CountTotal ) / 50

		local particle = self.emitter:Add( self.MatSmoke[math.random(1,#self.MatSmoke)], self:GetPos() )

		if particle then
			particle:SetVelocity( self:GetUp() * 60 + VectorRand() * 30 )
			particle:SetDieTime( math.Rand(1.5,2) )
			particle:SetAirResistance( 100 ) 
			particle:SetStartAlpha( 30 )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( 0 )
			particle:SetEndSize( 60 )
			particle:SetRollDelta( math.Rand( -1, 1 ) )
			particle:SetColor( 50,50,50 )
			particle:SetGravity( Vector( 0, 0, 200 ) )
			particle:SetCollide( false )
		end
	end
end

function ENT:Think()
	self:Smoke()
end

function ENT:OnRemove()
	CountTotal[ self:EntIndex() ] = nil

	if not IsValid(self.emitter) then return end

	self.emitter:Finish()
end

function ENT:Draw()
	local Timed = 1 - (self.DieTime - CurTime()) / self.LifeTime
	local Scale = math.max(math.min(2 - Timed * 2,1),0)

	local Scale02 = math.max(Scale - 0.8,0) / 0.2

	cam.Start3D2D( self:GetPos() + self:GetAngles():Up(), self:GetAngles(), 1 )
		surface.SetDrawColor( 255 * Scale02, (93 + 50 * Scale) * Scale02, (50 * Scale) * Scale02, (200 * Scale) * Scale02 )

		surface.SetMaterial( self.GlowMat1 )
		surface.DrawTexturedRectRotated( 0, 0, 8 , 8 , self.RandomAng )

		surface.SetMaterial( self.GlowMat2 )
		surface.DrawTexturedRectRotated( 0, 0, 16 , 16 , self.RandomAng )

		surface.SetDrawColor( 0, 0, 0, 255 )
		surface.SetMaterial( self.DecalMat )
		surface.DrawTexturedRectRotated( 0, 0, 16 , 16 , self.RandomAng )
	cam.End3D2D()
end

function ENT:DrawTranslucent()
	self:Draw()
end

--PATH lua/entities/lvs_base/sh_weapons.lua:

ENT.WEAPONS = {
	[1] = {},
}

function ENT:InitWeapons()
end

function ENT:AddWeapon( weaponData, PodID )
	if not istable( weaponData ) then print("[LVS] couldn't register weapon") return end

	local data = table.Copy( weaponData )

	if not PodID or PodID <= 1 then
		PodID = 1
	end

	if not self.WEAPONS[ PodID ] then
		self.WEAPONS[ PodID ] = {}
	end

	local default = LVS:GetWeaponPreset( "DEFAULT" )

	data.Icon = data.Icon or Material("lvs/weapons/bullet.png")
	data.Ammo = data.Ammo or -1
	data.Delay = data.Delay or FrameTime()

	if isnumber( data.Clip ) and data.Clip > 0 then
		data.HeatIsClip = true

		local ShootDelay = data.Delay

		local Clip = data.Clip
		local ReloadSpeed = data.ReloadSpeed or 2

		data.HeatRateUp = 1.00001 / (ShootDelay * Clip)
		data.HeatRateDown = 1 / ReloadSpeed
		data.OnReload = data.OnReload or default.OnReload
	else
		data.HeatRateUp = data.HeatRateUp or default.HeatRateUp
		data.HeatRateDown = data.HeatRateDown or default.HeatRateDown
	end

	data.Attack = data.Attack or default.Attack
	data.StartAttack = data.StartAttack or default.StartAttack
	data.FinishAttack = data.FinishAttack or default.FinishAttack
	data.OnSelect = data.OnSelect or default.OnSelect
	data.OnDeselect = data.OnDeselect or default.OnDeselect
	data.OnThink = data.OnThink or default.OnThink
	data.OnOverheat = data.OnOverheat or default.OnOverheat
	data.OnRemove = data.OnRemove or default.OnRemove
	data.UseableByAI = data.UseableByAI ~= false

	table.insert( self.WEAPONS[ PodID ], data )
end

function ENT:UpdateWeapon( PodID, WeaponID, weaponData )
	if not self.WEAPONS[ PodID ] then return end

	if not self.WEAPONS[ PodID ][ WeaponID ] then return end

	table.Merge( self.WEAPONS[ PodID ][ WeaponID ], weaponData )
end

function ENT:HasWeapon( ID )
	return istable( self.WEAPONS[1][ ID ] )
end

function ENT:AIHasWeapon( ID )
	local weapon = self.WEAPONS[1][ ID ]
	if not istable( weapon ) then return false end

	return weapon.UseableByAI
end

function ENT:GetActiveWeapon()
	local SelectedID = self:GetSelectedWeapon()
	local CurWeapon = self.WEAPONS[1][ SelectedID ]

	return CurWeapon, SelectedID
end

function ENT:GetMaxAmmo()
	local CurWeapon = self:GetActiveWeapon()

	if not CurWeapon then return -1 end

	return CurWeapon.Ammo or -1
end

function ENT:GetClip()
	local CurWeapon = self:GetActiveWeapon()

	if not CurWeapon then return 0 end

	local HeatIncrement = (CurWeapon.HeatRateUp or 0.2) * math.max(CurWeapon.Delay or 0, FrameTime())

	local Ammo = self:GetNWAmmo()

	if self:GetMaxAmmo() <= 0 and CurWeapon.Clip then
		Ammo = CurWeapon.Clip
	end

	return math.min( math.ceil( math.Round( (1 - self:GetNWHeat()) / HeatIncrement, 1 ) ), Ammo )
end

if SERVER then
	function ENT:WeaponRestoreAmmo()
		local AmmoIsSet = false

		for PodID, data in pairs( self.WEAPONS ) do
			for id, weapon in pairs( data ) do
				local MaxAmmo = weapon.Ammo or -1
				local CurAmmo = weapon._CurAmmo or -1

				if CurAmmo == MaxAmmo then continue end

				self.WEAPONS[PodID][ id ]._CurAmmo = MaxAmmo

				AmmoIsSet = true
			end
		end

		if AmmoIsSet then
			self:SetNWAmmo( self:GetAmmo() )

			for _, pod in pairs( self:GetPassengerSeats() ) do
				local weapon = pod:lvsGetWeapon()

				if not IsValid( weapon ) then continue end

				weapon:SetNWAmmo( weapon:GetAmmo() )
			end
		end

		return AmmoIsSet
	end
	
	function ENT:WeaponsOnRemove()
		for _, data in pairs( self.WEAPONS ) do
			for ID, Weapon in pairs( data ) do
				if not Weapon.OnRemove then continue end

				Weapon.OnRemove( self )
			end
		end
	end

	function ENT:WeaponsFinish()
		if not self._activeWeapon then return end

		local CurWeapon = self.WEAPONS[1][ self._activeWeapon ]

		if not CurWeapon then return end

		if CurWeapon.FinishAttack then
			CurWeapon.FinishAttack( self )
		end

		self._activeWeapon = nil
		self.OldAttack = false
	end

	function ENT:GetAmmo()
		if self:GetAI() then return self:GetMaxAmmo() end

		local CurWeapon = self:GetActiveWeapon()

		if not CurWeapon then return -1 end

		return CurWeapon._CurAmmo or self:GetMaxAmmo()
	end

	function ENT:TakeAmmo( num )
		if self:GetMaxAmmo() <= 0 then return end

		local CurWeapon = self:GetActiveWeapon()

		CurWeapon._CurAmmo = math.max( self:GetAmmo() - (num or 1), 0 )

		self:SetNWAmmo( CurWeapon._CurAmmo )
	end

	function ENT:GetHeat( weaponid )
		local CurWeapon

		if isnumber( weaponid ) and weaponid > 0 then
			CurWeapon = self.WEAPONS[1][ weaponid ]
		else
			CurWeapon = self:GetActiveWeapon()
		end

		if not CurWeapon then return 0 end

		return (CurWeapon._CurHeat or 0)
	end

	function ENT:GetOverheated()
		local CurWeapon = self:GetActiveWeapon()

		if not CurWeapon then return false end

		return CurWeapon.Overheated == true
	end

	function ENT:SetOverheated( overheat )
		if self:GetOverheated() == overheat then return end

		local CurWeapon = self:GetActiveWeapon()

		if not CurWeapon then return end

		CurWeapon.Overheated = overheat

		self:SetNWOverheated( overheat )

		if self:GetHeat() == 0 then return end

		if CurWeapon.OnOverheat then
			CurWeapon.OnOverheat( self )
		end
	end

	function ENT:SetHeat( heat )
		local CurWeapon = self:GetActiveWeapon()

		if not CurWeapon then return end

		heat = math.Clamp( heat, 0, 1 )

		CurWeapon._CurHeat = heat

		if self:GetNWHeat() == heat then return end

		self:SetNWHeat( heat )
	end

	function ENT:CanAttack()
		local CurWeapon = self:GetActiveWeapon()

		return (CurWeapon._NextFire or 0) < CurTime()
	end

	function ENT:SetNextAttack( time )
		local CurWeapon = self:GetActiveWeapon()

		CurWeapon._NextFire = time
	end

	function ENT:WeaponsShouldFire()
		if self:GetAI() then return self._AIFireInput end

		local ply = self:GetDriver()

		if not IsValid( ply ) then return false end

		return ply:lvsKeyDown( "ATTACK" )
	end

	function ENT:WeaponsThink()
		local EntTable = self:GetTable()

		local T = CurTime()
		local FT = FrameTime()
		local CurWeapon, SelectedID = self:GetActiveWeapon()
	
		for ID, Weapon in pairs( EntTable.WEAPONS[1] ) do
			local IsActive = ID == SelectedID

			if Weapon.OnThink then Weapon.OnThink( self, IsActive ) end

			if IsActive then continue end

			if Weapon.HeatIsClip and not Weapon.Overheated and Weapon._CurHeat ~= 0 then
				Weapon.Overheated = true
				Weapon._CurHeat = 1

				if Weapon.OnReload then Weapon.OnReload( self ) end
			end

			-- cool all inactive weapons down
			Weapon._CurHeat = Weapon._CurHeat and Weapon._CurHeat - math.min( Weapon._CurHeat, (Weapon.HeatRateDown or 0.25) * FT ) or 0
		end

		if not CurWeapon then return end

		local ShouldFire = self:WeaponsShouldFire()
		local CurHeat = self:GetHeat()

		if self:GetOverheated() then
			if CurHeat <= 0 then
				self:SetOverheated( false )
			else
				ShouldFire = false
			end
		else
			if CurHeat >= 1 then
				self:SetOverheated( true )
				ShouldFire = false
				if CurWeapon.OnReload then CurWeapon.OnReload( self ) end
			end
		end

		if self:GetMaxAmmo() > 0 then
			if self:GetAmmo() <= 0 then
				ShouldFire = false
			end
		end

		if ShouldFire ~= EntTable.OldAttack then
			EntTable.OldAttack = ShouldFire

			if ShouldFire then
				if CurWeapon.StartAttack then
					CurWeapon.StartAttack( self )
				end
				EntTable._activeWeapon = SelectedID
			else
				self:WeaponsFinish()
			end
		end

		if ShouldFire then
			if not self:CanAttack() then return end

			local ShootDelay = (CurWeapon.Delay or 0)

			self:SetNextAttack( T + ShootDelay )
			self:SetHeat( CurHeat + (CurWeapon.HeatRateUp or 0.2) * math.max(ShootDelay, FT) )

			if not CurWeapon.Attack then return end

			if CurWeapon.Attack( self ) then
				self:SetHeat( CurHeat - math.min( self:GetHeat(), (CurWeapon.HeatRateDown or 0.25) * FT ) )
				self:SetNextAttack( T )
			end

			EntTable._lvsNextActiveWeaponCoolDown = T + 0.25
		else
			if (EntTable._lvsNextActiveWeaponCoolDown or 0) > T then return end

			if CurWeapon.HeatIsClip and not CurWeapon.Overheated then

				self:SetHeat( self:GetHeat() )
	
				return
			end

			self:SetHeat( self:GetHeat() - math.min( self:GetHeat(), (CurWeapon.HeatRateDown or 0.25) * FT ) )
		end
	end

	function ENT:SelectWeapon( ID )
		if not isnumber( ID ) then return end

		if self.WEAPONS[1][ ID ] then
			self:SetSelectedWeapon( ID )
		end

		local ply = self:GetDriver()

		if not IsValid( ply ) then return end

		net.Start( "lvs_select_weapon" )
		net.Send( ply )
	end

	function ENT:OnWeaponChanged( name, old, new)
		if new == old then return end

		self:WeaponsFinish()

		local PrevWeapon = self.WEAPONS[1][ old ]
		if PrevWeapon and PrevWeapon.OnDeselect then
			PrevWeapon.OnDeselect( self, new )
		end

		local NextWeapon = self.WEAPONS[1][ new ]
		if NextWeapon and NextWeapon.OnSelect then
			NextWeapon.OnSelect( self, old )
			self:SetNWAmmo( NextWeapon._CurAmmo or NextWeapon.Ammo or -1 )
			self:SetNWOverheated( NextWeapon.Overheated == true )
		end
	end

	return
end

function ENT:DrawWeaponIcon( PodID, ID, x, y, width, height, IsSelected, IconColor )
end

function ENT:SelectWeapon( ID )
	if not isnumber( ID ) then return end

	net.Start( "lvs_select_weapon" )
		net.WriteInt( ID, 5 )
		net.WriteBool( false )
	net.SendToServer()
end

function ENT:NextWeapon()
	net.Start( "lvs_select_weapon" )
		net.WriteInt( 1, 5 )
		net.WriteBool( true )
	net.SendToServer()
end

function ENT:PrevWeapon()
	net.Start( "lvs_select_weapon" )
		net.WriteInt( -1, 5 )
		net.WriteBool( true )
	net.SendToServer()
end

LVS:AddHudEditor( "WeaponSwitcher", ScrW() - 210, ScrH() - 165,  200, 68, 200, 68, "WEAPON SELECTOR", 
	function( self, vehicle, X, Y, W, H, ScrX, ScrY, ply )
		if not vehicle.LVSHudPaintWeapons then return end
		vehicle:LVSHudPaintWeapons( X, Y, W, H, ScrX, ScrY, ply )
	end
)

LVS:AddHudEditor( "WeaponInfo", ScrW() - 230, ScrH() - 85,  220, 75, 220, 75, "WEAPON INFO", 
	function( self, vehicle, X, Y, W, H, ScrX, ScrY, ply )
		if not vehicle.LVSHudPaintWeaponInfo then return end

		vehicle:LVSHudPaintWeaponInfo( X, Y, W, H, ScrX, ScrY, ply )
	end
)

function ENT:GetAmmoID( ID )
	local ply = LocalPlayer()

	if not IsValid( ply ) then return end

	local Base = ply:lvsGetWeaponHandler()

	if not IsValid( Base ) then return -1 end

	local selected = Base:GetSelectedWeapon()
	local weapon = self.WEAPONS[ Base:GetPodIndex() ][ ID ]

	if ID == selected then
		weapon._CurAmmo = Base:GetNWAmmo()
	else
		weapon._CurAmmo = weapon._CurAmmo or weapon.Ammo or -1
	end

	return weapon._CurAmmo
end


local Circles = {
	[1] = {r = -1, col = Color(0,0,0,200)},
	[2] = {r = 0, col = Color(255,255,255,200)},
	[3] = {r = 1, col = Color(255,255,255,255)},
	[4] = {r = 2, col = Color(255,255,255,200)},
	[5] = {r = 3, col = Color(0,0,0,200)},
}

local function DrawCircle( X, Y, target_radius, heatvalue, overheated )
	local endang = 360 * heatvalue

	if endang == 0 then return end

	for i = 1, #Circles do
		local data = Circles[ i ]
		local radius = target_radius + data.r
		local segmentdist = endang / ( math.pi * radius / 2 )

		for a = 0, endang, segmentdist do
			local r = data.col.r
			local g = data.col.g * (1 - math.min(a / 270,1))
			local b = data.col.b * (1 - math.min(a / 90,1))

			surface.SetDrawColor( r, g, b, data.col.a )

			surface.DrawLine( X - math.sin( math.rad( a ) ) * radius, Y + math.cos( math.rad( a ) ) * radius, X - math.sin( math.rad( a + segmentdist ) ) * radius, Y + math.cos( math.rad( a + segmentdist ) ) * radius )
		end
	end
end

ENT.HeatMat = Material( "lvs/heat.png" )
ENT.HeatIsClipMat = Material( "lvs/3d2dmats/refil.png" )

local color_white = color_white
local color_red = Color(255,0,0,255)

function ENT:LVSHudPaintWeaponInfo( X, Y, w, h, ScrX, ScrY, ply )
	local Base = ply:lvsGetWeaponHandler()

	if not IsValid( Base ) then return end

	local ID = Base:GetSelectedWeapon()

	if not Base:HasWeapon( ID ) then return end

	local Weapon = Base:GetActiveWeapon()
	local Heat = Base:GetNWHeat()
	local OverHeated = Base:GetNWOverheated()
	local Ammo = Base:GetNWAmmo()

	if Weapon and Weapon.HeatIsClip then
		local Pod = ply:GetVehicle()

		if not IsValid( Pod ) then return end

		local PodID = Base:GetPodIndex()

		local FT = FrameTime()
		local ShootDelay = math.max(Weapon.Delay or 0, FT)
		local HeatIncrement = (Weapon.HeatRateUp or 0.2) * ShootDelay

		local Clip = Base:GetClip()

		if OverHeated then
			Clip = 0

			local hX = X + w - h * 0.5
			local hY = Y + h * 0.25 + h * 0.25
	
			surface.SetMaterial( self.HeatIsClipMat )
			surface.SetDrawColor( 0, 0, 0, 200 )
			surface.DrawTexturedRectRotated( hX + 3, hY + 1, h, h, 0 )
			surface.SetDrawColor( 255, 0, 0, 255 )
			surface.DrawTexturedRectRotated( hX + 1, hY - 1, h, h, 0 )

			DrawCircle( hX, hY, h * 0.35, Heat )
		end

		Ammo = Ammo - Clip

		local ColDyn = (Clip == 0 or OverHeated) and color_red or color_white

		draw.DrawText( "AMMO ", "LVS_FONT", X + 72, Y + 35, ColDyn, TEXT_ALIGN_RIGHT )

		draw.DrawText( Clip, "LVS_FONT_HUD_LARGE", X + 72, Y + 20, ColDyn, TEXT_ALIGN_LEFT )

		if Base:GetMaxAmmo() <= 0 then return end

		local ColDyn2 = Ammo <= Weapon.Clip and color_red or color_white

		X = X + math.max( (#string.Explode( "", Clip ) - 1) * 18, 0 )

		draw.DrawText( "/", "LVS_FONT_HUD_LARGE", X + 96, Y + 30, ColDyn2, TEXT_ALIGN_LEFT )

		draw.DrawText( Ammo, "LVS_FONT", X + 110, Y + 40, ColDyn2, TEXT_ALIGN_LEFT )

		return
	end

	local hX = X + w - h * 0.5
	local hY = Y + h * 0.25 + h * 0.25
	local hAng = math.cos( CurTime() * 50 ) * 5 * (OverHeated and 1 or Heat ^ 2)

	surface.SetMaterial( self.HeatMat )
	surface.SetDrawColor( 0, 0, 0, 200 )
	surface.DrawTexturedRectRotated( hX + 4, hY + 1, h * 0.5, h * 0.5, hAng )

	if OverHeated then
		surface.SetDrawColor( 255, 0, 0, 255 )
	else
		surface.SetDrawColor( 255, 255 * (1 - Heat), 255 * math.max(1 - Heat * 1.5,0), 255 )
	end

	surface.DrawTexturedRectRotated( hX + 2, hY - 1, h * 0.5, h * 0.5, hAng )

	DrawCircle( hX, hY, h * 0.35, Heat )

	if Base:GetMaxAmmo() <= 0 then return end

	draw.DrawText( "AMMO ", "LVS_FONT", X + 72, Y + 35, color_white, TEXT_ALIGN_RIGHT )
	draw.DrawText( Ammo, "LVS_FONT_HUD_LARGE", X + 72, Y + 20, color_white, TEXT_ALIGN_LEFT )
end

function ENT:LVSHudPaintWeapons( X, Y, w, h, ScrX, ScrY, ply )
	local EntTable = self:GetTable()

	local Base = ply:lvsGetWeaponHandler()

	if not IsValid( Base ) then return end

	local Pod = ply:GetVehicle()

	if not IsValid( Pod ) then return end

	local PodID = Base:GetPodIndex()

	local num = #self.WEAPONS[ PodID ]

	if num <= 1 then return end

	local CenterY = (Y + h * 0.5)
	local CenterX = (X + w * 0.5)

	local FlatSelector = CenterX > ScrX * 0.333 and CenterX < ScrX * 0.666

	local T = CurTime()
	local FT = RealFrameTime()

	local gap = 4
	local SizeY = h - gap

	local Selected = Base:GetSelectedWeapon()
	if Selected ~= EntTable._OldSelected then
		EntTable._OldSelected = Selected
		Pod._SelectActiveTime = T + 2
	end

	local tAlpha = (Pod._SelectActiveTime or 0) > T and 1 or 0
	local tAlphaRate = FT * 15

	EntTable.smAlphaSW = EntTable.smAlphaSW and (EntTable.smAlphaSW + math.Clamp(tAlpha - EntTable.smAlphaSW,-tAlphaRate,tAlphaRate)) or 0

	if EntTable.smAlphaSW > 0.95 then
		EntTable._DisplaySelected = Selected
	else
		EntTable._DisplaySelected = EntTable._DisplaySelected or Selected
	end

	local A255 = 255 * EntTable.smAlphaSW
	local A150 = 150 * EntTable.smAlphaSW

	local Col = Color(0,0,0,A150)
	local ColSelect = Color(255,255,255,A150)

	local SwapY = 0

	if Y < (ScrY * 0.5 - h * 0.5) then
		SwapY = 1
	end

	for ID = 1, num do
		local IsSelected = EntTable._DisplaySelected == ID
		local n = num - ID
		local xPos = FlatSelector and X + (w + gap) * (ID - 1) - ((w + gap) * 0.5 * num - w * 0.5) or X
		local yPos = FlatSelector and Y - h * math.min(SwapY,0) or Y - h * n + (num - 1) * h * SwapY

		draw.RoundedBox(5, xPos, yPos, w, SizeY, IsSelected and ColSelect or Col )

		if IsSelected then
			surface.SetDrawColor( 0, 0, 0, A255 )
		else
			surface.SetDrawColor( 255, 255, 255, A255 )
		end

		if isbool( EntTable.WEAPONS[PodID][ID].Icon ) then
			local col = IsSelected and Color(255,255,255,A255) or Color(0,0,0,A255) 
			self:DrawWeaponIcon( PodID, ID, xPos, yPos, SizeY * 2, SizeY, IsSelected, col )
		else
			surface.SetMaterial( self.WEAPONS[PodID][ID].Icon )
			surface.DrawTexturedRect( xPos, yPos, SizeY * 2, SizeY )
		end

		local ammo = self:GetAmmoID( ID )

		if ammo > -1 then
			draw.DrawText( ammo, "LVS_FONT_HUD", xPos + w - 10, yPos + SizeY * 0.5 - 10, IsSelected and Color(0,0,0,A255) or Color(255,255,255,A255), TEXT_ALIGN_RIGHT )
		else
			draw.DrawText( "O", "LVS_FONT_HUD", xPos + w - 19, yPos + SizeY * 0.5 - 10, IsSelected and Color(0,0,0,A255) or Color(255,255,255,A255), TEXT_ALIGN_RIGHT )
			draw.DrawText( "O", "LVS_FONT_HUD", xPos + w - 10, yPos + SizeY * 0.5 - 10, IsSelected and Color(0,0,0,A255) or Color(255,255,255,A255), TEXT_ALIGN_RIGHT )
		end
	end
end
--PATH lua/entities/lvs_base_fakehover/cl_init.lua:
return gluapack()()
--PATH lua/entities/lvs_base_fakehover/cl_hud.lua:

ENT.IconEngine = Material( "lvs/engine.png" )

function ENT:LVSHudPaintInfoText( X, Y, W, H, ScrX, ScrY, ply )
	local kmh = math.Round(self:GetVelocity():Length() * 0.09144,0)
	draw.DrawText( "km/h ", "LVS_FONT", X + 72, Y + 35, color_white, TEXT_ALIGN_RIGHT )
	draw.DrawText( kmh, "LVS_FONT_HUD_LARGE", X + 72, Y + 20, color_white, TEXT_ALIGN_LEFT )

	if ply ~= self:GetDriver() then return end

	local hX = X + W - H * 0.5
	local hY = Y + H * 0.25 + H * 0.25

	surface.SetMaterial( self.IconEngine )
	surface.SetDrawColor( 0, 0, 0, 200 )
	surface.DrawTexturedRectRotated( hX + 4, hY + 1, H * 0.5, H * 0.5, 0 )
	surface.SetDrawColor( color_white )
	surface.DrawTexturedRectRotated( hX + 2, hY - 1, H * 0.5, H * 0.5, 0 )

	if not self:GetEngineActive() then
		draw.SimpleText( "X" , "LVS_FONT",  hX, hY, Color(0,0,0,255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	else
		self:LVSDrawCircle( hX, hY, H * 0.35, self:GetThrottle() )
	end
end

function ENT:LVSPreHudPaint( X, Y, ply )
	return true
end

local zoom = 0
local zoom_mat = Material( "vgui/zoom" )

function ENT:PaintZoom( X, Y, ply )
	local TargetZoom = ply:lvsKeyDown( "ZOOM" ) and 1 or 0

	zoom = zoom + (TargetZoom - zoom) * RealFrameTime() * 10

	X = X * 0.5
	Y = Y * 0.5

	surface.SetDrawColor( Color(255,255,255,255 * zoom) )
	surface.SetMaterial(zoom_mat ) 
	surface.DrawTexturedRectRotated( X + X * 0.5, Y * 0.5, X, Y, 0 )
	surface.DrawTexturedRectRotated( X + X * 0.5, Y + Y * 0.5, Y, X, 270 )
	surface.DrawTexturedRectRotated( X * 0.5, Y * 0.5, Y, X, 90 )
	surface.DrawTexturedRectRotated( X * 0.5, Y + Y * 0.5, X, Y, 180 )
end

function ENT:LVSHudPaint( X, Y, ply )
	if not self:LVSPreHudPaint( X, Y, ply ) then return end

	self:PaintZoom( X, Y, ply )
end

--PATH lua/entities/lvs_base_starfighter/cl_init.lua:
return gluapack()()
--PATH lua/entities/lvs_base_starfighter/cl_deathsound.lua:
return gluapack()()
--PATH lua/entities/lvs_base_starfighter/cl_deathsound.lua:

function ENT:OnDestroyed()
	if not self.DeathSound then return end

	if self:GetVelocity():Length() <= self.MaxVelocity * 0.5 then return end

	self._sndDeath = CreateSound( self, self.DeathSound )
	self._sndDeath:SetSoundLevel( 125 )
	self._sndDeath:PlayEx( 1, 50 + 50 * self:CalcDoppler( LocalPlayer() ) )
end

function ENT:StopDeathSound()
	if not self._sndDeath then return end

	self._sndDeath:Stop()
end


--PATH lua/entities/lvs_base_turret/cl_camera.lua:
return gluapack()()
--PATH lua/entities/lvs_bomb.lua:
return gluapack()()
--PATH lua/entities/lvs_dwarfdroid/cl_prediction.lua:

function ENT:PredictPoseParamaters()
	local pod = self:GetTurretSeat()

	if not IsValid( pod ) then return end

	local plyL = LocalPlayer()
	local ply = pod:GetDriver()

	if ply ~= plyL then return end

	self:SetPosTurret()
	self:SetPoseParameterTurret( pod:lvsGetWeapon() )
end
--PATH lua/entities/lvs_fakehover_iftx/cl_prediction.lua:
return gluapack()()
--PATH lua/entities/lvs_fakehover_soundemitter.lua:
return gluapack()()
--PATH lua/entities/lvs_item_ammocrate.lua:
return gluapack()()
--PATH lua/entities/lvs_laatle_patrolgunship_rep/shared.lua:
ENT.Base = "lvs_base_repulsorlift"

ENT.PrintName = "LAAT/le Gunship"
ENT.Author = "Durian"
ENT.Information = ""
ENT.Category = "[LVS] - Republic Vehicles"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/kingpommes/starwars/patrol_transport/main.mdl"
ENT.GibModels = {
}

ENT.AITEAM = 1

ENT.MaxVelocity = 1250
ENT.MaxThrust = 1250

ENT.MaxPitch = 60

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 2

ENT.TurnRatePitch = 0.7
ENT.TurnRateYaw = 0.7
ENT.TurnRateRoll = 0.66

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 700
ENT.MaxShield = 400

function ENT:OnSetupDataTables()
	self:AddDT( "Bool", "WingsDown" )
	self:AddDT( "Entity", "GunnerSeat" )
	self:AddDT( "Bool", "SpotlightToggle" )
	self:AddDT( "Bool", "DoorsClose")

	if SERVER or CLIENT then
		self:NetworkVarNotify( "WingsDown", self.OnWingsChanged )
	end
end

function ENT:InitWeapons()

	local weapon = {}
		weapon.Icon = Material("lvs/weapons/concussionmissile.png")
		weapon.Ammo = 20
		weapon.Delay = 0 -- this will turn weapon.Attack to a somewhat think function
		weapon.HeatRateUp = -0.5 -- cool down when attack key is held. This system fires on key-release.
		weapon.HeatRateDown = 0.25
		weapon.Attack = function( ent )
			local T = CurTime()

			if IsValid( ent._ConcussionMissile ) then
				if (ent._nextMissleTracking or 0) > T then return end

				ent._nextMissleTracking = T + 0.1 -- 0.1 second interval because those find functions can be expensive

				ent._ConcussionMissile:FindTarget( ent:GetPos(), ent:GetForward(), 30, 7500 )

				return
			end

			if (ent._nextMissle or 0) > T then return end

			ent._nextMissle = T + 0.5

			ent._swapMissile = not ent._swapMissile

			local Pos = Vector( 180, (ent._swapMissile and -35 or 35), 20 )Vector(180.79,35.9,22.68)

			local Driver = self:GetDriver()

			local projectile = ents.Create( "lvs_concussionmissile" )
			projectile:SetPos( ent:LocalToWorld( Pos ) )
			projectile:SetAngles( ent:GetAngles() )
			projectile:SetParent( ent )
			projectile:Spawn()
			projectile:Activate()
			projectile:SetAttacker( IsValid( Driver ) and Driver or self )
			projectile:SetEntityFilter( ent:GetCrosshairFilterEnts() )
			projectile:SetSpeed( ent:GetVelocity():Length() + 4000 )
			projectile:SetDamage( 800 )
			projectile:SetRadius( 300 )

			ent._ConcussionMissile = projectile

			ent:SetNextAttack( CurTime() + 0.1 ) -- wait 0.1 second before starting to track
		end
		weapon.FinishAttack = function( ent )
			if not IsValid( ent._ConcussionMissile ) then return end

			local projectile = ent._ConcussionMissile

			projectile:Enable()
			projectile:EmitSound( "lvs/vehicles/vulturedroid/fire_missile.mp3", 125 )
			ent:TakeAmmo()

			ent._ConcussionMissile = nil

			local NewHeat = ent:GetHeat() + 0.75

			ent:SetHeat( NewHeat )
			if NewHeat >= 1 then
				ent:SetOverheated( true )
			end
		end
		weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
		weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/vehicles/imperial/overheat.wav") end
	self:AddWeapon( weapon )

	local weapon = {}		
		weapon.Icon = Material("lvs/weapons/dual_hmg.png")
		weapon.Ammo = 1250
		weapon.Delay = 0.25
		weapon.HeatRateUp = 0.3
		weapon.HeatRateDown = 0.3
		weapon.Attack = function( ent )
			local pod = ent:GetDriverSeat()

			if not IsValid( pod ) then return end

			if ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) >= 61 then return true end

			ent.FirePositions = {
				Vector(180.79,-35.9,22.68),
				Vector(180.79,35.9,22.68)
,
			}
			
			
			ent.NumPrim = ent.NumPrim and ent.NumPrim + 1 or 1
			if ent.NumPrim > #ent.FirePositions then ent.NumPrim = 1 end

			local startpos = pod:LocalToWorld( pod:OBBCenter() )
			local trace = ent:GetEyeTrace()

			local bullet = {}
			bullet.Src 	= ent:LocalToWorld( ent.FirePositions[ent.NumPrim] )
			bullet.Dir 	= (trace.HitPos - bullet.Src):GetNormalized()
			bullet.Spread 	= Vector( 0.01,  0.01, 0.01 )
			bullet.TracerName = "lvs_laser_green"
			bullet.Force	= 10
			bullet.HullSize 	= 25
			bullet.Damage	= 60
			bullet.SplashDamage = 200
			bullet.SplashDamageRadius = 70
			bullet.Velocity = 60000
			bullet.Attacker 	= ent:GetDriver()
			bullet.Callback = function(att, tr, dmginfo)
				local effectdata = EffectData()
					effectdata:SetStart( Vector(50,255,50) ) 
					effectdata:SetOrigin( tr.HitPos )
					effectdata:SetNormal( tr.HitNormal )
				util.Effect( "lvs_laser_impact", effectdata )
			end
			ent:LVSFireBullet( bullet )

			local effectdata = EffectData()
			effectdata:SetStart( Vector(50,255,50) )
			effectdata:SetOrigin( bullet.Src )
			effectdata:SetNormal( ent:GetForward() )
			effectdata:SetEntity( ent )
			util.Effect( "lvs_muzzle_colorable", effectdata )

			ent:TakeAmmo()

			veh = ent:GetVehicle()

			veh.PrimarySND:PlayOnce( 100 + math.cos( CurTime() + self:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
		end
		weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
		weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/vehicles/imperial/overheat.wav") end
		weapon.CalcView = function( ent, ply, pos, angles, fov, pod )
			local base = ent:GetVehicle()

			if not IsValid( base ) then 
				return LVS:CalcView( ent, ply, pos, angles, fov, pod )
			end

			if pod:GetThirdPersonMode() then
				pos = pos + base:GetUp() * 100
			end

			return LVS:CalcView( base, ply, pos, angles, fov, pod )
		end
		weapon.HudPaint = function( ent, X, Y, ply )
			local Col = (ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) > 60) and COLOR_RED or COLOR_WHITE

			local Pos2D = ent:GetEyeTrace().HitPos:ToScreen() 

			local base = ent:GetVehicle()
			base:PaintCrosshairCenter( Pos2D, Col )
			base:PaintCrosshairOuter( Pos2D, Col )
			base:LVSPaintHitMarker( Pos2D )
		end
		weapon.CalcView = function( ent, ply, pos, angles, fov, pod )
			local view = {}
			view.origin = pos
			view.angles = angles
			view.fov = fov
			view.drawviewer = false

			local mn = self:OBBMins()
			local mx = self:OBBMaxs()
			local radius = ( mn - mx ):Length()
			local radius = radius + radius * pod:GetCameraDistance()

			local clamped_angles = pod:WorldToLocalAngles( angles )
			clamped_angles.p = math.max( clamped_angles.p, -20 )
			clamped_angles = pod:LocalToWorldAngles( clamped_angles )

			local StartPos = self:LocalToWorld( Vector(-150,0,150) ) + clamped_angles:Up() * 150
			local EndPos = StartPos - clamped_angles:Forward() * radius + clamped_angles:Up() * radius * 0.2

			local WallOffset = 4

			local tr = util.TraceHull( {
				start = StartPos,
				endpos = EndPos,
				filter = function( e )
					local c = e:GetClass()
					local collide = not c:StartWith( "prop_physics" ) and not c:StartWith( "prop_dynamic" ) and not c:StartWith( "prop_ragdoll" ) and not e:IsVehicle() and not c:StartWith( "gmod_" ) and not c:StartWith( "lvs_" ) and not c:StartWith( "player" ) and not e.LVS

					return collide
				end,
				mins = Vector( -WallOffset, -WallOffset, -WallOffset ),
				maxs = Vector( WallOffset, WallOffset, WallOffset ),
			} )

			view.angles = angles + Angle(5,0,0)
			view.origin = tr.HitPos
			view.drawviewer = true

			if tr.Hit and  not tr.StartSolid then
				view.origin = view.origin + tr.HitNormal * WallOffset
			end

			return view
		end
	self:AddWeapon( weapon, 2 )

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/spotlight.png")
	weapon.Ammo = -1
	weapon.Delay = 0.1
	weapon.HeatRateUp = 0
	weapon.HeatRateDown = 1
	weapon.StartAttack = function( ent )
		if self:GetSpotlightToggle() == true then
			self:SetSpotlightToggle(false)
		else
			self:SetSpotlightToggle(true)
		end
	end
	self:AddWeapon( weapon )

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/gunship_sidedoor.png")
	weapon.Ammo = -1
	weapon.Delay = 0
	weapon.HeatRateUp = 0
	weapon.HeatRateDown = 0
	weapon.StartAttack = function( ent )
		if self:GetAI() then return end
	
		if self.t1 > CurTime() then return end
		if(self.Doors:GetSequence() == self.Doors:LookupSequence("DoorsOpen")) then
			self.Doors:ResetSequence(self.Doors:LookupSequence("DoorsClose"))
			self:SetDoorsClose(false)
		else				
			self.Doors:ResetSequence(self.Doors:LookupSequence("DoorsOpen"))
			self:SetDoorsClose(true)
		end
		self.t1 = CurTime() + 0.5
	end
	self:AddWeapon( weapon )
end

ENT.FlyByAdvance = 0.5
ENT.FlyBySound = "lvs/vehicles/laat/flyby"..math.random(1,2,3,4,5)..".wav"

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/laat/loop.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
	{
		sound = "^lvs/vehicles/laat/dist.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0.35,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		VolumeMin = 0,
		VolumeMax = 1,
		SoundLevel = 110,
	},
}

function ENT:CalcMainActivity( ply )
	local Pod = ply:GetVehicle()

	if Pod == self:GetDriverSeat() or Pod == self:GetGunnerSeat() then return end

	if ply.m_bWasNoclipping then 
		ply.m_bWasNoclipping = nil 
		ply:AnimResetGestureSlot( GESTURE_SLOT_CUSTOM ) 

		if CLIENT then 
			ply:SetIK( true )
		end 
	end 

	ply.CalcIdeal = ACT_STAND
	ply.CalcSeqOverride = ply:LookupSequence( "idle_all_02" )

	if ply:GetAllowWeaponsInVehicle() and IsValid( ply:GetActiveWeapon() ) then

		local holdtype = ply:GetActiveWeapon():GetHoldType()

		if holdtype == "smg" then 
			holdtype = "smg1"
		end

		local seqid = ply:LookupSequence( "idle_" .. holdtype )

		if seqid ~= -1 then
			ply.CalcSeqOverride = seqid
		end
	end

	return ply.CalcIdeal, ply.CalcSeqOverride
end
--PATH lua/entities/lvs_pro/cl_init.lua:
include("shared.lua")

function ENT:Initialize()
end

function ENT:CalcEngineSound( RPM, Pitch, Doppler )
	if self.ENG then
		self.ENG:ChangePitch(  math.Clamp(math.Clamp(  60 + Pitch * 50, 80,255) + Doppler,0,255) )
		self.ENG:ChangeVolume( math.Clamp( -1 + Pitch * 6, 0.5,1) )
	end
	
	if self.DIST then
		self.DIST:ChangePitch(  math.Clamp(math.Clamp(  50 + Pitch * 60, 50,255) + Doppler,0,255) )
		self.DIST:ChangeVolume( math.Clamp( -1 + Pitch * 6, 0,1) )
	end
end

function ENT:OnRemove()
	self:SoundStop()
end

function ENT:SoundStop()
	if self.DIST then
		self.DIST:Stop()
	end
	
	if self.ENG then
		self.ENG:Stop()
	end
end

--PATH lua/entities/lvs_repulsorlift_dropship/shared.lua:
return gluapack()()
--PATH lua/entities/lvs_space_laat/cl_init.lua:
include("shared.lua")

function ENT:Initialize()
	self.nextEFX = 0
	self.nextDFX = 0
	self.nextBeepSound = 0
	self.nextLFX = 0
	self.NextAlertSound = 0
	--self.ActiveTime = CurTime()
	self.bommed = false
	self.onact = false
end


local spotlight = Material("effects/lvs/laat_spotlight")
local glow_spotlight = Material("sprites/light_glow02_add")
local spotlight_color = Color(255, 255, 255)
local glow_color = Color(255, 255, 255, 10)
local glow_reactor = Material("sprites/light_glow02_add")
local lamp_pos = Vector(3, 0, 135)
local lamp_color_black = Color(0, 0, 0)
local lamp_color_red = Color(255, 0, 0)
local lamp_color_green = Color(0, 255, 0)
local reactor_color = Color(0, 127, 255)
local reactor_pos = {
	Vector(-270, -20, 265),
	Vector(-270, 20, 265),
}

ENT.EngineGlow = Material( "sprites/light_glow02_add" )
ENT.LightGlow = Material( "sprites/light_glow02_add" )
ENT.LightMaterial = Material( "effects/lvs/laat_spotlight" )
ENT.Red = Color( 255, 0, 0, 255)
ENT.SignalSprite = Material( "sprites/light_glow02_add" )
ENT.Spotlight = Material( "effects/lvs/spotlight_projectorbeam" )

ENT.LightMaterial = Material( "effects/lvs/laat_spotlight" )
ENT.GlowMaterial = Material( "sprites/light_glow02_add" )

ENT.EngineColor = Color( 255, 220, 150, 255)
ENT.EngineGlow = Material( "sprites/light_glow02_add" )
ENT.EngineCenter = Material( "vgui/circle" )
ENT.EnginePos = {
	[1] = Vector(-155,0,76.85),
	[2] = Vector(-155,0,41.82),
}

function ENT:WingTurretProjector()
	local FireWingTurret = self:GetWingTurretFire()

	if FireWingTurret == self.OldWingTurretFire then return end

	self.OldWingTurretFire = FireWingTurret

	if FireWingTurret then
		local effectdata = EffectData()
		effectdata:SetEntity( self )
		util.Effect( "lfs_fb_wingturret_projector", effectdata )
	end
end



function ENT:OnFrame()
	self:Boom()

	self:WingTurretProjector()

	self:ENGCheck()

	self:DamageFX()

	self:ExhaustFX()

end

function ENT:Boom()
	if self:GetHP() > 2200 then
		self.bommed = false
		self:StopParticles()
	end
	if self.bommed == false then
		if self:GetHP() < 2200 then
			ParticleEffectAttach("env_fire_large_smoke", PATTACH_POINT_FOLLOW, self, self:LookupAttachment("R_Heat_Hatch"))
			self.bommed = true
			local effectdata = EffectData()
				effectdata:SetOrigin(self:LocalToWorld(Vector(-300, 0, 180)))
			util.Effect("lvs_explosion_small", effectdata)
		end
	end
end

function ENT:ENGCheck()
	if self.onact == false then
		if self:GetEngineActive() == true then
			self.ActiveTime = CurTime()
			self.onact = true
			self.nextEFX = CurTime() + 1
		end
	end
	if self.onact == true then
		if self:GetEngineActive() == false then
			self.onact = false
			self.StopTime = CurTime()
		end
	end
	if self:GetEngineActive() == false then
		self.onact = false
	end
end

function ENT:ExhaustFX()
	local FullThrottle = self:GetThrottle() >= 35

	if self.OldFullThrottle ~= FullThrottle then
		self.OldFullThrottle = FullThrottle
		if FullThrottle then 
			self:EmitSound("laat_bf2/boost_"..math.random(1, 2)..".wav")
		end
	end

	if self:GetEngineActive() then
		if self.nextEFX < CurTime() then
			self.nextEFX = CurTime() + 0.01
			
			local emitter = ParticleEmitter(self:GetPos(), false)
			local Pos = {
				Vector(-270, -20, 265),
				Vector(-270, 20, 265),
			}

			if emitter then
				for _, v in pairs(Pos) do
					local vOffset = self:LocalToWorld( v )
					local vNormal = -self:GetForward()
					local vOffset2 = vOffset + vNormal * 5

					local particle = emitter:Add("sprites/heatwave", vOffset2)
					if not particle then return end
						particle:SetVelocity(vNormal * math.Rand(1500, 1000) + self:GetVelocity())
						particle:SetLifeTime(0)
						particle:SetDieTime(0.1)
						particle:SetStartAlpha(255)
						particle:SetEndAlpha(0)
						particle:SetStartSize(math.Rand(35, 50))
						particle:SetEndSize(math.Rand(0, 5))
						particle:SetRoll(math.Rand(-1, 1) * 100)
						particle:SetColor(255, 255, 255)
				end
				
				emitter:Finish()
			end
		end
	end
end

function ENT:CanSound()
	self.NextSound = self.NextSound or 0
	return self.NextSound < CurTime()
end

function ENT:CanSound2()
	self.NextSound2 = self.NextSound2 or 0
	return self.NextSound2 < CurTime()
end

function ENT:DelayNextSound( fDelay )
	if not isnumber( fDelay ) then return end
	
	self.NextSound = CurTime() + fDelay
end

function ENT:DelayNextSound2( fDelay )
	if not isnumber( fDelay ) then return end
	
	self.NextSound2 = CurTime() + fDelay
end

function ENT:CalcEngineSound( RPM, Pitch, Doppler )
	if self.ENG then
		self.ENG:ChangePitch(math.Clamp(math.Clamp(80 + Pitch * 25, 50, 255) + Doppler, 0, 255))
		self.ENG:ChangeVolume(math.Clamp(-1 + Pitch * 6, 0.5, 1))
	end
	
	if self.DIST then
		local ply = LocalPlayer()
		local DistMul = math.min((self:GetPos() - ply:GetPos()):Length() / 8000, 1) ^ 2
		self.DIST:ChangePitch(math.Clamp(100 + Doppler * 0.2, 0, 255))
		self.DIST:ChangeVolume(math.Clamp(-1.5 + Pitch * 6, 0.5, 1) * DistMul)
	end
end

function ENT:DamageFX()
	local HP = self:GetHP()
	if HP <= 0 or HP > self:GetMaxHP() * 0.5 then return end

	if self.nextDFX < CurTime() then
		self.nextDFX = CurTime() + 0.05
		
		local effectdata = EffectData()
			effectdata:SetOrigin(self:LocalToWorld(Vector(-280, 0, 250)))
		util.Effect("lfs_blacksmoke", effectdata)
		local effectdata = EffectData()
			effectdata:SetOrigin(self:LocalToWorld(Vector(-280, 0, 250)))
		util.Effect("lfs_blacksmoke", effectdata)
		local effectdata = EffectData()
			effectdata:SetOrigin(self:LocalToWorld(Vector(-280, 0, 250)))
		util.Effect("lfs_blacksmoke", effectdata)

		if HP <= 2200 then
			if math.random(0, 45) < 3 then
				if math.random(1, 3) == 1 then
					local Pos = self:LocalToWorld(Vector(0, 0, 140) + VectorRand() * 20)
						effectdata:SetOrigin(Pos)
					util.Effect("cball_explode", effectdata, true, true)
					sound.Play("laat_bf2/spark"..math.random(1, 4)..".ogg", Pos, 75)
				end
			end

			local ply = LocalPlayer()
			if self.NextAlertSound < CurTime() then
				self.NextAlertSound = CurTime() + 0.27
				self:EmitSound( "laat_bf2/crash.mp3", 85 )

				--sound.Play("laat_bf2/crash.mp3", self:GetPos() + self:GetForward() * 190 + self:GetUp() * 160, 75)
			end
		end
	end
end



function ENT:Draw()
	self:DrawModel()

	if self:GetEngineActive() then
		render.SetMaterial(glow_reactor)
		local delta = CurTime() - self.ActiveTime
		local max = math.min(15 * ( delta / 1 ), 15)

		local t = 0
		for _, v in pairs(reactor_pos) do
			if self:GetHP() < 2200 then
				if self.nextLFX > CurTime() && t == 1 then continue end
				self.nextLFX = CurTime() + math.random(0, 2)
			end

			local vOffset = self:LocalToWorld(v)
			local vNormal = -self:GetForward()
			
			for i = 0, max do 
				local vUp = -self:GetUp()
				local ind = i * 2
				local vOffsetTmp = vOffset + vNormal * -2 + vUp * ind + vNormal * ind

				render.DrawSprite(vOffsetTmp, 60, 60, reactor_color)
			end

			t = t + 1
		end
	else
		if self:GetHP() < 2200 then
			if self.nextLFX <= CurTime() then 
				self.nextLFX = CurTime() + math.random(0, 1)

				render.SetMaterial(glow_reactor)

				local vOffset = self:LocalToWorld(reactor_pos[2])
				local vNormal = -self:GetForward()
				
				for i = 0, 15 do 
					local vUp = -self:GetUp()
					local ind = i * 2
					local vOffsetTmp = vOffset + vNormal * -2 + vUp * ind + vNormal * ind

					render.DrawSprite(vOffsetTmp, 60, 60, reactor_color)
				end
			end
			
		end
		if self:GetHP() < 2200 then
			if self.nextLFX <= CurTime() then 
				self.nextLFX = CurTime() + math.random(0, 2)

				render.SetMaterial(glow_reactor)

				local vOffset = self:LocalToWorld(reactor_pos[1])
				local vNormal = -self:GetForward()
				
				for i = 0, 15 do 
					local vUp = -self:GetUp()
					local ind = i * 2
					local vOffsetTmp = vOffset + vNormal * -2 + vUp * ind + vNormal * ind

					render.DrawSprite(vOffsetTmp, 60, 60, reactor_color)
				end
			end
		end
	end
	local StartPos = self:LocalToWorld(lamp_pos)
	render.SetMaterial(glow_spotlight)
	local lamp_mode = self:GetLampMode()
	render.DrawSprite(StartPos, 80, 80, lamp_mode == 0 && lamp_color_black || lamp_mode == 1 && lamp_color_red || lamp_color_green)

	if not self:IsSpotlightMounted() or not self:GetSpotlightOn() or not self:GetEngineActive() then 
		self:RemoveLight()
		return
	end

	if not IsValid(self.projector_L) then
		self.projector_L, self.projector_LID = self:CreateSpotlight(), self:LookupAttachment("L_Spotlight_End")
	end

	self:UpdateSpotlight(self.projector_L, self.projector_LID)

	if not IsValid(self.projector_R) then
		self.projector_R, self.projector_RID = self:CreateSpotlight(), self:LookupAttachment("R_Spotlight_End")
	end

	self:UpdateSpotlight(self.projector_R, self.projector_RID)
end

function ENT:OnRemove()
	self:RemoveLight()
	self:RemoveLight2()
end

function ENT:RemoveLight2()
	if IsValid( self.projector ) then
		self.projector:Remove()
		self.projector = nil
	end

	if IsValid( self.frojector ) then
		self.frojector:Remove()
		self.frojector = nil
	end
end

function ENT:RemoveLight()
	if IsValid( self.projector_L ) then
		self.projector_L:Remove()
		self.projector_L = nil
	end

	if IsValid( self.projector_R ) then
		self.projector_R:Remove()
		self.projector_R = nil
	end
end

function ENT:UpdateSpotlight(ent, attachmentID)
	local muzzle = self:GetAttachment(attachmentID)
	local StartPos = muzzle.Pos
	local Dir = muzzle.Ang:Right()

	render.SetMaterial(glow_spotlight)
	render.DrawSprite(StartPos + Dir * 20, 400, 400, spotlight_color)

	render.SetMaterial(spotlight)
	render.DrawBeam(StartPos - Dir * 10, StartPos + Dir * 1500, 350, 0, 0.99, glow_color) 
	
	if IsValid(ent) then
		ent:SetPos(StartPos)
		ent:SetAngles(Dir:Angle())
		ent:Update()
	end
end

function ENT:CreateSpotlight()
	local spotlight = ProjectedTexture()
		spotlight:SetBrightness(10) 
		spotlight:SetTexture("effects/flashlight/soft")
		spotlight:SetColor(spotlight_color) 
		spotlight:SetEnableShadows(false) 
		spotlight:SetFarZ(5000) 
		spotlight:SetNearZ(75) 
		spotlight:SetFOV(40)
	
	return spotlight
end

function ENT:OnSpawn()

end

--[[


function ENT:EngineEffects()
	if not self:GetEngineActive() then return end
end

function ENT:PostDraw()
	if not self:GetEngineActive() then return end
end

function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end
end
]]--
function ENT:OnStartBoost()
	self:EmitSound( "laat_bf2/boost_"..math.random(1, 2)..".wav", 85 )
end

function ENT:OnStopBoost()
	self:EmitSound( "lvs/vehicles/vwing/brake.wav", 85 )
end

function ENT:CalcViewOverride( ply, pos, angles, fov, pod )
	if pod == self:GetDriverSeat() then

		if pod:GetThirdPersonMode() then
			pos = pos + self:GetUp() * 100, angles, fov
		end

		return pos, angles, fov
	end

	if pod == self:GetGunnerSeat() then

		if pod:GetThirdPersonMode() then
			pos = pos + self:GetUp() * 100, angles, fov
		end

		return pos, angles, fov
	end

	if pod:GetThirdPersonMode() then
		pos = ply:GetShootPos() + pod:GetUp() * 40
	else
		pos = pos + pod:GetUp() * 40
	end

	return pos, angles, fov
end

--[[
function ENT:CalcViewOverride( ply, pos, angles, fov, pod )
	if pod == self:GetDriverSeat() or self:GetGunnerSeat() then

		if pod:GetThirdPersonMode() then
			pos = pos + self:GetUp() * 100, angles, fov
		end

		return pos, angles, fov
	end

	if pod:GetThirdPersonMode() then
		pos = ply:GetShootPos() + pod:GetUp() * 40
	else
		pos = pos + pod:GetUp() * 40
	end

	return pos, angles, fov
end]]

function ENT:PreDrawTranslucent()
	if self:GetSpotlightToggle() == false then 
		self:RemoveLight2()
		return false
	end

	if not IsValid( self.projector ) then
		local thelamp = ProjectedTexture()
		thelamp:SetBrightness( 20 ) 
		thelamp:SetTexture( "effects/flashlight/soft" )
		thelamp:SetColor( Color(255,255,255) ) 
		thelamp:SetEnableShadows( false ) 
		thelamp:SetFarZ( 4000 ) 
		thelamp:SetNearZ( 1 ) 
		thelamp:SetFOV( 80 )
		self.projector = thelamp
	end

	local attachment = {
		Pos = Vector(332.26,-2.1,5.41),
		Ang = Angle(135.25,-0.01,0.71)
	}

	if attachment then
		local StartPos = self:LocalToWorld(attachment.Pos)
		local Dir = self:LocalToWorldAngles(attachment.Ang):Up()

		render.SetMaterial( self.LightGlow )
		render.DrawSprite( StartPos + Dir * 0, 20, 20, Color( 255, 255, 255, 255) )

		render.SetMaterial( self.LightMaterial )
		render.DrawBeam(  StartPos - Dir * 0,  StartPos + Dir * 100, 90, 0, 1, Color( 255, 255, 255, 12) ) 
		
		if IsValid( self.projector ) then
			self.projector:SetPos( StartPos )
			self.projector:SetAngles( Dir:Angle() )
			self.projector:Update()
		end
	end

	return false
end
--PATH lua/entities/lvs_space_laat/shared.lua:
return gluapack()()
--PATH lua/entities/lvs_starfighter_droidtrifighter/shared.lua:
return gluapack()()
--PATH lua/entities/lvs_starfighter_n1/cl_init.lua:
return gluapack()()
--PATH lua/entities/lvs_starfighter_vwing/cl_init.lua:
include("shared.lua")

ENT.EngineColor = Color( 255, 220, 150, 255)
ENT.EngineGlow = Material( "sprites/light_glow02_add" )
ENT.EngineCenter = Material( "vgui/circle" )
ENT.EnginePos = {
	[1] = Vector(-155,0,76.85),
	[2] = Vector(-155,0,41.82),
}

function ENT:CalcViewOverride( ply, pos, angles, fov, pod )
	if self:GetDriver() == ply and not pod:GetThirdPersonMode() then
		local newpos = pos + self:GetForward() * 37 + self:GetUp() * 8

		return newpos, angles, fov
	else
		return pos, angles, fov
	end
end

function ENT:OnSpawn()
	self:RegisterTrail( Vector(-152,55,55), 0, 20, 2, 1000, 150 )
	self:RegisterTrail( Vector(-152,-55,55), 0, 20, 2, 1000, 150 )
end

function ENT:OnFrame()
	self:EngineEffects()
	self:AnimWings()
end

function ENT:AnimWings()
	self._sm_wing = self._sm_wing or 1

	local target_wing = self:GetFoils() and 0 or 1
	local RFT = RealFrameTime() * (0.5 + math.abs( math.sin( self._sm_wing * math.pi ) ) * 0.5)
	local RateUp = RFT * 2
	local RateDown = RFT * 1.5

	self._sm_wing = self._sm_wing + math.Clamp(target_wing - self._sm_wing,-RateDown,RateUp)

	local DoneMoving = self._sm_wing == 1 or self._sm_wing == 0

	if self._oldDoneMoving ~= DoneMoving then
		self._oldDoneMoving = DoneMoving
		if not DoneMoving then
			self:EmitSound("lvs/vehicles/vwing/sfoils.wav")
		end
	end

	self:SetPoseParameter( "wings", 1 - self._sm_wing )

	self:InvalidateBoneCache()
end

function ENT:EngineEffects()
	if not self:GetEngineActive() then return end

	local T = CurTime()

	if (self.nextEFX or 0) > T then return end

	self.nextEFX = T + 0.01

	local THR = self:GetThrottle()

	local emitter = self:GetParticleEmitter( self:GetPos() )

	if not IsValid( emitter ) then return end

	for _, pos in pairs( self.EnginePos ) do
		local vOffset = self:LocalToWorld( pos )
		local vNormal = -self:GetForward()

		vOffset = vOffset + vNormal * 5

		local particle = emitter:Add( "effects/muzzleflash2", vOffset )

		if not particle then continue end

		particle:SetVelocity( vNormal * math.Rand(500,1000) + self:GetVelocity() )
		particle:SetLifeTime( 0 )
		particle:SetDieTime( 0.1 )
		particle:SetStartAlpha( 255 )
		particle:SetEndAlpha( 0 )
		particle:SetStartSize( math.Rand(15,25) )
		particle:SetEndSize( math.Rand(0,10) )
		particle:SetRoll( math.Rand(-1,1) * 100 )
		particle:SetColor( 255, 200, 50 )
	end
end

function ENT:PostDraw()
	if not self:GetEngineActive() then return end

	cam.Start3D2D( self:LocalToWorld( Vector(-136,0,76.85) ), self:LocalToWorldAngles( Angle(-90,0,0) ), 1 )
		surface.SetDrawColor( self.EngineColor )
		surface.SetMaterial( self.EngineCenter )
		surface.DrawTexturedRectRotated( 0, 0, 20, 20 , 0 )
		surface.SetDrawColor( color_white )
		surface.SetMaterial( self.EngineGlow )
		surface.DrawTexturedRectRotated( 0, 0, 20, 20 , 0 )
	cam.End3D2D()
	
	cam.Start3D2D( self:LocalToWorld( Vector(-136,0,41.82) ), self:LocalToWorldAngles( Angle(-90,0,0) ), 1 )
		surface.SetDrawColor( self.EngineColor )
		surface.SetMaterial( self.EngineCenter )
		surface.DrawTexturedRectRotated( 0, 0, 20, 20 , 0 )
		surface.SetDrawColor( color_white )
		surface.SetMaterial( self.EngineGlow )
		surface.DrawTexturedRectRotated( 0, 0, 20, 20 , 0 )
	cam.End3D2D()
end

function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	local Size = 60 + self:GetThrottle() * 60 + self:GetBoost()

	render.SetMaterial( self.EngineGlow )

	for _, pos in pairs( self.EnginePos ) do
		render.DrawSprite(  self:LocalToWorld( pos ), Size, Size, self.EngineColor )
	end
end

function ENT:OnStartBoost()
	self:EmitSound( "lvs/vehicles/vwing/boost.wav", 85 )
end

function ENT:OnStopBoost()
	self:EmitSound( "lvs/vehicles/vwing/brake.wav", 85 )
end

--PATH lua/entities/lvs_starfighter_vwing/shared.lua:

ENT.Base = "lvs_base_starfighter"

ENT.PrintName = "V-Wing"
ENT.Author = "Luna"
ENT.Information = "Starfighter of the Galactic Republic"
ENT.Category = "[LVS] - Star Wars"

ENT.VehicleCategory = "Star Wars"
ENT.VehicleSubCategory = "Starfighters"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/blu/vwing.mdl"
ENT.GibModels = {
	"models/gibs/helicopter_brokenpiece_01.mdl",
	"models/gibs/helicopter_brokenpiece_02.mdl",
	"models/gibs/helicopter_brokenpiece_03.mdl",
	"models/combine_apc_destroyed_gib02.mdl",
	"models/combine_apc_destroyed_gib04.mdl",
	"models/combine_apc_destroyed_gib05.mdl",
	"models/props_c17/trappropeller_engine.mdl",
	"models/gibs/airboat_broken_engine.mdl",
}

ENT.AITEAM = 2

ENT.MaxVelocity = 2150
ENT.MaxThrust = 2150

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3

ENT.TurnRatePitch = 1
ENT.TurnRateYaw = 1
ENT.TurnRateRoll = 1.25

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 300
ENT.MaxShield = 100

function ENT:OnSetupDataTables()
	self:AddDT( "Bool", "Foils" )
end

function ENT:InitWeapons()
	self.FirePositions = {
		Vector(3.97,-56.3,53.79),
		Vector(4.01,56.39,46.96),
		Vector(4.01,-56.39,46.96),
		Vector(3.97,56.3,53.79),
	}

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/mg.png")
	weapon.Ammo = 3000
	weapon.Delay = 0.07
	weapon.HeatRateUp = 0.25
	weapon.HeatRateDown = 1
	weapon.Attack = function( ent )
		ent.NumPrim = ent.NumPrim and ent.NumPrim + 1 or 1
		if ent.NumPrim > #ent.FirePositions then ent.NumPrim = 1 end

		if not ent:GetFoils() then
			ent:SetHeat( ent:GetHeat() + 0.1 )
		end
	
		local pod = ent:GetDriverSeat()

		if not IsValid( pod ) then return end

		local startpos = pod:LocalToWorld( pod:OBBCenter() )
		local trace = util.TraceHull( {
			start = startpos,
			endpos = (startpos + ent:GetForward() * 50000),
			mins = Vector( -10, -10, -10 ),
			maxs = Vector( 10, 10, 10 ),
			filter = ent:GetCrosshairFilterEnts()
		} )

		local CurPos = ent.FirePositions[ent.NumPrim]

		local bullet = {}
		bullet.Src 	= ent:LocalToWorld( CurPos )
		bullet.Dir 	= (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread 	= Vector( 0.025,  0.025, 0 )
		bullet.TracerName = "lvs_laser_green"
		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 25
		bullet.Velocity = 60000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(50,255,50) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_impact", effectdata )
		end
		ent:LVSFireBullet( bullet )

		local effectdata = EffectData()
		effectdata:SetStart( Vector(50,255,50) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( ent:GetForward() )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )

		ent:TakeAmmo()

		if CurPos.y > 0 then
			ent.SNDLeft:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
		else
			ent.SNDRight:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
		end
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )



	local weapon = {}
	weapon.Icon = Material("lvs/weapons/protontorpedo.png")
	weapon.Ammo = 4
	weapon.Delay = 0 -- this will turn weapon.Attack to a somewhat think function
	weapon.HeatRateUp = -0.5 -- cool down when attack key is held. This system fires on key-release.
	weapon.HeatRateDown = 0.25
	weapon.Attack = function( ent )
		local T = CurTime()

		if IsValid( ent._ProtonTorpedo ) then
			if (ent._nextMissleTracking or 0) > T then return end

			ent._nextMissleTracking = T + 0.1 -- 0.1 second interval because those find functions can be expensive

			ent._ProtonTorpedo:FindTarget( ent:GetPos(), ent:GetForward(), 30, 7500 )

			return
		end

		local T = CurTime()

		if (ent._nextMissle or 0) > T then return end

		ent._nextMissle = T + 0.5

		ent._swapMissile = not ent._swapMissile

		local Pos = Vector( 6, (ent._swapMissile and -57 or 57), 50.5 )

		local Driver = self:GetDriver()

		local projectile = ents.Create( "lvs_concussionmissile" )
		projectile:SetPos( ent:LocalToWorld( Pos ) )
		projectile:SetAngles( ent:GetAngles() )
		projectile:SetParent( ent )
		projectile:Spawn()
		projectile:Activate()
		projectile:SetAttacker( IsValid( Driver ) and Driver or self )
		projectile:SetEntityFilter( ent:GetCrosshairFilterEnts() )

		ent._ProtonTorpedo = projectile

		ent:SetNextAttack( CurTime() + 0.1 ) -- wait 0.1 second before starting to track
	end
	weapon.FinishAttack = function( ent )
		if not IsValid( ent._ProtonTorpedo ) then return end

		local projectile = ent._ProtonTorpedo

		projectile:Enable()
		projectile:EmitSound( "lvs/vehicles/vulturedroid/fire_missile.mp3", 125 )
		ent:TakeAmmo()

		ent._ProtonTorpedo = nil

		local NewHeat = ent:GetHeat() + 0.75

		ent:SetHeat( NewHeat )
		if NewHeat >= 1 then
			ent:SetOverheated( true )
		end
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )


	self:AddWeapon( LVS:GetWeaponPreset( "TURBO" ) )
end

ENT.FlyByAdvance = 0.5
ENT.FlyBySound = "lvs/vehicles/vwing/flyby.wav" 
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/vwing/loop.wav",
		sound_int = "lvs/vehicles/vwing/loop_interior.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 90,
	},
}
--PATH lua/entities/lvs_turret_aa/cl_init.lua:
return gluapack()()
--PATH lua/entities/lvs_turret_aa/shared.lua:
return gluapack()()
--PATH lua/entities/lvs_turret_aa/shared.lua:
ENT.Base = "lvs_base_turret"

ENT.PrintName = "Anti-Air Turret"
ENT.Author = "Luna"
ENT.Information = "It shoots lasers into the sky and makes things go boom"
ENT.Category = "[LVS] - Turrets (Republic)"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/antiairturret/rep_anti-airturret.mdl"

ENT.AITEAM = 2

ENT.MaxVelocity = 3000
ENT.MaxThrust = 3000

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3

ENT.TurnRatePitch = 1
ENT.TurnRateYaw = 1
ENT.TurnRateRoll = 1

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.LAATC_PICKUPABLE = true
ENT.LAATC_DROP_IN_AIR = true
ENT.LAATC_PICKUP_POS = Vector(-200,0,25)
ENT.LAATC_PICKUP_Angle = Angle(0,0,0)

ENT.MaxHealth = 4800

function ENT:OnSetupDataTables()
	self:AddDT( "Bool", "IsCarried" )
	self:AddDT( "Entity", "GunnerSeat" )
	self:AddDT( "Float", "TurretPitch" )
	self:AddDT( "Float", "TurretYaw" )

	if SERVER then
		self:NetworkVarNotify( "IsCarried", self.OnIsCarried )
	end
end

function ENT:TraceTurret()
	local ID = self:LookupAttachment( "muzzle1" )
	local Muzzle = self:GetAttachment( ID )

	if not Muzzle then return end

	local dir = Muzzle.Ang:Up()
	local pos = Muzzle.Pos

	local trace = util.TraceLine( {
		start = pos,
		endpos = (pos + dir * 50000),
	} )

	return trace
end

function ENT:GetAimAngles( ent )
    local trace = ent:GetEyeTrace()
    local AimAngles = self:WorldToLocalAngles( (trace.HitPos - self:LocalToWorld( Vector(0,0,60) ) ):GetNormalized():Angle() )

    return AimAngles
end

function ENT:WeaponsInRange( ent )
    local AimAngles = self:GetAimAngles( ent )

    return not (AimAngles.p >= -10 or AimAngles.p <= -180)
end

function ENT:InitWeapons()
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Delay = 0.25
	weapon.HeatRateUp = .34
	weapon.HeatRateDown = .5
	weapon.Attack = function( ent )
        if not ent:GetVehicle():WeaponsInRange( ent ) then return true end
		local base = ent:GetVehicle()

		local ID_1 = self:LookupAttachment( "muzzle1" )
		local ID_2 = self:LookupAttachment( "muzzle2" )
		local Muzzle1 = self:GetAttachment( ID_1 )
		local Muzzle2 = self:GetAttachment( ID_2 )

		if not Muzzle1 or not Muzzle2 then return end		

		ent.MirrorPrimary = not ent.MirrorPrimary

		local Pos = ent.MirrorPrimary and Muzzle1.Pos or Muzzle2.Pos
		local Dir =  (ent.MirrorPrimary and Muzzle1.Ang or Muzzle2.Ang):Up()

		local bullet = {}
		bullet.Src 	= Pos
		bullet.Dir 	= Dir
		bullet.Spread 	= Vector( 0.025,  0.025, 0.025 )
		bullet.TracerName = "lvs_laser_blue"
		bullet.Force	= 100
		bullet.HullSize 	= 50
		bullet.Damage	= 35
		bullet.Velocity = 50000
		bullet.SplashDamage	= 70
		bullet.SplashDamageRadius	= 250
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(50,50,255) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_explosion", effectdata )
		end

		local effectdata = EffectData()
		effectdata:SetStart( Vector(50,50,255) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( Dir )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )

		base.PrimarySND:PlayOnce( 100 + math.Rand(-3,3), 1 )
		ent:LVSFireBullet( bullet )
		
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav")end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	weapon.OnThink = function( ent, active )	
		if ent:GetVehicle():GetIsCarried( ent ) then
			self:SetPoseParameter("turret_pitch", 0 )
			self:SetPoseParameter("turret_yaw", 0 )
		end
		
		local AimAngles = self:GetAimAngles( ent )

		self:SetPoseParameter("turret_pitch", AimAngles.p )
		self:SetPoseParameter("turret_yaw", AimAngles.y )
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		local Pos2D = base:TraceTurret().HitPos:ToScreen()

		base:PaintCrosshairCenter( Pos2D, color_white )
		base:PaintCrosshairOuter( Pos2D, color_white )
		base:LVSPaintHitMarker( Pos2D )
	end
	self:AddWeapon( weapon, 2 )
	
	
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/dual_mg.png")
	weapon.Delay = 0.1
	weapon.HeatRateUp = .2
	weapon.HeatRateDown = .5
	weapon.Attack = function( ent )
        if not ent:GetVehicle():WeaponsInRange( ent ) then return true end
		local pod = ent:GetDriverSeat()
		local dir = ent:GetAimVector()
		local trace = ent:GetEyeTrace()
		local base = ent:GetVehicle()

		local ID_1 = self:LookupAttachment( "muzzle1" )
		local ID_2 = self:LookupAttachment( "muzzle2" )
		local Muzzle1 = self:GetAttachment( ID_1 )
		local Muzzle2 = self:GetAttachment( ID_2 )

		if not Muzzle1 or not Muzzle2 then return end

		ent.MirrorPrimary = not ent.MirrorPrimary

		local Pos = ent.MirrorPrimary and Muzzle1.Pos or Muzzle2.Pos
		local Dir =  (ent.MirrorPrimary and Muzzle1.Ang or Muzzle2.Ang):Up()

		ent.SwapTopBottom = not ent.SwapTopBottom

		base.SecondarySND:PlayOnce( 100 + math.Rand(-3,3), 1 )

		local bullet = {}
		bullet.Src = Pos
		bullet.Dir = Dir
		bullet.Spread 	= Vector( 0.07,  0.07, 0.07 )
		bullet.TracerName = "lvs_laser_blue"
		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 20
		bullet.Velocity = 50000
		--bullet.SplashDamage	= 20
		--bullet.SplashDamageRadius	= 200
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(50,50,255) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_explosion", effectdata )
		end
		ent:LVSFireBullet( bullet )
	end
	
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav")end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	weapon.HudPaint = function( ent, X, Y, ply )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		local Pos2D = base:TraceTurret().HitPos:ToScreen()

		base:PaintCrosshairCenter( Pos2D, color_white )
		base:PaintCrosshairOuter( Pos2D, color_white )
		base:LVSPaintHitMarker( Pos2D )
	end
	self:AddWeapon( weapon, 2 )
end

ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"
--PATH lua/entities/lvs_turret_ai_red/cl_init.lua:
return gluapack()()
--PATH lua/entities/lvs_vwing_advanced/cl_init.lua:
return gluapack()()
--PATH addons/[tfres] lego vechicles/lua/entities/lvs_vwing_advanced_lego/cl_init.lua:
include("shared.lua")

ENT.EngineColor = Color( 255, 220, 150, 255)
ENT.EngineGlow = Material( "sprites/light_glow02_add" )
ENT.EngineCenter = Material( "vgui/circle" )
ENT.EnginePos = {
	[1] = Vector(0,134,95),
	[2] = Vector(0,-134,95),
}

function ENT:OnFrame()
	self:EngineEffects()
end

function ENT:OnStartBoost()
	self:EmitSound( "lvs/vehicles/vwing/boost.wav", 85 )
end

function ENT:OnStopBoost()
	self:EmitSound( "lvs/vehicles/vwing/brake.wav", 85 )
end

function ENT:EngineEffects()
	if not self:GetEngineActive() then return end

	local T = CurTime()

	if (self.nextEFX or 0) > T then return end

	self.nextEFX = T + 0.01

	local THR = self:GetThrottle()

	local emitter = self:GetParticleEmitter( self:GetPos() )

	if not IsValid( emitter ) then return end

	for _, pos in pairs( self.EnginePos ) do
		local vOffset = self:LocalToWorld( pos )
		local vNormal = -self:GetForward()

		vOffset = vOffset + vNormal * 5

		local particle = emitter:Add( "effects/muzzleflash2", vOffset )

		if not particle then continue end

		particle:SetVelocity( vNormal * math.Rand(500,1000) + self:GetVelocity() )
		particle:SetLifeTime( 0 )
		particle:SetDieTime( 0.3 )
		particle:SetStartAlpha( 255 )
		particle:SetEndAlpha( 0 )
		particle:SetStartSize( math.Rand(25,40) )
		particle:SetEndSize( math.Rand(0,10) )
		particle:SetRoll( math.Rand(-1,1) * 100 )
		particle:SetColor( 50, 255, 247 )
	end
end

function ENT:PostDraw()
	if not self:GetEngineActive() then return end


end

function ENT:OnSpawn()
	self:RegisterTrail( Vector(-160,0.16,9.62), 0, 20, 2, 1000, 150 )
	self:RegisterTrail( Vector(-160,0.72,-30.29), 0, 20, 2, 1000, 150 )
end

function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	local Size = 60 + self:GetThrottle() * 60 + self:GetBoost()

	render.SetMaterial( self.EngineGlow )

	for _, pos in pairs( self.EnginePos ) do
		render.DrawSprite(  self:LocalToWorld( pos ), Size, Size, self.EngineColor )
	end
end


--PATH lua/entities/lvs_walker_atrt_flamethrower/cl_ikfunctions.lua:
return gluapack()()
--PATH lua/entities/lvs_walker_atte/cl_prediction.lua:

function ENT:PredictPoseParamaters()
	local pod = self:GetTurretSeat()

	if not IsValid( pod ) then return end

	local plyL = LocalPlayer()
	local ply = pod:GetDriver()

	if ply ~= plyL then return end

	self:SetPosTurret()
	self:SetPoseParameterTurret( pod:lvsGetWeapon() )
end

--PATH lua/entities/lvs_walker_hsd/cl_prediction.lua:

function ENT:PredictPoseParamaters()
	local pod = self:GetDriverSeat()

	if not IsValid( pod ) then return end

	local plyL = LocalPlayer()
	local ply = pod:GetDriver()

	if ply ~= plyL then return end

	self:AimTurretPrimary()
	self:AimTurretSecondary()
end
--PATH lua/entities/lvs_walker_hsd_leg.lua:
AddCSLuaFile()

ENT.Type            = "anim"

function ENT:SetupDataTables()
	self:NetworkVar( "Entity",0, "Base" )
	self:NetworkVar( "String",0, "LocationIndex" )
end

if SERVER then
	function ENT:Initialize()	
		self:SetModel( "models/blu/hsd_leg_1.mdl" )
		self:SetMoveType( MOVETYPE_NONE )
		self:SetSolid( SOLID_NONE )
	end

	function ENT:Think()
		return false
	end
else 
	include( "entities/lvs_walker_atte/cl_ikfunctions.lua" )

	local Length1 = 140
	local Length2 = 300

	local Length3 = 20
	local Length4 = 20

	local LegData1 = {
		Leg1 = {MDL = "models/blu/hsd_leg_2.mdl", Ang = Angle(0,-90,-90), Pos = Vector(0,0,0)},
		Leg2 = {MDL = "models/blu/hsd_leg_4.mdl", Ang = Angle(180,90,4), Pos = Vector(20,0,-12)},
		Foot = {MDL = "models/blu/hsd_foot.mdl", Ang = Angle(0,0,0), Pos = Vector(0,-2,0)}
	}

	local LegData2 = {
		Leg1 = {MDL = "models/blu/hsd_leg_3.mdl", Ang = Angle(0,90,-90), Pos = Vector(0,0,0)},
	}

	local StartPositions = {
		["FL"] = Vector(150,270,0),
		["FR"] = Vector(150,-270,0),
		["RL"] = Vector(-150,270,0),
		["RR"] = Vector(-150,-270,0),
	}

	local LocToID = {
		[1] = "RL",
		[2] = "FL",
		[3] = "RR",
		[4] = "FR",
	}

	function ENT:Think()
		local Base = self:GetBase()

		if not IsValid( Base ) then return end

		if Base:GetIsRagdoll() then 
			self:LegClearAll()

			return
		end

		local LocIndex = self:GetLocationIndex()

		if not Base:HitGround() then
			local Pos = Base:LocalToWorld( StartPositions[ LocIndex ] )

			self:RunIK( Pos, Base )
			self._OldPos = Pos
			self._smPos = Pos

			return
		end

		local Up = Base:GetUp()
		local Forward = Base:GetForward()
		local Vel = Base:GetVelocity()

		local Speed = Vel:Length()
		local VelForwardMul = math.min( Speed / 100, 1 )
		local VelForward = Vel:GetNormalized() * VelForwardMul + Forward * (1 - VelForwardMul)

		local TraceStart = Base:LocalToWorld( StartPositions[ LocIndex ] ) + VelForward * math.Clamp( 400 - Speed * 2, 100, 200 ) * VelForwardMul

		local trace = util.TraceLine( { 
			start = TraceStart + Vector(0,0,200),
			endpos = TraceStart - Vector(0,0,100), 
			filter = function( ent ) 
				if ent == Base or Base.HoverCollisionFilter[ ent:GetCollisionGroup() ] then return false end 

				return true
			end,
		} )

		local UpdateLeg = LocToID[ Base:GetUpdateLeg() ] == LocIndex

		self._OldPos = self._OldPos or trace.HitPos
		self._smPos = self._smPos or self._OldPos

		if self._OldUpdateLeg ~= UpdateLeg then
			self._OldUpdateLeg = UpdateLeg

			if UpdateLeg then
				self.UpdateNow = true
			end
		end

		if self.UpdateNow and not self.MoveLeg then
			sound.Play( Sound( "lvs/vehicles/hsd/hydraulic_stop0"..math.random(1,2)..".wav" ), self:GetPos(), SNDLVL_100dB )

			self.UpdateNow = nil
			self.MoveLeg = true
			self.MoveDelta = 0
		end

		local ShaftOffset = 0
		local ENDPOS = self._smPos + Up * 20

		if self.MoveLeg then
			local traceWater = util.TraceLine( {
				start = TraceStart + Vector(0,0,200),
				endpos = ENDPOS,
				filter = Base:GetCrosshairFilterEnts(),
				mask = MASK_WATER,
			} )

			if traceWater.Hit then
				local T = CurTime()

				if (self._NextFX or 0) < T then
					self._NextFX = T + 0.05
	
					local effectdata = EffectData()
						effectdata:SetOrigin( traceWater.HitPos )
						effectdata:SetEntity( Base )
						effectdata:SetMagnitude( 50 )
					util.Effect( "lvs_hover_water", effectdata )
				end
			end

			if self.MoveDelta >= 1 then
				self.MoveLeg = false
				self.MoveDelta = nil

				sound.Play( Sound( "lvs/vehicles/hsd/footstep0"..math.random(1,3)..".wav" ), ENDPOS, SNDLVL_100dB )

				local effectdata = EffectData()
					effectdata:SetOrigin( trace.HitPos )
				util.Effect( "lvs_walker_stomp", effectdata )

				sound.Play( Sound( "lvs/vehicles/hsd/hydraulic_start0"..math.random(1,2)..".wav" ), self:GetPos(), SNDLVL_100dB )
			else
				self.MoveDelta = math.min( self.MoveDelta + RealFrameTime() * 2, 1 )
	
				self._smPos = LerpVector( self.MoveDelta, self._OldPos, trace.HitPos )

				local MulZ =  math.max( math.sin( self.MoveDelta * math.pi ), 0 )

				ShaftOffset = MulZ ^ 2 * 30
				ENDPOS = ENDPOS + Up * MulZ * 50
			end
		else
			self._OldPos = self._smPos
		end

		self:RunIK( ENDPOS, Base, ShaftOffset )
	end

	function ENT:RunIK( ENDPOS, Base, shaftoffset )
		shaftoffset = shaftoffset or 0

		local Ang = Base:WorldToLocalAngles( (ENDPOS - self:GetPos()):Angle() )

		self:SetAngles( Base:LocalToWorldAngles( Angle(0,Ang.y + 90,0) ) )

		local ID = self:LookupAttachment( "lower" )
		local Att = self:GetAttachment( ID )

		if not Att then return end

		local Pos, Ang = WorldToLocal( ENDPOS, (ENDPOS - Att.Pos):Angle(), Att.Pos, self:LocalToWorldAngles( Angle(0,-90,0) ) )

		local STARTPOS = Att.Pos

		self:GetLegEnts( 1, Length1, Length2, self:LocalToWorldAngles( Angle(0,180,135) ), STARTPOS, ENDPOS, LegData1 )

		if not self.IK_Joints[ 1 ] or not IsValid( self.IK_Joints[ 1 ].Attachment2 ) then return end

		local shaft = self.IK_Joints[ 1 ].Attachment2

		shaft:SetPoseParameter( "extrude", shaftoffset )
		shaft:InvalidateBoneCache()

		local ID1 = self:LookupAttachment( "upper" )
		local Start = self:GetAttachment( ID1 )

		if not Start then return end

		local ID2 = shaft:LookupAttachment( "upper_end" )
		local End = shaft:GetAttachment( ID2 )

		if not End then return end

		self:GetLegEnts( 2, Length3, Length4, self:LocalToWorldAngles( Angle(0,0,-45) ), Start.Pos, End.Pos, LegData2 )

		if not self.IK_Joints[ 2 ] or not IsValid( self.IK_Joints[ 2 ].Attachment1 ) then return end

		local strut = self.IK_Joints[ 2 ].Attachment1
		strut:SetPoseParameter( "extrude", (Start.Pos - End.Pos):Length() )
		strut:InvalidateBoneCache()
	end

	function ENT:OnRemove()
		self:OnRemoved()
	end

	function ENT:Draw()
		local Base = self:GetBase()

		if not IsValid( Base ) then return end

		if Base:GetIsRagdoll() then return end

		self:DrawModel()
	end
end
--PATH lua/entities/mediaplayer_base/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"

ENT.Spawnable = false

ENT.Model = Model( "models/props_phx/rt_screen.mdl" )

ENT.MediaPlayerType = "entity"
ENT.IsMediaPlayerEntity = true

local ErrorModel = "models/error.mdl"

function ENT:Initialize()

	if SERVER then
		if self:GetModel() == ErrorModel then
			self:SetModel( self.Model )
		end

		self:SetUseType( SIMPLE_USE )

		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetMoveType( MOVETYPE_VPHYSICS )

		local phys = self:GetPhysicsObject()
		if IsValid( phys ) then
			phys:EnableMotion( false )
		end

		-- Install media player to entity
		local mp = self:InstallMediaPlayer( self.MediaPlayerType )

		-- Network media player ID
		self:SetMediaPlayerID( mp:GetId() )
	end

	-- Apply player config based on model
	self.PlayerConfig = self:GetMediaPlayerConfig()
end

function ENT:SetupDataTables()
	self:NetworkVar( "String", 0, "MediaPlayerID" )
end

function ENT:OnRemove()
	local mp = self:GetMediaPlayer()
	if mp then
		mp:Remove()
	end
end

function ENT:GetMediaPlayerConfig()
	local model = self:GetModel()
	local MPModelConfigs = list.Get( "MediaPlayerModelConfigs" )
	local config = MPModelConfigs and MPModelConfigs[model] or self.PlayerConfig
	return config
end

--PATH gamemodes/starwarsrp/entities/entities/microwave/shared.lua:
ENT.Base = "lab_base"
ENT.PrintName = "Microwave"

function ENT:initVars()
    self.model = "models/props/cs_office/microwave.mdl"
    self.initialPrice = GAMEMODE.Config.microwavefoodcost
    self.labPhrase = DarkRP.getPhrase("microwave")
    self.itemPhrase = DarkRP.getPhrase("food")
end

--PATH lua/entities/mk1.lua:
return gluapack()()
--PATH lua/entities/mortar_fire_shell/cl_init.lua:
include("shared.lua")

function ENT:Draw()
    self:DrawModel()
end
--PATH lua/entities/mortar_smoke_shell/cl_init.lua:
include("shared.lua")

function ENT:Draw()
    self:DrawModel()
end
--PATH addons/[mrs] mc_quests/lua/entities/mqs_npc/cl_init.lua:
return gluapack()()
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/entities/nade_k_thrown_bacta.lua:
AddCSLuaFile()

ENT.Type = "anim"
ENT.Base = "arc9_nade_base"
ENT.PrintName = "Bacta Grenade"
ENT.Author = ""
ENT.Information = ""
ENT.Spawnable = false
ENT.AdminSpawnable = false
ENT.CollisionGroup = COLLISION_GROUP_DEBRIS

ENT.Model = "models/arccw/kraken/sw/explosives/world/w_grenade_bacta.mdl"

AddCSLuaFile()

local regenInterval = 0.050
local regenDuration = 30
local playersInRegenRange = {}

local function RegenerateHealth(ply)
    if IsValid(ply) and ply:Alive() then
        local maxHealth = ply:GetMaxHealth()
        local currentHealth = ply:Health()
        local regenAmount = maxHealth * 0.05

        if currentHealth < maxHealth then
            ply:SetHealth(math.min(currentHealth + regenAmount, maxHealth))
        end
    end
end

-- Hook to start player health regeneration
local function StartRegenTimer(ply)
    if IsValid(ply) and ply:Alive() then
        if not playersInRegenRange[ply] then
            playersInRegenRange[ply] = true
            ply.regenStartTime = CurTime()

            timer.Create("HealthRegen_" .. ply:EntIndex(), regenInterval, regenDuration / regenInterval, function()
                if IsValid(ply) and ply:Alive() and playersInRegenRange[ply] then
                    RegenerateHealth(ply)
                else
                    timer.Remove("HealthRegen_" .. ply:EntIndex())
                    playersInRegenRange[ply] = nil
                end
            end)
        end
    end
end

-- Hook to detect players entering and leaving regeneration range
local function StopRegenTimer(ply)
    if playersInRegenRange[ply] then
        playersInRegenRange[ply] = nil
        timer.Remove("HealthRegen_" .. ply:EntIndex())
    end
end

hook.Add("PlayerEnteredRegenRadius", "PlayerEnteredRegenRadius", function(ply)
    StartRegenTimer(ply)
end)

hook.Add("PlayerLeftRegenRadius", "PlayerLeftRegenRadius", function(ply)
    StopRegenTimer(ply)
end)

local function IsPlayerInRegenArea(ply, grenadePos, radius)
    return IsValid(ply) and ply:GetPos():DistToSqr(grenadePos) <= radius * radius
end

function ENT:Initialize()
    if SERVER then
        self:SetModel(self.Model)
		self:PhysicsInit(SOLID_VPHYSICS)
		self:SetMoveType(MOVETYPE_VPHYSICS)
		self:SetSolid(SOLID_VPHYSICS)
		self:SetCollisionGroup(COLLISION_GROUP_NONE)
        self:SetSkin(self.Skin or 0)
        
        local phys = self:GetPhysicsObject()
        if phys:IsValid() then
            phys:Wake()
            phys:SetBuoyancyRatio(0)
        end
        
		self.Delay = CurTime() + 2.5
		self.NextParticle = 0
		self.ParticleCount = 0
		self.First = true
		self.IsDetonated = false
        
    end

    util.PrecacheSound("kraken/explosives/bactagrenade/bacta_beep.wav")
    self:EmitSound("kraken/explosives/bactagrenade/bacta_beep.wav")
end


function ENT:PhysicsCollide(data, physobj)
    if SERVER then
        if data.Speed > 75 then
            self:EmitSound(Sound("kraken/explosives/bounce/bounce" .. math.random(1,16) .. ".wav"))

            local tgt = data.HitEntity
            if IsValid(tgt) and not tgt:IsWorld() and (self.NextHit or 0) < CurTime() then
                self.NextHit = CurTime() + 0.1
                local dmginfo = DamageInfo()
                dmginfo:SetDamageType(DMG_GENERIC)
                dmginfo:SetDamage(10)
                dmginfo:SetAttacker(self:GetOwner())
                dmginfo:SetInflictor(self)
                dmginfo:SetDamageForce(data.OurOldVelocity * 0.5)
                tgt:TakeDamageInfo(dmginfo)
                if (IsValid(tgt) and (tgt:IsNPC() or tgt:IsPlayer() or tgt:IsNextBot()) and tgt:Health() <= 0) or (not tgt:IsWorld() and not IsValid(tgt)) or string.find(tgt:GetClass(), "breakable") then
                    local pos, ang, vel = self:GetPos(), self:GetAngles(), data.OurOldVelocity
                    timer.Simple(0, function()
                        if IsValid(self) then
                            self:SetAngles(ang)
                            self:SetPos(pos)
                            self:GetPhysicsObject():SetVelocityInstantaneous(vel)
                        end
                    end)
                end
            end
        elseif data.Speed > 25 then
            self:EmitSound(Sound("kraken/explosives/bounce/bounce" .. math.random(1,16) .. ".wav"))
        elseif data.Speed < 5 then
            self:SetMoveType(MOVETYPE_NONE)
        end
    end
end

function ENT:Think()
    if SERVER then    
        if CurTime() > self.Delay then
            if not self.IsDetonated then
                self:Detonate(self:GetPos())
                self.IsDetonated = true
                
                for _, v in pairs(ents.FindInSphere(self:GetPos(), 300)) do
                    if v:IsPlayer() then
                        hook.Call("PlayerEnteredRegenRadius", nil, v)
                    end
                end
            else
                for ply, _ in pairs(playersInRegenRange) do
                    if not IsPlayerInRegenArea(ply, self:GetPos(), 300) then
                        hook.Call("PlayerLeftRegenRadius", nil, ply)
                    end
                end
            end
        end
    end
end

function ENT:DrawTranslucent()
    self:Draw()
end

function ENT:Draw()
    self:DrawModel()
end

function ENT:Detonate(pos)
    if SERVER then
        if not self:IsValid() then return end
        self:SetNWBool("IsDetonated", true)
        self:EmitSound("kraken/explosives/bactagrenade/bacta_grenade.mp3", 120, 100, 1, CHAN_AUTO)
        
        local gas = EffectData()
        gas:SetOrigin(pos)
        gas:SetEntity(self.Owner)
        util.Effect("bactanade", gas)
    end
    
    self:SetMoveType(MOVETYPE_NONE)
    
    if SERVER then
        SafeRemoveEntityDelayed(self, 0.5)
    end
end
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/entities/nade_k_thrown_c25.lua:
AddCSLuaFile()

ENT.Type = "anim"
ENT.Base = "arc9_nade_base"
ENT.PrintName = "C-25 Grenade"
ENT.Author = ""
ENT.Information = ""
ENT.Spawnable = false
ENT.AdminSpawnable = false
ENT.CollisionGroup = COLLISION_GROUP_DEBRIS

ENT.Model = "models/arccw/kraken/sw/explosives/world/w_c25.mdl"
ENT.FuseTime = 0.1
ENT.TrailColor = Color(35, 202, 228)
ENT.TrailTexture = "sprites/bluelaser1"

ENT.BlastDamage = {
    [0] = 100,
    [1] = 300,
    [2] = 100,
}

AddCSLuaFile()

function ENT:Initialize()
    if SERVER then
        self:SetModel(self.Model)
        self:SetMoveType(MOVETYPE_VPHYSICS)
        self:SetSolid(SOLID_VPHYSICS)
        self:PhysicsInit(SOLID_VPHYSICS)
        self:SetSkin(self.Skin or 0)

        local phys = self:GetPhysicsObject()
        if phys:IsValid() then
            phys:Wake()
            phys:SetBuoyancyRatio(0)
        end

        self.SpawnTime = CurTime()
        self:SetPhysicsAttacker(self:GetOwner(), 10)

        util.PrecacheSound("kraken/explosives/thermalimploder/beeps.wav")
        self:EmitSound("kraken/explosives/thermalimploder/beeps.wav", 90, 100, 1, CHAN_AUTO)
    end
end

function ENT:PhysicsCollide(data, physobj)
    if SERVER then
        if data.Speed > 75 then
            self:EmitSound(Sound("kraken/explosives/bounce/bounce" .. math.random(1,16) .. ".wav"))

            local tgt = data.HitEntity
            if IsValid(tgt) and not tgt:IsWorld() and (self.NextHit or 0) < CurTime() then
                self.NextHit = CurTime() + 0.1
                local dmginfo = DamageInfo()
                dmginfo:SetDamageType(DMG_GENERIC)
                dmginfo:SetDamage(10)
                dmginfo:SetAttacker(self:GetOwner())
                dmginfo:SetInflictor(self)
                dmginfo:SetDamageForce(data.OurOldVelocity * 0.5)
                tgt:TakeDamageInfo(dmginfo)
                if (IsValid(tgt) and (tgt:IsNPC() or tgt:IsPlayer() or tgt:IsNextBot()) and tgt:Health() <= 0) or (not tgt:IsWorld() and not IsValid(tgt)) or string.find(tgt:GetClass(), "breakable") then
                    local pos, ang, vel = self:GetPos(), self:GetAngles(), data.OurOldVelocity
                    timer.Simple(0, function()
                        if IsValid(self) then
                            self:SetAngles(ang)
                            self:SetPos(pos)
                            self:GetPhysicsObject():SetVelocityInstantaneous(vel)
                        end
                    end)
                end
            end
        elseif data.Speed > 25 then
            self:EmitSound(Sound("kraken/explosives/bounce/bounce" .. math.random(1,16) .. ".wav"))
        end
        if data.Speed < 15 then
            self:SetMoveType(MOVETYPE_NONE)
            self:EmitSound(Sound("kraken/shared/therm_gren_charge.wav"))
        end
    end
end

function ENT:Think()
    if SERVER and CurTime() - self.SpawnTime >= self.FuseTime then
        self:Detonate()
    end
end

function ENT:Detonate()
    if SERVER then
        local effectdata = EffectData()
            effectdata:SetOrigin( self:GetPos() )

        if self:WaterLevel() >= 1 then
            util.Effect("WaterSurfaceExplosion", effectdata)
            self:EmitSound("weapons/underwater_explode3.wav", 120, 100, 1, CHAN_AUTO)
        else
            local explode = ents.Create( "info_particle_system" )
            explode:SetKeyValue( "effect_name", "vpr_nade_blast" )
            explode:SetOwner( self.Owner )
            explode:SetPos( self:GetPos() )
            explode:Spawn()
            explode:Activate()
            explode:Fire( "start", "", 0 )
            explode:Fire( "kill", "", 30 )
            --util.Effect("Explosion", effectdata)
            --util.Effect("hl2mmod_explosion_grenade", effectdata)
            self:EmitSound("kraken/explosives/shared/beeps2.wav", 90, 100, 1, CHAN_AUTO)
            self:EmitSound("ArcCW_Kraken.Explosives.Explosion", 120, 100, 1, CHAN_AUTO)
        end

        local attacker = self

        if self.Owner:IsValid() then
            attacker = self.Owner
        end

        local hit = false
        
        local pos = self:GetPos()

        for _, ent in pairs(ents.FindInSphere(pos, 450)) do
           
            local distSqr = ent:GetPos():DistToSqr(pos)
            local f = 1
            if distSqr > 9216 then -- 96 * 96
                f = Lerp((distSqr - 9216) / (122500 - 9216), 1, 0.25)
            end
            local dmginfo = DamageInfo()
            dmginfo:SetDamageType(DMG_BLAST)
            dmginfo:SetAttacker(attacker)
            dmginfo:SetDamage(190 * f)
            dmginfo:SetDamageForce((ent:WorldSpaceCenter() - pos):GetNormalized() * 9001 * f)
            dmginfo:SetInflictor(self)
            ent:TakeDamageInfo(dmginfo)
        end
        self:Remove()
        util.Decal("Scorch", pos, pos - Vector(0, 0, 30))
    end
end

function ENT:DrawTranslucent()
    self:Draw()
end

function ENT:Draw()
    self:DrawModel()
end
--PATH addons/[bronie] arccw-krakens-explosives-v1-5/lua/entities/nade_k_thrown_detonite/shared.lua:
return gluapack()()
--PATH lua/entities/nmg_ewhb-12_heavy_repeating_blaster/cl_init.lua:
return gluapack()()
--PATH lua/entities/npc_nightsister_undead/shared.lua:
return gluapack()()
--PATH lua/entities/npc_vj_sbdnew1/shared.lua:
ENT.Base 			= "npc_vj_creature_base" -- List of all base types: https://github.com/DrVrej/VJ-Base/wiki/Base-Types
ENT.Type 			= "ai"
ENT.PrintName 		= " "
ENT.Author 			= ""
ENT.Contact 		= ""
ENT.Purpose 		= ""
ENT.Instructions 	= "Click on the spawnicon to spawn it."
ENT.Category		= "[66] NPC's"

if (CLIENT) then
	local Name = "Armor B3"
	local LangName = "npc_vj_sbdnew1"
	language.Add(LangName, Name)
	killicon.Add(LangName,"",Color(255,0,0,0))
	language.Add("#"..LangName, Name)
	killicon.Add("#"..LangName,"",Color(255,0,0,0))
end
--PATH lua/entities/npc_vj_tankg_base/shared.lua:
return gluapack()()
--PATH lua/entities/obj_vj_bonefollower.lua:
/*--------------------------------------------------
	*** Copyright (c) 2012-2023 by DrVrej, All rights reserved. ***
	No parts of this code or any of its contents may be reproduced, copied, modified or adapted,
	without the prior written consent of the author, unless otherwise indicated for stand-alone materials.
--------------------------------------------------*/
AddCSLuaFile()
if (!file.Exists("autorun/vj_base_autorun.lua","LUA")) then return end

ENT.Base 			= "base_anim"
ENT.Type 			= "anim"
ENT.PrintName 		= "Bone Follower"
ENT.Author 			= "Cpt. Hazama"
ENT.Contact 		= "http://steamcommunity.com/groups/vrejgaming"
ENT.Purpose 		= "Used to make simple props and animate them, since prop_dynamic doesn't work properly in Garry's Mod."
ENT.Instructions 	= "Don't change anything."
ENT.Category		= "VJ Base"

ENT.Spawnable = false
ENT.AdminOnly = false
ENT.AutomaticFrameAdvance = true

ENT.VJ_BoneFollower = true
---------------------------------------------------------------------------------------------------------------------------------------------
if CLIENT then
	function ENT:Draw()
		//self:DrawModel()
	end
---------------------------------------------------------------------------------------------------------------------------------------------
	function ENT:DrawTranslucent()
		//self:DrawModel()
	end
---------------------------------------------------------------------------------------------------------------------------------------------
	function ENT:Initialize()
		local ent = self:GetParent()
		if IsValid(ent) then -- For some reason doesn't work?
			ent:SetIK(false) -- Until we can find a way to prevent IK chains from detecting the bone followers, we will have to disable IK on the parent.
		end
	end
end
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
if !SERVER then return end

function ENT:CustomOnInitialize() end -- In case you need to change anything
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:Initialize()
    self:SetSolid(SOLID_NONE)
    self:AddFlags(FL_NOTARGET)
    self:SetCollisionGroup(COLLISION_GROUP_IN_VEHICLE)
    self:SetCustomCollisionCheck(true)
    self:AddEFlags(EFL_DONTBLOCKLOS)

    self:CustomOnInitialize()
    self.BoneFollowers = {}

    hook.Add("OnEntityCreated", self, function(self,ent)
        if ent:GetClass() == "phys_bone_follower" then
            table.insert(self.BoneFollowers, ent)
        end
    end)
    hook.Add("PhysgunPickup", self, function(self,ply,ent)
        if ent:GetClass() == "phys_bone_follower" or ent == self then
            return false
        end
    end)

    timer.Simple(0.1, function()
        if IsValid(self) then
            self:CreateBoneFollowers()
            self.SetToRemove = true
            for _, v in ipairs(self.BoneFollowers) do
                v.VJ_BoneFollower = true
                v:SetCollisionGroup(COLLISION_GROUP_NONE)
                v:SetCustomCollisionCheck(true)
                v:AddEFlags(EFL_DONTBLOCKLOS)
                self:DeleteOnRemove(v)
            end
        end
    end)
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:OnTakeDamage(dmginfo)
	-- Make its owner entity (usually an NPC) take damage as if it was its own body
    local owner = self:GetOwner()
    if IsValid(owner) then
        owner:TakeDamageInfo(dmginfo)
    end
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:Think()
    self:UpdateBoneFollowers()
    self:NextThink(CurTime() + (0.069696968793869 + FrameTime()))
    if self.SetToRemove then
        self.SetToRemove = false
        hook.Remove("OnEntityCreated", self)
    end
    return true
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:OnRemove()
	self:DestroyBoneFollowers()
end
--PATH lua/entities/obj_vj_gib/shared.lua:
return gluapack()()
--PATH lua/entities/obj_vj_grenade.lua:
/*--------------------------------------------------
	*** Copyright (c) 2012-2023 by DrVrej, All rights reserved. ***
	No parts of this code or any of its contents may be reproduced, copied, modified or adapted,
	without the prior written consent of the author, unless otherwise indicated for stand-alone materials.
--------------------------------------------------*/
AddCSLuaFile()
if (!file.Exists("autorun/vj_base_autorun.lua","LUA")) then return end

ENT.Type 			= "anim"
ENT.Base 			= "obj_vj_projectile_base"
ENT.PrintName		= "Grenade"
ENT.Author 			= "DrVrej"
ENT.Contact 		= "http://steamcommunity.com/groups/vrejgaming"
ENT.Information		= "Projectiles for my addons"
ENT.Category		= "VJ Base"

ENT.Spawnable = true
ENT.AdminOnly = false

ENT.VJ_IsDetectableGrenade = true
ENT.VJ_IsPickupableDanger = true

if CLIENT then
	local Name = "Grenade"
	local LangName = "obj_vj_grenade"
	language.Add(LangName, Name)
	killicon.Add(LangName,"HUD/killicons/default",Color(255,80,0,255))
	language.Add("#"..LangName, Name)
	killicon.Add("#"..LangName,"HUD/killicons/default",Color(255,80,0,255))
end
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
if !SERVER then return end

ENT.Model = {"models/vj_weapons/w_grenade.mdl"} -- The models it should spawn with | Picks a random one from the table
ENT.MoveCollideType = nil
ENT.CollisionGroupType = nil
ENT.SolidType = SOLID_VPHYSICS
ENT.RemoveOnHit = false -- Should it remove itself when it touches something? | It will run the hit sound, place a decal, etc.
ENT.DoesRadiusDamage = true -- Should it do a blast damage when it hits something?
ENT.RadiusDamageRadius = 250 -- How far the damage go? The farther away it's from its enemy, the less damage it will do | Counted in world units
ENT.RadiusDamage = 80 -- How much damage should it deal? Remember this is a radius damage, therefore it will do less damage the farther away the entity is from its enemy
ENT.RadiusDamageUseRealisticRadius = true -- Should the damage decrease the farther away the enemy is from the position that the projectile hit?
ENT.RadiusDamageType = DMG_BLAST -- Damage type
ENT.RadiusDamageForce = 90 -- Put the force amount it should apply | false = Don't apply any force
ENT.DecalTbl_DeathDecals = {"Scorch"}
ENT.SoundTbl_OnCollide = {"weapons/hegrenade/he_bounce-1.wav"}

-- Custom
ENT.FussTime = 3
ENT.TimeSinceSpawn = 0
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:CustomPhysicsObjectOnInitialize(phys)
	phys:Wake()
	phys:EnableGravity(true)
	phys:SetBuoyancyRatio(0)
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:CustomOnInitialize()
	//if self:GetOwner():IsValid() && (self:GetOwner().GrenadeAttackFussTime) then
	//timer.Simple(self:GetOwner().GrenadeAttackFussTime,function() if IsValid(self) then self:DeathEffects() end end) else
	timer.Simple(self.FussTime,function() if IsValid(self) then self:DeathEffects() end end)
	//end
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:CustomOnThink()
	self.TimeSinceSpawn = self.TimeSinceSpawn + 0.2
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:CustomOnTakeDamage(dmginfo)
	if IsValid(self:GetPhysicsObject()) then
		self:GetPhysicsObject():AddVelocity(dmginfo:GetDamageForce() * 0.1)
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:CustomOnPhysicsCollide(data, phys)
	local getVel = phys:GetVelocity()
	local curVelSpeed = getVel:Length()
	//print(curVelSpeed)
	if curVelSpeed > 500 then -- Or else it will go flying!
		phys:SetVelocity(getVel * 0.9)
	end
	
	if curVelSpeed > 100 then -- If the grenade is going faster than 100, then play the touch sound
		self:OnCollideSoundCode()
	end
end
---------------------------------------------------------------------------------------------------------------------------------------------
local defAngle = Angle(0, 0, 0)
local vecZ4 = Vector(0, 0, 4)
local vezZ100 = Vector(0, 0, 100)
--
function ENT:DeathEffects()
	local selfPos = self:GetPos()
	
	ParticleEffect("vj_explosion1", self:GetPos(), defAngle, nil)
	
	local effectData = EffectData()
	effectData:SetOrigin(self:GetPos())
	//effectData:SetScale(500)
	//util.Effect("HelicopterMegaBomb", effectData)
	//util.Effect("ThumperDust", effectData)
	util.Effect("Explosion", effectData)
	//util.Effect("VJ_Small_Explosion1", effectData)

	local expLight = ents.Create("light_dynamic")
	expLight:SetKeyValue("brightness", "4")
	expLight:SetKeyValue("distance", "300")
	expLight:SetLocalPos(selfPos)
	expLight:SetLocalAngles(self:GetAngles())
	expLight:Fire("Color", "255 150 0")
	expLight:SetParent(self)
	expLight:Spawn()
	expLight:Activate()
	expLight:Fire("TurnOn", "", 0)
	self:DeleteOnRemove(expLight)
	util.ScreenShake(self:GetPos(), 100, 200, 1, 2500)

	self:SetLocalPos(selfPos + vecZ4) -- Because the entity is too close to the ground
	local tr = util.TraceLine({
		start = self:GetPos(),
		endpos = self:GetPos() - vezZ100,
		filter = self
	})
	util.Decal(VJ_PICK(self.DecalTbl_DeathDecals), tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)
	
	self:DoDamageCode()
	self:SetDeathVariablesTrue(nil, nil, false)
	self:Remove()
end
--PATH addons/[ekonomia] pcasino/lua/entities/pcasino_blackjack_table/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Blackjack Table"
ENT.Author = "Owain Owjo & The One Free-Man"
ENT.Category = "pCasino"
ENT.RenderGroup = RENDERGROUP_BOTH
ENT.Spawnable = false
ENT.AdminSpawnable = false

function ENT:SetupDataTables()
	self:NetworkVar("Int", 0, "StartRoundIn")
end

function ENT:GetPadByName(padName)
	if not self.padCache then
		self:GetCurrentPad(Vector(0, 0, 0)) -- Generate the cache
	end

	for i, _ in ipairs(self.padCache) do
		for k, v in pairs(_) do
			if k == padName then
				return k, v
			end
		end
	end
end

PerfectCasino.Core.RegisterEntity("pcasino_blackjack_table", {
	-- Bet data
	bet = {
		default = {d = 500, t = "num"}, -- The default bet
		max = {d = 1000, t = "num"}, -- The default bet
		min = {d = 100, t = "num"}, -- The default bet
		iteration = {d = 100, t = "num"} -- The default bet
	},
	turn = {
		timeout = {d = 30, t = "num"}
	},
	payout = {
		win = {d = 1.5, t = "num"},
		blackjack = {d = 3, t = "num"}
	},
	general = {
		betPeriod = {d = 30, t = "num"} -- The default bet
	}
},
"models/freeman/owain_blackjack_table.mdl")
--PATH addons/[ekonomia] pcasino/lua/entities/pcasino_chair/cl_init.lua:
include("shared.lua")

function ENT:PostData()
end

--PATH addons/[ekonomia] pcasino/lua/entities/pcasino_mystery_wheel/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Mysterly Wheel"
ENT.Author = "Owain Owjo & The One Free-Man"
ENT.Category = "pCasino"
ENT.RenderGroup = RENDERGROUP_BOTH
ENT.Spawnable = false
ENT.AdminSpawnable = false

PerfectCasino.Core.RegisterEntity("pcasino_mystery_wheel", {
	general = {
		useFreeSpins = {d = true, t = "bool"} -- Can you use free spins on this machine
	},
	buySpin = {
		buy = {d = false, t = "bool"}, -- Can you buy a spin on this machine
		cost = {d = 1000000, t = "int"}, 
	},
	-- Combo data
	wheel = { -- I know, 20 slots :O
		{n = "$1", f = "money", i = 1, p = "dolla"},
		{n = "Nothing", f = "nothing", i = "nil", p = "melon"},
		{n = "$250,000", f = "money", i = 250000, p = "dolla"},
		{n = "Spin Again", f = "prize_wheel", i = "nil", p = "mystery_1"},
		{n = "Crossbow", f = "weapon", i = "weapon_crossbow", p = "chest"},
		{n = "$1,000,000", f = "money", i = 1000000, p = "dolla"},
		{n = "100 Points", f = "ps1_points", i = 100, p = "coins"},
		{n = "Vehicle", f = "wcd_givecar", i = "alfa_stradaletdm", p = "car"},
		{n = "Die", f = "kill", i = "nil", p = "bell"},
		{n = "$50,000", f = "money", i = 50000, p = "dolla"},
		{n = "Cone Hat", f = "ps1_item", i = "conehat", p = "berry"},
		{n = "100% Armor", f = "armor", i = 100, p = "diamond"},
		{n = "SMG", f = "weapon", i = "weapon_smg1", p = "chest"},
		{n = "Nothing", f = "nothing", i = "nil", p = "melon"},
		{n = "100% Health", f = "health", i = 100, p = "diamond"},
		{n = "$100,000", f = "money", i = 100000, p = "dolla"},
		{n = "Be Alyx", f = "setmodel", i = "models/player/alyx.mdl", p = "cherry"},
		{n = "250 Points", f = "ps1_points", i = 250, p = "coins"},
		{n = "450 XP", f = "bwe_givexp", i = 450, p = "clover"},
		{n = "7 HP", f = "health", i = 7, p = "seven"},
	}
},
"models/freeman/owain_mystery_wheel.mdl")
--PATH addons/[ekonomia] pcasino/lua/entities/pcasino_npc/cl_init.lua:
return gluapack()()
--PATH addons/[ekonomia] pcasino/lua/entities/pcasino_prize_plinth/shared.lua:
return gluapack()()
--PATH addons/[ekonomia] pcasino/lua/entities/pcasino_prize_plinth/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Sign Wall Logo"
ENT.Author = "Owain Owjo & The One Free-Man"
ENT.Category = "pCasino"
ENT.Spawnable = false
ENT.AdminSpawnable = false

PerfectCasino.Core.RegisterEntity("pcasino_prize_plinth", {
	general = {
		rope = {d = true, t = "bool"},
		model = {d = "models/buggy.mdl", t = "string"}, 
		spin = {d = true, t = "bool"}, 
		bow = {d = false, t = "bool"}, 
		bowOffset = {d = 0, t = "int"}, 
	},
},
"models/freeman/owain_prize_plinth.mdl")
--PATH addons/[ekonomia] pcasino/lua/entities/pcasino_sign_wall_logo/cl_init.lua:
return gluapack()()
--PATH addons/[ekonomia] pcasino/lua/entities/pcasino_slot_machine/cl_init.lua:
return gluapack()()
--PATH addons/[ekonomia] pcasino/lua/entities/pcasino_slot_machine/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Slot Machine"
ENT.Author = "Owain Owjo & The One Free-Man"
ENT.Category = "pCasino"
ENT.Spawnable = false
ENT.AdminSpawnable = false

function ENT:SetupDataTables()
	self:NetworkVar("Int", 0, "CurrentJackpot")
end

PerfectCasino.Core.RegisterEntity("pcasino_slot_machine", {
	-- General data
	general = {
		limitUse = {d = false, t = "bool"}
	},
	-- Bet data
	bet = {
		default = {d = 1000, t = "num"}, -- The default bet
	},
	-- Combo data
	combo = {
		{c = {"bell", "bell", "bell"}, p = 0.5, j = false},
		{c = {"melon", "melon", "melon"}, p = 0.8, j = false},
		{c = {"cherry", "cherry", "cherry"}, p = 1, j = false},
		{c = {"seven", "seven", "seven"}, p = 1.6, j = false},
		{c = {"clover", "clover", "clover"}, p = 2, j = false},
		{c = {"diamond", "diamond", "diamond"}, p = 2.5, j = false},
		{c = {"diamond", "diamond", "anything"}, p = 2, j = false},
		{c = {"anything", "diamond", "diamond"}, p = 2, j = false},
		{c = {"berry", "berry", "berry"}, p = 2.8, j = false},
		{c = {"dollar", "dollar", "dollar"}, p = 0, j = true},
	},
	jackpot = {
		toggle = {d = true, t = "bool"}, -- The bell chance
		startValue = {d = 10000, t = "num"}, -- Jackpot start value
		betAdd = {d = 0.5, t = "num"}, -- The % of the bet to add to the jackpot
	},
	-- Chance data
	chance = {
		bell = {d = 15}, -- The bell chance
		melon = {d = 10}, -- The watermelon chance
		cherry = {d = 8}, -- The cherry chance
		seven = {d = 6}, -- The seven chance
		clover = {d = 5}, -- The clover chance
		diamond = {d = 3}, -- The diamond chance
		berry = {d = 2}, -- The strawberrry chance
		dollar = {d = 1} -- The dollar chance
	},
},
"models/freeman/owain_slotmachine.mdl")
--PATH lua/entities/pfx1_01.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Fire [v_3]"
ENT.Category         = "PPE: Fire & Smoke"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[1]groundflame1"
--PATH lua/entities/pfx1_08#_l.lua:
return gluapack()()
--PATH lua/entities/pfx1_08_~a.lua:
return gluapack()()
--PATH lua/entities/pfx1_08_~a.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Fire [Purple]"
ENT.Category         = "PPE: Fire & Smoke"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[1]_campfire_purple"
--PATH lua/entities/pfx1_08_~a_l.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Large Fire [Purple]"
ENT.Category         = "PPE: Fire & Smoke"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[1]_large_campfire_purple"
--PATH lua/entities/pfx2_04~.lua:
return gluapack()()
--PATH lua/entities/pfx4_00.lua:
return gluapack()()
--PATH lua/entities/pfx4_00~.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Basic Jet [Smokeless]"
ENT.Category         = "PPE: Tech"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[4]jet_f*"



--PATH lua/entities/pfx4_01_s.lua:
return gluapack()()
--PATH lua/entities/pfx4_01_s.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Smaller Blue Jet"
ENT.Category         = "PPE: Tech"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[4]jet_b_s"

--PATH lua/entities/pfx4_01~.lua:
return gluapack()()
--PATH lua/entities/pfx4_02.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Red Jet"
ENT.Category         = "PPE: Tech"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[4]jet_r"

--PATH lua/entities/pfx4_02_s~.lua:
return gluapack()()
--PATH lua/entities/pfx4_02_s~.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Smaller Red Jet [Smokeless]"
ENT.Category         = "PPE: Tech"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[4]jet_r_s*"
--PATH lua/entities/pfx4_03_s.lua:
return gluapack()()
--PATH lua/entities/pfx4_03_s~.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Smaller Green Jet [Smokeless]"
ENT.Category         = "PPE: Tech"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[4]jet_g_s*"
--PATH lua/entities/pfx4_05~.lua:
return gluapack()()
--PATH lua/entities/pfx4_06.lua:
return gluapack()()
--PATH lua/entities/pfx4_0a.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Vehicle Nitro Flame"
ENT.Category         = "PPE: Tech"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[4]_car_nitro"
--PATH lua/entities/pfx5_01.lua:
return gluapack()()
--PATH lua/entities/pfx6_01.lua:
return gluapack()()
--PATH lua/entities/pfx8_03.lua:
return gluapack()()
--PATH lua/entities/pfx_base.lua:
return gluapack()()
--PATH lua/entities/pfxcom.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "PFXCOM"
ENT.Category         = "PPE: Water"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[com]jet"
--PATH lua/entities/pfxcom1.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "PFXCOM1"
ENT.Category         = "PPE: Water"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[com1]jet"
--PATH lua/entities/prop_vj_flag.lua:
return gluapack()()
--PATH lua/entities/republic_control_point.lua:
return gluapack()()
--PATH lua/entities/roy_eta2_lvs/shared.lua:
return gluapack()()
--PATH lua/entities/rw_sw_dispencer_armor/cl_init.lua:
return gluapack()()
--PATH lua/entities/rw_sw_dispencer_armor/cl_init.lua:
include('shared.lua')

function ENT:Draw()
	self:DrawModel()
end
--PATH lua/entities/rw_sw_dispencer_health/shared.lua:
return gluapack()()
--PATH lua/entities/rw_sw_nade.lua:
return gluapack()()
--PATH lua/entities/sent_swrc_det/shared.lua:
AddCSLuaFile( )
DEFINE_BASECLASS( "base_anim" )

ENT.IsDODSTNT = true
ENT.TotalExplosions = 1
ENT.AutomaticFrameAdvance = true

util.PrecacheModel( "models/weapons/w_swrcdeton.mdl" )
util.PrecacheSound( "buttons/spark6.wav" )
util.PrecacheSound( "ambient/fire/mtov_flame2.wav" )

if CLIENT then
	ENT.Mat = Material( "sprites/redglow1" )
	ENT.Mat2 = Material( "cable/redlaser" )
	
	ENT.LP = Vector( -.5, 1, 2 )
end

function ENT:SetupDataTables( )
	self:NetworkVar( "Float", 0, "Defuse" )
	self:NetworkVar( "Float", 1, "Fuse" )
	
	self:NetworkVar( "Int", 0, "BurnAdjust" )
	
	self:NetworkVar( "Bool", 0, "Live" )
end

function ENT:Draw( )

	
	local bone, n, light
	
	bone = self:GetAttachment( self:LookupAttachment( "wick" ) )
	
	if not bone then
		return
	end
	
	self:DrawModel( )
	
	if self:GetDefuse( ) < 1 then
		
		--if self.BurnSound then
			--self.BurnSound:PlayEx( .5, 170 )
		--end
	else
		if self.BurnSound then
			self.BurnSound:Stop( )
		end
	end
end

function ENT:OnRemove( )
	if self.BurnSound then
		self.BurnSound:Stop( )
	end
end

function ENT:Use(activator, caller)
	self.Entity:ActivateX(1)
end

function ENT:ActivateX( scale )
	if not self:GetLive( ) then
		self:SetLive( true )
		self:SetBurnAdjust( scale or 1 )
		
		seq = self:LookupSequence( "w_tnt_wick" )
		self:ResetSequence( seq )
		self:SetPlaybackRate( 1 / self:GetBurnAdjust( ) )
		
		if not self.BurnSound then
			self.BurnSound = CreateSound( self, Sound( "weapons/explosives_cannons_superlazers/sw_detonator.ogg" ) )
		end
		self.BurnSound:Play( )
	end
end

function ENT:OnTakeDamage( info )
	self:TakePhysicsDamage( info )
	if info and self:IsValid( ) and not self.Refuse then
		if info:IsExplosionDamage( ) then
			self:Explode( )
		end
	end
end

function ENT:Initialize( )
	self:SetModel( "models/weapons/w_swrcdeton.mdl" )
	
	if SERVER then
		self:SetDefuse( 0 )
		self:SetFuse( 0 )
		
		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )
		
		self:PhysWake( )
	end
end

function ENT:Think( )
	local now, delta
	
	
	if CLIENT then
		return
	end
	
	now = CurTime( )
	
	delta = now - ( self.LastThink or now )
	
	self.LastThink = now
	
	if self:GetLive( ) then
		if not self.Used then
			self:SetDefuse( math.Clamp( self:GetDefuse( ) - delta * .5, 0, 1 ) )
		end
	end
	
	if self:GetDefuse( ) >= 1 and self:GetLive( ) then
		self:SetLive( false )
		
		self:EmitSound( "buttons/spark6.wav", 100, 63 )
		self:SetPlaybackRate( 0 )
	end
	
	if self:GetLive( ) then
		self:SetFuse( math.Clamp( self:GetFuse( ) + delta / ( self:GetBurnAdjust( ) * 19 ), 0, 1 ) )
		
		if self:GetFuse( ) >= 0.20 and SERVER then
			self:SetLive( false )
			self:Explode( )
		end
	end
	
	if self:GetLive( ) and self:WaterLevel( ) > 0 then
		self:SetLive( false )
		self:SetDefuse( 1 )
	end
	
	self.Used = false
end

local function Spin( vector, up, right, forward )
	local ang
	
	ang = ( vector * 1 ):Angle( )
	
	ang:RotateAroundAxis( ang:Up( ), math.random( -up / 2 , up / 2 ) )
	ang:RotateAroundAxis( ang:Right( ), math.random( -right / 2 , right / 2 ) )
	ang:RotateAroundAxis( ang:Forward( ), math.random( -forward / 2 , forward / 2 ) )
	
	return ang:Forward( )
end

function ENT:Explode( )
	if self.Refuse then
		return
	end
	
	self.Refuse = true
	
	for k, v in pairs (ents.FindInSphere(self.Entity:GetPos(), 250)) do
		v:Fire("EnableMotion", "", math.random(0, 0.5))
	end
	
	local explode = ents.Create( "env_explosion" )
	explode:SetPos( self:GetPos() )
	explode:SetKeyValue( "iMagnitude", "250" )
	explode:EmitSound( "hd/new_grenadeexplo.mp3", 100, 100 )
	explode:Spawn()
	explode:Activate()
	explode:Fire( "Explode", "", 0 )
	
	self:Remove()
end
--PATH lua/entities/sent_vj_droideka_shield_swrc/shared.lua:
return gluapack()()
--PATH lua/entities/sent_vj_droideka_shield_swrc/shared.lua:
if (!file.Exists("autorun/vj_base_autorun.lua","LUA")) then return end

ENT.Base 			= "base_gmodentity"
ENT.Type 			= "anim"
ENT.PrintName 		= "DEWeakPointtarget"
ENT.Author 			= "DrVrej"
ENT.Contact 		= "http://steamcommunity.com/groups/vrejgaming"
ENT.Purpose 		= "FRED! SAY IT!"
ENT.Instructions 	= "MY LEEEEEGGGG!"
ENT.Category		= "Borderlands 2"

ENT.Spawnable = false
ENT.AdminOnly = false
---------------------------------------------------------------------------------------------------------------------------------------------
if (CLIENT) then
	function ENT:Draw()
		self:DrawModel()
	end
end

--PATH lua/entities/sent_vj_ply_spawnpoint.lua:
/*--------------------------------------------------
	*** Copyright (c) 2012-2023 by DrVrej, All rights reserved. ***
	No parts of this code or any of its contents may be reproduced, copied, modified or adapted,
	without the prior written consent of the author, unless otherwise indicated for stand-alone materials.
--------------------------------------------------*/
AddCSLuaFile()
if (!file.Exists("autorun/vj_base_autorun.lua","LUA")) then return end

ENT.Base 			= "base_gmodentity"
ENT.Type 			= "anim"
ENT.PrintName 		= "Player Spawnpoint"
ENT.Author 			= "DrVrej"
ENT.Contact 		= "http://steamcommunity.com/groups/vrejgaming"
ENT.Purpose 		= "Sets the spawnpoint for all the players in the map!"
ENT.Instructions 	= "Don't change anything."
ENT.Category		= "VJ Base"

ENT.Spawnable = true
ENT.AdminOnly = true
---------------------------------------------------------------------------------------------------------------------------------------------
if CLIENT then
	function ENT:Draw()
		self:DrawModel()
	end
end
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
if !SERVER then return end

ENT.Active = true -- Is this spawnpoint active?

local colorGreen = Color(0, 255, 0)
local colorRed = Color(255, 0, 0)

local sdActivated = Sound("hl1/fvox/activated.wav")
local sdDeactivated = Sound("hl1/fvox/deactivated.wav")
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:Initialize()
	self:SetModel("models/props_junk/sawblade001a.mdl")
	self:PhysicsInit(SOLID_VPHYSICS)
	self:SetMoveType(MOVETYPE_NONE)
	self:SetSolid(SOLID_VPHYSICS)
	self:SetCollisionGroup(COLLISION_GROUP_DEBRIS)
	self:SetUseType(SIMPLE_USE)

	local phys = self:GetPhysicsObject()
	if phys and IsValid(phys) then
		phys:Wake()
	end

	self:SetColor(colorGreen)
end
---------------------------------------------------------------------------------------------------------------------------------------------
function ENT:Use(activator, caller)
	if activator:IsPlayer() && activator:IsAdmin() then
		if (self.Active == true) then
			self.Active = false
			self:EmitSound(sdDeactivated, 70, 100)
			self:SetColor(colorRed)
			activator:PrintMessage(HUD_PRINTTALK, "#vjbase.print.plyspawnpoint.deactivated")
		else
			self.Active = true
			self:EmitSound(sdActivated, 70, 100)
			self:SetColor(colorGreen)
			activator:PrintMessage(HUD_PRINTTALK, "#vjbase.print.plyspawnpoint.activated")
		end
	end
end
--PATH lua/entities/shuffle_shield.lua:
return gluapack()()
--PATH lua/entities/soulless.lua:
return gluapack()()
--PATH gamemodes/starwarsrp/entities/entities/spawned_food/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Spawned Food"
ENT.Author = "Rickster"
ENT.Spawnable = false
ENT.IsSpawnedFood = true
ENT.EatSound = "vo/sandwicheat09.mp3" -- Requires Team Fortress 2

function ENT:SetupDataTables()
    self:NetworkVar("Entity", 1, "owning_ent")
end

--PATH lua/entities/speeder_base.lua:
ENT.RenderGroup = RENDERGROUP_BOTH
ENT.Base = "base_anim"
ENT.Type = "vehicle"

ENT.PrintName = "Speeder Base"
ENT.Author = "Liam0102"
ENT.Category = "Star Wars"
ENT.AutomaticFrameAdvance = true
ENT.Spawnable = false;
ENT.AdminSpawnable = false;
ENT.IsSWVehicle = true;
ENT._IsSpeederVehicle = true;

local classes = {
	"speeder_bike",
	"stap",
	"rep_tank",
	"aat",
	"republic_speeder",
	"podracer",
	"landspeeder",
	"imp_speeder",
	"tx130",
	// Add the class name of your speeder here (The file name)
}
function IsSWSpeeder(class)
	
	for k,v in pairs(classes) do
		if(v == class) then
			return true;
		end
	end
	return false;

end
if SERVER then
function CreateBulletStructure(dmg,color,nosplashdamage)
	if(color == "blue" and dmg/2 > 30) then
		dmg = 30;
	elseif(color == "blue" and dmg/2 <= 30) then
		dmg = dmg/2;
	end
    
    local noion = false;
    if(color == "blue_noion") then
        color = "blue";
        noion = true;
    end

	local bullet = {
		Spread		= Vector(0.001,0.001,0),
		Damage		= dmg*1.25,
		Force		= dmg,
		TracerName	= color .. "_tracer_fx",
		Callback = function(p,tr,damage)
			local self = damage:GetInflictor():GetParent();
			
			util.Decal( "fadingscorch", tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal );
			local fx = EffectData()
				fx:SetOrigin(tr.HitPos);
				fx:SetNormal(tr.HitNormal);
			util.Effect( "StunstickImpact", fx, true )
			
			if(Should_HeliDamage) then
				local e = tr.Entity;
				if(e:GetClass() == "npc_helicopter" or e:GetClass() == "npc_combinegunship") then
					local health = e:Health();
					local new_health = health - dmg;
					if(new_health <= 0) then
						e:Input("SelfDestruct")
					else
						e:SetHealth(health - dmg);
					end
				end
			end		
			if(IsValid(self) and self != tr.Entity) then
				if(!nosplashdamage) then
					util.BlastDamage( self, self.Pilot or self, tr.HitPos, dmg*1.5, dmg*0.66)
				end
				
				if(color == "blue" and !noion) then
					if(tr.Entity.IsSWVehicle) then
						tr.Entity.IonShots = tr.Entity.IonShots + 1;
					end
				end
			end
		end	
	}	
	return bullet;
end
ENT.NextUse = {Use = CurTime(),Fire = CurTime(),FireBlast=CurTime(),Engine=CurTime(),Boost=CurTime(),};
ENT.FireSound = Sound("weapons/xwing_shoot.wav");
ENT.StartHover = 100;

AddCSLuaFile();

function ENT:Initialize()

	self:SetModel(self.EntModel);
	self:PhysicsInit(SOLID_VPHYSICS);
	self:SetMoveType(MOVETYPE_VPHYSICS);
	self:SetSolid(SOLID_VPHYSICS);
	self:StartMotionController();
	self:SetUseType(SIMPLE_USE);
	self:SetRenderMode(RENDERMODE_TRANSALPHA);
	self.Hover = true;
	
	self:SetNWInt("Health",self.StartHealth);
	self.HoverAmount = 100;	

	self.Accel={
		FWD=0,
		RIGHT=0,
		UP=0,
	};
	
	self.ShouldStandby = true;
	self.EngineOn = true;
	
	self.UseGroundTraces = false;
	self.StandbyHoverMod = 1;
	self.StandbyHover = 0;
	
	if(!self.SpeederClass) then
		self.SpeederClass = 1;
	end
	
	local phys = self:GetPhysicsObject()

	if(phys:IsValid()) then
		phys:Wake()
		phys:SetMass(100000)
	end
end
    
ENT.Flashlight = {};
function ENT:CreateFlashlight()

    local i = 1;
    for k,v in pairs(self.Flashlights) do
        self.Flashlight[i] = ents.Create( "env_projectedtexture" )
        self.Flashlight[i]:SetParent(self)

        self.Flashlight[i]:SetLocalPos(v[1])
        self.Flashlight[i]:SetLocalAngles(v[2])

        self.Flashlight[i]:SetKeyValue( "enableshadows", 1 )
        self.Flashlight[i]:SetKeyValue( "farz", self.FlashlightDistance or 1000 )
        self.Flashlight[i]:SetKeyValue( "nearz", 12 )
        self.Flashlight[i]:SetKeyValue( "lightfov", 60 )

        local c = Color(255,255,255);
        local b = 0.7;
        self.Flashlight[i]:SetKeyValue( "lightcolor", Format( "%i %i %i 255", c.r * b, c.g * b, c.b * b ) )
        self.Flashlight[i]:Spawn()
        self.Flashlight[i]:Input( "SpotlightTexture", NULL, NULL, "effects/flashlight001" )
        i = i+1;
    end
    self.FlashlightOn = true;
end
    
function ENT:RemoveFlashlight()
        
   if(IsValid(self.Flashlight[1])) then
        for k,v in pairs(self.Flashlight) do
            v:Remove(); 
            
        end
        table.Empty(self.Flashlight);
    end
    self.FlashlightOn = false;
end

function ENT:SpeederClassing()
	local mod = 1;
	if(self.SpeederClass == 2) then
		//Probes
		local fs = self.ForwardSpeed;
		
		if(fs < 0) then 
			fs = fs * -1; 
			mod = -1;
		end
		if(fs > 500) then
			self.ForwardSpeed = 400*mod;
		end
		
		local ms = self.BoostSpeed;
		if(ms < 0) then ms = ms*-1 end;
		if(ms > fs * 1.5) then
			self.BoostSpeed = (fs * 1.5)*mod;
		end
	end	
end


function ENT:TestLoc(pos)

	local e = ents.Create("prop_physics");
	e:SetPos(pos);
	e:SetModel("models/Boba_Fett/props/orb.mdl");
	e:Spawn();
	e:Activate();
	e:SetParent(self);
	
end


function ENT:OnRemove()

	if(self.Inflight and not self.Destroyed) then
		if(IsValid(self.Pilot)) then
			self:Exit(true,false);
		end
		if(IsValid(self.Passenger)) then
			self:Exit(false,false);
		end
	end
end

ENT.DriverFPV = false;
ENT.PassengerFPV = false;
function ENT:Enter(p,driver)
	self:SetNWInt("MaxSpeed",self.BoostSpeed);
	p:SetNWInt("SW_Speeder_MaxSpeed",self.BoostSpeed)
	self:SpeederClassing();
	if(self.NextUse.Use < CurTime()) then
		p:SetNWEntity(self.Vehicle,self);
		p:SetNetworkedBool("Flying"..self.Vehicle,true);
		
		if(driver) then
			p:EnterVehicle(self.DriverChair);
            self.DriverChair:SetThirdPersonMode(self.DriverFPV);
			self:SetNWBool("Flying" .. self.Vehicle,true);	
			self.Pilot = p;
			p:SetNWEntity("DriverSeat",self.DriverChair);
			self.Inflight = true;
			self:Rotorwash(true);
			self:GetPhysicsObject():Wake();
			self:GetPhysicsObject():EnableMotion(true);
			self:StartMotionController()
		else
            if(IsValid(self.PassengerChair)) then
                p:EnterVehicle(self.PassengerChair);
                self.DriverChair:SetThirdPersonMode(self.PassengerFPV);
                self.Passenger = p;
                p:SetNWEntity("PassengerSeat",self.PassengerChair);
            end
		end

		self.NextUse.Use = CurTime()+1;
	end
end

function ENT:Exit(driver,kill)
	if(driver) then
		if(IsValid(self.Pilot)) then
			self.Pilot:SetNetworkedBool("Flying"..self.Vehicle,false);
			self.Pilot:SetNWEntity(self.Vehicle,NULL);
			self.Pilot:SetNWEntity("DriverSeat",NULL);
			if(self.ExitModifier) then
				self.Pilot:SetPos(self:GetPos() + self:GetRight() * self.ExitModifier.x + self:GetForward() * self.ExitModifier.y + self:GetUp() * self.ExitModifier.z);
			else
				self.Pilot:SetPos((self:GetPos()+self:GetUp()*20+self:GetForward()*5+self:GetRight()*-85) or self.ExitPos);
			end
			if (kill) then self.Pilot:Kill(); end
            self.DriverFPV = self.DriverChair:GetThirdPersonMode();
            self.DriverChair:SetThirdPersonMode(false);
            self.Pilot:ExitVehicle(self.DriverChair);
		end
		self.num = 0;
		self.Accel.FWD = 0;
		self.Pilot = NULL;
		self:Rotorwash(false);
		self.Inflight = false;
		self:SetNWEntity(self.Vehicle,nil);
		self:SetNWBool("Flying" .. self.Vehicle,false);
        
		self.Accel.FWD = 0;
	else
		if(IsValid(self.Passenger)) then
			self.Passenger:SetNWBool("Flying"..self.Vehicle,false);
			self.Passenger:SetNWEntity(self.Vehicle,NULL)
			self.Passenger:SetNWEntity("PassengerSeat",NULL);
			if(self.ExitModifier) then
				self.Passenger:SetPos(self:GetPos() + self:GetRight() * -self.ExitModifier.x + self:GetForward() * self.ExitModifier.y + self:GetUp() * self.ExitModifier.z);
			else
				self.Passenger:SetPos((self:GetPos()+self:GetUp()*20+self:GetForward()*5+self:GetRight()*-85) or self.ExitPos);
			end
			if(kill) then self.Passenger:Kill() end;
            self.PassengerFPV = self.PassengerChair:GetThirdPersonMode();
            self.PassengerChair:SetThirdPersonMode(false);
		end
		self.Passenger = NULL;
	end
	self.NextUse.Use = CurTime() + 1;
end



function ENT:Think()
	if(IsValid(self.Passenger)) then
		if(self.Passenger:GetVehicle() != self.PassengerChair) then
			self:Exit(false,false);
		end
	end
	if(self.Inflight) then
	
		if(IsValid(self.Pilot)) then		
			if(self.Pilot:GetVehicle() != self.DriverChair) then
				self:Exit(true,false);
			end
		end	
		

		
		if(IsValid(self.Pilot)) then
			if(self.Pilot:KeyDown(IN_USE)) then
				if(self.NextUse.Use < CurTime()) then
					self:Exit(true,false);
				end
			end
                
            if(self.Pilot:KeyDown(IN_RELOAD) and self.HasFlashlight) then
                if(self.FlashlightOn) then
                    self:RemoveFlashlight();
                else
                    self:CreateFlashlight();
                end     
            end
			
			if(self.Pilot:KeyDown(IN_SPEED) and self.SpeederClass == 1) then
				self:Boost();
			end
			
			if(self.CanShoot) then
				if(self.Pilot:KeyDown(IN_ATTACK)) then
					self:FireWeapons();
				end
			end
			
			/*
			if(self.Pilot:KeyDown(IN_RELOAD)) then
				self.EngineOn = false;
			else
				self.EngineOn = true;
			end
			*/
		end
		
		if(self.Boosting and self.BoostTimer < CurTime()) then
			self.Boosting = false;
		end
	end

end

function ENT:Use(p)

	if(not self.Inflight) then
		if(p:KeyDown(IN_WALK)) then
			if(IsValid(self.PassengerChair)) then
				self:Enter(p,false);
			end
		else
			self:Enter(p,true);
		end
	else
		if(not IsValid(self.Passenger)) then
			self:Enter(p,false);
		end
	end

end

hook.Add("PlayerEnteredVehicle","SWSpeederUse", function(p, e)
	if(IsValid(e) and IsValid(p) and p:IsPlayer()) then
		local speeder = e:GetParent();
		if(IsValid(speeder) and speeder.IsSWVehicle) then
			if(e.IsSpeederChair) then
				if(!IsValid(speeder.Pilot) and !speeder.Inflight) then
					speeder:Enter(p,true);
				end
			elseif(e.SpeederPassenger) then
				if(!IsValid(speeder.Passenger)) then
					speeder:Enter(p,false);
				end
			end
		end
	end
end);

function ENT:SpawnChairs(pos,ang,pass,pos2,ang2,pod)

	local e = ents.Create("prop_vehicle_prisoner_pod");
	e:SetPos(pos);
	e:SetAngles(ang);
	e:SetParent(self);
	if(!pod) then
		e:SetModel("models/nova/airboat_seat.mdl");
	else
		e:SetModel("models/vehicles/prisoner_pod_inner.mdl");
	end
	e:SetRenderMode(RENDERMODE_TRANSALPHA);
	e:SetColor(Color(255,255,255,0));
	e:Spawn();
	e:Activate();
	e:GetPhysicsObject():EnableMotion(false);
	e:GetPhysicsObject():EnableCollisions(false);
	if(self.SeatClass) then
		e:SetVehicleClass(self.SeatClass);
	end
	e:SetUseType(USE_OFF);
	e.DrivingAnimType = 2;
	e.IsSpeederChair = true;
	self.DriverChair = e;	
	
	
	if(pass) then
		local e = ents.Create("prop_vehicle_prisoner_pod");
		e:SetPos(pos2);
		e:SetAngles(ang2);
		e:SetParent(self);
		e:SetModel("models/nova/airboat_seat.mdl");
		e:SetUseType(USE_OFF);
		e:SetRenderMode(RENDERMODE_TRANSALPHA);
		e:SetColor(Color(255,255,255,0));
		e:Spawn();
		e:Activate();
		e:GetPhysicsObject():EnableMotion(false);
		e:GetPhysicsObject():EnableCollisions(false);
		self.PassengerChair = e;
		e.SpeederPassenger = true;
	end
end

function ENT:SpawnWeapons()
	self.Weapons = {};
	for k,v in pairs(self.WeaponLocations) do
		local e = ents.Create("prop_physics");
		e:SetModel("models/props_junk/PopCan01a.mdl");
		e:SetPos(v);
		e:Spawn();
		e:Activate();
		e:SetRenderMode(RENDERMODE_TRANSALPHA);
		e:SetSolid(SOLID_NONE);
		e:GetPhysicsObject():EnableCollisions(false);
		e:GetPhysicsObject():EnableMotion(false);
		e:AddFlags(FL_DONTTOUCH);
		e:SetColor(Color(255,255,255,0));
		e:SetParent(self);
		self.Weapons[k] = e;
	end

end

ENT.BoostTimer = CurTime();
function ENT:Boost()
	
	if(self.NextUse.Boost < CurTime()) then
		self.Accel.FWD = self.BoostSpeed;
		self.Boosting = true;
		self:EmitSound(Sound("vehicles/speeder_boost4.wav"),85,100,1,CHAN_VOICE)
		self.BoostTimer = CurTime()+5;
		self.NextUse.Boost = CurTime() + 10;
	end

end

function ENT:FireWeapons()

	if(self.NextUse.Fire < CurTime()) then
		for k,v in pairs(self.Weapons) do
		
			local tr = util.TraceLine({
				start = self:GetPos(),
				endpos = self:GetPos()+self.Pilot:GetAimVector():Angle():Forward()*10000,
				filter = {self},
			})
			
			local angPos = (tr.HitPos - v:GetPos())
		
			self.Bullet.Src		= v:GetPos();
			self.Bullet.Attacker = self.Pilot or self;	
			self.Bullet.Dir = angPos;

			v:FireBullets(self.Bullet)
		end
		self:EmitSound(self.FireSound, 120, math.random(90,110));
		self.NextUse.Fire = CurTime() + (self.FireDelay or 0.3);
	end
end

function ENT:FireBlast(pos,gravity,vel,ang)
	if(self.NextUse.FireBlast < CurTime()) then
		local e = ents.Create("cannon_blast");
		e:SetPos(pos);
		e:Spawn();
		e:Activate();
		e:Prepare(self,Sound("weapons/n1_cannon.wav"),gravity,vel,ang);
		e:SetColor(Color(255,255,255,1));
		
		self.NextUse.FireBlast = CurTime() + 3;
	end
	
end


function ENT:RunTraces()
	self.FrontTrace = util.TraceLine({
		start = self.FrontPos,
		endpos = self.FrontPos + self:GetUp()*-10000,
		filter = {self,self.DriverChair,self.PassengerChair},
		mask = MASK_SOLID,
	});
	
	self.BackTrace = util.TraceLine({
		start = self.BackPos,
		endpos = self.BackPos + self:GetUp()*-10000,
		filter = {self,self.DriverChair,self.PassengerChair},
		mask = MASK_SOLID,		
	});
	
	self.MiddleTrace = util.TraceLine({
		start = self.MiddlePos,
		endpos = self.MiddlePos + self:GetUp()*-10000,
		filter = {self,self.DriverChair,self.PassengerChair},
		mask = MASK_SOLID,
	});
	
	self.WaterTrace = util.TraceLine({
		start = self.FrontPos,
		endpos = self.FrontPos + self:GetUp()*-10000,
		filter = {self,self.DriverChair,self.PassengerChair},
		mask = MASK_WATER,
	});
	
end

local FlightPhys={
	secondstoarrive	= 0.5;
	maxangular		= 50000;
	maxangulardamp	= 100000;
	maxspeed			= 1000000;
	maxspeeddamp		= 500000;
	dampfactor		= 1;
	teleportdistance	= 5000;
};
local ZAxis = Vector(0,0,1);
ENT.Roll = 0;
ENT.YawAccel = 0;
ENT.num = 0;
function ENT:PhysicsSimulate( phys, deltatime )
	//if(IsValid(self.Pilot) and self.Pilot:KeyDown(IN_WALK)) then return end;
	local UP = ZAxis;
	local RIGHT = self.RightDir;
	local FWD = self.FWDDir;
	local worldZ;
	self:RunTraces();
	
        
	
	if(!self.Tractored) then
		if(self.Inflight and IsValid(self.Pilot)) then
			/*
			local h = ((self.FrontTrace.HitPos.z - self:GetPos().z) + (self.MiddleTrace.HitPos.z - self:GetPos().z) + (self.BackTrace.HitPos.z - self:GetPos().z)) / 3;
			if(h < -500) then
				return
			end
			*/
			
			if(self.EngineOn) then
				-- Accelerate
				
				if(self.Boosting) then
					self.num = self.BoostSpeed;
					util.ScreenShake(self.DriverChair:GetPos(),5,60,0.1,100)
				elseif(self.Pilot:KeyDown(IN_RELOAD) and self.Pilot:KeyDown(IN_JUMP)) then
					self.num = 0;
				elseif(self.Pilot:KeyDown(IN_FORWARD)) then
					self.num = self.num + self.ForwardSpeed/100;
				elseif(self.Pilot:KeyDown(IN_BACK)) then
					self.num = self.num - self.ForwardSpeed/100;
				elseif(self.Pilot:KeyDown(IN_FORWARD) and self.Pilot:KeyDown(IN_SPEED) and self.SpeederClass == 2) then
					self.num = self.num + self.BoostSpeed/100;
				end
				if(!self.Boosting) then
					local min,max;
					if(self.CanBack) then
						min = self.ForwardSpeed/2 * -1;
					else
						min = 0;
					end
					max = self.ForwardSpeed;
					if(self.Pilot:KeyDown(IN_SPEED) and self.SpeederClass == 2) then
						max = self.BoostSpeed;
					end
					if(self.ForwardSpeed > 0) then
						self.num = math.Clamp(self.num,min,max)
					elseif(self.ForwardSpeed < 0) then
						self.num = math.Clamp(self.num,max,min)
					end
				end				
				self.Accel.FWD = math.Approach(self.Accel.FWD,self.num,self.AccelSpeed);
				
				self:SetNWInt("Speed",self.Accel.FWD);
				if(IsValid(self.Pilot)) then
					self.Pilot:SetNWInt("SW_Speeder_Speed",self.Accel.FWD);
				end
				
				if(self.Pilot:KeyDown(IN_MOVERIGHT)) then
					self.YawAccel = -50 - (self.Accel.FWD/100);
				elseif(self.Pilot:KeyDown(IN_MOVELEFT)) then
					self.YawAccel = 50 + (self.Accel.FWD/100);
				else
					self.YawAccel = 0;
					ExtraRoll = 0;
				end
			
				phys:Wake();


				local ang = Angle(0,self:GetAngles().y+self.YawAccel,0);
				ang = ang + self.ExtraRoll;
				if(!self.WaterTrace.Hit and self.UseGroundTraces) then
					ang = ang + (self.PitchMod or Angle(0,0,0));
				end		

				worldZ = self:GetHover();

				if(!self.CriticalDamage) then
					FlightPhys.angle = ang; --+ Vector(90 0, 0)							
					FlightPhys.pos = Vector(self:GetPos().x,self:GetPos().y,worldZ)+(FWD*self.Accel.FWD)+(RIGHT*self.Accel.RIGHT)+(UP*self.Accel.UP);
				else
					FlightPhys.angle = ang;
					FlightPhys.pos = Vector(self:GetPos().x,self:GetPos().y,worldZ)+(FWD*-2000)			
				end
				FlightPhys.deltatime = deltatime;
				phys:ComputeShadowControl(FlightPhys);
			end
		else
			if(self.ShouldStandby) then
				
				phys:Wake();
				worldZ = self:GetHover(true);
				FlightPhys.angle = Angle(0,self:GetAngles().y,0);
				FlightPhys.pos = Vector(self:GetPos().x,self:GetPos().y,worldZ-(self.StandbyHoverAmount or (self.HoverAmount/1.5)));
				FlightPhys.deltatime = deltatime;
				phys:ComputeShadowControl(FlightPhys);
			end
		end
	end
end

function SWSpeederStandbyPickup(p,e)
	if(IsValid(e) and e.IsSWVehicle) then
		e.ShouldStandby = false;
	end
end
hook.Add( "PhysgunPickup", "SWSpeederStandbyPickup", SWSpeederStandbyPickup )

function SWSpeederStandbyDrop(p,e)
	if(IsValid(e) and e.IsSWVehicle) then
		e.ShouldStandby = true;
	end
end
hook.Add("PhysgunDrop", "SWSpeederStandbyDrop", SWSpeederStandbyDrop);


function ENT:GetHover(standby)
	local worldZ = 0;
	
	if(not self.WaterTrace.Hit or (self.WaterTrace.Hit and self.FrontTrace.Hit and (self.WaterTrace.HitPos.z < self.FrontTrace.HitPos.z) and self:WaterLevel() < 1)) then
		self.UseGroundTraces = true;
		if(self.FrontTrace.Hit and self.BackTrace.Hit) then
			
			if(!standby) then
				if(self.FrontTrace.HitPos.z >= self.BackTrace.HitPos.z) then
					self.HoverAmount = self.StartHover + (self.FrontTrace.HitPos.z - self.BackTrace.HitPos.z)*(self.HoverMod or 1);
				else
					self.HoverAmount = self.StartHover - (self.BackTrace.HitPos.z - self.FrontTrace.HitPos.z)*(self.HoverMod or 1);
				end
			else
				self.HoverAmount = self.StartHover;
			end
			
			self.HoverAmount = math.Clamp(self.HoverAmount,0,250);

			if(self.FrontTrace.HitPos.z >= self.BackTrace.HitPos.z and self.FrontTrace.HitPos.z >= self.MiddleTrace.HitPos.z) then
				worldZ = self.FrontTrace.HitPos.z+self.HoverAmount;
			elseif(self.MiddleTrace.HitPos.z >= self.BackTrace.HitPos.z and self.MiddleTrace.HitPos.z >= self.FrontTrace.HitPos.z) then
				worldZ = self.MiddleTrace.HitPos.z+self.HoverAmount;
			elseif(self.BackTrace.HitPos.z >= self.FrontTrace.HitPos.z and self.BackTrace.HitPos.z >= self.MiddleTrace.HitPos.z) then
				worldZ = self.BackTrace.HitPos.z+self.HoverAmount;
			end

		end

	else
		self.UseGroundTraces = false;
		if(self.FrontTrace.Hit) then
			if(self.FrontTrace.HitPos.z < self.WaterTrace.HitPos.z) then
				worldZ = self.WaterTrace.HitPos.z+self.StartHover;
			end
		end
	end
	
	if(!self.NoWobble) then
		if(self.StandbyHover <= -3) then
			self.StandbyHoverMod = 1;
		elseif(self.StandbyHover >= 3) then
			self.StandbyHoverMod = -1;
		end
		self.StandbyHover = math.Approach(self.StandbyHover,3*self.StandbyHoverMod,0.025*self.StandbyHoverMod);
		
		return worldZ + self.StandbyHover;
	end
	return worldZ;
end

function ENT:Rotorwash(b)

	if(b) then
		if(!IsValid(self.RotorWash)) then
			local e = ents.Create("env_rotorwash_emitter");
			e:SetPos(self:GetPos());
			e:SetParent(self);
			e:Spawn();
			e:Activate();
			self.RotorWash = e;
		end
	else
		if(IsValid(self.RotorWash)) then
			self.RotorWash:Remove();
			self.RotorWash:Fire("Kill");
		end
	end
end

function ENT:Bang(p) --######## The effect, and killing the player if they're flying @RononDex

	self:EmitSound(Sound("Explosion.mp3"),100,100); --Play the jumper's explosion sound(Only good explosion sound i have)
	local fx = EffectData();
		fx:SetOrigin(self:GetPos());
	util.Effect("dirtyxplo",fx);

	if(self.Inflight) then
		if(IsValid(self.Pilot)) then
			if(!self.Pilot:HasGodMode()) then
				self:Exit(true,true); --Let the player out...
			else
				self:Exit(true,false);
			end
		end
		if(IsValid(self.Passenger)) then
			if(!self.Passenger:HasGodMode()) then
				self:Exit(false,true);
			else
				self:Exit(false,false);
			end
		end
	end
	self.Done = true;
	self:Remove(); --Get rid of the vehicle

end

function ENT:PhysicsCollide(cdat, phys)


	local ephys = cdat.HitEntity:GetPhysicsObject();
	
	if((cdat.DeltaTime)>0.5) then --0.5 seconds delay between taking physics damage
		local mass = (cdat.HitEntity:GetClass() == "worldspawn") and 1000 or cdat.HitObject:GetMass() --if it's worldspawn use 1000 (worldspawns physobj only has mass 1), else normal mass
		local dmg = (cdat.Speed*cdat.Speed*math.Clamp(mass, 0, 1000))/1000000
		self.Accel.FWD = math.Approach(self.Accel.FWD,self.Accel.FWD / dmg,100*((ephys:GetVelocity():Length()+1)/ephys:GetMass()));
		self:TakeDamage(dmg)
	end
end

function ENT:OnTakeDamage(dmg) --########## Shuttle's aren't invincible are they? @RononDex

	local health=self:GetNetworkedInt("Health")-(dmg:GetDamage()/2)

	self:SetNWInt("Health",health);
	
	if(health<100) then
		self.CriticalDamage = true;
		self:SetNWBool("CriticalDamage",true);
	end
	
	
	if((health)<=0) then
		self:Bang() -- Go boom
	end
end


end

if CLIENT then

	function ENT:Initialize()

		self.FXEmitter = ParticleEmitter(self:GetPos());
		
		self.StandbySounds = Sound("ambient/atmosphere/ambience_base.wav");
		self.SoundsOn = {}
		if (self.Sounds and self.Sounds.Engine) then
			self.EngineSound = self.EngineSound or CreateSound(self.Entity,self.Sounds.Engine);
			self.StandbySound = self.StandbySound or CreateSound(self.Entity,self.StandbySounds);
		end
		
		surface.CreateFont( "HUD_Health", {
			font = "Aurebesh",
			size = 12,
			weight = 1000,
			blursize = 0,
			scanlines = 0,
			antialias = true,
			underline = false,
			italic = false,
			strikeout = false,
			symbol = false,
			rotary = false,
			shadow = false,
			additive = false,
			//outline = true,
			outline = false,
		} )
		
		surface.CreateFont( "HUD_Crosshair", {
			font = "Default",
			size = 24,
			weight = 250,
			blursize = 0,
			scanlines = 0,
			antialias = false,
			underline = false,
			italic = false,
			strikeout = false,
			symbol = false,
			rotary = false,
			shadow = false,
			additive = false,
			outline = true,
		} )
	end

	function ENT:Draw() self:DrawModel() end;
	
	function ENT:OnRemove()	
		if (self.EngineSound) then
			self.EngineSound:Stop();
		end
		
		if(self.StandbySound) then
			self.StandbySound:Stop();
		end
	end
	
	function ENT:StartClientsideSound(mode)
		if(not self.SoundsOn[mode]) then
			if(mode == "Engine" and self.EngineSound) then
				self.EngineSound:Stop();
				self.EngineSound:SetSoundLevel(110);
				self.EngineSound:PlayEx(100,100);
			elseif(mode == "Standby" and self.StandbySound) then
				self.StandbySound:Stop();
				self.StandbySound:SetSoundLevel(66);
				self.StandbySound:PlayEx(1,200);	
			end
			self.SoundsOn[mode] = true;
		end
	end

	function ENT:StopClientsideSound(mode)
		if(self.SoundsOn[mode]) then
			if(mode == "Engine" and self.EngineSound) then
				self.EngineSound:FadeOut(2);
			elseif(mode == "Standby" and self.StandbySound) then
				self.StandbySound:FadeOut(2);
			end
			self.SoundsOn[mode] = nil;
		end
	end
	
	local Health = 0;
	local Speed = 0;
	local MaxSpeed = 0;
	function ENT:Think()
		
		local p = LocalPlayer();
		local SpeederActive = self:GetNWBool("Flying" ..self.Vehicle);
		
		if(SpeederActive) then
			local IsDriver = p:GetNWEntity(self.Vehicle) == self.Entity;
			-- Normal behaviour for Pilot or people who stand outside
			self:StartClientsideSound("Engine");
			--#########  Now add Pitch etc
			local velo = self.Entity:GetVelocity();
			local pitch = self.Entity:GetVelocity():Length();
			local doppler = 0;
			-- For the Doppler-Effect!
			if(not IsDriver) then
				-- Does the vehicle fly to the player or away from him?
				local dir = (p:GetPos() - self.Entity:GetPos());
				doppler = velo:Dot(dir)/(150*dir:Length());
			end
			
			
			Speed = p:GetNWInt("SW_Speeder_Speed") or self:GetNWInt("Speed");
			MaxSpeed = p:GetNWInt("SW_Speeder_MaxSpeed") or self:GetNWInt("MaxSpeed");
			
			if(self.SoundsOn.Engine) then
				
				spd = Speed;
				mspd = MaxSpeed;
				if(spd < 0) then
					spd = Speed * -1;
					mspd = MaxSpeed * -1;
				end

				self.EngineSound:ChangePitch(math.Clamp(60 + pitch/25,75,100) + doppler,0);
			end
			//self:StopClientsideSound("Standby");
			
			Health = self:GetNWInt("Health");
			
		else
			self:StopClientsideSound("Engine");
			/*
			if(IsValid(self)) then
				self:StartClientsideSound("Standby");
			else
				self:StopClientsideSound("Standby");
			end
			*/
		end
	
	end
	
	function ENT:Effects(pos,boost)
	
		local p = LocalPlayer();
		local roll = math.Rand(-45,45);
		local normal = (self.Entity:GetRight() * -1):GetNormalized();
		local FWD = self:GetRight();
		for k,v in pairs(pos) do
			if(boost) then
				if(p:KeyDown(IN_SPEED) or k == "Left" or k == "Right") then
					local heatwv = self.FXEmitter:Add("sprites/heatwave",v);
					heatwv:SetVelocity(normal*2);
					heatwv:SetDieTime(0.1);
					heatwv:SetStartAlpha(255);
					heatwv:SetEndAlpha(255);
					heatwv:SetStartSize(10);
					heatwv:SetEndSize(8);
					heatwv:SetColor(255,255,255);
					heatwv:SetRoll(roll);
				end
			else
				local heatwv = self.FXEmitter:Add("sprites/heatwave",v);
				heatwv:SetVelocity(normal*2);
				heatwv:SetDieTime(0.1);
				heatwv:SetStartAlpha(255);
				heatwv:SetEndAlpha(255);
				heatwv:SetStartSize(10);
				heatwv:SetEndSize(8);
				heatwv:SetColor(255,255,255);
				heatwv:SetRoll(roll);
			end
		end
	end
	
	function SW_Speeder_DrawHull(StartHealth)
	
		surface.SetFont("HUD_Health");
		local w = ScrW()/100*20;
		local h = w / 4;
		
		local x = ScrW() - w - w/8;
		local y = ScrH() / 4*3.4;
		
		local per = ((Health/StartHealth)*100)/100;

		surface.SetDrawColor( color_white )
		surface.SetMaterial( Material( "hud/hull/hp_frame_under.png", "noclamp" ) )
		
		surface.DrawTexturedRectUV( x, y, w, h, 0, 0, 1, 1 )
		
		if(Critical) then
			if(Health > StartHealth * 0.1) then
				surface.SetDrawColor(Color(50,120,255,255));
			else
				surface.SetDrawColor(Color(255,35,35,255));
			end
		end
		
		local barX = x + w * 0.02832;
		local barY = y + h * 0.27343;
		local barW = w * 0.90625;
		local barH = h * 0.4;
		surface.SetMaterial( Material( "hud/hull/hp_bar.png", "noclamp" ) )
		surface.DrawTexturedRectUV( barX, barY, barW*per, barH, 0, 0, per, 1 )
		
		surface.SetMaterial( Material( "hud/hull/hp_frame_over.png", "noclamp" ) )
		surface.SetDrawColor( color_white )
		surface.DrawTexturedRectUV( x, y, w, h, 0, 0, 1, 1 )
		
		health = math.Round(Health/StartHealth*100);
		health = health .. "%";
		local tW, tH = surface.GetTextSize(health);
		

		surface.SetTextColor(Color(255,255,255,255));
		x = x + w * 0.2775;
		y = y - tH / 2 + h * 0.1
		
		surface.SetTextPos(x,y + tH/2);
		surface.DrawText(health)

	end
	
	function SW_Speeder_DrawSpeedometer()
	
		local n = Speed;
		local ms = MaxSpeed;
		local reversed = false;
		if(ms < 0) then
			reversed = true;
			ms = ms * -1;
		end
		
		
		local c = color_white;
		if(reversed) then
			if(n > 0) then
				c = Color(255,50,50,255);
			end
		else
			if(n < 0) then
				c = Color(255,50,50,255);
				n = n * -1;
			end
		end
		if(n < 0) then
			n = n * -1;
		end

			local w = ScrW()/100*20;
		local h = w / 4;
		
		local x = ScrW() - w - w/8;
		local y = ScrH() / 4*3.4 + h/2*1.5;
		
		local per = ((n/ms)*100)/100;
		
		surface.SetDrawColor(color_white)
		surface.SetMaterial( Material( "hud/speedo/speed_frame_under.png", "noclamp" ) )
		surface.DrawTexturedRectUV( x, y, w, h, 0, 0, 1, 1 )
		
		local barX = x + w * 0.01953125;
		local barY = y + h * 0.234375;
		local barW = w * 0.9541015625;
		local barH = h * 0.53515625;
		surface.SetDrawColor(c)
		surface.SetMaterial( Material( "hud/speedo/speed_bar.png", "noclamp" ) )
		surface.DrawTexturedRectUV( barX, barY, barW*per, barH, 0, 0, per, 1 )
		
		surface.SetDrawColor(color_white)
		surface.SetMaterial( Material( "hud/speedo/speed_frame_over.png", "noclamp" ) )
		surface.DrawTexturedRectUV( x, y, w, h, 0, 0, 1, 1 )
		
		local blur = Speed/1000*-1;
		//DrawMotionBlur( 0.2, blur, 0.01 )


	end
	
	function SW_Speeder_Reticles(self,WeaponsPos) 
		local p = LocalPlayer();

		for i=1,table.Count(WeaponsPos) do
			local tr = util.TraceLine( {
				start = WeaponsPos[i],
				endpos = WeaponsPos[i] + p:GetAimVector():Angle():Forward()*10000,
				filter = {self},
			} )
			
			
			
			
			local material = "hud/reticle.png"
			local vpos = tr.HitPos;
			if(IsValid(tr.Entity)) then
				if(IsSWSpeeder(tr.Entity:GetClass()) and tr.Entity != self) then
					material = "hud/reticle_lock.png"
				end
			end
			local screen = vpos:ToScreen();

			local x,y;
			for k,v in pairs(screen) do
				if k=="x" then
					x = v;
				elseif k=="y" then
					y = v;
				end
			end
			

			local x,y;
			for k,v in pairs(screen) do
				if k=="x" then
					x = v;
				elseif k=="y" then
					y = v;
				end
			end
			
							
			local w = ScrW()/100*2;
			local h = w;
			surface.SetDrawColor( color_white )
			surface.SetMaterial( Material( material, "noclamp" ) )
			surface.DrawTexturedRectUV( x - w/2 , y - h/2, w, h, 0, 0, 1, 1 )

		end
	end
	
end
--PATH lua/entities/speeder_bike.lua:
ENT.RenderGroup = RENDERGROUP_BOTH
ENT.Base = "speeder_base"
ENT.Type = "vehicle"

ENT.PrintName = "Speeder Bike"
ENT.Author = "Liam0102"
ENT.Category = "Star Wars Vehicles: Empire"
ENT.AutomaticFrameAdvance = true
ENT.Spawnable = false;
ENT.AdminSpawnable = false;

ENT.Vehicle = "SpeederBike"; // The unique name for the speeder.
ENT.EntModel = "models/SGG/Starwars/speeder_bike.mdl"; // The path to your model
list.Set("SWVehicles", ENT.PrintName, ENT);

ENT.StartHealth = 1000;
if SERVER then

ENT.NextUse = {Use = CurTime(),Fire = CurTime()};
ENT.FireSound = Sound("vehicles/speeder_shoot.wav");


AddCSLuaFile();
function ENT:SpawnFunction(pl, tr)
	local e = ents.Create("speeder_bike");
	e:SetPos(tr.HitPos + Vector(0,0,10));
	e:SetAngles(Angle(0,pl:GetAimVector():Angle().Yaw+180,0));
	e:Spawn();
	e:Activate();
	return e;
end

function ENT:Initialize()
	self.BaseClass.Initialize(self);
	local driverPos = self:GetPos()+self:GetUp()*20+self:GetRight()*-10;
	local driverAng = self:GetAngles()+Angle(0,180,0);
	self:SpawnChairs(driverPos,driverAng,false)
	
	self.ForwardSpeed = -600;
	self.BoostSpeed = -900
	self.AccelSpeed = 8;
	self.WeaponLocations = {
		Main = self:GetPos()+self:GetRight()*100+self:GetUp()*15,
	}
	self.WeaponDir = self:GetAngles():Right();
	self:SpawnWeapons();
	self.HoverMod = 3;
	self.StartHover = 50;
	self.StandbyHoverAmount = 40;
	self.CanShoot = true;
	self.Bullet = CreateBulletStructure(100,"red");
	self.Flashlights = {
        {Vector(0,-100,0),Angle(0,-90,0)}
    }
    self.HasFlashlight = true;
end


local ZAxis = Vector(0,0,1);

function ENT:PhysicsSimulate( phys, deltatime )
	self.BackPos = self:GetPos()+self:GetRight()*-70+self:GetUp()*15;
	self.FrontPos = self:GetPos()+self:GetRight()*100+self:GetUp()*15;
	self.MiddlePos = self:GetPos()+self:GetUp()*15;
	if(self.Inflight) then
		local UP = ZAxis;
		self.RightDir = self.Entity:GetForward()*-1;
		self.FWDDir = self.Entity:GetForward():Cross(UP):GetNormalized()*-1;	
		

		
		self:RunTraces();

		self.ExtraRoll = Angle(self.YawAccel / 2,0,0);
		if(self.FrontTrace.HitPos.z >= self.BackTrace.HitPos.z) then
			self.PitchMod = Angle(0,0,math.Clamp((self.BackTrace.HitPos.z - self.FrontTrace.HitPos.z),-45,45)/2)
		else
			self.PitchMod = Angle(0,0,math.Clamp(-(self.FrontTrace.HitPos.z - self.BackTrace.HitPos.z),-45,45)/2)
		end
	end
	
	self.BaseClass.PhysicsSimulate(self,phys,deltatime);
	

end

end

if CLIENT then
	ENT.Sounds={
		Engine=Sound("vehicles/speederbike/speederbike_engine.wav"),
	}
	ENT.HasCustomCalcView = true;
	local Health = 0;
	local Speed = 0;
	function ENT:Think()
		self.BaseClass.Think(self);
		local p = LocalPlayer();
		local Flying = p:GetNWBool("Flying"..self.Vehicle);
		if(Flying) then

			Speed = self:GetNWInt("Speed");
		end
		
	end

	local View = {}
	function SpeederBikeCalcView()
		
		local p = LocalPlayer();
		local self = p:GetNWEntity("SpeederBike", NULL)
		local DriverSeat = p:GetNWEntity("DriverSeat",NULL);
		local PassengerSeat = p:GetNWEntity("PassengerSeat",NULL);
		if(IsValid(self)) then

			if(IsValid(DriverSeat)) then
				if(DriverSeat:GetThirdPersonMode()) then
					local pos = self:GetPos()+self:GetRight()*-250+self:GetUp()*100;
					//local face = self:GetAngles() + Angle(0,-90,0);
					local face = ((self:GetPos() + Vector(0,0,100))- pos):Angle();
						View.origin = pos;
						View.angles = face;
					return View;
				end
			end

		end
	end
	hook.Add("CalcView", "SpeederBikeView", SpeederBikeCalcView)

	
	hook.Add( "ShouldDrawLocalPlayer", "SpeederBikeDrawPlayerModel", function( p )
		local self = p:GetNWEntity("SpeederBike", NULL);
		local DriverSeat = p:GetNWEntity("DriverSeat",NULL);
		local PassengerSeat = p:GetNWEntity("PassengerSeat",NULL);
		if(IsValid(self)) then
			if(IsValid(DriverSeat)) then
				if(DriverSeat:GetThirdPersonMode()) then
					return true;
				end
			elseif(IsValid(PassengerSeat)) then
				if(PassengerSeat:GetThirdPersonMode()) then
					return true;
				end
			end
		end
	end);
	
	function SpeederBikeReticle()
	
		local p = LocalPlayer();
		local Flying = p:GetNWBool("FlyingSpeederBike");
		local self = p:GetNWEntity("SpeederBike");
		if(Flying and IsValid(self)) then
			local WeaponsPos = {self:GetPos()};
			
			SW_Speeder_Reticles(self,WeaponsPos)
			SW_Speeder_DrawHull(1000)
			SW_Speeder_DrawSpeedometer()

		end
	end
	hook.Add("HUDPaint", "SpeederBikeReticle", SpeederBikeReticle)
	
	
end
--PATH lua/entities/tfa_ammo_base.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/entities/tfa_battlefront_ent_nade_stun.lua:
return gluapack()()
--PATH lua/entities/tfa_exp_base/shared.lua:
return gluapack()()
--PATH lua/entities/tfa_exp_rocket.lua:
AddCSLuaFile()

ENT.Base = "tfa_exp_base"
ENT.PrintName = "Rocket-Propelled Explosive"

-- EDITABLE PARAMETERS -- START

ENT.LaunchSound = "" -- none, replace to enable
ENT.PropelSound = Sound("Missile.Accelerate") -- looped propel sound

ENT.BaseSpeed = 500 -- base rocket speed, in units

ENT.AccelerationTime = 0.25 -- time in seconds to accelerate to max speed
ENT.MaxSpeed = 1500 -- maximum speed, works if AccelerationTime > 0

ENT.HasTrail = true -- create trail

-- EDITABLE PARAMETERS -- END

ENT.AccelProgress = 0

ENT.DefaultModel = Model("models/weapons/w_missile.mdl")
ENT.Delay = 10

DEFINE_BASECLASS(ENT.Base)

-- Creates HL2 rocket trail by default, feel free to copy and edit to your needs
function ENT:CreateRocketTrail()
	if not SERVER then return end

	local rockettrail = ents.Create("env_rockettrail")
	rockettrail:DeleteOnRemove(self)

	rockettrail:SetPos(self:GetPos())
	rockettrail:SetAngles(self:GetAngles())
	rockettrail:SetParent(self)
	rockettrail:SetMoveType(MOVETYPE_NONE)
	rockettrail:AddSolidFlags(FSOLID_NOT_SOLID)

	rockettrail:SetSaveValue("m_Opacity", 0.2)
	rockettrail:SetSaveValue("m_SpawnRate", 100)
	rockettrail:SetSaveValue("m_ParticleLifetime", 0.5)
	rockettrail:SetSaveValue("m_StartColor", Vector(0.65, 0.65, 0.65))
	rockettrail:SetSaveValue("m_EndColor", Vector(0, 0, 0))
	rockettrail:SetSaveValue("m_StartSize", 8)
	rockettrail:SetSaveValue("m_EndSize", 32)
	rockettrail:SetSaveValue("m_SpawnRadius", 4)
	rockettrail:SetSaveValue("m_MinSpeed", 2)
	rockettrail:SetSaveValue("m_MaxSpeed", 16)
	rockettrail:SetSaveValue("m_nAttachment", 0)
	rockettrail:SetSaveValue("m_flDeathTime", CurTime() + 999)

	rockettrail:Activate()
	rockettrail:Spawn()
end

function ENT:Initialize(...)
	BaseClass.Initialize(self, ...)

	self:EmitSoundNet(self.PropelSound)

	if self.LaunchSound and self.LaunchSound ~= "" then
		self:EmitSoundNet(self.LaunchSound)
	end

	self:SetFriction(0)
	self:SetLocalAngularVelocity(angle_zero)

	self:SetMoveType(bit.bor(MOVETYPE_FLYGRAVITY, MOVECOLLIDE_FLY_BOUNCE))
	self:SetLocalVelocity(self:GetForward() * self.BaseSpeed)

	if self.HasTrail then
		self:CreateRocketTrail()
	end
end

function ENT:Think(...)
	if self.AccelerationTime > 0 and self.AccelProgress < 1 then
		self.LastAccelThink = self.LastAccelThink or CurTime()
		self.AccelProgress = Lerp((CurTime() - self.LastAccelThink) / self.AccelerationTime, self.AccelProgress, 1)
	end

	self:SetLocalVelocity(self:GetForward() * Lerp(self.AccelProgress, self.BaseSpeed, self.MaxSpeed))

	return BaseClass.Think(self, ...)
end

function ENT:Explode(...)
	self:StopSound(self.PropelSound)

	return BaseClass.Explode(self, ...)
end

function ENT:Touch()
	self.killtime = -1
end

--PATH lua/entities/tfbow_arrow/cl_init.lua:
return gluapack()()
--PATH lua/entities/tfbow_arrow_stuck_clientside/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	if IsValid( self:GetParent() ) then
		self:GetParent():SetupBones()
	end
	self:SetupBones()
	self:DrawModel()
end
--PATH lua/entities/tfbow_arrow_stuck_clientside/shared.lua:
ENT.Type = "anim"
ENT.PrintName = "Sawblade"
ENT.Author = ""
ENT.Contact = ""
ENT.Purpose = ""
ENT.Instructions = ""
ENT.DoNotDuplicate = true
ENT.DisableDuplicator = true

ENT.glitchthreshold = 24 --threshold distance from bone to reset pos
ENT.glitchthresholds = {}
ENT.glitchthresholds["ValveBiped.Bip01_Head1"] = 8
ENT.glitchthresholds["ValveBiped.Bip01_Head"] = 8
ENT.glitchthresholds["ValveBiped.Bip01_R_Hand"] = 1
ENT.glitchthresholds["ValveBiped.Bip01_L_Hand"] = 1
ENT.glitchthresholds["ValveBiped.Bip01_Spine2"] = 40

ENT.Hull = 1.5 --Expand hull to make it easier to grab
ENT.PredictCL = false
ENT.UseMod = false --Experimentally modify the parent's Use func

local cv_al = GetConVar("sv_tfa_arrow_lifetime")
local nzombies

local function GetBoneCenter(ent, bone)
	local bonechildren = ent:GetChildBones(bone)

	if #bonechildren <= 0 then
		return ent:GetBonePosition(bone)
	else
		local bonepos = ent:GetBonePosition(bone)
		local tmppos = bonepos

		if tmppos then
			for i = 1, #bonechildren do
				local childpos = ent:GetBonePosition(bonechildren[i])

				if childpos then
					tmppos = (tmppos + childpos) / 2
				end
			end
		else
			return ent:GetPos()
		end

		return tmppos
	end
end

function ENT:Initialize()

	if nzombies == nil then
		nzombies = nZombies or NZ or NZombies or engine.ActiveGamemode() == "nzombies"
	end

	local mdl = self:GetModel()

	if not mdl or mdl == "" or mdl == "models/error.mdl" then
		self:SetModel("models/weapons/w_tfa_arrow.mdl")
	end

	if SERVER then

		local mins = (self:OBBMins() and self:OBBMins() or Vector(0, 0, 0)) - Vector(1, 1, 1)
		local maxs = (self:OBBMaxs() and self:OBBMaxs() or Vector(0, 0, 0)) + Vector(1, 1, 1)
		self:PhysicsInitBox(mins * self.Hull, maxs * self.Hull)
		--self:PhysicsInit( SOLID_VPHYSICS )
		--self:SetSolid( SOLID_VPHYSICS )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		local phys = self:GetPhysicsObject()

		if (phys:IsValid()) then
			phys:Wake()
			phys:SetMass(2)
			phys:EnableGravity(false)
			phys:EnableCollisions(false)
		end

		if self.SetUseType then
			self:SetUseType(SIMPLE_USE)
		end

		if cv_al:GetInt() ~= -1 then
			timer.Simple( cv_al:GetFloat(), function()
				if IsValid(self) then
					self:Remove()
				end
			end)
		end

		self:SetUseType( SIMPLE_USE )
	end

	if SERVER then
		self:TargetEnt( true )
	end

	if CLIENT then
		self:SetPredictable(false)
	end

	if (self:GetModel() and self:GetModel() == "") then
		self:SetModel("models/weapons/w_tfa_arrow.mdl")
	end

	self:SetCollisionGroup(COLLISION_GROUP_WEAPON)

	self:DrawShadow(true)
end

function ENT:TargetEnt( init )
	if self.targent and IsValid(self.targent) then
		if init then
			local ent, bone, bonepos, bonerot
			ent = self.targent
			bone = self.targent:TranslatePhysBoneToBone(self.targphysbone)
			self.targbone = bone

			if not ent:GetBoneCount() or ent:GetBoneCount() <= 1 or string.find(ent:GetModel(), "door") then
				bonepos = ent:GetPos()
				bonerot = ent:GetAngles()
				self.enthasbones = false
			else
				if ent.SetupBones then
					ent:SetupBones()
				end

				bonepos, bonerot = ent:GetBonePosition(bone)
				self.enthasbones = true
			end

			if self.enthasbones == true then
				local gpos = self:GetPos()
				local bonepos2 = GetBoneCenter(ent, bone)
				local tmpgts = self.glitchthresholds[ent:LookupBone(bone)] or self.glitchthreshold

				while gpos:Distance(bonepos2) > tmpgts do
					self:SetPos((gpos + bonepos2) / 2)
					gpos = (gpos + bonepos2) / 2
				end
			end

			if not bonepos then
				bonepos = ent:GetPos()
				bonerot = ent:GetAngles()
			end

			self.posoff, self.angoff = WorldToLocal(self:GetPos(), self:GetAngles(), bonepos, bonerot)
		end
		self:FollowBone( self.targent, self.targbone or -1 )
		self:SetOwner( self.targent )
		self:SetLocalPos( self.posoff )
		self:SetLocalAngles( self.angoff )
		self.HTE = true
		if SERVER and self.PredictCL then
			timer.Simple(0.05,function()
				if IsValid(self) then
					net.Start("tfaArrowFollow")
					net.WriteEntity( self )
					net.WriteEntity( self.targent )
					net.WriteInt( self.targbone, 8 )
					net.WriteVector( self.posoff )
					net.WriteAngle( self.angoff )
					net.Broadcast()
				end
			end)
		end
	end
end

function ENT:Think()
	if CLIENT and not self.PredictCL then return end
	if IsValid(self.targent) and self.targent.Health and self.targent:Health() <= 0 and self.targent.GetRagdollEntity then
		local rag = self.targent:GetRagdollEntity()
		if IsValid(rag) then
			self.targent = rag
			self:TargetEnt( false )
		end
	end
	local par = self:GetParent()
	if IsValid(par) and self.UseMod and not par.HasUseMod then
		par.HasUseMod = true
		par.ArrowUseOld = par.ArrowUseOld or par.Use
		par.Use = function( parent, ... )
			for _,v in pairs( par:GetChildren() ) do
				if v.Use then v:Use(...) end
			end
			parent:Use( ... )
		end
		par:SetUseType( SIMPLE_USE )
	end
	if SERVER and not self.HTE then
		self:TargetEnt( true )
	end
	self:NextThink(CurTime())
	return true
end
--PATH lua/entities/tie_interceptor.lua:
return gluapack()()
--PATH lua/entities/turbolaserspawner/shared.lua:
return gluapack()()
--PATH lua/entities/tx130.lua:
return gluapack()()
--PATH lua/effects/arc9_muzzleeffect.lua:
return gluapack()()
--PATH lua/effects/arccw_flashexplosion.lua:
local images_smoke = {"particle/smokesprites_0001", "particle/smokesprites_0002", "particle/smokesprites_0003", "particle/smokesprites_0004", "particle/smokesprites_0005", "particle/smokesprites_0006", "particle/smokesprites_0007", "particle/smokesprites_0008", "particle/smokesprites_0009", "particle/smokesprites_0010", "particle/smokesprites_0011", "particle/smokesprites_0012", "particle/smokesprites_0013", "particle/smokesprites_0014", "particle/smokesprites_0015", "particle/smokesprites_0016"}

local function TableRandomChoice(tbl)
    return tbl[math.random(#tbl)]
end

function EFFECT:Init(data)
    self.Origin = data:GetOrigin()

    util.Decal("FadingScorch", self.Origin, self.Origin - Vector(0, 0, 16))

    local emitter = ParticleEmitter( self.Origin + Vector( 0, 0, 16 ) )

    for i = 0,5 do
        local particle = emitter:Add( TableRandomChoice(images_smoke) , self.Origin )
        local scol = math.Rand( 200, 225 )

        particle:SetVelocity( 250 * VectorRand() )
        particle:SetDieTime( math.Rand(1.5, 5) )
        particle:SetStartAlpha( 255 )
        particle:SetEndAlpha( 0 )
        particle:SetStartSize( math.Rand(100,200) )
        particle:SetEndSize( math.Rand(300,400) )
        particle:SetRoll( math.Rand(0,360) )
        particle:SetRollDelta( math.Rand(-1,1) )
        particle:SetColor( scol,scol,scol )
        particle:SetAirResistance( 100 )
        particle:SetGravity( Vector( math.Rand(-30,30) ,math.Rand(-30,30),math.Rand(10,40)) )
        particle:SetLighting( true )
        particle:SetCollide( true )
        particle:SetBounce( 0.5 )
    end

    local particle = emitter:Add( "sprites/heatwave", self.Origin )
        particle:SetAirResistance( 0 )
        particle:SetDieTime( 1.5 )
        particle:SetStartAlpha( 255 )
        particle:SetEndAlpha( 255 )
        particle:SetStartSize( 250 )
        particle:SetEndSize( 0 )
        particle:SetRoll( math.Rand(180,480) )
        particle:SetRollDelta( math.Rand(-5,5) )
        particle:SetColor( 255, 255, 255 )

    local fire = emitter:Add( "particle/fire", self.Origin )
        fire:SetAirResistance( 0 )
        fire:SetDieTime( 0.1 )
        fire:SetStartAlpha( 255 )
        fire:SetEndAlpha( 0 )
        fire:SetEndSize( 0 )
        fire:SetStartSize( 800 )
        fire:SetRoll( math.Rand(180,480) )
        fire:SetRollDelta( math.Rand(-1,1) )
        fire:SetColor( 255, 255, 255 )

    local light = DynamicLight(self:EntIndex())
    if (light) then
        light.Pos = self.Origin
        light.r = 255
        light.g = 255
        light.b = 255
        light.Brightness = 9
        light.Decay = 2500
        light.Size = 512
        light.DieTime = CurTime() + 0.1
    end

    emitter:Finish()

end

function EFFECT:Think()
    return false
end

function EFFECT:Render()
end
--PATH lua/effects/arccw_muzzleeffect.lua:
return gluapack()()
--PATH lua/effects/asa6_tracer.lua:
AddCSLuaFile()
AddCSLuaFile( "effects/fxbase.lua" )
include( "effects/fxbase.lua" )

EFFECT.ParticleCast = false
EFFECT.Time = nil

EFFECT.Speed = 24000
function EFFECT:Think()

	if ( !self.ParticleCast ) then
		util.ParticleTracerEx( 
			"asa6_tracer", 	--particle system
			self.StartPos, 	--startpos
			self.EndPos, 	--endpos
			false, 			--do whiz effect
			-1, 			--entity index
			-1  			--attachment
		)
		
		self.ParticleCast = true
	end
	
	if ( !self.Time ) then	
		self.Time = self.LifeTime + CurTime()
	end
	
	local Fraction = math.max( 0, ( self.Time - CurTime() ) / self.LifeTime )
	
	local difforigin = self.EndPos - self.StartPos
	local lightorigin = self.StartPos + ( difforigin * ( 1 - Fraction ) ) 

	local mLight = DynamicLight( -1 )
	if ( mLight ) then
		mLight.pos = lightorigin
		mLight.r = 130
		mLight.g = 120
		mLight.b = 255
		mLight.brightness = 3 * Fraction
		mLight.Size = 180 + 200 * Fraction
		mLight.Decay = 1024
		mLight.Style = 1
		mLight.DieTime = CurTime() + 1
	end
	
	return ( self.Time > CurTime() ) 
	
end

--PATH lua/effects/asa6_tracer_noattach.lua:
AddCSLuaFile()
AddCSLuaFile( "effects/fxbase.lua" )
include( "effects/fxbase.lua" )

EFFECT.ParticleCast = false
EFFECT.Time = nil
EFFECT.Speed = 12000
EFFECT.Length	= 64

function EFFECT:Init( data )

	self.StartPos = data:GetStart() --self:GetTracerOrigin( data )
	self.EndPos = data:GetOrigin()
	self.Parent = data:GetEntity()
	
	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos )

	local diff = ( self.EndPos - self.StartPos )
	
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	
	if ( !self.LifeTime ) then
		self.LifeTime = ( diff:Length() + self.Length ) / self.Speed
	else
		self.LifeTime = CurTime() + self.LifeTime
	end
	
end

function EFFECT:Think()
	
	if ( !self.ParticleCast ) then
		util.ParticleTracerEx( 
			"asa6_tracer", 	--particle system
			self.StartPos, 	--startpos
			self.EndPos, 	--endpos
			false, 			--do whiz effect
			-1, 			--entity index
			-1  			--attachment
		)
		
		self.ParticleCast = true
	end
	
	if ( !self.Time ) then	
		self.Time = self.LifeTime + CurTime()
	end
	
	local Fraction = math.max( 0, ( self.Time - CurTime() ) / self.LifeTime )
	
	local difforigin = self.EndPos - self.StartPos
	local lightorigin = self.StartPos + ( difforigin * ( 1 - Fraction ) ) 

	local mLight = DynamicLight( -1 )
	if ( mLight ) then
		mLight.pos = lightorigin
		mLight.r = 120
		mLight.g = 130
		mLight.b = 255
		mLight.brightness = 4 * Fraction
		mLight.Size = 180 + 200 * Fraction
		mLight.Decay = 1024
		mLight.Style = 1
		mLight.DieTime = CurTime() + 1
	end

	return ( self.Time > CurTime() )
	
end

--PATH lua/effects/astra_beam_noattach.lua:
AddCSLuaFile()
AddCSLuaFile( "effects/fxbase.lua" )
include( "effects/fxbase.lua" )

EFFECT.ParticleCast = false
EFFECT.Time = nil
EFFECT.Speed = 12000
EFFECT.Length	= 64

function EFFECT:Init( data )

	self.StartPos = data:GetStart() --self:GetTracerOrigin( data )
	self.EndPos = data:GetOrigin()
	self.Parent = data:GetEntity()
	
	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos )

	local diff = ( self.EndPos - self.StartPos )
	
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	
	if ( !self.LifeTime ) then
		self.LifeTime = ( diff:Length() + self.Length ) / self.Speed
	else
		self.LifeTime = CurTime() + self.LifeTime
	end
	
end

function EFFECT:Think()
	
	if ( !self.ParticleCast ) then
		util.ParticleTracerEx( 
			"astra_beam", 	--particle system
			self.StartPos, 	--startpos
			self.EndPos, 	--endpos
			false, 			--do whiz effect
			-1, 			--entity index
			-1  			--attachment
		)
		
		self.ParticleCast = true
	end
	
	if ( !self.Time ) then	
		self.Time = self.LifeTime + CurTime()
	end
	
	local Fraction = math.max( 0, ( self.Time - CurTime() ) / self.LifeTime )
	
	local difforigin = self.EndPos - self.StartPos
	local lightorigin = self.StartPos + ( difforigin * ( 1 - Fraction ) ) 

	local mLight = DynamicLight( -1 )
	if ( mLight ) then
		mLight.pos = lightorigin
		mLight.r = 120
		mLight.g = 130
		mLight.b = 255
		mLight.brightness = 4 * Fraction
		mLight.Size = 180 + 200 * Fraction
		mLight.Decay = 1024
		mLight.Style = 1
		mLight.DieTime = CurTime() + 1
	end

	return ( self.Time > CurTime() )
	
end

--PATH lua/effects/astw2_muzzleflash_swrc_blue/init.lua:
return gluapack()()
--PATH lua/effects/astw2_muzzleflash_swrc_conc_rifle/init.lua:
return gluapack()()
--PATH lua/effects/astw2_swrc_explosion_emp_grenade/init.lua:

function EFFECT:Init(data)
    self.Origin = data:GetOrigin()
    local emitter = ParticleEmitter( self.Origin + Vector( 0, 0, 16 ) )
local light = DynamicLight(self:EntIndex())
        if (light) then
            light.Pos = self:GetPos()
            light.r = 255
            light.g = 100
            light.b = 200
            light.Brightness = 5
            light.Decay = 10
            light.Size = 256
            light.DieTime = CurTime() + 0.3
        end
    local particle = emitter:Add("effects/swbf/emp", self.Origin)

    particle:SetVelocity( 25 * VectorRand() )
    particle:SetDieTime( 0.7 )
    particle:SetStartAlpha( 255 )
    particle:SetEndAlpha( 0 )
    particle:SetStartSize( math.Rand(50,75) )
    particle:SetEndSize( math.Rand(150,250) )
    particle:SetRoll( math.Rand(0,360) )
    particle:SetRollDelta( math.Rand(-3,3) )
    particle:SetColor( 255, 100, 255 )
    particle:SetAirResistance( 55 )
    particle:SetLighting( false )
    particle:SetCollide( false )

    for i = 0,5 do
        particle = emitter:Add( "effects/swbf/lightningball1" , self.Origin )

        particle:SetVelocity( 1 * VectorRand() )
        particle:SetDieTime( math.Rand(0.5, 1.5) )
        particle:SetStartAlpha( 200 )
        particle:SetEndAlpha( 0 )
        particle:SetStartSize( math.Rand(50,75) )
        particle:SetEndSize( math.Rand(150,200) )
        particle:SetRoll( math.Rand(0,360) )
        particle:SetRollDelta( math.Rand(-3,3) )
        particle:SetColor( 50,50,255 )
        particle:SetAirResistance( 200 )
        particle:SetGravity( Vector( 0, 0, math.Rand(10,40) ) )
        particle:SetLighting( false )
        particle:SetCollide( true )
        particle:SetBounce( 0.5 )
    end

    particle = emitter:Add( "sprites/heatwave", self.Origin )
        particle:SetAirResistance( 0 )
        particle:SetDieTime( 1.5 )
        particle:SetStartAlpha( 255 )
        particle:SetEndAlpha( 255 )
        particle:SetStartSize( 250 ) 
        particle:SetEndSize( 0 )
        particle:SetRoll( math.Rand(180,480) )
        particle:SetRollDelta( math.Rand(-5,5) )
        particle:SetColor( 255, 255, 255 )

    emitter:Finish()

end

function EFFECT:Think()
    return false
end

function EFFECT:Render()
end
--PATH lua/effects/astw2_swrc_explosion_geo_grenade/init.lua:

function EFFECT:Init(data)
    self.Origin = data:GetOrigin()
    local emitter = ParticleEmitter( self.Origin + Vector( 0, 0, 16 ) )
local light = DynamicLight(self:EntIndex())
        if (light) then
            light.Pos = self:GetPos()
            light.r = 255
            light.g = 200
            light.b = 100
            light.Brightness = 5
            light.Decay = 10
            light.Size = 324
            light.DieTime = CurTime() + 0.3
        end


    for i = 0,1 do
        particle = emitter:Add( "effects/swbf/flare4" , self.Origin )

        particle:SetVelocity( 1 * VectorRand() )
        particle:SetDieTime( math.Rand(0.25, 0.5) )
        particle:SetStartAlpha( 200 )
        particle:SetEndAlpha( 0 )
        particle:SetStartSize( math.Rand(20,35) )
        particle:SetEndSize( math.Rand(150,175) )
        particle:SetRoll( math.Rand(0,360) )
        particle:SetRollDelta( math.Rand(-1,1) )
        particle:SetColor( 200,255,100 )
        particle:SetAirResistance( 200 )
        particle:SetGravity( Vector( 0, 0, math.Rand(10,40) ) )
        particle:SetLighting( false )
        particle:SetCollide( true )
        particle:SetBounce( 0.5 )
    end

    particle = emitter:Add( "sprites/heatwave", self.Origin )
        particle:SetAirResistance( 0 )
        particle:SetDieTime( 1.5 )
        particle:SetStartAlpha( 255 )
        particle:SetEndAlpha( 255 )
        particle:SetStartSize( 250 ) 
        particle:SetEndSize( 0 )
        particle:SetRoll( math.Rand(180,480) )
        particle:SetRollDelta( math.Rand(-5,5) )
        particle:SetColor( 255, 255, 255 )

    emitter:Finish()

end

function EFFECT:Think()
    return false
end

function EFFECT:Render()
end
--PATH lua/effects/bliz_tracer.lua:
return gluapack()()
--PATH lua/effects/celest_blighten.lua:
EFFECT.FxMaterial = Material( "models/elemental/blightened" )

function EFFECT:Init( data )

	if ( GetConVar( "mat_fillrate" ):GetBool() ) then return end

	self.Time = data:GetScale()
	self.Origin = data:GetOrigin()
	self.LifeTime = CurTime() + self.Time
	
	local ent = data:GetEntity()
	
	if ( !IsValid( ent ) ) then return end
	if ( !ent:GetModel() ) then return end
			
	local pEntity = LocalPlayer()

	if ( ent == pEntity ) && ( !pEntity:ShouldDrawLocalPlayer() ) then
		self.ViewModel = true
			
		ent = pEntity:GetHands()
	end
	
	self.ParentEntity = ent
	
	if ( self.ParentEntity.RenderOverride ) then
		return
	end
	
	self:SetModel( ent:GetModel() )	
	self:SetPos( ent:GetPos() )
	self:SetAngles( ent:GetAngles() )
	self:SetParent( ent )
	
	self.ParentEntity.RenderOverride = self.RenderParent
	self.ParentEntity.SpawnEffect = self

end

function EFFECT:Think( )

	if ( !IsValid( self.ParentEntity ) ) then return false end
	
	local PPos = self.ParentEntity:GetPos()
	self:SetPos( PPos + ( EyePos() - PPos ):GetNormal() )
	
	local DieTime = self.LifeTime - CurTime()
	
	self.DeltaTime = DieTime
	
	if ( !self.ParticleCast ) then
		if ( self.Time >= 2 ) then
			ParticleEffectAttach( "fstar_freeze_catch", PATTACH_ABSORIGIN_FOLLOW, self.ParentEntity, 1 )
		end

		if ( self.ViewModel ) then
			local pOwner = self.ParentEntity:GetOwner()
			
			pOwner:ScreenFade( SCREENFADE.IN, Color( 210, 240, 255, 80 ), self.Time * 0.5, self.Time * 0.5 )
			pOwner:SetDSP( 32, false )
			
			self.FxMaterial:SetVector( "$emissiveBlendScrollVector", Vector( -1, -1 ) )
		end
		
		self.ParticleCast = true
	end
	
	if ( self.LifeTime > CurTime() ) then
		return true
	end
	
	self.ParentEntity:StopParticlesNamed( "fstar_freeze_catch" )
	
	self.ParentEntity.RenderOverride = nil
	self.ParentEntity.SpawnEffect = nil

	return false
	
end

function EFFECT:Render()

end

function EFFECT:RenderOverlay( entity )
		
	local Fraction = 1 - ( self.LifeTime - CurTime() ) / self.Time
	
	Fraction = math.Clamp( Fraction, 0, 1 )
	
	local origin = entity:GetPos()

	local EyeOrigin = EyePos()
	local EyeNormal = origin - EyeOrigin
	local Distance = EyeNormal:Length()
	EyeNormal:Normalize()
	
	local offset 
	
	if ( self.ViewModel ) then
		local iFov = 54
		local wEntity = LocalPlayer():GetActiveWeapon()
		if ( IsValid( wEntity ) && wEntity.ViewModelFOV ) then
			iFov = wEntity.ViewModelFOV
		end
		
		local add = -54 + iFov
		add = add * 0.3
		
		offset = EyeAngles():Forward() * ( 12 - add )
	else
		offset = EyeNormal * Distance * 0.01
	end
	
	local Pos = EyeOrigin + offset

	local clr = Vector( 120, 130, 255 ) / 255

	local fStrength = 2.2 - ( Fraction * 2 ^ ( Fraction * 1 ) )
	
	local owner
	if ( self.ViewModel ) then
		owner = entity:GetOwner()
	else
		owner = entity
	end

	self.FxMaterial:SetFloat( "$emissiveBlendStrength", fStrength )
	self.FxMaterial:SetFloat( "$time", Fraction )
	self.FxMaterial:SetVector( "$energycolor", clr * fStrength )
	
	cam.Start3D( Pos, EyeAngles() )
		render.MaterialOverride( self.FxMaterial )
		entity:DrawModel()
		render.MaterialOverride()
	cam.End3D()
	
	if ( self.ViewModel && self.ParentEntity:GetOwner() == LocalPlayer() ) then
		DrawMaterialOverlay( "models/elemental/blightened", 0 )
	end

end

function EFFECT:RenderParent()
	
	self:DrawModel()
	
	self.SpawnEffect:RenderOverlay( self )

end
--PATH lua/effects/cod2019_muzzle_inc/init.lua:
return gluapack()()
--PATH lua/effects/cod2019_tracer/init.lua:
return gluapack()()
--PATH lua/effects/cod2019_tracer/init.lua:
EFFECT.TracerName = "mw2019_tracer"

function EFFECT:Init(data)
    self.WeaponEnt = data:GetEntity()
    if not IsValid(self.WeaponEnt) then return end
    local hit = data:GetOrigin()
    local wep = data:GetEntity()
    if !IsValid(wep) then return end
	local start = (wep.GetTracerOrigin and wep:GetTracerOrigin()) or data:GetStart()
    self.Attachment = data:GetAttachment() or 1

    if IsValid(self.WeaponEnt.Owner) then
        if self.WeaponEnt.Owner == LocalPlayer() then
            if not self.WeaponEnt.Owner:GetViewEntity() then
                ang = self.WeaponEnt.Owner:EyeAngles()
                ang:Normalize()
                self.Forward = ang:Forward()
            else
                self.WeaponEnt = self.WeaponEnt.Owner:GetViewModel()
            end
        else
            ang = self.WeaponEnt.Owner:EyeAngles()
            ang:Normalize()
            self.Forward = ang:Forward()
        end
    end

    self.StartPos = start
    self.EndPos = hit
    local pcf = CreateParticleSystem(self.WeaponEnt, self.TracerName, PATTACH_ABSORIGIN, self.Attachment)
    if IsValid(pcf) then
        pcf:SetControlPoint(0,self.StartPos)
        pcf:SetControlPoint(1,self.EndPos)
        pcf:StartEmission()
    end
    timer.Simple(1.2, function()
        if IsValid(pcf) then
            pcf:StopEmissionAndDestroyImmediately()
        end
    end)
end

function EFFECT:Think()
    return false
end

function EFFECT:Render()
    if self.InValid then return false end
end
--PATH lua/effects/cod2019_tracer_small/init.lua:
return gluapack()()
--PATH lua/effects/csgo_muzzle_taser/init.lua:
return gluapack()()
--PATH lua/effects/csgo_muzzle_trail_long/init.lua:
return gluapack()()
--PATH lua/effects/dark_infect.lua:
return gluapack()()
--PATH lua/effects/effect_astw2_swrc_impact_wookie/init.lua:
return gluapack()()
--PATH lua/effects/effect_astw2_swrc_laser_yellow/init.lua:
return gluapack()()
--PATH lua/effects/effect_magicheal/init.lua:
//Main function
function EFFECT:Init(data)

	//Create particle emitter
	local emitter = ParticleEmitter(data:GetOrigin())

		//Amount of particles to create
		for i=0, 16 do

			local Pos = (data:GetOrigin() + Vector( math.Rand(-32,32), math.Rand(-32,32), math.Rand(-32,32) ) + Vector(0,0,42))

			local particle = emitter:Add( "sprites/orangecore1", Pos )
			if (particle) then

				particle:SetVelocity(VectorRand() * math.Rand(1920,2142))

				particle:SetLifeTime(0)
				particle:SetDieTime(math.Rand(1,2))

				local rand = math.random(242,255)
				if math.random(1,12) == 12 then rand = math.random(210,232) end
				particle:SetColor(0,200,150)

				particle:SetStartAlpha(math.Rand(50,60)) //Old values, 142, 162
				particle:SetEndAlpha(0)

				local Size = math.Rand(112,132)
				particle:SetStartSize(Size)
				particle:SetEndSize(Size)

				particle:SetRoll(math.Rand(-360, 360))
				particle:SetRollDelta(math.Rand(-5, 5))

				particle:SetAirResistance(math.Rand(520,620))

				particle:SetGravity( Vector(0, 0, math.Rand(-32, -64)) )


				particle:SetCollide(true)
				particle:SetBounce(0.42)

				particle:SetLighting(true)
				
				
				

			end
			local dlight = DynamicLight( LocalPlayer():EntIndex() )
	if ( dlight ) then
		dlight.pos = Pos
		dlight.r = 0
		dlight.g = 255
		dlight.b = 100
		dlight.brightness = 5
		dlight.Decay = 450
		dlight.Size = 256
		dlight.DieTime = CurTime() + 3
	end
			
			local particle = emitter:Add( "sprites/orangecore1", Pos )
			if (particle) then

				particle:SetVelocity(VectorRand() * math.Rand(1920,2142))

				particle:SetLifeTime(0)
				particle:SetDieTime(math.Rand(.3,1))

				local rand = math.random(242,255)
				if math.random(1,12) == 12 then rand = math.random(210,232) end
				particle:SetColor(0,255, 150)

				particle:SetStartAlpha(math.Rand(192,255)) //Old values, 142, 162
				particle:SetEndAlpha(0)

				local Size = math.Rand(112,132)
				particle:SetStartSize(Size*.5)
				particle:SetEndSize(Size*.1)

				particle:SetRoll(math.Rand(-360, 360))
				particle:SetRollDelta(math.Rand(-0.21, 0.21))

				particle:SetAirResistance(math.Rand(120,350))

				particle:SetGravity( Vector(0, 0, math.Rand(-32, -64)) )

				particle:SetCollide(true)
				particle:SetBounce(0.42)

				particle:SetLighting(false)
				
				

			end

		end

	//We're done with this emitter
	emitter:Finish()

end

//Kill effect
function EFFECT:Think()
return false
end

//Not used
function EFFECT:Render()
end
--PATH lua/effects/effect_sw_impact/init.lua:
EFFECT.Duration			= 0.1;
EFFECT.Size				= 20;

local MaterialGlow		= Material( "effects/sw_laser_bit" );

function EFFECT:Init( data )

	self.Position = data:GetOrigin();
	self.Normal = data:GetNormal();
	self.LifeTime = self.Duration;

	-- particles
	local emitter = ParticleEmitter( self.Position );
	if( emitter ) then
		
		for i = 1, 20 do

			local particle = emitter:Add( "effects/sw_laser_bit", self.Position + self.Normal * 2 );
			particle:SetVelocity( ( self.Normal + VectorRand() * 0.75 ):GetNormal() * math.Rand( 75, 125 ) );
			particle:SetDieTime( math.Rand( 0.5, 1.25 ) );
			particle:SetStartAlpha( 255 );
			particle:SetEndAlpha( 0 );
			particle:SetStartSize( math.Rand( 4, 8 ) );
			particle:SetEndSize( 0 );
			particle:SetRoll( 0 );
			particle:SetGravity( Vector( 0, 0, -250 ) );
			particle:SetCollide( true );
			particle:SetBounce( 0.3 );
			particle:SetAirResistance( 5 );

		end
		emitter:Finish();
	end
	
	--[[local emitter_s = ParticleEmitter( self.Position );
	if( emitter_s ) then
		for i = 1, 8 do
			--local smokeTexture	= "effects/awoi_musket_smoke_01"
			
			local particle_s = emitter_s:Add(smokeTexture, self.Position+self.Normal*2);
			particle_s:SetVelocity((self.Normal+VectorRand()*0.10):GetNormal()*math.Rand(250, 2500));
			particle_s:SetDieTime(math.Rand(1, 3));
			particle_s:SetStartAlpha(150);
			particle_s:SetEndAlpha(0);
			particle_s:SetStartSize(math.Rand(10, 20));
			particle_s:SetEndSize(math.Rand(10, 20));
			particle_s:SetGravity(Vector(math.Rand(0, 500), math.Rand(250, 1000), math.Rand(-250, 250)));
			particle_s:SetRoll(math.Rand(0, 360));
			particle_s:SetRollDelta(math.Rand(-0.5, 0.5));
			local colour = math.Rand(50, 150);
			particle_s:SetColor(colour, colour, colour, 100);
			particle_s:SetCollide(false);
			particle_s:SetAirResistance(2000);
		end--]]
		--emitter_s:Finish();
	--end
	
end


function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime();
	return self.LifeTime > 0;

end


function EFFECT:Render()

	local frac = math.max( 0, self.LifeTime / self.Duration );
	local rgb = 255 * frac;
	local color = Color( rgb, rgb, rgb, 255 );

	render.SetMaterial( MaterialGlow );
	render.DrawQuadEasy( self.Position + self.Normal, self.Normal, self.Size, self.Size, color );

end

--PATH lua/effects/effect_sw_laser_green_akimbo_pu/init.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/effects/force_block.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/effects/force_judgement.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/effects/force_lightningi.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/effects/force_lightningi_hit.lua:
--DO NOT EDIT OR REUPLOAD THIS FILE

local DecalMat = Material( util.DecalMaterial( "FadingScorch" ) )
function EFFECT:Init( data )
	self.Pos = data:GetOrigin()

	self.mat = Material( "sprites/light_glow02_add" )
	
	self.LifeTime = 0.5
	self.DieTime = CurTime() + self.LifeTime
	self.DieTimeGlow = CurTime() + 0.2

	local Col = self.Col
	local Pos = self.Pos
	local Dir = data:GetNormal()
	
	local emitter = ParticleEmitter( Pos, false )

	local trace = util.TraceLine( {
		start = Pos - Dir * 5,
		endpos = Pos + Dir * 5,
	} )

	if trace.Hit and not trace.HitNonWorld then
		util.DecalEx( DecalMat, trace.Entity, trace.HitPos + trace.HitNormal, trace.HitNormal, Color(255,255,255,255), math.Rand(0.4,0.8), math.Rand(0.4,0.8) )
	end

	for i = 0, 3 do
		local particle = emitter:Add( "sprites/rico1", Pos )
		
		local vel = VectorRand() * 100 + Dir * math.Rand(120,140)
		
		if particle then
			particle:SetVelocity( vel )
			particle:SetAngles( vel:Angle() + Angle(0,90,0) )
			particle:SetDieTime( math.Rand(1,2) )
			particle:SetStartAlpha( math.Rand( 200, 255 ) )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( 1 )
			particle:SetEndSize( 0.5 )
			particle:SetRoll( math.Rand(-100,100) )
			particle:SetRollDelta( math.Rand(-100,100) )
			particle:SetCollide( true )
			particle:SetBounce( 0.5 )
			particle:SetAirResistance( 0 )
			particle:SetColor( 255, 255, 255 )
			particle:SetGravity( Vector(0,0,-600) )
		end
	end

	self.Emitter = emitter
end

function EFFECT:Think()
	if self.DieTime < CurTime() then 
		if self.Emitter then
			self.Emitter:Finish()
		end

		if self.snd then
			self.snd:Stop()
		end

		return false
	end

	return true
end

local Mat = Material("particle/particle_glow_05_addnofog")
function EFFECT:Render()
	local Scale = (self.DieTimeGlow - CurTime()) / 0.2
	if Scale > 0 then
		render.SetMaterial( self.mat )
		render.DrawSprite( self.Pos, 24 * Scale, 24 * Scale, Color( 150, 150, 255, 255) ) -- DETRLECEK RENK
	end
end

--PATH addons/[miecze] moce i hilty/lua/effects/force_lightningx.lua:
return gluapack()()
--PATH addons/[miecze] moce i hilty/lua/effects/force_pull.lua:
return gluapack()()
--PATH lua/effects/gravrifle_preexplode.lua:
return gluapack()()
--PATH lua/effects/gravrifle_tracer.lua:
return gluapack()()
--PATH lua/effects/lfs_fb_detonator_explosion.lua:
return gluapack()()
--PATH lua/effects/lvs_bomb_cisexplosion.lua:
return gluapack()()
--PATH lua/effects/lvs_bullet_impact_explosive.lua:
return gluapack()()
--PATH lua/effects/lvs_capital_explosion.lua:
local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	local Pos = data:GetOrigin()

	local scale = data:GetScale()

	self.DieTime = CurTime() + 1

	self:Explosion( Pos, scale )

	local ply = LocalPlayer():GetViewEntity()
	if IsValid( ply ) then
		local delay = (Pos - ply:GetPos()):Length() / 13503.9
		timer.Simple( delay, function()
			sound.Play( "LVS.DYNAMIC_EXPLOSION", Pos )
		end )
	else
		sound.Play( "LVS.DYNAMIC_EXPLOSION", Pos )
	end
	
	for i = 1, 20 do
		timer.Simple(math.Rand(0,0.01) * i, function()
			if IsValid( self ) then
				local p = Pos + VectorRand() * 10 * i
				
				self:Explosion( p, math.Rand(scale * 0.6,scale * 1) )
			end
		end)
	end

	self:Debris( Pos )
end

function EFFECT:Debris( pos )
	local emitter = ParticleEmitter( pos, false )

	if not IsValid( emitter ) then return end

	for i = 0,60 do
		local particle = emitter:Add( "effects/fleck_tile"..math.random(1,2), pos )
		local vel = VectorRand() * math.Rand(200,600)
		vel.z = math.Rand(200,600)
		if particle then
			particle:SetVelocity( vel )
			particle:SetDieTime( math.Rand(10,15) )
			particle:SetAirResistance( 10 ) 
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 5 )
			particle:SetEndSize( 5 )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( 0,0,0 )
			particle:SetGravity( Vector( 0, 0, -600 ) )
			particle:SetCollide( true )
			particle:SetBounce( 0.3 )
		end
	end
	
	emitter:Finish()
end

function EFFECT:Explosion( pos , scale )
	local emitter = ParticleEmitter( pos, false )
	
	if not IsValid( emitter ) then return end

	for i = 0,10 do
		local particle = emitter:Add( Materials[ math.random(1, #Materials ) ], pos )

		if particle then
			particle:SetVelocity( VectorRand() * 1500 * scale )
			particle:SetDieTime( math.Rand(0.75,1.5) * scale )
			particle:SetAirResistance( math.Rand(200,600) ) 
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( math.Rand(60,120) * scale )
			particle:SetEndSize( math.Rand(220,320) * scale )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( 40,40,40 )
			particle:SetGravity( Vector( 0, 0, 100 ) )
			particle:SetCollide( false )
		end
	end

	for i = 0, 40 do
		local particle = emitter:Add( "particles/flamelet"..math.random(1,5), pos )

		if particle then
			particle:SetVelocity( VectorRand() * 1500 * scale )
			particle:SetDieTime( 0.2 )
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 20 * scale )
			particle:SetEndSize( math.Rand(180,240) * scale )
			particle:SetEndAlpha( 100 )
			particle:SetRoll( math.Rand( -1, 1 ) )
			particle:SetColor( 200,150,150 )
			particle:SetCollide( false )
		end
	end

	emitter:Finish()

	local dlight = DynamicLight( math.random(0,9999) )
	if dlight then
		dlight.pos = pos
		dlight.r = 255
		dlight.g = 180
		dlight.b = 100
		dlight.brightness = 8
		dlight.Decay = 2000
		dlight.Size = 300
		dlight.DieTime = CurTime() + 1
	end
end

function EFFECT:Think()
	if CurTime() < self.DieTime then return true end

	return false
end

function EFFECT:Render()
end
--PATH lua/effects/lvs_explosion_nodebris.lua:
return gluapack()()
--PATH lua/effects/lvs_muzzle_colorable.lua:

function EFFECT:Init( data )
	local Pos = data:GetOrigin()
	local Dir = data:GetNormal()
	local Ent = data:GetEntity()
	local Col = data:GetStart() or Vector(255,255,255)
	local Vel = Dir * 10

	if IsValid( Ent ) then
		Vel = Ent:GetVelocity()
	end

	local emitter = ParticleEmitter( Pos, false )

	if not IsValid( emitter ) then return end

	for i = 0, 12 do
		local particle = emitter:Add( "effects/muzzleflash2", Pos + Dir * i * 0.7 * math.random(1,2) * 0.5 )
		local Size = 1

		if not particle then continue end

		particle:SetVelocity( Dir * 800 + Vel )
		particle:SetDieTime( 0.05 )
		particle:SetStartAlpha( 255 * Size )
		particle:SetStartSize( math.max( math.random(10,24) - i * 0.5,0.1 ) * Size )
		particle:SetEndSize( 0 )
		particle:SetRoll( math.Rand( -1, 1 ) )
		particle:SetColor( Col.x, Col.y, Col.z )
		particle:SetCollide( false )
	end

	emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--PATH lua/effects/lvs_physics_scrape.lua:
return gluapack()()
--PATH lua/effects/lvs_proton_explosion.lua:
return gluapack()()
--PATH lua/effects/lvs_tracer_proton.lua:
return gluapack()()
--PATH lua/effects/lvs_tracer_yellow.lua:

EFFECT.MatBeam = Material( "effects/lvs_base/spark" )

function EFFECT:Init( data )
	local pos  = data:GetOrigin()
	local dir = data:GetNormal()

	self.ID = data:GetMaterialIndex()

	self:SetRenderBoundsWS( pos, pos + dir * 50000 )
end

function EFFECT:Think()
	if not LVS:GetBullet( self.ID ) then return false end

	return true
end

function EFFECT:Render()
	local bullet = LVS:GetBullet( self.ID )

	local endpos = bullet:GetPos()
	local dir = bullet:GetDir()

	local len = 1600 * bullet:GetLength()

	render.SetMaterial( self.MatBeam )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 3, 1, 0, Color( 255, 255, 125, 255 ) )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 10, 1, 0, Color( 125, 80, 0, 255 ) )
end

--PATH lua/effects/lvs_walker_stomp.lua:
return gluapack()()
--PATH lua/effects/fxbase.lua:
-- based on nomad's tracer by Chad Barrett --
-- edited for the use with SciFiWeapons by Darken217 --

AddCSLuaFile()
if ( CLIENT ) then
TRACER_FLAG_USEATTACHMENT	= 0x0002
end
EFFECT.Speed	= 6500
EFFECT.Length	= 64
EFFECT.Normal 	= Vector( 0, 0, 0 )

function EFFECT:GetTracerOrigin( data )
	if ( CLIENT ) then
		local vOrigin = data:GetStart()

		if ( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then
			local entParent = data:GetEntity()
			
			if ( !IsValid( entParent ) ) then 
				return vOrigin 
			end
			
			if ( !game.SinglePlayer() && entParent:IsEFlagSet( EFL_DORMANT ) ) then 
				return vOrigin 
			end
			
			if( entParent:IsWeapon() && entParent:IsCarriedByLocalPlayer() ) then
				local entPlayer = entParent:GetOwner()
				if ( IsValid( entPlayer ) ) then
					local entViewModel = entPlayer:GetViewModel()
					if ( IsValid( entViewModel ) && !LocalPlayer():ShouldDrawLocalPlayer() ) then
						entParent = entViewModel
					else 					
						if ( entParent.WorldModel ) then
							entParent:SetModel( entParent.WorldModel )
						end
					end
				end
			end

			local attachment = entParent:GetAttachment( data:GetAttachment() )
			if ( attachment ) then
				vOrigin = attachment.Pos
			end

		end
		
		return vOrigin
	end
end

function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data )
	self.EndPos = data:GetOrigin()
	self.Parent = data:GetEntity()
	
--	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos )

	local diff = ( self.EndPos - self.StartPos )
	
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	
	if ( !self.LifeTime ) then
		self.LifeTime = ( diff:Length() + self.Length ) / self.Speed
	else
		self.LifeTime = CurTime() + self.LifeTime
	end
	
end

function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	
	return self.LifeTime > 0

end

function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	
	startDistance = math.max( 0, startDistance )
	endDistance = math.max( 0, endDistance )

	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	
end
--PATH lua/effects/pele_tracer.lua:
AddCSLuaFile()
AddCSLuaFile( "effects/fxbase.lua" )
include( "effects/fxbase.lua" )

function EFFECT:Think()
	
	util.ParticleTracerEx( 
		"pele_tracer", 	--particle system
		self.StartPos, 	--startpos
		self.EndPos, 	--endpos
		true, 			--do whiz effect
		-1, 			--entity index
		-1  			--attachment
	)
	
	return false

end
--PATH lua/effects/red_tracer_fx.lua:
return gluapack()()
--PATH lua/effects/red_tracer_fx.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002;
SOUND_FROM_WORLD			= 0;
CHAN_STATIC					= 6;

EFFECT.Speed				= 6500;
EFFECT.Length				= 64;
//EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 72;

local MaterialMain			= Material( "effects/sw_laser_red_main" );
local MaterialFront			= Material( "effects/sw_laser_red_front" );

function EFFECT:GetTracerOrigin( data )

	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart();
	
	-- use attachment?
	if( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then

		local entity = data:GetEntity();
		
		if( not IsValid( entity ) ) then return start; end
		if( not game.SinglePlayer() and entity:IsEFlagSet( EFL_DORMANT ) ) then return start; end
		
		if( entity:IsWeapon() and entity:IsCarriedByLocalPlayer() ) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			
			-- use the view model
			local pl = entity:GetOwner();
			if( IsValid( pl ) ) then
				local vm = pl:GetViewModel();
				if( IsValid( vm ) and not LocalPlayer():ShouldDrawLocalPlayer() ) then
					entity = vm;
				else
					-- HACK: fix the model in multiplayer
					if( entity.WorldModel ) then
						entity:SetModel( entity.WorldModel );
					end
				end
			end
		end

		local attachment = entity:GetAttachment( data:GetAttachment() );
		if( attachment ) then
			start = attachment.Pos;
		end

	end
	
	return start;

end


function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data );
	self.EndPos = data:GetOrigin();
	
	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos );

	local diff = ( self.EndPos - self.StartPos );
	
	self.Normal = diff:GetNormal();
	self.StartTime = 0;
	self.LifeTime = ( diff:Length() + self.Length ) / self.Speed;
	
	-- whiz by sound
	local weapon = data:GetEntity();
	if( IsValid( weapon ) and ( not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer() ) ) then

		local dist, pos, time = util.DistanceToLine( self.StartPos, self.EndPos, EyePos() );
	end

end


function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime();
	self.StartTime = self.StartTime + FrameTime(); 

	return self.LifeTime > 0;

end


function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime;
	local startDistance = endDistance - self.Length;
	
	startDistance = math.max( 0, startDistance );
	endDistance = math.max( 0, endDistance );

	local startPos = self.StartPos + self.Normal * startDistance;
	local endPos = self.StartPos + self.Normal * (endDistance*1.1);
	
	render.SetMaterial( MaterialFront );
	render.DrawSprite( endPos, 52, 24, color_white );

	render.SetMaterial( MaterialMain );
	render.DrawBeam( startPos, endPos, 30, 0, 1, color_white );

    local dynlight = DynamicLight(self:EntIndex() * 4096);
    dynlight.Pos = startPos;
    dynlight.Brightness = 5;
    dynlight.Size = 100;
    dynlight.Decay = 1024;
    dynlight.R = 255;
    dynlight.G = 50;
    dynlight.B = 50;
    dynlight.DieTime = CurTime()+1;

end

--PATH lua/effects/rw_sw_dual_laser_white.lua:
TRACER_FLAG_USEATTACHMENT 	= 0x0002
SOUND_FROM_WORLD			= 0
CHAN_STATIC 				= 6

EFFECT.Speed 				= 16384
EFFECT.Length 				= 95

local MaterialMain 			= Material("effects/sw_laser_white_main")
local MaterialFront 		= Material("effects/sw_laser_white_front")
local DynamicTracer 		= GetConVar("cl_dynamic_tracer")

function EFFECT:Init(data)
	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.WeaponEntOG = data:GetEntity()
	self.Attachment = data:GetAttachment()
	local owent
	if IsValid(self.WeaponEnt) then
		owent = self.WeaponEnt.Owner or self.WeaponEnt:GetOwner()
		if not IsValid(owent) then
			owent = self.WeaponEnt:GetParent()
		end
	end
	if IsValid(owent) and owent:IsPlayer() then
		if owent ~= LocalPlayer() or owent:ShouldDrawLocalPlayer() then
			self.WeaponEnt = owent:GetActiveWeapon()
			if not IsValid(self.WeaponEnt) then return end
		else
			self.WeaponEnt = owent:GetViewModel()
			local theirweapon = owent:GetActiveWeapon()
			if IsValid(theirweapon) and theirweapon.ViewModelFlip or theirweapon.ViewModelFlipped then
				self.Flipped = true
			end
			if not IsValid(self.WeaponEnt) then return end
		end
	end
	if IsValid(self.WeaponEntOG) and self.WeaponEntOG.MuzzleAttachment then
		self.Attachment = self.WeaponEnt:LookupAttachment(self.WeaponEntOG.MuzzleAttachment)
		if not self.Attachment or self.Attachment <= 0 then
			self.Attachment = 1
		end
		if self.WeaponEntOG.Akimbo then
			if game.SinglePlayer() then
				self.WeaponEntOG.AnimCycle = self.WeaponEntOG:GetNW2Int("AnimCycle") or 0
			end
			self.Attachment = 1 + self.WeaponEntOG.AnimCycle
		end
	end
	local angpos
	if IsValid(self.WeaponEnt) then
		angpos = self.WeaponEnt:GetAttachment(self.Attachment)
	end
	if not angpos or not angpos.Pos then
		angpos = {
			Pos = bvec,
			Ang = uAng
		}
	end
	if self.Flipped then
		local tmpang = (self.Dir or angpos.Ang:Forward()):Angle()
		local localang = self.WeaponEnt:WorldToLocalAngles(tmpang)
		localang.y = localang.y + 180
		localang = self.WeaponEnt:LocalToWorldAngles(localang)
		self.Dir = localang:Forward()
	end
	if IsValid(owent) and self.Position:Distance(owent:GetShootPos()) > 72 then
		self.WeaponEnt = nil
	end
	
	self.StartPos = self:GetTracerShootPos(self.WeaponEnt and angpos.Pos or self.Position, self.WeaponEnt, self.Attachment)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	self.Normal = (self.EndPos - self.StartPos):GetNormalized()
	self.StartTime = 0
	local diff = self.EndPos - self.StartPos
	self.LifeTime = (diff:Length() - self.Length/2 ) / self.Speed
	self.data = data
	self.rot = nil
	weapon = data:GetEntity()
	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	if DynamicTracer:GetBool() then
		local spawn = util.CRC(tostring(self:GetPos()))
		local dlight = DynamicLight(self:EntIndex() + spawn)
		local endDistance = self.Speed * self.StartTime
		local endPos = self.StartPos + self.Normal * endDistance
		if (dlight) then
			dlight.pos = endPos
			dlight.r = 255
			dlight.g = 255
			dlight.b = 255
			dlight.brightness = 3
			dlight.Decay = 1500
			dlight.Size = 300
			dlight.nomodel = 1
			dlight.style = 6
			dlight.DieTime = CurTime() + 3
		end
	end
	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 9, 9, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 7, 0, 0, color_white)
end
--PATH lua/effects/rw_sw_impact_purple.lua:
return gluapack()()
--PATH lua/effects/rw_sw_impact_purple.lua:
local MaterialGlow		= Material( "effects/sw_i/sw_laser_bit_purple" );
function EFFECT:Init( data )
	local bit_amount = GetConVar("rw_sw_bit_amount"):GetInt()
	local smoke_amount = GetConVar("rw_sw_smoke_amount"):GetInt()
	local duration = GetConVar("rw_sw_impact_duration"):GetInt()
	self.Position = data:GetOrigin();
	self.Normal = data:GetNormal();
	self.LifeTime = duration;
	local emitter = ParticleEmitter( self.Position );
	if( emitter ) then
		for i = 1, bit_amount do
			local particle = emitter:Add( MaterialGlow, self.Position + self.Normal * 2 );
			particle:SetVelocity( ( self.Normal + VectorRand() * 0.75 ):GetNormal() * math.Rand( 75, 125 ) );
			particle:SetDieTime( math.Rand( 0.5, 1.25 ) );
			particle:SetStartAlpha( 255 );
			particle:SetEndAlpha( 0 );
			particle:SetStartSize( math.Rand( 4, 8 ) );
			particle:SetEndSize( 0 );
			particle:SetRoll( 0 );
			particle:SetGravity( Vector( 0, 0, -250 ) );
			particle:SetCollide( true );
			particle:SetBounce( 0.3 );
			particle:SetAirResistance( 5 );
		end
		emitter:Finish();
	end
	local emitter_s = ParticleEmitter( self.Position );
	if( emitter_s ) then
		for i = 1, smoke_amount do
			local smokeTexture	= "effects/smoke"
			local particle_s = emitter_s:Add(smokeTexture, self.Position+self.Normal*2);
			particle_s:SetVelocity((self.Normal+VectorRand()*0.10):GetNormal()*math.Rand(400, 900));
			particle_s:SetDieTime(math.Rand(2.1, 2.7));
			particle_s:SetStartAlpha(50);
			particle_s:SetEndAlpha(0);
			particle_s:SetStartSize(math.Rand(8, 16));
			particle_s:SetEndSize(math.Rand(0, 4));
			particle_s:SetGravity(Vector(math.Rand(0, 500), math.Rand(250, 1000), math.Rand(-250, 250)));
			particle_s:SetRoll(math.Rand(0, 360));
			particle_s:SetRollDelta(math.Rand(-0.5, 0.5));
			local colour = math.Rand(110, 130);
			particle_s:SetColor(colour, colour, colour, 100);
			particle_s:SetCollide(true);
			particle_s:SetAirResistance(2000);
		end
		emitter_s:Finish();
	end
end
function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime();
	return self.LifeTime > 0;
end
function EFFECT:Render()
	local size = GetConVar("rw_sw_impact_size"):GetInt()
	local duration = GetConVar("rw_sw_impact_duration"):GetInt()
	local frac = math.max( 0, self.LifeTime / duration);
	local rgb = 255 * frac;
	local color = Color( rgb, rgb, rgb, 255 );
	render.SetMaterial( MaterialGlow );
	render.DrawQuadEasy( self.Position + self.Normal, self.Normal, size, size, color );
end
--PATH lua/effects/rw_sw_impact_red.lua:
local MaterialGlow		= Material( "effects/sw_i/sw_laser_bit_red" );
function EFFECT:Init( data )
	local bit_amount = GetConVar("rw_sw_bit_amount"):GetInt()
	local smoke_amount = GetConVar("rw_sw_smoke_amount"):GetInt()
	local duration = GetConVar("rw_sw_impact_duration"):GetInt()
	self.Position = data:GetOrigin();
	self.Normal = data:GetNormal();
	self.LifeTime = duration;
	local emitter = ParticleEmitter( self.Position );
	if( emitter ) then
		for i = 1, bit_amount do
			local particle = emitter:Add( MaterialGlow, self.Position + self.Normal * 2 );
			particle:SetVelocity( ( self.Normal + VectorRand() * 0.75 ):GetNormal() * math.Rand( 75, 125 ) );
			particle:SetDieTime( math.Rand( 0.5, 1.25 ) );
			particle:SetStartAlpha( 255 );
			particle:SetEndAlpha( 0 );
			particle:SetStartSize( math.Rand( 4, 8 ) );
			particle:SetEndSize( 0 );
			particle:SetRoll( 0 );
			particle:SetGravity( Vector( 0, 0, -250 ) );
			particle:SetCollide( true );
			particle:SetBounce( 0.3 );
			particle:SetAirResistance( 5 );
		end
		emitter:Finish();
	end
	local emitter_s = ParticleEmitter( self.Position );
	if( emitter_s ) then
		for i = 1, smoke_amount do
			local smokeTexture	= "effects/smoke"
			local particle_s = emitter_s:Add(smokeTexture, self.Position+self.Normal*2);
			particle_s:SetVelocity((self.Normal+VectorRand()*0.10):GetNormal()*math.Rand(400, 900));
			particle_s:SetDieTime(math.Rand(2.1, 2.7));
			particle_s:SetStartAlpha(50);
			particle_s:SetEndAlpha(0);
			particle_s:SetStartSize(math.Rand(8, 16));
			particle_s:SetEndSize(math.Rand(0, 4));
			particle_s:SetGravity(Vector(math.Rand(0, 500), math.Rand(250, 1000), math.Rand(-250, 250)));
			particle_s:SetRoll(math.Rand(0, 360));
			particle_s:SetRollDelta(math.Rand(-0.5, 0.5));
			local colour = math.Rand(110, 130);
			particle_s:SetColor(colour, colour, colour, 100);
			particle_s:SetCollide(true);
			particle_s:SetAirResistance(2000);
		end
		emitter_s:Finish();
	end
end
function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime();
	return self.LifeTime > 0;
end
function EFFECT:Render()
	local size = GetConVar("rw_sw_impact_size"):GetInt()
	local duration = GetConVar("rw_sw_impact_duration"):GetInt()
	local frac = math.max( 0, self.LifeTime / duration);
	local rgb = 255 * frac;
	local color = Color( rgb, rgb, rgb, 255 );
	render.SetMaterial( MaterialGlow );
	render.DrawQuadEasy( self.Position + self.Normal, self.Normal, size, size, color );
end
--PATH lua/effects/rw_sw_impact_yellow.lua:
return gluapack()()
--PATH lua/effects/rw_sw_laser_aqua.lua:

TRACER_FLAG_USEATTACHMENT 	= 0x0002
SOUND_FROM_WORLD 			= 0
CHAN_STATIC 				= 6

EFFECT.Speed 				= 16384
EFFECT.Length 				= 175

local MaterialMain 			= Material("effects/sw_l/rw_sw_laser_m_aqua")
local MaterialFront 		= Material("effects/sw_l/rw_sw_laser_f_aqua")
local DynamicTracer 		= GetConVar("cl_dynamic_tracer")

function EFFECT:GetTracerOrigin(data)
	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart()

	-- use attachment?
	if (bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT) then
		local entity = data:GetEntity()
		if (not IsValid(entity)) then return start end
		if (not game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT)) then return start end

		if (entity:IsWeapon() and entity:IsCarriedByLocalPlayer()) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin()
			-- if( origin ) then
			-- 	return origin, angle, entity
			-- end
			-- use the view model
			local pl = entity:GetOwner()

			if (IsValid(pl)) then
				local vm = pl:GetViewModel()

				if (IsValid(vm) and not LocalPlayer():ShouldDrawLocalPlayer()) then
					entity = vm
					-- HACK: fix the model in multiplayer
				else
					if (entity.WorldModel) then
						entity:SetModel(entity.WorldModel)
					end
				end
			end
		end

		local attachment = entity:GetAttachment(data:GetAttachment())

		if (attachment) then
			start = attachment.Pos
		end
	end

	return start
end

function EFFECT:Init(data)
	self.StartPos = self:GetTracerOrigin(data)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	local diff = self.EndPos - self.StartPos
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = (diff:Length() + self.Length) / self.Speed
	-- whiz by sound
	local weapon = data:GetEntity()

	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

--concommand.Add("sv_dlight")
function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()

	if DynamicTracer:GetBool() then
		local spawn = util.CRC(tostring(self:GetPos()))
		local dlight = DynamicLight(self:EntIndex() + spawn)
		local endDistance = self.Speed * self.StartTime
		local endPos = self.StartPos + self.Normal * endDistance

		if (dlight) then
			dlight.pos = endPos
			dlight.r = 0
			dlight.g = 255
			dlight.b = 160
			dlight.brightness = 5
			dlight.Decay = 1000
			dlight.Size = 200
			dlight.nomodel = 1
			dlight.style = 6
			dlight.DieTime = CurTime() + 3
		end
	end

	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 6, 6, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 6, 0, 1, color_white)
end
--PATH lua/effects/rw_sw_laser_lightblue.lua:

TRACER_FLAG_USEATTACHMENT 	= 0x0002
SOUND_FROM_WORLD 			= 0
CHAN_STATIC 				= 6

EFFECT.Speed 				= 16384
EFFECT.Length 				= 95

local MaterialMain 			= Material("cs574/tracers/rw_sw_laser_m_lightblue")
local MaterialFront 		= Material("cs574/tracers/rw_sw_laser_f_lightblue")
local DynamicTracer 		= GetConVar("cl_dynamic_tracer")

function EFFECT:GetTracerOrigin(data)
	local start = data:GetStart()
	if (bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT) then
		local entity = data:GetEntity()
		if (not IsValid(entity)) then return start end
		if (not game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT)) then return start end
		if (entity:IsWeapon() and entity:IsCarriedByLocalPlayer()) then
			local pl = entity:GetOwner()
			if (IsValid(pl)) then
				local vm = pl:GetViewModel()
				if (IsValid(vm) and not LocalPlayer():ShouldDrawLocalPlayer()) then
					entity = vm
				else
					if (entity.WorldModel) then
						entity:SetModel(entity.WorldModel)
					end
				end
			end
		end
		local attachment = entity:GetAttachment(data:GetAttachment())
		if (attachment) then
			start = attachment.Pos
		end
	end
	return start
end

function EFFECT:Init(data)
	self.StartPos = self:GetTracerOrigin(data)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	local diff = self.EndPos - self.StartPos
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = (diff:Length() - self.Length/2 ) / self.Speed 	--self.LifeTime = (diff:Length() - (self.Length/2) ) / self.Speed
	local weapon = data:GetEntity()
	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	if DynamicTracer:GetBool() then
		local spawn = util.CRC(tostring(self:GetPos()))
		local dlight = DynamicLight(self:EntIndex() + spawn)
		local endDistance = self.Speed * self.StartTime
		local endPos = self.StartPos + self.Normal * endDistance
		if (dlight) then
			dlight.pos = endPos
			dlight.r = 0
			dlight.g = 210
			dlight.b = 255
			dlight.brightness = 2
			dlight.Decay = 1500
			dlight.Size = 300
			dlight.nomodel = 1
			dlight.style = 6
			dlight.DieTime = CurTime() + 3
		end
	end
	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 9, 9, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 7, 0, 0, color_white)
end
--PATH lua/effects/rw_sw_laser_red.lua:
return gluapack()()
--PATH lua/effects/rw_sw_laser_redpink.lua:
return gluapack()()
--PATH lua/effects/rw_sw_laser_redpink.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002
SOUND_FROM_WORLD			= 0
CHAN_STATIC					= 6

EFFECT.Speed				= 16384
EFFECT.Length				= 175

local MaterialMain			= Material( "effect/sw_l/rw_sw_laser_m_redpink" )
local MaterialFront			= Material( "effect/sw_l/rw_sw_laser_f_redpink" )
local DynamicTracer 		= GetConVar("cl_dynamic_tracer")

function EFFECT:GetTracerOrigin(data)
	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart()

	-- use attachment?
	if (bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT) then
		local entity = data:GetEntity()
		if (not IsValid(entity)) then return start end
		if (not game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT)) then return start end

		if (entity:IsWeapon() and entity:IsCarriedByLocalPlayer()) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			-- use the view model
			local pl = entity:GetOwner()

			if (IsValid(pl)) then
				local vm = pl:GetViewModel()

				if (IsValid(vm) and not LocalPlayer():ShouldDrawLocalPlayer()) then
					entity = vm
					-- HACK: fix the model in multiplayer
				else
					if (entity.WorldModel) then
						entity:SetModel(entity.WorldModel)
					end
				end
			end
		end

		local attachment = entity:GetAttachment(data:GetAttachment())

		if (attachment) then
			start = attachment.Pos
		end
	end

	return start
end

function EFFECT:Init(data)
	self.StartPos = self:GetTracerOrigin(data)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	local diff = self.EndPos - self.StartPos
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = (diff:Length() + self.Length) / self.Speed
	-- whiz by sound
	local weapon = data:GetEntity()

	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end


function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()

	if DynamicTracer:GetBool() then
		local spawn = util.CRC(tostring(self:GetPos()))
		local dlight = DynamicLight(self:EntIndex() + spawn)
		local endDistance = self.Speed * self.StartTime
		local endPos = self.StartPos + self.Normal * endDistance

		if (dlight) then
			dlight.pos = endPos
			dlight.r = 255
			dlight.g = 0
			dlight.b = 50
			dlight.brightness = 5
			dlight.Decay = 1000
			dlight.Size = 200
			dlight.nomodel = 1
			dlight.style = 6
			dlight.DieTime = CurTime() + 3
		end
	end

	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 8, 8, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 10, 0, 1, color_white)
end
--PATH lua/effects/rw_sw_muzzleflash_aqua.lua:
return gluapack()()
--PATH lua/effects/rw_sw_muzzleflash_orange.lua:
return gluapack()()
--PATH lua/effects/rw_sw_muzzleflash_white.lua:
EFFECT.Life = 0.12
EFFECT.XFlashSize = 0.55
EFFECT.FlashSize = 0.5
EFFECT.SmokeSize = 0
EFFECT.SparkSize = 1.25
EFFECT.HeatSize = 2.5
EFFECT.Color = Color(255,255,255)
EFFECT.ColorSprites = true

local AddVel = Vector()
local ang

function EFFECT:Init(data)
	self.WeaponEnt = data:GetEntity()
	if not IsValid(self.WeaponEnt) then return end
	self.Attachment = data:GetAttachment()
	self.Position = self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)

	if IsValid(self.WeaponEnt:GetOwner()) then
		if self.WeaponEnt:GetOwner() == LocalPlayer() then
			if self.WeaponEnt:GetOwner():ShouldDrawLocalPlayer() then
				ang = self.WeaponEnt:GetOwner():EyeAngles()
				ang:Normalize()
				--ang.p = math.max(math.min(ang.p,55),-55)
				self.Forward = ang:Forward()
			else
				self.WeaponEnt = self.WeaponEnt:GetOwner():GetViewModel()
			end
			--ang.p = math.max(math.min(ang.p,55),-55)
		else
			ang = self.WeaponEnt:GetOwner():EyeAngles()
			ang:Normalize()
			self.Forward = ang:Forward()
		end
	end

	self.Forward = self.Forward or data:GetNormal()
	self.Angle = self.Forward:Angle()
	self.Right = self.Angle:Right()
	self.vOffset = self.Position
	local dir = self.Forward
	local ownerent = self.WeaponEnt:GetOwner()

	if not IsValid(ownerent) then
		ownerent = LocalPlayer()
	end

	AddVel = ownerent:GetVelocity()
	self.vOffset = self.Position
	AddVel = AddVel * 0.05
	local dot = dir:GetNormalized():Dot(GetViewEntity():EyeAngles():Forward())
	local halofac = math.abs(dot)
	local epos = ownerent:GetShootPos()
	local dlight = DynamicLight(ownerent:EntIndex())

	if (dlight) then
		dlight.pos = epos + ownerent:EyeAngles():Forward() * self.vOffset:Distance(epos) --self.vOffset - ownerent:EyeAngles():Right() * 5 + 1.05 * ownerent:GetVelocity() * FrameTime()
		dlight.r = self.Color.r
		dlight.g = self.Color.g
		dlight.b = self.Color.b
		dlight.brightness = 4.5
		dlight.decay = 200 / self.Life
		dlight.size = self.FlashSize * 150
		dlight.dietime = CurTime() + self.Life
	end

	self.Dist = self.vOffset:Distance(epos)
	self.DLight = dlight
	self.DieTime = CurTime() + self.Life
	self.OwnerEnt = ownerent
	local emitter = ParticleEmitter(self.vOffset)
	local sval = 1 - math.random(0, 1) * 2

	if self.WeaponEnt.XTick == nil then
		self.WeaponEnt.XTick = 0
	end

	self.WeaponEnt.XTick = 1 - self.WeaponEnt.XTick

	if self.WeaponEnt.XTick == 1 and self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.XFlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(3 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			particle:SetEndSize(15 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
		--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
		--particle:SetEndSize( 0 )
	elseif self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			particle:SetStartSize(2 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			particle:SetEndSize(6 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
	end

	local flashCount = math.Round(self.FlashSize * 8)

	for i = 1, flashCount do
		local particle = emitter:Add(self.ColorSprites and "effects/scotchmuzzleflashw" or "effects/scotchmuzzleflash4", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 300 * (0.2 + (i / flashCount) * 0.8) * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(math.Rand(128, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			local szsc = 1 + (flashCount - i) * math.pow(1 / flashCount * 0.9,0.8)
			particle:SetStartSize(1.25 * math.Rand(1, 1.5) * szsc * self.FlashSize)
			particle:SetEndSize(6 * math.Rand(0.75, 1) * szsc * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	for _ = 1, flashCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 6 * self.FlashSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 1)
			particle:SetStartAlpha(math.Rand(40, 140))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(2 * math.Rand(1, 1.5) * self.FlashSize)
			particle:SetEndSize(20 * math.Rand(0.5, 1) * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(30, 60)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			--TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	local glowCount = math.ceil(self.FlashSize * 3)

	for i = 1, glowCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + dir * 0.9 * i)

		if (particle) then
			--particle:SetVelocity(dir * 32 )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(255 * (1 - halofac))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.2 * self.FlashSize)
			particle:SetEndSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.6 * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	local smokeCount = math.ceil(self.SmokeSize * 6)

	for _ = 0, smokeCount do
		local particle = emitter:Add("particles/smokey", self.vOffset + dir * math.Rand(3, 14))

		if (particle) then
			particle:SetVelocity(VectorRand() * 10 * self.SmokeSize + dir * math.Rand(35, 50) * self.SmokeSize + 1.05 * AddVel)
			particle:SetDieTime(math.Rand(0.6, 1) * self.Life * 6)
			particle:SetStartAlpha(math.Rand(12, 24))
			particle:SetEndAlpha(0)
			particle:SetStartSize(math.Rand(5, 7) * self.SmokeSize)
			particle:SetEndSize(math.Rand(15, 20) * self.SmokeSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.Rand(-0.8, 0.8))
			particle:SetLighting(true)
			particle:SetAirResistance(20)
			particle:SetGravity(Vector(0, 0, 60))
			particle:SetColor(255, 255, 255)
		end
	end

	local sparkcount = math.Round(math.random(8, 12) * self.SparkSize)

	for _ = 0, sparkcount do
		local particle = emitter:Add("effects/yellowflare", self.Position)

		if (particle) then
			particle:SetVelocity( VectorRand() * 30 * self.SparkSize)
			particle:SetVelocity(particle:GetVelocity() + 1.15 * AddVel )
			particle:SetVelocity( particle:GetVelocity() + dir * math.Rand(80, 100) * (1-math.abs(math.max(particle:GetVelocity():GetNormalized():Dot(-dir),0))) * self.SparkSize )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * math.Rand(0.9,1.1))
			particle:SetStartAlpha(255)
			particle:SetEndAlpha(0)
			particle:SetStartSize(0.6)
			particle:SetEndSize(1)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetGravity(vector_origin)
			particle:SetAirResistance(1)
			particle:SetStartLength(0.1)
			particle:SetEndLength(0.05)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, math.random(192, 225), math.random(140, 192))
			end

			particle:SetVelocityScale(true)
			local sl = self.SparkSize

			particle:SetThinkFunction(function(pa)
				math.randomseed(SysTime())
				local spd = pa:GetVelocity():Length()*12
				pa.ranvel = pa.ranvel or VectorRand() * spd
				pa.ranvel:Add(VectorRand() * spd * math.sqrt(FrameTime()))
				pa:SetVelocity(pa:GetVelocity() + pa.ranvel * sl * FrameTime() )
				pa:SetNextThink(CurTime())
			end)

			particle:SetNextThink(CurTime() + 0.01)
		end
	end

	if TFA.GetGasEnabled() then
		local particle = emitter:Add("sprites/heatwave", self.vOffset + dir*2)

		if (particle) then
			particle:SetVelocity(dir * 25 * self.HeatSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life)
			particle:SetStartAlpha(math.Rand(200, 225))
			particle:SetEndAlpha(0)
			particle:SetStartSize(math.Rand(3, 5) * self.HeatSize)
			particle:SetEndSize(math.Rand(8, 12) * self.HeatSize)
			particle:SetRoll(math.Rand(0, 360))
			particle:SetRollDelta(math.Rand(-2, 2))
			particle:SetAirResistance(5)
			particle:SetGravity(Vector(0, 0, 40))
			particle:SetColor(255, 255, 255)
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	if CurTime() > self.DieTime then
		return false
	elseif self.DLight and IsValid(self.OwnerEnt) then
			self.DLight.pos = self.OwnerEnt:GetShootPos() + self.OwnerEnt:EyeAngles():Forward() * self.Dist
	end

	return true
end

function EFFECT:Render()
end
--PATH lua/effects/spr_tracer.lua:
return gluapack()()
--PATH lua/effects/swexplosion.lua:
return gluapack()()
--PATH lua/effects/fxbase.lua:
return gluapack()()
--PATH lua/effects/tfa_muzzleflash_revolver/init.lua:
include("tfa/muzzleflash_base.lua")

EFFECT.Life = 0.1
EFFECT.XFlashSize = 0
EFFECT.FlashSize = 1
EFFECT.SmokeSize = 2
EFFECT.SparkSize = 1
EFFECT.HeatSize = 1.25
EFFECT.Color = Color(255, 225, 128)
EFFECT.ColorSprites = false

--PATH lua/effects/tfa_muzzleflash_rifle/init.lua:
include("tfa/muzzleflash_base.lua")

EFFECT.Life = 0.1
EFFECT.XFlashSize = 1
EFFECT.FlashSize = 1
EFFECT.SmokeSize = 1
EFFECT.SparkSize = 1
EFFECT.HeatSize = 1
EFFECT.Color = Color(255, 192, 64)
EFFECT.ColorSprites = false

--PATH lua/effects/tfa_muzzleflash_silenced/init.lua:
return gluapack()()
--PATH lua/tfa/muzzleflash_base.lua:
local vector_origin = Vector()

EFFECT.Life = 0.1
EFFECT.XFlashSize = 1
EFFECT.FlashSize = 1
EFFECT.SmokeSize = 1
EFFECT.SparkSize = 1
EFFECT.HeatSize = 1
EFFECT.Color = Color(255, 192, 64)
EFFECT.ColorSprites = false
EFFECT.UseDynamicLight = true

local AddVel = Vector()
local ang

function EFFECT:Init(data)
	self.WeaponEnt = data:GetEntity()
	if not IsValid(self.WeaponEnt) then return end
	self.Attachment = data:GetAttachment()
	self.Position = self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)

	if IsValid(self.WeaponEnt:GetOwner()) then
		if self.WeaponEnt:GetOwner() == LocalPlayer() then
			if self.WeaponEnt:GetOwner():ShouldDrawLocalPlayer() then
				ang = self.WeaponEnt:GetOwner():EyeAngles()
				ang:Normalize()
				--ang.p = math.max(math.min(ang.p,55),-55)
				self.Forward = ang:Forward()
			else
				self.WeaponEnt = self.WeaponEnt.OwnerViewModel
			end
			--ang.p = math.max(math.min(ang.p,55),-55)
		else
			ang = self.WeaponEnt:GetOwner():EyeAngles()
			ang:Normalize()
			self.Forward = ang:Forward()
		end
	end

	self.Forward = self.Forward or data:GetNormal()
	self.Angle = self.Forward:Angle()
	self.Right = self.Angle:Right()
	self.vOffset = self.Position
	local dir = self.Forward
	local ownerent = self.WeaponEnt:GetOwner()

	if not IsValid(ownerent) then
		ownerent = LocalPlayer()
	end

	AddVel = ownerent:GetVelocity()
	self.vOffset = self.Position
	AddVel = AddVel * 0.05
	local dot = dir:GetNormalized():Dot(GetViewEntity():EyeAngles():Forward())
	local halofac = math.abs(dot)
	local epos = ownerent:EyePos()

	local dlight
	if self.UseDynamicLight then
		dlight = DynamicLight(ownerent:EntIndex())

		if (dlight) then
			dlight.pos = epos + ownerent:EyeAngles():Forward() * self.vOffset:Distance(epos) --self.vOffset - ownerent:EyeAngles():Right() * 5 + 1.05 * ownerent:GetVelocity() * FrameTime()
			dlight.r = self.Color.r
			dlight.g = self.Color.g
			dlight.b = self.Color.b
			dlight.brightness = 4.5
			dlight.decay = 200 / self.Life
			dlight.size = self.FlashSize * 96
			dlight.dietime = CurTime() + self.Life
		end
	end

	self.Dist = self.vOffset:Distance(epos)
	self.DLight = dlight
	self.DieTime = CurTime() + self.Life
	self.OwnerEnt = ownerent
	local emitter = ParticleEmitter(self.vOffset)
	local sval = 1 - math.random(0, 1) * 2

	if self.WeaponEnt.XTick == nil then
		self.WeaponEnt.XTick = 0
	end

	self.WeaponEnt.XTick = 1 - self.WeaponEnt.XTick

	if self.WeaponEnt.XTick == 1 and self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.XFlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(3 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			particle:SetEndSize(15 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
		--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
		--particle:SetEndSize( 0 )
	elseif self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			particle:SetStartSize(2 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			particle:SetEndSize(6 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
	end

	local flashCount = math.Round(self.FlashSize * 8)

	for i = 1, flashCount do
		local particle = emitter:Add(self.ColorSprites and "effects/scotchmuzzleflashw" or "effects/scotchmuzzleflash4", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 300 * (0.2 + (i / flashCount) * 0.8) * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(math.Rand(128, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			local szsc = 1 + (flashCount - i) * math.pow(1 / flashCount * 0.9,0.8)
			particle:SetStartSize(1.25 * math.Rand(1, 1.5) * szsc * self.FlashSize)
			particle:SetEndSize(6 * math.Rand(0.75, 1) * szsc * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	for _ = 1, flashCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 6 * self.FlashSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 1)
			particle:SetStartAlpha(math.Rand(40, 140))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(2 * math.Rand(1, 1.5) * self.FlashSize)
			particle:SetEndSize(20 * math.Rand(0.5, 1) * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(30, 60)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			--TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	local glowCount = math.ceil(self.FlashSize * 3)

	for i = 1, glowCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + dir * 0.9 * i)

		if (particle) then
			--particle:SetVelocity(dir * 32 )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(255 * (1 - halofac))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.2 * self.FlashSize)
			particle:SetEndSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.6 * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	if TFA.GetMZFSmokeEnabled() then
		local smokeCount = math.ceil(self.SmokeSize * 6)

		for _ = 0, smokeCount do
			local particle = emitter:Add("particles/smokey", self.vOffset + dir * math.Rand(3, 14))

			if (particle) then
				particle:SetVelocity(VectorRand() * 10 * self.SmokeSize + dir * math.Rand(35, 50) * self.SmokeSize + 1.05 * AddVel)
				particle:SetDieTime(math.Rand(0.6, 1) * self.Life * 6)
				particle:SetStartAlpha(math.Rand(12, 24))
				particle:SetEndAlpha(0)
				particle:SetStartSize(math.Rand(5, 7) * self.SmokeSize)
				particle:SetEndSize(math.Rand(15, 20) * self.SmokeSize)
				particle:SetRoll(math.rad(math.Rand(0, 360)))
				particle:SetRollDelta(math.Rand(-0.8, 0.8))
				particle:SetLighting(true)
				particle:SetAirResistance(20)
				particle:SetGravity(Vector(0, 0, 60))
				particle:SetColor(255, 255, 255)
			end
		end
	end

	local sparkcount = math.Round(math.random(8, 12) * self.SparkSize)

	for _ = 0, sparkcount do
		local particle = emitter:Add("effects/yellowflare", self.Position)

		if (particle) then
			particle:SetVelocity( VectorRand() * 30 * self.SparkSize)
			particle:SetVelocity(particle:GetVelocity() + 1.15 * AddVel )
			particle:SetVelocity( particle:GetVelocity() + dir * math.Rand(80, 100) * (1-math.abs(math.max(particle:GetVelocity():GetNormalized():Dot(-dir),0))) * self.SparkSize )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * math.Rand(0.9,1.1))
			particle:SetStartAlpha(255)
			particle:SetEndAlpha(0)
			particle:SetStartSize(0.6)
			particle:SetEndSize(1)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetGravity(vector_origin)
			particle:SetAirResistance(1)
			particle:SetStartLength(0.1)
			particle:SetEndLength(0.05)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, math.random(192, 225), math.random(140, 192))
			end

			particle:SetVelocityScale(true)
			local sl = self.SparkSize

			particle:SetThinkFunction(function(pa)
				math.randomseed(SysTime())
				local spd = pa:GetVelocity():Length()*12
				pa.ranvel = pa.ranvel or VectorRand() * spd
				pa.ranvel:Add(VectorRand() * spd * math.sqrt(FrameTime()))
				pa:SetVelocity(pa:GetVelocity() + pa.ranvel * sl * FrameTime() )
				pa:SetNextThink(CurTime())
			end)

			particle:SetNextThink(CurTime() + 0.01)
		end
	end

	if TFA.GetGasEnabled() then
		local particle = emitter:Add("sprites/heatwave", self.vOffset + dir*2)

		if (particle) then
			particle:SetVelocity(dir * 25 * self.HeatSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life)
			particle:SetStartAlpha(math.Rand(200, 225))
			particle:SetEndAlpha(0)
			particle:SetStartSize(math.Rand(3, 5) * self.HeatSize)
			particle:SetEndSize(math.Rand(8, 12) * self.HeatSize)
			particle:SetRoll(math.Rand(0, 360))
			particle:SetRollDelta(math.Rand(-2, 2))
			particle:SetAirResistance(5)
			particle:SetGravity(Vector(0, 0, 40))
			particle:SetColor(255, 255, 255)
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	if CurTime() > (self.DieTime or 0) then
		return false
	elseif self.DLight and IsValid(self.OwnerEnt) then
		self.DLight.pos = self.OwnerEnt:EyePos() + self.OwnerEnt:EyeAngles():Forward() * self.Dist
	end

	return true
end

function EFFECT:Render()
end
--PATH lua/effects/tfa_muzzleflash_smg/init.lua:
return gluapack()()
--PATH lua/tfa/muzzleflash_base.lua:
return gluapack()()
--PATH lua/tfa/muzzleflash_base.lua:
return gluapack()()
--PATH lua/effects/tfa_tracer_fubar_aq/init.lua:
TRACER_FLAG_USEATTACHMENT       = 0x0002;
SOUND_FROM_WORLD                        = 0;
CHAN_STATIC                                     = 6;

EFFECT.InValid = false;

function EFFECT:Init( data )	

		self.Position = data:GetStart()
		self.WeaponEnt = data:GetEntity()
		self.Attachment = data:GetAttachment()
		
		-- Keep the start and end pos - we're going to interpolate between them
		self.StartPos = self:GetTracerShootPos( self.Position, self.WeaponEnt, self.Attachment )
		
        self.EndPos = data:GetOrigin()
		
        util.ParticleTracerEx("weapon_fubar_trail_aq", self.StartPos, self.EndPos, false, self:EntIndex(), self.Attachment)

end

function EFFECT:Think()
 
        return false
 
end

function EFFECT:Render()
		
		if self.InValid then return false end
		
end
--PATH lua/effects/tfa_tracer_fubar_light_aq/init.lua:
TRACER_FLAG_USEATTACHMENT       = 0x0002;
SOUND_FROM_WORLD                        = 0;
CHAN_STATIC                                     = 6;

EFFECT.InValid = false;

function EFFECT:Init( data )	

		self.Position = data:GetStart()
		self.WeaponEnt = data:GetEntity()
		self.Attachment = data:GetAttachment()
		
		-- Keep the start and end pos - we're going to interpolate between them
		self.StartPos = self:GetTracerShootPos( self.Position, self.WeaponEnt, self.Attachment )
		
        self.EndPos = data:GetOrigin()
		
        util.ParticleTracerEx("weapon_fubar_beam_aq", self.StartPos, self.EndPos, false, self:EntIndex(), self.Attachment)

end

function EFFECT:Think()
 
        return false
 
end

function EFFECT:Render()
		
		if self.InValid then return false end
		
end
--PATH addons/[bronie] republic-essentials-v2d/lua/effects/tracer_purple/init.lua:
return gluapack()()
--PATH addons/[bronie] republic-essentials-v2d/lua/effects/tracer_stun/init.lua:
return gluapack()()
--PATH lua/effects/tx_130_projector.lua:
--DO NOT EDIT OR REUPLOAD THIS FILE

EFFECT.Mat = Material( "effects/lfs_base/ballturret_projectorbeam" )
EFFECT.HitMat = Material( "sprites/light_glow02_add" )

function EFFECT:Init( data )
	self.Entity = data:GetEntity()
	
	if IsValid( self.Entity ) then
		self.ID = self.Entity:LookupAttachment( "lazer_cannon_muzzle" )
		
		if self.ID then
			local Muzzle = self.Entity:GetAttachment( self.ID )

			self:SetRenderBoundsWS( self.Entity:GetPos(), Muzzle.Ang:Up() * 50000 )
		end
	end
end

function EFFECT:Think()
	if not IsValid( self.Entity ) or not self.ID or not self.Entity:GetBTLFire() then
		return false
	end
	
	return true
end


function EFFECT:Render()
	if not self.ID or not IsValid( self.Entity ) then return end
	
	local Muzzle = self.Entity:GetAttachment( self.ID )
	
	local Dir = Muzzle.Ang:Up()
	local StartPos = Muzzle.Pos
	local Trace = util.TraceLine( { start = StartPos, endpos = StartPos + Dir * 50000, filter = self } )
	local EndPos = Trace.HitPos
	
	self:SetRenderBoundsWS( StartPos, EndPos )
	
	render.SetMaterial( self.Mat )
	render.DrawBeam( StartPos, EndPos, 14 + math.random(0,4), 1, 0, Color(0,0,255,255) )
	render.DrawBeam( StartPos, EndPos, 3 + math.random(0,4), 1, 0, Color(255,255,255,255) )
	
	render.SetMaterial( self.HitMat )
	local A = 150 + math.random(0,20)
	local B = 70 + math.random(0,20)
	render.DrawSprite( StartPos, A, A, Color(0,0,255,255) )
	render.DrawSprite( StartPos, B, B, Color(255,255,255,255) )
	
	render.DrawSprite( EndPos, A, A, Color(0,0,255,255) )
	render.DrawSprite( EndPos + VectorRand() * 10, B, B, Color(255,255,255,255) )
	
	if math.random(0,5) == 1 then
		local emitter = ParticleEmitter( EndPos, false )
		local dir = (self.Entity:GetPos() - EndPos):GetNormalized()
		
		for i = 0, 10 do
			local particle = emitter:Add( "sprites/rico1", EndPos )
			
			local vel = VectorRand()  * 100 + dir * 40
			
			if particle then
				particle:SetVelocity( vel )
				particle:SetAngles( vel:Angle() + Angle(0,90,0) )
				particle:SetDieTime( math.Rand(0.1,0.3) * 0.5 )
				particle:SetStartAlpha( math.Rand( 200, 255 ) )
				particle:SetEndAlpha( 0 )
				particle:SetStartSize( math.Rand(1,30) )
				particle:SetEndSize( 0 )
				particle:SetRoll( math.Rand(-100,100) )
				particle:SetRollDelta( math.Rand(-100,100) )

				particle:SetAirResistance( 0 )
			end
		end
		
		emitter:Finish()
	end
end

--PATH lua/effects/vj_weapon_rifleshell1/init.lua:
if (!file.Exists("autorun/vj_base_autorun.lua","LUA")) then return end
/*--------------------------------------------------
	*** Copyright (c) 2012-2023 by DrVrej, All rights reserved. ***
	No parts of this code or any of its contents may be reproduced, copied, modified or adapted,
	without the prior written consent of the author, unless otherwise indicated for stand-alone materials.
--------------------------------------------------*/
function EFFECT:Init(data)
	local ent = data:GetEntity()
	if !IsValid(ent) then return end
	local effectData = EffectData()
	effectData:SetOrigin(self:GetTracerShootPos(data:GetOrigin(), ent, data:GetAttachment()))
	util.Effect("RifleShellEject", effectData, true, true)
end
---------------------------------------------------------------------------------------------------------------------------------------------
function EFFECT:Think()
	return false
end
---------------------------------------------------------------------------------------------------------------------------------------------
function EFFECT:Render()
end
--PATH lua/effects/zulu_tracer.lua:
AddCSLuaFile()
AddCSLuaFile( "effects/fxbase.lua" )
include( "effects/fxbase.lua" )

EFFECT.ParticleCast = false
EFFECT.Time = nil

EFFECT.Speed = 12000
function EFFECT:Think()

	if ( !self.ParticleCast ) then
		util.ParticleTracerEx( 
			"_wraithgun_beam", 	--particle system
			self.StartPos, 	--startpos
			self.EndPos, 	--endpos
			false, 			--do whiz effect
			-1, 			--entity index
			-1  			--attachment
		)
		
		self.ParticleCast = true
	end
	
	if ( !self.Time ) then	
		self.Time = self.LifeTime + CurTime()
	end
	
	local Fraction = math.max( 0, ( self.Time - CurTime() ) / self.LifeTime )
	
	local difforigin = self.EndPos - self.StartPos
	local lightorigin = self.StartPos + ( difforigin * ( 1 - Fraction ) ) 

	local mLight = DynamicLight( -1 )
	if ( mLight ) then
		mLight.pos = lightorigin
		mLight.r = 30
		mLight.g = 40
		mLight.b = 255
		mLight.brightness = 3 * Fraction
		mLight.Size = 180 + 200 * Fraction
		mLight.Decay = 1024
		mLight.Style = 1
		mLight.DieTime = CurTime() + 1
	end
	
	return ( self.Time > CurTime() ) 
	
end

--PATH addons/[tfres] frest_levels/lua/fstands2/levels/config.lua:
return gluapack()()
--PATH lua/rd_claim_boards/core/languages/sh_en.lua:
return gluapack()()
--PATH addons/[tfres] datapad/lua/tfres/datapad/apps/test.lua:
local APP = {}

APP.Name = "Test"                   -- Nazwa
APP.Restricted = true               -- Dosownie nic nie zmienia
APP.Category = {}     -- Kategoria joba ktra ma dostp
APP.Rank = true                     -- Czy jest od oficera

APP.Derma = function(parrent)
    local x,y = parrent:GetWide(),parrent:GetTall()
	local pan = vgui.Create("DPanel",parrent)
    pan:SetSize(x,y)
    pan:Center()
    pan:SetBackgroundColor(Color(0,0,0))
    local label = vgui.Create("DLabel",pan)
	label:SetText("To jest strona testowa")
	label:SizeToContents()
	label:Center()
    label:SetTextColor(Color(0,0,0))

end

return APP
--PATH RunString(Ex):
surface.PlaySound( "garrysmod/ui_hover.wav" )
--PATH RunString(Ex):
RunGameUICommand( "Quit" )
--PATH RunString(Ex):
surface.PlaySound( "garrysmod/ui_click.wav" )