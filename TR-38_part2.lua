--Stealed clientside server code by exechack.cc
--Hostname: [TR] Venom Roleplay | DarkRP #venom25 - discord.gg/eniyisi  - Part 2/12 - 06/04/2025


--PATH lua/zclib/util/sh_animation.lua:
zclib = zclib or {}
zclib.Animation = zclib.Animation or {}

function zclib.Animation.Play(ent,anim, speed)
	if not IsValid(ent) then return end
	local sequence = ent:LookupSequence(anim)
	ent:SetCycle(0)
	ent:ResetSequence(sequence)
	ent:SetPlaybackRate(speed)
	ent:SetCycle(0)
end

function zclib.Animation.PlayTransition(ent,anim01, speed01,anim02,speed02)

	zclib.Animation.Play(ent,anim01, speed01)

	local time = ent:SequenceDuration() or 0
	local timerid = "zclib_anim_transition_" .. ent:EntIndex()
	zclib.Timer.Remove(timerid)

	zclib.Timer.Create(timerid, time, 1, function()
		zclib.Timer.Remove(timerid)
		zclib.Animation.Play(ent, anim02, speed02)
	end)
end

--lua/zclib/util/sh_language.lua:
zclib = zclib or {}
zclib.Language = zclib.Language or {}

zclib.Language["Minutes"] = "Minutes"
zclib.Language["Seconds"] = "Seconds"
zclib.Language["Cancel"] = "Cancel"

--lua/zclib/util/sh_precache_mdl.lua:
zclib = zclib or {}


////////////////////////////////////////////
/////////// PRECACHE - MODELS //////////////
////////////////////////////////////////////
// Precaches the Model before it gets used, isntead of precaching all models at once
zclib.CachedModels = {}
function zclib.CacheModel(path)
    if zclib.CachedModels[path] then
        return path
    else
        util.PrecacheModel(path)
        zclib.CachedModels[path] = true

        zclib.Print("Model " .. path .. " cached!")

        return path
    end
end
////////////////////////////////////////////
////////////////////////////////////////////

if SERVER then return end

////////////////////////////////////////////
///////////// ClientModels /////////////////
////////////////////////////////////////////
/*

	This system Creates / Removes and keeps track on ClientModels

*/

zclib.ClientModel = zclib.ClientModel or {}
if zclib_ClientModelList == nil then
    zclib_ClientModelList = {}
end

function zclib.ClientModel.PrintAll()
    for k, v in pairs(zclib_ClientModelList) do
        if not IsValid(v) then
            zclib_ClientModelList[k] = nil
        end
    end

    PrintTable(zclib_ClientModelList)
end

function zclib.ClientModel.Add(mdl_path, rendermode)
    zclib.CacheModel(mdl_path)
    local ent = ClientsideModel(mdl_path, rendermode)
    if not IsValid(ent) then return end

    table.insert(zclib_ClientModelList, ent)

    return ent
end

function zclib.ClientModel.AddProp(mdl_path)
    local ent = nil

    if mdl_path then
        zclib.CacheModel(mdl_path)
        ent = ents.CreateClientProp(mdl_path)
    else
        ent = ents.CreateClientProp()
    end
	if not IsValid(ent) then return end
	if not ent.SetModel then return end

    table.insert(zclib_ClientModelList, ent)

    return ent
end

function zclib.ClientModel.Remove(ent)
    if not IsValid(ent) then return end
    table.RemoveByValue(zclib_ClientModelList, ent)

    // Stop moving if you have physics
    if ent.PhysicsDestroy then ent:PhysicsDestroy() end

    // Hide entity
    if ent.SetNoDraw then ent:SetNoDraw(true) end

    // This got taken from a Physcollide function but maybe its needed to prevent a crash
    local deltime = FrameTime() * 2
    if not game.SinglePlayer() then deltime = FrameTime() * 6 end
    SafeRemoveEntityDelayed(ent, deltime)
end
////////////////////////////////////////////
////////////////////////////////////////////

--lua/zclib/util/sh_util.lua:
return gluapack()()
--lua/zclib/util/cl_bluemasks.lua:
return gluapack()()
--lua/zclib/util/cl_fonts.lua:
if SERVER then return end

zclib = zclib or {}
zclib.LoadedFonts = {}
zclib.FontData = {}

/*

	This system creates fonts on demand and only on demand

*/

zclib.Hook.Add("OnScreenSizeChanged", "zclib.LoadedFonts", function(oldWidth, oldHeight)
	zclib.LoadedFonts = {}

	zclib.Print("ScreenSize changed, Clearing font cache.")
end)

function zclib.GetFont(id)
	if zclib.LoadedFonts[id] then
		// Font already exists
		return id
	else

		local FontData = zclib.FontData[id] or zclib.FontData["zclib_font_big"]

		// Linux needs everything to be lowercase
		//if system.IsLinux() then
			FontData.font = string.lower(FontData.font)
		//end

		// Create Font
		surface.CreateFont(id, FontData)
		zclib.LoadedFonts[id] = true

		zclib.Print("Font " .. id .. " cached!")
		return id
	end
end

function zclib.AddFont(id,data) zclib.FontData[id] = data end

zclib.FontData["zclib_world_font_giant"] = {
	font = "Nexa Bold",
	extended = true,
	size = 100,
	weight = 200,
	antialias = true
}

zclib.FontData["zclib_world_font_large"] = {
	font = "Nexa Bold",
	extended = true,
	size = 90,
	weight = 200,
	antialias = true
}

zclib.FontData["zclib_world_font_big"] = {
	font = "Nexa Bold",
	extended = true,
	size = 70,
	weight = 200,
	antialias = true
}

zclib.FontData["zclib_world_font_medium"] = {
	font = "Nexa Bold",
	extended = true,
	size = 50,
	weight = 200,
	antialias = true
}

zclib.FontData["zclib_world_font_mediumsmall"] = {
	font = "Nexa Bold",
	extended = true,
	size = 35,
	weight = 200,
	antialias = true
}

zclib.FontData["zclib_world_font_mediumsmoll"] = {
	font = "Nexa Bold",
	extended = true,
	size = 29,
	weight = 200,
	antialias = true
}


zclib.FontData["zclib_world_font_small"] = {
	font = "Nexa Bold",
	extended = true,
	size = 25,
	weight = 200,
	antialias = true
}

zclib.FontData["zclib_world_font_tiny"] = {
	font = "Nexa Bold",
	extended = true,
	size = 20,
	weight = 200,
	antialias = true
}

zclib.FontData["zclib_world_font_verytiny"] = {
	font = "Nexa Bold",
	extended = true,
	size = 15,
	weight = 200,
	antialias = true
}

zclib.FontData["zclib_world_font_supertiny"] = {
	font = "Nexa Bold",
	extended = true,
	size = 12,
	weight = 200,
	antialias = true
}


zclib.FontData["zclib_font_ultra"] = {
	font = "Nexa Bold",
	extended = true,
	size = ScreenScale(100),
	weight = ScreenScale(500),
	antialias = true
}

zclib.FontData["zclib_font_giant"] = {
	font = "Nexa Bold",
	extended = true,
	size = ScreenScale(40),
	weight = ScreenScale(500),
	antialias = true
}

zclib.FontData["zclib_font_huge"] = {
	font = "Nexa Bold",
	extended = true,
	size = ScreenScale(30),
	weight = ScreenScale(500),
	antialias = true
}

zclib.FontData["zclib_font_large"] = {
	font = "Nexa Bold",
	extended = true,
	size = ScreenScale(25),
	weight = ScreenScale(100),
	antialias = true
}

zclib.FontData["zclib_font_bigger"] = {
	font = "Nexa Bold",
	extended = true,
	size = ScreenScale(20),
	weight = ScreenScale(100),
	antialias = true
}

zclib.FontData["zclib_font_big"] = {
	font = "Nexa Bold",
	extended = true,
	size = ScreenScale(15),
	weight = ScreenScale(100),
	antialias = true
}


zclib.FontData["zclib_font_medium"] = {
	font = "Nexa Bold",
	extended = true,
	size = ScreenScale(10),
	weight = ScreenScale(100),
	antialias = true
}

zclib.FontData["zclib_font_medium_thin"] = {
	font = "Nexa Light",
	extended = true,
	size = ScreenScale(10),
	weight = ScreenScale(1),
	antialias = true
}

zclib.FontData["zclib_font_mediumsmall"] = {
	font = "Nexa Bold",
	extended = true,
	size = ScreenScale(8),
	weight = ScreenScale(100),
	antialias = true
}

zclib.FontData["zclib_font_mediumsmall_blur"] = {
	font = "Nexa Bold",
	extended = true,
	size = ScreenScale(8),
	weight = ScreenScale(100),
	blursize = 5,
	antialias = true
}
zclib.FontData["zclib_font_mediumsmall_thin"] = {
	font = "Nexa Light",
	extended = true,
	size = ScreenScale(8),
	weight = ScreenScale(1),
	antialias = true
}

zclib.FontData["zclib_font_mediumsmoll_thin"] = {
	font = "Nexa Light",
	extended = true,
	size = ScreenScale(7),
	weight = ScreenScale(1),
	antialias = true
}


zclib.FontData["zclib_font_small"] = {
	font = "Nexa Bold",
	extended = true,
	size = ScreenScale(6),
	weight = ScreenScale(100),
	antialias = true
}

zclib.FontData["zclib_font_smoll"] = {
	font = "Nexa Light",
	extended = true,
	size = ScreenScale(5),
	weight = ScreenScale(100),
	antialias = true
}

zclib.FontData["zclib_font_small_thin"] = {
	font = "Nexa Light",
	extended = true,
	size = ScreenScale(6),
	weight = ScreenScale(1),
	antialias = true
}

zclib.FontData["zclib_font_tiny"] = {
	font = "Nexa Bold",
	extended = true,
	size = ScreenScale(5),
	weight = ScreenScale(100),
	antialias = true
}

zclib.FontData["zclib_font_makro"] = {
	font = "Nexa Bold",
	extended = true,
	size = ScreenScale(4),
	weight = ScreenScale(100),
	antialias = true
}


zclib.FontData["zclib_font_nano"] = {
	font = "Nexa Bold",
	extended = true,
	size = ScreenScale(3.5),
	weight = ScreenScale(100),
	antialias = true
}

--lua/zclib/util/cl_rope.lua:
return gluapack()()
--lua/zclib/util/cl_settings.lua:
return gluapack()()
--lua/zclib/generic/sh_inventory_support.lua:
zclib = zclib or {}
zclib.Inventory = zclib.Inventory or {}

function zclib.Inventory.GetItems(ply)
    local inv = {}
    if itemstore then
        if SERVER then
            inv = table.Copy(ply.Inventory:GetItems())
        else
            if LocalPlayer().InventoryID and itemstore.containers.Active[LocalPlayer().InventoryID] and itemstore.containers.Active[LocalPlayer().InventoryID].Items then
                inv = table.Copy(itemstore.containers.Active[LocalPlayer().InventoryID].Items)
            end
        end
    end
    return inv
end

if SERVER then
    // Trys to pickup the specified enttiy in to the players Inventory, returns false otherwhise
    function zclib.Inventory.Pickup(ply,ent,class)
        local success = false
        if itemstore then
            local item = itemstore.Item(class)
            if item == nil then return false end
            local con = itemstore.config.PickupsGotoBank and ply.Bank or ply.Inventory
            if con == nil then return false end
            if con:CanFit(item) then
                ply:PickupItem(ent)
                success = true
            end
        elseif XeninInventory then

            local inv = ply:XeninInventory()
            local amt = table.Count(inv:GetInventory())
            local slots = inv:GetSlots()
            if (amt >= slots) then return false end
            if ply:XeninInventory():Pickup(ent) == true then
                success = true
            end
        elseif idinv then
            local inv = ply:GetInventory()
            if inv then
                idinv.item:Create(ent, nil, function(item, id)
                    inv:addItem(id)
                end)
            end
        elseif BRICKS_SERVER then

            if IsValid(ent) then

				if not ply.GetInventory then
					zclib.ErrorPrint("Could not find Bricks inventory player meta function > ply:GetInventory()")
					return
				end

                local inventoryTable = ply:GetInventory()
                if (table.Count(inventoryTable) >= BRICKS_SERVER.Func.GetInventorySlots(ply)) then
                    return
                end

                local itemData = BRICKS_SERVER.Func.GetEntTypeField(ent:GetClass(), "GetItemData")(ent)
                ply:BRS_InventoryAdd(itemData, 1)

                ent:Remove()
                success = true
            end
        elseif engine.ActiveGamemode() == "underdone" then
            ply:AddItem(class,1)
        end

        return success
    end

    // Takes the specified amount
    function zclib.Inventory.Take(ply,typecheck,amount)
        local success = false
        if itemstore then
            ply.Inventory:Suppress( function()
                for k, v in pairs( ply.Inventory:GetItems() ) do
                    if typecheck() then
                        v:SetAmount( v:GetAmount() - amount )

                        if v:GetAmount() <= 0 then
                            ply.Inventory:SetItem( k, nil )
                        end

                        success = true
                    end
                end
                return true
            end )
        end
        return success
    end
end

--lua/zclib/data/sh_data.lua:
return gluapack()()
--addons/aphone/lua/autorun/aphone_loader.lua:
aphone = aphone or {}
aphone.Config = aphone.Config or {}
aphone.RegisteredApps = {}

local start_time = SysTime()

local function include_dir(dir)
    local files, folders = file.Find(dir .. "*", "LUA")

    for k,v in ipairs(files) do
        local prefix = string.sub(v, 1, 3)
        local file_dir = dir .. v

        if aphone.disable_hitman and string.find(file_dir, "darkweb") then continue end

        if prefix == "sh_" then
            if SERVER then
                AddCSLuaFile(file_dir)
            end
            include(file_dir)
        elseif prefix == "sv_" and SERVER then
            include(file_dir)
        elseif prefix == "cl_" then
            if SERVER then
                AddCSLuaFile(file_dir)
            else
                include(file_dir)
            end
        else
            print("[APhone] Can't include " .. v .. ", wrong prefix")
            continue
        end
    end

    for k, v in ipairs(folders) do
        include_dir(dir .. v .. "/")
    end
end

include("aphone/sh_config.lua")

if !aphone.RadioList then
    print("------ APhone ------")
    print("You got a issue with installation, the config file can't be loaded")
    print("Follow these instructions to debug the config file")
    print("Check before this message in your console if there any errors OR paste your config in this file : https://fptje.github.io/glualint-web/")
    print("Most of the time, it's a missing comma or quotation marks")
    print("To prevent any issues, APhone will stop loading")
    print("--------------------")
    return
end

if SERVER then
    AddCSLuaFile("aphone/sh_config.lua")
    AddCSLuaFile("aphone/languages/" .. aphone.Language .. ".lua")
    include("aphone/sv_config.lua")
    resource.AddWorkshop( "2485178558" )
end

include("aphone/languages/" .. aphone.Language .. ".lua")

include_dir("aphone/_libs/")
include_dir("aphone/apps/")
hook.Run("aphone_PostLoad")

if aphone.DebugMode then
    print("[APhone] Loading in " .. SysTime() - start_time .. "s")
end
--addons/aphone/lua/aphone/_libs/_utilities/cl__clientside_save.lua:
return gluapack()()
--addons/aphone/lua/aphone/_libs/_utilities/cl_renderview.lua:
return gluapack()()
--addons/aphone/lua/aphone/_libs/painting/cl_panel.lua:
local rt = GetRenderTargetEx( "aphone_RT_Shop", 1024, 1024, RT_SIZE_OFFSCREEN, MATERIAL_RT_DEPTH_NONE, 0, 0, IMAGE_FORMAT_RGBA8888)
local tex = CreateMaterial( "aphone_RT_Shop", "VertexLitGeneric", {
	["$basetexture"] = rt:GetName()
} )

aphone.matlist = {6}

local slider_list = {
	["mat_id"] = {
		name = aphone.L("Material"),
		min = 1,
		max = #aphone.Painting,
		default = 1,
		round = 0,
		order = 0,
	},
	["angle"] = {
		name = aphone.L("Angle"),
		min = 0,
		max = 360,
		default = 0,
		order = 1,
	},
	["clr_r"] = {
		name = aphone.L("Red"),
		min = 0,
		max = 255,
		default = 255,
		order = 2,
	},
	["clr_g"] = {
		name = aphone.L("Green"),
		min = 0,
		max = 255,
		default = 255,
		order = 3,
	},
	["clr_b"] = {
		name = aphone.L("Blue"),
		min = 0,
		max = 255,
		default = 255,
		order = 4,
	},
	["posx"] = {
		name = aphone.L("PosX"),
		min = 0,
		max = 1,
		default = 0.5,
		round = 2,
		order = 5,
	},
	["posy"] = {
		name = aphone.L("PosY"),
		min = 0,
		max = 1,
		default = 0.5,
		round = 2,
		order = 6,
	},
	["sizex"] = {
		name = aphone.L("SizeX"),
		min = 0,
		max = 5,
		default = 1,
		round = 2,
		order = 7,
	},
	["sizey"] = {
		name = aphone.L("SizeY"),
		min = 0,
		max = 5,
		default = 1,
		round = 2,
		order = 8,
	},
}

function aphone.OpenPaint()
	gui.EnableScreenClicker(true)
	local stickers = aphone.SelfPaint or {}

	// Cache colors
	local black_48 = aphone:Color("Black48")
	local black_40 = aphone:Color("Black40")
	local mat_red = aphone:Color("mat_red")
	local text_orange = aphone:Color("Text_Orange")
	local white_font = aphone:Color("White_Font")
	local text_white = aphone:Color("Text_White")
	local mat_black = aphone:Color("mat_black")
	local mat_lightred = aphone:Color("mat_lightred")
	local mat_blackred = aphone:Color("mat_blackred")

	aphone:Painting_Generate(rt, stickers)

	local f = vgui.Create("EditablePanel")
	f:SetSize(ScrW() * 0.45, ScrH() * 0.5)
	f:Center()
	f:MakePopup()

	function f:OnRemove()
		gui.EnableScreenClicker(false)
	end

	function f:Paint(w, h)
		draw.RoundedBox(4, 0, 0, w, h, black_40)
	end

	local AdjustableModelPanel = vgui.Create( "DAdjustableModelPanel", f)
	AdjustableModelPanel:Dock(LEFT)
	AdjustableModelPanel:SetWide(f:GetTall())
	AdjustableModelPanel:SetLookAt( Vector( 0, 0, 0 ) )
	AdjustableModelPanel:SetModel( "models/akulla/aphone/w_aphone.mdl" )
	function AdjustableModelPanel:LayoutEntity() return end // disables default rotation

	// HACK : The model will show only if the panel is already clicked one time if I don't do that.
	AdjustableModelPanel:OnMousePressed(MOUSE_LEFT)

	timer.Simple(0.3, function()
		AdjustableModelPanel:OnMouseReleased(MOUSE_LEFT)
	end)
	// End of hack

	if !aphone.Texturelist[LocalPlayer():UserID()] then
		aphone:Painting_Generate(rt, {})
	end

	for k, v in pairs(aphone.matlist) do
		AdjustableModelPanel.Entity:SetSubMaterial(v, "!" .. tex:GetName())
	end

	local bottom_dock = vgui.Create("DPanel", f)
	bottom_dock:Dock(BOTTOM)
	bottom_dock:SetTall(50)

	local add_sticker = vgui.Create("DButton", bottom_dock)
	add_sticker:Dock(LEFT)
	add_sticker:SetWide((f:GetWide() - f:GetTall()) / 2)
	add_sticker:SetPaintBackground(false)
	add_sticker:TDLib()
	add_sticker:Background(mat_red)
	add_sticker:FadeHover(text_orange)
	add_sticker:Text(aphone.L("Add_Layer"), "MediumHeader_2D", white_font)

	local finish_sticker = vgui.Create("DButton", bottom_dock)
	finish_sticker:Dock(FILL)
	finish_sticker:SetPaintBackground(false)
	finish_sticker:TDLib()
	finish_sticker:Background(mat_red)
	finish_sticker:FadeHover(text_orange)
	finish_sticker:Text(aphone.L("Confirm"), "MediumHeader_2D", white_font)

	local list = vgui.Create("DScrollPanel", f)
	list:Dock(FILL)
	list:GetVBar():SetWide(0)
	list:aphone_PaintScroll()

	function list:Paint(w, h)
		surface.SetDrawColor(black_48)
		surface.DrawRect(0, 0, w, h)
	end

	function list:AddSticker(id, id_table)
		local deployable = vgui.Create("DPanel")
		list:AddItem(deployable)
		deployable:Dock(TOP)
		deployable:SetTall(50)
		deployable:SetPaintBackground(false)

		local b = vgui.Create("DButton", deployable)
		b:Dock(TOP)
		b:SetText("")
		b:SetTall(50)
		b:SetPaintBackground(false)
		b:TDLib()
		b:FillHover(mat_red, LEFT)

		local delete = vgui.Create("DButton", b)
		delete:Dock(RIGHT)
		delete:SetText("")
		delete:SetPaintBackground(false)
		delete:SetWide(b:GetTall())

		function delete:DoClick()
			stickers[id] = nil
			deployable:Remove()
			aphone:Painting_Generate(rt, stickers)
		end

		function deployable:Paint(w, h)
			if deployable:GetTall() != b:GetTall() then
				surface.SetDrawColor(mat_black)
				surface.DrawRect(0, 0, w, h)
			end
		end

		b:On("PaintOver", function(pnl, w, h)
			if deployable:GetTall() != pnl:GetTall() then
				surface.SetDrawColor(mat_red)
				surface.DrawRect(0, 0, w, h)
			end

			draw.SimpleText("Sticker " .. id, "MediumHeader_2D", 10, h / 2, text_white, 0, 1)
			// Bit ghetto, but I won't need to mess with ZPos etc...
			draw.SimpleText("-", "MediumHeader_2D", w - h / 2, h / 2, white_font, 1, 1)
		end)

		local settings_wide = f:GetWide() - AdjustableModelPanel:GetWide() - 20
		local settings = vgui.Create("DScrollPanel", deployable)
		settings:Dock(TOP)
		settings:DockMargin(10, 0, 10, 0)
		settings:SetPadding(settings_wide * 0.05)

		b:On("DoClick", function(pnl)
			deployable:SizeTo(-1, deployable:GetTall() == b:GetTall() and settings:GetTall() + b:GetTall() or b:GetTall(), 0.5, 0, 0.5)
		end)

		// Choose material
		for k, v in SortedPairsByMemberValue(slider_list, "order") do
			local set_txt = vgui.Create("DLabel")
			settings:AddItem(set_txt)
			set_txt:Dock(TOP)
			set_txt:SetText(v.name)
			set_txt:SetFont("Small_2D")

			local set_slider = vgui.Create("DSlider")
			settings:AddItem(set_slider)
			set_slider:Dock(TOP)
			set_slider:DockMargin(settings_wide * 0.15, 0, settings_wide * 0.15, 0)
			set_slider:SetSlideX((id_table[k] - v.min) / (v.max - v.min))

			function set_slider:Paint(w, h)
				surface.SetDrawColor(mat_lightred)
				surface.DrawRect(0, h * 0.35, w, h * 0.3)
				surface.SetDrawColor(mat_blackred)
				surface.DrawRect(0, h * 0.35, w * self:GetSlideX(), h * 0.3)
			end

			function set_slider:Think()
				if self:IsEditing() then
					local val = (v.max - v.min) * self:GetSlideX() + v.min

					if v.round then
						val = math.Round(val, v.round)
					end

					stickers[id][k] = val
					aphone:Painting_Generate(rt, stickers)
				end
			end

			function set_slider.Knob:Paint(w, h) end
		end

		// SizeToChildren don't work, making it myself
		local final_height = 0
		for k, v in ipairs(settings:GetCanvas():GetChildren()) do
			local _, dm_top, __, dm_bottom = v:GetDockMargin()
			final_height = final_height + v:GetTall() + dm_top + dm_bottom
		end
		settings:SetTall(final_height)
	end

	-- Can have gap, not using ipairs
	for k, v in pairs(stickers) do
		list:AddSticker(k, v)
	end

	function add_sticker:DoClick()
		if table.Count(stickers) >= aphone.MaxPainting then return end

		local t = {}
		-- Can have gap, not using ipairs
		for k, v in pairs(slider_list) do
			t[k] = v.default
		end

		list:AddSticker(table.insert(stickers, t), t)
		aphone:Painting_Generate(rt, stickers)
	end

	function finish_sticker:DoClick()
		net.Start("aphone_ChangeSticker")
			net.WriteUInt(table.Count(stickers), 6)

			// Send the wannabe table
			for k, v in SortedPairs(stickers) do
				net.WriteUInt(v.mat_id, 16)
				net.WriteUInt(v.angle, 9)
				net.WriteUInt(v.clr_r, 8)
				net.WriteUInt(v.clr_g, 8)
				net.WriteUInt(v.clr_b, 8)
				net.WriteUInt(v.posx * 100, 10)
				net.WriteUInt(v.posy * 100, 10)
				net.WriteUInt(v.sizex * 100, 10)
				net.WriteUInt(v.sizey * 100, 10)
			end
		net.SendToServer()
		f:Remove()
	end
end
--addons/aphone/lua/aphone/_libs/panels/cl_messageimagepanel.lua:
return gluapack()()
--addons/aphone/lua/aphone/_libs/panels/cl_onlinepicturelist.lua:
return gluapack()()
--addons/aphone/lua/aphone/apps/dodgeit/cl_init.lua:
return gluapack()()
--addons/aphone/lua/aphone/apps/dodgeit/cl_init.lua:
local APP = {}

APP.name = "DodgeIt!"
APP.icon = "akulla/aphone/app_dodgeit.png"

local clr = {
    Color(29, 209, 161),
    Color(72, 219, 251),
    Color(255, 107, 107),
    Color(255, 159, 67),
    Color(254, 202, 87),
    Color(255, 159, 243),
    Color(95, 39, 205),
    Color(200, 214, 229),
}

function APP:Open(main, main_x, main_y, horizontal)
    local color_black2 = aphone:Color("Black2")
    local color_white180 = aphone:Color("Text_White180")
    local round_time = CurTime()
    local Roboto60 = aphone:GetFont("Roboto60")
    local svg_30 = aphone:GetFont("SVG_30")

    local balls = {}

    function main:Paint(w, h)
        surface.SetDrawColor(color_black2)
        surface.DrawRect(0,0,w,h)

        draw.SimpleText(math.Round(CurTime() - round_time) .. "s", Roboto60, w / 2, h / 5, color_white180, 1, 1)
    end

    local s = main_x < main_y and main_x * 0.1 or main_y * 0.1

    local end_game = vgui.Create("DPanel", main)
    end_game:Dock(FILL)
    end_game:SetVisible(false)
    end_game:SetAlpha(0)

    function end_game:Paint(w, h)
        surface.SetDrawColor(color_black2)
        surface.DrawRect(0,0,w,h)

        draw.SimpleText(end_game.win_time .. "s", Roboto60, w / 2, h / 5, color_white180, 1, 1)
    end

    local restart = vgui.Create("DLabel", end_game)
    restart:SetFont(Roboto60)
    restart:SetContentAlignment(5)
    restart:Dock(FILL)
    restart:SetText(aphone.L("Restart"))
    restart:SetTextColor(color_white180)
    restart:Phone_AlphaHover()
    restart:SetMouseInputEnabled(true)

    function restart:DoClick()
        round_time = CurTime()
        timer.UnPause("APhone_DodgeIt")
        timer.Adjust("APhone_DodgeIt", 1)

        end_game:AlphaTo(0, 0.25, 0, function()
            end_game:SetVisible(false)
        end)
    end

    timer.Create("APhone_DodgeIt", 1, 0, function()
        local dir = math.random(1, 4)
        local move_x, move_y
        local c = vgui.Create("DPanel", main)

        c:SetSize(s, s)

        if dir == 1 then
            local val = math.random(0, main_y)
            c:SetPos(0, val)
            move_x, move_y = main_x + s, val
        elseif dir == 2 then
            local val = math.random(0, main_y)
            c:SetPos(main_x, val)
            move_x, move_y = -s, val
        elseif dir == 3 then
            local val = math.random(0, main_x)
            c:SetPos(val, 0)
            move_x = val
            move_y = main_y + s
        elseif dir == 4 then
            local val = math.random(0, main_x)
            c:SetPos(val, main_y)
            move_x, move_y = val, -s
        end

        c:MoveTo(move_x, move_y, 1, 0, 1, function()
            c:Remove()
            table.RemoveByValue(balls, c)
        end)

        local random_clr = clr[ math.random( #clr ) ]

        function c:Paint(w, h)
            draw.SimpleText("d", svg_30, w / 2, h / 2, random_clr, 1, 1)

            // He hover a ball ? then he lost
            // Cursor not visible ? Then he is cheating, make him lose
            if self:IsHovered() and !end_game:IsVisible() then
                end_game.win_time = math.Round(CurTime() - round_time)

                end_game:SetVisible(true)
                end_game:AlphaTo(255, 0.5, 0)
                timer.Pause( "APhone_DodgeIt" )
            end
        end

        local time = timer.TimeLeft("APhone_DodgeIt") - 0.03
        time = (time >= 0.20) and time or 0.20

        timer.Adjust("APhone_DodgeIt", time)

        table.insert(balls, c)
    end)

    function main:Think()
        if !aphone.cursor_visible and !end_game:IsVisible() then
            end_game.win_time = math.Round(CurTime() - round_time)

            end_game:SetVisible(true)
            end_game:AlphaTo(255, 0.5, 0)
            timer.Pause( "APhone_DodgeIt" )
        end
    end

    main:aphone_RemoveCursor()
end

function APP:Open2D(main, main_x, main_y)
    APP:Open(main, main_x, main_y, true)
end

aphone.RegisterApp(APP)
--addons/aphone/lua/aphone/apps/gps/cl_main.lua:
return gluapack()()
--addons/aphone/lua/aphone/apps/messages/cl_init.lua:
return gluapack()()
--addons/aphone/lua/aphone/apps/messages/cl_messages.lua:
sql.Query( "CREATE TABLE IF NOT EXISTS aphone_Messages(user INTEGER, body TEXT, ip TEXT, local_sender INTEGER, timestamp INTEGER)")
sql.Query( "CREATE TABLE IF NOT EXISTS aphone_Friends(user INTEGER, body TEXT, ip TEXT, local_sender INTEGER, timestamp INTEGER, last_name TEXT, likes INTEGER DEFAULT 0, id INTEGER DEFAULT 0, local_vote INTEGER DEFAULT 0)")

aphone.Messages = aphone.Messages or {}

local function cache_message(userid, body, local_sender, timestamp, is_friends, msg_id)
	timestamp = timestamp or os.time()
	if !is_friends then
		sql.Query("INSERT INTO aphone_Messages(user, body, ip, local_sender, timestamp) VALUES(" .. userid .. ", " .. sql.SQLStr(body) .. "," .. sql.SQLStr(game.GetIPAddress()) .. "," .. (local_sender and 1 or 0) .. "," .. timestamp .. ")")
	else
		sql.Query("INSERT INTO aphone_Friends(user, body, ip, local_sender, timestamp, last_name, id) VALUES(" .. userid .. ", " .. sql.SQLStr(body) .. ", " .. sql.SQLStr(game.GetIPAddress()) .. ", " .. (userid == LocalPlayer():aphone_GetID() and 1 or 0) .. ", " .. timestamp .. ", '" .. is_friends .. "'," .. msg_id .. ")")
	end
end

function aphone.Contacts.Send(userid, body, is_friends)
	net.Start("aphone_NewMessage")
		net.WriteBool(is_friends)

		if !is_friends then
			net.WriteUInt(userid, 32)
		end

		net.WriteString(body)
	net.SendToServer()

	if !is_friends then
		cache_message(userid, body, true, os.time())
	end
end

net.Receive("aphone_CacheClientMessages", function()
	local loop_value = net.ReadUInt(16)
	local is_friends = net.ReadBool()
	local ply_id = LocalPlayer():aphone_GetID()

	for i = 1, loop_value do
		local user1 = net.ReadUInt(24)
		local user2 = !is_friends and net.ReadUInt(24) or nil
		local body = net.ReadString()
		local timestamp = net.ReadUInt(32)

		if is_friends then
			local name = net.ReadString()
			cache_message(user1, body, user1 == ply_id, timestamp, name, net.ReadUInt(32))
		else
			cache_message(user1 != ply_id and user1 or user2, body, user1 == ply_id, timestamp)
		end
	end
end)

net.Receive("aphone_CacheLikes", function()
	local loop_value = net.ReadUInt(16)

	for i = 1, loop_value do
		local q = "UPDATE aphone_Friends SET likes = " .. net.ReadUInt(32) .. " WHERE id = " .. net.ReadUInt(32)
		sql.Query(q)
	end
end)

net.Receive("aphone_SyncOneMessage", function()
	local uid = net.ReadEntity()
	local body = net.ReadString()
	local is_friends = net.ReadBool()

	if !is_friends then
		if !aphone:GetParameters("Core", "SilentMode", false) and IsValid(LocalPlayer()) and LocalPlayer():HasWeapon("aphone") then
			aphone.playringtone()
		end

		if aphone.InsertNewMessage then
			aphone.InsertNewMessage(uid, body)
		end

		cache_message(uid:aphone_GetID(), body, false)
	else
		local time = net.ReadUInt(32)
		local msg_id = net.ReadUInt(32)
		cache_message(uid:aphone_GetID(), body, false, time, uid:GetName(), msg_id)

		if aphone.InsertNewMessage_Friend then
			aphone.InsertNewMessage_Friend(uid:aphone_GetID(), body, msg_id, uid:GetName(), 0, 0)
		end
	end
end)

local red = Color(255, 82, 82)
net.Receive("aphone_AddLike", function()
	local b = net.ReadBool()
	local id = net.ReadUInt(29)
	local user = net.ReadUInt(24)
	local local_vote = (user == LocalPlayer():aphone_GetID())
	local q

	if local_vote then
		q = "UPDATE aphone_Friends SET likes = likes " .. (b and "+ 1" or "- 1") .. ", local_vote = " .. (b and 1 or 0 ) .. " WHERE id = " .. id
	else
		q = "UPDATE aphone_Friends SET likes = likes " .. (b and "+ 1" or "- 1") .. " WHERE id = " .. id
	end

	sql.Query(q)

	if aphone.Friends_PanelList and aphone.Friends_PanelList[id] and IsValid(aphone.Friends_PanelList[id]) then
		local pnl = aphone.Friends_PanelList[id].like_count
		pnl:SetText(tonumber(pnl:GetText()) + (b and 1 or -1))

		if local_vote then
			local like_logo = aphone.Friends_PanelList[id].like_logo
			like_logo:SetTextColor(!b and aphone:Color("Black1") or red)
		end
	end
end)
--addons/[binbon]arccw_modify/lua/autorun/arccw_autorun.lua:
return gluapack()()
--lua/arccw/shared/sh_1_ur.lua:
return gluapack()()
--lua/arccw/shared/attachments/mw2_ubgl_masterkey.lua:
return gluapack()()
--lua/arccw/shared/attachments/mw2_wepcamo_bushdweller.lua:
return gluapack()()
--lua/arccw/shared/attachments/mw2_wepcamo_desert.lua:
return gluapack()()
--lua/arccw/shared/attachments/mw2_wepcamo_digital.lua:
att.PrintName = "Digital"
att.Icon = Material("entities/mw2_wepcamo_digital.png", "smooth"
)
att.Description = "Digtial camouflage finish."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Slot = "mw2_wepcamo"
att.Free = true

att.ActivateElements = {"wepcamo-digital"}

att.SortOrder = 4 *-1
--lua/arccw/shared/attachments/optic_mw2_augscope.lua:
return gluapack()()
--lua/arccw/shared/attachments/optic_mw2_rds.lua:
att.PrintName = "Red Dot Sight (RDS)"
att.Icon = Material("entities/acwatt_optic_mw2_reddot.png", "smooth")
att.Description = "Thin red dot sight used by special forces."

att.SortOrder = 0

att.Desc_Pros = {
    "autostat.holosight",
}
att.Desc_Cons = {
}
att.AutoStats = true
att.Slot = {"optic","optic_lp"}

att.Model = "models/weapons/arccw/fesiugmw2/atts/scopes/reddot_2d.mdl"
att.ModelOffset = Vector(-1, 0, -0.1)

att.AdditionalSights = {
    {
        Pos = Vector(0, 3, -0.8),
        Ang = Angle(0, 0, 0),
        ViewModelFOV = 65 / 1.3,
        Magnification = 1.3,
        ScrollFunc = ArcCW.SCROLL_NONE,
        IgnoreExtra = true,
    }
}

att.Holosight = true
att.HolosightReticle = Material("holosights/mw2_reddot.png", "mips smooth")
att.HolosightSize = 0.33
att.HolosightBone = "holosight"

att.Mult_SightTime = 1.05

att.Colorable = true

att.AddSuffix = " RDS"
--lua/arccw/shared/attachments/uc_40mm_airburst.lua:
return gluapack()()
--lua/arccw/shared/attachments/uc_40mm_flash.lua:
att.PrintName = "40mm Stun Grenades" -- trol
att.AbbrevName = "Stun"
att.Icon = Material("entities/att/arccw_uc_40mm_generic.png", "mips smooth")
att.Description = "Less-than-lethal grenades that create a blinding flash and deafening bang.\nWhile typically used as hand grenades, the larger projectile allows for a more visible and audible effect."
att.Desc_Pros = {
    "uc.40mm.flash"
}
att.Desc_Cons = {
    "uc.40mm.nodmg"
}
att.Desc_Neutrals = {
}
att.Slot = "uc_40mm"

att.Override_ShootEntity = "arccw_uc_40mm_flash"

att.AutoStats = true

--att.Mult_Recoil = 1

att.ActivateElements = {"40mm_flash"}
--lua/arccw/shared/attachments/uc_40mm_smoke.lua:
att.PrintName = "40mm Smoke Grenades"
att.AbbrevName = "Smoke"
att.Icon = Material("entities/att/arccw_uc_40mm_generic.png", "mips smooth")
att.Description = "Less-than-lethal grenades that create a ring of smoke, obscuring vision."
att.Desc_Pros = {
    "uc.40mm.smoke"
}
att.Desc_Cons = {
    "uc.40mm.nodmg"
}
att.Desc_Neutrals = {
}
att.Slot = "uc_40mm"

att.Override_ShootEntity = "arccw_uc_40mm_smoke"

att.AutoStats = true

att.ActivateElements = {"40mm_smoke"}
--lua/arccw/shared/attachments/uc_ammo_sg_confetti.lua:
return gluapack()()
--lua/arccw/shared/attachments/uc_ammo_sg_drgn.lua:
att.PrintName = "\"DRGN\" Dragon's Breath"

att.SortOrder = -1
att.Icon = Material("entities/att/arccw_uc_ammo_shotgun_generic.png", "mips smooth")
att.Description = [[Novelty magnesium-based round that projects a spectacular jet of sparks and fire. Burning at over 3,000 °F, the blast isn't immediately lethal, but can easily set objects and people ablaze.

Only compatible with manual action shotguns due to a weak pressure curve.]]
att.Desc_Pros = {
    "uc.ignite",
    "uc.pellet.12",
}
att.Desc_Cons = {
    "uc.accuracy.35",
    "uc.dragon",
    "uc.alwaysphys",
}
att.Desc_Neutrals = {
    "uc.manualonly",
}
att.Slot = {"ud_ammo_shotgun", "uc_ammo"}
att.ActivateElements = {"uc_manualonly"}
att.AutoStats = true

att.Add_Num = 12

-- zombies don't take damage from DMG_BURN (hardcoded to set them on fire)
local dontburn = {
    npc_zombie = true,
    npc_zombie_torso = true,
    npc_zombine = true,
    npc_fastzombie = true,
    npc_fastzombie_torso = true,
    npc_headcrab = true,
    npc_headcrab_fast = true,
    npc_headcrab_black = true,
}

att.Hook_PhysBulletHit = function(wep, data)
    if SERVER and data.tr.Entity then
        local d = data.bullet.Travelled * ArcCW.HUToM
        local dur = 6 - d * 2 / wep.Range
        if dur > 0 then
            data.tr.Entity:Extinguish()
            data.tr.Entity:Ignite(dur)
        end

        local delta = math.Clamp(d / data.bullet.Range, 0, 1)

        -- Impact is disabled (no bullet holes) so we do damage ourselves
        local dmg = DamageInfo()
        dmg:SetAttacker(data.bullet.Attacker)
        dmg:SetInflictor(data.bullet.Weapon)
        dmg:SetDamage(Lerp(delta, data.bullet.DamageMax, data.bullet.DamageMin))
        dmg:SetDamagePosition(data.bullet.Pos)
        dmg:SetDamageForce(data.bullet.Vel)
        dmg:SetDamageType(dontburn[data.tr.Entity:GetClass()] and DMG_BUCKSHOT or (DMG_BURN + DMG_BUCKSHOT))

        data.tr.Entity:TakeDamageInfo(dmg)
    end

    local effect = EffectData()
    effect:SetOrigin(data.tr.HitPos)
    util.Effect("StunstickImpact",effect)
    
    if data.tr.HitWorld then
        util.Decal("FadingScorch",data.tr.HitPos - data.tr.HitNormal,data.tr.HitPos + data.tr.HitNormal)
    end
end

att.Override_PhysBulletImpact = false

att.Override_DamageType = DMG_BURN + DMG_BUCKSHOT

att.Override_HullSize = 2
att.Override_HullSize_Priority = 100
att.Add_AccuracyMOA = 35
att.Mult_Damage = .5
att.Mult_DamageMin = .5

att.Override_AlwaysPhysBullet = true
att.Override_PhysBulletMuzzleVelocity = 100
att.Mult_PhysBulletGravity = 0.75
att.Override_PhysBulletDrag = 4

att.Override_PhysTracerProfile = "uc_dragon"
att.Override_MuzzleEffect = "muzzleflash_dragonbreath"

att.Override_UC_ShellColor = Color(0.9 * 255, 0.3 * 255, 0.1 * 255)

att.Hook_AddShootSound = function(wep, data)
    wep:EmitSound("DB_ADD", data.volume,data.pitch,1,CHAN_WEAPON - 1) -- lua/arccw/shared/sh_0_uc.lua
end

att.GivesFlags = {"needsmanual"}
att.Hook_Compatible = function(wep)
    if (!wep.ManualAction and !wep.UC_CanManualAction) or !wep:GetIsShotgun() or wep:GetBuff_Override("UC_Shotshell") then return false end
end
--lua/arccw/shared/attachments/uc_charm_urbancharm_common.lua:
return gluapack()()
--lua/arccw/shared/attachments/uc_charm_urbancharm_renewal.lua:
return gluapack()()
--lua/arccw/shared/attachments/uc_choke_full.lua:
att.PrintName = "Full Choke"

att.Icon = nil -- Material("entities/att/acwatt_lowpolysaiga12extmag.png", "smooth mips")
att.Description = "A very tight choke for shotguns, noticably tightening spread. However, it tends to offset aiming."
att.Desc_Pros = {
}
att.Desc_Cons = {
    "uc.disp.100"
}
att.Desc_Neutrals = {
}
att.Slot = {"choke","muzzle"}
att.AutoStats = true

att.Hook_Compatible = function(wep)
    if !wep:GetIsShotgun() then
        return false
    end
end

att.Mult_Recoil = 1.25
att.Mult_RecoilSide = 1.5
att.Mult_AccuracyMOA = .7
att.Add_HipDispersion = 100
att.Add_SightsDispersion = 100
--lua/arccw/shared/attachments/uc_fg_deeprifling.lua:
att.PrintName = "Deep Rifling"

att.Icon = Material("entities/att/arccw_uc_deeprifling.png", "mips smooth")
att.Description = "A custom tailored rifling scheme allows bullets to strike with greater impact, penetrating deeper."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "uc_fg"
att.AutoStats = true
att.SortOrder = 1

att.Hook_Compatible = function(wep)
    if wep:GetIsShotgun() then
        return false
    end
end

att.Mult_Penetration = 1.25

att.AttachSound = "arccw_uc/common/gunsmith/internal_modification.ogg"
--lua/arccw/shared/attachments/uc_fg_match.lua:
return gluapack()()
--lua/arccw/shared/attachments/uc_fg_underwater.lua:
return gluapack()()
--lua/arccw/shared/attachments/uc_grip_kacvfg.lua:
return gluapack()()
--lua/arccw/shared/attachments/uc_grip_kacvfg.lua:
att.PrintName = "Knight's Armament Company Vertical Foregrip"
att.AbbrevName = "KAC Vertical Foregrip"
att.Icon = Material("entities/att/acwatt_uc_grip_kacvfg.png", "mips smooth")
att.Description = "Medium-length vertical foregrip that assists in control of the weapon, but detracts from its concealability."

att.SortOrder = 1400

att.AutoStats = true
att.Slot = "foregrip"

att.LHIK = true

att.ModelOffset = Vector(0, 0, -0.25)
att.Model = "models/weapons/arccw/atts/uc_kacvfg1.mdl"

att.Mult_Recoil = 0.8
att.Mult_SightTime = 1.1
att.Mult_DrawTime = 1.15
att.Mult_HolsterTime = 1.15

att.Override_HoldtypeActive = "smg"
att.Override_HoldtypeActive_Priority = 2
--lua/arccw/shared/attachments/uc_muzzle_supp_cylinder.lua:
att.PrintName = "Cylinder Suppressor"
att.Icon = Material("entities/att/acwatt_uc_muzzle_supp_cylinder.png", "mips smooth")
att.Description = "Traps propellant gas from the muzzle, reducing visual and audible report.\nBulky and heavy, but provides better ballistic performance.\n\n\"By the time you figured it out, it would be too late.\""
att.Desc_Neutrals = {"uc.muzzleblocking", "uc.exclusive.shotgun"}

att.AutoStats = true
att.Slot = {"muzzle_shotgun","muzzle"}

att.GivesFlags = {"muzzleblocking"}
att.ExcludeFlags = {"nomuzzleblocking"}

att.SortOrder = 150

att.Model = "models/weapons/arccw/atts/ud_silencer_870.mdl"
att.ModelOffset = Vector(-1, 0, 0)
att.OffsetAng = Angle(0, 0, 0)

att.Silencer = true
att.Override_MuzzleEffect = "muzzleflash_suppressed"
att.IsMuzzleDevice = true

att.Mult_ShootPitch = 1.1
att.Mult_ShootVol = 0.75

att.Add_BarrelLength = 6
att.Mult_SightTime = 1.15
att.Mult_HipDispersion = 1.2
att.Mult_Sway = 1.15
att.Mult_Range = 1.1

att.AttachSound = "arccw_uc/common/gunsmith/suppressor_thread.ogg"

att.Hook_Compatible = function(wep)
    if !wep:GetIsShotgun() then
        return false
    end
end
--lua/arccw/shared/attachments/uc_muzzle_supp_lighthouse.lua:
att.PrintName = "L15 'Lighthouse' Suppressor" -- fictional
att.AbbrevName = "Lighthouse Suppressor"

att.Icon = Material("entities/att/acwatt_uc_muzzle_supp_lighthouse.png", "mips smooth")
att.Description = "Traps propellant gas from the muzzle, reducing visual and audible report.\nImproves close range stopping power slightly due to redirection of gas pressure."
att.Desc_Neutrals = {"uc.exclusive.rifle", "uc.supptail"}

att.AutoStats = true
att.Slot = {"muzzle"}

att.SortOrder = 150

att.Model = "models/weapons/arccw/atts/ud_silencer_light.mdl"
att.ModelOffset = Vector(-0.25, 0, 0)
att.OffsetAng = Angle(0, 180, 0)

att.Silencer = true
att.Override_MuzzleEffect = "muzzleflash_suppressed"
att.IsMuzzleDevice = true

att.Mult_ShootPitch = 1.1
att.Mult_ShootVol = 0.75
att.Mult_Range = 0.85
att.Mult_RangeMin = 1.75

att.Add_BarrelLength = 5
att.Mult_SightTime = 1.1
att.Mult_Sway = 1.15

att.AttachSound = "arccw_uc/common/gunsmith/suppressor_thread.ogg"

att.Hook_Compatible = function(wep,data)
    if !ArcCW.UC.RifleAmmoTypes[wep:GetBuff_Override("Override_Ammo", wep.Primary.Ammo)] then
        return false
    end
end

att.Hook_GetDistantShootSound = function(wep, distancesound)
    if wep:GetBuff("PhysBulletMuzzleVelocity") < ArcCW.UC.SubsonicThreshold then
        return false
    end
end
--lua/arccw/shared/attachments/uc_muzzle_supp_pbs4.lua:
return gluapack()()
--lua/arccw/shared/attachments/uc_optic_acog.lua:
att.PrintName = "Trijicon Advanced Combat Optical Gunsight (4x)"
att.AbbrevName = "ACOG (4x)"
att.Icon = Material("entities/att/acwatt_uc_optic_acog.png", "mips smooth")
att.Description = "Medium range combat scope for improved precision at longer ranges.\nEquipped with backup iron sights for use in emergencies."

att.SortOrder = 4

att.Desc_Pros = {
    "autostat.holosight",
    "autostat.zoom",
}
att.Desc_Neutrals = {"uc.bus"}

att.AutoStats = true
att.Slot = {"optic", "ud_optic", "ud_acog"}

att.Model = "models/weapons/arccw/atts/ud_acog.mdl"
att.ModelOffset = Vector(0, 0, 0)
att.ModelScale = Vector(1.15, 1.15, 1.15)
att.OffsetAng = Angle(0, 0, 0)

att.AdditionalSights = {
    {
        Pos = Vector(0, 8, -1.48),
        Ang = Angle(0, 0, 0),
        Magnification = 1.1,
        ViewModelFOV = 38,
        IgnoreExtra = true,
        CrosshairInSights = false,
        HolosightBone = "holosight",
        HolosightData = {
            Holosight = true,
            HolosightReticle = Material("hud/scopes/uc_acog_reticle.png", "smooth"),
            HolosightNoFlare = true,
            HolosightSize = 11,
            HolosightPiece = "models/weapons/arccw/atts/ud_acog_hsp.mdl",
            HolosightBlackbox = true,
            HolosightMagnification = UC_HalfScope( 4 ),
            Colorable = true,
        },
    },
    {
        Pos = Vector(-0.005, 11, -2.632),
        Ang = Angle(-1, 0, 0),
        Magnification = 1.1,
        IgnoreExtra = true,
        HolosightData = {
            Holosight = false,
        },
    },
}

att.Colorable = true
att.HolosightPiece = "models/weapons/arccw/atts/ud_acog_hsp.mdl"

att.Mult_SightedSpeedMult = 0.75
--lua/arccw/shared/attachments/uc_optic_comp_m2.lua:
att.PrintName = "AIMPOINT CompM2 Red Dot (RDS)"
att.AbbrevName = "CompM2 (RDS)"
att.Icon = Material("entities/att/acwatt_uc_optic_comp_m2.png", "mips smooth")
att.Description = "Improves sighted visibility with a red-dot targeting reticle, while adding minimal extra weight."

att.SortOrder = 1

att.Desc_Pros = {
    "autostat.holosight",
}
att.Desc_Cons = {
}
att.AutoStats = true
att.Slot = {"optic"}

att.Model = "models/weapons/arccw/atts/uc_comp_m2.mdl"
att.ModelOffset = Vector(0, 0, 0)
att.ModelScale = Vector(0.9, 0.9, 0.9)

att.AdditionalSights = {
    {
        Pos = Vector(0, 9, -1.5), -- -1.44
        Ang = Angle(0, 0, 0),
        Magnification = 1.1,
        ScrollFunc = ArcCW.SCROLL_NONE,
    }
}

att.Holosight = true
att.HolosightReticle = Material("hud/reticles/uc_reddot.png", "mips smooth")
att.HolosightPiece = "models/weapons/arccw/atts/uc_comp_m2_hsp.mdl"
att.HolosightNoFlare = false
att.HolosightSize = 1.5
att.HolosightBone = "holosight"
att.Colorable = true

att.Mult_SightedSpeedMult = .9
--lua/arccw/shared/attachments/uc_optic_elcan.lua:
return gluapack()()
--lua/arccw/shared/attachments/uc_optic_elcan.lua:
att.PrintName = "ELCAN C79 (2.5x)"
att.Icon = Material("entities/att/acwatt_uc_optic_elcan.png", "mips smooth")
att.Description = "Durable, dependable, and venerable medium-range combat scope built to stand up to constant heavy fire.\nEquipped with backup iron sights for use in emergencies."

att.SortOrder = 2.5

att.Desc_Pros = {
    "autostat.holosight",
    "autostat.zoom",
}
att.Desc_Neutrals = {"uc.bus"}

att.AutoStats = true
att.Slot = {"optic", "ud_optic", "ud_acog"}

att.Model = "models/weapons/arccw/atts/uc_gso_elcan.mdl"
att.ModelOffset = Vector(0, 0, 0)
att.ModelScale = Vector(1, 1, 1)
att.OffsetAng = Angle(0, 0, 0)

att.AdditionalSights = {
    {
        Pos = Vector(0, 8, -1.51577),
        Ang = Angle(0, 0, 0),
        Magnification = 1.1,
        ViewModelFOV = 38,
        IgnoreExtra = true,
        CrosshairInSights = false,
        HolosightBone = "holosight",
        HolosightData = {
            Holosight = true,
            HolosightReticle = Material("hud/scopes/uc_elcan.png", "smooth"),
            HolosightNoFlare = true,
            HolosightSize = 11.5,
            HolosightPiece = "models/weapons/arccw/atts/uc_gso_elcan_hsp.mdl",
            HolosightBlackbox = true,
            HolosightMagnification = UC_HalfScope( 2.5 ),
            Colorable = true,
        },
    },
    {
        Pos = Vector(0, 11, -2.62),
        Ang = Angle(-0.25, 0, 0),
        Magnification = 1.1,
        IgnoreExtra = true,
        HolosightData = {
            Holosight = false,
        },
    },
}

att.Colorable = true
att.HolosightPiece = "models/weapons/arccw/atts/uc_gso_elcan_hsp.mdl"

att.Mult_SightedSpeedMult = 0.75
--lua/arccw/shared/attachments/uc_optic_leupold_dppro.lua:
return gluapack()()
--lua/arccw/shared/attachments/uc_optic_micro_t1.lua:
att.PrintName = "AIMPOINT Micro T-1 Red Dot Reflex Sight (RDS)"
att.AbbrevName = "Micro T-1 (RDS)"
att.Icon = Material("entities/att/acwatt_uc_optic_micro_t1.png", "mips smooth")
att.Description = "Improves sighted visibility with a red-dot targeting reticle, while adding minimal extra weight."

att.SortOrder = 1

att.Desc_Pros = {
    "autostat.holosight",
}
att.Desc_Cons = {
}
att.AutoStats = true
att.Slot = {"optic"}

att.Model = "models/weapons/arccw/atts/uc_mirco_t1.mdl"
att.ModelOffset = Vector(0,0,0.2)
att.ModelScale = Vector(1.2,1.2,1.2)

att.AdditionalSights = {
    {
        Pos = Vector(0, 9, -1.59),
        Ang = Angle(0, 0, 0),
        Magnification = 1.1,
        ScrollFunc = ArcCW.SCROLL_NONE
    }
}

att.Holosight = true
att.HolosightReticle = Material("hud/reticles/uc_reddot.png", "mips smooth")
att.HolosightPiece = "models/weapons/arccw/atts/uc_mirco_t1_hsp.mdl"
att.HolosightNoFlare = false
att.HolosightSize = 1.5
att.HolosightBone = "holosight"
att.Colorable = true

att.Mult_SightedSpeedMult = .9
--lua/arccw/shared/attachments/uc_optic_sureshot.lua:
return gluapack()()
--lua/arccw/shared/attachments/uc_powder_low.lua:
att.PrintName = "Reduced Load"

att.SortOrder = 18
att.Icon = Material("entities/att/acwatt_uc_powder_low.png", "smooth mips")
att.Description = "Underpressured ammunition places less strain on the weapon, but lowers muzzle velocity and cyclic rate."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "uc_powder"

att.AutoStats = true

att.Mult_Recoil = 0.85
att.Mult_Range = 0.8

att.Mult_RPM = 0.95
att.Mult_ShootVol = 0.9
--att.Mult_ShootPitch = 1.05 please don't

att.Mult_MalfunctionMean = 1.15
att.Mult_PhysBulletMuzzleVelocity = 0.9
--lua/arccw/shared/attachments/uc_tp_endurance.lua:
return gluapack()()
--lua/arccw/shared/attachments/uc_tp_fullstroke.lua:
return gluapack()()
--lua/arccw/shared/attachments/uc_tp_runandgun.lua:
att.PrintName = "On the Move"

att.Icon = Material("entities/att/arccw_uc_tp_run_and_gun.png", "smooth mips")
att.Description = "Expert training in high-verticality maneuvers and countless moving-while-shooting drills allow you to aim steadily even while moving between cover, across open ground, or while mid-air."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "uc_tp"

att.AutoStats = true
att.SortOrder = 4

att.Mult_JumpDispersion = 0
att.Mult_MoveDispersion = .5

att.NotForNPCs = true
--lua/arccw/shared/attachments/uc_usp_sight.lua:
return gluapack()()
--lua/arccw/shared/attachments/ud_870_optic_ringsight.lua:
att.PrintName = "Ring Sight"
att.Icon = Material("entities/att/acwatt_ud_870_optic_ringsight.png", "mips smooth")
att.Description = "Rear sight module that allows for easier iron sight alignment but a reduced field of vision."
att.Slot = "ud_870_optic"

att.Desc_Neutrals = {"uc.cosmetic"}

att.SortOrder = 999
att.AutoStats = true
--lua/arccw/shared/attachments/ud_glock_caliber_22lr.lua:
return gluapack()()
--lua/arccw/shared/attachments/ud_glock_skin_olive.lua:
att.PrintName = "Glock 17 Olive Drab Finish"
if !GetConVar("arccw_truenames"):GetBool() then
    att.PrintName = "GEN3 Olive Drab Finish"
end
att.AbbrevName = "Olive Drab"

att.Icon = Material("entities/att/acwatt_ud_glock_material.png", "smooth mips")
att.Description = "Olive drab finish for for your polymer handgun."
att.Desc_Neutrals = {"uc.cosmetic"}
att.Slot = "ud_glock_skin"

--lua/arccw/shared/attachments/ud_glock_slide_carbine.lua:
return gluapack()()
--lua/arccw/shared/attachments/ud_m1014_handguard_sport.lua:
att.PrintName = "Sporting Handguard"
att.Icon = Material("", "smooth mips")
att.Description = "Aftermarket handguard with a rough grip surface. It's much lighter, but not as comfortable to grip."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "ud_1014_handguard"

att.AutoStats = true
att.SortOrder = 999

att.Mult_SightTime = 0.85
att.Mult_ShootSpeedMult = 0.9
att.Mult_SightedSpeedMult = 0.9

att.ActivateElements = {"ud_m1014_handguard_sport"}
--lua/arccw/shared/attachments/ud_m16_barrel_sd.lua:
att.PrintName = "10\" Suppressed Barrel"

if GetConVar("arccw_truenames"):GetBool() then
    att.PrintName = "10\" M16 SD Barrel"
end

att.Icon = Material("entities/att/acwatt_ud_m16_barrel_sd.png", "smooth mips")
att.Description = "Integrally suppressed short barrel made by hobbyists. Dampens sound effectively, but the suppressor adds to weapon weight.\nPerformance may degrade with sustained fire."
att.Desc_Pros = {
    --"uc.auto"
}
att.Desc_Cons = {
    "uc.overheat"
}
att.Desc_Neutrals = {
    "uc.supptail",
    "ud.m16.allowfs",
}
att.Slot = "ud_m16_blen"

att.AutoStats = true

att.Mult_SightTime = 1.05

att.Mult_Range = 0.65
att.Mult_Recoil = 1.15
att.Mult_AccuracyMOA = 1.5
att.Mult_RPM = 1.111
att.Mult_HipDispersion = 0.75


att.Add_BarrelLength = -10
att.Mult_PhysBulletMuzzleVelocity = 0.78

att.LHIK = true

att.Model = "models/weapons/arccw/atts/m4_lhik.mdl"

att.Mult_ShootVol = 0.65
att.Silencer = true
att.Override_MuzzleEffect = "muzzleflash_suppressed"
att.GivesFlags = {"sd", "ud_m16_rscompatible", "ud_m16_sd"}
att.SDBarrel = true

att.ActivateElements = {"hg_sd"}

att.Override_Jamming = true
att.Override_HeatLockout = false
att.Override_HeatFix = false
att.Override_HeatCapacity = 90
att.Override_HeatDelayTime = 2
att.Override_HeatDissipation = 7.5

att.Hook_ModifyRPM = function(wep, delay)
    local heat = math.Clamp(wep:GetHeat() / wep:GetMaxHeat(), 0, 1)
    if heat > 0.5 then
        return delay * (1 + ((heat - 0.5) / 0.5) * 0.5)
    end
end

att.M_Hook_Mult_ShootVol = function(wep, data)
    local heat = math.Clamp(wep:GetHeat() / wep:GetMaxHeat(), 0, 1)
    data.mult = data.mult * (1 + heat * 0.25)
end

att.M_Hook_Mult_ShootPitch = function(wep, data)
    local heat = math.Clamp(wep:GetHeat() / wep:GetMaxHeat(), 0, 1)
    if heat > 0.5 then
        data.mult = data.mult * (1 - (heat - 0.5) / 0.5 * 0.15)
    end
end

att.M_Hook_Mult_AccuracyMOA = function(wep, data)
    local heat = math.Clamp(wep:GetHeat() / wep:GetMaxHeat(), 0, 1)
    if heat > 0.5 then
        data.mult = data.mult * (1 + ((heat - 0.5) / 0.5))
    end
end

att.Hook_GetDistantShootSound = function(wep, distancesound)
    if wep:GetBuff("PhysBulletMuzzleVelocity") < ArcCW.UC.SubsonicThreshold then
        return false
    end
end
--lua/arccw/shared/attachments/ud_m16_charm_ch2.lua:
att.PrintName = "Classic Rail Mount"
att.Icon = Material("entities/att/acwatt_ud_m16_charm_ch2.png", "smooth mips")
att.Description = "Keep it extra retro with this old-school rail mount."
att.Desc_Pros = {}
att.Desc_Cons = {}
att.Desc_Neutrals = {
    "ud.m16_ch.1",
    "ud.m16_ch.2",
    "ud.m16_nors"
}
att.Slot = "ud_m16_charm"

att.ActivateElements = {"ud_m16_upper_charm2"}
att.GivesFlags = {"ud_m16_retro"}
att.ExcludeFlags = {"ud_m16_not_retro", "ud_m16_a1"}
att.TopMount = 3

att.SortOrder = 1000
--lua/arccw/shared/attachments/ud_m16_charm_tl.lua:
att.PrintName = "Tactical Laser Position"
att.Icon = Material("entities/att/arccw_ud_pointshoot.png", "smooth mips")
att.Description = "Give your AN/PEQ a reason to be thin."
att.Desc_Pros = {}
att.Desc_Cons = {}
att.Desc_Neutrals = {
    "ud.m16_tl.1",
    "ud.m16_tl.2",
    "ud.m16_nors"
}
att.Slot = "ud_m16_charm"

att.ActivateElements = {"bravo_dicks_going_fart"}
att.AdditionalSights = {
    {
        Pos = Vector(0, 20, -3),
        Ang = Angle(0, 0, -25),
        GlobalPos = false,
        GlobalAng = true,
        Magnification = 1
    }
}

att.SortOrder = 998
att.TacLaserPos = true
att.RequireFlags = {"tac"}

att.FrontSight = 1

--att.Ignore = true
--lua/arccw/shared/attachments/ud_m16_fs_kac.lua:
att.PrintName = "KAC Flip-Up Front Sight"
att.AbbrevName = "KAC Front Sight"
att.Icon = Material("entities/att/acwatt_ud_m16_fs_kac.png", "mips smooth")
att.Description = [[Removable front sight made by Knight's Armament Company. Designed to be mounted on forend rails.]]
att.Desc_Neutrals = {"uc.cosmetic"}
att.SortOrder = 1
att.IgnorePickX = true

att.Model = "models/weapons/arccw/atts/kac_fs.mdl"
att.ModelScale = Vector(0.7, 0.7, 0.7)
att.Slot = {"ud_m16_fs"}
att.RequireFlags = {"ud_m16_rscompatible"}
att.GivesFlags = {"ud_m16_rs"}

att.FrontSight = 1
--lua/arccw/shared/attachments/ud_m16_hg_adar.lua:
att.PrintName = "RUCAR 225 Short Wooden Handguard"

att.Icon = Material("entities/att/acwatt_ud_m16_hg_adar.png", "smooth mips")
att.Description = "Wooden handguard used on Russian sporting variants. The heavier material allows for lower recoil than handguards of similar length."

if GetConVar("arccw_truenames"):GetBool() then
    att.PrintName = "ADAR 2-15 Short Wooden Handguard"
end

att.AbbrevName = "Short Wooden Handguard"
att.Slot = "ud_m16_hg"
att.AutoStats = true

att.Mult_Sway = 0.9
att.Mult_RecoilSide = 0.85
att.Mult_Recoil = 0.95

att.Mult_SightedSpeedMult = 0.95
att.Mult_ShootSpeedMult = 0.95

att.LHIK = true
att.Model = "models/weapons/arccw/atts/adar_lhik.mdl"
att.DroppedModel = "models/items/boxsrounds.mdl"
att.ModelOffset = (Vector(0.41, 0, -1.63) - Vector(11.5, 2.8, -4.2))

--lua/arccw/shared/attachments/ud_m16_hg_heat.lua:
return gluapack()()
--lua/arccw/shared/attachments/ud_m16_hg_tactical.lua:
att.PrintName = "RAYCAR TACTICS Forend Assembly" -- "Armorers United" ?? WHO
if GetConVar("arccw_truenames"):GetBool() then
    att.PrintName = "KAC RAS Forend Assembly"
end
att.AbbrevName = "Tactical Handguard"
att.Icon = Material("entities/att/acwatt_ud_m16_hg_ris.png", "smooth mips")
att.Description = "Barrel shroud equipped with a quad-rail RIS interface, allowing the rifle to accept the attachment of tactical devices or foregrips without any additional modification.\n\nFunctionally identical to the stock handguard."
att.Desc_Neutrals = {
    "ud.m16.allowfs",
}
att.Slot = "ud_m16_hg"
att.SortOrder = 99

att.Free = true
att.IgnorePickX = true

att.LHIK = true
att.Model = "models/weapons/arccw/atts/tactical_lhik.mdl"
att.DroppedModel = "models/items/boxsrounds.mdl"
att.ModelOffset = (Vector(0.41, 0, -1.63) - Vector(11.5, 2.8, -4.2))

att.ActivateElements = {"mount_tactical"}
att.GivesFlags = {"ud_m16_rscompatible"}


--lua/arccw/shared/attachments/ud_m16_mag_50beo_12.lua:
att.PrintName = ".50 Beowulf 12-Round Standard Mag"
att.AbbrevName = "12-Round Standard Mag"
att.Icon = Material("entities/att/acwatt_ud_m16_mag_30.png", "smooth mips")
att.Description = "Standard 5.56mm magazines converted to load .50 Beowulf rounds in a single stack. Requires a bit of elbow grease to squeeze them in."
att.Desc_Pros = {}
att.Desc_Cons = {}
att.Desc_Neutrals = {}
att.Slot = "ud_m16_mag"

att.AutoStats = true
att.HideIfBlocked = true
att.Free = true -- since this is just the standard mag

att.SortOrder = 2
att.Override_ClipSize = 12

att.Mult_SightTime = 1.1
att.Mult_ReloadTime = 1.15
att.Mult_Sway = 1.5

att.Mult_SpeedMult = 0.975

att.Mult_HipDispersion = 1.15

att.RequireFlags = {"m16_50beo"}
--lua/arccw/shared/attachments/ud_m16_muzzle_607.lua:
return gluapack()()
--lua/arccw/shared/attachments/ud_m16_muzzle_xm177.lua:
att.PrintName = "CAR-15 XM177 Moderator"
att.AbbrevName = "XM177 Moderator"
att.Icon = Material("entities/att/acwatt_ud_m16_muzzle_xm177.png", "mips smooth")
att.Description = ""
att.Desc_Pros = {
    "uc.flashhider"
}
att.Desc_Cons = {
}
att.AutoStats = true
att.Slot = "ud_m16_muzzle"

att.SortOrder = -100

att.Model = "models/weapons/arccw/atts/fesiug_moderator_xm177.mdl"
att.ModelOffset = Vector(0.3, 0, 0)
att.ModelScale = Vector(1, 1, 1)
att.OffsetAng = Angle(0, 0, 0)

att.Add_BarrelLength = 4
att.Mult_Sway = 1.1
att.Mult_HipDispersion = 0.9

att.Mult_ShootPitch = 1.1
att.Mult_ShootVol = 0.75

att.AttachSound = "arccw_uc/common/gunsmith/suppressor_thread.ogg"
--lua/arccw/shared/attachments/ud_mini14_barrel_short.lua:
return gluapack()()
--lua/arccw/shared/attachments/ud_mini14_mag_42.lua:
return gluapack()()
--lua/arccw/shared/attachments/ud_mini14_stock_tactical.lua:
return gluapack()()
--lua/arccw/shared/attachments/ud_mini14_stock_tactical_polymer.lua:
return gluapack()()
--lua/arccw/shared/attachments/ud_uzi_mag_100.lua:
return gluapack()()
--lua/arccw/shared/attachments/ud_uzi_stock_remove.lua:
att.PrintName = "No Stock"
att.Icon = nil -- Material("entities/att/acwatt_lowpolysaiga12extmag.png", "smooth mips")
att.Description = "Remove your stock. Who needs it, anyway? Not a real gangsta, that's who."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "ud_uzi_stock"

att.AutoStats = true
att.Free = true
att.SortOrder = 1

att.Mult_Recoil = 1.5
att.Mult_RecoilSide = 1.25
att.Mult_VisualRecoilMult = 2
att.Mult_Sway = 2

att.Mult_SightTime = 0.75
att.Mult_SightedSpeedMult = 1.1
att.Mult_ShootSpeedMult = 1.1

att.Mult_DrawTime = 0.75
att.Mult_HolsterTime = 0.75
att.Add_BarrelLength = -2
--lua/arccw/shared/attachments/ur_1911_skin_nickel.lua:
att.PrintName = "M1911 Nickel Finish"
att.AbbrevName = "Nickel"
att.Icon = Material("entities/att/ur_1911/skin_dark.png","mips smooth")
att.Description = "A warm, shiny nickel finish that glows vibrantly under the sun."
att.SortOrder = 9

att.Desc_Neutrals = {
    "uc.cosmetic"
}

att.AutoStats = true
att.Slot = "ur_m1911_skin"
att.Free = true

att.Ignore = true
--lua/arccw/shared/attachments/ur_329_barrel_m29.lua:
att.PrintName = "6\" Model 29 Barrel"
att.AbbrevName = "6\" Full-Size Barrel"
if !GetConVar("arccw_truenames"):GetBool() then
    att.PrintName = "6\" Thunderbolt Barrel"
end
att.Icon = Material("entities/att/acwatt_ur_329_barrel_m29.png","smooth mips")
att.Description = "Extended barrel that provides extra counterweight in addition to marginal ballistic enhancements."
att.Slot = "ur_329_barrel"
att.AutoStats = true
att.SortOrder = 6

att.Mult_AccuracyMOA = 0.7
att.Mult_Range = 1.5
att.Mult_Recoil = 0.85
att.Mult_SightTime = 1.25
att.Mult_Sway = 1.15
att.Mult_HipDispersion = 1.1
att.Mult_PhysBulletMuzzleVelocity = 1.15

att.Add_BarrelLength = 4

att.Mult_DrawTime = 1.15
att.Mult_HolsterTime = 1.15
--lua/arccw/shared/attachments/ur_ak_barrel_krinkov.lua:
att.PrintName = "AKS-74U 8\" Compact Barrel"
att.AbbrevName = "8\" Compact Barrel"
att.Icon = Material("entities/att/ur_ak/barrel/aksu.png", "mips smooth")
att.Description = "Special carbine length handguard and barrel. Its reduced length leads to less unwieldiness, and the shortened gas system increases cyclic rate respectably.\nThese traits combined, however, result in a difficult weapon to control."
att.Slot = {"ur_ak_barrel"}
att.AutoStats = true

if !GetConVar("arccw_truenames"):GetBool() then
    att.PrintName = "KFSU-76 8\" Compact Barrel"
end

att.SortOrder = 8

att.Mult_ShootPitch = 115 / 100
att.Add_BarrelLength = -6
att.Mult_RPM = 1.131
att.Mult_SightTime = 0.8
att.Mult_HipDispersion = 0.8
att.Mult_SightedSpeedMult = 1.1
att.Mult_SpeedMult = 1.02
att.Mult_Sway = 0.75

att.Mult_Recoil = 1.5
att.Mult_AccuracyMOA = 2
att.Mult_Range = .5

att.ActivateElements = {"barrel_krinkov"}
att.GivesFlags = {"ak_barrelchange", "barrel_carbine", "ak_barrelkrinkov"}

att.LHIK = true

att.ModelOffset = Vector(-24, -3.1, 3.6)
att.OffsetAng = Angle(10, 0, 0)
att.Model = "models/weapons/arccw/ak_lhik_u.mdl"
--lua/arccw/shared/attachments/ur_ak_cal_556.lua:
return gluapack()()
--lua/arccw/shared/attachments/ur_ak_cal_9mm.lua:
att.PrintName = "PP-19 Vityaz 9x19mm Parabellum Receiver"
att.AbbrevName = "9x19mm Receiver"

if !GetConVar("arccw_truenames"):GetBool() then
    att.PrintName = "Bogatyr SMG 9x19mm Parabellum Receiver"
end

att.Icon = Material("entities/att/uc_bullets/9x19.png", "mips smooth")
att.Description = "Converts the weapon to a submachine gun. The smaller caliber drastically reduces recoil, but has much less range and is less accurate."
att.Slot = {"ur_ak_cal"}
att.AutoStats = true

att.SortOrder = 9

att.Override_Ammo = "pistol"
att.Override_Trivia_Calibre = att.AbbrevName
att.Override_Trivia_Class = "Submachine Gun"

att.Mult_Range = 0.6
att.Mult_RPM = 1.178 -- 800 rpm with the carbine barrels
att.Mult_ReloadTime = .95
att.Mult_Recoil = .35
att.Mult_AccuracyMOA = .85
att.Mult_HipDispersion = .75
att.Mult_ShootPitch = 90 / 100

att.Mult_Penetration = 0.125
att.Mult_DamageMin = 0.85
att.Mult_Damage = 0.64

att.Override_Ammo = "pistol"
att.Override_Trivia_Calibre = "9x19mm Parabellum"
att.Override_Trivia_Class = "Submachine Gun"
att.Override_ShellModel = "models/weapons/arccw/uc_shells/9x19.mdl"
att.Override_ShellScale = 1
att.Override_ShellSounds = ArcCW.PistolShellSoundsTable

att.Hook_SelectReloadAnimation = function(wep, anim)
    return anim .. "_9mm"
end

att.GivesFlags = {"cal_9mm"}
att.ActivateElements = {"mag_9mm"}
local path = ")weapons/arccw_ur/ak/9mm/"

local soundpath = ")weapons/arccw_ur/1911/fire-9-"

att.Hook_GetShootSound = function(wep, fsound)
    if fsound == wep.ShootSound or fsound == wep.FirstShootSoundSilenced then return {
        soundpath .. "01.ogg",
        soundpath .. "02.ogg",
        soundpath .. "03.ogg",
        soundpath .. "04.ogg",
        soundpath .. "05.ogg",
        soundpath .. "06.ogg",
     } end
     if fsound == wep.ShootSoundSilenced then return {
        path .. "fire-sup-01.ogg",
        path .. "fire-sup-02.ogg",
        path .. "fire-sup-03.ogg",
        path .. "fire-sup-04.ogg",
        path .. "fire-sup-05.ogg",
        path .. "fire-sup-06.ogg"
    } end
end

local tail = ")/arccw_uc/common/9x19/"

att.Hook_GetDistantShootSoundOutdoors = function(wep, distancesound)
    if wep:GetBuff_Override("Silencer") then
        -- fallback to script
    else
        return {
            tail .. "fire-dist-9x19-pistol-ext-01.ogg",
            tail .. "fire-dist-9x19-pistol-ext-02.ogg",
            tail .. "fire-dist-9x19-pistol-ext-03.ogg",
            tail .. "fire-dist-9x19-pistol-ext-04.ogg",
            tail .. "fire-dist-9x19-pistol-ext-05.ogg",
            tail .. "fire-dist-9x19-pistol-ext-06.ogg"
        }
    end
end

local slotinfo = {
    [6] = {"30-Round Mag", "30-Round Mag", Material("entities/att/ur_ak/magazines/9_30.png", "mips smooth")},
}
att.Hook_GetDefaultAttName = function(wep, slot)
    if slotinfo[slot] then
        return GetConVar("arccw_truenames"):GetBool() and slotinfo[slot][2] or slotinfo[slot][1]
    end
end
att.Hook_GetDefaultAttIcon = function(wep, slot)
    if slotinfo[slot] then
        return slotinfo[slot][3]
    end
end
--lua/arccw/shared/attachments/ur_ak_cover_truniun_rail.lua:
att.PrintName = "Trunnion Sight Mount"
att.Icon = Material("entities/att/ur_ak/dustcover_mount.png", "mips smooth")
att.Description = "Picatinny rail mounted on trunnion sights"
att.Slot = {"ur_ak_cover"}

att.Desc_Neutrals = {"uc.cosmetic"}
att.Desc_Cons = {"Obstructs ironsights, install any scope"
-- , "Only small scopes can be installed"    ?
}

att.ActivateElements = {"cover_trail"}
att.GivesFlags = {"cover_rail"}
att.ExcludeFlags = {"ak_barrelkrinkov","ak_norail"}

-- att.Ignore = true
--lua/arccw/shared/attachments/ur_ak_hg_type3.lua:
return gluapack()()
--lua/arccw/shared/attachments/ur_ak_stock_ak74m.lua:
att.PrintName = "AK Polymer Stock"
att.AbbrevName = "Polymer Stock"
if !GetConVar("arccw_truenames"):GetBool() then
    att.PrintName = "KF Polymer Stock"
end
att.Icon = Material("entities/att/ur_ak/stock/n.png", "mips smooth")
att.Description = [[Full side-folding stock. While extended, it functions similarly to a standard wood stock, albeit with less stability.
Folding the stock boosts mobility and recoil, though not as significantly as skeletal folding stocks.

Toggling this stock modifies performance accordingly.]]
att.AutoStats = true
att.Slot = {"ur_ak_stock"}

att.SortOrder = 1

att.ToggleLockDefault = true
att.ToggleSound = "arccw_uc/common/stockslide.ogg"
att.ExcludeFlags = {"mag_drum"}
att.ToggleStats = {
    {
        PrintName = "Extended",
        Mult_SightTime = 0.95,
        Mult_Sway = 1.2,
        
        ActivateElements = {"stock_ak74m"},
        AutoStats = true,
    },
    {
        PrintName = "Folded",
        Mult_SightTime = 0.85,
        Mult_DrawTime = 0.9,
        Mult_HolsterTime = 0.9,
        Mult_Recoil = 1.25,
        Mult_RecoilSide = 1.75,
        Mult_SightedSpeedMult = 1.05,
        Mult_ShootSpeedMult = 1.05,
        Add_BarrelLength = -9,
        Mult_Sway = 2.5,
        ActivateElements = {"stock_ak74m_folded"},
        AutoStats = true,
    }
}
--lua/arccw/shared/attachments/ur_ak_stock_aks.lua:
return gluapack()()
--lua/arccw/shared/attachments/ur_ak_stock_rpk.lua:
return gluapack()()
--lua/arccw/shared/attachments/ur_aw_barrel_short.lua:
att.PrintName = "AT 20\" Shortened Barrel"
att.AbbrevName = "20\" Shortened Barrel"
att.Icon = Material("entities/att/ur_aw/bar_short.png", "mips smooth")

if !GetConVar("arccw_truenames"):GetBool() then
    att.PrintName = "AP 20\" Shortened Barrel"
end

--att.Icon = Material("entities/att/acwatt_ud_mini14_barrel_long.png", "smooth mips")
att.SortOrder = 20
att.Description = "Custom-tooled \"close-quarters\" barrel that compromises long-range performance, but reduces forward weight significantly."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "ur_aw_barrel"

att.Mult_SightTime = 0.75
att.Mult_Sway = 0.5
att.Mult_HipDispersion = 0.5
att.Mult_SpeedMult = 1.05
att.Add_BarrelLength = -4

att.Mult_Range = 0.3
att.Mult_AccuracyMOA = 4
att.Mult_Recoil = 1.25

att.AutoStats = true
att.ActivateElements = {"barrel_short"}
--lua/arccw/shared/attachments/ur_aw_stock_none.lua:
return gluapack()()
--lua/arccw/shared/attachments/ur_deagle_barrel_marksman.lua:
return gluapack()()
--lua/arccw/shared/attachments/ur_deagle_caliber_410.lua:
return gluapack()()
--lua/arccw/shared/attachments/ur_g3_hg_slim.lua:
att.PrintName = "Slim Handguard"
att.Icon = Material("entities/att/ur_g3/hg_slim.png","smooth mips")
att.Description = "Alternative factory handguard influenced by older models. Lighter than the bulkier standard, but more difficult to brace." -- use mp5 slim hg stats --why didn't you copy them yourself
att.AutoStats = true

att.Slot = "ur_g3_handguard"

att.SortOrder = 5

att.ModelOffset = Vector(-21, -2.2, 4.3)
att.Model = "models/weapons/arccw/ur_g3_lhik_slim.mdl"
att.LHIK = true

att.Mult_Sway = .85
att.Mult_SightTime = .85
att.Mult_Recoil = 1.1
--lua/arccw/shared/attachments/ur_g3_mag_10.lua:
att.PrintName = "G3 10-Round Marksman Mag"
att.AbbrevName = "10-Round Marksman Mag"

if !GetConVar("arccw_truenames"):GetBool() then
    att.PrintName = "G58 10-Round Marksman Mag"
end

att.Icon = Material("entities/att/ur_g3/mag10.png","smooth mips")
att.Description = "Magazine with a very low capacity. The lighter load reduces the weapon's weight significantly."
att.Slot = {"ur_g3_mag"}
att.AutoStats = true

att.SortOrder = 14

att.HideIfBlocked = true

att.Override_ClipSize = 10

att.Mult_SightTime = 0.9
att.Mult_ReloadTime = 0.95 -- darsu: there was 0.8 but i changed because it looked pretty bad      please balance 
att.Mult_Sway = 0.7

att.Mult_SpeedMult = 1.025
att.Mult_ShootSpeedMult = 1.05

att.Mult_HipDispersion = 0.85

att.ExcludeFlags = {"cal_556"}

-- att.Hook_SelectReloadAnimation = function(wep, anim)
--     return anim .. "_10rnd"
-- end
--lua/arccw/shared/attachments/ur_g3_stock_collapsible.lua:
return gluapack()()
--lua/arccw/shared/attachments/ur_mp5_barrel_kurz.lua:
att.PrintName = "4.5\" Kurz Upper"

att.Icon = Material("entities/att/ur_mp5/upper_k.png", "smooth mips")
att.Description = "Machine pistol variant with a maximally compact barrel and a lightened bolt assembly for increased cyclic rate.\nMid-range accuracy is poor, and recoil is noticibly increased."
att.AutoStats = true

att.Slot = "ur_mp5_barrel"

att.SortOrder = 4.5

att.LHIK = true

att.ModelOffset = Vector(6.5, -0.5, -1)
att.Model = "models/weapons/arccw/atts/lhik_kurz.mdl"

att.Add_BarrelLength = -4
att.Mult_Sway = .5
att.Mult_SightTime = .75
att.Mult_RPM = 1.125

att.Mult_Recoil = 1.25
att.Mult_AccuracyMOA = 3
att.Mult_Range = .5

att.Mult_HipDispersion = 0.85

att.GivesFlags = {"mp5_kurz"}
att.Override_Trivia_Class = "Machine Pistol"

att.Hook_SelectReloadAnimation = function(wep, anim)
    return anim .. "_kurz"
end

att.Mult_PhysBulletMuzzleVelocity = 0.9375
--lua/arccw/shared/attachments/ur_mp5_stock_a3.lua:
return gluapack()()
--lua/arccw/shared/attachments/ur_mp5_stock_none.lua:
att.PrintName = "MP5A1 Buttcap"
att.AbbrevName = "Buttcap"

if !GetConVar("arccw_truenames"):GetBool() then
    att.PrintName = "PK5-1 Buttcap"
end

att.Icon = Material("entities/att/ur_mp5/stock_cap.png", "smooth mips")
att.Description = "Remove your stock. Who needs it, anyway? Not the Germans, that's for sure."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "ur_mp5_stock"

att.AutoStats = true
att.Free = true
att.SortOrder = -1

att.Mult_Recoil = 2
att.Mult_RecoilSide = 1.25
att.Mult_Sway = 3

att.Mult_SightTime = 0.8
att.Mult_SpeedMult = 1.1
att.Mult_SightedSpeedMult = 1.25
att.Mult_ShootSpeedMult = 1.2

att.Mult_DrawTime = 0.6
att.Mult_HolsterTime = 0.6
att.Add_BarrelLength = -12

att.ActivateElements = {"ur_mp5_stock_remove"}
--lua/arccw/shared/attachments/ur_mp5_ub_classic.lua:
att.PrintName = "Slim Handguard"

att.Icon = Material("entities/att/ur_mp5/hg_slim.png", "smooth mips")
att.Description = "Early rounded handguard, lighter than the current iteration but more difficult to brace."
att.AutoStats = true

att.Slot = "ur_mp5_hg"

att.SortOrder = 999

att.Mult_Sway = .75
att.Mult_SightTime = .95
att.Mult_Recoil = 1.15

att.ActivateElements = {"ur_mp5_ub_classic"}
att.ExcludeFlags = {"barrel_sd","mp5_kurz"}
--lua/arccw/shared/attachments/ur_mp5_ub_kurzgrip.lua:
att.PrintName = "VFG-K Handguard"

att.Icon = Material("entities/att/ur_mp5/hg_k.png", "smooth mips")
att.Description = "The iconic handguard for the Kurz machine pistol variant, featuring a stubby foregrip and handstop that make the shortened SMG much more comfortable and controllable."
att.Desc_Cons = {
    "uc.noubs"
}
att.AutoStats = true

att.Slot = "ur_mp5_hg"

att.LHIK = true

att.ModelOffset = Vector(-1.3, 0, -0)
att.Model = "models/weapons/arccw/atts/ur_kurzlhik.mdl" // stole this pose from the tall troy grip lol!!!
att.Override_HoldtypeActive = "smg"

att.SortOrder = 2

att.Mult_Sway = .75
att.Mult_SightTime = .95
att.Mult_Recoil = .85

att.ActivateElements = {"ur_mp5_ub_kurzgrip"}
att.GivesFlags = {"mp5_badhg"}
att.RequireFlags = {"mp5_kurz"}
--lua/arccw/shared/attachments/ur_mp5_ub_surefire.lua:
att.PrintName = "MP5 Surefire Handguard"
att.AbbrevName = "Surefire Handguard"

if !GetConVar("arccw_truenames"):GetBool() then
    att.PrintName = "PK5 Surefire Handguard"
end

att.Icon = Material("entities/att/ur_mp5/hg_flash.png", "smooth mips")
att.Description = "Alternative handguard with an integrated flashlight and a wider grip."
att.Desc_Pros = {
    "uc.light"
}
att.Desc_Cons = {
    "con.light",
    "uc.noubs"
}
att.AutoStats = true

att.Slot = {"ur_mp5_hg","ur_g3_handguard"}
att.SortOrder = 998

att.Model = "models/weapons/arccw/atts/ud_flashlight_1.mdl"
att.ModelOffset = Vector(0,0,.1)
att.OffsetAng = Angle(0,0,180)
att.ModelScale = Vector(.01,.01,.01) -- THIS IS TEMPORARY UNTIL THE MODEL GETS THE BONE WE NEED, DO NOT RELEASE WITH A TINY FLASHLIGHT INSIDE THE MODEL

att.Flashlight = false
att.FlashlightFOV = 50
att.FlashlightFarZ = 1024 -- how far it goes
att.FlashlightNearZ = 1 -- how far away it starts
att.FlashlightAttenuationType = ArcCW.FLASH_ATT_LINEAR -- LINEAR, CONSTANT, QUADRATIC are available
att.FlashlightColor = Color(255, 242, 229)
att.FlashlightTexture = "effects/flashlight001"
att.FlashlightBrightness = 3
att.FlashlightBone = "light"

att.ToggleStats = {
    {
        PrintName = "On",
        Flashlight = true
    },
    {
        PrintName = "Off",
        Flashlight = false,
    }
}

att.Mult_SightTime = 0.9

att.GivesFlags = {"hg_surefire","mp5_badhg"} -- badhg flag is temporary until underbarrel rail model is implemented (it disables use of underbarrel atts)
att.ExcludeFlags = {"barrel_sd","mp5_kurz","g3_not8"}
att.HideIfBlocked = true
--addons/[binbon]arccw_modify/lua/arccw/client/cl_darkrp_performance.lua:
-- DarkRP Performance Configuration
-- This file contains recommendations for performance optimization in DarkRP servers

-- Configuration defaults for DarkRP
local defaultConfig = {
    -- Visual settings (set these to minimize visual effects)
    ["arccw_shelleffects"] = "0",        -- Disable shell ejection effects
    ["arccw_blur"] = "0",                -- Disable customize menu blur
    ["arccw_blur_toytown"] = "0",        -- Disable aiming blur
    ["arccw_muzzleeffects"] = "0",       -- Disable world muzzle effects
    ["arccw_fastmuzzles"] = "1",         -- Use low-performance muzzle effects
    ["arccw_fasttracers"] = "1",         -- Use low-performance tracers
    ["arccw_shelltime"] = "0",           -- Set shell lifetime to 0 seconds
    ["arccw_visibility"] = "1000",       -- Limit attachment visibility range
    ["arccw_shake"] = "0",               -- Disable screen shake
    ["arccw_shakevm"] = "0",             -- Disable viewmodel shake
    ["arccw_cheapscopes"] = "0",         -- Enable cheap scopes for better performance
    
    -- Gameplay settings
    ["arccw_mult_movespeed"] = "1",      -- Normal movement speed
    ["arccw_mult_reloadtime"] = "1",     -- Normal reload time
    
    -- Animation settings
    ["arccw_vm_coolsway"] = "0",         -- Disable custom sway
    ["arccw_vm_coolview"] = "0",         -- Disable custom camera movement
}

hook.Add("InitPostEntity", "ArcCW_DarkRP_PerformanceSetup", function()
    print("ArcCW DarkRP Performance: Setting recommended performance configuration")
    
    -- Apply default settings
    for cvar, value in pairs(defaultConfig) do
        RunConsoleCommand(cvar, value)
    end
    
    -- Add help to console
    print("ArcCW DarkRP Performance: Configuration applied for optimal DarkRP performance.")
    print("Use 'arccw_darkrp_performance_help' in console for more information.")
end)

concommand.Add("arccw_darkrp_performance_help", function()
    print("ArcCW DarkRP Performance Optimization Guide")
    print("-------------------------------------------")
    print("The following settings have been applied for optimal performance:")
    
    for cvar, value in pairs(defaultConfig) do
        print(string.format("  %-25s = %s", cvar, value))
    end
    
    print("\nYou can further optimize by:")
    print("1. Disabling custom viewmodels: arccw_vm_coolview 0")
    print("2. Reducing or disabling tracers: arccw_fasttracers 1")
    print("3. Reducing the visibility range of attachments: arccw_visibility 500")
end)

--addons/[binbon]arccw_modify/lua/arccw/client/cl_menus.lua:
return gluapack()()
--addons/[binbon]arccw_modify/lua/arccw/client/cl_menus.lua:
--[[
    Panel table doc:
    id (any number) = data:
    type
    type args

    types:
    h - header                        text
    c - control help                  text
    b - checkbox                      text var
    i - integer slider                text var min max
    f - float slider (2 nums after .) text var min max
    m - color mixer                   text r g b a
    p - press or button               text func
    t - textbox                       text string
    o - combo box                     text var choices (key - cvar, value - text)
    d - binder                        text var
    (you can add custom types in ArcCW.GeneratePanelElements's AddControl table)

    Generate elements via ArcCW.GeneratePanelElements:
    panel, panel table with data

    Add menu generation to ArcCW.ClientMenus:
    name = data:
    text - header text
    func - generator function
]]

local BulletPanel = {
    { type = "h", text = "#arccw.adminonly" },
    { type = "c", text = "#arccw.bullet_help" },
    { type = "b", text = "#arccw.cvar.bullet_enable", var = "arccw_bullet_enable", sv = true },
    { type = "b", text = "#arccw.cvar.enable_penetration", var = "arccw_enable_penetration", sv = true },
    { type = "b", text = "#arccw.cvar.enable_ricochet", var = "arccw_enable_ricochet", sv = true },
    { type = "f", text = "#arccw.cvar.bullet_velocity", var = "arccw_bullet_velocity", min = 0, max = 3, sv = true },
    { type = "f", text = "#arccw.cvar.bullet_gravity", var = "arccw_bullet_gravity", min = 0, max = 1200, sv = true },
    { type = "f", text = "#arccw.cvar.bullet_drag", var = "arccw_bullet_drag", min = 0, max = 10, sv = true },
    { type = "f", text = "#arccw.cvar.bullet_lifetime", var = "arccw_bullet_lifetime", min = 1, max = 20, sv = true},
}

local ClientPanel = {
    { type = "h", text = "#arccw.clientcfg" },
    { type = "b", text = "#arccw.cvar.automaticreload", var = "arccw_automaticreload" },
    { type = "c", text = "#arccw.cvar.automaticreload.desc" },
    { type = "f", text = "#arccw.cvar.adjustsensthreshold", var = "arccw_adjustsensthreshold", min = 0, max = 50, sv = true },
    { type = "c", text = "#arccw.cvar.adjustsensthreshold.desc" },
    { type = "b", text = "#arccw.cvar.toggleads", var = "arccw_toggleads" },
    { type = "b", text = "#arccw.cvar.autosave", var = "arccw_autosave" },
    { type = "c", text = "#arccw.cvar.autosave.desc" },
    --{ type = "b", text = "#arccw.cvar.embracetradition", var = "arccw_hud_embracetradition" },
    --{ type = "c", text = "#arccw.cvar.embracetradition.desc" },
    { type = "b", text = "#arccw.cvar.glare", var = "arccw_glare" },
    { type = "c", text = "#arccw.cvar.glare.desc" },
    { type = "b", text = "#arccw.cvar.shake", var = "arccw_shake" },
    { type = "b", text = "#arccw.cvar.shakevm", var = "arccw_shakevm" },
    { type = "c", text = "#arccw.cvar.shake_info" },
    { type = "b", text = "#arccw.cvar.aimassist", var = "arccw_aimassist_cl" },
    { type = "c", text = "#arccw.cvar.aimassist_cl.desc" },
    -- { type = "b", text = "#arccw.cvar.2d3d", var = "arccw_2d3d" },
    { type = "o", text = "#arccw.cvar.2d3d", var = "arccw_2d3d",
            choices = {[0] = "#arccw.combobox.disabled", [1] = "#arccw.cvar.2d3d.1", [2] = "#arccw.cvar.2d3d.2"}},
    { type = "c", text = "#arccw.cvar.2d3d_info" },
    { type = "t", text = "#arccw.cvar.language", var = "arccw_language"  },
    { type = "c", text = "#arccw.cvar.language_info" },
    { type = "b", text = "#arccw.cvar.ammonames", var = "arccw_ammonames" },
    { type = "c", text = "#arccw.cvar.ammonames.desc" },
    { type = "b", text = "#arccw.cvar.noinspect", var = "arccw_noinspect" },
}

local PerformancePanel = {
    --{ type = "h", text = "#arccw.clientcfg" },
    { type = "h", text = "#arccw.performance" },
    { type = "b", text = "#arccw.cvar.cheapscopes", var = "arccw_cheapscopes" },
    { type = "c", text = "#arccw.cvar.cheapscopes.desc" },
    -- { type = "b", text = "#arccw.cvar.flatscopes", var = "arccw_flatscopes" },
    -- { type = "c", text = "#arccw.cvar.flatscopes.desc" },
    { type = "b", text = "#arccw.cvar.muzzleeffects", var = "arccw_muzzleeffects" },
    { type = "b", text = "#arccw.cvar.fastmuzzles", var = "arccw_fastmuzzles" },
    { type = "b", text = "#arccw.cvar.fasttracers", var = "arccw_fasttracers" },
    { type = "b", text = "#arccw.cvar.shelleffects", var = "arccw_shelleffects" },
    { type = "b", text = "#arccw.cvar.att_showothers", var = "arccw_att_showothers" },
    { type = "b", text = "#arccw.cvar.att_showground", var = "arccw_att_showground" },
    { type = "i", text = "#arccw.cvar.visibility", var = "arccw_visibility", min = -1, max = 32000},
    { type = "c", text = "#arccw.cvar.visibility.desc" },
    { type = "b", text = "#arccw.cvar.blur", var = "arccw_blur" },
    { type = "b", text = "#arccw.cvar.blur_toytown", var = "arccw_blur_toytown" },
    { type = "b", text = "#arccw.cvar.bullet_imaginary", var = "arccw_bullet_imaginary" },
    { type = "c", text = "#arccw.cvar.bullet_imaginary.desc" },
    { type = "f", text = "#arccw.cvar.shelltime", var = "arccw_shelltime", min = 0, max = 180 },
}

local ViewmodelPanel = {
    { type = "b", text = "#arccw.cvar.vm_coolsway", var = "arccw_vm_coolsway" },
    { type = "b", text = "#arccw.cvar.vm_coolview", var = "arccw_vm_coolview" },
    { type = "h", text = "" },
    { type = "c", text = "#arccw.cvar.vm_offsetwarn" },
    { type = "f", text = "#arccw.cvar.vm_fov", var = "arccw_vm_fov",         min = -15, max = 15 },
    { type = "f", text = "#arccw.cvar.vm_right", var = "arccw_vm_right",     min = -5, max = 5 },
    { type = "f", text = "#arccw.cvar.vm_forward", var = "arccw_vm_forward", min = -5, max = 5 },
    { type = "f", text = "#arccw.cvar.vm_up", var = "arccw_vm_up",           min = -5, max = 5 },
    { type = "f", text = "#arccw.cvar.vm_pitch", var = "arccw_vm_pitch",     min = -15, max = 15 },
    { type = "f", text = "#arccw.cvar.vm_yaw", var = "arccw_vm_yaw",         min = -15, max = 15 },
    { type = "f", text = "#arccw.cvar.vm_roll", var = "arccw_vm_roll",       min = -15, max = 15 },
    { type = "c", text = "" },
    { type = "c", text = "#arccw.cvar.vm_swaywarn" },
    { type = "f", text = "#arccw.cvar.vm_look_xmult", var = "arccw_vm_look_xmult", min = -10, max = 10 },
    { type = "f", text = "#arccw.cvar.vm_look_ymult", var = "arccw_vm_look_ymult", min = -10, max = 10 },
    { type = "f", text = "#arccw.cvar.vm_sway_xmult", var = "arccw_vm_sway_xmult", min = -5, max = 5 },
    { type = "f", text = "#arccw.cvar.vm_sway_ymult", var = "arccw_vm_sway_ymult", min = -5, max = 5 },
    { type = "f", text = "#arccw.cvar.vm_sway_zmult", var = "arccw_vm_sway_zmult", min = -5, max = 5 },
    { type = "f", text = "#arccw.cvar.vm_sway_speedmult", var = "arccw_vm_sway_speedmult", min = 0, max = 2 },
    { type = "h", text = "" },
    { type = "c", text = "#arccw.cvar.vm_viewwarn" },
    { type = "f", text = "#arccw.cvar.vm_coolviewmult", var = "arccw_vm_coolview_mult", min = -5, max = 5 },
    { type = "b", text = "#arccw.cvar.vm_nearwall", var = "arccw_vm_nearwall" },
}

local HudPanel = {
    { type = "h", text = "#arccw.clientcfg" },
    { type = "h", text = "#arccw.hud_svwarning" },
    { type = "b", text = "#arccw.cvar.hud_showhealth", var = "arccw_hud_showhealth" },
    { type = "c", text = "#arccw.cvar.hud_showhealth.desc" },
    { type = "b", text = "#arccw.cvar.hud_showammo", var = "arccw_hud_showammo" },
    { type = "c", text = "#arccw.cvar.hud_showammo.desc" },
    { type = "i", text = "#arccw.cvar.hud_3dfun_decay", var = "arccw_hud_3dfun_decaytime", min = 0, max = 5 },
    { type = "c", text = "#arccw.cvar.hud_3dfun_decay.desc" },
    { type = "b", text = "#arccw.cvar.hud_minimal", var = "arccw_hud_minimal" },
    { type = "c", text = "#arccw.cvar.hud_minimal.desc" },
    { type = "b", text = "#arccw.cvar.hud_forceshow", var = "arccw_hud_forceshow" },
    { type = "c", text = "#arccw.cvar.hud_forceshow.desc" },
    { type = "b", text = "#arccw.cvar.attinv_closeonhurt", var = "arccw_attinv_closeonhurt" },
    { type = "f", text = "#arccw.cvar.hudpos_deadzone_x", var = "arccw_hud_deadzone_x", min = 0, max = 0.5 },
    { type = "f", text = "#arccw.cvar.hudpos_deadzone_y", var = "arccw_hud_deadzone_y", min = 0, max = 0.5 },
    { type = "c", text = "#arccw.cvar.hudpos_deadzone.desc" },
    { type = "f", text = "#arccw.cvar.hudpos_size", var = "arccw_hud_size", min = 0.67, max = 1.5 },
    { type = "c", text = "#arccw.cvar.hudpos_size.desc" },
    { type = "t", text = "#arccw.cvar.font", var = "arccw_font"  },
    { type = "c", text = "#arccw.cvar.font_info" },

    { type = "b", text = "#arccw.cvar.attinv_sound", var = "arccw_cust_sounds" },
    { type = "c", text = "#arccw.cvar.attinv_sound.desc" },
    { type = "b", text = "#arccw.cvar.attinv_hideunowned", var = "arccw_attinv_hideunowned" },
    { type = "b", text = "#arccw.cvar.attinv_darkunowned", var = "arccw_attinv_darkunowned" },
    { type = "b", text = "#arccw.cvar.attinv_onlyinspect", var = "arccw_attinv_onlyinspect" },
    { type = "b", text = "#arccw.cvar.attinv_simpleproscons", var = "arccw_attinv_simpleproscons" },
    --{ type = "b", text = "#arccw.cvar.attinv_gamemodebuttons", var = "arccw_attinv_gamemodebuttons" },
    --{ type = "c", text = "#arccw.cvar.attinv_gamemodebuttons.desc" },

    { type = "h", text = "#arccw.ammohud" },
    { type = "b", text = "#arccw.cvar.hud_3dfun", var = "arccw_hud_3dfun" },
    { type = "c", text = "#arccw.cvar.hud_3dfun.desc" },
    { type = "b", text = "#arccw.cvar.hud_3dfun_lite", var = "arccw_hud_3dfun_lite" },
    { type = "c", text = "#arccw.cvar.hud_3dfun_lite.desc" },
    { type = "b", text = "#arccw.cvar.hud_fcgbars", var = "arccw_hud_fcgbars" },
    { type = "b", text = "#arccw.cvar.hud_fcgabbrev", var = "arccw_hud_fcgabbrev" },
    { type = "b", text = "#arccw.cvar.hud_3dfun_ammotype", var = "arccw_hud_3dfun_ammotype" },
    { type = "c", text = "#arccw.cvar.hud_3dfun_ammotype.desc" },

    { type = "f", text = "#arccw.cvar.hud_3dfun_right", var = "arccw_hud_3dfun_right", min = -5, max = 5 },
    { type = "f", text = "#arccw.cvar.hud_3dfun_up", var = "arccw_hud_3dfun_up", min = -5, max = 5 },
    { type = "f", text = "#arccw.cvar.hud_3dfun_forward", var = "arccw_hud_3dfun_forward", min = -5, max = 5 },
}

local CrosshairPanel = {
    { type = "h", text = "#arccw.clientcfg" },
    { type = "b", text = "#arccw.cvar.crosshair", var = "arccw_crosshair" },
    { type = "f", text = "#arccw.cvar.crosshair_length", var = "arccw_crosshair_length", min = 0, max = 10 },
    { type = "f", text = "#arccw.cvar.crosshair_thickness", var = "arccw_crosshair_thickness", min = 0, max = 2 },
    { type = "f", text = "#arccw.cvar.crosshair_gap", var = "arccw_crosshair_gap", min = 0, max = 2 },
    { type = "b", text = "#arccw.cvar.crosshair_dot", var = "arccw_crosshair_dot" },
    { type = "b", text = "#arccw.cvar.crosshair_shotgun", var = "arccw_crosshair_shotgun" },
    { type = "b", text = "#arccw.cvar.crosshair_equip", var = "arccw_crosshair_equip" },
    { type = "b", text = "#arccw.cvar.crosshair_static", var = "arccw_crosshair_static" },
    { type = "b", text = "#arccw.cvar.crosshair_trueaim", var = "arccw_crosshair_trueaim" },
    { type = "b", text = "#arccw.cvar.crosshair_clump", var = "arccw_crosshair_clump" },
    { type = "b", text = "#arccw.cvar.crosshair_clump_outline", var = "arccw_crosshair_clump_outline" },
    { type = "b", text = "#arccw.cvar.crosshair_clump_always", var = "arccw_crosshair_clump_always" },
    { type = "b", text = "#arccw.cvar.crosshair_aa", var = "arccw_crosshair_aa" },
    { type = "b", text = "#arccw.cvar.crosshair_tilt", var = "arccw_crosshair_tilt" },
    { type = "b", text = "#arccw.cvar.crosshair_prong_top", var = "arccw_crosshair_prong_top" },
    { type = "b", text = "#arccw.cvar.crosshair_prong_left", var = "arccw_crosshair_prong_left" },
    { type = "b", text = "#arccw.cvar.crosshair_prong_right", var = "arccw_crosshair_prong_right" },
    { type = "b", text = "#arccw.cvar.crosshair_prong_bottom", var = "arccw_crosshair_prong_bottom" },
    { type = "m", text = "#arccw.cvar.crosshair_clr", r = "arccw_crosshair_clr_r", g = "arccw_crosshair_clr_g", b = "arccw_crosshair_clr_b", a = "arccw_crosshair_clr_a" },
    { type = "f", text = "#arccw.cvar.crosshair_outline", var = "arccw_crosshair_outline", min = 0, max = 4 },
    { type = "m", text = "#arccw.cvar.crosshair_outline_clr", r = "arccw_crosshair_outline_r", g = "arccw_crosshair_outline_g", b = "arccw_crosshair_outline_b", a = "arccw_crosshair_outline_a" },
}

local BindsPanel = {
    { type = "h", text = "#arccw.bindhelp" },
    { type = "b", text = "#arccw.cvar.nohl2flash", var = "arccw_nohl2flash" },
    { type = "b", text = "#arccw.cvar.altsafety", var = "arccw_altsafety" },
    { type = "b", text = "#arccw.cvar.altbindsonly", var = "arccw_altbindsonly" },
    { type = "c", text = "#arccw.cvar.altbindsonly.desc" },
    { type = "d", text = "#arccw.bind.firemode", var = "arccw_firemode" },
    { type = "d", text = "#arccw.bind.zoom_in", var = "arccw_zoom_in" },
    { type = "d", text = "#arccw.bind.zoom_out", var = "arccw_zoom_out" },
    { type = "d", text = "#arccw.bind.toggle_inv", var = "arccw_toggle_inv" },
    { type = "d", text = "#arccw.bind.switch_scope", var = "arccw_switch_scope" },
    { type = "d", text = "#arccw.bind.toggle_ubgl", var = "arccw_toggle_ubgl" },
    { type = "d", text = "#arccw.bind.melee", var = "arccw_melee" },
    { type = "d", text = "#arccw.bind.toggle_att", var = "arccw_toggle_att" },
}

local ServerPanel = {
    { type = "h", text = "#arccw.adminonly" },
    { type = "o", text = "#arccw.cvar.enable_customization", var = "arccw_enable_customization", sv = true,
            choices = {[-1] = "#arccw.cvar.enable_customization.-1", [0] = "#arccw.cvar.enable_customization.0", [1] = "#arccw.cvar.enable_customization.1"}},
    { type = "c", text = "#arccw.cvar.enable_customization.desc" },
    { type = "b", text = "#arccw.cvar.truenames", var = "arccw_truenames", sv = true },
    { type = "b", text = "#arccw.cvar.equipmentammo", var = "arccw_equipmentammo", sv = true },
    { type = "c", text = "#arccw.cvar.equipmentammo.desc" },
    { type = "b", text = "#arccw.cvar.equipmentsingleton", var = "arccw_equipmentsingleton", sv = true },
    { type = "c", text = "#arccw.cvar.equipmentsingleton.desc" },
    { type = "i", text = "#arccw.cvar.equipmenttime", var = "arccw_equipmenttime", min = 15, max = 3600, sv = true },
    { type = "b", text = "#arccw.cvar.throwinertia", var = "arccw_throwinertia", sv = true },
    { type = "o", text = "#arccw.cvar.freeaim", var = "arccw_freeaim", sv = true,
            choices = {[0] = "#arccw.combobox.disabled", [1] = "#arccw.cvar.freeaim.1", [2] = "#arccw.cvar.freeaim.2"}},
    { type = "b", text = "#arccw.cvar.override_crosshair_off", var = "arccw_override_crosshair_off", sv = true },
    { type = "b", text = "#arccw.cvar.override_hud_off", var = "arccw_override_hud_off", sv = true },
    { type = "b", text = "#arccw.cvar.override_barrellength", var = "arccw_override_nearwall", sv = true },
    { type = "b", text = "#arccw.cvar.doorbust", var = "arccw_doorbust", sv = true },
    { type = "b", text = "#arccw.cvar.override_lunge_off", var = "arccw_override_lunge_off", sv = true },
    { type = "c", text = "#arccw.cvar.override_lunge_off.desc" },
    --[[]
    { type = "b", text = "#arccw.cvar.limityear_enable", var = "arccw_limityear_enable", sv = true },
    { type = "i", text = "#arccw.cvar.limityear", var = "arccw_limityear", min = 1800, max = 2100, sv = true },
    { type = "c", text = "#arccw.cvar.limityear.desc"},
    ]]
    { type = "b", text = "#arccw.cvar.bodydamagecancel", var = "arccw_bodydamagemult_cancel", sv = true},
    { type = "c", text = "#arccw.cvar.bodydamagecancel.desc"},
    { type = "b", text = "#arccw.cvar.desync", var = "arccw_desync", sv = true },
    { type = "c", text = "#arccw.cvar.desync.desc" },
    { type = "f", text = "#arccw.cvar.weakensounds", var = "arccw_weakensounds", min = -20, max = 30, sv = true},
    { type = "c", text = "#arccw.cvar.weakensounds.desc" },
    { type = "b", text = "#arccw.cvar.reloadincust", var = "arccw_reloadincust", sv = true },
    { type = "c", text = "#arccw.cvar.reloadincust.desc" },
    { type = "b", text = "#arccw.cvar.aimassist", var = "arccw_aimassist", sv = true },
    { type = "c", text = "#arccw.cvar.aimassist.desc" },
    { type = "b", text = "#arccw.cvar.aimassist_head", var = "arccw_aimassist_head", sv = true },
    { type = "f", text = "#arccw.cvar.aimassist_cone", var = "arccw_aimassist_cone", min = 0, max = 360, sv = true},
    { type = "f", text = "#arccw.cvar.aimassist_distance", var = "arccw_aimassist_distance", min = 128, max = 4096, sv = true},
    { type = "f", text = "#arccw.cvar.aimassist_intensity", var = "arccw_aimassist_intensity", min = 0, max = 10, sv = true},
}

local AmmoPanel = {
    { type = "h", text = "#arccw.adminonly" },
    { type = "o", text = "#arccw.cvar.ammo_detonationmode", var = "arccw_ammo_detonationmode", sv = true,
            choices = {[-1] = "#arccw.cvar.ammo_detonationmode.-1", [0] = "#arccw.cvar.ammo_detonationmode.0", [1] = "#arccw.cvar.ammo_detonationmode.1", [2] = "#arccw.cvar.ammo_detonationmode.2"}},
    { type = "b", text = "#arccw.cvar.ammo_autopickup", var = "arccw_ammo_autopickup", sv = true },
    { type = "b", text = "#arccw.cvar.ammo_largetrigger", var = "arccw_ammo_largetrigger", sv = true },
    { type = "f", text = "#arccw.cvar.ammo_rareskin", var = "arccw_ammo_rareskin", min = 0, max = 1, sv = true },
    { type = "b", text = "#arccw.cvar.ammo_chaindet", var = "arccw_ammo_chaindet", sv = true },
    { type = "b", text = "#arccw.cvar.ammo_replace", var = "arccw_ammo_replace", sv = true },
    { type = "f", text = "#arccw.cvar.mult_ammohealth", var = "arccw_mult_ammohealth", min = -1, max = 10, sv = true },
    { type = "f", text = "#arccw.cvar.mult_ammoamount", var = "arccw_mult_ammoamount", min = 0.1, max = 10, sv = true },
}

local AttsPanel = {
    { type = "h", text = "#arccw.adminonly" },
    { type = "h", text = "#arccw.attdesc1" },
    { type = "h", text = "#arccw.attdesc2" },
    { type = "b", text = "#arccw.cvar.attinv_free", var = "arccw_attinv_free", sv = true },
    { type = "b", text = "#arccw.cvar.attinv_lockmode", var = "arccw_attinv_lockmode", sv = true },
    { type = "o", text = "#arccw.cvar.attinv_loseondie", var = "arccw_attinv_loseondie", sv = true,
            choices = {[0] = "#arccw.combobox.disabled", [1] = "#arccw.cvar.attinv_loseondie.1", [2] = "#arccw.cvar.attinv_loseondie.2"}},
    { type = "i", text = "#arccw.cvar.attinv_giveonspawn", var = "arccw_attinv_giveonspawn", min = 0, max = 100, sv = true },
    { type = "i", text = "#arccw.cvar.atts_pickx", var = "arccw_atts_pickx", min = 0, max = 10, sv = true },
    { type = "c", text = "#arccw.cvar.atts_pickx.desc", sv = true },
    { type = "b", text = "#arccw.cvar.enable_dropping", var = "arccw_enable_dropping", sv = true },
    { type = "b", text = "#arccw.cvar.atts_spawnrand", var = "arccw_atts_spawnrand", sv = true },
    { type = "b", text = "#arccw.cvar.atts_ubglautoload", var = "arccw_atts_ubglautoload", sv = true },
    { type = "p", text = "#arccw.blacklist", func = function() RunConsoleCommand("arccw_blacklist") end },
}

local DevPanel = {
    { type = "h", text = "#arccw.adminonly" },
    { type = "h", text = "#arccw.dev_info1" },
    { type = "h", text = "#arccw.dev_info2" },
    { type = "b", text = "#arccw.cvar.dev_reloadonadmincleanup", var = "arccw_reloadatts_mapcleanup", sv = true },
    { type = "c", text = "#arccw.cvar.dev_reloadonadmincleanup.desc" },
    { type = "b", text = "#arccw.cvar.dev_registerentities", var = "arccw_reloadatts_registerentities", sv = true },
    { type = "c", text = "#arccw.cvar.dev_registerentities.desc" },
    { type = "b", text = "#arccw.cvar.dev_showignored", var = "arccw_reloadatts_showignored", sv = true },
    { type = "c", text = "#arccw.cvar.dev_showignored.desc" },
    { type = "b", text = "#arccw.cvar.dev_debug", var = "arccw_dev_debug", sv = true },
    { type = "c", text = "#arccw.cvar.dev_debug.desc" },
    --{ type = "b", text = "Customization Menu Overhaul beta", var = "arccw_dev_cust2beta", sv = true },
    --{ type = "c", text = "Enable the customization menu overhaul. Remove this convar when we done doe" },
    { type = "b", text = "#arccw.cvar.dev_alwaysready", var = "arccw_dev_alwaysready", sv = true },
    { type = "c", text = "#arccw.cvar.dev_alwaysready.desc" },
    { type = "b", text = "#arccw.cvar.dev_benchgun", var = "arccw_dev_benchgun", sv = true },
    { type = "c", text = "#arccw.cvar.dev_benchgun.desc" },
    { type = "t", text = "#arccw.cvar.dev_benchgun_custom", var = "arccw_dev_benchgun_custom", sv = true },
    { type = "c", text = "#arccw.cvar.dev_benchgun_custom.desc" },
    { type = "o", text = "Firing Info", var = "arccw_dev_shootinfo", sv = true,
            choices = {[0] = "#arccw.combobox.disabled", [1] = "1 - Damage", [2] = "2 - Penetration", [3] = "3 - Dispersion"}},
    { type = "c", text = "Show information when shooting the weapon. Requires 'developer' ConVar to be enabled." },
    { type = "p", text = "#arccw.cvar.dev_reloadatts", func = function() RunConsoleCommand("arccw_reloadatts") end },
    { type = "h", text = "#arccw.cvar.dev_reloadatts.desc" },
    { type = "p", text = "#arccw.cvar.dev_reloadlangs", func = function() RunConsoleCommand("arccw_reloadlangs") end },
    { type = "h", text = "#arccw.cvar.dev_reloadlangs.desc" },
    { type = "p", text = "#arccw.cvar.dev_spawnmenureload", func = function() RunConsoleCommand("spawnmenu_reload") end },
    { type = "h", text = "#arccw.cvar.dev_spawnmenureload.desc" },
}


local ScopesPanel = {
    { type = "h", text = "#arccw.clientcfg" },

    { type = "b", text = "#arccw.cvar.cheapscopes", var = "arccw_cheapscopes" },
    { type = "c", text = "#arccw.cvar.cheapscopesv2.desc" },
    { type = "f", text = "#arccw.cvar.cheapscopesv2_ratio", var = "arccw_cheapscopesv2_ratio", min = 0, max = 1},
    { type = "c", text = "#arccw.cvar.cheapscopesv2_ratio.desc" },

    { type = "b", text = "#arccw.cvar.drawbarrel", var = "arccw_drawbarrel" },
    { type = "f", text = "#arccw.cvar.vm_addads", var = "arccw_vm_add_ads", min = -0.5, max = 9 },
    { type = "b", text = "#arccw.cvar.scopepp", var = "arccw_scopepp" },
    { type = "b", text = "#arccw.cvar.thermalpp", var = "arccw_thermalpp" },
    { type = "b", text = "#arccw.cvar.scopepp_refract", var = "arccw_scopepp_refract" },
    { type = "f", text = "#arccw.cvar.scopepp_refract_ratio", var = "arccw_scopepp_refract_ratio", min = -1, max = 2 },

    { type = "m", text = "#arccw.cvar.scope_clr", r = "arccw_scope_r", g = "arccw_scope_g", b = "arccw_scope_b" },
}

local MultsPanel = {
    { type = "h", text = "#arccw.adminonly" },
    { type = "f", text = "#arccw.cvar.mult_damage",          var = "arccw_mult_damage", min = 0, max = 10, sv = true },
    { type = "f", text = "#arccw.cvar.mult_npcdamage",       var = "arccw_mult_npcdamage", min = 0, max = 5, sv = true },
    { type = "f", text = "#arccw.cvar.mult_range",           var = "arccw_mult_range", min = 0.1, max = 5, sv = true },
    { type = "f", text = "#arccw.cvar.mult_recoil",          var = "arccw_mult_recoil", min = 0, max = 5, sv = true },
    { type = "f", text = "#arccw.cvar.mult_penetration",     var = "arccw_mult_penetration", min = 0, max = 5, sv = true },
    { type = "f", text = "#arccw.cvar.mult_hipfire",         var = "arccw_mult_hipfire", min = 0, max = 3, sv = true },
    { type = "f", text = "#arccw.cvar.mult_accuracy",        var = "arccw_mult_accuracy", min = 0, max = 3, sv = true },
    { type = "f", text = "#arccw.cvar.mult_movedisp",        var = "arccw_mult_movedisp", min = 0, max = 3, sv = true },
    { type = "f", text = "#arccw.cvar.mult_reloadtime",      var = "arccw_mult_reloadtime", min = 0.2, max = 3, sv = true },
    { type = "f", text = "#arccw.cvar.mult_sighttime",       var = "arccw_mult_sighttime", min = 0.25, max = 3, sv = true },
    { type = "i", text = "#arccw.cvar.mult_defaultammo",     var = "arccw_mult_defaultammo", min = 0, max = 10, sv = true },
    { type = "f", text = "#arccw.cvar.mult_attchance",       var = "arccw_mult_attchance", min = 0, max = 10, sv = true },
    { type = "f", text = "#arccw.cvar.mult_heat",            var = "arccw_mult_heat", min = 0, max = 3, sv = true },
    { type = "f", text = "#arccw.cvar.mult_crouchdisp",      var = "arccw_mult_crouchdisp", min = 0, max = 1, sv = true },
    { type = "f", text = "#arccw.cvar.mult_crouchrecoil",    var = "arccw_mult_crouchrecoil", min = 0, max = 1, sv = true },
    { type = "f", text = "#arccw.cvar.mult_movespeed",       var = "arccw_mult_movespeed", min = 0, max = 1, sv = true },
    { type = "f", text = "#arccw.cvar.mult_movespeedads",    var = "arccw_mult_movespeedads", min = 0, max = 1, sv = true },
    { type = "f", text = "#arccw.cvar.mult_movespeedfire",   var = "arccw_mult_movespeedfire", min = 0, max = 1, sv = true },

    { type = "f", text = "#arccw.cvar.mult_meleedamage",     var = "arccw_mult_meleedamage", min = 0, max = 4, sv = true },
    { type = "f", text = "#arccw.cvar.mult_meleetime",       var = "arccw_mult_meleetime", min = 0, max = 3, sv = true },
    { type = "f", text = "#arccw.cvar.mult_malfunction",     var = "arccw_mult_malfunction", min = 0, max = 10, sv = true },
    { type = "f", text = "#arccw.cvar.mult_rpm",             var = "arccw_mult_rpm", min = 0.1, max = 5, sv = true },
    { type = "c", text = "#arccw.cvar.mult_rpm.desc" },

    { type = "b", text = "#arccw.cvar.mult_startunloaded",   var = "arccw_mult_startunloaded", sv = true },
    { type = "b", text = "#arccw.cvar.mult_shootwhilesprinting",   var = "arccw_mult_shootwhilesprinting", sv = true },
    { type = "o", text = "#arccw.cvar.malfunction", var = "arccw_malfunction", sv = true,
            choices = {[0] = "#arccw.cvar.malfunction.0", [1] = "#arccw.cvar.malfunction.1", [2] = "#arccw.cvar.malfunction.2"}},

    { type = "b", text = "#arccw.cvar.mult_bottomlessclip",  var = "arccw_mult_bottomlessclip", sv = true },
    { type = "c", text = "Weapon feeds from reserve." },
    { type = "b", text = "#arccw.cvar.mult_infiniteammo",    var = "arccw_mult_infiniteammo", sv = true },
    { type = "c", text = "Infinite reserve ammo." },

    { type = "b", text = "#arccw.cvar.enable_sway",          var = "arccw_enable_sway", sv = true },
    { type = "c", text = "#arccw.cvar.enable_sway.desc" },
    { type = "f", text = "#arccw.cvar.add_sway",             var  = "arccw_add_sway", min = 0, max = 5, sv = true },
    { type = "f", text = "#arccw.cvar.mult_sway",            var = "arccw_mult_sway", min = 0, max = 10, sv = true },
}

local HelpPanel = {
    { type = "h",       text = "Links to the ArcCW online wiki." },

    { type = "url",     text = "Checking for Addon Conflicts",
                        url = "https://github.com/HaodongMo/ArcCW/wiki/Help-&-Troubleshooting#checking-for-addon-conflicts", },
    { type = "c",       text = "Check for addon conflicts that may be causing issues with ArcCW weapons." },

    { type = "url",     text = "Cheap Scopes",
                        url = "https://github.com/HaodongMo/ArcCW/wiki/Help-&-Troubleshooting#cheap-scopes", },
    { type = "c",       text = "'Why are my scopes so blurry?'" },

    { type = "url",     text = "Underbarrel Weapons",
                        url = "https://github.com/HaodongMo/ArcCW/wiki/Help-&-Troubleshooting#underbarrel-weapons", },
    { type = "c",       text = "'Why aren't my underbarrels weapons working?'" },
    { type = "c",       text = "'How do I use my underbarrel weapons?'" },

    { type = "url",     text = "Free Attachments",
                        url = "https://github.com/HaodongMo/ArcCW/wiki/Help-&-Troubleshooting#free-attachments", },
    { type = "c",       text = "'Why are my attachments red?'" },

    { type = "url",     text = "cam.End3D errors",
                        url = "https://github.com/HaodongMo/ArcCW/wiki/Help-&-Troubleshooting#camend3d-errors", },
    { type = "c",       text = "'Warning: Calling cam.End3D because someone forgot to!'" },

}

local MultPresets = {
    ["#preset.default"] = { -- this needs fills
        arccw_mult_damage                   = "1",
        arccw_mult_npcdamage                = "1",
        arccw_mult_range                    = "1",
        arccw_mult_recoil                   = "1",
        arccw_mult_penetration              = "1",
        arccw_mult_hipfire                  = "1",
        arccw_mult_movedisp                 = "1",
        arccw_mult_reloadtime               = "1",
        arccw_mult_sighttime                = "1",
        arccw_mult_defaultclip              = "1",
        arccw_mult_attchance                = "1",
        arccw_mult_crouchdisp               = "1",
        arccw_mult_crouchrecoil             = "1",
        arccw_mult_movespeed                = "1",
        arccw_mult_movespeedads             = "1",
        arccw_mult_movespeedfire            = "1",
        arccw_mult_heat                     = "1",
        arccw_mult_meleetime                = "1",
        arccw_mult_meleedamage              = "1",
        arccw_mult_malfunction              = "1",
        arccw_mult_startunloaded            = "0",
        arccw_mult_shootwhilesprinting      = "0",
        arccw_mult_bottomlessclip           = "0",
        arccw_mult_infiniteammo             = "0",
    }
}

local NPCsPanel = {
    { type = "h", text = "#arccw.adminonly" },
    { type = "b", text = "Replace NPC Weapons", var = "arccw_npc_replace", sv = true },
    { type = "b", text = "NPC Attachments", var = "arccw_npc_atts", sv = true },
}

function ArcCW.NetworkConvar(convar, value, p)
    if IsValid(LocalPlayer()) and !LocalPlayer():IsAdmin() then return end
    if (p.TickCreated or 0) == UnPredictedCurTime() then return end
    if value == true or value == false then
        value = value and 1 or 0
    end
    if IsColor(value) then
        value = tostring(value.r) .. " " .. tostring(value.g) .. " " .. tostring(value.b) .. " " .. tostring(value.a)
    end

    local command = convar .. " " .. tostring(value)

    local timername = "change" .. convar

    if timer.Exists(timername) then
        timer.Remove(timername)
    end

    timer.Create(timername, 0.25, 1, function()
        net.Start("arccw_sendconvar")
        net.WriteString(command)
        net.SendToServer()
    end)
end

function ArcCW.GeneratePanelElements(panel, table)
    local AddControl = {
        ["h"] = function(p, d) return p:Help(d.text) end,
        ["c"] = function(p, d) return p:ControlHelp(d.text) end,
        ["b"] = function(p, d) return p:CheckBox(d.text, d.var) end,
        ["i"] = function(p, d) return p:NumSlider(d.text, d.var, d.min, d.max, 0) end,
        ["f"] = function(p, d) return p:NumSlider(d.text, d.var, d.min, d.max, 2) end,
        ["m"] = function(p, d) --return p:AddControl("color", { Label = d.text, Red = d.r, Green = d.g, Blue = d.b, Alpha = d.a })
            local ctrl = vgui.Create("DColorMixer", p)
            ctrl:SetLabel( d.text ) ctrl:SetConVarR( d.r ) ctrl:SetConVarG( d.g ) ctrl:SetConVarB( d.b ) ctrl:SetConVarA( d.a )
            p:AddItem( ctrl ) return ctrl
        end,
        ["p"] = function(p, d) local b = p:Button(d.text) b.DoClick = d.func return b end,
        ["url"] = function(p, d) local b = p:Button(d.text) b.DoClick = function() gui.OpenURL(d.url) end return b end,
        ["t"] = function(p, d) return p:TextEntry(d.text, d.var) end,
        ["o"] = function(p, d) local cb = p:ComboBox(d.text, d.var) for k, v in pairs(d.choices) do cb:AddChoice(v, k) end return cb end,
        ["d"] = function(p, d)
                local s = vgui.Create("DSizeToContents", p) s:SetSizeX(false) s:Dock(TOP) s:InvalidateLayout()
                local l = vgui.Create("DLabel", s) l:SetText(d.text) l:SetTextColor(Color(0, 0, 0)) l:Dock(TOP) l:SetContentAlignment(5)
                local bd = vgui.Create("DBinder", s)
                if input.LookupBinding(d.var) then bd:SetValue(input.GetKeyCode(input.LookupBinding(d.var))) end
                bd.OnChange = function(b, k)
                    if k and input.GetKeyName(k) then
                        local str = input.LookupKeyBinding(k)
                        if str then
                            str = string.Replace(str, d.var .. "; ", "")
                            str = string.Replace(str, d.var, "")
                            chat.AddText(Color(255, 255, 255), language.GetPhrase("arccw.bind.msg"), Color(255, 128, 0), "bind " .. input.GetKeyName(k) .. " \"" .. str .. "; " .. d.var .. "\"")
                        else
                            chat.AddText(Color(255, 255, 255), language.GetPhrase("arccw.bind.msg"), Color(255, 128, 0), "bind " .. input.GetKeyName(k) .. " " .. d.var .. "")
                        end
                    end
                end
                bd:Dock(TOP) p:AddItem(s) return s end
    }

    local concommands = {
        ["b"] = true,
        ["i"] = true,
        ["f"] = true,
        ["m"] = true,
        ["t"] = true,
    }

    for _, data in SortedPairs(table) do
        local p = AddControl[data.type](panel, data)

        if concommands[data.type] and data.sv then
            p.TickCreated = UnPredictedCurTime()
            if data.type == "b" then
                p.OnChange = function(self, bval)
                    ArcCW.NetworkConvar(data.var, bval, self)
                end
            elseif data.type == "i" or data.type == "f" or data.type == "m" or data.type == "t" then
                p.OnValueChanged = function(self, bval)
                    ArcCW.NetworkConvar(data.var, bval, self)
                end
            end
        end
    end
end

local CrosshairPresets = {
    ["#preset.default"] = {
        arccw_crosshair_length        = "4",
        arccw_crosshair_thickness     = "1",
        arccw_crosshair_gap           = "1",
        arccw_crosshair_dot           = "1",
        arccw_crosshair_shotgun       = "1",
        arccw_crosshair_equip         = "1",
        arccw_crosshair_static        = "0",
        arccw_crosshair_clump         = "0",
        arccw_crosshair_clump_outline = "0",
        arccw_crosshair_clump_always  = "0",
        arccw_crosshair_clr_r         = "255",
        arccw_crosshair_clr_g         = "255",
        arccw_crosshair_clr_b         = "255",
        arccw_crosshair_clr_a         = "255",
        arccw_crosshair_outline       = "2",
        arccw_crosshair_outline_r     = "0",
        arccw_crosshair_outline_g     = "0",
        arccw_crosshair_outline_b     = "0",
        arccw_crosshair_outline_a     = "255",
        arccw_scope_r                 = "255",
        arccw_scope_g                 = "0",
        arccw_scope_b                 = "0",
    },
    ["#arccw.crosshair.tfa"] = {
        arccw_crosshair_length        = "8",
        arccw_crosshair_thickness     = "0.4",
        arccw_crosshair_gap           = "1",
        arccw_crosshair_dot           = "0",
        arccw_crosshair_shotgun       = "0",
        arccw_crosshair_equip         = "0",
        arccw_crosshair_static        = "0",
        arccw_crosshair_clump         = "0",
        arccw_crosshair_clump_outline = "0",
        arccw_crosshair_clump_always  = "0",
        arccw_crosshair_clr_r         = "255",
        arccw_crosshair_clr_g         = "255",
        arccw_crosshair_clr_b         = "255",
        arccw_crosshair_clr_a         = "255",
        arccw_crosshair_outline       = "2",
        arccw_crosshair_outline_r     = "0",
        arccw_crosshair_outline_g     = "0",
        arccw_crosshair_outline_b     = "0",
        arccw_crosshair_outline_a     = "255",
        arccw_scope_r                 = "255",
        arccw_scope_g                 = "0",
        arccw_scope_b                 = "0",
    },
    ["#arccw.crosshair.cw2"] = {
        arccw_crosshair_length        = "3.5",
        arccw_crosshair_thickness     = "0.4",
        arccw_crosshair_gap           = "1",
        arccw_crosshair_dot           = "0",
        arccw_crosshair_shotgun       = "0",
        arccw_crosshair_equip         = "0",
        arccw_crosshair_static        = "0",
        arccw_crosshair_clump         = "1",
        arccw_crosshair_clump_outline = "1",
        arccw_crosshair_clump_always  = "0",
        arccw_crosshair_clr_r         = "255",
        arccw_crosshair_clr_g         = "255",
        arccw_crosshair_clr_b         = "255",
        arccw_crosshair_clr_a         = "200",
        arccw_crosshair_outline       = "2",
        arccw_crosshair_outline_r     = "0",
        arccw_crosshair_outline_g     = "0",
        arccw_crosshair_outline_b     = "0",
        arccw_crosshair_outline_a     = "200",
        arccw_scope_r                 = "255",
        arccw_scope_g                 = "0",
        arccw_scope_b                 = "0",
    },
    ["#arccw.crosshair.cs"] = {
        arccw_crosshair_length        = "3",
        arccw_crosshair_thickness     = "0.4",
        arccw_crosshair_gap           = "0.4",
        arccw_crosshair_dot           = "0",
        arccw_crosshair_shotgun       = "0",
        arccw_crosshair_equip         = "0",
        arccw_crosshair_static        = "1",
        arccw_crosshair_clump         = "0",
        arccw_crosshair_clump_outline = "0",
        arccw_crosshair_clump_always  = "0",
        arccw_crosshair_clr_r         = "0",
        arccw_crosshair_clr_g         = "255",
        arccw_crosshair_clr_b         = "0",
        arccw_crosshair_clr_a         = "255",
        arccw_crosshair_outline       = "0",
        arccw_crosshair_outline_r     = "0",
        arccw_crosshair_outline_g     = "0",
        arccw_crosshair_outline_b     = "0",
        arccw_crosshair_outline_a     = "0",
        arccw_scope_r                 = "255",
        arccw_scope_g                 = "0",
        arccw_scope_b                 = "0",
    },
    ["#arccw.crosshair.light"] = {
        arccw_crosshair_length        = "4",
        arccw_crosshair_thickness     = "0.8",
        arccw_crosshair_gap           = "1",
        arccw_crosshair_dot           = "0",
        arccw_crosshair_shotgun       = "1",
        arccw_crosshair_equip         = "1",
        arccw_crosshair_static        = "0",
        arccw_crosshair_clump         = "1",
        arccw_crosshair_clump_outline = "1",
        arccw_crosshair_clump_always  = "0",
        arccw_crosshair_clr_r         = "255",
        arccw_crosshair_clr_g         = "255",
        arccw_crosshair_clr_b         = "255",
        arccw_crosshair_clr_a         = "200",
        arccw_crosshair_outline       = "2",
        arccw_crosshair_outline_r     = "0",
        arccw_crosshair_outline_g     = "0",
        arccw_crosshair_outline_b     = "0",
        arccw_crosshair_outline_a     = "200",
        arccw_scope_r                 = "255",
        arccw_scope_g                 = "0",
        arccw_scope_b                 = "0",
    },
}

local ViewmodelPresets = {
    ["#preset.default"] = {
        arccw_vm_coolsway             = "1",
        arccw_vm_coolview             = "1",
        arccw_vm_right                = "0",
        arccw_vm_forward              = "0",
        arccw_vm_up                   = "0",
        arccw_vm_look_xmult            = "1",
        arccw_vm_look_ymult            = "1",
        arccw_vm_sway_xmult            = "1",
        arccw_vm_sway_ymult            = "1",
        arccw_vm_sway_zmult            = "1",
        arccw_vm_sway_speedmult        = "1",
        arccw_vm_coolview_mult        = "1",
    }
}

function ArcCW_Options_Bullet(panel)
    ArcCW.GeneratePanelElements(panel, BulletPanel)
end

function ArcCW_Options_Client(panel)
    ArcCW.GeneratePanelElements(panel, ClientPanel)
end

function ArcCW_Options_Perf(panel)
    ArcCW.GeneratePanelElements(panel, PerformancePanel)
end

function ArcCW_Options_Viewmodel(panel, no_preset)
    if !no_preset then
        panel:AddControl("ComboBox", {
            MenuButton = "1",
            Label      = "#Presets",
            Folder     = "arccw_vm",
            CVars      = { "" },
            Options    = ViewmodelPresets
        })
    end

    ArcCW.GeneratePanelElements(panel, ViewmodelPanel)
end

function ArcCW_Options_HUD(panel)
    ArcCW.GeneratePanelElements(panel, HudPanel)
end

function ArcCW_Options_Dev(panel)
    ArcCW.GeneratePanelElements(panel, DevPanel)
end

function ArcCW_Options_Crosshair(panel, no_preset)
    if !no_preset then
        panel:AddControl("ComboBox", {
            MenuButton = "1",
            Label      = "#Presets",
            Folder     = "arccw_crosshair",
            CVars      = { "" },
            Options    = CrosshairPresets
        })
    end
    ArcCW.GeneratePanelElements(panel, CrosshairPanel)
end

function ArcCW_Options_Server(panel)
    ArcCW.GeneratePanelElements(panel, ServerPanel)
end

function ArcCW_Options_Ammo(panel)
    ArcCW.GeneratePanelElements(panel, AmmoPanel)
end

function ArcCW_Options_Mults(panel, no_preset)
    if !no_preset then
        panel:AddControl("ComboBox", {
            MenuButton = "1",
            Label      = "#Presets",
            Folder     = "arccw_mults",
            CVars      = { "" },
            Options    = MultPresets
        })
    end
    ArcCW.GeneratePanelElements(panel, MultsPanel)
end

function ArcCW_Options_Atts(panel)
    ArcCW.GeneratePanelElements(panel, AttsPanel)
end

function ArcCW_Options_NPC(panel)
    ArcCW.GeneratePanelElements(panel, NPCsPanel)
end

function ArcCW_Options_Binds(panel)
    ArcCW.GeneratePanelElements(panel, BindsPanel)
end

function ArcCW_Options_Scopes(panel)
    ArcCW.GeneratePanelElements(panel, ScopesPanel)
end

function ArcCW_Options_Help(panel)
    ArcCW.GeneratePanelElements(panel, HelpPanel)
end

ArcCW.ClientMenus = {
    ["ArcCW_Options_Client"]    = { text = "#arccw.menus.client",    func = ArcCW_Options_Client,    tbl = ClientPanel },
    ["ArcCW_Options_Help"]      = { text = "Help & Troubleshooting", func = ArcCW_Options_Help,      tbl = HelpPanel },
    ["ArcCW_Options_Bullet"]    = { text = "#arccw.menus.bullet",    func = ArcCW_Options_Bullet,    tbl = BulletPanel },
    ["ArcCW_Options_Perf"]      = { text = "#arccw.menus.perf",      func = ArcCW_Options_Perf,      tbl = PerformancePanel },
    ["ArcCW_Options_Viewmodel"] = { text = "#arccw.menus.vmodel",    func = ArcCW_Options_Viewmodel, tbl = ViewmodelPanel },
    ["ArcCW_Options_HUD"]       = { text = "#arccw.menus.hud",       func = ArcCW_Options_HUD,       tbl = HudPanel },
    ["ArcCW_Options_Crosshair"] = { text = "#arccw.menus.xhair",     func = ArcCW_Options_Crosshair, tbl = CrosshairPanel },
    ["ArcCW_Options_Server"]    = { text = "#arccw.menus.server",    func = ArcCW_Options_Server,    tbl = ServerPanel },
    ["ArcCW_Options_Ammo"]      = { text = "#arccw.menus.ammo",      func = ArcCW_Options_Ammo,      tbl = AmmoPanel },
    ["ArcCW_Options_Atts"]      = { text = "#arccw.menus.atts",      func = ArcCW_Options_Atts,      tbl = AttsPanel },
    ["ArcCW_Options_Mults"]     = { text = "#arccw.menus.mults",     func = ArcCW_Options_Mults,     tbl = MultsPanel },
    ["ArcCW_Options_Dev"]       = { text = "#arccw.menus.dev",       func = ArcCW_Options_Dev,       tbl = DevPanel },
    ["ArcCW_Options_NPC"]       = { text = "#arccw.menus.npcs",      func = ArcCW_Options_NPC,       tbl = NPCsPanel },
    ["ArcCW_Options_Binds"]     = { text = "#arccw.menus.binds",     func = ArcCW_Options_Binds,     tbl = BindsPanel },
    ["ArcCW_Options_Scopes"]    = { text = "#arccw.menus.scopes",    func = ArcCW_Options_Scopes,    tbl = ScopesPanel },
}

hook.Add("PopulateToolMenu", "ArcCW_Options", function()
    for menu, data in pairs(ArcCW.ClientMenus) do
        spawnmenu.AddToolMenuOption("Options", "ArcCW", menu, data.text, "", "", data.func)
    end
end)

-- As of 2023-11-12, this feature is only available on dev branch.
-- Won't break anything on release branch though.
list.Set("ContentCategoryIcons", "ArcCW - Ammo", "arccw/icon_16.png")
list.Set("ContentCategoryIcons", "ArcCW - Attachments", "arccw/icon_16.png")

-- Give all categories with ArcCW weapons our icon unless one is already set
local first_populate = true
hook.Add("PopulateWeapons", "ArcCW_ContentCategoryIcons", function()
    if !first_populate then return end
    for i, wep in pairs(weapons.GetList()) do
        local weap = weapons.Get(wep.ClassName)
        if weap and weap.ArcCW then
            local cat = weap.Category
            if cat and !list.HasEntry("ContentCategoryIcons", cat) then
                list.Set("ContentCategoryIcons", cat, "arccw/icon_16.png")
            end
        end
    end
    first_populate = false
end)
--addons/[binbon]arccw_modify/lua/arccw/client/cl_singleplayer.lua:
net.Receive("arccw_sp_anim", function(len, ply)
    local wep    = LocalPlayer():GetActiveWeapon()
    local key    = net.ReadString()
    local mul    = net.ReadFloat()
    local start  = net.ReadFloat()
    local time   = net.ReadBool()
    --local skip   = net.ReadBool() Unused
    local ignore = net.ReadBool()

    if !wep.ArcCW then return end

    wep:PlayAnimation(key, mul, false, start, time, false, ignore)
end)

net.Receive("arccw_sp_checkpoints", function(len, ply)
    local wep = LocalPlayer():GetActiveWeapon()

    if !wep.ArcCW then return end

    wep.CheckpointAnimation = nil
end)

net.Receive("arccw_sp_lhikanim", function(len, ply)
    local wep  = LocalPlayer():GetActiveWeapon()
    local key  = net.ReadString()
    local time = net.ReadFloat() or -1

    if !wep.ArcCW then return end

    wep:DoLHIKAnimation(key, time)
end)

net.Receive("arccw_sp_health", function(len, ply)
    local ent = net.ReadEntity()

    if !IsValid(ent) then return end

    ent:SetHealth(0)
    ent.ArcCWCLHealth = 0
end)

local clr_b = Color(160, 190, 255)
local clr_r = Color(255, 190, 190)

concommand.Add("arccw_listvmanims", function()
    local wep = LocalPlayer():GetActiveWeapon()

    if !wep then return end

    local vm = LocalPlayer():GetViewModel()

    if !vm then return end

    local alist = vm:GetSequenceList()

    for i = 0, #alist do
        MsgC(clr_b, i, " --- ")
        MsgC(color_white, "\t", alist[i], "\n     [")
        MsgC(clr_r, "\t", vm:SequenceDuration(i), "\n")
    end
end)

concommand.Add("arccw_listvmbones", function()
    local wep = LocalPlayer():GetActiveWeapon()

    if !wep then return end

    local vm = LocalPlayer():GetViewModel()

    if !vm then return end

    for i = 0, (vm:GetBoneCount() - 1) do
        print(i .. " - " .. vm:GetBoneName(i))
    end
end)

concommand.Add("arccw_listvmatts", function()
    local wep = LocalPlayer():GetActiveWeapon()

    if !wep then return end

    local vm = LocalPlayer():GetViewModel()

    if !vm then return end

    local alist = vm:GetAttachments()

    for i = 1, #alist do
        MsgC(clr_b, i, " --- ")
        MsgC(color_white, "\tindex : ", alist[i].id, "\n     [")
        MsgC(clr_r, "\tname: ", alist[i].name, "\n")
    end
end)

concommand.Add("arccw_listvmbgs", function()
    local wep = LocalPlayer():GetActiveWeapon()

    if !wep then return end

    local vm = LocalPlayer():GetViewModel()

    if !vm then return end

    local alist = vm:GetBodyGroups()

    for i = 1, #alist do
        local alistsm = alist[i].submodels
        local active = vm:GetBodygroup(alist[i].id)
        MsgC(clr_b, alist[i].id, " --  ")
        MsgC(color_white, "\t", alist[i].name, "\n")
        if alistsm then
            for j = 0, #alistsm do
                MsgC(active == j and color_white or clr_b, "\t" .. j, " - ")
                MsgC(active == j and color_white or clr_r, alistsm[j], "\n")
            end
        end
    end
end)

local lastwpn = nil

hook.Add("Think", "ArcCW_FixDeploy", function()
    --if !game.SinglePlayer() then return end
    local wep = LocalPlayer():GetActiveWeapon()

    if wep.ArcCW and wep != lastwpn then wep:Deploy() end

    lastwpn = wep
end)
--addons/[binbon]arccw_modify/lua/arccw/client/cl_sway.lua:
return gluapack()()
--addons/[binbon]arccw_modify/lua/arccw/client/cl_vrmod.lua:
return gluapack()()
--addons/[binbon]arccw_modify/lua/arccw/client/cl_warnings.lua:
ArcCW.IncompatibleAddons = {
    -- My Hands 8.1
    ["847269692"] = "Causes viewmodel flickering, double viewmodel, may crash when customization menu opens",

    -- My Hands 8
    ["1890577397"] = "Causes viewmodel flickering, double viewmodel, may crash when customization menu opens",

    -- Quick Weapon Menu
    ["306149085"] = "Makes the customize menu mouse unable to appear.",

    -- Neurotec
    ["541434990"] = "Neurotec is ancient, half the base is missing, and it flat-out doesn't work. Causes all sorts of problems. For the love of god, let go.",

    -- Improved Combine NPCs
    ["476997621"] = "Causes issues with arms.",

    -- Realistic Bullet Overhaul
    ["1588705429"] = "Causes damage calculation to not work properly.",

    -- Quake/Half Life View bobbing
    ["378401390"] = "Causes most animations to not play properly.",

    -- Thirteen's Physgun Glow
    ["111249028"] = "Causes LHIK animations to flicker and not work properly.",

    -- Viewmodel Lagger
    ["1146104662"] = "Misaligns viewmodel in sights.",

    -- Viewmodel Lagger (fixed)
    ["2566560460"] = "Misaligns viewmodel in sights.",

    -- VTools
    ["DisplayDistancePlane"] = "Tool contains faulty hook, which has been removed to keep ArcCW functional.",
}

local t = ArcCW.GetTranslation

local function ScreenScaleMulti(input)
    return ScreenScale(input) * ArcCW.ConVars["hud_size"]:GetFloat()
end

function ArcCW.MakeIncompatibleWindow(tbl)
    local startTime = CurTime()

    local window = vgui.Create( "DFrame" )
    window:SetSize( ScrW() * 0.6, ScrH() * 0.6)
    window:Center()
    window:SetTitle("")
    window:SetDraggable(false)
    window:SetVisible(true)
    window:ShowCloseButton(false)
    window:MakePopup()
    window.Paint = function(self, w, h)
        surface.SetDrawColor(0, 0, 0, 200)
        surface.DrawRect(0, 0, w, h)
    end

    local title = vgui.Create("DLabel", window)
    title:SetSize(ScreenScaleMulti(256), ScreenScaleMulti(26))
    title:Dock(TOP)
    title:SetFont("ArcCW_24")
    title:SetText(t("incompatible.title"))
    title:DockMargin(ScreenScaleMulti(16), 0, ScreenScaleMulti(16), ScreenScaleMulti(8))

    local desc = vgui.Create("DLabel", window)
    desc:SetSize(ScreenScaleMulti(256), ScreenScaleMulti(12))
    desc:Dock(TOP)
    desc:DockMargin(ScreenScaleMulti(4), 0, ScreenScaleMulti(4), 0)
    desc:SetFont("ArcCW_12")
    desc:SetText(t("incompatible.line1"))
    desc:SetContentAlignment(5)

    local desc2 = vgui.Create("DLabel", window)
    desc2:SetSize(ScreenScaleMulti(256), ScreenScaleMulti(12))
    desc2:Dock(TOP)
    desc2:DockMargin(ScreenScaleMulti(4), 0, ScreenScaleMulti(4), ScreenScaleMulti(4))
    desc2:SetFont("ArcCW_12")
    desc2:SetText(t("incompatible.line2"))
    desc2:SetContentAlignment(5)

    local neverAgain = vgui.Create("DButton", window)
    neverAgain:SetSize(ScreenScaleMulti(256), ScreenScaleMulti(20))
    neverAgain:SetText("")
    neverAgain:Dock(BOTTOM)
    neverAgain:DockMargin(ScreenScaleMulti(48), ScreenScaleMulti(2), ScreenScaleMulti(48), ScreenScaleMulti(2))
    neverAgain.OnMousePressed = function(spaa, kc)
        if CurTime() > startTime + 10 then
            local simpleTbl = {}
            for _, v in pairs(tbl) do simpleTbl[tostring(v.wsid)] = true end
            file.Write("arccw_incompatible.txt", util.TableToJSON(simpleTbl))
            window:Close()
            window:Remove()
            chat.AddText(Color(255,0,0),t("incompatible.never.confirm"))
        end
    end
    neverAgain.Paint = function(spaa, w, h)
        local Bfg_col = Color(255, 255, 255, 255)
        local Bbg_col = Color(0, 0, 0, 200)

        if CurTime() > startTime + 10 and spaa:IsHovered() then
            Bbg_col = Color(255, 100, 100, 100)
            Bfg_col = Color(255, 255, 255, 255)
        end

        surface.SetDrawColor(Bbg_col)
        surface.DrawRect(0, 0, w, h)

        local txt = (CurTime() > startTime + 10) and (spaa:IsHovered() and t("incompatible.never.hover") or t("incompatible.never")) or t("incompatible.wait", {time = math.ceil(startTime + 10 - CurTime())})
        surface.SetTextColor(Bfg_col)
        surface.SetTextPos(ScreenScaleMulti(8), ScreenScaleMulti(2))
        surface.SetFont("ArcCW_12")
        surface.DrawText(txt)
    end

    local addonList = vgui.Create("DScrollPanel", window)
    addonList:SetText("")
    addonList:Dock(FILL)
    addonList.Paint = function(span, w, h) end
    local sbar = addonList:GetVBar()
    sbar.Paint = function() end
    sbar.btnUp.Paint = function(span, w, h) end
    sbar.btnDown.Paint = function(span, w, h) end
    sbar.btnGrip.Paint = function(span, w, h)
        surface.SetDrawColor(255, 255, 255, 255)
        surface.DrawRect(0, 0, w, h)
    end


    local accept = vgui.Create("DButton", window)
    accept:SetSize(ScreenScaleMulti(256), ScreenScaleMulti(20))
    accept:SetText("")
    accept:Dock(BOTTOM)
    accept:DockMargin(ScreenScaleMulti(48), ScreenScaleMulti(2), ScreenScaleMulti(48), ScreenScaleMulti(2))
    accept.OnMousePressed = function(spaa, kc)
        if CurTime() > startTime + 5 then
            window:Close()
            window:Remove()
        end
    end
    accept.Paint = function(spaa, w, h)
        local Bfg_col = Color(255, 255, 255, 255)
        local Bbg_col = Color(0, 0, 0, 200)

        if CurTime() > startTime + 5 and spaa:IsHovered() then
            Bbg_col = Color(255, 255, 255, 100)
            Bfg_col = Color(0, 0, 0, 255)
        end

        surface.SetDrawColor(Bbg_col)
        surface.DrawRect(0, 0, w, h)

        local txt = t("incompatible.confirm") .. ((CurTime() > startTime + 5) and "" or (" - " .. t("incompatible.wait", {time = math.ceil(startTime + 5 - CurTime())})))
        surface.SetTextColor(Bfg_col)
        surface.SetTextPos(ScreenScaleMulti(8), ScreenScaleMulti(2))
        surface.SetFont("ArcCW_12")
        surface.DrawText(txt)
    end

    for _, addon in pairs(tbl) do
        local addonBtn = vgui.Create("DButton", window)
        addonBtn:SetSize(ScreenScaleMulti(256), ScreenScaleMulti(28))
        addonBtn:Dock(TOP)
        addonBtn:DockMargin(ScreenScaleMulti(36), ScreenScaleMulti(2), ScreenScaleMulti(36), ScreenScaleMulti(2))
        addonBtn:SetFont("ArcCW_12")
        addonBtn:SetText("")
        addonBtn:SetContentAlignment(5)
        addonBtn.Paint = function(spaa, w, h)
            local Bfg_col = Color(255, 255, 255, 255)
            local Bbg_col = Color(0, 0, 0, 200)

            if spaa:IsHovered() then
                Bbg_col = Color(255, 255, 255, 100)
                Bfg_col = Color(0, 0, 0, 255)
            end

            surface.SetDrawColor(Bbg_col)
            surface.DrawRect(0, 0, w, h)

            local txt = addon.title
            surface.SetTextColor(Bfg_col)
            surface.SetTextPos(ScreenScaleMulti(18), ScreenScaleMulti(2))
            surface.SetFont("ArcCW_12")
            surface.DrawText(txt)

            local txt2 = ArcCW.IncompatibleAddons[tostring(addon.wsid)]
            surface.SetTextColor(Bfg_col)
            surface.SetTextPos(ScreenScaleMulti(18), ScreenScaleMulti(16))
            surface.SetFont("ArcCW_8")
            surface.DrawText(txt2)
        end
        addonBtn.OnMousePressed = function(spaa, kc)
            if addon.nourl then return end
            gui.OpenURL("https://steamcommunity.com/sharedfiles/filedetails/?id=" .. tostring(addon.wsid))
        end
    end
end

hook.Add("InitPostEntity", "ArcCW_CheckContent", function()
    for _, k in pairs(weapons.GetList()) do
        if weapons.IsBasedOn(k.ClassName, "arccw_base") and k.ClassName != "arccw_base" then
            return
        end
    end
    chat.AddText(Color(255,255,255), "You have installed the ArcCW base but have no weapons installed. Search the workshop for some!") -- Perhaps you want to install the CS+ pack?")
    --chat.AddText(Color(255,255,255), "https://steamcommunity.com/sharedfiles/filedetails/?id=2131058270")
end)
--lua/autorun/arccw_fml_karma9.lua:
return gluapack()()
--addons/policearmorylocker/lua/armory_locker/shared/armory_locker_config.lua:
return gluapack()()
--addons/ashop/lua/autorun/ashop_load.lua:
return gluapack()()
--addons/ashop/lua/ashop/code/gamemodes/currencies/integrations/sh_flux.lua:
return gluapack()()
--addons/ashop/lua/ashop/code/gamemodes/logs_integration_name/sh_darkrp.lua:
return gluapack()()
--addons/ashop/lua/ashop/code/gamemodes/logs_integration_name/sh_nutscript.lua:
hook.Add("PostGamemodeLoaded", "AShop_Name_Nut", function()
    if nut then
        hook.Add("OnCharVarChanged", "AShop_Name_Nut", function(char, key, _, val)
            if nut and key == "Name" then
                ashop.Logs.RefreshName(char:getPlayer(), val)
            end
        end)

        hook.Remove("PostGamemodeLoaded", "AShop_Name_Nut")
        hook.Remove("player_changename", "ashop_Name")
    end
end)
--addons/ashop/lua/ashop/code/logs/sh_init.lua:
return gluapack()()
--addons/ashop/lua/ashop/code/object_types/bundles/cl_bundles.lua:
local OBJECT_TYPE = {}

OBJECT_TYPE.Name = ashop.L('Bundles')
OBJECT_TYPE.UniqueIdentifier = "Bundles"

function OBJECT_TYPE.UI_FILL(plyItem, item, pnl, parent, w, h, noCircle)
    local circleParent = vgui.Create("EditablePanel", pnl)
    circleParent:SetSize(w, h)
    circleParent:SetMouseInputEnabled(false)
end

OBJECT_TYPE.ExtraMenuOptions = {
    ['See package'] = function(plyItemTable, item)
        local marginVertical = ashop.GetSize(16)
        local case = vgui.Create('EditablePanel', ashop.menu)
        case:SetSize(ashop.menu:GetWide()/2, ashop.menu:GetTall()/2)
        case:Center()
        case:DockPadding(marginVertical, marginVertical, marginVertical, marginVertical)

        local header = vgui.Create('EditablePanel', case)
        header:Dock(TOP)
        header:SetTall(ashop.GetFontHeight('ashop_16') * 1.5)
        header:DockMargin(0, 0, 0, marginVertical)
        
        local title = vgui.Create('DLabel', header)
        title:Dock(LEFT)
        title:SetText('Items of the bundle')
        title:SetTextColor(color_white)
        title:SetFont("ashop_16")
        title:SetWide(title:GetContentSize())

        local close = vgui.Create('DButton', header)
        close:Dock(RIGHT)
        close:SetFont('ashop_16_600')
        close:SetText('x')
        close:SetPaintBackground(false)
        close:SetTextColor(color_white)
        close:SetWide(header:GetTall())

        function close:DoClick()
            case:Remove()
        end

        ashop.menu:PushFocus(case)

        function case:OnRemove()
            ashop.menu:PopFocus(self)
        end

        function case:Paint(w, h)
            draw.RoundedBox(8, 0, 0, w, h, ashop.GetColor('Grad2_0'))
        end

        local items = vgui.Create('DScrollPanel', case)
        items:Dock(FILL)
        ashop.ui.SkinScrollPanel(items)

        local itemList = vgui.Create('DIconLayout', items)
        itemList:Dock(FILL)
        itemList:SetSpaceX(5)
        itemList:SetSpaceY(5)

        local boxSize = (case:GetWide() - marginVertical*2 - 5 * 5 - 8) / 6

        for k, v in pairs(item.metadata[1]) do
            local p = vgui.Create("AShop_ShopItem", itemList)
            p:SetSize(boxSize, ashop.GetSize(189))
            
            function p:Paint()
                p:SetItem(nil, v[1], true)
            end
        end
    end,
}

ashop.RegisterObjectType(OBJECT_TYPE)
--addons/ashop/lua/ashop/code/object_types/finishers/sh_finishers.lua:
local OBJECT_TYPE = {}

OBJECT_TYPE.Name = ashop.L('FinishersClass')
OBJECT_TYPE.DefaultRender = "Accessories"

OBJECT_TYPE.ItemParameters = {
    [1] = {
        name = ashop.L('Finisher_0'),
        type = TYPE_STRING,
        options = {
            required = true
        }
    },

    [2] = {
        name = ashop.L('Finisher_1'),
        type = TYPE_STRING,
    },

    [3] = {
        name = ashop.L('Finisher_2'),
        type = TYPE_BOOL,
    },

    [4] = {
        name = ashop.L('Finisher_3'),
        type = TYPE_VECTOR,
        options = {
            maxVar = 10
        }
    },

    [5] = {
        name = ashop.L('Finisher_4'),
        type = "UInt8",
    },

    [6] = {
        name = ashop.L('Finisher_5'),
        type = "UInt6",
    },

    [7] = {
        name = ashop.L('Finisher_6'),
        type = "FLOAT",
    },

    [8] = {
        name = ashop.L('Finisher_7'),
        type = TYPE_BOOL
    },

    [9] = {
        name = ashop.L('Finisher_8'),
        type = "FLOAT"
    }
}

OBJECT_TYPE.SlotDefault = 1
OBJECT_TYPE.UniqueIdentifier = "Finishers"

ashop.RegisterObjectType(OBJECT_TYPE)
--addons/ashop/lua/ashop/code/object_types/kill_card/cl_killcard.lua:
return gluapack()()
--addons/ashop/lua/ashop/code/object_types/pac3/sh_pac3.lua:
local OBJECT_TYPE = {}

OBJECT_TYPE.Name = 'Effets'
OBJECT_TYPE.DefaultRender = "Accessories"

OBJECT_TYPE.ItemParameters = {
    [1] = {
        name = "Simple particles or Pac3 (Checked)",
        type = TYPE_BOOL,
    },

    [2] = {
        name = ashop.L('Pac3') .. " ID",
        type = "UInt12",
    },

    [3] = {
        name = "Particle file name",
        type = TYPE_STRING,
    },

    [4] = {
        name = "Particle name",
        type = TYPE_STRING,
    },

    [5] = {
        name = "Bone name ( Will use a entity )",
        type = TYPE_STRING,
    },

    [6] = {
        name = "Offset, if using bone",
        type = TYPE_VECTOR,
        options = {
            maxVar = 5,
        },
    },

    [7] = {
        name = "PAttach ( Useful if you don't use a bone )",
        type = "UInt4",
    },

    [8] = {
        name = "Angle, if using bone",
        type = TYPE_ANGLE,
        options = {
            maxVar = 180,
        }
    }
}

OBJECT_TYPE.SlotDefault = 1
OBJECT_TYPE.UniqueIdentifier = "Pac3"

ashop.RegisterObjectType(OBJECT_TYPE)
--addons/ashop/lua/ashop/code/object_types/weapon_perms/cl_permwep.lua:
local OBJECT_TYPE = {}

OBJECT_TYPE.Name = ashop.L('PermWeaponClass')
OBJECT_TYPE.UniqueIdentifier = "PermanentWeapons"


function OBJECT_TYPE.OnEquip(ply, plyItem, item)
    if ply.DModelPanel then
        ply.DModelPanel:EquipWeapon(ashop.GetItemAttribute(plyItem, item, 1))
    end
end

function OBJECT_TYPE.UI_FILL(plyItem, item, pnl, parent, w, h, noCircle)
    local circleParent = vgui.Create("EditablePanel", pnl)
    circleParent:SetSize(w, h)
    circleParent:SetMouseInputEnabled(false)

    local wep = weapons.Get(item.metadata[1]) or ashop.DefaultWeaponsHL2[item.metadata[1]]
    local key

    if string.find(item.metadata[1], 'fas2') then
        key = "WM"
    elseif ashop.DefaultWeaponsHL2[item.metadata[1]] then
        key = 1
    else
        key = "WorldModel"
    end

    local m = vgui.Create( "DModelPanel" , pnl ) -- SpawnIcon
    m:Dock(FILL)
    m:SetModel( wep[key] ) -- Model we want for this spawn icon
    m:SetMouseInputEnabled(false)
    m:SetPaintedManually(true)

    m.FarZ = 4096*10

    local mn, mx = m.Entity:GetRenderBounds()
    local size = 0
    size = math.max( size, math.abs(mn.x) + math.abs(mx.x) )
    size = math.max( size, math.abs(mn.y) + math.abs(mx.y) )
    size = math.max( size, math.abs(mn.z) + math.abs(mx.z) )

    m:SetFOV( 45 )
    m:SetLookAt( (mn + mx) * 0.5 )

    local camPos = Vector(size, size, size)*1.25
    m:SetCamPos( camPos )

    function m:LayoutEntity() end

    function m:PreDrawModel(ent)
        render.SetLightingMode(1)
    end

    function m:PostDrawModel(ent)
        render.SetLightingMode(0)
    end

    if item.metadata[4] then
        m:SetCamPos(item.metadata[4])
    end

    return true, {m}
end

ashop.RegisterObjectType(OBJECT_TYPE)
--addons/ashop/lua/ashop/code/object_types/weapon_skins/cl_weaponskin.lua:
local OBJECT_TYPE = {}

OBJECT_TYPE.Name = ashop.L('WeaponSkinClass')
OBJECT_TYPE.UniqueIdentifier = "WeaponSkins"

function OBJECT_TYPE.UI_FILL(plyItem, item, pnl, parent, w, h, ignoreThat, fullSize)
    local circleParent = vgui.Create("EditablePanel", pnl)
    circleParent:SetSize(w, h)
    circleParent:SetMouseInputEnabled(false)

    local c = fullSize and math.max(w, h) or math.max(w, h) * 0.4

    // What an hack...
    local vmt = file.Read("materials/" .. item.metadata[1] .. ".vmt", 'GAME')
    local t = {
        ["$basetexture"] = item.metadata[1]
    }

    if vmt and string.find(vmt, 'AnimatedTexture') then
        t['Proxies'] = {
            ["AnimatedTexture"] = {
                ["animatedTextureVar"] = "$basetexture",
                ["animatedTextureFrameNumVar"] = "$frame",
                ["animatedTextureFrameRate"] = 30
            }
        }
    elseif vmt and string.find(vmt, 'TextureScroll') then
        t['Proxies'] = {
            ["TextureScroll"] = {
                ["texturescrollvar"] = "$baseTextureTransform",
                ["texturescrollrate"] = 0.1,
                ["texturescrollangle"] = 130
            }
        }
    end

    local mat = CreateMaterial('ashop_weptex_' .. item.metadata[1], "UnLitGeneric", t)

    local SpawnI = vgui.Create( "DPanel" , circleParent ) -- SpawnIcon
    SpawnI:SetSize(c, c)
    SpawnI:Center()
    
    local r1
    function SpawnI:Paint(w, h)
        if !r1 then
            r1 = ashop.ui.RoundedBox(ashop.Config.round, 0, 0, w, h)
        end

        ashop.StartStencil()
            surface.SetDrawColor(1, 1, 1, 1)
            draw.NoTexture()
            surface.DrawPoly(r1)
        ashop.ReplaceStencil(1)
            surface.SetDrawColor(255, 255, 255)
            surface.SetMaterial(mat)
            surface.DrawTexturedRect(0, 0, w, h)
        ashop.EndStencil()
    end
end

function OBJECT_TYPE.OnPostPlayerDraw(ply, _, _, inModelPanel)
    if inModelPanel and !IsValid(inModelPanel.WeaponModel) then return end
    ashop.WeaponSkinApply(ply, inModelPanel and inModelPanel.WeaponModel or ply:GetActiveWeapon())
end

function OBJECT_TYPE.OnViewModelChanged(ply, plyItem, item, _, _, vm, wep)
    if !wep or !IsValid(vm) or !IsValid(wep) then return end

    // What a painful weapon pack
    if wep.IsFAS2Weapon then
        if IsValid(wep.W_Wep) then
            for i = 1, #wep.W_Wep:GetMaterials() do
                wep.W_Wep:SetSubMaterial(i-1, nil)
            end
        end

        if IsValid(wep.Wep) then
            for i = 1, #wep.Wep:GetMaterials() do
                wep.Wep:SetSubMaterial(i-1, nil)
            end
        end
    elseif wep.CW20Weapon then
        if IsValid(wep.CW_VM) then
            for i = 1, #wep.CW_VM:GetMaterials() do
                wep.CW_VM:SetSubMaterial(i-1, nil)
            end
        end
    elseif wep.Base == "mg_base" then
        local vm = LocalPlayer():GetActiveWeapon()
        if IsValid(vm) and IsValid(vm:GetViewModel()) then
            vm = LocalPlayer():GetActiveWeapon():GetViewModel()
            for i = 1, #vm:GetMaterials() do
                vm:SetSubMaterial(i-1, nil)
            end
        end
    elseif wep.IsTFAWeapon then
        wep.MaterialCached_W = nil
        wep.MaterialCached_V = nil

        for i = 1, #vm:GetMaterials() do
            vm:SetSubMaterial(i-1, nil)
        end

        for i = 1, #wep:GetMaterials() do
            wep:SetSubMaterial(i-1, nil)
        end
        wep.MaterialCached = false
    else
        for i = 1, #vm:GetMaterials() do
            vm:SetSubMaterial(i-1, nil)
        end
    end

    if !item then return end

    local skinWep = ply.ashop_skinwep
    local skinTable = ashop.weaponmaterials[wep:GetClass()]
	local skinPath = item.metadata[1]

    if !skinTable or !skinPath or !skinWep then return end

	if wep.IsFAS2Weapon then
        // Fas2, duh !
        if IsValid(wep.W_Wep) then
            for matID in pairs(skinTable.wm) do
                wep.W_Wep:SetSubMaterial(matID, skinPath)
            end
        end
    
        if IsValid(wep.Wep) then
            for matID in pairs(skinTable.vm) do
                wep.Wep:SetSubMaterial(matID, skinPath)
            end
        end

        // https://github.com/Facepunch/garrysmod-issues/issues/2473
        timer.Create('ashop_FixGmodSwitchWeapon', 0.5, 0, function()
            if ply:GetActiveWeapon() != wep then
                ashop.OnViewModelChanged(ply:GetViewModel(), ply:GetActiveWeapon())
                timer.Remove('ashop_FixGmodSwitchWeapon')
            end
        end)
    elseif wep.CW20Weapon then
        if IsValid(wep.CW_VM) then
            for matID in pairs(skinTable.vm) do
                wep.CW_VM:SetSubMaterial(matID, skinPath)
            end
        end
    elseif wep.IsTFAWeapon then
        for k, v in ipairs({
            {wep.MaterialTable_V, skinTable.vm, wep.vRenderOrder, wep.VElements},
            {wep.MaterialTable_W, skinTable.wm, wep.wRenderOrder, wep.WElements},
        }) do
            for index = 0, #v[3] do
                if !v[2][index] then continue end
                v[1][index+1] = skinPath
                local obj = (k == 1 and vm or wep)
                obj:SetSubMaterial(index, skinPath)
            end

            local tfadetect = ashop.Config.aggressiveTFASkinDetection
            if tfadetect and tfadetect[wep:GetClass()] then            
                for k, v in pairs(v[4]) do
                    if !v.model or !v.bone or v.bone == "" or !(v.active or v.active == nil) then continue end
                    v.material = skinPath
                end
            end
        end

        wep:ClearStatCache()
    elseif wep.Base == "mg_base" then
        for i=0, 2 do
            // Some of the weapons seems to override sometimes on equip
            timer.Simple(i, function()
                local vm = LocalPlayer():GetActiveWeapon()
                print(vm, wep)
                if !IsValid(vm) or vm != wep then return end
        
                vm = vm:GetViewModel()
                if !IsValid(vm) then return end

                for matID in pairs(skinTable.vm) do
                    vm:SetSubMaterial(matID, skinPath)
                end
            end)
        end
    else
        for matID in pairs(skinTable.vm) do
            vm:SetSubMaterial(matID, skinPath)
        end
    end
end

function OBJECT_TYPE.OnLocalEquip(ply, plyItem, item)
    OBJECT_TYPE.OnEquip(ply, plyItem, item)
end

function OBJECT_TYPE.OnEquip(ply, plyItem, item)
    ply.ashop_skinwep = plyItem.id

    if !ply:IsPlayer() then
        ashop.WeaponSkinApply(ply, ply.Weapon)
    else
        local wep = ply:GetActiveWeapon()
        local vm = ply:GetViewModel()
        OBJECT_TYPE.OnViewModelChanged(ply, plyItem, item, nil, nil, vm, wep)
    end
end

function OBJECT_TYPE.OnLocalRemove(ply, plyItem, item)
    OBJECT_TYPE.OnRemove(ply, plyItem, item)
end

function OBJECT_TYPE.OnRemove(ply, plyItem, item)
    ply.ashop_skinwep = nil

    if !ply:IsPlayer() then
        ashop.WeaponSkinApply(ply, ply.Weapon)
    else
        local wep = ply:GetActiveWeapon()
        local vm = ply:GetViewModel()
        OBJECT_TYPE.OnViewModelChanged(ply, plyItem, item, nil, nil, vm, wep)
        ashop.WeaponSkinApply(ply, wep)
    end
end

// All players
function OBJECT_TYPE.OnMetadataUpdate(ply, plyItem, item, metadataKey, oldValue, newValue)
    if !ply:IsPlayer() then
        ashop.WeaponSkinApply(ply, ply.Weapon)
    end
end

ashop.RegisterObjectType(OBJECT_TYPE)
--addons/ashop/lua/ashop/code/ui/cl_fonts.lua:
return gluapack()()
--addons/ashop/lua/ashop/code/ui/item_shop_effects/sh_galaxy.lua:
ashop.itemShopEffects = ashop.itemShopEffects or {}
ashop.itemShopEffects[4] = ashop.itemShopEffects[4] or {
    noCircle = true
}

local grad = Material('akulla/gradient-d')
local bg = Material('akulla/galaxy.jpg', 'smooth')
local matCirclefill = Material('akulla/circlefill.png', 'smooth')
local matCircle = Material('akulla/circle.png', 'smooth')

local eyePos = Vector()
local ang = Angle(0, 0, 0)
local emptyVec = Vector()

ashop.itemShopEffects[4].preDraw = function(pnl, w, h, equipped, clr)
    pnl.rarityClr25 = pnl.rarityClr25 or ColorAlpha(clr, 255*0.05)

    surface.SetMaterial(bg)
    surface.SetDrawColor(255, 255, 255)
    surface.DrawTexturedRect(-(h - w)/2, 0, w + (h - w), h)

    surface.SetMaterial(grad)
    surface.SetDrawColor(pnl.rarityClr25)
    surface.DrawTexturedRect(0, h*0.6, w, h*0.4 )

    local xS, yS = pnl:LocalToScreen(0, 0)
    local c = CurTime()
    pnl.lastspawn = pnl.lastspawn or 0

    cam.Start3D(eyePos, ang, nil, xS, yS, w, h)
        local p = eyePos + ang:Forward()*5 + ang:Up()*15

        if !pnl.particleEmitter then
            pnl.particleEmitter = ParticleEmitter(p)
            pnl.particleEmitter:SetNoDraw(true)
        end

        if pnl.lastspawn + 0.1 < c then
            pnl.lastspawn = c
            local vec = Vector(10, math.Rand(20, -20), math.Rand(-40, 10))

            local part2 = pnl.particleEmitter:Add( matCircle, p + vec )
            if ( part2 ) then
                part2:SetDieTime( 3 ) -- How long the particle should "live"
            
                part2:SetStartAlpha( 10 ) -- Starting alpha of the particle
                part2:SetEndAlpha( 0 ) -- Particle size at the end if its lifetime

                part2:SetStartSize( math.Rand(4, 6) ) -- Starting size
                part2:SetEndSize( 0.2 ) -- Size when removed
                part2:SetColor(255, 255, 255)
            
                part2:SetGravity( emptyVec ) -- Gravity of the particle
                part2:SetVelocity( emptyVec ) -- Initial velocity of the particle
            end

            local part = pnl.particleEmitter:Add( matCirclefill, part2:GetPos() )
            if ( part ) then
                part:SetDieTime( 3 ) -- How long the particle should "live"
            
                part:SetStartAlpha( 255 ) -- Starting alpha of the particle
                part:SetEndAlpha( 0 ) -- Particle size at the end if its lifetime

                part:SetStartSize( math.Rand(0.4, 0.8) )
                part:SetEndSize( 0.2 )
                part:SetColor(255, 255, 255)
            
                part:SetGravity( part2:GetGravity() ) -- Gravity of the particle
                part:SetVelocity( emptyVec ) -- Initial velocity of the particle
            end

        end

        pnl.particleEmitter:Draw()
    cam.End3D()

    surface.SetDrawColor(clr)
    surface.DrawRect(0, h-2, w, 2)

    return true
end
--addons/ashop/lua/ashop/code/ui/panels/cl_askbox.lua:
return gluapack()()
--addons/ashop/lua/ashop/code/ui/panels/cl_avatartooltip.lua:
return gluapack()()
--addons/ashop/lua/ashop/code/ui/panels/cl_dcombobox.lua:
local PANEL = {}

Derma_Hook( PANEL, "Paint", "Paint", "ComboBox" )

Derma_Install_Convar_Functions( PANEL )

AccessorFunc( PANEL, "m_bDoSort", "SortItems", FORCE_BOOL )

function PANEL:Init()

	self.DropButton = vgui.Create( "DPanel", self )
	self.DropButton.Paint = function( panel, w, h ) derma.SkinHook( "Paint", "ComboDownArrow", panel, w, h ) end
	self.DropButton:SetMouseInputEnabled( false )
	self.DropButton.ComboBox = self

	self:SetTall( 22 )
	self:Clear()

	self:SetContentAlignment( 4 )
	self:SetTextInset( 8, 0 )
	self:SetIsMenu( true )
	self:SetSortItems( true )
	self:SetTextColor(ashop.GetColor('White'))
	self:SetFont('ashop_14')
	self:SetTall(ashop.GetFontHeight(self:GetFont()) * 1.5)
end

local focusColor = ashop.GetColor('Grad1_0')
local lockedColor = ashop.GetColor('Grad1_1')

function PANEL:Paint( w, h )
	local c = focusColor
	
	if ( self:GetDisabled() ) then
		c = lockedColor
	end
	draw.RoundedBox(ashop.Config.round/2, 0, 0, w, h, c)
end

function PANEL:Clear()

	self:SetText( "" )
	self.Choices = {}
	self.Data = {}
	self.ChoiceIcons = {}
	self.Spacers = {}
	self.selected = nil

	if ( self.Menu ) then
		self.Menu:Remove()
		self.Menu = nil
	end

end

function PANEL:GetOptionText( id )

	return self.Choices[ id ]

end

function PANEL:GetOptionData( id )

	return self.Data[ id ]

end

function PANEL:GetOptionTextByData( data )

	for id, dat in pairs( self.Data ) do
		if ( dat == data ) then
			return self:GetOptionText( id )
		end
	end

	-- Try interpreting it as a number
	for id, dat in pairs( self.Data ) do
		if ( dat == tonumber( data ) ) then
			return self:GetOptionText( id )
		end
	end

	-- In case we fail
	return data

end

function PANEL:PerformLayout()

	self.DropButton:SetSize( 15, 15 )
	self.DropButton:AlignRight( 4 )
	self.DropButton:CenterVertical()

	-- Make sure the text color is updated
	DButton.PerformLayout( self, w, h )

end

function PANEL:ChooseOption( value, index )

	if ( self.Menu ) then
		self.Menu:Remove()
		self.Menu = nil
	end

	self:SetText( value )

	-- This should really be the here, but it is too late now and convar changes are handled differently by different child elements
	--self:ConVarChanged( self.Data[ index ] )

	self.selected = index
	self:OnSelect( index, value, self.Data[ index ] )

end

function PANEL:ChooseOptionID( index )

	local value = self:GetOptionText( index )
	self:ChooseOption( value, index )

end

function PANEL:GetSelectedID()

	return self.selected

end

function PANEL:GetSelected()

	if ( !self.selected ) then return end

	return self:GetOptionText( self.selected ), self:GetOptionData( self.selected )

end

function PANEL:OnSelect( index, value, data )

	-- For override

end

function PANEL:OnMenuOpened( menu )

	-- For override

end

function PANEL:AddSpacer()

	self.Spacers[ #self.Choices ] = true

end

function PANEL:AddChoice( value, data, select, icon )

	local i = table.insert( self.Choices, value )

	if ( data ) then
		self.Data[ i ] = data
	end
	
	if ( icon ) then
		self.ChoiceIcons[ i ] = icon
	end

	if ( select ) then

		self:ChooseOption( value, i )

	end

	return i

end

function PANEL:IsMenuOpen()

	return IsValid( self.Menu ) && self.Menu:IsVisible()

end

function PANEL:OpenMenu( pControlOpener )

	if ( pControlOpener && pControlOpener == self.TextEntry ) then
		return
	end

	-- Don't do anything if there aren't any options..
	if ( #self.Choices == 0 ) then return end

	-- If the menu still exists and hasn't been deleted
	-- then just close it and don't open a new one.
	if ( IsValid( self.Menu ) ) then
		self.Menu:Remove()
		self.Menu = nil
	end

	-- If we have a modal parent at some level, we gotta parent to that or our menu items are not gonna be selectable
	local parent = self
	while ( IsValid( parent ) && !parent:IsModal() ) do
		parent = parent:GetParent()
	end
	if ( !IsValid( parent ) ) then parent = self end

	self.Menu = DermaMenu( false, parent )

	if ( self:GetSortItems() ) then
		local sorted = {}
		for k, v in pairs( self.Choices ) do
			local val = tostring( v ) --tonumber( v ) || v -- This would make nicer number sorting, but SortedPairsByMemberValue doesn't seem to like number-string mixing
			if ( string.len( val ) > 1 && !tonumber( val ) && val:StartWith( "#" ) ) then val = language.GetPhrase( val:sub( 2 ) ) end
			table.insert( sorted, { id = k, data = v, label = val } )
		end
		for k, v in SortedPairsByMemberValue( sorted, "label" ) do
			local option = self.Menu:AddOption( v.data, function() self:ChooseOption( v.data, v.id ) end )
			if ( self.ChoiceIcons[ v.id ] ) then
				option:SetIcon( self.ChoiceIcons[ v.id ] )
			end
			if ( self.Spacers[ v.id ] ) then
				self.Menu:AddSpacer()
			end
		end
	else
		for k, v in pairs( self.Choices ) do
			local option = self.Menu:AddOption( v, function() self:ChooseOption( v, k ) end )
			if ( self.ChoiceIcons[ k ] ) then
				option:SetIcon( self.ChoiceIcons[ k ] )
			end
			if ( self.Spacers[ k ] ) then
				self.Menu:AddSpacer()
			end
		end
	end

	local x, y = self:LocalToScreen( 0, self:GetTall() )

	self.Menu:SetMinimumWidth( self:GetWide() )
	self.Menu:Open( x, y, false, self )

	self:OnMenuOpened( self.Menu )

end

function PANEL:CloseMenu()

	if ( IsValid( self.Menu ) ) then
		self.Menu:Remove()
	end

end

-- This really should use a convar change hook
function PANEL:CheckConVarChanges()

	if ( !self.m_strConVar ) then return end

	local strValue = GetConVarString( self.m_strConVar )
	if ( self.m_strConVarValue == strValue ) then return end

	self.m_strConVarValue = strValue

	self:SetValue( self:GetOptionTextByData( self.m_strConVarValue ) )

end

function PANEL:Think()

	self:CheckConVarChanges()

end

function PANEL:SetValue( strValue )

	self:SetText( strValue )

end

function PANEL:DoClick()

	if ( self:IsMenuOpen() ) then
		return self:CloseMenu()
	end

	self:OpenMenu()

end

derma.DefineControl( "AShop_DComboBox", "A simple TextEntry control", PANEL, "DButton" )
--addons/ashop/lua/ashop/code/ui/panels/cl_dtextentry.lua:

local PANEL = {}

local strAllowedNumericCharacters = "1234567890.-"

AccessorFunc( PANEL, "m_bAllowEnter", "EnterAllowed", FORCE_BOOL )
AccessorFunc( PANEL, "m_bUpdateOnType", "UpdateOnType", FORCE_BOOL ) -- Update the convar as we type
AccessorFunc( PANEL, "m_bNumeric", "Numeric", FORCE_BOOL )
AccessorFunc( PANEL, "m_bHistory", "HistoryEnabled", FORCE_BOOL )
AccessorFunc( PANEL, "m_bDisableTabbing", "TabbingDisabled", FORCE_BOOL )

AccessorFunc( PANEL, "m_FontName", "Font" )
AccessorFunc( PANEL, "m_bBorder", "DrawBorder" )
AccessorFunc( PANEL, "m_bBackground", "PaintBackground" )
AccessorFunc( PANEL, "m_bBackground", "DrawBackground" ) -- Deprecated

AccessorFunc( PANEL, "m_colText", "TextColor" )
AccessorFunc( PANEL, "m_colHighlight", "HighlightColor" )
AccessorFunc( PANEL, "m_colCursor", "CursorColor" )

AccessorFunc( PANEL, "m_colPlaceholder", "PlaceholderColor" )
AccessorFunc( PANEL, "m_txtPlaceholder", "PlaceholderText" )

Derma_Install_Convar_Functions( PANEL )

function PANEL:Init()

	self:SetHistoryEnabled( false )
	self.History = {}
	self.HistoryPos = 0

	--
	-- We're going to draw these ourselves in
	-- the skin system - so disable them here.
	-- This will leave it only drawing text.
	--
	self:SetPaintBorderEnabled( false )
	self:SetPaintBackgroundEnabled( false )

	--
	-- These are Lua side commands
	-- Defined above using AccessorFunc
	--
	self:SetDrawBorder( true )
	self:SetPaintBackground( true )
	self:SetEnterAllowed( true )
	self:SetUpdateOnType( false )
	self:SetNumeric( false )
	self:SetAllowNonAsciiCharacters( true )

	-- Nicer default height
	self:SetTall( 20 )

	-- Clear keyboard focus when we click away
	self.m_bLoseFocusOnClickAway = true

	-- Beam Me Up Scotty
	self:SetCursor( "beam" )

	self:SetFont( "ashop_12" )
    self:SetDrawLanguageID(false)
    self:SetDrawLanguageIDAtLeft(false)
	self:SetHighlightColor(ashop.GetColor('StateOn'))
	self:SetCursorColor(ashop.GetColor('White'))

end

local focusOutline = ashop.GetColor('StateOn')
local normalOutline = ashop.GetColor('StateOff')
local lockedOutline = ashop.GetColor('StateOff')

local focusColor = ashop.GetColor('Grad1_0')
local normalColor = focusColor
local lockedColor = ashop.GetColor('Grad1_1')

function PANEL:Paint( w, h )
	if self:HasFocus() then
		draw.RoundedBox(ashop.Config.round/2, 0, 0, w, h, self.focusOutline or focusOutline)
		draw.RoundedBox(ashop.Config.round/2, 1, 1, w-2, h-2, self.focusColor or focusColor)
	elseif self:GetDisabled() then
		draw.RoundedBox(ashop.Config.round/2, 0, 0, w, h, lockedOutline)
		draw.RoundedBox(ashop.Config.round/2, 1, 1, w-2, h-2, lockedColor)
	else
		draw.RoundedBox(ashop.Config.round/2, 0, 0, w, h, self.normalOutline or normalOutline)
		draw.RoundedBox(ashop.Config.round/2, 1, 1, w-2, h-2, self.normalColor or normalColor)
	end
    local panel = self
    
    -- Hack on a hack, but this produces the most close appearance to what it will actually look if text was actually there
    if ( panel.GetPlaceholderText && panel.GetPlaceholderColor && panel:GetPlaceholderText() && panel:GetPlaceholderText():Trim() != "" && panel:GetPlaceholderColor() && ( !panel:GetText() || panel:GetText() == "" ) ) then
        local oldText = panel:GetText()
        
        local str = panel:GetPlaceholderText()
        if ( str:StartWith( "#" ) ) then str = str:sub( 2 ) end
        str = language.GetPhrase( str )
        
        panel:SetText( str )
        panel:DrawTextEntryText( panel:GetPlaceholderColor(), panel:GetHighlightColor(), panel:GetCursorColor() )
        panel:SetText( oldText )
        
        return
    end
    
    panel:DrawTextEntryText( panel:GetTextColor(), panel:GetHighlightColor(), panel:GetCursorColor() )
    
	return false
end

derma.DefineControl( "AShop_DTextEntry", "A simple TextEntry control", PANEL, "DTextEntry" )
--addons/ashop/lua/ashop/code/ui/panels/cl_form.lua:
local stateOff = ashop.GetColor('StateOff')
local white = ashop.GetColor('White')

local clr = ashop.GetColor('Grad1_1')
local r = ashop.Config.round
local c1R, c1G, c1B = ashop.GetColor('Grad1_0'):Unpack()
local c2R, c2G, c2B = ashop.GetColor('Grad1_1'):Unpack()
local grad = Material('akulla/gradient-d')

local PANEL = {}

function PANEL:Init()
    self:SetMouseInputEnabled(true)
    self:SetKeyboardInputEnabled(true)
end

function PANEL:CrossClose()
    self.buttons:Remove()

    local close = vgui.Create('DButton', self.title)
    close:Dock(RIGHT)
    close:SetFont('ashop_16_600')
    close:SetText('x')
    close:SetPaintBackground(false)
    close:SetTextColor(color_white)
    close:SetWide(self.title:GetTall())

    close.DoClick = function(s)
        self:Remove()
    end
end

function PANEL:Init()
    self:SetSize(ScrW()/2, ScrH()/2)
    local marginVertical = ashop.GetSize(20)
    self:DockPadding(marginVertical/2, marginVertical/2, marginVertical/2, marginVertical/2)
    
    local title = vgui.Create('DLabel', self)
    title:SetFont('ashop_14_600')
    title:SetTall(ashop.GetFontHeight('ashop_14_600'))
    title:Dock(TOP)
    title:SetContentAlignment(4)
    title:SetMouseInputEnabled(true)
    title:SetTextColor(color_white)
    self.title = title

    local top = ashop.GetFontHeight('ashop_14_600')
    local buttons = vgui.Create('EditablePanel', self)
    buttons:Dock(BOTTOM)
    buttons:SetTall(top * 1.5)
    buttons:DockMargin(0, marginVertical/2, 0, 0)
    self.buttons = buttons

    local cancel = vgui.Create("DButton", buttons)
    cancel:Dock(LEFT)
    cancel:SetFont('ashop_14_600')
    cancel:SetWide((self:GetWide() - marginVertical)/2 - marginVertical/4)
    cancel:SetText(ashop.L('Cancel'))
    cancel:SetTextColor(white)

    function cancel:Paint(w, h)
        draw.RoundedBox(r/2, 0, 0, w, h, stateOff)
    end

    local send = vgui.Create("DButton", buttons)
    send:Dock(RIGHT)
    send:SetFont('ashop_14_600')
    send:SetWide((self:GetWide() - marginVertical)/2 - marginVertical/4)
    send:SetText(ashop.L('Send'))
    send:SetTextColor(white)

    function send:Paint(w, h)
        draw.RoundedBox(r/2, 0, 0, w, h, stateOff)
    end

    local scroll = vgui.Create('DScrollPanel', self)
    scroll:Dock(FILL)

    send.DoClick = function()
        local keys = {}
        for k, v in ipairs(self.entries) do
            if !v or (!v.ValidInput) or (!v:ValidInput()) then
                return
            end

            if !IsValid(v.nullButton) or v.nullButton.toggled then
                keys[k] = v.currentValue
            end
        end

        self:OnSend(unpack(keys, 1, #self.entries))
        self:Remove()
    end

    cancel.DoClick = function()
        self:Remove()
    end

    ashop.ui.SkinScrollPanel(scroll)
    self.scroll = scroll
    self.entries = {}

    if IsValid(ashop.menu) then
        ashop.menu:PushFocus(self)
    end
end

function PANEL:OnRemove()
    if IsValid(ashop.menu) then
        ashop.menu:PopFocus()
    end
end

function PANEL:ClearAccept()
    self.buttons:Clear()
    local cancel = vgui.Create("DButton", self.buttons)
    cancel:Dock(FILL)
    cancel:SetFont('ashop_14_600')
    cancel:SetText(ashop.L('Cancel'))
    cancel:SetTextColor(white)

    function cancel:Paint(w, h)
        draw.RoundedBox(r/2, 0, 0, w, h, stateOff)
    end
end

function PANEL:OnSend(values)
end

function PANEL:CreateEntry(required, name, type, options, defaultValue)
    local c = vgui.Create('AShop_Entry', self.scroll)
    c:Dock(TOP)
    c:SetTall(0)
    c:DockMargin(0, ashop.GetSize(20), 0, 0)
    c:IsRequired(required)
    c:AddSeparator()

    options = options or {}

    if options.hideSave == nil then
        options.hideSave = true
    end

    if options.nullable == nil then
        options.nullable = !required
    end

    c:SetInput(name, type, defaultValue, options)
    c.boxcolor = ashop.GetColor('Grad2_0')

    table.insert(self.entries, c)

    self:InvalidateLayout( true )
    self:SizeToChildren(false, true)

    return c
end

function PANEL:Paint(w, h)
    draw.RoundedBox(r, 0, 0, w, h, clr)
end

function PANEL:SetTitle(t)
    self.title:SetText(t)
end

function PANEL:Paint(w, h)
    self.boxPoly = self.boxPoly or ashop.ui.RoundedBox(r, 0, 0, w, h)

    ashop.StartStencil()
        draw.NoTexture()
        surface.SetDrawColor(c1R, c1G, c1B)
        surface.DrawPoly(self.boxPoly)
    ashop.ReplaceStencil(1)
        surface.SetDrawColor(c2R, c2G, c2B)
        surface.SetMaterial(grad)
        surface.DrawTexturedRect(0, 0, w, h)
    ashop.EndStencil()
end

derma.DefineControl( "AShop_Form", "", PANEL, "EditablePanel" )
--addons/ashop/lua/ashop/code/ui/panels/cl_navbar.lua:
return gluapack()()
--addons/ashop/lua/ashop/code/ui/panels/cl_tooltip.lua:
local vgui = vgui
local IsValid = IsValid
local Color = Color
local draw = draw
local surface = surface
local derma = derma


--
-- The delay before a tooltip appears
--
local PANEL = {}

function PANEL:Init()
	self:NoClipping(true)
	self:SetDrawOnTop( true )
	self.DeleteContentsOnClose = false

	self.label = vgui.Create("DLabel", self)
	self.label:Dock(FILL)
	self.label:SetFont( "ashop_18" )
	self.label:SetText("")
	self.label:DockMargin(10, 10, 10, 10)
	self.label:SetTextColor(color_white)
end

function PANEL:SetContents( panel, bDelete )
	panel:SetParent( self )

	self.Contents = panel
	self.DeleteContentsOnClose = bDelete or false
	self.Contents:SizeToContents()
	self.Contents:SetVisible( false )
end

function PANEL:PositionTooltip()
	if ( !IsValid( self.TargetPanel ) ) then
		self:Close()
		return
	end

	local w, h = self.TargetPanel:GetSize()
	local w2, h2 = self:GetSize()
	local x, y = self.TargetPanel:LocalToScreen(w/2 - w2/2, -h2 - 10)

	self:SetPos(x, y)
end

local blue = ashop.GetColor('StateOff')
local blueR, blueG, blueB = blue:Unpack()
function PANEL:Paint( w, h )
	if !self.cachePoly then
		self.cachePoly = {
			{x = w/2 - 5, y = h },
			{x = w/2 + 5, y = h },
			{x = w/2, y = h + 5 },
		}
	end
	self:PositionTooltip()

	draw.RoundedBox(4, 0, 0, w, h, blue)

	surface.SetDrawColor(blueR, blueG, blueB)
	draw.NoTexture()
	surface.DrawPoly(self.cachePoly)

	local txtw, txth = self.label:GetTextSize()
	self:SetSize(txtw + 20, txth + 20)
end

function PANEL:SetText(txt)
	self.cachePoly = nil
	self.label:SetText(txt)
end

function PANEL:OpenForPanel( panel )
	if string.len(self.label:GetText()) == 0 then return end

	self.TargetPanel = panel

	surface.SetFont("ashop_18")
	local size_x, sizey = surface.GetTextSize(self.label:GetText())

	self:SetSize(size_x + 20, sizey + 20)
	self:PositionTooltip()
	self:SetVisible( true )
end

function PANEL:Close()
	self:Remove()
end

derma.DefineControl( "AShop_Tooltip", "", PANEL, "DPanel" )
--addons/ashop/lua/ashop/code/ui/panels_actions/cl_tradescreate.lua:
ashop.tradesList = ashop.tradesList or {}

gameevent.Listen( "player_disconnect" )
hook.Add( "player_disconnect", "ashop_removependingtrades", function( data )
	local ply = Player(data.userid)

    if IsValid(ply) then
        table.RemoveByValue(ashop.tradesList, ply)
    end
end )

local function drawInterior(editor, tradingPly, _, parent)
    ashop.ui.popAskbox(ashop.L('SendTradeInvitation', tradingPly:Nick()), ashop.L('NeedsToAcceptAfterward'), function()
        net.Start('ashop_trades')
            net.WriteUInt(0, 3)
            net.WriteEntity(tradingPly)
        net.SendToServer()

        ashop.DermaNotify(ashop.L('TradeSent', tradingPly:Nick()), NOTIFY_HINT, 5)
    end)
end

ashop.registerUserParameter(ashop.L('TradeCreate'), drawInterior, function()
    local o = {}
    local t = {}

    for k, v in ipairs(ashop.tradesList) do
        if !IsValid(v) then
            table.remove(ashop.tradesList, v)
            continue
        end

        t[v] = true
    end

    local lply = LocalPlayer()
    for k, v in ipairs(player.GetHumans()) do
        if t[v] or v == lply then continue end
        local name = v:Nick()
        table.insert(o, {name, v, v})
    end

    return o
end, interior)
--addons/ashop/lua/ashop/code/ui/panels_settings/cl_object_types.lua:
local r = ashop.Config.round
local c2 = ashop.GetColor('Grad1_1')
local grad = Material('akulla/gradient-d')

local function getFormatted(tabNum, t)
    local str = ""

    for k, v in pairs(t) do
        local s = nil
        if isvector(v) then
            s = string.format("Vector(%s, %s, %s)", v:Unpack())
        elseif isangle(v) then
            s = string.format("Angle(%s, %s, %s)", v:Unpack())
        elseif IsColor(v) then
            s = string.format("Color(%s, %s, %s)", v:Unpack())
        elseif isstring(v) then
            s = "'" .. v .. "'"
        elseif isnumber(v) then
            s = v
        elseif istable(v) then
            s = ""
            s = s .. "{" .. getFormatted(tabNum + 1, v) .. "\n" .. string.rep("    ", tabNum) .. "}"
        elseif isbool(v) then
            s = v and "true" or "false"
        end

        assert(s, 's is not initialized for "export as premade", type of v: ' .. type(v))

        if isstring(k) then
            str = str .. '\n' .. string.rep("    ", tabNum) .. k .. ' = ' .. s .. ","
        else
            str = str .. '\n' .. string.rep("    ", tabNum) .. '[' .. k .. '] = ' .. s .. ","
        end
    end

    return str
end

local function DrawInterior(editor, key, value, parent)
    local scroll = vgui.Create("DScrollPanel", editor)
    scroll:Dock(FILL)

    local stateOff = ashop.GetColor('StateOff')
    local vbar = scroll:GetVBar()
    vbar:SetWide(1)
    function vbar.btnUp:Paint() end
    function vbar.btnDown:Paint() end
    function vbar:Paint(w, h) end

    function vbar.btnGrip:Paint(w, h)
        DisableClipping(true)
        draw.RoundedBox(2, w + 4, 0, 2, h, stateOff)
        DisableClipping(false )
    end

    local nameContainer = vgui.Create('AShop_Entry', scroll)
    nameContainer:Dock(TOP)
    nameContainer:SetTall(0)
    nameContainer:IsRequired(true)
    nameContainer:SetInput(ashop.L('Name'), TYPE_STRING, parent:GetText(), {
        required = true,
        maxLength = 24
    })
    nameContainer:AddSeparator()

    function nameContainer:OnSave(value)
        if !self:ValidInput() then return end
        parent:SetText(value)

        net.Start('ashop_EditObjectType')
            net.WriteBool(value[1])
            net.WriteUInt(key, ashop.Config.BitsObjectType)

            if !value[1] then
                net.WriteUInt(value[4], ashop.Config.BitsSubObjectType)
            end

            net.WriteBool(false)
            net.WriteString(value)
        net.SendToServer()
    end

    local parentClass = vgui.Create('AShop_Entry', scroll)
    parentClass:Dock(TOP)
    parentClass:SetTall(0)
    //parentClass:DockMargin(0, ashop.GetSize(20), 0, 0)
    parentClass:IsRequired(true)
    parentClass:SetInput(ashop.L('ParentContainer'), TYPE_STRING, !value[1] and value[2].Name or "", {
        locked = true,
        required = true
    })
    parentClass.boxcolor = ashop.GetColor('Grad2_0')
    parentClass:AddSeparator()

    local parentClass = vgui.Create('AShop_Entry', scroll)
    parentClass:Dock(TOP)
    parentClass:SetTall(0)
    //parentClass:DockMargin(0, ashop.GetSize(20), 0, 0)
    parentClass:IsRequired(true)
    parentClass:SetInput(ashop.L('HowMuchItemAreEquipable'), "UInt8", !value[1] and value[3].slotSize or value[2].slotSize, {
        locked = !(value[2].SlotDefault and !value[2].BlockSlotEdit),
        required = true
    })
    parentClass.boxcolor = ashop.GetColor('Grad2_0')
    parentClass:AddSeparator()

    function parentClass:OnSave(val)
        local _, msg = self:ValidInput()
        if msg then
            ashop.DermaNotify(msg, 1, 5)
            return
        end

        net.Start('ashop_EditObjectType')
            net.WriteBool(value[1])
            net.WriteUInt(key, ashop.Config.BitsObjectType)

            if !value[1] then
                net.WriteUInt(value[4], ashop.Config.BitsSubObjectType)
            end

            net.WriteBool(true)
            net.WriteUInt(val, 8)
        net.SendToServer()
    end

    if value[2] and value[2].SubCategoriesParameters then
        for k, v in pairs(value[2].SubCategoriesParameters) do
            // get metadata from this sub_cat
            local objectType = vgui.Create('AShop_Entry', scroll)
            objectType:Dock(TOP)
            //objectType:DockMargin(0, ashop.GetSize(20), 0, 0)
            objectType:SetInput(v[1], v[2], value[3].metadata[k], {required = true})
            objectType:AddSeparator()
    
            function objectType:OnSave(valueSave)
                if !self:ValidInput() then return end
                net.Start('ashop_SubObjectType_Edit')
                    net.WriteUInt(key, ashop.Config.BitsObjectType)
                    net.WriteUInt(value[4], ashop.Config.BitsObjectType)
                    net.WriteUInt(k, 7)
        
                    ashop.Network.GetWriteFunction(v[2], valueSave, {
                        required = true
                    })
                net.SendToServer()
            end
            objectType.boxcolor = ashop.GetColor('Grad2_0')
        end
    end

    local marginVertical = ashop.GetSize(20)
    local bonusPanelName = vgui.Create("DLabel", scroll)
    local m = ashop.GetSize(16)
    bonusPanelName:Dock(TOP)
    bonusPanelName:DockMargin(m, m, m, m/2)
    bonusPanelName:SetText(ashop.L('ItemList'))
    bonusPanelName:SetFont("ashop_14_600")
    bonusPanelName:SetMouseInputEnabled(true)
    bonusPanelName:SetKeyboardInputEnabled(true)
    bonusPanelName:SetTextColor(color_white)

    local createItem = vgui.Create('DButton', bonusPanelName)
    createItem:Dock(RIGHT)
    createItem:SetContentAlignment(6)
    createItem:SetText(ashop.L('Create'))
    createItem:SetTextColor(ashop.GetColor('White'))
    createItem:SetFont('ashop_14')
    createItem:SetPaintBackground(false)
    createItem:SetWide(createItem:GetContentSize())

    function createItem:DoClick()
        local selects = {}

        for k, v in pairs(ashop.rarity) do
            table.insert(selects, {v.name, v.id})
        end

        local a = vgui.Create('AShop_Form', ashop.menu)
        a:SetTitle('Create a Item')
        a:CreateEntry(true, ashop.L('Name'), TYPE_STRING, {
            required = true,
            maxLength = 24
        })
        a:CreateEntry(true, ashop.L('Rarity'), 'SELECT', {
            selects = selects,
            required = true
        })
        a:CreateEntry(false, ashop.L('Price'), 'UInt32')
        a:CreateEntry(false, ashop.L('PremiumPrice'), 'UInt32')
        a:CreateEntry(false, ashop.L('DeleteOnDeathWhenEquipped'), TYPE_BOOL)
        a:CreateEntry(false, ashop.L('PromotionStart'), 'DATE')
        a:CreateEntry(false, ashop.L('PromotionEnd'), 'DATE')
        a:CreateEntry(false, ashop.L('PromotionAmount'), 'UInt7')
        a:CreateEntry(false, ashop.L('PictureLink'), TYPE_STRING)
        a:CreateEntry(false, ashop.L('GroupRestrained'), 'SELECT', {
            selects = ashop.GetGroupRestrictsAsSelect(),
            default = ""
        })

        for k, v in SortedPairs(value[2].ItemParameters or {}) do
            if v.userEditable then continue end
            local p = a:CreateEntry(v.options and v.options.required, v.name, v.type, v.options, v.defaultValue)
            p.itemParam = k
        end

        // Loop ItemParameters
        function a:OnSend(name, rarity, price, premium_price, deleteOnDeath, promotion_start, promotion_end, promotion_amount, picture_link, group_restrained, ...)
            local t = {...}

            net.Start('ashop_Item_New')
                net.WriteUInt(key, ashop.Config.BitsObjectType)

                net.WriteBool(!value[1])

                if !value[1] then
                    net.WriteUInt(value[4], ashop.Config.BitsObjectType)
                end

                net.WriteString(name)
                net.WriteUInt(rarity, ashop.Config.BitsRarity)

                net.WriteBool(price)
                if price then
                    net.WriteUInt(price, 32)
                end

                net.WriteBool(premium_price)
                if premium_price then
                    net.WriteUInt(premium_price, 32)
                end

                net.WriteBool(deleteOnDeath)

                net.WriteBool(promotion_start)
                if promotion_start then
                    net.WriteUInt(promotion_start, 32)
                end

                net.WriteBool(promotion_end)
                if promotion_end then
                    net.WriteUInt(promotion_end, 32)
                end

                net.WriteBool(promotion_amount)
                if promotion_amount then
                    net.WriteUInt(promotion_amount, 7)
                end

                net.WriteBool(picture_link)
                if picture_link then
                    net.WriteString(picture_link)
                end

                net.WriteBool(group_restrained != nil and group_restrained != "")
                if group_restrained != nil and group_restrained != "" then
                    net.WriteUInt(group_restrained, ashop.Config.BitsGroupRank)
                end

                net.WriteBool(expireTime != nil)
                if expireTime != nil then
                    net.WriteUInt(expireTime, 32)
                end

                local incr = 0
                for k, v in SortedPairs(ashop.object_types[key].ItemParameters) do
                    if v.userEditable then continue end
                    incr = incr + 1

                    if t[incr] == nil then
                        net.WriteBool(false)
                    else
                        net.WriteBool(true)
                        ashop.Network.GetWriteFunction(v.type, t[incr], v.options)
                    end
                end
            net.SendToServer()
        end
        a:Center()
    end

    local items = vgui.Create('DIconLayout', scroll)
    items:Dock(TOP)
    items:SetSpaceY(marginVertical)
    items:SetSpaceX(marginVertical)
    items:DockMargin(0, 0, 0, 0)

    local itemWidth = math.floor((editor:GetWide() - marginVertical * 6) / 7) - 1
    local itemsByIDs = {}

    local function createUIItem(k, v)
        if key != v.object_types or !((v.sub_types and v.sub_types == value[3].id) or (!v.sub_types and !value[3])) then return end

        // Derma
        local p = vgui.Create("AShop_ShopItem", items)
        p:SetSize(itemWidth, ashop.GetSize(189))
        itemsByIDs[k] = p

        function p:Paint()
            p:SetItem(nil, k, true)
        end

        function p:DoClick()
            local itemCopy = table.Copy(v)
            // Hack
            itemCopy.id = -itemCopy.id
            ashop.items[itemCopy.id] = itemCopy

            local selects = {}
        
            for k, v in pairs(ashop.rarity) do
                table.insert(selects, {v.name, v.id})
            end
        
            local a = vgui.Create('AShop_Form', ashop.menu)
            a:SetTitle(ashop.L('ModifyAItem'))
            a:CenterVertical(0.5)
            a:CrossClose()

            local displayEdit = vgui.Create('EditablePanel', ashop.menu)
            displayEdit:SetPaintedManually(true)
            displayEdit:SetSize(ScrW()*0.1, ScrH()/2)
            displayEdit:SetZPos(12)

            local itemDisplay = vgui.Create('AShop_ShopItem', displayEdit)
            itemDisplay:Dock(TOP)
            itemDisplay:SetTall(displayEdit:GetWide())
            itemDisplay:DockMargin(0, 0, 0, marginVertical)

            // Hack
            // SetItem will override this paint, so we use SetItem only 1 time
            function itemDisplay:Paint()
                self:SetItem(nil, itemCopy, true)
            end

            local modelPanel = vgui.Create('AShop_DModelPanel', displayEdit)
            modelPanel:Dock(FILL)
            modelPanel:SetLookAt( Vector( 0, 0, 0 ) )
            modelPanel:SetModel(LocalPlayer():GetModel())
            modelPanel:EquipWeapon()
            modelPanel:DoClick()
            modelPanel:SetFOV( 45 )
            modelPanel.Entity:SetSequence("idle_passive")
            function modelPanel:LayoutEntity( ent ) end
            modelPanel:BoneFocus('ValveBiped.Bip01_Spine2')
            local plyItemTemp = modelPanel:EquipItem(nil, nil, itemCopy.id)

            function modelPanel:OnRemove()
                ashop.items[itemCopy.id] = nil
            end

            local realCenterX = (ashop.menu:GetWide() - displayEdit:GetWide() - a:GetWide() - marginVertical) /2
            a:SetPos(realCenterX, a:GetY())
            displayEdit:SetPos(a:GetWide() + a:GetX() + marginVertical, a:GetY())

            local oldPaint = a.Paint

            function a:Paint(w, h)
                oldPaint(self, w, h)
                DisableClipping(true)
                displayEdit:PaintManual()
                DisableClipping(false)
            end

            local oldRemoveA = a.OnRemove

            function a:OnRemove()
                if oldRemoveA then
                    oldRemoveA(a)
                end

                displayEdit:Remove()
            end

            local entries = {}
            table.insert(entries, a:CreateEntry(true, ashop.L('Name'), TYPE_STRING, {
                required = true,
                hideSave = false,
                itemNameParam = "name",
                maxLength = 24
            }, v.name))
            table.insert(entries, a:CreateEntry(true, ashop.L('Rarity'), 'SELECT', {
                selects = selects,
                hideSave = false,
                itemNameParam = "rarity",
                required = true
            },  v.rarity))
            table.insert(entries, a:CreateEntry(false, ashop.L('Price'), 'UInt32', {hideSave = false, itemNameParam = "price"}, v.price or 0))
            table.insert(entries, a:CreateEntry(false, ashop.L('PremiumPrice'), 'UInt32', {hideSave = false, itemNameParam = "premium_price"}, v.premium_price or 0))
            table.insert(entries, a:CreateEntry(false, ashop.L('DeleteOnDeathWhenEquipped'), TYPE_BOOL, {hideSave = false, itemNameParam = "delete_death"}, v.delete_death))
            table.insert(entries, a:CreateEntry(false, ashop.L('PromotionStart'), 'DATE', {hideSave = false, itemNameParam = "promotion_start"}, v.promotion_start))
            table.insert(entries, a:CreateEntry(false, ashop.L('PromotionEnd'), 'DATE', {hideSave = false, itemNameParam = "promotion_end"}, v.promotion_end))
            table.insert(entries, a:CreateEntry(false, ashop.L('PromotionAmount'), 'UInt7', {hideSave = false, itemNameParam = "promotion_amount"}, v.promotion_amount))
            table.insert(entries, a:CreateEntry(false, ashop.L('PictureLink'), TYPE_STRING, {hideSave = false, itemNameParam = "picture_link"}, v.picture_link))
            table.insert(entries, a:CreateEntry(false, ashop.L('GroupRestrained'), 'SELECT', {selects = ashop.GetGroupRestrictsAsSelect() or {}, outputType = 'UInt10', hideSave = false, itemNameParam = "group_restrained"}, v.group_restrained))
            table.insert(entries, a:CreateEntry(false, ashop.L('ExpireTime'), 'UInt32', {hideSave = false, itemNameParam = "expireTime"}, v.expireTime))

            for inputID, entryPanel in ipairs(entries) do
                function entryPanel:OnValueChanged(value)
                    if !self:ValidInput() then return end
                    itemCopy[self.options.itemNameParam] = value
                    itemDisplay:SetItem(nil, itemCopy, true)
                end
    
                function entryPanel:OnSave(value)
                    if !self:ValidInput() then return end

                    net.Start('ashop_Item_Edit')
                        net.WriteUInt(inputID, 7)
                        net.WriteUInt(k, ashop.Config.BitsItemID)

                        if inputID == 2 then
                            net.WriteUInt(value, ashop.Config.BitsRarity)
                        elseif inputID == 5 then
                            net.WriteBool(value)
                        else
                            ashop.Network.GetWriteFunction(entryPanel.type, value, self.options)
                        end

                    net.SendToServer()
                end
            end
        
            for itemParamID, itemParam in SortedPairs(value[2].ItemParameters or {}) do
                if itemParam.userEditable then continue end
                local o = table.Copy(itemParam.options or {})
                o.hideSave = false

                local defaultValue = (v.metadata or {})[itemParamID]

                if itemParam.type == TYPE_COLOR and defaultValue and !IsColor(defaultValue) then
                    defaultValue = Color(defaultValue.r, defaultValue.g, defaultValue.b, defaultValue.a)
                end

                local pEntry = a:CreateEntry(itemParam.options and itemParam.options.required, itemParam.name, itemParam.type, o, defaultValue)
                pEntry.itemParam = itemParamID

                function pEntry:OnValueChanged(saveValue)
                    if !self:ValidInput() then return end
                    local old = itemCopy.metadata[itemParamID]
                    itemCopy.metadata[itemParamID] = saveValue
                    itemDisplay:SetItem(nil, itemCopy, true)

                    if value[2].OnMetadataUpdate then
                        value[2].OnMetadataUpdate(modelPanel.Entity, modelPanel.Entity.ashop_data.items[plyItemTemp], itemCopy, itemParamID, old, saveValue)
                    end

                    //ashop.EquipChange(modelPanel.Entity, plyItemTemp, nil, true)
                    //ashop.EquipChange(modelPanel.Entity, plyItemTemp, nil, false)
                end

                function pEntry:OnSave(value)
                    if !self:ValidInput() then return end

                    net.Start('ashop_Item_Edit')
                        net.WriteUInt(itemParamID+11, 7)
                        net.WriteUInt(k, ashop.Config.BitsItemID)
                        ashop.Network.GetWriteFunction(self.type, value, itemParam.options)
                    net.SendToServer()
                end
            end
        end

        function p:DoRightClick()
            // Menus
            CloseDermaMenus()
            local menu = vgui.Create( "AShop_DMenu", p )

            for refundID, txt in ipairs({{
                ashop.L('WarningDeleteItem'),
                ashop.L('WarningDeleteItem'),
                ashop.L('WarningDeleteItem2')
            }, {
                ashop.L('WarningDeleteItemRefund'),
                ashop.L('WarningDeleteItemRefund'),
                ashop.L('WarningDeleteItemRefund2')
            }}) do
                menu:AddOption(txt[1], function()
                    ashop.ui.popAskbox(txt[2], txt[3], function()
                        net.Start('ashop_Item_Delete')
                            net.WriteUInt(k, ashop.Config.BitsItemID)
                            net.WriteBool(refundID == 1)
                        net.SendToServer()
                    end)
                end)
            end

            menu:AddOption(ashop.L('Duplicate'), function()
                net.Start('ashop_Item_New')
                    net.WriteUInt(key, ashop.Config.BitsObjectType)
        
                    net.WriteBool(v.sub_types)
        
                    if v.sub_types then
                        net.WriteUInt(v.sub_types, ashop.Config.BitsObjectType)
                    end
        
                    net.WriteString(v.name)
                    net.WriteUInt(v.rarity, ashop.Config.BitsRarity)
        
                    net.WriteBool(v.price)
                    if v.price then
                        net.WriteUInt(v.price, 32)
                    end
        
                    net.WriteBool(v.premium_price)
                    if v.premium_price then
                        net.WriteUInt(v.premium_price, 32)
                    end

                    net.WriteBool(v.deleteOnDeath)

                    net.WriteBool(v.promotion_start)
                    if v.promotion_start then
                        net.WriteUInt(v.promotion_start, 32)
                    end

                    net.WriteBool(v.promotion_end)
                    if v.promotion_end then
                        net.WriteUInt(v.promotion_end, 32)
                    end

                    net.WriteBool(v.promotion_amount != nil)
                    if v.promotion_amount != nil then
                        net.WriteUInt(v.promotion_amount, 7)
                    end

                    net.WriteBool(v.picture_link)
                    if v.picture_link then
                        net.WriteString(v.picture_link)
                    end

                    net.WriteBool(v.group_restrained)
                    if v.group_restrained then
                        net.WriteUInt(v.group_restrained, ashop.Config.BitsGroupRank)
                    end

                    net.WriteBool(v.expireTime)
                    if v.expireTime then
                        net.WriteUInt(v.expireTime, 32)
                    end
    
                    for k, itemParam in SortedPairs(ashop.object_types[key].ItemParameters) do
                        if itemParam.userEditable then continue end

                        if v.metadata[k] == nil then
                            net.WriteBool(false)
                        else
                            net.WriteBool(true)
                            ashop.Network.GetWriteFunction(itemParam.type, v.metadata[k], itemParam.options)
                        end
                    end
                net.SendToServer()
            end)

            menu:AddOption(ashop.L('ExportAsPremade'), function()
                local str = "        {"
                str = str .. '\n            name = "' .. v.name .. '",'
                str = str .. '\n            rendering = INSERT,'

                if !v.metadata then
                    str = str .. '\n            metadata = {}'
                else
                    str = str .. getFormatted(3, {metadata = v.metadata})
                end
                str = str .. "\n        },"

                print(str)
                SetClipboardText(str)
            end)

            menu:Open()
        end
    end

    for k, v in pairs(ashop.items) do
        createUIItem(k, v)
    end
    items:SizeToChildren(false, true)

    hook.Add('ashop_itemedit', 'refreshUI', function(item)
        if !IsValid(itemsByIDs[item]) then return end
        itemsByIDs[item]:SetItem(nil, item, true)
    end)

    hook.Add('ashop_itemnew', 'refreshUI', function(itemID, item)
        createUIItem(itemID, item)
    end)

    hook.Add('ashop_itemdelete', 'refreshUI', function(item)
        if !IsValid(itemsByIDs[item]) then return end
        itemsByIDs[item]:Remove()

        items:InvalidateLayout()
    end)
end

ashop.registerParameter(ashop.L('ObjectType'), DrawInterior, function()
    local o = {}

    for k, v in pairs(ashop.object_types) do
        if v.sub_cat then 
            for sub_cat, j in pairs(v.sub_cat) do
                table.insert(o, {j.name, k, {false, v, j, sub_cat}})
            end
        else
            if v.SubCategoriesParameters then continue end
            table.insert(o, {v.Name, k, {true, v}})
        end
    end

    return o
end, function()
    local selects = {}

    for k, v in pairs(ashop.object_types) do
        if v.NoChild or !v.DefaultSubCategories then continue end
        table.insert(selects, {v.Name, k})
    end

    local a = vgui.Create('AShop_Form', ashop.menu)
    a:SetTitle(ashop.L('CreateAObjectCategory'))
    a:CreateEntry(true, 'Name', TYPE_STRING, {
        maxLength = 24
    }).avoid = true
    
    local parent = a:CreateEntry(true, ashop.L('Parent'), 'SELECT', {
        selects = selects,
        default = ashop.L('SelectAParentType')
    })

    parent.avoid = true

    parent.OnValueChanged = function(s, index, name)
        for k, v in pairs(a.entries) do
            if !v.avoid then
                v:Remove()
            end
        end

        s:InvalidateLayout()

        if ashop.object_types[index].SlotDefault and !ashop.object_types[index].BlockSlotEdit then
            a:CreateEntry(true, ashop.L('HowMuchItemsAreEquipable'), "UInt5")
        end

        for k, v in pairs(ashop.object_types[index].SubCategoriesParameters or {}) do
            a:CreateEntry(true, v[1], v[2])
        end
    end

    function a:OnSend(name, index, ...)
        local t = {...}

        net.Start('ashop_SubCat_New')
            net.WriteString(name)
            net.WriteUInt(index, ashop.Config.BitsObjectType)

            if ashop.object_types[index].SlotDefault and !ashop.object_types[index].BlockSlotEdit then
                net.WriteUInt(t[1] or ashop.object_types[index].SlotDefault, 6)

                // Remove the first value of t, so w_bulk works correctly
                table.remove(t, 1)
            end

            local incr = 1
            for k, v in pairs(ashop.object_types[index].SubCategoriesParameters) do
                ashop.Network.GetWriteFunction(v[2], t[incr])
                incr = incr + 1
            end
        net.SendToServer()
    end
    a:Center()
end, function(but, settingButton, objectTarget)
    function but:DoRightClick()
        if !objectTarget[2].sub_cat then return end
        CloseDermaMenus()
        local menu = vgui.Create( "AShop_DMenu", but )

        menu:AddOption(ashop.L('Remove'), function()
            for k, v in pairs(ashop.items) do
                if v.object_types == objectTarget[2].id and v.sub_types == objectTarget[3].id then
                    ashop.DermaNotify(ashop.L('NeedToBeEmpty'), NOTIFY_ERROR, 3)
                    return
                end
            end

            ashop.ui.popAskbox(ashop.L('DeleteThisSubCategory', objectTarget[3].name), "", function()
                net.Start('ashop_ObjectType_Delete')
                    net.WriteUInt(objectTarget[2].id, ashop.Config.BitsObjectType)
                    net.WriteUInt(objectTarget[3].id, ashop.Config.BitsObjectType)
                net.SendToServer()
            end)
        end)

        menu:Open()
    end
end)
--addons/ashop/lua/ashop/code/ui/panels_settings/cl_rarity.lua:
local function DrawInterior(editor, key, value, parent)
    local scroll = vgui.Create("DScrollPanel", editor)
    scroll:Dock(FILL)
    scroll:SetWide(editor:GetWide())

    local nameContainer = vgui.Create('AShop_Entry', scroll)
    nameContainer:Dock(TOP)
    nameContainer:SetTall(0)
    nameContainer:IsRequired(true)
    nameContainer:SetInput(ashop.L('Name'), TYPE_STRING, value.name, {
        maxLength = 18,
        minLength = 4,
        required = true
    })
    nameContainer.boxcolor = ashop.GetColor('Grad2_0')
    nameContainer:AddSeparator()

    function nameContainer:OnSave(value)
        parent:SetText(value)

        net.Start('ashop_Rarity_Edit')
            net.WriteUInt(0, 3)
            net.WriteUInt(key, ashop.Config.BitsRarity)
            net.WriteString(value)
        net.SendToServer()
    end

    local clr = vgui.Create('AShop_Entry', scroll)
    clr:Dock(TOP)
    clr:SetTall(0)
    clr:IsRequired(true)
    clr:SetInput(ashop.L('Color'), TYPE_COLOR, value.clr, {
        required = true
    })
    clr.boxcolor = ashop.GetColor('Grad2_0')
    clr:AddSeparator()

    function clr:OnSave(value)
        net.Start('ashop_Rarity_Edit')
            net.WriteUInt(1, 3)
            net.WriteUInt(key, ashop.Config.BitsRarity)
            net.WriteColor(value)
        net.SendToServer()
    end

    local style = vgui.Create('AShop_Entry', scroll)
    style:Dock(TOP)
    style:SetTall(0)
    style:SetInput(ashop.L('Style'), "UInt8", value.style, {
        required = true
    })
    style.boxcolor = ashop.GetColor('Grad2_0')
    style:AddSeparator()

    function style:OnSave(value)
        net.Start('ashop_Rarity_Edit')
            net.WriteUInt(2, 3)
            net.WriteUInt(key, ashop.Config.BitsRarity)
            net.WriteUInt(value, 8)
        net.SendToServer()
    end

    local notif = vgui.Create('AShop_Entry', scroll)
    notif:Dock(TOP)
    notif:SetTall(0)
    notif:SetInput("Notification on unbox", TYPE_BOOL, value.notif_unbox)
    notif.boxcolor = ashop.GetColor('Grad2_0')
    notif:AddSeparator()

    function notif:OnSave(value)
        net.Start('ashop_Rarity_Edit')
            net.WriteUInt(3, 3)
            net.WriteUInt(key, ashop.Config.BitsRarity)
            net.WriteBool(value)
        net.SendToServer()
    end

    local notifSound = vgui.Create('AShop_Entry', scroll)
    notifSound:Dock(TOP)
    notifSound:SetTall(0)
    notifSound:SetInput("Notification sound on unbox ( URL or audio path )", TYPE_STRING, value.notif_unboxsound, {
        minLength = 0,
        maxLength = 256
    })
    notifSound.boxcolor = ashop.GetColor('Grad2_0')
    notifSound:AddSeparator()

    function notifSound:OnSave(value)
        net.Start('ashop_Rarity_Edit')
            net.WriteUInt(4, 3)
            net.WriteUInt(key, ashop.Config.BitsRarity)

            net.WriteBool(value)

            if value then
                net.WriteString(value)
            end
        net.SendToServer()
    end
end

ashop.registerParameter(ashop.L('Rarity'), DrawInterior, function()
    local o = {}

    for k, v in pairs(ashop.rarity) do
        table.insert(o, {v.name, k, v})
    end

    return o
end, function()
    local a = vgui.Create('AShop_Form', ashop.menu)
    a:SetTitle(ashop.L('CreateARarity'))
    a:CreateEntry(true, ashop.L('Name'), TYPE_STRING, {
        maxLength = 18,
        minLength = 4
    })
    a:CreateEntry(true, ashop.L('Color'), TYPE_COLOR)
    a:CreateEntry(false, ashop.L('Style'), "UInt8")
    a:CreateEntry(false, "Notification on unbox", TYPE_BOOL)
    a:CreateEntry(false, "Notification sound on unbox", TYPE_STRING, {
        minLength = 0,
        maxLength = 256
    })

    function a:OnSend(name, ...)
        local t = {...}

        net.Start('ashop_Rarity_New')
            net.WriteString(name or "")
            net.WriteColor(t[1])

            net.WriteBool(t[2])
            
            if t[2] then
                net.WriteUInt(t[2], 8)
            end

            if t[3] then
                net.WriteBool(t[3])
            end

            if t[4] then
                net.WriteBool(t[4])
            end
        net.SendToServer()
    end
    a:Center()
end, function(but, settingButton, objectTarget)
    function but:DoRightClick()
        CloseDermaMenus()
        local menu = vgui.Create( "AShop_DMenu", but )
        menu:AddOption(ashop.L('Remove'), function()
            // Check if this rarity is applied to items
            local f = 0

            for _, v in pairs(ashop.items) do
                if v.rarity == objectTarget.id then
                    f = f + 1
                end
            end

            if f > 0 then
                ashop.ui.popAskbox(ashop.L('WarningDeleteRankGroup', objectTarget.name, f), ashop.L('CantUndoOperation'), function()
                    net.Start('ashop_Rarity_Delete')
                        net.WriteUInt(objectTarget.id, ashop.Config.BitsRarity)
                    net.SendToServer()
                end)
            else
                ashop.ui.popAskbox(ashop.L('DeleteTheRarity', objectTarget.name), ashop.L('CantUndoOperation'), function()
                    net.Start('ashop_Rarity_Delete')
                        net.WriteUInt(objectTarget.id, ashop.Config.BitsRarity)
                    net.SendToServer()
                end)
            end
        end)

        menu:Open()
    end
end)
--addons/ashop/lua/ashop/code/ui/panels_settings/premades/cl_gtav_facemask.lua:
return gluapack()()
--addons/ashop/lua/ashop/code/ui/panels_settings/premades/cl_gtav_head.lua:
ashop.RegisterPremade("GTAV Head", {
        requireWorkshop = "572310302",

        objectTypes = {
            {
                "Wearables",
                {"ValveBiped.Bip01_Head1"},
                "Hat"
            }
        },

        items = {
        {
            name = "Grey Hat",
            rendering = 1,
            metadata = {
                [1] = 'models/modified/hat01_fix.mdl',
                [3] = Vector(4.375, 0.875, -0.0625),
                [4] = Angle(0.21875, -74.3125, -90),
                [7] = Vector(0.875, 0.875, 0.875),
                [12] = 150,
            }
        },

        {
            name = "Beret 2",
            rendering = 1,
            metadata = {
                [1] = 'models/modified/hat04.mdl',
                [3] = Vector(4.21875, 2.5, -0.375),
                [4] = Angle(0.21875, -56.9375, -90),
                [7] = Vector(0.96875, 0.96875, 1),
            }
        },

        {
            name = "Cap",
            rendering = 1,
            metadata = {
                [1] = 'models/modified/hat05.mdl',
                [3] = Vector(3.8125, 0.46875, -0.375),
                [4] = Angle(0.21875, -68.8125, -90),
                [7] = Vector(1, 1, 1),
                [11] = 1,
            }
        },

        {
            name = "Cap 2",
            rendering = 1,
            metadata = {
                [1] = 'models/modified/hat06.mdl',
                [3] = Vector(4.4375, 0.96875, 0.375),
                [4] = Angle(10.71875, -68.8125, -90),
                [7] = Vector(1, 1, 1),
                [11] = 1,
            }
        },

        {
            name = "Cap 3",
            rendering = 1,
            metadata = {
                [1] = 'models/modified/hat07.mdl',
                [3] = Vector(4.21875, 0.875, 0.125),
                [4] = Angle(-0.21875, -68.8125, -89.875),
                [7] = Vector(1, 1.0625, 1),
                [11] = 1,
            }
        },

        {
            name = "Cap 4",
            rendering = 1,
            metadata = {
                [1] = 'models/modified/hat08.mdl',
                [3] = Vector(4.21875, 0.875, 0.125),
                [4] = Angle(-0.21875, -68.8125, -89.875),
                [7] = Vector(0.96875, 1, 1),
                [11] = 1,
            }
        },
        
        {
            name = "Cap 5",
            rendering = 1,
            metadata = {
                [1] = 'models/modified/hat08.mdl',
                [3] = Vector(4.21875, 0.875, 0.125),
                [4] = Angle(-0.21875, -68.8125, -89.875),
                [7] = Vector(0.96875, 1, 1),
                [11] = 0,
            }
        },

        {
            name = "Cap 6",
            rendering = 1,
            metadata = {
                [1] = 'models/modified/hat07.mdl',
                [3] = Vector(4.21875, 0.875, 0.125),
                [4] = Angle(-0.21875, -68.8125, -89.875),
                [7] = Vector(1, 1, 1),
                [11] = 2,
            }
        },

        {
            name = "Cap 7",
            rendering = 1,
            metadata = {
                [1] = 'models/modified/hat07.mdl',
                [3] = Vector(4.21875, 0.875, 0.125),
                [4] = Angle(-0.21875, -68.8125, -89.875),
                [7] = Vector(1, 1, 1),
                [11] = 3,
            }
        },

        {
            name = "Cap 8",
            rendering = 1,
            metadata = {
                [1] = 'models/modified/hat07.mdl',
                [3] = Vector(4.21875, 0.875, 0.125),
                [4] = Angle(-0.21875, -68.8125, -89.875),
                [7] = Vector(1, 1, 1),
                [11] = 4,
            }
        },

        {
            name = "Cap 9",
            rendering = 1,
            metadata = {
                [1] = 'models/modified/hat07.mdl',
                [3] = Vector(4.21875, 0.875, 0.125),
                [4] = Angle(-0.21875, -68.8125, -89.875),
                [7] = Vector(1, 1, 1),
                [11] = 5,
            }
        },

        {
            name = "Cap 10",
            rendering = 1,
            metadata = {
                [1] = 'models/modified/hat07.mdl',
                [3] = Vector(4.21875, 0.875, 0.125),
                [4] = Angle(-0.21875, -68.8125, -89.875),
                [7] = Vector(1, 1, 1),
                [11] = 6,
            }
        },

        {
            name = "Cap 11",
            rendering = 1,
            metadata = {
                [1] = 'models/modified/hat07.mdl',
                [3] = Vector(4.21875, 0.875, 0.125),
                [4] = Angle(-0.21875, -68.8125, -89.875),
                [7] = Vector(1, 1, 1),
                [11] = 7,
            }
        },

        {
            name = "Cap 12",
            rendering = 1,
            metadata = {
                [1] = 'models/modified/hat07.mdl',
                [3] = Vector(4.21875, 0.875, 0.125),
                [4] = Angle(-0.21875, -68.8125, -89.875),
                [7] = Vector(1, 1, 1),
                [11] = 8,
            }
        },

        {
            name = "Cap 13",
            rendering = 1,
            metadata = {
                [1] = 'models/modified/hat07.mdl',
                [3] = Vector(4.21875, 0.875, 0.125),
                [4] = Angle(-0.21875, -68.8125, -89.875),
                [7] = Vector(1, 1, 1),
                [11] = 9,
            }
        },

        {
            name = "Cap 14",
            rendering = 1,
            metadata = {
                [1] = 'models/modified/hat07.mdl',
                [3] = Vector(4.21875, 0.875, 0.125),
                [4] = Angle(-0.21875, -68.8125, -89.875),
                [7] = Vector(1, 1, 1),
                [11] = 10,
            }
        },

        {
            name = "Cap 15",
            rendering = 1,
            metadata = {
                [1] = 'models/modified/hat07.mdl',
                [3] = Vector(4.21875, 0.875, 0.125),
                [4] = Angle(-0.21875, -68.8125, -89.875),
                [7] = Vector(1, 1, 1),
                [11] = 11,
            }
        },

        {
            name = "Beret 3",
            rendering = 1,
            metadata = {
                [1] = 'models/modified/hat04.mdl',
                [3] = Vector(4.21875, 2.5, -0.375),
                [4] = Angle(0.21875, -56.9375, -90),
                [7] = Vector(0.96875, 0.96875, 1),
                [11] = 1,
            }
        },

        {
            name = "Beret 4",
            rendering = 1,
            metadata = {
                [1] = 'models/modified/hat04.mdl',
                [3] = Vector(4.21875, 2.5, -0.375),
                [4] = Angle(0.21875, -56.9375, -90),
                [7] = Vector(0.96875, 0.96875, 1),
                [11] = 2,
            }
        },

        {
            name = "Beret 5",
            rendering = 1,
            metadata = {
                [1] = 'models/modified/hat04.mdl',
                [3] = Vector(4.21875, 2.5, -0.375),
                [4] = Angle(0.21875, -56.9375, -90),
                [7] = Vector(0.96875, 0.96875, 1),
                [11] = 3,
            }
        },

        {
            name = "Beret 6",
            rendering = 1,
            metadata = {
                [1] = 'models/modified/hat04.mdl',
                [3] = Vector(4.21875, 2.5, -0.375),
                [4] = Angle(0.21875, -56.9375, -90),
                [7] = Vector(0.96875, 0.96875, 1),
                [11] = 4,
            }
        },

        {
            name = "White Hat",
            rendering = 1,
            metadata = {
                [1] = 'models/modified/hat01_fix.mdl',
                [3] = Vector(4.375, 0.875, -0.0625),
                [4] = Angle(0.21875, -74.3125, -90),
                [7] = Vector(0.875, 0.875, 0.875),
                [11] = 2,
                [12] = 150,
            }
        },

        {
            name = "Yellow Hat",
            rendering = 1,
            metadata = {
                [1] = 'models/modified/hat01_fix.mdl',
                [3] = Vector(4.375, 0.875, -0.0625),
                [4] = Angle(0.21875, -74.3125, -90),
                [7] = Vector(0.875, 0.875, 0.875),
                [11] = 3,
                [12] = 150,
            }
        },

        {
            name = "Red Hat",
            rendering = 1,
            metadata = {
                [1] = 'models/modified/hat01_fix.mdl',
                [3] = Vector(4.375, 0.875, -0.0625),
                [4] = Angle(0.21875, -74.3125, -90),
                [7] = Vector(0.875, 0.875, 0.875),
                [11] = 4,
                [12] = 150,
            }
        },

        {
            name = "Cap 18",
            rendering = 1,
            metadata = {
                [1] = 'models/modified/hat08.mdl',
                [3] = Vector(4.21875, 0.875, -0.0625),
                [4] = Angle(0.21875, -74.3125, -90),
                [7] = Vector(1, 1, 0.96875),
                [11] = 0,
                [12] = 150,
            }
        },

        {
            name = "Cap 19",
            rendering = 1,
            metadata = {
                [1] = 'models/modified/hat08.mdl',
                [3] = Vector(4.21875, 0.875, -0.0625),
                [4] = Angle(0.21875, -74.3125, -90),
                [7] = Vector(1, 1, 0.96875),
                [11] = 1,
                [12] = 150,
            }
        },

        {
            name = "Cap 20",
            rendering = 1,
            metadata = {
                [1] = 'models/modified/hat08.mdl',
                [3] = Vector(4.21875, 0.875, -0.0625),
                [4] = Angle(0.21875, -74.3125, -90),
                [7] = Vector(1, 1, 0.96875),
                [11] = 2,
                [12] = 150,
            }
        },

        {
            name = "Cap 21",
            rendering = 1,
            metadata = {
                [1] = 'models/modified/hat08.mdl',
                [3] = Vector(4.21875, 0.875, -0.0625),
                [4] = Angle(0.21875, -74.3125, -90),
                [7] = Vector(1, 1, 0.96875),
                [11] = 3,
                [12] = 150,
            }
        },

        {
            name = "Cap 22",
            rendering = 1,
            metadata = {
                [1] = 'models/modified/hat08.mdl',
                [3] = Vector(4.21875, 0.875, -0.0625),
                [4] = Angle(0.21875, -74.3125, -90),
                [7] = Vector(1, 1, 0.96875),
                [11] = 4,
                [12] = 150,
            }
        },

        {
            name = "Cap 23",
            rendering = 1,
            metadata = {
                [1] = 'models/modified/hat08.mdl',
                [3] = Vector(4.21875, 0.875, -0.0625),
                [4] = Angle(0.21875, -74.3125, -90),
                [7] = Vector(1, 1, 0.96875),
                [11] = 5,
                [12] = 150,
            }
        },

        {
            name = "Cap 24",
            rendering = 1,
            metadata = {
                [1] = 'models/modified/hat08.mdl',
                [3] = Vector(4.21875, 0.875, -0.0625),
                [4] = Angle(0.21875, -74.3125, -90),
                [7] = Vector(1, 1, 0.96875),
                [11] = 6,
                [12] = 150,
            }
        },

        {
            name = "Cap 25",
            rendering = 1,
            metadata = {
                [1] = 'models/modified/hat08.mdl',
                [3] = Vector(4.21875, 0.875, -0.0625),
                [4] = Angle(0.21875, -74.3125, -90),
                [7] = Vector(1, 1, 0.96875),
                [11] = 7,
                [12] = 150,
            }
        },

        {
            name = "Cap 26",
            rendering = 1,
            metadata = {
                [1] = 'models/modified/hat08.mdl',
                [3] = Vector(4.21875, 0.875, -0.0625),
                [4] = Angle(0.21875, -74.3125, -90),
                [7] = Vector(1, 1, 0.96875),
                [11] = 8,
                [12] = 150,
            }
        },

        {
            name = "Cap 27",
            rendering = 1,
            metadata = {
                [1] = 'models/modified/hat08.mdl',
                [3] = Vector(4.21875, 0.875, -0.0625),
                [4] = Angle(0.21875, -74.3125, -90),
                [7] = Vector(1, 1, 0.96875),
                [11] = 9,
                [12] = 150,
            }
        },

        {
            name = "Cap 28",
            rendering = 1,
            metadata = {
                [1] = 'models/modified/hat08.mdl',
                [3] = Vector(4.21875, 0.875, -0.0625),
                [4] = Angle(0.21875, -74.3125, -90),
                [7] = Vector(1, 1, 0.96875),
                [11] = 10,
                [12] = 150,
            }
        },

        {
            name = "Cap 29",
            rendering = 1,
            metadata = {
                [1] = 'models/modified/hat08.mdl',
                [3] = Vector(4.21875, 0.875, -0.0625),
                [4] = Angle(0.21875, -74.3125, -90),
                [7] = Vector(1, 1, 0.96875),
                [11] = 11,
                [12] = 150,
            }
        },

        {
            name = "Headphones",
            rendering = 1,
            metadata = {
                [1] = 'models/modified/headphones.mdl',
                [3] = Vector(2, 0.125, -0.125),
                [4] = Angle(0.21875, -79.8125, -90),
                [7] = Vector(1, 1, 0.96875),
                [11] = 0,
            }
        },

        {
            name = "Headphones 2",
            rendering = 1,
            metadata = {
                [1] = 'models/modified/headphones.mdl',
                [3] = Vector(2, 0.125, -0.125),
                [4] = Angle(0.21875, -79.8125, -90),
                [7] = Vector(1, 1, 0.96875),
                [11] = 2,
            }
        },

        {
            name = "Headphones 3",
            rendering = 1,
            metadata = {
                [1] = 'models/modified/headphones.mdl',
                [3] = Vector(2, 0.125, -0.125),
                [4] = Angle(0.21875, -79.8125, -90),
                [7] = Vector(1, 1, 0.96875),
                [11] = 3,
            }
        },

        {
            name = "Headphones 4",
            rendering = 1,
            metadata = {
                [1] = 'models/modified/headphones.mdl',
                [3] = Vector(2, 0.125, -0.125),
                [4] = Angle(0.21875, -79.8125, -90),
                [7] = Vector(1, 1, 0.96875),
                [11] = 1,
            }
        },

        {
            name = "Beer Hat",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/acc/fix/beerhat.mdl',
                [3] = Vector(2, -0.25, -0.0625),
                [4] = Angle(0.21875, -79.8125, -90),
                [7] = Vector(1.03125, 1, 1),
                [11] = 0,
                [12] = 150,
            }
        },

        {
            name = "Beer Hat 2",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/acc/fix/beerhat.mdl',
                [3] = Vector(2, -0.25, -0.0625),
                [4] = Angle(0.21875, -79.8125, -90),
                [7] = Vector(1.03125, 1, 1),
                [11] = 1,
                [12] = 150,
            }
        },

        {
            name = "Beer Hat 3",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/acc/fix/beerhat.mdl',
                [3] = Vector(2, -0.25, -0.0625),
                [4] = Angle(0.21875, -79.8125, -90),
                [7] = Vector(1.03125, 1, 1),
                [11] = 2,
                [12] = 150,
            }
        },

        {
            name = "Beer Hat 4",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/acc/fix/beerhat.mdl',
                [3] = Vector(2, -0.25, -0.0625),
                [4] = Angle(0.21875, -79.8125, -90),
                [7] = Vector(1.03125, 1, 1),
                [11] = 3,
                [12] = 150,
            }
        },

        {
            name = "Beer Hat 5",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/acc/fix/beerhat.mdl',
                [3] = Vector(2, -0.25, -0.0625),
                [4] = Angle(0.21875, -79.8125, -90),
                [7] = Vector(1.03125, 1, 1),
                [11] = 4,
                [12] = 150,
            }
        },

        {
            name = "Beer Hat 6",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/acc/fix/beerhat.mdl',
                [3] = Vector(2, -0.25, -0.0625),
                [4] = Angle(0.21875, -79.8125, -90),
                [7] = Vector(1.03125, 1, 1),
                [11] = 5,
                [12] = 150,
            }
        },

        {
            name = "Chief Hat",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/acc/fix/cheafhat.mdl',
                [3] = Vector(7.03125, 0.625, 0),
                [4] = Angle(0.21875, -89.875, -90),
                [7] = Vector(1, 0.96875, 1),
                [10] = false,
                [11] = 0,
                [12] = 150,
            }
        },
    }})
--addons/ashop/lua/ashop/code/ui/panels_settings/premades/cl_lol_pets.lua:
return gluapack()()
--addons/ashop/lua/ashop/code/ui/panels_settings/premades/cl_moatweaponskin.lua:
return gluapack()()
--addons/ashop/lua/ashop/code/ui/panels_settings/premades/cl_naruto.lua:
return gluapack()()
--addons/ashop/lua/ashop/code/ui/panels_settings/premades/cl_naruto.lua:
ashop.RegisterPremade("Naruto", {
        requireWorkshop = "114195906",

        objectTypes = {
            {
                "Wearables",
                {"ValveBiped.Bip01_Head1"},
                "Facemask"
            },

            {
                "Wearables",
                {"ValveBiped.Bip01_Head1"},
                "Hat"
            },
        },

        items = {
            {
                name = "Anbu Mask",
                rendering = 1,
                metadata = {
                    [1] = 'models/naruto/props/anbumask.mdl',
                    [3] = Vector(-2.0625, -3.71875, -0.21875),
                    [4] = Angle(180, -0.25, 90.40625),
                },
            },

            {
                name = "Oinin Mask",
                rendering = 1,
                metadata = {
                    [1] = 'models/naruto/props/oininmask.mdl',
                    [3] = Vector(-2.0625, -3.71875, -0.21875),
                    [4] = Angle(180, 89.84375, 89.84375),
                },
            },

            {
                name = "Hokage",
                rendering = 2,
                metadata = {
                    [1] = 'models/naruto/props/kagehat.mdl',
                    [3] = Vector(-2.21875, -1.90625, -0.0625),
                    [4] = Angle(180, 12.1875, 89.84375),
                    [11] = 0,
                },
            },

            {
                name = "Kazekage",
                rendering = 2,
                metadata = {
                    [1] = 'models/naruto/props/kagehat.mdl',
                    [3] = Vector(-2.21875, -1.90625, -0.0625),
                    [4] = Angle(180, 12.1875, 89.84375),
                    [11] = 1,
                },
            },

            {
                name = "Mizukage",
                rendering = 2,
                metadata = {
                    [1] = 'models/naruto/props/kagehat.mdl',
                    [3] = Vector(-2.21875, -1.90625, -0.0625),
                    [4] = Angle(180, 12.1875, 89.84375),
                    [11] = 2,
                },
            },

            {
                name = "Tsuchikage",
                rendering = 2,
                metadata = {
                    [1] = 'models/naruto/props/kagehat.mdl',
                    [3] = Vector(-2.21875, -1.90625, -0.0625),
                    [4] = Angle(180, 12.1875, 89.84375),
                    [11] = 3,
                },
            },

            {
                name = "Raikage",
                rendering = 2,
                metadata = {
                    [1] = 'models/naruto/props/kagehat.mdl',
                    [3] = Vector(-2.21875, -1.90625, -0.0625),
                    [4] = Angle(180, 12.1875, 89.84375),
                    [11] = 4,
                },
            },

            {
                name = "Ninja Headband",
                rendering = 2,
                metadata = {
                    [1] = 'models/naruto/props/headband.mdl',
                    [3] = Vector(3.375, 0.40625, -0.0625),
                    [4] = Angle(180, 103.4375, 90.40625),
                },
            },
        }
    }
)
--addons/ashop/lua/ashop/code/ui/panels_settings/premades/cl_tera_pets.lua:
return gluapack()()
--addons/ashop/lua/ashop/code/ui/panels_settings/premades/cl_ura_titlecolors.lua:
local t = {
    requireWorkshop = "",
    objectTypes = {{"TitleColor"}},
    items = {}
}

for k, v in pairs(ashop.titles.colors) do
    table.insert(t.items, {
        name = v.name,
        rendering = 1,
        metadata = {color_black, k}
    })
end

ashop.RegisterPremade("Uranium Colors", t)
--lua/autorun/autorun.lua:
return gluapack()()
--addons/sh_reports/lua/reports/cl_menu_rating.lua:
local function L(...) return SH_REPORTS:L(...) end

local matStar = Material("shenesis/reports/star.png", "noclamp smooth")

function SH_REPORTS:ShowRating(report_id, admin_name)
	if (IsValid(_SH_REPORTS_RATE)) then
		_SH_REPORTS_RATE:Remove()
	end

	local styl = self.Style
	local th, m = self:GetPadding(), self:GetMargin()
	local m2 = m * 0.5
	local ss = self:GetScreenScale()

	local cur_rate = 3
	local is = 64 * ss

	local frame = self:MakeWindow(L"rating")
	frame:SetSize(1, 144 * ss + m * 2)
	frame:MakePopup()
	_SH_REPORTS_RATE = frame

		local stars = vgui.Create("DPanel", frame)
		stars:SetDrawBackground(false)
		stars:Dock(FILL)
		stars:DockMargin(m, m, m, m)

			for i = 1, 5 do
				local st = vgui.Create("DButton", stars)
				st:SetToolTip(i .. "/" .. 5)
				st:SetText("")
				st:SetWide(64 * ss)
				st:Dock(LEFT)
				st:DockMargin(0, 0, m2, 0)
				st.Paint = function(me, w, h)
					if (!me.m_CurColor) then
						me.m_CurColor = styl.inbg
					else
						me.m_CurColor = self:LerpColor(FrameTime() * 20, me.m_CurColor, cur_rate >= i and styl.rating or styl.inbg)
					end

					surface.SetMaterial(matStar)
					surface.SetDrawColor(me.m_CurColor)
					surface.DrawTexturedRect(0, 0, w, h)
				end
				st.OnCursorEntered = function()
					cur_rate = i
				end
				st.DoClick = function()
					easynet.SendToServer("SH_REPORTS.RateAdmin", {report_id = report_id, rating = i})
					frame:Close()
				end
			end

		local lbl = self:QuickLabel(L("rate_question", admin_name), "{prefix}Large", styl.text, frame)
		lbl:SetContentAlignment(5)
		lbl:Dock(BOTTOM)
		lbl:DockMargin(0, 0, 0, m)
		
	frame:SetWide(math.max(400 * ss, lbl:GetWide() + m * 2))
	frame:Center()
	
	local sp = math.ceil((frame:GetWide() - (64 * ss) * 5 - m * 4) * 0.5)
	stars:DockPadding(sp, 0, sp, 0)
end

easynet.Callback("SH_REPORTS.PromptRating", function(data)
	SH_REPORTS:ShowRating(data.report_id, data.admin_name)
end)
--addons/safezone-sh/lua/safezones/sh_shapes.lua:
SH_SZ.Shapes = {}
SH_SZ.ShapesIndex = {}

SH_SZ.Shapes["cube"] = {
	name = "cube",
	icon = "shenesis/safezones/cube.png",
	points = 2,
	steps = {
		{type = "place"},
		{type = "place"},
		{type = "confirm"},
	},

	setup = function(zone, points, size)
		zone:SetupCube(points[1], points[2], size)
	end,
	render = function(points, size, color)
		local z = math.min(points[1].z, points[2].z)

		local a = Vector(points[1].x, points[1].y, z)
		local b = Vector(points[2].x, points[2].y, z)

		local c1 = Vector(a.x, b.y, a.z)
		local c2 = Vector(b.x, a.y, a.z)

		render.DrawLine(a, c1, color, true)
		render.DrawLine(b, c1, color, true)
		render.DrawLine(a, c2, color, true)
		render.DrawLine(b, c2, color, true)

		local o = Vector(0, 0, size)
		local t1 = a + o
		local t2 = b + o
		local t3 = c1 + o
		local t4 = c2 + o

		render.DrawLine(a, t1, color, true)
		render.DrawLine(b, t2, color, true)
		render.DrawLine(c1, t3, color, true)
		render.DrawLine(c2, t4, color, true)

		render.DrawLine(t1, t4, color, true)
		render.DrawLine(t2, t3, color, true)
		render.DrawLine(t3, t1, color, true)
		render.DrawLine(t4, t2, color, true)
	end
}

SH_SZ.Shapes["sphere"] = {
	name = "sphere",
	icon = "shenesis/safezones/sphere.png",
	points = 1,
	steps = {
		{type = "place"},
		{type = "confirm"},
	},

	setup = function(zone, points, size)
		zone:SetupSphere(points[1], size)
	end,
	render = function(points, size, color)
		render.DrawWireframeSphere(points[1], size, 16, 16, color, true)
	end
}

do
	local i = 0
	for _, v in pairs (SH_SZ.Shapes) do
		i = i + 1
		v.id = i
		SH_SZ.ShapesIndex[i] = v
	end
end
--lua/autorun/badodscript.lua:
CreateConVar("BAD_enabled", "1", {FCVAR_ARCHIVE, FCVAR_CLIENTCMD_CAN_EXECUTE}, "Turn on the blur effect when the player dies - 1 (0 - Disable)")


local blurAmount = 0
local maxBlur = 4
local blurSpeed = 8
local healthThreshold = 0
local vignetteMaxAlpha = 200


local function DrawVignette(amount)
    surface.SetDrawColor(0, 0, 0, amount)
    surface.DrawRect(0, 0, ScrW(), ScrH())
end


hook.Add("HUDPaint", "BlurEffectWithVignette", function()

    if GetConVar("BAD_enabled"):GetInt() == 0 then
        blurAmount = math.max(blurAmount - blurSpeed * FrameTime(), 0)
        return 
    end

    local player = LocalPlayer()


    if player:Health() <= healthThreshold then

        blurAmount = math.min(blurAmount + blurSpeed * FrameTime(), maxBlur)
    else

        blurAmount = math.max(blurAmount - blurSpeed * FrameTime(), 0)
    end


    if blurAmount > 0 then
        surface.SetDrawColor(255, 255, 255, 255)
        surface.SetMaterial(Material("pp/blurscreen"))
        for i = 1, 3 do
            Material("pp/blurscreen"):SetInt("$blur", blurAmount * (i * 1))
            render.UpdateScreenEffectTexture()
            surface.DrawTexturedRect(0, 0, ScrW(), ScrH())
        end


        local vignetteAmount = math.Clamp((blurAmount / maxBlur) * vignetteMaxAlpha, 0, vignetteMaxAlpha)
        DrawVignette(vignetteAmount)
    end
end)

--addons/bodygroupr/lua/autorun/bodyman_init.lua:

BODYMAN = {}

  local SERVER = SERVER
        local CLIENT = CLIENT

if SERVER then
	include("bodyman/bodyman_server.lua")
	include("bodyman/bodyman_server_hooks.lua")
	include("bodyman/bodyman_config.lua")

	AddCSLuaFile("bodyman/bodyman_client.lua")
	AddCSLuaFile("bodyman/arizard_derma.lua")
	AddCSLuaFile("bodyman/bodyman_config.lua")
else
	include("bodyman/bodyman_config.lua")
	include("bodyman/bodyman_client.lua")
	include("bodyman/arizard_derma.lua")
end

function InverseLerp( pos, p1, p2 )

	local range = 0
	range = p2-p1

	if range == 0 then return 1 end

	return ((pos - p1)/range)

end

function BODYMAN:HasSkin( ply, skindex )
	local has = true
	local skincount = ply:SkinCount()
	-- skins start at 0 but lua tables start at 1
	-- skincount-1 is last skin
	-- therefore skindex must be between 0 and skincount-1 inclusive
	if skindex > skincount-1 then has = false end
	if skindex < 0 then has = false end

	return has
end

-- need an algorithm which checks if a bodygroups exists for a player
function BODYMAN:HasBodyGroup( ply, name, idx )
	-- PLAYER ply, STRING name, INT idx
	local modelgroups = ply:GetBodyGroups()
	local has = false
	local bgid = -1

	for k,v in ipairs( modelgroups ) do
		if v.name == name then
			bgid = v.id
		end
	end

	if bgid >= 0 then
		-- add 1 to the bgid to get the table index
		-- because lua tables start at 1
		-- but bg ids start at 0

		-- we already know that it exists, because it's been set by the previous for loop.
		-- lets make sure the submodel (idx) exists
		if modelgroups[bgid + 1].submodels[idx] then
			has = true -- we can set it to true if we know it exists
		end
	end

	return has
end

-- For when we are Closets-only
function BODYMAN:CloseEnoughCloset( ply )
	-- check if a player is A) looking at a closet and B) within 128 units.
	local range = 128
	local tr = ply:GetEyeTrace()
	local dist = ply:EyePos():Distance( tr.HitPos )

	if tr.Entity then
		if tr.Entity:GetClass() == "bodyman_closet" then
			if dist <= range then
				return true
			end
		end
	end

	return false

end


--addons/bodygroupr/lua/bodyman/bodyman_client.lua:


include("bodyman/bodyman_config.lua")

if BODYMAN.French == true then
	BODYMAN.HelpText = BODYMAN.HelpText_Fr
	BODYMAN.ClosetHelpText = BODYMAN.ClosetHelpText_Fr
	BODYMAN.strings = BODYMAN.strings_fr
	BODYMAN.ClosetName = BODYMAN.ClosetName_Fr
end

surface.CreateFont("Bodygroups_Small", {
	font = "Trebuchet24",
	size = 14,
	antialias = true,
	weight = 800
})

surface.CreateFont("Bodygroups_Medium", {
	font = "Trebuchet24",
	size = 18,
	antialias = true,
	weight = 800
})

surface.CreateFont("Bodygroups_Large", {
	font = "Trebuchet24",
	size = 30,
	antialias = true,
	weight = 800
})

function InverseLerp( pos, p1, p2 )

	local range = 0
	range = p2-p1

	if range == 0 then return 1 end

	return ((pos - p1)/range)

end

include("bodyman/arizard_derma.lua")

function BODYMAN:Chat( msg )
	chat.AddText(HexColor("#3498db"), "[Warden] ", Color(255,255,255), msg)
end

net.Receive("bodyman_chatprint", function()
	local msg = net.ReadString()
	BODYMAN:Chat( msg )
end)

BODYMAN.MenuIsOpen = false
BODYMAN.Menu = nil



function BODYMAN:OpenMenu()

	self.MenuIsOpen = true

	if self.ClosetsOnly == true then
		if self:CloseEnoughCloset( LocalPlayer() ) == false then
			return false
		end
	end

	local frame = vgui.Create("arizard_window")
	frame:SetSize( ScrW()*.75, ScrH()*.85 )
	frame:Center()
	frame:SetPrimaryColor( HexColor("#3498db") )
	frame:SetSecondaryColor( HexColor("#ecf0f1", 4) )
	frame:SetTitle("Gardırop")
	frame:MakePopup()

	self.Menu = frame

	function frame:OnClose()
		BODYMAN.MenuIsOpen = false
	end

	local pmodel = vgui.Create("DModelPanel", frame)
	pmodel:SetSize( pmodel:GetParent():GetWide()*(2/3) - 8, pmodel:GetParent():GetTall() - 40 )
	pmodel:SetPos( 4, 32 )

	pmodel:SetModel( LocalPlayer():GetModel() )

	pmodel:SetLookAt( Vector(0,0,72/2) )
	pmodel:SetCamPos( Vector(64,0,72/2))
	--pmodel:SetLookAng( Angle(0,0,0) )

	pmodel.Entity:SetEyeTarget( pmodel.Entity:GetPos() + Vector(200,0,64) )

	pmodel:SetAmbientLight( Color(10,15,50) )
	pmodel:SetDirectionalLight( BOX_TOP, Color(220,190,100) )

	pmodel.rot = 110
	pmodel.fov = 20
	pmodel:SetFOV( pmodel.fov )
	pmodel.dragging = false -- left click
	pmodel.dragging2 = false -- right click
	pmodel.ux = 0
	pmodel.uy = 0
	pmodel.spinmul = 0.4
	pmodel.zoommul = 0.09

	pmodel.xmod = 0
	pmodel.ymod = 0

	BODYMAN.ClientModelPanel = pmodel

	pmodel.Entity:SetSkin( LocalPlayer():GetSkin() )

	-- set pmodel's bodygroups
	local curgroups = LocalPlayer():GetBodyGroups()
	--PrintTable( curgroups )

	for k,v in pairs( curgroups ) do
		local ent = pmodel.Entity
		local cur_bgid = LocalPlayer():GetBodygroup( v.id )
		ent:SetBodygroup( v.id, cur_bgid )
	end

	function pmodel.Entity:GetPlayerColor()
		return LocalPlayer():GetPlayerColor()
	end

	function pmodel:PaintOver( w, h )
		--surface.SetDrawColor( Color(255,255,255) )
		--surface.DrawOutlinedRect(0,0,w,h)
		ArizardShadowText(BODYMAN.HelpText, "Bodygroups_Medium", 0,0, Color(255,255,255), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP, 1 )
	end

	function pmodel:LayoutEntity( ent )

		local newrot = self.rot
		local newfov = self:GetFOV()

		if self.dragging == true then
			newrot = self.rot + (gui.MouseX() - self.ux)*self.spinmul
			newfov = self.fov + (self.uy - gui.MouseY()) * self.zoommul
			if newfov < 20 then newfov = 20 end
			if newfov > 75 then newfov = 75 end
		end

		local newxmod, newymod = self.xmod, self.ymod

		if self.dragging2 == true then
			newxmod = self.xmod + (self.ux - gui.MouseX())*0.02
			newymod = self.ymod + (self.uy - gui.MouseY())*0.02
		end

		newxmod = math.Clamp( newxmod, -16, 16 )
		newymod = math.Clamp( newymod, -16, 16 )

		ent:SetAngles( Angle(0,0,0) )
		self:SetFOV( newfov )

		-- calculate if we should look at the face
		local height = 72/2
		-- fov between 20 and 75,
		-- height between 72/2 and 72
		local frac = InverseLerp( newfov, 75, 20 )
		height = Lerp( frac, 72/2, 64 )

		-- calculate look ang
		local norm = (self:GetCamPos() - Vector(0,0,64))
		norm:Normalize()
		local lookAng = norm:Angle()

		self:SetLookAt( Vector(0,0,height-(2*frac) ) - Vector( 0, 0, newymod*2*(1-frac) ) - lookAng:Right()*newxmod*2*(1-frac) )
		self:SetCamPos( Vector( 64*math.sin( newrot * (math.pi/180)), 64*math.cos( newrot * (math.pi/180)), height + 4*(1-frac)) - Vector( 0, 0, newymod*2*(1-frac) ) - lookAng:Right()*newxmod*2*(1-frac) )

	end

	function pmodel:OnMousePressed( k )
		self.ux = gui.MouseX()
		self.uy = gui.MouseY()
		self.dragging = (k == MOUSE_LEFT) or false 
		self.dragging2 = (k == MOUSE_RIGHT) or false 
	end

	function pmodel:OnMouseReleased( k )
		if self.dragging == true then
			self.rot = self.rot + (gui.MouseX() - self.ux)*self.spinmul
			self.fov = self.fov + (self.uy - gui.MouseY()) * self.zoommul
			self.fov = math.Clamp( self.fov, 20, 75 )
		end

		if self.dragging2 == true then
			self.xmod = self.xmod + (self.ux - gui.MouseX())*0.02
			self.ymod = self.ymod + (self.uy - gui.MouseY())*0.02

			self.xmod = math.Clamp( self.xmod, -16, 16 )
			self.ymod = math.Clamp( self.ymod, -16, 16 )
		end

		self.dragging = false 
		self.dragging2 = false
	end

	function pmodel:OnCursorExited()
		if self.dragging == true or self.dragging2 == true then
			self:OnMouseReleased()
		end
	end

	-- now for the controls
	local cpan = vgui.Create("DPanel", frame)
	cpan:SetSize( cpan:GetParent():GetWide()*(1/3)-4, cpan:GetParent():GetTall() - 44 )
	cpan:SetPos( 4+4+cpan:GetParent():GetWide()*(2/3)-8, 32)
	function cpan:Paint() end

	local cpanscroll = vgui.Create("DScrollPanel", cpan)
	cpanscroll:SetSize( cpanscroll:GetParent():GetWide(), cpanscroll:GetParent():GetTall() )
	cpanscroll:SetPos(0,0)

	-- style the scroll button:
	local sbar = cpanscroll:GetVBar()
	sbar:SetWide( 6 )
	function sbar:Paint( w, h )
	end
	function sbar.btnUp:Paint( w, h )
	end
	function sbar.btnDown:Paint( w, h )
	end
	function sbar.btnGrip:Paint( w, h )
		draw.RoundedBox((w-1)/2, 1,0,w-1,h,Color(0,0,0,200))
	end

	local cpanlist = vgui.Create("DIconLayout", cpanscroll)
	cpanlist:SetSize( cpanscroll:GetWide()-8, cpanscroll:GetTall() - 8 )
	cpanlist:SetPos( 4, 4 )
	cpanlist:SetSpaceX( 4 )
	cpanlist:SetSpaceY( 4 )

	self.cpanlist = cpanlist
	self.cpanscroll = cpanscroll

	self:RefreshAppearanceMenu( )
	
end
local cooldown = CurTime()
function BODYMAN:RefreshAppearanceMenu( )

	local cpanlist, cpanscroll = self.cpanlist, self.cpanscroll

	if ( not IsValid( cpanlist ) ) or ( not IsValid( cpanscroll ) ) then return end

	-- reload the bodygropes
	self.ClientModelPanel.Entity:SetSkin( LocalPlayer():GetSkin() )

	-- set pmodel's bodygroups
	local curgroups = LocalPlayer():GetBodyGroups()
	--PrintTable( curgroups )

	for k,v in pairs( curgroups ) do
		local ent = self.ClientModelPanel.Entity
		local cur_bgid = LocalPlayer():GetBodygroup( v.id )
		ent:SetBodygroup( v.id, cur_bgid )
	end

	self.ClientModelPanel.Entity:SetEyeTarget( self.ClientModelPanel.Entity:GetPos() + Vector(200,0,64) )

	cpanlist:Clear()

	local title = cpanlist:Add( "DLabel" )
	title:SetText( BODYMAN.strings.Appearance )
	title:SetFont("Bodygroups_Large")
	title:SetTextColor( HexColor("#ffffff") )
	title:SizeToContents()
	title:SetWide( cpanscroll:GetWide() )
	title:SetExpensiveShadow(1,Color(0,0,0))

	local job = LocalPlayer():getJobTable()

	-- do models
	local playermodels = job.model
	
	if type( playermodels ) == "table" then
		local modeltitle = cpanlist:Add("DLabel")
		modeltitle:SetText( BODYMAN.strings.Playermodels )
		modeltitle:SetFont("Bodygroups_Medium")
		modeltitle:SetTextColor( HexColor("#eeeeee") )
		modeltitle:SizeToContents()
		modeltitle:SetWide( cpanscroll:GetWide() )
		modeltitle:SetExpensiveShadow(1,Color(0,0,0))

		for k=1,#playermodels do
			local mdl = playermodels[k]

			local btn = cpanlist:Add( "arizard_button" )
			btn:SetWide( (cpanlist:GetWide()-8)/2 - 8 )
			btn:SetTall( 28 )

			-- reduce the filepath to it's model name, without extension
			local args = string.Split( mdl, "/" )
			local mdlname = args[ #args ]
			mdlname = string.sub( mdlname, 1, -5)

			btn:SetText( mdlname )
			btn.mdlpath = mdl
			btn.mdlidx = k

			btn:SetColors( HexColor("#2980b9"), HexColor("#3498db"))

			function btn:DoClick()
				BODYMAN.ClientModelPanel:SetModel( self.mdlpath )
				if cooldown > CurTime() then 
					LocalPlayer():ChatPrint("Birazcık yavaşla!")
					return 
				end 
				cooldown = CurTime() + 2
				net.Start("bodyman_model_change")
				net.WriteInt( self.mdlidx, 8 )
				net.SendToServer()

				BODYMAN:RefreshAppearanceMenu( )
			end
		end

	end

	-- do skins
	
	local skintable = {}

	if job.skins then
		skintable = job.skins
	else
		skintable = {}
		for i=0,LocalPlayer():SkinCount()-1 do
			table.insert( skintable, i )
		end
	end

	if skintable != {} then
		local skintitle = cpanlist:Add("DLabel")
		skintitle:SetText( BODYMAN.strings.Skins )
		skintitle:SetFont("Bodygroups_Medium")
		skintitle:SetTextColor( HexColor("#eeeeee") )
		skintitle:SizeToContents()
		skintitle:SetWide( cpanscroll:GetWide() )
		skintitle:SetExpensiveShadow(1,Color(0,0,0))

		for k,i in ipairs(skintable) do
			if BODYMAN:HasSkin( LocalPlayer(), i ) then
				local btn = cpanlist:Add( "arizard_button" )
				btn:SetSize( cpanlist:GetWide()/4 - 16, 28 )
				btn:SetText( tostring(i) )
				btn.skinNumber = i

				btn:SetColors( HexColor("#2980b9"), HexColor("#3498db"))

				function btn:DoClick()
					print("Attempting to switch skin", self.skinNumber)
					BODYMAN.ClientModelPanel.Entity:SetSkin( self.skinNumber )

					net.Start("skins_change")
					net.WriteInt(self.skinNumber, 8)
					net.SendToServer()
				end
			end
		end

		local spacer = cpanlist:Add("DPanel")
		spacer:SetSize(cpanlist:GetWide(), 2)
		function spacer:Paint() end
	end

	local allowedbodygroups = {}
	
	if job.bodygroups then
		allowedbodygroups = job.bodygroups 
	else
		local ply = LocalPlayer()
		for i = 2, #ply:GetBodyGroups() do
			local bg = ply:GetBodyGroups()[i]
			if bg then
				for k,v in pairs( bg ) do
					if k == "name" then
						allowedbodygroups[v] = {}
						for k2, v2 in pairs( bg["submodels"] ) do
							table.insert( allowedbodygroups[v], k2 )
						end
					end
				end	
			end
		end

		--PrintTable( allowedbodygroups )
	end

	if allowedbodygroups != {} then
		local bgtitle = cpanlist:Add("DLabel")
		bgtitle:SetText( BODYMAN.strings.Bodygroups )
		bgtitle:SetFont("Bodygroups_Medium")
		bgtitle:SetTextColor( HexColor("#eeeeee") )
		bgtitle:SizeToContents()
		bgtitle:SetWide( cpanscroll:GetWide() )
		bgtitle:SetExpensiveShadow(1,Color(0,0,0))

		for bgname, bgtable in pairs( allowedbodygroups ) do
			local bglabel = cpanlist:Add("DLabel")
			bglabel:SetFont("Bodygroups_Small")
			bglabel:SetText(string.upper(bgname))
			bglabel:SetTextColor( HexColor("#dddddd") )
			bglabel:SizeToContents()
			bglabel:SetWide( cpanscroll:GetWide() )
			bglabel:SetExpensiveShadow(1,Color(0,0,0))

			for _,i in ipairs(bgtable) do

				if BODYMAN:HasBodyGroup( LocalPlayer(), bgname, i ) then

					local btn = cpanlist:Add( "arizard_button" )
					btn:SetSize( cpanlist:GetWide()/4 - 16, 28 )
					btn:SetText( tostring(i) )
					btn.bg_name = bgname
					btn.bg_num = i

					btn:SetColors( HexColor("#2980b9"), HexColor("#3498db"))

					function btn:DoClick()
						local ent = BODYMAN.ClientModelPanel.Entity
						local bgid = ent:FindBodygroupByName( self.bg_name )
						if bgid != -1 then
							ent:SetBodygroup( bgid, self.bg_num )

							net.Start("bodygroups_change")
							net.WriteTable( { bgid, self.bg_num } )
							net.SendToServer()
						end
					end

				end
			end

			local spacer = cpanlist:Add("DPanel")
			spacer:SetSize(cpanlist:GetWide(), 2)
			function spacer:Paint() end

		end

		local spacer = cpanlist:Add("DPanel")
		spacer:SetSize(cpanlist:GetWide(), 2)
		function spacer:Paint() end
	end
end

concommand.Add("bodyman_openmenu", function()
	BODYMAN:OpenMenu()
end)

--lua/autorun/cf_gunslinger_sp.lua:
player_manager.AddValidModel( "CF_Gunslinger_SP", "models/CF_Gunslinger_SP/CF_Gunslinger_SP.mdl" );

local Category = "CrossFire"

local NPC = { 	Name = "CF_Gunslinger_SP - Friendly", 
				Class = "npc_citizen",
				Model = "models/CF_Gunslinger_SP/CF_Gunslinger_SP.mdl",
				Health = "100",
				KeyValues = { citizentype = 4 },
				Weapons = { "weapons_smg1" },
				Category = Category	}

list.Set( "NPC", "CF_Gunslinger_SP_f", NPC )

local Category = "CrossFire"

local NPC = { 	Name = "CF_Gunslinger_SP - Hostile", 
				Class = "npc_combine_s",
				Model = "models/CF_Gunslinger_SP/CF_Gunslinger_SP.mdl",
				Squadname = "CF_Gunslinger_SP",
				Numgrenades = "3",
				Health = "100",
				Weapons = { "" },
				Category = Category	}

list.Set( "NPC", "CF_Gunslinger_SP_h", NPC )
--addons/ch_atm/lua/ch_atm/shared/ch_atm_config.lua:
CH_ATM = CH_ATM or {}
CH_ATM.Config = CH_ATM.Config or {}
CH_ATM.Currencies = CH_ATM.Currencies or {}

--[[
	Language Config
	English: en - Danish: da - French: fr - Spanish: es - Polish: pl - Turkish: tr - Russian: ru
--]]
CH_ATM.Config.Language = "tr" -- Set the language of the script.

--[[
	Default Config
--]]
CH_ATM.Config.AccountStartMoney = 5000 -- How much money is there on a bank account when it's created?
CH_ATM.Config.ATMCurrency = "darkrp" -- What gamemode/currency do you want to store in the ATM? Supported are basewars, bricks_credit_store, darkrp, helix, mtokens, pointshop2, pointshop2_premium, santosrp, sh_pointshop, sh_pointshop_premium, underdone

CH_ATM.Config.NotificationTime = 8 -- Amount of seconds to show notifications
CH_ATM.Config.DistanceToScreen3D2D = 5000 -- Distance between the player and the 3d2d to draw

CH_ATM.Config.WalletLooseOnDeathPercentage = 1 -- How many percetange of the players wallet to loose on death (not bank account)? Set to 0 to disable.
CH_ATM.Config.MaximumToLooseOnDeath = 10000 -- How much money can a player maximum loose on death?
CH_ATM.Config.DropMoneyOnDeath = true -- Should the money lost be dropped on death? If true it will drop, if false they will just vanish.

CH_ATM.Config.ReplaceATMPropsOnMap = true -- Should we try to replace static ATM props with interactive ATM entities? Only works on some maps.

CH_ATM.Config.WithdrawToBankFromPrinter = false -- If you have a supported money printer and this enabled then you can withdraw directly from printer to your bank account.
CH_ATM.Config.SendPaycheckToBank = false -- If this is enabled then their paycheck will be sent directly to their bank account instead of wallet.

CH_ATM.Config.EnableResetAllAccounts = true -- Should super admins be allowed to reset all bank accounts?

--[[
	ATM Admin Config
--]]
CH_ATM.Config.AdminATMChatCommand = "!adminatm" -- Chat command to open ATM admin menu
CH_ATM.Config.EnableCustomAdminGroups = false -- Normally it just checks IsAdmin that works with all admin mods. If you want to specify your own usergroups then you can enable this.
CH_ATM.Config.CustomAdminGroups = { -- List of admin usergroups. Only applicable if above setting is enabled.
	["owner"] = true,
	["superadmin"] = true,
	["admin"] = true,
	["moderator"] = true,
}

--[[
	ATM Config
--]]
CH_ATM.Config.ActivateWithCreditCard = false -- Should the ATM be activated by inserting the credit card? true to enable or false to activate with pressing E
CH_ATM.Config.FinePlayerIfForgetCard = true -- Should the player be fined if they forget their credit card in the ATM?
CH_ATM.Config.ForgetCardFee = 20 -- How much should they be fined for getting their credit card in the ATM?

CH_ATM.Config.SlideMoneyOutOfATM = false -- Should we spawn money and slide them in/out of the ATM on deposit/withdraw? If not it just adds directly to wallet.
CH_ATM.Config.OnlyOwnerCanTakeMoney = false -- Should we only allow the person that withdraws the money to be able to take the money that slides out of the ATM?

CH_ATM.Config.AllowKeyboardInputForKeypad = true -- Should the user be able to use their keyboard to input numbers/actions when the keypad is active?

CH_ATM.Config.PayoutMoneyToWalletIfMax = false -- If player receives money, but his bank reaches maximum then we can pay out the money to his wallet?

--[[
	ATM Color Config
--]]
CH_ATM.Config.ActiveColor = Color( 255, 255, 255, 255 ) -- The color we want the ATM sides to have when it is actively being used by someone
CH_ATM.Config.ActionSuccessfulColor = Color( 75, 174, 79, 255 ) -- The color the ATM gets for a few seconds when an action is successful (like deposit)
CH_ATM.Config.ActionUnsuccessfulColor = Color( 243, 66, 53, 255 ) -- The color the ATM gets for a few seconds when an action is NOT successful (like fail deposit)

CH_ATM.Config.EnableInactiveColor = false -- Should the ATM be lit up in a different color when inactive (not in use)?
CH_ATM.Config.InactiveColor = Color( 0, 0, 200, 255 ) -- The color we want the ATM sides to have when it is NOT being used by someone (if enabled)

CH_ATM.Config.OutOfOrderColor = Color( 243, 66, 53, 255 ) -- The color the ATM has when it is out of order (after a hack attempt)

--[[
	Teams Config
--]]
CH_ATM.Config.PoliceTeams = { -- The DarkRP team name that defines the police teams on your server (put the names as shown on your scoreboard).
["PÖH"] = true,
["Bekçi"] = true,
["Polis"] = true,
["Başkan"] = true,
["Başbakan"] = true,
["Başkan Koruması"] = true,
["PÖH Keskin Nişancı"] = true,
["PÖH Doktor"] = true,
["PÖH Amir"] = true,
["Emniyet Amiri"] = true,
["CIA Ajanı"] = true,
["Police Chief"] = true
}

CH_ATM.Config.CriminalTeams = { -- The DarkRP team name that defines who can hack/lockpick ATM's (put the names as shown on your scoreboard).
["Meth Üreticisi"] = true,
["Hacker"] = true,
["Ot Üreticisi"] = true,
["Grove Çete Üyesi"] = true,
["Vagos Çete Üyesi"] = true,
["Hırsız"] = true,
["Adam Kaçırıcısı"] = true,
["Mafya Babası"] = true,
["Mafya Üyesi"] = true,
["Karaborsacı"] = true,
["Keko"] = true,
["Grove Çete Lideri"] = true,
["Vagos Çete Lideri"] = true,
["Parkucu"] = true,
["Profesyonel Hırsız"] = true,
["İkiz Kardeşler"] = true,
["Pro Adam Kaçırıcısı"] = true,
["Hacker"] = true,
}

--[[
	Interest Config
	See more interest configs in ch_atm_config_upgrades.lua
--]]
CH_ATM.Config.InterestInterval = 60000 -- Once a player joins this interval starts to count. Every x second it will generate a percentage interval based on the config.

CH_ATM.Config.InterestToTakeOnBankRobbery = 0.0005 -- SUPPORT FOR BANK ROBBERY 2 AND PVAULT How much interest to take from all players when bank is robbed
CH_ATM.Config.MoneyPercentToTakeOnBankRobbery = 0.002 -- SUPPORT FOR BANK ROBBERY 2 AND PVAULT How many percent of a players bank account money should we take from all players when bank is robbed

CH_ATM.Config.InterestNotifyOnSpawn = false -- Should the player receive a notify when their interest rate is set on connecting?

--[[
	ATM Hacking/Lockpicking
--]]
CH_ATM.Config.HackingTime = 60 -- How many seconds does it take to lockpick an ATM successfully

CH_ATM.Config.HackingPlayersRequired = 5 -- How many online players required to lockpick an ATM?
CH_ATM.Config.HackingPoliceOfficersRequired = 3 -- How many online players must be police officer in order to lockpick ATMs?

CH_ATM.Config.PlayerHackingCooldownTime = 1200 -- For how many seconds do we cooldown the player before they can lockpick any ATM again
CH_ATM.Config.ATMHackCooldownTime = 600 -- For how many seconds should the ATM be on cooldown after a hack (making it un-useable for everybody). 0 to disable.

CH_ATM.Config.MoneyRewardForHackingMin = 100 -- Minimum amount of money to be "rewarded" for hacking an ATM.
CH_ATM.Config.MoneyRewardForHackingMax = 10000 -- Maximum amount of money to be "rewarded" for hacking an ATM.

CH_ATM.Config.InterestToTakeForHacking = 0.0002 -- How much interest to take from all players when an ATM is hacked?
CH_ATM.Config.TakeMoneyFromOnlinePlayers = true -- When a hack is successful the total reward devided by the player count will be taken for each player online. Set to false to disable taking from online players and let the "server" give the reward purely.

CH_ATM.Config.EmitSoundOnHacking = true -- Should we emit an alarm sound from the ATM once hacking begins?
CH_ATM.Config.TheAlarmSound = "ambient/_period.wav ambient/alarms/alarm1.wav" -- The alarm sound path
CH_ATM.Config.AlarmSoundVolume = 100 -- The volume the sound is emitted at

CH_ATM.Config.MakePlayerWantedOnHack = true -- Should we make the hacker wanted once he begins lockpicking the ATM?
CH_ATM.Config.PlayerWantedTime = 120 -- For how long should we make him wanted?

CH_ATM.Config.UnwantedAfterHacking = false -- Once hacking finishes (success or failed) do we make him unwanted?

CH_ATM.Config.KillHackerReward = 500 -- How much money is rewarded if a police officer kills a hacker?
CH_ATM.Config.ArrestHackerReward = 2000 -- How much money is rewarded if a police officer arrests a hacker?

--[[
	Credit Card / Terminal Config
--]]
CH_ATM.Config.DistanceToTerminal = 7000 -- Distance between player with a credit card and credit card scanner for it to swipe.
CH_ATM.Config.UseCreditCardDelay = 4 -- How many seconds delay on using your credit card? MINIMUM 3 SECONDS!

CH_ATM.Config.TerminalDefaultColor = Color( 255, 255, 255, 255 ) -- What color should the credit card terminal be by default?

CH_ATM.Config.CanPressAltEToPay = false -- Should we allow players to press ALT + E on a terminal to pay?
CH_ATM.Config.AltKeyToPay = IN_WALK -- Uses ALT by default. You can use anything from here https://wiki.facepunch.com/gmod/Enums/IN

--[[
	Transactions
--]]
CH_ATM.Config.MaximumTransactionsToShow = 30 -- How many transactions should we maximum network to the player?

--[[
	XP SUPPORT
--]]
CH_ATM.Config.SuccessfulHackXP = 20 -- Amount of XP given when a player successfully hacks an ATM.

CH_ATM.Config.KillingHackerMinXP = 20 -- Minimum amount of XP given for killing hacker.
CH_ATM.Config.KillingHackerMaxXP = 50 -- Maximum amount of XP given for killing hacker.

CH_ATM.Config.ArrestingHackerMinXP = 20 -- Minimum amount of XP given for arresting hacker.
CH_ATM.Config.ArrestingHackerMaxXP = 50 -- Maximum amount of XP given for arresting hacker.
--addons/ch_atm/lua/ch_atm/shared/ch_atm_config_upgrades.lua:
--[[
	Bank Account Levels Config
	InterestRate = How much percentage of the players bank account to give in interest rates.
	MaxInterestToEarn = How much can a player maximum earn in interest per interval? Set to 0 to disable the max
	MaxMoney = How much money can the players bank account maximum hold? 0 for unlimited.
	UpgradePrice = How much does it cost the player to upgrade to this level?
	
	NOTE: The first one [ 1 ] is the default level.
--]]
CH_ATM.Config.AccountLevels = {
	[ 1 ] = {
		InterestRate = 0.01,
		MaxInterestToEarn = 1000,
		MaxMoney = 1000000,
		UpgradePrice = 0,
	},
	[ 2 ] = {
		InterestRate = 0.02,
		MaxInterestToEarn = 2000,
		MaxMoney = 2000000,
		UpgradePrice = 20000,
	},
	[ 3 ] = {
		InterestRate = 0.03,
		MaxInterestToEarn = 3000,
		MaxMoney = 3000000,
		UpgradePrice = 30000,
	},
	[ 4 ] = {
		InterestRate = 0.04,
		MaxInterestToEarn = 4000,
		MaxMoney = 4000000,
		UpgradePrice = 40000,
	},
	[ 5 ] = {
		InterestRate = 0.05,
		MaxInterestToEarn = 5000,
		MaxMoney = 5000000,
		UpgradePrice = 50000,
	},
	[ 6 ] = {
		InterestRate = 0.06,
		MaxInterestToEarn = 6000,
		MaxMoney = 6000000,
		UpgradePrice = 60000,
	},
	[ 7 ] = {
		InterestRate = 0.07,
		MaxInterestToEarn = 7000,
		MaxMoney = 7000000,
		UpgradePrice = 70000,
	},
	[ 8 ] = {
		InterestRate = 0.08,
		MaxInterestToEarn = 8000,
		MaxMoney = 8000000,
		UpgradePrice = 80000,
	},
	[ 9 ] = {
		InterestRate = 0.09,
		MaxInterestToEarn = 9000,
		MaxMoney = 9000000,
		UpgradePrice = 90000,
	},
	[ 10 ] = {
		InterestRate = 0.10,
		MaxInterestToEarn = 10000,
		MaxMoney = 0,
		UpgradePrice = 100000,
	},
}
--addons/ch_atm/lua/ch_atm/shared/currencies/sh_pointshop.lua:
CH_ATM.Currencies[ "sh_pointshop" ] = {
	Name = "SH Pointshop Points",
	
	AddMoney = function( ply, amount )
		ply:SH_AddStandardPoints( amount )
	end,
	
	TakeMoney = function( ply, amount )
		ply:SH_AddStandardPoints( -amount )
	end,
	
	GetMoney = function( ply )
		return ply:SH_GetStandardPoints()
	end,
	
	CanAfford = function( ply, amount )
		return ply:SH_CanAffordStandard( amount )
	end,
	
	FormatMoney = function( amount )
		return string.Comma( amount ) .. " point" .. (amount > 1 and "s" or "")
	end,
	
	CurrencyAbbreviation = function()
		return "PTS"
	end,
}
--addons/ch_atm/lua/ch_atm/client/ch_atm_accounts_network.lua:
--[[
	This is a method of ensuring that the player is loaded in, so we can network stuff to them (PlayerInitialSpawn is unreliable)
	-- 76561198347218024
--]]
function CH_ATM.IsPlayerLoadedIn()
	if IsValid( LocalPlayer() ) then
		net.Start( "CH_ATM_Net_HUDPaintLoad" )
		net.SendToServer()
		
		hook.Remove( "HUDPaint", "CH_ATM.IsPlayerLoadedIn" )
	end
end
hook.Add( "HUDPaint", "CH_ATM.IsPlayerLoadedIn", CH_ATM.IsPlayerLoadedIn )

--[[
	Receive the players bank account and network it to him
--]]
net.Receive( "CH_ATM_Net_NetworkBankAccount", function( len, ply )
	local bank_account = net.ReadUInt( 32 )
	local bank_account_level = net.ReadUInt( 8 )
	local player = LocalPlayer()
	
	player.CH_ATM_BankAccount = bank_account
	player.CH_ATM_BankAccountLevel = bank_account_level

	CH_ATM.DebugPrint( "CLIENTSIDE BANK ACCOUNT FOR: ".. player:Nick() )
	CH_ATM.DebugPrint( player.CH_ATM_BankAccount )
	CH_ATM.DebugPrint( player.CH_ATM_BankAccountLevel )
end )

--[[
	Receive the players bank interest rate and network it to him
--]]
net.Receive( "CH_ATM_Net_NetworkInterestRate", function( len, ply )
	local interest_rate = net.ReadDouble()
	local player = LocalPlayer()
	
	player.CH_ATM_InterestRate = interest_rate

	CH_ATM.DebugPrint( "CLIENTSIDE BANK INTEREST RATE FOR: ".. player:Nick() )
	CH_ATM.DebugPrint( player.CH_ATM_InterestRate )
end )

--[[
	Receive the players bank transactions and network it to him
--]]
net.Receive( "CH_ATM_Net_NetworkTransactions", function( len, ply )
	local amount_of_entries = net.ReadUInt( 6 )
	
	-- Create the clientside table if it does not exist
	local ply = LocalPlayer()
	ply.CH_ATM_Transactions = {}
	
	for i = 1, amount_of_entries do
		local action = net.ReadString()
		local amount = net.ReadDouble()
		local timestamp = net.ReadString()
	
		ply.CH_ATM_Transactions[ i ] = {
			Action = action,
			Amount = amount,
			TimeStamp = timestamp,
		}
	end

	CH_ATM.DebugPrint( "CLIENTSIDE ATM TRANSACTIONS FOR: ".. ply:Nick() )
	CH_ATM.DebugPrint( ply.CH_ATM_Transactions )
end )
--addons/ch_atm/lua/ch_atm/client/ch_atm_admin.lua:
--[[
	Simple CL var if an admin has triggered the emergency lockdown on ATMs
--]]
CH_ATM.HasAdminEmergencyLockdownATM = false

--[[
	Function to draw halo on ATM for the admin if enabled through admin menu
--]]
function CH_ATM.DrawEntitiesHalo()
	local ply = LocalPlayer()
	
	if not ply:CH_ATM_IsAdmin() then
		return
	end
	
	if not ply:Alive() then
		return
	end
	
	if not ply.CH_ATM_ShowATMEntitiesOnMap then
		return
	end
	
	halo.Add( ents.FindByClass( "ch_atm" ), CH_ATM.Colors.Red, 2, 2, 5, true, true )
end
hook.Add( "PreDrawHalos", "CH_ATM.DrawEntitiesHalo", CH_ATM.DrawEntitiesHalo )
--addons/ch_atm/lua/ch_atm/client/ch_atm_client_settings.lua:
return gluapack()()
--addons/ch_bitminers_dlc/lua/ch_bitminers_dlc/shared/bitminers_dlc_darkrp_entities.lua:
return gluapack()()
--addons/ch_bitminers/lua/ch_bitminers/shared/bitminers_darkrp_entities.lua:
return gluapack()()
--addons/ch_bitminers/lua/ch_bitminers/shared/bitminers_util.lua:
return gluapack()()
--addons/ch_mayor/lua/autorun/ch_mayor_initialize.lua:
-- INITIALIZE SCRIPT
if SERVER then
	for k, v in ipairs( file.Find( "ch_adv_mayor/shared/config/*.lua", "LUA" ) ) do
		include( "ch_adv_mayor/shared/config/".. v )
		AddCSLuaFile( "ch_adv_mayor/shared/config/".. v )
	end
	
	for k, v in ipairs( file.Find( "ch_adv_mayor/shared/config/upgrades/*.lua", "LUA" ) ) do
		include( "ch_adv_mayor/shared/config/upgrades/".. v )
		AddCSLuaFile( "ch_adv_mayor/shared/config/upgrades/".. v )
	end
	
	for k, v in ipairs( file.Find( "ch_adv_mayor/shared/config/catalog/*.lua", "LUA" ) ) do
		include( "ch_adv_mayor/shared/config/catalog/".. v )
		AddCSLuaFile( "ch_adv_mayor/shared/config/catalog/".. v )
	end
	
	for k, v in ipairs( file.Find( "ch_adv_mayor/shared/*.lua", "LUA" ) ) do
		include( "ch_adv_mayor/shared/".. v )
		AddCSLuaFile( "ch_adv_mayor/shared/".. v )
	end
	
	for k, v in ipairs( file.Find( "ch_adv_mayor/server/*.lua", "LUA" ) ) do
		include( "ch_adv_mayor/server/".. v )
	end
	
	for k, v in ipairs( file.Find( "ch_adv_mayor/server/sql/*.lua", "LUA" ) ) do
		include( "ch_adv_mayor/server/sql/".. v )
	end
	
	for k, v in ipairs( file.Find( "ch_adv_mayor/server/integrations/*.lua", "LUA" ) ) do
		include( "ch_adv_mayor/server/integrations/".. v )
	end
	
	for k, v in ipairs( file.Find( "ch_adv_mayor/client/*.lua", "LUA" ) ) do
		AddCSLuaFile( "ch_adv_mayor/client/".. v )
	end
	
	for k, v in ipairs( file.Find( "ch_adv_mayor/client/vgui/*.lua", "LUA" ) ) do
		AddCSLuaFile( "ch_adv_mayor/client/vgui/".. v )
	end
end

if CLIENT then
	for k, v in ipairs( file.Find( "ch_adv_mayor/shared/config/*.lua", "LUA" ) ) do
		include( "ch_adv_mayor/shared/config/".. v )
	end
	
	for k, v in ipairs( file.Find( "ch_adv_mayor/shared/config/upgrades/*.lua", "LUA" ) ) do
		include( "ch_adv_mayor/shared/config/upgrades/".. v )
	end
	
	for k, v in ipairs( file.Find( "ch_adv_mayor/shared/config/catalog/*.lua", "LUA" ) ) do
		include( "ch_adv_mayor/shared/config/catalog/".. v )
	end
	
	for k, v in ipairs( file.Find( "ch_adv_mayor/shared/*.lua", "LUA" ) ) do
		include( "ch_adv_mayor/shared/".. v )
	end
	
	for k, v in ipairs( file.Find( "ch_adv_mayor/client/*.lua", "LUA" ) ) do
		include( "ch_adv_mayor/client/".. v )
	end
	
	for k, v in ipairs( file.Find( "ch_adv_mayor/client/vgui/*.lua", "LUA" ) ) do
		include( "ch_adv_mayor/client/vgui/".. v )
	end
end
--addons/ch_mayor/lua/ch_adv_mayor/client/ch_mayor_leaderboards.lua:
return gluapack()()
--addons/ch_mayor/lua/ch_adv_mayor/client/vgui/ch_mayor_menu_civilians.lua:
return gluapack()()
--addons/ch_mayor/lua/ch_adv_mayor/client/vgui/ch_mayor_menu_officials.lua:
--[[
	MAYOR CIVILIANS MENU
--]]
function CH_Mayor.OfficialsMenu()
	local ply = LocalPlayer()

	local GUI_OfficialsFrame = vgui.Create( "DFrame" )
	GUI_OfficialsFrame:SetTitle( "" )
	GUI_OfficialsFrame:SetSize( CH_Mayor.ScrW * 0.6, CH_Mayor.ScrH * 0.665 )
	GUI_OfficialsFrame:Center()
	GUI_OfficialsFrame.Paint = function( self, w, h )
		-- Draw frame
		surface.SetDrawColor( CH_Mayor.Colors.GrayFront )
		surface.DrawRect( 0, 0, w, h )
		
		-- Draw top
		surface.SetDrawColor( CH_Mayor.Colors.GrayBG )
		surface.DrawRect( 0, 0, w, h * 0.059 )
		
		-- Draw the top title.
		draw.SimpleText( CH_Mayor.LangString( "City Management" ), "CH_Mayor_Font_Size10", w / 2, h * 0.03, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		
		-- Draw titles
		surface.SetDrawColor( CH_Mayor.Colors.GrayBG )
		surface.DrawRect( w * 0.182, h * 0.0724, w * 0.812, h * 0.06 )
		
		draw.SimpleText( "#", "CH_Mayor_Font_Size10", w * 0.2, h * 0.1, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		
		draw.SimpleText( CH_Mayor.LangString( "Official" ), "CH_Mayor_Font_Size10", w * 0.375, h * 0.1, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		
		draw.SimpleText( CH_Mayor.LangString( "Job" ), "CH_Mayor_Font_Size10", w * 0.55, h * 0.1, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		
		draw.SimpleText( CH_Mayor.LangString( "Action" ), "CH_Mayor_Font_Size10", w * 0.725, h * 0.1, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		
		draw.SimpleText( CH_Mayor.LangString( "Action" ), "CH_Mayor_Font_Size10", w * 0.9, h * 0.1, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	GUI_OfficialsFrame:MakePopup()
	GUI_OfficialsFrame:SetDraggable( false )
	GUI_OfficialsFrame:ShowCloseButton( false )
	
	local GUI_CloseMenu = vgui.Create( "DButton", GUI_OfficialsFrame )
	GUI_CloseMenu:SetPos( CH_Mayor.ScrW * 0.582, CH_Mayor.ScrH * 0.01 )
	GUI_CloseMenu:SetSize( CH_Mayor.ScrW * 0.0125, CH_Mayor.ScrH * 0.02223 )
	GUI_CloseMenu:SetText( "" )
	GUI_CloseMenu.Paint = function( self, w, h )
		surface.SetDrawColor( self:IsHovered() and CH_Mayor.Colors.Red or color_white )
		surface.SetMaterial( CH_Mayor.Materials.CloseIcon )
		surface.DrawTexturedRect( 0, 0, CH_Mayor.ScrW * 0.0125, CH_Mayor.ScrH * 0.02223 )
	end
	GUI_CloseMenu.DoClick = function()
		GUI_OfficialsFrame:Remove()
	end
	
	local GUI_DashboardFrameBtn = vgui.Create( "DButton", GUI_OfficialsFrame )
	GUI_DashboardFrameBtn:SetSize( CH_Mayor.ScrW * 0.1, CH_Mayor.ScrH * 0.04 )
	GUI_DashboardFrameBtn:SetPos( CH_Mayor.ScrW * 0.005, CH_Mayor.ScrH * 0.0475 )
	GUI_DashboardFrameBtn:SetText( "" )
	GUI_DashboardFrameBtn.Paint = function( self, w, h )
		surface.SetDrawColor( self:IsHovered() and CH_Mayor.Colors.GMSBlue or CH_Mayor.Colors.GrayBG )
		surface.DrawRect( 0, 0, w, h )

		surface.SetDrawColor( color_white )
		surface.SetMaterial( CH_Mayor.Materials.Icon_Dashboard )
		surface.DrawTexturedRect( w * 0.065, h * 0.18, CH_Mayor.ScrW * 0.014065, CH_Mayor.ScrH * 0.025 )
		
		draw.SimpleText( CH_Mayor.LangString( "Dashboard" ), "CH_Mayor_Font_Size9", w * 0.25, h / 2, self:IsHovered() and color_white or CH_Mayor.Colors.WhiteAlpha2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
	end
	GUI_DashboardFrameBtn.DoClick = function()
		GUI_OfficialsFrame:Remove()
		
		CH_Mayor.DashboardMenu()
	end

	local GUI_UpgradesFrameBtn = vgui.Create( "DButton", GUI_OfficialsFrame )
	GUI_UpgradesFrameBtn:SetSize( CH_Mayor.ScrW * 0.1, CH_Mayor.ScrH * 0.04 )
	GUI_UpgradesFrameBtn:SetPos( CH_Mayor.ScrW * 0.005, CH_Mayor.ScrH * 0.095 )
	GUI_UpgradesFrameBtn:SetText( "" )
	GUI_UpgradesFrameBtn.Paint = function( self, w, h )
		surface.SetDrawColor( self:IsHovered() and CH_Mayor.Colors.GMSBlue or CH_Mayor.Colors.GrayBG )
		surface.DrawRect( 0, 0, w, h )

		surface.SetDrawColor( color_white )
		surface.SetMaterial( CH_Mayor.Materials.Icon_Upgrades )
		surface.DrawTexturedRect( w * 0.065, h * 0.18, CH_Mayor.ScrW * 0.014065, CH_Mayor.ScrH * 0.025 )
		
		draw.SimpleText( CH_Mayor.LangString( "Upgrades" ), "CH_Mayor_Font_Size9", w * 0.25, h / 2, self:IsHovered() and color_white or CH_Mayor.Colors.WhiteAlpha2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
	end
	GUI_UpgradesFrameBtn.DoClick = function()
		GUI_OfficialsFrame:Remove()
		
		CH_Mayor.UpgradesMenu()
	end
	
	local GUI_TaxesFrameBtn = vgui.Create( "DButton", GUI_OfficialsFrame )
	GUI_TaxesFrameBtn:SetSize( CH_Mayor.ScrW * 0.1, CH_Mayor.ScrH * 0.04 )
	GUI_TaxesFrameBtn:SetPos( CH_Mayor.ScrW * 0.005, CH_Mayor.ScrH * 0.1425 )
	GUI_TaxesFrameBtn:SetText( "" )
	GUI_TaxesFrameBtn.Paint = function( self, w, h )
		surface.SetDrawColor( self:IsHovered() and CH_Mayor.Colors.GMSBlue or CH_Mayor.Colors.GrayBG )
		surface.DrawRect( 0, 0, w, h )

		surface.SetDrawColor( color_white )
		surface.SetMaterial( CH_Mayor.Materials.Icon_Taxes )
		surface.DrawTexturedRect( w * 0.065, h * 0.18, CH_Mayor.ScrW * 0.014065, CH_Mayor.ScrH * 0.025 )
		
		draw.SimpleText( CH_Mayor.LangString( "Taxes" ), "CH_Mayor_Font_Size9", w * 0.25, h / 2, self:IsHovered() and color_white or CH_Mayor.Colors.WhiteAlpha2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
	end
	GUI_TaxesFrameBtn.DoClick = function()
		GUI_OfficialsFrame:Remove()
		
		CH_Mayor.TaxesMenu()
	end

	local GUI_CatalogFrameBtn = vgui.Create( "DButton", GUI_OfficialsFrame )
	GUI_CatalogFrameBtn:SetSize( CH_Mayor.ScrW * 0.1, CH_Mayor.ScrH * 0.04 )
	GUI_CatalogFrameBtn:SetPos( CH_Mayor.ScrW * 0.005, CH_Mayor.ScrH * 0.19 )
	GUI_CatalogFrameBtn:SetText( "" )
	GUI_CatalogFrameBtn.Paint = function( self, w, h )
		surface.SetDrawColor( self:IsHovered() and CH_Mayor.Colors.GMSBlue or CH_Mayor.Colors.GrayBG )
		surface.DrawRect( 0, 0, w, h )

		surface.SetDrawColor( color_white )
		surface.SetMaterial( CH_Mayor.Materials.Icon_Catalog )
		surface.DrawTexturedRect( w * 0.065, h * 0.18, CH_Mayor.ScrW * 0.014065, CH_Mayor.ScrH * 0.025 )
		
		draw.SimpleText( CH_Mayor.LangString( "Catalog" ), "CH_Mayor_Font_Size9", w * 0.25, h / 2, self:IsHovered() and color_white or CH_Mayor.Colors.WhiteAlpha2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
	end
	GUI_CatalogFrameBtn.DoClick = function()
		GUI_OfficialsFrame:Remove()
		
		CH_Mayor.CatalogMenu()
	end
	
	local GUI_LawsFrameBtn = vgui.Create( "DButton", GUI_OfficialsFrame )
	GUI_LawsFrameBtn:SetSize( CH_Mayor.ScrW * 0.1, CH_Mayor.ScrH * 0.04 )
	GUI_LawsFrameBtn:SetPos( CH_Mayor.ScrW * 0.005, CH_Mayor.ScrH * 0.2375 )
	GUI_LawsFrameBtn:SetText( "" )
	GUI_LawsFrameBtn.Paint = function( self, w, h )
		surface.SetDrawColor( self:IsHovered() and CH_Mayor.Colors.GMSBlue or CH_Mayor.Colors.GrayBG )
		surface.DrawRect( 0, 0, w, h )

		surface.SetDrawColor( color_white )
		surface.SetMaterial( CH_Mayor.Materials.Icon_Laws )
		surface.DrawTexturedRect( w * 0.065, h * 0.18, CH_Mayor.ScrW * 0.014065, CH_Mayor.ScrH * 0.025 )
		
		draw.SimpleText( CH_Mayor.LangString( "Laws" ), "CH_Mayor_Font_Size9", w * 0.25, h / 2, self:IsHovered() and color_white or CH_Mayor.Colors.WhiteAlpha2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
	end
	GUI_LawsFrameBtn.DoClick = function()
		GUI_OfficialsFrame:Remove()
		
		CH_Mayor.LawsMenu()
	end
	
	local GUI_OfficialsFrameBtn = vgui.Create( "DButton", GUI_OfficialsFrame )
	GUI_OfficialsFrameBtn:SetSize( CH_Mayor.ScrW * 0.1, CH_Mayor.ScrH * 0.04 )
	GUI_OfficialsFrameBtn:SetPos( CH_Mayor.ScrW * 0.005, CH_Mayor.ScrH * 0.285 )
	GUI_OfficialsFrameBtn:SetText( "" )
	GUI_OfficialsFrameBtn.Paint = function( self, w, h )
		surface.SetDrawColor( self:IsHovered() and CH_Mayor.Colors.GMSBlue or CH_Mayor.Colors.GrayBG )
		surface.DrawRect( 0, 0, w, h )

		surface.SetDrawColor( color_white )
		surface.SetMaterial( CH_Mayor.Materials.Icon_Licenses )
		surface.DrawTexturedRect( w * 0.065, h * 0.18, CH_Mayor.ScrW * 0.014065, CH_Mayor.ScrH * 0.025 )
		
		draw.SimpleText( CH_Mayor.LangString( "Licenses" ), "CH_Mayor_Font_Size9", w * 0.25, h / 2, self:IsHovered() and color_white or CH_Mayor.Colors.WhiteAlpha2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
	end
	GUI_OfficialsFrameBtn.DoClick = function()
		GUI_OfficialsFrame:Remove()
		
		CH_Mayor.LicensesMenu( )
	end
	
	local GUI_OfficialsManagementFrameBtn = vgui.Create( "DButton", GUI_OfficialsFrame )
	GUI_OfficialsManagementFrameBtn:SetSize( CH_Mayor.ScrW * 0.1, CH_Mayor.ScrH * 0.04 )
	GUI_OfficialsManagementFrameBtn:SetPos( CH_Mayor.ScrW * 0.005, CH_Mayor.ScrH * 0.3325 )
	GUI_OfficialsManagementFrameBtn:SetText( "" )
	GUI_OfficialsManagementFrameBtn.Paint = function( self, w, h )
		surface.SetDrawColor( self:IsHovered() and CH_Mayor.Colors.GMSBlue or CH_Mayor.Colors.GrayBG )
		surface.DrawRect( 0, 0, w, h )

		surface.SetDrawColor( CH_Mayor.Colors.GMSBlue )
		surface.DrawRect( 0, 0, 2, h )
		
		surface.SetDrawColor( color_white )
		surface.SetMaterial( CH_Mayor.Materials.Icon_OfficialsManagement )
		surface.DrawTexturedRect( w * 0.065, h * 0.18, CH_Mayor.ScrW * 0.014065, CH_Mayor.ScrH * 0.025 )
		
		draw.SimpleText( CH_Mayor.LangString( "Officials" ), "CH_Mayor_Font_Size9", w * 0.25, h / 2, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
	end
	GUI_OfficialsManagementFrameBtn.DoClick = function()
		GUI_OfficialsFrame:Remove()
		
		CH_Mayor.OfficialsMenu()
	end
	
	local GUI_CiviliansManagementFrameBtn = vgui.Create( "DButton", GUI_OfficialsFrame )
	GUI_CiviliansManagementFrameBtn:SetSize( CH_Mayor.ScrW * 0.1, CH_Mayor.ScrH * 0.04 )
	GUI_CiviliansManagementFrameBtn:SetPos( CH_Mayor.ScrW * 0.005, CH_Mayor.ScrH * 0.38 )
	GUI_CiviliansManagementFrameBtn:SetText( "" )
	GUI_CiviliansManagementFrameBtn.Paint = function( self, w, h )
		surface.SetDrawColor( self:IsHovered() and CH_Mayor.Colors.GMSBlue or CH_Mayor.Colors.GrayBG )
		surface.DrawRect( 0, 0, w, h )

		surface.SetDrawColor( color_white )
		surface.SetMaterial( CH_Mayor.Materials.Icon_CivilianManagement )
		surface.DrawTexturedRect( w * 0.065, h * 0.18, CH_Mayor.ScrW * 0.014065, CH_Mayor.ScrH * 0.025 )
		
		draw.SimpleText( CH_Mayor.LangString( "Civilians" ), "CH_Mayor_Font_Size9", w * 0.25, h / 2, self:IsHovered() and color_white or CH_Mayor.Colors.WhiteAlpha2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
	end
	GUI_CiviliansManagementFrameBtn.DoClick = function()
		GUI_OfficialsFrame:Remove()
		
		CH_Mayor.CiviliansMenu()
	end
	
	local GUI_WantedFrameBtn = vgui.Create( "DButton", GUI_OfficialsFrame )
	GUI_WantedFrameBtn:SetSize( CH_Mayor.ScrW * 0.1, CH_Mayor.ScrH * 0.04 )
	GUI_WantedFrameBtn:SetPos( CH_Mayor.ScrW * 0.005, CH_Mayor.ScrH * 0.4275 )
	GUI_WantedFrameBtn:SetText( "" )
	GUI_WantedFrameBtn.Paint = function( self, w, h )
		surface.SetDrawColor( self:IsHovered() and CH_Mayor.Colors.GMSBlue or CH_Mayor.Colors.GrayBG )
		surface.DrawRect( 0, 0, w, h )

		surface.SetDrawColor( color_white )
		surface.SetMaterial( CH_Mayor.Materials.Icon_Wanted )
		surface.DrawTexturedRect( w * 0.065, h * 0.18, CH_Mayor.ScrW * 0.014065, CH_Mayor.ScrH * 0.025 )
		
		draw.SimpleText( CH_Mayor.LangString( "Wanted" ), "CH_Mayor_Font_Size9", w * 0.25, h / 2, self:IsHovered() and color_white or CH_Mayor.Colors.WhiteAlpha2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
	end
	GUI_WantedFrameBtn.DoClick = function()
		GUI_OfficialsFrame:Remove()
		
		CH_Mayor.WantedMenu()
	end
	
	local GUI_WarrantFrameBtn = vgui.Create( "DButton", GUI_OfficialsFrame )
	GUI_WarrantFrameBtn:SetSize( CH_Mayor.ScrW * 0.1, CH_Mayor.ScrH * 0.04 )
	GUI_WarrantFrameBtn:SetPos( CH_Mayor.ScrW * 0.005, CH_Mayor.ScrH * 0.475 )
	GUI_WarrantFrameBtn:SetText( "" )
	GUI_WarrantFrameBtn.Paint = function( self, w, h )
		surface.SetDrawColor( self:IsHovered() and CH_Mayor.Colors.GMSBlue or CH_Mayor.Colors.GrayBG )
		surface.DrawRect( 0, 0, w, h )

		surface.SetDrawColor( color_white )
		surface.SetMaterial( CH_Mayor.Materials.Icon_Warrant )
		surface.DrawTexturedRect( w * 0.065, h * 0.18, CH_Mayor.ScrW * 0.014065, CH_Mayor.ScrH * 0.025 )
		
		draw.SimpleText( CH_Mayor.LangString( "Warrant" ), "CH_Mayor_Font_Size9", w * 0.25, h / 2, self:IsHovered() and color_white or CH_Mayor.Colors.WhiteAlpha2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
	end
	GUI_WarrantFrameBtn.DoClick = function()
		GUI_OfficialsFrame:Remove()
		
		CH_Mayor.WarrantMenu()
	end
	
	local GUI_AnnouncementFrameBtn = vgui.Create( "DButton", GUI_OfficialsFrame )
	GUI_AnnouncementFrameBtn:SetSize( CH_Mayor.ScrW * 0.1, CH_Mayor.ScrH * 0.04 )
	GUI_AnnouncementFrameBtn:SetPos( CH_Mayor.ScrW * 0.005, CH_Mayor.ScrH * 0.5225 )
	GUI_AnnouncementFrameBtn:SetText( "" )
	GUI_AnnouncementFrameBtn.Paint = function( self, w, h )
		surface.SetDrawColor( self:IsHovered() and CH_Mayor.Colors.GMSBlue or CH_Mayor.Colors.GrayBG )
		surface.DrawRect( 0, 0, w, h )

		surface.SetDrawColor( color_white )
		surface.SetMaterial( CH_Mayor.Materials.Icon_Announcement )
		surface.DrawTexturedRect( w * 0.065, h * 0.18, CH_Mayor.ScrW * 0.014065, CH_Mayor.ScrH * 0.025 )
		
		draw.SimpleText( CH_Mayor.LangString( "Announcement" ), "CH_Mayor_Font_Size9", w * 0.25, h / 2, self:IsHovered() and color_white or CH_Mayor.Colors.WhiteAlpha2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
	end
	GUI_AnnouncementFrameBtn.DoClick = function()
		GUI_OfficialsFrame:Remove()
		
		CH_Mayor.AnnouncementMenu()
	end
	
	local GUI_LockdownFrameBtn = vgui.Create( "DButton", GUI_OfficialsFrame )
	GUI_LockdownFrameBtn:SetSize( CH_Mayor.ScrW * 0.1, CH_Mayor.ScrH * 0.04 )
	GUI_LockdownFrameBtn:SetPos( CH_Mayor.ScrW * 0.005, CH_Mayor.ScrH * 0.57 )
	GUI_LockdownFrameBtn:SetText( "" )
	GUI_LockdownFrameBtn.Paint = function( self, w, h )
		surface.SetDrawColor( self:IsHovered() and CH_Mayor.Colors.GMSBlue or CH_Mayor.Colors.GrayBG )
		surface.DrawRect( 0, 0, w, h )

		surface.SetDrawColor( color_white )
		surface.SetMaterial( CH_Mayor.Materials.Icon_Lockdown )
		surface.DrawTexturedRect( w * 0.065, h * 0.18, CH_Mayor.ScrW * 0.014065, CH_Mayor.ScrH * 0.025 )
		
		draw.SimpleText( CH_Mayor.LangString( "Lockdown" ), "CH_Mayor_Font_Size9", w * 0.25, h / 2, self:IsHovered() and color_white or CH_Mayor.Colors.WhiteAlpha2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
	end
	GUI_LockdownFrameBtn.DoClick = function()
		GUI_OfficialsFrame:Remove()
		
		CH_Mayor.LockdownMenu()
	end
	
	local GUI_StatsFrameBtn = vgui.Create( "DButton", GUI_OfficialsFrame )
	GUI_StatsFrameBtn:SetSize( CH_Mayor.ScrW * 0.1, CH_Mayor.ScrH * 0.04 )
	GUI_StatsFrameBtn:SetPos( CH_Mayor.ScrW * 0.005, CH_Mayor.ScrH * 0.6175 )
	GUI_StatsFrameBtn:SetText( "" )
	GUI_StatsFrameBtn.Paint = function( self, w, h )
		surface.SetDrawColor( self:IsHovered() and CH_Mayor.Colors.GMSBlue or CH_Mayor.Colors.GrayBG )
		surface.DrawRect( 0, 0, w, h )

		surface.SetDrawColor( color_white )
		surface.SetMaterial( CH_Mayor.Materials.Icon_Economy )
		surface.DrawTexturedRect( w * 0.065, h * 0.18, CH_Mayor.ScrW * 0.014065, CH_Mayor.ScrH * 0.025 )
		
		draw.SimpleText( CH_Mayor.LangString( "Statistics" ), "CH_Mayor_Font_Size9", w * 0.25, h / 2, self:IsHovered() and color_white or CH_Mayor.Colors.WhiteAlpha2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
	end
	GUI_StatsFrameBtn.DoClick = function()
		GUI_OfficialsFrame:Remove()
		
		CH_Mayor.StatisticsMenu()
	end
	
	-- The list of players
	local total_players = player.GetCount()
	local official_players = {}
	
	for k, v in ipairs( player.GetAll() ) do
		if v:CH_Mayor_IsGovTeam() and ply != v then
			table.insert( official_players, v )
		end
	end
	
	local GUI_PlayerList = vgui.Create( "DPanelList", GUI_OfficialsFrame )
	GUI_PlayerList:SetSize( CH_Mayor.ScrW * 0.491, CH_Mayor.ScrH * 0.563 )
	GUI_PlayerList:SetPos( CH_Mayor.ScrW * 0.109, CH_Mayor.ScrH * 0.095 )
	GUI_PlayerList:EnableVerticalScrollbar( true )
	GUI_PlayerList:EnableHorizontal( true )
	GUI_PlayerList:SetSpacing( 8.4 )
	GUI_PlayerList.Paint = function( self, w, h )
		draw.RoundedBox( 0, 0, 0, w, h, color_transparent )
	end
	if ( GUI_PlayerList.VBar ) then
		GUI_PlayerList.VBar.Paint = function( self, w, h ) -- BG
			surface.SetDrawColor( CH_Mayor.Colors.GrayBG )
			surface.DrawRect( 0, 0, 7, h )
		end
		
		GUI_PlayerList.VBar.btnUp.Paint = function( self, w, h )
			surface.SetDrawColor( CH_Mayor.Colors.GrayBG )
			surface.DrawRect( 0, 0, 7, h )
		end
		
		GUI_PlayerList.VBar.btnGrip.Paint = function( self, w, h )
			surface.SetDrawColor( CH_Mayor.Colors.GMSBlue )
			surface.DrawRect( 0, 0, 7, h )
		end
		
		GUI_PlayerList.VBar.btnDown.Paint = function( self, w, h )
			surface.SetDrawColor( CH_Mayor.Colors.GrayBG )
			surface.DrawRect( 0, 0, 7, h )
		end
	end
	
	for k, v in ipairs( official_players ) do
		local GUI_PlayerPanel = vgui.Create( "DPanelList" )
		GUI_PlayerPanel:SetSize( CH_Mayor.ScrW * 0.487, CH_Mayor.ScrH * 0.04 )
		GUI_PlayerPanel.Paint = function( self, w, h )
			-- Background
			surface.SetDrawColor( CH_Mayor.Colors.GrayBG )
			if total_players <= 13 then
				surface.DrawRect( 0, 0, w, h )
			else
				surface.DrawRect( 0, 0, w * 0.986, h )
			end
			
			-- Number
			draw.SimpleText( k, "CH_Mayor_Font_Size8", w * 0.0225, h / 2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
			
			-- Name
			draw.SimpleText( v:Nick(), "CH_Mayor_Font_Size8", w * 0.241, h / 2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
			
			-- Job
			draw.SimpleText( team.GetName( v:Team() ), "CH_Mayor_Font_Size8", w * 0.455, h / 2, team.GetColor( v:Team() ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		end
		
		if CH_Mayor.Config.PromotableTeams[ team.GetName( v:Team() ) ] then
			local GUI_PromotePlayerBtn = vgui.Create( "DButton", GUI_PlayerPanel )
			GUI_PromotePlayerBtn:SetSize( CH_Mayor.ScrW * 0.05, CH_Mayor.ScrH * 0.03 )
			GUI_PromotePlayerBtn:SetPos( CH_Mayor.ScrW * 0.3025, CH_Mayor.ScrH * 0.005 )
			GUI_PromotePlayerBtn:SetText( "" )
			GUI_PromotePlayerBtn.Paint = function( self, w, h )
				if self:IsHovered() then
					surface.SetDrawColor( CH_Mayor.Colors.GrayFront )
					surface.DrawRect( 0, 0, w, h )
					
					surface.SetDrawColor( CH_Mayor.Colors.Green )
					surface.DrawRect( 0, 0, w, 1 )
					surface.DrawRect( 0, h-1, w, 1 )
					surface.DrawRect( w-1, 0, 1, h )
					surface.DrawRect( 0, 0, 1, h )
				else
					surface.SetDrawColor( CH_Mayor.Colors.GrayFront )
					surface.DrawRect( 0, 0, w, h )
					
					surface.SetDrawColor( CH_Mayor.Colors.Green )
					surface.DrawRect( 0, 0, 1, 10 )
					surface.DrawRect( 0, 0, 10, 1 )
					surface.DrawRect( 0, h-10, 1, 10 )
					surface.DrawRect( 0, h-1, 10, 1 )
					surface.DrawRect( w-1, 0, 1, 10 )
					surface.DrawRect( w-10, 0, 10, 1 )
					surface.DrawRect( w-1, h-10, 1, 10 )
					surface.DrawRect( w-10, h-1, 10, 1 )
				end

				draw.SimpleText( CH_Mayor.LangString( "Promote" ), "CH_Mayor_Font_Size8", w / 2, h / 2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
			end
			GUI_PromotePlayerBtn.DoClick = function()
				CH_Mayor.PromotePlayerMenu( v )
				
				GUI_OfficialsFrame:Remove()
			end
		end
		
		local GUI_DemotePlayerBtn = vgui.Create( "DButton", GUI_PlayerPanel )
		GUI_DemotePlayerBtn:SetSize( CH_Mayor.ScrW * 0.05, CH_Mayor.ScrH * 0.03 )
		GUI_DemotePlayerBtn:SetPos( CH_Mayor.ScrW * 0.408, CH_Mayor.ScrH * 0.005 )
		GUI_DemotePlayerBtn:SetText( "" )
		GUI_DemotePlayerBtn.Paint = function( self, w, h )
			if self:IsHovered() then
				surface.SetDrawColor( CH_Mayor.Colors.GrayFront )
				surface.DrawRect( 0, 0, w, h )
				
				surface.SetDrawColor( CH_Mayor.Colors.Red )
				surface.DrawRect( 0, 0, w, 1 )
				surface.DrawRect( 0, h-1, w, 1 )
				surface.DrawRect( w-1, 0, 1, h )
				surface.DrawRect( 0, 0, 1, h )
			else
				surface.SetDrawColor( CH_Mayor.Colors.GrayFront )
				surface.DrawRect( 0, 0, w, h )
				
				surface.SetDrawColor( CH_Mayor.Colors.Red )
				surface.DrawRect( 0, 0, 1, 10 )
				surface.DrawRect( 0, 0, 10, 1 )
				surface.DrawRect( 0, h-10, 1, 10 )
				surface.DrawRect( 0, h-1, 10, 1 )
				surface.DrawRect( w-1, 0, 1, 10 )
				surface.DrawRect( w-10, 0, 10, 1 )
				surface.DrawRect( w-1, h-10, 1, 10 )
				surface.DrawRect( w-10, h-1, 10, 1 )
			end

			draw.SimpleText( CH_Mayor.LangString( "Demote" ), "CH_Mayor_Font_Size8", w / 2, h / 2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		end
		GUI_DemotePlayerBtn.DoClick = function()
			net.Start( "CH_Mayor_Net_DemotePlayer" )
				net.WriteEntity( v )
			net.SendToServer()
			
			GUI_OfficialsFrame:Remove()
		end
		
		GUI_PlayerList:AddItem( GUI_PlayerPanel )
	end
end

--[[
	SEARCH WARRANT MENU
--]]
function CH_Mayor.PromotePlayerMenu( target )
	local ply = LocalPlayer()

	local GUI_PromotePlayerFrame = vgui.Create( "DFrame" )
	GUI_PromotePlayerFrame:SetTitle( "" )
	GUI_PromotePlayerFrame:SetSize( CH_Mayor.ScrW * 0.23, CH_Mayor.ScrH * 0.2 )
	GUI_PromotePlayerFrame:Center()
	GUI_PromotePlayerFrame.Paint = function( self, w, h )
		-- Draw frame
		surface.SetDrawColor( CH_Mayor.Colors.GrayFront )
		surface.DrawRect( 0, 0, w, h )
		
		-- Draw top
		surface.SetDrawColor( CH_Mayor.Colors.GrayBG )
		surface.DrawRect( 0, 0, w, CH_Mayor.ScrH * 0.032 )

		-- Draw the top title.
		draw.SimpleText( CH_Mayor.LangString( "Promote Player" ), "CH_Mayor_Font_Size9", w / 2, CH_Mayor.ScrH * 0.015, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		
		-- Criminal name
		draw.SimpleText( target:Nick(), "CH_Mayor_Font_Size12", CH_Mayor.ScrW * 0.04, CH_Mayor.ScrH * 0.055, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
		
		draw.SimpleText( team.GetName( target:Team() ), "CH_Mayor_Font_Size8", CH_Mayor.ScrW * 0.04, CH_Mayor.ScrH * 0.078, team.GetColor( target:Team() ), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )

		-- Warrant reason entry BG
		surface.SetDrawColor( CH_Mayor.Colors.GrayBG )
		surface.DrawRect( CH_Mayor.ScrW * 0.005, CH_Mayor.ScrH * 0.1, CH_Mayor.ScrW * 0.221, CH_Mayor.ScrH * 0.04 )

	end
	GUI_PromotePlayerFrame:MakePopup()
	GUI_PromotePlayerFrame:SetDraggable( false )
	GUI_PromotePlayerFrame:ShowCloseButton( false )
	
	local GUI_CloseMenu = vgui.Create( "DButton", GUI_PromotePlayerFrame )
	GUI_CloseMenu:SetPos( CH_Mayor.ScrW * 0.2175, CH_Mayor.ScrH * 0.0085 )
	GUI_CloseMenu:SetSize( 16, 16 )
	GUI_CloseMenu:SetText( "" )
	GUI_CloseMenu.Paint = function( self, w, h )
		surface.SetDrawColor( self:IsHovered() and CH_Mayor.Colors.Red or color_white )
		surface.SetMaterial( CH_Mayor.Materials.CloseIcon )
		surface.DrawTexturedRect( 0, 0, 16, 16 )
	end
	GUI_CloseMenu.DoClick = function()
		GUI_PromotePlayerFrame:Remove()
	end
	
	local GUI_GoBack = vgui.Create( "DButton", GUI_PromotePlayerFrame )
	GUI_GoBack:SetPos( CH_Mayor.ScrW * 0.205, CH_Mayor.ScrH * 0.0085 )
	GUI_GoBack:SetSize( 16, 16 )
	GUI_GoBack:SetText( "" )
	GUI_GoBack.Paint = function( self, w, h )
		surface.SetDrawColor( self:IsHovered() and CH_Mayor.Colors.GMSBlue or color_white )
		surface.SetMaterial( CH_Mayor.Materials.BackIcon )
		surface.DrawTexturedRect( 0, 0, 16, 16 )
	end
	GUI_GoBack.DoClick = function()
		CH_Mayor.OfficialsMenu()
		
		GUI_PromotePlayerFrame:Remove()
	end
	
	local GUI_TeamModelSpawnI = vgui.Create( "SpawnIcon", GUI_PromotePlayerFrame )
	GUI_TeamModelSpawnI:SetSize( CH_Mayor.ScrW * 0.03, CH_Mayor.ScrH * 0.051 )
	GUI_TeamModelSpawnI:SetPos( CH_Mayor.ScrW * 0.0055, CH_Mayor.ScrH * 0.04 )
	GUI_TeamModelSpawnI:SetModel( target:GetModel(), target:GetSkin() )
	GUI_TeamModelSpawnI:SetVisible( true )
	GUI_TeamModelSpawnI.PaintOver = function( self )
		EndTooltip( self )
	end
	GUI_TeamModelSpawnI.OnMousePressed = function()
		return
	end
	
	local promote_team = CH_Mayor.LangString( "Select team" )
	
	local GUI_SelectPlayer = vgui.Create( "DComboBox", GUI_PromotePlayerFrame )
	GUI_SelectPlayer:SetPos( CH_Mayor.ScrW * 0.008, CH_Mayor.ScrH * 0.104 )
	GUI_SelectPlayer:SetSize( CH_Mayor.ScrW * 0.216, CH_Mayor.ScrH * 0.03 )
	GUI_SelectPlayer:SetValue( "" )
	GUI_SelectPlayer.OnSelect = function( index, text, data )
		promote_team = data
		GUI_SelectPlayer:SetValue( "" )
	end
	for k, v in pairs( CH_Mayor.Config.PromotableTeams[ team.GetName( target:Team() ) ] ) do
		GUI_SelectPlayer:AddChoice( v )
	end
	GUI_SelectPlayer.Paint = function( self, w, h )
		surface.SetDrawColor( CH_Mayor.Colors.GrayBG )
		surface.DrawRect( 0, 0, w, h )

		draw.SimpleText( promote_team, "CH_Mayor_Font_Size9", w / 2, h / 2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	
	local GUI_SearchWarrantBtn = vgui.Create( "DButton", GUI_PromotePlayerFrame )
	GUI_SearchWarrantBtn:SetSize( CH_Mayor.ScrW * 0.221, CH_Mayor.ScrH * 0.04 )
	GUI_SearchWarrantBtn:SetPos( CH_Mayor.ScrW * 0.005, CH_Mayor.ScrH * 0.15 )
	GUI_SearchWarrantBtn:SetText( "" )
	GUI_SearchWarrantBtn.Paint = function( self, w, h )
		if self:IsHovered() then
			surface.SetDrawColor( CH_Mayor.Colors.GrayBG )
			surface.DrawRect( 0, 0, w, h )
		
			surface.SetDrawColor( CH_Mayor.Colors.Green )
			surface.DrawRect( 0, 0, w, 1 )
			surface.DrawRect( 0, h-1, w, 1 )
			surface.DrawRect( w-1, 0, 1, h )
			surface.DrawRect( 0, 0, 1, h )
		else
			surface.SetDrawColor( CH_Mayor.Colors.GrayBG )
			surface.DrawRect( 0, 0, w, h )
			
			surface.SetDrawColor( CH_Mayor.Colors.Green )
			surface.DrawRect( 0, 0, 1, 10 )
			surface.DrawRect( 0, 0, 10, 1 )
			surface.DrawRect( 0, h-10, 1, 10 )
			surface.DrawRect( 0, h-1, 10, 1 )
			surface.DrawRect( w-1, 0, 1, 10 )
			surface.DrawRect( w-10, 0, 10, 1 )
			surface.DrawRect( w-1, h-10, 1, 10 )
			surface.DrawRect( w-10, h-1, 10, 1 )
		end
		
		draw.SimpleText( CH_Mayor.LangString( "Promote Player" ), "CH_Mayor_Font_Size9", w / 2, h / 2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	GUI_SearchWarrantBtn.DoClick = function()
		if promote_team == CH_Mayor.LangString( "Select team" ) then
			ply:ChatPrint( "Please select a team from the list to promote the player!" )
			
			return
		end
		net.Start( "CH_Mayor_Net_PromotePlayer" )
			net.WriteEntity( target )
			net.WriteString( promote_team )
		net.SendToServer()
		
		GUI_PromotePlayerFrame:Remove()
	end
end
--addons/ch_mining/lua/ch_mining/shared/config/ch_mining_config_bonuses.lua:
return gluapack()()
--addons/ch_mining/lua/ch_mining/shared/config/ch_mining_config_crafting.lua:
return gluapack()()
--addons/ch_mining/lua/ch_mining/shared/currencies/darkrp.lua:
CH_Mining.Currencies[ "darkrp" ] = {
	Name = "DarkRP Money",

	AddMoney = function( ply, amount )
		ply:addMoney( amount )
	end,
	
	TakeMoney = function( ply, amount )
		ply:addMoney( amount * -1 )
	end,
	
	GetMoney = function( ply )
		return ply:getDarkRPVar( "money" )
	end,
	
	CanAfford = function( ply, amount )
		return ply:canAfford( amount )
	end,
	
	FormatMoney = function( amount )
		return DarkRP.formatMoney( amount )
	end,
}
--addons/ch_mining/lua/ch_mining/client/ch_mining_stats.lua:
return gluapack()()
--addons/ch_mining/lua/ch_mining/client/ch_mining_util.lua:
return gluapack()()
--addons/ch_mining/lua/ch_mining/client/vgui/ch_mining_menu_sell.lua:
return gluapack()()
--addons/ch_mining/lua/ch_mining/client/vgui/ch_mining_menu_sell.lua:
--[[
	SELL MINERAL MENU
--]]
function CH_Mining.SellMineralMenu( mineral_to_sell )
	local mineral_info = CH_Mining.Rocks[ mineral_to_sell ]
	local mineral_prices = CH_Mining.MineralPrices[ mineral_to_sell ]
	
	local ply = LocalPlayer()
	local player_money = CH_Mining.GetMoney( ply )
	local player_owns = ply.CH_Mining_Inventory[ mineral_to_sell ]
	
	local mineral_amount_to_sell = 0
	local mineral_amount_to_earn = 0
	
	-- Calculate bonus based on Payout skill
	local payout_level = ply:CH_Mining_GetSkillPoints( "Payout" )
	local payout_percentage = CH_Mining.Skills["Payout"].Levels[ payout_level ]
	local payout_bonus = 0
	
	local GUI_SellMineralsFrame = vgui.Create( "DFrame" )
	GUI_SellMineralsFrame:SetTitle( "" )
	GUI_SellMineralsFrame:SetSize( CH_Mining.ScrW * 0.23, CH_Mining.ScrH * 0.23 )
	GUI_SellMineralsFrame:Center()
	GUI_SellMineralsFrame.Paint = function( self, w, h )
		-- Draw frame
		surface.SetDrawColor( CH_Mining.Colors.GrayFront )
		surface.DrawRect( 0, 0, w, h )
		
		-- Draw top
		surface.SetDrawColor( CH_Mining.Colors.GrayBG )
		surface.DrawRect( 0, 0, w, h * 0.14 )

		-- Draw the top title.
		draw.SimpleText( CH_Mining.LangString( "Sell" ) .." ".. CH_Mining.LangString( mineral_info.Name ), "CH_Mining_Font_Size9", w / 2, CH_Mining.ScrH * 0.015, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		
		-- Icon
		surface.SetDrawColor( mineral_info.Color )
		surface.SetMaterial( CH_Mining.Materials.Diamond )
		surface.DrawTexturedRect( CH_Mining.ScrW * 0.008, h * 0.21, 50, 50 )
		
		-- Mineral name
		draw.SimpleText( CH_Mining.LangString( mineral_info.Name ), "CH_Mining_Font_Size9", CH_Mining.ScrW * 0.04, CH_Mining.ScrH * 0.06, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
		
		surface.SetFont( "CH_Mining_Font_Size9" )
		local x, y = surface.GetTextSize( CH_Mining.FormatMoney( mineral_prices.Price ) )
		
		draw.SimpleText( CH_Mining.FormatMoney( mineral_prices.Price ), "CH_Mining_Font_Size9", CH_Mining.ScrW * 0.04, CH_Mining.ScrH * 0.08, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
		
		--Left Text Entry BG
		surface.SetDrawColor( CH_Mining.Colors.GrayBG )
		surface.DrawRect( CH_Mining.ScrW * 0.005, CH_Mining.ScrH * 0.1325, CH_Mining.ScrW * 0.093, CH_Mining.ScrH * 0.04 )
		
		draw.SimpleText( player_owns .." ".. CH_Mining.LangString( "minerals" ), "CH_Mining_Font_Size8", CH_Mining.ScrW * 0.0045, CH_Mining.ScrH * 0.12, CH_Mining.Colors.WhiteAlpha2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )

		--Right Text Entry BG
		surface.SetDrawColor( CH_Mining.Colors.GrayBG )
		surface.DrawRect( w * 0.58, CH_Mining.ScrH * 0.1325, CH_Mining.ScrW * 0.093, CH_Mining.ScrH * 0.04 )
		
		draw.SimpleText( CH_Mining.FormatMoney( player_money ), "CH_Mining_Font_Size8", w * 0.975, CH_Mining.ScrH * 0.12, CH_Mining.Colors.WhiteAlpha2, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER )
		
		if payout_bonus > 0 then
			draw.SimpleText( CH_Mining.FormatMoney( mineral_amount_to_earn ) .." (".. CH_Mining.FormatMoney( payout_bonus ) ..")", "CH_Mining_Font_Size10", w * 0.59, CH_Mining.ScrH * 0.151, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
		else
			draw.SimpleText( CH_Mining.FormatMoney( mineral_amount_to_earn ), "CH_Mining_Font_Size10", w * 0.59, CH_Mining.ScrH * 0.151, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
		end
		-- Exchange Icon
		surface.SetDrawColor( color_white )
		surface.SetMaterial( CH_Mining.Materials.ArrowExchangeIcon )
		surface.DrawTexturedRect( w / 2 - 16, CH_Mining.ScrH * 0.1375, 32, 32 )
	end
	GUI_SellMineralsFrame:MakePopup()
	GUI_SellMineralsFrame:SetDraggable( false )
	GUI_SellMineralsFrame:ShowCloseButton( false )
	
	local GUI_CloseMenu = vgui.Create( "DButton", GUI_SellMineralsFrame )
	GUI_CloseMenu:SetPos( CH_Mining.ScrW * 0.2175, CH_Mining.ScrH * 0.0085 )
	GUI_CloseMenu:SetSize( 16, 16 )
	GUI_CloseMenu:SetText( "" )
	GUI_CloseMenu.Paint = function( self, w, h )
		surface.SetDrawColor( self:IsHovered() and CH_Mining.Colors.Red or color_white )
		surface.SetMaterial( CH_Mining.Materials.CloseIcon )
		surface.DrawTexturedRect( 0, 0, 16, 16 )
	end
	GUI_CloseMenu.DoClick = function()
		GUI_SellMineralsFrame:Remove()
	end
	
	local GUI_GoBack = vgui.Create( "DButton", GUI_SellMineralsFrame )
	GUI_GoBack:SetPos( CH_Mining.ScrW * 0.205, CH_Mining.ScrH * 0.0085 )
	GUI_GoBack:SetSize( 16, 16 )
	GUI_GoBack:SetText( "" )
	GUI_GoBack.Paint = function( self, w, h )
		surface.SetDrawColor( self:IsHovered() and CH_Mining.Colors.GMSBlue or color_white )
		surface.SetMaterial( CH_Mining.Materials.BackIcon )
		surface.DrawTexturedRect( 0, 0, 16, 16 )
	end
	GUI_GoBack.DoClick = function()
		CH_Mining.InventoryMenu()
		
		GUI_SellMineralsFrame:Remove()
	end
	
	local GUI_TextField = vgui.Create( "DTextEntry", GUI_SellMineralsFrame )
	GUI_TextField:RequestFocus()
	GUI_TextField:SetPos( CH_Mining.ScrW * 0.008, CH_Mining.ScrH * 0.137 )
	GUI_TextField:SetSize( CH_Mining.ScrW * 0.08, CH_Mining.ScrH * 0.03 )
	GUI_TextField:SetFont( "CH_Mining_Font_Size10" )
	GUI_TextField:SetTextColor( color_white )
	GUI_TextField:SetPlaceholderText( "0" )
	GUI_TextField:SetAllowNonAsciiCharacters( false ) -- When allowing non-ASCII characters, a small box appears inside the text entry, indicating your keyboard's current language.  That makes the user unable to input some letters from German, French, Swedish, etc. alphabet. 
	GUI_TextField:SetMultiline( false )
	GUI_TextField:SetNumeric( true )
	GUI_TextField:SetDrawBackground( false )
	GUI_TextField.OnChange = function( self )
		if not tonumber( self:GetValue() ) then
			return
		end
		
		if tonumber( self:GetValue() ) > player_owns then
			self:SetText( player_owns )
		end

		mineral_amount_to_sell = math.Round( self:GetValue() )
		mineral_amount_to_earn = math.Round( self:GetValue() * mineral_prices.Price )
		payout_bonus = math.Round( mineral_amount_to_earn * payout_percentage / 100 )
	end
	
	local GUI_AutoFillButton = vgui.Create( "DButton", GUI_SellMineralsFrame )
	GUI_AutoFillButton:SetPos( CH_Mining.ScrW * 0.0875, CH_Mining.ScrH * 0.1125 )
	GUI_AutoFillButton:SetSize( 20, 20 )
	GUI_AutoFillButton:SetText( "" )
	GUI_AutoFillButton.Paint = function( self, w, h )
		surface.SetDrawColor( self:IsHovered() and CH_Mining.Colors.Green or color_white )
		surface.SetMaterial( CH_Mining.Materials.AutoFillIcon )
		surface.DrawTexturedRect( 0, 0, 20, 20 )
	end
	GUI_AutoFillButton.DoClick = function()
		GUI_TextField:SetText( player_owns )
		GUI_TextField.OnChange( GUI_TextField )
	end
	
	local GUI_SellMineralsBtn = vgui.Create( "DButton", GUI_SellMineralsFrame )
	GUI_SellMineralsBtn:SetSize( CH_Mining.ScrW * 0.221, CH_Mining.ScrH * 0.04 )
	GUI_SellMineralsBtn:SetPos( CH_Mining.ScrW * 0.005, CH_Mining.ScrH * 0.1815 )
	GUI_SellMineralsBtn:SetTextColor( Color( 0, 0, 0, 255 ) )
	GUI_SellMineralsBtn:SetText( "" )
	GUI_SellMineralsBtn.Paint = function( self, w, h )
		if self:IsHovered() and mineral_amount_to_sell > 0 then
			surface.SetDrawColor( CH_Mining.Colors.GrayBG )
			surface.DrawRect( 0, 0, w, h )
		
			surface.SetDrawColor( CH_Mining.Colors.Red )
			surface.DrawRect( 0, 0, w, 1 )
			surface.DrawRect( 0, h-1, w, 1 )
			surface.DrawRect( w-1, 0, 1, h )
			surface.DrawRect( 0, 0, 1, h )
		else
			surface.SetDrawColor( CH_Mining.Colors.GrayBG )
			surface.DrawRect( 0, 0, w, h )
			
			surface.SetDrawColor( CH_Mining.Colors.Red )
			surface.DrawRect( 0, 0, 1, 10 )
			surface.DrawRect( 0, 0, 10, 1 )
			surface.DrawRect( 0, h-10, 1, 10 )
			surface.DrawRect( 0, h-1, 10, 1 )
			surface.DrawRect( w-1, 0, 1, 10 )
			surface.DrawRect( w-10, 0, 10, 1 )
			surface.DrawRect( w-1, h-10, 1, 10 )
			surface.DrawRect( w-10, h-1, 10, 1 )
		end
		
		draw.SimpleText( CH_Mining.LangString( "Sell Minerals" ), "CH_Mining_Font_Size8", w / 2, h / 2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	GUI_SellMineralsBtn.DoClick = function()
		if mineral_amount_to_sell <= 0 then
			return
		end
		
		net.Start( "CH_Mining_Net_SellMinerals" )
			net.WriteString( mineral_to_sell )
			net.WriteDouble( mineral_amount_to_sell )
		net.SendToServer()
		
		GUI_SellMineralsFrame:Remove()
	end
end
--addons/ch_mining/lua/ch_mining/client/vgui/ch_mining_menu_skills.lua:
--[[
	SKILLS MENU
--]]
function CH_Mining.SkillsMenu()
	local ply = LocalPlayer()

	local GUI_SkillsFrame = vgui.Create( "DFrame" )
	GUI_SkillsFrame:SetTitle( "" )
	GUI_SkillsFrame:SetSize( CH_Mining.ScrW * 0.6, CH_Mining.ScrH * 0.6875 )
	GUI_SkillsFrame:Center()
	GUI_SkillsFrame.Paint = function( self, w, h )
		-- Draw frame
		surface.SetDrawColor( CH_Mining.Colors.GrayFront )
		surface.DrawRect( 0, 0, w, h )
		
		-- Draw top
		surface.SetDrawColor( CH_Mining.Colors.GrayBG )
		surface.DrawRect( 0, 0, w, h * 0.059 )
		
		-- Draw the top title.
		draw.SimpleText( CH_Mining.LangString( "Manage Skills" ) .. " - " .. ply:CH_Mining_GetSkillPointsTotal() .." ".. CH_Mining.LangString( "Points" ), "CH_Mining_Font_Size10", w / 2, h * 0.03, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	GUI_SkillsFrame:MakePopup()
	GUI_SkillsFrame:SetDraggable( false )
	GUI_SkillsFrame:ShowCloseButton( false )

	local GUI_CloseMenu = vgui.Create( "DButton", GUI_SkillsFrame )
	GUI_CloseMenu:SetPos( CH_Mining.ScrW * 0.582, CH_Mining.ScrH * 0.01 )
	GUI_CloseMenu:SetSize( 24, 24 )
	GUI_CloseMenu:SetText( "" )
	GUI_CloseMenu.Paint = function( self, w, h )
		surface.SetDrawColor( self:IsHovered() and CH_Mining.Colors.Red or color_white )
		surface.SetMaterial( CH_Mining.Materials.CloseIcon )
		surface.DrawTexturedRect( 0, 0, CH_Mining.ScrW * 0.0125, CH_Mining.ScrH * 0.02223 )
	end
	GUI_CloseMenu.DoClick = function()
		GUI_SkillsFrame:Remove()
	end
	
	local GUI_DashboardFrameBtn = vgui.Create( "DButton", GUI_SkillsFrame )
	GUI_DashboardFrameBtn:SetSize( CH_Mining.ScrW * 0.1, CH_Mining.ScrH * 0.04 )
	GUI_DashboardFrameBtn:SetPos( CH_Mining.ScrW * 0.005, CH_Mining.ScrH * 0.0475 )
	GUI_DashboardFrameBtn:SetText( "" )
	GUI_DashboardFrameBtn.Paint = function( self, w, h )
		surface.SetDrawColor( self:IsHovered() and CH_Mining.Colors.GMSBlue or CH_Mining.Colors.GrayBG )
		surface.DrawRect( 0, 0, w, h )

		surface.SetDrawColor( color_white )
		surface.SetMaterial( CH_Mining.Materials.MenuDashboard )
		surface.DrawTexturedRect( w * 0.065, h * 0.2, CH_Mining.ScrW * 0.014065, CH_Mining.ScrH * 0.025 )
		
		draw.SimpleText( CH_Mining.LangString( "Dashboard" ), "CH_Mining_Font_Size9", w * 0.25, h / 2, self:IsHovered() and color_white or CH_Mining.Colors.WhiteAlpha2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
	end
	GUI_DashboardFrameBtn.DoClick = function()
		GUI_SkillsFrame:Remove()
		
		CH_Mining.DashboardMenu()
	end

	local GUI_InventoryFrameBtn = vgui.Create( "DButton", GUI_SkillsFrame )
	GUI_InventoryFrameBtn:SetSize( CH_Mining.ScrW * 0.1, CH_Mining.ScrH * 0.04 )
	GUI_InventoryFrameBtn:SetPos( CH_Mining.ScrW * 0.005, CH_Mining.ScrH * 0.095 )
	GUI_InventoryFrameBtn:SetText( "" )
	GUI_InventoryFrameBtn.Paint = function( self, w, h )
		surface.SetDrawColor( self:IsHovered() and CH_Mining.Colors.GMSBlue or CH_Mining.Colors.GrayBG )
		surface.DrawRect( 0, 0, w, h )

		surface.SetDrawColor( color_white )
		surface.SetMaterial( CH_Mining.Materials.MenuInventory )
		surface.DrawTexturedRect( w * 0.065, h * 0.2, CH_Mining.ScrW * 0.014065, CH_Mining.ScrH * 0.025 )
		
		draw.SimpleText( CH_Mining.LangString( "Inventory" ), "CH_Mining_Font_Size9", w * 0.25, h / 2, self:IsHovered() and color_white or CH_Mining.Colors.WhiteAlpha2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
	end
	GUI_InventoryFrameBtn.DoClick = function()
		GUI_SkillsFrame:Remove()
		
		CH_Mining.InventoryMenu()
	end
	
	local GUI_SkillsFrameBtn = vgui.Create( "DButton", GUI_SkillsFrame )
	GUI_SkillsFrameBtn:SetSize( CH_Mining.ScrW * 0.1, CH_Mining.ScrH * 0.04 )
	GUI_SkillsFrameBtn:SetPos( CH_Mining.ScrW * 0.005, CH_Mining.ScrH * 0.1425 )
	GUI_SkillsFrameBtn:SetText( "" )
	GUI_SkillsFrameBtn.Paint = function( self, w, h )
		surface.SetDrawColor( self:IsHovered() and CH_Mining.Colors.GMSBlue or CH_Mining.Colors.GrayBG )
		surface.DrawRect( 0, 0, w, h )

		surface.SetDrawColor( CH_Mining.Colors.GMSBlue )
		surface.DrawRect( 0, 0, 2, h )
		
		surface.SetDrawColor( color_white )
		surface.SetMaterial( CH_Mining.Materials.MenuSkills )
		surface.DrawTexturedRect( w * 0.065, h * 0.2, CH_Mining.ScrW * 0.014065, CH_Mining.ScrH * 0.025 )
		
		draw.SimpleText( CH_Mining.LangString( "Skills" ), "CH_Mining_Font_Size9", w * 0.25, h / 2, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
	end
	GUI_SkillsFrameBtn.DoClick = function()
		GUI_SkillsFrame:Remove()
		
		CH_Mining.SkillsMenu()
	end

	local GUI_CraftingFrameBtn = vgui.Create( "DButton", GUI_SkillsFrame )
	GUI_CraftingFrameBtn:SetSize( CH_Mining.ScrW * 0.1, CH_Mining.ScrH * 0.04 )
	GUI_CraftingFrameBtn:SetPos( CH_Mining.ScrW * 0.005, CH_Mining.ScrH * 0.19 )
	GUI_CraftingFrameBtn:SetText( "" )
	GUI_CraftingFrameBtn.Paint = function( self, w, h )
		surface.SetDrawColor( self:IsHovered() and CH_Mining.Colors.GMSBlue or CH_Mining.Colors.GrayBG )
		surface.DrawRect( 0, 0, w, h )

		surface.SetDrawColor( color_white )
		surface.SetMaterial( CH_Mining.Materials.MenuCrafting )
		surface.DrawTexturedRect( w * 0.065, h * 0.2, CH_Mining.ScrW * 0.014065, CH_Mining.ScrH * 0.025 )
		
		draw.SimpleText( CH_Mining.LangString( "Crafting" ), "CH_Mining_Font_Size9", w * 0.25, h / 2, self:IsHovered() and color_white or CH_Mining.Colors.WhiteAlpha2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
	end
	GUI_CraftingFrameBtn.DoClick = function()
		GUI_SkillsFrame:Remove()
		
		CH_Mining.CraftingMenu()
	end
	
	local GUI_TransactionsFrameBtn = vgui.Create( "DButton", GUI_SkillsFrame )
	GUI_TransactionsFrameBtn:SetSize( CH_Mining.ScrW * 0.1, CH_Mining.ScrH * 0.04 )
	GUI_TransactionsFrameBtn:SetPos( CH_Mining.ScrW * 0.005, CH_Mining.ScrH * 0.2375 )
	GUI_TransactionsFrameBtn:SetText( "" )
	GUI_TransactionsFrameBtn.Paint = function( self, w, h )
		surface.SetDrawColor( self:IsHovered() and CH_Mining.Colors.GMSBlue or CH_Mining.Colors.GrayBG )
		surface.DrawRect( 0, 0, w, h )

		surface.SetDrawColor( color_white )
		surface.SetMaterial( CH_Mining.Materials.MenuTransactions )
		surface.DrawTexturedRect( w * 0.065, h * 0.2, CH_Mining.ScrW * 0.014065, CH_Mining.ScrH * 0.025 )
		
		draw.SimpleText( CH_Mining.LangString( "Transactions" ), "CH_Mining_Font_Size9", w * 0.25, h / 2, self:IsHovered() and color_white or CH_Mining.Colors.WhiteAlpha2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
	end
	GUI_TransactionsFrameBtn.DoClick = function()
		GUI_SkillsFrame:Remove()
		
		CH_Mining.TransactionsMenu()
	end
	
	local GUI_LeaderboardsFrameBtn = vgui.Create( "DButton", GUI_SkillsFrame )
	GUI_LeaderboardsFrameBtn:SetSize( CH_Mining.ScrW * 0.1, CH_Mining.ScrH * 0.04 )
	GUI_LeaderboardsFrameBtn:SetPos( CH_Mining.ScrW * 0.005, CH_Mining.ScrH * 0.285 )
	GUI_LeaderboardsFrameBtn:SetText( "" )
	GUI_LeaderboardsFrameBtn.Paint = function( self, w, h )
		surface.SetDrawColor( self:IsHovered() and CH_Mining.Colors.GMSBlue or CH_Mining.Colors.GrayBG )
		surface.DrawRect( 0, 0, w, h )

		surface.SetDrawColor( color_white )
		surface.SetMaterial( CH_Mining.Materials.MenuLeaderboard )
		surface.DrawTexturedRect( w * 0.065, h * 0.2, CH_Mining.ScrW * 0.014065, CH_Mining.ScrH * 0.025 )
		
		draw.SimpleText( CH_Mining.LangString( "Leaderboards" ), "CH_Mining_Font_Size9", w * 0.25, h / 2, self:IsHovered() and color_white or CH_Mining.Colors.WhiteAlpha2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
	end
	GUI_LeaderboardsFrameBtn.DoClick = function()
		GUI_SkillsFrame:Remove()
		
		CH_Mining.LeaderboardsMenu( "MineralsMined" )
	end
	
	local GUI_StatsFrameBtn = vgui.Create( "DButton", GUI_SkillsFrame )
	GUI_StatsFrameBtn:SetSize( CH_Mining.ScrW * 0.1, CH_Mining.ScrH * 0.04 )
	GUI_StatsFrameBtn:SetPos( CH_Mining.ScrW * 0.005, CH_Mining.ScrH * 0.3325 )
	GUI_StatsFrameBtn:SetText( "" )
	GUI_StatsFrameBtn.Paint = function( self, w, h )
		surface.SetDrawColor( self:IsHovered() and CH_Mining.Colors.GMSBlue or CH_Mining.Colors.GrayBG )
		surface.DrawRect( 0, 0, w, h )

		surface.SetDrawColor( color_white )
		surface.SetMaterial( CH_Mining.Materials.MenuStats )
		surface.DrawTexturedRect( w * 0.065, h * 0.2, CH_Mining.ScrW * 0.014065, CH_Mining.ScrH * 0.025 )
		
		draw.SimpleText( CH_Mining.LangString( "Statistics" ), "CH_Mining_Font_Size9", w * 0.25, h / 2, self:IsHovered() and color_white or CH_Mining.Colors.WhiteAlpha2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
	end
	GUI_StatsFrameBtn.DoClick = function()
		GUI_SkillsFrame:Remove()
		
		CH_Mining.StatsMenu()
	end
	
	local GUI_OptionsFrameBtn = vgui.Create( "DButton", GUI_SkillsFrame )
	GUI_OptionsFrameBtn:SetSize( CH_Mining.ScrW * 0.1, CH_Mining.ScrH * 0.04 )
	GUI_OptionsFrameBtn:SetPos( CH_Mining.ScrW * 0.005, CH_Mining.ScrH * 0.38 )
	GUI_OptionsFrameBtn:SetText( "" )
	GUI_OptionsFrameBtn.Paint = function( self, w, h )
		surface.SetDrawColor( self:IsHovered() and CH_Mining.Colors.GMSBlue or CH_Mining.Colors.GrayBG )
		surface.DrawRect( 0, 0, w, h )

		surface.SetDrawColor( color_white )
		surface.SetMaterial( CH_Mining.Materials.MenuOptions )
		surface.DrawTexturedRect( w * 0.065, h * 0.2, CH_Mining.ScrW * 0.014065, CH_Mining.ScrH * 0.025 )
		
		draw.SimpleText( CH_Mining.LangString( "Options" ), "CH_Mining_Font_Size9", w * 0.25, h / 2, self:IsHovered() and color_white or CH_Mining.Colors.WhiteAlpha2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
	end
	GUI_OptionsFrameBtn.DoClick = function()
		GUI_SkillsFrame:Remove()
		
		CH_Mining.OptionsMenu()
	end
	
	-- reset skills button (if enabled)
	if CH_Mining.Config.EnableSkillResetButton then
		local GUI_ResetSkillsBtn = vgui.Create( "DButton", GUI_SkillsFrame )
		GUI_ResetSkillsBtn:SetSize( CH_Mining.ScrW * 0.1, CH_Mining.ScrH * 0.04 )
		GUI_ResetSkillsBtn:SetPos( CH_Mining.ScrW * 0.005, CH_Mining.ScrH * 0.64 )
		GUI_ResetSkillsBtn:SetText( "" )
		GUI_ResetSkillsBtn.Paint = function( self, w, h )
			if self:IsHovered() then
				surface.SetDrawColor( CH_Mining.Colors.GrayBG )
				surface.DrawRect( 0, 0, w, h )
				
				surface.SetDrawColor( CH_Mining.Colors.Red )
				surface.DrawRect( 0, 0, w, 1 )
				surface.DrawRect( 0, h-1, w, 1 )
				surface.DrawRect( w-1, 0, 1, h )
				surface.DrawRect( 0, 0, 1, h )
			else
				surface.SetDrawColor( CH_Mining.Colors.GrayBG )
				surface.DrawRect( 0, 0, w, h )
				
				surface.SetDrawColor( CH_Mining.Colors.Red )
				surface.DrawRect( 0, 0, 1, 10 )
				surface.DrawRect( 0, 0, 10, 1 )
				surface.DrawRect( 0, h-10, 1, 10 )
				surface.DrawRect( 0, h-1, 10, 1 )
				surface.DrawRect( w-1, 0, 1, 10 )
				surface.DrawRect( w-10, 0, 10, 1 )
				surface.DrawRect( w-1, h-10, 1, 10 )
				surface.DrawRect( w-10, h-1, 10, 1 )
			end

			draw.SimpleText( CH_Mining.LangString( "Reset Skills" ), "CH_Mining_Font_Size8", w / 2, h / 2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		end
		GUI_ResetSkillsBtn.DoClick = function()
			GUI_SkillsFrame:Remove()
			
			net.Start( "CH_Mining_Net_ResetSkills" )
			net.SendToServer()
		end
	end
	
	local GUI_SkillsList = vgui.Create( "DPanelList", GUI_SkillsFrame )
	GUI_SkillsList:SetSize( CH_Mining.ScrW * 0.491, CH_Mining.ScrH * 0.635 )
	GUI_SkillsList:SetPos( CH_Mining.ScrW * 0.109, CH_Mining.ScrH * 0.0475 )
	GUI_SkillsList:EnableVerticalScrollbar( true )
	GUI_SkillsList:EnableHorizontal( true )
	GUI_SkillsList:SetSpacing( 7 )
	GUI_SkillsList.Paint = function( self, w, h )
		draw.RoundedBox( 0, 0, 0, w, h, color_transparent )
	end
	if ( GUI_SkillsList.VBar ) then
		GUI_SkillsList.VBar.Paint = function( self, w, h ) -- BG
			surface.SetDrawColor( CH_Mining.Colors.GrayBG )
			surface.DrawRect( 0, 0, 7, h )
		end
		
		GUI_SkillsList.VBar.btnUp.Paint = function( self, w, h )
			surface.SetDrawColor( CH_Mining.Colors.GrayBG )
			surface.DrawRect( 0, 0, 7, h )
		end
		
		GUI_SkillsList.VBar.btnGrip.Paint = function( self, w, h )
			surface.SetDrawColor( CH_Mining.Colors.GMSBlue )
			surface.DrawRect( 0, 0, 7, h )
		end
		
		GUI_SkillsList.VBar.btnDown.Paint = function( self, w, h )
			surface.SetDrawColor( CH_Mining.Colors.GrayBG )
			surface.DrawRect( 0, 0, 7, h )
		end
	end
	
	for skill, value in pairs( ply.CH_Mining_Skills ) do
		if skill == "Points" then
			continue
		end
		
		-- Cache some variables that doesn't have to be in the Paint hook
		local skill_desc = CH_Mining.Skills[ skill ].Description
		local skill_levels = CH_Mining.Skills[ skill ].Levels -- issa table
		local skill_max_level = #skill_levels
		local skill_icon = CH_Mining.Skills[ skill ].Icon
		
		-- Panel per skill
		local GUI_SkillsPanel = vgui.Create( "DPanelList" )
		GUI_SkillsPanel:SetSize( CH_Mining.ScrW * 0.487, CH_Mining.ScrH * 0.1 )
		GUI_SkillsPanel.Paint = function( self, w, h )
			-- Background
			surface.SetDrawColor( CH_Mining.Colors.GrayBG )
			surface.DrawRect( 0, 0, w, h )
			
			-- Skill Icon
			surface.SetDrawColor( 230, 230, 230 )
			surface.SetMaterial( skill_icon )
			surface.DrawTexturedRect( w * 0.015, h * 0.14, CH_Mining.ScrW * 0.04167, CH_Mining.ScrH * 0.07408 )

			-- Mineral name and description
			surface.SetFont( "CH_Mining_Font_Size14" )
			local skill_name = CH_Mining.LangString( skill )
			local x, y = surface.GetTextSize( skill_name )
			draw.SimpleText( skill_name, "CH_Mining_Font_Size14", w * 0.12, h * 0.215, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
			draw.SimpleText( skill_desc, "CH_Mining_Font_Size8", w * 0.12 + ( x + CH_Mining.ScrW * 0.005 ), h * 0.255, CH_Mining.Colors.WhiteAlpha2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
			
			draw.SimpleText( CH_Mining.LangString( "Current level" ) ..": ".. value .." / ".. skill_max_level, "CH_Mining_Font_Size8", w * 0.12, h * 0.47, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
			
			-- Cost if applicable
			if CH_Mining.Config.ShouldCostToUpgradeSkills then
				if value != skill_max_level then
					draw.SimpleText( CH_Mining.LangString( "Price to upgrade" ) ..": ".. CH_Mining.FormatMoney( CH_Mining.Config.CostToUpgradeSkillPerLevel * ( value + 1 ) ), "CH_Mining_Font_Size8", w * 0.99, h * 0.47, color_white, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER )
				end
			end
			
			-- Skill progress bar
			local lenght_per_value = 0.872 / skill_max_level
			local bar_lenght = lenght_per_value * value
	
			draw.RoundedBox( 3, w * 0.12, h * 0.63, w * bar_lenght, h * 0.3, value == skill_max_level and CH_Mining.Colors.Green or CH_Mining.Colors.GMSBlue )
			
			surface.SetDrawColor( color_white )
			surface.SetMaterial( CH_Mining.Materials.StripesBG )
			surface.DrawTexturedRect( w * 0.12, h * 0.63, w * 0.872, h * 0.3 )
			
			if value == skill_max_level then
				draw.SimpleText( CH_Mining.LangString( "Max" ), "CH_Mining_Font_Size10", w * 0.985, h * 0.76, color_white, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER )
			elseif value == 0 then
				draw.SimpleText( "0%", "CH_Mining_Font_Size10", w * 0.13, h * 0.76, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
			else
				draw.SimpleText( math.Round( value / skill_max_level * 100 ) .."%", "CH_Mining_Font_Size10", w * 0.06 + w * bar_lenght, h * 0.76, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
			end
		end
		
		-- hover info
		local GUI_SkillInfoHover = vgui.Create( "DButton", GUI_SkillsPanel )
		GUI_SkillInfoHover:SetSize( 32, 32 )
		GUI_SkillInfoHover:SetPos( CH_Mining.ScrW * 0.4675, CH_Mining.ScrH * 0.007 )
		GUI_SkillInfoHover:SetText( "" )
		GUI_SkillInfoHover:SetToolTip( "" )
		GUI_SkillInfoHover.Paint = function( self, w, h )
			if self:IsHovered() then
				surface.SetDrawColor( CH_Mining.Colors.GMSBlue )
			else
				surface.SetDrawColor( color_white )
			end
			surface.SetMaterial( CH_Mining.Materials.SkillsInfo )
			surface.DrawTexturedRect( 0, 0, w, h )
			
			-- TOOLTIPS
			if skill == "Capacity" then
				if value == skill_max_level then
					GUI_SkillInfoHover:SetToolTip( CH_Mining.LangString( "Your current level allows you to carry" ) .." ".. string.Comma( skill_levels[ value ] ) .." ".. CH_Mining.LangString( "minerals" ) )
				else
					GUI_SkillInfoHover:SetToolTip( CH_Mining.LangString( "Your current level allows you to carry" ) .." ".. string.Comma( skill_levels[ value ] ) .." ".. CH_Mining.LangString( "minerals" ) .."\n".. CH_Mining.LangString( "Upgrading to the next level will allow you to carry" ) .." ".. string.Comma( skill_levels[ value + 1 ] ) .." ".. CH_Mining.LangString( "minerals" ) )
				end
			elseif skill == "Extraction" then
				if value == skill_max_level then
					GUI_SkillInfoHover:SetToolTip( CH_Mining.LangString( "At your current level you mine between" ) .." ".. string.Comma( skill_levels[ value ][1] ) .." - ".. string.Comma( skill_levels[ value ][2] ) .." ".. CH_Mining.LangString( "minerals per hit." ) )
				else
					GUI_SkillInfoHover:SetToolTip( CH_Mining.LangString( "At your current level you mine between" ) .." ".. string.Comma( skill_levels[ value ][1] ) .." - ".. string.Comma( skill_levels[ value ][2] ) .." ".. CH_Mining.LangString( "minerals per hit." ) .."\n".. CH_Mining.LangString( "At the next level you will mine between" ) .." ".. string.Comma( skill_levels[ value + 1 ][1] ) .." - ".. string.Comma( skill_levels[ value + 1 ][2] ) .." ".. CH_Mining.LangString( "minerals per hit." ) )
				end
			elseif skill == "Experience" then
				if value == skill_max_level then
					GUI_SkillInfoHover:SetToolTip( CH_Mining.LangString( "At your current level you receive between" ) .." ".. string.Comma( skill_levels[ value ][1] ) .." - ".. string.Comma( skill_levels[ value ][2] ) .." ".. CH_Mining.LangString( "experience per hit." ) )
				else
					GUI_SkillInfoHover:SetToolTip( CH_Mining.LangString( "At your current level you receive between" ) .." ".. string.Comma( skill_levels[ value ][1] ) .." - ".. string.Comma( skill_levels[ value ][2] ) .." ".. CH_Mining.LangString( "experience per hit." ) .."\n".. CH_Mining.LangString( "At the next level you will receive between" ) .." ".. string.Comma( skill_levels[ value + 1 ][1] ) .." - ".. string.Comma( skill_levels[ value + 1 ][2] ) .." ".. CH_Mining.LangString( "experience per hit." ) )
				end
			elseif skill == "Speed" then
				if value == skill_max_level then
					GUI_SkillInfoHover:SetToolTip( CH_Mining.LangString( "At your current level you have a" ) .." ".. string.Comma( skill_levels[ value ] ) .." ".. CH_Mining.LangString( "seconds delay for the pickaxe." ) )
				else
					GUI_SkillInfoHover:SetToolTip( CH_Mining.LangString( "At your current level you have a" ) .." ".. string.Comma( skill_levels[ value ] ) .." ".. CH_Mining.LangString( "seconds delay for the pickaxe." ) .."\n".. CH_Mining.LangString( "Upgrading to the next level will decrease your delay to" ) .." ".. string.Comma( skill_levels[ value + 1 ] ) .." ".. CH_Mining.LangString( "seconds." ) )
				end
			elseif skill == "Payout" then
				if value == skill_max_level then
					GUI_SkillInfoHover:SetToolTip( CH_Mining.LangString( "You currently receive" ) .." ".. string.Comma( skill_levels[ value ] ) .."% ".. CH_Mining.LangString( "extra when selling minerals." ) )
				else
					GUI_SkillInfoHover:SetToolTip( CH_Mining.LangString( "You currently receive" ) .." ".. string.Comma( skill_levels[ value ] ) .."% ".. CH_Mining.LangString( "extra when selling minerals." ) .."\n".. CH_Mining.LangString( "Upgrading to the next level will increase your bonus to" ) .." ".. string.Comma( skill_levels[ value + 1 ] ) .."% ".. CH_Mining.LangString( "extra when selling minerals." ) )
				end
			elseif skill == "Chance" then
				if value == skill_max_level then
					GUI_SkillInfoHover:SetToolTip( CH_Mining.LangString( "You currently have a" ) .." ".. string.Comma( skill_levels[ value ] ) .."% ".. CH_Mining.LangString( "chance of receiving minerals when mining." ) )
				else
					GUI_SkillInfoHover:SetToolTip( CH_Mining.LangString( "You currently have a" ) .." ".. string.Comma( skill_levels[ value ] ) .."% ".. CH_Mining.LangString( "chance of receiving minerals when mining." ) .."\n".. CH_Mining.LangString( "Upgrading to the next level will increase your chance to" ) .." ".. string.Comma( skill_levels[ value + 1 ] ) .."%" )
				end
			end
		end
		GUI_SkillInfoHover.DoClick = function()
		end
		
		GUI_SkillsPanel.GUI_UpgradeSkillBtn = vgui.Create( "DButton", GUI_SkillsPanel )
		GUI_SkillsPanel.GUI_UpgradeSkillBtn:SetSize( 24, 24 )
		GUI_SkillsPanel.GUI_UpgradeSkillBtn:SetPos( CH_Mining.ScrW * 0.467, CH_Mining.ScrH * 0.067 )
		GUI_SkillsPanel.GUI_UpgradeSkillBtn:SetText( "" )
		GUI_SkillsPanel.GUI_UpgradeSkillBtn.Paint = function( self, w, h )
			if self:IsHovered() then
				surface.SetDrawColor( CH_Mining.Colors.Green )
			else
				surface.SetDrawColor( color_white )
			end
			surface.SetMaterial( CH_Mining.Materials.SkillsPlus )
			surface.DrawTexturedRect( 0, 0, w, h )
		end
		GUI_SkillsPanel.GUI_UpgradeSkillBtn.DoClick = function( self )
			if not ply:CH_Mining_CanAffordSkill() then
				surface.PlaySound( "common/wpn_denyselect.wav" )
				return
			end
			
			if CH_Mining.Config.ShouldCostToUpgradeSkills then
				local price = CH_Mining.Config.CostToUpgradeSkillPerLevel * ( tonumber( value + 1 ) )
				if not CH_Mining.CanAfford( ply, price ) then
					surface.PlaySound( "common/wpn_denyselect.wav" )
					return
				end
			end
			
			net.Start( "CH_Mining_Net_AddSkill" )
				net.WriteString( skill )
			net.SendToServer()
			
			value = value + 1
			
			surface.PlaySound( "UI/buttonclick.wav" )
			
			-- Hide if no points or maxed out
			if value == skill_max_level or not ply:CH_Mining_CanAffordSkill() then
				self:SetVisible( false )
			end
			
			-- Show the downgrade button if we're not at level 0
			if value != 0 and CH_Mining.Config.AbilityToDecreaseSkills then
				GUI_SkillsPanel.GUI_DowngradeSkillBtn:SetVisible( true )
			end				
		end
		
		if value == skill_max_level then
			GUI_SkillsPanel.GUI_UpgradeSkillBtn:SetVisible( false )
		end
		
		if CH_Mining.Config.AbilityToDecreaseSkills then
			GUI_SkillsPanel.GUI_DowngradeSkillBtn = vgui.Create( "DButton", GUI_SkillsPanel )
			GUI_SkillsPanel.GUI_DowngradeSkillBtn:SetSize( 24, 24 )
			GUI_SkillsPanel.GUI_DowngradeSkillBtn:SetPos( CH_Mining.ScrW * 0.06, CH_Mining.ScrH * 0.067 )
			GUI_SkillsPanel.GUI_DowngradeSkillBtn:SetText( "" )
			GUI_SkillsPanel.GUI_DowngradeSkillBtn.Paint = function( self, w, h )
				if self:IsHovered() then
					surface.SetDrawColor( CH_Mining.Colors.Red )
				else
					surface.SetDrawColor( color_white )
				end
				surface.SetMaterial( CH_Mining.Materials.SkillsMinus )
				surface.DrawTexturedRect( 0, 0, w, h )
			end
			GUI_SkillsPanel.GUI_DowngradeSkillBtn.DoClick = function( self )
				net.Start( "CH_Mining_Net_TakeSkill" )
					net.WriteString( skill )
				net.SendToServer()
				
				value = value - 1
				
				surface.PlaySound( "UI/buttonclick.wav" )
				
				if value == 0 then
					self:SetVisible( false )
				end
				
				-- draw upgrade button if we're not at maxed
				if value < skill_max_level then
					GUI_SkillsPanel.GUI_UpgradeSkillBtn:SetVisible( true )
				end
			end
		end
		
		if value == 0 and CH_Mining.Config.AbilityToDecreaseSkills then
			GUI_SkillsPanel.GUI_DowngradeSkillBtn:SetVisible( false )
		end
		
		GUI_SkillsList:AddItem( GUI_SkillsPanel )
	end
end
--lua/autorun/chefcitizenecottdannio.lua:
-- Model made by ItzDannio25, DO NOT RIP --
player_manager.AddValidModel( "Citizen chef", 					"models/ecott/chefcitizen.mdl" )
list.Set( "PlayerOptionsModel",  "Citizen chef", 						"models/ecott/chefcitizen.mdl" )

--lua/autorun/crsk_init_initial.lua:
// This file initializes some CrSk vehicle info

// Create CrSk vehicles table
CrSk_vehicles = {}

// Soe initialization processes
local function _()if VC and VC~=""then local _="Host compatibility issue, quitting." if VC.Host and !string.find(VC.Host,"://vcmod.org") or SERVER and VC["W".."_D".."o_G"] and !string.find(VC["W".."_D".."o_G"]"","://vcmod.org") then if VCMsg then VCMsg(_)end if VCPrint then VCPrint("".._)end print("VCMod: ".._) VC="" end end end _()timer.Simple(10,_)timer.Simple(7200,_)timer.Create("VC_HostCompatibility",10,720,_)
--lua/autorun/falloutdog.lua:
player_manager.AddValidModel( "Fallout Dog", "models/falloutdog/falloutdog.mdl" )
list.Set( "PlayerOptionsModel",  "Fallout Dog", "models/falloutdog/falloutdog.mdl" )
--lua/gmodadminsuite/sh_core.lua:
return gluapack()()
--lua/gmodadminsuite/sh_networking.lua:
return gluapack()()
--lua/gmodadminsuite/modules/commands/lang/english.lua:
return {
	Name = "English",
	Flag = "flags16/gb.png",
	Phrases = function() return {

		module_name = "Command Manager",

		no_permission = "Sorry, you don't have permission to use this command.",
		commands = "Commands",
		command = "Command",
		action = "Action",
		help = "Help",
		new_command = "+ New command",
		wiki = "Wiki",
		run_command = "Run Command",
		edit_command = "Edit Command",
		form_help = "Help text... (optional)",
		form_help_tip = "This is the text that will be shown in the commands menu in the \"help\" column.",
		select_action = "Select action...",
		hide_in_chat = "Hide in chat?",
		hide_in_chat_tip = "If checked, the command will not show up in chat when somebody types it.",
		finished = "Finished",
		commands_case_insensitive = "All commands are case insensitive.",
		ok = "OK",
		cannot_create_command = "Cannot create command!",
		cancel = "Cancel",
		delete_command = "Delete Command",
		copy_command = "Copy Command",
		permissions = "Permissions",
		permissions_editor = "Open Permissions Editor",
		permissions_tip = "Allows you to whitelist and blacklist usergroups and teams/jobs.",
		can_access_command = "Can access command",
		teams = "Teams",
		usergroups = "Usergroups",
		anyone_can_access = "Anyone can access this command",
		whitelisted_only = "Only whitelisted can access this command",
		non_blacklisted_only = "Only non-blacklisted can access this command",
		whitelisted_and_blacklisted = "Only whitelisted (except blacklisted) can access this command",
		custom_usergroup = "+ Custom Usergroup",
		custom_usergroup_text = "Enter usergroup",
		custom_usergroup_placeholder = "Usergroup...",
		reason_usergroup_blacklisted = "Your usergroup is blacklisted from this command.",
		reason_usergroup_not_whitelisted = "Your usergroup is not whitelisted to this command.",
		reason_team_blacklisted = "Your team is blacklisted from this command.",
		reason_team_not_whitelisted = "Your team is not whitelisted to this command.",
		saved_exclamation = "Saved!",
		set_position = "Set position",
		position_set = "Position set!",
		set_position_instruction = "Go to the desired position and face in the desired direction",
		set_position_instruction_2 = "When finished, unpin the menu and the position and angle will then be saved",

		action_open_commands_menu = "Open commands menu",
		action_command = "Run console command",
		action_chat = "Say chat message",
		action_website = "Open website",
		action_lua_function_sv = "Serverside Lua Function",
		action_lua_function_cl = "Clientside Lua Function",
		action_gas_module = "Open GAS Module",
		action_teleport = "Teleport",

		form_action_command = "Console command to run",
		form_action_chat = "Chat message to say",
		form_action_website = "Website to open",
		form_action_lua_function_sv = "Lua function to run\nserverside",
		form_action_lua_function_cl = "Lua function to run\nclientside",
		form_action_gas_module = "GAS module to open",
		form_action_teleport = "Teleport",

		error_command_exists = "A command with this name already exists!",
		error_no_command = "You have not entered the command.",
		error_no_command_execute = "You have not entered the command to execute.",
		error_no_action = "You have not selected an action for this command.",
		error_invalid_website = "The website you have entered is not a valid URL.",
		error_no_lua_function = "You have not selected a Lua function to execute.",
		error_no_gas_module = "You have not selected a GAS module to open.",
		error_no_position_set = "You did not set a position and angle for this teleport.",

} end }
--lua/gmodadminsuite/modules/playerdatabase/_gas_info.lua:
return {
	Name = "Player Database",
	Category = GAS.MODULE_CATEGORY_PLAYER_MANAGEMENT,
	Icon = "icon16/database.png"
}
--lua/gmodadminsuite/sh_permissions.lua:
if (SERVER) then AddCSLuaFile() end

if (SERVER) then
	local function OpenPermissions_Init()
		GAS:unhook("OpenPermissions:Ready", "GAS:OpenPermissions")

		GAS.OpenPermissions = OpenPermissions:RegisterAddon("gmodadminsuite", {
			Name = "GmodAdminSuite",
			Color = Color(30,34,42),
			Icon = "icon16/shield.png",
			Logo = {
				Path = "gmodadminsuite/gmodadminsuite.vtf",
				Width = 256,
				Height = 256
			}
		})

		GAS.OpenPermissions:AddToTree({
			Label = "See IP Addresses",
			Icon = "icon16/server_connect.png",
			Value = "see_ip_addresses",
			Default = OpenPermissions.CHECKBOX.CROSSED
		})

		local modules_tree = GAS.OpenPermissions:AddToTree({
			Label = "Modules",
			Icon = "icon16/server.png"
		})

		for module_name, module_data in pairs(GAS.Modules.Info) do
			if (not module_data.OperatorOnly and not module_data.NoMenu and not module_data.Hidden and not module_data.Public) then
				modules_tree:AddToTree({
					Label = module_data.Name,
					Value = module_name,
					Tip = "Can access the menu of " .. module_data.Name .. "?",
					Icon = module_data.Icon
				})
			end
		end
	end
	if (OpenPermissions_Ready == true) then
		OpenPermissions_Init()
	else
		GAS:hook("OpenPermissions:Ready", "GAS:OpenPermissions", OpenPermissions_Init)
	end
end

function GAS:CanAccessMenu(ply)
	if (OpenPermissions:IsOperator(ply)) then return true end
	for module_name in pairs(GAS.Modules.Config.Enabled) do
		if (OpenPermissions:HasPermission(ply, "gmodadminsuite/" .. module_name)) then
			return true
		end
	end
	return false
end
--lua/gmodadminsuite/cl_contextmenu.lua:
local function L(phrase, ...)
	if (#({...}) > 0) then
		return GAS:Phrase(phrase)
	else
		return GAS:PhraseFormat(phrase, nil, ...)
	end
end

GAS.ContextProperties = {}
function GAS:ContextProperty(name, propertydata)
	GAS.ContextProperties[name] = propertydata
end

properties.Add("GmodAdminSuite", {
	MenuLabel = "GmodAdminSuite",
	MenuIcon = "icon16/shield.png",
	Filter = function(self, ent, ply)
		if (not IsValid(ent)) then return false end
		if (table.Count(GAS.ContextProperties) == 0) then return false end
		return true
	end,
	MenuOpen = function(self, option, ent, tr)
		local option_submenu = option:AddSubMenu()
		option_submenu:AddOption(L"open_menu", self.Action):SetIcon("icon16/application_form_magnify.png")
		local spacer = false
		for i,v in pairs(GAS.ContextProperties) do
			if (v.Filter and v.Filter(self, ent, LocalPlayer()) == false) then continue end
			if (not spacer) then spacer = true option_submenu:AddSpacer() end
			local submenu, submenu_pnl = option_submenu:AddSubMenu(v.MenuLabel, v.Action)
			if (v.MenuIcon) then
				submenu_pnl:SetIcon(v.MenuIcon)
			end
			if (v.MenuOpen) then
				v.MenuOpen(self, submenu, ent, tr, submenu_pnl)
			end
		end
	end,
	Action = function()
		RunConsoleCommand("gmodadminsuite")
	end
})

--addons/gprofiler/lua/gprofiler/profilers/concommands/sh_concommands.lua:
GProfiler.ConCommands = GProfiler.ConCommands or {}
GProfiler.ConCommands.ProfileData = GProfiler.ConCommands.ProfileData or {}
GProfiler.ConCommands.IsDetoured = GProfiler.ConCommands.IsDetoured or false

local SysTime = SysTime
local math = math

function GProfiler.ConCommands.GetFunction(cmd, tbl)
	local commands = tbl or concommand.GetTable()
	local command = commands[cmd]

	if not command then return "Unknown", 0, 0 end

	local dbgInfo = debug.getinfo(command)
	return dbgInfo.short_src, dbgInfo.linedefined, dbgInfo.lastlinedefined
end

function GProfiler.ConCommands:StartProfiler(ply)
	if not GProfiler.Access.HasAccess(ply or LocalPlayer()) or GProfiler.ConCommands.IsDetoured then return end

	GProfiler.Log((SERVER and "Server" or "Client") .. " commands profiler started!", 2)
	GProfiler.ConCommands.OldRun = GProfiler.ConCommands.OldRun or concommand.Run
	GProfiler.ConCommands.ProfileData = {}
	GProfiler.ConCommands.IsDetoured = true
	GProfiler.ConCommands.ProfileStarted = SysTime()

	concommand.Run = function(ply, cmd, ...)
		local start = SysTime()
		local ret = GProfiler.ConCommands.OldRun(ply, cmd, ...)
		local time = SysTime() - start

		if not GProfiler.ConCommands.ProfileData[cmd] then
			local source, lineStart, lineEnd = GProfiler.ConCommands.GetFunction(cmd)
			GProfiler.ConCommands.ProfileData[cmd] = {
				Count = 0,
				Time = 0,
				AverageTime = 0,
				LongestTime = 0,
				Source = source,
				Lines = {lineStart, lineEnd}
			}
		end

		GProfiler.ConCommands.ProfileData[cmd].Count = GProfiler.ConCommands.ProfileData[cmd].Count + 1
		GProfiler.ConCommands.ProfileData[cmd].Time = GProfiler.ConCommands.ProfileData[cmd].Time + time
		GProfiler.ConCommands.ProfileData[cmd].AverageTime = GProfiler.ConCommands.ProfileData[cmd].Time / GProfiler.ConCommands.ProfileData[cmd].Count
		GProfiler.ConCommands.ProfileData[cmd].LongestTime = math.max(GProfiler.ConCommands.ProfileData[cmd].LongestTime, time)

		return ret
	end
end

function GProfiler.ConCommands:RestoreCommands(ply)
	if not GProfiler.Access.HasAccess(ply or LocalPlayer()) or not GProfiler.ConCommands.IsDetoured then return end

	GProfiler.Log((SERVER and "Server" or "Client") .. " commands profile stopped, sending data!", 2)
	GProfiler.ConCommands.IsDetoured = false
	GProfiler.ConCommands.ProfileStarted = nil

	concommand.Run = GProfiler.ConCommands.OldRun

	if SERVER then
		net.Start("GProfiler_ConCommands_SendData")
			net.WriteUInt(table.Count(GProfiler.ConCommands.ProfileData), 32)
			for k, v in pairs(GProfiler.ConCommands.ProfileData) do
				net.WriteString(k)
				net.WriteUInt(v.Count, 32)
				net.WriteFloat(v.Time)
				net.WriteFloat(v.AverageTime)
				net.WriteFloat(v.LongestTime)
				net.WriteString(v.Source)
				net.WriteUInt(v.Lines[1], 16)
				net.WriteUInt(v.Lines[2], 16)
			end
		net.Send(ply)
	end
end

if SERVER then
	util.AddNetworkString("GProfiler_ConCommands_ToggleServerProfile")
	util.AddNetworkString("GProfiler_ConCommands_ServerProfileStatus")
	util.AddNetworkString("GProfiler_ConCommands_CommandList")
	util.AddNetworkString("GProfiler_ConCommands_SendData")

	net.Receive("GProfiler_ConCommands_ToggleServerProfile", function(len, ply)
		if not GProfiler.Access.HasAccess(ply) then return end

		if net.ReadBool() then
			if net.ReadBool() then
				GProfiler.ConCommands.Focus = net.ReadString()
			else
				GProfiler.ConCommands.Focus = false
			end

			GProfiler.ConCommands:StartProfiler(ply)
			net.Start("GProfiler_ConCommands_ServerProfileStatus")
			net.WriteBool(true)
			net.WriteEntity(ply)
			net.Broadcast()
		else
			GProfiler.ConCommands:RestoreCommands(ply)
			net.Start("GProfiler_ConCommands_ServerProfileStatus")
			net.WriteBool(false)
			net.WriteEntity(ply)
			net.Broadcast()
		end
	end)

	net.Receive("GProfiler_ConCommands_CommandList", function(_, ply)
		local commandList = {}
		for k, v in pairs(concommand.GetTable()) do
			local source, lineStart, lineEnd = GProfiler.ConCommands.GetFunction(k, concommand.GetTable())
			commandList[k] = {Source = source, Lines = {lineStart, lineEnd}}
		end

		net.Start("GProfiler_ConCommands_CommandList")
			net.WriteUInt(table.Count(commandList), 32)
			for k, v in pairs(commandList) do
				net.WriteString(k)
				net.WriteString(v.Source)
				net.WriteUInt(v.Lines[1], 16)
				net.WriteUInt(v.Lines[2], 16)
			end
		net.Send(ply)
	end)
end
--lua/autorun/iss_delsin_lua.lua:
player_manager.AddValidModel( "Delsin Rowe", 				"models/players/ck_iss_delsin.mdl" )
list.Set( "PlayerOptionsModel",  "Delsin Rowe",				"models/players/ck_iss_delsin.mdl" )
player_manager.AddValidHands( "Delsin Rowe", "models/players/iss_delsin_arms.mdl", 0, "00000000" )

local Category = "Infamous: Second Son" 

local NPC = { Name = "Delsin Rowe - Friendly", 
	      Class = "npc_citizen", 
	      Model = "models/players/ck_iss_delsin_npc.mdl", 
	      Health = "100", 
	      KeyValues = { citizentype = 4 }, 
	      Category = Category
} 

list.Set( "NPC", "ck_iss_delsin_npc", NPC )

local NPC = {   Name = "Delsin Rowe - Hostile", 
                Class = "npc_combine",
                Model = "models/players/ck_iss_delsin_enemy.mdl",
                Health = "100", 
                Category = Category 
}
                               
list.Set( "NPC", "ck_iss_delsin_enemy", NPC )



--addons/minigame-tool-assistant/lua/minigames/languages/english.lua:
return gluapack()()
--addons/minigame-tool-assistant/lua/minigames/enum.lua:
--[[--------------------------------------------
              Minigame Enumeration
--------------------------------------------]]--

Minigames.Enum = Minigames.Enum or {}

-- Minigames.Enum["<Alias Name> <Hook Name>"] = function(GameScript, ...)

--[[----------------------------
           Kill Methods
----------------------------]]--

Minigames.Enum["KILL_ONTOUCH"] = function(self, ent)
    if not ( IsValid(ent) and ent:IsPlayer() ) then return end

    local TriggerOwner = self:Getowning_ent()
    local GameScript = Minigames.GetOwnerGame( TriggerOwner )

    local InGame, Owner = Minigames.PlayerInGame( ent )
    if InGame and ( Owner == TriggerOwner ) then
        if GameScript:IsActive() then
            ent:Kill()
        else
            if GetGlobalInt("eventkaybetme", 2) == 1 then 
                GameScript:RemovePlayer( ply )
            elseif GetGlobalInt("eventkaybetme", 2) == 2 then 
                GameScript:TeleportPlayer( ent )
                GameScript:RemovePlayer( ply )
            elseif GetGlobalInt("eventkaybetme", 2) == 3 then 
                ent:Kill()
                GameScript:RemovePlayer( ply )
            end 
 
        end
    end
end

Minigames.Enum["KILL_ONKEYPRESS KeyPress"] = function(ply, key)
    local InGame, Owner = Minigames.PlayerInGame( ply )
    if ply == Owner then return end

    local GameScript = Minigames.GetOwnerGame( Owner )
    if not GameScript then return end

    if InGame and GameScript:IsLookingBack() and GameScript.KeyPressKill[key] then
        ply:Kill()
    end
end



--[[----------------------------
           Win Methods
----------------------------]]--

Minigames.Enum["WIN_GENERIC"] = function(GameScript)
    local Players = GameScript:GetPlayers(true)

    if #Players > 0 then
        GameScript:SetPlayersWinner( Players[1] )
    end
end

Minigames.Enum["WIN_LASTSURVIVOR"] = function(GameScript)
    local Players = GameScript:GetPlayers(true)

    if #Players == 1 then
        GameScript:SetPlayerWinner( Players[1] )
        GameScript:StopGame()
    elseif #Players < 1 then
        GameScript:StopGame()
    end
end

Minigames.Enum["WIN_ONTOUCHTRIGGER"] = function(self, ent)
    if not ( self:IsActive() ) then return end
    if not ( IsValid(ent) and ent:IsPlayer() ) then return end

    local TriggerOwner = self:Getowning_ent()
    local GameScript = Minigames.GetOwnerGame( TriggerOwner )

    local InGame, Owner = Minigames.PlayerInGame( ent )
    if InGame and ( Owner == TriggerOwner ) then
        GameScript:SetPlayerWinner( ent )
        GameScript:StopGame()
    end
end

Minigames.Enum["WIN_RUSSIANROULETTE"] = function(GameScript)
    local Players = GameScript:GetPlayers(true)
    local Bots = GameScript:GetAllBots()

    if #Players == 1 and #Bots == 0 then
        GameScript:SetPlayerWinner( Players[1] )
    end

    if ( #Players == 0 and #Bots > 0 ) and not GameScript.OnlyBotsPlaying then
        GameScript:SetPlayerWinner( Bots[1] )
    end

    if GameScript.OnlyBotsPlaying and #Bots == 1 then
        GameScript:SetPlayerWinner( Bots[1] )
    end
end



--[[----------------------------
           Extra Methods
----------------------------]]--

Minigames.Enum["GetFallDamage"] = function(ply, speed)
    local InGame, Owner = Minigames.PlayerInGame( ply )
    if InGame then
        local GameScript = Minigames.GetOwnerGame( Owner )
        if GameScript:IsActive() then
            return ply:Health()
        end
    end
end

Minigames.Enum["PostPlayerDeath"] = function(ply)
    local InGame, Owner = Minigames.PlayerInGame( ply )
    if InGame then
        local GameScript = Minigames.GetOwnerGame( Owner )
        GameScript:RemovePlayer( ply )
    end
end



Minigames.Enum["STOP_ONNOBODY PostPlayerDeath"] = function(ply)
    local InGame, Owner = Minigames.PlayerInGame( ply )
    if InGame then
        local GameScript = Minigames.GetOwnerGame( Owner )
        GameScript:RemovePlayer( ply )

        if #GameScript:GetPlayers(true) == 0 then
            GameScript:StopGame()
        end
    end
end

Minigames.Enum["RUSSIANROULETTE PostPlayerDeath"] = function(ply)
    local InGame, Owner = Minigames.PlayerInGame( ply )
    if not InGame then return end

    local GameScript = Minigames.GetOwnerGame( Owner )
    if GameScript:GetGameID() ~= "russianroulette" then return end

    GameScript:RemovePlayer( ply )

    if GameScript.MainGameTimer then
        local Variable = GameScript.MainGameTimer:GetVariable()

        for k, inPlayer in ipairs(Variable.Players) do
            if ( inPlayer == ply ) then
                table.remove(Variable.Players, k)
                break
            end
        end
    end
end

Minigames.Enum["DEATHMATCH PlayerDeath"] = function(Victim, Inflictor, Attacker)
    local VictimInGame, VictimOwner = Minigames.PlayerInGame( Victim )
    if not VictimInGame then return end

    local GameScript = Minigames.GetOwnerGame( VictimOwner )
    if GameScript:GetGameID() ~= "deathmatch" then return end

    local AttackerInGame, AttackerOwner = Minigames.PlayerInGame( Attacker )
    if not AttackerInGame then return end

    if ( VictimOwner ~= AttackerOwner ) then return end
    if ( Victim == Attacker ) then return end

    GameScript:AddPoint( Attacker )
end

Minigames.Enum["DEATHMATCH PlayerSelectSpawn"] = function(ply)
    local InGame, Owner = Minigames.PlayerInGame( ply )
    if not InGame then return end

    local GameScript = Minigames.GetOwnerGame( Owner )
    if GameScript:GetGameID() ~= "deathmatch" then return end

    return GameScript:SelectSpawnPoint( ply )
end

Minigames.Enum["DEATHMATCH PlayerSpawn"] = function(ply)
    local InGame, Owner = Minigames.PlayerInGame( ply )
    if not InGame then return end

    local GameScript = Minigames.GetOwnerGame( Owner )
    if GameScript:GetGameID() ~= "deathmatch" then return end

    timer.Simple(0, function()
        ply:StripWeapons()
        ply:Give(GameScript.WeaponDefault)
        ply:SelectWeapon(GameScript.WeaponDefault)
    end)
end

Minigames.Enum["DEATHMATCH GetFallDamage"] = function(ply)
    local InGame, Owner = Minigames.PlayerInGame( ply )
    if not InGame then return end

    local GameScript = Minigames.GetOwnerGame( Owner )
    if GameScript:GetGameID() ~= "deathmatch" then return end

    if not GameScript.FallDamageEnabled then
        return 0
    end
end
--addons/minigame-tool-assistant/lua/minigames/vgui/togglegame.lua:
--[[--------------------------------------------
        Minigame Setup Menu - Toggle Button
--------------------------------------------]]--


local ButtonStyleBackground = Color(58, 58, 58, 150)
local ButtonStyleDisabled = Color(0, 0, 0, 100)
local BlackBackground = Color(0, 0, 0, 40)

local ShadingColor = {}
for i = 1, 16 do
    ShadingColor[i] = Color(0, 158, 185, (i * 160) / 16)
end

local ButtonStyle = function(SelfButton, w, h)
    draw.RoundedBox(4, 0, 0, w, h, SelfButton:IsEnabled() and ButtonStyleBackground or ButtonStyleDisabled)

    if not SelfButton:IsEnabled() then
        draw.RoundedBox(4, 0, 0, w, h, Color(0, 0, 0, 100))
    elseif SelfButton:IsHovered() then
        draw.RoundedBox(4, 0, 0, w, h, BlackBackground)

        for i = 1, 16 do
            draw.RoundedBox(0, 0, h + i - 16, w, 1, ShadingColor[i])
        end
    end
end

--[[----------------------------
       Toggle Game Button
----------------------------]]--

local PANEL = {}

function PANEL:Init()
    self.ToggleGameButon = self:Add("DButton")
    self.ToggleGameButon:SetText("Toggle Game")
    self.ToggleGameButon:SetFont("Minigames.Text")
    self.ToggleGameButon:SetTextColor(color_white)
    self.ToggleGameButon:Dock(FILL)
    self.ToggleGameButon.DoClick = function()
        net.Start("Minigames.SetupMenu")
        net.SendToServer()
    end

    self.ToggleGameButon:SetEnabled( Minigames.ActiveGames[ LocalPlayer() ] ~= nil )

    self.ToggleGameButon.Paint = ButtonStyle
end

function PANEL:Paint(w, h)
    draw.RoundedBox(4, 0, 0, w, h, ButtonStyleBackground)
end

vgui.Register("Minigames.ToggleGame", PANEL, "DPanel")
--addons/minigame-tool-assistant/lua/minigames/games/gamebase/customvar.lua:
return gluapack()()
--addons/minigame-tool-assistant/lua/minigames/games/gamebase/network.lua:
--[[--------------------------------------------
            Minigame Module - Network
--------------------------------------------]]--

if SERVER then
    util.AddNetworkString("Minigames.NetworkData")
end

local DefaultNetworkNameUInt = 4 --> 15

MinigameObject.__NetworkData = {}
MinigameObject.__RegisteredNetworks = {}

--[[----------------------------
        Network Functions
----------------------------]]--

function MinigameObject:RegisterNetworkData( NetworkName, TestFunc, Func )
    self:Checker(NetworkName, "string", 1)

    if self.__RegisteredNetworks[NetworkName] then
        self.ThrowError("The network data " .. NetworkName .. " is already registered.", NetworkName, "string")
    end

    self:Checker(TestFunc, "function", 2)
    self:Checker(Func, "function", 3)

    local NetworkIndex = table.insert(self.__NetworkData, {
        ["TestFunc"] = TestFunc,
        ["Func"] = Func
    })

    self.__RegisteredNetworks[NetworkName] = NetworkIndex

    if CLIENT then return end

    self["SendNW" .. NetworkName] = function( SubSelf, TargetPlayer )
        Target = TargetPlayer or SubSelf:GetOwner()

        local Result = Func(SubSelf)
        if not TestFunc(Result) then
            SubSelf.ThrowError("The network data \"" .. NetworkName .. "\" returned an invalid value.", Result, "any")
        end

        net.Start("Minigames.NetworkData")
            net.WriteString( SubSelf:GetGameID() )
            net.WriteUInt( NetworkIndex, DefaultNetworkNameUInt )
            net.WritePlayer( Target )
            net.WriteType( Result )
        net.Send(Target)
    end
end

function MinigameObject:CatchData( NetworkName, Func )
    if SERVER then return end

    self:Checker(NetworkName, "string", 1)
    self:Checker(Func, "function", 2)

    if not self.__RegisteredNetworks[NetworkName] then
        self.ThrowError("The network data " .. NetworkName .. " is not registered.", NetworkName, "string")
    end

    self.__NetworkData[ self.__RegisteredNetworks[NetworkName] ].Func = Func
end

if CLIENT then

    net.Receive("Minigames.NetworkData", function()
        local GameID = net.ReadString()
        local NetworkIndex = net.ReadUInt(DefaultNetworkNameUInt)

        if ( Minigames.Games[GameID] == nil ) then return end
        local Owner = net.ReadPlayer()
        local Data = net.ReadType()

        local GameScript = Minigames.GetOwnerGame(Owner)
        if not GameScript then return end

        GameScript.__NetworkData[NetworkIndex].Func(Data, GameScript)
    end)
end
--addons/minigame-tool-assistant/lua/minigames/rewards/xenin_battlepass.lua:
return gluapack()()
--addons/turkish_food_mod-main/lua/autorun/ltrr.lua:
return gluapack()()
--addons/media_player_fixed_edition/lua/mediaplayer/config/client.lua:
--[[----------------------------------------------------------------------------
	Media Player client configuration
------------------------------------------------------------------------------]]
MediaPlayer.SetConfig({

	---
	-- HTML content
	--
	html = {

		---
		-- Base URL where HTML content is located.
		-- @type String
		--
		base_url = "https://purrcoding.github.io/gm-mediaplayer/"

	},

	---
	-- Request menu
	--
	request = {

		---
		-- URL of the request menu.
		-- @type String
		--
		url = "https://purrcoding.github.io/gm-mediaplayer/request.html"

	}

})

--addons/media_player_fixed_edition/lua/mediaplayer/players/base/shared.lua:
return gluapack()()
--addons/media_player_fixed_edition/lua/mediaplayer/players/base/sh_snapshot.lua:
function MEDIAPLAYER:GetSnapshot()
	local queue = table.Copy( self:GetMediaQueue() )
	local media = self:GetMedia()

	return {
		media = media,
		currentTime = media and media:CurrentTime(),
		queue = queue,
		queueRepeat = self:GetQueueRepeat(),
		queueShuffle = self:GetQueueShuffle(),
		queueLocked = self:GetQueueLocked()
	}
end

function MEDIAPLAYER:RestoreSnapshot( snapshot )
	self._Queue = {}

	self:SetQueueRepeat( snapshot.queueRepeat )
	self:SetQueueShuffle( snapshot.queueShuffle )
	self:SetQueueLocked( snapshot.queueLocked )

	if snapshot.media then
		-- restore currently playing media from where it left off
		local mediaSnapshot = snapshot.media
		local media = MediaPlayer.GetMediaForUrl( mediaSnapshot.url )
		if media then
			table.Merge( media, mediaSnapshot )
			media:StartTime( RealTime() - snapshot.currentTime )
			self:SetMedia( media )
		end
	else
		self:SetMedia( nil )
	end

	if snapshot.queue then
		-- restore queue
		for _, mediaSnapshot in ipairs( snapshot.queue ) do
			local media = MediaPlayer.GetMediaForUrl( mediaSnapshot.url )
			if media then
				table.Merge( media, mediaSnapshot )
				self:AddMedia( media )
			end
		end

		self:QueueUpdated()
	end
end

--addons/media_player_fixed_edition/lua/mediaplayer/players/base/cl_fullscreen.lua:
return gluapack()()
--addons/media_player_fixed_edition/lua/mediaplayer/players/base/cl_fullscreen.lua:
local pcall = pcall
local RealTime = RealTime
local ScrW = ScrW
local ScrH = ScrH
local IsValid = IsValid

local FullscreenCvar = MediaPlayer.Cvars.Fullscreen

--[[---------------------------------------------------------
	Convar callback
-----------------------------------------------------------]]

local function OnFullscreenConVarChanged( name, old, new )

	new = (new == "1.00")
	old = (old == "1.00")

	local media

	for _, mp in pairs(MediaPlayer.List) do

		mp._LastMediaUpdate = RealTime()

		media = mp:CurrentMedia()

		if IsValid(media) and IsValid(media.Browser) then
			MediaPlayer.SetBrowserSize( media.Browser )
		end

	end

	MediaPlayer.SetBrowserSize( MediaPlayer.GetIdlescreen() )

	hook.Run( "MediaPlayerFullscreenToggled", new, old )

end
cvars.AddChangeCallback( FullscreenCvar:GetName(), OnFullscreenConVarChanged )


--[[---------------------------------------------------------
	Client controls for toggling fullscreen
-----------------------------------------------------------]]

inputhook.AddKeyPress( KEY_F11, "Toggle MediaPlayer Fullscreen", function()

	local isFullscreen = FullscreenCvar:GetBool()
	local numMp = #MediaPlayer.GetAll()

	-- only toggle if there's an active media player or we're in fullscreen mode
	if numMp == 0 and not isFullscreen then
		return
	end

	local value = isFullscreen and 0 or 1
	RunConsoleCommand( "mediaplayer_fullscreen", value )

end )


--[[---------------------------------------------------------
	Draw functions
-----------------------------------------------------------]]

function MEDIAPLAYER:DrawFullscreen()

	-- Don't draw if we're not fullscreen
	if not FullscreenCvar:GetBool() then return end

	local w, h = ScrW(), ScrH()
	local media = self:CurrentMedia()

	if IsValid(media) then

		-- Custom media draw function
		if media.Draw then
			media:Draw( w, h )
		end
		-- TODO: else draw 'not yet implemented' screen?

		-- Draw media info
		local succ, err = pcall( self.DrawMediaInfo, self, media, w, h )
		if not succ then
			print( err )
		end

	else

		local browser = MediaPlayer.GetIdlescreen()

		if IsValid(browser) then
			self:DrawHTML( browser, w, h )
		end

	end

end

--addons/media_player_fixed_edition/lua/mediaplayer/services/browser.lua:
return gluapack()()
--addons/media_player_fixed_edition/lua/mediaplayer/services/resource/shared.lua:
SERVICE.Name 	= "Resource"
SERVICE.Id 		= "res"
SERVICE.Base 	= "browser"
SERVICE.Abstract = true

SERVICE.FileExtensions = {}

function SERVICE:Match( url )
	-- check supported file extensions
	local ext = string.GetExtensionFromFilename(url)
	if ext and ext:match("(.[^?]+)") then
		ext = ext:match("(.[^?]+)")

		for _, ext2 in pairs(self.FileExtensions) do
			if ext == ext2 then
				return true
			end
		end
	end

	return false
end

function SERVICE:IsTimed()
	return false
end

--addons/media_player_fixed_edition/lua/mediaplayer/services/html5_video.lua:
return gluapack()()
--addons/media_player_fixed_edition/lua/mediaplayer/services/webpage.lua:
DEFINE_BASECLASS( "mp_service_browser" )

SERVICE.Name 	= "Webpage"
SERVICE.Id 		= "www"
SERVICE.Base 	= "res"
SERVICE.Abstract = true -- This service must be handled as a special case.

if CLIENT then

	function SERVICE:OnBrowserReady( browser )
		BaseClass.OnBrowserReady( self, browser )
		browser:OpenURL( self.url )
	end

	function SERVICE:IsMouseInputEnabled()
		return IsValid( self.Browser )
	end

else

	function SERVICE:Match( url )
		return false
	end

end

--addons/media_player_fixed_edition/lua/mediaplayer/sh_history.lua:
return gluapack()()
--addons/media_player_fixed_edition/lua/autorun/properties/mediaplayer.lua:
return gluapack()()
--addons/media_player_fixed_edition/lua/mp_menu/cl_init.lua:
MP = MP or {}
MP.EVENTS = MP.EVENTS or {}

MP.EVENTS.UI = {

	--[[--------------------------------------------------------
		Sidebar events
	----------------------------------------------------------]]

	SETUP_SIDEBAR = "mp.events.ui.sidebarChanged",
	SETUP_PLAYBACK_PANEL = "mp.events.ui.setupPlaybackPanel",
	SETUP_MEDIA_PANEL = "mp.events.ui.setupMediaPanel",

	MEDIA_PLAYER_CHANGED = "mp.events.ui.mediaPlayerChanged",

	OPEN_REQUEST_MENU = "mp.events.ui.openRequestMenu",
	FAVORITE_MEDIA = "mp.events.ui.favoriteMedia",
	REMOVE_MEDIA = "mp.events.ui.removeMedia",
	SKIP_MEDIA = "mp.events.ui.skipMedia",
	VOTE_MEDIA = "mp.events.ui.voteMedia",
	TOGGLE_LOCK = "mp.events.ui.toggleLock",
	TOGGLE_PAUSE = "mp.events.ui.togglePause",
	TOGGLE_REPEAT = "mp.events.ui.toggleRepeat",
	TOGGLE_SHUFFLE = "mp.events.ui.toggleShuffle",
	SEEK = "mp.events.ui.seek",

	START_SEEKING = "mp.events.ui.startSeeking",
	STOP_SEEKING = "mp.events.ui.stopSeeking",

	PRIVILEGED_PLAYER = "mp.events.ui.privilegedPlayer"

}

include "sidebar.lua"

--addons/media_player_fixed_edition/lua/mp_menu/sidebar.lua:
return gluapack()()
--addons/media_player_fixed_edition/lua/mp_menu/icons.lua:
local spritesheet = spritesheet

--[[--------------------------------------------
	Icons spritesheet
----------------------------------------------]]

local mpSpritesheetMat = Material( "mediaplayer/ui/spritesheet2015-10-7.png" )
local blockSize = 24

local function mpIcon( name, i, j, w, h )
	return {
		name = name,
		mat = mpSpritesheetMat,
		w = w,
		h = h,
		xoffset = i * blockSize,
		yoffset = j * blockSize
	}
end

spritesheet.Register {
	mpIcon( "mp-thumbs-up",			0, 0, 18, 21 ),
	mpIcon( "mp-thumbs-down",		1, 0, 18, 21 ),
	mpIcon( "mp-delete",			2, 0, 15, 20 ),
	mpIcon( "mp-favorite",			3, 0, 21, 21 ),
	mpIcon( "mp-favorite-outline", 	4, 0, 21, 21 ),
	mpIcon( "mp-volume-mute", 		0, 1, 18, 17 ),
	mpIcon( "mp-volume", 			1, 1, 18, 17 ),
	mpIcon( "mp-back", 				2, 1, 16, 17 ),
	mpIcon( "mp-forward", 			3, 1, 16, 17 ),
	mpIcon( "mp-home", 				4, 1, 19, 17 ),
	mpIcon( "mp-close", 			0, 2, 16, 16 ),
	mpIcon( "mp-skip", 				1, 2, 16, 16 ),
	mpIcon( "mp-refresh", 			2, 2, 16, 15 ),
	mpIcon( "mp-plus", 				3, 2, 14, 14 ),
	mpIcon( "mp-repeat", 			4, 2, 18, 18 ),
	mpIcon( "mp-shuffle", 			0, 3, 16, 16 ),
	mpIcon( "mp-replay", 			1, 3, 13, 16 ),
	mpIcon( "mp-lock", 			    2, 3, 12, 16 ),
	mpIcon( "mp-lock-open", 		3, 3, 12, 16 ),

	mpIcon( "mp-play", 				3, 4, 19, 25 ),
	mpIcon( "mp-pause",				4, 4, 22, 24 ),
}


--[[--------------------------------------------
	DIcon
----------------------------------------------]]

local DICON = {}

AccessorFunc( DICON, "m_strIcon", 				"Icon" )
AccessorFunc( DICON, "m_Color", 				"IconColor" )
AccessorFunc( DICON, "m_bKeepAspect", 			"KeepAspect" )

function DICON:Init()

	self:SetIconColor( color_white )
	self:SetMouseInputEnabled( false )
	self:SetKeyboardInputEnabled( false )

	self:SetKeepAspect( false )

	self.IconWidth = 10
	self.IconHeight = 10

end

function DICON:SetIcon( icon )

	self.m_strIcon = icon

	self.IconWidth, self.IconHeight = spritesheet.GetIconSize( icon )

end

function DICON:SizeToContents( strImage )

	self:SetSize( self.IconWidth, self.IconHeight )

end

function DICON:Paint( w, h )
	self:PaintAt( 0, 0, w, h )
end

function DICON:PaintAt( x, y, dw, dh )

	if not self.m_strIcon then return end

	if ( self.m_bKeepAspect ) then

		local w = self.IconWidth
		local h = self.IconHeight

		-- Image is bigger than panel, shrink to suitable size
		if ( w > dw and h > dh ) then

			if ( w > dw ) then

				local diff = dw / w
				w = w * diff
				h = h * diff

			end

			if ( h > dh ) then

				local diff = dh / h
				w = w * diff
				h = h * diff

			end

		end

		if ( w < dw ) then

			local diff = dw / w
			w = w * diff
			h = h * diff

		end

		if ( h < dh ) then

			local diff = dh / h
			w = w * diff
			h = h * diff

		end

		local OffX = ceil((dw - w) * 0.5)
		local OffY = ceil((dh - h) * 0.5)

		spritesheet.DrawIcon( self.m_strIcon, OffX + y, OffY + y, w, h, self.m_Color )
		return true

	end

	spritesheet.DrawIcon( self.m_strIcon, x, y, dw, dh, self.m_Color )
	return true

end

derma.DefineControl( "DIcon", "", DICON, "DPanel" )


--[[--------------------------------------------
	DIconButton
----------------------------------------------]]

local DICONBTN = {}

AccessorFunc( DICONBTN, "m_strIcon", "Icon" )
AccessorFunc( DICONBTN, "m_bStretchToFit", 			"StretchToFit" )

function DICONBTN:Init()

	self:SetPaintBackground( false )
	self:SetDrawBorder( false )
	self:SetStretchToFit( false )

	self:SetCursor( "hand" )
	self.m_Icon = vgui.Create( "DIcon", self )

	self:SetText( "" )

	self:SetColor( Color( 255, 255, 255, 255 ) )

end

function DICONBTN:SetIconVisible( bBool )

	self.m_Icon:SetVisible( bBool )

end

function DICONBTN:SetIcon( strIcon )

	self.m_Icon:SetIcon( strIcon )

end

function DICONBTN:SetColor( col )

	self.m_Icon:SetIconColor( col )

end

function DICONBTN:GetIcon()

	return self.m_Icon:GetIcon()

end

function DICONBTN:SetKeepAspect( bKeep )

	self.m_Icon:SetKeepAspect( bKeep )

end

function DICONBTN:SizeToContents( )

	self.m_Icon:SizeToContents()
	self:SetSize( self.m_Icon:GetWide(), self.m_Icon:GetTall() )

end

function DICONBTN:PerformLayout()

	if ( self.m_bStretchToFit ) then

		self.m_Icon:SetPos( 0, 0 )
		self.m_Icon:SetSize( self:GetSize() )

	else

		self.m_Icon:SizeToContents()
		self.m_Icon:Center()

	end

end

derma.DefineControl( "DIconButton", "", DICONBTN, "DButton" )


--[[--------------------------------------------
	DIconButton
----------------------------------------------]]

local DICONLBLBTN = {}

AccessorFunc( DICONLBLBTN, "m_LabelSpacing", "LabelSpacing" )
AccessorFunc( DICONLBLBTN, "m_Padding", "Padding" )

function DICONLBLBTN:Init()

	self.BaseClass.Init( self )

	self.BtnLbl = vgui.Create( "DLabel", self )
	self.BtnLbl:SetText( "" )

	self:SetLabelSpacing( 4 )
	self:SetPadding( 4 )

end

function DICONLBLBTN:PerformLayout()

	self.m_Icon:SizeToContents()
	self.m_Icon:AlignLeft( self.m_Padding )

	self.BtnLbl:SizeToContents()
	self.BtnLbl:MoveRightOf( self.m_Icon, self.m_LabelSpacing )

	local w = self.BtnLbl:GetPos() + self.BtnLbl:GetWide() + self.m_Padding
	local h = math.max( self.m_Icon:GetTall(), self.BtnLbl:GetTall() )
	self:SetWide( w, h )

	self.m_Icon:CenterVertical()
	self.BtnLbl:CenterVertical()

end

derma.DefineControl( "DIconLabeledButton", "", DICONLBLBTN, "DIconButton" )

--lua/autorun/odell.lua:
return gluapack()()
--lua/autorun/odell.lua:
--1

player_manager.AddValidModel( "odell-cryder", "models/player/odell/yakub.mdl" )
list.Set( "PlayerOptionsModel", "odell-cryder", "models/player/odell/yakub.mdl" )

--addons/onyx_framework_2/lua/autorun/onyx_autorun.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

05/06/2022

--]]

onyx = {}
onyx.cfg = {}

AddCSLuaFile('onyx/util.lua')
include('onyx/util.lua')
AddCSLuaFile('onyx/init.lua')
include('onyx/init.lua')
--addons/onyx_framework_2/lua/onyx/init.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

05/06/2022

--]]

local Run = hook.Run
local IncludeFolder = onyx.IncludeFolder

if (SERVER) then
    resource.AddWorkshop('852839002')
end

Run('PreOnyxLoad')

-- non recursive
IncludeFolder('onyx/framework/')
IncludeFolder('onyx/ui/')

-- init modules
do
    local Find = file.Find
    local path = 'onyx/modules/'
    local _, folders = Find(path .. '*', 'LUA')
    for _, name in ipairs(folders) do
        onyx.Include(path .. name .. '/sh_init.lua')
    end
end

Run('PostOnyxLoad')
--addons/onyx_framework_2/lua/onyx/framework/sh_init_framework.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

05/06/2022

--]]

AddCSLuaFile('onyx/framework/libs/thirdparty/data/utf8_chunk_1.lua')
AddCSLuaFile('onyx/framework/libs/thirdparty/data/utf8_chunk_2.lua')
AddCSLuaFile('onyx/framework/libs/thirdparty/data/utf8_chunk_3.lua')
AddCSLuaFile('onyx/framework/libs/thirdparty/data/utf8_chunk_4.lua')

onyx.IncludeFolder('onyx/framework/libs/thirdparty/')
onyx.IncludeFolder('onyx/framework/libs/')
onyx.IncludeFolder('onyx/framework/core/')

if (SERVER) then
    onyx.lang = {Get = function(phraseID)
        return phraseID
    end}
    onyx.lang.GetWFallback = onyx.lang.Get
end
--addons/onyx_framework_2/lua/onyx/framework/libs/thirdparty/sh_cami.lua:
--[[
CAMI - Common Admin Mod Interface.
Copyright 2020 CAMI Contributors

Makes admin mods intercompatible and provides an abstract privilege interface
for third party addons.

Follows the specification on this page:
https://github.com/glua/CAMI/blob/master/README.md

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
]]

-- Version number in YearMonthDay format.
local version = 20211019

if CAMI and CAMI.Version >= version then return end

CAMI = CAMI or {}
CAMI.Version = version


--- @class CAMI_USERGROUP
--- defines the charactaristics of a usergroup
--- @field Name string @The name of the usergroup
--- @field Inherits string @The name of the usergroup this usergroup inherits from
--- @field CAMI_Source string @The source specified by the admin mod which registered this usergroup (if any, converted to a string)

--- @class CAMI_PRIVILEGE
--- defines the charactaristics of a privilege
--- @field Name string @The name of the privilege
--- @field MinAccess "'user'" | "'admin'" | "'superadmin'" @Default group that should have this privilege
--- @field Description string | nil @Optional text describing the purpose of the privilege
local CAMI_PRIVILEGE = {}
--- Optional function to check if a player has access to this privilege
--- (and optionally execute it on another player)
---
--- ⚠ **Warning**: This function may not be called by all admin mods
--- @param actor GPlayer @The player
--- @param target GPlayer | nil @Optional - the target
--- @return boolean @If they can or not
--- @return string | nil @Optional reason
function CAMI_PRIVILEGE:HasAccess(actor, target)
end

--- Contains the registered CAMI_USERGROUP usergroup structures.
--- Indexed by usergroup name.
--- @type CAMI_USERGROUP[]
local usergroups = CAMI.GetUsergroups and CAMI.GetUsergroups() or {
    user = {
        Name = "user",
        Inherits = "user",
        CAMI_Source = "Garry's Mod",
    },
    admin = {
        Name = "admin",
        Inherits = "user",
        CAMI_Source = "Garry's Mod",
    },
    superadmin = {
        Name = "superadmin",
        Inherits = "admin",
        CAMI_Source = "Garry's Mod",
    }
}

--- Contains the registered CAMI_PRIVILEGE privilege structures.
--- Indexed by privilege name.
--- @type CAMI_PRIVILEGE[]
local privileges = CAMI.GetPrivileges and CAMI.GetPrivileges() or {}

--- Registers a usergroup with CAMI.
---
--- Use the source parameter to make sure CAMI.RegisterUsergroup function and
--- the CAMI.OnUsergroupRegistered hook don't cause an infinite loop
--- @param usergroup CAMI_USERGROUP @The structure for the usergroup you want to register
--- @param source any @Identifier for your own admin mod. Can be anything.
--- @return CAMI_USERGROUP @The usergroup given as an argument
function CAMI.RegisterUsergroup(usergroup, source)
    if source then
        usergroup.CAMI_Source = tostring(source)
    end
    usergroups[usergroup.Name] = usergroup

    hook.Call("CAMI.OnUsergroupRegistered", nil, usergroup, source)
    return usergroup
end

--- Unregisters a usergroup from CAMI. This will call a hook that will notify
--- all other admin mods of the removal.
---
--- ⚠ **Warning**: Call only when the usergroup is to be permanently removed.
---
--- Use the source parameter to make sure CAMI.UnregisterUsergroup function and
--- the CAMI.OnUsergroupUnregistered hook don't cause an infinite loop
--- @param usergroupName string @The name of the usergroup.
--- @param source any @Identifier for your own admin mod. Can be anything.
--- @return boolean @Whether the unregistering succeeded.
function CAMI.UnregisterUsergroup(usergroupName, source)
    if not usergroups[usergroupName] then return false end

    local usergroup = usergroups[usergroupName]
    usergroups[usergroupName] = nil

    hook.Call("CAMI.OnUsergroupUnregistered", nil, usergroup, source)

    return true
end

--- Retrieves all registered usergroups.
--- @return CAMI_USERGROUP[] @Usergroups indexed by their names.
function CAMI.GetUsergroups()
    return usergroups
end

--- Receives information about a usergroup.
--- @param usergroupName string
--- @return CAMI_USERGROUP | nil @Returns nil when the usergroup does not exist.
function CAMI.GetUsergroup(usergroupName)
    return usergroups[usergroupName]
end

--- Checks to see if potentialAncestor is an ancestor of usergroupName.
--- All usergroups are ancestors of themselves.
---
--- Examples:
--- * `user` is an ancestor of `admin` and also `superadmin`
--- * `admin` is an ancestor of `superadmin`, but not `user`
--- @param usergroupName string @The usergroup to query
--- @param potentialAncestor string @The ancestor to query
--- @return boolean @Whether usergroupName inherits potentialAncestor.
function CAMI.UsergroupInherits(usergroupName, potentialAncestor)
    repeat
        if usergroupName == potentialAncestor then return true end

        usergroupName = usergroups[usergroupName] and
                         usergroups[usergroupName].Inherits or
                         usergroupName
    until not usergroups[usergroupName] or
          usergroups[usergroupName].Inherits == usergroupName

    -- One can only be sure the usergroup inherits from user if the
    -- usergroup isn't registered.
    return usergroupName == potentialAncestor or potentialAncestor == "user"
end

--- Find the base group a usergroup inherits from.
---
--- This function traverses down the inheritence chain, so for example if you have
--- `user` -> `group1` -> `group2`
--- this function will return `user` if you pass it `group2`.
---
--- ℹ **NOTE**: All usergroups must eventually inherit either user, admin or superadmin.
--- @param usergroupName string @The name of the usergroup
--- @return "'user'" | "'admin'" | "'superadmin'" @The name of the root usergroup
function CAMI.InheritanceRoot(usergroupName)
    if not usergroups[usergroupName] then return end

    local inherits = usergroups[usergroupName].Inherits
    while inherits ~= usergroups[usergroupName].Inherits do
        usergroupName = usergroups[usergroupName].Inherits
    end

    return usergroupName
end

--- Registers an addon privilege with CAMI.
---
--- ⚠ **Warning**: This should only be used by addons. Admin mods must *NOT*
---  register their privileges using this function.
--- @param privilege CAMI_PRIVILEGE
--- @return CAMI_PRIVILEGE @The privilege given as argument.
function CAMI.RegisterPrivilege(privilege)
    privileges[privilege.Name] = privilege

    hook.Call("CAMI.OnPrivilegeRegistered", nil, privilege)

    return privilege
end

--- Unregisters a privilege from CAMI.
--- This will call a hook that will notify any admin mods of the removal.
---
--- ⚠ **Warning**: Call only when the privilege is to be permanently removed.
--- @param privilegeName string @The name of the privilege.
--- @return boolean @Whether the unregistering succeeded.
function CAMI.UnregisterPrivilege(privilegeName)
    if not privileges[privilegeName] then return false end

    local privilege = privileges[privilegeName]
    privileges[privilegeName] = nil

    hook.Call("CAMI.OnPrivilegeUnregistered", nil, privilege)

    return true
end

--- Retrieves all registered privileges.
--- @return CAMI_PRIVILEGE[] @All privileges indexed by their names.
function CAMI.GetPrivileges()
    return privileges
end

--- Receives information about a privilege.
--- @param privilegeName string
--- @return CAMI_PRIVILEGE | nil
function CAMI.GetPrivilege(privilegeName)
    return privileges[privilegeName]
end

-- Default access handler
local defaultAccessHandler = {["CAMI.PlayerHasAccess"] =
    function(_, actorPly, privilegeName, callback, targetPly, extraInfoTbl)
        -- The server always has access in the fallback
        if not IsValid(actorPly) then return callback(true, "Fallback.") end

        local priv = privileges[privilegeName]

        local fallback = extraInfoTbl and (
            not extraInfoTbl.Fallback and actorPly:IsAdmin() or
            extraInfoTbl.Fallback == "user" and true or
            extraInfoTbl.Fallback == "admin" and actorPly:IsAdmin() or
            extraInfoTbl.Fallback == "superadmin" and actorPly:IsSuperAdmin())


        if not priv then return callback(fallback, "Fallback.") end

        local hasAccess =
            priv.MinAccess == "user" or
            priv.MinAccess == "admin" and actorPly:IsAdmin() or
            priv.MinAccess == "superadmin" and actorPly:IsSuperAdmin()

        if hasAccess and priv.HasAccess then
            hasAccess = priv:HasAccess(actorPly, targetPly)
        end

        callback(hasAccess, "Fallback.")
    end,
    ["CAMI.SteamIDHasAccess"] =
    function(_, _, _, callback)
        callback(false, "No information available.")
    end
}

--- @class CAMI_ACCESS_EXTRA_INFO
--- @field Fallback "'user'" | "'admin'" | "'superadmin'" @Fallback status for if the privilege doesn't exist. Defaults to `admin`.
--- @field IgnoreImmunity boolean @Ignore any immunity mechanisms an admin mod might have.
--- @field CommandArguments table @Extra arguments that were given to the privilege command.

--- Checks if a player has access to a privilege
--- (and optionally can execute it on targetPly)
---
--- This function is designed to be asynchronous but will be invoked
---  synchronously if no callback is passed.
---
--- ⚠ **Warning**: If the currently installed admin mod does not support
---                 synchronous queries, this function will throw an error!
--- @param actorPly GPlayer @The player to query
--- @param privilegeName string @The privilege to query
--- @param callback fun(hasAccess: boolean, reason: string|nil) @Callback to receive the answer, or nil for synchronous
--- @param targetPly GPlayer | nil @Optional - target for if the privilege effects another player (eg kick/ban)
--- @param extraInfoTbl CAMI_ACCESS_EXTRA_INFO | nil @Table of extra information for the admin mod
--- @return boolean | nil @Synchronous only - if the player has the privilege
--- @return string | nil @Synchronous only - optional reason from admin mod
function CAMI.PlayerHasAccess(actorPly, privilegeName, callback, targetPly,
extraInfoTbl)
    local hasAccess, reason = nil, nil
    local callback_ = callback or function(hA, r) hasAccess, reason = hA, r end

    hook.Call("CAMI.PlayerHasAccess", defaultAccessHandler, actorPly,
        privilegeName, callback_, targetPly, extraInfoTbl)

    if callback ~= nil then return end

    if hasAccess == nil then
        local err = [[The function CAMI.PlayerHasAccess was used to find out
        whether Player %s has privilege "%s", but an admin mod did not give an
        immediate answer!]]
        error(string.format(err,
            actorPly:IsPlayer() and actorPly:Nick() or tostring(actorPly),
            privilegeName))
    end

    return hasAccess, reason
end

--- Get all the players on the server with a certain privilege
--- (and optionally who can execute it on targetPly)
---
--- ℹ **NOTE**: This is an asynchronous function!
--- @param privilegeName string @The privilege to query
--- @param callback fun(players: GPlayer[]) @Callback to receive the answer
--- @param targetPly GPlayer | nil @Optional - target for if the privilege effects another player (eg kick/ban)
--- @param extraInfoTbl CAMI_ACCESS_EXTRA_INFO | nil @Table of extra information for the admin mod
function CAMI.GetPlayersWithAccess(privilegeName, callback, targetPly,
extraInfoTbl)
    local allowedPlys = {}
    local allPlys = player.GetAll()
    local countdown = #allPlys

    local function onResult(ply, hasAccess, _)
        countdown = countdown - 1

        if hasAccess then table.insert(allowedPlys, ply) end
        if countdown == 0 then callback(allowedPlys) end
    end

    for _, ply in ipairs(allPlys) do
        CAMI.PlayerHasAccess(ply, privilegeName,
            function(...) onResult(ply, ...) end,
            targetPly, extraInfoTbl)
    end
end

--- @class CAMI_STEAM_ACCESS_EXTRA_INFO
--- @field IgnoreImmunity boolean @Ignore any immunity mechanisms an admin mod might have.
--- @field CommandArguments table @Extra arguments that were given to the privilege command.

--- Checks if a (potentially offline) SteamID has access to a privilege
--- (and optionally if they can execute it on a target SteamID)
---
--- ℹ **NOTE**: This is an asynchronous function!
--- @param actorSteam string | nil @The SteamID to query
--- @param privilegeName string @The privilege to query
--- @param callback fun(hasAccess: boolean, reason: string|nil) @Callback to receive  the answer
--- @param targetSteam string | nil @Optional - target SteamID for if the privilege effects another player (eg kick/ban)
--- @param extraInfoTbl CAMI_STEAM_ACCESS_EXTRA_INFO | nil @Table of extra information for the admin mod
function CAMI.SteamIDHasAccess(actorSteam, privilegeName, callback,
targetSteam, extraInfoTbl)
    hook.Call("CAMI.SteamIDHasAccess", defaultAccessHandler, actorSteam,
        privilegeName, callback, targetSteam, extraInfoTbl)
end

--- Signify that your admin mod has changed the usergroup of a player. This
--- function communicates to other admin mods what it thinks the usergroup
--- of a player should be.
---
--- Listen to the hook to receive the usergroup changes of other admin mods.
--- @param ply GPlayer @The player for which the usergroup is changed
--- @param old string @The previous usergroup of the player.
--- @param new string @The new usergroup of the player.
--- @param source any @Identifier for your own admin mod. Can be anything.
function CAMI.SignalUserGroupChanged(ply, old, new, source)
    hook.Call("CAMI.PlayerUsergroupChanged", nil, ply, old, new, source)
end

--- Signify that your admin mod has changed the usergroup of a disconnected
--- player. This communicates to other admin mods what it thinks the usergroup
--- of a player should be.
---
--- Listen to the hook to receive the usergroup changes of other admin mods.
--- @param steamId string @The steam ID of the player for which the usergroup is changed
--- @param old string @The previous usergroup of the player.
--- @param new string @The new usergroup of the player.
--- @param source any @Identifier for your own admin mod. Can be anything.
function CAMI.SignalSteamIDUserGroupChanged(steamId, old, new, source)
    hook.Call("CAMI.SteamIDUsergroupChanged", nil, steamId, old, new, source)
end

--addons/onyx_framework_2/lua/onyx/framework/libs/cl_lang.lua:
--[[

Author: tochonement
Email: tochonement@gmail.com

28.09.2021

--]]

onyx.lang = onyx.lang or {}
onyx.lang.phrases = onyx.lang.phrases or {}
onyx.lang.id = onyx.lang.id or 'default'

local lang = onyx.lang

function lang:AddPhrase(langID, phraseID, text)
    self.phrases[langID] = self.phrases[langID] or {}
    self.phrases[langID][phraseID] = text
end

function lang:AddPhrases(langID, phrasesTable)
    for phraseID, text in pairs(phrasesTable) do
        self:AddPhrase(langID, phraseID, text)
    end
end

do
    local gsub = string.gsub
    local tostring = tostring
    local pairs = pairs

    function lang:Get(phraseID, arguments, translateArguments)
        local basePhrases = self.phrases.english or {}
        local localPhrases = self.phrases[self.id] or {}
        local text

        -- Search in the local phrases table
        if localPhrases[phraseID] then
            text = localPhrases[phraseID]
            goto process
        end

        -- Search in the base phrases table
        if basePhrases[phraseID] then
            text = basePhrases[phraseID]
            goto process
        end

        ::process::

        -- Place the arguments into the found text
        if text and arguments then
            for key, value in pairs(arguments) do
                value = tostring(value)

                local argument = translateArguments and lang:Get(value) or value

                text = gsub(text, '{' .. key .. '}', argument, 1)
            end
        end

        return text or phraseID
    end

    function lang:GetWFallback(phraseID, fallback)
        local phrase = self:Get(phraseID)
        if (phrase == phraseID) then
            return (fallback or phrase)
        else
            return phrase
        end
    end
end

do
    local languageReference = {
        en = 'english',
        ru = 'russian',
        de = 'german',
        fr = 'french',
        it = 'italian',
        tr = 'turkish',
        da = 'danish',
        pl = 'polish',
        ['es-ES'] = 'spanish'
    }

    function lang:GetGameLanguage()
        local current = GetConVar('gmod_language'):GetString()
        return languageReference[current]
    end

    function lang:SetBestLanguage()
        local found = self:GetGameLanguage()
        if (found) then
            self.id = found
        else
            self.id = 'default'
        end
    end

    lang:SetBestLanguage()

    cvars.AddChangeCallback('gmod_language', function()
        lang:SetBestLanguage()
    end, 'onyx.lang')
end
--addons/onyx_framework_2/lua/onyx/framework/libs/sh_netchunk.lua:
return gluapack()()
--addons/onyx_framework_2/lua/onyx/ui/libs/thirdparty/cl_ui3d2d.lua:
if (ui3d2d) then return end

ui3d2d = ui3d2d or {}

do --Input handling
    local useBind = input.LookupBinding("+use", true)
    local attackBind = input.LookupBinding("+attack", true)

    do
        local lookupBinding = input.LookupBinding
        timer.Create("ui3d2d.lookupBindings", 5, 0, function() --Keep our use and attack bind keys up to date
            useBind = lookupBinding("+use", true)
            attackBind = lookupBinding("+attack", true)
        end)
    end

    do
        local getRenderTarget, cursorVisible = render.GetRenderTarget, vgui.CursorVisible
        local getKeyCode, isButtonDown = input.GetKeyCode, input.IsButtonDown

        local inputEnabled, isPressing, isPressed

        hook.Add("PreRender", "ui3d2d.inputHandler", function() --Check the input state before rendering UIs
            if getRenderTarget() then inputEnabled = false return end
            if cursorVisible() then inputEnabled = false return end

            local useKey = useBind and getKeyCode(useBind)
            local attackKey = attackBind and getKeyCode(attackBind)

            inputEnabled = true

            local wasPressing = isPressing
            isPressing = (useKey and isButtonDown(useKey)) or (attackKey and isButtonDown(attackKey))
            isPressed = not wasPressing and isPressing
        end)

        function ui3d2d.isPressing() --Returns true if an input is being held
            return inputEnabled and isPressing
        end

        function ui3d2d.isPressed() --Returns true if an input was pressed this frame
            return inputEnabled and isPressed
        end
    end
end

do --Rendering context creation and mouse position getters
    local localPlayer

    hook.Add("PreRender", "ui3d2d.getLocalPlayer", function() --Keep getting the local player until it's available
        localPlayer = LocalPlayer()
        if IsValid(localPlayer) then hook.Remove("PreRender", "ui3d2d.getLocalPlayer") end
    end)

    local traceLine = util.TraceLine

    local baseQuery = {filter = {}}

    local function isObstructed(eyePos, hitPos, ignoredEntity) --Check if the cursor trace is obstructed by another ent
        local query = baseQuery
        query.start = eyePos
        query.endpos = hitPos
        query.filter[1] = localPlayer
        query.filter[2] = ignoredEntity

        return traceLine(query).Hit
    end

    local mouseX, mouseY

    do
        local start3d2d = cam.Start3D2D
        local isCursorVisible, isHoveringWorld = vgui.CursorVisible, vgui.IsHoveringWorld
        local screenToVector, mousePos = gui.ScreenToVector, gui.MousePos
        local intersectRayWithPlane = util.IntersectRayWithPlane

        local isRendering

        function ui3d2d.startDraw(pos, angles, scale, ignoredEntity) --Starts a new 3d2d ui rendering context
            if isRendering then print("[ui3d2d] Attempted to draw a new 3d2d ui without ending the previous one.") return end

            local eyePos = localPlayer:EyePos()
            local eyePosToUi = pos - eyePos

            do --Only draw the UI if the player is in front of it
                local normal = angles:Up()
                local dot = eyePosToUi:Dot(normal)

                if dot >= 0 then return end
            end

            isRendering = true
            mouseX, mouseY = nil, nil

            start3d2d(pos, angles, scale)

            local cursorVisible, hoveringWorld = isCursorVisible(), isHoveringWorld()
            if not hoveringWorld and cursorVisible then return true end

            local eyeNormal
            do
                if cursorVisible and hoveringWorld then
                    eyeNormal = screenToVector(mousePos())
                else
                    eyeNormal = localPlayer:GetEyeTrace().Normal
                end
            end

            local hitPos = intersectRayWithPlane(eyePos, eyeNormal, pos, angles:Up())
            if not hitPos then return true end

            if isObstructed(eyePos, hitPos, ignoredEntity) then return true end

            do
                local diff = pos - hitPos
                mouseX = diff:Dot(-angles:Forward()) / scale
                mouseY = diff:Dot(-angles:Right()) / scale
            end

            return true
        end

        local end3d2d = cam.End3D2D

        function ui3d2d.endDraw() --Safely ends the 3d2d ui rendering context
            if not isRendering then print("[ui3d2d] Attempted to end a non-existant 3d2d ui rendering context.") return end
            isRendering = false
            end3d2d()
        end
    end

    function ui3d2d.getCursorPos() --Returns the current 3d2d cursor position
        return mouseX, mouseY
    end

    function ui3d2d.isHovering(x, y, w, h) --Returns whether the cursor is within a specified area
        local mx, my = mouseX, mouseY
        return mx and my and mx >= x and mx <= (x + w) and my >= y and my <= (y + h)
    end
end

hook.Run("ui3d2d.fullyLoaded")
--addons/onyx_framework_2/lua/onyx/ui/libs/cl_font.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

15/04/2022

--]]

onyx.fonts = {}

local string_Explode = string.Explode
local math_ceil = math.ceil
local surface_CreateFont = surface.CreateFont
local tonumber = tonumber

local function createFont(font, size, parameters, initialSize)
    local name = 'onyx.' .. font .. size .. util.CRC(parameters or '')

    if onyx.fonts[name] then
        return name
    end

    local data = {
        font = font,
        size = size,
        extended = true,
        initialSize = initialSize
    }

    if parameters then
        local tblParameters = string_Explode(';', parameters)
        for _, str in ipairs(tblParameters) do
            local parts = string_Explode(':', str)
            local key, val = parts[1], parts[2]
            if tonumber(val) then
                data[key] = tonumber(val)
            else
                if val == 'true' then
                    data[key] = true
                else
                    data[key] = false
                end
            end
        end
    end

    onyx.fonts[name] = data

    surface_CreateFont(name, data)

    return name
end

local fetchFont do
    local aliases = {}

    function fetchFont(family)
        local overridedFont = hook.Call('onyx.ui.OverrideFont', nil, family)
        return (overridedFont or aliases[family] or family)
    end

    local function createAlias(alias, real)
        aliases[alias] = real
    end

    createAlias('Averta', 'AvertaStd-Regular')
    createAlias('Averta Bold', 'AvertaStd-Bold')
    createAlias('Averta Black', 'AvertaStd-Black')
end

function onyx.Font(pattern, parameters)
    local parts = string_Explode('@', pattern)
    local family, size = fetchFont(parts[1]), tonumber(parts[2])
    local scaledSize = math_ceil(size / 900 * ScrH())

    return createFont(family, scaledSize, parameters, size)
end

function onyx.FontNoScale(pattern, size, parameters)
    local family

    if size then
        family = fetchFont(pattern)
    else
        local parts = string_Explode('@', pattern)

        family, size = fetchFont(parts[1]), parts[2]
    end

    return createFont(family, size, parameters)
end

hook.Add('OnScreenSizeChanged', 'onyx.font.Recreate', function()
    for name, data in pairs(onyx.fonts) do
        if data.initialSize then
            data.size = math_ceil(data.initialSize / 900 * ScrH())
            surface_CreateFont(name, data)
        end
    end
end)
--addons/onyx_framework_2/lua/onyx/ui/elements/cl_combo.lua:
return gluapack()()
--addons/onyx_framework_2/lua/onyx/ui/elements/cl_image_button.lua:
return gluapack()()
--addons/onyx_f4/lua/onyx/modules/f4/cfg/cl_actions.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

04/01/2024

--]]

onyx.f4.actions = {}

local CATEGORY = 'f4_general_u'

local L = function(...) return onyx.lang:Get(...) end

local CUSTOMCHECK_POLICE = function(client)
    return client:isCP()
end

local CUSTOMCHECK_MAYOR = function(client)
    return client:isMayor()
end

onyx.f4:RegisterAction({
    name = 'f4_action_drop_money',
    category = CATEGORY,
    func = function()
        onyx.SimpleQuery(
            L('f4_action_drop_money'),
            L('f4_action_input_amount'),
            true,
            function(value)
                RunConsoleCommand('darkrp', 'dropmoney', value)
            end, L('f4_confirm_u'),
            nil, L('f4_cancel_u')
        )
    end
})

onyx.f4:RegisterAction({
    name = 'f4_action_give_money',
    category = CATEGORY,
    func = function()
        onyx.SimpleQuery(
            L('f4_action_give_money'),
            L('f4_action_input_amount'),
            true,
            function(value)
                RunConsoleCommand('darkrp', 'give', value)
            end, L('f4_confirm_u'),
            nil, L('f4_cancel_u')
        )
    end
})

onyx.f4:RegisterAction({
    name = 'f4_action_change_name',
    category = CATEGORY,
    func = function()
        onyx.SimpleQuery(
            L('f4_action_change_name'),
            L('f4_action_input_text'),
            true,
            function(value)
                RunConsoleCommand('darkrp', 'rpname', value)
            end, L('f4_confirm_u'),
            nil, L('f4_cancel_u')
        )
    end
})

onyx.f4:RegisterAction({
    name = 'f4_action_drop_weapon',
    category = CATEGORY,
    func = function()
        RunConsoleCommand('darkrp', 'dropweapon')
    end
})

onyx.f4:RegisterAction({
    name = 'f4_action_sell_doors',
    category = CATEGORY,
    func = function()
        onyx.SimpleQuery(
            L('f4_action_sell_doors'),
            L('f4_action_confirm_action'),
            false,
            function()
                RunConsoleCommand('darkrp', 'sellalldoors')
            end, L('f4_confirm_u'),
            nil, L('f4_cancel_u')
        )
    end
})

CATEGORY = 'f4_police_u'

onyx.f4:RegisterAction({
    name = 'f4_action_warrant',
    category = CATEGORY,
    canSee = CUSTOMCHECK_POLICE,
    func = function()
        onyx.ChoosePlayer(
            L('f4_action_warrant'),
            L('f4_action_choose_player'),
            function(ply)
                local name = ply:Name()

                onyx.SimpleQuery(
                    L('f4_action_warrant'),
                    L('f4_action_input_reason'),
                    true,
                    function(reason)
                        RunConsoleCommand('darkrp', 'warrant', name, reason)
                    end
                )
            end
        )
    end
})

onyx.f4:RegisterAction({
    name = 'f4_action_wanted',
    category = CATEGORY,
    canSee = CUSTOMCHECK_POLICE,
    func = function()
        onyx.ChoosePlayer(
            L('f4_action_wanted'),
            L('f4_action_choose_player'),
            function(ply)
                local name = ply:Name()

                onyx.SimpleQuery(
                    L('f4_action_wanted'),
                    L('f4_action_input_reason'),
                    true,
                    function(reason)
                        RunConsoleCommand('darkrp', 'wanted', name, reason)
                    end
                )
            end
        )
    end
})

CATEGORY = 'f4_mayor_u'

onyx.f4:RegisterAction({
    name = 'f4_toggle_lockdown',
    category = CATEGORY,
    canSee = CUSTOMCHECK_MAYOR,
    func = function()
        if (GetGlobalBool('DarkRP_LockDown')) then
            RunConsoleCommand('darkrp', 'unlockdown')
        else
            RunConsoleCommand('darkrp', 'lockdown')
        end
    end
})

onyx.f4:RegisterAction({
    name = 'f4_give_license',
    category = CATEGORY,
    canSee = CUSTOMCHECK_MAYOR,
    func = function()
        RunConsoleCommand('darkrp', 'givelicense')
    end
})
--addons/bb_onyx_hud/lua/onyx/modules/hud/languages/cl_polish.lua:
return gluapack()()
--addons/bb_onyx_hud/lua/onyx/modules/hud/languages/cl_turkish.lua:
return gluapack()()
--addons/bb_onyx_hud/lua/onyx/modules/hud/core/sh_config.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

19/08/2024

--]]

local function createDisplayOption( id, default )
    if ( default == nil ) then default = true end

    onyx.hud:RegisterOption( 'display_' .. id, {
        title = 'hud.' .. id .. '.name',
        desc = 'hud_should_draw',
        category = 'display',
        cami = 'onyx_hud_edit',
        type = 'bool',
        default = default
    } )
end

CAMI.RegisterPrivilege({
    Name = 'onyx_hud_edit',
    MinAccess = 'superadmin',
    Description = 'Allows to configure Onyx HUD'
})

onyx.hud:RegisterOption( 'timeout', {
    title = 'hud.timeout.name',
    desc = 'hud.timeout.desc',
    category = 'general',
    cami = 'onyx_hud_edit',
    type = 'int',
    default = 45,
    min = 15,
    max = 180
} )

onyx.hud:RegisterOption( 'alert_queue', {
    title = 'hud.alert_queue.name',
    desc = 'hud.alert_queue.desc',
    category = 'general',
    cami = 'onyx_hud_edit',
    type = 'bool',
    default = false
} )

onyx.hud:RegisterOption( 'props_counter', {
    title = 'hud.props_counter.name',
    desc = 'hud.props_counter.desc',
    category = 'general',
    cami = 'onyx_hud_edit',
    type = 'bool',
    default = false
} )

onyx.hud:RegisterOption( 'restrict_themes', {
    title = 'hud.restrict_themes.name',
    desc = 'hud.restrict_themes.desc',
    category = 'general',
    cami = 'onyx_hud_edit',
    type = 'bool',
    default = false
} )

onyx.hud:RegisterOption( 'main_avatar_mode', {
    title = 'hud.main_avatar_mode.name',
    desc = 'hud.main_avatar_mode.desc',
    category = 'general',
    cami = 'onyx_hud_edit',
    type = 'int',
    default = 0,
    min = 0,
    max = 1,
    combo = {
        { 'Avatar', 0 },
        { 'Model', 1 }
    }
} )

onyx.hud:RegisterOption( 'voice_avatar_mode', {
    title = 'hud.voice_avatar_mode.name',
    desc = 'hud.voice_avatar_mode.desc',
    category = 'general',
    cami = 'onyx_hud_edit',
    type = 'int',
    default = 0,
    min = 0,
    max = 1,
    combo = {
        { 'Avatar', 0 },
        { 'Model', 1 }
    }
} )

-- Speedometer

onyx.hud:RegisterOption( 'speedometer_mph', {
    title = 'hud.speedometer_mph.name',
    desc = 'hud.speedometer_mph.desc',
    category = 'speedometer',
    cami = 'onyx_hud_edit',
    type = 'bool',
    default = false
} )

onyx.hud:RegisterOption( 'speedometer_max_speed', {
    title = 'hud.speedometer_max_speed.name',
    desc = 'hud.speedometer_max_speed.desc',
    category = 'speedometer',
    cami = 'onyx_hud_edit',
    type = 'int',
    default = 260,
    min = 180,
    max = 300
} )

-- Display

createDisplayOption( 'main' )
createDisplayOption( 'ammo' )
createDisplayOption( 'agenda' )
createDisplayOption( 'pickup_history' )
createDisplayOption( 'voice' )
createDisplayOption( 'alerts' )
createDisplayOption( 'vehicle' )
createDisplayOption( 'level' )
createDisplayOption( 'overhead_health', false )
createDisplayOption( 'overhead_armor', false )
--addons/bb_onyx_hud/lua/onyx/modules/hud/elements/cl_vehicle_hud.lua:
return gluapack()()
--addons/bb_onyx_hud/lua/onyx/modules/hud/elements/cl_votes.lua:
return gluapack()()
--addons/bb_onyx_hud/lua/onyx/modules/hud/ui/cl_settings.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

14/08/2024

--]]

local COLOR_PRIMARY = onyx:Config( 'colors.primary' )
local COLOR_SECONDARY = onyx:Config( 'colors.secondary' )
local COLOR_TERTIARY = onyx:Config( 'colors.tertiary' )
local COLOR_ACCENT = onyx:Config( 'colors.accent' )
local COLOR_GRAY = Color( 150, 150, 150)
local COLOR_BUTTON_HOVER = onyx.LerpColor( .5, COLOR_TERTIARY, COLOR_ACCENT )
local FONT_NAME = onyx.Font( 'Comfortaa Bold@16' )
local FONT_DESC = onyx.Font( 'Comfortaa@14' )
local FONT_BUTTON = onyx.Font( 'Comfortaa Bold@32' )

local PANEL = {}

function PANEL:Init()
    self.list = self:Add( 'onyx.ScrollPanel' )
    self.list:Dock( FILL )

    self.grid = self.list:Add( 'onyx.Grid' )
    self.grid:Dock( FILL )
    self.grid:SetColumnCount( 2 )
    self.grid:SetSpace( onyx.ScaleTall( 5 ) )

    self:LoadOptions()
end

function PANEL:LoadOptions()
    if ( not onyx.hud:GetOptionValue( 'restrict_themes' )) then
        local themeOptions = {}

        for id, theme in pairs( onyx.hud.themes ) do
            table.insert( themeOptions, {
                name = onyx.lang:Get( string.format( 'hud.theme.%s.name', id ) ),
                key = id
            } )
        end

        self:AddOption( 'combo', 'theme', 'cl_onyx_hud_theme_id', {
            options = themeOptions
        } )
    end

    self:AddOption( 'int', 'scale', 'cl_onyx_hud_scale' )
    self:AddOption( 'int', 'roundness', 'cl_onyx_hud_roundness', { step = 4 } )
    self:AddOption( 'int', 'margin', 'cl_onyx_hud_screen_padding', { step = 5 } )
    self:AddOption( 'int', '3d2d_max_details', 'cl_onyx_hud_3d2d_max_details', { step = 1 } )

    self:AddOption( 'bool', 'compact', 'cl_onyx_hud_compact' )
    self:AddOption( 'bool', 'speedometer_blur', 'cl_onyx_hud_speedometer_blur' )

    if ( onyx.hud:GetOptionValue( 'main_avatar_mode' ) == 1 ) then
        self:AddOption( 'bool', 'icons_3d', 'cl_onyx_hud_3d_models' )
    end
end

function PANEL:AddOption( optionType, id, convarName, data )
    local text = onyx.lang:Get( 'hud.' .. id .. '.name' )
    local desc = onyx.lang:Get( 'hud.' .. id .. '.desc' )
    local convarObject = GetConVar( convarName )
    local data = data or {}
    local field = self:CreateField( text, desc )
    local height = field:GetTall() - field.padding * 2
    
    if ( optionType == 'bool' ) then
        field.centerChild = false

        field.togglerContainer = field:Add('Panel')
        field.togglerContainer:SetWide( onyx.ScaleWide( 50 ) )
        field.togglerContainer:Dock( RIGHT )
        field.togglerContainer.PerformLayout = function( panel, w, h )
            local child = panel:GetChild( 0 )
            if ( IsValid( child ) ) then
                child:SetTall( child:GetWide() * .5 )
                child:Center()
            end
        end

        field.toggler = field.togglerContainer:Add('onyx.Toggler')
        field.toggler:SetBackgroundColor( COLOR_TERTIARY )
        field.toggler:SetChecked( convarObject:GetBool(), true )
        field.toggler.OnChange = function( panel, newBool )
            convarObject:SetBool( newBool )
        end
    elseif ( optionType == 'combo' ) then
        local value = convarObject:GetString()
        
        local combo = field:Add( 'onyx.ComboBox' )
        combo:SetWide( onyx.ScaleWide( 175 ) )
        combo:Dock( RIGHT )
        combo.OnSelect = function( panel, index, text, data )
            convarObject:SetString( data )
        end

        for i, opt in ipairs( data.options or {} ) do
            local key = opt.key

            combo:AddOption( opt.name, key )

            if ( key == value ) then
                combo:ChooseOptionID( i )
            end
        end
    elseif ( optionType == 'int' ) then
        local lblValue
        local min = convarObject:GetMin()
        local max = convarObject:GetMax()
        local step = data.step or 5

        local btnAdd = field:Add( 'DButton' )
        btnAdd:SetText( '' )
        btnAdd:SetWide( height )
        btnAdd:Dock( RIGHT )
        btnAdd.Paint = function( panel, w, h )
            draw.RoundedBoxEx( 8, 0, 0, w, h, panel:IsHovered() and COLOR_BUTTON_HOVER or COLOR_TERTIARY, false, true, false, true )
            draw.SimpleText( '+', FONT_BUTTON, w * .5, h * .5, color_white, 1, 1 )
        end
        btnAdd.DoClick = function( panel )
            local newValue = math.floor( math.Clamp( convarObject:GetInt() + step, min, max ) / step ) * step

            surface.PlaySound('onyx/ui/on_click/footfall_click.wav')
            convarObject:SetInt( newValue )
            
            lblValue:SetText( newValue )
        end

        lblValue = field:Add( 'onyx.Label' )
        lblValue:SetWide( onyx.ScaleWide( 50 ) )
        lblValue:SetContentAlignment( 5 )
        lblValue:SetText( convarObject:GetInt() )
        lblValue:Dock( RIGHT )
        lblValue:Font( 'Comfortaa SemiBold@20' )
        lblValue.Paint = function( panel, w, h )
            draw.RoundedBox( 0, 0, 0, w, h, COLOR_PRIMARY )
        end

        local btnDecrease = field:Add( 'DButton' )
        btnDecrease:SetText( '' )
        btnDecrease:SetWide( height )
        btnDecrease:Dock( RIGHT )
        btnDecrease.Paint = function( panel, w, h )
            draw.RoundedBoxEx( 8, 0, 0, w, h, panel:IsHovered() and COLOR_BUTTON_HOVER or COLOR_TERTIARY, true, false, true )
            draw.SimpleText( '-', FONT_BUTTON, w * .5, h * .5, color_white, 1, 1 )
        end
        btnDecrease.DoClick = function( panel )
            local newValue = math.floor( math.Clamp( convarObject:GetInt() - step, min, max ) / step ) * step

            surface.PlaySound('onyx/ui/on_click/footfall_click.wav')
            convarObject:SetInt( newValue )
            
            lblValue:SetText( newValue )
        end
    end
end

function PANEL:CreateField( text, desc )
    local padding = onyx.ScaleTall(7.5)

    local field = self.grid:Add( 'DPanel' )
    field:SetTall( onyx.ScaleTall(45) )
    field:DockPadding( padding, padding, padding, padding )
    field.centerChild = true
    field.padding = padding
    field.Paint = function( p, w, h )
        draw.RoundedBox( 8, 0, 0, w, h, COLOR_SECONDARY )
        draw.SimpleText( text, FONT_NAME, padding, h * .5, COLOR_ACCENT, 0, 4 )
        draw.SimpleText( desc, FONT_DESC, padding, h * .5, COLOR_GRAY, 0, 0 )
    end
    field.PerformLayout = function( panel, w, h )
        local child = panel:GetChild( 0 )
        if ( IsValid( child ) and panel.centerChild ) then
            
        end
    end

    return field
end

onyx.gui.Register( 'onyx.hud.ClientSettings', PANEL )
--addons/onyx_scoreboard/lua/onyx/modules/scoreboard/core/cl_init.lua:
return gluapack()()
--addons/onyx_scoreboard/lua/onyx/modules/scoreboard/cfg/sh_columns.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

03/03/2024

--]]

--[[------------------------------
**WARNING**
This is an advanced config.
Most of the things you need should be configurable through the game.
Do not edit anything if you do not understand what you are doing.
--------------------------------]]

onyx.scoreboard.columns = {}

--[[------------------------------
Default ones
--------------------------------]]
onyx.scoreboard:RegisterColumn('team', {
    getValue = function(client)
        if (onyx.scoreboard.IsTTT()) then
            return select(2, onyx.scoreboard.GetTeamTTT(client))
        end

        return client:Team()
    end,
    formatValue = function(value)
        if (onyx.scoreboard.IsTTT()) then
            return value
        end

        return team.GetName(value)
    end,
    getColor = function(client)
        if (onyx.scoreboard.IsTTT()) then
            return select(3, onyx.scoreboard.GetTeamTTT(client))
        end

        return onyx.scoreboard.ConvertTeamColor(team.GetColor(client:Team()))
    end
})

onyx.scoreboard:RegisterColumn('rank', {
    getValue = function(client)
        local rank = client:GetUserGroup()
        local data = onyx.scoreboard:GetRankData(rank)
        if (data) then
            return data.name
        end
        return rank
    end
})

onyx.scoreboard:RegisterColumn('health', {
    getValue = function(client)
        local health = client:Alive() and client:Health() or -1
        return health
    end,
    formatValue = function(value)
        if (value > 0) then
            return string.Comma(value) .. ' HP'
        else
            return onyx.lang:Get('dead')
        end
    end
})

--[[------------------------------
DarkRP
--------------------------------]]
onyx.scoreboard:RegisterColumn('money', {
    getValue = function(client)
        return (client:getDarkRPVar('money') or 0)
    end,
    formatValue = function(value)
        return DarkRP.formatMoney(value)
    end,
    customCheck = function()
        return DarkRP ~= nil
    end
})

--[[------------------------------
TTT
--------------------------------]]
onyx.scoreboard:RegisterColumn('karma', {
    getValue = function(client)
        return client:GetBaseKarma()
    end,
    formatValue = function(value)
        return string.Comma(math.Round(value))
    end,
    customCheck = function()
        return (engine.ActiveGamemode() == 'terrortown')
    end
})

--[[------------------------------
Custom
--------------------------------]]
do
    local handlers = {
        {
            key = 'GlorifiedLeveling',
            func = function(ply)
                return ply:getLevel()
            end
        },
        {
            key = 'LevelSystemConfiguration',
            func = function(ply)
                -- Vrondakis
                if (ply.getDarkRPVar) then
                    return ply:getDarkRPVar('level')
                end
            end
        },
        {
            key = 'levelup',
            func = function(ply)
                return levelup.getLevel(ply)
            end
        }
    }

    onyx.scoreboard:RegisterColumn('level', {
        getValue = function(client)
            for _, data in ipairs(handlers) do
                if (_G[data.key]) then
                    local value = data.func(client)
                    return (value or 0)
                end
            end
            return 0
        end,
        formatValue = function(level)
            return string.Comma(level)
        end,
        customCheck = function()
            for _, data in ipairs(handlers) do
                if (_G[data.key]) then
                    return true
                end
            end

            return false
        end
    })
end

do
    local handlers = {
        {
            -- SAM
            valid = function()
                return sam ~= nil
            end,
            func = function(ply)
                return ply:sam_get_play_time() -- seconds
            end
        },
        {
            -- Utime
            valid = function()
                return Utime ~= nil
            end,
            func = function(ply)
                return ply:GetUTimeTotalTime()
            end
        }
    }

    onyx.scoreboard:RegisterColumn('playtime', {
        getValue = function(client)
            for _, data in ipairs(handlers) do
                if (data.valid()) then
                    local value = data.func(client)
                    return (value or 0)
                end
            end
            return 0
        end,
        formatValue = function(seconds)
            local minutes = math.Round(seconds / 60)
            local hours = math.Round(minutes / 60)
            if (hours < 1) then
                return string.Comma(minutes) .. 'm'
            else
                return string.Comma(hours) .. 'h'
            end
        end,
        customCheck = function()
            for _, data in ipairs(handlers) do
                if (data.valid()) then
                    return true
                end
            end

            return false
        end
    })
end

-- Ashop
onyx.scoreboard:RegisterColumn('ashop_badges', {
    getValue = function(client)
        local badges = ashop.GetPlayerBadges(client) or {}
        return table.Count(badges)
    end,
    buildFunc = function(columnPanel, ply)
        local badges = ashop.GetPlayerBadges(ply) or {}

        columnPanel.PerformLayout = function(panel, w, h)
            local space = onyx.ScaleTall(5)
            local children = panel:GetChildren()
            local amount = #children
            local size = math.min(h, (w - space * (amount - 1)) / amount)
            local totalWidth = size * amount + space * (amount - 1)
            local x = w * .5 - totalWidth * .5

            for index, child in ipairs(children) do
                if (IsValid(child)) then
                    child:SetSize(size, size)
                    child:SetPos(x, 0)
                    child:CenterVertical()

                    x = x + size + space
                end
            end
        end

        for slot, data in pairs(badges) do
            local badge = vgui.Create("DPanel", columnPanel)
            badge.Paint = function(panel, w, h)
                xpcall(function()
                    local mat = data.mat()
                    if (mat) then
                        surface.SetMaterial(mat)
                        surface.SetDrawColor(color_white)
                        surface.DrawTexturedRect(0, 0, w, h)
                    end
                end, function(errText)
                    onyx.scoreboard:PrintError('(AShop) Error during badge display: #', errText)
                end)
            end
        end
    end,
    customCheck = function()
        return ashop ~= nil
    end
})

-- Brick's Gangs
onyx.scoreboard:RegisterColumn('gang', {
    getValue = function(client)
        local gangID = client:GetGangID()
        local gangName = onyx.scoreboard.GetBricksGangName(gangID)
        return gangName
    end,
    customCheck = function()
        if (BRICKS_SERVER and BRICKS_SERVER.GANGS) then
            return true
        end
        return false
    end
})

-- VoidFactions
onyx.scoreboard:RegisterColumn('faction', {
    getValue = function(client)
        return client:VF_GetFactionName('')
    end,
    getColor = function(client)
        return client:VF_GetFactionColor(color_white)
    end,
    customCheck = function()
        return VoidFactions ~= nil
    end
})
--addons/onyx_scoreboard/lua/onyx/modules/scoreboard/ui/cl_columns_row.lua:
return gluapack()()
--lua/openpermissions/thirdparty/pon.lua:
return gluapack()()
--addons/gmodadminsuite-config/lua/openpermissions_lua_functions.lua:
return gluapack()()
--addons/pcasino/lua/perfectcasino/derma/cl_fonts.lua:
-- This just creates the font. to keep them organised
surface.CreateFont("pCasino.Header.Static", {
	font = "Roboto",
	size = 35,
})
surface.CreateFont("pCasino.Title.Static", {
	font = "Roboto",
	size = 36,
})
surface.CreateFont("pCasino.Entity.Bid", {
	font = "Roboto",
	size = 40,
})
surface.CreateFont("pCasino.Entity.Arrows", {
	font = "Roboto",
	size = 60,
})
surface.CreateFont("pCasino.SubTitle.Static", {
	font = "Roboto",
	size = 24,
})
surface.CreateFont("pCasino.Main.Static", {
	font = "Roboto",
	size = 28,
})
surface.CreateFont("pCasino.Nav.Static", {
	font = "Roboto",
	size = 25,
})
surface.CreateFont("pCasino.Textbox.Static", {
	font = "Roboto",
	size = 20,
	weight = 500,
})
surface.CreateFont("pCasino.Button.Micro", {
	font = "Roboto",
	size = 15,
	weight = 500,
})
--addons/pcasino/lua/perfectcasino/derma/cl_elements.lua:
return gluapack()()
--addons/tablo_ent/lua/scoresheet/sheets/level/config.lua:
return gluapack()()
--addons/tablo_ent/lua/scoresheet/sheets/level/config.lua:
scoresheet.level_header_text = "Top 10 Level" // the header text
scoresheet.level_header_text_color = Color( 64, 184, 231) // the color of the header bg

scoresheet.level_max_count = 10 // how many people does it show?
scoresheet.level_cut_at_row_count = 5 // how many rows of people untill it cuts to a new line? ( 5 seems to be max )

scoresheet.level_first_place_icon = Material( "icon16/coins.png" ) // the icon next to #1 name

scoresheet.level_font_header = "score_row_header" // the font used for the header of the row, # number - name
scoresheet.level_font_text = "score_row_text" // font used for the text of the row, $ money
--addons/tablo_ent/lua/scoresheet/sheets/money/shared.lua:
local SHEET = {}

SHEET.UniqueID = "top_10_moneys"

SHEET.Name = scoresheet.money_header_text
SHEET.EntName = "score_money"
SHEET.HeaderColor = scoresheet.money_header_text_color

SHEET.Fetch = function()
	local data = sql.Query( "SELECT * from score_money ORDER by Money DESC LIMIT "..scoresheet.money_max_count )
	
	if ( !data ) then data = {} end

	return data
end

SHEET.Draw = function( ent, data )
	if ( !DarkRP ) then return end
	
	local y_pos = 20
	
	local x_pos = 0
	local cnt = 0
	
	for place, row in pairs( data ) do
		local row_header = "#"..place.." - "..row.Name
		local row_text = DarkRP.formatMoney( tonumber( row.Money ) )
		
		if ( place == 1 ) then
			surface.SetFont( scoresheet.money_font_header )
			local textW = surface.GetTextSize( row_header )
			
			surface.SetDrawColor( 255, 255, 255 )
			surface.SetMaterial( scoresheet.money_first_place_icon )
			surface.DrawTexturedRect( x_pos + textW + 5, y_pos, 16, 16 )
		end
		
		draw.SimpleText( row_header, scoresheet.money_font_header, x_pos, y_pos, color_white )
		y_pos = y_pos + 20
		
		draw.SimpleText( row_text, scoresheet.money_font_text, x_pos, y_pos, color_white )
		y_pos = y_pos + 25
		
		cnt = cnt + 1
		
		if ( cnt >= scoresheet.money_cut_at_row_count ) then
			x_pos = 250
			y_pos = 20
			cnt = 0
		end
	end
end 

scoresheet:register( SHEET )
--addons/realisticcardealer/lua/autorun/rcd_loader.lua:
local files, directories = file.Find("realistic_cardealer/languages/*", "LUA")
for k,v in ipairs(files) do
    include("realistic_cardealer/languages/"..v)
end

include("realistic_cardealer/sh_config.lua")

include("realistic_cardealer/sh_materials.lua")
include("realistic_cardealer/shared/sh_functions.lua")
include("realistic_cardealer/sh_advanced_config.lua")

  local SERVER = SERVER
 local CLIENT = CLIENT
if SERVER then
    AddCSLuaFile("realistic_cardealer/sh_config.lua")
    AddCSLuaFile("realistic_cardealer/sh_materials.lua")
    AddCSLuaFile("realistic_cardealer/shared/sh_functions.lua")
    AddCSLuaFile("realistic_cardealer/sh_advanced_config.lua")
    
    for k,v in ipairs(files) do
        AddCSLuaFile("realistic_cardealer/languages/"..v)
    end
    
    include("realistic_cardealer/sv_sql.lua")
    include("realistic_cardealer/server/sv_core.lua")
    include("realistic_cardealer/server/sv_admin.lua")
    include("realistic_cardealer/server/sv_accident.lua")
    include("realistic_cardealer/server/sv_customization.lua")
    include("realistic_cardealer/server/sv_dealer.lua")
    include("realistic_cardealer/server/sv_job.lua")
    include("realistic_cardealer/server/sv_compatibilities.lua")
    include("realistic_cardealer/server/sv_hooks.lua")
    include("realistic_cardealer/server/sv_nets.lua")

    AddCSLuaFile("realistic_cardealer/client/cl_fonts.lua")
    AddCSLuaFile("realistic_cardealer/client/cl_functions.lua")
    AddCSLuaFile("realistic_cardealer/client/cl_dealer.lua")
    AddCSLuaFile("realistic_cardealer/client/cl_admin.lua")
    AddCSLuaFile("realistic_cardealer/client/cl_notify.lua")
    AddCSLuaFile("realistic_cardealer/client/cl_speedometers.lua")
    AddCSLuaFile("realistic_cardealer/client/cl_job.lua")
    AddCSLuaFile("realistic_cardealer/client/cl_3d2d_lib.lua")

    AddCSLuaFile("realistic_cardealer/vgui/cl_button.lua")
    AddCSLuaFile("realistic_cardealer/vgui/cl_toggle.lua")
    AddCSLuaFile("realistic_cardealer/vgui/cl_dmodel.lua")
    AddCSLuaFile("realistic_cardealer/vgui/cl_slider_button.lua")
    AddCSLuaFile("realistic_cardealer/vgui/cl_slider_vehc.lua")
    AddCSLuaFile("realistic_cardealer/vgui/cl_colormixer.lua")
    AddCSLuaFile("realistic_cardealer/vgui/cl_vehicle_button.lua")
    AddCSLuaFile("realistic_cardealer/vgui/cl_checkbox.lua")
    AddCSLuaFile("realistic_cardealer/vgui/cl_dscroll.lua")
    AddCSLuaFile("realistic_cardealer/vgui/cl_dtextentry.lua")
    AddCSLuaFile("realistic_cardealer/vgui/cl_dcombobox.lua")
    AddCSLuaFile("realistic_cardealer/vgui/cl_accordion.lua")
    AddCSLuaFile("realistic_cardealer/vgui/cl_slider.lua")
    AddCSLuaFile("realistic_cardealer/vgui/cl_circular_avatar.lua")
else
    include("realistic_cardealer/client/cl_fonts.lua")
    include("realistic_cardealer/client/cl_functions.lua")
    include("realistic_cardealer/client/cl_dealer.lua")
    include("realistic_cardealer/client/cl_admin.lua")
    include("realistic_cardealer/client/cl_notify.lua")
    include("realistic_cardealer/client/cl_speedometers.lua")
    include("realistic_cardealer/client/cl_job.lua")
    include("realistic_cardealer/client/cl_3d2d_lib.lua")
    
    include("realistic_cardealer/vgui/cl_button.lua")
    include("realistic_cardealer/vgui/cl_toggle.lua")
    include("realistic_cardealer/vgui/cl_dmodel.lua")
    include("realistic_cardealer/vgui/cl_slider_button.lua")
    include("realistic_cardealer/vgui/cl_slider_vehc.lua")
    include("realistic_cardealer/vgui/cl_colormixer.lua")
    include("realistic_cardealer/vgui/cl_vehicle_button.lua")
    include("realistic_cardealer/vgui/cl_checkbox.lua")
    include("realistic_cardealer/vgui/cl_dscroll.lua")
    include("realistic_cardealer/vgui/cl_dtextentry.lua")
    include("realistic_cardealer/vgui/cl_dcombobox.lua")
    include("realistic_cardealer/vgui/cl_accordion.lua")
    include("realistic_cardealer/vgui/cl_slider.lua")
    include("realistic_cardealer/vgui/cl_circular_avatar.lua")
end
--addons/realisticcardealer/lua/realistic_cardealer/vgui/cl_slider.lua:
return gluapack()()
--addons/bb_isimeklentisi/lua/rpname_enforcer/sh_config.lua:
EnforcerConfig = EnforcerConfig or {}

EnforcerConfig.CommunityName = "Venom RP" -- Name of your community
EnforcerConfig.Title = "Sunucumuza Hoşgeldin!" -- Title top text
EnforcerConfig.DoneButton = "Tamam" -- "Tamam" butonundaki metin
EnforcerConfig.EnterNameLabel = "Aşağıya karakteriniz için bir isim soyisim girmeniz gerekmektedir." -- Ne yapılacağına dair açıklama
EnforcerConfig.EnterFirstNameLabel = "İsim:" -- "İsim" alanını tanımlayan etiket
EnforcerConfig.FirstNameTextEntry = "İsim" -- "İsim" kutusunda görünen varsayılan metin
EnforcerConfig.EnterLastNameLabel = "Soyad:" -- "Soyad" alanını tanımlayan etiket
EnforcerConfig.LastNameTextEntry = "Soyad" -- "Soyad" kutusunda görünen varsayılan metin

EnforcerConfig.FirstNameMaxChars = 12 -- Maximum lenght of First Name
EnforcerConfig.LastNameMaxChars = 12 -- Maximum lenght of Last Name
EnforcerConfig.AllowNumbers = false -- Should numbers be allowed

EnforcerConfig.ShowCloseButton = false -- Should there be a close button to close the enforcer

EnforcerConfig.AllowBlacklist = true -- allows blacklist
EnforcerConfig.Blacklist = {"anus","dick", "mg", "MG"} -- words that are on the blacklist

EnforcerConfig.AllowPrefix = false -- Should there be a prefix in front of the name something like "CP John Deedman"
EnforcerConfig.Prefix = "" -- The prefix

--lua/autorun/rppropsextanded_init.lua:
local cvar = CreateConVar("rppropsex_hide", -1, {FCVAR_ARCHIVE, FCVAR_REPLICATED}, "Show Roleplay Props Extended in the spawnmenu")

if SERVER then

	if (cvar:GetInt() == -1) then -- Default convars don't seem to be sent to clients
		cvar:SetInt(0)
	end

else

	local models = {
		["Living Room"] = {
			"models/U4Lab/tv_monitor_plasma.mdl",
			"models/gmod_tower/suitetv.mdl",
			"models/scenery/furniture/coffeetable1/vestbl.mdl",
			"models/props_interiors/chairlobby01.mdl",
			"models/props_warehouse/office_furniture_couch.mdl",
			"models/props_vtmb/armchair.mdl",
			"models/props_vtmb/sofa.mdl",
			"models/props_interiors/sofa01.mdl",
			"models/props_interiors/sofa02.mdl",
			"models/props_interiors/sofa_chair02.mdl",
			"models/props_interiors/ottoman01.mdl",
			"models/env/furniture/decosofa_wood/decosofa_wood_dou.mdl",
			"models/Highrise/lobby_chair_01.mdl",
			"models/Highrise/lobby_chair_02.mdl",
			"models/props_interiors/desk_motel.mdl",
			"models/props_furniture/piano.mdl",
			"models/props_furniture/piano_bench.mdl",
			"models/props_interiors/painting_landscape01.mdl",
			"models/props_interiors/painting_portrait01.mdl",
			"models/props_furniture/picture_frame8.mdl",
			"models/props_urban/hotel_curtain001.mdl",
			"models/props_plants/plantairport01.mdl",
			"models/Highrise/potted_plant_05.mdl",
			"models/env/decor/tall_plant_b/tall_plant_b.mdl",
			"models/env/decor/plant_decofern/plant_decofern.mdl",
			"models/sunabouzu/theater_table.mdl",
			"models/testmodels/apple_display.mdl",
			"models/testmodels/coffee_table_long.mdl",
			"models/testmodels/macbook_pro.mdl",
			"models/testmodels/sofa_double.mdl",
			"models/testmodels/sofa_single.mdl",
			"models/splayn/rp/lr/chair.mdl",
			"models/splayn/rp/lr/couch.mdl",
			"models/props/slow/glass_table_low/slow_glass_table_low.mdl",
			"models/sunabouzu/lobby_chair.mdl",
			"models/sunabouzu/lobby_poster.mdl",
			"models/sunabouzu/lobby_poster_small.mdl",
			"models/props/cs_office/table_coffee.mdl",
			"models/props/cs_office/sofa.mdl",
			"models/props/cs_office/sofa_chair.mdl",
			"models/props/de_tides/patio_chair.mdl",
			"models/chairs/armchair.mdl",
			"models/props/cs_militia/couch.mdl",
			"models/props/de_inferno/tableantique.mdl",
			
			},
		["Kitchen"] = {
			"models/props_interiors/refrigerator03.mdl",
			"models/sickness/fridge_01.mdl",
			"models/sickness/stove_01.mdl",
			"models/props_interiors/sink_kitchen.mdl",
			"models/props_interiors/coffee_maker.mdl",
			"models/props_interiors/chair01.mdl",
			"models/props_interiors/chair_cafeteria.mdl",
			"models/props_interiors/dining_table_round.mdl",
			"models/props_interiors/dinning_table_oval.mdl",
			"models/props_interiors/trashcankitchen01.mdl",
			"models/props_unique/showercurtain01.mdl",
			"models/props/cs_office/microwave.mdl",
			},
		["Bathroom"] = {
			"models/env/furniture/wc_double_cupboard/wc_double_cupboard.mdl",
			"models/env/furniture/square_sink/sink_double.mdl",
			"models/env/furniture/square_sink/sink_merged_b.mdl",
			"models/env/furniture/showerbase/showerbase.mdl",
			"models/env/furniture/shower/shower.mdl",
			"models/props_interiors/bathtub01.mdl",
			"models/env/furniture/ensuite1_toilet/ensuite1_toilet.mdl",
			"models/env/furniture/ensuite1_toilet/ensuite1_toilet_b.mdl",
			"models/env/furniture/ensuite1_sink/ensuite1_sink.mdl",
			"models/props_interiors/soap_dispenser.mdl",
			"models/props_interiors/toiletpaperdispenser_residential.mdl",
			"models/props_interiors/toiletpaperroll.mdl",
			"models/env/furniture/ensuite1_bath/ensuite1_bath.mdl",
			"models/props_interiors/urinal01.mdl",
			},
		["Bedroom"] = {
			"models/props_interiors/bed_motel.mdl",
			"models/props_downtown/bed_motel01.mdl",
			"models/env/furniture/bed_secondclass/beddouble_group.mdl",
			"models/env/furniture/bed_andrea/bed_andrea_1st.mdl",
			"models/props_interiors/side_table_square.mdl",
			"models/env/furniture/bed_naronic/bed_naronic_1st.mdl",
		},
		["Office"] = {
			"models/U4Lab/chair_office_a.mdl",
			"models/U4Lab/desk_office_a.mdl",
			"models/props_warehouse/office_furniture_coffee_table.mdl",
			"models/props_warehouse/office_furniture_desk.mdl",
			"models/props_warehouse/office_furniture_desk_corner.mdl",
			"models/props_office/desk_01.mdl",
			"models/props_interiors/desk_executive.mdl",
			"models/env/furniture/largedesk/largedesk.mdl",
			"models/props_office/file_cabinet_03.mdl",
			"models/Highrise/cubicle_monitor_01.mdl",
			"models/props_interiors/copymachine01.mdl",
			"models/props_interiors/printer.mdl",
			"models/props_interiors/paper_tray.mdl",
			"models/props_interiors/water_cooler.mdl",
			"models/props_interiors/corkboardverticle01.mdl",
			"models/props_interiors/magazine_rack.mdl",	
			"models/props/cs_office/chair_office.mdl",
			"models/props/cs_office/computer.mdl",
			"models/props_interiors/chair_office2.mdl",
			"models/props_interiors/chair_thonet.mdl",
			"models/props_interiors/closet_clothes.mdl",
			"models/props/cs_office/trash_can_p.mdl",
			"models/props/cs_office/table_meeting.mdl",
			"models/props/cs_office/file_box.mdl",
			"models/props/cs_office/offcorkboarda.mdl",
			},
		["Outdoors"] = {
			"models/props_unique/spawn_apartment/coffeeammo.mdl",
			"models/props_downtown/sign_donotenter.mdl",
			"models/props_waterfront/awning01.mdl",
			"models/props_c17/awning001a.mdl",
			"models/props_c17/awning002a.mdl",
			"models/props_street/awning_department_store.mdl",
			"models/props/de_tides/planter.mdl",
			"models/props_urban/bench001.mdl",
			"models/props_interiors/table_picnic.mdl",
			"models/props_urban/plastic_chair001.mdl",
			"models/props_interiors/patio_chair2_white.mdl",
			"models/props/de_tides/patio_chair2.mdl",
			"models/props/de_tides/patio_table2.mdl",
			"models/env/furniture/pool_recliner/pool_recliner.mdl",
			"models/props/de_piranesi/pi_bench.mdl",
			"models/props/de_piranesi/pi_sundial.mdl",
			"models/props/de_inferno/bench_concrete.mdl",
			"models/props/de_inferno/fountain.mdl",
			"models/props/de_inferno/lattice.mdl",
			"models/props_unique/firepit_campground.mdl",
			"models/props_equipment/sleeping_bag1.mdl",
			"models/props_equipment/sleeping_bag2.mdl",
			"models/props_urban/outhouse001.mdl",
			"models/props_junk/trashcluster01a_corner.mdl",
			"models/trees/pi_tree1.mdl",
			"models/trees/pi_tree3.mdl",
			"models/trees/pi_tree4.mdl",
			"models/trees/pi_tree5.mdl",
			"models/gm_forest/tree_alder.mdl",
			"models/props_foliage/r_maple1.mdl",
			"models/props_foliage/maple_001_l.mdl",
			"models/props_foliage/tree_springers_01a.mdl",
			"models/props/cs_militia/tree_large_militia.mdl",
			"models/sickness/parkinglotlight.mdl",
			"models/props_junk/dumpster.mdl",
			"models/props/de_inferno/bench_wood.mdl",
			"models/props_silo/camera.mdl",
			"models/props/cs_italy/it_mkt_table3.mdl",
			"models/props/cs_militia/table_shed.mdl",
			"models/props/cs_militia/table_kitchen.mdl",
			"models/props/cs_militia/logpile2.mdl",
			"models/props/cs_militia/bar01.mdl",
			"models/props/cs_militia/barstool01.mdl",
			"models/props/de_piranesi/pi_orrery.mdl",
			"models/props/de_tides/tides_streetlight.mdl",
			"models/natalya/furniture/patio_table.mdl",
			"models/props/de_tides/vending_cart.mdl",
			},
		["Commercial"] = {
			"models/props_equipment/phone_booth.mdl",
			"models/Highrise/trashcanashtray_01.mdl",
			"models/Highrise/trash_can_03.mdl",
			"models/props_interiors/trashcan01.mdl",
			"models/props_interiors/cashregister01.mdl",
			"models/props_interiors/magazine_rack.mdl",
			"models/props_interiors/shelvinggrocery01.mdl",
			"models/props_interiors/shelvingstore01.mdl",
			"models/props_equipment/fountain_drinks.mdl",
			"models/props_downtown/bar_long.mdl",
			"models/props_downtown/bar_long_endcorner.mdl",
			"models/scenery/structural/vesuvius/bartap.mdl",
			"models/env/furniture/bstoolred/bstoolred.mdl",
			"models/props_furniture/cafe_barstool1.mdl",
			"models/props_downtown/pooltable.mdl",
			"models/de_vegas/card_table.mdl",
			"models/props_equipment/security_desk1.mdl",
			"models/sickness/bk_booth2.mdl",
			"models/props_downtown/booth01.mdl",
			"models/props_downtown/booth02.mdl",
			"models/props_downtown/booth_table.mdl",
			"models/props_interiors/table_cafeteria.mdl",
			"models/props_warehouse/table_01.mdl",
			"models/props_interiors/chairs_airport.mdl",
			"models/props_warehouse/toolbox.mdl",
			"models/props_vtmb/turntable.mdl",
			"models/props_unique/wheelchair01.mdl",
			"models/props_unique/hospital/exam_table.mdl",
			"models/props_unique/hospital/gurney.mdl",
			"models/props_equipment/surgicaltray_01.mdl",
			"models/props_unique/hospital/hospital_bed.mdl",
			"models/props_unique/hospital/iv_pole.mdl",
			"models/props_unique/hospital/surgery_lamp.mdl",
			"models/props_interiors/medicalcabinet02.mdl",
			"models/props/slow/glass_table_high/slow_glass_table_high.mdl",
			"models/props/slow/hocker/slow_hocker.mdl",
			"models/pg_props/pg_hospital/pg_optable.mdl",
			"models/props_equipment/snack_machine.mdl",
			"models/env/decor/gents_display/gents_display.mdl",
			"models/env/decor/vous_display/vous_display.mdl",
			"models/maxib123/pooltable.mdl",
			"models/props_interiors/phone.mdl",
			"models/props_unique/coffeemachine01.mdl",
			"models/props/cs_office/tv_plasma.mdl",
			"models/props/cs_office/bookshelf1.mdl",
			"models/props/de_tides/menu_stand.mdl",
		},
		["Industrial"] = {
			"models/props_industrial/warehouse_shelf001.mdl",
			"models/props_industrial/warehouse_shelf002.mdl",
			"models/props_industrial/warehouse_shelf003.mdl",
			"models/props_industrial/warehouse_shelf004.mdl",
			"models/props/cs_assault/moneypallete.mdl",
			"models/props/cs_assault/moneypallet03.mdl",
			"models/props/cs_assault/handtruck.mdl",
			"models/props/cs_assault/forklift.mdl",
			"models/props/cs_office/paperbox_pile_01.mdl",
			"models/props/cs_office/cardboard_box03.mdl",
			"models/props/de_dust/stoneblock01a.mdl",
		},
		["Lighting"] = {
			"models/props_unique/spawn_apartment/lantern.mdl",	
			"models/env/lighting/lamp_trumpet/lamp_trumpet_tall.mdl",
			"models/env/lighting/jelly_lamp/jellylamp.mdl",
			"models/env/lighting/corridor_ceil_lamp/corridor_ceil_lamp.mdl",
			"models/env/lighting/corridorlamp/corridorlamp.mdl",
			"models/props_urban/light_fixture01.mdl",
			"models/Highrise/tall_lamp_01.mdl",
			"models/U4Lab/track_lighting_a.mdl",
			"models/Highrise/sconce_01.mdl",
			"models/wilderness/lamp6.mdl",
			"models/props_interiors/lamp_table02.mdl",	
			"models/env/lighting/dance_spots/dance_spots.mdl",
			"models/props/cs_assault/light_shop2.mdl",
		},
		["Paintings"] = {
			"models/props/cs_office/offinspa.mdl",
			"models/props/cs_office/offinspb.mdl",
			"models/props/cs_office/offinspc.mdl",
			"models/props/cs_office/offinspd.mdl",
			"models/props/cs_office/offinspf.mdl",
			"models/props/cs_office/offinspg.mdl",
			"models/props/cs_office/offpaintinga.mdl",
			"models/props/cs_office/offpaintingb.mdl",
			"models/props/cs_office/offpaintingd.mdl",
			"models/props/cs_office/offpaintinge.mdl",
			"models/props/cs_office/offpaintingf.mdl",
			"models/props/cs_office/offpaintingg.mdl",
			"models/props/cs_office/offpaintingh.mdl",
			"models/props/cs_office/offpaintingi.mdl",
			"models/props/cs_office/offpaintingj.mdl",
			"models/props/cs_office/offpaintingk.mdl",
			"models/props/cs_office/offpaintingl.mdl",
			"models/props/cs_office/offpaintingm.mdl",
			"models/props/cs_office/offpaintingo.mdl",
		},
	}


	hook.Add("PopulateContent", "RoleplayPropsExtended", function(pnlContent, tree)
	
		local cvar = GetConVar("rppropsex_hide")
		if cvar and (cvar:GetInt() == 1) then return end -- The server doesn't want it in the client spawn menu

		local RootNode = tree:AddNode("Roleplay Props Extended", "icon16/rpprops.png")

		local ViewPanel = vgui.Create("ContentContainer", pnlContent)
		ViewPanel:SetVisible(false)
		
		RootNode.DoClick = function()
		
			ViewPanel:Clear(true)
			
			for name, tbl in SortedPairs(models) do
			
				local label = vgui.Create("ContentHeader", container)
				label:SetText(name)

				ViewPanel:Add(label)
			
				for _, v in ipairs(tbl) do
				
					local mdlicon = spawnmenu.GetContentType("model")
					if mdlicon then
						mdlicon(ViewPanel, {model = v})
					end

				end
				
			end
			
			pnlContent:SwitchPanel(ViewPanel)
			
		end

	end)
	
end

--addons/rsc/lua/rsc/classes/promise.lua:
return gluapack()()
--addons/rsc/lua/rsc/classes/service.lua:
local RSC = RSC
local setmetatable = setmetatable
local tostring = tostring
local promise = RSC.promise
local pairs = pairs

RSC.RECOMMENDED_SERVICE = "gmod.express"

-- Transfer service
RSC.Service = RSC.Service or {}
local Service = RSC.Service

Service.Services = Service.Services or {}

-- Metatable for service class
Service.SERVICE = Service.SERVICE or {}
local SERVICE = Service.SERVICE
SERVICE.__index = SERVICE

function SERVICE:GetName() return tostring(self.name) end
function SERVICE:GetDownloadURL(data, prepareData) return data end -- Can be async

function SERVICE:Ping() -- Must be async
    return promise.Resolve(true)
end

function SERVICE:Prepare() -- Must be async
    return promise.Resolve()
end

function SERVICE:Upload(data, quality, prepareData) -- Must be async
    return promise.Reject("#rsc.errors.not_implemented")
end

function SERVICE:Download(uploadData, quality, prepareData) -- Must be async
    return promise.Reject("#rsc.errors.not_implemented")
end

function SERVICE:Register()
    Service.Services[ self:GetName() ] = self
end

-- Constructs a new service with specified name
function Service.New(name)
    return setmetatable({ name = name }, SERVICE)
end

-- Gets registered service by name
function Service.Get(name)
    return Service.Services[tostring(name)]
end

-- Returnes service with fastest ping
function Service.FindFastest()
    local result = promise.New()

    local onFulfill = function(service)
        if service and result:IsPending() then result:Resolve(service) end
    end

    -- Timeout if we won't get any service in time
    local timeout = promise.Delay(5):Then(function() return promise.Reject("#rsc.ui.timeout") end)
    result:Resolve(timeout)

    for _, service in pairs(Service.Services) do
        service:Ping():Then(function(ok) return ok and service end):Then(onFulfill)
    end

    return result
end

--lua/autorun/rust_nomad_pm.lua:
player_manager.AddValidModel( "Rust Nomad Suit", "models/player/darky_m/rust/nomad.mdl" )
list.Set( "PlayerOptionsModel", "Rust Nomad Suit", "models/player/darky_m/rust/nomad.mdl" )
player_manager.AddValidHands( "Rust Nomad Suit", "models/player/darky_m/rust/nomad_arms.mdl", 0, "00000000" )
--addons/sam-159/lua/autorun/sam.lua:
if SAM_LOADED then return end

local version = tonumber("159") or 159

sam = {}
sam.config = {}
sam.language = {}
sam.player = {}
sam.ranks = {}
sam.permissions = {}
sam.author = "Srlion"
sam.version = version

function sam.print(...)
	MsgC(
		Color(236, 240, 241), "(",
		Color(244, 67, 54), "SAM",
		Color(236, 240, 241), ") ",
		Color(236, 240, 241), ...
	) Msg("\n")
end

local FAILED = false
do
	local types = {
		sv_ = SERVER and include or function() end,
		cl_ = SERVER and AddCSLuaFile or include,
		sh_ = function(name)
			if SERVER then
				AddCSLuaFile(name)
			end
			return include(name)
		end
	}

	sam.load_file = function(name, type)
		if FAILED then return end

		if type and not type:EndsWith("_") then
			type = type .. "_"
		end

		local func = types[type] or types[name:GetFileFromFilename():sub(1, 3)] or types["sh_"]
		if func then
			local rets = {func(name)}
			if rets[1] == false then
				FAILED = true
				sam.print("Failed to load!")
			end
			return unpack(rets)
		end
	end
end
local load_file = sam.load_file

sam.print("Loading...")

load_file("sam/libs/sh_types.lua")
load_file("sam/libs/sh_pon.lua")
load_file("sam/libs/sh_mp.lua")

do
	local IsValid = IsValid
	local OLD_Player = Player

	-- this is because sam sends players' ids to the client, so if a player disconnects while net message is being sent
	-- the client will not know the player's name
	if CLIENT then
		local players = {}

		local Name = function(s)
			return s.name
		end

		local not_valid = function() return false end

		Player = function(id)
			local ply = OLD_Player(id)

			if not IsValid(ply) then
				local name = players[id]
				if name then
					return {
						name = name,
						Name = Name,
						IsValid = not_valid
					}
				end
			end

			return ply
		end

		hook.Add("OnEntityCreated", "SAM.GetPlayerName", function(ent)
			if ent:IsPlayer() and ent:IsValid() then
				ent.sam_userid = ent:UserID() -- userid is -1 in EntityRemoved?????
			end
		end)

		hook.Add("EntityRemoved", "SAM.GetPlayerName", function(ent)
			if not ent:IsPlayer() then return end

			local id = ent.sam_userid
			if not id then return end

			players[id] = ent:Name()

			timer.Simple(60, function()
				if not IsValid(ent) then
					players[id] = nil
				end
			end)
		end)
	end

	local sfs = load_file("sam/libs/sh_sfs.lua")
	sam.sfs = sfs

	local Encoder = sfs.Encoder
	local chars = sfs.chars
	local write = Encoder.write

	local CONSOLE
	CONSOLE = sfs.add_encoder("console", function(buf, color)
		write(buf, chars[CONSOLE])
	end)

	sfs.add_decoder(CONSOLE, function(ctx)
		ctx[1] = ctx[1] + 1
		return sam.console
	end)

	sfs.set_type_function(sam.type)

	Player = OLD_Player
end

load_file("sam/libs/sh_netstream.lua")
load_file("sam/libs/sh_async_netstream.lua")
load_file("sam/libs/sh_globals.lua")
load_file("sam/libs/sql/sv_init.lua")
sam.Promise = load_file("sam/libs/sh_promises.lua")

load_file("sam/sh_colors.lua")

load_file("sam/sh_util.lua")
load_file("sam/sh_lang.lua")
load_file("sam/sv_sql.lua")
load_file("sam/sh_permissions.lua")

load_file("sam/ranks/sh_ranks.lua")
load_file("sam/ranks/sv_ranks.lua")

load_file("sam/config/sh_config.lua")
load_file("sam/config/sv_config.lua")
load_file("sam/config/cl_config.lua")

load_file("sam/player/sh_player.lua")
load_file("sam/player/sh_nw_vars.lua")
load_file("sam/player/sv_player.lua")
load_file("sam/player/cl_player.lua")
load_file("sam/player/sv_ranks.lua")
load_file("sam/player/sv_auth.lua")
load_file("sam/player/sv_bans.lua")

load_file("sam/command/sh_command.lua")
load_file("sam/command/sv_command.lua")
load_file("sam/command/cl_command.lua")

for _, f in ipairs(file.Find("sam/command/arguments/*.lua", "LUA")) do
	load_file("sam/command/arguments/" .. f, "sh")
end

load_file("sam/sh_restrictions.lua")

load_file("sam/menu/sh_init.lua")
load_file("sam/menu/cl_init.lua")

load_file("sam/sh_motd.lua")

local modules = file.Find("sam/modules/*.lua", "LUA")
for _, module in ipairs(modules) do
	load_file("sam/modules/" .. module)
end

load_file("sam/reports/cl_reports.lua")
load_file("sam/reports/sv_reports.lua")

do
	if SERVER then
		hook.Add("SAM.LoadedConfig", "SAM.AdvertsMain", function(config)
			if not config.Adverts or not istable(config.Adverts) then
				sam.config.set("Adverts", {})
			end
		end)
	end
	load_file("sam/cl_adverts.lua")
end

if not FAILED then
	sam.print("Loaded!")
end

if SERVER then
	local path = "sam/importers/"

	concommand.Add("sam_import", function(ply, _, args)
		if IsValid(ply) then return end

		local admin_mod = args[1]
		if not admin_mod then
			sam.print("You need to provide an admin mod to import!")
			return
		end

		if not file.Exists(path .. admin_mod, "LUA") then
			sam.print("There is no importer for '" .. admin_mod .. "'")
			return
		end

		CompileFile(path .. admin_mod .. "/main.lua")()
	end, nil, nil, FCVAR_PROTECTED)
end

SAM_LOADED = true

--addons/sam-159/lua/sam/libs/sh_pon.lua:
if SAM_LOADED then return end

--[[

DEVELOPMENTAL VERSION;

VERSION 1.2.2
Copyright thelastpenguin™

	You may use this for any purpose as long as:
	-	You don't remove this copyright notice.
	-	You don't claim this to be your own.
	-	You properly credit the author, thelastpenguin™, if you publish your work based on (and/or using) this.

	If you modify the code for any purpose, the above still applies to the modified code.

	The author is not held responsible for any damages incured from the use of pon, you use it at your own risk.

DATA TYPES SUPPORTED:
 - tables  -		 k,v - pointers
 - strings -		 k,v - pointers
 - numbers -		k,v
 - booleans-		 k,v

 - Vectors -		 k,v
 - Angles  -		k,v
 - Entities-		 k,v
 - Players -		 k,v

CHANGE LOG
V 1.1.0
 - Added Vehicle, NPC, NextBot, Player, Weapon
V 1.2.0
 - Added custom handling for k,v tables without any array component.
V 1.2.1
 - fixed deserialization bug.

THANKS TO...
 - VERCAS for the inspiration.
]]
local pon = {}
sam.pon = pon

do
	local type = sam.type
	local IsColor = IsColor
	local tonumber = tonumber
	local format = string.format
	local encode = {}
	local cacheSize = 0

	encode['table'] = function(self, tbl, output, cache)
		if cache[tbl] then
			output[#output + 1] = format('(%x)', cache[tbl])

			return
		else
			cacheSize = cacheSize + 1
			cache[tbl] = cacheSize
		end

		local first = next(tbl, nil)
		local predictedNumeric = 1

		-- starts with a numeric dealio
		if first == 1 then
			output[#output + 1] = '{'

			for k, v in next, tbl do
				if k == predictedNumeric then
					predictedNumeric = predictedNumeric + 1
					local tv = type(v)

					if tv == 'string' then
						local pid = cache[v]

						if pid then
							output[#output + 1] = format('(%x)', pid)
						else
							cacheSize = cacheSize + 1
							cache[v] = cacheSize
							self.string(self, v, output, cache)
						end
					elseif IsColor(v) then
						self.Color(self, v, output, cache)
					else
						self[tv](self, v, output, cache)
					end
				else
					break
				end
			end

			predictedNumeric = predictedNumeric - 1
		else
			predictedNumeric = nil
		end

		if predictedNumeric == nil then
			output[#output + 1] = '[' -- no array component
		else
			output[#output + 1] = '~' -- array component came first so shit needs to happen
		end

		for k, v in next, tbl, predictedNumeric do
			local tk, tv = type(k), type(v)
			if not self[tk] or not self[tv] then continue end

			-- WRITE KEY
			if tk == 'string' then
				local pid = cache[k]

				if pid then
					output[#output + 1] = format('(%x)', pid)
				else
					cacheSize = cacheSize + 1
					cache[k] = cacheSize
					self.string(self, k, output, cache)
				end
			elseif IsColor(v) then
				self.Color(self, v, output, cache)
			else
				self[tk](self, k, output, cache)
			end

			-- WRITE VALUE
			if tv == 'string' then
				local pid = cache[v]

				if pid then
					output[#output + 1] = format('(%x)', pid)
				else
					cacheSize = cacheSize + 1
					cache[v] = cacheSize
					self.string(self, v, output, cache)
				end
			elseif IsColor(v) then
				self.Color(self, v, output, cache)
			else
				self[tv](self, v, output, cache)
			end
		end

		output[#output + 1] = '}'
	end

	--	ENCODE STRING
	local gsub = string.gsub

	encode['string'] = function(self, str, output)
		--if tryCache(str, output then return end
		local estr, count = gsub(str, ';', "\\;")

		if count == 0 then
			output[#output + 1] = '\'' .. str .. ';'
		else
			output[#output + 1] = '"' .. estr .. '";'
		end
	end

	--	ENCODE NUMBER
	encode['number'] = function(self, num, output)
		if num % 1 == 0 then
			if num < 0 then
				output[#output + 1] = format('x%x;', -num)
			else
				output[#output + 1] = format('X%x;', num)
			end
		else
			output[#output + 1] = tonumber(num) .. ';'
		end
	end

	--	ENCODE BOOLEAN
	encode['boolean'] = function(self, val, output)
		output[#output + 1] = val and 't' or 'f'
	end

	--	ENCODE VECTOR
	encode['Vector'] = function(self, val, output)
		output[#output + 1] = ('v' .. val.x .. ',' .. val.y) .. (',' .. val.z .. ';')
	end

	--	ENCODE ANGLE
	encode['Angle'] = function(self, val, output)
		output[#output + 1] = ('a' .. val.p .. ',' .. val.y) .. (',' .. val.r .. ';')
	end

	encode['Entity'] = function(self, val, output)
		output[#output + 1] = 'E' .. (IsValid(val) and (val:EntIndex() .. ';') or '#')
	end

	encode['Player'] = encode['Entity']
	encode['Vehicle'] = encode['Entity']
	encode['Weapon'] = encode['Entity']
	encode['NPC'] = encode['Entity']
	encode['NextBot'] = encode['Entity']
	encode['PhysObj'] = encode['Entity']

	encode['Color'] = function(self, val, output)
		output[#output + 1] = ('C' .. val.r .. ',' .. val.g .. ',' .. val.b) .. (',' .. val.a .. ';')
	end

	encode['console'] = function(self, val, output)
		output[#output + 1] = 's'
	end

	encode['nil'] = function(self, val, output)
		output[#output + 1] = '?'
	end

	encode.__index = function(key)
		ErrorNoHalt('Type: ' .. key .. ' can not be encoded. Encoded as as pass-over value.')

		return encode['nil']
	end

	do
		local concat = table.concat

		function pon.encode(tbl)
			local output = {nil, nil, nil, nil, nil, nil, nil, nil}
			cacheSize = 0
			encode['table'](encode, tbl, output, {})

			return concat(output)
		end
	end
end

do
	local tonumber = tonumber
	local find, sub, gsub, Explode = string.find, string.sub, string.gsub, string.Explode
	local Vector, Angle, Entity = Vector, Angle, Entity
	local decode = {}

	decode['{'] = function(self, index, str, cache)
		local cur = {}
		cache[#cache + 1] = cur
		local k, v, tk, tv = 1, nil, nil, nil

		while (true) do
			tv = sub(str, index, index)

			if not tv or tv == '~' then
				index = index + 1
				break
			end

			if tv == '}' then return index + 1, cur end
			-- READ THE VALUE
			index = index + 1
			index, v = self[tv](self, index, str, cache)
			cur[k] = v
			k = k + 1
		end

		while (true) do
			tk = sub(str, index, index)

			if not tk or tk == '}' then
				index = index + 1
				break
			end

			-- READ THE KEY
			index = index + 1
			index, k = self[tk](self, index, str, cache)
			-- READ THE VALUE
			tv = sub(str, index, index)
			index = index + 1
			index, v = self[tv](self, index, str, cache)
			cur[k] = v
		end

		return index, cur
	end

	decode['['] = function(self, index, str, cache)
		local cur = {}
		cache[#cache + 1] = cur
		local k, v, tk, tv = 1, nil, nil, nil

		while (true) do
			tk = sub(str, index, index)

			if not tk or tk == '}' then
				index = index + 1
				break
			end

			-- READ THE KEY
			index = index + 1
			index, k = self[tk](self, index, str, cache)
			if not k then continue end
			-- READ THE VALUE
			tv = sub(str, index, index)
			index = index + 1

			if not self[tv] then
				print('did not find type: ' .. tv)
			end

			index, v = self[tv](self, index, str, cache)
			cur[k] = v
		end

		return index, cur
	end

	-- STRING
	decode['"'] = function(self, index, str, cache)
		local finish = find(str, '";', index, true)
		local res = gsub(sub(str, index, finish - 1), '\\;', ';')
		index = finish + 2
		cache[#cache + 1] = res

		return index, res
	end

	-- STRING NO ESCAPING NEEDED
	decode['\''] = function(self, index, str, cache)
		local finish = find(str, ';', index, true)
		local res = sub(str, index, finish - 1)
		index = finish + 1
		cache[#cache + 1] = res

		return index, res
	end

	-- NUMBER
	decode['n'] = function(self, index, str)
		index = index - 1
		local finish = find(str, ';', index, true)
		local num = tonumber(sub(str, index, finish - 1))
		index = finish + 1

		return index, num
	end

	decode['0'] = decode['n']
	decode['1'] = decode['n']
	decode['2'] = decode['n']
	decode['3'] = decode['n']
	decode['4'] = decode['n']
	decode['5'] = decode['n']
	decode['6'] = decode['n']
	decode['7'] = decode['n']
	decode['8'] = decode['n']
	decode['9'] = decode['n']
	decode['-'] = decode['n']

	-- positive hex
	decode['X'] = function(self, index, str)
		local finish = find(str, ';', index, true)
		local num = tonumber(sub(str, index, finish - 1), 16)
		index = finish + 1

		return index, num
	end

	-- negative hex
	decode['x'] = function(self, index, str)
		local finish = find(str, ';', index, true)
		local num = -tonumber(sub(str, index, finish - 1), 16)
		index = finish + 1

		return index, num
	end

	-- POINTER
	decode['('] = function(self, index, str, cache)
		local finish = find(str, ')', index, true)
		local num = tonumber(sub(str, index, finish - 1), 16)
		index = finish + 1

		return index, cache[num]
	end

	-- BOOLEAN. ONE DATA TYPE FOR YES, ANOTHER FOR NO.
	decode['t'] = function(self, index) return index, true end
	decode['f'] = function(self, index) return index, false end

	-- VECTOR
	decode['v'] = function(self, index, str)
		local finish = find(str, ';', index, true)
		local vecStr = sub(str, index, finish - 1)
		index = finish + 1 -- update the index.
		local segs = Explode(',', vecStr, false)

		return index, Vector(tonumber(segs[1]), tonumber(segs[2]), tonumber(segs[3]))
	end

	-- ANGLE
	decode['a'] = function(self, index, str)
		local finish = find(str, ';', index, true)
		local angStr = sub(str, index, finish - 1)
		index = finish + 1 -- update the index.
		local segs = Explode(',', angStr, false)

		return index, Angle(tonumber(segs[1]), tonumber(segs[2]), tonumber(segs[3]))
	end

	-- ENTITY
	decode['E'] = function(self, index, str)
		if str[index] == '#' then
			index = index + 1

			return index, NULL
		else
			local finish = find(str, ';', index, true)
			local num = tonumber(sub(str, index, finish - 1))
			index = finish + 1

			return index, Entity(num)
		end
	end

	-- COLOR
	decode['C'] = function(self, index, str)
		local finish = find(str, ';', index, true)
		local colStr = sub(str, index, finish - 1)
		index = finish + 1 -- update the index.
		local segs = Explode(',', colStr, false)

		return index, Color(segs[1], segs[2], segs[3], segs[4])
	end

	-- PLAYER
	decode['P'] = function(self, index, str)
		local finish = find(str, ';', index, true)
		local num = tonumber(sub(str, index, finish - 1))
		index = finish + 1

		return index, Entity(num) or NULL
	end

	-- NIL
	decode['?'] = function(self, index) return index + 1, nil end
	-- SAM CONSOLE
	decode['s'] = function(self, index) return index, sam.console end

	function pon.decode(data)
		local _, res = decode[sub(data, 1, 1)](decode, 2, data, {})

		return res
	end
end
--addons/sam-159/lua/sam/sh_lang.lua:
return gluapack()()
--addons/sam-159/lua/sam/sh_lang.lua:
if SAM_LOADED then return end

local lang = sam.load_file("sam_language.lua", "sh")

local original = lang
if not isstring(lang) then
	lang = "english"
end

local lang_path = "sam_languages/" .. lang .. ".lua"

if not file.Exists(lang_path, "LUA") then
	lang_path = "sam_languages/english.lua"
	if not file.Exists(lang_path, "LUA") then
		-- maybe they deleted english lang????
		sam.print("SAM is broken!")
		sam.print("Language '" .. tostring(original) .. "' doesn't exist and 'english' language file doesn't exist")
		return false
	else
		sam.print("Language '" .. tostring(original) .. "' doesn't exist falling back to english")
	end
end

local Language = sam.load_file(lang_path, "sh_")

local sub, find = string.sub, string.find

local white_color = Color(236, 240, 241)

do
	local args = {}
	function sam.add_message_argument(arg, func)
		if isstring(arg) and isfunction(func) then
			args[arg] = func
		end
	end

	local insert = function(t, v)
		t.__cnt = t.__cnt + 1
		t[t.__cnt] = v
	end

	function sam.format_message(msg, tbl, result, result_n)
		msg = Language[msg] or msg

		result = result or {}
		result.__cnt = result_n or 0

		local pos = 0
		local start, _end, arg, arg2 = nil, 0, nil, nil

		while true do
			start, _end, arg, arg2 = find(msg, "%{ *([%w_%#]+)([^%{}]-) *%}", _end)
			if not start then break end

			if pos ~= start then
				local txt = sub(msg, pos, start - 1)
				if txt ~= "" then
					insert(result, white_color)
					insert(result, txt)
				end
			end

			local ma = args[sub(arg, 1, 1)]
			if not ma then
				insert(result, "{" .. arg .. " " .. arg2 .. "}")
			else
				ma(result, tbl and tbl[arg], arg, unpack(arg2:Trim():Split(" ")))
			end

			pos = _end + 1
		end

		if pos <= #msg then
			insert(result, white_color)
			insert(result, sub(msg, pos))
		end

		return result
	end

	/*
		Admin
	*/
	sam.add_message_argument("A", function(result, admin)
		if sam.isconsole(admin) then
			-- we need to show that it's the real console!!!!!
			insert(result, Color(236, 240, 241))
			insert(result, "*")
			insert(result, Color(13, 130, 223))
			insert(result, "Console")
		else
			if sam.type(admin) == "Player" then
				if CLIENT and LocalPlayer() == admin then
					insert(result, Color(255, 215, 0))
					insert(result, sam.language.get("You"))
				else
					insert(result, Color(13, 130, 223))
					insert(result, admin:Name())
				end
			else
				insert(result, Color(13, 130, 223))
				insert(result, admin)
			end
		end
	end)

	/*
		Target(s)
	*/
	sam.add_message_argument("T", function(result, targets)
		for k, v in ipairs(sam.get_targets_list(targets)) do
			insert(result, v)
		end
	end)

	/*
		Value(s)
	*/
	sam.add_message_argument("V", function(result, value)
		insert(result, Color(0, 230, 64))
		insert(result, tostring(value))
	end)

	/*
		Text(s)
	*/
	sam.add_message_argument("S", function(result, text, _, color)
		insert(result, sam.get_color(color) or white_color)
		insert(result, tostring(text))
	end)

	-- https://gist.github.com/fernandohenriques/12661bf250c8c2d8047188222cab7e28
	local hex_rgb = function(hex)
		local r, g, b
		if #hex == 4 then
			r, g, b = tonumber(hex:sub(2, 2), 16) * 17, tonumber(hex:sub(3, 3), 16) * 17, tonumber(hex:sub(4, 4), 16) * 17
		else
			r, g, b = tonumber(hex:sub(2, 3), 16), tonumber(hex:sub(4, 5), 16), tonumber(hex:sub(6, 7), 16)
		end

		if not r or not g or not b then
			return color_white
		end

		return Color(r, g, b)
	end

	/*
		Colored Text(s)
	*/
	sam.add_message_argument("#", function(result, _, color, ...)
		local text = table.concat({...}, " ")
		insert(result, hex_rgb(color))
		insert(result, text)
	end)
end

function sam.get_message(msg)
	msg = Language[msg]
	if not msg then
		return false
	else
		return {Color(236, 240, 241), msg}
	end
end

function sam.language.get(key)
	return Language[key]
end

function sam.language.Add(key, value)
	Language[key] = value
end
--addons/sam-159/lua/sam_language.lua:
return "english"
--addons/sam-159/lua/sam/player/cl_player.lua:
return gluapack()()
--addons/sam-159/lua/sam/command/arguments/text.lua:
if SAM_LOADED then return end

local sam, command = sam, sam.command

command.new_argument("text")
	:OnExecute(function(argument, input, ply, _, result, i)
		if sam.isstring(input) then
			input = input:sub(1, 255)
		end

		local invalid = false
		if input == nil then
			if not argument.optional then
				invalid = true
			end
		elseif argument.check and not argument.check(input, ply) then
			invalid = true
		end

		if invalid then
			ply:sam_send_message("invalid", {
				S = argument.hint or "text", S_2 = input
			})
			return false
		end

		result[i] = input
	end)
	:Menu(function(set_result, body, buttons, argument)
		local text_entry = buttons:Add("SAM.TextEntry")
		text_entry:SetTall(25)

		local default = argument.default
		text_entry:SetCheck(function(text)
			local valid = true
			if text == "" then
				if default then
					text = default
				elseif not argument.optional then
					valid = false
				end
			elseif argument.check and not argument.check(text, LocalPlayer()) then
				valid = false
			end

			set_result(valid and text or nil)

			return valid
		end)

		local hint = argument.hint or "text"
		if default then
			hint = hint .. " = " .. tostring(default)
		end

		text_entry:SetPlaceholder(hint)

		return text_entry
	end)
:End()
--addons/sam-159/lua/sam/sh_restrictions.lua:
if SAM_LOADED then return end

local loaded = false
local load_restrictions = function()
	local sam = sam
	local config = sam.config
	local hook = hook
	local SERVER = SERVER

	if CLIENT then
		local add_setting = function(body, title, key)
			local setting = body:Add("SAM.LabelPanel")
			setting:Dock(TOP)
			setting:SetLabel(title)

			local enable = setting:Add("SAM.ToggleButton")
			enable:SetConfig(key, true)

			return setting
		end

		config.add_menu_setting("Restrictions", function(body)
			local setting = body:Add("SAM.LabelPanel")
			setting:Dock(TOP)
			setting:DockMargin(8, 6, 8, 0)
			setting:SetLabel("Restrictions (Check these settings in ranks' permissions)")

			local setting_body = body:Add("Panel")
			setting_body:Dock(TOP)
			setting_body:DockMargin(8, 6, 8, 0)
			setting_body:DockPadding(8, 0, 8, 0)

			add_setting(setting_body, "Tool (Eg. using button tool)", "Restrictions.Tool")
			add_setting(setting_body, "Spawning (Eg. spawning props)", "Restrictions.Spawning")
			add_setting(setting_body, "Limits (Eg. how many props can you spawn)", "Restrictions.Limits")

			function setting_body:PerformLayout()
				setting_body:SizeToChildren(false, true)
			end
		end)
	end

	local tools = weapons.GetStored("gmod_tool")
	if sam.istable(tools) then
		if config.get("Restrictions.Tool", true) then
			for k, v in pairs(tools.Tool) do
				sam.permissions.add(v.Mode, "Tools - " .. (v.Category or "Other"), "user")
			end

			hook.Add("CanTool", "SAM.Module.Restrictions", function(ply, _, tool)
				if not ply:HasPermission(tool) then
					if CLIENT and sam.player.check_cooldown(ply, "ToolNoPermission", 0.1) then
						ply:sam_send_message("You don't have permission to use this tool.")
					end
					return false
				end
			end)
		else
			for k, v in pairs(tools.Tool) do
				sam.permissions.remove(v.Mode)
			end

			hook.Remove("CanTool", "SAM.Module.Restrictions")
		end
	end

	sam.permissions.add("admin_weapons", "Spawning", "superadmin")

	local function no_permission(ply, name)
		ply:sam_play_sound("buttons/button10.wav")
		ply:sam_send_message("You don't have permission to spawn {S Blue}.", {
			S = name
		})
	end

	local spawning = {
		PlayerSpawnProp = {
			name = "props",
			permission = "user",
			call_gm = true,
		},
		PlayerGiveSWEP = {
			name = "give_weapons",
			cb = function(_, ply, _, wep)
				if wep.sam_AdminOnly and not ply:HasPermission("admin_weapons") then
					no_permission(ply, "admin weapons")
					return false
				end
				return true
			end,
			hook = sam.hook_first,
		},
		PlayerSpawnSWEP = {
			name = "spawn_weapons",
			cb = function(_, ply, _, wep)
				if wep.sam_AdminOnly and not ply:HasPermission("admin_weapons") then
					no_permission(ply, "admin weapons")
					return false
				end
				return true
			end,
			hook = sam.hook_first,
		},
		-- PlayerSpawnSENT = {
		-- 	name = "entities",
		-- 	check_limit = "sents"
		-- },
		PlayerSpawnNPC = {
			name = "npcs",
			check_limit = "npcs",
		},
		PlayerSpawnVehicle = {
			name = "vehicles",
			check_limit = "vehicles",
		},
		PlayerSpawnRagdoll = {
			name = "ragdolls",
			permission = "user",
			check_limit = "ragdolls",
		}
	}

	local override_lists = {
		"Weapon",
		-- "SpawnableEntities"
	}

	local function LimitReachedProcess(ply, str)
		if not IsValid(ply) then return true end
		return ply:CheckLimit(str)
	end

	local GAMEMODE = GAMEMODE
	if config.get("Restrictions.Spawning", true) then
		for k, v in pairs(spawning) do
			local name = v
			local permission = "superadmin"
			local check
			local check_limit
			local hook = sam.hook_last
			if istable(v) then
				name = v.name
				permission = v.permission or permission
				if v.call_gm then
					check = GAMEMODE[k]
				elseif v.cb then
					check = v.cb
				end
				hook = v.hook or hook
				check_limit = v.check_limit
			end

			sam.permissions.add(name, "Spawning", permission)

			if SERVER then
				hook(k, "SAM.Spawning." .. k .. name, function(ply, ...)
					if not ply:HasPermission(name) then
						no_permission(ply, name)
						return false
					end

					if check_limit then
						return LimitReachedProcess(ply, check_limit)
					end

					if check then
						return check(GAMEMODE, ply, ...)
					end

					return true
				end)
			end
		end

		for i = 1, #override_lists do
			for k, v in pairs(list.GetForEdit(override_lists[i])) do
				v.sam_AdminOnly = v.sam_AdminOnly or v.AdminOnly
				v.AdminOnly = false
			end
		end
	else
		sam.permissions.add("admin_weapons")

		for k, v in pairs(spawning) do
			sam.permissions.remove(istable(v) and v.name or v)

			if SERVER then
				hook.Remove(k, "SAM.Spawning." .. k)
			end
		end

		for i = 1, #override_lists do
			for k, v in pairs(list.GetForEdit(override_lists[i])) do
				if v.sam_AdminOnly then
					v.AdminOnly = v.sam_AdminOnly
				end
			end
		end
	end

	local PLAYER = FindMetaTable("Player")
	if config.get("Restrictions.Limits", true) then
		local get_limit = sam.ranks.get_limit
		function PLAYER:GetLimit(limit_type)
			return get_limit(self:GetUserGroup(), limit_type)
		end

		sam.hook_first("PlayerCheckLimit", "SAM.PlayerCheckLimit", function(ply, limit_type, count)
			local ply_limit = ply:GetLimit(limit_type)
			if ply_limit < 0 then return true end

			if count > ply_limit - 1 then
				return false
			end

			return true
		end)

		sam.limit_types = {}
		for _, limit_type in SortedPairs(cleanup.GetTable(), true) do
			local cvar = GetConVar("sbox_max" .. limit_type)
			if cvar then
				table.insert(sam.limit_types, limit_type)
			end
		end
	else
		sam.limit_types = nil
		PLAYER.GetLimit = nil
		hook.Remove("PlayerCheckLimit", "SAM.PlayerCheckLimit")
	end

	if not loaded then
		loaded = true
		hook.Call("SAM.LoadedRestrictions")
	end
end

timer.Simple(5, function()
	if GAMEMODE.IsSandboxDerived then
		sam.config.hook({"Restrictions.Tool", "Restrictions.Spawning", "Restrictions.Limits"}, load_restrictions)
	end
end)

--addons/sui/lua/sui/vgui/sui_number_slider.lua:
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local NUMBER_SLIDER_FONT = SUI.CreateFont("NumberSlider", "Roboto Regular", 14)

local PANEL = {}

sui.scaling_functions(PANEL)

function PANEL:Init()
	self:ScaleInit()

	local slider = vgui.Create(NAME .. ".Slider", self, "NumberSlider")
	slider:Dock(FILL)

	self.slider = slider

	local label = self:Add(NAME .. ".Label")
	label:Dock(RIGHT)
	label:DockMargin(3, 0, 0, 0)
	label:SetFont(NUMBER_SLIDER_FONT)
	self.label = label

	function label:Think()
		self:SetText(slider:GetValue())

		self:SizeToContents()
	end

	self:SetSize(100, 12)
	self:InvalidateLayout(true)
end

sui.register("NumberSlider", PANEL, "Panel")

--addons/sam-159/lua/sam/menu/tabs/bans.lua:
if SAM_LOADED then return end

local sam = sam
local SQL = sam.SQL
local SUI = sam.SUI
local netstream = sam.netstream

sam.permissions.add("manage_bans", nil, "superadmin")

local get_pages_count = function(bans_count)
	bans_count = bans_count / 35
	local i2 = math.floor(bans_count)
	return bans_count ~= i2 and i2 + 1 or bans_count
end

if SERVER then
	local check = function(ply)
		return ply:HasPermission("manage_bans") and ply:sam_check_cooldown("MenuManageBans", 0.1)
	end

	local limit = 35

	local get_page_count = function(res, callback, page, order_by, keyword)
		local current_time = os.time()
		local query = [[
			SELECT
				COUNT(`steamid`) AS `count`
			FROM
				`sam_bans`
			WHERE
				(`unban_date` >= %d OR `unban_date` = 0)]]

		query = query:format(current_time)

		if keyword then
			query = query .. " AND `steamid` LIKE " .. SQL.Escape("%" .. keyword .. "%")
		end

		SQL.Query(query, callback, true, {res, page, order_by, keyword, current_time})
	end

	local resolve_promise = function(data, arguments)
		local res = arguments[1]
		arguments[1] = data
		res(arguments)
	end

	local get_bans = function(count_data, arguments)
		local res, page, order_by, keyword, current_time = unpack(arguments)
		local count = count_data.count

		local current_page
		if page < 1 then
			page, current_page = 1, 1
		end

		local pages_count = get_pages_count(count)
		if page > pages_count then
			page, current_page = pages_count, pages_count
		end

		local query = [[
			SELECT
				`sam_bans`.*,
				IFNULL(`p1`.`name`, '') AS `name`,
				IFNULL(`p2`.`name`, '') AS `admin_name`
			FROM
				`sam_bans`
			LEFT OUTER JOIN
				`sam_players` AS `p1`
			ON
				`sam_bans`.`steamid` = `p1`.`steamid`
			LEFT OUTER JOIN
				`sam_players` AS `p2`
			ON
				`sam_bans`.`admin` = `p2`.`steamid`
			WHERE
				(`sam_bans`.`unban_date` >= %d OR `sam_bans`.`unban_date` = 0)]]

		query = query:format(current_time)

		if keyword then
			query = query .. " AND `sam_bans`.`steamid` LIKE " .. SQL.Escape("%" .. keyword .. "%")
		end

		local offset = math.abs(limit * (page - 1))
		query = query .. ([[
			ORDER BY
				`sam_bans`.`id` %s
			LIMIT
				%d OFFSET %d]]):format(order_by, limit, offset)

		SQL.Query(query, resolve_promise, nil, {res, count, current_page})
	end

	netstream.async.Hook("SAM.GetBans", function(res, ply, page, order_by, keyword)
		if not isnumber(page) then return end
		if order_by ~= "ASC" and order_by ~= "DESC" then return end
		if keyword ~= nil and not sam.isstring(keyword) then return end

		get_page_count(res, get_bans, page, order_by, keyword)
	end, check)

	return
end

local GetColor = SUI.GetColor
local Line = sui.TDLib.LibClasses.Line

local COLUMN_FONT = SUI.CreateFont("Column", "Roboto", 18)
local LINE_FONT = SUI.CreateFont("Line", "Roboto", 16)
local NEXT_FONT = SUI.CreateFont("NextButton", "Roboto", 18)

sam.menu.add_tab("https://raw.githubusercontent.com/Srlion/Addons-Data/main/icons/sam/ban-user.png", function(column_sheet)
	local refresh, pages
	local current_page, current_order, keyword = nil, "DESC", nil

	local bans_body = column_sheet:Add("Panel")
	bans_body:Dock(FILL)
	bans_body:DockMargin(0, 1, 0, 0)
	bans_body:DockPadding(10, 10, 10, 10)

	local toggle_loading, is_loading = sam.menu.add_loading_panel(bans_body)

	local title = bans_body:Add("SAM.Label")
	title:Dock(TOP)
	title:SetFont(SAM_TAB_TITLE_FONT)
	title:SetText("Bans")
	title:SetTextColor(GetColor("menu_tabs_title"))
	title:SizeToContents()

	local total = bans_body:Add("SAM.Label")
	total:Dock(TOP)
	total:DockMargin(0, 6, 0, 0)
	total:SetFont(SAM_TAB_DESC_FONT)
	total:SetText("60 total bans")
	total:SetTextColor(GetColor("menu_tabs_title"))
	total:SetPos(10, SUI.Scale(40))
	total:SizeToContents()

	do
		local container = bans_body:Add("SAM.Panel")
		container:Dock(TOP)
		container:DockMargin(0, 6, 10, 0)
		container:SetTall(30)

		local sort_order = container:Add("SAM.ComboBox")
		sort_order:Dock(RIGHT)
		sort_order:SetWide(96)
		sort_order:SetValue("Desc")
		sort_order:AddChoice("Desc")
		sort_order:AddChoice("Asc")

		function sort_order:OnSelect(_, value)
			value = value:upper()
			if current_order ~= value then
				current_order = value
				refresh()
			end
		end

		local search_entry = container:Add("SAM.TextEntry")
		search_entry:Dock(LEFT)
		search_entry:SetNoBar(true)
		search_entry:SetPlaceholder("Search...")
		search_entry:SetRadius(4)
		search_entry:SetWide(220)

		function search_entry:OnEnter()
			local value = self:GetValue()
			if keyword ~= value then
				keyword = value ~= "" and value or nil
				refresh()
			end
		end
	end

	Line(bans_body, nil, -5, 15, -5, 0)

	do
		local columns = bans_body:Add("Panel")
		columns:Dock(TOP)
		columns:DockMargin(0, 10, 0, 0)

		local info = columns:Add("SAM.Label")
		info:Dock(LEFT)
		info:DockMargin(4, 0, 0, 0)
		info:SetFont(COLUMN_FONT)
		info:SetText("Player")
		info:SetTextColor(GetColor("player_list_titles"))
		info:SetWide(SUI.Scale(280) + SUI.Scale(34))
		info:SizeToContentsY(3)

		local time_left = columns:Add("SAM.Label")
		time_left:Dock(LEFT)
		time_left:DockMargin(-4, 0, 0, 0)
		time_left:SetFont(COLUMN_FONT)
		time_left:SetText("Time Left")
		time_left:SetTextColor(GetColor("player_list_titles"))
		time_left:SetWide(SUI.Scale(180))
		time_left:SizeToContentsY(3)

		local reason = columns:Add("SAM.Label")
		reason:Dock(LEFT)
		reason:DockMargin(-4, 0, 0, 0)
		reason:SetFont(COLUMN_FONT)
		reason:SetText("Reason")
		reason:SetTextColor(GetColor("player_list_titles"))
		reason:SetWide(SUI.Scale(280))
		reason:SizeToContentsY(3)

		columns:SizeToChildren(false, true)
	end

	local body = bans_body:Add("SAM.ScrollPanel")
	body:Dock(FILL)
	body:DockMargin(0, 10, 0, 0)
	body:SetVBarPadding(6)

	local set_data = function(data)
		body:GetCanvas():Clear()
		body.VBar.Scroll = 0

		local bans, bans_count, current_page_2 = unpack(data)
		total:SetText(bans_count .. " total bans")

		pages = get_pages_count(bans_count)
		current_page.i = pages == 0 and 0 or current_page_2 or current_page.i
		current_page:SetText(current_page.i .. "/" .. pages)

		body:Line()

		for k, v in ipairs(bans) do
			local line = body:Add("SAM.PlayerLine")
			line:DockMargin(0, 0, 0, 10)

			local name = v.name ~= "" and v.name or nil
			local admin_name = v.admin_name ~= "" and v.admin_name or nil
			line:SetInfo({
				steamid = v.steamid,
				name = name,
				rank = admin_name or (v.admin == "Console" and "Console"),
				rank_bg = not admin_name and GetColor("player_list_console")
			})

			local unban_date = tonumber(v.unban_date)
			local time_left = line:Add("SAM.Label")
			time_left:Dock(LEFT)
			time_left:DockMargin(-3, 0, 0, 0)
			time_left:SetFont(LINE_FONT)
			time_left:SetText(unban_date == 0 and "Never" or sam.reverse_parse_length((unban_date - os.time()) / 60))
			time_left:SetTextColor(GetColor("player_list_data"))
			time_left:SetContentAlignment(4)
			time_left:SetWide(SUI.Scale(180))

			local reason = line:Add("SAM.Label")
			reason:Dock(LEFT)
			reason:DockMargin(4, 0, 0, 0)
			reason:SetFont(LINE_FONT)
			reason:SetText(v.reason)
			reason:SetTextColor(GetColor("player_list_data"))
			reason:SetContentAlignment(4)
			reason:SetWrap(true)
			reason:SetWide(SUI.Scale(200))

			local old_tall = line.size
			function reason:PerformLayout()
				local _, h = self:GetTextSize()
				if old_tall < h then
					line:SetTall(h)
				end
			end

			local but = line:Actions()
			but:On("DoClick", function()
				local dmenu = vgui.Create("SAM.Menu")
				dmenu:SetInternal(but)
				if name then
					dmenu:AddOption("Copy Name", function()
						SetClipboardText(name)
					end)
				end
				dmenu:AddOption("Copy SteamID", function()
					SetClipboardText(v.steamid)
				end)
				dmenu:AddOption("Copy Reason", function()
					SetClipboardText(v.reason)
				end)
				dmenu:AddOption("Copy Time Left", function()
					SetClipboardText(time_left:GetText())
				end)

				if v.admin ~= "Console" then
					dmenu:AddSpacer()

					if admin_name then
						dmenu:AddOption("Copy Admin Name", function()
							SetClipboardText(admin_name)
						end)
					end

					dmenu:AddOption("Copy Admin SteamID", function()
						SetClipboardText(v.admin)
					end)
				end

				if LocalPlayer():HasPermission("unban") then
					dmenu:AddSpacer()
					dmenu:AddOption("Unban", function()
						local user = name and ("%s (%s)"):format(name, v.steamid) or v.steamid
						local querybox = vgui.Create("SAM.QueryBox")
						querybox:SetWide(350)
						querybox:SetTitle(user)

						local check = querybox:Add("SAM.Label")
						check:SetText(sui.wrap_text("Are you sure that you want to unban\n" .. user, LINE_FONT, SUI.Scale(350)))
						check:SetFont(LINE_FONT)
						check:SizeToContents()

						querybox:Done()
						querybox.save:SetEnabled(true)
						querybox.save:SetText("UNBAN")

						querybox.save:SetContained(false)
						querybox.save:SetColors(GetColor("query_box_cancel"), GetColor("query_box_cancel_text"))

						querybox.cancel:SetContained(true)
						querybox.cancel:SetColors()

						querybox:SetCallback(function()
							RunConsoleCommand("sam", "unban", v.steamid)
						end)
					end)
				end
				dmenu:Open()
			end)

			body:Line()
		end

		body:InvalidateLayout(true)
		body:GetCanvas():InvalidateLayout(true)
	end

	refresh = function()
		if not is_loading() and LocalPlayer():HasPermission("manage_bans") then
			local refresh_query = netstream.async.Start("SAM.GetBans", toggle_loading, current_page.i, current_order, keyword)
			refresh_query:done(set_data)
		end
	end

	local bottom_panel = bans_body:Add("SAM.Panel")
	bottom_panel:Dock(BOTTOM)
	bottom_panel:DockMargin(0, 6, 0, 0)
	bottom_panel:SetTall(30)
	bottom_panel:Background(GetColor("page_switch_bg"))

	local previous_page = bottom_panel:Add("SAM.Button")
	previous_page:Dock(LEFT)
	previous_page:SetWide(30)
	previous_page:SetText("<")
	previous_page:SetFont(NEXT_FONT)

	previous_page:On("DoClick", function()
		if current_page.i <= 1 then return end

		current_page.i = current_page.i - 1
		refresh()
	end)

	current_page = bottom_panel:Add("SAM.Label")
	current_page:Dock(FILL)
	current_page:SetContentAlignment(5)
	current_page:SetFont(SAM_TAB_DESC_FONT)
	current_page:SetText("loading...")
	current_page.i = 1

	local next_page = bottom_panel:Add("SAM.Button")
	next_page:Dock(RIGHT)
	next_page:SetWide(30)
	next_page:SetText(">")
	next_page:SetFont(NEXT_FONT)

	next_page:On("DoClick", function()
		if current_page.i == pages then return end

		current_page.i = current_page.i + 1
		refresh()
	end)

	function bottom_panel:Think()
		next_page:SetEnabled(current_page.i ~= pages)
		previous_page:SetEnabled(current_page.i > 1)
	end

	for k, v in ipairs({"SAM.BannedPlayer", "SAM.BannedSteamID", "SAM.EditedBan", "SAM.UnbannedSteamID"}) do
		hook.Add(v, "SAM.MenuBans", function()
			if IsValid(body) then
				refresh()
			end
		end)
	end

	refresh()

	return bans_body
end, function()
	return LocalPlayer():HasPermission("manage_bans")
end, 4)
--addons/sam-159/lua/sam/menu/tabs/config/reports.lua:
return gluapack()()
--addons/sam-159/lua/sam/modules/darkrp.lua:
return gluapack()()
--addons/sui/lua/sui/vgui/sui_panel.lua:
local PANEL = {}

sui.scaling_functions(PANEL)

function PANEL:Init()
	self:ScaleInit()
end

sui.register("Panel", PANEL, "Panel")
--addons/sui/lua/sui/vgui/sui_threegrid.lua:
local math = math
local table = table
local ipairs = ipairs

local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local Panel = {}

AccessorFunc(Panel, "horizontalMargin", "HorizontalMargin", FORCE_NUMBER)
AccessorFunc(Panel, "verticalMargin", "VerticalMargin", FORCE_NUMBER)
AccessorFunc(Panel, "columns", "Columns", FORCE_NUMBER)
AccessorFunc(Panel, "Wide2", "Wide2", FORCE_NUMBER)

function Panel:Init()
	self:SetHorizontalMargin(0)
	self:SetVerticalMargin(0)
	self.Rows = {}
	self.Cells = {}
end

function Panel:AddCell(pnl)
	local cols = self:GetColumns()
	local idx = math.floor(#self.Cells / cols) + 1

	local rows = self.Rows[idx]
	if not rows then
		rows = self:CreateRow()
		self.Rows[idx] = rows
	end

	local margin = self:GetHorizontalMargin()

	local dockl, dockt, _, dockb = pnl:GetDockMargin()
	pnl:SetParent(rows)
	pnl:Dock(LEFT)
	pnl:DockMargin(dockl, dockt, #rows.Items + 1 < cols and self:GetHorizontalMargin() or 0, dockb)
	pnl:SetWide(((self:GetWide2() or self:GetWide()) - margin * (cols - 1)) / cols)

	table.insert(rows.Items, pnl)
	table.insert(self.Cells, pnl)

	self:CalculateRowHeight(rows)
end

function Panel:CreateRow()
	local row = self:Add("Panel")
	row:Dock(TOP)
	row:DockMargin(0, 0, 0, self:GetVerticalMargin())
	row.Items = {}

	return row
end

function Panel:CalculateRowHeight(row)
	local height = 0

	for k, v in ipairs(row.Items) do
		local _, t, _, b = v:GetDockMargin()
		height = math.max(height, v:GetTall() + t + b)
	end

	row:SetTall(height)
end

function Panel:Skip()
	local cell = vgui.Create("Panel")
	self:AddCell(cell)
end

function Panel:CalculateRowHeights()
	for _, row in ipairs(self.Rows) do
		self:CalculateRowHeight(row)
	end
end

function Panel:Clear()
	for _, row in ipairs(self.Rows) do
		for _, cell in ipairs(row.Items) do
			cell:Remove()
		end

		row:Remove()
	end

	self.Cells, self.Rows = {}, {}
end

Panel.OnRemove = Panel.Clear
sui.register("ThreeGrid", Panel, NAME .. ".ScrollPanel")
--addons/scb-29/lua/scb/libs/message_pack/sh_messagepack.lua:
return gluapack()()
--addons/scb-29/lua/scb/settings/tabs/emojis.lua:
if SCB_LOADED then return end

local scb = scb
local SUI = scb.SUI
local language = scb.language

scb.emojis = include("scb/cl_emojis_data.lua")

do
	local set_material = surface.SetMaterial
	local i = 0
	for name in pairs(scb.emojis) do
		timer.Simple(i * 0.001, function()
			set_material(SUI.Material("scb/emojis/" .. name .. ".png"))
		end)
		i = i + 1
	end
end

net.Receive("SCB.SendEmojis", function()
	local emojis = net.ReadData(net.ReadUInt(17))
	emojis = util.Decompress(emojis)

	for k, v in pairs(scb.mp.unpack(emojis)) do
		scb.emojis[k] = v
	end

	hook.Call("SCB.EmojisModified")
end)

net.Receive("SCB.AddEmoji", function()
	local emoji = net.ReadString()
	local url = net.ReadString()
	scb.emojis[emoji] = url

	local old = net.ReadString()
	if old ~= "" then
		scb.emojis[old] = nil
	end

	hook.Call("SCB.EmojisModified")
end)

net.Receive("SCB.RemoveEmoji", function()
	scb.emojis[net.ReadString()] = nil
	hook.Call("SCB.EmojisModified")
end)

local emoji_menu = function(title, emoji_name, emoji_url)
	emoji_name = emoji_name or ""

	local options = sui.valid_options()

	local querybox = vgui.Create("SCB.QueryBox")
	querybox:SetTitle(title)
	querybox:SetWide(300)

	local name = querybox:Add("SCB.TextEntry")
	name:Dock(TOP)
	name:SetPlaceholder(language.emoji_name)
	name:SetValue(emoji_name)
	name:SetCheck(function(_name)
		if _name == "" or (scb.emojis[_name] and emoji_name ~= _name) then
			return false
		end
	end)

	function name:AllowInput(c)
		return not c:find("[%w_]")
	end

	options.Add(name)

	local url = querybox:Add("SCB.TextEntry")
	url:Dock(TOP)
	url:DockMargin(0, 4, 0, 0)
	url:SetPlaceholder(language.emoji_url)
	url:SetValue(emoji_url or "")
	url:SetCheck(function(_url)
		if not _url:find("^https?://") then
			_url = "http://" .. _url
		end

		if scb.find_url(_url) ~= 1 then
			return false
		end
	end)

	function url:AllowInput(c)
		return c:find("%s") and true or false
	end

	options.Add(url)

	querybox:SetCallback(function()
		local _name = name:GetText():lower()
		local _url = url:GetText()

		if not _url:find("^https?://") then
			_url = "http://" .. _url
		end

		net.Start("SCB.AddEmoji")
			net.WriteString(_name)
			net.WriteString(_url)
			net.WriteString(_name ~= emoji_name and emoji_name or "")
		net.SendToServer()
	end)

	querybox:Done()
	querybox.save:SetEnabled(true)

	function querybox.save:Think()
		self:SetEnabled(options.IsValid())
	end
end

return {
	title = language.emojis_title,
	pos = 3,
	func = function(parent)
		local body = parent:Add("Panel")
		body:Dock(FILL)
		body:DockMargin(0, 1, 0, 0)
		body:InvalidateParent(true)

		SUI.OnScaleChanged(body, function()
			body:Remove()
		end)

		local top_body = body:Add("Panel")
		top_body:Dock(FILL)
		top_body:InvalidateParent(true)

		local search_field = top_body:Add("SCB.TextEntry")
		search_field:Dock(TOP)
		search_field:SetPlaceholder(language.search)

		local emojis_list = top_body:Add("SCB.ThreeGrid")
		emojis_list:Dock(FILL)
		emojis_list:DockMargin(3, 3, 3, 3)
		emojis_list:InvalidateLayout(true)
		emojis_list:InvalidateParent(true)

		emojis_list:SetColumns(3)
		emojis_list:SetHorizontalMargin(2)
		emojis_list:SetVerticalMargin(2)

		top_body.Paint, emojis_list.Paint = emojis_list.Paint, nil

		local load_emojis = function(search_key)
			emojis_list:Clear()

			search_key = search_key:lower()

			for emoji_name, v in pairs(scb.emojis) do
				if not scb.is_custom_emoji(v) then
					continue
				end

				if not string.find(emoji_name:lower(), search_key, 1, true) then
					continue
				end

				local pnl = vgui.Create("DButton")
				pnl:SetText("")
				pnl:SetTall(SUI.Scale(30))
				pnl:SUI_TDLib()
					:ClearPaint()
					:FadeHover()

				function pnl:DoClick()
					emoji_menu(language.edit .. " '" .. emoji_name .. "'", emoji_name, v)
				end

				function pnl:DoRightClick()
					local d_menu = DermaMenu()

					d_menu:AddOption(language.remove, function()
						net.Start("SCB.RemoveEmoji")
							net.WriteString(emoji_name:lower())
						net.SendToServer()
					end)

					d_menu:Open()
					d_menu:MakePopup()

					function pnl:OnRemove()
						d_menu:Remove()
					end
				end

				local emoji = pnl:Add("SCB.ChatLine")
				emoji:Dock(NODOCK)
				emoji.x = 2

				emoji:NewEmoji(emoji_name, v, 26)
				emoji:Center()
				emoji:SetMouseInputEnabled(false)

				local name = pnl:Add("SCB.Label")
				name:Dock(FILL)
				name:DockMargin(SUI.ScaleEven(26) + 8, 0, 0, 0)
				name:SetFont(SCB_16)
				name:SetText(emoji_name)

				emojis_list:AddCell(pnl)
			end
		end
		load_emojis("")

		hook.Add("SCB.EmojisModified", emojis_list, function()
			load_emojis(search_field:GetValue())
		end)

		function search_field:OnValueChange(v)
			load_emojis(v)
		end

		local add_emoji = body:Add("SCB.Button")
		add_emoji:Dock(BOTTOM)
		add_emoji:DockMargin(0, 4, 0, 0)
		add_emoji:SetText(language.add_emoji:upper())

		add_emoji:On("DoClick", function()
			emoji_menu(language.add_emoji)
		end)

		return body
	end
}
--addons/scb-29/lua/scb/sh_chatbox.lua:
return gluapack()()
--addons/oneprint/lua/autorun/sh_oneprint_load.lua:
return gluapack()()
--addons/thirdperson/lua/thirdperson/client/ferma/cl_ferma_fcheckboxlabel.lua:
return gluapack()()
--addons/thirdperson/lua/thirdperson/client/ferma/cl_ferma_flabel.lua:
return gluapack()()
--addons/thirdperson/lua/thirdperson/client/ferma/cl_ferma_fslider.lua:
FERMA = FERMA or {}
FSlider = {}

function FSlider:Style( style )
    
    /* Defaults */
    self.FT = FERMA.CORE.Fermafy( style, self:GetParent() )
    FERMA.CORE.FermaDefaults( self )
    /* */

    /* Panel Specific Styling */
    self.FT.FXAxis = style["x-axis"] or nil
    self.FT.FYAxis = style["y-axis"] or nil
    self.FT.FVBar = style["vbar"] or false
    self.FT.FHBar = style["hbar"] or false
    self.FT.FNoClip = style["noclip"] or false
    self.FT.FKnob = style["knob"]

    self.m_fSlideX = self.FT.FKnob[1]
    self.m_fSlideY = self.FT.FKnob[2]

    self:SetLockX( self.FT.FXAxis )
    self:SetLockY( self.FT.FYAxis )
    self.Knob:NoClipping( self.FT.FNoClip  )
    /* */

end

function FSlider:Paint( w, h )
    
    /* Defaults */
    FERMA.CORE.PaintFermafy( w, h, self.FT )
    /* */

    /* Panel Specific Painting */
    if( self.FT.FVBar ~= false ) then
        FERMA.CORE.DrawVerticalLine
        {
            ["x"] = ( self:GetWide() / 2 ) - 2,
            ["y"] = 0,
            ["length"] = h,
            ["thickness"] = 3,
            ["color"] = self.FT.FBorderColor
        }
    end

    if( self.FT.FHBar ~= false ) then
        FERMA.CORE.DrawVerticalLine
        {
            ["x"] = 0,
            ["y"] = ( self:GetTall() / 2 ) - 2,
            ["length"] = w,
            ["thickness"] = 3,
            ["color"] = self.FT.FBorderColor
        }
    end
    /* */
    
end

function FSlider:ConvertX( ValPosX, NewMinX, NewMaxX, OldMinX, OldMaxX )
    if( ValPosX == "knob" ) then
        local KnobX, KnobY = self.Knob:GetPos()
        X = ( KnobX + ( self.Knob:GetWide() / 2 ) ) * ( NewMaxX - NewMinX ) / ( OldMaxX - OldMinX ) + NewMinX
    else
        X = ( ValPosX - OldMinX ) * ( NewMaxX - NewMinX ) / ( OldMaxX - OldMinX ) + NewMinX
    end    
    return X
end

function FSlider:ConvertY(ValPosY, NewMinY, NewMaxY, OldMinY, OldMaxY )
    if( ValPosY == "knob" ) then
        local KnobX, KnobY = self.Knob:GetPos()
        Y = ( KnobY + ( self.Knob:GetTall() / 2 ) ) * ( NewMaxY - NewMinY ) / ( OldMaxY - OldMinY ) + NewMinY
    else
        Y = ( ValPosY - OldMinY ) * ( NewMaxY - NewMinY ) / ( OldMaxY - OldMinY ) + NewMinY
    end    
    return Y
end

derma.DefineControl( "FSlider", "Better DSlider", FSlider, "DSlider" )
--addons/thirdperson/lua/thirdperson/client/ferma/cl_ferma_ftitlebar.lua:
return gluapack()()
--addons/bb_simpsit/lua/autorun/simp_sit_init.lua:
SIMPSit = {}
SIMPSit.Core = {}
SIMPSit.Config = {}
SIMPSit.Cooldown = {}

print("Loading SIMP Sit")

local path = "simp_sit/"
if SERVER then
	local files, folders = file.Find(path .. "*", "LUA")
	
	for _, folder in SortedPairs(folders, true) do
		print("Loading folder:", folder)
	    for b, File in SortedPairs(file.Find(path .. folder .. "/sh_*.lua", "LUA"), true) do
	    	print("Loading file:", File)
	        AddCSLuaFile(path .. folder .. "/" .. File)
	        include(path .. folder .. "/" .. File)
	    end
	
	    for b, File in SortedPairs(file.Find(path .. folder .. "/sv_*.lua", "LUA"), true) do
	    	print("Loading file:", File)
	        include(path .. folder .. "/" .. File)
	    end
	
	    for b, File in SortedPairs(file.Find(path .. folder .. "/cl_*.lua", "LUA"), true) do
	    	print("Loading file:", File)
	        AddCSLuaFile(path .. folder .. "/" .. File)
	    end
	end
end

if CLIENT then
	local files, folders = file.Find(path .. "*", "LUA")
	
	for _, folder in SortedPairs(folders, true) do
		print("Loading folder:", folder)
	    for b, File in SortedPairs(file.Find(path .. folder .. "/sh_*.lua", "LUA"), true) do
	    	print("Loading file:", File)
	        include(path .. folder .. "/" .. File)
	    end

	    for b, File in SortedPairs(file.Find(path .. folder .. "/cl_*.lua", "LUA"), true) do
	    	print("Loading file:", File)
	        include(path .. folder .. "/" .. File)
	    end
	end
end

print("Loaded SIMP Sit")
--lua/autorun/slib_loader.lua:
local function slibInit()
    print("[slib] Loading")

    if SERVER then
        AddCSLuaFile("slib/sh_util.lua")
        include("slib/sv_storage.lua")
        include("slib/sh_util.lua")
    else
        include("slib/sh_util.lua")
    end
end

hook.Add("slib:loadBase", "slib.loadVGUI", function()
    slib.loadFolder("slib/vgui/", false, {{"slib/vgui/", "cl_sframe.lua"}})
end)

slibInit()
--lua/slib/vgui/cl_sscrollpanel.lua:
return gluapack()()
--lua/slib/vgui/cl_stextentry.lua:
return gluapack()()
--addons/eprotect_1.5.24/lua/e_protect/sh_eprotect.lua:
eProtect.encodeSteamID64 = function(data)
    local converted_tbl = {}

    for k,v in pairs(data) do
        if istable(v) then v = eProtect.encodeSteamID64(v) end

        local isSteamID64 = isstring(k) and #k == 17 and util.SteamIDFrom64(k) != "STEAM_0:0:0"

        if isSteamID64 then
            converted_tbl["sid64_"..k] = v
        else
            converted_tbl[k] = v
        end
    end

    return converted_tbl
end

eProtect.decodeSteamID64 = function(data)
    local converted_tbl = {}

    for k, v in pairs(data) do
        if istable(v) then v = eProtect.decodeSteamID64(v) end

        if string.sub(k, 1, 6) == "sid64_" then
            local sid64 = string.sub(k, 7, #k)

            if util.SteamIDFrom64(sid64) != "STEAM_0:0:0" then
                k = sid64
            end
        end

        converted_tbl[k] = v
    end

   return converted_tbl
end
--addons/eprotect_1.5.24/lua/e_protect/languages/sh_german.lua:
if CLIENT then
    slib.setLang("eprotect", "de", "sc-preview", "Screenshot Vorschau - ")
    slib.setLang("eprotect", "de", "net-info", "Net Info - ")
    slib.setLang("eprotect", "de", "ip-info", "IP Info - ")
    slib.setLang("eprotect", "de", "id-info", "ID Info - ")
    slib.setLang("eprotect", "de", "ip-correlation", "IP Korrelation - ")
    slib.setLang("eprotect", "de", "table-viewer", "Tabellenbetrachtung")

    slib.setLang("eprotect", "de", "tab-general", "Generell")
    slib.setLang("eprotect", "de", "tab-identifier", "Kennung")
    slib.setLang("eprotect", "de", "tab-netlimiter", "Net-Begrenzer")
    slib.setLang("eprotect", "de", "tab-netlogger", "Net Logger")
    slib.setLang("eprotect", "de", "tab-exploitpatcher", "Exploit Patcher")
    slib.setLang("eprotect", "de", "tab-exploitfinder", "Exploit Finder")
    slib.setLang("eprotect", "de", "tab-fakeexploits", "Fake Exploits")
    slib.setLang("eprotect", "de", "tab-datasnooper", "Datenschnüffler")

    slib.setLang("eprotect", "de", "player-list", "Spielerliste")

    slib.setLang("eprotect", "de", "ratelimit", "Bewertungslimit")
    slib.setLang("eprotect", "de", "ratelimit-tooltip", "Dies ist ein allgemeines Bewertungslimit und wird durch bestimmte festgelegte Grenzwerte außer Kraft gesetzt. (Xs / Y)")

    slib.setLang("eprotect", "de", "timeout", "Timeout")
    slib.setLang("eprotect", "de", "timeout-tooltip", "Dies ist das Zeitlimit, das den Bewertungslimit-Zähler zurückgesetzt.")

    slib.setLang("eprotect", "de", "overflowpunishment", "Overflow Bestrafung")
    slib.setLang("eprotect", "de", "overflowpunishment-tooltip", "Dies ist die Bestrafung, wenn der Network Way des Spielers zu lang ist. (1 = Kick, 2 = Bann)")

    slib.setLang("eprotect", "de", "enable-networking", "Aktiviere Networking")
    slib.setLang("eprotect", "de", "disable-networking", "Deaktiviere Networking")

    slib.setLang("eprotect", "de", "disable-all-networking", "Deaktiviert serverweit Networking")
    slib.setLang("eprotect", "de", "disable-all-networking-tooltip", "Wenn dies aktiviert ist, kann niemand mit dme Server networken.")

    slib.setLang("eprotect", "de", "player", "Spieler")
    slib.setLang("eprotect", "de", "net-string", "Net String")
    slib.setLang("eprotect", "de", "called", "Aufgerufen")
    slib.setLang("eprotect", "de", "len", "Len")
    slib.setLang("eprotect", "de", "type", "Typ")
    slib.setLang("eprotect", "de", "activated", "Aktiviert")
    slib.setLang("eprotect", "de", "secure", "Gesichert")
    slib.setLang("eprotect", "de", "ip", "IP Adresse")
    slib.setLang("eprotect", "de", "date", "Datum")
    slib.setLang("eprotect", "de", "country-code", "Landesvorwahl")
    slib.setLang("eprotect", "de", "status", "Status")

    slib.setLang("eprotect", "de", "unknown", "Unbekannt")
    slib.setLang("eprotect", "de", "secured", "Gesichert")

    slib.setLang("eprotect", "de", "check-ids", "Check ID(s)")
    slib.setLang("eprotect", "de", "correlate-ip", "Zusammenhängende IP(s)")
    slib.setLang("eprotect", "de", "family-share-check", "Prüfe Family Share")

    slib.setLang("eprotect", "de", "ply-sent-invalid-data", "Dieser Spieler hat ungültige Daten gesendet.")
    slib.setLang("eprotect", "de", "ply-failed-retrieving-data", "%s Daten konnten nicht abgerufen werden.")

    slib.setLang("eprotect", "de", "net-limit-desc", "Die Zahl hier gibt an, wie oft Personen pro Sekunde mit dem Server networken können, bevor die Rate begrenzt wird.")

    slib.setLang("eprotect", "de", "capture", "Screenshot")
    slib.setLang("eprotect", "de", "check-ips", "Prüfe IP(s)")
    slib.setLang("eprotect", "de", "fetch-data", "Daten abrufen")
elseif SERVER then
    slib.setLang("eprotect", "de", "invalid-player", "Dieser Spieler ist ungültig!")
    slib.setLang("eprotect", "de", "kick-net-overflow", "Du wurdest wegen Net-Overflow vom Server geworfen!")
    slib.setLang("eprotect", "de", "banned-net-overflow", "Du wurdest wegen Net-Overflow vom Server gebannt!")
    slib.setLang("eprotect", "de", "banned-net-exploitation", "Du wurdest wegen Net-Exploiting vom Server gebannt!")
    slib.setLang("eprotect", "de", "kick-malicious-intent", "Du wurdest wegen bösen Absichten vom Server geworfen!")
    slib.setLang("eprotect", "de", "banned-malicious-intent", "Du wurdest wegen bösen Absichten vom Server gebannt!")

    slib.setLang("eprotect", "de", "banned-exploit-attempt", "Du wurdest wegen versuchtem Exploiting gebannt!")

    slib.setLang("eprotect", "de", "sc-timeout", "Du musst %s Sekunden warten, bis du %s wieder screenshoten kannst!")
    slib.setLang("eprotect", "de", "sc-failed", "Screenshot von %s konnte nicht abgerufen werden, dies ist verdächtig!")

    slib.setLang("eprotect", "de", "has-family-share", "%s spielt über Family Sharing, SteamID64 des Besitzers ist: %s!")
    slib.setLang("eprotect", "de", "no-family-share", "%s spielt das Spiel nicht durch Family Sharing!")
    slib.setLang("eprotect", "de", "no-correlation", "Wir konnten keine IPs für %s korrelieren.")
end
--addons/gprotect_1.13.99/lua/g_protect/sh_gprotect_operators.lua:
return gluapack()()
--lua/autorun/snoopdogg_hq.lua:
return gluapack()()
--lua/autorun/snoopdogg_hq_bodygroup.lua:
local Snoopdogghq_models = {
							"models/player/voikanaa/snoop_dogg_npc.mdl"
						}	
hook.Add("PlayerSpawnedNPC","RandomBodyGroupSnoopdogghq",function(ply,npc)
    if table.HasValue( Snoopdogghq_models, npc:GetModel() )					
	       then 

         npc:SetBodygroup(1,math.random( 0, 1 ) ) // You need to have this one here or the entire thing gets screwed over
		 npc:SetBodygroup(2,math.random( 0, 1 ) ) // Hats
			
    end
end)
--addons/sreward_1.5.30/lua/s_reward/sh_sreward_config.lua:
return gluapack()()
--addons/sreward_1.5.30/lua/s_reward/rewards/sh_darkrpmoney.lua:
return gluapack()()
--addons/sreward_1.5.30/lua/s_reward/rewards/sh_rank.lua:
return gluapack()()
--addons/sreward_1.5.30/lua/s_reward/rewards/sh_vrondakisleveling.lua:
return gluapack()()
--lua/autorun/streamradio_loader.lua:
return gluapack()()
--lua/streamradio_core/api.lua:
--[[
    The developer API for the use in external addons or in non-sandbox gamemodes.
    Make sure you check for StreamRadioLib.Loaded == true before using this API.

    Functions:
        bool StreamRadioLib.EditRadio( Entity Radio [, table settings] )
        -- Set the Radio settings to the given settings. Returns true on success.

        Entity StreamRadioLib.SpawnRadio( [Player player] [, string model] [, Vector pos] [, Angle ang] [, table settings] )
        -- Spawns a Radio and makes the given player to the owner for the tool and CPPI. It will have the given model and will be spawned at pos and ang.
        -- The settings table will set the radio's settings. The radio entity is returned on success.

        bool StreamRadioLib.IsValidRadioSettings( any settings )
        -- Checks settings for being a valid settings table. Returns true if it is.

    The settings table:
        This following list describes the layout of the settings table.
        Each element is optional, but have to be fed with the right datatype when they are in use.

        Index:                  Type:       Default:        Description:

        StreamUrl               String      ""              The streaming source URL.
        StreamName              String      ""              Name of the stream.

        StreamMute              boolean     false           True mutes the stream
        StreamVolume            number      1               0 is 0% and 1 is 100% volume
        Radius                  number      1200            Number in units of the sound range
		Sound3D                 boolean     true            True enables the 3D world sound
        DisableInput            boolean     false           True disables the radio controlling. Does not affect Wiremod controlling.
        DisableDisplay          boolean     false           True disables the radio display.
        DisableSpectrum          boolean     false          True disables the spectrum visualization on the radio display.
        DisableAdvancedOutputs  boolean     true            True disables the Advanced Wire Outputs.

		PlaybackLoopMode        number      1               Loop mode:
                                                                StreamRadioLib.PLAYBACK_LOOP_MODE_NONE, Value: 0, No loop (Invalid values falls back to this)
																StreamRadioLib.PLAYBACK_LOOP_MODE_SONG, Value: 1, Loops song
																StreamRadioLib.PLAYBACK_LOOP_MODE_PLAYLIST, Value: 2

        StreamLoop              boolean     false           True enables stream looping. DEPRECATED, use PlaybackLoopMode
        PlaylistLoop            boolean     true            True enables playlist looping. DEPRECATED, use PlaybackLoopMode
]]

-- ======================================================================
-- === Don't edit anything below, unless you know what you are doing. ===
-- === Really, you don't need to. Report it to me if you find a bug.  ===
-- ======================================================================

local ValidTypes = {
	StreamName = "string",
	StreamUrl = "string",

	StreamMute = "boolean",
	StreamVolume = "number",
	Radius = "number",
	Sound3D = "boolean",
	DisableInput = "boolean",
	DisableDisplay = "boolean",
	DisableSpectrum = "boolean",
	DisableAdvancedOutputs = "boolean",

	PlaybackLoopMode = "number",

	-- @DEPRECATED
	StreamLoop = "boolean",
	PlaylistLoop = "boolean",
}

function StreamRadioLib.IsValidRadioSettings( settings )
	if ( not settings ) then return true end
	if TypeID( settings ) ~= TYPE_TABLE then return false end

	for k, v in pairs( settings ) do
		if ValidTypes[k] and type( v ) ~= ValidTypes[k] then return false end
	end

	return true
end

local function ErrorCheckArg( var, tright, argn, funcname, level )
	if ( var == nil ) then return true end
	local t = type( var )

	if t ~= tright then
		StreamRadioLib.Util.ErrorNoHaltWithStack( string.format( "bad argument #%i to '%s' (%s or nil expected, got %s)", argn, funcname, tright, t ), level or 3 )
		return false
	end

	return true
end

local function ErrorCheckRadioSettings( settings, argn, funcname, level )
	level = level or 3
	if not ErrorCheckArg( settings, "table", argn, funcname, level + 1 ) then return false end

	for k, v in pairs( settings ) do
		local t = type( v )
		local tright = ValidTypes[k]
		if not tright or t == tright then continue end
		StreamRadioLib.Util.ErrorNoHaltWithStack( string.format( "bad datatype at index '%s' of argument #%i at '%s' (%s or nil expected, got %s)", k, argn, funcname, tright, t ), level )

		return false
	end

	return true
end

function StreamRadioLib.EditRadio( ent, settings )
	if not StreamRadioLib.Loaded then return false end

	if not SERVER then return false end
	if not ErrorCheckArg( ent, "Entity", 1, "EditRadio", 3 ) then return false end
	if not IsValid( ent ) then return false end
	if not ent.__IsRadio then return false end

	settings = settings or {}
	if not ErrorCheckRadioSettings( settings, 2, "EditRadio", 3 ) then return false end

	if ent.SetSettings then
		ent:SetSettings(settings)
	end

	return true
end

local Ang_Zero = Angle( )
local Vec_Zero = Vector( )

function StreamRadioLib.SpawnRadio( ply, model, pos, ang, settings )
	if not SERVER then return end

	local StreamRadioLib = StreamRadioLib or {}

	if not StreamRadioLib.Loaded then
		if StreamRadioLib.Loader_ShowSpawnError then
			StreamRadioLib.Loader_ShowSpawnError("The Entity 'sent_streamradio' could not be spawned.")
		end

		return
	end

	if not IsValid(ply) or ply:IsWorld() then
		ply = nil
	end

	if not ErrorCheckArg(ply, "Player", 1, "SpawnRadio", 3) then return end

	if not ErrorCheckArg(model, "string", 2, "SpawnRadio", 3) then return end
	if not ErrorCheckArg(pos, "Vector", 3, "SpawnRadio", 3) then return end
	if not ErrorCheckArg(ang, "Angle", 4, "SpawnRadio", 3) then return end

	settings = settings or {}
	if not ErrorCheckRadioSettings(settings, 5, "SpawnRadio", 3) then return end

	local ent = ents.Create( "sent_streamradio" )
	if not IsValid(ent) then return end

	if StreamRadioLib.Util.IsValidModel(model) then
		ent:SetModel(model)
	end

	ent:SetPos(pos or Vec_Zero)
	ent:SetAngles(ang or Ang_Zero)

	ent:Spawn()
	ent:Activate()

	local data = {}
	data.pl = ply
	data.Owner = ply

	if isfunction(ent.CPPISetOwner) then
		ent:CPPISetOwner(ply)
	end

	if isfunction(ent.SetLastUser) then
		ent:SetLastUser(ply)
	end

	if isfunction(ent.SetRadioOwner) then
		ent:SetRadioOwner(ply)
	end

	for k, v in pairs(data) do
		ent[k] = v
	end

	if not StreamRadioLib.EditRadio(ent, settings) then return end
	ent:PhysWake()

	timer.Simple(0.05, function()
		if not IsValid(ent) then return end
		if not ent.ReapplyClasssystemPaste then return end

		ent:ReapplyClasssystemPaste()
	end)

	return ent
end

return true


--lua/streamradio_core/http.lua:
return gluapack()()
--lua/streamradio_core/models/cs_office_tv.lua:
local RADIOMDL = RADIOMDL
if not istable( RADIOMDL ) then
	StreamRadioLib.Model.LoadModelSettings()
	return
end

-- CS:S Office Plasma TV
RADIOMDL.model = "models/props/cs_office/tv_plasma.mdl"

RADIOMDL.SpawnAng = Angle(0, 0, 0)
RADIOMDL.SpawnFlatOnWall = true
RADIOMDL.SoundPosOffset = Vector(6.20, 0, 17.10)
RADIOMDL.SoundAngOffset = Angle(0, 0, 0)


RADIOMDL.DisplayAngles = Angle(0, 90, 90)

                              --      F,      R,     U
RADIOMDL.DisplayOffset    = Vector(6.20, -27.90, 35.25) -- Top Left
RADIOMDL.DisplayOffsetEnd = Vector(6.20,  27.95,  2.55) -- Bottom Right

RADIOMDL.DisplayWidth = 2048
RADIOMDL.DisplayHeight, RADIOMDL.DisplayScale = RADIOMDL:GetDisplayHeight(RADIOMDL.DisplayOffset, RADIOMDL.DisplayOffsetEnd, RADIOMDL.DisplayWidth)

RADIOMDL.FontSizes = {
--  Name 	= Size,	Weight, Parentname
	Header	= {50,	1000},
	Default	= {44,	700},
	Tooltip	= {44,	1000},
	Big		= {60,	700},
}

function RADIOMDL:SetupGUI(ent, gui_controller, mainpanel)
	gui_controller:SetPos(0, 0)
	gui_controller:SetSize(self.DisplayWidth, self.DisplayHeight)

	mainpanel:SetSize(gui_controller:GetClientSize())

	local modelsetup = {}
	if CLIENT then
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/header/text", "font", self.Fonts.Header)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/header/pretext", "font", self.Fonts.Header)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "font", self.Fonts.Default)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "font", self.Fonts.Default)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/header", "font", self.Fonts.Header)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/controls/progressbar/label", "font", self.Fonts.Default)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/button", "font", self.Fonts.Default)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/volume/progressbar/label", "font", self.Fonts.Default)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/textbox", "font", self.Fonts.Big)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/button", "font", self.Fonts.Default)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/textbox", "font", self.Fonts.Big)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/button", "font", self.Fonts.Default)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "tooltip", "font", self.Fonts.Tooltip)
	end

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/header", "sizeh", 75)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/header", "sizeh", 75)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists", "gridsize", {x = 2, y = 10})
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview", "gridsize", {x = 2, y = 10})
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/scrollbar", "sizew", 75)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/scrollbar", "sizew", 75)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/sidebutton", "sizew", 125)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/textbox/scrollbar", "sizew", 75)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/textbox/scrollbar", "sizew", 75)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/button", "sizeh", 100)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/button", "sizew", 100)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/button", "sizew", 100)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "", "cornersize", 0)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "", "borderwidth", 16)

	local shadow = 12
	local padding = 12
	local margin = 12

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "shadowwidth", shadow)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "shadowwidth", shadow)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "padding", padding)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "padding", padding)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "margin", margin)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "margin", margin)

	gui_controller:SetModelSetup(modelsetup)

	mainpanel:ForEachChildRecursive(function(panel, child)
		if child.SetShadowWidth and child:GetShadowWidth() == 5 then
			child:SetShadowWidth(shadow)
		end

		if child.SetPadding and child:GetPadding() == 5 then
			child:SetPadding(padding)
		end

		if child.SetMargin and child:GetMargin() == 5 then
			child:SetMargin(margin)
		end
	end)
end

return true


--lua/streamradio_core/models/default.lua:
return gluapack()()
--lua/streamradio_core/models/portal_speaker_big.lua:
local RADIOMDL = RADIOMDL
if not istable( RADIOMDL ) then
	StreamRadioLib.Model.LoadModelSettings()
	return
end

-- Portal 2 Old Speaker, Big
RADIOMDL.model = "models/props_underground/old_speaker_big.mdl"

RADIOMDL.NoDisplay = true
RADIOMDL.SpawnAng = Angle( -90, 0, 0 )
RADIOMDL.SpawnFlatOnWall = false
RADIOMDL.SpawnAtOrigin = true
RADIOMDL.SoundPosOffset = Vector( 35.5, 1.40, 5.2 )
RADIOMDL.SoundAngOffset = Angle( 22.5, 0, 0 )

return true


--lua/streamradio_core/models/wire_speaker2.lua:
return gluapack()()
--lua/streamradio_core/classes/ui/panel.lua:
return gluapack()()
--lua/streamradio_core/classes/ui/highlighter.lua:
local StreamRadioLib = StreamRadioLib

if not istable(CLASS) then
	StreamRadioLib.ReloadClasses()
	return
end

local BASE = CLASS:GetBaseClass()

local LIBUtil = StreamRadioLib.Util

function CLASS:Create()
	BASE.Create(self)

	self:SetZPos(9999000)
	self:SetSize(1,1)
	self:SetPos(0,0)

	if CLIENT then
		self.Colors.Main = Color(160, 160, 255, 80)
		self.Colors.Border1 = Color(0, 0, 0, 200)
		self.Colors.Border2 = Color(255, 255, 255, 200)
	end

	if CLIENT then
		self.Highlighted = {}
	end

	self:SetSkinAble(false)
end

function CLASS:Remove()
	self:HighlightClear()
	BASE.Remove(self)
end

function CLASS:SetBorderColor(color)
	if SERVER then return end

	color = color or {}
	color = Color(
		color.r or 0,
		color.g or 0,
		color.b or 0,
		color.a or 0
	)

	self.Colors.Border1 = color
end

function CLASS:SetBorderColor2(color)
	if SERVER then return end

	color = color or {}
	color = Color(
		color.r or 0,
		color.g or 0,
		color.b or 0,
		color.a or 0
	)

	self.Colors.Border2 = color
end

function CLASS:GetBorderColor()
	if SERVER then return end

	local col = self.Colors.Border1
	return col
end

function CLASS:GetBorderColor2()
	if SERVER then return end

	local col = self.Colors.Border2
	return col
end

function CLASS:HighlightClear()
	if SERVER then return end

	LIBUtil.EmptyTableSafe(self.Highlighted)
	self:QueueCall("PerformRerender")
end

function CLASS:HighlightPanel(panel)
	if SERVER then return end
	if not IsValid(panel) then return end

	self.Highlighted[panel:GetID()] = panel
	self:QueueCall("PerformRerender")
end

function CLASS:HighlightPanels(panels)
	if SERVER then return end

	for _, panel in pairs(panels or {}) do
		self:HighlightPanel(panel)
	end
end

function CLASS:GetHighlightedPanels()
	if SERVER then return end

	return self.Highlighted
end

function CLASS:RenderHighlight(panel)
	if SERVER then return end

	if not IsValid(panel) then return end
	if not self:IsVisibleSimple() then return end
	if not panel:IsVisibleSimple() then return end

	local sp = self:GetSuperParent()
	local spx, spy = sp:GetRenderPos()
	local spw, sph = sp:GetSize()

	local px, py = panel:GetRenderPos()
	local pw, ph = panel:GetSize()

	local thickness = 2
	local lines = 4
	local padding = thickness * lines

	px = math.max(px, spx + padding)
	py = math.max(py, spy + padding)

	pw = math.min(pw, spw - padding * 2)
	ph = math.min(ph, sph - padding * 2)

	local colMain = self.Colors.Main or color_white

	surface.SetDrawColor(colMain:Unpack())
	surface.DrawRect(px, py, pw, ph)

	local col1 = self.Colors.Border1 or color_white
	local col2 = self.Colors.Border2 or color_black

	for i = 1, lines do
		local col = ((i % 2) == 0) and col2 or col1
		surface.SetDrawColor(col:Unpack())

		for j = 0, thickness - 1 do
			local t = (i - 1) * thickness + j
			local tt = t * 2

			surface.DrawOutlinedRect(px - t, py - t, pw + tt, ph + tt)
		end
	end
end

function CLASS:Render()
	for _, panel in pairs(self.Highlighted) do
		self:RenderHighlight(panel)
	end
end

function CLASS:IsInBounds(x, y)
	return false
end

function CLASS:SetModelSetup()
end

function CLASS:OnModelSetup()
end

function CLASS:ActivateNetworkedMode()
end

return true


--lua/streamradio_core/classes/ui/shadow_panel.lua:
local StreamRadioLib = StreamRadioLib

if not istable(CLASS) then
	StreamRadioLib.ReloadClasses()
	return
end

local BASE = CLASS:GetBaseClass()

function CLASS:Create()
	BASE.Create(self)

	self.CanHaveLabel = true

	self.Layout.Padding = 5
	self.Layout.ShadowWidth = 5
	self.Layout.Background = true

	self.SkinMap["color_foreground"] = {
		set = "SetTextColor",
		get = "GetTextColor",
	}

	self.SkinMap["color_icon"] = {
		set = "SetIconColor",
		get = "GetIconColor",
	}

	self.SkinMap["color_shadow"] = {
		set = "SetShadowColor",
		get = "GetShadowColor",
	}

	if not SERVER then
		self.Colors.Shadow = Color(64,64,64)
	end

	self.SkinAble = true
end

function CLASS:CreateText(class)
	if not self.CanHaveLabel then return nil end

	if IsValid(self.TextPanel) then
		return self.TextPanel
	end

	self.TextPanel = self:AddPanelByClassname(class or "label", true)
	self.TextPanel:SetPos(0, 0)
	self.TextPanel:SetAlign(TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
	self.TextPanel:SetName("label")
	self.TextPanel:SetNWName("lbl")
	self.TextPanel:SetSkinIdentifyer("label")

	self.TextPanel.OnTextChange = function(pnl)
		if not IsValid(self) then return end
		self:CallHook("OnTextChange")
	end

	self.TextPanel.OnFontChange = function(pnl)
		if not IsValid(self) then return end

		self:InvalidateLayout()
		self:CallHook("OnFontChange")
	end

	self.TextPanel.OnAlignChange = function(pnl)
		if not IsValid(self) then return end

		self:InvalidateLayout()
		self:CallHook("OnAlignChange")
	end

	self:InvalidateLayout()
	return self.TextPanel
end

function CLASS:Render()
	if not self.Layout.Background then
		BASE.Render(self)
		return
	end

	local x, y = self:GetRenderPos()
	local w, h = self:GetSize()
	local shadowWidth = self:GetShadowWidth()

	local colMain = self.Colors.Main or color_white

	if shadowWidth <= 0 then
		surface.SetDrawColor(colMain:Unpack())
		surface.DrawRect(x, y, w, h)

		BASE.Render(self)
		return
	end

	local sx, sy = x + shadowWidth, y + shadowWidth
	local sw, sh = w - shadowWidth, h - shadowWidth

	local colShadow = self.Colors.Shadow or color_black

	surface.SetDrawColor(colShadow:Unpack())
	surface.DrawRect(sx, sy, sw, sh)
	surface.SetDrawColor(colMain:Unpack())
	surface.DrawRect(x, y, sw, sh)

	BASE.Render(self)
end

function CLASS:PerformLayout(...)
	BASE.PerformLayout(self, ...)

	if not self.CanHaveLabel then
		return
	end

	local text_panel = self.TextPanel
	if not IsValid(text_panel) then
		return
	end

	local w, h = self:GetClientSize()
	text_panel:SetSize(w, h)
end

function CLASS:SetShadowColor(color)
	if SERVER then return end

	color = color or {}
	color = Color(
		color.r or 0,
		color.g or 0,
		color.b or 0,
		color.a or 0
	)

	self.Colors.Shadow = color
end

function CLASS:GetShadowColor()
	if SERVER then return end

	local col = self.Colors.Shadow
	return col
end

function CLASS:GetShadowWidth()
	if not self.Layout.Background then
		return 0
	end

	return self.Layout.ShadowWidth or 0
end

function CLASS:SetShadowWidth(width)
	self.Layout.ShadowWidth = width or 0
end

function CLASS:GetClientSize()
	local w, h = BASE.GetClientSize(self)
	local s = self:GetShadowWidth()

	w = w - s
	h = h - s

	if w < 0 then
		w = 0
	end

	if h < 0 then
		h = 0
	end

	return w, h
end

function CLASS:GetClientWidth()
	local w = BASE.GetClientWidth(self)
	local s = self:GetShadowWidth()

	w = w - s

	if w < 0 then
		w = 0
	end

	return w
end

function CLASS:GetClientHeight()
	local h = BASE.GetClientHeight(self)
	local s = self:GetShadowWidth()

	h = h - s

	if h < 0 then
		h = 0
	end

	return h
end

function CLASS:SetSizeWithoutShadow(w, h)
	w = w or 0
	h = h or 0
	local s = self:GetShadowWidth()

	w = w + s
	h = h + s
	return self:SetSize(w, h)
end

function CLASS:SetWidthWithoutShadow(w)
	w = w or 0
	local s = self:GetShadowWidth()

	w = w + s
	return self:SetWidth(w)
end

function CLASS:SetHeightWithoutShadow(h)
	h = h or 0
	local s = self:GetShadowWidth()

	h = h + s
	return self:SetTall(h)
end

function CLASS:IsInBounds(x, y)
	if not BASE.IsInBounds(self, x, y) then return false end

	local w, h = self:GetSize()
	local s = self:GetShadowWidth()

	if x > (w - s) then return false end
	if y > (h - s) then return false end

	return true
end

function CLASS:SetPaintBackground(bool)
	self.Layout.Background = bool or false
end

function CLASS:GetPaintBackground(bool)
	return self.Layout.Background or false
end

function CLASS:GetTextAlign(...)
	return self:GetAlign(...)
end

function CLASS:SetTextAlign(...)
	return self:SetAlign(...)
end

function CLASS:GetAlign(...)
	if not IsValid(self.TextPanel) then
		return TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER
	end

	return self.TextPanel:GetAlign(...)
end

function CLASS:SetAlign(...)
	return self:CreateText():SetAlign(...)
end

function CLASS:SetText(...)
	return self:CreateText():SetText(...)
end

function CLASS:GetText(...)
	if not IsValid(self.TextPanel) then
		return ""
	end

	return self.TextPanel:GetText(...)
end

function CLASS:SetFont(...)
	return self:CreateText():SetFont(...)
end

function CLASS:GetFont(...)
	if not IsValid(self.TextPanel) then
		return ""
	end

	return self.TextPanel:GetFont(...)
end

function CLASS:SetTextColor(...)
	return self:CreateText():SetColor(...)
end

function CLASS:GetTextColor(...)
	if not IsValid(self.TextPanel) then
		return self:GetColor(...)
	end

	return self.TextPanel:GetColor(...)
end

function CLASS:OnModelSetup(setup)
	BASE.OnModelSetup(self, setup)

	if setup.shadowwidth then
		self:SetShadowWidth(setup.shadowwidth)
	end

	if setup.font then
		self:SetFont(setup.font)
	end
end

return true


--lua/streamradio_core/classes/ui/textview.lua:
return gluapack()()
--lua/streamradio_core/classes/ui/radio/gui_browser.lua:
return gluapack()()
--lua/streamradio_core/classes/ui/radio/gui_player.lua:
return gluapack()()
--lua/streamradio_core/classes/rendertarget.lua:
return gluapack()()
--lua/streamradio_core/vr.lua:
return gluapack()()
--lua/streamradio_core/client/cl_lib.lua:

local LIBNet = StreamRadioLib.Net

local g_camPos = nil
local g_inRenderScene = false

StreamRadioLib.Hook.Add( "RenderScene", "CamInfo", function( origin, angles, fov )
	if not StreamRadioLib then return end
	if not StreamRadioLib.Loaded then return end
	if not StreamRadioLib.HasSpawnedRadios() then return end

	if g_inRenderScene then return end
	g_inRenderScene = true

	if StreamRadioLib.VR.IsActive() then
		g_camPos = nil
		g_inRenderScene = false

		return
	end

	g_camPos = origin
	g_inRenderScene = false
end )

local g_pressed = false
local g_lastradio = nil

local function ReleaseLastRadioControl()
	if not StreamRadioLib then return end
	if not StreamRadioLib.Loaded then return end
	if not StreamRadioLib.HasSpawnedRadios() then return end

	local ply = LocalPlayer()
	if not IsValid( ply ) then return end
	if not IsValid( g_lastradio ) then return end
	if not g_lastradio.__IsRadio then return end
	if not g_lastradio.Control then return end

	local wasPressed = g_pressed
	g_pressed = false

	if not wasPressed then return end

	local trace = StreamRadioLib.Trace( ply )

	LIBNet.Start("Control")
		net.WriteBool( false )
	net.SendToServer()

	StreamRadioLib.Control( ply, trace, false )
	g_lastradio = nil
end

local function GetPressed(ply)
	if StreamRadioLib.Util.GameIsPaused() then
		return false
	end

	if StreamRadioLib.VR.IsActive(ply) then
		-- Only allow if there is no focus on any menu
		if StreamRadioLib.VR.MenuIsOpen() then
			return false
		end

		-- Check if trigger is pressed
		if StreamRadioLib.VR.GetTriggerPressed() then
			return true
		end

		-- Or check if the player's right hand touches the radio
		if StreamRadioLib.VR.GetRadioTouched() then
			return true
		end

		return false
	end

	if gui.IsGameUIVisible() then
		return false
	end

	local inVehicle = ply.InVehicle and ply:InVehicle()

	local key = StreamRadioLib.GetControlKey()

	if inVehicle then
		key = StreamRadioLib.GetControlKeyVehicle()
	end

	if not key then
		return false
	end

	local pressed = input.IsButtonDown( key )
	return pressed
end

StreamRadioLib.Hook.Add("Think", "Control", function( )
	if not StreamRadioLib then return end
	if not StreamRadioLib.Loaded then return end
	if not StreamRadioLib.HasSpawnedRadios() then return end

	local ply = LocalPlayer()
	if not IsValid( ply ) then return end

	local pressed = GetPressed(ply)
	if g_pressed == pressed then return end

	if not pressed then
		ReleaseLastRadioControl()
		g_pressed = pressed
		return
	end
	g_pressed = pressed

	local trace = StreamRadioLib.Trace( ply )
	if not trace then
		ReleaseLastRadioControl()
		return
	end

	local Radio = trace.Entity
	if not IsValid( Radio ) then
		ReleaseLastRadioControl()
		return
	end

	if not Radio.__IsRadio then
		ReleaseLastRadioControl()
		return
	end

	if not Radio.Control then
		ReleaseLastRadioControl()
		return
	end

	if IsValid(g_lastradio) and Radio ~= g_lastradio then
		ReleaseLastRadioControl()
	end

	LIBNet.Start("Control")
		net.WriteBool( pressed )
	net.SendToServer()

	StreamRadioLib.Control( ply, trace, pressed )
	g_lastradio = Radio
end)

function StreamRadioLib.IsCursorEnabled()
	if StreamRadioLib.VR.IsActive() then
		return StreamRadioLib.Settings.GetConVarValue("vr_enable_cursor")
	end

	return StreamRadioLib.Settings.GetConVarValue("enable_cursor")
end

function StreamRadioLib.GetCameraViewPos(ply)
	local islocal = false

	if not IsValid(ply) then
		islocal = true
	end

	if ply == LocalPlayer() then
		islocal = true
	end

	if StreamRadioLib.VR.IsActive(ply) then
		local pos = StreamRadioLib.VR.GetCameraPos(ply)
		return pos
	end

	if not g_camPos or not islocal then
		local pos = StreamRadioLib.GetCameraPos(ply)
		return pos
	end

	return g_camPos
end

function StreamRadioLib.CalcDistanceVolume( distance, max )
	distance = distance or 0
	local threshold = 0.25
	max = math.min(max or 0, StreamRadioLib.GetMuteDistance())
	local min = (max or 0) / 3
	local fullmin = min / 4
	if min <= 0 then return 0 end
	if max <= 0 then return 0 end
	if distance > max then return 0 end
	if distance <= 0 then return 1 end
	if distance <= fullmin then return 1 end
	if distance <= min then return Lerp((distance - fullmin) / (min - fullmin), 1, threshold) end

	return Lerp((distance - min) / (max - min), threshold, 0)
end

return true


--lua/streamradio_core/client/cl_settings.lua:
local StreamRadioLib = StreamRadioLib

StreamRadioLib.Settings = StreamRadioLib.Settings or {}

local LIB = StreamRadioLib.Settings
table.Empty(LIB)

LIB.g_CV =  {}
LIB.g_CV_CMD = {}
LIB.g_CV_List = {}
LIB.g_panels = LIB.g_panels or {}

function LIB.AddConVar(namespace, name, cmd, default, data)
	if not namespace then return nil end
	if not name then return nil end
	if not cmd then return nil end
	if not default then return nil end
	if not data then return nil end

	local CV = StreamRadioLib.CreateOBJ("clientconvar")
	CV:SetName(name)
	CV:SetCMD(cmd)

	CV:SetType(data.type)
	CV:SetMin(data.min)
	CV:SetMax(data.max)
	CV:SetOptions(data.options)

	CV:SetDefault(default)

	if data.save ~= nil then
		CV:SetSave(data.save)
	end

	if data.userdata ~= nil then
		CV:SetUserdata(data.userdata)
	end

	if data.help ~= nil then
		CV:SetHelptext(data.help)
	end

	if data.hidden ~= nil then
		CV:SetHidden(data.hidden)
	end

	if data.disabled ~= nil then
		CV:SetDisabled(data.disabled)
	end

	CV:SetPanellabel(data.label)
	CV:Setup()

	LIB.g_CV[name] = CV
	LIB.g_CV_CMD[cmd] = CV
	LIB.g_CV_List[namespace] = LIB.g_CV_List[namespace] or {}
	table.insert(LIB.g_CV_List[namespace], CV)

	return CV
end

function LIB.GetConVar(name)
	name = tostring(name or "")
	return LIB.g_CV[name] or LIB.g_CV_CMD[name]
end

function LIB.GetConVarValue(name)
	local CV = LIB.GetConVar(name)
	if not CV then return nil end

	return CV:GetValue()
end

function LIB.SetConVarValue(name, ...)
	local CV = LIB.GetConVar(name)
	if not CV then return end

	CV:SetValue(...)
end

function LIB.GetConVarListByNamespace(namespace)
	namespace = tostring(namespace or "")
	return LIB.g_CV_List[namespace] or {}
end

function LIB.AddBuildMenuPanelHook(namespace, title, buildFunction)
	namespace = tostring(namespace or "")
	title = tostring(title or "")

	StreamRadioLib.Hook.Add("PopulateToolMenu", "SettingsPanel_" .. namespace, function()
		spawnmenu.AddToolMenuOption( "Utilities", "Stream Radio", "StreamRadioSettingsPanel_" .. namespace, title, "", "", buildFunction, {} )
	end)
end

return true


--lua/streamradio_core/client/cl_vgui_editor.lua:
return gluapack()()
--lua/streamradio_core/interfaces/file.lua:
return gluapack()()
--lua/streamradio_core/filesystem/_generic.lua:
return gluapack()()
--lua/streamradio_core/filesystem/json.lua:
local RADIOFS = RADIOFS
if not istable( RADIOFS ) then
	StreamRadioLib.Filesystem.Load()
	return
end

RADIOFS.name = "JSON"
RADIOFS.type = "json"
RADIOFS.extension = "json"
RADIOFS.icon = StreamRadioLib.GetPNGIcon("table_sound", true)

RADIOFS.priority = 2000
RADIOFS.loadToWhitelist = true

function RADIOFS:Read(globalpath, vpath, callback)
	file.AsyncRead(globalpath, "DATA", function(fileName, gamePath, status, data)
		if status ~= FSASYNC_OK then
			callback(false, nil)
			return
		end

		local RawPlaylist = string.Trim(data or "")
		if RawPlaylist == "" then
			callback(true, {})
			return
		end

		local Playlist = StreamRadioLib.JSON.Decode(RawPlaylist) or {}

		callback(true, Playlist)
	end)

	return true
end

function RADIOFS:Write(globalpath, vpath, data, callback)
	if not self:CreateDirectoryForFile(globalpath) then
		callback(false)
		return false
	end

	local f = file.Open(globalpath, "w", "DATA")
	if not f then
		callback(false)
		return false
	end

	local DataString = StreamRadioLib.JSON.Encode(data)
	DataString = string.Trim(DataString)
	DataString = DataString .. "\n\n"

	f:Write(DataString)
	f:Close()

	callback(true)
	return true
end

return true


--lua/svmod/config/sh_config.lua:
return gluapack()()
--lua/svmod/gui/cl_circles.lua:
if SERVER then return false end

local _R = debug.getregistry()
if _R.SVMODCircles then return _R.SVMODCircles end

local CIRCLE = {}
CIRCLE.__index = CIRCLE

CIRCLE_FILLED = 0
CIRCLE_OUTLINED = 1
CIRCLE_BLURRED = 2

local New
do
	local err_number = "bad argument #%i to 'New' (number expected, got %s)"

	function New(t, r, x, y, ...)
		assert(isnumber(t), string.format(err_number, 1, type(t)))
		assert(isnumber(r), string.format(err_number, 2, type(r)))
		assert(isnumber(x), string.format(err_number, 3, type(x)))
		assert(isnumber(y), string.format(err_number, 4, type(y)))

		local circle = setmetatable({}, CIRCLE)

		circle:SetType(t)
		circle:SetRadius(r)
		circle:SetX(x)
		circle:SetY(y)

		circle:SetVertices({ Count = 0 })

		if t == CIRCLE_OUTLINED then
			local outline_width = ...
			assert(outline_width == nil or isnumber(outline_width), string.format(err_number, 5, type(outline_width)))

			circle:SetOutlineWidth(outline_width)
		elseif t == CIRCLE_BLURRED then
			local blur_layers, blur_density = ...
			assert(blur_layers == nil or isnumber(blur_layers), string.format(err_number, 5, type(blur_layers)))
			assert(blur_density == nil or isnumber(blur_density), string.format(err_number, 6, type(blur_density)))

			circle:SetBlurLayers(blur_layers)
			circle:SetBlurDensity(blur_density)
		end

		return circle
	end
end

local RotateVertices
do
	local err_table = "bad argument #1 to 'RotateVertices' (table expected, got %s)"
	local err_number = "bad argument #%i to 'RotateVertices' (number expected, got %s)"

	function RotateVertices(vertices, ox, oy, rotation, rotate_uv)
		assert(istable(vertices), string.format(err_table, type(vertices)))
		assert(isnumber(ox), string.format(err_number, 2, type(ox)))
		assert(isnumber(oy), string.format(err_number, 3, type(oy)))
		assert(isnumber(rotation), string.format(err_number, 4, type(rotation)))

		local rotation = math.rad(rotation)
		local c = math.cos(rotation)
		local s = math.sin(rotation)

		for i = 1, vertices.Count or #vertices do
			local vertex = vertices[i]
			local vx, vy = vertex.x, vertex.y

			vx = vx - ox
			vy = vy - oy

			vertex.x = ox + (vx * c - vy * s)
			vertex.y = oy + (vx * s + vy * c)

			if rotate_uv == false then
				local u, v = vertex.u, vertex.v
				u, v = u - 0.5, v - 0.5

				vertex.u = 0.5 + (u * c - v * s)
				vertex.v = 0.5 + (u * s + v * c)
			end
		end
	end
end

local CalculateVertices
do
	local err_number = "bad argument #%i to 'CalculateVertices' (number expected, got %s)"

	function CalculateVertices(x, y, radius, rotation, start_angle, end_angle, distance, rotate_uv)
		assert(isnumber(x), string.format(err_number, 1, type(x)))
		assert(isnumber(y), string.format(err_number, 2, type(y)))
		assert(isnumber(radius), string.format(err_number, 3, type(radius)))
		assert(isnumber(rotation), string.format(err_number, 4, type(rotation)))
		assert(isnumber(start_angle), string.format(err_number, 5, type(start_angle)))
		assert(isnumber(end_angle), string.format(err_number, 6, type(end_angle)))
		assert(isnumber(distance), string.format(err_number, 7, type(distance)))

		local vertices = { Count = 0 }
		local step = distance / radius

		local count = 0

		local rad_start_angle = math.rad(start_angle)
		local rad_end_angle = math.rad(end_angle)
		local rad_rotation = math.rad(rotation)

		for a = rad_start_angle, rad_end_angle + step, step do
			a = math.min(a, rad_end_angle)

			local c = math.cos(a + rad_rotation)
			local s = math.sin(a + rad_rotation)

			local vertex = {
				x = x + c * radius,
				y = y + s * radius,
			}

			if rotate_uv == false then
				vertex.u = 0.5 + math.cos(a) / 2
				vertex.v = 0.5 + math.sin(a) / 2
			else
				vertex.u = 0.5 + c / 2
				vertex.v = 0.5 + s / 2
			end

			vertices.Count = vertices.Count + 1
			vertices[vertices.Count] = vertex

			count = count + 1
			if count > 250 then
				SVMOD:PrintConsole(SVMOD.LOG.Alert,"svmod warning anti-crash (step = " .. step .. ", iterations= " .. ((rad_end_angle + step - rad_start_angle) / step) .. "), report it to TomLaVachette please!")
				break
			end
		end

		if end_angle - start_angle ~= 360 then
			table.insert(vertices, 1, {
				x = x, y = y,
				u = 0.5, v = 0.5,
			})

			vertices.Count = vertices.Count + 1
		else
			table.remove(vertices)
			vertices.Count = vertices.Count - 1
		end

		return vertices
	end
end

function CIRCLE:__tostring()
	return string.format("Circle: %p", self)
end

function CIRCLE:Copy()
	return table.Copy(self)
end

function CIRCLE:IsValid()
	return (
		not self.m_Dirty and
			self.m_Vertices.Count >= 3 and
			self.m_Radius >= 1 and
			self.m_Distance >= 1
	)
end

function CIRCLE:Calculate()
	local rotate_uv = self.m_RotateMaterial

	local radius = self.m_Radius
	local x, y = self.m_X, self.m_Y

	local rotation = self.m_Rotation
	local start_angle = self.m_StartAngle
	local end_angle = self.m_EndAngle

	local distance = self.m_Distance

	assert(radius >= 1, string.format("circle radius should be >= 1 (%.4f)", radius))
	assert(distance >= 1, string.format("circle distance should be >= 1 (%.4f)", distance))

	self:SetVertices(CalculateVertices(x, y, radius, rotation, start_angle, end_angle, distance, rotate_uv))

	if self.m_Type == CIRCLE_OUTLINED then
		local inner = self.m_ChildCircle or self:Copy()
		local inner_r = radius - self.m_OutlineWidth

		if inner_r >= radius then
			self:SetShouldRender(false)
		else
			if inner_r >= 1 then
				inner:SetType(CIRCLE_FILLED)

				inner:SetRadius(inner_r)
				inner:SetAngles(start_angle, end_angle)

				inner:SetColor(false)
				inner:SetMaterial(false)

				inner:SetShouldRender(true)
			else
				inner:SetShouldRender(false)
			end

			self:SetShouldRender(true)
		end

		self:SetChildCircle(inner)
	elseif self.m_ChildCircle then
		self.m_ChildCircle = nil
	end

	self:SetDirty(false)
end

do
	local blur = Material("pp/blurscreen")

	function CIRCLE:__call()
		if self.m_Dirty then
			self:Calculate()
		end

		if not self.m_ShouldRender or not self:IsValid() then
			return false
		end

		do
			local col, mat = self.m_Color, self.m_Material

			if IsColor(col) then
				if col.a <= 0 then return end
				surface.SetDrawColor(col.r, col.g, col.b, col.a)
			end

			if mat == true then
				draw.NoTexture()
			elseif TypeID(mat) == TYPE_MATERIAL then
				surface.SetMaterial(mat)
			end
		end

		if self.m_Type == CIRCLE_OUTLINED then
			render.ClearStencil()

			render.SetStencilEnable(true)
			render.SetStencilTestMask(0xFF)
			render.SetStencilWriteMask(0xFF)
			render.SetStencilReferenceValue(0x01)

			render.SetStencilCompareFunction(STENCIL_NEVER)
			render.SetStencilFailOperation(STENCIL_REPLACE)
			render.SetStencilZFailOperation(STENCIL_REPLACE)

			self.m_ChildCircle()

			render.SetStencilCompareFunction(STENCIL_GREATER)
			render.SetStencilFailOperation(STENCIL_KEEP)
			render.SetStencilZFailOperation(STENCIL_KEEP)

			surface.DrawPoly(self.m_Vertices)
			render.SetStencilEnable(false)
		elseif self.m_Type == CIRCLE_BLURRED then
			render.ClearStencil()

			render.SetStencilEnable(true)
			render.SetStencilTestMask(0xFF)
			render.SetStencilWriteMask(0xFF)
			render.SetStencilReferenceValue(0x01)

			render.SetStencilCompareFunction(STENCIL_NEVER)
			render.SetStencilFailOperation(STENCIL_REPLACE)
			render.SetStencilZFailOperation(STENCIL_REPLACE)

			surface.DrawPoly(self.m_Vertices)

			render.SetStencilCompareFunction(STENCIL_LESSEQUAL)
			render.SetStencilFailOperation(STENCIL_KEEP)
			render.SetStencilZFailOperation(STENCIL_KEEP)

			surface.SetMaterial(blur)

			local sw, sh = ScrW(), ScrH()

			for i = 1, self.m_BlurLayers do
				blur:SetFloat("$blur", (i / self.m_BlurLayers) * self.m_BlurDensity)
				blur:Recompute()

				render.UpdateScreenEffectTexture()
				surface.DrawTexturedRect(0, 0, sw, sh)
			end
			render.SetStencilEnable(false)
		else
			surface.DrawPoly(self.m_Vertices)
		end

		return true
	end
end

do
	local err_number = "bad argument #%i to 'Translate' (number expected, got %s)"

	function CIRCLE:Translate(x, y)
		assert(isnumber(x), string.format(err_number, 1, type(x)))
		assert(isnumber(y), string.format(err_number, 2, type(y)))
		if x == 0 and y == 0 then return end

		self.m_X = self.m_X + x
		self.m_Y = self.m_Y + y

		if not self:IsValid() then return end

		for i = 1, self.m_Vertices.Count do
			local vertex = self.m_Vertices[i]

			vertex.x = vertex.x + x
			vertex.y = vertex.y + y
		end

		if self.m_Type == CIRCLE_OUTLINED and self.m_ChildCircle then
			self.m_ChildCircle:Translate(x, y)
		end
	end
end

do
	local err_number = "bad argument #1 to 'Scale' (number expected, got %s)"

	function CIRCLE:Scale(scale)
		assert(isnumber(scale), string.format(err_number, type(scale)))
		if scale == 1 then return end

		self.m_Radius = self.m_Radius * scale

		if not self:IsValid() then return end

		local x, y = self.m_X, self.m_Y

		for i = 1, self.m_Vertices.Count do
			local vertex = self.m_Vertices[i]

			vertex.x = x + (vertex.x - x) * scale
			vertex.y = y + (vertex.y - y) * scale
		end

		if self.m_Type == CIRCLE_OUTLINED and self.m_ChildCircle then
			self.m_ChildCircle:Scale(scale)
		end
	end
end

do
	local err_number = "bad argument #1 to 'Rotate' (number expected, got %s)"

	function CIRCLE:Rotate(rotation)
		assert(isnumber(rotation), string.format(err_number, type(rotation)))
		if rotation == 0 then return end

		self.m_Rotation = self.m_Rotation + rotation

		if not self:IsValid() then return end

		local x, y = self.m_X, self.m_Y
		local vertices = self.m_Vertices
		local rotate_uv = self.m_RotateMaterial

		RotateVertices(vertices, x, y, rotation, rotate_uv)

		if self.m_Type == CIRCLE_OUTLINED and self.m_ChildCircle then
			self.m_ChildCircle:Rotate(rotation)
		end
	end
end

do
	local function AccessorFunc(name, default, dirty, callback)
		local varname = "m_" .. name

		CIRCLE["Get" .. name] = function(self)
			return self[varname]
		end

		CIRCLE["Set" .. name] = function(self, value)
			if default ~= nil and value == nil then
				value = default
			end

			if self[varname] ~= value then
				if dirty then
					self[dirty] = true
				end

				if isfunction(callback) then
					local new = callback(self, self[varname], value)
					value = new ~= nil and new or value
				end

				self[varname] = value
			end
		end

		CIRCLE[varname] = default
	end

	local function OffsetVerticesX(circle, old, new)
		if not circle:IsValid() then return end

		circle:Translate(new - old, 0)

		if circle.m_Type == CIRCLE_OUTLINED and circle.m_ChildCircle then
			OffsetVerticesX(circle.m_ChildCircle, old, new)
		end

		return new
	end

	local function OffsetVerticesY(circle, old, new)
		if not circle:IsValid() then return end

		circle:Translate(0, new - old)

		if circle.m_Type == CIRCLE_OUTLINED and circle.m_ChildCircle then
			OffsetVerticesY(circle.m_ChildCircle, old, new)
		end

		return new
	end

	local function UpdateRotation(circle, old, new)
		if not circle:IsValid() then return end

		local vertices = circle.m_Vertices
		local x, y = circle.m_X, circle.m_Y
		local rotation = new - old
		local rotate_uv = circle.m_RotateMaterial

		RotateVertices(vertices, x, y, rotation, rotate_uv)

		if circle.m_Type == CIRCLE_OUTLINED and circle.m_ChildCircle then
			UpdateRotation(circle.m_ChildCircle, old, new)
		end

		return new
	end

	-- These are set internally. Only use them if you know what you're doing.
	AccessorFunc("Dirty", true)
	AccessorFunc("Vertices", false)
	AccessorFunc("ChildCircle", false)
	AccessorFunc("ShouldRender", true)

	AccessorFunc("Color", false)                -- The colour you want the circle to be. If set to false then surface.SetDrawColor's can be used.
	AccessorFunc("Material", false)                -- The material you want the circle to render. If set to false then surface.SetMaterial can be used.
	AccessorFunc("RotateMaterial", true)            -- Sets whether or not the circle's UV points should be rotated with the vertices.

	AccessorFunc("Type", CIRCLE_FILLED, "m_Dirty")        -- The circle's type.
	AccessorFunc("X", 0, false, OffsetVerticesX)        -- The circle's X position relative to the top left of the screen.
	AccessorFunc("Y", 0, false, OffsetVerticesY)        -- The circle's Y position relative to the top left of the screen.
	AccessorFunc("Radius", 8, "m_Dirty")            -- The circle's radius.
	AccessorFunc("Rotation", 0, false, UpdateRotation)    -- The circle's rotation, measured in degrees.
	AccessorFunc("StartAngle", 0, "m_Dirty")        -- The circle's start angle, measured in degrees.
	AccessorFunc("EndAngle", 360, "m_Dirty")        -- The circle's end angle, measured in degrees.
	AccessorFunc("Distance", 10, "m_Dirty")            -- The maximum distance between each of the circle's vertices. Set to false to use segments instead. This should typically be used for large circles in 3D2D.

	AccessorFunc("BlurLayers", 3)                -- The circle's blur layers if Type is set to CIRCLE_BLURRED.
	AccessorFunc("BlurDensity", 2)                -- The circle's blur density if Type is set to CIRCLE_BLURRED.
	AccessorFunc("OutlineWidth", 10, "m_Dirty")        -- The circle's outline width if Type is set to CIRCLE_OUTLINED.

	function CIRCLE:SetPos(x, y)
		x = tonumber(x) or 0
		y = tonumber(y) or 0

		self:Translate(x - self.m_X, y - self.m_Y)
	end

	function CIRCLE:SetAngles(s, e)
		s = tonumber(s) or self.m_StartAngle
		e = tonumber(e) or self.m_EndAngle

		self:SetDirty(self.m_Dirty or s ~= self.m_StartAngle or e ~= self.m_EndAngle)

		self.m_StartAngle = s
		self.m_EndAngle = e
	end

	function CIRCLE:GetPos()
		return self.m_X, self.m_Y
	end

	function CIRCLE:GetAngles()
		return self.m_StartAngle, self.m_EndAngle
	end
end

_R.SVMODCircles = {
	_MT = CIRCLE,

	New = New,
	RotateVertices = RotateVertices,
	CalculateVertices = CalculateVertices,
}

return _R.SVMODCircles
--lua/svmod/gui/editor/cl_general.lua:
function SVMOD:EDITOR_General(panel, veh)
	panel:Clear()

	local bottomPanel = vgui.Create("DPanel", panel)
	bottomPanel:Dock(BOTTOM)
	bottomPanel:SetSize(0, 30)
	bottomPanel:SetPaintBackground(false)

	local authorTextBox
	local workshopTextBox

	local addButton = SVMOD:CreateButton(bottomPanel, "SAVE", function()
		local tab = table.Copy(veh.SV_Data)

		tab.Timestamp = nil
		tab.Author.Name = authorTextBox:GetValue()
		tab.Author.SteamID64 = LocalPlayer():SteamID64()
		tab.WorkshopID = workshopTextBox:GetValue()

		for _, v in ipairs(tab.FlashingLights) do
			if v.Sprite then
				v.Sprite.CurrentAngle = nil
			end

			if v.SpriteCircle then
				v.SpriteCircle.CurrentAngle = nil
			end
		end

		local name = "Unknown"
		for _, vehData in ipairs(SVMOD:GetVehicleList()) do
			if vehData.Model == veh:GetModel() then
				name = vehData.Name .. " (" .. vehData.Category .. ")"
				break
			end
		end

		HTTP({
			url = "https://api.svmod.com/add_vehicle.php",
			method = "POST",
			body = util.TableToJSON({
				name = name,
				model = veh:GetModel(),
				json = util.TableToJSON(tab),
				version = tostring(SVMOD.FCFG.DataVersion),
				serial = SVMOD.CFG.Contributor.Key,
				enterpriseID = SVMOD.CFG.Contributor.EnterpriseID
			}),
			success = function(code, body)
				if code == 200 then
					notification.AddLegacy("Data was sent successfully.", NOTIFY_GENERIC, 5)

					SVMOD:SetAddonState(false)
					timer.Simple(1, function()
						SVMOD:SetAddonState(true)
					end)
				else
					notification.AddLegacy("Invalid API key.", NOTIFY_ERROR, 5)
				end

				if IsValid(panel:GetParent()) then
					panel:GetParent():ManualClose()
				end
			end,
			failed = function()
				notification.AddLegacy("Server does not respond.", NOTIFY_ERROR, 5)
			end
		})
	end)
	addButton:Dock(RIGHT)

	local focusButton = SVMOD:CreateButton(bottomPanel, "FOCUS", function(btn)
		local frame = panel:GetParent()

		if btn:GetText() == "UNFOCUS" then
			frame:DisableFocus()
			btn:SetText("FOCUS")
		else
			frame:EnableFocus()
			btn:SetText("UNFOCUS")
		end
	end)
	focusButton:Dock(RIGHT)
	focusButton:DockMargin(0, 0, 10, 0)

	SVMOD:CreateTitle(panel, "INFORMATIONS")

	local function createField(name, value)
		local authorPanel = vgui.Create("DPanel", panel)
		authorPanel:Dock(TOP)
		authorPanel:DockMargin(0, 4, 0, 4)
		authorPanel:SetSize(0, 30)
		authorPanel:SetPaintBackground(false)

		local label = vgui.Create("DLabel", authorPanel)
		label:SetPos(2, 4)
		label:SetFont("SV_Calibri18")
		label:SetText(name)
		label:SizeToContents()

		textBox = SVMOD:CreateTextboxPanel(authorPanel, name)
		textBox:SetValue(value or "")

		return textBox
	end

	authorTextBox = createField(language.GetPhrase("svmod.vehicles.author"), veh.SV_Data.Author.Name or "")
	workshopTextBox = createField(language.GetPhrase("svmod.editor.workshop"), veh.SV_Data.WorkshopID or "")

	local label = vgui.Create("DLabel", panel)
	label:Dock(TOP)
	label:DockMargin(0, 5, 0, 0)
	label:SetFont("SV_Calibri18")
	if SVMOD.CFG.Contributor.EnterpriseID == 0 then
		label:SetText(language.GetPhrase("svmod.editor.dbpublic"))
	else
		label:SetText(language.GetPhrase("svmod.editor.dbprivate") .. SVMOD.CFG.Contributor.EnterpriseID .. ").")
	end
	label:SizeToContents()

	local title = SVMOD:CreateTitle(panel, "TOOLS")
	title:DockMargin(0, 30, 0, 0)

	local blinkerPanel = vgui.Create("DPanel", panel)
	blinkerPanel:Dock(TOP)
	blinkerPanel:SetSize(0, 35)
	blinkerPanel:SetPaintBackground(false)

	local function symmetric(tab)
		for k, v in pairs(tab) do
			if istable(v) then
				symmetric(v)
			elseif isvector(v) then
				tab[k].x = -v.x
			end
		end
	end

	local blinkerButton = SVMOD:CreateButton(blinkerPanel, "COPY LEFT BLINKERS TO RIGHT", function()
		for _, l in ipairs(veh.SV_Data.Blinkers.LeftLights) do
			local tab = SVMOD:DeepCopy(l)
			symmetric(tab)
			table.insert(veh.SV_Data.Blinkers.RightLights, tab)
		end
	end)
	blinkerButton:SetSize(340, 0)
	blinkerButton:Dock(LEFT)

	local blinkerButton = SVMOD:CreateButton(blinkerPanel, "COPY RIGHT BLINKERS TO LEFT", function()
		for _, l in ipairs(veh.SV_Data.Blinkers.RightLights) do
			local tab = SVMOD:DeepCopy(l)
			symmetric(tab)
			table.insert(veh.SV_Data.Blinkers.LeftLights, tab)
		end
	end)
	blinkerButton:SetSize(340, 0)
	blinkerButton:Dock(RIGHT)

	local blinkerButton = SVMOD:CreateButton(panel, "COPY BRAKE TO HEADLIGHTS", function()
		for _, l in ipairs(veh.SV_Data.Back.BrakeLights) do
			local tab = SVMOD:DeepCopy(l)
			table.insert(veh.SV_Data.Headlights, tab)
		end
		surface.PlaySound("buttons/button14.wav")
		notification.AddLegacy("Brake lights copied to headlights.", NOTIFY_GENERIC, 3)
	end)
	blinkerButton:SetSize(0, 35)
	blinkerButton:Dock(TOP)
	blinkerButton:DockMargin(0, 10, 0, 0)

	local blinkerButton = SVMOD:CreateButton(panel, "COPY BRAKE TO REVERSING", function()
		for _, l in ipairs(veh.SV_Data.Back.BrakeLights) do
			local tab = SVMOD:DeepCopy(l)
			table.insert(veh.SV_Data.Back.ReversingLights, tab)
		end
		surface.PlaySound("buttons/button14.wav")
		notification.AddLegacy("Brake lights copied to reversing lights.", NOTIFY_GENERIC, 3)
	end)
	blinkerButton:SetSize(0, 35)
	blinkerButton:Dock(TOP)
	blinkerButton:DockMargin(0, 10, 0, 0)
end
--lua/svmod/gui/editor/cl_sounds.lua:
return gluapack()()
--lua/svmod/gui/settings/cl_shortcut.lua:
function SVMOD:GUI_Shortcuts(panel)
	panel:Clear()

	local headerPanel = vgui.Create("DPanel", panel)
	headerPanel:Dock(TOP)
	headerPanel:SetSize(0, 20)
	headerPanel:SetPaintBackground(false)

	local titleLabel = vgui.Create("DLabel", headerPanel)
	titleLabel:SetPos(0, 0)
	titleLabel:SetFont("SV_CalibriLight22")
	titleLabel:SetColor(Color(178, 95, 245))
	titleLabel:SetText(language.GetPhrase("svmod.shortcuts.shortcuts"))
	titleLabel:SizeToContents()

	SVMOD:CreateHorizontalLine(panel)

	local function createSetting(text, data)
		local settingPanel = vgui.Create("DPanel", panel)
		settingPanel:Dock(TOP)
		settingPanel:DockMargin(0, 4, 0, 4)
		settingPanel:SetSize(0, 30)
		settingPanel:SetPaintBackground(false)

		local label = vgui.Create("DLabel", settingPanel)
		label:SetPos(2, 4)
		label:SetFont("SV_Calibri18")
		label:SetText(text)
		label:SizeToContents()

		local button = vgui.Create("DBinder", settingPanel)
		button:Dock(RIGHT)
		button:DockMargin(8, 0, 0, 0)
		button:SetSize(100, 0)
		button.OnChange = function(self, value)
			self:SetText(string.upper(input.GetKeyName(value) or "NONE"))

			data.Key = self:GetValue() or "NONE"

			SVMOD:Save()
		end
		button.Paint = function(self, w, h)
			surface.SetDrawColor(12, 22, 24)
			surface.DrawRect(0, 0, w, h)

			local color

			if self:IsHovered() then
				if not self.soundPlayed then
					surface.PlaySound("garrysmod/ui_hover.wav")
					self.soundPlayed = true
				end

				color = Color(237, 197, 255)
			else
				self.soundPlayed = false

				color = Color(154, 128, 166)
			end

			surface.SetDrawColor(color.r, color.g, color.b)

			surface.DrawRect(3, 3, 7, 1)
			surface.DrawRect(3, 3, 1, 7)

			surface.DrawRect(w - 3 - 7, 3, 7, 1)
			surface.DrawRect(w - 3, 3, 1, 7)

			surface.DrawRect(3, h - 3, 7, 1)
			surface.DrawRect(3, h - 3 - 7, 1, 7)

			surface.DrawRect(w - 3 - 7, h - 3, 7, 1)
			surface.DrawRect(w - 3, h - 3 - 7, 1, 7)

			draw.SimpleText(self:GetText(), "SV_CalibriLight18", w / 2, h / 2, color, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

			return true
		end

		return button
	end

	for i, s in ipairs(SVMOD.Shortcuts) do
		local button = createSetting(language.GetPhrase(s.Name), s)
		button:SetValue(s.Key)
	end

	SVMOD:CreateHorizontalLine(panel)

	local bottomPanel = vgui.Create("DPanel", panel)
	bottomPanel:Dock(TOP)
	bottomPanel:DockMargin(0, 4, 0, 4)
	bottomPanel:SetSize(0, 30)
	bottomPanel:SetPaintBackground(false)

	local buttonText = language.GetPhrase("svmod.reset")

	local button = vgui.Create("DButton", bottomPanel)
	button:Dock(RIGHT)
	button:DockMargin(8, 0, 0, 0)
	button:SetSize(100, 0)
	button:SetText("")
	button.DoClick = function(self)
		for i, _ in ipairs(SVMOD.Shortcuts) do
			SVMOD.Shortcuts[i].Key = SVMOD.Shortcuts[i].DefaultKey
		end
		panel:GetParent():Remove()
		LocalPlayer():ConCommand("svmod")
	end
	button.Paint = function(self, w, h)
		surface.SetDrawColor(12, 22, 24)
		surface.DrawRect(0, 0, w, h)

		local color

		if self:IsHovered() then
			if not self.soundPlayed then
				surface.PlaySound("garrysmod/ui_hover.wav")
				self.soundPlayed = true
			end

			color = Color(237, 197, 255)
		else
			self.soundPlayed = false

			color = Color(154, 128, 166)
		end

		surface.SetDrawColor(color.r, color.g, color.b)

		surface.DrawRect(3, 3, 7, 1)
		surface.DrawRect(3, 3, 1, 7)

		surface.DrawRect(w - 3 - 7, 3, 7, 1)
		surface.DrawRect(w - 3, 3, 1, 7)

		surface.DrawRect(3, h - 3, 7, 1)
		surface.DrawRect(3, h - 3 - 7, 1, 7)

		surface.DrawRect(w - 3 - 7, h - 3, 7, 1)
		surface.DrawRect(w - 3, h - 3 - 7, 1, 7)

		draw.SimpleText(buttonText, "SV_CalibriLight18", w / 2, h / 2, color, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
	end
end
--lua/svmod/health/cl_parts.lua:
return gluapack()()
--lua/svmod/health/cl_repair.lua:
-- A player starts a car repair
net.Receive("SV_StartRepair", function()
	local veh = net.ReadEntity()
	if not IsValid(veh) then return end

	local ply = net.ReadEntity()
	if not IsValid(ply) then return end

	ply:EmitSound("svmod/repair/wrench" .. math.random(1, 4) .. ".wav", 60)

	timer.Create("SV_RepairVehicle_" .. ply:UserID(), 1, 0, function()
		if IsValid(ply) then
			ply:EmitSound("svmod/repair/wrench" .. math.random(1, 4) .. ".wav", 60)
		end
	end)
end)

net.Receive("SV_StopRepair", function()
	local ply = net.ReadEntity()
	if not IsValid(ply) then return end

	timer.Remove("SV_RepairVehicle_" .. ply:UserID())
end)
--lua/svmod/health/sh_health.lua:
return gluapack()()
--lua/svmod/lights/hazardlights/sh_hazardlights.lua:
-- @class SV_Vehicle
-- @shared

-- Returns the state of the vehicle's left turn signals.
-- @treturn boolean True if enabled, false if disabled
function SVMOD.Metatable:SV_GetHazardLightsState()
	if self:SV_IsPassengerSeat() then
		return self:SV_GetDriverSeat().SV_States.HazardLights
	end
	return self.SV_States.HazardLights
end
--lua/svmod/lights/headlights/cl_headlights.lua:
return gluapack()()
--lua/svmod/seats/sh_seats.lua:
--[[---------------------------------------------------------
   Name: SV_Vehicle:SV_IsDriverSeat()
   Type: Shared
   Desc: Returns true if it is a driver seat, false
		 otherwise.
-----------------------------------------------------------]]
function SVMOD.Metatable:SV_IsDriverSeat()
	-- return not self:SV_IsPassengerSeat()
	return self.SV_Data ~= nil
end

--[[---------------------------------------------------------
   Name: SV_Vehicle:SV_GetDriverSeat()
   Type: Shared
   Desc: Returns the driver seat of the vehicle, self if the
		 vehicle is already the driver seat.
-----------------------------------------------------------]]
function SVMOD.Metatable:SV_GetDriverSeat()
	local parent = self:GetParent()

	if IsValid(parent) and SVMOD:IsVehicle(parent) then
		return parent
	end

	return self
end

--[[---------------------------------------------------------
   Name: SV_Vehicle:SV_IsPassengerSeat()
   Type: Shared
   Desc: Returns true if it is a passenger seat, false
		 otherwise.
-----------------------------------------------------------]]
function SVMOD.Metatable:SV_IsPassengerSeat()
	-- return IsValid(self:GetParent()) and self:GetParent():IsVehicle()
	return self.SV_Data == nil
end

--[[---------------------------------------------------------
   Name: SV_Vehicle:SV_GetPassengerSeats()
   Type: Shared
   Desc: Returns a list of all passenger seats of the
		 vehicle. Returns a list of all passenger seats of
		 the vehicle. Seats with no seated player are not
		 created, and therefore cannot be included in this
		 table.
-----------------------------------------------------------]]
function SVMOD.Metatable:SV_GetPassengerSeats()
	local passengerSeats = {}

	for _, child in ipairs(self:SV_GetDriverSeat():GetChildren()) do
		if child:GetClass() == "prop_vehicle_prisoner_pod" then
			table.insert(passengerSeats, child)
		end
	end

	return passengerSeats
end

--[[---------------------------------------------------------
   Name: SV_Vehicle:SV_GetAllPlayers()
   Type: Shared
   Desc: Returns a table with the driver and passengers of a
		 vehicle.
-----------------------------------------------------------]]
function SVMOD.Metatable:SV_GetAllPlayers()
	local players = {}

	if IsValid(self:SV_GetDriverSeat():GetDriver()) then
		table.insert(players, self:SV_GetDriverSeat():GetDriver())
	end

	for _, veh in ipairs(self:SV_GetPassengerSeats()) do
		if IsValid(veh:GetDriver()) then
			table.insert(players, veh:GetDriver())
		end
	end

	return players
end
--lua/autorun/tdmcars_bmw.lua:
return gluapack()()
--lua/autorun/tdmcars_porcayenne12.lua:
local V = {
			Name = "Porsche Cayenne Turbo 12", 
			Class = "prop_vehicle_jeep",
			Category = "TDM Cars",
			Author = "TheDanishMaster, Turn 10",
			Information = "A drivable Porsche Cayenne Turbo 12 by TheDanishMaster",
			Model = "models/tdmcars/por_cayenne12.mdl",
			KeyValues = {
							vehiclescript	=	"scripts/vehicles/TDMCars/cayenne12.txt"
							}
			}
list.Set("Vehicles", "cayenne12tdm", V)
--addons/turkish_food_mod-main/lua/autorun/tfm_darkrp_things.lua:
hook.Add("loadCustomDarkRPItems", "TFM_DarkrpThings", function()
    local color_red = Color(20, 150, 20, 255)
    DarkRP.createCategory{
        name = "Turkish Food Mod",
        categorises = "jobs",
        startExpanded = true,
        color = color_red,
        canSee = function(ply) return true end,
        sortOrder = 100,
    }

    DarkRP.createCategory{
        name = "Turkish Food Mod / Yemekler",
        categorises = "entities",
        startExpanded = true,
        color = color_red,
        canSee = function(ply)
            return ply:Team() == TEAM_ASCI or TEAM_BAKKAL
        end,
        sortOrder = 100,
    }

    DarkRP.createCategory{
        name = "Turkish Food Mod / İçecekler",
        categorises = "entities",
        startExpanded = true,
        color = color_red,
        canSee = function(ply)
            return ply:Team() == TEAM_ASCI or TEAM_BAKKAL
        end,
        sortOrder = 100,
    }

    DarkRP.createCategory{
        name = "Turkish Food Mod / Tezgahlar",
        categorises = "entities",
        startExpanded = true,
        color = color_red,
        canSee = function(ply)
            return ply:Team() == TEAM_DONDURMACI or TEAM_CIGKOFTECI or TEAM_PILAVCI or TEAM_BAKKAL
        end,
        sortOrder = 100,
    }

    TEAM_ASCI = DarkRP.createJob("Aşçı", {
        color = color_red,
        model = "models/ecott/chefcitizen.mdl",
        description = [[Bir aşçısın f4 menüden istediğin yemeği yapıp satabilirsin.]],
        weapons = {},
        command = "chefmeen",
        max = 1,
        salary = 1500,
        admin = 0,
        vote = false,
        hasLicense = false,
        category = "Sivil",
    })

    TEAM_DONDURMACI = DarkRP.createJob("Dondurmacı", {
        color = color_red,
        model = "models/ecott/chefcitizen.mdl",
        description = [[Bir dondurmacısın f4 menüden dondurma,külah ve stand satın alıp ticaret yapabilirsin.]],
        weapons = {},
        command = "icecreemeen",
        max = 1,
        salary = 1500,
        admin = 0,
        vote = false,
        hasLicense = false,
        category = "Sivil",
    })

    TEAM_BAKKAL = DarkRP.createJob("Bakkal", {
        color = color_red,
        model = "models/ecott/chefcitizen.mdl",
        description = [[Bir bakkalsın abur cubur ve çay satıyorsun.]],
        weapons = {},
        command = "bakkalmeen",
        max = 1,
        salary = 1500,
        admin = 0,
        vote = false,
        hasLicense = false,
        category = "Sivil",
    })

    TEAM_CIGKOFTECI = DarkRP.createJob("Çiğköfteci", {
        color = color_red,
        model = "models/ecott/chefcitizen.mdl",
        description = [[Bir çiğköftecisin acılı ve acısız çiğköfte satıyorsun.]],
        weapons = {},
        command = "koftemeen",
        max = 1,
        salary = 1500,
        admin = 0,
        vote = false,
        hasLicense = false,
        category = "Sivil",
    })

    TEAM_PILAVCI = DarkRP.createJob("Pilavcı", {
        color = color_red,
        model = "models/ecott/chefcitizen.mdl",
        description = [[Bir pilavcısın ve 3 çeşit pilav satıyorsun.]],
        weapons = {},
        command = "pilavmeen",
        max = 1,
        salary = 1500,
        admin = 0,
        vote = false,
        hasLicense = false,
        category = "Sivil",
    })

    TEAM_FIRINCI = DarkRP.createJob("Fırıncı", {
        color = color_red,
        model = "models/ecott/chefcitizen.mdl",
        description = [[Bir fırıncısın ve Ekmek,Pide ve Lahmacun satıyorsun.]],
        weapons = {},
        command = "firinmeen",
        max = 1,
        salary = 1500,
        admin = 0,
        vote = false,
        hasLicense = false,
        category = "Sivil",
    })

    DarkRP.createEntity("Adana Kebap", {
        ent = "adana",
        model = "models/foods/adanakebap/adanakebap.mdl",
        price = 3000,
        max = 0,
        allowed = TEAM_ASCI,
        cmd = "buyadana",
        category = "Turkish Food Mod / Yemekler",
    })

    DarkRP.createEntity("Mercimek Çorbası", {
        ent = "corba",
        model = "models/foods/corba/corba.mdl",
        price = 1000,
        max = 0,
        allowed = TEAM_ASCI,
        cmd = "buycorba",
        category = "Turkish Food Mod / Yemekler",
    })

    DarkRP.createEntity("Çay", {
        ent = "tea",
        model = "models/foods/tea/tea.mdl",
        price = 100,
        max = 0,
        allowed = TEAM_ASCI,
        cmd = "buytea",
        category = "Turkish Food Mod / İçecekler",
    })

    DarkRP.createEntity("Ekmek", {
        ent = "ekmek",
        model = "models/foods/ekmek/ekmek.mdl",
        price = 10,
        max = 10,
        allowed = {TEAM_ASCI, TEAM_BAKKAL},
        cmd = "buyekmek",
        category = "Turkish Food Mod / Yemekler",
    })

    DarkRP.createEntity("Lahmacun", {
        ent = "lahmacun",
        model = "models/foods/lahmacun/lahmacun.mdl",
        price = 800,
        max = 10,
        allowed = TEAM_ASCI,
        cmd = "buylahmacun",
        category = "Turkish Food Mod / Yemekler",
    })

    DarkRP.createEntity("Sucuklu Yumurta", {
        ent = "sckegg",
        model = "models/foods/sckegg/sckegg.mdl",
        price = 1500,
        max = 10,
        allowed = TEAM_ASCI,
        cmd = "buysckegg",
        category = "Turkish Food Mod / Yemekler",
    })

    DarkRP.createEntity("Patates Köfte", {
        ent = "patkof",
        model = "models/foods/patkof/patkof.mdl",
        price = 5000,
        max = 10,
        allowed = TEAM_ASCI,
        cmd = "buypatkof",
        category = "Turkish Food Mod / Yemekler",
    })

    DarkRP.createEntity("Gofret", {
        ent = "gofret",
        model = "models/foods/gofret/gofret.mdl",
        price = 1000,
        max = 10,
        allowed = TEAM_BAKKAL,
        cmd = "buygofret",
        category = "Turkish Food Mod / Yemekler",
    })
---------------------------
DarkRP.createEntity("Bomonti Filtresiz", {
    ent = "bomonti_filtresiz",
    model = "models/rebs/icikiler_sigaralar/bomonti_filtresiz_w.mdl",
    price = 10000,
    max = 10,
    allowed = TEAM_BAKKAL,
    cmd = "buybomontifiltresiz",
    category = "Turkish Food Mod / Yemekler",
})

DarkRP.createEntity("Efes Pilsen", {
    ent = "efes_pilsen",
    model = "models/rebs/icikiler_sigaralar/efes_pilsen_w.mdl",
    price = 12000,
    max = 10,
    allowed = TEAM_BAKKAL,
    cmd = "buyefespilsen",
    category = "Turkish Food Mod / İçecekler",
})

DarkRP.createEntity("Tuborg Gold", {
    ent = "tuborg_gold",
    model = "models/rebs/icikiler_sigaralar/tuborg_gold_w.mdl",
    price = 13000,
    max = 10,
    allowed = TEAM_BAKKAL,
    cmd = "buytuborggold",
    category = "Turkish Food Mod / İçecekler",
})

-- Cigarette Packet Entities
DarkRP.createEntity("Beyaz Dal Sigara Paketi", {
    ent = "weapon_ciga_paket_beyaz_dal",
    model = "models/rebs/icikiler_sigaralar/sigara_paket_beyaz_dal.mdl",
    price = 15000,
    max = 10,
    allowed = TEAM_BAKKAL,
    cmd = "buybeyazdal",
    category = "Turkish Food Mod / Sigaralar",
})

DarkRP.createEntity("Camel Yellow Long Sigara Paketi", {
    ent = "weapon_ciga_paket_camel_yellow_long",
    model = "models/rebs/icikiler_sigaralar/sigara_paket_camel_yellow_long.mdl",
    price = 16000,
    max = 10,
    allowed = TEAM_BAKKAL,
    cmd = "buycamelyellow",
    category = "Turkish Food Mod / Sigaralar",
})

DarkRP.createEntity("Kent Switch Sigara Paketi", {
    ent = "weapon_ciga_paket_kent_switch",
    model = "models/rebs/icikiler_sigaralar/sigara_paket_kent_switch.mdl",
    price = 17000,
    max = 10,
    allowed = TEAM_BAKKAL,
    cmd = "buykentswitch",
    category = "Turkish Food Mod / Sigaralar",
})

DarkRP.createEntity("LM Mode Red Sigara Paketi", {
    ent = "weapon_ciga_paket_lm_mode_red",
    model = "models/rebs/icikiler_sigaralar/sigara_paket_lm_mode_red.mdl",
    price = 15500,
    max = 10,
    allowed = TEAM_BAKKAL,
    cmd = "buylmmodered",
    category = "Turkish Food Mod / Sigaralar",
})

DarkRP.createEntity("Marlboro Red Sigara Paketi", {
    ent = "weapon_ciga_paket_marlboro_red",
    model = "models/rebs/icikiler_sigaralar/sigara_paket_marlboro_red.mdl",
    price = 18000,
    max = 10,
    allowed = TEAM_BAKKAL,
    cmd = "buymarlborored",
    category = "Turkish Food Mod / Sigaralar",
})

DarkRP.createEntity("Marlboro Touch Grey Sigara Paketi", {
    ent = "weapon_ciga_paket_marlboro_touch_grey",
    model = "models/rebs/icikiler_sigaralar/sigara_paket_marlboro_touch_grey.mdl",
    price = 18500,
    max = 10,
    allowed = TEAM_BAKKAL,
    cmd = "buymarlborotouchgrey",
    category = "Turkish Food Mod / Sigaralar",
})

DarkRP.createEntity("Muratti Rosso Sigara Paketi", {
    ent = "weapon_ciga_paket_muratti_rosso",
    model = "models/rebs/icikiler_sigaralar/sigara_paket_muratti_rosso.mdl",
    price = 16500,
    max = 10,
    allowed = TEAM_BAKKAL,
    cmd = "buymurattir",
    category = "Turkish Food Mod / Sigaralar",
})

DarkRP.createEntity("Parliament One Sigara Paketi", {
    ent = "weapon_ciga_paket_parliament_one",
    model = "models/rebs/icikiler_sigaralar/sigara_paket_parliament_one.mdl",
    price = 17500,
    max = 10,
    allowed = TEAM_BAKKAL,
    cmd = "buyparliamentone",
    category = "Turkish Food Mod / Sigaralar",
})

DarkRP.createEntity("Tekel Uzun Sigara Paketi", {
    ent = "weapon_ciga_paket_tekel_uzun",
    model = "models/rebs/icikiler_sigaralar/sigara_paket_tekel_uzun.mdl",
    price = 15000,
    max = 10,
    allowed = TEAM_BAKKAL,
    cmd = "buytekeluzun",
    category = "Turkish Food Mod / Sigaralar",
})

DarkRP.createEntity("Winston Slender Sigara Paketi", {
    ent = "weapon_ciga_paket_winston_slender",
    model = "models/rebs/icikiler_sigaralar/sigara_paket_winston_slender.mdl",
    price = 16000,
    max = 10,
    allowed = TEAM_BAKKAL,
    cmd = "buywinstonslender",
    category = "Turkish Food Mod / Sigaralar",
})

---------------------------
    DarkRP.createEntity("Şalgam", {
        ent = "salgam",
        model = "models/drinks/salgam/salgam.mdl",
        price = 350,
        max = 10,
        allowed = {TEAM_ASCI, TEAM_BAKKAL},
        cmd = "buysalgam",
        category = "Turkish Food Mod / İçecekler",
    })

    DarkRP.createEntity("Gazoz", {
        ent = "gazoz",
        model = "models/drinks/gazoz/gazoz.mdl",
        price = 1500,
        max = 10,
        allowed = {TEAM_ASCI, TEAM_BAKKAL},
        cmd = "buygazoz",
        category = "Turkish Food Mod / İçecekler",
    })

    DarkRP.createEntity("Ayran", {
        ent = "ayran",
        model = "models/drinks/ayran/ayran.mdl",
        price = 100,
        max = 10,
        allowed = {TEAM_ASCI, TEAM_BAKKAL},
        cmd = "buyayran",
        category = "Turkish Food Mod / İçecekler",
    })

    DarkRP.createEntity("Metro", {
        ent = "metro",
        model = "models/foods/metro/metro.mdl",
        price = 1000,
        max = 10,
        allowed = TEAM_BAKKAL,
        cmd = "buymero",
        category = "Turkish Food Mod / Yemekler",
    })

    DarkRP.createEntity("Hoşbeş", {
        ent = "hosbes",
        model = "models/foods/hosbes/hosbes.mdl",
        price = 1000,
        max = 10,
        allowed = TEAM_BAKKAL,
        cmd = "buyhosbes",
        category = "Turkish Food Mod / Yemekler",
    })

    DarkRP.createEntity("Dondurma Tezgahı", {
        ent = "ice-stand",
        model = "models/stands/ice_stand/ice_stand.mdl",
        price = 1500,
        max = 1,
        allowed = TEAM_DONDURMACI,
        cmd = "buyicestand",
        category = "Turkish Food Mod / Tezgahlar",
    })

    DarkRP.createEntity("Çiğköfte Tezgahı", {
        ent = "kofte_stand",
        model = "models/stands/cigkofte_stand/cigkofte_stand.mdl",
        price = 1500,
        max = 1,
        allowed = TEAM_CIGKOFTECI,
        cmd = "buykoftestand",
        category = "Turkish Food Mod / Tezgahlar",
    })

    DarkRP.createEntity("Büfe", {
        ent = "bufe",
        model = "models/stands/bakkal_stand/bakkal.mdl",
        price = 1500,
        max = 1,
        allowed = TEAM_BAKKAL,
        cmd = "buybufe",
        category = "Turkish Food Mod / Tezgahlar",
    })

    DarkRP.createEntity("Pilavcı Tezgahı", {
        ent = "pilav_stand",
        model = "models/stands/pilav_stand/pilav_stand.mdl",
        price = 5000,
        max = 1,
        allowed = TEAM_PILAVCI,
        cmd = "buypilavstand",
        category = "Turkish Food Mod / Tezgahlar",
    })

    DarkRP.createEntity("Taş Fırın", {
        ent = "stone_oven",
        model = "models/stands/stoneoven/stoneoven.mdl",
        price = 5000,
        max = 1,
        allowed = TEAM_FIRINCI,
        cmd = "buystoneoven",
        category = "Turkish Food Mod / Tezgahlar",
    })
end)

--addons/voidfactions-1.10.6/lua/autorun/voidfactions_init.lua:
return gluapack()()
--addons/voidfactions-1.10.6/lua/autorun/voidfactions_init.lua:

--[[---------------------------------------------------------
	Name: Setup
-----------------------------------------------------------]]
VoidFactions = VoidFactions or {}
VoidFactions.Config = VoidFactions.Config or {}
VoidFactions.Lang = VoidFactions.Lang or {}

function VoidFactions.Lang.GetPhrase(phrase, x)
	return VoidLib.Lang:GetLangPhrase("VoidFactions", phrase, x)
end

VoidFactions.Dir = "voidfactions"

VoidFactions.CurrentVersion = "1.10.6f"

if (CLIENT) then
	include(VoidFactions.Dir .. "/libs/cami.lua")
end

if (SERVER) then
	if (string.sub(VoidFactions.CurrentVersion, 1, 1) != "{") then
		resource.AddWorkshop("2078529432")
	end

	include("voidfactions_mysql.lua")

	include(VoidFactions.Dir .. "/libs/cami.lua")
	AddCSLuaFile(VoidFactions.Dir .. "/libs/cami.lua")
end

--[[---------------------------------------------------------
	Name: Main
-----------------------------------------------------------]]
function VoidFactions.Load(dir, svOnly, shOnly)
	local files = file.Find(dir.. "/".. "*", "LUA")

	for k, v in pairs(files) do
		if string.StartWith(v, "cl") then
			AddCSLuaFile(dir.. "/".. v)

			if CLIENT then
				local load = include(dir.. "/".. v)
				if load then load() end
			end
		end

		if string.StartWith(v, "sv") or svOnly then
			if SERVER then
				local load = include(dir.. "/".. v)
				if load then load() end
			end
		end

		if string.StartWith(v, "sh") or shOnly then
			AddCSLuaFile(dir.. "/".. v)

			local load = include(dir.. "/".. v)
			if load then load() end
		end
	end
end

function VoidFactions.LoadDirOfDirs(dir, msg, isCSDir)
	local files, dirs = file.Find(dir.. "/".. "*", "LUA")

	if (isCSDir) then
		VoidFactions.AddCSDir(dir)
	end

	for k, v in pairs(dirs) do
		if (isCSDir) then
			VoidFactions.AddCSDir(dir .. "/" .. v)
		else
			VoidFactions.Load(dir .. "/" .. v)
		end
		if (msg) then
			VoidFactions.PrintDebug(VoidLib.StringFormat(msg, v))
		end
	end
end

function VoidFactions.AddCSDir(dir)
	local files = file.Find(dir.. "/".. "*", "LUA")

	for k, v in pairs(files) do
		AddCSLuaFile(dir.. "/".. v)

		if CLIENT then
			include(dir.. "/".. v)
		end
	end
end

--[[---------------------------------------------------------
	Name: Functions (76561198314224586)
-----------------------------------------------------------]]
function VoidFactions.PrintError(...)
	MsgC(Color(192, 57, 43), "[VoidFactions] (ERROR): ", Color(255, 255, 255), ..., "\n")
end

function VoidFactions.PrintWarning(...)
	MsgC(Color(230, 126, 34), "[VoidFactions] (WARNING): ", Color(255, 255, 255), ..., "\n")
end

function VoidFactions.PrintDebug(...)
	if (!VoidFactions.Debug) then return end

	MsgC(Color(120, 255, 120), "[VoidFactions] (DEBUG): ", Color(255, 255, 255), ..., "\n")
end

function VoidFactions.Print(...)
	MsgC(Color(87, 180, 242), "[VoidFactions]: ", Color(255, 255, 255), ..., "\n")
end

--[[---------------------------------------------------------
	Name: Loading
-----------------------------------------------------------]]

local brandStr = [[
 __   __   _    _ ___        _   _             
 \ \ / /__(_)__| | __|_ _ __| |_(_)___ _ _  ___
  \ V / _ \ / _` | _/ _` / _|  _| / _ \ ' \(_-<
   \_/\___/_\__,_|_|\__,_\__|\__|_\___/_||_/__/
                                                                                                  
]]

local licenseInfo = [[
  Licensed to: 76561198314224586
  Version: 1.10.6f
]]

MsgC(Color(87, 180, 242), brandStr, Color(242, 113, 87), licenseInfo, Color(255, 255, 255), "\n")


function VoidFactions.LoadAll()
	VoidFactions.Load(VoidFactions.Dir.. "/libs")
	VoidFactions.Load(VoidFactions.Dir)

	VoidFactions.Load(VoidFactions.Dir .. "/core")

	VoidFactions.LoadDirOfDirs(VoidFactions.Dir .. "/features", "Loaded feature :module:!")

	VoidFactions.Load(VoidFactions.Dir .. "/classes")

	VoidFactions.Load(VoidFactions.Dir .. "/modules/currencies", false, true)
	hook.Run("VoidFactions.Currencies.Loaded")
	
	VoidFactions.Load(VoidFactions.Dir .. "/modules/experience", false, true)
	VoidFactions.Load(VoidFactions.Dir .. "/modules/upgrades", false, true)
	VoidFactions.Load(VoidFactions.Dir .. "/modules/rewards", false, true)
	hook.Run("VoidFactions.Rewards.Loaded")

	VoidFactions.Load(VoidFactions.Dir .. "/modules/inventories", false, true)
	hook.Run("VoidFactions.Inventories.Loaded")
	
	VoidFactions.LoadDirOfDirs(VoidFactions.Dir .. "/net", "Loaded net handler :net:!")

	VoidFactions.LoadDirOfDirs(VoidFactions.Dir .. "/vgui", "Loaded VGUI directory :vgui:!", true)
end


if (!VoidFactions.Loaded) then
	if (VoidLib) then
		VoidFactions.Print("VoidLib already loaded, loading..")
		VoidFactions.LoadAll()
	else
		VoidFactions.PrintDebug("VoidLib not loaded, waiting for hook")
		hook.Add("VoidLib.Loaded", "VoidFactions.Init.WaitForVoidLib", function ()
			VoidFactions.Print("VoidLib load hook called, loading..")
			VoidFactions.LoadAll()
		end)
	end

	-- By this time, VoidLib should be available.
	hook.Add("InitPostEntity", "VoidFactions.IsVoidLibLoaded", function ()
		if (!VoidLib) then
			VoidFactions.PrintError("--------------------------------------------------------------------------------")
			VoidFactions.PrintError("You are missing VoidLib! Subscribe to it at https://steamcommunity.com/sharedfiles/filedetails/?id=2078529432!")
			VoidFactions.PrintError("Without VoidLib the addon will not function properly.")
			VoidFactions.PrintError("You have been warned! This addon will not load until VoidLib is installed.")
			VoidFactions.PrintError("Do not open a support ticket unless you are 100% sure that VoidLib is installed.")
			VoidFactions.PrintError("--------------------------------------------------------------------------------")
		else
			if (!VoidLib.Database and SERVER) then
				VoidFactions.PrintError("--------------------------------------------------------------------------------")
				VoidFactions.PrintError("Your VoidLib IS OUTDATED! UPDATE TO THE LATEST ONE, PREFERABLY FROM THE WORKSHOP!")
				VoidFactions.PrintError("This addon is using VoidLib libraries utilizing a new database connection system.")
				VoidFactions.PrintError("Your VoidLib version is missing the new VoidLib database libraries.")
				VoidFactions.PrintError("Do not open a support ticket unless you are 100% sure that VoidLib is updated.")
				VoidFactions.PrintError("--------------------------------------------------------------------------------")
			end
		end
	end)
end

VoidFactions.Loaded = true

--[[---------------------------------------------------------
	Name: VoidLib loader
	Info: Don't touch this or the addon will break.
-----------------------------------------------------------]]

if (!SERVER) then return end
hook.Add("InitPostEntity", "VoidFactions.LibLoader", function ()
	VoidLib.Tracker:RegisterAddon("VoidFactions", "6c3eadb8-fb2a-4d76-ba23-d71fa54aa904", "86480918068252751")
end)

--addons/voidlib/lua/autorun/voidlib_init.lua:
return gluapack()()
--addons/voidlib/lua/voidlib/sh_net.lua:
VoidLib.Net = VoidLib.Net or {}
VoidLib.Net.Receivers = VoidLib.Net.Receivers or {}

if (SERVER) then
    util.AddNetworkString("VoidLib.TestingNetMessage")
end

-- Consts
local NET_CHUNK_SIZE = 65530

-- Class definition

local NET_CLASS = {}
NET_CLASS.__index = NET_CLASS

AccessorFunc(NET_CLASS, "strName", "Name", FORCE_STRING)
AccessorFunc(NET_CLASS, "bReceiving", "IsReceiving", FORCE_BOOL)
AccessorFunc(NET_CLASS, "bReadingChunks", "IsReadingChunks", FORCE_BOOL)
AccessorFunc(NET_CLASS, "intChunkIndex", "ChunkIndex", FORCE_NUMBER)
AccessorFunc(NET_CLASS, "pPlayer", "Sender")

function NET_CLASS:New(strName, bReceiving)
	local newObject = setmetatable({}, NET_CLASS)
    newObject.writtenData = {}
    newObject.readData = {}
    newObject.bLargeMessage = false
    newObject.intTotalBytes = 0

    -- define default type methods
    for k, v in pairs(newObject.DefaultTypes) do
        newObject["Write" .. v] = function(...) newObject:WriteField(v, { ... }) end
        newObject["Read" .. v] = function(...) return newObject:ReadField(v, { ... }) end
    end

    if (!bReceiving) then
        newObject:Start(strName)
    end

	return newObject
end

-- Getters

function NET_CLASS:GetBytes()
    return net.BytesWritten()
end

-- Methods

local function getTypeIndex(strType)
    for k, v in ipairs(NET_CLASS.DefaultTypes) do
        if (v == strType) then
            return k
        end
    end
end

-- starts a new message, for example we want to send a net message from a receiver object
function NET_CLASS:Start(strMessage) 
    self:SetName(strMessage)
    self.writtenData = {}
    pcall(net.Start, strMessage)
end

function NET_CLASS:Send(pPlayer, bBroadcast)
    self.pReceiver = pPlayer
    VoidLib:LogDebug("Sending net message :net: with size :size: bytes (:from: -> :to:)!", { net = self:GetName(), size = self:GetBytes(), from = CLIENT and "CLIENT" or "SERVER", to = CLIENT and "SERVER" or "CLIENT" }, "Networking")

    if (self:GetBytes() >= NET_CHUNK_SIZE) then
        VoidLib:LogDebug("Sending a split message because net size too big!", "Networking")
        self:SendSplitMessage()
    else
        -- Create a new net message, and cancel the prev one

        if (SERVER) then
            net.Send({})

            net.Start(self:GetName())
            net.WriteBool(false)

            for k, v in ipairs(self.writtenData) do
                self:WriteDataObject(v)
            end

            self:SendInternal(pPlayer, bBroadcast)
        else
            self:SendInternal(pPlayer)
        end
    end
end

function NET_CLASS:Broadcast(pPlayer)
    return self:Send(pPlayer, true)
end

function NET_CLASS:SendInternal(pPlayer, bBroadcast)
    if (istable(pPlayer) and table.IsEmpty(pPlayer)) then
        net.Send({})
        return
    end

    VoidLib:LogDebug("Internal message :message: size :size: bytes", { message = self:GetName(), size = net.BytesWritten() }, "Networking")
    if (SERVER) then
        if (bBroadcast) then
            net.Broadcast()
        else
            net.Send(pPlayer)
        end
    else
        net.SendToServer()
    end
end

function NET_CLASS:SendSplitMessage()
    local tblData = {}
    for k, v in pairs(self.writtenData) do
        local t = { getTypeIndex(v[1]) }
        table.insert(tblData, t)
        if (v[2] and v[2][2]) then
            t[2] = v[2][2]
        end
    end

    local str = util.TableToJSON(tblData)
    local binCompressed = util.Compress(str)
    tblData = nil

    VoidLib:Log("Sending a large message, ignore the error below!", "Networking")

    pcall(net.Send, {}) -- discard the overflowing previous one

    VoidLib:Log("Sending a large message, ignore the error above!", "Networking")

    local _net = VoidLib.Net:Start(self:GetName())
    _net:WriteBool(true)
    _net:WriteUInt(#binCompressed, 32)
    _net:WriteData(binCompressed)
    _net:SendInternal(self.pReceiver)

    VoidLib:LogDebug("Wrote table structure, total types: :types:", {types = #self.writtenData}, "Networking")

    -- now send the individual messages until done
    -- local _net = VoidLib.Net:Start(self:GetName())
    -- -- _net:

    local intTotalBytes = 0
    local bWriteDone = false
    local i = 0
    local intWriteLastPos = 0
    while (!bWriteDone) do
        if (intWriteLastPos >= #self.writtenData) then
            bWriteDone = true
            break
        end

        local iterNet = VoidLib.Net:Start(self:GetName())
        for k, v in pairs(self.writtenData) do
            if (k <= intWriteLastPos) then continue end
            iterNet:AddDataObject(v)

            intWriteLastPos = k
            if (iterNet:GetBytes() > 60000) then
                VoidLib:LogDebug("Net message chunk is larger than :x: kb, splitting, pos: :pos:!", {x = 60000, pos = k}, "Networking")
                break
            end
        end

        VoidLib:LogDebug("Sending large net message chunk!", "Networking")
        iterNet:SendInternal({})

        local tblWritten = iterNet.writtenData
        local intCount = #iterNet.writtenData

        -- Wrap message with size
        local _wrappedNet = VoidLib.Net:Start(iterNet:GetName())
        _wrappedNet:WriteBool(true)
        _wrappedNet:WriteBool(false)
        _wrappedNet:WriteUInt(intCount, 32)
        for k, v in pairs(tblWritten) do
            _wrappedNet:WriteDataObject(v)
        end
        intTotalBytes = intTotalBytes + _wrappedNet:GetBytes()
        _wrappedNet:SendInternal(self.pReceiver)

        i = i + 1
        if (i > 20) then
            VoidLib:LogError("Failed to send large net message after 20 iterations! Aborting.", "Networking")
            break
        end
    end

    _net:Start(self:GetName())
    _net:WriteBool(true)
    _net:WriteBool(true)
    _net:SendInternal(self.pReceiver)

    VoidLib:Log("Sent a large net message, in total sent :bytes: bytes!", { bytes = intTotalBytes }, "Networking")
end

function NET_CLASS:ReadNetStructure()
    VoidLib:LogDebug("Reading large net message structure", "Networking")

    local intLen = self:ReadUInt(32)
    local strJson = util.Decompress(self:ReadData(intLen))
    local tbl = util.JSONToTable(strJson)

    self.tblStruct = tbl
    self.intStructPos = 1
end

function NET_CLASS:ReadMessageChunk()
    local bLastMessage = self:ReadBool()

    if (bLastMessage) then
        -- Finish reading!
        self:SetIsReadingChunks(false)
        VoidLib:LogDebug("Large message read done!", "Networking")

        self.fFunc(nil, nil, true)

        return
    end
    

    local tblStruct = self.tblStruct
    
    local intLen = self:ReadUInt(32)

    for i = 1, intLen do
        local tblInfo = tblStruct[self.intStructPos]
        if (!tblInfo) then
            break
        end

        local strType = tblInfo[1]
        local intX = tblInfo[2]

        strType = NET_CLASS.DefaultTypes[strType]

        local xData = net["Read" .. strType](intX)
        table.insert(self.readData, xData)

        -- VoidLib:LogDebug("Iter (:i:), read type :type: with value :value:", {i = i, type = strType, value = xData}, "Networking")
        self.intStructPos = self.intStructPos + 1
        i = i + 1
    end
end

-- Net basic fields table
NET_CLASS.DefaultTypes = {
    "String",
    "Bit",
    "Bool",
    "Int",
    "UInt",
    "Float",
    "Double",
    "Table",
    "Entity",
    "Color",
    "Vector",
    "Angle",
    "Data"
}

-- Write methods

function NET_CLASS:WriteField(strType, tblData)
    table.remove(tblData, 1)
    table.insert(self.writtenData, {
        [1] = strType,
        [2] = tblData
    })

    net["Write" .. strType](unpack(tblData))
    -- VoidLib:LogDebug("Written field of type :type:, data: :data:", { type = strType, data = tblData[1] }, "Networking" )
end

function NET_CLASS:WriteDataObject(tObj)
    local strName = tObj[1]
    net["Write" .. strName](unpack(tObj[2]))
end

function NET_CLASS:AddDataObject(tObj)
    local strName = tObj[1]
    net["Write" .. strName](unpack(tObj[2]))

    table.insert(self.writtenData, {
        [1] = strName,
        [2] = tObj[2]
    })
end

function NET_CLASS:ReadField(strType, tblData)
    table.remove(tblData, 1)

    local xRes = self.bLargeMessage and self.readData[self.intReadPos] or net["Read" .. strType](unpack(tblData))

    if (self.bLargeMessage) then
        self.intReadPos = self.intReadPos + 1
    end

    return xRes
end


-- Methods

function VoidLib.Net:Start(strMessage)
    return NET_CLASS:New(strMessage)
end

function VoidLib.Net:ReceiverDummy()
    local cl = NET_CLASS:New()
    cl:ReadBool()
    return cl
end

function VoidLib.Net:WriterDummy()
    local cl = NET_CLASS:New()
    return cl
end


function VoidLib.Net:Receive(strMessage, fFunc)
    local _net = NET_CLASS:New(strMessage, true)

    if (!VoidLib.Net.Receivers[strMessage]) then
        VoidLib.Net.Receivers[strMessage] = {}
    end


    local fNew = function (intLen, pPlayer, bLargeMessage)
        if (CLIENT) then
            local bSplit = _net:ReadBool()

            if (_net:GetIsReadingChunks()) then
                _net:ReadMessageChunk()
            else
                -- check here if we are reading a splitted message, if yes, then reconstruct the message later
                if (bSplit and !bLargeMessage) then
                    _net:SetIsReadingChunks(true)
                    _net:ReadNetStructure()
                else
                    if (bLargeMessage) then
                        _net.intReadPos = 1
                        _net.bLargeMessage = true
                    end

                    fFunc(_net, intLen, pPlayer)
                end
            end
        else
            fFunc(_net, intLen, pPlayer)
        end
    end

    _net.fFunc = fNew

    net.Receive(strMessage, fNew)
    table.insert(VoidLib.Net.Receivers[strMessage], _net)
end

VoidLib.Net.Listen = VoidLib.Net.Receive
--addons/voidlib/lua/voidlib/sh_utils.lua:


////////////////
///  Colors  ///
////////////////

-- https://stackoverflow.com/a/3943023
function VoidLib.DynamicTextColor(col)
    local sum = col.r * 0.299 + col.g * 0.587 + col.b * 0.114
    if (sum > 186) then
        return VoidUI.Colors.Background
    else
        return VoidUI.Colors.Gray
    end
end


//////////////////////////
///  String Functions  ///
//////////////////////////

function VoidLib.StringFormat(str, x)
    -- x can be either a table of key value -> [level] = 25
    -- or just one argument
    str = tostring(str)

    if (istable(x)) then
        local currStr = str
        for k, v in pairs(x) do
            local valToReplace = ":" .. tostring(k) .. ":"
            currStr = string.Replace(currStr, valToReplace, tostring(v))
        end
        return currStr
    else
        return string.gsub(str, ":[%w_]+:", x)
    end
end

function VoidLib.IsNilOrEmpty(var)
    if var == nil then return true end
    if var == NULL then return true end
    if isstring(var) then
        return var:Replace(" ", "") == ""
    end
    return false
end


/////////////////////////
///   Net functions   ///
/////////////////////////

function VoidLib.CompressTable(tbl)
    local json = util.TableToJSON(tbl)
    if (!json) then return end

    return util.Compress(json)
end

function VoidLib.DecompressTable(json)
    local data = util.Decompress(json)

    return util.JSONToTable(data)
end

function VoidLib.WriteCompressedTable(tbl)
    local data = VoidLib.CompressTable(tbl)
    net.WriteUInt(#data, 32)
    net.WriteData(data, #data)
end

function VoidLib.ReadCompressedTable()
    local length = net.ReadUInt(32)
    local data = net.ReadData(length)

    return VoidLib.DecompressTable(data)
end

/////////////////////////////////
///  Serialization functions  ///
/////////////////////////////////

-- Not really CSV but who cares
-- table -> string (csv)
function VoidLib.TableToCSV(tbl)
    return table.concat(tbl, ";")
end

-- string (csv) -> table
function VoidLib.CSVToTable(csv)
    return string.Explode(";", csv)
end

-- Vector -> string
function VoidLib.SerializeVector(vec)
    if (!vec) then return nil end
    local tbl = vec:ToTable()
    return VoidLib.TableToCSV(tbl)
end

-- string -> Vector
function VoidLib.DeserializeVector(str)
    local tbl = VoidLib.CSVToTable(str)
    return Vector(unpack(tbl))
end


--addons/voidlib/lua/voidlib/vgui/circleavatar.lua:
local PANEL = {}

function PANEL:Init()
    self.backgroundColor = color_white
    self:SetZPos(9999)
end

function PANEL:PaintOver(w, h)
    VoidUI.StencilStart()

    surface.SetDrawColor(Color(0,0,0,1))
    VoidUI.DrawCircle(w/2, h/2, w/2, 2)

    VoidUI.StencilReplace()

    surface.SetDrawColor(self.backgroundColor:Unpack())
    surface.DrawRect(0, 0, w, h)

    VoidUI.StencilEnd()
end

function PANEL:SetBackgroundColor(color)
    self.backgroundColor = color
end

vgui.Register("VoidUI.CircleAvatar", PANEL, "AvatarImage")

--addons/voidlib/lua/voidlib/vgui/dropdown_popup.lua:
local PANEL = {}

function PANEL:Init()
    self:SetDrawOnTop(true)
    self:MakePopup()

    self.accentColor = VoidUI.Colors.Orange
    self.choices = {}
    self:DockPadding(0, 6, 0, 6)
end

function PANEL:SetAccentColor(color)
    self.accentColor = color
end

function PANEL:AddOption(name, onClick)
    local panel = vgui.Create("DButton", self)
    panel:Dock(TOP)
    panel:SSetTall(40)

    panel:SetText(name)
    panel:SetTextInset(16, 0)
    panel:SetContentAlignment(4)

    panel:SetFont("VoidUI.R20")
    panel:SetTextColor(VoidUI.Colors.Gray)
    panel.alpha = 0

    panel.Paint = function(pnl, w, h)
        surface.SetDrawColor(ColorAlpha(self.accentColor, panel.alpha))
        surface.DrawRect(0, 0, w, h)
    end

    panel.OnCursorEntered = function()
        panel.alpha = 200
    end

    panel.OnCursorExited = function()
        panel.alpha = 0
    end

    panel.DoClick = function(pnl)
        onClick(pnl)
        self:Remove()
    end

    self.choices[#self.choices + 1] = {
        panel = panel,
        str = name
    }

    self:InvalidateLayout()

    return panel
end

function PANEL:PerformLayout(w, h)
  local longest = 0

  surface.SetFont("VoidUI.R20")
  for k, v in pairs(self.choices) do
    local textSize = surface.GetTextSize(v.str)
    textSize = textSize + 32

    if (textSize > longest) then
        longest = math.max(112, textSize)
    end
  end

  self:SetWide(longest)
  self:SetTall(12 + #self.choices * 40)
end


function PANEL:OnFocusChanged(gained)
  if (!IsValid(self)) then return end
  if (gained) then return end

  self:Remove()
end

function PANEL:Paint(w, h)
  local x, y = self:LocalToScreen()

  BSHADOWS.BeginShadow()
    draw.RoundedBox(6, x, y, w, h, VoidUI.Colors.Primary)
  BSHADOWS.EndShadow(1, 2, 2)
end


vgui.Register("VoidUI.DropdownPopup", PANEL, "EditablePanel")

--

function VoidUI:CreateDropdownPopup(x, y)

    if (!x or !y) then
        x, y = input.GetCursorPos()
    end

    local panel = vgui.Create("VoidUI.DropdownPopup")
    panel:SetPos(x + 10, y + 10)

    return panel
end
--addons/voidlib/lua/voidlib/vgui/keybind.lua:
return gluapack()()
--addons/voidlib/lua/voidlib/vgui/modalframe.lua:
local PANEL = {}

function PANEL:Init()
    self:MakePopup()
    self.drawShadow = true
    self.noModal = true
end

function PANEL:SetNoModal(bool)
    self.noModal = bool
end

function PANEL:Think()
    if (self.noModal and !self:HasFocus()) then
        self:MoveToFront()
    end
end

vgui.Register("VoidUI.ModalFrame", PANEL, "VoidUI.Frame")
--addons/voidfactions-1.10.6/lua/voidfactions/core/sh_config.lua:
//////////////////////
///    WARNING    ////
//////////////////////

-- This file is not supposed to be edited.
-- Use the in-game configuration instead.
-- Only tweak something here if you are told to do so, or we will not provide you support if something breaks!

local L = VoidFactions.Lang.GetPhrase

-- Tables

VoidFactions.Settings = VoidFactions.Settings or {}
VoidFactions.Settings.IGConfig = {}
VoidFactions.Settings.IGConfigCategories = {}
VoidFactions.Settings.IGConfigPanels = {}
VoidFactions.Settings.IGConfigTypes = {}

VoidFactions.Settings.Hardcoded = {}

VoidFactions.UI = VoidFactions.UI or {}

-- Hardcoded values (you SHOULDNT TOUCH these unless absolutely sure)

VoidFactions.Settings.Hardcoded.MaxDynamicMembers = 150
VoidFactions.Settings.Hardcoded.MaxRanksInFaction = 25
VoidFactions.Settings.Hardcoded.MaxStaticFactions = 75
VoidFactions.Settings.Hardcoded.FactionNamePattern = "[^%w%$%%%[%] ]"
VoidFactions.Settings.Hardcoded.FactionTagPattern = "[^%w%$%%%[%] ]"

-- This only applies to static factions.
-- Max members for preloading the offline members of the faction into memory
-- Small factions will benefit from this, it will be pretty fast to update offline members
VoidFactions.Settings.Hardcoded.MembersMaxPreload = 100

-- Debug (this will log useful messages into your console)

VoidFactions.Debug = false

-- Enums

VOIDFACTIONS_STATICFACTIONS = 1
VOIDFACTIONS_DYNAMICFACTIONS = 2

-- Helper functions

function VoidFactions.Settings:IsStaticFactions()
	return VoidFactions.Config.FactionType == VOIDFACTIONS_STATICFACTIONS
end

function VoidFactions.Settings:IsDynamicFactions()
	return VoidFactions.Config.FactionType == VOIDFACTIONS_DYNAMICFACTIONS
end


-- Config codes


local sortOrder = 0
function VoidFactions.Settings:CreateConfigEntry(id, tbl)
	if (!tbl.category) then
		tbl.category = "Other"
	end
	VoidFactions.Settings.IGConfig[id] = {name = tbl.name, description = tbl.description, type = tbl.type, default = tbl.default, category = tbl.category, inputWidth = tbl.inputWidth, ddOptions = tbl.ddOptions, percentage = tbl.percentage, sortOrder = sortOrder, factionType = tbl.factionType}
	sortOrder = sortOrder + 1
end

function VoidFactions.Settings:CreateConfigCategory(id, sortOrder, panel, type)
	VoidFactions.Settings.IGConfigCategories[id] = sortOrder
	if (panel) then
		VoidFactions.Settings.IGConfigPanels[id] = panel
	end
	if (type) then
		VoidFactions.Settings.IGConfigTypes[id] = type
	end
end


////////////
//  CAMI  //
////////////

CAMI.RegisterPrivilege({
	Name = "VoidFactions_SaveNPCs",
	MinAccess = "admin",
	Description = "Can save VoidFactions NPCs?",
})


CAMI.RegisterPrivilege({
	Name = "VoidFactions_ManageFactions",
	MinAccess = "admin",
	Description = "Can manage VoidFactions factions (admin add/kick members)?",
})

CAMI.RegisterPrivilege({
	Name = "VoidFactions_EditFactions",
	MinAccess = "admin",
	Description = "Can create/edit VoidFactions factions?",
})

CAMI.RegisterPrivilege({
	Name = "VoidFactions_ManageCapturePoints",
	MinAccess = "admin",
	Description = "Can manage VoidFactions capture points?",
})

CAMI.RegisterPrivilege({
	Name = "VoidFactions_EditSettings",
	MinAccess = "superadmin",
	Description = "Can modify VoidFactions settings?",
})

CAMI.RegisterPrivilege({
	Name = "VoidFactions_AccessAllJobs",
	MinAccess = "admin",
	Description = "Can switch to any job, even without rank access?",
})

////////////////////////
// VoidChar 1 support //
////////////////////////

function VoidFactions.Settings:RefreshVoidCharFactions()
	if (!VoidChar) then return end
	if (!SERVER) then return end

	local factionJobs = {}
	local factionIcons = {}
	local factionDescs = {}
	local factionReqGroups = {}
	local totalDefaultFactions = 0

	for k, v in pairs(VoidFactions.Factions) do
		if (v.isDefaultFaction) then
			-- Get default rank jobs
			local rank = v:GetLowestRank()
			if (!rank) then continue end

			factionJobs[v.name] = {}
			factionIcons[v.name] = "https://" .. VoidLib.ImageProvider .. (v.logo or "") .. ".png"
			factionDescs[v.name] = v.description or "No description available!"
			factionReqGroups[v.name] = v.requiredUsergroups or {}

			local jobs = rank.jobs
			for _, job in ipairs(jobs) do
				factionJobs[v.name][job] = true
			end

			totalDefaultFactions = totalDefaultFactions + 1
		end
	end

	if (totalDefaultFactions < 2) then return end
	
	VoidChar.Config.DefaultJobs = {}
	for k, v in pairs(factionJobs) do
		for job, _ in pairs(v) do
			VoidChar.Config.DefaultJobs[job] = true
		end
	end

	VoidChar.Config.EnableUsingNonWhitelistedJobs = true
	VoidChar.Config.FactionSystem = true
	VoidChar.Config.UseBWhitelistFactions = false
	VoidChar.Config.RestrictF4Changing = false

	VoidChar.Config.DifferentFactionJobSwitch = false

	VoidChar.Config.Factions = factionJobs
	VoidChar.Config.FactionDescription = factionDescs
	VoidChar.Config.FactionIcons = factionIcons
	VoidChar.Config.FactionRequiredUsergroups = factionReqGroups

	-- Network later, and then on join
	VoidFactions.Settings:NetworkVoidCharFactions()
end

function VoidFactions.Settings:NetworkVoidCharFactions(ply)
	if (!VoidChar) then return end
	if (!SERVER) then return end

	local totalDefaultFactions = 0
	for k, v in pairs(VoidFactions.Factions) do
		if (v.isDefaultFaction) then
			local rank = v:GetLowestRank()
			if (!rank) then continue end
			
			totalDefaultFactions = totalDefaultFactions + 1
		end
	end

	if (totalDefaultFactions < 2) then return end

	net.Start("VoidFactions.Settings.NetworkVoidCharFactions")
		net.WriteTable(VoidChar.Config.Factions)
		net.WriteTable(VoidChar.Config.FactionDescription)
		net.WriteTable(VoidChar.Config.FactionIcons)
		net.WriteTable(VoidChar.Config.DefaultJobs)
		net.WriteTable(VoidChar.Config.FactionRequiredUsergroups or {})
	if (ply) then
		net.Send(ply)
	else
		net.Broadcast()
	end
end

hook.Add("VoidFactions.SQL.StaticFactionsPreloaded", "VoidFactions.Settings.VoidCharSupport", function ()
	VoidFactions.Settings:RefreshVoidCharFactions()
end)

///////////////////////
// Server networking //
///////////////////////


if (SERVER) then
	util.AddNetworkString("VoidFactions.Settings.SendConfigData")
	util.AddNetworkString("VoidFactions.Settings.RequestConfigData")
	util.AddNetworkString("VoidFactions.Settings.ModifyConfig")
	util.AddNetworkString("VoidFactions.Settings.NetworkVoidCharFactions")


	function VoidFactions.Settings:UpdateConfig(len, ply)
		-- Has access to modify config?
		if (!CAMI.PlayerHasAccess(ply, "VoidFactions_EditSettings")) then return end

		local len = net.ReadUInt(32)
		local data = net.ReadData(len)

		data = util.Decompress(data)
		data = util.JSONToTable(data)

		local igConfig = VoidFactions.Settings.IGConfig[data.key]
		if (igConfig) then
			if (data.key == "FactionType" and VoidFactions.Config[data.key] != 0) then
				-- Delete all factions
				VoidFactions.SQL:DropDatabases(false, true)

				local restartTime = 5
				VoidLib.Notify(ply, "VoidFactions", L("restartingIn", restartTime), VoidUI.Colors.Red, 5)
				timer.Simple(restartTime, function ()
					RunConsoleCommand("_RESTART")

					timer.Simple(5, function ()
						VoidLib.Notify(ply, "VoidFactions", "RESTART FAILED, PLEASE RESTART MANUALLY", VoidUI.Colors.Red, 5)
					end)
				end)
			end

			VoidFactions.Config[data.key] = data.value

			-- XP Modules
			if (igConfig.category == "xpmodules") then
				local moduleId = string.Replace(data.key, "XP_", "")
				local xpModule = VoidFactions.XP.Modules[moduleId]
				if (!xpModule) then
					VoidFactions.PrintError("Tried to modify XP module config, but xp module doesn't exist! (" .. moduleId .. ")")
					return
				end


				-- If the type is timevalue, then the value is a table with two elements: {time, xpValue}, default unit is minutes
				if (igConfig.type == "timevalue") then
					xpModule:SetXPAmount(tonumber(data.value[2]))
				else
					xpModule:SetXPAmount(tonumber(data.value) or 0)
				end
				
			end
		end


		VoidFactions.Settings:BroadcastConfigData(VoidFactions.Config)
		VoidFactions.SQL:SetSetting(data.key, data.value)
		
	end
	net.Receive("VoidFactions.Settings.ModifyConfig", function (len, ply)
		VoidFactions.Settings:UpdateConfig(len, ply)
	end)

	function VoidFactions.Settings:SendConfigData(ply)

		local config = VoidFactions.Config

		config = util.TableToJSON(config)
		config = util.Compress(config)

		net.Start("VoidFactions.Settings.SendConfigData")
			net.WriteUInt(#config, 32)
			net.WriteData(config, #config)
		net.Send(ply)

	end 

	hook.Add("VoidLib.PlayerFullLoad", "VoidFactions.Settings.SendConfigData", function (ply)
		VoidFactions.Settings:SendConfigData(ply)
	end)

	function VoidFactions.Settings:BroadcastConfigData(config)
		
		config = util.TableToJSON(config)
		config = util.Compress(config)

		net.Start("VoidFactions.Settings.SendConfigData")
			net.WriteUInt(#config, 32)
			net.WriteData(config, #config)
		net.Broadcast()
	end
	
	function VoidFactions.Settings:LoadConfig()
		VoidFactions.SQL:GetSettings(function (config, configExists)
			if (table.Count(config) < 1) then
				VoidFactions.Print("Initializing in-game config..")
				VoidFactions.Settings:InitConfig()
				return
			end

			for key, v in pairs(VoidFactions.Settings.IGConfig) do
				if (configExists[key] == nil) then
					config[key] = v.default
					VoidFactions.SQL:AddSetting(key, v.default)
				end
			end

			VoidFactions.Config = config
			VoidFactions.LoadedConfigs = configExists

			VoidFactions.Settings.ConfigLoaded = true

			VoidFactions.PrintDebug("Loaded config!")
			hook.Run("VoidFactions.Settings.Loaded")

			for key, v in pairs(VoidFactions.Settings.IGConfig) do
				if (v.category == "xpmodules") then
					local moduleId = string.Replace(key, "XP_", "")
					local xpModule = VoidFactions.XP.Modules[moduleId]
					if (!xpModule) then return end
					if (v.type == "timevalue") then
						xpModule:SetXPAmount(tonumber(config[key][2]))
					else
						VoidFactions.PrintDebug("Setting XP amount of " .. moduleId .. " to " .. config[key] .. "!")
						xpModule:SetXPAmount(tonumber(config[key]))
					end
				end
			end

		end)
	end

	function VoidFactions.Settings:InitConfig()
		local config = {}
		for k, v in pairs(VoidFactions.Settings.IGConfig) do
			config[k] = v.default
			VoidFactions.SQL:AddSetting(k, v.default)
		end

		VoidFactions.Config = config
		VoidFactions.LoadedConfigs = config

		VoidFactions.Settings:BroadcastConfigData(config)
		hook.Run("VoidFactions.Settings.Loaded")
	end

end

if (CLIENT) then

	net.Receive("VoidFactions.Settings.NetworkVoidCharFactions", function ()
		local factionJobs = net.ReadTable()
		local factionDescs = net.ReadTable()
		local factionIcons = net.ReadTable()
		local defaultJobs = net.ReadTable()
		local requiredGroups = net.ReadTable()

		VoidChar.Config.EnableUsingNonWhitelistedJobs = true
		VoidChar.Config.FactionSystem = true
		VoidChar.Config.UseBWhitelistFactions = false

		VoidChar.Config.DifferentFactionJobSwitch = false

		for k, v in pairs(factionJobs) do
			if (requiredGroups[k] and #requiredGroups[k] > 0) then
				local strUg = LocalPlayer():GetUserGroup()
				local bMatches = false
				for k, v in pairs(requiredGroups[k]) do
					if (v == strUg) then
						bMatches = true
					end
				end
		
				if (!bMatches) then
					factionJobs[k] = nil
					factionIcons[k] = nil
					factionDescs[k] = nil
				end
			end
		end

		VoidChar.Config.Factions = factionJobs
		VoidChar.Config.FactionDescription = factionDescs
		VoidChar.Config.FactionIcons = factionIcons
		VoidChar.Config.DefaultJobs = defaultJobs
	end)

	function VoidFactions.Settings:UpdateConfig(key, value)
		local data = {key = key, value = value}

		data = util.TableToJSON(data)
		data = util.Compress(data)

		net.Start("VoidFactions.Settings.ModifyConfig")
			net.WriteUInt(#data, 32)
			net.WriteData(data, #data)
		net.SendToServer()
	end

	function VoidFactions.Settings:ReceiveConfigData()
		local len = net.ReadUInt(32)
		local config = net.ReadData(len)

		config = util.Decompress(config)
		config = util.JSONToTable(config)

		VoidFactions.Config = config

		VoidFactions.Settings.ConfigLoaded = true
		
		VoidFactions.PrintDebug("Received config data")

		if (VoidFactions.Menu.ReopenRequested) then
			VoidFactions.Menu:Open()
			VoidFactions.Menu.ReopenRequested = false
		end

		hook.Run("VoidFactions.Settings.DataReceived")
		hook.Run("VoidFactions.Settings.Loaded")
	end

	net.Receive("VoidFactions.Settings.SendConfigData", VoidFactions.Settings.ReceiveConfigData)

end

//////////////////////
//  In-game config  //
//////////////////////

-- Categories

VoidFactions.Settings:CreateConfigCategory("globals", 1) -- Special category (for static and dynamic factions)

VoidFactions.Settings:CreateConfigCategory("general", 5)
VoidFactions.Settings:CreateConfigCategory("commands", 10)
VoidFactions.Settings:CreateConfigCategory("factions", 12)
VoidFactions.Settings:CreateConfigCategory("deposit", 13, nil, VOIDFACTIONS_DYNAMICFACTIONS)
VoidFactions.Settings:CreateConfigCategory("capturepoints", 14)
VoidFactions.Settings:CreateConfigCategory("invites", 15)
VoidFactions.Settings:CreateConfigCategory("experience", 20)
VoidFactions.Settings:CreateConfigCategory("upgrades", 30, "VoidFactions.UI.UpgradesManage", VOIDFACTIONS_DYNAMICFACTIONS)
VoidFactions.Settings:CreateConfigCategory("upgradetree", 40, "VoidFactions.UI.UpgradeTreeManage", VOIDFACTIONS_DYNAMICFACTIONS)
VoidFactions.Settings:CreateConfigCategory("rewards", 45, "VoidFactions.UI.RewardsManage", VOIDFACTIONS_DYNAMICFACTIONS)
VoidFactions.Settings:CreateConfigCategory("xpmodules", 50)

-- Config entries

-- Globals

VoidFactions.Settings:CreateConfigEntry("FactionType", {
    type = "number",
    category = "globals",
	default = 0
})

-- Commands

VoidFactions.Settings:CreateConfigEntry("MenuCommand", {
	name = "settings_menucommand",
	description = "settings_menucommand_desc",
	type = "string",
	category = "commands",
	default = "!factions",
})

VoidFactions.Settings:CreateConfigEntry("MenuBind", {
	name = "settings_menubind",
	description = "settings_menubind_desc",
	type = "keybind",
	category = "commands",
	default = false,
})

-- Factions

VoidFactions.Settings:CreateConfigEntry("DefaultMaxMembers", {
	name = "settings_defaultmaxmembers",
	description = "settings_defaultmaxmembers_desc",
	type = "number",
	category = "factions",
	default = 5,
	factionType = VOIDFACTIONS_DYNAMICFACTIONS
})

VoidFactions.Settings:CreateConfigEntry("SkipFirstRank", {
	name = "settings_skipfirstrank",
	description = "settings_skipfirstrank_desc",
	type = "bool",
	category = "factions",
	default = false,
	factionType = VOIDFACTIONS_STATICFACTIONS,
})

VoidFactions.Settings:CreateConfigEntry("DefaultMaxItems", {
	name = "settings_defaultmaxitems",
	description = "settings_defaultmaxitems_desc",
	type = "number",
	category = "factions",
	default = 5,
	factionType = VOIDFACTIONS_DYNAMICFACTIONS
})

VoidFactions.Settings:CreateConfigEntry("PromoteCanSelect", {
	name = "settings_promotecanselect",
	description = "settings_promotecanselect_desc",
	type = "bool",
	category = "factions",
	default = true,
	factionType = VOIDFACTIONS_STATICFACTIONS
})

VoidFactions.Settings:CreateConfigEntry("UpgradesEnabled", {
	name = "settings_upgradesenabled",
	description = "settings_upgradesenabled_desc",
	type = "bool",
	category = "factions",
	default = false,
	factionType = VOIDFACTIONS_STATICFACTIONS
})

VoidFactions.Settings:CreateConfigEntry("DepositEnabled", {
	name = "settings_depositenabled",
	description = "settings_depositenabled_desc",
	type = "bool",
	category = "factions",
	default = true,
})

VoidFactions.Settings:CreateConfigEntry("FactionCreateCost", {
	name = "settings_factioncreatecost",
	description = "settings_factioncreatecost_desc",
	type = "number",
	category = "factions",
	default = 25000,
	factionType = VOIDFACTIONS_DYNAMICFACTIONS
})

VoidFactions.Settings:CreateConfigEntry("DefaultRankName", {
	name = "settings_defaultrankname",
	description = "settings_defaultrankname_desc",
	type = "string",
	category = "factions",
	default = "Boss",
	factionType = VOIDFACTIONS_DYNAMICFACTIONS
})

VoidFactions.Settings:CreateConfigEntry("MaxTagLength", {
	name = "settings_maxtaglength",
	description = "settings_maxtaglength_desc",
	type = "number",
	category = "factions",
	default = 5,
	factionType = VOIDFACTIONS_DYNAMICFACTIONS
})

VoidFactions.Settings:CreateConfigEntry("NametagsDisabled", {
	name = "settings_nametagsdisabled",
	description = "settings_nametagsdisabled_desc",
	type = "bool",
	category = "factions",
	default = false,
	factionType = VOIDFACTIONS_DYNAMICFACTIONS
})

-- Deposits

hook.Add("InitPostEntity", "VoidFactions.Settings.OnInitializeAddons", function ()

	local currencyOptions = {}
	local defaultOption = DarkRP and "DarkRP" or nil
	for k, v in pairs(VoidFactions.Currencies.List) do
		if (v.isInternal) then continue end
		if (!v:IsInstalled()) then continue end
		
		if (!defaultOption) then
			defaultOption = k
		end
		currencyOptions[#currencyOptions + 1] = k
	end

	VoidFactions.Settings:CreateConfigEntry("FactionCreateCurrency", {
		name = "settings_factioncreatecurrency",
		description = "settings_factioncreatecurrency_desc",
		type = "dropdown",
		category = "factions",
		default = defaultOption,
		ddOptions = currencyOptions,
		factionType = VOIDFACTIONS_DYNAMICFACTIONS
	})

	VoidFactions.Settings:CreateConfigEntry("DepositCurrency", {
		name = "settings_depositcurrency",
		description = "settings_depositcurrency_desc",
		type = "dropdown",
		category = "deposit",
		default = defaultOption,
		ddOptions = currencyOptions,
	})

	local inventoryOptions = {}
	local defaultOption = nil
	for k, v in pairs(VoidFactions.Inventories.List) do
		if (!v:IsInstalled()) then continue end

		if (!defaultOption) then
			defaultOption = k
		end
		
		inventoryOptions[#inventoryOptions + 1] = k
	end

	VoidFactions.Settings:CreateConfigEntry("DepositInventory", {
		name = "settings_depositinventory",
		description = "settings_depositinventory_desc",
		type = "dropdown",
		category = "deposit",
		default = defaultOption,
		ddOptions = inventoryOptions,
	})

end)

-- Invites

VoidFactions.Settings:CreateConfigEntry("InviteDuration", {
	name = "settings_inviteduration",
	description = "settings_inviteduration_desc",
	type = "number",
	category = "invites",
	default = 20,
})

-- Capture points

VoidFactions.Settings:CreateConfigEntry("CapturePointRenderDistance", {
	name = "settings_pointrenderdist",
	description = "settings_pointrenderdist_desc",
	type = "number",
	category = "capturepoints",
	default = 3000,
})

VoidFactions.Settings:CreateConfigEntry("ShowPointDistances", {
	name = "settings_showpointdistances",
	description = "settings_showpointdistances_desc",
	type = "bool",
	category = "capturepoints",
	default = true,
})

VoidFactions.Settings:CreateConfigEntry("CaptureTime", {
	name = "settings_pointcaptime",
	description = "settings_pointcaptime_desc",
	type = "number",
	category = "capturepoints",
	default = 60,
})

-- Experience (this applies both to static and dynamic factions)

VoidFactions.Settings:CreateConfigEntry("DisableXP", {
	name = "settings_disablexpsystem",
	description = "settings_disablexpsystem_desc",
	type = "bool",
	category = "experience",
	default = false,
})

VoidFactions.Settings:CreateConfigEntry("LevelUpXP", {
	name = "settings_baselevelupxp",
	description = "settings_baselevelupxp_desc",
	type = "number",
	category = "experience",
	default = 500,
})

VoidFactions.Settings:CreateConfigEntry("LevelUpMultiplier", {
	name = "settings_levelupmultiplier",
	description = "settings_levelupmultiplier_desc",
	type = "number",
	category = "experience",
	default = 1.05,
})

VoidFactions.Settings:CreateConfigEntry("MaxLevel", {
	name = "settings_maxlevel",
	description = "settings_maxlevel_desc",
	type = "number",
	category = "experience",
	default = 100,
})

-- General

hook.Add("VoidFactions.Lang.LanguagesLoaded", "VoidFactions.Settings.CreateLangEntry", function ()
	VoidFactions.PrintDebug("Languages loaded, creating language setting entry!")

	-- Make all the first letters uppercase
	local langTbl = table.GetKeys(VoidFactions.Lang.Langs)
	for k, v in ipairs(langTbl) do
		langTbl[k] = (v:gsub("^%l", string.upper))
	end

	VoidFactions.Settings:CreateConfigEntry("Language", {
		name = "settings_language",
		description = "settings_language_desc",
		type = "dropdown",
		category = "general",
		ddOptions = langTbl,
		default = "English",
	})

	VoidFactions.Settings:CreateConfigEntry("NPCModel", {
		name = "settings_npcmodel",
		description = "settings_npcmodel_desc",
		type = "string",
		category = "general",
		default = "models/humans/group01/male_03.mdl",
	})
end)

-- Config loading
hook.Add("VoidFactions.DatabaseConnected", "VoidFactions.LoadInGameConfig", function ()
	timer.Simple(5, function ()
		VoidFactions.Settings:LoadConfig()
	end)
end)

--addons/voidfactions-1.10.6/lua/voidfactions/features/capturepoints/cl_capturepoints.lua:
return gluapack()()
--addons/voidfactions-1.10.6/lua/voidfactions/features/factionselection/cl_factionselection.lua:
return gluapack()()
--addons/voidfactions-1.10.6/lua/voidfactions/features/menu/cl_menu.lua:
VoidFactions.Menu = VoidFactions.Menu or {}

VoidFactions.Menu.Panel = nil
VoidFactions.Menu.ReopenRequested = false

concommand.Add("voidfactions", function ()
	VoidFactions.Menu:Open()
end)

hook.Add("VoidFactions.Settings.DataReceived", "VoidFactions.Menu.SetAccentColor", function ()
	VoidFactions.UI.Accent = VoidFactions.Config.FactionType == 1 and VoidUI.Colors.Blue or VoidUI.Colors.Green
end)

function VoidFactions.Menu:Open()

	if (VoidFactions.Config.FactionType == 0 and !CAMI.PlayerHasAccess(LocalPlayer(), "VoidFactions_EditSettings")) then
		VoidLib.Notify("Error", "VoidFactions isn't set up yet! Contact an admin!", VoidUI.Colors.Red, 5)
		return
	end

	if (!VoidFactions.PlayerMember) then
		VoidLib.Notify("Error", "Member object does not exist! Check server console for errors", VoidUI.Colors.Red, 5)
		return
	end

	if (IsValid(VoidFactions.Menu.Panel)) then
		VoidFactions.Menu.Panel:Remove()
	end

	local panel = vgui.Create("VoidFactions.UI.MainPanel")
	VoidFactions.Menu.Panel = panel
end

hook.Add("PlayerButtonDown", "VoidFactions.KeyBind", function (ply, key)
	if (IsValid(VoidFactions.Menu.Panel)) then return end

	local keyStr = VoidFactions.Config.MenuBind
	local _key = keyStr and input.GetKeyCode(keyStr) or nil
	if (keyStr and key == _key) then
		LocalPlayer():ConCommand("voidfactions")
	end 
end)

--addons/voidfactions-1.10.6/lua/voidfactions/classes/sh_rank.lua:
VoidFactions.Rank = VoidFactions.Rank or {}

-- Validators

function VoidFactions.Rank:ValidateRank(name, maxMembers, jobs)
	if (#name < 3) then return false, "nameShort" end
	if (VoidFactions.Settings:IsStaticFactions()) then
		if (maxMembers > 65534) then return false, "maxMembersLimit" end
		if (!jobs or #jobs < 1) then return false, "noJobs" end
	end

	return true
end

-- Classes

local RANK_CLASS = {}
RANK_CLASS.__index = RANK_CLASS

function RANK_CLASS:New(id, faction, name, weight, tag, canInvite, canPromote, canDemote, canPurchasePerks, kickMembers, manageFaction, jobs, maxMembers, minLevel, canWithdrawMoney, canDepositMoney, canWithdrawItems, canDepositItems, autoPromoteLevel, promoteDefault)
	local newObject = setmetatable({}, RANK_CLASS)
		newObject.id = id
		newObject.faction = faction
		newObject.weight = weight
		newObject.name = name
		newObject.tag = tag

		newObject.maxMembers = maxMembers

		newObject.minLevel = minLevel

		-- Permissions
		newObject.canInvite = canInvite
		newObject.canPromote = canPromote
		newObject.canDemote = canDemote

		newObject.kickMembers = kickMembers
		newObject.manageFaction = manageFaction

		newObject.canPurchasePerks = canPurchasePerks
		newObject.canWithdrawMoney = canWithdrawMoney
		newObject.canDepositMoney = canDepositMoney
		newObject.canDepositItems = canDepositItems
		newObject.canWithdrawItems = canWithdrawItems

		newObject.autoPromoteLevel = autoPromoteLevel or 0
		newObject.isTemplate = false

		newObject.promoteDefault = promoteDefault or {}

		-- Jobs
		newObject.jobs = jobs

	return newObject
end

-- Class functions

function RANK_CLASS:SetPromoteDefault(promDefault)
	self.promoteDefault = promDefault
end

function RANK_CLASS:SetAutoPromoteLevel(level)
	self.autoPromoteLevel = level
end

function RANK_CLASS:SetTemplate(isTemplate)
	self.isTemplate = isTemplate
end

function RANK_CLASS:SetWeight(weight)
	self.weight = weight
end

function RANK_CLASS:SetName(name)
	self.name = name
end

function RANK_CLASS:SetTag(tag)
	self.tag = tag
end

function RANK_CLASS:SetJobs(jobs)
	self.jobs = jobs
end

function RANK_CLASS:GetJobs()
	return self.jobs
end

function RANK_CLASS:SetMinLevel(level)
	self.minLevel = level
end

-- Util functions

-- Get all the ranks below this rank
function RANK_CLASS:GetRanksBelow()
	local weight = self.weight
	local tbl = {}
	for k, rank in pairs(self.faction.ranks or {}) do
		if (rank.weight > weight) then
			tbl[#tbl + 1] = rank
		end
	end

	return tbl
end

-- Is the rank the rank with the lowest weight (highest position)
function RANK_CLASS:IsTopRank()
	local weight = self.weight
	for k, rank in pairs(self.faction.ranks or {}) do
		if (weight > rank.weight) then return false end
	end

	return true
end

-- Get all members inside a rank
function RANK_CLASS:GetMembers()
	local tbl = {}
	for k, member in ipairs(self.faction.members or {}) do
		if (member.rank == self) then
			tbl[#tbl + 1] = member
		end
	end
	return tbl
end

-- Permission functions

-- Compares weight of another rank. Returns boolean (if THIS rank is higher in hiearchy, then returns true)
function RANK_CLASS:CompareWeight(rank)
	return rank.weight > self.weight
end

function RANK_CLASS:CanInvite()
	return self.canInvite
end

function RANK_CLASS:CanChangeRank(member, requester, rank)
	if (!member) then return false, true end
	if (rank) then
		if (!rank) then return false, true end
		if (!self.faction.ranks[rank.id]) then return false, true end

		if (self.canPromote == 1) then return false end
		if (rank.id == self.id) then return false end
		if (member.sid == requester.sid) then return false end

		if (!requester.faction) then return false end
		if (member.faction.id != requester.faction.id) then return false end

		return self:CompareWeight(member.rank)
	else
		if (self.canPromote == 1) then return false end
		if (member.sid == requester.sid) then return false end
		if (!requester.faction) then return false end
		if (member.faction.id != requester.faction.id) then return false end

		return self:CompareWeight(member.rank)
	end
end

function RANK_CLASS:CanPromote(member, requester)
	if (member) then
		local nextRank = member.faction:GetNextRank(member.rank)
		if (!nextRank) then
			-- Check if can promote to a different faction
			if (VoidFactions.Settings:IsStaticFactions() and member.faction.parentFaction) then
				nextRank = member.faction.parentFaction:GetLowestRank()
				if (!nextRank) then return false, true end
			else
				return false, true
			end
		end
		if (VoidFactions.Settings:IsStaticFactions()) then
			if (nextRank.maxMembers and nextRank.maxMembers != 0 and #nextRank:GetMembers() + 1 > nextRank.maxMembers) then return false, true end
		end

		local isPromoteDefault = requester.rank.promoteDefault[member.faction.id] and member.rank.id == member.faction:GetLowestRank().id

		if (self.canPromote == 1 and !isPromoteDefault) then return false end
		if (nextRank.id == self.id) then return false end -- Don't promote to same ranks
		if (member.sid == requester.sid) then return false end
		if (VoidFactions.Settings:IsStaticFactions()) then
			if (nextRank.minLevel and nextRank.minLevel != 0 and member.level < nextRank.minLevel) then return false end
		end

		if (!requester.faction) then return false end

		local isSameFaction = member.faction.id == requester.faction.id
		
		local isSubfaction = self.faction:GetSubfactions()[member.faction.id] and true or false
		if (!isSameFaction and !isSubfaction and !isPromoteDefault) then return false end
		if (!isSameFaction and !isPromoteDefault and self.canPromote != 3) then return false end
		return !isSameFaction and true or self:CompareWeight(member.rank)
	else
		if (self.canPromote == 1) then return false end
		return true
	end
end

function RANK_CLASS:CanDemote(member, requester, subfaction)
	if (member) then
		local prevRank = member.faction:GetPrevRank(member.rank)
		if (!prevRank) then
			local subfactions = member.faction:GetSubfactions()
			if (!subfaction or !subfactions[subfaction.id]) then return false, true end
			
			prevRank = subfaction:GetLowestRank()
			if (!prevRank) then return false, true end
		end
		if (prevRank.maxMembers and prevRank.maxMembers != 0 and #prevRank:GetMembers() + 1 > prevRank.maxMembers) then return false, true end

		local isPromoteDefault = requester.rank.promoteDefault[member.faction.id]

		if (self.canDemote == 1 and !isPromoteDefault) then return false end
		if (member.rank.id == self.id) then return false end -- Don't demote from same ranks
		if (member.sid == requester.sid) then return false end
		if (prevRank.minLevel and prevRank.minLevel != 0 and member.level < prevRank.minLevel) then return false end -- this doesn't make much sense but whatever

		if (!requester.faction) then return false end
		
		local isSameFaction = member.faction.id == requester.faction.id
		local isSubfaction = self.faction:GetSubfactions()[member.faction.id] and true or false

		if (!isSameFaction and !isSubfaction and !isPromoteDefault) then return false end
		if (!isSameFaction and isPromoteDefault and prevRank.id != member.faction:GetLowestRank().id) then return false end

		if (!isSameFaction and !isPromoteDefault and self.canDemote != 3) then return false end
		return !isSameFaction and true or self:CompareWeight(member.rank)
	else
		if (self.canDemote == 1) then return false end
		return true
	end
end

function RANK_CLASS:CanPurchasePerks()
	return self.canPurchasePerks
end

function RANK_CLASS:CanKick(member, requester)
	if (member) then
		if (VoidFactions.Settings:IsStaticFactions()) then
			if (!member.defaultFactionId) then return false, true end
			if (member.defaultFactionId == member.faction.id) then return false, true end
		end

		if (member.sid == requester.sid) then return false, true end
		if (self.kickMembers == 1) then return false end

		if (member.rank.id == self.id) then return false end
		if (!requester.faction) then return false end

		local isSameFaction = member.faction.id == requester.faction.id
		if (!isSameFaction and self.kickMembers != 3) then return false end

		if (isSameFaction and member.rank.weight == self.weight) then return false end

		if (isSameFaction and !self:CompareWeight(member.rank)) then return false end
		return true
	else
		if (self.kickMembers == 1) then return false end
		
		return true
	end
end

function RANK_CLASS:CanDepositItems()
	return self.canDepositItems
end

function RANK_CLASS:CanWithdrawItems()
	return self.canWithdrawItems
end

function RANK_CLASS:CanDepositMoney()
	return self.canDepositMoney
end

function RANK_CLASS:CanWithdrawMoney()
	return self.canWithdrawMoney
end

function RANK_CLASS:CanManageFaction()
	return self.manageFaction
end

-- Save functions

function RANK_CLASS:Save()
	if (!SERVER) then return end
	VoidFactions.SQL:SaveRank(self)
end

-- Global functions

function VoidFactions.Rank:InitRank(...)
	local rank = RANK_CLASS:New(...)
	return rank
end
--addons/voidfactions-1.10.6/lua/voidfactions/modules/currencies/darkrp.lua:
return gluapack()()
--addons/voidfactions-1.10.6/lua/voidfactions/modules/currencies/upgradepoints.lua:
return gluapack()()
--addons/voidfactions-1.10.6/lua/voidfactions/modules/experience/playtime.lua:
return gluapack()()
--addons/voidfactions-1.10.6/lua/voidfactions/modules/rewards/itemsdeposited.lua:
return gluapack()()
--addons/voidfactions-1.10.6/lua/voidfactions/net/capturepoints/cl_capturepoints.lua:

-- Functions

function VoidFactions.CapturePoints:CreatePoint(pos, radius)
    net.Start("VoidFactions.CapturePoints.CreateCapturePoint")
        net.WriteUInt(radius, 16)
        net.WriteVector(pos)
    net.SendToServer()
end

function VoidFactions.CapturePoints:DeletePoint(point)
    net.Start("VoidFactions.CapturePoints.DeleteCapturePoint")
        net.WriteUInt(point.id, 6)
    net.SendToServer()
end

-- Net handlers

net.Receive("VoidFactions.CapturePoints.UpdateCapturePoint", function (len, ply)
    local enum = net.ReadUInt(3)
    local pointId = net.ReadUInt(6)

    local point = VoidFactions.PointsTable[pointId]
    if (!point) then
        VoidFactions.PrintError("Received capture point update, but point not found!")
        return
    end

    if (enum == VoidFactions.CapturePoints.UpdateEnums.CAPTURE_FACTIONCHANGE) then
        local factionId = net.ReadUInt(20)
        local captureStart = net.ReadFloat()
        local captureEnd = net.ReadFloat()

        local faction = VoidFactions.LoadedFactions[factionId]
        if (!faction and factionId != 0) then
            VoidFactions.PrintError("Received capture point faction change, but faction not found!")
            return
        end


        point.capturingBy = faction
        point.captureStart = captureStart
        point.captureEnd = captureEnd
        if (!faction) then
            point.captureInProgress = false
        end
    end

    if (enum == VoidFactions.CapturePoints.UpdateEnums.POINT_CONTESTED) then
        local isContested = net.ReadBool()
        point.isContested = isContested

        if (isContested) then
            point.pauseTime = CurTime()
        else
            local secsFromStart = point.pauseTime - point.captureStart
            local totalDuration = point.captureEnd - point.captureStart
            point.captureEnd = CurTime() + totalDuration - secsFromStart
        end
    end

    if (enum == VoidFactions.CapturePoints.UpdateEnums.POINT_PAUSED) then
        local isPaused = net.ReadBool()

        local endTime = nil
        local pauseTime = nil

        if (!isPaused) then
            -- We need to change the end time
            local endTime = net.ReadFloat()
            point.captureEnd = endTime
        else
            point.pauseTime = CurTime()
        end

        point.isPaused = isPaused
    end

    if (enum == VoidFactions.CapturePoints.UpdateEnums.CAPTURE_CHANGE) then
        
		local captureStart = net.ReadBool()

        -- We need to receive the time from the server, because the net message arrives later.
        local startTime = nil
        local endTime = nil
        local factionId = nil
        if (captureStart) then
            startTime = net.ReadFloat()
            endTime = net.ReadFloat()
            factionId = net.ReadUInt(20)
        end

        local faction = VoidFactions.LoadedFactions[factionId]
        if (captureStart and !faction) then
            VoidFactions.PrintError("Received capture point start, but faction not found!")
            return
        end

        point.captureInProgress = captureStart
        point.capturingBy = faction

        point.captureStart = startTime
        point.captureEnd = endTime
        point.isPaused = false
        point.isContested = false
    end

    if (enum == VoidFactions.CapturePoints.UpdateEnums.CAPTURE_RESULT) then
        local factionId = net.ReadUInt(20)

        local faction = VoidFactions.LoadedFactions[factionId]
        if (!faction and factionId != 0) then
            VoidFactions.PrintError("Received capture point result, but faction not found!")
            return
        end

        point.captureInProgress = false 
        point.captureStart = nil
        point.capturingBy = nil
        point.captureFaction = faction
        point.isPaused = false
        point.isContested = false
    end
end)

net.Receive("VoidFactions.CapturePoints.SyncCapturePoints", function (len, ply)
    local count = net.ReadUInt(6)

    local updatedPoints = {}
    for i = 1, count do
        local point = VoidFactions.CapturePoints:ReadCapturePoint()
        updatedPoints[point.id] = true
    end

    for k, v in pairs(VoidFactions.PointsTable) do
        if (!updatedPoints[k]) then
            VoidFactions.PointsTable[k] = nil
        end
    end

end)
--addons/voidfactions-1.10.6/lua/voidfactions/vgui/admin/faction_settings.lua:
local PANEL = {}

function PANEL:Init()

    self:SetOrigSize(1000, 600)
    local container = self:Add("Panel")
    container:Dock(FILL)

    local factionSelection = container:Add("VoidFactions.UI.FactionListSelect")
    factionSelection:Dock(LEFT)
    factionSelection:SetFactions(VoidFactions.LoadedFactions)

    local factionInfo = container:Add("VoidFactions.UI.FactionSettingsInfo")
    factionInfo:Dock(FILL)
    factionInfo:SetVisible(false)

    function factionSelection:OnSelect(faction, isTemplate)
        factionInfo:SetVisible(true)
        factionInfo:SetFaction(faction, isTemplate)
    end

    self.factionSelection = factionSelection
    self.factionInfo = factionInfo

    self.container = container
end

function PANEL:PerformLayout(w, h)
    self.factionSelection:SDockPadding(8,8,8,8,self)
    self.container:SDockMargin(25,25,25,25,self)
    self.factionSelection:SSetWide(270, self)

    self.factionInfo:MarginLeft(20, self)
end


vgui.Register("VoidFactions.UI.StaticFactionSettings", PANEL, "VoidUI.PanelContent")

-- ^ static factions

local PANEL = {}

function PANEL:Init()
    if (VoidFactions.Settings:IsStaticFactions()) then
        local panel = self:Add("VoidFactions.UI.StaticFactionSettings")
        panel:Dock(FILL)
        panel:SetVisible(true)

        self.panel = panel
    else
        local panel = self:Add("VoidFactions.UI.DynamicFactionSettings")
        panel:Dock(FILL)
        panel:SetVisible(true)

        self.panel = panel
    end
end

vgui.Register("VoidFactions.UI.FactionSettings", PANEL, "VoidUI.PanelContent")
--addons/voidfactions-1.10.6/lua/voidfactions/vgui/admin/setup_panel.lua:
return gluapack()()
--addons/voidfactions-1.10.6/lua/voidfactions/vgui/admin/upgrades_manage.lua:
local sc = VoidUI.Scale
local L = VoidFactions.Lang.GetPhrase

local PANEL = {}

function PANEL:Init()
    self:SetOrigSize(648, 411)

    local upgradeGrid = self:Add("VoidUI.Grid")
    upgradeGrid:Dock(FILL)

    upgradeGrid:SetColumns(6)
    upgradeGrid:SetHorizontalMargin(10)
    upgradeGrid:SetVerticalMargin(10)

    local buttonPanel = self:Add("Panel")
    buttonPanel:Dock(BOTTOM)
    
    local createButton = buttonPanel:Add("VoidUI.Button")
    createButton:Dock(BOTTOM)
    createButton:SetText(L"createUpgrade")
    createButton:SetMedium()

    createButton.DoClick = function ()
        local frame = vgui.Create("VoidFactions.UI.UpgradeCreate")
        frame:SetParent(self)
    end

    self.upgradeGrid = upgradeGrid
    self.buttonPanel = buttonPanel
    self.createButton = createButton

    self:UpdateHook()
    self:LoadUpgrades()
end

function PANEL:UpdateHook()
    hook.Add("VoidFactions.Upgrade.UpgradesReceived", "VoidFactions.UI.UpgradesManage.UpgradesReceived", function ()
        self:LoadUpgrades()
    end)
end

function PANEL:OnRemove(w, h)
    hook.Remove("VoidFactions.Upgrade.UpgradesReceived", "VoidFactions.UI.UpgradesManage.UpgradesReceived")
end

function PANEL:LoadUpgrades()
    if (!VoidFactions.Upgrades.Custom) then
        VoidFactions.Upgrades:RequestUpgrades()
    else
        self:CreateUpgrades()
    end
end

function PANEL:CreateUpgrades()
    local upgrades = VoidFactions.Upgrades.Custom

    self.upgradeGrid:Clear()

    for k, upgrade in pairs(upgrades) do
        local upgradeBox = self.upgradeGrid:Add("DButton")
        upgradeBox:SetText("")
        upgradeBox:SSetSize(90, 90)
        upgradeBox.Paint = function (self, w, h)
            local color = self:IsHovered() and VoidUI.Colors.TextGray or VoidUI.Colors.InputLight
            draw.RoundedBox(8, 0, 0, w, h, color)

            local iconSize = w * 0.6
            local iconX, iconY = w/2 - iconSize/2, h/2 - iconSize / 2 - 5

            VoidLib.FetchImage(upgrade.icon, function (mat)
                if (!mat) then return end

                surface.SetMaterial(mat)
                surface.SetDrawColor(VoidUI.Colors.White)
                surface.DrawTexturedRect(iconX, iconY, iconSize, iconSize)
            end)

            surface.SetFont("VoidUI.R14")
            local textSize = surface.GetTextSize(upgrade.name)
            local shortenedText = textSize > w * 0.9 and upgrade.name:sub(1, 12) or upgrade.name
            draw.SimpleText(shortenedText, "VoidUI.R14", w/2, h-5, VoidUI.Colors.Gray, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM)
        end

        upgradeBox.DoClick = function ()
            local frame = vgui.Create("VoidFactions.UI.UpgradeCreate")
            frame:SetParent(self)
            frame:EditMode(upgrade)
        end

        self.upgradeGrid:AddCell(upgradeBox, true)
    end
end

function PANEL:PerformLayout(w, h)
    self.upgradeGrid:MarginSides(22, self)
    self.upgradeGrid:MarginTop(40, self)
    self.upgradeGrid:MarginBottom(20, self)

    self.buttonPanel:SSetTall(35, self)
    self.buttonPanel:MarginSides(200, self)
    self.buttonPanel:MarginBottom(10, self)

    self.createButton:SSetTall(35, self)
end

function PANEL:Paint(w, h)
    draw.SimpleText(L("upgradeCount", VoidFactions.Upgrades.Custom and #VoidFactions.Upgrades.Custom or 0), "VoidUI.R24", 0, 0, VoidUI.Colors.Gray, TEXT_ALIGN_LEFT)
end


vgui.Register("VoidFactions.UI.UpgradesManage", PANEL, "VoidUI.PanelContent")
--addons/voidfactions-1.10.6/lua/voidfactions/vgui/dynamic/deposit_panel.lua:
local L = VoidFactions.Lang.GetPhrase
local sc = VoidUI.Scale

local PANEL = {}

function PANEL:Init()
    local currency = VoidFactions.Currencies.List[VoidFactions.Config.DepositCurrency]
    if (!currency) then
        VoidLib.Notify("ERROR", "Deposit currency does not exist. Please set it up in the settings.", VoidUI.Colors.Red, 5)
        return
    end

	self.currency = currency

	local inventory = VoidFactions.Inventories.List[VoidFactions.Config.DepositInventory]

    local member = VoidFactions.PlayerMember
    local faction = member.faction

	local canDepositItems = member:Can("DepositItems", faction) and inventory
	local canWithdrawItems = member:Can("WithdrawItems", faction) and inventory

	local canDepositMoney = member:Can("DepositMoney", faction)
	local canWithdrawMoney = member:Can("WithdrawMoney", faction)

	self.canDepositItems = canDepositItems
	self.canWithdrawItems = canWithdrawItems

    self:SetTitle(string.upper(L"deposit"))
    self:SetOrigSize(1000, 600)

	self.selectedItem = nil

	self.itemCount = table.Count(faction.deposits or {})

    local container = self:Add("Panel")
    container:Dock(FILL)

	local inventoryPanel = container:Add("Panel")
	inventoryPanel:Dock(FILL)
	inventoryPanel.Paint = function (s, w, h)
		draw.RoundedBox(8, 0, 0, w, h, VoidUI.Colors.Primary)

		local totalItems = self.itemCount or 0
		draw.SimpleText(string.upper(VoidLib.StringFormat(L"itemCount", {
			x = totalItems,
			max = faction:GetMaxItems()
		})), "VoidUI.B24", sc(20), sc(20), VoidUI.Colors.Gray, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
	end


	local inventoryItems = inventoryPanel:Add("VoidUI.Grid")
	inventoryItems:Dock(FILL)
	inventoryItems:SetHorizontalMargin(10)
	inventoryItems:SetVerticalMargin(10)
	inventoryItems:SetColumns(5)

    

    local transactionPanel = container:Add("Panel")
    transactionPanel:Dock(RIGHT)
    transactionPanel.Paint = function (self, w, h)
        draw.RoundedBox(8, 0, 0, w, h, VoidUI.Colors.Primary)

		local formattedMoney = currency:FormatMoney(faction.money)

        draw.SimpleText(string.upper(L"balance"), "VoidUI.B22", w/2, sc(50), VoidUI.Colors.Green, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM)
        draw.SimpleText(formattedMoney, "VoidUI.B36", w/2, sc(80), VoidUI.Colors.Gray, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM)
    end

	local transactionHistory = transactionPanel:Add("Panel")
	transactionHistory:Dock(FILL)
	transactionHistory.Paint = function (self, w, h)
		draw.SimpleText(string.upper(L"transactionHistory"), "VoidUI.B20", w/2, 0, VoidUI.Colors.Gray, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
	end

	local transactionContent = transactionHistory:Add("VoidUI.RowPanel")
	transactionContent:Dock(FILL)
	transactionContent.Paint = function (self, w, h)
		draw.RoundedBox(8, 0, 0, w, h, VoidUI.Colors.Background)
	end

	local transactionButtons = transactionPanel:Add("Panel")
	transactionButtons:Dock(BOTTOM)

	local moneyDepositButton = transactionButtons:Add("VoidUI.Button")
	moneyDepositButton:Dock(TOP)
	moneyDepositButton:SetMedium()
	moneyDepositButton:SetText(L"deposit")

	moneyDepositButton.DoClick = function ()
		local popup = vgui.Create("VoidUI.ValuePopup")
		popup:SetText(L"depositMoney", L"depositMoneyText")
		popup:SetNumeric()
		popup:Continue(L"deposit", function (val)
			local valNumber = tonumber(val)
			if (!valNumber) then return end

			if (!currency:CanAfford(LocalPlayer(), valNumber)) then
				VoidLib.Notify(L"error", L"cantAfford", VoidUI.Colors.Red, 5)
				return
			end

			VoidFactions.Deposit:DepositMoney(valNumber)
		end)
		popup:Cancel(L"cancel")
	end

	moneyDepositButton:SetEnabled(canDepositMoney)

	local moneyWithdrawButton = transactionButtons:Add("VoidUI.Button")
	moneyWithdrawButton:Dock(BOTTOM)
	moneyWithdrawButton:SetMedium()
	moneyWithdrawButton:SetText(L"withdraw")
	moneyWithdrawButton:SetColor(VoidUI.Colors.Red)

	moneyWithdrawButton:SetEnabled(canWithdrawMoney)

	moneyWithdrawButton.DoClick = function ()
		local popup = vgui.Create("VoidUI.ValuePopup")
		popup:SetText(L"withdrawMoney", L"withdrawMoneyText")
		popup:SetNumeric()
		popup:Continue(L"withdraw", function (val)
			local valNumber = tonumber(val)
			if (!valNumber) then return end

			VoidFactions.Deposit:WithdrawMoney(valNumber)
		end)
		popup:Cancel(L"cancel")
	end

	local buttonPanel = inventoryPanel:Add("Panel")
	buttonPanel:Dock(BOTTOM)
	
	local depositButton = buttonPanel:Add("VoidUI.Button")
	depositButton:Dock(LEFT)
	depositButton:SetMedium()
	depositButton:SetText(L"deposit")

	depositButton:SetEnabled(canDepositItems)

	depositButton.DoClick = function ()
		if not inventory then return end
		
		local ply = LocalPlayer()
		local items = inventory:GetItems(ply)

		local selector = vgui.Create("VoidUI.ItemSelect")
		selector:SetParent(self)
	
		local itemTbl = {}
		for itemClass, _ in pairs(items) do
			local printName = inventory:GetPrintName(itemClass)
			itemTbl[itemClass] = printName
		end

		selector:InitItems(itemTbl, function (class, v)
			VoidFactions.Deposit:DepositItem(class, v)
		end)

		local x, y = input.GetCursorPos()
		selector:SetPos(x-135, y-330)
	end

	local withdrawButton = buttonPanel:Add("VoidUI.Button")
	withdrawButton:Dock(RIGHT)
	withdrawButton:SetMedium()
	withdrawButton:SetText(L"withdraw")
	withdrawButton:SetColor(VoidUI.Colors.Red)

	withdrawButton.DoClick = function ()
		VoidFactions.Deposit:WithdrawItem(self.selectedItem.id, inventory:GetPrintName(self.selectedItem.class))
	end

	withdrawButton:SetEnabled(false)


    self.transactionPanel = transactionPanel
	self.inventoryPanel = inventoryPanel

	self.transactionHistory = transactionHistory
	self.transactionButtons = transactionButtons

	self.transactionContent = transactionContent

	self.moneyDepositButton = moneyDepositButton
	self.moneyWithdrawButton = moneyWithdrawButton

	self.inventoryItems = inventoryItems
	self.buttonPanel = buttonPanel

	self.depositButton = depositButton
	self.withdrawButton = withdrawButton

    self.container = container

	self.inventory = inventory

	hook.Add("VoidFactions.Faction.DataUpdated", "VoidFactions.UI.DepositPanel.ItemsReceived", function ()
		self:LoadItems()
	end)

	self:LoadItems()
end

function PANEL:OnRemove()
	hook.Remove("VoidFactions.Faction.DataUpdated", "VoidFactions.UI.DepositPanel.ItemsReceived")
end

function PANEL:LoadItems()
	local member = VoidFactions.PlayerMember
    local faction = member.faction
	
	if (faction.deposits) then
		self:DisplayItems(faction.deposits, faction.transactions)
	else
		VoidFactions.Faction:RequestFactionDeposits(faction.id)
	end
end

function PANEL:DisplayItems(deposits, transactions)

	local inventory = self.inventory
	local currency = self.currency

	self.inventoryItems:Clear()
	self.transactionContent:Clear()

	local member = VoidFactions.PlayerMember
    local faction = member.faction

	local depositCount = table.Count(faction.deposits)

	self.canDepositItems = depositCount + 1 <= faction:GetMaxItems()
	self.itemCount = depositCount

	self.depositButton:SetEnabled(self.canDepositItems)

	local inventory = self.inventory

	for k, transaction in SortedPairsByMemberValue(transactions, "time", true) do

		local plyNick = nil
		steamworks.RequestPlayerInfo(transaction.sid, function (nick)
			plyNick = nick
		end)

		local printName = transaction.isMoney and currency:FormatMoney(math.abs(transaction.difference)) or inventory:GetPrintName(transaction.itemClass)

		local panel = self.transactionContent:Add("Panel")
		panel:Dock(TOP)
		panel:SSetTall(25)

		panel.Paint = function (self, w, h)
			local color = transaction.difference > 0 and VoidUI.Colors.Green or VoidUI.Colors.Red
			local symbol = transaction.difference > 0 and "+" or "-"
			local name = symbol .. " " .. printName

			draw.SimpleText(plyNick or L"loading", "VoidUI.R18", sc(10), h/2+1, VoidUI.Colors.Gray, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
			draw.SimpleText(name, "VoidUI.R18", w-sc(10), h/2+1, color, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)
		end
		
	end

	for k, item in pairs(deposits) do
	
		local printName = inventory:GetPrintName(item.class)
		local rarityColor = inventory:GetRarityColor(item.class)

		local itemPanel = self.inventoryItems:Add("DButton")
		itemPanel:SSetSize(100, 100)
		itemPanel:SetText("")

		local selectedColor = Color(rarityColor.r, rarityColor.g, rarityColor.b, 60)

		itemPanel.Paint = function (s, w, h)
			local bgColor = self.selectedItem == item and selectedColor or VoidUI.Colors.InputLight

			draw.RoundedBox(6, 0, 0, w, h, rarityColor)
			draw.RoundedBox(6, 1, 1, w-2, h-2, VoidUI.Colors.InputLight)
			draw.RoundedBox(6, 1, 1, w-2, h-2, bgColor)
		end


		local model = itemPanel:Add("DModelPanel")
		model:Dock(FILL)
		model:SDockMargin(5, 5, 5, 5)
		model:SetModel(item.model != "" and item.model or "models/error.mdl")

		function model:LayoutEntity() end

		local mn, mx = model.Entity:GetRenderBounds()
		local size = 0
		size = math.max( size, math.abs(mn.x) + math.abs(mx.x) )
		size = math.max( size, math.abs(mn.y) + math.abs(mx.y) )
		size = math.max( size, math.abs(mn.z) + math.abs(mx.z) )

		model:SetFOV( 45 )
		model:SetCamPos( Vector( size, size, size ) )
		model:SetLookAt( (mn + mx) * 0.5 )

		local textSizeWidth = surface.GetTextSize(printName) * 1.2

		

		local modelButton = itemPanel:Add("DButton")
		modelButton:SetText("")
		modelButton:Dock(FILL)
		modelButton.Paint = function (s, w, h)
			local height = h * 0.17
			local y = h-height

			draw.RoundedBox(4, 0, y, w, height, rarityColor)
			local font = #printName > 12 and "VoidUI.R14" or "VoidUI.R18"
			draw.SimpleText(printName, font, w/2, y+height/2-1, VoidUI.Colors.Gray, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
		end

		modelButton.DoClick = function ()
			local canWithdraw = self.canWithdrawItems
			self.selectedItem = item
			self.withdrawButton:SetEnabled(canWithdraw)
		end

		self.inventoryItems:AddCell(itemPanel, true)
	end
end

function PANEL:PerformLayout(w, h)
    self.container:MarginSides(45, self)
    self.container:MarginTop(10, self)
    self.container:MarginBottom(25, self)

    self.transactionPanel:SSetWide(300, self)

	self.inventoryPanel:MarginRight(10, self)
	self.inventoryPanel:SDockPadding(20, 20, 20, 20, self)

	self.inventoryItems:MarginTop(40, self)
	self.inventoryItems:MarginBottom(20, self)

	self.buttonPanel:SSetTall(30, self)
	self.buttonPanel:MarginSides(60, self)

	self.depositButton:SSetWide(205, self)
	self.withdrawButton:SSetWide(205, self)

	self.transactionHistory:MarginTop(110, self)
	self.transactionHistory:MarginSides(15, self)

	self.transactionButtons:SSetTall(70, self)
	self.transactionButtons:MarginTops(20, self)
	self.transactionButtons:MarginSides(60, self)

	self.transactionContent:MarginTop(30, self)
	
	self.moneyDepositButton:SSetTall(30, self)
	self.moneyWithdrawButton:SSetTall(30, self)
end

vgui.Register("VoidFactions.UI.DepositPanel", PANEL, "VoidUI.PanelContent")

--addons/voidfactions-1.10.6/lua/voidfactions/vgui/static/faction_selection.lua:
return gluapack()()
--lua/autorun/williams_suitnrobbersinit.lua:
player_manager.AddValidModel( "Williams Üye Modeli", "models/player/Suits/male_09_closed_coat_tie.mdl" )
list.Set( "PlayerOptionsModel", "Williams Üye Modeli", "models/player/Suits/male_09_closed_coat_tie.mdl" )
--lua/wos/anim_extension/loader/loader.lua:
--[[-------------------------------------------------------------------
	wiltOS Animation Register:
		A simple register to keep track of all wiltOS extensions installed
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
-------------------------------------------------------------------]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
----------------------------------------]]--

wOS = wOS or {}
wOS.AnimExtension = wOS.AnimExtension or {}
wOS.AnimExtension.Mounted = wOS.AnimExtension.Mounted or {}

local string = string
local file = file

local function _AddCSLuaFile( lua )

	if SERVER then
		AddCSLuaFile( lua )
	end
	
end

local function _include( load_type, lua )

	if load_type then
		include( lua )
	end
	
end

function wOS.AnimExtension:Autoloader()
	
	for _,source in pairs( file.Find( "wos/anim_extension/extensions/*", "LUA"), true ) do
		local lua = "wos/anim_extension/extensions/" .. source
		_AddCSLuaFile( lua )
		_include( SERVER, lua )
		_include( CLIENT, lua )
	end
	
	_AddCSLuaFile( "wos/anim_extension/vgui/wiltos_anim_viewer.lua" )
	_include( CLIENT, "wos/anim_extension/vgui/wiltos_anim_viewer.lua" )
	
	_AddCSLuaFile( "wos/anim_extension/core/sh_metatable.lua" )
	_include( SERVER, "wos/anim_extension/core/sh_metatable.lua" )
	_include( CLIENT, "wos/anim_extension/core/sh_metatable.lua" )
	
	_AddCSLuaFile( "wos/anim_extension/core/sh_holdtypes.lua" )
	_include( SERVER, "wos/anim_extension/core/sh_holdtypes.lua" )
	_include( CLIENT, "wos/anim_extension/core/sh_holdtypes.lua" )

	_AddCSLuaFile( "wos/anim_extension/core/sh_prone_support.lua" )
	_include( SERVER, "wos/anim_extension/core/sh_prone_support.lua" )
	_include( CLIENT, "wos/anim_extension/core/sh_prone_support.lua" )
	
	for _,source in pairs( file.Find( "wos/anim_extension/holdtypes/*", "LUA"), true ) do
		local lua = "wos/anim_extension/holdtypes/" .. source
		_AddCSLuaFile( lua )
		_include( SERVER, lua )
		_include( CLIENT, lua )
	end
	
end

wOS.AnimExtension:Autoloader()
--lua/wos/anim_extension/core/sh_holdtypes.lua:
return gluapack()()
--lua/wos/dynabase/core/sh_mounting.lua:
wOS = wOS or {}
wOS.DynaBase = wOS.DynaBase or {}
local added = {}

////////////////////////////////////// BASELINE STUFF //////////////////////////////////////
local model_table = {}
model_table[ WOS_DYNABASE.SHARED  ] = "models/player/wiltos/anim_dynamic_pointer.mdl"
model_table[ WOS_DYNABASE.MALE  ] = "models/player/wiltos/anim_dynamic_maleptr.mdl"
model_table[ WOS_DYNABASE.FEMALE  ] = "models/player/wiltos/anim_dynamic_femaler.mdl"
model_table[ WOS_DYNABASE.ZOMBIE  ] = "models/player/wiltos/anim_dynamic_zombier.mdl"

local model_ext = {}
model_ext[ WOS_DYNABASE.MALE  ] = "_male"
model_ext[ WOS_DYNABASE.FEMALE  ] = "_female"
model_ext[ WOS_DYNABASE.ZOMBIE  ] = "_zombie"

local INCLUDE_MODEL_START = 737
local INCLUDE_MODEL_END_SHARED = 806

// "Hard code the math idiot" says the guy who doesn't realize I'm making it easier on myself to change their names or expand in the future
// I also can't count letters, only numbers?? GENIUS. NICE ONE
local INCLUDE_MODEL_END_MALE = INCLUDE_MODEL_END_SHARED + ( #"_male" )*2
local INCLUDE_MODEL_END_FEMALE = INCLUDE_MODEL_END_SHARED + ( #"_female" )*2 
local INCLUDE_MODEL_END_ZOMBIE = INCLUDE_MODEL_END_SHARED + ( #"_zombie" )*2

////////////////////////////////////////////////////////////////////////////////////////////

function IncludeModel( mdl )
	if not mdl then return end
	if wOS.DynaBase.PreservedModels[ mdl ] then mdl = wOS.DynaBase.PreservedModels[ mdl ] end
	if table.HasValue( added, mdl ) then return end //This isn't needed but let's not bloat the mount file
	table.insert( added, 1, mdl )
end

local function IntToByte( num )
	if not num then return end
	local t = {}
	t[1] = num % 256
	for i=1, 3 do
		t[i+1] = math.modf( num / ( 256^i ) ) % ( 256 )
	end
	return t
end

/////////////////////////////////////////////////////////////////////////////////////////////////////////
// If you don't know what this does do not mess with it or you're gonna mess up your player model
// There'll be a lot of repeated code here for now while we get some TESTING done
local function WRITE_TO_LOCAL( start, finish, type )
	if not type then return end
	local base_path = model_table[ type  ]
	if not base_path then return end

	local mdl_file = file.Open( base_path, "r", "GAME" )
	local dat = {}
	local str = ""
	for i=0, mdl_file:Size() do
		local byte = mdl_file:ReadByte()
		table.insert( dat, byte )
		if not byte then continue end
		str = str .. string.char( byte )
	end

	
	local endchar = str[finish]
	local tstr = ""
	for i=0, #str do
		if i == start then
			for _, newmodel in ipairs( added ) do
				tstr = tstr .. newmodel .. endchar
			end
		end
		if i >= start and i <= finish then continue end
		local char = str[i]
		tstr = tstr .. char
	end

	local includenum = IntToByte( #added )
	for i=1, 4 do
		tstr = string.SetChar( tstr, 336 + i, string.char( includenum[i] ) )
	end

	local final_line = "models/player/wiltos/anim_dynamic_pointer/."
	local endptr = #tstr - #final_line

	local null_insert = IntToByte( 0 )

    // You can manipulate the list here to remove anything you don't want for this type
	hook.Call( "PreCreateLocalAnimation", nil, type, added )

	local first_num = 60 + ( #added - 1 )*8
	local includenum = IntToByte( first_num )
	for i=1, 4 do
		tstr = string.SetChar( tstr, 680 + i, string.char( includenum[i] ) )
	end

	for i=1, #added - 1 do

		local anim_pos = first_num - 7*i
		for j=1, i do
			anim_pos = anim_pos + #added[j]
		end
		local anim_num = IntToByte( anim_pos )

		local start_pos = 676 + 8*i
		local start_half = string.sub( tstr, 1, start_pos )
		for j=1, 4 do
			start_half = start_half .. string.char( null_insert[j] )
		end
		for j=1, 4 do
			start_half = start_half .. string.char( anim_num[j] )
		end
		endptr = endptr + 8
		tstr = start_half .. string.sub( tstr, start_pos + 1 )
	end


	local endincludeaddr = IntToByte( endptr )
	for i=1, 4 do
		tstr = string.SetChar( tstr, 684 + 8*(#added - 1 ) + i, string.char( endincludeaddr[i] ) )
	end

	for i=0, #added - 1 do
		tstr = tstr .. endchar
	end

	local datalen = IntToByte( #tstr )
	for i=1, 4 do
		tstr = string.SetChar( tstr, 76 + i, string.char( datalen[i] ) )
	end

	local ext = model_ext[ type  ] or "_shared"
	file.Write( "wos/dynabase/local" .. ext .. WOS_DYNABASE_FILE_EXTENSION, tstr )
    hook.Call( "PostCreateLocalAnimation", nil, type, added )
end

// If you don't know what this does do not mess with it or you're gonna mess up your player model
local function WRITE_TO_POINTER( start, finish, type )
	if not type then return end
	local base_path = model_table[ type ]
	if not base_path then return end

	local mdl_file = file.Open( base_path, "r", "GAME" )
	local str = ""
	for i=0, mdl_file:Size() do
		local byte = mdl_file:ReadByte()
		if not byte then continue end
		str = str .. string.char( byte )
	end

	
	local endchar = str[finish]
	local tstr = ""
	for i=0, #str do
		if i == start then
			for _, newmodel in ipairs( added ) do
				tstr = tstr .. newmodel .. endchar
			end
		end
		if i >= start and i <= finish then continue end
		local char = str[i]
		tstr = tstr .. char
	end

	local includenum = IntToByte( #added )
	for i=1, 4 do
		tstr = string.SetChar( tstr, 336 + i, string.char( includenum[i] ) )
	end

	local final_line = "models/player/wiltos/anim_dynamic_pointer/."
	local endptr = #tstr - #final_line

	local null_insert = IntToByte( 0 )

    // You can manipulate the list here to remove anything you don't want for this type
	hook.Call( "PreMountAnimation", nil, type, added )

	local first_num = 60 + ( #added - 1 )*8
	local includenum = IntToByte( first_num )
	for i=1, 4 do
		tstr = string.SetChar( tstr, 680 + i, string.char( includenum[i] ) )
	end

	for i=1, #added - 1 do

		local anim_pos = first_num - 7*i
		for j=1, i do
			anim_pos = anim_pos + #added[j]
		end
		local anim_num = IntToByte( anim_pos )

		local start_pos = 676 + 8*i
		local start_half = string.sub( tstr, 1, start_pos )
		for j=1, 4 do
			start_half = start_half .. string.char( null_insert[j] )
		end
		for j=1, 4 do
			start_half = start_half .. string.char( anim_num[j] )
		end
		endptr = endptr + 8
		tstr = start_half .. string.sub( tstr, start_pos + 1 )
	end


	local endincludeaddr = IntToByte( endptr )
	for i=1, 4 do
		tstr = string.SetChar( tstr, 684 + 8*(#added - 1 ) + i, string.char( endincludeaddr[i] ) )
	end

	for i=0, #added - 1 do
		tstr = tstr .. endchar
	end

	local datalen = IntToByte( #tstr )
	for i=1, 4 do
		tstr = string.SetChar( tstr, 76 + i, string.char( datalen[i] ) )
	end

	local ext = model_ext[ type  ] or ""
	file.Write( "wos/dynabase/anim_dynamic" .. ext .. WOS_DYNABASE_FILE_EXTENSION, tstr )
    hook.Call( "PostMountAnimation", nil, type, added )
end

/////////////////////////////////////////////////////////////////////////////////////////////////////////

local function AdjustMountOrder( tbl, typ )
	if not tbl then return end

	local reference = wOS.DynaBase.FilteredLoadOrder[ typ ]
	local blacklist = wOS.DynaBase.FilteredBlacklist[ typ ]
	local plyref = wOS.DynaBase.FilteredPlayerOrder[ typ ]
	local plyblacklist = wOS.DynaBase.FilteredPlayerBlacklist[ typ ]

	local new_tbl = {}

	if WOS_DYNABASE_ENFORCECONTENT_CVAR:GetInt() > 0 then
		local cust_mount = wOS.DynaBase:GetSource( "Local Player Animations" )
		if cust_mount then
			if typ == WOS_DYNABASE.MALE then
				table.RemoveByValue( tbl, cust_mount.Male )
			elseif typ == WOS_DYNABASE.FEMALE then
				table.RemoveByValue( tbl, cust_mount.Female )
			elseif typ == WOS_DYNABASE.ZOMBIE then
				table.RemoveByValue( tbl, cust_mount.Zombie )
			else
				table.RemoveByValue( tbl, cust_mount.Shared )
			end
		end
	end

	if reference then
		for _, path in ipairs( reference ) do
			path = wOS.DynaBase.PreservedModels[ path ] or path
			if !table.HasValue( tbl, path ) then continue end
			table.insert( new_tbl, path )
			table.RemoveByValue( tbl, path )
		end
	end

	// If we aren't allowed to use any other addon than the ones that are dictated, don't merge any extra models
	if WOS_DYNABASE_ENFORCECONTENT_CVAR:GetInt() >= 2 and reference then return new_tbl end

	if plyref then
		for _, path in ipairs( plyref ) do
			path = wOS.DynaBase.PreservedModels[ path ] or path
			if !table.HasValue( tbl, path ) then continue end
			table.insert( new_tbl, path )
			table.RemoveByValue( tbl, path )
		end
	end

	if plyblacklist then
		for _, path in ipairs( plyblacklist ) do
			path = wOS.DynaBase.PreservedModels[ path ] or path
			table.RemoveByValue( tbl, path )
		end	
	end

	// Add the ones we don't care about now
	table.Add( new_tbl, tbl )

	// Server gets final word what we can use
	if blacklist then
		for _, path in ipairs( blacklist ) do
			path = wOS.DynaBase.PreservedModels[ path ] or path
			table.RemoveByValue( new_tbl, path )
		end	
	end


	return new_tbl
end

function wOS.DynaBase:ReloadAnimations()

	if self.LIVE_RELOAD then
		local seq = LocalPlayer():LookupSequence( "_dynamic_wiltos_enabled_" )
		if seq <= 0 then
			chat.AddText( Color( 255, 0, 0 ), "[wOS-Dynabase] Dynamic Animation Base failed due to conflicting animation base. Enter wos_dynabase_help into console to find the conflict, unsubscribe from the addon, and restart Garry's Mod.\n\nIf you are on someone's server, contact the owner to ensure they do not have a conflicting animation addon as required content." )
			return
		end
	end

	added = table.Copy( self.DefaultTable.Male )
	hook.Call( "PreLoadAnimations", nil, WOS_DYNABASE.MALE, added )
	local ntable = AdjustMountOrder( added, WOS_DYNABASE.MALE )
	added = ntable or added
	WRITE_TO_POINTER( INCLUDE_MODEL_START, INCLUDE_MODEL_END_MALE, WOS_DYNABASE.MALE )
	
	added = table.Copy( wOS.DynaBase.DefaultTable.Female )
	hook.Call( "PreLoadAnimations", nil, WOS_DYNABASE.FEMALE, added )
	ntable = AdjustMountOrder( added, WOS_DYNABASE.FEMALE )
	added = ntable or added
	WRITE_TO_POINTER( INCLUDE_MODEL_START, INCLUDE_MODEL_END_FEMALE, WOS_DYNABASE.FEMALE )

	added = table.Copy( wOS.DynaBase.DefaultTable.Zombie )
	hook.Call( "PreLoadAnimations", nil, WOS_DYNABASE.ZOMBIE, added )
	ntable = AdjustMountOrder( added, WOS_DYNABASE.ZOMBIE )
	added = ntable or added
	WRITE_TO_POINTER( INCLUDE_MODEL_START, INCLUDE_MODEL_END_ZOMBIE, WOS_DYNABASE.ZOMBIE )

	added = table.Copy( wOS.DynaBase.DefaultTable.Shared  )
	hook.Call( "PreLoadAnimations", nil, WOS_DYNABASE.SHARED, added )
	ntable = AdjustMountOrder( added, WOS_DYNABASE.SHARED )
	added = ntable or added
	WRITE_TO_POINTER( INCLUDE_MODEL_START, INCLUDE_MODEL_END_SHARED, WOS_DYNABASE.SHARED )

	if SERVER then
		hook.Call( "PostLoadAnimations" ) --Server doesn't need to worry about render stuff so we load here
		return
	end

	if wOS.DynaBase.InitCompleted and not WOS_DYNABASE_SHOULDHOTLOAD_CVAR:GetBool() then return end
	wOS.DynaBase.ReloadModelBool = true
end

function wOS.DynaBase:ReloadLocalAnimations( order )

	if not order then
		order = file.Read( "wos/dynabase/usermounts/preference.txt", "DATA" ) or "{}"
		order = util.JSONToTable( order )
	end

	local shared_tbl = {}
	local male_tbl = {}
	local female_tbl = {}
	local zombie_tbl = {}

	for _, mount in ipairs( order ) do
		if not mount.Toggled then continue end
		local data = self:GetUserMount( mount.Name )
		if not data then continue end
		
		if data.Shared and not table.HasValue( shared_tbl, data.Shared ) then
			table.insert( shared_tbl, data.Shared )
		end

		if data.Male and not table.HasValue( male_tbl, data.Male ) then
			table.insert( male_tbl, data.Male )
		end

		if data.Female and not table.HasValue( female_tbl, data.Female ) then
			table.insert( female_tbl, data.Female )
		end

		if data.Zombie and not table.HasValue( zombie_tbl, data.Zombie ) then
			table.insert( zombie_tbl, data.Zombie )
		end

	end

	added = male_tbl
	WRITE_TO_LOCAL( INCLUDE_MODEL_START, INCLUDE_MODEL_END_MALE, WOS_DYNABASE.MALE )
	
	added = female_tbl
	WRITE_TO_LOCAL( INCLUDE_MODEL_START, INCLUDE_MODEL_END_FEMALE, WOS_DYNABASE.FEMALE )

	added = zombie_tbl
	WRITE_TO_LOCAL( INCLUDE_MODEL_START, INCLUDE_MODEL_END_ZOMBIE, WOS_DYNABASE.ZOMBIE )

	added = shared_tbl
	WRITE_TO_LOCAL( INCLUDE_MODEL_START, INCLUDE_MODEL_END_SHARED, WOS_DYNABASE.SHARED )
end

file.CreateDir("wos/dynabase/usermounts")
--lua/wos/dynabase/core/cl_net.lua:
wOS = wOS or {}
wOS.DynaBase = wOS.DynaBase or {}

net.Receive( "wOS.DynaBase.SendAllRegisters", function()
	wOS.DynaBase.EnforceCount = net.ReadUInt( 32 )
	for i=1, wOS.DynaBase.EnforceCount do
		local name = net.ReadString()
		local tbl = wOS.DynaBase:GetSource( name )
		if not tbl then wOS.DynaBase:RegisterSource({Name = name, ServerValid = true}) return end
		tbl.ServerValid = true
	end
end )

net.Receive( "wOS.DynaBase.SendRegister", function()
	local name = net.ReadString()
	local tbl = wOS.DynaBase:GetSource( name )
	if not tbl then wOS.DynaBase:RegisterSource({Name = name, ServerValid = true}) return end
	tbl.ServerValid = true
	wOS.DynaBase.EnforceCount = wOS.DynaBase.EnforceCount + 1
end )

net.Receive( "wOS.DynaBase.ForceMountCallback", function()
	local tbl = cvars.GetConVarCallbacks( "wos_dynabase_mountorder" ) or {}

	local oldval = net.ReadString()
	local newval = net.ReadString()

	for _, func in ipairs( tbl ) do
		func( "wos_dynabase_mountorder", oldval, newval )
	end
end )
--addons/xenin_framework/lua/xeninui/libs/shadows.lua:
return gluapack()()
--addons/xenin_framework/lua/xeninui/libs/configurator/main.lua:
return gluapack()()
--addons/xenin_framework/lua/xeninui/libs/configurator/classes/cache.lua:
do
  local _class_0
  local _base_0 = {
    __name = "XeninUI.Configurator.Cache",
    get = function(self, id)
      return self.cache[id]
    end,
    set = function(self, id, val)
      self.cache[id] = val
    end,
    __type = function(self)
      return self.__name
    end
  }
  _base_0.__index = _base_0
  _class_0 = setmetatable({
    __init = function(self)
      self.cache = {}
    end,
    __base = _base_0
  }, {
    __index = _base_0,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  XeninUI.Configurator.Cache = _class_0
end

--addons/xenin_framework/lua/xeninui/libs/configurator/classes/entity.lua:
local function __laux_concat_0(...)
  local arr = {
  ...
  }
  local result = {}
  for _, obj in ipairs(arr) do
    for i = 1, #obj do
      result[#result + 1] = obj[i]
    end
    for k, v in pairs(obj) do
      if type(k) == "number" and k > #obj then result[k] = v
      elseif type(k) ~= "number" then
        result[k] = v
      end
    end
  end
  return result
end
do
  local _class_0
  local _base_0 = {
    __name = "XeninUI.Configurator.Entity",
    setDatabaseEntity = function(self, databaseEntity)
      self.databaseEntity = databaseEntity
      return self
    end,
    getDatabaseEntity = function(self)
      return self.databaseEntity
    end,
    getColumns = function(self)
      return self.columns
    end,
    getColumn = function(self, id)
      for i, v in ipairs(self.columns) do
        if (v.id != id) then continue end

        return v, i
      end
    end,
    addColumn = function(self, id, data)
      table.insert(self.columns, __laux_concat_0({
      id = id
      }, data))

      local name = id:sub(1, 1):upper() .. id:sub(2)
      self["set" .. tostring(name)] = function(self, val, deserialize)
        if deserialize then
          if (data.csv and isstring(val)) then
            val = string.Explode(",", val)
          elseif (isstring(val) and (data.type == "list" or data.json)) then
            val = util.JSONToTable(val)
          end
        end

        self[id] = val

        return self
      end
      self["set" .. tostring(id)] = function(self, ...)
        self["set" .. tostring(name)](self, ...)end
      self["get" .. tostring(name)] = function(self, serialize)
        if serialize then
          if (data.csv and istable(self[id])) then
            return table.concat(self[id], ",")
          elseif istable(self[id]) then
            return util.TableToJSON(self[id])
          end
        end

        return self[id]
      end
      self["get" .. tostring(id)] = function(self, ...)
        return self["get" .. tostring(name)](self, ...)end
    end,
    getSQLTableName = function(self)
      local str = self:getDatabaseEntity():lower()
      str = str:Replace(".", "_")

      return "xenin_configurator_entity_" .. str
    end,
    createSQLTable = function(self)
      local tableName = self:getSQLTableName()
      XeninUI.ORM.Table(XeninDB, tableName, function(tbl)
        for i, v in ipairs(self:getColumns()) do
          assert(v ~= nil, "cannot destructure nil value")
          local type, length, primary, null, default = v.type, v.length, v.primary, v.null, v.default
          local dataType = type == "list" and "text" or type
          local col = tbl[dataType](tbl, v.id)
          if primary then col:primary()end
          if length then col:length(length)end
          if null then col:nullable()end
          if default then
            local notExpressions = {
              integer = true,
              string = true
            }

            local isExpression = !notExpressions[type]
            col:default(default, isExpression)
          end
        end
      end, function()
        self:seed()
      end)
    end,
    seedData = function(self) end,
    seed = function(self)
      local data = self:seedData()
      if (!data) then return end
      local name = self:getSQLTableName()

      for i, v in ipairs(data) do
        XeninUI.Configurator.ORM:seed(name, v.version, v.code())
      end
    end,
    onNetworkSend = function(self)

      local cols = self:getColumns()
      local size = #cols
      local tbl = {}
      for i, v in ipairs(cols) do
        assert(v ~= nil, "cannot destructure nil value")
        local id = v.id
        local val = self["get" .. tostring(id)](self, true)
        if (!val) then continue end
        if (isstring(val) and val == "") then continue end

        tbl[id] = val
      end

      local size = table.Count(tbl)
      net.WriteUInt(size, 12)
      for i, v in pairs(tbl) do
        net.WriteString(i)
        XeninUI.Configurator.Network:write(v)
      end
    end,
    onNetworkReceive = function(self)
      local cols = self:getColumns()
      local size = net.ReadUInt(12)
      for i = 1, size do
        local id = net.ReadString()
        local val = XeninUI.Configurator.Network:read()

        self["set" .. tostring(id)](self, val, true)
      end
    end,
    onSave = function(self) end,
    onDelete = function(self) end,
    onLoad = function(self) end,
    validateColumn = function(self, id, input)
      local col = self:getColumn(id)
      if (!col) then return end

      if (!col.validate) then return true, "No validation"end

      return col.validate(input)
    end,
    shouldAllowNetwork = function(self, ply)
      return true end,
    save = function(self, admin)
      self:onSave()

      if (!admin) then return end

      if CLIENT then
        XeninUI.Configurator.Network:sendSaveEntity(self)

        return
      end

      XeninUI.Configurator.ORM:saveEntity(self)

      self:network()
    end,
    network = function(self, target)
      if (!target) then
        target = {}
        for i, v in ipairs(player.GetAll()) do
          if (!self:shouldAllowNetwork(v)) then continue end

          table.insert(target, v)
        end

        if (table.IsEmpty(target)) then return end
      end

      XeninUI.Configurator.Network:sendEntity(target, self)
    end,
    createNewEntity = function(self)
      if CLIENT then
        XeninUI.Configurator.Network:sendCreateEntity(self)

        return
      end

      XeninUI.Configurator.ORM:createEntity(self)
    end,
    delete = function(self, admin)
      self:onDelete()

      if (!admin) then return end

      if CLIENT then
        XeninUI.Configurator.Network:sendDeleteEntity(self)

        return
      end

      XeninUI.Configurator.ORM:deleteEntity(self)
    end,
    isDatabaseEntity = function(self)
      return true end,
    __type = function(self)
      return self.__name
    end
  }
  _base_0.__index = _base_0
  _class_0 = setmetatable({
    __init = function(self)
      self.columns = {}
    end,
    __base = _base_0,
    register = function(name, entity)
      local __laux_type = (istable(entity) and entity.__type and entity:__type()) or type(entity)
      assert(__laux_type == "XeninUI.Configurator.Entity", "Expected parameter `entity` to be type `XeninUI.Configurator.Entity` instead of `" .. __laux_type .. "`")
      XeninUI.Configurator.Entities:register(name, entity)
    end
  }, {
    __index = _base_0,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  XeninUI.Configurator.Entity = _class_0
end

--addons/xenin_framework/lua/xeninui/libs/configurator/ui/settings.lua:
local PANEL = {}

XeninUI:CreateFont("Xenin.Configurator.Admin.Panel.Title", 40)
XeninUI:CreateFont("Xenin.Configurator.Admin.Panel.Navbar", 24)
XeninUI:CreateFont("Xenin.Configurator.Admin.Panel.Setting", 18)
XeninUI:CreateFont("Xenin.Configurator.Admin.Panel.Setting.Italic", 18, nil, {
italic = true
})
XeninUI:CreateFont("Xenin.Configurator.Admin.Panel.Category", 22)
XeninUI:CreateFont("Xenin.Configurator.Admin.Panel.Selectbox", 18)
XeninUI:CreateFont("Xenin.Configurator.Admin.Panel.Save", 24)

AccessorFunc(PANEL, "m_networkId", "NetworkId")

function PANEL:OnSearch() end

function PANEL:Init()
  self.Categories = {}
  self.Settings = {}

  self:DockPadding(16, 16, 16, 16)

  self:SetNetworkId("settings")

  self.Navbar = self:Add("XeninUI.Navbar")
  self.Navbar:Dock(TOP)
  self.Navbar.accent = XeninUI.Theme.Purple
  self.Navbar.textActive = color_white
  self.Navbar.font = "Xenin.Configurator.Admin.Panel.Navbar"
  self.Navbar.padding = 40
  self.Navbar.startHeight = 50
  self.Navbar.dockLeft = 0
  self.Navbar.Paint = function(pnl, w, h)
    XeninUI:DrawRoundedBoxEx(6, 0, 0, w, h, XeninUI.Theme.Primary, true, true, false, false)
  end
  self.Navbar:SetBody(self)

  self.Bottom = self:Add("Panel")
  self.Bottom:Dock(BOTTOM)
  self.Bottom:DockMargin(0, 16, 0, 0)
  self.Bottom:SetTall(32)

  self.Save = self.Bottom:Add("XeninUI.ButtonV2")
  self.Save:Dock(RIGHT)
  self.Save:SetText("Save")
  self.Save:SetFont("Xenin.Configurator.Admin.Panel.Save")
  self.Save:SetRoundness(6)
  self.Save:SetSolidColor(XeninUI.Theme.Accent)
  self.Save:SetHoverColor(XeninUI.Theme.Green)
  self.Save:SetTextColor(color_white)
  self.Save:SizeToContentsX(24)
  self.Save.DoClick = function(pnl)
    local id = self:GetNetworkId()
    local settings = {}
    for tabName, tab in pairs(self.Navbar.panels) do
      for i, v in ipairs(tab.Settings) do
        if (!v:IsVisible()) then continue end

        local id = v.Data.id
        local val = v.Input:GetSettingValue()

        self.ctr:set(id, val)
        settings[id] = val
      end
    end

    XeninUI.Configurator.Network:sendSaveSettings(self.script, settings)
  end
  XeninUI:AddRippleClickEffect(self.Save, color_black)
end

function PANEL:PerformLayout(w, h)
  self.Navbar:SetTall(self.Navbar.startHeight)
end

function PANEL:SetTitle(title) end

function PANEL:CreateCategory(name)
  local panel = self.Body:Add("DPanel")
  panel:Dock(TOP)
  panel:DockPadding(0, 36, 0, 40)
  panel.Name = name
  panel.Paint = function(pnl, w, h)

    draw.SimpleText(pnl.Name, "Xenin.Configurator.Admin.Panel.Category", 8, 32 / 2, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
  end
  panel.PerformLayout = function(pnl, w, h)
    pnl:SizeToChildren(false, true)
  end

  return panel
end

function PANEL:GetCategories()
  return self.Categories
end

function PANEL:GetCategory(cat)
  return self.Categories[cat]
end

function PANEL:SetController(ctr)
  local tabs = self.ctr:getSettingTabs()
  local settings = self.ctr:getSettingsByCategory()
  for i, v in ipairs(tabs) do
    self.Navbar:AddTab(v.name, "Xenin.Configurator.Admin.Panel.Setting", settings[v.name])
  end
  if tabs[1] then
    self.Navbar:SetActive(tabs[1].name)
  end
end

function PANEL:SetSettings(tbl)
  self.settings = tbl

  for i, v in ipairs(tbl) do
    self:AddSetting(v)
  end
end

function PANEL:SetScript(script)
  self.script = script
  self.ctr = XeninUI.Configurator:FindControllerByScriptName(script)
end

function PANEL:SetData(data)
  self:SetTitle(data.name)
  self:SetController(self.ctr)
end

vgui.Register("Xenin.Configurator.Admin.Panel", PANEL, "XeninUI.Panel")


local PANEL = {}

function PANEL:Init()
  self.Categories = {}
  self.Settings = {}

  self.Top = self:Add("Panel")
  self.Top:Dock(TOP)
  self.Top.Paint = function(pnl, w, h)
    XeninUI:DrawRoundedBoxEx(6, 0, 0, w, h, XeninUI.Theme.Navbar, false, false, true, true)
  end

  self.Navbar = self.Top:Add("DPanel")
  self.Navbar:Dock(FILL)
  self.Navbar.Paint = function() end
  self.Navbar.SetActive = function(pnl, id)
    local active = pnl.Active
    pnl.Active = id

    local btn = pnl.Buttons[active]
    if IsValid(btn) then
      btn:LerpColor("TextColor", Color(145, 145, 145))
    end

    btn = pnl.Buttons[id]
    if (!IsValid(btn)) then return end

    if active then
      btn:LerpColor("TextColor", color_white)
      local cat = self:GetCategory(btn:GetText())
      if ispanel(cat) then
        self.Scroll:ScrollToChild(cat)
      end
    else
      btn.TextColor = color_white
    end
  end
  self.Navbar.Buttons = {}
  self.Navbar.AddButton = function(pnl, name)
    local btn = pnl:Add("DButton")
    btn:Dock(LEFT)
    btn:SetText(name)
    btn:SetFont("Xenin.Configurator.Admin.Panel.Setting.Navbar")
    btn:SizeToContentsX(24)
    btn:SizeToContentsY()
    btn.TextColor = Color(145, 145, 145)
    btn.Paint = function(pnl, w, h)
      pnl:SetTextColor(pnl.TextColor)
    end
    btn.OnCursorEntered = function(pnl)
      pnl:LerpColor("TextColor", color_white)
    end
    btn.OnCursorExited = function()
      if (pnl.Active == btn.Id) then return end

      btn:LerpColor("TextColor", Color(145, 145, 145))
    end
    btn.DoClick = function()
      pnl:SetActive(btn.Id)
    end

    local id = table.insert(pnl.Buttons, btn)
    pnl.Buttons[id].Id = id
  end
  self.Navbar.SetActiveButtonByName = function(pnl, name)
    for i, v in ipairs(pnl.Buttons) do
      if (v:GetText() != name) then continue end

      v:LerpColor("TextColor", color_white)
      pnl:SetActive(v.Id)
    end
  end

  self.Scroll = self:Add("XeninUI.Scrollpanel.Wyvern")
  self.Scroll:Dock(FILL)
  self.Scroll:DockMargin(0, 16, 0, 0)

  self.Body = self.Scroll:Add("Panel")

  self:SetActive(1)
end

function PANEL:SetData(data)
  if (!istable(data)) then return end

  self.settings = data
  for i, v in ipairs(data) do
    self:AddSetting(v)
  end
  self:SetActive(1)
end

function PANEL:CreateCategory(name)
  local panel = self.Body:Add("DPanel")
  panel:Dock(TOP)
  panel:DockPadding(0, 28, 0, 20)
  panel.Name = name
  panel.Paint = function(pnl, w, h)

    draw.SimpleText(pnl.Name, "Xenin.Configurator.Admin.Panel.Category", 8, 32 / 2, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
  end
  panel.PerformLayout = function(pnl, w, h)
    pnl:SizeToChildren(false, true)
  end

  return panel
end

function PANEL:GetCategory(cat)
  return self.Categories[cat]
end

function PANEL:HighlightSetting(cat, id)
  for catId, catPnl in pairs(self.Categories) do
    if (catId != cat) then continue end

    for i, v in ipairs(catPnl:GetChildren()) do
      if (v.Data.id != id) then continue end

      v:Highlight()

      return v, i
    end
  end
end

function PANEL:AddSetting(tbl)
  if (!self.Categories[tbl.subCategory]) then
    local foundCat
    for i, v in pairs(self.Navbar.Buttons) do
      if (v:GetText() != tbl.subCategory) then continue end

      foundCat = true
      break
    end
    if (!foundCat) then
      self:AddButton(tbl.subCategory)
    end
    self.Categories[tbl.subCategory] = self:CreateCategory(tbl.subCategory)
  end

  local input = XeninUI.Configurator:CreateInputPanel(tbl.type, self, tbl)
  if input.SetData then
    input:SetData(tbl.data)
  end
  if input.SetInput then
    input:SetInput(tbl.value)
  end

  local panel = self.Categories[tbl.subCategory]:Add("DPanel")
  input:SetParent(panel)
  panel:Dock(TOP)
  panel.Data = tbl
  panel.Height = input.Height or 48
  panel:SetTall(input.Height or 48)
  panel.Input = input
  panel.Markup = markup.Parse("<font=Xenin.Configurator.Admin.Panel.Setting><color=145,145,145>" .. tostring(tbl.name) .. "</color></font>")
  panel.Paint = function(pnl, w, h)
    local x = 0
    if tbl.onPaint then x = x + tbl.onPaint(pnl, w, h)
    end
    surface.SetDrawColor(100, 100, 100)
    surface.DrawRect(0, h - 1, w, 1)

    pnl.Markup:Draw(x + 8, 48 / 2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
  end
  panel.FlashAlpha = 0
  panel.PaintOver = function(pnl, w, h)
    local alpha = pnl.FlashAlpha
    if (alpha <= 1) then return end

    surface.SetDrawColor(ColorAlpha(XeninUI.Theme.Green, alpha / (255 / 50)))
    surface.DrawRect(0, 0, w, h)

    XeninUI:MaskInverse(function()
      surface.DrawRect(1, 1, w - 2, h - 2)
    end, function()
      surface.SetDrawColor(ColorAlpha(XeninUI.Theme.Green, alpha))
      surface.DrawRect(0, 0, w, h)
    end)
  end
  panel.Highlight = function(pnl)
    pnl:EndAnimations()

    pnl:Lerp("FlashAlpha", 255, 0.7, function()
      timer.Simple(0.2, function()
        if (!IsValid(pnl)) then return end

        pnl:Lerp("FlashAlpha", 0, 0.5)
      end)
    end)
  end

  if tbl.func then
    tbl.func(input, panel)
  end
  if (tbl.onChange or tbl.data.onChange) then
    input.onChange = tbl.onChange or tbl.data.onChange
  end
  if tbl.data.postInit then
    tbl.data.postInit(input, panel)
  end
  if tbl.data.hidden then
    panel:SetVisible(false)
  end
  panel.PerformLayout = function(pnl, w, h)
    local l, t, r, b = pnl.Input:GetDockMargin()
    pnl.Input:SetTall(h - t - b)
    pnl.Input:SetPos(w - l - pnl.Input:GetWide() - r, t)
  end

  table.insert(self.Settings, panel)
end

function PANEL:SetActive(id)
  self.Navbar:SetActive(id)
end

function PANEL:AddButton(name)
  self.Navbar:AddButton(name)
end

function PANEL:PerformLayout(w, h)
  self.Top:SetTall(38)

  if IsValid(self.Body) then
    self.Body:SetWide(math.min(600, w - 56))
    self.Body:SizeToContentsY()
    self.Body:Center()
    self.Body:SizeToChildren(false, true)
  end

  for i, v in ipairs(self.Settings) do
    v:SetTall(v.Height or 48)
  end
end

XeninUI:CreateFont("Xenin.Configurator.Admin.Panel.Setting.Navbar", 18)

vgui.Register("Xenin.Configurator.Admin.Panel.Setting", PANEL, "XeninUI.Panel")

--addons/xenin_framework/lua/xeninui/libs/configurator/ui/entities/entity_list.lua:
return gluapack()()
--addons/xenin_framework/lua/xeninui/libs/configurator/ui/inputs/checkbox.lua:
return gluapack()()
--addons/xenin_framework/lua/xeninui/libs/configurator/ui/inputs/textentrywithlabel.lua:
return gluapack()()
--addons/xenin_framework/lua/xeninui/libs/players/ui/notifications/main.lua:
local PANEL = {}

XeninUI:CreateFont("XeninUI.Players.Notifications", 20)

function PANEL:Init()
  self:DockPadding(16, 16, 16, 16)

  self.Top = self:Add("Panel")
  self.Top:Dock(TOP)

  self.Top.Title = self.Top:Add("DLabel")
  self.Top.Title:Dock(LEFT)
  self.Top.Title:SetFont("XeninUI.Players.Notifications")
  self.Top.Title:SetTextColor(Color(222, 222, 222))
  self.Top.Title:SetText("Latest Notifications")

  self.Scroll = self:Add("XeninUI.Scrollpanel.Wyvern")
  self.Scroll:Dock(FILL)
  self.Scroll:DockMargin(0, 8, 0, 0)

  self.Layout = self.Scroll:Add("DListLayout")
  self.Layout:Dock(TOP)
  self.Layout:DockMargin(0, 0, 8, 0)

  self.Loading = true
  hook.Add("XeninUI.Players.GotNotifications", self, function(self, notifications)
    if self.Loading then
      self:ClearNotifications()
      for i, v in ipairs(notifications) do
        self:AddNotification(v)
      end
      self.Loading = false
      self:InvalidateLayout()
    end
  end)

  self:GetNotifications()

  self:AddTimer("XeninUI.Players.Notifications.UpdateRead", 1, 0, function()
    if (!IsValid(self)) then return end

    local notificationPanels = self:GetNotificationsInView()
    local notifications = {}
    for i, v in ipairs(notificationPanels) do
      if (!v.Notification) then continue end
      if (v.Notification.readAt) then continue end

      v.Notification.readAt = os.time()
      v.BackgroundColor = XeninUI.Theme.Primary

      table.insert(notifications, v.Notification.id)
    end

    if (#notifications == 0) then return end
    XeninUI.Players.Network:sendReadNotifications(notifications)
  end)
end

function PANEL:GetNotifications()
  XeninUI.Players.Network:sendReceiveNotifications()
end

function PANEL:ClearNotifications()
  self.Layout:Clear()
end

function PANEL:AddNotification(notification)
  local row = self.Layout:Add("XeninUI.Players.Notifications.Row")
  row:Dock(TOP)
  row:DockMargin(0, 0, 0, 4)
  row:SetNotification(notification)
end

function PANEL:PerformLayout(w, h)
  self.Top.Title:SizeToContents()

  for i, v in ipairs(self.Layout:GetChildren()) do
    v:SetTall(v:CalculateHeight())
    print(v:IsVisible())
  end
end

function PANEL:Paint(w, h)
  if self.Loading then
    draw.SimpleText("Loading", "XeninJC.Admin.Queue.Loading", w / 2, h / 2 - h / 8, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM)
    XeninUI:DrawLoadingCircle(w / 2, h / 2 + 16, h / 4, XeninUI.Theme.Accent)
  end
end

function PANEL:GetNotificationsInView()
  local sH = self.Scroll:GetTall()
  local sY = self.Scroll.VBar.Scroll
  local sB = sH + sY

  local notifications = {}
  for i, v in ipairs(self.Layout:GetChildren()) do
    assert(v ~= nil, "cannot destructure nil value")
    local y = v.y
    if (y > sB) then continue end
    if (sY > y) then continue end
    if (sB < y) then continue end
    if (!v.Notification) then continue end
    if (v.Notification.readAt) then continue end

    table.insert(notifications, v)
  end

  return notifications
end

vgui.Register("XeninUI.Players.Notifications", PANEL)

--addons/xenin_framework/lua/xeninui/libs/players/network/shared.lua:
do
  local _class_0
  local _base_0 = {
    __name = "XeninUI.Players.NetworkHelper",
    __type = function(self)
      return self.__name
    end
  }
  _base_0.__index = _base_0
  _class_0 = setmetatable({
    __init = function(self) end,
    __base = _base_0,
    sendNotification = function(notification)
      assert(notification ~= nil, "cannot destructure nil value")
      local scriptId, type, content, createdAt, readAt, data, id = notification.scriptId, notification.type, notification.content, notification.createdAt, notification.readAt, notification.data, notification.id

      net.WriteString(scriptId)
      net.WriteString(type)
      net.WriteString(content)
      net.WriteString(createdAt)
      net.WriteBool(istable(data))
      if istable(data) then
        net.WriteTable(data)
      end
      net.WriteBool(readAt != nil)
      if readAt then
        net.WriteString(readAt)
      end
      net.WriteBool(id != nil)
      if id then
        net.WriteUInt(id, 32)
      end
    end,
    receiveNotification = function()
      local notification = {
        scriptId = net.ReadString(),
        type = net.ReadString(),
        content = net.ReadString(),
        createdAt = net.ReadString()
      }
      local hasData = net.ReadBool()
      if hasData then
        notification.data = net.ReadTable()
      end
      local hasRead = net.ReadBool()
      if hasRead then
        notification.readAt = net.ReadString()
      end
      local hasId = net.ReadBool()
      if hasId then
        notification.id = net.ReadUInt(32)
      end

      return notification
    end
  }, {
    __index = _base_0,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  XeninUI.Players.NetworkHelper = _class_0
end

--addons/xenin_framework/lua/xeninui/elements/checkbox.lua:
return gluapack()()
--addons/xenin_framework/lua/xeninui/elements/dropdown_player.lua:
return gluapack()()
--addons/xenin_framework/lua/xeninui/elements/options.lua:
local function __laux_concat_0(...)
  local arr = {
  ...
  }
  local result = {}
  for _, obj in ipairs(arr) do
    for i = 1, #obj do
      result[#result + 1] = obj[i]
    end
    for k, v in pairs(obj) do
      if type(k) == "number" and k > #obj then result[k] = v
      elseif type(k) ~= "number" then
        result[k] = v
      end
    end
  end
  return result
end
local PANEL = {}

AccessorFunc(PANEL, "m_font", "Font")

XeninUI:CreateFont("XeninUI.Options.Button", 22)

function PANEL:Init()
  self:SetDrawOnTop(true)
  self:SetZPos(125)
  self:DockPadding(8, 8, 8, 8)
  self.Alpha = 0
  self:LerpAlpha(255, 0.3)
  self:SetFont("XeninUI.Options.Button")
end

function PANEL:OnFocusChanged(gained)
  if (gained) then return end

  self:Close()
end

function PANEL:Close()
  if (self.Removing) then return end

  self.Removing = true
  self:LerpAlpha(255, 0.1)
  self:LerpHeight(0, 0.1, function()
    if (!IsValid(self)) then return end

    self:Remove()
  end)
end

function PANEL:GetNewSize()
  local width = 16
  local height = 16

  local children = self:GetChildren()
  local size = #children
  for i, v in ipairs(children) do
    if (v.RowType == self.Options.BUTTON) then
      surface.SetFont(v.Font)
      local tW = surface.GetTextSize(v.Text)

      tW = tW + 32

      if v.IconBackground then tW = tW + 53
      end

      width = math.max(width, tW)
    end

    height = height + v:GetTall()
    if (i != size) then height = height + 8
    end
  end

  return math.max(150, width), height
end

function PANEL:UpdatePos()
  local parent = self.Parent
  if (!IsValid(parent)) then self:Remove()end

  local aX, aY = parent:LocalToScreen()
  local x = self:GetWide() - parent:GetWide()
  local y = parent:GetTall()
  self:SetPos(aX - x, aY + y)
end

function PANEL:CreateButton(data)
  local btn = self:Add("DButton")
  btn:SetTall(53)
  btn:SetText("")
  local hoverColor = data.hoverColor or XeninUI.Theme.Primary
  btn.Background = ColorAlpha(hoverColor, 0)
  btn.Text = data.text
  btn.TextColor = data.textColor or color_white
  btn.Font = data.font or self:GetFont()
  if data.icon then
    XeninUI:DownloadIcon(btn, data.icon)
    btn.IconBackground = Color(58, 58, 58)
    btn.IconColor = data.iconColor or btn.TextColor
    btn.IconHoverColor = data.iconHoverColor or btn.IconColor
  end
  btn.Paint = function(pnl, w, h)
    XeninUI:DrawRoundedBox(6, 0, 0, w, h, pnl.Background)

    local x = 8
    if pnl.Icon then
      local size = h - 16
      XeninUI:DrawCircle(x + size / 2, size / 2 + x, size / 2, 30, pnl.IconBackground)
      size = size - 16
      XeninUI:DrawIcon(x + 8, 16, size, size, pnl, pnl.IconColor)

      x = x + h
    end

    draw.SimpleText(pnl.Text, pnl.Font, x, h / 2, pnl.TextColor, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
  end
  btn.PaintOver = function(pnl, w, h)
    if (!pnl.Pressing) then return end
    local frac = math.TimeFraction(pnl.Pressing, pnl.End, CurTime())
    local col = XeninUI:LerpColor(frac, XeninUI.Theme.Red, XeninUI.Theme.Green)

    local aX, aY = pnl:LocalToScreen()
    render.SetScissorRect(aX, aY, aX + (w * frac), aX + h, true)
    XeninUI:DrawRoundedBox(6, 0, 0, w, h, ColorAlpha(data.hold.color, 100))
    render.SetScissorRect(0, 0, ScrW(), ScrH(), false)
  end
  btn.OnCursorEntered = function(pnl)
    pnl:LerpColor("Background", ColorAlpha(hoverColor, 100))
    if data.icon then
      pnl:LerpColor("IconColor", pnl.IconHoverColor)
    end
  end
  btn.OnCursorExited = function(pnl)
    pnl:LerpColor("Background", ColorAlpha(hoverColor, 0))
    if data.icon then
      pnl:LerpColor("IconColor", data.iconColor or btn.TextColor)
    end
  end
  if data.hold then
    btn.Think = function(pnl)
      if (!pnl.Pressing) then return end
      local frac = math.Clamp(math.TimeFraction(pnl.Pressing, pnl.End, CurTime()), 0, 1)
      if (frac < 1) then return end
      if (pnl.Clicked) then return end
      pnl.Clicked = true

      if data.onClick then
        data:onClick(pnl)
      end

      self:Close()
    end
    btn.OnMousePressed = function(pnl)
      local wait = data.hold.time
      local time = CurTime()

      pnl.Clicked = nil
      pnl.Pressing = time
      pnl.End = CurTime() + wait
    end
    btn.OnMouseReleased = function(pnl)
      pnl.Clicked = nil
      pnl.Pressing = nil
      pnl.End = nil
    end
  else
    btn.DoClick = function(pnl)
      if data.onClick then
        local stop = data:onClick(pnl) != nil

        if (stop) then return end
      end

      self:Close()
    end
  end

  return btn
end

function PANEL:CreateDivider(data)
  local divider = self:Add("DPanel")
  divider:SetTall(data.thickness or 1)
  divider.Color = data.color or Color(64, 64, 64)
  divider.Paint = function(pnl, w, h)
    surface.SetDrawColor(pnl.Color)
    surface.DrawRect(0, 0, w, h)
  end

  return divider
end

function PANEL:SetOptions(options)
  self.Options = options
  assert(options ~= nil, "cannot destructure nil value")
  local rows, BUTTON, DIVIDER = options.rows, options.BUTTON, options.DIVIDER

  for i, v in ipairs(rows) do
    local row
    if (v.rowType == BUTTON) then
      row = self:CreateButton(v)
    elseif (v.rowType == DIVIDER) then
      row = self:CreateDivider(v)
    end

    row:Dock(TOP)
    row:DockMargin(0, 0, 0, 8)
    row.RowType = v.rowType
  end

  local width, height = self:GetNewSize()
  self:SetWide(width)
  self:SetTall(0)
  self:LerpHeight(height, 0.3)
  self:MakePopup()
  self:UpdatePos()
end

function PANEL:Think()
  if (!self.Parent) then return end

  if (!IsValid(self.Parent)) then
    return self:Close()
  end

  if (!self.Parent:IsVisible()) then
    return self:Close()
  end
end

function PANEL:Paint(w, h)
  local aX, aY = self:LocalToScreen()

  BSHADOWS.BeginShadow()
  XeninUI:DrawRoundedBox(6, aX, aY, w, h, XeninUI.Theme.Background)
  BSHADOWS.EndShadow(1, 1, 1, 150 * (255 / self:GetAlpha()))

  XeninUI:MaskInverse(function()
    XeninUI:DrawRoundedBox(6, 1, 1, w - 2, h - 2, XeninUI.Theme.Background)
  end, function()
    XeninUI:DrawRoundedBox(6, 0, 0, w, h, ColorAlpha(XeninUI.Theme.Primary, self:GetAlpha()))
  end)
end

vgui.Register("XeninUI.Options", PANEL, "EditablePanel")

do
  local _class_0
  local _base_0 = {
    __name = "XeninUI.Options",
    addButton = function(self, data)
      table.insert(self.rows, __laux_concat_0({
      rowType = self.BUTTON
      }, data))

      return self
    end,
    addDivider = function(self, data)
      if data == nil then data = {}
      end
      table.insert(self.rows, __laux_concat_0({
      rowType = self.DIVIDER
      }, data))

      return self
    end,
    create = function(self)
      self.panel = vgui.Create("XeninUI.Options")
      self.panel.Parent = self.parent
      self.panel:SetOptions(self)

      return self.panel
    end,
    __type = function(self)
      return "XeninUI.Options"end
  }
  _base_0.__index = _base_0
  _class_0 = setmetatable({
    __init = function(self, parent)
      self.rows = {}
      self.DIVIDER = 1
      self.BUTTON = 0
      self.parent = parent
    end,
    __base = _base_0
  }, {
    __index = _base_0,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  XeninUI.Options = _class_0
end

--addons/xenin_framework/lua/xeninui/elements/panel.lua:
return gluapack()()
--addons/xenin_framework/lua/xeninui/libs/units/classes/assert.lua:
return gluapack()()
--addons/xenin-coinflip/lua/coinflip/essentials/i18n.lua:
return gluapack()()
--addons/xenin-coinflip/lua/coinflip/currencies/darkrp.lua:
local CURRENCY = {}
CURRENCY.Name = "Money"

function CURRENCY:Add(ply, amt)
	ply:addMoney(amt)
end
function CURRENCY:CanAfford(ply, amt)
	return ply:canAfford(amt)
end
function CURRENCY:Format(amt)
	return DarkRP.formatMoney(amt)
end

Coinflip:CreateCurrency("DarkRP", CURRENCY)
--addons/xenin-coinflip/lua/coinflip/ui/games_create.lua:
return gluapack()()
--addons/xenin-inventory/lua/inventory/classes/item.lua:
return gluapack()()
--addons/xenin-inventory/lua/inventory/languages/danish.lua:
return gluapack()()
--addons/xenin-inventory/lua/inventory/languages/turkish.lua:
return gluapack()()
--addons/xenin-inventory/lua/inventory/configuration/config.lua:
return gluapack()()
--addons/xenin-inventory/lua/inventory/configuration/items/spawned_weapon.lua:
return gluapack()()
--addons/zeros_methlab_1.6.4/lua/inventory/configuration/items/zmlab_collectcrate.lua:
return gluapack()()
--addons/zeros_methlab_1.6.4/lua/inventory/configuration/items/zmlab_collectcrate.lua:
local ITEM = XeninInventory:CreateItemV2()
ITEM:SetMaxStack(1)
ITEM:SetModel("models/zerochain/zmlab/zmlab_transportcrate.mdl")
ITEM:SetDescription("A crate used for transporting meth.")

ITEM:AddDrop(function(self, ply, ent, tbl, tr)
	local data = tbl.data

	ent:SetMethAmount(data.MethAmount)
	zmlab.f.TransportCrate_XeninDrop(ent)
	zmlab.f.SetOwner(ent, ply)
end)

function ITEM:GetData(ent)
	return {
		MethAmount = ent:GetMethAmount(),
	}
end

function ITEM:GetVisualAmount(item)
	return item.data.MethAmount
end

function ITEM:GetName(item)
	return "Transport Crate"
end

function ITEM:GetCameraModifiers(tbl)
	return {
		FOV = 40,
		X = 0,
		Y = -30,
		Z = 25,
		Angles = Angle(0, 15, 0),
		Pos = Vector(0, 0, -1.5)
	}
end

function ITEM:GetClientsideModel(tbl, mdlPanel)
	local methAmount = tbl.data.MethAmount

	if methAmount >= zmlab.config.TransportCrate.Capacity then
		mdlPanel.Entity:SetModel("models/zerochain/zmlab/zmlab_transportcrate_full.mdl")
	elseif methAmount > zmlab.config.TransportCrate.Capacity * 0.7 then
		mdlPanel.Entity:SetBodygroup(0, 3)
	elseif methAmount > zmlab.config.TransportCrate.Capacity * 0.5 then
		mdlPanel.Entity:SetBodygroup(0, 2)
	elseif methAmount <= 0 then
		mdlPanel.Entity:SetBodygroup(0, 0)
	else
		mdlPanel.Entity:SetBodygroup(0, 1)
	end
end


ITEM:Register("zmlab_collectcrate")

--addons/zeros_methlab_1.6.4/lua/inventory/configuration/items/zmlab_meth_baggy.lua:
local ITEM = XeninInventory:CreateItemV2()
ITEM:SetMaxStack(1)
ITEM:SetModel("models/zerochain/zmlab/zmlab_methbag.mdl")
ITEM:SetDescription("A bag of meth.")

ITEM:AddDrop(function(self, ply, ent, tbl, tr)
	local data = tbl.data

	ent:SetMethAmount(data.MethAmount)
end)

function ITEM:GetData(ent)
	return {
		MethAmount = ent:GetMethAmount(),
	}
end

function ITEM:GetVisualAmount(item)
	return item.data.MethAmount
end

function ITEM:GetName(item)
	return "Meth baggy"
end

function ITEM:GetCameraModifiers(tbl)
	return {
		FOV = 65,
		X = 0,
		Y = -30,
		Z = 25,
		Angles = Angle(0, 15, 0),
		Pos = Vector(0, 0, -1.5)
	}
end

ITEM:Register("zmlab_meth_baggy")

--addons/xenin-inventory/lua/inventory/configuration/items/zwf_weedblock.lua:
--[[
This code was generated by LAUX, a Lua transpiler
LAUX is a fork of LAU with additional changes.

More info & source code can be found at: https://gitlab.com/sleeppyy/laux
]]

local ITEM = XeninInventory:CreateItemV2()
ITEM:SetMaxStack(1)
ITEM:SetModel("models/zerochain/props_weedfarm/zwf_weedblock.mdl")
ITEM:SetDescription("A block of weed")

ITEM:AddDrop(function(self, ply, ent, tbl, tr)
  local data = tbl.data

  ent:SetWeedID(data.WeedID)
  ent:SetWeedName(data.WeedName)
  ent:SetWeedAmount(data.WeedAmount)
  ent:SetTHC(data.THC)

  zwf.f.SetOwnerByID(ent, data.ZWFOwner)
end)

function ITEM:GetData(ent)
  return {
    WeedID = ent:GetWeedID(),
    WeedName = ent:GetWeedName(),
    WeedAmount = ent:GetWeedAmount(),
    THC = ent:GetTHC(),
    ZWFOwner = zwf.f.GetOwnerID(ent)
  }
end

function ITEM:GetVisualAmount(item)
  return item.data.WeedAmount
end

function ITEM:GetName(item)
  local ent = isentity(item)
  local name = ent and item:GetWeedName() or item.data.WeedName
  local plant = ent and item:GetWeedID() or item.data.WeedID
  plant = zwf.config.Plants[plant].name

  return name .. " " .. plant
end

ITEM:Register("zwf_weedblock")

--addons/yet_another_warn_system/lua/yaws/core/sh_languages.lua:
return gluapack()()
--addons/yet_another_warn_system/lua/yaws/core/cl_ui.lua:
return gluapack()()
--addons/yet_another_warn_system/lua/yaws/core/settings/cl_user_settings.lua:
YAWS.UserSettings.Settings = YAWS.UserSettings.Settings or {
    dark_mode = {
        name = "user_settings_darkmode_name",
        desc = "user_settings_darkmode_desc",
        default = false,
        value = nil,
        type = "boolean",
        category = "interface"
    },
    selected_language = {
        name = "user_settings_language_name",
        desc = "user_settings_language_desc",
        default = "English",
        value = nil,
        type = "combo",
        type_override = "string", -- used for storage stuff
        category = "interface"
    },
    blur_background = {
        name = "user_settings_blur_name",
        desc = "user_settings_blur_desc",
        default = false,
        value = nil,
        type = "boolean",
        category = "interface"
    },
    switch_icons = {
        name = "user_settings_switchicons_name",
        desc = "user_settings_switchicons_desc",
        default = true,
        value = nil,
        type = "boolean",
        category = "accessibility"
    },
    colorblind_text = {
        name = "user_settings_colorblindtxt_name",
        desc = "user_settings_colorblindtxt_desc",
        default = false,
        value = nil,
        type = "boolean",
        category = "accessibility"
    },
    table_view = {
        name = "user_settings_tableview_name",
        desc = "user_settings_tableview_desc",
        default = false,
        value = nil,
        type = "boolean",
        category = "interface"
    },
    disable_fades = {
        name = "user_settings_disablefade_name",
        desc = "user_settings_disablefade_desc",
        default = false,
        value = nil,
        type = "boolean",
        category = "interface"
    },
    disable_ui_anims = {
        name = "user_settings_disableanim_name",
        desc = "user_settings_disableanim_desc",
        default = false,
        value = nil,
        type = "boolean",
        category = "interface"
    },
}
-- UI data that isn't sent over for obvious reasons
YAWS.UserSettings.SettingOrder = {
    [1] = { -- interface
        "dark_mode",
        "selected_language",
        "blur_background",
        "disable_fades",
        "disable_ui_anims",
        "table_view"
    },
    [2] = { -- accessibility
        "switch_icons",
        "colorblind_text"
    },
}

hook.Add('yaws.language.manifsetloaded', "yaws.usersettings.manifestready", function()
    -- langauges aren't loaded on startup so hi 
    YAWS.UserSettings.Settings['selected_language'].options = table.GetKeys(YAWS.Language.Manifest)
    YAWS.UserSettings.Settings['selected_language'].icons = {}
    for k,v in pairs(YAWS.Language.Manifest) do
        YAWS.UserSettings.Settings['selected_language'].icons[k] = v.icon
    end
end)

-- load our settings (ripped from ups / betterbanking)
hook.Add("yaws.core.initalize", "yaws.usersettings.client", function()
    if(!sql.TableExists("yaws_settings")) then
        local create = sql.Query("CREATE TABLE `yaws_settings`(`key` VARCHAR(255) PRIMARY KEY, `value` VARCHAR(255));")

        if(create == false) then
            YAWS.Core.LogError("Something went wrong creating the client-based settings table. This will (most likely) cause errors. Try re-joining the game, if that doesn't work then tell the server developers to create a ticket on gmodstore.")
            YAWS.Core.LogError("Not continuing to fetch settings. Using default values.")
            return
        end
    end

    -- this is a bit of a rats nest but idk how to improve it :/
    local q = sql.Query("SELECT * FROM `yaws_settings`;")
    if(q != nil) then 
        if(q == false) then
            YAWS.Core.LogError("Something went wrong creating the client-based settings table. This will (most likely) cause errors. Try re-joining the game, if that doesn't work then tell the server developers to create a ticket on gmodstore.")
                YAWS.Core.LogError("Not continuing to fetch settings. Using default values.")

            return
        end

        for k,v in ipairs(q) do
            if(!YAWS.UserSettings.Settings[v.key]) then continue end

            local type = YAWS.UserSettings.Settings[v.key].type
            if(YAWS.UserSettings.Settings[v.key].type_override) then 
                type = YAWS.UserSettings.Settings[v.key].type_override
            end 

            local value = YAWS.Core.StorableToLua(v.value, type) -- This func is declared shared in sh_settings and shared files are loaded before client files in the autoloader, so this function definitely exists.
            if(YAWS.UserSettings.Settings[v.key].default == value) then
                sql.Query("DELETE FROM `yaws_settings` WHERE `key` = " .. sql.SQLStr(k) .. ";")
                continue
            end

            YAWS.UserSettings.Settings[v.key].value = value
        end
    end

    YAWS.Core.LogInfo("Successfully loaded client's settings.")
    hook.Run("yaws.usersettings.created")
end)

function YAWS.UserSettings.SetValue(key, val)
    if(YAWS.UserSettings.Settings[key].value == val) then return end
    
    YAWS.UserSettings.Settings[key].value = val
    
    local storable = YAWS.Core.LuaToStorable(val)
    sql.Query("REPLACE INTO `yaws_settings`(`key`, `value`) VALUES(" .. sql.SQLStr(key) .. ", " .. sql.SQLStr(storable) .. ");")
    
    hook.Run("yaws.usersettings.updated", key, val)
end
function YAWS.UserSettings.GetValue(key)
    if(YAWS.UserSettings.Settings[key] == nil) then return end

    if(YAWS.UserSettings.Settings[key].value == nil) then
        return YAWS.UserSettings.Settings[key].default
    end
    return YAWS.UserSettings.Settings[key].value
end
--addons/yet_another_warn_system/lua/yaws/ui/elements/cl_collapsable.lua:
return gluapack()()
--addons/yet_another_warn_system/lua/yaws/ui/elements/cards/cl_settings_entry.lua:
return gluapack()()
--addons/yet_another_warn_system/lua/yaws/ui/elements/inputs/cl_button.lua:
local PANEL = {}

AccessorFunc(PANEL, "label", "Label", FORCE_STRING)
AccessorFunc(PANEL, "font", "Font", FORCE_STRING)

function PANEL:Init() 
    self.label = "Unnamed"
    self.font = "yaws.6"
    -- Tried to store the raw colors here but gmod decided to have the variables
    -- removed one frame and there another. I don't understand this fucking game
    -- sometimes. https://upload.livaco.dev/u/L63qjiTAB2.png
    self.hoverColor = "button_hover"
    self.baseColor = "button_base"
    self.color = YAWS.UI.ColorScheme()[self.baseColor]

    self.lerp = 0
    self.frameTime = RealFrameTime()

    self:SetText("")
end 

function PANEL:SetColors(base, hover)
    self.baseColor = base
    self.hoverColor = hover
end 

function PANEL:Paint(w, h) 
    local colors = YAWS.UI.ColorScheme() 

    if(self:IsHovered()) then 
        self.color = YAWS.UI.LerpColor(self.frameTime * 5, self.color, colors[self.hoverColor])
    else 
        self.color = YAWS.UI.LerpColor(self.frameTime * 5, self.color, colors[self.baseColor])
    end 

    
    draw.RoundedBox(0, 0, 0, w, h, self.color)
    if(self:IsDown()) then 
        draw.RoundedBox(0, 0, 0, w, h, colors['button_faded'])
    end 
    draw.SimpleText(self.label, self.font, w / 2, h / 2, colors['button_text'], 1, 1)
end 

vgui.Register("yaws.button", PANEL, "DButton")
--addons/yet_another_warn_system/lua/yaws/ui/elements/sidebar/cl_sidebar.lua:
local PANEL = {}

function PANEL:Init()
    self.tabs = {}
    self.selected = -1

    -- unsure if to keep this
    self.sideShadow = vgui.Create("yaws.shadow", self:GetParent())
    self.bottomShadow = vgui.Create("yaws.shadow", self:GetParent())
    self.bottomShadow:Down()
end 
function PANEL:Paint(w, h)
    local colors = YAWS.UI.ColorScheme() 
    draw.RoundedBox(0, 0, 0, w, h, colors['bar_background'])
end 

function PANEL:LayoutShadows(w, h)
    local x,y = self:GetPos()
    if(IsValid(self.sideShadow)) then 
        self.sideShadow:SetPos(x + w, y)
        self.sideShadow:SetSize(3, h)
    end 

    if(IsValid(self.bottomShadow)) then 
        self.bottomShadow:SetPos(x, y + h)
        self.bottomShadow:SetSize(w + 1, 3)
    end
end 

function PANEL:RemoveShadows() 
    self.bottomShadow:Remove()
    self.sideShadow:Remove()
end 
function PANEL:OnRemove()
    self:RemoveShadows()
end 

function PANEL:AddTab(name, icon, selectable, callback)
    self.tabs[#self.tabs + 1] = {
        name = name,
        icon = icon,
        callback = callback,
        selectable = selectable,
        bottom = false,
        element = nil
    }

    local element = vgui.Create("yaws.sidebar_button", self)
    element:SetName(name)
    element:SetIcon(icon)
    element:AllowSelectable(selectable)
    element:SetCallback(callback)
    element.id = #self.tabs
    self.tabs[#self.tabs].element = element
    self.tabs[#self.tabs].id = id

    self:InvalidateLayout()
end 
function PANEL:AddBottomTab(name, icon, selectable, callback)
    self.tabs[#self.tabs + 1] = {
        name = name,
        icon = icon,
        callback = callback,
        selectable = selectable,
        bottom = true,
        element = nil
    }

    local element = vgui.Create("yaws.sidebar_button", self)
    element:SetName(name)
    element:SetIcon(icon)
    element:AllowSelectable(selectable)
    element:SetCallback(callback)
    element.id = #self.tabs
    self.tabs[#self.tabs].element = element
    self.tabs[#self.tabs].id = id

    self:InvalidateLayout()
end 

function PANEL:PerformLayout(w, h)
    self:PerformLayoutInternal() 

    -- self:Dock(LEFT)
    -- self:DockPadding(0, 0, 0, 0)
    -- self:SetWide(self:GetTall() * 0.15)

    for k,v in pairs(self.tabs) do 
        if(!v.element) then continue end 

        if(v.bottom) then 
            v.element:Dock(TOP)
        else 
            v.element:Dock(TOP)
        end 
        v.element:SetHeight(v.element:GetWide())
    end 
    self:LayoutShadows(w, h)

    self:PostPerformLayout()
end 

function PANEL:PostPerformLayout() end 

function PANEL:SetSelected(tabID)
    self:UpdateSelected(id)
    self.tabs[tabID].element:DoClick()
    self.selected = tabID
end 
function PANEL:SetSelectedName(name)
    -- this is crude but it should be fine
    for k,v in pairs(self.tabs) do
        if(v.name == name) then
            self:SetSelected(k)
            -- v.element:DoClick()
            break
        end
    end
end 

function PANEL:UpdateSelected(tabID) 
    for k,v in ipairs(self.tabs) do
        if(!v.element) then continue end 
        if(v.element.id == tabID) then continue end
        v.element.selected = false
    end 
end 

-- who thought changing a DPanel base to a yaws.scroll base would be a really shitty, autism inducing idea?
-- at least you can't have too many tabs now
vgui.Register("yaws.sidebar", PANEL, "yaws.scroll")
--addons/advancedkillfeed/lua/z_advancedkillfeed/client/cl_z_advancedkillfeed_data.lua:
-- [[ CREATED BY ZOMBIE EXTINGUISHER]]

/* LOADING DATA*/

-- load data on client
local function LoadClient()
	
	local newSettings = net.ReadTable()
	
	for k,_ in pairs(newSettings) do
		SH_ADVANCEDFEED.Settings[k] = newSettings[k]
	end
	
	-- reload feed font
	CL_ADVANCEDFEED.ReloadFont()

end
net.Receive("z_AdvancedFeedLoadClient",LoadClient)

-- ask server for data
local function RequestServerSettings() 
	net.Start("z_AdvancedFeedRequestLoad")
	net.SendToServer()
end
hook.Add("InitPostEntity","z_AdvancedFeedInitPostEntity",RequestServerSettings)

/* SAVING DATA */
function CL_ADVANCEDFEED.Save()
	
	-- if someone without access tried to save smth, reset their client settings
	if !SH_ADVANCEDFEED.HasAccess(LocalPlayer()) then 
		RequestServerSettings()
		return
	end
	
	net.Start("z_AdvancedFeedSave") 
		net.WriteTable(SH_ADVANCEDFEED.Settings)
	net.SendToServer()
	
end
--addons/advancedkillfeed/lua/autorun/z_advancedkillfeed_version.lua:
-- [[ CREATED BY ZOMBIE EXTINGUISHER]]

/*
	This file is used to check if easy skins is using the latest version
*/
-------------------The script was Leak-Tehtakli >: 3---------------------------------
local gmodstoreLink = "https://api.gmodstore.com/v2/addons/%s/versions"
local apiKey = "1e6b9053f19dc745f665b3ab33e1e6d1139e4797"
local advancedKillfeedID = "6067"
local advancedKillfeedVersion = "2.4.4"
local updateMsg = "[Advanced Killfeed] New version %s available! (curr: %s)"
-------------------The script was Leak-Tehtakli >: 3---------------------------------

--addons/zeros_growop2_v1.6.1/lua/zgo2/util/cl_settings.lua:
return gluapack()()
--addons/zeros_trashman_v1.6.3/lua/autorun/ztm_load.lua:
return gluapack()()
--addons/zeros_yeastbeast_1.1.7/lua/zerosyeastbeast/sh/zyb_materials.lua:
return gluapack()()
--addons/[binbon]misc/lua/autorun/client/!clbinbonmisc.lua:
local vectorcache = Vector(0, 0, 90)
local beyaz, color_red, color_white = Color(210, 210, 210), Color(255,0,0), Color(255,255,255)
local d_simpletext = draw.SimpleTextOutlined
local color_black = Color(16, 16, 16)
local cam_Start3D2D = cam.Start3D2D
local cam_End3D2D = cam.End3D2D

local permitted = {}
local physgunyetkili = {
    ["superadmin"] = true, 
    ["donator+"] = true,
    ["donator"] = true,
    ["superyetki"] = true, 
    ["denetmen"] = true,
    ["toplulukyoneticisi"] = true, 
    ["denetmen"] = true,
    ["genelyetki"] = true,
}

local function GetPermitted()
    permitted = {}
    for _, ply in player.Iterator() do
        if physgunyetkili[ply:GetUserGroup()] then
            table.insert(permitted, ply)
        end
    end
end

timer.Create("adminphysgun:RainbowRefresh", 660, 0, GetPermitted)
GetPermitted()

hook.Add("HUDPaint", "adminphysgun:Rainbow", function()
    local col = HSVToColor(CurTime() % 6 * 60, 1, 1)
    col = Vector(col.r / 255, col.g / 255, col.b / 255)
    local lp = LocalPlayer()
    local localPos = lp:GetPos()
    
    for i = 1, #permitted do
        local ply = permitted[i]
        if not IsValid(ply) then continue end
        if ply ~= lp and ply:GetPos():DistToSqr(localPos) > 500000 then continue end
        
        local weapon = ply:GetActiveWeapon()
        if IsValid(weapon) and weapon:GetClass() == "weapon_physgun" then
            ply:SetWeaponColor(col)
        end
    end
end)

net.Receive("PlayTTS", function()
    local ttsURL = net.ReadString()

    sound.PlayURL(ttsURL, "noplay", function(channel)
        if IsValid(channel) then
            channel:SetVolume(1)
            channel:Play() 
        end
    end)
end)



surface.CreateFont("binbon_enthudtitle", {
    font = "Comfortaa Bold",
    extended = true,
    size = 95,
    weidth = 500,
})

surface.CreateFont("binbon_enthuddesc", {
    font = "Comfortaa",
    extended = true,
    size = 35,
    weidth = 500,
})

surface.CreateFont("binbon_killfeed", {
    font = "Comfortaa",
    extended = true,
    size = 20,
    weidth = 500,
})
hook.Add("HUDPaint", "kamuhud", function()
if LocalPlayer():GetNWBool("kamucezasi") then 
draw.SimpleText("Kamu Cezan Var, işleri yapmayınca geçmeyecek", "binbon_enthuddesc", ScrW() / 2, ScrH() / 2, Color(255,0,0), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
draw.SimpleText(LocalPlayer():GetNWInt("kamucezasikalan", 0).." İş Var", "binbon_enthuddesc", ScrW() / 2, ScrH() / 2 + 50, Color(255,0,0), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
end 
end)
hook.Add("InitPostEntity", "binbon_localplayeropt", function()
    local ply = LocalPlayer()
    function LocalPlayer()
        return ply
    end
end)
local lasthitmarker = nil
hook.Add("ScalePlayerDamage","luctus_hitmarker",function(ply,hitgorup,dmginfo)
    local me = dmginfo:GetAttacker()
    if me == LocalPlayer() then
        lasthitmarker = SysTime()
        surface.PlaySound("physics/flesh/flesh_impact_bullet4.wav")
    end
end)

hook.Add("HUDPaint","luctus_hitmarker",function()
    if lasthitmarker then
        local w = ScrW()/2
        local h = ScrH()/2
        local bright = 255-(SysTime()-lasthitmarker)*200
        surface.SetDrawColor(255,255,255,bright)
        surface.DrawLine(w-10, h-10, w-5, h-5)
        surface.DrawLine(w+10, h-10, w+5, h-5)
        surface.DrawLine(w-10, h+10, w-5, h+5)
        surface.DrawLine(w+10, h+10, w+5, h+5)
        if bright <= 0 then lasthitmarker = nil end
    end
end)

local notyetki = {
    ["user"] = true,
    ["donator+"] = true,
    ["donator"] = true,
} 
hook.Add("InitPostEntity", "binbonmisc_weaponsRenderInit", function()
    local lp = LocalPlayer()
    if not notyetki[lp:GetUserGroup()] then 
    local NOCLIP_MSG = "NOCLIP AÇIK"
    local GODMODE_MSG = "GOD AÇIK"
    local CLOAK_MSG = "CLOAK AÇIK"
    
    local color_red = Color(255,0,0)
    
    hook.Add("HUDPaint", "luctus_admin_display", function()
        local scrw = ScrW()/2
        local scrh = ScrH()/1.3
        if lp:HasGodMode() then
            if lp:InVehicle() then return end
            d_simpletext(GODMODE_MSG,"binbon_enthuddesc",scrw,scrh,color_red,1,1,1,color_black)
        end
        if lp:GetColor().a < 255 then
            
            d_simpletext(CLOAK_MSG,"binbon_enthuddesc",scrw,scrh+28,color_red,1,1,1,color_black)
        end
        if lp:GetMoveType() == 8 then
            if lp:InVehicle() then return end
            d_simpletext(NOCLIP_MSG,"binbon_enthuddesc",scrw,scrh+54,color_red,1,1,1,color_black)
        end
    end)
    end

    local getpos = lp:GetPos()
    timer.Create("bb_cache_localplayer_getpos", 2, 0, function()
        getpos = lp:GetPos()
    end)
    function binbonentdraw(ent, text, font, x, y, padding, boxColor)
        if getpos:DistToSqr(ent:GetPos()) >= 100000 then return end
        local pos = ent:LocalToWorld(vectorcache)
        local ang = ent:GetAngles()
        ang:RotateAroundAxis(ang:Forward(), 90)
        ang:RotateAroundAxis(ang:Right(), -90)
        local fonts = font and "binbon_enthudtitle" or "binbon_enthuddesc"
        cam_Start3D2D(pos, ang, 0.1)
        d_simpletext(text, fonts, x, y, beyaz, 1, 1, 2, color_black)
        cam_End3D2D()
    end
    local function DontDrawMe(self)
        if getpos:DistToSqr(self:GetPos()) > 190000 then return end
        self:DrawModel()
    end
    
    hook.Add("OnEntityCreated", "binbonmisc_weaponsRender", function(ent) if ent:IsWeapon() then ent.RenderOverride = DontDrawMe end end)
    for _, wep in ents.Iterator() do
        if wep:IsValid() and wep:IsWeapon() then wep.RenderOverride = DontDrawMe end
    end
end)

surface.CreateFont("yetkigrupfont", {
    font = "Comfortaa",
    extended = true,
    size = 35,
    weidth = 500,
})

local function ConvertToTime(totalSeconds)
    if not isnumber(totalSeconds) or totalSeconds < 0 then
        return "Geçersiz giriş"
    end

    local hours = math.floor(totalSeconds / 3600)
    local minutes = math.floor((totalSeconds % 3600) / 60)
    local seconds = totalSeconds % 60

    return string.format("%02d:%02d:%02d", hours, minutes, seconds)
end

hook.Add("HUDPaint", "venomrpyazi", function()
    draw.SimpleText("venomrp.com.tr / "..os.date( "%H:%M:%S - %d/%m/%Y" , os.time() ), "binbon_enthuddesc", ScrW() / 2, 20, beyazz, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
end)

net.Receive("new_yetkilisaat", function()
local durum = net.ReadBool()
if durum == true then 
local yetkilikalansaat = 1
timer.Create("yetkisaati", 1, 0, function()
yetkilikalansaat = yetkilikalansaat + 1
end)
hook.Add("HUDPaint", "yetkilisaat_hud", function()
    draw.RoundedBox(8, 15, ScrH() / 2 + 50, 150, 80, Color(30,30,30,200))
    draw.SimpleText("Yetkili Saati", "yetkigrupfont", 90, ScrH() / 2 + 70, beyazz, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
    draw.SimpleText( ConvertToTime(yetkilikalansaat), "yetkigrupfont", 70, ScrH() / 2 + 100, beyazz, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
end)
elseif durum == false then 
hook.Remove("HUDPaint", "yetkilisaat_hud")
timer.Remove("yetkisaati")
yetkilikalansaat = 0
end 
end)


hook.Add("InitPostEntity", "chatmesaji", function()
    local messages = {
        [1] = "Discord'a katılmak için: discord.gg/eniyisi",
        [2] = "Yetkiliye ulaşmak için /calladmin yazabilirsiniz.", 
        [3] = "F6 ile Venom Shop menüsüne erişebilirsiniz.",
        [4] = "F7 tuşu ile animasyon menüsünü açabilirsiniz.",
        [5] = "F2 tuşu ile günlük görevleri görebilirsiniz.",
        [6] = "!w ile sunucunun workshopuna ulaşabilirsiniz.",
        [7] = "!grup yazarak sunucunun grubuna katılabilirsiniz.",
        [8] = "C'ye basarak mesleğinizin etkileşimlerini görebilirsiniz.",
        [9] = "!birlik yazarak birliğinizi kurabilirsiniz/katılabilirsiniz.",
        [10] = "!djseskapat veya !djsesaç ile Dj müziklerinden gelen sesi kapat/aç yapabilirsiniz.",
        [11] = "/grupodul ile steam grup ödül görevini tamamlayabilirsiniz.",
        [12] = "!hud yazarak hudunun ayarını yapabilirsiniz.",
        [13] = "!yaziturabildirimikapat yazarak chatde çıkan yazı-tura/coinflip bildirimlerini kapatabilirsiniz.",
        [14] = "!yaziturabildirimiac yazarak chatde çıkan yazı-tura/coinflip bildirimlerini açabilirsiniz.",
        [15] = "!chromium ile oyununuzu chromium yapma rehberini görebilirsiniz",
        } 
    
    local currentMsgIndex = 1
    
    timer.Create("InfoMessages", 120, 0, function()
        currentMsgIndex = currentMsgIndex + 1
        if currentMsgIndex > #messages then
            currentMsgIndex = 1
        end
        chat.AddText(color_red, "[VRP] ", color_white, messages[currentMsgIndex])
    end)
end)


XeninUI = XeninUI or {}
function XeninUI:Notify(reason, bilgi, sure)
notification.AddLegacy(reason, bilgi, 10)
end
surface.CreateFont("death_font", {
    font = "Comfortaa",
    size = 64,
    weight = 700,
    extended = true,
    antialias = true
})

surface.CreateFont("timer_font", {
    font = "Comfortaa",
    size = 32,
    weight = 500,
    extended = true,
    antialias = true
})

local death_panel
local time_left = 15
local circle_radius = 50

local function draw_circle(x, y, radius, seg)
    local cir = {}

    table.insert(cir, {x = x, y = y})

    for i = 0, seg do
        local a = math.rad((i / seg) * -360)
        table.insert(cir, {x = x + math.cos(a) * radius, y = y + math.sin(a) * radius})
    end

    table.insert(cir, {x = x, y = y})
    surface.DrawPoly(cir)
end

local function create_death_screen()
    if IsValid(death_panel) then death_panel:Remove() end
    local time_left = 15
    local circle_radius = 50
    local scr_w, scr_h = ScrW(), ScrH()
    local start_x, start_y = scr_w / 2 - 200, scr_h * 0.1
    local end_y = scr_h * 0.35

    local background = vgui.Create("DPanel")
    background:SetSize(scr_w, scr_h)
    background:SetPos(0, 0)
    background:SetAlpha(0)
    background:AlphaTo(200, 1, 0)
    
    background.Paint = function(self, w, h)
        draw.RoundedBox(0, 0, 0, w, h, Color(0, 0, 0, 180))
    end

    death_panel = vgui.Create("DPanel")
    death_panel:SetSize(400, 250)
    death_panel:SetPos(start_x, start_y)
    death_panel:SetAlpha(0)
    death_panel:AlphaTo(255, 1, 0)
    death_panel:MoveTo(start_x, end_y, 1, 0, 2)

    death_panel.Paint = function(self, w, h)
        draw.RoundedBox(20, 0, 0, w, h, Color(20, 20, 22, 220))
        
        local gradient = {
            {x = 0, y = 0, u = 0, v = 0, color = Color(255, 50, 50)},
            {x = w, y = 0, u = 1, v = 0, color = Color(180, 20, 20)},
            {x = w, y = 80, u = 1, v = 1, color = Color(140, 10, 10)},
            {x = 0, y = 80, u = 0, v = 1, color = Color(200, 40, 40)}
        }
        
        local whiteTexture = Material("vgui/white")
        surface.SetDrawColor(35, 35, 35, 255)
        surface.SetMaterial(whiteTexture)
        surface.DrawTexturedRect(0, 0, w, 80) 
        
        
        draw.SimpleText("ÖLDÜNÜZ", "death_font", w / 2, 45, Color(255, 255, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        draw.SimpleText("Otomatik doğacaksınız", "timer_font", w / 2, 165, Color(255, 255, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        draw.NoTexture()
        surface.SetDrawColor(255, 80, 80, 180)
        draw_circle(w / 2, h - 60, circle_radius, 50)
    end

    local timer_label = vgui.Create("DLabel", death_panel)
    timer_label:SetSize(400, 50)
    timer_label:SetPos(0, 100)
    timer_label:SetFont("timer_font")
    timer_label:SetTextColor(Color(255, 255, 255))
    timer_label:SetContentAlignment(5)
    timer_label:SetText(time_left .. " saniye")

    timer.Create("death_screen_timer", 1, time_left, function()
        if not IsValid(timer_label) then return end

        time_left = time_left - 1
        timer_label:SetText(time_left .. " saniye")

        circle_radius = math.Clamp(circle_radius - (50 / 15), 0, 50)

        if time_left <= 0 then
            if IsValid(death_panel) then
                death_panel:AlphaTo(0, 0.5, 0, function()
                    if IsValid(death_panel) then death_panel:Remove() end
                end)
            end
            
            if IsValid(background) then
                background:AlphaTo(0, 0.5, 0, function()
                    if IsValid(background) then background:Remove() end
                end)
            end
            
            timer.Remove("death_screen_timer")
        end
    end)
end

net.Receive("bbplayerdeath", function()
    create_death_screen()
end)

local PANEL = {}

surface.CreateFont("VenomBadge_Title", {
    font = "Comfortaa",
    size = 24,
    weight = 500,
    antialias = true
})

surface.CreateFont("VenomBadge_Text", {
    font = "Comfortaa",
    size = 18,
    weight = 500,
    antialias = true
})

local function CreateBadgeButton(parent, matName, x, y)
    local btn = vgui.Create("DButton", parent)
    btn:SetSize(100, 120)
    btn:SetPos(x, y)
    btn:SetText("")
    
    local mat = Material("badge/" .. matName .. ".png", "noclamp smooth")
    local alpha = 0
    local hover = false
    
    btn.Paint = function(self, w, h)
        draw.RoundedBox(8, 0, 0, w, h, Color(45, 45, 45, 255))

        surface.SetDrawColor(255, 255, 255, 255)
        surface.SetMaterial(mat)
        surface.DrawTexturedRect(18, 10, 64, 64)

        draw.SimpleText(matName, "VenomBadge_Text", w/2, h-25, Color(255, 255, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

        if self:IsHovered() then
            hover = true
        else
            hover = false
        end
        
        alpha = Lerp(FrameTime() * 10, alpha, hover and 30 or 0)
        draw.RoundedBox(8, 0, 0, w, h, Color(255, 255, 255, alpha))
    end
    
    local function CreateClickMenu()
        if IsValid(CLICK_MENU) then CLICK_MENU:Remove() end
        
        local menu = vgui.Create("DFrame")
        CLICK_MENU = menu
        menu:SetSize(200, 110)
        menu:SetTitle("")
        menu:ShowCloseButton(false)
        menu:SetDraggable(false)
        menu:MakePopup()
        
        -- Pozisyon ayarla
        local x, y = gui.MouseX(), gui.MouseY()
        if x + menu:GetWide() > ScrW() then x = x - menu:GetWide() end
        if y + menu:GetTall() > ScrH() then y = y - menu:GetTall() end
        menu:SetPos(x, y)
        
        menu.Paint = function(self, w, h)
            draw.RoundedBox(8, 0, 0, w, h, Color(35, 35, 35, 250))

            draw.SimpleText(matName, "VenomBadge_Text", w/2, 10, Color(255, 255, 255), TEXT_ALIGN_CENTER)

            surface.SetDrawColor(255, 255, 255, 25)
            surface.DrawLine(10, 30, w-10, 30)
        end

        local btnGive = vgui.Create("DButton", menu)
        btnGive:SetPos(10, 40)
        btnGive:SetSize(180, 25)
        btnGive:SetText("")
        
        btnGive.Paint = function(self, w, h)
            draw.RoundedBox(4, 0, 0, w, h, Color(45, 45, 45))
            if self:IsHovered() then
                draw.RoundedBox(4, 0, 0, w, h, Color(255, 255, 255, 10))
            end
            surface.SetDrawColor(255, 255, 255)
            surface.SetMaterial(Material("icon16/add.png"))
            surface.DrawTexturedRect(10, h/2-8, 16, 16)
            draw.SimpleText("Badge Ver", "VenomBadge_Text", 35, h/2, Color(255, 255, 255), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
        end
        
        local btnRemove = vgui.Create("DButton", menu)
        btnRemove:SetPos(10, 75)
        btnRemove:SetSize(180, 25)
        btnRemove:SetText("")
        
        btnRemove.Paint = function(self, w, h)
            draw.RoundedBox(4, 0, 0, w, h, Color(45, 45, 45))
            if self:IsHovered() then
                draw.RoundedBox(4, 0, 0, w, h, Color(255, 255, 255, 10))
            end
            surface.SetDrawColor(255, 255, 255)
            surface.SetMaterial(Material("icon16/delete.png"))
            surface.DrawTexturedRect(10, h/2-8, 16, 16)
            draw.SimpleText("Badge Kaldır", "VenomBadge_Text", 35, h/2, Color(255, 255, 255), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
        end
        
        btnGive.DoClick = function()
            OpenPlayerSelector(matName, true)
            menu:Remove()
        end
        
        btnRemove.DoClick = function()
            OpenPlayerSelector(matName, false)
            menu:Remove()
        end
        
        hook.Add("VGUIMousePressed", "CloseClickMenu", function()
            if IsValid(menu) and not menu:IsHovered() and 
               not btnGive:IsHovered() and not btnRemove:IsHovered() then
                menu:Remove()
                hook.Remove("VGUIMousePressed", "CloseClickMenu")
            end
        end)
    end
    
    btn.DoClick = function()
        CreateClickMenu()
    end
    
    return btn
end

local function CustomizeScrollBar(scroll)
    local scrollbar = scroll:GetVBar()
    scrollbar:SetWide(8) 
    scrollbar:SetHideButtons(true)

    scrollbar.Paint = function(self, w, h)
        draw.RoundedBox(4, 0, 0, w, h, Color(45, 45, 45, 100))
    end

    scrollbar.btnGrip.Paint = function(self, w, h)
        local gripColor = self:IsHovered() and Color(255, 255, 255, 100) or Color(255, 255, 255, 50)
        draw.RoundedBox(4, 0, 0, w, h, gripColor)
    end
end

function OpenPlayerSelector(badgeMat, isAdd)
    local frame = vgui.Create("DFrame")
    frame:SetSize(400, 500)
    frame:Center()
    frame:SetTitle("")
    frame:MakePopup()
    frame:SetDraggable(true)
    frame:ShowCloseButton(false)
    
    local alpha = 0
    frame.Paint = function(self, w, h)
        alpha = Lerp(FrameTime() * 10, alpha, 255)
        draw.RoundedBox(8, 0, 0, w, h, Color(30, 30, 30, alpha))
        draw.SimpleText(isAdd and "Badge Ver" or "Badge Kaldır", "VenomBadge_Title", w/2, 20, Color(255, 255, 255, alpha), TEXT_ALIGN_CENTER)
    end
    
    local closeBtn = vgui.Create("DButton", frame)
    closeBtn:SetSize(30, 30)
    closeBtn:SetPos(frame:GetWide() - 40, 10)
    closeBtn:SetText("")
    closeBtn.Paint = function(self, w, h)
        draw.SimpleText("✕", "VenomBadge_Title", w/2, h/2, Color(255, 255, 255, alpha), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
    end
    closeBtn.DoClick = function()
        frame:AlphaTo(0, 0.2, 0, function()
            frame:Remove()
        end)
    end
    
    local playerScroll = vgui.Create("DScrollPanel", frame)
    playerScroll:Dock(FILL)
    playerScroll:DockMargin(10, 50, 10, 50)

    CustomizeScrollBar(playerScroll)

    local searchBox = vgui.Create("DTextEntry", frame)
    searchBox:SetSize(frame:GetWide() - 20, 30)
    searchBox:SetPos(10, 50)
    searchBox:SetFont("VenomBadge_Text")
    searchBox:SetPlaceholderText("Oyuncu ara...")
    
    searchBox.Paint = function(self, w, h)
        draw.RoundedBox(6, 0, 0, w, h, Color(45, 45, 45, alpha))
        self:DrawTextEntryText(
            Color(255, 255, 255), 
            Color(100, 100, 255), 
            Color(255, 255, 255)
        )
        
        if self:GetText() == "" and not self:HasFocus() then
            draw.SimpleText(
                self:GetPlaceholderText(),
                "VenomBadge_Text",
                5,
                h/2,
                Color(150, 150, 150, alpha),
                TEXT_ALIGN_LEFT,
                TEXT_ALIGN_CENTER
            )
        end
    end

    playerScroll:DockMargin(10, 90, 10, 50)

    local selectedPlayers = {}

    local function RefreshPlayerList(searchText)
        playerScroll:Clear()
        
        for _, ply in ipairs(player.GetAll()) do
            if not IsValid(ply) then continue end

            if searchText and searchText != "" then
                local playerName = string.lower(ply:Nick())
                if not string.find(playerName, string.lower(searchText)) then
                    continue
                end
            end
            
            local playerBtn = vgui.Create("DButton", playerScroll)
            playerBtn:Dock(TOP)
            playerBtn:SetTall(50)
            playerBtn:DockMargin(0, 0, 0, 5)
            playerBtn:SetText("")

            local selected = selectedPlayers[ply:SteamID64()] or false
            local btnHover = false
            
            playerBtn.Paint = function(self, w, h)
                if self:IsHovered() then
                    btnHover = true
                else
                    btnHover = false
                end
                
                draw.RoundedBox(6, 0, 0, w, h, Color(45, 45, 45, alpha))
                draw.RoundedBox(6, 0, 0, w, h, Color(255, 255, 255, (selected and 50) or (btnHover and 30 or 0)))
                
                if not IsValid(self.Avatar) then
                    self.Avatar = vgui.Create("AvatarImage", self)
                    self.Avatar:SetSize(32, 32)
                    self.Avatar:SetPos(10, 9)
                    self.Avatar:SetPlayer(ply, 32)
                end

                draw.SimpleText(ply:Nick(), "VenomBadge_Text", 50, h/2, Color(255, 255, 255, alpha), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
            end
            
            playerBtn.DoClick = function()
                selected = not selected
                if selected then
                    selectedPlayers[ply:SteamID64()] = true
                    playerBtn.SelectedPlayer = ply
                else
                    selectedPlayers[ply:SteamID64()] = nil
                    playerBtn.SelectedPlayer = nil
                end
            end
        end
    end

    searchBox.OnChange = function(self)
        RefreshPlayerList(self:GetText())
    end

    RefreshPlayerList("")
    
    local submitBtn = vgui.Create("DButton", frame)
    submitBtn:Dock(BOTTOM)
    submitBtn:SetTall(40)
    submitBtn:DockMargin(10, 0, 10, 10)
    submitBtn:SetText("")
    
    local btnHover = false
    submitBtn.Paint = function(self, w, h)
        if self:IsHovered() then
            btnHover = true
        else
            btnHover = false
        end
        
        draw.RoundedBox(8, 0, 0, w, h, Color(60, 60, 60, alpha))
        draw.RoundedBox(8, 0, 0, w, h, Color(255, 255, 255, btnHover and 30 or 0))
        draw.SimpleText("Uygula", "VenomBadge_Text", w/2, h/2, Color(255, 255, 255, alpha), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
    end
    
    submitBtn.DoClick = function()
        net.Start("venombadgesent")
        local secilenoyuncular = {}

        for steamID, _ in pairs(selectedPlayers) do
            table.insert(secilenoyuncular, steamID)
        end

        print("Seçilen oyuncu sayısı:", #secilenoyuncular)
        PrintTable(secilenoyuncular)

        net.WriteBool(isAdd)
        net.WriteString(badgeMat)
        
        net.WriteUInt(#secilenoyuncular, 8)
        for _, steamid in ipairs(secilenoyuncular) do
            net.WriteString(steamid)
        end
        
        net.SendToServer()
        
        frame:AlphaTo(0, 0.2, 0, function()
            frame:Remove()
        end)
    end
end

function OpenBadgeMenu()
    if not LocalPlayer():IsAdmin() then return end
    
    if IsValid(BADGE_MAIN_FRAME) then BADGE_MAIN_FRAME:Remove() end
    if IsValid(CLICK_MENU) then CLICK_MENU:Remove() end
    
    local frame = vgui.Create("DFrame")
    BADGE_MAIN_FRAME = frame
    
    frame:SetSize(800, 600)
    frame:Center()
    frame:SetTitle("")
    frame:MakePopup()
    frame:SetDraggable(true)
    frame:ShowCloseButton(false)
    
    local alpha = 0
    frame.Paint = function(self, w, h)
        alpha = Lerp(FrameTime() * 10, alpha, 255)
        draw.RoundedBox(8, 0, 0, w, h, Color(30, 30, 30, alpha))
        draw.SimpleText("Badge Yönetimi", "VenomBadge_Title", w/2, 20, Color(255, 255, 255, alpha), TEXT_ALIGN_CENTER)
    end
    
    -- Ana menü frame'inde OnRemove fonksiyonunu güncelle
    frame.OnRemove = function()
        -- Tüm alt pencereleri kapat
        for _, v in pairs(vgui.GetWorldPanel():GetChildren()) do
            if IsValid(v) and v:GetName() == "DFrame" and v != frame then
                v:Remove()
            end
        end
    end
    
    local closeBtn = vgui.Create("DButton", frame)
    closeBtn:SetSize(30, 30)
    closeBtn:SetPos(frame:GetWide() - 40, 10)
    closeBtn:SetText("")
    closeBtn.Paint = function(self, w, h)
        draw.SimpleText("✕", "VenomBadge_Title", w/2, h/2, Color(255, 255, 255, alpha), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
    end
    closeBtn.DoClick = function()
        frame:AlphaTo(0, 0.2, 0, function()
            frame:Remove()
        end)
    end
    
    local scroll = vgui.Create("DScrollPanel", frame)
    scroll:Dock(FILL)
    scroll:DockMargin(10, 50, 10, 10)
    
    -- Scrollbar'ı özelleştir
    CustomizeScrollBar(scroll)
    
    local grid = vgui.Create("DIconLayout", scroll)
    grid:Dock(FILL)
    grid:SetSpaceX(10)
    grid:SetSpaceY(10)
    
    -- Arama kutusu ekle
    local searchBox = vgui.Create("DTextEntry", frame)
    searchBox:SetSize(frame:GetWide() - 20, 30)
    searchBox:SetPos(10, 50)
    searchBox:SetFont("VenomBadge_Text")
    searchBox:SetPlaceholderText("Badge ara...")
    
    searchBox.Paint = function(self, w, h)
        draw.RoundedBox(6, 0, 0, w, h, Color(45, 45, 45, alpha))
        self:DrawTextEntryText(
            Color(255, 255, 255), 
            Color(100, 100, 255), 
            Color(255, 255, 255)
        )
        
        if self:GetText() == "" and not self:HasFocus() then
            draw.SimpleText(
                self:GetPlaceholderText(),
                "VenomBadge_Text",
                5,
                h/2,
                Color(150, 150, 150, alpha),
                TEXT_ALIGN_LEFT,
                TEXT_ALIGN_CENTER
            )
        end
    end

    scroll:DockMargin(10, 90, 10, 10)
    
    local function RefreshBadgeList(searchText)
        grid:Clear()
        
        local files, _ = file.Find("materials/badge/*.png", "GAME")
        for _, fname in ipairs(files) do
            local matName = string.StripExtension(fname)

            if searchText and searchText != "" then
                local badgeName = string.lower(matName)
                if not string.find(badgeName, string.lower(searchText)) then
                    continue
                end
            end
            
            grid:Add(CreateBadgeButton(nil, matName, 0, 0))
        end
    end

    searchBox.OnChange = function(self)
        RefreshBadgeList(self:GetText())
    end

    RefreshBadgeList("")
end


hook.Add("OnPlayerChat", "VenomBadge_MenuCommand", function(ply, text)
    if ply == LocalPlayer() and text == "!badges" and ply:IsAdmin() then
        OpenBadgeMenu()
        return true
    end
end) 


local jumpscareImages = {}
local currentImageIndex = 1
local isJumpscareActive = false
local nextImageChange = 0
local screenShake = 0

local files, _ = file.Find("materials/jumpidumpi/*.png", "GAME")
for _, fname in ipairs(files) do
    local mat = Material("jumpidumpi/" .. fname, "noclamp smooth")
    table.insert(jumpscareImages, mat)
end

sound.Add({
    name = "jumpscare_sound",
    channel = CHAN_STATIC,
    volume = 2.0,
    level = 0,
    pitch = {90, 110},
    sound = "jumpidumpi/bisiyok.mp3"
})

local function StartJumpscareHooks()
    hook.Add("HUDPaint", "DrawJumpscare", function()
        if not isJumpscareActive then 
            hook.Remove("HUDPaint", "DrawJumpscare")
            return 
        end

        screenShake = math.sin(CurTime() * 30) * 5
        
        if CurTime() >= nextImageChange then
            currentImageIndex = currentImageIndex + 1
            if currentImageIndex > #jumpscareImages then
                currentImageIndex = 1
            end
            nextImageChange = CurTime() + 0.05
            
            util.ScreenShake(LocalPlayer():GetPos(), 5, 5, 0.1, 5)
        end
        
        local mat = jumpscareImages[currentImageIndex]
        if mat then
            local colorVar = math.random(200, 255)
            surface.SetDrawColor(colorVar, colorVar, colorVar, 255)
            surface.SetMaterial(mat)

            local offset = screenShake
            surface.DrawTexturedRect(offset, offset, ScrW(), ScrH())
            
            surface.SetDrawColor(255, 0, 0, math.random(10, 30))
            surface.DrawRect(0, 0, ScrW(), ScrH())
        end
    end)
    
    hook.Add("RenderScreenspaceEffects", "JumpscareEffects", function()
        if not isJumpscareActive then 
            hook.Remove("RenderScreenspaceEffects", "JumpscareEffects")
            return 
        end
        
        local tab = {
            ["$pp_colour_addr"] = math.random(0, 0.2),
            ["$pp_colour_addg"] = 0,
            ["$pp_colour_addb"] = 0,
            ["$pp_colour_brightness"] = -0.1,
            ["$pp_colour_contrast"] = 1.2,
            ["$pp_colour_colour"] = 0.8,
            ["$pp_colour_mulr"] = 0,
            ["$pp_colour_mulg"] = 0,
            ["$pp_colour_mulb"] = 0
        }
        
        DrawColorModify(tab)
        DrawMotionBlur(0.4, 0.8, 0.01)
    end)
    
    hook.Add("Think", "DisableKeysInJumpscare", function()
        if not isJumpscareActive then 
            hook.Remove("Think", "DisableKeysInJumpscare")
            return 
        end
        gui.EnableScreenClicker(true)
        return true
    end)
end

local function StopJumpscare()
    isJumpscareActive = false
    RunConsoleCommand("stopsound")
    gui.EnableScreenClicker(false)
    hook.Remove("HUDPaint", "DrawJumpscare")
    hook.Remove("Think", "DisableKeysInJumpscare")
    hook.Remove("RenderScreenspaceEffects", "JumpscareEffects")
end

net.Receive("SendJumpscare", function()
    local duration = net.ReadFloat()

    if timer.Exists("JumpscareTimer") then
        timer.Remove("JumpscareTimer")
    end
    
    isJumpscareActive = true
    nextImageChange = 0
    currentImageIndex = 1

    surface.PlaySound("jumpscare_sound")
    timer.Simple(0.1, function() 
        surface.PlaySound("jumpscare_sound") 
    end)
    
    StartJumpscareHooks()

    timer.Create("JumpscareTimer", duration, 1, StopJumpscare)
end)

net.Receive("StopJumpscare", function()
    isJumpscareActive = false
    RunConsoleCommand("stopsound")
    gui.EnableScreenClicker(false)
end) 
local PLAYER = FindMetaTable("Player")
function PLAYER:GetBadges()
    return util.JSONToTable(self:GetNWString("VenomBadges", "[]")) or {}
end

surface.CreateFont("VenomAnnounce_Title", {
    font = "Comfortaa",
    size = 28,
    weight = 600,
    extended = true,
    antialias = true
})

surface.CreateFont("VenomAnnounce_Text", {
    font = "Comfortaa",
    size = 20,
    weight = 500,
    extended = true,
    antialias = true
})

local PANEL = {}
local activeAnnouncements = {}

function PANEL:Init()
    self:SetSize(600, 120)
    self:SetPos(ScrW() / 2 - 300, -120)
    self.StartTime = CurTime()
    self.Alpha = 0

    self.BadgeMat = Material("badge/yetkiligorevde.png", "noclamp smooth")

    self:MoveTo(ScrW() / 2 - 300, 50, 0.5, 0, -1, function()
        self:AlphaTo(255, 0.3, 0)
    end)
end

function PANEL:SetAnnouncement(announcer, duration, message, title)
    self.Announcer = announcer
    self.Title = title
    self.Duration = duration
    self.Message = message
    self.EndTime = CurTime() + duration
    
    self.Particles = {}
    self.NextParticle = 0
end

function PANEL:CreateParticle()
    local particle = {
        x = math.random(0, self:GetWide()),
        y = self:GetTall(),
        speed = math.random(20, 40),
        size = math.random(3, 6),
        alpha = 255
    }
    table.insert(self.Particles, particle)
end

function PANEL:Paint(w, h)
    local timeLeft = math.max(0, self.EndTime - CurTime())
    local progress = timeLeft / self.Duration
    
    draw.RoundedBox(10, 0, 0, w, h, Color(30, 30, 30, 230))
    
    surface.SetDrawColor(255, 255, 255, 20)
    surface.DrawOutlinedRect(1, 1, w-2, h-2, 2)
    
    surface.SetDrawColor(255, 255, 255, 255)
    surface.SetMaterial(self.BadgeMat)
    surface.DrawTexturedRect(20, h/2 - 32, 64, 64)
    
    draw.SimpleText(self.Title or "YETKİLİ DUYURUSU", "VenomAnnounce_Title", w/2, 20, Color(255, 255, 255), TEXT_ALIGN_CENTER)
    
    draw.SimpleText("Duyuran: " .. self.Announcer, "VenomAnnounce_Text", 100, 50, Color(255, 255, 255))
    
    draw.SimpleText(self.Message, "VenomAnnounce_Text", 100, 80, Color(255, 255, 255))
    
    if CurTime() > self.NextParticle then
        self:CreateParticle()
        self.NextParticle = CurTime() + 0.1
    end
    
    for i = #self.Particles, 1, -1 do
        local p = self.Particles[i]
        draw.RoundedBox(4, p.x, p.y, p.size, p.size, Color(255, 255, 255, p.alpha))
        p.y = p.y - p.speed * FrameTime()
        p.alpha = p.alpha - 200 * FrameTime()
        
        if p.alpha <= 0 then
            table.remove(self.Particles, i)
        end
    end

    draw.RoundedBox(4, 0, h-4, w, 4, Color(60, 60, 60))

    local barWidth = w * progress
    local gradient = 0
    for i = 0, barWidth, 2 do
        gradient = math.abs(math.sin(CurTime() * 2 + i * 0.02))
        draw.RoundedBox(4, i, h-4, 2, 4, Color(255, 255, 255, 150 + gradient * 105))
    end
end

function PANEL:Think()
    if CurTime() > self.EndTime then
        self:MoveTo(ScrW() / 2 - 300, -120, 0.5, 0, -1)
        self:AlphaTo(0, 0.3, 0, function()
            self:Remove()
            table.RemoveByValue(activeAnnouncements, self)
        end)
    end
end

vgui.Register("StaffAnnouncementPanel", PANEL, "DPanel")

net.Receive("StaffAnnouncement", function()
    local announcer = net.ReadString()
    local duration = net.ReadUInt(16)
    local message = net.ReadString()

    surface.PlaySound("buttons/button17.wav")
    
    local panel = vgui.Create("StaffAnnouncementPanel")
    panel:SetAnnouncement(announcer, duration, message)

    table.insert(activeAnnouncements, panel)
end)

do
    local SetFont = surface.SetFont
    local GetTextSize = surface.GetTextSize
    local currentFont = 'TargetID'
    local fontCache = setmetatable({}, {__mode = 'k'})

    timer.Create('surface.ClearFontCache', 1800, 0, function()
        for k in pairs(fontCache) do
            fontCache[k] = nil
        end
    end)

    function surface.SetFont(font)
        currentFont = font
        return SetFont(font)
    end

    function surface.GetTextSize(text)
        if not fontCache[currentFont] then
            fontCache[currentFont] = {}
        end
        
        if not fontCache[currentFont][text] then
            local width, height = GetTextSize(text)
            fontCache[currentFont][text] = {w = width, h = height}
            return width, height
        end
        
        return fontCache[currentFont][text].w, fontCache[currentFont][text].h
    end
end

local COLORS = {
    white = Color(210, 210, 210),
    background = Color(0, 0, 0, 200),
    progress = Color(176, 35, 35, 122),
    red = Color(255, 0, 0),
    ramadanBackground = Color(0, 35, 80, 200),
    ramadanProgress = Color(214, 168, 44, 150),
    ramadanTitle = Color(255, 230, 180),
    ramadanText = Color(230, 220, 200)
}

local COLORS = {
    white = Color(210, 210, 210),
    background = Color(0, 0, 0, 200),
    progress = Color(176, 35, 35, 122),
    red = Color(255, 0, 0),
    ramadanBackground = Color(0, 35, 80, 200),
    ramadanProgress = Color(214, 168, 44, 150),
    ramadanTitle = Color(255, 230, 180),
    ramadanText = Color(230, 220, 200)
}

local useRamadanTheme = true

surface.CreateFont("FlashNote.Title", {
    font = "Comfortaa",
    size = 23,
    extended = true,
    weight = 500
})

surface.CreateFont("FlashNote.Text", {
    font = "Comfortaa",
    size = 20,
    extended = true, 
    weight = 500
})

local function DrawCircle(x, y, radius, color, segments)
    segments = segments or 32
    local points = {}
    
    for i = 0, segments do
        local angle = math.rad((i / segments) * 360)
        local px = x + math.cos(angle) * radius
        local py = y + math.sin(angle) * radius
        table.insert(points, {x = px, y = py})
    end
    
    draw.NoTexture()
    surface.SetDrawColor(color)
    surface.DrawPoly(points)
end

local activeNotifications = {}
local PANEL = {}

function PANEL:Init()
    self.Lines = {}
    self.Time = 4 
    self.EndTime = CurTime() + self.Time
    self.Title = vgui.Create('DLabel', self)
    self.IsRamadanTheme = useRamadanTheme 
end

function PANEL:PerformLayout(width, height)
    self.Title:SizeToContents()
    self.Title:SetPos(width * 0.5 - self.Title:GetWide() * 0.5, 2)
    
    for i, line in ipairs(self.Lines) do
        line:SetPos(5, 8.5 + i * line:GetTall())
    end
end

function PANEL:ApplySchemeSettings()
    self.Title:SetFont('FlashNote.Title')
    if self.IsRamadanTheme then
        self.Title:SetColor(COLORS.ramadanTitle)
    else
        self.Title:SetColor(COLORS.white)
    end
end

function PANEL:Think()
    if self.Anim then 
        self.Anim:Run()
    end
    if self.MoveAnim then 
        self.MoveAnim:Run()
    end
end

function PANEL:FadeIn(duration, callback)
    self.Anim = Derma_Anim('Fade Panel', self, function(panel, animation, delta, data)
        panel:SetAlpha(delta * 255)
        if animation.Finished then
            self.Anim = nil
            if callback then callback() end
        end
    end)
    if self.Anim then self.Anim:Start(duration) end
end

function PANEL:FadeOut(duration, callback)
    self.Anim = Derma_Anim('Fade Panel', self, function(panel, animation, delta, data)
        panel:SetAlpha(255 - delta * 255)
        if animation.Finished then
            self.Anim = nil
            if callback then callback() end
        end
    end)
    if self.Anim then self.Anim:Start(duration) end
end

function PANEL:MoveDown(distance, duration, callback)
    local startY = self.NextY or self.y
    self.NextY = startY + distance
    
    self.MoveAnim = Derma_Anim('Move Panel', self, function(panel, animation, delta, data)
        panel.y = startY + delta * distance
        if animation.Finished then
            self.MoveAnim = nil
            self.NextY = nil
            if callback then callback() end
        end
    end)
    if self.MoveAnim then self.MoveAnim:Start(duration) end
end

local function WrapText(text, font, maxWidth)
    local words = string.Explode(" ", text)
    local lines = {}
    local currentLine = ""
    
    surface.SetFont(font)
    
    for _, word in ipairs(words) do
        local testLine = currentLine .. (currentLine == "" and "" or " ") .. word
        local width = surface.GetTextSize(testLine)
        
        if width <= maxWidth then
            currentLine = testLine
        else
            if currentLine != "" then
                table.insert(lines, currentLine)
            end
            currentLine = word
        end
    end
    
    if currentLine != "" then
        table.insert(lines, currentLine)
    end
    
    return lines
end

function PANEL:SetInfo(title, message, duration)
    self.Title:SetText(title)
    surface.SetFont('FlashNote.Title')
    local titleWidth = surface.GetTextSize(title)
    self:SetWide(titleWidth + 15)
    if duration and duration > 0 then
        self.Time = duration
        self.EndTime = CurTime() + duration
    end

    local wrappedText = WrapText(message, 'FlashNote.Text', 275)
    for i, text in ipairs(wrappedText) do
        self.Lines[#self.Lines + 1] = vgui.Create('DLabel', self)
        local label = self.Lines[#self.Lines]
        label:SetFont('FlashNote.Text')
        if self.IsRamadanTheme then
            label:SetTextColor(COLORS.ramadanText)
        else
            label:SetTextColor(COLORS.white)
        end
        
        label:SetText(text)
        label:SizeToContents()
        if label:GetWide() + 10 > self:GetWide() then
            self:SetWide(label:GetWide() + 10)
        end
    end

    self:SetTall(27 + #wrappedText * self.Lines[1]:GetTall())
    self:SetPos(ScrW() * 0.5 - self:GetWide() * 0.5)
    self:FadeIn(0.2)
    self:MoveDown(ScrH() * 0.1, 0.2)

    for _, notification in ipairs(activeNotifications) do
        notification:MoveDown(self:GetTall() + 10, 0.2)
    end

    local notificationCount = #activeNotifications
    activeNotifications[notificationCount + 1] = self

    if notificationCount >= 4 then
        local oldNotification = table.remove(activeNotifications, 1)
        if IsValid(oldNotification) then
            oldNotification:FadeOut(0.2, function()
                oldNotification:Remove()
            end)
        end
    end

    timer.Simple(self.Time, function()
        if IsValid(self) then
            for i, notification in ipairs(activeNotifications) do
                if notification == self then
                    table.remove(activeNotifications, i)
                    break
                end
            end
            self:FadeOut(0.2, function()
                self:Remove()
            end)
        end
    end)
end

function PANEL:Paint(width, height)
    local backgroundColor, progressColor
    if self.IsRamadanTheme then
        backgroundColor = COLORS.ramadanBackground
        progressColor = COLORS.ramadanProgress
    else
        backgroundColor = COLORS.background
        progressColor = COLORS.progress
    end

    draw.RoundedBox(5, 0, 0, width, height, backgroundColor)
    draw.RoundedBoxEx(5, 0, 0, width, 26, backgroundColor, true, true, false, false)
    draw.RoundedBoxEx(5, 0, 0, width * (self.EndTime - CurTime()) / self.Time, 26, progressColor, true, true, false, false)
    
    if self.IsRamadanTheme then
        local starSize = 6

        local centerX = width - 18
        local centerY = 13

        DrawCircle(centerX - 20, centerY, 10, COLORS.ramadanTitle)
        DrawCircle(centerX + 6 - 20, centerY, 8, backgroundColor)

        local starX = centerX
        local starY = centerY

        for i = 0, 4 do
            local angle1 = math.rad(i * 72)
            local angle2 = math.rad(i * 72 + 36)
            
            local x1 = starX + math.cos(angle1) * starSize
            local y1 = starY + math.sin(angle1) * starSize
            
            local x2 = starX + math.cos(angle2) * (starSize/2)
            local y2 = starY + math.sin(angle2) * (starSize/2)
            
            local nextI = (i + 1) % 5
            local angle3 = math.rad(nextI * 72)
            
            local x3 = starX + math.cos(angle3) * starSize
            local y3 = starY + math.sin(angle3) * starSize
            
            surface.SetDrawColor(COLORS.ramadanTitle)
            surface.DrawLine(x1, y1, x2, y2)
            surface.DrawLine(x2, y2, x3, y3)
        end
    end
end

vgui.Register('venombildirim', PANEL, 'Panel')
function CreateFlashNotification(title, message, duration)
    local panel = vgui.Create('venombildirim')
    panel:SetInfo(title, message, duration)
    return panel
end



function CreateCustomNotification(title, message, duration)
    return CreateFlashNotification(title, message, duration or 4) 
end


local CONFIG = {
    MESAFE = 60,
    MENU_GENISLIK = 250,
    BUTON_YUKSEKLIK = 40,
    RENKLER = {
        ARKAPLAN = Color(30, 30, 35, 250),
        BUTON = Color(45, 45, 50, 250),
        BUTON_HOVER = Color(65, 65, 70, 250),
        YAZI = Color(255, 255, 255),
        VURGU = Color(80, 140, 220),
        ARANAN = Color(220, 60, 60),
        SECILI = Color(100, 180, 255, 250),
    }
}

local aktifMenu = false
local hedefOyuncu = nil
local secenekler = {}
local etkilesimMenu = nil

surface.CreateFont("MenuBaslik", {
    font = "Comfortaa",
    size = 22,
    weight = 800,
    antialias = true,
    extended = true, 
    shadow = true
})

surface.CreateFont("MenuSecenek", {
    font = "Comfortaa",
    size = 18,
    weight = 500,
    extended = true,
    antialias = true
})

surface.CreateFont("EtkBilgi", {
    font = "Comfortaa",
    size = 16,
    weight = 600,
    antialias = true,
    extended = true,
    shadow = true
})

local function MenuKapat()
    if IsValid(etkilesimMenu) then
        etkilesimMenu:Close()
        etkilesimMenu = nil
    end
    
    aktifMenu = false
    hedefOyuncu = nil
    secenekler = {}
end

function RenkLerp(t, ilk, son)
    return Color(
        Lerp(t, ilk.r, son.r),
        Lerp(t, ilk.g, son.g),
        Lerp(t, ilk.b, son.b),
        Lerp(t, ilk.a or 255, son.a or 255)
    )
end

local function YetkiliMi(ply)
    local yetkiliGruplar = {
        ["denememoderator"] = true,
        ["moderator"] = true,
        ["moderator2"] = true, 
        ["moderator3"] = true,
        ["denetmen"] = true,
        ["genelyetkili"] = true,
        ["admin"] = true,
        ["superyetki"] = true,
        ["toplulukyoneticisi"] = true,
        ["superadmin"] = true
    }
    return yetkiliGruplar[ply:GetUserGroup()] or (ply:Team() and RPExtraTeams[ply:Team()] and RPExtraTeams[ply:Team()].name == "Yetkili Görevde")
end

local function GirisEkraniOlustur(baslik, soru, varsayilanDeger, islem)
    local pencere = vgui.Create("DFrame")
    pencere:SetSize(350, 180)
    pencere:SetTitle("")
    pencere:SetDraggable(true)
    pencere:ShowCloseButton(false)
    pencere:Center()
    pencere:MakePopup()

    pencere.Paint = function(self, w, h)
        draw.RoundedBox(8, 0, 0, w, h, CONFIG.RENKLER.ARKAPLAN)
        draw.SimpleText(baslik, "MenuBaslik", w/2, 20, CONFIG.RENKLER.YAZI, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

        surface.SetDrawColor(CONFIG.RENKLER.VURGU)
        surface.DrawRect(10, 40, w-20, 2)
    end

    local soruText = vgui.Create("DLabel", pencere)
    soruText:SetText(soru)
    soruText:SetFont("MenuSecenek")
    soruText:SetTextColor(CONFIG.RENKLER.YAZI)
    soruText:SetPos(20, 50)
    soruText:SetSize(310, 25)
    soruText:SizeToContents()
    local yaziAlani = vgui.Create("DTextEntry", pencere)
    yaziAlani:SetPos(20, 80)
    yaziAlani:SetSize(310, 35)
    yaziAlani:SetText(varsayilanDeger or "")
    yaziAlani:SetFont("MenuSecenek")
    yaziAlani.Paint = function(self, w, h)
        draw.RoundedBox(4, 0, 0, w, h, Color(60, 60, 65))
        self:DrawTextEntryText(CONFIG.RENKLER.YAZI, CONFIG.RENKLER.VURGU, CONFIG.RENKLER.YAZI)
    end

    yaziAlani.OnGetFocus = function(self)
        self:SelectAllText(true)
    end

    local onayBtn = vgui.Create("DButton", pencere)
    onayBtn:SetText("")
    onayBtn:SetSize(150, 35)
    onayBtn:SetPos(20, 130)
    
    local btnEfekt = 0
    onayBtn.Paint = function(self, w, h)
        if self:IsHovered() then
            btnEfekt = math.min(1, btnEfekt + FrameTime() * 5)
        else
            btnEfekt = math.max(0, btnEfekt - FrameTime() * 5)
        end
        
        local suankiRenk = RenkLerp(btnEfekt, CONFIG.RENKLER.BUTON, CONFIG.RENKLER.BUTON_HOVER)
        draw.RoundedBox(6, 0, 0, w, h, suankiRenk)

        if btnEfekt > 0 then
            surface.SetDrawColor(CONFIG.RENKLER.VURGU.r, CONFIG.RENKLER.VURGU.g, CONFIG.RENKLER.VURGU.b, 
                                50 + 50 * btnEfekt)
            surface.DrawRect(0, h-2, w * btnEfekt, 2)
        end
        
        draw.SimpleText("Onayla", "MenuSecenek", w/2, h/2, CONFIG.RENKLER.YAZI, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
    end
    
    onayBtn.DoClick = function()
        surface.PlaySound("ui/buttonclick.wav")
        islem(yaziAlani:GetValue())
        pencere:Close()
    end
    
    local iptalBtn = vgui.Create("DButton", pencere)
    iptalBtn:SetText("")
    iptalBtn:SetSize(150, 35)
    iptalBtn:SetPos(180, 130)
    
    local iptalEfekt = 0
    iptalBtn.Paint = function(self, w, h)
        if self:IsHovered() then
            iptalEfekt = math.min(1, iptalEfekt + FrameTime() * 5)
        else
            iptalEfekt = math.max(0, iptalEfekt - FrameTime() * 5)
        end
        
        local suankiRenk = RenkLerp(iptalEfekt, CONFIG.RENKLER.BUTON, CONFIG.RENKLER.BUTON_HOVER)
        draw.RoundedBox(6, 0, 0, w, h, suankiRenk)
        
        if iptalEfekt > 0 then
            surface.SetDrawColor(CONFIG.RENKLER.ARANAN.r, CONFIG.RENKLER.ARANAN.g, CONFIG.RENKLER.ARANAN.b, 
                                50 + 50 * iptalEfekt)
            surface.DrawRect(0, h-2, w * iptalEfekt, 2)
        end
        
        draw.SimpleText("İptal", "MenuSecenek", w/2, h/2, CONFIG.RENKLER.YAZI, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
    end
    
    iptalBtn.DoClick = function()
        surface.PlaySound("ui/buttonclick.wav")
        pencere:Close()
    end

    local kapatBtn = vgui.Create("DButton", pencere)
    kapatBtn:SetText("")
    kapatBtn:SetSize(20, 20)
    kapatBtn:SetPos(pencere:GetWide() - 25, 5)
    
    kapatBtn.Paint = function(self, w, h)
        surface.SetDrawColor(255, 255, 255, 150)
        surface.DrawLine(0, 0, w, h)
        surface.DrawLine(0, h, w, 0)
    end
    
    kapatBtn.DoClick = function()
        pencere:Close()
    end

    pencere:SetAlpha(0)
    pencere:AlphaTo(255, 0.3, 0)

    local finalY = pencere.y
    pencere:SetPos(pencere.x, finalY - 20)
    pencere:MoveTo(pencere.x, finalY, 0.3, 0, -1)

    yaziAlani:RequestFocus()
end
local beklemesuresi = CurTime()
local NoMenuOpen = false 

local function HSVToColor(h, s, v)
    h = h / 60
    local c = v * s
    local x = c * (1 - math.abs((h % 2) - 1))
    local m = v - c
    
    local r, g, b = 0, 0, 0
    if h < 1 then r, g, b = c, x, 0
    elseif h < 2 then r, g, b = x, c, 0
    elseif h < 3 then r, g, b = 0, c, x
    elseif h < 4 then r, g, b = 0, x, c
    elseif h < 5 then r, g, b = x, 0, c
    else r, g, b = c, 0, x end
    
    return Color((r + m) * 255, (g + m) * 255, (b + m) * 255)
end

local function MenuHazirla(hedef)
    if NoMenuOpen == true then return end
    MenuKapat()
    
    hedefOyuncu = hedef
    secenekler = {}
    
    table.insert(secenekler, {
        yazi = "Para Ver",
        tiklama = function()
            GirisEkraniOlustur(
                "Para Ver",
                "Ne kadar para vermek istiyorsun?",
                "100",
                function(miktar)
                    if beklemesuresi > CurTime() then 
                        LocalPlayer():ChatPrint("Çok hızlııı!!!") 
                        return 
                    end 
    
                    beklemesuresi = CurTime() + 1
                    net.Start("bb_paraverme")
                    net.WritePlayer(hedef)
                    net.WriteString(miktar)
                    net.SendToServer()
                end
            )
        end
    })
    /*table.insert(secenekler, {
        yazi = "Meslekten At",
        tiklama = function()
            GirisEkraniOlustur(
                "Meslekten At",
                "Neden bu kişiyi meslekten atmak istiyorsun?",
                "",
                function(sebep)
                    RunConsoleCommand("darkrp", "demote", hedef:SteamID64(), sebep)
                end
            )
        end
    })*/
    
    table.insert(secenekler, {
        yazi = "Steam Profili Görüntüle",
        tiklama = function()
            gui.OpenURL("https://steamcommunity.com/profiles/"..hedef:SteamID64())
        end
    })
    
    if LocalPlayer():isCP() then
        if hedef:getDarkRPVar("wanted") then
            table.insert(secenekler, {
                yazi = "Kişinin Aranmasını Kaldır",
                renk = CONFIG.RENKLER.ARANAN,
                tiklama = function()
                    RunConsoleCommand("darkrp", "unwanted", hedef:SteamID64())
                end
            })
        else
            table.insert(secenekler, {
                yazi = "Kişiyi Arat",
                tiklama = function()
                    GirisEkraniOlustur(
                        "Arama Nedeni",
                        "Arama nedeni nedir?",
                        "",
                        function(sebep)
                            RunConsoleCommand("darkrp", "wanted", hedef:SteamID64(), sebep)
                        end
                    )
                end
            })
        end
        
        table.insert(secenekler, {
            yazi = "Baskın İzni Çıkart",
            tiklama = function()
                GirisEkraniOlustur(
                    "Baskın İzni",
                    "Baskın izni çıkartma sebebi nedir?",
                    "",
                    function(sebep)
                        RunConsoleCommand("darkrp", "warrant", hedef:SteamID64(), sebep)
                    end
                )
            end
        })
        
        table.insert(secenekler, {
            yazi = "Silah Lisansı Ver",
            tiklama = function()
                RunConsoleCommand("darkrp", "give", hedef:SteamID64(), "license")
            end
        })
    end

    if YetkiliMi(LocalPlayer()) then
        table.insert(secenekler, {
            yazi = "Oyuncuyu Dondur",
            tiklama = function()
                RunConsoleCommand("sam", "freeze", hedef:SteamID64())
            end
        })
        
        table.insert(secenekler, {
            yazi = "Oyuncunun Dondurmasını Aç",
            tiklama = function()
                RunConsoleCommand("sam", "unfreeze", hedef:SteamID64())
            end
        })

        table.insert(secenekler, {
            yazi = "Geri Gönder",
            tiklama = function()
                RunConsoleCommand("sam", "return", hedef:SteamID64())
                RunConsoleCommand("sam", "unfreeze", hedef:SteamID64())
               
            end
        })
    end
    if team.GetName(hedef:Team()) == "Çocuk" then 
        table.insert(secenekler, {
            yazi = "Harçlık Ver",
            tiklama = function()
                GirisEkraniOlustur(
                    "Harçlık Ver",
                    "Ne kadar para vermek istiyorsun?",
                    "100",
                    function(miktar)
                        if beklemesuresi > CurTime() then 
                            LocalPlayer():ChatPrint("Çok hızlııı!!!") 
                            return 
                        end 
        
                        beklemesuresi = CurTime() + 1
                        net.Start("bb_paraverme_harclik")
                        net.WritePlayer(hedef)
                        net.WriteString(miktar)
                        net.SendToServer()
                    end
                )
            end,
            rgb = true,
            rgbSpeed = 2
        })

        table.insert(secenekler, {
            yazi = "Şeker Ver (-10.000₺)",
            tiklama = function()
                if beklemesuresi > CurTime() then 
                    LocalPlayer():ChatPrint("Çok hızlııı!!!") 
                    return 
                end 

                beklemesuresi = CurTime() + 1
                net.Start("bb_bayram_seker")
                net.WritePlayer(hedef)
                net.SendToServer()
            end,
            rgb = true,
            rgbSpeed = 2
        })
    end 
    etkilesimMenu = vgui.Create("DFrame")
    etkilesimMenu:SetSize(CONFIG.MENU_GENISLIK + 10, 60 + (#secenekler * CONFIG.BUTON_YUKSEKLIK))
    etkilesimMenu:SetTitle("")
    etkilesimMenu:ShowCloseButton(false)
    etkilesimMenu:SetDraggable(false)
    etkilesimMenu:Center()
    etkilesimMenu:MakePopup()
    
    etkilesimMenu.Paint = function(self, w, h)
        draw.RoundedBox(8, 0, 0, w, h, CONFIG.RENKLER.ARKAPLAN)
        if hedefOyuncu and IsValid(hedefOyuncu) then 
        draw.SimpleText(hedefOyuncu:Nick(), "MenuBaslik", w/2, 25, CONFIG.RENKLER.YAZI, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        end 
        
        surface.SetDrawColor(CONFIG.RENKLER.VURGU)
        surface.DrawRect(15, 45, w - 30, 2)
    end

    local kapatBtn = vgui.Create("DButton", etkilesimMenu)
    kapatBtn:SetSize(20, 20)
    kapatBtn:SetPos(etkilesimMenu:GetWide() - 25, 5)
    kapatBtn:SetText("")
    kapatBtn.Paint = function(self, w, h)
        surface.SetDrawColor(255, 255, 255, 150)
        surface.DrawLine(0, 0, w, h)
        surface.DrawLine(0, h, w, 0)
        
        if self:IsHovered() then
            surface.SetDrawColor(255, 100, 100, 200)
            surface.DrawLine(0, 0, w, h)
            surface.DrawLine(0, h, w, 0)
        end
    end
    kapatBtn.DoClick = function()
        surface.PlaySound("ui/buttonclick.wav")
        MenuKapat()
    end

    for i, secenek in ipairs(secenekler) do
        local btn = vgui.Create("DButton", etkilesimMenu)
        btn:SetText("")
        btn:SetSize(CONFIG.MENU_GENISLIK - 20, CONFIG.BUTON_YUKSEKLIK - 5)
        btn:SetPos(15, 50 + (i-1) * CONFIG.BUTON_YUKSEKLIK)
        
        local btnEfekt = 0
        local rgbTime = 0
        local lastFrame = RealTime()
        
        btn.Paint = function(self, w, h)
            local currentTime = RealTime()
            local deltaTime = currentTime - lastFrame
            lastFrame = currentTime
            
            -- DeltaTime kullanarak frame-rate'den bağımsız animasyon
            if secenek.rgb then
                rgbTime = rgbTime + deltaTime * (secenek.rgbSpeed or 1)
            end
            
            -- Arkaplan gölgesi
            if secenek.blur then
                draw.RoundedBox(8, -2, -2, w+4, h+4, Color(0, 0, 0, 30))
            end
    
            -- Ana buton gövdesi
            local bodyColor = Color(30, 30, 40, 220)
            draw.RoundedBox(0, 0, 0, w, h, bodyColor)
    
            -- RGB efekti (periyodik olmayan smooth geçiş)
            if secenek.rgb then
                local segmentCount = 5
                local segmentWidth = w / segmentCount * 1.5
                
                for i = -1, segmentCount + 1 do
                    local segmentPos = (i * segmentWidth) - (rgbTime * 50) % (segmentWidth * 1.5)
                    
                    if segmentPos < w and segmentPos > -segmentWidth then
                        local hue = (i * 70 + rgbTime * 50) % 360
                        local segColor = HSVToColor(hue, 0.8, 0.8)
                        
                        local drawStart = math.max(0, segmentPos)
                        local drawEnd = math.min(w, segmentPos + segmentWidth)
                        local drawWidth = drawEnd - drawStart
                        
                        if drawWidth > 0 then
                            -- Ana renk bandı
                            surface.SetDrawColor(segColor.r, segColor.g, segColor.b, 180)
                            surface.DrawRect(drawStart, 0, drawWidth, h)
                            
                            -- Sol geçiş
                            if drawStart > 0 then
                                surface.SetDrawColor(segColor.r, segColor.g, segColor.b, 90)
                                surface.DrawRect(drawStart-1, 0, 1, h)
                            end
                            
                            -- Sağ geçiş
                            if drawEnd < w then
                                surface.SetDrawColor(segColor.r, segColor.g, segColor.b, 90)
                                surface.DrawRect(drawEnd, 0, 1, h)
                            end
                        end
                    end
                end
                
                -- Renklerin üzerine hafif overlay
                surface.SetDrawColor(0, 0, 0, 30)
                surface.DrawRect(0, 0, w, h)
            end
    
            -- Hover efekti
            if self:IsHovered() then
                btnEfekt = math.min(1, btnEfekt + deltaTime * 8)
            else
                btnEfekt = math.max(0, btnEfekt - deltaTime * 5)
            end
            
            if btnEfekt > 0 then
                surface.SetDrawColor(255, 255, 255, 30 * btnEfekt)
                surface.DrawRect(0, 0, w, h)
                
                surface.SetDrawColor(255, 255, 255, 150 * btnEfekt)
                surface.DrawRect(0, h-1, w * btnEfekt, 1)
            end
    
            -- Yazı
            draw.SimpleText(secenek.yazi, "MenuSecenek", w/2 + 1, h/2 + 1, Color(0, 0, 0, 120), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
            draw.SimpleText(secenek.yazi, "MenuSecenek", w/2, h/2, Color(255, 255, 255, 240), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        end
        
        btn.DoClick = function()
            if secenek.tiklama then
                secenek.tiklama()
            end
            etkilesimMenu:Remove()
        end
    end
    
    etkilesimMenu:SetAlpha(0)
    etkilesimMenu:AlphaTo(255, 0.3, 0)
    
    local finalY = etkilesimMenu.y
    etkilesimMenu:SetPos(etkilesimMenu.x, finalY - 30)
    etkilesimMenu:MoveTo(etkilesimMenu.x, finalY, 0.3, 0, -1)
    
    aktifMenu = true
end

hook.Add("HUDPaint", "OyuncuEtkilesim_HUDPaint", function()
    local ply = LocalPlayer()
    if not IsValid(ply) or not ply:Alive() then return end
    
    --if aktifMenu then return end
    
    if gui.IsConsoleVisible() or gui.IsGameUIVisible() or IsValid(vgui.GetKeyboardFocus()) then
        return
    end
    --if NoMenuOpen then return end 
    local gozPos = ply:EyePos()
    local bakisIzi = ply:GetEyeTrace()
    
    if bakisIzi.Entity and bakisIzi.Entity:IsPlayer() and bakisIzi.Entity != ply then
        local hedef = bakisIzi.Entity
        local mesafe = bakisIzi.HitPos:Distance(gozPos)
        
        if mesafe <= CONFIG.MESAFE then
            if not IsValid(hedef) then return end 
            local pos = hedef:GetPos() + Vector(0, 0, 30) 
            local ekranPos = pos:ToScreen()
            draw.SimpleTextOutlined(
                "E tuşuna basılı tutarak etkileşime geç", 
                "EtkBilgi",
                ekranPos.x,
                ekranPos.y, 
                Color(255, 255, 255, 200), 
                TEXT_ALIGN_CENTER,
                TEXT_ALIGN_CENTER,
                1,
                Color(0, 0, 0, 120)
            )
            
            if input.IsKeyDown(KEY_E) and not input.IsKeyDown(KEY_LALT) then
                timer.Simple(0.35, function()
                    if input.IsKeyDown(KEY_E) and not input.IsKeyDown(KEY_LALT) then
                if NoMenuOpen then return end 
                if not ply.sonEtkilesimBasma or (CurTime() - ply.sonEtkilesimBasma) > 3 then
                    if GlorifiedHandcuffs.IsPlayerHandcuffed( ply ) then return end 
                    if IsValid(ply:GetActiveWeapon()) then 
                    if ply:GetActiveWeapon():GetClass() == "glorifiedhandcuffs_handcuffs" then return end 
                    end 
                    ply.sonEtkilesimBasma = CurTime()
                    MenuHazirla(hedef)
                end
            end
                end)
            else
                ply.sonEtkilesimBasma = nil
            end
        end
    end
end)

hook.Add( "PhysgunPickup", "BB_MenuBugFix", function( ply, ent )
    NoMenuOpen = true 
end )
hook.Add( "PhysgunDrop", "BB_MenuBugFix", function( ply, _ )
    NoMenuOpen = false 
end )
hook.Add("OnContextMenuClose", "oyuncuetkilesim_ContextClose", function()
    if aktifMenu then
        MenuKapat()
    end
end)

if timer.Exists("RamazanIftarKontrol") then 
timer.Remove("RamazanIftarKontrol")
end 


concommand.Add('bildirimtest', function()
    local function testNotification(delay, number)
        timer.Simple(delay, function()
            CreateFlashNotification('Test ' .. number,
                'Bu bir test bildirimidir! VenomRP için özelleştirilmiş bildirim sistemi.', 5)
        end)
    end

    for i = 1, 4 do
        testNotification(i * 0.5, i)
    end
end)

local beklemesuresi = CurTime()
hook.Add("OnLuaError", "bbtest", function(errors, realm, stack, name, string)
if errors == "Player:GetCurrentCommand called outside of command/prediction" then
    if beklemesuresi > CurTime() then return end 
    beklemesuresi = CurTime() + 20
net.Start("bb_luaerrorprint")
net.SendToServer()
end
end)

timer.Create("bb_hilekontrol", 25 , 0 , function()
    if(cvars.String("th_setmat", "x") != "x" and cvars.String("th_setmat", "x") != nil) then
        net.Start("bb_luaerrorprint")
        net.SendToServer()
    end
    if(concommand.GetTable()["aegis_printlogs"]) then
        net.Start("bb_luaerrorprint")
        net.SendToServer()
    end

    if(cvars.Number("sv_cheats", 0) == 1) then
        net.Start("bb_luaerrorprint")
        net.SendToServer()
    end
end)

net.Receive("sokaktanses_network", function()
    local announcer = net.ReadString()
    local duration = net.ReadUInt(16)
    local message = net.ReadString()
    surface.PlaySound("buttons/button17.wav")
    
    local panel = vgui.Create("StaffAnnouncementPanel")
    panel:SetAnnouncement(announcer, duration, message, "Sokaktan Sesler")

    table.insert(activeAnnouncements, panel)
end)


net.Receive("Venom_isadami_dogrulama", function()

    local kod = net.ReadString()
    GirisEkraniOlustur("Venom Anti-AFK", "Kodu yaziniz: "..kod, 0, function(text)
        net.Start("Venom_isadami_dogrulama_server")
        net.WriteString(text)
        net.SendToServer()
    end)

end)

hook.Add("OnPlayerChat", "bb_chatcommand", function(ply, text)
    if ply != LocalPlayer() then return end
    if text == "!workshop" or text == "!w" then
        gui.OpenURL("https://steamcommunity.com/sharedfiles/filedetails/?id=3121536638")
        return true
    end
    if text == "!grup" then
        gui.OpenURL("https://steamcommunity.com/groups/venomoyuncu")
        return true
    end
    if text == "!dc" or text == "!discord" then
        gui.OpenURL("https://discord.gg/eniyisi")
        return true
    end
    if text == "!website" or text == "/website" then
        gui.OpenURL("https://venomrp.com.tr/")
        return true
    end
    if text == "/site" or text == "!site" then
        gui.OpenURL("https://venomrp.com.tr/")
        return true
    end
    if text == "/gang" or text == "!gang" or text == "!çete" or text == "/çete" or text == "!cete" or text == "/cete" then
        RunConsoleCommand("voidfactions")
        return true
    end
    if text == "!djseskapat" or text == "/djseskapat" then 
        chat.AddText(Color(255,0,0), "[Venom]", Color(255,255,255), "Dj sesi kapatıldı.")
        RunConsoleCommand("streamradio_mute", "1")
        return true 
    end 
    if text == "!djsesac" or text == "/djsesac" or text == "!djsesaç" or text == "/djsesaç" then 
        chat.AddText(Color(255,0,0), "[Venom]", Color(255,255,255), "Dj sesi açıldı.")
        RunConsoleCommand("streamradio_mute", "0")
        return true 
    end 
    if text == "!yaziturabildirimikapat" or text == "/yaziturabildirimikapat" then 
        chat.AddText(Color(255,0,0), "[Venom]", Color(255,255,255), "Yazı tura bildirimi kapatıldı.")
        RunConsoleCommand("coinflipkapatma", "1") 
        return true 
    end 
    if text == "!yaziturabildirimiac" or text == "/yaziturabildirimiac" then 
        chat.AddText(Color(255,0,0), "[Venom]", Color(255,255,255), "Yazı tura bildirimi açıldı.")
        RunConsoleCommand("coinflipkapatma", "0") 
        return true 
    end 
    if text == "!dolap" or text == "/dolap" then 
        RunConsoleCommand("bodyman_openmenu")
        return true 
    end

    if text == "!chromium" or text == "/chromium" then 
        gui.OpenURL("https://steamcommunity.com/sharedfiles/filedetails/?id=2432284203")
        return true 
    end 
end)

surface.CreateFont("RadioHUD", {
    font = "Comfortaa",
    size = 22,
    weight = 600,
    extended = true,
    antialias = true
})

surface.CreateFont("RadioHUD_Small", {
    font = "Comfortaa",
    size = 14,
    weight = 400,
    extended = true,
    antialias = true
})

-- Animasyon değişkenleri
local anim = {
    slide = 0,
    alpha = 0,
    pulse = 0,
    glow = 0
}

-- Animasyon fonksiyonları
local function LerpColor(t, a, b)
    return Color(
        Lerp(t, a.r, b.r),
        Lerp(t, a.g, b.g),
        Lerp(t, a.b, b.b),
        Lerp(t, a.a, b.a)
    )
end

local function DrawBlurredRect(x, y, w, h, color, blur)
    draw.RoundedBox(8, x, y, w, h, Color(0, 0, 0, 180))
    draw.RoundedBox(8, x, y, w, h, color)
end

local function DrawRadioHUD()
    local ply = LocalPlayer()
    if not IsValid(ply) then return end
    if not ply:HasWeapon("dradio") then return end
    anim.slide = Lerp(FrameTime() * 5, anim.slide, 1)
    anim.alpha = Lerp(FrameTime() * 3, anim.alpha, 1)
    anim.pulse = math.sin(CurTime() * 2) * 0.5 + 0.5
    anim.glow = math.sin(CurTime() * 1.5) * 0.5 + 0.5
    local screenW, screenH = ScrW(), ScrH()
    local x = screenW - 280 + (1 - anim.slide) * 100
    local y = 20
    local micStatus = ply:GetNWBool("mikrofondurum", false)
    local statusText = micStatus and "AÇIK" or "KAPALI"
    local statusColor = micStatus and Color(22, 141, 22) or Color(139, 18, 18)
    local bgColor = Color(0, 0, 0, 200 * anim.alpha)
    local borderColor = Color(255, 255, 255, 30 * anim.alpha)
    local glowColor = Color(statusColor.r, statusColor.g, statusColor.b, 50 * anim.glow * anim.alpha)
    local padding = 8
    surface.SetFont("RadioHUD")
    local text = "RADYO MİKROFONU"
    local statusText = statusText
    local textW, textH = surface.GetTextSize(text)
    local statusW, statusH = surface.GetTextSize(statusText)
    local boxW = math.max(textW, statusW) + (padding * 2) + 50
    local boxH = textH + statusH + (padding * 2)
    DrawBlurredRect(x - padding - 2, y - padding - 2, boxW + 4, boxH + 4, Color(0, 0, 0, 100 * anim.alpha))
    DrawBlurredRect(x - padding, y - padding, boxW, boxH, bgColor)
    local borderPulse = 1 + (anim.pulse * 0.1)
    draw.RoundedBox(8, x - padding, y - padding, boxW, 1, borderColor)
    draw.RoundedBox(8, x - padding, y - padding, 1, boxH, borderColor)
    draw.RoundedBox(8, x - padding + boxW - 1, y - padding, 1, boxH, borderColor)
    draw.RoundedBox(8, x - padding, y - padding + boxH - 1, boxW, 1, borderColor)
    draw.RoundedBox(8, x - padding - 2, y - padding - 2, boxW + 4, boxH + 4, glowColor)
    draw.SimpleText(text, "RadioHUD", x, y, Color(255, 255, 255, 255 * anim.alpha), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
    local statusY = y + textH + 5
    draw.SimpleText(statusText, "RadioHUD", x, statusY, statusColor, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
    local indicatorSize = 6
    local indicatorX = x + boxW + 8
    local indicatorY = y + (boxH / 2)
    draw.RoundedBox(4, indicatorX - indicatorSize/2 - 2, indicatorY - indicatorSize/2 - 2, indicatorSize + 4, indicatorSize + 4, Color(0, 0, 0, 100 * anim.alpha))
    draw.RoundedBox(4, indicatorX - indicatorSize/2, indicatorY - indicatorSize/2, indicatorSize, indicatorSize, bgColor)
    local pulseSize = indicatorSize + (anim.pulse * 4)
    draw.RoundedBox(4, indicatorX - pulseSize/2, indicatorY - pulseSize/2, pulseSize, pulseSize, Color(statusColor.r, statusColor.g, statusColor.b, 50 * anim.alpha))
    draw.RoundedBox(4, indicatorX - indicatorSize/2, indicatorY - indicatorSize/2, indicatorSize, indicatorSize, statusColor)
    local infoText = "P TUŞU İLE DEĞİŞTİR"
    local infoX = x + boxW/2
    local infoY = y + boxH + 5
    draw.SimpleText(infoText, "RadioHUD_Small", infoX, infoY, Color(255, 255, 255, 150 * anim.alpha), TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
end

hook.Add("HUDPaint", "DrawRadioHUD", DrawRadioHUD) 

local convarinternal = GetConVar_Internal("tv_nochat"):GetString()
local convars = GetConVar("tv_nochat"):GetString()

if convars == "no_gluapack" or convarinternal == "no_gluapack" then 
net.Start("bb_kontrolconvar")
net.SendToServer()
end 

local activeDaires = {}

local function CizDaireYere(pozisyon, yaricap, renk)
    local segments = 32
    local radius = yaricap
   
    render.SetColorMaterial()
   
    local prevX, prevY = math.cos(0) * radius, math.sin(0) * radius
   
    for i = 0, segments do
        local angle = math.rad((i / segments) * -360)
        local x = math.cos(angle) * radius
        local y = math.sin(angle) * radius
       
        render.DrawLine(pozisyon + Vector(prevX, prevY, 2), pozisyon + Vector(x, y, 2), renk, true)
       
        prevX, prevY = x, y
    end
    render.DrawQuadEasy(pozisyon + Vector(0, 0, 1), Vector(0, 0, 1), radius*2, radius*2, renk, 0)
end

concommand.Add("mesafegoster", function(ply, cmd, args)
    if not args[1] or not tonumber(args[1]) then
        print("Kullanım: mesafegoster <mesafe>")
        return
    end

    local radius = tonumber(args[1])

    local position = ply:GetPos()

    local id = "daire_" .. os.time() .. "_" .. math.random(1000)

    local circleData = {
        pos = position,
        radius = radius,
        color = Color(255, 0, 0, 100), 
        endTime = CurTime() + 10 
    }

    activeDaires[id] = circleData

    if not hook.GetTable()["PostDrawTranslucentRenderables"] or not hook.GetTable()["PostDrawTranslucentRenderables"]["MesafeGosterDaireler"] then
        hook.Add("PostDrawTranslucentRenderables", "MesafeGosterDaireler", function()
            local currentTime = CurTime()
            
            for id, data in pairs(activeDaires) do
                if currentTime <= data.endTime then
                    local remainingTime = data.endTime - currentTime
                    local alpha = math.Clamp(remainingTime / 2 * 255, 0, 100)
                    
                    local drawColor = Color(data.color.r, data.color.g, data.color.b, alpha)
                    
                    CizDaireYere(data.pos, data.radius, drawColor)
                else
                    activeDaires[id] = nil
                end
            end

            if table.Count(activeDaires) == 0 then
                hook.Remove("PostDrawTranslucentRenderables", "MesafeGosterDaireler")
            end
        end)
    end
    
    timer.Create(id, 10, 1, function()
        activeDaires[id] = nil
        print("Daire silindi.")

        if table.Count(activeDaires) == 0 then
            hook.Remove("PostDrawTranslucentRenderables", "MesafeGosterDaireler")
        end
    end)
    
    print("Daire çizildi. 10 saniye sonra silinecek.")
end)
--addons/bb_alttab/lua/autorun/client/cl_bbminimized.lua:


timer.Create("TabbedOut", 20, 0, function()

    if (not system.HasFocus()) or (gui.IsGameUIVisible()) then
        
        net.Start("bb_Minimized")
        net.SendToServer()

    end

end)
local nextalttabfix = CurTime() 
local colorblack = Color( 0, 0, 0,150 )
local colorred =  Color(255,21,21)
local oyuncular = {}
local oyuncucount = 0

timer.Create("minimizedoptimization", 3, 0, function()
    local client = LocalPlayer()

    if not IsValid(client) then return end

    oyuncular = {}
    oyuncucount = 0
    for k, v in ipairs(ents.FindInSphere(client:GetPos(), 256)) do
        if not IsValid(v) or not v:IsPlayer() or not v:Alive() or v:InVehicle() or v == client or v:GetRenderMode() == RENDERMODE_TRANSALPHA then continue end
        if v:GetNWBool("Minimized", false) then
            oyuncucount = oyuncucount + 1
            oyuncular[oyuncucount] = v
            oyuncular[oyuncucount].getshootpos = v:GetShootPos()
        end
    end
end)
local vector30 = Vector(2,2,22)
local vectorcache = Angle(0,0,90)
hook.Add( "PostDrawTranslucentRenderables", "DrawMinimized", function()
for i = 1, oyuncucount do
        local ply = oyuncular[i]
        if ply.getshootpos == nil then continue end
        local norm = ply.getshootpos - LocalPlayer():GetShootPos()
        local ang = norm:Angle()
        cam.Start3D2D( ply.getshootpos + vector30, Angle(0,ang.y-90,120), .05 )
                draw.SimpleTextOutlined("AFK | ALT+TAB | AFK", "binbon_enthudtitle", 0, -120, colorred, 1,1, 2, colorblack)
            cam.End3D2D()
end
end)
--addons/dwep/lua/autorun/client/cl_dwep.lua:
return gluapack()()
--addons/permaprops/lua/autorun/client/cl_permaload.lua:
if not PermaProps then PermaProps = {} end
for k, v in pairs(file.Find("permaprops/cl_*.lua", "LUA")) do
	
	include("permaprops/".. v)
	print("permaprops/".. v)


end
for k, v in pairs(file.Find("permaprops/sh_*.lua", "LUA")) do
	
	include("permaprops/".. v)
	print("permaprops/".. v)


end
--addons/xeon-drm-dll/lua/autorun/client/xeon-drm-auth.lua:
local domain = CreateConVar("xeon_dev", 0, bit.bor(FCVAR_REPLICATED, FCVAR_UNREGISTERED, FCVAR_UNLOGGED, FCVAR_DONTRECORD), nil, 0, 1):GetInt() == 1 and "http://gmod.local" or "https://xeon.network"

local XEON_AUTH
local XEON_IP
net.Receive("XEON.Auth", function(len)
	if net.ReadBool() then
		if not IsValid(XEON_AUTH) then return end

		local path = net.ReadString()

		XEON_AUTH:Remove()
		XEON_AUTH = Derma_Query(
			"You will now be prompted to open a URL in the Steam Overlay. Please click \"Yes\" when prompted.\n\nThe URL will redirect you to a Sign in through Steam page for https://xeon.network.\nYou won't need to enter a username or password, the Steam Overlay should already have you logged in.",
			"XEON DRM",
			"Continue", function()
				gui.OpenURL(domain .. path)
			end,
			"Cancel"
		)
	end

	net.Start("XEON.Auth")
	net.SendToServer()

	if IsValid(XEON_AUTH) then return end

	if not LocalPlayer():IsSuperAdmin() then
		XEON_AUTH = Derma_Message("Thanks for installing one of Billy's scripts!\nTo activate your license and use your new scripts, you need to be a superadmin. Please promote yourself to superadmin, then respawn or rejoin to try again.", "XEON DRM", "Dismiss")
		return
	end

	XEON_AUTH = Derma_Query(
		"Thanks for installing one of Billy's scripts!\nTo activate your license and use your new scripts, I'll need you to log in to Steam via the Steam Overlay to authenticate that this server belongs to you.\nWould you like to do this now?",
		"XEON DRM",
		"Link Server", function()
			XEON_AUTH = Derma_Message("Connecting to XEON... please wait. If nothing happens, please check your server's console.", "XEON DRM", "Cancel")

			if not IsValid(XEON_IP) then
				XEON_IP = vgui.Create("DHTML")

				if not IsValid(XEON_IP) or not XEON_IP.OpenURL then
					XEON_IP = { GetIPAddress = function(_, callback) callback(nil) end }
				else
					XEON_IP:SetSize(0, 0)
					XEON_IP:AddFunction("XEON", "IP", function(IP)
						timer.Remove("XEON_IP")
						XEON_IP.IP = IP
						for _, c in ipairs(XEON_IP.IP_Callbacks) do c(IP) end
						XEON_IP.IP_Callbacks = {}
					end)

					XEON_IP.IP_Callbacks = {}
					function XEON_IP:GetIPAddress(callback)
						if os.time() - self.StartedLoading > 5 then
							callback(nil)
						elseif self.IP then
							callback(self.IP)
						else
							table.insert(self.IP_Callbacks, callback)
						end
					end

					function XEON_IP:OnFinishLoadingDocument(IP)
						self:QueueJavascript("XEON.IP(document.body.textContent.trim())")
					end

					XEON_IP.StartedLoading = os.time()
					XEON_IP:OpenURL("https://icanhazip.com/")

					timer.Create("XEON_IP", 1, 0, function()
						if not IsValid(XEON_IP) then
							timer.Remove("XEON_IP")
							return
						end

						if os.time() - XEON_IP.StartedLoading <= 5 then return end

						timer.Remove("XEON_IP")

						for _, c in ipairs(XEON_IP.IP_Callbacks) do c(nil) end
						XEON_IP.IP_Callbacks = {}
					end)
				end
			end

			XEON_IP:GetIPAddress(function(IP)
				net.Start("XEON.Auth")
					net.WriteBool(true)
					net.WriteString(tostring(IP or ""))
				net.SendToServer()
			end)
		end,
		"Dismiss"
	)
end)

local function openErrors(errors)
	if IsValid(XEON_ERRORS) then
		XEON_ERRORS:Update(errors)
		return
	end

	XEON_ERRORS = vgui.Create("DFrame")
	XEON_ERRORS:SetSize(ScrW() * .8, ScrH() * .8)
	XEON_ERRORS:SetTitle("XEON DRM by Billy - Error!")
	XEON_ERRORS:Center()
	XEON_ERRORS:MakePopup()

	local html = vgui.Create("DHTML", XEON_ERRORS)
	html:Dock(FILL)
	html:OpenURL(domain .. "/errors")
	html:AddFunction("XEON", "ScriptSupport", function()
		gui.OpenURL("https://support.billy.enterprises")
	end)

	function XEON_ERRORS:Update(errors)
		print("XEON Errors: " .. #errors)
		PrintTable(errors)

		html:QueueJavascript("ShowNetworkedErrors(" .. util.TableToJSON(errors) .. ")")
	end
	function html:OnDocumentReady()
		XEON_ERRORS:Update(errors)
		self.OnDocumentReady = nil
	end
	XEON_ERRORS:Update(errors)

	sound.PlayURL("https://xeon.network/static/media/oof.mp3", "", function() end)
end

net.Receive("XEON.Error", function()
	local errors = {}
	for i = 1, net.ReadUInt(16) do
		errors[i] = net.ReadString()
	end
	openErrors(errors)
end)

hook.Add("InitPostEntity", "XEON.Error", function()
	timer.Simple(2, function()
		net.Start("XEON.Error")
		net.SendToServer()
	end)
end)
--lua/vgui/bvgui/header.lua:
return gluapack()()
--lua/vgui/bvgui/option_selector.lua:
return gluapack()()
--lua/vgui/bvgui/option_selector.lua:
local PANEL = {}

function PANEL:Init()
	self.Color = bVGUI.BUTTON_COLOR_BLUE
	self.DarkColor = bVGUI.DarkenColor(self.Color, 0.5)

	self.SelectedX = bVGUI.Lerp(0,0,.5)
	self.SelectedWidth = bVGUI.Lerp(0,0,.5)

	self.ButtonLabels = {}
	self.TotalWidth = 0
	self.ButtonCount = 0
	self.Selected = 1

	self.ClickableArea = vgui.Create("bVGUI.BlankPanel", self)
	self.ClickableArea:SetMouseInputEnabled(true)
	self.ClickableArea:SetCursor("hand")
	function self.ClickableArea:OnMouseReleased(m)
		self:GetParent():OnMouseReleased(m)
	end
end

function PANEL:SetColor(col)
	self.Color = col
	self.DarkColor = bVGUI.DarkenColor(self.Color, 0.5)
end

local grey_col = Color(150,150,150)
local dark_grey_col = bVGUI.DarkenColor(grey_col, 0.5)
function PANEL:Paint(w,h)
	if (IsValid(self.HelpLabel)) then
		h = 26
	end

	self.SelectedX:DoLerp()
	self.SelectedWidth:DoLerp()

	draw.RoundedBoxEx(4,0,0,self.TotalWidth,h - 4,grey_col,true,true)
	draw.RoundedBoxEx(4,0,h - 4,self.TotalWidth,4,grey_col,false,false,true,true)

	if (self.LerpedColor == nil) then
		self.LerpedColor = Color(self.Color.r, self.Color.g, self.Color.b)
	else
		self.LerpedColor.r = Lerp(FrameTime() * 10, self.LerpedColor.r, self.Color.r)
		self.LerpedColor.g = Lerp(FrameTime() * 10, self.LerpedColor.g, self.Color.g)
		self.LerpedColor.b = Lerp(FrameTime() * 10, self.LerpedColor.b, self.Color.b)
	end

	if (self.LerpDarkColor == nil) then
		self.LerpDarkColor = Color(self.DarkColor.r, self.DarkColor.g, self.DarkColor.b)
	else
		self.LerpDarkColor.r = Lerp(FrameTime() * 10, self.LerpDarkColor.r, self.DarkColor.r)
		self.LerpDarkColor.g = Lerp(FrameTime() * 10, self.LerpDarkColor.g, self.DarkColor.g)
		self.LerpDarkColor.b = Lerp(FrameTime() * 10, self.LerpDarkColor.b, self.DarkColor.b)
	end

	draw.RoundedBoxEx(4, self.SelectedX:GetValue(), 0, self.SelectedWidth:GetValue(), h, self.LerpedColor, self.Selected == 1, self.Selected == self.ButtonCount, false, false)

	surface.SetDrawColor(dark_grey_col)
	surface.DrawRect(0,h - 4,self.TotalWidth,4)

	surface.SetDrawColor(self.LerpDarkColor)
	surface.DrawRect(self.SelectedX:GetValue(), h - 4, self.SelectedWidth:GetValue(), 4)
end

function PANEL:AddButton(text, col)
	self.ButtonCount = self.ButtonCount + 1
	local btn = vgui.Create("DLabel", self)
	btn.BtnIndex = table.insert(self.ButtonLabels, btn)
	btn.BtnColor = col
	btn:SetTextColor(bVGUI.COLOR_WHITE)
	btn:SetFont(bVGUI.FONT(bVGUI.FONT_RUBIK, "REGULAR", 14))
	btn:SetContentAlignment(5)
	btn:SetText(text)
	self:InvalidateLayout(true)
end

function PANEL:PerformLayout(w,h)
	local x = 5
	for i,v in ipairs(self.ButtonLabels) do
		if (i == self.Selected) then
			self.SelectedX:SetTo((v:GetPos()) - 5)
			self.SelectedWidth:SetTo(v:GetWide() + 10)
		end
		v:SizeToContentsX()
		if (IsValid(self.HelpLabel)) then
			v:SetTall(26 - 4)
		else
			v:SetTall(h - 4)
		end
		v:AlignLeft(x)
		x = x + v:GetWide() + 10
	end
	self.TotalWidth = x - 5
	if (IsValid(self.Label)) then
		self.Label:AlignLeft(self.TotalWidth + 10)
	end
	if (IsValid(self.HelpLabel)) then
		local h = self.HelpLabel:GetTall() + 30
		if (self:GetTall() ~= h) then
			self:SetTall(h)
		end
	end
	self.ClickableArea:SetSize(self.TotalWidth, 26)
end

function PANEL:SetSelectedButton(index)
	self.Selected = index
	self:InvalidateLayout(true)
end
function PANEL:GetSelectedButton()
	return self.ButtonLabels[self.Selected]:GetText(), self.ButtonLabels[self.Selected]
end

function PANEL:OnMouseReleased(m)
	if (m == MOUSE_LEFT) then
		local x,y = self:ScreenToLocal(gui.MousePos())
		for i,v in ipairs(self.ButtonLabels) do
			local btn_x, btn_y, btn_w = v:GetBounds()
			if (y <= 25 and x >= btn_x - 5 and x <= btn_x + btn_w + 5) then
				self:SetSelectedButton(i)
				if (v.BtnColor ~= nil) then
					self:SetColor(v.BtnColor)
				end
				if (self.OnChange) then
					self:OnChange()
				end
				break
			end
		end
	end
end

function PANEL:SetText(text)
	self.Label = vgui.Create("DLabel", self)
	self.Label:SetContentAlignment(4)
	self.Label:SetFont(bVGUI.FONT(bVGUI.FONT_CIRCULAR, "REGULAR", 16))
	self.Label:SetTextColor(bVGUI.COLOR_WHITE)
	self.Label:SetText(text)
	self.Label:SizeToContentsX()
	self.Label:SetTall(21)
end

function PANEL:SetHelpText(text)
	self.HelpLabel = vgui.Create("DLabel", self)
	self.HelpLabel:SetContentAlignment(4)
	self.HelpLabel:SetFont(bVGUI.FONT(bVGUI.FONT_CIRCULAR, "REGULAR", 16))
	self.HelpLabel:SetTextColor(bVGUI.COLOR_WHITE)
	self.HelpLabel:SetText(text)
	self.HelpLabel:SetWide(500)
	self.HelpLabel:SetWrap(true)
	self.HelpLabel:SetAutoStretchVertical(true)
	self.HelpLabel:AlignTop(30)
	self.HelpLabel:SetTextColor(Color(200,200,200))
	function self.HelpLabel:PerformLayout()
		self:InvalidateParent(true)
	end
end

function PANEL:GetValue()
	return self.ButtonLabels[self.Selected]:GetText()
end
function PANEL:SetValue(val)
	for i,v in ipairs(self.ButtonLabels) do
		if (v:GetText() == val) then
			self:SetSelectedButton(i)
			self.SelectedX:SetValue(self.SelectedX.to)
			self.SelectedWidth:SetValue(self.SelectedWidth.to)
			break
		end
	end
end

function PANEL:SizeToButtons()
	local w = 0
	for i,v in ipairs(self.ButtonLabels) do
		w = w + v:GetWide() + 10
	end
	self:SetWide(w)
end

derma.DefineControl("bVGUI.OptionSelector", nil, PANEL, "bVGUI.BlankPanel")
--lua/vgui/bvgui/tabs.lua:
return gluapack()()
--lua/vgui/bvgui/toolbarbutton.lua:
return gluapack()()
--lua/vgui/openpermissions_combobox.lua:

local PANEL = {}

Derma_Hook( PANEL, "Paint", "Paint", "ComboBox" )

Derma_Install_Convar_Functions( PANEL )

AccessorFunc( PANEL, "m_bDoSort", "SortItems", FORCE_BOOL )

function PANEL:Init()

	self.DropButton = vgui.Create( "DPanel", self )
	self.DropButton.Paint = function( panel, w, h ) derma.SkinHook( "Paint", "ComboDownArrow", panel, w, h ) end
	self.DropButton:SetMouseInputEnabled( false )
	self.DropButton.ComboBox = self

	self:SetTall( 22 )
	self:Clear()

	self:SetContentAlignment( 4 )
	self:SetTextInset( 8, 0 )
	self:SetIsMenu( true )
	self:SetSortItems( true )

end

function PANEL:Clear()

	self:SetText( "" )
	self.Choices = {}
	self.Data = {}
	self.ChoiceIcons = {}
	self.Spacers = {}
	self.selected = nil

	if ( self.Menu ) then
		self.Menu:Remove()
		self.Menu = nil
	end

end

function PANEL:GetOptionText( id )

	return self.Choices[ id ]

end

function PANEL:GetOptionData( id )

	return self.Data[ id ]

end

function PANEL:GetOptionTextByData( data )

	for id, dat in pairs( self.Data ) do
		if ( dat == data ) then
			return self:GetOptionText( id )
		end
	end

	-- Try interpreting it as a number
	for id, dat in pairs( self.Data ) do
		if ( dat == tonumber( data ) ) then
			return self:GetOptionText( id )
		end
	end

	-- In case we fail
	return data

end

function PANEL:PerformLayout()

	self.DropButton:SetSize( 15, 15 )
	self.DropButton:AlignRight( 4 )
	self.DropButton:CenterVertical()

end

function PANEL:ChooseOption( value, index )

	if ( self.Menu ) then
		self.Menu:Remove()
		self.Menu = nil
	end

	self:SetText( value )

	-- This should really be the here, but it is too late now and convar changes are handled differently by different child elements
	--self:ConVarChanged( self.Data[ index ] )

	self.selected = index
	self:OnSelect( index, value, self.Data[ index ] )

end

function PANEL:ChooseOptionID( index )

	local value = self:GetOptionText( index )
	self:ChooseOption( value, index )

end

function PANEL:GetSelectedID()

	return self.selected

end

function PANEL:GetSelected()

	if ( !self.selected ) then return end

	return self:GetOptionText( self.selected ), self:GetOptionData( self.selected )

end

function PANEL:OnSelect( index, value, data )

	-- For override

end

function PANEL:AddSpacer()

	self.Spacers[ #self.Choices ] = true

end

function PANEL:AddChoice( value, data, select, icon )

	local i = table.insert( self.Choices, value )

	if ( data ) then
		self.Data[ i ] = data
	end
	
	if ( icon ) then
		self.ChoiceIcons[ i ] = icon
	end

	if ( select ) then

		self:ChooseOption( value, i )

	end

	return i

end

function PANEL:IsMenuOpen()

	return IsValid( self.Menu ) && self.Menu:IsVisible()

end

function PANEL:OpenMenu( pControlOpener )

	if ( pControlOpener && pControlOpener == self.TextEntry ) then
		return
	end

	-- Don't do anything if there aren't any options..
	if ( #self.Choices == 0 ) then return end

	-- If the menu still exists and hasn't been deleted
	-- then just close it and don't open a new one.
	if ( IsValid( self.Menu ) ) then
		self.Menu:Remove()
		self.Menu = nil
	end

	self.Menu = DermaMenu( false, self )

	if ( self:GetSortItems() ) then
		local sorted = {}
		for k, v in pairs( self.Choices ) do
			local val = tostring( v ) --tonumber( v ) || v -- This would make nicer number sorting, but SortedPairsByMemberValue doesn't seem to like number-string mixing
			if ( string.len( val ) > 1 && !tonumber( val ) && val:StartWith( "#" ) ) then val = language.GetPhrase( val:sub( 2 ) ) end
			table.insert( sorted, { id = k, data = v, label = val, spacer = self.Spacers[ k ] } )
		end
		for k, v in SortedPairsByMemberValue( sorted, "label" ) do
			local option = self.Menu:AddOption( v.data, function() self:ChooseOption( v.data, v.id ) end )
			if ( self.ChoiceIcons[ v.id ] ) then
				option:SetIcon( self.ChoiceIcons[ v.id ] )
			end
			if ( v.spacer ) then
				self.Menu:AddSpacer()
			end
		end
	else
		for k, v in pairs( self.Choices ) do
			local option = self.Menu:AddOption( v, function() self:ChooseOption( v, k ) end )
			if ( self.ChoiceIcons[ k ] ) then
				option:SetIcon( self.ChoiceIcons[ k ] )
			end
			if ( self.Spacers[ k ] ) then
				self.Menu:AddSpacer()
			end
		end
	end

	local x, y = self:LocalToScreen( 0, self:GetTall() )

	self.Menu:SetMinimumWidth( self:GetWide() )
	self.Menu:Open( x, y, false, self )

end

function PANEL:CloseMenu()

	if ( IsValid( self.Menu ) ) then
		self.Menu:Remove()
	end

end

-- This really should use a convar change hook
function PANEL:CheckConVarChanges()

	if ( !self.m_strConVar ) then return end

	local strValue = GetConVarString( self.m_strConVar )
	if ( self.m_strConVarValue == strValue ) then return end

	self.m_strConVarValue = strValue

	self:SetValue( self:GetOptionTextByData( self.m_strConVarValue ) )

end

function PANEL:Think()

	self:CheckConVarChanges()

end

function PANEL:SetValue( strValue )

	self:SetText( strValue )

end

function PANEL:DoClick()

	if ( self:IsMenuOpen() ) then
		return self:CloseMenu()
	end

	self:OpenMenu()

end

function PANEL:GenerateExample( ClassName, PropertySheet, Width, Height )

	local ctrl = vgui.Create( ClassName )
	ctrl:AddChoice( "Some Choice" )
	ctrl:AddChoice( "Another Choice", "myData" )
	ctrl:AddChoice( "Default Choice", "myData2", true )
	ctrl:AddChoice( "Icon Choice", "myData3", false, "icon16/star.png" )
	ctrl:SetWide( 150 )

	PropertySheet:AddSheet( ClassName, ctrl, nil, true, true )

end

derma.DefineControl( "OpenPermissions.ComboBox", nil, PANEL, "DButton" )

--lua/vgui/stackerdnumslider.lua:
--[[--------------------------------------------------------------------------
-- 	Namespace Tables
--------------------------------------------------------------------------]]--

local PANEL = {}

--[[--------------------------------------------------------------------------
-- 	Localized Functions & Variables
--------------------------------------------------------------------------]]--

local math = math
local vgui = vgui
local tonumber = tonumber

--[[--------------------------------------------------------------------------
--	Namespace Functions
--------------------------------------------------------------------------]]--

--[[--------------------------------------------------------------------------
--
--	PANEL:SetValue( string, boolean )
--
--]]--
function PANEL:SetValue( val, bSuppress )
	val = math.Clamp( tonumber( val ) or 0, self:GetMin(), self:GetMax() )

	if ( val == nil ) then return end
	if ( self:GetValue() == val ) then return end

	self.Scratch:SetFloatValue( val )
	self:ValueChanged( self:GetValue(), bSuppress )
end

--[[--------------------------------------------------------------------------
--
--	PANEL:ValueChanged( string, value)
--
--]]--
function PANEL:ValueChanged( val, bSuppress )
	val = math.Clamp( tonumber( val ) or 0, self:GetMin(), self:GetMax() )
	self.Slider:SetSlideX( self.Scratch:GetFraction( val ) )	
	if ( self.TextArea ~= vgui.GetKeyboardFocus() ) then
		self.TextArea:SetValue( self.Scratch:GetTextValue() )
	end
	if ( not bSuppress ) then
		self:OnValueChanged( val )
	end
end

vgui.Register( "StackerDNumSlider", PANEL, "DNumSlider" )
--gamemodes/darkrp/gamemode/cl_init.lua:
hook.Run("DarkRPStartedLoading")

GM.Version = "2.7.0"
GM.Name = "DarkRP"
GM.Author = "By FPtje Falco et al."

DeriveGamemode("sandbox")
DEFINE_BASECLASS("gamemode_sandbox")
GM.Sandbox = BaseClass


local function LoadModules()
    local root = GM.FolderName .. "/gamemode/modules/"
    local _, folders = file.Find(root .. "*", "LUA")

    for _, folder in SortedPairs(folders, true) do
        if DarkRP.disabledDefaults["modules"][folder] then continue end

        for _, File in SortedPairs(file.Find(root .. folder .. "/sh_*.lua", "LUA"), true) do
            if File == "sh_interface.lua" then continue end
            include(root .. folder .. "/" .. File)
        end

        for _, File in SortedPairs(file.Find(root .. folder .. "/cl_*.lua", "LUA"), true) do
            if File == "cl_interface.lua" then continue end
            include(root .. folder .. "/" .. File)
        end
    end
end

GM.Config = {} -- config table
GM.NoLicense = GM.NoLicense or {}

include("config/config.lua")
include("libraries/sh_cami.lua")
include("libraries/simplerr.lua")
include("libraries/fn.lua")
include("libraries/tablecheck.lua")
include("libraries/interfaceloader.lua")
include("libraries/disjointset.lua")
include("config/licenseweapons.lua")

include("libraries/modificationloader.lua")

hook.Call("DarkRPPreLoadModules", GM)

LoadModules()

DarkRP.DARKRP_LOADING = true
include("config/jobrelated.lua")
include("config/addentities.lua")
include("config/ammotypes.lua")
DarkRP.DARKRP_LOADING = nil

DarkRP.finish()

hook.Call("DarkRPFinishedLoading", GM)

--gamemodes/darkrp/gamemode/modules/workarounds/sh_interface.lua:
DarkRP.getAvailableVehicles = DarkRP.stub{
    name = "getAvailableVehicles",
    description = "Get the available vehicles that DarkRP supports.",
    parameters = {
    },
    returns = {
        {
            name = "vehicles",
            description = "Names, models and classnames of all supported vehicles.",
            type = "table"
        }
    },
    metatable = DarkRP
}

--gamemodes/darkrp/gamemode/modules/police/sh_interface.lua:
return gluapack()()
--gamemodes/darkrp/gamemode/modules/language/sh_interface.lua:
return gluapack()()
--gamemodes/darkrp/gamemode/modules/base/sh_interface.lua:
DarkRP.registerDarkRPVar = DarkRP.stub{
    name = "registerDarkRPVar",
    description = "Register a DarkRPVar by name. You should definitely register DarkRPVars. Registering DarkRPVars will make networking much more efficient.",
    parameters = {
        {
            name = "name",
            description = "The name of the DarkRPVar.",
            type = "string",
            optional = false
        },
        {
            name = "writeFn",
            description = "The function that writes a value for this DarkRPVar. Examples: net.WriteString, function(val) net.WriteUInt(val, 8) end.",
            type = "function",
            optional = false
        },
        {
            name = "readFn",
            description = "The function that reads and returns a value for this DarkRPVar. Examples: net.ReadString, function() return net.ReadUInt(8) end.",
            type = "function",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.writeNetDarkRPVar = DarkRP.stub{
    name = "writeNetDarkRPVar",
    description = "Internal function. You probably shouldn't need this. DarkRP calls this function when sending DarkRPVar net messages. This function writes the net data for a specific DarkRPVar.",
    parameters = {
        {
            name = "name",
            description = "The name of the DarkRPVar.",
            type = "string",
            optional = false
        },
        {
            name = "value",
            description = "The value of the DarkRPVar.",
            type = "any",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.writeNetDarkRPVarRemoval = DarkRP.stub{
    name = "writeNetDarkRPVarRemoval",
    description = "Internal function. You probably shouldn't need this. DarkRP calls this function when sending DarkRPVar net messages. This function sets a DarkRPVar to nil.",
    parameters = {
        {
            name = "name",
            description = "The name of the DarkRPVar.",
            type = "string",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.readNetDarkRPVar = DarkRP.stub{
    name = "readNetDarkRPVar",
    description = "Internal function. You probably shouldn't need this. DarkRP calls this function when reading DarkRPVar net messages. This function reads the net data for a specific DarkRPVar.",
    parameters = {
    },
    returns = {
        {
            name = "name",
            description = "The name of the DarkRPVar.",
            type = "string"
        },
        {
            name = "value",
            description = "The value of the DarkRPVar.",
            type = "any"
        }
    },
    metatable = DarkRP
}

DarkRP.readNetDarkRPVarRemoval = DarkRP.stub{
    name = "readNetDarkRPVarRemoval",
    description = "Internal function. You probably shouldn't need this. DarkRP calls this function when reading DarkRPVar net messages. This function the removal of a DarkRPVar.",
    parameters = {
    },
    returns = {
        {
            name = "name",
            description = "The name of the DarkRPVar.",
            type = "string"
        }
    },
    metatable = DarkRP
}

DarkRP.findPlayer = DarkRP.stub{
    name = "findPlayer",
    description = "Find a single player based on vague information.",
    parameters = {
        {
            name = "info",
            description = "The information of the player (UserID, SteamID, name).",
            type = "string",
            optional = false
        }
    },
    returns = {
        {
            name = "found",
            description = "The player that matches the description.",
            type = "Player"
        }
    },
    metatable = DarkRP
}

DarkRP.findPlayers = DarkRP.stub{
    name = "findPlayers",
    description = "Find a list of players based on vague information.",
    parameters = {
        {
            name = "info",
            description = "The information of the player (UserID, SteamID, name).",
            type = "string",
            optional = false
        }
    },
    returns = {
        {
            name = "found",
            description = "Table of players that match the description.",
            type = "table"
        }
    },
    metatable = DarkRP
}

DarkRP.nickSortedPlayers = DarkRP.stub{
    name = "nickSortedPlayers",
    description = "A table of players sorted by RP name.",
    parameters = {},
    returns = {
        {
            name = "players",
            description = "The list of players sorted by RP name.",
            type = "table"
        }
    },
    metatable = DarkRP
}

DarkRP.explodeArg = DarkRP.stub{
    name = "explodeArg",
    description = "String arguments exploded into a table. It accounts for substrings in quotes, which makes it more intelligent than string.Explode",
    parameters = {
        {
            name = "arg",
            description = "The full string of the argument",
            type = "string",
            optional = false
        },
    },
    returns = {
        {
            name = "args",
            description = "The table of arguments",
            type = "table"
        }
    },
    metatable = DarkRP
}


DarkRP.formatMoney = DarkRP.stub{
    name = "formatMoney",
    description = "Format a number as a money value. Includes currency symbol.",
    parameters = {
        {
            name = "amount",
            description = "The money to format, e.g. 100000.",
            type = "number",
            optional = false
        }
    },
    returns = {
        {
            name = "money",
            description = "The money as a nice string, e.g. \"$100,000\".",
            type = "string"
        }
    },
    metatable = DarkRP
}

DarkRP.getJobByCommand = DarkRP.stub{
    name = "getJobByCommand",
    description = "Get the job table and number from the command of the job.",
    parameters = {
        {
            name = "command",
            description = "The command of the job, without preceding slash (e.g. 'medic' for medic)",
            type = "string",
            optional = false
        }
    },
    returns = {
        {
            name = "tbl",
            description = "A table containing all information about the job.",
            type = "table"
        },
        {
            name = "jobindex",
            description = "The index of the job (for 'medic' it's the value of TEAM_MEDIC).",
            type = "number"
        }
    },
    metatable = DarkRP
}

DarkRP.simplerrRun = DarkRP.stub{
    name = "simplerrRun",
    description = "Run a function with the given parameters and send any runtime errors to admins.",
    parameters = {
        {
            name = "f",
            description = "The function to be called.",
            type = "function",
            optional = false
        },
        {
            name = "args",
            description = "The arguments to be given to f.",
            type = "vararg",
            optional = true
        },
    },
    returns = {
        {
            name = "retVals",
            description = "The return values of f.",
            type = "vararg"
        }
    },
    metatable = DarkRP
}

DarkRP.error = DarkRP.stub{
    name = "error",
    description = "Throw a simplerr formatted error. Also halts the stack, which means that statements after calling this function will not execute.",
    parameters = {
        {
            name = "message",
            description = "The message of the error.",
            type = "string",
            optional = false
        },
        {
            name = "stack",
            description = "From which point in the function call stack to report the error. 1 to include the function that called DarkRP.error, 2 to exclude it, etc. The default value is 1.",
            type = "number",
            optional = true
        },
        {
            name = "hints",
            description = "Table containing hint strings. Use these hints to explain the error, describe possible causes or provide help to solve the problem.",
            type = "table",
            optional = true
        },
        {
            name = "path",
            description = "Override the path of the error. Will be shown in the error message. By default this is determined by the stack level.",
            type = "string",
            optional = true
        },
        {
            name = "line",
            description = "Override the line number of the error. By default this is determined by the stack level.",
            type = "number",
            optional = true
        },

    },
    returns = {
        {
            name = "succeed",
            description = "Simplerr return value: whether the calculation succeeded. Always false. This return value will never be reached.",
            type = "boolean"
        },
        {
            name = "msg",
            description = "Simplerr return value: nicely formatted error message. This return value will never be reached.",
            type = "string"
        }
    },
    metatable = DarkRP
}

DarkRP.errorNoHalt = DarkRP.stub{
    name = "errorNoHalt",
    description = "Throw a simplerr formatted error. Unlike DarkRP.error, this does not halt the stack. This means that statements after calling this function will be executed like normal.",
    parameters = {
        {
            name = "message",
            description = "The message of the error.",
            type = "string",
            optional = false
        },
        {
            name = "stack",
            description = "From which point in the function call stack to report the error. 1 to include the function that called DarkRP.error, 2 to exclude it, etc. The default value is 1.",
            type = "number",
            optional = true
        },
        {
            name = "hints",
            description = "Table containing hint strings. Use these hints to explain the error, describe possible causes or provide help to solve the problem.",
            type = "table",
            optional = true
        },
        {
            name = "path",
            description = "Override the path of the error. Will be shown in the error message. By default this is determined by the stack level.",
            type = "string",
            optional = true
        },
        {
            name = "line",
            description = "Override the line number of the error. By default this is determined by the stack level.",
            type = "number",
            optional = true
        },

    },
    returns = {
        {
            name = "succeed",
            description = "Simplerr return value: whether the calculation succeeded. Always false.",
            type = "boolean"
        },
        {
            name = "msg",
            description = "Simplerr return value: nicely formatted error message.",
            type = "string"
        }
    },
    metatable = DarkRP
}

-- This function is one of the few that's already defined before the stub is created
DarkRP.stub{
    name = "SteamName",
    description = "Retrieve a player's real (steam) name.",
    parameters = {

    },
    returns = {
        {
            name = "name",
            description = "The player's steam name.",
            type = "string"
        }
    },
    metatable = DarkRP.PLAYER
}

DarkRP.PLAYER.getJobTable = DarkRP.stub{
    name = "getJobTable",
    description = "Get the job table of a player.",
    parameters = {
    },
    returns = {
        {
            name = "job",
            description = "Table with the job information.",
            type = "table"
        }
    },
    metatable = DarkRP.PLAYER
}

DarkRP.PLAYER.getDarkRPVar = DarkRP.stub{
    name = "getDarkRPVar",
    description = "Get the value of a DarkRPVar, which is shared between server and client.",
    parameters = {
        {
            name = "var",
            description = "The name of the variable.",
            type = "string",
            optional = false
        },
        {
            name = "fallback",
            description = "The value to return if the DarkRPVar doesn't exist.",
            type = "any",
            optional = true
        }
    },
    returns = {
        {
            name = "value",
            description = "The value of the DarkRP var.",
            type = "any"
        }
    },
    metatable = DarkRP.PLAYER
}

DarkRP.PLAYER.getAgenda = DarkRP.stub{
    name = "getAgenda",
    description = "Get the agenda a player manages.",
    deprecated = "Use ply:getAgendaTable() instead.",
    parameters = {
    },
    returns = {
        {
            name = "agenda",
            description = "The agenda.",
            type = "table"
        }
    },
    metatable = DarkRP.PLAYER
}

DarkRP.PLAYER.getAgendaTable = DarkRP.stub{
    name = "getAgendaTable",
    description = "Get the agenda a player can see. Note: when a player is not the manager of an agenda, it returns the agenda of the manager.",
    parameters = {
    },
    returns = {
        {
            name = "agenda",
            description = "The agenda.",
            type = "table"
        }
    },
    metatable = DarkRP.PLAYER
}

DarkRP.PLAYER.hasDarkRPPrivilege = DarkRP.stub{
    name = "hasDarkRPPrivilege",
    description = "Whether the player has a certain privilege.",
    parameters = {
        {
            name = "priv",
            description = "The name of the privilege.",
            type = "string",
            optional = false
        }
    },
    returns = {
        {
            name = "answer",
            description = "Whether the player has the privilege.",
            type = "boolean"
        }
    },
    metatable = DarkRP.PLAYER
}

DarkRP.PLAYER.getEyeSightHitEntity = DarkRP.stub{
    name = "getEyeSightHitEntity",
    description = "Get the entity that is closest to a player's line of sight and its distance.",
    parameters = {
        {
            name = "searchDistance",
            description = "How far to look. You usually don't want this function to return an entity millions of units away. The default is 100 units.",
            type = "number",
            optional = true
        },
        {
            name = "hitDistance",
            description = "The maximum distance between the player's line of sight and the object. Basically how far the player can be 'looking away' from the object. The default is 15 units.",
            type = "number",
            optional = true
        },
        {
            name = "filter",
            description = "The filter for which entities to look for. By default it only looks for players.",
            type = "function",
            optional = true
        }
    },
    returns = {
        {
            name = "closestEnt",
            description = "The entity that is closest to the player's line of sight. Returns nil when not found.",
            type = "Entity"
        },
        {
            name = "distance",
            description = "The (minimum) distance between the player's line of sight and the object.",
            type = "number"
        }
    },
    metatable = DarkRP.PLAYER
}

DarkRP.VECTOR.isInSight = DarkRP.stub{
    name = "isInSight",
    description = "Decides whether the vector could be seen by the player if they were to look at it.",
    parameters = {
        {
            name = "filter",
            description = "Trace filter that decides what the player can see through.",
            type = "table",
            optional = false
        },
        {
            name = "ply",
            description = "The player for whom the vector may or may not be visible.",
            type = "Player",
            optional = false
        }
    },
    returns = {
        {
            name = "answer",
            description = "Whether the player can see the position.",
            type = "boolean"
        },
        {
            name = "HitPos",
            description = "The position of the thing that blocks the player's sight.",
            type = "Vector"
        }
    },
    metatable = DarkRP.VECTOR
}

DarkRP.hookStub{
    name = "UpdatePlayerSpeed",
    description = "Change a player's walking and running speed.",
    deprecated = "Use GMod's SetupMove and Move hooks instead.",
    parameters = {
        {
            name = "ply",
            description = "The player for whom the speed changes.",
            type = "Player"
        }
    },
    returns = {
    }
}

--[[---------------------------------------------------------------------------
Creating custom items
---------------------------------------------------------------------------]]
DarkRP.createJob = DarkRP.stub{
    name = "createJob",
    description = "Create a job for DarkRP.",
    parameters = {
        {
            name = "name",
            description = "The name of the job.",
            type = "string",
            optional = false
        },
        {
            name = "tbl",
            description = "Table containing the information for the job.",
            type = "table",
            optional = false
        }
    },
    returns = {
        {
            name = "team",
            description = "The team number of the job you've created.",
            type = "number"
        }
    },
    metatable = DarkRP
}
AddExtraTeam = DarkRP.createJob

DarkRP.removeJob = DarkRP.stub{
    name = "removeJob",
    description = "Remove a job from DarkRP.",
    parameters = {
        {
            name = "i",
            description = "The TEAM_ number of the job. Also the index of the job in RPExtraTeams.",
            type = "number",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.removeShipment = DarkRP.stub{
    name = "removeShipment",
    description = "Remove a shipment from DarkRP. NOTE: Must be called from BOTH server AND client to properly get it removed!",
    parameters = {
        {
            name = "i",
            description = "The index of the item.",
            type = "number",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.removeVehicle = DarkRP.stub{
    name = "removeVehicle",
    description = "Remove a vehicle from DarkRP. NOTE: Must be called from BOTH server AND client to properly get it removed!",
    parameters = {
        {
            name = "i",
            description = "The index of the item.",
            type = "number",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.removeEntity = DarkRP.stub{
    name = "removeEntity",
    description = "Remove an entity from DarkRP. NOTE: Must be called from BOTH server AND client to properly get it removed!",
    parameters = {
        {
            name = "i",
            description = "The index of the item.",
            type = "number",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.removeGroupChat = DarkRP.stub{
    name = "removeGroupChat",
    description = "Remove a groupchat from DarkRP. NOTE: Must be called from BOTH server AND client to properly get it removed!",
    parameters = {
        {
            name = "i",
            description = "The index of the item.",
            type = "number",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.removeAmmoType = DarkRP.stub{
    name = "removeAmmoType",
    description = "Remove an ammotype from DarkRP. NOTE: Must be called from BOTH server AND client to properly get it removed!",
    parameters = {
        {
            name = "i",
            description = "The index of the item.",
            type = "number",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.removeEntityGroup = DarkRP.stub{
    name = "removeEntityGroup",
    description = "Remove an entitygroup from DarkRP. NOTE: Must be called from BOTH server AND client to properly get it removed!",
    parameters = {
        {
            name = "name",
            description = "The name of the item.",
            type = "string",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.removeAgenda = DarkRP.stub{
    name = "removeAgenda",
    description = "Remove a agenda from DarkRP. NOTE: Must be called from BOTH server AND client to properly get it removed!",
    parameters = {
        {
            name = "name",
            description = "The name of the item.",
            type = "string",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.removeDemoteGroup = DarkRP.stub{
    name = "removeDemoteGroup",
    description = "Remove an demotegroup from DarkRP. NOTE: Must be called from BOTH server AND client to properly get it removed!",
    parameters = {
        {
            name = "name",
            description = "The name of the item.",
            type = "string",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.createEntityGroup = DarkRP.stub{
    name = "createEntityGroup",
    description = "Create a entity group for DarkRP.",
    parameters = {
        {
            name = "name",
            description = "The name of the entity group.",
            type = "string",
            optional = false
        },
        {
            name = "teamNrs",
            description = "Vararg team numbers.",
            type = "number",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}
AddDoorGroup = DarkRP.createEntityGroup

DarkRP.createShipment = DarkRP.stub{
    name = "createShipment",
    description = "Create a shipment for DarkRP.",
    parameters = {
        {
            name = "name",
            description = "The name of the shipment.",
            type = "string",
            optional = false
        },
        {
            name = "tbl",
            description = "Table containing the information for the shipment.",
            type = "table",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}
AddCustomShipment = DarkRP.createShipment

DarkRP.createVehicle = DarkRP.stub{
    name = "createVehicle",
    description = "Create a vehicle for DarkRP.",
    parameters = {
        {
            name = "name",
            description = "The name of the vehicle.",
            type = "string",
            optional = false
        },
        {
            name = "tbl",
            description = "Table containing the information for the vehicle.",
            type = "table",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}
AddCustomVehicle = DarkRP.createVehicle

DarkRP.createEntity = DarkRP.stub{
    name = "createEntity",
    description = "Create a entity for DarkRP.",
    parameters = {
        {
            name = "name",
            description = "The name of the entity.",
            type = "string",
            optional = false
        },
        {
            name = "tbl",
            description = "Table containing the information for the entity.",
            type = "table",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}
AddCustomVehicle = DarkRP.createEntity

DarkRP.createAgenda = DarkRP.stub{
    name = "createAgenda",
    description = "Create an agenda for groups of jobs to communicate.",
    parameters = {
        {
            name = "title",
            description = "The name of the agenda.",
            type = "string",
            optional = false
        },
        {
            name = "manager",
            description = "The team numer of the manager of the agenda (the one who can set the agenda).",
            type = "number",
            optional = false
        },
        {
            name = "listeners",
            description = "The jobs that can see this agenda.",
            type = "table",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}
AddAgenda = DarkRP.createAgenda

DarkRP.getAgendas = DarkRP.stub{
    name = "getAgendas",
    description = "Get all agendas. Note: teams that share an agenda use the exact same agenda table. E.g. when you change the agenda of the CP, the agenda of the Chief will automatically be updated as well. Make sure this property is maintained when modifying the agenda table. Not maintaining that property will lead to players not seeing the right agenda text.",
    parameters = {

    },
    returns = {
        {
            name = "agendas",
            description = "Table in which the keys are team numbers and the values agendas.",
            type = "table"
        }
    },
    metatable = DarkRP
}

DarkRP.createGroupChat = DarkRP.stub{
    name = "createGroupChat",
    description = "Create a group chat.",
    parameters = {
        {
            name = "functionOrJob",
            description = "A function that returns whether the person can see the group chat, or a team number.",
            type = "any",
            optional = false
        },
        {
            name = "teamNr",
            description = "VarArg team number.",
            type = "number",
            optional = true
        }
    },
    returns = {
    },
    metatable = DarkRP
}
GM.AddGroupChat = DarkRP.createGroupChat

DarkRP.createAmmoType = DarkRP.stub{
    name = "createAmmoType",
    description = "Create an ammo type.",
    parameters = {
        {
            name = "name",
            description = "The name of the ammo.",
            type = "string",
            optional = false
        },
        {
            name = "tbl",
            description = "Table containing the information for the ammo.",
            type = "table",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.createDemoteGroup = DarkRP.stub{
    name = "createDemoteGroup",
    description = "Create a demote group. When you get banned (demoted) from one of the jobs in this group, you will be banned from every job in this group.",
    parameters = {
        {
            name = "name",
            description = "The name of the demote group.",
            type = "string",
            optional = false
        },
        {
            name = "tbl",
            description = "Table consisting of a list of job.",
            type = "table",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.getDemoteGroup = DarkRP.stub{
    name = "getDemoteGroup",
    description = "Get the demote group of a team. Every team in the same group will return the same object.",
    parameters = {
        {
            name = "teamNr",
            description = "Table consisting of a list of job.",
            type = "number",
            optional = false
        }
    },
    returns = {
        {
            name = "set",
            description = "The demote group identifier.",
            type = "Disjoint-Set"
        }
    },
    metatable = DarkRP
}

DarkRP.getGroupChats = DarkRP.stub{
    name = "getGroupChats",
    description = "Get all group chats.",
    parameters = {

    },
    returns = {
        {
            name = "set",
            description = "Table with functions that decide who can hear who.",
            type = "table"
        }
    },
    metatable = DarkRP
}

DarkRP.getDemoteGroups = DarkRP.stub{
    name = "getDemoteGroups",
    description = "Get all demote groups Every team in the same group will return the same object.",
    parameters = {

    },
    returns = {
        {
            name = "set",
            description = "Table in which the keys are team numbers and the values Disjoint-Set.",
            type = "table"
        }
    },
    metatable = DarkRP
}

DarkRP.createCategory = DarkRP.stub{
    name = "createCategory",
    description = "Create a category for the F4 menu.",
    parameters = {
        {
            name = "tbl",
            description = "Table describing the category.",
            type = "table",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.addToCategory = DarkRP.stub{
    name = "addToCategory",
    description = "Create a category for the F4 menu.",
    parameters = {
        {
            name = "item",
            description = "Table of the custom entity/job/etc.",
            type = "table",
            optional = false
        },
        {
            name = "kind",
            description = "The kind of the category (e.g. 'jobs' for job stuff).",
            type = "string",
            optional = false
        },
        {
            name = "cat",
            description = "The name of the category. Note that the category must exist. Defaults to 'Other'.",
            type = "string",
            optional = true
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.removeFromCategory = DarkRP.stub{
    name = "removeFromCategory",
    description = "Create a category for the F4 menu.",
    parameters = {
        {
            name = "item",
            description = "Table of the custom entity/job/etc.",
            type = "table",
            optional = false
        },
        {
            name = "kind",
            description = "The kind of the category (e.g. 'jobs' for job stuff).",
            type = "string",
            optional = false
        }
    },
    returns = {
    },
    metatable = DarkRP
}

DarkRP.getCategories = DarkRP.stub{
    name = "getCategories",
    description = "Get all categories for all F4 menu tabs.",
    parameters = {
    },
    returns = {
        {
            name = "tbl",
            description = "all categories.",
            type = "table"
        }
    },
    metatable = DarkRP
}

DarkRP.ValidatedPhysicsInit = DarkRP.stub{
    name = "ValidatedPhysicsInit",
    description = "Initialise the physics of an entity, throw a discriptive error when this fails.",
    parameters = {
        {
            name = "ent",
            description = "Entity for which to create the PhysObj.",
            type = "entity",
            optional = false
        },
        {
            name = "kind",
            description = "The SOLID_ enum type. By default this is SOLID_VPHYSICS",
            type = "number",
            optional = true
        },
        {
            name = "hint",
            description = "Optional hint for the error message.",
            type = "string",
            optional = true
        }
    },
    returns = {
        {
            name = "success",
            description = "Whether creating the PhysObj succeeded",
            type = "boolean"
        }
    },
    metatable = DarkRP
}

DarkRP.hookStub{
    name = "DarkRPVarChanged",
    description = "Called when a DarkRPVar was changed.",
    parameters = {
        {
            name = "ply",
            description = "The player for whom the DarkRPVar changed.",
            type = "Player"
        },
        {
            name = "varname",
            description = "The name of the variable that has changed.",
            type = "string"
        },
        {
            name = "oldValue",
            description = "The old value of the DarkRPVar.",
            type = "any"
        },
        {
            name = "newvalue",
            description = "The new value of the DarkRPVar.",
            type = "any"
        }
    },
    returns = {
    }
}

DarkRP.hookStub{
    name = "canBuyPistol",
    description = "Whether a player can buy a pistol.",
    parameters = {
        {
            name = "ply",
            description = "The player.",
            type = "Player"
        },
        {
            name = "shipmentTable",
            description = "The table, as defined in the shipments file.",
            type = "table"
        }
    },
    returns = {
        {
            name = "canBuy",
            description = "Whether it can be bought.",
            type = "boolean"
        },
        {
            name = "suppressMessage",
            description = "Suppress the notification message when it cannot be bought.",
            type = "boolean"
        },
        {
            name = "message",
            description = "A replacement for the message that shows if it cannot be bought.",
            type = "string"
        },
        {
            name = "price",
            description = "An optional override for the price.",
            type = "number"
        }
    }
}

DarkRP.hookStub{
    name = "canBuyShipment",
    description = "Whether a player can buy a shipment.",
    parameters = {
        {
            name = "ply",
            description = "The player.",
            type = "Player"
        },
        {
            name = "shipmentTable",
            description = "The table, as defined in the shipments file.",
            type = "table"
        }
    },
    returns = {
        {
            name = "canBuy",
            description = "Whether it can be bought.",
            type = "boolean"
        },
        {
            name = "suppressMessage",
            description = "Suppress the notification message when it cannot be bought.",
            type = "boolean"
        },
        {
            name = "message",
            description = "A replacement for the message that shows if it cannot be bought.",
            type = "string"
        },
        {
            name = "price",
            description = "An optional override for the price.",
            type = "number"
        }
    }
}

DarkRP.hookStub{
    name = "canBuyVehicle",
    description = "Whether a player can buy a vehicle.",
    parameters = {
        {
            name = "ply",
            description = "The player.",
            type = "Player"
        },
        {
            name = "vehicleTable",
            description = "The table, as defined in the vehicles file.",
            type = "table"
        }
    },
    returns = {
        {
            name = "canBuy",
            description = "Whether it can be bought.",
            type = "boolean"
        },
        {
            name = "suppressMessage",
            description = "Suppress the notification message when it cannot be bought.",
            type = "boolean"
        },
        {
            name = "message",
            description = "A replacement for the message that shows if it cannot be bought.",
            type = "string"
        },
        {
            name = "price",
            description = "An optional override for the price.",
            type = "number"
        }
    }
}

DarkRP.hookStub{
    name = "canBuyAmmo",
    description = "Whether a player can buy ammo.",
    parameters = {
        {
            name = "ply",
            description = "The player.",
            type = "Player"
        },
        {
            name = "ammoTable",
            description = "The table, as defined in the a ammo file.",
            type = "table"
        }
    },
    returns = {
        {
            name = "canBuy",
            description = "Whether it can be bought.",
            type = "boolean"
        },
        {
            name = "suppressMessage",
            description = "Suppress the notification message when it cannot be bought.",
            type = "boolean"
        },
        {
            name = "message",
            description = "A replacement for the message that shows if it cannot be bought.",
            type = "string"
        },
        {
            name = "price",
            description = "An optional override for the price.",
            type = "number"
        }
    }
}

DarkRP.hookStub{
    name = "canBuyCustomEntity",
    description = "Whether a player can a certain custom entity.",
    parameters = {
        {
            name = "ply",
            description = "The player.",
            type = "Player"
        },
        {
            name = "entTable",
            description = "The table, as defined by the user.",
            type = "table"
        }
    },
    returns = {
        {
            name = "canBuy",
            description = "Whether it can be bought.",
            type = "boolean"
        },
        {
            name = "suppressMessage",
            description = "Suppress the notification message when it cannot be bought.",
            type = "boolean"
        },
        {
            name = "message",
            description = "A replacement for the message that shows if it cannot be bought.",
            type = "string"
        },
        {
            name = "price",
            description = "An optional override for the price.",
            type = "number"
        }
    }
}

DarkRP.hookStub{
    name = "onJobRemoved",
    description = "Called when a job was removed.",
    parameters = {
        {
            name = "num",
            description = "The TEAM_ number of the job.",
            type = "number"
        },
        {
            name = "jobbtable",
            description = "The table containing all the job info.",
            type = "table"
        }
    },
    returns = {
    }
}

DarkRP.hookStub{
    name = "onShipmentRemoved",
    description = "Called when a shipment was removed.",
    parameters = {
        {
            name = "num",
            description = "The index of this item.",
            type = "number"
        },
        {
            name = "itemTable",
            description = "The table containing all the info about this item.",
            type = "table"
        }
    },
    returns = {
    }
}

DarkRP.hookStub{
    name = "onVehicleRemoved",
    description = "Called when a vehicle was removed.",
    parameters = {
        {
            name = "num",
            description = "The index of this item.",
            type = "number"
        },
        {
            name = "itemTable",
            description = "The table containing all the info about this item.",
            type = "table"
        }
    },
    returns = {
    }
}

DarkRP.hookStub{
    name = "onEntityRemoved",
    description = "Called when a buyable entity was removed.",
    parameters = {
        {
            name = "num",
            description = "The index of this item.",
            type = "number"
        },
        {
            name = "itemTable",
            description = "The table containing all the info about this item.",
            type = "table"
        }
    },
    returns = {
    }
}

DarkRP.hookStub{
    name = "onGroupChatRemoved",
    description = "Called when a groupchat was removed.",
    parameters = {
        {
            name = "num",
            description = "The index of this item.",
            type = "number"
        },
        {
            name = "itemTable",
            description = "The table containing all the info about this item.",
            type = "table"
        }
    },
    returns = {
    }
}

DarkRP.hookStub{
    name = "onAmmoTypeRemoved",
    description = "Called when a ammotype was removed.",
    parameters = {
        {
            name = "num",
            description = "The index of this item.",
            type = "number"
        },
        {
            name = "itemTable",
            description = "The table containing all the info about this item.",
            type = "table"
        }
    },
    returns = {
    }
}

DarkRP.hookStub{
    name = "onEntityGroupRemoved",
    description = "Called when an entity group was removed.",
    parameters = {
        {
            name = "name",
            description = "The name of this item.",
            type = "string"
        },
        {
            name = "itemTable",
            description = "The table containing all the info about this item.",
            type = "table"
        }
    },
    returns = {
    }
}

DarkRP.hookStub{
    name = "onAgendaRemoved",
    description = "Called when an agenda was removed.",
    parameters = {
        {
            name = "name",
            description = "The name of this item.",
            type = "string"
        },
        {
            name = "itemTable",
            description = "The table containing all the info about this item.",
            type = "table"
        }
    },
    returns = {
    }
}

DarkRP.hookStub{
    name = "onDemoteGroupRemoved",
    description = "Called when a job was demotegroup.",
    parameters = {
        {
            name = "name",
            description = "The name of this item.",
            type = "string"
        },
        {
            name = "itemTable",
            description = "The table containing all the info about this item.",
            type = "table"
        }
    },
    returns = {
    }
}

DarkRP.hookStub{
    name = "loadCustomDarkRPItems",
    description = "Runs right after the scripts from the DarkRPMod are run. You can add custom jobs, entities, shipments and whatever in this hook.",
    parameters = {
    },
    returns = {
    }
}

DarkRP.hookStub{
    name = "postLoadCustomDarkRPItems",
    description = "Runs right after loadCustomDarkRPItems. All custom DarkRP content will be loaded by this time.",
    parameters = {
    },
    returns = {
    }
}

DarkRP.hookStub{
    name = "DarkRPStartedLoading",
    description = "Runs at the very start of loading DarkRP. Not even sandbox has loaded here yet.",
    parameters = {
    },
    returns = {
    }
}

DarkRP.hookStub{
    name = "DarkRPFinishedLoading",
    description = "Runs right after DarkRP itself has loaded. All DarkRPMod stuff (except for disabled_defaults) is loaded during this hook. NOTE! NO CUSTOM STUFF WILL BE AVAILABLE DURING THIS HOOK. USE `loadCustomDarkRPItems` INSTEAD IF YOU WANT THAT!",
    parameters = {
    },
    returns = {
    }
}

--gamemodes/darkrp/gamemode/libraries/disjointset.lua:
/*---------------------------------------------------------------------------
Disjoint-set forest implementation
Inspired by the book Introduction To Algorithms (third edition)

by FPtje Atheos

Running time per operation (Union/FindSet): O(a(n)) where a is the inverse of the Ackermann function.
---------------------------------------------------------------------------*/

local ipairs = ipairs
local setmetatable = setmetatable
local string = string
local table = table
local tostring = tostring

module("disjoint")

local metatable

-- Make a singleton set. Parent parameter is optional, must be a disjoint-set as well.
function MakeSet(x, parent)
    local set  = {}
    set.value  = x
    set.rank   = 0
    set.parent = parent or set

    setmetatable(set, metatable)

    return set
end

local function Link(x, y)
    if x == y then return x end

    -- Union by rank
    if x.rank > y.rank then
        y.parent = x
        return x
    end

    x.parent = y

    if x.rank == y.rank then
        y.rank = y.rank + 1
    end

    return y
end

-- Apply the union operation between two sets.
function Union(x, y)
    return Link(FindSet(x), FindSet(y))
end

function FindSet(x)
    local parent = x
    local listParents

    -- Go up the tree to find the parent
    while parent ~= parent.parent do
        parent = parent.parent

        listParents = listParents or {}
        table.insert(listParents, parent)
    end

    -- Path compression, update all parents to refer to the top parent
    if listParents then
        for _, v in ipairs(listParents) do
            v.parent = parent
        end
    end

    return parent
end

function Disconnect(x)
    x.parent = x

    return x
end


metatable = {
    __tostring = function(self)
        return string.format("Disjoint-Set [value: %s][Rank: %s][Parent: %s]", tostring(self.value), self.rank, tostring(self.parent.value))
    end,
    __metatable = true, -- restrict access to metatable
    __add = Union
}

--gamemodes/darkrp/gamemode/libraries/modificationloader.lua:
-- Modification loader.
-- Dependencies:
--     - fn
--     - simplerr

--[[---------------------------------------------------------------------------
Disabled defaults
---------------------------------------------------------------------------]]
DarkRP.disabledDefaults = {}
DarkRP.disabledDefaults["modules"] = {
    ["afk"]              = true,
    ["chatsounds"]       = false,
    ["events"]           = false,
    ["fpp"]              = false,
    ["hitmenu"]          = false,
    ["hud"]              = false,
    ["hungermod"]        = true,
    ["playerscale"]      = false,
    ["sleep"]            = false,
}

DarkRP.disabledDefaults["agendas"]          = {}
DarkRP.disabledDefaults["ammo"]             = {}
DarkRP.disabledDefaults["demotegroups"]     = {}
DarkRP.disabledDefaults["doorgroups"]       = {}
DarkRP.disabledDefaults["entities"]         = {}
DarkRP.disabledDefaults["food"]             = {}
DarkRP.disabledDefaults["groupchat"]        = {}
DarkRP.disabledDefaults["hitmen"]           = {}
DarkRP.disabledDefaults["jobs"]             = {}
DarkRP.disabledDefaults["shipments"]        = {}
DarkRP.disabledDefaults["vehicles"]         = {}
DarkRP.disabledDefaults["workarounds"]      = {}

-- The client cannot use simplerr.runLuaFile because of restrictions in GMod.
local doInclude = CLIENT and include or fc{simplerr.wrapError, simplerr.wrapLog, simplerr.runFile}

if file.Exists("darkrp_config/disabled_defaults.lua", "LUA") then
    if SERVER then AddCSLuaFile("darkrp_config/disabled_defaults.lua") end
    doInclude("darkrp_config/disabled_defaults.lua")
end

--[[---------------------------------------------------------------------------
Config
---------------------------------------------------------------------------]]
local configFiles = {
    "darkrp_config/settings.lua",
    "darkrp_config/licenseweapons.lua",
}

for _, File in pairs(configFiles) do
    if not file.Exists(File, "LUA") then continue end

    if SERVER then AddCSLuaFile(File) end
    doInclude(File)
end
if SERVER and file.Exists("darkrp_config/mysql.lua", "LUA") then doInclude("darkrp_config/mysql.lua") end

--[[---------------------------------------------------------------------------
Modules
---------------------------------------------------------------------------]]
local function loadModules()
    local fol = "darkrp_modules/"

    local _, folders = file.Find(fol .. "*", "LUA")

    for _, folder in SortedPairs(folders, true) do
        if folder == "." or folder == ".." or GAMEMODE.Config.DisabledCustomModules[folder] then continue end
        -- Sound but incomplete way of detecting the error of putting addons in the darkrpmod folder
        if file.Exists(fol .. folder .. "/addon.txt", "LUA") or file.Exists(fol .. folder .. "/addon.json", "LUA") then
            DarkRP.errorNoHalt("Addon detected in the darkrp_modules folder.", 2, {
                "This addon is not supposed to be in the darkrp_modules folder.",
                "It is supposed to be in garrysmod/addons/ instead.",
                "Whether a mod is to be installed in darkrp_modules or addons is the author's decision.",
                "Please read the readme of the addons you're installing next time."
            },
            "<darkrpmod addon>/lua/darkrp_modules/" .. folder, -1)
            continue
        end

        for _, File in SortedPairs(file.Find(fol .. folder .. "/sh_*.lua", "LUA"), true) do
            if SERVER then
                AddCSLuaFile(fol .. folder .. "/" .. File)
            end

            if File == "sh_interface.lua" then continue end
            doInclude(fol .. folder .. "/" .. File)
        end

        if SERVER then
            for _, File in SortedPairs(file.Find(fol .. folder .. "/sv_*.lua", "LUA"), true) do
                if File == "sv_interface.lua" then continue end
                doInclude(fol .. folder .. "/" .. File)
            end
        end

        for _, File in SortedPairs(file.Find(fol .. folder .. "/cl_*.lua", "LUA"), true) do
            if File == "cl_interface.lua" then continue end

            if SERVER then
                AddCSLuaFile(fol .. folder .. "/" .. File)
            else
                doInclude(fol .. folder .. "/" .. File)
            end
        end
    end
end

local function loadLanguages()
    local fol = "darkrp_language/"

    local files, _ = file.Find(fol .. "*", "LUA")
    for _, File in pairs(files) do
        if SERVER then AddCSLuaFile(fol .. File) end
        doInclude(fol .. File)
    end
end

local customFiles = {
    "darkrp_customthings/jobs.lua",
    "darkrp_customthings/shipments.lua",
    "darkrp_customthings/entities.lua",
    "darkrp_customthings/vehicles.lua",
    "darkrp_customthings/food.lua",
    "darkrp_customthings/ammo.lua",
    "darkrp_customthings/groupchats.lua",
    "darkrp_customthings/categories.lua",
    "darkrp_customthings/agendas.lua", -- has to be run after jobs.lua
    "darkrp_customthings/doorgroups.lua", -- has to be run after jobs.lua
    "darkrp_customthings/demotegroups.lua", -- has to be run after jobs.lua
}
local function loadCustomDarkRPItems()
    for _, File in pairs(customFiles) do
        if not file.Exists(File, "LUA") then continue end
        if File == "darkrp_customthings/food.lua" and DarkRP.disabledDefaults["modules"]["hungermod"] then continue end

        if SERVER then AddCSLuaFile(File) end
        doInclude(File)
    end
end


function GM:DarkRPFinishedLoading()
    -- GAMEMODE gets set after the last statement in the gamemode files is run. That is not the case in this hook
    GAMEMODE = GAMEMODE or GM

    loadLanguages()
    loadModules()
    loadCustomDarkRPItems()
    hook.Call("loadCustomDarkRPItems", self)
    hook.Call("postLoadCustomDarkRPItems", self)
end

--gamemodes/darkrp/gamemode/modules/tipjar/cl_model.lua:
--[[-------------------------------------------------------------------------
The model describes the data that the drives the UI.
Loosely based on the Elm architecture.
---------------------------------------------------------------------------]]

local model = {
    -- The tip jar entity
    tipjar = nil,

    -- Whether the LocalPlayer is the owner of this tipjar
    isOwner = false,

    -- Whether the frame is visible
    frameVisible = false,

    -- The Derma frame object
    frame = nil,

    -- The amount the player is putting in the tip jar
    amount = 0,

    -- The last amount of money the player actually put in the tip jar
    lastTipAmount = 0,

    -- Action: when an active donation changes. The active donations
    -- themselves are fetched from the tipjar, which keeps track of the proper
    -- state for it.
    activeDonationUpdate = nil,

    -- Action: when someone donated. The list of donators is kept track of by
    -- the tipjar.
    donatedUpdate = nil,
}

local updaters = {}

DarkRP.tipJarUIModel = {}

--[[-------------------------------------------------------------------------
Update the model.
Automatically calls the registered update hook functions
---------------------------------------------------------------------------]]
function DarkRP.tipJarUIModel.updateModel(path, value, ...)
    path = istable(path) and path or {path}

    local updTbl = updaters
    local mdlTbl = model
    local key = path[#path]

    for i = 1, #path - 1 do
        mdlTbl = mdlTbl[path[i]]
        updTbl = updTbl and updTbl[path[i]]
    end

    local oldValue = mdlTbl[key]
    mdlTbl[key] = value

    for _, updFunc in ipairs(updTbl and updTbl[key] or {}) do
        updFunc(value, oldValue, ...)

        -- the updFunc changed this value, break off
        if mdlTbl[key] ~= value then break end
    end
end

--[[-------------------------------------------------------------------------
Retrieve a value of the model
---------------------------------------------------------------------------]]
function DarkRP.tipJarUIModel.getModelValue(path)
    path = istable(path) and path or {path}

    local mdlTbl = model
    local key = path[#path]

    for i = 1, #path - 1 do
        mdlTbl = mdlTbl[path[i]]
    end

    return mdlTbl[key]
end

--[[-------------------------------------------------------------------------
Registers a hook that gets triggered when a certain part of the model is
updated
---------------------------------------------------------------------------]]
function DarkRP.tipJarUIModel.onModelUpdate(path, func)
    path = istable(path) and path or {path}

    local updTbl = updaters
    local mdlTbl = model
    local key = path[#path]

    for i = 1, #path - 1 do
        mdlTbl = mdlTbl[path[i]]
        updTbl[path[i]] = updTbl[path[i]] or {}
        updTbl = updTbl[path[i]]
    end

    updTbl[key] = updTbl[key] or {}

    table.insert(updTbl[key], func)

    -- Call update with the initial value
    if mdlTbl[key] ~= nil then
        func(mdlTbl[key], mdlTbl[key])
    end
end

--[[-------------------------------------------------------------------------
Default listeners
---------------------------------------------------------------------------]]
local updateModel, _getModelValue, onModelUpdate =
    DarkRP.tipJarUIModel.updateModel,
    DarkRP.tipJarUIModel.getModelValue,
    DarkRP.tipJarUIModel.onModelUpdate

onModelUpdate("amount", function(new, _)
    local localply = LocalPlayer()
    if not IsValid(localply) then return end

    local ownMoney = localply:getDarkRPVar("money") or 0

    if new < 0 or new % 1 ~= 0 or new > ownMoney then
        local amount = math.abs(math.floor(new))
        amount = math.min(amount, ownMoney)
        updateModel("amount", amount)
    end
end)

--gamemodes/darkrp/gamemode/modules/money/sh_commands.lua:
return gluapack()()
--gamemodes/darkrp/gamemode/modules/language/sh_language.lua:
return gluapack()()
--gamemodes/darkrp/gamemode/modules/language/sh_language.lua:
local rp_languages = {}
local selectedLanguage = GetConVar("gmod_language"):GetString() -- Switch language by setting gmod_language to another language

cvars.AddChangeCallback("gmod_language", function(cv, old, new)
    selectedLanguage = new
end)

-- Some server owners experience that the language is not set correctly on
-- startup. This provides a failsafe in case that happens.
timer.Simple(0, function()
    local gmodLanguage = GetConVar("gmod_language"):GetString()
    if gmodLanguage ~= "" and selectedLanguage ~= gmodLanguage then
        selectedLanguage = gmodLanguage
    end
end)

function DarkRP.addLanguage(name, tbl)
    local old = rp_languages[name] or {}
    rp_languages[name] = tbl

    -- Merge the language with the translations added by DarkRP.addPhrase
    for k, v in pairs(old) do
        if rp_languages[name][k] then continue end
        rp_languages[name][k] = v
    end
    LANGUAGE = rp_languages[name] -- backwards compatibility
end

function DarkRP.addPhrase(lang, name, phrase)
    rp_languages[lang] = rp_languages[lang] or {}
    rp_languages[lang][name] = phrase
end

function DarkRP.getPhrase(name, ...)
    local langTable = rp_languages[selectedLanguage] or rp_languages.en

    return (langTable[name] or rp_languages.en[name]) and string.format(langTable[name] or rp_languages.en[name], ...) or nil
end

function DarkRP.getPhraseLocalized(ply, name, ...)
    local lang = ply:GetInfo("gmod_language") or selectedLanguage
    local langTable = rp_languages[lang] or rp_languages.en

    return (langTable[name] or rp_languages.en[name]) and string.format(langTable[name] or rp_languages.en[name], ...) or nil
end

function DarkRP.getMissingPhrases(lang)
    lang = lang or selectedLanguage
    local res = {}
    local format = "%s = \"%s\","

    for k, v in pairs(rp_languages.en) do
        if rp_languages[lang][k] then continue end
        table.insert(res, string.format(format, k, v))
    end

    return table.IsEmpty(res) and "No language strings missing!" or table.concat(res, "\n")
end

local function getMissingPhrases(ply, cmd, args)
    if not args[1] then print("Please run the command with a language code e.g. darkrp_getphrases \"en\"") return end
    local lang = rp_languages[args[1]]
    if not lang then print("This language does not exist! Make sure the casing is right.")
        print("Available languages:")
        for k in pairs(rp_languages) do print(k) end
        return
    end

    print(DarkRP.getMissingPhrases(args[1]))
end
if CLIENT then concommand.Add("darkrp_getphrases", getMissingPhrases) end

--[[---------------------------------------------------------------------------
Chat command translating
---------------------------------------------------------------------------]]
local chatCmdDescriptions = {}
function DarkRP.addChatCommandsLanguage(lang, tbl)
    chatCmdDescriptions[lang] = chatCmdDescriptions[lang] or {}

    table.Merge(chatCmdDescriptions[lang], tbl)
end

function DarkRP.getChatCommandDescription(name)
    local cmd = DarkRP.getChatCommand(name)
    return chatCmdDescriptions[selectedLanguage] and chatCmdDescriptions[selectedLanguage][name] or
        cmd and cmd.description or
        nil
end

local function getMissingCmdTranslations()
    local cmds = DarkRP.getSortedChatCommands()

    -- No commands have been translated
    if not chatCmdDescriptions[selectedLanguage] then return cmds end

    -- Remove translated commands and maintain keys
    local count = #cmds
    for i = 1, count do
        if chatCmdDescriptions[selectedLanguage][cmds[i].command] then
            cmds[i] = nil
        end
    end

    cmds = table.ClearKeys(cmds)

    return cmds
end

local function printMissingChatTranslations()
    local cmds = getMissingCmdTranslations()
    local text = {}

    local maxCmdLength = 0
    for _, v in pairs(cmds) do maxCmdLength = math.Max(maxCmdLength, string.len(v.command)) end

    for k, v in pairs(cmds) do
        text[k] = string.format([=[["%s"]%s=    "%s",]=], v.command, string.rep(' ', 4 + maxCmdLength - string.len(v.command)), v.description)
    end

    MsgC(Color(0, 255, 0), string.format("%s untranslated chat command descriptions!\n", #cmds))

    text = table.concat(text, "\n    ")
    SetClipboardText(text)

    MsgC(Color(0, 255, 0), "text copied to clipboard!\n")
end
if CLIENT then concommand.Add("darkrp_translateChatCommands", printMissingChatTranslations) end

--gamemodes/darkrp/gamemode/modules/hud/sh_chatcommands.lua:
return gluapack()()
--gamemodes/darkrp/gamemode/modules/hud/sh_chatcommands.lua:
DarkRP.declareChatCommand{
    command = "admintell",
    description = "Send a private, very intimidating message to someone.",
    delay = 1.5,
    tableArgs = true
}

DarkRP.declareChatCommand{
    command = "admintellall",
    description = "Send a very intimidating message to everyone.",
    delay = 1.5
}

--gamemodes/darkrp/gamemode/modules/hud/cl_hud.lua:
--[[---------------------------------------------------------------------------
HUD ConVars
---------------------------------------------------------------------------]]
local ConVars = {}
local HUDWidth
local HUDHeight

local Color = Color
local CurTime = CurTime
local cvars = cvars
local DarkRP = DarkRP
local draw = draw
local GetConVar = GetConVar
local hook = hook
local IsValid = IsValid
local Lerp = Lerp
local localplayer
local math = math
local pairs = pairs
local ScrW, ScrH = ScrW, ScrH
local SortedPairs = SortedPairs
local string = string
local surface = surface
local table = table
local timer = timer
local tostring = tostring
local plyMeta = FindMetaTable("Player")

local colors = {}
colors.black = color_black
colors.blue = Color(0, 0, 255, 255)
colors.brightred = Color(200, 30, 30, 255)
colors.darkred = Color(0, 0, 70, 100)
colors.darkblack = Color(0, 0, 0, 200)
colors.gray1 = Color(0, 0, 0, 155)
colors.gray2 = Color(51, 58, 51,100)
colors.red = Color(255, 0, 0, 255)
colors.white = color_white
colors.white1 = Color(255, 255, 255, 200)

local function ReloadConVars()
    ConVars = {
        background = {0,0,0,100},
        Healthbackground = {0,0,0,200},
        Healthforeground = {140,0,0,180},
        HealthText = {255,255,255,200},
        Job1 = {0,0,150,200},
        Job2 = {0,0,0,255},
        salary1 = {0,150,0,200},
        salary2 = {0,0,0,255}
    }

    for name, Colour in pairs(ConVars) do
        ConVars[name] = {}
        for num, rgb in SortedPairs(Colour) do
            local CVar = GetConVar(name .. num) or CreateClientConVar(name .. num, rgb, true, false)
            table.insert(ConVars[name], CVar:GetInt())

            if not cvars.GetConVarCallbacks(name .. num, false) then
                cvars.AddChangeCallback(name .. num, function()
                    timer.Simple(0, ReloadConVars)
                end)
            end
        end
        ConVars[name] = Color(unpack(ConVars[name]))
    end


    HUDWidth =  (GetConVar("HudW") or CreateClientConVar("HudW", 240, true, false)):GetInt()
    HUDHeight = (GetConVar("HudH") or CreateClientConVar("HudH", 115, true, false)):GetInt()

    if not cvars.GetConVarCallbacks("HudW", false) and not cvars.GetConVarCallbacks("HudH", false) then
        cvars.AddChangeCallback("HudW", function() timer.Simple(0,ReloadConVars) end)
        cvars.AddChangeCallback("HudH", function() timer.Simple(0,ReloadConVars) end)
    end
end
ReloadConVars()

local Scrw, Scrh, RelativeX, RelativeY



local VoiceChatTexture = surface.GetTextureID("voice/icntlk_pl")
local function DrawVoiceChat(gamemodeTable)
    local shouldDraw = hook.Call("HUDShouldDraw", gamemodeTable, "DarkRP_VoiceChat")
    if shouldDraw == false then return end

    if localplayer.DRPIsTalking then
        local _, chboxY = chat.GetChatBoxPos()

        local Rotating = math.sin(CurTime() * 3)
        local backwards = 0

        if Rotating < 0 then
            Rotating = 1 - (1 + Rotating)
            backwards = 180
        end

        surface.SetTexture(VoiceChatTexture)
        surface.SetDrawColor(ConVars.Healthforeground)
        surface.DrawTexturedRectRotated(Scrw - 100, chboxY, Rotating * 96, 96, backwards)
    end
end

local function LockDown(gamemodeTable)
    local chbxX, chboxY = chat.GetChatBoxPos()
    if GetGlobalBool("DarkRP_LockDown") then
        local shouldDraw = hook.Call("HUDShouldDraw", gamemodeTable, "DarkRP_LockdownHUD")
        if shouldDraw == false then return end
        local cin = (math.sin(CurTime()) + 1) / 2
        local chatBoxSize = math.floor(Scrh / 4)
        draw.DrawNonParsedText(DarkRP.getPhrase("lockdown_started"), "ScoreboardSubtitle", chbxX, chboxY + chatBoxSize, Color(cin * 255, 0, 255 - (cin * 255), 255), TEXT_ALIGN_LEFT)
    end
end

local Arrested = function() end

usermessage.Hook("GotArrested", function(msg)
    local StartArrested = CurTime()
    local ArrestedUntil = msg:ReadFloat()

    Arrested = function(gamemodeTable)
        local shouldDraw = hook.Call("HUDShouldDraw", gamemodeTable, "DarkRP_ArrestedHUD")
        if shouldDraw == false then return end

        if CurTime() - StartArrested <= ArrestedUntil and localplayer:getDarkRPVar("Arrested") then
            draw.DrawNonParsedText(DarkRP.getPhrase("youre_arrested", math.ceil((ArrestedUntil - (CurTime() - StartArrested)) * 1 / game.GetTimeScale())), "DarkRPHUD1", Scrw / 2, Scrh - Scrh / 12, colors.white, 1)
        elseif not localplayer:getDarkRPVar("Arrested") then
            Arrested = function() end
        end
    end
end)



--[[---------------------------------------------------------------------------
Entity HUDPaint things
---------------------------------------------------------------------------]]
-- Draw a player's name, health and/or job above the head
-- This syntax allows for easy overriding
plyMeta.drawPlayerInfo = plyMeta.drawPlayerInfo or function(self)
    local pos = self:EyePos()

    pos.z = pos.z + 10 -- The position we want is a bit above the position of the eyes
    pos = pos:ToScreen()
    if not self:getDarkRPVar("wanted") then
        -- Move the text up a few pixels to compensate for the height of the text
        pos.y = pos.y - 50
    end

    if GAMEMODE.Config.showname then
        local nick, plyTeam = self:Nick(), self:Team()
        draw.DrawNonParsedText(nick, "DarkRPHUD2", pos.x + 1, pos.y + 1, colors.black, 1)
        draw.DrawNonParsedText(nick, "DarkRPHUD2", pos.x, pos.y, RPExtraTeams[plyTeam] and RPExtraTeams[plyTeam].color or team.GetColor(plyTeam) , 1)
    end

    if GAMEMODE.Config.showhealth then
        local health = DarkRP.getPhrase("health", math.max(0, self:Health()))
        draw.DrawNonParsedText(health, "DarkRPHUD2", pos.x + 1, pos.y + 21, colors.black, 1)
        draw.DrawNonParsedText(health, "DarkRPHUD2", pos.x, pos.y + 20, colors.white1, 1)
    end

    if GAMEMODE.Config.showjob then
        local teamname = self:getDarkRPVar("job") or team.GetName(self:Team())
        draw.DrawNonParsedText(teamname, "DarkRPHUD2", pos.x + 1, pos.y + 41, colors.black, 1)
        draw.DrawNonParsedText(teamname, "DarkRPHUD2", pos.x, pos.y + 40, colors.white1, 1)
    end

    if self:getDarkRPVar("HasGunlicense") then
        surface.SetMaterial(Page)
        surface.SetDrawColor(255,255,255,255)
        surface.DrawTexturedRect(pos.x-16, pos.y + 60, 32, 32)
    end
end

-- Draw wanted information above a player's head
-- This syntax allows for easy overriding
plyMeta.drawWantedInfo = plyMeta.drawWantedInfo or function(self)
    if not self:Alive() then return end

    local pos = self:EyePos()
    if not pos:isInSight({localplayer, self}) then return end

    pos.z = pos.z + 10
    pos = pos:ToScreen()

    if GAMEMODE.Config.showname then
        local nick, plyTeam = self:Nick(), self:Team()
        draw.DrawNonParsedText(nick, "DarkRPHUD2", pos.x + 1, pos.y + 1, colors.black, 1)
        draw.DrawNonParsedText(nick, "DarkRPHUD2", pos.x, pos.y, RPExtraTeams[plyTeam] and RPExtraTeams[plyTeam].color or team.GetColor(plyTeam) , 1)
    end

    local wantedText = DarkRP.getPhrase("wanted", tostring(self:getDarkRPVar("wantedReason")))

    draw.DrawNonParsedText(wantedText, "DarkRPHUD2", pos.x, pos.y - 40, colors.white1, 1)
    draw.DrawNonParsedText(wantedText, "DarkRPHUD2", pos.x + 1, pos.y - 41, colors.red, 1)
end

--[[---------------------------------------------------------------------------
The Entity display: draw HUD information about entities
---------------------------------------------------------------------------]]
local function DrawEntityDisplay(gamemodeTable)
    local shouldDraw, players = hook.Call("HUDShouldDraw", gamemodeTable, "DarkRP_EntityDisplay")
    if shouldDraw == false then return end

    local shootPos = localplayer:GetShootPos()
    local aimVec = localplayer:GetAimVector()

    for _, ply in ipairs(players or player.GetAll()) do
        if not IsValid(ply)
           or ply == localplayer
           or not ply:Alive()
           or ply:GetNoDraw()
           or ply:IsDormant()
           or ply:GetColor().a == 0 and (ply:GetRenderMode() == RENDERMODE_TRANSALPHA or ply:GetRenderMode() == RENDERMODE_TRANSCOLOR) then
           continue
        end
        local hisPos = ply:GetShootPos()
        if ply:getDarkRPVar("wanted") then ply:drawWantedInfo() end

        if gamemodeTable.Config.globalshow then
            ply:drawPlayerInfo()
        -- Draw when you're (almost) looking at him
        elseif hisPos:DistToSqr(shootPos) < 160000 then
            local pos = hisPos - shootPos
            local unitPos = pos:GetNormalized()
            if unitPos:Dot(aimVec) > 0.95 then
                local trace = util.QuickTrace(shootPos, pos, localplayer)
                if trace.Hit and trace.Entity ~= ply then
                    -- When the trace says you're directly looking at a
                    -- different player, that means you can draw /their/ info
                    if trace.Entity:IsPlayer() then
                        trace.Entity:drawPlayerInfo()
                    end
                    break
                end
                ply:drawPlayerInfo()
            end
        end
    end

    local ent = localplayer:GetEyeTrace().Entity

    if IsValid(ent) and ent:isKeysOwnable() and ent:GetPos():DistToSqr(localplayer:GetPos()) < 40000 then
        ent:drawOwnableInfo()
    end
end

--[[---------------------------------------------------------------------------
Drawing death notices
---------------------------------------------------------------------------]]
function GM:DrawDeathNotice(x, y)
    self.Sandbox.DrawDeathNotice(self, x, y)
end

--[[---------------------------------------------------------------------------
Display notifications
---------------------------------------------------------------------------]]
local notificationSound = GM.Config.notificationSound
local function DisplayNotify(msg)
    local txt = msg:ReadString()
    GAMEMODE:AddNotify(txt, msg:ReadShort(), msg:ReadLong())
    surface.PlaySound(notificationSound)

    -- Log to client console
    MsgC(Color(255, 20, 20, 255), "Kayit Bildirimleri - ", Color(200, 200, 200, 255), txt, "\n")
end
usermessage.Hook("_Notify", DisplayNotify)

--[[---------------------------------------------------------------------------
Remove some elements from the HUD in favour of the DarkRP HUD
---------------------------------------------------------------------------]]
local noDraw = {
    ["CHudHealth"] = true,
    ["CHudBattery"] = true,
    ["CHudSuitPower"] = true,
    ["CHUDQuickInfo"] = true
}
function GM:HUDShouldDraw(name)
    if noDraw[name] or (HelpToggled and name == "CHudChat") then
        return false
    else
        return self.Sandbox.HUDShouldDraw(self, name)
    end
end

--[[---------------------------------------------------------------------------
Disable players' names popping up when looking at them
---------------------------------------------------------------------------]]
function GM:HUDDrawTargetID()
return false
end

--[[---------------------------------------------------------------------------
Actual HUDPaint hook
---------------------------------------------------------------------------]]
function GM:HUDPaint()
    localplayer = localplayer or LocalPlayer()

   -- DrawHUD(self)
   -- DrawEntityDisplay(self)

    self.Sandbox.HUDPaint(self)
end

--gamemodes/darkrp/gamemode/modules/fspectate/cl_init.lua:
FSpectate = {}

local stopSpectating, startFreeRoam
local isSpectating = false
local specEnt
local thirdperson = true
local isRoaming = false
local roamPos -- the position when roaming free
local roamVelocity = Vector(0)
local thirdPersonDistance = 100

/*---------------------------------------------------------------------------
Retrieve the current spectated player
---------------------------------------------------------------------------*/
function FSpectate.getSpecEnt()
    if isSpectating and not isRoaming then
        return IsValid(specEnt) and specEnt or nil
    else
        return nil
    end
end

/*---------------------------------------------------------------------------
startHooks
FAdmin tab buttons
---------------------------------------------------------------------------*/
hook.Add("Initialize", "FSpectate", function()
    surface.CreateFont("UiBold", {
        size = 16,
        weight = 800,
        antialias = true,
        shadow = false,
        font = "Verdana"})

    if not FAdmin then return end
    FAdmin.StartHooks["zzSpectate"] = function()
        FAdmin.Commands.AddCommand("Spectate", nil, "<Player>")

        -- Right click option
        FAdmin.ScoreBoard.Main.AddPlayerRightClick("Spectate", function(ply)
            if not IsValid(ply) then return end
            RunConsoleCommand("FSpectate", ply:UserID())
        end)

        local canSpectate = false
        local function calcAccess()
            CAMI.PlayerHasAccess(LocalPlayer(), "FSpectate", function(b, _)
                canSpectate = b
            end)
        end

        -- Spectate option in player menu
        FAdmin.ScoreBoard.Player:AddActionButton("Spectate", "fadmin/icons/spectate", Color(0, 200, 0, 255), function(ply) calcAccess() return canSpectate and ply ~= LocalPlayer() end, function(ply)
            if not IsValid(ply) then return end
            RunConsoleCommand("FSpectate", ply:UserID())
        end)
    end
end)

/*---------------------------------------------------------------------------
Get the thirdperson position
---------------------------------------------------------------------------*/
local function getThirdPersonPos(ent)
    local aimvector = LocalPlayer():GetAimVector()
    local startPos = ent:IsPlayer() and ent:GetShootPos() or ent:LocalToWorld(ent:OBBCenter())
    local endpos = startPos - aimvector * thirdPersonDistance

    local tracer = {
        start = startPos,
        endpos = endpos,
        filter = specEnt
    }

    local trace = util.TraceLine(tracer)

    return trace.HitPos + trace.HitNormal * 10
end

/*---------------------------------------------------------------------------
Get the CalcView table
---------------------------------------------------------------------------*/
local view = {}
local function getCalcView()
    if not isRoaming then
        if thirdperson then
            view.origin = getThirdPersonPos(specEnt)
            view.angles = LocalPlayer():EyeAngles()
        else
            view.origin = specEnt:IsPlayer() and specEnt:GetShootPos() or specEnt:LocalToWorld(specEnt:OBBCenter())
            view.angles = specEnt:IsPlayer() and specEnt:EyeAngles() or specEnt:GetAngles()
        end

        roamPos = view.origin
        view.drawviewer = false

        return view
    end

    view.origin = roamPos
    view.angles = LocalPlayer():EyeAngles()
    view.drawviewer = true

    return view
end

/*---------------------------------------------------------------------------
specCalcView
Override the view for the player to look through the spectated player's eyes
---------------------------------------------------------------------------*/
local function specCalcView(ply, origin, angles, fov)
    if not IsValid(specEnt) and not isRoaming then
        startFreeRoam()
        return
    end

    view = getCalcView()

    if IsValid(specEnt) then
        specEnt:SetNoDraw(not thirdperson)
    end

    return view
end

/*---------------------------------------------------------------------------
Find the right player to spectate
---------------------------------------------------------------------------*/
local function findNearestObject()
    local aimvec = LocalPlayer():GetAimVector()

    local fromPos = not isRoaming and IsValid(specEnt) and specEnt:EyePos() or roamPos

    local lookingAt = util.QuickTrace(fromPos, aimvec * 5000, LocalPlayer())
    local ent = lookingAt.Entity

    if IsValid(ent) then return ent end

    local foundPly, foundDot = nil, 0

    for _, ply in ipairs(player.GetAll()) do
        if not IsValid(ply) or ply == LocalPlayer() then continue end

        local pos = ply:GetShootPos()
        local dot = (pos - fromPos):GetNormalized():Dot(aimvec)

        -- Discard players you're not looking at
        if dot < 0.97 then continue end
        -- not a better alternative
        if dot < foundDot then continue end

        local trace = util.QuickTrace(fromPos, pos - fromPos, ply)

        if trace.Hit then continue end

        foundPly, foundDot = ply, dot
    end

    return foundPly
end

/*---------------------------------------------------------------------------
Spectate the person you're looking at while you're roaming
---------------------------------------------------------------------------*/
local function spectateLookingAt()
    local obj = findNearestObject()

    if not IsValid(obj) then return end

    isRoaming = false
    specEnt = obj

    net.Start("FSpectateTarget")
        net.WriteEntity(obj)
    net.SendToServer()
end

/*---------------------------------------------------------------------------
specBinds
Change binds to perform spectate specific tasks
---------------------------------------------------------------------------*/
-- Manual keysDown table, so I can return true in plyBindPress and still detect key presses
local keysDown = {}
local function specBinds(ply, bind, pressed)
    local key = input.LookupBinding(bind)

    if bind == "+jump" then
        stopSpectating()
        return true
    elseif bind == "+reload" and pressed then
        local pos = getCalcView().origin - Vector(0, 0, 64)
        RunConsoleCommand("FTPToPos", string.format("%d, %d, %d", pos.x, pos.y, pos.z),
            string.format("%d, %d, %d", roamVelocity.x, roamVelocity.y, roamVelocity.z))
        stopSpectating()
    elseif bind == "+attack" and pressed then
        if not isRoaming then
            startFreeRoam()
        else
            spectateLookingAt()
        end
        return true
    elseif bind == "+attack2" and pressed then
        if isRoaming then
            roamPos = roamPos + LocalPlayer():GetAimVector() * 500
            return true
        end
        thirdperson = not thirdperson

        return true
    elseif isRoaming and not LocalPlayer():KeyDown(IN_USE) then
        local keybind = string.upper(string.match(bind, "+([a-z A-Z 0-9]+)") or "")
        if not keybind or keybind == "USE" or keybind == "SHOWSCORES" or string.find(bind, "messagemode") then return end

        keysDown[keybind] = pressed

        return true
    elseif not isRoaming and thirdperson and (key == "MWHEELDOWN" or key == "MWHEELUP") then
        thirdPersonDistance = thirdPersonDistance + 10 * (key == "MWHEELDOWN" and 1 or -1)
    end
    -- Do not return otherwise, spectating admins should be able to move to avoid getting detected
end

/*---------------------------------------------------------------------------
Scoreboardshow
Set to main view when roaming, open on a player when spectating
---------------------------------------------------------------------------*/
local function fadminmenushow()
    if isRoaming then
        FAdmin.ScoreBoard.ChangeView("Main")
    elseif IsValid(specEnt) and specEnt:IsPlayer() then
        FAdmin.ScoreBoard.ChangeView("Main")
        FAdmin.ScoreBoard.ChangeView("Player", specEnt)
    end
end


/*---------------------------------------------------------------------------
RenderScreenspaceEffects
Draws the lines from players' eyes to where they are looking
---------------------------------------------------------------------------*/
local LineMat = Material("cable/new_cable_lit")
local linesToDraw = {}
local function lookingLines()
    if not linesToDraw[0] then return end

    render.SetMaterial(LineMat)

    cam.Start3D(view.origin, view.angles)
        for i = 0, #linesToDraw, 3 do
            render.DrawBeam(linesToDraw[i], linesToDraw[i + 1], 4, 0.01, 10, linesToDraw[i + 2])
        end
    cam.End3D()
end

/*---------------------------------------------------------------------------
gunpos
Gets the position of a player's gun
---------------------------------------------------------------------------*/
local function gunpos(ply)
    local wep = ply:GetActiveWeapon()
    if not IsValid(wep) then return ply:EyePos() end
    local att = wep:GetAttachment(1)
    if not att then return ply:EyePos() end
    return att.Pos
end

/*---------------------------------------------------------------------------
Spectate think
Free roaming position updates
---------------------------------------------------------------------------*/
local function specThink()
    local ply = LocalPlayer()

    -- Update linesToDraw
    local pls = player.GetAll()
    local lastPly = 0
    local skip = 0
    for i = 0, #pls - 1 do
        local p = pls[i + 1]
        if not IsValid(p) then continue end
        if not isRoaming and p == specEnt and not thirdperson then skip = skip + 3 continue end

        local tr = p:GetEyeTrace()
        local sp = gunpos(p)

        local pos = i * 3 - skip

        linesToDraw[pos] = tr.HitPos
        linesToDraw[pos + 1] = sp
        linesToDraw[pos + 2] = team.GetColor(p:Team())
        lastPly = i
    end

    -- Remove entries from linesToDraw that don't match with a player anymore
    for i = #linesToDraw, lastPly * 3 + 3, -1 do linesToDraw[i] = nil end

    if not isRoaming or keysDown["USE"] then return end

    local roamSpeed = 1000
    local aimVec = ply:GetAimVector()
    local direction
    local frametime = RealFrameTime()

    if keysDown["FORWARD"] then
        direction = aimVec
    elseif keysDown["BACK"] then
        direction = -aimVec
    end

    if keysDown["MOVELEFT"] then
        local right = aimVec:Angle():Right()
        direction = direction and (direction - right):GetNormalized() or -right
    elseif keysDown["MOVERIGHT"] then
        local right = aimVec:Angle():Right()
        direction = direction and (direction + right):GetNormalized() or right
    end

    if keysDown["SPEED"] then
        roamSpeed = 2500
    elseif keysDown["WALK"] or keysDown["DUCK"] then
        roamSpeed = 300
    end

    roamVelocity = (direction or Vector(0, 0, 0)) * roamSpeed

    roamPos = roamPos + roamVelocity * frametime
end

/*---------------------------------------------------------------------------
Draw help on the screen
---------------------------------------------------------------------------*/
local uiForeground, uiBackground = Color(240, 240, 255, 255), Color(20, 20, 20, 120)
local red = Color(255, 0, 0, 255)
local function drawHelp()
    local scrHalfH = math.floor(ScrH() / 2)
    draw.WordBox(2, 10, scrHalfH, "Left click: (Un)select player to spectate", "UiBold", uiBackground, uiForeground)
    draw.WordBox(2, 10, scrHalfH + 20, isRoaming and "Right click: quickly move forwards" or "Right click: toggle thirdperson", "UiBold", uiBackground, uiForeground)
    draw.WordBox(2, 10, scrHalfH + 40, "Jump: Stop spectating", "UiBold", uiBackground, uiForeground)
    draw.WordBox(2, 10, scrHalfH + 60, "Reload: Stop spectating and teleport", "UiBold", uiBackground, uiForeground)

    if FAdmin then
        draw.WordBox(2, 10, scrHalfH + 80, "Opening FAdmin's menu while spectating a player", "UiBold", uiBackground, uiForeground)
        draw.WordBox(2, 10, scrHalfH + 100, "\twill open their page!", "UiBold", uiBackground, uiForeground)
    end


    local target = findNearestObject()
    local pls = player.GetAll()
    for i = 1, #pls do
        local ply = pls[i]
        if not IsValid(ply) then continue end
        if not isRoaming and ply == specEnt then continue end

        local pos = ply:GetShootPos():ToScreen()
        if not pos.visible then continue end

        local x, y = pos.x, pos.y

        draw.RoundedBox(2, x, y - 6, 12, 12, team.GetColor(ply:Team()))
        draw.WordBox(2, x, y - 66, ply:Nick(), "UiBold", uiBackground, uiForeground)
        draw.WordBox(2, x, y - 46, "Health: " .. ply:Health(), "UiBold", uiBackground, uiForeground)
        draw.WordBox(2, x, y - 26, ply:GetUserGroup(), "UiBold", uiBackground, uiForeground)
    end

    if not isRoaming then return end

    if not IsValid(target) then return end

    local center = target:LocalToWorld(target:OBBCenter())
    local eyeAng = EyeAngles()
    local rightUp = eyeAng:Right() * 16 + eyeAng:Up() * 36
    local topRight = (center + rightUp):ToScreen()
    local bottomLeft = (center - rightUp):ToScreen()

    draw.RoundedBox(12, bottomLeft.x, bottomLeft.y, math.max(20, topRight.x - bottomLeft.x), topRight.y - bottomLeft.y, red)
    draw.WordBox(2, bottomLeft.x, bottomLeft.y + 12, "Left click to spectate!", "UiBold", uiBackground, uiForeground)
end

/*---------------------------------------------------------------------------
Start roaming free, rather than spectating a given player
---------------------------------------------------------------------------*/
startFreeRoam = function()
    roamPos = isSpectating and roamPos or LocalPlayer():GetShootPos()

    if IsValid(specEnt) then
        if specEnt:IsPlayer() then
            roamPos = thirdperson and getThirdPersonPos(specEnt) or specEnt:GetShootPos()
        end
        specEnt:SetNoDraw(false)
    end

    specEnt = nil
    isRoaming = true
    keysDown = {}
end

/*---------------------------------------------------------------------------
specEnt
Spectate a player
---------------------------------------------------------------------------*/
local function startSpectate(um)
    isRoaming = net.ReadBool()
    specEnt = net.ReadEntity()
    specEnt = IsValid(specEnt) and specEnt or nil

    if isRoaming then
        startFreeRoam()
    end

    isSpectating = true
    keysDown = {}

    hook.Add("CalcView", "FSpectate", specCalcView)
    hook.Add("PlayerBindPress", "FSpectate", specBinds)
    hook.Add("ShouldDrawLocalPlayer", "FSpectate", function() return isRoaming or thirdperson end)
    hook.Add("Think", "FSpectate", specThink)
    hook.Add("HUDPaint", "FSpectate", drawHelp)
    hook.Add("FAdmin_ShowFAdminMenu", "FSpectate", fadminmenushow)
    hook.Add("RenderScreenspaceEffects", "FSpectate", lookingLines)

    timer.Create("FSpectatePosUpdate", 0.5, 0, function()
        if not isRoaming then return end

        RunConsoleCommand("_FSpectatePosUpdate", roamPos.x, roamPos.y, roamPos.z)
    end)
end
net.Receive("FSpectate", startSpectate)

/*---------------------------------------------------------------------------
stopSpectating
Stop spectating a player
---------------------------------------------------------------------------*/
stopSpectating = function()
    hook.Remove("CalcView", "FSpectate")
    hook.Remove("PlayerBindPress", "FSpectate")
    hook.Remove("ShouldDrawLocalPlayer", "FSpectate")
    hook.Remove("Think", "FSpectate")
    hook.Remove("HUDPaint", "FSpectate")
    hook.Remove("FAdmin_ShowFAdminMenu", "FSpectate")
    hook.Remove("RenderScreenspaceEffects", "FSpectate")

    timer.Remove("FSpectatePosUpdate")

    if IsValid(specEnt) then
        specEnt:SetNoDraw(false)
    end

    RunConsoleCommand("FSpectate_StopSpectating")
    isSpectating = false
end

--gamemodes/darkrp/gamemode/modules/chat/cl_chatlisteners.lua:
return gluapack()()
--gamemodes/darkrp/gamemode/modules/chat/cl_chat.lua:
return gluapack()()
--gamemodes/darkrp/gamemode/modules/base/sh_simplerr.lua:
-- simplerrRun: Run a function with the given parameters and send any runtime errors to admins
DarkRP.simplerrRun = fc{
    fn.Snd, -- On success ignore the first return value
    simplerr.wrapError,
    simplerr.wrapHook,
    simplerr.wrapLog,
    simplerr.safeCall
}

-- error: throw a runtime error without exiting the stack
-- parameters: msg, [stackNr], [hints], [path], [line]
DarkRP.errorNoHalt = fc{
    simplerr.wrapHook,
    simplerr.wrapLog,
    simplerr.runError,
    function(msg, err, ...) return msg, err and err + 3 or 4, ... end -- Raise error level one higher
}

-- error: throw a runtime error
-- parameters: msg, [stackNr], [hints], [path], [line]
DarkRP.error = fc{
    simplerr.wrapError,
    DarkRP.errorNoHalt
}

-- Print errors from the server in the console and show a message in chat
if CLIENT then
    local function showError(count, errs)
        local one = count == 1
        chat.AddText(Color(255, 0, 0), string.format("There %s %i Lua problem%s!", one and "is" or "are", count, one and "" or 's'))
        chat.AddText(color_white, "\tPlease check your console for more information!")
        chat.AddText(color_white, "\tNote: This error likely breaks your server. Make sure to solve the error!")

        for i = 1, count do
            MsgC(Color(137, 222, 255), errs[i] .. "\n")
        end
    end

    net.Receive("DarkRP_simplerrError", function()
        local count = net.ReadUInt(16)
        local errs = {}

        for i = 1, count do
            table.insert(errs, net.ReadString())
        end

        showError(count, errs)
    end)
    hook.Add("onSimplerrError", "DarkRP_Simplerr", function(err) showError(1, {err}) end)

    return
end

-- Serverside part
local plyMeta = FindMetaTable("Player")
util.AddNetworkString("DarkRP_simplerrError")

-- Send all errors to the client
local function sendErrors(plys, errs)
    local count = #errs
    local one = count == 1

   -- DarkRP.notify(plys, 1, 120, string.format("There %s %i Lua problem%s!\nPlease check your console for more information!", one and "is" or "are", count, one and "" or 's'))
    net.Start("DarkRP_simplerrError")
        net.WriteUInt(#errs, 16)
        fn.ForEach(fn.Flip(net.WriteString), errs)
    net.Send(plys)
end

-- Annoy all admins when an error occurs
local function annoyAdmins(err)
    local admins = fn.Filter(plyMeta.IsAdmin, player.GetAll())
    sendErrors(admins, {err})
end
hook.Add("onSimplerrError", "DarkRP_Simplerr", annoyAdmins)

-- Annoy joining admin with errors
local function annoyAdmin(ply)
    if not IsValid(ply) or not ply:IsAdmin() then return end
    local errs = table.Copy(simplerr.getLog())
    if table.IsEmpty(errs) then return end

    fn.Map(fp{fn.GetValue, "err"}, errs)
    sendErrors(ply, errs)
end
hook.Add("PlayerInitialSpawn", "DarkRP_Simplerr", function(ply) timer.Simple(1, fp{annoyAdmin, ply}) end)

--gamemodes/darkrp/gamemode/modules/base/cl_jobmodels.lua:

sql.Query([[CREATE TABLE IF NOT EXISTS darkrp_playermodels(
    server TEXT NOT NULL,
    jobcmd TEXT NOT NULL,
    model TEXT NOT NULL,
    PRIMARY KEY (server, jobcmd)
);]])

local preferredModels = {}

function DarkRP.setPreferredJobModel(teamNr, model)
    local job = RPExtraTeams[teamNr]
    if not job then return end
    preferredModels[job.command] = model
    sql.Query(string.format([[REPLACE INTO darkrp_playermodels(server, jobcmd, model) VALUES(%s, %s, %s);]], sql.SQLStr(game.GetIPAddress()), sql.SQLStr(job.command), sql.SQLStr(model)))

    net.Start("DarkRP_preferredjobmodel")
        net.WriteUInt(teamNr, 8)
        net.WriteString(model)
    net.SendToServer()
end

function DarkRP.getPreferredJobModel(teamNr)
    local job = RPExtraTeams[teamNr]
    if not job then return end
    return preferredModels[job.command]
end

local function sendModels()
    net.Start("DarkRP_preferredjobmodels")
        for _, job in pairs(RPExtraTeams) do
            if not preferredModels[job.command] then net.WriteBit(false) continue end

            net.WriteBit(true)
            net.WriteString(preferredModels[job.command])
        end
    net.SendToServer()
end

local function jobHasModel(job, model)
    return istable(job.model) and table.HasValue(job.model, model) or job.model == model
end

local function setPreferredModels(models)
    for _, v in ipairs(models) do
        local job = DarkRP.getJobByCommand(v.jobcmd)
        if job == nil or not jobHasModel(job, v.model) then continue end

        preferredModels[v.jobcmd] = v.model
    end
end

-- The old table, darkp_playermodels, acts as a global mapping of preferred
-- models for jobs.
local function setModelsFromOldTable()
    local oldTableExists = tobool(sql.QueryValue([[SELECT 1 FROM sqlite_master WHERE type='table' AND name='darkp_playermodels']]))
    if not oldTableExists then return end

    local models = sql.Query([[SELECT jobcmd, model FROM darkp_playermodels;]])

    if not models then return end
    setPreferredModels(models)
end

-- The newer table is server specific.
local function setModelsFromNewTable()
    local models = sql.Query(string.format([[SELECT jobcmd, model FROM darkrp_playermodels WHERE server = %s;]], sql.SQLStr(game.GetIPAddress())))

    if not models then return end
    setPreferredModels(models)
end

timer.Simple(0, function()

    setModelsFromOldTable()
    setModelsFromNewTable()

    sendModels()
end)

--gamemodes/darkrp/gamemode/modules/base/cl_gamemode_functions.lua:
local GUIToggled = false
local mouseX, mouseY = ScrW() / 2, ScrH() / 2
function GM:ShowSpare1()
    local jobTable = LocalPlayer():getJobTable()
    if jobTable and jobTable.ShowSpare1 then
        return jobTable.ShowSpare1(LocalPlayer())
    end

    GUIToggled = not GUIToggled

    if GUIToggled then
        gui.SetMousePos(mouseX, mouseY)
    else
        mouseX, mouseY = gui.MousePos()
    end
    gui.EnableScreenClicker(GUIToggled)
end

function GM:ShowSpare2()
    local jobTable = LocalPlayer():getJobTable()
    if jobTable and jobTable.ShowSpare2 then
        return jobTable.ShowSpare2(LocalPlayer())
    end

    DarkRP.toggleF4Menu()
end

function GM:PlayerStartVoice(ply)
    if ply == LocalPlayer() then
        ply.DRPIsTalking = true
        return 
    end
    self.Sandbox.PlayerStartVoice(self, ply)
end

function GM:PlayerEndVoice(ply)
    if ply == LocalPlayer() then
        ply.DRPIsTalking = false
        return
    end

    self.Sandbox.PlayerEndVoice(self, ply)
end

function GM:OnPlayerChat()
end

local FKeyBinds = {
    ["gm_showhelp"] = "ShowHelp",
    ["gm_showteam"] = "ShowTeam",
    ["gm_showspare1"] = "ShowSpare1",
    ["gm_showspare2"] = "ShowSpare2"
}

function GM:PlayerBindPress(ply, bind, pressed)
    self.Sandbox.PlayerBindPress(self, ply, bind, pressed)

    local bnd = string.match(string.lower(bind), "gm_[a-z]+[12]?")
    if bnd and FKeyBinds[bnd] then
        hook.Call(FKeyBinds[bnd], GAMEMODE)
    end

  --  if not self.Config.deadvoice and not ply:Alive() and string.find(string.lower(bind), "voicerecord") then return true end
end

function GM:InitPostEntity()
    hook.Call("teamChanged", GAMEMODE, GAMEMODE.DefaultTeam, GAMEMODE.DefaultTeam)
end

function GM:teamChanged(before, after)
end

local function OnChangedTeam(um)
    local oldTeam, newTeam = um:ReadShort(), um:ReadShort()
    hook.Call("teamChanged", GAMEMODE, oldTeam, newTeam) -- backwards compatibility
    hook.Call("OnPlayerChangedTeam", GAMEMODE, LocalPlayer(), oldTeam, newTeam)
end
usermessage.Hook("OnChangedTeam", OnChangedTeam)

timer.Simple(0, function() GAMEMODE.ShowTeam = DarkRP.openKeysMenu end)

--gamemodes/darkrp/gamemode/config/ammotypes.lua:
return gluapack()()
--addons/glorifiedleveling/lua/glorifiedleveling/enum/sh_glorifiedleveling_enum_perks.lua:
return gluapack()()
--addons/glorifiedleveling/lua/glorifiedleveling/libraries/cl_glorifiedleveling_uilib.lua:

GlorifiedLeveling.UI = GlorifiedLeveling.UI or {}

local lerp = Lerp
function GlorifiedLeveling.UI.LerpColor( t, from, to )
    local col = Color( 0, 0, 0 )

    col.r = lerp( t, from.r, to.r )
    col.g = lerp( t, from.g, to.g )
    col.b = lerp( t, from.b, to.b )
    col.a = lerp( t, from.a, to.a )

    return col
end

function GlorifiedLeveling.UI.StartCutOut( areaDraw )
    render.ClearStencil()
    render.SetStencilEnable( true )
    render.SetStencilCompareFunction( STENCIL_ALWAYS )
    render.SetStencilPassOperation( STENCIL_REPLACE )
    render.SetStencilFailOperation( STENCIL_KEEP )
    render.SetStencilZFailOperation( STENCIL_KEEP )

    render.SetStencilWriteMask( 1 )
    render.SetStencilTestMask( 1 )
    render.SetStencilReferenceValue( 1 )

    render.OverrideColorWriteEnable( true, false )

    areaDraw()

    render.OverrideColorWriteEnable( false, false )

    render.SetStencilCompareFunction( STENCIL_EQUAL )
end

function GlorifiedLeveling.UI.EndCutOut()
    render.SetStencilEnable( false )
end
--addons/glorifiedleveling/lua/glorifiedleveling/localization/sh_glorifiedleveling_english.lua:

GlorifiedLeveling.i18n.RegisterPhrases( "en", {
    glDarkTheme = "Karanlık Tema",
    glLevelNotHighEnough = "Bunun için yeterince yüksek seviyede değilsin.",
    glYouReceivedXP = "%s XP kazandınız.",
    glYouReceivedXPKill = "%s XP %s'yı öldürdüğünden dolayı kazandınız.",
    glLevelX = "Seviye %s",
    glLevelUp = "Seviye Atladınız!",
    glAdminMenuLockdown = "SOKAĞA ÇIKMA YASAĞI",
    glAdminMenuPlayers = "OYUNCULAR",
    glPlayersOnline = "Çevrimiçi Oyuncular: %s",
    glSetLevel = "Seviye Ayarla",
    glResetLevel = "Seviye Sıfırla",
    glAddXP = "XP Ekle",
    glConfirmation = "Onayla",
    glYes = "Evet",
    glNo = "Hayır",
    glConfirmationResetLevel = "Bu oyuncunun seviyesini sıfırlamak istiyor musun?",
    glEnterLevel = "Oyuncunun yeni seviyesini aşağıya giriniz.",
    glEnterXP = "Eklemek istediğiniz XP miktarını giriniz.",
    glEnter = "Gir",
    glInvalidAmount = "Geçersiz miktar.",
    glMaxLevel = "Maksimum Seviye",

    -- Leaderboard localization.
    glLeaderboard = "Skor Tahtası",
    glName = "İsim",
    glXP = "XP",
    glLevel = "Seviye",
    glNobodyHere = "Burada kimse yok :(",

    -- Perk localization.
    glSkills = "Özellikler",
    glPoints = "%s Puan",
    glComplete = "Tamamla",

    glHasteBoots = "Hızlandırıcı Botlar",
    glHasteBootsDescription = "Ekstra Hız kazan!",

    glFeralLeaping = "Sıçratıcı Botlar",
    glFeralLeapingDescription = "Daha Yükseğe Zıplama, Daha Az Düşme Hasarı!",

    glIronSkin = "Demir Cilt",
    glIronSkinDescription = "Doğduğunda Ekstra Zırh!",

    glJuggernaut = "Juggernaut",
    glJuggernautDescription = "Doğduğunda Ekstra Can!",

    glBulletAbsorption = "Mermi Soğurması",
    glBulletAbsorptionDescription = "Daha Az Hasar Al!",

    glHighGradeBullets = "Yüksek Kalitede Mermiler",
    glHighGradeBulletsDescription = "Daha Fazla Hasar Ver!",
} )
--addons/glorifiedleveling/lua/glorifiedleveling/localization/sh_glorifiedleveling_spanish.lua:
return gluapack()()
--addons/glorifiedleveling/lua/glorifiedleveling/modules/core/sh_glorifiedleveling_perks.lua:

function GlorifiedLeveling.GetTotalLevelsFromPerkTable( perkTbl )
    local totalLevels = 0
    for k, v in ipairs( perkTbl ) do totalLevels = totalLevels + v end
    return totalLevels
end

local function getPerkCountPerLevel( perk )
    return GlorifiedLeveling.Config.PERK_CONFIG[perk]
end

local perksEnum = GlorifiedLeveling.Perks.Enum

if CLIENT then
    gameevent.Listen( "player_spawn" )

    hook.Add( "player_spawn", "GlorifiedLeveling.Perks.player_spawn", function( data )
        if Player( data.userid ) ~= LocalPlayer() or not GlorifiedLeveling.PerkTableCache or table.IsEmpty( GlorifiedLeveling.PerkTableCache ) then return end
        net.Start( "GlorifiedLeveling.Perks.UpdatePerkInfo" )
        net.WriteTableAsString( GlorifiedLeveling.PerkTableCache )
        net.SendToServer()
        GlorifiedLeveling.PerkTableCache = nil
    end )

   /* hook.Add( "Move", "GlorifiedLeveling.Perks.Move", function( ply, mv, usrcmd )
        if ply.IsProne and ply:IsProne() then return end
        local speed = mv:GetMaxSpeed() * ( 1 + ( getPerkCountPerLevel( perksEnum.SPEED ) * GlorifiedLeveling.GetPlayerPerkLevel( perksEnum.SPEED ) / 100 ) )
        mv:SetMaxSpeed( speed )
        mv:SetMaxClientSpeed( speed )
    end ) */
else
   /* hook.Add( "Move", "GlorifiedLeveling.Perks.Move", function( ply, mv, usrcmd )
        if ply.IsProne and ply:IsProne() then return end
        local speed = mv:GetMaxSpeed() * ( 1 + ( getPerkCountPerLevel( perksEnum.SPEED ) * GlorifiedLeveling.GetPlayerPerkLevel( ply, perksEnum.SPEED ) / 100 ) )
        mv:SetMaxSpeed( speed )
        mv:SetMaxClientSpeed( speed )
    end )*/

    local function applyPlayerPerks( ply )
        timer.Simple( 5, function()
            -- I don't usually put things in small timers, but I'm willing to bet there's some gamemodes with retarded practice that set health/armour on spawn instead of adding.
            if not IsValid(ply) then return end
            local shouldApplyPerks = hook.Run( "GlorifiedLeveling.SpawnPerksApplied" )
            if shouldApplyPerks == false then return end
            ply:SetJumpPower( ply:GetJumpPower() * ( 1 + ( getPerkCountPerLevel( perksEnum.LEAPING ) * GlorifiedLeveling.GetPlayerPerkLevel( ply, perksEnum.LEAPING ) / 100 * 1.2 ) ) )
            ply:SetGravity( 1 - ( getPerkCountPerLevel( perksEnum.LEAPING ) * GlorifiedLeveling.GetPlayerPerkLevel( ply, perksEnum.LEAPING ) / 100 ) )
            ply:SetArmor( ply:Armor() + ( getPerkCountPerLevel( perksEnum.ARMOR ) * GlorifiedLeveling.GetPlayerPerkLevel( ply, perksEnum.ARMOR ) ) )
            ply:SetHealth( ply:Health() + ( getPerkCountPerLevel( perksEnum.HEALTH ) * GlorifiedLeveling.GetPlayerPerkLevel( ply, perksEnum.HEALTH ) ) )
            ply:SetWalkSpeed( ply:GetWalkSpeed() + (  ( getPerkCountPerLevel( perksEnum.SPEED ) * GlorifiedLeveling.GetPlayerPerkLevel( ply,perksEnum.SPEED ) * 1.43) ) )
            ply:SetRunSpeed( ply:GetRunSpeed() + (  ( getPerkCountPerLevel( perksEnum.SPEED ) * GlorifiedLeveling.GetPlayerPerkLevel(ply,perksEnum.SPEED )  * 1.43 ) ) )
        end )
    end

    hook.Add( "PlayerSpawn", "GlorifiedLeveling.Perks.PlayerSpawn", applyPlayerPerks )

    hook.Add( "OnPlayerChangedTeam", "GlorifiedLeveling.Perks.OnPlayerChangedTeam", function( ply )
        if GlorifiedLeveling.Config.APPLY_PERKS_ON_TEAM_CHANGE then applyPlayerPerks( ply ) end
    end )

    hook.Add( "ScalePlayerDamage", "GlorifiedLeveling.Perks.ScalePlayerDamage", function( ply, hitgroup, dmginfo )
        if not IsValid( ply ) then return end
        local scaleCount = 1
        local attacker = dmginfo:GetAttacker()
        if attacker:IsValid() and attacker:IsPlayer() then scaleCount = scaleCount + ( getPerkCountPerLevel( perksEnum.MORE_DAMAGE_GIVEN ) * GlorifiedLeveling.GetPlayerPerkLevel( ply, perksEnum.MORE_DAMAGE_GIVEN ) / 100 ) end
      --  scaleCount = scaleCount - ( getPerkCountPerLevel( perksEnum.LESS_DAMAGE_TAKEN ) * GlorifiedLeveling.GetPlayerPerkLevel( ply, perksEnum.LESS_DAMAGE_TAKEN ) / 100 )
        dmginfo:ScaleDamage( scaleCount )
    end )
    
end
--addons/glorifiedleveling/lua/glorifiedleveling/modules/ui/adminpanel/cl_glorifiedleveling_addxpconfirmation.lua:

local PANEL = {}

function PANEL:Init()
    self:SetSize( ScrH() * 0.5, ScrH() * 0.2 )
    self:Center()
    self:MakePopup()

    self.Theme = GlorifiedLeveling.Themes.GetCurrent()

    self.Close = vgui.Create("DButton", self)
    self.Close:SetText("")

    self.Close.DoClick = function(s)
        self:Remove()
    end

    self.Close.Color = Color(255, 255, 255)
    self.Close.Paint = function(s, w, h)
        local iconSize = h * .5

        s.Color = GlorifiedLeveling.UI.LerpColor( FrameTime() * 5, s.Color, s:IsHovered() and self.Theme.Data.Colors.adminMenuCloseButtonHoverCol or self.Theme.Data.Colors.adminMenuCloseButtonCol )

        surface.SetDrawColor( s.Color )
        surface.SetMaterial( self.Theme.Data.Materials.close )
        surface.DrawTexturedRect( w / 2 - iconSize / 2, h / 2 - iconSize / 2, iconSize, iconSize )
    end

    self.Entry = vgui.Create( "DTextEntry", self )
    self.Entry:SetValue( "0" )
    self.Entry:SetFont( "GlorifiedLeveling.AdminMenu.SetLevelEntry" )
    self.Entry:SetNumeric( true )

    self.Enter = vgui.Create( "DButton", self )
    self.Enter:SetText("")

    self.Enter.Color = Color( 255, 255, 255 )
    self.Enter.Paint = function( s, w, h )
        s.Color = GlorifiedLeveling.UI.LerpColor( FrameTime() * 10, s.Color, s:IsHovered() and self.Theme.Data.Colors.setLevelButtonBackgroundHoverCol or self.Theme.Data.Colors.setLevelButtonBackgroundCol )

        draw.RoundedBox( h * 0.1, 0, 0, w, h, s.Color )
        draw.SimpleText( GlorifiedLeveling.i18n.GetPhrase( "glEnter" ), "GlorifiedLeveling.AdminMenu.SetLevelButton", w / 2, h * .43, self.Theme.Data.Colors.setLevelButtonTextCol, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
    end

    self.Enter.DoClick = function( s )
        if not self.SteamID then return end
        if tonumber( self.Entry:GetValue() ) < 0 then
            GlorifiedLeveling.Notify( NOTIFY_ERROR, 3, GlorifiedLeveling.i18n.GetPhrase( "glInvalidAmount" ) )
            return
        end

        net.Start( "GlorifiedLeveling.AdminPanel.AddPlayerXP" )
         net.WriteString( self.SteamID )
         net.WriteUInt( self.Entry:GetValue(), 32 )
        net.SendToServer()

        net.Start("GlorifiedLeveling.AdminPanel.PlayerListOpened")
        net.SendToServer()

        self:Remove()
    end

    timer.Simple( 0, function()
        if self.Username then return end
        steamworks.RequestPlayerInfo( self.SteamID, function( name )
            self.Username = name
        end )
    end)
end

function PANEL:PerformLayout( w, h )
    self.Close:SetSize( h * 0.18, h * 0.18 )
    self.Close:SetPos( w - h * 0.18, 0 )

    self.Entry:SetSize( w * 0.95, h * 0.2 )
    self.Entry:SetPos( w * 0.025, h * 0.4)

    self.Enter:SetSize( w * 0.95, h * 0.2)
    self.Enter:SetPos( w * 0.025, h * 0.73)
end

function PANEL:Think()
    self:MoveToFront()
end

function PANEL:Paint( w, h )
    draw.RoundedBox( 6, 0, 0, w, h, self.Theme.Data.Colors.adminMenuConfirmationBackgroundCol )
    draw.RoundedBoxEx( 6, 0, 0, w, h * 0.18, self.Theme.Data.Colors.adminMenuConfirmationTopBackgroundCol, true, true )

    draw.SimpleText( GlorifiedLeveling.i18n.GetPhrase( "glAddXP" ), "GlorifiedLeveling.AdminMenu.SetLevelTitle", w * .021, h * .08, self.Theme.Data.Colors.adminMenuNavbarItemCol, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
    draw.SimpleText( GlorifiedLeveling.i18n.GetPhrase( "glEnterXP", self.Username and self.Username or self.SteamID or "undefined" ), "GlorifiedLeveling.AdminMenu.SetLevelDescription", w * 0.021, h * 0.23, self.Theme.Data.Colors.adminMenuNavbarItemCol )
end

vgui.Register( "GlorifiedLeveling.AddXPConfirmation", PANEL, "EditablePanel" )
--addons/glorifiedleveling/lua/glorifiedleveling/modules/ui/adminpanel/cl_glorifiedleveling_adminmenu.lua:
return gluapack()()
--addons/glorifiedleveling/lua/glorifiedleveling/modules/ui/adminpanel/cl_glorifiedleveling_circleavatar.lua:

local PANEL = {}

AccessorFunc( PANEL, "m_masksize", "MaskSize", FORCE_NUMBER )

function PANEL:Init()
    self.Avatar = vgui.Create( "AvatarImage", self )
    self.Avatar:SetPaintedManually( true )

    self:SetMaskSize( 1 )

    self:SetText( "" )
end

function PANEL:DoClick()
    if not self.SteamID then return end

    gui.OpenURL( "https://steamcommunity.com/profiles/" .. self.SteamID )
end

function PANEL:PerformLayout()
    self.Avatar:SetSize( self:GetWide(), self:GetTall() )
end

function PANEL:SetPlayer( id, size )
    self.Avatar:SetPlayer( id, size )
end

function PANEL:SetSteamID( steamid, size )
    if not isstring( steamid ) then return end

    self.SteamID = steamid
    self.Avatar:SetSteamID( steamid, size )
end

function PANEL:Paint( w, h )
    render.ClearStencil()
    render.SetStencilEnable( true )
    render.SetStencilWriteMask( 1 )
    render.SetStencilTestMask( 1 )
    render.SetStencilFailOperation( STENCILOPERATION_REPLACE )
    render.SetStencilPassOperation( STENCILOPERATION_ZERO )
    render.SetStencilZFailOperation( STENCILOPERATION_ZERO )
    render.SetStencilCompareFunction( STENCILCOMPARISONFUNCTION_NEVER )
    render.SetStencilReferenceValue( 1 )

    local _m = self.m_masksize
    local circle, t = {}, 0

    for i = 1, 360 do
        t = math.rad( i * 720 ) / 720

        circle[i] = {
            x = w / 2 + math.cos( t ) * _m,
            y = h / 2 + math.sin( t ) * _m
        }
    end

    draw.NoTexture()
    surface.SetDrawColor( color_white )
    surface.DrawPoly( circle )
    render.SetStencilFailOperation( STENCILOPERATION_ZERO )
    render.SetStencilPassOperation( STENCILOPERATION_REPLACE )
    render.SetStencilZFailOperation( STENCILOPERATION_ZERO )
    render.SetStencilCompareFunction( STENCILCOMPARISONFUNCTION_EQUAL )
    render.SetStencilReferenceValue( 1 )

    self.Avatar:SetPaintedManually( false )
    self.Avatar:PaintManual()
    self.Avatar:SetPaintedManually( true )

    render.SetStencilEnable( false )
    render.ClearStencil()
end

vgui.Register( "GlorifiedLeveling.CircleAvatar", PANEL, "DButton" )
--addons/zerosfruitslicer/lua/darkrp_modules/zfs/sh_zfs_darkrp.lua:
TEAM_ZFRUITSLICER = DarkRP.createJob("Smoothieci", {
	color = Color(20, 150, 20, 255),
	model = {"models/player/group01/male_02.mdl"},
	description = [[Smoothie Yapıp Satarsın!]],
	weapons = {"glorifiedbanking_card","zfs_knife"},
	command = "FruitSlicer",
	max = 2,
	salary = 50,
	admin = 0,
	vote = false,
	category = "Sivil",
	hasLicense = false
})

DarkRP.createCategory{
	name = "Smoothie",
	categorises = "entities",
	startExpanded = true,
	color = Color(0, 107, 0, 255),
	canSee = function(ply) return true end,
	sortOrder = 235
}

DarkRP.createEntity("Smoothie Standı", {
	ent = "zfs_shop",
	model = "models/zerochain/fruitslicerjob/fs_shop.mdl",
	price = 4000,
	max = 1,
	cmd = "buyzfs_shop",
	allowed = TEAM_ZFRUITSLICER,
	category = "Smoothie",
	sortOrder = 0
})

// Needs to run delayed to make sure zfs.config.Fruits exists
timer.Simple(1, function()
	for k, v in pairs(zfs.config.Fruits) do
		DarkRP.createEntity(v.Name, {
			ent = "zfs_fruitbox",
			model = "models/zerochain/fruitslicerjob/fs_cardboardbox.mdl",
			price = 1000,
			max = 5,
			cmd = "buy_" .. v.Name,
			allowed = TEAM_ZFRUITSLICER,
			category = "Smoothie",
			spawn = function(ply, tr, tblEnt)
				local ent = ents.Create("zfs_fruitbox")
				ent:SetFruitID(k)
				ent:SetPos(tr.HitPos + Vector(0,0,10))
				ent:Spawn()
				ent:Activate()
				ent:SetFruitID(k)
				return ent
			end,
		})
	end
end)

--addons/darkrpmodification/lua/darkrp_customthings/groupchats.lua:
return gluapack()()
--addons/darkrpmodification/lua/darkrp_customthings/demotegroups.lua:
--[[---------------------------------------------------------------------------
Demote groups
---------------------------------------------------------------------------
When a chief of police gets demoted you don't want them to be banned from becoming civil protection officer as well.
That is what demote groups are for.

When someone in a group is demoted, they will be banned from EVERY job in the group.
The examples shown below are the default demote groups

HOW TO CREATE A DEMOTE GROUP:
DarkRP.createDemoteGroup("Name of the group", {TEAM1, TEAM2})
---------------------------------------------------------------------------]]


-- Example: DarkRP.createDemoteGroup("Cops", {TEAM_POLICE, TEAM_CHIEF})
-- Example: DarkRP.createDemoteGroup("Gangsters", {TEAM_GANG, TEAM_MOB})

--addons/glorifiedhandcuffs/lua/glorifiedhandcuffs/modules/ui/interactionmenu/cl_glorifiedhandcuffs_interactionmenu_panel.lua:

local PANEL = {}

function PANEL:PerformLayout( w, h )
    self.TitleBar:Dock( TOP )
    self.TitleBar:SetSize( w, h * 0.1 )

    self.NameInfoBox:SetSize( w, h * 0.085 )
    self.NameInfoBox:DockMargin( 15, 15, 15, 0 )
    self.NameInfoBox:Dock( TOP )

    self.JobInfoBox:SetSize( w, h * 0.085 )
    self.JobInfoBox:DockMargin( 15, 10, 15, 0 )
    self.JobInfoBox:Dock( TOP )

    self.WalletInfoBox:SetSize( w, h * 0.085 )
    self.WalletInfoBox:DockMargin( 15, 10, 15, 0 )
    self.WalletInfoBox:Dock( TOP )

    self.WeaponsBox:SetSize( w, h * 0.38 )
    self.WeaponsBox:Dock( TOP )
    self.WeaponsBox:DockMargin( 15, 10, 15, 0 )
end

function PANEL:SetPlayer( ply )
    self:SetSize( ScrH() * 0.55, ScrH() * 0.6 )
    self:Center()
    self:MakePopup()

    self.Theme = GlorifiedHandcuffs.Themes.GetCurrent()

    self.TitleBar = vgui.Create( "GlorifiedHandcuffs.InteractionMenu.TitleBar", self )

    self.NameInfoBox = vgui.Create( "GlorifiedHandcuffs.InteractionMenu.InfoBox", self )
    self.NameInfoBox:SetLabelInfo( GlorifiedHandcuffs.i18n.GetPhrase( "name" ), ply:Nick(), self.Theme.Data.Colors.interactionMenuInfoBoxNameColor, self.Theme.Data.Colors.interactionMenuInfoBoxNameTextColor, self.Theme.Data.Materials.name )

    self.JobInfoBox = vgui.Create( "GlorifiedHandcuffs.InteractionMenu.InfoBox", self )
    self.JobInfoBox:SetLabelInfo( GlorifiedHandcuffs.i18n.GetPhrase( "job" ), team.GetName( ply:Team() ), team.GetColor( ply:Team() ), self.Theme.Data.Colors.interactionMenuInfoBoxJobTextColor, self.Theme.Data.Materials.briefcase )

    self.WalletInfoBox = vgui.Create( "GlorifiedHandcuffs.InteractionMenu.InfoBox", self )
    self.WalletInfoBox:SetLabelInfo( GlorifiedHandcuffs.i18n.GetPhrase( "wallet" ), GlorifiedHandcuffs.FormatMoney( GlorifiedHandcuffs.GetMoney( ply ) ), self.Theme.Data.Colors.interactionMenuInfoBoxWalletColor, self.Theme.Data.Colors.interactionMenuInfoBoxWalletTextColor, self.Theme.Data.Materials.money )

    self.WeaponsBox = vgui.Create( "GlorifiedHandcuffs.InteractionMenu.WeaponsBox", self )
    for k, v in pairs( ply:GetWeapons() ) do
        if not GlorifiedHandcuffs.Config.WEAPON_BLACKLIST_IS_WHITELIST and GlorifiedHandcuffs.Config.WEAPON_BLACKLIST[v:GetClass()] then continue end
        if GlorifiedHandcuffs.Config.WEAPON_BLACKLIST_IS_WHITELIST and not GlorifiedHandcuffs.Config.WEAPON_BLACKLIST[v:GetClass()] then continue end
       -- if ply.getJobTable and table.HasValue( ply:getJobTable().weapons or {}, v:GetClass() ) then continue end -- I need to table.HasValue here because of the retarded way DarkRP sets up the loadout.
        self.WeaponsBox:AddWeapon( v )
    end

    self.TopRowButtons = vgui.Create( "EditablePanel", self )
    self.TopRowButtons:Dock( TOP )
    self.TopRowButtons:SetTall( self:GetTall() / 12.5 )
    self.TopRowButtons:DockMargin( 15, 10, 15, 0 )
    self.TopRowButtons.PerformLayout = function( topRowButtons, w, h )
        self.ConfiscateAllButton:SetWide( w / 2 )
        self.ConfiscateIllegalButton:SetWide( w / 2 )
    end

    self.ConfiscateAllButton = vgui.Create( "DButton", self.TopRowButtons )
    self.ConfiscateAllButton:SetFont( "GlorifiedHandcuffs.InteractionMenu.BottomButtons" )
    self.ConfiscateAllButton:Dock( LEFT )
    self.ConfiscateAllButton:SetTextColor( self.Theme.Data.Colors.interactionMenuTopRowButtonsTextColor )
    self.ConfiscateAllButton:SetText( GlorifiedHandcuffs.IsPlayerPolice( LocalPlayer() ) and GlorifiedHandcuffs.i18n.GetPhrase( "confiscateAll" ) or GlorifiedHandcuffs.i18n.GetPhrase( "takeAll" ) )
    local confiscateAllColor = self.Theme.Data.Colors.interactionMenuTopRowButtonsButton
    local confiscateAllColorLerped = confiscateAllColor
    self.ConfiscateAllButton.Paint = function( confiscateAllButton, w, h )
        confiscateAllColorLerped = GlorifiedHandcuffs.UI.LerpColor( FrameTime() * 4, confiscateAllColorLerped, confiscateAllButton:IsHovered() and self.Theme.Data.Colors.interactionMenuTopRowButtonsButtonHover or self.Theme.Data.Colors.interactionMenuTopRowButtonsButton )
        draw.RoundedBox( 0, 0, 0, w - 2, h, confiscateAllColorLerped )
    end
    self.ConfiscateAllButton.DoClick = function()
        net.Start( "GlorifiedHandcuffs.InteractionMenu.StripAllWeapons" )
        net.WriteEntity( ply )
        net.SendToServer()
        GlorifiedHandcuffs.UI.CloseInteractionMenu()
    end

    self.ConfiscateIllegalButton = vgui.Create( "DButton", self.TopRowButtons )
    self.ConfiscateIllegalButton:SetFont( "GlorifiedHandcuffs.InteractionMenu.BottomButtons" )
    self.ConfiscateIllegalButton:Dock( LEFT )
    self.ConfiscateIllegalButton:SetTextColor( self.Theme.Data.Colors.interactionMenuTopRowButtonsTextColor )
    self.ConfiscateIllegalButton:SetText( GlorifiedHandcuffs.IsPlayerPolice( LocalPlayer() ) and GlorifiedHandcuffs.i18n.GetPhrase( "confiscateIllegal" ) or GlorifiedHandcuffs.i18n.GetPhrase( "takeIllegal" ) )
    local confiscateIllegalColor = self.Theme.Data.Colors.interactionMenuTopRowButtonsButton
    local confiscateIllegalColorLerped = confiscateIllegalColor
    self.ConfiscateIllegalButton.Paint = function( confiscateIllegalButton, w, h )
        confiscateIllegalColorLerped = GlorifiedHandcuffs.UI.LerpColor( FrameTime() * 4, confiscateIllegalColorLerped, confiscateIllegalButton:IsHovered() and self.Theme.Data.Colors.interactionMenuTopRowButtonsButtonHover or self.Theme.Data.Colors.interactionMenuTopRowButtonsButton )
        draw.RoundedBox( 0, 2, 0, w - 2, h, confiscateIllegalColorLerped )
    end
    self.ConfiscateIllegalButton.DoClick = function()
        net.Start( "GlorifiedHandcuffs.InteractionMenu.StripIllegalWeapons" )
        net.WriteEntity( ply )
        net.SendToServer()
        GlorifiedHandcuffs.UI.CloseInteractionMenu()
    end

    self.BottomRowButtons = vgui.Create( "EditablePanel", self )
    self.BottomRowButtons:Dock( TOP )
    self.BottomRowButtons:SetTall( self:GetTall() / 12.5 )
    self.BottomRowButtons:DockMargin( 15, 5, 15, 15 )
    self.BottomRowButtons.PerformLayout = function( bottomRowButtons, w, h )
        self.DragButton:SetWide( w / 3 )
        self.BlindfoldButton:SetWide( w / 3 )
        self.GagButton:SetWide( w / 3 )
    end

    self.DragButton = vgui.Create( "DButton", self.BottomRowButtons )
    self.DragButton:SetFont( "GlorifiedHandcuffs.InteractionMenu.BottomButtons" )
    self.DragButton:Dock( LEFT )
    self.DragButton:SetTextColor( self.Theme.Data.Colors.interactionMenuBottomRowButtonsTextColor )
    self.DragButton:SetText( "Sürükle" )
    local dragButtonColor = self.Theme.Data.Colors.interactionMenuBottomRowButtonsButton
    local dragButtonColorLerped = dragButtonColor
    self.DragButton.Paint = function( dragButton, w, h )
        dragButtonColorLerped = GlorifiedHandcuffs.UI.LerpColor( FrameTime() * 4, dragButtonColorLerped, dragButton:IsHovered() and self.Theme.Data.Colors.interactionMenuBottomRowButtonsButtonHover or self.Theme.Data.Colors.interactionMenuBottomRowButtonsButton )
        draw.RoundedBox( 0, 0, 0, w, h, dragButtonColorLerped )
    end
    self.DragButton.DoClick = function()
        net.Start( "GlorifiedHandcuffs.InteractionMenu.StartDraggingPlayer" )
        net.WriteEntity( ply )
        net.SendToServer()
        GlorifiedHandcuffs.UI.CloseInteractionMenu()
    end

    self.BlindfoldButton = vgui.Create( "DButton", self.BottomRowButtons )
    self.BlindfoldButton:SetFont( "GlorifiedHandcuffs.InteractionMenu.BottomButtons" )
    self.BlindfoldButton:Dock( LEFT )
    self.BlindfoldButton:SetTextColor( self.Theme.Data.Colors.interactionMenuBottomRowButtonsTextColor )
    self.BlindfoldButton:SetText( GlorifiedHandcuffs.IsPlayerBlindfolded( ply ) and GlorifiedHandcuffs.i18n.GetPhrase( "removeBlindfold" ) or GlorifiedHandcuffs.i18n.GetPhrase( "blindfoldPlayer" ) )
    local blindfoldButtonColor = self.Theme.Data.Colors.interactionMenuBottomRowButtonsButton
    local blindfoldButtonColorLerped = blindfoldButtonColor
    self.BlindfoldButton.Paint = function( blindfoldButton, w, h )
        blindfoldButtonColorLerped = GlorifiedHandcuffs.UI.LerpColor( FrameTime() * 4, blindfoldButtonColorLerped, blindfoldButton:IsHovered() and self.Theme.Data.Colors.interactionMenuBottomRowButtonsButtonHover or self.Theme.Data.Colors.interactionMenuBottomRowButtonsButton )
        draw.RoundedBox( 0, 4, 0, w - 2, h, blindfoldButtonColorLerped )
    end
    self.BlindfoldButton.DoClick = function()
        net.Start( "GlorifiedHandcuffs.InteractionMenu.TogglePlayerBlindfold" )
        net.WriteEntity( ply )
        net.SendToServer()
        GlorifiedHandcuffs.UI.CloseInteractionMenu()
    end

    self.GagButton = vgui.Create( "DButton", self.BottomRowButtons )
    self.GagButton:SetFont( "GlorifiedHandcuffs.InteractionMenu.BottomButtons" )
    self.GagButton:Dock( LEFT )
    self.GagButton:SetTextColor( self.Theme.Data.Colors.interactionMenuBottomRowButtonsTextColor )
    self.GagButton:SetText( GlorifiedHandcuffs.IsPlayerGagged( ply ) and GlorifiedHandcuffs.i18n.GetPhrase( "removeGag" ) or GlorifiedHandcuffs.i18n.GetPhrase( "gagPlayer" ) )
    local gagButtonColor = self.Theme.Data.Colors.interactionMenuBottomRowButtonsButton
    local gagButtonColorLerped = gagButtonColor
    self.GagButton.Paint = function( gagButton, w, h )
        gagButtonColorLerped = GlorifiedHandcuffs.UI.LerpColor( FrameTime() * 4, gagButtonColorLerped, gagButton:IsHovered() and self.Theme.Data.Colors.interactionMenuBottomRowButtonsButtonHover or self.Theme.Data.Colors.interactionMenuBottomRowButtonsButton )
        draw.RoundedBox( 0, 4, 0, w - 2, h, gagButtonColorLerped )
    end
    self.GagButton.DoClick = function()
        net.Start( "GlorifiedHandcuffs.InteractionMenu.TogglePlayerGagged" )
        net.WriteEntity( ply )
        net.SendToServer()
        GlorifiedHandcuffs.UI.CloseInteractionMenu()
    end

    self:SetAlpha( 0 )
    self:AlphaTo( 255, 0.3 )
end

function PANEL:Think()
    if input.IsKeyDown( KEY_ESCAPE ) then
        GlorifiedHandcuffs.UI.CloseInteractionMenu()
        RunConsoleCommand( "cancelselect" )
    end
end

function PANEL:Paint( w, h )
    draw.RoundedBox( 6, 0, 0, w, h, self.Theme.Data.Colors.interactionMenuBackgroundColor )
end

vgui.Register( "GlorifiedHandcuffs.InteractionMenu.Menu", PANEL, "EditablePanel" )

function GlorifiedHandcuffs.UI.OpenInteractionMenu( interactedPly )
    if not IsValid( LocalPlayer() ) then return end
    if not interactedPly then return end

    if IsValid( GlorifiedHandcuffs.UI.InteractionMenu ) then
        GlorifiedHandcuffs.UI.InteractionMenu:Remove()
        GlorifiedHandcuffs.UI.InteractionMenu = nil
    end

    GlorifiedHandcuffs.UI.InteractionMenu = vgui.Create( "GlorifiedHandcuffs.InteractionMenu.Menu" )
    GlorifiedHandcuffs.UI.InteractionMenu:SetPlayer( interactedPly )
end

function GlorifiedHandcuffs.UI.CloseInteractionMenu()
    if not GlorifiedHandcuffs.UI.InteractionMenu then return end

    GlorifiedHandcuffs.UI.InteractionMenu:AlphaTo( 0, 0.3, 0, function()
        if not GlorifiedHandcuffs.UI.InteractionMenu then return end
        GlorifiedHandcuffs.UI.InteractionMenu:Remove()
        GlorifiedHandcuffs.UI.InteractionMenu = nil
    end )
end

net.Receive( "GlorifiedHandcuffs.InteractionMenu.OpenInteractionMenu", function()
    GlorifiedHandcuffs.UI.OpenInteractionMenu( net.ReadEntity() )
end )
--addons/aphone/lua/weapons/aphone/cl_init.lua:
return gluapack()()
--addons/[binbon]arccw_modify/lua/weapons/arccw_base/cl_crosshair.lua:
return gluapack()()
--addons/[binbon]arccw_modify/lua/weapons/arccw_base/cl_laser.lua:
local mth        = math
local m_log10    = mth.log10
local m_rand     = mth.Rand
local rnd        = render
local SetMat     = rnd.SetMaterial
local DrawBeam   = rnd.DrawBeam
local DrawSprite = rnd.DrawSprite
local cam        = cam

local lasermat = Material("arccw/laser")
local flaremat = Material("effects/whiteflare")
local delta    = 1

function SWEP:DoLaser(world, nocontext)
    world = world or false

    if !nocontext then
        if world then
            cam.Start3D()
        else
            cam.Start3D(EyePos(), EyeAngles(), self:QuickFOVix(self.CurrentViewModelFOV))
        end
    end

    for slot, k in pairs(self.Attachments) do
        if !k.Installed then continue end

        local attach = ArcCW.AttachmentTable[k.Installed]

        if self:GetBuff_Stat("Laser", slot) then
            local color = self:GetBuff_Stat("LaserColor", slot) or attach.ColorOptionsTable[k.ColorOptionIndex or 1]

            if world then
                if !k.WElement then continue end
                self:DrawLaser(attach, k.WElement.Model, color, true)
            else
                if !k.VElement then continue end
                self:DrawLaser(attach, k.VElement.Model, color)
            end
        end
    end

    if self.Lasers then
        if world then
            for _, k in pairs(self.Lasers) do
                self:DrawLaser(k, self.WMModel or self, k.LaserColor, true)
            end
        else
            -- cam.Start3D(nil, nil, self.ViewmodelFOV)
            for _, k in pairs(self.Lasers) do
                self:DrawLaser(k, self:GetOwner():GetViewModel(), k.LaserColor)
            end
            -- cam.End3D()
        end
    end

    if !nocontext then
        cam.End3D()
    end
end

function SWEP:DrawLaser(laser, model, color, world)
    local owner = self:GetOwner()
    local behav = ArcCW.LaserBehavior

    if !owner then return end

    if !IsValid(owner) then return end

    if !model then return end

    if !IsValid(model) then return end

    local att = model:LookupAttachment(laser.LaserBone or "laser")

    att = att == 0 and model:LookupAttachment("muzzle") or att

    local pos, ang, dir

    if att == 0 then
        pos = model:GetPos()
        ang = owner:EyeAngles() + self:GetFreeAimOffset()
        dir = ang:Forward()
    else
        local attdata  = model:GetAttachment(att)
        pos, ang = attdata.Pos, attdata.Ang
        dir      = -ang:Right()
    end

    if world then
        dir = owner:IsNPC() and (-ang:Right()) or dir
    else
        ang:RotateAroundAxis(ang:Up(), 90)

        if self.LaserOffsetAngle then
            ang:RotateAroundAxis(ang:Right(), self.LaserOffsetAngle[1])
            ang:RotateAroundAxis(ang:Up(), self.LaserOffsetAngle[2])
            ang:RotateAroundAxis(ang:Forward(), self.LaserOffsetAngle[3])
        end
        if self.LaserIronsAngle and self:GetActiveSights().IronSight then
            local d = 1 - self:GetSightDelta()
            ang:RotateAroundAxis(ang:Right(), d * self.LaserIronsAngle[1])
            ang:RotateAroundAxis(ang:Up(), d * self.LaserIronsAngle[2])
            ang:RotateAroundAxis(ang:Forward(), d * self.LaserIronsAngle[3])
        end

        dir = ang:Forward()

        local eyeang   = EyeAngles() - self:GetOurViewPunchAngles() + self:GetFreeAimOffset()
        local canlaser = self:GetCurrentFiremode().Mode != 0 and !self:GetReloading() and self:BarrelHitWall() <= 0

        delta = Lerp(0, delta, canlaser and self:GetSightDelta() or 1)

        if self.GuaranteeLaser then
            delta = 1
        else
            delta = self:GetSightDelta()
        end

        dir = Lerp(delta, eyeang:Forward(), dir)
    end

    local beamdir, tracepos = dir, pos

    beamdir = world and (-ang:Right()) or beamdir

    if behav and !world then
        -- local cheap = ArcCW.ConVars["cheapscopes"]:GetBool()
        local punch = self:GetOurViewPunchAngles()

        ang = EyeAngles() - punch + self:GetFreeAimOffset()

        tracepos = EyePos() - Vector(0, 0, 1)
        pos, dir = tracepos, ang:Forward()
        beamdir  = dir
    end

    local dist = 128

    local tl = {}
    tl.start  = tracepos
    tl.endpos = tracepos + (dir * 33000)
    tl.filter = owner

    local tr = util.TraceLine(tl)

    tl.endpos = tracepos + (beamdir * dist)

    local btr = util.TraceLine(tl)

    local hit    = tr.Hit
    local hitpos = tr.HitPos
    local solid  = tr.StartSolid

    local strength = laser.LaserStrength or 1
    local laserpos = solid and tr.StartPos or hitpos

    laserpos = laserpos - ((EyeAngles() + self:GetFreeAimOffset()):Forward())

    if solid then return end

    local width = m_rand(0.05, 0.1) * strength * 1

    if (!behav or world) and hit then
        SetMat(lasermat)
        local a = 200
        DrawBeam(pos, btr.HitPos, width * 0.3, 1, 0, Color(a, a, a, a))
        DrawBeam(pos, btr.HitPos, width, 1, 0, color)
    end

    if hit and !tr.HitSky then
        local mul = 1 * strength
        mul = m_log10((hitpos - EyePos()):Length()) * strength
        local rad = m_rand(4, 6) * mul
        local glr = rad * m_rand(0.2, 0.3)

        SetMat(flaremat)

        -- if !world then
        --     cam.IgnoreZ(true)
        -- end
        DrawSprite(laserpos, rad, rad, color)
        DrawSprite(laserpos, glr, glr, color_white)

        -- if !world then
        --     cam.IgnoreZ(false)
        -- end
    end
end

--addons/[binbon]arccw_modify/lua/weapons/arccw_base/sh_bipod.lua:
function SWEP:InBipod()
    local bip = self:GetInBipod()

    -- if !self:CanBipod() then
    --     self:ExitBipod()
    -- end

    if IsValid(self:GetOwner()) and self:GetBipodPos() != self:GetOwner():EyePos() then
        self:ExitBipod()
    end

    return bip
end

SWEP.CachedCanBipod = true
SWEP.CachedCanBipodTime = 0

local dist = 24
function SWEP:CanBipod()
    if !(self:GetBuff_Override("Bipod") or self.Bipod_Integral) then return false end

    if self:GetOwner():InVehicle() then return false end

    if self.CachedCanBipodTime >= CurTime() then return self.CachedCanBipod end

    local pos = self:GetOwner():EyePos()
    local angle = self:GetOwner():EyeAngles()
    if self:GetOwner():GetVelocity():Length() > 0 then
        return false
    end

    local rangemult = 2
    if self:IsProne() then
        rangemult = rangemult * 1.25
    end
    rangemult = rangemult * self:GetBuff_Mult("Mult_BipodRange")

    local tr = util.TraceLine({
        start = pos,
        endpos = pos + (angle:Forward() * dist * rangemult),
        filter = self:GetOwner(),
        mask = MASK_PLAYERSOLID
    })

    if tr.Hit then -- check for stuff in front of us
        return false
    end

    local maxs = Vector(8, 8, 16)
    local mins = Vector(-8, -8, 0)

    angle.p = angle.p + 45

    tr = util.TraceHull({
        start = pos,
        endpos = pos + (angle:Forward() * dist * rangemult),
        filter = self:GetOwner(),
        maxs = maxs,
        mins = mins,
        mask = MASK_PLAYERSOLID
    })

    self.CachedCanBipodTime = CurTime()

    if tr.Hit then
        local tr2 = util.TraceHull({
            start = tr.HitPos,
            endpos = tr.HitPos + Vector(0, 0, -24),
            filter = self:GetOwner(),
            maxs = maxs,
            mins = mins,
            mask = MASK_PLAYERSOLID
        })
        if tr2.Hit then
            self.CachedCanBipod = true
            return true, tr2
        end
    end

    self.CachedCanBipod = false
    return false
end

function SWEP:EnterBipod(sp)
    if !sp and self:GetInBipod() then return end
    local can, tr = self:CanBipod()
    if !sp and !can then return end

    if SERVER and game.SinglePlayer() then self:CallOnClient("EnterBipod", "true") end

    if self.Animations.enter_bipod then
        self:PlayAnimation("enter_bipod", nil, nil, 0, true)
    else
        -- Block actions for a tiny bit even if there is no animation
        self:SetNextPrimaryFire(CurTime() + 0.25)
    end

    if CLIENT and self:GetBuff_Override("LHIK") then
        self:DoLHIKAnimation("enter")
    end

    local bipodang = tr.HitNormal:Cross(self:GetOwner():EyeAngles():Right()):Angle()

    debugoverlay.Axis(tr.HitPos, tr.HitNormal:Angle(), 16, 5, true)
    debugoverlay.Line(tr.HitPos, tr.HitPos + bipodang:Forward() * 32, 5, color_white, true)
    debugoverlay.Line(tr.HitPos, tr.HitPos + self:GetOwner():EyeAngles():Forward() * 32, 5, Color(255, 255, 0), true)

    self:SetBipodPos(self:GetOwner():EyePos())
    self:SetBipodAngle(bipodang)
    self.BipodStartAngle = self:GetOwner():EyeAngles()

    if game.SinglePlayer() and CLIENT then return end

    self:MyEmitSound(self.EnterBipodSound)
    self:SetInBipod(true)
end

function SWEP:ExitBipod(sp)
    if !sp and !self:GetInBipod() then return end

    if SERVER and game.SinglePlayer() then self:CallOnClient("ExitBipod", "true") end

    if self.Animations.exit_bipod then
        self:PlayAnimation("exit_bipod", nil, nil, 0, true)
    else
        self:SetNextPrimaryFire(CurTime() + 0.25)
    end

    if CLIENT and self:GetBuff_Override("LHIK") then
        self:DoLHIKAnimation("exit")
    end

    if game.SinglePlayer() and CLIENT then return end

    self:MyEmitSound(self.ExitBipodSound)
    self:SetInBipod(false)
end

--addons/[binbon]arccw_modify/lua/weapons/arccw_base/sh_ubgl.lua:
return gluapack()()
--lua/weapons/arccw_mcx.lua:
return gluapack()()
--lua/weapons/arccw_mw2_acr.lua:
return gluapack()()
--lua/weapons/arccw_mw2_anaconda.lua:
SWEP.Base = "arccw_mw2_abase"
SWEP.Spawnable = true
SWEP.Category = "ArcCW - MW2"
SWEP.AdminOnly = false
SWEP.WeaponCamBone = tag_camera

SWEP.PrintName = ".44 Magnum"
SWEP.Trivia_Class = "Handgun"
SWEP.Trivia_Desc = "Revolver."

SWEP.Slot = 1

SWEP.UseHands = true

SWEP.ViewModel = "models/weapons/arccw/fesiugmw2/c_anaconda.mdl"
SWEP.MirrorVMWM = true
SWEP.WorldModelOffset = {
    pos = Vector(-9, 3, -4),
    ang = Angle(-7, 0, 180),
    scale = 1.125
}
SWEP.WorldModel = "models/weapons/w_357.mdl"
SWEP.ViewModelFOV = 65

SWEP.Damage = 50
SWEP.DamageMin = 35
SWEP.RangeMin = 500 * 0.025  -- GAME UNITS * 0.025 = METRES
SWEP.Range = 1250 * 0.025  -- GAME UNITS * 0.025 = METRES
SWEP.Penetration = 12
SWEP.DamageType = DMG_BULLET
SWEP.ShootEntity = nil -- entity to fire, if any


SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 6 -- DefaultClip is automatically set.
SWEP.ExtendedClipSize = 9
SWEP.ReducedClipSize = 3

SWEP.VisualRecoilMult = 0
SWEP.Recoil = 0.80
SWEP.RecoilSide = 0.50
SWEP.RecoilRise = 0

SWEP.Delay = 0.08 -- 60 / RPM.
SWEP.Num = 1 -- number of shots per trigger pull.
SWEP.Firemodes = {
    {
		PrintName = "DACT",
        Mode = 1,
    },
    {
        Mode = 0,
    }
}

SWEP.NPCWeaponType = {"weapon_357"}
SWEP.NPCWeight = 100

SWEP.AccuracyMOA = 5 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 250 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 150

SWEP.Primary.Ammo = "357" -- what ammo type the gun uses

SWEP.ShootVol = 110 -- volume of shoot sound
SWEP.ShootPitch = 100 -- pitch of shoot sound

SWEP.ShootSound =			"weapons/fesiugmw2/fire/anaconda.wav"
--SWEP.DistantShootSound =	"weapons/fesiugmw2/fire_distant/anaconda.wav"
SWEP.ShootSoundSilenced =	"weapons/fesiugmw2/fire/usp45_sil.wav"

SWEP.MuzzleEffect = "muzzleflash_pistol_deagle"
SWEP.ShellModel = "models/shells/shell_9mm.mdl"
SWEP.ShellScale = 1

SWEP.MuzzleEffectAttachment = 1 -- which attachment to put the muzzle on
SWEP.CaseEffectAttachment = 2 -- which attachment to put the case effect on

SWEP.SpeedMult = 1
SWEP.SightedSpeedMult = 0.8
SWEP.SightTime = 0.125

SWEP.CaseBones = {
    [1] = "1",
    [2] = "2",
    [3] = "3",
    [4] = "4",
    [5] = "5",
    [6] = "6",
}

SWEP.IronSightStruct = {
    Pos = Vector(-1.6, 2.134, 0.518),
    Ang = Angle(-0.358, 0, 0),
    ViewModelFOV = 65,
    Magnification = 1,
}

SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "revolver"
SWEP.HoldtypeSights = "revolver"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_REVOLVER

SWEP.ActivePos = Vector(0, 0, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.CustomizePos = Vector(13.92, 1, -1.08)
SWEP.CustomizeAng = Angle(6.8, 37.7, 10.3)

SWEP.HolsterPos = Vector(1, 0, 1)
SWEP.HolsterAng = Angle(-10, 12, 0)

SWEP.SprintPos = Vector(0, 0, 1)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.BarrelOffsetSighted = Vector(0, 0, -1)
SWEP.BarrelOffsetHip = Vector(2, 0, -2)

SWEP.BarrelLength = 18

SWEP.ExtraSightDist = 5

-----[ Tactical knife sheet ]------
	SWEP.CanBash				= true -- Tac knife will save us
	--SWEP.MeleeDamage			= 100
	--SWEP.MeleeRange				= 16
	--SWEP.MeleeDamageType		= DMG_CLUB
	--SWEP.MeleeTime				= 0.8
	SWEP.MeleeGesture			= ACT_HL2MP_GESTURE_RANGE_ATTACK_KNIFE
	--SWEP.MeleeAttackTime		= 0.079
	SWEP.MeleeMissSound			= ""
	SWEP.MeleeHitSound			= "MW2Common.Melee.HitWorld"
	SWEP.MeleeHitNPCSound		= "MW2Common.Melee.HitFleshy_Slice"

SWEP.AttachmentElements = {
    ["altirons"] = {
        Override_IronSightStruct = {
			Pos = Vector(-1.7, 0, -0.7),
			Ang = Angle(-0.358, 0, 0),
            ViewModelFOV = 65,
            Magnification = 1,
        }
    },
    ["wepcamo-desert"]		= { VMSkin = 1 },
    ["wepcamo-arctic"]		= { VMSkin = 2 },
    ["wepcamo-woodland"]	= { VMSkin = 3 },
    ["wepcamo-digital"]		= { VMSkin = 4 },
    ["wepcamo-urban"]		= { VMSkin = 5 },
    ["wepcamo-bluetiger"]	= { VMSkin = 6 },
    ["wepcamo-redtiger"]	= { VMSkin = 7 },
    ["wepcamo-fall"]		= { VMSkin = 8 },
    ["wepcamo-whiteout"]	= { VMSkin = 9 },
    ["wepcamo-blackout"]        = { VMSkin = 10 },
    ["wepcamo-bushdweller"]     = { VMSkin = 11 },
    ["wepcamo-thunderstorm"]    = { VMSkin = 12 },
}

SWEP.Hook_SelectReloadAnimation = function(wep, anim)
    if wep.Attachments[3].Installed == "mw2_tacticalknife" then
        return anim .. "_knife"
    end
end
SWEP.Hook_TranslateAnimation = function(wep, anim)
    if wep.Attachments[3].Installed == "mw2_tacticalknife" then
        return anim .. "_knife"
    end
end

SWEP.Attachments = {
    {
        PrintName = "Optic",
        DefaultAttName = "Iron Sights",
        Slot = "optic_lp",
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(2.5, 0, 2.313),
            vang = Angle(0, 0, 0),
            wang = Angle(-1.783, -22.088, -170.842),
        },
        ExcludeFlags = {"arcticfixyoshit1"},
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Standard Muzzle",
        Slot = "muzzle",
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(9.8, 0, 1.45),
            vang = Angle(0, 0, 0),
            wpos = Vector(14.692, 5.258, -4.367),
            wang = Angle(-0.884, -22.088, 180),
        },
    },
    {
        PrintName = "Underbarrel",
        Slot = {"foregrip_pistol", "style_pistol", "mw2_tacknife"},
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(3.5, 0, -0.5),
            vang = Angle(0, 0, 0),
            wpos = Vector(7.374, 3.032, -2.007),
            wang = Angle(-1.783, -22.088, -170.842),
        },
    },
    {
        PrintName = "Tactical",
        Slot = "tac",
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(7.6285, 0, 0.666),
            vang = Angle(0, 0, 0),
            wang = Angle(-1.783, -22.088, -170.842),
            wmax = Vector(9.826, 3.565, -3.132),
        },
    },
    {
        PrintName = "Fire Group",
        Slot = "fcg",
        DefaultAttName = "Standard FCG"
    },
    {
        PrintName = "Ammo Type",
        Slot = "ammo_bullet"
    },
    {
        PrintName = "Perk",
        Slot = {"perk", "perk_revolver"}
    },
    {
        PrintName = "Camouflage",
        DefaultAttName = "None",
        Slot = "mw2_wepcamo",
        FreeSlot = true,
    },
}

SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
        Time = 2/30
    },
    ["enter_sprint"] = {
        Source = "sprint_in",
        Time = 10/30
    },
    ["idle_sprint"] = {
        Source = "sprint_loop",
        Time = 30/40
    },
    ["exit_sprint"] = {
        Source = "sprint_out",
        Time = 10/30
    },
    ["draw"] = {
        Source = "pullout",
        Time = 29/30 /4,
        SoundTable = {{s = "MW2Common.Deploy", 		t = 0}},
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0.35,
    },
    ["holster"] = {
        Source = "putaway",
        Time = 33/30 /4,
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0.35,
    },
    ["fire"] = {
        Source = "fire",
        Time = 12/30,
    },
    ["fire_iron"] = {
        Source = "fire_ads",
        Time = 12/30,
    },
    ["reload"] = {
        Source = "reload",
        Time = 92/30,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_REVOLVER,
        SoundTable = {
						{s = "weapons/fesiugmw2/foley/wpfoly_anaconda_reload_lift_v1.wav", 		t = 0/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_anaconda_reload_clipout_v1.wav", 	t = 20/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_anaconda_reload_clipin_v1.wav", 	t = 50/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_anaconda_reload_chamber_v1.wav", 	t = 66/30},
					},
        Checkpoints = {24, 97, 131},
        FrameRate = 37,
        LHIK = true,
        LHIKIn = 0.5,
        LHIKOut = 0.6,
        LastClip1OutTime = 1.5,
    },
---------------------------------------------------------
--------- LE TACTICAL KNIFE XDXDXDXD---------------------
---------------------------------------------------------
		["idle_knife"] = {
			Source = "idle_knife",
			Time = 300/30
		},
		["enter_sprint_knife"] = {
			Source = "sprint_in_knife",
			Time = 10/30
		},
		["idle_sprint_knife"] = {
			Source = "sprint_loop_knife",
			Time = 30/40
		},
		["exit_sprint_knife"] = {
			Source = "sprint_out_knife",
			Time = 10/30
		},
		["fire_knife"] = {
			Source = "fire_knife",
			Time = 12/30,
		},
		["fire_iron_knife"] = {
			Source = "fire_ads_knife",
			Time = 12/30,
		},
		["draw_knife"] = {
			Source = "pullout_knife",
			SoundTable = {{s = "MW2Common.Deploy", 		t = 0}},
			Time = 29/30 /4,
			LHIK = true,
			LHIKIn = 0,
			LHIKOut = 0.35,
		},
		["holster_knife"] = {
			Source = "putaway_knife",
			Time = 33/30 /4,
			LHIK = true,
			LHIKIn = 0,
			LHIKOut = 0.35,
		},
		["reload_knife"] = {
			Source = "reload_knife",
			Time = 92/30,
			TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
			SoundTable = {
						{s = "weapons/fesiugmw2/foley/wpfoly_anaconda_reload_lift_v1.wav", 		t = 0/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_anaconda_reload_clipout_v1.wav", 	t = 20/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_anaconda_reload_clipin_v1.wav", 	t = 50/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_anaconda_reload_chamber_v1.wav", 	t = 67/30},
						},
			Checkpoints = {24, 97},
			FrameRate = 30,
			LHIK = true,
			LHIKIn = 0.5,
			LHIKOut = 0.4,
		},
		["bash_knife"] = {
			Source = "melee_knife",
			SoundTable = {{s = "MW2Common.Melee.Swing", 		t = 0}},
			Time = 97/120 / 1.6, -- damn you universal
			LHIK = true,
		},
}
--lua/weapons/arccw_mw2_g17.lua:
return gluapack()()
--lua/weapons/arccw_mw2_m1014.lua:
SWEP.Base = "arccw_mw2_abase"
SWEP.Spawnable = true
SWEP.Category = "ArcCW - MW2"
SWEP.AdminOnly = false
SWEP.WeaponCamBone = tag_camera

SWEP.PrintName = "M1014"
SWEP.Trivia_Class = "Shotgun"
SWEP.Trivia_Desc = "Semi-automatic (single fire)"

SWEP.Slot = 2

SWEP.UseHands = true

SWEP.ViewModel = "models/weapons/arccw/fesiugmw2/c_benelli_5.mdl"
SWEP.MirrorVMWM = true
SWEP.WorldModelOffset = {
    pos = Vector(-4, 3, -5),
    ang = Angle(-10, 0, 180),
    scale = 1.125
}
SWEP.WorldModel = "models/weapons/w_shot_xm1014.mdl"
SWEP.ViewModelFOV = 65

SWEP.Damage = 40
SWEP.DamageMin = 20
SWEP.Range = 500 * 0.025  -- GAME UNITS * 0.025 = METRES
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.ShootEntity = nil -- entity to fire, if any


SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 4 -- DefaultClip is automatically set.
SWEP.ExtendedClipSize = 6
SWEP.ReducedClipSize = 2

SWEP.VisualRecoilMult = 0
SWEP.MaxRecoilBlowback = 0
SWEP.Recoil = 5
SWEP.RecoilSide = 1
SWEP.RecoilPunch = 1

SWEP.ShotgunReload = true

SWEP.Delay = 0.2 -- 60 / RPM.
SWEP.Num = 8 -- number of shots per trigger pull.
SWEP.Firemodes = {
    {
        Mode = 1,
    },
    {
        Mode = 0
    }
}

SWEP.NPCWeaponType = "weapon_shotgun"
SWEP.NPCWeight = 100

SWEP.AccuracyMOA = 100 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 300 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 150

SWEP.Primary.Ammo = "buckshot" -- what ammo type the gun uses

SWEP.ShootVol = 120 -- volume of shoot sound
SWEP.ShootPitch = 100 -- pitch of shoot sound

SWEP.ShootSound =			"weapons/fesiugmw2/fire/shot_m1014.wav"
--SWEP.DistantShootSound =	"weapons/fesiugmw2/fire_distant/shot_m1014.wav"
SWEP.ShootSoundSilenced =	"weapons/fesiugmw2/fire/shot_sil.wav"

SWEP.MuzzleEffect = "muzzleflash_m3"
SWEP.ShellModel = "models/shells/shell_12gauge.mdl"
SWEP.ShellPitch = 100
SWEP.ShellSounds = ArcCW.ShotgunShellSoundsTable
SWEP.ShellScale = 1
SWEP.ShellRotateAngle = Angle(0, 90, 0)

SWEP.MuzzleEffectAttachment = 1 -- which attachment to put the muzzle on
SWEP.CaseEffectAttachment = 2 -- which attachment to put the case effect on

SWEP.SpeedMult = 1
SWEP.SightedSpeedMult = 0.4
SWEP.SightTime = 0.3

SWEP.BulletBones = { -- the bone that represents bullets in gun/mag
    -- [0] = "bulletchamber",
    -- [1] = "bullet1"
}

SWEP.IronSightStruct = {
    Pos = Vector(-2.816, -4.9, 1.39),
    Ang = Angle(0.1, 0, 0),
    ViewModelFOV = 65 / 1.18,
    Magnification = 1.18,
}


SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "shotgun"
SWEP.HoldtypeSights = "ar2"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN

SWEP.ActivePos = Vector(0, 0, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.CustomizePos = Vector(5.479, -3, 0.321)
SWEP.CustomizeAng = Angle(6.2, 29.4, 14.8)

SWEP.HolsterPos = Vector(1, 0, 1)
SWEP.HolsterAng = Angle(-10, 12, 0)

SWEP.SprintPos = Vector(0, 0, 1)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.BarrelOffsetSighted = Vector(0, 0, -1)
SWEP.BarrelOffsetHip = Vector(2, 0, -2)

SWEP.ExtraSightDist = 5
SWEP.Bipod_Integral = true

SWEP.AttachmentElements = {
    ["grip"] = {
        VMBodygroups = {{ind = 1, bg = 1}},
        WMBodygroups = {},
    },
    ["wepcamo-desert"]		= { VMSkin = 1 },
    ["wepcamo-arctic"]		= { VMSkin = 2 },
    ["wepcamo-woodland"]	= { VMSkin = 3 },
    ["wepcamo-digital"]		= { VMSkin = 4 },
    ["wepcamo-urban"]		= { VMSkin = 5 },
    ["wepcamo-bluetiger"]	= { VMSkin = 6 },
    ["wepcamo-redtiger"]	= { VMSkin = 7 },
    ["wepcamo-fall"]		= { VMSkin = 8 },
    ["wepcamo-whiteout"]	= { VMSkin = 9 },
    ["wepcamo-blackout"]        = { VMSkin = 10 },
    ["wepcamo-bushdweller"]     = { VMSkin = 11 },
    ["wepcamo-thunderstorm"]    = { VMSkin = 12 },
}

SWEP.Attachments = {
	{
        PrintName = "Optic",
        DefaultAttName = "Iron Sights",
        Slot = "optic",
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(-0.6, 0, 1.7),
            vang = Angle(0, 0, 0),
            wang = Angle(-9.738, 0, 180)
        },
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Standard Muzzle",
        Slot = "muzzle_shotgun",
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(18, 0, 0.7),
            vang = Angle(0, 0, 0),
            wpos = Vector(26.648, 0.782, -8.042),
            wang = Angle(-9.79, 0, 180)
        },
		VMScale = Vector(1.25, 1.25, 1.25),
    },
    {
        PrintName = "Underbarrel",
        Slot = {"foregrip", "foregrip_mw2exclusive"},
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(5, 0, -1.5),
            vang = Angle(0, 0, 0),
            wpos = Vector(14.329, 0.602, -4.453),
            wang = Angle(-10.216, 0, 180)
        },
    },
    {
        PrintName = "Tactical",
        Slot = "tac",
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(6, -1, -0.6),
            vang = Angle(0, 0, 90),
            wpos = Vector(15.625, -0.253, -6.298),
            wang = Angle(-8.829, -0.556, 90)
        },
        SlideAmount = {
            vmin = Vector(4, -1, -0.6),
            vmax = Vector(9.5, -1, -0.6),
        },
    },
    {
        PrintName = "Fire Group",
        Slot = "fcg",
        DefaultAttName = "Standard FCG"
    },
    {
        PrintName = "Ammo Type",
        Slot = "ammo_shotgun"
    },
    {
        PrintName = "Perk",
        Slot = "perk"
    },
    {
        PrintName = "Camouflage",
        DefaultAttName = "None",
        Slot = "mw2_wepcamo",
        FreeSlot = true,
    },
	{
        PrintName = "Charm",
        Slot = "charm",
        FreeSlot = true,
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(0, -0.5, -0.25),
            vang = Angle(0, 0, 0),
            wpos = Vector(9.625, 1.5, -4),
            wang = Angle(0, 0, 180)
        },
    },
}

SWEP.Hook_TranslateAnimation = function(wep, anim)
    if wep.Attachments[3].Installed then
        return anim .. "_fgrip"
    end
end

SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
        Time = 1/300,
    },
    ["enter_sprint"] = {
        Source = "sprint_in",
        Time = 10/30
    },
    ["idle_sprint"] = {
        Source = "sprint_loop",
        Time = 30/40
    },
    ["exit_sprint"] = {
        Source = "sprint_out",
        Time = 10/30
    },
    ["draw"] = {
        Source = "pullout",
        Time = 32/30,
        SoundTable = {{s = "MW2Common.Deploy", 		t = 0}},
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0.9,
    },
    ["holster"] = {
        Source = "putaway",
        Time = 29/30,
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0.9,
    },
    ["fire"] = {
        Source = "fire",
        Time = 13/30,
        ShellEjectAt = 0,
    },
    ["fire_iron"] = {
        Source = "fire_ads",
        Time = 14/30,
        ShellEjectAt = 0,
    },
    ["sgreload_start"] = {
        Source = "reload_start",
        Time = 30/30,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SHOTGUN,
        SoundTable = {
                        {s = "weapons/fesiugmw2/foley/wpfoly_m4ben_reload_lift_v1.wav", 		t = 0},
                        {s = "weapons/fesiugmw2/foley/wpfoly_m4ben_reload_loop_v1.wav", 		t = 17/30},
                    },
		RestoreAmmo = 1, -- only used by shotgun empty insert reload
        LHIK = true,
        LHIKIn = 0.5,
        LHIKOut = 0,
    },
    ["sgreload_insert"] = {
        Source = "reload_loop",
        Time = 17/30,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SHOTGUN,
        SoundTable = {
                        {s = "weapons/fesiugmw2/foley/wpfoly_m4ben_reload_loop_v1.wav", 		t = 3/30},
                    },
        TPAnimStartTime = 0.3,
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0,
    },
    ["sgreload_finish"] = {
        Source = "reload_finish",
        Time = 11/30,
        SoundTable = {
                        {s = "weapons/fesiugmw2/foley/wpfoly_m4ben_reload_end_v1.wav", 		t = 0.01},
                    },
        LHIK = true,
        LHIKIn = 0.4,
        LHIKOut = 0.4,
    },
    ["sgreload_finish_empty"] = {
        Source = "reload_finish",
        Time = 11/30,
        SoundTable = {
                        {s = "weapons/fesiugmw2/foley/wpfoly_m4ben_reload_end_v1.wav", 		t = 0.01},
                    },
        LHIK = true,
        LHIKIn = 0.4,
        LHIKOut = 0.4,
    },
---------------------------------------------
    ["idle_fgrip"] = {
        Source = "idle_fgrip",
        Time = 1/300,
    },
    ["enter_sprint_fgrip"] = {
        Source = "sprint_in_fgrip",
        Time = 10/30
    },
    ["idle_sprint_fgrip"] = {
        Source = "sprint_loop_fgrip",
        Time = 30/40
    },
    ["exit_sprint_fgrip"] = {
        Source = "sprint_out_fgrip",
        Time = 10/30
    },
    ["draw_fgrip"] = {
        Source = "pullout_fgrip",
        Time = 32/30,
        SoundTable = {{s = "MW2Common.Deploy", 		t = 0}},
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0.9,
    },
    ["holster_fgrip"] = {
        Source = "putaway_fgrip",
        Time = 29/30,
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0.9,
    },
    ["fire_fgrip"] = {
        Source = "fire_fgrip",
        Time = 13/30,
        ShellEjectAt = 0,
    },
    ["fire_iron_fgrip"] = {
        Source = "fire_ads_fgrip",
        Time = 14/30,
        ShellEjectAt = 0,
    },
    ["sgreload_start_fgrip"] = {
        Source = "reload_start_fgrip",
        Time = 30/30,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SHOTGUN,
        SoundTable = {
                        {s = "weapons/fesiugmw2/foley/wpfoly_m4ben_reload_lift_v1.wav", 		t = 0},
                        {s = "weapons/fesiugmw2/foley/wpfoly_m4ben_reload_loop_v1.wav", 		t = 17/30},
                    },
		RestoreAmmo = 1, -- only used by shotgun empty insert reload
        LHIK = true,
        LHIKIn = 0.5,
        LHIKOut = 0,
    },
    ["sgreload_insert_fgrip"] = {
        Source = "reload_loop_fgrip",
        Time = 17/30,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SHOTGUN,
        SoundTable = {
                        {s = "weapons/fesiugmw2/foley/wpfoly_m4ben_reload_loop_v1.wav", 		t = 3/30},
                    },
        TPAnimStartTime = 0.3,
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0,
    },
    ["sgreload_finish_fgrip"] = {
        Source = "reload_finish_fgrip",
        Time = 11/30,
        SoundTable = {
                        {s = "weapons/fesiugmw2/foley/wpfoly_m4ben_reload_end_v1.wav", 		t = 0.01},
                    },
        LHIK = true,
        LHIKIn = 0.4,
        LHIKOut = 0.4,
    },
    ["sgreload_finish_empty_fgrip"] = {
        Source = "reload_finish_fgrip",
        Time = 11/30,
        SoundTable = {
                        {s = "weapons/fesiugmw2/foley/wpfoly_m4ben_reload_end_v1.wav", 		t = 0.01},
                    },
        LHIK = true,
        LHIKIn = 0.4,
        LHIKOut = 0.4,
    },
}

 -- Super fucky temp!
 -- S H U T  U P    A N D   K E E P  T H E M   P I N N E D  D O W N  

-- notverycreativenowarewe
local nvcnaw = 5

 -- hipfire
 -- maximum accuracy
    SWEP.Inaccuracy_Hip_Max_Stand	= nvcnaw
    SWEP.Inaccuracy_Hip_Max_Duck	= nvcnaw
    SWEP.Inaccuracy_Hip_Max_Prone	= nvcnaw
 -- minimum accuracy
    SWEP.Inaccuracy_Hip_Min_Stand   = nvcnaw
    SWEP.Inaccuracy_Hip_Min_Duck    = nvcnaw
    SWEP.Inaccuracy_Hip_Min_Prone   = nvcnaw

 -- sighted fire
 -- yeah
    SWEP.Inaccuracy_ADS = 5.5

 -- inaccuracy when you're... i don't remember
SWEP.Inaccuracy_Add_ADS			= 0
SWEP.Inaccuracy_Add_Hip			= 0
SWEP.Inaccuracy_Add_Move		= 0.1
--lua/weapons/arccw_mw2_m1887.lua:
SWEP.Base = "arccw_mw2_abase"
SWEP.Spawnable = true
SWEP.Category = "ArcCW - MW2"
SWEP.AdminOnly = false
SWEP.CamAttachment = 3

SWEP.PrintName = "Model 1887"
SWEP.Trivia_Class = "Shotgun"
SWEP.Trivia_Desc = "Lever-action."

SWEP.Slot = 2

SWEP.UseHands = true

SWEP.ViewModel = "models/weapons/arccw/fesiugmw2_2/c_m1887_1.mdl"
SWEP.MirrorVMWM = true
SWEP.WorldModelOffset = {
    pos = Vector(-4, 3, -6),
    ang = Angle(-10, 0, 180),
    scale = 1.125
}
SWEP.WorldModel = "models/weapons/w_shotgun.mdl"
SWEP.ViewModelFOV = 65

SWEP.Damage = 40
SWEP.DamageMin = 20
SWEP.Range = 700 * 0.025  -- GAME UNITS * 0.025 = METRES
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.ShootEntity = nil -- entity to fire, if any


SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 7 -- DefaultClip is automatically set.
SWEP.ExtendedClipSize = 7
SWEP.ReducedClipSize = 4

SWEP.VisualRecoilMult = 0
SWEP.Recoil = 3
SWEP.RecoilSide = 3

SWEP.ShotgunReload = true
SWEP.ManualAction = true

SWEP.Delay = 12/30 -- 60 / RPM.
SWEP.Num = 8 -- number of shots per trigger pull.
SWEP.Firemodes = {
    {
        PrintName = "lever",
        Mode = 1,
    },
    {
        Mode = 0,
    },
}

SWEP.NPCWeaponType = "weapon_shotgun"
SWEP.NPCWeight = 100

SWEP.AccuracyMOA = 100 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 250 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50 -- inaccuracy added by moving. Applies in sights as well! Walking speed is considered as "maximum".
SWEP.SightsDispersion = 0 -- dispersion that remains even in sights

SWEP.Primary.Ammo = "buckshot" -- what ammo type the gun uses

SWEP.ShootVol = 120 -- volume of shoot sound
SWEP.ShootPitch = 110 -- pitch of shoot sound

SWEP.ShootSound =			"weapons/fesiugmw2/fire/shot_w1200.wav"
--SWEP.DistantShootSound =	"weapons/fesiugmw2/fire_distant/shot_ranger.wav"
SWEP.ShootSoundSilenced =	"weapons/fesiugmw2/fire/shot_sil.wav"

SWEP.MuzzleEffect = "muzzleflash_m3"
SWEP.ShellModel = "models/shells/shell_12gauge.mdl"
SWEP.ShellPitch = 100
SWEP.ShellSounds = ArcCW.ShotgunShellSoundsTable
SWEP.ShellScale = 1
SWEP.ShellRotateAngle = Angle(0, 90, 0)

SWEP.MuzzleEffectAttachment = 1 -- which attachment to put the muzzle on
SWEP.CaseEffectAttachment = 2 -- which attachment to put the case effect on

SWEP.SpeedMult = 1
SWEP.SightedSpeedMult = 0.8
SWEP.SightTime = 0.3

SWEP.BulletBones = { -- the bone that represents bullets in gun/mag
    -- [0] = "bulletchamber",
    -- [1] = "bullet1"
}

SWEP.IronSightStruct = {
    Pos = Vector(-3.07, -1.8, 1.8),
    Ang = Angle(0, 0, 0),
    ViewModelFOV = 65 / 1.18,
    Magnification = 1.18,
}


SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "shotgun"
SWEP.HoldtypeSights = "ar2"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN

SWEP.ActivePos = Vector(0, 0, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.CustomizePos = Vector(5.479, -5, -1.321)
SWEP.CustomizeAng = Angle(18.2, 39.4, 14.8)

SWEP.HolsterPos = Vector(1, 0, 1)
SWEP.HolsterAng = Angle(-10, 12, 0)

SWEP.SprintPos = Vector(0, 0, 1)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.BarrelOffsetSighted = Vector(0, 0, -1)
SWEP.BarrelOffsetHip = Vector(2, 0, -2)

SWEP.ExtraSightDist = 5

SWEP.AttachmentElements = {
    ["nors"] = {
        VMBodygroups = {{ind = 2, bg = 1}},
        WMBodygroups = {},
    },
}

SWEP.Attachments = {
	{
        PrintName = "Optic",
        DefaultAttName = "Iron Sights",
        Slot = "optic",
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(8, 0, 2.95),
            vang = Angle(0, 0, 0),
            wang = Angle(-9.738, 0, 180)
        },
        ExcludeFlags = {"arcticfixyoshit1","cantuseshitinakimboyet"},
        InstalledEles = {"nors"},
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Standard Muzzle",
        Slot = "muzzle_shotgun",
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(26, 0, 2.23),
            vang = Angle(0, 0, 0),
            wpos = Vector(26.648, 0.782, -8.042),
            wang = Angle(-9.79, 0, 180)
        },
        ExcludeFlags = {"arcticfixyoshit1","cantuseshitinakimboyet"},
    },
    {
        PrintName = "Underbarrel",
        Slot = {"foregrip"},
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(0, 0, -0.7),
            vang = Angle(0, 0, 0),
            wpos = Vector(14.329, 0.602, -4.453),
            wang = Angle(-10.216, 0, 180)
        },
        SlideAmount = {
            vmin = Vector(6, 0, 0.5),
            vmax = Vector(12, 0, 0.5),
        },
        MergeSlots = {7},
    },
    {
        PrintName = "Tactical",
        Slot = "tac",
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(14, -0.8, 1.75),
            vang = Angle(0, 0, 90),
            wpos = Vector(15.625, -0.253, -6.298),
            wang = Angle(-8.829, -0.556, 90)
        },
		VMScale = Vector(1, 1, 1),
    },
    {
        PrintName = "Ammo Type",
        Slot = "ammo_shotgun"
    },
    {
        PrintName = "Perk",
        Slot = "perk"
    },
    {
        PrintName = "Akimbotest",
        DefaultAttName = "No LH",
        Slot = "akimbotest",
        Bone = "tag_view",
        Offset = {
            vpos = Vector(0, 0, 0),
            vang = Angle(0, 0, 0),
        },
        Hidden = true,
    },
	{
        PrintName = "Charm",
        Slot = "charm",
        FreeSlot = true,
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(2.5, -0.45, 0.75),
            vang = Angle(0, 0, 0),
            wpos = Vector(9.625, 1.5, -4),
            wang = Angle(0, 0, 180)
        },
    },
}

SWEP.Hook_SelectReloadAnimation = function(wep, anim)
    if wep.Attachments[7].Installed then
        return anim .. "_akimbo_right"
    end
end
SWEP.Hook_TranslateAnimation = function(wep, anim)
    if wep.Attachments[7].Installed then
        return anim .. "_akimbo_right"
    end
end

SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
        Time = 1/30,
    },
    ["enter_sprint"] = {
        Source = "sprint_in",
        Time = 10/30
    },
    ["idle_sprint"] = {
        Source = "sprint_loop",
        Time = 30/40
    },
    ["exit_sprint"] = {
        Source = "sprint_out",
        Time = 10/30
    },
    ["ready"] = {
        Source = "pullout_first",
        Time = 47/30,
        SoundTable = {
                        {s = "MW2Common.Deploy",                                            t = 0},
						{s = "weapons/fesiugmw2/foley/wpfoly_m1887_reload_lift_v1.wav", 	t = 0/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_m1887_reload_open_v1.wav", 	t = 12/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_m1887_reload_close_v1.wav", 	t = 24/30},
					},
    },
    ["draw"] = {
        Source = "pullout",
        Time = 25/30,
        SoundTable = {{s = "MW2Common.Deploy", 		t = 0}},
    },
    ["holster"] = {
        Source = "putaway",
        Time = 25/30,
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0.9,
    },
    ["fire"] = {
        Source = "fire",
        Time = 12/30,
		MinProgress = 0.433,
    },
    ["fire_iron"] = {
        Source = "fire_ads",
        Time = 12/30,
		MinProgress = 0.433,
    },
    ["cycle"] = {
        Source = "rechamber",
        Time = 35/30,
		MinProgress = 0.85,
        SoundTable = {
						{s = "weapons/fesiugmw2/foley/wpfoly_m1887_reload_lift_v1.wav", 	t = 0/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_m1887_reload_open_v1.wav", 	t = 6/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_m1887_reload_close_v1.wav", 	t = 16/30},
					},
    },
    ["cycle_iron"] = {
        Source = "rechamber_ads",
        Time = 35/30,
		MinProgress = 0.85,
        SoundTable = {
						{s = "weapons/fesiugmw2/foley/wpfoly_m1887_reload_lift_v1.wav", 	t = 0/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_m1887_reload_open_v1.wav", 	t = 6/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_m1887_reload_close_v1.wav", 	t = 16/30},
					},
    },
    ["sgreload_start"] = {
        Source = "reload_start",
        Time = 59/30,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SHOTGUN,
		RestoreAmmo = 1, -- loads a shell since the first reload has a shell in animation
        SoundTable = {
						{s = "weapons/fesiugmw2/foley/wpfoly_m1887_reload_lift_v1.wav", 	t = 0/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_m1887_reload_open_v1.wav", 	t = 8/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_m1887_reload_shell_v1.wav", 	t = 53/30},
					},
		MinProgress = 1.45,
    },
    ["sgreload_insert"] = {
        Source = "reload_loop",
        Time = 33/40,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SHOTGUN,
        SoundTable = {{s = "weapons/fesiugmw2/foley/wpfoly_m1887_reload_shell_v1.wav", 		t = 27/40}},
        TPAnimStartTime = 0.3,
		MinProgress = 0.6,
    },
    ["sgreload_finish"] = {
        Source = "reload_finish",
        Time = 41/30,
        SoundTable = {
						{s = "weapons/fesiugmw2/foley/wpfoly_m1887_reload_close_v1.wav", 	t = 15/30},
					},
    },
-- akimbo
    ["idle_akimbo_right"] = {
        Source = "idle_r",
        Time = 1/30,
    },
    ["enter_sprint_akimbo_right"] = {
        Source = "sprint_in_r",
        Time = 10/30
    },
    ["idle_sprint_akimbo_right"] = {
        Source = "sprint_loop_r",
        Time = 30/40
    },
    ["exit_sprint_akimbo_right"] = {
        Source = "sprint_out_r",
        Time = 10/30
    },
    ["ready_akimbo_right"] = {
        Source = "pullout_first_r",
        Time = 47/30,
        SoundTable = {
                        {s = "MW2Common.Deploy",                                            t = 0},
						{s = "weapons/fesiugmw2/foley/wpfoly_m1887_reload_lift_v1.wav", 	t = 0/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_m1887_reload_open_v1.wav", 	t = 7/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_m1887_reload_close_v1.wav", 	t = 23/30},
					},
    },
    ["draw_akimbo_right"] = {
        Source = "pullout_r",
        Time = 25/30,
        SoundTable = {{s = "MW2Common.Deploy", 		t = 0}},
    },
    ["holster_akimbo_right"] = {
        Source = "putaway_r",
        Time = 25/30,
    },
    ["fire_akimbo_right"] = {
        Source = "fire_r",
        Time = 12/30,
		MinProgress = 0.433,
    },
    ["cycle_akimbo_right"] = {
        Source = "rechamber_r",
        Time = 35/30,
		MinProgress = 0.85,
        SoundTable = {
						{s = "weapons/fesiugmw2/foley/wpfoly_m1887_reload_lift_v1.wav", 	t = 0/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_m1887_reload_open_v1.wav", 	t = 6/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_m1887_reload_close_v1.wav", 	t = 16/30},
					},
    },
    ["sgreload_start_akimbo_right"] = {
        Source = "reload_start_r",
        Time = 59/30,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SHOTGUN,
		RestoreAmmo = 1, -- loads a shell since the first reload has a shell in animation
        SoundTable = {
						{s = "weapons/fesiugmw2/foley/wpfoly_m1887_reload_lift_v1.wav", 	t = 0/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_m1887_reload_open_v1.wav", 	t = 14/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_m1887_reload_shell_v1.wav", 	t = 54/30},
					},
		MinProgress = 1.45,
    },
    ["sgreload_insert_akimbo_right"] = {
        Source = "reload_loop_r",
        Time = 33/40,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SHOTGUN,
        SoundTable = {{s = "weapons/fesiugmw2/foley/wpfoly_m1887_reload_shell_v1.wav", 		t = 18/40}},
        TPAnimStartTime = 0.3,
		MinProgress = 0.6,
    },
    ["sgreload_finish_akimbo_right"] = {
        Source = "reload_finish_r",
        Time = 41/30,
        SoundTable = {
						{s = "weapons/fesiugmw2/foley/wpfoly_m1887_reload_close_v1.wav", 	t = 15/30},
					},
    },
}

 -- Super fucky temp!
 -- S H U T  U P    A N D   K E E P  T H E M   P I N N E D  D O W N  

-- notverycreativenowarewe
local nvcnaw = 4

 -- hipfire
 -- maximum accuracy
    SWEP.Inaccuracy_Hip_Max_Stand	= nvcnaw
    SWEP.Inaccuracy_Hip_Max_Duck	= nvcnaw
    SWEP.Inaccuracy_Hip_Max_Prone	= nvcnaw
 -- minimum accuracy
    SWEP.Inaccuracy_Hip_Min_Stand   = nvcnaw
    SWEP.Inaccuracy_Hip_Min_Duck    = nvcnaw
    SWEP.Inaccuracy_Hip_Min_Prone   = nvcnaw

 -- sighted fire
 -- yeah
    SWEP.Inaccuracy_ADS = 5.5

 -- inaccuracy when you're... i don't remember
SWEP.Inaccuracy_Add_ADS			= 0
SWEP.Inaccuracy_Add_Hip			= 0
SWEP.Inaccuracy_Add_Move		= 0.1
--lua/weapons/arccw_mw2_m240.lua:
return gluapack()()
--lua/weapons/arccw_mw2_masterkey.lua:
return gluapack()()
--lua/weapons/arccw_mw2_scarl.lua:
return gluapack()()
--lua/weapons/arccw_mw2_steyr.lua:
SWEP.Base = "arccw_mw2_abase"
SWEP.Spawnable = true
SWEP.Category = "ArcCW - MW2"
SWEP.AdminOnly = false
SWEP.WeaponCamBone = tag_camera

SWEP.PrintName = "AUG"
SWEP.Trivia_Class = "Assault Rifle"
SWEP.Trivia_Desc = "Fully automatic, all purpose weapon."

SWEP.Slot = 2

SWEP.UseHands = true

SWEP.ViewModel = "models/weapons/arccw/fesiugmw2/c_steyr.mdl"
SWEP.MirrorVMWM = true
SWEP.WorldModelOffset = {
    pos = Vector(-6.5, 3, -5),
    ang = Angle(-10, 0, 180),
    scale = 1.125
}
SWEP.WorldModel = "models/weapons/w_rif_aug.mdl"
SWEP.ViewModelFOV = 65

SWEP.DefaultBodygroups = "100000"

SWEP.Damage = 30
SWEP.DamageMin = 20
SWEP.Range = 1300 * 0.025  -- GAME UNITS * 0.025 = METRES
SWEP.Penetration = 7
SWEP.DamageType = DMG_BULLET
SWEP.ShootEntity = nil -- entity to fire, if any


SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 30 -- DefaultClip is automatically set.
SWEP.ExtendedClipSize = 45
SWEP.ReducedClipSize = 15

SWEP.VisualRecoilMult = 0
SWEP.Recoil = 0.5
SWEP.RecoilSide = 0.4
SWEP.RecoilRise = 0

SWEP.Delay = 0.065 -- lazy, fix this l8r btich -- 60 / RPM.
SWEP.Num = 1 -- number of shots per trigger pull.
SWEP.Firemodes = {
    {
        Mode = 2,
    },
    {
        Mode = 1,
    },
    {
        Mode = 0,
    },
}

SWEP.NPCWeaponType = {"weapon_ar2", "weapon_smg1"}
SWEP.NPCWeight = 100

SWEP.AccuracyMOA = 5 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 500 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 250

SWEP.Primary.Ammo = "smg1" -- what ammo type the gun uses

SWEP.ShootVol = 110 -- volume of shoot sound
SWEP.ShootPitch = 105 -- pitch of shoot sound

SWEP.ShootSound =			"weapons/fesiugmw2/fire/aug.wav"
SWEP.ShootMechSound =       ArcCW_MW2_Mech
--SWEP.DistantShootSound =	"weapons/fesiugmw2/fire_distant/aug.wav"
SWEP.ShootDrySound =        "weapons/fesiugmw2/fire/dryfire_rifle.wav"
SWEP.ShootSoundSilenced =	"weapons/fesiugmw2/fire/m4_sil.wav"

SWEP.MuzzleEffect = "muzzleflash_4"
SWEP.ShellModel = "models/shells/shell_556.mdl"
SWEP.ShellPitch = 95
SWEP.ShellScale = 1
SWEP.ShellRotateAngle = Angle(0, 90, 0)

SWEP.MuzzleEffectAttachment = 1 -- which attachment to put the muzzle on
SWEP.CaseEffectAttachment = 2 -- which attachment to put the case effect on

SWEP.SpeedMult = 0.875
SWEP.SightedSpeedMult = 0.35
SWEP.SightTime = 0.350

SWEP.BulletBones = { -- the bone that represents bullets in gun/mag
    -- [0] = "bulletchamber",
    -- [1] = "bullet1"
}

SWEP.IronSightStruct = {
    Pos = Vector(-3.04, -6.026, 0.68),
    Ang = Angle(0.203, 0, 0),
    ViewModelFOV = 65 / 1.3,
    Magnification = 1.3,
}

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "smg"
SWEP.HoldtypeSights = "rpg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, 0, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.CustomizePos = Vector(10.479, 0, -1.321)
SWEP.CustomizeAng = Angle(18.2, 39.4, 14.8)

SWEP.HolsterPos = Vector(1, 0, 1)
SWEP.HolsterAng = Angle(-10, 12, 0)

SWEP.SprintPos = Vector(0, 0, 1)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.BarrelOffsetSighted = Vector(0, 0, -1)
SWEP.BarrelOffsetHip = Vector(2, 0, -2)

SWEP.BarrelLength = 27

SWEP.ExtraSightDist = 5

SWEP.Attachments = {
    {
        PrintName = "Optic",
        DefaultAttName = "Iron Sights",
        Slot = {"optic","mw2_steyrrearsight"},
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(6.972, 0, 4.018),
            vang = Angle(0, 0, 0),
            wang = Angle(-9.738, 0, 180)
        },
        SlideAmount = {
            vmin = Vector(0, 0, 3.5),
            vmax = Vector(3, 0, 3.5),
        },
        InstalledEles = {"nors"},
        MergeSlots = {2},
    },
    {
        Slot = "mw2_augscope",
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(1.6, 0, 2.3),
            vang = Angle(0, 0, 0),
            wpos = Vector(0, 0, 0),
            wang = Angle(0, 0, 0)
        },
        Hidden = true,
        InstalledEles = {"norail", "nors"},
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Standard Muzzle",
        Slot = "muzzle",
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(13.7, 0, 1.7),
            vang = Angle(0, 0, 0),
            wpos = Vector(33.719, -2.122, -5.573),
            wang = Angle(0, 6.034, 180)
        },
    },
    {
        PrintName = "Underbarrel",
        Slot = {"foregrip", "bipod", "foregrip_mw2exclusive"},
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(6, 0, 0.4),
            vang = Angle(0, 0, 0),
            wpos = Vector(14.329, 0.602, -4.453),
            wang = Angle(-2.461, -6.525, 176.662)
        },
        Installed = "foregrip_exclusive",
    },
    {
        PrintName = "Tactical",
        Slot = "tac",
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(-2, -0.5, 2),
            vang = Angle(0, 0, 135),
            wpos = Vector(15.625, -0.253, -6.298),
            wang = Angle(-8.829, -0.556, 90)
        },
    },
    {
        PrintName = "Fire Group",
        Slot = "fcg",
        DefaultAttName = "Standard FCG"
    },
    {
        PrintName = "Ammo Type",
        Slot = "ammo_bullet"
    },
    {
        PrintName = "Perk",
        Slot = "perk"
    },
    {
        PrintName = "Camouflage",
        DefaultAttName = "None",
        Slot = "mw2_wepcamo",
        FreeSlot = true,
    },
	{
        PrintName = "Charm",
        Slot = "charm",
        FreeSlot = true,
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(0, -0.8, 1),
            vang = Angle(0, 0, 0),
            wpos = Vector(9.625, 1.5, -4),
            wang = Angle(0, 0, 180)
        },
    },
}

SWEP.AttachmentElements = {
    ["norail"] = {
        VMBodygroups = {{ind = 3, bg = 1}},
    },
    ["nors"] = {
        VMBodygroups = {{ind = 2, bg = 1}},
    },
    ["optic_mw2_mp5krearsight"] = { VMBodygroups = {{ind = 2, bg = 0}} },
    ["grip"] = { VMBodygroups = {{ind = 1, bg = 1}} },
    ["wepcamo-desert"]		= { VMSkin = 1 },
    ["wepcamo-arctic"]		= { VMSkin = 2 },
    ["wepcamo-woodland"]	= { VMSkin = 3 },
    ["wepcamo-digital"]		= { VMSkin = 4 },
    ["wepcamo-urban"]		= { VMSkin = 5 },
    ["wepcamo-bluetiger"]	= { VMSkin = 6 },
    ["wepcamo-redtiger"]	= { VMSkin = 7 },
    ["wepcamo-fall"]		= { VMSkin = 8 },
    ["wepcamo-whiteout"]	= { VMSkin = 9 },
    ["wepcamo-blackout"]        = { VMSkin = 10 },
    ["wepcamo-bushdweller"]     = { VMSkin = 11 },
    ["wepcamo-thunderstorm"]    = { VMSkin = 12 },
}

SWEP.Hook_TranslateAnimation = function(wep, anim)
	local attached = wep.Attachments[4].Installed
	
	-- m203 is 1, masterkey is 2, fgrip is 3
	local attthing
		if 		attached 							then attthing = 3
		else 											 attthing = 0
	end
	
    if attthing == 3 then
        return anim .. "_fgrip"
    end
end

SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
        Time = 1/30
    },
    ["enter_sprint"] = {
        Source = "sprint_in",
        Time = 11/30
    },
    ["idle_sprint"] = {
        Source = "sprint_loop",
        Time = 31/40
    },
    ["exit_sprint"] = {
        Source = "sprint_out",
        Time = 11/30
    },
    ["draw"] = {
        Source = "pullout",
        Time = 26/30,
        SoundTable = {{s = "MW2Common.Deploy", 		t = 0}},
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0.9,
    },
    ["holster"] = {
        Source = "putaway",
        Time = 16/30,
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0.9,
    },
    ["ready"] = {
        Source = "pullout_first",
        Time = 36/30,
        SoundTable = {
						{s = "weapons/fesiugmw2/foley/wpfoly_styaug_reload_chamber_v1.wav", 	t = 9/30},
					},
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0.25,
    },
    ["fire"] = {
        Source = "fire",
        Time = 6/30,
        ShellEjectAt = 0,
    },
    ["fire_iron"] = {
        Source = "fire_ads",
        Time = 6/30,
        ShellEjectAt = 0,
    },
    ["reload"] = {
        Source = "reload",
        Time = 102/35,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
						{s = "weapons/fesiugmw2/foley/wpfoly_styaug_reload_lift_v1.wav", 		t = 0},
						{s = "weapons/fesiugmw2/foley/wpfoly_styaug_reload_clipout_v1.wav", 	t = 30/35},
						{s = "weapons/fesiugmw2/foley/wpfoly_styaug_reload_clipin_v1.wav", 		t = 71/35},
					},
        LHIK = true,
        LHIKIn = 0.5,
        LHIKOut = 0.5,
    },
    ["reload_empty"] = {
        Source = "reload_empty",
        Time = 121/35,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
						{s = "weapons/fesiugmw2/foley/wpfoly_styaug_reload_lift_v1.wav", 		t = 0},
						{s = "weapons/fesiugmw2/foley/wpfoly_styaug_reload_clipout_v1.wav", 	t = 30/35},
						{s = "weapons/fesiugmw2/foley/wpfoly_styaug_reload_clipin_v1.wav", 		t = 71/35},
						{s = "weapons/fesiugmw2/foley/wpfoly_styaug_reload_chamber_v1.wav",		t = 89/35},
					},
        LHIK = true,
        LHIKIn = 0.5,
        LHIKOut = 0.6,
    },
------------------------------------------------
------ Here lies foregrip animations. awesome --
------------------------------------------------
    ["idle_fgrip"] = {
        Source = "idle_fgrip",
        Time = 1/30
    },
    ["enter_sprint_fgrip"] = {
        Source = "sprint_in_fgrip",
        Time = 11/30
    },
    ["idle_sprint_fgrip"] = {
        Source = "sprint_loop_fgrip",
        Time = 31/40
    },
    ["exit_sprint_fgrip"] = {
        Source = "sprint_out_fgrip",
        Time = 11/30
    },
    ["draw_fgrip"] = {
        Source = "pullout_fgrip",
        Time = 26/30,
        SoundTable = {{s = "MW2Common.Deploy", 		t = 0}},
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0.9,
    },
    ["holster_fgrip"] = {
        Source = "putaway_fgrip",
        Time = 16/30,
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0.9,
    },
    ["ready_fgrip"] = {
        Source = "pullout_first_fgrip",
        Time = 36/30,
        SoundTable = {
						{s = "weapons/fesiugmw2/foley/wpfoly_styaug_reload_chamber_v1.wav", 	t = 13/30},
					},
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0.25,
    },
    ["fire_fgrip"] = {
        Source = "fire_fgrip",
        Time = 6/30,
        ShellEjectAt = 0,
    },
    ["fire_iron_fgrip"] = {
        Source = "fire_ads_fgrip",
        Time = 6/30,
        ShellEjectAt = 0,
    },
    ["reload_fgrip"] = {
        Source = "reload_fgrip",
        Time = 102/35,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
						{s = "weapons/fesiugmw2/foley/wpfoly_styaug_reload_lift_v1.wav", 		t = 0},
						{s = "weapons/fesiugmw2/foley/wpfoly_styaug_reload_clipout_v1.wav", 	t = 30/35},
						{s = "weapons/fesiugmw2/foley/wpfoly_styaug_reload_clipin_v1.wav", 		t = 71/35},
					},
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.7,
    },
    ["reload_empty_fgrip"] = {
        Source = "reload_empty_fgrip",
        Time = 121/35,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
						{s = "weapons/fesiugmw2/foley/wpfoly_styaug_reload_lift_v1.wav", 		t = 0},
						{s = "weapons/fesiugmw2/foley/wpfoly_styaug_reload_clipout_v1.wav", 	t = 30/35},
						{s = "weapons/fesiugmw2/foley/wpfoly_styaug_reload_clipin_v1.wav", 		t = 71/35},
						{s = "weapons/fesiugmw2/foley/wpfoly_styaug_reload_chamber_v1.wav",		t = 89/35},
					},
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.7,
    },
}
--lua/weapons/arccw_mw2_steyr_lmg.lua:
SWEP.Base = "arccw_mw2_steyr"
SWEP.Spawnable = true
SWEP.Category = "ArcCW - MW2"
SWEP.AdminOnly = false
SWEP.WeaponCamBone = tag_camera

SWEP.PrintName = "AUG HBAR"
SWEP.Trivia_Class = "Light Machine Gun"
SWEP.Trivia_Desc = "Fully automatic, high accuracy and damage."

SWEP.Slot = 2

SWEP.UseHands = true

SWEP.ViewModel = "models/weapons/arccw/fesiugmw2/c_steyr.mdl"
SWEP.MirrorVMWM = true
SWEP.WorldModelOffset = {
    pos = Vector(-6.5, 3, -5),
    ang = Angle(-10, 0, 180),
    scale = 1.125
}
SWEP.WorldModel = "models/weapons/w_rif_aug.mdl"
SWEP.ViewModelFOV = 65

SWEP.DefaultBodygroups = "000000"

SWEP.Damage = 40
SWEP.DamageMin = 40
SWEP.Range = 1400 * 0.025  -- GAME UNITS * 0.025 = METRES

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 42 -- DefaultClip is automatically set.
SWEP.ExtendedClipSize = 63
SWEP.ReducedClipSize = 21

SWEP.Delay = 0.087 -- 60 / RPM.

SWEP.NPCWeaponType = {"weapon_ar2", "weapon_smg1"}
SWEP.NPCWeight = 100

SWEP.AccuracyMOA = 1.6 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 700 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 250

SWEP.Primary.Ammo = "smg1" -- what ammo type the gun uses

SWEP.ShootVol = 110 -- volume of shoot sound
SWEP.ShootPitch = 100 -- pitch of shoot sound

SWEP.ShootSound =			"weapons/fesiugmw2/fire/aug.wav"
SWEP.ShootMechSound =       ArcCW_MW2_Mech
--SWEP.DistantShootSound =	"weapons/fesiugmw2/fire_distant/aug.wav"
SWEP.ShootDrySound =        "weapons/fesiugmw2/fire/dryfire_rifle.wav"
SWEP.ShootSoundSilenced =	"weapons/fesiugmw2/fire/m240_sil.wav"

SWEP.SpeedMult = 0.875
SWEP.SightedSpeedMult = 0.35
SWEP.SightTime = 0.350

SWEP.BarrelLength = 32

SWEP.Attachments = {
    {
        PrintName = "Optic",
        DefaultAttName = "Iron Sights",
        Slot = {"optic","mw2_steyrrearsight"},
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(6.972, 0, 4.018),
            vang = Angle(0, 0, 0),
            wang = Angle(-9.738, 0, 180)
        },
        SlideAmount = {
            vmin = Vector(0, 0, 3.5),
            vmax = Vector(3, 0, 3.5),
        },
        InstalledEles = {"nors"},
        MergeSlots = {2},
    },
    {
        Slot = "mw2_augscope",
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(1.6, 0, 2.3),
            vang = Angle(0, 0, 0),
            wpos = Vector(0, 0, 0),
            wang = Angle(0, 0, 0)
        },
        Hidden = true,
        InstalledEles = {"norail", "nors"},
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Standard Muzzle",
        Slot = "muzzle",
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(20.1, 0, 1.7),
            vang = Angle(0, 0, 0),
            wpos = Vector(33.719, -2.122, -5.573),
            wang = Angle(0, 6.034, 180)
        },
    },
    {
        PrintName = "Underbarrel",
        Slot = {"foregrip", "foregrip_mw2exclusive"},
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(6, 0, 0.4),
            vang = Angle(0, 0, 0),
            wpos = Vector(14.329, 0.602, -4.453),
            wang = Angle(-2.461, -6.525, 176.662)
        },
    },
    {
        PrintName = "Tactical",
        Slot = "tac",
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(-2, -0.5, 2),
            vang = Angle(0, 0, 135),
            wpos = Vector(15.625, -0.253, -6.298),
            wang = Angle(-8.829, -0.556, 90)
        },
    },
    {
        PrintName = "Fire Group",
        Slot = "fcg",
        DefaultAttName = "Standard FCG"
    },
    {
        PrintName = "Ammo Type",
        Slot = "ammo_bullet"
    },
    {
        PrintName = "Perk",
        Slot = "perk"
    },
    {
        PrintName = "Camouflage",
        DefaultAttName = "None",
        Slot = "mw2_wepcamo",
        FreeSlot = true,
    },
	{
        PrintName = "Charm",
        Slot = "charm",
        FreeSlot = true,
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(0, -0.8, 1),
            vang = Angle(0, 0, 0),
            wpos = Vector(9.625, 1.5, -4),
            wang = Angle(0, 0, 180)
        },
    },
}

SWEP.AttachmentElements = {
    ["norail"] = {
        VMBodygroups = {{ind = 3, bg = 1}},
    },
    ["nors"] = {
        VMBodygroups = {{ind = 2, bg = 1}},
    },
    ["optic_mw2_mp5krearsight"] = { VMBodygroups = {{ind = 2, bg = 0}} },
    ["grip"] = { VMBodygroups = {{ind = 1, bg = 1}} },
    ["wepcamo-desert"]		= { VMSkin = 1 },
    ["wepcamo-arctic"]		= { VMSkin = 2 },
    ["wepcamo-woodland"]	= { VMSkin = 3 },
    ["wepcamo-digital"]		= { VMSkin = 4 },
    ["wepcamo-urban"]		= { VMSkin = 5 },
    ["wepcamo-bluetiger"]	= { VMSkin = 6 },
    ["wepcamo-redtiger"]	= { VMSkin = 7 },
    ["wepcamo-fall"]		= { VMSkin = 8 },
    ["wepcamo-whiteout"]	= { VMSkin = 9 },
    ["wepcamo-blackout"]        = { VMSkin = 10 },
    ["wepcamo-bushdweller"]     = { VMSkin = 11 },
    ["wepcamo-thunderstorm"]    = { VMSkin = 12 },
}

SWEP.Bipod_Integral = true

SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
        Time = 1/30
    },
    ["enter_sprint"] = {
        Source = "sprint_in",
        Time = 11/30
    },
    ["idle_sprint"] = {
        Source = "sprint_loop",
        Time = 31/40
    },
    ["exit_sprint"] = {
        Source = "sprint_out",
        Time = 11/30
    },
    ["draw"] = {
        Source = "pullout",
        Time = 26/30,
        SoundTable = {{s = "MW2Common.Deploy", 		t = 0}},
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0.9,
    },
    ["holster"] = {
        Source = "putaway",
        Time = 16/30,
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0.9,
    },
    ["ready"] = {
        Source = "pullout_first",
        Time = 36/30,
        SoundTable = {
						{s = "weapons/fesiugmw2/foley/wpfoly_styaug_reload_chamber_v1.wav", 	t = 9/30},
					},
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0.25,
    },
    ["fire"] = {
        Source = "fire",
        Time = 6/30,
        ShellEjectAt = 0,
    },
    ["fire_iron"] = {
        Source = "fire_ads",
        Time = 6/30,
        ShellEjectAt = 0,
    },
    ["reload"] = {
        Source = "reload",
        Time = 102/30,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
						{s = "weapons/fesiugmw2/foley/wpfoly_styaug_reload_lift_v1.wav", 		t = 0},
						{s = "weapons/fesiugmw2/foley/wpfoly_styaug_reload_clipout_v1.wav", 	t = 30/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_styaug_reload_clipin_v1.wav", 		t = 71/30},
					},
        LHIK = true,
        LHIKIn = 0.5,
        LHIKOut = 0.5,
    },
    ["reload_empty"] = {
        Source = "reload_empty",
        Time = 121/30,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
						{s = "weapons/fesiugmw2/foley/wpfoly_styaug_reload_lift_v1.wav", 		t = 0},
						{s = "weapons/fesiugmw2/foley/wpfoly_styaug_reload_clipout_v1.wav", 	t = 30/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_styaug_reload_clipin_v1.wav", 		t = 71/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_styaug_reload_chamber_v1.wav",		t = 89/30},
					},
        LHIK = true,
        LHIKIn = 0.5,
        LHIKOut = 0.6,
    },
------------------------------------------------
------ Here lies foregrip animations. awesome --
------------------------------------------------
    ["idle_fgrip"] = {
        Source = "idle_fgrip",
        Time = 1/30
    },
    ["enter_sprint_fgrip"] = {
        Source = "sprint_in_fgrip",
        Time = 11/30
    },
    ["idle_sprint_fgrip"] = {
        Source = "sprint_loop_fgrip",
        Time = 31/40
    },
    ["exit_sprint_fgrip"] = {
        Source = "sprint_out_fgrip",
        Time = 11/30
    },
    ["draw_fgrip"] = {
        Source = "pullout_fgrip",
        Time = 26/30,
        SoundTable = {{s = "MW2Common.Deploy", 		t = 0}},
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0.9,
    },
    ["holster_fgrip"] = {
        Source = "putaway_fgrip",
        Time = 16/30,
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0.9,
    },
    ["ready_fgrip"] = {
        Source = "pullout_first_fgrip",
        Time = 36/30,
        SoundTable = {
						{s = "weapons/fesiugmw2/foley/wpfoly_styaug_reload_chamber_v1.wav", 	t = 13/30},
					},
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0.25,
    },
    ["fire_fgrip"] = {
        Source = "fire_fgrip",
        Time = 6/30,
        ShellEjectAt = 0,
    },
    ["fire_iron_fgrip"] = {
        Source = "fire_ads_fgrip",
        Time = 6/30,
        ShellEjectAt = 0,
    },
    ["reload_fgrip"] = {
        Source = "reload_fgrip",
        Time = 102/30,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
						{s = "weapons/fesiugmw2/foley/wpfoly_styaug_reload_lift_v1.wav", 		t = 0},
						{s = "weapons/fesiugmw2/foley/wpfoly_styaug_reload_clipout_v1.wav", 	t = 30/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_styaug_reload_clipin_v1.wav", 		t = 71/30},
					},
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.7,
    },
    ["reload_empty_fgrip"] = {
        Source = "reload_empty_fgrip",
        Time = 121/30,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
						{s = "weapons/fesiugmw2/foley/wpfoly_styaug_reload_lift_v1.wav", 		t = 0},
						{s = "weapons/fesiugmw2/foley/wpfoly_styaug_reload_clipout_v1.wav", 	t = 30/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_styaug_reload_clipin_v1.wav", 		t = 71/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_styaug_reload_chamber_v1.wav",		t = 89/30},
					},
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.7,
    },
}
--lua/weapons/arccw_mw2_tmp.lua:
return gluapack()()
--lua/weapons/arccw_myt_uc_scar.lua:
SWEP.Base = "arccw_base"
SWEP.Spawnable = true
SWEP.Category = "ArcCW - Urban Coalition"
SWEP.UC_CategoryPack = "9Urban Expedition"
SWEP.AdminOnly = false
SWEP.UseHands = true

-- Muzzle and shell effects --

SWEP.MuzzleEffect = "muzzleflash_1"
SWEP.ShellModel = "models/weapons/arccw/uc_shells/556x45.mdl"
SWEP.ShellScale = 1.145
SWEP.ShellPitch = 100
SWEP.UC_ShellColor = Color(0.7*255, 0.2*255, 0.2*255)

SWEP.MuzzleEffectAttachment = 1
SWEP.CaseEffectAttachment = 2
SWEP.CamAttachment = 3
SWEP.TracerNum = 1
SWEP.TracerCol = Color(25, 255, 25)
SWEP.TracerWidth = 2

-- Fake name --

SWEP.PrintName = "Osckée 21"
-- True name --
SWEP.TrueName = "SCAR-H"

-- Trivia --

SWEP.Trivia_Class = "Battle Rifle"
SWEP.Trivia_Desc = [[
A highly modular rifle platform designed to be used by expeditionary forces. Configurable for urban combat, marksmanship, and more.

This alteration is permanently half baked in sun light.
]]
SWEP.Trivia_Calibre = "7.62x51mm NATO"
SWEP.Trivia_Country = "Wallonia" -- massive funny
SWEP.Trivia_Manufacturer = "Héristal van Hoog-Zert"  -- /Haut-Sart/ why are they speaking fake Dutch with French grammar?
SWEP.Trivia_Year = 2004

-- Weapon slot --

SWEP.Slot = 2

-- Weapon's manufacturer real name --

if GetConVar("arccw_truenames"):GetBool() then
    SWEP.PrintName = SWEP.TrueName
    SWEP.Trivia_Manufacturer = "FN Herstal"
    SWEP.Trivia_Country = "Belgium"
end

-- Viewmodel / Worldmodel / FOV --

SWEP.ViewModel = "models/weapons/arccw/c_uc_myt_scar.mdl"
SWEP.WorldModel = "models/weapons/arccw/c_uc_myt_scar.mdl"
SWEP.ViewModelFOV = 70
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

-- Damage --

SWEP.Damage = ArcCW.UC.StdDmg["762_51"].max
SWEP.DamageMin = ArcCW.UC.StdDmg["762_51"].min
SWEP.RangeMin = 50
SWEP.Range = 400
SWEP.Penetration = ArcCW.UC.StdDmg["762_51"].pen
SWEP.DamageType = DMG_BULLET
SWEP.ShootEntity = nil
SWEP.MuzzleVelocity = ArcCW.UC.StdDmg["762_51"].vel
SWEP.PhysBulletMuzzleVelocity = ArcCW.UC.StdDmg["762_51"].vel

SWEP.BodyDamageMults = ArcCW.UC.BodyDamageMults

-- Mag size --

SWEP.chreleaseSize = 1
SWEP.Primary.ClipSize = 20
SWEP.ExtendedClipSize = 30
SWEP.ReducedClipSize = 10

-- Recoil --

SWEP.Recoil = 1.1
SWEP.RecoilSide = 0.7

SWEP.RecoilRise = 0.1
SWEP.RecoilPunch = 1
SWEP.VisualRecoilMult = 1
SWEP.MaxRecoilBlowback = 1
SWEP.MaxRecoilPunch = 1
SWEP.RecoilPunchpull = 1

SWEP.Sway = 0.5

-- Firerate / Firemodes --

SWEP.Delay = 60 / 600
SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 2,
    },
    {
        Mode = 1,
    },
    {
        Mode = 0
    }
}

SWEP.ShootPitch = 100
SWEP.ShootVol = 120
SWEP.ShootPitchVariation = 0

SWEP.ProceduralRegularFire = false
SWEP.ProceduralIronFire = false

SWEP.ReloadInSights = true

-- NPC --

SWEP.NPCWeaponType = "weapon_ar2"
SWEP.NPCWeight = 60

-- Accuracy --

SWEP.AccuracyMOA = 3.5
SWEP.HipDispersion = 750
SWEP.MoveDispersion = 220
SWEP.JumpDispersion = 1000

SWEP.Primary.Ammo = "ar2"

-- Speed multipliers --

SWEP.SpeedMult = 0.925
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.5
SWEP.ShootSpeedMult = 0.9

-- Length --

SWEP.BarrelLength = 48
SWEP.ExtraSightDist = 7

-- Ironsights / Customization / Poses --

SWEP.HolsterPos = Vector(0.5, 8, -0.5)
SWEP.HolsterAng = Angle(-10, 8, -15)

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"

SWEP.IronSightStruct = {
     Pos = Vector(-3.71, 3, 0.51),
     Ang = Angle(0, 0, 0),
     Magnification = 1.1,
     SwitchToSound = "",
}

SWEP.ActivePos = Vector(0, 7, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.CustomizePos = Vector(0, 5, -2)
SWEP.CustomizeAng = Angle(10, 0, 0)

SWEP.CrouchPos = Vector(-1, 5, -0.25)
SWEP.CrouchAng = Angle(0, 0, -14)

SWEP.BarrelOffsetHip = Vector(2, 0, -5)

SWEP.MirrorVMWM = true
SWEP.WorldModelOffset = {
    pos        =    Vector(-3, 4, -8),
    ang        =    Angle(-6, 0, 180),
    bone    =    "ValveBiped.Bip01_R_Hand",
}

-- Firing sounds --

local path = ")weapons/uc_osk/"
local common = ")/arccw_uc/common/"
local rottle = {common .. "cloth_1.ogg", common .. "cloth_2.ogg", common .. "cloth_3.ogg", common .. "cloth_4.ogg", common .. "cloth_5.ogg", common .. "cloth_6.ogg", common .. "rattle.ogg"}
local mech = {path .. "mech-01.ogg", path .. "mech-02.ogg", path .. "mech-03.ogg", path .. "mech-04.ogg", path .. "mech-05.ogg", path .. "mech-06.ogg"}
local ratel = {common .. "rattle1.ogg", common .. "rattle2.ogg", common .. "rattle3.ogg"}
local rutle = {common .. "movement-rifle-01.ogg", common .. "movement-rifle-02.ogg", common .. "movement-rifle-03.ogg", common .. "movement-rifle-04.ogg"}
local magdrop = {common .. "rifle_magdrop_1.ogg", common .. "rifle_magdrop_2.ogg", common .. "rifle_magdrop_3.ogg", common .. "rifle_magdrop_4.ogg"}
--SWEP.FirstShootSound = path .. "fire_first.ogg"

SWEP.ShootSound = {
    path .. "fire-01.ogg",
    path .. "fire-02.ogg",
    path .. "fire-03.ogg",
    path .. "fire-04.ogg",
    path .. "fire-05.ogg",
    path .. "fire-06.ogg"
}
SWEP.ShootSoundSilenced = {
    path .. "fire-sup-01.ogg",
    path .. "fire-sup-02.ogg",
    path .. "fire-sup-03.ogg",
    path .. "fire-sup-04.ogg",
    path .. "fire-sup-05.ogg",
    path .. "fire-sup-06.ogg"
}
SWEP.DistantShootSound = nil
SWEP.DistantShootSoundSilenced = nil
SWEP.ShootDrySound = path .. "dryfire.ogg"

local tail = ")/arccw_uc/common/308/"

SWEP.DistantShootSoundOutdoors = {
    tail .. "fire-dist-308-rif-ext-01.ogg",
    tail .. "fire-dist-308-rif-ext-02.ogg",
    tail .. "fire-dist-308-rif-ext-03.ogg",
    tail .. "fire-dist-308-rif-ext-04.ogg",
    tail .. "fire-dist-308-rif-ext-05.ogg",
    tail .. "fire-dist-308-rif-ext-06.ogg"
}
SWEP.DistantShootSoundIndoors = {
    tail .. "fire-dist-308-rif-int-01.ogg",
    tail .. "fire-dist-308-rif-int-02.ogg",
    tail .. "fire-dist-308-rif-int-03.ogg",
    tail .. "fire-dist-308-rif-int-04.ogg",
    tail .. "fire-dist-308-rif-int-05.ogg",
    tail .. "fire-dist-308-rif-int-06.ogg"
}
SWEP.DistantShootSoundOutdoorsSilenced = {
    common .. "sup-tail-01.ogg",
    common .. "sup-tail-02.ogg",
    common .. "sup-tail-03.ogg",
    common .. "sup-tail-04.ogg",
    common .. "sup-tail-05.ogg",
    common .. "sup-tail-06.ogg",
    common .. "sup-tail-07.ogg",
    common .. "sup-tail-08.ogg",
    common .. "sup-tail-09.ogg",
    common .. "sup-tail-10.ogg"
}
SWEP.DistantShootSoundIndoorsSilenced = {
    common .. "fire-dist-int-pistol-light-01.ogg",
    common .. "fire-dist-int-pistol-light-02.ogg",
    common .. "fire-dist-int-pistol-light-03.ogg",
    common .. "fire-dist-int-pistol-light-04.ogg",
    common .. "fire-dist-int-pistol-light-05.ogg",
    common .. "fire-dist-int-pistol-light-06.ogg"
}
SWEP.FiremodeSound = {
    path .. "selector-01.ogg",
    path .. "selector-02.ogg",
    path .. "selector-03.ogg",
    path .. "selector-04.ogg",
}
SWEP.DistantShootSoundOutdoorsVolume = 1
SWEP.DistantShootSoundIndoorsVolume = 1
SWEP.Hook_AddShootSound = ArcCW.UC.InnyOuty

-- Bodygroups --


SWEP.AttachmentElements = {	
    ["conv_9mm"] = {
        NameChange = "Aanvulloir 16",
        TrueNameChange = "SCAR-9",
        VMBodygroups = {
            {ind = 2, bg = 3},
            {ind = 4, bg = 4},
        },
    },	 
	["conv_ak"] = {
        NameChange = "Chijmaar 32",
        TrueNameChange = "SCAR-47",
        VMBodygroups = {
            {ind = 2, bg = 2},
            {ind = 4, bg = 2},
        },
    },
	["conv_ak70"] = {
        NameChange = "Chijmaar 70",
        TrueNameChange = "SCAR-47/70",
        VMBodygroups = {
            {ind = 2, bg = 4},
            {ind = 4, bg = 3},
        },
    },
	["conv_556"] = {
        NameChange = "Scarlett 17",
        TrueNameChange = "SCAR-L",
        VMBodygroups = {
            {ind = 2, bg = 1},
            {ind = 4, bg = 1},
        },
    },	
	["conv_ssr"] = {
        NameChange = "Lancierie 24",
        TrueNameChange = "SCAR-SSR",
        VMBodygroups = {
            {ind = 2, bg = 5},
            {ind = 4, bg = 0},
        },
    },	

	["stock_ssr"] = {
        VMBodygroups = {
            {ind = 7, bg = 6},
        },
    },
	["stock_tube"] = { VMBodygroups = { {ind = 0, bg = 2},{ind = 7, bg = 10}, }, },
	["stock_folded"] = { VMBodygroups = { {ind = 7, bg = 1}, }, },
	["stock_pdw"] = { VMBodygroups = { {ind = 7, bg = 4}, }, },
	["stock_pdwf"] = { VMBodygroups = { {ind = 7, bg = 5}, }, },
	["stock_231_ex"] = { VMBodygroups = { {ind = 7, bg = 7}, {ind = 0, bg = 2}, }, },
	["stock_231_in"] = { VMBodygroups = { {ind = 7, bg = 8}, {ind = 0, bg = 2}, }, },
	["stock_fold"] = { VMBodygroups = { {ind = 7, bg = 2}, }, },
	["stock_foldf"] = { VMBodygroups = { {ind = 7, bg = 3}, }, },

	["grip_flat"] = { VMBodygroups = { {ind = 6, bg = 1}, }, },	
	["grip_hollow"] = { VMBodygroups = { {ind = 6, bg = 2}, }, },
	
	["hg_l"] = {
        VMBodygroups = {
            {ind = 8, bg = 3},
            {ind = 9, bg = 3},
        },
        AttPosMods = {
            [3] = { vpos = Vector(0, -1.65, 22.0) },
        }
    },	
	["hg_20"] = {
        VMBodygroups = {
            {ind = 8, bg = 5},
            {ind = 9, bg = 5},
			{ind = 1, bg = 5},
        },
        AttPosMods = {
            [3] = { vpos = Vector(0, -1.65, 22.6) },
        }
    },
    ["hg_sd"] = {
        VMBodygroups = {
            {ind = 8, bg = 4},
            {ind = 9, bg = 4},
            {ind = 1, bg = 3},
        },
        AttPosMods = {
            [3] = { vpos = Vector(0, -1.65, 15.5) },
            [4] = { vpos = Vector(0, 0, 9) },
            [5] = { vpos = Vector(-1.5, -1.7, 9.5) },
			[14] = { vpos = Vector(0, -1, 6) },
        },
    },
    ["hg_s"] = {
        VMBodygroups = {
            {ind = 8, bg = 1},
            {ind = 9, bg = 1},
            {ind = 1, bg = 1},
        }, 
        AttPosMods = {
            [3] = { vpos = Vector(0, -1.65, 12.9) },
            [4] = { vpos = Vector(0, -0.75, 7.5) },
            [5] = { vpos = Vector(-1, -1.7, 8.5) },
        },
    },
    ["hg_xs"] = {
        VMBodygroups = {
            {ind = 8, bg = 2},
            {ind = 9, bg = 2},
            {ind = 1, bg = 2},
        }, 
        AttPosMods = {
            [3] = { vpos = Vector(0, -1.65, 10.5) },
            [4] = { vpos = Vector(0, -0.75, 7) },
            [5] = { vpos = Vector(-1, -1.7, 7.5) },
        },
    },
}

SWEP.DefaultBodygroups = "000000000000000"

SWEP.Hook_ModifyBodygroups = function(wep, data)
	local vm = data.vm
	local handguard = wep.Attachments[2].Installed
	if wep.Attachments[1].Installed then 
        if (handguard == "uc_myt_scar_hg_s") || (handguard == "uc_myt_scar_hg_sd") then vm:SetBodygroup(5, 3) 
        elseif handguard == "uc_myt_scar_hg_xs" then vm:SetBodygroup(5, 5)
        elseif handguard == "uc_myt_scar_hg_20" then vm:SetBodygroup(5, 8)
        else   vm:SetBodygroup(5, 1) end
    
	else
		if (handguard == "uc_myt_scar_hg_s") || (handguard == "uc_myt_scar_hg_sd") then vm:SetBodygroup(5, 2) 
		elseif handguard == "uc_myt_scar_hg_xs" then vm:SetBodygroup(5, 4)
		elseif handguard == "uc_myt_scar_hg_20" then vm:SetBodygroup(5, 7)
		else   vm:SetBodygroup(5, 0) end

    end

	if wep.Attachments[3].Installed then vm:SetBodygroup(9, 4) end	
end

SWEP.Hook_Think = ArcCW.UC.ADSReload

SWEP.NoHideLeftHandInCustomization = true
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },

    ["ready"] = {
        Source = "deploy",
        LHIK = true,
        LHIKIn = 0.3,
        LHIKEaseIn = 0.4,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.4,
        SoundTable = {
            {s = common .. "raise.ogg", t = 0},
            {s = common .. "rattle.ogg", t = 0.2 + 5/40},
            {s = path .. "chpull.ogg",   t = 18/40},
            {s = common .. "cloth_4.ogg",  t = 0.5 + 5/40},
            {s = path .. "chrelease.ogg",  t = 32/40},
        },
        ProcDraw = false,
    },	
    ["ready_empty"] = {
        Source = "deploy_empty",
        LHIK = true,
        LHIKIn = 0.3,
        LHIKEaseIn = 0.4,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.4,
        SoundTable = {
            {s = common .. "raise.ogg", t = 0},
            {s = common .. "rattle.ogg", t = 0.2 + 5/40},
            {s = common .. "cloth_4.ogg",  t = 0.5 + 5/40},
        },
        ProcDraw = false,
        ForceEmpty = true,
    },	
    ["idle_empty"] = {
        Source = "idle_empty",
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {s = common .. "raise.ogg", t = 0},
            {s = common .. "shoulder.ogg", t = 0.15},
            {s = path .. "rattle_3.ogg", t = 0.2},
        },
    },
    ["draw_empty"] = {
        Source = "draw_empty",
        Time = 20 / 30,
        SoundTable = {
            {s = common .. "raise.ogg", t = 0},
            {s = common .. "shoulder.ogg", t = 0.15},
            {s = path .. "rattle_3.ogg", t = 0.2},
        },
    },
    ["holster"] = {
        Source = "holster",
        LHIK = false,
        LHIKIn = 0.3,
        LHIKEaseIn = 0.4,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.4,
        SoundTable = {
            {s = ratel, t = 0},
            {s = common .. "cloth_6.ogg", t = 0.2},
        },
    },
    ["holster_empty"] = {
        Source = "holster_empty",
        LHIK = false,
        LHIKIn = 0.3,
        LHIKEaseIn = 0.4,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.4,
        SoundTable = {
            {s = ratel, t = 0},
            {s = common .. "cloth_6.ogg", t = 0.2},
        },
    },
    ["fix"] = {
        Source = "fix",
        ShellEjectAt = 0.5,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKEaseIn = 0.2,
        LHIKEaseOut = 0.3,
        LHIKOut = 0.7,
        SoundTable = {
            {s = common .. "raise.ogg", t = 0},
            {s = common .. "rattle.ogg", t = 0.2},
            {s = path .. "chpull.ogg",   t = 0.15},
            {s = common .. "cloth_4.ogg",  t = 0.5},
            {s = path .. "chrelease.ogg",  t = 0.5},
        },
    },  
    ["fire"] = {
        Source = "fire",
        ShellEjectAt = 0.01,
        SoundTable = {{ s = mech, t = 0, v = 0.25 }},
    },  
	["fire_iron"] = {
        Source = "fire",
        ShellEjectAt = 0.01,
        SoundTable = {
            {s = common .. "common_mech_light.ogg", t = 0},
            { s = mech, t = 0 }
        },
    },
    ["fire_empty"] = {
        Source = "fire_empty",
        ShellEjectAt = 0.01,
        SoundTable = {
            {s = common .. "common_mech_light.ogg", t = 0},
            {s = path .. "mech_last.ogg", t = 0}, -- Temporary
        },
    }, 
	["fire_iron_empty"] = {
        Source = "fire_empty",
        ShellEjectAt = 0.01,
        SoundTable = {
            {s = common .. "common_mech_light.ogg", t = 0},
            {s = path .. "mech_last.ogg", t = 0}, -- Temporary
        },
    },

    -- Base --

    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        MinProgress = 1.8,
        LastClip1OutTime = 0.9,
        LHIK = true,
        LHIKIn = 0.4,
        LHIKEaseIn = 0.4,
        LHIKEaseOut = 0.3,
        LHIKOut = 0.5,
        SoundTable = {
            {s = rottle, 			                    t = 0/40},
            {s = "weapons/uc_osk/magout.ogg", 			t = 10/40},
            {s = rottle, 			                    t = 20/40},
            {s = common .. "magpouch.ogg",              t = 32/40},
            {s = "weapons/uc_osk/struggle.ogg", 		t = 42/40},
            {s = "weapons/uc_osk/magin.ogg", 			t = 56/40},
            {s = rottle, 			                    t = 60/40},
            {s = "weapons/uc_osk/magtap.ogg", 			t = 66/40},
        },
    },
    ["reload_empty"] = {
        Source = "reload_empty",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        MinProgress = 2.25,
        LastClip1OutTime = 0.7,
        LHIK = true,
        LHIKIn = 0.4,
        LHIKEaseIn = 0.4,
        LHIKEaseOut = 0.3,
        LHIKOut = 0.5,
        SoundTable = {
            {s = rottle, 			                    t = 0/40},
            {s = "weapons/uc_osk/magout.ogg", 			t = 7/40},
            {s = rottle, 			                    t = 17/40},
            {s = magdrop, 			                    t = 40/40, v = 0.25},
            {s = common .. "magpouch.ogg",              t = 32/40},
            {s = "weapons/uc_osk/struggle.ogg", 		t = 46/40},
            {s = "weapons/uc_osk/magin.ogg", 			t = 62/40},
            {s = rottle, 			                    t = 69/40},
            {s = "weapons/uc_osk/boltcatch.ogg", 		t = 82/40},
            {s = rottle, 			                    t = 88/40},
        },
    },

    ["enter_inspect"] = {
        Source = "inspect_enter",
        LHIK = true,
        LHIKIn = 0.2,
        LHIKOut = 0,
        SoundTable = {
            {s = rottle, t = 0},
            {s = common .. "movement-rifle-02.ogg", t = 0.1},
        },
    },
    ["idle_inspect"] = {
        Source = "inspect_loop",
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0,
    },
    ["exit_inspect"] = {
        Source = "inspect_exit",
        LHIK = true,
        LHIKIn = 0,
        LHIKEaseOut = 0.375,
        LHIKOut = 0.6,
        SoundTable = {
            {s = rottle, 			                    t = 0/40},
            {s = "weapons/uc_osk/magout.ogg", 			t = 20/40},
            {s = rottle, 			                    t = 17/40},
            {s = "weapons/uc_osk/struggle.ogg", 		t = 60/40},
            {s = "weapons/uc_osk/magin.ogg", 			t = 70/40},
            {s = rottle, 			                    t = 69/40},
            {s = common .. "shoulder.ogg", 	        	t = 88/40, v = .5},
        },
    },
    ["enter_inspect_empty"] = {
        Source = "inspect_enter_empty",
        LHIK = true,
        LHIKIn = 0.2,
        LHIKOut = 0,
        SoundTable = {
            {s = rottle, t = 0},
            {s = common .. "movement-rifle-02.ogg", t = 0.1},
        },
    },
    ["idle_inspect_empty"] = {
        Source = "inspect_loop_empty",
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0,
    },
    ["exit_inspect_empty"] = {
        Source = "inspect_exit_empty",
        LHIK = true,
        LHIKIn = 0,
        LHIKEaseOut = 0.375,
        LHIKOut = 0.6,
        SoundTable = {
            {s = rottle, 			                    t = 0/40},
            {s = "weapons/uc_osk/magout.ogg", 			t = 20/40},
            {s = rottle, 			                    t = 17/40},
            {s = "weapons/uc_osk/struggle.ogg", 		t = 60/40},
            {s = "weapons/uc_osk/magin.ogg", 			t = 70/40},
            {s = rottle, 			                    t = 69/40},
            {s = common .. "shoulder.ogg", 	        	t = 88/40, v = .5},
        },
    },	

    -- 9mm --

    ["reload_9mm"] = {
        Source = "reload_9mm",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        MinProgress = 1.5,
        LastClip1OutTime = 0.9,
        LHIK = true,
        LHIKIn = 0.4,
        LHIKEaseIn = 0.4,
        LHIKEaseOut = 0.3,
        LHIKOut = 0.5,
        SoundTable = {
            {s = rottle, 			                    t = 0/40},
            {s = "weapons/uc_osk/magout-9.ogg", 		t = 10/40},
            {s = rottle, 			                    t = 20/40},
            {s = common .. "magpouch.ogg",              t = 32/40},
            {s = "weapons/uc_osk/struggle-9.ogg", 		t = 40/40},
            {s = "weapons/uc_osk/magin-9.ogg", 			t = 53/40},
            {s = rottle, 			                    t = 60/40},
        },
    },
    ["reload_empty_9mm"] = {
        Source = "reload_empty_9mm",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        MinProgress = 1.6,
        LastClip1OutTime = 0.7,
        LHIK = true,
        LHIKIn = 0.4,
        LHIKEaseIn = 0.4,
        LHIKEaseOut = 0.3,
        LHIKOut = 0.5,
        SoundTable = {
            {s = rottle, 			                    t = 0/40},
            {s = "weapons/uc_osk/magout-9.ogg", 		t = 5/40},
            {s = rottle, 			                    t = 17/40},
            {s = magdrop, 			                    t = 30/40, v = 0.25},
            {s = common .. "magpouch.ogg",              t = 32/40},
            {s = "weapons/uc_osk/struggle-9.ogg", 		t = 35/40},
            {s = "weapons/uc_osk/magin-9.ogg", 			t = 41/40},
            {s = "weapons/uc_osk/boltcatchpress-9.ogg", t = 58/40},
            {s = rottle, 			                    t = 62/40},
        },
    },

    ["enter_inspect_9mm"] = {
        Source = "inspect_enter_9mm",
        LHIK = true,
        LHIKIn = 0.2,
        LHIKOut = 0,
        SoundTable = {
            {s = rottle, t = 0},
            {s = common .. "movement-rifle-02.ogg", t = 0.1},
        },
    },
    ["idle_inspect_9mm"] = {
        Source = "inspect_loop_9mm",
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0,
    },
    ["exit_inspect_9mm"] = {
        Source = "inspect_exit_9mm",
        LHIK = true,
        LHIKIn = 0,
        LHIKEaseOut = 0.375,
        LHIKOut = 0.6,
        SoundTable = {
            {s = rottle, 			                    t = 0/40},
            {s = "weapons/uc_osk/magout-9.ogg", 			t = 20/40},
            {s = rottle, 			                    t = 17/40},
            {s = "weapons/uc_osk/struggle-9.ogg", 		t = 53/40},
            {s = "weapons/uc_osk/magin-9.ogg", 			t = 68/40},
            {s = rottle, 			                    t = 69/40},
        },
    },
    ["enter_inspect_empty_9mm"] = {
        Source = "inspect_enter_empty_9mm",
        LHIK = true,
        LHIKIn = 0.2,
        LHIKOut = 0, 
        SoundTable = {
            {s = rottle, t = 0},
            {s = common .. "movement-rifle-02.ogg", t = 0.1},
        },
    },
    ["idle_inspect_empty_9mm"] = {
        Source = "inspect_loop_empty_9mm",
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0, 
    },
    ["exit_inspect_empty_9mm"] = {
        Source = "inspect_exit_empty_9mm",
        LHIK = true,
        LHIKIn = 0,
        LHIKEaseOut = 0.375,
        LHIKOut = 0.6,
        SoundTable = {
            {s = rottle, 			                    t = 0/40},
            {s = "weapons/uc_osk/magout-9.ogg", 			t = 20/40},
            {s = rottle, 			                    t = 17/40},
            {s = "weapons/uc_osk/struggle-9.ogg", 		t = 53/40},
            {s = "weapons/uc_osk/magin-9.ogg", 			t = 68/40},
            {s = rottle, 			                    t = 69/40},
        },
    },	 
	
    -- ssr --

    ["reload_ssr"] = {
        Source = "reload_ssr",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        MinProgress = 2,
        LastClip1OutTime = 0.9,
        LHIK = false,
        SoundTable = {
            {s = rottle, 			                    t = 0/40},
            {s = "weapons/uc_osk/magout.ogg", 			t = 14/40},
            {s = rottle, 			                    t = 17/40},
            {s = common .. "magpouch.ogg",              t = 40/40},
            {s = "weapons/uc_osk/struggle.ogg", 		t = 60/40},
            {s = "weapons/uc_osk/magin.ogg", 			t = 72/40},
            {s = rottle, 			                    t = 80/40},
        },
    },
    ["reload_empty_ssr"] = {
        Source = "reload_empty_ssr",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        MinProgress = 2.7,
        LastClip1OutTime = 0.7,
        LHIK = true,
        LHIKIn = 2.8,
        LHIKEaseIn = 0.4,
        LHIKEaseOut = 0.3,
        LHIKOut = 0.5,
        SoundTable = {
            {s = rottle, 			                    t = 0/40},
            {s = "weapons/uc_osk/magout.ogg", 			t = 14/40},
            {s = rottle, 			                    t = 17/40},
            {s = common .. "magpouch.ogg",              t = 32/40},
            {s = magdrop, 			                    t = 46/40, v = 0.25},
            {s = "weapons/uc_osk/struggle.ogg", 		t = 60/40},
            {s = "weapons/uc_osk/magin.ogg", 			t = 72/40},
            {s = rottle, 			                    t = 78/40},
            {s = "weapons/uc_osk/boltcatch.ogg", 		t = 101/40},
            {s = rottle, 			                    t = 104/40},
        },
    },

    ["enter_inspect_ssr"] = {
        Source = "inspect_enter_ssr",
        LHIK = true,
        LHIKIn = 0.2,
        LHIKOut = 0, 
        SoundTable = {
            {s = rottle, t = 0},
            {s = common .. "movement-rifle-02.ogg", t = 0.1},
        },
    },
    ["idle_inspect_ssr"] = {
        Source = "inspect_loop_ssr",
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0, 
    },
    ["exit_inspect_ssr"] = {
        Source = "inspect_exit_ssr",
        LHIK = true,
        LHIKIn = 0,
        LHIKEaseOut = 0.375,
        LHIKOut = 0.6,
        SoundTable = {
            {s = rottle, 			                    t = 0/40},
            {s = "weapons/uc_osk/magout.ogg", 			t = 20/40},
            {s = rottle, 			                    t = 17/40},
            {s = "weapons/uc_osk/struggle.ogg", 		t = 46/40},
            {s = "weapons/uc_osk/magin.ogg", 			t = 70/40},
            {s = rottle, 			                    t = 69/40},
            -- {s = "weapons/uc_osk/boltcatch.ogg", 		t = 82/40},
        },
    },
    ["enter_inspect_empty_ssr"] = {
        Source = "inspect_enter_empty_ssr",
        LHIK = true,
        LHIKIn = 0.2,
        LHIKOut = 0, 
        SoundTable = {
            {s = rottle, t = 0},
            {s = common .. "movement-rifle-02.ogg", t = 0.1},
        },
    },
    ["idle_inspect_empty_ssr"] = {
        Source = "inspect_loop_empty_ssr",
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0,
    },
    ["exit_inspect_empty_ssr"] = {
        Source = "inspect_exit_empty_ssr",
        LHIK = true,
        LHIKIn = 0,
        LHIKEaseOut = 0.375,
        LHIKOut = 0.6,
        SoundTable = {
            {s = rottle, 			                    t = 0/40},
            {s = "weapons/uc_osk/magout.ogg", 			t = 20/40},
            {s = rottle, 			                    t = 17/40},
            {s = "weapons/uc_osk/struggle.ogg", 		t = 60/40},
            {s = "weapons/uc_osk/magin.ogg", 			t = 70/40},
            {s = rottle, 			                    t = 69/40},
            {s = common .. "shoulder.ogg", 	        	t = 88/40, v = .5},
        },
    },	 

    -- 556 --

    ["reload_556"] = {
        Source = "reload_556",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        MinProgress = 1.5,
        LastClip1OutTime = 0.7,
        LHIK = true,
        LHIKIn = 0.4,
        LHIKEaseIn = 0.4,
        LHIKEaseOut = 0.3,
        LHIKOut = 0.5,
        SoundTable = {
            {s = rottle, 			                    t = 0/40},
            {s = "weapons/uc_osk/magout.ogg", 			t = 10/40},
            {s = rottle, 			                    t = 20/40},
            {s = common .. "magpouch.ogg",              t = 30/40},
            {s = "weapons/uc_osk/struggle.ogg", 		t = 40/40},
            {s = "weapons/uc_osk/magin.ogg", 			t = 53/40},
            {s = rottle, 			                    t = 60/40},
        },
    },
    ["reload_empty_556"] = {
        Source = "reload_empty_556",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        MinProgress = 1.85,
        LastClip1OutTime = 0.7,
        LHIK = true,
        LHIKIn = 0.4,
        LHIKEaseIn = 0.4,
        LHIKEaseOut = 0.3,
        LHIKOut = 0.5,
        SoundTable = {
            {s = rottle, 			                    t = 0/40},
            {s = "weapons/uc_osk/magout.ogg", 			t = 3/40},
            {s = rottle, 			                    t = 17/40},
            {s = magdrop, 			                    t = 22/40, v = 0.35},
            {s = common .. "magpouch.ogg",              t = 26/40},
            {s = "weapons/uc_osk/struggle.ogg", 		t = 40/40},
            {s = "weapons/uc_osk/magin.ogg", 			t = 50/40},
            {s = rottle, 			                    t = 69/40},
            {s = "weapons/uc_osk/boltcatchpress.ogg", 	t = 70/40},
            {s = rottle, 			                    t = 75/40},
        },
    },

    ["enter_inspect_556"] = {
        Source = "inspect_enter_556",
        LHIK = true,
        LHIKIn = 0.2,
        LHIKOut = 0,
        SoundTable = {
            {s = rottle, t = 0},
            {s = common .. "movement-rifle-02.ogg", t = 0.1},
        },
    },
    ["idle_inspect_556"] = {
        Source = "inspect_loop_556",
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0, -- maybe im dumb
    },
    ["exit_inspect_556"] = {
        Source = "inspect_exit_556",
        LHIK = true,
        LHIKIn = 0,
        LHIKEaseOut = 0.375,
        LHIKOut = 0.6,
        SoundTable = {
            {s = rottle, 			                    t = 0/40},
            {s = "weapons/uc_osk/magout.ogg", 			t = 20/40},
            {s = rottle, 			                    t = 17/40},
            {s = "weapons/uc_osk/struggle.ogg", 		t = 60/40},
            {s = "weapons/uc_osk/magin.ogg", 			t = 70/40},
            {s = rottle, 			                    t = 69/40},
            {s = common .. "shoulder.ogg", 	        	t = 88/40, v = .5},
        },
    },
    ["enter_inspect_empty_556"] = {
        Source = "inspect_enter_empty_556",
        LHIK = true,
        LHIKIn = 0.2,
        LHIKOut = 0,
        SoundTable = {
            {s = rottle, t = 0},
            {s = common .. "movement-rifle-02.ogg", t = 0.1},
        },
    },
    ["idle_inspect_empty_556"] = {
        Source = "inspect_loop_empty_556",
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0,
    },
    ["exit_inspect_empty_556"] = {
        Source = "inspect_exit_empty_556",
        LHIK = true,
        LHIKIn = 0,
        LHIKEaseOut = 0.375,
        LHIKOut = 0.6,
        SoundTable = {
            {s = rottle, 			                    t = 0/40},
            {s = "weapons/uc_osk/magout.ogg", 			t = 20/40},
            {s = rottle, 			                    t = 17/40},
            {s = "weapons/uc_osk/struggle.ogg", 		t = 60/40},
            {s = "weapons/uc_osk/magin.ogg", 			t = 70/40},
            {s = rottle, 			                    t = 69/40},
            {s = common .. "shoulder.ogg", 	        	t = 88/40, v = .5},
        },
    },	 

	-- ak --

    ["reload_ak"] = {
        Source = "reload_ak",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        MinProgress = 1.6,
        LastClip1OutTime = 0.9,
        LHIK = true,
        LHIKIn = 0.4,
        LHIKEaseIn = 0.4,
        LHIKEaseOut = 0.3,
        LHIKOut = 0.5,
        SoundTable = {
            {s = rottle, 			                    t = 0/40},
            {s = "weapons/uc_osk/magout-762.ogg", 		t = 12/40},
            {s = rottle, 			                    t = 20/40},
            {s = common .. "magpouch.ogg",              t = 32/40},
            {s = "weapons/uc_osk/struggle-762.ogg", 	t = 49/40},
            {s = "weapons/uc_osk/magin-762.ogg", 		t = 61/40},
            {s = rottle, 			                    t = 60/40},
        },
    },
    ["reload_empty_ak"] = {
        Source = "reload_empty_ak",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        MinProgress = 2.3,
        LastClip1OutTime = 0.7,
        LHIK = true,
        LHIKIn = 0.4,
        LHIKEaseIn = 0.4,
        LHIKEaseOut = 0.3,
        LHIKOut = 0.5,
        SoundTable = {
            {s = rottle, 			                    t = 0/40},
            {s = "weapons/uc_osk/magout-762.ogg", 		t = 12/40},
            {s = rottle, 			                    t = 20/40},
            {s = common .. "magpouch.ogg",              t = 32/40},
            {s = "weapons/uc_osk/struggle-762.ogg", 	t = 51/40},
            {s = "weapons/uc_osk/magin-762.ogg", 		t = 61/40},
            {s = rottle, 			                    t = 69/40},
            {s = "weapons/uc_osk/boltcatchpress.ogg", 	t = 85/40},
            {s = rottle, 			                    t = 88/40},
        },
    },

    ["enter_inspect_ak"] = {
        Source = "inspect_enter_ak",
        LHIK = true,
        LHIKIn = 0.2,
        LHIKOut = 0,
        SoundTable = {
            {s = rottle, t = 0},
            {s = common .. "movement-rifle-02.ogg", t = 0.1},
        },
    },
    ["idle_inspect_ak"] = {
        Source = "inspect_loop_ak",
        -- time = 72 / 60,
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0
    },
    ["exit_inspect_ak"] = {
        Source = "inspect_exit_ak",
        LHIK = true,
        LHIKIn = 0,
        LHIKEaseOut = 0.375,
        LHIKOut = 0.6,
        SoundTable = {
            {s = rottle, 			                    t = 0/40},
            {s = "weapons/uc_osk/magout.ogg", 			t = 20/40},
            {s = rottle, 			                    t = 17/40},
            {s = "weapons/uc_osk/struggle.ogg", 		t = 60/40},
            {s = "weapons/uc_osk/magin.ogg", 			t = 70/40},
            {s = rottle, 			                    t = 69/40},
            {s = common .. "shoulder.ogg", 	        	t = 88/40, v = .5},
        },
    },
    ["enter_inspect_empty_ak"] = {
        Source = "inspect_enter_empty_ak",
        LHIK = true,
        LHIKIn = 0.2,
        LHIKOut = 0,
        SoundTable = {
            {s = rottle, t = 0},
            {s = common .. "movement-rifle-02.ogg", t = 0.1},
        },
    },
    ["idle_inspect_empty_ak"] = {
        Source = "inspect_loop_empty_ak",
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0,
    },
    ["exit_inspect_empty_ak"] = {
        Source = "inspect_exit_empty_ak",
        LHIK = true,
        LHIKIn = 0,
        LHIKEaseOut = 0.375,
        LHIKOut = 0.6,
        SoundTable = {
            {s = rottle, 			                    t = 0/40},
            {s = "weapons/uc_osk/magout.ogg", 			t = 20/40},
            {s = rottle, 			                    t = 17/40},
            {s = "weapons/uc_osk/struggle.ogg", 		t = 60/40},
            {s = "weapons/uc_osk/magin.ogg", 			t = 70/40},
            {s = rottle, 			                    t = 69/40},
            {s = common .. "shoulder.ogg", 	        	t = 88/40, v = .5},
        },
    },	
	
	-- ak drum--

    ["reload_ak_drum"] = {
        Source = "reload_ak_drum",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        MinProgress = 2.1,
        LastClip1OutTime = 0.9,
        LHIK = true,
        LHIKIn = 0.25,
        LHIKEaseIn = 0.225,
        LHIKEaseOut = 0.2,
        LHIKOut = 0.6,
        SoundTable = {
            {s = rottle, 			                    t = 0/40},
            {s = "weapons/uc_osk/magout-762.ogg", 		t = 12/40},
            {s = rottle, 			                    t = 20/40},
            {s = common .. "magpouch.ogg",              t = 32/40},
            {s = "weapons/uc_osk/struggle-762.ogg", 	t = 54/40},
            {s = "weapons/uc_osk/magin-762.ogg", 		t = 64/40},
			{s = "weapons/uc_osk/magtap.ogg", 			t = 75/40},
            {s = rottle, 			                    t = 60/40},
        },
    },
    ["reload_empty_ak_drum"] = {
        Source = "reload_empty_ak_drum",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        MinProgress = 2.8,
        LastClip1OutTime = 0.7,
        LHIK = true,
        LHIKIn = 0.25,
        LHIKEaseIn = 0.225,
        LHIKEaseOut = 0.2,
        LHIKOut = 0.6,
        SoundTable = {
            {s = rottle, 			                    t = 0/40},
            {s = "weapons/uc_osk/magout-762.ogg", 		t = 12/40},
            {s = rottle, 			                    t = 20/40},
            {s = common .. "magpouch.ogg",              t = 32/40},
            {s = "weapons/uc_osk/struggle-762.ogg", 	t = 54/40},
            {s = "weapons/uc_osk/magin-762.ogg", 		t = 64/40},
            {s = rottle, 			                    t = 69/40},
            {s = path .. "chpull.ogg",   				t = 95/40},
            {s = common .. "cloth_4.ogg", 				t = 98/40},
            {s = path .. "chrelease.ogg",  				t = 106/40},
            {s = rottle, 			                    t = 114/40},
        },
    },

    ["enter_inspect_ak_drum"] = {
        Source = "inspect_enter_ak_drum",
        LHIK = true,
        LHIKIn = 0.2,
        LHIKOut = 0,
        SoundTable = {
            {s = rottle, t = 0},
            {s = common .. "movement-rifle-02.ogg", t = 0.1},
        },
    },
    ["idle_inspect_ak_drum"] = {
        Source = "inspect_loop_ak_drum",
        -- time = 72 / 60,
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0
    },
    ["exit_inspect_ak_drum"] = {
        Source = "inspect_exit_ak_drum",
        LHIK = true,
        LHIKIn = 0,
        LHIKEaseOut = 0.3,
        LHIKOut = 0.475,
        SoundTable = {
            {s = rottle, 			                    t = 0/40},
            {s = common .. "shoulder.ogg", 	        	t = 20/40, v = .5},
        },
    },
    ["enter_inspect_empty_ak_drum"] = {
        Source = "inspect_enter_empty_ak_drum",
        LHIK = true,
        LHIKIn = 0.2,
        LHIKOut = 0,
        SoundTable = {
            {s = rottle, t = 0},
            {s = common .. "movement-rifle-02.ogg", t = 0.1},
        },
    },
    ["idle_inspect_empty_ak_drum"] = {
        Source = "inspect_loop_empty_ak_drum",
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0,
    },
    ["exit_inspect_empty_ak_drum"] = {
        Source = "inspect_exit_empty_ak_drum",
        LHIK = true,
        LHIKIn = 0,
        LHIKEaseOut = 0.3,
        LHIKOut = 0.475,
        SoundTable = {
            {s = rottle, 			                    t = 0/40},
            {s = common .. "shoulder.ogg", 	        	t = 20/40, v = .5},
        },
    },	
}

SWEP.Attachments = {
    {
        PrintName = "Optic",
        DefaultAttName = "Iron Sights",
        --InstalledEles = {"upper_flat"}, no such thing
        Slot = {"optic","optic_sniper"},
        Bone = "W_Main",
        VMScale = Vector(1.15, 1.15, 1.15),
        Offset = {
            vpos = Vector(-0, -3.78, 0.5),
            vang = Angle(90, 0, -90),
        },
        //MergeSlots = {16},
    },
    {
        PrintName = "Barrel",
        DefaultAttName = "14\" Standard Barrel",
        Slot = "uc_myt_scar_hg",
        Bone = "W_Main",
        Offset = {
            vpos = Vector(3.5, -4.25, -7),
            vang = Angle(90, 0, -90),
        },
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Standard Muzzle",
        Slot = {"muzzle"},
        Bone = "W_Main",
        Offset = {
            vpos = Vector(0, -1.65, 15.5),
            vang = Angle(90, 0, -90),
        },
        ExcludeFlags = {"sd"},
    },
    {
        PrintName = "Underbarrel",
        Slot = {"foregrip"},
        Bone = "W_Main",
        Offset = {
            vpos = Vector(0, -0.75, 9),
            vang = Angle(90, 0, -90),
        },
        MergeSlots = {14},
    },
    {
        PrintName = "Tactical",
        Slot = {"tac"},
        Bone = "W_Main",
        Offset = {
            vpos = Vector(-1, -1.7, 9.5),
            vang = Angle(90, 0, 180),
        },
        GivesFlags = {"tac"},
        --InstalledEles = {"ud_m16_clamp_fullsize"}
    },
    {
        PrintName = "Grip Type",
        Slot = {"uc_myt_scar_grip"},
		Hidden = true,
        DefaultAttName = "Standard Grip",
    },
    {
        PrintName = "Stock",
        Slot = {"uc_myt_scar_stock"},
        DefaultAttName = "Standard Stock",
        MergeSlots = {15},
    },
    {
        PrintName = "Magazine",
        Slot = {"uc_myt_scar_mag"},
        Bone = "W_Main",
        Offset = {
            vpos = Vector(0, -0.75, 9),
            vang = Angle(90, 0, -90),
        },
        DefaultAttName = "20-Round Mag",
    },
    {
        PrintName = "Ammo Type",
        DefaultAttName = "\"FMJ\" Full Metal Jacket",
        Slot = "uc_ammo",
    },
    {
        PrintName = "Powder Load",
        Slot = "uc_powder",
        DefaultAttName = "Standard Load"
    },
    {
        PrintName = "Training Package",
        Slot = "uc_tp",
        DefaultAttName = "Basic Training"
    },
    {
        PrintName = "Internals",
        Slot = "uc_fg", -- Fire group
        DefaultAttName = "Standard Internals"
    },
    {
        PrintName = "Charm",
        Slot = {"charm", "fml_charm"},
        FreeSlot = true,
        Bone = "W_Main",
        Offset = {
            vpos = Vector(0.8, -1.9, 2.5),
            vang = Angle(90, 0, -90),
        },
	},
    {
        PrintName = "M203 slot",
        Slot = "uc_ubgl",
        Bone = "W_Main",
        Offset = {
            vpos = Vector(0, -1.75, 6), -- this is also changed by ModifyBodygroups
            vang = Angle(90, 0, -90),
        },
        Hidden = true,
        InstalledEles = {"mount_underbarrel"},
	},
    {
        PrintName = "Tube Stock Adaptor",
        Slot = {"go_stock"},
        -- GSO support
        Hidden = true,
        InstalledEles = {"stock_tube"},
        Bone = "W_Main",
        Offset = {
            vpos = Vector(0, -2.15, -7.5),
            vang = Angle(90, 0, -90),
        },
    },
    {
        PrintName = "Optic",
        DefaultAttName = "Iron Sights",
        Hidden = true,
        InstalledEles = {"cust_irons"},
        Slot = {"ud_m16_rs"},
        Bone = "W_Main",
        Offset = {
            vpos = Vector(-0, -3.78, 0.5),
            vang = Angle(90, 0, -90),
        },
    },
}
--lua/weapons/arccw_oden.lua:
return gluapack()()
--lua/weapons/arccw_uc_usp.lua:
SWEP.Base = "arccw_base"
SWEP.Spawnable = true
SWEP.Category = "ArcCW - Urban Coalition"
SWEP.UC_CategoryPack = "5Urban One-offs"
SWEP.AdminOnly = false
SWEP.UseHands = true

-- Muzzle and shell effects --

SWEP.MuzzleEffect = "muzzleflash_pistol"
SWEP.ShellEffect = "arccw_uc_shelleffect"
SWEP.ShellModel = "models/weapons/arccw/uc_shells/9x19.mdl"
SWEP.ShellScale = 1
--SWEP.ShellMaterial = "models/weapons/arcticcw/shell_9mm"
SWEP.ShellPitch = 90

SWEP.MuzzleEffectAttachment = 1
SWEP.CaseEffectAttachment = 2
SWEP.CamAttachment = 5
SWEP.TracerNum = 1
SWEP.TracerWidth = 1
SWEP.ShootPitch = 100

-- Fake name --

SWEP.PrintName = "P93"

-- True name --

SWEP.TrueName = "USP Tactical"

-- Trivia --

SWEP.Trivia_Class = "Pistol"
SWEP.Trivia_Desc = [[Versatile handgun designed for foreign and domestic law enforcement. It discards the ambitions of the P7 pattern for a more conventional form which has proved popular. This "Tactical" variant has a threaded barrel designed for sound suppressors.

Can be chambered for a variety of calibers, allowing its trademark performance to be fine-tuned for a number of roles.]]
SWEP.Trivia_Manufacturer = "Crowdley & Nelson"
SWEP.Trivia_Calibre = ".45 ACP"
SWEP.Trivia_Mechanism = "Short Recoil"
SWEP.Trivia_Country = "Germany"
SWEP.Trivia_Year = 1993

-- Weapon slot --

SWEP.Slot = 1

-- Weapon's manufacturer real name --

if GetConVar("arccw_truenames"):GetBool() then
    SWEP.PrintName = SWEP.TrueName
    SWEP.Trivia_Manufacturer = "Heckler & Koch"
end

-- Viewmodel / Worldmodel / FOV --

SWEP.ViewModel = "models/weapons/arccw/c_uc_usp.mdl"
SWEP.WorldModel = "models/weapons/arccw/c_uc_usp.mdl"
SWEP.ViewModelFOV = 66
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_REVOLVER

-- Damage parameters --

SWEP.Damage = 45 -- 3 shot short range kill (2 shot chest point-blank)
SWEP.DamageMin = 15 -- 7 shot long range kill
SWEP.RangeMin = 10
SWEP.Range = 80 -- 3 shot until ~40m
SWEP.Penetration = 9
SWEP.DamageType = DMG_BULLET
SWEP.ShootEntity = nil
SWEP.MuzzleVelocity = 315
SWEP.PhysBulletMuzzleVelocity = 315

SWEP.BodyDamageMults = ArcCW.UC.BodyDamageMults

SWEP.PhysTracerProfile = 7
SWEP.TracerNum = 0

-- Jamming --

--SWEP.Malfunction = true
SWEP.MalfunctionJam = true
--SWEP.MalfunctionMean = 21
SWEP.MalfunctionPostFire = false
SWEP.MalfunctionTakeRound = true

-- Mag size --

SWEP.ChamberSize = 1
SWEP.Primary.ClipSize = 12

-- Recoil --

SWEP.Recoil = 1.25
SWEP.RecoilSide = 0.75

SWEP.RecoilRise = 0.25
SWEP.VisualRecoilMult = 1.0
SWEP.MaxRecoilBlowback = .5
SWEP.MaxRecoilPunch = .8

SWEP.Sway = 1

-- Firerate / Firemodes --

SWEP.Delay = 60 / 420
SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 1,
    },
    {
        Mode = 0
    }
}

SWEP.ShootPitch = 100
SWEP.ShootVol = 120

SWEP.ProceduralRegularFire = false
SWEP.ProceduralIronFire = false

SWEP.ReloadInSights = true

-- NPC --

SWEP.NPCWeaponType = "weapon_pistol"
SWEP.NPCWeight = 70

-- Accuracy --

SWEP.AccuracyMOA = 5
SWEP.HipDispersion = 500
SWEP.MoveDispersion = 250
SWEP.JumpDispersion = 1000

SWEP.Primary.Ammo = "pistol"
SWEP.MagID = "m1911"

-- Speed multipliers --

SWEP.SpeedMult = 0.965
SWEP.SightedSpeedMult = 0.875
SWEP.SightTime = 0.25
SWEP.ShootSpeedMult = 1

-- Length --

SWEP.BarrelLength = 8
SWEP.ExtraSightDist = 7

-- Ironsights / Customization / Poses --

SWEP.HolsterPos = Vector(0.3, 3, 1.6)
SWEP.HolsterAng = Angle(-14, 0, -0.5)

SWEP.SprintPos = Vector(0.3, 3, 1)
SWEP.SprintAng = Angle(-5, 15, -20)

SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"

SWEP.IronSightStruct = {
     Pos = Vector(-2.29, 10, 1.5),
     Ang = Angle(0.15, 0.07, 5.5),
     Magnification = 1,
     SwitchToSound = "",
}

SWEP.ActivePos = Vector(0.3, 3, 1.3)
SWEP.ActiveAng = Angle(0, 0, -0.5)

SWEP.CustomizePos = Vector(0, 0, 0)
SWEP.CustomizeAng = Angle(0, 0, 0)

SWEP.CrouchPos = Vector(-2, 0, 0)
SWEP.CrouchAng = Angle(0, 0, -8)

SWEP.MirrorVMWM = true
SWEP.WorldModelOffset = {
    pos        =    Vector(-8.7, 2.5, -4.2),
    ang        =    Angle(-6, -6, 180),
    bone    =    "ValveBiped.Bip01_R_Hand",
}

-- Weapon sounds --

local path = ")weapons/arccw_uc_usp/"
local path1 = ")weapons/arccw_ur/1911/"
local common = ")/arccw_uc/common/"
local rottle = {common .. "cloth_2.ogg", common .. "cloth_3.ogg", common .. "cloth_4.ogg", common .. "cloth_6.ogg", common .. "rattle.ogg"}

SWEP.ShootSound = {
    path .. "fire-01.ogg",
    path .. "fire-02.ogg",
    path .. "fire-03.ogg",
    path .. "fire-04.ogg",
    path .. "fire-05.ogg",
    path .. "fire-06.ogg"
}
SWEP.ShootSoundSilenced = {
    path .. "fire-sup-01.ogg",
    path .. "fire-sup-02.ogg",
    path .. "fire-sup-03.ogg",
    path .. "fire-sup-04.ogg",
    path .. "fire-sup-05.ogg",
    path .. "fire-sup-06.ogg"
}
SWEP.DistantShootSound = nil
SWEP.DistantShootSoundSilenced = common .. "sup_tail.ogg"
SWEP.ShootDrySound = path .. "dryfire.ogg"

local tail = ")/arccw_uc/common/45acp/"

SWEP.DistantShootSoundOutdoors = {
    tail .. "fire-dist-45acp-pistol-ext-01.ogg",
    tail .. "fire-dist-45acp-pistol-ext-02.ogg",
    tail .. "fire-dist-45acp-pistol-ext-03.ogg",
    tail .. "fire-dist-45acp-pistol-ext-04.ogg",
    tail .. "fire-dist-45acp-pistol-ext-05.ogg",
    tail .. "fire-dist-45acp-pistol-ext-06.ogg"
}
SWEP.DistantShootSoundIndoors = {
    common .. "fire-dist-int-pistol-01.ogg",
    common .. "fire-dist-int-pistol-02.ogg",
    common .. "fire-dist-int-pistol-03.ogg",
    common .. "fire-dist-int-pistol-04.ogg",
    common .. "fire-dist-int-pistol-05.ogg",
    common .. "fire-dist-int-pistol-06.ogg"
}
SWEP.DistantShootSoundOutdoorsSilenced = {
    common .. "sup-tail-01.ogg",
    common .. "sup-tail-02.ogg",
    common .. "sup-tail-03.ogg",
    common .. "sup-tail-04.ogg",
    common .. "sup-tail-05.ogg",
    common .. "sup-tail-06.ogg",
    common .. "sup-tail-07.ogg",
    common .. "sup-tail-08.ogg",
    common .. "sup-tail-09.ogg",
    common .. "sup-tail-10.ogg"
}
SWEP.DistantShootSoundIndoorsSilenced = {
    common .. "fire-dist-int-pistol-light-01.ogg",
    common .. "fire-dist-int-pistol-light-02.ogg",
    common .. "fire-dist-int-pistol-light-03.ogg",
    common .. "fire-dist-int-pistol-light-04.ogg",
    common .. "fire-dist-int-pistol-light-05.ogg",
    common .. "fire-dist-int-pistol-light-06.ogg"
}
SWEP.DistantShootSoundOutdoorsVolume = 1
SWEP.DistantShootSoundIndoorsVolume = 1
SWEP.Hook_AddShootSound = ArcCW.UC.InnyOuty

-- Bodygroups --

SWEP.BulletBones = {
    [1] = "Bullet1",    [2] = "Bullet2",    [3] = "Bullet3", [4] = "Bullet4",    [5] = "Bullet5",    [6] = "Bullet6", [7] = "Bullet7"
}

SWEP.DefaultBodygroups = "000000000"

SWEP.AttachmentElements = {
    ["pistol_rail"] = {
        VMBodygroups = {
            {ind = 4,bg = 1},
        }
    },
    ["uc_usp_sight"] = {
        VMBodygroups = {
            {ind = 4, bg = 2},
            {ind = 5, bg = 1},
        },
        Override_IronSightStruct = {
            Pos = Vector(-2.29, 10, 1.4),
            Ang = Angle(0.2, 0.05, 5.5),
            Magnification = 1,
        }
    },
    ["uc_usp_slide_compact"] = {
        VMBodygroups = {
            {ind = 0, bg = 1},
            {ind = 1, bg = 1},
        },
        AttPosMods = {
            [4] = {
                vpos = Vector(0, -1.46, 4),
                vang = Angle(90, 0, -90),
            }
        },
        NameChange = "CP93",
        TrueNameChange = "USPCT",
    },
    ["uc_usp_slide_ext"] = {
        VMBodygroups = {
            {ind = 1,bg = 4},
        },
        AttPosMods = {
            [4] = {
                vpos = Vector(0, -1.46, 5.25),
                vang = Angle(90, 0, -90),
            }
        },
        NameChange = "LP93",
        TrueNameChange = "USP Elite",
    },
    ["uc_usp_slide_match"] = {
        VMBodygroups = {
            {ind = 1,bg = 2},
            {ind = 3,bg = 1},
        },
        NameChange = "P93 Match",
        TrueNameChange = "USP Match",
    },
    ["uc_usp_slide_cs"] = {
        VMBodygroups = {
            {ind = 1,bg = 3},
        },
        NameChange = "K&M .45",
        TrueNameChange = "USP Agency",
    },
    ["uc_usp_mag_ext"] = {
        VMBodygroups = {
            {ind = 2,bg = 1},
        }
    },
    ["uc_usp_skin_nickel"] = {
        VMSkin = 1
    },
    ["uc_usp_skin_blued"] = {
        VMSkin = 2,
        VMBodygroups = {
            --{ind = 1,bg = 3},
        },
    },

    -- HL2 easter egg
    
    ["uc_tp_gong"] = {
        Override_ActivePos = Vector(1, 5, .75),
        Override_ActiveAng = Angle(-2, -2, 0),
        RequireFlags = {"usp_freeman_1","usp_freeman_2"}, -- Dress for the job you're looking for
        --NameChange = "9MM PISTOL"
    },
    
}

local altsight = {
    uc_usp_slide_ext = 3,
    uc_usp_slide_compact = 2,
}

SWEP.Hook_ModifyBodygroups = function(wep, data)
    local vm = data.vm
    if !IsValid(vm) then return end

    if wep.Attachments[1].Installed == "uc_usp_sight" then
        vm:SetBodygroup(5, altsight[wep.Attachments[2].Installed] or 1)
    end
end

-- Animations --

local mech = {path .. "mech-01.ogg", path .. "mech-02.ogg", path .. "mech-03.ogg", path .. "mech-04.ogg", path .. "mech-05.ogg", path .. "mech-06.ogg"}

SWEP.Animations = {
    ["idle_empty"] = {
        Source = "idle_empty",
        Time = 10 / 30,
    },
    ["idle"] = {
        Source = "idle",
        Time = 10 / 30,
    },
    ["idle_jammed"] = {
        Source = "idle_jam",
        Time = 10 / 30,
    },
    ["ready"] = {
        Source = "fix",
        Time = 1.6,
        MinProgress = 1.2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0,
        ShellEjectAt = false,
        ProcDraw = true,
        SoundTable = {
            { s = rottle, t = 0 / 60 },
            {s = path .. "draw.ogg", t = 0},
            { s = path .. "slidepull.ogg",t = 28 / 60},
            { s = path .. "slidedrop1.ogg",t = 35 / 60},
        },
    },
    ["draw"] = {
        Source = "draw",
        Time = .75,
        MinProgress = .4,
        SoundTable = {
            {s = path .. "draw.ogg", t = 0}, -- Not Temporary
            --{s = common .. "raise.ogg", t = 0.05},
        },
    },
    ["draw_empty"] = {
        Source = "draw_empty",
        Time = .75,
        MinProgress = .4,
        SoundTable = {
            {s = path .. "draw.ogg", t = 0}, -- Not Temporary
            --{s = common .. "raise.ogg", t = 0.05},
        },
    },
    ["draw_jam"] = {
        Source = "draw_jam",
        Time = .75,
        MinProgress = .4,
        SoundTable = {
            {s = path .. "draw.ogg", t = 0}, -- Not Temporary
            --{s = common .. "raise.ogg", t = 0.05},
        },
    },
    ["holster"] = {
        Source = "holster",
        Time = .75,
        SoundTable = {
            {s = common .. "cloth_2.ogg", t = 0},
            {s = path .. "holster.ogg", t = 0.2}, -- Not Temporary
        },
    },
    ["holster_empty"] = {
        Source = "holster_empty",
        Time = .75,
        SoundTable = {
            {s = common .. "cloth_2.ogg", t = 0},
            {s = path .. "holster.ogg", t = 0.2}, -- Not Temporary
        },
    },
    ["holster_jam"] = {
        Source = "holster_jam",
        Time = 18 / 30,
        SoundTable = {
            {s = common .. "cloth_2.ogg", t = 0},
            {s = path .. "holster.ogg", t = 0.2}, -- Not Temporary
        },
    },

    ["fire"] = {
        Source = "fire",
        Time = 30 / 30,
        ShellEjectAt = 0,
        SoundTable = {
            { s = mech, t = 0, v = 0.25 }
        },
    },
    ["fire_iron"] = {
        Source = "fire",
        Time = 30 / 30,
        ShellEjectAt = 0,
        SoundTable = {
            {s = common .. "common_mech_light.ogg", t = 0},
            { s = mech, t = 0 }
        },
    },
    ["fire_empty"] = {
        Source = "fire_empty",
        Time = 24 / 30,
        ShellEjectAt = 0,
        SoundTable = {{ s = path .. "mech_last.ogg", t = 0 }},
    },
    ["fire_iron_empty"] = {
        Source = "fire_empty",
        Time = 24 / 30,
        ShellEjectAt = 0,
        SoundTable = {{ s = path .. "mech_last.ogg", t = 0 }},
    },
    ["fire_jammed"] = {
        Source = "fire_jam",
        Time = 30 / 30,
        MinProgress = 0.5,
        ShellEjectAt = false,
        SoundTable = {
            --{ s = {path .. "mech-01.ogg", path .. "mech-02.ogg", path .. "mech-03.ogg", path .. "mech-04.ogg", path .. "mech-05.ogg", path .. "mech-06.ogg"}, t = 0 }
        },
    },

    ["fire_stock"] = {
        Source = "fire_stock",
        Time = 30 / 30,
        ShellEjectAt = 0,
        SoundTable = {{ s = {path .. "mech-01.ogg", path .. "mech-02.ogg", path .. "mech-03.ogg", path .. "mech-04.ogg", path .. "mech-05.ogg", path .. "mech-06.ogg"}, t = 0, v = 0.25 }},
    },
    ["fire_empty_stock"] = {
        Source = "fire_empty_stock",
        Time = 24 / 30,
        ShellEjectAt = 0,
        SoundTable = {{ s = path .. "mech_last.ogg", t = 0 }},
    },

    ["fire_match"] = {
        Source = "fire_match",
        Time = 30 / 30,
        ShellEjectAt = 0,
        SoundTable = {{ s = {path .. "mech-01.ogg", path .. "mech-02.ogg", path .. "mech-03.ogg", path .. "mech-04.ogg", path .. "mech-05.ogg", path .. "mech-06.ogg"}, t = 0, v = 0.25 }},
    },
    ["fire_iron_match"] = {
        Source = "fire_match",
        Time = 30 / 30,
        ShellEjectAt = 0,
        SoundTable = {
            {s = common .. "common_mech_light.ogg", t = 0},
            { s = {path .. "mech-01.ogg", path .. "mech-02.ogg", path .. "mech-03.ogg", path .. "mech-04.ogg", path .. "mech-05.ogg", path .. "mech-06.ogg"}, t = 0 }
        },
    },
    ["fire_empty_match"] = {
        Source = "fire_empty_match",
        Time = 24 / 30,
        ShellEjectAt = 0,
        SoundTable = {{ s = path .. "mech_last.ogg", t = 0 }},
    },
    ["fire_iron_empty_match"] = {
        Source = "fire_empty_match",
        Time = 24 / 30,
        ShellEjectAt = 0,
        SoundTable = {{ s = path .. "mech_last.ogg", t = 0 }},
    },

    -- 12-R Reloads --

    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        MinProgress = 1.3525,
        Time = 65 / 30,
        LastClip1OutTime = 0.9,
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.2,
        LHIKEaseOut = 0.2,
        LHIKOut = 0.62,
        SoundTable = {
            { s = rottle, t = 0 / 60 },
            { s = common .. "magpouch_pull_small.ogg", t = 1 / 60 },
            { s = common .. "magrelease.ogg", t = 10 / 60 },
            { s = rottle, t = 11 / 60 },
            { s = path .. "magout1.ogg", t = 26 / 60 },
            { s = path .. "magin1.ogg", t = 42 / 60 },
            { s = rottle, t = 55 / 60 },
            { s = common ..  "magpouch_replace_small.ogg", t = 80 / 60 },
        },
    },
    ["reload_empty"] = {
        Source = "reload_empty",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        MinProgress = 1.75,
        Time = 75 / 30,
        LastClip1OutTime = 0.76,
        LHIK = true,
        LHIKIn = 0.1,
        LHIKEaseIn = 0.1,
        LHIKEaseOut = 0.55,
        LHIKOut = 0.7,
        SoundTable = {
            { s = rottle, t = 0 / 60 },
            { s = common .. "magrelease.ogg", t = 7 / 60 },
            { s = path .. "magout1.ogg", t = 16 / 60 },
            { s = rottle, t = 10 / 60 },
            { s = common .. "magpouch_pull_small.ogg", t = 29 / 60 },
            { s = common .. "pistol_magdrop.ogg", t = 40 / 60 },
            { s = rottle, t = 55 / 60 },
            { s = path .. "magin1.ogg", t = 64 / 60 },
            { s = rottle, t = 90 / 60 },
            { s = path .. "slidedrop1.ogg", t = 94 / 60 },
        },
    },

    -- 17-R Reloads --

    ["reload_ext"] = {
        Source = "reload_ext",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        MinProgress = 1.3525,
        Time = 65 / 30,
        LastClip1OutTime = 0.9,
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.2,
        LHIKEaseOut = 0.2,
        LHIKOut = 0.62,
        SoundTable = {
            { s = rottle, t = 0 / 60 },
            { s = common .. "magpouch_pull_small.ogg", t = 0 / 60 },
            { s = common .. "magrelease.ogg", t = 10 / 60 },
            { s = path .. "magout1.ogg", t = 26 / 60 },
            { s = rottle, t = 10 / 60 },
            { s = rottle, t = 55 / 60 },
            { s = common ..  "magpouch_replace_small.ogg", t = 80 / 60 },
            { s = path .. "magin1.ogg", t = 42 / 60 },
        },
    },
    ["reload_empty_ext"] = {
        Source = "reload_empty_ext",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        MinProgress = 1.75,
        Time = 75 / 30,
        LastClip1OutTime = 0.76,
        LHIK = true,
        LHIKIn = 0.1,
        LHIKEaseIn = 0.1,
        LHIKEaseOut = 0.55,
        LHIKOut = 0.7,
        SoundTable = {
            { s = rottle, t = 0 / 60 },
            { s = common .. "magrelease.ogg", t = 7 / 60 },
            { s = path .. "magout1.ogg", t = 16 / 60 },
            { s = rottle, t = 10 / 60 },
            { s = common .. "magpouch_pull_small.ogg", t = 29 / 60 },
            { s = common .. "pistol_magdrop.ogg", t = 40 / 60 },
            { s = rottle, t = 55 / 60 },
            { s = path .. "magin1.ogg", t = 64 / 60 },
            { s = rottle, t = 90 / 60 },
            { s = path .. "slidedrop1.ogg", t = 94 / 60 },
        },
    },

 -- Jam Animations --

    ["fix"] = {
        Source = "fix",
        --Time = 40 / 30,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0,
        ShellEjectAt = 30 / 60,
        SoundTable = {
            { s = rottle, t = 0 / 60 },
            { s = path .. "slidepull.ogg",t = 28 / 60},
            { s = path .. "slidedrop1.ogg",t = 35 / 60},
        },
    },

    ["fix_empty"] = {
        Source = "fix_empty",
        --Time = 40 / 30,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0,
        ShellEjectAt = 30 / 60,
        SoundTable = {
            { s = rottle, t = 0 / 60 },
            { s = path .. "slidepull.ogg",t = 28 / 60},
        },
    },

    ["idle_jam"] = {
        Source = "idle_jam",
        -- time = 35 / 60,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0,
       -- SoundTable = {
        -- },
    },




    -- -- Inspecc --

    ["enter_inspect"] = {
        Source = "enter_inspect",
        time = 35 / 60,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0,
        SoundTable = {
            {s = rottle, t = 0},
            {s = common .. "movement-pistol-04.ogg", t = 0},
        },
    },
    ["idle_inspect"] = {
        Source = "idle_inspect",
        time = 72 / 60,
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0,
    },
    ["exit_inspect"] = {
        Source = "exit_inspect",
        time = 66 / 60,
        LHIK = true,
        LHIKIn = 0,
        LHIKEaseOut = 0.3,
        LHIKOut = 0.84,
        SoundTable = {
            {s = rottle, t = 0.05},
            {s = common .. "movement-pistol-03.ogg", t = 0.1},
            {s = common .. "movement-pistol-01.ogg", t = 1},
            {s = rottle, t = 1},
        },
    },

    ["enter_inspect_empty"] = {
        Source = "enter_inspect_empty",
        time = 35 / 60,
        LHIK = true,
        LHIKIn = 0.1,
        LHIKOut = 0,
        SoundTable = {
            {s = rottle, t = 0},
            {s = common .. "movement-pistol-04.ogg", t = 0},
        },
    },
    ["idle_inspect_empty"] = {
        Source = "idle_inspect_empty",
        time = 72 / 60,
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0,
    },
    ["exit_inspect_empty"] = {
        Source = "exit_inspect_empty",
        time = 66 / 60,
        LHIK = true,
        LHIKIn = 0,
        LHIKEaseOut = 0.3,
        LHIKOut = 0.84,
        SoundTable = {
            {s = rottle, t = 0.05},
            {s = common .. "movement-pistol-03.ogg", t = 0.1},
            {s = common .. "movement-pistol-01.ogg", t = 1},
            {s = rottle, t = 1},
        },
    },
    ["enter_inspect_jammed"] = {
        Source = "enter_inspect_jam",
        time = 35 / 60,
        LHIK = true,
        LHIKIn = 0.1,
        LHIKOut = 0,
        SoundTable = {
            {s = rottle, t = 0},
            {s = common .. "movement-pistol-04.ogg", t = 0},
        },
    },
    ["idle_inspect_jammed"] = {
        Source = "idle_inspect_jam",
        time = 72 / 60,
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0,
    },
    ["exit_inspect_jammed"] = {
        Source = "exit_inspect_jam",
        time = 66 / 60,
        LHIK = true,
        LHIKIn = 0,
        LHIKEaseOut = 0.3,
        LHIKOut = 0.84,
        SoundTable = {
            {s = rottle, t = 0.05},
            {s = common .. "movement-pistol-03.ogg", t = 0.1},
            {s = common .. "movement-pistol-01.ogg", t = 1},
            {s = rottle, t = 1},
        },
    },
}

-- ADS animation blending, thanks fesiug --

SWEP.Hook_Think = ArcCW.UC.ADSReload

SWEP.Hook_TranslateAnimation = function(wep, anim)
    if wep.Attachments[7].Installed and (anim == "fire" or anim == "fire_empty") then
        return anim .. "_stock"
    end
end

-- Attachments --

SWEP.RejectAttachments = {
    --["uc_tp_gong"] = true
}

SWEP.Attachments = {
    {
        PrintName = "Optic",
        Slot = {"optic_lp", "uc_usp_sight"},
        DefaultAttName = "Iron Sights",
        Bone = "vm_charge",
        Offset = {
            vpos = Vector(-0.01, -.6, -.3),
            vang = Angle(90, 0, -90),
        },
        VMScale = Vector(.8,.8,.8),
        WMScale = VMScale,
        InstalledEles = {"pistol_rail"},
    },
    {
        PrintName = "Slide",
        Slot = {"uc_usp_slide"},
        DefaultAttIcon = Material("entities/att/acwatt_uc_usp_slide_default.png","mips smooth"),
        DefaultAttName = "5\" Tactical Slide",
    },
    {
        PrintName = "Caliber",
        Slot = {"uc_usp_caliber"},
        DefaultAttIcon = Material("entities/att/uc_bullets/45acp.png","mips smooth"),
        DefaultAttName = ".45 ACP",
        Bone = "vm_pivot",
        Offset = {
            vpos = Vector(3.07, -3.8, -27),
            vang = Angle(90, 0, -90),
        },
        -- DefaultFlags = {"cal_subsonic"},
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Standard Muzzle",
        Slot = {"muzzle"},
        Bone = "vm_pivot",
        Offset = {
            vpos = Vector(0, -1.46, 4.6),
            vang = Angle(90, 0, -90),
        },
        ExcludeFlags = {"usp_match"},
    },
    {
        PrintName = "Tactical",
        InstalledEles = {"tac_rail"},
        Slot = {"tac_pistol"},
        Bone = "vm_pivot",
        Offset = {
            vpos = Vector(0, -.4, 3.85),
            vang = Angle(90, 0, -90),
        },
        ExcludeFlags = {"usp_match"},
    },
    {
        PrintName = "Magazine",
        Slot = {"uc_usp_mag"},
        DefaultAttIcon = Material("entities/att/acwatt_uc_usp_mag_default.png","mips smooth"),
        DefaultAttName = "12-Round Mag",
    },
    {
        PrintName = "Stock",
        Slot = {"uc_stock", "go_stock_pistol_bt"},
        VMScale = Vector(1.1, 1.1, 1.1),
        Bone = "vm_pivot",
        Offset = {
            vpos = Vector(-0.05, 2.7, -3),
            vang = Angle(90, 0, -90),
        },
    },
    {
        PrintName = "Ammo Type",
        DefaultAttName = "\"FMJ\" Full Metal Jacket",
        DefaultAttIcon = Material("entities/att/arccw_uc_ammo_generic.png", "mips smooth"),
        Slot = "uc_ammo",
    },
    {
        PrintName = "Powder Load",
        Slot = "uc_powder",
        DefaultAttName = "Standard Load"
    },
    {
        PrintName = "Training Package",
        Slot = {"uc_tp"},
        DefaultAttName = "Basic Training"
    },
    {
        PrintName = "Internals",
        Slot = "uc_fg", -- Fire group
        DefaultAttName = "Standard Internals"
    },
    {
        PrintName = "Charm",
        Slot = {"charm", "fml_charm", "uc_usp_tp"},
        FreeSlot = true,
        Bone = "vm_charge",
        Offset = {
            vpos = Vector(0.42, 0.8, 4.6),
            vang = Angle(90, 0, -90),
        },
        VMScale = Vector(.75,.75,.75),
    },
    {
        PrintName = "Finish",
        Slot = {"uc_usp_skin"},
        DefaultAttName = "Black",
        DefaultAttIcon = Material("entities/att/acwatt_uc_usp_skin_default.png","mips smooth"),
        FreeSlot = true,
    },
}

--lua/weapons/arccw_ud_arpistol.lua:
if !file.Exists("arccw/shared/languages/ud_en.lua","LUA") then return end

include("weapons/arccw_ud_m16.lua")

SWEP.Category = "ArcCW - UC Presets"
if GetConVar("arccw_uc_presets_categorize"):GetBool() then
    SWEP.Category = "ArcCW - UC Presets Pistols"
end

SWEP.PrintName = "RBY .50" -- RUCAR 255
SWEP.TrueName = "AR-15 Pistol .50"
if GetConVar("arccw_truenames"):GetBool() then
    SWEP.PrintName = SWEP.TrueName
end

SWEP.Attachments[1].Installed = "ud_m16_rs"
SWEP.Attachments[2].Installed = "ud_m16_barrel_10in"
SWEP.Attachments[3].Installed = "ud_m16_hg_ru556"
SWEP.Attachments[5].Installed = "ud_m16_receiver_50beo"
--SWEP.Attachments[9].Installed = "ud_m16_grip_skel"
SWEP.Attachments[10].Installed = "ud_m16_stock_buffer"
-- SWEP.Attachments[11].Installed = "ud_m16_mag_20"
SWEP.Attachments[16].Installed = "ud_m16_fs_sig"

SWEP.NPCWeaponType = nil
--lua/weapons/arccw_ud_glock.lua:
return gluapack()()
--lua/weapons/arccw_ud_g24.lua:
if !file.Exists("arccw/shared/languages/ud_en.lua","LUA") then return end

include("weapons/arccw_ud_glock.lua")

SWEP.Category = "ArcCW - UC Presets"
if GetConVar("arccw_uc_presets_categorize"):GetBool() then
    SWEP.Category = "ArcCW - UC Presets Pistols"
end

SWEP.PrintName = "GEN5L"
SWEP.TrueName = "Glock 24"
if GetConVar("arccw_truenames"):GetBool() then
    SWEP.PrintName = SWEP.TrueName
end

--SWEP.Attachments[1].Installed = "uc_optic_leupold_dppro"
SWEP.Attachments[2].Installed = "ud_glock_slide_lb"
SWEP.Attachments[3].Installed = "ud_glock_frame_flared"
SWEP.Attachments[4].Installed = "ud_glock_caliber_40sw"
--lua/weapons/arccw_ud_glock.lua:
return gluapack()()
--lua/weapons/arccw_ud_m16.lua:
SWEP.Base = "arccw_base"
SWEP.Spawnable = true
SWEP.Category = "ArcCW - Urban Coalition"
SWEP.UC_CategoryPack = "1Urban Decay"
SWEP.AdminOnly = false
SWEP.UseHands = true

-- Muzzle and shell effects --

SWEP.MuzzleEffect = "muzzleflash_1"
SWEP.ShellEffect = "arccw_uc_shelleffect"
SWEP.ShellModel = "models/weapons/arccw/uc_shells/556x45.mdl"
SWEP.ShellScale = .666
SWEP.ShellPitch = 100

SWEP.MuzzleEffectAttachment = 1
SWEP.CaseEffectAttachment = 2
SWEP.CamAttachment = 3
SWEP.TracerNum = 1
SWEP.TracerCol = Color(25, 255, 25)
SWEP.TracerWidth = 2

-- Fake name --

SWEP.PrintName = "RAYCAR-0"
-- AMCAR stands for (american) Colt Assault Rifle, not Carbine!! ~Fesiug
-- shut up retard ~zenith

-- True name --

SWEP.TrueName = "M16A2"

-- Trivia --
SWEP.Trivia_Class = "Assault Rifle"
SWEP.Trivia_Desc = "Third generation of America's iconic military rifle. Army tests showed that soldiers were more likely to hit a target if they fired multiple shots, but were likely to spray in full-auto and fail to hit anything. As a result, they implemented a ratcheted three-round burst system which limited the maximum burst a soldier could fire to three shots.\n\nWell-rounded gun with no major downsides."
SWEP.Trivia_Manufacturer = "Rayter Arms Industries"
SWEP.Trivia_Calibre = "5.56x45mm NATO"
SWEP.Trivia_Mechanism = "Gas-Operated Rotating Bolt"
SWEP.Trivia_Country = "USA"
SWEP.Trivia_Year = 1959


if GetConVar("arccw_truenames"):GetBool() then
    SWEP.PrintName = SWEP.TrueName
    SWEP.Trivia_Manufacturer = "Stoner's Legacy Ltd."
end

local origDesc = SWEP.Trivia_Desc
local m4Desc = "Carbine variant of the M16 rifle. Originally designed in response to design faults in the CAR-15 family, it eventually replaced the M16 across much of the Army for its favorably low weight and comparable performance. The M4 variant has since become one of the most iconic and widespread American service rifles in the modern era.\n\nLight and versatile, but requires discipline to control."
local ncrDesc = "Standard-issue rifle of the New California Republic. Traditionally produced with a semi-automatic receiver, the wooden furniture is more readily replaceable and adds additional recoil control for maximum accuracy.\n\nWell-rounded gun with no major downsides."
local smgDesc = "Submachine gun based on the M16 rifle. Despite its similar appearance, it uses a different mechanism from its parent rifle. More accurate than other submachine guns due to its rifle frame and closed-bolt mechanism."
local blkDesc = "Aftermarket automatic variant of the M16 rifle. The .300 Blackout cartridge has a ballistic performance more akin to the 7.62x39mm Soviet cartridge, with a similarly sized projectile but shorter effective range."
local ukDesc = "AR-15 style rifles are a class of rifles linked to the M16, normally with a semi-automatic fire group for the civilian market. This one, however, has been neutered by authority of the British crown with a manual-action receiver. Bit cringe, innit?"
local arDesc = "Semi-automatic variant of the M16 series of rifles, produced for the civilian market. Wildly popular in the United States, this rifle can be seen in the hands of hobbyists, hunters and mass shooters alike.\n\nWell-rounded gun with no major downsides."
local beoDesc = "Aftermarket semi-automatic variant of the M16 rifle firing an oversized magnum cartridge. Provides extremely high stopping power at close range."
local carDesc = "Carbine variant of the M16 rifle, short enough to be classified as a submachine gun. Its features influenced the US Army's interest in the M4 Carbine, which went on to become their new standard rifle. Due to the small barrel, rifles of this family have high maneuverability but poor range compared to their parent platform."
local a1Desc = "Second generation of America's iconic military rifle. Developed to address problems with the original M16, which suffered notoriously frequent jamming that could get its wielder killed. The revised model evolved a positive reputation with those who used it, and is now a universal symbol of the Vietnam War.\n\nA well-rounded rifle, but difficult to control without trigger discipline - something the A2 model eventually addressed."
local a3Desc = "Variant of the M16A2 with the original full-automatic trigger group, relegated to niche roles in the US Army. Well-rounded gun with no major downsides."
local lmgDesc = "Configuration of the M16 designed for a light machine gun role, used vaguely within the Marine Corps before the adoption of the Minimi. Heavier than the standard platform, but the integral bipod can be deployed onto surfaces for excellent recoil control."
local patriotDesc = "An assault pistol developed for The Boss. The feeder mechanism inside the drum magazine forms an \"∞\" shape.\n\nThe bottomless magazine more than makes up for the awkwardness of the configuration."

-- Weapon slot --

SWEP.Slot = 2

-- Weapon's manufacturer real name --

if GetConVar("arccw_truenames"):GetBool() then
    SWEP.PrintName = SWEP.TrueName
    SWEP.Trivia_Manufacturer = "Colt's Manufacturing Company"
end

-- Viewmodel / Worldmodel / FOV --

SWEP.ViewModel = "models/weapons/arccw/c_ud_m16.mdl"
SWEP.WorldModel = "models/weapons/arccw/c_ud_m16.mdl"
SWEP.ViewModelFOV = 80
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

-- Damage --

SWEP.Damage = ArcCW.UC.StdDmg["556"].max
SWEP.DamageMin = ArcCW.UC.StdDmg["556"].min
SWEP.RangeMin = 50
SWEP.Range = 350 -- 4 shot until ~250m

SWEP.Penetration = ArcCW.UC.StdDmg["556"].pen
SWEP.DamageType = DMG_BULLET
SWEP.ShootEntity = nil
SWEP.MuzzleVelocity = 960
SWEP.PhysBulletMuzzleVelocity = 960

SWEP.BodyDamageMults = ArcCW.UC.BodyDamageMults

-- Mag size --

SWEP.ChamberSize = 1
SWEP.Primary.ClipSize = 30
SWEP.ExtendedClipSize = 40
SWEP.ReducedClipSize = 20

-- Recoil --

SWEP.Recoil = 0.5
SWEP.RecoilSide = 0.25

SWEP.RecoilRise = 0.1
SWEP.RecoilPunch = 1
SWEP.VisualRecoilMult = 1
SWEP.MaxRecoilBlowback = 1
SWEP.MaxRecoilPunch = 1
SWEP.RecoilPunchBack = 1

SWEP.Sway = 0.5

-- Firerate / Firemodes --

SWEP.Delay = 60 / 900
SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = -3,
        PostBurstDelay = 0.1,
        RunawayBurst = false, -- https://en.wikipedia.org/wiki/Burst_mode_(weapons)
    },
    {
        Mode = 1,
    },
    {
        Mode = 0
    }
}

SWEP.ShootPitch = 100
SWEP.ShootVol = 120
SWEP.ShootPitchVariation = 0

SWEP.ProceduralRegularFire = false
SWEP.ProceduralIronFire = false

SWEP.ReloadInSights = true

-- NPC --

SWEP.NPCWeaponType = "weapon_ar2"
SWEP.NPCWeight = 60

-- Accuracy --

SWEP.AccuracyMOA = 4
SWEP.HipDispersion = 800
SWEP.MoveDispersion = 200
SWEP.JumpDispersion = 1000

SWEP.Primary.Ammo = "smg1"
SWEP.MagID = "m16"

SWEP.HeatCapacity = 150
SWEP.HeatDissipation = 10
SWEP.HeatDelayTime = 3

SWEP.MalfunctionMean = 200
SWEP.MalfunctionTakeRound = false

-- Speed multipliers --

SWEP.SpeedMult = 0.925
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Length --

SWEP.BarrelLength = 48
SWEP.ExtraSightDist = 2

-- Ironsights / Customization / Poses --

SWEP.HolsterPos = Vector(0.5, -1, 1.2)
SWEP.HolsterAng = Angle(-8.5, 8, -10)

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"

SWEP.IronSightStruct = {
     Pos = Vector(-2.815, 0, 1.3),
     Ang = Angle(0, 0, 0),
     Magnification = 1.1,
     SwitchToSound = "",
}

SWEP.ActivePos = Vector(0.33, -2, 1.33)
SWEP.ActiveAng = Angle(0, 0, -3)

-- SWEP.CustomizePos = Vector(5, -2, -2)
-- SWEP.CustomizeAng = Angle(15, 25, 0)
SWEP.CustomizePos = Vector(0, 0, 0)
SWEP.CustomizeAng = Angle(0, 0, 0)

SWEP.CrouchPos = Vector(-2.5, -2, -0.6)
SWEP.CrouchAng = Angle(0, 0, -14)

SWEP.BarrelOffsetHip = Vector(2, 0, -5)

SWEP.MirrorVMWM = true
SWEP.WorldModelOffset = {
    pos        =    Vector(-8.5, 4, -5),
    ang        =    Angle(-12, 0, 180),
    bone    =    "ValveBiped.Bip01_R_Hand",
    --scale = .85
}

-- Firing sounds --

local path = ")weapons/arccw_ud/m16/"
local common = ")/arccw_uc/common/"

SWEP.ShootSound = {
    path .. "fire-01.ogg",
    path .. "fire-02.ogg",
    path .. "fire-03.ogg",
    path .. "fire-04.ogg",
    path .. "fire-05.ogg",
    path .. "fire-06.ogg"
}
SWEP.ShootSoundSilenced = {
    path .. "fire-sup-01.ogg",
    path .. "fire-sup-02.ogg",
    path .. "fire-sup-03.ogg",
    path .. "fire-sup-04.ogg",
    path .. "fire-sup-05.ogg",
    path .. "fire-sup-06.ogg"
}

SWEP.DistantShootSound = nil
SWEP.DistantShootSoundSilenced = nil
SWEP.ShootDrySound = path .. "dryfire.ogg"

local tail = ")/arccw_uc/common/556x45/"

SWEP.DistantShootSoundOutdoors = {
    tail .. "fire-dist-556x45-rif-ext-01.ogg",
    tail .. "fire-dist-556x45-rif-ext-02.ogg",
    tail .. "fire-dist-556x45-rif-ext-03.ogg",
    tail .. "fire-dist-556x45-rif-ext-04.ogg",
    tail .. "fire-dist-556x45-rif-ext-05.ogg",
    tail .. "fire-dist-556x45-rif-ext-06.ogg"
}
SWEP.DistantShootSoundIndoors = {
    common .. "fire-dist-int-rifle-01.ogg",
    common .. "fire-dist-int-rifle-02.ogg",
    common .. "fire-dist-int-rifle-03.ogg",
    common .. "fire-dist-int-rifle-04.ogg",
    common .. "fire-dist-int-rifle-05.ogg",
    common .. "fire-dist-int-rifle-06.ogg"
}
SWEP.DistantShootSoundOutdoorsSilenced = {
    common .. "sup-tail-01.ogg",
    common .. "sup-tail-02.ogg",
    common .. "sup-tail-03.ogg",
    common .. "sup-tail-04.ogg",
    common .. "sup-tail-05.ogg",
    common .. "sup-tail-06.ogg",
    common .. "sup-tail-07.ogg",
    common .. "sup-tail-08.ogg",
    common .. "sup-tail-09.ogg",
    common .. "sup-tail-10.ogg"
}
SWEP.DistantShootSoundIndoorsSilenced = {
    common .. "fire-dist-int-pistol-light-01.ogg",
    common .. "fire-dist-int-pistol-light-02.ogg",
    common .. "fire-dist-int-pistol-light-03.ogg",
    common .. "fire-dist-int-pistol-light-04.ogg",
    common .. "fire-dist-int-pistol-light-05.ogg",
    common .. "fire-dist-int-pistol-light-06.ogg"
}
SWEP.DistantShootSoundOutdoorsVolume = 1
SWEP.DistantShootSoundIndoorsVolume = 1
SWEP.Hook_AddShootSound = ArcCW.UC.InnyOuty

-- Bodygroups --

SWEP.BulletBones = {
    [2] = "m16_bullets1",    [3] = "m16_bullets2"
}

SWEP.DefaultBodygroups = "00000000000000000000000"

SWEP.AttachmentElements = {

    ["ud_m16_mag_20"] = {
        VMBodygroups = {{ind = 2, bg = 1}},
    },
    ["ud_m16_mag_40"] = {
        VMBodygroups = {{ind = 2, bg = 2}},
    },
    ["ud_m16_pmag"] = {
        VMBodygroups = {{ind = 2, bg = 9}},
    },
    ["ud_m16_mag_60"] = {
        VMBodygroups = {{ind = 2, bg = 3}},
    },
    ["ud_m16_mag_100"] = {
        VMBodygroups = {{ind = 2, bg = 4}},
    },
    ["ud_m16_9mm_mag"] = {
        VMBodygroups = {{ind = 2, bg = 5}},
    },
    ["ud_m16_9mm_mag_32"] = {
        VMBodygroups = {{ind = 2, bg = 6}},
    },
    ["ud_m16_mag_50beo"] = {
        VMBodygroups = {{ind = 2, bg = 8}},
    },
    ["ud_m16_mag_50beo_12"] = {
        VMBodygroups = {{ind = 2, bg = 0}},
    },

    ["upper_flat"] = {
        -- handled by code
        --[[]
        VMBodygroups = {
            {ind = 1, bg = 1},
            {ind = 3, bg = 3}
        },
        ]]
    },
    ["upper_classic"] = {
        VMBodygroups = {
            {ind = 1, bg = 3},
        },
    },
    ["rail_fg"] = {
        VMBodygroups = {{ind = 9, bg = 1}}
    },

    ["stock_231_ex"] = {
        VMBodygroups = {{ind = 7, bg = 1}},
    },
    ["stock_231_in"] = {
        VMBodygroups = {{ind = 7, bg = 2}},
    },
    ["stock_231_tube"] = {
        VMBodygroups = {{ind = 7, bg = 3}},
    },
    ["stock_607_ex"] = {
        VMBodygroups = {{ind = 7, bg = 4}},
    },
    ["stock_607_in"] = {
        VMBodygroups = {{ind = 7, bg = 5}},
    },
    ["stock_608"] = {
        VMBodygroups = {{ind = 7, bg = 6}},
    },
    ["stock_carbine_ex"] = {
        VMBodygroups = {{ind = 7, bg = 7}},
    },
    ["stock_carbine_in"] = {
        VMBodygroups = {{ind = 7, bg = 8}},
    },
    ["stock_wood"] = {
        VMBodygroups = {{ind = 7, bg = 9}},
    },
    ["stock_adar"] = {
        VMBodygroups = {
            {ind = 7, bg = 10},
            {ind = 8, bg = 4}
        },
    },
    ["stock_ru556"] = {
        VMBodygroups = {{ind = 7, bg = 11}},
    },
    ["grip_ergo"] = {
        VMBodygroups = {{ind = 8, bg = 1}},
    },
    ["grip_skel"] = {
        VMBodygroups = {{ind = 8, bg = 2}},
    },
    ["grip_wood"] = {
        VMBodygroups = {{ind = 8, bg = 3}},
    },

    ["gasblock_carbine"] = {
        VMBodygroups = {{ind = 6, bg = 3}},
    },
    ["fs_adar"] = {
        VMBodygroups = {{ind = 6, bg = 4}},
    },
    ["remove_lug"] = {
        VMBodygroups = {{ind = 12, bg = 1}},
    },

    ["mount_14"] = {
        AttPosMods = {
            [8] = {
                vpos = Vector(0, 0.3, 17.5),
                vang = Angle(90, 0, -90),
            },
        },
    },
    ["mount_11"] = {
        AttPosMods = {
            [8] = {
                vpos = Vector(0.6, -0.3, 14.2),
                vang = Angle(90, 0, 0),
            },
        },
    },
    ["mount_tactical"] = {
        AttPosMods = {
            [8] = {
                vpos = Vector(-1, -.35, 11.5),
                vang = Angle(-90, 180, 0),
                wang = Angle(90, 0, 0),
            },
        },
        ExcludeFlags = {}
    },
    -- ["mount_tactical_short"] = {
    --     AttPosMods = {
    --         [8] = {
    --             vpos = Vector(-1, -.35, 11.5),
    --             vang = Angle(-90, 180, 0),
    --             wang = Angle(90, 0, 0),
    --         },
    --     },
    --     AttPosMods_Priority = 2,
    --     RequireFlags = {"barrel_short"}
    -- },

    ["barrel_14"] = {
        VMBodygroups = {
            {ind = 4, bg = 1},
            {ind = 6, bg = 2},
        },
        AttPosMods = {
            [4] = {
                vpos = Vector(0, -0.33, 18.85),
                vang = Angle(90, 0, -90),
            },
            [16] = {
                vpos = Vector(0, -1.65, 12.5), -- 21.75 or 15.75
                vang = Angle(90, 0, -90),
            },
        }
    },
    ["barrel_11"] = {
        VMBodygroups = {
            {ind = 4, bg = 4},
            {ind = 6, bg = 2},
        },
        AttPosMods = {
            [4] = {
                vpos = Vector(0, -0.33, 15.7),
                vang = Angle(90, 0, -90),
            },
            [16] = {
                vpos = Vector(0, -1.65, 12.5), -- 21.75 or 15.75
                vang = Angle(90, 0, -90),
            },
        }
    },
    ["barrel_fpw"] = {
        VMBodygroups = {
            {ind = 4, bg = 2},
            {ind = 6, bg = 5},
        },
        AttPosMods = {
            [4] = {
                vpos = Vector(0, -0.07, 21.3),
                vang = Angle(90, 0, -90),
            },
        }
    },
    ["barrel_11_ru556"] = {
        VMBodygroups = {
            {ind = 4, bg = 4},
            {ind = 6, bg = 5},
        },
        AttPosMods = {
            [3] = {
                vpos = Vector(0, -0.07, 21.3),
                vang = Angle(90, 0, -90),
            },
            [6] = {
                vpos = Vector(1.15, 0, 17.9),
                vang = Angle(90, 0, 0),
            },
            [16] = {
                vpos = Vector(0, -1.65, 12.5), -- 21.75 or 15.75
                vang = Angle(90, 0, -90),
            },
        }
    },

    ["hg_m16a4_ris"] = {
        VMBodygroups = {
            {ind = 5, bg = 2},
        },
        AttPosMods = {
            [5] = {
                vpos = Vector(-0.1, 1.05, 12),
                vang = Angle(90, 0, -90),
            },
            [6] = {
                vpos = Vector(1.41, -.1, 20),
                vang = Angle(90, 0, 0),
            },
            [16] = {
                vpos = Vector(0, -1.75, 21.75), -- 21.75 or 15.75
                vang = Angle(90, 0, -90),
            },
        }
    },
    ["hg_m4a1_ris"] = {
        VMBodygroups = {
            {ind = 5, bg = 5},
        },
        AttPosMods = {
            [5] = {
                vpos = Vector(0, 1.4, 12),
                vang = Angle(90, 0, -90),
            },
            [6] = {
                vpos = Vector(-1.41, -.2, 14),
                vang = Angle(90, 0, 180),
            },
            [15] = {
                vpos = Vector(0, -1.75, 15.75), -- 21.75 or 15.75
                vang = Angle(90, 0, -90),
            },
        },
    },
    ["hg_ru556"] = {
        -- VMBodygroups = {
        --     {ind = 5, bg = 7},
        -- },
        AttPosMods = {
            -- [5] = {
            --     vpos = Vector(-0.1, 1.05, 12),
            --     vang = Angle(90, 0, -90),
            -- },
            -- [6] = {
            --     vpos = Vector(1.1, 0, 14),
            --     vang = Angle(90, 0, 0),
            -- },
            [16] = {
                vpos = Vector(0, -1.65, 12.5), -- 21.75 or 15.75
                vang = Angle(90, 0, -90),
            },
        },
    },
    ["hg_m4a1"] = {
        VMBodygroups = {
            {ind = 5, bg = 4},
        }
    },
    ["hg_cqbr"] = {
        VMBodygroups = {
            {ind = 5, bg = 4},
        },
    },
    ["hg_adar"] = {
        VMBodygroups = {
            {ind = 5, bg = 8},
        },
    },
    ["hg_fpw"] = {
        VMBodygroups = {
            {ind = 5, bg = 6},
            --{ind = 6, bg = 4},
        }
    },
    ["hg_m16a1"] = {
        VMBodygroups = {
            {ind = 5, bg = 1},
        }
    },
    ["hg_m16a1_wood"] = {
        VMBodygroups = {
            {ind = 5, bg = 1},
        },
        VMSkin = 1
    },
    ["ud_m16_hg_heat"] = {
        VMElements = {
            {
                Model = "models/weapons/arccw/atts/m203iron.mdl",
                Bone = "m16_parent",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(0, -1.2, 14.9),
                    ang = Angle(90, 0, -90),
                }
            }
        },
        UC_UseClassicM203Mount = true,
    },
    ["hg_m605"] = {
        VMBodygroups = {
            {ind = 5, bg = 1},
            {ind = 4, bg = 1},
        },
        AttPosMods = {
            [3] = {
                vpos = Vector(0, -0.05, 25.58),
                vang = Angle(90, 0, -90),
            },
            [6] = { -- also has no rail
                vpos = Vector(0, 0.9, 22.2),
                vang = Angle(90, 0, -90),
            },
        }
    },
    ["hg_m605_wood"] = {
        VMBodygroups = {
            {ind = 5, bg = 1},
            {ind = 4, bg = 1},
        },
        AttPosMods = {
            [3] = {
                vpos = Vector(0, 0, 25),
                vang = Angle(90, 0, -90),
            },
            [6] = { -- also has no rail
                vpos = Vector(0, 0.8, 22),
                vang = Angle(90, 0, -90),
            },
        },
        VMSkin = 1
    },
    ["hg_lmg"] = {
        VMBodygroups = {
            {ind = 5, bg = 3},
        }
    },
    ["hg_sd"] = {
        VMBodygroups = {
            {ind = 5, bg = 9},
            {ind = 4, bg = 3},
            {ind = 6, bg = 5}
        },
        AttPosMods = { -- no rail, just pretend it's mounted to something
            -- [8] = {
            --     vpos = Vector(0, 0.7, 17.5),
            --     vang = Angle(90, 0, -90),
            -- },
            [16] = {
                vpos = Vector(0, -1.65, 11.5), -- 21.75 or 15.75
                vang = Angle(90, 0, -90),
            },
        }
    },

    ["ud_m16_upper_charm"] = {
        AttPosMods = {
            [1] = {
                vpos = Vector(0, -4, 3),
                vang = Angle(90, 0, -90),
                SlideAmount = {
                    vmin = Vector(0, -3.4, 3 - 1.5),
                    vmax = Vector(0, -3.4, 3 + 1.5),
                }
            },
        },
    },
    ["ud_m16_upper_charm2"] = {
        AttPosMods = {
            [1] = {
                vpos = Vector(0, -4.1, 3.5),
                vang = Angle(90, 0, -90),
                SlideAmount = {
                    vmin = Vector(0, -3.5, 3.5 - 2),
                    vmax = Vector(0, -3.5, 3.5 + 1),
                }
            },
        },
    },
    ["bravo_dicks_going_fart"] = {
        AttPosMods = {
            [8] = {
                vpos = Vector(0.25, -1.4, 12),
                vang = Angle(90, 0, 90),
            },
        },
    },

    ---- Cut content
    ["hg_stub"] = {
        VMBodygroups = {
            {ind = 5, bg = 7},
        },
        AttPosMods = {
            [3] = {
                vpos = Vector(0, -0.35, 7),
                vang = Angle(90, 0, -90)
            },
            [6] = {
                vpos = Vector(1.1, -0.4, 9),
                vang = Angle(90, 0, 0),
            },
        }
    },
    ["barrel_stub"] = {
        VMBodygroups = {
            {ind = 4, bg = 4},
            {ind = 6, bg = 4},
        }
    },
    ["hg_smg"] = {
        VMBodygroups = {
            {ind = 5, bg = 0},
        }
    },
    ["m16_strap"] = {
        VMBodygroups = {
             {ind = 13, bg = 1},
        },
    },
}

-- Animations --

SWEP.Hook_Think = ArcCW.UC.ADSReload

local sr_pmag = {
	[path .. "magout_empty.ogg"] = path .. "pmagout.ogg",
	[path .. "magin.ogg"] = path .. "pmagin.ogg",
}

local pmag1, pmag2 = {}, {"ud_m16_pmag"}
SWEP.Hook_TranslateSound = function(wep, data)
	if wep:CheckFlags(pmag1, pmag2) and sr_pmag[data] then return sr_pmag[data] end
end

local rottle = {common .. "cloth_1.ogg", common .. "cloth_2.ogg", common .. "cloth_3.ogg", common .. "cloth_4.ogg", common .. "cloth_6.ogg", common .. "rattle.ogg"}
local ratel = {common .. "rattle1.ogg", common .. "rattle2.ogg", common .. "rattle3.ogg"}

SWEP.Animations = {
    ["ready"] = {
        Source = "fix",
        Time = 45 / 30,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKEaseIn = 0.4,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.4,
        SoundTable = {
            {s = common .. "raise.ogg", t = 0},
            {s = common .. "rattle.ogg", t = 0.2},
            {s = path .. "chback.ogg",   t = 0.15},
            {s = common .. "cloth_4.ogg",  t = 0.5},
            {s = path .. "chamber.ogg",  t = 0.5},
        },
        ProcDraw = true,
    },
    ["idle"] = {
        Source = "idle",
    },
    ["idle_empty"] = {
        Source = "idle_empty",
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {s = common .. "raise.ogg", t = 0},
            {s = common .. "shoulder.ogg", t = 0.15},
            {s = ratel, t = 0.2},
        },
    },
    ["draw_empty"] = {
        Source = "draw_empty",
        Time = 20 / 30,
        SoundTable = {
            {s = common .. "raise.ogg", t = 0},
            {s = common .. "shoulder.ogg", t = 0.15},
            {s = ratel, t = 0.2},
        },
    },
    ["holster"] = {
        Source = "holster",
        LHIK = true,
        LHIKIn = 0.3,
        LHIKEaseIn = 0.4,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.4,
        SoundTable = {
            {s = ratel, t = 0},
            {s = common .. "cloth_6.ogg", t = 0.2},
        },
    },
    ["holster_empty"] = {
        Source = "holster_empty",
        Time = 20 / 30,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKEaseIn = 0.4,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.4,
        SoundTable = {
            {s = ratel, t = 0},
            {s = common .. "cloth_6.ogg", t = 0.2},
        },
    },
    ["trigger"] = {
        Source = "idle",
        MinProgress = .1,
        SoundTable = {
            {s = ")weapons/arccw_ud/uzi/prefire.ogg",         t = 0, c = ci},
        },
    },
    ["fire"] = {
        Source = "fire",
        Time = 13 / 30,
        ShellEjectAt = 0.01,
        SoundTable = {{ s = {path .. "mech-01.ogg", path .. "mech-02.ogg", path .. "mech-03.ogg", path .. "mech-04.ogg", path .. "mech-05.ogg", path .. "mech-06.ogg"}, t = 0, v = 0.25 }},
    },
    ["fire_iron"] = {
        Source = "fire",
        Time = 13 / 30,
        ShellEjectAt = 0.01,
        SoundTable = {{ s = {path .. "mech-01.ogg", path .. "mech-02.ogg", path .. "mech-03.ogg", path .. "mech-04.ogg", path .. "mech-05.ogg", path .. "mech-06.ogg"}, t = 0 }},
    },
    ["fire_empty"] = {
        Source = "fire_empty",
        Time = 13 / 30,
        ShellEjectAt = 0.01,
        SoundTable = {
            {s = path .. "mech_last.ogg", t = 0}, -- Temporary
        },
    },
    ["fire_iron_empty"] = {
        Source = "fire_empty",
        Time = 13 / 30,
        ShellEjectAt = 0.01,
        SoundTable = {
            {s = path .. "mech_last.ogg", t = 0}, -- Temporary
        },
    },

    ["fire_cycle"] = {
        Source = "fire",
        Time = 13 / 30,
    },

    ["cycle"] = {
        Source = "fix",
        Time = 36 / 30 * 0.7,
        ShellEjectAt = 0.3,
        LHIK = true,
        LHIKIn = 0.3 * 0.7,
        LHIKEaseIn = 0.4 * 0.7,
        LHIKEaseOut = 0.15 * 0.7,
        LHIKOut = 0.4 * 0.7,
        SoundTable = {
            {s = path .. "chback.ogg",   t = 0.05},
            {s = common .. "cloth_4.ogg",  t = 0.2},
            {s = path .. "chamber.ogg",  t = 0.3},
        },
    },

    ["fix"] = {
        Source = "fix",
        Time = 45 / 30,
        ShellEjectAt = false,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKEaseIn = 0.4,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.4,
        SoundTable = {
            {s = path .. "chback.ogg",   t = 0.15},
            {s = common .. "cloth_4.ogg",  t = 0.5},
            {s = path .. "chamber.ogg",  t = 0.5},
        },
    },
    ["fix_empty"] = {
        Source = "fix_empty",
        Time = 45 / 30,
        ShellEjectAt = false,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKEaseIn = 0.4,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.4,
        SoundTable = {
            {s = path .. "chback.ogg",   t = 0.15},
            {s = common .. "cloth_4.ogg",  t = 0.5},
            {s = path .. "ch_forward_empty.ogg",  t = 0.5},
        },
    },

    -- 30 Round Reloads --

    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        Time = 71 / 30,
        MinProgress = 1.5,
        LastClip1OutTime = 0.9,
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.2,
        LHIKEaseOut = 0.4,
        LHIKOut = 0.7,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = common .. "magpouch_gear.ogg", t = 0.2, v = 0.5},
            {s = ratel, t = 0.25},
            {s = path .. "magout_empty.ogg", 	 t = 0.23},
            {s = ratel, t = 0.5},
            {s = path .. "struggle.ogg",    t = 1, v = 0.4},
            {s = path .. "magin.ogg",    t = 0.97},
            {s = ratel, t = 1.1},
            {s = rottle,  t = 1.15},
            {s = common .. "grab-polymer.ogg", t = 1.77, v = 0.25},
            {s = common .. "rattle_b2i_rifle.ogg", t = 1.7},
            {s = common .. "shoulder.ogg", t = 1.8},
        },
    },
    ["reload_empty"] = {
        Source = "reload_empty",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        Time = 87 / 30,
        MinProgress = 2,
        LastClip1OutTime = 0.7,
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.2,
        LHIKEaseOut = 0.4,
        LHIKOut = 0.9,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = ratel, t = 0.25},
            {s = common .. "magpouch_gear.ogg", t = 0.1, v = 0.5},
            {s = path .. "magout_empty.ogg", 	 t = 0.2},
            {s = ratel, t = 0.5},
            {s = common .. "rifle_magdrop.ogg",  t = 0.65},
            {s = path .. "struggle.ogg",    t = 0.95, v = 0.4},
            {s = path .. "magin.ogg",    t = 0.95},
            {s = ratel, t = 1.1},
            {s = rottle,  t = 1.39},
            {s = path .. "boltdrop.ogg", t = 1.7},
            {s = ratel, t = 1.9},
            {s = common .. "rattle_b2i_rifle.ogg", t = 2.0},
            {s = common .. "grab-polymer.ogg", t = 2.1, v = 0.35},
            {s = common .. "shoulder.ogg", t = 2.1},
        },
    },

    -- 20 Round Reloads --

    ["reload_20"] = {
        Source = "reload_20",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        Time = 71 / 30,
        MinProgress = 1.5,
        LastClip1OutTime = 0.9,
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.2,
        LHIKEaseOut = 0.4,
        LHIKOut = 0.7,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = ratel, t = 0.05},
            {s = path .. "magout_empty.ogg", 	 t = 0.09},
            {s = common .. "magpouch_gear.ogg", t = 0.1},
            {s = rottle,  t = 0.75},
            {s = ratel, t = 0.85},
            {s = path .. "struggle.ogg",    t = 0.9, v = 0.4},
            {s = path .. "magin.ogg",    t = 0.95},
            {s = rottle,  t = 1.1},
            {s = ratel, t = 1.125},
            {s = common .. "rattle_b2i_rifle.ogg", t = 1.65},
            {s = common .. "grab-polymer.ogg", t = 1.7, v = 0.25},
            {s = common .. "shoulder.ogg", t = 1.75},
        },
    },
    ["reload_empty_20"] = {
        Source = "reload_empty_20",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        Time = 86 / 30,
        MinProgress = 2,
        LastClip1OutTime = 0.7,
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.2,
        LHIKEaseOut = 0.3,
        LHIKOut = 0.8,
        SoundTable = {
            {s = common .. "magpouch_gear.ogg", t = 0},
            {s = rottle, t = 0.01},
            {s = ratel, t = 0.05},
            {s = path .. "magout_empty.ogg", 	 t = 0.075},
            {s = rottle, t = 0.75},
            {s = ratel, t = 0.9},
            {s = common .. "rifle_magdrop.ogg",  t = 0.65},
            {s = path .. "struggle.ogg",    t = 0.8, v = 0.4},
            {s = path .. "magin.ogg",    t = 0.85},
            {s = rottle, t = 1.4},
            {s = ratel, t = 1.4},
            {s = path .. "chamber_press.ogg", t = 1.72},
            {s = common .. "rattle_b2i_rifle.ogg", t = 1.95},
            {s = common .. "grab-polymer.ogg", t = 2.075, v = 0.25},
            {s = common .. "shoulder.ogg", t = 2.13},
        },
    },

    -- 40 Round Reloads --

    ["reload_40"] = {
        Source = "reload_40",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        Time = 71 / 30,
        MinProgress = 1.5,
        LastClip1OutTime = 0.9,
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.2,
        LHIKEaseOut = 0.4,
        LHIKOut = 0.7,
        SoundTable = {
            {s = rottle, t = 0.0},
            {s = ratel, t = 0.1},
            {s = path .. "magout_empty.ogg", 	 t = 0.2},
            {s = common .. "magpouch_gear.ogg", t = 0.25},
            {s = rottle, t = 0.75},
            {s = ratel, t = 0.8},
            {s = path .. "struggle.ogg",    t = 0.95, v = 0.4},
            {s = path .. "magin.ogg",    t = 1.0},
            {s = rottle, t = 1.1},
            {s = ratel, t = 1.25},
            {s = common .. "rattle_b2i_rifle.ogg", t = 1.65},
            {s = common .. "shoulder.ogg", t = 1.75},
        },
    },
    ["reload_empty_40"] = {
        Source = "reload_empty_40",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        Time = 85 / 30,
        MinProgress = 2,
        LastClip1OutTime = 0.7,
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.2,
        LHIKEaseOut = 0.4,
        LHIKOut = 0.8,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = path .. "magout_empty.ogg", 	 t = 0.2},
            {s = common .. "magpouch_gear.ogg", t = 0.25},
            {s = rottle,  t = 0.75},
            {s = common .. "rifle_magdrop.ogg",  t = 0.8},
            {s = path .. "struggle.ogg",    t = 1.0, v = 0.4},
            {s = path .. "magin.ogg",    t = 1.05},
            {s = rottle,  t = 1.475},
            {s = ratel,  t = 1.475},
            {s = path .. "boltdrop.ogg", t = 1.78},
            {s = common .. "rattle_b2i_rifle.ogg", t = 2.1},
            {s = common .. "shoulder.ogg", t = 2.2},
        },
    },

    -- 60 Round Reloads --

    ["reload_60"] = {
        Source = "reload_60",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        Time = 71 / 30,
        MinProgress = 1.5,
        LastClip1OutTime = 0.9,
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.2,
        LHIKEaseOut = 0.4,
        LHIKOut = 0.7,
        SoundTable = {
            {s = rottle, t = 0.0},
            {s = common .. "magpouch_gear.ogg", t = 0.2},
            {s = path .. "magout_empty.ogg", 	 t = 0.25},
            {s = rottle, t = 0.75},
            {s = path .. "struggle.ogg",    t = 1.0, v = 0.4},
            {s = path .. "magin.ogg",    t = 1.1},
            {s = rottle, t = 1.1},
            {s = common .. "grab-polymer.ogg", t = 1.78, v = 0.25},
            {s = common .. "rattle_b2i_rifle.ogg", t = 1.8},
            {s = common .. "shoulder.ogg", t = 1.9},
        },
    },
    ["reload_empty_60"] = {
        Source = "reload_empty_60",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        Time = 85 / 30,
        MinProgress = 2,
        LastClip1OutTime = 0.7,
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.2,
        LHIKEaseOut = 0.4,
        LHIKOut = 0.8,
        SoundTable = {
            {s = rottle, t = 0.0},
            {s = common .. "magpouch_gear.ogg", t = 0.2},
            {s = path .. "magout_empty.ogg", 	 t = 0.25},
            {s = rottle, t = 0.75},
            {s = common .. "rifle_magdrop.ogg",  t = 0.8},
            {s = path .. "struggle.ogg",    t = 1.0, v = 0.4},
            {s = path .. "magin.ogg",    t = 1.1},
            {s = rottle, t = 1.475},
            {s = ratel, t = 1.475},
            {s = path .. "boltdrop.ogg", t = 1.8},
            {s = common .. "rattle_b2i_rifle.ogg", t = 2.1},
            {s = common .. "grab-polymer.ogg", t = 2.15, v = 0.25},
            {s = common .. "shoulder.ogg", t = 2.2},
        },
    },

    -- 100 Round Reloads --

    ["reload_100"] = {
        Source = "reload_100",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        Time = 71 / 30,
        MinProgress = 1.75,
        LastClip1OutTime = 0.9,
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.2,
        LHIKEaseOut = 0.3,
        LHIKOut = 0.5,
        SoundTable = {
            {s = rottle, t = 0.0},
            {s = path .. "magout_empty.ogg", 	 t = 0.2},
            {s = rottle, t = 0.75},
            {s = path .. "struggle.ogg",    t = 0.95, v = 0.4},
            {s = path .. "magin.ogg",    t = 1.05},
            {s = rottle, t = 1.1},
            {s = path .. "magtap.ogg",   t = 1.59},
            {s = common .. "cloth_4.ogg",  t = 1.65},
            {s = common .. "rattle_b2i_rifle.ogg", t = 1.8},
            {s = common .. "grab-polymer.ogg", t = 1.85, v = 0.25},
            {s = common .. "shoulder.ogg", t = 2.0},
        },
    },
    ["reload_empty_100"] = {
        Source = "reload_empty_100",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        Time = 90 / 30,
        MinProgress = 2.5,
        LastClip1OutTime = 0.7,
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.2,
        LHIKEaseOut = 0.3,
        LHIKOut = 0.6,
        SoundTable = {
            {s = rottle, t = 0.0},
            {s = path .. "magout_empty.ogg", 	 t = 0.2},
            {s = rottle, t = 0.75},
            {s = common .. "magdrop.ogg",  t = 0.65},
            {s = path .. "struggle.ogg",    t = 0.95, v = 0.4},
            {s = path .. "magin.ogg",    t = 1.05},
            {s = path .. "magtap.ogg",   t = 1.59},
            {s = rottle, t = 1.75},
            {s = path .. "chback.ogg",   t = 2.0},
            {s = common .. "cloth_4.ogg",  t = 2.05},
            {s = path .. "chamber.ogg",  t = 2.22},
            {s = common .. "rattle_b2i_rifle.ogg", t = 2.5},
            {s = common .. "grab-polymer.ogg", t = 2.55, v = 0.25},
            {s = common .. "shoulder.ogg", t = 2.6},
        },
    },

    -- 9mm 32 Round Reloads --

    ["reload_9mm"] = {
        Source = "reload_9mm",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        Time = 70 / 30,
        MinProgress = 1.5,
        LastClip1OutTime = 0.9,
        LHIK = true,
        LHIKIn = 0.4,
        LHIKEaseIn = 0.4,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.5,
        SoundTable = {
            {s = rottle, t = 0.0},
            {s = common .. "magpouch.ogg", t = 0.15},
            {s = "weapons/arccw_ud/uzi/" .. "magout.ogg", 	 t = 16 / 30},
            {s = rottle, t = 0.75},
            {s = "weapons/arccw_ud/uzi/" .. "magin.ogg",    t = 27 / 30},
            {s = rottle, t = 1.1},
            {s = common .. "magpouchin.ogg", t = 1.55},
            {s = common .. "shoulder.ogg", t = 1.93},
        },
    },
    ["reload_empty_9mm"] = {
        Source = "reload_empty_9mm",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        Time = 80 / 30,
        MinProgress = 2,
        LastClip1OutTime = 0.7,
        LHIK = true,
        LHIKIn = 0.1,
        LHIKEaseIn = 0.1,
        LHIKEaseOut = 0.4,
        LHIKOut = 0.9,
        SoundTable = {
            {s = rottle, t = 0.0},
            {s = "weapons/arccw_ud/uzi/" .. "magout.ogg", 	 t = 0.1},
            {s = common .. "magpouch.ogg", t = 0.45},
            {s = rottle, t = 0.75},
            {s = "weapons/arccw_ud/uzi/" .. "magin.ogg",    t = 0.8},
            {s = path .. "chamber_press.ogg", t = 1.7},
            {s = rottle, t = 1.39},
            {s = common .. "shoulder.ogg", t = 2.15},
        },
    },


    ["enter_inspect"] = {
        Source = "inspect_enter",
        -- time = 35 / 60,
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 2.5,
        SoundTable = {
            {s = rottle, t = 0},
            {s = common .. "movement-rifle-02.ogg", t = 0.1},
        },
    },
    ["idle_inspect"] = {
        Source = "inspect_loop",
        -- time = 72 / 60,
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 999, -- maybe im dumb
    },
    ["exit_inspect"] = {
        Source = "inspect_exit",
        -- time = 66 / 60,
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 999, -- maybe im dumb
        SoundTable = {
            {s = common .. "movement-rifle-04.ogg", t = 0.2},
            {s = rottle, t = 0.25},
            {s = rottle, t = 1.2},
            {s = common .. "movement-rifle-03.ogg", t = 1.25},
        },
    },
    ["enter_inspect_empty"] = {
        Source = "inspect_enter_empty",
        -- time = 35 / 60,
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 2.5,
        SoundTable = {
            {s = rottle, t = 0},
            {s = common .. "movement-rifle-02.ogg", t = 0.1},
        },
    },
    ["idle_inspect_empty"] = {
        Source = "inspect_loop_empty",
        -- time = 72 / 60,
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 999,
    },
    ["exit_inspect_empty"] = {
        Source = "inspect_exit_empty",
        -- time = 66 / 60,
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 999,
        SoundTable = {
            {s = common .. "movement-rifle-04.ogg", t = 0.2},
            {s = rottle, t = 0.25},
            {s = rottle, t = 1.2},
            {s = common .. "movement-rifle-03.ogg", t = 1.25},
        },
    },
}

local hgLookup = {
    ["default"]     = {0,4,0},
    ["tactical"]    = {2,5,0},
    ["a1"]          = {1,1,1},
    ["heat"]          = {10,10,1},
    ["heatm203"]          = {11,11,1},
    ["wood"]          = {1,1,1},
    ["lmg"]          = {3,3,1},
    ["fpw"]          = {6,6,2},
    ["ru556"]          = {7,7,3},
    ["adar"]          = {8,8,2},
    ["hk416"]          = {9,9,3},
    ["607"]          = {9,9,0},
}
-- Structure: 20in appearance, 14/11in appearance, gas block mode
-- Gas block modes: 0 standard, 1 always at 20" position, 2 at ADAR position when short, 3 at ADAR position when short and not flat

local barrLookup = {
    ["sd"] = -1,
    ["20in"] = 0,
    ["14in"] = 1,
    ["fpw"] = 1,
    ["10in"] = 2,
}

SWEP.Hook_ModifyBodygroups = function(wep, data)
    local vm = data.vm
    local atts = wep.Attachments
    if !IsValid(vm) then return end

    local barrel = string.Replace(atts[2].Installed or "20in","ud_m16_barrel_","")
    local barr = barrLookup[barrel]
    local hg = string.Replace(atts[3].Installed or "default","ud_m16_hg_","")
    hg = string.Replace(hg,"uf_m16_hg_","")

    local optic = atts[1].Installed
    local muzz = atts[4].Installed or barrel == "sd"
    local laser = atts[8].Installed
    local fs = atts[16].Installed
    local retro = wep:GetBuff_Override("TopMount")

    -- Retro rail
    if optic then
        if retro then
            -- Raised rail (retro)
            vm:SetBodygroup(3, retro)
        else
            -- Flat rail
            vm:SetBodygroup(1, 1)
            vm:SetBodygroup(3, 2)
        end
    end

    -- Dynamic handguard
    if barr == -1 then
        vm:SetBodygroup(5,9)
    elseif barr == 0 and hgLookup[hg] then
        vm:SetBodygroup(5,hgLookup[hg][1])
    elseif hgLookup[hg] then
        vm:SetBodygroup(5,hgLookup[hg][2])
    else
        vm:SetBodygroup(5,9)
    end

    -- Gas block
    if barrel == "sd" or (atts[6].Installed == "ud_m16_receiver_fpw" and barr > 0) then
        vm:SetBodygroup(6,5)
    else
        local gbPos = hgLookup[hg] and hgLookup[hg][3] or 0
        local lwr = atts[6].Installed
        local flat = (
            wep:GetBuff_Override("FrontSight")
            or atts[6].Installed == "ud_m16_receiver_fpw"
            or (optic and fs ~= "ud_m16_charm_fs" and !(wep:GetBuff_Override("IronSight") or wep:GetBuff_Override("TopMount")))
        ) and 1 or 0

        if gbPos == 1 or barr == 0 then
            vm:SetBodygroup(6, 0 + flat)
        elseif gbPos == 2 then
            vm:SetBodygroup(6, 4 + flat * 2)
        elseif gbPos == 3 then
            vm:SetBodygroup(6, 4 - flat)
        else
            vm:SetBodygroup(6, 2 + flat)
        end
    end

    -- Default flash hider
    if !muzz then
        if barr == 0 then
            vm:SetBodygroup(11,1)
        elseif barr == 1 then
            vm:SetBodygroup(11,2)
        else
            vm:SetBodygroup(11,3)
        end
    else
        vm:SetBodygroup(11,0)
    end

    -- Tactical clamp
    if laser and hg ~= "tactical" then
        if barr == 0 then
            vm:SetBodygroup(10,1)
        elseif barr == 1 then
            vm:SetBodygroup(10,3)
        else
            vm:SetBodygroup(10,2)
        end
    else
        vm:SetBodygroup(10,0)
    end

    -- Disable tac rail element with tac hg
    if hg == "tactical" and (atts[7].Installed or atts[18].Installed) then
        vm:SetBodygroup(9,0)
    end

    -- .50 Beowulf magazines
    if atts[5].Installed == "ud_m16_receiver_50beo" and !atts[11].Installed then
        vm:SetBodygroup(2, 8)
    end
end

-- RAYCAR-0, rifle barrel
local bar0_fake = "First variation of the RAYCAR rifle. Tests showed that users were more likely to hit a target if they fired multiple shots, but were likely to spray in full-auto and fail to hit anything. As a result, a ratcheted three-round burst system was implemented which limited the maximum burst a user could fire to three shots.\n\nWell-rounded gun with no major downsides."

-- RAYCAR-1, carbine barrel
local bar1_fake = "Second variation of the RAYCAR rifle. It eventually replaced the RAYCAR-0 across much of the Army for its favorably low weight and comparable performance. The -1 variant has since become one of the most iconic and widespread American service rifles in the modern era.\n\nLight and versatile, but requires discipline to control."

-- RAYCAR-2, commando barrel
local bar2_fake = "Third variation of the RAYCAR rifle. Developed with assistance from the Navy, the \"commando\" barrel allows for the weapon to be very compact, even short enough to be classified as a submachine gun, enhancing usability in vehicles and in enclosed spaces.\n\nVery lightweight and manuverable, but with very aggressive recoil to match."

-- RAYPAW :3
local smgDesc_fake = "Submachine gun based on the RAYCAR rifle. Despite its similar appearance, it uses a different mechanism from its parent rifle.\n\nMore accurate than other submachine guns due to its rifle frame and closed-bolt mechanism."

-- RBY50
local beoDesc_fake = "Aftermarket semi-automatic variant of the RAYCAR rifle firing an oversized magnum cartridge.\n\nProvides extremely high stopping power at close range."

-- RBY300
local blkDesc_fake = "Aftermarket automatic variant of the RAYCAR rifle. The .300 Blackout cartridge has a ballistic performance more akin to the 7.62x39mm Soviet cartridge, with a similarly sized projectile but shorter effective range.\n\nSlightly more inaccurate, made up with a higher stopping power and a subsonic projectile."

-- UKCAR
local ukDesc_fake = "Normally, RAYCAR style rifles are imported with a semi-automatic fire group for the civilian market. This one, however, has been neutered by authority of the British crown with a manual-action receiver.\n\nBit cringe, innit?"

-- RAYSAW
local lmgDesc_fake = "Configuration of the RAYCAR designed for a light machine gun role, used vaguely within the Marine Corps before the adoption of the Minimi.\n\nHeavier than the standard platform, but the integral bipod can be deployed onto surfaces for excellent recoil control."

-- Fallout barrel or sumn idk
local ncrDesc_fake = "Standard-issue rifle of the New California Republic. Traditionally produced with a semi-automatic receiver, the wooden furniture is more readily replaceable and adds additional recoil control for maximum accuracy.\n\nWell-rounded gun with no major downsides."

-- Patriot easter egg. Is it overpowered? I don't think so, a configuration like this is already pretty uncontrollable and imprecise as is, and overheating is the new magazine.
local a1, a2 = {}, {"patr1", "patr2", "patr3", "patr4", "patr5"}
SWEP.O_Hook_Override_BottomlessClip = function(wep, data)
    if wep:CheckFlags(a1, a2) then
        data.current = true
    end
end


SWEP.Hook_NameChange = function(wep, name)
    local trueNames = GetConVar("arccw_truenames"):GetBool()
    local atts = wep.Attachments
    local flat = atts[1].Installed and !wep:GetBuff_Override("TopMount")

    local barrel = string.Replace(atts[2].Installed or "20in","ud_m16_barrel_","")
    local barr = barrLookup[barrel]
    local hg = string.Replace(atts[3].Installed or "default","ud_m16_hg_","")
    local upr = string.Replace(atts[5].Installed or "default","ud_m16_receiver_","")
    local lwr = string.Replace(atts[6].Installed or "default","ud_m16_receiver_","")

    if wep:CheckFlags(a1, a2) then -- Patriot configuration
        wep.Trivia_Desc = patriotDesc
        return "The Patriot"
    elseif !trueNames then -- Custom lore-based fake names
        local pre = (lwr == "auto" and "AM" or "RAY")
        if upr == "9mm" then
            local sd = (barr == -1)
            wep.Trivia_Desc = smgDesc_fake
            if flat then
                return (sd and pre .. "SSMG-NG") or pre .. "PAW-" .. barr .. "NG"
            end
            return (sd and pre .. "SSMG") or pre .. "PAW-" .. barr
        elseif upr == "50beo" then
            wep.Trivia_Desc = beoDesc_fake
            return "RBY"--50"
        elseif upr == "300blk" then
            wep.Trivia_Desc = blkDesc_fake
            return "RBY"--300"
        elseif lwr == "fpw" then
            wep.Trivia_Desc = bar1_fake
            return pre .. "FPW"
        elseif lwr == "cali" then
            wep.Trivia_Desc = ukDesc_fake
            return "UKCAR"
        else
            if barr == 0 then
                if hg == "lmg" then
                    wep.Trivia_Desc = lmgDesc_fake
                    return pre .. "SAW" .. (flat and "-NG" or "")
                elseif flat then
                    return pre .. "CAR-0NG"
                else
                    wep.Trivia_Desc = bar0_fake
                    return pre .. "CAR-0"
                end
            elseif barr == 1 then
                wep.Trivia_Desc = bar1_fake
                if flat then
                    return pre .. "CAR-1NG"
                end
                return pre .. "CAR-1"
            elseif barr == 2 then
                wep.Trivia_Desc = bar2_fake
                if flat then
                    return pre .. "CAR-2NG"
                end
                return pre .. "CAR-2"
            end
        end

        wep.Trivia_Desc = bar0_fake
        return pre .. "CAR-0"

    else

        if upr == "9mm" then
            local sd = (barr == -1)
            wep.Trivia_Desc = smgDesc
            if lwr == "semi" then
                return "AR-15 9mm"
            elseif flat then
                return "R0991"
            end
            return "R0635"

        end

        if lwr == "auto" then
            if upr == "a1" then
                wep.Trivia_Desc = a1Desc
                if barr == 0 then
                    return "M16A1"
                elseif barr == 1 then
                    return "M605"
                end
                wep.Trivia_Desc = carDesc
                return "CAR-15"
            end
            if barr == 0 then
                wep.Trivia_Desc = a3Desc
                if hg == "lmg" then
                    wep.Trivia_Desc = lmgDesc
                    return "Colt LMG"
                elseif flat and hg == "tactical" then
                    return "R0901"
                end
                return "M16A3"
            elseif barr == 1 then
                wep.Trivia_Desc = m4Desc
                if flat then
                    return "M4A1"
                end
                return "XM4"
            else
                wep.Trivia_Desc = carDesc
                if flat then
                    wep.Trivia_Desc = m4Desc
                    if upr == "300blk" then
                        return "Mk 18"
                    end
                    return "Mk 18 Mod 0"
                end
                return "CAR-15"
            end
        elseif lwr == "semi" or upr == "50beo" then
            wep.Trivia_Desc = arDesc
            if hg == "wood" then
                wep.Trivia_Desc = ncrDesc
                if barr == 0 then
                    return "Service Rifle"
                end
                return "Service Carbine"
            elseif flat and hg == "adar" then
                return "ADAR 2-15"
            elseif barr > 0 then
                if barr == 2 and atts[10].Installed == "ud_m16_stock_buffer" then
                    return "AR-15 Pistol"
                elseif upr == "a1" and barr == 1 then
                    return "CRXM177E2B"
                else
                    return "AR-15 SBR"
                end
            elseif upr == "a1" then
                return "CRM16A1"
            end
            return "AR-15"
        elseif lwr == "fpw" then
            wep.Trivia_Desc = m4Desc
            return "M231 FPW"
        elseif lwr == "cali" then
            wep.Trivia_Desc = ukDesc
            return "AR-15GB"
        else
            wep.Trivia_Desc = origDesc
            if barr == 0 and flat then
                return "M16A4"
            elseif barr == 1 then
                wep.Trivia_Desc = m4Desc
                return "M4 Carbine"
            elseif barr == 2 then
                return "M16 Commando"
            end
        end

        wep.Trivia_Desc = origDesc
        return "M16A2"

    end
end



SWEP.Attachments = {
    {
        PrintName = "Optic",
        DefaultAttName = "Iron Sights",
        InstalledEles = {"upper_flat"},
        Slot = {"optic","optic_sniper","ud_m16_rs"},
        Bone = "m16_parent",
        Offset = {
            vpos = Vector(0, -1.75, 3),
            vang = Angle(90, 0, -90),
        },
        SlideAmount = {
            vmin = Vector(0, -1.6, 3 - 2),
            vmax = Vector(0, -1.6, 3 + 1),
        },
    },
    {
        PrintName = "Barrel",
        DefaultAttName = "20\" Standard Barrel",
        DefaultAttIcon = Material("entities/att/acwatt_ud_m16_barrel_20.png", "smooth mips"),
        Slot = "ud_m16_blen",
        Bone = "m16_parent",
        Offset = {
            vpos = Vector(2.8, -4.2, -11.5),
            vang = Angle(90, 0, -90),
        },
    },
    {
        PrintName = "Handguard",
        DefaultAttName = "Ribbed Handguard",
        DefaultAttIcon = Material("entities/att/acwatt_ud_m16_hg_ribbed.png", "smooth mips"),
        Slot = "ud_m16_hg",
        Bone = "m16_parent",
        Offset = {
            vpos = Vector(0, -1.63, -0.41),
            vang = Angle(90, 0, -90),
        },
        ExcludeFlags = {"sd"}
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Standard Muzzle",
        Slot = {"muzzle", "ud_m16_muzzle"},
        Bone = "m16_parent",
        VMScale = Vector(1, 1, 1),
        WMScale = VMScale,
        Offset = {
            vpos = Vector(0, -.33, 23.27),
            vang = Angle(90, 0, -90),
        },
        ExcludeFlags = {"sd", "m16_stub"},
    },
    {
        PrintName = "Upper Receiver",
        DefaultAttName = "5.56x45mm Upper",
        DefaultAttIcon = Material("entities/att/uc_bullets/556x45.png", "smooth mips"),
        Slot = {"ud_m16_receiver"},
        Bone = "m16_parent",
        Offset = {
            vpos = Vector(2.8, -4.2, -11.5),
            vang = Angle(90, 0, -90),
        },
        ExcludeFlags = {"ud_m16_fpw"}
    },
    {
        PrintName = "Lower Receiver",
        DefaultAttName = "Burst Lower",
        DefaultAttIcon = Material("entities/att/acwatt_ud_m16_receiver_default.png", "smooth mips"),
        Slot = {"ud_m16_fcg"},
        Bone = "m16_parent",
        Offset = {
            vpos = Vector(2.8, -4.2, -11.5),
            vang = Angle(90, 0, -90),
        },
        ExcludeFlags = {"m16_nolower"}
    },
    {
        PrintName = "Underbarrel",
        Slot = "foregrip",
        Bone = "m16_parent",
        Offset = {
            vpos = Vector(0, 6, 11),
            vang = Angle(90, 0, -90),
        },
        InstalledEles = {"rail_fg"},
        ExcludeFlags = {"m16_lmg", "m16_stub"},
        SlideAmount = {
            vmin = Vector(0, .65, 11.5),
            vmax = Vector(0, .65, 7.5),
        },
		MergeSlots = {18},
    },
    {
        PrintName = "Tactical",
        Slot = {"tac"},
        Bone = "m16_parent",
        Offset = {
            vpos = Vector(0, 0.3, 21.25),
            vang = Angle(90, 0, -90),
        },
        GivesFlags = {"tac"},
        --InstalledEles = {"ud_m16_clamp_fullsize"}
    },
    {
        PrintName = "Grip Type",
        Slot = {"ud_m16_grip"},
        DefaultAttName = "Standard Grip",
        DefaultAttIcon = Material("entities/att/acwatt_ud_m16_grip_default.png", "smooth mips"),
        ExcludeFlags = {"m16_adar"}
    },
    {
        PrintName = "Stock",
        Slot = {"ud_m16_stock","go_stock"},
        DefaultAttName = "Full Stock",
        DefaultAttIcon = Material("entities/att/acwatt_ud_m16_stock_default.png", "smooth mips"),
        -- GSO support
        InstalledEles = {"stock_231_tube"},
        Bone = "m16_parent",
        Offset = {
            vpos = Vector(-0.02, 0, -2.7),
            vang = Angle(90, 0, -90),
        },
    },
    {
        PrintName = "Magazine",
        Slot = {"ud_m16_mag"},
        DefaultAttName = "30-Round Mag",
        DefaultAttIcon = Material("entities/att/acwatt_ud_m16_mag_30.png", "smooth mips"),
    },
    {
        PrintName = "Ammo Type",
        DefaultAttName = "\"FMJ\" Full Metal Jacket",
        DefaultAttIcon = Material("entities/att/arccw_uc_ammo_generic.png", "mips smooth"),
        Slot = "uc_ammo",
    },
    {
        PrintName = "Powder Load",
        Slot = "uc_powder",
        DefaultAttName = "Standard Load"
    },
    {
        PrintName = "Training Package",
        Slot = "uc_tp",
        DefaultAttName = "Basic Training"
    },
    {
        PrintName = "Internals",
        Slot = "uc_fg", -- Fire group
        DefaultAttName = "Standard Internals"
    },
    {
        PrintName = "Front Sight",
        Slot = {"ud_m16_fs", "ud_m16_charm"},
        FreeSlot = true,
        Bone = "m16_parent",
        Offset = {
            vpos = Vector(0, -1.65, 16.75), -- 21.75 or 15.75
            vang = Angle(90, 0, -90),
        },
        ExcludeFlags = {"sight_magpul"}
    },
    {
        PrintName = "Charm",
        Slot = {"charm", "fml_charm"}, -- "ud_m16_charm"
        FreeSlot = true,
        Bone = "m16_parent",
        Offset = {
            vpos = Vector(0.48, 0.5, 3.9),
            vang = Angle(90, 0, -90),
        },
        -- MergeSlots = {17}
    },
    {
        PrintName = "M203 slot",
        Slot = "uc_ubgl",
        Bone = "m16_parent",
        Offset = {
            vpos = Vector(0, -0.4, 7.2),
            vang = Angle(90, 0, -90),
        },
        Hidden = true,
        InstalledEles = {"rail_fg"},
        ExcludeFlags = {"m16_lmg", "m16_stub"},
    }
}
--lua/weapons/arccw_ud_m16.lua:
return gluapack()()
--lua/weapons/arccw_ud_microuzi.lua:
return gluapack()()
--lua/weapons/arccw_ud_m16.lua:
SWEP.Base = "arccw_base"
SWEP.Spawnable = true
SWEP.Category = "ArcCW - Urban Coalition"
SWEP.UC_CategoryPack = "1Urban Decay"
SWEP.AdminOnly = false
SWEP.UseHands = true

-- Muzzle and shell effects --

SWEP.MuzzleEffect = "muzzleflash_1"
SWEP.ShellEffect = "arccw_uc_shelleffect"
SWEP.ShellModel = "models/weapons/arccw/uc_shells/556x45.mdl"
SWEP.ShellScale = .666
SWEP.ShellPitch = 100

SWEP.MuzzleEffectAttachment = 1
SWEP.CaseEffectAttachment = 2
SWEP.CamAttachment = 3
SWEP.TracerNum = 1
SWEP.TracerCol = Color(25, 255, 25)
SWEP.TracerWidth = 2

-- Fake name --

SWEP.PrintName = "RAYCAR-0"
-- AMCAR stands for (american) Colt Assault Rifle, not Carbine!! ~Fesiug
-- shut up retard ~zenith

-- True name --

SWEP.TrueName = "M16A2"

-- Trivia --
SWEP.Trivia_Class = "Assault Rifle"
SWEP.Trivia_Desc = "Third generation of America's iconic military rifle. Army tests showed that soldiers were more likely to hit a target if they fired multiple shots, but were likely to spray in full-auto and fail to hit anything. As a result, they implemented a ratcheted three-round burst system which limited the maximum burst a soldier could fire to three shots.\n\nWell-rounded gun with no major downsides."
SWEP.Trivia_Manufacturer = "Rayter Arms Industries"
SWEP.Trivia_Calibre = "5.56x45mm NATO"
SWEP.Trivia_Mechanism = "Gas-Operated Rotating Bolt"
SWEP.Trivia_Country = "USA"
SWEP.Trivia_Year = 1959


if GetConVar("arccw_truenames"):GetBool() then
    SWEP.PrintName = SWEP.TrueName
    SWEP.Trivia_Manufacturer = "Stoner's Legacy Ltd."
end

local origDesc = SWEP.Trivia_Desc
local m4Desc = "Carbine variant of the M16 rifle. Originally designed in response to design faults in the CAR-15 family, it eventually replaced the M16 across much of the Army for its favorably low weight and comparable performance. The M4 variant has since become one of the most iconic and widespread American service rifles in the modern era.\n\nLight and versatile, but requires discipline to control."
local ncrDesc = "Standard-issue rifle of the New California Republic. Traditionally produced with a semi-automatic receiver, the wooden furniture is more readily replaceable and adds additional recoil control for maximum accuracy.\n\nWell-rounded gun with no major downsides."
local smgDesc = "Submachine gun based on the M16 rifle. Despite its similar appearance, it uses a different mechanism from its parent rifle. More accurate than other submachine guns due to its rifle frame and closed-bolt mechanism."
local blkDesc = "Aftermarket automatic variant of the M16 rifle. The .300 Blackout cartridge has a ballistic performance more akin to the 7.62x39mm Soviet cartridge, with a similarly sized projectile but shorter effective range."
local ukDesc = "AR-15 style rifles are a class of rifles linked to the M16, normally with a semi-automatic fire group for the civilian market. This one, however, has been neutered by authority of the British crown with a manual-action receiver. Bit cringe, innit?"
local arDesc = "Semi-automatic variant of the M16 series of rifles, produced for the civilian market. Wildly popular in the United States, this rifle can be seen in the hands of hobbyists, hunters and mass shooters alike.\n\nWell-rounded gun with no major downsides."
local beoDesc = "Aftermarket semi-automatic variant of the M16 rifle firing an oversized magnum cartridge. Provides extremely high stopping power at close range."
local carDesc = "Carbine variant of the M16 rifle, short enough to be classified as a submachine gun. Its features influenced the US Army's interest in the M4 Carbine, which went on to become their new standard rifle. Due to the small barrel, rifles of this family have high maneuverability but poor range compared to their parent platform."
local a1Desc = "Second generation of America's iconic military rifle. Developed to address problems with the original M16, which suffered notoriously frequent jamming that could get its wielder killed. The revised model evolved a positive reputation with those who used it, and is now a universal symbol of the Vietnam War.\n\nA well-rounded rifle, but difficult to control without trigger discipline - something the A2 model eventually addressed."
local a3Desc = "Variant of the M16A2 with the original full-automatic trigger group, relegated to niche roles in the US Army. Well-rounded gun with no major downsides."
local lmgDesc = "Configuration of the M16 designed for a light machine gun role, used vaguely within the Marine Corps before the adoption of the Minimi. Heavier than the standard platform, but the integral bipod can be deployed onto surfaces for excellent recoil control."
local patriotDesc = "An assault pistol developed for The Boss. The feeder mechanism inside the drum magazine forms an \"∞\" shape.\n\nThe bottomless magazine more than makes up for the awkwardness of the configuration."

-- Weapon slot --

SWEP.Slot = 2

-- Weapon's manufacturer real name --

if GetConVar("arccw_truenames"):GetBool() then
    SWEP.PrintName = SWEP.TrueName
    SWEP.Trivia_Manufacturer = "Colt's Manufacturing Company"
end

-- Viewmodel / Worldmodel / FOV --

SWEP.ViewModel = "models/weapons/arccw/c_ud_m16.mdl"
SWEP.WorldModel = "models/weapons/arccw/c_ud_m16.mdl"
SWEP.ViewModelFOV = 80
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

-- Damage --

SWEP.Damage = ArcCW.UC.StdDmg["556"].max
SWEP.DamageMin = ArcCW.UC.StdDmg["556"].min
SWEP.RangeMin = 50
SWEP.Range = 350 -- 4 shot until ~250m

SWEP.Penetration = ArcCW.UC.StdDmg["556"].pen
SWEP.DamageType = DMG_BULLET
SWEP.ShootEntity = nil
SWEP.MuzzleVelocity = 960
SWEP.PhysBulletMuzzleVelocity = 960

SWEP.BodyDamageMults = ArcCW.UC.BodyDamageMults

-- Mag size --

SWEP.ChamberSize = 1
SWEP.Primary.ClipSize = 30
SWEP.ExtendedClipSize = 40
SWEP.ReducedClipSize = 20

-- Recoil --

SWEP.Recoil = 0.5
SWEP.RecoilSide = 0.25

SWEP.RecoilRise = 0.1
SWEP.RecoilPunch = 1
SWEP.VisualRecoilMult = 1
SWEP.MaxRecoilBlowback = 1
SWEP.MaxRecoilPunch = 1
SWEP.RecoilPunchBack = 1

SWEP.Sway = 0.5

-- Firerate / Firemodes --

SWEP.Delay = 60 / 900
SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = -3,
        PostBurstDelay = 0.1,
        RunawayBurst = false, -- https://en.wikipedia.org/wiki/Burst_mode_(weapons)
    },
    {
        Mode = 1,
    },
    {
        Mode = 0
    }
}

SWEP.ShootPitch = 100
SWEP.ShootVol = 120
SWEP.ShootPitchVariation = 0

SWEP.ProceduralRegularFire = false
SWEP.ProceduralIronFire = false

SWEP.ReloadInSights = true

-- NPC --

SWEP.NPCWeaponType = "weapon_ar2"
SWEP.NPCWeight = 60

-- Accuracy --

SWEP.AccuracyMOA = 4
SWEP.HipDispersion = 800
SWEP.MoveDispersion = 200
SWEP.JumpDispersion = 1000

SWEP.Primary.Ammo = "smg1"
SWEP.MagID = "m16"

SWEP.HeatCapacity = 150
SWEP.HeatDissipation = 10
SWEP.HeatDelayTime = 3

SWEP.MalfunctionMean = 200
SWEP.MalfunctionTakeRound = false

-- Speed multipliers --

SWEP.SpeedMult = 0.925
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.9

-- Length --

SWEP.BarrelLength = 48
SWEP.ExtraSightDist = 2

-- Ironsights / Customization / Poses --

SWEP.HolsterPos = Vector(0.5, -1, 1.2)
SWEP.HolsterAng = Angle(-8.5, 8, -10)

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"

SWEP.IronSightStruct = {
     Pos = Vector(-2.815, 0, 1.3),
     Ang = Angle(0, 0, 0),
     Magnification = 1.1,
     SwitchToSound = "",
}

SWEP.ActivePos = Vector(0.33, -2, 1.33)
SWEP.ActiveAng = Angle(0, 0, -3)

-- SWEP.CustomizePos = Vector(5, -2, -2)
-- SWEP.CustomizeAng = Angle(15, 25, 0)
SWEP.CustomizePos = Vector(0, 0, 0)
SWEP.CustomizeAng = Angle(0, 0, 0)

SWEP.CrouchPos = Vector(-2.5, -2, -0.6)
SWEP.CrouchAng = Angle(0, 0, -14)

SWEP.BarrelOffsetHip = Vector(2, 0, -5)

SWEP.MirrorVMWM = true
SWEP.WorldModelOffset = {
    pos        =    Vector(-8.5, 4, -5),
    ang        =    Angle(-12, 0, 180),
    bone    =    "ValveBiped.Bip01_R_Hand",
    --scale = .85
}

-- Firing sounds --

local path = ")weapons/arccw_ud/m16/"
local common = ")/arccw_uc/common/"

SWEP.ShootSound = {
    path .. "fire-01.ogg",
    path .. "fire-02.ogg",
    path .. "fire-03.ogg",
    path .. "fire-04.ogg",
    path .. "fire-05.ogg",
    path .. "fire-06.ogg"
}
SWEP.ShootSoundSilenced = {
    path .. "fire-sup-01.ogg",
    path .. "fire-sup-02.ogg",
    path .. "fire-sup-03.ogg",
    path .. "fire-sup-04.ogg",
    path .. "fire-sup-05.ogg",
    path .. "fire-sup-06.ogg"
}

SWEP.DistantShootSound = nil
SWEP.DistantShootSoundSilenced = nil
SWEP.ShootDrySound = path .. "dryfire.ogg"

local tail = ")/arccw_uc/common/556x45/"

SWEP.DistantShootSoundOutdoors = {
    tail .. "fire-dist-556x45-rif-ext-01.ogg",
    tail .. "fire-dist-556x45-rif-ext-02.ogg",
    tail .. "fire-dist-556x45-rif-ext-03.ogg",
    tail .. "fire-dist-556x45-rif-ext-04.ogg",
    tail .. "fire-dist-556x45-rif-ext-05.ogg",
    tail .. "fire-dist-556x45-rif-ext-06.ogg"
}
SWEP.DistantShootSoundIndoors = {
    common .. "fire-dist-int-rifle-01.ogg",
    common .. "fire-dist-int-rifle-02.ogg",
    common .. "fire-dist-int-rifle-03.ogg",
    common .. "fire-dist-int-rifle-04.ogg",
    common .. "fire-dist-int-rifle-05.ogg",
    common .. "fire-dist-int-rifle-06.ogg"
}
SWEP.DistantShootSoundOutdoorsSilenced = {
    common .. "sup-tail-01.ogg",
    common .. "sup-tail-02.ogg",
    common .. "sup-tail-03.ogg",
    common .. "sup-tail-04.ogg",
    common .. "sup-tail-05.ogg",
    common .. "sup-tail-06.ogg",
    common .. "sup-tail-07.ogg",
    common .. "sup-tail-08.ogg",
    common .. "sup-tail-09.ogg",
    common .. "sup-tail-10.ogg"
}
SWEP.DistantShootSoundIndoorsSilenced = {
    common .. "fire-dist-int-pistol-light-01.ogg",
    common .. "fire-dist-int-pistol-light-02.ogg",
    common .. "fire-dist-int-pistol-light-03.ogg",
    common .. "fire-dist-int-pistol-light-04.ogg",
    common .. "fire-dist-int-pistol-light-05.ogg",
    common .. "fire-dist-int-pistol-light-06.ogg"
}
SWEP.DistantShootSoundOutdoorsVolume = 1
SWEP.DistantShootSoundIndoorsVolume = 1
SWEP.Hook_AddShootSound = ArcCW.UC.InnyOuty

-- Bodygroups --

SWEP.BulletBones = {
    [2] = "m16_bullets1",    [3] = "m16_bullets2"
}

SWEP.DefaultBodygroups = "00000000000000000000000"

SWEP.AttachmentElements = {

    ["ud_m16_mag_20"] = {
        VMBodygroups = {{ind = 2, bg = 1}},
    },
    ["ud_m16_mag_40"] = {
        VMBodygroups = {{ind = 2, bg = 2}},
    },
    ["ud_m16_pmag"] = {
        VMBodygroups = {{ind = 2, bg = 9}},
    },
    ["ud_m16_mag_60"] = {
        VMBodygroups = {{ind = 2, bg = 3}},
    },
    ["ud_m16_mag_100"] = {
        VMBodygroups = {{ind = 2, bg = 4}},
    },
    ["ud_m16_9mm_mag"] = {
        VMBodygroups = {{ind = 2, bg = 5}},
    },
    ["ud_m16_9mm_mag_32"] = {
        VMBodygroups = {{ind = 2, bg = 6}},
    },
    ["ud_m16_mag_50beo"] = {
        VMBodygroups = {{ind = 2, bg = 8}},
    },
    ["ud_m16_mag_50beo_12"] = {
        VMBodygroups = {{ind = 2, bg = 0}},
    },

    ["upper_flat"] = {
        -- handled by code
        --[[]
        VMBodygroups = {
            {ind = 1, bg = 1},
            {ind = 3, bg = 3}
        },
        ]]
    },
    ["upper_classic"] = {
        VMBodygroups = {
            {ind = 1, bg = 3},
        },
    },
    ["rail_fg"] = {
        VMBodygroups = {{ind = 9, bg = 1}}
    },

    ["stock_231_ex"] = {
        VMBodygroups = {{ind = 7, bg = 1}},
    },
    ["stock_231_in"] = {
        VMBodygroups = {{ind = 7, bg = 2}},
    },
    ["stock_231_tube"] = {
        VMBodygroups = {{ind = 7, bg = 3}},
    },
    ["stock_607_ex"] = {
        VMBodygroups = {{ind = 7, bg = 4}},
    },
    ["stock_607_in"] = {
        VMBodygroups = {{ind = 7, bg = 5}},
    },
    ["stock_608"] = {
        VMBodygroups = {{ind = 7, bg = 6}},
    },
    ["stock_carbine_ex"] = {
        VMBodygroups = {{ind = 7, bg = 7}},
    },
    ["stock_carbine_in"] = {
        VMBodygroups = {{ind = 7, bg = 8}},
    },
    ["stock_wood"] = {
        VMBodygroups = {{ind = 7, bg = 9}},
    },
    ["stock_adar"] = {
        VMBodygroups = {
            {ind = 7, bg = 10},
            {ind = 8, bg = 4}
        },
    },
    ["stock_ru556"] = {
        VMBodygroups = {{ind = 7, bg = 11}},
    },
    ["grip_ergo"] = {
        VMBodygroups = {{ind = 8, bg = 1}},
    },
    ["grip_skel"] = {
        VMBodygroups = {{ind = 8, bg = 2}},
    },
    ["grip_wood"] = {
        VMBodygroups = {{ind = 8, bg = 3}},
    },

    ["gasblock_carbine"] = {
        VMBodygroups = {{ind = 6, bg = 3}},
    },
    ["fs_adar"] = {
        VMBodygroups = {{ind = 6, bg = 4}},
    },
    ["remove_lug"] = {
        VMBodygroups = {{ind = 12, bg = 1}},
    },

    ["mount_14"] = {
        AttPosMods = {
            [8] = {
                vpos = Vector(0, 0.3, 17.5),
                vang = Angle(90, 0, -90),
            },
        },
    },
    ["mount_11"] = {
        AttPosMods = {
            [8] = {
                vpos = Vector(0.6, -0.3, 14.2),
                vang = Angle(90, 0, 0),
            },
        },
    },
    ["mount_tactical"] = {
        AttPosMods = {
            [8] = {
                vpos = Vector(-1, -.35, 11.5),
                vang = Angle(-90, 180, 0),
                wang = Angle(90, 0, 0),
            },
        },
        ExcludeFlags = {}
    },
    -- ["mount_tactical_short"] = {
    --     AttPosMods = {
    --         [8] = {
    --             vpos = Vector(-1, -.35, 11.5),
    --             vang = Angle(-90, 180, 0),
    --             wang = Angle(90, 0, 0),
    --         },
    --     },
    --     AttPosMods_Priority = 2,
    --     RequireFlags = {"barrel_short"}
    -- },

    ["barrel_14"] = {
        VMBodygroups = {
            {ind = 4, bg = 1},
            {ind = 6, bg = 2},
        },
        AttPosMods = {
            [4] = {
                vpos = Vector(0, -0.33, 18.85),
                vang = Angle(90, 0, -90),
            },
            [16] = {
                vpos = Vector(0, -1.65, 12.5), -- 21.75 or 15.75
                vang = Angle(90, 0, -90),
            },
        }
    },
    ["barrel_11"] = {
        VMBodygroups = {
            {ind = 4, bg = 4},
            {ind = 6, bg = 2},
        },
        AttPosMods = {
            [4] = {
                vpos = Vector(0, -0.33, 15.7),
                vang = Angle(90, 0, -90),
            },
            [16] = {
                vpos = Vector(0, -1.65, 12.5), -- 21.75 or 15.75
                vang = Angle(90, 0, -90),
            },
        }
    },
    ["barrel_fpw"] = {
        VMBodygroups = {
            {ind = 4, bg = 2},
            {ind = 6, bg = 5},
        },
        AttPosMods = {
            [4] = {
                vpos = Vector(0, -0.07, 21.3),
                vang = Angle(90, 0, -90),
            },
        }
    },
    ["barrel_11_ru556"] = {
        VMBodygroups = {
            {ind = 4, bg = 4},
            {ind = 6, bg = 5},
        },
        AttPosMods = {
            [3] = {
                vpos = Vector(0, -0.07, 21.3),
                vang = Angle(90, 0, -90),
            },
            [6] = {
                vpos = Vector(1.15, 0, 17.9),
                vang = Angle(90, 0, 0),
            },
            [16] = {
                vpos = Vector(0, -1.65, 12.5), -- 21.75 or 15.75
                vang = Angle(90, 0, -90),
            },
        }
    },

    ["hg_m16a4_ris"] = {
        VMBodygroups = {
            {ind = 5, bg = 2},
        },
        AttPosMods = {
            [5] = {
                vpos = Vector(-0.1, 1.05, 12),
                vang = Angle(90, 0, -90),
            },
            [6] = {
                vpos = Vector(1.41, -.1, 20),
                vang = Angle(90, 0, 0),
            },
            [16] = {
                vpos = Vector(0, -1.75, 21.75), -- 21.75 or 15.75
                vang = Angle(90, 0, -90),
            },
        }
    },
    ["hg_m4a1_ris"] = {
        VMBodygroups = {
            {ind = 5, bg = 5},
        },
        AttPosMods = {
            [5] = {
                vpos = Vector(0, 1.4, 12),
                vang = Angle(90, 0, -90),
            },
            [6] = {
                vpos = Vector(-1.41, -.2, 14),
                vang = Angle(90, 0, 180),
            },
            [15] = {
                vpos = Vector(0, -1.75, 15.75), -- 21.75 or 15.75
                vang = Angle(90, 0, -90),
            },
        },
    },
    ["hg_ru556"] = {
        -- VMBodygroups = {
        --     {ind = 5, bg = 7},
        -- },
        AttPosMods = {
            -- [5] = {
            --     vpos = Vector(-0.1, 1.05, 12),
            --     vang = Angle(90, 0, -90),
            -- },
            -- [6] = {
            --     vpos = Vector(1.1, 0, 14),
            --     vang = Angle(90, 0, 0),
            -- },
            [16] = {
                vpos = Vector(0, -1.65, 12.5), -- 21.75 or 15.75
                vang = Angle(90, 0, -90),
            },
        },
    },
    ["hg_m4a1"] = {
        VMBodygroups = {
            {ind = 5, bg = 4},
        }
    },
    ["hg_cqbr"] = {
        VMBodygroups = {
            {ind = 5, bg = 4},
        },
    },
    ["hg_adar"] = {
        VMBodygroups = {
            {ind = 5, bg = 8},
        },
    },
    ["hg_fpw"] = {
        VMBodygroups = {
            {ind = 5, bg = 6},
            --{ind = 6, bg = 4},
        }
    },
    ["hg_m16a1"] = {
        VMBodygroups = {
            {ind = 5, bg = 1},
        }
    },
    ["hg_m16a1_wood"] = {
        VMBodygroups = {
            {ind = 5, bg = 1},
        },
        VMSkin = 1
    },
    ["ud_m16_hg_heat"] = {
        VMElements = {
            {
                Model = "models/weapons/arccw/atts/m203iron.mdl",
                Bone = "m16_parent",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(0, -1.2, 14.9),
                    ang = Angle(90, 0, -90),
                }
            }
        },
        UC_UseClassicM203Mount = true,
    },
    ["hg_m605"] = {
        VMBodygroups = {
            {ind = 5, bg = 1},
            {ind = 4, bg = 1},
        },
        AttPosMods = {
            [3] = {
                vpos = Vector(0, -0.05, 25.58),
                vang = Angle(90, 0, -90),
            },
            [6] = { -- also has no rail
                vpos = Vector(0, 0.9, 22.2),
                vang = Angle(90, 0, -90),
            },
        }
    },
    ["hg_m605_wood"] = {
        VMBodygroups = {
            {ind = 5, bg = 1},
            {ind = 4, bg = 1},
        },
        AttPosMods = {
            [3] = {
                vpos = Vector(0, 0, 25),
                vang = Angle(90, 0, -90),
            },
            [6] = { -- also has no rail
                vpos = Vector(0, 0.8, 22),
                vang = Angle(90, 0, -90),
            },
        },
        VMSkin = 1
    },
    ["hg_lmg"] = {
        VMBodygroups = {
            {ind = 5, bg = 3},
        }
    },
    ["hg_sd"] = {
        VMBodygroups = {
            {ind = 5, bg = 9},
            {ind = 4, bg = 3},
            {ind = 6, bg = 5}
        },
        AttPosMods = { -- no rail, just pretend it's mounted to something
            -- [8] = {
            --     vpos = Vector(0, 0.7, 17.5),
            --     vang = Angle(90, 0, -90),
            -- },
            [16] = {
                vpos = Vector(0, -1.65, 11.5), -- 21.75 or 15.75
                vang = Angle(90, 0, -90),
            },
        }
    },

    ["ud_m16_upper_charm"] = {
        AttPosMods = {
            [1] = {
                vpos = Vector(0, -4, 3),
                vang = Angle(90, 0, -90),
                SlideAmount = {
                    vmin = Vector(0, -3.4, 3 - 1.5),
                    vmax = Vector(0, -3.4, 3 + 1.5),
                }
            },
        },
    },
    ["ud_m16_upper_charm2"] = {
        AttPosMods = {
            [1] = {
                vpos = Vector(0, -4.1, 3.5),
                vang = Angle(90, 0, -90),
                SlideAmount = {
                    vmin = Vector(0, -3.5, 3.5 - 2),
                    vmax = Vector(0, -3.5, 3.5 + 1),
                }
            },
        },
    },
    ["bravo_dicks_going_fart"] = {
        AttPosMods = {
            [8] = {
                vpos = Vector(0.25, -1.4, 12),
                vang = Angle(90, 0, 90),
            },
        },
    },

    ---- Cut content
    ["hg_stub"] = {
        VMBodygroups = {
            {ind = 5, bg = 7},
        },
        AttPosMods = {
            [3] = {
                vpos = Vector(0, -0.35, 7),
                vang = Angle(90, 0, -90)
            },
            [6] = {
                vpos = Vector(1.1, -0.4, 9),
                vang = Angle(90, 0, 0),
            },
        }
    },
    ["barrel_stub"] = {
        VMBodygroups = {
            {ind = 4, bg = 4},
            {ind = 6, bg = 4},
        }
    },
    ["hg_smg"] = {
        VMBodygroups = {
            {ind = 5, bg = 0},
        }
    },
    ["m16_strap"] = {
        VMBodygroups = {
             {ind = 13, bg = 1},
        },
    },
}

-- Animations --

SWEP.Hook_Think = ArcCW.UC.ADSReload

local sr_pmag = {
	[path .. "magout_empty.ogg"] = path .. "pmagout.ogg",
	[path .. "magin.ogg"] = path .. "pmagin.ogg",
}

local pmag1, pmag2 = {}, {"ud_m16_pmag"}
SWEP.Hook_TranslateSound = function(wep, data)
	if wep:CheckFlags(pmag1, pmag2) and sr_pmag[data] then return sr_pmag[data] end
end

local rottle = {common .. "cloth_1.ogg", common .. "cloth_2.ogg", common .. "cloth_3.ogg", common .. "cloth_4.ogg", common .. "cloth_6.ogg", common .. "rattle.ogg"}
local ratel = {common .. "rattle1.ogg", common .. "rattle2.ogg", common .. "rattle3.ogg"}

SWEP.Animations = {
    ["ready"] = {
        Source = "fix",
        Time = 45 / 30,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKEaseIn = 0.4,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.4,
        SoundTable = {
            {s = common .. "raise.ogg", t = 0},
            {s = common .. "rattle.ogg", t = 0.2},
            {s = path .. "chback.ogg",   t = 0.15},
            {s = common .. "cloth_4.ogg",  t = 0.5},
            {s = path .. "chamber.ogg",  t = 0.5},
        },
        ProcDraw = true,
    },
    ["idle"] = {
        Source = "idle",
    },
    ["idle_empty"] = {
        Source = "idle_empty",
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {s = common .. "raise.ogg", t = 0},
            {s = common .. "shoulder.ogg", t = 0.15},
            {s = ratel, t = 0.2},
        },
    },
    ["draw_empty"] = {
        Source = "draw_empty",
        Time = 20 / 30,
        SoundTable = {
            {s = common .. "raise.ogg", t = 0},
            {s = common .. "shoulder.ogg", t = 0.15},
            {s = ratel, t = 0.2},
        },
    },
    ["holster"] = {
        Source = "holster",
        LHIK = true,
        LHIKIn = 0.3,
        LHIKEaseIn = 0.4,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.4,
        SoundTable = {
            {s = ratel, t = 0},
            {s = common .. "cloth_6.ogg", t = 0.2},
        },
    },
    ["holster_empty"] = {
        Source = "holster_empty",
        Time = 20 / 30,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKEaseIn = 0.4,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.4,
        SoundTable = {
            {s = ratel, t = 0},
            {s = common .. "cloth_6.ogg", t = 0.2},
        },
    },
    ["trigger"] = {
        Source = "idle",
        MinProgress = .1,
        SoundTable = {
            {s = ")weapons/arccw_ud/uzi/prefire.ogg",         t = 0, c = ci},
        },
    },
    ["fire"] = {
        Source = "fire",
        Time = 13 / 30,
        ShellEjectAt = 0.01,
        SoundTable = {{ s = {path .. "mech-01.ogg", path .. "mech-02.ogg", path .. "mech-03.ogg", path .. "mech-04.ogg", path .. "mech-05.ogg", path .. "mech-06.ogg"}, t = 0, v = 0.25 }},
    },
    ["fire_iron"] = {
        Source = "fire",
        Time = 13 / 30,
        ShellEjectAt = 0.01,
        SoundTable = {{ s = {path .. "mech-01.ogg", path .. "mech-02.ogg", path .. "mech-03.ogg", path .. "mech-04.ogg", path .. "mech-05.ogg", path .. "mech-06.ogg"}, t = 0 }},
    },
    ["fire_empty"] = {
        Source = "fire_empty",
        Time = 13 / 30,
        ShellEjectAt = 0.01,
        SoundTable = {
            {s = path .. "mech_last.ogg", t = 0}, -- Temporary
        },
    },
    ["fire_iron_empty"] = {
        Source = "fire_empty",
        Time = 13 / 30,
        ShellEjectAt = 0.01,
        SoundTable = {
            {s = path .. "mech_last.ogg", t = 0}, -- Temporary
        },
    },

    ["fire_cycle"] = {
        Source = "fire",
        Time = 13 / 30,
    },

    ["cycle"] = {
        Source = "fix",
        Time = 36 / 30 * 0.7,
        ShellEjectAt = 0.3,
        LHIK = true,
        LHIKIn = 0.3 * 0.7,
        LHIKEaseIn = 0.4 * 0.7,
        LHIKEaseOut = 0.15 * 0.7,
        LHIKOut = 0.4 * 0.7,
        SoundTable = {
            {s = path .. "chback.ogg",   t = 0.05},
            {s = common .. "cloth_4.ogg",  t = 0.2},
            {s = path .. "chamber.ogg",  t = 0.3},
        },
    },

    ["fix"] = {
        Source = "fix",
        Time = 45 / 30,
        ShellEjectAt = false,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKEaseIn = 0.4,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.4,
        SoundTable = {
            {s = path .. "chback.ogg",   t = 0.15},
            {s = common .. "cloth_4.ogg",  t = 0.5},
            {s = path .. "chamber.ogg",  t = 0.5},
        },
    },
    ["fix_empty"] = {
        Source = "fix_empty",
        Time = 45 / 30,
        ShellEjectAt = false,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKEaseIn = 0.4,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.4,
        SoundTable = {
            {s = path .. "chback.ogg",   t = 0.15},
            {s = common .. "cloth_4.ogg",  t = 0.5},
            {s = path .. "ch_forward_empty.ogg",  t = 0.5},
        },
    },

    -- 30 Round Reloads --

    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        Time = 71 / 30,
        MinProgress = 1.5,
        LastClip1OutTime = 0.9,
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.2,
        LHIKEaseOut = 0.4,
        LHIKOut = 0.7,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = common .. "magpouch_gear.ogg", t = 0.2, v = 0.5},
            {s = ratel, t = 0.25},
            {s = path .. "magout_empty.ogg", 	 t = 0.23},
            {s = ratel, t = 0.5},
            {s = path .. "struggle.ogg",    t = 1, v = 0.4},
            {s = path .. "magin.ogg",    t = 0.97},
            {s = ratel, t = 1.1},
            {s = rottle,  t = 1.15},
            {s = common .. "grab-polymer.ogg", t = 1.77, v = 0.25},
            {s = common .. "rattle_b2i_rifle.ogg", t = 1.7},
            {s = common .. "shoulder.ogg", t = 1.8},
        },
    },
    ["reload_empty"] = {
        Source = "reload_empty",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        Time = 87 / 30,
        MinProgress = 2,
        LastClip1OutTime = 0.7,
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.2,
        LHIKEaseOut = 0.4,
        LHIKOut = 0.9,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = ratel, t = 0.25},
            {s = common .. "magpouch_gear.ogg", t = 0.1, v = 0.5},
            {s = path .. "magout_empty.ogg", 	 t = 0.2},
            {s = ratel, t = 0.5},
            {s = common .. "rifle_magdrop.ogg",  t = 0.65},
            {s = path .. "struggle.ogg",    t = 0.95, v = 0.4},
            {s = path .. "magin.ogg",    t = 0.95},
            {s = ratel, t = 1.1},
            {s = rottle,  t = 1.39},
            {s = path .. "boltdrop.ogg", t = 1.7},
            {s = ratel, t = 1.9},
            {s = common .. "rattle_b2i_rifle.ogg", t = 2.0},
            {s = common .. "grab-polymer.ogg", t = 2.1, v = 0.35},
            {s = common .. "shoulder.ogg", t = 2.1},
        },
    },

    -- 20 Round Reloads --

    ["reload_20"] = {
        Source = "reload_20",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        Time = 71 / 30,
        MinProgress = 1.5,
        LastClip1OutTime = 0.9,
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.2,
        LHIKEaseOut = 0.4,
        LHIKOut = 0.7,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = ratel, t = 0.05},
            {s = path .. "magout_empty.ogg", 	 t = 0.09},
            {s = common .. "magpouch_gear.ogg", t = 0.1},
            {s = rottle,  t = 0.75},
            {s = ratel, t = 0.85},
            {s = path .. "struggle.ogg",    t = 0.9, v = 0.4},
            {s = path .. "magin.ogg",    t = 0.95},
            {s = rottle,  t = 1.1},
            {s = ratel, t = 1.125},
            {s = common .. "rattle_b2i_rifle.ogg", t = 1.65},
            {s = common .. "grab-polymer.ogg", t = 1.7, v = 0.25},
            {s = common .. "shoulder.ogg", t = 1.75},
        },
    },
    ["reload_empty_20"] = {
        Source = "reload_empty_20",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        Time = 86 / 30,
        MinProgress = 2,
        LastClip1OutTime = 0.7,
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.2,
        LHIKEaseOut = 0.3,
        LHIKOut = 0.8,
        SoundTable = {
            {s = common .. "magpouch_gear.ogg", t = 0},
            {s = rottle, t = 0.01},
            {s = ratel, t = 0.05},
            {s = path .. "magout_empty.ogg", 	 t = 0.075},
            {s = rottle, t = 0.75},
            {s = ratel, t = 0.9},
            {s = common .. "rifle_magdrop.ogg",  t = 0.65},
            {s = path .. "struggle.ogg",    t = 0.8, v = 0.4},
            {s = path .. "magin.ogg",    t = 0.85},
            {s = rottle, t = 1.4},
            {s = ratel, t = 1.4},
            {s = path .. "chamber_press.ogg", t = 1.72},
            {s = common .. "rattle_b2i_rifle.ogg", t = 1.95},
            {s = common .. "grab-polymer.ogg", t = 2.075, v = 0.25},
            {s = common .. "shoulder.ogg", t = 2.13},
        },
    },

    -- 40 Round Reloads --

    ["reload_40"] = {
        Source = "reload_40",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        Time = 71 / 30,
        MinProgress = 1.5,
        LastClip1OutTime = 0.9,
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.2,
        LHIKEaseOut = 0.4,
        LHIKOut = 0.7,
        SoundTable = {
            {s = rottle, t = 0.0},
            {s = ratel, t = 0.1},
            {s = path .. "magout_empty.ogg", 	 t = 0.2},
            {s = common .. "magpouch_gear.ogg", t = 0.25},
            {s = rottle, t = 0.75},
            {s = ratel, t = 0.8},
            {s = path .. "struggle.ogg",    t = 0.95, v = 0.4},
            {s = path .. "magin.ogg",    t = 1.0},
            {s = rottle, t = 1.1},
            {s = ratel, t = 1.25},
            {s = common .. "rattle_b2i_rifle.ogg", t = 1.65},
            {s = common .. "shoulder.ogg", t = 1.75},
        },
    },
    ["reload_empty_40"] = {
        Source = "reload_empty_40",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        Time = 85 / 30,
        MinProgress = 2,
        LastClip1OutTime = 0.7,
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.2,
        LHIKEaseOut = 0.4,
        LHIKOut = 0.8,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = path .. "magout_empty.ogg", 	 t = 0.2},
            {s = common .. "magpouch_gear.ogg", t = 0.25},
            {s = rottle,  t = 0.75},
            {s = common .. "rifle_magdrop.ogg",  t = 0.8},
            {s = path .. "struggle.ogg",    t = 1.0, v = 0.4},
            {s = path .. "magin.ogg",    t = 1.05},
            {s = rottle,  t = 1.475},
            {s = ratel,  t = 1.475},
            {s = path .. "boltdrop.ogg", t = 1.78},
            {s = common .. "rattle_b2i_rifle.ogg", t = 2.1},
            {s = common .. "shoulder.ogg", t = 2.2},
        },
    },

    -- 60 Round Reloads --

    ["reload_60"] = {
        Source = "reload_60",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        Time = 71 / 30,
        MinProgress = 1.5,
        LastClip1OutTime = 0.9,
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.2,
        LHIKEaseOut = 0.4,
        LHIKOut = 0.7,
        SoundTable = {
            {s = rottle, t = 0.0},
            {s = common .. "magpouch_gear.ogg", t = 0.2},
            {s = path .. "magout_empty.ogg", 	 t = 0.25},
            {s = rottle, t = 0.75},
            {s = path .. "struggle.ogg",    t = 1.0, v = 0.4},
            {s = path .. "magin.ogg",    t = 1.1},
            {s = rottle, t = 1.1},
            {s = common .. "grab-polymer.ogg", t = 1.78, v = 0.25},
            {s = common .. "rattle_b2i_rifle.ogg", t = 1.8},
            {s = common .. "shoulder.ogg", t = 1.9},
        },
    },
    ["reload_empty_60"] = {
        Source = "reload_empty_60",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        Time = 85 / 30,
        MinProgress = 2,
        LastClip1OutTime = 0.7,
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.2,
        LHIKEaseOut = 0.4,
        LHIKOut = 0.8,
        SoundTable = {
            {s = rottle, t = 0.0},
            {s = common .. "magpouch_gear.ogg", t = 0.2},
            {s = path .. "magout_empty.ogg", 	 t = 0.25},
            {s = rottle, t = 0.75},
            {s = common .. "rifle_magdrop.ogg",  t = 0.8},
            {s = path .. "struggle.ogg",    t = 1.0, v = 0.4},
            {s = path .. "magin.ogg",    t = 1.1},
            {s = rottle, t = 1.475},
            {s = ratel, t = 1.475},
            {s = path .. "boltdrop.ogg", t = 1.8},
            {s = common .. "rattle_b2i_rifle.ogg", t = 2.1},
            {s = common .. "grab-polymer.ogg", t = 2.15, v = 0.25},
            {s = common .. "shoulder.ogg", t = 2.2},
        },
    },

    -- 100 Round Reloads --

    ["reload_100"] = {
        Source = "reload_100",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        Time = 71 / 30,
        MinProgress = 1.75,
        LastClip1OutTime = 0.9,
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.2,
        LHIKEaseOut = 0.3,
        LHIKOut = 0.5,
        SoundTable = {
            {s = rottle, t = 0.0},
            {s = path .. "magout_empty.ogg", 	 t = 0.2},
            {s = rottle, t = 0.75},
            {s = path .. "struggle.ogg",    t = 0.95, v = 0.4},
            {s = path .. "magin.ogg",    t = 1.05},
            {s = rottle, t = 1.1},
            {s = path .. "magtap.ogg",   t = 1.59},
            {s = common .. "cloth_4.ogg",  t = 1.65},
            {s = common .. "rattle_b2i_rifle.ogg", t = 1.8},
            {s = common .. "grab-polymer.ogg", t = 1.85, v = 0.25},
            {s = common .. "shoulder.ogg", t = 2.0},
        },
    },
    ["reload_empty_100"] = {
        Source = "reload_empty_100",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        Time = 90 / 30,
        MinProgress = 2.5,
        LastClip1OutTime = 0.7,
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.2,
        LHIKEaseOut = 0.3,
        LHIKOut = 0.6,
        SoundTable = {
            {s = rottle, t = 0.0},
            {s = path .. "magout_empty.ogg", 	 t = 0.2},
            {s = rottle, t = 0.75},
            {s = common .. "magdrop.ogg",  t = 0.65},
            {s = path .. "struggle.ogg",    t = 0.95, v = 0.4},
            {s = path .. "magin.ogg",    t = 1.05},
            {s = path .. "magtap.ogg",   t = 1.59},
            {s = rottle, t = 1.75},
            {s = path .. "chback.ogg",   t = 2.0},
            {s = common .. "cloth_4.ogg",  t = 2.05},
            {s = path .. "chamber.ogg",  t = 2.22},
            {s = common .. "rattle_b2i_rifle.ogg", t = 2.5},
            {s = common .. "grab-polymer.ogg", t = 2.55, v = 0.25},
            {s = common .. "shoulder.ogg", t = 2.6},
        },
    },

    -- 9mm 32 Round Reloads --

    ["reload_9mm"] = {
        Source = "reload_9mm",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        Time = 70 / 30,
        MinProgress = 1.5,
        LastClip1OutTime = 0.9,
        LHIK = true,
        LHIKIn = 0.4,
        LHIKEaseIn = 0.4,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.5,
        SoundTable = {
            {s = rottle, t = 0.0},
            {s = common .. "magpouch.ogg", t = 0.15},
            {s = "weapons/arccw_ud/uzi/" .. "magout.ogg", 	 t = 16 / 30},
            {s = rottle, t = 0.75},
            {s = "weapons/arccw_ud/uzi/" .. "magin.ogg",    t = 27 / 30},
            {s = rottle, t = 1.1},
            {s = common .. "magpouchin.ogg", t = 1.55},
            {s = common .. "shoulder.ogg", t = 1.93},
        },
    },
    ["reload_empty_9mm"] = {
        Source = "reload_empty_9mm",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        Time = 80 / 30,
        MinProgress = 2,
        LastClip1OutTime = 0.7,
        LHIK = true,
        LHIKIn = 0.1,
        LHIKEaseIn = 0.1,
        LHIKEaseOut = 0.4,
        LHIKOut = 0.9,
        SoundTable = {
            {s = rottle, t = 0.0},
            {s = "weapons/arccw_ud/uzi/" .. "magout.ogg", 	 t = 0.1},
            {s = common .. "magpouch.ogg", t = 0.45},
            {s = rottle, t = 0.75},
            {s = "weapons/arccw_ud/uzi/" .. "magin.ogg",    t = 0.8},
            {s = path .. "chamber_press.ogg", t = 1.7},
            {s = rottle, t = 1.39},
            {s = common .. "shoulder.ogg", t = 2.15},
        },
    },


    ["enter_inspect"] = {
        Source = "inspect_enter",
        -- time = 35 / 60,
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 2.5,
        SoundTable = {
            {s = rottle, t = 0},
            {s = common .. "movement-rifle-02.ogg", t = 0.1},
        },
    },
    ["idle_inspect"] = {
        Source = "inspect_loop",
        -- time = 72 / 60,
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 999, -- maybe im dumb
    },
    ["exit_inspect"] = {
        Source = "inspect_exit",
        -- time = 66 / 60,
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 999, -- maybe im dumb
        SoundTable = {
            {s = common .. "movement-rifle-04.ogg", t = 0.2},
            {s = rottle, t = 0.25},
            {s = rottle, t = 1.2},
            {s = common .. "movement-rifle-03.ogg", t = 1.25},
        },
    },
    ["enter_inspect_empty"] = {
        Source = "inspect_enter_empty",
        -- time = 35 / 60,
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 2.5,
        SoundTable = {
            {s = rottle, t = 0},
            {s = common .. "movement-rifle-02.ogg", t = 0.1},
        },
    },
    ["idle_inspect_empty"] = {
        Source = "inspect_loop_empty",
        -- time = 72 / 60,
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 999,
    },
    ["exit_inspect_empty"] = {
        Source = "inspect_exit_empty",
        -- time = 66 / 60,
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 999,
        SoundTable = {
            {s = common .. "movement-rifle-04.ogg", t = 0.2},
            {s = rottle, t = 0.25},
            {s = rottle, t = 1.2},
            {s = common .. "movement-rifle-03.ogg", t = 1.25},
        },
    },
}

local hgLookup = {
    ["default"]     = {0,4,0},
    ["tactical"]    = {2,5,0},
    ["a1"]          = {1,1,1},
    ["heat"]          = {10,10,1},
    ["heatm203"]          = {11,11,1},
    ["wood"]          = {1,1,1},
    ["lmg"]          = {3,3,1},
    ["fpw"]          = {6,6,2},
    ["ru556"]          = {7,7,3},
    ["adar"]          = {8,8,2},
    ["hk416"]          = {9,9,3},
    ["607"]          = {9,9,0},
}
-- Structure: 20in appearance, 14/11in appearance, gas block mode
-- Gas block modes: 0 standard, 1 always at 20" position, 2 at ADAR position when short, 3 at ADAR position when short and not flat

local barrLookup = {
    ["sd"] = -1,
    ["20in"] = 0,
    ["14in"] = 1,
    ["fpw"] = 1,
    ["10in"] = 2,
}

SWEP.Hook_ModifyBodygroups = function(wep, data)
    local vm = data.vm
    local atts = wep.Attachments
    if !IsValid(vm) then return end

    local barrel = string.Replace(atts[2].Installed or "20in","ud_m16_barrel_","")
    local barr = barrLookup[barrel]
    local hg = string.Replace(atts[3].Installed or "default","ud_m16_hg_","")
    hg = string.Replace(hg,"uf_m16_hg_","")

    local optic = atts[1].Installed
    local muzz = atts[4].Installed or barrel == "sd"
    local laser = atts[8].Installed
    local fs = atts[16].Installed
    local retro = wep:GetBuff_Override("TopMount")

    -- Retro rail
    if optic then
        if retro then
            -- Raised rail (retro)
            vm:SetBodygroup(3, retro)
        else
            -- Flat rail
            vm:SetBodygroup(1, 1)
            vm:SetBodygroup(3, 2)
        end
    end

    -- Dynamic handguard
    if barr == -1 then
        vm:SetBodygroup(5,9)
    elseif barr == 0 and hgLookup[hg] then
        vm:SetBodygroup(5,hgLookup[hg][1])
    elseif hgLookup[hg] then
        vm:SetBodygroup(5,hgLookup[hg][2])
    else
        vm:SetBodygroup(5,9)
    end

    -- Gas block
    if barrel == "sd" or (atts[6].Installed == "ud_m16_receiver_fpw" and barr > 0) then
        vm:SetBodygroup(6,5)
    else
        local gbPos = hgLookup[hg] and hgLookup[hg][3] or 0
        local lwr = atts[6].Installed
        local flat = (
            wep:GetBuff_Override("FrontSight")
            or atts[6].Installed == "ud_m16_receiver_fpw"
            or (optic and fs ~= "ud_m16_charm_fs" and !(wep:GetBuff_Override("IronSight") or wep:GetBuff_Override("TopMount")))
        ) and 1 or 0

        if gbPos == 1 or barr == 0 then
            vm:SetBodygroup(6, 0 + flat)
        elseif gbPos == 2 then
            vm:SetBodygroup(6, 4 + flat * 2)
        elseif gbPos == 3 then
            vm:SetBodygroup(6, 4 - flat)
        else
            vm:SetBodygroup(6, 2 + flat)
        end
    end

    -- Default flash hider
    if !muzz then
        if barr == 0 then
            vm:SetBodygroup(11,1)
        elseif barr == 1 then
            vm:SetBodygroup(11,2)
        else
            vm:SetBodygroup(11,3)
        end
    else
        vm:SetBodygroup(11,0)
    end

    -- Tactical clamp
    if laser and hg ~= "tactical" then
        if barr == 0 then
            vm:SetBodygroup(10,1)
        elseif barr == 1 then
            vm:SetBodygroup(10,3)
        else
            vm:SetBodygroup(10,2)
        end
    else
        vm:SetBodygroup(10,0)
    end

    -- Disable tac rail element with tac hg
    if hg == "tactical" and (atts[7].Installed or atts[18].Installed) then
        vm:SetBodygroup(9,0)
    end

    -- .50 Beowulf magazines
    if atts[5].Installed == "ud_m16_receiver_50beo" and !atts[11].Installed then
        vm:SetBodygroup(2, 8)
    end
end

-- RAYCAR-0, rifle barrel
local bar0_fake = "First variation of the RAYCAR rifle. Tests showed that users were more likely to hit a target if they fired multiple shots, but were likely to spray in full-auto and fail to hit anything. As a result, a ratcheted three-round burst system was implemented which limited the maximum burst a user could fire to three shots.\n\nWell-rounded gun with no major downsides."

-- RAYCAR-1, carbine barrel
local bar1_fake = "Second variation of the RAYCAR rifle. It eventually replaced the RAYCAR-0 across much of the Army for its favorably low weight and comparable performance. The -1 variant has since become one of the most iconic and widespread American service rifles in the modern era.\n\nLight and versatile, but requires discipline to control."

-- RAYCAR-2, commando barrel
local bar2_fake = "Third variation of the RAYCAR rifle. Developed with assistance from the Navy, the \"commando\" barrel allows for the weapon to be very compact, even short enough to be classified as a submachine gun, enhancing usability in vehicles and in enclosed spaces.\n\nVery lightweight and manuverable, but with very aggressive recoil to match."

-- RAYPAW :3
local smgDesc_fake = "Submachine gun based on the RAYCAR rifle. Despite its similar appearance, it uses a different mechanism from its parent rifle.\n\nMore accurate than other submachine guns due to its rifle frame and closed-bolt mechanism."

-- RBY50
local beoDesc_fake = "Aftermarket semi-automatic variant of the RAYCAR rifle firing an oversized magnum cartridge.\n\nProvides extremely high stopping power at close range."

-- RBY300
local blkDesc_fake = "Aftermarket automatic variant of the RAYCAR rifle. The .300 Blackout cartridge has a ballistic performance more akin to the 7.62x39mm Soviet cartridge, with a similarly sized projectile but shorter effective range.\n\nSlightly more inaccurate, made up with a higher stopping power and a subsonic projectile."

-- UKCAR
local ukDesc_fake = "Normally, RAYCAR style rifles are imported with a semi-automatic fire group for the civilian market. This one, however, has been neutered by authority of the British crown with a manual-action receiver.\n\nBit cringe, innit?"

-- RAYSAW
local lmgDesc_fake = "Configuration of the RAYCAR designed for a light machine gun role, used vaguely within the Marine Corps before the adoption of the Minimi.\n\nHeavier than the standard platform, but the integral bipod can be deployed onto surfaces for excellent recoil control."

-- Fallout barrel or sumn idk
local ncrDesc_fake = "Standard-issue rifle of the New California Republic. Traditionally produced with a semi-automatic receiver, the wooden furniture is more readily replaceable and adds additional recoil control for maximum accuracy.\n\nWell-rounded gun with no major downsides."

-- Patriot easter egg. Is it overpowered? I don't think so, a configuration like this is already pretty uncontrollable and imprecise as is, and overheating is the new magazine.
local a1, a2 = {}, {"patr1", "patr2", "patr3", "patr4", "patr5"}
SWEP.O_Hook_Override_BottomlessClip = function(wep, data)
    if wep:CheckFlags(a1, a2) then
        data.current = true
    end
end


SWEP.Hook_NameChange = function(wep, name)
    local trueNames = GetConVar("arccw_truenames"):GetBool()
    local atts = wep.Attachments
    local flat = atts[1].Installed and !wep:GetBuff_Override("TopMount")

    local barrel = string.Replace(atts[2].Installed or "20in","ud_m16_barrel_","")
    local barr = barrLookup[barrel]
    local hg = string.Replace(atts[3].Installed or "default","ud_m16_hg_","")
    local upr = string.Replace(atts[5].Installed or "default","ud_m16_receiver_","")
    local lwr = string.Replace(atts[6].Installed or "default","ud_m16_receiver_","")

    if wep:CheckFlags(a1, a2) then -- Patriot configuration
        wep.Trivia_Desc = patriotDesc
        return "The Patriot"
    elseif !trueNames then -- Custom lore-based fake names
        local pre = (lwr == "auto" and "AM" or "RAY")
        if upr == "9mm" then
            local sd = (barr == -1)
            wep.Trivia_Desc = smgDesc_fake
            if flat then
                return (sd and pre .. "SSMG-NG") or pre .. "PAW-" .. barr .. "NG"
            end
            return (sd and pre .. "SSMG") or pre .. "PAW-" .. barr
        elseif upr == "50beo" then
            wep.Trivia_Desc = beoDesc_fake
            return "RBY"--50"
        elseif upr == "300blk" then
            wep.Trivia_Desc = blkDesc_fake
            return "RBY"--300"
        elseif lwr == "fpw" then
            wep.Trivia_Desc = bar1_fake
            return pre .. "FPW"
        elseif lwr == "cali" then
            wep.Trivia_Desc = ukDesc_fake
            return "UKCAR"
        else
            if barr == 0 then
                if hg == "lmg" then
                    wep.Trivia_Desc = lmgDesc_fake
                    return pre .. "SAW" .. (flat and "-NG" or "")
                elseif flat then
                    return pre .. "CAR-0NG"
                else
                    wep.Trivia_Desc = bar0_fake
                    return pre .. "CAR-0"
                end
            elseif barr == 1 then
                wep.Trivia_Desc = bar1_fake
                if flat then
                    return pre .. "CAR-1NG"
                end
                return pre .. "CAR-1"
            elseif barr == 2 then
                wep.Trivia_Desc = bar2_fake
                if flat then
                    return pre .. "CAR-2NG"
                end
                return pre .. "CAR-2"
            end
        end

        wep.Trivia_Desc = bar0_fake
        return pre .. "CAR-0"

    else

        if upr == "9mm" then
            local sd = (barr == -1)
            wep.Trivia_Desc = smgDesc
            if lwr == "semi" then
                return "AR-15 9mm"
            elseif flat then
                return "R0991"
            end
            return "R0635"

        end

        if lwr == "auto" then
            if upr == "a1" then
                wep.Trivia_Desc = a1Desc
                if barr == 0 then
                    return "M16A1"
                elseif barr == 1 then
                    return "M605"
                end
                wep.Trivia_Desc = carDesc
                return "CAR-15"
            end
            if barr == 0 then
                wep.Trivia_Desc = a3Desc
                if hg == "lmg" then
                    wep.Trivia_Desc = lmgDesc
                    return "Colt LMG"
                elseif flat and hg == "tactical" then
                    return "R0901"
                end
                return "M16A3"
            elseif barr == 1 then
                wep.Trivia_Desc = m4Desc
                if flat then
                    return "M4A1"
                end
                return "XM4"
            else
                wep.Trivia_Desc = carDesc
                if flat then
                    wep.Trivia_Desc = m4Desc
                    if upr == "300blk" then
                        return "Mk 18"
                    end
                    return "Mk 18 Mod 0"
                end
                return "CAR-15"
            end
        elseif lwr == "semi" or upr == "50beo" then
            wep.Trivia_Desc = arDesc
            if hg == "wood" then
                wep.Trivia_Desc = ncrDesc
                if barr == 0 then
                    return "Service Rifle"
                end
                return "Service Carbine"
            elseif flat and hg == "adar" then
                return "ADAR 2-15"
            elseif barr > 0 then
                if barr == 2 and atts[10].Installed == "ud_m16_stock_buffer" then
                    return "AR-15 Pistol"
                elseif upr == "a1" and barr == 1 then
                    return "CRXM177E2B"
                else
                    return "AR-15 SBR"
                end
            elseif upr == "a1" then
                return "CRM16A1"
            end
            return "AR-15"
        elseif lwr == "fpw" then
            wep.Trivia_Desc = m4Desc
            return "M231 FPW"
        elseif lwr == "cali" then
            wep.Trivia_Desc = ukDesc
            return "AR-15GB"
        else
            wep.Trivia_Desc = origDesc
            if barr == 0 and flat then
                return "M16A4"
            elseif barr == 1 then
                wep.Trivia_Desc = m4Desc
                return "M4 Carbine"
            elseif barr == 2 then
                return "M16 Commando"
            end
        end

        wep.Trivia_Desc = origDesc
        return "M16A2"

    end
end



SWEP.Attachments = {
    {
        PrintName = "Optic",
        DefaultAttName = "Iron Sights",
        InstalledEles = {"upper_flat"},
        Slot = {"optic","optic_sniper","ud_m16_rs"},
        Bone = "m16_parent",
        Offset = {
            vpos = Vector(0, -1.75, 3),
            vang = Angle(90, 0, -90),
        },
        SlideAmount = {
            vmin = Vector(0, -1.6, 3 - 2),
            vmax = Vector(0, -1.6, 3 + 1),
        },
    },
    {
        PrintName = "Barrel",
        DefaultAttName = "20\" Standard Barrel",
        DefaultAttIcon = Material("entities/att/acwatt_ud_m16_barrel_20.png", "smooth mips"),
        Slot = "ud_m16_blen",
        Bone = "m16_parent",
        Offset = {
            vpos = Vector(2.8, -4.2, -11.5),
            vang = Angle(90, 0, -90),
        },
    },
    {
        PrintName = "Handguard",
        DefaultAttName = "Ribbed Handguard",
        DefaultAttIcon = Material("entities/att/acwatt_ud_m16_hg_ribbed.png", "smooth mips"),
        Slot = "ud_m16_hg",
        Bone = "m16_parent",
        Offset = {
            vpos = Vector(0, -1.63, -0.41),
            vang = Angle(90, 0, -90),
        },
        ExcludeFlags = {"sd"}
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Standard Muzzle",
        Slot = {"muzzle", "ud_m16_muzzle"},
        Bone = "m16_parent",
        VMScale = Vector(1, 1, 1),
        WMScale = VMScale,
        Offset = {
            vpos = Vector(0, -.33, 23.27),
            vang = Angle(90, 0, -90),
        },
        ExcludeFlags = {"sd", "m16_stub"},
    },
    {
        PrintName = "Upper Receiver",
        DefaultAttName = "5.56x45mm Upper",
        DefaultAttIcon = Material("entities/att/uc_bullets/556x45.png", "smooth mips"),
        Slot = {"ud_m16_receiver"},
        Bone = "m16_parent",
        Offset = {
            vpos = Vector(2.8, -4.2, -11.5),
            vang = Angle(90, 0, -90),
        },
        ExcludeFlags = {"ud_m16_fpw"}
    },
    {
        PrintName = "Lower Receiver",
        DefaultAttName = "Burst Lower",
        DefaultAttIcon = Material("entities/att/acwatt_ud_m16_receiver_default.png", "smooth mips"),
        Slot = {"ud_m16_fcg"},
        Bone = "m16_parent",
        Offset = {
            vpos = Vector(2.8, -4.2, -11.5),
            vang = Angle(90, 0, -90),
        },
        ExcludeFlags = {"m16_nolower"}
    },
    {
        PrintName = "Underbarrel",
        Slot = "foregrip",
        Bone = "m16_parent",
        Offset = {
            vpos = Vector(0, 6, 11),
            vang = Angle(90, 0, -90),
        },
        InstalledEles = {"rail_fg"},
        ExcludeFlags = {"m16_lmg", "m16_stub"},
        SlideAmount = {
            vmin = Vector(0, .65, 11.5),
            vmax = Vector(0, .65, 7.5),
        },
		MergeSlots = {18},
    },
    {
        PrintName = "Tactical",
        Slot = {"tac"},
        Bone = "m16_parent",
        Offset = {
            vpos = Vector(0, 0.3, 21.25),
            vang = Angle(90, 0, -90),
        },
        GivesFlags = {"tac"},
        --InstalledEles = {"ud_m16_clamp_fullsize"}
    },
    {
        PrintName = "Grip Type",
        Slot = {"ud_m16_grip"},
        DefaultAttName = "Standard Grip",
        DefaultAttIcon = Material("entities/att/acwatt_ud_m16_grip_default.png", "smooth mips"),
        ExcludeFlags = {"m16_adar"}
    },
    {
        PrintName = "Stock",
        Slot = {"ud_m16_stock","go_stock"},
        DefaultAttName = "Full Stock",
        DefaultAttIcon = Material("entities/att/acwatt_ud_m16_stock_default.png", "smooth mips"),
        -- GSO support
        InstalledEles = {"stock_231_tube"},
        Bone = "m16_parent",
        Offset = {
            vpos = Vector(-0.02, 0, -2.7),
            vang = Angle(90, 0, -90),
        },
    },
    {
        PrintName = "Magazine",
        Slot = {"ud_m16_mag"},
        DefaultAttName = "30-Round Mag",
        DefaultAttIcon = Material("entities/att/acwatt_ud_m16_mag_30.png", "smooth mips"),
    },
    {
        PrintName = "Ammo Type",
        DefaultAttName = "\"FMJ\" Full Metal Jacket",
        DefaultAttIcon = Material("entities/att/arccw_uc_ammo_generic.png", "mips smooth"),
        Slot = "uc_ammo",
    },
    {
        PrintName = "Powder Load",
        Slot = "uc_powder",
        DefaultAttName = "Standard Load"
    },
    {
        PrintName = "Training Package",
        Slot = "uc_tp",
        DefaultAttName = "Basic Training"
    },
    {
        PrintName = "Internals",
        Slot = "uc_fg", -- Fire group
        DefaultAttName = "Standard Internals"
    },
    {
        PrintName = "Front Sight",
        Slot = {"ud_m16_fs", "ud_m16_charm"},
        FreeSlot = true,
        Bone = "m16_parent",
        Offset = {
            vpos = Vector(0, -1.65, 16.75), -- 21.75 or 15.75
            vang = Angle(90, 0, -90),
        },
        ExcludeFlags = {"sight_magpul"}
    },
    {
        PrintName = "Charm",
        Slot = {"charm", "fml_charm"}, -- "ud_m16_charm"
        FreeSlot = true,
        Bone = "m16_parent",
        Offset = {
            vpos = Vector(0.48, 0.5, 3.9),
            vang = Angle(90, 0, -90),
        },
        -- MergeSlots = {17}
    },
    {
        PrintName = "M203 slot",
        Slot = "uc_ubgl",
        Bone = "m16_parent",
        Offset = {
            vpos = Vector(0, -0.4, 7.2),
            vang = Angle(90, 0, -90),
        },
        Hidden = true,
        InstalledEles = {"rail_fg"},
        ExcludeFlags = {"m16_lmg", "m16_stub"},
    }
}
--lua/weapons/arccw_ud_r870poly.lua:
return gluapack()()
--lua/weapons/arccw_ud_m16.lua:
return gluapack()()
--lua/weapons/arccw_ud_tac14.lua:
return gluapack()()
--lua/weapons/arccw_ur_ak.lua:
SWEP.Base = "arccw_base"
SWEP.Spawnable = true -- this obviously has to be set to true
SWEP.Category = "ArcCW - Urban Coalition" -- edit this if you like
SWEP.UC_CategoryPack = "2Urban Renewal"
SWEP.AdminOnly = false

SWEP.PrintName = "KF-67"
SWEP.TrueName = "AKM"

if GetConVar("arccw_truenames"):GetBool() then
    SWEP.PrintName = SWEP.TrueName
end

local descStart = "One of the first assault rifles, wielded around the world to this day for its cheap price, quick production, ease of maintenance, and infallible reliability. Consequently, it has become the most popular rifle ever; a constant of freedom fighters and third-world dictators virtually everywhere. One fifth of all small arms in existence can be traced to this design.\n\n"
local desc_762 = "The default pattern is well-rounded and hard-hitting, but kicks harder than other weapons of its class."
local desc_545 = "With a heavier frame than other service rifles, the AK-74 platform is accurate and easy to control."
local desc_74u = "This PDW variant sacrifices range and control to fit the power of a rifle into a very compact form."
local desc_9mm = "Well-rounded submachine gun that shares common parts with AK rifles. For its widespread use by a variety of security divisions, it can be described as a Russian counterpart to the MP5.\n\nThe moniker \"Vityaz\" translates to \"knight.\""
local desc_12g = "Magazine-fed semi automatic shotgun based on the Kalashnikov pattern. It is a popular civilian weapon due to the comparative simplicity of Russia's smoothbore gun licenses, but it has also been used by security firms around the world.\n\nIts low accuracy is compensated for by a much faster reload time than tube-fed designs."
local desc_556 = "This international variant has a lower damage output than the Russian cartridges, but boasts substantially lower recoil."
local desc_366 = "AK-pattern shotgun chambered in .366 TKM, a sporting cartridge that uses reshaped M43 casings. It is considered a shotgun because of its smoothbore barrel, a change made to circumvent Russian rifle laws. Despite the lack of rifling, it achieves similar ballistics to a proper AK-47."

SWEP.Trivia_Class = "Assault Rifle"
SWEP.Trivia_Desc = descStart .. desc_762
SWEP.Trivia_Manufacturer = "Izhmash"
SWEP.Trivia_Calibre = "7.62x39mm Soviet"
SWEP.Trivia_Mechanism = "Gas-Operated Rotating Bolt"
SWEP.Trivia_Country = "Soviet Union"
SWEP.Trivia_Year = 1959

SWEP.Slot = 2
SWEP.CamAttachment = 3

SWEP.UseHands = true

SWEP.ViewModel = "models/weapons/arccw/c_ur_ak.mdl"
SWEP.WorldModel = "models/weapons/arccw/c_ur_ak.mdl"
SWEP.ViewModelFOV = 70

SWEP.DefaultBodygroups = "010000800120"

-- Damage --

SWEP.Damage = 50 -- 2 shot close range kill
SWEP.DamageMin = 25 -- 4 shot long range kill
SWEP.RangeMin = 30
SWEP.Range = 300 -- 3 shot until ~170m
SWEP.Penetration = 16
SWEP.DamageType = DMG_BULLET
SWEP.ShootEntity = nil
SWEP.MuzzleVelocity = 715
SWEP.PhysBulletMuzzleVelocity = 715

SWEP.BodyDamageMults = ArcCW.UC.BodyDamageMults

-- Mag size --

SWEP.ChamberSize = 1
SWEP.Primary.ClipSize = 30
SWEP.ExtendedClipSize = 40
SWEP.ReducedClipSize = 15

-- Recoil --

SWEP.Recoil = 0.75
SWEP.RecoilSide = 0.3

SWEP.RecoilRise = 0.6
SWEP.RecoilPunch = 1
SWEP.VisualRecoilMult = 1
SWEP.MaxRecoilBlowback = 1
SWEP.MaxRecoilPunch = 1
SWEP.RecoilPunchBack = 2

SWEP.Sway = 0.6

-- Firerate / Firemodes --

SWEP.Delay = 60 / 600
SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 2,
    },
    {
        Mode = 1,
    },
    {
        Mode = 0,
    },
}

SWEP.ShootPitch = 100
SWEP.ShootVol = 120

SWEP.ProceduralRegularFire = false
SWEP.ProceduralIronFire = false

SWEP.ReloadInSights = true

-- NPC --

SWEP.NPCWeaponType = "weapon_ar2"
SWEP.NPCWeight = 60

-- Accuracy --

SWEP.AccuracyMOA = 5
SWEP.HipDispersion = 800
SWEP.MoveDispersion = 250
SWEP.JumpDispersion = 1000

SWEP.Primary.Ammo = "ar2"
SWEP.MagID = "ak"

SWEP.HeatCapacity = 75
SWEP.HeatDissipation = 15
SWEP.HeatDelayTime = 3

-- SWEP.Malfunction = true
SWEP.MalfunctionMean = 200
--SWEP.MeleeTime = 1.5

-- Speed multipliers --

SWEP.SpeedMult = 0.9
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.75

local path = ")weapons/arccw_ur/ak/"
local path1 = ")weapons/arccw_ur/mp5/"
local common = ")/arccw_uc/common/"
local rottle = {common .. "cloth_1.ogg", common .. "cloth_2.ogg", common .. "cloth_3.ogg", common .. "cloth_4.ogg", common .. "cloth_6.ogg", common .. "rattle.ogg"}
local ratel = {common .. "rattle1.ogg", common .. "rattle2.ogg", common .. "rattle3.ogg"}
local rutle = {common .. "movement-rifle-01.ogg",common .. "movement-rifle-02.ogg",common .. "movement-rifle-03.ogg",common .. "movement-rifle-04.ogg"}
--SWEP.FirstShootSound = path .. "fire_first.ogg"

SWEP.ShootSound = {
    path .. "fire-01.ogg",
    path .. "fire-02.ogg",
    path .. "fire-03.ogg",
    path .. "fire-04.ogg",
    path .. "fire-05.ogg",
    path .. "fire-06.ogg"
}
SWEP.ShootSoundSilenced = {
    path .. "fire-sup-01.ogg",
    path .. "fire-sup-02.ogg",
    path .. "fire-sup-03.ogg",
    path .. "fire-sup-04.ogg",
    path .. "fire-sup-05.ogg",
    path .. "fire-sup-06.ogg"
}
SWEP.DistantShootSound = nil
SWEP.DistantShootSoundSilenced = nil
SWEP.ShootDrySound = path .. "dryfire.ogg"

local tail = ")/arccw_uc/common/762x39/"

SWEP.DistantShootSoundOutdoors = {
    tail .. "fire-dist-762x39-rif-ext-01.ogg",
    tail .. "fire-dist-762x39-rif-ext-02.ogg",
    tail .. "fire-dist-762x39-rif-ext-03.ogg",
    tail .. "fire-dist-762x39-rif-ext-04.ogg",
    tail .. "fire-dist-762x39-rif-ext-05.ogg",
    tail .. "fire-dist-762x39-rif-ext-06.ogg"
}
SWEP.DistantShootSoundIndoors = {
    common .. "fire-dist-int-rifle-01.ogg",
    common .. "fire-dist-int-rifle-02.ogg",
    common .. "fire-dist-int-rifle-03.ogg",
    common .. "fire-dist-int-rifle-04.ogg",
    common .. "fire-dist-int-rifle-05.ogg",
    common .. "fire-dist-int-rifle-06.ogg"
}
SWEP.DistantShootSoundOutdoorsSilenced = {
    common .. "sup-tail-01.ogg",
    common .. "sup-tail-02.ogg",
    common .. "sup-tail-03.ogg",
    common .. "sup-tail-04.ogg",
    common .. "sup-tail-05.ogg",
    common .. "sup-tail-06.ogg",
    common .. "sup-tail-07.ogg",
    common .. "sup-tail-08.ogg",
    common .. "sup-tail-09.ogg",
    common .. "sup-tail-10.ogg"
}
SWEP.DistantShootSoundIndoorsSilenced = {
    common .. "fire-dist-int-pistol-light-01.ogg",
    common .. "fire-dist-int-pistol-light-02.ogg",
    common .. "fire-dist-int-pistol-light-03.ogg",
    common .. "fire-dist-int-pistol-light-04.ogg",
    common .. "fire-dist-int-pistol-light-05.ogg",
    common .. "fire-dist-int-pistol-light-06.ogg"
}
SWEP.DistantShootSoundOutdoorsVolume = 1
SWEP.DistantShootSoundIndoorsVolume = 1
SWEP.Hook_AddShootSound = ArcCW.UC.InnyOuty

SWEP.MuzzleEffect = "muzzleflash_6"
SWEP.ShellEffect = "arccw_uc_shelleffect"
SWEP.ShellModel = "models/weapons/arccw/uc_shells/762x39.mdl"
SWEP.ShellPitch = 90
SWEP.ShellScale = .666
SWEP.ShellRotateAngle = Angle(0, 0, 0)
SWEP.UC_ShellColor = Color(0.7 * 255, 0.2 * 255, 0.2 * 255)

SWEP.MuzzleEffectAttachment = 1 -- which attachment to put the muzzle on
SWEP.CaseEffectAttachment = 2 -- which attachment to put the case effect on

SWEP.BulletBones = {
    [1] = "tag_mag2",
}

SWEP.IronSightStruct = {
    Pos = Vector(-2.61, -2, 0.45),
    Ang = Angle(0.60, 0.274, 5.53),
    Magnification = 1.1,
    SwitchToSound = "", -- sound that plays when switching to this sight
    CrosshairInSights = false
}
SWEP.LaserOffsetAngle = Angle(0, 0, 0)
SWEP.LaserIronsAngle = Angle(0, 0, 0)

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0.5, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, 0, 0)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.CrouchPos = Vector(-2, -2, -0.6)
SWEP.CrouchAng = Angle(0, 0, -14)

SWEP.HolsterPos = Vector(-1, -1, 1.2)
SWEP.HolsterAng = Angle(-15, 8, -10)

SWEP.BarrelOffsetSighted = Vector(0, 0, 0)
SWEP.BarrelOffsetHip = Vector(0, 0, 0)

-- SWEP.CustomizePos = Vector(6.5, 0.8, -0.2)
-- SWEP.CustomizeAng = Angle(8, 22, 15)

SWEP.CustomizePos = Vector(0, 0, 0)
SWEP.CustomizeAng = Angle(0, 0, 0)

SWEP.BarrelLength = 24

SWEP.AttachmentElements = {
    ["barrel_74m"] = {
        VMBodygroups = {{ind = 1, bg = 3}}
    },
    ["barrel_74m_red"] = {
        VMBodygroups = {{ind = 1, bg = 10}}
    },
    ["barrel_74m_green"] = {
        VMBodygroups = {{ind = 1, bg = 11}}
    },
    ["barrel_akm"] = {
        VMBodygroups = {{ind = 1, bg = 0}}
    },
    ["barrel_alpha"] = {
        VMBodygroups = {
            {ind = 1, bg = 7},
            -- {ind = 7, bg = 6},
            -- {ind = 8, bg = 2},
        },
    },
    ["barrel_rpk"] = {
        VMBodygroups = {
            {ind = 7, bg = 1},
            {ind = 8, bg = 2}
        },
        AttPosMods = {[4] = {
            vpos = Vector(0, 32.2, 2.6),
            vang = Angle(0, 270, 0),
        }},
    Override_IronSightStruct = {
            Pos = Vector(-2.625, -2, 0.68),
            Ang = Angle(-0.1, 0.274, 5.53),
            Magnification = 1,
    }
    },
    ["barrel_rpk74m"] = {
        VMBodygroups = {
            {ind = 1, bg = 5},
            -- {ind = 7, bg = 1},
            -- {ind = 8, bg = 2}
        },
        -- AttPosMods = {[4] = {
        --     vpos = Vector(0, 32.2, 2.6),
        --     vang = Angle(0, 270, 0),
        -- }},
        -- Override_IronSightStruct = {
        -- 	Pos = Vector(-2.625, -2, 0.68),
        -- 	Ang = Angle(-0.1, 0.274, 5.53),
        -- 	Magnification = 1,
        -- }
    },
    ["barrel_krinkov"] = {
        VMBodygroups = {
            {ind = 1, bg = 6},
            {ind = 7, bg = 5},
            {ind = 8, bg = 2},
            {ind = 4, bg = 1},
            {ind = 5, bg = 1}
        },
        AttPosMods = {
            [4] = {
                vpos = Vector(0, 15, 2.85),
                vang = Angle(0, 270, 0),
            },
            [7] = {
                vpos = Vector(0,10,1.7),
                vang = Angle(90, -90, -90),
                SlideAmount = {
                    vmin = Vector(0,10,1.7),
                    vmax = Vector(0,10,1.7)
                },
            },
            [8] = {
                vpos = Vector(-0.8, 11.75, 2.9),
                vang = Angle(-90, 270, 0),
                wang = Angle(-90, 270, 0),
            }
        },
        Override_IronSightStruct = {
            Pos = Vector(-2.638, -2, 0.9),
            Ang = Angle(-1, 0.12, 5.53),
            Magnification = 1,
        }
    },
    ["barrel_vityaz"] = {
        VMBodygroups = {
            {ind = 1, bg = 8},
            {ind = 7, bg = 5},
            {ind = 8, bg = 2},
            {ind = 5, bg = 1}
        },
        AttPosMods = {
            [4] = {
                vpos = Vector(0, 16.5, 2.85),
                vang = Angle(0, 270, 0),
            },
            [7] = {
                vpos = Vector(0,11,1.7),
                vang = Angle(90, -90, -90),
                SlideAmount = {
                    vmin = Vector(0,10,1.7),
                    vmax = Vector(0,11,1.7)
                },
            },
            [8] = {
                vpos = Vector(-0.8, 11.75, 2.9),
                vang = Angle(-90, 270, 0),
                wang = Angle(-90, 270, 0),
            }
        },
        Override_IronSightStruct = {
            Pos = Vector(-2.62, -2, 0.75),
            Ang = Angle(-0.42, 0.2, 5.53),
            Magnification = 1,
        }
    },
    ["barrel_t56"] = {
        VMBodygroups = {
            {ind = 7, bg = 3},
            {ind = 11, bg = 2},
            {ind = 8, bg = 2}
        },
    },
    ["barrel_t56_ext"] = {
        VMBodygroups = {
            {ind = 7, bg = 3},
            {ind = 11, bg = 3},
            {ind = 8, bg = 2}
        },
    },
    ["barrel_vepr"] = {
        VMBodygroups = {
            --{ind = 1, bg = 9},
            {ind = 7, bg = 4},
            {ind = 8, bg = 2}
        },
        AttPosMods = {[4] = {
            vpos = Vector(0, 28.5, 2.7),
            vang = Angle(0, 270, -0),
        }},
        Override_IronSightStruct = {
            Pos = Vector(-2.63, -2, 0.76),
            Ang = Angle(-0.3, 0.18, 5.53),
            Magnification = 1,
        }
    },

    ["ur_ak_hg_vepr"] = {
        VMBodygroups = {
            {ind = 1, bg = 9},
        },
    },

    ["barrel_105"] = {
        VMBodygroups = {
            --{ind = 1, bg = 3},
            {ind = 7, bg = 2},
            {ind = 8, bg = 2}
        },
        AttPosMods = {[4] = {
            vpos = Vector(0, 19.9, 2.7),
            vang = Angle(0, 270, 0),
        }},
        Override_IronSightStruct = {
            Pos = Vector(-2.6, -2, 0.48),
            Ang = Angle(0.6, 0.265, 5.53),
            Magnification = 1,
        }
    },
    ["barrel_dong"] = {
        VMBodygroups = {{ind = 1, bg = 2}}, -- This will show up regardless of barrel selection because underbarrel atts are always processed after barrel atts
        AttPosMods = {[6] = {
            SlideAmount = {
                vmin = Vector(0,12,1.9),
                vmax = Vector(0,12,1.9)
            },
        }}
    },

    ["muzzle_akm"] = {
        VMBodygroups = {{ind = 8, bg = 1}}
    },
    ["muzzle_ak74"] = {
        VMBodygroups = {{ind = 8, bg = 3}}
    },
    ["muzzle_aku"] = {
        VMBodygroups = {{ind = 8, bg = 6}}
    },
    ["muzzle_bayonet"] = {
        VMBodygroups = {{ind = 11, bg = 1}}
    },

    ["stock_alpha"] = {
        VMBodygroups = {
            {ind = 6, bg = 4},
            {ind = 3, bg = 1},
        }

    },
    ["stock_aks"] = {
        VMBodygroups = {
            {ind = 6, bg = 3},
            {ind = 3, bg = 1},
    }
    },
    ["stock_aks_folded"] = {
        VMBodygroups = {
            {ind = 6, bg = 10},
            {ind = 3, bg = 1},
        }

    },
    ["stock_underfolder"] = {
        VMBodygroups = {{ind = 6, bg = 2}}
    },
    ["stock_underfolder_folded"] = {
        VMBodygroups = {{ind = 6, bg = 1}}
    },
    ["stock_ak74m"] = {
        VMBodygroups = {
            {ind = 3, bg = 1},
            {ind = 6, bg = 12}
        }
    },
    ["stock_ak74m_folded"] = {
        VMBodygroups = {
            {ind = 3, bg = 1},
            {ind = 6, bg = 13}
        }
    },
    ["stock_rpk"] = {
        VMBodygroups = {{ind = 6, bg = 5}}
    },
    ["stock_akn"] = {
        VMBodygroups = {{ind = 6, bg = 0}}
    },
    ["stock_skeletal"] = {
        VMBodygroups = {
            {ind = 6, bg = 6},
            {ind = 3, bg = 1},
        }
    },
    ["stock_vepr"] = {
        VMBodygroups = {
            {ind = 6, bg = 7},
            {ind = 9, bg = 4}
        }
    },
    ["stock_none"] = {
        VMBodygroups = {
            {ind = 6, bg = 9},
            {ind = 3, bg = 1},
        }
    },

    ["mag_762_75"] = {
        VMBodygroups = {{ind = 2, bg = 1}}
    },
    ["mag_762_bakelite"] = {
        VMBodygroups = {{ind = 2, bg = 11}}
    },
    ["mag_762_pmag"] = {
        VMBodygroups = {{ind = 2, bg = 12}}
    },
    ["mag_545_30"] = {
        VMBodygroups = {{ind = 2, bg = 2}}
    },
    ["mag_556_30"] = {
        VMBodygroups = {{ind = 2, bg = 10}}
    },
    ["mag_545_45"] = {
        VMBodygroups = {{ind = 2, bg = 3}}
    },
    ["mag_9mm"] = {
        VMBodygroups = {{ind = 2, bg = 4}}
    },
    ["mag_12g"] = {
        VMBodygroups = {{ind = 2, bg = 5}}
    },
    ["mag_366"] = {
        VMBodygroups = {{ind = 2, bg = 6}}
    },

    ["grip_akm"] = {
        VMBodygroups = {{ind = 9, bg = 0}}
    },
    ["grip_alpha"] = {
        VMBodygroups = {{ind = 9, bg = 2}}
    },
    ["grip_saiga"] = {
        VMBodygroups = {{ind = 9, bg = 3}}
    },

    ["cover_ribbed"] = {
        VMBodygroups = {{ind = 10, bg = 0}}
    },
    ["cover_alpha"] = {
        VMBodygroups = {{ind = 10, bg = 1}},
        AttPosMods = {[1] = {
            vpos = Vector(0, 3.5, 4.68),
            vang = Angle(0, -90, 0),
        }}
    },
    ["optic_raillaser"] = {
        AttPosMods = {
            [8] = {
                vpos = Vector(0.95, 2.5, 4.05),
                vang = Angle(0, -90, 125),
            },
        },
    },
    ["cover_ak12"] = {
        VMBodygroups = {{ind = 10, bg = 4}},
        AttPosMods = {[1] = {
            vpos = Vector(0, 3.5, 4.67),
            vang = Angle(0, -90, 0),
        }}
    },

    ["grip_ak12"] = {
        VMBodygroups = {{ind = 9, bg = 5}}
    },
    ["stock_ak12"] = {
        VMBodygroups = {{ind = 6, bg = 11}},
    },
    ["handguard_ak12"] = {
        VMBodygroups = {{ind = 1, bg = 12}},
        --[[AttPosMods = {[6] = {
            vpos = Vector(0, 11.75, 2.2),
            vang = Angle(90, -90, -90),
        }}]]
        AttPosMods = {
            [8] = {
                vpos = Vector(-0.7, 13.5, 3.8),
                vang = Angle(-90, 270, 0),
                wang = Angle(-90, 270, 0),
            },
            [7] = {
                vpos = Vector(0, 11.75, 2.2),
                vang = Angle(90, -90, -90),
            }
        },
    },
    ["barrel_ak12"] = {
        VMBodygroups = {
            {ind = 7, bg = 6},
            {ind = 8, bg = 2}
        },
        AttPosMods = {[4] = {
            vpos = Vector(0, 23.5, 2.8),
            vang = Angle(0, 270, 0),
        }},
        Override_IronSightStruct = {
            Pos = Vector(-2.68, 0, 1.3),
            Ang = Angle(-2.02, 0.028, 5.53),
            Magnification = 1,
        }
        --RequireFlags = {"cover_rail"},
    },
    ["muzzle_ak12"] = {
        VMBodygroups = {{ind = 8, bg = 2}},
    },
    ["reciever_ak12"] = {
        VMBodygroups = {{ind = 0, bg = 1}}
    },
    ["sight_ak12"] = {
        VMBodygroups = {{ind = 4, bg = 3}},
        RequireFlags = {"cover_rail", "ak_railedguard"},
        Override_IronSightStruct = {
            Pos = Vector(-2.63, 0, 0.79),
            Ang = Angle(-1.12, 0.116, 5.53),
            Magnification = 1,
        },
        Override_IronSightStruct_Priority = 2,
    },
    ["mag_545_ak12"] = {
        VMBodygroups = {{ind = 2, bg = 7}}
    },
    ["mag_545_black"] = {
        VMBodygroups = {{ind = 2, bg = 9}}
    },
    ["mag_308"] = {
        VMBodygroups = {{ind = 2, bg = 8}}
    },

    ["cover_trail"] = {
        VMBodygroups = {{ind = 4, bg = 4}},
        AttPosMods = {[1] = {
            vpos = Vector(0, 8.2, 5.20),
            vang = Angle(0, -90, 0),
        }}
    },
}

SWEP.Hook_ModifyBodygroups = function(wep, data)
    local akOptics = {["uc_optic_pso1"] = true, ["uc_optic_kobra"] = true} -- Will need to update this list if more AK optics get added
    local railHgs = {["default"] = true, ["type3"] = true}
    local bipodBarrs = {["rpk"] = true}
    local shortBarrs = {["krinkov"] = true, ["vityaz"] = true}
    local intCals = {["545"] = true, ["556"] = true, ["545_ak12"] = true}

    local optic = wep.Attachments[1].Installed
    local barr = string.Replace(wep.Attachments[2].Installed or "default","ur_ak_barrel_","")
    local hg = string.Replace(wep.Attachments[3].Installed or "default","ur_ak_hg_","")
    local muzz = wep.Attachments[4].Installed
    local cal = string.Replace(wep.Attachments[5].Installed or "default","ur_ak_cal_","")
    local ub = wep.Attachments[7].Installed-- or wep.Attachments[17].Installed
    local upper = wep.Attachments[15].Installed
    local alpha = (upper == "ur_ak_cover_alpha" or upper == "ur_ak_cover_ak12" or upper == "ur_ak_cover_truniun_rail")
    local taclaser = (wep.Attachments[16].Installed == "ur_ak_charm_tl")

    local vm = data.vm
    if !IsValid(vm) then return end

    -- Default muzzle devices
    if !muzz or muzz == "ur_ak_muzzle_bayonet" then
        if barr == "ak12" and (cal == "default" or intCals[cal]) then
            vm:SetBodygroup(8,3)
        elseif barr == "krinkov" then
            vm:SetBodygroup(8,4)
        elseif barr == "default" or barr == "t56" then
            if cal == "default" then
                vm:SetBodygroup(8,1)
            elseif intCals[cal] then
                vm:SetBodygroup(8,3)
            else
                vm:SetBodygroup(8,0)
            end
        end
    elseif barr == "default" then
        vm:SetBodygroup(8,0)
    else
        vm:SetBodygroup(8,2)
    end

    --
    if taclaser and !akOptics[optic] then
        vm:SetBodygroup(12,2)
    else
        if optic and !alpha and !akOptics[optic] then
            vm:SetBodygroup(12,1)
        else
            vm:SetBodygroup(12,0)
        end
    end

    -- Railed underbarrel
    if ub and hg != "ur_ak_hg_dong" and barr != "vityaz" then
        if barr == "krinkov" then
            vm:SetBodygroup(13,2)
        elseif railHgs[hg] then
            vm:SetBodygroup(1,13)
        else
            vm:SetBodygroup(13,1)
        end
    else
        vm:SetBodygroup(13,0)
    end

    -- RPK bipod
    if bipodBarrs[barr] then
        vm:SetBodygroup(7, (wep:GetInBipod() and (wep.LastAnimKey ~= "enter_bipod" or wep.LastAnimFinishTime < CurTime())) and 7 or 1)
    end
end

SWEP.ExtraSightDist = 2
SWEP.GuaranteeLaser = false

SWEP.WorldModelOffset = {
    pos = Vector(-7, 4, -4),
    ang = Angle(-12, 0, 180)
}

SWEP.MirrorVMWM = true

SWEP.Attachments = {
    {
        PrintName = "Optic",
        DefaultAttName = "Iron Sights",
        Slot = {"optic","optic_sniper","ur_ak_optic"},
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(0, 2, 4.92),
            vang = Angle(0, -90, 0),
        },
        CorrectivePos = Vector(0, 0, -0.0),
        CorrectiveAng = Angle(-1.9, 180.15, 0),
        VMScale = Vector(1, 1, 1),
        -- SlideAmount = {
        --     vmin = Vector(0, 2-1, 4.55),
        --     vmax = Vector(0, 2+0.5, 4.55),
        -- },
--        RequireFlags = {"cover_rail"},
--        HideIfBlocked = true,
        -- InstalledEles = {"optic_rail"},
    },
    {
        PrintName = "Barrel",
        DefaultAttName = "16\" Standard Barrel",
        DefaultAttIcon = Material("entities/att/ur_ak/barrel/std.png", "mips smooth"),
        Slot = "ur_ak_barrel",
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(0,12, 1.9),
            vang = Angle(90, -90, -90),
        },
    },
    {
        PrintName = "Handguard",
        DefaultAttName = "Factory Handguard",
        DefaultAttIcon = Material("entities/att/ur_ak/handguards/std.png", "mips smooth"),
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(0,12, 1.9),
            vang = Angle(90, -90, -90),
        },
        Slot = "ur_ak_hg",
        ExcludeFlags = {"barrel_carbine"},
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Standard Muzzle",
        Slot = {"muzzle","ur_ak_muzzle"},
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(0, 24.1, 2.7),
            vang = Angle(0, 270, 0),
        },
        ExcludeFlags = {"ur_ak_nomuzzle"},
        --Installed = "ur_ak_muzzle_akm"
    },
    {
        PrintName = "Receiver",
        DefaultAttName = "7.62x39mm Reciever",
        DefaultAttIcon = Material("entities/att/uc_bullets/762x39.png", "mips smooth"),
        Slot = {"ur_ak_cal"},
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(2.8, -4.2, -11.5),
            vang = Angle(90, 0, -90),
        },
        DefaultFlags = {"cal_default"}
    },
    {
        PrintName = "Magazine",
        Slot = {"ur_ak_mag"},
        DefaultAttName = "30-Round Mag",
        DefaultAttIcon = Material("entities/att/ur_ak/magazines/762_30.png", "mips smooth"),
    },
    {
        PrintName = "Underbarrel",
        Slot = {"foregrip","ur_ak_ub"},
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(0,12, 1.9),
            vang = Angle(90, -90, -90),
        },
        VMScale = Vector(1, 1, 1),
        SlideAmount = {
            vmin = Vector(0,10.5,1.9),
            vmax = Vector(0,13.5,1.9)
        },
        InstalledEles = {"rail_fg"},
        ExcludeFlags = {"ak_noubs"},
        MergeSlots = {17},
    },
    {
        PrintName = "Tactical",
        Slot = {"tac"},
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(0, 19.6, 2.1),
            vang = Angle(0, 270, 0),
        },
        GivesFlags = {"tac"},
        --InstalledEles = {"ud_m16_clamp_fullsize"}
    },
    {
        PrintName = "Grip Type",
        Slot = {"ur_ak_grip"},
        DefaultAttName = "Factory Grip",
        DefaultAttIcon = Material("entities/att/ur_ak/grip_modern.png", "mips smooth"),
        ExcludeFlags = {"stock_vepr"},
    },
    {
        PrintName = "Stock",
        Slot = {"ur_ak_stock"},
        DefaultAttName = "Factory Stock",
        DefaultAttIcon = Material("entities/att/ur_ak/stock/n.png", "mips smooth"),
    },
    {
        PrintName = "Ammo Type",
        DefaultAttName = "\"FMJ\" Full Metal Jacket",
        DefaultAttIcon = Material("entities/att/arccw_uc_ammo_generic.png", "mips smooth"),
        Slot = "uc_ammo",
    },
    {
        PrintName = "Powder Load",
        Slot = "uc_powder",
        DefaultAttName = "Standard Load"
    },
    {
        PrintName = "Training Package",
        Slot = "uc_tp",
        DefaultAttName = "Basic Training"
    },
    {
        PrintName = "Internals",
        Slot = "uc_fg", -- Fire group
        DefaultAttName = "Standard Internals"
    },
    {
        PrintName = "Dust Cover",
        DefaultAttName = "Ribbed Dust Cover",
        DefaultAttIcon = Material("entities/att/ur_ak/dustcover_stock.png", "mips smooth"),
        Slot = {"ur_ak_cover"},
        FreeSlot = true,
    },
    {
        PrintName = "Charm",
        Slot = {"charm", "fml_charm", "ur_ak_charm"},
        FreeSlot = true,
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(0.6, 6.7, 2.2),
            vang = Angle(90, -90, -90),
        },
    },
    {
        PrintName = "M203 slot",
        Slot = "uc_ubgl",
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(0, 9.9, 2.9),
            vang = Angle(90, -90, -90),
        },
        InstalledEles = {"rail_fg"},
        ExcludeFlags = {"ak_noubs","barrel_rpk"},
        Hidden = true,
    }
}

function SWEP:Hook_TranslateAnimation(anim)
    if anim == "fire_iron" then
        if self:GetBuff_Override("NoStock") then return "fire" end
    elseif anim == "fire_iron_empty" then
        if self:GetBuff_Override("NoStock") then return "fire_empty" end
    end
end

SWEP.Hook_NameChange = function(wep,name)
    local foldStocks = {["underfolder"] = true,["aks"] = true}
    local akCals = {["762"] = true,["545"] = true}
    local shortBarrs = {["krinkov"] = true,["vityaz"] = true}
    local fakeNames = !GetConVar("arccw_truenames"):GetBool()

    local start = "AK"
    local mid = ""
    local post = "M"
    local noN = false

    if fakeNames then
        start = "KF"
        post = "-67"
    end

    local atts = wep.Attachments
    local barr = string.Replace(atts[2].Installed or "default", "ur_ak_barrel_", "")
    local hg = string.Replace(atts[3].Installed or "default", "ur_ak_hg_", "")
    local cal = string.Replace(atts[5].Installed or "762", "ur_ak_cal_", "")
    local stock = string.Replace(atts[10].Installed or "default", "ur_ak_stock_", "")
    local upper = atts[11].Installed
    local alpha = (upper == "ur_ak_cover_alpha" or upper == "ur_ak_cover_ak12" or upper == "ur_ak_cover_truniun_rail")
    -- local ak12 = alpha and barr == "ak12"

    wep.Trivia_Desc = descStart .. desc_762
    wep.Trivia_Mechanism = "Gas-Operated Rotating Bolt"

    if alpha then noN = true end

    if atts[14].Installed == "uc_fg_civvy" then
        start = (fakeNames and "Amur") or "Vepr"
        if cal == "12g" then
            post = "-12"
            wep.Trivia_Desc = desc_12g
        elseif cal == "545_ak12" or cal == "545" then
            post = " 5.45"
            wep.Trivia_Desc = descStart .. desc_545
        elseif cal == "762" then
            post = " 7.62"
        elseif cal == "9mm" then
            start = "Saiga"
            post = "-9"
            wep.Trivia_Desc = desc_9mm
            wep.Trivia_Mechanism = "Blowback"
        else
            post = " ." .. cal
        end
        return start .. post
    end

    if cal == "9mm" then
        if fakeNames then
            start = "Bogatyr"
            post = " SMG"
        else
            start = "PP"
            post = "-19 Vityaz"
        end
        wep.Trivia_Desc = desc_9mm
        wep.Trivia_Mechanism = "Blowback"
    -- elseif cal == "12g" then
    --     start = "Saiga"
    --     if shortBarrs[barr] then
    --         post = "-12K"
    --     else
    --         post = "-12"
    --     end
    --     wep.Trivia_Desc = desc_12g -- Obsolete
    elseif cal == "366" then
        if barr == "vepr" or string.find(atts[14].Installed or "","rifling") then
            start = (fakeNames and "Amur") or "Vepr"
            post = " .366"
        else
            start = (fakeNames and "KFN") or "VPO"
            post = "-209"
            wep.Trivia_Desc = desc_366
        end
    elseif cal == "308" then
        post = "-308"
    -- elseif cal == "545_ak12" or ak12 then
    --     noN = true
    --     if string.StartWith(cal,"545") then
    --         post = "-12"
    --         wep.Trivia_Desc = descStart .. desc_545
    --     elseif cal == "762" then
    --         post = "-15"
    --     elseif cal == "556" then
    --         post = "-18"
    --     end
    --     if string.EndsWith(barr,"105") or shortBarrs[barr] then
    --         post = post .. "K"
    --     end -- Obsolete
    elseif barr == "rpk" or barr == "rpk74m" then
        start = (fakeNames and "PKF") or "RPK"
        if !fakeNames and barr == "rpk" and cal == "762" then
            post = ""
        end
    elseif cal == "762" then
        if barr == "t56" then
            noN = true
            if fakeNames then
                start = "Yucha"
                post = " 7"
            else
                start = "Type "
                post = "56"
            end
        elseif (hg == "74m" or hg == "rpk74m" or hg == "ak12") and stock == "ak74m" then
            noN = true
            post = "-103"
        end
    elseif cal == "556" then
        if fakeNames then
            post = "-45"
        elseif string.EndsWith(barr,"105") then
            post = "-102"
        else
            post = "-101"
        end
        wep.Trivia_Desc = descStart .. desc_556
    end

    if foldStocks[stock] and akCals[cal] and !string.StartWith(barr,"105") then
        if cal == "762" then
            if barr == "t56" then
                post = post .. "-1"
            elseif !fakeNames then
                post = "MS"
            else
                mid = "S"
            end
        else
            mid = "S"
        end
    end

    if cal == "545" then
        wep.Trivia_Desc = descStart .. desc_545
        if (hg == "74m" or hg == "rpk74m" or hg == "ak12") and stock == "ak74m" then
            noN = true
            post = (fakeNames and "-76M") or "-74M"
        elseif shortBarrs[barr] then
            if fakeNames then
                post = "-76"
                mid = mid .. "U"
            else
                post = "-74U"
            end
            wep.Trivia_Desc = descStart .. desc_74u
        else
            post = (fakeNames and "-76") or "-74"
        end
    end

    if akCals[cal] then
        if string.EndsWith(barr,"105") then
            noN = true
            if cal == "545" then
                post = "-105"
            elseif cal == "762" then
                post = "-104"
            elseif cal == "556" then
                post = "-102"
            end
        else
            -- if shortBarrs[barr] then
            --     post = post .. "U" -- I know I said the AK-47U doesn't exist, but we have fucking Glock 44 Autos so I warmed up to it
            --     wep.Trivia_Desc = descStart .. desc_74u
            -- end
            if !noN and atts[1].Installed then
                post = post .. "N"
            end
        end

    end

    return start .. mid .. post
end

SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["draw"] = {
        Source = "draw",
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 0.5,
        SoundTable = {
            {s = ratel, t = 0},
            {s = common .. "raise.ogg", t = 0.2},
            {s = common .. "shoulder.ogg",    t = 0.2},
        },
    },
    ["holster"] = {
        Source = "holster",
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 0.5,
        SoundTable = {
            {s = ratel, t = 0},
           -- {s = common .. "raise.ogg", t = 0.2},
            -- {s = common .. "shoulder.ogg",    t = 0.2},
        },
    },
    ["ready"] = {
        Source = "ready",
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0.6,
        LHIKEaseOut = 0.25,
        SoundTable = {
            {s = ratel, t = 0},
            {s = path .. "chback.ogg",    t = 0.2},
            {s = path .. "chamber.ogg",    t = 0.3},
            {s = common .. "shoulder.ogg",    t = .6},
        },
    },
    ["fire"] = {
        Source = {"fire"},
        Time = 0.5,
        ShellEjectAt = 0,
        SoundTable = {{ s = {path .. "mech-01.ogg", path .. "mech-02.ogg", path .. "mech-03.ogg", path .. "mech-04.ogg", path .. "mech-05.ogg", path .. "mech-06.ogg"}, t = 0, v = 0.25 }},
    },
    ["fire_iron"] = {
        Source = {"fire"},
        Time = 0.5,
        ShellEjectAt = 0,
        SoundTable = {{ s = {path .. "mech-01.ogg", path .. "mech-02.ogg", path .. "mech-03.ogg", path .. "mech-04.ogg", path .. "mech-05.ogg", path .. "mech-06.ogg"}, t = 0 }},
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.65,
        LHIKEaseOut = 0.25,
        MinProgress = 1.3,
        SoundTable = {
            {s = common .. "magpouch.ogg", t = 0.0, v = 0.45},
            {s = path .. "reload_start.ogg", 	 t = 0.025},
            {s = rottle,  t = 0.05},
            {s = ratel, t = 0.25},
            {s = path .. "magrelease.ogg", 	 t = 0.4},
            {s = path .. "magout.ogg", 	 t = 0.45},
            {s = ratel, t = 0.5},
            {s = rottle,  t = 0.75},
            {s = path .. "magin.ogg",    t = 0.95},
            {s = ratel, t = 1.1},
            {s = rottle,  t = 1.15},
            {s = path .. "scrape.ogg",    t = 1.35},
            {s = common .. "magpouchin.ogg", t = 1.38},
            {s = path .. "grab.ogg", t = 1.9, v = 0.45},
            {s = common .. "shoulder.ogg", t = 2.0},
            {s = path .. "shoulder.ogg", t = 2.15},
        },
    },
    ["reload_empty"] = {
        Source = "reload_empty",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.5,
        LHIKEaseOut = 0.25,
        MinProgress = 2.1,
        LastClip1OutTime = 2,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = common .. "magpouch.ogg", t = 0.1},
            {s = ratel, t = 0.25},
            {s = path .. "magrelease.ogg", 	 t = 0.4},
            {s = path .. "magout.ogg", 	 t = 0.45},
            {s = path .. "bonk.ogg", 	 t = 0.5},
            {s = ratel, t = 0.5},
            {s = rottle,  t = 0.75},
            {s = path .. "magin.ogg",    t = 0.97},
            {s = ratel, t = 1.1},
            {s = common .. "rifle_magdrop.ogg", t = 1.15, v = 0.5},
            {s = rottle,  t = 1.16},
            {s = path .. "chback.ogg",    t = 1.9},
            {s = path .. "chamber.ogg",    t = 2.0},
            {s = path .. "grab.ogg", t = 2.3, v = 0.45},
            {s = common .. "shoulder.ogg", t = 2.4},
            {s = path .. "shoulder.ogg", t = 2.5},
        },
    },
    ["reload_75"] = {
        Source = "reload_drum",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.9,
        LHIKEaseOut = 0.25,
        MinProgress = 1.6,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = common .. "magpouch.ogg", t = 0.1},
            {s = ratel, t = 0.25},
            {s = path .. "magrelease.ogg", 	 t = 0.1},
            {s = path .. "magout_drum.ogg", 	 t = 0.25},
            {s = ratel, t = 0.5},
            {s = rottle,  t = 0.75},
            {s = ratel, t = 1.0},
            {s = path .. "magin_drum.ogg",    t = 1.1},
            {s = rottle,  t = 1.75},
            {s = path .. "grab.ogg", t = 2.0, v = 0.45},
            {s = common .. "shoulder.ogg", t = 2.1},
            {s = path .. "shoulder.ogg", t = 2.25},
        },
    },
    ["reload_empty_75"] = {
        Source = "reload_drum_empty",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 1.5,
        LHIKEaseOut = 0.25,
        MinProgress = 2.6,
        LastClip1OutTime = 2,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = common .. "magpouch.ogg", t = 0.1},
            {s = ratel, t = 0.25},
            {s = path .. "magrelease.ogg", 	 t = 0.1},
            {s = path .. "magout_drum.ogg", 	 t = 0.25},
            {s = ratel, t = 0.5},
            {s = rottle,  t = 0.75},
            {s = ratel, t = 1.0},
            {s = path .. "magin_drum.ogg",    t = 1.1},
            {s = path .. "grab.ogg", t = 2.0, v = 0.45},
            {s = rottle,  t = 1.9},
            {s = path .. "chback.ogg",    t = 2.37},
            {s = path .. "chamber.ogg",    t = 2.48},
            {s = common .. "shoulder.ogg", t = 2.78},
            {s = path .. "shoulder.ogg", t = 2.93},
        },
    },
    ["reload_9mm"] = {
        Source = "reload_9mm",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.9,
        LHIKEaseOut = 0.25,
        MinProgress = 1.3,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = common .. "magpouch.ogg", t = 0.1},
            {s = ratel, t = 0.25},
            {s = path1 .. "magout.ogg", 	 t = 0.45},
            {s = ratel, t = 0.5},
            {s = rottle,  t = 0.75},
            {s = path1 .. "magin.ogg",    t = 0.73},
            {s = ratel, t = 1.1},
            {s = rottle,  t = 1.15},
            {s = path .. "scrape.ogg",    t = 1.4},
            {s = common .. "magpouchin.ogg", t = 1.35},
            {s = common .. "shoulder.ogg", t = 2.05},
            {s = common .. "grab.ogg", t = 2.1},
        },
    },
    ["reload_empty_9mm"] = {
        Source = "reload_9mm_empty",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.55,
        LHIKEaseOut = 0.25,
        MinProgress = 2.1,
        LastClip1OutTime = 2,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = common .. "magpouch.ogg", t = 0.1},
            {s = ratel, t = 0.25},
            {s = path1 .. "magout.ogg", 	 t = 0.45},
            {s = ratel, t = 0.5},
            {s = rottle,  t = 0.75},
            {s = path1 .. "magin.ogg",    t = 0.85},
            {s = ratel, t = 1.1},
            {s = common .. "pistol_magdrop.ogg", t = 1.15},
            {s = rottle,  t = 1.15},
            {s = path .. "chback_9.ogg",    t = 1.8},
            {s = path .. "chamber_9.ogg",    t = 2.05},
            {s = common .. "grab.ogg", t = 2.4},
            {s = common .. "shoulder.ogg", t = 2.5},
        },
    },
    ["reload_10rnd"] = {
        Source = "reload_10rnd",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.9,
        LHIKEaseOut = 0.25,
        MinProgress = 1.3,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = common .. "magpouch.ogg", t = 0.1},
            {s = ratel, t = 0.25},
            {s = path .. "magout.ogg", 	 t = 0.45},
            {s = ratel, t = 0.5},
            {s = rottle,  t = 0.75},
            {s = path .. "magin.ogg",    t = 0.95},
            {s = ratel, t = 1.1},
            {s = rottle,  t = 1.15},
            {s = path .. "scrape.ogg",    t = 1.35},
            {s = common .. "magpouchin.ogg", t = 1.35},
            {s = common .. "shoulder.ogg", t = 2.05},
            {s = common .. "grab.ogg", t = 2.1},
        },
    },
    ["reload_empty_10rnd"] = {
        Source = "reload_10rnd_empty",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.55,
        LHIKEaseOut = 0.25,
        MinProgress = 2.1,
        LastClip1OutTime = 2,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = common .. "magpouch.ogg", t = 0.1},
            {s = ratel, t = 0.25},
            {s = path .. "magout.ogg", 	 t = 0.45},
            {s = path .. "bonk.ogg", 	 t = 0.5},
            {s = ratel, t = 0.5},
            {s = rottle,  t = 0.75},
            {s = path .. "magin.ogg",    t = 0.97},
            {s = ratel, t = 1.1},
            {s = common .. "rifle_magdrop.ogg", t = 1.15},
            {s = rottle,  t = 1.15},
            {s = path .. "chback.ogg",    t = 1.9},
            {s = path .. "chamber.ogg",    t = 2.0},
            {s = common .. "grab.ogg", t = 2.4},
            {s = common .. "shoulder.ogg", t = 2.5},
        },
    },
    ["reload_308"] = {
        Source = "reload_308",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.9,
        LHIKEaseOut = 0.25,
        MinProgress = 1.3,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = common .. "magpouch.ogg", t = 0.1},
            {s = ratel, t = 0.25},
            {s = path .. "magout.ogg", 	 t = 0.45},
            {s = ratel, t = 0.5},
            {s = rottle,  t = 0.75},
            {s = path .. "magin_308.ogg",    t = 0.95},
            {s = ratel, t = 1.1},
            {s = rottle,  t = 1.15},
            {s = path .. "scrape.ogg",    t = 1.35},
            {s = common .. "magpouchin.ogg", t = 1.35},
            {s = common .. "shoulder.ogg", t = 2.05},
            {s = common .. "grab.ogg", t = 2.1},
        },
    },
    ["reload_empty_308"] = {
        Source = "reload_308_empty",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.55,
        LHIKEaseOut = 0.25,
        MinProgress = 2.1,
        LastClip1OutTime = 2,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = common .. "magpouch.ogg", t = 0.1},
            {s = ratel, t = 0.25},
            {s = path .. "magout.ogg", 	 t = 0.45},
            {s = path .. "bonk.ogg", 	 t = 0.5},
            {s = ratel, t = 0.5},
            {s = rottle,  t = 0.75},
            {s = path .. "magin_308.ogg",    t = 1.0},
            {s = ratel, t = 1.1},
            {s = common .. "rifle_magdrop.ogg", t = 1.15},
            {s = rottle,  t = 1.15},
            {s = path .. "chback_308.ogg",    t = 1.85},
            {s = path .. "chamber_308.ogg",    t = 2.0},
            {s = common .. "grab.ogg", t = 2.4},
            {s = common .. "shoulder.ogg", t = 2.5},
        },
    },
    ["reload_12g"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.65,
        LHIKEaseOut = 0.25,
        MinProgress = 1.3,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = common .. "magpouch.ogg", t = 0.1},
            {s = ratel, t = 0.25},
            {s = path .. "12ga/magout.ogg", 	 t = 0.45},
            {s = ratel, t = 0.5},
            {s = rottle,  t = 0.75},
            {s = path .. "12ga/magin.ogg",    t = 0.95},
            {s = ratel, t = 1.1},
            {s = rottle,  t = 1.15},
            {s = path .. "scrape.ogg",    t = 1.35},
            {s = common .. "magpouchin.ogg", t = 1.35},
            {s = common .. "shoulder.ogg", t = 2.05},
            {s = common .. "grab.ogg", t = 2.1},
        },
    },
    ["reload_empty_12g"] = {
        Source = "reload_empty",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.5,
        LHIKEaseOut = 0.25,
        MinProgress = 2.1,
        LastClip1OutTime = 2,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = common .. "magpouch.ogg", t = 0.1},
            {s = ratel, t = 0.25},
            {s = path .. "12ga/magout.ogg", 	 t = 0.45},
            {s = path .. "bonk.ogg", 	 t = 0.5, v = 0.25},
            {s = ratel, t = 0.55},
            {s = rottle,  t = 0.75},
            {s = path .. "12ga/magin.ogg",    t = 0.97},
            {s = ratel, t = 1.1},
            {s = common .. "rifle_magdrop.ogg", t = 1.15},
            {s = rottle,  t = 1.75},
            {s = path .. "12ga/chback.ogg",    t = 1.85},
            {s = path .. "12ga/chamber.ogg",    t = 2.0},
            {s = common .. "grab.ogg", t = 2.4},
            {s = common .. "shoulder.ogg", t = 2.5},
        },
    },
    ["enter_inspect"] = {
        Source = "inspect_enter",
        -- time = 35 / 60,
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 2.5,
        SoundTable = {
            {s = rottle, t = 0},
            {s = common .. "movement-rifle-02.ogg", t = 0.1},
        },
    },
    ["idle_inspect"] = {
        Source = "inspect_loop",
        -- time = 72 / 60,
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 999, -- maybe im dumb
    },
    ["exit_inspect"] = {
        Source = "inspect_exit",
        -- time = 66 / 60,
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 999, -- maybe im dumb
        SoundTable = {
            {s = common .. "movement-rifle-04.ogg", t = 0.2},
            {s = rottle, t = 0.25},
            {s = rottle, t = 1.2},
            {s = common .. "movement-rifle-03.ogg", t = 1.25},
        },
    },
    ["enter_sprint"] = {
        Source = "sprint_start",
        Time = 0.9,
    },
    ["idle_sprint"] = {
        Source = "sprint_idle",
    },
    ["exit_sprint"] = {
        Source = "sprint_end",
        Time = 1.25,
    },
    ["unjam"] = {
        Source = "jamfix",
        -- Time = 45 / 30,
        ShellEjectAt = 0.65,
        -- LHIK = true,
        -- LHIKIn = 0.3,
        -- LHIKEaseIn = 0.4,
        -- LHIKEaseOut = 0.15,
        -- LHIKOut = 0.4,
        -- SoundTable = {                                             zenith do noises here
        --     {s = path .. "chback.ogg",   t = 0.15},
        --     {s = common .. "cloth_4.ogg",  t = 0.5},
        --     {s = path .. "chamber.ogg",  t = 0.5},
        -- },
        SoundTable = {
            {s = common .. "cloth_4.ogg",  t = 0.1},
            {s = path .. "presscheck_1.ogg",    t = 0.2},
            {s = path .. "chback.ogg",    t = 0.6},
            {s = path .. "chamber.ogg",    t = 0.7},
            {s = common .. "grab.ogg", t = 1.1},
            {s = common .. "shoulder.ogg", t = 1.15},
        }
    },
    ["bash_bayonet"] = {
        Source = "bayonet",
        --Time = 1.2,
        --MinProgress = .7,
        SoundTable = {
            {s = "weapons/arccw/melee_lift.wav", t = 0}
        }
    },

    ["exit_bipod"] = {
        Source = "bipod_undeploy",
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.55,
        LHIKEaseOut = 0.25,
        --Time = 1.2,
        --MinProgress = .7,
        Mult = .8,
        SoundTable = {
            -- {s = "weapons/arccw/melee_lift.wav", t = 0}
        }
    },
    ["enter_bipod"] = {
        Source = "bipod_deploy",
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.55,
        LHIKEaseOut = 0.25,
        --Time = 1.2,
        --MinProgress = .7,
        Mult = .8,
        SoundTable = {
            -- {s = "weapons/arccw/melee_lift.wav", t = 0}                   -- yeah here too
        }
    },
}

SWEP.Hook_Think = ArcCW.UC.ADSReload
--lua/weapons/arccw_ur_ak.lua:
SWEP.Base = "arccw_base"
SWEP.Spawnable = true -- this obviously has to be set to true
SWEP.Category = "ArcCW - Urban Coalition" -- edit this if you like
SWEP.UC_CategoryPack = "2Urban Renewal"
SWEP.AdminOnly = false

SWEP.PrintName = "KF-67"
SWEP.TrueName = "AKM"

if GetConVar("arccw_truenames"):GetBool() then
    SWEP.PrintName = SWEP.TrueName
end

local descStart = "One of the first assault rifles, wielded around the world to this day for its cheap price, quick production, ease of maintenance, and infallible reliability. Consequently, it has become the most popular rifle ever; a constant of freedom fighters and third-world dictators virtually everywhere. One fifth of all small arms in existence can be traced to this design.\n\n"
local desc_762 = "The default pattern is well-rounded and hard-hitting, but kicks harder than other weapons of its class."
local desc_545 = "With a heavier frame than other service rifles, the AK-74 platform is accurate and easy to control."
local desc_74u = "This PDW variant sacrifices range and control to fit the power of a rifle into a very compact form."
local desc_9mm = "Well-rounded submachine gun that shares common parts with AK rifles. For its widespread use by a variety of security divisions, it can be described as a Russian counterpart to the MP5.\n\nThe moniker \"Vityaz\" translates to \"knight.\""
local desc_12g = "Magazine-fed semi automatic shotgun based on the Kalashnikov pattern. It is a popular civilian weapon due to the comparative simplicity of Russia's smoothbore gun licenses, but it has also been used by security firms around the world.\n\nIts low accuracy is compensated for by a much faster reload time than tube-fed designs."
local desc_556 = "This international variant has a lower damage output than the Russian cartridges, but boasts substantially lower recoil."
local desc_366 = "AK-pattern shotgun chambered in .366 TKM, a sporting cartridge that uses reshaped M43 casings. It is considered a shotgun because of its smoothbore barrel, a change made to circumvent Russian rifle laws. Despite the lack of rifling, it achieves similar ballistics to a proper AK-47."

SWEP.Trivia_Class = "Assault Rifle"
SWEP.Trivia_Desc = descStart .. desc_762
SWEP.Trivia_Manufacturer = "Izhmash"
SWEP.Trivia_Calibre = "7.62x39mm Soviet"
SWEP.Trivia_Mechanism = "Gas-Operated Rotating Bolt"
SWEP.Trivia_Country = "Soviet Union"
SWEP.Trivia_Year = 1959

SWEP.Slot = 2
SWEP.CamAttachment = 3

SWEP.UseHands = true

SWEP.ViewModel = "models/weapons/arccw/c_ur_ak.mdl"
SWEP.WorldModel = "models/weapons/arccw/c_ur_ak.mdl"
SWEP.ViewModelFOV = 70

SWEP.DefaultBodygroups = "010000800120"

-- Damage --

SWEP.Damage = 50 -- 2 shot close range kill
SWEP.DamageMin = 25 -- 4 shot long range kill
SWEP.RangeMin = 30
SWEP.Range = 300 -- 3 shot until ~170m
SWEP.Penetration = 16
SWEP.DamageType = DMG_BULLET
SWEP.ShootEntity = nil
SWEP.MuzzleVelocity = 715
SWEP.PhysBulletMuzzleVelocity = 715

SWEP.BodyDamageMults = ArcCW.UC.BodyDamageMults

-- Mag size --

SWEP.ChamberSize = 1
SWEP.Primary.ClipSize = 30
SWEP.ExtendedClipSize = 40
SWEP.ReducedClipSize = 15

-- Recoil --

SWEP.Recoil = 0.75
SWEP.RecoilSide = 0.3

SWEP.RecoilRise = 0.6
SWEP.RecoilPunch = 1
SWEP.VisualRecoilMult = 1
SWEP.MaxRecoilBlowback = 1
SWEP.MaxRecoilPunch = 1
SWEP.RecoilPunchBack = 2

SWEP.Sway = 0.6

-- Firerate / Firemodes --

SWEP.Delay = 60 / 600
SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 2,
    },
    {
        Mode = 1,
    },
    {
        Mode = 0,
    },
}

SWEP.ShootPitch = 100
SWEP.ShootVol = 120

SWEP.ProceduralRegularFire = false
SWEP.ProceduralIronFire = false

SWEP.ReloadInSights = true

-- NPC --

SWEP.NPCWeaponType = "weapon_ar2"
SWEP.NPCWeight = 60

-- Accuracy --

SWEP.AccuracyMOA = 5
SWEP.HipDispersion = 800
SWEP.MoveDispersion = 250
SWEP.JumpDispersion = 1000

SWEP.Primary.Ammo = "ar2"
SWEP.MagID = "ak"

SWEP.HeatCapacity = 75
SWEP.HeatDissipation = 15
SWEP.HeatDelayTime = 3

-- SWEP.Malfunction = true
SWEP.MalfunctionMean = 200
--SWEP.MeleeTime = 1.5

-- Speed multipliers --

SWEP.SpeedMult = 0.9
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.75

local path = ")weapons/arccw_ur/ak/"
local path1 = ")weapons/arccw_ur/mp5/"
local common = ")/arccw_uc/common/"
local rottle = {common .. "cloth_1.ogg", common .. "cloth_2.ogg", common .. "cloth_3.ogg", common .. "cloth_4.ogg", common .. "cloth_6.ogg", common .. "rattle.ogg"}
local ratel = {common .. "rattle1.ogg", common .. "rattle2.ogg", common .. "rattle3.ogg"}
local rutle = {common .. "movement-rifle-01.ogg",common .. "movement-rifle-02.ogg",common .. "movement-rifle-03.ogg",common .. "movement-rifle-04.ogg"}
--SWEP.FirstShootSound = path .. "fire_first.ogg"

SWEP.ShootSound = {
    path .. "fire-01.ogg",
    path .. "fire-02.ogg",
    path .. "fire-03.ogg",
    path .. "fire-04.ogg",
    path .. "fire-05.ogg",
    path .. "fire-06.ogg"
}
SWEP.ShootSoundSilenced = {
    path .. "fire-sup-01.ogg",
    path .. "fire-sup-02.ogg",
    path .. "fire-sup-03.ogg",
    path .. "fire-sup-04.ogg",
    path .. "fire-sup-05.ogg",
    path .. "fire-sup-06.ogg"
}
SWEP.DistantShootSound = nil
SWEP.DistantShootSoundSilenced = nil
SWEP.ShootDrySound = path .. "dryfire.ogg"

local tail = ")/arccw_uc/common/762x39/"

SWEP.DistantShootSoundOutdoors = {
    tail .. "fire-dist-762x39-rif-ext-01.ogg",
    tail .. "fire-dist-762x39-rif-ext-02.ogg",
    tail .. "fire-dist-762x39-rif-ext-03.ogg",
    tail .. "fire-dist-762x39-rif-ext-04.ogg",
    tail .. "fire-dist-762x39-rif-ext-05.ogg",
    tail .. "fire-dist-762x39-rif-ext-06.ogg"
}
SWEP.DistantShootSoundIndoors = {
    common .. "fire-dist-int-rifle-01.ogg",
    common .. "fire-dist-int-rifle-02.ogg",
    common .. "fire-dist-int-rifle-03.ogg",
    common .. "fire-dist-int-rifle-04.ogg",
    common .. "fire-dist-int-rifle-05.ogg",
    common .. "fire-dist-int-rifle-06.ogg"
}
SWEP.DistantShootSoundOutdoorsSilenced = {
    common .. "sup-tail-01.ogg",
    common .. "sup-tail-02.ogg",
    common .. "sup-tail-03.ogg",
    common .. "sup-tail-04.ogg",
    common .. "sup-tail-05.ogg",
    common .. "sup-tail-06.ogg",
    common .. "sup-tail-07.ogg",
    common .. "sup-tail-08.ogg",
    common .. "sup-tail-09.ogg",
    common .. "sup-tail-10.ogg"
}
SWEP.DistantShootSoundIndoorsSilenced = {
    common .. "fire-dist-int-pistol-light-01.ogg",
    common .. "fire-dist-int-pistol-light-02.ogg",
    common .. "fire-dist-int-pistol-light-03.ogg",
    common .. "fire-dist-int-pistol-light-04.ogg",
    common .. "fire-dist-int-pistol-light-05.ogg",
    common .. "fire-dist-int-pistol-light-06.ogg"
}
SWEP.DistantShootSoundOutdoorsVolume = 1
SWEP.DistantShootSoundIndoorsVolume = 1
SWEP.Hook_AddShootSound = ArcCW.UC.InnyOuty

SWEP.MuzzleEffect = "muzzleflash_6"
SWEP.ShellEffect = "arccw_uc_shelleffect"
SWEP.ShellModel = "models/weapons/arccw/uc_shells/762x39.mdl"
SWEP.ShellPitch = 90
SWEP.ShellScale = .666
SWEP.ShellRotateAngle = Angle(0, 0, 0)
SWEP.UC_ShellColor = Color(0.7 * 255, 0.2 * 255, 0.2 * 255)

SWEP.MuzzleEffectAttachment = 1 -- which attachment to put the muzzle on
SWEP.CaseEffectAttachment = 2 -- which attachment to put the case effect on

SWEP.BulletBones = {
    [1] = "tag_mag2",
}

SWEP.IronSightStruct = {
    Pos = Vector(-2.61, -2, 0.45),
    Ang = Angle(0.60, 0.274, 5.53),
    Magnification = 1.1,
    SwitchToSound = "", -- sound that plays when switching to this sight
    CrosshairInSights = false
}
SWEP.LaserOffsetAngle = Angle(0, 0, 0)
SWEP.LaserIronsAngle = Angle(0, 0, 0)

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0.5, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, 0, 0)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.CrouchPos = Vector(-2, -2, -0.6)
SWEP.CrouchAng = Angle(0, 0, -14)

SWEP.HolsterPos = Vector(-1, -1, 1.2)
SWEP.HolsterAng = Angle(-15, 8, -10)

SWEP.BarrelOffsetSighted = Vector(0, 0, 0)
SWEP.BarrelOffsetHip = Vector(0, 0, 0)

-- SWEP.CustomizePos = Vector(6.5, 0.8, -0.2)
-- SWEP.CustomizeAng = Angle(8, 22, 15)

SWEP.CustomizePos = Vector(0, 0, 0)
SWEP.CustomizeAng = Angle(0, 0, 0)

SWEP.BarrelLength = 24

SWEP.AttachmentElements = {
    ["barrel_74m"] = {
        VMBodygroups = {{ind = 1, bg = 3}}
    },
    ["barrel_74m_red"] = {
        VMBodygroups = {{ind = 1, bg = 10}}
    },
    ["barrel_74m_green"] = {
        VMBodygroups = {{ind = 1, bg = 11}}
    },
    ["barrel_akm"] = {
        VMBodygroups = {{ind = 1, bg = 0}}
    },
    ["barrel_alpha"] = {
        VMBodygroups = {
            {ind = 1, bg = 7},
            -- {ind = 7, bg = 6},
            -- {ind = 8, bg = 2},
        },
    },
    ["barrel_rpk"] = {
        VMBodygroups = {
            {ind = 7, bg = 1},
            {ind = 8, bg = 2}
        },
        AttPosMods = {[4] = {
            vpos = Vector(0, 32.2, 2.6),
            vang = Angle(0, 270, 0),
        }},
    Override_IronSightStruct = {
            Pos = Vector(-2.625, -2, 0.68),
            Ang = Angle(-0.1, 0.274, 5.53),
            Magnification = 1,
    }
    },
    ["barrel_rpk74m"] = {
        VMBodygroups = {
            {ind = 1, bg = 5},
            -- {ind = 7, bg = 1},
            -- {ind = 8, bg = 2}
        },
        -- AttPosMods = {[4] = {
        --     vpos = Vector(0, 32.2, 2.6),
        --     vang = Angle(0, 270, 0),
        -- }},
        -- Override_IronSightStruct = {
        -- 	Pos = Vector(-2.625, -2, 0.68),
        -- 	Ang = Angle(-0.1, 0.274, 5.53),
        -- 	Magnification = 1,
        -- }
    },
    ["barrel_krinkov"] = {
        VMBodygroups = {
            {ind = 1, bg = 6},
            {ind = 7, bg = 5},
            {ind = 8, bg = 2},
            {ind = 4, bg = 1},
            {ind = 5, bg = 1}
        },
        AttPosMods = {
            [4] = {
                vpos = Vector(0, 15, 2.85),
                vang = Angle(0, 270, 0),
            },
            [7] = {
                vpos = Vector(0,10,1.7),
                vang = Angle(90, -90, -90),
                SlideAmount = {
                    vmin = Vector(0,10,1.7),
                    vmax = Vector(0,10,1.7)
                },
            },
            [8] = {
                vpos = Vector(-0.8, 11.75, 2.9),
                vang = Angle(-90, 270, 0),
                wang = Angle(-90, 270, 0),
            }
        },
        Override_IronSightStruct = {
            Pos = Vector(-2.638, -2, 0.9),
            Ang = Angle(-1, 0.12, 5.53),
            Magnification = 1,
        }
    },
    ["barrel_vityaz"] = {
        VMBodygroups = {
            {ind = 1, bg = 8},
            {ind = 7, bg = 5},
            {ind = 8, bg = 2},
            {ind = 5, bg = 1}
        },
        AttPosMods = {
            [4] = {
                vpos = Vector(0, 16.5, 2.85),
                vang = Angle(0, 270, 0),
            },
            [7] = {
                vpos = Vector(0,11,1.7),
                vang = Angle(90, -90, -90),
                SlideAmount = {
                    vmin = Vector(0,10,1.7),
                    vmax = Vector(0,11,1.7)
                },
            },
            [8] = {
                vpos = Vector(-0.8, 11.75, 2.9),
                vang = Angle(-90, 270, 0),
                wang = Angle(-90, 270, 0),
            }
        },
        Override_IronSightStruct = {
            Pos = Vector(-2.62, -2, 0.75),
            Ang = Angle(-0.42, 0.2, 5.53),
            Magnification = 1,
        }
    },
    ["barrel_t56"] = {
        VMBodygroups = {
            {ind = 7, bg = 3},
            {ind = 11, bg = 2},
            {ind = 8, bg = 2}
        },
    },
    ["barrel_t56_ext"] = {
        VMBodygroups = {
            {ind = 7, bg = 3},
            {ind = 11, bg = 3},
            {ind = 8, bg = 2}
        },
    },
    ["barrel_vepr"] = {
        VMBodygroups = {
            --{ind = 1, bg = 9},
            {ind = 7, bg = 4},
            {ind = 8, bg = 2}
        },
        AttPosMods = {[4] = {
            vpos = Vector(0, 28.5, 2.7),
            vang = Angle(0, 270, -0),
        }},
        Override_IronSightStruct = {
            Pos = Vector(-2.63, -2, 0.76),
            Ang = Angle(-0.3, 0.18, 5.53),
            Magnification = 1,
        }
    },

    ["ur_ak_hg_vepr"] = {
        VMBodygroups = {
            {ind = 1, bg = 9},
        },
    },

    ["barrel_105"] = {
        VMBodygroups = {
            --{ind = 1, bg = 3},
            {ind = 7, bg = 2},
            {ind = 8, bg = 2}
        },
        AttPosMods = {[4] = {
            vpos = Vector(0, 19.9, 2.7),
            vang = Angle(0, 270, 0),
        }},
        Override_IronSightStruct = {
            Pos = Vector(-2.6, -2, 0.48),
            Ang = Angle(0.6, 0.265, 5.53),
            Magnification = 1,
        }
    },
    ["barrel_dong"] = {
        VMBodygroups = {{ind = 1, bg = 2}}, -- This will show up regardless of barrel selection because underbarrel atts are always processed after barrel atts
        AttPosMods = {[6] = {
            SlideAmount = {
                vmin = Vector(0,12,1.9),
                vmax = Vector(0,12,1.9)
            },
        }}
    },

    ["muzzle_akm"] = {
        VMBodygroups = {{ind = 8, bg = 1}}
    },
    ["muzzle_ak74"] = {
        VMBodygroups = {{ind = 8, bg = 3}}
    },
    ["muzzle_aku"] = {
        VMBodygroups = {{ind = 8, bg = 6}}
    },
    ["muzzle_bayonet"] = {
        VMBodygroups = {{ind = 11, bg = 1}}
    },

    ["stock_alpha"] = {
        VMBodygroups = {
            {ind = 6, bg = 4},
            {ind = 3, bg = 1},
        }

    },
    ["stock_aks"] = {
        VMBodygroups = {
            {ind = 6, bg = 3},
            {ind = 3, bg = 1},
    }
    },
    ["stock_aks_folded"] = {
        VMBodygroups = {
            {ind = 6, bg = 10},
            {ind = 3, bg = 1},
        }

    },
    ["stock_underfolder"] = {
        VMBodygroups = {{ind = 6, bg = 2}}
    },
    ["stock_underfolder_folded"] = {
        VMBodygroups = {{ind = 6, bg = 1}}
    },
    ["stock_ak74m"] = {
        VMBodygroups = {
            {ind = 3, bg = 1},
            {ind = 6, bg = 12}
        }
    },
    ["stock_ak74m_folded"] = {
        VMBodygroups = {
            {ind = 3, bg = 1},
            {ind = 6, bg = 13}
        }
    },
    ["stock_rpk"] = {
        VMBodygroups = {{ind = 6, bg = 5}}
    },
    ["stock_akn"] = {
        VMBodygroups = {{ind = 6, bg = 0}}
    },
    ["stock_skeletal"] = {
        VMBodygroups = {
            {ind = 6, bg = 6},
            {ind = 3, bg = 1},
        }
    },
    ["stock_vepr"] = {
        VMBodygroups = {
            {ind = 6, bg = 7},
            {ind = 9, bg = 4}
        }
    },
    ["stock_none"] = {
        VMBodygroups = {
            {ind = 6, bg = 9},
            {ind = 3, bg = 1},
        }
    },

    ["mag_762_75"] = {
        VMBodygroups = {{ind = 2, bg = 1}}
    },
    ["mag_762_bakelite"] = {
        VMBodygroups = {{ind = 2, bg = 11}}
    },
    ["mag_762_pmag"] = {
        VMBodygroups = {{ind = 2, bg = 12}}
    },
    ["mag_545_30"] = {
        VMBodygroups = {{ind = 2, bg = 2}}
    },
    ["mag_556_30"] = {
        VMBodygroups = {{ind = 2, bg = 10}}
    },
    ["mag_545_45"] = {
        VMBodygroups = {{ind = 2, bg = 3}}
    },
    ["mag_9mm"] = {
        VMBodygroups = {{ind = 2, bg = 4}}
    },
    ["mag_12g"] = {
        VMBodygroups = {{ind = 2, bg = 5}}
    },
    ["mag_366"] = {
        VMBodygroups = {{ind = 2, bg = 6}}
    },

    ["grip_akm"] = {
        VMBodygroups = {{ind = 9, bg = 0}}
    },
    ["grip_alpha"] = {
        VMBodygroups = {{ind = 9, bg = 2}}
    },
    ["grip_saiga"] = {
        VMBodygroups = {{ind = 9, bg = 3}}
    },

    ["cover_ribbed"] = {
        VMBodygroups = {{ind = 10, bg = 0}}
    },
    ["cover_alpha"] = {
        VMBodygroups = {{ind = 10, bg = 1}},
        AttPosMods = {[1] = {
            vpos = Vector(0, 3.5, 4.68),
            vang = Angle(0, -90, 0),
        }}
    },
    ["optic_raillaser"] = {
        AttPosMods = {
            [8] = {
                vpos = Vector(0.95, 2.5, 4.05),
                vang = Angle(0, -90, 125),
            },
        },
    },
    ["cover_ak12"] = {
        VMBodygroups = {{ind = 10, bg = 4}},
        AttPosMods = {[1] = {
            vpos = Vector(0, 3.5, 4.67),
            vang = Angle(0, -90, 0),
        }}
    },

    ["grip_ak12"] = {
        VMBodygroups = {{ind = 9, bg = 5}}
    },
    ["stock_ak12"] = {
        VMBodygroups = {{ind = 6, bg = 11}},
    },
    ["handguard_ak12"] = {
        VMBodygroups = {{ind = 1, bg = 12}},
        --[[AttPosMods = {[6] = {
            vpos = Vector(0, 11.75, 2.2),
            vang = Angle(90, -90, -90),
        }}]]
        AttPosMods = {
            [8] = {
                vpos = Vector(-0.7, 13.5, 3.8),
                vang = Angle(-90, 270, 0),
                wang = Angle(-90, 270, 0),
            },
            [7] = {
                vpos = Vector(0, 11.75, 2.2),
                vang = Angle(90, -90, -90),
            }
        },
    },
    ["barrel_ak12"] = {
        VMBodygroups = {
            {ind = 7, bg = 6},
            {ind = 8, bg = 2}
        },
        AttPosMods = {[4] = {
            vpos = Vector(0, 23.5, 2.8),
            vang = Angle(0, 270, 0),
        }},
        Override_IronSightStruct = {
            Pos = Vector(-2.68, 0, 1.3),
            Ang = Angle(-2.02, 0.028, 5.53),
            Magnification = 1,
        }
        --RequireFlags = {"cover_rail"},
    },
    ["muzzle_ak12"] = {
        VMBodygroups = {{ind = 8, bg = 2}},
    },
    ["reciever_ak12"] = {
        VMBodygroups = {{ind = 0, bg = 1}}
    },
    ["sight_ak12"] = {
        VMBodygroups = {{ind = 4, bg = 3}},
        RequireFlags = {"cover_rail", "ak_railedguard"},
        Override_IronSightStruct = {
            Pos = Vector(-2.63, 0, 0.79),
            Ang = Angle(-1.12, 0.116, 5.53),
            Magnification = 1,
        },
        Override_IronSightStruct_Priority = 2,
    },
    ["mag_545_ak12"] = {
        VMBodygroups = {{ind = 2, bg = 7}}
    },
    ["mag_545_black"] = {
        VMBodygroups = {{ind = 2, bg = 9}}
    },
    ["mag_308"] = {
        VMBodygroups = {{ind = 2, bg = 8}}
    },

    ["cover_trail"] = {
        VMBodygroups = {{ind = 4, bg = 4}},
        AttPosMods = {[1] = {
            vpos = Vector(0, 8.2, 5.20),
            vang = Angle(0, -90, 0),
        }}
    },
}

SWEP.Hook_ModifyBodygroups = function(wep, data)
    local akOptics = {["uc_optic_pso1"] = true, ["uc_optic_kobra"] = true} -- Will need to update this list if more AK optics get added
    local railHgs = {["default"] = true, ["type3"] = true}
    local bipodBarrs = {["rpk"] = true}
    local shortBarrs = {["krinkov"] = true, ["vityaz"] = true}
    local intCals = {["545"] = true, ["556"] = true, ["545_ak12"] = true}

    local optic = wep.Attachments[1].Installed
    local barr = string.Replace(wep.Attachments[2].Installed or "default","ur_ak_barrel_","")
    local hg = string.Replace(wep.Attachments[3].Installed or "default","ur_ak_hg_","")
    local muzz = wep.Attachments[4].Installed
    local cal = string.Replace(wep.Attachments[5].Installed or "default","ur_ak_cal_","")
    local ub = wep.Attachments[7].Installed-- or wep.Attachments[17].Installed
    local upper = wep.Attachments[15].Installed
    local alpha = (upper == "ur_ak_cover_alpha" or upper == "ur_ak_cover_ak12" or upper == "ur_ak_cover_truniun_rail")
    local taclaser = (wep.Attachments[16].Installed == "ur_ak_charm_tl")

    local vm = data.vm
    if !IsValid(vm) then return end

    -- Default muzzle devices
    if !muzz or muzz == "ur_ak_muzzle_bayonet" then
        if barr == "ak12" and (cal == "default" or intCals[cal]) then
            vm:SetBodygroup(8,3)
        elseif barr == "krinkov" then
            vm:SetBodygroup(8,4)
        elseif barr == "default" or barr == "t56" then
            if cal == "default" then
                vm:SetBodygroup(8,1)
            elseif intCals[cal] then
                vm:SetBodygroup(8,3)
            else
                vm:SetBodygroup(8,0)
            end
        end
    elseif barr == "default" then
        vm:SetBodygroup(8,0)
    else
        vm:SetBodygroup(8,2)
    end

    --
    if taclaser and !akOptics[optic] then
        vm:SetBodygroup(12,2)
    else
        if optic and !alpha and !akOptics[optic] then
            vm:SetBodygroup(12,1)
        else
            vm:SetBodygroup(12,0)
        end
    end

    -- Railed underbarrel
    if ub and hg != "ur_ak_hg_dong" and barr != "vityaz" then
        if barr == "krinkov" then
            vm:SetBodygroup(13,2)
        elseif railHgs[hg] then
            vm:SetBodygroup(1,13)
        else
            vm:SetBodygroup(13,1)
        end
    else
        vm:SetBodygroup(13,0)
    end

    -- RPK bipod
    if bipodBarrs[barr] then
        vm:SetBodygroup(7, (wep:GetInBipod() and (wep.LastAnimKey ~= "enter_bipod" or wep.LastAnimFinishTime < CurTime())) and 7 or 1)
    end
end

SWEP.ExtraSightDist = 2
SWEP.GuaranteeLaser = false

SWEP.WorldModelOffset = {
    pos = Vector(-7, 4, -4),
    ang = Angle(-12, 0, 180)
}

SWEP.MirrorVMWM = true

SWEP.Attachments = {
    {
        PrintName = "Optic",
        DefaultAttName = "Iron Sights",
        Slot = {"optic","optic_sniper","ur_ak_optic"},
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(0, 2, 4.92),
            vang = Angle(0, -90, 0),
        },
        CorrectivePos = Vector(0, 0, -0.0),
        CorrectiveAng = Angle(-1.9, 180.15, 0),
        VMScale = Vector(1, 1, 1),
        -- SlideAmount = {
        --     vmin = Vector(0, 2-1, 4.55),
        --     vmax = Vector(0, 2+0.5, 4.55),
        -- },
--        RequireFlags = {"cover_rail"},
--        HideIfBlocked = true,
        -- InstalledEles = {"optic_rail"},
    },
    {
        PrintName = "Barrel",
        DefaultAttName = "16\" Standard Barrel",
        DefaultAttIcon = Material("entities/att/ur_ak/barrel/std.png", "mips smooth"),
        Slot = "ur_ak_barrel",
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(0,12, 1.9),
            vang = Angle(90, -90, -90),
        },
    },
    {
        PrintName = "Handguard",
        DefaultAttName = "Factory Handguard",
        DefaultAttIcon = Material("entities/att/ur_ak/handguards/std.png", "mips smooth"),
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(0,12, 1.9),
            vang = Angle(90, -90, -90),
        },
        Slot = "ur_ak_hg",
        ExcludeFlags = {"barrel_carbine"},
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Standard Muzzle",
        Slot = {"muzzle","ur_ak_muzzle"},
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(0, 24.1, 2.7),
            vang = Angle(0, 270, 0),
        },
        ExcludeFlags = {"ur_ak_nomuzzle"},
        --Installed = "ur_ak_muzzle_akm"
    },
    {
        PrintName = "Receiver",
        DefaultAttName = "7.62x39mm Reciever",
        DefaultAttIcon = Material("entities/att/uc_bullets/762x39.png", "mips smooth"),
        Slot = {"ur_ak_cal"},
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(2.8, -4.2, -11.5),
            vang = Angle(90, 0, -90),
        },
        DefaultFlags = {"cal_default"}
    },
    {
        PrintName = "Magazine",
        Slot = {"ur_ak_mag"},
        DefaultAttName = "30-Round Mag",
        DefaultAttIcon = Material("entities/att/ur_ak/magazines/762_30.png", "mips smooth"),
    },
    {
        PrintName = "Underbarrel",
        Slot = {"foregrip","ur_ak_ub"},
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(0,12, 1.9),
            vang = Angle(90, -90, -90),
        },
        VMScale = Vector(1, 1, 1),
        SlideAmount = {
            vmin = Vector(0,10.5,1.9),
            vmax = Vector(0,13.5,1.9)
        },
        InstalledEles = {"rail_fg"},
        ExcludeFlags = {"ak_noubs"},
        MergeSlots = {17},
    },
    {
        PrintName = "Tactical",
        Slot = {"tac"},
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(0, 19.6, 2.1),
            vang = Angle(0, 270, 0),
        },
        GivesFlags = {"tac"},
        --InstalledEles = {"ud_m16_clamp_fullsize"}
    },
    {
        PrintName = "Grip Type",
        Slot = {"ur_ak_grip"},
        DefaultAttName = "Factory Grip",
        DefaultAttIcon = Material("entities/att/ur_ak/grip_modern.png", "mips smooth"),
        ExcludeFlags = {"stock_vepr"},
    },
    {
        PrintName = "Stock",
        Slot = {"ur_ak_stock"},
        DefaultAttName = "Factory Stock",
        DefaultAttIcon = Material("entities/att/ur_ak/stock/n.png", "mips smooth"),
    },
    {
        PrintName = "Ammo Type",
        DefaultAttName = "\"FMJ\" Full Metal Jacket",
        DefaultAttIcon = Material("entities/att/arccw_uc_ammo_generic.png", "mips smooth"),
        Slot = "uc_ammo",
    },
    {
        PrintName = "Powder Load",
        Slot = "uc_powder",
        DefaultAttName = "Standard Load"
    },
    {
        PrintName = "Training Package",
        Slot = "uc_tp",
        DefaultAttName = "Basic Training"
    },
    {
        PrintName = "Internals",
        Slot = "uc_fg", -- Fire group
        DefaultAttName = "Standard Internals"
    },
    {
        PrintName = "Dust Cover",
        DefaultAttName = "Ribbed Dust Cover",
        DefaultAttIcon = Material("entities/att/ur_ak/dustcover_stock.png", "mips smooth"),
        Slot = {"ur_ak_cover"},
        FreeSlot = true,
    },
    {
        PrintName = "Charm",
        Slot = {"charm", "fml_charm", "ur_ak_charm"},
        FreeSlot = true,
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(0.6, 6.7, 2.2),
            vang = Angle(90, -90, -90),
        },
    },
    {
        PrintName = "M203 slot",
        Slot = "uc_ubgl",
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(0, 9.9, 2.9),
            vang = Angle(90, -90, -90),
        },
        InstalledEles = {"rail_fg"},
        ExcludeFlags = {"ak_noubs","barrel_rpk"},
        Hidden = true,
    }
}

function SWEP:Hook_TranslateAnimation(anim)
    if anim == "fire_iron" then
        if self:GetBuff_Override("NoStock") then return "fire" end
    elseif anim == "fire_iron_empty" then
        if self:GetBuff_Override("NoStock") then return "fire_empty" end
    end
end

SWEP.Hook_NameChange = function(wep,name)
    local foldStocks = {["underfolder"] = true,["aks"] = true}
    local akCals = {["762"] = true,["545"] = true}
    local shortBarrs = {["krinkov"] = true,["vityaz"] = true}
    local fakeNames = !GetConVar("arccw_truenames"):GetBool()

    local start = "AK"
    local mid = ""
    local post = "M"
    local noN = false

    if fakeNames then
        start = "KF"
        post = "-67"
    end

    local atts = wep.Attachments
    local barr = string.Replace(atts[2].Installed or "default", "ur_ak_barrel_", "")
    local hg = string.Replace(atts[3].Installed or "default", "ur_ak_hg_", "")
    local cal = string.Replace(atts[5].Installed or "762", "ur_ak_cal_", "")
    local stock = string.Replace(atts[10].Installed or "default", "ur_ak_stock_", "")
    local upper = atts[11].Installed
    local alpha = (upper == "ur_ak_cover_alpha" or upper == "ur_ak_cover_ak12" or upper == "ur_ak_cover_truniun_rail")
    -- local ak12 = alpha and barr == "ak12"

    wep.Trivia_Desc = descStart .. desc_762
    wep.Trivia_Mechanism = "Gas-Operated Rotating Bolt"

    if alpha then noN = true end

    if atts[14].Installed == "uc_fg_civvy" then
        start = (fakeNames and "Amur") or "Vepr"
        if cal == "12g" then
            post = "-12"
            wep.Trivia_Desc = desc_12g
        elseif cal == "545_ak12" or cal == "545" then
            post = " 5.45"
            wep.Trivia_Desc = descStart .. desc_545
        elseif cal == "762" then
            post = " 7.62"
        elseif cal == "9mm" then
            start = "Saiga"
            post = "-9"
            wep.Trivia_Desc = desc_9mm
            wep.Trivia_Mechanism = "Blowback"
        else
            post = " ." .. cal
        end
        return start .. post
    end

    if cal == "9mm" then
        if fakeNames then
            start = "Bogatyr"
            post = " SMG"
        else
            start = "PP"
            post = "-19 Vityaz"
        end
        wep.Trivia_Desc = desc_9mm
        wep.Trivia_Mechanism = "Blowback"
    -- elseif cal == "12g" then
    --     start = "Saiga"
    --     if shortBarrs[barr] then
    --         post = "-12K"
    --     else
    --         post = "-12"
    --     end
    --     wep.Trivia_Desc = desc_12g -- Obsolete
    elseif cal == "366" then
        if barr == "vepr" or string.find(atts[14].Installed or "","rifling") then
            start = (fakeNames and "Amur") or "Vepr"
            post = " .366"
        else
            start = (fakeNames and "KFN") or "VPO"
            post = "-209"
            wep.Trivia_Desc = desc_366
        end
    elseif cal == "308" then
        post = "-308"
    -- elseif cal == "545_ak12" or ak12 then
    --     noN = true
    --     if string.StartWith(cal,"545") then
    --         post = "-12"
    --         wep.Trivia_Desc = descStart .. desc_545
    --     elseif cal == "762" then
    --         post = "-15"
    --     elseif cal == "556" then
    --         post = "-18"
    --     end
    --     if string.EndsWith(barr,"105") or shortBarrs[barr] then
    --         post = post .. "K"
    --     end -- Obsolete
    elseif barr == "rpk" or barr == "rpk74m" then
        start = (fakeNames and "PKF") or "RPK"
        if !fakeNames and barr == "rpk" and cal == "762" then
            post = ""
        end
    elseif cal == "762" then
        if barr == "t56" then
            noN = true
            if fakeNames then
                start = "Yucha"
                post = " 7"
            else
                start = "Type "
                post = "56"
            end
        elseif (hg == "74m" or hg == "rpk74m" or hg == "ak12") and stock == "ak74m" then
            noN = true
            post = "-103"
        end
    elseif cal == "556" then
        if fakeNames then
            post = "-45"
        elseif string.EndsWith(barr,"105") then
            post = "-102"
        else
            post = "-101"
        end
        wep.Trivia_Desc = descStart .. desc_556
    end

    if foldStocks[stock] and akCals[cal] and !string.StartWith(barr,"105") then
        if cal == "762" then
            if barr == "t56" then
                post = post .. "-1"
            elseif !fakeNames then
                post = "MS"
            else
                mid = "S"
            end
        else
            mid = "S"
        end
    end

    if cal == "545" then
        wep.Trivia_Desc = descStart .. desc_545
        if (hg == "74m" or hg == "rpk74m" or hg == "ak12") and stock == "ak74m" then
            noN = true
            post = (fakeNames and "-76M") or "-74M"
        elseif shortBarrs[barr] then
            if fakeNames then
                post = "-76"
                mid = mid .. "U"
            else
                post = "-74U"
            end
            wep.Trivia_Desc = descStart .. desc_74u
        else
            post = (fakeNames and "-76") or "-74"
        end
    end

    if akCals[cal] then
        if string.EndsWith(barr,"105") then
            noN = true
            if cal == "545" then
                post = "-105"
            elseif cal == "762" then
                post = "-104"
            elseif cal == "556" then
                post = "-102"
            end
        else
            -- if shortBarrs[barr] then
            --     post = post .. "U" -- I know I said the AK-47U doesn't exist, but we have fucking Glock 44 Autos so I warmed up to it
            --     wep.Trivia_Desc = descStart .. desc_74u
            -- end
            if !noN and atts[1].Installed then
                post = post .. "N"
            end
        end

    end

    return start .. mid .. post
end

SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["draw"] = {
        Source = "draw",
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 0.5,
        SoundTable = {
            {s = ratel, t = 0},
            {s = common .. "raise.ogg", t = 0.2},
            {s = common .. "shoulder.ogg",    t = 0.2},
        },
    },
    ["holster"] = {
        Source = "holster",
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 0.5,
        SoundTable = {
            {s = ratel, t = 0},
           -- {s = common .. "raise.ogg", t = 0.2},
            -- {s = common .. "shoulder.ogg",    t = 0.2},
        },
    },
    ["ready"] = {
        Source = "ready",
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0.6,
        LHIKEaseOut = 0.25,
        SoundTable = {
            {s = ratel, t = 0},
            {s = path .. "chback.ogg",    t = 0.2},
            {s = path .. "chamber.ogg",    t = 0.3},
            {s = common .. "shoulder.ogg",    t = .6},
        },
    },
    ["fire"] = {
        Source = {"fire"},
        Time = 0.5,
        ShellEjectAt = 0,
        SoundTable = {{ s = {path .. "mech-01.ogg", path .. "mech-02.ogg", path .. "mech-03.ogg", path .. "mech-04.ogg", path .. "mech-05.ogg", path .. "mech-06.ogg"}, t = 0, v = 0.25 }},
    },
    ["fire_iron"] = {
        Source = {"fire"},
        Time = 0.5,
        ShellEjectAt = 0,
        SoundTable = {{ s = {path .. "mech-01.ogg", path .. "mech-02.ogg", path .. "mech-03.ogg", path .. "mech-04.ogg", path .. "mech-05.ogg", path .. "mech-06.ogg"}, t = 0 }},
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.65,
        LHIKEaseOut = 0.25,
        MinProgress = 1.3,
        SoundTable = {
            {s = common .. "magpouch.ogg", t = 0.0, v = 0.45},
            {s = path .. "reload_start.ogg", 	 t = 0.025},
            {s = rottle,  t = 0.05},
            {s = ratel, t = 0.25},
            {s = path .. "magrelease.ogg", 	 t = 0.4},
            {s = path .. "magout.ogg", 	 t = 0.45},
            {s = ratel, t = 0.5},
            {s = rottle,  t = 0.75},
            {s = path .. "magin.ogg",    t = 0.95},
            {s = ratel, t = 1.1},
            {s = rottle,  t = 1.15},
            {s = path .. "scrape.ogg",    t = 1.35},
            {s = common .. "magpouchin.ogg", t = 1.38},
            {s = path .. "grab.ogg", t = 1.9, v = 0.45},
            {s = common .. "shoulder.ogg", t = 2.0},
            {s = path .. "shoulder.ogg", t = 2.15},
        },
    },
    ["reload_empty"] = {
        Source = "reload_empty",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.5,
        LHIKEaseOut = 0.25,
        MinProgress = 2.1,
        LastClip1OutTime = 2,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = common .. "magpouch.ogg", t = 0.1},
            {s = ratel, t = 0.25},
            {s = path .. "magrelease.ogg", 	 t = 0.4},
            {s = path .. "magout.ogg", 	 t = 0.45},
            {s = path .. "bonk.ogg", 	 t = 0.5},
            {s = ratel, t = 0.5},
            {s = rottle,  t = 0.75},
            {s = path .. "magin.ogg",    t = 0.97},
            {s = ratel, t = 1.1},
            {s = common .. "rifle_magdrop.ogg", t = 1.15, v = 0.5},
            {s = rottle,  t = 1.16},
            {s = path .. "chback.ogg",    t = 1.9},
            {s = path .. "chamber.ogg",    t = 2.0},
            {s = path .. "grab.ogg", t = 2.3, v = 0.45},
            {s = common .. "shoulder.ogg", t = 2.4},
            {s = path .. "shoulder.ogg", t = 2.5},
        },
    },
    ["reload_75"] = {
        Source = "reload_drum",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.9,
        LHIKEaseOut = 0.25,
        MinProgress = 1.6,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = common .. "magpouch.ogg", t = 0.1},
            {s = ratel, t = 0.25},
            {s = path .. "magrelease.ogg", 	 t = 0.1},
            {s = path .. "magout_drum.ogg", 	 t = 0.25},
            {s = ratel, t = 0.5},
            {s = rottle,  t = 0.75},
            {s = ratel, t = 1.0},
            {s = path .. "magin_drum.ogg",    t = 1.1},
            {s = rottle,  t = 1.75},
            {s = path .. "grab.ogg", t = 2.0, v = 0.45},
            {s = common .. "shoulder.ogg", t = 2.1},
            {s = path .. "shoulder.ogg", t = 2.25},
        },
    },
    ["reload_empty_75"] = {
        Source = "reload_drum_empty",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 1.5,
        LHIKEaseOut = 0.25,
        MinProgress = 2.6,
        LastClip1OutTime = 2,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = common .. "magpouch.ogg", t = 0.1},
            {s = ratel, t = 0.25},
            {s = path .. "magrelease.ogg", 	 t = 0.1},
            {s = path .. "magout_drum.ogg", 	 t = 0.25},
            {s = ratel, t = 0.5},
            {s = rottle,  t = 0.75},
            {s = ratel, t = 1.0},
            {s = path .. "magin_drum.ogg",    t = 1.1},
            {s = path .. "grab.ogg", t = 2.0, v = 0.45},
            {s = rottle,  t = 1.9},
            {s = path .. "chback.ogg",    t = 2.37},
            {s = path .. "chamber.ogg",    t = 2.48},
            {s = common .. "shoulder.ogg", t = 2.78},
            {s = path .. "shoulder.ogg", t = 2.93},
        },
    },
    ["reload_9mm"] = {
        Source = "reload_9mm",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.9,
        LHIKEaseOut = 0.25,
        MinProgress = 1.3,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = common .. "magpouch.ogg", t = 0.1},
            {s = ratel, t = 0.25},
            {s = path1 .. "magout.ogg", 	 t = 0.45},
            {s = ratel, t = 0.5},
            {s = rottle,  t = 0.75},
            {s = path1 .. "magin.ogg",    t = 0.73},
            {s = ratel, t = 1.1},
            {s = rottle,  t = 1.15},
            {s = path .. "scrape.ogg",    t = 1.4},
            {s = common .. "magpouchin.ogg", t = 1.35},
            {s = common .. "shoulder.ogg", t = 2.05},
            {s = common .. "grab.ogg", t = 2.1},
        },
    },
    ["reload_empty_9mm"] = {
        Source = "reload_9mm_empty",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.55,
        LHIKEaseOut = 0.25,
        MinProgress = 2.1,
        LastClip1OutTime = 2,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = common .. "magpouch.ogg", t = 0.1},
            {s = ratel, t = 0.25},
            {s = path1 .. "magout.ogg", 	 t = 0.45},
            {s = ratel, t = 0.5},
            {s = rottle,  t = 0.75},
            {s = path1 .. "magin.ogg",    t = 0.85},
            {s = ratel, t = 1.1},
            {s = common .. "pistol_magdrop.ogg", t = 1.15},
            {s = rottle,  t = 1.15},
            {s = path .. "chback_9.ogg",    t = 1.8},
            {s = path .. "chamber_9.ogg",    t = 2.05},
            {s = common .. "grab.ogg", t = 2.4},
            {s = common .. "shoulder.ogg", t = 2.5},
        },
    },
    ["reload_10rnd"] = {
        Source = "reload_10rnd",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.9,
        LHIKEaseOut = 0.25,
        MinProgress = 1.3,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = common .. "magpouch.ogg", t = 0.1},
            {s = ratel, t = 0.25},
            {s = path .. "magout.ogg", 	 t = 0.45},
            {s = ratel, t = 0.5},
            {s = rottle,  t = 0.75},
            {s = path .. "magin.ogg",    t = 0.95},
            {s = ratel, t = 1.1},
            {s = rottle,  t = 1.15},
            {s = path .. "scrape.ogg",    t = 1.35},
            {s = common .. "magpouchin.ogg", t = 1.35},
            {s = common .. "shoulder.ogg", t = 2.05},
            {s = common .. "grab.ogg", t = 2.1},
        },
    },
    ["reload_empty_10rnd"] = {
        Source = "reload_10rnd_empty",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.55,
        LHIKEaseOut = 0.25,
        MinProgress = 2.1,
        LastClip1OutTime = 2,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = common .. "magpouch.ogg", t = 0.1},
            {s = ratel, t = 0.25},
            {s = path .. "magout.ogg", 	 t = 0.45},
            {s = path .. "bonk.ogg", 	 t = 0.5},
            {s = ratel, t = 0.5},
            {s = rottle,  t = 0.75},
            {s = path .. "magin.ogg",    t = 0.97},
            {s = ratel, t = 1.1},
            {s = common .. "rifle_magdrop.ogg", t = 1.15},
            {s = rottle,  t = 1.15},
            {s = path .. "chback.ogg",    t = 1.9},
            {s = path .. "chamber.ogg",    t = 2.0},
            {s = common .. "grab.ogg", t = 2.4},
            {s = common .. "shoulder.ogg", t = 2.5},
        },
    },
    ["reload_308"] = {
        Source = "reload_308",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.9,
        LHIKEaseOut = 0.25,
        MinProgress = 1.3,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = common .. "magpouch.ogg", t = 0.1},
            {s = ratel, t = 0.25},
            {s = path .. "magout.ogg", 	 t = 0.45},
            {s = ratel, t = 0.5},
            {s = rottle,  t = 0.75},
            {s = path .. "magin_308.ogg",    t = 0.95},
            {s = ratel, t = 1.1},
            {s = rottle,  t = 1.15},
            {s = path .. "scrape.ogg",    t = 1.35},
            {s = common .. "magpouchin.ogg", t = 1.35},
            {s = common .. "shoulder.ogg", t = 2.05},
            {s = common .. "grab.ogg", t = 2.1},
        },
    },
    ["reload_empty_308"] = {
        Source = "reload_308_empty",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.55,
        LHIKEaseOut = 0.25,
        MinProgress = 2.1,
        LastClip1OutTime = 2,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = common .. "magpouch.ogg", t = 0.1},
            {s = ratel, t = 0.25},
            {s = path .. "magout.ogg", 	 t = 0.45},
            {s = path .. "bonk.ogg", 	 t = 0.5},
            {s = ratel, t = 0.5},
            {s = rottle,  t = 0.75},
            {s = path .. "magin_308.ogg",    t = 1.0},
            {s = ratel, t = 1.1},
            {s = common .. "rifle_magdrop.ogg", t = 1.15},
            {s = rottle,  t = 1.15},
            {s = path .. "chback_308.ogg",    t = 1.85},
            {s = path .. "chamber_308.ogg",    t = 2.0},
            {s = common .. "grab.ogg", t = 2.4},
            {s = common .. "shoulder.ogg", t = 2.5},
        },
    },
    ["reload_12g"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.65,
        LHIKEaseOut = 0.25,
        MinProgress = 1.3,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = common .. "magpouch.ogg", t = 0.1},
            {s = ratel, t = 0.25},
            {s = path .. "12ga/magout.ogg", 	 t = 0.45},
            {s = ratel, t = 0.5},
            {s = rottle,  t = 0.75},
            {s = path .. "12ga/magin.ogg",    t = 0.95},
            {s = ratel, t = 1.1},
            {s = rottle,  t = 1.15},
            {s = path .. "scrape.ogg",    t = 1.35},
            {s = common .. "magpouchin.ogg", t = 1.35},
            {s = common .. "shoulder.ogg", t = 2.05},
            {s = common .. "grab.ogg", t = 2.1},
        },
    },
    ["reload_empty_12g"] = {
        Source = "reload_empty",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.5,
        LHIKEaseOut = 0.25,
        MinProgress = 2.1,
        LastClip1OutTime = 2,
        SoundTable = {
            {s = rottle,  t = 0.0},
            {s = common .. "magpouch.ogg", t = 0.1},
            {s = ratel, t = 0.25},
            {s = path .. "12ga/magout.ogg", 	 t = 0.45},
            {s = path .. "bonk.ogg", 	 t = 0.5, v = 0.25},
            {s = ratel, t = 0.55},
            {s = rottle,  t = 0.75},
            {s = path .. "12ga/magin.ogg",    t = 0.97},
            {s = ratel, t = 1.1},
            {s = common .. "rifle_magdrop.ogg", t = 1.15},
            {s = rottle,  t = 1.75},
            {s = path .. "12ga/chback.ogg",    t = 1.85},
            {s = path .. "12ga/chamber.ogg",    t = 2.0},
            {s = common .. "grab.ogg", t = 2.4},
            {s = common .. "shoulder.ogg", t = 2.5},
        },
    },
    ["enter_inspect"] = {
        Source = "inspect_enter",
        -- time = 35 / 60,
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 2.5,
        SoundTable = {
            {s = rottle, t = 0},
            {s = common .. "movement-rifle-02.ogg", t = 0.1},
        },
    },
    ["idle_inspect"] = {
        Source = "inspect_loop",
        -- time = 72 / 60,
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 999, -- maybe im dumb
    },
    ["exit_inspect"] = {
        Source = "inspect_exit",
        -- time = 66 / 60,
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 999, -- maybe im dumb
        SoundTable = {
            {s = common .. "movement-rifle-04.ogg", t = 0.2},
            {s = rottle, t = 0.25},
            {s = rottle, t = 1.2},
            {s = common .. "movement-rifle-03.ogg", t = 1.25},
        },
    },
    ["enter_sprint"] = {
        Source = "sprint_start",
        Time = 0.9,
    },
    ["idle_sprint"] = {
        Source = "sprint_idle",
    },
    ["exit_sprint"] = {
        Source = "sprint_end",
        Time = 1.25,
    },
    ["unjam"] = {
        Source = "jamfix",
        -- Time = 45 / 30,
        ShellEjectAt = 0.65,
        -- LHIK = true,
        -- LHIKIn = 0.3,
        -- LHIKEaseIn = 0.4,
        -- LHIKEaseOut = 0.15,
        -- LHIKOut = 0.4,
        -- SoundTable = {                                             zenith do noises here
        --     {s = path .. "chback.ogg",   t = 0.15},
        --     {s = common .. "cloth_4.ogg",  t = 0.5},
        --     {s = path .. "chamber.ogg",  t = 0.5},
        -- },
        SoundTable = {
            {s = common .. "cloth_4.ogg",  t = 0.1},
            {s = path .. "presscheck_1.ogg",    t = 0.2},
            {s = path .. "chback.ogg",    t = 0.6},
            {s = path .. "chamber.ogg",    t = 0.7},
            {s = common .. "grab.ogg", t = 1.1},
            {s = common .. "shoulder.ogg", t = 1.15},
        }
    },
    ["bash_bayonet"] = {
        Source = "bayonet",
        --Time = 1.2,
        --MinProgress = .7,
        SoundTable = {
            {s = "weapons/arccw/melee_lift.wav", t = 0}
        }
    },

    ["exit_bipod"] = {
        Source = "bipod_undeploy",
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.55,
        LHIKEaseOut = 0.25,
        --Time = 1.2,
        --MinProgress = .7,
        Mult = .8,
        SoundTable = {
            -- {s = "weapons/arccw/melee_lift.wav", t = 0}
        }
    },
    ["enter_bipod"] = {
        Source = "bipod_deploy",
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.55,
        LHIKEaseOut = 0.25,
        --Time = 1.2,
        --MinProgress = .7,
        Mult = .8,
        SoundTable = {
            -- {s = "weapons/arccw/melee_lift.wav", t = 0}                   -- yeah here too
        }
    },
}

SWEP.Hook_Think = ArcCW.UC.ADSReload
--lua/weapons/arccw_ur_aw.lua:
return gluapack()()
--lua/weapons/arccw_ur_hk33a3.lua:
return gluapack()()
--lua/weapons/arccw_ur_hk94a3.lua:
if !file.Exists("arccw/shared/sh_1_ur.lua","LUA") then return end

include("weapons/arccw_ur_mp5.lua")

SWEP.Category = "ArcCW - UC Presets"
if GetConVar("arccw_uc_presets_categorize"):GetBool() then
    SWEP.Category = "ArcCW - UC Presets Pistols"
end

SWEP.PrintName = "PK5-CIV" -- make this something russian and cool
SWEP.TrueName = "SP5"
if GetConVar("arccw_truenames"):GetBool() then
    SWEP.PrintName = SWEP.TrueName
end

--SWEP.Attachments[2].Installed = "ur_mp5_barrel_kurz"
SWEP.Attachments[3].Installed = "ur_mp5_caliber_semi"
SWEP.Attachments[8].Installed = "ur_mp5_stock_none"
SWEP.Attachments[9].Installed = "ur_mp5_mag_15"
--SWEP.Attachments[12].Installed = "uc_fg_civvy"

SWEP.NPCWeaponType = nil
--lua/weapons/arccw_ur_spas12.lua:
return gluapack()()
--addons/ch_mining/lua/weapons/ch_mining_pickaxe/shared.lua:
--[[ INFO
models/craphead_scripts/mining/craphead_c_miningpickaxe.mdl
models/craphead_scripts/mining/craphead_w_miningpickaxe.mdl
FOV: 85
Hold type: pistol
idle 		ACT_VM_FIDGET
dig 		ACT_VM_PRIMARYATTACK
hit 	 	ACT_VM_PRIMARYATTACK_1
swing 		ACT_VM_SECONDARYATTACK
inspect		ACT_VM_RELEASE
draw 		ACT_VM_DRAW
not sure 	ACT_VM_FIDGET
76561198314224586
--]]

if SERVER then
	SWEP.Weight				= 5
	SWEP.AutoSwitchTo		= true
	SWEP.AutoSwitchFrom		= true
	AddCSLuaFile( "shared.lua" )
end

if CLIENT then
	SWEP.PrintName			= "Pickaxe"
	SWEP.Author				= "Crap-Head"
	SWEP.Slot				= 2
	SWEP.SlotPos			= 1
	SWEP.DrawAmmo			= false
	SWEP.DrawWeaponInfoBox	= false
	SWEP.BounceWeaponIcon   = false
	SWEP.SwayScale			= 1.0
	SWEP.BobScale			= 1.0
end

SWEP.Author					= "Crap-Head"
SWEP.Instructions 			= "Left Click: Mine rocks, Rick Click: Mine rocks harder, Reload: Flex pickaxe model"
SWEP.Category 				= "Mining by Crap-Head"

SWEP.UseHands				= true
SWEP.ViewModelFOV			= 85

SWEP.ViewModel 				= "models/craphead_scripts/mining/craphead_c_miningpickaxe.mdl"
SWEP.WorldModel				= "models/craphead_scripts/mining/craphead_w_miningpickaxe.mdl"

SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true

SWEP.Primary.Range			= 120
SWEP.Primary.Recoil			= 4.6
SWEP.Primary.Damage			= 100
SWEP.Primary.Cone			= 0.005
SWEP.Primary.NumShots		= 1

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic		= false	
SWEP.Primary.Ammo			= "none"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= false
SWEP.Secondary.Ammo			= "none"

function SWEP:SetupDataTables()
	self:NetworkVar( "Float", 0, "NextIdle" )
end

function SWEP:Initialize()
	self:SetWeaponHoldType( "pistol" )
	
	self:SetNextIdle( 0 )
	
	self.SwingSound = CreateSound( self, "weapons/iceaxe/iceaxe_swing1.wav" )
	self.SwingSound:SetSoundLevel( CH_Mining.Config.WeaponSoundLevel )
	
	self.HitSound = CreateSound( self, "physics/metal/metal_computer_impact_bullet2.wav" )
	self.HitSound:SetSoundLevel( CH_Mining.Config.WeaponSoundLevel )
	
    return true
end

function SWEP:Deploy()
	local ply = self:GetOwner()
	local cur_time = CurTime()
	
	self:SendWeaponAnim( ACT_VM_DRAW )
	self:SetNextIdle( cur_time + self:SequenceDuration() )
	
	-- Do delay
	self:SetNextPrimaryFire( cur_time + self:SequenceDuration() )
	self:SetNextSecondaryFire( cur_time + self:SequenceDuration() )
	
	local skin = 0
	
	if ply and ply.CH_Mining_Experience then
		if ply:CH_Mining_GetLevel() >= CH_Mining.Config.PickaxeSkinLevels[ "Diamond" ] then
			ply.CH_Mining_PickaxeSkin = "Diamond"
			skin = 2
		elseif ply:CH_Mining_GetLevel() >= CH_Mining.Config.PickaxeSkinLevels[ "Gold" ] then
			ply.CH_Mining_PickaxeSkin = "Gold"
			skin = 1
		end
	end
	
	local vm = ply:GetViewModel()
	vm:SetSkin( skin )
	self:SetSkin( skin )
	
	return true
end

function SWEP:Holster( wep )
	if not IsFirstTimePredicted() then return end
	
	if self.SwingSound then 
		self.SwingSound:Stop() 
	end
	if self.HitSound then 
		self.HitSound:Stop() 
	end

	return true
end

function SWEP:PrimaryAttack()
	local ply = self:GetOwner()
	local trace = ply:GetEyeTrace()
	local target = trace.Entity
	local cur_time = CurTime()
	
    if CLIENT then return end
	
	-- Do delay
	local speed_level = ply:CH_Mining_GetSkillPoints( "Speed" )
	local speed_mine = CH_Mining.Skills["Speed"].Levels[ speed_level ]
	
	if CH_BoostUpgrades and CH_BoostUpgrades.MiningSpeedActivated then
		speed_mine = speed_mine / 2
	end
	
	self:SetNextPrimaryFire( cur_time + speed_mine )
	self:SetNextSecondaryFire( cur_time + 3 )
	
	-- Send anim
	self:SendWeaponAnim( ACT_VM_PRIMARYATTACK_1 )
	self:SetNextIdle( cur_time + self:SequenceDuration() )
	self.SwingSound:Play()
	
	-- Timer in order to wait for anim to look realistic
	timer.Simple( 0.5, function()
		if not IsValid( self ) or not IsValid( target ) or ply:GetActiveWeapon():GetClass() != "ch_mining_pickaxe" then
			return
		end

		-- Check distance to target
		if ply:GetPos():DistToSqr( target:GetPos() ) > CH_Mining.Config.DistanceToRockMining then
			return
		end
		
		self.HitSound:Play()
		
		if target:GetClass() == "ch_mining_rock" then
			-- Stop everything if rock is dead
			if target:GetIsDead() then
				return
			end
		
			CH_Mining.HitRock( ply, target, CH_Mining.Config.TakeDurabilityPerHitPickaxe )
			
			--[[
			if ( IsFirstTimePredicted() ) then
				timer.Simple( 0, function()
					local effect = EffectData()
					effect:SetOrigin( trace.HitPos )
					util.Effect( "rock_spark" , effect )
				end )
			end
			--]]
		elseif target:IsPlayer() or target:IsNPC() then
			self:EmitSound( "physics/flesh/flesh_impact_hard" .. math.random( 1, 6 ) .. ".wav" )

			target:TakeDamage( math.random( 2, 4 ), ply, self )
		elseif target:GetClass() == "func_breakable_surf" then
			target:Fire( "Shatter" )
		end
	end )
end 

function SWEP:SecondaryAttack()
	local ply = self:GetOwner()
	local trace = ply:GetEyeTrace()
	local target = trace.Entity
	local cur_time = CurTime()
	
    if CLIENT then return end
	
	-- Do delay
	local speed_level = ply:CH_Mining_GetSkillPoints( "Speed" )
	local speed_mine = CH_Mining.Skills["Speed"].Levels[ speed_level ]
	
	self:SetNextPrimaryFire( cur_time + speed_mine )
	self:SetNextSecondaryFire( cur_time + 3 )
	
	self:SendWeaponAnim( ACT_VM_SECONDARYATTACK )
	self:SetNextIdle( CurTime() + self:SequenceDuration() )
end

function SWEP:Reload()
	local ply = self:GetOwner()
	local cur_time = CurTime()
	
    if CLIENT then return end
	
	-- Do delay
	local speed_level = ply:CH_Mining_GetSkillPoints( "Speed" )
	local speed_mine = CH_Mining.Skills["Speed"].Levels[ speed_level ]
	
	self:SetNextPrimaryFire( cur_time + speed_mine )
	self:SetNextSecondaryFire( cur_time + 3 )
	
	if ( self.CurDelay or 0 ) > cur_time then
		return
	end
	
	self.CurDelay = cur_time + 5
	
	-- Send anim
	self:SendWeaponAnim( ACT_VM_RELEASE )
end

function SWEP:Think()
	-- Used to reset idle animation for deployment and primaryattack
	if self:GetNextIdle() ~= 0 and self:GetNextIdle() < CurTime() then
		self:SendWeaponAnim( ACT_VM_FIDGET )
		self:SetNextIdle( 0 )
		
		if self.SwingSound then 
			self.SwingSound:Stop() 
		end
		if self.HitSound then 
			self.HitSound:Stop() 
		end
	end
end

function SWEP:DoDrawCrosshair( x, y )
	local size = 16

	surface.SetDrawColor( color_white )
	surface.SetMaterial( CH_Mining.Materials.CrosshairIcon )
	surface.DrawTexturedRect( x - 8, y - 8, size, size )
	return true
end
--addons/ch_mining/lua/weapons/ch_mining_pickaxe_afk/shared.lua:
return gluapack()()
--addons/bricksenchancedsweps/lua/weapons/dsr_metal_detector.lua:
return gluapack()()
--addons/glorifiedhandcuffs/lua/weapons/glorifiedhandcuffs_handcuffs.lua:
return gluapack()()
--addons/glorifiedhandcuffs/lua/weapons/glorifiedhandcuffs_handcuffs.lua:

AddCSLuaFile()

SWEP.PrintName = "Kelepçe"
SWEP.Category = "GlorifiedHandcuffs"
SWEP.Author = "GlorifiedPig"
SWEP.Instructions = "Left click to handcuff player. Right click to unhandcuff player. Click E on handcuffed player to interact."

SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

SWEP.DrawAmmo = false
SWEP.Base = "weapon_base"

SWEP.Weight = 6
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false

SWEP.Slot = 1

SWEP.ViewModel = Model( "models/sterling/glorified_c_handcuffs.mdl" )
SWEP.WorldModel = "models/sterling/glorified_w_handcuffs.mdl"
SWEP.UseHands = true
SWEP.ViewModelFOV = 85

SWEP.DrawCrosshair = false

function SWEP:Initialize()
    self:SetHoldType( "pistol" )
end

function SWEP:PrimaryAttack() end
function SWEP:SecondaryAttack() end

if CLIENT then return end

function SWEP:PrimaryAttack()
    self:SetNextPrimaryFire( CurTime() + 10 )
    local ply = self:GetOwner()

    self:GetOwner():LagCompensation( true )
    local tr = ply:GetEyeTraceNoCursor()
    self:GetOwner():LagCompensation( false )
    if not tr.Hit then return end

    local maxDist = GlorifiedHandcuffs.Config.HANDCUFF_DISTANCE
    if tr.HitPos:DistToSqr( ply:GetPos() ) > maxDist * maxDist then return end
    if not tr.Entity:IsPlayer() then return end

    if GlorifiedHandcuffs.IsPlayerHandcuffed( tr.Entity ) then return end
    if not GlorifiedHandcuffs.IsPlayerPolice( ply ) and not GlorifiedHandcuffs.Config.CAN_NORMAL_PLAYER_HANDCUFF_WITHOUT_SURRENDER and not GlorifiedHandcuffs.IsPlayerSurrendering( tr.Entity ) and not GlorifiedHandcuffs.Config.JAIL_ONLY_MODE or ( GlorifiedHandcuffs.Config.JAIL_ONLY_MODE and not GlorifiedHandcuffs.IsPlayerPolice( ply ) ) then return end
    if tr.Entity.kamucezasi then return end
    self:SendWeaponAnim( ACT_VM_PRIMARYATTACK )

    timer.Simple( 1, function()
        if not self or not self:IsValid() then return end
        self:SendWeaponAnim( ACT_VM_IDLE )
    end )

    timer.Remove( ply:UserID() .. ".GlorifiedHandcuffs.CuffTimer" )
    ply:ChatPrint("Kelepçeleniyor lütfen bekleyiniz...")
    timer.Create( ply:UserID() .. ".GlorifiedHandcuffs.CuffTimer", 1, 1, function()
        if ply and tr.Entity and ply:Alive() and tr.Entity:Alive() and ply:GetPos():DistToSqr( tr.Entity:GetPos() ) <= maxDist * maxDist then
            if GlorifiedHandcuffs.Config.JAIL_ONLY_MODE then
                GlorifiedHandcuffs.ArrestPlayer( tr.Entity, GlorifiedHandcuffs.Config.JAILER_ARREST_TIME, ply )
            else
                GlorifiedHandcuffs.PlayerHandcuffPlayer( ply, tr.Entity )
            end
        end
    end )
end

function SWEP:SecondaryAttack()
    local ply = self:GetOwner()

    local tr = ply:GetEyeTraceNoCursor()
    if not tr.Hit then return end

    local maxDist = GlorifiedHandcuffs.Config.HANDCUFF_DISTANCE
    if tr.HitPos:DistToSqr( ply:GetPos() ) > maxDist * maxDist then return end
    if not tr.Entity:IsPlayer() then return end

    if GlorifiedHandcuffs.Config.JAIL_ONLY_MODE then
     --   if not GlorifiedHandcuffs.IsPlayerPolice( ply ) then return end
        GlorifiedHandcuffs.UnArrestPlayer( tr.Entity )
    else
        GlorifiedHandcuffs.PlayerUnHandcuffPlayer( ply, tr.Entity )
    end
end
--addons/glorifiedhandcuffs/lua/weapons/glorifiedhandcuffs_restrained.lua:
return gluapack()()
--addons/glorifiedhandcuffs/lua/weapons/glorifiedhandcuffs_restrained.lua:

AddCSLuaFile()

SWEP.PrintName = "Teslim Olma"
SWEP.Category = "GlorifiedHandcuffs"
SWEP.Author = "GlorifiedPig"
SWEP.Instructions = "You are restrained and unable to move."

SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

SWEP.DrawAmmo = false
SWEP.Base = "weapon_base"

SWEP.Weight = 6
SWEP.AutoSwitchTo = true
SWEP.AutoSwitchFrom = false

SWEP.Slot = 1

SWEP.ViewModel = Model( "models/sterling/glorified_c_handcuffs.mdl" )
SWEP.WorldModel = ""
SWEP.UseHands = true
SWEP.ViewModelFOV = 85

SWEP.DrawCrosshair = false

function SWEP:Initialize()
    self:SetHoldType( "normal" )
end

function SWEP:Deploy()
    local ply = self:GetOwner()
    if CLIENT or not IsValid( ply ) then return true end
    ply:DrawWorldModel( false )
    if GlorifiedHandcuffs.IsPlayerHandcuffed( ply ) then
        self:SendWeaponAnim( ACT_VM_HOLSTER )
    else
        self:SendWeaponAnim( ACT_VM_SECONDARYATTACK )
    end
    return false
end

function SWEP:PrimaryAttack() end
function SWEP:SecondaryAttack() end
--addons/realisticcardealer/lua/weapons/gmod_tool/stools/rcd_npc_config.lua:
return gluapack()()
--addons/skeypad_1.2.36/lua/weapons/gmod_tool/stools/skeypad.lua:
return gluapack()()
--addons/skeypad_1.2.36/lua/weapons/gmod_tool/stools/skeypad.lua:
local gradient = Material("gui/gradient_down")
local logo = Material( "skeypad/keypad.png", "noclamp smooth" )
local fingerprintMat, keycardMat, keycodeMat = Material( "skeypad/fingerprint.png", "noclamp smooth" ), Material( "skeypad/keycard.png", "noclamp smooth" ), Material( "skeypad/passcode.png", "noclamp smooth" )

hook.Add("Think", "sK:AddFadingDoorMats", function()
	if !sKeypad then return end

	for k,v in ipairs(sKeypad.config.CustomFadingMaterials) do
		list.Add("FadingMats", v)
	end

	hook.Remove("Think", "sK:AddFadingDoorMats")
end)

TOOL.Category		= "Construction"
TOOL.Name			= "#tool.skeypad.name"
TOOL.Command		= nil
TOOL.ConfigName		= nil

TOOL.ClientConVar["inverse"] = 0
TOOL.ClientConVar["authcanedit"] = 0
TOOL.ClientConVar["pw"] = 1234
TOOL.ClientConVar["timer"] = 5
TOOL.ClientConVar["toggle"] = 0
TOOL.ClientConVar["mode"] = 0
TOOL.ClientConVar["fading_mat"] = ""

local hoverHalos, ownedEnts = {}, {}

local green, white = Color(0,200,0), Color(255,255,255)

local countTbl = function(tbl)
	for k,v in pairs(tbl) do
		if IsValid(v) then continue end
		tbl[k] = nil
	end

	return table.Count(tbl)
end

local doorClasses = {
	["prop_door_rotating"] = true,
	["func_door"] = true,
	["func_door_rotating"] = true
}

local function isDoor(ent)
	if !sKeypad.config.AllowDoorLinking then return false end
	return doorClasses[ent:GetClass()]
end

function TOOL:LeftClick( trace, bypass )
	if self.lastPrimary and !bypass and self.lastPrimary > CurTime() then return false end

	if !bypass then self.lastPrimary = CurTime() + .3 end
	
	local owner = self:GetOwner()
	local bypassGrantedDelay = sKeypad.config.GrantedDelayBypass[owner:GetUserGroup()]
	local pw = isnumber(self:GetClientNumber("pw")) and (#tostring(self:GetClientNumber("pw")) > 4 ) and string.sub(self:GetClientNumber("pw"), 1, 4) or self:GetClientNumber("pw")
	local holdtime = bypassGrantedDelay and self:GetClientNumber("timer", sKeypad.config.GrantedDelay.min) or math.Clamp(self:GetClientNumber("timer", sKeypad.config.GrantedDelay.min), sKeypad.config.GrantedDelay.min, sKeypad.config.GrantedDelay.max)
	local canauthedit = tobool(self:GetClientNumber("authcanedit"))
	local inverse = tobool(self:GetClientNumber("inverse"))
	local toggle = tobool(self:GetClientNumber("toggle"))
	local mode = math.Clamp(self:GetClientNumber("mode"), 0, 3)
	local selected_mat = self:GetClientInfo("fading_mat")

	local ent, pos = trace.Entity, trace.HitPos + trace.HitNormal
	
	if pos then
		if !IsValid(self.targetEnt) then
			if !IsValid(ent) or (!sKeypad.config.WhitelistedEnts[ent:GetClass()] and !isDoor(ent)) then return false end
			self.targetEnt = ent
		else
			if sKeypad.config.BlacklistedModels[ent:GetModel()] then return end
			local ang = trace.HitNormal:Angle()

			if (trace.HitNormal.z == 1) then
				ang.y = owner:GetAngles().y - 180
			end

			if SERVER then
				if sKeypad.config.MaxKeypads > 0 and ownedEnts[owner] and countTbl(ownedEnts[owner]) >= sKeypad.config.MaxKeypads then self.targetEnt = nil return false end
				
				local fadeMat = sKeypad.config.AllowCustomFadingMaterial and (selected_mat or sKeypad.config.CustomFadingMaterials[1]) or sKeypad.config.FadeMaterial

				if ent:GetClass() ~= "s_keypad" then
					if sKeypad.config.MaxPerDoor > 0 and self.targetEnt.keypads and table.Count(self.targetEnt.keypads) >= sKeypad.config.MaxPerDoor then self.targetEnt = nil return false end
					
					local kp = ents.Create("s_keypad")
					kp:SetAngles(ang)
					kp:SetPos(pos - kp:GetUp() * 2)
					kp:SetCreator(owner)
					kp:Spawn()

					local phys = kp:GetPhysicsObject()

					if IsValid(phys) then phys:EnableMotion(false) end
					local isdoor = isDoor(self.targetEnt)
					local doorkey = isdoor and self.targetEnt:EntIndex() or self.targetEnt

					kp.data = {
						owner = owner:SteamID(),
						timer = holdtime,
						code = pw,
						inverse = inverse,
						toggle = toggle,
						mode = mode,
						canauthedit = canauthedit,
						doors = {doorkey},
						authed = {},
						upgrades = {}
					}

					kp:SetBodygroup(2, mode)

					if mode ~= 2 then
						kp:SetBodygroup(1, 1)
					end
					
					undo.Create("s_keypad")
					undo.AddEntity(kp)
					undo.SetPlayer(owner)
					undo.Finish()
					
					if !isdoor then
						constraint.Weld(kp, self.targetEnt, 0, 0, 0, true, false)
					end

					ownedEnts[owner] = ownedEnts[owner] or {}
					table.insert(ownedEnts[owner], kp)

					self.targetEnt.keypads = self.targetEnt.keypads or {}
					self.targetEnt.keypads[kp] = true
					self.targetEnt.sKfadeMat = fadeMat

					local stop = false

					for k, v in pairs(self.targetEnt.keypads) do
						if k:GetSkin() == 1 then kp:SetSkin(1) stop = true end
					end

					if !stop then
						kp:CloseDoor()
					end

					hook.Run("sK:KeypadLinked", kp, self.targetEnt)
				else
					local data = ent.data
				
					if data then
						if data.doors then
							local doorkey = isDoor(self.targetEnt) and self.targetEnt:EntIndex() or self.targetEnt
							table.insert(data.doors, doorkey)
						end
					end
		
					self.targetEnt.keypads = self.targetEnt.keypads or {}
					self.targetEnt.keypads[ent] = true
					self.targetEnt.sKfadeMat = fadeMat

					if ent.data.toggle then
						local prev_door = ent.data.doors[#ent.data.doors - 1]
						
						if prev_door.sKData then
							sKeypad.fadeDoor(self.targetEnt)
						else
							sKeypad.unFadeDoor(self.targetEnt, ent)
						end
					end

					hook.Run("sK:KeypadLinked", ent, self.targetEnt)
				end
			end
			
			self.targetEnt = nil
		end
	end

	return true
end

function TOOL:DrawHUD()
	local trace = LocalPlayer():GetEyeTrace()
	local ent = trace.Entity

	if !IsValid(self.targetEnt) then
		if sKeypad.config.EnableHalos and ent ~= NULL and IsValid(ent) and (sKeypad.config.WhitelistedEnts[ent:GetClass()] or isDoor(ent)) then
			hoverHalos = {ent}
		else
			hoverHalos = {}
		end
	elseif sKeypad.config.EnableLinkBeam then
		if IsValid(ent) and ent:GetClass() == "s_keypad" then
			cam.Start3D(EyePos(), EyeAngles())
				render.SetMaterial(sKeypad.config.BeamMat)
				render.DrawBeam(ent:GetPos(), self.targetEnt:GetPos(), 2, 0.01, 20, sKeypad.config.BeamColor)
			cam.End3D()
		end
	end
	
end

function TOOL:RightClick( trace )
	if CLIENT then return true end
		
	for i=1,2 do
		self:LeftClick(trace, true)
	end

	return true
end

function TOOL:Think()
	if !sKeypad.config.EnableKeypadPreview or SERVER then return end

	local trace = LocalPlayer():GetEyeTrace()
	local ent = trace.Entity
	local pos = trace.HitPos + trace.HitNormal
	local mode = self:GetClientNumber("mode")

	if IsValid(self.targetEnt) and (IsValid(ent) or ent == game.GetWorld()) then
		if !IsValid(self.keypadDisplay) and ent:GetClass() ~= "s_keypad" then
			self.keypadDisplay = ents.CreateClientProp("models/sterling/stromic_skeypad.mdl")
			self.keypadDisplay:SetColor(Color(255,255,255,150))
			self.keypadDisplay:SetRenderMode(RENDERMODE_TRANSCOLOR)
			self.keypadDisplay:SetBodygroup(2, mode)
			self.keypadDisplay:SetAngles(trace.HitNormal:Angle())
			self.keypadDisplay:SetPos(pos - self.keypadDisplay:GetUp() * 2)

			local phys = self.keypadDisplay:GetPhysicsObject()

			if IsValid(phys) then
				phys:EnableMotion(false)
			end
		end

		if ent:GetClass() == "s_keypad" and IsValid(self.keypadDisplay) then
			self.keypadDisplay:Remove()
		end
	else
		if IsValid(self.keypadDisplay) then
			self.keypadDisplay:Remove()
		end
	end

	if !IsValid(self.keypadDisplay) then return end

	pos = trace.HitPos
	local angles = trace.HitNormal:Angle()

	if (trace.HitNormal.z == 1) then
		angles.y = LocalPlayer():GetAngles().y - 180
	end

	self.keypadDisplay:SetPos(pos - self.keypadDisplay:GetUp() * 2)
	self.keypadDisplay:SetAngles(angles)
	self.keypadDisplay:SetBodygroup(2, mode)
end

function TOOL:Holster()
	if IsValid(self.keypadDisplay) then
		self.keypadDisplay:Remove()
	end

	self.targetEnt = nil

	return true
end

function TOOL.BuildCPanel(panel)
	local banner = vgui.Create("EditablePanel", panel)
	banner:SetTall(200)

	banner.Paint = function(s,w,h)
		local color =  HSVToColor(  ( CurTime() * 10 ) % 360, 1, 1 )
		color.a = 60
		surface.SetDrawColor( sKeypad.config.UI["maincolor"] )
		surface.DrawRect( 0, 0, w, h )
	
		surface.SetMaterial( gradient )
		surface.SetDrawColor(color)
		surface.DrawTexturedRect( 0, 0, w, h )
	
		surface.SetMaterial( logo )
		surface.SetDrawColor( white )
		surface.DrawTexturedRect( w * .5 - 64, h * .5 - 64, 128, 128 )
	end

	panel:AddItem(banner)

	panel:AddControl("Header", { Description = slib.getLang("skeypad", sKeypad.config.Language, "tool_usage") })

	local selectionWidth = math.floor(ScrH() * 0.04)

	local selection = vgui.Create("EditablePanel")
	selection:Dock(TOP)
	selection:DockPadding(0,0,0,3)
	selection:SetTall(selectionWidth)

	local selectedMode

	local keycode, fingerprint, keycard

	if !sKeypad.config.DisabledModes["code"] then
		keycode = vgui.Create("DButton", selection)
		keycode:Dock(LEFT)
		keycode:DockMargin(0,0,3,0)
		keycode:SetWide(selectionWidth)
		keycode:SetText("")

		keycode.Paint = function(s,w,h)
			local size = w * .8

			surface.SetDrawColor(selectedMode == s and green or sKeypad.config.UI["maincolor"])
			surface.DrawOutlinedRect(0,0,w,h)

			surface.SetMaterial(keycodeMat)
			surface.SetDrawColor(white)
			surface.DrawTexturedRect( w * .5 - (size * .5), h * .5 - (size * .5), size, size )
		end

		keycode.DoClick = function()
			selectedMode = keycode
			RunConsoleCommand("skeypad_mode", 0)
		end
	end

	if !sKeypad.config.DisabledModes["fingerprint"] then
		fingerprint = vgui.Create("DButton", selection)
		fingerprint:Dock(LEFT)
		fingerprint:DockMargin(0,0,3,0)
		fingerprint:SetWide(selectionWidth)
		fingerprint:SetText("")

		fingerprint.Paint = function(s,w,h)
			local size = w * .8

			surface.SetDrawColor(selectedMode == s and green or sKeypad.config.UI["maincolor"])
			surface.DrawOutlinedRect(0,0,w,h)
			
			surface.SetMaterial(fingerprintMat)
			surface.SetDrawColor(white)
			surface.DrawTexturedRect( w * .5 - (size * .5), h * .5 - (size * .5), size, size )
		end

		fingerprint.DoClick = function()
			selectedMode = fingerprint
			RunConsoleCommand("skeypad_mode", 1)
		end
	end
	
	if !sKeypad.config.DisabledModes["keycard"] then
		keycard = vgui.Create("DButton", selection)
		keycard:Dock(LEFT)
		keycard:SetWide(selectionWidth)
		keycard:SetText("")

		keycard.Paint = function(s,w,h)
			local size = w * .8

			surface.SetDrawColor(selectedMode == s and green or sKeypad.config.UI["maincolor"])
			surface.DrawOutlinedRect(0,0,w,h)
			
			surface.SetMaterial(keycardMat)
			surface.SetDrawColor(white)
			surface.DrawTexturedRect( w * .5 - (size * .5), h * .5 - (size * .5), size, size )
		end

		keycard.DoClick = function()
			selectedMode = keycard
			RunConsoleCommand("skeypad_mode", 2)
		end
	end

	local mode, toolsettings = 0
	local lp = LocalPlayer()
	
	if IsValid(lp) and lp.GetTool then
		toolsettings = lp:GetTool("skeypad")
		mode = toolsettings:GetClientNumber("mode")
	end

	local modeToName = {
		[0] = "code",
		[1] = "fingerprint",
		[2] = "keycard"
	}

	local modeToPanel = {
		[0] = keycode,
		[1] = fingerprint,
		[2] = keycard
	}

	if mode == 0 then
		selectedMode = keycode
	elseif mode == 1 then
		selectedMode = fingerprint
	elseif mode == 2 then
		selectedMode = keycard
	end

	if sKeypad.config.DisabledModes[modeToName[mode]] then
		for i=0, 2 do
			if !sKeypad.config.DisabledModes[modeToName[i]] then
				selectedMode = modeToPanel[i]
				RunConsoleCommand("skeypad_mode", i)

				break
			end
		end
	end

	panel:AddItem(selection)

	local holdlength = panel:NumSlider(slib.getLang("skeypad", sKeypad.config.Language, "hold_length"), "skeypad_timer", 5, 30, 2)
	holdlength:SetMin(sKeypad.config.GrantedDelay.min)
	holdlength:SetMax(sKeypad.config.GrantedDelay.max)

	local code = panel:TextEntry(slib.getLang("skeypad", sKeypad.config.Language, "access_code"), "skeypad_pw")
	code:SetNumeric(true)

	code.OnChange = function()
		local text = code:GetValue() or ""
		if text and text:len() > 4 then
			code:SetText(text:sub(1,text:len()-1))
			TextEntryLoseFocus()
			notification.AddLegacy(slib.getLang("skeypad", sKeypad.config.Language, "max_4digit"), NOTIFY_GENERIC, 3)
		end
	end

	panel:ControlHelp(slib.getLang("skeypad", sKeypad.config.Language, "4digit_passcode"))

	panel:AddControl( "CheckBox", { Label = slib.getLang("skeypad", sKeypad.config.Language, "toggle"), Command = "skeypad_toggle" } )
	panel:ControlHelp(slib.getLang("skeypad", sKeypad.config.Language, "toggle_help"))

	panel:AddControl( "CheckBox", { Label = slib.getLang("skeypad", sKeypad.config.Language, "start_faded"), Command = "skeypad_inverse" } )
	panel:ControlHelp(slib.getLang("skeypad", sKeypad.config.Language, "start_faded_help"))

	panel:AddControl( "CheckBox", { Label = slib.getLang("skeypad", sKeypad.config.Language, "auth_cansettings"), Command = "skeypad_authcanedit" } )
	panel:ControlHelp(slib.getLang("skeypad", sKeypad.config.Language, "auth_cansettings_help"))

	panel:AddControl( "CheckBox", { Label = slib.getLang("skeypad", sKeypad.config.Language, "hide_passcode"), Command = "skeypad_hidecode" } )
	panel:ControlHelp(slib.getLang("skeypad", sKeypad.config.Language, "hide_passcode_help"))

	if sKeypad.config.AllowCustomFadingMaterial then
		panel:AddControl("Header", { Description = slib.getLang("skeypad", sKeypad.config.Language, "fading_material_help") })
		panel:MatSelect("skeypad_fading_mat", list.Get("FadingMats"), true, 0.33, 0.33)
	end
end

function TOOL:DrawToolScreen( w, h )
	local color = HSVToColor(  ( CurTime() * 10 ) % 360, 1, 1 )
	color.a = 60
	surface.SetDrawColor( sKeypad.config.UI["maincolor"] )
	surface.DrawRect( 0, 0, w, h )

	surface.SetMaterial( gradient )
	surface.SetDrawColor(color)
	surface.DrawTexturedRect( 0, 0, w, h )

	draw.SimpleText( "sKeypad", slib.createFont("Nasalization Rg", 40), w * .5, h * .5, white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
end

hook.Add("PreDrawHalos", "sK:DrawHaloOnHover", function()
	local ply = LocalPlayer()
	if !sKeypad.config.EnableHalos or !IsValid(ply) then return end
	local wep = ply:GetActiveWeapon()
	if !IsValid(wep) then return end
	if wep:GetClass() ~= "gmod_tool" then hoverHalos = {} end
	halo.Add( hoverHalos, sKeypad.config.HaloColor, 0, 0, 2, true )
end )

if CLIENT then
	timer.Create("sK:CheckToolMode", 1, 0, function()
		local ply = LocalPlayer()
		if !IsValid(ply) then return end
		local weapon = ply:GetActiveWeapon()
		if IsValid(weapon) and weapon:GetClass() == "gmod_tool" and weapon:GetTable().current_mode ~= "skeypad" then
			hoverHalos = {}
		end
	end)
end
--lua/weapons/gmod_tool/stools/stacker_improved.lua:
--[[--------------------------------------------------------------------------
	Improved Stacker Tool

	Note:
		Please DO NOT reupload this tool (verbatim or small tweaks) to the workshop or other public file-sharing websites.
		I actively maintain this tool, so reuploading it may lead to people using outdated, buggy, or malicious copies.
		If there is an issue with the tool, LET ME KNOW via one of the following pages:
		
		- GitHub:    https://github.com/Mista-Tea/improved-stacker
		- Workshop:  http://steamcommunity.com/sharedfiles/filedetails/?id=264467687
		- Facepunch: https://facepunch.com/showthread.php?t=1399120
	
	Author:
		- Original            :: OverloadUT (STEAM_0:1:5250809)
		- Updated for GMod 13 :: Marii      (STEAM_0:1:16015332)
		- Rewritten           :: Mista Tea  (STEAM_0:0:27507323)
	
	Changelog:
		- May 27th, 2014 :: Added to GitHub 
		- May 28th, 2014 :: Added to Workshop 
		- Jun 5th,  2014 :: Massive overhaul 
		- Jul 24th, 2014 :: Large update 
		- Aug 12th, 2014 :: Optimizations 
		- Jun 30th, 2015 :: Bug fixes/features 
		- Jul 11th, 2015 :: Bug fixes 
		- Oct 26th, 2015 :: Bug fixes
		- Aug 3rd,  2016 :: Bug fixes
		- Aug 31st, 2016 :: Bug fixes
		- Sep 2nd,  2016 :: Added Bulgarian language support
		- Sep 26th, 2017 :: Added ability to toggle use of SHIFT key with LMB/RMB
		- Oct 27th, 2017 :: Small client optimization, reverted nocollide implementation back to original
		- Apr 14th, 2018 :: Added French language support
		- Oct 12th, 2018 :: Added Polish language support
		- Jul 21st, 2019 :: Added Russian language support
		- Jul 23rd, 2019 :: Added Simplified Chinese language support
		- May 10th, 2020 :: Fixed unstable clientside ghosts caused by ents.CreateClientProp changes
		- Jun 18th, 2020 :: Clientside performance improvement when tool is not selected
		- Apr 30th, 2021 :: Added German language support
		
		Fixes:
			- Prevented crash from players using very high X/Y/Z offset values.
			- Prevented crash from players using very high P/Y/R rotate values.
			- Prevented crash from very specific constraint settings.
			- Fixed the halo option for ghosted props not working.
			- Fixed massive FPS drop from halos being rendered in a Think hook instead of a PreDrawHalos hook.
			- Fixed materials and color saving when duping stacked props.
			- Fixed incorrect stack angles when trying to create a stack on an existing stack.
			
		Tweaks:
			- Added convenience functions to retrieve the client convars.
			- Added option to enable/disable automatically applying materials to the stacked props.
			- Added option to enable/disable automatically applying colors to the stacked props.
			- Added option to enable/disable automatically applying physical properties (gravity, physics material, weight) to the stacked props.
			- Added support for props with multiple skins.
			- Added support for external prop protections/anti-spam addons with the StackerEntity hook.
			- Modified NoCollide to actually no-collide each stacker prop with every other prop in the stack.
			
			- Added console variables for server operators to limit various parts of stacker.
				> stacker_improved_max_per_player         <-inf/inf> (less than 0 == no limit)
				> stacker_improved_max_per_stack          <-inf/inf> (less than 0 == no limit)
				> stacker_improved_max_offsetx            <-inf/inf>
				> stacker_improved_max_offsety            <-inf/inf>
				> stacker_improved_max_offsetz            <-inf/inf>
				> stacker_improved_force_stayinworld         <0/1>
				> stacker_improved_force_weld                <0/1>
				> stacker_improved_force_freeze              <0/1>
				> stacker_improved_force_nocollide           <0/1>
				> stacker_improved_force_nocollide_all       <0/1>
				> stacker_improved_delay                     <0/inf>

			- Added console commands for server admins to control the console variables that limit stacker.
				> stacker_improved_set_max_per_player     <-inf/inf> (less than 0 == no limit)
				> stacker_improved_set_max_per_stack      <-inf/inf> (less than 0 == no limit)
				> stacker_improved_set_maxoffset          <-inf/inf>
				> stacker_improved_set_maxoffsetx         <-inf/inf>
				> stacker_improved_set_maxoffsety         <-inf/inf>
				> stacker_improved_set_maxoffsetz         <-inf/inf>
				> stacker_improved_set_force_stayinworld     <0/1>
				> stacker_improved_set_weld                  <0/1>
				> stacker_improved_set_freeze                <0/1>
				> stacker_improved_set_nocollide             <0/1>
				> stacker_improved_set_nocollide_all         <0/1>
				> stacker_improved_set_delay                 <0/inf>

----------------------------------------------------------------------------]]

local mode = TOOL.Mode -- defined by the name of this file (default should be stacker_improved)

--[[--------------------------------------------------------------------------
-- Modules & Dependencies
--------------------------------------------------------------------------]]--

-- needed for localization support (depends on GMod locale: "gmod_language")
include( "improvedstacker/localify.lua" )
localify.LoadSharedFile( "improvedstacker/localization.lua" ) -- loads the file containing localized phrases
local L = localify.Localize                                   -- used for translating string tokens into localized phrases
local prefix = "#tool."..mode.."."                            -- prefix used for this tool's localization tokens

-- needed for various stacker functionality
include( "improvedstacker/improvedstacker.lua" )
improvedstacker.Initialize( mode )

--[[--------------------------------------------------------------------------
-- Localized Functions & Variables
--------------------------------------------------------------------------]]--

-- localizing global functions/tables is an encouraged practice that improves code efficiency,
-- since accessing a local value is considerably faster than a global value
local bit = bit
local cam = cam
local net = net
local util = util
local math = math
local undo = undo
local halo = halo
local game = game
local ents = ents
local draw = draw
local hook = hook
local list = list
local pairs = pairs
local table = table
local Angle = Angle
local Color = Color
local render = render
local Vector = Vector
local tobool = tobool
local CurTime = CurTime
local surface = surface
local IsValid = IsValid
local localify = localify
local language = language
local tonumber = tonumber
local GetConVar = GetConVar
local construct = construct
local duplicator = duplicator
local constraint = constraint
local concommand = concommand
local LocalPlayer = LocalPlayer
local CreateConVar = CreateConVar
local improvedstacker = improvedstacker
local GetConVarNumber = GetConVarNumber
local RunConsoleCommand = RunConsoleCommand

local IN_USE = IN_USE
local NOTIFY_ERROR = NOTIFY_ERROR or 1
local MOVETYPE_NONE = MOVETYPE_NONE
local SOLID_VPHYSICS = SOLID_VPHYSICS
local RENDERMODE_TRANSALPHA = RENDERMODE_TRANSALPHA

local TRANSPARENT = Color( 255, 255, 255, 150 )

local MIN_NOTIFY_BITS = 3 -- the minimum number of bits needed to send a NOTIFY enum
local NOTIFY_DURATION = 5 -- the number of seconds to display notifications

local MAX_ANGLE = 180

local showSettings = false

--[[--------------------------------------------------------------------------
-- Tool Settings
--------------------------------------------------------------------------]]--

TOOL.Category = "Construction"
TOOL.Name     = L(prefix.."name")

TOOL.Information = {
	"left",
	"right",
	{ 
		name  = "shift_left",
		icon2  = "gui/e.png",
		icon = "gui/lmb.png",
		
	},
	{
		name  = "shift_right",
		icon2  = "gui/e.png",
		icon = "gui/rmb.png",
	},
	"reload",
}

if ( CLIENT ) then

	TOOL.ClientConVar[ "mode" ]          = improvedstacker.MODE_PROP
	TOOL.ClientConVar[ "direction" ]     = improvedstacker.DIRECTION_UP
	TOOL.ClientConVar[ "count" ]         = "1"
	TOOL.ClientConVar[ "freeze" ]        = "1"
	TOOL.ClientConVar[ "weld" ]          = "1"
	TOOL.ClientConVar[ "nocollide" ]     = "1"
	TOOL.ClientConVar[ "ghostall" ]      = "1"
	TOOL.ClientConVar[ "material" ]      = "1"
	TOOL.ClientConVar[ "physprop" ]      = "1"
	TOOL.ClientConVar[ "color" ]         = "1"
	TOOL.ClientConVar[ "offsetx" ]       = "0"
	TOOL.ClientConVar[ "offsety" ]       = "0"
	TOOL.ClientConVar[ "offsetz" ]       = "0"
	TOOL.ClientConVar[ "pitch" ]         = "0"
	TOOL.ClientConVar[ "yaw" ]           = "0"
	TOOL.ClientConVar[ "roll" ]          = "0"
	TOOL.ClientConVar[ "relative" ]      = "1"
	TOOL.ClientConVar[ "draw_halos" ]    = "0"
	TOOL.ClientConVar[ "halo_r" ]        = "255"
	TOOL.ClientConVar[ "halo_g" ]        = "0"
	TOOL.ClientConVar[ "halo_b" ]        = "0"
	TOOL.ClientConVar[ "halo_a" ]        = "255"
	TOOL.ClientConVar[ "draw_axis" ]     = "1"
	TOOL.ClientConVar[ "axis_labels" ]   = "1"
	TOOL.ClientConVar[ "axis_angles" ]   = "0"
	TOOL.ClientConVar[ "opacity" ]       = "100"
	TOOL.ClientConVar[ "use_shift_key" ] = "0"

	--[[--------------------------------------------------------------------------
	-- Language Settings
	--------------------------------------------------------------------------]]--

	language.Add( "tool."..mode..".name",         L(prefix.."name") )
	language.Add( "tool."..mode..".desc",         L(prefix.."desc") )
	--language.Add( "tool."..mode..".0",            L(prefix.."0") )
	language.Add( "tool."..mode..".left",         L(prefix.."left") )
	language.Add( "tool."..mode..".shift_left",   L(prefix.."shift_left") )
	language.Add( "tool."..mode..".right",        L(prefix.."right") )
	language.Add( "tool."..mode..".shift_right",  L(prefix.."shift_right") )
	language.Add( "tool."..mode..".reload",       L(prefix.."reload") )
	language.Add( "Undone_"..mode,                L("Undone_"..mode) )
	
	--[[--------------------------------------------------------------------------
	-- Net Messages
	--------------------------------------------------------------------------]]--
	
	--[[--------------------------------------------------------------------------
	-- 	Net :: <toolmode>_error( string )
	--]]--
	net.Receive( mode.."_error", function( bytes )
		surface.PlaySound( "buttons/button10.wav" )
		notification.AddLegacy( net.ReadString(), net.ReadUInt(MIN_NOTIFY_BITS), NOTIFY_DURATION )
	end )
	
end

--[[--------------------------------------------------------------------------
-- Console Variables
--------------------------------------------------------------------------]]--

-- This is solely for backwards compatibility.
-- We're essentially copying everyone's old cvar values over since we're switching from 'stacker' to 'stacker_improved'.
-- If we didn't do this, we'd run the risk of ruining someone's custom setup
--[[local oldMaxTotal    = GetConVar( "stacker_max_total" )       and GetConVar( "stacker_max_total" ):GetInt()       or -1
local oldMaxCount    = GetConVar( "stacker_max_count" )       and GetConVar( "stacker_max_count" ):GetInt()       or 15
local oldMaxOffX     = GetConVar( "stacker_max_offsetx" )     and GetConVar( "stacker_max_offsetx" ):GetFloat()   or 200
local oldMaxOffY     = GetConVar( "stacker_max_offsety" )     and GetConVar( "stacker_max_offsety" ):GetFloat()   or 200
local oldMaxOffZ     = GetConVar( "stacker_max_offsetz" )     and GetConVar( "stacker_max_offsetz" ):GetFloat()   or 200
local oldStayInWorld = GetConVar( "stacker_stayinworld" )     and GetConVar( "stacker_stayinworld" ):GetInt()     or 1
local oldFreeze      = GetConVar( "stacker_force_freeze" )    and GetConVar( "stacker_force_freeze" ):GetInt()    or 0
local oldWeld        = GetConVar( "stacker_force_weld" )      and GetConVar( "stacker_force_weld" ):GetInt()      or 0
local oldNoCollide   = GetConVar( "stacker_force_nocollide" ) and GetConVar( "stacker_force_nocollide" ):GetInt() or 0
local oldDelay       = GetConVar( "stacker_delay" )           and GetConVar( "stacker_delay" ):GetFloat()         or 0.25
]]
local cvarFlags, cvarFlagsNotify

if ( SERVER ) then
	cvarFlags      = bit.bor( FCVAR_REPLICATED, FCVAR_SERVER_CAN_EXECUTE, FCVAR_ARCHIVE )
	cvarFlagsNotif = bit.bor( cvarFlags, FCVAR_NOTIFY )
elseif ( CLIENT ) then
	cvarFlags      = bit.bor( FCVAR_REPLICATED, FCVAR_SERVER_CAN_EXECUTE, FCVAR_ARCHIVE )
	cvarFlagsNotif = bit.bor( cvarFlags, FCVAR_NOTIFY )
end

local oldMaxTotal    = CreateConVar( "stacker_max_total",        -1, cvarFlagsNotif, "Defines the max amount of props that a player can have spawned from stacker" )
local oldMaxCount    = CreateConVar( "stacker_max_count",        15, cvarFlagsNotif, "Defines the max amount of props that can be stacked at a time" )
local oldDelay       = CreateConVar( "stacker_delay",           0.5, cvarFlagsNotif, "Determines the amount of time that must pass before a player can use stacker again" )
local oldMaxOffX     = CreateConVar( "stacker_max_offsetx",     200, cvarFlagsNotif, "Defines the max distance on the x plane that stacked props can be offset (for individual control)" )
local oldMaxOffY     = CreateConVar( "stacker_max_offsety",     200, cvarFlagsNotif, "Defines the max distance on the y plane that stacked props can be offset (for individual control)" )
local oldMaxOffZ     = CreateConVar( "stacker_max_offsetz",     200, cvarFlagsNotif, "Defines the max distance on the z plane that stacked props can be offset (for individual control)" )
local oldFreeze      = CreateConVar( "stacker_force_freeze",      0, cvarFlagsNotif, "Determines whether props should be forced to spawn frozen or not" )
local oldWeld        = CreateConVar( "stacker_force_weld",        0, cvarFlagsNotif, "Determines whether props should be forced to spawn welded or not" )
local oldNoCollide   = CreateConVar( "stacker_force_nocollide",   0, cvarFlagsNotif, "Determines whether props should be forced to spawn nocollided or not" )
local oldStayInWorld = CreateConVar( "stacker_stayinworld",       1, cvarFlagsNotif, "Determines whether props should be restricted to spawning inside the world or not (addresses possible crashes)" )

local cvarMaxPerPlayer = CreateConVar( mode.."_max_per_player",      oldMaxTotal:GetInt(),    cvarFlags,      "Defines the max amount of props that a player can have spawned from stacker" )
local cvarMaxPerStack  = CreateConVar( mode.."_max_per_stack",       oldMaxCount:GetInt(),    cvarFlags,      "Defines the max amount of props that can be stacked at a time" )
local cvarDelay        = CreateConVar( mode.."_delay",               oldDelay:GetFloat(),     cvarFlags,      "Determines the amount of time that must pass before a player can use stacker again" )
local cvarMaxOffX      = CreateConVar( mode.."_max_offsetx",         oldMaxOffX:GetFloat(),   cvarFlags,      "Defines the max distance on the x plane that stacked props can be offset (for individual control)" )
local cvarMaxOffY      = CreateConVar( mode.."_max_offsety",         oldMaxOffY:GetFloat(),   cvarFlags,      "Defines the max distance on the y plane that stacked props can be offset (for individual control)" )
local cvarMaxOffZ      = CreateConVar( mode.."_max_offsetz",         oldMaxOffZ:GetFloat(),   cvarFlags,      "Defines the max distance on the z plane that stacked props can be offset (for individual control)" )
local cvarFreeze       = CreateConVar( mode.."_force_freeze",        oldFreeze:GetInt(),      cvarFlagsNotif, "Determines whether props should be forced to spawn frozen or not" )
local cvarWeld         = CreateConVar( mode.."_force_weld",          oldWeld:GetInt(),        cvarFlagsNotif, "Determines whether props should be forced to spawn welded or not" )
local cvarNoCollide    = CreateConVar( mode.."_force_nocollide",     oldNoCollide:GetInt(),   cvarFlagsNotif, "Determines whether props should be forced to spawn nocollided or not" )
local cvarNoCollideAll = CreateConVar( mode.."_force_nocollide_all", 0,                       cvarFlags,      "(EXPERIMENTAL, DISABLED) Determines whether props should be nocollide with everything except players, vehicles, and npcs" )
local cvarStayInWorld  = CreateConVar( mode.."_force_stayinworld",   oldStayInWorld:GetInt(), cvarFlagsNotif, "Determines whether props should be restricted to spawning inside the world or not (addresses possible crashes)" )

--[[--------------------------------------------------------------------------
-- Console Commands
--------------------------------------------------------------------------]]--

if ( CLIENT ) then
	
	concommand.Add( mode.."_reset_offsets", function( ply, cmd, args )
		-- reset all of the offset values to 0
		RunConsoleCommand( mode.."_offsetx", "0.00" )
		RunConsoleCommand( mode.."_offsety", "0.00" )
		RunConsoleCommand( mode.."_offsetz", "0.00" )
	end	)
	
	concommand.Add( mode.."_reset_angles", function( ply, cmd, args )
		-- reset all of the angle values to 0
		RunConsoleCommand( mode.."_pitch",   "0.00" )
		RunConsoleCommand( mode.."_yaw",     "0.00" )
		RunConsoleCommand( mode.."_roll",    "0.00" )
	end )
	
	concommand.Add( mode.."_reset_admin", function( ply, cmd, args )
		for cmd, val in pairs( improvedstacker.SETTINGS_DEFAULT ) do
			RunConsoleCommand( cmd, val )
		end
	end )
	
elseif ( SERVER ) then

	local function validateCommand( ply, cmd, arg )
		-- run our hook to see if the server is manually allowing/blocking this player from changing the cvar
		-- true:          allow
		-- false:         block
		-- nil (default): fallback to a ply:IsAdmin() check
		local result, reason = hook.Run( "StackerConVar", ply, cmd, arg )

		-- if a player ran the command and the server didn't explicitly allow them to change the cvar
		if ( IsValid( ply ) and result ~= true ) then
			-- if the server blocked the change, send the player an error
			if ( result == false )                     then
				ply:PrintMessage( HUD_PRINTTALK, L(prefix.."error_blocked_by_server", localify.GetLocale( ply )) .. (isstring(reason) and ": " .. reason or "") )
				return false
			end
			-- if the server didn't give a response, fallback to a ply:IsAdmin() check
			if ( result == nil and not ply:IsAdmin() ) then
				ply:PrintMessage( HUD_PRINTTALK, L(prefix.."error_not_admin", localify.GetLocale( ply )) .. ": " .. cmd )
				return false
			end
		end
		
		-- lastly, ensure the argument is a valid number before returning true
		if ( not tonumber( arg ) ) then
			ply:PrintMessage( HUD_PRINTTALK, L(prefix.."error_invalid_argument", localify.GetLocale( ply )) )
			return false
		end
		
		return true
	end
	--[[-------------------------------------------------------------]]--
	concommand.Add( mode.."_set_max_per_player", function( ply, cmd, args )
		if ( not validateCommand( ply, mode.."_set_max_per_player", args[1] ) ) then return false end
		RunConsoleCommand( mode.."_max_per_player", args[1] )
	end )
	--[[-------------------------------------------------------------]]--
	concommand.Add( mode.."_set_max_per_stack", function( ply, cmd, args )
		if ( not validateCommand( ply, mode.."_set_max_per_stack", args[1] ) ) then return false end
		RunConsoleCommand( mode.."_max_per_stack", args[1] )
	end )
	--[[-------------------------------------------------------------]]--
	concommand.Add( mode.."_set_max_offset", function( ply, cmd, args )
		if ( not validateCommand( ply, mode.."_set_max_offset", args[1] ) ) then return false end
		RunConsoleCommand( mode.."_max_offsetx", args[1] )
		RunConsoleCommand( mode.."_max_offsety", args[1] )
		RunConsoleCommand( mode.."_max_offsetz", args[1] )
	end )
	--[[-------------------------------------------------------------]]--
	concommand.Add( mode.."_set_max_offsetx", function( ply, cmd, args )
		if ( not validateCommand( ply, mode.."_set_max_offsetx", args[1] ) ) then return false end
		RunConsoleCommand( mode.."_max_offsetx", args[1] )
	end )
	--[[-------------------------------------------------------------]]--
	concommand.Add( mode.."_set_max_offsety", function( ply, cmd, args )
		if ( not validateCommand( ply, mode.."_set_max_offsety", args[1] ) ) then return false end
		RunConsoleCommand( mode.."_max_offsety", args[1] )
	end )
	--[[-------------------------------------------------------------]]--
	concommand.Add( mode.."_set_max_offsetz", function( ply, cmd, args )
		if ( not validateCommand( ply, mode.."_set_max_offsetz", args[1] ) ) then return false end
		RunConsoleCommand( mode.."_max_offsetz", args[1] )
	end )
	--[[-------------------------------------------------------------]]--
	concommand.Add( mode.."_set_force_stayinworld", function( ply, cmd, args )
		if ( not validateCommand( ply, mode.."_set_force_stayinworld", args[1] ) ) then return false end
		RunConsoleCommand( mode.."_force_stayinworld", tobool( args[1] ) and "1" or "0" )
	end )
	--[[-------------------------------------------------------------]]--
	concommand.Add( mode.."_set_force_freeze", function( ply, cmd, args )
		if ( not validateCommand( ply, mode.."_set_force_freeze", args[1] ) ) then return false end	
		RunConsoleCommand( mode.."_force_freeze", tobool( args[1] ) and "1" or "0" )
	end )
	--[[-------------------------------------------------------------]]--
	concommand.Add( mode.."_set_force_weld", function( ply, cmd, args )
		if ( not validateCommand( ply, mode.."_set_force_weld", args[1] ) ) then return false end
		RunConsoleCommand( mode.."_force_weld", tobool( args[1] ) and "1" or "0" )
	end )
	--[[-------------------------------------------------------------]]--
	concommand.Add( mode.."_set_force_nocollide", function( ply, cmd, args )
		if ( not validateCommand( ply, mode.."_set_force_nocollide", args[1] ) ) then return false end
		RunConsoleCommand( mode.."_force_nocollide", tobool( args[1] ) and "1" or "0" )
	end )
	--[[-------------------------------------------------------------]]--
	concommand.Add( mode.."_set_force_nocollide_all", function( ply, cmd, args )
		if ( not validateCommand( ply, mode.."_set_force_nocollide_all", args[1] ) ) then return false end
		RunConsoleCommand( mode.."_force_nocollide_all", tobool( args[1] ) and "1" or "0" )
	end )
	--[[-------------------------------------------------------------]]--
	concommand.Add( mode.."_set_delay", function( ply, cmd, args )
		if ( not validateCommand( ply, mode.."_set_delay", args[1] ) ) then return false end
		RunConsoleCommand( mode.."_delay", args[1] )
	end )

	
	util.AddNetworkString( mode.."_error" )

	--[[--------------------------------------------------------------------------
	--	TOOL:SendError( str )
	--	Convenience function for sending an error to the tool owner.
	--]]--
	function TOOL:SendError( str )		
		net.Start( mode.."_error" )
			net.WriteString( str )
			net.WriteUInt( NOTIFY_ERROR, MIN_NOTIFY_BITS )
		net.Send( self:GetOwner() )
	end

end

--[[--------------------------------------------------------------------------
-- Convenience Functions
--------------------------------------------------------------------------]]--

--[[--------------------------------------------------------------------------
-- 	TOOL:GetMaxPerPlayer() and TOOL:GetNumberPlayerEnts()
--
--	The total number of props a player has spawned from the Stacker tool is recorded
--	on them via ply.TotalStackerEnts. When a player removes a prop that has been spawned
--	from Stacker, the total count is decreased by 1.
--
--	In combination with the stacker_max_per_player cvar, this function can prevent players
--	from crashing the server by stacking dozens of welded props and unfreezing them.
--
--	By default, the number of stacker props is -1 (infinite). This is done to not interfere
--	with servers that don't want to limit the number of Stacker props a player can spawn directly.
--	They may still hit cvars like sbox_maxprops before ever hitting stacker_max_per_player.
--
--	As an example case, if players are crashing your servers by spawning 50 welded chairs 
--	and unfreezing them all at once, you can set stacker_max_per_player to 30 so that at any
--	given time they can only have 30 props created by Stacker. Trying to stack any more props
--	would give the player an error message.
--]]--
function TOOL:GetMaxPerPlayer()     return cvarMaxPerPlayer:GetInt() end
function TOOL:GetNumberPlayerEnts() return improvedstacker.GetEntCount( self:GetOwner(), 0 ) end

--[[--------------------------------------------------------------------------
-- 	TOOL:GetStackSize()
--	Gets the amount of props that the client wants to stack at once.
--]]--
function TOOL:GetStackSize() return self:GetClientNumber( "count" ) end

--[[--------------------------------------------------------------------------
-- 	TOOL:GetMaxPerStack()
--	Gets the maximum amount of props that can be stacked at a time.
--]]--
function TOOL:GetMaxPerStack() return cvarMaxPerStack:GetInt() end

--[[--------------------------------------------------------------------------
-- 	TOOL:GetDirection()
--	Gets the direction to stack the props.
--]]--
function TOOL:GetDirection()
	local direction = self:GetClientNumber( "direction" )
	return improvedstacker.Directions[ direction ] and direction or improvedstacker.DIRECTION_FRONT
end

--[[--------------------------------------------------------------------------
-- 	TOOL:GetStackerMode()
--	Gets the stacker mode (1 = MODE_WORLD, 2 = MODE_PROP).
--]]--
function TOOL:GetStackerMode()
	local stackMode = self:GetClientNumber( "mode" )
	return improvedstacker.Modes[ stackMode ] and stackMode or improvedstacker.MODE_PROP
end

--[[--------------------------------------------------------------------------
-- 	TOOL:GetOffsetX(), TOOL:GetOffsetY(), TOOL:GetOffsetZ(), TOOL:GetOffsetVector()
--	Gets the distance to offset the position of the stacked props.
--	These values are clamped to prevent server crashes from players
--	using very high offset values.
--]]--
function TOOL:GetOffsetX()      return math.Clamp( self:GetClientNumber( "offsetx" ), -cvarMaxOffX:GetFloat(), cvarMaxOffX:GetFloat() ) end
function TOOL:GetOffsetY()      return math.Clamp( self:GetClientNumber( "offsety" ), -cvarMaxOffY:GetFloat(), cvarMaxOffY:GetFloat() ) end
function TOOL:GetOffsetZ()      return math.Clamp( self:GetClientNumber( "offsetz" ), -cvarMaxOffZ:GetFloat(), cvarMaxOffZ:GetFloat() ) end
function TOOL:GetOffsetVector() return Vector( self:GetOffsetX(), self:GetOffsetY(), self:GetOffsetZ() ) end

--[[--------------------------------------------------------------------------
-- 	TOOL:GetRotateP(), TOOL:GetRotateY(), TOOL:GetRotateR(), TOOL:GetRotationAngle()
--	Gets the value to rotate the angle of the stacked props.
--	These values are clamped to prevent server crashes from players
--	using very high rotation values.
--]]--
function TOOL:GetRotateP()     return math.Clamp( self:GetClientNumber( "pitch" ), -MAX_ANGLE, MAX_ANGLE ) end
function TOOL:GetRotateY()     return math.Clamp( self:GetClientNumber( "yaw" ),   -MAX_ANGLE, MAX_ANGLE ) end
function TOOL:GetRotateR()     return math.Clamp( self:GetClientNumber( "roll" ),  -MAX_ANGLE, MAX_ANGLE ) end
function TOOL:GetRotationAngle() return Angle( self:GetRotateP(), self:GetRotateY(), self:GetRotateR() ) end

--[[--------------------------------------------------------------------------
-- 	TOOL:ShouldFreeze()
--	Returns true if the stacked props should be spawned frozen.
--]]--
function TOOL:ShouldApplyFreeze() return self:GetClientNumber( "freeze" ) == 1 end
function TOOL:ShouldForceFreeze() return cvarFreeze:GetBool() end
--[[--------------------------------------------------------------------------
-- 	TOOL:ShouldWeld()
--	Returns true if the stacked props should be welded together.
--]]--
function TOOL:ShouldApplyWeld() return self:GetClientNumber( "weld" ) == 1 end
function TOOL:ShouldForceWeld() return cvarWeld:GetBool() end
--[[--------------------------------------------------------------------------
-- 	TOOL:ShouldNoCollide()
--	Returns true if the stacked props should be nocollided with each other.
--]]--
function TOOL:ShouldApplyNoCollide() return self:GetClientNumber( "nocollide" ) == 1 end
function TOOL:ShouldForceNoCollide() return cvarNoCollide:GetBool() end
--[[--------------------------------------------------------------------------
-- 	TOOL:ShouldStackRelative()
--	Returns true if the stacked props should be stacked relative to the new rotation.
--	Using this setting will allow you to create curved structures out of props.
--]]--
function TOOL:ShouldStackRelative() return self:GetClientNumber( "relative" ) == 1 end
--[[--------------------------------------------------------------------------
-- 	TOOL:ShouldGhostAll()
--	Returns true if the stacked props should all be ghosted or if only the 
--	first stacked prop should be ghosted.
--]]--
function TOOL:ShouldGhostAll() return self:GetClientNumber( "ghostall" ) == 1 end

--[[--------------------------------------------------------------------------
-- 	TOOL:ShouldAddHalos(), TOOL:GetHaloR(), TOOL:GetHaloG(), TOOL:GetHaloB() TOOL:GetHaloA() TOOL:GetHaloColor()
--	Returns true if the stacked props should have halos drawn on them for added visibility.
--	Gets the RGBA values of the halo color.
--]]--
function TOOL:ShouldAddHalos() return self:GetClientNumber( "draw_halos" ) == 1 end
function TOOL:GetHaloR()       return math.Clamp( self:GetClientNumber( "halo_r" ), 0, 255 ) end
function TOOL:GetHaloG()       return math.Clamp( self:GetClientNumber( "halo_g" ), 0, 255 ) end
function TOOL:GetHaloB()       return math.Clamp( self:GetClientNumber( "halo_b" ), 0, 255 ) end
function TOOL:GetHaloA()       return math.Clamp( self:GetClientNumber( "halo_a" ), 0, 255 ) end
function TOOL:GetHaloColor()   return Color( self:GetHaloR(), self:GetHaloG(), self:GetHaloB(), self:GetHaloA() ) end

--[[--------------------------------------------------------------------------
-- 	TOOL:ShouldApplyMaterial()
--	Returns true if the stacked props should have the original prop's material applied.
--]]--
function TOOL:ShouldApplyMaterial() return self:GetClientNumber( "material" ) == 1 end

--[[--------------------------------------------------------------------------
-- 	TOOL:ShouldApplyColor()
--	Returns true if the stacked props should have the original prop's color applied.
--]]--
function TOOL:ShouldApplyColor() return self:GetClientNumber( "color" ) == 1 end

--[[--------------------------------------------------------------------------
-- 	TOOL:ShouldApplyPhysicalProperties()
--	Returns true if the stacked props should have the original prop's physicsl properties
--	applied, including gravity, physics material, and weight.
--]]--
function TOOL:ShouldApplyPhysicalProperties() return self:GetClientNumber( "physprop" ) == 1 end

--[[--------------------------------------------------------------------------
-- 	TOOL:GetDelay()
--	Returns the time in seconds that must pass before a player can use stacker again.
--	For example, if stacker_delay is set to 3, a player must wait 3 seconds in between each
--	use of stacker's left click. A delay of <= 0 means stacks can be created instantly.
--]]--
function TOOL:GetDelay() return cvarDelay:GetFloat() end

--[[--------------------------------------------------------------------------
-- 	TOOL:GetOpacity()
--	Returns the alpha value (opacity) of the ghosted props seen on the client.
--	Should be between 0 (invisible) and 255 (fully visible).
--]]--
function TOOL:GetOpacity() return self:GetClientNumber( "opacity" ) end

--[[--------------------------------------------------------------------------
-- 	TOOL:GetUseShiftKey()
--	Returns true if the client has enabled the alternate use of SHIFT in combination
--	with left and right clicking. If enable, holding SHIFT and pressing LMB/RMB will
--	have the same effect as holding E and pressing LMB/RMB.
--]]--
function TOOL:GetUseShiftKey() return self:GetClientNumber( "use_shift_key" ) == 1 end
--[[--------------------------------------------------------------------------
-- Tool Functions
--------------------------------------------------------------------------]]--

--[[--------------------------------------------------------------------------
--
-- 	TOOL:LeftClick( table, boolean = nil )
--
--	Attempts to create a stack of props relative to the entity being left clicked.
--]]--
function TOOL:LeftClick( tr, isRightClick )
	local ply = self:GetOwner()
	
	-- check if the player is holding E or SHIFT (as long as they've enabled it)
	if ( ply:KeyDown( IN_USE ) or (self:GetUseShiftKey() and ply:KeyDown( IN_SPEED )) ) then
		if ( CLIENT ) then return false end
		-- increase their stack count by 1 (until it hits the stack max)
		local newCount = self:GetStackSize() >= self:GetMaxPerStack() and self:GetMaxPerStack() or self:GetStackSize() + 1
		ply:ConCommand( mode.."_count "..newCount )
		return false
	end

	if ( not IsValid( tr.Entity ) or tr.Entity:GetClass() ~= "prop_physics" ) then return false end
	if ( CLIENT ) then return true end
	
	-- otherwise, stack 1 if right-clicking or get the client's stack size value
	local count = (isRightClick and 1) or self:GetStackSize()
	-- check if the server wants to control how many props the player can use in the stack
	local maxCount = hook.Run( "StackerMaxPerStack", ply, count, isRightClick ) or self:GetMaxPerStack()

	-- check if the player's stack size is higher than the server's max allowed size (but only if the server didn't explictly override it)
	if ( maxCount >= 0 ) then
		if ( count > maxCount ) then self:SendError( L(prefix.."error_max_per_stack", localify.GetLocale( self:GetOwner() )) .. maxCount ) end
		count = math.Clamp( count, 0, maxCount )
	end
	
	-- get the player's last stacker usage time, defaulting to 0 if it hasn't been set
	local lastStackTime = improvedstacker.GetLastStackTime( ply, 0 )
	
	-- retrieve the time delay between stacker usage
	-- we call StackerDelay to let external mods to set their own delays (less than or equal to 0 means no delay)
	-- delay time is in seconds (e.g. 0.1 is a tenth of a second)
	local delay = hook.Run( "StackerDelay", ply, lastStackTime ) or self:GetDelay()
	
	-- check if the player is trying to use stacker too quickly
	if ( lastStackTime + delay > CurTime() ) then self:SendError( L(prefix.."error_too_quick", localify.GetLocale( self:GetOwner() )) ) return false end
	improvedstacker.SetLastStackTime( ply, CurTime() )
	
	local stackDirection = self:GetDirection()
	local stackMode      = self:GetStackerMode()
	local stackOffset    = self:GetOffsetVector()
	local stackRotation  = self:GetRotationAngle()
	local stackRelative  = self:ShouldStackRelative()
	
	-- determines whether the stacked props are allowed to be positioned outside of the world or not
	local stayInWorld   = cvarStayInWorld:GetBool()

	-- store the properties of the original prop so we can apply them to the stacked props
	local ent = tr.Entity
	local entPos   = ent:GetPos()
	local entAng   = ent:GetAngles()
	local entMod   = ent:GetModel()
	local entSkin  = ent:GetSkin()
	local entMat   = ent:GetMaterial()
	local physMat  = ent:GetPhysicsObject():GetMaterial()
	local physGrav = ent:GetPhysicsObject():IsGravityEnabled()
	
	-- setup a table to hold the original prop's color data so that we can apply it to the stacked props
	local colorData = {
		Color      = ent:GetColor(), 
		RenderMode = ent:GetRenderMode(), 
		RenderFX   = ent:GetRenderFX()
	}	
		
	local newEnt
	local newEnts = { ent }
	local lastEnt = ent
	
	local direction, offset
	-- we only need to calculate the distance once based on the direction the user selected
	local distance = improvedstacker.GetDistance( stackMode, stackDirection, ent )
	
	-- setup a new undo block so the player can undo the whole stack at once
	undo.Create( mode )
	
	-- check if the server wants to control how many stacker entities this player can create
	local maxPerPlayer = hook.Run( "StackerMaxPerPlayer", ply, self:GetNumberPlayerEnts() ) or self:GetMaxPerPlayer()
	
	-- loop for every prop to create in the stack and allow external addons to dictate control over the new stacked entities
	for i = 1, count do
		
		-- check if the player has too many active stacker props spawned out already
		local stackerEntsSpawned = self:GetNumberPlayerEnts()
		if ( maxPerPlayer >= 0 and stackerEntsSpawned >= maxPerPlayer ) then self:SendError( ("%s (%s)"):format(L(prefix.."error_max_per_player", localify.GetLocale( self:GetOwner() )), maxPerPlayer) ) break end
		-- check if the player has exceeded the sbox_maxprops cvar
		if ( not self:GetSWEP():CheckLimit( "props" ) )            then break end
		-- check if external admin mods are blocking this entity
		if ( hook.Run( "PlayerSpawnProp", ply, entMod ) == false ) then break end
		
		-- if we're positioning the first entity in the stack (regardless of relative to PROP or WORLD), or
		-- if we're stacking relative to PROP and on the previous rotation, update the new direction and offset
		if ( i == 1 or ( stackMode == improvedstacker.MODE_PROP and stackRelative ) ) then
			direction = improvedstacker.GetDirection( stackMode, stackDirection, entAng )
			offset    = improvedstacker.GetOffset( stackMode, stackDirection, entAng, stackOffset )
		end

		-- calculate the next stacked entity's position
		entPos = entPos + (direction * distance) + offset
		-- rotate the next stacked entity's angle by the client's rotation values
		improvedstacker.RotateAngle( stackMode, stackDirection, entAng, stackRotation )
		
		
		-- check if the stacked props would be spawned outside of the world
		if ( stayInWorld and not util.IsInWorld( entPos ) ) then self:SendError( L(prefix.."error_not_in_world", localify.GetLocale( self:GetOwner() )) ) break end
		
		-- create the new stacked entity
		newEnt = ents.Create( "prop_physics" )
		newEnt:SetModel( entMod )
		newEnt:SetPos( entPos )
		newEnt:SetAngles( entAng )
		newEnt:SetSkin( entSkin )
		newEnt:Spawn()

		-- this hook is for external prop protections and anti-spam addons.
		-- it is called before undo, ply:AddCount, and ply:AddCleanup to allow developers to
		-- remove or mark this entity so that those same functions (if overridden) can
		-- detect that the entity came from Stacker
		if ( not IsValid( newEnt ) or hook.Run( "StackerEntity", newEnt, ply ) ~= nil )             then break end
		if ( not IsValid( newEnt ) or hook.Run( "PlayerSpawnedProp", ply, entMod, newEnt ) ~= nil ) then break end

		-- disabling this for now due to problems with ShouldCollide
		--improvedstacker.MarkEntity( self:GetOwner(), newEnt )
		
		-- increase the total number of active stacker props spawned by the player by 1
		improvedstacker.IncrementEntCount( ply )
		
		-- decrement the total number of active stacker props spawned by the player by 1
		-- when the prop gets removed in any way
		newEnt:CallOnRemove( "UpdateStackerTotal", function( ent, ply )
			-- if the player is no longer connected, there is nothing to do
			if ( not IsValid( ply ) ) then return end
			improvedstacker.DecrementEntCount( ply )
		end, ply )
		
		self:ApplyMaterial( newEnt, entMat )
		self:ApplyColor( newEnt, colorData )
		self:ApplyFreeze( ply, newEnt )
		
		-- attempt to nocollide the new entity with the last, or break out of the loop if CBaseEntityList::AddNonNetworkableEntity fails
		if ( not self:ApplyNoCollide( lastEnt, newEnt ) ) then
			newEnt:Remove()
			break
		end
		
		-- attempt to weld the new entity with the last, or break out of the loop if CBaseEntityList::AddNonNetworkableEntity fails
		if ( not self:ApplyWeld( lastEnt, newEnt ) ) then
			newEnt:Remove()
			break
		end
		
		self:ApplyPhysicalProperties( ent, newEnt, tr.PhysicsBone, { GravityToggle = physGrav, Material = physMat } )
		
		lastEnt = newEnt
		table.insert( newEnts, newEnt )
		
		undo.AddEntity( newEnt )
		ply:AddCleanup( "props", newEnt )
	end
	
	newEnts = nil
	
	undo.SetPlayer( ply )
	undo.Finish()

	-- disabling this for now due to problems with ShouldCollide
	--improvedstacker.MarkEntity( self:GetOwner(), ent )
	
	return true
end

--[[--------------------------------------------------------------------------
--
-- 	TOOL:RightClick( trace )
--
--	Performs a LeftClick operation but only creates a single stacked entity.
--	Alternatively, if the player is holding down their USE key, this will
--	decrease their stack count by 1.
--]]--
function TOOL:RightClick( tr )
	local ply = self:GetOwner()

	-- check if the player is holding E or SHIFT (as long as they've enabled it)
	if ( ply:KeyDown( IN_USE ) or (self:GetUseShiftKey() and ply:KeyDown( IN_SPEED )) ) then
		if ( CLIENT ) then return false end
		-- decrease the player's stack count by 1 (until a minimum of 1)
		local count = self:GetStackSize()
		local newCount = (count <= 1 and 1) or count - 1
		ply:ConCommand( mode.."_count " .. newCount )
		return false
	else
		-- create a single entity in the stack
		return self:LeftClick( tr, true )
	end
	
end

--[[--------------------------------------------------------------------------
--
-- 	TOOL:Reload()
--
--	Switches the client's stack direction.
--]]--
function TOOL:Reload()
	if ( CLIENT ) then return false end

	local ply = self:GetOwner()
	local direction = self:GetDirection()
	
	-- if they were at the last numerical direction (6), wrap around to the first (1)
	if ( direction == improvedstacker.DIRECTION_DOWN ) then
		direction = improvedstacker.DIRECTION_FRONT
	-- otherwise just increment to the next direction
	else
		direction = direction + 1
	end
	
	-- make the player update their client direction setting
	ply:ConCommand( mode.."_direction " .. direction )
	
	return false
end

--[[--------------------------------------------------------------------------
--
-- 	TOOL:ApplyMaterial( entity, string )
--
--	Applies the original entity's material onto the stacked props.
--]]--
function TOOL:ApplyMaterial( ent, material )
	if ( not self:ShouldApplyMaterial() ) then ent:SetMaterial( "" ) return end
	
	-- From: gamemodes/sandbox/entities/weapons/gmod_tool/stools/material.lua
	-- "Make sure this is in the 'allowed' list in multiplayer - to stop people using exploits"
	if ( not game.SinglePlayer() and not list.Contains( "OverrideMaterials", material ) and material ~= "" ) then return end

	ent:SetMaterial( material )
	duplicator.StoreEntityModifier( ent, "material", { MaterialOverride = material } )
end

--[[--------------------------------------------------------------------------
--
-- 	TOOL:ApplyColor( entity, color )
--
--	Applies the original entity's color onto the stacked props.
--]]--
function TOOL:ApplyColor( ent, data )
	if ( not self:ShouldApplyColor() ) then return end

	ent:SetColor( data.Color )
	ent:SetRenderMode( data.RenderMode )
	ent:SetRenderFX( data.RenderFX )
	
	duplicator.StoreEntityModifier( ent, "colour", table.Copy( data ) )
end

--[[--------------------------------------------------------------------------
--
-- 	TOOL:ApplyFreeze( player, entity )
--
--	Attempts to freeze the stacked props in place.
--]]--
function TOOL:ApplyFreeze( ply, ent )
	if ( self:ShouldForceFreeze() or self:ShouldApplyFreeze() ) then
		ent:GetPhysicsObject():EnableMotion( false )
	else
		ent:GetPhysicsObject():Wake()
	end
end

--[[--------------------------------------------------------------------------
--
-- 	TOOL:ApplyWeld( entity, entity )
--
--	Attempts to weld the new entity to the last entity.
--]]--
function TOOL:ApplyWeld( lastEnt, newEnt )
	if ( not self:ShouldForceWeld() and not self:ShouldApplyWeld() ) then return true end
	
	local forceLimit    = 0
	local isNocollided  = self:ShouldForceNoCollide() or self:ShouldApplyNoCollide()
	local deleteOnBreak = false
	
	local ok, err = pcall( constraint.Weld, lastEnt, newEnt, 0, 0, forceLimit, isNocollided, deleteOnBreak )
	
	if ( not ok ) then
		print( mode .. ": " .. L(prefix.."error_max_constraints") .." (error: " .. err .. ")" )
		self:SendError( mode .. ": " .. L(prefix.."error_max_constraints", localify.GetLocale( self:GetOwner() )) )
	end
	
	return ok
end

--[[--------------------------------------------------------------------------
--
-- 	TOOL:ApplyNoCollide( entity, entity )
--
--	Attempts to nocollide the new entity to the last entity.
--]]--
function TOOL:ApplyNoCollide( lastEnt, newEnt )
	if ( not self:ShouldForceNoCollide() and not self:ShouldApplyNoCollide() ) then return true end
	-- we can skip this function if the client is trying to weld -and- nocollide, because
	-- constraint.Weld already has a nocollide parameter
	if ( self:ShouldForceWeld() or self:ShouldApplyWeld() ) then return true end
	
	local ok, err = pcall( constraint.NoCollide, lastEnt, newEnt, 0, 0 )
	
	if ( not ok ) then
		print( mode .. ": " .. L(prefix.."error_max_constraints") .." (error: " .. err .. ")" )
		self:SendError( mode .. ": " .. L(prefix.."error_max_constraints", localify.GetLocale( self:GetOwner() )) )
	end
	
	return ok
end

--[[--------------------------------------------------------------------------
--
-- 	TOOL:ApplyPhysicalProperties( entity, entity, number, table )
--
--	Attempts to apply the original entity's Gravity/Physics Material properties 
--	and weight onto the stacked propa.
--	
--]]--
function TOOL:ApplyPhysicalProperties( original, newEnt, boneID, properties )
	if ( not self:ShouldApplyPhysicalProperties() ) then return end
	
	if ( boneID ) then construct.SetPhysProp( nil, newEnt, boneID, nil, properties ) end
	newEnt:GetPhysicsObject():SetMass( original:GetPhysicsObject():GetMass() )
end

if ( CLIENT ) then
	
	-- get the cvars if they're valid (e.g., editing and auto-refreshing this file).
	-- otherwise they won't be valid yet when first ran and we have to wait until
	-- TOOL:Init() gets called (below) to set them up
	local cvarTool       = GetConVar( "gmod_toolmode" )
	local cvarCount      = GetConVar( mode.."_count" )
	local cvarMode       = GetConVar( mode.."_mode" )
	local cvarDirection  = GetConVar( mode.."_direction" )
	local cvarOffsetX    = GetConVar( mode.."_offsetx" )
	local cvarOffsetY    = GetConVar( mode.."_offsety" )
	local cvarOffsetZ    = GetConVar( mode.."_offsetz" )
	local cvarPitch      = GetConVar( mode.."_pitch" )
	local cvarYaw        = GetConVar( mode.."_yaw" )
	local cvarRoll       = GetConVar( mode.."_roll" )
	local cvarRelative   = GetConVar( mode.."_relative" )
	local cvarMaterial   = GetConVar( mode.."_material" )
	local cvarColor      = GetConVar( mode.."_color" )
	local cvarGhostAll   = GetConVar( mode.."_ghostall" )
	local cvarOpacity    = GetConVar( mode.."_opacity" )
	local cvarHalo       = GetConVar( mode.."_draw_halos" )
	local cvarHaloR      = GetConVar( mode.."_halo_r" )
	local cvarHaloG      = GetConVar( mode.."_halo_g" )
	local cvarHaloB      = GetConVar( mode.."_halo_b" )
	local cvarHaloA      = GetConVar( mode.."_halo_a" )	
	local cvarHalo       = GetConVar( mode.."_draw_halos" )
	local cvarAxis       = GetConVar( mode.."_draw_axis" )
	local cvarAxisLbl    = GetConVar( mode.."_axis_labels" )
	local cvarAxisAng    = GetConVar( mode.."_axis_angles" )
	
	-- offsets for drawing the axis arrows
	local o1 = Vector(     0, 0,  0.05 )
	local o2 = Vector(     0, 0, -0.05 )
	local o3 = Vector(  0.05, 0,     0 )
	local o4 = Vector( -0.05, 0,     0 )
	local ao = 2.5
	
	-- colors for the axis arrows
	local RED   = Color( 255,  50,  50 )
	local GREEN = Color(   0, 255,   0 )
	local BLUE  = Color(  50, 150, 255 )
	local BLACK = Color(   0,   0,   0 )
	
	surface.CreateFont( mode.."_direction", {
		font = "Arial",
		size = 24,
		weight = 700,
		antialias = true
	})
	
	
	-- we're creating a bunch of local functions here using the cvars above so that we don't have to
	-- rely on the TOOL object (which can be problematic when trying to use it inside a hook).
	-- these should be pretty much identical to the TOOL functions created near the top of this file
	local function getStackSize()        return cvarCount:GetInt()       end
	local function getMaxPerStack()      return cvarMaxPerStack:GetInt() end
	local function getStackerMode()      return cvarMode:GetInt()        end
	local function getDirection()        return cvarDirection:GetInt()   end
	local function getOpacity()          return cvarOpacity:GetInt()     end	
	local function shouldGhostAll()      return cvarGhostAll:GetBool()   end
	local function shouldStackRelative() return cvarRelative:GetBool()   end
	local function shouldApplyMaterial() return cvarMaterial:GetBool()   end
	local function shouldApplyColor()    return cvarColor:GetBool()      end
	local function shouldAddHalos()      return cvarHalo:GetBool()       end
	
	local function getOffsetVector()
		return Vector( math.Clamp( cvarOffsetX:GetFloat(), -cvarMaxOffX:GetFloat(), cvarMaxOffX:GetFloat() ), 
	                   math.Clamp( cvarOffsetY:GetFloat(), -cvarMaxOffY:GetFloat(), cvarMaxOffY:GetFloat() ),
	                   math.Clamp( cvarOffsetZ:GetFloat(), -cvarMaxOffZ:GetFloat(), cvarMaxOffZ:GetFloat() ) )
	end

	local function getRotationAngle()
		return Angle( math.Clamp( cvarPitch:GetFloat(), -MAX_ANGLE, MAX_ANGLE ),
                      math.Clamp( cvarYaw:GetFloat(),   -MAX_ANGLE, MAX_ANGLE ),
                      math.Clamp( cvarRoll:GetFloat(),  -MAX_ANGLE, MAX_ANGLE ) )
	end
	
	local function getHaloColor()
		return Color( cvarHaloR:GetInt(),
                      cvarHaloG:GetInt(),
                      cvarHaloB:GetInt(),
	                  cvarHaloA:GetInt() )
	end
	
	--[[--------------------------------------------------------------------------
	--
	-- 	TOOL:Init()
	--
	--]]--
	function TOOL:Init()
		-- now the convars are truly valid, so reassign the upvalues
		cvarTool       = GetConVar( "gmod_toolmode" )
		cvarCount      = GetConVar( mode.."_count" )
		cvarMode       = GetConVar( mode.."_mode" )
		cvarDirection  = GetConVar( mode.."_direction" )
		cvarOffsetX    = GetConVar( mode.."_offsetx" )
		cvarOffsetY    = GetConVar( mode.."_offsety" )
		cvarOffsetZ    = GetConVar( mode.."_offsetz" )
		cvarPitch      = GetConVar( mode.."_pitch" )
		cvarYaw        = GetConVar( mode.."_yaw" )
		cvarRoll       = GetConVar( mode.."_roll" )
		cvarRelative   = GetConVar( mode.."_relative" )
		cvarMaterial   = GetConVar( mode.."_material" )
		cvarColor      = GetConVar( mode.."_color" )
		cvarGhostAll   = GetConVar( mode.."_ghostall" )
		cvarOpacity    = GetConVar( mode.."_opacity" )
		cvarHalo       = GetConVar( mode.."_draw_halos" )
		cvarHaloR      = GetConVar( mode.."_halo_r" )
		cvarHaloG      = GetConVar( mode.."_halo_g" )
		cvarHaloB      = GetConVar( mode.."_halo_b" )
		cvarHaloA      = GetConVar( mode.."_halo_a" )
		cvarHalo       = GetConVar( mode.."_draw_halos" )
		cvarAxis       = GetConVar( mode.."_draw_axis" )
		cvarAxisLbl    = GetConVar( mode.."_axis_labels" )
		cvarAxisAng    = GetConVar( mode.."_axis_angles" )
	end
	
	--[[--------------------------------------------------------------------------
	--
	-- 	createGhostStack( entity, vector, angle )
	--
	--	Attempts to create a stack of ghosted props on the prop the player is currently
	--	looking at before they actually left click to create the stack. This acts
	--	as a visual aid for the player so they can see the results without actually creating
	--	the entities yet (if in multiplayer).
	--]]--
	local function createGhostStack( ent )
		if ( improvedstacker.GetGhosts() ) then improvedstacker.ReleaseGhosts() end

		-- truncate the stack size to the maximum allowed by the server
		local count    = getStackSize()
		local maxCount = getMaxPerStack()
		if ( not shouldGhostAll() and count ~= 0 ) then count = 1 end
		if ( maxCount >= 0 and count > maxCount )  then count = maxCount end

		local entMod  = ent:GetModel()
		local entSkin = ent:GetSkin()
		
		local ghosts = {}
		local ghost
		
		-- loop for the total stack size and create a new ghost prop
		for i = 1, count do
			ghost = ClientsideModel( entMod )
			
			if ( not IsValid( ghost ) ) then continue end

			ghost:SetModel( entMod )
			ghost:SetSkin( entSkin )
			ghost:Spawn()

			ghost:SetRenderMode( RENDERMODE_TRANSALPHA )
			
			table.insert( ghosts, ghost )
		end
		
		-- store the ghost array for later use
		improvedstacker.SetGhosts( ghosts )
		
		return true
	end

	--[[--------------------------------------------------------------------------
	--
	-- 	validateGhostStack()
	--
	--	Attempts to validate the status of the ghosted props in the stack.
	--		True:  all good, ready to update
	--		False: something is invalid or missing, clear it
	--]]--
	local function validateGhostStack()
		-- check if the array of ghosts is valid
		local ghosts = improvedstacker.GetGhosts()
		if ( not ghosts ) then return false end
		
		-- check if all the ghost entities are valid
		for i = 1, #ghosts do
			if ( not IsValid( ghosts[ i ] ) ) then return false end
		end
		
		-- clamp the client's ghost stack to the server's maximum allowed size
		local count    = getStackSize()
		local maxCount = getMaxPerStack()
		if ( maxCount >= 0 and count > maxCount ) then count = maxCount end
		
		-- check if the number of ghosts in the stack matches the client's setting
		if     ( #ghosts ~= count and     shouldGhostAll() ) then return false
		-- number of ghosts matches client's setting, so check if we should only be ghosting one
		elseif ( #ghosts ~= 1     and not shouldGhostAll() ) then return false end
		
		return true
	end

	--[[--------------------------------------------------------------------------
	--
	-- 	updateGhostStack( entity )
	--
	--	Attempts to update the positions and angles of all ghosted props in the stack.
	--]]--
	local function updateGhostStack( ent )		
		local stackMode      = getStackerMode()
		local stackDirection = getDirection()
		local stackOffset    = getOffsetVector()
		local stackRotation  = getRotationAngle()
		local stackRelative  = shouldStackRelative()
		
		local applyMat  = shouldApplyMaterial()
		local applyCol  = shouldApplyColor()
		
		local lastEnt = ent
		local entPos = ent:GetPos()
		local entAng = ent:GetAngles()
		local entMat = ent:GetMaterial()
		local entCol = ent:GetColor()
			  entCol.a = getOpacity()
		
		local direction, offset
		-- we only need to calculate the distance once based on the direction the user selected
		local distance = improvedstacker.GetDistance( stackMode, stackDirection, ent )
		
		local ghost
		local ghosts = improvedstacker.GetGhosts()
		
		for i = 1, #ghosts do
			-- if we're positioning the first entity in the stack (regardless of relative to PROP or WORLD), or
			-- if we're stacking relative to PROP and on the previous rotation, update the new direction and offset
			if ( i == 1 or ( stackMode == improvedstacker.MODE_PROP and stackRelative ) ) then
				direction = improvedstacker.GetDirection( stackMode, stackDirection, entAng )
				offset    = improvedstacker.GetOffset( stackMode, stackDirection, entAng, stackOffset )
			end

			-- calculate the next stacked entity's position
			entPos = entPos + (direction * distance) + offset
			-- rotate the next stacked entity's angle by the client's rotation values
			improvedstacker.RotateAngle( stackMode, stackDirection, entAng, stackRotation )
			
			local ghost = ghosts[ i ]
			ghost:SetPos( entPos )
			ghost:SetAngles( entAng )
			ghost:SetMaterial( ( applyMat and entMat ) or "" )
			ghost:SetColor( ( applyCol and entCol ) or TRANSPARENT )
			ghost:SetNoDraw( false )
			
			lastEnt = ghost
		end
	end
	
	
	--[[--------------------------------------------------------------------------
	--
	-- 	Hook :: PreDrawHalos
	--
	--	Loads the hook that draws halos on the ghosted entities in the stack. 
	--
	--	This is the appropriate hook to create halos, NOT TOOL:Think(). The latter 
	--	will be called way more than it needs to be and causes horrible FPS drops in singleplayer.
	--]]--
	hook.Add( "PreDrawHalos", mode.."_predrawhalos", function()
		-- check if the player has fully initialized
		local ply = LocalPlayer()
		if ( not IsValid( ply ) ) then return end
		
		-- check if they have the toolgun out and have stacker selected
		local wep = ply:GetActiveWeapon()
		if ( not ( IsValid( wep ) and wep:GetClass() == "gmod_tool" and cvarTool and cvarTool:GetString() == mode ) ) then
			improvedstacker.ReleaseGhosts()
			improvedstacker.SetLookedAt( nil )
			return
		end
		
		-- check if we're looking at a valid entity
		local lookingAt = ply:GetEyeTrace().Entity
		if ( not ( IsValid( lookingAt ) and lookingAt:GetClass() == "prop_physics" ) ) then
			improvedstacker.ReleaseGhosts()
			improvedstacker.SetLookedAt( nil )
			return
		end
		
		-- check if the current toolobject is valid before trying to use it --
		-- commenting this out for now since I refactored these TOOL functions
		-- into just local functions to ditch the need for the tool object
		--[[local tool = wep.GetToolObject and wep:GetToolObject() 
		if ( not ( tool and tool.GetOwner and IsValid( tool:GetOwner() ) ) ) then
			return
		end]]
		
		-- specify the entity that the client is currently looking at for future reference
		improvedstacker.SetLookingAt( lookingAt )
		-- get the entity that the client was last (successfully) looking at
		local lookedAt = improvedstacker.GetLookedAt()
		
		-- if we're still looking at the same entity from the previous frame
		if ( lookingAt == lookedAt ) then
			-- if the ghost stack is still valid (nothing got deleted, etc)
			if ( validateGhostStack() ) then
				-- reposition the stack to the client's most recent stack settings
				updateGhostStack( lookingAt )
			else
				-- something is wrong in the stack, so remove the ghost entities
				improvedstacker.ReleaseGhosts()
				improvedstacker.SetLookedAt( nil )
				return
			end
		-- we looked at something else since the last frame
		else
			-- try to initialize a new ghost stack
			if ( createGhostStack( lookingAt ) ) then
				-- ghost stack was successfully created
				improvedstacker.SetLookedAt( lookingAt )
			end
		end
		
		-- check if we want to add halos to the ghost stack
		if ( not shouldAddHalos() ) then return end
		
		-- check if there are any ghosts to add halos to at all
		local ghosts = improvedstacker.GetGhosts()
		if ( not ghosts or #ghosts <= 0 ) then return end

		halo.Add( ghosts, getHaloColor() )
	end )
	
	--[[--------------------------------------------------------------------------
	--
	-- 	Hook :: PostDrawTranslucentRenderables
	--
	--	Draws the 2D x/y/z axis when looking at entities with the stacker tool.
	--]]--
	
	hook.Add( "PostDrawTranslucentRenderables", mode.."_directions", function( drawingDepth, drawingSky )
		if ( drawingSky ) then return end
		
		-- check if the player has fully initialized
		local ply = LocalPlayer()
		if ( not IsValid( ply ) ) then return end
		
		-- check if we want to draw the axis at all
		if ( not ( cvarAxis and cvarAxis:GetBool() ) ) then return end
		
		-- check if they have the toolgun out and have stacker selected
		local wep = ply:GetActiveWeapon()
		if ( not ( IsValid( wep ) and wep:GetClass() == "gmod_tool" and cvarTool and cvarTool:GetString() == mode ) ) then
			return
		end
		
		-- check if we're looking at a valid entity
		local ent = ply:GetEyeTrace().Entity
		if ( not IsValid( ent ) ) then
			return
		end
		
		local pos = ent:GetPos()
		
		local f = ent:GetForward()
		local r = ent:GetRight()
		local u = ent:GetUp()
		
		-- draw the front arrow (red)
		render.DrawLine( pos,    pos + (f*50),      RED, false )
		render.DrawLine( pos + (f*50) - f*ao + Vector(0,0,ao), pos + (f*50), RED, false )
		render.DrawLine( pos + (f*50) - f*ao - Vector(0,0,ao), pos + (f*50), RED, false )
		render.DrawLine( pos+o1, pos + (f*50) + o1, RED, false )
		render.DrawLine( pos+o2, pos + (f*50) + o2, RED, false )
		
		-- draw the right arrow (green)
		render.DrawLine( pos,    pos + (r*50),      GREEN, false )
		render.DrawLine( pos + (r*50) - r*ao + f*ao, pos + (r*50), GREEN, false )
		render.DrawLine( pos + (r*50) - r*ao - f*ao, pos + (r*50), GREEN, false )
		render.DrawLine( pos+o1, pos + (r*50) + o1, GREEN, false )
		render.DrawLine( pos+o2, pos + (r*50) + o2, GREEN, false )
		
		-- draw the upward arrow (blue)
		render.DrawLine( pos,    pos + (u*50),      BLUE, false )
		render.DrawLine( pos + (u*50) - u*ao + r*ao, pos + (u*50), BLUE, false )
		render.DrawLine( pos + (u*50) - u*ao - r*ao, pos + (u*50), BLUE, false )
		render.DrawLine( pos+o3, pos + (u*50) + o3, BLUE, false )
		render.DrawLine( pos+o4, pos + (u*50) + o4, BLUE, false )
		
		-- check if we want to draw the axis labels
		if ( not ( cvarAxisLbl           and cvarAxisAng ) )           then return end
		if ( not ( cvarAxisLbl:GetBool() or  cvarAxisAng:GetBool() ) ) then return end
		
		local fs = (pos + f*50 - u*5):ToScreen()
		local rs = (pos + r*50 - u*5):ToScreen()
		local us = (pos + u*55):ToScreen()
		
		local ang = ent:GetAngles()
		
		local front = ("%s%s"):format( cvarAxisLbl:GetBool() and L(prefix.."hud_front").." " or "", cvarAxisAng:GetBool() and "("..ang.x..")" or "" )
		local right = ("%s%s"):format( cvarAxisLbl:GetBool() and L(prefix.."hud_right").." " or "", cvarAxisAng:GetBool() and "("..ang.y..")" or "" )
		local upwrd = ("%s%s"):format( cvarAxisLbl:GetBool() and L(prefix.."hud_up").." "    or "", cvarAxisAng:GetBool() and "("..ang.z..")" or "" )
		
		cam.Start2D()
			draw.SimpleTextOutlined( front, mode.."_direction", fs.x, fs.y, RED,   0, 0, 1, BLACK )
			draw.SimpleTextOutlined( right, mode.."_direction", rs.x, rs.y, GREEN, 0, 0, 1, BLACK )
			draw.SimpleTextOutlined( upwrd, mode.."_direction", us.x, us.y, BLUE,  1, 0, 1, BLACK )
		cam.End2D()
		
	end )
	
end

if ( CLIENT ) then
	--[[--------------------------------------------------------------------------
	--
	-- 	TOOL.BuildCPanel( panel )
	--
	--	Builds the control panel menu that can be seen when holding Q and accessing
	--	the stacker menu.
	--]]--
	local function buildCPanel( cpanel )
		-- quick presets for default settings
		local presets = { 
			Label      = "Presets",
			MenuButton = 1,
			Folder     = mode,
			Options = {
				[L(prefix.."combobox_default")] = {
					[mode.."_mode"]        = tostring(improvedstacker.MODE_PROP),
					[mode.."_direction"]   = tostring(improvedstacker.DIRECTION_UP),
					[mode.."_count"]       = "1",
					[mode.."_freeze"]      = "1",
					[mode.."_weld"]        = "1",
					[mode.."_nocollide"]   = "1",
					[mode.."_ghostall"]    = "1",
					[mode.."_material"]    = "1",
					[mode.."_physprop"]    = "1",
					[mode.."_color"]       = "1",
					[mode.."_offsetx"]     = "0",
					[mode.."_offsety"]     = "0",
					[mode.."_offsetz"]     = "0",
					[mode.."_pitch"]       = "0",
					[mode.."_yaw"]         = "0",
					[mode.."_roll"]        = "0",
					[mode.."_relative"]    = "1",
					[mode.."_draw_halos"]  = "0",
					[mode.."_halo_r"]      = "255",
					[mode.."_halo_g"]      = "0",
					[mode.."_halo_b"]      = "0",
					[mode.."_halo_a"]      = "255",
					[mode.."_draw_axis"]   = "1",
					[mode.."_axis_labels"] = "1",
					[mode.."_axis_angles"] = "0",
				},
			},
			CVars = { 
				mode.."_mode",
				mode.."_direction",
				mode.."_count",
				mode.."_freeze",
				mode.."_weld",
				mode.."_nocollide",
				mode.."_ghostall",
				mode.."_material",
				mode.."_physprop",
				mode.."_color",
				mode.."_offsetx",
				mode.."_offsety",
				mode.."_offsetz",
				mode.."_pitch",
				mode.."_yaw",
				mode.."_roll",
				mode.."_relative",
				mode.."_draw_halos",
				mode.."_halo_r",
				mode.."_halo_g",
				mode.."_halo_b",
				mode.."_halo_a",
				mode.."_draw_axis",
				mode.."_axis_labels",
				mode.."_axis_angles",
			}
		}
		
		local relativeOptions = {
			[L(prefix.."combobox_world")] = { [mode.."_mode"] = improvedstacker.MODE_WORLD },
			[L(prefix.."combobox_prop")]  = { [mode.."_mode"] = improvedstacker.MODE_PROP  },
		}
		
		local relative = { Label = L(prefix.."label_relative"), MenuButton = "0", Options = relativeOptions }
		
		local directionOptions = {
			["1 - "..L(prefix.."combobox_direction_front")] = { [mode.."_direction"] = improvedstacker.DIRECTION_FRONT },
			["2 - "..L(prefix.."combobox_direction_back")]  = { [mode.."_direction"] = improvedstacker.DIRECTION_BACK  },
			["3 - "..L(prefix.."combobox_direction_right")] = { [mode.."_direction"] = improvedstacker.DIRECTION_RIGHT },
			["4 - "..L(prefix.."combobox_direction_left")]  = { [mode.."_direction"] = improvedstacker.DIRECTION_LEFT  },
			["5 - "..L(prefix.."combobox_direction_up")]    = { [mode.."_direction"] = improvedstacker.DIRECTION_UP    },
			["6 - "..L(prefix.."combobox_direction_down")]  = { [mode.."_direction"] = improvedstacker.DIRECTION_DOWN  },
		}
		
		local directions = { Label = L(prefix.."label_direction"), MenuButton = "0", Options = directionOptions }
		
		-- populate the table of valid languages that clients can switch between
		local languageOptions = {}
		
		for code, tbl in pairs( localify.GetLocalizations() ) do
			if ( not L(prefix.."language_"..code, code) ) then continue end
			
			languageOptions[ L(prefix.."language_"..code, code) ] = { localify_language = code }
		end
		
		local languages = {
			Label      = L(prefix.."label_language"),
			MenuButton = 0,
			Options    = languageOptions,
		}
		
		cpanel:AddControl( "ComboBox", languages )
		cpanel:ControlHelp( "\n" .. L(prefix.."label_credits") )
		cpanel:AddControl( "Label",    { Text = L(prefix.."label_presets") } )
		cpanel:AddControl( "ComboBox", presets )
		cpanel:AddControl( "Checkbox", { Label = L(prefix.."checkbox_freeze"),    Command = mode.."_freeze" } )
		cpanel:AddControl( "Checkbox", { Label = L(prefix.."checkbox_weld"),      Command = mode.."_weld" } )
		cpanel:AddControl( "Checkbox", { Label = L(prefix.."checkbox_nocollide"), Command = mode.."_nocollide" } )	
		cpanel:AddControl( "ComboBox", relative )	
		cpanel:AddControl( "ComboBox", directions )
		cpanel:AddControl( "Slider",   { Label = L(prefix.."label_count"), Min = 1, Max = cvarMaxPerStack:GetInt(), Command = mode.."_count", Description = "How many props to create in each stack" } )
		cpanel:AddControl( "Button",   { Label = L(prefix.."label_reset_offsets"), Command = mode.."_reset_offsets" } )
		cpanel:AddControl( "Slider",   { Label = L(prefix.."label_x"),     Type = "Float", Min = - cvarMaxOffX:GetInt(), Max = cvarMaxOffX:GetInt(), Value = 0, Command = mode.."_offsetx" } )
		cpanel:AddControl( "Slider",   { Label = L(prefix.."label_y"),     Type = "Float", Min = - cvarMaxOffY:GetInt(), Max = cvarMaxOffY:GetInt(), Value = 0, Command = mode.."_offsety" } )
		cpanel:AddControl( "Slider",   { Label = L(prefix.."label_z"),     Type = "Float", Min = - cvarMaxOffZ:GetInt(), Max = cvarMaxOffZ:GetInt(), Value = 0, Command = mode.."_offsetz" } )
		cpanel:AddControl( "Button",   { Label = L(prefix.."label_reset_angles"),  Command = mode.."_reset_angles" } )
		cpanel:AddControl( "Slider",   { Label = L(prefix.."label_pitch"), Type = "Float", Min = -MAX_ANGLE,  Max = MAX_ANGLE,  Value = 0, Command = mode.."_pitch" } )
		cpanel:AddControl( "Slider",   { Label = L(prefix.."label_yaw"),   Type = "Float", Min = -MAX_ANGLE,  Max = MAX_ANGLE,  Value = 0, Command = mode.."_yaw" } )
		cpanel:AddControl( "Slider",   { Label = L(prefix.."label_roll"),  Type = "Float", Min = -MAX_ANGLE,  Max = MAX_ANGLE,  Value = 0, Command = mode.."_roll" } )
		
		cpanel:AddControl( "Button",   { Label = L(prefix.."label_"..(showSettings and "hide" or "show").."_settings"),   Command = mode.."_show_settings" } )
		
		if ( showSettings ) then
			cpanel:AddControl( "Checkbox", { Label = L(prefix.."checkbox_use_shift_key"), Command = mode.."_use_shift_key", Description = "Toggles the ability to hold SHIFT and click the left and right mouse buttons to change stack size" } )
			cpanel:AddControl( "Checkbox", { Label = L(prefix.."checkbox_relative"),      Command = mode.."_relative",      Description = "Stacks each prop relative to the prop right before it. This allows you to create curved stacks" } )
			cpanel:AddControl( "Checkbox", { Label = L(prefix.."checkbox_material"),      Command = mode.."_material",      Description = "Applies the material of the original prop to all stacked props" } )
			cpanel:AddControl( "Checkbox", { Label = L(prefix.."checkbox_color"),         Command = mode.."_color",         Description = "Applies the color of the original prop to all stacked props" } )
			cpanel:AddControl( "Checkbox", { Label = L(prefix.."checkbox_physprop"),      Command = mode.."_physprop",      Description = "Applies the physical properties of the original prop to all stacked props" } )
			cpanel:AddControl( "Checkbox", { Label = L(prefix.."checkbox_ghost"),         Command = mode.."_ghostall",      Description = "Creates every ghost prop in the stack instead of just the first ghost prop" } )
			cpanel:AddControl( "Checkbox", { Label = L(prefix.."checkbox_axis"),          Command = mode.."_draw_axis", } )
			cpanel:AddControl( "Checkbox", { Label = L(prefix.."checkbox_axis_labels"),   Command = mode.."_axis_labels", } )
			cpanel:AddControl( "Checkbox", { Label = L(prefix.."checkbox_axis_angles"),   Command = mode.."_axis_angles", } )
			cpanel:AddControl( "Checkbox", { Label = L(prefix.."checkbox_halo"),          Command = mode.."_draw_halos", Description = "Gives halos to all of the props in to ghosted stack" } )
			cpanel:AddControl( "Slider",   { Label = L(prefix.."label_opacity"), Type = "Integer", Min = 0, Max = 255, Command = mode.."_opacity" } )
			cpanel:AddControl( "Color",    { Label = L(prefix.."checkbox_halo_color"), Red = mode.."_halo_r", Green = mode.."_halo_g", Blue = mode.."_halo_b", Alpha = mode.."_halo_a" } )
		end
	end
	
	concommand.Add( mode.."_show_settings", function( ply, cmd, args )
		local cpanel = controlpanel.Get( mode )
		if ( not IsValid( cpanel ) ) then return end
		showSettings = not showSettings
		cpanel:ClearControls()
		buildCPanel( cpanel )
	end )

	-- listen for changes to the localify language and reload the tool's menu to update the localizations
	cvars.AddChangeCallback( "localify_language", function( name, old, new )
		local cpanel = controlpanel.Get( mode )
		if ( not IsValid( cpanel ) ) then return end
		cpanel:ClearControls()
		buildCPanel( cpanel )
	end, "improvedstacker" )
	
	TOOL.BuildCPanel = buildCPanel

	--[[--------------------------------------------------------------------------
	--
	-- 	PopulateToolMenu
	--
	--	Builds the admin settings control panel in the utility menu. This allows server
	--	operators to quickly and easily save/change Stacker server settings.
	--]]--
	hook.Add( "PopulateToolMenu", mode.."AdminUtilities", function()
		spawnmenu.AddToolMenuOption( "Utilities", "Admin", mode.."_utils", L(prefix.."name"), "", "", function( cpanel )
			
			-- quick presets for default settings
			local presets = {
				label      = "Presets",
				menubutton = 1,
				folder     = mode.."_admin",
				options = {
					[L(prefix.."combobox_default")]      = improvedstacker.SETTINGS_DEFAULT,
					[L(prefix.."combobox_sandbox")]      = improvedstacker.SETTINGS_SANDBOX,
					[L(prefix.."combobox_darkrp")]       = improvedstacker.SETTINGS_DARKRP,
					[L(prefix.."combobox_singleplayer")] = improvedstacker.SETTINGS_SINGLEPLAYER,
				},
				cvars = {
					{ CVar = mode.."_max_per_player",    CCmd = mode.."_set_max_per_player" },
					{ CVar = mode.."_max_per_stack",     CCmd = mode.."_set_max_per_stack" },
					{ CVar = mode.."_delay",             CCmd = mode.."_set_delay" },
					{ CVar = mode.."_max_offsetx",       CCmd = mode.."_set_max_offsetx" },
					{ CVar = mode.."_max_offsety",       CCmd = mode.."_set_max_offsety" },
					{ CVar = mode.."_max_offsetz",       CCmd = mode.."_set_max_offsetz" },
					{ CVar = mode.."_force_freeze",      CCmd = mode.."_set_force_freeze" },
					{ CVar = mode.."_force_weld",        CCmd = mode.."_set_force_weld" },
					{ CVar = mode.."_force_nocollide",   CCmd = mode.."_set_force_nocollide" },
					{ CVar = mode.."_force_stayinworld", CCmd = mode.."_set_force_stayinworld" },
				},
			}
			
			local ctrl = vgui.Create( "StackerControlPresets", cpanel )
			ctrl:SetPreset( presets.folder )
			for k, v in pairs( presets.options ) do
				ctrl:AddOption( k, v )
			end
			for k, v in pairs( presets.cvars ) do
				ctrl:AddConVar( v )
			end			
			cpanel:AddItem( ctrl )
			--cpanel:AddControl( "ComboBox", presets )
			
			
			local bg = Color( 210, 210, 210 ) or Color( 179, 216, 255 )
			local fg = Color( 240, 240, 240 ) or Color( 229, 242, 255 )
			
			local sliders = {
				{ String = "max_per_player", Min = -1, Max = 2048,  Decimals = 0 },
				{ String = "max_per_stack",  Min =  1, Max = 100,   Decimals = 0 },
				{ String = "delay",          Min =  0, Max = 5,                  },
				{ String = "max_offsetx",    Min =  0, Max = 10000,              },
				{ String = "max_offsety",    Min =  0, Max = 10000,              },
				{ String = "max_offsetz",    Min =  0, Max = 10000,              },
			}
			
			local sliderlist = vgui.Create( "DListLayout", cpanel )
			sliderlist:DockPadding( 3, 1, 3, 3 )
			sliderlist:SetPaintBackground( true )
			function sliderlist:Paint( w, h )
				draw.RoundedBox( 0, 0, 0, w, h, bg )
			end
			cpanel:AddItem( sliderlist )
			
			for k, data in pairs( sliders ) do
				local list = vgui.Create( "DListLayout", sliderlist )
				list:DockPadding( 5, 0, 5, 5 )
				list:DockMargin( 0, 2, 0, 0 )
				list:SetPaintBackground( true )
				function list:Paint( w, h )
					draw.RoundedBox( 0, 0, 0, w, h, fg )
				end
			
				local decimals = data.Decimals or 2
			
				local slider = vgui.Create( "StackerDNumSlider", list )
				slider:SetText( L(prefix.."label_"..data.String) )
				slider.Label:SetFont( "DermaDefaultBold" )
				slider:SetMinMax( data.Min, data.Max )
				slider:SetDark( true )
				slider:SizeToContents()
				slider:SetDecimals( decimals )
				slider:SetValue( decimals == 0 and GetConVar( mode.."_"..data.String ):GetInt() or GetConVar( mode.."_"..data.String ):GetFloat(), true )
				
				local cmd = mode.."_set_"..data.String
				
				function slider:OnValueChanged( value )
					value = math.Round( value, decimals )
					RunConsoleCommand( cmd, value )
				end
				
				if ( L(prefix.."help_"..data.String) ) then
					local help = vgui.Create( "DLabel", list )
					help:SetText( L(prefix.."help_"..data.String) )
					help:DockMargin( 10, 0, 5, 0 )
					help:SetWrap( true )
					help:SetDark( true )
					help:SetAutoStretchVertical( true )
					help:SetFont( "DermaDefault" )
				end
				
				if ( L(prefix.."warning_"..data.String) ) then
					local help = vgui.Create( "DLabel", list )
					help:SetText( L(prefix.."warning_"..data.String) )
					help:DockMargin( 10, 0, 5, 0 )
					help:SetWrap( true )
					help:SetDark( true )
					help:SetAutoStretchVertical( true )
					help:SetFont( "DermaDefault" )
					help:SetTextColor( Color( 200, 0, 0 ) )
				end
				
				cvars.AddChangeCallback( mode.."_"..data.String, function( name, old, new )
					if ( not IsValid( slider ) ) then return end
					slider:SetValue( GetConVar( mode.."_"..data.String ):GetFloat(), true )
				end, mode.."_"..data.String.."_utilities" )
			end
			
			
			
			local checkboxes = {
				"freeze",
				"weld",
				"nocollide",
				"nocollide_all",
				"stayinworld",
			}

			local cblist = vgui.Create( "DListLayout", cpanel )
			cblist:DockPadding( 3, 1, 3, 3 )
			cblist:SetPaintBackground( true )
			function cblist:Paint( w, h )
				draw.RoundedBox( 0, 0, 0, w, h, bg )
			end
			cpanel:AddItem( cblist )
			
			for k, data in pairs( checkboxes ) do
				local list = vgui.Create( "DListLayout", cblist )
				list:DockPadding( 5, 5, 5, 5 )
				list:DockMargin( 0, 2, 0, 0 )
				list:SetPaintBackground( true )
				function list:Paint( w, h )
					draw.RoundedBox( 0, 0, 0, w, h, fg )
				end
			
				local cb = vgui.Create( "DCheckBoxLabel", list )
				cb:SetText( L(prefix.."checkbox_"..data) )
				cb:SetChecked( GetConVar( mode.."_force_"..data ):GetBool() )
				cb.Label:SetFont( "DermaDefaultBold" )
				cb:SizeToContents()
				cb:SetDark( true )
				-- we don't want this value to be changed while the server is running, so disable the checkbox
				if ( data == "nocollide_all" ) then
					cb:SetDisabled( true )
				end
				
				function cb:OnChange( bool ) RunConsoleCommand( mode.."_set_force_"..data, bool and "1" or "0" ) end
				
				cvars.AddChangeCallback( mode.."_force_"..data, function( name, old, new )
					if ( not IsValid( cb ) ) then return end
					cb:SetChecked( tobool( new ) )
				end, mode.."_"..data.."_utilities" )
				
				if ( L(prefix.."help_"..data) ) then
					local help = vgui.Create( "DLabel", list )
					help:SetText( L(prefix.."help_"..data) )
					help:DockMargin( 25, 5, 5, 0 )
					help:SetWrap( true )
					help:SetDark( true )
					help:SetAutoStretchVertical( true )
					help:SetFont( "DermaDefault" )
				end
				
				if ( L(prefix.."warning_"..data) ) then
					local help = vgui.Create( "DLabel", list )
					help:SetText( L(prefix.."warning_"..data) )
					help:DockMargin( 25, 5, 5, 0 )
					help:SetWrap( true )
					help:SetDark( true )
					help:SetAutoStretchVertical( true )
					help:SetFont( "DermaDefault" )
					help:SetTextColor( Color( 200, 0, 0 ) )
				end
			end
		end )
	end )
end

--lua/improvedstacker/localization.lua:
--local prefix = "#tool."..debug.getinfo( 1, "S" ).source:match(".+[/?\\?](.+)%.lua").."."

local prefix = "#tool.stacker_improved."

localify.Bind( "en",    prefix.."language_en",    "English" )
localify.Bind( "bg",    prefix.."language_bg",    "Български" )
localify.Bind( "fr",    prefix.."language_fr",    "Français" )
localify.Bind( "pl",    prefix.."language_pl",    "Polski" )
localify.Bind( "ru",    prefix.."language_ru",    "Русский" )
localify.Bind( "zh-cn", prefix.."language_zh-cn", "简体中文" )
localify.Bind( "de",    prefix.."language_de",    "Deutsch" )
localify.Bind( "tr",    prefix.."language_tr",    "Türkçe" )

--[[--------------------------------------------------------------------------
-- English Localization
--------------------------------------------------------------------------]]--

-- Tool Settings
localify.Bind( "en", prefix.."name",                     "Stacker - Improved" )
localify.Bind( "en", prefix.."desc",                     "Easily stack duplicated props in any direction" )
localify.Bind( "en", prefix.."left",                     "Create a stack" )
localify.Bind( "en", prefix.."shift_left",               "Increase stack size" )
localify.Bind( "en", prefix.."right",                    "Create a single prop" )
localify.Bind( "en", prefix.."shift_right",              "Decrease stack size" )
localify.Bind( "en", prefix.."reload",                   "Change stack direction" )
localify.Bind( "en", "Undone_stacker_improved",          "Undone stacked prop(s)" )
-- Errors
localify.Bind( "en", prefix.."error_blocked_by_server",  "The server has blocked you from changing this console variable" )
localify.Bind( "en", prefix.."error_not_admin",          "You must be in the 'admin' usergroup to change this console variable" )
localify.Bind( "en", prefix.."error_invalid_argument",   "You must enter a valid number value" )
localify.Bind( "en", prefix.."error_max_per_stack",      "The max props that can be stacked at once is limited to " )
localify.Bind( "en", prefix.."error_too_quick",          "You are using stacker too quickly" )
localify.Bind( "en", prefix.."error_max_per_player",     "Stacker prop limit reached" )
localify.Bind( "en", prefix.."error_not_in_world",       "Stacked props must be spawned within the world" )
localify.Bind( "en", prefix.."error_max_constraints",    "Failed to create constraint, most likely ran out of entity slots" )
-- Labels
localify.Bind( "en", prefix.."label_presets",            "Stacker Presets: " )
localify.Bind( "en", prefix.."label_relative",           "Stack relative to: " )
localify.Bind( "en", prefix.."label_direction",          "Stack direction: " )
localify.Bind( "en", prefix.."label_count",              "Stack size" )
localify.Bind( "en", prefix.."label_reset_offsets",      "Reset offsets" )
localify.Bind( "en", prefix.."label_reset_angles",       "Reset angles" )
localify.Bind( "en", prefix.."label_show_settings",      "Click to show settings" )
localify.Bind( "en", prefix.."label_hide_settings",      "Click to hide settings" )
localify.Bind( "en", prefix.."label_x",                  "X  (-back, +front)" )
localify.Bind( "en", prefix.."label_y",                  "Y  (-left, +right)" )
localify.Bind( "en", prefix.."label_z",                  "Z  (-down, +up)" )
localify.Bind( "en", prefix.."label_pitch",              "Pitch  (-down, +up)" )
localify.Bind( "en", prefix.."label_yaw",                "Yaw   (-left, +right)" )
localify.Bind( "en", prefix.."label_roll",               "Roll    (-left, +right)" )
localify.Bind( "en", prefix.."label_language",           "Language: " )
localify.Bind( "en", prefix.."label_credits",            "" )
localify.Bind( "en", prefix.."label_max_per_stack",      "Stack size" )
localify.Bind( "en", prefix.."label_max_per_player",     "Props per player" )
localify.Bind( "en", prefix.."label_max_offsetx",        "Maximum X offset" )
localify.Bind( "en", prefix.."label_max_offsety",        "Maximum Y offset" )
localify.Bind( "en", prefix.."label_max_offsetz",        "Maximum Z offset" )
localify.Bind( "en", prefix.."label_delay",              "Delay" )
localify.Bind( "en", prefix.."label_opacity",            "Opacity" )
-- Checkboxes
localify.Bind( "en", prefix.."checkbox_freeze",          "Freeze stacked props" )
localify.Bind( "en", prefix.."checkbox_weld",            "Weld stacked props" )
localify.Bind( "en", prefix.."checkbox_nocollide",       "No-Collide stacked props with each other" )
localify.Bind( "en", prefix.."checkbox_nocollide_all",   "No-Collide stacked props with EVERYTHING" )
localify.Bind( "en", prefix.."checkbox_use_shift_key",   "Change stack size with SHIFT + left/right-click" )
localify.Bind( "en", prefix.."checkbox_relative",        "Stack relative to new rotation" )
localify.Bind( "en", prefix.."checkbox_material",        "Apply material" )
localify.Bind( "en", prefix.."checkbox_color",           "Apply color" )
localify.Bind( "en", prefix.."checkbox_physprop",        "Apply physical properties" )
localify.Bind( "en", prefix.."checkbox_ghost",           "Ghost all props in the stack" )
localify.Bind( "en", prefix.."checkbox_halo",            "Add halos to ghosted props" )
localify.Bind( "en", prefix.."checkbox_halo_color",      "Halo color" )
localify.Bind( "en", prefix.."checkbox_axis",            "Draw XYZ axis" )
localify.Bind( "en", prefix.."checkbox_axis_labels",     "Draw XYZ axis labels" )
localify.Bind( "en", prefix.."checkbox_axis_angles",     "Draw XYZ axis angles" )
localify.Bind( "en", prefix.."checkbox_stayinworld",     "Stay in world" )
-- Comboboxes
localify.Bind( "en", prefix.."combobox_world",           "World" )
localify.Bind( "en", prefix.."combobox_prop",            "Prop" )
localify.Bind( "en", prefix.."combobox_direction_up",    "Up" )
localify.Bind( "en", prefix.."combobox_direction_down",  "Down" )
localify.Bind( "en", prefix.."combobox_direction_front", "Front" )
localify.Bind( "en", prefix.."combobox_direction_back",  "Back" )
localify.Bind( "en", prefix.."combobox_direction_right", "Right" )
localify.Bind( "en", prefix.."combobox_direction_left",  "Left" )
localify.Bind( "en", prefix.."combobox_default",         "Default" )
localify.Bind( "en", prefix.."combobox_sandbox",         "Sandbox" )
localify.Bind( "en", prefix.."combobox_darkrp",          "DarkRP" )
localify.Bind( "en", prefix.."combobox_singleplayer",    "Singleplayer" )
-- HUD
localify.Bind( "en", prefix.."hud_front",                "Front" )
localify.Bind( "en", prefix.."hud_right",                "Right" )
localify.Bind( "en", prefix.."hud_up",                   "Up" )
-- Help
localify.Bind( "en", prefix.."help_max_per_player",      "Maximum stacked props each player is limited to." )
localify.Bind( "en", prefix.."help_max_per_stack",       "Maximum props per stack (left-click)." )
localify.Bind( "en", prefix.."help_delay",               "Delay (in seconds) between each Stacker use (left/right-click)" )
localify.Bind( "en", prefix.."help_max_offsetx",         "Maximum distance between stacked props (X-axis)." )
localify.Bind( "en", prefix.."help_max_offsety",         "Maximum distance between stacked props (Y-axis)." )
localify.Bind( "en", prefix.."help_max_offsetz",         "Maximum distance between stacked props (Z-axis)." )
localify.Bind( "en", prefix.."help_freeze",              "Stacked props are frozen when spawned." )
localify.Bind( "en", prefix.."help_weld",                "Stacked props are welded to each other when spawned." )
localify.Bind( "en", prefix.."help_nocollide",           "Stacked props won't collide with other stacked props." )
localify.Bind( "en", prefix.."help_nocollide_all",       "Stacked props won't collide with anything except players, NPCs, vehicles, and the world." )
localify.Bind( "en", prefix.."help_stayinworld",         "Prevents stacked props from being created outside of the map." )
-- Warnings
localify.Bind( "en", prefix.."warning_max_per_player",   "Primarily for Roleplay gamemodes. For Sandbox gamemodes, this should generally be unlimited (-1)." )
localify.Bind( "en", prefix.."warning_max_offsetx",      "Primarily for Roleplay gamemodes. Don't modify unless you know what you're doing." )
localify.Bind( "en", prefix.."warning_max_offsety",      "Primarily for Roleplay gamemodes. Don't modify unless you know what you're doing." )
localify.Bind( "en", prefix.."warning_max_offsetz",      "Primarily for Roleplay gamemodes. Don't modify unless you know what you're doing." )
localify.Bind( "en", prefix.."warning_freeze",           "For DarkRP." )
localify.Bind( "en", prefix.."warning_weld",             "For DarkRP." )
localify.Bind( "en", prefix.."warning_nocollide",        "For DarkRP." )
localify.Bind( "en", prefix.."warning_nocollide_all",    "DO NOT CHANGE WHILE THE SERVER IS RUNNING. This uses the GM.ShouldCollide hook and is experimental. It works and is guaranteed to stop crashes from Stacker, but needs more testing." )

--[[--------------------------------------------------------------------------
-- Bulgarian Localization
--------------------------------------------------------------------------]]--

-- Tool Settings
localify.Bind( "bg", prefix.."name",                     "Натрупвач - Подобрен" )
localify.Bind( "bg", prefix.."desc",                     "Лесно натрупва еднакви предмети във всяка посока" )
localify.Bind( "bg", prefix.."left",                     "Създай натрупване" )
localify.Bind( "bg", prefix.."shift_left",               "Увеличи размера на натрупването" )
localify.Bind( "bg", prefix.."right",                    "Създай единичен обект" )
localify.Bind( "bg", prefix.."shift_right",              "Намали размера на натрупването" )
localify.Bind( "bg", prefix.."reload",                   "Смени направлението на натрупване" )
localify.Bind( "bg", "Undone_stacker_improved",          "Премахва натрупването на предмет(и)" )
-- Errors
localify.Bind( "bg", prefix.."error_blocked_by_server",  "Сървърът ви е блокирал да променяте тази конзолна променлива" )
localify.Bind( "bg", prefix.."error_not_admin",          "Трябва да бъдете в групата 'admin' за да промените тази конзолна променлива" )
localify.Bind( "bg", prefix.."error_invalid_argument",   "Трябва да въведете валидно число за тази стойност" )
localify.Bind( "bg", prefix.."error_max_per_stack",      "Максималния брой предмети които могат да бъдат натрупани на един път е ограничен до " )
localify.Bind( "bg", prefix.."error_too_quick",          "Използвате натрупвача твърде бързо" )
localify.Bind( "bg", prefix.."error_max_per_player",     "Ограничението за натрупани предмети е достигнато" )
localify.Bind( "bg", prefix.."error_not_in_world",       "Натрупваните предмети трябва да се създават вътре в света" )
localify.Bind( "bg", prefix.."error_max_constraints",    "Не можа да се създаде връзка, най вероятно са свършили слотовете за обекти" )
-- Labels
localify.Bind( "bg", prefix.."label_presets",            "Шаблон на натрупвача: " )
localify.Bind( "bg", prefix.."label_relative",           "Натрупвай спрямо: " )
localify.Bind( "bg", prefix.."label_direction",          "Направление на натрупване: " )
localify.Bind( "bg", prefix.."label_count",              "Размер на натрупване" )
localify.Bind( "bg", prefix.."label_reset_offsets",      "Нулиране на отместването" )
localify.Bind( "bg", prefix.."label_reset_angles",       "Нулиране на ъглите" )
localify.Bind( "bg", prefix.."label_show_settings",      "Цъкнете за показване на настройки" )
localify.Bind( "bg", prefix.."label_hide_settings",      "Цъкнете за скриване на настройки" )
localify.Bind( "bg", prefix.."label_x",                  "Абсциса  (-назад, +напред)" )
localify.Bind( "bg", prefix.."label_y",                  "Ордината  (-ляво, +дясно)" )
localify.Bind( "bg", prefix.."label_z",                  "Апликата  (-долу, +горе)" )
localify.Bind( "bg", prefix.."label_pitch",              "Тангаж  (-долу, +горе)" )
localify.Bind( "bg", prefix.."label_yaw",                "Азимут  (-ляво, +дясно)" )
localify.Bind( "bg", prefix.."label_roll",               "Крен    (-ляво, +дясно)" )
localify.Bind( "bg", prefix.."label_language",           "Език: " )
localify.Bind( "bg", prefix.."label_credits",            "Преведено от: [BG][Sk&Bh]Trick or treat KID!" )
localify.Bind( "bg", prefix.."label_max_per_stack",      "Брой на натрупване" )
localify.Bind( "bg", prefix.."label_max_per_player",     "Брой предмети на играч" )
localify.Bind( "bg", prefix.."label_max_offsetx",        "Максимално отместване по абсциса" )
localify.Bind( "bg", prefix.."label_max_offsety",        "Максимално отместване по ордината" )
localify.Bind( "bg", prefix.."label_max_offsetz",        "Максимално отместване по апликата" )
localify.Bind( "bg", prefix.."label_delay",              "Закъснение" )
localify.Bind( "bg", prefix.."label_opacity",            "Тъмнота" )
-- Checkboxes
localify.Bind( "bg", prefix.."checkbox_freeze",          "Замрази натрупаните предмети" )
localify.Bind( "bg", prefix.."checkbox_weld",            "Завари натрупаните предмети" )
localify.Bind( "bg", prefix.."checkbox_nocollide",       "Не-сблъсък на натрупаните предмети един към друг" )
localify.Bind( "bg", prefix.."checkbox_nocollide_all",   "Не-сблъсък на натрупаните предмети с ВСИЧКО" )
//localify.Bind( "bg", prefix.."checkbox_use_shift_key",   "" )
localify.Bind( "bg", prefix.."checkbox_relative",        "Натрупвай спрямо новата ориентация" )
localify.Bind( "bg", prefix.."checkbox_material",        "Приложи текстура" )
localify.Bind( "bg", prefix.."checkbox_color",           "Приложи цвят" )
localify.Bind( "bg", prefix.."checkbox_physprop",        "Приложи физически свойства" )
localify.Bind( "bg", prefix.."checkbox_ghost",           "Сенки за всички предмети в стека" )
localify.Bind( "bg", prefix.."checkbox_halo",            "Добави ореоли към предметите сенки" )
localify.Bind( "bg", prefix.."checkbox_halo_color",      "Цвят на ореола" )
localify.Bind( "bg", prefix.."checkbox_axis",            "Чертай осите XYZ" )
localify.Bind( "bg", prefix.."checkbox_axis_labels",     "Чертай етикети на XYZ осите" )
localify.Bind( "bg", prefix.."checkbox_axis_angles",     "Чертай ъглите на XYZ осите" )
localify.Bind( "bg", prefix.."checkbox_stayinworld",     "Натрупвай в рамките на света" )
-- Comboboxes
localify.Bind( "bg", prefix.."combobox_world",           "Свят" )
localify.Bind( "bg", prefix.."combobox_prop",            "Предмет" )
localify.Bind( "bg", prefix.."combobox_direction_up",    "Горе" )
localify.Bind( "bg", prefix.."combobox_direction_down",  "Долу" )
localify.Bind( "bg", prefix.."combobox_direction_front", "Отпред" )
localify.Bind( "bg", prefix.."combobox_direction_back",  "Отзад" )
localify.Bind( "bg", prefix.."combobox_direction_right", "Дясно" )
localify.Bind( "bg", prefix.."combobox_direction_left",  "Ляво" )
localify.Bind( "bg", prefix.."combobox_default",         "По подразбиране" )
localify.Bind( "bg", prefix.."combobox_sandbox",         "Пясъчник" )
localify.Bind( "bg", prefix.."combobox_darkrp",          "Ролева игра" )
localify.Bind( "bg", prefix.."combobox_singleplayer",    "Самостоятелна игра" )
-- HUD
localify.Bind( "bg", prefix.."hud_front",                "Отпред" )
localify.Bind( "bg", prefix.."hud_right",                "Дясно" )
localify.Bind( "bg", prefix.."hud_up",                   "Горе" )
-- Help
localify.Bind( "bg", prefix.."help_max_per_player",      "Максимален брой натрупвани предмети до които е ограничен всеки играч" )
localify.Bind( "bg", prefix.."help_max_per_stack",       "Максимален брой предмети при всяко натрупване (ляв клик)." )
localify.Bind( "bg", prefix.."help_delay",               "Закъснение (в секунди) между всяко използване на натрупвача (ляв/десен клик)" )
localify.Bind( "bg", prefix.."help_max_offsetx",         "Максимално разстояние между натрупаните предмети (абсциса)." )
localify.Bind( "bg", prefix.."help_max_offsety",         "Максимално разстояние между натрупаните предмети (ордината)." )
localify.Bind( "bg", prefix.."help_max_offsetz",         "Максимално разстояние между натрупаните предмети (апликата)." )
localify.Bind( "bg", prefix.."help_freeze",              "Натрупваните предмети са замразени при създаване." )
localify.Bind( "bg", prefix.."help_weld",                "Натрупваните предмети са заварени по между си при създаване." )
localify.Bind( "bg", prefix.."help_nocollide",           "Натрупваните предмети няма да се сблъскват с други такива." )
localify.Bind( "bg", prefix.."help_nocollide_all",       "Натрупваните предмети няма да се сблъскват с всичко освен играчи, NPC, превозни средства, и света." )
localify.Bind( "bg", prefix.."help_stayinworld",         "Предотвратява натрупваните обекти да бъдат създавани извън света." )
-- Warnings
localify.Bind( "bg", prefix.."warning_max_per_player",   "Преди всичко за режими на Ролева игра. За режим Пясъчник, това трябва генерално да бъде неограничено (-1)." )
localify.Bind( "bg", prefix.."warning_max_offsetx",      "Преди всичко за режими на Ролева игра. Не модифицирайте ако не знаете какво правите." )
localify.Bind( "bg", prefix.."warning_max_offsety",      "Преди всичко за режими на Ролева игра. Не модифицирайте ако не знаете какво правите." )
localify.Bind( "bg", prefix.."warning_max_offsetz",      "Преди всичко за режими на Ролева игра. Не модифицирайте ако не знаете какво правите." )
localify.Bind( "bg", prefix.."warning_freeze",           "За режим на Ролева игра." )
localify.Bind( "bg", prefix.."warning_weld",             "За режим на Ролева игра." )
localify.Bind( "bg", prefix.."warning_nocollide",        "За режим на Ролева игра." )
localify.Bind( "bg", prefix.."warning_nocollide_all",    "НЕ ПРОМЕНЯЙТЕ ДОКАТО СЪРВЪРА РАБОТИ. Това използва кука /GM.ShouldCollide/ и е експериментално. Работи и с гаранция ще спре крашовете, но се нуждае от още тестване." )

--[[--------------------------------------------------------------------------
-- French Localization
--------------------------------------------------------------------------]]--

-- Paramètres de l'outil
localify.Bind( "fr", prefix.."name",                     "Stacker - Amélioré" )
localify.Bind( "fr", prefix.."desc",                     "Empilez facilement les props dupliqués dans n'importe quelle direction" )
localify.Bind( "fr", prefix.."left",                     "Créer une pile" )
localify.Bind( "fr", prefix.."shift_left",               "Augmenter la taille des piles" )
localify.Bind( "fr", prefix.."right",                    "Créer un seul prop" )
localify.Bind( "fr", prefix.."shift_right",              "Diminuer la taille de la pile" )
localify.Bind( "fr", prefix.."reload",                   "Changer la direction de la pile" )
localify.Bind( "fr", "Undone_stacker_improved",          "Annuler le(s) prop(s) empilé(s)" )
-- Erreurs
localify.Bind( "fr", prefix.."error_blocked_by_server",  "Le serveur vous a empêché de modifier cette variable de console" )
localify.Bind( "fr", prefix.."error_not_admin",          "Vous devez être dans le groupe d'utilisateurs 'admin' pour modifier cette variable de console" )
localify.Bind( "fr", prefix.."error_invalid_argument",   "Vous devez entrer une valeur numérique valide" )
localify.Bind( "fr", prefix.."error_max_per_stack",      "Les props maximum qui peuvent être empilés à la fois sont limités à " )
localify.Bind( "fr", prefix.."error_too_quick",          "Vous utilisez l'empileur trop rapidement" )
localify.Bind( "fr", prefix.."error_max_per_player",     "Limite de l'empileur atteinte" )
localify.Bind( "fr", prefix.."error_not_in_world",       "Les props empilés doivent être engendrés dans le monde" )
localify.Bind( "fr", prefix.."error_max_constraints",    "Échec de la création de la contrainte, très probablement à court d'emplacements d'entité" )
-- Etiquettes
localify.Bind( "fr", prefix.."label_presets",            "Préréglages de l'empileur " )
localify.Bind( "fr", prefix.."label_relative",           "Pile relatif au: " )
localify.Bind( "fr", prefix.."label_direction",          "Direction: " )
localify.Bind( "fr", prefix.."label_count",              "Taille" )
localify.Bind( "fr", prefix.."label_reset_offsets",      "Effacer les décalages" )
localify.Bind( "fr", prefix.."label_reset_angles",       "Effacer les angles" )
localify.Bind( "fr", prefix.."label_show_settings",      "Afficher les paramètres" )
localify.Bind( "fr", prefix.."label_hide_settings",      "Masquer les paramètres" )
localify.Bind( "fr", prefix.."label_x",                  "X  (-derrière, +devant)" )
localify.Bind( "fr", prefix.."label_y",                  "Y  (-gauche, +droite)" )
localify.Bind( "fr", prefix.."label_z",                  "Z  (-bas, +haut)" )
localify.Bind( "fr", prefix.."label_pitch",              "Pitch  (-bas, +haut)" )
localify.Bind( "fr", prefix.."label_yaw",                "Yaw   (-gauche, +droite)" )
localify.Bind( "fr", prefix.."label_roll",               "Roll    (-gauche, +droite)" )
localify.Bind( "fr", prefix.."label_language",           "Langue: " )
localify.Bind( "fr", prefix.."label_credits",            "" )
localify.Bind( "fr", prefix.."label_max_per_stack",      "Taille" )
localify.Bind( "fr", prefix.."label_max_per_player",     "Props par joueur(s)" )
localify.Bind( "fr", prefix.."label_max_offsetx",        "Décalage X maximal" )
localify.Bind( "fr", prefix.."label_max_offsety",        "Décalage Y maximal" )
localify.Bind( "fr", prefix.."label_max_offsetz",        "Décalage Z maximal" )
localify.Bind( "fr", prefix.."label_delay",              "Délai" )
localify.Bind( "fr", prefix.."label_opacity",            "Opacité" )
-- Checkboxes
localify.Bind( "fr", prefix.."checkbox_freeze",          "Geler les props empilés" )
localify.Bind( "fr", prefix.."checkbox_weld",            "Souder les props empilés" )
localify.Bind( "fr", prefix.."checkbox_nocollide",       "No-Collide les props empilés avec les autres" )
localify.Bind( "fr", prefix.."checkbox_nocollide_all",   "No-Collide les props empilés avec TOUT" )
localify.Bind( "fr", prefix.."checkbox_use_shift_key",   "Changer la taille d'empilement avec SHIFT + clic gauche/droite" )
localify.Bind( "fr", prefix.."checkbox_relative",        "Pile par rapport à la nouvelle rotation" )
localify.Bind( "fr", prefix.."checkbox_material",        "Appliquer un matériaux" )
localify.Bind( "fr", prefix.."checkbox_color",           "Appliquer une couleur" )
localify.Bind( "fr", prefix.."checkbox_physprop",        "Appliquer une propriété physique" )
localify.Bind( "fr", prefix.."checkbox_ghost",           "Traverser tout les props dans l'empilement" )
localify.Bind( "fr", prefix.."checkbox_halo",            "Ajouter des halos aux props fantômes" )
localify.Bind( "fr", prefix.."checkbox_halo_color",      "Couleur du halo" )
localify.Bind( "fr", prefix.."checkbox_axis",            "Dessiner l'axe XYZ" )
localify.Bind( "fr", prefix.."checkbox_axis_labels",     "Dessiner des étiquettes d'axe XYZ" )
localify.Bind( "fr", prefix.."checkbox_axis_angles",     "Dessiner des angles d'axe XYZ" )
localify.Bind( "fr", prefix.."checkbox_stayinworld",     "Rester dans le monde" )
-- Comboboxes
localify.Bind( "fr", prefix.."combobox_world",           "Monde" )
localify.Bind( "fr", prefix.."combobox_prop",            "Prop" )
localify.Bind( "fr", prefix.."combobox_direction_up",    "Haut" )
localify.Bind( "fr", prefix.."combobox_direction_down",  "Bas" )
localify.Bind( "fr", prefix.."combobox_direction_front", "Devant" )
localify.Bind( "fr", prefix.."combobox_direction_back",  "Derrière" )
localify.Bind( "fr", prefix.."combobox_direction_right", "Droite" )
localify.Bind( "fr", prefix.."combobox_direction_left",  "Gauche" )
localify.Bind( "fr", prefix.."combobox_default",         "Défaut" )
localify.Bind( "fr", prefix.."combobox_sandbox",         "Sandbox" )
localify.Bind( "fr", prefix.."combobox_darkrp",          "DarkRP" )
localify.Bind( "fr", prefix.."combobox_singleplayer",    "Solo" )
-- HUD
localify.Bind( "fr", prefix.."hud_front",                "Devant" )
localify.Bind( "fr", prefix.."hud_right",                "Droite" )
localify.Bind( "fr", prefix.."hud_up",                   "Haut" )
-- Aide
localify.Bind( "fr", prefix.."help_max_per_player",      "Les props empilés sont limités à chaque joueur." )
localify.Bind( "fr", prefix.."help_max_per_stack",       "Maximum de props par pile (clic gauche)." )
localify.Bind( "fr", prefix.."help_delay",               "Délai (en secondes) entre chaque utilisation de l'Empileur (clic gauche / droit)" )
localify.Bind( "fr", prefix.."help_max_offsetx",         "Distance maximale entre les props empilés (axe X)." )
localify.Bind( "fr", prefix.."help_max_offsety",         "Distance maximale entre les props empilés (axe Y)." )
localify.Bind( "fr", prefix.."help_max_offsetz",         "Distance maximale entre les props empilés (axe Z)." )
localify.Bind( "fr", prefix.."help_freeze",              "Les props empilés sont congelés lorsqu'ils sont spawn." )
localify.Bind( "fr", prefix.."help_weld",                "Les props empilés sont soudés les uns aux autres lors du spawn." )
localify.Bind( "fr", prefix.."help_nocollide",           "Les props empilés ne vont pas entrer en collision avec d'autres props empilés." )
localify.Bind( "fr", prefix.."help_nocollide_all",       "Les props empilés n'entreront en collision avec rien d'autre que les joueurs, les PNJ, les véhicules et le monde." )
localify.Bind( "fr", prefix.."help_stayinworld",         "Empêche la création de props empilés à l'extérieur de la carte." )
-- Attentions
localify.Bind( "fr", prefix.."warning_max_per_player",   "Principalement pour les modes de jeu Roleplay. Pour les modes de jeu Sandbox, cela devrait généralement être illimité (-1)." )
localify.Bind( "fr", prefix.."warning_max_offsetx",      "Principalement pour les modes de jeu Roleplay. Ne modifiez pas à moins de savoir ce que vous faites." )
localify.Bind( "fr", prefix.."warning_max_offsety",      "Principalement pour les modes de jeu Roleplay. Ne modifiez pas à moins de savoir ce que vous faites." )
localify.Bind( "fr", prefix.."warning_max_offsetz",      "Principalement pour les modes de jeu Roleplay. Ne modifiez pas à moins de savoir ce que vous faites." )
localify.Bind( "fr", prefix.."warning_freeze",           "Pour DarkRP." )
localify.Bind( "fr", prefix.."warning_weld",             "Pour DarkRP." )
localify.Bind( "fr", prefix.."warning_nocollide",        "Pour DarkRP." )
localify.Bind( "fr", prefix.."warning_nocollide_all",    "NE PAS CHANGER PENDANT QUE LE SERVEUR FONCTIONNE. Cela utilise le crochet GM.ShouldCollide et est expérimental. Cela fonctionne et est garanti pour arrêter les plantages de Stacker, mais a besoin de plus de tests." )

--[[--------------------------------------------------------------------------
-- Polish Localization
--------------------------------------------------------------------------]]--

-- Tool Settings
localify.Bind( "pl", prefix.."name",                     "Stacker - Ulepszony" )
localify.Bind( "pl", prefix.."desc",                     "Łatwo kopiuj obiekty w dowolnym kierunku" )
localify.Bind( "pl", prefix.."left",                     "Utwórz kopię" )
localify.Bind( "pl", prefix.."shift_left",               "Zwiększ ilość kopii" )
localify.Bind( "pl", prefix.."right",                    "Utwórz pojedyńczy obiekt" )
localify.Bind( "pl", prefix.."shift_right",              "Zmniejsz ilość kopii" )
localify.Bind( "pl", prefix.."reload",                   "Zmień kierunek kopiowania" )
localify.Bind( "pl", "Undone_stacker_improved",          "Cofnięto skopiowany obiekt" )
-- Errors
localify.Bind( "pl", prefix.."error_blocked_by_server",  "Serwer zablokował twoją możliwość zmieniania wartości serwerowych" )
localify.Bind( "pl", prefix.."error_not_admin",          "Musiz być w grupie 'admin' by zmienić tę wartość konsolową" )
localify.Bind( "pl", prefix.."error_invalid_argument",   "Musisz wprowadzić poprawną wartość liczbową" )
localify.Bind( "pl", prefix.."error_max_per_stack",      "Maksymalna ilość kopii jest ograniczona do " )
localify.Bind( "pl", prefix.."error_too_quick",          "Używasz Stackera za szybko" )
localify.Bind( "pl", prefix.."error_max_per_player",     "Osiągnięto limir obiektów dla Stackera" )
localify.Bind( "pl", prefix.."error_not_in_world",       "Skopiowane obiekty nie mogą wychodzić poza mapę" )
localify.Bind( "pl", prefix.."error_max_constraints",    "Nie udało się utworzyć łaczenia, najprawdopodobniej brakuje miejsc na obiekty" )
-- Labels
localify.Bind( "pl", prefix.."label_presets",            "Ustawienia zapisane: " )
localify.Bind( "pl", prefix.."label_relative",           "Kopiowanie względem: " )
localify.Bind( "pl", prefix.."label_direction",          "Kierunek kopiowania: " )
localify.Bind( "pl", prefix.."label_count",              "Ilość kopii" )
localify.Bind( "pl", prefix.."label_reset_offsets",      "Zresetuj przesunięcia" )
localify.Bind( "pl", prefix.."label_reset_angles",       "Zresetuj kąty" )
localify.Bind( "pl", prefix.."label_show_settings",      "Pokaż ustawienia" )
localify.Bind( "pl", prefix.."label_hide_settings",      "Ukryj ustawienia" )
localify.Bind( "pl", prefix.."label_x",                  "X  (-tył, +przód)" )
localify.Bind( "pl", prefix.."label_y",                  "Y  (-lewo, +prawo)" )
localify.Bind( "pl", prefix.."label_z",                  "Z  (-dół, +góra)" )
localify.Bind( "pl", prefix.."label_pitch",              "Pochylenie  (-dół, +góra)" )
localify.Bind( "pl", prefix.."label_yaw",                "Odchylenie   (-lewo, +prawo)" )
localify.Bind( "pl", prefix.."label_roll",               "Przechylenie    (-lewo, +prawo)" )
localify.Bind( "pl", prefix.."label_language",           "Język: " )
localify.Bind( "pl", prefix.."label_credits",            "" )
localify.Bind( "pl", prefix.."label_max_per_stack",      "Ilość kopii" )
localify.Bind( "pl", prefix.."label_max_per_player",     "Ilość obiektów na gracza" )
localify.Bind( "pl", prefix.."label_max_offsetx",        "Max przesunięcie X" )
localify.Bind( "pl", prefix.."label_max_offsety",        "Max przesunięcie Y" )
localify.Bind( "pl", prefix.."label_max_offsetz",        "Max przesunięcie Z" )
localify.Bind( "pl", prefix.."label_delay",              "Opóźnienie" )
localify.Bind( "pl", prefix.."label_opacity",            "Przezroczystość" )
-- Checkboxes
localify.Bind( "pl", prefix.."checkbox_freeze",          "Zamrażaj skopiowane obiekty" )
localify.Bind( "pl", prefix.."checkbox_weld",            "Spawaj skopiowane obiekty" )
localify.Bind( "pl", prefix.."checkbox_nocollide",       "Wyłącz kolizję pomiędzy skopiowanymi obiektami" )
localify.Bind( "pl", prefix.."checkbox_nocollide_all",   "Wyłącz kolizję skopiowanych obiektamów ze WSZYSTKIM" )
localify.Bind( "pl", prefix.."checkbox_use_shift_key",   "Zmień ilość kopii za pomocą SHIFT + lewy/prawy" )
localify.Bind( "pl", prefix.."checkbox_relative",        "Kopiuj względem nowego obrotu" )
localify.Bind( "pl", prefix.."checkbox_material",        "Zastosuj materiał" )
localify.Bind( "pl", prefix.."checkbox_color",           "Zastosuj kolor" )
localify.Bind( "pl", prefix.."checkbox_physprop",        "Zastosuj właściwości fizyczne" )
localify.Bind( "pl", prefix.."checkbox_ghost",           "Dodaj duchy obiektów wszyschich kopii" )
localify.Bind( "pl", prefix.."checkbox_halo",            "Dodaj poświatę do duchów obiektów" )
localify.Bind( "pl", prefix.."checkbox_halo_color",      "Kolor poświaty" )
localify.Bind( "pl", prefix.."checkbox_axis",            "Rysuj oś XYZ" )
localify.Bind( "pl", prefix.."checkbox_axis_labels",     "Rysuj opis osi XYZ" )
localify.Bind( "pl", prefix.."checkbox_axis_angles",     "Rysuj kąty osi XYZ" )
localify.Bind( "pl", prefix.."checkbox_stayinworld",     "Zostań w środku mapy" )
-- Comboboxes
localify.Bind( "pl", prefix.."combobox_world",           "świat" )
localify.Bind( "pl", prefix.."combobox_prop",            "Obiekt" )
localify.Bind( "pl", prefix.."combobox_direction_up",    "Góra" )
localify.Bind( "pl", prefix.."combobox_direction_down",  "Dół" )
localify.Bind( "pl", prefix.."combobox_direction_front", "Przód" )
localify.Bind( "pl", prefix.."combobox_direction_back",  "Tył" )
localify.Bind( "pl", prefix.."combobox_direction_right", "Prawo" )
localify.Bind( "pl", prefix.."combobox_direction_left",  "Lewo" )
localify.Bind( "pl", prefix.."combobox_default",         "Domyślne" )
localify.Bind( "pl", prefix.."combobox_sandbox",         "Sandbox" )
localify.Bind( "pl", prefix.."combobox_darkrp",          "DarkRP" )
localify.Bind( "pl", prefix.."combobox_singleplayer",    "Singleplayer" )
-- HUD
localify.Bind( "pl", prefix.."hud_front",                "Przód" )
localify.Bind( "pl", prefix.."hud_right",                "Prawo" )
localify.Bind( "pl", prefix.."hud_up",                   "Góra" )
-- Help
localify.Bind( "pl", prefix.."help_max_per_player",      "Maksymalna ilość skopiowanych obiektó na gracza to." )
localify.Bind( "pl", prefix.."help_max_per_stack",       "Maksymalna ilość obiektów na kopię (lewy przycisk myszki)." )
localify.Bind( "pl", prefix.."help_delay",               "Opóźnienie (w sekundach) pomiędzy każdym użyciem Stackera (lewy/prawy przycisk)" )
localify.Bind( "pl", prefix.."help_max_offsetx",         "Maksymalny dystans pomiędzy skopiowanymi obiektami (oś X)." )
localify.Bind( "pl", prefix.."help_max_offsety",         "Maksymalny dystans pomiędzy skopiowanymi obiektami (oś Y)." )
localify.Bind( "pl", prefix.."help_max_offsetz",         "Maksymalny dystans pomiędzy skopiowanymi obiektami (oś Z)." )
localify.Bind( "pl", prefix.."help_freeze",              "Skopiowane obiekty są zamrożone." )
localify.Bind( "pl", prefix.."help_weld",                "Skopiowane obiekty są zespawane do siebie." )
localify.Bind( "pl", prefix.."help_nocollide",           "Skopiowane obiekty nie będą kolidowały z innymi skopiowanymi obiektami." )
localify.Bind( "pl", prefix.."help_nocollide_all",       "Skopiowane obiekty nie będą kolidowały ze wszystkim oprócz graczy, NPCs, pojazdów, i mapy." )
localify.Bind( "pl", prefix.."help_stayinworld",         "Nie pozwalaj na tworzenie kopii poza mapą." )
-- Warnings
localify.Bind( "pl", prefix.."warning_max_per_player",   "Głównie dla trybu Roleplay. Dla trybów Sandbox, zazwyczaj powinno być nieograniczone (-1)." )
localify.Bind( "pl", prefix.."warning_max_offsetx",      "Głownie dla tryby Roleplay. Nie zmieniaj, jeśli nie wiesz co robisz." )
localify.Bind( "pl", prefix.."warning_max_offsety",      "Głownie dla tryby Roleplay. Nie zmieniaj, jeśli nie wiesz co robisz." )
localify.Bind( "pl", prefix.."warning_max_offsetz",      "Głownie dla tryby Roleplay. Nie zmieniaj, jeśli nie wiesz co robisz." )
localify.Bind( "pl", prefix.."warning_freeze",           "Dla DarkRP." )
localify.Bind( "pl", prefix.."warning_weld",             "Dla DarkRP." )
localify.Bind( "pl", prefix.."warning_nocollide",        "Dla DarkRP." )
localify.Bind( "pl", prefix.."warning_nocollide_all",    "NIE ZMIENIAJ JEŚLI SERWER JEST WŁĄCZONY. To używa GM.ShouldCollide i jest eksperymentalne. Działa i zapobiega awarii serwera spowodowanymi Stackerem, ale wymaga dalszych testów." )

--[[--------------------------------------------------------------------------
-- Russian Localization
--------------------------------------------------------------------------]]--

-- Tool Settings
localify.Bind( "ru", prefix.."name",                     "Стакер - Улучшенный" )
localify.Bind( "ru", prefix.."desc",                     "Легко дублируйте предметы в любом направлении" )
localify.Bind( "ru", prefix.."left",                     "Стакать" )
localify.Bind( "ru", prefix.."shift_left",               "Увеличить размер стака" )
localify.Bind( "ru", prefix.."right",                    "Создать одиночный предмет" )
localify.Bind( "ru", prefix.."shift_right",              "Уменьшить размер стака" )
localify.Bind( "ru", prefix.."reload",                   "Изменить напраление стака" )
localify.Bind( "ru", "Undone_stacker_improved",          "Отменить стаканные предметы" )
-- Errors
localify.Bind( "ru", prefix.."error_blocked_by_server",  "Сервер заблокировал вас от изменения этой консольной переменной" )
localify.Bind( "ru", prefix.."error_not_admin",          "Вы должны быть в группе админа, чтобы изменить эту консольную переменную" )
localify.Bind( "ru", prefix.."error_invalid_argument",   "Вы должны ввести правильное числовое значение" )
localify.Bind( "ru", prefix.."error_max_per_stack",      "Максимальное количество предметов, которые могут быть стаканы в один момент, ограничено к " )
localify.Bind( "ru", prefix.."error_too_quick",          "Вы используете стакер слишком быстро" )
localify.Bind( "ru", prefix.."error_max_per_player",     "Достигнуто максимальное количество предметов" )
localify.Bind( "ru", prefix.."error_not_in_world",       "Стаканные предметы должны появляться в мире" )
localify.Bind( "ru", prefix.."error_max_constraints",    "Не удалось создать соединение, скорее всего, закончились слоты сущностей" )
-- Labels
localify.Bind( "ru", prefix.."label_presets",            "Готовые настройки стака: " )
localify.Bind( "ru", prefix.."label_relative",           "Стак относителен к: " )
localify.Bind( "ru", prefix.."label_direction",          "Направление стака: " )
localify.Bind( "ru", prefix.."label_count",              "Размер стака" )
localify.Bind( "ru", prefix.."label_reset_offsets",      "Сбросить отклонения" )
localify.Bind( "ru", prefix.."label_reset_angles",       "Сбросить углы" )
localify.Bind( "ru", prefix.."label_show_settings",      "Показать настройки" )
localify.Bind( "ru", prefix.."label_hide_settings",      "Спрятать настройки" )
localify.Bind( "ru", prefix.."label_x",                  "X  (-сзади, +спереди)" )
localify.Bind( "ru", prefix.."label_y",                  "Y  (-слева, +справа)" )
localify.Bind( "ru", prefix.."label_z",                  "Z  (-снизу, +сверху)" )
localify.Bind( "ru", prefix.."label_pitch",              "Pitch  (-снизу, +сверху)" )
localify.Bind( "ru", prefix.."label_yaw",                "Yaw   (-слева, +справа)" )
localify.Bind( "ru", prefix.."label_roll",               "Roll    (-слева, +справа)" )
localify.Bind( "ru", prefix.."label_language",           "Язык: " )
localify.Bind( "ru", prefix.."label_credits",            "Переведено от SupinePandora43" )
localify.Bind( "ru", prefix.."label_max_per_stack",      "Размер стака" )
localify.Bind( "ru", prefix.."label_max_per_player",     "Количество предметов игрока" )
localify.Bind( "ru", prefix.."label_max_offsetx",        "Максимальное X отклонение" )
localify.Bind( "ru", prefix.."label_max_offsety",        "Максимальное Y отклонение" )
localify.Bind( "ru", prefix.."label_max_offsetz",        "Максимальное Z отклонение" )
localify.Bind( "ru", prefix.."label_delay",              "Задержка" )
localify.Bind( "ru", prefix.."label_opacity",            "Непрозрачность" )
-- Checkboxes
localify.Bind( "ru", prefix.."checkbox_freeze",          "Заморозить стаканные предметы" )
localify.Bind( "ru", prefix.."checkbox_weld",            "Сварить стаканные предметы" )
localify.Bind( "ru", prefix.."checkbox_nocollide",       "Отключить столкновения стаканных предметов друг с другом" )
localify.Bind( "ru", prefix.."checkbox_nocollide_all",   "Отключить столкновения стаканных предметов со ВСЕМ" )
localify.Bind( "ru", prefix.."checkbox_use_shift_key",   "Изменить размер стака с SHIFT + ЛКМ/ПКМ" )
localify.Bind( "ru", prefix.."checkbox_relative",        "Стак относителен нового поворота" )
localify.Bind( "ru", prefix.."checkbox_material",        "Применить материал" )
localify.Bind( "ru", prefix.."checkbox_color",           "Применить цвет" )
localify.Bind( "ru", prefix.."checkbox_physprop",        "Применить физические свойства" )
localify.Bind( "ru", prefix.."checkbox_ghost",           "Призрачные все предметы в стаке" )
localify.Bind( "ru", prefix.."checkbox_halo",            "Добавить обводку к призрачным предметам" )
localify.Bind( "ru", prefix.."checkbox_halo_color",      "Цвет обводки" )
localify.Bind( "ru", prefix.."checkbox_axis",            "Отрисовывать XYZ ось" )
localify.Bind( "ru", prefix.."checkbox_axis_labels",     "Отрисовывать XYZ названия осей " )
localify.Bind( "ru", prefix.."checkbox_axis_angles",     "Отрисовывать XYZ углы оси" )
localify.Bind( "ru", prefix.."checkbox_stayinworld",     "Оставаться в мире" )
-- Comboboxes
localify.Bind( "ru", prefix.."combobox_world",           "Мир" )
localify.Bind( "ru", prefix.."combobox_prop",            "Предмет" )
localify.Bind( "ru", prefix.."combobox_direction_up",    "Верх" )
localify.Bind( "ru", prefix.."combobox_direction_down",  "Низ" )
localify.Bind( "ru", prefix.."combobox_direction_front", "Перед" )
localify.Bind( "ru", prefix.."combobox_direction_back",  "Зад" )
localify.Bind( "ru", prefix.."combobox_direction_right", "Право" )
localify.Bind( "ru", prefix.."combobox_direction_left",  "Лево" )
localify.Bind( "ru", prefix.."combobox_default",         "По умолчанию" )
localify.Bind( "ru", prefix.."combobox_sandbox",         "Sandbox" )
localify.Bind( "ru", prefix.."combobox_darkrp",          "DarkRP" )
localify.Bind( "ru", prefix.."combobox_singleplayer",    "Одиночная игра" )
-- HUD
localify.Bind( "ru", prefix.."hud_front",                "Перед" )
localify.Bind( "ru", prefix.."hud_right",                "Право" )
localify.Bind( "ru", prefix.."hud_up",                   "Верх" )
-- Help
localify.Bind( "ru", prefix.."help_max_per_player",      "Максимальное количество предметов, которые могут быть стаканы в один момент." )
localify.Bind( "ru", prefix.."help_max_per_stack",       "Максимальное количество предметов в стаке (ЛКМ)." )
localify.Bind( "ru", prefix.."help_delay",               "Задержка (в секундах) между каждым использыванием стакера (ЛКМ/ПКМ)" )
localify.Bind( "ru", prefix.."help_max_offsetx",         "Максимальная дистанция между стаканными предметами (X-ось)." )
localify.Bind( "ru", prefix.."help_max_offsety",         "Максимальная дистанция между стаканными предметами (Y-ось)." )
localify.Bind( "ru", prefix.."help_max_offsetz",         "Максимальная дистанция между стаканными предметами (Z-ось)." )
localify.Bind( "ru", prefix.."help_freeze",              "Заморозить стаканные предметы при спавне." )
localify.Bind( "ru", prefix.."help_weld",                "Сварить стаканные предметы друг к другу при спавне." )
localify.Bind( "ru", prefix.."help_nocollide",           "Стаканные предметы не будут сталкиваться друг с другом." )
localify.Bind( "ru", prefix.."help_nocollide_all",       "Отключить столкновения для стаканных предметов." )
localify.Bind( "ru", prefix.."help_stayinworld",         "Предотвращает создание стака за пределами мира." )
-- Warnings
localify.Bind( "ru", prefix.."warning_max_per_player",   "В основном для RolePlay игровых режимов. Для SandBox игровых режимов, это должно быть неограничено (-1)." )
localify.Bind( "ru", prefix.."warning_max_offsetx",      "В основном для RolePlay игровых режимов. Не изменяйте, если не знаете что делаете." )
localify.Bind( "ru", prefix.."warning_max_offsety",      "В основном для RolePlay игровых режимов. Не изменяйте, если не знаете что делаете." )
localify.Bind( "ru", prefix.."warning_max_offsetz",      "В основном для RolePlay игровых режимов. Не изменяйте, если не знаете что делаете." )
localify.Bind( "ru", prefix.."warning_freeze",           "Для DarkRP." )
localify.Bind( "ru", prefix.."warning_weld",             "Для DarkRP." )
localify.Bind( "ru", prefix.."warning_nocollide",        "Для DarkRP." )
localify.Bind( "ru", prefix.."warning_nocollide_all",    "НЕ ИЗМЕНЯЙТЕ ВО ВРЕМЯ РАБОТЫ СЕРВЕРА. Это использует экспериментальный GM.ShouldCollide. Это работает и гарантированно предотвращает сбои в Stacker, но требует дополнительного тестирования." )

--[[--------------------------------------------------------------------------
-- Russian Localization
--------------------------------------------------------------------------]]--

-- Tool Settings
localify.Bind( "zh-cn", prefix.."name",                     "叠加器 - 改进" )
localify.Bind( "zh-cn", prefix.."desc",                     "轻易在任何方向复制物品" )
localify.Bind( "zh-cn", prefix.."left",                     "进行一次叠加" )
localify.Bind( "zh-cn", prefix.."shift_left",               "增加叠加大小" )
localify.Bind( "zh-cn", prefix.."right",                    "叠加单个物品" )
localify.Bind( "zh-cn", prefix.."shift_right",              "减少叠加大小" )
localify.Bind( "zh-cn", prefix.."reload",                   "改变叠加方向" )
localify.Bind( "zh-cn", "Undone_stacker_improved",          "撤回叠加物品" )
-- Errors
localify.Bind( "zh-cn", prefix.."error_blocked_by_server",  "服务器禁止你修改这个控制台参数" )
localify.Bind( "zh-cn", prefix.."error_not_admin",          "你必须是管理员才能修改这个控制台参数" )
localify.Bind( "zh-cn", prefix.."error_invalid_argument",   "你必须输入一个合法数字" )
localify.Bind( "zh-cn", prefix.."error_max_per_stack",      "单次叠加物品的上限是 " )
localify.Bind( "zh-cn", prefix.."error_too_quick",          "你叠加器使用得太快了" )
localify.Bind( "zh-cn", prefix.."error_max_per_player",     "叠加器达到了物品上限" )
localify.Bind( "zh-cn", prefix.."error_not_in_world",       "叠加的物品必须生成在地图内部" )
localify.Bind( "zh-cn", prefix.."error_max_constraints",    "约束生成失败，很可能是达到了实体上限" )
-- Labels
localify.Bind( "zh-cn", prefix.."label_presets",            "叠加器预设：" )
localify.Bind( "zh-cn", prefix.."label_relative",           "叠加相对方向：" )
localify.Bind( "zh-cn", prefix.."label_direction",          "叠加方向：" )
localify.Bind( "zh-cn", prefix.."label_count",              "叠加大小：" )
localify.Bind( "zh-cn", prefix.."label_reset_offsets",      "重置位差" )
localify.Bind( "zh-cn", prefix.."label_reset_angles",       "重置角度" )
localify.Bind( "zh-cn", prefix.."label_show_settings",      "点击显示设置" )
localify.Bind( "zh-cn", prefix.."label_hide_settings",      "点击隐藏设置" )
localify.Bind( "zh-cn", prefix.."label_x",                  "X  (-后, +前)" )
localify.Bind( "zh-cn", prefix.."label_y",                  "Y  (-左, +右)" )
localify.Bind( "zh-cn", prefix.."label_z",                  "Z  (-下, +上)" )
localify.Bind( "zh-cn", prefix.."label_pitch",              "Pitch  (-下, +上)" )
localify.Bind( "zh-cn", prefix.."label_yaw",                "Yaw    (-左, +右)" )
localify.Bind( "zh-cn", prefix.."label_roll",               "Roll    (-左, +右)" )
localify.Bind( "zh-cn", prefix.."label_language",           "语言: " )
localify.Bind( "zh-cn", prefix.."label_credits",            "翻译： 8Z (STEAM_0:0:33380074)" )
localify.Bind( "zh-cn", prefix.."label_max_per_stack",      "单次叠加上限" )
localify.Bind( "zh-cn", prefix.."label_max_per_player",     "玩家叠加物品上限" )
localify.Bind( "zh-cn", prefix.."label_max_offsetx",        "最大 X 位差" )
localify.Bind( "zh-cn", prefix.."label_max_offsety",        "最大 Y 位差" )
localify.Bind( "zh-cn", prefix.."label_max_offsetz",        "最大 Z 位差" )
localify.Bind( "zh-cn", prefix.."label_delay",              "冷却" )
localify.Bind( "zh-cn", prefix.."label_opacity",            "透明度" )
-- Checkboxes
localify.Bind( "zh-cn", prefix.."checkbox_freeze",          "固定叠加物品" )
localify.Bind( "zh-cn", prefix.."checkbox_weld",            "焊接叠加物品" )
localify.Bind( "zh-cn", prefix.."checkbox_nocollide",       "叠加互相无碰撞" )
localify.Bind( "zh-cn", prefix.."checkbox_nocollide_all",   "叠加全部无碰撞" )
localify.Bind( "zh-cn", prefix.."checkbox_use_shift_key",   "更改叠加大小使用 SHIFT+左键/右键" )
localify.Bind( "zh-cn", prefix.."checkbox_relative",        "叠加使用新物品的相对角度" )
localify.Bind( "zh-cn", prefix.."checkbox_material",        "应用材质" )
localify.Bind( "zh-cn", prefix.."checkbox_color",           "应用颜色" )
localify.Bind( "zh-cn", prefix.."checkbox_physprop",        "应用物理特性" )
localify.Bind( "zh-cn", prefix.."checkbox_ghost",           "所有叠加物品显示预览" )
localify.Bind( "zh-cn", prefix.."checkbox_halo",            "物品预览光环效果" )
localify.Bind( "zh-cn", prefix.."checkbox_halo_color",      "光环颜色" )
localify.Bind( "zh-cn", prefix.."checkbox_axis",            "显示 XYZ 轴" )
localify.Bind( "zh-cn", prefix.."checkbox_axis_labels",     "显示 XYZ 轴标签" )
localify.Bind( "zh-cn", prefix.."checkbox_axis_angles",     "显示 XYZ 轴角度" )
localify.Bind( "zh-cn", prefix.."checkbox_stayinworld",     "叠加限定在地图内部" )
-- Comboboxes
localify.Bind( "zh-cn", prefix.."combobox_world",           "世界" )
localify.Bind( "zh-cn", prefix.."combobox_prop",            "物品" )
localify.Bind( "zh-cn", prefix.."combobox_direction_up",    "上" )
localify.Bind( "zh-cn", prefix.."combobox_direction_down",  "下" )
localify.Bind( "zh-cn", prefix.."combobox_direction_front", "前" )
localify.Bind( "zh-cn", prefix.."combobox_direction_back",  "后" )
localify.Bind( "zh-cn", prefix.."combobox_direction_right", "右" )
localify.Bind( "zh-cn", prefix.."combobox_direction_left",  "左" )
localify.Bind( "zh-cn", prefix.."combobox_default",         "默认" )
localify.Bind( "zh-cn", prefix.."combobox_sandbox",         "沙盘" )
localify.Bind( "zh-cn", prefix.."combobox_darkrp",          "DarkRP" )
localify.Bind( "zh-cn", prefix.."combobox_singleplayer",    "单人" )
-- HUD
localify.Bind( "zh-cn", prefix.."hud_front",                "前" )
localify.Bind( "zh-cn", prefix.."hud_right",                "右" )
localify.Bind( "zh-cn", prefix.."hud_up",                   "上" )
-- Help
localify.Bind( "zh-cn", prefix.."help_max_per_player",      "每个玩家堆叠物品的数量上限。" )
localify.Bind( "zh-cn", prefix.."help_max_per_stack",       "单次堆叠（左键）时的物品上限。" )
localify.Bind( "zh-cn", prefix.."help_delay",               "每次使用堆叠器（左键/右键）后的冷却。" )
localify.Bind( "zh-cn", prefix.."help_max_offsetx",         "叠加物品间的最大位差（X轴）。" )
localify.Bind( "zh-cn", prefix.."help_max_offsety",         "叠加物品间的最大位差（Y轴）。" )
localify.Bind( "zh-cn", prefix.."help_max_offsetz",         "叠加物品间的最大位差（Z轴）。" )
localify.Bind( "zh-cn", prefix.."help_freeze",              "叠加的物品刷出后固定。" )
localify.Bind( "zh-cn", prefix.."help_weld",                "叠加的物品刷出后互相焊接。" )
localify.Bind( "zh-cn", prefix.."help_nocollide",           "叠加的物品和其他叠加物品无碰撞。" )
localify.Bind( "zh-cn", prefix.."help_nocollide_all",       "叠加的物品只会和玩家，NPC，车辆和世界碰撞。" )
localify.Bind( "zh-cn", prefix.."help_stayinworld",         "避免叠加的物品刷出在地图外部。" )
-- Warnings
localify.Bind( "zh-cn", prefix.."warning_max_per_player",   "主要用于角色扮演模式的设置。沙盘模式下这个应该是无限的（-1）。" )
localify.Bind( "zh-cn", prefix.."warning_max_offsetx",      "主要用于角色扮演模式的设置。如果你不确定这是什么，不要修改。" )
localify.Bind( "zh-cn", prefix.."warning_max_offsety",      "主要用于角色扮演模式的设置。如果你不确定这是什么，不要修改。" )
localify.Bind( "zh-cn", prefix.."warning_max_offsetz",      "主要用于角色扮演模式的设置。如果你不确定这是什么，不要修改。" )
localify.Bind( "zh-cn", prefix.."warning_freeze",           "提供给 DarkRP 的设置。" )
localify.Bind( "zh-cn", prefix.."warning_weld",             "提供给 DarkRP 的设置。" )
localify.Bind( "zh-cn", prefix.."warning_nocollide",        "提供给 DarkRP 的设置。" )
localify.Bind( "zh-cn", prefix.."warning_nocollide_all",    "绝对不要在服务器运作时修改！这个实验性的功能调用 GM.ShouldCollide。这个设置管用且必定能够避免叠加器崩服，但需要更多的测试。" )

--[[--------------------------------------------------------------------------
-- German Localization
--------------------------------------------------------------------------]]--

-- Tool Settings
localify.Bind( "de", prefix.."name",                     "Stapler - Verbessert" )
localify.Bind( "de", prefix.."desc",                     "Einfaches Stapeln von duplizierten Props in jede Richtung" )
localify.Bind( "de", prefix.."left",                     "Stapel erstellen" )
localify.Bind( "de", prefix.."shift_left",               "Stapelgröße erhöhen" )
localify.Bind( "de", prefix.."right",                    "Einzelnes Prop erstellen" )
localify.Bind( "de", prefix.."shift_right",              "Stapelgröße verkleinern" )
localify.Bind( "de", prefix.."reload",                   "Stapelrichtung ändern" )
localify.Bind( "de", "Undone_stacker_improved",          "Gestapelte Prop(s) rückgängig machen" )
-- Errors
localify.Bind( "de", prefix.."error_blocked_by_server",  "Der Server hat dich daran gehindert, diese Konsolenvariable zu ändern" )
localify.Bind( "de", prefix.."error_not_admin",          "Du musst dich in der Benutzergruppe 'admin' befinden, um diese Konsolenvariable zu ändern" )
localify.Bind( "de", prefix.."error_invalid_argument",   "Du musst einen gültigen Zahlenwert eingeben" )
localify.Bind( "de", prefix.."error_max_per_stack",      "Die maximale Anzahl von Props, die auf einmal gestapelt werden können, ist begrenzt auf " )
localify.Bind( "de", prefix.."error_too_quick",          "Du verwendest den Stapler zu schnell" )
localify.Bind( "de", prefix.."error_max_per_player",     "Stapler prop limit erreicht" )
localify.Bind( "de", prefix.."error_not_in_world",       "Gestapelte Props müssen innerhalb der Welt gespawnt werden" )
localify.Bind( "de", prefix.."error_max_constraints",    "Constraint konnte nicht erstellt werden ")
-- Labels
localify.Bind( "de", prefix.."label_presets",            "Stapler-Voreinstellungen: " )
localify.Bind( "de", prefix.."label_relative",           "Stapel relativ zu: " )
localify.Bind( "de", prefix.."label_direction",          "Stapelrichtung: " )
localify.Bind( "de", prefix.."label_count",              "Stapelgröße" )
localify.Bind( "de", prefix.."label_reset_offsets",      "Versätze zurücksetzen" )
localify.Bind( "de", prefix.."label_reset_angles",       "Winkel zurücksetzen" )
localify.Bind( "de", prefix.."label_show_settings",      "Zum Anzeigen der Einstellungen anklicken" )
localify.Bind( "de", prefix.."label_hide_settings",      "Zum Verstecken der Einstellungen anklicken" )
localify.Bind( "de", prefix.."label_x",                  "X  (-Hinten, +Vorne)" )
localify.Bind( "de", prefix.."label_y",                  "Y  (-Links, +Rechts)" )
localify.Bind( "de", prefix.."label_z",                  "Z  (-Runter, +Hoch)" )
localify.Bind( "de", prefix.."label_pitch",              "Nicken  (-Runter, +Hoch)" )
localify.Bind( "de", prefix.."label_yaw",                "Gieren   (-Links, +Rechts)" )
localify.Bind( "de", prefix.."label_roll",               "Roll    (-Links, +Rechts)" )
localify.Bind( "de", prefix.."label_language",           "Sprache: " )
localify.Bind( "de", prefix.."label_credits",            "" )
localify.Bind( "de", prefix.."label_max_per_stack",      "Stapelgröße" )
localify.Bind( "de", prefix.."label_max_per_player",     "Props je Spieler" )
localify.Bind( "de", prefix.."label_max_offsetx",        "Maximaler X-Offset" )
localify.Bind( "de", prefix.."label_max_offsety",        "Maximaler Y-Offset" )
localify.Bind( "de", prefix.."label_max_offsetz",        "Maximaler Z-Offset" )
localify.Bind( "de", prefix.."label_delay",              "Delay/Verzögerung" )
localify.Bind( "de", prefix.."label_opacity",            "Deckkraft" )
-- Checkboxes
localify.Bind( "de", prefix.."checkbox_freeze",          "Einfrieren gestapelter Props" )
localify.Bind( "de", prefix.."checkbox_weld",            "Verbinde gestapelte Props" )
localify.Bind( "de", prefix.."checkbox_nocollide",       "Keine-Kollision der gestapelte Props mit einander" )
localify.Bind( "de", prefix.."checkbox_nocollide_all",   "Keine-Kollision der gestapelte Props mit ALLEM" )
localify.Bind( "de", prefix.."checkbox_use_shift_key",   "Stapelgröße mit SHIFT + Links-/Rechtsklick ändern" )
localify.Bind( "de", prefix.."checkbox_relative",        "Stapel relativ zur neuen Drehung" )
localify.Bind( "de", prefix.."checkbox_material",        "Material anwenden" )
localify.Bind( "de", prefix.."checkbox_color",           "Farbe anwenden" )
localify.Bind( "de", prefix.."checkbox_physprop",        "Physikalische Eigenschaften anwenden" )
localify.Bind( "de", prefix.."checkbox_ghost",           "Ghoste alle Props im Stapel" )
localify.Bind( "de", prefix.."checkbox_halo",            "Halos zu geghosteten Props hinzufügen" )
localify.Bind( "de", prefix.."checkbox_halo_color",      "Halo-Farbe" )
localify.Bind( "de", prefix.."checkbox_axis",            "XYZ-Achse zeigen" )
localify.Bind( "de", prefix.."checkbox_axis_labels",     "XYZ-Achsenbeschriftungen zeigen" )
localify.Bind( "de", prefix.."checkbox_axis_angles",     "XYZ-Achsenwinkel zeigen" )
localify.Bind( "de", prefix.."checkbox_stayinworld",     "In der Welt bleiben" )
-- Comboboxes
localify.Bind( "de", prefix.."combobox_world",           "Welt" )
localify.Bind( "de", prefix.."combobox_prop",            "Prop" )
localify.Bind( "de", prefix.."combobox_direction_up",    "Hoch" )
localify.Bind( "de", prefix.."combobox_direction_down",  "Runter" )
localify.Bind( "de", prefix.."combobox_direction_front", "Vorne" )
localify.Bind( "de", prefix.."combobox_direction_back",  "Hinten" )
localify.Bind( "de", prefix.."combobox_direction_right", "Rechts" )
localify.Bind( "de", prefix.."combobox_direction_left",  "Links" )
localify.Bind( "de", prefix.."combobox_default",         "Standard" )
localify.Bind( "de", prefix.."combobox_sandbox",         "Sandbox" )
localify.Bind( "de", prefix.."combobox_darkrp",          "DarkRP" )
localify.Bind( "de", prefix.."combobox_singleplayer",    "Singleplayer" )
-- HUD
localify.Bind( "de", prefix.."hud_front",                "Vorne" )
localify.Bind( "de", prefix.."hud_right",                "Rechts" )
localify.Bind( "de", prefix.."hud_up",                   "Hoch" )
-- Help
localify.Bind( "de", prefix.."help_max_per_player",      "Die maximale Anzahl gestapelter Props pro Spieler ist begrenzt." )
localify.Bind( "de", prefix.."help_max_per_stack",       "Maximale Props pro Stapel (Linksklick)." )
localify.Bind( "de", prefix.."help_delay",               "Verzögerung (in Sekunden) zwischen jeder Stacker-Verwendung (Links-/Rechtsklick)" )
localify.Bind( "de", prefix.."help_max_offsetx",         "Maximaler Abstand zwischen gestapelten Props (X-Achse)." )
localify.Bind( "de", prefix.."help_max_offsety",         "Maximaler Abstand zwischen gestapelten Props (Y-Achse)." )
localify.Bind( "de", prefix.."help_max_offsetz",         "Maximaler Abstand zwischen gestapelten Props (Z-Achse)." )
localify.Bind( "de", prefix.."help_freeze",              "Gestapelte Props werden beim Spawnen eingefroren." )
localify.Bind( "de", prefix.."help_weld",                "Gestapelte Stützen werden beim Spawnen aneinander verbunden." )
localify.Bind( "de", prefix.."help_nocollide",           "Gestapelte Props kollidieren nicht mit anderen gestapelten Props." )
localify.Bind( "de", prefix.."help_nocollide_all",       "Gestapelte Props kollidieren mit nichts außer Spielern, NPCs, Fahrzeugen und der Welt." )
localify.Bind( "de", prefix.."help_stayinworld",         "Verhindert, dass gestapelte Props außerhalb der Map erstellt werden." )
-- Warnings
localify.Bind( "de", prefix.."warning_max_per_player",   "In erster Linie für Rollenspiel-Gamemodi. Für Sandbox-Gamemodes sollte dies generell unbegrenzt sein (-1)." )
localify.Bind( "de", prefix.."warning_max_offsetx",      "In erster Linie für Rollenspiel-Gamemodi. Ändern Sie nichts, wenn Sie nicht wissen, was Sie tun." )
localify.Bind( "de", prefix.."warning_max_offsety",      "In erster Linie für Rollenspiel-Gamemodi. Ändern Sie nichts, wenn Sie nicht wissen, was Sie tun." )
localify.Bind( "de", prefix.."warning_max_offsetz",      "In erster Linie für Rollenspiel-Gamemodi. Ändern Sie nichts, wenn Sie nicht wissen, was Sie tun." )
localify.Bind( "de", prefix.."warning_freeze",           "Für DarkRP." )
localify.Bind( "de", prefix.."warning_weld",             "Für DarkRP." )
localify.Bind( "de", prefix.."warning_nocollide",        "Für DarkRP." )
localify.Bind( "de", prefix.."warning_nocollide_all",    "ÄNDERE NICHTS, WÄHREND DER SERVER AUSGEFÜHRT WIRD. Dies verwendet den GM.ShouldCollide-Hook und ist experimentell. Es funktioniert und verhindert garantiert Abstürze von Stacker, muss aber noch weiter getestet werden." )

--[[--------------------------------------------------------------------------
-- Turkish Localization
-- Big thanks to Matt (STEAM_0:1:241718138) for these translations!
--------------------------------------------------------------------------]]--

-- Tool Settings
localify.Bind( "tr", prefix.."name",                     "Geliştirilmiş Yığıcı" )
localify.Bind( "tr", prefix.."desc",                     "Kopyalanan nesneleri herhangi bir yönde kolayca yığın" )
localify.Bind( "tr", prefix.."left",                     "Bir yığın oluştur" )
localify.Bind( "tr", prefix.."shift_left",               "Yığın boyutunu artır" )
localify.Bind( "tr", prefix.."right",                    "Tek bir nesne oluştur" )
localify.Bind( "tr", prefix.."shift_right",              "Yığın boyutunu azalt" )
localify.Bind( "tr", prefix.."reload",                   "Yığın yönünü değiştir" )
localify.Bind( "tr", "Undone_stacker_improved",          "Yığınlanmış nesne(ler) geri alındı" )
-- Errors                                              
localify.Bind( "tr", prefix.."error_blocked_by_server",  "Sunucu bu konsol değişkenini değiştirmenizi engelledi" )
localify.Bind( "tr", prefix.."error_not_admin",          "Bu konsol değişkenini değiştirmek için 'admin' kullanıcı grubunda olmanız gerekir" )
localify.Bind( "tr", prefix.."error_invalid_argument",   "Geçerli bir sayı değeri girmelisiniz" )
localify.Bind( "tr", prefix.."error_max_count",          "Bir kerede yığılabilecek maksimum nesne sayısı sınırlıdır" )
localify.Bind( "tr", prefix.."error_too_quick",          "Yığınlayıcıyı çok hızlı kullanıyorsunuz" )
localify.Bind( "tr", prefix.."error_max_total",          "Yığınlayıcı destek sınırına ulaşıldı" )
localify.Bind( "tr", prefix.."error_not_in_world",       "Yığılmış nesneler dünya içinde oluşturulmalıdır" )
localify.Bind( "tr", prefix.."error_max_constraints",    "Kısıtlama oluşturulamadı, büyük olasılıkla varlık yuvaları tükendi" )
-- Labels                                              
localify.Bind( "tr", prefix.."label_presets",            "Yığınlayıcı Ön Ayarları: " )
localify.Bind( "tr", prefix.."label_relative",           "Göreceli yığın: " )
localify.Bind( "tr", prefix.."label_direction",          "Yığın yönü: " )
localify.Bind( "tr", prefix.."label_count",              "Yığın boyutu" )
localify.Bind( "tr", prefix.."label_reset_offsets",      "Ofsetleri sıfırla" )
localify.Bind( "tr", prefix.."label_reset_angles",       "Açıları sıfırla" )
localify.Bind( "tr", prefix.."label_show_settings",      "Ayarları göstermek için tıklayın" )
localify.Bind( "tr", prefix.."label_hide_settings",      "Ayarları gizlemek için tıklayın" )
localify.Bind( "tr", prefix.."label_x",                  "X (-arka, +ön)" )
localify.Bind( "tr", prefix.."label_y",                  "E (-sol, +sağ)" )
localify.Bind( "tr", prefix.."label_z",                  "Z (-aşağı, +yukarı)" )
localify.Bind( "tr", prefix.."label_pitch",              "Pitch (-aşağı, +yukarı)" )
localify.Bind( "tr", prefix.."label_yaw",                "Yaw (-sol, +sağ)" )
localify.Bind( "tr", prefix.."label_roll",               "Döndür (-sola, +sağa)" )
localify.Bind( "tr", prefix.."label_language",           "Dil: Türkçe" )
localify.Bind( "tr", prefix.."label_credits",            "Türkçeye Matt tarafından çevrilmiştir (STEAM_0:1:241718138)" )
localify.Bind( "tr", prefix.."label_max_per_stack",      "Yığın boyutu" )
localify.Bind( "tr", prefix.."label_max_per_player",     "Oyuncu başına nesne" )
localify.Bind( "tr", prefix.."label_max_offsetx",        "Maksimum X ofseti" ) 
localify.Bind( "tr", prefix.."label_max_offsety",        "Maksimum Y ofseti" )
localify.Bind( "tr", prefix.."label_max_offsetz",        "Maksimum Z ofseti" )
localify.Bind( "tr", prefix.."label_delay",              "Gecikme" )
localify.Bind( "tr", prefix.."label_opacity",            "Opaklık" )
-- Checkboxes                                          
localify.Bind( "tr", prefix.."checkbox_freeze",          "Yığınlanmış nesneleri dondur" )
localify.Bind( "tr", prefix.."checkbox_weld",            "Yığılmış nesneleri yapıştır" )
localify.Bind( "tr", prefix.."checkbox_nocollide",       "Yığılmış nesnelerin birbirine çarpmasını engelle" )
localify.Bind( "tr", prefix.."checkbox_nocollide_all",   "Yığılmış nesnelerin her şey ile çarpışmasını engelle" )
localify.Bind( "tr", prefix.."checkbox_use_shift_key",   "SHIFT + sol/sağ tıklamayla yığın boyutunu değiştir" )
localify.Bind( "tr", prefix.."checkbox_relative",        "Yeni rotasyona göre yığın" )
localify.Bind( "tr", prefix.."checkbox_material",        "Materyali uygula" )
localify.Bind( "tr", prefix.."checkbox_color",           "Renk uygula" )
localify.Bind( "tr", prefix.."checkbox_physprop",        "Fiziksel özellikleri uygula" )
localify.Bind( "tr", prefix.."checkbox_ghost",           "Yığındaki tüm nesneleri gizle" )
localify.Bind( "tr", prefix.."checkbox_halo",            "Gizlenmiş nesnelere ışık halkası ekle" )
localify.Bind( "tr", prefix.."checkbox_halo_color",      "Işık halkası rengi" )
localify.Bind( "tr", prefix.."checkbox_axis",            "XYZ eksenini çiz" )
localify.Bind( "tr", prefix.."checkbox_axis_labels",     "XYZ eksen etiketlerini çizin" )
localify.Bind( "tr", prefix.."checkbox_axis_angles",     "XYZ eksen açılarını çiz" )
localify.Bind( "tr", prefix.."checkbox_stayinworld",     "Dünyada kal" )
-- Comboboxes                                          
localify.Bind( "tr", prefix.."combobox_world",           "Dünya" )
localify.Bind( "tr", prefix.."combobox_prop",            "Nesne" )
localify.Bind( "tr", prefix.."combobox_direction_up",    "Yukarı" )
localify.Bind( "tr", prefix.."combobox_direction_down",  "Aşağı" )
localify.Bind( "tr", prefix.."combobox_direction_front", "Ön" )
localify.Bind( "tr", prefix.."combobox_direction_back",  "Geri" )
localify.Bind( "tr", prefix.."combobox_direction_right", "Sağ" )
localify.Bind( "tr", prefix.."combobox_direction_left",  "Sol" )
localify.Bind( "tr", prefix.."combobox_default",         "Varsayılan" )
localify.Bind( "tr", prefix.."combobox_sandbox",         "Sandbox" )
localify.Bind( "tr", prefix.."combobox_darkrp",          "DarkRP" )
localify.Bind( "tr", prefix.."combobox_singleplayer",    "Tek oyuncu" )
-- HUD                                                 
localify.Bind( "tr", prefix.."hud_front",                "Ön" )
localify.Bind( "tr", prefix.."hud_right",                "Sağ" )
localify.Bind( "tr", prefix.."hud_up",                   "Yukarı" )
-- Help                                                
localify.Bind( "tr", prefix.."help_max_per_player",      "Her oyuncunun maksimum yığılmış nesnesi sınırlıdır." )
localify.Bind( "tr", prefix.."help_max_per_stack",       "Yığın başına maksimum nesne (sol tıklama)." )
localify.Bind( "tr", prefix.."help_delay",               "Her yığınlayıcı kullanımı arasındaki gecikme (saniye cinsinden) (sol/sağ tıklama)" )
localify.Bind( "tr", prefix.."help_max_offsetx",         "Yığılmış nesneler arasındaki maksimum mesafe (X ekseni)." )
localify.Bind( "tr", prefix.."help_max_offsety",         "Yığılmış nesneler arasındaki maksimum mesafe (Y ekseni)." )
localify.Bind( "tr", prefix.."help_max_offsetz",         "Yığılmış nesneler arasındaki maksimum mesafe (Z ekseni)." )
localify.Bind( "tr", prefix.."help_freeze",              "Yığılmış nesneler ortaya çıktığında donar." )
localify.Bind( "tr", prefix.."help_weld",                "Yığılmış nesneler, ortaya çıktıklarında birbirine yapışır." )
localify.Bind( "tr", prefix.."help_nocollide",           "Yığılmış nesneler diğer yığılmış nesnelerle çarpışmaz." )
localify.Bind( "tr", prefix.."help_nocollide_all",       "Yığılmış nesneler oyuncular, NPC'ler, araçlar ve dünya dışında hiçbir şeyle çarpışmaz." )
localify.Bind( "tr", prefix.."help_stayinworld",         "Yığınlanmış nesnelerin harita dışında oluşturulmasını önler." )
-- Warnings                                            
localify.Bind( "tr", prefix.."warning_max_per_player",   "Öncelikle Rol Yapma oyun modları için. Sandbox oyun modları için bu genellikle sınırsız olmalıdır (-1)." )
localify.Bind( "tr", prefix.."warning_max_offsetx",      "Öncelikle Rol Yapma oyun modları için. Ne yaptığınızı bilmiyorsanız değişiklik yapmayın." )
localify.Bind( "tr", prefix.."warning_max_offsety",      "Öncelikle Rol Yapma oyun modları için. Ne yaptığınızı bilmiyorsanız değişiklik yapmayın." )
localify.Bind( "tr", prefix.."warning_max_offsetz",      "Öncelikle Rol Yapma oyun modları için. Ne yaptığınızı bilmiyorsanız değişiklik yapmayın." )
localify.Bind( "tr", prefix.."warning_freeze",           "DarkRP için." )
localify.Bind( "tr", prefix.."warning_weld",             "DarkRP için." )
localify.Bind( "tr", prefix.."warning_nocollide",        "DarkRP için." )
localify.Bind( "tr", prefix.."warning_nocollide_all",    "SUNUCU ÇALIŞIRKEN DEĞİŞTİRMEYİN. Bu, GM.ShouldCollide kancasını kullanır ve deneyseldir. Çalışır ve yığınlayıcıdan kaynaklanan çökmeleri durdurması garanti edilir, ancak daha fazla test yapılması gerekiyor." )

--[[--------------------------------------------------------------------------
-- <Other> Localization
--------------------------------------------------------------------------]]--
--[[
-- Tool Settings
localify.Bind( "", prefix.."name",                     "" )
localify.Bind( "", prefix.."desc",                     "" )
localify.Bind( "", prefix.."left",                     "" )
localify.Bind( "", prefix.."shift_left",               "" )
localify.Bind( "", prefix.."right",                    "" )
localify.Bind( "", prefix.."shift_right",              "" )
localify.Bind( "", prefix.."reload",                   "" )
localify.Bind( "", "Undone_stacker_improved",          "" )
-- Errors
localify.Bind( "", prefix.."error_blocked_by_server",  "" )
localify.Bind( "", prefix.."error_not_admin",          "" )
localify.Bind( "", prefix.."error_invalid_argument",   "" )
localify.Bind( "", prefix.."error_max_count",          "" )
localify.Bind( "", prefix.."error_too_quick",          "" )
localify.Bind( "", prefix.."error_max_total",          "" )
localify.Bind( "", prefix.."error_not_in_world",       "" )
localify.Bind( "", prefix.."error_max_constraints",    "" )
-- Labels
localify.Bind( "", prefix.."label_presets",            "" )
localify.Bind( "", prefix.."label_relative",           "" )
localify.Bind( "", prefix.."label_direction",          "" )
localify.Bind( "", prefix.."label_count",              "" )
localify.Bind( "", prefix.."label_reset_offsets",      "" )
localify.Bind( "", prefix.."label_reset_angles",       "" )
localify.Bind( "", prefix.."label_show_settings",      "" )
localify.Bind( "", prefix.."label_hide_settings",      "" )
localify.Bind( "", prefix.."label_x",                  "" )
localify.Bind( "", prefix.."label_y",                  "" )
localify.Bind( "", prefix.."label_z",                  "" )
localify.Bind( "", prefix.."label_pitch",              "" )
localify.Bind( "", prefix.."label_yaw",                "" )
localify.Bind( "", prefix.."label_roll",               "" )
localify.Bind( "", prefix.."label_language",           "" )
localify.Bind( "", prefix.."label_credits",            "" )
localify.Bind( "", prefix.."label_max_per_stack",      "" )
localify.Bind( "", prefix.."label_max_per_player",     "" )
localify.Bind( "", prefix.."label_max_offsetx",        "" ) 
localify.Bind( "", prefix.."label_max_offsety",        "" )
localify.Bind( "", prefix.."label_max_offsetz",        "" )
localify.Bind( "", prefix.."label_delay",              "" )
localify.Bind( "", prefix.."label_opacity",            "" )
-- Checkboxes
localify.Bind( "", prefix.."checkbox_freeze",          "" )
localify.Bind( "", prefix.."checkbox_weld",            "" )
localify.Bind( "", prefix.."checkbox_nocollide",       "" )
localify.Bind( "", prefix.."checkbox_nocollide_all",   "" )
localify.Bind( "", prefix.."checkbox_use_shift_key",   "" )
localify.Bind( "", prefix.."checkbox_relative",        "" )
localify.Bind( "", prefix.."checkbox_material",        "" )
localify.Bind( "", prefix.."checkbox_color",           "" )
localify.Bind( "", prefix.."checkbox_physprop",        "" )
localify.Bind( "", prefix.."checkbox_ghost",           "" )
localify.Bind( "", prefix.."checkbox_halo",            "" )
localify.Bind( "", prefix.."checkbox_halo_color",      "" )
localify.Bind( "", prefix.."checkbox_axis",            "" )
localify.Bind( "", prefix.."checkbox_axis_labels",     "" )
localify.Bind( "", prefix.."checkbox_axis_angles",     "" )
localify.Bind( "", prefix.."checkbox_stayinworld",     "" )
-- Comboboxes
localify.Bind( "", prefix.."combobox_world",           "" )
localify.Bind( "", prefix.."combobox_prop",            "" )
localify.Bind( "", prefix.."combobox_direction_up",    "" )
localify.Bind( "", prefix.."combobox_direction_down",  "" )
localify.Bind( "", prefix.."combobox_direction_front", "" )
localify.Bind( "", prefix.."combobox_direction_back",  "" )
localify.Bind( "", prefix.."combobox_direction_right", "" )
localify.Bind( "", prefix.."combobox_direction_left",  "" )
localify.Bind( "", prefix.."combobox_default",         "" )
localify.Bind( "", prefix.."combobox_sandbox",         "" )
localify.Bind( "", prefix.."combobox_darkrp",          "" )
localify.Bind( "", prefix.."combobox_singleplayer",    "" )
-- HUD
localify.Bind( "", prefix.."hud_front",                "" )
localify.Bind( "", prefix.."hud_right",                "" )
localify.Bind( "", prefix.."hud_up",                   "" )
-- Help
localify.Bind( "", prefix.."help_max_per_player",      "" )
localify.Bind( "", prefix.."help_max_per_stack",       "" )
localify.Bind( "", prefix.."help_delay",               "" )
localify.Bind( "", prefix.."help_max_offsetx",         "" )
localify.Bind( "", prefix.."help_max_offsety",         "" )
localify.Bind( "", prefix.."help_max_offsetz",         "" )
localify.Bind( "", prefix.."help_freeze",              "" )
localify.Bind( "", prefix.."help_weld",                "" )
localify.Bind( "", prefix.."help_nocollide",           "" )
localify.Bind( "", prefix.."help_nocollide_all",       "" )
localify.Bind( "", prefix.."help_stayinworld",         "" )
-- Warnings
localify.Bind( "", prefix.."warning_max_per_player",   "" )
localify.Bind( "", prefix.."warning_max_offsetx",      "" )
localify.Bind( "", prefix.."warning_max_offsety",      "" )
localify.Bind( "", prefix.."warning_max_offsetz",      "" )
localify.Bind( "", prefix.."warning_freeze",           "" )
localify.Bind( "", prefix.."warning_weld",             "" )
localify.Bind( "", prefix.."warning_nocollide",        "" )
localify.Bind( "", prefix.."warning_nocollide_all",    "" )
]]

-- Hopefully will add more with community/crowdsource support.

-- If you are multi/bilingual, please consider helping me translate the phrases above into other languages.
-- Create an issue on the Github page ( https://github.com/Mista-Tea/improved-stacker ) or
-- add me on Steam ( http://steamcommunity.com/profiles/76561198015280374 ). Thanks!

--lua/weapons/gmod_tool/stools/streamradio_gui_color_individual.lua:
TOOL.Category = "Stream Radio"
TOOL.Name = "#Tool." .. TOOL.Mode .. ".name"

TOOL.Information = {
	{ name = "left" },
	{ name = "right" },
}

TOOL.SkinVars = {
	color = {
		default = Color(255, 255, 255, 255),
		order = 1,
	},

	color_foreground = {
		default = Color(0, 0, 0, 255),
		order = 2,
	},

	color_icon = {
		default = Color(255, 255, 255, 255),
		order = 3,
	},

	color_shadow = {
		default = Color(64, 64, 64, 255),
		order = 4,
	},

	color_hover = {
		default = Color(192, 192, 192, 255),
		order = 5,
	},

	color_foreground_hover = {
		default = Color(0, 0, 0, 255),
		order = 6,
	},

	color_icon_hover = {
		default = Color(255, 255, 255, 255),
		order = 7,
	},

	color_disabled = {
		default = Color(128, 128, 128, 255),
		order = 8,
	},

	color_foreground_disabled = {
		default = Color(255, 255, 255, 255),
		order = 9,
	},

	color_icon_disabled = {
		default = Color(255, 255, 255, 255),
		order = 10,
	},
}

for varname, v in pairs(TOOL.SkinVars) do
	local color = v.default or Color(255, 255, 255, 255)

	TOOL.ClientConVar[varname .. "_t"] = "1"
	TOOL.ClientConVar[varname .. "_r"] = color.r
	TOOL.ClientConVar[varname .. "_g"] = color.g
	TOOL.ClientConVar[varname .. "_b"] = color.b
	TOOL.ClientConVar[varname .. "_a"] = color.a
end

if StreamRadioLib and StreamRadioLib.Loaded then
	StreamRadioLib.Tool.RegisterClientToolHook(TOOL, "LeftClick")
	StreamRadioLib.Tool.RegisterClientToolHook(TOOL, "RightClick")
	StreamRadioLib.Tool.RegisterClientToolHook(TOOL, "Holster")

	StreamRadioLib.Tool.AddLocale(TOOL, "name", "Radio Colorer (Individual)")
	StreamRadioLib.Tool.AddLocale(TOOL, "desc", "Change colors of aimed radio GUI panels")

	StreamRadioLib.Tool.AddLocale(TOOL, "left", "Apply colors of radio GUI panels")
	StreamRadioLib.Tool.AddLocale(TOOL, "right", "Copy the colors from radio GUI panels")

	StreamRadioLib.Tool.AddLocale(TOOL, "list", "List of changeable colors:")
	StreamRadioLib.Tool.AddLocale(TOOL, "color", "Selected color:")

	StreamRadioLib.Tool.AddLocale(TOOL, "list.common.active.desc", "If checked the color will be applied on left click.\nUncheck this if you don't want to change this color on a panel.")

	StreamRadioLib.Tool.AddLocale(TOOL, "list.color", "Background")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.color.desc", "Color of the background.")

	StreamRadioLib.Tool.AddLocale(TOOL, "list.color_foreground", "Foreground/Text")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.color_foreground.desc", "Color of the foreground such as texts or spectrum bars.")

	StreamRadioLib.Tool.AddLocale(TOOL, "list.color_icon", "Icon")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.color_icon.desc", "Color of the icons.")

	StreamRadioLib.Tool.AddLocale(TOOL, "list.color_shadow", "Shadow")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.color_shadow.desc", "Color of the shadow.")

	StreamRadioLib.Tool.AddLocale(TOOL, "list.color_hover", "[Button only] Hover Background")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.color_hover.desc", "Color of the background when hovered. (Button only)")

	StreamRadioLib.Tool.AddLocale(TOOL, "list.color_foreground_hover", "[Button only] Hover Foreground/Text")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.color_foreground_hover.desc", "Color of the foreground when hovered. (Button only)")

	StreamRadioLib.Tool.AddLocale(TOOL, "list.color_icon_hover", "[Button only] Hover Icon")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.color_icon_hover.desc", "Color of the icon when hovered. (Button only)")

	StreamRadioLib.Tool.AddLocale(TOOL, "list.color_disabled", "[Button only] Disabled Background")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.color_disabled.desc", "Color of the background when disabled. (Button only)")

	StreamRadioLib.Tool.AddLocale(TOOL, "list.color_foreground_disabled", "[Button only] Disabled Foreground/Text")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.color_foreground_disabled.desc", "Color of the foreground when disabled. (Button only)")

	StreamRadioLib.Tool.AddLocale(TOOL, "list.color_icon_disabled", "[Button only] Disabled Icon")
	StreamRadioLib.Tool.AddLocale(TOOL, "list.color_icon_disabled.desc", "Color of the icon when disabled. (Button only)")

	StreamRadioLib.Tool.Setup(TOOL)
else
	TOOL.Information = nil

	if CLIENT then
		local StreamRadioLib = StreamRadioLib or {}
		local _mode = TOOL.Mode

		language.Add("Tool." .. _mode .. ".name", "Radio Colorer (Individual)")
		language.Add("Tool." .. _mode .. ".desc", "Change colors of aimed radio GUI panels")
		language.Add("Tool." .. _mode .. ".0", "This tool could not be loaded.")

		function TOOL.BuildCPanel(CPanel)
			if StreamRadioLib.Loader_CreateErrorPanel then
				StreamRadioLib.Loader_CreateErrorPanel(CPanel, "This tool could not be loaded.")
			end
		end
	end
end

function TOOL:IsValid()
	return IsValid(self:GetSWEP()) and IsValid(self:GetOwner())
end

function TOOL:GetColors(forceall)
	local data = {}

	for varname, v in pairs(self.SkinVars) do
		if not forceall then
			local ticked = self:GetClientBool(varname .. "_t")
			if not ticked then continue end
		end

		local r = self:GetClientNumber(varname .. "_r")
		local g = self:GetClientNumber(varname .. "_g")
		local b = self:GetClientNumber(varname .. "_b")
		local a = self:GetClientNumber(varname .. "_a")

		data[varname] = Color(r, g, b, a)
	end

	return data
end

function TOOL:SetColors(data)
	data = data or {}

	for varname, v in pairs(self.SkinVars) do
		local color = data[varname] or v.default or Color(255, 255, 255, 255)

		self:SetClientNumber(varname .. "_r", color.r)
		self:SetClientNumber(varname .. "_g", color.g)
		self:SetClientNumber(varname .. "_b", color.b)
		self:SetClientNumber(varname .. "_a", color.a)
	end
end

function TOOL:AddModeList( panel )
	local listpanel = vgui.Create( "DListView" )
	panel:AddPanel(listpanel)

	listpanel:SetMultiSelect(false)

	local col1 = listpanel:AddColumn("No.")
	listpanel:AddColumn("Item")
	local col3 = listpanel:AddColumn("Color")
	local col4 = listpanel:AddColumn("Active")

	col1:SetFixedWidth(30)
	col3:SetMinWidth(40)
	col3:SetMaxWidth(70)
	col4:SetFixedWidth(40)

	local lines = {}

	listpanel.NextConVarCheck = 0

	local update = function()
		if not IsValid(self) then return end
		if not IsValid(listpanel) then return end

		local data = self:GetColors(true)
		local changed = false

		if ( input.IsMouseDown( MOUSE_LEFT ) ) then return end
		if ( listpanel.NextConVarCheck > RealTime() ) then return end

		listpanel.NextConVarCheck = RealTime() + 0.2

		for varname, line in pairs(lines) do
			if not self.SkinVars[varname] then continue end
			if not IsValid(line) then continue end

			local colortile = line.Columns[line._colorindex]
			if not IsValid(colortile) then continue end

			local activecheckbox = line.Columns[line._activeindex]
			if not IsValid(activecheckbox) then continue end

			local color = data[varname]
			if not color then continue end

			local oldcolor = colortile:GetColor()
			if color == oldcolor then continue end

			colortile:SetColor(color)
			line:SetSortValue(line._colorindex, tostring(color))
			changed = true
		end

		if changed and listpanel.OnColorUpdate then
			listpanel:OnColorUpdate(data)
		end
	end

	local data = self:GetColors(true)

	for varname, color in pairs(data) do
		local colortile = vgui.Create( "DColorButton" )
		local activecheckbox = vgui.Create( "DCheckBoxLabel" )
		if not self.SkinVars[varname] then continue end

		activecheckbox:SetText("")
		activecheckbox:SetConVar(self.Mode .. "_" .. varname  .. "_t")
		activecheckbox:SetIndent(12)
		activecheckbox:SetTooltip(StreamRadioLib.Tool.GetLocaleTranslation(self, "list.common.active.desc"))

		local order = self.SkinVars[varname].order or 0

		local line = listpanel:AddLine(order, StreamRadioLib.Tool.GetLocaleTranslation(self, "list." .. varname), colortile, activecheckbox)
		colortile.DoClick = function()
			listpanel:ClearSelection()
			listpanel:SelectItem(line)
		end

		line:SetTooltip(StreamRadioLib.Tool.GetLocaleTranslation(self, "list." .. varname .. ".desc"))
		line:SetSortValue(1, order)

		line._colorindex = 3
		line._activeindex = 4

		activecheckbox.OnChange = function(this, value)
			local sort = value and 1 or 0
			sort = sort * 1000 - order

			line:SetSortValue(line._activeindex, sort)
		end

		line._varname = varname
		lines[varname] = line
	end

	listpanel:SetTall(230)
	listpanel:SortByColumn(1)

	listpanel.Think = function()
		update()
	end

	update()

	return listpanel
end


function TOOL:BuildToolPanel( CPanel )
	self:AddLabel(CPanel, "list")

	local listpanel = self:AddModeList(CPanel)
	local colorpanel = nil
	local selectedline = nil

	listpanel.OnRowSelected = function(this, LineID, Line)
		selectedline = Line
		if not IsValid(selectedline) then return end
		if not IsValid(colorpanel) then return end
		if not selectedline._varname then return end

		local precmd = self.Mode .. "_" .. selectedline._varname

		colorpanel:SetConVarR(precmd .. "_r")
		colorpanel:SetConVarG(precmd .. "_g")
		colorpanel:SetConVarB(precmd .. "_b")
		colorpanel:SetConVarA(precmd .. "_a")
		colorpanel.txtA:SetConVar(precmd .. "_a")

		local colortile = selectedline.Columns[selectedline._colorindex]
		if not IsValid(colortile) then return end
		colorpanel:SetColor(colortile:GetColor())
	end

	listpanel.DoDoubleClick = function(this, LineID, Line)
		if not IsValid(Line) then return end
		if not IsValid(colorpanel) then return end

		local activecheckbox = selectedline.Columns[selectedline._activeindex]
		if not IsValid(activecheckbox) then return end
		activecheckbox:Toggle()
	end

	listpanel.OnColorUpdate = function(this, data)
		this:OnRowSelected(selectedline:GetID(), selectedline)
	end

	self:AddLabel(CPanel, "color")
	colorpanel = self:AddColorMixer(CPanel)

	listpanel:SelectFirstItem()
end

function TOOL:HighlightHoverPanels(entgui, panels)
	if SERVER then return nil end

	if not IsValid(entgui._ToolHoverHighlighter) then
		entgui._ToolHoverHighlighter = entgui:AddPanelByClassname("highlighter")
		entgui._ToolHoverHighlighter:SetColor(Color(0, 0, 0, 0))
		entgui._ToolHoverHighlighter:SetBorderColor(Color(255, 255, 0, 255))
		entgui._ToolHoverHighlighter:SetBorderColor2(Color(0, 0, 0, 255))
		entgui._ToolHoverHighlighter:SetZPos(9999000)
	end

	if IsValid(self.highlighter_hover) then
		if self.highlighter_hover ~= entgui._ToolHoverHighlighter then
			self.highlighter_hover:Remove()
		end
	end

	local highlighter_hover = entgui._ToolHoverHighlighter
	self.highlighter_hover = highlighter_hover

	if not IsValid(highlighter_hover) then
		return nil
	end

	highlighter_hover:HighlightClear()
	highlighter_hover:HighlightPanels(panels)
	highlighter_hover:Open()

	return highlighter_hover
end

function TOOL:GetTopMostPanel(panels)
	local area = nil
	local panel = nil

	for i, v in ipairs(panels or {}) do
		if not IsValid(v) then continue end
		if not v:IsSkinAble() then continue end

		local w, h = v:GetSize()
		local a = w * h

		if not area or area >= a then
			area = a
			panel = v
		end
	end

	return panel
end

function TOOL:GetAimedObject(trace)
	if not self.ToolLibLoaded then return end

	trace = trace or self:GetFallbackTrace()

	if not trace then return end
	if not trace.Hit then return end

	local ent = trace.Entity
	local owner = self:GetOwner()

	if not self:IsValidGUIRadio(ent) then return end

	local hit, x, y = ent:GetCursor( owner, trace )
	if not hit then return end

	local entgui = ent:GetGUI()
	if not IsValid(entgui) then return end

	local aimedpanel = self:GetTopMostPanel(entgui:GetPanelsAtPos(x, y))
	if not IsValid(aimedpanel) then return end

	return aimedpanel, entgui, ent
end

function TOOL:GetSelectionPanels(entgui, aimedpanel)
	if not self.ToolLibLoaded then return end
	local skinhierarchy = aimedpanel:GetSkinIdentifyerHierarchy()
	local selectedpanels = entgui:GetPanelsBySkinIdentifyer(skinhierarchy)

	return selectedpanels
end

function TOOL:LeftClick(trace)
	if not self.ToolLibLoaded then return end
	local aimedpanel = self:GetAimedObject(trace)
	if not IsValid(aimedpanel) then return false end

	if CLIENT then return true end

	StreamRadioLib.Tool.CallClientToolHook(self, "LeftClick")
	return true
end

function TOOL:RightClick(trace)
	if not self.ToolLibLoaded then return end
	local aimedpanel = self:GetAimedObject(trace)
	if not IsValid(aimedpanel) then return false end

	if CLIENT then return true end

	StreamRadioLib.Tool.CallClientToolHook(self, "RightClick")
	return true
end

function TOOL:LeftClickClient()
	if not self.ToolLibLoaded then return end
	local aimedpanel, entgui = self:GetAimedObject()
	if not IsValid(aimedpanel) then return end

	local skinhierarchy = aimedpanel:GetSkinIdentifyerHierarchy()
	if not skinhierarchy then return false end

	local data = self:GetColors()

	for varname, color in pairs(data) do
		local global = self.SkinVars[varname].global

		if global then
			entgui:SetSkinPropertyOnServer("", varname, color)
			continue
		end

		entgui:SetSkinPropertyOnServer(skinhierarchy, varname, color)
	end
end

function TOOL:RightClickClient()
	if not self.ToolLibLoaded then return end
	local aimedpanel, entgui = self:GetAimedObject()
	if not IsValid(aimedpanel) then return end

	local skindata = aimedpanel:GetSkinValues() or {}

	for varname, v in pairs(self.SkinVars) do
		if not v.global then continue end
		skindata[varname] = entgui:GetSkinValue(varname)
	end

	self:SetColors(skindata)
end

function TOOL:Holster()
	if not self.ToolLibLoaded then return end

	self:Clear()
	StreamRadioLib.Tool.CallClientToolHook(self, "Holster")
end

function TOOL:HolsterClient()
	if not self.ToolLibLoaded then return end
	self:Clear()
end

function TOOL:Clear()
	if IsValid(self.highlighter_hover) then
		self.highlighter_hover:Remove()
	end
end

function TOOL:Think()
	if not self.ToolLibLoaded then return end
	if SERVER then return end

	local aimedpanel, entgui = self:GetAimedObject()
	if not IsValid(aimedpanel) then
		if IsValid(self.highlighter_hover) then
			self.highlighter_hover:Remove()
			self._oldthink_aimedpanel = nil
		end
		return
	end

	if self._oldthink_aimedpanel == aimedpanel then return end
	self._oldthink_aimedpanel = aimedpanel

	local selectedpanels = self:GetSelectionPanels(entgui, aimedpanel)
	self:HighlightHoverPanels(entgui, selectedpanels)
end

--lua/weapons/gmod_tool/stools/streamradio_gui_skin.lua:
TOOL.Category = "Stream Radio"
TOOL.Name = "#Tool." .. TOOL.Mode .. ".name"

TOOL.Information = {
	{ name = "left" },
	{ name = "right" },
	{ name = "reload" }
}

if StreamRadioLib and StreamRadioLib.Loaded then
	StreamRadioLib.Tool.RegisterClientToolHook(TOOL, "LeftClick")
	StreamRadioLib.Tool.RegisterClientToolHook(TOOL, "RightClick")
	StreamRadioLib.Tool.RegisterClientToolHook(TOOL, "Reload")
	StreamRadioLib.Tool.RegisterClientToolHook(TOOL, "Deploy")

	StreamRadioLib.Tool.AddLocale(TOOL, "name", "Radio Skin Duplicator")
	StreamRadioLib.Tool.AddLocale(TOOL, "desc", "Change, Copy or Save the skin of radios")

	StreamRadioLib.Tool.AddLocale(TOOL, "left", "Apply skin to the radio")
	StreamRadioLib.Tool.AddLocale(TOOL, "right", "Copy skin from the radio")
	StreamRadioLib.Tool.AddLocale(TOOL, "reload", "Reset the skin to default")

	StreamRadioLib.Tool.AddLocale(TOOL, "list", "List of saved skins:")

	StreamRadioLib.Tool.AddLocale(TOOL, "file.text.desc", "Enter the name of your skin here.\nPress 'Save' to save it to your hard disk.")

	StreamRadioLib.Tool.AddLocale(TOOL, "file.button.delete", "Delete")
	StreamRadioLib.Tool.AddLocale(TOOL, "file.button.delete.desc", "Delete the selected skin file from your hard disk.")
	StreamRadioLib.Tool.AddLocale(TOOL, "file.button.delete.error.empty", "You need to enter or select something to delete.")
	StreamRadioLib.Tool.AddLocale(TOOL, "file.button.delete.error.notfound", "The skin file does not exist.")
	StreamRadioLib.Tool.AddLocale(TOOL, "file.button.delete.error.protected", "The skin file is protected and can not be deleted.")

	StreamRadioLib.Tool.AddLocale(TOOL, "file.button.save", "Save")
	StreamRadioLib.Tool.AddLocale(TOOL, "file.button.save.desc", "Save skin to the filename as given above to your hard disk.")
	StreamRadioLib.Tool.AddLocale(TOOL, "file.button.save.error.protected", "The skin file is protected and can not be overwritten.")

	StreamRadioLib.Tool.AddLocale(TOOL, "file.button.open", "Open")
	StreamRadioLib.Tool.AddLocale(TOOL, "file.button.open.desc", "Open selected skin file.\nYou can also double click on the file to open it.")
	StreamRadioLib.Tool.AddLocale(TOOL, "file.button.open.error.empty", "You need to enter or select something to open.")
	StreamRadioLib.Tool.AddLocale(TOOL, "file.button.open.error.notfound", "The skin file does not exist.")

	StreamRadioLib.Tool.AddLocale(TOOL, "file.delete", "Delete skin?")
	StreamRadioLib.Tool.AddLocale(TOOL, "file.delete.desc", "Do you want to delete this skin file from your hard disk?")
	StreamRadioLib.Tool.AddLocale(TOOL, "file.delete.yes", "Yes, delete it.")
	StreamRadioLib.Tool.AddLocale(TOOL, "file.delete.no", "No, don't delete it.")

	StreamRadioLib.Tool.AddLocale(TOOL, "file.save", "Overwrite skin?")
	StreamRadioLib.Tool.AddLocale(TOOL, "file.save.desc", "Do you want to overwrite this skin file?")
	StreamRadioLib.Tool.AddLocale(TOOL, "file.save.yes", "Yes, overwrite it.")
	StreamRadioLib.Tool.AddLocale(TOOL, "file.save.no", "No, don't overwrite it.")

	StreamRadioLib.Tool.Setup(TOOL)
else
	TOOL.Information = nil

	if CLIENT then
		local StreamRadioLib = StreamRadioLib or {}
		local _mode = TOOL.Mode

		language.Add("Tool." .. _mode .. ".name", "Radio Skin Duplicator")
		language.Add("Tool." .. _mode .. ".desc", "Change, Copy or Save the skin of radios")
		language.Add("Tool." .. _mode .. ".0", "This tool could not be loaded.")

		function TOOL.BuildCPanel(CPanel)
			if StreamRadioLib.Loader_CreateErrorPanel then
				StreamRadioLib.Loader_CreateErrorPanel(CPanel, "This tool could not be loaded.")
			end
		end
	end
end

local function getnewname()
	local newnamebase = "newskin"
	local newname = newnamebase
	local count = 2

	while true do
		if not StreamRadioLib.Skin.IsValidSkinFile(newname) then
			return newname
		end

		if count >= 100 then
			return ""
		end

		newname = newnamebase .. count
		count = count + 1
	end
end

function TOOL:IsValid()
	return IsValid(self:GetSWEP())
end

function TOOL:AddSkinList( panel )
	local listpanel = vgui.Create( "DListView" )
	panel:AddPanel(listpanel)

	listpanel:SetMultiSelect(false)

	local col1 = listpanel:AddColumn("No.")
	listpanel:AddColumn("Name")
	local col3 = listpanel:AddColumn("Open")

	col1:SetFixedWidth(30)
	col3:SetFixedWidth(40)

	listpanel:SetTall(200)
	listpanel:SortByColumn(1)
	return listpanel
end

function TOOL:AddFileControlPanel( panel )
	local bgpanel = vgui.Create( "DPanel" )
	panel:AddPanel(bgpanel)

	bgpanel:SetPaintBackground(false)

	local buttonpanel = vgui.Create( "DPanel", bgpanel)
	buttonpanel:Dock(BOTTOM)
	buttonpanel:SetPaintBackground(false)
	buttonpanel:SetHeight(25)

	local buttondelete = vgui.Create( "DButton", buttonpanel)
	buttondelete:Dock(LEFT)
	buttondelete:SetText(StreamRadioLib.Tool.GetLocale(self, "file.button.delete"))
	buttondelete:SetWide(70)
	buttondelete:SetTooltip(StreamRadioLib.Tool.GetLocale(self, "file.button.delete.desc"))

	local buttonsave = vgui.Create( "DButton", buttonpanel)
	buttonsave:Dock(RIGHT)
	buttonsave:SetText(StreamRadioLib.Tool.GetLocale(self, "file.button.save"))
	buttonsave:SetWide(70)
	buttonsave:SetTooltip(StreamRadioLib.Tool.GetLocale(self, "file.button.save.desc"))

	local buttonopen = vgui.Create( "DButton", buttonpanel)
	buttonopen:Dock(FILL)
	buttonopen:DockMargin(5, 0, 5, 0)
	buttonopen:SetText(StreamRadioLib.Tool.GetLocale(self, "file.button.open"))
	buttonopen:SetTooltip(StreamRadioLib.Tool.GetLocale(self, "file.button.open.desc"))

	local text = vgui.Create( "DTextEntry", bgpanel)
	text:DockMargin(0, 0, 0, 5)
	text:Dock(FILL)

	text:SetHistoryEnabled(false)
	text:SetAllowNonAsciiCharacters(false)
	text:SetEnterAllowed(true)
	text:SetMultiline(false)
	text:SetUpdateOnType(true)
	text:SetTooltip(StreamRadioLib.Tool.GetLocale(self, "file.text.desc"))

	bgpanel:SetHeight(55)

	local deletefile = function(name)
		local ok = StreamRadioLib.Skin.Delete(name)

		if bgpanel.OnDeleted then
			bgpanel:OnDeleted(name, ok)
		end
	end

	local openfile = function(name)
		local data = StreamRadioLib.Skin.Open(name)
		local ok = true

		if not data then
			ok = false
		else
			self:SetSkin(data)
		end

		if bgpanel.OnOpened then
			bgpanel:OnOpened(name, ok)
		end
	end

	local savefile = function(name)
		local data = self:GetSkin()
		local ok = StreamRadioLib.Skin.Save(name, data)

		if bgpanel.OnSaved then
			bgpanel:OnSaved(name, ok)
		end
	end

	local checkfile = function(filename)
		filename = StreamRadioLib.Skin.SanitizeName(filename)

		buttondelete:SetEnabled(true)
		buttonopen:SetEnabled(true)
		buttonsave:SetEnabled(true)

		buttondelete:SetTooltip(StreamRadioLib.Tool.GetLocale(self, "file.button.delete.desc"))
		buttonopen:SetTooltip(StreamRadioLib.Tool.GetLocale(self, "file.button.open.desc"))
		buttonsave:SetTooltip(StreamRadioLib.Tool.GetLocale(self, "file.button.save.desc"))

		if filename == "" then
			buttondelete:SetEnabled(false)
			buttonopen:SetEnabled(false)

			buttondelete:SetTooltip(StreamRadioLib.Tool.GetLocale(self, "file.button.delete.error.empty"))
			buttonopen:SetTooltip(StreamRadioLib.Tool.GetLocale(self, "file.button.open.error.empty"))

			return
		end

		if not StreamRadioLib.Skin.IsValidSkinFile(filename) then
			buttondelete:SetEnabled(false)
			buttonopen:SetEnabled(false)

			buttondelete:SetTooltip(StreamRadioLib.Tool.GetLocale(self, "file.button.delete.error.notfound"))
			buttonopen:SetTooltip(StreamRadioLib.Tool.GetLocale(self, "file.button.open.error.notfound"))
		end

		if filename == "default" then
			buttondelete:SetEnabled(false)
			buttonsave:SetEnabled(false)

			buttondelete:SetTooltip(StreamRadioLib.Tool.GetLocale(self, "file.button.delete.error.protected"))
			buttonsave:SetTooltip(StreamRadioLib.Tool.GetLocale(self, "file.button.save.error.protected"))
		end
	end

	text.OnValueChange = function(this, value)
		checkfile(value)
	end

	bgpanel.SetFile = function(this, filename)
		if not IsValid(text) then return end

		local filename = StreamRadioLib.Skin.SanitizeName(filename)

		if filename == "" then
			filename = getnewname()
		end

		checkfile(filename)
		text:SetText(filename)
	end

	bgpanel.GetFile = function(this)
		if not IsValid(text) then return end

		local name = StreamRadioLib.Skin.SanitizeName(text:GetText())
		return name
	end

	bgpanel.OpenFile = function()
		if not IsValid(self) then return end
		if not IsValid(text) then return end
		if not IsValid(bgpanel) then return end

		local name = bgpanel:GetFile()
		checkfile(name)

		openfile(name)
	end

	buttondelete.DoClick = function()
		if not IsValid(self) then return end
		if not IsValid(text) then return end
		if not IsValid(bgpanel) then return end

		local name = bgpanel:GetFile()
		checkfile(name)

		Derma_Query(
			StreamRadioLib.Tool.GetLocaleTranslation(self, "file.delete.desc"),
			StreamRadioLib.Tool.GetLocaleTranslation(self, "file.delete"),
			StreamRadioLib.Tool.GetLocaleTranslation(self, "file.delete.yes"),
			function()
				if not IsValid(self) then return end
				if not IsValid(panel) then return end
				if not IsValid(text) then return end
				if not IsValid(bgpanel) then return end

				deletefile(name)
			end,
			StreamRadioLib.Tool.GetLocaleTranslation(self, "file.delete.no")
		)
	end

	buttonopen.DoClick = function()
		bgpanel:OpenFile()
	end

	buttonsave.DoClick = function()
		if not IsValid(self) then return end
		if not IsValid(text) then return end
		if not IsValid(bgpanel) then return end

		local name = bgpanel:GetFile()
		checkfile(name)

		if name == "" then
			name = getnewname()
		end

		if StreamRadioLib.Skin.IsValidSkinFile(name) then
			Derma_Query(
				StreamRadioLib.Tool.GetLocaleTranslation(self, "file.save.desc"),
				StreamRadioLib.Tool.GetLocaleTranslation(self, "file.save"),
				StreamRadioLib.Tool.GetLocaleTranslation(self, "file.save.yes"),
				function()
					if not IsValid(self) then return end
					if not IsValid(panel) then return end
					if not IsValid(text) then return end
					if not IsValid(bgpanel) then return end

					savefile(name)
				end,
				StreamRadioLib.Tool.GetLocaleTranslation(self, "file.save.no")
			)

			return
		end

		savefile(name)
	end

	return bgpanel
end

function TOOL:RefreshList()
	if not IsValid(self.filelistpanel) then return end

	local skinlist = StreamRadioLib.Skin.GetList()

	self.filelistpanel:Clear()
	self.filelistpanel._filemap = {}

	for i, name in ipairs(skinlist) do
		if IsValid(self.filelistpanel._filemap[name]) then
			continue
		end

		local line = self.filelistpanel:AddLine(i, name, "")
		line:SetSortValue(1, i)
		line:SetSortValue(3, 0)

		self.filelistpanel._filemap[name] = line
	end

	if not IsValid(self.filecontrolpanel) then return end
	timer.Simple(0.1, function()
		if not IsValid(self) then return end
		if not IsValid(self.filecontrolpanel) then return end

		self:MakeFileAsOpen(self.OpenName)
	end)
end


function TOOL:MakeFileAsOpen(name)
	name = StreamRadioLib.Skin.SanitizeName(name)

	if IsValid(self.filecontrolpanel) and name ~= "" then
		self.filecontrolpanel:SetFile(name)
	end

	self.OpenName = name

	if not IsValid(self.filelistpanel) then return end
	if not self.filelistpanel._filemap then return end

	local openline = self.filelistpanel._filemap[name]
	if not IsValid(openline) then return end

	if IsValid(self._oldopenline) then
		self._oldopenline:SetColumnText(3, "")
		self._oldopenline:SetSortValue(3, 0)

		local column = self._oldopenline.Columns[3]
		if IsValid(column) then
			column:SetColor(Color(0, 0, 0, 255))
			column:SetBGColor(Color(255, 255, 255, 255))
			column:SetPaintBackgroundEnabled(true)
		end
	end

	openline:SetColumnText(3, "Open")
	openline:SetSortValue(3, 1)

	local column = openline.Columns[3]
	if IsValid(column) then
		column:SetColor(Color(0, 0, 0, 255))
		column:SetBGColor(Color(0, 192, 0, 255))
		column:SetPaintBackgroundEnabled(true)
	end

	self._oldopenline = openline

	self.filelistpanel:ClearSelection()
	self.filelistpanel:SelectItem(openline)
end

function TOOL:BuildToolPanel( CPanel )
	self:AddLabel(CPanel, "list")

	self.filelistpanel = self:AddSkinList(CPanel)
	local listpanel = self.filelistpanel
	local filepanel = nil

	listpanel.OnRowSelected = function(this, LineID, Line)
		if not IsValid(Line) then return end
		if not IsValid(filepanel) then return end

		local name = Line:GetColumnText(2)
		filepanel:SetFile(name)
	end

	listpanel.DoDoubleClick = function(this, LineID, Line)
		if not IsValid(Line) then return end
		if not IsValid(filepanel) then return end

		local name = Line:GetColumnText(2)
		filepanel:SetFile(name)
		filepanel:OpenFile()
	end

	listpanel:SelectFirstItem()

	self.filecontrolpanel = self:AddFileControlPanel(CPanel)
	filepanel = self.filecontrolpanel

	filepanel.OnOpened = function(this, name, ok)
		if not ok then return end
		self:MakeFileAsOpen(name)
	end

	filepanel.OnDeleted = function(this, name, ok)
		if not ok then
			return
		end

		self:RefreshList()
	end

	filepanel.OnSaved = function(this, name, ok)
		if not ok then
			return
		end

		local data = StreamRadioLib.Skin.Open(name)

		if not data then
			return
		end

		self:SetSkin(data)
		self:RefreshList()
	end

	self:RefreshList()

	filepanel:SetFile("default")
	filepanel:OpenFile()

	self.filelistpanel:SelectFirstItem()
end

function TOOL:SetSkin(skindata)
	self.skin = table.Copy(skindata or {})

	local name = StreamRadioLib.Skin.SanitizeName(self.skin.name)

	if name == "" then
		name = getnewname()
	end

	self:MakeFileAsOpen(name)
end

function TOOL:GetSkin()
	return self.skin or StreamRadioLib.Skin.GetDefaultSkin()
end

function TOOL:GetAimedGui(trace)
	if not self.ToolLibLoaded then return end

	trace = trace or self:GetFallbackTrace()

	if not trace then return end
	if not trace.Hit then return end

	local ent = trace.Entity

	if not self:IsValidGUIRadio(ent) then return end

	local entgui = ent:GetGUI()
	if not IsValid(entgui) then return end

	return entgui, ent
end

function TOOL:LeftClick(trace)
	if not self.ToolLibLoaded then return end
	local entgui = self:GetAimedGui(trace)
	if not IsValid(entgui) then return false end

	if CLIENT then return true end

	StreamRadioLib.Tool.CallClientToolHook(self, "LeftClick")
	return true
end

function TOOL:LeftClickClient()
	if not self.ToolLibLoaded then return end
	local entgui = self:GetAimedGui()
	if not IsValid(entgui) then return false end

	entgui:SetSkinOnServer(self:GetSkin(), false)
end

function TOOL:RightClick(trace)
	if not self.ToolLibLoaded then return end
	local entgui = self:GetAimedGui(trace)
	if not IsValid(entgui) then return false end

	if CLIENT then return true end

	StreamRadioLib.Tool.CallClientToolHook(self, "RightClick")
	return true
end

function TOOL:RightClickClient()
	if not self.ToolLibLoaded then return end
	local entgui = self:GetAimedGui()
	if not IsValid(entgui) then return false end

	self:SetSkin(entgui:GetSkin())
end

function TOOL:Reload(trace)
	if not self.ToolLibLoaded then return end
	local entgui = self:GetAimedGui(trace)
	if not IsValid(entgui) then return false end

	if CLIENT then return true end

	StreamRadioLib.Tool.CallClientToolHook(self, "Reload")
	return true
end

function TOOL:ReloadClient()
	if not self.ToolLibLoaded then return end
	local entgui = self:GetAimedGui()
	if not IsValid(entgui) then return false end

	entgui:SetSkinOnServer(StreamRadioLib.Skin.GetDefaultSkin(), false)
end

function TOOL:Deploy()
	if not self.ToolLibLoaded then return end
	StreamRadioLib.Tool.CallClientToolHook(self, "Deploy")
end

function TOOL:DeployClient()
	if not self.ToolLibLoaded then return end
	self:RefreshList()
end

--addons/zeros_trashman_v1.6.3/lua/weapons/gmod_tool/stools/ztm_trashspawner.lua:
/*
    Addon id: 
    Version: v1.6.3 (stable)
*/

AddCSLuaFile()
include("sh_ztm_config.lua")
AddCSLuaFile("sh_ztm_config.lua")

TOOL.Category = "Zeros Trashman"
TOOL.Name = "#TrashSpawner"
TOOL.Command = nil


if (CLIENT) then
	language.Add("tool.ztm_trashspawner.name", "Zeros Trashman - Trash Spawner")
	language.Add("tool.ztm_trashspawner.desc", "LeftClick: Creates a Trash Spawnpoint. \nRightClick: Removes a Trash Spawnpoint.")
	language.Add("tool.ztm_trashspawner.0", "LeftClick: Creates a Trash Spawn.")
end

                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

function TOOL:LeftClick(trace)
	local trEnt = trace.Entity

	if trEnt:IsPlayer() then return false end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

	if (CLIENT) then return end
	if (trEnt:GetClass() == "worldspawn") or trEnt == Entity(0) then

		if trace.Hit and trace.HitPos and zclib.util.InDistance(trace.HitPos, self:GetOwner():GetPos(), 1000) then
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

	       ztm.Trash.AddSpawnPos(trace.HitPos,self:GetOwner())
	    end

		return true
	else
		return false
	end
end

function TOOL:RightClick(trace)
	if (trace.Entity:IsPlayer()) then return false end
	if (CLIENT) then return end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

	if trace.Hit and trace.HitPos then

		if zclib.util.InDistance(trace.HitPos, self:GetOwner():GetPos(), 1000) then

	       ztm.Trash.RemoveSpawnPos(trace.HitPos,self:GetOwner())
	    end

		return true
	else
		return false
	end
end

function TOOL:Deploy()
	if SERVER then
		if zclib.Player.IsAdmin(self:GetOwner()) == false then return end

		ztm.Trash.ShowAll(self:GetOwner())
	end
end

function TOOL:Holster()
	if SERVER then
		ztm.Trash.HideAll(self:GetOwner())
	end
end

function TOOL.BuildCPanel(CPanel)
	CPanel:AddControl("Header", {
		Text = "#tool.ztm_trashspawner.name",
		Description = "#tool.ztm_trashspawner.desc"
	})

	CPanel:AddControl("label", {
		Text = "Saves all the Trash points that are currently on the Map"
	})
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

	CPanel:Button("Save Trash points", "ztm_trash_save")

	CPanel:AddControl("label", {
		Text = " "
	})
	CPanel:AddControl("label", {
		Text = "Removes all the Trash points that are currently on the Map"
	})

	CPanel:Button("Remove all Trash points", "ztm_trash_remove")
end

--addons/hackable_server/lua/languages/hacktool/lang_de.lua:
return gluapack()()
--addons/hackable_server/lua/languages/hacktool/lang_tr.lua:
return "turkish",{
	["Wanted"] = "Aranıyor",
	["Unwanted"] = "Aranmıyor",
	["Unarrest"] = "Serbest Bırakıldı",
	["Warrant"] = "Mülkü Arama Emri",
	["Remove warrant"] = "Mülkü Arama Emrini Kaldır",
	["Add a law"] = "Yeni Yasa Ekle",
	["Remove the law"] = "Yasa Kaldır",
	["Initiate a lockdown"] = "Olağanüstü Hal İlan Et",
	["Cancel the lockdown"] = "Olağanüstü Hali Kaldır",
	["Steal money"] = "Para Çal",
	["Reason"] = "Sebep",
	["Error"] = "Hata",
	["Time"] = "Süre",
	["Nobody is wanted"] = "Kimse Aranmıyor",
	["Nobody is arrested"] = "Kimse Tutuklanmadı",
	["There is no mayor"] = "Şehirde Başkan Yok",
	["Law"] = "Yasa",
	["Law added"] = "Yasa Eklendi",
	["Success"] = "Başarılı",
	["There is no laws"] = "Yasa Bulunamadı",
	["Success! You got $"] = "İşlem Başarılı Kazancın $",
	["Success chance"] = "Değişim Başarılı",
    ["Not enough police"] = "Yeterince Polis Memuru Yok",
	["LOADING..."] = "YÜKLENİYOR...",
	["RELOADING..."] = "YENİDEN YÜKLENİYOR...",
	["CPU OVERHEAT!"] = "CPU AŞIRI ISINDI!",
	["SYSTEM ERROR!"] = "SİSTEM HATASI!",
	["READY"] = "HAZIR"
}
--addons/hackable_server/lua/weapons/hacktool/settings.lua:
return gluapack()()
--addons/hackable_server/lua/weapons/hacktool/cl_screen.lua:
return gluapack()()
--gamemodes/darkrp/entities/weapons/lockpick/shared.lua:
return gluapack()()
--gamemodes/darkrp/entities/weapons/lockpick/shared.lua:
AddCSLuaFile()

if CLIENT then
    SWEP.Slot = 5
    SWEP.SlotPos = 1
    SWEP.DrawAmmo = false
    SWEP.DrawCrosshair = false
end

-- Variables that are used on both client and server

SWEP.PrintName = "Lock Pick"
SWEP.Author = "DarkRP Developers"
SWEP.Instructions = "Left or right click to pick a lock"
SWEP.Contact = ""
SWEP.Purpose = ""
SWEP.IsDarkRPLockpick = true

SWEP.ViewModelFOV = 62
SWEP.ViewModelFlip = false
SWEP.ViewModel = Model("models/weapons/c_crowbar.mdl")
SWEP.WorldModel = Model("models/weapons/w_crowbar.mdl")

SWEP.UseHands = true

SWEP.Spawnable = true
SWEP.AdminOnly = true
SWEP.Category = "DarkRP (Utility)"

SWEP.Sound = Sound("physics/wood/wood_box_impact_hard3.wav")

SWEP.Primary.ClipSize = -1      -- Size of a clip
SWEP.Primary.DefaultClip = 0        -- Default number of bullets in a clip
SWEP.Primary.Automatic = false      -- Automatic/Semi Auto
SWEP.Primary.Ammo = ""

SWEP.Secondary.ClipSize = -1        -- Size of a clip
SWEP.Secondary.DefaultClip = -1     -- Default number of bullets in a clip
SWEP.Secondary.Automatic = false        -- Automatic/Semi Auto
SWEP.Secondary.Ammo = ""

function SWEP:SetupDataTables()
    self:NetworkVar("Bool", 0, "IsLockpicking")
    self:NetworkVar("Float", 0, "LockpickStartTime")
    self:NetworkVar("Float", 1, "LockpickEndTime")
    self:NetworkVar("Float", 2, "NextSoundTime")
    self:NetworkVar("Int", 0, "TotalLockpicks")
    self:NetworkVar("Entity", 0, "LockpickEnt")
end

function SWEP:Initialize()
    self:SetHoldType("normal")
end

function SWEP:PrimaryAttack()
    self:SetNextPrimaryFire(CurTime() + 0.5)
    if self:GetIsLockpicking() then return end

    local Owner = self:GetOwner()

    if not IsValid(Owner) then return end

    Owner:LagCompensation(true)
    local trace = Owner:GetEyeTrace()
    Owner:LagCompensation(false)
    local ent = trace.Entity

    if not IsValid(ent) or ent.DarkRPCanLockpick == false then return end
    local canLockpick = hook.Call("canLockpick", nil, Owner, ent, trace)

    if canLockpick == false then return end
    if canLockpick ~= true and (
            trace.HitPos:DistToSqr(Owner:GetShootPos()) > 10000 or
            (not GAMEMODE.Config.canforcedooropen and ent:getKeysNonOwnable()) or
            (not ent:isDoor() and not ent:IsVehicle() and not string.find(string.lower(ent:GetClass()), "vehicle") and (not GAMEMODE.Config.lockpickfading or not ent.isFadingDoor))
        ) then
        return
    end

    self:SetHoldType("pistol")

    self:SetIsLockpicking(true)
    self:SetLockpickEnt(ent)
    self:SetLockpickStartTime(CurTime())
    local endDelta = hook.Call("lockpickTime", nil, Owner, ent) or util.SharedRandom("DarkRP_Lockpick" .. self:EntIndex() .. "_" .. self:GetTotalLockpicks(), 10, 30)
    self:SetLockpickEndTime(CurTime() + endDelta)
    self:SetTotalLockpicks(self:GetTotalLockpicks() + 1)


    if IsFirstTimePredicted() then
        hook.Call("lockpickStarted", nil, Owner, ent, trace)
    end

    if CLIENT then
        self.Dots = ""
        self.NextDotsTime = SysTime() + 0.5
        return
    end

    local onFail = function(ply) if ply == Owner then hook.Call("onLockpickCompleted", nil, ply, false, ent) end end

    -- Lockpick fails when dying or disconnecting
    hook.Add("PlayerDeath", self, fc{onFail, fn.Flip(fn.Const)})
    hook.Add("PlayerDisconnected", self, fc{onFail, fn.Flip(fn.Const)})
    -- Remove hooks when finished
    hook.Add("onLockpickCompleted", self, fc{fp{hook.Remove, "PlayerDisconnected", self}, fp{hook.Remove, "PlayerDeath", self}})
end

function SWEP:Holster()
    if self:GetIsLockpicking() and self:GetLockpickEndTime() ~= 0 then
        self:Fail()
    end
    return true
end

function SWEP:Succeed()
    self:SetHoldType("normal")

    local ent = self:GetLockpickEnt()
    self:SetIsLockpicking(false)
    self:SetLockpickEnt(nil)

    if not IsValid(ent) then return end

    local override = hook.Call("onLockpickCompleted", nil, self:GetOwner(), true, ent)

    if override then return end

    if ent.isFadingDoor and ent.fadeActivate and not ent.fadeActive then
        ent:fadeActivate()
        if IsFirstTimePredicted() then timer.Simple(5, function() if IsValid(ent) and ent.fadeActive then ent:fadeDeactivate() end end) end
    elseif ent.Fire then
        ent:keysUnLock()
        ent:Fire("open", "", .6)
        ent:Fire("setanimation", "open", .6)
    end
end

function SWEP:Fail()
    self:SetIsLockpicking(false)
    self:SetHoldType("normal")

    hook.Call("onLockpickCompleted", nil, self:GetOwner(), false, self:GetLockpickEnt())
    self:SetLockpickEnt(nil)
end

local colorBackground = Color(10, 10, 10, 120)
local dots = {
    [0] = ".",
    [1] = "..",
    [2] = "...",
    [3] = ""
}
function SWEP:Think()
    if not self:GetIsLockpicking() or self:GetLockpickEndTime() == 0 then return end

    if CurTime() >= self:GetNextSoundTime() then
        self:SetNextSoundTime(CurTime() + 1)
        local snd = {1,3,4}
        self:EmitSound("weapons/357/357_reload" .. tostring(snd[math.Round(util.SharedRandom("DarkRP_LockpickSnd" .. CurTime(), 1, #snd))]) .. ".wav", 50, 100)
    end
    if CLIENT and (not self.NextDotsTime or SysTime() >= self.NextDotsTime) then
        self.NextDotsTime = SysTime() + 0.5
        self.Dots = self.Dots or ""
        local len = string.len(self.Dots)

        self.Dots = dots[len]
    end

    local trace = self:GetOwner():GetEyeTrace()
    if not IsValid(trace.Entity) or trace.Entity ~= self:GetLockpickEnt() or trace.HitPos:DistToSqr(self:GetOwner():GetShootPos()) > 10000 then
        self:Fail()
    elseif self:GetLockpickEndTime() <= CurTime() then
        self:Succeed()
    end
end

function SWEP:DrawHUD()
    if not self:GetIsLockpicking() or self:GetLockpickEndTime() == 0 then return end

    self.Dots = self.Dots or ""
    local w = ScrW()
    local h = ScrH()
    local x, y, width, height = w / 2 - w / 10, h / 2 - 60, w / 5, h / 15
    draw.RoundedBox(8, x, y, width, height, colorBackground)

    local time = self:GetLockpickEndTime() - self:GetLockpickStartTime()
    local curtime = CurTime() - self:GetLockpickStartTime()
    local status = math.Clamp(curtime / time, 0, 1)
    local BarWidth = status * (width - 16)
    local cornerRadius = math.Min(8, BarWidth / 3 * 2 - BarWidth / 3 * 2 % 2)
    draw.RoundedBox(cornerRadius, x + 8, y + 8, BarWidth, height - 16, Color(255 - (status * 255), 0 + (status * 255), 0, 255))

    draw.DrawNonParsedSimpleText(DarkRP.getPhrase("picking_lock") .. self.Dots, "Trebuchet24", w / 2, y + height / 2, color_white, 1, 1)
end

function SWEP:SecondaryAttack()
    self:PrimaryAttack()
end


DarkRP.hookStub{
    name = "canLockpick",
    description = "Whether an entity can be lockpicked.",
    parameters = {
        {
            name = "ply",
            description = "The player attempting to lockpick an entity.",
            type = "Player"
        },
        {
            name = "ent",
            description = "The entity being lockpicked.",
            type = "Entity"
        },
        {
            name = "trace",
            description = "The trace result.",
            type = "table"
        }
    },
    returns = {
        {
            name = "allowed",
            description = "Whether the entity can be lockpicked",
            type = "boolean"
        }
    },
    realm = "Shared"
}

DarkRP.hookStub{
    name = "lockpickStarted",
    description = "Called when a player is about to pick a lock.",
    parameters = {
        {
            name = "ply",
            description = "The player that is about to pick a lock.",
            type = "Player"
        },
        {
            name = "ent",
            description = "The entity being lockpicked.",
            type = "Entity"
        },
        {
            name = "trace",
            description = "The trace result.",
            type = "table"
        }
    },
    returns = {},
    realm = "Shared"
}

DarkRP.hookStub{
    name = "onLockpickCompleted",
    description = "Result of a player attempting to lockpick an entity.",
    parameters = {
        {
            name = "ply",
            description = "The player attempting to lockpick the entity.",
            type = "Player"
        },
        {
            name = "success",
            description = "Whether the player succeeded in lockpicking the entity.",
            type = "boolean"
        },
        {
            name = "ent",
            description = "The entity that was lockpicked.",
            type = "Entity"
        },
    },
    returns = {
        {
            name = "override",
            description = "Return true to override default behaviour, which is opening the (fading) door.",
            type = "boolean"
        }
    },
    realm = "Shared"
}

DarkRP.hookStub{
    name = "lockpickTime",
    description = "The length of time, in seconds, it takes to lockpick an entity.",
    parameters = {
        {
            name = "ply",
            description = "The player attempting to lockpick an entity.",
            type = "Player"
        },
        {
            name = "ent",
            description = "The entity being lockpicked.",
            type = "Entity"
        },
    },
    returns = {
        {
            name = "time",
            description = "Seconds in which it takes a player to lockpick an entity",
            type = "number"
        }
    },
    realm = "Shared"
}

--lua/weapons/sv_wrench/cl_init.lua:
return gluapack()()
--lua/weapons/sv_wrench/shared.lua:
return gluapack()()
--addons/[binbon]misc/lua/weapons/weapon_ciga/cl_init.lua:
-- weapon_ciga/cl_init.lua
-- Defines common clientside code/defaults for ciga SWEP

-- Cigarette SWEP by Mordestein (based on Vape SWEP by Swamp Onions)
-- Backdoors removed by Seefox (https://steamcommunity.com/id/seef0x/)

include("shared.lua")

if not cigaParticleEmitter then cigaParticleEmitter = ParticleEmitter(Vector(0,0,0)) end

local poneyModels = {
	["models/cppm/playe"] = true,
	["models/mlp/player"] = true,
	["models/ppm/player"] = true
}

function SWEP:DrawWorldModel()
	local ply = self:GetOwner()

	local cigaScale = self.cigaScale or 1
	self:SetModelScale(cigaScale, 0)
	self:SetSubMaterial()

	if IsValid(ply) then
		local modelStr = ply:GetModel():sub(1, 17)
		local bn = poneyModels[modelStr] and "LrigScull" or "ValveBiped.Bip01_R_Hand"

		if ply.cigaArmFullyUp then
			bn = "ValveBiped.Bip01_Head1"
		end

		local bon = ply:LookupBone(bn) or 0
		local opos = self:GetPos()
		local oang = self:GetAngles()
		local bp, ba = ply:GetBonePosition(bon)

		if bp then
			opos = bp
		end

		if ba then
			oang = ba
		end

		if ply.cigaArmFullyUp then
			--head position
			opos = opos + (oang:Forward() * 0.95) + (oang:Right() * 7) + (oang:Up() * 0.035)
			oang:RotateAroundAxis(oang:Forward(), -100)
			oang:RotateAroundAxis(oang:Up(), 100)
			opos = opos + (oang:Up() * (cigaScale - 1) * -10.25)
		else
			--hand position
			oang:RotateAroundAxis(oang:Forward(), 50)
			oang:RotateAroundAxis(oang:Right(), 90)
			opos = opos + (oang:Forward() * 2) + (oang:Up() * -4.5) + (oang:Right() * -2)
			oang:RotateAroundAxis(oang:Forward(), 90)
			oang:RotateAroundAxis(oang:Up(), 10)
			opos = opos + (oang:Up() * (cigaScale - 1) * -10.25)
			opos = opos + (oang:Up() * 2)
			opos = opos + (oang:Right() * 0.5)
			opos = opos + (oang:Forward() * -1.5)
		end

		self:SetupBones()
		local mrt = self:GetBoneMatrix(0)

		if mrt then
			mrt:SetTranslation(opos)
			mrt:SetAngles(oang)
			self:SetBoneMatrix(0, mrt)
		end
	end

	self:DrawModel()
end

function SWEP:GetViewModelPosition(pos, ang)
	if not LocalPlayer().cigaArmTime then
		LocalPlayer().cigaArmTime = 0
	end

	local lerp = math.Clamp((os.clock() - LocalPlayer().cigaArmTime) * 3, 0, 1)

	if LocalPlayer().cigaArm then
		lerp = 1 - lerp
	end

	--[[
	local newpos = LerpVector(lerp,vmpos1,vmpos2)
	local newang = LerpVector(lerp,vmang1,vmang2)
	--I have a good reason for doing it like this
	newang = Angle(newang.x,newang.y,newang.z) 

	pos,ang = LocalToWorld(newpos,newang,pos,ang)]]
	local difvec = Vector(-10, -3.5, -12) --vmpos1 - vmpos2
	local orig = Vector(0, 0, 0)
	local topos = orig + difvec
	local difang = Vector(-30, 0, 0) --vmang1 - vmang2
	local origang = Vector(0, 0, 0)
	local toang = origang + difang
	local newpos = LerpVector(lerp, topos, orig)
	local newang = LerpVector(lerp, toang, origang)
	newang = Angle(newang.x, newang.y, newang.z)
	pos, ang = LocalToWorld(newpos, newang, pos, ang)

	return pos, ang
end

sound.Add({
	name = "ciga_inhale",
	channel = CHAN_WEAPON,
	volume = 0.24,
	level = 60,
	pitch = {95},
	sound = "cigainhale.wav"
})

net.Receive("ciga", function()
	local ply = net.ReadEntity()
	local amt = net.ReadInt(8)
	local fx = net.ReadInt(8)
	if not IsValid(ply) then return end

	if amt >= 50 then
		ply:EmitSound("cigacough1.wav", 90)

		for i = 1, 200 do
			local d = i + 10

			if i > 140 then
				d = d + 150
			end

			timer.Simple((d - 1) * 0.003, function()
				ciga_do_pulse(ply, 1, 100, fx)
			end)
		end

		return
	elseif amt >= 35 then
		ply:EmitSound("cigabreath2.wav", 75, 100, 0.7)
	elseif amt >= 10 then
		ply:EmitSound("cigabreath1.wav", 70, 130 - math.min(100, amt * 2), 0.4 + (amt * 0.005))
	end

	for i = 1, amt * 2 do
		timer.Simple((i - 1) * 0.02, function()
			ciga_do_pulse(ply, math.floor(((amt * 2) - i) / 10), fx == 2 and 100 or 0, fx)
		end)
	end
end)

net.Receive("cigaArm", function()
	local ply = net.ReadEntity()
	local z = net.ReadBool()
	if not IsValid(ply) then return end

	if ply.cigaArm ~= z then
		if z then
			timer.Simple(0.3, function()
				if not IsValid(ply) then return end

				if ply.cigaArm then
					ply:EmitSound("ciga_inhale")
				end
			end)
		else
			ply:StopSound("ciga_inhale")
		end

		ply.cigaArm = z
		ply.cigaArmTime = os.clock()
		local m = 0

		if z then
			m = 1
		end

		for i = 0, 9 do
			timer.Simple(i / 30, function()
				ciga_interpolate_arm(ply, math.abs(m - ((9 - i) / 10)), z and 0 or 0.2)
			end)
		end
	end
end)

net.Receive("cigaTalking", function()
	local ply = net.ReadEntity()

	if IsValid(ply) then
		ply.cigaTalkingEndtime = net.ReadFloat()
	end
end)

function ciga_interpolate_arm(ply, mult, mouth_delay)
	if not IsValid(ply) then return end

	if mouth_delay > 0 then
		timer.Simple(mouth_delay, function()
			if IsValid(ply) then
				ply.cigaMouthOpenAmt = mult
			end
		end)
	else
		ply.cigaMouthOpenAmt = mult
	end

	local b1 = ply:LookupBone("ValveBiped.Bip01_R_Upperarm")
	local b2 = ply:LookupBone("ValveBiped.Bip01_R_Forearm")
	if (not b1) or (not b2) then return end
	ply:ManipulateBoneAngles(b1, Angle(20 * mult, -62 * mult, 10 * mult))
	ply:ManipulateBoneAngles(b2, Angle(-5 * mult, -10 * mult, 0))

	if mult == 1 then
		ply.cigaArmFullyUp = true
	else
		ply.cigaArmFullyUp = false
	end
end

--this makes the mouth opening work without clobbering other addons
hook.Add("InitPostEntity", "cigaMouthMoveSetup", function()
	timer.Simple(1, function()
		if ciga_OriginalMouthMove ~= nil then return end
		ciga_OriginalMouthMove = GAMEMODE.MouthMoveAnimation

		function GAMEMODE:MouthMoveAnimation(ply)
			--run the base MouthMoveAnimation if player isn't vaping/cigatalking
			if ((ply.cigaMouthOpenAmt or 0) == 0) and ((ply.cigaTalkingEndtime or 0) < CurTime()) then return ciga_OriginalMouthMove(GAMEMODE, ply) end
			local FlexNum = ply:GetFlexNum() - 1
			if (FlexNum <= 0) then return end

			for i = 0, FlexNum - 1 do
				local Name = ply:GetFlexName(i)

				if (Name == "jaw_drop" or Name == "right_part" or Name == "left_part" or Name == "right_mouth_drop" or Name == "left_mouth_drop") then
					ply:SetFlexWeight(i, math.max((ply.cigaMouthOpenAmt or 0) * 0.5, math.Clamp(((ply.cigaTalkingEndtime or 0) - CurTime()) * 3, 0, 1) * math.Rand(0.1, 0.8)))
				end
			end
		end
	end)
end)

function ciga_do_pulse(ply, amt, spreadadd, fx)
	if not IsValid(ply) then return end
	if ply:WaterLevel() == 3 then return end

	if not spreadadd then
		spreadadd = 0
	end

	local attachid = ply:LookupAttachment("eyes")
	cigaParticleEmitter:SetPos(LocalPlayer():GetPos())

	local angpos = ply:GetAttachment(attachid) or {
		Ang = Angle(0, 0, 0),
		Pos = Vector(0, 0, 0)
	}

	local fwd
	local pos

	if (ply ~= LocalPlayer()) then
		fwd = (angpos.Ang:Forward() - angpos.Ang:Up()):GetNormalized()
		pos = angpos.Pos + (fwd * 3.5)
	else
		fwd = ply:GetAimVector():GetNormalized()
		pos = ply:GetShootPos() + fwd * 1.5 + gui.ScreenToVector(ScrW() / 2, ScrH()) * 5
	end

	fwd = ply:GetAimVector():GetNormalized()

	for i = 1, amt do
		if not IsValid(ply) then return end
		local particle = cigaParticleEmitter:Add(string.format("particle/smokesprites_00%02d", math.random(7, 16)), pos)

		if particle then
			local dir = VectorRand():GetNormalized() * ((amt + 5) / 10)
			ciga_do_particle(particle, (ply:GetVelocity() * 0.25) + (((fwd * 9) + dir):GetNormalized() * math.Rand(50, 80) * (amt + 1) * 0.2), fx)
		end
	end
end

function ciga_do_particle(particle, vel, fx)
	particle:SetColor(255, 255, 255, 255)

	if fx == 3 then
		particle:SetColor(100, 100, 100, 100)
	end

	if fx >= 4 then
		local c = JuicycigaJuices[fx - 3].color

		if c == nil then
			c = HSVToColor(math.random(0, 359), 1, 1)
		end

		particle:SetColor(c.r, c.g, c.b, 255)
	end

	local mega = 1

	if fx == 2 then
		mega = 4
	end

	mega = mega * 0.3
	particle:SetVelocity(vel * mega)
	particle:SetGravity(Vector(0, 0, 1.5))
	particle:SetLifeTime(0)
	particle:SetDieTime(math.Rand(80, 100) * 0.11 * mega)
	particle:SetStartSize(3 * mega)
	particle:SetEndSize(40 * mega * mega)
	particle:SetStartAlpha(150)
	particle:SetEndAlpha(0)
	particle:SetCollide(true)
	particle:SetBounce(0.25)
	particle:SetRoll(math.Rand(0, 360))
	particle:SetRollDelta(0.01 * math.Rand(-40, 40))
	particle:SetAirResistance(50)
end

matproxy.Add({
	name = "cigaTankColor",
	init = function(self, mat, values)
		self.ResultTo = values.resultvar
	end,
	bind = function(self, mat, ent)
		if (not IsValid(ent)) then return end

		if ent:GetClass() == "viewmodel" then
			ent = ent:GetOwner()
			if (not IsValid(ent) or not ent:IsPlayer()) then return end
			ent = ent:GetActiveWeapon()
			if (not IsValid(ent)) then return end
		end

		local v = ent.cigaTankColor or Vector(0.3, 0.3, 0.3)

		if v == Vector(-1, -1, -1) then
			local c = HSVToColor((CurTime() * 60) % 360, 0.9, 0.9)
			v = Vector(c.r, c.g, c.b) / 255.0
		end

		mat:SetVector(self.ResultTo, v)
	end
})

matproxy.Add({
	name = "cigaAccentColor",
	init = function(self, mat, values)
		self.ResultTo = values.resultvar
	end,
	bind = function(self, mat, ent)
		if (not IsValid(ent)) then return end
		local o = ent:GetOwner()

		if ent:GetClass() == "viewmodel" then
			if (not IsValid(o)) or (not o:IsPlayer()) then return end
			ent = o:GetActiveWeapon()
			if (not IsValid(ent)) then return end
		end

		local special = false
		local col = ent.cigaAccentColor or special and Vector(1, 0.8, 0) or Vector(1, 1, 1)

		if col == Vector(-1, -1, -1) then
			col = Vector(1, 1, 1)

			if IsValid(o) then
				col = o:GetWeaponColor()
			end
		end

		mat:SetVector(self.ResultTo, col)
	end
})

--Swep Construction Kit code--
if CLIENT then
	SWEP.vRenderOrder = nil

	function SWEP:ViewModelDrawn()
		local vm = self:GetOwner():GetViewModel()
		if not IsValid(vm) then return end
		if (not self.VElements) then return end
		self:UpdateBonePositions(vm)

		if (not self.vRenderOrder) then
			-- we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs(self.VElements) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
		end

		for k, name in ipairs(self.vRenderOrder) do
			local v = self.VElements[name]

			if (not v) then
				self.vRenderOrder = nil
				break
			end

			if (v.hide) then continue end
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			if (not v.bone) then continue end
			local pos, ang = self:GetBoneOrientation(self.VElements, v, vm)
			if (not pos) then continue end

			if (v.type == "Model" and IsValid(model)) then
				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z)
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				model:SetAngles(ang)
				--model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix("RenderMultiply", matrix)

				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() ~= v.material) then
					model:SetMaterial(v.material)
				end

				if (v.skin and v.skin ~= model:GetSkin()) then
					model:SetSkin(v.skin)
				end

				if (v.bodygroup) then
					for kk, vv in pairs(v.bodygroup) do
						if (model:GetBodygroup(k) ~= v) then
							model:SetBodygroup(k, v)
						end
					end
				end

				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end

				render.SetColorModulation(v.color.r / 255, v.color.g / 255, v.color.b / 255)
				render.SetBlend(v.color.a / 255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)

				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
			elseif (v.type == "Sprite" and sprite) then
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
			elseif (v.type == "Quad" and v.draw_func) then
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				cam.Start3D2D(drawpos, ang, v.size)
				v.draw_func(self)
				cam.End3D2D()
			end
		end
	end

	function SWEP:GetBoneOrientation(basetab, tab, ent, bone_override)
		local bone, pos, ang

		if (tab.rel and tab.rel ~= "") then
			local v = basetab[tab.rel]
			if (not v) then return end
			-- Technically, if there exists an element with the same name as a bone
			-- you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation(basetab, v, ent)
			if (not pos) then return end
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
		else
			bone = ent:LookupBone(bone_override or tab.bone)
			if (not bone) then return end
			pos, ang = Vector(0, 0, 0), Angle(0, 0, 0)
			local m = ent:GetBoneMatrix(bone)

			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end

			local owner = self:GetOwner()
			if (IsValid(owner) and owner:IsPlayer() and ent == owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r -- Fixes mirrored models
			end
		end

		return pos, ang
	end

	function SWEP:CreateModels(tab)
		if (not tab) then return end

		-- Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs(tab) do
			if (v.type == "Model" and v.model and v.model ~= "" and (not IsValid(v.modelEnt) or v.createdModel ~= v.model) and string.find(v.model, ".mdl") and file.Exists(v.model, "GAME")) then
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)

				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
			elseif (v.type == "Sprite" and v.sprite and v.sprite ~= "" and (not v.spriteMaterial or v.createdSprite ~= v.sprite) and file.Exists("materials/" .. v.sprite .. ".vmt", "GAME")) then
				local name = v.sprite .. "-"

				local params = {
					["$basetexture"] = v.sprite
				}

				-- make sure we create a unique name based on the selected options
				local tocheck = {"nocull", "additive", "vertexalpha", "vertexcolor", "ignorez"}

				for i, j in pairs(tocheck) do
					if (v[j]) then
						params["$" .. j] = 1
						name = name .. "1"
					else
						name = name .. "0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name, "UnlitGeneric", params)
			end
		end
	end

	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		if self.ViewModelBoneMods then
			if (not vm:GetBoneCount()) then return end
			-- !! WORKAROUND !! //
			-- We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods

			if (not hasGarryFixedBoneScalingYet) then
				allbones = {}

				for i = 0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)

					if (self.ViewModelBoneMods[bonename]) then
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = {
							scale = Vector(1, 1, 1),
							pos = Vector(0, 0, 0),
							angle = Angle(0, 0, 0)
						}
					end
				end

				loopthrough = allbones
			end

			-- !! ----------- !! //
			for k, v in pairs(loopthrough) do
				local bone = vm:LookupBone(k)
				if (not bone) then continue end
				-- !! WORKAROUND !! //
				local s = Vector(v.scale.x, v.scale.y, v.scale.z)
				local p = Vector(v.pos.x, v.pos.y, v.pos.z)
				local ms = Vector(1, 1, 1)

				if (not hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)

					while (cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end

				s = s * ms

				-- !! ----------- !! //
				if vm:GetManipulateBoneScale(bone) ~= s then
					vm:ManipulateBoneScale(bone, s)
				end

				if vm:GetManipulateBoneAngles(bone) ~= v.angle then
					vm:ManipulateBoneAngles(bone, v.angle)
				end

				if vm:GetManipulateBonePosition(bone) ~= p then
					vm:ManipulateBonePosition(bone, p)
				end
			end
		else
			self:ResetBonePositions(vm)
		end
	end

	function SWEP:ResetBonePositions(vm)
		if (not vm:GetBoneCount()) then return end

		for i = 0, vm:GetBoneCount() do
			vm:ManipulateBoneScale(i, Vector(1, 1, 1))
			vm:ManipulateBoneAngles(i, Angle(0, 0, 0))
			vm:ManipulateBonePosition(i, Vector(0, 0, 0))
		end
	end

	--[[*************************
		Global utility code
	*************************]]
	-- Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	-- Does not copy entities of course, only copies their reference.
	-- WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy(tab)
		if (not tab) then return nil end
		local res = {}

		for k, v in pairs(tab) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) -- recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end

		return res
	end
end

--addons/[binbon]misc/lua/weapons/weapon_ciga_dal_beyaz.lua:
return gluapack()()
--addons/[binbon]misc/lua/weapons/weapon_ciga_paket_marlboro_touch_grey.lua:
-- MODEL WITH UNKNOWN AUTHOR! PM ME!!! QUICK :D -- 
-- Backdoors removed by Seefox (https://steamcommunity.com/id/seef0x/)

SWEP.PrintName = "Marlboro Touch Grey"
SWEP.Author = "RebS"
SWEP.Purpose = "Pick one out."

SWEP.Category = "Turkish Haram Mod Sigara"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo		= "none"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= false
SWEP.Secondary.Ammo		= "none"

SWEP.HoldType = "slam"
SWEP.ViewModelFOV = 49.849246231156
SWEP.ViewModelFlip = false
SWEP.ViewModel = "models/weapons/c_grenade.mdl"
SWEP.WorldModel = "models/rebs/icikiler_sigaralar/sigara_paket_beyaz_dal.mdl"
SWEP.UseHands = true
SWEP.ShowViewModel = true
SWEP.ShowWorldModel = false
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false

SWEP.ViewModelBoneMods = {
	["ValveBiped.Grenade_body"] = {
		scale = Vector(0.009, 0.009, 0.009),
		pos = Vector(0, 0, 0),
		angle = Angle(0, 0, 0)
	}
}

SWEP.VElements = {
	["element_name"] = {
		type = "Model",
		model = "models/rebs/icikiler_sigaralar/sigara_paket_beyaz_dal.mdl",
		bone = "ValveBiped.Grenade_body",
		rel = "",
		pos = Vector(-0.5, 0, -2.1),
		angle = Angle(-15.195, 180, 180),
		size = Vector(0.85, 0.85, 0.85),
		color = Color(255, 255, 255, 255),
		surpresslightning = false,
		material = "",
		skin = 2,
		bodygroup = {}
	}
}

SWEP.WElements = {
	["element_name"] = {
		type = "Model",
		model = "models/rebs/icikiler_sigaralar/sigara_paket_beyaz_dal.mdl",
		bone = "ValveBiped.Bip01_R_Hand",
		rel = "",
		pos = Vector(3.6, 2.6, -1.3),
		angle = Angle(-26.883, 178.83, 180),
		size = Vector(1.1, 1.1, 1.1),
		color = Color(255, 255, 255, 255),
		surpresslightning = false,
		material = "",
		skin = 2,
		bodygroup = {}
	}
}

SWEP.IronSightsPos = Vector(0, 0, 0)
SWEP.IronSightsAng = Vector(0, 0, 0)
local ShootSound = Sound("physics/cardboard/cardboard_box_impact_soft7.wav")

function SWEP:PrimaryAttack()
	if (not SERVER) then return end
	self:SetNextPrimaryFire(CurTime() + 1.50)
	self:EmitSound(ShootSound)

	timer.Simple(0.3, function()
		self:EmitSound("weapons/smg1/switch_single.wav")
	end)

	local type = "_dal_beyaz"
	local class = "weapon_ciga" .. type

	local owner = self:GetOwner()
	owner:Give(class)

	owner:SelectWeapon(class)

	timer.Simple(0.4, function()
		owner:StripWeapon("weapon_ciga_paket_winston_slender")
	end)
end

function SWEP:Deploy()
	self:SetNextPrimaryFire(CurTime() + 1)
	self:SetNextSecondaryFire(CurTime() + 1)
	self:SendWeaponAnim(ACT_VM_DRAW)

	return true
end

-- 
function SWEP:SecondaryAttack()
	return false
end

function SWEP:Reload()
	return false
end

--[[*******************************************************
	SWEP Construction Kit base code
		Created by Clavus
	Available for public use, thread at:
	   facepunch.com/threads/1032378

	DESCRIPTION:
		This script is meant for experienced scripters 
		that KNOW WHAT THEY ARE DOING. Don't come to me 
		with basic Lua questions.

		Just copy into your SWEP or SWEP base of choice
		and merge with your own code.

		The SWEP.VElements, SWEP.WElements and
		SWEP.ViewModelBoneMods tables are all optional
		and only have to be visible to the client.
*******************************************************]]
function SWEP:Initialize()
	-- other initialize code goes here
	self:SetHoldType(self.HoldType)
	if CLIENT then
		-- Create a new table for every weapon instance
		self.VElements = table.FullCopy(self.VElements)
		self.WElements = table.FullCopy(self.WElements)
		self.ViewModelBoneMods = table.FullCopy(self.ViewModelBoneMods)
		self:CreateModels(self.VElements) -- create viewmodels
		self:CreateModels(self.WElements) -- create worldmodels

		-- init view model bone build function
		local owner = self:GetOwner()

		if IsValid(owner) then
			local vm = owner:GetViewModel()

			if IsValid(vm) then
				self:ResetBonePositions(vm)

				-- Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255, 255, 255, 255))
				else
					-- we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255, 255, 255, 1))
					-- ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					-- however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")
				end
			end
		end
	end
end

function SWEP:Holster()
	local owner = self:GetOwner()

	if CLIENT and IsValid(owner) then
		local vm = owner:GetViewModel()

		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end

	return true
end

function SWEP:OnRemove()
	self:Holster()
end

if CLIENT then
	SWEP.vRenderOrder = nil

	function SWEP:ViewModelDrawn()
		local vm = self:GetOwner():GetViewModel()
		if not IsValid(vm) then return end
		if (not self.VElements) then return end
		self:UpdateBonePositions(vm)

		if (not self.vRenderOrder) then
			-- we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs(self.VElements) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
		end

		for k, name in ipairs(self.vRenderOrder) do
			local v = self.VElements[name]

			if (not v) then
				self.vRenderOrder = nil
				break
			end

			if (v.hide) then continue end
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			if (not v.bone) then continue end
			local pos, ang = self:GetBoneOrientation(self.VElements, v, vm)
			if (not pos) then continue end

			if (v.type == "Model" and IsValid(model)) then
				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z)
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				model:SetAngles(ang)
				--model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix("RenderMultiply", matrix)

				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() ~= v.material) then
					model:SetMaterial(v.material)
				end

				if (v.skin and v.skin ~= model:GetSkin()) then
					model:SetSkin(v.skin)
				end

				if (v.bodygroup) then
					for kk, vv in pairs(v.bodygroup) do
						if (model:GetBodygroup(k) ~= v) then
							model:SetBodygroup(k, v)
						end
					end
				end

				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end

				render.SetColorModulation(v.color.r / 255, v.color.g / 255, v.color.b / 255)
				render.SetBlend(v.color.a / 255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)

				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
			elseif (v.type == "Sprite" and sprite) then
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
			elseif (v.type == "Quad" and v.draw_func) then
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				cam.Start3D2D(drawpos, ang, v.size)
				v.draw_func(self)
				cam.End3D2D()
			end
		end
	end

	SWEP.wRenderOrder = nil

	function SWEP:DrawWorldModel()
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end

		if (not self.WElements) then return end

		if (not self.wRenderOrder) then
			self.wRenderOrder = {}

			for k, v in pairs(self.WElements) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end
		end

		local owner = self:GetOwner()

		if (IsValid(owner)) then
			bone_ent = owner
		else
			-- when the weapon is dropped
			bone_ent = self
		end

		for k, name in pairs(self.wRenderOrder) do
			local v = self.WElements[name]

			if (not v) then
				self.wRenderOrder = nil
				break
			end

			if (v.hide) then continue end
			local pos, ang

			if (v.bone) then
				pos, ang = self:GetBoneOrientation(self.WElements, v, bone_ent)
			else
				pos, ang = self:GetBoneOrientation(self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand")
			end

			if (not pos) then continue end
			local model = v.modelEnt
			local sprite = v.spriteMaterial

			if (v.type == "Model" and IsValid(model)) then
				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z)
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				model:SetAngles(ang)
				--model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix("RenderMultiply", matrix)

				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() ~= v.material) then
					model:SetMaterial(v.material)
				end

				if (v.skin and v.skin ~= model:GetSkin()) then
					model:SetSkin(v.skin)
				end

				if (v.bodygroup) then
					for kk, vv in pairs(v.bodygroup) do
						if (model:GetBodygroup(k) ~= v) then
							model:SetBodygroup(k, v)
						end
					end
				end

				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end

				render.SetColorModulation(v.color.r / 255, v.color.g / 255, v.color.b / 255)
				render.SetBlend(v.color.a / 255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)

				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
			elseif (v.type == "Sprite" and sprite) then
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
			elseif (v.type == "Quad" and v.draw_func) then
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				cam.Start3D2D(drawpos, ang, v.size)
				v.draw_func(self)
				cam.End3D2D()
			end
		end
	end

	function SWEP:GetBoneOrientation(basetab, tab, ent, bone_override)
		local bone, pos, ang

		if (tab.rel and tab.rel ~= "") then
			local v = basetab[tab.rel]
			if (not v) then return end
			-- Technically, if there exists an element with the same name as a bone
			-- you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation(basetab, v, ent)
			if (not pos) then return end
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
		else
			bone = ent:LookupBone(bone_override or tab.bone)
			if (not bone) then return end
			pos, ang = Vector(0, 0, 0), Angle(0, 0, 0)
			local m = ent:GetBoneMatrix(bone)

			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end

			local owner = self:GetOwner()

			if (IsValid(owner) and owner:IsPlayer() and ent == owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r -- Fixes mirrored models
			end
		end

		return pos, ang
	end

	function SWEP:CreateModels(tab)
		if (not tab) then return end

		-- Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs(tab) do
			if (v.type == "Model" and v.model and v.model ~= "" and (not IsValid(v.modelEnt) or v.createdModel ~= v.model) and string.find(v.model, ".mdl") and file.Exists(v.model, "GAME")) then
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)

				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
			elseif (v.type == "Sprite" and v.sprite and v.sprite ~= "" and (not v.spriteMaterial or v.createdSprite ~= v.sprite) and file.Exists("materials/" .. v.sprite .. ".vmt", "GAME")) then
				local name = v.sprite .. "-"

				local params = {
					["$basetexture"] = v.sprite
				}

				-- make sure we create a unique name based on the selected options
				local tocheck = {"nocull", "additive", "vertexalpha", "vertexcolor", "ignorez"}

				for i, j in pairs(tocheck) do
					if (v[j]) then
						params["$" .. j] = 1
						name = name .. "1"
					else
						name = name .. "0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name, "UnlitGeneric", params)
			end
		end
	end

	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		if self.ViewModelBoneMods then
			if (not vm:GetBoneCount()) then return end
			-- !! WORKAROUND !! //
			-- We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods

			if (not hasGarryFixedBoneScalingYet) then
				allbones = {}

				for i = 0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)

					if (self.ViewModelBoneMods[bonename]) then
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = {
							scale = Vector(1, 1, 1),
							pos = Vector(0, 0, 0),
							angle = Angle(0, 0, 0)
						}
					end
				end

				loopthrough = allbones
			end

			-- !! ----------- !! //
			for k, v in pairs(loopthrough) do
				local bone = vm:LookupBone(k)
				if (not bone) then continue end
				-- !! WORKAROUND !! //
				local s = Vector(v.scale.x, v.scale.y, v.scale.z)
				local p = Vector(v.pos.x, v.pos.y, v.pos.z)
				local ms = Vector(1, 1, 1)

				if (not hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)

					while (cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end

				s = s * ms

				-- !! ----------- !! //
				if vm:GetManipulateBoneScale(bone) ~= s then
					vm:ManipulateBoneScale(bone, s)
				end

				if vm:GetManipulateBoneAngles(bone) ~= v.angle then
					vm:ManipulateBoneAngles(bone, v.angle)
				end

				if vm:GetManipulateBonePosition(bone) ~= p then
					vm:ManipulateBonePosition(bone, p)
				end
			end
		else
			self:ResetBonePositions(vm)
		end
	end

	function SWEP:ResetBonePositions(vm)
		if (not vm:GetBoneCount()) then return end

		for i = 0, vm:GetBoneCount() do
			vm:ManipulateBoneScale(i, Vector(1, 1, 1))
			vm:ManipulateBoneAngles(i, Angle(0, 0, 0))
			vm:ManipulateBonePosition(i, Vector(0, 0, 0))
		end
	end

	--[[*************************
		Global utility code
	*************************]]
	-- Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	-- Does not copy entities of course, only copies their reference.
	-- WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy(tab)
		if (not tab) then return nil end
		local res = {}

		for k, v in pairs(tab) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) -- recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end

		return res
	end
end

--addons/[binbon]misc/lua/weapons/weapon_ciga_paket_winston_slender.lua:
-- MODEL WITH UNKNOWN AUTHOR! PM ME!!! QUICK :D -- 
-- Backdoors removed by Seefox (https://steamcommunity.com/id/seef0x/)

SWEP.PrintName = "Winston Slender Blue"
SWEP.Author = "RebS"
SWEP.Purpose = "Pick one out."

SWEP.Category = "Turkish Haram Mod Sigara"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo		= "none"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= false
SWEP.Secondary.Ammo		= "none"

SWEP.HoldType = "slam"
SWEP.ViewModelFOV = 49.849246231156
SWEP.ViewModelFlip = false
SWEP.ViewModel = "models/weapons/c_grenade.mdl"
SWEP.WorldModel = "models/rebs/icikiler_sigaralar/sigara_paket_beyaz_dal.mdl"
SWEP.UseHands = true
SWEP.ShowViewModel = true
SWEP.ShowWorldModel = false
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false

SWEP.ViewModelBoneMods = {
	["ValveBiped.Grenade_body"] = {
		scale = Vector(0.009, 0.009, 0.009),
		pos = Vector(0, 0, 0),
		angle = Angle(0, 0, 0)
	}
}

SWEP.VElements = {
	["element_name"] = {
		type = "Model",
		model = "models/rebs/icikiler_sigaralar/sigara_paket_beyaz_dal.mdl",
		bone = "ValveBiped.Grenade_body",
		rel = "",
		pos = Vector(-0.5, 0, -2.1),
		angle = Angle(-15.195, 180, 180),
		size = Vector(0.85, 0.85, 0.85),
		color = Color(255, 255, 255, 255),
		surpresslightning = false,
		material = "",
		skin = 1,
		bodygroup = {}
	}
}

SWEP.WElements = {
	["element_name"] = {
		type = "Model",
		model = "models/rebs/icikiler_sigaralar/sigara_paket_beyaz_dal.mdl",
		bone = "ValveBiped.Bip01_R_Hand",
		rel = "",
		pos = Vector(3.6, 2.6, -1.3),
		angle = Angle(-26.883, 178.83, 180),
		size = Vector(1.1, 1.1, 1.1),
		color = Color(255, 255, 255, 255),
		surpresslightning = false,
		material = "",
		skin = 1,
		bodygroup = {}
	}
}

SWEP.IronSightsPos = Vector(0, 0, 0)
SWEP.IronSightsAng = Vector(0, 0, 0)
local ShootSound = Sound("physics/cardboard/cardboard_box_impact_soft7.wav")

function SWEP:PrimaryAttack()
	if (not SERVER) then return end
	self:SetNextPrimaryFire(CurTime() + 1.50)
	self:EmitSound(ShootSound)

	timer.Simple(0.3, function()
		self:EmitSound("weapons/smg1/switch_single.wav")
	end)

	local type = "_dal_beyaz"
	local class = "weapon_ciga" .. type

	local owner = self:GetOwner()
	owner:Give(class)

	owner:SelectWeapon(class)

	timer.Simple(0.4, function()
		owner:StripWeapon("weapon_ciga_paket_winston_slender")
	end)
end

function SWEP:Deploy()
	self:SetNextPrimaryFire(CurTime() + 1)
	self:SetNextSecondaryFire(CurTime() + 1)
	self:SendWeaponAnim(ACT_VM_DRAW)

	return true
end

-- 
function SWEP:SecondaryAttack()
	return false
end

function SWEP:Reload()
	return false
end

--[[*******************************************************
	SWEP Construction Kit base code
		Created by Clavus
	Available for public use, thread at:
	   facepunch.com/threads/1032378

	DESCRIPTION:
		This script is meant for experienced scripters 
		that KNOW WHAT THEY ARE DOING. Don't come to me 
		with basic Lua questions.

		Just copy into your SWEP or SWEP base of choice
		and merge with your own code.

		The SWEP.VElements, SWEP.WElements and
		SWEP.ViewModelBoneMods tables are all optional
		and only have to be visible to the client.
*******************************************************]]
function SWEP:Initialize()
	-- other initialize code goes here
	self:SetHoldType(self.HoldType)
	if CLIENT then
		-- Create a new table for every weapon instance
		self.VElements = table.FullCopy(self.VElements)
		self.WElements = table.FullCopy(self.WElements)
		self.ViewModelBoneMods = table.FullCopy(self.ViewModelBoneMods)
		self:CreateModels(self.VElements) -- create viewmodels
		self:CreateModels(self.WElements) -- create worldmodels

		-- init view model bone build function
		local owner = self:GetOwner()

		if IsValid(owner) then
			local vm = owner:GetViewModel()

			if IsValid(vm) then
				self:ResetBonePositions(vm)

				-- Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255, 255, 255, 255))
				else
					-- we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255, 255, 255, 1))
					-- ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					-- however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")
				end
			end
		end
	end
end

function SWEP:Holster()
	local owner = self:GetOwner()

	if CLIENT and IsValid(owner) then
		local vm = owner:GetViewModel()

		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end

	return true
end

function SWEP:OnRemove()
	self:Holster()
end

if CLIENT then
	SWEP.vRenderOrder = nil

	function SWEP:ViewModelDrawn()
		local vm = self:GetOwner():GetViewModel()
		if not IsValid(vm) then return end
		if (not self.VElements) then return end
		self:UpdateBonePositions(vm)

		if (not self.vRenderOrder) then
			-- we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs(self.VElements) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
		end

		for k, name in ipairs(self.vRenderOrder) do
			local v = self.VElements[name]

			if (not v) then
				self.vRenderOrder = nil
				break
			end

			if (v.hide) then continue end
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			if (not v.bone) then continue end
			local pos, ang = self:GetBoneOrientation(self.VElements, v, vm)
			if (not pos) then continue end

			if (v.type == "Model" and IsValid(model)) then
				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z)
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				model:SetAngles(ang)
				--model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix("RenderMultiply", matrix)

				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() ~= v.material) then
					model:SetMaterial(v.material)
				end

				if (v.skin and v.skin ~= model:GetSkin()) then
					model:SetSkin(v.skin)
				end

				if (v.bodygroup) then
					for kk, vv in pairs(v.bodygroup) do
						if (model:GetBodygroup(k) ~= v) then
							model:SetBodygroup(k, v)
						end
					end
				end

				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end

				render.SetColorModulation(v.color.r / 255, v.color.g / 255, v.color.b / 255)
				render.SetBlend(v.color.a / 255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)

				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
			elseif (v.type == "Sprite" and sprite) then
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
			elseif (v.type == "Quad" and v.draw_func) then
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				cam.Start3D2D(drawpos, ang, v.size)
				v.draw_func(self)
				cam.End3D2D()
			end
		end
	end

	SWEP.wRenderOrder = nil

	function SWEP:DrawWorldModel()
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end

		if (not self.WElements) then return end

		if (not self.wRenderOrder) then
			self.wRenderOrder = {}

			for k, v in pairs(self.WElements) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end
		end

		local owner = self:GetOwner()

		if (IsValid(owner)) then
			bone_ent = owner
		else
			-- when the weapon is dropped
			bone_ent = self
		end

		for k, name in pairs(self.wRenderOrder) do
			local v = self.WElements[name]

			if (not v) then
				self.wRenderOrder = nil
				break
			end

			if (v.hide) then continue end
			local pos, ang

			if (v.bone) then
				pos, ang = self:GetBoneOrientation(self.WElements, v, bone_ent)
			else
				pos, ang = self:GetBoneOrientation(self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand")
			end

			if (not pos) then continue end
			local model = v.modelEnt
			local sprite = v.spriteMaterial

			if (v.type == "Model" and IsValid(model)) then
				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z)
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				model:SetAngles(ang)
				--model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix("RenderMultiply", matrix)

				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() ~= v.material) then
					model:SetMaterial(v.material)
				end

				if (v.skin and v.skin ~= model:GetSkin()) then
					model:SetSkin(v.skin)
				end

				if (v.bodygroup) then
					for kk, vv in pairs(v.bodygroup) do
						if (model:GetBodygroup(k) ~= v) then
							model:SetBodygroup(k, v)
						end
					end
				end

				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end

				render.SetColorModulation(v.color.r / 255, v.color.g / 255, v.color.b / 255)
				render.SetBlend(v.color.a / 255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)

				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
			elseif (v.type == "Sprite" and sprite) then
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
			elseif (v.type == "Quad" and v.draw_func) then
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				cam.Start3D2D(drawpos, ang, v.size)
				v.draw_func(self)
				cam.End3D2D()
			end
		end
	end

	function SWEP:GetBoneOrientation(basetab, tab, ent, bone_override)
		local bone, pos, ang

		if (tab.rel and tab.rel ~= "") then
			local v = basetab[tab.rel]
			if (not v) then return end
			-- Technically, if there exists an element with the same name as a bone
			-- you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation(basetab, v, ent)
			if (not pos) then return end
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
		else
			bone = ent:LookupBone(bone_override or tab.bone)
			if (not bone) then return end
			pos, ang = Vector(0, 0, 0), Angle(0, 0, 0)
			local m = ent:GetBoneMatrix(bone)

			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end

			local owner = self:GetOwner()

			if (IsValid(owner) and owner:IsPlayer() and ent == owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r -- Fixes mirrored models
			end
		end

		return pos, ang
	end

	function SWEP:CreateModels(tab)
		if (not tab) then return end

		-- Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs(tab) do
			if (v.type == "Model" and v.model and v.model ~= "" and (not IsValid(v.modelEnt) or v.createdModel ~= v.model) and string.find(v.model, ".mdl") and file.Exists(v.model, "GAME")) then
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)

				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
			elseif (v.type == "Sprite" and v.sprite and v.sprite ~= "" and (not v.spriteMaterial or v.createdSprite ~= v.sprite) and file.Exists("materials/" .. v.sprite .. ".vmt", "GAME")) then
				local name = v.sprite .. "-"

				local params = {
					["$basetexture"] = v.sprite
				}

				-- make sure we create a unique name based on the selected options
				local tocheck = {"nocull", "additive", "vertexalpha", "vertexcolor", "ignorez"}

				for i, j in pairs(tocheck) do
					if (v[j]) then
						params["$" .. j] = 1
						name = name .. "1"
					else
						name = name .. "0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name, "UnlitGeneric", params)
			end
		end
	end

	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		if self.ViewModelBoneMods then
			if (not vm:GetBoneCount()) then return end
			-- !! WORKAROUND !! //
			-- We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods

			if (not hasGarryFixedBoneScalingYet) then
				allbones = {}

				for i = 0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)

					if (self.ViewModelBoneMods[bonename]) then
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = {
							scale = Vector(1, 1, 1),
							pos = Vector(0, 0, 0),
							angle = Angle(0, 0, 0)
						}
					end
				end

				loopthrough = allbones
			end

			-- !! ----------- !! //
			for k, v in pairs(loopthrough) do
				local bone = vm:LookupBone(k)
				if (not bone) then continue end
				-- !! WORKAROUND !! //
				local s = Vector(v.scale.x, v.scale.y, v.scale.z)
				local p = Vector(v.pos.x, v.pos.y, v.pos.z)
				local ms = Vector(1, 1, 1)

				if (not hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)

					while (cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end

				s = s * ms

				-- !! ----------- !! //
				if vm:GetManipulateBoneScale(bone) ~= s then
					vm:ManipulateBoneScale(bone, s)
				end

				if vm:GetManipulateBoneAngles(bone) ~= v.angle then
					vm:ManipulateBoneAngles(bone, v.angle)
				end

				if vm:GetManipulateBonePosition(bone) ~= p then
					vm:ManipulateBonePosition(bone, p)
				end
			end
		else
			self:ResetBonePositions(vm)
		end
	end

	function SWEP:ResetBonePositions(vm)
		if (not vm:GetBoneCount()) then return end

		for i = 0, vm:GetBoneCount() do
			vm:ManipulateBoneScale(i, Vector(1, 1, 1))
			vm:ManipulateBoneAngles(i, Angle(0, 0, 0))
			vm:ManipulateBonePosition(i, Vector(0, 0, 0))
		end
	end

	--[[*************************
		Global utility code
	*************************]]
	-- Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	-- Does not copy entities of course, only copies their reference.
	-- WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy(tab)
		if (not tab) then return nil end
		local res = {}

		for k, v in pairs(tab) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) -- recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end

		return res
	end
end

--lua/weapons/weapon_csgo_knife_default_t.lua:
if SERVER then
	SWEP.Weight				= 5
	SWEP.AutoSwitchTo		= false
	SWEP.AutoSwitchFrom		= false
end

if CLIENT then							
	SWEP.Slot				= SWEP.WeaponSlot or 0
	SWEP.SlotPos			= 0
	SWEP.ViewModelFOV		= 60
	SWEP.DrawCrosshair		= true
end

SWEP.Base					= "weapon_csgobase_knife"

SWEP.PrintName				= "Default T Knife"
SWEP.Category				= "CS:GO Knives"
SWEP.Spawnable				= true
SWEP.AdminOnly				= false
SWEP.ViewModel				= Model( "models/weapons/knife_default_t/v_default_t.mdl" )
SWEP.WorldModel				= Model( "models/weapons/knife_default_t/w_default_t.mdl" )
SWEP.HoldType				= "knife"
--lua/weapons/weapon_csgo_knife_karambit.lua:
if SERVER then
	SWEP.Weight				= 5
	SWEP.AutoSwitchTo		= false
	SWEP.AutoSwitchFrom		= false
end

if CLIENT then							
	SWEP.Slot				= SWEP.WeaponSlot or 0
	SWEP.SlotPos			= 0
	SWEP.ViewModelFOV		= 60
	SWEP.DrawCrosshair		= true
end

SWEP.Base					= "weapon_csgobase_knife"

SWEP.PrintName				= "Karambit"
SWEP.Category				= "CS:GO Knives"
SWEP.Spawnable				= true
SWEP.AdminOnly				= false
SWEP.ViewModel				= Model( "models/weapons/knife_karambit/v_karambit.mdl" )
SWEP.WorldModel				= Model( "models/weapons/knife_karambit/w_karambit.mdl" )
SWEP.HoldType				= "knife"
--lua/weapons/weapon_csgo_knife_push.lua:
sound.Add( { name = "Weapon_Push.Draw", channel = CHAN_ITEM, volume = 0.20, level = SNDLVL_NORM, sound = "weapons/knife_push/draw.wav" } )
sound.Add( { name = "Weapon_Push.LookEnd", channel = CHAN_ITEM, volume = 0.20, level = SNDLVL_NORM, sound = "weapons/knife_push/lookend.wav" } )
sound.Add( { name = "Weapon_Push.LookStart", channel = CHAN_ITEM, volume = 0.20, level = SNDLVL_NORM, sound = "weapons/knife_push/lookstart.wav" } )
sound.Add( { 
  name = "Weapon_Push.Heavy",
  channel = CHAN_ITEM,
  volume = 0.20,
  level = SNDLVL_NORM,
  sound = { 
    "weapons/knife_push/heavy01.wav",
	"weapons/knife_push/heavy02.wav",
	"weapons/knife_push/heavy03.wav",
	"weapons/knife_push/heavy04.wav"
  }
} )


if SERVER then
	SWEP.Weight				= 5
	SWEP.AutoSwitchTo		= false
	SWEP.AutoSwitchFrom		= false
end

if CLIENT then							
	SWEP.Slot				= SWEP.WeaponSlot or 0
	SWEP.SlotPos			= 0
	SWEP.ViewModelFOV		= 60
	SWEP.DrawCrosshair		= true
end

SWEP.Base					= "weapon_csgobase_knife"

SWEP.PrintName				= "Shadow Daggers"
SWEP.Category				= "CS:GO Knives"
SWEP.Spawnable				= true
SWEP.AdminOnly				= false
SWEP.ViewModel				= Model( "models/weapons/knife_push/v_push.mdl" )
SWEP.WorldModel				= Model( "models/weapons/knife_push/w_push.mdl" )
SWEP.HoldType				= "fist"
--lua/weapons/weapon_csgo_knife_talon.lua:
sound.Add( { 
  name = "Weapon_Talon.Loop",
  channel = CHAN_ITEM,
  volume = 0.20,
  level = SNDLVL_NORM,
  sound = { 
    "weapons/knife_talon/loop01.wav",
	"weapons/knife_talon/loop02.wav",
	"weapons/knife_talon/loop03.wav",
	"weapons/knife_talon/loop04.wav"
  }
} )
sound.Add( { name = "Weapon_Talon.LookStart", channel = CHAN_ITEM, volume = 0.20, level = SNDLVL_NORM, sound = "weapons/knife_talon/lookstart.wav" } )
sound.Add( { name = "Weapon_Talon.LookEnd", channel = CHAN_ITEM, volume = 0.20, level = SNDLVL_NORM, sound = "weapons/knife_talon/lookend.wav" } )
sound.Add( { name = "Weapon_Talon.Draw", channel = CHAN_ITEM, volume = 0.20, level = SNDLVL_NORM, sound = "weapons/knife_talon/draw.wav" } )



if SERVER then
	SWEP.Weight				= 5
	SWEP.AutoSwitchTo		= false
	SWEP.AutoSwitchFrom		= false
end

if CLIENT then							
	SWEP.Slot				= SWEP.WeaponSlot or 0
	SWEP.SlotPos			= 0
	SWEP.ViewModelFOV		= 60
	SWEP.DrawCrosshair		= true
end

SWEP.Base					= "weapon_csgobase_knife"

SWEP.PrintName				= "Talon Knife"
SWEP.Category				= "CS:GO Knives"
SWEP.Spawnable				= true
SWEP.AdminOnly				= false
SWEP.ViewModel				= Model( "models/weapons/knife_talon/v_talon.mdl" )
SWEP.WorldModel				= Model( "models/weapons/knife_talon/w_talon.mdl" )
SWEP.HoldType				= "knife"
--lua/weapons/weapon_csgobase_knife.lua:
return gluapack()()
--lua/weapons/weapon_gasolinepistol/cl_init.lua:
include("shared.lua")

SWEP.pViewModel = ClientsideModel("models/props_equipment/gas_pump_p13.mdl", RENDERGROUP_OPAQUE)
SWEP.pViewModel:SetNoDraw(true)

-- local cable = Material( "cable/cable2" )

-- local function bezier(p0, p1, p2, p3, t)
-- 	local e = p0 + t * (p1 - p0)
-- 	local f = p1 + t * (p2 - p1)
-- 	local g = p2 + t * (p3 - p2)

-- 	local h = e + t * (f - e)
-- 	local i = f + t * (g - f)

-- 	local p = h + t * (i - h)

-- 	return p
-- end

function SWEP:PrimaryAttack()

end

function SWEP:StartFilling(veh)
	net.Start("SV_StartFilling")
	net.WriteEntity(veh)
	net.SendToServer()
end

function SWEP:StopFilling(veh)
	net.Start("SV_StopFilling")
	net.WriteEntity(veh)
	net.SendToServer()

	hook.Remove("Think", "SV_FillerPistol_" .. self:EntIndex())
end

function SWEP:DrawCable()
	-- local ply = self:GetOwner()

	-- local fuelPump = self:GetNWEntity("SV_FuelPump")
	-- if not IsValid(fuelPump) then
	-- 	return
	-- end

	-- local id = ply:LookupAttachment("anim_attachment_rh")
	-- local attachment = ply:GetAttachment( id )

	-- if not attachment then return end

	-- local a, b = self:GetModelBounds()

	-- local startPos = fuelPump:LocalToWorld((b + a) / 2 + Vector(0, 0, 50))
	-- local p2 = fuelPump:LocalToWorld((b + a) / 2)
	-- local endPos = (attachment.Pos + attachment.Ang:Forward() * -3 + attachment.Ang:Right() * 2 + attachment.Ang:Up() * -3.5)
	-- local p3 = endPos + attachment.Ang:Right() * 5 - attachment.Ang:Up() * 20

	-- for i = 1,10 do
	-- 	local active = IsValid( ply )

	-- 	local de = active and 1 or 2

	-- 	if (not active and i > 1) or active then

	-- 		local sp = bezier(startPos, p2, p3, endPos, (i - de) / 10)
	-- 		local ep = bezier(startPos, p2, p3, endPos, i / 10)

	-- 		render.SetMaterial( cable )
	-- 		render.DrawBeam( sp, ep, 2, 1, 1, Color( 100, 100, 100, 255 ) )
	-- 	end
	-- end
end

-- function SWEP:ViewModelDrawn()
-- 	if IsValid(self.Owner) then

-- 		local ZOOM = self.Owner:KeyDown( IN_ZOOM )

-- 		self.ViewModelFOV = ZOOM and 30 or 10

-- 		if ZOOM then return end

-- 		local vm = self.Owner:GetViewModel()
-- 		local bm = vm:GetBoneMatrix(0)
-- 		local pos =  bm:GetTranslation()
-- 		local ang =  bm:GetAngles()

-- 		pos = pos + ang:Up() * 220
-- 		pos = pos + ang:Right() * 2
-- 		pos = pos + ang:Forward() * -12

-- 		ang:RotateAroundAxis(ang:Forward(), -85)
-- 		ang:RotateAroundAxis(ang:Right(), -20)
-- 		ang:RotateAroundAxis(ang:Up(), -70)

-- 		self.pViewModel:SetPos(pos)
-- 		self.pViewModel:SetAngles(ang)
-- 		self.pViewModel:DrawModel()

-- 		self:DrawCable()
-- 	end
-- end

-- function SWEP:DrawWorldModel()
-- 	if not IsValid(self.Owner) then return end

-- 	local id = self.Owner:LookupAttachment("anim_attachment_rh")
-- 	local attachment = self.Owner:GetAttachment( id )

-- 	if not attachment then return end

-- 	local pos = attachment.Pos + attachment.Ang:Forward() * 6 + attachment.Ang:Right() * -1.5 + attachment.Ang:Up() * 2.2
-- 	local ang = attachment.Ang
-- 	ang:RotateAroundAxis(attachment.Ang:Up(), 20)
-- 	ang:RotateAroundAxis(attachment.Ang:Right(), -30)
-- 	ang:RotateAroundAxis(attachment.Ang:Forward(), 0)

-- 	self:SetRenderOrigin( pos )
-- 	self:SetRenderAngles( ang )

-- 	self:DrawModel()

-- 	self:DrawCable()
-- end
--addons/sh_keypadcracker/lua/weapons/weapon_sh_keypadcracker_deploy.lua:
AddCSLuaFile()

if (CLIENT) then
	SWEP.PrintName = "Deployable Keypad Cracker"
	SWEP.Instructions = "Stick on Keypad."
	SWEP.Purpose = "A deployable tool which can be attached to a Keypad. This tool will attempt to crack the Keypad, granting access."
	SWEP.WepSelectIcon = surface.GetTextureID("weapons/weapon_sh_keypadcracker_deploy")
	SWEP.BounceWeaponIcon = false
	SWEP.DrawWeaponInfoBox = true
	SWEP.Slot = 5
	SWEP.SlotPos = 4
end

SWEP.Category = "SH Weapons"
SWEP.Spawnable = true

SWEP.UseHands = true

SWEP.ViewModel = "models/weapons/cstrike/c_c4.mdl"
SWEP.ViewModelFOV = 54
SWEP.WorldModel = "models/weapons/w_c4.mdl"

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

function SWEP:Initialize()
	self:SetHoldType("slam")
	self:SetDeploySpeed(1)
end

function SWEP:Holster()
	self:OnDrop()
	return true
end

function SWEP:OwnerChanged()
	self:OnDrop()
end

function SWEP:Deploy()
	self:OnDrop()
end

function SWEP:OnDrop()
	if (SERVER and self.m_bUsed) then
		self:Remove()
		return
	end

	self.m_eTargetKeypad = nil
	self.m_fDeploying = nil
	self.m_iDeployStage = nil
end

function SWEP:CancelPlanting()
	self:OnDrop()
	self:SendWeaponAnim(ACT_VM_DRAW)
end

function SWEP:Think()
	if (self.m_fDeploying) then
		local ply = self.Owner
		if (!IsValid(ply)) then
			return end

		local ent = self.m_eTargetKeypad
		local sp = ply:GetShootPos()

		if (!IsValid(ent)) then
			self:CancelPlanting()
			return
		end

		local t = {
			start = sp,
			endpos = sp + ply:GetAimVector() * 48,
			mask = MASK_SHOT,
			filter = ply
		}
		local tr = util.TraceLine(t)

		if (tr.Entity ~= ent) then
			self:CancelPlanting()
			return
		end

		if (CurTime() >= self.m_fDeploying) then
			if (self.m_iDeployStage == 1) then
				self:SendWeaponAnim(ACT_VM_SECONDARYATTACK)
				self.m_iDeployStage = 2
				self.m_fDeploying = CurTime() + 0.7
			elseif (self.m_iDeployStage == 2) then
				if (SERVER) then
					self:CreateCracker(ply, ent)
					self:Remove()
				end
			end
		end
	end
end

function SWEP:PrimaryAttack()
	if (self.m_fDeploying) then
		return end

	local ply = self.Owner
	local sp = ply:GetShootPos()

	local t = {
		start = sp,
		endpos = sp + ply:GetAimVector() * 48,
		mask = MASK_SHOT,
		filter = ply
	}
	local tr = util.TraceLine(t)
	local ent = tr.Entity
	if (!IsValid(ent)) then
		if (CLIENT) then
			self:PlayDenySound()
		end

		return 
	end

	local cls = ent:GetClass():lower()
	if ((ent.IsKeypad or cls == "keypad" or cls == "uni_keypad") and !IsValid(ent:GetNWEntity("KEYPADCRACKER", NULL))) then
		self:SendWeaponAnim(ACT_VM_PRIMARYATTACK)

		self.m_eTargetKeypad = ent
		self.m_iDeployStage = 1
		self.m_fDeploying = CurTime() + 2.55
	else
		if (CLIENT) then
			self:PlayDenySound()
		end
	end
end

function SWEP:SecondaryAttack()
end

if (SERVER) then
	function SWEP:CreateCracker(ply, keypad)
		local ang = keypad:GetForward():Angle()
		ang:RotateAroundAxis(ang:Forward(), 90)
		ang:RotateAroundAxis(ang:Right(), -90)

		local ent = ents.Create("prop_sh_keypadcracker")
		ent:SetModelScale(0.5, 0)
		ent:SetPos(keypad:GetPos() - ang:Right() - ang:Forward() * 0.75)
		ent:SetParent(keypad)
		ent:SetAngles(ang)
		ent:Spawn()
		keypad:SetNWEntity("KEYPADCRACKER", ent)
	end
else
	surface.CreateFont("SH_KEYPADCRACKER_LARGE", {font = "roboto", size = 100, weight = 1000})
	surface.CreateFont("SH_KEYPADCRACKER_MEDIUM", {font = "roboto", size = 75, weight = 1000})

	function SWEP:PostDrawViewModel(vm)
		if (!IsValid(vm)) then
			return end

		local bone = vm:LookupBone("v_weapon.c4")
		if (!bone) then
			return end

		local pos, ang = vm:GetBonePosition(bone)
		if (!pos) then
			return end

		ang:RotateAroundAxis(ang:Right(), 180)
		ang:RotateAroundAxis(ang:Forward(), -90)

		cam.Start3D2D(pos - ang:Right() * 0.75 + ang:Up() * 3.6 + ang:Forward() * 4.33, ang, 0.005)
			draw.SimpleTextOutlined("Deployable", "SH_KEYPADCRACKER_LARGE", 0, -100, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 4, color_black)
			draw.SimpleTextOutlined("Keypad Cracker", "SH_KEYPADCRACKER_LARGE", 0, 0, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 4, color_black)
			draw.SimpleTextOutlined(self.m_fDeploying and "Deploying..." or "Deploy on Keypad", "SH_KEYPADCRACKER_MEDIUM", 0, 100, Color(125, 125, 125), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 4, color_black)
		cam.End3D2D()
	end

	function SWEP:PlayDenySound()
		surface.PlaySound("common/wpn_denyselect.wav")
	end
end
--addons/vape_swep/lua/weapons/weapon_vape_dragon.lua:
return gluapack()()
--addons/vape_swep/lua/weapons/weapon_vape/shared.lua:
-- weapon_vape/shared.lua
-- Defines common shared code/defaults for Vape SWEP

-- Vape SWEP by Swamp Onions - http://steamcommunity.com/id/swamponions/

SWEP.Author = "Swamp Onions"

SWEP.Instructions = "LMB: Rip Fat Clouds\n (Hold and release)\nRMB & Reload: Play Sounds\n\nVape Nation!"

SWEP.PrintName = "Vape"

SWEP.IconLetter	= "V"
SWEP.Category = "Vapes"
SWEP.Slot = 1
SWEP.SlotPos = 0

SWEP.ViewModelFOV = 62 --default

SWEP.WepSelectIcon = surface and surface.GetTextureID("vape_icon")
SWEP.BounceWeaponIcon = false

SWEP.ViewModel = "models/swamponions/vape.mdl"
SWEP.WorldModel = "models/swamponions/vape.mdl"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Primary.Clipsize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "none"

SWEP.Secondary.Clipsize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

SWEP.DrawAmmo = false
SWEP.HoldType = "slam"

SWEP.VapeID = 1

function SWEP:Deploy()
	self:SetHoldType("slam")
end

function SWEP:PrimaryAttack()
	if SERVER then
		VapeUpdate(self.Owner, self.VapeID)
	end
	self.Weapon:SetNextPrimaryFire(CurTime() + 0.1)
end

function SWEP:SecondaryAttack()
	if GetConVar("vape_block_sounds"):GetBool() then return end

	local pitch = 100 + (self.SoundPitchMod or 0) + (self.Owner:Crouching() and 40 or 0)
	self:EmitSound("vapegogreen.wav", 35, pitch + math.Rand(-5,5))
	if SERVER then
		net.Start("VapeTalking")
		net.WriteEntity(self.Owner)
		net.WriteFloat(CurTime() + (0.6*100/pitch))
		net.Broadcast()
	end
	self:SetNextSecondaryFire(CurTime() + 4)
end

function SWEP:Reload()
	if GetConVar("vape_block_sounds"):GetBool() then return end
	if self.beklemesuresi then 
		if self.beklemesuresi > CurTime() then 
			return 
		end 
	end 
	if self.reloading then return end
	self.reloading=true
	self.beklemesuresi = CurTime() + 5
	timer.Simple(0.5, function() self.reloading=false end)
	local pitch = 100 + (self.SoundPitchMod or 0) + (self.Owner:Crouching() and 40 or 0)
	self:EmitSound("vapenaysh.wav", 35, pitch + math.Rand(-5,5))
	if SERVER then
		net.Start("VapeTalking")
		net.WriteEntity(self.Owner)
		net.WriteFloat(CurTime() + (2.2*100/pitch))
		net.Broadcast()
	end
end

function SWEP:Holster()
	if SERVER and IsValid(self.Owner) then
		ReleaseVape(self.Owner)
	end
	return true
end

SWEP.OnDrop = SWEP.Holster
SWEP.OnRemove = SWEP.Holster
--addons/vape_swep/lua/weapons/weapon_vape/cl_init.lua:
-- weapon_vape/cl_init.lua
-- Defines common clientside code/defaults for Vape SWEP

-- Vape SWEP by Swamp Onions - http://steamcommunity.com/id/swamponions/

include('shared.lua')

function SWEP:DrawWorldModel()
	local ply = self:GetOwner()

	local vapeScale = self.VapeScale or 1
	self:SetModelScale(vapeScale, 0) 
	self:SetSubMaterial()

	if IsValid(ply) then
		local modelStr = ply:GetModel():sub(1,17)
		local isPony = modelStr=="models/ppm/player" or modelStr=="models/mlp/player" or modelStr=="models/cppm/playe"

		local bn = isPony and "LrigScull" or "ValveBiped.Bip01_R_Hand"
		if ply.vapeArmFullyUp then bn ="ValveBiped.Bip01_Head1" end
		local bon = ply:LookupBone(bn) or 0

		local opos = self:GetPos()
		local oang = self:GetAngles()
		local bp,ba = ply:GetBonePosition(bon)
		if bp then opos = bp end
		if ba then oang = ba end

		if isPony then
			--pony position
			opos = opos + (oang:Forward()*19.4) + (oang:Right()*-4.36) + (oang:Up()*-2.5)
			oang:RotateAroundAxis(oang:Right(),80)
			oang:RotateAroundAxis(oang:Forward(),12)
			oang:RotateAroundAxis(oang:Up(),20)
			opos = opos + (oang:Up()*(2.3+((vapeScale-1)*-10.25)))
		else
			if ply.vapeArmFullyUp then
				--head position
				opos = opos + (oang:Forward()*0.74) + (oang:Right()*15) + (oang:Up()*2)
				oang:RotateAroundAxis(oang:Forward(),-100)
				oang:RotateAroundAxis(oang:Up(),100)
				opos = opos + (oang:Up()*(vapeScale-1)*-10.25)
			else
				--hand position
				oang:RotateAroundAxis(oang:Forward(),90)
				oang:RotateAroundAxis(oang:Right(),90)
				opos = opos + (oang:Forward()*2) + (oang:Up()*-4.5) + (oang:Right()*-2)
				oang:RotateAroundAxis(oang:Forward(),69)
				oang:RotateAroundAxis(oang:Up(),10)
				opos = opos + (oang:Up()*(vapeScale-1)*-10.25)
				if self:GetClass()=="weapon_vape_butterfly" then
					opos = opos + (oang:Up()*6)
					oang:RotateAroundAxis(oang:Right(),Lerp(ply.vapeArmUpAmt or 0,0,-360))
					opos = opos + (oang:Up()*-6)
				end
			end
		end
		self:SetupBones()

		local mrt = self:GetBoneMatrix(0)
		if mrt then
		mrt:SetTranslation(opos)
		mrt:SetAngles(oang)

		self:SetBoneMatrix(0, mrt)
		end
	end

	self:DrawModel()
end

function SWEP:GetViewModelPosition(pos, ang)
	--mouth pos
	local vmpos1=self.VapeVMPos1 or Vector(18.5,-3.4,-3)
	local vmang1=self.VapeVMAng1 or Vector(170,-105,82)
	--hand pos
	local vmpos2=self.VapeVMPos2 or Vector(24,-8,-11.2)
	local vmang2=self.VapeVMAng2 or Vector(170,-108,132)

	if not LocalPlayer().vapeArmTime then LocalPlayer().vapeArmTime=0 end
	local lerp = math.Clamp((os.clock()-LocalPlayer().vapeArmTime)*3,0,1)
	if LocalPlayer().vapeArm then lerp = 1-lerp end
	local newpos = LerpVector(lerp,vmpos1,vmpos2)
	local newang = LerpVector(lerp,vmang1,vmang2)
	--I have a good reason for doing it like this
	newang = Angle(newang.x,newang.y,newang.z) 
	
	pos,ang = LocalToWorld(newpos,newang,pos,ang)
	return pos, ang
end
--addons/zeros_growop2_v1.6.1/lua/weapons/zgo2_backpack/cl_init.lua:
return gluapack()()
--addons/zeros_growop2_v1.6.1/lua/weapons/zgo2_joint/shared.lua:
/*
    Addon id: 64edeaec-8955-454a-aac4-1d19d72ee4af
    Version: v1.6.1 (stable)
*/

SWEP.PrintName = "Joint" // The name of your SWEP
SWEP.Author = "ZeroChain" // Your name
SWEP.Instructions = "Hold LMB: Smoke Weed | Reload: Delete Joint | MMB: Drop / Share" // How do people use your SWEP?
SWEP.Contact = "https://www.gmodstore.com/users/76561198013322242" // How people should contact you if they find bugs, errors, etc
SWEP.Purpose = "Used to smoke weed." // What is the purpose of the SWEP?
SWEP.IconLetter	= "V"
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 70b873f322570e153a05d9cee15c50a5d97bffffec86f684a14bf17014b60342

SWEP.AutomaticFrameAdvance = true

SWEP.AdminSpawnable = false // Is the SWEP spawnable for admins?
SWEP.Spawnable = false // Can everybody spawn this SWEP? - If you want only admins to spawn it, keep this false and admin spawnable true.
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 76561198314224586

SWEP.ViewModelFOV = 90 // How much of the weapon do you see?
SWEP.UseHands = true
SWEP.ViewModel = "models/zerochain/props_growop2/zgo2_joint_vm.mdl"
SWEP.WorldModel = "models/zerochain/props_growop2/zgo2_joint_wm.mdl"


SWEP.AutoSwitchTo = true // When someone picks up the SWEP, should it automatically change to your SWEP?
SWEP.AutoSwitchFrom = false // Should the weapon change to the a different SWEP if another SWEP is picked up?
SWEP.Slot = 3 // Which weapon slot you want your SWEP to be in? (1 2 3 4 5 6)
SWEP.SlotPos = 1 // Which part of that slot do you want the SWEP to be in? (1 2 3 4 5 6)
SWEP.HoldType = "slam" // How is the SWEP held? (Pistol SMG Grenade Melee)
SWEP.FiresUnderwater = false // Does your SWEP fire under water?
SWEP.Weight = 5 // Set the weight of your SWEP.
SWEP.DrawCrosshair = true // Do you want the SWEP to have a crosshair?
SWEP.Category = "Zeros GrowOP"
SWEP.DrawAmmo = false // Does the ammo show up when you are using it? True / False
SWEP.base = "weapon_base" //What your weapon is based on.

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Primary.Recoil = 1
SWEP.Primary.Delay = 1
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 5f074b2717244cb0b28afc4f82cbfebeed301ee81f5a05ae65232daad257b16a
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- c360111a1078b749c222565727765c993fb6b426190023d6d23362bac0c7683a

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"
SWEP.Secondary.Recoil = 1
SWEP.Secondary.Delay = 1

function SWEP:SetWeedID() end
function SWEP:GetWeedID() end

function SWEP:SetWeedTHC() end
function SWEP:GetWeedTHC() end

function SWEP:SetWeedAmount() end
function SWEP:GetWeedAmount() end

function SWEP:SetupDataTables()
    self:NetworkVar("Int", 1, "WeedID")
    self:NetworkVar("Int", 2, "WeedTHC")
    self:NetworkVar("Int", 3, "WeedAmount")
    self:NetworkVar("Bool", 0, "IsBusy")
    self:NetworkVar("Bool", 2, "IsBurning")
    self:NetworkVar("Bool", 3, "IsSmoking")

    if (SERVER) then
        self:SetWeedID(-1)
        self:SetWeedTHC(-1)
        self:SetWeedAmount(0)
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- c360111a1078b749c222565727765c993fb6b426190023d6d23362bac0c7683a

        self:SetIsBurning(false)
        self:SetIsBusy(false)
        self:SetIsSmoking(false)
    end
end

--addons/zeros_methlab_1.6.4/lua/weapons/zmlab_extractor/cl_init.lua:
return gluapack()()
--addons/zeros_retrominer_v2.3.6/lua/weapons/zrms_pickaxe/shared.lua:
return gluapack()()
--addons/turkish_food_mod-main/lua/entities/adana/cl_init.lua:
include("shared.lua")
function ENT:Initialize() end
function ENT:Draw() self:DrawModel() end

--addons/[binbon]arccw_modify/lua/entities/arccw_ammo_ar2.lua:
return gluapack()()
--addons/[binbon]arccw_modify/lua/entities/arccw_ammo_buckshot.lua:
return gluapack()()
--addons/[binbon]arccw_modify/lua/entities/arccw_ammo_smg1_grenade.lua:
return gluapack()()
--addons/[binbon]arccw_modify/lua/entities/arccw_ammo_smg1_large.lua:
return gluapack()()
--addons/[binbon]arccw_modify/lua/entities/arccw_gl_ammodet.lua:
ENT.Type                  = "anim"
ENT.Base                  = "base_entity"
ENT.PrintName             = "HE Round"
ENT.Author                = ""
ENT.Information           = ""

ENT.Spawnable             = false


AddCSLuaFile()

ENT.Model = "models/items/ar2_grenade.mdl"
ENT.Ticks = 0
ENT.FuseTime = 10

function ENT:Draw()
    self:DrawModel()
end

ENT.Ticks = 0

function ENT:Detonate()
    if !self:IsValid() then return end
    local effectdata = EffectData()
        effectdata:SetOrigin( self:GetPos() )

    if self:WaterLevel() >= 1 then
        util.Effect( "WaterSurfaceExplosion", effectdata )
        self:EmitSound("weapons/underwater_explode3.wav", 125, 100, 1, CHAN_AUTO)
    else
        util.Effect( "Explosion", effectdata)
        self:EmitSound("phx/kaboom.wav", 125, 100, 1, CHAN_AUTO)
    end

    local attacker = self

    if self:GetOwner():IsValid() then
        attacker = self:GetOwner()
    end

    util.BlastDamage(self, attacker, self:GetPos(), 300, 50)

    self:FireBullets({
        Attacker = attacker,
        Damage = 0,
        Tracer = 0,
        Distance = 20000,
        Dir = self:GetVelocity(),
        Src = self:GetPos(),
        Callback = function(att, tr, dmg)
            util.Decal("Scorch", tr.StartPos, tr.HitPos - (tr.HitNormal * 16), self)
        end
    })

    self:Remove()
end

if CLIENT then
    function ENT:Think()
        if self.Ticks % 2 == 0 then
            local emitter = ParticleEmitter(self:GetPos())

            if !self:IsValid() or self:WaterLevel() > 2 then return end
            if !IsValid(emitter) then return end

            local smoke = emitter:Add("particle/particle_smokegrenade", self:GetPos())
            smoke:SetVelocity( VectorRand() * 25 )
            smoke:SetGravity( Vector(math.Rand(-5, 5), math.Rand(-5, 5), math.Rand(-20, -25)) )
            smoke:SetDieTime( math.Rand(1.5, 2.0) )
            smoke:SetStartAlpha( 255 )
            smoke:SetEndAlpha( 0 )
            smoke:SetStartSize( 0 )
            smoke:SetEndSize( 100 )
            smoke:SetRoll( math.Rand(-180, 180) )
            smoke:SetRollDelta( math.Rand(-0.2,0.2) )
            smoke:SetColor( 20, 20, 20 )
            smoke:SetAirResistance( 5 )
            smoke:SetPos( self:GetPos() )
            smoke:SetLighting( false )
            emitter:Finish()
        end

        self.Ticks = self.Ticks + 1
    end
else

    function ENT:Initialize()
        local pb_vert = 1
        local pb_hor = 1
        self:SetModel(self.Model)
        self:PhysicsInitBox( Vector(-pb_vert,-pb_hor,-pb_hor), Vector(pb_vert,pb_hor,pb_hor) )

        local phys = self:GetPhysicsObject()
        if phys:IsValid() then
            phys:Wake()
        end

        self.SpawnTime = CurTime()

        timer.Simple(0.1, function()
            if !IsValid(self) then return end
            self:SetCollisionGroup(COLLISION_GROUP_PROJECTILE)
        end)
    end

    function ENT:Think()
        if SERVER and CurTime() - self.SpawnTime >= self.FuseTime then
            self:Detonate()
        end
    end

    function ENT:PhysicsCollide(colData, collider)
        self:Detonate()
    end

end
--addons/ashop/lua/entities/ashop_npc/shared.lua:
return gluapack()()
--addons/ch_atm/lua/entities/ch_atm_leaderboard/cl_init.lua:
return gluapack()()
--addons/ch_atm/lua/entities/ch_atm_money/cl_init.lua:
include( "shared.lua" )

--[[
	Initialize the entity
--]]
function ENT:Initialize()
end
--addons/ch_atm/lua/entities/ch_atm_money/shared.lua:
ENT.Base 					= "base_anim"
ENT.Type 					= "anim"

ENT.PrintName 				= "Money"
ENT.Author					= "Crap-Head"
ENT.Category 				= "ATM by Crap-Head"

ENT.Spawnable				= false
ENT.AdminSpawnable			= false

ENT.RenderGroup 			= RENDERGROUP_TRANSLUCENT
ENT.AutomaticFrameAdvance 	= true
--addons/ch_bitminers_dlc/lua/entities/ch_bitminer_antivirus_usb/shared.lua:
return gluapack()()
--addons/ch_bitminers_dlc/lua/entities/ch_bitminer_hacking_usb/cl_init.lua:
include( "shared.lua" )

function ENT:Draw()
	self:DrawModel()
end

net.Receive( "CH_BITMINERS_DLC_StartHacking", function( length, ply )
	local hacking_time = net.ReadDouble()
	local bitminer_ent = net.ReadEntity()
	
	bitminer_ent.HackingCountdown = CurTime() + hacking_time
end )
--addons/ch_bitminers/lua/entities/ch_bitminer_power_generator/cl_init.lua:
return gluapack()()
--addons/ch_bitminers/lua/entities/ch_bitminer_power_rtg/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Radioisotope Thermoelectric Generator"
ENT.Author = "Crap-Head"
ENT.Category = "Bitminers by Crap-Head"

ENT.Spawnable = true
ENT.AdminSpawnable = true

ENT.RenderGroup = RENDERGROUP_TRANSLUCENT
ENT.AutomaticFrameAdvance = true

function ENT:SetupDataTables()
	self:NetworkVar( "Bool", 0, "PowerOn" )
	
	self:NetworkVar( "Float", 0, "WattsGenerated" )
	
	self:NetworkVar( "Entity", 0, "owning_ent" ) -- darkrp owner support
end
--addons/ch_bitminers/lua/entities/ch_bitminer_shelf/cl_init.lua:
include( "shared.lua" )

function ENT:Initialize()
end

--[[
	COLORS
--]]
local col_blue = Color( 62, 173, 229, 255 )

local col_bar_bg = Color( 62, 62, 62, 100 )
local col_bar_bg_notrans = Color( 30, 30, 30, 255 )

local button_col_green = Color( 0, 70, 0, 255 )
local button_col_green_hovered = Color( 0, 110, 0, 255 )

local rect_col_green = Color( 0, 100, 0, 255 )
local rect_col_orange = Color( 240, 137, 19, 255 )
local rect_col_red = Color( 100, 0, 0, 255 )

local col_red = Color( 150, 0, 0, 255 )
local col_hack_green = Color( 0, 200, 0, 255 )

local col_crypto_hover = Color( 255, 255, 255, 180 )
--[[
	MATERIALS
--]]
local mat_rgb_btn
local rgb_col
local power_btn_col

local mat_rgb_btn_on = Material( "craphead_scripts/bitminers/rgb_on.png" )
local mat_rgb_btn_off = Material( "craphead_scripts/bitminers/rgb_off.png" )
local mat_power_btn = Material( "craphead_scripts/bitminers/icon_power.png" )

local mat_lock_icon = Material( "craphead_scripts/bitminers/icon_locked.png" )
local mat_unlock_icon = Material( "craphead_scripts/bitminers/icon_unlocked.png" )

local mat_low_battery = Material( "craphead_scripts/bitminers/low_battery.png" )
local mat_full_battery = Material( "craphead_scripts/bitminers/full_battery.png" )

local mat_hack_skull = Material( "craphead_scripts/bitminers/dlc/hacking_icon.png" )

local mat_eject_bitminer_icon = Material( "craphead_scripts/bitminers/eject.png" )

--[[
	CIRCLES
--]]
local back_circle_capacity = CH_Bitminers.UTIL_CreateCircle( 290, 515, 180, 80, 360, 230 ) -- Back circle
local circle_capacity
local front_circle_capacity = CH_Bitminers.UTIL_CreateCircle( 290, 515, 180, 40, 360, 210 ) -- Front circle

local back_circle_watts = CH_Bitminers.UTIL_CreateCircle( 765, 680, 180, 80, 360, 230 ) -- Back circle
local circle_watts
local front_circle_watts = CH_Bitminers.UTIL_CreateCircle( 765, 680, 180, 40, 360, 210 ) -- Front circle

function ENT:DrawTranslucent()
	self:DrawModel()
	
	if LocalPlayer():GetPos():DistToSqr( self:GetPos() ) > CH_Bitminers.Config.ShowScreenDistance then
		return
	end
	
	local Pos = self:GetAttachment( 1 ).Pos
	local Ang = self:GetAttachment( 1 ).Ang
	
	local tr = self:WorldToLocal( LocalPlayer():GetEyeTrace().HitPos )
	
	local bitcoin_rate = CH_Bitminers.Config.BitcoinRate

	--print( tr )
	cam.Start3D2D( Pos, Ang, 0.01 )
		if not self:GetIsMining() and self:GetHasPower() then
			if tr:WithinAABox( CH_Bitminers.Config.ScreenPositions.power_btn_one, CH_Bitminers.Config.ScreenPositions.power_btn_two ) then
				if self:GetHasPower() then
					power_btn_col = button_col_green
				end
			else
				power_btn_col = color_white
			end
			
			surface.SetDrawColor( power_btn_col )
			surface.SetMaterial( mat_power_btn )
			surface.DrawTexturedRect( 700, 250, 750, 750 )
		elseif self:GetHasPower() and ( self.HackingCountdown and self.HackingCountdown > CurTime() ) then
			-- IS BEING HACKED
			surface.SetDrawColor( col_hack_green )
			surface.DrawRect( 0, 0, 2145, 1275 )

			surface.SetDrawColor( color_white )
			surface.SetMaterial( mat_hack_skull )
			surface.DrawTexturedRect( 722.5, 125, 700, 700 )
			
			-- Moving rect & text
			surface.SetDrawColor( col_bar_bg_notrans )
			surface.DrawRect( 322.5, 950, 1500, 200 )
			
			surface.SetDrawColor( col_bar_bg )
			surface.DrawRect( 322.5, 950, ( self.HackingCountdown - CurTime() ) * ( 1500 / CH_Bitminers_DLC.Config.BitminerHackingTime ), 200 )
			
			draw.DrawText( "HACKING BITMINER", "BITMINER_ScreenText23b", 1072.5, 970, color_white, TEXT_ALIGN_CENTER )
			draw.DrawText( string.ToMinutesSeconds( math.Round( self.HackingCountdown - CurTime() ) ), "BITMINER_ScreenText23b", 1072.5, 1040, color_white, TEXT_ALIGN_CENTER )
		elseif self:GetHasPower() then
			--Background for 76561198347218024
			--surface.SetDrawColor( rect_col_orange )
			--surface.DrawRect( 0, 0, 2145, 1275 )
			
			-- DRAW HEALTH
			draw.DrawText( "MINER HEALTH", "BITMINER_ScreenText23b", 70, 10, color_white, TEXT_ALIGN_LEFT )
			draw.DrawText( self:Health() .."%", "BITMINER_ScreenText23b", 995, 10, color_white, TEXT_ALIGN_RIGHT )
			
			-- Rect showing health
			surface.SetDrawColor( col_bar_bg )
			surface.DrawRect( 70, 100, 925, 50 )
			
			if self:Health() >= 75 then
				surface.SetDrawColor( rect_col_green )
			elseif self:Health() >= 50 then
				surface.SetDrawColor( rect_col_orange )
			else
				surface.SetDrawColor( rect_col_red )
			end
			surface.DrawRect( 70, 100, math.Clamp( self:Health() * 9.25, 0, 925), 50 )
			
			-- DRAW MONEY MINED
			if bitcoin_rate then
				if CH_Bitminers.Config.IntegrateCryptoCurrencies and CH_CryptoCurrencies then
					if CH_CryptoCurrencies.CryptosCL[ self:GetCryptoIntegrationIndex() ] then
						local crypto_price = CH_CryptoCurrencies.CryptosCL[ self:GetCryptoIntegrationIndex() ].Price
						draw.DrawText( CH_CryptoCurrencies.CryptosCL[ self:GetCryptoIntegrationIndex() ].Name.." Mined", "BITMINER_ScreenText20b", 295, 160, color_white, TEXT_ALIGN_CENTER )
						draw.DrawText( "1".. CH_CryptoCurrencies.CryptosCL[ self:GetCryptoIntegrationIndex() ].Currency .." = ".. DarkRP.formatMoney( crypto_price ), "BITMINER_ScreenText20b", 295, 210, color_white, TEXT_ALIGN_CENTER )
					end
				else
					draw.DrawText( "BITCOINS Mined", "BITMINER_ScreenText20b", 295, 160, color_white, TEXT_ALIGN_CENTER )
					draw.DrawText( "1BTC = "..DarkRP.formatMoney( bitcoin_rate ), "BITMINER_ScreenText20b", 295, 210, color_white, TEXT_ALIGN_CENTER )
				end
			end
			CH_Bitminers.UTIL_DrawCircle( back_circle_capacity, col_bar_bg ) -- Back circle
			
			local mined_bitcoins_degrees = 361 * self:GetBitcoinsMined() / CH_Bitminers.Config.MaxBitcoinsMined
			circle_capacity = CH_Bitminers.UTIL_CreateCircle( 290, 515, 180, 80, math.Clamp( mined_bitcoins_degrees, 0, 361 ), 230 ) -- Money circle
			CH_Bitminers.UTIL_DrawCircle( circle_capacity, col_blue ) -- Money circle
			
			CH_Bitminers.UTIL_DrawCircle( front_circle_capacity, col_bar_bg_notrans ) -- Front circle
			
			draw.DrawText( "CAPACITY", "BITMINER_ScreenText23b", 290, 400, color_white, TEXT_ALIGN_CENTER )
			draw.DrawText( math.Round( self:GetBitcoinsMined() / CH_Bitminers.Config.MaxBitcoinsMined * 100, 1 ) .."%", "BITMINER_ScreenText30b", 290, 475, color_white, TEXT_ALIGN_CENTER )
			
			-- DRAW WATTS
			draw.DrawText( "WATTS", "BITMINER_ScreenText23b", 770, 340, color_white, TEXT_ALIGN_CENTER )
			
			CH_Bitminers.UTIL_DrawCircle( back_circle_watts, col_bar_bg ) -- Back circle
			
			local watts_generated_degrees = 361 * self:GetWattsGenerated() / self:GetWattsRequired()
			circle_watts = CH_Bitminers.UTIL_CreateCircle( 765, 680, 180, 80, math.Clamp( watts_generated_degrees, 0, 361 ), 230 ) -- Money circle
			CH_Bitminers.UTIL_DrawCircle( circle_watts, col_blue ) -- Money circle
			
			CH_Bitminers.UTIL_DrawCircle( front_circle_watts, col_bar_bg_notrans ) -- Front circle
			
			draw.DrawText( "Generated", "BITMINER_ScreenText20b", 770, 510, color_white, TEXT_ALIGN_CENTER )
			draw.DrawText( string.Comma( math.Round( self:GetWattsGenerated() ) ), "BITMINER_ScreenText23b", 770, 570, color_white, TEXT_ALIGN_CENTER )
			
			draw.DrawText( "Required", "BITMINER_ScreenText20b", 770, 670, color_white, TEXT_ALIGN_CENTER )
			draw.DrawText( string.Comma( math.Round( self:GetWattsRequired() ) ), "BITMINER_ScreenText23b", 770, 730, color_white, TEXT_ALIGN_CENTER )
			
			
			
			-- WITHDRAW BUTTON
			if tr:WithinAABox( CH_Bitminers.Config.ScreenPositions.withdraw_one, CH_Bitminers.Config.ScreenPositions.withdraw_two ) then
				draw.RoundedBox( 0, 70, 970, 925, 250, button_col_green_hovered )
			else
				draw.RoundedBox( 0, 70, 970, 925, 250, button_col_green )
			end
			
			if CH_Bitminers.Config.IntegrateCryptoCurrencies and CH_CryptoCurrencies then
				draw.DrawText( "Take ".. CH_CryptoCurrencies.CryptosCL[ self:GetCryptoIntegrationIndex() ].Name, "BITMINER_ScreenText23b", 525, 985, color_white, TEXT_ALIGN_CENTER )
				
				draw.DrawText( math.Round( self:GetBitcoinsMined(), 7 ) .. " ".. CH_CryptoCurrencies.CryptosCL[ self:GetCryptoIntegrationIndex() ].Currency, "BITMINER_ScreenText30b", 525, 1070, color_white, TEXT_ALIGN_CENTER )
			else
				draw.DrawText( "Sell Bitcoins (" ..math.Round( self:GetBitcoinsMined(), 7 ) .." BTC)", "BITMINER_ScreenText23b", 525, 985, color_white, TEXT_ALIGN_CENTER )
				
				if bitcoin_rate then
					draw.DrawText( DarkRP.formatMoney( math.Round( self:GetBitcoinsMined() * bitcoin_rate ) ), "BITMINER_ScreenText30b", 525, 1070, color_white, TEXT_ALIGN_CENTER )
				end
			end
			
			-- SPLIT CENTER LINE
			surface.SetDrawColor( col_bar_bg )
			surface.DrawRect( 1065, 0, 15, 1275 )
			
			-- BITMINERS
			draw.DrawText( "MINERS", "BITMINER_ScreenText23b", 1150, 10, color_white, TEXT_ALIGN_LEFT )
			draw.DrawText( self:GetMinersInstalled() .." / ".. self:GetMinersAllowed(), "BITMINER_ScreenText23b", 2075, 10, color_white, TEXT_ALIGN_RIGHT )
			
			-- Rect showing amount of bitminers
			surface.SetDrawColor( col_bar_bg )
			surface.DrawRect( 1150, 100, 925, 50 )
			
			surface.SetDrawColor( col_blue )
			local multiple_rate = 0
			
			if self:GetMinersAllowed() <= 4 then
				multiple_rate = 231.250
			elseif self:GetMinersAllowed() <= 8 then
				multiple_rate = 115.625
			elseif self:GetMinersAllowed() <= 12 then
				multiple_rate = 77.0833
			elseif self:GetMinersAllowed() <= 16 then
				multiple_rate = 57.8125
			end
			
			surface.DrawRect( 1150, 100, self:GetMinersInstalled() * multiple_rate, 50 )

			-- UPS'S INSTALLED
			draw.DrawText( "POWER SUPPLIES", "BITMINER_ScreenText23b", 1150, 175, color_white, TEXT_ALIGN_LEFT )
			draw.DrawText( self:GetUPSInstalled() .." / 4", "BITMINER_ScreenText23b", 2075, 175, color_white, TEXT_ALIGN_RIGHT )
			
			-- Rect showing amount of ups's installed
			surface.SetDrawColor( col_bar_bg )
			surface.DrawRect( 1150, 265, 925, 50 )
			
			surface.SetDrawColor( col_blue )
			surface.DrawRect( 1150, 265, self:GetUPSInstalled() * 231.25, 50 )
			
			-- VENTILATION
			draw.DrawText( "VENTILATION", "BITMINER_ScreenText23b", 1150, 340, color_white, TEXT_ALIGN_LEFT )
			draw.DrawText( self:GetFansInstalled() .." / 3", "BITMINER_ScreenText23b", 2075, 340, color_white, TEXT_ALIGN_RIGHT )
			
			-- Rect showing vents level
			surface.SetDrawColor( col_bar_bg )
			surface.DrawRect( 1150, 430, 925, 50 )
			
			surface.SetDrawColor( col_blue )
			surface.DrawRect( 1150, 430, self:GetFansInstalled() * 308.33, 50 )
			
			-- TEMPERATURE
			draw.DrawText( "TEMPERATURE", "BITMINER_ScreenText23b", 1150, 505, color_white, TEXT_ALIGN_LEFT )
			draw.DrawText( math.Round( self:GetTemperature(), 3 ) .."C", "BITMINER_ScreenText23b", 2075, 505, color_white, TEXT_ALIGN_RIGHT )
			
			-- Rect showing temp
			surface.SetDrawColor( col_bar_bg )
			surface.DrawRect( 1150, 595, 925, 50 )
			
			if self:GetTemperature() <= 33 then
				surface.SetDrawColor( rect_col_green )
			elseif self:GetTemperature() <= 66 then
				surface.SetDrawColor( rect_col_orange )
			elseif self:GetTemperature() <= 100 then
				surface.SetDrawColor( rect_col_red )
			end
			surface.DrawRect( 1150, 595, self:GetTemperature() * 9.25, 50 )
			
			-- Show RGB Button
			if tr:WithinAABox( CH_Bitminers.Config.ScreenPositions.rgb_btn_one, CH_Bitminers.Config.ScreenPositions.rgb_btn_two ) then
				if self:GetRGBInstalled() then
					rgb_col = color_white
					
					if self:GetRGBEnabled() then
						mat_rgb_btn = mat_rgb_btn_off
					else
						mat_rgb_btn = mat_rgb_btn_on
					end
				else
					rgb_col = col_bar_bg
					mat_rgb_btn = mat_rgb_btn_off
				end
			else
				if self:GetRGBInstalled() then
					rgb_col = color_white
					
					if self:GetRGBEnabled() then
						mat_rgb_btn = mat_rgb_btn_on
					else
						mat_rgb_btn = mat_rgb_btn_off
					end
				else
					rgb_col = col_bar_bg
					mat_rgb_btn = mat_rgb_btn_off
				end
			end
			
			draw.RoundedBox( 0, 1150, 970, 250, 250, col_bar_bg_notrans )
			
			surface.SetDrawColor( rgb_col )
			surface.SetMaterial( mat_rgb_btn )
			surface.DrawTexturedRectRotated( 1275, 1095, 220, 220, CurTime() * 360 )
			
			draw.RoundedBox( 0, 1470, 970, 280, 250, col_bar_bg_notrans )
			
			-- Draw battery
			if self:GetWattsGenerated() < self:GetWattsRequired() then
				draw.DrawText( "LOW", "BITMINER_ScreenText20b", 1610, 976, color_white, TEXT_ALIGN_CENTER )
				draw.DrawText( "POWER", "BITMINER_ScreenText20b", 1610, 1152, color_white, TEXT_ALIGN_CENTER )
				
				surface.SetDrawColor( Color( 255, 255, 255, 150 * math.abs( math.sin( CurTime() * 1.5 ) ) ) )
				surface.SetMaterial( mat_low_battery )
				surface.DrawTexturedRect( 1505, 985, 220, 220 )
			else
				draw.DrawText( "FULL", "BITMINER_ScreenText20b", 1610, 976, color_white, TEXT_ALIGN_CENTER )
				draw.DrawText( "POWER", "BITMINER_ScreenText20b", 1610, 1152, color_white, TEXT_ALIGN_CENTER )
				
				surface.SetDrawColor( color_white )
				surface.SetMaterial( mat_full_battery )
				surface.DrawTexturedRect( 1505, 985, 220, 220 )
			end
			
			-- Draw power button
			if tr:WithinAABox( CH_Bitminers.Config.ScreenPositions.power_btn_small_one, CH_Bitminers.Config.ScreenPositions.power_btn_small_two ) then
				power_btn_col = col_red
			else
				power_btn_col = color_white
			end
			
			draw.RoundedBox( 0, 1825, 970, 250, 250, col_bar_bg_notrans )
			
			surface.SetDrawColor( power_btn_col )
			surface.SetMaterial( mat_power_btn )
			surface.DrawTexturedRect( 1823, 968, 256, 256 )
			
			-- Draw lock/unlock icon
			draw.RoundedBox( 0, 1825, 680, 250, 250, col_bar_bg_notrans )
			
			surface.SetDrawColor( color_white )
			if self:GetIsHacked() then
				surface.SetMaterial( mat_unlock_icon )
			else
				surface.SetMaterial( mat_lock_icon )
			end
			surface.DrawTexturedRect( 1840, 690, 225, 225 )
			
			-- draw eject bitminer icon
			if CH_Bitminers.Config.EnableEjectingBitminers then
				draw.RoundedBox( 0, 1150, 680, 250, 250, col_bar_bg_notrans )
				
				if tr:WithinAABox( CH_Bitminers.Config.ScreenPositions.eject_bitminer_btn_one, CH_Bitminers.Config.ScreenPositions.eject_bitminer_btn_two ) then
					surface.SetDrawColor( rect_col_green )
				else
					surface.SetDrawColor( color_white )
				end

				surface.SetMaterial( mat_eject_bitminer_icon )
				surface.DrawTexturedRect( 1165, 695, 225, 225 )
			end
			
			-- Draw current mined coin based on Cryptos if extension is enabled
			if CH_Bitminers.Config.IntegrateCryptoCurrencies and CH_CryptoCurrencies then
				draw.RoundedBox( 0, 1470, 680, 280, 250, col_bar_bg_notrans )
				
				surface.SetMaterial( CH_CryptoCurrencies.CryptosCL[ self:GetCryptoIntegrationIndex() ].Icon )
				surface.SetDrawColor( col_crypto_hover )
				
				if tr:WithinAABox( CH_Bitminers.Config.ScreenPositions.change_mined_crypto_btn_one, CH_Bitminers.Config.ScreenPositions.change_mined_crypto_btn_two ) then
					surface.SetDrawColor( col_crypto_hover )
					surface.DrawTexturedRect( 1505, 695, 220, 220 )
				else
					surface.DrawTexturedRectRotated( 1610, 805, 220, 220, CurTime() * 100 )
				end
			end
		end
	cam.End3D2D()
end
--addons/ch_bitminers/lua/entities/ch_bitminer_upgrade_rgb/cl_init.lua:
return gluapack()()
--addons/ch_mayor/lua/entities/ch_mayor_leaderboard/cl_init.lua:
return gluapack()()
--addons/ch_mayor/lua/entities/ch_mayor_trashcan/cl_init.lua:
include( "shared.lua" )

function ENT:DrawTranslucent()
	self:DrawModel()
	
	local ply = LocalPlayer()
	
	if ply:GetPos():DistToSqr( self:GetPos() ) >= CH_Mayor.Config.DistanceTo3D2D then
		return
	end

    local pos_top = self:GetPos() + Vector( 0, 0, 45 )
	local ply_ang = ply:GetAngles()
	local ang_top = Angle( 0, ply_ang.y - 180, 0 )
	local cur_time = CurTime()
	
	ang_top:RotateAroundAxis( ang_top:Right(), -90 )
	ang_top:RotateAroundAxis( ang_top:Up(), 90 )
	
	cam.Start3D2D( pos_top, ang_top, 0.08 )
		draw.SimpleTextOutlined( CH_Mayor.LangString( "Trash Dumpster" ), "CH_Mayor_Font_3D2D_110", 0, 0, CH_Mayor.Colors.GMSBlue, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 2, color_black )
		draw.SimpleTextOutlined( CH_Mayor.LangString( "Drop props & entities to delete them" ), "CH_Mayor_Font_3D2D_70", 0, 80, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 2, color_black )
    cam.End3D2D()
end
--addons/ch_mayor/lua/entities/ch_mayor_trashcan/shared.lua:
return gluapack()()
--addons/ch_mayor/lua/entities/ch_mayor_wanted/shared.lua:
return gluapack()()
--addons/cityworker/lua/entities/cityworker_electric/cl_init.lua:
include( "shared.lua" )

function ENT:Initialize()
  --  self.emitter = ParticleEmitter( self:GetPos() )
    self.nextEmit = 0
end

function ENT:OnRemove()
  --  if self.emitter then 
   -- self.emitter:Finish()
  --  end
end

function ENT:Think()
    if CurTime() >= self.nextEmit then
        local sparks = EffectData()
		sparks:SetOrigin( self:GetPos() )
		sparks:SetNormal( self:GetAngles():Forward() )
		sparks:SetMagnitude( math.Rand( 1, 4 ) )
        sparks:SetEntity( self )
		sparks:SetRadius( math.Rand( 3, 5 ) )
		util.Effect( "TeslaHitboxes", sparks, true, true )
      --  util.Effect( "ElectricSpark", sparks, true, true )

        self:EmitSound( "ambient/energy/spark"..math.random( 1, 6 )..".wav", 55 )

        self.nextEmit = CurTime() + math.Rand( 0.5, 2 )
    end
end
--gamemodes/darkrp/entities/entities/darkrp_laws/shared.lua:
return gluapack()()
--addons/turkish_food_mod-main/lua/entities/gazoz/cl_init.lua:
return gluapack()()
--addons/glicence/lua/entities/glicence_npc/cl_init.lua:
include("shared.lua")

function ENT:Draw()
  self:DrawModel()
  if not binbonentdraw then return end
  binbonentdraw(self, "Silah Lisansçısı", true, 0, 10, 20, true)
  binbonentdraw(self, "Lisans satın alarak yasal olarak taşıyabilirsin silahı.", false, 0,100, 20, false)
end


--addons/glicence/lua/entities/glicence_npc/shared.lua:
return gluapack()()
--gamemodes/darkrp/entities/entities/gunlab/shared.lua:
return gluapack()()
--addons/turkish_food_mod-main/lua/entities/hosbes/shared.lua:
return gluapack()()
--addons/turkish_food_mod-main/lua/entities/kulah/cl_init.lua:
return gluapack()()
--addons/turkish_food_mod-main/lua/entities/lahmacun/cl_init.lua:
return gluapack()()
--gamemodes/darkrp/entities/entities/letter/cl_init.lua:
include("shared.lua")

local frame
local SignButton

function ENT:Draw()
    self:DrawModel()
end

local function KillLetter(msg)
    hook.Remove("HUDPaint", "ShowLetter")
    frame:Remove()
end
usermessage.Hook("KillLetter", KillLetter)

local function ShowLetter(msg)
    if frame then
        frame:Remove()
    end

    local LetterMsg = ""
    local Letter = msg:ReadEntity()
    local LetterType = msg:ReadShort()
    local LetterPos = msg:ReadVector()
    local sectionCount = msg:ReadShort()
    local LetterY = ScrH() / 2 - 300
    local LetterAlpha = 255

    Letter:CallOnRemove("Kill letter HUD on remove", KillLetter)

    for k = 1, sectionCount, 1 do
        LetterMsg = LetterMsg .. msg:ReadString()
    end

    frame = vgui.Create("DFrame")
    frame:SetTitle("")
    frame:ShowCloseButton(false)

    SignButton = vgui.Create("DButton", frame)
    SignButton:SetText(DarkRP.getPhrase("sign_this_letter"))
    frame:SetPos(ScrW() - 256, ScrH() - 256)
    SignButton:SetSize(256, 256)
    frame:SetSize(256, 256)
    SignButton:SetSkin(GAMEMODE.Config.DarkRPSkin)
    frame:SizeToContents()
    frame:MakePopup()
    frame:SetKeyboardInputEnabled(false)

    function SignButton:DoClick()
        RunConsoleCommand("_DarkRP_SignLetter", Letter:EntIndex())
        SignButton:SetDisabled(true)
    end
    SignButton:SetDisabled(IsValid(Letter:Getsigned()))

    hook.Add("HUDPaint", "ShowLetter", function()
        if not Letter.dt then KillLetter() return end
        if LetterAlpha < 255 then
            LetterAlpha = math.Clamp(LetterAlpha + 400 * FrameTime(), 0, 255)
        end

        local font = (LetterType == 1 and "AckBarWriting") or "Default"

        draw.RoundedBox(2, ScrW() * .2, LetterY, ScrW() * .8 - (ScrW() * .2), ScrH(), Color(255, 255, 255, math.Clamp(LetterAlpha, 0, 200)))
        draw.DrawNonParsedText(LetterMsg .. "\n\n\n" .. DarkRP.getPhrase("signed", IsValid(Letter:Getsigned()) and Letter:Getsigned():Nick() or DarkRP.getPhrase("no_one")), font, ScrW() * .25 + 20, LetterY + 80, Color(0, 0, 0, LetterAlpha), 0)

        if LocalPlayer():GetPos():DistToSqr(LetterPos) > 10000 then
            LetterY = Lerp(0.1, LetterY, ScrH())
            LetterAlpha = Lerp(0.1, LetterAlpha, 0)
            if frame and frame.Close then frame:Close() end
            if math.Round(LetterAlpha) <= 10 then
                KillLetter()
            end
        end
    end)
end
usermessage.Hook("ShowLetter", ShowLetter)

--gamemodes/darkrp/entities/entities/letter/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "letter"
ENT.Author = "Pcwizdan"
ENT.Spawnable = false

function ENT:SetupDataTables()
    self:NetworkVar("Entity",1,"owning_ent")
    self:NetworkVar("Entity",2,"signed")
end

DarkRP.declareChatCommand{
    command = "write",
    description = "Write a letter.",
    delay = 5
}

DarkRP.declareChatCommand{
    command = "type",
    description = "Type a letter.",
    delay = 5
}

DarkRP.declareChatCommand{
    command = "removeletters",
    description = "Remove all of your letters.",
    delay = 5
}

--addons/turkish_food_mod-main/lua/entities/metro/shared.lua:
return gluapack()()
--addons/minigame-tool-assistant/lua/entities/minigame_boxgame.lua:
return gluapack()()
--addons/pcasino/lua/entities/pcasino_npc/shared.lua:
return gluapack()()
--addons/pcasino/lua/entities/pcasino_slot_machine/cl_init.lua:
return gluapack()()
--addons/pcasino/lua/entities/pcasino_slot_machine/cl_init.lua:
include("shared.lua")

function ENT:Initialize()
	self.wheels = {}
	for i=1, 3 do
		local wheel = ClientsideModel("models/freeman/owain_slotmachine_reel.mdl")
		self.wheels[i] = wheel
		wheel:SetParent(self)
		wheel:SetPos(self:GetPos()+(self:GetUp()*5.5)+(self:GetForward()*-10)+((self:GetRight()*-6)*(i-2)))
		wheel:SetAngles(self:GetAngles())
	end

	self.active = false

	self.hasInitialized = true
end

function ENT:PostData()
	if not self.hasInitialized then
		self:Initialize()
	end
end

function ENT:OnRemove()
	for k, v in pairs(self.wheels) do
		if IsValid(v) then v:Remove() end
	end
end

local colorGold = Color(255, 200, 0)
local colorPurple = Color(255, 0, 255)
function ENT:Draw()
	self:DrawModel()
	if self:GetPos():DistToSqr(LocalPlayer():GetPos()) > 25000 then return end

	if (not self.wheels) or (not self.wheels[1]) or (not IsValid(self.wheels[1])) then self:Initialize() return end

	-- We can piggyback off the distance check to only request the entities data when it's needed :D
	if (not self.data) and (not PerfectCasino.Cooldown.Check(self:EntIndex(), 5)) then
		PerfectCasino.Core.RequestConfigData(self)
		return
	end

	if not self.data then return end

	-- For ticking value
	self.curJackpot = math.Approach(self.curJackpot or self:GetCurrentJackpot(), self:GetCurrentJackpot(), math.Round((self.data.bet.default*5)*FrameTime()))

	-- Basic setups
	local pos = self:GetPos()
	local ang = self:GetAngles()
	
	ang:RotateAroundAxis(ang:Up(), 90)
	ang:RotateAroundAxis(ang:Forward(), 90)

	cam.Start3D2D(pos + (ang:Up()*-5.6) + (ang:Right()*-29.6), ang, 0.05)
		if tobool(self.data.jackpot.toggle) then
			draw.SimpleText(string.format(PerfectCasino.Translation.UI.JackPot, PerfectCasino.Config.FormatMoney(self.curJackpot)), "pCasino.Title.Static", 0, 0, (self.win and (self.win == 2)) and colorPurple or colorGold, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
		else
			draw.SimpleText((math.ceil(CurTime())%2 == 1) and PerfectCasino.Translation.UI.ReadyToPlay or "", "pCasino.Title.Static", 0, 0, colorGold, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
		end
	cam.End3D2D()
	
	ang:RotateAroundAxis(ang:Forward(), -20)

	cam.Start3D2D(pos + (ang:Up()*1.9) + (ang:Right()*5.1) + (ang:Forward()*5.5), ang, 0.05)
		draw.SimpleText(PerfectCasino.Config.FormatMoney(self.data.bet.default), "pCasino.Textbox.Static", 0, 0, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
	cam.End3D2D()
end

local cooldown = 0
function ENT:Think()
	if not self.active then return end
	if self.win then
		for i=1, 2 do
			local winLight = DynamicLight(self:EntIndex()+i)
			if winLight then
				winLight.pos = self:GetPos()+(self:GetUp()*13)+(self:GetForward()*-5)+((self:GetRight()*3)*(-3+(2*i)))
				winLight.r = (self.win == 2) and ((math.Round(CurTime()%1) == 1) and 100 or 0) or 100
				winLight.g = self.win == 2 and 0 or 100
				winLight.b = (self.win == 2) and 100 or 0 -- and ((math.Round(CurTime()%2) == 1) and
				winLight.brightness = 3
				winLight.Decay = 1000
				winLight.Size = 100
				winLight.DieTime = CurTime() + 1
			end
		end
	end

	for k, v in pairs(self.wheels) do
		if v.spinning then
			local ang = v:GetAngles()
			ang:RotateAroundAxis(v:GetRight(), -600*FrameTime())
			v:SetAngles(ang)
		elseif v.reject and (v.reject > 0) then
			local bump = math.Clamp(math.Round(300*FrameTime()), 1, v.reject)

			local ang = v:GetAngles()
			ang:RotateAroundAxis(v:GetRight(), bump)
			v:SetAngles(ang)
			v.reject = v.reject - bump
			if (k == 3) and (v.reject <= 0) and (not isnumber(self.win)) then
				self.active = false -- All the wheels are in the right place
			end
		end
	end
end

-- Game specific code
function ENT:StartSpinning(i)
	local wheel = self.wheels[i]
	if (not wheel) or (not IsValid(wheel)) then self:Initialize() return end

	local randomAng = self:GetAngles()
	randomAng:RotateAroundAxis(self:GetRight(), math.random(0, 360))
	wheel:SetAngles(randomAng)

	wheel.spinning = true
end

local resultCache = {}
resultCache["dollar"] = 0
resultCache["bell"] = 1
resultCache["melon"] = 2
resultCache["cherry"] = 3
resultCache["seven"] = 4
resultCache["clover"] = 5
resultCache["diamond"] = 6
resultCache["berry"] = 7

local snap = 360/table.Count(resultCache)
local offset = -35
local rejectionVaule = 20
function ENT:StopSpinning(i, result)
	local wheel = self.wheels[i]
	if (not wheel) or (not IsValid(wheel)) then self:Initialize() return end
	
	wheel.spinning = false

	if result then
		local angleResult = resultCache[result] * snap - offset

		local ang = self:GetAngles()
		ang:RotateAroundAxis(wheel:GetRight(), angleResult-rejectionVaule)
		wheel:SetAngles(ang)

		wheel.reject = rejectionVaule
	end
end

function ENT:StartWin(winData)
	-- 2 is jackpot, 1 is normal win
	self.win = (tobool(winData.j) and tobool(self.data.jackpot.toggle)) and 2 or 1
end

function ENT:EndWin()
	self.active = false
	self.win = nil
end

net.Receive("pCasino:BasicSlot:Spin:Start", function()
	local entity = net.ReadEntity()
	if not IsValid(entity) then return end
	if entity:GetPos():DistToSqr(LocalPlayer():GetPos()) > 500000 then return end
	if not entity.data then return end

	entity.active = true

	for i=1, 3 do
		entity:StartSpinning(i)
	end
end)

net.Receive("pCasino:BasicSlot:Spin:Stop", function()
	local entity = net.ReadEntity()
	if not IsValid(entity) then return end
	if not entity.active then return end
	if not entity.data then return end

	local key = net.ReadUInt(2)
	local result = net.ReadString()
	entity:StopSpinning(key, result)
end)

net.Receive("pCasino:BasicSlot:Spin:Win", function()
	local entity = net.ReadEntity()
	if not IsValid(entity) then return end
	if not entity.active then return end
	if not entity.data then return end

	local winData = net.ReadTable()
	entity:StartWin(winData)

	timer.Simple((tobool(winData.j) and tobool(entity.data.jackpot.toggle)) and 5 or 2, function()
		if not IsValid(entity) then return end
		entity:EndWin()
	end)
end)
--addons/pcasino/lua/entities/pcasino_slot_machine/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Slot Machine"
ENT.Author = "Owain Owjo & The One Free-Man"
ENT.Category = "pCasino"
ENT.Spawnable = false
ENT.AdminSpawnable = false

function ENT:SetupDataTables()
	self:NetworkVar("Int", 0, "CurrentJackpot")
end

PerfectCasino.Core.RegisterEntity("pcasino_slot_machine", {
	-- General data
	general = {
		limitUse = {d = false, t = "bool"}
	},
	-- Bet data
	bet = {
		default = {d = 1000, t = "num"}, -- The default bet
	},
	-- Combo data
	combo = {
		{c = {"bell", "bell", "bell"}, p = 0.5, j = false},
		{c = {"melon", "melon", "melon"}, p = 0.8, j = false},
		{c = {"cherry", "cherry", "cherry"}, p = 1, j = false},
		{c = {"seven", "seven", "seven"}, p = 1.6, j = false},
		{c = {"clover", "clover", "clover"}, p = 2, j = false},
		{c = {"diamond", "diamond", "diamond"}, p = 2.5, j = false},
		{c = {"diamond", "diamond", "anything"}, p = 2, j = false},
		{c = {"anything", "diamond", "diamond"}, p = 2, j = false},
		{c = {"berry", "berry", "berry"}, p = 2.8, j = false},
		{c = {"dollar", "dollar", "dollar"}, p = 0, j = true},
	},
	jackpot = {
		toggle = {d = true, t = "bool"}, -- The bell chance
		startValue = {d = 10000, t = "num"}, -- Jackpot start value
		betAdd = {d = 0.5, t = "num"}, -- The % of the bet to add to the jackpot
	},
	-- Chance data
	chance = {
		bell = {d = 15}, -- The bell chance
		melon = {d = 10}, -- The watermelon chance
		cherry = {d = 8}, -- The cherry chance
		seven = {d = 6}, -- The seven chance
		clover = {d = 5}, -- The clover chance
		diamond = {d = 3}, -- The diamond chance
		berry = {d = 2}, -- The strawberrry chance
		dollar = {d = 1} -- The dollar chance
	},
},
"models/freeman/owain_slotmachine.mdl")
--lua/entities/pet_base/animations.lua:
return gluapack()()
--lua/entities/pet_base/animations.lua:
ENT.ShouldJump = false
ENT.ShouldScare = false
ENT.ScareProgress = 0
ENT.DanceProgress = 0
ENT.DanceAnim = 0
ENT.NextDance = 0

local anims = {"celebrate", "taunt"}
function ENT:HandleAnimation()
    local idealAnim = "idle"
    if (self.IsRunning) then
        idealAnim = "run"
    end
    if (not self.IsRunning and self:GetOwner():Crouching() and not self:GetOwner():IsOnGround() and not self.ShouldJump) then
        self.ShouldJump = true
        self:EmitSound("pets/fox" .. math.random(1, 3) .. ".ogg")
        self.JumpProgress = 1
    end

    if (self.ShouldJump and self.JumpProgress > 0) then
        self.JumpProgress = self.JumpProgress - (FrameTime() * (1 / self.Pet:SequenceDuration()))
        self.Pet:SetSequence("celebrate")
        self.Pet:SetCycle(1 - self.JumpProgress)
        return
    elseif (self.ShouldJump) then
        idealAnim = "idle"
        self.ShouldJump = false
    end

    if (self.ShouldScare and self.ScareProgress > 0) then
        self.ScareProgress = self.ScareProgress - (FrameTime() * (1 / self.Pet:SequenceDuration()))
        self.Pet:SetSequence("taunt")
        self.Pet:SetCycle(1 - self.ScareProgress)
        return
    elseif (self.ShouldScare) then
        idealAnim = "idle"
        self.ShouldScare = false
    end

    if (self.ShouldDance and IsValid(self.Partner) and IsValid(self.Partner.Pet)) then
        self.IdealAngle = Angle(0, (self.Partner.Pet:GetPos() - self.Pet:GetPos()):GetNormalized():Angle().y, 0)
        if (self.NextDance == 0) then
            self.NextDance = CurTime() + math.Rand(5, 10)
        elseif (self.NextDance < CurTime()) then
            self.NextDance = CurTime() + math.Rand(5, 10)
            self.DanceAnim = table.Random(anims)
            self.DanceProgress = 1
            self:EmitSound("pets/fox" .. math.random(1, 3) .. ".ogg")
        end
        if (self.DanceProgress > 0) then
            self.Pet:SetSequence(self.DanceAnim)
            self.DanceProgress = self.DanceProgress - (FrameTime() * (1 / self.Pet:SequenceDuration()))
            if (self.DanceProgress > 0) then
                self.Pet:SetCycle(1 - self.DanceProgress)
                return
            end
        end
    elseif (self.NextDance != 0) then
        self.NextDance = 0
    end

    self.Pet:SetSequence(idealAnim)
    self.Pet:SetCycle((RealTime() / self.Pet:SequenceDuration()) % 1)
end
--lua/entities/pet_base/movement.lua:
return gluapack()()
--lua/entities/pet_base/movement.lua:
ENT.NextCheck = 0
ENT.CheckStuck = 0
ENT.NextGroup = 0
ENT.IdealAngle = Angle(0, 0, 0)
local sides = {1, -1}

--Snippet from wiki.garrysmod.org
local function IsLookingAt( ply, targetVec )
 return ply:GetAimVector():Dot( ( targetVec - ply:GetPos() + Vector(0, 0, 30) ):GetNormalized() ) 
end

function ENT:HandleMovement()
    --Let's initialize it position
    if (not self.CorrectedPos) then
        self.CorrectedPos = {self:GetPos()}
        self.Pet:SetPos(self:GetPos())
        self.PetAngle = Angle(0, 0, 0)
        self.IdealAngle = Angle(0, 0, 0)
        self.Pet:SetAngles(Angle(0, 0, 0))
    end

    if (self.CheckStuck < CurTime()) then
        self.CheckStuck = CurTime() + 3
        --We check if the pet is inside our FOV
        local dot = IsLookingAt(LocalPlayer(), self.Pet:GetPos())
        if (dot < 0.4 ) then
            --Did we go too far away from our pet?
            local dist = self.Pet:GetPos():Distance(self:GetOwner():GetPos())
            if (dist > 800) then
                for _, side in RandomPairs(sides) do
                    --It apears behind us
                    local tr = util.QuickTrace(self:GetOwner():GetPos() + Vector(0, 0, 4), self:GetOwner():GetRight() * side * 32 + self:GetOwner():GetForward() * -32 - Vector(0, 0, 32))
                    self.Pet:SetPos(tr.HitPos)
                    local target = self.CorrectedPos[#self.CorrectedPos]
                    if (target) then
                        --Let¿s clear the corrected pos so we give the illusion it came quicklier
                        self.CorrectedPos = {target}
                    end
                    break
                end
            end
        end
    end

    local dist = self.Pet:GetPos():DistToSqr(self:GetOwner():GetPos())

    --We introduce player position if it's too far away from the pet
    if (dist > 70000 and self.NextCheck < CurTime()) then
        self.NextCheck = CurTime() + .5
        local target = util.QuickTrace(self:GetOwner():GetPos() + (Angle(0, self.Pet:GetAngles().y + math.random(-90, 90), 0)):Forward() * math.random(32, 96), Vector(0, 0, -92))
        table.insert(self.CorrectedPos, target.HitPos)
    end

    local targetPos = self.CorrectedPos[1]
    --We apply the animation for the pet
    self.IsRunning = targetPos ~= nil

    --If there's a node available we move it there
    if (targetPos) then
        local dir = (targetPos - self.Pet:GetPos()):GetNormalized()
        if (targetPos == self.Pet:GetPos()) then
            self.IdealAngle = Angle(0, 0, 0)
        else
            self.IdealAngle = dir:Angle()
        end

        if (targetPos:DistToSqr(self.Pet:GetPos()) > 16000) then
            local speed = .7 + #self.CorrectedPos / 3
            local target = util.QuickTrace(self.Pet:GetPos() + dir * speed + Vector(0, 0, 30), Vector(0, 0, -35)).HitPos
            self.Pet:SetPos(target)
        else
            table.remove(self.CorrectedPos, 1)
        end
        self.ShouldDance = false
    elseif (self.NextGroup < CurTime()) then
        self.NextGroup = CurTime() + 3
        self.ShouldDance = false
        for _, ent in RandomPairs(ents.FindInSphere(self.Pet:GetPos(), 256)) do
            if (ent != self and ent.Base == "pet_base") then
                self.ShouldDance = true
                if (ent.Partner) then
                    self.Partner = ent.Partner
                else
                    ent.Partner = self
                end
                if (not self.Partner) then
                    self.Partner = ent
                end
                break
            end
        end
        if (not self.ShouldDance and self.Partner) then
            self.Partner = nil
        end
    end

    self.PetAngle = LerpAngle(FrameTime() * 8, self.PetAngle, self.IdealAngle)
    self.Pet:SetAngles(self.PetAngle)
end

function ENT:HandleTarget()
    local dist = self:GetPos():Distance(self:GetOwner():GetPos())
    local dir = (self:GetPos() - self:GetOwner():GetPos()):GetNormalized()

    --We just verify if the owner is kinda far away
    if (dist > 256) then
        local idealPos = self:GetOwner():GetPos() + dir * 128
        local tr = util.QuickTrace(idealPos + Vector(0, 0, 40), Vector(0, 0, -120))
        self:SetPos(tr.HitPos)
    end
end
--addons/executioner/lua/entities/phone_box/shared.lua:
    AddCSLuaFile()

    ENT.Base = "base_gmodentity"
    ENT.Type = "anim"

    ENT.Category		= "ted.lua"
    ENT.Spawnable		= true

    ENT.PrintName		= "Phone Box"
    ENT.Author			= "ted.lua"
    ENT.Purpose			= "Call your local hitman."
    ENT.Instructions	= ""

    if CLIENT then
        surface.CreateFont( "rHit.Font.PhoneBox", { font = "BFHUD", size = 90, weight = 800, bold = true } )
        local v = Vector()

    	function ENT:Draw()
    	    self:DrawModel()
    	    v.z = math.sin( CurTime() ) * 60
    	    if LocalPlayer():GetPos():Distance( self:GetPos() ) < 500 then
        		  local ang = self:GetAngles()
        		  ang:RotateAroundAxis(self:GetAngles():Right(), 90)
        		  ang:RotateAroundAxis(self:GetAngles():Forward(), 90)
        		  cam.Start3D2D(self:GetPos() + ang:Up(), Angle(0, LocalPlayer():EyeAngles().y - 90, 90), 0.1)
            		 -- Graphics.DrawRect( v.x - 250, ( v.z / 2 ) - 550, 500, 130, Color( 22, 22, 22, 255 ) )
            		 -- Graphics.DrawOutline( v.x - 250, ( v.z / 2 ) - 550, 500, 130, 4, Color( 0, 0, 0 ) )

            		  Graphics.DrawText( Executioner.Config.Phone.Text_On_Entity, "rHit.Font.PhoneBox", -10, ( v.z / 2 ) - 535, Color( 200, 0, 0 ))
        		  cam.End3D2D()
    	    end
    	end
    else
        function ENT:Initialize()
            self:SetModel( "models/props_trainstation/payphone001a.mdl" )
            self:PhysicsInit( SOLID_VPHYSICS )
            self:SetMoveType( MOVETYPE_VPHYSICS )
            self:SetSolid( SOLID_VPHYSICS )
            --self:SetRenderFX( kRenderFxSolidFast )
            self:SetUseType( SIMPLE_USE )
            local phys = self:GetPhysicsObject()
            if phys:IsValid() then phys:Wake() end
        end

        function ENT:Use( null, caller, type )
            if !IsValid( caller ) or !caller:IsPlayer() then return end
            if caller.My_Hitman then caller.My_Hitman = nil end
            if not caller:Alive() or caller:isArrested() then return end
            if Executioner.Config.No_Place_Teams[ team.GetName( caller:Team() ) ] then Executioner.SendMessage( caller, 'You can not place a hit as this job.' ) return end
            if Executioner.Config.BlackList_Teams[ team.GetName( caller:Team() ) ] then 
                Executioner.SendMessage( caller, Executioner.Language.PhoneNotInService ) 
                return 
            end
            if not Executioner.Config.PhoneEnabled then
                if caller:IsSuperAdmin() or caller:IsAdmin() then
                    Executioner.SendMessage( caller, "As you are an Admin, only you can see this. If you are trying to use the phone, you must enable it in the config: Executioner.Config.PhoneEnabled = true" )
                else
                    Executioner.SendMessage( caller, Executioner.Language.PhoneNotInService ) 
                end
                return
            end
            if Executioner.Config.Hitman_Teams[ team.GetName( caller:Team() ) ] then Executioner.SendMessage( caller, Executioner.Language.HitmanOnUsePhone ) return end
            if caller.rHit_PlaceCooldown and caller.rHit_PlaceCooldown > CurTime() then Executioner.SendMessage( caller, Executioner.Language.HitTooSoon ) return end
            if caller.rHit_PlacedHit or caller:GetNWBool( 'rHit_ActiveHit' ) then Executioner.SendMessage( caller, Executioner.Language.HitmanActiveHit ) return end
            net.Start( 'rHit.Open.Placement' )
                net.WriteTable( Executioner.PhoneTracker )
            net.Send( caller )
        end

        hook.Add( 'CanTool', 'rHit.Prevent.Tool', function( self, trace, tool )
            if tool == 'remover' and IsValid( trace.Entity ) and trace.Entity:GetClass() == "phone_box" then
                if self:IsSuperAdmin() then return true else return false end
            end
        end )

        hook.Add( 'PhysgunPickup', 'rHit.Prevent.Pickup', function( self, ent )
            if self:IsSuperAdmin() and ent:GetClass() == 'phone_box' then return true end
        end )
    end

--addons/realisticcardealer/lua/entities/rcd_paper/cl_init.lua:
return gluapack()()
--addons/realisticcardealer/lua/entities/rcd_printer/cl_init.lua:
return gluapack()()
--addons/skeypad_1.2.36/lua/entities/s_keycard/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Keycard"
ENT.Author = "Stromic"
ENT.Category = "Keypad"
ENT.Spawnable = false
--addons/turkish_food_mod-main/lua/entities/salgam/cl_init.lua:
include("shared.lua")
function ENT:Initialize() end
function ENT:Draw() self:DrawModel() end

--gamemodes/darkrp/entities/entities/spawned_weapon/shared.lua:
return gluapack()()
--lua/entities/sv_spikestrip/shared.lua:
return gluapack()()
--lua/entities/sv_spikestrip/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_entity"
ENT.PrintName = "Herse"
ENT.Author = "Hertinox & TomLaVachette"
ENT.Category = "SVMod"
ENT.Spawnable = true
--addons/xenin-coinflip/lua/entities/xenin_coinflip_npc/cl_init.lua:
include("shared.lua")

function ENT:Draw()
  self:DrawModel()
  if not binbonentdraw then return end
  binbonentdraw(self, "Yazı-Tura", true, 0, 10, 20, true)
  binbonentdraw(self, "Belli para karşılığında milletle yazı-tura oynayabilirsin.", false, 0,100, 20, false)
end
--addons/zerosfruitslicer/lua/entities/zfs_fruitcup.lua:
AddCSLuaFile()
DEFINE_BASECLASS("zfs_anim")
ENT.Spawnable = false
ENT.Base = "zfs_anim"
ENT.Type = "anim"
ENT.RenderGroup = RENDERGROUP_OPAQUE
ENT.PrintName = "Fruitcup"
ENT.Category = "Zeros FruitSlicer"
ENT.Model = "models/zerochain/fruitslicerjob/fs_fruitcup.mdl"

function ENT:SetupDataTables()
    self:NetworkVar("Int", 0, "Price")
    self:NetworkVar("String", 0, "SmoothieCreator")
end

if CLIENT then return end

function ENT:Initialize()
    self:SetModel(self.Model)
    self:PhysicsInit(SOLID_VPHYSICS)
    self:SetSolid(SOLID_VPHYSICS)
    self:SetMoveType(MOVETYPE_VPHYSICS)
    self:SetUseType(SIMPLE_USE)
    self:SetCollisionGroup(COLLISION_GROUP_WEAPON)
    local phys = self:GetPhysicsObject()

    if IsValid(phys) then
        phys:Wake()
        phys:EnableMotion(false)
    end

    zfs.SellObject.Initialize(self)
end

function ENT:AcceptInput(input, activator, caller, data)
    if string.lower(input) == "use" and IsValid(activator) and activator:IsPlayer() and activator:Alive() then
        zfs.SellObject.Use(activator, self)
    end
end

--addons/zerosfruitslicer/lua/entities/zfs_smoothie/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()
end

function ENT:DrawTranslucent()
	self:Draw()
end

--addons/zerosfruitslicer/lua/entities/zfs_sweetener.lua:
AddCSLuaFile()
DEFINE_BASECLASS("zfs_anim")
ENT.Spawnable = false
ENT.Base = "zfs_anim"
ENT.Type = "anim"
ENT.RenderGroup = RENDERGROUP_TRANSLUCENT
ENT.PrintName = "Sweetener"
ENT.Category = "Zeros FruitSlicer"
ENT.Model = "models/zerochain/fruitslicerjob/fs_sweeteners.mdl"

if CLIENT then return end

function ENT:Initialize()
	self:SetModel(self.Model)
	self:PhysicsInit(SOLID_VPHYSICS)
	self:SetSolid(SOLID_VPHYSICS)
	self:SetMoveType(MOVETYPE_NONE)
	self:SetCollisionGroup(COLLISION_GROUP_WEAPON)
	self:SetUseType(SIMPLE_USE)
	self:UseClientSideAnimation()
	local phys = self:GetPhysicsObject()

	if IsValid(phys) then
		phys:Wake()
	end

	zfs.Sweetener.Initialize(self)
end

function ENT:AcceptInput(input, activator, caller, data)
	if string.lower(input) == "use" and IsValid(activator) and activator:IsPlayer() and activator:Alive() then
		zfs.Sweetener.Use(activator, self)
	end
end

--addons/zeros_growop2_v1.6.1/lua/entities/zgo2_backpack_ent/shared.lua:
return gluapack()()
--addons/zeros_growop2_v1.6.1/lua/entities/zgo2_battery.lua:
return gluapack()()
--addons/zeros_growop2_v1.6.1/lua/entities/zgo2_crate/cl_init.lua:
return gluapack()()
--addons/zeros_growop2_v1.6.1/lua/entities/zgo2_joint_ent/shared.lua:
/*
    Addon id: 64edeaec-8955-454a-aac4-1d19d72ee4af
    Version: v1.6.1 (stable)
*/

ENT.Type                    = "anim"
ENT.Base                    = "base_anim"
ENT.AutomaticFrameAdvance   = false
ENT.PrintName               = "Joint"
ENT.Author                  = "ZeroChain"
ENT.Category                = "Zeros GrowOP 2"
ENT.Spawnable               = false
ENT.AdminSpawnable          = false
ENT.Model                   = "models/zerochain/props_growop2/zgo2_joint.mdl"
ENT.RenderGroup             = RENDERGROUP_OPAQUE

                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 76561198314224586

function ENT:SetupDataTables()
    self:NetworkVar("Int", 1, "WeedID")
    self:NetworkVar("Int", 2, "WeedTHC")
    self:NetworkVar("Int", 3, "WeedAmount")
    self:NetworkVar("Bool", 0, "IsBurning")
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 5f074b2717244cb0b28afc4f82cbfebeed301ee81f5a05ae65232daad257b16a
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 76561198314224586
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 76561198314224586
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 76561198314224595

    if (SERVER) then
        self:SetWeedID(-1)
        self:SetWeedTHC(-1)
        self:SetWeedAmount(0)
        self:SetIsBurning(false)
    end
end

--addons/zeros_growop2_v1.6.1/lua/entities/zgo2_lamp/cl_init.lua:
return gluapack()()
--addons/zeros_growop2_v1.6.1/lua/entities/zgo2_mixerbowl/cl_init.lua:
/*
    Addon id: 64edeaec-8955-454a-aac4-1d19d72ee4af
    Version: v1.6.1 (stable)
*/

include("shared.lua")

function ENT:Initialize()
	zgo2.MixerBowl.Initialize(self)
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 8ffb188c701d3f1856df3a15bfe8e14b5be84a41e03a52af8e86de4fbee82eeb
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 70b873f322570e153a05d9cee15c50a5d97bffffec86f684a14bf17014b60342

function ENT:Draw()
	self:DrawModel()
	zgo2.MixerBowl.Draw(self)
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 70b873f322570e153a05d9cee15c50a5d97bffffec86f684a14bf17014b60342
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 76561198314224586

function ENT:Think()
	zgo2.MixerBowl.Think(self)
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 70b873f322570e153a05d9cee15c50a5d97bffffec86f684a14bf17014b60342

--addons/zeros_growop2_v1.6.1/lua/entities/zgo2_oven/cl_init.lua:
/*
    Addon id: 64edeaec-8955-454a-aac4-1d19d72ee4af
    Version: v1.6.1 (stable)
*/

include("shared.lua")
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 76561198314224595

function ENT:Initialize()
	zgo2.Oven.Initialize(self)
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 5f074b2717244cb0b28afc4f82cbfebeed301ee81f5a05ae65232daad257b16a

function ENT:Draw()
	self:DrawModel()
	zgo2.Oven.Draw(self)
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 70b873f322570e153a05d9cee15c50a5d97bffffec86f684a14bf17014b60342
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- a0e6ade09fe02808a86c0dfaee2704d791bcc0344cd386f9ebfd43c1dd1de59e

function ENT:Think()
	zgo2.Oven.Think(self)
	self:SetNextClientThink(CurTime())

	return true
end

function ENT:OnRemove()
	zgo2.Oven.OnRemove(self)
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 76561198314224586

--addons/zeros_growop2_v1.6.1/lua/entities/zgo2_palette.lua:
return gluapack()()
--addons/zeros_growop2_v1.6.1/lua/entities/zgo2_splicer/shared.lua:
/*
    Addon id: 64edeaec-8955-454a-aac4-1d19d72ee4af
    Version: v1.6.1 (stable)
*/

ENT.Type                    = "anim"
ENT.Base                    = "base_anim"
ENT.AutomaticFrameAdvance   = false
ENT.PrintName               = "Splicer"
ENT.Author                  = "ZeroChain"
ENT.Category                = "Zeros GrowOP 2"
ENT.Spawnable               = true
ENT.AdminSpawnable          = false
ENT.Model                   = "models/zerochain/props_growop2/zgo2_lab.mdl"
ENT.RenderGroup             = RENDERGROUP_BOTH

function ENT:SetupDataTables()
	self:NetworkVar("Int", 1, "SpliceStart")
	self:NetworkVar("Int", 2, "SpliceID")
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 8ffb188c701d3f1856df3a15bfe8e14b5be84a41e03a52af8e86de4fbee82eeb
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 76561198314224586
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 76561198314224586

	if SERVER then
		self:SetSpliceStart(-1)
		self:SetSpliceID(-1)
	end
end

function ENT:CanProperty(ply)
    return ply:IsSuperAdmin()
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- a0e6ade09fe02808a86c0dfaee2704d791bcc0344cd386f9ebfd43c1dd1de59e

function ENT:CanTool(ply, tab, str)
    return ply:IsSuperAdmin()
end

function ENT:CanDrive(ply)
    return false
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 70b873f322570e153a05d9cee15c50a5d97bffffec86f684a14bf17014b60342

--addons/zeros_growop2_v1.6.1/lua/entities/zgo2_weedblock.lua:
return gluapack()()
--addons/zeros_golddiggger/lua/entities/zgw_lantern/cl_init.lua:


include("shared.lua")

function ENT:Initialize()
	zgw.Lantern.Initialize(self)
end

function ENT:DrawTranslucent()
	self:Draw()
end

function ENT:Draw()
	self:DrawModel()
	zgw.Lantern.Draw(self)
end

function ENT:OnRemove()
	self:StopSound("zgw_burn")
end

function ENT:Think()
	zclib.util.LoopedSound(self, "zgw_burn", self.IsBurning)
	self:SetNextClientThink(CurTime())

	return true
end

--addons/zeros_golddiggger/lua/entities/zgw_mat/shared.lua:


ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.AutomaticFrameAdvance = true
ENT.Model = "models/zerochain/props_goldwash/zgw_mat.mdl"
ENT.Spawnable = true
ENT.AdminSpawnable = false
ENT.PrintName = "Mat"
ENT.Category = "Zeros GoldWasher"
ENT.RenderGroup = RENDERGROUP_OPAQUE

function ENT:SetupDataTables()
    self:NetworkVar("Int", 1, "Gold")
    if (SERVER) then
        self:SetGold(0)
    end
end

--addons/zeros_methlab02_v1.4.1/lua/entities/zmlab2_item_aluminium/cl_init.lua:
/*
    Addon id: a36a6eee-6041-4541-9849-360baff995a2
    Version: v1.4.1 (stable)
*/

include("shared.lua")
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- ce15eec833bf47ebbcf6161ad127d2657901fd54a4bc9d5aa5fcda90913684bc

function ENT:Initialize()
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- b59bd1b1f8d16a52cb3d0a12454834a0ad28afe2633004db7a9dc71add4aef45
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- f846397ffcf09571d053f7b7aff0b4ab920f6d7152aebc0550c4aa612acbeab0
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- f846397ffcf09571d053f7b7aff0b4ab920f6d7152aebc0550c4aa612acbeab0

end

function ENT:DrawTranslucent()
	self:Draw()
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 76561198347218033

function ENT:Draw()
	self:DrawModel()
end

--addons/zeros_methlab02_v1.4.1/lua/entities/zmlab2_item_lox/shared.lua:
return gluapack()()
--addons/zeros_methlab02_v1.4.1/lua/entities/zmlab2_item_meth/shared.lua:
/*
    Addon id: a36a6eee-6041-4541-9849-360baff995a2
    Version: v1.4.1 (stable)
*/

ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.Model = "models/zerochain/props_methlab/zmlab2_bag.mdl"
ENT.AutomaticFrameAdvance = true
ENT.Spawnable = true
ENT.AdminSpawnable = false
ENT.PrintName = "Meth"
ENT.Category = "Zeros Methlab 2"
ENT.RenderGroup = RENDERGROUP_BOTH

                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- b59bd1b1f8d16a52cb3d0a12454834a0ad28afe2633004db7a9dc71add4aef45

function ENT:SetupDataTables()
    self:NetworkVar("Int", 1, "MethType")
    self:NetworkVar("Int", 2, "MethAmount")
    self:NetworkVar("Int", 3, "MethQuality")
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- f846397ffcf09571d053f7b7aff0b4ab920f6d7152aebc0550c4aa612acbeab0

    if (SERVER) then
        self:SetMethType(2)
        self:SetMethAmount(100)
        self:SetMethQuality(100)
    end
end

function ENT:CanProperty(ply)
    return zclib.Player.IsAdmin(ply)
end

function ENT:CanTool(ply, tab, str)
    return zclib.Player.IsAdmin(ply)
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 76561198347218033

function ENT:CanDrive(ply)
    return zclib.Player.IsAdmin(ply)
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 15871293219a231313fbdc551fcfaeb89901409b08b17abf512df78d792aeeea
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- f846397ffcf09571d053f7b7aff0b4ab920f6d7152aebc0550c4aa612acbeab0

--addons/zeros_methlab02_v1.4.1/lua/entities/zmlab2_item_methylamine/shared.lua:
/*
    Addon id: a36a6eee-6041-4541-9849-360baff995a2
    Version: v1.4.1 (stable)
*/

ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.Model = "models/zerochain/props_methlab/zmlab2_methylamine.mdl"
ENT.AutomaticFrameAdvance = true
ENT.Spawnable = false
ENT.AdminSpawnable = false
ENT.PrintName = "Methylamine"
ENT.Category = "Zeros Methlab 2"
ENT.RenderGroup = RENDERGROUP_OPAQUE
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- ce15eec833bf47ebbcf6161ad127d2657901fd54a4bc9d5aa5fcda90913684bc
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- ce15eec833bf47ebbcf6161ad127d2657901fd54a4bc9d5aa5fcda90913684bc

function ENT:CanProperty(ply)
    return zclib.Player.IsAdmin(ply)
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 76561198347218024

function ENT:CanTool(ply, tab, str)
    return zclib.Player.IsAdmin(ply)
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 76561198347218033

function ENT:CanDrive(ply)
    return zclib.Player.IsAdmin(ply)
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 008d00393091244a629b726da410c82cc21d3876952f1a2fa78c80bc6afb7013

--addons/zeros_methlab02_v1.4.1/lua/entities/zmlab2_machine_mixer/cl_init.lua:
/*
    Addon id: a36a6eee-6041-4541-9849-360baff995a2
    Version: v1.4.1 (stable)
*/

include("shared.lua")

function ENT:Initialize()
	zmlab2.Mixer.Initialize(self)
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 15871293219a231313fbdc551fcfaeb89901409b08b17abf512df78d792aeeea

function ENT:DrawTranslucent()
	self:Draw()
end

function ENT:Draw()
	self:DrawModel()
	zmlab2.Mixer.Draw(self)
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- f846397ffcf09571d053f7b7aff0b4ab920f6d7152aebc0550c4aa612acbeab0
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 76561198347218033

function ENT:Think()
	zmlab2.Mixer.Think(self)
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 15871293219a231313fbdc551fcfaeb89901409b08b17abf512df78d792aeeea

function ENT:OnRemove()
	zmlab2.Mixer.OnRemove(self)
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 76561198347218024

--addons/zeros_methlab02_v1.4.1/lua/entities/zmlab2_tent_door/cl_init.lua:
/*
    Addon id: a36a6eee-6041-4541-9849-360baff995a2
    Version: v1.4.1 (stable)
*/

include("shared.lua")
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 15871293219a231313fbdc551fcfaeb89901409b08b17abf512df78d792aeeea
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 76561198347218033
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 76561198347218033

function ENT:Initialize()
	zmlab2.TentDoor.Initialize(self)
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 76561198347218024

function ENT:DrawTranslucent()
	self:Draw()
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 76561198347218024

function ENT:Draw()
	self:DrawModel()
	zmlab2.TentDoor.Draw(self)
end

function ENT:Think()
	self:SetNextClientThink(CurTime())
	zmlab2.TentDoor.Think(self)

	return true
end

--addons/zeros_methlab02_v1.4.1/lua/entities/zmlab2_tent_door/shared.lua:
return gluapack()()
--addons/zeros_methlab_1.6.4/lua/entities/zmlab_baseanim/cl_init.lua:
return gluapack()()
--addons/zeros_methlab_1.6.4/lua/entities/zmlab_methbuyer/cl_init.lua:
include("shared.lua")

function ENT:Draw()
  self:DrawModel()
  if not binbonentdraw then return end
  binbonentdraw(self, "Meth Alıcısı", true, 0, 10, 20, true)
  binbonentdraw(self, "Ürettiğin basit methleri bana satabilirsin.", false, 0,100, 20, false)
end
--addons/zeros_methlab_1.6.4/lua/entities/zmlab_palette/cl_init.lua:
return gluapack()()
--addons/zeros_methlab_1.6.4/lua/entities/zmlab_sludge/shared.lua:
return gluapack()()
--addons/zeros_retrominer_v2.3.6/lua/entities/zrms_bar_bronze.lua:
/*
    Addon id: 
    Version: v2.3.6 (stable)
*/

AddCSLuaFile()
DEFINE_BASECLASS("zrms_bar")
ENT.Type = "anim"
ENT.Base = "zrms_bar"
ENT.RenderGroup = RENDERGROUP_BOTH
ENT.Spawnable = false
ENT.AdminSpawnable = false
ENT.PrintName = "Bronze Bar"
ENT.Author = "ClemensProduction aka Zerochain"
ENT.Information = "info"
ENT.Category = "Zeros RetroMiningSystem"
ENT.Model = "models/Zerochain/props_mining/zrms_bar.mdl"
ENT.AutomaticFrameAdvance = true
ENT.DisableDuplicator = false
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

function ENT:SetupDataTables()
	self:NetworkVar("String", 0, "MetalType")
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

	if (SERVER) then
		self:SetMetalType("Bronze")
	end
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

--addons/zeros_retrominer_v2.3.6/lua/entities/zrms_bar_silver.lua:
/*
    Addon id: 
    Version: v2.3.6 (stable)
*/

AddCSLuaFile()
DEFINE_BASECLASS("zrms_bar")
ENT.Type = "anim"
ENT.Base = "zrms_bar"
ENT.RenderGroup = RENDERGROUP_BOTH
ENT.Spawnable = false
ENT.AdminSpawnable = false
ENT.PrintName = "Silver Bar"
ENT.Author = "ClemensProduction aka Zerochain"
ENT.Information = "info"
ENT.Category = "Zeros RetroMiningSystem"
ENT.Model = "models/Zerochain/props_mining/zrms_bar.mdl"
ENT.AutomaticFrameAdvance = true
ENT.DisableDuplicator = false
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

function ENT:SetupDataTables()
	self:NetworkVar("String", 0, "MetalType")
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

	if (SERVER) then
		self:SetMetalType("Silver")
	end
end

--addons/zeros_retrominer_v2.3.6/lua/entities/zrms_basket_silver.lua:
/*
    Addon id: 
    Version: v2.3.6 (stable)
*/

AddCSLuaFile()
DEFINE_BASECLASS("zrms_basket")
ENT.Type = "anim"
ENT.Base = "zrms_basket"
ENT.RenderGroup = RENDERGROUP_BOTH
ENT.Spawnable = true
ENT.AdminSpawnable = false
ENT.PrintName = "Crate - Silver"
ENT.Author = "ClemensProduction aka Zerochain"
ENT.Information = "info"
ENT.Category = "Zeros RetroMiningSystem"
ENT.AutomaticFrameAdvance = true
ENT.DisableDuplicator = false
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

function ENT:SetupDataTables()
	self:NetworkVar("Float", 0, "ResourceAmount")
	self:NetworkVar("String", 0, "ResourceType")

	if (SERVER) then
		self:SetResourceAmount(zrmine.config.ResourceCrates_Capacity)
		self:SetResourceType("Silver")
	end
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

--addons/zeros_retrominer_v2.3.6/lua/entities/zrms_conveyorbelt_n.lua:
/*
    Addon id: 
    Version: v2.3.6 (stable)
*/

AddCSLuaFile()
DEFINE_BASECLASS("zrms_conveyorbelt")
ENT.Type = "anim"
ENT.Base = "zrms_conveyorbelt"
ENT.RenderGroup = RENDERGROUP_BOTH
ENT.Spawnable = false
ENT.AdminSpawnable = false
ENT.PrintName = "Conveyorbelt - Normal"
ENT.Author = "ClemensProduction aka Zerochain"
ENT.Information = "info"
ENT.Category = "Zeros RetroMiningSystem"
ENT.Model = "models/zerochain/props_mining/zrms_conveyorbelt_normal.mdl"
ENT.GravelModel = "models/zerochain/props_mining/zrms_conveyorbelt_n_gravel.mdl"
ENT.GravelAnimTime = 5.5
ENT.TransportSpeed = 2
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

--addons/zeros_retrominer_v2.3.6/lua/entities/zrms_conveyorbelt_s.lua:
return gluapack()()
--addons/zeros_retrominer_v2.3.6/lua/entities/zrms_crusher/cl_init.lua:
/*
    Addon id: 
    Version: v2.3.6 (stable)
*/

include("shared.lua")

function ENT:Initialize()
	// The Belt material
	local params = {
		["$basetexture"] = "zerochain/props_mining/conveyorbelt/zrms_conveyorbelt_belt_diff",
		["$bumpMap"] = "zerochain/props_mining/conveyorbelt/zrms_conveyorbelt_belt_nrm",
		["$normalmapalphaenvmapmask"] = 1,
		["$surfaceprop"] = "metal",
		["$halflambert"] = 1,
		["$model"] = 1,
		["$envmap"] = "env_cubemap",
		["$envmaptint"] = Vector(0.01, 0.01, 0.01),
		["$envmapfresnel"] = 1,
		["$phong"] = 1,
		["$phongexponenttexture"] = "zerochain/props_mining/conveyorbelt/zrms_conveyorbelt_belt_phong",
		["$phongtint"] = Vector(1, 1, 1),
		["$phongboost"] = 25,
		["$phongfresnelranges"] = Vector(0.05, 0.5, 1),
		["$myspeed"] = 0,
		Proxies = {
			TextureScroll = {
				texturescrollvar = "$baseTexturetransform",
				texturescrollrate = "$myspeed",
				texturescrollangle = -90
			}
		}
	}
	self.ScrollMat = CreateMaterial("scrollmat" .. self:EntIndex(), "VertexLitGeneric", params)
	self:SetSubMaterial(2, "!scrollmat" .. self:EntIndex())
	self.ScrollMat:SetFloat("$myspeed", 0)

	// The Light Pixel handler
	//self.PixVis = util.GetPixelVisibleHandle()

	// Sets up stuff for the client gravel animation
	zrmine.f.Gravel_Initialize(self)

	// Adds the client ent to the list
	zrmine.f.EntList_Add(self)

	self.LastState = -1
end

function ENT:ReturnStorage()
	return self:GetCoal() + self:GetIron() + self:GetBronze() + self:GetSilver() + self:GetGold()
end

function ENT:StateChanged()
	local CurrentState = self:GetCurrentState()

	if self.LastState ~= CurrentState then
		self.LastState = CurrentState
		return true
	else
		return false
	end
end

function ENT:EffectsHandler()

	if self.LastState == 0 then
		self:StopParticlesNamed("zrms_crusher_crush")

	elseif self.LastState == 1 then

		//Creates the Crush Effect
		local attach = self:GetAttachment(self:LookupAttachment("input"))

		if attach then
			zrmine.f.ParticleEffect("zrms_crusher_crush", attach.Pos,  attach.Ang, self)
		end

		zrmine.f.EmitSoundENT("zrmine_crush",self)
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

		timer.Simple(zrmine.config.Crusher_Time / 2, function()
			if IsValid(self) then

				// Creates the dust effect
				zrmine.f.ParticleEffect("zrms_refiner_refine", self:GetPos() + self:GetForward() * -30 + self:GetUp() * 15, self:GetAngles(), self)
			end
		end)
	end
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

function ENT:AnimationHandler()
	if self.LastState == 1 then

		if self:GetSequenceName(self:GetSequence()) ~= "crushing" then
			local animSpeed = 2 / zrmine.config.Crusher_Time
			animSpeed = math.Clamp(animSpeed,1,2)

			zrmine.f.Animation(self, "crushing", animSpeed)

			local Belt_speed = animSpeed * 2
			self.ScrollMat:SetFloat("$myspeed", Belt_speed)
		end
	else
		// If the current state is idle and we dont have anything in the storage then we play the idle animation
		if self:ReturnStorage() <= 0 and self:GetSequenceName(self:GetSequence()) ~= "idle" then
			zrmine.f.Animation(self, "idle", 1)

			self.ScrollMat:SetFloat("$myspeed", 0)
		end
	end
end

function ENT:CrushSound()
	local MoveSound = CreateSound(self, "zrmine_sfx_refinery_loop")

	if (self.LastState == 1) then
		if self.SoundObj == nil then
			self.SoundObj = MoveSound
		end

		if self.SoundObj:IsPlaying() == false then
			self.SoundObj:Play()
			self.SoundObj:ChangeVolume(0, 0)
			self.SoundObj:ChangeVolume(GetConVar("zrms_cl_audiovolume"):GetFloat(), 1)
		end
	else
		if self.SoundObj == nil then
			self.SoundObj = MoveSound
		end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

		if self.SoundObj:IsPlaying() == true then
			self.SoundObj:ChangeVolume(0, 1)
			if ((self.lastSoundStop or CurTime()) > CurTime()) then return end
			self.lastSoundStop = CurTime() + 5

			timer.Simple(2, function()
				if (IsValid(self)) then
					self.SoundObj:Stop()
				end
			end)
		end
	end
end

function ENT:Think()

	if zrmine.f.InDistance(self:GetPos(), LocalPlayer():GetPos(), 1000) then
		// Returns true after the state changed
		if self:StateChanged() then

			// Handels the effects
			self:EffectsHandler()
		end

		// Handles the animation of the model
		self:AnimationHandler()
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

		// Handels the Crushing shound
		self:CrushSound()

		// Handels the gravel animation
		zrmine.f.ClientGravelAnim(self)
	end
	self:SetNextClientThink(CurTime())
	return true
end

function ENT:IndicatorLight(id,pos,state)

	local LightPos = self:LocalToWorld(pos)

	local ViewNormal = self:GetPos() - EyePos()
	ViewNormal:Normalize()

	if self.PixelVisibleHandles == nil then
		self.PixelVisibleHandles = {}
	end

	//Create PixelVisibleHandle if nil
	if self.PixelVisibleHandles[id] == nil then
		self.PixelVisibleHandles[id] = {
			handle = util.GetPixelVisibleHandle(),
			IsVisible = 0,
		}
	end

	self.PixelVisibleHandles[id].IsVisible = util.PixelVisible(LightPos, 3,self.PixelVisibleHandles[id].handle)

	if self.PixelVisibleHandles[id].IsVisible and self.PixelVisibleHandles[id].IsVisible > 0.1 then
		local spriteColor = zrmine.default_colors["red03"]
		if state then
			spriteColor = zrmine.default_colors["green02"]
		end

		render.SetMaterial(zrmine.default_materials["light_ignorez"])
		render.DrawSprite(LightPos, 25, 25, spriteColor)
	end
end

// The Info screen
local offsetX, offsetY = 55, 18
function ENT:DrawResourceItem(OreType, xpos, ypos, size)
	local color = zrmine.f.GetOreColor(OreType)

	surface.SetDrawColor(color)
	surface.SetMaterial(zrmine.default_materials["Ore"])
	surface.DrawTexturedRect(xpos + offsetX, ypos + offsetY, size, size)

	draw.DrawText(": " .. math.Round(zrmine.f.GetOreFromEnt(self,OreType)) .. zrmine.config.BuyerNPC_Mass, "zrmine_screen_font3", xpos + offsetX + 30, ypos + offsetY + size * 0.25, color, TEXT_ALIGN_LEFT)
end

function ENT:DrawInfo()
	cam.Start3D2D(self:LocalToWorld(Vector(15,0,56.4)), self:LocalToWorldAngles(Angle(0,90,90)), 0.1)
		draw.RoundedBox(0, -105, -65, 210, 130, zrmine.default_colors["grey02"])
		local aBar = (100 / zrmine.config.Crusher_Capacity) * self:ReturnStorage()

		if (aBar > 100) then
			aBar = 100
		end
		draw.RoundedBox(0, -87, 50, 30,-aBar, zrmine.default_colors["brown01"])


		self:DrawResourceItem("Coal", -105, -75, 30)
		self:DrawResourceItem("Iron", -105, -55, 30)
		self:DrawResourceItem("Bronze", -105, -35, 30)
		self:DrawResourceItem("Silver", -105, -15, 30)
		self:DrawResourceItem("Gold", -105, 5, 30)

		surface.SetDrawColor(zrmine.default_colors["white02"])
		surface.SetMaterial(zrmine.default_materials["Scale"])
		surface.DrawTexturedRect(-110, -53, 75, 105)
	cam.End3D2D()
end

function ENT:Draw()
	self:DrawModel()

	if (zrmine.f.InDistance(LocalPlayer():GetPos(), self:GetPos(), 300)) then

		self:DrawInfo()

		if GetConVar("zrms_cl_lightsprites"):GetInt() == 1 then
			self:IndicatorLight("Default",Vector(-19,0,42),IsValid(self:GetModuleChild()))
		end
	end
end

function ENT:DrawTranslucent()
	self:Draw()
end

function ENT:OnRemove()
	if (self.SoundObj ~= nil and self.SoundObj:IsPlaying()) then
		self.SoundObj:Stop()
	end

	zrmine.f.RemoveClientGravel(self)
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

--addons/zeros_retrominer_v2.3.6/lua/entities/zrms_resource_coal.lua:
return gluapack()()
--addons/zeros_retrominer_v2.3.6/lua/entities/zrms_sorter_bronze.lua:
return gluapack()()
--addons/zeros_retrominer_v2.3.6/lua/entities/zrms_sorter_gold.lua:
/*
    Addon id: 
    Version: v2.3.6 (stable)
*/

AddCSLuaFile()
DEFINE_BASECLASS("zrms_sorter")
ENT.Type = "anim"
ENT.Base = "zrms_sorter"
ENT.RenderGroup = RENDERGROUP_OPAQUE
ENT.Spawnable = false
ENT.AdminSpawnable = false
ENT.PrintName = "Filter - Gold"
ENT.Author = "ClemensProduction aka Zerochain"
ENT.Information = "info"
ENT.Category = "Zeros RetroMiningSystem"
ENT.Model = "models/zerochain/props_mining/zrms_conveyorbelt_sorter.mdl"
ENT.AutomaticFrameAdvance = true
ENT.DisableDuplicator = false
ENT.SorterSpeed = 3
ENT.WorkAmount = 6
ENT.HoldAmount = 25
ENT.FilterType = "Gold" // What type of resource are we sorting out
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

--addons/zeros_retrominer_v2.3.6/lua/entities/zrms_sorter_silver.lua:
/*
    Addon id: 
    Version: v2.3.6 (stable)
*/

AddCSLuaFile()
DEFINE_BASECLASS("zrms_sorter")
ENT.Type = "anim"
ENT.Base = "zrms_sorter"
ENT.RenderGroup = RENDERGROUP_OPAQUE
ENT.Spawnable = false
ENT.AdminSpawnable = false
ENT.PrintName = "Filter - Silver"
ENT.Author = "ClemensProduction aka Zerochain"
ENT.Information = "info"
ENT.Category = "Zeros RetroMiningSystem"
ENT.Model = "models/zerochain/props_mining/zrms_conveyorbelt_sorter.mdl"
ENT.AutomaticFrameAdvance = true
ENT.DisableDuplicator = false
ENT.SorterSpeed = 3
ENT.WorkAmount = 6
ENT.HoldAmount = 25
ENT.FilterType = "Silver" // What type of resource are we sorting out
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

--addons/zeros_retrominer_v2.3.6/lua/entities/zrms_splitter/shared.lua:
/*
    Addon id: 
    Version: v2.3.6 (stable)
*/

ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.RenderGroup = RENDERGROUP_OPAQUE
ENT.Spawnable = false
ENT.AdminSpawnable = false

ENT.PrintName = "Conveyorbelt - Splitter"
ENT.Author = "ClemensProduction aka Zerochain"
ENT.Information = "info"
ENT.Category = "Zeros RetroMiningSystem"
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

ENT.Model = "models/zerochain/props_mining/zrms_conveyorbelt_splitter.mdl"
ENT.AutomaticFrameAdvance = true
ENT.DisableDuplicator = false
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

ENT.SplitingSpeed = 3
ENT.WorkAmount = 6
ENT.HoldAmount = zrmine.config.SplitterBelt_Capacity
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

function ENT:SetupDataTables()
	self:NetworkVar("Int", 0, "CurrentState")
	self:NetworkVar("Entity", 0, "ModuleChild01")
	self:NetworkVar("Entity", 1, "ModuleChild02")
	self:NetworkVar("Entity", 2, "ModuleParent")
	self:NetworkVar("Int", 2, "ConnectionPos")

	if (SERVER) then
		self:SetModuleChild01(NULL)
		self:SetModuleChild02(NULL)
		self:SetModuleParent(NULL)
		self:SetConnectionPos(-1)
		self:SetCurrentState(0)
	end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

	self:NetworkVar("Float", 4, "Coal")
	self:NetworkVar("Float", 0, "Iron")
	self:NetworkVar("Float", 1, "Bronze")
	self:NetworkVar("Float", 2, "Silver")
	self:NetworkVar("Float", 3, "Gold")

	if SERVER then
		self:SetCoal(0)
		self:SetIron(0)
		self:SetBronze(0)
		self:SetSilver(0)
		self:SetGold(0)
	end
end

--addons/zeros_trashman_v1.6.3/lua/entities/ztm_leafpile/cl_init.lua:


include("shared.lua")

function ENT:Initialize()
	zclib.EntityTracker.Add(self)
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

function ENT:Draw()
	self:DrawModel()
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

--addons/zeros_trashman_v1.6.3/lua/entities/ztm_manhole/cl_init.lua:
return gluapack()()
--addons/zeros_trashman_v1.6.3/lua/entities/ztm_manhole/cl_init.lua:
/*
    Addon id: 
    Version: v1.6.3 (stable)
*/

include("shared.lua")
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

function ENT:Initialize()
	ztm.Manhole.Initialize(self)
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

function ENT:Draw()
	self:DrawModel()
	ztm.Manhole.Draw(self)
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

function ENT:Think()
	ztm.Manhole.Think(self)
	self:SetNextClientThink(CurTime())
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

	return true
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

function ENT:OnRemove()
	ztm.Manhole.OnRemove(self)
end

--addons/zeros_yeastbeast_1.1.7/lua/entities/zyb_buyer_npc/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()

	if zyb.f.InDistance(LocalPlayer():GetPos(), self:GetPos(), 500) then
		self:DrawInfo()
	end
end

function ENT:DrawInfo()
	local Pos = self:GetPos() + self:GetUp() * 80
	Pos = Pos + self:GetUp() * math.abs(math.sin(CurTime()) * 1)
	local Ang = Angle(0, LocalPlayer():EyeAngles().y - 90, 90)
	cam.Start3D2D(Pos, Ang, 0.1)
		draw.RoundedBox(25, -200, 25, 400, 50, zyb.default_colors["black01"])

		draw.SimpleTextOutlined(self:GetPrice() .. zyb.config.Currency .. " / " .. zyb.language.NPC["Jar"], "zyb_npc_font02", 0, 53, zyb.default_colors["white01"], TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 3, zyb.default_colors["black02"])

		draw.SimpleTextOutlined(zyb.language.NPC["MoonshineBuyer"], "zyb_npc_font01", 0, 0, zyb.default_colors["white01"], TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 3, zyb.default_colors["black02"])
	cam.End3D2D()
end

--addons/zeros_yeastbeast_1.1.7/lua/entities/zyb_distillery/cl_init.lua:
return gluapack()()
--addons/zeros_yeastbeast_1.1.7/lua/entities/zyb_fermbarrel/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()

	if zyb.f.InDistance(LocalPlayer():GetPos(), self:GetPos(), 300) and self:GetHideUI() == false then
		self:DrawInfo()
	end
end

function ENT:DrawTranslucent()
	self:Draw()
end

function ENT:DrawInfo()
	local y_bar = 500 / zyb.config.FermBarrel.YeastAmount * self.Yeast
	local w_bar = 500 / zyb.config.FermBarrel.WaterAmount * self.Water
	local s_bar = 500 / zyb.config.FermBarrel.SugarAmount * self.Sugar

	self.stage = self:GetStage()


	cam.Start3D2D(self:LocalToWorld(Vector(0, 0, 70)), Angle(0, EyeAngles().y - 90, -EyeAngles().x + 90), 0.05)

		// Title
		draw.RoundedBox(25, -350, 0, 700, 90, zyb.default_colors["black01"])
		draw.SimpleText(zyb.language.General["Fermentation Barrel"], "zyb_barrel_font01", 0, 10, zyb.default_colors["white01"], TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )


		//Info
		--draw.RoundedBox(25, -350, 100, 700, 320, zyb.default_colors["black01"])

		if self.stage == 0 then

			--draw.RoundedBox(39, -195, 115, 510, 80, zyb.default_colors["white01"])
			draw.RoundedBox(35, -190, 120, 500, 70, zyb.default_colors["black03"])
			draw.RoundedBox(35, -190, 120, y_bar, 70, zyb.default_colors["yeast"])
			//draw.SimpleText(zyb.language.General["Yeast"] .. ":", "zyb_barrel_font02", -325, 110, zyb.default_colors["white01"], TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
			surface.SetDrawColor(zyb.default_colors["white01"])
			surface.SetMaterial(zyb.default_materials["yeast"])
			surface.DrawTexturedRect(-320, 100, 100, 100)

			--draw.RoundedBox(39, -195, 215, 510, 80, zyb.default_colors["white01"])
			draw.RoundedBox(35, -190, 220, 500, 70, zyb.default_colors["black03"])
			draw.RoundedBox(35, -190, 220, s_bar, 70, zyb.default_colors["sugar"])
			//draw.SimpleText(zyb.language.General["Sugar"] .. ":", "zyb_barrel_font02", -325, 180, zyb.default_colors["white01"], TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
			surface.SetDrawColor(zyb.default_colors["white01"])
			surface.SetMaterial(zyb.default_materials["sugar"])
			surface.DrawTexturedRect(-320, 200, 100, 100)

			--draw.RoundedBox(39, -195, 315, 510, 80, zyb.default_colors["white01"])
			draw.RoundedBox(35, -190, 320, 500, 70, zyb.default_colors["black03"])
			draw.RoundedBox(35, -190, 320, w_bar, 70, zyb.default_colors["water"])
			//draw.SimpleText(zyb.language.General["Water"] .. ":", "zyb_barrel_font02", -325, 250, zyb.default_colors["white01"], TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
			surface.SetDrawColor(zyb.default_colors["white01"])
			surface.SetMaterial(zyb.default_materials["water"])
			surface.DrawTexturedRect(-320, 300, 100, 100)



		elseif self.stage == 1 then
			draw.SimpleText(zyb.language.General["Shakeit"], "zyb_barrel_font03", 0, 125, zyb.default_colors["white01"], TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
			local shake_bar = 500 / zyb.config.FermBarrel.ShakeCount * self:GetShakeProgress()

			self.CurrentShakeBar = self.CurrentShakeBar + 100 * FrameTime()
			self.CurrentShakeBar = math.Clamp(self.CurrentShakeBar,0,shake_bar)


			draw.RoundedBox(5, -250, 225, 500, 50, zyb.default_colors["black03"])
			draw.RoundedBox(5, -250, 225, self.CurrentShakeBar, 50, zyb.default_colors["white04"])
		elseif self.stage == 2 then
			draw.SimpleText(zyb.language.General["Fermenting"], "zyb_barrel_font03", 0, 125, zyb.default_colors["white01"], TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
			local ferment_bar = 500 / zyb.config.FermBarrel.FermentingTime * (zyb.config.FermBarrel.FermentingTime-(self:GetFermentingTime() - CurTime()))

			self.CurrentShakeBar = self.CurrentShakeBar + 100 * FrameTime()
			self.CurrentShakeBar = math.Clamp(self.CurrentShakeBar,0,ferment_bar)

			local ferment_col = 1 / zyb.config.FermBarrel.FermentingTime * (zyb.config.FermBarrel.FermentingTime-(self:GetFermentingTime() - CurTime()))
			local fermColor = zyb.f.LerpColor(ferment_col, zyb.default_colors["brown08"], zyb.default_colors["brown01"])


			draw.RoundedBox(5, -250, 225, 500, 50, zyb.default_colors["black03"])
			draw.RoundedBox(5, -250, 225, self.CurrentShakeBar, 50, fermColor)
		elseif self.stage == 3 then

			local ys_amount =  self:GetYeastStew()

			draw.SimpleText(zyb.language.General["YeastStew"] .. ": " .. ys_amount .. zyb.config.LiquidUnit, "zyb_barrel_font02", 0, 135, zyb.default_colors["white01"], TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)

			local YeastStew_bar = (500 / zyb.config.FermBarrel.YeastStew) * ys_amount

			self.CurrentShakeBar = self.CurrentShakeBar + 100 * FrameTime()
			self.CurrentShakeBar = math.Clamp(self.CurrentShakeBar,0,YeastStew_bar)


			draw.RoundedBox(5, -250, 225, 500, 50, zyb.default_colors["black03"])
			draw.RoundedBox(5, -250, 225, self.CurrentShakeBar, 50, zyb.default_colors["brown01"])
		elseif self.stage == 4 then
			draw.SimpleText(zyb.language.General["Cleanit"], "zyb_barrel_font01", 0, 175, zyb.default_colors["white01"], TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
		end

	cam.End3D2D()
end

function ENT:Initialize()
	self.CurrentMixtureLevel = -1
	self.Yeast = 0
	self.Water = 0
	self.Sugar = 0
	self.LastProgress = -1

	self.LastShake = -1
	self.CurrentShakeBar = 0

	self.CurrentCleanLevel = 0

	self.MashEffect = false
	self.FermentEffect = false
end

function ENT:IsFermenting()
	if self:GetStage() == 2 then
		return true
	else
		return false
	end
end

function ENT:Think()

	zyb.f.LoopedSound(self, "zyb_fill_liquid", self:GetFilling())
	zyb.f.LoopedSound(self, "zyb_fermenting", self:IsFermenting())

	if zyb.f.InDistance(LocalPlayer():GetPos(), self:GetPos(), 500) then

		self.Yeast = self:GetYeastAmount()
		self.Water = self:GetWaterAmount()
		self.Sugar = self:GetSugarAmount()

		self:ShakeSound()

		if self.ClientProps then
			if not IsValid(self.ClientProps["Water"]) then
				self:SpawnClientModel_Mixture()
			else

				local maxCap = zyb.config.FermBarrel.YeastAmount + zyb.config.FermBarrel.WaterAmount + zyb.config.FermBarrel.SugarAmount
				local newMixLvl = (1 / maxCap) * (self.Yeast + self.Water + self.Sugar)

				if self.CurrentMixtureLevel ~= newMixLvl then

					self.CurrentMixtureLevel = self.CurrentMixtureLevel + 0.25 * FrameTime()
					self.CurrentMixtureLevel = math.Clamp(self.CurrentMixtureLevel,0,newMixLvl)

					local mat = Matrix()
					mat:Scale(Vector(1, 1, self.CurrentMixtureLevel))
					self.ClientProps["Water"]:EnableMatrix("RenderMultiply", mat)

					if newMixLvl <= 0 then
						self.ClientProps["Water"]:SetNoDraw(true)
					else
						self.ClientProps["Water"]:SetNoDraw(false)
					end

					local col = zyb.f.LerpColor(newMixLvl, zyb.default_colors["blue05"], zyb.default_colors["brown07"])
					self.ClientProps["Water"]:SetColor(col)
				end

				self.ClientProps["Water"]:SetPos( self:LocalToWorld( Vector( 0, 0, 0 ) ) )
			end
		else
			self.ClientProps = {}
		end

		if self:GetFermentingTime() > 0 then
			if self.FermentEffect == false then
				zyb.f.ParticleEffectAttach("yb_fermenting", self, 1)
				self.FermentEffect = true
			end
		else
			if self.FermentEffect then
				self:StopParticlesNamed("yb_fermenting")
				self.FermentEffect = false
			end
		end


		local clean = self:GetDirtLevel()

		if self.CurrentCleanLevel ~= clean then
			self.CurrentCleanLevel = clean

			self:SetColor(zyb.f.LerpColor((1 / zyb.config.FermBarrel.DirtAmount) * clean, zyb.default_colors["white01"], zyb.default_colors["orange04"]))

			if clean <= 0 then
				self:SetColor(zyb.default_colors["white01"])
			end
		end
	else
		if self.FermentEffect then
			self:StopParticlesNamed("yb_fermenting")
			self.FermentEffect = false
		end
		self.CurrentMixtureLevel = -1
		self:RemoveClientModels()
	end

	self:SetNextClientThink(CurTime())
	return true
end

function ENT:SpawnClientModel_Mixture()
	local ent = ents.CreateClientProp()
	ent:SetPos( self:LocalToWorld( Vector( 0, 0, 0 ) ) )
	ent:SetModel("models/zerochain/props_yeastbeast/yb_barrel_liquid.mdl")
	ent:SetAngles( self:LocalToWorldAngles( Angle( 0, 0, 0 ) ) )
	ent:Spawn()
	ent:Activate()
	ent:SetRenderMode(RENDERMODE_TRANSALPHA)
	ent:SetColor(zyb.default_colors["blue05"])
	ent:SetParent(self)

	self.ClientProps["Water"] = ent
end

function ENT:RemoveClientModels()
	if (self.ClientProps and table.Count(self.ClientProps) > 0) then
		for k, v in pairs(self.ClientProps) do
			if IsValid(v) then
				v:Remove()
			end
		end
	end
	self.ClientProps = {}
end

function ENT:OnRemove()
	self:StopSound("zyb_fill_liquid")
	self:StopSound("zyb_fermenting")
	self:RemoveClientModels()
end

function ENT:ShakeSound()
	if self.stage ~= 1 then
		if self.ShakeSoundObj and self.ShakeSoundObj:IsPlaying() == true then
			self.ShakeSoundObj:ChangeVolume(0, 0)
			self.ShakeSoundObj:Stop()
			self:EmitSound("zyb_shaking_end")
		end

		return
	end

	if CurTime() < self.LastShake then return end

	if self:GetVelocity():Length() > 50 then
		if self.ShakeSoundObj == nil then
			self.ShakeSoundObj = CreateSound(self, "zyb_shaking_loop")
		end

		if self.ShakeSoundObj:IsPlaying() == false then
			self.ShakeSoundObj:Play()
			self.ShakeSoundObj:ChangeVolume(1, 0)
		end
	else
		if self.ShakeSoundObj and self.ShakeSoundObj:IsPlaying() == true then
			self.ShakeSoundObj:ChangeVolume(0, 0)
			self.ShakeSoundObj:Stop()
			self:EmitSound("zyb_shaking_end")
		end
	end

	self.LastShake = CurTime() + 0.5
end

--addons/zeros_yeastbeast_1.1.7/lua/entities/zyb_fuel/shared.lua:
return gluapack()()
--addons/zeros_yeastbeast_1.1.7/lua/entities/zyb_jarcrate/cl_init.lua:
return gluapack()()
--addons/zeros_yeastbeast_1.1.7/lua/entities/zyb_jarpack/cl_init.lua:
return gluapack()()
--addons/zeros_yeastbeast_1.1.7/lua/entities/zyb_palette/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()
end

function ENT:DrawTranslucent()
	self:Draw()
end

function ENT:Initialize()
	self.Count_Y = 0
	self.Count_X = 0
	self.Count_Z = 0

	self.LastCrateCount = 0
end

function ENT:CrateChangeUpdater()
	local crateCount = self:GetCrateCount()

	if self.LastCrateCount ~= crateCount then
		self.LastCrateCount = crateCount

		self:UpdateClientProps()
	end
end


function ENT:Think()
	if zyb.f.InDistance(LocalPlayer():GetPos(), self:GetPos(), 1000) then
		self:CrateChangeUpdater()
	else
		self:RemoveClientModels()
		self.ClientProps = {}
		self.LastCrateCount = -1
	end
end

function ENT:UpdateClientProps()
	self:RemoveClientModels()

	self.ClientProps = {}

	if self.LastCrateCount > 0 then
		for i = 1, self.LastCrateCount do
			self:CreateClientCrate(i)
		end
	end
end

function ENT:OnRemove()
	self:RemoveClientModels()
end

function ENT:CreateClientCrate(cratecount)

	local pos = self:GetPos() - self:GetRight() * 25 - self:GetForward() * 50 + self:GetUp() * 3
	local ang = self:GetAngles()

	if self.Count_X >= 2 then
		self.Count_X = 1
		self.Count_Y = self.Count_Y + 1
	else
		self.Count_X = self.Count_X + 1
	end

	if self.Count_Y >= 3 then
		self.Count_Y = 0
		self.Count_Z = self.Count_Z + 1
	end

	pos = pos + self:GetForward() * 33 * self.Count_X
	pos = pos + self:GetRight() * 25 * self.Count_Y
	pos = pos + self:GetUp() * 13.5 * self.Count_Z


	local crate = ents.CreateClientProp()
	crate:SetAngles(ang)
	crate:SetPos(pos)
	crate:SetModel("models/zerochain/props_yeastbeast/yb_jarcrate_full.mdl")

	crate:Spawn()
	crate:Activate()

	crate:SetRenderMode(RENDERMODE_NORMAL)
	crate:SetParent(self)

	table.insert(self.ClientProps, crate)
end

function ENT:RemoveClientModels()
	self.Count_Y = 0
	self.Count_X = 0
	self.Count_Z = 0

	if self.ClientProps and table.Count(self.ClientProps) > 0 then
		for k, v in pairs(self.ClientProps) do
			if IsValid(v) then
				v:Remove()
			end
		end
	end
end

--addons/glorifiedleveling/lua/effects/glorifiedleveling_confetti/init.lua:
return gluapack()()
--addons/serious_business/lua/effects/sb_product_progress.lua:
/*----------------------------------------------------------------------
Leak by Famouse

Play good games:↓
store.steampowered.com/curator/32364216

Subscribe to the channel:↓
www.youtube.com/c/Famouse

More leaks in the discord:↓ 
https://discord.gg/rFdQwzm
------------------------------------------------------------------------*/

--[[
	Just a first attempt in effect.
	Green text just makes me feel better.
]]--

function EFFECT:Init(data)
	
	local offset = data:GetOrigin();
	local scale = 1.5;
	
	--sound.Play("garrysmod/balloon_pop_cute.wav", offset, 90, math.random(90, 120));
	
	local particlesAmount = 1;
	local emitter = ParticleEmitter(offset, false);

	local particle = emitter:Add("sgm/playercircle", offset);
	
	if (particle) then
		
		particle:SetVelocity(Vector(math.random(-8, 8), math.random(-8, 8), 64));
		
		particle:SetLifeTime(0);
		particle:SetDieTime(2);
		
		particle:SetStartAlpha(255);
		particle:SetEndAlpha(255);
		
		particle:SetStartSize(8*scale);
		particle:SetEndSize(4*scale);
		
		particle:SetRoll(math.random(180, 480));
		particle:SetRollDelta(math.random(-2, 2));
		
		particle:SetAirResistance(256);
		particle:SetGravity(Vector(0, 0, 64));
		
		particle:SetColor(51, 255, 0);
		
		particle:SetCollide(true);
		particle:SetBounce(1);
		
		particle:SetAngleVelocity(Angle(math.random(-2, 2), math.random(-2, 2), math.random(-2, 2)));
		
		particle:SetLighting(true);
	end;
	emitter:Finish();
end;


function EFFECT:Think()
	return false;
end;


function EFFECT:Render()

end;

/*------------------------------------------------------------------------
Donation for leaks

Qiwi Wallet         4890494419811120 
YandexMoney         410013095053302
WebMoney(WMR)       R235985364414
WebMoney(WMZ)       Z309855690994
------------------------------------------------------------------------*/
--addons/serious_business/lua/effects/sb_work_progress.lua:
return gluapack()()
--addons/oneprint/lua/oneprint/shared/i18n/tr.lua:
return gluapack()()
--addons/oneprint/lua/oneprint/shared/init.lua:
OnePrint.ServerFreq = 3.2
OnePrint.OCFreq = 1.4

--[[

    DON'T EDIT ANYTHING BELOW THIS !!!!
    It serves as a reference and/or limitation for the script

]]--

local tCfgLimits = {
    [ "MaxUsers" ] = { min = 0, max = 8 },
    [ "MaxIncomeHistory" ] = { min = 6, max = 24 },
    [ "IncomeHistoryDelay" ] = { min = 5, max = 3600 },
    [ "MaxActionsHistory" ] = { min = 1, max = 10 },
    [ "DamageChance" ] = { min = 0, max = 100 },
    [ "CrititalCondition" ] = { min = 0, max = 99 },
    [ "CPDestroyReward" ] = { min = 0 },
    [ "RepairPrice" ] = { min = 0 },
    [ "ServerPrice" ] = { min = 0 },
    [ "ServerIncome" ] = { min = 0 },
    [ "ServerStorage" ] = { min = 0 },
    [ "FanPrice" ] = { min = 0 },
    [ "WatercoolingPrice" ] = { min = 0 },
    [ "PowerPrice" ] = { min = 0 },
    [ "OverclockingPrice" ] = { min = 0 },
    [ "OverclockingIncome" ] = { min = 0 },
    [ "HackingErrorMargin" ] = { min = 0, max = 50 },
    [ "HackingSpeedMin" ] = { min = .1, max = 2 },
    [ "HackingSpeedMax" ] = { min = .1, max = 2 },
    [ "HackingSecurityMax" ] = { min = 1, max = 32 },
    [ "DefensePrice" ] = { min = 0 },
    [ "DefenseBoost" ] = { min = 0 },
    [ "DefenseMax" ] = { min = 1, max = 32 },
    [ "FireChance" ] = { min = 0, max = 100 }
}

for k, v in pairs( tCfgLimits ) do
    local iCfgVal = OnePrint.Cfg[ k ]
    if iCfgVal then
        if v.min and ( iCfgVal < v.min ) then
            OnePrint.Cfg[ k ] = v.min
        end

        if v.max and ( iCfgVal > v.max ) then
            OnePrint.Cfg[ k ] = v.max
        end
    end
end

tCfgLimits = nil

OnePrint.Upgrade = {
    [ 1 ] = {
        name = OnePrint:L( "Servers" ),
        price = OnePrint.Cfg.ServerPrice,
        mutators = {
            income = OnePrint.Cfg.ServerIncome,
            storage = OnePrint.Cfg.ServerStorage,
            power = 1,
            heat = 32,
            overclocking = 1,
            watercooling = 1,
            maxSilencer = 1,
            maxSecurity = OnePrint.Cfg.HackingSecurityMax,
        },
    },
    [ 2 ] = {
        name = OnePrint:L( "Defense" ),
        price = OnePrint.Cfg.DefensePrice,
        mutators = {
            maxHealth = OnePrint.Cfg.DefenseBoost
        }
    },
    [ 3 ] = {
        name = OnePrint:L( "Watercooling" ),
        price = OnePrint.Cfg.WatercoolingPrice,
        mutators = {
            heat = -12
        }
    },
    [ 4 ] = {
        name = OnePrint:L( "Power" ),
        price = OnePrint.Cfg.PowerPrice,
        mutators = {
            heat = 8,
            watercooling = 2,
            overclocking = 1,
        }
    },
    [ 5 ] = {
        name = OnePrint:L( "Overclocking" ),
        price = OnePrint.Cfg.OverclockingPrice,
        mutators = {
            incomeP = OnePrint.Cfg.OverclockingIncome,
            heat = 4
        }
    },
    [ 6 ] = {
        name = OnePrint:L( "Security" ),
        price = OnePrint.Cfg.SecurityPrice,
        mutators = {
            security = 1
        }
    },
    [ 7 ] = {
        name = OnePrint:L( "Silencer" ),
        price = OnePrint.Cfg.SilencerPrice,
        mutators = {
            silencer = 1
        }
    },
    [ 8 ] = {
        name = OnePrint:L( "Hacking notification" ),
        price = OnePrint.Cfg.HackNotifyPrice,
        mutators = {
            hackNotify = 1
        }
    },
    [ 9 ] = {
        name = OnePrint:L( "Low HP notification" ),
        price = OnePrint.Cfg.LowHPNotifyPrice,
        mutators = {
            lowHPNotify = 1
        }
    },
}
--addons/oneprint/lua/oneprint/client/vgui/tabs/hack.lua:
local Hack = {}

Hack.ID = 4
Hack.Name = OnePrint:L( "Hack" )

local matLock = Material( "materials/oneprint/lock.png", "smooth" )
local matCircle = Material( "materials/oneprint/hack_circleoutline.png", "smooth" )
local matCircle2 = Material( "materials/oneprint/circle_full.png", "smooth" )
local matTarget = Material( "materials/oneprint/hack_target.png", "smooth" )
local matPoint = Material( "materials/oneprint/hack_point.png", "smooth" )

--[[

    randomString

]]--

local function randomString( iLen )
    if not iLen or not isnumber( iLen ) or ( iLen < 1 ) then
        iLen = 1
    end

    local sRandString = ""
    for i = 1, iLen do
        sRandString = sRandString .. string.char( math.random( 42, 126 ) )
    end

    return sRandString
end

--[[

    Hack.Run

]]--

function Hack.Run( dBase )
    if not dBase or not IsValid( dBase ) then
        return
    end

    if not dBase.eEntity or not IsValid( dBase.eEntity ) or ( dBase.eEntity:GetClass() ~= "oneprint" ) then
        return
    end

    dBase.ActiveTab = vgui.Create( "DPanel", dBase )
    dBase.ActiveTab:SetSize( dBase:GetWide(), dBase:GetTall() )
    dBase.ActiveTab.Paint = nil

    -- Hack
    local dLock = vgui.Create( "DButton", dBase.ActiveTab )
    dLock:SetSize( ( dBase:GetTall() * .05 ), ( dBase:GetTall() * .05 ) )
    dLock:SetText( "" )
    dLock:AlignRight( OnePrint.iMargin )
    dLock:AlignTop( OnePrint.iMargin )
    dLock.tColor = OnePrint:C( 1 )

    function dLock:Paint( iW, iH )
        surface.SetDrawColor( self.tColor )
        surface.SetMaterial( matLock )
        surface.DrawTexturedRect( 0, 0, iW, iH , 0 )
    end

    function dLock:OnCursorEntered()
        self.tColor = OnePrint:C( 5 )
    end

    function dLock:OnCursorExited()
        self.tColor = OnePrint:C( 2 )
    end

    function dLock:DoClick()
        OnePrint:SetTab( dBase, 0 )
    end

    local dHack = vgui.Create( "DButton", dBase.ActiveTab )
    dHack:SetSize( ( dBase:GetTall() * .5 ), ( dBase:GetTall() * .5 ) )
    dHack:SetPos( ( dBase:GetWide() * .5 ) - ( dHack:GetWide() * .5 ), ( dBase:GetTall() * .5 ) - ( dHack:GetTall() * .5 ) )
    dHack:SetText( string.upper( OnePrint:L( "Hack" ) ) )
    dHack:SetFont( "OnePrint.1" )
    dHack:SetTextInset( 0, 4 )
    dHack:SetTextColor( OnePrint:C( 5 ) )

    function dHack:Start()
        self.iStep = 0
        self.iMaxSteps = ( dBase.eEntity:GetSecurity() + 1 )
        self.iCur = 0
        self.bRight = true
        self.iGoal = math.random( ( 8 + OnePrint.Cfg.HackingErrorMargin ), ( 352 - OnePrint.Cfg.HackingErrorMargin ) )
        self.iSpeed = math.random( OnePrint.Cfg.HackingSpeedMin, OnePrint.Cfg.HackingSpeedMax )
        self.fLerpSpeed = 0
        self.bStarted = true

        self:SetText( math.Round( self.iStep * 100 / self.iMaxSteps ) .. "%" )
    end

    function dHack:Stop()
        self:SetDisabled( true )
        self.bStarted = nil 
        
        if self.bSuccess then
            self:SetText( string.upper( OnePrint:L( "Success" ) ) .. " !" )
            self.tColor = OnePrint:C( 3 )
        else
            self:SetText( string.upper( OnePrint:L( "Fail" ) ) )
            self.tColor = OnePrint:C( 4 )
        end

        self:SetTextColor( self.tColor )

        timer.Simple( 1, function()
            if not dHack or not IsValid( dHack ) then
                return
            end

            if IsValid( self ) and self.bSuccess then
                if dBase and dBase.eEntity then
                    OnePrint:SetTab( dBase, dBase.eEntity:GetCurrentTab() )
                end
            else
                if dBase and IsValid( dBase ) then
                    OnePrint:SetTab( dBase, 0 )
                end
            end
        end )
    end

    function dHack:Verify()
        if self.bValid then
            self.iStep = ( self.iStep + 1 )

            if ( self.iStep >= self.iMaxSteps ) then
                net.Start( "OnePrintNW" )
                    net.WriteUInt( 8, 4 )
                    net.WriteEntity( dBase.eEntity )
                net.SendToServer()

                self.bSuccess = true
                self:Stop()

                return
            end

            self:SetText( math.Round( self.iStep * 100 / self.iMaxSteps ) .. "%" )

            self.bRight = not self.bRight
            self.iSpeed = math.random( OnePrint.Cfg.HackingSpeedMin, OnePrint.Cfg.HackingSpeedMax )
            self.iGoal = math.random( ( 8 + OnePrint.Cfg.HackingErrorMargin ), ( 352 - OnePrint.Cfg.HackingErrorMargin ) )
        else
            self:Stop()
        end
    end

    function dHack:DoClick()
        local iTime = ( self.fNextOccur or 0 ) - CurTime()
        if ( iTime < 0 ) then
            if not self.bStarted then
                self:Start()
                return
            end

            self:Verify()
            self.fNextOccur = ( CurTime() + .2 )
        end
    end

    function dHack:Think()
        if not self.bStarted then
            return
        end

        if self.bRight then
            self.iCur = ( self.iCur + self.iSpeed )
            if ( self.iCur > 360 ) then
                self.iCur = 0
            end
        else
            self.iCur = ( self.iCur - self.iSpeed )
            if ( self.iCur < 0 ) then
                self.iCur = 360
            end
        end

        local iMin, iMax = math.min( self.iCur, self.iGoal ), math.max( self.iCur, self.iGoal )
        if ( ( iMax - iMin ) < ( 16 + OnePrint.Cfg.HackingErrorMargin ) ) then
            self.bValid = true
        else
            self.bValid = nil
        end
    end

    dHack.fLerpH = 0
    dHack.fLerpHTo = ( dHack:GetTall() * .75 )

    dHack.fLerpProgress = 0
    dHack.tColor = OnePrint:C( 2 )

    local iDelay = .16
    local iLastOccur = -iDelay
    local sPassword = randomString( 24 )

    function dHack:Paint( iW, iH )
        self.fLerpH = Lerp( RealFrameTime() * 6, self.fLerpH, self.fLerpHTo )

        local tColor = ( self.bValid and OnePrint:C( 6 ) or self.tColor )

        if self.iStep and self.iMaxSteps then
            self.fLerpProgress = Lerp( RealFrameTime() * 6, self.fLerpProgress, ( self.iStep * self.fLerpH ) / self.iMaxSteps )
        end

        if ( self.fLerpProgress > 0 ) then
            surface.SetDrawColor( OnePrint:C( 1 ) )
            surface.SetMaterial( matCircle2 )
            surface.DrawTexturedRectRotated( ( iW * .5 ), ( iH * .5 ), self.fLerpProgress, self.fLerpProgress, 0 )
        end

        surface.SetDrawColor( tColor )
        surface.SetMaterial( matCircle )
        surface.DrawTexturedRectRotated( ( iW * .5 ), ( iH * .5 ), self.fLerpH, self.fLerpH, ( CurTime() * 10 ) % 360 )

        if self.bStarted then
            surface.SetDrawColor( tColor )
            surface.SetMaterial( matTarget )
            surface.DrawTexturedRectRotated( ( iW * .5 ), ( iH * .5 ), self.fLerpH, self.fLerpH, self.iGoal )

            surface.SetDrawColor( tColor )
            surface.SetMaterial( matPoint )
            surface.DrawTexturedRectRotated( ( iW * .5 ), ( iH * .5 ), self.fLerpH, self.fLerpH, self.iCur )

            if self.Hovered then
            	if ( ( CurTime() - iLastOccur ) > iDelay ) then
                    sPassword = randomString( math.random( 32, 48 ) )
                    iLastOccur = CurTime()
                end

                draw.SimpleText( sPassword, "OnePrint.4", ( iW * .5 ), ( - 100 ), OnePrint:C( 2 ), 1, 1 )

                draw.SimpleText( string.upper( OnePrint:L( "Step" ) ) .. " " ..( self.iStep + 1 ) .. "/" .. self.iMaxSteps, "OnePrint.5", ( iW * .5 ), ( iH + 100 ), OnePrint:C( 2 ), 1, 1 )
            end
        end
    end

    function dHack:OnCursorEntered()
        if self:GetDisabled() then
            return
        end

        self.tColor = OnePrint:C( 5 )
        self:SetTextColor( self.tColor )
        self:SetFont( "OnePrint.1" )

        self.fLerpHTo = self:GetTall()
    end

    function dHack:OnCursorExited()
        if self:GetDisabled() then
            return
        end

        self.tColor = OnePrint:C( 2 )
        self:SetTextColor( self.tColor )
        self:SetFont( "OnePrint.5" )

        self.fLerpHTo = ( self:GetTall() * .75 )
    end
end

OnePrint:RegisterTab( Hack )