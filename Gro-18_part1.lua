--Stealed clientside server code by exechack.cc
--Hostname: Große Armee der Republik ★EGM★ [57 / 100] [v4.0.11] - Part 1/5 - 06/04/2025


--lua/autorun/023.lua:
player_manager.AddValidModel( "Novux_023", "models/Novux/023/Novux_SCP-023.mdl" );
player_manager.AddValidModel( "Novux_023_white", "models/novux/023/novux_scp-023_white.mdl" );

--addons/bkeypads/lua/bkeypads/sh_lang.lua:
if SERVER then
	for _, f in ipairs((file.Find("bkeypads/lang/*.lua", "LUA"))) do
		AddCSLuaFile("bkeypads/lang/" .. f)
	end
else
	local raw = CreateClientConVar("bkeypads_lang_raw", "0", false, false, "Disables language string translations, only showing raw phrases.", 0, 1):GetBool()
	local dump_strings = CreateClientConVar("bkeypads_lang_debug", "0", false, false, "Prints language strings to console as they are interpolated.", 0, 1):GetBool()
	local dump_traces = CreateClientConVar("bkeypads_lang_traces", "0", false, false, "Prints stack traces to console when language strings are interpolated.", 0, 1):GetBool()
	
	local function InjectGmodLangPhrases()
		for key, _val in pairs(bKeypads.LANG.English.Phrases) do
			local val = bKeypads.LANG.Phrases[key] or _val
			if key:StartWith("tool.") then
				language.Add(key, raw and key or val)
			elseif key:StartWith("Undo_") or key:StartWith("Undone_") then
				language.Add(key, raw and key or val)
			else
				language.Add("bKeypads_" .. key, raw and key or val)
			end
		end
	end
	
	cvars.AddChangeCallback("bkeypads_lang_raw", function(_, __, val)
		raw = tobool(val)
		InjectGmodLangPhrases()
	end)
	cvars.AddChangeCallback("bkeypads_lang_debug", function(_, __, val)
		dump_strings = tobool(val)
	end)
	cvars.AddChangeCallback("bkeypads_lang_traces", function(_, __, val)
		dump_traces = tobool(val)
	end)

	bKeypads.LANG = {}
	bKeypads.LANG.English = include("bkeypads/lang/english.lua")
	bKeypads.LANG.Metadata = bKeypads.LANG.English

	local warned_untranslated = {}
	local function warn_untranslated(phrase, return_val)
		if not warned_untranslated[phrase] then
			warned_untranslated[phrase] = true
			bKeypads:print("[" .. bKeypads.LANG.Metadata.Name .. "] WARNING: Untranslated string \"" .. phrase .. "\"!", bKeypads.PRINT_TYPE_BAD, "LANG")
			--debug.Trace()
		end
		return return_val
	end

	function bKeypads.L(phrase)
		if raw then
			return phrase
		else
			local interpolated = bKeypads.LANG.Phrases[phrase] or warn_untranslated(phrase, bKeypads.LANG.English.Phrases[phrase] or phrase)
			if dump_strings or dump_traces then
				bKeypads:print(phrase, bKeypads.PRINT_TYPE_NEUTRAL, "LANG")
				if dump_strings then
					bKeypads:print((interpolated:gsub("\n", "\\n")) .. (dump_traces and "" or "\n"), bKeypads.PRINT_TYPE_NEUTRAL, "LANG")
				end
				if dump_traces then
					debug.Trace()
				end
			end
			return interpolated
		end
	end

	function bKeypads._L(phrase)
		if raw then
			return phrase
		else
			if not bKeypads.LANG.Phrases[phrase] and not bKeypads.LANG.English.Phrases[phrase] and not warned_untranslated[phrase] then
				warned_untranslated[phrase] = true
				bKeypads:print("[" .. bKeypads.LANG.Metadata.Name .. "] WARNING: Untranslated string \"" .. phrase .. "\"!", bKeypads.PRINT_TYPE_BAD, "LANG")
				debug.Trace()
			elseif dump_strings or dump_traces then
				bKeypads.L(phrase)
			end
			return "#bKeypads_" .. phrase
		end
	end

	local gmod_lang_mapping = include("bkeypads/lang/_gmod_langs.lua")
	local function SelectLanguage(gmod_language)
		bKeypads.LANG.Metadata = nil
		bKeypads.LANG.Phrases = nil

		local active_language = gmod_lang_mapping[GetConVar("gmod_language"):GetString()] or gmod_lang_mapping["en"]
		if active_language ~= "english" and file.Exists("bkeypads/lang/" .. active_language .. ".lua", "LUA") then
			local success, metadata = pcall(include, "bkeypads/lang/" .. active_language .. ".lua")
			if success then
				bKeypads.LANG.Metadata = metadata or bKeypads.LANG.English
				bKeypads.LANG.Phrases = (metadata or {}).Phrases or bKeypads.LANG.English.Phrases
			else
				ErrorNoHalt("Error in Billy's Keypads language file: bkeypads/lang/" .. active_language .. ".lua\n")
				ErrorNoHalt(metadata .. "\n")
				debug.Trace()
			end
		end

		if not bKeypads.LANG.Metadata or not bKeypads.LANG.Phrases then
			bKeypads.LANG.Metadata = bKeypads.LANG.English
			bKeypads.LANG.Phrases = bKeypads.LANG.English.Phrases
		end

		InjectGmodLangPhrases()

		hook.Run("bKeypads.LanguageChanged")
	end

	cvars.AddChangeCallback("gmod_language", function(_,__,lang)
		SelectLanguage(lang)
	end, "bKeypads_gmod_language")

	SelectLanguage(GetConVar("gmod_language"):GetString() or "en")
	
	--## Language Functions ##--

	function bKeypads:FormatTimeDelta(time, unix)
		local delta = time - unix
		if delta < 60 then
			return bKeypads.L(delta == 1 and "s_second" or "s_seconds"):format(delta)
		elseif delta < 3600 then
			local min = math.Round(delta / 60)
			return bKeypads.L(min == 1 and "s_minute" or "s_minutes"):format(min)
		elseif delta < 86400 then
			local hour = math.Round(delta / 60 / 60)
			return bKeypads.L(hour == 1 and "s_hour" or "s_hours"):format(hour)
		else
			return os.date("%x %X", unix)
		end
	end
end
--addons/bkeypads/lua/bkeypads/lang/_gmod_langs.lua:
return {
	["en"] = "english",
	["en-PT"] = "english",
	["ru"] = "russian",
	["fr"] = "french",
	["de"] = "german",
}
--addons/bkeypads/lua/bkeypads/cl_performance.lua:
-- Track client FPS to dynamically add performance compensations when required

bKeypads.IsWindows = system.IsWindows()

bKeypads.Performance = {}
bKeypads.Performance.Optimize = false

function bKeypads.Performance:Optimizing()
	return
		bKeypads.Settings:Get("optimizations") ~= "none" and (
			bKeypads.Performance.Optimize or
			bKeypads.Settings:Get("optimizations") == "potato"
		)
end

function bKeypads.Performance:Alpha3D2D(dist)
	return 1 - math.Clamp((dist - 20000) / (bKeypads.Settings:Get("optimizations_3d2d_distance") ^ 2), 0, 1)
end

bKeypads.Performance.FPS = math.huge

bKeypads.Performance.FPSAverage = math.huge
bKeypads.Performance.FPSAverageClock = 0

bKeypads.Performance.FrameCount = 0
bKeypads.Performance.FrameNumber = FrameNumber()

timer.Create("bKeypads.Performance.FPS", 1, 0, function()
	bKeypads.Performance.FPS = FrameNumber() - bKeypads.Performance.FrameNumber
	bKeypads.Performance.FrameNumber = FrameNumber()
	bKeypads.Performance.FrameCount = bKeypads.Performance.FrameCount + bKeypads.Performance.FPS

	bKeypads.Performance.FPSAverageClock = bKeypads.Performance.FPSAverageClock + 1
	bKeypads.Performance.FPSAverage = bKeypads.Performance.FrameCount / bKeypads.Performance.FPSAverageClock

	if bKeypads.Performance.FPSAverageClock == 5 then
		bKeypads.Performance.FPSAverageClock = 1
		bKeypads.Performance.FrameCount = bKeypads.Performance.FPS
	end

	if bKeypads.IsWindows and not system.HasFocus() then
		bKeypads.Performance.Optimize = true
	else
		bKeypads.Performance.FPSThreshold = bKeypads.Performance.FPSThreshold or bKeypads.Settings:Get("optimizations_fps_threshold")
		if not bKeypads.Performance.Optimize and bKeypads.Performance.FPSAverage < bKeypads.Performance.FPSThreshold then
			bKeypads.Performance.FPSThreshold = bKeypads.Performance.FPSThreshold + 5
			bKeypads.Performance.Optimize = true
		elseif bKeypads.Performance.Optimize and bKeypads.Performance.FPSAverage > bKeypads.Performance.FPSThreshold then
			bKeypads.Performance.FPSThreshold = bKeypads.Performance.FPSThreshold - 5
			bKeypads.Performance.Optimize = false
		end
	end
end)
--addons/bkeypads/lua/bkeypads/sh_permissions.lua:
bKeypads.Permissions = {}

bKeypads.Permissions.Registry = {
	{
		Label = "Create Keypads",
		Value = "create_keypads",
		Icon = "icon16/wand.png",
		Default = true
	},

	{
		Label = "Create Mirrored Keypads",
		Value = "mirror_keypads",
		Icon = "icon16/page_white_copy.png",
		Default = true
	},

	{
		Label = "Administration",
		Value = "administration",
		Icon = "icon16/shield.png",

		{
			{
				Label = "Keypad Logos/Images",
				Value = "custom_img",
				Icon = "icon16/picture.png",

				{
					{
						Label = "Ban/Unban Players from Feature",
						Value = "ban",
						Icon = "icon16/group_key.png",
						Tip = "Allow this group to ban/unban players from uploading custom keypad images to their keypads?"
					},

					{
						Label = "Remove Keypad Images",
						Value = "remove",
						Icon = "icon16/delete.png",
						Tip = "Allow this group to remove keypad images from keypads?"
					},
				}
			}
		}
	},

	{
		Label = "Notifications",
		Value = "notifications",
		Icon = "icon16/error.png",

		{
			{
				Label   = "Access Granted",
				Value   = "access_granted",
				Icon    = "icon16/flag_green.png",
				Tip     = "Allow this group to receive \"Access Granted\" notifications?",
				Default = true
			},

			{
				Label   = "Access Denied",
				Value   = "access_denied",
				Icon    = "icon16/flag_red.png",
				Tip     = "Allow this group to receive \"Access Denied\" notifications?",
				Default = true
			},
		}
	},

	{
		Label = "Tools",
		Value = "tools",
		Icon = "icon16/wrench.png",
		
		{
			{
				Label = "Use Admin Tool",
				Value = "admin_tool",
				Icon = "icon16/wand.png",
				Tip = "Allow the use of the admin tool (access logs, door link checker, fading door link checker, keypad link checker, etc.)?"
			},

			{
				Label = "Use Keypad Breaker Tool",
				Value = "keypad_breaker",
				Icon = "icon16/bomb.png",
				Tip = "Allow the use of the keypad breaker tool?"
			},
		}
	},

	{
		Label = "Keypad Settings",
		Value = "keypads",
		Icon = "icon16/calculator.png",
		
		{
			{
				Label = "Bypass \"Keypads Only On Fading Doors\"",
				Value = "bypass_keypad_only_fading_doors",
				Icon = "icon16/map.png",
				Tip = "Allow this group to bypass the \"Keypads Only On Fading Doors\" setting?",
			},

			{
				Label = "Use Custom Lua Functions",
				Value = "custom_lua_functions",
				Icon = "icon16/script_code.png",
				Tip = "Allow this group to whitelist/blacklist access via custom Lua functions (that you defined in bkeypads_custom_access.lua) on their keypads?",
				Default = true
			},

			{
				Label = "Create Uncrackable Keypads",
				Value = "uncrackable_keypads",
				Icon = "icon16/shield.png",
				Tip = "Allow this group to create keypads that can't be cracked by a keypad cracker?"
			},

			{
				Label = "Keypad Payments",
				Value = "payments",
				Icon = "icon16/money.png",
				Tip = "Allow this group to create keypads which charge money for use?",
				Default = true
			},

			{
				Label = "Wiremod",
				Value = "wiremod",
				Icon = "icon16/wrench_orange.png",
				Tip = "Allow this group to create keypads which have Wiremod outputs?",
				Default = true
			},

			{
				Label = "Keyboard Button Simulation",
				Value = "keyboard_button_simulation",
				Icon = "icon16/keyboard.png",
				Tip = "Allow this group to create keypads which simulate pressing keys on their keyboard?"
			},

			{
				Label = "Create Unfrozen Keypads",
				Value = "unfrozen_keypads",
				Icon = "icon16/weather_snow.png",
				Tip = "Allow this group to unfreeze their keypads?",
				Default = true
			},

			{
				Label = "Create Unwelded Keypads",
				Value = "unwelded_keypads",
				Icon = "icon16/link_break.png",
				Tip = "Allow this group to unweld their keypads? If not, any keypads they create will be welded.",
				Default = true,
			},

			{
				Label = "Create Collidable Keypads",
				Value = "collidable_keypads",
				Icon = "icon16/collision_on.png",
				Tip = "Allow this group to create collidable keypads? If not, any keypads they create will be no-collided.",
				Default = true,
			},

			{
				Label = "Keypad Appearance",
				Value = "appearance",
				Icon = "icon16/palette.png",

				{
					{
						Label = "Use custom image/logo",
						Value = "custom_img",
						Icon = "icon16/picture.png",
						Tip = "Allow this group to use a custom image on their keypads?",
						Default = true
					},
					
					{
						Label = "Change background color",
						Value = "bg_color",
						Icon = "icon16/color_wheel.png",
						Tip = "Allow this group to change the background color of their keypads?",
						Default = true
					},

					{
						Label = "RAINBOW BACKGROUND COLOR",
						Value = "rainbows",
						Icon = "icon16/rainbow.png",
						Tip = "RAINBOWS HELL YEAH"
					},
				}
			},
		}
	},

	{
		Label = "Persistence",
		Value = "persistence", 
		Icon = "icon16/world.png",

		{
			{
				Label = "Manage persistent keycards",
				Value = "manage_persistent_keycards",
				Tip = "Create, modify and destroy persistent keycards",
				Icon = "icon16/vcard.png",
			},

			{
				Label = "Manage persistent keypads",
				Value = "manage_persistent_keypads",
				Tip = "Create, modify and destroy persistent keypads",
				Icon = "icon16/star.png",
			},

			{
				Label = "Switch keypad persistence profile",
				Value = "switch_profile",
				Tip = "Switch between other keypad layouts & configurations (profiles) for the map on the fly",
				Icon = "icon16/disk.png",
			},

			{
				Label = "Manage persistent keypad profiles",
				Value = "manage_profiles",
				Tip = "Create or delete keypad persistence profiles",
				Icon = "icon16/wand.png",
			},
		}
	},

	{
		Label = "Linking",
		Value = "linking",
		Icon = "icon16/link.png",

		{
			{
				Label = "Link keypads",
				Value = "link_keypads",
				Icon = "icon16/calculator.png",
				Tip = "Allow this group to link their keypads together?",
				Default = true
			},

			{
				Label = "Link to doors",
				Value = "doors",
				Icon = "icon16/door_in.png",
				Tip = "Allow this group to link their keypads to map doors?"
			},

			{
				Label = "[DarkRP] Link to owned doors",
				Value = "darkrp_doors",
				Icon = "icon16/door_in.png",
				Tip = "Allow this group to link their keypads to OWNED map doors?",
				Default = true
			},

			{
				Label = "[DarkRP] Prevent Lockpick links",
				Value = "darkrp_prevent_lockpick",
				Icon = "icon16/lock_break.png",
				Tip = "Allow this group to prevent lockpicking on linked map doors?",
			},

			{
				Label = "Link to buttons",
				Value = "buttons",
				Icon = "icon16/control_eject.png",
				Tip = "Allow this group to link their keypads to map buttons?",
			},

			{
				Label = "Link to Gmod Sandbox buttons",
				Value = "gmod_button",
				Icon = "icon16/control_eject_blue.png",
				Tip = "Allow this group to link their keypads to Sandbox's buttons (spawned with the Button tool)?",
				Default = true
			},

			{
				Label = "Pseudolinking",
				Value = "pseudolink",
				Icon = "icon16/script_code.png",
				Tip = "Allow this group to create pseudolinks?"
			},

			{
				Label = "Disable Map Objects",
				Value = "disable_map_objects",
				Icon = "icon16/cross.png",
				Tip = "Allow this group to disable map objects? (Disabling buttons, keeping doors locked, etc.)"
			},

			{
				Label = "Redirect +use",
				Value = "redirect_use",
				Icon = "icon16/arrow_undo.png",
				Tip = "Allow this group to redirect +use on map links?"
			},

			{
				Label = "Hide Map Object",
				Value = "hide_map_object",
				Icon = "icon16/lightbulb_off.png",
				Tip = "Allow this group to hide map objects to prevent them from rendering?",
			},

			{
				Label = "Bypass Maximum Linking Distance",
				Value = "max_distance",
				Icon = "icon16/chart_curve.png",
				Tip = "Allow this group to bypass the maximum linking distance set in the config?",
			},
		}
	},

	{
		Label = "Access Methods",
		Icon = "icon16/shield_go.png",
		Value = "access_methods",

		{
			{
				Label = "PIN",
				Value = "pin",
				Icon = "icon16/calculator.png",
				Tip = "Allow this group to create keypads which require a PIN code for access?",
				Default = true
			},

			{
				Label = "Face Scanning (FaceID)",
				Value = "faceid",
				Icon = "icon16/camera.png",
				Tip = "Allow this group to create keypads which require a facial scan for access?",
				Default = true
			},

			{
				Label = "Keycard",
				Value = "keycard",
				Icon = "icon16/vcard.png",
				Tip = "Allow this group to create keypads which require a keycard for access?",
				Default = true
			},
		}
	},

	{
		Label = "Fading Doors",
		Value = "fading_doors",
		Icon = "icon16/door_open.png",

		{
			{
				Label = "Create Fading Doors",
				Value = "create",
				Icon = "icon16/door.png",
				Tip = "Allow this group to create fading doors?",
				Default = true
			},

			{
				Label = "Fading Door Sounds",
				Value = "sounds",
				Icon = "icon16/sound.png",
				Tip = "Allow this group to create fading doors which emit sounds?",
				Default = true
			},

			{
				Label = "Freeze to Cancel Fade",
				Value = "freeze_cancel",
				Icon = "icon16/door_out.png",
				Tip = "Allow this group to cancel a fading door's fade when picked up & frozen using their physgun?",
				Default = true
			},

			{
				Label = "Open with Keyboard",
				Value = "keyboard",
				Icon = "icon16/keyboard.png",
				Tip = "Allow this group to open their fading doors via keyboard buttons? (This can be disabled completely in the config)",
				Default = true
			},
		}
	},

	{
		Label = "Keycards",
		Value = "keycards",
		Icon = "icon16/vcard.png",

		{
			{
				Label = "Drop Keycards",
				Value = "drop",
				Icon = "icon16/arrow_down.png",
				Tip = "Allow this group to drop keycards they've picked up?",
				Default = true
			},

			{
				Label = "Drop Loadout Keycard",
				Value = "drop_spawned",
				Icon = "icon16/box.png",
				Tip = "Allow this group to drop the keycard their team/job spawns with?",
				Default = true
			},
		}
	},

	{
		Label = "Destruction",
		Value = "destruction",
		Icon = "icon16/bomb.png",

		{
			{
				Label = "Create Indestructible Keypads",
				Value = "indestructible",
				Icon = "icon16/shield.png",
				Tip = "When keypad destruction is ENABLED, can this group create indestructible keypads?"
			},

			{
				Label = "Create Destructible Keypads",
				Value = "destructible",
				Icon = "icon16/bomb.png",
				Tip = "When keypad destruction is DISABLED, can this group create destructible keypads?"
			},

			{
				Label = "Override Destruction Config",
				Value = "override_config",
				Icon = "icon16/cog_edit.png",
				Tip = "Can this group override the health and shield of keypads they spawn?"
			},
		}
	}
}

--## Build Tree ##--

bKeypads.Permissions.Tree = {}
do
	local function step(id, registry)
		for _, permission in ipairs(registry) do
			local id = (id and (id .. "/") or "") .. permission.Value
			bKeypads.Permissions.Tree[id] = permission
			if permission[1] then
				step(id, permission[1])
			end
		end
	end
	step(nil, bKeypads.Permissions.Registry, bKeypads.Permissions.Tree)
end

--## Interface ##--

do
	local permissionsCache = {}

	function bKeypads.Permissions:Cached(ply, permission_id)
		assert(bKeypads.Permissions.Tree[permission_id] ~= nil, "Permission \"" .. permission_id .. "\" does not exist!")
		if OpenPermissions and OpenPermissions.HasPermission then
			if not permissionsCache[ply] or not permissionsCache[ply][permission_id] or SysTime() >= permissionsCache[ply][permission_id].Expires then
				return bKeypads.Permissions:Check(ply, permission_id)
			end
			return permissionsCache[ply][permission_id].Result
		else
			return bKeypads.Permissions:Check(ply, permission_id)
		end
	end

	function bKeypads.Permissions:Check(ply, permission_id)
		assert(bKeypads.Permissions.Tree[permission_id] ~= nil, "Permission \"" .. permission_id .. "\" does not exist!")
		if OpenPermissions and OpenPermissions.HasPermission then
			if not permissionsCache[ply] then permissionsCache[ply] = {} end
			
			local cache = {
				Expires = SysTime() + 1,
				Result  = OpenPermissions:HasPermission(ply, "bkeypads/" .. permission_id)
			}
			permissionsCache[ply][permission_id] = cache

			return cache.Result
		else
			return ply:IsSuperAdmin() or bKeypads.Permissions.Tree[permission_id].Default == true
		end
	end
end

--## OpenPermissions Support ##--

if SERVER then
	local function bKeypads_Init()
		bKeypads.OpenPermissions = OpenPermissions:RegisterAddon("bkeypads", {
			Name  = "Billy's Keypads",
			Color = Color(0,150,255),
			Icon  = "icon16/calculator.png",
			Logo = {
				Path = "bkeypads/logo_wide_white.png",
				Width = 335,
				Height = 128
			}
		})

		local function step(tree, registry)
			for _, permission in ipairs(registry) do
				local branch = tree:AddToTree({
					Value = permission.Value,
					Label = permission.Label,
					Icon = permission.Icon,
					Tip = permission.Tip,
					Default = (permission.Default == true and OpenPermissions.CHECKBOX.TICKED) or (permission.Default == false and OpenPermissions.CHECKBOX.CROSSED) or nil,
				})
				if permission[1] then
					step(branch, permission[1])
				end
			end
		end
		step(bKeypads.OpenPermissions, bKeypads.Permissions.Registry)
	end

	local function OpenPermissions_Init()
		hook.Remove("OpenPermissions:Ready", "bKeypads.OpenPermissions")
		if bKeypads_Ready == true then
			bKeypads_Init()
		else
			hook.Add("bKeypads.Ready", "bKeypads.OpenPermissions", bKeypads_Init)
		end
	end
	if OpenPermissions_Ready == true then
		OpenPermissions_Init()
	else
		hook.Add("OpenPermissions:Ready", "bKeypads.OpenPermissions", OpenPermissions_Init)
	end
end

--## CanTool ##--

local checkFunc = SERVER and bKeypads.Permissions.Check or bKeypads.Permissions.Cached

function bKeypads.CanTool(ply, tr, tool)
	if IsValid(tr.Entity) and tr.Entity.bKeypad then
		if tool == "bkeypads_breaker" then
			return checkFunc(bKeypads.Permissions, ply, "tools/keypad_breaker")
		elseif tool == "bkeypads_admin_tool" then
			return checkFunc(bKeypads.Permissions, ply, "tools/admin_tool")
		elseif tool == "bkeypads_persistence" then
			return checkFunc(bKeypads.Permissions, ply, "persistence/manage_persistent_keypads") or checkFunc(bKeypads.Permissions, ply, "persistence/manage_persistent_keycards")
		end
	elseif tool == "bkeypads_linker" then
		local toolObj = ply:GetTool(tool)
		if not toolObj then return end
		if toolObj.MapLinking and IsValid(toolObj.TargetEnt) then
			if bKeypads.MapLinking:IsDoor(toolObj.TargetEnt) then
				if checkFunc(bKeypads.Permissions, ply, "linking/doors") or (DarkRP and toolObj.TargetEnt.isKeysOwnedBy and checkFunc(bKeypads.Permissions, ply, "linking/darkrp_doors") and toolObj.TargetEnt:isKeysOwnedBy(ply)) then
					return true
				end
			elseif bKeypads.MapLinking:IsMapButton(toolObj.TargetEnt) then
				return checkFunc(bKeypads.Permissions, ply, "linking/buttons")
			end
		end
	end
end

bKeypads_gamemode_Call = bKeypads_gamemode_Call or gamemode.Call
gamemode.Call = function(event, ...)
	if event == "CanTool" then
		local r = bKeypads.CanTool(...)
		if r ~= nil then return r end
	end
	return bKeypads_gamemode_Call(event, ...)
end
--addons/bkeypads/lua/bkeypads/sh_keycard_inventory.lua:
bKeypads.Keycards = bKeypads.Keycards or {}
bKeypads.Keycards.Inventory = {}
bKeypads_Keycards_Inventory_Cards = bKeypads_Keycards_Inventory_Cards or {}
bKeypads.Keycards.Inventory.Cards = bKeypads_Keycards_Inventory_Cards

function bKeypads.Keycards.Inventory:Clear(ply)
	bKeypads.Keycards.Inventory.Cards[ply] = nil
end
hook.Add("player_spawn", "bKeypads.Keycards.Inventory.Spawn", function(data)
	if not data or not data.userid then return end
	local ply = Player(data.userid)
	if not IsValid(ply) then return end
	bKeypads.Keycards.Inventory:Clear(ply)
end)
gameevent.Listen("player_spawn")

function bKeypads.Keycards.Inventory:IsHoldingKeycard(ply, keycardID)
	return bKeypads.Keycards.Inventory.Cards[ply] ~= nil and bKeypads.Keycards.Inventory.Cards[ply][keycardID] ~= nil
end

function bKeypads.Keycards.Inventory:PickupKeycard(ply, keycard, keycardIDFallback)
	assert(IsValid(ply), "NULL player tried to pickup a keycard!")

	local keycardID = isnumber(keycard) or (IsValid(keycard) and keycard:GetID() or keycardIDFallback)
	assert(keycardID ~= 0, "Tried to pick up keycard with no ID!")

	if bKeypads.Keycards.Inventory.Cards[ply] and bKeypads.Keycards.Inventory.Cards[ply][keycardID] then return end
	bKeypads.Keycards.Inventory.Cards[ply] = bKeypads.Keycards.Inventory.Cards[ply] or {}
	bKeypads.Keycards.Inventory.Cards[ply][keycardID] = true

	--print("PICKED UP", ply, keycard, keycardIDFallback)

	if IsValid(keycard) then
		if not keycard:GetInfinite() then
			if keycard:GetQuantity() <= 0 then
				return
			elseif SERVER then
				keycard:SetQuantity(keycard:GetQuantity() - 1)

				hook.Run("bKeypads.Keycard.PickedUp", ply, keycard, keycard:GetQuantity())

				if keycard:GetQuantity() == 0 and not keycard:GetPersist() then
					keycard:Remove()
				end
			end
		elseif SERVER then
			hook.Run("bKeypads.Keycard.PickedUp", ply, keycard)
		end
	end

	local keycardData = bKeypads.Keycards:GetByID(keycardID)
	if SERVER and keycardData and IsValid(keycardData.Keycard) and keycardData.Keycard:GetHideToHolders() then
		--keycardData.Keycard:SetCollisionRule(ply, false)
		keycardData.Keycard:SetPreventTransmit(ply, true)
	end

	if (IsValid(keycard) and keycard:GetPlayerKeycardDataBind() == ply:SteamID()) or (keycardData and keycardData.PlayerBind and keycardData.PlayerBind and #keycardData.PlayerBind > 0 and keycardData.PlayerBind == ply:SteamID()) then
		bKeypads_Keycards_Registry[keycardID] = bKeypads.Keycards:GetKeycardData(ply)

		local bkeycard = ply:GetWeapon("bkeycard")
		if IsValid(bkeycard) and not bkeycard:GetWasPickedUp() then
			bKeypads.Keycards.Inventory.Cards[ply][keycardID] = nil
			if table.IsEmpty(bKeypads.Keycards.Inventory.Cards[ply]) then
				bKeypads.Keycards.Inventory.Cards[ply] = nil
			end
		end
	end

	if SERVER then

		net.Start("bKeypads.Keycards.Inventory.Pickup")
			net.WriteEntity(ply)
			net.WriteEntity(keycard or NULL)
			net.WriteUInt(keycardID, 32)
		net.Broadcast()

		if bKeypads.Keycards.Inventory.Cards[ply] and bKeypads.Keycards.Inventory.Cards[ply][keycardID] then
			local bkeycard = ply:GetWeapon("bkeycard")
			if not IsValid(bkeycard) then
				bkeycard = ply:Give("bkeycard")
				bkeycard:EmitSound("weapons/smg1/switch_burst.wav", 55, 100, 1, CHAN_WEAPON)
				if IsValid(bkeycard) then
					bkeycard:SetWasPickedUp(true)
				end
			end

			if IsValid(bkeycard) then
				bkeycard:SetSelectedKeycard(keycardID)
			end
		end

	elseif IsValid(bKeypads_Keycard_Inventory) then

		bKeypads_Keycard_Inventory.keycardsContainer:Populate()

	end
end

function bKeypads.Keycards.Inventory:RemoveKeycard(ply, keycardID)
	--print("REMOVED KEYCARD", ply, keycardID)

	if keycardID ~= 0 then
		if not bKeypads.Keycards.Inventory.Cards[ply] or not bKeypads.Keycards.Inventory.Cards[ply][keycardID] then return false end

		bKeypads.Keycards.Inventory.Cards[ply][keycardID] = nil
		if table.IsEmpty(bKeypads.Keycards.Inventory.Cards[ply]) then
			bKeypads.Keycards.Inventory.Cards[ply] = nil
		end
	end

	if SERVER then
		
		local rootKeycard = bKeypads.Keycards:GetByID(keycardID)
		if rootKeycard and IsValid(rootKeycard.Keycard) and rootKeycard.Keycard:GetHideToHolders() then
			--rootKeycard.Keycard:SetCollisionRule(ply, true)
			rootKeycard.Keycard:SetPreventTransmit(ply, false)
		end

		if keycardID ~= 0 then
			net.Start("bKeypads.Keycards.Inventory.Remove")
				net.WriteEntity(ply)
				net.WriteUInt(keycardID, 32)
			net.Broadcast()
		end

		local bkeycard = ply:GetWeapon("bkeycard")
		if IsValid(bkeycard) and bkeycard:GetSelectedKeycard() == keycardID then
			if bkeycard:GetWasPickedUp() then
				local heldKeycards = bKeypads.Keycards.Inventory:GetHeldKeycards(ply)
				local switchTo = heldKeycards ~= nil and next(heldKeycards) or nil
				if switchTo then
					bkeycard:SetSelectedKeycard(switchTo)
				else
					ply:StripWeapon("bkeycard")
					ply:SwitchToDefaultWeapon()
				end
			elseif keycardID ~= 0 then
				bkeycard:SetSelectedKeycard(0)
			else
				ply:StripWeapon("bkeycard")
				ply:SwitchToDefaultWeapon()
			end
		end

	elseif ply == LocalPlayer() and IsValid(bKeypads_Keycard_Inventory) then

		bKeypads_Keycard_Inventory.keycardsContainer:Populate()

	end

	return true
end

function bKeypads.Keycards.Inventory:DropKeycard(ply, keycardID)
	local canDrop
	if keycardID == 0 then
		canDrop = bKeypads.Config.Keycards.CanDropSpawnedWithKeycard and bKeypads.Permissions:Check(ply, "keycards/drop_spawned")
	else
		canDrop = bKeypads.Config.Keycards.CanDropKeycard and bKeypads.Permissions:Check(ply, "keycards/drop")
	end
	if not canDrop then return end
	if not IsValid(ply:GetWeapon("bkeycard")) or ply:GetWeapon("bkeycard"):GetBeingScanned() then return end
	if not bKeypads.Keycards.Inventory:RemoveKeycard(ply, keycardID) then return end

	if SERVER then

		local _, keycard = bKeypads.Keycards:SpawnKeycard(keycardID, ply)
		hook.Run("bKeypads.Keycard.Dropped", ply, keycard)

	elseif ply == LocalPlayer() then

		net.Start("bKeypads.Keycards.Inventory.Drop")
			net.WriteUInt(keycardID, 32)
		net.SendToServer()

	end
end

function bKeypads.Keycards.Inventory:GetHeldKeycards(ply)
	return bKeypads.Keycards.Inventory.Cards[ply]
end

function bKeypads.Keycards.Inventory:SwitchKeycard(ply, keycardID)
	local bkeycard = ply:GetWeapon("bkeycard")
	if not IsValid(bkeycard) or bkeycard:GetBeingScanned() then return end

	if keycardID == 0 then
		if bkeycard:GetWasPickedUp() then return end
	else
		if not bKeypads.Keycards.Inventory:IsHoldingKeycard(ply, keycardID) then return end
	end

	if SERVER then
		bkeycard:SetSelectedKeycard(keycardID)
		hook.Run("bKeypads.Keycard.Selected", ply, keycardID, bkeycard)
	elseif ply == LocalPlayer() then
		net.Start("bKeypads.Keycards.Inventory.Switch")
			net.WriteUInt(keycardID, 32)
		net.SendToServer()
	end
end

if SERVER then
	hook.Add("canDropWeapon", "bKeypads.DarkRP.canDropWeapon", function(ply, wep)
		if wep:GetClass() == "bkeycard" then
			return false
		end
	end)
end

if SERVER then
	util.AddNetworkString("bKeypads.Keycards.Inventory.Pickup")
	util.AddNetworkString("bKeypads.Keycards.Inventory.Drop")
	util.AddNetworkString("bKeypads.Keycards.Inventory.Remove")
	util.AddNetworkString("bKeypads.Keycards.Inventory.Switch")

	net.Receive("bKeypads.Keycards.Inventory.Drop", function(_, ply)
		bKeypads.Keycards.Inventory:DropKeycard(ply, net.ReadUInt(32))
	end)

	net.Receive("bKeypads.Keycards.Inventory.Switch", function(_, ply)
		bKeypads.Keycards.Inventory:SwitchKeycard(ply, net.ReadUInt(32))
	end)
else
	net.Receive("bKeypads.Keycards.Inventory.Pickup", function()
		bKeypads.Keycards.Inventory:PickupKeycard(net.ReadEntity(), net.ReadEntity(), net.ReadUInt(32))
	end)

	net.Receive("bKeypads.Keycards.Inventory.Remove", function()
		bKeypads.Keycards.Inventory:RemoveKeycard(net.ReadEntity(), net.ReadUInt(32))
	end)
end

if CLIENT then
	if IsValid(bKeypads_Keycard_Inventory) then
		bKeypads_Keycard_Inventory:Remove()
	end

	local KeycardModelPanels

	local KEYCARD_ACTIVE = -1
	local KEYCARD_PLAYER = 0

	local width
	local marginBottom

	local tileSpacing
	local tileRowCount
	local tileSize

	local activeTileWidth
	local activeTileHeight
	local activeTileSpacing

	local function InventoryScreenScale()
		width = (800 / 1920) * ScrW()
		marginBottom = (50 / 1920) * ScrW()

		tileSpacing = (10 / 1920) * ScrW()
		tileRowCount = math.ceil((7 / 1920) * ScrW())
		tileSize = (width - ((tileRowCount - 1) * tileSpacing)) / tileRowCount

		activeTileWidth = (300 / 1920) * ScrW()
		activeTileHeight = (200 / 1920) * ScrW()
		activeTileSpacing = marginBottom / 2
	end
	InventoryScreenScale()
	hook.Add("OnScreenSizeChanged", "bKeypads.Keycard.Inventory.ScreenScale", InventoryScreenScale)

	local InventoryThinkCache, InventoryThinkCacheFrame
	local function InventoryThink()
		if not InventoryThinkCache or InventoryThinkCacheFrame ~= FrameNumber() then
			local keycardWeapon = LocalPlayer():GetActiveWeapon()
			InventoryThinkCache = LocalPlayer():Alive() and IsValid(keycardWeapon) and keycardWeapon:GetClass() == "bkeycard"
		end
		return InventoryThinkCache
	end

	local examineKeycardDMenu
	local function GetExaminationKeycard()
		if not InventoryThink() then return end
		if IsValid(examineKeycardDMenu) then
			return examineKeycardDMenu.m_examineKeycard, examineKeycardDMenu.m_examineKeycardID
		else
			local hovered = vgui.GetHoveredPanel()
			if IsValid(hovered) and hovered.m_bIsbKeycardPanel and hovered.m_iKeycardID and hovered.m_iKeycardID ~= KEYCARD_ACTIVE then
				return hovered.Entity, hovered.m_iKeycardID
			end
		end
		return LocalPlayer():GetActiveWeapon(), LocalPlayer():GetActiveWeapon():GetSelectedKeycard()
	end

	local function keycardPanel_Paint(self, w, h)
		if not InventoryThink() then return end

		surface.SetDrawColor(0, 0, 0, 200)
		surface.DrawRect(0, 0, w, h)
		
		if LocalPlayer():GetActiveWeapon():GetSelectedKeycard() == self.m_iKeycardID then
			surface.SetDrawColor(bKeypads.COLOR.GMODBLUE)
			surface.DrawOutlinedRect(0, 0, w, h, 3)
		elseif select(2, GetExaminationKeycard()) == self.m_iKeycardID then
			surface.SetDrawColor(bKeypads.COLOR.GMODBLUE)
			surface.DrawOutlinedRect(0, 0, w, h, 3)
		else
			surface.SetDrawColor(150, 150, 150, 255)
			surface.DrawOutlinedRect(0, 0, w, h)
		end

		DModelPanel.Paint(self, w, h)
	end

	local function keycardPanel_OnMousePressed(self, m)
		if (m == MOUSE_LEFT or m == MOUSE_RIGHT) then self._m = m end
	end
	local function keycardPanel_OnMouseReleased(self, m)
		if self._m == m and InventoryThink() then
			local bkeycard = LocalPlayer():GetActiveWeapon()

			surface.PlaySound("weapons/ar2/ar2_empty.wav")

			local DMenu = DermaMenu(nil, self)

			examineKeycardDMenu = DMenu
			DMenu.m_examineKeycard = self.Entity
			DMenu.m_examineKeycardID = self.m_iKeycardID

			DMenu:AddOption(self.Entity:GetKeycardName()):SetIcon("icon16/tag_blue.png")
			DMenu:AddSpacer()

			local KeycardLevels, SubMenu = DMenu:AddSubMenu(bKeypads.L"KeycardLevels")
			SubMenu:SetIcon("icon16/vcard.png")
			
			for _, level in ipairs(self.Entity:GetLevels()) do
				bKeypads.DermaMenuOption_Color(KeycardLevels:AddOption("[" .. level .. "] " .. bKeypads.Keycards.Levels[level].Name), bKeypads.Keycards.Levels[level].Color)
			end

			if bkeycard:GetSelectedKeycard() ~= self.m_iKeycardID then
				DMenu:AddOption(bKeypads.L"KeycardSwitch", function()

					bKeypads.Keycards.Inventory:SwitchKeycard(LocalPlayer(), self.m_iKeycardID)

				end):SetIcon("icon16/arrow_switch.png")
			end

			local canDrop
			if self.m_iKeycardID == 0 then
				canDrop = bKeypads.Config.Keycards.CanDropSpawnedWithKeycard and bKeypads.Permissions:Check(LocalPlayer(), "keycards/drop_spawned")
			else
				canDrop = bKeypads.Config.Keycards.CanDropKeycard and bKeypads.Permissions:Check(LocalPlayer(), "keycards/drop")
			end
			if canDrop then
				DMenu:AddOption(bKeypads.L"KeycardDrop", function()
				
					surface.PlaySound("weapons/iceaxe/iceaxe_swing1.wav")

					bKeypads.Keycards.Inventory:DropKeycard(LocalPlayer(), self.m_iKeycardID)

				end):SetIcon("icon16/delete.png")
			end

			DMenu:Open()
		end
		self._m = nil
	end

	local function keycardPanel_GetKeycardColor(self)
		return (self.m_KeycardMetadata or {}).Color or bKeypads.COLOR.RED
	end
	local function keycardPanel_GetKeycardName(self)
		return self.m_KeycardMetadata.Name or bKeypads.L("KeycardLevel"):format(self.m_iPrimaryLevel)
	end
	local function keycardPanel_GetLevels(self)
		return self.m_KeycardData.Levels
	end
	local function keycardPanel_GetPlayerModel(self)
		return self.m_KeycardData.PlayerModel
	end
	local function keycardPanel_GetSteamID(self)
		return self.m_KeycardData.SteamID
	end
	local function keycardPanel_GetTeam(self)
		return self.m_KeycardData.Team
	end
	local function keycardPanel_GetHash(self)
		return self.m_Hash
	end

	local function activeTile_OnMouseReleased(self, m)
		if self._m == m then
			local KeycardModelPanel = KeycardModelPanels[LocalPlayer():GetActiveWeapon():GetSelectedKeycard()]
			if IsValid(KeycardModelPanel) then
				KeycardModelPanel:OnMousePressed(m)
				KeycardModelPanel:OnMouseReleased(m)
			end
		end
		self._m = nil
	end

	local function KeycardModelPanel_PreDrawModel(self)
		if not InventoryThink() then return end

		if self.m_iKeycardID == KEYCARD_ACTIVE then
			local examineKeycard, examineKeycardID = GetExaminationKeycard()

			if self.m_iTextureKeycardID ~= examineKeycardID then
				self.m_iTextureKeycardID = examineKeycardID
				self.Entity.KeycardColor = examineKeycard:GetKeycardColor()
			end
			
			bKeypads.Keycards.Textures:Draw(bKeypads.Keycards.Textures.TOP, self.Entity, examineKeycard)
		else
			bKeypads.Keycards.Textures:Draw(bKeypads.Keycards.Textures.TOP, self.Entity)
		end
	end
	local function KeycardModelPanel_SetKeycardID(self, keycardID)
		self.m_iKeycardID = keycardID

		if keycardID ~= KEYCARD_ACTIVE then
			local keycard = keycardID == KEYCARD_PLAYER and bKeypads.Keycards:GetKeycardData(LocalPlayer()) or bKeypads.Keycards:GetByID(keycardID)

			self.Entity.m_iPrimaryLevel   = keycard.PrimaryLevel
			self.Entity.m_KeycardMetadata = bKeypads.Keycards.Levels[keycard.PrimaryLevel]
			self.Entity.m_KeycardData     = keycard
			self.Entity.m_Hash            = util.CRC((keycard.SteamID or "") .. (keycard.PlayerModel or "") .. table.concat(keycard.Levels, ",") .. (keycard.Team or ""))

			self.Entity.GetKeycardColor   = keycardPanel_GetKeycardColor
			self.Entity.GetKeycardName    = keycardPanel_GetKeycardName
			self.Entity.GetLevels         = keycardPanel_GetLevels
			self.Entity.GetPlayerModel    = keycardPanel_GetPlayerModel
			self.Entity.GetSteamID        = keycardPanel_GetSteamID
			self.Entity.GetTeam           = keycardPanel_GetTeam
			self.Entity.GetHash           = keycardPanel_GetHash
		end
	end
	local function KeycardModelPanel_LayoutSpin(self)
		local mn, mx = self.Entity:GetRenderBounds()
		local size = 0
		size = math.max(size, math.abs(mn.x) + math.abs(mx.x))
		size = math.max(size, math.abs(mn.y) + math.abs(mx.y))
		size = math.max(size, math.abs(mn.z) + math.abs(mx.z))
		
		local CamPos = Vector(size, size, size)
		local LookAt = (mn + mx) * 0.5

		self:SetFOV(45)
		self:SetCamPos(CamPos)
		self:SetLookAt(LookAt)
	end
	local function KeycardModelPanel_LayoutExamine(self)
		self.LayoutEntity = bKeypads.noop
		self:SetFOV(30)
		self:SetCamPos(Vector(0,0,10))
		self:SetLookAng(Angle(90, 270, 0))
	end
	local function KeycardModelPanel(parent, keycardID)
		local keycardPanel = vgui.Create("DModelPanel", parent)

		keycardPanel.m_bIsbKeycardPanel = true

		keycardPanel.SetKeycardID = KeycardModelPanel_SetKeycardID
		keycardPanel.LayoutSpin = KeycardModelPanel_LayoutSpin
		keycardPanel.LayoutExamine = KeycardModelPanel_LayoutExamine

		keycardPanel.PreDrawModel = KeycardModelPanel_PreDrawModel
		keycardPanel.OnMousePressed = keycardPanel_OnMousePressed
		keycardPanel.OnMouseReleased = keycardPanel_OnMouseReleased

		keycardPanel:SetMouseInputEnabled(true)
		keycardPanel:SetCursor("hand")

		keycardPanel:SetModel(bKeypads.MODEL.KEYCARD)
		keycardPanel.Entity.bKeycard = true

		if keycardID then
			keycardPanel:SetKeycardID(keycardID)
		end

		return keycardPanel
	end

	local function bKeypads_Keycard_Inventory_PerformLayout(self, w, h)
		if self._w == w and self._h == h and self._c == #self:GetChildren() then return end
		self._w, self._h, self._c = w, h, #self:GetChildren()

		self:SizeToChildren(false, true)
		self:CenterHorizontal()
		self:AlignBottom(marginBottom)
	end

	local function bKeypads_Keycard_Inventory_Think(self, w, h)
		if not InventoryThink() then
			self:Remove()
		end
	end

	local function keycardsContainer_PerformLayout(self, w, h)
		for i, keycard in ipairs(self:GetChildren()) do
			keycard:SetPos(((i - 1) % (tileRowCount - 1)) * (tileSize + tileSpacing), math.floor(i / tileRowCount) * (tileSize + tileSpacing))
		end

		self:SizeToChildren(true, true)
		self:AlignTop(activeTileHeight + activeTileSpacing)
		self:CenterHorizontal()
		self:InvalidateParent()
	end

	local function focusMouse(self)
		if FrameNumber() - self.m_iFrameStart >= 2 then
			input.SetCursorPos(self:LocalToScreen(self:GetWide() / 2, self:GetTall() / 2))
			self.Think = nil
		end
	end
	
	function bKeypads.Keycards.Inventory:Show()
		if not InventoryThink() then return end

		if IsValid(bKeypads_Keycard_Inventory) then
			bKeypads_Keycard_Inventory:Remove()
		end

		KeycardModelPanels = {}

		local selectedKeycardPanel

		bKeypads_Keycard_Inventory = vgui.Create("EditablePanel")
		bKeypads_Keycard_Inventory.Paint = nil
		bKeypads_Keycard_Inventory:SetWide(width)
		bKeypads_Keycard_Inventory:MakePopup()
		bKeypads_Keycard_Inventory:SetKeyboardInputEnabled(false)
		bKeypads_Keycard_Inventory:SetMouseInputEnabled(true)
		bKeypads_Keycard_Inventory.PerformLayout = bKeypads_Keycard_Inventory_PerformLayout
		bKeypads_Keycard_Inventory.Think = bKeypads_Keycard_Inventory_Think

		local activeTileContainer = vgui.Create("DPanel", bKeypads_Keycard_Inventory)
		activeTileContainer.Paint = nil
		activeTileContainer:SetSize(activeTileWidth, activeTileHeight + activeTileSpacing)
		activeTileContainer:CenterHorizontal()

			local activeTile = KeycardModelPanel(activeTileContainer, KEYCARD_ACTIVE)
			activeTile:LayoutExamine()
			activeTile:SetSize(activeTileWidth, activeTileHeight)
			activeTile.OnMouseReleased = activeTile_OnMouseReleased

		local keycardsContainer = vgui.Create("DPanel", bKeypads_Keycard_Inventory)
		bKeypads_Keycard_Inventory.keycardsContainer = keycardsContainer
		keycardsContainer.Paint = nil
		keycardsContainer.PerformLayout = keycardsContainer_PerformLayout
		keycardsContainer.Populate = function()
			keycardsContainer:Clear()
			keycardsContainer.m_iTileCount = 0

			if not LocalPlayer():GetActiveWeapon():GetWasPickedUp() then
				local keycardPanel = KeycardModelPanel(keycardsContainer, KEYCARD_PLAYER)
				keycardPanel:LayoutSpin()
				keycardPanel:SetSize(tileSize, tileSize)
				keycardPanel.Paint = keycardPanel_Paint

				KeycardModelPanels[KEYCARD_PLAYER] = keycardPanel

				keycardsContainer.m_iTileCount = keycardsContainer.m_iTileCount + 1

				if not selectedKeycardPanel and LocalPlayer():GetActiveWeapon():GetSelectedKeycard() == 0 then
					selectedKeycardPanel = keycardPanel
				end
			end

			local heldKeycards = bKeypads.Keycards.Inventory:GetHeldKeycards(LocalPlayer())
			if heldKeycards then
				local sortKeycards = {}
				for keycardID in pairs(heldKeycards) do
					local keycardData = bKeypads.Keycards:GetByID(keycardID)
					local power = (keycardData.PrimaryLevel ^ 2) + #keycardData.Levels
					sortKeycards[keycardID] = power
				end
				for keycardID in SortedPairsByValue(sortKeycards, true) do
					local keycardPanel = KeycardModelPanel(keycardsContainer, keycardID)
					keycardPanel:LayoutSpin()
					keycardPanel:SetSize(tileSize, tileSize)
					keycardPanel.Paint = keycardPanel_Paint

					KeycardModelPanels[keycardID] = keycardPanel

					keycardsContainer.m_iTileCount = keycardsContainer.m_iTileCount + 1

					if not selectedKeycardPanel and LocalPlayer():GetActiveWeapon():GetSelectedKeycard() == keycardID then
						selectedKeycardPanel = keycardPanel
					end
				end
			end

			local rows = keycardsContainer.m_iTileCount / (tileRowCount - 1)
			keycardsContainer:SetTall((math.ceil(rows) * tileSize) + ((math.ceil(rows) - 1) * tileSpacing))
			bKeypads_Keycard_Inventory:SetTall(activeTileHeight + activeTileSpacing + keycardsContainer:GetTall())
			bKeypads_Keycard_Inventory:AlignBottom(marginBottom)
		end

		keycardsContainer:Populate()

		if IsValid(selectedKeycardPanel) then
			selectedKeycardPanel.Think = focusMouse
			selectedKeycardPanel.m_iFrameStart = FrameNumber()
		end
		selectedKeycardPanel = true

		surface.PlaySound("npc/combine_soldier/gear5.wav")
	end
end
--addons/bkeypads/lua/bkeypads/sh_keypad_linking.lua:
bKeypads.KeypadLinking = {}
bKeypads.KeypadLinking.Links = {}

if SERVER then
	for _, keypad in ipairs(ents.GetAll()) do
		if keypad.bKeypad then
			keypad:SetParentKeypad(NULL)
		end
	end

	local function undoLink(undoTbl, selectedKeypad, targetKeypad)
		if IsValid(targetKeypad) and targetKeypad:GetParentKeypad() == selectedKeypad then
			targetKeypad:SetParentKeypad(NULL)
			return true
		end
		return false
	end
	function bKeypads.KeypadLinking:Link(selectedKeypad, targetKeypad, ply)
		targetKeypad:SetParentKeypad(selectedKeypad)

		local persisting = false
		if bKeypads.Persistence:IsPersisting(targetKeypad) then
			persisting = true
			bKeypads.Persistence:CommitKeypad(targetKeypad)
		end
		if bKeypads.Persistence:IsPersisting(selectedKeypad) then
			persisting = true
			bKeypads.Persistence:CommitKeypad(selectedKeypad)
		end

		if IsValid(ply) then
			if not persisting then
				undo.Create("bKeypads_Keypad_Link")
					undo.AddFunction(undoLink, selectedKeypad, targetKeypad)
					undo.SetPlayer(ply)
				undo.Finish()
			end
			hook.Run("bKeypads.Link.Keypad", ply, selectedKeypad, targetKeypad)
		end
	end

	function bKeypads.KeypadLinking:Unlink(selectedKeypad, targetKeypad, ply)
		local canLink, source, target = bKeypads.KeypadLinking:TranslatePair(selectedKeypad, targetKeypad)
		if canLink then
			if IsValid(ply) then
				hook.Run("bKeypads.Unlink.Keypad", ply, source, target)
			end
			target:SetParentKeypad(NULL)
			
			if bKeypads.Persistence:IsPersisting(target) then
				bKeypads.Persistence:CommitKeypad(target)
			end
			if bKeypads.Persistence:IsPersisting(source) then
				bKeypads.Persistence:CommitKeypad(source)
			end
		end
	end
end

function bKeypads.KeypadLinking:TranslatePair(selectedKeypad, targetKeypad)
	if selectedKeypad == targetKeypad then return false end

	local selectedKeypadProxy = selectedKeypad:LinkProxy()
	local targetKeypadProxy = targetKeypad:LinkProxy()

	if selectedKeypadProxy == targetKeypadProxy then
		if selectedKeypad:IsParentKeypad() then
			return true, selectedKeypad, targetKeypad
		elseif targetKeypad:IsParentKeypad() then
			return true, targetKeypad, selectedKeypad
		else
			return true, selectedKeypadProxy, selectedKeypad
		end
	elseif selectedKeypadProxy:IsParentKeypad() and targetKeypadProxy:IsParentKeypad() then
		return false
	elseif targetKeypadProxy:IsParentKeypad() then
		return true, targetKeypadProxy, selectedKeypadProxy
	else
		return true, selectedKeypadProxy, targetKeypadProxy
	end
end

if SERVER then
	hook.Add("EntityRemoved", "bKeypads.Linking.EntityRemoved", function(keypad)
		if not keypad.bKeypad then return end
		if IsValid(keypad) and IsValid(bKeypads.KeypadLinking.Links[keypad]) then
			bKeypads.KeypadLinking:Unlink(bKeypads.KeypadLinking.Links[keypad], keypad)
		end
		bKeypads.KeypadLinking.Links[keypad] = nil
	end)
end
--addons/bkeypads/lua/bkeypads/sh_stool.lua:
-- Some strings and behaviour have been adapted under fair use from
-- https://github.com/willox/gmod-keypad/blob/master/lua/weapons/gmod_tool/stools/keypad_willox.lua
-- https://github.com/willox/gmod-keypad/blob/master/lua/weapons/gmod_tool/stools/keypad_willox_wire.lua
-- This is to simulate behaviour that players are already familiar with; all rights reserved.

local L = bKeypads.L

bKeypads.STOOL = {}
bKeypads.STOOL.RainbowBackgroundColor = 0xFFFFFF+1

--## Spawn menu closure blocking ##--

bKeypads.STOOL.BlockSpawnmenuClose = false
local function BlockSpawnmenuClose()
	if bKeypads.STOOL.BlockSpawnmenuClose then
		RunConsoleCommand("+menu")
	end
end
hook.Add("OnSpawnMenuClose", "bKeypads.BlockSpawnmenuClose", BlockSpawnmenuClose)

local function BlockSpawnmenuClose_BindPress(_, bind, pressed)
	if bKeypads.STOOL.BlockSpawnmenuClose and (bind == "+attack" or bind == "+attack2") and pressed then
		return true
	end
end
hook.Add("PlayerBindPress", "bKeypads.BlockSpawnmenuClose.BindPress", BlockSpawnmenuClose_BindPress)

--## Admin tools ##--

hook.Add("AddToolMenuCategories", "bKeypads.Spawnmenu.Admin", function()
	spawnmenu.AddToolCategory("Admin", "Billy's Keypads", "Billy's Keypads")
end)
hook.Add("PopulateToolMenu", "bKeypads.Spawnmenu.Admin", function()
	spawnmenu.AddToolMenuOption("Admin", "Billy's Keypads", "bKeypads.Persistence", "#bKeypads_Persistence", "gmod_tool bkeypads_persistence", "", bKeypads_Persistence_BuildCPanel)
	spawnmenu.AddToolMenuOption("Admin", "Billy's Keypads", "bKeypads.AdminTool", "#bKeypads_AdminTool", "gmod_tool bkeypads_admin_tool", "", bKeypads_AdminTool_BuildCPanel)
	spawnmenu.AddToolMenuOption("Admin", "Billy's Keypads", "bKeypads.KeypadBreaker", "#tool.bkeypads_breaker.name", "gmod_tool bkeypads_breaker", "", bKeypads_KeypadBreaker_BuildCPanel)
end)

--## CheckLimit convenience function ##--

bKeypads.STOOL.LIMIT_KEYPADS = 0
bKeypads.STOOL.LIMIT_FADING_DOORS = 1
function bKeypads.STOOL:CheckLimit(ply, limitType)
	local max, count

	if limitType == bKeypads.STOOL.LIMIT_KEYPADS then
		max = bKeypads.Config.MaxKeypads[ply:GetUserGroup()] or bKeypads.Config.MaxKeypads["default"] or 0
		count = ply:GetCount("_bkeypads")
	elseif limitType == bKeypads.STOOL.LIMIT_FADING_DOORS then
		max = bKeypads.Config.FadingDoors.Maximum[ply:GetUserGroup()] or bKeypads.Config.FadingDoors.Maximum["default"] or 0
		count = ply:GetCount("_bkeypads_fading_doors")
	end

	if max and count then
		return max == 0 or count < max
	end

	return false
end

--## Utility ##--

local stool_tr = { mask = bit.bor( CONTENTS_SOLID, CONTENTS_MOVEABLE, CONTENTS_MONSTER, CONTENTS_WINDOW, CONTENTS_DEBRIS, CONTENTS_GRATE, CONTENTS_AUX ) }
local stool_tr_cached
local stool_tr_cached_clock
function bKeypads:GetToolTrace(ply)
	local clock = SERVER and engine.TickCount() or FrameNumber()
	if stool_tr_cached and stool_tr_cached_clock ~= clock then
		stool_tr_cached = nil
	end
	if not stool_tr_cached then
		stool_tr_cached_clock = clock

		stool_tr.start = ply:EyePos()
		stool_tr.endpos = stool_tr.start + (ply:GetAimVector() * (4096 * 8))
		stool_tr.filter = ply

		stool_tr_cached = util.TraceLine(stool_tr)
	end
	return stool_tr_cached
end

--## Keypad STOOL itself ##--

bKeypads.STOOL.Settings = {}

local function print_err_stack(err)
	ErrorNoHalt(err .. "\n")
	debug.Trace()
end

function bKeypads.STOOL.LeftClick(self, tr)
	if not IsFirstTimePredicted() then return end

	local ply = self:GetOwner()
	if not IsValid(ply) then return false end

	if not tr.HitPos or (IsValid(tr.Entity) and tr.Entity:IsPlayer()) then return false end

	local isUpdating = IsValid(tr.Entity) and tr.Entity.bKeypad
	if not isUpdating and not bKeypads.STOOL:CheckLimit(ply, bKeypads.STOOL.LIMIT_KEYPADS) then return true end

	local KeypadOnlyFadingDoors = bKeypads.Config.KeypadOnlyFadingDoors and not bKeypads.Permissions:Check(ply, "keypads/bypass_keypad_only_fading_doors")
	if not isUpdating and KeypadOnlyFadingDoors and (tr.Entity == game.GetWorld() or not bKeypads.FadingDoors:CanFadingDoor(tr.Entity)) then
		return false
	end

	local authMode = self:GetClientNumber("auth_mode")

	if (
		(authMode ~= bKeypads.AUTH_MODE.KEYCARD or not bKeypads.Config.Scanning.ScanMethods.EnableKeycards) and
		(authMode ~= bKeypads.AUTH_MODE.FACEID or not bKeypads.Config.Scanning.ScanMethods.EnableFaceID) and
		(authMode ~= bKeypads.AUTH_MODE.PIN or not bKeypads.Config.Scanning.ScanMethods.EnablePIN)
	) then return false end
	
	if not bKeypads.Permissions:Check(ply, "access_methods/" .. (
		(authMode == bKeypads.AUTH_MODE.KEYCARD and "keycard") or
		(authMode == bKeypads.AUTH_MODE.FACEID and "faceid") or
		(authMode == bKeypads.AUTH_MODE.PIN and "pin")
	)) then return false end

	local keypad
	local mirrorKeypad
	if SERVER then

		local CreationData = isUpdating and tr.Entity:GetCreationData() or bKeypads.KeypadData:CreationData()
		CreationData.AuthMode = authMode

		CreationData.PIN = authMode == bKeypads.AUTH_MODE.PIN and self:GetClientInfo("pin") or nil
		
		CreationData.KeypadName = string.sub(self:GetClientInfo("name"), 1, 30)
		
		CreationData.NoCollide = tobool(self:GetClientNumber("nocollide")) or not bKeypads.Permissions:Check(ply, "keypads/collidable_keypads") or nil
		CreationData.Freeze = tobool(self:GetClientNumber("freeze")) or not bKeypads.Permissions:Check(ply, "keypads/unfrozen_keypads") or nil
		
		local must_weld = not bKeypads.Permissions:Check(ply, "keypads/unwelded_keypads")
		if KeypadOnlyFadingDoors or (tobool(self:GetClientNumber("weld")) or must_weld) then
			if not isUpdating and (IsValid(tr.Entity) or tr.HitWorld) then
				CreationData.WeldToEnt = tr.Entity
				CreationData.WeldToEntID = tr.Entity:MapCreationID() ~= -1 and tr.Entity:MapCreationID() or nil
				CreationData.WeldBone = tr.PhysicsBone or 0
				CreationData.WeldRemoveOnBreak = KeypadOnlyFadingDoors or nil
			elseif must_weld then
				return false
			end
		else
			CreationData.WeldToEnt = nil
			CreationData.WeldToEntID = nil
		end

		CreationData.Wiremod = tobool(self:GetClientNumber("wiremod")) and bKeypads.Permissions:Check(ply, "keypads/wiremod") or nil -- TODO https://www.gmodstore.com/messages/60657
		CreationData.Uncrackable = tobool(self:GetClientNumber("uncrackable")) and bKeypads.Permissions:Check(ply, "keypads/uncrackable_keypads") or nil

		if not bKeypads.Config.EnableKeyboardPress or not bKeypads.Permissions:Check(ply, "keypads/keyboard_button_simulation") then
			CreationData.GrantedKey = 0
			CreationData.DeniedKey = 0
		else
			CreationData.GrantedKey = self:GetClientNumber("granted_key") or 0
			CreationData.DeniedKey = self:GetClientNumber("denied_key") or 0
		end

		CreationData.GrantedTime = bKeypads.math.min(bKeypads.math.max(self:GetClientNumber("granted_hold_time"), 0, bKeypads.Config.Scanning.AccessGranted.MinimumTime), bKeypads.Config.Scanning.AccessGranted.MaximumTime ~= 0 and bKeypads.Config.Scanning.AccessGranted.MaximumTime or nil)
		CreationData.GrantedDelay = bKeypads.math.max(self:GetClientNumber("granted_initial_delay"), 0)
		CreationData.GrantedRepeats = bKeypads.math.min(bKeypads.math.max(math.Round(self:GetClientNumber("granted_repeats")), 0), bKeypads.Config.Scanning.AccessGranted.MaximumRepeats ~= 0 and bKeypads.Config.Scanning.AccessGranted.MaximumRepeats or nil)
		CreationData.GrantedRepeatDelay = bKeypads.math.max(self:GetClientNumber("granted_repeat_delay"), 0, bKeypads.Config.Scanning.AccessGranted.MinimumRepeatDelay)

		CreationData.DeniedTime = bKeypads.math.min(bKeypads.math.max(self:GetClientNumber("denied_hold_time"), 0, bKeypads.Config.Scanning.AccessDenied.MinimumTime), bKeypads.Config.Scanning.AccessDenied.MaximumTime ~= 0 and bKeypads.Config.Scanning.AccessDenied.MaximumTime or nil)
		CreationData.DeniedDelay = bKeypads.math.max(self:GetClientNumber("denied_initial_delay"), 0)
		CreationData.DeniedRepeats = bKeypads.math.min(bKeypads.math.max(math.Round(self:GetClientNumber("denied_repeats")), 0), bKeypads.Config.Scanning.AccessDenied.MaximumRepeats ~= 0 and bKeypads.Config.Scanning.AccessDenied.MaximumRepeats or nil)
		CreationData.DeniedRepeatDelay = bKeypads.math.max(self:GetClientNumber("denied_repeat_delay"), 0, bKeypads.Config.Scanning.AccessDenied.MinimumRepeatDelay)

		CreationData.ChargeUnauthorized = tobool(self:GetClientNumber("charge_unauthorized")) and bKeypads.Permissions:Check(ply, "keypads/payments") or nil
		
		CreationData.GrantedNotifications = tobool(self:GetClientNumber("granted_notification")) and bKeypads.Permissions:Check(ply, "notifications/access_granted") or nil
		CreationData.DeniedNotifications = tobool(self:GetClientNumber("denied_notification")) and bKeypads.Permissions:Check(ply, "notifications/access_denied") or nil
		
		CreationData.BackgroundColor = (tobool(self:GetClientNumber("rainbow_background_color")) and bKeypads.Permissions:Check(ply, "keypads/appearance/rainbows") and bKeypads.STOOL.RainbowBackgroundColor) or (authMode ~= bKeypads.AUTH_MODE.PIN and bKeypads.Permissions:Check(ply, "keypads/appearance/bg_color") and self:GetClientNumber("background_color")) or nil
		
		CreationData.Destructible = bKeypads.Config.KeypadDestruction.Enable
		if bKeypads.Config.KeypadDestruction.Enable then
			if bKeypads.Permissions:Check(ply, "destruction/indestructible") then
				CreationData.Destructible = not tobool(self:GetClientNumber("indestructible"))
				if CreationData.Destructible then
					CreationData.MaxHealth = math.max(self:GetClientNumber("max_health"), 1)
					CreationData.Shield = math.max(self:GetClientNumber("shield"), 0)
				end
			end
		else
			if bKeypads.Permissions:Check(ply, "destruction/destructible") then
				CreationData.Destructible = tobool(self:GetClientNumber("destructible"))
				if CreationData.Destructible then
					CreationData.MaxHealth = math.max(self:GetClientNumber("max_health"), 1)
					CreationData.Shield = math.max(self:GetClientNumber("shield"), 0)
				end
			end
		end

		CreationData.ImageURL = bKeypads.Config.Appearance.CustomImages.Enable and bKeypads.Permissions:Check(ply, "keypads/appearance/custom_img") and self:GetClientInfo("image_url") or ""
		if #CreationData.ImageURL == 0 or not bKeypads.KeypadImages:VerifyURL(CreationData.ImageURL) then
			CreationData.ImageURL = nil
		end

		if isUpdating then
			tr.Entity:Reset()
			tr.Entity:SetCreationData(CreationData)
			bKeypads:FetchAccessMatrix(ply, tr.Entity)
		else
		
			CreationData.Creator = ply
			
			local pos, angles = self:CalculateKeypadPos(tr)
			keypad = bKeypads:CreateKeypad(pos, angles, CreationData)

			ply:AddCount("_bkeypads", keypad)
			ply:AddCleanup("_bkeypads", keypad)

			if bKeypads.Config.KeypadMirroring and self:GetClientNumber("mirror") == 1 and bKeypads.Permissions:Check(ply, "mirror_keypads") then
				local mirrorPos, mirrorAng = self:CalculateMirroredKeypadPos(keypad, tr)
				if mirrorPos and mirrorAng then
					mirrorKeypad = bKeypads:CreateKeypad(mirrorPos, mirrorAng, CreationData)
				end
			end

			bKeypads:FetchAccessMatrix(ply, keypad, mirrorKeypad)

			if IsValid(mirrorKeypad) then
				timer.Simple(0, function()
					if IsValid(mirrorKeypad) and IsValid(keypad) then
						constraint.Weld(mirrorKeypad, keypad, 0, 0, 0, true, true)
					else
						if IsValid(mirrorKeypad) then
							mirrorKeypad:Remove()
						elseif IsValid(keypad) then
							keypad:Remove()
						end
					end
				end)

				bKeypads:FetchAccessMatrix(ply, mirrorKeypad)

				undo.Create("bKeypad")
					undo.AddEntity(keypad)
					undo.AddEntity(mirrorKeypad)
					undo.SetPlayer(ply)
				undo.Finish()

				ply:AddCleanup("_bkeypads", mirrorKeypad)

				bKeypads.KeypadLinking:Link(keypad, mirrorKeypad)
			else
				undo.Create("bKeypad")
					undo.AddEntity(keypad)
					undo.SetPlayer(ply)
				undo.Finish()
			end
			
		end

	end

	if not isUpdating and self:AutoFadingDoor() and bKeypads.Permissions:Check(ply, "fading_doors/create") then
		local tool = ply:GetTool("bkeypads_fading_door")
		if tool then
			if bKeypads.FadingDoors:CanFadingDoor(tr.Entity) and not bKeypads.FadingDoors:IsFadingDoor(tr.Entity) then
				bKeypads.FadingDoors.STOOL.LeftClick(tool, tr)
			end
			if SERVER and IsValid(keypad) and bKeypads.FadingDoors:IsFadingDoor(tr.Entity) and hook.Run("CanTool", ply, tr, "bkeypads_linker") then
				local links = bKeypads.FadingDoors:GetLinks(tr.Entity)
				if not links or not IsValid(links[keypad]) then
					bKeypads.FadingDoors:Link(keypad, tr.Entity, true, ply)
				end
				if IsValid(mirrorKeypad) and (not links or not IsValid(links[mirrorKeypad])) then
					bKeypads.FadingDoors:Link(mirrorKeypad, tr.Entity, true, ply)
				end
			end
		end
	end

	return true
end

if SERVER then
	util.AddNetworkString("bKeypads.KeypadAccessMatrix.Copy")
end
function bKeypads.STOOL.RightClick(self, tr)
	if not IsValid(self:GetOwner()) or not IsValid(tr.Entity) or not tr.Entity.bKeypad or tr.Entity:GetAuthMode() == bKeypads.AUTH_MODE.PIN then return false end

	if CLIENT then
		if IsFirstTimePredicted() then
			surface.PlaySound("garrysmod/balloon_pop_cute.wav")
			notification.AddProgress("KeypadAccessMatrixCopying", bKeypads.L("KeypadAccessMatrixCopying"))
			return true
		end
		return false
	else
		net.Start("bKeypads.KeypadAccessMatrix.Copy")
			bKeypads.KeypadData.Net:Serialize(tr.Entity.AccessMatrix)
			net.WriteUInt(tr.Entity:GetAuthMode(), 4)
		net.Send(self:GetOwner())
	end

	return true
end

if CLIENT then
	local matKeycard = Material("bkeypads/keycard")

	local function NumericOnly(self, c)
		if self:GetValue():sub(1,1) == "0" then
			return c == "0" or self:GetCaretPos() > 0
		end
		if c == "0" then
			return self:GetCaretPos() == 0 and #self:GetValue() > 0
		end
		return tonumber(c) == nil
	end

	local function NumericOnlyBounds(self)
		local n = tonumber(self:GetValue())
		if not n or (self.m_iMinimum ~= nil and n < self.m_iMinimum) or (self.m_iMaximum ~= nil and n > self.m_iMaximum) then
			self:SetText(tostring(self.m_iDefault))
		end
	end
	
	--## VGUI ##--
	
	local AccessOptions = {
		[bKeypads.ACCESS_GROUP.PLAYER] = function(AccessTable, AccessType, menu)
			if AccessType == bKeypads.ACCESS_TYPE.WHITELIST then
				local op = menu:AddOption(L("AddGroup"):format(L"GroupMe"), function()
					AccessTable:GetAccessMatrix()[AccessType][bKeypads.ACCESS_GROUP.PLAYER][LocalPlayer():SteamID()] = LocalPlayer():Nick()
					AccessTable:ResolveConflicts(AccessType)
					AccessTable:Populate()
					surface.PlaySound("garrysmod/ui_click.wav")
				end)
				op:SetIcon("icon16/box.png")

				op.m_Image.AvatarImage = vgui.Create("AvatarImage", op.m_Image)
				op.m_Image.AvatarImage:SetSteamID(LocalPlayer():SteamID64(), 32)
				op.m_Image.AvatarImage:Dock(FILL)
			end

			menu:AddOption(L("AddGroup"):format(L"Player"), function()
				bKeypads.STOOL.BlockSpawnmenuClose = true
				bKeypads.PlayerSelector:Open(function(steamid64s)
					bKeypads.STOOL.BlockSpawnmenuClose = false
					for steamid64, nick in pairs(steamid64s) do
						local ply = bKeypads.player.GetBySteamID64(steamid64)
						AccessTable:GetAccessMatrix()[AccessType][bKeypads.ACCESS_GROUP.PLAYER][util.SteamIDFrom64(steamid64)] = IsValid(ply) and ply:Nick() or (isstring(nick) and nick) or false
						AccessTable:ResolveConflicts(AccessType)
					end
					AccessTable:Populate()
				end)
			end):SetIcon("icon16/user.png")
		end,

		[bKeypads.ACCESS_GROUP.KEYCARD_LEVEL] = function(AccessTable, AccessType, menu)
			local AddKeycardLevel, _ = menu:AddSubMenu(L("AddGroup"):format(L"GroupKeycardLevel"))
			_:SetIcon("icon16/vcard.png")
			
			for level, data in SortedPairs(bKeypads.Keycards.Levels) do
				bKeypads.DermaMenuOption_Color(AddKeycardLevel:AddOption("[" .. level .. "] " .. data.Name, function()
					AccessTable:GetAccessMatrix()[AccessType][bKeypads.ACCESS_GROUP.KEYCARD_LEVEL][level] = true
					AccessTable:ResolveConflicts(AccessType)
					AccessTable:Populate()
					surface.PlaySound("garrysmod/ui_click.wav")
				end), data.Color or Color(255,0,0))
			end

			if AccessType == bKeypads.ACCESS_TYPE.WHITELIST then
				-- bKeypads.ACCESS_GROUP.SUPERIOR_KEYCARDS
				AddKeycardLevel:AddOption(L"AllSuperiorKeycards", function()
					AccessTable:GetAccessMatrix()[AccessType][bKeypads.ACCESS_GROUP.SUPERIOR_KEYCARDS] = true
					AccessTable:ResolveConflicts(AccessType)
					AccessTable:Populate()
					surface.PlaySound("garrysmod/ui_click.wav")
				end):SetIcon("icon16/sitemap_color.png")
			end
		end,

		[bKeypads.ACCESS_GROUP.STEAM_FRIENDS] = function(AccessTable, AccessType, menu)
			menu:AddOption(L"SteamFriends", function()
				AccessTable:GetAccessMatrix()[AccessType][bKeypads.ACCESS_GROUP.STEAM_FRIENDS] = true
				AccessTable:ResolveConflicts(AccessType)
				AccessTable:Populate()
				surface.PlaySound("garrysmod/ui_click.wav")
			end):SetIcon("icon16/emoticon_grin.png")
		end,

		[bKeypads.ACCESS_GROUP.USERGROUP] = function(AccessTable, AccessType, menu)
			local AddUsergroup, _ = menu:AddSubMenu(L("AddGroup"):format(L"Usergroup"))
			_:SetIcon("icon16/shield.png")

			local usergroups = {user = true, admin = true, superadmin = true}
			for _, ply in ipairs(player.GetAll()) do
				if OpenPermissions then
					for usergroup in pairs(OpenPermissions:GetUserGroups(ply)) do
						usergroups[usergroup] = true
					end
				else
					usergroups[ply:GetUserGroup()] = true
				end
			end
			
			for usergroup in SortedPairs(usergroups) do
				AddUsergroup:AddOption(usergroup, function()
					AccessTable:GetAccessMatrix()[AccessType][bKeypads.ACCESS_GROUP.USERGROUP][usergroup] = true
					AccessTable:ResolveConflicts(AccessType)
					AccessTable:Populate()
					surface.PlaySound("garrysmod/ui_click.wav")
				end):SetIcon((usergroup == "admin" or usergroup == "superadmin") and "icon16/shield.png" or "icon16/group.png")
			end

			AddUsergroup:AddOption(L"CustomEllipsis", function()
				bKeypads.STOOL.BlockSpawnmenuClose = true
				Derma_StringRequest(L("AddGroup"):format(L"Usergroup"), L"EnterUsergroup", "", function(usergroup)
					if usergroup and #usergroup > 0 then
						AccessTable:GetAccessMatrix()[AccessType][bKeypads.ACCESS_GROUP.USERGROUP][usergroup] = true
						AccessTable:ResolveConflicts(AccessType)
						AccessTable:Populate()
						surface.PlaySound("garrysmod/ui_click.wav")
					end
					bKeypads.STOOL.BlockSpawnmenuClose = false
				end, function() bKeypads.STOOL.BlockSpawnmenuClose = false end)
			end):SetIcon("icon16/pencil.png")
		end,

		[bKeypads.ACCESS_GROUP.TEAM] = function(AccessTable, AccessType, menu)
			local AddTeam, _ = menu:AddSubMenu(L("AddGroup"):format(L"Team"))
			_:SetIcon("icon16/flag_purple.png")

			for _, teamTbl in SortedPairsByMemberValue(team.GetAllTeams(), "Name") do
				bKeypads.DermaMenuOption_Color(AddTeam:AddOption(teamTbl.Name, function()
					AccessTable:GetAccessMatrix()[AccessType][bKeypads.ACCESS_GROUP.TEAM][teamTbl.Name] = true
					AccessTable:ResolveConflicts(AccessType)
					AccessTable:Populate()
					surface.PlaySound("garrysmod/ui_click.wav")
				end), teamTbl.Color)
			end
		end,

		["DarkRP"] = function(AccessType, menu)
			local DarkRPSubMenu, _ = menu:AddSubMenu("DarkRP")
			_:SetMaterial(Material("vgui/titlebaricon"))
			return DarkRPSubMenu
		end,

		[bKeypads.ACCESS_GROUP.DARKRP_JOB] = function(AccessTable, AccessType, menu, DarkRPSubMenu)
			DarkRPSubMenu:AddOption(L("AddGroup"):format(L"Job"), function()
				bKeypads.STOOL.BlockSpawnmenuClose = true
				bKeypads.JobSelector:Open(function(commands)
					bKeypads.STOOL.BlockSpawnmenuClose = false
					if #commands > 0 and IsValid(AccessTable) then
						for _, command in ipairs(commands) do
							AccessTable:GetAccessMatrix()[AccessType][bKeypads.ACCESS_GROUP.DARKRP_JOB][command] = true
							AccessTable:ResolveConflicts(AccessType)
						end
						AccessTable:Populate()
					end
				end)
			end):SetIcon("icon16/user_gray.png")
		end,

		[bKeypads.ACCESS_GROUP.DARKRP_JOB_CATEGORY] = function(AccessTable, AccessType, menu, DarkRPSubMenu)
			local AddJobCategory, _ = DarkRPSubMenu:AddSubMenu(L("AddGroup"):format(L"GroupJobCategory"))
			_:SetIcon("icon16/user_gray.png")

			for _, category in SortedPairsByMemberValue(DarkRP.getCategories().jobs, "name") do
				bKeypads.DermaMenuOption_Color(AddJobCategory:AddOption(category.name, function()
					AccessTable:GetAccessMatrix()[AccessType][bKeypads.ACCESS_GROUP.DARKRP_JOB_CATEGORY][category.name] = true
					AccessTable:ResolveConflicts(AccessType)
					AccessTable:Populate()
					surface.PlaySound("garrysmod/ui_click.wav")
				end), category.color)
			end
		end,

		[bKeypads.ACCESS_GROUP.DARKRP_DOOR_GROUP] = function(AccessTable, AccessType, menu, DarkRPSubMenu)
			local AddDoorGroupCategory, _ = DarkRPSubMenu:AddSubMenu(L("AddGroup"):format(L"GroupDoorGroup"))
			_:SetIcon("icon16/door.png")

			for _, doorGroup in SortedPairsByMemberValue(RPExtraTeamDoors, "name") do
				local opt = AddDoorGroupCategory:AddOption(doorGroup.name, function()
					AccessTable:GetAccessMatrix()[AccessType][bKeypads.ACCESS_GROUP.DARKRP_DOOR_GROUP][doorGroup.name] = true
					AccessTable:ResolveConflicts(AccessType)
					AccessTable:Populate()
					surface.PlaySound("garrysmod/ui_click.wav")
				end)
				if doorGroup[1] then
					bKeypads.DermaMenuOption_Color(opt, team.GetColor(doorGroup[1]))
				else
					opt:SetIcon("icon16/door.png")
				end
			end
		end,

		[bKeypads.ACCESS_GROUP.DARKRP_AGENDA_GROUP] = function(AccessTable, AccessType, menu, DarkRPSubMenu)
			local AddAgendaGroupCategory, _ = DarkRPSubMenu:AddSubMenu(L("AddGroup"):format(L"GroupAgendaGroup"))
			_:SetIcon("icon16/sound.png")

			local added = {}
			for _, agenda in SortedPairsByMemberValue(DarkRP.getAgendas(), "Title") do
				if not added[agenda] then added[agenda] = true else continue end
				local opt = AddAgendaGroupCategory:AddOption(agenda.Title, function()
					AccessTable:GetAccessMatrix()[AccessType][bKeypads.ACCESS_GROUP.DARKRP_AGENDA_GROUP][agenda.Title] = true
					AccessTable:ResolveConflicts(AccessType)
					AccessTable:Populate()
					surface.PlaySound("garrysmod/ui_click.wav")
				end)

				if isnumber(agenda.Manager) then
					bKeypads.DermaMenuOption_Color(opt, team.GetColor(agenda.Manager))
				else
					local job = agenda.Manager[1] or agenda.Listeners[1]
					if job then
						bKeypads.DermaMenuOption_Color(opt, team.GetColor(job))
					else
						opt:SetIcon("icon16/comments.png")
					end
				end
			end
		end,

		[bKeypads.ACCESS_GROUP.DARKRP_DEMOTE_GROUP] = function(AccessTable, AccessType, menu, DarkRPSubMenu)
			local AddDemoteGroupCategory, _ = DarkRPSubMenu:AddSubMenu(L("AddGroup"):format(L"GroupDemoteGroup"))
			_:SetIcon("icon16/report_user.png")

			local added = {}
			for job, demoteGroup in SortedPairsByMemberValue(DarkRP.getDemoteGroups(), "name") do
				if not added[demoteGroup] then added[demoteGroup] = true else continue end
				if not demoteGroup.name then continue end

				bKeypads.DermaMenuOption_Color(AddDemoteGroupCategory:AddOption(demoteGroup.name, function()
					AccessTable:GetAccessMatrix()[AccessType][bKeypads.ACCESS_GROUP.DARKRP_DEMOTE_GROUP][demoteGroup.name] = true
					AccessTable:ResolveConflicts(AccessType)
					AccessTable:Populate()
					surface.PlaySound("garrysmod/ui_click.wav")
				end), team.GetColor(job))
			end
		end,

		["Helix"] = function(AccessType, menu)
			local HelixSubMenu, _ = menu:AddSubMenu("Helix")
			_:SetMaterial(Material("vgui/titlebaricon"))
			return HelixSubMenu
		end,

		[bKeypads.ACCESS_GROUP.HELIX_FLAG] = function(AccessTable, AccessType, menu, HelixSubMenu)
			local AddHelixFlagCategory, _ = HelixSubMenu:AddSubMenu(L("AddGroup"):format(L"Flag"))
			_:SetIcon("icon16/flag_green.png")

			for flag, data in SortedPairs(ix.flag.list) do
				local op = AddHelixFlagCategory:AddOption(flag, function()
					AccessTable:GetAccessMatrix()[AccessType][bKeypads.ACCESS_GROUP.HELIX_FLAG][flag] = true
					AccessTable:ResolveConflicts(AccessType)
					AccessTable:Populate()
					surface.PlaySound("garrysmod/ui_click.wav")
				end)
				op:SetIcon("icon16/flag_green.png")
				op.bKeypads_Tooltip = data.description
			end
		end,
	}

	local function RainbowLabelPaint(self)
		local txt, rainbow = bKeypads.L("RainbowBackground"), not bKeypads.Performance:Optimizing() and self.bkeypads_rainbow_background_color:GetBool()
		if rainbow then
			txt = txt:upper()
			if self:GetText() ~= " " then self:SetText(" ") end
		else
			if self:GetText() ~= txt then
				self:SetText(txt)
				self:InvalidateParent(true)
			end
			return
		end

		local dc = DisableClipping(true)

		surface.SetFont(self:GetFont() == "DermaDefault" and "DermaDefaultBold" or self:GetFont())

		local shakeX, shakeY = math.Rand(-1, 1), math.Rand(-1, 1)
		surface.SetTextColor(self:GetColor())
		surface.SetTextPos(shakeX * 2, shakeY * 2)
		surface.DrawText(txt)

		surface.SetTextPos(0, 0)
		local txt_len = #txt
		local timeStep = CurTime() % txt_len
		for i = 1, txt_len do
			surface.SetTextColor(bKeypads:Rainbow(((((i + timeStep) % (txt_len - 1)) + 1) / txt_len) * 360))
			surface.DrawText(txt[i])
		end

		DisableClipping(dc)
	end

	local function BtnContainer_PerformLayout(self, w)
		self.Button1:Dock(LEFT)
		self.Button1:SetWide((w / 2) - 5)
		self.Button2:Dock(RIGHT)
		self.Button2:SetWide((w / 2) - 5)
	end

	local function HelpCategory_OnToggle(self)
		if not self:GetExpanded() then
			cookie.Set("bkeypads_help_viewed", 1)
		end
	end

	local function MethodBtnContainer_PerformLayout(self, w, h)
		local methods = (self.PIN:IsVisible() and 1 or 0) + (self.Keycard:IsVisible() and 1 or 0) + (self.FaceID:IsVisible() and 1 or 0)

		local space = math.min((w - (10 * (methods - 1))) / 3, 75)

		self:SetTall(space)
		self.PIN:SetSize(space - 14, space - 14)
		self.FaceID:SetSize(space - 14, space - 14)
		self.Keycard:SetSize(space - 14, space - 14)
		
		local btn_w = (methods * space) + ((methods - 1) * 10)
		local x = (w - btn_w) / 2
		
		if self.PIN:IsVisible() then
			self.PIN:SetPos(x + 7, 0)
			self.PIN:CenterVertical()

			x = x + space + 10
		end

		if self.FaceID:IsVisible() then
			self.FaceID:SetPos(x + 7, 0)
			self.FaceID:CenterVertical()

			x = x + space + 10
		end

		if self.Keycard:IsVisible() then
			self.Keycard:SetPos(x + 7, 0)
			self.Keycard:CenterVertical()

			--x = x + space + 10
		end
	end

	local bkeypads_auth_mode, authMethodAnimStart, authMethodAnimXStart, authMethodAnimX
	local function MethodBtnAnim(self)
		local x,y
		local AuthMode = bkeypads_auth_mode:GetInt()
		if AuthMode == bKeypads.AUTH_MODE.KEYCARD then
			x,y = self.Keycard:GetPos()
		elseif AuthMode == bKeypads.AUTH_MODE.PIN then
			x,y = self.PIN:GetPos()
		elseif AuthMode == bKeypads.AUTH_MODE.FACEID then
			x,y = self.FaceID:GetPos()
		end

		authMethodAnimX = x

		return x,y
	end

	local function MethodBtnClickSwitch(self)
		authMethodAnimStart, authMethodAnimXStart = SysTime(), authMethodAnimX
		bkeypads_auth_mode:SetInt(self.AuthMode)
		self:GetParent().CPanel.AccessCategory:AuthModeChanged(self.AuthMode)
		self:GetParent().CPanel.AppearanceCategory:AuthModeChanged(self.AuthMode)
	end

	local function MethodBtnClick(self)
		self:DoSwitch(self)
		RunConsoleCommand("gmod_tool", "bkeypads")
		surface.PlaySound("ui/buttonclick.wav")
	end

	local function MethodBtnContainer_PaintOver(self, w, h)
		surface.SetDrawColor(0,0,0)

		local x,y = MethodBtnAnim(self)
		local frac = math.Clamp(math.TimeFraction(authMethodAnimStart, authMethodAnimStart + .2, SysTime()), 0, 1)
		x = Lerp(bKeypads.ease.InOutSine(frac), authMethodAnimXStart, authMethodAnimX)

		local methods = (self.PIN:IsVisible() and 1 or 0) + (self.Keycard:IsVisible() and 1 or 0) + (self.FaceID:IsVisible() and 1 or 0)
		local space = math.min((w - (10 * (methods - 1))) / 3, 75)
		surface.DrawOutlinedRect(x - 6 - 1, y - 6 - 1, space, space)
		surface.DrawOutlinedRect(x - 6, y - 6, space - 2, space - 2)
	end

	local function AccessBtnContainer_PerformLayout(self,w,h)
		self.WhitelistBtn:SetWide((w / 2) - 5)
		self.BlacklistBtn:SetWide((w / 2) - 5)
	end

	local function SaveKeypadAllowInput(self, c)
		return not c:match("[A-Za-z0-9-_]")
	end
	
	local function PaymentEntryAllowInput(self, c)
		if c == "0" then
			return #self:GetValue() ~= 0 and (self:GetValue() == "0" or self:GetCaretPos() == 0)
		else
			if not c:match("[1-9]") then return true end
			return self:GetValue() == "0" and self:GetCaretPos() ~= 0
		end
	end

	local function MaximumCharsAllowInput(self, c)
		if self._AllowInput and self:_AllowInput(c) == true then return true end
		if not self.m_MaximumChars then return end
		if #self:GetValue() + 1 >= self.m_MaximumChars then
			return true
		end
	end

	function bKeypads.STOOL.BuildCPanel(CPanel)
		local isMainCPanel = controlpanel.Get("bkeypads") == CPanel
		local AccessTable
		
		bKeypads:InjectSmoothScroll(CPanel)
		
		bkeypads_auth_mode = bkeypads_auth_mode or GetConVar("bkeypads_auth_mode")
		local bkeypads_background_color = GetConVar("bkeypads_background_color")
		local bkeypads_image_url = GetConVar("bkeypads_image_url")

		bKeypads:STOOLMatrix(CPanel)

		local KeypadName = bKeypads:RecursiveTooltip(L"KeypadNameTip", CPanel:TextEntry(L"Name", "bkeypads_name"))
		KeypadName.m_MaximumChars = 23
		KeypadName.AllowInput = MaximumCharsAllowInput

		local AutoFadingDoor = bKeypads:RecursiveTooltip(L"AutoFadingDoorTip", CPanel:CheckBox(L"AutoFadingDoor", "bkeypads_auto_fading_door"))
		local MirrorPlacement = bKeypads:RecursiveTooltip(L"MirrorPlacementTip", CPanel:CheckBox(L"MirrorPlacement", "bkeypads_mirror"))

		--## HELP ##--

		CPanel.HelpCategory = vgui.Create("DForm", CPanel)
		CPanel.HelpCategory:SetLabel(L"Help")
		CPanel.HelpCategory:SetExpanded(cookie.GetNumber("bkeypads_help_viewed", 0) == 0)
		CPanel.HelpCategory.OnToggle = HelpCategory_OnToggle

			local img = vgui.Create("bKeypads.DockedImage", CPanel.HelpCategory)
			img:SetMaterial(Material("bkeypads/keypads.png", "smooth"))
			CPanel.HelpCategory:AddItem(img)

			CPanel.HelpCategory:Help(L"ToolHelp1" .. "\n\n" .. L"ToolHelp2" .. "\n\n" .. L"ToolHelp3" .. "\n\n" .. L"ToolHelp4"):DockMargin(0, 0, 0, 0)

			CPanel.Tutorial = vgui.Create("DButton", CPanel)
			CPanel.Tutorial:SetText(L"Tutorial")
			CPanel.Tutorial:SetIcon("icon16/emoticon_grin.png")
			CPanel.Tutorial:SetTall(25)
			CPanel.Tutorial.DoClick = function()
				bKeypads.Tutorial:OpenMenu()
			end
			-- TODO write wiki and add https://youtu.be/IK4TrpkGBLs [FR]

			CPanel.HelpCategory:AddItem(CPanel.Tutorial)

		CPanel:AddItem(CPanel.HelpCategory)

		--## SAVING ##--

		CPanel.SavesCategory = vgui.Create("DForm", CPanel)
		CPanel.SavesCategory:SetLabel(L"SavedKeypads")
		CPanel.SavesCategory:SetExpanded(false)

			bKeypads:AddHelp(CPanel.SavesCategory, L"SaveLoadTip"):DockMargin(0, 0, 0, 0)

			CPanel.FileSelection = vgui.Create("DListView", CPanel.SavesCategory)
			CPanel.FileSelection:SetTall(150)
			CPanel.FileSelection:AddColumn(L"Name")
			CPanel.FileSelection:AddColumn(L"Added")
			function CPanel.FileSelection:Populate()
				self:Clear()

				local savedKeypads = {}
				for _, f in ipairs((file.Find("bkeypads/saved/*.json", "DATA"))) do
					table.insert(savedKeypads, {LastModified = file.Time("bkeypads/saved/" .. f, "DATA"), Name = f:sub(1,-2-5-5)})
				end
				table.SortByMember(savedKeypads, "LastModified")
				for _, f in ipairs(savedKeypads) do
					CPanel.FileSelection:AddLine(f.Name, os.date("%x %X", f.LastModified)).Name = f.Name
				end
			end
			CPanel.FileSelection:Populate()

		CPanel.SavesCategory:AddItem(CPanel.FileSelection)

			local BtnContainer = vgui.Create("DPanel", CPanel.SavesCategory)
			BtnContainer.Paint = nil
			BtnContainer.PerformLayout = BtnContainer_PerformLayout
			
				CPanel.LoadSave = vgui.Create("DButton", BtnContainer)
				CPanel.LoadSave:SetText(L"LoadSave")
				CPanel.LoadSave:SetIcon("icon16/page_lightning.png")
				CPanel.LoadSave:SetTall(25)
				CPanel.LoadSave:SetDisabled(true)
			
				CPanel.DeleteSave = vgui.Create("DButton", BtnContainer)
				CPanel.DeleteSave:SetText(L"Delete")
				CPanel.DeleteSave:SetIcon("icon16/cancel.png")
				CPanel.DeleteSave:SetTall(25)
				CPanel.DeleteSave:SetDisabled(true)
				CPanel.DeleteSave.DoClick = function(self)
					surface.PlaySound("common/warning.wav")

					bKeypads.STOOL.BlockSpawnmenuClose = true

					local _, line = CPanel.FileSelection:GetSelectedLine()
					Derma_Query((bKeypads.L("DeleteSaveConfirm")):format(line.Name), L"Delete", L"Yes", function()
						surface.PlaySound("npc/roller/remote_yes.wav")

						bKeypads.STOOL.BlockSpawnmenuClose = false

						file.Delete("bkeypads/saved/" .. line.Name .. "_stool.json")
						file.Delete("bkeypads/saved/" .. line.Name .. "_access.dat")

						self:SetDisabled(true)
						CPanel.LoadSave:SetDisabled(true)
						CPanel.FileSelection:Populate()
					end, L"Cancel", function() bKeypads.STOOL.BlockSpawnmenuClose = false end)
				end

				BtnContainer.Button1 = CPanel.LoadSave
				BtnContainer.Button2 = CPanel.DeleteSave
			
		CPanel.SavesCategory:AddItem(BtnContainer)

			CPanel.SaveKeypad = vgui.Create("DButton", CPanel.SavesCategory)
			CPanel.SaveKeypad:SetText(L"SaveKeypad")
			CPanel.SaveKeypad:SetIcon("icon16/page_save.png")
			CPanel.SaveKeypad:SetTall(25)
			CPanel.SaveKeypad.DoClick = function()
				bKeypads.STOOL.BlockSpawnmenuClose = true

				local Window = Derma_StringRequest(L"SaveKeypad", L"SaveKeypadFileName", "", function(filename)
					if #filename > 0 then
						local function DoSave()
							surface.PlaySound("garrysmod/content_downloaded.wav")
							bKeypads.STOOL.BlockSpawnmenuClose = false

							local savedKeypad = {}
							for convar_name, def in pairs(bKeypads_STOOL_CONVARS) do
								local convar = GetConVar("bkeypads_" .. convar_name)
								if isnumber(def) then
									local fl = convar:GetFloat()
									savedKeypad[convar_name] = fl % 1 == 0 and convar:GetInt() or fl
								else
									savedKeypad[convar_name] = convar:GetString()
								end
							end
							file.Write("bkeypads/saved/" .. filename .. "_stool.json", util.TableToJSON(savedKeypad))
							bKeypads.KeypadData.File:Serialize(bKeypads.KeypadData.File:Open("bkeypads/saved/" .. filename .. "_access.dat", true, "DATA"), AccessTable:GetAccessMatrix())

							CPanel.LoadSave:SetDisabled(true)
							CPanel.DeleteSave:SetDisabled(true)
							CPanel.FileSelection:Populate()
						end
						if file.Exists("bkeypads/saved/" .. filename .. "_stool.json", "DATA") then
							surface.PlaySound("npc/roller/remote_yes.wav")
							Derma_Query((bKeypads.L("SaveKeypadAlreadyExists")):format(os.date("%c", file.Time("bkeypads/saved/" .. filename .. "_stool.json", "DATA"))), L"SaveKeypad", L"Yes", DoSave, L"Cancel")
						else
							DoSave()
						end
					else
						bKeypads.STOOL.BlockSpawnmenuClose = false
					end
				end, function() bKeypads.STOOL.BlockSpawnmenuClose = false end)

				local TextEntry = Window:Find("DTextEntry")
				TextEntry:SetAllowNonAsciiCharacters(false)
				TextEntry._AllowInput = SaveKeypadAllowInput
				TextEntry.m_MaximumChars = 30
				TextEntry.AllowInput = MaximumCharsAllowInput
			end
	
		function CPanel.FileSelection:OnRowSelected(index, line)
			CPanel.DeleteSave:SetDisabled(false)
			CPanel.LoadSave:SetDisabled(false)
		end

		CPanel.SavesCategory:AddItem(CPanel.SaveKeypad)

		CPanel:AddItem(CPanel.SavesCategory)

		--## DESTRUCTION ##--

		CPanel.DestructionCategory = vgui.Create("DForm", CPanel)
		CPanel.DestructionCategory:SetLabel(L"Destruction")
		CPanel.DestructionCategory:SetExpanded(false)

			CPanel.DestructionCategory.Indestructible = CPanel.DestructionCategory:CheckBox(L"Indestructible", "bkeypads_indestructible")
			bKeypads:AddShieldIcon(CPanel.DestructionCategory.Indestructible)

			CPanel.DestructionCategory.Destructible = CPanel.DestructionCategory:CheckBox(L"Destructible", "bkeypads_destructible")
			bKeypads:AddShieldIcon(CPanel.DestructionCategory.Destructible)

			CPanel.DestructionCategory.MaxHealth = CPanel.DestructionCategory:TextEntry(L"MaxHealth", "bkeypads_max_health")
			CPanel.DestructionCategory.MaxHealth.m_iDefault = bKeypads.Config.KeypadDestruction.KeypadHealth
			CPanel.DestructionCategory.MaxHealth.m_iMinimum = 1
			CPanel.DestructionCategory.MaxHealth.AllowInput = NumericOnly
			CPanel.DestructionCategory.MaxHealth.OnValueChange = NumericOnlyBounds
			bKeypads:AddShieldIcon(CPanel.DestructionCategory.MaxHealth)

			CPanel.DestructionCategory.Shield = CPanel.DestructionCategory:TextEntry(L"Shield", "bkeypads_shield")
			CPanel.DestructionCategory.Shield.m_iDefault = 0
			CPanel.DestructionCategory.Shield.m_iMinimum = 0
			CPanel.DestructionCategory.Shield.AllowInput = NumericOnly
			CPanel.DestructionCategory.Shield.OnValueChange = NumericOnlyBounds
			bKeypads:AddShieldIcon(CPanel.DestructionCategory.Shield)

		CPanel:AddItem(CPanel.DestructionCategory)

		--## NOTIFICATIONS ##--

		CPanel.NotificationsCategory = vgui.Create("DForm", CPanel)
		CPanel.NotificationsCategory:SetLabel(L"Notifications")
		CPanel.NotificationsCategory:SetExpanded(GetConVar("bkeypads_granted_notification"):GetBool() or GetConVar("bkeypads_denied_notification"):GetBool())

			CPanel.NotificationsCategory.AccessGranted = CPanel.NotificationsCategory:CheckBox(L"AccessGranted", "bkeypads_granted_notification")
			CPanel.NotificationsCategory.AccessDenied  = CPanel.NotificationsCategory:CheckBox(L"AccessDenied", "bkeypads_denied_notification")

			bKeypads:RecursiveTooltip(L"AccessGrantedNotificationTip", CPanel.NotificationsCategory.AccessGranted)
			bKeypads:RecursiveTooltip(L"AccessDeniedNotificationTip", CPanel.NotificationsCategory.AccessDenied)

		CPanel:AddItem(CPanel.NotificationsCategory)

		--## CONFIG ##--

		CPanel.ConfigCategory = vgui.Create("DForm", CPanel)
		CPanel.ConfigCategory:SetLabel(L"Configuration")

			local NoCollideCheckbox = bKeypads:RecursiveTooltip(L"NoCollideTip", CPanel.ConfigCategory:CheckBox(L"NoCollide", "bkeypads_nocollide"))
			local FreezeCheckbox = bKeypads:RecursiveTooltip(L"FreezeTip", CPanel.ConfigCategory:CheckBox(L"Freeze", "bkeypads_freeze"))
			local WeldCheckbox = bKeypads:RecursiveTooltip(L"WeldTip", CPanel.ConfigCategory:CheckBox(L"Weld", "bkeypads_weld"))

			local WiremodCheckbox = bKeypads:RecursiveTooltip(L"WiremodTip", CPanel.ConfigCategory:CheckBox("Wiremod", "bkeypads_wiremod"))

			local UncrackableCheckbox = CPanel.ConfigCategory:CheckBox(L"Uncrackable", "bkeypads_uncrackable")
			bKeypads:AddShieldIcon(UncrackableCheckbox)
			bKeypads:RecursiveTooltip(L"UncrackableTip" .. "\n" .. L"UncrackableIncompatibilitiesTip", UncrackableCheckbox)
		
		CPanel:AddItem(CPanel.ConfigCategory)

		--## METHOD ##--

		CPanel.MethodCategory = vgui.Create("DForm", CPanel)
		CPanel.MethodCategory:SetLabel(L"KeypadMethod")

			local MethodBtnContainer = vgui.Create("DPanel", CPanel.MethodCategory)
			MethodBtnContainer.CPanel = CPanel
			MethodBtnContainer.Paint = nil
			MethodBtnContainer:SetTall(64 + 20)
			MethodBtnContainer.PerformLayout = MethodBtnContainer_PerformLayout

			MethodBtnContainer.PIN = vgui.Create("DImageButton", MethodBtnContainer)
			MethodBtnContainer.PIN.AuthMode = bKeypads.AUTH_MODE.PIN
			MethodBtnContainer.PIN:SetSize(64,64)
			MethodBtnContainer.PIN.bKeypads_Tooltip = L"PINTip"
			MethodBtnContainer.PIN.DoClick = MethodBtnClick
			MethodBtnContainer.PIN.DoSwitch = MethodBtnClickSwitch
			MethodBtnContainer.PIN:SetMaterial(Material("bkeypads/method_pin"))
			MethodBtnContainer.PIN:SetColor(bKeypads.COLOR.BLACK)

			MethodBtnContainer.FaceID = vgui.Create("DImageButton", MethodBtnContainer)
			MethodBtnContainer.FaceID.AuthMode = bKeypads.AUTH_MODE.FACEID
			MethodBtnContainer.FaceID:SetSize(64,64)
			MethodBtnContainer.FaceID.bKeypads_Tooltip = L"FaceIDTip"
			MethodBtnContainer.FaceID.DoClick = MethodBtnClick
			MethodBtnContainer.FaceID.DoSwitch = MethodBtnClickSwitch
			MethodBtnContainer.FaceID:SetMaterial(Material("bkeypads/face_id"))
			MethodBtnContainer.FaceID:SetColor(bKeypads.COLOR.BLACK)

			MethodBtnContainer.Keycard = vgui.Create("DImageButton", MethodBtnContainer)
			MethodBtnContainer.Keycard.AuthMode = bKeypads.AUTH_MODE.KEYCARD
			MethodBtnContainer.Keycard:SetSize(64,64)
			MethodBtnContainer.Keycard.bKeypads_Tooltip = L"KeycardTip"
			MethodBtnContainer.Keycard.DoClick = MethodBtnClick
			MethodBtnContainer.Keycard.DoSwitch = MethodBtnClickSwitch
			MethodBtnContainer.Keycard:SetMaterial(matKeycard)
			MethodBtnContainer.Keycard:SetColor(bKeypads.COLOR.BLACK)

			MethodBtnAnim(MethodBtnContainer)
			authMethodAnimStart = SysTime() - .2
			authMethodAnimXStart = authMethodAnimX
			MethodBtnContainer.PaintOver = MethodBtnContainer_PaintOver

			bKeypads_AuthModeChangedCallbackID = (bKeypads_AuthModeChangedCallbackID or 0) + 1
			local myCallbackID = bKeypads_AuthModeChangedCallbackID
			cvars.AddChangeCallback("bkeypads_auth_mode", function(_, __, AuthMode)
				if IsValid(MethodBtnContainer) then
					local AuthMode = tonumber(AuthMode)
					if AuthMode == bKeypads.AUTH_MODE.PIN then
						MethodBtnContainer.PIN:DoSwitch()
					elseif AuthMode == bKeypads.AUTH_MODE.FACEID then
						MethodBtnContainer.FaceID:DoSwitch()
					elseif AuthMode == bKeypads.AUTH_MODE.KEYCARD then
						MethodBtnContainer.Keycard:DoSwitch()
					end
				else
					cvars.RemoveChangeCallback("bkeypads_auth_mode", "bkeypads_auth_mode_" .. myCallbackID)
				end
			end, "bkeypads_auth_mode_" .. bKeypads_AuthModeChangedCallbackID)

			CPanel.MethodCategory:AddItem(MethodBtnContainer)
		
		CPanel:AddItem(CPanel.MethodCategory)

		--## ACCESS ##--

		CPanel.AccessCategory = vgui.Create("DForm", CPanel)
		CPanel.AccessCategory:SetLabel(L"Access")

			local PINField = CPanel.AccessCategory:TextEntry(L"PIN", "bkeypads_pin")
			function PINField:AllowInput(c)
				return not tonumber(c) or #self:GetValue() >= 6
			end

			local ChargeUnauthorized = bKeypads:RecursiveTooltip(L"ChargeUnauthorizedTip", CPanel.AccessCategory:CheckBox(L"ChargeUnauthorized", "bkeypads_charge_unauthorized"))
			ChargeUnauthorized:SetDisabled(true)
			ChargeUnauthorized:SetChecked(false)

			local PaymentBtn = vgui.Create("DButton", CPanel.AccessCategory)
			PaymentBtn:SetTall(25)
			PaymentBtn:SetIcon("icon16/money.png")
			PaymentBtn:SetText(L"SetPayment")
			PaymentBtn.bKeypads_Tooltip = L"SetPaymentTip"
			PaymentBtn.DoClick = function()
				surface.PlaySound("garrysmod/ui_click.wav")
				
				bKeypads.STOOL.BlockSpawnmenuClose = true

				local txt = L"PaymentEntry"
				if bKeypads.Config.Payments.MaximumPayment > 0 or bKeypads.Config.Payments.MinimumPayment > 1 then
					txt = txt .. "\n"
					if bKeypads.Config.Payments.MinimumPayment > 1 then
						txt = txt .. "\n" .. (L"PaymentMinimum"):format(bKeypads.Economy:formatMoney(bKeypads.Config.Payments.MinimumPayment))
					end
					if bKeypads.Config.Payments.MaximumPayment > 0 then
						txt = txt .. "\n" .. (L"PaymentMaximum"):format(bKeypads.Economy:formatMoney(bKeypads.Config.Payments.MaximumPayment))
					end
				end
				Derma_StringRequest(L"Payment", txt, "",
					function(amount)
						bKeypads.STOOL.BlockSpawnmenuClose = false
						amount = tonumber(amount)
						if amount and amount >= 0 and amount % 1 == 0 then
							if amount == 0 then
								AccessTable:GetAccessMatrix()[bKeypads.ACCESS_GROUP.PAYMENT] = false
							elseif bKeypads.Config.Payments.MaximumPayment > 0 and amount > bKeypads.Config.Payments.MaximumPayment then
								surface.PlaySound("common/warning.wav")
								Derma_Message((L"PaymentAboveMaximum"):format(bKeypads.Economy:formatMoney(bKeypads.Config.Payments.MaximumPayment)), L"Payment", L"Dismiss")
								return
							elseif bKeypads.Config.Payments.MinimumPayment > 1 and amount < bKeypads.Config.Payments.MinimumPayment then
								surface.PlaySound("common/warning.wav")
								Derma_Message((L"PaymentBelowMinimum"):format(bKeypads.Economy:formatMoney(bKeypads.Config.Payments.MinimumPayment)), L"Payment", L"Dismiss")
								return
							else
								AccessTable:GetAccessMatrix()[bKeypads.ACCESS_GROUP.PAYMENT] = math.min(amount, (2^31)-1)
							end
							AccessTable:Populate()
							surface.PlaySound("bkeypads/cash.wav")
						end
					end,

					function()
						bKeypads.STOOL.BlockSpawnmenuClose = false
					end
				):Find("DTextEntry").AllowInput = PaymentEntryAllowInput
			end
			CPanel.AccessCategory:AddItem(PaymentBtn)

		do
			local AccessTip = bKeypads:AddHelp(CPanel.AccessCategory, L"KeypadAccessTip2")
			AccessTip:DockMargin(0, 0, 0, 0)

			AccessTable = vgui.Create("bKeypads.AccessMatrix", CPanel.AccessCategory)
			if isMainCPanel then bKeypads.AccessTable = AccessTable end
			AccessTable:SetUseConVar(true)
			AccessTable:Dock(TOP)
			AccessTable:SetTall(200)
			AccessTable.PostPopulate = function()
				if AccessTable:GetAccessMatrix()[bKeypads.ACCESS_GROUP.PAYMENT] ~= false then
					ChargeUnauthorized:SetDisabled(false)
				else
					ChargeUnauthorized:SetChecked(false)
					ChargeUnauthorized:SetDisabled(true)
				end
			end

			CPanel.AccessCategory:AddItem(AccessTable)

			local function AccessBtnClick(self)
				surface.PlaySound("garrysmod/ui_return.wav")

				local menu = DermaMenu(nil, self)

				if bkeypads_auth_mode:GetInt() == bKeypads.AUTH_MODE.KEYCARD then
					AccessOptions[bKeypads.ACCESS_GROUP.KEYCARD_LEVEL](AccessTable, self.AccessType, menu)
				end
				
				AccessOptions[bKeypads.ACCESS_GROUP.PLAYER](AccessTable, self.AccessType, menu)
				AccessOptions[bKeypads.ACCESS_GROUP.STEAM_FRIENDS](AccessTable, self.AccessType, menu)
				AccessOptions[bKeypads.ACCESS_GROUP.USERGROUP](AccessTable, self.AccessType, menu)
				if DarkRP then
					local DarkRPSubMenu = AccessOptions["DarkRP"](self.AccessType, menu)
					AccessOptions[bKeypads.ACCESS_GROUP.DARKRP_JOB](AccessTable, self.AccessType, menu, DarkRPSubMenu)
					AccessOptions[bKeypads.ACCESS_GROUP.DARKRP_JOB_CATEGORY](AccessTable, self.AccessType, menu, DarkRPSubMenu)
					AccessOptions[bKeypads.ACCESS_GROUP.DARKRP_DOOR_GROUP](AccessTable, self.AccessType, menu, DarkRPSubMenu)
					AccessOptions[bKeypads.ACCESS_GROUP.DARKRP_AGENDA_GROUP](AccessTable, self.AccessType, menu, DarkRPSubMenu)
					AccessOptions[bKeypads.ACCESS_GROUP.DARKRP_DEMOTE_GROUP](AccessTable, self.AccessType, menu, DarkRPSubMenu)
				else
					AccessOptions[bKeypads.ACCESS_GROUP.TEAM](AccessTable, self.AccessType, menu)
				end
				if ix and ix.flag then
					local HelixSubMenu = AccessOptions["Helix"](self.AccessType, menu)
					AccessOptions[bKeypads.ACCESS_GROUP.HELIX_FLAG](AccessTable, self.AccessType, menu, HelixSubMenu)
				end

				if bKeypads.CustomAccess.UserConfig.Enabled then
					local spacer = false

					if not table.IsEmpty(bKeypads.CustomAccess.UserConfig.TeamGroups) then
						if not spacer then
							spacer = true
							menu:AddSpacer()
						end

						local TeamGroups, _ = menu:AddSubMenu(L("AddGroup"):format(L"GroupCustomTeamGroup"))
						_:SetIcon("icon16/script_code_red.png")

						for name in pairs(bKeypads.CustomAccess.UserConfig.TeamGroups) do
							TeamGroups:AddOption(name, function()
								AccessTable:GetAccessMatrix()[self.AccessType][bKeypads.ACCESS_GROUP.CUSTOM_TEAM_GROUP][name] = true
								AccessTable:ResolveConflicts(self.AccessType)
								AccessTable:Populate()
								surface.PlaySound("garrysmod/ui_click.wav")
							end):SetIcon("icon16/script_code_red.png")
						end
					end

					if not table.IsEmpty(bKeypads.CustomAccess.UserConfig.LuaFunctions) and bKeypads.Permissions:Check(LocalPlayer(), "keypads/custom_lua_functions") then
						if not spacer then
							spacer = true
							menu:AddSpacer()
						end

						local LuaFunctions, _ = menu:AddSubMenu(L("AddGroup"):format(L"GroupCustomLuaFunction"))
						_:SetIcon("icon16/script_code.png")

						for name in pairs(bKeypads.CustomAccess.UserConfig.LuaFunctions) do
							LuaFunctions:AddOption(name, function()
								AccessTable:GetAccessMatrix()[self.AccessType][bKeypads.ACCESS_GROUP.CUSTOM_LUA_FUNCTION][name] = true
								AccessTable:ResolveConflicts(self.AccessType)
								AccessTable:Populate()
								surface.PlaySound("garrysmod/ui_click.wav")
							end):SetIcon("icon16/script_code.png")
						end
					end
				end

				if bKeypads.CustomAccess.Addons.Enabled then
					menu:AddSpacer()

					local function addCustomAccessMember(parent, member)
						local option, btn
						if member.Members then
							option, btn = parent:AddSubMenu(member.Name)
							for id, member in SortedPairsByMemberValue(member.Members, "Name") do
								addCustomAccessMember(option, member)
							end
						else
							option = parent:AddOption(member.Name, function()
								AccessTable:GetAccessMatrix()[self.AccessType][bKeypads.ACCESS_GROUP.CUSTOM_ADDON_FUNCTION][member.ID] = true
								AccessTable:ResolveConflicts(self.AccessType)
								AccessTable:Populate()
								surface.PlaySound("garrysmod/ui_click.wav")
							end)
						end
						if IsColor(member.Icon) or (istable(member.Icon) and member.Icon.r and member.Icon.g and member.Icon.b) then
							bKeypads.DermaMenuOption_Color(btn or option, member.Icon)
						elseif isstring(member.Icon) then
							(btn or option):SetIcon(member.Icon)
						elseif type(member.Icon) == "IMaterial" then
							(btn or option):SetMaterial(member.Icon)
						end
					end
					for id, addon in SortedPairsByMemberValue(bKeypads.CustomAccess.Addons.Registry, "Name") do
						addCustomAccessMember(menu, addon)
					end
				end

				local x,y = self:LocalToScreen(0, self:GetTall() - 1)
				menu:Open(x,y,nil,self)
			end

			local AccessBtnContainer = vgui.Create("DPanel", CPanel.AccessCategory)
			AccessBtnContainer:SetTall(25)
			AccessBtnContainer.Paint = nil
			AccessBtnContainer.PerformLayout = AccessBtnContainer_PerformLayout
			CPanel.AccessCategory:AddItem(AccessBtnContainer)

			AccessBtnContainer.WhitelistBtn = vgui.Create("DButton", AccessBtnContainer)
			AccessBtnContainer.WhitelistBtn:Dock(LEFT)
			AccessBtnContainer.WhitelistBtn:SetIcon("icon16/accept.png")
			AccessBtnContainer.WhitelistBtn:SetText(L"Whitelist")
			AccessBtnContainer.WhitelistBtn.bKeypads_Tooltip = L"WhitelistTip"
			AccessBtnContainer.WhitelistBtn.DoClick = AccessBtnClick
			AccessBtnContainer.WhitelistBtn.AccessType = bKeypads.ACCESS_TYPE.WHITELIST

			AccessBtnContainer.BlacklistBtn = vgui.Create("DButton", AccessBtnContainer)
			AccessBtnContainer.BlacklistBtn:Dock(RIGHT)
			AccessBtnContainer.BlacklistBtn:SetIcon("icon16/delete.png")
			AccessBtnContainer.BlacklistBtn:SetText(L"Blacklist")
			AccessBtnContainer.BlacklistBtn.bKeypads_Tooltip = L"BlacklistTip"
			AccessBtnContainer.BlacklistBtn.DoClick = AccessBtnClick
			AccessBtnContainer.BlacklistBtn.AccessType = bKeypads.ACCESS_TYPE.BLACKLIST

			local ClearBtn = vgui.Create("DButton", CPanel.AccessCategory)
			ClearBtn:SetTall(25)
			ClearBtn:SetIcon("icon16/bin.png")
			ClearBtn:SetText(L"Clear")
			ClearBtn.DoClick = function()
				surface.PlaySound("common/warning.wav")

				bKeypads.STOOL.BlockSpawnmenuClose = true
				Derma_Query(L"ClearAccessMatrixConfirm", L"Clear", L"Yes", function()
					surface.PlaySound("npc/roller/remote_yes.wav")
					bKeypads.STOOL.BlockSpawnmenuClose = false
					AccessTable:ResetAccessMatrix()
					AccessTable:Populate()
				end, L"No", function() bKeypads.STOOL.BlockSpawnmenuClose = false end)
			end
			CPanel.AccessCategory:AddItem(ClearBtn)

			function CPanel.AccessCategory:AuthModeChanged(authMode)
				local is_pin = authMode == bKeypads.AUTH_MODE.PIN

				PINField:GetParent():SetVisible(is_pin)
				ChargeUnauthorized:GetParent():SetVisible(not is_pin)
				PaymentBtn:GetParent():SetVisible(not is_pin)
				AccessTip:GetParent():SetVisible(not is_pin)
				AccessTable:GetParent():SetVisible(not is_pin)
				AccessBtnContainer.WhitelistBtn:GetParent():SetVisible(not is_pin)
				AccessBtnContainer.BlacklistBtn:GetParent():SetVisible(not is_pin)
				ClearBtn:GetParent():SetVisible(not is_pin)
				
				AccessTable:LoadAccessMatrix(authMode)

				CPanel:InvalidateChildren(true)
			end
			CPanel.AccessCategory:AuthModeChanged(bkeypads_auth_mode:GetInt())
		end
		
		CPanel:AddItem(CPanel.AccessCategory)

		--## BEHAVIOUR ##--

		CPanel.BehaviourCategory = vgui.Create("DForm", CPanel)
		CPanel.BehaviourCategory:SetLabel(L"Behaviour")

		local KeyBindersContainer = vgui.Create("DPanel", CPanel.BehaviourCategory)
		KeyBindersContainer:SetTall(75)
		KeyBindersContainer.Paint = nil

		do
			local ctrl = vgui.Create("CtrlNumPad", KeyBindersContainer)
			ctrl:Dock(FILL)
			ctrl:SetConVar1("bkeypads_granted_key")
			ctrl:SetConVar2("bkeypads_denied_key")
			ctrl:SetLabel1(L"AccessGrantedKey")
			ctrl:SetLabel2(L"AccessDeniedKey")

			CPanel.BehaviourCategory:AddItem(KeyBindersContainer)

			ctrl.NumPad1.bKeypads_Tooltip = L"AccessGrantedKeyTip" .. "\n" .. L"DBinderTip"
			ctrl.NumPad2.bKeypads_Tooltip = L"AccessDeniedKeyTip" .. "\n" .. L"DBinderTip"
			
			local AccessSettings = {"AccessGranted", "AccessDenied"}
			local AccessConVars = {"granted", "denied"}
			for i=1,2 do
				local AccessX = AccessSettings[i]
				local AccessConVar = AccessConVars[i]

				CPanel.BehaviourCategory[AccessX] = vgui.Create("DForm", CPanel.BehaviourCategory)
				CPanel.BehaviourCategory[AccessX]:SetLabel(L(AccessX))
				CPanel.BehaviourCategory[AccessX]:SetExpanded(i == 1)

				local AccessCategory = CPanel.BehaviourCategory[AccessX]

				AccessCategory.HoldLength = bKeypads:RecursiveTooltip(L"HoldLengthTip", AccessCategory:NumSlider(L"HoldLength", "bkeypads_" .. AccessConVar .. "_hold_time", bKeypads.Config.Scanning[AccessX].MinimumTime, bKeypads.Config.Scanning[AccessX].MaximumTime ~= 0 and bKeypads.Config.Scanning[AccessX].MaximumTime or 10, 2))
				AccessCategory.InitialDelay = bKeypads:RecursiveTooltip(L"InitialDelayTip", AccessCategory:NumSlider(L"InitialDelay", "bkeypads_" .. AccessConVar .. "_initial_delay", 0, 10, 2))
				AccessCategory.Repeats = bKeypads:RecursiveTooltip(L"RepeatsTip", AccessCategory:NumSlider(L"Repeats", "bkeypads_" .. AccessConVar .. "_repeats", 0, 10, 0))
				AccessCategory.RepeatDelay = bKeypads:RecursiveTooltip(L"RepeatDelayTip", AccessCategory:NumSlider(L"RepeatDelay", "bkeypads_" .. AccessConVar .. "_repeat_delay", 0.1, 10, 2))

				CPanel.BehaviourCategory:AddItem(AccessCategory)
			end
		end

		CPanel:AddItem(CPanel.BehaviourCategory)

		--## APPEARANCE ##--
		
		CPanel.AppearanceCategory = vgui.Create("DForm", CPanel)
		CPanel.AppearanceCategory:SetLabel(L"Appearance")
		CPanel.AppearanceCategory:SetExpanded(false)

			CPanel.AppearanceCategory.BackgroundColor = vgui.Create("DForm", CPanel.AppearanceCategory)
			CPanel.AppearanceCategory.BackgroundColor:SetLabel(L"BackgroundColor")
			CPanel.AppearanceCategory.BackgroundColor.Color = Color(255,255,255)

			CPanel.AppearanceCategory.BackgroundColor.Rainbow = CPanel.AppearanceCategory.BackgroundColor:CheckBox(L"RainbowBackground", "bkeypads_rainbow_background_color")
			CPanel.AppearanceCategory.BackgroundColor.Rainbow.Label.bkeypads_rainbow_background_color = GetConVar("bkeypads_rainbow_background_color")
			CPanel.AppearanceCategory.BackgroundColor.Rainbow.Label.Paint = RainbowLabelPaint

			do
				local BackgroundColor = vgui.Create("DPanel", CPanel.AppearanceCategory)
				CPanel.AppearanceCategory.BackgroundColor.ColorPicker = BackgroundColor
				BackgroundColor:SetTall(150)
				BackgroundColor.Paint = nil

					local RGBPicker = vgui.Create("DRGBPicker", BackgroundColor)
					RGBPicker:Dock(LEFT)
					RGBPicker:SetWide(30)
					RGBPicker:DockMargin(0, 0, 5, 0)

					local ColorCubeContainer = vgui.Create("DPanel", BackgroundColor)
					ColorCubeContainer.Paint = nil
					ColorCubeContainer:Dock(FILL)

						local ColorCube = vgui.Create("DColorCube", ColorCubeContainer)
						ColorCube:Dock(FILL)

						local Manual = vgui.Create("DPanel", ColorCubeContainer)
						Manual:Dock(BOTTOM)
						Manual:DockMargin(0, 5, 0, 0)
						Manual:SetTall(20)

							local r = vgui.Create("DTextEntry", Manual)
							r:SetNumeric(true)
							r:Dock(LEFT)
							r:SetWide(40)
							r:DockMargin(0, 0, 5, 0)

							local g = vgui.Create("DTextEntry", Manual)
							g:SetNumeric(true)
							g:Dock(LEFT)
							g:SetWide(40)
							g:DockMargin(0, 0, 5, 0)

							local b = vgui.Create("DTextEntry", Manual)
							b:SetNumeric(true)
							b:Dock(LEFT)
							b:SetWide(40)
							b:DockMargin(0, 0, 5, 0)

							local hex = vgui.Create("DTextEntry", Manual)
							hex:Dock(FILL)
							function hex:AllowInput(char)
								return (self:GetValue():sub(1, self:GetCaretPos()) .. char .. self:GetValue():sub(self:GetCaretPos() + 1)):match("^%#?%x?%x?%x?%x?%x?%x?$") == nil
							end

					local function UpdateColors(col)
						CPanel.AppearanceCategory.BackgroundColor.Color = col

						r:SetText(col.r)
						r.PrevText = r:GetText()

						g:SetText(col.g)
						g.PrevText = g:GetText()

						b:SetText(col.b)
						b.PrevText = b:GetText()

						hex:SetText("##" .. string.upper(bit.tohex(col.r, 2) .. bit.tohex(col.g, 2) .. bit.tohex(col.b, 2)))
						hex.PrevText = hex:GetText()

						bkeypads_background_color:SetInt(65536 * col.r + 256 * col.g + col.b)
					end

					function CPanel.AppearanceCategory.BackgroundColor:SetColors(col)
						ColorCube:SetColor(col)

						UpdateColors(col)

						local h = ColorToHSV(col)
						RGBPicker:SetRGB(HSVToColor(h, 1, 1))

						local _, height = RGBPicker:GetSize()
						RGBPicker.LastY = height*(1-(h/360))
					end

					function r:OnUserUpdate()
						local val = tonumber(self:GetValue())
						if val and val >= 0 and val <= 255 then
							CPanel.AppearanceCategory.BackgroundColor.Color.r = val
							CPanel.AppearanceCategory.BackgroundColor:SetColors(CPanel.AppearanceCategory.BackgroundColor.Color)
						else
							self:SetText(self.PrevText)
						end
					end

					function g:OnUserUpdate()
						local val = tonumber(self:GetValue())
						if val and val >= 0 and val <= 255 then
							CPanel.AppearanceCategory.BackgroundColor.Color.g = val
							CPanel.AppearanceCategory.BackgroundColor:SetColors(CPanel.AppearanceCategory.BackgroundColor.Color)
						else
							self:SetText(self.PrevText)
						end
					end

					function b:OnUserUpdate()
						local val = tonumber(self:GetValue())
						if val and val >= 0 and val <= 255 then
							CPanel.AppearanceCategory.BackgroundColor.Color.b = val
							CPanel.AppearanceCategory.BackgroundColor:SetColors(CPanel.AppearanceCategory.BackgroundColor.Color)
						else
							self:SetText(self.PrevText)
						end
					end

					function hex:OnUserUpdate()
						local val = tonumber(self:GetText():gsub("^%#+", ""), 16)
						if val then
							CPanel.AppearanceCategory.BackgroundColor:SetColors(bKeypads:IntToColor(val))
						else
							self:SetText(self.PrevText)
						end
					end

					for _, v in ipairs({r, g, b, hex}) do
						function v:OnFocusChanged(gained)
							if not gained then
								self:OnEnter()
							end
						end
						function v:OnEnter()
							self:OnUserUpdate()
						end
					end

					local RGBPicker_PerformLayout = RGBPicker.PerformLayout
					function RGBPicker:PerformLayout()
						CPanel.AppearanceCategory.BackgroundColor:SetColors(bKeypads:IntToColor(bkeypads_background_color:GetInt() or 0x0096FF))
						self.PerformLayout = RGBPicker_PerformLayout
						RGBPicker_PerformLayout = nil
					end
					
					function RGBPicker:OnChange(col)
						local h = ColorToHSV(col)
						local _, s, v = ColorToHSV(ColorCube:GetRGB())
						ColorCube:SetColor(HSVToColor(h, s, v))
						UpdateColors(col)
					end

					function ColorCube:OnUserChanged(col)
						UpdateColors(col)
					end

				CPanel.AppearanceCategory.BackgroundColor:AddItem(BackgroundColor)

				local reset = CPanel.AppearanceCategory.BackgroundColor:Button(L"Reset")
				CPanel.AppearanceCategory.BackgroundColor.ResetBtn = reset
				reset:SetIcon("icon16/arrow_refresh.png")
				function reset:DoClick()
					CPanel.AppearanceCategory.BackgroundColor:SetColors(Color(0,150,255))
				end
			end

			CPanel.AppearanceCategory:AddItem(CPanel.AppearanceCategory.BackgroundColor)

			CPanel.AppearanceCategory.LogoImage = vgui.Create("DForm", CPanel.AppearanceCategory)
			CPanel.AppearanceCategory.LogoImage:SetLabel(L"LogoImage")

			do
				local LogoImageContainer = vgui.Create("DPanel", CPanel.AppearanceCategory.LogoImage)
				LogoImageContainer:SetTall(128 + 10)
				LogoImageContainer.Paint = nil

				local LogoImageMaterial, CustomLogoImageMaterial

				local LogoImage = vgui.Create("DPanel", LogoImageContainer)
				LogoImage:SetSize(128 + 10, 128 + 10)
				function LogoImage:Paint(w,h)
					if CPanel.AppearanceCategory.BackgroundColor.Rainbow.Label.bkeypads_rainbow_background_color:GetBool() and bKeypads.Permissions:Cached(LocalPlayer(), "keypads/appearance/rainbows") then
						if bKeypads.Performance:Optimizing() then
							surface.SetDrawColor(bKeypads:Rainbow((((CurTime() + 1) / 4) % 2) * math.pi))
							surface.DrawRect(0, 0, w, h)
						else
							bKeypads:DrawRainbow(w, h)
						end
					else
						surface.SetDrawColor(CPanel.AppearanceCategory.BackgroundColor.Color)
						surface.DrawRect(0,0,w,h)
					end

					if CustomLogoImageMaterial and not bKeypads.KeypadImages.Bans:Check(LocalPlayer()) then
						surface.SetDrawColor(255,255,255)
						surface.SetMaterial(CustomLogoImageMaterial)
						surface.DrawTexturedRect(5, 5, 128, 128)
					elseif LogoImageMaterial then
						surface.SetDrawColor(bKeypads:DarkenForeground(CPanel.AppearanceCategory.BackgroundColor.Color) and bKeypads.COLOR.SLATE or bKeypads.COLOR.WHITE)
						surface.SetMaterial(LogoImageMaterial)
						surface.DrawTexturedRect(5, 5, 128, 128)
					end

					surface.SetDrawColor(0,0,0)
					surface.DrawOutlinedRect(0,0,w,h)
				end

				function LogoImageContainer:PerformLayout()
					LogoImage:Center()
				end

				CPanel.AppearanceCategory.LogoImage:AddItem(LogoImageContainer)

				local setlogo = CPanel.AppearanceCategory.LogoImage:Button(L"SetLogoImage")
				setlogo:SetIcon("icon16/picture.png")
				setlogo.DoClick = function()
					if bKeypads.KeypadImages.Bans:Check(LocalPlayer()) then
						Derma_Message(L"BannedFromFeature", L"Error", L"Dismiss")
						surface.PlaySound("buttons/button2.wav")
					else
						bKeypads.STOOL.BlockSpawnmenuClose = true
						bKeypads.KeypadImages:Open(function(selected, url, mat)
							bKeypads.STOOL.BlockSpawnmenuClose = false
							if selected then
								CustomLogoImageMaterial = mat
								bkeypads_image_url:SetString(url)
								CPanel.AppearanceCategory.RemoveLogo:SetDisabled(false)
							end
						end)
					end
				end

				CPanel.AppearanceCategory.RemoveLogo = CPanel.AppearanceCategory.LogoImage:Button(L"Remove")
				CPanel.AppearanceCategory.RemoveLogo:SetIcon("icon16/delete.png")
				CPanel.AppearanceCategory.RemoveLogo:SetDisabled(bkeypads_image_url:GetString() == "")
				CPanel.AppearanceCategory.RemoveLogo.DoClick = function()
					bkeypads_image_url:SetString("")
					CustomLogoImageMaterial = nil
					CPanel.AppearanceCategory.RemoveLogo:SetDisabled(true)
				end

				if bkeypads_image_url:GetString() ~= "" and bKeypads.KeypadImages:VerifyURL(bkeypads_image_url:GetString()) then
					bKeypads.KeypadImages:GetImage(bkeypads_image_url:GetString(), function(success, mat)
						if success then
							CustomLogoImageMaterial = mat
						end
					end, false, true)
				end

				function CPanel.AppearanceCategory:AuthModeChanged(authMode)
					LogoImageMaterial = Material(authMode == bKeypads.AUTH_MODE.FACEID and "bkeypads/face_id" or "bkeypads/keycard")
				end
				CPanel.AppearanceCategory:AuthModeChanged(bkeypads_auth_mode:GetInt())
			end

			CPanel.AppearanceCategory:AddItem(CPanel.AppearanceCategory.LogoImage)

		CPanel:AddItem(CPanel.AppearanceCategory)

		local padding = vgui.Create("DPanel", CPanel)
		padding:SetTall(0)
		padding.Paint = nil
		CPanel:AddItem(padding)
		
		CPanel.LoadSave.DoClick = function(self)
			bKeypads.STOOL.BlockSpawnmenuClose = true

			local _, line = CPanel.FileSelection:GetSelectedLine()
			Derma_Query((bKeypads.L("LoadSaveWarning")):format(line.Name), L"LoadSave", L"Yes", function()
				bKeypads.STOOL.BlockSpawnmenuClose = false
				
				self:SetDisabled(true)
				CPanel.DeleteSave:SetDisabled(true)
				CPanel.FileSelection:ClearSelection()

				local stool = file.Read("bkeypads/saved/" .. line.Name .. "_stool.json", "DATA")
				local access = file.Read("bkeypads/saved/" .. line.Name .. "_access.dat", "DATA")
				if not stool then Derma_Message(L"LoadSaveFailed" .. " [1]", L"LoadSave", L"Dismiss") return end
				if not access then Derma_Message(L"LoadSaveFailed" .. " [2]", L"LoadSave", L"Dismiss") return end

				stool = util.JSONToTable(stool)
				if not stool then Derma_Message(L"LoadSaveFailed" .. " [3]", L"LoadSave", L"Dismiss") return end

				local success, SavedAccessMatrix = xpcall(bKeypads.KeypadData.File.Deserialize, print_err_stack, bKeypads.KeypadData.File, file.Open("bkeypads/saved/" .. line.Name .. "_access.dat", "rb", "DATA"))
				if not success or not SavedAccessMatrix then Derma_Message(L"LoadSaveFailed" .. " [4]", L"LoadSave", L"Dismiss") return end

				local success = xpcall(function()
					for convar_name, val in pairs(stool) do
						local convar = GetConVar("bkeypads_" .. convar_name)
						if isnumber(val) then
							if val % 1 == 0 then
								convar:SetInt(val)
							else
								convar:SetFloat(val)
							end
						else
							convar:SetString(val)
						end
					end

					local authMode = bkeypads_auth_mode:GetInt()

					AccessTable.AccessMatrices[authMode] = SavedAccessMatrix

					CPanel.AccessCategory:AuthModeChanged(authMode)
					CPanel.AppearanceCategory:AuthModeChanged(authMode)

					if bkeypads_image_url:GetString() ~= "" and bKeypads.KeypadImages:VerifyURL(bkeypads_image_url:GetString()) then
						bKeypads.KeypadImages:GetImage(bkeypads_image_url:GetString(), function(success, mat)
							if success then
								CustomLogoImageMaterial = mat
							end
						end, false, true)
					end

					CPanel.AppearanceCategory.BackgroundColor:SetColors(bKeypads:IntToColor(bkeypads_background_color:GetInt() or 0x0096FF))
				end, print_err_stack)

				if not success then Derma_Message(L"LoadSaveFailed" .. " [5]", L"LoadSave", L"Dismiss") return end

			end, L"Cancel", function() bKeypads.STOOL.BlockSpawnmenuClose = false end)
		end

		CPanel.bKeypads_Think = CPanel.bKeypads_Think or CPanel.Think
		CPanel.Think = function()
			if CPanel.bKeypads_Think then
				CPanel.bKeypads_Think(CPanel)
			end

			local authMode = bkeypads_auth_mode:GetInt()

			-- Wiremod Checkbox
			local can_wiremod = WireLib ~= nil and bKeypads.Config.Wiremod.Enabled == true and bKeypads.Permissions:Cached(LocalPlayer(), "keypads/wiremod")
			if can_wiremod ~= WiremodCheckbox:IsVisible() then
				WiremodCheckbox:SetVisible(can_wiremod)
				WiremodCheckbox:InvalidateParent()
			end

			-- Uncrackable Checkbox
			local can_uncrackable = bKeypads.Permissions:Cached(LocalPlayer(), "keypads/uncrackable_keypads")
			if can_uncrackable ~= UncrackableCheckbox:IsVisible() then
				UncrackableCheckbox:SetVisible(can_uncrackable)
				UncrackableCheckbox:InvalidateParent()
			end

			-- Access Method Selectors
			local can_pin     = bKeypads.Config.Scanning.ScanMethods.EnablePIN and bKeypads.Permissions:Cached(LocalPlayer(), "access_methods/pin")
			local can_faceid  = bKeypads.Config.Scanning.ScanMethods.EnableFaceID and bKeypads.Permissions:Cached(LocalPlayer(), "access_methods/faceid")
			local can_keycard = bKeypads.Config.Scanning.ScanMethods.EnableKeycards and bKeypads.Permissions:Cached(LocalPlayer(), "access_methods/keycard")

			MethodBtnContainer.PIN:SetVisible(can_pin)
			MethodBtnContainer.FaceID:SetVisible(can_faceid)
			MethodBtnContainer.Keycard:SetVisible(can_keycard)

			if bkeypads_auth_mode:GetInt() == bKeypads.AUTH_MODE.PIN and not can_pin then
				bkeypads_auth_mode:SetInt(bKeypads.AUTH_MODE.FACEID)
			end
			if bkeypads_auth_mode:GetInt() == bKeypads.AUTH_MODE.FACEID and not can_faceid then
				bkeypads_auth_mode:SetInt(bKeypads.AUTH_MODE.KEYCARD)
			end
			if bkeypads_auth_mode:GetInt() == bKeypads.AUTH_MODE.KEYCARD and not can_keycard then
				bkeypads_auth_mode:SetInt(bKeypads.AUTH_MODE.PIN)
			end

			-- Appearance Category
			local can_change_appearance = authMode ~= bKeypads.AUTH_MODE.PIN
			local can_rainbow_bg = can_change_appearance and bKeypads.Permissions:Cached(LocalPlayer(), "keypads/appearance/rainbows")
			local can_change_bg  = (not can_rainbow_bg or not CPanel.AppearanceCategory.BackgroundColor.Rainbow.Label.bkeypads_rainbow_background_color:GetBool()) and can_change_appearance and bKeypads.Permissions:Cached(LocalPlayer(), "keypads/appearance/bg_color")
			local can_change_img = can_change_appearance and bKeypads.Config.Appearance.CustomImages.Enable and bKeypads.Permissions:Cached(LocalPlayer(), "keypads/appearance/custom_img")
			local show_bg_category = can_change_bg or can_rainbow_bg
			can_change_appearance = can_change_bg or can_rainbow_bg or can_change_img

			if can_change_appearance ~= CPanel.AppearanceCategory:IsVisible() then
				CPanel.AppearanceCategory:SetVisible(can_change_appearance)
				CPanel.AppearanceCategory:InvalidateParent()
			end
			if show_bg_category ~= CPanel.AppearanceCategory.BackgroundColor:IsVisible() then
				CPanel.AppearanceCategory.BackgroundColor:SetVisible(show_bg_category)
				CPanel.AppearanceCategory.BackgroundColor:InvalidateParent()
			end
			if show_bg_category then
				if can_change_bg ~= CPanel.AppearanceCategory.BackgroundColor.ColorPicker:IsVisible() then
					CPanel.AppearanceCategory.BackgroundColor.ColorPicker:SetVisible(can_change_bg)
					CPanel.AppearanceCategory.BackgroundColor.ColorPicker:InvalidateParent()
				end
				if can_change_bg ~= CPanel.AppearanceCategory.BackgroundColor.ResetBtn:IsVisible() then
					CPanel.AppearanceCategory.BackgroundColor.ResetBtn:SetVisible(can_change_bg)
					CPanel.AppearanceCategory.BackgroundColor.ResetBtn:InvalidateParent()
				end
				if can_rainbow_bg ~= CPanel.AppearanceCategory.BackgroundColor.Rainbow:IsVisible() then
					CPanel.AppearanceCategory.BackgroundColor.Rainbow:SetVisible(can_rainbow_bg)
					CPanel.AppearanceCategory.BackgroundColor.Rainbow:InvalidateParent()
				end
			end
			if can_change_img ~= CPanel.AppearanceCategory.LogoImage:IsVisible() then
				CPanel.AppearanceCategory.LogoImage:SetVisible(can_change_img)
				CPanel.AppearanceCategory.LogoImage:InvalidateParent()
			end
			if can_change_img then
				local img_banned = bKeypads.KeypadImages.Bans:Check(LocalPlayer())
				if img_banned == CPanel.AppearanceCategory.RemoveLogo:IsVisible() then
					CPanel.AppearanceCategory.RemoveLogo:SetVisible(not img_banned)
					CPanel.AppearanceCategory.RemoveLogo:InvalidateParent()
				end
			end

			-- Keyboard Button Simulation
			local can_simulate_keyboard_press = bKeypads.Config.EnableKeyboardPress and bKeypads.Permissions:Cached(LocalPlayer(), "keypads/keyboard_button_simulation")
			if can_simulate_keyboard_press ~= KeyBindersContainer:IsVisible() then
				KeyBindersContainer:SetVisible(can_simulate_keyboard_press)
				KeyBindersContainer:InvalidateParent()
			end

			-- No-collide, freeze
			local can_create_unfrozen_keypads = bKeypads.Permissions:Cached(LocalPlayer(), "keypads/unfrozen_keypads")
			if can_create_unfrozen_keypads ~= FreezeCheckbox:IsVisible() then
				FreezeCheckbox:SetVisible(can_create_unfrozen_keypads)
				FreezeCheckbox:InvalidateParent()
			end
			local can_create_collidable_keypads = bKeypads.Permissions:Cached(LocalPlayer(), "keypads/collidable_keypads")
			if can_create_collidable_keypads ~= NoCollideCheckbox:IsVisible() then
				NoCollideCheckbox:SetVisible(can_create_collidable_keypads)
				NoCollideCheckbox:InvalidateParent()
			end

			-- Payments
			local can_set_payment = bKeypads.Economy:HasCashSystem() and bKeypads.Config.Payments.Enable and bKeypads.Permissions:Cached(LocalPlayer(), "keypads/payments")
			if can_set_payment ~= ChargeUnauthorized:IsVisible() then
				ChargeUnauthorized:SetVisible(can_set_payment)
				ChargeUnauthorized:InvalidateParent()
			end
			if can_set_payment ~= PaymentBtn:IsVisible() then
				PaymentBtn:SetVisible(can_set_payment)
				PaymentBtn:InvalidateParent()
			end

			-- Notifications
			local can_access_granted_notification = bKeypads.Config.Notifications.Enable and bKeypads.Permissions:Cached(LocalPlayer(), "notifications/access_granted")
			local can_access_denied_notification  = bKeypads.Config.Notifications.Enable and bKeypads.Permissions:Cached(LocalPlayer(), "notifications/access_denied")
			local can_notify = can_access_granted_notification or can_access_denied_notification
			if can_notify ~= CPanel.NotificationsCategory:IsVisible() then
				CPanel.NotificationsCategory:SetVisible(can_notify)
				CPanel.NotificationsCategory:InvalidateParent()
			end
			if can_access_granted_notification ~= CPanel.NotificationsCategory.AccessGranted:IsVisible() then
				CPanel.NotificationsCategory.AccessGranted:SetVisible(can_access_granted_notification)
				CPanel.NotificationsCategory.AccessGranted:InvalidateParent()
			end
			if can_access_denied_notification ~= CPanel.NotificationsCategory.AccessDenied:IsVisible() then
				CPanel.NotificationsCategory.AccessDenied:SetVisible(can_access_denied_notification)
				CPanel.NotificationsCategory.AccessDenied:InvalidateParent()
			end

			-- Destruction
			local can_change_destruction = bKeypads.Config.KeypadDestruction.Enable and bKeypads.Permissions:Cached(LocalPlayer(), "destruction/indestructible") or bKeypads.Permissions:Cached(LocalPlayer(), "destruction/destructible")
			if can_change_destruction ~= CPanel.DestructionCategory:IsVisible() then
				CPanel.DestructionCategory:SetVisible(can_change_destruction)
				CPanel.DestructionCategory:InvalidateParent()
			end

			local can_change_destruction_values = bKeypads.Permissions:Cached(LocalPlayer(), "destruction/override_config")
			if can_change_destruction_values ~= CPanel.DestructionCategory.MaxHealth:IsVisible() then
				CPanel.DestructionCategory.MaxHealth:SetVisible(can_change_destruction_values)
				CPanel.DestructionCategory.MaxHealth:InvalidateParent()

				CPanel.DestructionCategory.Shield:SetVisible(can_change_destruction_values)
				CPanel.DestructionCategory.Shield:InvalidateParent()
			end

			if can_change_destruction_values then
				local indestructible
				if bKeypads.Config.KeypadDestruction.Enable then
					indestructible = CPanel.DestructionCategory.Indestructible:GetChecked()
				else
					indestructible = not CPanel.DestructionCategory.Destructible:GetChecked()
				end

				if CPanel.DestructionCategory.MaxHealth:GetDisabled() ~= indestructible then
					CPanel.DestructionCategory.MaxHealth:SetDisabled(indestructible)
				end
				if CPanel.DestructionCategory.Shield:GetDisabled() ~= indestructible then
					CPanel.DestructionCategory.Shield:SetDisabled(indestructible)
				end
			end

			if bKeypads.Config.KeypadDestruction.Enable ~= CPanel.DestructionCategory.Indestructible:IsVisible() then
				CPanel.DestructionCategory.Indestructible:SetVisible(bKeypads.Config.KeypadDestruction.Enable)
				CPanel.DestructionCategory.Indestructible:InvalidateParent()
			end
			if bKeypads.Config.KeypadDestruction.Enable ~= not CPanel.DestructionCategory.Destructible:IsVisible() then
				CPanel.DestructionCategory.Destructible:SetVisible(not bKeypads.Config.KeypadDestruction.Enable)
				CPanel.DestructionCategory.Destructible:InvalidateParent()
			end

			local can_mirror_keypads = bKeypads.Config.KeypadMirroring and bKeypads.Permissions:Cached(LocalPlayer(), "mirror_keypads")
			if can_mirror_keypads ~= MirrorPlacement:IsVisible() then
				MirrorPlacement:SetVisible(can_mirror_keypads)
				MirrorPlacement:InvalidateParent()
			end

			local can_see_auto_fading_door = not bKeypads.Config.KeypadOnlyFadingDoors or bKeypads.Permissions:Cached(LocalPlayer(), "keypads/bypass_keypad_only_fading_doors")
			if can_see_auto_fading_door ~= AutoFadingDoor:IsVisible() then
				AutoFadingDoor:SetVisible(can_see_auto_fading_door)
				AutoFadingDoor:InvalidateParent()
			end
			
			local can_create_unwelded_keypads = can_see_auto_fading_door and bKeypads.Permissions:Cached(LocalPlayer(), "keypads/unwelded_keypads")
			if can_create_unwelded_keypads ~= WeldCheckbox:IsVisible() then
				WeldCheckbox:SetVisible(can_create_unwelded_keypads)
				WeldCheckbox:InvalidateParent()
			end

			local showConfigurationCategory = can_create_unfrozen_keypads or can_create_unwelded_keypads or can_create_collidable_keypads or WiremodCheckbox:IsVisible()
			if showConfigurationCategory ~= CPanel.ConfigCategory:IsVisible() then
				CPanel.ConfigCategory:SetVisible(showConfigurationCategory)
				CPanel.ConfigCategory:InvalidateParent()
			end
		end

		hook.Run("bKeypads.BuildCPanel", CPanel)
	end

	do
		local initialAccessMatrices = {}
		net.Receive("bKeypads.KeypadData.Fetch", function()
			local token = net.ReadUInt(16)
			
			if IsValid(bKeypads.AccessTable) and bKeypads.AccessTable:GetAccessMatrix() then
				net.Start("bKeypads.KeypadData.Push")
					net.WriteUInt(token, 16)
					bKeypads.KeypadData.Net:Serialize(bKeypads.AccessTable:GetAccessMatrix())
				net.SendToServer()
			else
				local authMode = GetConVar("bkeypads_auth_mode"):GetInt()
				if not initialAccessMatrices[authMode] then
					if file.Exists("bkeypads/stool/access_matrix_" .. authMode .. ".dat", "DATA") then
						local success, SavedAccessMatrix = pcall(bKeypads.KeypadData.File.Deserialize, bKeypads.KeypadData.File, file.Open("bkeypads/stool/access_matrix_" .. authMode .. ".dat", "rb", "DATA")) --true, bKeypads.KeypadData.File:Deserialize(bKeypads.KeypadData.File:Open("bkeypads/stool_access_matrices.dat", false, "DATA", true)) --
						if success and SavedAccessMatrix then
							initialAccessMatrices[authMode] = SavedAccessMatrix
						else
							file.Delete("bkeypads/stool/access_matrix_" .. authMode .. ".dat")
							initialAccessMatrices[authMode] = bKeypads.KeypadData:AccessMatrix()
						end
					else
						initialAccessMatrices[authMode] = bKeypads.KeypadData:AccessMatrix()
					end
				end
				
				net.Start("bKeypads.KeypadData.Push")
					net.WriteUInt(token, 16)
					bKeypads.KeypadData.Net:Serialize(initialAccessMatrices[authMode])
				net.SendToServer()
			end
		end)
	end

	local function KeypadAccessMatrixCopy()
		local CPanel
		if not IsValid(bKeypads.AccessTable) then
			CPanel = controlpanel.Get("bkeypads")
			bKeypads.STOOL.BuildCPanel(CPanel)
			CPanel:SetVisible(false)
			
			if not IsValid(bKeypads.AccessTable) then
				controlpanel.Clear("bkeypads")
				return
			end
		end

		local bkeypads_auth_mode = GetConVar("bkeypads_auth_mode")

		local accessMatrix = bKeypads.KeypadData.Net:Deserialize()
		local authMode = net.ReadUInt(4)

		bKeypads.AccessTable.AccessMatrices[authMode] = table.Copy(accessMatrix)
		bKeypads.AccessTable:SaveAccessMatrix()

		bkeypads_auth_mode:SetInt(0)
		bkeypads_auth_mode:SetInt(authMode)

		surface.PlaySound("garrysmod/content_downloaded.wav")
		notification.AddLegacy(L"KeypadAccessMatrixCopied", NOTIFY_GENERIC, 2)

		if CPanel then controlpanel.Clear("bkeypads") end
	end
	local function KeypadAccessMatrixCopyError(err)
		surface.PlaySound("buttons/button2.wav")
		notification.AddLegacy(L"KeypadAccessMatrixCopyError", NOTIFY_ERROR, 5)

		ErrorNoHalt("ERROR: " .. err .. "\n")
		debug.Trace()
	end
	net.Receive("bKeypads.KeypadAccessMatrix.Copy", function()
		notification.Kill("KeypadAccessMatrixCopying")
		xpcall(KeypadAccessMatrixCopy, KeypadAccessMatrixCopyError)
	end)
end
--addons/bkeypads/lua/bkeypads/cl_keycard_textures.lua:
if IsValid(bKeypads_Keycards_TextureSkeleton) then
	bKeypads_Keycards_TextureSkeleton:Remove()
end

bKeypads.Keycards.Textures = {}

bKeypads.Keycards.Textures.KeycardImage = {}

bKeypads.Keycards.Textures.TOP    = 1
bKeypads.Keycards.Textures.BOTTOM = 2
bKeypads.Keycards.Textures.BOTH   = bit.bor(bKeypads.Keycards.Textures.TOP, bKeypads.Keycards.Textures.BOTTOM)

function bKeypads.Keycards.Textures:Apply(keycard, orientation, keycardHash)
	if not keycard.m_KeycardTextures then
		keycard.m_KeycardTextures = {}
	end
	if keycard.m_KeycardTextures[orientation] ~= keycardHash then
		keycard.m_KeycardTextures[orientation] = keycardHash

		-- FIXME https://github.com/Facepunch/garrysmod-issues/issues/3362
		if keycard:EntIndex() == -1 then
			keycard:SetSubMaterial(orientation, nil)
			keycard:SetSubMaterial(orientation, "!bKeypads_Keycard_" .. keycardHash .. "_" .. orientation)
		else
			timer.Simple(1, function() bKeypads:nextTick(function()
				if not IsValid(keycard) then return end
				keycard:SetSubMaterial(orientation, nil)
				keycard:SetSubMaterial(orientation, "!bKeypads_Keycard_" .. keycardHash .. "_" .. orientation)
			end) end)
		end
	end
end

local scale = .01
local magstripeHeight = 0.69
local keycardPad = 0.13
local _keycardPad = math.floor(keycardPad / scale)

do
	local keycardMins, keycardMaxs = Vector(-2.573145, -1.541140, -0.028437), Vector(2.573145, 1.541140, 0.028437)
	
	local keycardW = math.floor((keycardMaxs.x - keycardMins.x) / scale)
	local keycardH = math.floor((keycardMaxs.y - keycardMins.y - magstripeHeight) / scale)

	function bKeypads.Keycards.Textures:GetDimensions(mins, maxs)
		if mins and maxs then
			return math.floor((maxs.x - mins.x) / scale),
			       math.floor((maxs.y - mins.y - magstripeHeight) / scale)
		else
			return keycardW, keycardH
		end
	end

	bKeypads.Keycards.Textures.DimensionsDirty = true
	function bKeypads.Keycards.Textures:UpdateDimensions(mins, maxs)
		keycardW = math.floor((maxs.x - mins.x) / scale)
		keycardH = math.floor((maxs.y - mins.y - magstripeHeight) / scale)
		bKeypads.Keycards.Textures.DimensionsDirty = nil
	end
end

do
	local function BlackBackgroundPaint(self, w, h)
		surface.SetDrawColor(0, 0, 0)
		surface.DrawRect(0, 0, w, h)
	end
	local function ImageContainerPaint(self, w, h)
		surface.SetDrawColor(bKeypads.Config.Keycards.KeycardImage.BackgroundColor)
		surface.DrawRect(0, 0, w, h)
	end
	local function Identification_PerformLayout(self, w, h)
		self.Model:SetSize(w, w)
		self.ImageContainer:SetSize(w, w)
		self.ImageContainer:AlignBottom(0)
	end
	local function LevelsPaint(self, w, h)
		surface.SetTextColor(255, 255, 255)
		local levelBoxSize = (h - _keycardPad) / 2
		for i = 1, math.min(#self.m_Levels, 11) do
			local level = self.m_Levels[i]

			local x
			if self:GetParent():GetParent().Orientation == bKeypads.Keycards.Textures.TOP then
				x = ((i - 1) % 6) * (levelBoxSize + _keycardPad)
			else
				x = w - levelBoxSize - (((i - 1) % 6) * (levelBoxSize + _keycardPad))
			end

			local y = (math.floor(i / 7) * (levelBoxSize + _keycardPad)) + (#self.m_Levels < 6 and (h - levelBoxSize) or 0)

			surface.SetDrawColor(0,0,0,200)
			surface.DrawRect(x, y, levelBoxSize, levelBoxSize)

			surface.SetDrawColor((bKeypads.Keycards.Levels[level] or bKeypads.Keycards.Levels[1]).Color or bKeypads.Keycards.Levels[1].Color)
			surface.DrawOutlinedRect(x, y, levelBoxSize, levelBoxSize, 2)

			surface.SetFont(level <= 9 and "bKeypads.Keycards.3D2D.Levels.1" or "bKeypads.Keycards.3D2D.Levels.2")
			local txtW, txtH = surface.GetTextSize(tostring(level))
			surface.SetTextPos(x + ((levelBoxSize - txtW) / 2), y + ((levelBoxSize - txtH) / 2))
			surface.DrawText(level)
		end
	end
	local function Get3D2DPanel()
		if not IsValid(bKeypads_Keycards_TextureSkeleton) then
			bKeypads_Keycards_TextureSkeleton = vgui.Create("DPanel")

			local skeleton = bKeypads_Keycards_TextureSkeleton
			skeleton.Paint = nil
			skeleton:SetPaintedManually(true)
			skeleton:SetRenderInScreenshots(false)
			skeleton:DockPadding(_keycardPad, _keycardPad, _keycardPad, _keycardPad)

				skeleton.Content = vgui.Create("DPanel", skeleton)
				skeleton.Content.Paint = nil
				skeleton.Content:Dock(FILL)

					skeleton.Level = vgui.Create("DLabel", skeleton.Content)
					skeleton.Level:Dock(TOP)
					skeleton.Level:SetFont("bKeypads.Keycards.3D2D.Level")

					skeleton.Team = vgui.Create("DLabel", skeleton.Content)
					skeleton.Team:Dock(TOP)
					skeleton.Team:SetFont("bKeypads.Keycards.3D2D.Team")

					skeleton.Levels = vgui.Create("DPanel", skeleton.Content)
					skeleton.Levels:Dock(BOTTOM)
					skeleton.Levels:DockMargin(0, _keycardPad, 0, 0)
					skeleton.Levels.Paint = LevelsPaint

				skeleton.Identification = vgui.Create("DPanel", skeleton)
				skeleton.Identification.Paint = nil
				skeleton.Identification.PerformLayout = Identification_PerformLayout

					skeleton.Identification.Model = vgui.Create("SpawnIcon", skeleton.Identification)
					skeleton.Identification.Model.PaintOver = skeleton.Identification.Model.Paint
					skeleton.Identification.Model.Paint = BlackBackgroundPaint

					skeleton.Identification.ImageContainer = vgui.Create("DPanel", skeleton.Identification)
					skeleton.Identification.ImageContainer.Paint = ImageContainerPaint

					skeleton.Identification.Image = vgui.Create("DImage", skeleton.Identification.ImageContainer)
					skeleton.Identification.Image:Dock(FILL)
					skeleton.Identification.Image:SetVisible(false)

					skeleton.Identification.Avatar = vgui.Create("AvatarImage", skeleton.Identification.ImageContainer)
					skeleton.Identification.Avatar:Dock(FILL)
					skeleton.Identification.Avatar:SetVisible(false)
		end
		
		return bKeypads_Keycards_TextureSkeleton
	end

	-- Track each keycard's materials and enforce their $basetexture to be the correct RT
	local RT_ID_Materials = {}

	-- ID of any new RTs	
	local RT_Pool_Count = 0

	-- Reserved RTs - these are being used for the next draw operation
	local RT_Pool_Reservations = {}
	
	-- Spare RTs
	local RT_Pool_Available = {}

	local keycardBaseTexture = CreateMaterial("bKeypads.Keycards.Textures.BaseTexture", "UnlitGeneric", {
		["$basetexture"] = "models/bkeypads/keycard_identification",
		["$surfaceprop"] = "Plastic",
		["$blendtintbybasealpha"] = 1,
		["$blendtintcoloroverbase"] = 0
	})

	local RT_Queue_FrameBudget = 3
	local RT_RotationMatrix = Matrix()
	local RT_RotationMatrixTranslate = Vector()
	RT_RotationMatrix:SetAngles(Angle(0, -90, 0))

	local RT_Queue = {}

	local RT_QUEUE_TEXTURE_ID  = 1
	local RT_QUEUE_ORIENTATION = 2
	local RT_QUEUE_KEYCARD     = 3
	local RT_QUEUE_FRAME       = 4

	local function RT_Queue_Render()
		if not bKeypads.Keycards.Textures.KeycardImage.Loaded then return end

		local RT_ID, data
		while not RT_ID do
			RT_ID, data = next(RT_Queue)
			if not RT_ID then return end

			if IsValid(data[RT_QUEUE_KEYCARD]) then
				-- Increment frame number
				data[RT_QUEUE_FRAME] = data[RT_QUEUE_FRAME] + 1

				-- If we've rendered the needed frames, remove from the queue
				if data[RT_QUEUE_FRAME] == RT_Queue_FrameBudget then
					RT_Queue[RT_ID] = nil
				end
			else
				-- keycard is gone, remove from the queue
				RT_Queue[RT_ID] = nil
				RT_ID = nil
			end
		end

		local textureID, orientation, keycard = unpack(data)

		local keycardW, keycardH = bKeypads.Keycards.Textures:GetDimensions()
		local RT = GetRenderTargetEx("bKeypads_KeycardRT_" .. RT_ID, keycardH, keycardW, RT_SIZE_NO_CHANGE, MATERIAL_RT_DEPTH_NONE, 32768, CREATERENDERTARGETFLAGS_HDR, IMAGE_FORMAT_DEFAULT)

		RT_RotationMatrixTranslate.y = keycardW
		RT_RotationMatrix:SetTranslation(RT_RotationMatrixTranslate)

		render.PushRenderTarget(RT, 0, 0, keycardH, keycardW)
		cam.Start2D()
			render.PushFilterMag(TEXFILTER.ANISOTROPIC)
			render.PushFilterMin(TEXFILTER.ANISOTROPIC)

			cam.PushModelMatrix(RT_RotationMatrix)

			keycardBaseTexture:SetVector("$color2", keycard:GetKeycardColor():ToVector())
			keycardBaseTexture:Recompute()
			surface.SetDrawColor(255, 255, 255)
			surface.SetMaterial(keycardBaseTexture)
			surface.DrawTexturedRect(0, 0, ScrH(), ScrW())

			local skeleton = Get3D2DPanel()

			skeleton:SetPos(0, 0)
			skeleton:SetSize(ScrH(), ScrW())

			skeleton.Orientation = orientation
			skeleton.TextColor = bKeypads:GetLuminance(keycard:GetKeycardColor()) > 0.65 and bKeypads.COLOR.BLACK or bKeypads.COLOR.WHITE

			if orientation == bKeypads.Keycards.Textures.TOP then
				skeleton.Identification:Dock(LEFT)
				skeleton.Content:DockPadding(_keycardPad, 0, 0, 0)
				skeleton.Level:SetContentAlignment(7)
				skeleton.Team:SetContentAlignment(7)
			else
				skeleton.Identification:Dock(RIGHT)
				skeleton.Content:DockPadding(0, 0, _keycardPad, 0)
				skeleton.Level:SetContentAlignment(9)
				skeleton.Team:SetContentAlignment(9)
			end
			skeleton.Levels:SetTall((keycardH - _keycardPad - _keycardPad - _keycardPad) / 2)
			skeleton.Identification:SetWide((keycardH - _keycardPad - _keycardPad - _keycardPad) / 2)
			
			local levels = keycard:GetLevels()
			if levels then
				skeleton.Level:SetText(keycard:GetKeycardName())
				skeleton.Level:SetTextColor(skeleton.TextColor)
				skeleton.Level:SizeToContentsY()
				skeleton.Level:SetVisible(true)

				if levels and #levels > 1 then
					skeleton.Levels.m_Levels = levels
					skeleton.Levels:SetVisible(true)
				else
					skeleton.Levels:SetVisible(false)
				end
			else
				skeleton.Level:SetVisible(false)
			end

			local teamIndex = keycard:GetTeam() ~= 0 and keycard:GetTeam() or nil
			if teamIndex then
				skeleton.Team:SetText(IsValid(keycard:GetOwner()) and DarkRP and bKeypads.Config.Keycards.ShowCustomJobName and keycard:GetOwner().getDarkRPVar and keycard:GetOwner():getDarkRPVar("job") or team.GetName(teamIndex))
				skeleton.Team:SizeToContentsY()
				skeleton.Team:SetTextColor(skeleton.TextColor)
				skeleton.Team:SetVisible(true)
			else
				skeleton.Team:SetVisible(false)
			end

			local model = keycard:GetPlayerModel() ~= "" and keycard:GetPlayerModel() or "models/player/kleiner.mdl"
			if skeleton.Identification.Model.Model ~= model then
				skeleton.Identification.Model:SetModel(model)
				skeleton.Identification.Model.Model = model
			end

			local steamid = keycard:GetSteamID()
			local showImg = bKeypads.Keycards.Textures.KeycardImage.PrimaryImage
			if showImg == "AVATAR" and (not steamid or #steamid == 0) then
				showImg = bKeypads.Keycards.Textures.KeycardImage.SecondaryImage
			end

			if showImg == "AVATAR" then
				if skeleton.Identification.Avatar.SteamID ~= steamid then
					skeleton.Identification.Avatar.SteamID = steamid
					skeleton.Identification.Avatar:SetSteamID(util.SteamIDTo64(steamid), 184)
				end
				skeleton.Identification.ImageContainer:DockPadding(0, 0, 0, 0)
				skeleton.Identification.Avatar:SetVisible(true)
				skeleton.Identification.Image:SetVisible(false)
			else
				if skeleton.Identification.Image:GetMaterial() ~= showImg then
					skeleton.Identification.Image:SetMaterial(showImg)
				end
				skeleton.Identification.ImageContainer:DockPadding(10, 10, 10, 10)
				skeleton.Identification.Avatar:SetVisible(false)
				skeleton.Identification.Image:SetVisible(true)
			end

			skeleton:InvalidateChildren(true)
			skeleton:PaintManual()

			cam.PopModelMatrix()

			render.PopFilterMag()
			render.PopFilterMin()
		cam.End2D()
		render.PopRenderTarget()
		
		if not RT_ID_Materials[RT_ID][textureID] then
			RT_ID_Materials[RT_ID][textureID] = true

			local mat = Material("!bKeypads_Keycard_" .. textureID)
			mat:SetTexture("$basetexture", "bKeypads_KeycardRT_" .. RT_ID)
			mat:Recompute()
		end
	end
	
	local createdKeycardMaterials = {}
	local keycardMaterialData = { ["$surfaceprop"] = "Plastic" }
	function bKeypads.Keycards.Textures:Queue(orientation, dataKeycard, keycard, keycardHash, RT_ID)
		if bKeypads.Keycards.Textures.DimensionsDirty and keycard:GetModelScale() == 1 then
			bKeypads.Keycards.Textures:UpdateDimensions(keycard:GetModelBounds())
		end

		local textureID = keycardHash .. "_" .. orientation
		if not createdKeycardMaterials[textureID] then
			createdKeycardMaterials[textureID] = CreateMaterial("bKeypads_Keycard_" .. textureID, "VertexLitGeneric", keycardMaterialData)
		end

		if not RT_Queue[RT_ID] then
			RT_Queue[RT_ID] = { textureID, orientation, dataKeycard or keycard, 0 }
		elseif RT_Queue[RT_ID][RT_QUEUE_TEXTURE_ID] ~= textureID then
			RT_Queue[RT_ID][RT_QUEUE_TEXTURE_ID] = textureID
			RT_Queue[RT_ID][RT_QUEUE_ORIENTATION] = orientation
			RT_Queue[RT_ID][RT_QUEUE_KEYCARD] = dataKeycard or keycard
			RT_Queue[RT_ID][RT_QUEUE_FRAME] = 0
		end
	end
	
	local ReserveAvailableRT = {}
	local function ClearRTReservations()
		RT_Queue_Render()

		for textureID in pairs(ReserveAvailableRT) do
			local key, RT_ID = next(RT_Pool_Available)
			if key then
				-- There's a spare RT, let's reserve it
				RT_Pool_Reservations[textureID] = RT_ID
				RT_Pool_Available[key] = nil
				RT_ID_Materials[RT_ID] = {}
			else
				-- No spare RTs, let's create a new one
				RT_Pool_Count = RT_Pool_Count + 1

				RT_Pool_Reservations[textureID] = RT_Pool_Count
				RT_ID_Materials[RT_Pool_Count] = {}
			end

			ReserveAvailableRT[textureID] = nil
		end

		-- New frame, clear any reservations
		table.Merge(RT_Pool_Available, RT_Pool_Reservations)
		RT_Pool_Reservations = {}
	end
	bKeypads:InitPostEntity(function()
		timer.Simple(bKeypads_Keycard_Textures_Delayed and 0 or 10, function()
			bKeypads_Keycard_Textures_Delayed = true
			hook.Add("PreRender", "bKeypads.Keycards.Textures.ClearRTReservations", ClearRTReservations) ClearRTReservations()
		end)
	end)

	local function ReserveRT(orientation, keycard, dataKeycard)
		local keycardHash = (dataKeycard or keycard):GetHash()
		local textureID = keycardHash .. "_" .. orientation

		if ReserveAvailableRT[textureID] then
			if keycard.m_KeycardTextures then
				keycard:SetSubMaterial()
				keycard.m_KeycardTextures = nil
			end
			return
		end

		local RT_ID = RT_Pool_Reservations[textureID]
		if not RT_ID then
			RT_ID = RT_Pool_Available[textureID]
			if RT_ID then
				-- We were using this RT in the last frame, let's reserve it again
				RT_Pool_Available[textureID] = nil
				RT_Pool_Reservations[textureID] = RT_ID
			else
				-- Reserve an available RT after this frame
				ReserveAvailableRT[textureID] = true
				if keycard.m_KeycardTextures then
					keycard:SetSubMaterial()
					keycard.m_KeycardTextures = nil
				end
				return
			end
		end

		if not RT_ID_Materials[RT_ID][textureID] then
			bKeypads.Keycards.Textures:Queue(orientation, dataKeycard, keycard, keycardHash, RT_ID)
		end
		bKeypads.Keycards.Textures:Apply(keycard, orientation, keycardHash)
	end
	
	function bKeypads.Keycards.Textures:Draw(orientations, keycard, dataKeycard)
		if bKeypads.Settings:Get("optimizations_disable_keycard_textures") then return end
		if bit.band(orientations, bKeypads.Keycards.Textures.TOP) ~= 0 then
			ReserveRT(bKeypads.Keycards.Textures.TOP, keycard, dataKeycard)
		end
		if bit.band(orientations, bKeypads.Keycards.Textures.BOTTOM) ~= 0 then
			ReserveRT(bKeypads.Keycards.Textures.BOTTOM, keycard, dataKeycard)
		end
	end

	function bKeypads.Keycards.Textures:Reset()
		RT_ID_Materials = {}
		RT_Pool_Reservations = {}
		RT_Pool_Available = {}
		RT_Queue = {}

		for _, ent in ipairs(ents.GetAll()) do
			if ent.bKeycard then
				ent:SetSubMaterial(bKeypads.Keycards.Textures.TOP, nil)
				ent:SetSubMaterial(bKeypads.Keycards.Textures.BOTTOM, nil)
			end
		end
	end
end

-- Stupid hack to precache AvatarImage
bKeypads_Keycards_Textures_CacheAvatarImage = bKeypads_Keycards_Textures_CacheAvatarImage or {}
local precache_id = 0
local function PrecacheAvatarImage(ply)
	if not IsValid(ply) or ply:IsBot() or bKeypads_Keycards_Textures_CacheAvatarImage[ply] ~= nil then return end

	local id = precache_id
	precache_id = precache_id + 1

	local function precache()
		if IsValid(ply) then
			if not ply:SteamID64() then return end

			bKeypads_Keycards_Textures_CacheAvatarImage[ply] = os.time()

			local AvatarImage = vgui.Create("AvatarImage")
			AvatarImage:SetSteamID(ply:SteamID64(), 184)
			AvatarImage:SetSize(1, 1)
			AvatarImage:SetPos(-2, -2)
			AvatarImage.PaintOver = function(self) self:Remove() end
		end

		timer.Remove("bKeypads.PrecacheAvatarImage:" .. id)
	end

	timer.Create("bKeypads.PrecacheAvatarImage:" .. id, 1, 0, precache)
	precache()
end
hook.Add("PlayerInitialSpawn", "bKeypads.Keycards.3D2D.CacheAvatarImage", PrecacheAvatarImage)
bKeypads:InitPostEntity(function()
	timer.Create("bKeypads.PrecacheAvatarImage", 1, 0, function()
		local test = vgui.Create("AvatarImage")
		if not IsValid(test) then return end
		test:Remove()

		timer.Remove("bKeypads.PrecacheAvatarImage")

		PrecacheAvatarImage(LocalPlayer())
		for _, ply in ipairs(player.GetHumans()) do
			PrecacheAvatarImage(ply)
		end
	end)
end)

local function GetKeycardImage(_imageChoice, callback)
	local imageChoice = _imageChoice:lower():Trim()
	if imageChoice == "avatar" then
		callback("AVATAR")
		return
	end

	local img = Material("bkeypads/keycard.png", "smooth")

	if imageChoice ~= "keycard" then
		if imageChoice == "scp" then
			img = Material("bkeypads/scp.png", "smooth")

		elseif imageChoice:match("^https?://.-$") then

			bKeypads:print("Loading from: " .. _imageChoice, bKeypads.PRINT_TYPE_INFO, "KeycardImage")
			http.Fetch(_imageChoice, function(body, size, headers, code)
				if size > 0 and code >= 200 and code < 300 then
					file.Write("bkeypads/KeycardImage.png", body)
					local customMat = Material("../data/bkeypads/KeycardImage.png", "smooth")
					if customMat and not customMat:IsError() then
						img = customMat
						bKeypads:print("Loaded successfully", bKeypads.PRINT_TYPE_GOOD, "KeycardImage")
					else
						bKeypads:print("Could not load: " .. _imageChoice, bKeypads.PRINT_TYPE_WARN, "KeycardImage")
						bKeypads:print("Gmod was unable to convert the response into a valid texture", bKeypads.PRINT_TYPE_WARN, "KeycardImage")
					end
				else
					bKeypads:print("Could not load: " .. _imageChoice, bKeypads.PRINT_TYPE_WARN, "KeycardImage")
					bKeypads:print("HTTP " .. code, bKeypads.PRINT_TYPE_WARN, "KeycardImage")
				end
				bKeypads:print("Response: " .. string.NiceSize(size), bKeypads.PRINT_TYPE_GOOD, "KeycardImage")

				callback(img)
			end, function(err)
				bKeypads:print("Could not load: " .. _imageChoice, bKeypads.PRINT_TYPE_WARN, "KeycardImage")
				bKeypads:print("\"" .. err .. "\"", bKeypads.PRINT_TYPE_WARN, "KeycardImage")

				callback(img)
			end)
			return

		elseif isstring(imageChoice) and #imageChoice > 0 then

			local customMat = Material(_imageChoice, "smooth")
			if customMat and not customMat:IsError() then
				img = customMat
			else
				bKeypads:print("Could not load material: \"materials/" .. _imageChoice .. "\"", bKeypads.PRINT_TYPE_WARN, "KeycardImage")
			end

		end
	end

	callback(img)
end

local function CacheKeycardImage()
	bKeypads.Keycards.Textures.KeycardImage.Loaded = false

	local primary = bKeypads.Config.Keycards.KeycardImage.Image
	local backup = bKeypads.Config.Keycards.KeycardImage.Backup:lower():Trim() == "avatar" and "keycard" or bKeypads.Config.Keycards.KeycardImage.Backup

	GetKeycardImage(primary, function(img)
		bKeypads.Keycards.Textures.KeycardImage.PrimaryImage = img
		
		if backup == primary then
			bKeypads.Keycards.Textures.KeycardImage.SecondaryImage = img
			bKeypads.Keycards.Textures.KeycardImage.Loaded = true
		else
			GetKeycardImage(backup, function(img)
				bKeypads.Keycards.Textures.KeycardImage.SecondaryImage = img
				bKeypads.Keycards.Textures.KeycardImage.Loaded = true
			end)
		end
	end)
end
hook.Add("bKeypads.ConfigUpdated", "bKeypads.Keycards.3D2D.KeycardImage", CacheKeycardImage)
CacheKeycardImage()
--addons/bkeypads/lua/bkeypads/cl_tutorial.lua:
local L = bKeypads.L

local developer = GetConVar("developer")
local gmod_language

if bKeypads.Tutorial and IsValid(bKeypads.Tutorial.Menu) then
	bKeypads.Tutorial.Menu:Close()
end

bKeypads.Tutorial = {}

--## CONSTANTS ##--

local GRADIENT = Material("bkeypads/darken_gradient.png")
local GRADIENT_LIGHT = Material("bkeypads/darken_gradient_light.png")
local GRADIENT_LARGE = Material("bkeypads/darken_gradient_large.png")
local GRADIENT_LIGHT_LARGE = Material("bkeypads/darken_gradient_light_large.png")

local playerModels = {
	"models/player/Group01/Female_01.mdl",
	"models/player/Group01/Female_02.mdl",
	"models/player/Group01/Female_03.mdl",
	"models/player/Group01/Female_04.mdl",
	"models/player/Group01/Female_06.mdl",
	"models/player/group01/male_01.mdl",
	"models/player/Group01/Male_02.mdl",
	"models/player/Group01/male_03.mdl",
	"models/player/Group01/Male_04.mdl",
	"models/player/Group01/Male_05.mdl",
	"models/player/Group01/Male_06.mdl",
	"models/player/Group01/Male_07.mdl",
	"models/player/Group01/Male_08.mdl",
	"models/player/Group01/Male_09.mdl"
}

local matToolgunTrace = Material("effects/tool_tracer")

local DRAW_MODEL_BITMASK_BOTH_1 = bit.bor(STUDIO_TWOPASS, STUDIO_RENDER)
local DRAW_MODEL_BITMASK_BOTH_2 = bit.bor(STUDIO_TWOPASS, STUDIO_RENDER, STUDIO_TRANSPARENCY)

--## SCENE DATA ##--

local activeScene
local activeFrame
local sceneStart
local sceneFrame
local sceneFrameStart
local sceneFrameMasterSequence
local sceneFrameTimeDelta
local sceneFramePrevFrameTimestamp
local sceneFrameObjects
local sceneFrameCaptionOverride
local sceneAdvanceFrame
local sceneCenter
local sceneTransitioning
local circleCamLastFrame
local circleCamLag

bKeypads.Tutorial.Shortcuts = {}
hook.Add("bKeypads.TutorialScenes", "bKeypads.Tutorial.Shortcuts", function()
	for _, category in ipairs(bKeypads.Tutorial.Categories) do
		if not category.Scenes then continue end
		for _, scene in ipairs(category.Scenes) do
			if istable(scene) and scene.Shortcut then
				bKeypads.Tutorial.Shortcuts[scene.Shortcut] = scene
			end
		end
	end
end)

local function InterpolateLanguageStrings(str, second_pass)
	local i = 1
	while true do
		local startPos, endPos = str:find("%%.-%%", i)
		if not startPos then break end
		str = str:sub(1, startPos - 1) .. (second_pass and bKeypads.L(str:sub(startPos + 1, endPos - 1)) or InterpolateLanguageStrings(bKeypads.L(str:sub(startPos + 1, endPos - 1)), true)) .. str:sub(endPos + 1)
		i = endPos + 1
	end
	return str
end

function bKeypads.Tutorial:GetSceneObject(objName)
	return sceneFrameObjects and sceneFrameObjects[objName] or NULL
end

--## SCENE RENDERING ##--

local sceneRT
local sceneRTMat

local sceneRTTransition
local sceneRTTransitionMat

local function createSceneRT()
	sceneRT = GetRenderTargetEx("bKeypads_Tutorial_SceneRT_" .. ScrW() .. "x" .. ScrH(), ScrW(), ScrH(), RT_SIZE_DEFAULT, MATERIAL_RT_DEPTH_SHARED, bit.bor(512, 32768, 16, 4, 8, 8192), CREATERENDERTARGETFLAGS_HDR, IMAGE_FORMAT_BGRA8888)

	sceneRTMat = CreateMaterial("bKeypads_Tutorial_SceneRT", "UnlitGeneric", {
		["$translucent"] = 1,
		["$vertexalpha"] = 1,
	})

	sceneRTMat:SetTexture("$basetexture", sceneRT:GetName())
	sceneRTMat:Recompute()

	sceneRTTransition = GetRenderTargetEx("bKeypads_Tutorial_SceneRT_Transition_" .. ScrW() .. "x" .. ScrH(), ScrW(), ScrH(), RT_SIZE_DEFAULT, MATERIAL_RT_DEPTH_SHARED, bit.bor(512, 32768, 16, 4, 8, 8192), CREATERENDERTARGETFLAGS_HDR, IMAGE_FORMAT_BGRA8888)

	sceneRTTransitionMat = CreateMaterial("bKeypads_Tutorial_SceneRT_Transition", "UnlitGeneric", {
		["$translucent"] = 1,
		["$vertexalpha"] = 1,
	})

	sceneRTTransitionMat:SetTexture("$basetexture", sceneRTTransition:GetName())
	sceneRTTransitionMat:Recompute()

	bKeypads.Tutorial.SCENE_RT = sceneRT
end
local function initSceneRT()
	hook.Add("OnScreenSizeChanged", "bKeypads.Tutorial.SceneRT", createSceneRT) createSceneRT()
end

local function DrawToolgunTracer(Life, StartPos, EndPos)
	local Alpha = 255 * (1 - Life)
	if Alpha < 1 then return end

	render.SetMaterial(matToolgunTrace)
	local texcoord = math.Rand(0, 1)

	local norm = (StartPos - EndPos) * Life
	local Length = norm:Length()

	for i = 1, 3 do
		render.DrawBeam(StartPos - norm, EndPos, 8, texcoord, texcoord + Length / 128, color_white)
	end

	render.DrawBeam(StartPos, EndPos, 8, texcoord, texcoord + ((StartPos - EndPos):Length() / 128), Color(255, 255, 255, 128 * (1 - Life)))

	Life = Life + FrameTime() * 4
	return Life
end

local function DrawModel(ent)
	if ent:GetRenderGroup() == RENDERGROUP_BOTH then
		ent:DrawModel(DRAW_MODEL_BITMASK_BOTH_1)
		ent:DrawModel(DRAW_MODEL_BITMASK_BOTH_2)
	else
		ent:DrawModel()
	end
end

-- Stupid hack to render halos in the correct 3D context
bKeypads_cam_Start3D = bKeypads_cam_Start3D or cam.Start3D
bKeypads_cam_End3D = bKeypads_cam_End3D or cam.End3D
local function noop() end

-- Stupid hack to render 3D2D UI on entities correctly
local sceneX, sceneY
local cam_Start3D2D, cam_End3D2D do
	local scene3D2DMatrix, scene3D2DVec = Matrix(), Vector()
	local scene3D2DPushed = false
	function cam_Start3D2D(pos, ang, scale)
		if not sceneX or not sceneY then
			scene3D2DPushed = false
			cam.Start3D2D(pos, ang, scale)
		else
			local translation = Vector(pos)
			translation:Add(ang:Forward() * (-sceneX * scale))
			translation:Add(ang:Right() * (-sceneY * scale))
			translation:Sub(ang:Up())

			scene3D2DMatrix:SetAngles(ang)
			scene3D2DMatrix:SetTranslation(translation)

			scene3D2DVec:SetUnpacked(scale, -scale, 1)
			scene3D2DMatrix:SetScale(scene3D2DVec)

			cam.PushModelMatrix(scene3D2DMatrix, true)

			scene3D2DPushed = true
		end
	end
	function cam_End3D2D()
		if scene3D2DPushed then
			cam.PopModelMatrix()
		else
			cam.End3D2D()
		end
	end
end

-- Stupid hack to clip 3D2D UI properly
local function clip_Scissor2D(self, w, h)
	bKeypads.clip:Scissor2D(w, h, self.ClipX, self.ClipY, self.ClipZ)
end

-- Hack to render sprites properly
bKeypads_Tutorial_EyePos = bKeypads_Tutorial_EyePos or EyePos
bKeypads_Tutorial_EyeAngles = bKeypads_Tutorial_EyeAngles or EyeAngles

local camPos, camAng
local function EyePos_Hack()
	return camPos or bKeypads_Tutorial_EyePos()
end
local function EyeAngles_Hack()
	return camAng or bKeypads_Tutorial_EyeAngles()
end

-- Dumb easing function for walking
local function walkEase(x)
	return x == 1 and 1 or 1 - (2 ^ (-20 * x))
end

if bKeypads_Tutorial_SceneObjects then for _, ent in pairs(bKeypads_Tutorial_SceneObjects) do if IsValid(ent) then ent:Remove() end end end
bKeypads_Tutorial_SceneObjects = nil
-- lua_run_cl for _, v in ipairs(ents.GetAll()) do if v:EntIndex() == -1 then v:Remove() end end

if bKeypads_Tutorial_ScenePanels then for _, ent in pairs(bKeypads_Tutorial_ScenePanels) do if IsValid(ent) then ent:Remove() end end end
bKeypads_Tutorial_ScenePanels = nil

function bKeypads.Tutorial:ClearScene()
	if sceneFrameObjects then
		for _, ent in ipairs(sceneFrameObjects) do
			if IsValid(ent) then
				ent:Remove()
			end
			if ent.Particles and ent.Particles:IsValid() then
				ent.Particles:StopEmissionAndDestroyImmediately()
			end
		end
	end
	if sceneFramePanels then
		for _, pnl in ipairs(sceneFramePanels) do
			if IsValid(pnl) then
				pnl:Remove()
			end
		end
	end
end

function bKeypads.Tutorial:SetupScene(scene)
	if not scene.Frames or not scene.Frames[1] then return end

	if initSceneRT then
		initSceneRT()
		initSceneRT = nil
	end

	activeScene = scene
	activeFrame = scene.Frames[1]
	sceneStart = CurTime()
	sceneTransitioning = nil
	sceneFrameStart = nil
	sceneFramePrevFrameTimestamp = CurTime()
	sceneFrame = 1
	sceneCenter, sceneMins, sceneMaxs = Vector(), Vector(), Vector()
	sceneFrameMasterSequence = nil
	sceneAdvanceFrame = nil
	sceneFrameCaptionOverride = nil
	circleCamLastFrame = nil
	circleCamLag = 0
	sceneX, sceneY = nil, nil

	bKeypads.Tutorial:SetupFrame(activeFrame)
end

function bKeypads.Tutorial:StopScene()
	bKeypads.Tutorial:ClearScene()

	bKeypads.Tutorial.Menu.Scene.ActiveScene = nil
	bKeypads.Tutorial.Menu.Scene.m_tTVAnimation = nil

	activeScene = nil
	activeFrame = nil
	sceneStart = nil
	sceneTransitioning = nil
	sceneFrameStart = nil
	sceneFrame = nil
	sceneCenter, sceneMins, sceneMaxs = nil, nil, nil
	sceneFrameMasterSequence = nil
	sceneFrameTimeDelta = nil
	sceneFramePrevFrameTimestamp = nil
	sceneAdvanceFrame = nil
	sceneFrameObjects = nil
	sceneFramePanels = nil
	sceneFrameCaptionOverride = nil
	bKeypads_Tutorial_SceneObjects = nil
	bKeypads_Tutorial_ScenePanels = nil
	circleCamLastFrame = nil
	circleCamLag = nil
	sceneX, sceneY = nil, nil

	EyePos = bKeypads_Tutorial_EyePos
	EyeAngles = bKeypads_Tutorial_EyeAngles
end

function bKeypads.Tutorial:SetupFrame(frame)
	bKeypads.Tutorial:ClearScene()
	
	sceneCenter, sceneMins, sceneMaxs = Vector(), Vector(), Vector()

	sceneFrameMasterSequence = nil

	sceneFrameCaptionOverride = nil

	sceneFrameObjects = {}
	bKeypads_Tutorial_SceneObjects = sceneFrameObjects

	sceneFramePanels = {}
	bKeypads_Tutorial_ScenePanels = sceneFramePanels

	if frame.Panels then
		for _, pnlObj in ipairs(frame.Panels) do
			local pnl
			if isstring(pnlObj[1]) then
				pnl = vgui.Create(pnlObj[1], bKeypads.Tutorial.Menu.Scene)
			elseif isfunction(pnlObj[1]) then
				pnl = pnlObj[1](bKeypads.Tutorial.Menu.Scene)
			end

			if not IsValid(pnl) or not ispanel(pnl) then
				ErrorNoHalt("Failed to create panel \"" .. tostring(pnlObj[1]) .. "\"!\n")
				continue
			end

			table.insert(sceneFramePanels, pnl)

			if not pnlObj.SuppressFade then
				pnl:SetAlpha(0)
				pnl.bKeypads_FadeAlpha = true
			end

			if isfunction(pnlObj[2]) then pnlObj[2](pnl, bKeypads.Tutorial.Menu.Scene:GetWide(), bKeypads.Tutorial.Menu.Scene:GetTall()) end
		end
	end

	if frame.Objects then
		for _, obj in ipairs(frame.Objects) do
			local ent
			local isClientsideSENT
			if obj.Class == "Player" then

				ent = ClientsideModel(playerModels[math.random(1, #playerModels)], RENDERGROUP_OPAQUE)
				ent:UseClientSideAnimation()
				ent:ResetSequenceInfo()
				
				if developer:GetInt() >= 2 then
					for id, sequence in SortedPairsByValue(ent:GetSequenceList()) do
						print(id, sequence)
					end
					print(ent:GetModel())
				end

				if obj.Weapon then
					ent.m_sWeapon = obj.Weapon

					ent.Weapon = ClientsideModel(obj.Weapon, RENDERGROUP_OPAQUE)
					ent.Weapon:SetMoveType(MOVETYPE_NONE)
					ent.Weapon:SetParent(ent, ent:LookupAttachment("anim_attachment_RH"))
					ent.Weapon:AddEffects(bit.bor(EF_BONEMERGE, EF_BONEMERGE_FASTCULL, EF_PARENT_ANIMATES))
					ent.Weapon:SetNoDraw(true)
					ent.Weapon:SetOwner(ent)
					ent.Weapon:SetSolid(SOLID_NONE)
					ent.Weapon:Spawn()
					ent.Weapon:Activate()

					if obj.HoldType then
						ent.HoldType = obj.HoldType
					end

					table.insert(sceneFrameObjects, ent.Weapon)
				end

			elseif obj.Class == "prop_physics" then
				ent = ents.CreateClientProp(obj.Model, RENDERGROUP_OPAQUE)
			else
				ent = ents.CreateClientside(obj.Class)
				isClientsideSENT = true
			end

			if not IsValid(ent) then
				ErrorNoHalt("Failed to create \"" .. obj.Class .. "\" (" .. tostring(ent) .. ") clientside!\n")
				continue
			end

			ent.bKeypads_Tutorial = true

			ent.FrameObject = obj

			ent:SetPredictable(false)
			ent:SetLOD(0)
			ent:SetNoDraw(true)

			if obj.Sequence then
				ent.Sequence = obj.Sequence
				if obj.MasterSequence then
					ent.MasterSequence = true
					sceneFrameMasterSequence = {
						ent = ent,
						Sequence = ent.MasterSequence
					}
				end
			end

			if ent.MasterSequence then
				table.insert(sceneFrameObjects, 1, ent)
			else
				table.insert(sceneFrameObjects, ent)
			end
			if obj.ID then
				sceneFrameObjects[obj.ID] = ent
			end

			if obj.Class ~= "prop_physics" and obj.Model then
				ent:SetModel(obj.Model)
			end

			if obj.Material then
				ent:SetMaterial(obj.Material)
			end

			if obj.Class ~= "Player" then
				local phys = ent:GetPhysicsObject()
				if IsValid(phys) then
					phys:EnableMotion(false)
				end
				ent:SetMoveType(MOVETYPE_NONE)
			end

			ent.OriginPos = ent:GetPos()

			ent:Spawn()

			local mins, maxs
			for i = 1, 3 do
				if i == 1 then
					mins, maxs = ent:GetModelBounds()
				elseif i == 2 then
					mins, maxs = ent:GetCollisionBounds()
				elseif i == 3 then
					mins, maxs = ent:GetRenderBounds()
				end
				if mins and maxs then break end
			end
			if mins and maxs then
				if obj.Class == "Player" then mins.z = 0 end
				
				local center = (maxs + mins) / 2
				center.z = mins.z
				ent:SetPos(ent:GetPos() - ent:LocalToWorld(center))
			end

			if obj.Translate then
				ent:SetPos(ent:GetPos() + obj.Translate)
			end
			if obj.Angle then
				ent:SetAngles(obj.Angle)
			end

			if obj.Class == "Player" then
				if ent.HoldType then
					ent:ResetSequence("walk_" .. ent.HoldType)
				else
					local seq = ent:SelectWeightedSequence(ACT_WALK)
					ent:ResetSequence(seq ~= -1 and seq or "walk_all")
				end
			end

			if isClientsideSENT then
				ent.Start3D2D = cam_Start3D2D
				ent.End3D2D = cam_End3D2D
				ent.Scissor2D = clip_Scissor2D
				ent.m_ForceSupressEngineLighting = true
				if ent.TutorialInitialize then
					ent:TutorialInitialize()
				end

				if obj.NetworkVars then
					for key, val in pairs(obj.NetworkVars) do
						assert(isfunction(ent["Set" .. key]), "NetworkVar setter \"" .. tostring(key) .. "\" does not exist!")
						ent["Set" .. key](ent, val)
					end
				end
			end
		end
	end
end

local circleVec = Vector()
function bKeypads.Tutorial:RenderScene(x, y, w, h, paused)
	if not bKeypads or not bKeypads.Tutorial or not IsValid(bKeypads.Tutorial.Menu) or not bKeypads.Tutorial.Menu:IsVisible() then return end

	local activeScene = bKeypads.Tutorial.Menu.Scene.ActiveScene
	if not activeScene or not activeScene.Frames then return end

	sceneX, sceneY = x, y

	local activeFrame = bKeypads.Tutorial.Menu.Scene.ActiveScene.Frames[sceneFrame]
	if not activeFrame then bKeypads.Tutorial:StopScene() return end

	sceneFrameTimeDelta = (CurTime() - sceneFramePrevFrameTimestamp)
	sceneFramePrevFrameTimestamp = CurTime()

	if paused or not sceneFrameStart then
		sceneFrameStart = CurTime()
	end

	local FOV = activeFrame.FOV or 110
	local CameraFocus = sceneCenter
	if activeFrame.CameraFocus and IsValid(sceneFrameObjects[activeFrame.CameraFocus]) then
		CameraFocus = sceneFrameObjects[activeFrame.CameraFocus]:WorldSpaceCenter()
	end
	
	local frameDelta = CurTime() - (sceneFrameStart or CurTime())
	local sceneDelta = CurTime() - (sceneStart or CurTime())
	
	local circleCamDelta
	if activeFrame.CircularCam == false or activeScene.CircularCam == false or not activeFrame.Objects or #activeFrame.Objects == 0 then
		circleCamLag = circleCamLag + (CurTime() - (circleCamLastFrame or CurTime()))
		if activeFrame.CameraFocus and IsValid(sceneFrameObjects[activeFrame.CameraFocus]) then
			circleCamDelta = 0
		else
			circleCamDelta = activeFrame.CircularCamFactor or 0
		end
	else
		circleCamDelta = (CurTime() - (sceneStart or CurTime())) - circleCamLag
	end
	circleCamLastFrame = CurTime()

	local timeStep = ((circleCamDelta / 8) % 2) * math.pi
	circleVec.x = math.sin(timeStep)
	circleVec.y = math.cos(timeStep)

	local sceneSizeX, sceneSizeY, sceneSizeZ = sceneMaxs.x - sceneMins.x, sceneMaxs.y - sceneMins.y, sceneMaxs.z - sceneMins.z

	local sceneTranslation = activeFrame.SceneTranslate or activeScene.SceneTranslate
	if sceneTranslation then sceneSizeX, sceneSizeY, sceneSizeZ = sceneSizeX + sceneTranslation.x, sceneSizeY + sceneTranslation.y, sceneSizeZ + sceneTranslation.z end

	local camDist = (math.max(sceneSizeX, sceneSizeY, sceneSizeZ)) * (1 + (1 / math.tan(math.rad(FOV / 2))))

	local camFocalPoint = Vector(CameraFocus)
	camFocalPoint:Sub(camDist * circleVec)
	camFocalPoint.z = sceneCenter.z

	local camTranslate = activeFrame.CameraTranslate or activeScene.CameraTranslate
	if camTranslate then
		camFocalPoint:Add(camTranslate)
	end

	local lookAt = Vector(CameraFocus)
	lookAt.z = sceneCenter.z

	local camPos = Vector(camFocalPoint)
	if not activeScene.CameraCenterZ then
		camPos.z = camPos.z * 1.1
		lookAt.z = lookAt.z * 0.9
	end

	local shootPos
	local shootVec

	local RTWidth, RTHeight = sceneRT:Width(), sceneRT:Height()
	local RTViewportX, RTViewportY = (RTWidth - w) / 2, (RTHeight - h) / 2

	cam.Start3D = bKeypads_cam_Start3D
	cam.End3D = bKeypads_cam_End3D

	render.PushRenderTarget(sceneRT)

	render.SetWriteDepthToDestAlpha(false)
	render.OverrideAlphaWriteEnable(true, true)
	render.OverrideDepthEnable(true, true)

	-- TODO faceid for keypad owner PIN for everyone else

	render.Clear(bKeypads.COLOR.GMODBLUE.r, bKeypads.COLOR.GMODBLUE.g, bKeypads.COLOR.GMODBLUE.b, 255, true, false)

	local _ScrW, _ScrH = ScrW(), ScrH()
	render.SetViewPort(RTViewportX, RTViewportY, w, h)
	
	cam.Start2D()
		surface.SetDrawColor(255, 255, 255)
		surface.SetMaterial(GRADIENT_LIGHT_LARGE)
		surface.DrawTexturedRect(0, 0, ScrW(), ScrH())

		render.ClearDepth()
	cam.End2D()

	render.OverrideAlphaWriteEnable(false)
	render.OverrideDepthEnable(false)

	if activeScene.CameraPos or activeFrame.CameraPos then
		camPos = activeScene.CameraPos or activeFrame.CameraPos
	end

	if activeScene.CameraAngle or activeFrame.CameraAngle then
		camAng = activeScene.CameraAngle or activeFrame.CameraAngle
	else
		camAng = (lookAt - camFocalPoint):Angle()
	end

	EyePos = EyePos_Hack
	EyeAngles = EyeAngles_Hack
	
	cam.Start3D(camPos, camAng, FOV, 0, 0, RTWidth, RTHeight, 1, 99999999999)

	--render.SetColorMaterialIgnoreZ()
	--render.DrawBox(vector_origin, angle_zero, sceneMins, sceneMaxs, Color(255,0,0), false)

		render.SuppressEngineLighting(true)
		render.SetLightingOrigin(vector_origin)
		render.ResetModelLighting(1, 1, 1)
		render.SetColorModulation(1, 1, 1)
		render.SetAmbientLight(1, 1, 1)

			local rayEnts
			local rayEntsDict
			if activeFrame.Raycast and IsValid(sceneFrameObjects["PLAYER"]) then
				local ply = sceneFrameObjects["PLAYER"]
				local eyes = ply:LookupAttachment("eyes")
				if eyes ~= -1 then
					local aim_pitch, aim_yaw = ply:LookupPoseParameter("aim_pitch"), ply:LookupPoseParameter("aim_yaw")
					if aim_pitch ~= -1 and aim_yaw ~= -1 then
						local pMins, pMaxs = ply:GetPoseParameterRange(aim_pitch)
						local aim_pitch = math.Remap(ply:GetPoseParameter("aim_pitch"), 0, 1, pMins, pMaxs)

						local yMins, yMaxs = ply:GetPoseParameterRange(aim_yaw)
						local aim_yaw = math.Remap(ply:GetPoseParameter("aim_yaw"), 0, 1, yMins, yMaxs)

						local eyeAngles = Angle(aim_pitch, aim_yaw, 0)

						shootPos = ply:GetAttachment(eyes).Pos
						shootVec = eyeAngles:Forward()

						rayEnts, rayEntsDict = {}, {}
						for _, ent in ipairs(ents.FindAlongRay(shootPos, shootPos + (shootVec * (sceneFrameObjects.RaycastDist or 256)), vector_origin, vector_origin)) do
							if ent.bKeypads_Tutorial and ent ~= ply and ent:GetParent() ~= ply then
								table.insert(rayEnts, ent)
								rayEntsDict[ent] = true
							end
						end
					end
				end
			end

			local shootToolgunAt
			local shootToolgunFrom

			local halos, linkingBeams

			local masterSequenceAdvance
			for _, ent in ipairs(sceneFrameObjects) do
				if ent.bKeypad then ent.ClipX, ent.ClipY, ent.ClipZ = sceneX, sceneY, 1 end

				ent.SingularRef = { ent }

				if ent.Sequence then
					if not ent.m_iCurrentSequence then
						ent.m_iCurrentSequence = 1
					end

					local curSequence = ent.Sequence[ent.m_iCurrentSequence]
					if curSequence then
						if curSequence.Halo then
							halos = halos or {}
							curSequence.Halo.Ents = ent.SingularRef
							table.insert(halos, curSequence.Halo)
						end
						if curSequence.DrawLinkingBeam then
							linkingBeams = linkingBeams or {}
							table.insert(linkingBeams, curSequence.DrawLinkingBeam)
						end
					end
				
					if paused then goto drawEnt end

					if masterSequenceAdvance or (ent.m_iSequenceEnd and CurTime() >= ent.m_iSequenceEnd) then
						ent.m_iSequenceEnd = nil
						ent.m_iCurrentSequence = ent.m_iCurrentSequence + 1
						ent.m_bSequencePlaying = false
						if ent.MasterSequence then
							masterSequenceAdvance = true
						end
						
						curSequence = ent.Sequence[ent.m_iCurrentSequence]
					end

					if curSequence then
						if curSequence.Caption then
							sceneFrameCaptionOverride = curSequence.Caption
						elseif curSequence.Caption == false then
							sceneFrameCaptionOverride = nil
						end

						local seq = -1
						--local layeredSeq = -1
						if isstring(curSequence[1]) then
							local startPos, endPos = curSequence[1]:find("%%HOLDTYPE%%")
							if startPos and endPos then
								seq = ent:LookupSequence(curSequence[1]:sub(1, startPos - 1) .. (ent.HoldType or "all") .. curSequence[1]:sub(endPos + 1))
							else
								seq = ent:LookupSequence(curSequence[1])
							end
						end

						if not ent.m_bSequencePlaying then
							ent.OriginPos = ent:GetPos()
							ent.m_bSequencePlaying = true
							ent.m_iSequenceStart = CurTime()
							ent.m_aLookAng = nil
							ent.m_fAimPitch = nil
							ent.m_fAimYaw = nil
							ent.m_fHeadPitch = nil
							ent.m_fHeadYaw = nil

							if seq ~= -1 then
								ent:SetSequence(seq)
								ent:SetCycle(0)
							end

							if curSequence.WalkTo then ent:SetCycle(0) end
							--if layeredSeq ~= -1 then
							--	ent:SetLayerSequence(0, layeredSeq)
							--	ent:SetLayerPlaybackRate(0, 1)
							--	ent:SetLayerCycle(0, 0)
							--	ent:SetLayerWeight(0, 1)
							--end

							if curSequence.Duration then
								ent.m_iSequenceEnd = CurTime() + curSequence.Duration
							end

							if isfunction(curSequence[1]) then
								curSequence[1](ent)
							end
							
							if curSequence.ShootToolgun and IsValid(ent.Weapon) then
								local shootAt = sceneFrameObjects[curSequence.ShootToolgun]
								if IsValid(shootAt) then
									surface.PlaySound("weapons/airboat/airboat_gun_lastshot1.wav")
								end
							end

							if curSequence.Weapon == false then
								surface.PlaySound("npc/combine_soldier/gear5.wav")
								if IsValid(ent.Weapon) then
									table.RemoveByValue(sceneFrameObjects, ent.Weapon)
									ent.Weapon:Remove()
								end
								ent.HoldType = nil
								if seq == -1 then
									local seq = ent:SelectWeightedSequence(ACT_WALK)
									ent:ResetSequence(seq ~= -1 and seq or "walk_all")
								end
							end
						end

						if curSequence.ShootToolgun then
							--layeredSeq = ent:SelectWeightedSequence(ACT_HL2MP_GESTURE_RANGE_ATTACK_REVOLVER)
							
							local shootAt = sceneFrameObjects[curSequence.ShootToolgun]
							if IsValid(shootAt) and (not ent.Weapon.m_iToolgunTracerLife or ent.Weapon.m_iToolgunTracerLife < 1) then
								shootToolgunFrom = ent.Weapon
								shootToolgunAt = shootAt
							end
						elseif IsValid(ent.Weapon) then
							ent.Weapon.m_iToolgunTracerLife = nil
						end

						if curSequence.WalkTo then
							local walkDir = (curSequence.WalkTo - ent:GetPos())
							local walkLength = walkDir:Length()

							if not curSequence.WalkLength then curSequence.WalkLength = (curSequence.WalkTo - ent.OriginPos):Length() end
							local progress = walkLength / curSequence.WalkLength

							if progress - 0.01 <= 0 then
								ent.m_iCurrentSequence = ent.m_iCurrentSequence + 1
								ent.m_bSequencePlaying = false

								if ent.MasterSequence then
									masterSequenceAdvance = true
								end
							else
								walkDir:Normalize()
								
								local walkSpeed = walkDir * walkEase(progress)
								ent:SetPoseParameter("move_x", walkSpeed.x)
								ent:SetPoseParameter("move_y", walkSpeed.y)
								ent:InvalidateBoneCache()

								walkDir:Mul(ent:GetSequenceGroundSpeed(ent:GetSequence()) * sceneFrameTimeDelta)
								walkDir:Add(ent:GetPos())
								ent:SetPos(walkDir)
							end
						else
							local from, to = ent:GetPoseParameterRange(ent:LookupPoseParameter("move_x"))
							if from and to then ent:SetPoseParameter("move_x", math.Remap(ent:GetPoseParameter("move_x"), 0, 1, from, to) * .95) end
							local from, to = ent:GetPoseParameterRange(ent:LookupPoseParameter("move_y"))
							if from and to then ent:SetPoseParameter("move_y", math.Remap(ent:GetPoseParameter("move_y"), 0, 1, from, to) * .95) end
							ent:InvalidateBoneCache()
						end

						if curSequence.LookAt then
							local eyes = ent:LookupAttachment("eyes")
							if eyes ~= -1 then
								local shootPos = ent:GetAttachment(eyes).Pos

								local lookEnt = sceneFrameObjects[curSequence.LookAt]
								if IsValid(lookEnt) then
									local lookFrac = curSequence.Duration and bKeypads.ease.InOutCubic(math.TimeFraction(ent.m_iSequenceStart, ent.m_iSequenceStart + curSequence.Duration, CurTime())) or 1

									if not ent.m_aLookAng then
										ent.m_aLookAng = ent:GetAngles()
									end

									local lookAng = (lookEnt:GetPos() - shootPos):Angle()
									lookAng:Normalize()

									local aim_pitch, aim_yaw = lookAng.p, lookAng.y
									lookAng.r = 0
									lookAng.p = 0

									if not ent.m_fAimPitch then
										local aim_pitch = ent:LookupPoseParameter("aim_pitch")
										if aim_pitch ~= -1 then
											local pMins, pMaxs = ent:GetPoseParameterRange(aim_pitch)
											ent.m_fAimPitch = math.Remap(ent:GetPoseParameter("aim_pitch"), 0, 1, pMins, pMaxs)
										end
									end
									if ent.m_fAimPitch then ent:SetPoseParameter("aim_pitch", Lerp(lookFrac, ent.m_fAimPitch, aim_pitch)) end

									if not ent.m_fAimYaw then
										local aim_yaw = ent:LookupPoseParameter("aim_yaw")
										if aim_yaw ~= -1 then
											local yMins, yMaxs = ent:GetPoseParameterRange(aim_yaw)
											ent.m_fAimYaw = math.Remap(ent:GetPoseParameter("aim_yaw"), 0, 1, yMins, yMaxs)
										end
									end
									if ent.m_fAimYaw then ent:SetPoseParameter("aim_yaw", Lerp(lookFrac, ent.m_fAimYaw, aim_yaw)) end

									local head_pitch = ent:LookupPoseParameter("head_pitch")
									if head_pitch ~= -1 then
										local pMins, pMaxs = ent:GetPoseParameterRange(head_pitch)
										if not ent.m_fHeadPitch then
											ent.m_fHeadPitch = math.Remap(ent:GetPoseParameter("head_pitch"), 0, 1, pMins, pMaxs)
										end
										ent:SetPoseParameter("head_pitch", Lerp(lookFrac, ent.m_fHeadPitch, math.Clamp(aim_pitch, pMins, pMaxs)))
									end

									local head_yaw = ent:LookupPoseParameter("head_yaw")
									if head_yaw ~= -1 then
										local yMins, yMaxs = ent:GetPoseParameterRange(head_yaw)
										if not ent.m_fHeadYaw then
											ent.m_fHeadYaw = math.Remap(ent:GetPoseParameter("head_yaw"), 0, 1, yMins, yMaxs)
										end
										ent:SetPoseParameter("head_yaw", Lerp(lookFrac, ent.m_fHeadYaw, math.Clamp(aim_yaw, yMins, yMaxs)))
									end

									ent:InvalidateBoneCache()
								end
							end
						end

					elseif (sceneFrameMasterSequence == nil or ent.MasterSequence) and ent.m_iCurrentSequence >= #ent.Sequence then
						sceneAdvanceFrame = true
					end
				end

				::drawEnt::
				if not ent.AutomaticFrameAdvance then
					ent:FrameAdvance()
				end

				DrawModel(ent)

				if IsValid(ent.Weapon) then
					DrawModel(ent.Weapon)
				end

				if ent.Particles and ent.Particles:IsValid() then
					ent.Particles:Render()
				end

				if (not ent.m_iCurrentSequence or ent.m_iCurrentSequence == 1) and ent.FrameObject and not ent.FrameObject.OutOfFrame then
					local mins, maxs = ent:GetRotatedAABB(ent:GetModelBounds())
					mins, maxs = ent:LocalToWorld(mins), ent:LocalToWorld(maxs)

					if sceneMins:IsZero() then
						sceneMins = mins
					else
						sceneMins:SetUnpacked(
							math.min(sceneMins.x, mins.x),
							math.min(sceneMins.y, mins.y),
							math.min(sceneMins.z, mins.z)
						)
					end

					if sceneMaxs:IsZero() then
						sceneMaxs = maxs
					else
						sceneMaxs:SetUnpacked(
							math.max(sceneMaxs.x, maxs.x),
							math.max(sceneMaxs.y, maxs.y),
							math.max(sceneMaxs.z, maxs.z)
						)
					end

					local mins, maxs = ent:GetModelBounds()
					mins, maxs = ent:LocalToWorld(mins), ent:LocalToWorld(maxs)

					sceneMins:SetUnpacked(
						math.min(sceneMins.x, mins.x),
						math.min(sceneMins.y, mins.y),
						math.min(sceneMins.z, mins.z)
					)

					sceneMaxs:SetUnpacked(
						math.max(sceneMaxs.x, maxs.x),
						math.max(sceneMaxs.y, maxs.y),
						math.max(sceneMaxs.z, maxs.z)
					)
				end
			end
			
			if sceneMaxs and sceneMins then
				sceneCenter = (sceneMaxs + sceneMins) / 2
			end

			if shootToolgunFrom and shootToolgunAt then
				local muzzle = shootToolgunFrom:LookupAttachment("muzzle")
				shootToolgunFrom.m_iToolgunTracerLife = DrawToolgunTracer(shootToolgunFrom.m_iToolgunTracerLife or 0, shootToolgunFrom:GetAttachment(muzzle).Pos, shootToolgunAt:WorldSpaceCenter())
			end

		render.SuppressEngineLighting(false)

		if halos then
			cam.Start3D = noop
			cam.End3D = noop
				for _, entry in ipairs(halos) do
					if IsValid(entry.Ents[1]) and (not entry.Raycast or not rayEntsDict or rayEntsDict[entry.Ents[1]]) then
						halo.Render(entry)
					end
				end
			cam.Start3D = bKeypads_cam_Start3D
			cam.End3D = bKeypads_cam_End3D
		end

		if linkingBeams then
			bKeypads.ESP.AnimateDataBeam()
			for _, linkingBeam in ipairs(linkingBeams) do
				local ent1

				if istable(linkingBeam[1]) then
					local ent = sceneFrameObjects[linkingBeam[1][1]]
					if IsValid(ent) then
						if not shootPos or not rayEntsDict or rayEntsDict[ent] then
							ent1 = ent
						else
							ent1 = shootPos + (shootVec * (linkingBeam.MaxDist or 64))
						end
					end
				elseif isstring(linkingBeam[1]) then
					local ent = sceneFrameObjects[linkingBeam[1]]
					if IsValid(ent) then
						ent1 = ent
					end
				else
					ent1 = linkingBeam[1]
				end

				local ent2
				if istable(linkingBeam[2]) then
					local ent = sceneFrameObjects[linkingBeam[2][1]]
					if IsValid(ent) then
						if not shootPos or not rayEntsDict or rayEntsDict[ent] then
							ent2 = ent
						else
							ent2 = shootPos + (shootVec * (linkingBeam.MaxDist or 64))
						end
					end
				elseif isstring(linkingBeam[2]) then
					if IsValid(sceneFrameObjects[linkingBeam[2]]) then
						ent2 = sceneFrameObjects[linkingBeam[2]]
					end
				else
					ent2 = linkingBeam[2]
				end

				if ent1 and ent2 then
					local ignoreZ = bKeypads.ESP.IgnoreZ
					bKeypads.ESP.IgnoreZ = linkingBeam[5] ~= true
					cam.IgnoreZ(bKeypads.ESP.IgnoreZ)
						bKeypads.ESP.DrawDataBeam(ent1, ent2, linkingBeam[3], linkingBeam[4], linkingBeam[5])
					cam.IgnoreZ(false)
					bKeypads.ESP.IgnoreZ = ignoreZ
				end
			end
		end
	cam.End3D()

	EyePos = bKeypads_Tutorial_EyePos
	EyeAngles = bKeypads_Tutorial_EyeAngles

	local caption = sceneFrameCaptionOverride or activeFrame.Caption
	if caption then
		cam.Start2D()
			gmod_language = gmod_language or GetConVar("gmod_language")

			local marginX, marginY = 30, 30
			local txtWidth = ScrW() - (marginX * 2)
			local txtY = ScrH() - marginY

			local captionStr = InterpolateLanguageStrings(caption)
			if not activeFrame.MarkupObj or activeFrame.MarkupObj.str ~= captionStr or activeFrame.MarkupObj.w ~= w or activeFrame.MarkupObj.h ~= h or activeFrame.MarkupObj.lang ~= gmod_language:GetString() then
				activeFrame.MarkupObj = {
					bKeypads.markup.Parse("<font=bKeypads.Tutorial.Caption><color=255,255,255>" .. captionStr .. "</color></font>", txtWidth),
					w = w,
					h = h,
					lang = gmod_language:GetString(),
					str = captionStr
				}
			end
			
			activeFrame.MarkupObj[1]:Draw((ScrW() - txtWidth) / 2, txtY, TEXT_ALIGN_LEFT, TEXT_ALIGN_BOTTOM, 255, TEXT_ALIGN_CENTER)
		cam.End2D()
	end

	render.OverrideAlphaWriteEnable(false)
	render.OverrideDepthEnable(false)
	render.SetViewPort(0, 0, _ScrW, _ScrH)
	render.PopRenderTarget()
end

local function ScenePaint(self, w, h)
	if not IsValid(bKeypads.Tutorial.Menu) then return end
	local x, y = self:LocalToScreen(0, 0)
	
	bKeypads.Tutorial:RenderScene(x, y, w, h, self.m_bTVAnimation == true or sceneTransitioning)

	local RTWidth, RTHeight = sceneRTTransition:Width(), sceneRTTransition:Height()

	if sceneTransitioning then

		bKeypads:TVAnimation(self, .5, w, h, true, x, y, bKeypads.ease.InOutSine)

			local frac = math.Clamp(math.TimeFraction(self.m_tTVAnimation.Start, self.m_tTVAnimation.Start + .5, CurTime()), 0, 1)
			if frac == 1 then sceneTransitioning = false end

			surface.SetAlphaMultiplier(1 - frac)

			local dc = DisableClipping(false)
				surface.SetDrawColor(255, 255, 255, 255)
				bKeypads:DrawSubpixelClippedMaterial(sceneRTTransitionMat, (w - RTWidth) / 2, (h - RTHeight) / 2, RTWidth, RTHeight)
			DisableClipping(dc)

			surface.SetAlphaMultiplier(1)

		bKeypads:TVAnimation(self)
	end

	bKeypads:TVAnimation(self, .5, w, h, self.ActiveScene == nil, x, y, bKeypads.ease.InOutSine)

		local frac = math.Clamp(math.TimeFraction(self.m_tTVAnimation.Start, self.m_tTVAnimation.Start + .5, CurTime()), 0, 1)
		if self.ActiveScene == nil then
			if frac == 1 then
				bKeypads:TVAnimation(self)
				self:SetVisible(false)
				return
			else
				frac = 1 - frac
			end
		end

		if sceneFramePanels then
			local fadeFrac = bKeypads.ease.OutSine(math.Clamp(math.TimeFraction(self.m_tTVAnimation.Start + .5, self.m_tTVAnimation.Start + .5 + .25, CurTime()), 0, 1))
			for _, pnl in ipairs(sceneFramePanels) do
				if pnl.bKeypads_FadeAlpha then
					pnl:SetAlpha(255 * fadeFrac)
				end
			end
		end
		
		surface.SetAlphaMultiplier(frac)
		
		local dc = DisableClipping(false)
			surface.SetDrawColor(255, 255, 255, 255)
			bKeypads:DrawSubpixelClippedMaterial(sceneRTMat, (w - RTWidth) / 2, (h - RTHeight) / 2, RTWidth, RTHeight)
		DisableClipping(dc)

		surface.SetAlphaMultiplier(1)

	bKeypads:TVAnimation(self)
end

local function SceneThink(self)
	if activeFrame and sceneFrame and (sceneAdvanceFrame or (activeFrame.Duration and sceneFrameStart and CurTime() - sceneFrameStart > activeFrame.Duration)) then
		sceneAdvanceFrame = nil
		sceneFrame = sceneFrame + 1
		if sceneFrame > #bKeypads.Tutorial.Menu.Scene.ActiveScene.Frames then
			surface.PlaySound("bkeypads/cracker/success.mp3")
			bKeypads.Tutorial:StopScene()
		else
			bKeypads.Tutorial.Menu.Scene.m_tTVAnimation = nil
			sceneTransitioning = true
			render.CopyTexture(sceneRT, sceneRTTransition)

			surface.PlaySound("npc/turret_floor/click1.wav")
			activeFrame = bKeypads.Tutorial.Menu.Scene.ActiveScene.Frames[sceneFrame]
			bKeypads.Tutorial:SetupFrame(activeFrame)
		end
	end
end

--## MENU ##--

local LOGO = Material("bkeypads/logo_wide_white.png", "smooth")

local function MenuPaint(self, w, h)
	surface.SetDrawColor(bKeypads.COLOR.GMODBLUE)
	surface.DrawRect(0, 0, w, 24)

	surface.SetDrawColor(bKeypads.COLOR.GMODBLUE)
	surface.DrawRect(0, 24 - 2, w, h - 24 + 2)
	
	surface.SetMaterial(GRADIENT_LIGHT_LARGE)
	surface.SetDrawColor(255, 255, 255)
	surface.DrawTexturedRectRotated(w / 2, ((24 + 2) + h) / 2, w, h - 24 + 2, 180)

	surface.SetDrawColor(bKeypads.COLOR.SLATE)
	surface.DrawRect(2, 24, w - 4, h - 24 - 2)

	local logo_w = (230 / 900) * w
	local logo_h = (128 / 335) * logo_w
	surface.SetMaterial(LOGO)
	surface.SetDrawColor(255, 255, 255, 100)
	surface.DrawTexturedRect(self.Categories:GetWide() + ((w - 4 - self.Categories:GetWide() - logo_w) / 2), 24 + ((h - 24 - 2) - logo_h) / 2, logo_w, logo_h)

	surface.SetDrawColor(255, 255, 255)
	surface.SetMaterial(GRADIENT_LIGHT)
	surface.DrawTexturedRect(0, 0, w, 24)

	surface.SetDrawColor(255, 255, 255, 200)
	surface.SetMaterial(GRADIENT)
	surface.DrawTexturedRectRotated(self.Categories:GetWide() + (7 / 2), (h + (24 + 2)) / 2, h - 24 - 2, 7, -90)
end

local function SceneClicked(self)
	if not IsValid(bKeypads.Tutorial.Menu) then return end

	if self.Scene.Function or self.Scene.Setting then
		surface.PlaySound("bkeypads/cracker/success.mp3")
	end

	if self.Scene.Function then
		self.Scene.Function(self.Scene)
	end

	if self.Scene.Setting then
		if not IsValid(g_SpawnMenu) or not g_SpawnMenu:IsVisible() then
			RunConsoleCommand("+menu")
		end
		bKeypads:OpenSettings()

		local setting = self.Scene.Setting
		if setting ~= "" then
			timer.Simple(0, function() timer.Simple(0, function()
				if not bKeypads or not bKeypads.Settings or not IsValid(bKeypads.Settings.CPanel) or not bKeypads.Settings.CPanel:IsVisible() then return end

				local settingPnl = bKeypads.Settings.CPanel.SettingPanels[setting]
				if not IsValid(settingPnl) then return end

				bKeypads.Settings.CPanel.SmoothScroll:InvalidateLayout(true)

				local y = select(2, bKeypads.Settings.CPanel.SmoothScroll.pnlCanvas:ScreenToLocal(settingPnl:LocalToScreen(settingPnl:GetWide() / 2, settingPnl:GetTall() / 2)))
				y = y - (bKeypads.Settings.CPanel.SmoothScroll:GetTall())
				y = -y

				-- FIXME

				bKeypads.Settings.CPanel.SmoothScroll.pnlCanvas.TargetOffset = y
				bKeypads.Settings.CPanel.SmoothScroll.pnlCanvas.CurrentOffset = y
				print(y)

				local VBar = bKeypads.Settings.CPanel.SmoothScroll:GetVBar()
				VBar.TargetY = y
				VBar.CurrentY = y
				VBar:InvalidateLayout(true)
				
				timer.Simple(0, function()
					if not IsValid(settingPnl) or not settingPnl:IsVisible() then return end
					input.SetCursorPos(settingPnl:LocalToScreen(settingPnl:GetWide() / 2, settingPnl:GetTall() / 2))
				end)
			end) end)
		end

		timer.Simple(0, function()
			if not IsValid(bKeypads.Tutorial.Menu) or not bKeypads.Tutorial.Menu:IsVisible() then return end
			bKeypads.Tutorial.Menu:MakePopup()
			bKeypads.Tutorial.Menu:MoveToFront()
		end)
	end

	if not self.Scene.Frames then
		bKeypads.Tutorial.Menu.Scene.ActiveScene = nil
		bKeypads.Tutorial.Menu.Scene.m_tTVAnimation = nil
		return
	end

	bKeypads.Tutorial:StopScene()
	bKeypads.Tutorial:SetupScene(self.Scene)

	if not bKeypads.Tutorial.Menu.Scene:IsVisible() then
		bKeypads.Tutorial.Menu.Scene.m_tTVAnimation = nil
		bKeypads.Tutorial.Menu.Scene:SetVisible(true)
		surface.PlaySound("bkeypads/cracker/whirr.mp3")
	elseif bKeypads.Tutorial.Menu.Scene.ActiveScene ~= self.Scene then
		surface.PlaySound("bkeypads/cracker/success.mp3")
	else
		surface.PlaySound("bkeypads/cracker/hello.mp3")
	end

	bKeypads.Tutorial.Menu.Scene.ActiveScene = self.Scene
end

local function MenuOnClose()
	surface.PlaySound("garrysmod/balloon_pop_cute.wav")
	bKeypads.Tutorial:StopScene()
end

local function CategoriesPaint(self, w, h)
	surface.SetDrawColor(20, 20, 20)
	surface.DrawRect(0, 0, w, h)
end

function bKeypads.Tutorial:OpenMenu()
	if IsValid(bKeypads.Tutorial.Menu) then
		bKeypads.Tutorial.Menu:Close()
	else
		surface.PlaySound("garrysmod/content_downloaded.wav")
	end

	local L = bKeypads.L
	local I = InterpolateLanguageStrings

	local h = (600 / 1080) * ScrH()
	local w = (900 / 600) * h

	--## MAIN WINDOW ##--
	
	local menu = vgui.Create("DFrame") bKeypads.Tutorial.Menu = menu
	menu:SetIcon("icon16/emoticon_grin.png")
	menu:SetTitle("Billy's Keypads - " .. L"Tutorial")
	menu:SetSize(w, h)
	menu:DockPadding(2, 24, 2, 2)
	menu:SetSizable(true)
	menu:MakePopup()
	menu.Paint = MenuPaint
	menu.OnClose = MenuOnClose

	menu.lblTitle:SetTextColor(bKeypads.COLOR.WHITE)
	menu.lblTitle:SetFont("bKeypads.TutorialFont")
	
	menu:SetPos((ScrW() - menu:GetWide()) / 2, ScrH())
	local y = (ScrH() + menu:GetTall()) / 2
	menu:NewAnimation(1, 0, .25).Think = function(_, pnl, f)
		local f = bKeypads.ease.OutSine(f)

		local x = pnl:GetPos()
		pnl:SetPos(x, ScrH() - (y * f))

		pnl:SetAlpha(f * 255)
	end

	--## CATEGORIES ##--

	menu.Divider = vgui.Create("DHorizontalDivider", menu)
	menu.Divider:Dock(FILL)
	menu.Divider:SetDividerWidth(2)

	menu.Categories = vgui.Create("bKeypads.SmoothScroll.CategoryList", menu)
	menu.Categories.Paint = CategoriesPaint
	menu.Divider:SetLeft(menu.Categories)

	menu.Content = vgui.Create("DPanel", menu)
	menu.Content.Paint = nil
	menu.Divider:SetRight(menu.Content)

	menu.Divider:SetLeftWidth(w * .25)

	for _, category in ipairs(bKeypads.Tutorial.Categories) do
		local categoryPnl = menu.Categories:Add(I(category.Name))
		categoryPnl.Category = category

		if category.Scenes then for _, scene in ipairs(category.Scenes) do
			if isstring(scene) then
				scene = bKeypads.Tutorial.Shortcuts[scene]
				if not scene then continue end
			end
			local scenePnl = categoryPnl:Add(I(scene.Name))
			scenePnl.Category = category
			scenePnl.Scene = scene
			scenePnl.DoClick = SceneClicked
			if scene.Tooltip then
				bKeypads:RecursiveTooltip(I(scene.Tooltip), scenePnl)
			end
		end end
	end

	--## SCENE ##--

	menu.Scene = vgui.Create("DPanel", menu.Content)
	menu.Scene:Dock(FILL)
	menu.Scene:SetVisible(false)
	menu.Scene.Paint = ScenePaint
	menu.Scene.Think = SceneThink

	hook.Run("bKeypads.BuildCPanel", menu)
end

include("bkeypads/cl_tutorial_scenes.lua")

hook.Add("bKeypads.TutorialScenes", "bKeypads.TutorialScenes.RefreshMenu", function()
	if bKeypads and bKeypads.Tutorial and IsValid(bKeypads.Tutorial.Menu) then
		bKeypads.Tutorial:OpenMenu() bKeypads.Tutorial:OpenMenu()
	end
end)
--addons/bkeypads/lua/bkeypads/lib/md5.lua:
local md5 = {
  _VERSION     = "md5.lua 1.1.0",
  _DESCRIPTION = "MD5 computation in Lua (5.1-3, LuaJIT)",
  _URL         = "https://github.com/kikito/md5.lua",
  _LICENSE     = [[
    MIT LICENSE

    Copyright (c) 2013 Enrique García Cota + Adam Baldwin + hanzao + Equi 4 Software

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the
    "Software"), to deal in the Software without restriction, including
    without limitation the rights to use, copy, modify, merge, publish,
    distribute, sublicense, and/or sell copies of the Software, and to
    permit persons to whom the Software is furnished to do so, subject to
    the following conditions:

    The above copyright notice and this permission notice shall be included
    in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
    IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  ]]
}

-- bit lib implementions

local char, byte, format, rep, sub =
  string.char, string.byte, string.format, string.rep, string.sub
local bit_or, bit_and, bit_not, bit_xor, bit_rshift, bit_lshift = bit.bor, bit.band, bit.bnot, bit.bxor, bit.rshift, bit.lshift

-- convert little-endian 32-bit int to a 4-char string
local function lei2str(i)
  local f=function (s) return char( bit_and( bit_rshift(i, s), 255)) end
  return f(0)..f(8)..f(16)..f(24)
end

-- convert raw string to big-endian int
local function str2bei(s)
  local v=0
  for i=1, #s do
    v = v * 256 + byte(s, i)
  end
  return v
end

-- convert raw string to little-endian int
local function str2lei(s)
  local v=0
  for i = #s,1,-1 do
    v = v*256 + byte(s, i)
  end
  return v
end

-- cut up a string in little-endian ints of given size
local function cut_le_str(s,...)
  local o, r = 1, {}
  local args = {...}
  for i=1, #args do
    table.insert(r, str2lei(sub(s, o, o + args[i] - 1)))
    o = o + args[i]
  end
  return r
end

local swap = function (w) return str2bei(lei2str(w)) end

-- An MD5 mplementation in Lua, requires bitlib (hacked to use LuaBit from above, ugh)
-- 10/02/2001 jcw@equi4.com

local CONSTS = {
  0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee,
  0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501,
  0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be,
  0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821,
  0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa,
  0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8,
  0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed,
  0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a,
  0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c,
  0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70,
  0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05,
  0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665,
  0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039,
  0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1,
  0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1,
  0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391,
  0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476
}

local f=function (x,y,z) return bit_or(bit_and(x,y),bit_and(-x-1,z)) end
local g=function (x,y,z) return bit_or(bit_and(x,z),bit_and(y,-z-1)) end
local h=function (x,y,z) return bit_xor(x,bit_xor(y,z)) end
local i=function (x,y,z) return bit_xor(y,bit_or(x,-z-1)) end
local z=function (ff,a,b,c,d,x,s,ac)
  a=bit_and(a+ff(b,c,d)+x+ac,0xFFFFFFFF)
  -- be *very* careful that left shift does not cause rounding!
  return bit_or(bit_lshift(bit_and(a,bit_rshift(0xFFFFFFFF,s)),s),bit_rshift(a,32-s))+b
end

local function transform(A,B,C,D,X)
  local a,b,c,d=A,B,C,D
  local t=CONSTS

  a=z(f,a,b,c,d,X[ 0], 7,t[ 1])
  d=z(f,d,a,b,c,X[ 1],12,t[ 2])
  c=z(f,c,d,a,b,X[ 2],17,t[ 3])
  b=z(f,b,c,d,a,X[ 3],22,t[ 4])
  a=z(f,a,b,c,d,X[ 4], 7,t[ 5])
  d=z(f,d,a,b,c,X[ 5],12,t[ 6])
  c=z(f,c,d,a,b,X[ 6],17,t[ 7])
  b=z(f,b,c,d,a,X[ 7],22,t[ 8])
  a=z(f,a,b,c,d,X[ 8], 7,t[ 9])
  d=z(f,d,a,b,c,X[ 9],12,t[10])
  c=z(f,c,d,a,b,X[10],17,t[11])
  b=z(f,b,c,d,a,X[11],22,t[12])
  a=z(f,a,b,c,d,X[12], 7,t[13])
  d=z(f,d,a,b,c,X[13],12,t[14])
  c=z(f,c,d,a,b,X[14],17,t[15])
  b=z(f,b,c,d,a,X[15],22,t[16])

  a=z(g,a,b,c,d,X[ 1], 5,t[17])
  d=z(g,d,a,b,c,X[ 6], 9,t[18])
  c=z(g,c,d,a,b,X[11],14,t[19])
  b=z(g,b,c,d,a,X[ 0],20,t[20])
  a=z(g,a,b,c,d,X[ 5], 5,t[21])
  d=z(g,d,a,b,c,X[10], 9,t[22])
  c=z(g,c,d,a,b,X[15],14,t[23])
  b=z(g,b,c,d,a,X[ 4],20,t[24])
  a=z(g,a,b,c,d,X[ 9], 5,t[25])
  d=z(g,d,a,b,c,X[14], 9,t[26])
  c=z(g,c,d,a,b,X[ 3],14,t[27])
  b=z(g,b,c,d,a,X[ 8],20,t[28])
  a=z(g,a,b,c,d,X[13], 5,t[29])
  d=z(g,d,a,b,c,X[ 2], 9,t[30])
  c=z(g,c,d,a,b,X[ 7],14,t[31])
  b=z(g,b,c,d,a,X[12],20,t[32])

  a=z(h,a,b,c,d,X[ 5], 4,t[33])
  d=z(h,d,a,b,c,X[ 8],11,t[34])
  c=z(h,c,d,a,b,X[11],16,t[35])
  b=z(h,b,c,d,a,X[14],23,t[36])
  a=z(h,a,b,c,d,X[ 1], 4,t[37])
  d=z(h,d,a,b,c,X[ 4],11,t[38])
  c=z(h,c,d,a,b,X[ 7],16,t[39])
  b=z(h,b,c,d,a,X[10],23,t[40])
  a=z(h,a,b,c,d,X[13], 4,t[41])
  d=z(h,d,a,b,c,X[ 0],11,t[42])
  c=z(h,c,d,a,b,X[ 3],16,t[43])
  b=z(h,b,c,d,a,X[ 6],23,t[44])
  a=z(h,a,b,c,d,X[ 9], 4,t[45])
  d=z(h,d,a,b,c,X[12],11,t[46])
  c=z(h,c,d,a,b,X[15],16,t[47])
  b=z(h,b,c,d,a,X[ 2],23,t[48])

  a=z(i,a,b,c,d,X[ 0], 6,t[49])
  d=z(i,d,a,b,c,X[ 7],10,t[50])
  c=z(i,c,d,a,b,X[14],15,t[51])
  b=z(i,b,c,d,a,X[ 5],21,t[52])
  a=z(i,a,b,c,d,X[12], 6,t[53])
  d=z(i,d,a,b,c,X[ 3],10,t[54])
  c=z(i,c,d,a,b,X[10],15,t[55])
  b=z(i,b,c,d,a,X[ 1],21,t[56])
  a=z(i,a,b,c,d,X[ 8], 6,t[57])
  d=z(i,d,a,b,c,X[15],10,t[58])
  c=z(i,c,d,a,b,X[ 6],15,t[59])
  b=z(i,b,c,d,a,X[13],21,t[60])
  a=z(i,a,b,c,d,X[ 4], 6,t[61])
  d=z(i,d,a,b,c,X[11],10,t[62])
  c=z(i,c,d,a,b,X[ 2],15,t[63])
  b=z(i,b,c,d,a,X[ 9],21,t[64])

  return bit_and(A+a,0xFFFFFFFF),bit_and(B+b,0xFFFFFFFF),
         bit_and(C+c,0xFFFFFFFF),bit_and(D+d,0xFFFFFFFF)
end

----------------------------------------------------------------

local function md5_update(self, s)
  self.pos = self.pos + #s
  s = self.buf .. s
  for ii = 1, #s - 63, 64 do
    local X = cut_le_str(sub(s,ii,ii+63),4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4)
    assert(#X == 16)
    X[0] = table.remove(X,1) -- zero based!
    self.a,self.b,self.c,self.d = transform(self.a,self.b,self.c,self.d,X)
  end
  self.buf = sub(s, math.floor(#s/64)*64 + 1, #s)
  return self
end

local function md5_finish(self)
  local msgLen = self.pos
  local padLen = 56 - msgLen % 64

  if msgLen % 64 > 56 then padLen = padLen + 64 end

  if padLen == 0 then padLen = 64 end

  local s = char(128) .. rep(char(0),padLen-1) .. lei2str(bit_and(8*msgLen, 0xFFFFFFFF)) .. lei2str(math.floor(msgLen/0x20000000))
  md5_update(self, s)

  assert(self.pos % 64 == 0)
  return lei2str(self.a) .. lei2str(self.b) .. lei2str(self.c) .. lei2str(self.d)
end

----------------------------------------------------------------

function md5.new()
  return { a = CONSTS[65], b = CONSTS[66], c = CONSTS[67], d = CONSTS[68],
           pos = 0,
           buf = '',
           update = md5_update,
           finish = md5_finish }
end

function md5.tohex(s)
  return format("%08x%08x%08x%08x", str2bei(sub(s, 1, 4)), str2bei(sub(s, 5, 8)), str2bei(sub(s, 9, 12)), str2bei(sub(s, 13, 16)))
end

function md5.sum(s)
  return md5.new():update(s):finish()
end

function md5.sumhexa(s)
  return md5.tohex(md5.sum(s))
end

return md5
--addons/bkeypads/lua/bkeypads/lib/ease.lua:
-- FIXME https://github.com/Facepunch/garrysmod/pull/1755
-- probably won't get merged for years, so here we are

local math = math

local ease = {}
setfenv(1, ease)

--[[---------------------------------------------------------
	Source code of functions
-----------------------------------------------------------]]

-- https://github.com/Facepunch/garrysmod/pull/1755
-- https://web.archive.org/web/20201212082306/https://easings.net/
-- https://web.archive.org/web/20201218211606/https://raw.githubusercontent.com/ai/easings.net/master/src/easings.yml

--[[---------------------------------------------------------
	Easing constants
-----------------------------------------------------------]]

local c1 = 1.70158
local c3 = c1 + 1
local c2 = c1 * 1.525
local c4 = ( 2 * math.pi ) / 3
local c5 = ( 2 * math.pi ) / 4.5
local n1 = 7.5625
local d1 = 2.75

--[[---------------------------------------------------------
	Easing functions
-----------------------------------------------------------]]

function InSine( x )
	return 1 - math.cos( ( x * math.pi ) / 2 )
end

function OutSine( x )
	return math.sin( ( x * math.pi ) / 2 )
end

function InOutSine( x )
	return -( math.cos( math.pi * x ) - 1 ) / 2
end

function InQuad( x )
	return x * x
end

function OutQuad( x )
	return 1 - ( 1 - x ) * ( 1 - x )
end

function InOutQuad( x )
	return x < 0.5 && 2 * x * x || 1 - ( ( -2 * x + 2 ) ^ 2 ) / 2
end

function InCubic( x )
	return x * x * x
end

function OutCubic( x )
	return 1 - ( ( 1 - x ) ^ 3 )
end

function InOutCubic( x )
	return x < 0.5 && 4 * x * x * x || 1 - ( ( -2 * x + 2 ) ^ 3 ) / 2
end

function InQuart( x )
	return x * x * x * x
end

function OutQuart( x )
	return 1 - ( ( 1 - x ) ^ 4 )
end

function InOutQuart( x )
	return x < 0.5 && 8 * x * x * x * x || 1 - ( ( -2 * x + 2 ) ^ 4 ) / 2
end

function InQuint( x )
	return x * x * x * x * x
end

function OutQuint( x )
	return 1 - ( ( 1 - x ) ^ 5 )
end

function InOutQuint( x )
	return x < 0.5 && 16 * x * x * x * x * x || 1 - ( ( -2 * x + 2 ) ^ 5 ) / 2
end

function InExpo( x )
	return x == 0 && 0 || ( 2 ^ ( 10 * x - 10 ) )
end

function OutExpo( x )
	return x == 1 && 1 || 1 - ( 2 ^ ( -10 * x ) )
end

function InOutExpo( x )
	return x == 0
		&& 0
		|| x == 1
		&& 1
		|| x < 0.5 && ( 2 ^ ( 20 * x - 10 ) ) / 2
		|| ( 2 - ( 2 ^ ( -20 * x + 10 ) ) ) / 2
end

function InCirc( x )
	return 1 - math.sqrt( 1 - ( x ^ 2 ) )
end

function OutCirc( x )
	return math.sqrt( 1 - ( ( x - 1 ) ^ 2 ) )
end

function InOutCirc( x )
	return x < 0.5
		&& ( 1 - math.sqrt( 1 - ( ( 2 * x ) ^ 2 ) ) ) / 2
		|| ( math.sqrt( 1 - ( ( -2 * x + 2 ) ^ 2 ) ) + 1 ) / 2
end

function InBack( x )
	return c3 * x * x * x - c1 * x * x
end

function OutBack( x )
	return 1 + c3 * ( ( x - 1 ) ^ 3 ) + c1 * ( ( x - 1 ) ^ 2 )
end

function InOutBack( x )
	return x < 0.5
		&& ( ( ( 2 * x ) ^ 2 ) * ( ( c2 + 1 ) * 2 * x - c2 ) ) / 2
		|| ( ( ( 2 * x - 2 ) ^ 2 ) * ( ( c2 + 1 ) * ( x * 2 - 2 ) + c2 ) + 2 ) / 2
end

function InElastic( x )
	return x == 0
		&& 0
		|| x == 1
		&& 1
		|| -( 2 ^ ( 10 * x - 10 ) ) * math.sin( ( x * 10 - 10.75 ) * c4 )
end

function OutElastic( x )
	return x == 0
		&& 0
		|| x == 1
		&& 1
		|| ( 2 ^ ( -10 * x ) ) * math.sin( ( x * 10 - 0.75 ) * c4 ) + 1
end

function InOutElastic( x )
	return x == 0
		&& 0
		|| x == 1
		&& 1
		|| x < 0.5
		&& -( ( 2 ^ ( 20 * x - 10 ) ) * math.sin( ( 20 * x - 11.125 ) * c5 ) ) / 2
		|| ( ( 2 ^ ( -20 * x + 10 ) ) * math.sin( ( 20 * x - 11.125 ) * c5 ) ) / 2 + 1
end

function InBounce( x )
	return 1 - easeOutBounce( 1 - x )
end

function OutBounce( x )
	if ( x < 1 / d1 ) then
		return n1 * x * x
	elseif ( x < 2 / d1 ) then
		x = x - ( 1.5 / d1 )
		return n1 * x * x + 0.75
	elseif ( x < 2.5 / d1 ) then
		x = x - ( 2.25 / d1 )
		return n1 * x * x + 0.9375
	else
		x = x - ( 2.625 / d1 )
		return n1 * x * x + 0.984375
	end
end

function InOutBounce( x )
	return x < 0.5
		&& ( 1 - easeOutBounce( 1 - 2 * x ) ) / 2
		|| ( 1 + easeOutBounce( 2 * x - 1 ) ) / 2
end

return ease
--lua/autorun/ask.lua:
local function AddPlayerModel( name, model )

	list.Set( "PlayerOptionsModel", name, model )
	player_manager.AddValidModel( name, model )

end


AddPlayerModel( "Senator Ask",		"models/player/tiki/ask.mdl" )

--addons/ballistic_shields/lua/libraries/cl_surfacegeturl.lua:
/*
MIT License

Copyright (c) 2016 Matt Krins

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

--[[ Helper Function by StealthPaw/101kl/MattKrins. --]]
if SERVER then return end
local WebMaterials = {}
function surface.GetURL(url, w, h, time)
	if !url or !w or !h then return Material("error") end
	if WebMaterials[url] then return WebMaterials[url] end
	local WebPanel = vgui.Create( "HTML" )
	WebPanel:SetAlpha( 0 )
	WebPanel:SetSize( tonumber(w), tonumber(h) )
	WebPanel:OpenURL( url )
	WebPanel.Paint = function(self)
		if !WebMaterials[url] and self:GetHTMLMaterial() then
			WebMaterials[url] = self:GetHTMLMaterial()
			self:Remove()
		end
	end
	timer.Simple( 1 or tonumber(time), function() if IsValid(WebPanel) then WebPanel:Remove() end end ) // In case we do not render
	return Material("error")
end
--addons/ballistic_shields/lua/bs_config.lua:
include( "ballistic_shields/sh_bs_util.lua" )

--------------------- BALLISTIC SHIELDS V1.1.4 -------------------------

---- CONFIG ----
-- AVALAIBLE LANGUAGES - English
bshields.config.language = "German"
-- DISABLE HUD
bshields.config.disablehud = false
-- MINIMUM RIOT SHIELD DAMAGE
bshields.config.rshielddmgmin = 16
-- MAXIMUM RIOT SHIELD DAMAGE
bshields.config.rshielddmgmax = 25
-- HEAVY SHIELD EXPLOSION DAMAGE REDUCITON (IN %)
bshields.config.hshieldexpl = 25
-- HEAVY SHIELD MELEE DAMAGE REDUCTION (IN %)
bshields.config.hshieldmelee = 0
-- RIOT SHIELD MELEE DAMAGE REDUCTION (IN %)
bshields.config.rshieldmelee = 60
-- HEAVY SHIELD BREACH COOLDOWN (IN SECONDS)
bshields.config.hshieldcd = 20
-- DOOR RESPAWN TIMER (IN SECONDS)
bshields.config.doorrespawn = 60
-- MAXIMUM AMOUNT OF DEPLOYED SHIELDS
bshields.config.maxshields = 3
-- SHOULD FADING DOORS BE BREACHABLE?
bshields.config.breachfdoors = false
-- ALLOW BREACHING UNOWNED DOORS
bshields.config.breachudoors = false

-------- CUSTOM TEXTURES, LEAVE "" FOR DEFAULT "POLICE" TEXT. ----------
--- FOR EDITING USE THE 256x256 TEMPLATE INCLUDED IN THE MAIN FOLDER ---

-- HEAVY SHIELD
bshields.config.hShieldTexture = "https://i.imgur.com/afyGHiK.png"
-- RIOT SHIELD
bshields.config.rShieldTexture = "https://i.imgur.com/afyGHiK.png"
-- DEPLOYABLE SHIELD
bshields.config.dShieldTexture = "https://i.imgur.com/afyGHiK.png" 
-- PLAYERS MIGHT HAVE TO RECONNECT IN ORDER TO SEE THE NEW TEXTURES! ---

-- [CW2 ONLY] YOU NEED THIS ADDON: https://steamcommunity.com/sharedfiles/filedetails/?id=1771994451
-- SHOULD RIOT SHIELD BE BULLETPROOF? --
bshields.config.rshieldbp = true
--lua/autorun/ben.lua:
local function AddPlayerModel( name, model )

	list.Set( "PlayerOptionsModel", name, model )
	player_manager.AddValidModel( name, model )

end


AddPlayerModel( "Ben Kenobi",		"models/player/tiki/ben.mdl" )

--lua/autorun/egm_104th_new.lua:
-- Register the 104th material sets
hook.Add("BaseModel.RegisterMaterialSets", "EGM.CWRP.104thTrooper", function()
	-- Base 104th Trooper
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "104th_trooper", "104th - Trooper Armor", {
		["body"] = "egm/104th/trooper/body",
		["body_mirrored"] = "egm/104th/trooper/body",

		["kama"] = "egm/104th/shared/heavy",

		["pauldron"] = "egm/104th/shared/specialist",
	})
	-- 104th Trooper Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "104th_trooper", "104th - Trooper Helmet", {
		["helmet"] = "egm/104th/trooper/helmet",
		["binoculars"] = "egm/104th/shared/specialist",
        ["rangefinder"] = "egm/104th/shared/rangefinder",
	})
	-- 104th Trooper Backpack
	BaseModel:RegisterMaterialSet("models/egm/core/backpack/backpack.mdl", "104th_backpack", "104th - Trooper Backpack", {
		["backpack"] = "egm/104th/shared/heavy",
	})
	-- 104th RMC Backpack
	BaseModel:RegisterMaterialSet("models/egm/core/backpack/backpack.mdl", "104th_backpack_rmc", "104th - Trooper Backpack RMC", {
		["backpack"] = "egm/104th/rmc/heavy",
	})
	-- 104th TEB Backpack
	BaseModel:RegisterMaterialSet("models/egm/core/backpack/backpack.mdl", "104th_backpack_teb", "104th - Trooper Backpack TEB", {
		["backpack"] = "egm/104th/teb/heavy",
	})
	-- 104th Jetpack
	BaseModel:RegisterMaterialSet("models/egm/core/bp_jetpack/bp_jetpack.mdl", "104th_jetpack", "104th - Jetpack", {
		["bp_jetpack"] = "egm/104th/shared/jetpack",
	})
	-- 104th Jumppack
	BaseModel:RegisterMaterialSet("models/egm/core/bp_jumppack/bp_jumppack.mdl", "104th_jumppack", "104th - Jumppack", {
		["bp_jumppack"] = "egm/104th/shared/specialist",
	})

	-- 104th Trooper 2 Armor
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "104th_trooper_2", "104th - Trooper 2 Armor", {
		["body"] = "egm/104th/trooper/body_2",
		["body_mirrored"] = "egm/104th/trooper/body_2",

		["kama"] = "egm/104th/shared/heavy",

		["pauldron"] = "egm/104th/shared/specialist",
	})
	-- 104th Hunter Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "104th_hunter_company", "104th - Hunter Company Helmet", {
		["helmet"] = "egm/104th/trooper/helmet_variant",
		["binoculars"] = "egm/104th/shared/specialist",
        ["rangefinder"] = "egm/104th/shared/rangefinder",
	})

	-- 104th Medal 1 Armor
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "104th_medal_1", "104th - Auszeichnung 1 Armor", {
		["body"] = "egm/104th/trooper/body_arc",
		["body_mirrored"] = "egm/104th/trooper/body_arc",

		["kama"] = "egm/104th/shared/heavy",

		["pauldron"] = "egm/104th/shared/specialist",
	})
	-- 104th Medal 1 Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "104th_medal_1", "104th - Auszeichnung 1 Helmet", {
		["helmet"] = "egm/104th/trooper/helmet_arc",
		["binoculars"] = "egm/104th/shared/specialist",
        ["rangefinder"] = "egm/104th/shared/rangefinder",
	})

	-- 104th Medal 2 Armor
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "104th_medal_2", "104th - Auszeichnung 2 Armor", {
		["body"] = "egm/104th/trooper/body_officer",
		["body_mirrored"] = "egm/104th/trooper/body_officer",

		["kama"] = "egm/104th/shared/heavy",

		["pauldron"] = "egm/104th/shared/specialist",
	})
	-- 104th Medal 2 Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "104th_medal_2", "104th - Auszeichnung 2 Helmet", {
		["helmet"] = "egm/104th/trooper/helmet_officer",
		["binoculars"] = "egm/104th/shared/specialist",
        ["rangefinder"] = "egm/104th/shared/rangefinder",
	})

	-- 104th Medic Armor
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "104th_medic", "104th - Medic Armor", {
		["body"] = "egm/104th/trooper/body_med",
		["body_mirrored"] = "egm/104th/trooper/body_med",

		["kama"] = "egm/104th/shared/heavy",

		["pauldron"] = "egm/104th/shared/specialist",
	})
	-- Hunter Company
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "104th_HC", "104th - HC Armor", {
		["body"] = "egm/104th/hc/body",
		["body_mirrored"] = "egm/104th/hc/body",

		["kama"] = "egm/104th/shared/heavy",

		["pauldron"] = "egm/104th/shared/specialist",
	})
	-- 104th TEB Armor
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "104th_TEB", "104th - TEB Armor", {
		["body"] = "egm/104th/teb/body",
		["body_mirrored"] = "egm/104th/teb/body",

		["kama"] = "egm/104th/shared/heavy",

		["pauldron"] = "egm/104th/shared/specialist",
	})
    -- LORE --
	-- 104th Sinker Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "104th_sinker", "104th - Sinker Helmet", {
		["helmet"] = "egm/104th/sinker/helmet",
		["binoculars"] = "egm/104th/shared/specialist",
        ["rangefinder"] = "egm/104th/shared/rangefinder",
	})

	-- 104th Comet Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "104th_comet", "104th - Comet Helmet", {
		["helmet"] = "egm/104th/comet/helmet",
		["binoculars"] = "egm/104th/shared/specialist",
        ["rangefinder"] = "egm/104th/shared/rangefinder",
	})

	-- 104th Boost Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "104th_boost", "104th - Boost Helmet", {
		["helmet"] = "egm/104th/boost/helmet",
		["binoculars"] = "egm/104th/shared/specialist",
        ["rangefinder"] = "egm/104th/shared/rangefinder",
	})

	-- 104th Wolffe Armor
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "104th_wolffe", "104th - Wolffe Armor", {
		["body"] = "egm/104th/trooper/body",
		["body_mirrored"] = "egm/104th/trooper/body_2",
        ["antenna_shoulder"] = "egm/104th/wolffe/antenna",

		["kama_arc"] = "egm/104th/wolffe/wolffe_kama",
	})
	-- 104th Wolffe Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_barc/helmet_barc.mdl", "104th_wolffe", "104th - Wolffe Helmet", {
		["helmet_barc"] = "egm/104th/wolffe/wolffe_helmet",
		["binoculars"] = "egm/104th/shared/specialist",
        ["rangefinder"] = "egm/104th/shared/rangefinder",
	})
	-- 104th Wolffe Jetpack
	BaseModel:RegisterMaterialSet("models/egm/core/bp_jetpack/bp_jetpack.mdl", "104th_wolffe_jetpack", "104th - Wolffe Jetpack", {
		["bp_jetpack"] = "egm/104th/wolffe/wolffe_jetpack",
	})
end)
--lua/autorun/egm_archer.lua:
-- Register the Custom Char Archer Materials
hook.Add("BaseModel.RegisterMaterialSets", "EGM.CWRP.SOArcher", function()
	-- Archer Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "so_archer", "SO Archer - Armor", {
		["body"] = "egm/custom_char/so/archer/body",
		["body_mirrored"] = "egm/custom_char/so/archer/body2",

		["kama"] = "egm/specops/attachment/heavy",
		["kama_arc"] = "egm/custom_char/so/archer/kama_arc",

		["pauldron"] = "egm/specops/attachment/specialist",
		["pauldron_simple"] = "egm/specops/attachment/pauldron_simple",
		["antenna_shoulder"] = "egm/specops/attachment/antenna_shoulder",
		["antenna_back"] = "egm/specops/attachment/antenna_back",
		["ammo_arm"] = "egm/specops/attachment/specialist",
		
		["pauldron_big"] = "egm/custom_char/so/archer/gear",
		["holsters"] = "egm/custom_char/so/archer/gear",
		["pockets"] = "egm/custom_char/so/archer/gear",
		["arc_gear_body"] = "egm/custom_char/so/archer/gear",
		["arc_gear_legs"] = "egm/custom_char/so/archer/gear",
		["arc_gear_arms"] = "egm/custom_char/so/archer/gear",

		["straps_double"] = "egm/specops/attachment/heavy",
		["straps_double_grenades"] = "egm/specops/attachment/heavy",
		["straps_double_datapad"] = "egm/specops/attachment/heavy",
		["strap"] = "egm/specops/attachment/heavy",
		["strap_grenades"] = "egm/specops/attachment/heavy",
		["strap_datapad"] = "egm/specops/attachment/heavy",
	})
	-- Archer Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "so_archer", "SO Archer - Helmet", {
		["helmet"] = "egm/custom_char/so/archer/helmet",

		["arc_crest"] = "egm/custom_char/so/archer/arc_crest",

		["flashlight"] = "egm/specops/trooper/helmet",
		["camera"] = "egm/specops/attachment/camera",
		["binoculars"] = "egm/specops/attachment/specialist",

		["sunvisor"] = "egm/specops/attachment/heavy",
		["armor"] = "egm/specops/attachment/heavy",

		["rangefinder"] = "egm/specops/attachment/rangefinder",

		["antenna_big"] = "egm/specops/attachment/antenna_big",
		["antenna_ear"] = "egm/specops/attachment/antenna_ear",

		["antenna_back"] = "egm/specops/attachment/antenna_back",
	})
	-- Archer Helmet Ear
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_spec_ops/helmet_spec_ops.mdl", "so_archer", "SO Archer - Helmet SO", {
		["helmet_spec_ops"] = "egm/custom_char/so/archer/helmet2",
		["helmet_ear"] = "egm/custom_char/so/archer/helmet_ear",
		["antenna_spec_ops"] = "egm/specops/attachment/antenna",
		["flashlight"] = "egm/specops/attachment/helmet",
		["camera"] = "egm/specops/attachment/camera",
	})
	-- Spec Ops Trooper Side Backpack
	BaseModel:RegisterMaterialSet("models/egm/core/sidebag/sidebag.mdl", "Specops_trooper", "Spec Ops - Trooper Sideback", {
		["sidebag"] = "egm/specops/attachment/heavy",
		["sidebag_datapad"] = "egm/specops/attachment/heavy",
	})
	-- Spec Ops Trooper Backpack
	BaseModel:RegisterMaterialSet("models/egm/core/backpack/backpack.mdl", "Specops_trooper", "Spec Ops - Trooper Backpack", {
		["backpack"] = "egm/specops/attachment/heavy",	
	})
end)
--lua/autorun/egm_clyde.lua:
-- Register the Custom Char Clyde Materials
hook.Add("BaseModel.RegisterMaterialSets", "EGM.CWRP.187thClyde", function()
	-- Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "187th_clyde", "187th Clyde - Armor", {
        ["body"] = "egm/custom_char/187th/clyde/body",
		["body_mirrored"] = "egm/custom_char/187th/clyde/body",

        ["kama"] = "egm/custom_char/187th/clyde/heavy",
		["kama_arc"] = "egm/custom_char/187th/clyde/kama_arc",
		["holsters"] = "egm/custom_char/187th/clyde/gear",
		
		["pauldron_big"] = "egm/custom_char/187th/clyde/gear",

		["ammo_arm"] = "egm/custom_char/187th/clyde/specialist",
		["ammo_shoulder"] = "egm/custom_char/187th/clyde/heavy",

		["straps_double"] = "egm/custom_char/187th/clyde/heavy_straps",
        ["straps_double_grenades"] = "egm/custom_char/187th/clyde/heavy_straps",
        ["straps_double_datapad"] = "egm/custom_char/187th/clyde/heavy_straps",
        ["strap"] = "egm/custom_char/187th/clyde/heavy_straps",
        ["strap_grenades"] = "egm/custom_char/187th/clyde/heavy_straps",
        ["strap_datapad"] = "egm/custom_char/187th/clyde/heavy_straps",
    })

	-- Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "187th_clyde", "187th clyde - Helmet", {
		["helmet"] = "egm/custom_char/187th/clyde/helmet",
		["sunvisor"] = "egm/custom_char/187th/clyde/heavy",
		["flashlight"] = "egm/core/helmet_p2/flashlight",
		["antenna_back"] = "egm/core/helmet_p2/antenna_back",
	})
	
	-- Helmet Airborne
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_airborne/helmet_airborne.mdl", "187th_clyde", "187th clyde - Helmet Airborne", {
		["helmet_airborne"] = "egm/custom_char/187th/clyde/helmet_airborne",
		["sunvisor"] = "egm/custom_char/187th/clyde/heavy",
		["flashlight"] = "egm/core/helmet_airborne/flashlight",
		["rangefinder"] = "egm/core/helmet_airborne/rangefinder",
	})

	-- Jetpack
	BaseModel:RegisterMaterialSet("models/egm/core/bp_jetpack/bp_jetpack.mdl", "187th_clyde", "187th Clyde - Jetpack", {
		["bp_jetpack"] = "egm/custom_char/187th/clyde/bp_jetpack",
	})
end)
--lua/autorun/egm_data.lua:
-- Register the Custom Char Data Materials
hook.Add("BaseModel.RegisterMaterialSets", "EGM.CWRP.187thData", function()
	-- Data Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "187th_data", "Data Body", {
		["body"] = "egm/custom_char/187th/data/body",
		["body_mirrored"] = "egm/custom_char/187th/data/body",

        ["kama"] = "egm/187th/attachment/kama",
		["kama_arc"] = "egm/custom_char/187th/data/kama_arc",

		["pauldron_simple"] = "egm/custom_char/187th/data/pauldron_simple",
        ["pauldron"] = "egm/187th/attachment/pauldron",
		
		["holsters"] = "egm/187th/attachment/holsters",
		["pockets"] = "egm/187th/attachment/pockets",
    })
		-- Data P2 Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "187th_data", "Data Helmet", {
		["helmet"] = "egm/187th/haupteinheit/helmet",

		["binoculars"] = "egm/187th/attachment/binoculars",

		["sunvisor"] = "egm/custom_char/187th/data/heavy",
		["armor"] = "egm/custom_char/187th/data/heavy",
	})
		-- Data Barc Helmet
		BaseModel:RegisterMaterialSet("models/egm/core/helmet_barc/helmet_barc.mdl", "187th_data", "Data Barc Helmet", {
		["helmet_barc"] = "egm/custom_char/187th/data/helmet_barc",
		["sunvisor"] = "egm/custom_char/187th/data/heavy",
		["binoculars"] = "egm/187th/attachment/binoculars",
		["armor"] = "egm/custom_char/187th/data/heavy",
	})
end)
--lua/autorun/egm_dominance.lua:
-- Register the Custom Char Vapid Material Sets
hook.Add("BaseModel.RegisterMaterialSets", "EGM.CWRP.AARCVapid", function()
	-- AARC Vapid Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "aarc_vapid", "AARC Vapid - Body", {
        ["body"] = 	"egm/custom_char/aarc/dominance/body",
		["body_mirrored"] = "egm/custom_char/aarc/dominance/body",

		["kama_arc"] = "egm/custom_char/aarc/dominance/kama",

		["pauldron_big"] = "egm/custom_char/aarc/dominance/gear",
		
		["arc_gear_body"] = "egm/custom_char/aarc/dominance/gear",
		["arc_gear_legs"] = "egm/custom_char/aarc/dominance/gear",
		["arc_gear_arms"] = "egm/custom_char/aarc/dominance/gear",
    })
	-- AARC Vapid Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p1/helmet_p1.mdl", "aarc_vapid", "AARC Vapid - Helmet", {
		["helmet_p1"] = "egm/custom_char/aarc/dominance/helmet",
		["sunvisor"] = "egm/custom_char/aarc/dominance/heavy",
		["rangefinder"] = "egm/custom_char/aarc/dominance/rangefinder",
	})
	-- AARC Vapid Jetpack
	BaseModel:RegisterMaterialSet("models/egm/core/bp_jetpack/bp_jetpack.mdl", "aarc_vapid", "AARC Vapid - Jetpack", {
		["bp_jetpack"] = "egm/custom_char/aarc/dominance/jetpack",
	})
	-- AARC Vapid Backpack
	BaseModel:RegisterMaterialSet("models/egm/core/backpack/backpack.mdl", "aarc_vapid", "AARC Vapid - Backpack", {
		["backpack"] = "egm/custom_char/aarc/dominance/heavy",
	})
end)
--lua/autorun/egm_gm.lua:
-- Register the Galactic Marines material sets
hook.Add("BaseModel.RegisterMaterialSets", "EGM.CWRP.GMTrooper", function()
	-- PHASE 2 --
	-- Base GM Trooper
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "gm_trooper", "GM - P2 Trooper Armor", {
		["body"] = "egm/gm/main/p2/body",
		["body_mirrored"] = "egm/gm/main/p2/body",

		["kama"] = "egm/gm/main/p2/heavy",
		["kama_arc"] = "egm/gm/main/p2/kama_arc",

		["antenna_shoulder"] = "egm/gm/main/p2/antenna",

		["pauldron"] = "egm/gm/main/p2/specialist",
		["ammo_arm"] = "egm/gm/main/p2/specialist",
		["pauldron_simple"] = "egm/gm/main/p2/pauldron_simple",
	})
	-- GM Trooper Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "gm_trooper", "GM - P2 Trooper Helmet", {
		["helmet"] = "egm/gm/main/p2/helmet",
		["binoculars"] = "egm/gm/main/p2/specialist",
		["rangefinder"] = "egm/gm/main/p2/rangefinder",

		["sunvisor"] = "egm/gm/main/p2/heavy",
		["armor"] = "egm/gm/main/p2/heavy",
	})

	-- GM Trooper Backpack
	BaseModel:RegisterMaterialSet("models/egm/core/backpack/backpack.mdl", "gm_trooper", "GM - Trooper Backpack", {
		["backpack"] = "egm/gm/main/p2/heavy",
	})

	-- Base GM Officer
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "gm_officer", "GM - P2 Officer Armor", {
		["body"] = "egm/gm/main/p2/body_officer",
		["body_mirrored"] = "egm/gm/main/p2/body_officer",

		["kama"] = "egm/gm/main/p2/heavy",
		["kama_arc"] = "egm/gm/main/p2/kama_arc",

		["antenna_shoulder"] = "egm/gm/main/p2/antenna",

		["pauldron"] = "egm/gm/main/p2/specialist",
		["ammo_arm"] = "egm/gm/main/p2/specialist",
		["pauldron_simple"] = "egm/gm/main/p2/pauldron_simple",
	})
	-- GM Officer Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "gm_officer", "GM - P2 Officer Helmet", {
		["helmet"] = "egm/gm/main/p2/helmet_officer",
		["binoculars"] = "egm/gm/main/p2/specialist",
		["rangefinder"] = "egm/gm/main/p2/rangefinder",

		["sunvisor"] = "egm/gm/main/p2/heavy",
		["armor"] = "egm/gm/main/p2/heavy",
	})

	-- Base 44th Trooper
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "gm_44th_trooper", "GM - 44th Trooper Armor", {
		["body"] = "egm/gm/44th/p2/body",
		["body_mirrored"] = "egm/gm/44th/p2/body",

		["kama"] = "egm/gm/44th/p2/heavy",
		["kama_arc"] = "egm/gm/44th/p2/kama_arc",

		["pauldron"] = "egm/gm/44th/p2/specialist",
		["ammo_arm"] = "egm/gm/44th/p2/specialist",
		["pauldron_simple"] = "egm/gm/44th/p2/pauldron_simple",
	})
	-- 44th Trooper Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_airborne/helmet_airborne.mdl", "gm_44th_trooper", "GM - 44th Trooper Helmet", {
		["helmet_airborne"] = "egm/gm/44th/p2/helmet",
	})
	-- 44th Trooper Backpack
	BaseModel:RegisterMaterialSet("models/egm/core/backpack/backpack.mdl", "gm_44th_trooper", "GM - 44th Trooper Backpack", {
		["backpack"] = "egm/gm/44th/p2/heavy",
	})

	-- Base 44th Veteran
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "gm_44th_veteran", "GM - 44th Veteran Armor", {
		["body"] = "egm/gm/44th/p2/body_veteran",
		["body_mirrored"] = "egm/gm/44th/p2/body_veteran",

		["kama"] = "egm/gm/44th/p2/heavy",
		["kama_arc"] = "egm/gm/44th/p2/kama_arc",

		["pauldron"] = "egm/gm/44th/p2/specialist",
		["ammo_arm"] = "egm/gm/44th/p2/specialist",
		["pauldron_simple"] = "egm/gm/44th/p2/pauldron_simple",
	})
	-- 44th Trooper Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_airborne/helmet_airborne.mdl", "gm_44th_veteran", "GM - 44th Veteran Helmet", {
		["helmet_airborne"] = "egm/gm/44th/p2/helmet_veteran",
	})

	-- SYNTHMESH --
	-- Base GM Trooper
	BaseModel:RegisterMaterialSet("models/egm/core/clone_synthmesh/clone_synthmesh.mdl", "gm_trooper_s", "GM - Synthmesh Trooper Armor", {
		["body"] = "egm/gm/main/synthmesh/body",
		["synthmesh"] = "egm/gm/main/synthmesh/synthmesh",

		["kama"] = "egm/gm/main/synthmesh/kama",

		["antenna_shoulder"] = "egm/gm/main/p2/antenna",

		["pauldron"] = "egm/gm/main/p2/specialist",
	})
	-- GM Trooper Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_synthmesh/helmet_synthmesh.mdl", "gm_trooper_s", "GM - Synthmesh Trooper Helmet", {
		["helmet_synthmesh"] = "egm/gm/main/synthmesh/helmet",
	})
	-- GM Trooper Utility Backpack
	BaseModel:RegisterMaterialSet("models/egm/core/bp_utility/bp_utility.mdl", "gm_trooper_s", "GM - Synthmesh Utility Backpack", {
		["bp_utility"] = "egm/gm/main/synthmesh/backpack",
	})
	-- GM Trooper Comms Backpack
	BaseModel:RegisterMaterialSet("models/egm/core/bp_comms/bp_comms.mdl", "gm_trooper_s", "GM - Synthmesh Comms Backpack", {
		["bp_comms"] = "egm/gm/main/synthmesh/backpack_comms",
	})

	-- GM Officer Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_synthmesh/helmet_synthmesh.mdl", "gm_officer_s", "GM - Synthmesh Officer Helmet", {
		["helmet_synthmesh"] = "egm/gm/main/synthmesh/helmet_officer",
	})

	-- GM Command Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_synthmesh/helmet_synthmesh.mdl", "gm_command_s", "GM - Synthmesh Command Helmet", {
		["helmet_synthmesh"] = "egm/gm/main/synthmesh/helmet_command",
	})

	-- Base 44th Trooper
	BaseModel:RegisterMaterialSet("models/egm/core/clone_synthmesh/clone_synthmesh.mdl", "gm_44th_trooper_s", "GM - 44th Synthmesh Trooper Armor", {
		["body"] = "egm/gm/44th/synthmesh/body",
		["synthmesh"] = "egm/gm/44th/synthmesh/synthmesh",

		["kama"] = "egm/gm/44th/synthmesh/kama",

		["pauldron"] = "egm/gm/44th/p2/specialist",
	})
	-- 44th Trooper Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_synthmesh/helmet_synthmesh.mdl", "gm_44th_trooper_s", "GM - 44th Synthmesh Trooper Helmet", {
		["helmet_synthmesh"] = "egm/gm/44th/synthmesh/helmet",
	})
	-- 44th Trooper Utility Backpack
	BaseModel:RegisterMaterialSet("models/egm/core/bp_utility/bp_utility.mdl", "gm_44th_trooper_s", "GM - 44th Synthmesh Utility Backpack", {
		["bp_utility"] = "egm/gm/44th/synthmesh/backpack",
	})
	-- 44th Trooper Comms Backpack
	BaseModel:RegisterMaterialSet("models/egm/core/bp_comms/bp_comms.mdl", "gm_44th_trooper_s", "GM - 44th Synthmesh Comms Backpack", {
		["bp_comms"] = "egm/gm/44th/synthmesh/backpack_comms",
	})

	-- LORE --
	-- Base Bacara
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "gm_bacara", "GM - Bacara Armor", {
		["body"] = "egm/core/clone_armor/body",
		["body_mirrored"] = "egm/core/clone_armor/body_mirrored",

		["kama"] = "egm/gm/lore/bacara/heavy",
	})
	-- Bacara Trooper Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_lore_bacara/helmet_lore_bacara.mdl", "gm_bacara", "GM - Bacara Helmet", {
		["helmet_lore_bacara"] = "egm/core/helmet_lore_bacara/helmet_lore_bacara",
		["helmet_lore_bacara_top"] = "egm/gm/lore/bacara/helmet",
	})

	-- Base Keller Trooper
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "gm_keller", "GM - Keller Armor", {
		["body"] = "egm/gm/lore/keller/body",
		["body_mirrored"] = "egm/gm/lore/keller/body",

		["kama"] = "egm/gm/44th/p2/heavy",
		["kama_arc"] = "egm/gm/44th/p2/kama_arc",

		["pauldron"] = "egm/gm/44th/p2/specialist",
		["ammo_arm"] = "egm/gm/44th/p2/specialist",
		["pauldron_simple"] = "egm/gm/44th/p2/pauldron_simple",
	})
	-- 44th Keller Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_airborne/helmet_airborne.mdl", "gm_keller", "GM - Keller Helmet", {
		["helmet_airborne"] = "egm/gm/lore/keller/helmet",
	})
end)
--lua/autorun/egm_marvin.lua:
-- Register the Custom Char Schraubi Materials
hook.Add("BaseModel.RegisterMaterialSets", "EGM.CWRP.327thMarvin", function()
	-- Marvin Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "327th_Marvin", "327th Marvin - Armor", {
        ["body"] = "egm/custom_char/327th/marvin/body",
		["body_mirrored"] = "egm/custom_char/327th/marvin/body",

		["holsters"] = "egm/custom_char/327th/marvin/gear",
		["arc_gear_body"] = "egm/custom_char/327th/marvin/gear",
		["arc_gear_legs"] = "egm/custom_char/327th/marvin/gear",
		["arc_gear_arms"] = "egm/custom_char/327th/marvin/gear",
		["pauldron_big"] = "egm/custom_char/327th/marvin/gear",
		
		["ammo_arm"] = "egm/custom_char/327th/marvin/specialist",		
		["pauldron"] = "egm/custom_char/327th/marvin/specialist",
		["pauldron_simple"] = "egm/327th_new/trooper/pauldron_simple",
		
		["kama"] = "egm/custom_char/327th/marvin/heavy",
		["ammo_shoulder"] = "egm/custom_char/327th/marvin/heavy",
		["straps_double"] = "egm/custom_char/327th/marvin/heavy",
		["straps_double_grenades"] = "egm/custom_char/327th/marvin/heavy",
		["straps_double_datapad"] = "egm/custom_char/327th/marvin/heavy",
		["strap"] = "egm/custom_char/327th/marvin/heavy",
		["strap_grenades"] = "egm/custom_char/327th/marvin/heavy",
		["strap_datapad"] = "egm/custom_char/327th/marvin/heavy",
    })
	-- Marvin Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_barc/helmet_barc.mdl", "327th_Marvin", "327th Marvin - Helmet", {
		["helmet_barc"] = "egm/custom_char/327th/marvin/helmet_barc",
		["binoculars"] = "egm/327th_new/trooper/specialist",

	})
	-- Marvin Jumppack
	BaseModel:RegisterMaterialSet("models/egm/core/bp_jumppack/bp_jumppack.mdl", "327th_Marvin", "Marvin - Jumppack", {
		["bp_jumppack"] = "egm/custom_char/327th/marvin/specialist",
	})
	BaseModel:RegisterMaterialSet("models/egm/core/sidebag/sidebag.mdl", "327th_Marvin", "Marvin - Sideback", {
		["sidebag"] = "egm/custom_char/327th/marvin/heavy",
		["sidebag_grenades"] = "egm/custom_char/327th/marvin/heavy",
	})
end)
--lua/autorun/egm_navy.lua:
-- Register the navy material sets
hook.Add("BaseModel.RegisterMaterialSets", "EGM.CWRP.Navy", function()
	-- Taktik Abteilung
	BaseModel:RegisterMaterialSet("models/egm/core/uniform/uniform.mdl", "navy_blue", "Navy Uniform - Taktik Abteilung", {
		["body"] = "egm/navy/blue/body",
		["legs"] = "egm/navy/blue/legs",
	})

	-- Management Abteilung
	BaseModel:RegisterMaterialSet("models/egm/core/uniform/uniform.mdl", "navy_brown", "Navy Uniform - Management Abteilung", {
		["body"] = "egm/navy/brown/body",
		["legs"] = "egm/navy/brown/legs",
	})
	
	-- Intelligence
	BaseModel:RegisterMaterialSet("models/egm/core/uniform/uniform.mdl", "navy_black", "Navy Uniform - Intelligence", {
		["body"] = "egm/navy/black/body",
		["legs"] = "egm/navy/black/legs",
	})
end)
--lua/autorun/find_conflicts_hook.lua:
addon_hooks_conflict_finder = addon_hooks_conflict_finder or {}

local concommand_name
if SERVER then
	concommand_name = "find_conflicts_hook_sv"
	util.AddNetworkString( "find_conflicts_hook" )
else
	concommand_name = "find_conflicts_hook_cl"
end

local SendToSuperAdmins -- parameter set below

---------- BUILD LUA LIST FOR EACH WORKSHOP ADDON ----------
local ComprAddonsList, ComprAddonsListLen -- cache for Lua files in Workshop addons, sent to client
local net_ReceiveLuaFiles
-- addon_hooks_conflict_finder.AddonsList: Workshop addons list, only set when the 1st test starts
if SERVER then
	function addon_hooks_conflict_finder.FillAddonsList()
		local TempAddonsList = {}
		local title
		for _,addon_info in pairs( engine.GetAddons() ) do
			title = addon_info.title
			if isstring( title ) then
				local _,folders = file.Find( "*", title )
				local folder_l
				for _,folder in ipairs( folders ) do
					folder_l = string.lower( folder )
					if folder_l=="lua" or folder_l=="gamemodes" then -- only listed if contains Lua
						table.insert( TempAddonsList, title )
						break
					end
				end
			end
		end
		addon_hooks_conflict_finder.AddonsList = {}
		for _,title in ipairs( TempAddonsList ) do
			local dirs = {"lua", "gamemodes"}
			local finished = false
			local BeginLoop,EndLoop = 1,#dirs
			while !finished do
				for i=BeginLoop,EndLoop,1 do
					local _,DirListTmp = file.Find( dirs[i].."/*", title )
					for _,DirName in ipairs( DirListTmp ) do
						table.insert( dirs, dirs[i].."/"..DirName )
					end
				end
				BeginLoop = EndLoop+1
				EndLoop = #dirs
				if BeginLoop > EndLoop then
					finished = true
				end
			end
			local LuaList = {}
			for _,dir in ipairs( dirs ) do
				local files = file.Find( dir.."/*.lua", title )
				for _,f in ipairs( files ) do
					LuaList[dir.."/"..f] = true -- BEWARE OF CASE-SENSITIVE file systems
				end
			end
			addon_hooks_conflict_finder.AddonsList[title] = LuaList
		end
		ComprAddonsList = util.Compress( util.TableToJSON( addon_hooks_conflict_finder.AddonsList ) )
		ComprAddonsListLen = string.len( ComprAddonsList )
	end
	net.Receive( "find_conflicts_hook", function( len, ply )
		if !addon_hooks_conflict_finder.AddonsList then
			addon_hooks_conflict_finder.FillAddonsList()
		end
		net.Start( "find_conflicts_hook" )
			net.WriteUInt( 1, 8 )
			net.WriteUInt( ComprAddonsListLen, 32 )
			net.WriteData( ComprAddonsList, ComprAddonsListLen )
		net.Send( ply )
	end )
else
	function addon_hooks_conflict_finder.FillAddonsList()
		net.Start( "find_conflicts_hook" )
		net.SendToServer()
	end
	function net_ReceiveLuaFiles()
		addon_hooks_conflict_finder.AddonsList = util.JSONToTable( util.Decompress( net.ReadData( net.ReadUInt( 32 ) ) ) )
		KnownLuaFiles = {}
	end
end

---------- FIND LUA FILE LOCATION ----------
local KnownLuaFiles = {} -- cache for Lua file readable locations (table of paths or path+addon name)
function addon_hooks_conflict_finder.LocateLuaFile( LuaFile )
	-- WorkshopAddons must be nil when LuaFile is not contained in any Workshop addon, otherwise it must be a table of addon names.
	if !KnownLuaFiles[LuaFile] then
		local CleanLuaFile = LuaFile
		if string.sub( CleanLuaFile, 1, 9 )=="workshop/" then
			CleanLuaFile = string.sub( CleanLuaFile, 10 ) -- remove the workshop/ prefix
		end
		local WorkshopAddons
		local f
		if addon_hooks_conflict_finder.AddonsList then -- nil while client has not loaded
			for title,LuaList in pairs( addon_hooks_conflict_finder.AddonsList ) do
				if LuaList[CleanLuaFile] then -- BEWARE OF CASE-SENSITIVE file systems
					WorkshopAddons = WorkshopAddons or {}
					table.insert( WorkshopAddons, title )
				end
			end
		end
		KnownLuaFiles[LuaFile] = { -- This table can be completed with other fields if needed (legacy addons, gamemodes).
			WorkshopAddons = WorkshopAddons,
		}
	end
	return ( KnownLuaFiles[LuaFile] ).WorkshopAddons
end

---------- MESSAGE COLORS ----------
local ServerColor = Color( 255, 128, 192 )
local ResultColor
if SERVER then
	ResultColor = ServerColor
else
	ResultColor = Color( 255, 192, 0 )
end

---------- FORMAT HOOK RESULTS ----------
local FormatReturned
do
	local FormatBase = 'Event "%s", %s,\n in "%s" (lines %s to %s),\n %s, returned:%s\n\n'
	function FormatReturned( EventName, HookName, LuaFile, linedefined, lastlinedefined, foundstr, list_rarg )
		return string.format( FormatBase, EventName, HookName, LuaFile, tostring( linedefined ), tostring( lastlinedefined ), foundstr, list_rarg )
	end
end

---------- NETWORK ----------
if CLIENT then
	local function net_ReceiveRemoteReturned()
		local EventName = net.ReadString()
		local HookName = net.ReadString()
		local LuaFile = net.ReadString()
		local linedefined = net.ReadUInt( 32 )
		local lastlinedefined = net.ReadUInt( 32 )
		local foundstr = net.ReadString()
		local list_rarg = net.ReadString()
		MsgC( ServerColor, FormatReturned( EventName, HookName, LuaFile, linedefined, lastlinedefined, foundstr, list_rarg ) )
	end
	net.Receive( "find_conflicts_hook", function()
		local Type = net.ReadUInt( 8 )
		if Type == 0 then
			net_ReceiveRemoteReturned()
		elseif Type == 1 then
			net_ReceiveLuaFiles()
		end
	end )
end

---------- REPORT HOOK RESULTS ----------
local find_conflicts_hook -- function defined below
function addon_hooks_conflict_finder.ReportHookResult( EventName, HookName, HookFunction, ... )
	local Returned = { ... }
	if #Returned == 0 or ( #Returned == 1 and Returned[1] == nil ) then -- unverified condition
		return ...
	end
	-- Process HookName:
	if HookName == nil then
		HookName = "GAMEMODE"
	elseif isstring( HookName ) then
		HookName = 'hook "'..HookName..'"'
	else
		HookName = 'hook '..tostring( HookName )
	end
	-- Process info:
	local info = debug.getinfo( HookFunction, 'S' )
	-- MsgN( "info" ); PrintTable( info ) -- debug
	-- Process list_rarg:
	local list_rarg = ""
	for k,rarg in ipairs( Returned ) do
		if isstring( rarg ) then
			list_rarg = list_rarg.."\n\tArg #"..tostring( k )..' = "'..rarg..'"'
		else
			list_rarg = list_rarg.."\n\tArg #"..tostring( k )..' = '..tostring( rarg )
		end
	end
	-- Finish operation:
	local LuaFile = tostring( info.short_src )
	local foundstr
	do
		local locations = addon_hooks_conflict_finder.LocateLuaFile( LuaFile )
		if !locations then
			foundstr = "not found in Workshop addons"
		elseif #locations == 1 then
			foundstr = "found in Workshop addon « "..locations[1].." »"
		else
			foundstr = "found in Workshop addons « "..string.Implode( " », « ", locations ).." »"
		end
	end
	if CLIENT or !SendToSuperAdmins then
		MsgC( ResultColor, FormatReturned( EventName, HookName, LuaFile, info.linedefined, info.lastlinedefined, foundstr, list_rarg ) )
	else
		local superadmins = {}
		for _,ply in pairs( player.GetAll() ) do
			if ply:IsSuperAdmin() then
				superadmins[#superadmins+1] = ply
			end
		end
		if #superadmins > 0 then
			net.Start( "find_conflicts_hook" )
				net.WriteUInt( 0, 8 )
				net.WriteString( EventName )
				net.WriteString( HookName )
				net.WriteString( LuaFile )
				net.WriteUInt( info.linedefined or 0, 32 )
				net.WriteUInt( info.lastlinedefined or 0, 32 )
				net.WriteString( foundstr )
				net.WriteString( list_rarg )
			net.Send( superadmins )
		else
			find_conflicts_hook( nil, concommand_name, { EventName, 0 }, concommand_name..' "'..EventName..'" "0"' ) -- Stop sending to superadmins if none connected.
		end
	end
	return ...
end

---------- SEND MESSAGE ----------
local function NiceMsgN( ply, ... )
	if SERVER and IsValid( ply ) then
		ply:PrintMessage( HUD_PRINTCONSOLE, string.Implode( "", { ... } ) )
	else
		MsgN( ... )
	end
end

---------- START TESTS ----------
local helpstr = concommand_name.." <EventName> <0|1>\n   Displays the hook result of the specified event name in order to find a hook conflict.\n"
local CancelTests
if addon_hooks_conflict_finder.CancelTests then
	CancelTests = addon_hooks_conflict_finder.CancelTests
else
	CancelTests = {}
	addon_hooks_conflict_finder.CancelTests = CancelTests
end
function addon_hooks_conflict_finder.AddModifiedHook( EventName, HookName, HookFunction )
	if isfunction( HookFunction ) then
		local function new_HookFunction( ... )
			return addon_hooks_conflict_finder.ReportHookResult( EventName, HookName, HookFunction, HookFunction( ... ) )
		end
		addon_hooks_conflict_finder.CancelTests[EventName][HookName] = HookFunction
		-- hook.Remove( EventName, HookName ) -- useless
		addon_hooks_conflict_finder.hook_Add( EventName, HookName, new_HookFunction )
	end
end
function find_conflicts_hook( ply, cmd, args, fullstring )
	if CLIENT or !IsValid( ply ) or ply:IsSuperAdmin() then
		local EventName = args[1]
		if !isstring( EventName ) then
			NiceMsgN( ply, " - "..helpstr )
			return
		end
		if !addon_hooks_conflict_finder.AddonsList then
			addon_hooks_conflict_finder.FillAddonsList()
		end
		local start_op = tobool( tonumber( args[2] or 1 ) )
		local IsRunning = istable( CancelTests[EventName] )
		local HookTable = hook.GetTable() -- This is a copy!
		local EventFunctions = HookTable[EventName]
		local CancelTest
		if start_op then -- begin operation
			if !IsRunning then
				if IsValid( ply ) then
					SendToSuperAdmins = true
				else
					SendToSuperAdmins = false
				end
				if istable( EventFunctions ) and table.Count( EventFunctions ) > 0 then
					if !addon_hooks_conflict_finder.hook_Add then
						addon_hooks_conflict_finder.hook_Add = hook.Add
						hook.Add = function( EventName, HookName, HookFunction, ... )
							if addon_hooks_conflict_finder.CancelTests[EventName] then
								addon_hooks_conflict_finder.AddModifiedHook( EventName, HookName, HookFunction )
							else
								addon_hooks_conflict_finder.hook_Add( EventName, HookName, HookFunction, ... )
							end
						end
					end
					CancelTests[EventName] = {}
					CancelTest = CancelTests[EventName]
					for HookName,HookFunction in pairs( EventFunctions ) do
						addon_hooks_conflict_finder.AddModifiedHook( EventName, HookName, HookFunction )
					end
					NiceMsgN( ply, 'Conflict test started for event name "'..EventName..'"!' )
				else
					NiceMsgN( ply, 'Could find no hook with event name "'..EventName..'"!' )
					return
				end
				if isfunction( GAMEMODE[EventName] ) then
					local HookFunction = GAMEMODE[EventName]
					local function new_HookFunction( ... )
						return addon_hooks_conflict_finder.ReportHookResult( EventName, nil, HookFunction, HookFunction( ... ) )
					end
					CancelTest[GAMEMODE] = HookFunction -- to be restored first
					GAMEMODE[EventName] = new_HookFunction
				end
			else
				NiceMsgN( ply, 'Conflict test is already started for event name "'..EventName..'"!' )
			end
		else -- finish operation
			if IsRunning then
				local CancelTest = CancelTests[EventName]
				if CancelTest[GAMEMODE] != nil then
					GAMEMODE[EventName] = CancelTest[GAMEMODE]
					CancelTest[GAMEMODE] = nil
				end
				for HookName,HookFunction in pairs( EventFunctions ) do -- Check the current hooks instead of the cancel list in case of removed hooks while the test was running.
					if CancelTest[HookName] != nil then
						-- hook.Remove( EventName, HookName ) -- useless
						addon_hooks_conflict_finder.hook_Add( EventName, HookName, CancelTest[HookName] )
					end
				end
				CancelTests[EventName] = nil
				NiceMsgN( ply, 'Conflict test is now stopped for event name "'..EventName..'"!' )
			else
				NiceMsgN( ply, 'Conflict test is not running for event name "'..EventName..'"!' )
			end
		end
	end
end
concommand.Add( concommand_name, find_conflicts_hook, nil, helpstr, 0 )

--addons/fprofiler/lua/fprofiler/report.lua:
local function getData()
	local callCounts = FProfiler.Internal.getCallCounts()
	local inclusiveTimes = FProfiler.Internal.getInclusiveTimes()
	local funcNames = FProfiler.Internal.getFunctionNames()

	local data = {}
	for func, called in pairs(callCounts) do
		local row = {}
		row.func = func
		row.info = debug.getinfo(func, "nfS")
		row.total_called = called
		row.total_time = inclusiveTimes[func] or 0
		row.average_time = row.total_time / row.total_called

		row.name, row.namewhat = nil, nil

		row.names = {}
		for name, namedata in pairs(funcNames[func]) do
			table.insert(row.names, {name = name, namewhat = namedata.namewhat, nparams = namedata.nparams})
		end

		table.insert(data, row)
	end

	return data
end

local function cull(data, count)
	if not count then return data end

	for i = count + 1, #data do
		data[i] = nil
	end

	return data
end

--[[-------------------------------------------------------------------------
The functions that are called most often
Their implementations are O(n lg n),
which is probably suboptimal but not worth my time optimising.
---------------------------------------------------------------------------]]
function FProfiler.Internal.mostOftenCalled(count)
	local sorted = getData()

	table.SortByMember(sorted, "total_called")

	return cull(sorted, count)
end

--[[-------------------------------------------------------------------------
The functions that take the longest time in total
---------------------------------------------------------------------------]]
function FProfiler.Internal.mostTimeInclusive(count)
	local sorted = getData()

	table.SortByMember(sorted, "total_time")

	return cull(sorted, count)
end

--[[-------------------------------------------------------------------------
The functions that take the longest average time
---------------------------------------------------------------------------]]
function FProfiler.Internal.mostTimeInclusiveAverage(count)
	local sorted = getData()

	table.SortByMember(sorted, "average_time")

	return cull(sorted, count)
end

--[[-------------------------------------------------------------------------
Get the top <count> of most often called, time inclusive and average
NOTE: This will almost definitely return more than <count> results.
Up to three times <count> is possible.
---------------------------------------------------------------------------]]
function FProfiler.Internal.getAggregatedResults(count)
	count = count or 100

	local dict = {}
	local mostTime = FProfiler.Internal.mostTimeInclusive(count)
	for i = 1, #mostTime do dict[mostTime[i].func] = true end

	local mostAvg = FProfiler.Internal.mostTimeInclusiveAverage(count)

	for i = 1, #mostAvg do
		if dict[mostAvg[i].func] then continue end
		dict[mostAvg[i].func] = true
		table.insert(mostTime, mostAvg[i])
	end

	local mostCalled = FProfiler.Internal.mostOftenCalled(count)

	for i = 1, #mostCalled do
		if dict[mostCalled[i].func] then continue end
		dict[mostCalled[i].func] = true
		table.insert(mostTime, mostCalled[i])
	end

	table.SortByMember(mostTime, "total_time")

	return mostTime
end

--lua/autorun/google46.lua:
list.Set( "Fenn Rau", "Fenn Rau", "models/fisher/mando/fenn/fenn.mdl" )
player_manager.AddValidModel( "Fenn Rau", "models/fisher/mando/fenn/fenn.mdl" ) 
player_manager.AddValidHands( "Fenn Rau", "models/fisher/mando/fenn/fenn_hands.mdl", 0, "00000000" ) 
--addons/gtawards/lua/autorun/gtawards_load.lua:
--------------------------------------
--     GTawards (c) 2015 - 2020     --
--                                  --
--  Created by Jakob 'ibot3' Müller --
--   and Pascal 'P4sca1' Sthamer    --
--									--
--  You are not permitted to share, --
--   	trade, give away, sell 		--
--      or otherwise distribute 	--
--------------------------------------

MsgN("[GTawards] Loading")

GTawards = GTawards or {}
GTawards.Settings = GTawards.Settings or {}
GTawards.Localization = GTawards.Localization or {}

-- {{ user_id }}
if SERVER then
	GTawards.Players = GTawards.Players or {}
	GTawards.Ranks = GTawards.Ranks or {}
	GTawards.Actions = GTawards.Actions or {}

	-- 1) Load Config
	AddCSLuaFile("gtawards/config/sh_config.lua")
	include("gtawards/config/sh_config.lua")

	-- 2) Load Localization
	AddCSLuaFile("gtawards/localization/" .. (GTawards.Locale or "en") .. ".lua")
	include ("gtawards/localization/" .. (GTawards.Locale or "en") .. ".lua")

	-- 3) Add clientside files
	AddCSLuaFile("gtawards/shared/sh_main.lua")
	AddCSLuaFile("gtawards/client/cl_admin_main.lua")
	AddCSLuaFile("gtawards/client/cl_main.lua")
	AddCSLuaFile("gtawards/client/cl_topplayers.lua")
	AddCSLuaFile("gtawards/client/cl_vgui_listview.lua")
	AddCSLuaFile("gtawards/client/cl_vgui_pageselector.lua")

	-- 4) Load serverside files
	include("gtawards/shared/sh_main.lua") -- Needs to be loaded first for translation function.
	include("gtawards/config/sv_config.lua")
	include("gtawards/server/sv_actions.lua")
	include("gtawards/server/sv_import.lua")
	include("gtawards/server/sv_main.lua")
	include("gtawards/server/sv_migrate.lua")
	include("gtawards/server/sv_ply.lua")
	include("gtawards/server/sv_rank.lua")
	include("gtawards/server/sv_server.lua")
	include("gtawards/server/sv_settings.lua")
	include("gtawards/server/sv_sql.lua")
	include("gtawards/server/sv_timepanel.lua")
	include("gtawards/server/sv_topplayers.lua")
end

if CLIENT then
	-- 1) Load config
	include("gtawards/config/sh_config.lua")

	-- 2) Load locaization
	include ("gtawards/localization/" .. (GTawards.Locale or "en") .. ".lua")

	-- 3) Load clientside files
	include("gtawards/shared/sh_main.lua") -- Needs to be loaded first for translation function.
	include("gtawards/client/cl_main.lua")
	include("gtawards/client/cl_admin_main.lua")
	include("gtawards/client/cl_topplayers.lua")
	include("gtawards/client/cl_vgui_listview.lua")
	include("gtawards/client/cl_vgui_pageselector.lua")
end

-- Localization
local locale = GTawards.Locale or "en"
if SERVER then
	AddCSLuaFile("gtawards/localization/" .. locale .. ".lua")
end
include("gtawards/localization/" .. locale .. ".lua")

hook.Run("GTawards.Loaded")

MsgN("[GTawards] Finished loading")
--addons/gtawards/lua/gtawards/config/sh_config.lua:
--------------------------------------
--     GTawards (c) 2015 - 2020     --
--                                  --
--  Created by Jakob 'ibot3' Müller --
--   and Pascal 'P4sca1' Sthamer    --
--									--
--  You are not permitted to share, --
--   	trade, give away, sell 		--
--      or otherwise distribute 	--
--------------------------------------

-- The ID of the server. Every server should have a unique numerical id!
-- Set to -1 to use the gtaw_serverid convar.
GTawards.ServerID = -1

-- A list of users (steamid64 only) that have access to the admin menu. ONLY GIVE RIGHTS TO AUTHROIZED PERSONS!
GTawards.Admins = {
	"76561198039545371"
}

-- These groups have access to the admin menu (!gtawards). ONLY GIVE RIGHTS TO AUTHORIZED PERSONS!
GTawards.AdminGroups = {
	"gruender",
	"communityleitung",
	"superadmin"
}

-- Enables debug mode.
GTawards.Debug = false

-- Whether there should be a chat notification on player rank up.
GTawards.Notifications = true

-- Whether there should be a chat notification for the 'Newbie' rank (the 1st rank).
GTawards.NewbieNotification = false

-- Whether all players should get a chat notification when one player ranks up.
GTawards.BroadcastNotifications = true

-- The sound to play on rankup. Make sure its a valid direct-download url.
-- false to disable.
GTawards.RankUpSound = "https://www.dropbox.com/s/tex1ymd03exz3dm/demonstrative.mp3?dl=1"

-- The key which opens the top player list. You can alternatively write !gtawards_top into chat.
-- Set to false to disable the key. Valid key enums can be found here: https://wiki.garrysmod.com/page/Enums/KEY.
GTawards.TopPlayerKey = false

-- Possible values: en, de, fr, ru, tr
-- Feel free to contribute another language via a support ticket!
-- Just copy localozation/en.lua and start translating.
GTawards.Locale = "de"
--addons/gtawards/lua/gtawards/localization/de.lua:
GTawards.Localization["of"] = "von"
GTawards.Localization["page"] = "Seite"
GTawards.Localization["congratulations"] = "Glückwunsch! Du bist jetzt $1!"
GTawards.Localization["rankup"] = "$1 ist jetzt $2!"

GTawards.Localization["timepanel.reached_max_rank"] = "Höchster Rang: $1"
GTawards.Localization["timepanel.time_left"] = "$1 verbleibend bis $2"

GTawards.Localization["topplayers.title"] = "Top-Spielerliste"
GTawards.Localization["topplayers.your_position"] = "Deine Position: $1"
GTawards.Localization["topplayers.name"] = "Name"
GTawards.Localization["topplayers.time"] = "Zeit"
GTawards.Localization["topplayers.rank"] = "Rang"
GTawards.Localization["topplayers.steam_profile"] = "Steam Profil"
GTawards.Localization["topplayers.loading"] = "Lädt..."
GTawards.Localization["topplayers.no_data"] = "Keine Daten"
--addons/gtawards/lua/gtawards/shared/sh_main.lua:
--------------------------------------
--     GTawards (c) 2015 - 2020     --
--                                  --
--  Created by Jakob 'ibot3' Müller --
--   and Pascal 'P4sca1' Sthamer    --
--									--
--  You are not permitted to share, --
--   	trade, give away, sell 		--
--      or otherwise distribute 	--
--------------------------------------

local Player = FindMetaTable("Player")

-- Gets the total play time of a player in seconds.
function Player:GT_GetTime()
	if SERVER then
		local playerData = GTawards:GetPlayerData(self)
		if !playerData then return 0 end

		return playerData.time + (os.time() - playerData.lastTimeSync)
	end

	if CLIENT then
		if !self.GT_Time then return 0 end
		return self.GT_Time + (os.time() - self.GT_LastTimeSync)
	end
end

-- Gets the play time of the current player session (map reloads, server restarts and disconnects reset this time).
function Player:GT_GetSessionTime()
	if SERVER then
		return self:TimeConnected()
	end

	if CLIENT then
		if !self.GT_SessionTime then return 0 end
		return self.GT_SessionTime + (os.time() - self.GT_LastTimeSync)
	end
end

-- Overwrite sam functions for getting a players time
function Player:sam_get_play_time()
	return self:GT_GetTime()
end

function Player:sam_get_session_time()
	return self:GT_GetSessionTime()
end

-- Returns whether the player has access to the admin menu.
function Player:GT_IsAdmin()
	return table.HasValue(GTawards.AdminGroups, self:GetUserGroup()) or table.HasValue(GTawards.Admins, self:SteamID64())
end

-- Prints a formatted, colored message into chat.
-- type can be either success, error or neutral.
function GTawards:Print(type, message)
	if type == "success" then
		MsgC("[GTawards] ", Color(0, 255, 0), message .. "\n")
	elseif type == "error" then
		MsgC("[GTawards] ", Color(255, 0, 0), message .. "\n")
	elseif type == "neutral" then
		MsgC("[GTawards] ", Color(255, 255, 255), message .. "\n")
	end
end

-- Converts the amount of seconds into a specific type. The following types are supported:
-- fullstring: to display time in the format xd xh xm
-- {{ user_id sha256 gtawards }}
-- string: same as fullstring but leaves out zeros.
-- table: a time table containing minutes (index 1), hours (index 2), days (index 3) and weeks (index 4).
function GTawards:ConvertTime(seconds, type)
	local none = seconds == 0

	local minutes = math.floor(seconds / 60)
	seconds       = seconds - minutes * 60 
	local hours   = math.floor(minutes / 60)
	minutes       = minutes - hours * 60 
	local days    = math.floor(hours / 24)
	hours         = hours - days * 24
	local weeks = math.floor(days / 7)
	days = days - weeks * 7

	if tostring(type) == "fullstring" then
		if none then 
			return "0w 0d 0h 0m"
		end
		
		return weeks .. "w " .. days .. "d " .. hours .. "h " .. minutes .. "m"
	elseif tostring(type) == "string" then
		local timeString = ""

		if none then
			return "0s"
		end

		if weeks > 0 then 
			timeString = weeks .. "w "
		end
		if days > 0 then 
			timeString = timeString .. days .. "d "
		end
		if hours > 0 then 
			timeString = timeString .. hours .. "h "
		end
		if minutes > 0 then 
			timeString = timeString .. minutes .. "m "
		end
		if seconds > 0 then
			timeString = timeString .. seconds .. "s"
		end

		return timeString
	elseif tostring(type) == "table" then 
		return { minutes, hours, days, weeks}
	end
end

function GTawards:Translate(key, ...)
	local locString = self.Localization[key]

	if locString then
		for k, param in pairs({...}) do
			locString = string.Replace(locString, "$" .. k, param)
		end

		return locString
	end

    return "[MISSING]"
end
--addons/gtawards/lua/gtawards/client/cl_topplayers.lua:
--------------------------------------
--     GTawards (c) 2015 - 2020     --
--                                  --
--  Created by Jakob 'ibot3' Müller --
--   and Pascal 'P4sca1' Sthamer    --
--									--
--  You are not permitted to share, --
--   	trade, give away, sell 		--
--      or otherwise distribute 	--
--------------------------------------

local NextThink = 0

function GTawards:TopPlayers_Open()
	if IsValid(GTawards.TopPlayerFrame) then GTawards.TopPlayerFrame:Close() return end
	
	local w = ScrW() * 0.6
	local h = ScrH() * 0.7
	local opened = CurTime()

	local main = vgui.Create("DFrame")
	main:SetSize(w, h)
	main:Center()
	main:SetTitle("GTawards :: " .. GTawards:Translate("topplayers.title"))
	function main:Paint(w, h)
		draw.RoundedBox(0, 0, 0, w, 24, GTawards.Color2)
		draw.RoundedBox(0, 0, 24, w, h - 24, GTawards.Color1)
	end
	function main:Think()
		if GTawards.TopPlayerKey and input.IsKeyDown(GTawards.TopPlayerKey) and opened + 0.3 <= CurTime() then
			self:Close()
			NextThink = CurTime() + 0.3
		end
	end

	local position = vgui.Create("DLabel", main)
	position:Dock(TOP)
	position:DockMargin(0, 0, 0, h * 0.03)
	position:SetTextColor(Color(255, 255, 255))
	position:SetText(GTawards:Translate("topplayers.your_position", ""))
	position:SetFont("GTawardsListViewColumn")
	position:SizeToContents()

	local playerList = vgui.Create("GTawardsListView", main)
	playerList:Dock(FILL)
	playerList:SetHeaderHeight(h * 0.05)
	playerList:SetDataHeight(h * 0.035)
	playerList:SetMultiSelect(false)
	playerList:BackgroundColor(GTawards.Color1)
	playerList:AddCustomColumn("#"):SetFixedWidth(50)
	playerList:AddCustomColumn(GTawards:Translate("topplayers.name"))
	playerList:AddCustomColumn(GTawards:Translate("topplayers.time"))
	playerList:AddCustomColumn(GTawards:Translate("topplayers.rank"))
	playerList:AddCustomColumn("SteamID64"):SetFixedWidth(0)
	playerList:HeaderBgColor(GTawards.Color2)
	playerList:GripColor(GTawards.Color2)
	playerList:LineSelectedBgColor(GTawards.Color2)
	playerList:BtnDownBgColor(GTawards.Color2)
	playerList:BtnUpBgColor(GTawards.Color2)
	playerList.Loading = true
	function playerList:Refresh(players)
		self:Clear()

		for k, v in pairs(players) do
			local line = playerList:AddCustomLine(v.position, v.name, GTawards:ConvertTime(v.time, "fullstring"), v.rank, v.steamid)
			line.steamid = v.steamid
		end
	end

	function playerList:OnRowRightClick(index, row)
		local DropDown = DermaMenu()

		DropDown:AddOption(GTawards:Translate("topplayers.steam_profile"), function() 
			gui.OpenURL("https://steamcommunity.com/profiles/" .. row.steamid)
		end):SetImage("icon16/vcard.png")

		DropDown:Open()
	end

	-- {{ user_id sha256 gtawards }}
	local playerListHint = vgui.Create("DLabel", playerList)
	playerListHint:Dock(FILL)
	playerListHint:SetText("")
	function playerListHint:Paint(width, height)
		if playerList.Loading then
			draw.SimpleText(GTawards:Translate("topplayers.loading"), "GTawardsListViewColumn", width / 2, height / 2, Color(255, 255, 255), TEXT_ALIGN_CENTER)
		elseif #playerList:GetLines() == 0 then
			draw.SimpleText(GTawards:Translate("topplayers.no_data"), "GTawardsListViewColumn", width / 2, height / 2, Color(255, 255, 255), TEXT_ALIGN_CENTER)
		end
	end

	local pageSelection = vgui.Create("GTawardsPageSelector", main)
    pageSelection:SetHeight(ScrH() * 0.025)
    pageSelection:Dock(BOTTOM)
    pageSelection:SetPage(1)
    pageSelection:SetPageCount(1)
    pageSelection:SetCallback(function(newPage)
        net.Start("GTawards.GetTopPlayers")
			net.WriteInt(newPage, 32)
		net.SendToServer()
    end)
    function pageSelection:Think()
        if playerList.Loading then
            self:SetEnabled(false)
        else
            self:SetEnabled(true)
        end
    end

	net.Receive("GTawards.GetTopPlayers", function()
		-- Handle edge case where panel is closed before topplayer list is loaded.
		if (!IsValid(main)) then return end

		local players = net.ReadTable()
		local count = net.ReadInt(32)
		position:SetText(GTawards:Translate("topplayers.your_position", tostring(net.ReadInt(32))))
		position:SizeToContents()
		playerList:Refresh(players)
		playerList.Loading = false

		-- Set the number of pages.
		local entriesPerPage = 50
		local pages = math.max(math.ceil(count / entriesPerPage), 1)
        pageSelection:SetPageCount(pages)
	end)

	net.Start("GTawards.GetTopPlayers")
		net.WriteInt(1, 32)
	net.SendToServer()

	main:MakePopup()
	GTawards.TopPlayerFrame = main
end

net.Receive("GTawards.OpenTopPlayersMenu", function()
	GTawards:TopPlayers_Open()
end)

hook.Add("Think", "GTawardsTopPlayerMenu", function()
	if NextThink <= CurTime() then
		if GTawards.TopPlayerKey and input.IsKeyDown(GTawards.TopPlayerKey) and !vgui.GetKeyboardFocus() and !gui.IsGameUIVisible() and !gui.IsConsoleVisible() then
			NextThink = CurTime() + 0.3
						
			GTawards:TopPlayers_Open()
		end
	end
end)
--addons/hbombs_base/lua/autorun/hb_emp_whitelist.lua:

if SERVER then
	AddCSLuaFile();
emp_whitelist = {"gmod_wire_pod",
	"gmod_wire_expression2",
	"gmod_wire_gate",
	"gmod_wire_value",
	"gmod_wire_button",
	"gmod_wire_dynamic_button",
	"gmod_button",
	"gmod_hoverball",
	"radio_music",
	"airraid_siren",
	"general_siren",
	"missile_detector",
	"nuclear_siren",
	"sent_tardis",
	"npc_rollermine",
	"npc_manhack",
	"npc_cscanner",
	"npc_turret_floor",
	"npc_clawscanner",
	"npc_helicopter",
	"npc_combinegunship",
	"scifi_siren"}
end

--addons/hbombs_base/lua/autorun/hb_help.lua:
AddCSLuaFile()


if (CLIENT) then
     function gbehelp( ply, text, public)
         if (string.find(text, "!hb") != nil) then
			 chat.AddText("Console commands:")
             chat.AddText("hb_easyuse [0/1] - Should nukes interact on use?")
	         chat.AddText("hb_fragility [0/1] - Should nukes arm, launch on damage?")
	         chat.AddText("hb_unfreeze [0/1] - Should nukes unfreeze stuff?")
			 chat.AddText("hb_deleteconstraints [0/1] - Should nukes delete constraints?")
			 chat.AddText("hb_explosion_damage  [0/1] - Should nukes do damage upon explosion?")
		 end
     end
end
hook.Add( "OnPlayerChat", "hbhelp", hbhelp )
--lua/autorun/hcn_citizens_male.lua:
-- Trandoshan
list.Set( "PlayerOptionsModel",  "HCN_Bossk", "models/hcn/starwars/bf/bossk/bossk.mdl" )
player_manager.AddValidModel( "HCN_Bossk", "models/hcn/starwars/bf/bossk/bossk.mdl" )
player_manager.AddValidHands( "HCN_Bossk", "models/hcn/starwars/bf/bossk/hands/bossk_hands.mdl", 0, "00000000" )

list.Set( "PlayerOptionsModel",  "HCN_Trandoshan", "models/hcn/starwars/bf/bossk/trandoshan.mdl" )
player_manager.AddValidModel( "HCN_Trandoshan", "models/hcn/starwars/bf/bossk/trandoshan.mdl" )
player_manager.AddValidHands( "HCN_Trandoshan", "models/hcn/starwars/bf/bossk/hands/bossk_hands.mdl", 0, "00000000" )


-- Alien Species
list.Set( "PlayerOptionsModel",  "HCN_Alien", "models/hcn/starwars/bf/alien/alien.mdl" )
player_manager.AddValidModel( "HCN_Alien", "models/hcn/starwars/bf/alien/alien.mdl" )
player_manager.AddValidHands( "HCN_Alien", "models/hcn/starwars/bf/human/hands/human_male_hands.mdl", 0, "00000000" )

list.Set( "PlayerOptionsModel",  "HCN_Alien_2", "models/hcn/starwars/bf/alien/alien_2.mdl" )
player_manager.AddValidModel( "HCN_Alien_2", "models/hcn/starwars/bf/alien/alien_2.mdl" )
player_manager.AddValidHands( "HCN_Alien_2", "models/hcn/starwars/bf/human/hands/human_male_hands_2.mdl", 0, "00000000" )

list.Set( "PlayerOptionsModel",  "HCN_Alien_3", "models/hcn/starwars/bf/alien/alien_3.mdl" )
player_manager.AddValidModel( "HCN_Alien_3", "models/hcn/starwars/bf/alien/alien_3.mdl" )
player_manager.AddValidHands( "HCN_Alien_3", "models/hcn/starwars/bf/human/hands/human_male_hands_3.mdl", 0, "00000000" )

list.Set( "PlayerOptionsModel",  "HCN_Alien_4", "models/hcn/starwars/bf/alien/alien_4.mdl" )
player_manager.AddValidModel( "HCN_Alien_4", "models/hcn/starwars/bf/alien/alien_4.mdl" )
player_manager.AddValidHands( "HCN_Alien_4", "models/hcn/starwars/bf/human/hands/human_male_hands_4.mdl", 0, "00000000" )

list.Set( "PlayerOptionsModel",  "HCN_Alien_5", "models/hcn/starwars/bf/alien/alien_5.mdl" )
player_manager.AddValidModel( "HCN_Alien_5", "models/hcn/starwars/bf/alien/alien_5.mdl" )
player_manager.AddValidHands( "HCN_Alien_5", "models/hcn/starwars/bf/human/hands/human_male_hands_5.mdl", 0, "00000000" )

list.Set( "PlayerOptionsModel",  "HCN_Alien_6", "models/hcn/starwars/bf/alien/alien_6.mdl" )
player_manager.AddValidModel( "HCN_Alien_6", "models/hcn/starwars/bf/alien/alien_6.mdl" )
player_manager.AddValidHands( "HCN_Alien_6", "models/hcn/starwars/bf/human/hands/human_male_hands_5.mdl", 0, "00000000" )



-- Human
list.Set( "PlayerOptionsModel",  "HCN_Human_male", "models/hcn/starwars/bf/human/human_male.mdl" )
player_manager.AddValidModel( "HCN_Human_male", "models/hcn/starwars/bf/human/human_male.mdl" )
player_manager.AddValidHands( "HCN_Human_male", "models/hcn/starwars/bf/human/hands/human_male_hands.mdl", 0, "00000000" )

list.Set( "PlayerOptionsModel",  "HCN_Human_male_2", "models/hcn/starwars/bf/human/human_male_2.mdl" )
player_manager.AddValidModel( "HCN_Human_male_2", "models/hcn/starwars/bf/human/human_male_2.mdl" )
player_manager.AddValidHands( "HCN_Human_male_2", "models/hcn/starwars/bf/human/hands/human_male_hands_2.mdl", 0, "00000000" )

list.Set( "PlayerOptionsModel",  "HCN_Human_male_3", "models/hcn/starwars/bf/human/human_male_3.mdl" )
player_manager.AddValidModel( "HCN_Human_male_3", "models/hcn/starwars/bf/human/human_male_3.mdl" )
player_manager.AddValidHands( "HCN_Human_male_3", "models/hcn/starwars/bf/human/hands/human_male_hands_3.mdl", 0, "00000000" )

list.Set( "PlayerOptionsModel",  "HCN_Human_male_4", "models/hcn/starwars/bf/human/human_male_4.mdl" )
player_manager.AddValidModel( "HCN_Human_male_4", "models/hcn/starwars/bf/human/human_male_4.mdl" )
player_manager.AddValidHands( "HCN_Human_male_4", "models/hcn/starwars/bf/human/hands/human_male_hands_4.mdl", 0, "00000000" )

list.Set( "PlayerOptionsModel",  "HCN_Human_male_5", "models/hcn/starwars/bf/human/human_male_5.mdl" )
player_manager.AddValidModel( "HCN_Human_male_5", "models/hcn/starwars/bf/human/human_male_5.mdl" )
player_manager.AddValidHands( "HCN_Human_male_5", "models/hcn/starwars/bf/human/hands/human_male_hands_5.mdl", 0, "00000000" )
--addons/hween/lua/autorun/hween.lua:
if SERVER then
	local flashLightsKilled = false
	hook.Add("PlayerSwitchFlashlight", "Hacking", function(ply, en)
		if not flashLightsKilled then return end

		if en then return false end
	end)

	hook.Add("EGMRP.Loaded", "HWeen.RegisterCommands", function()
		Chat:RegisterCommand("fltoggle", {
			enabled = true,
			commands = {"/fltoggle", "/flt"},
			execute = function(ply, args)
				flashLightsKilled = not flashLightsKilled
				if flashLightsKilled then
					for _, otherPly in pairs(player.GetHumans()) do
						otherPly:Flashlight(false)
					end

					net.Start("ChatMessage")
						net.WriteTable({"All flashlights have been killed."})
					net.Send(ply)
				else
					net.Start("ChatMessage")
						net.WriteTable({"All flashlights have been repaired."})
					net.Send(ply)
				end
			end,
			canUse = function(ply)
				if ply:IsAtLeast("eventleiter") then
					return true
				end

				return false
			end
		})

		Chat:RegisterCommand("xray", {
			enabled = true,
			commands = {"/xray"},
			execute = function(ply, args)
				ply:SetNWBool("xray", not ply:GetNWBool("xray", false))

				net.Start("ChatMessage")
					net.WriteTable({"X-Ray is now " .. (ply:GetNWBool("xray", false) and "enabled" or "disabled") .. "."})
				net.Send(ply)
			end,
			canUse = function(ply)
				if ply:IsAtLeast("eventleiter") then
					return true
				end

				return false
			end
		})
	end)
end

if CLIENT then
	hook.Add("PreDrawHalos", "Hacking", function()
		local ply = LocalPlayer()
		if not ply:GetNWBool("xray", false) then return end

		halo.Add( player.GetHumans(), Color(0, 255, 0), 5, 5, 2 , true, true)
	end)
end

--lua/autorun/ifnumbarans.lua:
list.Set( "Umbaran General", "models/player/icefusenetworks/ifnumbarangeneral.mdl"  )
player_manager.AddValidModel( "Umbaran General", "models/player/icefusenetworks/ifnumbarangeneral.mdl"  )

list.Set( "Umbaran Soldier", "models/player/icefusenetworks/ifnumbaran.mdl"  )
player_manager.AddValidModel( "Umbaran Soldier", "models/player/icefusenetworks/ifnumbaran.mdl"  )




--lua/autorun/kaminoan.lua:
local function AddPlayerModel( name, model )

	list.Set( "PlayerOptionsModel", name, model )
	player_manager.AddValidModel( name, model )

end


AddPlayerModel( "Kaminoan",		"models/player/tiki/kaminoan.mdl" )

--addons/low_health_effect/lua/autorun/lowhealth_sh.lua:
if SERVER then
	resource.AddFile("materials/vgui/vignette_w.vmt")
	resource.AddFile("sound/lowhp/hbeat.wav")
end

AddCSLuaFile()




--[[ 
#################################################
#################################################
#################################################
 DON'T TOUCH UNLESS YOU KNOW WHAT YOU'RE DOING
#################################################
#################################################
#################################################
]]
CreateConVar( "etb_healtheffect_system", 1, {FCVAR_SERVER_CAN_EXECUTE, FCVAR_NOTIFY}, "0 = Health effect OFF // 1 = Health effect ON" )

CreateConVar( "etb_heartbeat_sound", 1, {FCVAR_SERVER_CAN_EXECUTE, FCVAR_NOTIFY}, "0 = OFF // 1 = On // At certain value of health will the heartbeat sound start playing?" )

CreateConVar( "etb_redflash", 1, {FCVAR_SERVER_CAN_EXECUTE, FCVAR_NOTIFY}, "0 = OFF // 1 = On // At certain value of health will the screen flash red?" )
CreateConVar( "etb_blueflash", 1, {FCVAR_SERVER_CAN_EXECUTE, FCVAR_NOTIFY}, "0 = OFF // 1 = On // At certain value of health will the screen flash blue? (only droids)" )

CreateConVar( "etb_vignette", 1, {FCVAR_SERVER_CAN_EXECUTE, FCVAR_NOTIFY}, "0 = OFF // 1 = On // At certain value of health will the screen become darker?" )

CreateConVar( "etb_threshold", 25, {FCVAR_SERVER_CAN_EXECUTE, FCVAR_NOTIFY}, "At this point, sounds and screen will getting stronger" )

CreateConVar( "etb_muffle_sound", 1, {FCVAR_SERVER_CAN_EXECUTE, FCVAR_NOTIFY}, "0 = OFF // 1 = On // At certain value of health will the sound become muffled?" )

CreateConVar( "etb_muffle_effect", 10, {FCVAR_SERVER_CAN_EXECUTE, FCVAR_NOTIFY}, "Health value that the sounds will become muffled" )

local etb_healtheffect_system = GetConVar( "etb_healtheffect_system" )
local etb_heartbeat_sound = GetConVar( "etb_heartbeat_sound" )
local etb_redflash = GetConVar( "etb_redflash" )
local etb_blueflash = GetConVar( "etb_blueflash" )
local etb_vignette = GetConVar( "etb_vignette" )
local etb_threshold = GetConVar( "etb_threshold" )
local etb_muffle_sound = GetConVar( "etb_muffle_sound" )
local etb_muffle_effect = GetConVar( "etb_muffle_effect" )

if CLIENT then
	-- CreateClientConVar("etb_healtheffect", 1, true, true, "0 = Health effect OFF // 1 = Health effect ON")
	
	local intensity = 0
	local hpwait, hpalpha = 0, 0
	local vig = surface.GetTextureID("vgui/vignette_w")
	
	local clr = {
		[ "$pp_colour_addr" ] = 0,
		[ "$pp_colour_addg" ] = 0,
		[ "$pp_colour_addb" ] = 0,
		[ "$pp_colour_brightness" ] = 0,
		[ "$pp_colour_contrast" ] = 1,
		[ "$pp_colour_colour" ] = 1,
		[ "$pp_colour_mulr" ] = 0,
		[ "$pp_colour_mulg" ] = 0,
		[ "$pp_colour_mulb" ] = 0
	}

	local function LowHP_HUDPaint()
		if etb_healtheffect_system:GetInt() == 0 then
			return 
		end
		
		local ply = LocalPlayer()
		local hp = ply:Health()
		local x, y = ScrW(), ScrH()
		local FT = FrameTime()
		
		if etb_muffle_sound:GetInt() then
			if ply:Health() <= etb_muffle_effect:GetInt() then
				if not ply.lastDSP then
					ply:SetDSP(14)
					ply.lastDSP = 14
				end
			else
				if ply.lastDSP then
					ply:SetDSP(0)
					ply.lastDSP = nil
				end
			end
		end
		

		intensity = math.Approach(intensity, math.Clamp(1 - math.Clamp(hp / etb_threshold:GetInt(), 0, 1), 0, 1), FT * 3)

local BypassModels = {
	"models/kingpommes/starwars/playermodels/astromech.mdl",
	"models/kingpommes/starwars/playermodels/gnk.mdl",
	"models/kingpommes/starwars/playermodels/lin.mdl",
	"models/kingpommes/starwars/playermodels/mouse.mdl",
	"models/kingpommes/starwars/playermodels/wed.mdl",
	"models/kingpommes/starwars/misc/droids/r5_j2.mdl",
	"models/kingpommes/starwars/misc/droids/r4_i9.mdl",
	"models/sally/tkaro/bx_commando_droid.mdl",
	"models/player/hydro/b2_battledroid/b2_battledroid.mdl",
	"models/player/hydro/b1_battledroids/specialist/b1_battledroid_specialist.mdl",
	"models/player/hydro/b1_battledroids/officer/b1_battledroid_officer.mdl",
	"models/player/hydro/b1_battledroids/heavy/b1_battledroid_heavy.mdl",
	"models/player/hydro/b1_battledroids/assault/b1_battledroid_assault.mdl",
	"models/player/jellik/starwars/highsinger.mdl",
	"models/tfa/comm/gg/pm_sw_grievous.mdl",
	"models/player/t3_01.mdl",
	"models/player/t3_02.mdl",
	"models/player/t3_03.mdl",
	"models/player/t3_04.mdl",
	"models/sgg/starwars/battledroid.mdl",
	"models/player/sgg/starwars/battledroid.mdl",
	"models/sgg/starwars/battledroid_commander.mdl",
	"models/sgg/starwars/battledroid_geo.mdl",
	"models/sgg/starwars/battledroid_pilot.mdl",
	"models/sgg/starwars/battledroid_security.mdl",
	"models/player/sgg/starwars/battledroid.mdl",
	"models/player/sgg/starwars/battledroid_commander.mdl",
	"models/player/sgg/starwars/battledroid_geo.mdl",
	"models/player/sgg/starwars/battledroid_pilot.mdl",
	"models/player/sgg/starwars/battledroid_security.mdl",
	"models/player/hevoc/b1_battledroids/firefighter/b1_battledroid_firefighter.mdl",
	"models/player/hydro/b2_battledroid/b2_battledroid.mdl",
	"models/player/tiki/med_droid.mdl",
	"models/player/valley/medicaldroid.mdl",
	"models/player/valley/policedroid.mdl",
	"models/tfa/comm/gg/npc_cit_sw_droid_b1.mdl",
	"models/tfa/comm/gg/npc_cit_sw_droid_b2.mdl",
	"models/tfa/comm/gg/npc_cit_sw_droid_b2_gunvariant.mdl",
	"models/tfa/comm/gg/npc_cit_sw_droid_commander.mdl",
	"models/tfa/comm/gg/npc_cit_sw_droid_commando.mdl",
	"models/tfa/comm/gg/npc_cit_sw_droid_tactical.mdl",
	"models/tfa/comm/gg/npc_comb_sw_droid_b1.mdl",
	"models/tfa/comm/gg/npc_comb_sw_droid_b2.mdl",
	"models/tfa/comm/gg/npc_comb_sw_droid_b2_gunvariant.mdl",
	"models/tfa/comm/gg/npc_comb_sw_droid_b2_staticarm.mdl",
	"models/tfa/comm/gg/npc_comb_sw_droid_commander.mdl",
	"models/tfa/comm/gg/npc_comb_sw_droid_commando.mdl",
	"models/tfa/comm/gg/npc_comb_sw_droid_tactical.mdl",
	"models/tfa/comm/gg/npc_comb_sw_g_droid_b1.mdl",
	"models/tfa/comm/gg/npc_comb_sw_t_droid_b1.mdl",
	"models/tfa/comm/gg/npc_comb_x_droid_b1.mdl",
	"models/tfa/comm/gg/npc_reb_sw_g_droid_b1.mdl",
	"models/tfa/comm/gg/npc_reb_sw_t_droid_b1.mdl",
	"models/tfa/comm/gg/pm_sw_droid_b1.mdl",
	"models/tfa/comm/gg/pm_sw_droid_b2.mdl",
	"models/tfa/comm/gg/pm_sw_droid_b2_gunvariant.mdl",
	"models/tfa/comm/gg/pm_sw_droid_commander.mdl",
	"models/tfa/comm/gg/pm_sw_droid_commando.mdl",
	"models/tfa/comm/gg/pm_sw_droid_tactical.mdl",
	"models/tfa/comm/gg/pm_sw_g_droid_b1.mdl",
	"models/tfa/comm/gg/pm_sw_t_droid_b1.mdl",
	"models/kingpommes/emperors_tower/ph_props/gnk_droid/gnk_droid.mdl",
	"models/kingpommes/emperors_tower/ph_props/mouse_droid/mouse_droid.mdl",
	"models/kingpommes/starwars/misc/droids/gnk_550.mdl",
	"models/kingpommes/starwars/misc/droids/lin_droid.mdl",
	"models/kingpommes/starwars/misc/droids/r2_q5.mdl",
	"models/starwars/stan/droidekas/droideka.mdl",
	"models/player/r2d2.mdl",
	"models/player/r2kt.mdl",
	"models/player/r4p17.mdl",
	"models/player/r4_imperial.mdl",
	"models/player/r5blue.mdl",
	"models/tfa/comm/gg/npc_comb_magna_guard_combined.mdl",
	"models/tfa/comm/gg/npc_comb_magna_guard_season4.mdl",
	"models/tfa/comm/gg/npc_comb_magna_guard_trainer.mdl",
	"models/tfa/comm/gg/npc_reb_magna_guard_combined.mdl",
	"models/tfa/comm/gg/npc_reb_magna_guard_season4.mdl",
	"models/tfa/comm/gg/npc_reb_magna_guard_trainer.mdl",
	"models/tfa/comm/gg/pm_sw_magna_guard_combined.mdl",
	"models/tfa/comm/gg/pm_sw_magna_guard_season4.mdl",
	"models/tfa/comm/gg/pm_sw_magna_guard_trainer.mdl",
	"models/sengels/grievous/general_grievous.mdl",
	"models/tfa/comm/gg/pm_sw_grievous.mdl",
	"models/kingpommes/emperors_tower/ph_props/lin_droid/lin_droid.mdl",
	"models/kingpommes/emperors_tower/ph_props/wed_15/wed_15.mdl",
	"models/player/c3po.mdl",
	"models/tfa/comm/gg/pm_sw_magna_guard_combined.mdl",
	"models/tfa/comm/gg/pm_sw_magna_guard_season4.mdl",
	"models/tfa/comm/gg/pm_sw_magna_guard_trainer.mdl",
	"models/gonzo/narshaddaacharacters/droid1/droid1.mdl",
	"models/gonzo/narshaddaacharacters/droid2/droid2.mdl",
	"models/super_tactical_kalani/pm_droid_tactical_kalani.mdl",
	"models/super_tactical_krayt/pm_droid_tactical_krayt.mdl",
	"models/super_tactical_stuxnet/pm_droid_tactical_stuxnet.mdl",
	"models/tactical_black/pm_droid_tactical_black.mdl",
	"models/tactical_blue/pm_droid_tactical_blue.mdl",
	"models/tactical_gold/pm_droid_tactical_gold.mdl",
	"models/tactical_purple/pm_droid_tactical_purple.mdl",
	"models/tactical_red/pm_droid_tactical_red.mdl",
	"models/starwars/grady/protocol_droids/protocol-black.mdl",
	"models/player/b1battledroids/b1_base.mdl",
	"models/player/b1battledroids/b1_base_aatdriver.mdl",
	"models/player/b1battledroids/b1_base_com.mdl",
	"models/player/b1battledroids/b1_base_gen1.mdl",
	"models/player/b1battledroids/b1_base_pilot.mdl",
	"models/player/b1battledroids/b1_base_security.mdl",
	"models/player/b1battledroids/b1_base_training.mdl",
	"models/player/b1battledroids/b1_firefighter.mdl",
	"models/player/b1battledroids/b1_geo.mdl",
	"models/player/b1battledroids/b1_geo_com.mdl",
	"models/player/b1battledroids/b1_rocket.mdl",
	"models/props/starwars/medical/health_droid.mdl",
	"models/kingpommes/starwars/misc/droids/gnk_droid.mdl",
	"models/kingpommes/starwars/misc/droids/gnk_550.mdl",
	"models/ace/sw/r2.mdl",
	"models/ace/sw/r4.mdl",
	"models/ace/sw/r5.mdl",
	"models/player/ig88/ig88.mdl",
	"models/player/tiki/proxy.mdl",
	"models/pm_admiral_trench.mdl",
	"models/starwars/syphadias/props/hoth_barrack/r1_droid.mdl",
	"models/aussisengels/grievous/general_grievous.mdl",
		}

		if (table.HasValue( BypassModels, ply:GetModel())) then
			if LocalPlayer():Health() > 0 then
				if intensity > 0 then
					if etb_vignette:GetInt() == 1 then
						surface.SetDrawColor(0, 0, 0, 200 * intensity)
						surface.SetTexture(vig)
						surface.DrawTexturedRect(0, 0, x, y)
					end
					
					clr[ "$pp_colour_colour" ] = 1 - intensity
					DrawColorModify(clr)
					
					if ply:Alive() then
						local CT = CurTime()
							if etb_heartbeat_sound:GetInt() == 1 then
								if CT > hpwait then
									ply:EmitSound("summe/emp_02.mp3", 45 * intensity, 100 + 20 * intensity)
									hpwait = CT + math.Rand(0.5, 2)
								end
							end
						
						if etb_blueflash:GetInt() == 1 then
							surface.SetDrawColor(52, 222, 200, (50 * intensity) * hpalpha)
							surface.DrawTexturedRect(0, 0, x, y)
							DrawMaterialOverlay("effects/tvscreen_noise002a", 1)
							
							if CT < hpwait - 0.4 then
								hpalpha = math.Approach(hpalpha, 1, FrameTime() * 10)
							else
								hpalpha = math.Approach(hpalpha, 0.33, FrameTime() * 10)
							end
						end
					end
				end
			end
		else

		
			if LocalPlayer():Health() > 0 then
				if intensity > 0 then
					if etb_vignette:GetInt() == 1 then
						surface.SetDrawColor(0, 0, 0, 200 * intensity)
						surface.SetTexture(vig)
						surface.DrawTexturedRect(0, 0, x, y)
					end
					
					clr[ "$pp_colour_colour" ] = 1 - intensity
					DrawColorModify(clr)
					
					if ply:Alive() then
						
						if etb_redflash:GetInt() == 1 then
							local CT = CurTime()
								if etb_heartbeat_sound:GetInt() == 1 then
									if CT > hpwait then
										ply:EmitSound("lowhp/hbeat.wav", 45 * intensity, 100 + 20 * intensity)
										hpwait = CT + 0.5
									end
								end
							surface.SetDrawColor(255, 0, 0, (50 * intensity) * hpalpha)
							surface.DrawTexturedRect(0, 0, x, y)
							
							if CT < hpwait - 0.4 then
								hpalpha = math.Approach(hpalpha, 1, FrameTime() * 10)
							else
								hpalpha = math.Approach(hpalpha, 0.33, FrameTime() * 10)
							end
						end
					end
				end
			end -- end bypass
		end	
	end

	hook.Add("HUDPaint", "LowHP_HUDPaint", LowHP_HUDPaint)
end

--lua/autorun/lucien.lua:
player_manager.AddValidModel( "lucien", "models/gonzo/lucien/lucien.mdl" ) 
list.Set( "PlayerOptionsModel",  "lucien", "models/gonzo/lucien/lucien.mdl" )




--addons/lvs_base/lua/lvs_framework/init.lua:

local StartTime = SysTime()

if SERVER then
	AddCSLuaFile("includes/circles/circles.lua")
end

local function FileIsEmpty( filename )
	if file.Size( filename, "LUA" ) <= 1 then -- this is suspicous
		local data = file.Read( filename, "LUA" )

		if data and string.len( data ) <= 1 then -- confirm its empty

			print("[LVS] - refusing to load '"..filename.."'! File is Empty!" )

			return true
		end
	end

	return false
end

for _, filename in pairs( file.Find("lvs_framework/autorun/*.lua", "LUA") ) do
	if FileIsEmpty( "lvs_framework/autorun/"..filename ) then continue end

	if string.StartWith( filename, "sv_") then -- sv_ prefix only load serverside
		if SERVER then
			include("lvs_framework/autorun/"..filename)
		end

		continue
	end

	if string.StartWith( filename, "cl_") then -- cl_ prefix only load clientside
		if SERVER then
			AddCSLuaFile("lvs_framework/autorun/"..filename)
		else
			include("lvs_framework/autorun/"..filename)
		end

		continue
	end

	-- everything else is shared
	if SERVER then
		AddCSLuaFile("lvs_framework/autorun/"..filename)
	end
	include("lvs_framework/autorun/"..filename)
end

hook.Run( "LVS:Initialize" )

print("[LVS] - initialized ["..math.Round((SysTime() - StartTime) * 1000,2).."ms]")

if CLIENT then
	hook.Add( "InitPostEntity", "!!!lvscheckupdates", function()
		timer.Simple(20, function()
			LVS.CheckUpdates()

			local convar = GetConVar( "no_error_hitboxes" )

			if not convar then return end

			convar:SetBool( false )
		end)
	end )

	return
end

resource.AddWorkshop("2912816023")

local ValveWierdBlastDamageClass = {
	["npc_strider"] = true, -- takes 70 damage for each blast damage as constant value ...
	["npc_combinegunship"] = true, -- takes 44 damage as constant value ...
	["func_breakable_surf"] = true, -- this entity dont care about anything that isnt a trace attack or blast damage
}

function LVS:BlastDamage( pos, forward, attacker, inflictor, damage, damagetype, radius, force )

	local dmginfo = DamageInfo()
	dmginfo:SetAttacker( attacker )
	dmginfo:SetInflictor( inflictor )
	dmginfo:SetDamage( damage )
	dmginfo:SetDamageType( damagetype == DMG_BLAST and DMG_SONIC or damagetype )

	if damagetype ~= DMG_BLAST then
		dmginfo:SetDamagePosition( pos )
		dmginfo:SetDamageForce( forward * force )

		util.BlastDamageInfo( dmginfo, pos, radius )

		return
	end

	util.BlastDamageInfo( dmginfo, pos, radius )

	local FragmentAngle = 10
	local NumFragments = 16
	local NumFragmentsMissed = 0

	local RegisteredHits = {}

	local trace = util.TraceLine( {
		start = pos,
		endpos = pos - forward * radius,
		filter = { attacker, inflictor },
	} )

	local startpos = trace.HitPos

	for i = 1, NumFragments do
		local ang = forward:Angle() + Angle( math.random(-FragmentAngle,FragmentAngle), math.random(-FragmentAngle,FragmentAngle), 0 )
		local dir = ang:Forward()

		local endpos = pos + dir * radius

		local trace = util.TraceLine( {
			start = startpos,
			endpos = endpos,
			filter = { attacker, inflictor },
		} )

		debugoverlay.Line( startpos, trace.HitPos, 10, Color( 255, 0, 0, 255 ), true )

		if not trace.Hit then
			NumFragmentsMissed = NumFragmentsMissed + 1

			continue
		end

		if not IsValid( trace.Entity ) then continue end

		if not RegisteredHits[ trace.Entity ] then
			RegisteredHits[ trace.Entity ] = {}
		end

		table.insert( RegisteredHits[ trace.Entity ], {
			origin = trace.HitPos,
			force = forward * force,
		} )
	end

	local Hull = Vector(10,10,10)

	for _, ent in ipairs( ents.FindInSphere( pos, radius ) ) do
		if not ent.LVS or ent == inflictor or ent == attacker then continue end

		local trace = util.TraceHull( {
			start = pos,
			endpos = ent:LocalToWorld( ent:OBBCenter() ),
			mins = -Hull,
			maxs = Hull,
			whitelist = true,
			ignoreworld = true,
			filter = ent,
		} )

		debugoverlay.Line( pos, trace.HitPos, 10, Color( 255, 0, 0, 255 ), true )

		NumFragments = NumFragments + 1

		if not RegisteredHits[ ent ] then
			RegisteredHits[ ent ] = {}
		end

		table.insert( RegisteredHits[ ent ], {
			origin = trace.HitPos,
			force = forward * force,
		} )
	end

	if NumFragmentsMissed == NumFragments then return end

	local DamageBoost = NumFragments / ( NumFragments - NumFragmentsMissed )

	for ent, data in pairs( RegisteredHits ) do
		local NumHits = #data
		local AverageOrigin = vector_origin
		local AverageForce = vector_origin

		for _, HitData in pairs( data ) do
			AverageOrigin = AverageOrigin + HitData.origin
			AverageForce = AverageForce + HitData.force
		end

		AverageOrigin = AverageOrigin / NumHits
		AverageForce = AverageForce / NumHits

		local TotalDamage = ( ( NumHits * DamageBoost ) / NumFragments ) * damage

		--debugoverlay.Cross( AverageOrigin, 50, 10, Color( 255, 0, 255 ) )

		-- hack
		if ValveWierdBlastDamageClass[ ent:GetClass() ] then

			util.BlastDamage( inflictor, attacker, pos, radius, damage )

			continue
		end

		local dmginfo = DamageInfo()
		dmginfo:SetAttacker( attacker )
		dmginfo:SetInflictor( inflictor )
		dmginfo:SetDamage( TotalDamage )
		dmginfo:SetDamageForce( AverageForce )
		dmginfo:SetDamagePosition( AverageOrigin )
		dmginfo:SetDamageType( DMG_BLAST )

		ent:TakeDamageInfo( dmginfo )
	end
end

function LVS:FixVelocity()
	local tbl = physenv.GetPerformanceSettings()

	if tbl.MaxVelocity < 4000 then
		local OldVel = tbl.MaxVelocity

		tbl.MaxVelocity = 4000
		physenv.SetPerformanceSettings(tbl)

		print("[LVS] Low MaxVelocity detected! Increasing! "..OldVel.." => 4000")
	end

	if tbl.MaxAngularVelocity < 7272 then
		local OldAngVel = tbl.MaxAngularVelocity

		tbl.MaxAngularVelocity = 7272
		physenv.SetPerformanceSettings(tbl)

		print("[LVS] Low MaxAngularVelocity detected! Increasing! "..OldAngVel.." => 7272")
	end
end

hook.Add( "InitPostEntity", "!!!lvscheckupdates", function()
	timer.Simple(20, function()
		LVS.CheckUpdates()
	end)
end )
--addons/lvs_base/lua/lvs_framework/autorun/lvs_bulletsystem.lua:
local LVS = LVS

LVS._ActiveBullets = {}

function LVS:RemoveBullet( index )
	LVS._ActiveBullets[ index ] = nil
end

function LVS:GetBullet( index )
	if not LVS._ActiveBullets then return end

	return LVS._ActiveBullets[ index ]
end

local NewBullet = {}
NewBullet.__index = NewBullet 

function NewBullet:SetPos( pos )
	self.curpos = pos
end

function NewBullet:GetBulletIndex()
	return self.bulletindex
end

function NewBullet:Remove()
	local index = self.bulletindex

	if SERVER then
		-- prevents ghost bullets if the client fails to detect the hit
		net.Start( "lvs_remove_bullet", true )
			net.WriteInt( index, 13 )
		net.SendPVS( self:GetPos() )
	end

	LVS:RemoveBullet( index )
end

function NewBullet:GetPos()
	if not self.curpos then return self.Src end

	return self.curpos
end

function NewBullet:SetGravity( new )
	self.Gravity = new
end

function NewBullet:GetGravity()
	return self.Gravity or vector_origin
end

function NewBullet:GetDir()
	return self.Dir or vector_origin
end

function NewBullet:SetDir( newdir )
	self.Dir = newdir
end

function NewBullet:GetTimeAlive()
	return CurTime() - self.StartTime
end

function NewBullet:GetSpawnTime()
	if SERVER then
		return self.StartTime
	else
		return math.min( self.StartTimeCL, CurTime() ) -- time when the bullet is received on client
	end
end

function NewBullet:GetLength()
	return math.min((CurTime() - self:GetSpawnTime()) * 14,1)
end

function NewBullet:HandleWaterImpact( traceStart, traceEnd, Filter )
	if self.HasHitWater then return end

	local traceWater = util.TraceLine( {
		start = traceStart,
		endpos = traceEnd,
		filter = Filter,
		mask = MASK_WATER,
	} )

	if not traceWater.Hit then return end

	self.HasHitWater = true

	local effectdata = EffectData()
	effectdata:SetOrigin( traceWater.HitPos )
	effectdata:SetScale( 10 + self.HullSize * 0.5 )
	effectdata:SetFlags( 2 )
	util.Effect( "WaterSplash", effectdata, true, true )
end

function NewBullet:HandleFlybySound( EarPos )
	if self.Muted or not LVS.EnableBulletNearmiss then return end

	local BulletPos = self:GetPos()

	local EarDist = (EarPos - BulletPos):LengthSqr()

	if self.OldEarDist and self.OldEarDist < EarDist then

		if EarDist < 250000 then
			local effectdata = EffectData()
			effectdata:SetOrigin( EarPos + (BulletPos - EarPos):GetNormalized() * 20 )
			effectdata:SetFlags( 2 )
			util.Effect( "TracerSound", effectdata )
		end

		self.Muted = true
	end

	self.OldEarDist = EarDist
end

function NewBullet:DoBulletFlight( TimeAlive )

	local StartPos = self.Src
	local StartDirection = self.StartDir

	local Velocity = self.Velocity

	local PosOffset

	-- startpos, direction and curtime of creation is networked to client. 
	-- the bullet position is simulated by doing startpos + dir * time * velocity
	if self.EnableBallistics then
		local PosTheoretical = StartDirection * TimeAlive * Velocity

		PosOffset = PosTheoretical + self:GetGravity() * (TimeAlive ^ 2)

		self:SetDir( (StartPos + PosOffset - StartPos):GetNormalized() )
	else
		PosOffset = self.Dir * TimeAlive * Velocity
	end

	if SERVER then
		self:SetPos( StartPos + PosOffset )
	else

		-- "parent" the bullet to the vehicle for a very short time on client. This will give the illusion of the bullet not lagging behind even tho it is fired later on client
		if IsValid( self.Entity ) and self.SrcEntity then
			local mul = self:GetLength()
			local inv = 1 - mul

			self:SetPos( StartPos * mul + self.Entity:LocalToWorld( self.SrcEntity ) * inv + PosOffset )

			return
		end

		-- if no parent detected, run same code as server
		self:SetPos( StartPos + PosOffset )
	end
end

function NewBullet:OnCollide( trace )
	if CLIENT then return end

	if trace.Entity == self.LastDamageTarget then return end

	local Attacker = (IsValid( self.Attacker ) and self.Attacker) or (IsValid( self.Entity ) and self.Entity) or game.GetWorld()
	local Inflictor = (IsValid( self.Entity ) and self.Entity) or (IsValid( self.Attacker ) and self.Attacker) or game.GetWorld()

	local dmginfo = DamageInfo()
	dmginfo:SetDamage( self.Damage )
	dmginfo:SetAttacker( Attacker )
	dmginfo:SetInflictor( Inflictor )
	dmginfo:SetDamageType( DMG_AIRBOAT )
	dmginfo:SetDamagePosition( trace.HitPos )

	if self.Force1km then
		local Mul = math.min( (self.Src - trace.HitPos):Length() / 39370, 1 )
		local invMul = math.max( 1 - Mul, 0 )

		dmginfo:SetDamageForce( self.Dir * (self.Force * invMul + self.Force1km * Mul) )
	else
		dmginfo:SetDamageForce( self.Dir * self.Force )
	end

	if self.Callback then
		self.Callback( Attacker, trace, dmginfo )
	end

	if trace.Entity:GetClass() == "func_breakable_surf" then
		-- this will cause the entire thing to just fall apart
		dmginfo:SetDamageType( DMG_BLAST )
	end

	trace.Entity:DispatchTraceAttack( dmginfo, trace )

	self.LastDamageTarget = trace.Entity
end

function NewBullet:DoSplashDamage( trace )
	if not self.SplashDamage or not self.SplashDamageRadius then return false end

	if self.SplashDamageEffect ~= "" then
		local effectdata = EffectData()
		effectdata:SetOrigin( trace.HitPos )
		effectdata:SetNormal( trace.HitWorld and trace.HitNormal or self.Dir )
		effectdata:SetMagnitude( self.SplashDamageRadius / 250 )
		util.Effect( self.SplashDamageEffect, effectdata )
	end

	local Attacker = (IsValid( self.Attacker ) and self.Attacker) or (IsValid( self.Entity ) and self.Entity) or game.GetWorld()
	local Inflictor = (IsValid( self.Entity ) and self.Entity) or (IsValid( self.Attacker ) and self.Attacker) or game.GetWorld()

	LVS:BlastDamage( trace.HitPos, self.Dir, Attacker, Inflictor, self.SplashDamage, self.SplashDamageType, self.SplashDamageRadius, self.SplashDamageForce )

	self.SplashDamage = nil
	self.SplashDamageRadius = nil
	self.SplashDamageEffect = nil

	return true
end

function NewBullet:HandleCollision( traceStart, traceEnd, Filter )
	local TraceMask = self.HullSize <= 1 and MASK_SHOT_PORTAL or MASK_SHOT_HULL

	local traceLine
	local traceHull

	if self.HullTraceResult then
		traceHull = self.HullTraceResult
	else
		traceLine = util.TraceLine( {
			start = traceStart,
			endpos = traceEnd,
			filter = Filter,
			mask = TraceMask
		} )

		local trace = util.TraceHull( {
			start = traceStart,
			endpos = traceEnd,
			filter = Filter,
			mins = self.Mins,
			maxs = self.Maxs,
			mask = TraceMask,
			ignoreworld = true
		} )

		if traceLine.Entity == trace.Entity and trace.Hit and traceLine.Hit then
			trace = traceLine
		end

		if trace.Hit then
			self.HullTraceResult = trace
			traceHull = trace

			self:OnCollide( trace )

			if self:DoSplashDamage( trace ) then
				self:Remove()
			end
		else
			traceHull = { Hit = false }
		end
	end

	if not traceLine then
		traceLine = util.TraceLine( {
			start = traceStart,
			endpos = traceEnd,
			filter = Filter,
			mask = TraceMask
		} )
	end

	if not traceLine.Hit then
		return
	end

	self:OnCollide( traceLine )

	self:DoSplashDamage( traceLine )

	self:Remove()

	if SERVER then return end

	if not traceLine.HitSky then
		local effectdata = EffectData()
		effectdata:SetOrigin( traceLine.HitPos )
		effectdata:SetEntity( traceLine.Entity )
		effectdata:SetStart( traceStart )
		effectdata:SetNormal( traceLine.HitNormal )
		effectdata:SetSurfaceProp( traceLine.SurfaceProps )
		util.Effect( "Impact", effectdata )
	end
end

local function GetEarPos()
	if SERVER then return vector_origin end

	local EarPos

	local ply = LocalPlayer()
	local ViewEnt = ply:GetViewEntity()

	if ViewEnt == ply then
		if IsValid( ply:lvsGetVehicle() ) then
			EarPos = ply:lvsGetView()
		else
			EarPos = ply:GetShootPos()
		end
	else
		EarPos = ViewEnt:GetPos()
	end

	return EarPos
end

local function HandleBullets()
	local T = CurTime()
	local FT = FrameTime()

	local EarPos = GetEarPos()

	for id, bullet in pairs( LVS._ActiveBullets ) do
		if bullet:GetSpawnTime() + 5 < T then -- destroy all bullets older than 5 seconds
			bullet:Remove()

			continue
		end

		local TimeAlive = bullet:GetTimeAlive()

		if TimeAlive < 0 then continue end -- CurTime() is predicted, this can be a negative number in some cases.

		local Filter = bullet.Filter

		local traceStart = bullet:GetPos()
			bullet:DoBulletFlight( TimeAlive )
		local traceEnd = bullet:GetPos()

		if CLIENT then
			--debugoverlay.Line( traceStart, traceEnd, Color( 255, 255, 255 ), true )

			-- bullet flyby sounds
			bullet:HandleFlybySound( EarPos )

			-- bullet water impact effects
			bullet:HandleWaterImpact( traceStart, traceEnd, Filter )
		end

		bullet:HandleCollision( traceStart, traceEnd, Filter )
	end
end

local vector_one = Vector(1,1,1)

if SERVER then
	util.AddNetworkString( "lvs_fire_bullet" )
	util.AddNetworkString( "lvs_remove_bullet" )

	hook.Add( "Tick", "!!!!lvs_bullet_handler", function( ply, ent ) -- from what i understand, think can "skip" on lag, while tick still simulates all steps
		HandleBullets()
	end )

	local Index = 0
	local MaxIndex = 4094 -- this is the util.effect limit

	function LVS:FireBullet( data )

		Index = Index + 1

		if Index > MaxIndex then
			Index = 1
		end

		LVS._ActiveBullets[ Index ] = nil

		local bullet = {}

		setmetatable( bullet, NewBullet )

		bullet.TracerName = data.TracerName or "lvs_tracer_orange"
		bullet.Src = data.Src or vector_origin
		bullet.Dir = (data.Dir + VectorRand() * (data.Spread or vector_origin) * 0.5):GetNormalized()
		bullet.StartDir = bullet.Dir
		bullet.Force = data.Force or 10

		if data.Force1km then
			bullet.Force1km = data.Force1km
		end

		bullet.HullSize = data.HullSize or 5
		bullet.Mins = -vector_one * bullet.HullSize
		bullet.Maxs = vector_one * bullet.HullSize
		bullet.Velocity = data.Velocity or 2500
		bullet.Attacker = IsValid( data.Attacker ) and data.Attacker or (IsValid( data.Entity ) and data.Entity or game.GetWorld())
		bullet.Damage = data.Damage or 10
		bullet.Entity = data.Entity
		if IsValid( bullet.Entity ) and bullet.Entity.GetCrosshairFilterEnts then
			bullet.Filter = bullet.Entity:GetCrosshairFilterEnts()
		else
			bullet.Filter = bullet.Entity
		end
		bullet.SrcEntity = data.SrcEntity or vector_origin
		bullet.Callback = data.Callback
		bullet.SplashDamage = data.SplashDamage
		bullet.SplashDamageForce = data.SplashDamageForce or 500
		bullet.SplashDamageRadius = data.SplashDamageRadius
		bullet.SplashDamageEffect = data.SplashDamageEffect or "lvs_bullet_impact"
		bullet.SplashDamageType = data.SplashDamageType or DMG_SONIC
		bullet.StartTime = CurTime()
		bullet.EnableBallistics = data.EnableBallistics == true

		if bullet.EnableBallistics then
			bullet:SetGravity( physenv.GetGravity() )
		end

		if InfMap then
			for _, ply in ipairs( player.GetAll() ) do
				local NewPos = Vector( bullet.Src.x, bullet.Src.y, bullet.Src.z ) - InfMap.unlocalize_vector( Vector(), ply.CHUNK_OFFSET )

				net.Start( "lvs_fire_bullet", true )
					net.WriteInt( Index, 13 )
					net.WriteString( bullet.TracerName )
					net.WriteFloat( NewPos.x )
					net.WriteFloat( NewPos.y )
					net.WriteFloat( NewPos.z )
					net.WriteAngle( bullet.Dir:Angle() )
					net.WriteFloat( bullet.StartTime )
					net.WriteFloat( bullet.HullSize )
					net.WriteEntity( bullet.Entity )
					net.WriteFloat( bullet.SrcEntity.x )
					net.WriteFloat( bullet.SrcEntity.y )
					net.WriteFloat( bullet.SrcEntity.z )
					net.WriteFloat( bullet.Velocity )
					net.WriteBool( bullet.EnableBallistics )
				net.Send( ply )
			end
		else
			net.Start( "lvs_fire_bullet", true )
				net.WriteInt( Index, 13 )
				net.WriteString( bullet.TracerName )
				net.WriteFloat( bullet.Src.x )
				net.WriteFloat( bullet.Src.y )
				net.WriteFloat( bullet.Src.z )
				net.WriteAngle( bullet.Dir:Angle() )
				net.WriteFloat( bullet.StartTime )
				net.WriteFloat( bullet.HullSize )
				net.WriteEntity( bullet.Entity )
				net.WriteFloat( bullet.SrcEntity.x )
				net.WriteFloat( bullet.SrcEntity.y )
				net.WriteFloat( bullet.SrcEntity.z )
				net.WriteFloat( bullet.Velocity )
				net.WriteBool( bullet.EnableBallistics )
			net.SendPVS( bullet.Src )
		end

		bullet.bulletindex = Index
		LVS._ActiveBullets[ Index ] = bullet
	end
else
	net.Receive( "lvs_remove_bullet", function( length )
		LVS:RemoveBullet( net.ReadInt( 13 ) )
	end)

	net.Receive( "lvs_fire_bullet", function( length )
		local Index = net.ReadInt( 13 )

		LVS._ActiveBullets[ Index ] = nil

		local bullet = {}

		setmetatable( bullet, NewBullet )

		bullet.TracerName = net.ReadString()
		bullet.Src = Vector(net.ReadFloat(),net.ReadFloat(),net.ReadFloat())
		bullet.Dir = net.ReadAngle():Forward()
		bullet.StartDir = bullet.Dir
		bullet.StartTime = net.ReadFloat()
		bullet.HullSize = net.ReadFloat()
		bullet.Mins = -vector_one * bullet.HullSize
		bullet.Maxs = vector_one * bullet.HullSize
		bullet.Entity = net.ReadEntity()
		if IsValid( bullet.Entity ) and bullet.Entity.GetCrosshairFilterEnts then
			bullet.Filter = bullet.Entity:GetCrosshairFilterEnts()
		else
			bullet.Filter = bullet.Entity
		end
		bullet.SrcEntity = Vector(net.ReadFloat(),net.ReadFloat(),net.ReadFloat())

		if bullet.SrcEntity == vector_origin then
			bullet.SrcEntity = nil
		end

		bullet.Velocity = net.ReadFloat()

		bullet.EnableBallistics = net.ReadBool()

		if bullet.EnableBallistics then
			bullet:SetGravity( physenv.GetGravity() )
		end

		bullet.StartTimeCL = CurTime() + RealFrameTime()

		local ply = LocalPlayer()

		if IsValid( ply ) then
			bullet.Muted = bullet.Entity == ply:lvsGetVehicle() or bullet.Entity:GetOwner() == ply
		end

		bullet.bulletindex = Index
		LVS._ActiveBullets[ Index ] = bullet

		local effectdata = EffectData()
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( bullet.Dir )
		effectdata:SetMaterialIndex( Index )
		util.Effect( bullet.TracerName, effectdata )
	end )

	hook.Add( "Think", "!!!!_lvs_bullet_think_cl", function()
		HandleBullets()
	end )
end
--addons/lvs_base/lua/lvs_framework/autorun/lvs_damagenotify.lua:

if CLIENT then 
	net.Receive( "lvs_hurtmarker", function( len )
		if not LVS.ShowHitMarker then return end

		local ply = LocalPlayer()

		local vehicle = ply:lvsGetVehicle()

		if not IsValid( vehicle ) then return end

		vehicle:HurtMarker( net.ReadFloat() )
	end )

	net.Receive( "lvs_hitmarker", function( len )
		if not LVS.ShowHitMarker then return end

		local ply = LocalPlayer()

		local vehicle = ply:lvsGetVehicle()

		local IsCrit = net.ReadBool()

		if not IsValid( vehicle ) then
			hook.Run( "LVS:OnHudIndicator", ply,  IsCrit and "crit" or "hit" )

			return
		end

		if IsCrit then
			vehicle:CritMarker()
		else
			vehicle:HitMarker()
		end
	end )

	net.Receive( "lvs_killmarker", function( len )
		if not LVS.ShowHitMarker then return end

		local ply = LocalPlayer()

		local vehicle = ply:lvsGetVehicle()

		if not IsValid( vehicle ) then
			hook.Run( "LVS:OnHudIndicator", ply, "kill" )

			return
		end

		vehicle:KillMarker()
	end )

	net.Receive( "lvs_armormarker", function( len )
		if not LVS.ShowHitMarker then return end

		local ply = LocalPlayer()

		local vehicle = ply:lvsGetVehicle()

		local IsDamage = net.ReadBool()

		if not IsValid( vehicle ) then
			hook.Run( "LVS:OnHudIndicator", ply, IsDamage and "armorcrit" or "armor" )

			return
		end

		vehicle:ArmorMarker( IsDamage )
	end )

	return
end

util.AddNetworkString( "lvs_hitmarker" )
util.AddNetworkString( "lvs_hurtmarker" )
util.AddNetworkString( "lvs_killmarker" )
util.AddNetworkString( "lvs_armormarker" )
--lua/autorun/mothma.lua:
local function AddPlayerModel( name, model )

	list.Set( "PlayerOptionsModel", name, model )
	player_manager.AddValidModel( name, model )

end


AddPlayerModel( "Senator Mothma",		"models/player/tiki/mothma.mdl" )

--lua/autorun/npctools_init.lua:
game.AddParticles("particles/plate_green.pcf")
PrecacheParticleSystem("plate_green")
if(SERVER) then
	AddCSLuaFile("includes/modules/json.lua")
	AddCSLuaFile("autorun/client/cl_npctools_relationships.lua")
end
--addons/openpermissions/lua/openpermissions/sh.lua:
function OpenPermissions:CreatePermissionsRegistry()
	local registry = {}
	for _, enum in pairs(OpenPermissions.ACCESS_GROUP) do registry[enum] = {} end
	return registry
end

OpenPermissions.REGISTRY = {}
OpenPermissions.REGISTRY.NETWORKED = 0
OpenPermissions.REGISTRY.FLAT_FILE = 1
function OpenPermissions:SerializeRegistry(dataType)
	if (dataType == OpenPermissions.REGISTRY.NETWORKED) then

		if (file.Exists("openpermissions_v2.dat", "DATA")) then
			-- Lazy but still probably quicker
			local data = file.Read("openpermissions_v2.dat", "DATA")
			net.WriteUInt(#data, 32)
			net.WriteData(data, #data)
		else
			net.WriteUInt(0, 32)
		end

	elseif (dataType == OpenPermissions.REGISTRY.FLAT_FILE) then

		local f = file.Open("openpermissions_v2.dat", "wb", "DATA")

		-- Write file header
		f:Write("OPENPERMISSIONS")

		local ids = {}
		local id = 0
		local ids_pos = f:Tell()
		f:Seek(ids_pos + (32 / 8)) -- Allocate a UShort for seeker position of IDs

		-- Write permissions registry
		local access_group_count = 0
		local access_group_pos = f:Tell()
		f:Seek(access_group_pos + (32 / 8))
		for access_group, accessors in pairs(OpenPermissions.PermissionsRegistry) do
			f:WriteUShort(access_group)
			access_group_count = access_group_count + 1

			local accessors_count = 0
			local accessors_pos = f:Tell()
			f:Seek(accessors_pos + (32 / 8))
			for accessor, permissions in pairs(accessors) do
				if (isnumber(accessor)) then
					f:WriteBool(false)
					f:WriteULong(accessor)
				elseif (isstring(accessor)) then
					f:WriteBool(true)
					f:WriteUShort(#accessor)
					f:Write(accessor)
				else
					error("Invalid accessor key type! (" .. type(accessor) .. ")")
				end
				accessors_count = accessors_count + 1

				local permissions_count = 0
				local permissions_pos = f:Tell()
				f:Seek(permissions_pos + (32 / 8))
				for permission_id, access in pairs(permissions) do
					if (not ids[permission_id]) then
						id = id + 1
						ids[permission_id] = id
					end
					f:WriteUShort(ids[permission_id])
					f:WriteBool(access == OpenPermissions.CHECKBOX.INHERIT)
					f:WriteBool(access == OpenPermissions.CHECKBOX.TICKED)
					permissions_count = permissions_count + 1
				end
				local pos = f:Tell()
				f:Seek(permissions_pos)
				f:WriteULong(permissions_count)
				f:Seek(pos)
			end
			local pos = f:Tell()
			f:Seek(accessors_pos)
			f:WriteULong(accessors_count)
			f:Seek(pos)
		end
		local pos = f:Tell()
		f:Seek(access_group_pos)
		f:WriteULong(access_group_count)
		f:Seek(pos)

		-- Write IDs
		local count = 0
		local countPos = f:Tell()
		f:Seek(countPos + (32 / 8)) -- We can seek back and write the count here
		for str, id in pairs(ids) do
			f:WriteUShort(#str)
			f:Write(str)
			f:WriteUShort(id)
			count = count + 1
		end
		f:Seek(countPos)
		f:WriteULong(count)

		f:Seek(ids_pos)
		f:WriteULong(countPos)

		f:Close()

		file.Write("openpermissions_v2.dat", util.Compress(file.Read("openpermissions_v2.dat", "DATA")))

	end
end
function OpenPermissions:DeserializeRegistry(dataType, stream)
	if (dataType == OpenPermissions.REGISTRY.NETWORKED) then
		
		-- Lazy but still probably quicker
		local data_len = net.ReadUInt(32)
		if (data_len == 0) then return end

		local data = net.ReadData(data_len)

		file.Write("openpermissions_networked.dat", data)
		OpenPermissions:DeserializeRegistry(OpenPermissions.REGISTRY.FLAT_FILE, "openpermissions_networked.dat")
		file.Delete("openpermissions_networked.dat")

	elseif (dataType == OpenPermissions.REGISTRY.FLAT_FILE) then
		
		local data = file.Read(stream or "openpermissions_v2.dat", "DATA")
		file.Write("openpermissions_stream.dat", util.Decompress(data))
		local f = file.Open("openpermissions_stream.dat", "rb", "DATA")

		assert(f:Read(#("OPENPERMISSIONS")) == "OPENPERMISSIONS", "Error! OpenPermissions data corrupted!")

		OpenPermissions.IDs = { Int = {}, Str = {} }
		OpenPermissions.PermissionsRegistry = OpenPermissions:CreatePermissionsRegistry()

		local ids = {}

		local pointer = f:ReadULong()
		local pos = f:Tell()
		f:Seek(pointer)

		-- Read permission IDs
		for i = 1, f:ReadULong() do
			local permission_str = f:Read(f:ReadUShort())
			local permission_id = f:ReadUShort()
			ids[permission_id] = permission_str
		end
		
		f:Seek(pos)

		-- Read permission registry
		for i = 1, f:ReadULong() do
			local access_group = f:ReadUShort()
			OpenPermissions.PermissionsRegistry[access_group] = {}
			
			for j = 1, f:ReadULong() do
				local accessor = f:ReadBool() and f:Read(f:ReadUShort()) or f:ReadULong()
				OpenPermissions.PermissionsRegistry[access_group][accessor] = {}

				for k = 1, f:ReadULong() do
					OpenPermissions.PermissionsRegistry[access_group][accessor][ids[f:ReadUShort()]] = f:ReadBool() and OpenPermissions.CHECKBOX.INHERIT or (f:ReadBool() and OpenPermissions.CHECKBOX.TICKED or OpenPermissions.CHECKBOX.CROSSED)
				end
			end
		end

		f:Close()
		file.Delete("openpermissions_stream.dat")

		return OpenPermissions.PermissionsRegistry

	end
end

function OpenPermissions:SerializeTable(tbl)
	return OpenPermissions.pon.encode(tbl)
end

function OpenPermissions:DeserializeTable(tbl)
	return OpenPermissions.pon.decode(tbl)
end

local NetworkedTblCache = {}
function OpenPermissions:ClearNetworkCache(tbl)
	NetworkedTblCache[tostring(tbl)] = nil
end
function OpenPermissions:StartNetworkTable(tbl, cache, clear_cache)
	if (tbl == OpenPermissions.PermissionsRegistry) then
		return OpenPermissions:SerializeRegistry(OpenPermissions.REGISTRY.NETWORKED)
	end

	local tbl_enc
	if (cache and not clear_cache and NetworkedTblCache[tostring(tbl)] ~= nil) then
		tbl_enc = NetworkedTblCache[tostring(tbl)]
	else
		tbl_enc = util.Compress(OpenPermissions:SerializeTable(tbl))
		if (cache) then
			NetworkedTblCache[tostring(tbl)] = tbl_enc
		end
	end
	net.WriteUInt(#tbl_enc, 32)
	net.WriteData(tbl_enc, #tbl_enc)
end
function OpenPermissions:ReceiveNetworkTable()
	local tbl_enc_len = net.ReadUInt(32)
	local tbl_dec = OpenPermissions:DeserializeTable(util.Decompress(net.ReadData(tbl_enc_len)))
	return tbl_dec
end

--## SteamIDs ##--

function OpenPermissions:SteamID64ToAccountID(steamid64)
	return OpenPermissions:SteamIDToAccountID(util.SteamIDFrom64(steamid64))
end

function OpenPermissions:SteamIDToAccountID(steamid)
	local acc32 = tonumber(steamid:sub(11))
	return (acc32 * 2) + tonumber(steamid:sub(9,9))
end

function OpenPermissions:AccountIDToSteamID(account_id)
	local sid32 = tonumber(account_id) / 2
	if (sid32 % 1 > 0) then
		return "STEAM_0:1:" .. math.floor(sid32)
	else
		return "STEAM_0:0:" .. sid32
	end
end

function OpenPermissions:AccountIDToSteamID64(account_id)
	return util.SteamIDTo64(OpenPermissions:AccountIDToSteamID(account_id))
end

--## Usergroup Management ##--

function OpenPermissions:IsUserGroup(ply, ...)
	local vararg = {...}
	if (#vararg == 1) then
		return ply:IsUserGroup(vararg[1]) or (not ply:IsBot() and hook.Run("OpenPermissions:IsUserGroup", ply, vararg[1]) == true) or false
	else
		for _,ug in ipairs(vararg) do
			if (ply:IsUserGroup(ug) or (not ply:IsBot() and hook.Run("OpenPermissions:IsUserGroup", ply, ug) == true)) then
				return true
			end
		end
		return false
	end
end

function OpenPermissions:IsUsergroups(ply, usergroups)
	local ply_usergroups = OpenPermissions:GetUserGroups(ply)
	for _,usergroup in ipairs(usergroups) do
		if (ply_usergroups[usergroup]) then
			return true
		end
	end
	return false
end

function OpenPermissions:GetUserGroups(ply)
	local usergroups_tbl = {[ply:GetUserGroup()] = true}
	if (not ply:IsBot()) then
		hook.Run("OpenPermissions:GetUserGroups", ply, usergroups_tbl)
	end
	return usergroups_tbl
end

--## Internal Operators Indexing ##--
OpenPermissions.IndexedOperators = {}
for _,_s in ipairs(OpenPermissions.Operators.SteamIDs) do
	local s = string.Trim(_s)
	if (s:find("^STEAM_%d:%d:%d+$")) then
		OpenPermissions.IndexedOperators[OpenPermissions:SteamIDToAccountID(s)] = true
	elseif (s:find("^7656119%d+$")) then
		OpenPermissions.IndexedOperators[OpenPermissions:SteamID64ToAccountID(s)] = true
	else
		OpenPermissions:Print("Invalid SteamID in config file; not a SteamID/SteamID64: \"" .. _s .. "\"", "[ERROR]", OpenPermissions.COLOR_RED)
	end
end

function OpenPermissions:IsOperator(ply)
	if (ply:IsBot()) then return false end
	if (OpenPermissions.IndexedOperators[ply:AccountID()]) then
		return true
	end
	for _,u in ipairs(OpenPermissions.Operators.Usergroups) do
		if (OpenPermissions:IsUserGroup(ply, u)) then
			return true
		end
	end
	if (hook.Run("OpenPermissions:IsOperator", ply) == true) then
		return true
	end
	return false
end

--## HasPermission, GetPermission ##--

function OpenPermissions:GetPermission(ply, permission_id, is_operator)
	if (type(ply) ~= "Player" or ply:AccountID() == nil) then
		OpenPermissions:Print("Tried to do a permission check on a non-player or a player without an assigned account ID?", "[ERROR]", OpenPermissions.COLOR_RED)
		debug.Trace()
		return false
	end
	if (ply:IsBot()) then return false end
	if (is_operator == true or (is_operator ~= false and OpenPermissions:IsOperator(ply))) then return true end
	
	local has_permission = OpenPermissions.CHECKBOX.INHERIT

	if (type(permission_id) == "table") then
		for _,v in ipairs(permission_id) do
			local r = OpenPermissions:GetPermission(ply, v)
			if (r ~= OpenPermissions.CHECKBOX.INHERIT) then
				return r
			end
		end
		return OpenPermissions.CHECKBOX.INHERIT
	end

	for usergroup in pairs(OpenPermissions:GetUserGroups(ply)) do
		local ply_usergroup_registry = OpenPermissions.PermissionsRegistry[OpenPermissions.ACCESS_GROUP.USERGROUP][usergroup]
		if (ply_usergroup_registry) then
			if (ply_usergroup_registry[permission_id] == OpenPermissions.CHECKBOX.TICKED or ply_usergroup_registry[permission_id] == true) then
				has_permission = OpenPermissions.CHECKBOX.TICKED
			elseif (ply_usergroup_registry[permission_id] == OpenPermissions.CHECKBOX.CROSSED) then
				return OpenPermissions.CHECKBOX.CROSSED
			end
		end
	end

	local ply_steamid_registry = OpenPermissions.PermissionsRegistry[OpenPermissions.ACCESS_GROUP.STEAMID][ply:AccountID()]
	if (ply_steamid_registry) then
		if (ply_steamid_registry[permission_id] == OpenPermissions.CHECKBOX.TICKED or ply_steamid_registry[permission_id] == true) then
			has_permission = OpenPermissions.CHECKBOX.TICKED
		elseif (ply_steamid_registry[permission_id] == OpenPermissions.CHECKBOX.CROSSED) then
			return OpenPermissions.CHECKBOX.CROSSED
		end
	end

	if (ply:Team()) then
		local ply_team_registry = OpenPermissions.PermissionsRegistry[OpenPermissions.ACCESS_GROUP.TEAM][OpenPermissions:GetTeamIdentifier(ply:Team())]
		if (ply_team_registry) then
			if (ply_team_registry[permission_id] == OpenPermissions.CHECKBOX.TICKED or ply_team_registry[permission_id] == true) then
				has_permission = OpenPermissions.CHECKBOX.TICKED
			elseif (ply_team_registry[permission_id] == OpenPermissions.CHECKBOX.CROSSED) then
				return OpenPermissions.CHECKBOX.CROSSED
			end
		end

		if (OpenPermissions.IsDarkRP and RPExtraTeams[ply:Team()]) then
			local ply_category_name = RPExtraTeams[ply:Team()].category
			local ply_category
			for i,category in ipairs(DarkRP.getCategories().jobs) do
				if (category.name == ply_category_name) then
					ply_category = i
					break
				end
			end
			if (ply_category) then
				local ply_category_registry = OpenPermissions.PermissionsRegistry[OpenPermissions.ACCESS_GROUP.DARKRP_CATEGORY][OpenPermissions:DarkRP_GetCategoryIdentifier(ply_category)]
				if (ply_category_registry) then
					if (ply_category_registry[permission_id] == OpenPermissions.CHECKBOX.TICKED or ply_category_registry[permission_id] == true) then
						has_permission = OpenPermissions.CHECKBOX.TICKED
					elseif (ply_category_registry[permission_id] == OpenPermissions.CHECKBOX.CROSSED) then
						return OpenPermissions.CHECKBOX.CROSSED
					end
				end
			end
		end
	end

	for name, func in pairs(OpenPermissions.LuaFunctions) do
		local lua_function_registry = OpenPermissions.PermissionsRegistry[OpenPermissions.ACCESS_GROUP.LUA_FUNCTION][name]
		if (lua_function_registry) then
			if (func(ply, permission_id) == true) then
				if (lua_function_registry[permission_id] == OpenPermissions.CHECKBOX.TICKED or lua_function_registry[permission_id] == true) then
					has_permission = OpenPermissions.CHECKBOX.TICKED
				elseif (lua_function_registry[permission_id] == OpenPermissions.CHECKBOX.CROSSED) then
					return OpenPermissions.CHECKBOX.CROSSED
				end
			end
		end
	end

	if (has_permission == OpenPermissions.CHECKBOX.INHERIT and OpenPermissions.DefaultPermissions[permission_id] == OpenPermissions.CHECKBOX.TICKED) then
		has_permission = OpenPermissions.CHECKBOX.TICKED
	end

	return has_permission
end

function OpenPermissions:HasPermission(ply, permission_id, is_operator)
	if (type(ply) ~= "Player" or ply:AccountID() == nil) then
		OpenPermissions:Print("Tried to do a permission check on a non-player or a player without an assigned account ID?", "[ERROR]", OpenPermissions.COLOR_RED)
		debug.Trace()
		return false
	end
	if (ply:IsBot()) then return false end
	if (is_operator == true or (is_operator ~= false and OpenPermissions:IsOperator(ply))) then return true end

	local has_permission = false

	if (type(permission_id) == "table") then
		for _,v in ipairs(permission_id) do
			if (OpenPermissions:HasPermission(ply, v)) then
				return true
			end
		end
		return false
	end

	for usergroup in pairs(OpenPermissions:GetUserGroups(ply)) do
		local ply_usergroup_registry = OpenPermissions.PermissionsRegistry[OpenPermissions.ACCESS_GROUP.USERGROUP][usergroup]
		if (ply_usergroup_registry) then
			if (ply_usergroup_registry[permission_id] == OpenPermissions.CHECKBOX.TICKED or ply_usergroup_registry[permission_id] == true) then
				has_permission = true
			elseif (ply_usergroup_registry[permission_id] == OpenPermissions.CHECKBOX.CROSSED) then
				return false
			end
		end
	end

	local ply_steamid_registry = OpenPermissions.PermissionsRegistry[OpenPermissions.ACCESS_GROUP.STEAMID][ply:AccountID()]
	if (ply_steamid_registry) then
		if (ply_steamid_registry[permission_id] == OpenPermissions.CHECKBOX.TICKED or ply_steamid_registry[permission_id] == true) then
			has_permission = true
		elseif (ply_steamid_registry[permission_id] == OpenPermissions.CHECKBOX.CROSSED) then
			return false
		end
	end

	if (ply:Team()) then
		local ply_team_registry = OpenPermissions.PermissionsRegistry[OpenPermissions.ACCESS_GROUP.TEAM][OpenPermissions:GetTeamIdentifier(ply:Team())]
		if (ply_team_registry) then
			if (ply_team_registry[permission_id] == OpenPermissions.CHECKBOX.TICKED or ply_team_registry[permission_id] == true) then
				has_permission = true
			elseif (ply_team_registry[permission_id] == OpenPermissions.CHECKBOX.CROSSED) then
				return false
			end
		end

		if (OpenPermissions.IsDarkRP and RPExtraTeams[ply:Team()]) then
			local ply_category_name = RPExtraTeams[ply:Team()].category
			local ply_category
			for i,category in ipairs(DarkRP.getCategories().jobs) do
				if (category.name == ply_category_name) then
					ply_category = i
					break
				end
			end
			if (ply_category) then
				local ply_category_registry = OpenPermissions.PermissionsRegistry[OpenPermissions.ACCESS_GROUP.DARKRP_CATEGORY][OpenPermissions:DarkRP_GetCategoryIdentifier(ply_category)]
				if (ply_category_registry) then
					if (ply_category_registry[permission_id] == OpenPermissions.CHECKBOX.TICKED or ply_category_registry[permission_id] == true) then
						has_permission = true
					elseif (ply_category_registry[permission_id] == OpenPermissions.CHECKBOX.CROSSED) then
						return false
					end
				end
			end
		end
	end

	for name, func in pairs(OpenPermissions.LuaFunctions) do
		local lua_function_registry = OpenPermissions.PermissionsRegistry[OpenPermissions.ACCESS_GROUP.LUA_FUNCTION][name]
		if (lua_function_registry) then
			if (func(ply, permission_id) == true) then
				if (lua_function_registry[permission_id] == OpenPermissions.CHECKBOX.TICKED or lua_function_registry[permission_id] == true) then
					has_permission = true
				elseif (lua_function_registry[permission_id] == OpenPermissions.CHECKBOX.CROSSED) then
					return false
				end
			end
		end
	end

	if (has_permission == false and OpenPermissions.DefaultPermissions[permission_id] == OpenPermissions.CHECKBOX.TICKED) then
		has_permission = true
	end

	return has_permission
end

--## Teams ##--

local team_identifier_index = {}
function OpenPermissions:GetTeamIdentifier(team_index)
	local team_identifier = hook.Run("OpenPermissions:GetTeamIdentifier", team_index)
	if (team_identifier) then
		team_identifier_index[team_identifier] = team_index
		return team_identifier
	end
	if (OpenPermissions.IsDarkRP and RPExtraTeams and team_index ~= 0) then
		if (RPExtraTeams[team_index]) then
			local team_identifier = RPExtraTeams[team_index].OPENPERMISSIONS_IDENTIFIER or RPExtraTeams[team_index].GAS_IDENTIFIER or RPExtraTeams[team_index].command
			team_identifier_index[team_identifier] = team_index
			return team_identifier
		end
	else
		local team_identifier = team.GetName(team_index)
		team_identifier_index[team_identifier] = team_index
		return team_identifier
	end
end

function OpenPermissions:GetTeamFromIdentifier(team_identifier)
	if (team_identifier == "Joining/Connecting") then return TEAM_CONNECTING end
	if (team_identifier == "Unassigned") then return TEAM_UNASSIGNED end
	if (team_identifier == "Spectator") then return TEAM_SPECTATOR end
	if (team_identifier_index[team_identifier]) then return team_identifier_index[team_identifier] end

	local team_index = hook.Run("OpenPermissions:GetTeamFromIdentifier", team_identifier)
	if (team_index) then
		team_identifier_index[team_identifier] = team_index
		return team_index
	end
	if (OpenPermissions.IsDarkRP and RPExtraTeams) then
		for _,job in ipairs(RPExtraTeams) do
			if (job.OPENPERMISSIONS_IDENTIFIER == team_identifier or job.command == team_identifier) then
				team_identifier_index[team_identifier] = job.team
				return job.team
			end
		end
	else
		for i,t in ipairs(team.GetAllTeams()) do
			if (t.Name == team_identifier) then
				team_identifier_index[team_identifier] = i
				return i
			end
		end
	end
end

local category_identifier_index = {}
function OpenPermissions:DarkRP_GetCategoryIdentifier(category_index)
	local category_identifier = hook.Run("OpenPermissions:DarkRP_GetCategoryIdentifier", category_index)
	if (category_identifier) then
		category_identifier_index[category_identifier] = category_index
		return category_identifier
	end

	local category = DarkRP.getCategories().jobs[category_index]
	local category_identifier = category.OPENPERMISSIONS_IDENTIFIER or category.GAS_IDENTIFIER or category.name

	category_identifier_index[category_identifier] = category_index
	return category_identifier
end

function OpenPermissions:DarkRP_GetCategoryFromIdentifier(category_identifier)
	if (category_identifier_index[category_identifier]) then return category_identifier_index[category_identifier] end

	local category_index = hook.Run("OpenPermissions:DarkRP_GetCategoryFromIdentifier", category_identifier)
	if (category_index) then
		category_identifier_index[category_index] = category_identifier
		return category_index
	end

	for i,category in pairs(DarkRP.getCategories().jobs) do
		local category_id = category.OPENPERMISSIONS_IDENTIFIER or category.GAS_IDENTIFIER or category.name
		if (category_id == category_identifier) then
			category_identifier_index[category_id] = i
			return i
		end
	end
end

--## Misc ##--

function OpenPermissions:table_IsEmpty(tbl)
	return next(tbl) == nil
end

function OpenPermissions:table_IsIdentical(tbl1, tbl2)
	local function r(tbl1, tbl2)
		for key, val in pairs(tbl1) do
			if (tbl2[key] == nil) then
				return false
			elseif (type(val) == "table") then
				if (r(val, tbl2[key]) == false) then
					return false
				end
			elseif (tbl2[key] ~= val) then
				return false
			end
		end
		for key, val in pairs(tbl2) do
			if (tbl1[key] == nil) then
				return false
			elseif (type(val) == "table") then
				if (r(val, tbl1[key]) == false) then
					return false
				end
			elseif (tbl1[key] ~= val) then
				return false
			end
		end
	end
	return r(tbl1, tbl2) ~= false
end

--## Enums ##--

OpenPermissions.ADDON = 0
OpenPermissions.PERMISSION = 1
OpenPermissions.CATEGORY = 2
OpenPermissions.SUBPERMISSION = 3

OpenPermissions.PermissionsRegistry = OpenPermissions:CreatePermissionsRegistry()
OpenPermissions.DefaultPermissions = {}

--## Networking ##--

if (SERVER) then
	-- Convert old file format to new
	if (file.Exists("openpermissions.dat", "DATA") and not file.Exists("openpermissions_v2.dat", "DATA")) then
		local read_file = file.Read("openpermissions.dat", "DATA")
		if (not read_file) then
			OpenPermissions:Print("Failed to read saved permissions data", "[ERROR]", OpenPermissions.COLOR_RED)
		else
			read_file = util.Decompress(read_file)
			if (not read_file) then
				OpenPermissions:Print("Failed to decompress saved permissions data", "[ERROR]", OpenPermissions.COLOR_RED)
			else
				local no_errors, deserialized = pcall(OpenPermissions.pon.decode, read_file)
				if (not no_errors) then
					OpenPermissions:Print("Failed to deserialize decompressed saved permissions data", "[ERROR]", OpenPermissions.COLOR_RED)
				else
					--OpenPermissions:Print("Saved permissions data successfully loaded", "[INFO]", OpenPermissions.COLOR_GREEN)

					-- Restructure
					for access_group_str, permissions in pairs(deserialized) do
						local access_group, accessor = access_group_str:match("(%d) (.+)")
						OpenPermissions.PermissionsRegistry[access_group] = OpenPermissions.PermissionsRegistry[access_group] or {}
						OpenPermissions.PermissionsRegistry[access_group][accessor] = {}
						for permission_id_str, permission in pairs(permissions) do
							OpenPermissions.PermissionsRegistry[access_group][accessor][permission_id_str] = permission
						end
					end

					-- Save new data
					OpenPermissions:SerializeRegistry(OpenPermissions.REGISTRY.FLAT_FILE)

					file.Rename("openpermissions.dat", "openpermissions_v1.dat")
				end
			end
		end
	end

	if (file.Exists("openpermissions_v2.dat", "DATA")) then
		local no_errors = xpcall(OpenPermissions.DeserializeRegistry, function(err)
			OpenPermissions:Print("Failed to deserialize decompressed saved permissions data", "[ERROR]", OpenPermissions.COLOR_RED)

			print(err)
			debug.Trace()
		end, OpenPermissions, OpenPermissions.REGISTRY.FLAT_FILE)

		if (no_errors) then
			OpenPermissions:Print("Saved permissions data successfully loaded", "[INFO]", OpenPermissions.COLOR_GREEN)
		end
	end
	net.Receive("OpenPermissions.SavePermissions", function(_, ply)
		if (not OpenPermissions:IsOperator(ply)) then return end
		OpenPermissions:DeserializeRegistry(OpenPermissions.REGISTRY.NETWORKED)
		OpenPermissions:SerializeRegistry(OpenPermissions.REGISTRY.FLAT_FILE)

		net.Start("OpenPermissions.PermissionsRegistry")
			OpenPermissions:StartNetworkTable(OpenPermissions.PermissionsRegistry, true, true)
			OpenPermissions:StartNetworkTable(OpenPermissions.DefaultPermissions, true)
		net.SendOmit(ply)
	end)
	net.Receive("OpenPermissions.PermissionsRegistry", function(_, ply)
		net.Start("OpenPermissions.PermissionsRegistry")
			OpenPermissions:StartNetworkTable(OpenPermissions.PermissionsRegistry, true)
			OpenPermissions:StartNetworkTable(OpenPermissions.DefaultPermissions, true)
		net.Send(ply)
	end)
else
	net.Receive("OpenPermissions.PermissionsRegistry", function()
		OpenPermissions:DeserializeRegistry(OpenPermissions.REGISTRY.NETWORKED)
		OpenPermissions.DefaultPermissions = OpenPermissions:ReceiveNetworkTable()
		OpenPermissions:Print("Received permissions registry", "[INFO]")
	end)
	if (OpenPermissions_PermissionsRegistry_InitPostEntity) then
		net.Start("OpenPermissions.PermissionsRegistry")
		net.SendToServer()
	else
		hook.Add("InitPostEntity", "OpenPermissions.PermissionsRegistry", function()
			OpenPermissions_PermissionsRegistry_InitPostEntity = true
			net.Start("OpenPermissions.PermissionsRegistry")
			net.SendToServer()
		end)
	end
end
--lua/autorun/palpy.lua:
player_manager.AddValidModel( "palpatine", 		"models/player/gpalpatine.mdl" );
list.Set( "PlayerOptionsModel", "palpatine", 	"models/player/gpalpatine.mdl" );
--lua/autorun/ppfx_cache.lua:
game.AddParticles( "particles/pfx_redux.pcf" )
-- 1
PrecacheParticleSystem("[1]campfire1")
PrecacheParticleSystem("[1]cig_smoke*")
PrecacheParticleSystem("[1]candle_flame")
PrecacheParticleSystem("[1]ground_fire_1")
PrecacheParticleSystem("[1]ground_fire_1*")
PrecacheParticleSystem("[1]smoke_lifting_01")
PrecacheParticleSystem("[1]_large_campfire")
PrecacheParticleSystem("[1]fireplace_default")
PrecacheParticleSystem("[1]_smoke_colorful_1")
PrecacheParticleSystem("[1]groundflame1")
PrecacheParticleSystem("[1]molotov_ground")
PrecacheParticleSystem("[1]embers")
PrecacheParticleSystem("[1]embers_~")
PrecacheParticleSystem("[1]flametrail")
PrecacheParticleSystem("[1]groundflame")
PrecacheParticleSystem("[1]flamethrower_basic")
PrecacheParticleSystem("[1]big_smoke")
PrecacheParticleSystem("[1]_large_campfire_red")
PrecacheParticleSystem("[1]_campfire_red")
PrecacheParticleSystem("[1]_large_campfire_yellow")
PrecacheParticleSystem("[1]_campfire_yellow")
PrecacheParticleSystem("[1]_large_campfire_purple")
PrecacheParticleSystem("[1]_campfire_purple")
PrecacheParticleSystem("[1]_large_campfire_green")
PrecacheParticleSystem("[1]_campfire_green")
PrecacheParticleSystem("[1]_large_campfire_pink")
PrecacheParticleSystem("[1]_campfire_pink")
PrecacheParticleSystem("[1]_large_campfire_blue")
PrecacheParticleSystem("[1]_campfire_blue")
PrecacheParticleSystem("[1]g_leak_flame")
-- 2
PrecacheParticleSystem("[2]sparkle1")
PrecacheParticleSystem("[2]sparkle2")
PrecacheParticleSystem("[2]gushing_blood_alien")
PrecacheParticleSystem("[2]gushing_blood_alien*")
PrecacheParticleSystem("[2]gushing_blood")
PrecacheParticleSystem("[2]gushing_blood*")
PrecacheParticleSystem("[2]acid_ground")
PrecacheParticleSystem("[2]swirl_1")
PrecacheParticleSystem("[2]swirl_rnd")
PrecacheParticleSystem("[2]gman_lines")
PrecacheParticleSystem("[2]blood_leak")
PrecacheParticleSystem("[2]blood_leak_alien")
-- 3
PrecacheParticleSystem("[3]sakura_env")
PrecacheParticleSystem("[3]leaves_env")
-- 4
PrecacheParticleSystem("[4]jet_r")
PrecacheParticleSystem("[4]jet_r*")
PrecacheParticleSystem("[4]jet_r_s")
PrecacheParticleSystem("[4]jet_r_s*")
PrecacheParticleSystem("[4]jet_g_s")
PrecacheParticleSystem("[4]jet_g_s*")
PrecacheParticleSystem("[4]jet_g")
PrecacheParticleSystem("[4]jet_g*")
PrecacheParticleSystem("[4]jet_b_s")
PrecacheParticleSystem("[4]jet_b_s*")
PrecacheParticleSystem("[4]jet_b")
PrecacheParticleSystem("[4]jet_b*")
PrecacheParticleSystem("[4]jet_f_s")
PrecacheParticleSystem("[4]jet_f_s*")
PrecacheParticleSystem("[4]jet_f")
PrecacheParticleSystem("[4]jet_f*")
PrecacheParticleSystem("[4]jet_v_s")
PrecacheParticleSystem("[4]jet_v_s*")
PrecacheParticleSystem("[4]jet_v")
PrecacheParticleSystem("[4]jet_v*")
PrecacheParticleSystem("[4]energy_rod_r")
PrecacheParticleSystem("[4]energy_rod_g")
PrecacheParticleSystem("[4]energy_rod_b")
PrecacheParticleSystem("[4]energy_rod_y")
PrecacheParticleSystem("[4]arcs_electric_1")
PrecacheParticleSystem("[4]arcs_electric_1_small")
PrecacheParticleSystem("[4]bfg_*proj")
PrecacheParticleSystem("[4]electric_beam")
PrecacheParticleSystem("[4]matrix_core")
PrecacheParticleSystem("[4]binary_sphere")
PrecacheParticleSystem("[4]_car_nitro")
-- 5
PrecacheParticleSystem("[5]black_hole_micro_b")
PrecacheParticleSystem("[5]black_hole_mmicro_b")
PrecacheParticleSystem("[5]black_hole_b")
PrecacheParticleSystem("[5]black_hole_micro")
PrecacheParticleSystem("[5]black_hole_mmicro")
PrecacheParticleSystem("[5]black_hole")
PrecacheParticleSystem("[5]starfield1")
PrecacheParticleSystem("[5]starfield_2")
PrecacheParticleSystem("[5]simple_galaxy")
-- 6
PrecacheParticleSystem("[6]gunfire_generic")
PrecacheParticleSystem("[6]bullet_tracer_generic")
PrecacheParticleSystem("[6]gunfire_ar2")
PrecacheParticleSystem("[6]bullet_tracer_ar2")
-- 7
PrecacheParticleSystem("[7]dusty_wind1")
PrecacheParticleSystem("[7]rain")
PrecacheParticleSystem("[7]snow")
PrecacheParticleSystem("[7]areal_fog_s")
PrecacheParticleSystem("[7]area_of_fog")
PrecacheParticleSystem("[7]blizzard_mod")
-- 8
PrecacheParticleSystem("[8]magic_1")
PrecacheParticleSystem("[8]red_vortex")
PrecacheParticleSystem("[8]magic_flame")
PrecacheParticleSystem("[8]magic_portal*")
PrecacheParticleSystem("[8]magic_portal")
PrecacheParticleSystem("[8]core_1")
PrecacheParticleSystem("[8]ball_core")
PrecacheParticleSystem("[8]orb_1")
PrecacheParticleSystem("[8]frostbeam")
-- 9
PrecacheParticleSystem("[9]colorful_trail_1")
-- A
PrecacheParticleSystem("[A]waterleak_1")

--lua/autorun/prone_init.lua:
-- Copyright 2020, George "Stalker" Petrou. Enjoy!

--[[	DOCUMENTATION
prone.Version
	- Version of Prone Mod in YearMonthDay form.

COMMANDS:
	prone
		- Client
		- Enters or exits prone.
	prone_config
		- Client
		- Opens a little config menu for your prone keys.

HOOKS:
	prone.Initialized
		- Shared
		- Called after the Prone Mod has finished loading.
	prone.ShouldChangeCalcView
		- Client
		- Should the Prone Mod handle the transition of the player's view down/up from prone.
		- Arg One:	Local player.
		- Return:	Boolean. False to disable, anything else to enable.
	prone.ShouldChangeCalcViewModelView
		- Client
		- Same as prone.ShouldChangeCalcView but for their view model.

	Note:	These hooks are called on the server and client entering prone
			They are also predicted:
	
	prone.OnPlayerEntered
		- Called when a player is getting down to go prone.
		- Arg One:	Player entering prone.
		- Arg Two:	The length of their get down animation.
	prone.OnPlayerExitted
		- Called when a player just completely exitted prone.
		- Arg One:	The player that exitted prone.
	prone.CanEnter
		- Called to see if a player can enter prone.
		- Arg One:	The player that wants to go prone.
		- Return:	A boolean determining if they can enter prone or not.
	prone.CanExit
		- Called to see if a player can exit prone.
		- Arg One:	The player that wants to exit prone.
		- Return:	A boolean determining if they can exit prone or not.
		
FUNCTIONS:
	Note: None of these functions exist till after the initialize hook is called.
	
	PLAYER:IsProne()
		- Shared
		- Returns true if the player is prone.
	PLAYER:GetProneAnimationState()
		- Shared
		- Returns one of the PRONE_ enums mentionned below.
	prone.Handle(Player)
		- Shared
		- If the player is prone this will make them end, otherwise it will make them enter prone.
		- For prediction try to call this shared if you can.
	prone.Enter(Player)
		- Shared
		- Will make the player go prone, doesn't check to see if they should or if they are already in prone.
		- You should probably check with ply:IsProne() and prone.CanEnter(Player) before using this function.
		- For prediction try to call this shared if you can.
	prone.End(Player)
		- Shared
		- Will make the given player exit prone, doesn't check to see if they should or if they are already out of prone.
		- You should probably check with ply:IsProne() and prone.CanExit(Player) before using this function.
		- For prediction try to call this shared if you can.
	prone.Exit(Player)
		- Shared
		- Will make the player immediately exit prone, skipping the get up animation. Doesn't check to see if a player is already prone.
	prone.Request()
		- Client
		- Will ask the server to exit prone if they are prone or to enter prone if they aren't.
	RunConsoleCommand("prone_config")
		- Client
		- Will open up the in-game prone configuration menu.

	Note: These functions below MUST be called in or after the prone.Initialzed hook has been called.
	prone.AddNewHoldTypeAnimation(holdtype, movingSequenceName, idleSequenceName)
		- Shared
		- Registers a new hold type animation. Requires a sequence name for the moving animation and idle animation for that holdtype.
		- Can be used to override pre-existing holdtypes. Must be called shared.
	prone.GetIdleAnimation(holdtype)
		- Shared
		- Returns the name of the sequence corresponding the idle stance of the given holdtype.
	prone.GetMovingAnimation(holdtype)
		- Shared
		- Returns the name of the sequence corresponding the moving stance of the given holdtype.

ENUMERATIONS:
	PRONE_GETTINGDOWN	= 0
		-- Prone state. Set when the player is getting down into prone.
	PRONE_INPRONE		= 1
		-- Prone state. Set when the player is down in prone.
	PRONE_GETTINGUP		= 2
		-- Prone state. Set when the player is getting up.
	PRONE_NOTINPRONE	= 3
		-- Prone state. Set when a player is not prone.
	PRONE_IMPULSE		= 217
		-- Sent to server from client using CUserCmd:SetImpulse() to signify the user wanting to go prone.
	PRONE_CUSTOM_ANIM_EVENT_NUM		= 69420
		-- Passed as a data arg with Player:DoCustomAnimEvent() to be used in the GM:DoAnimationEvent hook.

CONVARS:
	prone_movespeed
		-- Server (replicated and archived)
		-- Number, speed of moving while prone.
	prone_bindkey_enabled
		-- Client (archived)
		-- Boolean (1 or 0), should a bind key be pressed to enter prone, or just the "prone" command.
	prone_bindkey_key
		-- Client (archived)
		-- Number, representing a KEY enum, for what the bind key should be.
	prone_bindkey_doubletap
		-- Client (archived)
		-- Boolean, should we have to double press the bind key to go prone.
	prone_jumptogetup
		-- Client (archived)
		-- Boolean, should the jump key toggle prone.
	prone_jumptogetup_doubletap
		-- Client (archived)
		-- Boolean, if prone_jumptogetup is enabled, should we have to double tap it.
	prone_disabletransitions
		-- Client (archived)
		-- Boolean, should we disable view transitions when entering and exitting prone.
]]

----------------------------------------------------------------
-- Initialization
----------------------------------------------------------------
prone = prone or {}
prone.Config = prone.Config or {}
prone.Animations = prone.Animations or {}

-- YearMonthDay
prone.Version = 20200711

-- States
PRONE_GETTINGDOWN	= 0
PRONE_INPRONE		= 1
PRONE_GETTINGUP		= 2
PRONE_NOTINPRONE	= 3

-- The impulse number to be used for toggling prone.
-- If anybody steals my number there will be hell to pay.
PRONE_IMPULSE = 127

-- This number is passed as the "data" arg to ply:DoCustomAnimEvent().
-- Again, steal this number and there will be hell to pay.
PRONE_CUSTOM_ANIM_EVENT_NUM = 69420

if SERVER then
	-- https://steamcommunity.com/sharedfiles/filedetails/?id=775573383
	resource.AddWorkshop("775573383")
end

hook.Add("Initialize", "prone.Initialize", function()
	-- Send files
	if SERVER then
		AddCSLuaFile("prone/class_prone_statedata.lua")
		AddCSLuaFile("prone/config.lua")
		AddCSLuaFile("prone/sh_prone.lua")
		AddCSLuaFile("prone/sh_thirdparty_compat.lua")
		AddCSLuaFile("prone/cl_prone.lua")
	end

	-- Load files (in order)
	include("prone/class_prone_statedata.lua")
	include("prone/config.lua")
	include("prone/sh_prone.lua")
	include("prone/sh_thirdparty_compat.lua")
	if SERVER then
		include("prone/sv_prone.lua")
	else
		include("prone/cl_prone.lua")
	end

	print("Initialized The Prone Mod, by Stalker and Stiffy360 (wOS version)")
	hook.Call("prone.Initialized")
end)


----------------------------------------------------------------
-- Pre-Library
---------------
-- Collection of small functions used throughout the addon.
----------------------------------------------------------------

---------------------
-- prone.WritePlayer
---------------------
-- Desc:		Writes a player entity via the net library.
-- Arg One:		Player, to write.
function prone.WritePlayer(ply)
	if IsValid(ply) then
		net.WriteUInt(ply:EntIndex(), 7)
	else
		net.WriteUInt(0, 7)
	end
end

--------------------
-- prone.ReadPlayer
--------------------
-- Desc:		Reads a player entity via the net library.
-- Arg One:		Player, to read.
function prone.ReadPlayer()
	local i = net.ReadUInt(7)
	if not i then
		return
	end
	return Entity(i)
end

-- Sandbox C-Menu
if CLIENT then
	hook.Add("PopulateToolMenu", "prone.SandboxOptionsMenu", function()
		spawnmenu.AddToolMenuOption("Utilities", "User", "prone_options", "Prone Options", "", "", function(panel)
			panel:SetName("Prone Mod")
			panel:AddControl("Header", {
				Text = "",
				Description = "Configuration menu for the Prone Mod."
			})

			panel:AddControl("Checkbox", {
				Label = "Enable the bind key",
				Command = "prone_bindkey_enabled"
			})

			panel:AddControl("Checkbox", {
				Label = "Double-tap the bind key",
				Command = "prone_bindkey_doubletap"
			})

			panel:AddControl("Checkbox", {
				Label = "Can press jump to get up",
				Command = "prone_jumptogetup"
			})

			panel:AddControl("Checkbox", {
				Label = "Double-tap jump to get up",
				Command = "prone_jumptogetup_doubletap"
			})

			panel:AddControl("Numpad", {
				Label = "Set the Bind-Key",
				Command = "prone_bindkey_key"
			})
		end)
	end)
end
--addons/sam/lua/sam/libs/sh_globals.lua:
if SAM_LOADED then return end

local sam, netstream = sam, sam.netstream

local globals

if SERVER then
	globals = {}
	local order = {}

	local get_order_key = function(key)
		for i = 1, #order do
			if order[i] == key then
				return i
			end
		end
	end

	function sam.set_global(key, value, force)
		if force or globals[key] ~= value then
			globals[key] = value

			if value ~= nil then
				if not get_order_key(key) then
					table.insert(order, key)
				end
			else
				local i = get_order_key(key)
				if i then
					table.remove(order, i)
				end
			end

			netstream.Start(nil, "SetGlobal", key, value)
		end
	end

	hook.Add("OnEntityCreated", "SAM.Globals", function(ent)
		if ent:IsPlayer() and ent:IsValid() then
			netstream.Start(ent, "SendGlobals", globals, order)
		end
	end)
end

if CLIENT then
	function sam.set_global(key, value)
		if globals then
			globals[key] = value
			hook.Call("SAM.ChangedGlobalVar", nil, key, value)
		end
	end
	netstream.Hook("SetGlobal", sam.set_global)

	netstream.Hook("SendGlobals", function(vars, order)
		globals = vars

		for _, key in ipairs(order) do
			hook.Call("SAM.ChangedGlobalVar", nil, key, vars[key])
		end
	end)
end

function sam.get_global(key, default)
	if globals then
		local value = globals[key]
		if value ~= nil then
			return value
		end
	end

	return default
end
--addons/sam/lua/sam/menu/sh_init.lua:
if SAM_LOADED then return end

require("sui")

sam.command.new("menu")
	:Help("Open admin mod menu")
	:MenuHide()
	:DisableNotify()
	:OnExecute(function(ply)
		sam.netstream.Start(ply, "OpenMenu")
	end)
:End()

if CLIENT then
	sam.netstream.Hook("OpenMenu", function()
		sam.menu.open_menu()
	end)
end

if SERVER then
	for _, f in ipairs(file.Find("sam/menu/tabs/*.lua", "LUA")) do
		sam.load_file("sam/menu/tabs/" .. f)
	end
end
--addons/sui/lua/sui/cl_base.lua:
local hook = hook
local bit = bit
local math = math

local Color = Color
local ipairs = ipairs
local RealFrameTime = RealFrameTime

local color_white = color_white
local color_black = color_black

local sui = sui

local isfunction = sui.isfunction
local isstring = sui.isstring

local floor = math.floor

function sui.scale(v)
	return ScrH() * (v / 900)
end

function sui.hex_rgb(hex)
	hex = tonumber(hex:gsub("^([%w])([%w])([%w])$", "%1%1%2%2%3%3", 1), 16)

	return Color(
		bit.band(bit.rshift(hex, 16), 0xFF),
		bit.band(bit.rshift(hex, 8), 0xFF),
		bit.band(hex, 0xFF)
	)
end

function sui.rgb_hex(c)
	return bit.tohex((c.r * 0x10000) + (c.g * 0x100) + c.b, 6)
end
local rgb_hex = sui.rgb_hex

function sui.lerp_color(from, to)
	local frac = RealFrameTime() * 10
	from.r = Lerp(frac, from.r, to.r)
	from.g = Lerp(frac, from.g, to.g)
	from.b = Lerp(frac, from.b, to.b)
	from.a = Lerp(frac, from.a, to.a)
end

do
	local colors = {
		["41b9ff"] = Color(44, 62, 80),
		["00c853"] = Color(44, 62, 80),
		["181818"] = Color(242, 241, 239),
		["212121"] = Color(242, 241, 239),
	}

	function sui.contrast_color(color)
		local c = colors[rgb_hex(color)]
		if c then return c end

		local luminance = (0.299 * color.r + 0.587 * color.g + 0.114 * color.b) / 255
		return luminance > 0.5 and color_black or color_white
	end
end

do
	local SetDrawColor = surface.SetDrawColor
	local SetMaterial = surface.SetMaterial
	local DrawTexturedRectRotated = surface.DrawTexturedRectRotated
	function sui.draw_material(mat, x, y, size, col, rot)
		SetDrawColor(col)

		if x == -1 then
			x = size / 2
		end

		if y == -1 then
			y = size / 2
		end

		if mat then
			SetMaterial(mat)
		end

		DrawTexturedRectRotated(x, y, size, size, rot or 0)
	end
end

do
	local hsv_t = {
		[0] = function(v, p, q, t)
			return v, t, p
		end,
		[1] = function(v, p, q, t)
			return q, v, p
		end,
		[2] = function(v, p, q, t)
			return p, v, t
		end,
		[3] = function(v, p, q, t)
			return p, q, v
		end,
		[4] = function(v, p, q, t)
			return t, p, v
		end,
		[5] = function(v, p, q, t)
			return v, p, q
		end
	}

	function sui.hsv_to_rgb(h, s, v)
		local i = floor(h * 6)
		local f = h * 6 - i

		return hsv_t[i % 6](
			v * 255, -- v
			(v * (1 - s)) * 255, -- p
			(v * (1 - f * s)) * 255, -- q
			(v * (1 - (1 - f) * s)) * 255 -- t
		)
	end
end

local Panel = FindMetaTable("Panel")
local SetSize = Panel.SetSize
local GetWide = Panel.GetWide
local GetTall = Panel.GetTall
function sui.scaling_functions(panel)
	local scale_changed
	local SUI = CURRENT_SUI

	local dock_top = function(s, h)
		if not h then return end

		if not scale_changed then
			s.real_h = h
		end

		if not s.no_scale then
			h = SUI.Scale(h)
		end

		if GetTall(s) == h then return end

		SetSize(s, GetWide(s), h)
	end

	local dock_right = function(s, w)
		if not w then return end

		if not scale_changed then
			s.real_w = w
		end

		if not s.no_scale then
			w = SUI.Scale(w)
		end

		if GetWide(s) == w then return end

		SetSize(s, w, GetTall(s))
	end

	local size_changed = function(s, w, h)
		if s.using_scale then return end

		s.using_scale = true

		local dock = s:GetDock()

		if dock ~= FILL then
			if dock == NODOCK then
				dock_top(s, h)
				dock_right(s, w)
			elseif dock == TOP or dock == BOTTOM then
				dock_top(s, h)
			else
				dock_right(s, w)
			end
		end

		s.using_scale = nil
	end

	local wide_changed = function(s, w)
		size_changed(s, w)
	end

	local tall_changed = function(s, h)
		size_changed(s, nil, h)
	end

	function panel:ScaleChanged()
		scale_changed = true
		size_changed(self, self.real_w, self.real_h)
		scale_changed = nil
		if self.OnScaleChange then
			self:OnScaleChange()
		end
	end

	local on_remove = function(s)
		SUI.RemoveScaleHook(s)
	end

	function panel:ScaleInit()
		self.SetSize = size_changed
		self.SetWide = wide_changed
		self.SetTall = tall_changed
		SUI.OnScaleChanged(self, self.ScaleChanged)
		self:On("OnRemove", on_remove)
	end
end

do
	local utf8 = {}

	local str_rel_to_abs = function(str, v, str_n)
		return v > 0 and v or math.max(str_n + v + 1, 1)
	end

	local utf8_decode = function(str, start_pos, str_n)
		start_pos = str_rel_to_abs(str, start_pos or 1, str_n)

		local b1 = str:byte(start_pos, start_pos)
		if not b1 then return nil end
		if b1 < 0x80 then return start_pos, start_pos, b1 end
		if b1 > 0xF4 or b1 < 0xC2 then return nil end

		local cont_byte_count = b1 >= 0xF0 and 3 or b1 >= 0xE0 and 2 or b1 >= 0xC0 and 1
		local end_pos = start_pos + cont_byte_count
		local code_point = 0

		if str_n < end_pos then return nil end

		local bytes = {str:byte(start_pos + 1, end_pos)}
		for i = 1, #bytes do
			local b_x = bytes[i]
			if bit.band(b_x, 0xC0) ~= 0x80 then return nil end
			code_point = bit.bor(bit.lshift(code_point, 6), bit.band(b_x, 0x3F))
			b1 = bit.lshift(b1, 1)
		end

		code_point = bit.bor(code_point, bit.lshift(bit.band(b1, 0x7F), cont_byte_count * 5))

		return start_pos, end_pos, code_point
	end

	local replacement = string.char(239, 191, 189)

	function utf8.force(str)
		local end_pos = #str
		if end_pos == 0 then return str, end_pos end

		local ret = ""
		local cur_pos = 1

		repeat
			local seq_start_pos, seq_end_pos = utf8_decode(str, cur_pos, end_pos)

			if not seq_start_pos then
				ret = ret .. replacement
				cur_pos = cur_pos + 1
			else
				ret = ret .. str:sub(seq_start_pos, seq_end_pos)
				cur_pos = seq_end_pos + 1
			end
		until cur_pos > end_pos

		return ret, #ret
	end

	-- https://gist.github.com/gdeglin/4128882

	local utf8_char_bytes = function(c)
		if c > 0 and c <= 127 then
			return 1
		elseif c >= 194 and c <= 223 then
			return 2
		elseif c >= 224 and c <= 239 then
			return 3
		elseif c >= 240 and c <= 244 then
			return 4
		end
	end
	utf8.char_bytes = utf8_char_bytes

	function utf8.len(str)
		local length = #str

		local len = 0

		local pos = 1
		while pos <= length do
			len = len + 1
			pos = pos + utf8_char_bytes(str:byte(pos))
		end

		return len
	end

	function utf8.sub(str, i, j)
		j = j or -1

		if i == nil then return "" end

		local l = (i >= 0 and j >= 0) or utf8.len(str)
		local start_char = (i >= 0) and i or l + i + 1
		local end_char = (j >= 0) and j or l + j + 1

		if start_char > end_char then return "" end

		local pos = 1
		local length = #str
		local len = 0

		local start_byte, end_byte = 1, length

		while pos <= length do
			len = len + 1

			if len == start_char then
				start_byte = pos
			end

			pos = pos + utf8_char_bytes(str:byte(pos))

			if len == end_char then
				end_byte = pos - 1
				break
			end
		end

		return str:sub(start_byte, end_byte)
	end

	sui.utf8 = utf8
end

--
-- thanks falco!
-- https://github.com/FPtje/DarkRP/blob/4fd2c3c315427e79bb7624702cfaefe9ad26ac7e/gamemode/modules/base/cl_util.lua#L42
--
do
	local utf8 = utf8
	local surface = surface

	local max_width, original_width, can_fix

	local fix_width = function()
		if can_fix then
			can_fix = false
			max_width = original_width
		end
	end

	local char_wrap = function(text, remaining_width)
		local total_width  = 0

		local new_text = ""
		for char in text:gmatch(utf8.charpattern) do
			total_width  = total_width  + surface.GetTextSize(char)
			if total_width >= remaining_width then
				total_width = surface.GetTextSize(char)
				fix_width()
				remaining_width = max_width

				new_text = new_text .. ("\n" .. char)
			else
				new_text = new_text .. char
			end
		end

		return new_text, total_width
	end

	function sui.wrap_text(text, font, width, first_width)
		text = sui.utf8.force(text)

		local total_width = 0
		can_fix = first_width and true or false
		max_width, original_width = first_width or width, width

		surface.SetFont(font)

		local space_width = surface.GetTextSize(" ")

		text = text:gsub("(%s?[%S]*)", function(word)
			local char = word:sub(1, 1)
			if char == "\n" then
				total_width = 0
				fix_width()
			end

			local wordlen = surface.GetTextSize(word)
			total_width = total_width + wordlen

			if wordlen >= max_width then
				local split_word
				split_word, total_width = char_wrap(word, max_width - (total_width - wordlen))
				return split_word
			elseif total_width < max_width then
				return word
			end

			fix_width()

			total_width = wordlen

			if char == " " then
				total_width = total_width - space_width
				return "\n" .. word:sub(2)
			end

			return "\n" .. word
		end)

		return text
	end
end

function sui.register(classname, panel_table, parent_class)
	sui.TDLib.Install(panel_table)

	if not panel_table.Add then
		function panel_table:Add(pnl)
			return vgui.Create(pnl, self)
		end
	end

	if not panel_table.NoOverrideClear and not panel_table.Clear then
		function panel_table:Clear()
			local children = self:GetChildren()
			for i = 1, #children do
				children[i]:Remove()
			end
		end
	end

	local SUI = CURRENT_SUI

	for k, v in pairs(SUI.panels_funcs) do
		panel_table[k] = v
	end

	panel_table.SUI_GetColor = function(name)
		return SUI.GetColor(name)
	end

	SUI.panels[classname] = panel_table

	return vgui.Register(SUI.name .. "." .. classname, panel_table, parent_class)
end

local Material; do
	local C_Material, material_str = select(2, debug.getupvalue(_G.Material, 1)), "0001010" -- [["mips smooth"]]
	Material = function(name)
		return C_Material(name, material_str)
	end
end
sui.Material = Material

local function prepare_theme(theme)
	for k, v in pairs(theme) do
		if IsColor(v) then continue end

		if istable(v) then
			prepare_theme(v)
		elseif isstring(v) and v:sub(1, 1) == "#" then
			theme[k] = sui.hex_rgb(v:sub(2))
		end
	end
end

function sui.new(addon_name, default_scaling, panels_funcs)
	local SUI = {
		name = addon_name,
		panels = {},
		panels_funcs = panels_funcs or {}
	}

	CURRENT_SUI = SUI

	do
		local themes = table.Copy(sui.themes)
		local current_theme_table

		function SUI.GetColor(color_name)
			return current_theme_table[color_name]
		end

		function SUI.SetTheme(theme_name)
			SUI.current_theme = theme_name
			current_theme_table = themes[theme_name]
			hook.Call(addon_name .. ".ThemeChanged")
		end

		function SUI.GetThemes()
			return themes
		end

		function SUI.AddToTheme(theme_name, tbl)
			local theme = themes[theme_name]
			for k, v in pairs(tbl) do
				theme[k] = v
			end
			prepare_theme(theme)
		end

		function SUI.RemoveTheme(theme_name)
			themes[theme_name] = nil
			if theme_name == SUI.current_theme then
				SUI.SetTheme(next(themes))
			end
		end

		function SUI.AddTheme(theme_name, tbl)
			prepare_theme(tbl)
			themes[theme_name] = tbl
		end

		SUI.themes = themes
	end

	local Scale
	do
		local scale = 1

		if default_scaling then
			SUI.Scale = sui.scale
		else
			function SUI.Scale(v)
				return floor((v * scale) + 0.5)
			end
		end
		Scale = SUI.Scale

		function SUI.ScaleEven(v)
			v = Scale(v)
			if v % 2 ~= 0 then
				v = v + 1
			end
			return v
		end

		function SUI.SetScale(_scale)
			if _scale == scale then return end

			scale = _scale
			SUI.scale = _scale

			for k, v in pairs(SUI.fonts) do
				SUI.CreateFont(k:sub(#addon_name + 1), v.font, v.size, v.weight)
			end

			SUI.CallScaleChanged()
		end

		local n = 0
		local keys = {}
		local hooks = {}
		_G[addon_name .. "_HOOKS"] = keys
		_G[addon_name .. "_KEYS"] = hooks
		_G[addon_name .. "_N"] = function()
			return n
		end
		function SUI.OnScaleChanged(name, func)
			if not isfunction(func) then
				error("Invalid function?")
			end

			if not name then
				error("Invalid name?")
			end

			if not isstring(name) then
				local _func = func
				func = function()
					local isvalid = name.IsValid
					if isvalid and isvalid(name) then
						_func(name)
					else
						SUI.RemoveScaleHook(name, true)
					end
				end
			end

			local pos = keys[name]
			if pos then
				hooks[pos + 1] = func
			else
				hooks[n + 1] = name
				hooks[n + 2] = func
				keys[name] = n + 1
				n = n + 2
			end
		end

		function SUI.RemoveScaleHook(name, in_hook)
			local pos = keys[name]
			if not pos then return end

			if in_hook then
				hooks[pos] = nil
				hooks[pos + 1] = nil
			else
				local new_name = hooks[n - 1]
				if new_name then
					hooks[pos], hooks[pos + 1] = new_name, hooks[n]
					hooks[n - 1], hooks[n] = nil, nil
					keys[new_name] = pos
				end
				n = n - 2
			end
			keys[name] = nil
		end

		function SUI.CallScaleChanged()
			if n == 0 then return end

			local i, c_n = 2, n
			::loop::
			local func = hooks[i]
			if func then
				func()
				i = i + 2
			else
				local _n, _i = c_n, i
				if n ~= c_n then
					_n = n
					i = i + 2
				else
					c_n = c_n - 2
				end

				local new_name = hooks[_n - 1]
				if new_name then
					hooks[_i - 1], hooks[_i] = new_name, hooks[_n]
					hooks[_n - 1], hooks[_n] = nil, nil
					keys[new_name] = _i - 1
				end

				n = n - 2
			end

			if i <= c_n then
				goto loop
			end
		end

		function SUI.GetScale()
			return scale
		end

		SUI.scale = 1
	end

	do
		local fonts = {}

		function SUI.CreateFont(font_name, font, size, weight)
			font_name = addon_name .. font_name

			fonts[font_name] = fonts[font_name] or {
				font = font,
				size = size,
				weight = weight
			}

			surface.CreateFont(font_name, {
				font = font,
				size = Scale(size),
				weight = weight,
				extended = true
			})

			return font_name
		end

		function SUI.GetFont(font_name)
			return addon_name .. font_name
		end

		function SUI.GetFontHeight(font_name)
			local font = fonts[addon_name .. font_name] or fonts[font_name]
			if not font then return 0 end

			return floor(Scale(font.size or 0))
		end

		SUI.fonts = fonts
	end

	do
		local materials = {}

		local delay = 0.008
		local next_run = UnPredictedCurTime()

		function SUI.Material(mat, allow_delay)
			local _mat = materials[mat]
			if _mat then return _mat end

			if allow_delay then
				if UnPredictedCurTime() < next_run then return end
				next_run = UnPredictedCurTime() + delay
			end

			materials[mat] = Material(mat)

			return materials[mat]
		end

		SUI.materials = materials
	end

	SUI.SetTheme("Dark")

	for _, f in ipairs(file.Find("sui/vgui/sui_*.lua", "LUA")) do
		include("sui/vgui/" .. f)
	end

	for _, f in ipairs(file.Find(string.format("sui/vgui/%s_*.lua", addon_name:lower()), "LUA")) do
		include("sui/vgui/" .. f)
	end

	return SUI
end

sui.themes = sui.themes or {}
function sui.add_theme(name, tbl)
	prepare_theme(tbl)
	sui.themes[name] = tbl
end

function sui.valid_options()
	local objs = {}
	objs.IsValid = function()
		local valid = true
		for i = 1, #objs do
			local obj = objs[i]
			if obj:IsValid() and obj.valid == false then
				valid = false
				break
			end
		end
		return valid
	end
	objs.Add = function(obj)
		table.insert(objs, obj)
	end
	return objs
end

do
	local SURFACE = Color(31, 31, 31)
	local PRIMARY = Color(65, 185, 255)

	local ON_SURFACE = Color(255, 255, 255)
	local ON_SURFACE_HIGH_EMPHASIS = ColorAlpha(ON_SURFACE, 221)
	local ON_SURFACE_MEDIUM_EMPHASIS = ColorAlpha(ON_SURFACE, 122)
	local ON_SURFACE_DISABLED = ColorAlpha(ON_SURFACE, 97)

	local ON_PRIMARY = Color(60, 60, 60)

	sui.add_theme("Dark", {
		frame = Color(18, 18, 18),
		frame_blur = false,

		title = ON_SURFACE,
		header = SURFACE,

		close = ON_SURFACE_MEDIUM_EMPHASIS,
		close_hover = Color(255, 60, 60),
		close_press = Color(255, 255, 255, 30),

		button = PRIMARY,
		button_text = "#050709",
		button_hover = ColorAlpha(ON_PRIMARY, 100),
		button_click = ColorAlpha(ON_PRIMARY, 240),
		button_disabled = Color(100, 100, 100),
		button_disabled_text = "#bdbdbd",

		button2_hover = ColorAlpha(PRIMARY, 5),
		button2_selected = ColorAlpha(PRIMARY, 15),

		scroll = ColorAlpha(PRIMARY, 97),
		scroll_grip = PRIMARY,

		scroll_panel = Color(29, 29, 29),
		scroll_panel_outline = false,

		text_entry_bg = Color(34, 34, 34),
		text_entry_bar_color = Color(0, 0, 0, 0),
		text_entry = ON_SURFACE_HIGH_EMPHASIS,
		text_entry_2 = ON_SURFACE_MEDIUM_EMPHASIS,
		text_entry_3 = PRIMARY,

		property_sheet_bg = Color(39, 39, 39),
		property_sheet_tab = Color(150, 150, 150),
		property_sheet_tab_click = Color(255, 255, 255, 30),
		property_sheet_tab_active = PRIMARY,

		toggle_button = ON_SURFACE_DISABLED,
		toggle_button_switch = ON_SURFACE_HIGH_EMPHASIS,

		toggle_button_active = ColorAlpha(PRIMARY, 65),
		toggle_button_switch_active = PRIMARY,

		slider_knob = PRIMARY,
		slider_track = ColorAlpha(PRIMARY, 65),
		slider_hover = ColorAlpha(PRIMARY, 5),
		slider_pressed = ColorAlpha(PRIMARY, 30),

		on_sheet = Color(43, 43, 43, 200),
		on_sheet_hover = Color(200, 200, 200, 20),

		--=--
		query_box_bg = "#181818",
		query_box_cancel = Color(244, 67, 54, 30),
		query_box_cancel_text = "#f44336",
		--=--

		--=--
		menu = "#212121",

		menu_option = "#212121",
		menu_option_text = "#bdbdbd",
		menu_option_hover = "#3b3b3b",
		menu_option_hover_text = "#fefefe",

		menu_spacer = "#303030",
		--=--

		line = "#303030",

		--=--
		column_sheet = "#263238",
		column_sheet_bar = "#202020",

		column_sheet_tab = "#202020",
		column_sheet_tab_hover = "#2e2e2e",
		column_sheet_tab_active = "#383838",

		column_sheet_tab_icon = "#909090",
		column_sheet_tab_icon_hover = "#f0f0f0",
		column_sheet_tab_icon_active = "#34a1e0",
		--=--

		--=--
		collapse_category_header = "#272727",
		collapse_category_header_hover = "#2a2a2a",
		collapse_category_header_active = "#2e2e2e",

		collapse_category_header_text = "#aaaaaa",
		collapse_category_header_text_hover = "#dcdcdc",
		collapse_category_header_text_active = "#34A1E0",

		collapse_category_item = "#343434",
		collapse_category_item_hover = "#464646",
		collapse_category_item_active = "#535353",

		collapse_category_item_text = "#aaaaaa",
		collapse_category_item_text_hover = "#dcdcdc",
		collapse_category_item_text_active = "#ffffff",
		--=--
	})
end

do
	local PRIMARY = Color(65, 185, 255)

	local ON_PRIMARY = Color(220, 220, 220)

	sui.add_theme("Blur", {
		frame = Color(30, 30, 30, 220),
		frame_blur = true,

		title = Color(255, 255, 255),
		header = Color(60, 60, 60, 200),

		close = Color(200, 200, 200),
		close_hover = Color(255, 60, 60),
		close_press = Color(255, 255, 255, 30),

		button = ColorAlpha(PRIMARY, 130),
		button_text = ON_PRIMARY,
		button_hover = Color(0, 0, 0, 30),
		button_click = PRIMARY,
		button_disabled = Color(100, 100, 100),
		button_disabled_text = "#bdbdbd",

		button2_hover = ColorAlpha(PRIMARY, 5),
		button2_selected = ColorAlpha(PRIMARY, 15),

		scroll = Color(0, 0, 0, 100),
		scroll_grip = PRIMARY,

		scroll_panel = Color(255, 255, 255, 10),
		scroll_panel_outline = false,

		text_entry_bg = Color(0, 0, 0, 0),
		text_entry_bar_color = Color(200, 200, 200, 153),
		text_entry = Color(240, 240, 240, 221),
		text_entry_2 = Color(200, 200, 200, 153),
		text_entry_3 = PRIMARY,

		property_sheet_bg = Color(60, 60, 60, 200),
		property_sheet_tab = Color(150, 150, 150),
		property_sheet_tab_click = Color(255, 255, 255, 40),
		property_sheet_tab_active = PRIMARY,

		toggle_button = Color(244, 67, 54),
		toggle_button_switch = Color(230, 230, 230),

		toggle_button_active = PRIMARY,
		toggle_button_switch_active = Color(230, 230, 230),

		slider_knob = PRIMARY,
		slider_track = ColorAlpha(PRIMARY, 100),
		slider_hover = ColorAlpha(PRIMARY, 40),
		slider_pressed = ColorAlpha(PRIMARY, 70),

		on_sheet = Color(60, 60, 60, 180),
		on_sheet_hover = Color(30, 30, 30, 70),

		--=--
		query_box_bg = Color(0, 0, 0, 100),
		query_box_cancel = Color(244, 67, 54, 30),
		query_box_cancel_text = "#f44336",
		--=--
	})
end
--addons/sui/lua/sui/vgui/sui_number_slider.lua:
local surface = surface

local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local NUMBER_SLIDER_FONT = SUI.CreateFont("NumberSlider", "Roboto Regular", 14)

local PANEL = {}

sui.scaling_functions(PANEL)

function PANEL:Init()
	self:ScaleInit()

	local slider = vgui.Create(NAME .. ".Slider", self, "NumberSlider")
	slider:Dock(FILL)

	self.slider = slider

	local label = self:Add(NAME .. ".Label")
	label:Dock(RIGHT)
	label:DockMargin(3, 0, 0, 0)
	label:SetFont(NUMBER_SLIDER_FONT)
	self.label = label

	function label:Think()
		self:SetText(slider:GetValue())

		self:SizeToContents()
	end

	self:SetSize(100, 12)
	self:InvalidateLayout(true)
end

sui.register("NumberSlider", PANEL, "Panel")
--addons/sui/lua/sui/vgui/sui_panel.lua:
local PANEL = {}

sui.scaling_functions(PANEL)

function PANEL:Init()
	self:ScaleInit()
end

sui.register("Panel", PANEL, "Panel")
--addons/sui/lua/sui/vgui/sui_text_entry.lua:
local sui = sui

local surface = surface
local utf8 = sui.utf8
local draw = draw
local math = math

local IsValid = IsValid
local tostring = tostring
local tonumber = tonumber

local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local GetColor = SUI.GetColor
local TEXT_ENTRY_FONT = SUI.CreateFont("TextEntry", "Roboto Regular", 16)

local Panel = {}

sui.scaling_functions(Panel)

AccessorFunc(Panel, "m_FontName", "Font", FORCE_STRING)
AccessorFunc(Panel, "m_Editable", "Editable", FORCE_BOOL)
AccessorFunc(Panel, "m_Placeholder", "Placeholder", FORCE_STRING)
AccessorFunc(Panel, "m_MaxChars", "MaxChars", FORCE_NUMBER)
AccessorFunc(Panel, "m_Numeric", "Numeric", FORCE_BOOL)
AccessorFunc(Panel, "m_NoBar", "NoBar", FORCE_BOOL)
AccessorFunc(Panel, "m_BarColor", "BarColor")
AccessorFunc(Panel, "m_Background", "Background")
AccessorFunc(Panel, "m_Radius", "Radius")
AccessorFunc(Panel, "m_NoEnter", "NoEnter")

Panel:SetRadius(3)

function Panel:Init()
	self:ScaleInit()

	self:SetupTransition("TextEntryReady", 0.9, function()
		return self:IsEditing() or self:GetBarColor() ~= nil
	end)

	self:SetUpdateOnType(true)
	self:SetCursor("beam")
	self:SetFont(TEXT_ENTRY_FONT)
	self:SetPlaceholder("Placeholder text")

	self:SetSize(200, 22)

	self.allowed_numeric_characters = "1234567890.-"

	self.history = {}
	self.history_pos = 1
	self.can_use_history = true

	self:OnScaleChange()
end

function Panel:SetCaretPos(pos)
	DTextEntry.SetCaretPos(self, math.Clamp(pos, 0, utf8.len(self:GetText())))
end

function Panel:SetValue(value)
	self:SetText(value)
	self:OnValueChange(value)
end

function Panel:AllowInput(ch)
	if self:CheckNumeric(ch) then return true end

	if sui.wspace_chs[ch] or sui.cntrl_chs[ch] then
		return true
	end

	local max_chars = self:GetMaxChars()
	if max_chars and #self:GetText() >= max_chars then
		surface.PlaySound("resource/warning.wav")
		return true
	end
end

function Panel:AddValue(v, i, j)
	local original_text = self:GetText()

	local start
	if i then
		start = original_text:sub(1, i)
	else
		start = utf8.sub(original_text, 1, self:GetCaretPos())
	end

	local text = start .. v
	local caret_pos = utf8.len(text)

	local _end
	if j then
		_end = original_text:sub(j)
	else
		_end = utf8.sub(original_text, utf8.len(start) + 1)
	end
	text = text .. _end

	local max_chars = self:GetMaxChars()
	if max_chars then
		text = text:sub(1, max_chars)
	end

	self:SetValue(text)
	self:SetCaretPos(caret_pos)
end

function Panel:OnKeyCodeTyped(code)
	if self.no_down then
		self.no_down = nil
		return
	end

	if code == KEY_UP or code == KEY_DOWN then
		if not self:UpdateFromHistory(code) then
			return true
		end

		local lines, caret_line = self:GetNumLines()

		if lines == 1 then
			return true
		end

		--
		-- this fixes a weird issue
		-- make the text entry has at least 2 lines, go up then go down, you won't be able to go up again
		--
		if code == KEY_DOWN and lines == caret_line + 1 then
			self.no_down = true
			gui.InternalKeyCodeTyped(KEY_DOWN)
		end
	end

	self:OnKeyCode(code)

	if code == KEY_ENTER then
		if IsValid(self.Menu) then
			self.Menu:Remove()
		end

		if not self:GetNoEnter() then
			self:FocusNext()
			self:OnEnter()
		end
	end
end

function Panel:DisallowFloats(disallow)
	if not isbool(disallow) then
		disallow = true
	end

	if disallow then
		self.allowed_numeric_characters = self.allowed_numeric_characters:gsub("%.", "", 1)
	elseif not self.allowed_numeric_characters:find(".", 1, true) then
		self.allowed_numeric_characters = self.allowed_numeric_characters .. "."
	end
end

function Panel:DisallowNegative(disallow)
	if not isbool(disallow) then
		disallow = true
	end

	if disallow then
		self.allowed_numeric_characters = self.allowed_numeric_characters:gsub("%-", "", 1)
	elseif not self.allowed_numeric_characters:find("-", 1, true) then
		self.allowed_numeric_characters = self.allowed_numeric_characters .. "-"
	end
end

function Panel:CheckNumeric(value)
	if not self:GetNumeric() then return false end

	if not self.allowed_numeric_characters:find(value, 1, true) then
		return true
	end

	local new_value = ""
	local current_value = tostring(self:GetText())

	local caret_pos = self:GetCaretPos()
	for i = 0, #current_value do
		new_value = new_value .. current_value:sub(i, i)
		if i == caret_pos then
			new_value = new_value .. value
		end
	end

	if #current_value ~= 0 and not tonumber(new_value) then
		return true
	end

	return false
end

function Panel:AddHistory(txt)
	if not txt or txt == "" then return end
	local history = self.history
	if history[#history] ~= txt then
		table.insert(history, txt)
	end
end

function Panel:UpdateFromHistory(code)
	if not self.can_use_history then return end

	local lines, caret_line = self:GetNumLines()

	if code == KEY_UP then
		if caret_line > 1 then return true end -- enable the caret to move up and down

		if self.history_pos <= 1 then return end

		self.history_pos = self.history_pos - 1
	elseif code == KEY_DOWN then
		if caret_line ~= lines then return true end

		if self.history_pos >= #self.history then
			self:SetValue("")
			self:SetCaretPos(0)
			self.history_pos = #self.history + 1
			return
		end

		self.history_pos = self.history_pos + 1
	end

	local text = self.history[self.history_pos]
	if not text then return end

	self:SetValue(text)
	self:SetCaretPos(utf8.len(text))
end

function Panel:OnTextChanged()
	self.history_pos = #self.history + 1

	local text = self:GetText()

	self.can_use_history = text == "" and true or false

	if self:GetUpdateOnType() then
		self:UpdateConvarValue()
		self:OnValueChange(text)
	end

	self:OnChange()
end

function Panel:OnScaleChange()
	self:InvalidateLayout()
	self:InvalidateLayout(true)
end

function Panel:Paint(w, h)
	self:RoundedBox("Background", self:GetRadius(), 0, 0, w, h, GetColor("text_entry_bg") or self:GetBackground())

	local text_entry_3 = GetColor("text_entry_3")

	if self:GetText() == "" then
		local old_text = self:GetText()
		self:SetText(self:GetPlaceholder())
		self:DrawTextEntryText(GetColor("text_entry_2"), text_entry_3, text_entry_3)
		self:SetText(old_text)
	else
		self:DrawTextEntryText(GetColor("text_entry"), text_entry_3, text_entry_3)
	end

	if not self:GetNoBar() then
		local bar_color = self:GetBarColor()

		self:RoundedBox("Bar1", 0, 0, h - 1, w, 1, GetColor("text_entry_bar_color"))

		local bar = math.Round(w * self.TextEntryReady)
		if bar > 0 then
			self:RoundedBox("Bar2", 0, (w / 2) - (bar / 2), h - 1, bar, 1, bar_color or text_entry_3)
		end
	end
end

-- https://github.com/ValveSoftware/source-sdk-2013/blob/0d8dceea4310fde5706b3ce1c70609d72a38efdf/mp/src/vgui2/vgui_controls/TextEntry.cpp#L969
function Panel:GetNumLines(wide)
	local num_lines = 1

	wide = wide or self:GetWide() - 2

	local vbar = self:GetChildren()[1]
	if vbar then
		wide = wide - vbar:GetWide()
	end

	local char_width
	local x = 3

	local word_start_index = 1
	local word_start_len
	local word_length = 0
	local has_word = false
	local just_started_new_line = true
	local word_started_on_new_line = true

	local start_char = 1

	surface.SetFont(self:GetFont())

	local i = start_char
	local text, n = utf8.force(self:GetText())
	local caret_line = 0
	local caret_pos = self:GetCaretPos()
	local caret_i = 1
	while i <= n do
		local ch_len = utf8.char_bytes(text:byte(i))
		local ch = text:sub(i, i + ch_len - 1)

		if ch ~= " " then
			if not has_word then
				word_start_index = i
				word_start_len = ch_len
				has_word = true
				word_started_on_new_line = just_started_new_line
				word_length = 0
			end
		else
			has_word = false
		end

		char_width = surface.GetTextSize(ch)
		just_started_new_line = false

		if (x + char_width) >= wide then
			x = 3

			just_started_new_line = true
			has_word = false

			if word_started_on_new_line then
				num_lines = num_lines + 1
			else
				num_lines = num_lines + 1
				i = (word_start_index + word_start_len) - ch_len
			end

			word_length = 0
		end

		x = x + char_width
		word_length = word_length + char_width

		if caret_i == caret_pos then
			caret_line = num_lines
		end

		i = i + ch_len
		caret_i = caret_i + 1
	end

	return num_lines, caret_line
end

function Panel:SetCheck(func, col)
	function self:OnValueChange(text)
		if func(text) == false then
			self.valid = false
			self:SetBarColor(GetColor("close_hover"))
			self:SetNoEnter(true)
		else
			self.valid = true
			self:SetBarColor(col)
			self:SetNoEnter(false)
		end
	end
	self:SetValue(self:GetText())
end

sui.register("TextEntry", Panel, "DTextEntry")
--addons/sui/lua/sui/vgui/sui_zbutton.lua:
local draw = draw
local render = render

local TDLib = sui.TDLib
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local lerp_color = sui.lerp_color
local contrast_color = sui.contrast_color

local BUTTON_FONT = SUI.CreateFont("Button", "Roboto Medium", 16)

local color_white = color_white
local color_transparent = Color(0, 0, 0, 0)

local PANEL = {}

AccessorFunc(PANEL, "m_Background", "Background")
AccessorFunc(PANEL, "m_bContained", "Contained", FORCE_BOOL)

sui.TDLib.Install(PANEL)
sui.scaling_functions(PANEL)

PANEL:ClearPaint()
PANEL:SetContained(true)

local Panel = FindMetaTable("Panel")
local SetMouseInputEnabled = Panel.SetMouseInputEnabled
local IsMouseInputEnabled = Panel.IsMouseInputEnabled
local SetCursor = Panel.SetCursor
local SetContentAlignment = Panel.SetContentAlignment
function PANEL:Init()
	self:ScaleInit()

	self.vertices, self.vertices_2 = {}, {}

	SetMouseInputEnabled(self, true)
	SetCursor(self, "hand")
	SetContentAlignment(self, 5)

	self:SetSize(90, 30)
	self:SetFont(BUTTON_FONT)

	self:CircleClick(nil, 7)

	self.OldPaint, self.Paint = self.Paint, self.Paint2

	self.cur_col = Color(0, 0, 0, 0)
end

function PANEL:SetEnabled(b)
	SetMouseInputEnabled(self, b)
end

function PANEL:IsEnabled()
	return IsMouseInputEnabled(self)
end

function PANEL:ContainedPaint(w, h)
	local enabled = self:IsEnabled()
	local col
	if enabled then
		col = self:GetBackground() or SUI.GetColor("button")
		self:SetTextColor(SUI.GetColor("button_text"))
	else
		col = SUI.GetColor("button_disabled")
		self:SetTextColor(SUI.GetColor("button_disabled_text"))
	end
	self:RoundedBox("Background", 4, 0, 0, w, h, col)

	if not enabled then return end

	self.circle_click_color = SUI.GetColor("button_click")

	if self.Hovered or self.Selected then
		self:RoundedBox("Hover", 4, 0, 0, w, h, SUI.GetColor("button_hover"))
	end
end

function PANEL:SetColors(hover_color, text_color)
	self.hover = hover_color
	self.text_color = text_color
end

function PANEL:Paint2(w, h)
	if self:GetContained() then
		self:ContainedPaint(w, h)
		self:OldPaint(w, h)
		return
	end

	render.ClearStencil()
	render.SetStencilEnable(true)

	render.SetStencilWriteMask(1)
	render.SetStencilTestMask(1)

	render.SetStencilFailOperation(STENCILOPERATION_REPLACE)
	render.SetStencilPassOperation(STENCILOPERATION_ZERO)
	render.SetStencilZFailOperation(STENCILOPERATION_ZERO)
	render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_NEVER)
	render.SetStencilReferenceValue(1)

	TDLib.RoundedBox(self.vertices, 4, 0, 0, w, h, color_white)

	render.SetStencilFailOperation(STENCILOPERATION_ZERO)
	render.SetStencilPassOperation(STENCILOPERATION_REPLACE)
	render.SetStencilZFailOperation(STENCILOPERATION_ZERO)
	render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_EQUAL)
	render.SetStencilReferenceValue(1)

	local cur_col = self.cur_col
	if self.Selected then
		lerp_color(cur_col, SUI.GetColor("button2_selected"))
	elseif self.Hovered then
		lerp_color(cur_col, self.hover or SUI.GetColor("button2_hover"))
	else
		lerp_color(cur_col, color_transparent)
	end

	TDLib.RoundedBox(self.vertices_2, 4, 0, 0, w, h, cur_col)

	if self.text_color then
		self.circle_click_color = self.text_color
		self:SetTextColor(self.text_color)
	else
		local col = contrast_color(cur_col)
		self.circle_click_color = col
		self:SetTextColor(col)
	end

	self:OldPaint(w, h)

	render.SetStencilEnable(false)
	render.ClearStencil()
end

sui.register("Button", PANEL, NAME .. ".Label")
--addons/sam/lua/sam/menu/tabs/config/reports.lua:
if SAM_LOADED then return end

local sam = sam
local config = sam.config

local not_empty = function(s)
	return s and s ~= ""
end

local number_entry = function(setting, config_key, default)
	local entry = setting:Add("SAM.TextEntry")
	entry:SetWide(50)
	entry:SetPlaceholder("")
	entry:SetBackground(Color(34, 34, 34))
	entry:SetNumeric(true)
	entry:DisallowFloats()
	entry:DisallowNegative()
	entry:SetCheck(not_empty)
	entry:SetConfig(config_key, default)

	return entry
end

config.add_tab("Reports", function(parent)
	local body = parent:Add("SAM.ScrollPanel")
	body:Dock(FILL)
	body:LineMargin(0, 6, 0, 0)

	local i = 0
	body:GetCanvas():On("OnChildAdded", function(s, child)
		i = i + 1
		child:SetZPos(i)

		if not body.making_line then
			body:Line()
		end
	end)

	do
		local setting = body:Add("SAM.LabelPanel")
		setting:Dock(TOP)
		setting:SetLabel("Enable")
		setting:DockMargin(8, 6, 8, 0)

		local enable = setting:Add("SAM.ToggleButton")
		enable:SetConfig("Reports", true)
	end

	do
		local setting = body:Add("SAM.LabelPanel")
		setting:Dock(TOP)
		setting:SetLabel("Commands")
		setting:DockMargin(8, 6, 8, 0)

		local entry = setting:Add("SAM.TextEntry")
		entry:SetWide(200)
		entry:SetNoBar(true)
		entry:SetPlaceholder("")
		entry:SetMultiline(true)
		entry:SetConfig("Reports.Commands")
		entry.no_scale = true

		function entry:OnValueChange()
			self:SetTall(self:GetNumLines() * (sam.SUI.Scale(16) --[[font size]] + 1) + 1 + 2)
		end
		entry:OnValueChange()
	end

	do
		local setting = body:Add("SAM.LabelPanel")
		setting:Dock(TOP)
		setting:SetLabel("Max Reports (Number of reports that can show on your screen)")
		setting:DockMargin(8, 6, 8, 0)

		number_entry(setting, "Reports.MaxReports", 4)
	end

	do
		local setting = body:Add("SAM.LabelPanel")
		setting:Dock(TOP)
		setting:SetLabel("Auto Close Time (Time to wait before automatically closing claimed reports)")
		setting:DockMargin(8, 6, 8, 0)

		local entry = setting:Add("SAM.TextEntry")
		entry:SetWide(70)
		entry:SetNoBar(false)
		entry:SetPlaceholder("")
		entry:SetCheck(function(time)
			time = sam.parse_length(time)
			if not time then
				return false
			end
		end)
		entry:SetConfig("Reports.AutoCloseTime", "10m")
	end

	do
		local setting = body:Add("SAM.LabelPanel")
		setting:Dock(TOP)
		setting:SetLabel("Always Show (Show the popups even if you are not on duty)")
		setting:DockMargin(8, 6, 8, 0)

		local enable = setting:Add("SAM.ToggleButton")
		enable:SetConfig("Reports.AlwaysShow", true)
	end

	do
		local setting = body:Add("SAM.LabelPanel")
		setting:Dock(TOP)
		setting:SetLabel("On Duty Jobs")
		setting:DockMargin(8, 6, 8, 0)

		local entry = setting:Add("SAM.TextEntry")
		entry:SetWide(300)
		entry:SetNoBar(true)
		entry:SetPlaceholder("")
		entry:SetMultiline(true)
		entry:SetConfig("Reports.DutyJobs", "")
		entry.no_scale = true

		function entry:OnValueChange()
			self:SetTall(self:GetNumLines() * (sam.SUI.Scale(16) --[[font size]] + 1) + 1 + 2)
		end
		entry:OnValueChange()
	end

	do
		local setting = body:Add("SAM.LabelPanel")
		setting:Dock(TOP)
		setting:SetLabel("Position")
		setting:DockMargin(8, 6, 8, 0)

		local combo = setting:Add("SAM.ComboBox")
		combo:SetWide(60)
		combo:AddChoice("Left", nil, true)
		combo:AddChoice("Right")
		combo:SetConfig("Reports.Position", "Left")
	end

	do
		local setting = body:Add("SAM.LabelPanel")
		setting:Dock(TOP)
		setting:SetLabel("X Padding")
		setting:DockMargin(8, 6, 8, 0)

		number_entry(setting, "Reports.XPadding", 5)
	end

	do
		local setting = body:Add("SAM.LabelPanel")
		setting:Dock(TOP)
		setting:SetLabel("Y Padding")
		setting:DockMargin(8, 6, 8, 0)

		number_entry(setting, "Reports.YPadding", 5)
	end

	return body
end, function()
	return LocalPlayer():HasPermission("manage_config")
end, 2)
--addons/sam/lua/sam/menu/tabs/ranks.lua:
if SAM_LOADED then return end
if SERVER then return end

local sam = sam
local SUI = sam.SUI

local GetColor = SUI.GetColor
local Line = sui.TDLib.LibClasses.Line
local AnimatedSetVisible = sui.TDLib.LibClasses.AnimatedSetVisible

local RANK_NAME = SUI.CreateFont("RankName", "Roboto Bold", 18)
local RANK_INFO = SUI.CreateFont("RankInfo", "Roboto Medium", 12)

local CREATE_RANK = SUI.CreateFont("CreateRank", "Roboto Bold", 16, 200)
local RANK_TITLE = SUI.CreateFont("RankTitle", "Roboto Bold", 20)

local rank_menu = function(rank, data)
	local valid = sui.valid_options()

	local imm, banlim
	if rank then
		imm, banlim = data.immunity, data.ban_limit
	end

	local edit_rank = vgui.Create("SAM.QueryBox")
	edit_rank:SetWide(470)
	edit_rank:SetTitle(rank and string.format("Edit Rank '%s'", rank) or "Create Rank")

	local new_name = rank
	if not sam.ranks.is_default_rank(rank) then
		local name = edit_rank:Add("SAM.LabelPanel")
		name:SetLabel("Rank Name")

		local entry = name:Add("SAM.TextEntry")
		entry:SetSize(210, 28)
		entry:SetNoBar(false)
		entry:SetPlaceholder("")
		entry:SetValue(rank or "")
		entry:SetCheck(function(_name)
			new_name = _name

			if _name == rank then return end
			if _name == "" or sam.ranks.is_rank(_name) then
				return false
			end
		end)

		valid.Add(entry)
	end

	local new_immunity = imm
	do
		local immunity = edit_rank:Add("SAM.LabelPanel")
		immunity:SetLabel("Immunity (2~99)")
		immunity:DockMargin(0, 5, 0, 0)

		local entry = immunity:Add("SAM.TextEntry")
		entry:SetSize(210, 28)
		entry:SetNumeric(true)
		entry:DisallowFloats(true)
		entry:DisallowNegative(true)
		entry:SetPlaceholder("")
		entry:SetValue(imm or "2")
		entry:SetCheck(function(_immunity)
			new_immunity = _immunity

			if _immunity == "" then
				return false
			end

			_immunity = tonumber(_immunity)
			new_immunity = _immunity
			if _immunity < 2 or _immunity > 99 then
				return false
			end
		end)

		valid.Add(entry)
	end

	local new_banlimit = banlim
	do
		local banlimit = edit_rank:Add("SAM.LabelPanel")
		banlimit:SetLabel("Ban Limit (1y 1mo 1w 1d 1h 1m)")
		banlimit:DockMargin(0, 5, 0, 0)

		local entry = banlimit:Add("SAM.TextEntry")
		entry:SetSize(210, 28)
		entry:SetNoBar(false)
		entry:SetPlaceholder("")
		entry:SetValue(banlim and sam.reverse_parse_length(banlim) or "2w")
		entry:SetCheck(function(_banlimit)
			new_banlimit = sam.parse_length(_banlimit)
			if not new_banlimit and _banlimit ~= banlim then
				return false
			end
		end)

		valid.Add(entry)
	end

	local inherit = rank and sam.ranks.get_rank(rank).inherit or "user"
	local new_inherit = inherit
	do
		local inherits_from = edit_rank:Add("SAM.LabelPanel")
		inherits_from:SetLabel("Inherits From")
		inherits_from:DockMargin(0, 5, 0, 0)

		local entry = inherits_from:Add("SAM.ComboBox")
		entry:SetSize(210, 28)
		entry:SetValue(inherit)

		for name in SortedPairsByMemberValue(sam.ranks.get_ranks(), "immunity", true) do
			if name ~= rank and not sam.ranks.inherits_from(name, rank) then
				entry:AddChoice(name)
			end
		end

		function entry:OnSelect(_, value)
			new_inherit = value
		end
	end


	edit_rank:Done()
	edit_rank.save:SetEnabled(true)
	edit_rank.save:SetText("SAVE")

	if rank then
		edit_rank:SetCallback(function()
			local to_run = {}

			if new_immunity ~= imm then
				table.insert(to_run, {"changerankimmunity", rank, new_immunity})
			end

			if new_banlimit ~= banlim then
				table.insert(to_run, {"changerankbanlimit", rank, new_banlimit})
			end

			if new_inherit ~= inherit then
				table.insert(to_run, {"changeinherit", rank, new_inherit})
			end

			if new_name ~= rank then
				table.insert(to_run, {"renamerank", rank, new_name})
			end
			sam.command.run_commands(to_run)
		end)
	else
		edit_rank:SetCallback(function()
			RunConsoleCommand("sam", "addrank", new_name, new_inherit, new_immunity, new_banlimit)
		end)
	end

	function edit_rank.save:Think()
		self:SetEnabled(valid.IsValid())
	end
end

sam.menu.add_tab("https://raw.githubusercontent.com/Srlion/Addons-Data/main/icons/sam/military_rank.png", function(column_sheet)
	local current_rank

	local parent = column_sheet:Add("Panel")
	parent:Dock(FILL)
	parent:DockMargin(0, 1, 0, 0)

	local title = parent:Add("SAM.Label")
	title:Dock(TOP)
	title:DockMargin(10, 10, 0, 0)
	title:SetFont(SAM_TAB_TITLE_FONT)
	title:SetText("Ranks")
	title:SetTextColor(GetColor("menu_tabs_title"))
	title:SizeToContents()

	local total = parent:Add("SAM.Label")
	total:Dock(TOP)
	total:DockMargin(10, 6, 0, 0)
	total:SetFont(SAM_TAB_DESC_FONT)
	total:SetText(table.Count(sam.ranks.get_ranks()) .. " total ranks")
	total:SetTextColor(GetColor("menu_tabs_title"))
	total:SizeToContents()

	local search_entry
	do
		local container = parent:Add("SAM.Panel")
		container:Dock(TOP)
		container:DockMargin(10, 6, 10, SUI.Scale(15))
		container:SetTall(30)

		search_entry = container:Add("SAM.TextEntry")
		search_entry:Dock(LEFT)
		search_entry:SetNoBar(true)
		search_entry:SetPlaceholder("Search...")
		search_entry:SetRadius(4)
		search_entry:SetWide(220)
	end

	local create_rank = parent:Add("SAM.Button")
	create_rank:SetFont(CREATE_RANK)
	create_rank:SetText("Create Rank")
	create_rank:Dock(BOTTOM)
	create_rank:DockMargin(10, 0, 10, 10)

	create_rank:On("DoClick", function()
		rank_menu()
	end)

	local right_body = parent:Add("Panel")
	right_body:Dock(RIGHT)
	right_body:DockMargin(0, 5, 10, 10)
	right_body:SetWide(0)
	right_body:SetZPos(-1)

	local rank_title = right_body:Add("SAM.Label")
	rank_title:Dock(TOP)
	rank_title:DockMargin(0, 0, 0, 5)
	rank_title:SetFont(RANK_TITLE)
	rank_title:SetTextColor(GetColor("menu_tabs_title"))

	local permissions_body = right_body:Add("SAM.CollapseCategory")
	permissions_body:Dock(FILL)
	permissions_body:GetCanvas():DockPadding(0, 0, 5, 0)

	local function refresh_access()
		if not IsValid(current_rank) then return end

		for k, v in ipairs(permissions_body.items) do
			AnimatedSetVisible(v.img, sam.ranks.has_permission(current_rank.name, v.name))
		end
	end

	for k, v in ipairs({"SAM.ChangedInheritRank", "SAM.RankPermissionGiven", "SAM.RankPermissionTaken"}) do
		hook.Add(v, "SAM.Menu.RefreshPermissions ", refresh_access)
	end

	local function refresh_permissions()
		permissions_body:GetCanvas():Clear()
		table.Empty(permissions_body.items)
		table.Empty(permissions_body.categories)

		local item_click = function(s)
			local rank = current_rank.name
			if not sam.ranks.has_permission(rank, s.name) then
				RunConsoleCommand("sam", "givepermission", rank, s.name)
			else
				RunConsoleCommand("sam", "takepermission", rank, s.name)
			end
		end

		for k, v in ipairs(sam.permissions.get()) do
			local item = permissions_body:add_item(v.name, v.category)
			item:SetContentAlignment(4)
			item:SetTextInset(6, 0)
			item:SizeToContentsY(SUI.Scale(10))
			item:SetZPos(k)
			item.name = v.name
			item.DoClick = item_click

			local img = item:Add("SAM.Image")
			img:Dock(RIGHT)
			img:DockMargin(4, 4, 4, 4)
			img:InvalidateParent(true)
			img:SetWide(img:GetTall())
			img:SetImageColor(Color(52, 161, 224))
			img:SetImage("https://raw.githubusercontent.com/Srlion/Addons-Data/main/icons/sam/check_mark.png")

			item.img = img
		end
	end

	local limits_body

	do
		local permissions_search = right_body:Add("SAM.TextEntry")
		permissions_search:Dock(TOP)
		permissions_search:DockMargin(0, 0, 5, 10)
		permissions_search:SetNoBar(true)
		permissions_search:SetPlaceholder("Search...")
		permissions_search:SetRadius(4)
		permissions_search:SetTall(30)

		function permissions_search:OnValueChange(text)
			if limits_body and limits_body:IsVisible() then
				local children = limits_body:GetCanvas():GetChildren()
				for k, v in ipairs(children) do
					v:AnimatedSetVisible(v.title:find(text, nil, true) ~= nil)
				end
				limits_body:InvalidateLayout(true)
			else
				permissions_body:Search(text:lower())
			end
		end

		Line(right_body):SetZPos(2)
	end

	local function load_limits()
		if sam.limit_types then
			if limits_body then return end
		else
			if limits_body then
				limits_body:SetVisible(false)
				permissions_body:AnimatedSetVisible(true)
				limits_body:Remove()
				limits_body = nil
			end
			return
		end

		limits_body = right_body:Add("SAM.ScrollPanel")
		limits_body:Dock(FILL)
		limits_body:GetCanvas():DockPadding(0, 0, 5, 0)
		limits_body:SetVisible(false)

		local item_enter = function(s)
			if not IsValid(current_rank) then return end

			local rank = current_rank.name

			local limit = math.Clamp(s:GetValue(), -1, 1000)
			if limit ~= sam.ranks.get_limit(rank, s.limit_type) then
				RunConsoleCommand("sam", "changeranklimit", rank, s.limit_type, limit)
			else
				s:SetText(tostring(sam.ranks.get_limit(rank, s.limit_type)))
			end
		end

		local not_empty = function(s)
			return s and s ~= ""
		end

		local limit_values = {}
		for k, v in ipairs(sam.limit_types) do
			local immunity = limits_body:Add("SAM.LabelPanel")
			immunity:SetLabel(v)
			immunity:DockMargin(5, 0, 0, 5)

			local entry = immunity:Add("SAM.TextEntry")
			entry:SetSize(60, 26)
			entry:SetNumeric(true)
			entry:DisallowFloats(true)
			entry:SetPlaceholder("")
			entry:SetCheck(not_empty)
			entry.limit_type = v
			entry.OnEnter = item_enter

			table.insert(limit_values, entry)
		end

		function limits_body:Refresh()
			if not IsValid(current_rank) then return end

			local rank = current_rank.name
			for k, v in ipairs(limit_values) do
				v:SetValue(tostring(sam.ranks.get_limit(rank, v.limit_type)))
			end
		end

		local right_current_rank = right_body:Add("SAM.Button")
		right_current_rank:Dock(BOTTOM)
		right_current_rank:DockMargin(0, 5, 0, 0)
		right_current_rank:SetFont(CREATE_RANK)
		right_current_rank:SetText("Switch to Limits")
		right_current_rank:On("DoClick", function()
			limits_body:AnimatedToggleVisible()
			permissions_body:AnimatedToggleVisible()

			if permissions_body:AnimatedIsVisible() then
				right_current_rank:SetText("Switch to Limits")
			else
				right_current_rank:SetText("Switch to Permissions")
			end
		end)

		limits_body:On("OnRemove", function()
			right_current_rank:Remove()
		end)
		limits_body:Refresh()
	end

	local function refresh_all()
		timer.Create("SAM.Menu.Ranks.Refresh", 1, 1, function()
			load_limits()
			refresh_permissions()
			refresh_access()
		end)
	end

	sam.config.hook({"Restrictions.Limits"}, refresh_all)

	for k, v in ipairs({"SAM.AddedPermission", "SAM.PermissionModified", "SAM.RemovedPermission"}) do
		hook.Add(v, "SAM.Menu.RefreshPermissions", refresh_all)
	end

	local body = parent:Add("SAM.ScrollPanel")
	body:Dock(FILL)
	body:DockMargin(10, 0, 5, 10)
	body:SetVBarPadding(6)

	body:Line():SetZPos(-101)

	local select_rank = function(s)
		if not IsValid(s) then
			current_rank = nil
			right_body:SizeTo(0, -1, 0.3)
			return
		end

		if IsValid(current_rank) then
			current_rank.Selected = false

			if current_rank == s then
				current_rank = nil
				right_body:SizeTo(0, -1, 0.3)
				return
			end
		end

		s.Selected = true
		current_rank = s
		refresh_access()
		if limits_body then
			limits_body:Refresh()
		end
		right_body:SizeTo(SUI.Scale(300), -1, 0.3)

		rank_title:SetText(s.name)
		rank_title:SizeToContents()
	end

	local ranks = {}

	function search_entry:OnValueChange()
		local value = self:GetValue()
		for k, v in pairs(ranks) do
			local show = k:find(value, nil, true)
			show = show ~= nil
			v.line:AnimatedSetVisible(show)
			v:GetParent():AnimatedSetVisible(show)
		end
	end

	local add_rank = function(rank_name, data)
		if rank_name == "superadmin" then return end
		if not IsValid(body) then return end

		local line = body:Add("SAM.Panel")
		line:Dock(TOP)
		line:DockMargin(0, 0, 0, 10)
		line:SetTall(34)
		line:SetZPos(-data.immunity)
		line:InvalidateLayout(true)

		local container = line:Add("SAM.Button")
		container:Dock(FILL)
		container:DockMargin(0, 0, 5, 0)
		container:DockPadding(5, 5, 0, 5)
		container:SetText("")
		container:SetContained(false)
		container.name = rank_name

		ranks[rank_name] = container

		container:On("DoClick", select_rank)

		function container:DoRightClick()
			rank_name = container.name

			if rank_name == "user" then return end

			local dmenu = vgui.Create("SAM.Menu")
			dmenu:SetSize(w, h)
			dmenu:SetInternal(container)

			dmenu:AddOption("Edit Rank", function()
				rank_menu(rank_name, sam.ranks.get_rank(rank_name))
			end)

			if not sam.ranks.is_default_rank(rank_name) then
				dmenu:AddSpacer()

				dmenu:AddOption("Remove Rank", function()
					local remove_rank = vgui.Create("SAM.QueryBox")
					remove_rank:SetWide(350)

					local check = remove_rank:Add("SAM.Label")
					check:SetText("Are you sure that you want to remove '" .. rank_name .. "'?")
					check:SetFont("SAMLine")
					check:SetWrap(true)
					check:SetAutoStretchVertical(true)

					remove_rank:Done()
					remove_rank.save:SetEnabled(true)
					remove_rank.save:SetText("REMOVE")
					remove_rank.save:SetContained(false)
					remove_rank.save:SetColors(GetColor("query_box_cancel"), GetColor("query_box_cancel_text"))

					remove_rank.cancel:SetContained(true)
					remove_rank.cancel:SetColors()

					remove_rank:SetCallback(function()
						RunConsoleCommand("sam", "removerank", rank_name)
					end)
				end)
			end

			dmenu:Open()
			dmenu:SetPos(input.GetCursorPos())
		end

		do
			local name = container:Add("SAM.Label")
			name:Dock(TOP)
			name:DockMargin(0, 0, 0, 2)
			name:SetTextColor(GetColor("player_list_names"))
			name:SetFont(RANK_NAME)
			name:SetText(rank_name)
			name:SizeToContents()

			local immunity = container:Add("SAM.Label")
			immunity:Dock(TOP)
			immunity:SetTextColor(GetColor("player_list_steamid"))
			immunity:SetFont(RANK_INFO)
			immunity:SetText("Immunity: " .. data.immunity)
			immunity:SizeToContents()

			local banlimit = container:Add("SAM.Label")
			banlimit:Dock(TOP)
			banlimit:SetTextColor(GetColor("player_list_steamid"))
			banlimit:SetFont(RANK_INFO)
			banlimit:SetText("Ban limit: " .. sam.reverse_parse_length(sam.parse_length(data.ban_limit)))
			banlimit:SizeToContents()

			local inherit = container:Add("SAM.Label")
			inherit:Dock(TOP)
			inherit:SetTextColor(GetColor("player_list_steamid"))
			inherit:SetFont(RANK_INFO)
			inherit:SetText("Inherits from: " .. (sam.isstring(data.inherit) and data.inherit or "none"))
			inherit:SizeToContents()
		end

		container:InvalidateLayout(true)
		container:SizeToChildren(false, true)
		line:SizeToChildren(false, true)

		local _line = body:Line()
		_line:SetZPos(-data.immunity)

		container.line = _line
		container.data = data
	end

	for rank_name, v in pairs(sam.ranks.get_ranks()) do
		add_rank(rank_name, v)
	end

	hook.Add("SAM.AddedRank", "SAM.RefreshRanksList", function(name, rank)
		add_rank(name, rank)
	end)

	hook.Add("SAM.RemovedRank", "SAM.RefreshRanksList", function(name)
		local line = ranks[name]
		if not IsValid(line) then return end

		line.line:Remove()
		line:GetParent():Remove()
		ranks[name] = nil

		if line == current_rank then
			select_rank()
		end
	end)

	-- This is just better than caching panels for stuff that ain't gonna be called a lot
	hook.Add("SAM.RankNameChanged", "SAM.RefreshRanksList", function(name, new_name)
		local line = ranks[name]
		if not IsValid(line) then return end

		-- if current_rank == name then
		-- 	rank_name:SetText(new_name)
		-- end

		line:GetChildren()[1]:SetText(new_name)

		ranks[new_name], ranks[name] = line, nil
		line.name = new_name
	end)

	hook.Add("SAM.RankImmunityChanged", "SAM.RefreshRanksList", function(name, immunity)
		local line = ranks[name]
		if not IsValid(line) then return end

		line:GetChildren()[2]:SetText("Immunity: " .. immunity)
		line:GetParent():SetZPos(-immunity)

		-- SetZPos is kinda weird to deal with
		line.line:SetZPos(-immunity + 1)
		line.line:SetZPos(-immunity)
	end)

	hook.Add("SAM.RankBanLimitChanged", "SAM.RefreshRanksList", function(name, new_limit)
		local line = ranks[name]
		if IsValid(line) then
			line:GetChildren()[3]:SetText("Ban limit: " .. sam.reverse_parse_length(new_limit))
		end
	end)

	hook.Add("SAM.ChangedInheritRank", "SAM.RefreshRanksList", function(name, new_inherit)
		local line = ranks[name]
		if IsValid(line) then
			line:GetChildren()[4]:SetText("Inherits from: " .. new_inherit)
		end
	end)

	return parent
end, function()
	return LocalPlayer():HasPermission("manage_ranks")
end, 3)
--addons/sam/lua/sam/modules/cami.lua:
if SAM_LOADED then return end

--[[
CAMI - Common Admin Mod Interface.
Copyright 2020 CAMI Contributors

Makes admin mods intercompatible and provides an abstract privilege interface
for third party addons.

Follows the specification on this page:
https://github.com/glua/CAMI/blob/master/README.md

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
]]

-- Version number in YearMonthDay format.
local version = 20201130

if CAMI and CAMI.Version >= version then return end

CAMI = CAMI or {}
CAMI.Version = version


--- @class CAMI_USERGROUP
--- defines the charactaristics of a usergroup
--- @field Name string @The name of the usergroup
--- @field Inherits string @The name of the usergroup this usergroup inherits from

--- @class CAMI_PRIVILEGE
--- defines the charactaristics of a privilege
--- @field Name string @The name of the privilege
--- @field MinAccess "'user'" | "'admin'" | "'superadmin'" @Default group that should have this privilege
--- @field Description string | nil @Optional text describing the purpose of the privilege
local CAMI_PRIVILEGE = {}
--- Optional function to check if a player has access to this privilege
--- (and optionally execute it on another player)
---
--- ⚠ **Warning**: This function may not be called by all admin mods
--- @param actor GPlayer @The player
--- @param target GPlayer | nil @Optional - the target
--- @return boolean @If they can or not
--- @return string | nil @Optional reason
function CAMI_PRIVILEGE:HasAccess(actor, target)
end

--- Contains the registered CAMI_USERGROUP usergroup structures.
--- Indexed by usergroup name.
--- @type CAMI_USERGROUP[]
local usergroups = CAMI.GetUsergroups and CAMI.GetUsergroups() or {
    user = {
        Name = "user",
        Inherits = "user"
    },
    admin = {
        Name = "admin",
        Inherits = "user"
    },
    superadmin = {
        Name = "superadmin",
        Inherits = "admin"
    }
}

--- Contains the registered CAMI_PRIVILEGE privilege structures.
--- Indexed by privilege name.
--- @type CAMI_PRIVILEGE[]
local privileges = CAMI.GetPrivileges and CAMI.GetPrivileges() or {}

--- Registers a usergroup with CAMI.
---
--- Use the source parameter to make sure CAMI.RegisterUsergroup function and
--- the CAMI.OnUsergroupRegistered hook don't cause an infinite loop
--- @param usergroup CAMI_USERGROUP @The structure for the usergroup you want to register
--- @param source any @Identifier for your own admin mod. Can be anything.
--- @return CAMI_USERGROUP @The usergroup given as an argument
function CAMI.RegisterUsergroup(usergroup, source)
    usergroups[usergroup.Name] = usergroup

    hook.Call("CAMI.OnUsergroupRegistered", nil, usergroup, source)
    return usergroup
end

--- Unregisters a usergroup from CAMI. This will call a hook that will notify
--- all other admin mods of the removal.
---
--- ⚠ **Warning**: Call only when the usergroup is to be permanently removed.
---
--- Use the source parameter to make sure CAMI.UnregisterUsergroup function and
--- the CAMI.OnUsergroupUnregistered hook don't cause an infinite loop
--- @param usergroupName string @The name of the usergroup.
--- @param source any @Identifier for your own admin mod. Can be anything.
--- @return boolean @Whether the unregistering succeeded.
function CAMI.UnregisterUsergroup(usergroupName, source)
    if not usergroups[usergroupName] then return false end

    local usergroup = usergroups[usergroupName]
    usergroups[usergroupName] = nil

    hook.Call("CAMI.OnUsergroupUnregistered", nil, usergroup, source)

    return true
end

--- Retrieves all registered usergroups.
--- @return CAMI_USERGROUP[] @Usergroups indexed by their names.
function CAMI.GetUsergroups()
    return usergroups
end

--- Receives information about a usergroup.
--- @param usergroupName string
--- @return CAMI_USERGROUP | nil @Returns nil when the usergroup does not exist.
function CAMI.GetUsergroup(usergroupName)
    return usergroups[usergroupName]
end

--- Checks to see if potentialAncestor is an ancestor of usergroupName.
--- All usergroups are ancestors of themselves.
---
--- Examples:
--- * `user` is an ancestor of `admin` and also `superadmin`
--- * `admin` is an ancestor of `superadmin`, but not `user`
--- @param usergroupName string @The usergroup to query
--- @param potentialAncestor string @The ancestor to query
--- @return boolean @Whether usergroupName inherits potentialAncestor.
function CAMI.UsergroupInherits(usergroupName, potentialAncestor)
    repeat
        if usergroupName == potentialAncestor then return true end

        usergroupName = usergroups[usergroupName] and
                         usergroups[usergroupName].Inherits or
                         usergroupName
    until not usergroups[usergroupName] or
          usergroups[usergroupName].Inherits == usergroupName

    -- One can only be sure the usergroup inherits from user if the
    -- usergroup isn't registered.
    return usergroupName == potentialAncestor or potentialAncestor == "user"
end

--- Find the base group a usergroup inherits from.
---
--- This function traverses down the inheritence chain, so for example if you have
--- `user` -> `group1` -> `group2`
--- this function will return `user` if you pass it `group2`.
---
--- ℹ **NOTE**: All usergroups must eventually inherit either user, admin or superadmin.
--- @param usergroupName string @The name of the usergroup
--- @return "'user'" | "'admin'" | "'superadmin'" @The name of the root usergroup
function CAMI.InheritanceRoot(usergroupName)
    if not usergroups[usergroupName] then return end

    local inherits = usergroups[usergroupName].Inherits
    while inherits ~= usergroups[usergroupName].Inherits do
        usergroupName = usergroups[usergroupName].Inherits
    end

    return usergroupName
end

--- Registers an addon privilege with CAMI.
---
--- ⚠ **Warning**: This should only be used by addons. Admin mods must *NOT*
---  register their privileges using this function.
--- @param privilege CAMI_PRIVILEGE
--- @return CAMI_PRIVILEGE @The privilege given as argument.
function CAMI.RegisterPrivilege(privilege)
    privileges[privilege.Name] = privilege

    hook.Call("CAMI.OnPrivilegeRegistered", nil, privilege)

    return privilege
end

--- Unregisters a privilege from CAMI.
--- This will call a hook that will notify any admin mods of the removal.
---
--- ⚠ **Warning**: Call only when the privilege is to be permanently removed.
--- @param privilegeName string @The name of the privilege.
--- @return boolean @Whether the unregistering succeeded.
function CAMI.UnregisterPrivilege(privilegeName)
    if not privileges[privilegeName] then return false end

    local privilege = privileges[privilegeName]
    privileges[privilegeName] = nil

    hook.Call("CAMI.OnPrivilegeUnregistered", nil, privilege)

    return true
end

--- Retrieves all registered privileges.
--- @return CAMI_PRIVILEGE[] @All privileges indexed by their names.
function CAMI.GetPrivileges()
    return privileges
end

--- Receives information about a privilege.
--- @param privilegeName string
--- @return CAMI_PRIVILEGE | nil
function CAMI.GetPrivilege(privilegeName)
    return privileges[privilegeName]
end

-- Default access handler
local defaultAccessHandler = {["CAMI.PlayerHasAccess"] =
    function(_, actorPly, privilegeName, callback, targetPly, extraInfoTbl)
        -- The server always has access in the fallback
        if not IsValid(actorPly) then return callback(true, "Fallback.") end

        local priv = privileges[privilegeName]

        local fallback = extraInfoTbl and (
            not extraInfoTbl.Fallback and actorPly:IsAdmin() or
            extraInfoTbl.Fallback == "user" and true or
            extraInfoTbl.Fallback == "admin" and actorPly:IsAdmin() or
            extraInfoTbl.Fallback == "superadmin" and actorPly:IsSuperAdmin())


        if not priv then return callback(fallback, "Fallback.") end

        local hasAccess =
            priv.MinAccess == "user" or
            priv.MinAccess == "admin" and actorPly:IsAdmin() or
            priv.MinAccess == "superadmin" and actorPly:IsSuperAdmin()

        if hasAccess and priv.HasAccess then
            hasAccess = priv:HasAccess(actorPly, targetPly)
        end

        callback(hasAccess, "Fallback.")
    end,
    ["CAMI.SteamIDHasAccess"] =
    function(_, _, _, callback)
        callback(false, "No information available.")
    end
}

--- @class CAMI_ACCESS_EXTRA_INFO
--- @field Fallback "'user'" | "'admin'" | "'superadmin'" @Fallback status for if the privilege doesn't exist. Defaults to `admin`.
--- @field IgnoreImmunity boolean @Ignore any immunity mechanisms an admin mod might have.
--- @field CommandArguments table @Extra arguments that were given to the privilege command.

--- Checks if a player has access to a privilege
--- (and optionally can execute it on targetPly)
---
--- This function is designed to be asynchronous but will be invoked
---  synchronously if no callback is passed.
---
--- ⚠ **Warning**: If the currently installed admin mod does not support
---                 synchronous queries, this function will throw an error!
--- @param actorPly GPlayer @The player to query
--- @param privilegeName string @The privilege to query
--- @param callback fun(hasAccess: boolean, reason: string|nil) @Callback to receive the answer, or nil for synchronous
--- @param targetPly GPlayer | nil @Optional - target for if the privilege effects another player (eg kick/ban)
--- @param extraInfoTbl CAMI_ACCESS_EXTRA_INFO | nil @Table of extra information for the admin mod
--- @return boolean | nil @Synchronous only - if the player has the privilege
--- @return string | nil @Synchronous only - optional reason from admin mod
function CAMI.PlayerHasAccess(actorPly, privilegeName, callback, targetPly,
extraInfoTbl)
    local hasAccess, reason = nil, nil
    local callback_ = callback or function(hA, r) hasAccess, reason = hA, r end

    hook.Call("CAMI.PlayerHasAccess", defaultAccessHandler, actorPly,
        privilegeName, callback_, targetPly, extraInfoTbl)

    if callback ~= nil then return end

    if hasAccess == nil then
        local err = [[The function CAMI.PlayerHasAccess was used to find out
        whether Player %s has privilege "%s", but an admin mod did not give an
        immediate answer!]]
        error(string.format(err,
            actorPly:IsPlayer() and actorPly:Nick() or tostring(actorPly),
            privilegeName))
    end

    return hasAccess, reason
end

--- Get all the players on the server with a certain privilege
--- (and optionally who can execute it on targetPly)
---
--- ℹ **NOTE**: This is an asynchronous function!
--- @param privilegeName string @The privilege to query
--- @param callback fun(players: GPlayer[]) @Callback to receive the answer
--- @param targetPly GPlayer | nil @Optional - target for if the privilege effects another player (eg kick/ban)
--- @param extraInfoTbl CAMI_ACCESS_EXTRA_INFO | nil @Table of extra information for the admin mod
function CAMI.GetPlayersWithAccess(privilegeName, callback, targetPly,
extraInfoTbl)
    local allowedPlys = {}
    local allPlys = player.GetAll()
    local countdown = #allPlys

    local function onResult(ply, hasAccess, _)
        countdown = countdown - 1

        if hasAccess then table.insert(allowedPlys, ply) end
        if countdown == 0 then callback(allowedPlys) end
    end

    for _, ply in ipairs(allPlys) do
        CAMI.PlayerHasAccess(ply, privilegeName,
            function(...) onResult(ply, ...) end,
            targetPly, extraInfoTbl)
    end
end

--- @class CAMI_STEAM_ACCESS_EXTRA_INFO
--- @field IgnoreImmunity boolean @Ignore any immunity mechanisms an admin mod might have.
--- @field CommandArguments table @Extra arguments that were given to the privilege command.

--- Checks if a (potentially offline) SteamID has access to a privilege
--- (and optionally if they can execute it on a target SteamID)
---
--- ℹ **NOTE**: This is an asynchronous function!
--- @param actorSteam string | nil @The SteamID to query
--- @param privilegeName string @The privilege to query
--- @param callback fun(hasAccess: boolean, reason: string|nil) @Callback to receive  the answer
--- @param targetSteam string | nil @Optional - target SteamID for if the privilege effects another player (eg kick/ban)
--- @param extraInfoTbl CAMI_STEAM_ACCESS_EXTRA_INFO | nil @Table of extra information for the admin mod
function CAMI.SteamIDHasAccess(actorSteam, privilegeName, callback,
targetSteam, extraInfoTbl)
    hook.Call("CAMI.SteamIDHasAccess", defaultAccessHandler, actorSteam,
        privilegeName, callback, targetSteam, extraInfoTbl)
end

--- Signify that your admin mod has changed the usergroup of a player. This
--- function communicates to other admin mods what it thinks the usergroup
--- of a player should be.
---
--- Listen to the hook to receive the usergroup changes of other admin mods.
--- @param ply GPlayer @The player for which the usergroup is changed
--- @param old string @The previous usergroup of the player.
--- @param new string @The new usergroup of the player.
--- @param source any @Identifier for your own admin mod. Can be anything.
function CAMI.SignalUserGroupChanged(ply, old, new, source)
    hook.Call("CAMI.PlayerUsergroupChanged", nil, ply, old, new, source)
end

--- Signify that your admin mod has changed the usergroup of a disconnected
--- player. This communicates to other admin mods what it thinks the usergroup
--- of a player should be.
---
--- Listen to the hook to receive the usergroup changes of other admin mods.
--- @param steamId string @The steam ID of the player for which the usergroup is changed
--- @param old string @The previous usergroup of the player.
--- @param new string @The new usergroup of the player.
--- @param source any @Identifier for your own admin mod. Can be anything.
function CAMI.SignalSteamIDUserGroupChanged(steamId, old, new, source)
    hook.Call("CAMI.SteamIDUsergroupChanged", nil, steamId, old, new, source)
end

--addons/sam/lua/sam/modules/fun.lua:
if SAM_LOADED then return end

local sam, command, language = sam, sam.command, sam.language

command.set_category("Fun")

do
	local sounds = {}
	for i = 1, 6 do
		sounds[i] = "physics/body/body_medium_impact_hard" .. i .. ".wav"
	end

	local slap = function(ply, damage, admin)
		if not ply:Alive() or ply:sam_get_nwvar("frozen") then return end
		ply:ExitVehicle()

		ply:SetVelocity(Vector(math.random(-100, 100), math.random(-100, 100), math.random(200, 400)))
		ply:EmitSound(sounds[math.random(1, 6)], 60, math.random(80, 120))

		if damage > 0 then
			ply:TakeDamage(damage, admin, DMG_GENERIC)
		end
	end

	command.new("slap")
		:SetPermission("slap", "admin")

		:AddArg("player")
		:AddArg("number", {hint = "damage", round = true, optional = true, min = 0, default = 0})

		:Help("slap_help")

		:OnExecute(function(ply, targets, damage)
			for i = 1, #targets do
				slap(targets[i], damage, ply)
			end

			if damage > 0 then
				sam.player.send_message(ply, "slap_damage", {
					A = ply, T = targets, V = damage
				})
			else
				sam.player.send_message(ply, "slap", {
					A = ply, T = targets
				})
			end
		end)
	:End()
end

command.new("slay")
	:SetPermission("slay", "admin")

	:AddArg("player")

	:Help("slay_help")

	:OnExecute(function(ply, targets)
		for i = 1, #targets do
			local v = targets[i]
			if not v:sam_get_exclusive(ply) then
				v:Kill()
			end
		end

		sam.player.send_message(ply, "slay", {
			A = ply, T = targets
		})
	end)
:End()

command.new("hp")
	:Aliases("sethp", "health", "sethealth")

	:SetPermission("hp", "admin")

	:AddArg("player")
	:AddArg("number", {hint = "amount", min = 1, max = 2147483647, round = true, optional = true, default = 100})

	:Help("hp_help")

	:OnExecute(function(ply, targets, amount)
		for i = 1, #targets do
			targets[i]:SetHealth(amount)
		end

		sam.player.send_message(ply, "set_hp", {
			A = ply, T = targets, V = amount
		})
	end)
:End()

command.new("armor")
	:Aliases("setarmor")

	:SetPermission("armor", "admin")

	:AddArg("player")
	:AddArg("number", {hint = "amount", min = 1, max = 2147483647, round = true, optional = true, default = 100})

	:Help("armor_help")

	:OnExecute(function(ply, targets, amount)
		for i = 1, #targets do
			targets[i]:SetArmor(amount)
		end

		sam.player.send_message(ply, "set_armor", {
			A = ply, T = targets, V = amount
		})
	end)
:End()

command.new("ignite")
	:SetPermission("ignite", "admin")

	:AddArg("player")
	:AddArg("number", {hint = "seconds", optional = true, default = 60, round = true})

	:Help("ignite_help")

	:OnExecute(function(ply, targets, length)
		for i = 1, #targets do
			local target = targets[i]

			if target:IsOnFire() then
				target:Extinguish()
			end

			target:Ignite(length)
		end

		sam.player.send_message(ply, "ignite", {
			A = ply, T = targets, V = length
		})
	end)
:End()

command.new("unignite")
	:Aliases("extinguish")

	:SetPermission("ignite", "admin")

	:AddArg("player", {optional = true})

	:Help("unignite_help")

	:OnExecute(function(ply, targets)
		for i = 1, #targets do
			targets[i]:Extinguish()
		end

		sam.player.send_message(ply, "unignite", {
			A = ply, T = targets
		})
	end)
:End()

command.new("god")
	:Aliases("invincible")

	:SetPermission("god", "admin")

	:AddArg("player", {optional = true})

	:Help("god_help")

	:OnExecute(function(ply, targets)
		for i = 1, #targets do
			local target = targets[i]
			target:GodEnable()
			target.sam_has_god_mode = true
		end

		sam.player.send_message(ply, "god", {
			A = ply, T = targets
		})
	end)
:End()

command.new("ungod")
	:Aliases("uninvincible")

	:SetPermission("ungod", "admin")

	:AddArg("player", {optional = true})

	:Help("ungod_help")

	:OnExecute(function(ply, targets)
		for i = 1, #targets do
			local target = targets[i]
			target:GodDisable()
			target.sam_has_god_mode = nil
		end

		sam.player.send_message(ply, "ungod", {
			A = ply, T = targets
		})
	end)
:End()

do
	command.new("freeze")
		:SetPermission("freeze", "admin")

		:AddArg("player")

		:Help("freeze_help")

		:OnExecute(function(ply, targets)
			for i = 1, #targets do
				local v = targets[i]
				v:ExitVehicle()
				if v:sam_get_nwvar("frozen") then
					v:UnLock()
				end
				v:Lock()
				v:sam_set_nwvar("frozen", true)
				v:sam_set_exclusive("frozen")
			end

			sam.player.send_message(ply, "freeze", {
				A = ply, T = targets
			})
		end)
	:End()

	command.new("unfreeze")
		:SetPermission("unfreeze", "admin")

		:AddArg("player", {optional = true})

		:Help("unfreeze_help")

		:OnExecute(function(ply, targets)
			for i = 1, #targets do
				local v = targets[i]
				v:UnLock()
				v:sam_set_nwvar("frozen", false)
				v:sam_set_exclusive(nil)
			end

			sam.player.send_message(ply, "unfreeze", {
				A = ply, T = targets
			})
		end)
	:End()

	local disallow = function(ply)
		if ply:sam_get_nwvar("frozen") then
			return false
		end
	end

	for _, v in ipairs({"SAM.CanPlayerSpawn", "CanPlayerSuicide", "CanTool"}) do
		hook.Add(v, "SAM.FreezePlayer." .. v, disallow)
	end
end

command.new("cloak")
	:SetPermission("cloak", "admin")

	:AddArg("player", {optional = true})

	:Help("cloak_help")

	:OnExecute(function(ply, targets)
		for i = 1, #targets do
			targets[i]:sam_cloak()
		end

		sam.player.send_message(ply, "cloak", {
			A = ply, T = targets
		})
	end)
:End()

command.new("uncloak")
	:SetPermission("uncloak", "admin")

	:AddArg("player", {optional = true})

	:Help("uncloak_help")

	:OnExecute(function(ply, targets)
		for i = 1, #targets do
			targets[i]:sam_uncloak()
		end

		sam.player.send_message(ply, "uncloak", {
			A = ply, T = targets
		})
	end)
:End()

do
	local jail_props = {
		Vector(0, 0, -5), Angle(90, 0, 0);
		Vector(0, 0, 97), Angle(90, 0, 0);

		Vector(21, 31, 46), Angle(0, 90, 0);
		Vector(21, -31, 46), Angle(0, 90, 0);
		Vector(-21, 31, 46), Angle(0, 90, 0);
		Vector(-21, -31, 46), Angle(0, 90, 0);

		Vector(-52, 0, 46), Angle(0, 0, 0);
		Vector(52, 0, 46), Angle(0, 0, 0)
	}

	local remove_jail = function(ply_jail_props)
		for _, jail_prop in ipairs(ply_jail_props) do
			if IsValid(jail_prop) then
				jail_prop:Remove()
			end
		end
	end

	local unjail = function(ply)
		if not IsValid(ply) then return end
		if not ply:sam_get_nwvar("jailed") then return end

		remove_jail(ply.sam_jail_props)

		ply.sam_jail_props = nil
		ply.sam_jail_pos = nil

		ply:sam_set_nwvar("jailed", nil)
		ply:sam_set_exclusive(nil)

		timer.Remove("SAM.Unjail." .. ply:SteamID())
		timer.Remove("SAM.Jail.Watch." .. ply:SteamID())
	end

	local return_false = function()
		return false
	end

	local function jail(ply, time)
		if not IsValid(ply) then return end
		if not isnumber(time) or time < 0 then
			time = 0
		end

		if ply:sam_get_nwvar("frozen") then
			RunConsoleCommand("sam", "unfreeze", "#" .. ply:EntIndex())
		end

		if not ply:sam_get_nwvar("jailed") or (not ply.sam_jail_props or not IsValid(ply.sam_jail_props[1])) then
			ply:ExitVehicle()
			ply:SetMoveType(MOVETYPE_WALK)

			ply.sam_jail_pos = ply:GetPos()

			ply:sam_set_nwvar("jailed", true)
			ply:sam_set_exclusive("in jail")

			if ply.sam_jail_props then
				for k, v in ipairs(ply.sam_jail_props) do
					if IsValid(v) then
						v:Remove()
					end
				end
			end

			local ply_jail_props = {}
			for i = 1, #jail_props, 2 do
				local jail_prop = ents.Create("prop_physics")
				jail_prop:SetModel("models/props_building_details/Storefront_Template001a_Bars.mdl")
				jail_prop:SetPos(ply.sam_jail_pos + jail_props[i])
				jail_prop:SetAngles(jail_props[i + 1])
				jail_prop:SetMoveType(MOVETYPE_NONE)
				jail_prop:Spawn()
				jail_prop:GetPhysicsObject():EnableMotion(false)
				jail_prop.CanTool = return_false
				jail_prop.PhysgunPickup = return_false
				jail_prop.jailWall = true
				table.insert(ply_jail_props, jail_prop)
			end
			ply.sam_jail_props = ply_jail_props
		end

		local steamid = ply:SteamID()

		if time == 0 then
			timer.Remove("SAM.Unjail." .. steamid)
		else
			timer.Create("SAM.Unjail." .. steamid, time, 1, function()
				if IsValid(ply) then
					unjail(ply)
				end
			end)
		end

		timer.Create("SAM.Jail.Watch." .. steamid, 0.5, 0, function()
			if not IsValid(ply) then
				return timer.Remove("SAM.Jail.Watch." .. steamid)
			end

			if ply:GetPos():DistToSqr(ply.sam_jail_pos) > 4900 then
				ply:SetPos(ply.sam_jail_pos)
			end

			if not IsValid(ply.sam_jail_props[1]) then
				jail(ply, timer.TimeLeft("SAM.Unjail." .. steamid) or 0)
			end
		end)
	end

	command.new("jail")
		:SetPermission("jail", "admin")

		:AddArg("player")
		:AddArg("length", {optional = true, default = 0, min = 0})
		:AddArg("text", {hint = "reason", optional = true, default = sam.language.get("default_reason")})

		:GetRestArgs()

		:Help("jail_help")

		:OnExecute(function(ply, targets, length, reason)
			for i = 1, #targets do
				jail(targets[i], length * 60)
			end

			sam.player.send_message(ply, "jail", {
				A = ply, T = targets, V = sam.format_length(length), V_2 = reason
			})
		end)
	:End()

	command.new("unjail")
		:SetPermission("unjail", "admin")

		:AddArg("player", {optional = true})

		:Help("unjail_help")

		:OnExecute(function(ply, targets)
			for i = 1, #targets do
				unjail(targets[i])
			end

			sam.player.send_message(ply, "unjail", {
				A = ply, T = targets
			})
		end)
	:End()

	sam.hook_first("CanProperty", "SAM.Jail", function(_, property, ent)
		if ent.jailWall and property == "remover" then
			return false
		end
	end)

	if SERVER then
		hook.Add("PlayerSpawn", "SAM.Jail", function(ply)
			if ply:sam_get_nwvar("jailed") or ply:sam_get_pdata("jailed") then
				if ply.sam_jail_pos then
					ply:SetPos(ply.sam_jail_pos)
				else
					ply:SetPos(ply:sam_get_pdata("jail_pos"))
					jail(ply, ply:sam_get_pdata("jail_time_left"))

					ply:sam_set_pdata("jailed", nil)
					ply:sam_set_pdata("jail_pos", nil)
					ply:sam_set_pdata("jail_time_left", nil)
				end
			end
		end)

		hook.Add("PlayerEnteredVehicle", "SAM.Jail", function(ply)
			if ply:sam_get_nwvar("jailed") then
				ply:ExitVehicle()
			end
		end)

		hook.Add("PlayerDisconnected", "SAM.Jail", function(ply)
			if ply:sam_get_nwvar("jailed") then
				remove_jail(ply.sam_jail_props)

				ply:sam_set_pdata("jailed", true)
				ply:sam_set_pdata("jail_pos", ply.sam_jail_pos)
				ply:sam_set_pdata("jail_time_left", timer.TimeLeft("SAM.Unjail." .. ply:SteamID()) or 0)

				timer.Remove("SAM.Unjail." .. ply:SteamID())
				timer.Remove("SAM.Jail.Watch." .. ply:SteamID())
			end
		end)
	end

	local disallow = function(ply)
		if ply:sam_get_nwvar("jailed") then
			return false
		end
	end

	for _, v in ipairs({"PlayerNoClip", "SAM.CanPlayerSpawn", "CanPlayerEnterVehicle", "CanPlayerSuicide", "CanTool"}) do
		hook.Add(v, "SAM.Jail", disallow)
	end
end

command.new("strip")
	:SetPermission("strip", "admin")

	:AddArg("player")

	:Help("strip_help")

	:OnExecute(function(ply, targets)
		for i = 1, #targets do
			targets[i]:StripWeapons()
		end

		sam.player.send_message(ply, "strip", {
			A = ply, T = targets
		})
	end)
:End()

command.new("respawn")
	:SetPermission("respawn", "admin")

	:AddArg("player", {optional = true})

	:Help("respawn_help")

	:OnExecute(function(ply, targets)
		for i = 1, #targets do
			targets[i]:Spawn()
		end

		sam.player.send_message(ply, "respawn", {
			A = ply, T = targets
		})
	end)
:End()

command.new("setmodel")
	:SetPermission("setmodel", "superadmin")

	:AddArg("player")
	:AddArg("text", {hint = "model"})

	:Help("setmodel_help")

	:OnExecute(function(ply, targets, model)
		for i = 1, #targets do
			targets[i]:SetModel(model)
		end

		sam.player.send_message(ply, "setmodel", {
			A = ply, T = targets, V = model
		})
	end)
:End()

command.new("giveammo")
	:Aliases("ammo")

	:SetPermission("giveammo", "superadmin")

	:AddArg("player")
	:AddArg("number", {hint = "amount", min = 0, max = 99999})

	:Help("giveammo_help")

	:OnExecute(function(ply, targets, amount)
		if amount == 0 then
			amount = 99999
		end

		for i = 1, #targets do
			local target = targets[i]
			for _, wep in ipairs(target:GetWeapons()) do
				if wep:GetPrimaryAmmoType() ~= -1 then
					target:GiveAmmo(amount, wep:GetPrimaryAmmoType(), true)
				end

				if wep:GetSecondaryAmmoType() ~= -1 then
					target:GiveAmmo(amount, wep:GetSecondaryAmmoType(), true)
				end
			end
		end

		sam.player.send_message(ply, "giveammo", {
			A = ply, T = targets, V = amount
		})
	end)
:End()

do
	command.new("scale")
		:SetPermission("scale", "superadmin")

		:AddArg("player")
		:AddArg("number", {hint = "amount", optional = true, min = 0, max = 2.5, default = 1})

		:Help("scale_help")

		:OnExecute(function(ply, targets, amount)
			for i = 1, #targets do
				local v = targets[i]
				v:SetModelScale(amount)

				-- https://github.com/carz1175/More-ULX-Commands/blob/9b142ee4247a84f16e2dc2ec71c879ab76e145d4/lua/ulx/modules/sh/extended.lua#L313
				v:SetViewOffset(Vector(0, 0, 64 * amount))
				v:SetViewOffsetDucked(Vector(0, 0, 28 * amount))

				v.sam_scaled = true
			end

			sam.player.send_message(ply, "scale", {
				A = ply, T = targets, V = amount
			})
		end)
	:End()

	hook.Add("PlayerSpawn", "SAM.Scale", function(ply)
		if ply.sam_scaled then
			ply.sam_scaled = nil
			ply:SetViewOffset(Vector(0, 0, 64))
			ply:SetViewOffsetDucked(Vector(0, 0, 28))
		end
	end)
end

sam.command.new("freezeprops")
	:SetPermission("freezeprops", "admin")
	:Help("freezeprops_help")

	:OnExecute(function(ply)
		for _, prop in ipairs(ents.FindByClass("prop_physics")) do
			local physics_obj = prop:GetPhysicsObject()
			if IsValid(physics_obj) then
				physics_obj:EnableMotion(false)
			end
		end

		sam.player.send_message(nil, "freezeprops", {
			A = ply
		})
	end)
:End()


command.new("setmaterial")
	:SetPermission("setmaterial", "admin")

	:AddArg("player")
	:AddArg("text", {hint = "material"})

	:Help("Change player(s)'s material.")

	:OnExecute(function(ply, targets, material)
		for i = 1, #targets do
			targets[i]:SetMaterial(material)
		end

		sam.player.send_message(ply, "You set a new material for yourself.", {
			A = ply, T = targets, V = material
		})
	end)
:End()

command.new("uncuff")
	:SetPermission("uncuff", "admin")

	:AddArg("player", {single_target = true})

	:Help("Uncuffs a player")

	:OnExecute(function(ply, targets)
		local target = targets[1]

		if target:sam_get_exclusive(ply) then
			ply:sam_send_message(target:sam_get_exclusive(ply))
			return
		end

		local _, cuffs = target:IsHandcuffed()

		if not IsValid(cuffs) then return end

		cuffs:Uncuff()

		if target ~= ply then
			Notify:Info(target, "Befreit", "Du wurdest von " .. ply:Nick() .. " aus den Handschellen befreit.")
		end

		Notify:Success(ply, "Befreit", "Du hast " .. target:Nick() .. " aus den Handschellen befreit.")
	end)
:End()

command.new("sound")
	:SetPermission("sound", "admin")

	:AddArg("text", {hint = "Sound"})
	:AddArg("number", {hint = "Volume", optional = false, min = 0, max = 1, default = 0.5})
	:AddArg("number", {hint = "Duration", optional = true, min = 0, max = 999, default = 0})

	:Help("Plays a sound to everyone.")

	:OnExecute(function(ply, sound, volume, duration)
		net.Start("wOS.PES.Sound")
			net.WriteString(sound)
			net.WriteFloat(volume)
			net.WriteInt(duration, 8)
		net.Send(player.GetHumans())
	end)
:End()

--addons/sui/lua/sui/vgui/sui_property_sheet.lua:
local draw = draw
local surface = surface
local vgui = vgui

local TYPE_MATERIAL = TYPE_MATERIAL

local RealFrameTime = RealFrameTime
local IsValid = IsValid
local Lerp = Lerp
local pairs = pairs
local TypeID = TypeID

local TDLib_Classes = sui.TDLib.LibClasses
local TextColor = TDLib_Classes.TextColor
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local PROPERTY_SHEET_FONT = SUI.CreateFont("PropertySheet", "Roboto Regular", 18)

local PANEL = {}

AccessorFunc(PANEL, "m_FontName", "Font", FORCE_STRING)

function PANEL:Init()
	self.tabs = {}

	self:SetFont(PROPERTY_SHEET_FONT)

	local tab_scroller = self:Add("DHorizontalScroller")
	tab_scroller:Dock(TOP)

	self.tabs_tall = 26
	self.tab_scroller = tab_scroller

	self:ScaleChanged()
	SUI.OnScaleChanged(self, self.ScaleChanged)
end

function PANEL:ScaleChanged()
	self.tab_scroller:SetTall(SUI.Scale(self.tabs_tall))

	for k, v in pairs(self.tab_scroller.Panels) do
		if v:IsValid() then
			if v.Material then
				v:SetWide(self.tab_scroller:GetTall())
			else
				v:SizeToContentsX()
			end
		end
	end

	self:InvalidateLayout(true)
end

function PANEL:Paint(w, h)
	self:RoundedBox("Background", 1, 0, 0, w, self.tab_scroller:GetTall(), SUI.GetColor("property_sheet_bg"))
end

function PANEL:PaintOver(w, h)
	local active_tab = self:GetActiveTab()
	if not IsValid(active_tab) then return end

	local tab_scroller = self.tab_scroller
	local offset = tab_scroller:GetTall() - SUI.Scale(1)

	local x = active_tab:LocalToScreen(0) - self:LocalToScreen(0)

	if not self.activeTabX then
		self.activeTabX = x
		self.activeTabW = active_tab:GetWide()
	end

	local delta = RealFrameTime() * 6
	if delta then
		self.activeTabX = Lerp(delta, self.activeTabX, x)
		self.activeTabW = Lerp(delta, self.activeTabW, active_tab:GetWide())
	end

	self:RoundedBox("Background2", 1, self.activeTabX, tab_scroller.y + offset, self.activeTabW, SUI.Scale(1), SUI.GetColor("property_sheet_tab_active"))
end

local tab_Paint = function(s, w, h)
	s.circle_click_color = SUI.GetColor("property_sheet_tab_click")
	if s.property_sheet:GetActiveTab() == s then
		TextColor(s, SUI.GetColor("property_sheet_tab_active"))
	else
		TextColor(s, SUI.GetColor("property_sheet_tab"))
	end
end

local tab_DoClick = function(s)
	s.parent:SetActiveTab(s)
end

local image_paint = function(s, w, h)
	surface.SetDrawColor(color_white)
	surface.SetMaterial(s.Material)
	surface.DrawTexturedRectRotated(w * 0.5, h * 0.5, w - 10, h - 10, 0)
end

function PANEL:AddSheet(name, load_func)
	local tab = vgui.Create("DButton")
	if TypeID(name) == TYPE_MATERIAL then
		tab:SetText("")
		tab.Material = name
		tab.Paint = image_paint
		tab:SetWide(self.tab_scroller:GetTall())
	else
		tab:SetFont(self:GetFont())
		tab:SetText(name)
		tab:SetTextInset(10, 0)
		tab:SizeToContentsX()

		tab.Paint = tab_Paint
	end

	tab.parent = self
	tab.DoClick = tab_DoClick

	tab.load_func = load_func
	tab.property_sheet = self

	tab.On = TDLib_Classes.On
	TDLib_Classes.CircleClick(tab)

	self.tab_scroller:AddPanel(tab)

	if not self:GetActiveTab() then
		self:SetActiveTab(tab)
	end

	table.insert(self.tabs, tab)

	return tab
end

function PANEL:GetActiveTab()
	return self.active_tab
end

function PANEL:SetActiveTab(new_tab)
	if IsValid(new_tab) and not IsValid(new_tab.panel) then
		local panel = new_tab.load_func(self)
		panel:SetParent(self)
		panel:SetVisible(false)

		panel.tab = new_tab
		new_tab.panel = panel
	end

	if self.active_tab and IsValid(self.active_tab.panel) then
		self.active_tab.panel:SetVisible(false)
	end

	if IsValid(new_tab) then
		new_tab.panel:SetVisible(true)
	end

	self.active_tab = new_tab
end

sui.register("PropertySheet", PANEL, "EditablePanel")
--addons/sui/lua/sui/vgui/sui_query_box.lua:
local ScrW, ScrH = ScrW, ScrH
local DisableClipping = DisableClipping
local SetDrawColor = surface.SetDrawColor
local DrawRect = surface.DrawRect
local BlurPanel = sui.TDLib.BlurPanel
local lerp_color = sui.lerp_color

local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local GetColor = SUI.GetColor

local PANEL = {}

function PANEL:SetCallback(callback)
	self.callback = callback
end

function PANEL:Init()
	self:SetSize(0, 0)

	local bottom = self:Add("Panel")
	bottom:Dock(BOTTOM)
	bottom:DockMargin(4, 10, 4, 4)
	bottom:SetZPos(100)

	local save = bottom:Add(NAME .. ".Button")
	save:SetText("SAVE")
	save:Dock(RIGHT)
	save:SetEnabled(false)
	self.save = save

	function save.DoClick()
		self.callback()
		self:Remove()
	end

	local cancel = bottom:Add(NAME .. ".Button")
	cancel:Dock(RIGHT)
	cancel:DockMargin(0, 0, 4, 0)
	cancel:SetContained(false)
	cancel:SetColors(GetColor("query_box_cancel"), GetColor("query_box_cancel_text"))
	cancel:SetText("CANCEL")
	self.cancel = cancel

	function cancel.DoClick()
		self:Remove()
	end

	bottom:SetSize(save:GetWide() * 2 + 4, SUI.Scale(30))

	local body = self:Add("Panel")
	body:Dock(FILL)
	body:DockMargin(4, 4, 4, 4)
	body:DockPadding(3, 3, 3, 3)
	body:InvalidateLayout(true)
	body:InvalidateParent(true)

	local added = 1
	function body.OnChildAdded(s, child)
		added = added + 1
		child:Dock(TOP)
		child:SetZPos(added)
		child:InvalidateLayout(true)
		s:InvalidateLayout(true)
	end
	self.body = body

	function self:Add(name)
		return body:Add(name)
	end

	local old_Paint = self.Paint
	local trans = Color(0, 0, 0, 0)
	local new_col = Color(70, 70, 70, 100)
	function self:Paint(w, h)
		lerp_color(trans, new_col)

		local x, y = self:LocalToScreen(0, 0)
		DisableClipping(true)
			BlurPanel(self)
			SetDrawColor(trans)
			DrawRect(x * -1, y * -1, ScrW(), ScrH())
		DisableClipping(false)

		old_Paint(self, w, h)
	end
end

function PANEL:ChildrenHeight()
	local body = self.body

	self.header:InvalidateLayout(true)
	local height = self.header:GetTall()

	body:InvalidateLayout(true)
	self:InvalidateLayout(true)
	height = height + select(2, body:ChildrenSize())

	height = height + SUI.Scale(30) + 14 + 6

	return height
end

function PANEL:Paint(w, h)
	if GetColor("frame_blur") then
		BlurPanel(self)
	end

	self:RoundedBox("Background", 8, 0, 0, w, h, GetColor("query_box_bg"))
end

function PANEL:Done()
	self:InvalidateChildren(true)

	self.size_to_children = function()
		local h = self:ChildrenHeight()
		self:RealSetSize(self:GetWide(), h)
		self.real_h = h
	end

	self:Center()
	self:MakePopup()
	self:DoModal(true)

	timer.Simple(0.08, function()
		self:AddAnimations(self:GetWide(), self:ChildrenHeight(), true)
	end)
end

sui.register("QueryBox", PANEL, NAME .. ".Frame")
--addons/sui/lua/sui/vgui/sui_zbutton.lua:
local draw = draw
local render = render

local TDLib = sui.TDLib
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local lerp_color = sui.lerp_color
local contrast_color = sui.contrast_color

local BUTTON_FONT = SUI.CreateFont("Button", "Roboto Medium", 16)

local color_white = color_white
local color_transparent = Color(0, 0, 0, 0)

local PANEL = {}

AccessorFunc(PANEL, "m_Background", "Background")
AccessorFunc(PANEL, "m_bContained", "Contained", FORCE_BOOL)

sui.TDLib.Install(PANEL)
sui.scaling_functions(PANEL)

PANEL:ClearPaint()
PANEL:SetContained(true)

local Panel = FindMetaTable("Panel")
local SetMouseInputEnabled = Panel.SetMouseInputEnabled
local IsMouseInputEnabled = Panel.IsMouseInputEnabled
local SetCursor = Panel.SetCursor
local SetContentAlignment = Panel.SetContentAlignment
function PANEL:Init()
	self:ScaleInit()

	self.vertices, self.vertices_2 = {}, {}

	SetMouseInputEnabled(self, true)
	SetCursor(self, "hand")
	SetContentAlignment(self, 5)

	self:SetSize(90, 30)
	self:SetFont(BUTTON_FONT)

	self:CircleClick(nil, 7)

	self.OldPaint, self.Paint = self.Paint, self.Paint2

	self.cur_col = Color(0, 0, 0, 0)
end

function PANEL:SetEnabled(b)
	SetMouseInputEnabled(self, b)
end

function PANEL:IsEnabled()
	return IsMouseInputEnabled(self)
end

function PANEL:ContainedPaint(w, h)
	local enabled = self:IsEnabled()
	local col
	if enabled then
		col = self:GetBackground() or SUI.GetColor("button")
		self:SetTextColor(SUI.GetColor("button_text"))
	else
		col = SUI.GetColor("button_disabled")
		self:SetTextColor(SUI.GetColor("button_disabled_text"))
	end
	self:RoundedBox("Background", 4, 0, 0, w, h, col)

	if not enabled then return end

	self.circle_click_color = SUI.GetColor("button_click")

	if self.Hovered or self.Selected then
		self:RoundedBox("Hover", 4, 0, 0, w, h, SUI.GetColor("button_hover"))
	end
end

function PANEL:SetColors(hover_color, text_color)
	self.hover = hover_color
	self.text_color = text_color
end

function PANEL:Paint2(w, h)
	if self:GetContained() then
		self:ContainedPaint(w, h)
		self:OldPaint(w, h)
		return
	end

	render.ClearStencil()
	render.SetStencilEnable(true)

	render.SetStencilWriteMask(1)
	render.SetStencilTestMask(1)

	render.SetStencilFailOperation(STENCILOPERATION_REPLACE)
	render.SetStencilPassOperation(STENCILOPERATION_ZERO)
	render.SetStencilZFailOperation(STENCILOPERATION_ZERO)
	render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_NEVER)
	render.SetStencilReferenceValue(1)

	TDLib.RoundedBox(self.vertices, 4, 0, 0, w, h, color_white)

	render.SetStencilFailOperation(STENCILOPERATION_ZERO)
	render.SetStencilPassOperation(STENCILOPERATION_REPLACE)
	render.SetStencilZFailOperation(STENCILOPERATION_ZERO)
	render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_EQUAL)
	render.SetStencilReferenceValue(1)

	local cur_col = self.cur_col
	if self.Selected then
		lerp_color(cur_col, SUI.GetColor("button2_selected"))
	elseif self.Hovered then
		lerp_color(cur_col, self.hover or SUI.GetColor("button2_hover"))
	else
		lerp_color(cur_col, color_transparent)
	end

	TDLib.RoundedBox(self.vertices_2, 4, 0, 0, w, h, cur_col)

	if self.text_color then
		self.circle_click_color = self.text_color
		self:SetTextColor(self.text_color)
	else
		local col = contrast_color(cur_col)
		self.circle_click_color = col
		self:SetTextColor(col)
	end

	self:OldPaint(w, h)

	render.SetStencilEnable(false)
	render.ClearStencil()
end

sui.register("Button", PANEL, NAME .. ".Label")
--addons/scb_chatbox/lua/scb/libs/message_pack/sh_messagepack.lua:
if SCB_LOADED then return end

--
-- lua-MessagePack : <https://fperrad.frama.io/lua-MessagePack/>
--

local SIZEOF_NUMBER = string.pack and #string.pack('n', 0.0) or 8
local maxinteger
local mininteger

local assert = assert
local error = error
local pairs = pairs
local pcall = pcall
local setmetatable = setmetatable
local tostring = tostring
local char = string.char
local format = string.format
local floor = math.floor
local tointeger = floor
local frexp = math.frexp
local ldexp = math.ldexp
local huge = math.huge
local tconcat = table.concat

local type = scb.type
local isnumber = scb.isnumber
local _ENV = nil
local m = {}

--[[ debug only
local function hexadump (s)
	return (s:gsub('.', function (c) return format('%02X ', c:byte()) end))
end
m.hexadump = hexadump
--]]

local function argerror (caller, narg, extramsg)
	error("bad argument #" .. tostring(narg) .. " to "
		  .. caller .. " (" .. extramsg .. ")")
end

local function typeerror (caller, narg, arg, tname)
	argerror(caller, narg, tname .. " expected, got " .. type(arg))
end

local function checktype (caller, narg, arg, tname)
	if type(arg) ~= tname then
		typeerror(caller, narg, arg, tname)
	end
end

local packers = setmetatable({}, {
	__index = function (t, k)
		if k == 1 then return end   -- allows ipairs
		error("pack '" .. k .. "' is unimplemented")
	end
})
m.packers = packers

packers['nil'] = function (buffer)
	buffer[#buffer+1] = char(0xC0)	-- nil
end

packers['boolean'] = function (buffer, bool)
	if bool then
		buffer[#buffer+1] = char(0xC3)	-- true
	else
		buffer[#buffer+1] = char(0xC2)	-- false
	end
end

packers['string_compat'] = function (buffer, str)
	local n = #str
	if n <= 0x1F then
		buffer[#buffer+1] = char(0xA0 + n)	-- fixstr
	elseif n <= 0xFFFF then
		buffer[#buffer+1] = char(0xDA,		-- str16
								 floor(n / 0x100),
								 n % 0x100)
	elseif n <= 4294967295.0 then
		buffer[#buffer+1] = char(0xDB,		-- str32
								 floor(n / 0x1000000),
								 floor(n / 0x10000) % 0x100,
								 floor(n / 0x100) % 0x100,
								 n % 0x100)
	else
		error"overflow in pack 'string_compat'"
	end
	buffer[#buffer+1] = str
end

packers['_string'] = function (buffer, str)
	local n = #str
	if n <= 0x1F then
		buffer[#buffer+1] = char(0xA0 + n)		-- fixstr
	elseif n <= 0xFF then
		buffer[#buffer+1] = char(0xD9,			-- str8
								 n)
	elseif n <= 0xFFFF then
		buffer[#buffer+1] = char(0xDA,			-- str16
								 floor(n / 0x100),
								 n % 0x100)
	elseif n <= 4294967295.0 then
		buffer[#buffer+1] = char(0xDB,			-- str32
								 floor(n / 0x1000000),
								 floor(n / 0x10000) % 0x100,
								 floor(n / 0x100) % 0x100,
								 n % 0x100)
	else
		error"overflow in pack 'string'"
	end
	buffer[#buffer+1] = str
end

packers['binary'] = function (buffer, str)
	local n = #str
	if n <= 0xFF then
		buffer[#buffer+1] = char(0xC4,		-- bin8
								 n)
	elseif n <= 0xFFFF then
		buffer[#buffer+1] = char(0xC5,		-- bin16
								 floor(n / 0x100),
								 n % 0x100)
	elseif n <= 4294967295.0 then
		buffer[#buffer+1] = char(0xC6,		-- bin32
								 floor(n / 0x1000000),
								 floor(n / 0x10000) % 0x100,
								 floor(n / 0x100) % 0x100,
								 n % 0x100)
	else
		error"overflow in pack 'binary'"
	end
	buffer[#buffer+1] = str
end

local set_string = function (str)
	if str == 'string_compat' then
		packers['string'] = packers['string_compat']
	elseif str == 'string' then
		packers['string'] = packers['_string']
	elseif str == 'binary' then
		packers['string'] = packers['binary']
	else
		argerror('set_string', 1, "invalid option '" .. str .."'")
	end
end
m.set_string = set_string

packers['map'] = function (buffer, tbl, n)
	if n <= 0x0F then
		buffer[#buffer+1] = char(0x80 + n)		-- fixmap
	elseif n <= 0xFFFF then
		buffer[#buffer+1] = char(0xDE,			-- map16
								 floor(n / 0x100),
								 n % 0x100)
	elseif n <= 4294967295.0 then
		buffer[#buffer+1] = char(0xDF,			-- map32
								 floor(n / 0x1000000),
								 floor(n / 0x10000) % 0x100,
								 floor(n / 0x100) % 0x100,
								 n % 0x100)
	else
		error"overflow in pack 'map'"
	end
	for k, v in pairs(tbl) do
		packers[type(k)](buffer, k)
		packers[type(v)](buffer, v)
	end
end

packers['array'] = function (buffer, tbl, n)
	if n <= 0x0F then
		buffer[#buffer+1] = char(0x90 + n)		-- fixarray
	elseif n <= 0xFFFF then
		buffer[#buffer+1] = char(0xDC,			-- array16
								 floor(n / 0x100),
								 n % 0x100)
	elseif n <= 4294967295.0 then
		buffer[#buffer+1] = char(0xDD,			-- array32
								 floor(n / 0x1000000),
								 floor(n / 0x10000) % 0x100,
								 floor(n / 0x100) % 0x100,
								 n % 0x100)
	else
		error"overflow in pack 'array'"
	end
	for i = 1, n do
		local v = tbl[i]
		packers[type(v)](buffer, v)
	end
end

local set_array = function (array)
	if array == 'without_hole' then
		packers['_table'] = function (buffer, tbl)
			local is_map, n, max = false, 0, 0
			for k in pairs(tbl) do
				if isnumber(k) and k > 0 then
					if k > max then
						max = k
					end
				else
					is_map = true
				end
				n = n + 1
			end
			if max ~= n then	-- there are holes
				is_map = true
			end
			if is_map then
				packers['map'](buffer, tbl, n)
			else
				packers['array'](buffer, tbl, n)
			end
		end
	elseif array == 'with_hole' then
		packers['_table'] = function (buffer, tbl)
			local is_map, n, max = false, 0, 0
			for k in pairs(tbl) do
				if isnumber(k) and k > 0 then
					if k > max then
						max = k
					end
				else
					is_map = true
				end
				n = n + 1
			end
			if is_map then
				packers['map'](buffer, tbl, n)
			else
				packers['array'](buffer, tbl, max)
			end
		end
	elseif array == 'always_as_map' then
		packers['_table'] = function(buffer, tbl)
			local n = 0
			for k in pairs(tbl) do
				n = n + 1
			end
			packers['map'](buffer, tbl, n)
		end
	else
		argerror('set_array', 1, "invalid option '" .. array .."'")
	end
end
m.set_array = set_array

packers['table'] = function (buffer, tbl)
	packers['_table'](buffer, tbl)
end

packers['unsigned'] = function (buffer, n)
	if n >= 0 then
		if n <= 0x7F then
			buffer[#buffer+1] = char(n)			-- fixnum_pos
		elseif n <= 0xFF then
			buffer[#buffer+1] = char(0xCC,		-- uint8
									 n)
		elseif n <= 0xFFFF then
			buffer[#buffer+1] = char(0xCD,		-- uint16
									 floor(n / 0x100),
									 n % 0x100)
		elseif n <= 4294967295.0 then
			buffer[#buffer+1] = char(0xCE,		-- uint32
									 floor(n / 0x1000000),
									 floor(n / 0x10000) % 0x100,
									 floor(n / 0x100) % 0x100,
									 n % 0x100)
		else
			buffer[#buffer+1] = char(0xCF,		-- uint64
									 0,			-- only 53 bits from double
									 floor(n / 0x1000000000000) % 0x100,
									 floor(n / 0x10000000000) % 0x100,
									 floor(n / 0x100000000) % 0x100,
									 floor(n / 0x1000000) % 0x100,
									 floor(n / 0x10000) % 0x100,
									 floor(n / 0x100) % 0x100,
									 n % 0x100)
		end
	else
		if n >= -0x20 then
			buffer[#buffer+1] = char(0x100 + n) -- fixnum_neg
		elseif n >= -0x80 then
			buffer[#buffer+1] = char(0xD0,		-- int8
									 0x100 + n)
		elseif n >= -0x8000 then
			n = 0x10000 + n
			buffer[#buffer+1] = char(0xD1,		-- int16
									 floor(n / 0x100),
									 n % 0x100)
		elseif n >= -0x80000000 then
			n = 4294967296.0 + n
			buffer[#buffer+1] = char(0xD2,		-- int32
									 floor(n / 0x1000000),
									 floor(n / 0x10000) % 0x100,
									 floor(n / 0x100) % 0x100,
									 n % 0x100)
		else
			buffer[#buffer+1] = char(0xD3,		-- int64
									 0xFF,		-- only 53 bits from double
									 floor(n / 0x1000000000000) % 0x100,
									 floor(n / 0x10000000000) % 0x100,
									 floor(n / 0x100000000) % 0x100,
									 floor(n / 0x1000000) % 0x100,
									 floor(n / 0x10000) % 0x100,
									 floor(n / 0x100) % 0x100,
									 n % 0x100)
		end
	end
end

packers['signed'] = function (buffer, n)
	if n >= 0 then
		if n <= 0x7F then
			buffer[#buffer+1] = char(n)			-- fixnum_pos
		elseif n <= 0x7FFF then
			buffer[#buffer+1] = char(0xD1,		-- int16
									 floor(n / 0x100),
									 n % 0x100)
		elseif n <= 0x7FFFFFFF then
			buffer[#buffer+1] = char(0xD2,		-- int32
									 floor(n / 0x1000000),
									 floor(n / 0x10000) % 0x100,
									 floor(n / 0x100) % 0x100,
									 n % 0x100)
		else
			buffer[#buffer+1] = char(0xD3,		-- int64
									 0,			-- only 53 bits from double
									 floor(n / 0x1000000000000) % 0x100,
									 floor(n / 0x10000000000) % 0x100,
									 floor(n / 0x100000000) % 0x100,
									 floor(n / 0x1000000) % 0x100,
									 floor(n / 0x10000) % 0x100,
									 floor(n / 0x100) % 0x100,
									 n % 0x100)
		end
	else
		if n >= -0x20 then
			buffer[#buffer+1] = char(0xE0 + 0x20 + n)   -- fixnum_neg
		elseif n >= -0x80 then
			buffer[#buffer+1] = char(0xD0,		-- int8
									 0x100 + n)
		elseif n >= -0x8000 then
			n = 0x10000 + n
			buffer[#buffer+1] = char(0xD1,		-- int16
									 floor(n / 0x100),
									 n % 0x100)
		elseif n >= -0x80000000 then
			n = 4294967296.0 + n
			buffer[#buffer+1] = char(0xD2,		-- int32
									 floor(n / 0x1000000),
									 floor(n / 0x10000) % 0x100,
									 floor(n / 0x100) % 0x100,
									 n % 0x100)
		else
			buffer[#buffer+1] = char(0xD3,		-- int64
									 0xFF,		-- only 53 bits from double
									 floor(n / 0x1000000000000) % 0x100,
									 floor(n / 0x10000000000) % 0x100,
									 floor(n / 0x100000000) % 0x100,
									 floor(n / 0x1000000) % 0x100,
									 floor(n / 0x10000) % 0x100,
									 floor(n / 0x100) % 0x100,
									 n % 0x100)
		end
	end
end

local set_integer = function (integer)
	if integer == 'unsigned' then
		packers['integer'] = packers['unsigned']
	elseif integer == 'signed' then
		packers['integer'] = packers['signed']
	else
		argerror('set_integer', 1, "invalid option '" .. integer .."'")
	end
end
m.set_integer = set_integer

packers['float'] = function (buffer, n)
	local sign = 0
	if n < 0.0 then
		sign = 0x80
		n = -n
	end
	local mant, expo = frexp(n)
	if mant ~= mant then
		buffer[#buffer+1] = char(0xCA,  -- nan
								 0xFF, 0x88, 0x00, 0x00)
	elseif mant == huge or expo > 0x80 then
		if sign == 0 then
			buffer[#buffer+1] = char(0xCA,	  -- inf
									 0x7F, 0x80, 0x00, 0x00)
		else
			buffer[#buffer+1] = char(0xCA,	  -- -inf
									 0xFF, 0x80, 0x00, 0x00)
		end
	elseif (mant == 0.0 and expo == 0) or expo < -0x7E then
		buffer[#buffer+1] = char(0xCA,  -- zero
								 sign, 0x00, 0x00, 0x00)
	else
		expo = expo + 0x7E
		mant = floor((mant * 2.0 - 1.0) * ldexp(0.5, 24))
		buffer[#buffer+1] = char(0xCA,
								 sign + floor(expo / 0x2),
								 (expo % 0x2) * 0x80 + floor(mant / 0x10000),
								 floor(mant / 0x100) % 0x100,
								 mant % 0x100)
	end
end

packers['double'] = function (buffer, n)
	local sign = 0
	if n < 0.0 then
		sign = 0x80
		n = -n
	end
	local mant, expo = frexp(n)
	if mant ~= mant then
		buffer[#buffer+1] = char(0xCB,  -- nan
								 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)
	elseif mant == huge or expo > 0x400 then
		if sign == 0 then
			buffer[#buffer+1] = char(0xCB,	  -- inf
									 0x7F, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)
		else
			buffer[#buffer+1] = char(0xCB,	  -- -inf
									 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)
		end
	elseif (mant == 0.0 and expo == 0) or expo < -0x3FE then
		buffer[#buffer+1] = char(0xCB,  -- zero
								 sign, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)
	else
		expo = expo + 0x3FE
		mant = floor((mant * 2.0 - 1.0) * ldexp(0.5, 53))
		buffer[#buffer+1] = char(0xCB,
								 sign + floor(expo / 0x10),
								 (expo % 0x10) * 0x10 + floor(mant / 0x1000000000000),
								 floor(mant / 0x10000000000) % 0x100,
								 floor(mant / 0x100000000) % 0x100,
								 floor(mant / 0x1000000) % 0x100,
								 floor(mant / 0x10000) % 0x100,
								 floor(mant / 0x100) % 0x100,
								 mant % 0x100)
	end
end

local set_number = function (number)
	if number == 'float' then
		packers['number'] = function (buffer, n)
			if floor(n) == n and n < maxinteger and n > mininteger then
				packers['integer'](buffer, n)
			else
				packers['float'](buffer, n)
			end
		end
	elseif number == 'double' then
		packers['number'] = function (buffer, n)
			if floor(n) == n and n < maxinteger and n > mininteger then
				packers['integer'](buffer, n)
			else
				packers['double'](buffer, n)
			end
		end
	else
		argerror('set_number', 1, "invalid option '" .. number .."'")
	end
end
m.set_number = set_number

for k = 0, 4 do
	local n = tointeger(2^k)
	local fixext = 0xD4 + k
	packers['fixext' .. tostring(n)] = function (buffer, tag, data)
		assert(#data == n, "bad length for fixext" .. tostring(n))
		buffer[#buffer+1] = char(fixext,
								 tag < 0 and tag + 0x100 or tag)
		buffer[#buffer+1] = data
	end
end

packers['ext'] = function (buffer, tag, data)
	local n = #data
	if n <= 0xFF then
		buffer[#buffer+1] = char(0xC7,		  -- ext8
								 n,
								 tag < 0 and tag + 0x100 or tag)
	elseif n <= 0xFFFF then
		buffer[#buffer+1] = char(0xC8,		  -- ext16
								 floor(n / 0x100),
								 n % 0x100,
								 tag < 0 and tag + 0x100 or tag)
	elseif n <= 4294967295.0 then
		buffer[#buffer+1] = char(0xC9,		  -- ext&32
								 floor(n / 0x1000000),
								 floor(n / 0x10000) % 0x100,
								 floor(n / 0x100) % 0x100,
								 n % 0x100,
								 tag < 0 and tag + 0x100 or tag)
	else
		error"overflow in pack 'ext'"
	end
	buffer[#buffer+1] = data
end

function m.pack (data)
	local buffer = {}
	packers[type(data)](buffer, data)
	return tconcat(buffer)
end


local unpackers		 -- forward declaration

local function unpack_cursor (c)
	local s, i, j = c.s, c.i, c.j
	if i > j then
		c:underflow(i)
		s, i, j = c.s, c.i, c.j
	end
	local val = s:byte(i)
	c.i = i+1
	return unpackers[val](c, val)
end
m.unpack_cursor = unpack_cursor

local function unpack_str (c, n)
	local s, i, j = c.s, c.i, c.j
	local e = i+n-1
	if e > j or n < 0 then
		c:underflow(e)
		s, i, j = c.s, c.i, c.j
		e = i+n-1
	end
	c.i = i+n
	return s:sub(i, e)
end

local function unpack_array (c, n)
	local t = {}
	for i = 1, n do
		t[i] = unpack_cursor(c)
	end
	return t
end

local function unpack_map (c, n)
	local t = {}
	for i = 1, n do
		local k = unpack_cursor(c)
		local val = unpack_cursor(c)
		if k == nil or k ~= k then
			k = m.sentinel
		end
		if k ~= nil then
			t[k] = val
		end
	end
	return t
end

local function unpack_float (c)
	local s, i, j = c.s, c.i, c.j
	if i+3 > j then
		c:underflow(i+3)
		s, i, j = c.s, c.i, c.j
	end
	local b1, b2, b3, b4 = s:byte(i, i+3)
	local sign = b1 > 0x7F
	local expo = (b1 % 0x80) * 0x2 + floor(b2 / 0x80)
	local mant = ((b2 % 0x80) * 0x100 + b3) * 0x100 + b4
	if sign then
		sign = -1
	else
		sign = 1
	end
	local n
	if mant == 0 and expo == 0 then
		n = sign * 0.0
	elseif expo == 0xFF then
		if mant == 0 then
			n = sign * huge
		else
			n = 0.0/0.0
		end
	else
		n = sign * ldexp(1.0 + mant / 0x800000, expo - 0x7F)
	end
	c.i = i+4
	return n
end

local function unpack_double (c)
	local s, i, j = c.s, c.i, c.j
	if i+7 > j then
		c:underflow(i+7)
		s, i, j = c.s, c.i, c.j
	end
	local b1, b2, b3, b4, b5, b6, b7, b8 = s:byte(i, i+7)
	local sign = b1 > 0x7F
	local expo = (b1 % 0x80) * 0x10 + floor(b2 / 0x10)
	local mant = ((((((b2 % 0x10) * 0x100 + b3) * 0x100 + b4) * 0x100 + b5) * 0x100 + b6) * 0x100 + b7) * 0x100 + b8
	if sign then
		sign = -1
	else
		sign = 1
	end
	local n
	if mant == 0 and expo == 0 then
		n = sign * 0.0
	elseif expo == 0x7FF then
		if mant == 0 then
			n = sign * huge
		else
			n = 0.0/0.0
		end
	else
		n = sign * ldexp(1.0 + mant / 4503599627370496.0, expo - 0x3FF)
	end
	c.i = i+8
	return n
end

local function unpack_uint8 (c)
	local s, i, j = c.s, c.i, c.j
	if i > j then
		c:underflow(i)
		s, i, j = c.s, c.i, c.j
	end
	local b1 = s:byte(i)
	c.i = i+1
	return b1
end

local function unpack_uint16 (c)
	local s, i, j = c.s, c.i, c.j
	if i+1 > j then
		c:underflow(i+1)
		s, i, j = c.s, c.i, c.j
	end
	local b1, b2 = s:byte(i, i+1)
	c.i = i+2
	return b1 * 0x100 + b2
end

local function unpack_uint32 (c)
	local s, i, j = c.s, c.i, c.j
	if i+3 > j then
		c:underflow(i+3)
		s, i, j = c.s, c.i, c.j
	end
	local b1, b2, b3, b4 = s:byte(i, i+3)
	c.i = i+4
	return ((b1 * 0x100 + b2) * 0x100 + b3) * 0x100 + b4
end

local function unpack_uint64 (c)
	local s, i, j = c.s, c.i, c.j
	if i+7 > j then
		c:underflow(i+7)
		s, i, j = c.s, c.i, c.j
	end
	local b1, b2, b3, b4, b5, b6, b7, b8 = s:byte(i, i+7)
	c.i = i+8
	return ((((((b1 * 0x100 + b2) * 0x100 + b3) * 0x100 + b4) * 0x100 + b5) * 0x100 + b6) * 0x100 + b7) * 0x100 + b8
end

local function unpack_int8 (c)
	local s, i, j = c.s, c.i, c.j
	if i > j then
		c:underflow(i)
		s, i, j = c.s, c.i, c.j
	end
	local b1 = s:byte(i)
	c.i = i+1
	if b1 < 0x80 then
		return b1
	else
		return b1 - 0x100
	end
end

local function unpack_int16 (c)
	local s, i, j = c.s, c.i, c.j
	if i+1 > j then
		c:underflow(i+1)
		s, i, j = c.s, c.i, c.j
	end
	local b1, b2 = s:byte(i, i+1)
	c.i = i+2
	if b1 < 0x80 then
		return b1 * 0x100 + b2
	else
		return ((b1 - 0xFF) * 0x100 + (b2 - 0xFF)) - 1
	end
end

local function unpack_int32 (c)
	local s, i, j = c.s, c.i, c.j
	if i+3 > j then
		c:underflow(i+3)
		s, i, j = c.s, c.i, c.j
	end
	local b1, b2, b3, b4 = s:byte(i, i+3)
	c.i = i+4
	if b1 < 0x80 then
		return ((b1 * 0x100 + b2) * 0x100 + b3) * 0x100 + b4
	else
		return ((((b1 - 0xFF) * 0x100 + (b2 - 0xFF)) * 0x100 + (b3 - 0xFF)) * 0x100 + (b4 - 0xFF)) - 1
	end
end

local function unpack_int64 (c)
	local s, i, j = c.s, c.i, c.j
	if i+7 > j then
		c:underflow(i+7)
		s, i, j = c.s, c.i, c.j
	end
	local b1, b2, b3, b4, b5, b6, b7, b8 = s:byte(i, i+7)
	c.i = i+8
	if b1 < 0x80 then
		return ((((((b1 * 0x100 + b2) * 0x100 + b3) * 0x100 + b4) * 0x100 + b5) * 0x100 + b6) * 0x100 + b7) * 0x100 + b8
	else
		return ((((((((b1 - 0xFF) * 0x100 + (b2 - 0xFF)) * 0x100 + (b3 - 0xFF)) * 0x100 + (b4 - 0xFF)) * 0x100 + (b5 - 0xFF)) * 0x100 + (b6 - 0xFF)) * 0x100 + (b7 - 0xFF)) * 0x100 + (b8 - 0xFF)) - 1
	end
end

function m.build_ext (tag, data)
	return nil
end

local function unpack_ext (c, n, tag)
	local s, i, j = c.s, c.i, c.j
	local e = i+n-1
	if e > j or n < 0 then
		c:underflow(e)
		s, i, j = c.s, c.i, c.j
		e = i+n-1
	end
	c.i = i+n
	return m.build_ext(tag, s:sub(i, e))
end

local fn_1 = function(c, val)
	return val
end

local fn_2 = function(c, val)
	return unpack_map(c, val % 0x10)
end

local fn_3 = function(c, val)
	return unpack_array(c, val % 0x10)
end

local fn_4 = function(c, val)
	return unpack_str(c, val % 0x20)
end

local fn_5 = function(c, val)
	return val - 0x100
end

unpackers = setmetatable({
	[0xC0] = function () return nil end,
	[0xC2] = function () return false end,
	[0xC3] = function () return true end,
	[0xC4] = function (c) return unpack_str(c, unpack_uint8(c)) end,	-- bin8
	[0xC5] = function (c) return unpack_str(c, unpack_uint16(c)) end,   -- bin16
	[0xC6] = function (c) return unpack_str(c, unpack_uint32(c)) end,   -- bin32
	[0xC7] = function (c) return unpack_ext(c, unpack_uint8(c), unpack_int8(c)) end,
	[0xC8] = function (c) return unpack_ext(c, unpack_uint16(c), unpack_int8(c)) end,
	[0xC9] = function (c) return unpack_ext(c, unpack_uint32(c), unpack_int8(c)) end,
	[0xCA] = unpack_float,
	[0xCB] = unpack_double,
	[0xCC] = unpack_uint8,
	[0xCD] = unpack_uint16,
	[0xCE] = unpack_uint32,
	[0xCF] = unpack_uint64,
	[0xD0] = unpack_int8,
	[0xD1] = unpack_int16,
	[0xD2] = unpack_int32,
	[0xD3] = unpack_int64,
	[0xD4] = function (c) return unpack_ext(c, 1, unpack_int8(c)) end,
	[0xD5] = function (c) return unpack_ext(c, 2, unpack_int8(c)) end,
	[0xD6] = function (c) return unpack_ext(c, 4, unpack_int8(c)) end,
	[0xD7] = function (c) return unpack_ext(c, 8, unpack_int8(c)) end,
	[0xD8] = function (c) return unpack_ext(c, 16, unpack_int8(c)) end,
	[0xD9] = function (c) return unpack_str(c, unpack_uint8(c)) end,
	[0xDA] = function (c) return unpack_str(c, unpack_uint16(c)) end,
	[0xDB] = function (c) return unpack_str(c, unpack_uint32(c)) end,
	[0xDC] = function (c) return unpack_array(c, unpack_uint16(c)) end,
	[0xDD] = function (c) return unpack_array(c, unpack_uint32(c)) end,
	[0xDE] = function (c) return unpack_map(c, unpack_uint16(c)) end,
	[0xDF] = function (c) return unpack_map(c, unpack_uint32(c)) end,
}, {
	__index = function (t, k)
		if k < 0xC0 then
			if k < 0x80 then
				return fn_1
			elseif k < 0x90 then
				return fn_2
			elseif k < 0xA0 then
				return fn_3
			else
				return fn_4
			end
		elseif k > 0xDF then
			return fn_5
		else
			return function () error("unpack '" .. format('%#x', k) .. "' is unimplemented") end
		end
	end
})

local function cursor_string (str)
	return {
		s = str,
		i = 1,
		j = #str,
		underflow = function ()
						error "missing bytes"
					end,
	}
end

local function cursor_loader (ld)
	return {
		s = '',
		i = 1,
		j = 0,
		underflow = function (self, e)
						self.s = self.s:sub(self.i)
						e = e - self.i + 1
						self.i = 1
						self.j = 0
						while e > self.j do
							local chunk = ld()
							if not chunk then
								error "missing bytes"
							end
							self.s = self.s .. chunk
							self.j = #self.s
						end
					end,
	}
end

function m.unpack (s)
	checktype('unpack', 1, s, 'string')
	local cursor = cursor_string(s)
	local data = unpack_cursor(cursor)
	if cursor.i <= cursor.j then
		error "extra bytes"
	end
	return data
end

function m.unpacker (src)
	if type(src) == 'string' then
		local cursor = cursor_string(src)
		return function ()
			if cursor.i <= cursor.j then
				return cursor.i, unpack_cursor(cursor)
			end
		end
	elseif type(src) == 'function' then
		local cursor = cursor_loader(src)
		return function ()
			if cursor.i > cursor.j then
				pcall(cursor.underflow, cursor, cursor.i)
			end
			if cursor.i <= cursor.j then
				return true, unpack_cursor(cursor)
			end
		end
	else
		argerror('unpacker', 1, "string or function expected, got " .. type(src))
	end
end

set_string'string_compat'
set_integer'unsigned'
if SIZEOF_NUMBER == 4 then
	maxinteger = 16777215
	mininteger = -maxinteger
	m.small_lua = true
	unpackers[0xCB] = nil	   -- double
	unpackers[0xCF] = nil	   -- uint64
	unpackers[0xD3] = nil	   -- int64
	set_number'float'
else
	maxinteger = 9007199254740991
	mininteger = -maxinteger
	set_number'double'
	if SIZEOF_NUMBER > 8 then
		m.long_double = true
	end
end
set_array'without_hole'

m._VERSION = '0.5.2'
m._DESCRIPTION = "lua-MessagePack : a pure Lua implementation"
m._COPYRIGHT = "Copyright (c) 2012-2019 Francois Perrad"

return m

--
-- This library is licensed under the terms of the MIT/X11 license,
-- like Lua itself.
--

--addons/scb_chatbox/lua/scb/settings/cl_settings.lua:
if SCB_LOADED then return end

local vgui = vgui

local IsValid = IsValid
local pairs = pairs
local LocalPlayer = LocalPlayer

local scb = scb

local tabs = {}
for _, f in ipairs(file.Find("scb/settings/tabs/*.lua", "LUA")) do
	local data = include("scb/settings/tabs/" .. f)
	tabs[data.pos or #tabs + 1] = data
end

function scb.open_settings()
	if IsValid(scb.settings_frame) then
		return scb.settings_frame:Remove()
	end

	local frame = vgui.Create("SCB.Frame")
	frame:SetTitle("SCB | " .. scb.language.settings_title)
	frame:MakePopup()
	frame:AddAnimations(382, 420)

	local sheet = frame:Add("SCB.PropertySheet")
	sheet:Dock(FILL)
	sheet:DockMargin(4, 4, 4, 4)
	sheet:InvalidateParent(true)
	sheet:InvalidateLayout(true)

	for k, v in pairs(tabs) do
		if v.check == false or scb.has_permission(LocalPlayer(), "menu") then
			sheet:AddSheet(v.title, v.func)
		end
	end

	scb.settings_frame = frame
end
--addons/scb_chatbox/lua/scb/vgui/scb_emojis.lua:
if SCB_LOADED then return end

local draw = draw
local IsValid = IsValid
local math = math
local pairs = pairs
local table = table
local SortedPairsByMemberValue = SortedPairsByMemberValue
local timer = timer

local scb = scb
local sui = sui
local SUI = scb.SUI
local language = scb.language

local Panel = {}

local flag = "flag_" .. (system.GetCountry() or ""):lower()
local categories = {
	People = {1, "grinning"},
	Nature = {2, "cat"},
	Food = {3, "watermelon"},
	Activities = {4, "person_in_lotus_position"},
	Travel = {5, "desert_island"},
	Objects = {6, "coffee"},
	Symbols = {7, "question"},
	Flags = {8, scb.emojis[flag] and flag or "flag_eg"},
	Custom = {9, "unlock"}
}

local generate_emojis = function()
	for k, v in pairs(categories) do
		local key = tostring(v[1])
		local emojis = {}

		local i, max_pos = 1, -math.huge
		for name, cat in pairs(scb.emojis) do
			local pos = i
			if not scb.is_custom_emoji(cat) then
				cat, pos = cat:sub(1, 1), tonumber(cat:sub(2))
			end

			if cat ~= key and (k ~= "Custom" or not scb.is_custom_emoji(cat)) then continue end

			emojis[pos] = name
			max_pos = math.max(max_pos, pos)

			i = i + 1
		end

		v[3] = emojis
		v[4] = max_pos
	end
end
generate_emojis()
hook.Add("SCB.EmojisModified", "FixEmojis", generate_emojis)

local DoClick = function(s)
	local text_entry = scb.chatbox.text_entry
	text_entry:RequestFocus()
	text_entry:AddValue(":" .. s.name .. ": ")

	s.parent:Remove()
end

local hovered_color = Color(50, 50, 50, 150)
local emoji_Paint = function(s, w, h)
	if s.parent.selected == s then
		s.search_field:SetPlaceholder(":" .. s.name .. ":")
		draw.RoundedBox(0, 0, 0, w, h, hovered_color)
	end
end

local emoji_OnCursorEntered = function(s, w, h)
	s.parent.selected = s
end

local category_list_Paint = function(_, w, h)
	draw.RoundedBox(3, 0, 0, w, h, SUI.GetColor("scroll_panel"))
end

local make_category_list = function(parent, columns)
	local category_list = parent:Add("SCB.ThreeGrid")
	category_list:Dock(FILL)
	category_list:DockMargin(2, 0, 2, 2)
	category_list:GetCanvas():DockPadding(2, 2, 2, 2)
	category_list:InvalidateParent(true)
	category_list:SetWide2(category_list:GetWide() - (SUI.Scale(4) * 2))
	category_list:InvalidateParent(true)

	category_list:SetColumns(columns)
	category_list:SetHorizontalMargin(4)

	category_list.Paint = category_list_Paint

	return category_list
end

local add_emoji = function(self, emoji, category_list, search_field)
	if not IsValid(category_list) then return end

	local emoji_size = SUI.ScaleEven(28)

	local pnl = vgui.Create("DButton")
	pnl:SetTall(emoji_size)
	category_list:AddCell(pnl)

	pnl:SetSize(emoji_size, emoji_size)
	pnl:SetText("")
	pnl:SetTooltip(emoji)

	pnl.parent = self
	pnl.name = emoji
	pnl.search_field = search_field
	pnl.Paint = emoji_Paint
	pnl.OnCursorEntered = emoji_OnCursorEntered
	pnl.DoClick = DoClick

	local img = pnl:Add("SCB.Image")
	img:Dock(FILL)
	img:DockMargin(3, 3, 3, 3)
	img:SetMouseInputEnabled(false)

	local info = scb.emojis[emoji]
	img:SetImage(scb.is_custom_emoji(info) and info or ("scb/emojis/" .. emoji .. ".png"))
end

function Panel:Init()
	local has_permission = scb.has_permission(LocalPlayer(), "custom_emojis")
	local categories_n = table.Count(categories) - (has_permission and 0 or 1)

	self.tabs_tall = 30
	self.tab_scroller:SetTall(SUI.Scale(self.tabs_tall))

	self:SetFont(SCB_14)

	self.w = self.tab_scroller:GetTall() * categories_n
	self.h = self.w + 10

	self:InvalidateLayout(true)

	self.tab_scroller:Dock(BOTTOM)

	local emoji_size = SUI.ScaleEven(28)
	local columns = math.floor(self.w / emoji_size) - 1

	local search_field = self:Add("SCB.TextEntry")
	search_field:Dock(TOP)
	search_field:DockMargin(2, 2, 2, 2)
	search_field:SetPlaceholder(language.search)
	search_field:SetMouseInputEnabled(true)
	search_field:SetNoBar(true)

	local old_Paint = search_field.Paint
	function search_field:Paint(w, h)
		local outline = SUI.GetColor("scroll_panel_outline")
		if outline then
			sui.TDLib.DrawOutlinedBox(3, 0, 0, w, h, SUI.GetColor("scroll_panel"), outline, 1)
		else
			draw.RoundedBox(3, 0, 0, w, h, SUI.GetColor("scroll_panel"))
		end

		old_Paint(self, w, h)
	end

	function search_field.OnValueChange(s, value)
		if value == "" then
			if IsValid(s.search_body) then
				s.search_body:Remove()
			end
			self:SetActiveTab(self.tabs[1])
			search_field:SetPlaceholder(language.search)
			return
		end

		value = value:gsub(":", ""):lower()

		local search_body = s.search_body
		if not IsValid(search_body) then
			self:SetActiveTab(nil)

			search_body = self:Add("Panel")
			s.search_body = search_body
		end

		search_body:Dock(FILL)
		search_body:InvalidateParent(true)
		search_body:Clear()

		local category_list = make_category_list(search_body, columns)

		local main_i = 0
		for k, v in SortedPairsByMemberValue(categories, 1) do
			local emojis, n = v[3], v[4]
			for i = 1, n do
				local emoji = emojis[i]
				if not emoji then continue end
				if not emoji:find(value) then continue end

				timer.Simple(main_i * 0.004, function()
					add_emoji(self, emoji, category_list, search_field)
				end)

				main_i = main_i + 1
			end
		end
	end

	function self.tab_scroller:Paint(w, h)
		draw.RoundedBox(0, 0, 0, w, h, SUI.GetColor("header"))
	end

	for k, v in SortedPairsByMemberValue(categories, 1) do
		if k == "Custom" and not has_permission then continue end

		self:AddSheet(SUI.Material("scb/emojis/" .. v[2] .. ".png"), function(parent)
			local category_list = make_category_list(parent, columns)

			local emojis, n = v[3], v[4]
			for i = 1, n do
				local emoji = emojis[i]
				if not emoji then continue end

				timer.Simple(i * 0.004, function()
					add_emoji(self, emoji, category_list, search_field)
				end)
			end

			return category_list
		end):SetTooltip(k)
	end

	self:MakePopup()
	self:ParentToHUD()

	search_field:RequestFocus()

	hook.Add("VGUIMousePressed", self, function(_, panel, mouse_code)
		if self == panel then return end
		if self:IsOurChild(panel) then return end
		if mouse_code ~= MOUSE_LEFT then return end
		if panel == self.button then return end
		if panel == scb.chatbox.header then return end

		self:Remove()
	end)
end

function Panel:Paint(w, h)
	if SUI.GetColor("frame_blur") then
		sui.TDLib.BlurPanel(self)
	end

	draw.RoundedBox(0, 0, 0, w, h, SUI.GetColor("frame"))
end

function Panel:OnKeyCodePressed(key_code)
	if key_code == KEY_ENTER and IsValid(self.selected) then
		self.selected:DoClick()
	end
end

local anim_speed = 0.2
function Panel:FixPos()
	local w, h = self.w, self.h

	self:SetSize(s, w * 1.1, h * 1.1)
	self:SetPos(self:_GetPos())
	self:SetAlpha(0)

	self:SizeTo(w, h, anim_speed, 0, -1)
	local x, y = self:_GetPos(w, h)
	self:MoveTo(x, y, anim_speed, 0, -1)
	self:AlphaTo(255, anim_speed + 0.02, 0, function()
		self.Think = self._Think
	end)
end

function Panel:_GetPos(m_w, m_h)
	local button = self.button

	if not m_w then
		m_w, m_h = self:GetSize()
	end

	local x, y, w = button:GetBounds()
	x, y = button:LocalToScreen(0, 0)
	x = x - (m_w / 2 - w / 2)
	y = y - m_h - 4

	return x, y
end

function Panel:_Think()
	self:SetPos(self:_GetPos())
	self:MoveToFront()
end

sui.register("EmojiList", Panel, "SCB.PropertySheet")
--addons/scb_chatbox/lua/scb/vgui/scb_emojis_select.lua:
if SCB_LOADED then return end

local draw = draw

local scb = scb
local sui = sui
local SUI = scb.SUI

local Panel = {}

AccessorFunc(Panel, "m_bTextEntry", "TextEntry")

function Panel:Init()
	self.emojis = {}
end

local line_DoClick = function(s)
	local parent = s:GetParent()
	parent[KEY_ENTER](parent)
end

local emoji_Paint = function(s, w, h)
	local parent = s.parent
	if parent.selected_emoji == s then
		draw.RoundedBox(0, 0, 0, w, h, SUI.GetColor("emoji_select_menu_selected"))
	end
end

local emoji_OnCursorEntered = function(s)
	s.parent.selected_emoji = s.emoji
end

function Panel:AddEmoji(name)
	local line = self:Add("DButton")
	line:Dock(TOP)
	line:SetTall(SUI.ScaleEven(22))
	line:InvalidateParent(true)
	line:SetText("")
	line.Paint = nil
	line.DoClick = line_DoClick
	line.parent = self
	line.OnCursorEntered = emoji_OnCursorEntered

	local emoji = line:Add("SCB.ChatLine")
	emoji:Dock(NODOCK)
	emoji:SetSize(line:GetSize())
	emoji:NewLabel(" ")
	emoji:NewEmoji(name, scb.emojis[name], 20)
	emoji:NewLabel(" :" .. name .. ":")
	emoji:Center()
	emoji:SetMouseInputEnabled(false)

	emoji.parent = self
	emoji.name = name
	emoji.Paint = emoji_Paint

	emoji.i = table.insert(self.emojis, emoji)

	if emoji.i == 1 then
		self.selected_emoji = emoji
	end

	line.emoji = emoji

	self:InvalidateLayout(true)
	self:SizeToChildren(false, true)

	return emoji
end

function Panel:SetStartEnd(start, _end)
	self.start, self._end = start, _end
end

function Panel:Paint(w, h)
	if SUI.GetColor("frame_blur") then
		sui.TDLib.BlurPanel(self)
	end

	draw.RoundedBox(3, 0, 0, w, h, SUI.GetColor("emoji_select_menu"))
end

Panel[KEY_UP] = function(self)
	self.selected_emoji = self.emojis[self.selected_emoji.i - 1] or self.emojis[#self.emojis]
	return true
end

Panel[KEY_DOWN] = function(self)
	self.selected_emoji = self.emojis[self.selected_emoji.i + 1] or self.emojis[1]
	return true
end

Panel[KEY_ENTER] = function(self)
	local text_entry = self:GetTextEntry()
	text_entry:RequestFocus()
	text_entry:AddValue(":" .. self.selected_emoji.name .. ": ", self.start - 1, self._end + 1)

	scb.emoji_set_used(self.selected_emoji.name)
	return true
end
Panel[KEY_TAB] = Panel[KEY_ENTER]

Panel[KEY_ESCAPE] = function(self)
	gui.HideGameUI()
	self:Remove()
end

sui.register("EmojisSelect", Panel, "Panel")
--addons/fusioncutter/lua/autorun/sh_index_fusioncutter.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--           Fusion Cutter           --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--     Fusion Cutter | SH Index      --
---------------------------------------

Fusioncutter = Fusioncutter || {}

if SERVER then
	AddCSLuaFile("fusioncutter/sh_config.lua")
	AddCSLuaFile("fusioncutter/sh_fusioncutter.lua")
	AddCSLuaFile("fusioncutter/cl_fusioncutter.lua")

	include("fusioncutter/sv_fusioncutter.lua")
	include("fusioncutter/sh_fusioncutter.lua")
	include("fusioncutter/sh_config.lua")
end

if CLIENT then
	include("fusioncutter/sh_config.lua")
	include("fusioncutter/sh_fusioncutter.lua")
	include("fusioncutter/cl_fusioncutter.lua")
end
--addons/fusioncutter/lua/fusioncutter/sh_fusioncutter.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--           Fusion Cutter           --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--        Fusion Cutter | SV         --
---------------------------------------

local Player = FindMetaTable("Player")

-- Checks if player has a fusion cutter
function Player:HasFusioncutter()
	local weps = self:GetWeapons()

	for _, wep in pairs(weps) do
		if not wep.IsFusioncutter then continue end

		return true
	end

	return false
end
--addons/map_control/lua/map_control/sh_config.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Mapcontrol             --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--     Mapcontrol | SH Config        --
---------------------------------------

-- Defines the buttons on the maps
Mapcontrol.Buttons = {}
Mapcontrol.Buttons["rp_bananakin_gn"] = {
	alarmButton = 1839,
}
--addons/starwars_universe/lua/star-wars-universe/client/cl_swu_changelog.lua:
local adraw = include("libs/advanceddraw.lua")

SWU = SWU or {}

surface.CreateFont("SwuChangelogHeader", {
    font = "Saira",
    size = 65,
    weight = 1000,
    antialias = true,
    shadow = false
})
surface.CreateFont("SwuChangelogTitle1", {
    font = "Saira",
    size = 50,
    weight = 1000,
    antialias = true,
    shadow = false
})
surface.CreateFont("SwuChangelogTitle2", {
    font = "Saira",
    size = 37,
    weight = 150,
    underline = true,
    antialias = true,
    shadow = false
})
surface.CreateFont("SwuChangelogText", {
    font = "Saira",
    size = 31,
    weight = 100,
    antialias = true,
    shadow = false
})
surface.CreateFont("SwuChangelogUnderline", {
    font = "Saira",
    size = 25,
    weight = 100,
    antialias = true,
    shadow = false
})

local icons = {
    ["+"] = Material("the-coding-ducks/swu/icons/added.png"),
    ["-"] = Material("the-coding-ducks/swu/icons/removed.png"),
    ["#"] = Material("the-coding-ducks/swu/icons/modified.png"),
}

local discordIcon = Material("the-coding-ducks/swu/icons/discord-icon.png", "smooth")
local steamIcon = Material("the-coding-ducks/swu/icons/steam-icon.png", "smooth")

local function ShouldShowChangelog()
    local updateTable = {
        ["lastSeenVersion"] = 0,
        ["ignore"] = false
    }

    if not file.Exists("star-wars-universe", "DATA") then
        file.CreateDir("star-wars-universe")
    end

    if file.Exists("star-wars-universe/config.json", "DATA") then
        updateTable = util.JSONToTable(file.Read("star-wars-universe/config.json", "DATA"))
    end

    if updateTable["lastSeenVersion"] >= SWU.Version or not istable(SWU.Changelog) or not istable(SWU.Changelog.changes) then
        return false
    end
    return SWU.Configuration:GetConVar("swu_enable_changelog"):GetBool()
end

local function UpdateChangelogConfig(ignore)
    ignore = ignore or false

    file.Write("star-wars-universe/config.json", util.TableToJSON({
        ["lastSeenVersion"] = SWU.Version,
        ["ignore"] = ignore
    }))
end

local COLORS = {
    primary = Color(10,10,10,200),
    background = Color(10,10,10,100),
    success = Color(122, 201, 67),
    dark = Color(26, 26, 26), -- in SWU.Colors.Default.dark
    light = Color(240, 240, 240),
    accent = Color(255, 153, 0) -- in SWU.Colors.Default.accent
}

function SWU:ShowChangelog()
    if (not ShouldShowChangelog()) then return end

    if (IsValid(self.ChangelogFrame)) then
        self.ChangelogFrame:Remove()
    end

    self.ChangelogFrame = vgui.Create("DFrame")
    local frame = self.ChangelogFrame
    frame:SetSize(ScrW() * 0.3, ScrH() * 0.8)
    frame:Center()
    frame:SetTitle("")
    frame:ShowCloseButton(false)
    frame:SetDraggable(false)
    frame:MakePopup()
    frame:DockPadding(0,0,0,0)

    frame.Paint = function () end

    local padding = frame:GetWide() * 0.025

    local header = frame:Add("DPanel")
    header:Dock(TOP)
    header:DockPadding(padding, padding, padding, padding)
    header:SetSize(frame:GetWide(), frame:GetTall() * 0.12)
    header.Paint = function()
        adraw.Derma_DrawPanelBlur(header, COLORS.primary)
    end

    local title = header:Add("DLabel")
    title:SetFont("SwuChangelogHeader")
    title:Dock(FILL)
    title:SetText("STAR WARS UNIVERSE")
    title:SetContentAlignment(5)
    title:SetMouseInputEnabled(true)
    title:SizeToContents()
    title:SetColor(COLORS.light)

    local content = frame:Add("DPanel")
    content:Dock(TOP)
    content:DockPadding(padding, padding, padding, padding)
    content:DockMargin(0, frame:GetTall() * 0.0125, 0, frame:GetTall() * 0.0125)
    content:SetSize(frame:GetWide(), frame:GetTall() * 0.735)
    content.Paint = function()
        adraw.Derma_DrawPanelBlur(content, COLORS.background)
    end

    local changelog = content:Add("DLabel")
    changelog:SetFont("SwuChangelogTitle1")
    changelog:SetText("CHANGELOG")
    changelog:SetColor(COLORS.accent)
    changelog:SetContentAlignment(4)
    changelog:Dock(TOP)
    changelog:SizeToContents()

    local version = content:Add("DLabel")
    version:DockMargin(0, frame:GetTall() * 0.0125, 0, frame:GetTall() * 0.0125)
    version:SetFont("SwuChangelogTitle2")
    version:SetText(SWU.Changelog.title)
    version:SetColor(COLORS.light)
    version:SetContentAlignment(4)
    version:Dock(TOP)
    version:SizeToContents()

    for _, change in ipairs(SWU.Changelog.changes) do
        local entry = content:Add("DPanel")
        entry.Paint = function () end
        entry:Dock(TOP)

        local icon = entry:Add("DPanel")
        icon:Dock(LEFT)
        icon:SetSize(icon:GetTall(), icon:GetTall())
        icon:DockMargin(0,0,icon:GetWide() * 0.2,0)
        icon.Paint = function (s, w, h)
            surface.SetDrawColor(COLORS.light)
            surface.SetMaterial(icons[change.type])
            surface.DrawTexturedRect(0,0,h,h)
        end

        local text = entry:Add("DLabel")
        text:SetText(change.text)
        text:Dock(LEFT)
        text:SetColor(COLORS.light)
        text:SetFont("SwuChangelogText")
        text:SizeToContents()
        text:SetWrap(true)
    end

    local links = content:Add("DPanel")
    links:Dock(BOTTOM)
    links:DockPadding(padding * 0.5, padding * 0.5, padding * 0.5, padding * 0.5)
    links:SetSize(frame:GetWide(), frame:GetTall() * 0.05)
    links.Paint = function()
        adraw.Derma_DrawPanelBlur(links, COLORS.background)
    end

    local discord = links:Add("DPanel")
    discord:Dock(RIGHT)
    discord:SetCursor("hand")
    discord:SetSize(frame:GetTall() * 0.05 - padding, frame:GetTall() * 0.05 - padding)
    discord:DockMargin(padding * 0.5,0,0,0)
    discord.Paint = function (s, w, h)
        surface.SetMaterial(discordIcon)
        surface.SetDrawColor(255,255,255)
        if (s:IsHovered()) then
            surface.SetDrawColor(88,101,242)
        end
        surface.DrawTexturedRect(0,0,math.floor(w),math.floor(h))
    end
    discord.OnMousePressed = function ()
        gui.OpenURL("https://discord.gg/TfDnmVB99X")
    end

    local steam = links:Add("DPanel")
    steam:Dock(RIGHT)
    steam:SetCursor("hand")
    steam:SetSize(frame:GetTall() * 0.05 - padding, frame:GetTall() * 0.05 - padding)
    steam.Paint = function (s, w, h)
        surface.SetMaterial(steamIcon)
        surface.SetDrawColor(255,255,255)
        if (s:IsHovered()) then
            surface.SetDrawColor(24,32,53)
        end
        surface.DrawTexturedRect(0,0,math.floor(w),math.floor(h))
    end
    steam.OnMousePressed = function ()
        gui.OpenURL("https://steamcommunity.com/sharedfiles/filedetails/?id=2735358488")
    end

    local footer = frame:Add("DPanel")
    footer:Dock(TOP)
    footer:DockPadding(padding, padding, padding, padding)
    footer:SetSize(frame:GetWide(), frame:GetTall() * 0.12)
    footer.Paint = function()
        adraw.Derma_DrawPanelBlur(footer, COLORS.primary)
    end

    local dontShowAgain = footer:Add("DLabel")
    dontShowAgain:SetFont("SwuChangelogUnderline")
    dontShowAgain:Dock(BOTTOM)
    dontShowAgain:SetText("Never show me the changelog again")
    dontShowAgain:SetContentAlignment(5)
    dontShowAgain:SetMouseInputEnabled(true)
    dontShowAgain:SetCursor("hand")
    dontShowAgain:SizeToContents()
    dontShowAgain.DoClick = function (self)
        LocalPlayer():ConCommand("swu_enable_changelog 0")
        frame:Close()
    end

    local bottomPadding = dontShowAgain:GetTall() * 0.3
    local closeBtn = footer:Add("DButton")
    closeBtn:Dock(BOTTOM)
    closeBtn:SetCursor("hand")
    closeBtn:SetSize(frame:GetWide(), frame:GetTall() * 0.12 - padding * 2 - dontShowAgain:GetTall() - bottomPadding)
    closeBtn:DockMargin(0,0,0,bottomPadding)
    closeBtn:SetText("")
    closeBtn.Paint = function (self, w, h)
        local x, y = 0, 0

        if (closeBtn:IsDown()) then
            local f = 0.002
            x, y = w * f, w * f
            w, h = w * (1 - f * 2), h - w * f * 2
        end

        draw.RoundedBox(0,math.Round(x),math.Round(y),w,h,COLORS.success)

        draw.SimpleText("CONTINUE", "SwuChangelogHeader", w * 0.5, h * 0.5, COLORS.dark, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
    end
    closeBtn.DoClick = function (self)
        UpdateChangelogConfig()
        frame:Close()
    end

end

hook.Add("Think", "SWU_OpenChangelog", function ()
    SWU:ShowChangelog()
    hook.Remove("Think", "SWU_OpenChangelog")
end)

--addons/starwars_universe/lua/libs/advanceddraw.lua:
--    Advanced Draw:
--    - IMGUI Source Code: https://github.com/wyozi-gmod/imgui
--    - Draw Precache Arc
--    - Draw Line with thickness

local adraw = {}

adraw.skin = {
    background = Color(0, 0, 0, 0),
    backgroundHover = Color(0, 0, 0, 0),
    border = Color(255, 255, 255),
    borderHover = Color(255, 127, 0),
    borderPress = Color(255, 80, 0),
    foreground = Color(255, 255, 255),
    foregroundHover = Color(255, 127, 0),
    foregroundPress = Color(255, 80, 0),
}

local devCvar = GetConVar("developer")

function adraw.IsDeveloperMode()
    return not adraw.DisableDeveloperMode and devCvar:GetInt() > 0
end

local _devMode = false -- cached local variable updated once in a while

function adraw.Hook(name, id, callback)
    local hookUniqifier = debug.getinfo(4).short_src
    hook.Add(name, "adraw / " .. id .. " / " .. hookUniqifier, callback)
end

local local_player
local gState = {}

local function shouldAcceptInput()
    -- don't process input during non-main renderpass
    if render.GetRenderTarget() ~= nil then return false end
    -- don't process input if we're doing VGUI stuff (and not in context menu)
    if vgui.CursorVisible() and vgui.GetHoveredPanel() ~= g_ContextMenu then return false end

    return true
end

adraw.Hook("PreRender", "adraw / Input", function()
    -- calculate mouse state
    if shouldAcceptInput() then
        local useBind = input.LookupBinding("+use", true)
        local attackBind = input.LookupBinding("+attack", true)
        local USE = useBind and input.GetKeyCode(useBind)
        local ATTACK = attackBind and input.GetKeyCode(attackBind)
        local wasPressing = gState.pressing
        gState.pressing = (USE and input.IsButtonDown(USE)) or (ATTACK and input.IsButtonDown(ATTACK))
        gState.pressed = not wasPressing and gState.pressing
    end
end)

hook.Add("NotifyShouldTransmit", "adraw / ClearRenderBounds", function(ent, shouldTransmit)
    if not shouldTransmit then return end
    local tb = ent:GetTable()
    if not tb._adrawRBExpansion then return end
    tb._adrawRBExpansion = nil
end)

local traceResultTable = {}

local traceQueryTable = {
    output = traceResultTable,
    filter = {}
}

local function isObstructed(eyePos, hitPos, ignoredEntity)
    local q = traceQueryTable
    q.start = eyePos
    q.endpos = hitPos
    q.filter[1] = local_player
    q.filter[2] = ignoredEntity
    local tr = util.TraceLine(q)

    if tr.Hit then
        return true, tr.Entity
    else
        return false
    end
end

function adraw.Start3D2D(pos, angles, scale, distanceHide, distanceFadeStart)
    local_player = local_player or LocalPlayer()

    if gState.shutdown == true then return end

    if gState.rendering == true then
        print("[AdvancedDraw] Starting a new adraw context when previous one is still rendering" .. "Shutting down rendering pipeline to prevent crashes..")
        gState.shutdown = true

        return false
    end

    _devMode = adraw.IsDeveloperMode()
    local eyePos = local_player:EyePos()
    local eyePosToPos = pos - eyePos

    -- OPTIMIZATION: Test that we are in front of the UI
    do
        local normal = angles:Up()
        local dot = eyePosToPos:Dot(normal)

        if _devMode then
            gState._devDot = dot
        end

        -- since normal is pointing away from surface towards viewer, dot<0 is visible
        if dot >= 0 then return false end
    end

    -- OPTIMIZATION: Distance based fade/hide
    if distanceHide then
        local distance = eyePosToPos:Length()
        if distance > distanceHide then return false end

        if _devMode then
            gState._devDist = distance
            gState._devHideDist = distanceHide
        end

        if distanceHide and distanceFadeStart and distance > distanceFadeStart then
            local blend = math.min(math.Remap(distance, distanceFadeStart, distanceHide, 1, 0), 1)
            render.SetBlend(blend)
            surface.SetAlphaMultiplier(blend)
        end
    end

    gState.rendering = true
    gState.pos = pos
    gState.angles = angles
    gState.scale = scale
    cam.Start3D2D(pos, angles, scale)

    -- calculate mousepos
    if not vgui.CursorVisible() or vgui.IsHoveringWorld() then
        local tr = local_player:GetEyeTrace()
        local eyepos = tr.StartPos
        local eyenormal

        if vgui.CursorVisible() and vgui.IsHoveringWorld() then
            eyenormal = gui.ScreenToVector(gui.MousePos())
        else
            eyenormal = tr.Normal
        end

        local planeNormal = angles:Up()
        local hitPos = util.IntersectRayWithPlane(eyepos, eyenormal, pos, planeNormal)

        if hitPos then
            local obstructed, obstructer = isObstructed(eyepos, hitPos, gState.entity)

            if obstructed then
                gState.mx = nil
                gState.my = nil

                if _devMode then
                    gState._devInputBlocker = "collision " .. obstructer:GetClass() .. "/" .. obstructer:EntIndex()
                end
            else
                local diff = pos - hitPos
                -- This cool code is from Willox's keypad CalculateCursorPos
                local x = diff:Dot(-angles:Forward()) / scale
                local y = diff:Dot(-angles:Right()) / scale
                gState.mx = x
                gState.my = y
            end
        else
            gState.mx = nil
            gState.my = nil

            if _devMode then
                gState._devInputBlocker = "not looking at plane"
            end
        end
    else
        gState.mx = nil
        gState.my = nil

        if _devMode then
            gState._devInputBlocker = "not hovering world"
        end
    end

    if _devMode then
        gState._renderStarted = SysTime()
    end

    return true
end

function adraw.Entity3D2D(ent, lpos, lang, scale, ...)
    gState.entity = ent
    local ret = adraw.Start3D2D(ent:LocalToWorld(lpos), ent:LocalToWorldAngles(lang), scale, ...)

    if not ret then
        gState.entity = nil
    end

    return ret
end

local function calculateRenderBounds(x, y, w, h)
    local pos = gState.pos
    local fwd, right = gState.angles:Forward(), gState.angles:Right()
    local scale = gState.scale
    local firstCorner, secondCorner = pos + fwd * x * scale + right * y * scale, pos + fwd * (x + w) * scale + right * (y + h) * scale
    local minrb, maxrb = Vector(math.huge, math.huge, math.huge), Vector(-math.huge, -math.huge, -math.huge)
    minrb.x = math.min(minrb.x, firstCorner.x, secondCorner.x)
    minrb.y = math.min(minrb.y, firstCorner.y, secondCorner.y)
    minrb.z = math.min(minrb.z, firstCorner.z, secondCorner.z)
    maxrb.x = math.max(maxrb.x, firstCorner.x, secondCorner.x)
    maxrb.y = math.max(maxrb.y, firstCorner.y, secondCorner.y)
    maxrb.z = math.max(maxrb.z, firstCorner.z, secondCorner.z)

    return minrb, maxrb
end

function adraw.ExpandRenderBoundsFromRect(x, y, w, h)
    local ent = gState.entity

    if IsValid(ent) then
        local tb = ent:GetTable()
        -- make sure we're not applying same expansion twice
        local expansion = tb._adrawRBExpansion

        if expansion then
            local ex, ey, ew, eh = unpack(expansion)
            if ex == x and ey == y and ew == w and eh == h then return end
        end

        local minrb, maxrb = calculateRenderBounds(x, y, w, h)
        ent:SetRenderBoundsWS(minrb, maxrb)

        if _devMode then
            print("[adraw] Updated renderbounds of ", ent, " to ", minrb, "x", maxrb)
        end

        tb._adrawRBExpansion = {x, y, w, h}
    else
        if _devMode then
            print("[adraw] Attempted to update renderbounds when entity is not valid!! ", debug.traceback())
        end
    end
end

local devOffset = Vector(0, 0, 30)

local devColours = {
    background = Color(0, 0, 0, 200),
    title = Color(78, 205, 196),
    mouseHovered = Color(0, 255, 0),
    mouseUnhovered = Color(255, 0, 0),
    pos = Color(255, 255, 255),
    distance = Color(200, 200, 200, 200),
    ang = Color(255, 255, 255),
    dot = Color(200, 200, 200, 200),
    angleToEye = Color(200, 200, 200, 200),
    renderTime = Color(255, 255, 255),
    renderBounds = Color(0, 0, 255)
}

local function developerText(str, x, y, clr)
    draw.SimpleText(str, "DefaultFixedDropShadow", x, y, clr, TEXT_ALIGN_CENTER, nil)
end

local function drawDeveloperInfo()
    local camAng = local_player:EyeAngles()
    camAng:RotateAroundAxis(camAng:Right(), 90)
    camAng:RotateAroundAxis(camAng:Up(), -90)
    cam.IgnoreZ(true)
    cam.Start3D2D(gState.pos + devOffset, camAng, 0.15)
        local bgCol = devColours["background"]
        surface.SetDrawColor(bgCol.r, bgCol.g, bgCol.b, bgCol.a)
        surface.DrawRect(-100, 0, 200, 140)
        local titleCol = devColours["title"]
        developerText("adraw developer", 0, 5, titleCol)
        surface.SetDrawColor(titleCol.r, titleCol.g, titleCol.b)
        surface.DrawLine(-50, 16, 50, 16)
        local mx, my = gState.mx, gState.my
    
        if mx and my then
            developerText(string.format("mouse: hovering %d x %d", mx, my), 0, 20, devColours["mouseHovered"])
        else
            developerText(string.format("mouse: %s", gState._devInputBlocker or ""), 0, 20, devColours["mouseUnhovered"])
        end
    
        local pos = gState.pos
        developerText(string.format("pos: %.2f %.2f %.2f", pos.x, pos.y, pos.z), 0, 40, devColours["pos"])
        developerText(string.format("distance %.2f / %.2f", gState._devDist or 0, gState._devHideDist or 0), 0, 53, devColours["distance"])
        local ang = gState.angles
        developerText(string.format("ang: %.2f %.2f %.2f", ang.p, ang.y, ang.r), 0, 75, devColours["ang"])
        developerText(string.format("dot %d", gState._devDot or 0), 0, 88, devColours["dot"])
        local angToEye = (pos - local_player:EyePos()):Angle()
        angToEye:RotateAroundAxis(ang:Up(), -90)
        angToEye:RotateAroundAxis(ang:Right(), 90)
        developerText(string.format("angle to eye (%d,%d,%d)", angToEye.p, angToEye.y, angToEye.r), 0, 100, devColours["angleToEye"])
        developerText(string.format("rendertime avg: %.2fms", (gState._devBenchAveraged or 0) * 1000), 0, 120, devColours["renderTime"])
    cam.End3D2D()
    cam.IgnoreZ(false)
    local ent = gState.entity

    if not IsValid(ent) then return end
    local tb = ent:GetTable()
    if not tb._adrawRBExpansion then return end
    local ex, ey, ew, eh = unpack(tb._adrawRBExpansion)
    local minrb, maxrb = calculateRenderBounds(ex, ey, ew, eh)
    render.DrawWireframeBox(vector_origin, angle_zero, minrb, maxrb, devColours["renderBounds"])
end

function adraw.End3D2D()
    if gState then
        if _devMode then
            local renderTook = SysTime() - gState._renderStarted
            gState._devBenchTests = (gState._devBenchTests or 0) + 1
            gState._devBenchTaken = (gState._devBenchTaken or 0) + renderTook

            if gState._devBenchTests == 100 then
                gState._devBenchAveraged = gState._devBenchTaken / 100
                gState._devBenchTests = 0
                gState._devBenchTaken = 0
            end
        end

        gState.rendering = false
        cam.End3D2D()
        render.SetBlend(1)
        surface.SetAlphaMultiplier(1)

        if _devMode then
            drawDeveloperInfo()
        end

        gState.entity = nil
    end
end

function adraw.CursorPos()
    local mx, my = gState.mx, gState.my

    return mx, my
end

function adraw.IsHovering(x, y, w, h)
    local mx, my = gState.mx, gState.my

    return mx and my and mx >= x and mx <= (x + w) and my >= y and my <= (y + h)
end

function adraw.IsPressing()
    return shouldAcceptInput() and gState.pressing
end

function adraw.IsPressed()
    return shouldAcceptInput() and gState.pressed
end

local _createdFonts = {}
local _adrawFontToGmodFont = {}
local EXCLAMATION_BYTE = string.byte("!")

function adraw.xFont(font, defaultSize)
    -- special font
    if string.byte(font, 1) == EXCLAMATION_BYTE then
        local existingGFont = _adrawFontToGmodFont[font]
        if existingGFont then return existingGFont end
        -- Font not cached; parse the font
        local name, size = font:match("!([^@]+)@(.+)")

        if size then
            size = tonumber(size)
        end

        if not size and defaultSize then
            name = font:match("^!([^@]+)$")
            size = defaultSize
        end

        local fontName = string.format("adraw_%s_%d", name, size)
        _adrawFontToGmodFont[font] = fontName

        if not _createdFonts[fontName] then
            surface.CreateFont(fontName, {
                font = name,
                size = size
            })

            _createdFonts[fontName] = true
        end

        return fontName
    end

    return font
end

function adraw.DrawBox(x,y,w,h,borderWidth, borderColor)
    if borderWidth > 0 then
        surface.SetDrawColor(borderColor)
        surface.DrawRect(x, y, w, borderWidth)
        surface.DrawRect(x, y + borderWidth, borderWidth, h - borderWidth * 2)
        surface.DrawRect(x, y + h - borderWidth, w, borderWidth)
        surface.DrawRect(x + w - borderWidth + 1, y, borderWidth, h)
    end
end

function adraw.xButton(x, y, w, h, borderWidth, borderClr, hoverClr, pressColor)
    local bw = borderWidth or 1
    local bgColor = adraw.IsHovering(x, y, w, h) and adraw.skin.backgroundHover or adraw.skin.background
    local borderColor = ((adraw.IsPressing() and adraw.IsHovering(x, y, w, h)) and (pressColor or adraw.skin.borderPress)) or (adraw.IsHovering(x, y, w, h) and (hoverClr or adraw.skin.borderHover)) or (borderClr or adraw.skin.border)
    surface.SetDrawColor(bgColor)
    surface.DrawRect(x, y, w, h)

    adraw.DrawBox(x,y,w,h,bw,borderColor)

    local isHovering = adraw.IsHovering(x, y, w, h)
    return shouldAcceptInput() and isHovering and gState.pressed, isHovering
end

function adraw.xOneColorButton(x, y, w, h, borderWidth, clr)
    local bw = borderWidth or 1
    surface.SetDrawColor(clr)
    surface.DrawRect(x, y, w, h)

    if bw > 0 then
        surface.SetDrawColor(clr)
        surface.DrawRect(x, y, w, bw)
        surface.DrawRect(x, y + bw, bw, h - bw * 2)
        surface.DrawRect(x, y + h - bw, w, bw)
        surface.DrawRect(x + w - bw + 1, y, bw, h)
    end

    return shouldAcceptInput() and adraw.IsHovering(x, y, w, h) and gState.pressed
end

function adraw.xCursor(x, y, w, h)
    local fgColor = adraw.IsPressing() and adraw.skin.foregroundPress or adraw.skin.foreground
    local mx, my = gState.mx, gState.my
    if not mx or not my then return end
    if x and w and (mx < x or mx > x + w) then return end
    if y and h and (my < y or my > y + h) then return end
    local cursorSize = math.ceil(0.3 / gState.scale)
    surface.SetDrawColor(fgColor)
    surface.DrawLine(mx - cursorSize, my, mx + cursorSize, my)
    surface.DrawLine(mx, my - cursorSize, mx, my + cursorSize)
end

function adraw.xTextButton(text, font, x, y, w, h, borderWidth, color, hoverClr, pressColor)
    local fgColor = ((adraw.IsPressing() and adraw.IsHovering(x, y, w, h)) and (pressColor or adraw.skin.foregroundPress)) or (adraw.IsHovering(x, y, w, h) and (hoverClr or adraw.skin.foregroundHover)) or (color or adraw.skin.foreground)
    local clicked = adraw.xButton(x, y, w, h, borderWidth, color, hoverClr, pressColor)
    font = adraw.xFont(font, math.floor(h * 0.618))
    draw.SimpleText(text, font, x + w / 2, y + h / 2, fgColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

    return clicked
end

function adraw.xConButton(x, y, w, h, borderWidth, color, hoverClr, pressColor, conColor, condition)
    local fgColor
    local clicked
    if condition then
        fgColor = conColor
        clicked = adraw.xOneColorButton(x, y, w, h, borderWidth, conColor)
    else
        fgColor = ((adraw.IsPressing() and adraw.IsHovering(x, y, w, h)) and (pressColor or adraw.skin.foregroundPress)) or (adraw.IsHovering(x, y, w, h) and (hoverClr or adraw.skin.foregroundHover)) or (color or adraw.skin.foreground)
        clicked = adraw.xButton(x, y, w, h, borderWidth, color, hoverClr, pressColor)
    end

    return clicked
end

function adraw.xSymbolButton(symbol, x, y, w, h, borderWidth, color, hoverClr, pressColor)
    local fgColor = ((adraw.IsPressing() and adraw.IsHovering(x, y, w, h)) and (pressColor or adraw.skin.foregroundPress)) or (adraw.IsHovering(x, y, w, h) and (hoverClr or adraw.skin.foregroundHover)) or (color or adraw.skin.foreground)
    local clicked = adraw.xButton(x, y, w, h, borderWidth, color, hoverClr, pressColor)
    surface.SetMaterial(symbol)
    surface.SetDrawColor(fgColor)
    surface.DrawTexturedRect(x, y, w, h)

    return clicked
end

function adraw.xDrawLine(x, y, x2, y2, sz)
    local midX = (x + x2) / 2
    local midY = (y + y2) / 2

    local dx = x2 - x
    local dy = y2 - y
    local ang = -math.deg(math.atan2(dy, dx))

    local len = math.sqrt((x2 - x) ^ 2 + (y2 - y) ^ 2)
    draw.NoTexture()
    surface.DrawTexturedRectRotated(midX, midY, len, sz, ang)
end

local cached = {}

function adraw.Arc(cx, cy, radius, thickness, startang, endang, roughness, color)
    local arc = tostring(cx) .. tostring(cy) .. tostring(radius) .. tostring(thickness) .. tostring(startang) .. tostring(endang) .. tostring(roughness)
    surface.SetDrawColor(color)
    draw.NoTexture()

    if (cached[arc] == nil) then
        cached[arc] = adraw.PrecacheArc(cx, cy, radius, thickness, startang, endang, roughness)
    end

    adraw.DrawArc(cached[arc])
end

function adraw.PrecacheArc(cx, cy, radius, thickness, startang, endang, roughness)
    local triarc = {}
    local roughness = math.max(roughness or 1, 1)
    local step = roughness
    local startang, endang = startang or 0, endang or 0

    if startang > endang then
        step = math.abs(step) * -1
    end

    local inner = {}
    local r = radius - thickness

    for deg = startang, endang, step do
        local rad = math.rad(deg)
        local ox, oy = cx + (math.cos(rad) * r), cy + (-math.sin(rad) * r)

        table.insert(inner, {
            x = ox,
            y = oy,
            u = (ox - cx) / radius + .5,
            v = (oy - cy) / radius + .5,
        })
    end

    local outer = {}

    for deg = startang, endang, step do
        local rad = math.rad(deg)
        local ox, oy = cx + (math.cos(rad) * radius), cy + (-math.sin(rad) * radius)

        table.insert(outer, {
            x = ox,
            y = oy,
            u = (ox - cx) / radius + .5,
            v = (oy - cy) / radius + .5,
        })
    end

    for tri = 1, #inner * 2 do
        local p1, p2, p3
        p1 = outer[math.floor(tri / 2) + 1]
        p3 = inner[math.floor((tri + 1) / 2) + 1]

        if tri % 2 == 0 then
            p2 = outer[math.floor((tri + 1) / 2)]
        else
            p2 = inner[math.floor((tri + 1) / 2)]
        end

        table.insert(triarc, {p1, p2, p3})
    end

    return triarc
end

function adraw.DrawArc(arc)
    for _, v in ipairs(arc) do
        surface.DrawPoly(v)
    end
end

function adraw.DrawTexturedRectRotatedPoint( x, y, w, h, rot, x0, y0 )
    local c = math.cos( math.rad( rot ) )
    local s = math.sin( math.rad( rot ) )

    local newx = y0 * s - x0 * c
    local newy = y0 * c + x0 * s

    surface.DrawTexturedRectRotated( x + newx, y + newy, w, h, rot )
end

local matBlurScreen = Material("pp/blurscreen")
function adraw.Derma_DrawPanelBlur(panel, color)
    color = color or Color(10,10,10,100)
    local x, y = panel:LocalToScreen( 0, 0 )

    -- Menu cannot do blur
    if ( not MENU_DLL ) then
        surface.SetMaterial( matBlurScreen )
        surface.SetDrawColor( 255, 255, 255, 255 )

        for i = 0.33, 1, 0.33 do
            matBlurScreen:SetFloat( "$blur", 5 * i )
            matBlurScreen:Recompute()
            if ( render ) then
                render.UpdateScreenEffectTexture()
            end
            surface.DrawTexturedRect( x * -1, y * -1, ScrW(), ScrH() )
        end
    end

    surface.SetDrawColor(color)
    surface.DrawRect( x * -1, y * -1, ScrW(), ScrH() )
end

return adraw

--addons/starwars_universe/lua/star-wars-universe/client/vgui/cl_swu_row.lua:
local PANEL = {}

surface.CreateFont("SwuRowText", {
    font = "Saira",
    size = 30,
    weight = 250,
    antialias = true,
    shadow = false
})

function PANEL:Init()
    self:Dock(TOP)

    self:SetSize(self:GetParent():GetWide(), 40)
end

function PANEL:SetText(text)
    self.Text = text
end

function PANEL:GetText()
    return self.Text
end

function PANEL:Paint(w,h)
    draw.SimpleText(self.Text, "SwuRowText", 0, h * 0.5, nil, nil, TEXT_ALIGN_CENTER)
end

function PANEL:AddContent(panelClass)
    if (IsValid(self.Content)) then
        self.Content:Remove()
    end

    self.Content = self:Add(panelClass)
    self.Content:Dock(RIGHT)

    return self.Content
end

vgui.Register("swu_row", PANEL, "swu_basepanel")
--addons/starwars_universe/lua/star-wars-universe/shared/sh_swu_interaction.lua:
SWU = SWU or {}
SWU.Util = SWU.Util or {}
SWU.Util.IgnoreEnter = SWU.Util.IgnoreEnter or 0

if SERVER then
    util.AddNetworkString("swu_sendInteractionConfiguration")

    net.Receive("swu_sendInteractionConfiguration", function (_, ply)
        ply.InteractionConfiguration = net.ReadBool()
    end)
end

local function InteractableRealm(realm, callable, ...)
    local args = {...}
    return function (self) if realm then callable(self, unpack(args)) end end
end

function SWU.Util:InteractableServer(callable, ...)
    return InteractableRealm(SERVER, callable, ...)
end
function SWU.Util:InteractableClient(callable, ...)
    return InteractableRealm(CLIENT, callable, ...)
end

local function canInput(ply, hitPos)
    return ply:EyePos():DistToSqr(hitPos) < 5000
end

local function hasInteractionEnabled(ply)
    if SERVER then return ply.InteractionConfiguration end

    return SWU.Configuration:GetConVar("swu_enable_interaction"):GetBool()
end

hook.Add("PlayerButtonDown", "RegisterSWUInteractableBinds", function (ply, code)
    if not hasInteractionEnabled(ply) then return end

    if CLIENT and not IsFirstTimePredicted() then return end

    if CLIENT and (code == KEY_PAD_ENTER or code == KEY_ENTER) and CurTime() - SWU.Util.IgnoreEnter < 2 then SWU.Util.IgnoreEnter = 0 return end -- Required for closing search field of naviation computer using Enter

    local trace = ply:GetEyeTrace()
    local ent = trace.Entity
    if not isentity(ent) or not ent.SWU_Interactable or not canInput(ply, trace.HitPos) then return end

    if isfunction(ent.SWU_UsedKeys[code]) then
        ent.SWU_UsedKeys[code](ent)
    end
end)


if SERVER then return end

hook.Add("PlayerBindPress", "BlockBindsOnSWUInteractable", function(ply, _, _, code)
    if not hasInteractionEnabled(ply) then return end

    local trace = ply:GetEyeTrace()
    local ent = trace.Entity
    if not isentity(ent) or not ent.SWU_Interactable or not canInput(ply, trace.HitPos) then return end

    return isfunction(ent.SWU_UsedKeys[code])
end)

--lua/sitanywhere/helpers.lua:
SitAnywhere = SitAnywhere or {}
SitAnywhere.NET = {
	["SitWantedAng"] = 0,
	["SitRequestExit"] = 1,
}

SitAnywhere.ClassBlacklist = {
	["gmod_wire_keyboard"] = true,
	["prop_combine_ball"] = true
}

SitAnywhere.DoNotParent = {
	["yava_chunk"] = true
}
SitAnywhere.ModelBlacklist = {
}

local EMETA = FindMetaTable"Entity"

function SitAnywhere.GetAreaProfile(pos, resolution, simple)
	local filter = player.GetAll()
	local dists = {}
	local distsang = {}
	local ang_smallest_hori = nil
	local smallest_hori = 90000
	local angPerIt = (360 / resolution)
	for I = 0, 360, angPerIt do
		local rad = math.rad(I)
		local dir = Vector(math.cos(rad), math.sin(rad), 0)
		local trace = util.QuickTrace(pos + dir * 20 + Vector(0,0,5), Vector(0,0,-15000), filter)
		trace.HorizontalTrace = util.QuickTrace(pos + Vector(0,0,5), dir * 1000, filter)
		trace.Distance  =  trace.StartPos:Distance(trace.HitPos)
		trace.Distance2 = trace.HorizontalTrace.StartPos:Distance(trace.HorizontalTrace.HitPos)
		trace.ang = I

		if (not trace.Hit or trace.Distance > 14) and (not trace.HorizontalTrace.Hit or trace.Distance2 > 20) then
			if simple then return true end
			table.insert(dists, trace)
		end
		if trace.Distance2 < smallest_hori and (not trace.HorizontalTrace.Hit or trace.Distance2 > 3) then
			smallest_hori = trace.Distance2
			ang_smallest_hori = I
		end
		distsang[I] = trace
	end

	if simple then return false end
	return dists, distsang, ang_smallest_hori, smallest_hori
end

function SitAnywhere.CheckValidAngForSit(pos, surfaceAng, ang)
	local rad = math.rad(ang)
	local dir = Vector(math.cos(rad), math.sin(rad), 0)
	local trace2 = util.TraceLine({
		start = pos - dir * (20 - .5) + surfaceAng:Forward() * 5,
		endpos = pos - dir * (20 - .5) + surfaceAng:Forward() * -160,
		filter = player.GetAll()
	})

	local hor_trace = util.TraceLine({
		start = pos + Vector(0, 0, 5),
		endpos = pos + Vector(0, 0, 5) - dir * 1600,
		filter = player.GetAll()
	})

	return hor_trace.StartPos:Distance(hor_trace.HitPos) > 20 and trace2.StartPos:Distance(trace2.HitPos) > 14
end


local SitOnEntsMode = CreateConVar("sitting_ent_mode","3", {FCVAR_NOTIFY, FCVAR_ARCHIVE, FCVAR_REPLICATED}, "0 = No entities\n1 = World entities only\n2 = Self-Owned, World, Unowned\n3 = Any Entity", 0, 3)
--[[
	0 - Can't sit on any ents
	1 - Can't sit on any player ents
	2 - Can only sit on your own ents
	3 - Any
]]

local blacklist = SitAnywhere.ClassBlacklist
local model_blacklist = SitAnywhere.ModelBlacklist
function SitAnywhere.ValidSitTrace(ply, EyeTrace)
	if not EyeTrace.Hit then return false end
	if EyeTrace.HitPos:Distance(EyeTrace.StartPos) > 100 then return false end
	local t = hook.Run("CheckValidSit", ply, EyeTrace)

	if t == false or t == true then
		return t
	end

	if not EyeTrace.HitWorld and SitOnEntsMode:GetInt() == 0 then return false end
	if not EyeTrace.HitWorld and blacklist[string.lower(EyeTrace.Entity:GetClass())] then return false end
	if not EyeTrace.HitWorld and EyeTrace.Entity:GetModel() and model_blacklist[string.lower(EyeTrace.Entity:GetModel())] then return false end


	if EMETA.CPPIGetOwner and SitOnEntsMode:GetInt() >= 1 then
		if SitOnEntsMode:GetInt() == 1 then
			if not EyeTrace.HitWorld then
				local owner = EyeTrace.Entity:CPPIGetOwner()
				if type(owner) == "Player" and owner ~= nil and owner:IsValid() and owner:IsPlayer() then
					return false
				end
			end
		elseif SitOnEntsMode:GetInt() == 2 then
			if not EyeTrace.HitWorld then
				local owner = EyeTrace.Entity:CPPIGetOwner()
				if type(owner) == "Player" and owner ~= nil and owner:IsValid() and owner:IsPlayer() and owner ~= ply then
					return false
				end
			end
		end
	end
	return true
end

local seatClass = "prop_vehicle_prisoner_pod"
local PMETA = FindMetaTable"Player"
function PMETA:GetSitters()
	local seats, holders = {}, {}

	local function processSeat(seat, depth)
		depth = (depth or 0) + 1
		if IsValid(seat:GetDriver()) and seat:GetDriver() ~= self then
			table.insert(seats, seat)
		end
		for _, v in pairs(seat:GetChildren()) do
			if IsValid(v) and v:GetClass() == seatClass and IsValid(v:GetDriver()) and #v:GetChildren() > 0 and depth <= 128 then
				processSeat(v, depth)
			end
		end
	end

	local plyVehicle = self:GetVehicle()
	if IsValid(plyVehicle) and plyVehicle:GetClass() == seatClass then
		processSeat(plyVehicle)
	end

	for _, v in pairs(self:GetChildren()) do
		if IsValid(v) and v:GetClass() == seatClass then
			processSeat(v)
		end
	end

	for _, v in pairs(ents.FindByClass("sit_holder")) do
		if v.GetTargetPlayer and v:GetTargetPlayer() == self then
			table.insert(holders, v)
			if v.GetSeat and IsValid(v:GetSeat()) then
				processSeat(v:GetSeat())
			end
		end
	end
	return seats, holders
end

function PMETA:IsPlayerSittingOn(ply)
	local seats = ply:GetSitters()
	for _,v in pairs(seats) do
		if IsValid(v:GetDriver()) and v:GetDriver() == self then return true end
	end
	return false
end

function PMETA:GetSitting()
	if not IsValid(self:GetVehicle()) then return false end
	local veh = self:GetVehicle()
	if veh:GetNWBool("playerdynseat", false) then
		local parent = veh:GetParent()
		if IsValid(parent) and parent:GetClass() == "sit_holder" then
			return veh, parent
		else
			return veh
		end
	end
	return false
end

function PMETA:ExitSit()
	if CLIENT then
		if self ~= LocalPlayer() then return end
		net.Start("SitAnywhere")
			net.WriteInt(SitAnywhere.NET.SitRequestExit, 4)
		net.SendToServer()
	else
		local seat, holder = self:GetSitting()
		SafeRemoveEntity(seat)
		SafeRemoveEntity(holder)

		if SitAnywhere.GroundSit and self:GetNWBool("SitGroundSitting", false) then
			self:SetNWBool("SitGroundSitting", false)
		end
	end
end

function EMETA:IsSitAnywhereSeat()
	if self:GetClass() ~= "prop_vehicle_prisoner_pod" then return false end
	if SERVER and self.playerdynseat then return true end
	return self:GetNWBool("playerdynseat", false)
end
--lua/autorun/skinforcer.lua:

if SERVER then
	AddCSLuaFile("skins/devinity.lua")
	AddCSLuaFile()

	resource.AddSingleFile("materials/summe/summe.png")
else
	include("skins/devinity.lua")

	hook.Add("ForceDermaSkin", "skinforcehook", function()
		return "devinity"
	end)
end

--addons/tfa_base/lua/tfa/enums/sights.lua:
TFA.Enum.SIGHTSPOS_ATTACH = 0
TFA.Enum.SIGHTSPOS_BONE = 1

TFA.Enum.RETICLE_FLAT = bit.lshift(1, 1)
TFA.Enum.RETICLE_MODEL = bit.lshift(1, 2)
TFA.Enum.RETICLE_QUAD = bit.lshift(1, 3)

TFA.Enum.RETICLE_DRAW_ORDER = {
	TFA.Enum.RETICLE_MODEL,
	TFA.Enum.RETICLE_QUAD,
	TFA.Enum.RETICLE_FLAT,
}
--addons/tfa_base/lua/tfa/enums/statusnew.lua:
TFA.ENUM_COUNTER = TFA.ENUM_COUNTER or 0

TFA.Enum.InverseStatus = TFA.Enum.InverseStatus or {}
local upper = string.upper

local function gen(input)
	return "STATUS_" .. upper(input)
end

function TFA.AddStatus(input)
	local key = gen(input)
	local getkey = TFA.Enum[key]

	if not getkey then
		getkey = TFA.ENUM_COUNTER
		TFA.ENUM_COUNTER = TFA.ENUM_COUNTER + 1
		TFA.Enum[key] = getkey
	end

	TFA.Enum.InverseStatus[getkey] = key

	return getkey
end

function TFA.GetStatus(input)
	local key = gen(input)
	local getkey = TFA.Enum[key]

	if not getkey then
		return TFA.AddStatus(input) -- DANGEROUS:
		-- Race condition:
		-- If something go terribly wrong and order of addition of new statuses fuck up
		-- everything will fail horribly!
	end

	return getkey
end

TFA.AddStatus("idle")
TFA.AddStatus("draw")
TFA.AddStatus("holster")
TFA.AddStatus("holster_final")
TFA.AddStatus("holster_ready")
TFA.AddStatus("reloading")
TFA.AddStatus("reloading_wait")

TFA.AddStatus("reloading_loop_start")
TFA.AddStatus("reloading_loop_start_empty")
TFA.AddStatus("reloading_loop")
TFA.AddStatus("reloading_loop_end")

TFA.Enum.STATUS_RELOADING_SHOTGUN_START = TFA.Enum.STATUS_RELOADING_LOOP_START
TFA.Enum.STATUS_RELOADING_SHOTGUN_START_SHELL = TFA.Enum.STATUS_RELOADING_LOOP_START_EMPTY
TFA.Enum.STATUS_RELOADING_SHOTGUN_LOOP = TFA.Enum.STATUS_RELOADING_LOOP
TFA.Enum.STATUS_RELOADING_SHOTGUN_END = TFA.Enum.STATUS_RELOADING_LOOP_END

TFA.AddStatus("shooting")
TFA.AddStatus("silencer_toggle")
TFA.AddStatus("bashing")
TFA.AddStatus("bashing_wait")
TFA.AddStatus("inspecting")
TFA.AddStatus("fidget")
TFA.AddStatus("firemode")

TFA.AddStatus("pump")

TFA.AddStatus("knife_slash")
TFA.AddStatus("knife_stab")

TFA.AddStatus("grenade_pull")
TFA.AddStatus("grenade_ready")
TFA.AddStatus("grenade_throw")

TFA.AddStatus("blocking")
TFA.AddStatus("blocking_end")

TFA.AddStatus("bow_shoot")
TFA.AddStatus("bow_cancel")

TFA.AddStatus("grenade_pull")
TFA.AddStatus("grenade_throw")
TFA.AddStatus("grenade_ready")
TFA.AddStatus("grenade_throw_wait")

TFA.Enum.HolsterStatus = {
	[TFA.Enum.STATUS_HOLSTER] = true,
	[TFA.Enum.STATUS_HOLSTER_FINAL] = true,
	[TFA.Enum.STATUS_HOLSTER_READY] = true
}

TFA.Enum.HolsterStatusFinal = {
	[TFA.Enum.STATUS_HOLSTER_FINAL] = true,
	[TFA.Enum.STATUS_HOLSTER_READY] = true
}

TFA.Enum.ReloadStatus = {
	[TFA.Enum.STATUS_RELOADING] = true,
	[TFA.Enum.STATUS_RELOADING_WAIT] = true,
	[TFA.Enum.STATUS_RELOADING_LOOP_START] = true,
	[TFA.Enum.STATUS_RELOADING_LOOP_START_EMPTY] = true,
	[TFA.Enum.STATUS_RELOADING_LOOP] = true,
	[TFA.Enum.STATUS_RELOADING_LOOP_END] = true
}

TFA.Enum.ReadyStatus = {
	[TFA.Enum.STATUS_IDLE] = true,
	[TFA.Enum.STATUS_INSPECTING] = true,
	[TFA.Enum.STATUS_FIDGET] = true
}

TFA.Enum.IronStatus = {
	[TFA.Enum.STATUS_IDLE] = true,
	[TFA.Enum.STATUS_SHOOTING] = true,
	[TFA.Enum.STATUS_PUMP] = true,
	[TFA.Enum.STATUS_FIREMODE] = true--,
	--[TFA.Enum.STATUS_FIDGET] = true
}

TFA.Enum.HUDDisabledStatus = {
	[TFA.Enum.STATUS_IDLE] = true,
	[TFA.Enum.STATUS_SHOOTING] = true,
	[TFA.Enum.STATUS_FIREMODE] = true,
	[TFA.Enum.STATUS_BASHING] = true,
	[TFA.Enum.STATUS_BASHING_WAIT] = true,
	[TFA.Enum.STATUS_HOLSTER] = true,
	[TFA.Enum.STATUS_HOLSTER_FINAL] = true,
	[TFA.Enum.STATUS_HOLSTER_READY] = true,
	[TFA.Enum.STATUS_KNIFE_SLASH] = true,
	[TFA.Enum.STATUS_KNIFE_STAB] = true,
	[TFA.Enum.STATUS_GRENADE_PULL] = true,
	[TFA.Enum.STATUS_GRENADE_READY] = true,
	[TFA.Enum.STATUS_GRENADE_THROW] = true,
	[TFA.Enum.STATUS_BLOCKING] = true,
	[TFA.Enum.STATUS_BLOCKING_END] = true,
	[TFA.Enum.STATUS_PUMP] = true
}

TFA.Enum.BashStatus = {
	[TFA.Enum.STATUS_BASHING] = true,
	[TFA.Enum.STATUS_BASHING_WAIT] = true,
}

TFA.Enum.SHOOT_IDLE = 0
TFA.Enum.SHOOT_START = 1
TFA.Enum.SHOOT_LOOP = 2
TFA.Enum.SHOOT_CHECK = 3
TFA.Enum.SHOOT_END = 4

TFA.Enum.ShootReadyStatus = {
	[TFA.Enum.SHOOT_IDLE] = true,
	[TFA.Enum.SHOOT_END] = true
}

TFA.Enum.ShootLoopingStatus = {
	[TFA.Enum.SHOOT_START] = true,
	[TFA.Enum.SHOOT_LOOP] = true,
	[TFA.Enum.SHOOT_CHECK] = true
}

--addons/tfa_base/lua/tfa/modules/tfa_envcheck.lua:
local EmptyFunc = function() end

local debugInfoTbl = debug.getinfo(EmptyFunc)

local cv_do_check = CreateConVar("sv_tfa_envcheck", "1", {FCVAR_ARCHIVE, FCVAR_NOTIFY, FCVAR_REPLICATED}, "Enable environment sanity checks and warnings?")

local function checkEnv(plyIn)
	if not cv_do_check:GetBool() then return end

	local function printFunc(msg, ...)
		msg = "[TFA Base] " .. msg

		if chat and chat.AddText then
			return chat.AddText(msg, ...)
		end

		return print(msg, ...)
	end

	if game.SinglePlayer() then
		if CLIENT then
			local found = false
			for _, wepDefTable in ipairs(weapons.GetList()) do
				if wepDefTable.Spawnable and weapons.IsBasedOn(wepDefTable.ClassName, "tfa_gun_base") then
					found = true

					break
				end
			end

			if not found then
				printFunc("Thank you for installing our weapons base! It appears that you have installed only the base itself, which does not include any weapons by default. Please install some weapons/packs that utilize TFA Base for full experience!")
			end
		end

		local shortsrc = debugInfoTbl.short_src

		if shortsrc:StartWith("addons") then -- legacy/unpacked addon
			local addonRootFolder = shortsrc:GetPathFromFilename():Replace("lua/tfa/modules/", "")

			if not file.Exists(addonRootFolder .. ".git", "GAME") then -- assume unpacked version by missing .git folder, which is ignored by gmad.exe
				printFunc("You are using unpacked version of TFA Base.\nWe only provide support for Steam Workshop version.")
			end
		end
	else
		local activeGamemode = engine.ActiveGamemode()
		local isRP = activeGamemode:find("rp")
				or activeGamemode:find("roleplay")
				or activeGamemode:find("serious")

		if isRP and (SERVER or (IsValid(plyIn) and (plyIn:IsAdmin() or plyIn:IsSuperAdmin()))) then
			print("You are running the base on DarkRP or DarkRP-derived gamemode. We can't guarantee that it will work correctly with any possible addons the server might have installed (especially the paid ones), so we don't provide support for RP gamemodes/servers. If you've encountered a conflict error with another addon, it's most likely that addon's fault. DO NOT CONTACT US ABOUT THAT!")
		end
	end

	timer.Simple(0, function()
		if not TFA.BASE_LOAD_COMPLETE or not TFA.SWEP_LOAD_COMPLETE then
			printFunc("Some of the base's modules have failed to load. You are probably going over Lua files limit. Try disabling some addons until you stop getting this error.")
		end
	end)
end

if CLIENT then
	hook.Add("HUDPaint", "TFA_CheckEnv", function()
		local ply = LocalPlayer()

		if not IsValid(ply) then return end

		hook.Remove("HUDPaint", "TFA_CheckEnv")

		checkEnv(ply)
	end)
else
	resource.AddWorkshop("2840031720")

	hook.Add("InitPostEntity", "TFA_CheckEnv", checkEnv)
end

--addons/tfa_base/lua/tfa/ballistics/bullet.lua:
local vector_origin = Vector()

--[[Bullet Struct:
[BULLET_ID] = {
	["owner"] = Entity, --used for dmginfo SetAttacker
	["inflictor"] = Entity, --used for dmginfo SetInflictor
	["damage"] = Double, --floating point number representing inflicted damage
	["force"] = Double,
	["pos"] = Vector, --vector representing current position
	["velocity"] = Vector, --vector representing movement velocity
	["model"] = String --optional variable representing the given model,
	["bul"] = {} --optional table containing bullet data,
	["smokeparticle"] = String, --smoke particle name from within pcf
	["bulletOverride"] = Bool --disable coming out of gun barrel on clientside
}
]]
local BallisticBullet = {
	["owner"] = NULL,
	["inflictor"] = NULL,
	["damage"] = 0,
	["force"] = 0,
	["pos"] = vector_origin,
	["velocity"] = vector_origin,
	["model"] = "models/bullets/w_pbullet1.mdl",
	["bul"] = {},
	["delete"] = false,
	["smokeparticle"] = "tfa_bullet_smoke_tracer"
}

local traceRes = {}

local traceData = {
	mask = MASK_SHOT,
	collisiongroup = COLLISION_GROUP_NONE,
	ignoreworld = false,
	output = traceRes
}

local MASK_SHOT_NOWATER = MASK_SHOT

--main update block
function BallisticBullet:Update(delta)
	if self.delete then return end
	self:_setup()
	if self.delete then return end

	local realdelta = (delta - self.last_update) / TFA.Ballistics.SubSteps
	self.last_update = delta

	local newPos = self:_getnewPosition(realdelta)
	newPos = self:_checkWater(realdelta, newPos)
	self:_accelerate(realdelta)
	self:_moveSafe(newPos)
end

--internal function for sanity checks, etc.
function BallisticBullet:_setup()
	self.creationTime = CurTime()

	if (not IsValid(self.owner)) or (not IsValid(self.inflictor)) then
		self:Remove()
	end

	if CurTime() > self.creationTime + TFA.Ballistics.BulletLife then
		self:Remove()
	end

	self.playerOwned = self.owner.IsPlayer and self.owner:IsPlayer()
	self.startVelocity = self.velocity:Length()
	self.startDamage = self.damage
end

function BallisticBullet:_think()
	if (not IsValid(self.owner)) or (not IsValid(self.inflictor)) then
		self:Remove()
	end

	if CurTime() > self.creationTime + TFA.Ballistics.BulletLife then
		self:Remove()
	end
end

--internal function for calculating position change
function BallisticBullet:_getnewPosition(delta)
	--verlet
	return self.pos + (self.velocity + TFA.Ballistics.Gravity * delta * 0.5) * delta
end

--internal function for handling water
function BallisticBullet:_checkWater(delta, target)
	local newPos = target
	traceData.start = self.pos
	traceData.endpos = newPos
	traceData.filter = {self.owner, self.inflictor}
	traceData.mask = MASK_WATER
	util.TraceLine(traceData)

	if traceRes.Hit and traceRes.Fraction < 1 and traceRes.Fraction > 0 and not self.Underwater then
		self.Underwater = true
		newPos = traceRes.HitPos + traceRes.Normal
		self.velocity = self.velocity / TFA.Ballistics.WaterEntranceResistance
		local fx = EffectData()
		fx:SetOrigin(newPos)
		local sc = math.sqrt(self.damage / 28) * 6
		fx:SetScale(sc)
		util.Effect("gunshotsplash", fx)
	end

	return newPos
end

--internal function for handling acceleration
local function GetWind()
	return vector_origin
end

if StormFox and StormFox.Version then
	if StormFox.Version < 2 then -- SF1
		local SF_GetNetworkData = StormFox.GetNetworkData

		function GetWind()
			local windSpeed = SF_GetNetworkData("Wind") * TFA.Ballistics.UnitScale
			local windAng = Angle(0, SF_GetNetworkData("WindAngle"), 0)

			return windSpeed * windAng:Forward():GetNormalized()
		end
	elseif StormFox.Wind then -- SF2
		local SFW_GetForce = StormFox.Wind.GetForce
		local SFW_GetYaw = StormFox.Wind.GetYaw

		function GetWind()
			local windSpeed = SFW_GetForce() * TFA.Ballistics.UnitScale
			local windAng = Angle(0, SFW_GetYaw(), 0)

			return windSpeed * windAng:Forward():GetNormalized()
		end
	end
end

function BallisticBullet:_accelerate(delta)
	local dragDensity = self.Underwater and TFA.Ballistics.WaterResistance or TFA.Ballistics.AirResistance
	local drag = -self.velocity:GetNormalized() * self.velocity:Length() * self.velocity:Length() * 0.00006 * dragDensity
	local wind = GetWind()

	if self.Underwater then
		self.velocity = self.velocity / (1 + TFA.Ballistics.WaterResistance * delta)
	end

	self.velocity = self.velocity + (TFA.Ballistics.Gravity + drag + wind) * delta
	self.damage = self.startDamage * math.sqrt(self.velocity:Length() / self.startVelocity)
end

local IsInWorld, IsInWorld2

do
	local tr = {collisiongroup = COLLISION_GROUP_WORLD}

	function IsInWorld2(pos)
		tr.start = pos
		tr.endpos = pos
		return not util.TraceLine(tr).AllSolid
	end
end

if CLIENT then
	IsInWorld = IsInWorld2
else
	IsInWorld = util.IsInWorld
end

--internal function for moving with collision test
function BallisticBullet:_moveSafe(newPos)
	if not self.tr_filter then
		if IsValid(self.IgnoreEntity) then
			self.tr_filter = {self.owner, self.inflictor, self.IgnoreEntity}
		else
			self.tr_filter = {self.owner, self.inflictor}
		end
	end

	traceData.start = self.pos
	traceData.endpos = newPos + (newPos - self.pos):GetNormalized()
	traceData.filter = self.tr_filter
	traceData.mask = MASK_SHOT_NOWATER

	--collision trace
	if self.playerOwned then
		self.owner:LagCompensation(true)
	end

	util.TraceLine(traceData)

	if self.playerOwned then
		self.owner:LagCompensation(false)
	end

	--collision check
	if traceRes.Hit and traceRes.Fraction < 1 and traceRes.Fraction > 0 then
		self:Impact(traceRes)
	elseif IsInWorld(newPos) then
		self.pos = newPos
	else
		self:Remove()
	end
end

--called when hitting something, or manually if necessary
function BallisticBullet:Impact(tr)
	self.pos = tr.HitPos
	self:Remove()

	if CLIENT and (game.SinglePlayer() or self.owner ~= LocalPlayer()) then return end

	if tr.HitSky then return end
	local vn = self.velocity:GetNormalized()

	local bul = {
		["Damage"] = self.damage,
		["Force"] = self.force,
		["Num"] = 1,
		["Src"] = self.pos - vn * 4,
		["Dir"] = vn * 8,
		["Spread"] = vector_origin,
		["IgnoreEntity"] = self.owner,
		["Attacker"] = self.owner,
		["Distance"] = 8,
		["Tracer"] = 0
	}

	setmetatable(bul, {
		["__index"] = self.bul
	})

	self.owner:FireBullets(bul)
end

--Render
--local cv_bullet_style, cv_tracers_adv
local cv_bullet_style

if CLIENT then
	CreateClientConVar("cl_tfa_ballistics_mp", "1", true, false, "Receive bullet data from other players?")
	cv_bullet_style = CreateClientConVar("cl_tfa_ballistics_fx_bullet", "1", true, false, "Display bullet models for each TFA ballistics bullet?")
	CreateClientConVar("cl_tfa_ballistics_fx_tracers_style", "1", true, false, "Style of tracers for TFA ballistics? 0=disable,1=smoke")
	CreateClientConVar("cl_tfa_ballistics_fx_tracers_mp", "1", true, false, "Enable tracers for other TFA ballistics users?")
	--cv_tracers_adv = CreateClientConVar("cl_tfa_ballistics_fx_tracers_adv", "1", true, false, "Enable advanced tracer calculations for other users? This corrects smoke trail to their barrel")
	--[[
	cv_receive = GetConVar("cl_tfa_ballistics_mp")
	cv_bullet_style = GetConVar("cl_tfa_ballistics_fx_bullet")
	cv_tracers_style = GetConVar("cl_tfa_ballistics_fx_tracers_style")
	cv_tracers_mp = GetConVar("cl_tfa_ballistics_fx_tracers_mp")
	cv_tracers_adv = GetConVar("cl_tfa_ballistics_fx_tracers_adv")
	]]
	--
end

--[[local DEFANGPOS = {
	Pos = vector_origin,
	Ang = angle_zero
}]]

function BallisticBullet:Render()
	if SERVER then return end
	if self.delete then return end

	if not self.curmodel then
		self.curmodel = ClientsideModel(self.model, RENDERGROUP_OPAQUE)
		self.curmodel:SetNoDraw(not cv_bullet_style:GetBool())
	end

	--[==[if IsValid(self.curmodel) and (cv_bullet_style:GetBool() or self.smokeparticle ~= "") then
		if self.customPosition then
			fpos = self.pos
			--fang = self.velocity:Angle()
		else
			if self.owner == GetViewEntity() or self.owner == LocalPlayer() then
				local spos, sang = self.pos, self.velocity:Angle()
				self.curmodel:SetPos(spos)
				self.curmodel:SetAngles(sang)

				if not self.vOffsetPos then
					local att

					if self.inflictor.GetMuzzleAttachment and self.inflictor:GetMuzzleAttachment() then
						att = self.inflictor:GetMuzzleAttachment()
					else
						att = self.inflictor.MuzzleAttachmentRaw or 1
					end

					if LocalPlayer():ShouldDrawLocalPlayer() then
						local npos = LocalPlayer():GetActiveWeapon():GetAttachment(att) or DEFANGPOS
						self.vOffsetPos = self.curmodel:WorldToLocal(npos.Pos)
						self.vOffsetAng = self.curmodel:WorldToLocalAngles(npos.Ang)
					else
						local npos = LocalPlayer():GetViewModel():GetAttachment(att) or DEFANGPOS
						self.vOffsetPos = self.curmodel:WorldToLocal(npos.Pos)
						self.vOffsetAng = self.curmodel:WorldToLocalAngles(npos.Ang)
					end
				end

				fpos = self.curmodel:LocalToWorld(self.vOffsetPos)
				--fang = self.curmodel:LocalToWorldAngles(self.vOffsetAng)
			elseif self.owner:IsPlayer() and cv_tracers_adv:GetBool() then
				local spos, sang = self.pos, self.velocity:Angle()
				self.curmodel:SetPos(spos)
				self.curmodel:SetAngles(sang)

				if not self.vOffsetPos then
					local npos = self.owner:GetActiveWeapon():GetAttachment(1) or DEFANGPOS
					self.vOffsetPos = self.curmodel:WorldToLocal(npos.Pos)
					self.vOffsetAng = self.curmodel:WorldToLocalAngles(npos.Ang)
				end

				fpos = self.curmodel:LocalToWorld(self.vOffsetPos)
				--fang = self.curmodel:LocalToWorldAngles(self.vOffsetAng)
			else
				fpos = self.pos
				--fang = self.velocity:Angle()
			end
		end

		--[[if cv_bullet_style:GetBool() then
			self.curmodel:SetupBones()
			self.curmodel:DrawModel()
		end]]
	end]==]

	local fpos, fang = self.pos, self.velocity:Angle()

	self.curmodel:SetPos(fpos)
	self.curmodel:SetAngles(fang)

	if self.smokeparticle ~= "" and not self.cursmoke then
		self.cursmoke = CreateParticleSystem(self.curmodel, self.smokeparticle, PATTACH_ABSORIGIN_FOLLOW, 1)
		if not self.cursmoke then return end
		self.cursmoke:StartEmission()
	elseif self.cursmoke and IsValid(self.owner) then
		self.cursmoke:SetSortOrigin(self.owner.GetShootPos and self.owner:GetShootPos() or self.owner.EyePos and self.owner:EyePos() or vector_origin)

		if self.Underwater then
			self.cursmoke:StopEmission()
			self.cursmoke = nil
			self.smokeparticle = ""
		end
	end
end

function BallisticBullet:Remove()
	if self.cursmoke then
		self.cursmoke:StopEmission()
		self.cursmoke = nil
	end

	if self.curmodel and self.curmodel.Remove then
		self.curmodel:Remove()
		self.curmodel = nil
	end

	self.delete = true
end

local CopyTable = table.Copy

function TFA.Ballistics:Bullet(t)
	local b = CopyTable(t or {})

	setmetatable(b, {
		["__index"] = BallisticBullet
	})

	return b
end
--addons/tfa_base/lua/tfa/modules/tfa_bodygroups.lua:
local sp = game.SinglePlayer()

hook.Add("PlayerSwitchWeapon", "TFA_Bodygroups_PSW", function(ply, oldwep, wep)
	if not IsValid(wep) or not wep.IsTFAWeapon then return end

	timer.Simple(0, function()
		if not IsValid(ply) or ply:GetActiveWeapon() ~= wep then return end

		wep:ApplyViewModelModifications()

		if sp then
			wep:CallOnClient("ApplyViewModelModifications")
		end
	end)
end)

--addons/tfa_base/lua/tfa/modules/tfa_darkrp.lua:
local TFA_PocketBlock = {}
TFA_PocketBlock["tfa_ammo_357"] = true
TFA_PocketBlock["tfa_ammo_ar2"] = true
TFA_PocketBlock["tfa_ammo_buckshot"] = true
TFA_PocketBlock["tfa_ammo_c4"] = true
TFA_PocketBlock["tfa_ammo_frags"] = true
TFA_PocketBlock["tfa_ammo_ieds"] = true
TFA_PocketBlock["tfa_ammo_nervegas"] = true
TFA_PocketBlock["tfa_ammo_nuke"] = true
TFA_PocketBlock["tfa_ammo_pistol"] = true
TFA_PocketBlock["tfa_ammo_proxmines"] = true
TFA_PocketBlock["tfa_ammo_rockets"] = true
TFA_PocketBlock["tfa_ammo_smg"] = true
TFA_PocketBlock["tfa_ammo_smg1_grenade"] = true
TFA_PocketBlock["tfa_ammo_smg1_grenade_large"] = true
TFA_PocketBlock["tfa_ammo_sniper_rounds"] = true
TFA_PocketBlock["tfa_ammo_stickynades"] = true
TFA_PocketBlock["tfa_ammo_winchester"] = true

local function TFA_PockBlock(ply, wep) --Get it, because cockblock, hehe.....  so mature.
	if not IsValid(wep) then return end
	local class = wep:GetClass()
	if TFA_PocketBlock[class] then return false end
end

hook.Add("canPocket", "TFA_PockBlock", TFA_PockBlock)

--addons/tfa_base/lua/tfa/modules/tfa_hooks.lua:
local TFA = TFA

TFA.INSPECTION_IMPULSE = 148
TFA.BASH_IMPULSE = 149
TFA.CYCLE_FIREMODE_IMPULSE = 150
TFA.CYCLE_SAFETY_IMPULSE = 151

TFA.INSPECTION_IMPULSE_STRING = "148"
TFA.BASH_IMPULSE_STRING = "149"
TFA.CYCLE_FIREMODE_IMPULSE_STRING = "150"
TFA.CYCLE_SAFETY_IMPULSE_STRING = "151"

local sp = game.SinglePlayer()
local CurTime = CurTime

local ENTITY = FindMetaTable("Entity")
local PLAYER = FindMetaTable("Player")

--[[
Hook: PlayerPostThink
Function: Weapon Logic
Used For: Main weapon "think" logic
]]
--
if CLIENT and sp then
	local engine_TickCount = engine.TickCount

	hook.Add("PlayerPostThink", "PlayerTickTFA", function(plyv)
		local wepv = PLAYER.GetActiveWeapon(plyv)
		if not IsValid(wepv) then return end
		local wep2 = ENTITY.GetTable(wepv)

		if wep2.IsTFAWeapon then
			local ply2 = PLAYER.GetTable(plyv)

			local tickCount = engine_TickCount()
			wep2.PlayerThink(wepv, plyv, ply2.last_tfa_think == tickCount)
			ply2.last_tfa_think = tickCount
		end
	end)
end

if SERVER or not sp then
	local IsFirstTimePredicted = IsFirstTimePredicted

	hook.Add("FinishMove", "PlayerTickTFA", function(plyv)
		local wepv = PLAYER.GetActiveWeapon(plyv)
		if not IsValid(wepv) then return end
		local wep2 = ENTITY.GetTable(wepv)

		if wep2.IsTFAWeapon then
			wep2.PlayerThink(wepv, plyv, not IsFirstTimePredicted())
		end
	end)
end

--[[
Hook: Think
Function: Weapon Logic for NPC
User For: Calling SWEP:Think for NPCs manually
]]
--
if SERVER then
	hook.Add("Think", "NPCTickTFA", function()
		hook.Run("TFA_NPCWeaponThink")
	end)
end

--[[
Hook: Tick
Function: Inspection mouse support
Used For: Enables and disables screen clicker
]]
--
if CLIENT then
	local tfablurintensity
	local its_old = 0
	local ScreenClicker = false
	local cl_tfa_inspect_hide = GetConVar("cl_tfa_inspect_hide")
	local cl_drawhud = GetConVar("cl_drawhud")

	hook.Add("Tick", "TFAInspectionScreenClicker", function()
		tfablurintensity = 0

		if LocalPlayer():IsValid() and LocalPlayer():GetActiveWeapon():IsValid() then
			local w = LocalPlayer():GetActiveWeapon()

			if w.IsTFAWeapon then
				tfablurintensity = w:GetCustomizing() and 1 or 0
			end
		end

		if tfablurintensity > its_old and not ScreenClicker and not cl_tfa_inspect_hide:GetBool() and cl_drawhud:GetBool() then
			gui.EnableScreenClicker(true)
			ScreenClicker = true
		elseif tfablurintensity < its_old and ScreenClicker then
			gui.EnableScreenClicker(false)
			ScreenClicker = false
		end

		its_old = tfablurintensity
	end)

	local engine_TickCount = engine.TickCount
	local tickInterval = engine.TickInterval()
	local FrameTime = FrameTime
	local math_Clamp = math.Clamp

	TFA.TickDeltaLastTick = TFA.TickDeltaLastTick or engine_TickCount() - 1
	TFA.TickDelta = 0

	hook.Add("Think", "TFABase_PlayerThinkCL", function()
		TFA.TickDelta = math_Clamp(TFA.TickDelta + FrameTime() / tickInterval, 0, 1)

		local tcount = engine_TickCount()
		if TFA.TickDeltaLastTick ~= tcount then
			TFA.TickDeltaLastTick = tcount
			TFA.TickDelta = 0
		end

		local ply = LocalPlayer()
		if not IsValid(ply) then return end

		local weapon = ply:GetActiveWeapon()

		if IsValid(weapon) and weapon.IsTFAWeapon and weapon.PlayerThinkCL then
			weapon:PlayerThinkCL(ply)
		end
	end)
end

if CLIENT and sp then
	local lastSDLP

	local function SyncSDLP()
		local ply = LocalPlayer()
		if not IsValid(ply) then return end

		local SDLP = ply:ShouldDrawLocalPlayer()
		if lastSDLP == nil or lastSDLP ~= SDLP then
			net.Start("tfaSDLP", true)
			net.WriteBool(SDLP)
			net.SendToServer()

			lastSDLP = SDLP
		end
	end

	hook.Add("Think", "TFABase_ShouldDrawLocalPlayer", SyncSDLP)
end

--[[
Hook: AllowPlayerPickup
Function: Prop holding
Used For: Records last held object
]]
--
hook.Add("AllowPlayerPickup", "TFAPickupDisable", function(plyv, ent)
	plyv:SetNW2Entity("LastHeldEntity", ent)
end)

--[[
Hook: PlayerBindPress
Function: Intercept Keybinds
Used For:  Alternate attack, inspection, shotgun interrupts, and more
]]
--
local cv_cm = GetConVar("sv_tfa_cmenu")
local cv_cm_key = GetConVar("sv_tfa_cmenu_key")
local keyv

local function GetInspectionKey()
	if cv_cm_key and cv_cm_key:GetInt() >= 0 then
		keyv = cv_cm_key:GetInt()
	else
		keyv = TFA.BindToKey(input.LookupBinding("+menu_context", true) or "c", KEY_C)
	end

	return keyv
end

local function TFAContextBlock()
	local plyv = LocalPlayer()

	if not plyv:IsValid() or GetViewEntity() ~= plyv then return end

	if plyv:InVehicle() and not plyv:GetAllowWeaponsInVehicle() then return end

	local wepv = plyv:GetActiveWeapon()
	if not IsValid(wepv) then return end

	if plyv:GetInfoNum("cl_tfa_keys_customize", 0) > 0 then return end

	if GetInspectionKey() == TFA.BindToKey(input.LookupBinding("+menu_context", true) or "c", KEY_C) and wepv.ToggleInspect and cv_cm:GetBool() and not plyv:KeyDown(IN_USE) then return false end
end

hook.Add("ContextMenuOpen", "TFAContextBlock", TFAContextBlock)

if CLIENT then
	local kd_old = false

	local cl_tfa_keys_customize

	local function TFAKPThink()
		local plyv = LocalPlayer()
		if not plyv:IsValid() then return end
		local wepv = plyv:GetActiveWeapon()
		if not IsValid(wepv) then return end

		if not cl_tfa_keys_customize then
			cl_tfa_keys_customize = GetConVar("cl_tfa_keys_customize")
		end

		if cl_tfa_keys_customize:GetBool() then return end

		local key = GetInspectionKey()
		local kd = input.IsKeyDown(key)

		if IsValid(vgui.GetKeyboardFocus()) then
			kd = false
		end

		if kd ~= kd_old and kd and cv_cm:GetBool() and not plyv:KeyDown(IN_USE) then
			RunConsoleCommand("impulse", tostring(TFA.INSPECTION_IMPULSE))
		end

		kd_old = kd
	end

	hook.Add("Think", "TFAInspectionMenu", TFAKPThink)
end

local cv_lr = GetConVar("sv_tfa_reloads_legacy")
local reload_threshold = 0.3

local sv_cheats = GetConVar("sv_cheats")
local host_timescale = GetConVar("host_timescale")

local band = bit.band
local bxor = bit.bxor
local bnot = bit.bnot
local GetTimeScale = game.GetTimeScale
local IN_ATTACK2 = IN_ATTACK2
local IN_RELOAD = IN_RELOAD

local function FinishMove(ply, cmovedata)
	if ply:InVehicle() and not ply:GetAllowWeaponsInVehicle() then return end

	local wepv = ply:GetActiveWeapon()
	if not IsValid(wepv) or not wepv.IsTFAWeapon then return end

	wepv:TFAFinishMove(ply, cmovedata:GetVelocity(), cmovedata)

	local impulse = cmovedata:GetImpulseCommand()

	if impulse == TFA.INSPECTION_IMPULSE then
		wepv:ToggleInspect()
	elseif impulse == TFA.CYCLE_FIREMODE_IMPULSE and wepv:GetStatus() == TFA.Enum.STATUS_IDLE and wepv:GetStatL("SelectiveFire") then
		wepv:CycleFireMode()
	elseif impulse == TFA.CYCLE_SAFETY_IMPULSE and wepv:GetStatus() == TFA.Enum.STATUS_IDLE then
		wepv:CycleSafety()
	end

	local BashImpulse = cmovedata:GetImpulseCommand() == TFA.BASH_IMPULSE
	ply:TFA_SetZoomKeyDown(BashImpulse) -- this may or may not work

	if wepv.SetBashImpulse then
		wepv:SetBashImpulse(BashImpulse)
	end

	if cmovedata:GetImpulseCommand() == 100 and (wepv:GetStatL("FlashlightAttachmentName") ~= nil or wepv:GetStatL("FlashlightAttachment", 0) > 0) then
		wepv:ToggleFlashlight()
	end

	local lastButtons = wepv:GetDownButtons()
	local buttons = cmovedata:GetButtons()
	local stillPressed = band(lastButtons, buttons)
	local changed = bxor(lastButtons, buttons)
	local pressed = band(changed, bnot(lastButtons), buttons)
	local depressed = band(changed, lastButtons, bnot(buttons))

	wepv:SetDownButtons(buttons)
	wepv:SetLastPressedButtons(pressed)

	local time = CurTime()

	local cl_tfa_ironsights_toggle = (ply:GetInfoNum("cl_tfa_ironsights_toggle", 0) or 0) >= 1
	local cl_tfa_ironsights_resight = (ply:GetInfoNum("cl_tfa_ironsights_resight", 0) or 0) >= 1
	local cl_tfa_ironsights_responsive = (ply:GetInfoNum("cl_tfa_ironsights_responsive", 0) or 0) >= 1
	local cl_tfa_ironsights_responsive_timer = ply:GetInfoNum("cl_tfa_ironsights_responsive_timer", 0.175) or 0.175

	local scale_dividier = GetTimeScale() * (sv_cheats:GetBool() and host_timescale:GetFloat() or 1)

	if wepv:GetStatL("Secondary.IronSightsEnabled", false) and not wepv:IsSafety() then
		if band(changed, IN_ATTACK2) == IN_ATTACK2 then
			local deltaPress = (time - wepv:GetLastIronSightsPressed()) / scale_dividier

			-- pressing for first time
			if not wepv:GetIronSightsRaw() and band(pressed, IN_ATTACK2) == IN_ATTACK2 then
				wepv:SetIronSightsRaw(true)
				wepv:SetLastIronSightsPressed(time)
			elseif wepv:GetIronSightsRaw() and
				((cl_tfa_ironsights_toggle or cl_tfa_ironsights_responsive) and band(pressed, IN_ATTACK2) == IN_ATTACK2 or
				not cl_tfa_ironsights_toggle and not cl_tfa_ironsights_responsive and band(depressed, IN_ATTACK2) == IN_ATTACK2)
			then
				-- get out of iron sights
				wepv:SetIronSightsRaw(false)
				wepv:SetLastIronSightsPressed(-1)
			elseif wepv:GetIronSightsRaw() and cl_tfa_ironsights_responsive and band(depressed, IN_ATTACK2) == IN_ATTACK2 and deltaPress > cl_tfa_ironsights_responsive_timer then
				-- we depressed IN_ATTACK2 with it were being held down
				wepv:SetIronSightsRaw(false)
				wepv:SetLastIronSightsPressed(-1)
			end
		elseif wepv:GetIronSightsRaw() and not cl_tfa_ironsights_resight and (not TFA.Enum.IronStatus[wepv:GetStatus()] or wepv:GetSprinting()) then
			wepv:SetIronSightsRaw(false)
			wepv:SetLastIronSightsPressed(-1)
		end
	end

	if
		band(depressed, IN_RELOAD) == IN_RELOAD and
		not cv_lr:GetBool()
		and band(buttons, IN_USE) == 0
		and time <= (wepv:GetLastReloadPressed() + reload_threshold * scale_dividier)
	then
		wepv:SetLastReloadPressed(-1)
		wepv:Reload(true)
	elseif band(pressed, IN_RELOAD) == IN_RELOAD then
		wepv:SetLastReloadPressed(time)
	elseif band(buttons, IN_RELOAD) ~= 0 and band(buttons, IN_USE) == 0 and time > (wepv:GetLastReloadPressed() + reload_threshold * scale_dividier) then
		wepv:CheckAmmo()
	end

	if BashImpulse then
		if wepv.AltAttack then
			wepv:AltAttack()
		end
	end
end

hook.Add("FinishMove", "TFAFinishMove", FinishMove)

local function TFABashZoom(plyv, cusercmd)
	if plyv:InVehicle() and not plyv:GetAllowWeaponsInVehicle() then return end

	if plyv:GetInfoNum("cl_tfa_keys_bash", 0) ~= 0 then
		if (sp or CLIENT) and plyv.tfa_bash_hack then
			cusercmd:SetImpulse(TFA.BASH_IMPULSE)
		end

		return
	end

	local zoom = cusercmd:KeyDown(IN_ZOOM)

	if zoom then
		local wepv = plyv:GetActiveWeapon()

		if IsValid(wepv) and wepv.IsTFAWeapon and wepv.AltAttack then
			cusercmd:RemoveKey(IN_ZOOM)
			cusercmd:SetImpulse(TFA.BASH_IMPULSE)
		end
	end
end

hook.Add("StartCommand", "TFABashZoom", TFABashZoom)

--[[
Hook: PlayerSpawn
Function: Extinguishes players, zoom cleanup
Used For:  Fixes incendiary bullets post-respawn
]]
--
hook.Add("PlayerSpawn", "TFAExtinguishQOL", function(plyv)
	if IsValid(plyv) and plyv:IsOnFire() then
		plyv:Extinguish()
	end
end)

local sv_tfa_weapon_weight = GetConVar("sv_tfa_weapon_weight")

--[[
Hook: SetupMove
Function: Modify movement speed
Used For:  Weapon slowdown, ironsights slowdown
]]
--
hook.Add("SetupMove", "tfa_setupmove", function(plyv, movedata, commanddata)
	local wepv = plyv:GetActiveWeapon()

	if IsValid(wepv) and wepv.IsTFAWeapon and sv_tfa_weapon_weight:GetBool() then
		local speedmult = Lerp(wepv:GetIronSightsProgress(), wepv:GetStatL("RegularMoveSpeedMultiplier", 1), wepv:GetStatL("AimingDownSightsSpeedMultiplier", 1))
		movedata:SetMaxClientSpeed(movedata:GetMaxClientSpeed() * speedmult)
		commanddata:SetForwardMove(commanddata:GetForwardMove() * speedmult)
		commanddata:SetSideMove(commanddata:GetSideMove() * speedmult)
	end
end)

--[[
Hook: InitPostEntity
Function: Patches or removes other hooks that breaking or changing behavior of our weapons in a negative way
Used For: Fixing our stuff
]]
--

local function FixInvalidPMHook()
	if not CLIENT then return end

	local hookTable = hook.GetTable()

	if hookTable["PostDrawViewModel"] and hookTable["PostDrawViewModel"]["Set player hand skin"] then
		local targetFunc = hookTable["PostDrawViewModel"]["Set player hand skin"]
		if not targetFunc then return end

		local cv_shouldfix = GetConVar("cl_tfa_fix_pmhands_hook") or CreateClientConVar("cl_tfa_fix_pmhands_hook", "1", true, false, "Fix hands skin hook for CaptainBigButt's (and others) playermodels (Change requires map restart)")

		if not cv_shouldfix:GetBool() then return end

		print("[TFA Base] The playermodels you have installed breaks the automatic rig parenting for Insurgency and CS:GO weapons. The fix is applied but it's more of a band-aid, the solution would be to either fix this properly on author's side or to uninstall the addon.")

		if CLIENT and debug and debug.getinfo then
			local funcPath = debug.getinfo(targetFunc).short_src

			print("Type whereis " .. funcPath .. " in console to see the conflicting addon.")
		end

		hook.Remove("PostDrawViewModel", "Set player hand skin")
		hook.Add("PreDrawPlayerHands", "Set player hand skin BUT FIXED", function(hands, vm, ply, weapon)
			if hands:SkinCount() == ply:SkinCount() then
				hands:SetSkin(ply:GetSkin())
			end
		end)
	end
end

local function PatchSiminovSniperHook()
	if not CLIENT then return end -- that hook is clientside only

	local hookTable = hook.GetTable()

	if hookTable["CreateMove"] and hookTable["CreateMove"]["SniperCreateMove"] then
		local SniperCreateMove = hookTable["CreateMove"]["SniperCreateMove"] -- getting the original function
		if not SniperCreateMove then return end

		local cv_shouldfix = GetConVar("cl_tfa_fix_siminov_scopes") or CreateClientConVar("cl_tfa_fix_siminov_scopes", "1", true, false, "Patch Siminov's sniper overlay hook with weapon base check (Change requires map restart)")

		if not cv_shouldfix:GetBool() then return end

		local PatchedSniperCreateMove = function(cmd) -- wrapping their function with our check
			local ply = LocalPlayer()

			if IsValid(ply) and IsValid(ply:GetActiveWeapon()) and ply:GetActiveWeapon().IsTFAWeapon then
				return
			end

			SniperCreateMove(cmd)
		end

		hook.Remove("CreateMove", "SniperCreateMove") -- removing original hook
		hook.Add("CreateMove", "SniperCreateMove_PatchedByTFABase", PatchedSniperCreateMove) -- creating new hook with wrap
	end
end

hook.Add("InitPostEntity", "tfa_unfuckeverything", function()
	FixInvalidPMHook()
	PatchSiminovSniperHook()
end)

--[[
Hook: PlayerSwitchFlashlight
Function: Flashlight toggle
Used For: Switching flashlight on weapon and blocking HEV flashlight
]]
--
hook.Add("PlayerSwitchFlashlight", "tfa_toggleflashlight", function(plyv, toEnable)
	if CLIENT then return end -- this is serverside hook GO AWAY
	-- fuck you source
	-- where is fucking prediction??!??!?!?/

	if not IsValid(plyv) or not toEnable then return end -- allow disabling HEV flashlight

	local wepv = plyv:GetActiveWeapon()

	if IsValid(wepv) and wepv.IsTFAWeapon and (wepv:GetStatL("FlashlightAttachmentName") ~= nil or wepv:GetStatL("FlashlightAttachment", 0) > 0) then
		-- wepv:ToggleFlashlight()

		return false
	end
end)

--[[
Hook: SetupMove
Function: Update players NW2 variable
Used For: Walking animation NW2 var
]]
--
hook.Add("SetupMove", "tfa_checkforplayerwalking", function(plyv, mvdatav, cmdv)
	if not IsValid(plyv) or not mvdatav then return end

	if mvdatav:GetForwardSpeed() ~= 0 or mvdatav:GetSideSpeed() ~= 0 then
		if not plyv:GetNW2Bool("TFA_IsWalking") then
			plyv:SetNW2Bool("TFA_IsWalking", true)
		end
	elseif plyv:GetNW2Bool("TFA_IsWalking") then
		plyv:SetNW2Bool("TFA_IsWalking", false)
	end
end)

--[[
Hook: PreDrawOpaqueRenderables
Function: Calls SWEP:PreDrawOpaqueRenderables()
Used For: whatever draw stuff you need lol
]]
--
hook.Add("PreDrawOpaqueRenderables", "tfaweaponspredrawopaque", function()
	for _, v in ipairs(player.GetAll()) do
		local wepv = v:GetActiveWeapon()

		if IsValid(wepv) and wepv.IsTFAWeapon and wepv.PreDrawOpaqueRenderables then
			wepv:PreDrawOpaqueRenderables()
		end
	end
end)

--[[
Hook: PreDrawViewModel
Function: Calculating viewmodel offsets
Used For: Viewmodel sway, offset and flip
]]
--
if CLIENT then
	local vec = Vector()
	local ang = Angle()

	local IsGameUIVisible = gui and gui.IsGameUIVisible

	local FrameTime = FrameTime
	local FrameNumber = FrameNumber
	local lastframe = FrameNumber() - 1
	hook.Add("PreDrawViewModel", "TFACalculateViewmodel", function(vm, plyv, wepv)
		if lastframe == FrameNumber() then return end
		lastframe = FrameNumber()

		if not IsValid(wepv) or not wepv.IsTFAWeapon then return end
		local wep2 = wepv:GetTable()

		if sp and IsGameUIVisible and IsGameUIVisible() then return end

		wep2.UpdateEngineBob(wepv)

		local delta = FrameTime()

		wep2.Sway(wepv, vec, ang, delta)
		wep2.CalculateViewModelOffset(wepv, delta)
		wep2.CalculateViewModelFlip(wepv)

		wep2.UpdateProjectedTextures(wepv, true)
	end)
end

--[[
Hook: EntityTakeDamage
Function: Applies physics damage to Combine Turrets
Used For: Knocking up Combine Turrets with TFA Base weapons
]]
--
hook.Add("EntityTakeDamage", "TFA_TurretPhysics", function(entv, dmg)
	if entv:GetClass() == "npc_turret_floor" then
		entv:TakePhysicsDamage(dmg)
	end
end)

--[[
Hook: HUDPaint
Function: Calls another hook
Used For: Hook that notifies when player is fully loaded.
]]
--
hook.Add("HUDPaint", "TFA_TRIGGERCLIENTLOAD", function()
	if LocalPlayer():IsValid() then
		hook.Remove("HUDPaint", "TFA_TRIGGERCLIENTLOAD")

		hook.Run("TFA_ClientLoad")
	end
end)

--[[
Hook: InitPostEntity
Function: Wraps SWEP:Think functions
Used For: Patching old, broken weapons that override SWEP:Think without calling baseclass
]]
--
local PatchClassBlacklisted = {
	tfa_gun_base = true,
	tfa_melee_base = true,
	tfa_bash_base = true,
	tfa_bow_base = true,
	tfa_knife_base = true,
	tfa_nade_base = true,
	tfa_sword_advanced_base = true,
	tfa_cssnade_base = true,
	tfa_shotty_base = true,
	tfa_akimbo_base = true,
	tfa_3dbash_base = true,
	tfa_3dscoped_base = true,
	tfa_scoped_base = true,
}

local cv_shouldpatchthink = GetConVar("sv_tfa_backcompat_patchswepthink") or CreateConVar("sv_tfa_backcompat_patchswepthink", "1", CLIENT and {FCVAR_REPLICATED} or {FCVAR_REPLICATED, FCVAR_ARCHIVE, FCVAR_NOTIFY}, "Enable patching of old weapons that override SWEP:Think function to work with newer version of the base?\n\tDISABLING THIS IS NOT RECOMMENDED AND MAY LEAD TO NON-FUNCTIONING WEAPONS!")

hook.Add("InitPostEntity", "TFA_PatchThinkOverride", function()
	if not cv_shouldpatchthink:GetBool() then return end
	if not debug or not debug.getinfo then return end

	for _, wepRefTable in ipairs(weapons.GetList()) do
		local class = wepRefTable.ClassName

		if PatchClassBlacklisted[class] or not weapons.IsBasedOn(class, "tfa_gun_base") then
			goto THINK1FOUND
		end

		local wepRealTbl = weapons.GetStored(class)

		if wepRealTbl.Think then
			local info = debug.getinfo(wepRealTbl.Think, "S")
			if not info or not info.linedefined or not info.lastlinedefined then goto THINK1FOUND end

			local src = info.short_src

			if src:StartWith("addons/") then
				src = src:gsub("^addons/[^%0:/]+/", "")
			end

			local luafile = file.Read(src:sub(5), "LUA")
			if not luafile or luafile == "" then goto THINK1FOUND end

			local lua = luafile:gsub("\r\n","\n"):gsub("\r","\n"):Split("\n")

			for i = info.linedefined, info.lastlinedefined do
				local line = lua[i]

				if not line or line:find("BaseClass%s*.%s*Think%s*%(") then
					goto THINK1FOUND
				end
			end

			print(("[TFA Base] Weapon %s (%s) is overriding SWEP:Think() function without calling baseclass!"):format(wepRefTable.ClassName, info.short_src))

			local BaseClass = baseclass.Get(wepRealTbl.Base)

			wepRealTbl.ThinkFuncUnwrapped = wepRealTbl.ThinkFuncUnwrapped or wepRealTbl.Think
			function wepRealTbl:Think(...)
				self:ThinkFuncUnwrapped(...)

				return BaseClass.Think(self, ...)
			end
		end

		::THINK1FOUND::
	end
end)
--addons/tfa_base/lua/tfa/modules/tfa_keybinds.lua:
TFA._KeyBindTable = TFA._KeyBindTable or {}
local KeyBindTable = TFA._KeyBindTable

local cv_prefix = "cl_tfa_keys_"

local sp = game.SinglePlayer()

if sp then -- THANK YOU GARRY FOR HIGH QUALITY PREDICTION IN SINGLEPLAYER
	if SERVER then
		util.AddNetworkString("TFA_KB_State")
		util.AddNetworkString("TFA_KB_Think")
	end

	if CLIENT then
		net.Receive("TFA_KB_State", function()
			local ply = LocalPlayer()

			local bind = net.ReadString()
			local state = net.ReadBool()

			local data = KeyBindTable[bind]

			if data and data.state ~= state then
				data.state = state

				if state then
					data.onpress(ply)
				else
					data.onrelease(ply)
				end
			end
		end)

		net.Receive("TFA_KB_Think", function()
			local ply = LocalPlayer()

			local bind = net.ReadString()

			local data = KeyBindTable[bind]

			if data and data.think and data.state then
				data.think(ply)
			end
		end)
	end
end

local function empty()
end

function TFA.RegisterKeyBind(data_in)
	assert(type(data_in) == "table", "Data must be a table!")
	assert(data_in.bind and type(data_in.bind) == "string", "Invalid bind name!")
	-- assert(not TFA._KeyBindTable[data.bind], "Keybind already registered!")

	local data = table.Copy(data_in)

	if not data.onpress then
		data.onpress = empty
	elseif type(data.onpress) ~= "function" then
		error("data.onpress - function expected, got " .. type(data.onpress))
	end

	if not data.onrelease then
		data.onrelease = empty
	elseif type(data.onrelease) ~= "function" then
		error("data.onrelease - function expected, got " .. type(data.onrelease))
	end

	data.state = false

	if CLIENT and GetConVar(cv_prefix .. data.bind) == nil then
		CreateClientConVar(cv_prefix .. data.bind, 0, true, true, data.desc)
	end

	hook.Add("PlayerButtonDown", "TFA_KB_KeyDown_" .. data.bind, function(ply, button)
		if not IsFirstTimePredicted() then return end
		local cv_key = ply:GetInfoNum(cv_prefix .. data.bind, 0)

		if cv_key > 0 and cv_key == button and not data.state then
			data.state = true
			data.onpress(ply)

			if sp and SERVER then
				net.Start("TFA_KB_State", true)
				net.WriteString(data.bind)
				net.WriteBool(data.state)
				net.Send(ply)
			end
		end
	end)

	hook.Add("PlayerButtonUp", "TFA_KB_KeyUp_" .. data.bind, function(ply, button)
		if not IsFirstTimePredicted() then return end
		local cv_key = ply:GetInfoNum(cv_prefix .. data.bind, 0)

		if cv_key > 0 and cv_key == button and data.state then
			data.state = false
			data.onrelease(ply)

			if sp and SERVER then
				net.Start("TFA_KB_State", true)
				net.WriteString(data.bind)
				net.WriteBool(data.state)
				net.Send(ply)
			end
		end
	end)

	hook.Remove("PlayerPostThink", "TFA_KB_Think_" .. data.bind)

	if data.think and type(data.think) == "function" then
		hook.Add("PlayerPostThink", "TFA_KB_Think_" .. data.bind, function(ply)
			if data.state then
				data.think(ply)

				if sp and SERVER then
					net.Start("TFA_KB_Think", true)
					net.WriteString(data.bind)
					net.Send(ply)
				end
			end
		end)
	end

	KeyBindTable[data.bind] = data
end

if CLIENT then -- Populate spawnmenu settings with registered keybinds
	local function tfaOptionKeys(panel)
		panel:Help("#tfa.keybinds.help.bind")
		panel:Help("#tfa.keybinds.help.bound")
		panel:Help("#tfa.keybinds.help.unbind")
		panel:Help("")

		for _, data in pairs(KeyBindTable) do
			local cv = GetConVar(cv_prefix .. data.bind)

			if cv then
				panel:Help("#tfa.keybind." .. data.bind)

				local binder = vgui.Create("DBinder")

				binder:SetValue(cv:GetInt())

				function binder:OnChange(newcode)
					cv:SetInt(newcode)
				end

				panel:AddItem(binder)
				panel:Help("")
			end
		end
	end

	hook.Add("PopulateToolMenu", "TFA_AddKeyBinds", function()
		spawnmenu.AddToolMenuOption("Utilities", "TFA SWEP Base Settings", "TFASwepBaseKeybinds", "#tfa.smsettings.keybinds", "", "", tfaOptionKeys)
	end)
end

-- Default keybinds
TFA.RegisterKeyBind({
	bind = "bash",

	onpress = function(plyv)
		if not plyv:IsValid() then return end

		plyv.tfa_bash_hack = true
	end,

	onrelease = function(plyv)
		if not plyv:IsValid() then return end

		plyv.tfa_bash_hack = false
	end
})

TFA.RegisterKeyBind({
	bind = "customize",
	onpress = CLIENT and function(plyv)
		if not plyv:IsValid() then return end

		RunConsoleCommand("impulse", TFA.INSPECTION_IMPULSE_STRING)
	end
})

TFA.RegisterKeyBind({
	bind = "inspect",
	onpress = function(plyv)
		local wepv = plyv:GetActiveWeapon()

		if (IsValid(wepv) and wepv.GetStat) and (wepv:GetActivityEnabled(ACT_VM_FIDGET) or wepv.InspectionActions) and wepv:GetStatus() == TFA.Enum.STATUS_IDLE then
			local _, tanim, ttype = wepv:ChooseInspectAnim()
			wepv:ScheduleStatus(TFA.Enum.STATUS_FIDGET, wepv:GetActivityLength(tanim, false, ttype))
		end
	end
})

TFA.RegisterKeyBind({
	bind = "firemode",
	onpress = CLIENT and function(plyv)
		local wepv = plyv:GetActiveWeapon()

		if IsValid(wepv) and wepv.GetStat then
			if wepv:GetStatL("SelectiveFire") and not wepv:GetOwner():KeyDown(IN_SPEED) then
				RunConsoleCommand("impulse", TFA.CYCLE_FIREMODE_IMPULSE_STRING)
			elseif wepv:GetOwner():KeyDown(IN_SPEED) then
				RunConsoleCommand("impulse", TFA.CYCLE_SAFETY_IMPULSE_STRING)
			end
		end
	end
})

TFA.RegisterKeyBind({
	bind = "silencer",
	onpress = function(plyv)
		local wepv = plyv:GetActiveWeapon()

		if (IsValid(wepv) and wepv.GetStat) and wepv:GetStatRawL("CanBeSilenced") and TFA.Enum.ReadyStatus[wepv:GetStatus()] then
			local _, tanim, ttype = wepv:ChooseSilenceAnim(not wepv:GetSilenced())
			wepv:ScheduleStatus(TFA.Enum.STATUS_SILENCER_TOGGLE, wepv:GetActivityLength(tanim, true, ttype))
		end
	end
})

-- EXAMPLE KEYBIND:
--[[
	TFA.RegisterKeyBind({
		bind = "whatever", -- bind id, cvar is cl_tfa_keys_whatever
		onpress = function(ply) end, -- function called on key press
		onrelease = function(ply) end, -- function called on key release
		think = function(ply) end, -- called from PlayerPostThink when key is held down
	})
]]

--addons/tfa_base/lua/tfa/modules/tfa_small_entities.lua:
-- This file contain aliases/slight modifications which do not deserve their own Lua file

weapons.Register({
	Base = "tfa_nade_base",
	AllowUnderhanded = true,
}, "tfa_cssnade_base")

weapons.Register({
	Base = "tfa_gun_base",
	Shotgun = true,
}, "tfa_shotty_base")

weapons.Register({
	Base = "tfa_gun_base",
}, "tfa_akimbo_base")

if SERVER then
	AddCSLuaFile("tfa/3dscoped_base.lua")
end

local SWEP_ = include("tfa/3dscoped_base.lua")
local SWEP = table.Copy(SWEP_)
SWEP.Secondary = {}

SWEP.Secondary.UseACOG = false
SWEP.Secondary.UseMilDot = false
SWEP.Secondary.UseSVD = false
SWEP.Secondary.UseParabolic = false
SWEP.Secondary.UseElcan = false
SWEP.Secondary.UseGreenDuplex = false
SWEP.RTScopeFOV = 6
SWEP.RTScopeAttachment = 3 --Anchor the scope shadow to this
SWEP.Scoped = false
SWEP.BoltAction = false
SWEP.ScopeLegacyOrientation = false --used to align with eyeangles instead of vm angles
SWEP.ScopeAngleTransforms = {}
--{"P",1} --Pitch, 1
--{"Y",1} --Yaw, 1
--{"R",1} --Roll, 1
SWEP.ScopeOverlayTransforms = {0, 0}
SWEP.ScopeOverlayTransformMultiplier = 0.8
SWEP.RTMaterialOverride = 1
SWEP.IronSightsSensitivity = 1
SWEP.ScopeShadow = nil
SWEP.ScopeReticule = nil
SWEP.ScopeDirt = nil
SWEP.ScopeReticule_CrossCol = false
SWEP.ScopeReticule_Scale = {1, 1}
--[[End of Tweakable Parameters]]--
SWEP.Scoped_3D = true
SWEP.BoltAction_3D = false

SWEP.Base = "tfa_bash_base"

weapons.Register(SWEP, "tfa_3dbash_base")

SWEP = table.Copy(SWEP_)
SWEP.Secondary = {}

SWEP.Secondary.UseACOG = false
SWEP.Secondary.UseMilDot = false
SWEP.Secondary.UseSVD = false
SWEP.Secondary.UseParabolic = false
SWEP.Secondary.UseElcan = false
SWEP.Secondary.UseGreenDuplex = false
SWEP.RTScopeFOV = 6
SWEP.RTScopeAttachment = 3
SWEP.Scoped = false
SWEP.BoltAction = false
SWEP.ScopeLegacyOrientation = false --used to align with eyeangles instead of vm angles
SWEP.ScopeAngleTransforms = {}
--{"P",1} --Pitch, 1
--{"Y",1} --Yaw, 1
--{"R",1} --Roll, 1
SWEP.ScopeOverlayTransforms = {0, 0}
SWEP.ScopeOverlayTransformMultiplier = 0.8
SWEP.RTMaterialOverride = 1
SWEP.IronSightsSensitivity = 1
SWEP.ScopeShadow = nil
SWEP.ScopeReticule = nil
SWEP.ScopeDirt = nil
SWEP.ScopeReticule_CrossCol = false
SWEP.ScopeReticule_Scale = {1, 1}
--[[End of Tweakable Parameters]]--
SWEP.Scoped_3D = true
SWEP.BoltAction_3D = false

SWEP.Base = "tfa_gun_base"

weapons.Register(SWEP, "tfa_3dscoped_base")

weapons.Register({
	Base = "tfa_gun_base",

	Secondary = {
		UseACOG = false,
		UseMilDot = false,
		UseSVD = false,
		UseParabolic = false,
		UseElcan = false,
		UseGreenDuplex = false,
	},

	Scoped = true,
	BoltAction = false,
}, "tfa_scoped_base")

local ammo = {
	["357"] = {
		Type = "anim",
		Base = "tfa_ammo_base",
		PrintName = "357",
		Category = "TFA Ammunition",
		Spawnable = true,
		AdminSpawnable = true,
		Class = "",
		MyModel = "models/Items/357ammo.mdl",
		AmmoCount = 25,
		AmmoType = "357",
		DrawText = true,
		TextColor = Color(225, 225, 225, 255),
		TextPosition = Vector(5, 0, 7.5),
		TextAngles = Vector(42, 90, 0),
		ShouldDrawShadow = true,
		ImpactSound = "Default.ImpactSoft",
		Damage = 50,
	},

	ar2 = {
		Type = "anim",
		Base = "tfa_ammo_base",
		PrintName = "Assault Ammo",
		Category = "TFA Ammunition",
		Spawnable = true,
		AdminSpawnable = true,
		Class = "",
		MyModel = "models/Items/BoxMRounds.mdl",
		AmmoCount = 100,
		AmmoType = "ar2",
		DrawText = true,
		TextColor = Color(5, 5, 5, 255),
		TextPosition = Vector(2, 1.5, 13.4),
		TextAngles = Vector(90, 90, 90),
		ShouldDrawShadow = true,
		ImpactSound = "Default.ImpactSoft",
		Damage = 35,
		Text = "Assault Ammo",
	},

	buckshot = {
		Type = "anim",
		Base = "tfa_ammo_base",
		PrintName = "Buckshot",
		Category = "TFA Ammunition",
		Spawnable = true,
		AdminSpawnable = true,
		Class = "",
		MyModel = "models/Items/BoxBuckshot.mdl",
		AmmoCount = 20,
		AmmoType = "buckshot",
		DrawText = true,
		TextColor = Color(225, 225, 225, 255),
		TextPosition = Vector(2, 3.54, 3),
		TextAngles = Vector(0, 90, 90),
		ShouldDrawShadow = true,
		ImpactSound = "Default.ImpactSoft",
		Damage = 40,
		Text = "Buckshot",
	},

	pistol = {
		Type = "anim",
		Base = "tfa_ammo_base",
		PrintName = "Pistol Rounds",
		Category = "TFA Ammunition",
		Spawnable = true,
		AdminSpawnable = true,
		Class = "",
		MyModel = "models/Items/BoxSRounds.mdl",
		AmmoCount = 100,
		AmmoType = "pistol",
		DrawText = true,
		TextColor = Color(255, 255, 255, 255),
		TextPosition = Vector(2, 1.5, 11.6),
		TextAngles = Vector(90, 90, 90),
		ShouldDrawShadow = true,
		ImpactSound = "Default.ImpactSoft",
		Damage = 40,
		Text = "Pistol Rounds",
	},

	smg = {
		Type = "anim",
		Base = "tfa_ammo_base",
		PrintName = "SMG Rounds",
		Category = "TFA Ammunition",
		Spawnable = true,
		AdminSpawnable = true,
		Class = "",
		MyModel = "models/Items/BoxSRounds.mdl",
		AmmoCount = 100,
		AmmoType = "smg1",
		DrawText = true,
		TextColor = Color(255, 255, 255, 255),
		TextPosition = Vector(2, 1.5, 11.6),
		TextAngles = Vector(90, 90, 90),
		ShouldDrawShadow = true,
		ImpactSound = "Default.ImpactSoft",
		Damage = 20,
		Text = "SMG Rounds",
	},

	smg1_grenade = {
		Type = "anim",
		Base = "tfa_ammo_base",
		PrintName = "SMG Grenade",
		Category = "TFA Ammunition",

		Spawnable = true,
		AdminSpawnable = true,

		MyModel = "models/items/tfa/ar2_grenade.mdl",

		AmmoType = "SMG1_Grenade",
		AmmoCount = 1,

		DamageThreshold = 15,
	},

	smg1_grenade_large = {
		Type = "anim",
		Base = "tfa_ammo_base",
		PrintName = "SMG Grenades",
		Category = "TFA Ammunition",

		Spawnable = true,
		AdminSpawnable = true,

		MyModel = "models/items/tfa/boxar2grenades.mdl",

		AmmoType = "SMG1_Grenade",
		AmmoCount = 5,

		DamageThreshold = 55,
	},

	sniper_rounds = {
		Type = "anim",
		Base = "tfa_ammo_base",
		PrintName = "Sniper Ammo",
		Category = "TFA Ammunition",
		Spawnable = true,
		AdminSpawnable = true,
		Class = "",
		MyModel = "models/Items/sniper_round_box.mdl",
		AmmoCount = 30,
		AmmoType = "SniperPenetratedRound",
		DrawText = true,
		TextColor = Color(185, 25, 25, 255),
		TextPosition = Vector(1, -1.45, 2.1),
		TextAngles = Vector(90, 0, 0),
		ShouldDrawShadow = true,
		ImpactSound = "Default.ImpactSoft",
		Damage = 80,
		Text = "Sniper Rounds",
		TextScale = 0.5,
	},

	winchester = {
		Type = "anim",
		Base = "tfa_ammo_base",
		PrintName = "Winchester Ammo",
		Category = "TFA Ammunition",
		Spawnable = true,
		AdminSpawnable = true,
		Class = "",
		MyModel = "models/Items/sniper_round_box.mdl",
		AmmoCount = 50,
		AmmoType = "AirboatGun",
		DrawText = true,
		TextColor = Color(185, 25, 25, 255),
		TextPosition = Vector(1, -1.45, 1.5),
		TextAngles = Vector(90, 0, 0),
		ShouldDrawShadow = true,
		ImpactSound = "Default.ImpactSoft",
		Damage = 30,
		Text = ".308",
	}
}

for ammoclass, ENT in pairs(ammo) do
	scripted_ents.Register(ENT, "tfa_ammo_" .. ammoclass)
end

--addons/egm_tfa_weapons/lua/tfa/3dscoped_base.lua:

-- Copyright (c) 2018-2020 TFA Base Devs

-- Permission is hereby granted, free of charge, to any person obtaining a copy
-- of this software and associated documentation files (the "Software"), to deal
-- in the Software without restriction, including without limitation the rights
-- to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-- copies of the Software, and to permit persons to whom the Software is
-- furnished to do so, subject to the following conditions:

-- The above copyright notice and this permission notice shall be included in all
-- copies or substantial portions of the Software.

-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-- SOFTWARE.

local SWEP = {}

local BaseClass = baseclass.Get("tfa_gun_base")

local scopecvar = GetConVar("cl_tfa_3dscope")
local scopeshadowcvar = GetConVar("cl_tfa_3dscope_overlay")

local sp = game.SinglePlayer()

function SWEP:Do3DScope()
	if scopecvar then
		return scopecvar:GetBool()
	else
		if self:OwnerIsValid() and self:GetOwner().GetInfoNum then
			return self:GetOwner():GetInfoNum("cl_tfa_3dscope", 1) == 1
		else
			return true
		end
	end
end

function SWEP:Do3DScopeOverlay()
	if scopeshadowcvar then
		return scopeshadowcvar:GetBool()
	else
		return false
	end
end

function SWEP:UpdateScopeType(force)
	local target = self.Secondary_TFA or self.Secondary

	if self.Scoped_3D and force then
		self.Scoped = true
		self.Scoped_3D = false

		if target.ScopeZoom_Backup then
			target.ScopeZoom = target.ScopeZoom_Backup
		else
			target.ScopeZoom = 90 / self:GetStat("Secondary.IronFOV")
		end

		if self.BoltAction_3D then
			self.BoltAction = true
			self.BoltAction_3D = nil

			self:ClearStatCache("BoltAction")
		end

		target.IronFOV = 90 / self:GetStat("Secondary.ScopeZoom")
		self.IronSightsSensitivity = 1
	end

	if self:Do3DScope() then
		self.Scoped = false
		self.Scoped_3D = true

		if not target.ScopeZoom_Backup then
			target.ScopeZoom_Backup = target.ScopeZoom
		end

		if self.BoltAction then
			self.BoltAction_3D = true
			self.BoltAction = self.BoltAction_Forced or false
			self.DisableChambering = true
			self.FireModeName = "tfa.firemode.bolt"
		end

		if target.ScopeZoom and target.ScopeZoom > 0 then
			if CLIENT then
				self.RTScopeFOV = 90 / target.ScopeZoom * ( target.ScopeScreenScale or 0.392592592592592 )
			end

			target.IronFOV_Backup = target.IronFOV
			target.IronFOV = 70

			if CLIENT then
				self.IronSightsSensitivity = self:Get3DSensitivity()
			end

			target.ScopeZoom = nil
		end
	else
		self.Scoped = true
		self.Scoped_3D = false

		if target.ScopeZoom_Backup then
			target.ScopeZoom = target.ScopeZoom_Backup
		else
			target.ScopeZoom = 4
		end

		if self.BoltAction_3D then
			self.BoltAction = true
			self.BoltAction_3D = nil

			self:ClearStatCache("BoltAction")
		end

		target.IronFOV = 90 / target.ScopeZoom
		self.IronSightsSensitivity = 1
	end
end

function SWEP:Initialize(...)
	self.Primary_TFA = self.Primary
	self.Secondary_TFA = self.Secondary
	self:UpdateScopeType()
	self.Primary_TFA = nil
	self.Secondary_TFA = nil

	BaseClass.Initialize(self, ...)

	timer.Simple(0, function()
		if IsValid(self) and self:OwnerIsValid() then
			self:UpdateScopeType()
		end
	end)
end

function SWEP:Deploy(...)
	if SERVER and self:OwnerIsValid() and sp then
		self:CallOnClient("UpdateScopeType", "")
	end

	self:UpdateScopeType()

	timer.Simple(0, function()
		if IsValid(self) and self:OwnerIsValid() then
			self:UpdateScopeType()
		end
	end)

	return BaseClass.Deploy(self,...)
end

local flipcv = GetConVar("cl_tfa_viewmodel_flip")
local cd = {}
local crosscol = Color(255, 255, 255, 255)
SWEP.RTOpaque = true

local cv_cc_r = GetConVar("cl_tfa_hud_crosshair_color_r")
local cv_cc_g = GetConVar("cl_tfa_hud_crosshair_color_g")
local cv_cc_b = GetConVar("cl_tfa_hud_crosshair_color_b")
local cv_cc_a = GetConVar("cl_tfa_hud_crosshair_color_a")

SWEP.defaultscrvec = Vector()

function SWEP:RTCode(rt, scrw, scrh)
	local legacy = self.ScopeLegacyOrientation
	local rttw = ScrW()
	local rtth = ScrH()

	if not self:VMIV() then return end

	if not self.myshadowmask then
		self.myshadowmask = surface.GetTextureID(self.ScopeShadow or "vgui/scope_shadowmask_test")
	end

	if not self.myreticule then
		self.myreticule = Material(self.ScopeReticule or "scope/gdcw_scopesightonly")
	end

	if not self.mydirt then
		self.mydirt = Material(self.ScopeDirt or "vgui/scope_dirt")
	end

	local vm = self.OwnerViewModel

	if not self.LastOwnerPos then
		self.LastOwnerPos = self:GetOwner():GetShootPos()
	end

	local owoff = self:GetOwner():GetShootPos() - self.LastOwnerPos

	self.LastOwnerPos = self:GetOwner():GetShootPos()

	local scrpos

	if self.RTScopeAttachment and self.RTScopeAttachment > 0 then
		vm:SetupBones()
		local att = vm:GetAttachment( self.RTScopeAttachment or 1 )
		if not att then return end
		local pos = att.Pos - owoff
		cam.Start3D()
		cam.End3D()
		scrpos = pos:ToScreen()
	else
		self.defaultscrvec.x = scrw / 2
		self.defaultscrvec.y = scrh / 2
		scrpos = self.defaultscrvec
	end

	scrpos.x = scrpos.x - scrw / 2 + self.ScopeOverlayTransforms[1]
	scrpos.y = scrpos.y - scrh / 2 + self.ScopeOverlayTransforms[2]
	scrpos.x = scrpos.x / scrw * 1920
	scrpos.y = scrpos.y / scrw * 1920
	scrpos.x = math.Clamp(scrpos.x, -1024, 1024)
	scrpos.y = math.Clamp(scrpos.y, -1024, 1024)
	--scrpos.x = scrpos.x * ( 2 - self:GetIronSightsProgress()*1 )
	--scrpos.y = scrpos.y * ( 2 - self:GetIronSightsProgress()*1 )
	scrpos.x = scrpos.x * self.ScopeOverlayTransformMultiplier
	scrpos.y = scrpos.y * self.ScopeOverlayTransformMultiplier

	if not self.scrpos then
		self.scrpos = scrpos
	end

	self.scrpos.x = math.Approach(self.scrpos.x, scrpos.x, (scrpos.x - self.scrpos.x) * FrameTime() * 10)
	self.scrpos.y = math.Approach(self.scrpos.y, scrpos.y, (scrpos.y - self.scrpos.y) * FrameTime() * 10)
	scrpos = self.scrpos
	render.OverrideAlphaWriteEnable(true, true)
	surface.SetDrawColor(color_white)
	surface.DrawRect(-512, -512, 1024, 1024)
	render.OverrideAlphaWriteEnable(true, true)

	local ang = legacy and self:GetOwner():EyeAngles() or vm:GetAngles()

	if self.RTScopeAttachment and self.RTScopeAttachment > 0 then
		vm:SetupBones()
		local AngPos = vm:GetAttachment( self.RTScopeAttachment )

		if AngPos then
			ang = AngPos.Ang

			if flipcv:GetBool() then
				ang.y = -ang.y
			end

			for _, v in pairs(self.ScopeAngleTransforms) do
				if v[1] == "P" then
					ang:RotateAroundAxis(ang:Right(), v[2])
				elseif v[1] == "Y" then
					ang:RotateAroundAxis(ang:Up(), v[2])
				elseif v[1] == "R" then
					ang:RotateAroundAxis(ang:Forward(), v[2])
				end
			end
		end
	end

	cd.angles = ang
	cd.origin = self:GetOwner():GetShootPos()

	if not self.RTScopeOffset then
		self.RTScopeOffset = {0, 0}
	end

	if not self.RTScopeScale then
		self.RTScopeScale = {1, 1}
	end

	local rtow, rtoh = self.RTScopeOffset[1], self.RTScopeOffset[2]
	local rtw, rth = rttw * self.RTScopeScale[1], rtth * self.RTScopeScale[2]

	cd.x = 0
	cd.y = 0
	cd.w = rtw
	cd.h = rth
	cd.fov = self.RTScopeFOV
	cd.drawviewmodel = false
	cd.drawhud = false
	render.Clear(0, 0, 0, 255, true, true)
	render.SetScissorRect(0 + rtow, 0 + rtoh, rtw + rtow, rth + rtoh, true)

	if self:GetIronSightsProgress() > 0.01 and self.Scoped_3D then
		render.RenderView(cd)
	end

	render.SetScissorRect(0, 0, rtw, rth, false)
	render.OverrideAlphaWriteEnable(false, true)
	cam.Start2D()
	draw.NoTexture()
	surface.SetTexture(self.myshadowmask)
	surface.SetDrawColor(color_white)

	if self:Do3DScopeOverlay() then
		surface.DrawTexturedRect(scrpos.x + rtow - rtw / 2, scrpos.y + rtoh - rth / 2, rtw * 2, rth * 2)
	end

	if self.ScopeReticule_CrossCol then
		crosscol.r = cv_cc_r:GetFloat()
		crosscol.g = cv_cc_g:GetFloat()
		crosscol.b = cv_cc_b:GetFloat()
		crosscol.a = cv_cc_a:GetFloat()
		surface.SetDrawColor(crosscol)
	end

	surface.SetMaterial(self.myreticule)
	local tmpborderw = rtw * (1 - self.ScopeReticule_Scale[1]) / 2
	local tmpborderh = rth * (1 - self.ScopeReticule_Scale[2]) / 2
	surface.DrawTexturedRect(rtow + tmpborderw, rtoh + tmpborderh, rtw - tmpborderw * 2, rth - tmpborderh * 2)
	surface.SetDrawColor(color_black)
	draw.NoTexture()

	if self:Do3DScopeOverlay() then
		surface.DrawRect(scrpos.x - 2048 + rtow, -1024 + rtoh, 2048, 2048)
		surface.DrawRect(scrpos.x + rtw + rtow, -1024 + rtoh, 2048, 2048)
		surface.DrawRect(-1024 + rtow, scrpos.y - 2048 + rtoh, 2048, 2048)
		surface.DrawRect(-1024 + rtow, scrpos.y + rth + rtoh, 2048, 2048)
	end

	surface.SetDrawColor(ColorAlpha(color_black, 255 - 255 * (math.Clamp(self:GetIronSightsProgress() - 0.75, 0, 0.25) * 4)))
	surface.DrawRect(-1024 + rtow, -1024 + rtoh, 2048, 2048)
	surface.SetMaterial(self.mydirt)
	surface.SetDrawColor(ColorAlpha(color_white, 128))
	surface.DrawTexturedRect(0, 0, rtw, rth)
	surface.SetDrawColor(ColorAlpha(color_white, 64))
	surface.DrawTexturedRectUV(rtow, rtoh, rtw, rth, 2, 0, 0, 2)
	cam.End2D()
end

return SWEP

--addons/tfa_base/lua/tfa/modules/tfa_npc_teamcolor.lua:
local ENTMETA = FindMetaTable("Entity")
local PLYMETA = FindMetaTable("Player")
local NPCMETA = FindMetaTable("NPC")

local IsValid = ENTMETA.IsValid

local Alive = PLYMETA.Alive
local GetActiveWeapon = PLYMETA.GetActiveWeapon
local GetAimVector = PLYMETA.GetAimVector
local GetShootPos = PLYMETA.GetShootPos

local Disposition = NPCMETA.Disposition

local util_TraceLine = util.TraceLine
local MASK_SHOT = MASK_SHOT

if SERVER then
	util.AddNetworkString("TFA_NPC_DISP")

	local NPCDispCacheSV = {}
	local function PlayerPostThink(ply)
		if not Alive(ply) then return end

		local wep = GetActiveWeapon(ply)
		if not IsValid(wep) or not wep.IsTFAWeapon then return end

		if not NPCDispCacheSV[ply] then
			NPCDispCacheSV[ply] = {}
		end

		local tr = {}
		tr.start = GetShootPos(ply)
		tr.endpos = tr.start + GetAimVector(ply) * 0xffff
		tr.filter = ply
		tr.mask = MASK_SHOT
		local targent = util_TraceLine(tr).Entity

		if IsValid(targent) and type(targent) == "NPC" then
			local disp = Disposition(targent, ply)

			if not NPCDispCacheSV[ply][targent] or NPCDispCacheSV[ply][targent] ~= disp then
				NPCDispCacheSV[ply][targent] = disp

				net.Start("TFA_NPC_DISP")
				net.WriteEntity(targent)
				net.WriteUInt(disp, 3)
				net.Send(ply)
			end
		end
	end

	hook.Add("PlayerPostThink", "TFA_NPCDispositionSync", PlayerPostThink)
else
	local NPCDispCacheSV = {}
	net.Receive("TFA_NPC_DISP", function()
		local ent = net.ReadEntity()
		local disp = net.ReadUInt(3)

		NPCDispCacheSV[ent] = disp
	end)

	function TFA.GetNPCDisposition(ent)
		return NPCDispCacheSV[ent]
	end
end
--addons/tfa_base/lua/tfa/modules/tfa_snd_timescale.lua:
local sv_cheats_cv = GetConVar("sv_cheats")
local host_timescale_cv = GetConVar("host_timescale")
local ts

local en_cvar = GetConVar("sv_tfa_soundscale")

hook.Add("EntityEmitSound", "zzz_TFA_EntityEmitSound", function(soundData)
	local ent = soundData.Entity
	local modified
	local weapon

	if ent:IsWeapon() then
		weapon = ent
	elseif ent:IsNPC() or ent:IsPlayer() then
		weapon = ent:GetActiveWeapon()
	end

	if IsValid(weapon) and weapon.IsTFA and weapon.IsTFAWeapon then
		if weapon.GonnaAdjuctPitch then
			soundData.Pitch = soundData.Pitch * weapon.RequiredPitch
			weapon.GonnaAdjuctPitch = false
			modified = true
		end

		if weapon.GonnaAdjustVol then
			soundData.Volume = soundData.Volume * weapon.RequiredVolume
			weapon.GonnaAdjustVol = false
			modified = true
		end
	end

	if not en_cvar then return modified end
	if not en_cvar:GetBool() then return modified end
	ts = game.GetTimeScale()

	if sv_cheats_cv:GetBool() then
		ts = ts * host_timescale_cv:GetFloat()
	end

	if engine.GetDemoPlaybackTimeScale then
		ts = ts * engine.GetDemoPlaybackTimeScale()
	end

	if ts ~= 1 then
		soundData.Pitch = math.Clamp(soundData.Pitch * ts, 0, 255)
		return true
	end

	return modified
end)

--addons/tfa_base/lua/tfa/modules/tfa_tttpatch.lua:
if engine.ActiveGamemode() ~= "terrortown" then return end

local cv_enabled = CreateConVar("sv_tfa_ttt_patch_weapons", "1", {FCVAR_ARCHIVE, FCVAR_REPLICATED, FCVAR_NOTIFY}, "Patch TFA Base weapons to automatically spawn")

-- luacheck: globals WEAPON_NONE WEAPON_MELEE WEAPON_PISTOL WEAPON_HEAVY WEAPON_NADE WEAPON_CARRY WEAPON_EQUIP1 WEAPON_EQUIP2 WEAPON_ROLE WEAPON_EQUIP WEAPON_UNARMED ROLE_INNOCENT ROLE_TRAITOR ROLE_DETECTIVE ROLE_NONE
WEAPON_NONE = WEAPON_NONE or 0
WEAPON_MELEE = WEAPON_MELEE or 1
WEAPON_PISTOL = WEAPON_PISTOL or 2
WEAPON_HEAVY = WEAPON_HEAVY or 3
WEAPON_NADE = WEAPON_NADE or 4
WEAPON_CARRY = WEAPON_CARRY or 5
WEAPON_EQUIP1 = WEAPON_EQUIP1 or 6
WEAPON_EQUIP2 = WEAPON_EQUIP2 or 7
WEAPON_ROLE = WEAPON_ROLE or 8
WEAPON_EQUIP = WEAPON_EQUIP or WEAPON_EQUIP1
WEAPON_UNARMED = WEAPON_UNARMED or -1
ROLE_INNOCENT = ROLE_INNOCENT or 0
ROLE_TRAITOR = ROLE_TRAITOR or 1
ROLE_DETECTIVE = ROLE_DETECTIVE or 2
ROLE_NONE = ROLE_NONE or ROLE_INNOCENT

local KindTable = {
	[0] = WEAPON_MELEE,
	[1] = WEAPON_PISTOL,
	[2] = WEAPON_HEAVY,
	[3] = WEAPON_HEAVY,
	[4] = WEAPON_HEAVY,
	[5] = WEAPON_EQUIP1,
	[6] = WEAPON_EQUIP2
}

local TypeStrings = {
	[WEAPON_NONE] = "Invalid",
	[WEAPON_MELEE] = "Melee",
	[WEAPON_PISTOL] = "Pistol",
	[WEAPON_HEAVY] = "Heavy",
	[WEAPON_NADE] = "Grenade",
	[WEAPON_CARRY] = "Carry",
	[WEAPON_EQUIP1] = "Equipment",
	[WEAPON_EQUIP2] = "Equipment",
	[WEAPON_ROLE] = "Role"
}

local function PatchWep(wep)
	if not weapons.IsBasedOn(wep, "tfa_gun_base") then return end
	if wep:find("base") then return end

	local tbl = weapons.GetStored(wep)
	if not tbl then return end

	tbl.AllowSprintAttack = true -- no sprinting ever, running convar is a dumb idea

	if (not tbl.Kind) or (not isnumber(tbl.Kind)) then
		tbl.Kind = KindTable[tbl.Slot or 2] or WEAPON_HEAVY

		if (tbl.ProjectileVelocity and tbl.ProjectileVelocity < 1000 and tbl.ProjectileVelocity > 0) or string.find(tbl.Base or "", "nade") then
			tbl.Kind = WEAPON_NADE
		end

		if tbl.IsMelee then
			tbl.Kind = WEAPON_MELEE
		end

		if not tbl.Spawnable then
			tbl.Kind = WEAPON_NONE
		end
	end

	--if not tbl.Icon then
	--	tbl.Icon = nil--"vgui/entities/" .. wep
	--end
	tbl.model = tbl.model or tbl.WorldModel

	if not tbl.CanBuy then
		--if tbl.Spawnable then
		--	tbl.CanBuy = { ROLE_TRAITOR, ROLE_DETECTIVE }
		--else
		tbl.CanBuy = {}
		--end
	end

	for _, v in pairs(tbl.CanBuy) do
		if v ~= ROLE_TRAITOR and v ~= ROLE_DETECTIVE then
			table.RemoveByValue(tbl.CanBuy, v)
		end
	end

	if (not tbl.Icon) or (string.len(tbl.Icon) <= 0) then
		tbl.Icon = nil
		if file.Exists("materials/entities/" .. wep .. ".png", "GAME") then
			tbl.Icon = "entities/" .. wep .. ".png"
		elseif file.Exists("materials/vgui/entities/" .. wep .. ".vmt", "GAME") then
			tbl.Icon = "vgui/entities/" .. wep
		end
	end

	if tbl.LimitedStock == nil then
		tbl.LimitedStock = false
	end

	if not tbl.EquipMenuData then
		tbl.EquipMenuData = {
			["type"] = TypeStrings[tbl.Kind],
			["desc"] = tbl.PrintName or wep
		}
	end

	if tbl.IsSilent == nil then
		tbl.IsSilent = false
	end

	if tbl.NoSights == nil then
		if tbl.data then
			tbl.NoSights = tbl.Secondary.IronSightsEnabled == false or tbl.data and tbl.data.ironsights ~= 0 or false
		end

		if tbl.NoSights == nil then
			tbl.NoSights = false
		end
	end

	if tbl.AutoSpawnable == nil then
		tbl.AutoSpawnable = tbl.Spawnable
	end
end

local function Patch()
	if not cv_enabled:GetBool() then return end

	for _, v in pairs(weapons.GetList()) do
		local wep = v.ClassName

		if wep then
			PatchWep(wep)
		end
	end
end

if SERVER then
	hook.Add("Initialize", "TFAPatchTTT", Patch)
end
if CLIENT then
	hook.Add("HUDPaint", "TFAPatchTTT", function()
		if LocalPlayer():IsValid() then
			Patch()
			hook.Remove("HUDPaint","TFAPatchTTT")
		end
	end)
end

--addons/tfa_base/lua/tfa/modules/cl_tfa_attachment_icon.lua:
local padding = TFA.Attachments.UIPadding
local PANEL = {}
PANEL.Wep = nil
PANEL.ID = nil
PANEL.Att = nil --Weapon attachment
PANEL.Attachment = nil --Actual TFA attachment table

function PANEL:Init()
	self.Wep = nil --Weapon Entity
	self.ID = nil --Attachment ID
	self.Att = nil --Attachment Category
	self.Attachment = nil --TFA Attachment Name
	self:SetMouseInputEnabled(true)
	self:SetZPos(500)
end

function PANEL:SetWeapon(wep)
	if IsValid(wep) then
		self.Wep = wep
	end
end

function PANEL:SetGunAttachment(att)
	if att ~= nil then
		self.Att = att
	end
end

function PANEL:SetAttachment(att)
	self.Attachment = att
end

function PANEL:SetID(id)
	if id ~= nil then
		self.ID = id
	end
end

function PANEL:GetSelected()
	if not IsValid(self.Wep) then return false end
	if not self.Att then return end
	if not self.ID then return end
	if not self.Wep.Attachments[self.Att] then return end

	return self.Wep.Attachments[self.Att].sel == self.ID
end

function PANEL:AttachSound(attached)
	if self.Attachment and TFA.Attachments.Atts[self.Attachment] then
		local att = TFA.Attachments.Atts[self.Attachment]

		local snd = attached and att.AttachSound or att.DetachSound

		if snd and IsValid(self.Wep) then
			self.Wep:EmitSound(snd)

			return
		end
	end

	chat.PlaySound()
end

function PANEL:OnMousePressed()
	if not IsValid(self.Wep) or not self.Attachment or self.Attachment == "" then return end

	if self:GetSelected() and self.Wep:CanAttach(self.Attachment, true) then
		self.Wep:SetTFAAttachment(self.Att, -1, true)
		self:AttachSound(false)
	elseif self.Wep.Attachments[self.Att] and self.Wep:CanAttach(self.Attachment) then
		self.Wep:SetTFAAttachment(self.Att, self.ID, true)
		self:AttachSound(true)
	end
end

local function abbrev(str)
	local tbl = string.Explode(" ",str,false)
	local retstr = ""
	for k,v in ipairs(tbl) do
		local tmpstr = utf8.sub(v,1,1)
		retstr = retstr .. ((k == 1) and string.upper(tmpstr) or string.lower(tmpstr))
	end
	return retstr
end

function PANEL:Paint(w, h)
	if not IsValid(self.Wep) then return end
	if self.Attachment == nil then return end
	if not TFA.Attachments.Atts[self.Attachment] then self:SetMouseInputEnabled(false) return end
	local sel = self:GetSelected()
	local col = sel and TFA.Attachments.Colors["active"] or TFA.Attachments.Colors["background"]

	if not sel and not self.Wep:CanAttach(self.Attachment) then
		col = TFA.Attachments.Colors["error"]
	elseif sel and not self.Wep:CanAttach(self.Attachment, true) then
		col = TFA.Attachments.Colors["error_attached"]
	end

	draw.RoundedBox(0, 0, 0, w, h, ColorAlpha(col, self.Wep:GetInspectingProgress() * 225))

	if not TFA.Attachments.Atts[self.Attachment].Icon then
		TFA.Attachments.Atts[self.Attachment].Icon = "entities/tfa_qmark.png"
	end

	if not TFA.Attachments.Atts[self.Attachment].Icon_Cached then
		TFA.Attachments.Atts[self.Attachment].Icon_Cached = Material(TFA.Attachments.Atts[self.Attachment].Icon, "noclamp smooth")
	end

	local attachmentIcon = TFA.Attachments.Atts[self.Attachment].Icon_Cached

	local iconOverride = self.Wep:GetStat("AttachmentIconOverride." .. self.Attachment)
	if iconOverride and type(iconOverride) == "IMaterial" then
		attachmentIcon = iconOverride
	end

	surface.SetDrawColor(ColorAlpha(color_white, self.Wep:GetInspectingProgress() * 255))
	surface.SetMaterial(attachmentIcon)
	surface.DrawTexturedRect(padding, padding, w - padding * 2, h - padding * 2)
	if not TFA.Attachments.Atts[self.Attachment].ShortName then
		TFA.Attachments.Atts[self.Attachment].ShortName = abbrev(language.GetPhrase(TFA.Attachments.Atts[self.Attachment].Name) or "")
		TFA.Attachments.Atts[self.Attachment].ShortNameGenerated = true
	end
	draw.SimpleText(string.upper(TFA.Attachments.Atts[self.Attachment].ShortName) , "TFAAttachmentIconFontTiny", padding / 4, h, ColorAlpha(TFA.Attachments.Colors["primary"], self.Wep:GetInspectingProgress() * (sel and 192 or 64)), TEXT_ALIGN_LEFT, TEXT_ALIGN_BOTTOM)
end

vgui.Register("TFAAttachmentIcon", PANEL, "Panel")

-- cleanup generated shortnames
cvars.AddChangeCallback("gmod_language", function()
	for id, att in pairs(TFA.Attachments.Atts or {}) do
		if att.ShortNameGenerated then
			att.ShortName = nil
			att.ShortNameGenerated = nil
		end
	end
end, "tfa_attachment_clearshortnames")
--addons/tfa_base/lua/tfa/modules/cl_tfa_devtools.lua:
local cv_dba = GetConVar("cl_tfa_debug_animations")
local cv_dbc = GetConVar("cl_tfa_debug_crosshair")

local color_red = Color(255, 0, 0, 255)
local color_white = Color(255, 255, 255, 255)

local state_strings = {}

for i = 1, 32 do
	local strcomp = string.rep("%d", i)
	local slice = {}

	for i2 = 0, i - 1 do
		table.insert(slice, "band(rshift(state, " .. i2 .. "), 1) == 0 and 0 or 1")
	end

	local fn = CompileString([[
		local rshift = bit.rshift
		local band = bit.band
		return function(state)
			return ]] .. table.concat(slice, ", ") .. [[
		end
	]], "tfa_dev_tools")()

	state_strings[i] = function(state)
		return string.format(strcomp, fn(state))
	end
end

local lastStatusBarWidth = 300
local lastAnimStatusWidth = 300

local STATUS_BAR_COLOR = Color(255, 255, 255)
local STATUS_BAR_COLOR_BG = Color(74, 74, 74)

local function DrawDebugInfo(w, h, ply, wep)
	if not cv_dba:GetBool() then return end

	local x, y = w * .5, h * .2

	if wep.event_table_overflow then
		if wep.EventTableEdict[0] then
			draw.SimpleTextOutlined("UNPREDICTED Event table state:", "TFASleekDebug", x + 240, y, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP, 1, color_black)
			local y2 = y + TFA.Fonts.SleekHeightDebug

			if not wep._built_event_debug_string_fn then
				local str = ""
				local str2 = ""

				for i = 0, #wep.EventTableEdict do
					str = str .. "%d"

					if (i + 1) % 32 == 0 then
						str = str .. "\n"
					end

					if str2 == "" then
						str2 = "self.EventTableEdict[" .. i .. "].called and 1 or 0"
					else
						str2 = str2 .. ", self.EventTableEdict[" .. i .. "].called and 1 or 0"
					end
				end

				wep._built_event_debug_string_fn = CompileString([[
					local format = string.format
					return function(self)
						return format([==[]] .. str .. [[]==], ]] .. str2 .. [[)
					end
				]], "TFA Base Debug Tools")()
			end

			for line in string.gmatch(wep:_built_event_debug_string_fn(), "(%S+)") do
				draw.SimpleTextOutlined(line, "TFASleekDebug", x + 240, y2, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP, 1, color_black)
				y2 = y2 + TFA.Fonts.SleekHeightDebug
			end
		end
	elseif wep._EventSlotCount ~= 0 then
		draw.SimpleTextOutlined("Event table state:", "TFASleekDebug", x + 240, y, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP, 1, color_black)
		local y2 = y + TFA.Fonts.SleekHeightDebug

		for i = 1, wep._EventSlotCount do
			local state = wep["GetEventStatus" .. i](wep)
			local stringbake

			if i ~= wep._EventSlotCount then
				stringbake = state_strings[32](state)
			else
				local fn = state_strings[wep._EventSlotNum % 32 + 1]

				if not fn then break end
				stringbake = fn(state)
			end

			draw.SimpleTextOutlined(stringbake, "TFASleekDebug", x + 240, y2, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP, 1, color_black)
			y2 = y2 + TFA.Fonts.SleekHeightDebug
		end
	end

	local statusText = string.format(
		"%s [%.2f, %.2f, %.2f, %.2f]",
		TFA.Enum.InverseStatus[wep:GetStatus()] or wep:GetStatus(),
		CurTime() + (wep.CurTimePredictionAdvance or 0),
		wep:GetStatusProgress(true),
		wep:GetStatusStart(),
		wep:GetStatusEnd())

	draw.SimpleTextOutlined(statusText, "TFASleekDebug", x, y, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP, 1, color_black)

	--[[if wep:GetStatusProgress() >= 1 then
		local stW, stH = surface.GetTextSize(statusText)

		lastStatusBarWidth = math.max(300, stW)
	end]]

	y = y + TFA.Fonts.SleekHeightDebug + 2

	surface.SetDrawColor(STATUS_BAR_COLOR_BG)
	surface.DrawRect(x - lastStatusBarWidth / 2, y, lastStatusBarWidth, 4)

	surface.SetDrawColor(STATUS_BAR_COLOR)
	surface.DrawRect(x - lastStatusBarWidth / 2, y, lastStatusBarWidth * wep:GetStatusProgress(true), 4)

	y = y + 8

	local vm = wep.OwnerViewModel

	if IsValid(vm) then
		local seq = vm:GetSequence()

		draw.SimpleTextOutlined(string.format("%s [%d] (%s/%d)", vm:GetSequenceName(seq), seq, vm:GetSequenceActivityName(seq), vm:GetSequenceActivity(seq)), "TFASleekDebug", x, y, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP, 1, color_black)
		y = y + TFA.Fonts.SleekHeightDebug

		local cycle = vm:GetCycle()
		local len = vm:SequenceDuration(seq)
		local rate = vm:GetPlaybackRate()

		local animStatus = string.format("%.2fs / %.2fs (%.2f) @ %d%%", cycle * len, len, cycle, rate * 100)

		draw.SimpleTextOutlined(animStatus, "TFASleekDebug", x, y, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP, 1, color_black)
		--local stW, stH = surface.GetTextSize(animStatus)
		--lastAnimStatusWidth = math.max(300, stW)

		y = y + TFA.Fonts.SleekHeightDebug + 2

		surface.SetDrawColor(STATUS_BAR_COLOR_BG)
		surface.DrawRect(x - lastAnimStatusWidth / 2, y, lastAnimStatusWidth, 4)

		if len * rate >= 0.2 then
			surface.SetDrawColor(STATUS_BAR_COLOR)
			surface.DrawRect(x - lastAnimStatusWidth / 2, y, lastAnimStatusWidth * cycle, 4)
		end
	end
end

local function DrawDebugCrosshair(w, h, ply, wep)
	if not cv_dbc:GetBool() then return end

	surface.SetDrawColor(color_red)
	surface.DrawRect(w * .5 - 1, h * .5 - 1, 2, 2)

	local tr = util.QuickTrace(ply:GetShootPos(), wep:GetAimVector(), ply)
	local tsc = tr.HitPos:ToScreen()

	if tsc.visible then
		surface.SetDrawColor(color_white)
		surface.DrawRect(tsc.x - 1, tsc.y - 1, 2, 2)
	end
end

local w, h

hook.Add("HUDPaint", "tfa_drawdebughud", function()
	local ply = LocalPlayer() or NULL
	if not ply:IsValid() or not ply:IsAdmin() then return end

	local wep = ply:GetActiveWeapon() or NULL
	if not wep:IsValid() or not wep.IsTFAWeapon then return end

	w, h = ScrW(), ScrH()

	DrawDebugInfo(w, h, ply, wep)
	DrawDebugCrosshair(w, h, ply, wep)
end)

--tfa_dev_tools:
		local rshift = bit.rshift
		local band = bit.band
		return function(state)
			return band(rshift(state, 0), 1) == 0 and 0 or 1		end
	
--tfa_dev_tools:
		local rshift = bit.rshift
		local band = bit.band
		return function(state)
			return band(rshift(state, 0), 1) == 0 and 0 or 1, band(rshift(state, 1), 1) == 0 and 0 or 1, band(rshift(state, 2), 1) == 0 and 0 or 1, band(rshift(state, 3), 1) == 0 and 0 or 1		end
	
--tfa_dev_tools:
		local rshift = bit.rshift
		local band = bit.band
		return function(state)
			return band(rshift(state, 0), 1) == 0 and 0 or 1, band(rshift(state, 1), 1) == 0 and 0 or 1, band(rshift(state, 2), 1) == 0 and 0 or 1, band(rshift(state, 3), 1) == 0 and 0 or 1, band(rshift(state, 4), 1) == 0 and 0 or 1		end
	
--tfa_dev_tools:
		local rshift = bit.rshift
		local band = bit.band
		return function(state)
			return band(rshift(state, 0), 1) == 0 and 0 or 1, band(rshift(state, 1), 1) == 0 and 0 or 1, band(rshift(state, 2), 1) == 0 and 0 or 1, band(rshift(state, 3), 1) == 0 and 0 or 1, band(rshift(state, 4), 1) == 0 and 0 or 1, band(rshift(state, 5), 1) == 0 and 0 or 1		end
	
--tfa_dev_tools:
		local rshift = bit.rshift
		local band = bit.band
		return function(state)
			return band(rshift(state, 0), 1) == 0 and 0 or 1, band(rshift(state, 1), 1) == 0 and 0 or 1, band(rshift(state, 2), 1) == 0 and 0 or 1, band(rshift(state, 3), 1) == 0 and 0 or 1, band(rshift(state, 4), 1) == 0 and 0 or 1, band(rshift(state, 5), 1) == 0 and 0 or 1, band(rshift(state, 6), 1) == 0 and 0 or 1, band(rshift(state, 7), 1) == 0 and 0 or 1		end
	
--tfa_dev_tools:
		local rshift = bit.rshift
		local band = bit.band
		return function(state)
			return band(rshift(state, 0), 1) == 0 and 0 or 1, band(rshift(state, 1), 1) == 0 and 0 or 1, band(rshift(state, 2), 1) == 0 and 0 or 1, band(rshift(state, 3), 1) == 0 and 0 or 1, band(rshift(state, 4), 1) == 0 and 0 or 1, band(rshift(state, 5), 1) == 0 and 0 or 1, band(rshift(state, 6), 1) == 0 and 0 or 1, band(rshift(state, 7), 1) == 0 and 0 or 1, band(rshift(state, 8), 1) == 0 and 0 or 1, band(rshift(state, 9), 1) == 0 and 0 or 1		end
	
--tfa_dev_tools:
		local rshift = bit.rshift
		local band = bit.band
		return function(state)
			return band(rshift(state, 0), 1) == 0 and 0 or 1, band(rshift(state, 1), 1) == 0 and 0 or 1, band(rshift(state, 2), 1) == 0 and 0 or 1, band(rshift(state, 3), 1) == 0 and 0 or 1, band(rshift(state, 4), 1) == 0 and 0 or 1, band(rshift(state, 5), 1) == 0 and 0 or 1, band(rshift(state, 6), 1) == 0 and 0 or 1, band(rshift(state, 7), 1) == 0 and 0 or 1, band(rshift(state, 8), 1) == 0 and 0 or 1, band(rshift(state, 9), 1) == 0 and 0 or 1, band(rshift(state, 10), 1) == 0 and 0 or 1, band(rshift(state, 11), 1) == 0 and 0 or 1, band(rshift(state, 12), 1) == 0 and 0 or 1		end
	
--tfa_dev_tools:
		local rshift = bit.rshift
		local band = bit.band
		return function(state)
			return band(rshift(state, 0), 1) == 0 and 0 or 1, band(rshift(state, 1), 1) == 0 and 0 or 1, band(rshift(state, 2), 1) == 0 and 0 or 1, band(rshift(state, 3), 1) == 0 and 0 or 1, band(rshift(state, 4), 1) == 0 and 0 or 1, band(rshift(state, 5), 1) == 0 and 0 or 1, band(rshift(state, 6), 1) == 0 and 0 or 1, band(rshift(state, 7), 1) == 0 and 0 or 1, band(rshift(state, 8), 1) == 0 and 0 or 1, band(rshift(state, 9), 1) == 0 and 0 or 1, band(rshift(state, 10), 1) == 0 and 0 or 1, band(rshift(state, 11), 1) == 0 and 0 or 1, band(rshift(state, 12), 1) == 0 and 0 or 1, band(rshift(state, 13), 1) == 0 and 0 or 1, band(rshift(state, 14), 1) == 0 and 0 or 1, band(rshift(state, 15), 1) == 0 and 0 or 1, band(rshift(state, 16), 1) == 0 and 0 or 1, band(rshift(state, 17), 1) == 0 and 0 or 1, band(rshift(state, 18), 1) == 0 and 0 or 1, band(rshift(state, 19), 1) == 0 and 0 or 1, band(rshift(state, 20), 1) == 0 and 0 or 1, band(rshift(state, 21), 1) == 0 and 0 or 1		end
	
--tfa_dev_tools:
		local rshift = bit.rshift
		local band = bit.band
		return function(state)
			return band(rshift(state, 0), 1) == 0 and 0 or 1, band(rshift(state, 1), 1) == 0 and 0 or 1, band(rshift(state, 2), 1) == 0 and 0 or 1, band(rshift(state, 3), 1) == 0 and 0 or 1, band(rshift(state, 4), 1) == 0 and 0 or 1, band(rshift(state, 5), 1) == 0 and 0 or 1, band(rshift(state, 6), 1) == 0 and 0 or 1, band(rshift(state, 7), 1) == 0 and 0 or 1, band(rshift(state, 8), 1) == 0 and 0 or 1, band(rshift(state, 9), 1) == 0 and 0 or 1, band(rshift(state, 10), 1) == 0 and 0 or 1, band(rshift(state, 11), 1) == 0 and 0 or 1, band(rshift(state, 12), 1) == 0 and 0 or 1, band(rshift(state, 13), 1) == 0 and 0 or 1, band(rshift(state, 14), 1) == 0 and 0 or 1, band(rshift(state, 15), 1) == 0 and 0 or 1, band(rshift(state, 16), 1) == 0 and 0 or 1, band(rshift(state, 17), 1) == 0 and 0 or 1, band(rshift(state, 18), 1) == 0 and 0 or 1, band(rshift(state, 19), 1) == 0 and 0 or 1, band(rshift(state, 20), 1) == 0 and 0 or 1, band(rshift(state, 21), 1) == 0 and 0 or 1, band(rshift(state, 22), 1) == 0 and 0 or 1, band(rshift(state, 23), 1) == 0 and 0 or 1, band(rshift(state, 24), 1) == 0 and 0 or 1		end
	
--tfa_dev_tools:
		local rshift = bit.rshift
		local band = bit.band
		return function(state)
			return band(rshift(state, 0), 1) == 0 and 0 or 1, band(rshift(state, 1), 1) == 0 and 0 or 1, band(rshift(state, 2), 1) == 0 and 0 or 1, band(rshift(state, 3), 1) == 0 and 0 or 1, band(rshift(state, 4), 1) == 0 and 0 or 1, band(rshift(state, 5), 1) == 0 and 0 or 1, band(rshift(state, 6), 1) == 0 and 0 or 1, band(rshift(state, 7), 1) == 0 and 0 or 1, band(rshift(state, 8), 1) == 0 and 0 or 1, band(rshift(state, 9), 1) == 0 and 0 or 1, band(rshift(state, 10), 1) == 0 and 0 or 1, band(rshift(state, 11), 1) == 0 and 0 or 1, band(rshift(state, 12), 1) == 0 and 0 or 1, band(rshift(state, 13), 1) == 0 and 0 or 1, band(rshift(state, 14), 1) == 0 and 0 or 1, band(rshift(state, 15), 1) == 0 and 0 or 1, band(rshift(state, 16), 1) == 0 and 0 or 1, band(rshift(state, 17), 1) == 0 and 0 or 1, band(rshift(state, 18), 1) == 0 and 0 or 1, band(rshift(state, 19), 1) == 0 and 0 or 1, band(rshift(state, 20), 1) == 0 and 0 or 1, band(rshift(state, 21), 1) == 0 and 0 or 1, band(rshift(state, 22), 1) == 0 and 0 or 1, band(rshift(state, 23), 1) == 0 and 0 or 1, band(rshift(state, 24), 1) == 0 and 0 or 1, band(rshift(state, 25), 1) == 0 and 0 or 1, band(rshift(state, 26), 1) == 0 and 0 or 1		end
	
--tfa_dev_tools:
		local rshift = bit.rshift
		local band = bit.band
		return function(state)
			return band(rshift(state, 0), 1) == 0 and 0 or 1, band(rshift(state, 1), 1) == 0 and 0 or 1, band(rshift(state, 2), 1) == 0 and 0 or 1, band(rshift(state, 3), 1) == 0 and 0 or 1, band(rshift(state, 4), 1) == 0 and 0 or 1, band(rshift(state, 5), 1) == 0 and 0 or 1, band(rshift(state, 6), 1) == 0 and 0 or 1, band(rshift(state, 7), 1) == 0 and 0 or 1, band(rshift(state, 8), 1) == 0 and 0 or 1, band(rshift(state, 9), 1) == 0 and 0 or 1, band(rshift(state, 10), 1) == 0 and 0 or 1, band(rshift(state, 11), 1) == 0 and 0 or 1, band(rshift(state, 12), 1) == 0 and 0 or 1, band(rshift(state, 13), 1) == 0 and 0 or 1, band(rshift(state, 14), 1) == 0 and 0 or 1, band(rshift(state, 15), 1) == 0 and 0 or 1, band(rshift(state, 16), 1) == 0 and 0 or 1, band(rshift(state, 17), 1) == 0 and 0 or 1, band(rshift(state, 18), 1) == 0 and 0 or 1, band(rshift(state, 19), 1) == 0 and 0 or 1, band(rshift(state, 20), 1) == 0 and 0 or 1, band(rshift(state, 21), 1) == 0 and 0 or 1, band(rshift(state, 22), 1) == 0 and 0 or 1, band(rshift(state, 23), 1) == 0 and 0 or 1, band(rshift(state, 24), 1) == 0 and 0 or 1, band(rshift(state, 25), 1) == 0 and 0 or 1, band(rshift(state, 26), 1) == 0 and 0 or 1, band(rshift(state, 27), 1) == 0 and 0 or 1, band(rshift(state, 28), 1) == 0 and 0 or 1, band(rshift(state, 29), 1) == 0 and 0 or 1		end
	
--addons/tfa_base/lua/tfa/modules/cl_tfa_materials.lua:
TFA_SCOPE_ACOG = {
	scopetex = surface.GetTextureID("scope/gdcw_closedsight"),
	reticletex = surface.GetTextureID("scope/gdcw_acogchevron"),
	dottex = surface.GetTextureID("scope/gdcw_acogcross")
}

TFA_SCOPE_MILDOT = {
	scopetex = surface.GetTextureID("scope/gdcw_scopesight")
}

TFA_SCOPE_SVD = {
	scopetex = surface.GetTextureID("scope/gdcw_svdsight")
}

TFA_SCOPE_PARABOLIC = {
	scopetex = surface.GetTextureID("scope/gdcw_parabolicsight")
}

TFA_SCOPE_ELCAN = {
	scopetex = surface.GetTextureID("scope/gdcw_elcansight"),
	reticletex = surface.GetTextureID("scope/gdcw_elcanreticle")
}

TFA_SCOPE_GREENDUPLEX = {
	scopetex = surface.GetTextureID("scope/gdcw_closedsight"),
	reticletex = surface.GetTextureID("scope/gdcw_nvgilluminatedduplex")
}

TFA_SCOPE_AIMPOINT = {
	scopetex = surface.GetTextureID("scope/gdcw_closedsight"),
	reticletex = surface.GetTextureID("scope/aimpoint")
}

TFA_SCOPE_MATADOR = {
	scopetex = surface.GetTextureID("scope/rocketscope")
}

TFA_SCOPE_SCOPESCALE = 4
TFA_SCOPE_RETICLESCALE = 1
TFA_SCOPE_DOTSCALE = 1

--addons/tfa_base/lua/tfa/modules/cl_tfa_particles_lua.lua:
local vector_origin = Vector()

TFA.Particles = TFA.Particles or {}
TFA.Particles.FlareParts = {}
TFA.Particles.VMAttachments = {}

local VMAttachments = TFA.Particles.VMAttachments
local FlareParts = TFA.Particles.FlareParts

local ply, vm, wep

local IsValid_ = FindMetaTable("Entity").IsValid
local GetModel = FindMetaTable("Entity").GetModel
local lastVMModel, lastVMAtts

local lastRequired = 0
local RealTime = RealTime
local FrameTime = FrameTime
local LocalPlayer = LocalPlayer
local ipairs = ipairs
local istable = istable
local isfunction = isfunction
local WorldToLocal = WorldToLocal
local table = table

local thinkAttachments = {}
local slowThinkers = 0

hook.Add("PreDrawEffects", "TFAMuzzleUpdate", function()
	if lastRequired < RealTime() then return end

	if not ply then
		ply = LocalPlayer()
	end

	if not IsValid_(vm) then
		vm = ply:GetViewModel()
		if not IsValid_(vm) then return end
	end

	local vmmodel = GetModel(vm)

	if vmmodel ~= lastVMModel then
		lastVMModel = vmmodel
		lastVMAtts = vm:GetAttachments()
	end

	if not lastVMAtts then return end

	if slowThinkers == 0 then
		for i in pairs(thinkAttachments) do
			VMAttachments[i] = vm:GetAttachment(i)
		end
	else
		for i = 1, #lastVMAtts do
			VMAttachments[i] = vm:GetAttachment(i)
		end
	end

	for _, v in ipairs(FlareParts) do
		if v and v.ThinkFunc then
			v:ThinkFunc()
		end
	end
end)

function TFA.Particles.RegisterParticleThink(particle, partfunc)
	if not particle or not isfunction(partfunc) then return end

	if not ply then
		ply = LocalPlayer()
	end

	if not IsValid_(vm) then
		vm = ply:GetViewModel()
		if not IsValid_(vm) then return end
	end

	particle.ThinkFunc = partfunc

	if IsValid(particle.FollowEnt) and particle.Att then
		local angpos = particle.FollowEnt:GetAttachment(particle.Att)

		if angpos then
			particle.OffPos = WorldToLocal(particle:GetPos(), particle:GetAngles(), angpos.Pos, angpos.Ang)
		end
	end

	local att = particle.Att

	local isFast = partfunc == TFA.Particles.FollowMuzzle and att ~= nil
	local isVM = particle.FollowEnt == vm

	if isFast then
		if isVM then
			thinkAttachments[att] = (thinkAttachments[att] or 0) + 1
		end
	else
		slowThinkers = slowThinkers + 1
	end

	table.insert(FlareParts, particle)

	timer.Simple(particle:GetDieTime(), function()
		if particle then
			table.RemoveByValue(FlareParts, particle)
		end

		if not isFast then
			slowThinkers = slowThinkers - 1
		elseif isVM and att then
			thinkAttachments[att] = thinkAttachments[att] - 1
			if thinkAttachments[att] <= 0 then thinkAttachments[att] = nil end
		end
	end)

	lastRequired = RealTime() + 0.5
end

function TFA.Particles.FollowMuzzle(self, first)
	if lastRequired < RealTime() then
		lastRequired = RealTime() + 0.5
		return
	end

	lastRequired = RealTime() + 0.5

	if self.isfirst == nil then
		self.isfirst = false
		first = true
	end

	if not IsValid_(ply) or not IsValid_(vm) then return end
	wep = ply:GetActiveWeapon()
	if IsValid(wep) and wep.IsCurrentlyScoped and wep:IsCurrentlyScoped() then return end

	if not IsValid(self.FollowEnt) then return end
	local owent = self.FollowEnt:GetOwner() or self.FollowEnt
	if not IsValid(owent) then return end

	local firvel

	if first then
		firvel = owent:GetVelocity() * FrameTime() * 1.1
	else
		firvel = vector_origin
	end

	if not self.Att or not self.OffPos then return end

	if self.FollowEnt == vm then
		local angpos = VMAttachments[self.Att]

		if angpos then
			local tmppos = LocalToWorld(self.OffPos, self:GetAngles(), angpos.Pos, angpos.Ang)
			local npos = tmppos + self:GetVelocity() * FrameTime()
			self.OffPos = WorldToLocal(npos + firvel, self:GetAngles(), angpos.Pos, angpos.Ang)
			self:SetPos(npos + firvel)
		end

		return
	end

	local angpos = self.FollowEnt:GetAttachment(self.Att)

	if angpos then
		local tmppos = LocalToWorld(self.OffPos, self:GetAngles(), angpos.Pos, angpos.Ang)
		local npos = tmppos + self:GetVelocity() * FrameTime()
		self.OffPos = WorldToLocal(npos + firvel * 0.5, self:GetAngles(), angpos.Pos, angpos.Ang)
		self:SetPos(npos + firvel)
	end
end

--addons/tfa_base/lua/tfa/modules/cl_tfa_rtbgblur.lua:
local FT = FrameTime

local tfablurintensity = 0

local cv_3dscopes = GetConVar("cl_tfa_3dscope")

local cv_mode = CreateClientConVar("cl_tfa_fx_rtscopeblur_mode", "1", true, false)
local funcs = {}

local cv_blur_passes = CreateClientConVar("cl_tfa_fx_rtscopeblur_passes", "3", true, false)
local cv_blur_intensity = CreateClientConVar("cl_tfa_fx_rtscopeblur_intensity", "4", true, false)
local blurTex = Material("pp/blurscreen")
funcs[1] = function()
	surface.SetDrawColor(color_white)
	render.SetMaterial(blurTex)
	local passes = cv_blur_passes:GetInt()

	for _ = 1, passes do
		render.UpdateScreenEffectTexture()

		blurTex:SetFloat("$blur", tfablurintensity * cv_blur_intensity:GetFloat() / math.sqrt(passes) )
		blurTex:Recompute()

		render.DrawScreenQuad()
	end
end

local blur_mat = Material("pp/bokehblur")
funcs[2] = function()
	render.UpdateScreenEffectTexture()
	render.UpdateFullScreenDepthTexture()

	blur_mat:SetTexture("$BASETEXTURE", render.GetScreenEffectTexture())
	blur_mat:SetTexture("$DEPTHTEXTURE", render.GetResolvedFullFrameDepth())

	blur_mat:SetFloat("$size", tfablurintensity * cv_blur_intensity:GetFloat() * 1.5 )
	blur_mat:SetFloat("$focus", 0)
	blur_mat:SetFloat("$focusradius", 0.25)

	render.SetMaterial(blur_mat)
	render.DrawScreenQuad()
end

hook.Add("PostDrawTranslucentRenderables", "tfa_draw_rt_blur", function()
	if TFA.DrawingRenderTarget then return end

	if not cv_3dscopes:GetBool() then return end

	local mode = cv_mode:GetInt()
	if not isfunction(funcs[mode]) then return end

	local ply = LocalPlayer()
	if not IsValid(ply) or ply:ShouldDrawLocalPlayer() then return end

	local wep = ply:GetActiveWeapon()
	if not IsValid(wep) or not wep.IsTFAWeapon or not wep.GetStat then return end
	if not wep:GetStatL("RTBGBlur") then return end
	if not wep:GetStatL("RTDrawEnabled") and not wep:GetStatL("RTMaterialOverride") and not wep.RTCode then return end

	if wep.GLDeployed and wep:GLDeployed() then
		tfablurintensity = Lerp(FT() * 12.5, tfablurintensity, 0)
	else
		local progress = math.Clamp(wep.CLIronSightsProgress or 0, 0, 1)
		tfablurintensity = Lerp(FT() * 25, tfablurintensity, progress)
	end

	if tfablurintensity > 0.05 then
		funcs[mode]()
	end
end)

hook.Add("NeedsDepthPass", "aaaaaaaaaaaaaaaaaaNeedsDepthPass_TJA_IronSight", function()
	if tfablurintensity > 0.05 and cv_mode:GetInt() == 2 then
		if not cv_3dscopes:GetBool() then return end

		DOFModeHack(true)

		return true
	end
end)
--addons/tfa_base/lua/tfa/modules/cl_tfa_settingsmenu.lua:
local IsSinglePlayer = game.SinglePlayer()

function TFA.NumSliderNet(_parent, label, convar, min, max, decimals, ...)
	local gconvar = assert(GetConVar(convar), "Unknown ConVar: " .. convar .. "!")
	local newpanel

	if IsSinglePlayer then
		newpanel = _parent:NumSlider(label, convar, min, max, decimals, ...)
	else
		newpanel = _parent:NumSlider(label, nil, min, max, decimals, ...)
	end

	decimals = decimals or 0
	local sf = "%." .. decimals .. "f"

	if not IsSinglePlayer then
		local ignore = false

		newpanel.Think = function(_self)
			if _self._wait_for_update and _self._wait_for_update > RealTime() then return end
			local float = gconvar:GetFloat()

			if _self:GetValue() ~= float then
				ignore = true
				_self:SetValue(float)
				ignore = false
			end
		end

		newpanel.OnValueChanged = function(_self, _newval)
			if ignore then return end

			if not LocalPlayer():IsAdmin() then return end
			_self._wait_for_update = RealTime() + 1

			timer.Create("tfa_vgui_" .. convar, 0.5, 1, function()
				if not LocalPlayer():IsAdmin() then return end

				net.Start("TFA_SetServerCommand")
				net.WriteString(convar)
				net.WriteString(string.format(sf, _newval))
				net.SendToServer()
			end)
		end
	end

	return newpanel
end

function TFA.CheckBoxNet(_parent, label, convar, ...)
	local gconvar = assert(GetConVar(convar), "Unknown ConVar: " .. convar .. "!")
	local newpanel

	if IsSinglePlayer then
		newpanel = _parent:CheckBox(label, convar, ...)
	else
		newpanel = _parent:CheckBox(label, nil, ...)
	end

	if not IsSinglePlayer then
		if not IsValid(newpanel.Button) then return newpanel end

		newpanel.Button.Think = function(_self)
			local bool = gconvar:GetBool()

			if _self:GetChecked() ~= bool then
				_self:SetChecked(bool)
			end
		end

		newpanel.OnChange = function(_self, _bVal)
			if not LocalPlayer():IsAdmin() then return end
			if _bVal == gconvar:GetBool() then return end

			net.Start("TFA_SetServerCommand")
			net.WriteString(convar)
			net.WriteString(_bVal and "1" or "0")
			net.SendToServer()
		end
	end

	return newpanel
end

function TFA.ComboBoxNet(_parent, label, convar, ...)
	local gconvar = assert(GetConVar(convar), "Unknown ConVar: " .. convar .. "!")
	local combobox, leftpanel

	if IsSinglePlayer then
		combobox, leftpanel = _parent:ComboBox(label, convar, ...)
	else
		combobox, leftpanel = _parent:ComboBox(label, nil, ...)
	end

	if not IsSinglePlayer then
		combobox.Think = function(_self)
			local value = gconvar:GetString()

			if _self:GetValue() ~= value then
				_self:SetValue(value)
			end
		end

		combobox.OnSelect = function(_self, _index, _value, _data)
			if not LocalPlayer():IsAdmin() then return end
			local _newval = tostring(_data or _value)

			net.Start("TFA_SetServerCommand")
			net.WriteString(convar)
			net.WriteString(_newval)
			net.SendToServer()
		end
	end

	return combobox, leftpanel
end

--addons/tfa_base/lua/tfa/modules/cl_tfa_subcategories.lua:
local cv_enable = CreateClientConVar("cl_tfa_subcategories_enabled", "1", true, false, "Enable spawnmenu subcategories? (Update spawnmenu with spawnmenu_reload command after changing this!)")
local cv_autoassign = CreateClientConVar("cl_tfa_subcategories_auto", "0", true, false, "Attempt to auto-assign missing subcategories based on weapon's type?")

local function PopulateWeapons(pnlContent, tree, browseNode)
	if not cv_enable:GetBool() then return end

	local cats, subs = {}, {}

	for class, _wep in pairs(list.Get("Weapon") or {}) do
		if not _wep.Spawnable then continue end

		local cat = _wep.Category or "Other2"
		cats[cat] = cats[cat] or {}

		if not weapons.IsBasedOn(class, "tfa_gun_base") then
			table.insert(cats[cat], _wep)

			continue
		end

		local wep = weapons.Get(class)
		local sub = wep.SubCategory or (cv_autoassign:GetBool() and wep:GetType())
		if not sub or sub == "" then
			table.insert(cats[cat], wep)

			continue
		end

		subs[cat] = subs[cat] or {}
		subs[cat][sub] = subs[cat][sub] or {}

		table.insert(subs[cat][sub], wep)
	end

	local root = tree:Root()
	if not IsValid(root) then return end

	for _, node in ipairs(root:GetChildNodes()) do
		local name = node:GetText()
		if not name or not subs[name] then continue end

		node.DoPopulate = function(self)
			if self.PropPanel then return end

			self.PropPanel = vgui.Create("ContentContainer", pnlContent)
			self.PropPanel:SetVisible(false)
			self.PropPanel:SetTriggerSpawnlistChange(false)

			for sname, subcat in SortedPairs(subs[name]) do
				spawnmenu.CreateContentIcon("header", self.PropPanel, {text = sname})

				for _, ent in SortedPairsByMemberValue(subcat, "PrintName") do
					spawnmenu.CreateContentIcon(ent.ScriptedEntityType or "weapon", self.PropPanel, {
						nicename	= ent.PrintName or ent.ClassName,
						spawnname	= ent.ClassName,
						material	= ent.IconOverride or "entities/" .. ent.ClassName .. ".png",
						admin		= ent.AdminOnly
					})
				end
			end

			if cats[name] and #cats[name] > 0 then
				spawnmenu.CreateContentIcon("header", self.PropPanel, {text = "Other"})

				for _, ent in SortedPairsByMemberValue(cats[name], "PrintName") do
					spawnmenu.CreateContentIcon(ent.ScriptedEntityType or "weapon", self.PropPanel, {
						nicename	= ent.PrintName or ent.ClassName,
						spawnname	= ent.ClassName,
						material	= ent.IconOverride or "entities/" .. ent.ClassName .. ".png",
						admin		= ent.AdminOnly
					})
				end
			end
		end
	end
end

hook.Add("PopulateWeapons", "AddTFAWeaponContent", function(pnlContent, tree, browseNode)
	timer.Simple(0, function()
		PopulateWeapons(pnlContent, tree, browseNode)
	end)
end, 1)

TFA.BASE_LOAD_COMPLETE = true
--lua/tfa/external/tfa_csgo_particles.lua:
CSGOParticleFiles = {}
table.insert(CSGOParticleFiles, #CSGOParticleFiles, "cs_weapon_fx")
table.insert(CSGOParticleFiles, #CSGOParticleFiles, "explosions_fx")
table.insert(CSGOParticleFiles, #CSGOParticleFiles, "inferno_fx")

CSGOParticleEffects = {}
table.insert(CSGOParticleEffects, #CSGOParticleEffects, "weapon_muzzle_flash_assaultrifle")
table.insert(CSGOParticleEffects, #CSGOParticleEffects, "weapon_muzzle_flash_assaultrifle_silenced")
table.insert(CSGOParticleEffects, #CSGOParticleEffects, "weapon_muzzle_flash_awp")
table.insert(CSGOParticleEffects, #CSGOParticleEffects, "weapon_muzzle_flash_autoshotgun")
table.insert(CSGOParticleEffects, #CSGOParticleEffects, "weapon_muzzle_flash_huntingrifle")
table.insert(CSGOParticleEffects, #CSGOParticleEffects, "weapon_muzzle_flash_huntingrifle_FP")
table.insert(CSGOParticleEffects, #CSGOParticleEffects, "weapon_muzzle_flash_pistol")
table.insert(CSGOParticleEffects, #CSGOParticleEffects, "weapon_muzzle_flash_pistol_silenced")
table.insert(CSGOParticleEffects, #CSGOParticleEffects, "weapon_muzzle_flash_pistol_elite")
table.insert(CSGOParticleEffects, #CSGOParticleEffects, "weapon_muzzle_flash_shotgun")
table.insert(CSGOParticleEffects, #CSGOParticleEffects, "weapon_muzzle_flash_smg")
table.insert(CSGOParticleEffects, #CSGOParticleEffects, "weapon_muzzle_flash_para")
table.insert(CSGOParticleEffects, #CSGOParticleEffects, "weapon_muzzle_flash_para_FP")
table.insert(CSGOParticleEffects, #CSGOParticleEffects, "weapon_muzzle_flash_taser")
table.insert(CSGOParticleEffects, #CSGOParticleEffects, "weapon_shell_casing_50cal")
table.insert(CSGOParticleEffects, #CSGOParticleEffects, "weapon_shell_casing_9mm")
table.insert(CSGOParticleEffects, #CSGOParticleEffects, "weapon_shell_casing_9mm_FP")
table.insert(CSGOParticleEffects, #CSGOParticleEffects, "weapon_shell_casing_rifle")
table.insert(CSGOParticleEffects, #CSGOParticleEffects, "weapon_shell_casing_shotgun")
table.insert(CSGOParticleEffects, #CSGOParticleEffects, "weapon_shell_casing_50cal_fallback")
table.insert(CSGOParticleEffects, #CSGOParticleEffects, "weapon_shell_casing_9mm_fallback")
table.insert(CSGOParticleEffects, #CSGOParticleEffects, "weapon_shell_casing_rifle_fallback")
table.insert(CSGOParticleEffects, #CSGOParticleEffects, "weapon_shell_casing_shotgun_fallback")
table.insert(CSGOParticleEffects, #CSGOParticleEffects, "weapon_muzzle_smoke")
table.insert(CSGOParticleEffects, #CSGOParticleEffects, "weapon_muzzle_smoke_long")
table.insert(CSGOParticleEffects, #CSGOParticleEffects, "weapon_muzzle_flash_smoke_small")
table.insert(CSGOParticleEffects, #CSGOParticleEffects, "weapon_muzzle_flash_smoke_small2")
table.insert(CSGOParticleEffects, #CSGOParticleEffects, "weapon_muzzle_flash_smoke_small3")
table.insert(CSGOParticleEffects, #CSGOParticleEffects, "weapon_muzzle_flash_smoke_small4")
table.insert(CSGOParticleEffects, #CSGOParticleEffects, "weapon_muzzle_flash_smoke_medium")
table.insert(CSGOParticleEffects, #CSGOParticleEffects, "weapon_sensorgren_beeplight")
table.insert(CSGOParticleEffects, #CSGOParticleEffects, "weapon_sensorgren_detonate")
table.insert(CSGOParticleEffects, #CSGOParticleEffects, "weapon_tracers")
table.insert(CSGOParticleEffects, #CSGOParticleEffects, "weapon_tracers_50cal")
table.insert(CSGOParticleEffects, #CSGOParticleEffects, "weapon_tracers_mach")
table.insert(CSGOParticleEffects, #CSGOParticleEffects, "weapon_tracers_pistol")
table.insert(CSGOParticleEffects, #CSGOParticleEffects, "weapon_tracers_rifle")
table.insert(CSGOParticleEffects, #CSGOParticleEffects, "weapon_tracers_shot")
table.insert(CSGOParticleEffects, #CSGOParticleEffects, "weapon_tracers_silenced")
table.insert(CSGOParticleEffects, #CSGOParticleEffects, "weapon_tracers_smg")
table.insert(CSGOParticleEffects, #CSGOParticleEffects, "weapon_tracers_taser")
table.insert(CSGOParticleEffects, #CSGOParticleEffects, "weapon_decoy_ground_effect")
table.insert(CSGOParticleEffects, #CSGOParticleEffects, "weapon_decoy_ground_effect_shot")
table.insert(CSGOParticleEffects, #CSGOParticleEffects, "weapon_molotov_fp")
table.insert(CSGOParticleEffects, #CSGOParticleEffects, "weapon_molotov_thrown")
//EXPLOSION_FX
table.insert(CSGOParticleEffects, #CSGOParticleEffects, "c4_timer_light")
table.insert(CSGOParticleEffects, #CSGOParticleEffects, "c4_timer_light_trigger")
table.insert(CSGOParticleEffects, #CSGOParticleEffects, "c4_timer_light_held")
table.insert(CSGOParticleEffects, #CSGOParticleEffects, "c4_timer_light_dropped")
table.insert(CSGOParticleEffects, #CSGOParticleEffects, "explosion_c4_500")
table.insert(CSGOParticleEffects, #CSGOParticleEffects, "explosion_coop_mission_c4")
table.insert(CSGOParticleEffects, #CSGOParticleEffects, "explosion_basic")
table.insert(CSGOParticleEffects, #CSGOParticleEffects, "explosion_hegrenade_interior")
table.insert(CSGOParticleEffects, #CSGOParticleEffects, "explosion_hegrenade_brief")
table.insert(CSGOParticleEffects, #CSGOParticleEffects, "explosion_smoke_disperse")
table.insert(CSGOParticleEffects, #CSGOParticleEffects, "explosion_smokegrenade")
table.insert(CSGOParticleEffects, #CSGOParticleEffects, "explosion_smokegrenade_fallback")
table.insert(CSGOParticleEffects, #CSGOParticleEffects, "explosion_smokegrenade_CT")
//INFERNO FX
table.insert(CSGOParticleEffects, #CSGOParticleEffects, "molotov_explosion")
table.insert(CSGOParticleEffects, #CSGOParticleEffects, "molotov_fire01")
table.insert(CSGOParticleEffects, #CSGOParticleEffects, "molotov_groundfire")
table.insert(CSGOParticleEffects, #CSGOParticleEffects, "molotov_fire_main_gm")
table.insert(CSGOParticleEffects, #CSGOParticleEffects, "molotov_fire_child_gm")
table.insert(CSGOParticleEffects, #CSGOParticleEffects, "molotov_groundfire_00HIGH")
table.insert(CSGOParticleEffects, #CSGOParticleEffects, "molotov_groundfire_00MEDIUM")
table.insert(CSGOParticleEffects, #CSGOParticleEffects, "extinguish_fire")
table.insert(CSGOParticleEffects, #CSGOParticleEffects, "explosion_molotov_air")
table.insert(CSGOParticleEffects, #CSGOParticleEffects, "incgrenade_thrown_trail")

for k, v in pairs(CSGOParticleFiles) do
	game.AddParticles("particles/" .. v .. ".pcf")
end

for k, v in pairs(CSGOParticleEffects) do
	PrecacheParticleSystem(v)
end
--lua/tfa/att/mod_stun10_servius.lua:
if not ATTACHMENT then
	ATTACHMENT = {}
end


ATTACHMENT.Name = "Charge Round Beta"
ATTACHMENT.ShortName = "10s" --Abbreviation, 5 chars or less please
--ATTACHMENT.ID = "base" -- normally this is just your filename
ATTACHMENT.Description = { 
	TFA.AttachmentColors["+"],"Stunned for 10 Seconds",
}
ATTACHMENT.Icon = "entities/icon/mod_stun10.png" --Revers to label, please give it an icon though!  This should be the path to a png, like "entities/tfa_ammo_match.png"

ATTACHMENT.WeaponTable = {
	["Primary"] = {
		["AmmoConsumption"] = 7,
		["StatusEffect"] = "stun",
		["StatusEffectDmg"] = 20,
		["StatusEffectDur"] = 10,
		["StatusEffectParticle"] = true,
	},
	["TracerName"] = "effect_sw_laser_blue_stun",
}

function ATTACHMENT:Attach(wep)
	wep.CustomBulletCallbackOld = wep.CustomBulletCallbackOld or wep.CustomBulletCallback
	wep.CustomBulletCallback = function(a, tr, dmg)
		local wep = dmg:GetInflictor()
		if wep:GetStat("Primary.StatusEffect") then
			GMSERV:AddStatus(tr.Entity, wep:GetOwner(), wep:GetStat("Primary.StatusEffect"), wep:GetStat("Primary.StatusEffectDur"), wep:GetStat("Primary.StatusEffectDmg"), wep:GetStat("Primary.StatusEffectParticle"))
			--util.Effect("BGOLightning", ED_Stun, true, true)
		end
	end
end

function ATTACHMENT:Detach(wep)
	wep.CustomBulletCallback = wep.CustomBulletCallbackOld
	wep.CustomBulletCallbackOld = nil
end

if not TFA_ATTACHMENT_ISUPDATING then
	TFAUpdateAttachments()
end
--lua/tfa/att/mod_stun15_servius.lua:
if not ATTACHMENT then
	ATTACHMENT = {}
end


ATTACHMENT.Name = "Charge Round Charlie"
ATTACHMENT.ShortName = "15s" --Abbreviation, 5 chars or less please
--ATTACHMENT.ID = "base" -- normally this is just your filename
ATTACHMENT.Description = { 
	TFA.AttachmentColors["+"],"Stunned for 15 Seconds",
}
ATTACHMENT.Icon = "entities/icon/mod_stun15.png" --Revers to label, please give it an icon though!  This should be the path to a png, like "entities/tfa_ammo_match.png"

ATTACHMENT.WeaponTable = {
	["Primary"] = {
		["AmmoConsumption"] = 7,
		["StatusEffect"] = "stun",
		["StatusEffectDmg"] = 45,
		["StatusEffectDur"] = 15,
		["StatusEffectParticle"] = true,
	},
	["TracerName"] = "effect_sw_laser_blue_stun",
}

function ATTACHMENT:Attach(wep)
	wep.CustomBulletCallbackOld = wep.CustomBulletCallbackOld or wep.CustomBulletCallback
	wep.CustomBulletCallback = function(a, tr, dmg)
		local wep = dmg:GetInflictor()
		if wep:GetStat("Primary.StatusEffect") then
			GMSERV:AddStatus(tr.Entity, wep:GetOwner(), wep:GetStat("Primary.StatusEffect"), wep:GetStat("Primary.StatusEffectDur"), wep:GetStat("Primary.StatusEffectDmg"), wep:GetStat("Primary.StatusEffectParticle"))
			--util.Effect("BGOLightning", ED_Stun, true, true)
		end
	end
end

function ATTACHMENT:Detach(wep)
	wep.CustomBulletCallback = wep.CustomBulletCallbackOld
	wep.CustomBulletCallbackOld = nil
end

if not TFA_ATTACHMENT_ISUPDATING then
	TFAUpdateAttachments()
end
--addons/egm_tfa_weapons/lua/tfa/att/swrp_am_stun_lite.lua:
if not ATTACHMENT then
	ATTACHMENT = {}
end

ATTACHMENT.Name = "Stun Charge"
ATTACHMENT.ShortName = "Stun" --Abbreviation, 5 chars or less please
ATTACHMENT.Description = {
	TFA.AttachmentColors["+"], "Betäubt Gegner",
	TFA.Attachments.Colors["-"], "Niedrigere Schussrate"
}
ATTACHMENT.Icon = "entities/icon/mod_stun20.png" -- Revers to label, please give it an icon though!  This should be the path to a png, like "entities/tfa_ammo_match.png"

ATTACHMENT.WeaponTable = {
	["Primary"] = {
		["RPM"] = function( wep, stat ) return math.min(stat, 150) end,
		["RPM_Semi"] = function( wep, stat ) return math.min(stat, 150) end,
		["Range"] = function( wep, stat ) return math.min(stat, 750) end,
		["NumShots"] = 1,
		["Sound"] = "cwrp/weapons/taser_light.wav"
	},

	["TracerCount"] = 1,
	["TracerName"] = function( wep, stat ) return "effect_sw_stun_blue" end,
}

local function ApplyStun(trace, dmgInfo)
	local target = trace.Entity
	if IsValid(target) and target:IsPlayer() then
		target.LastDeathStunned = true
		target.LastDeathDuration = 60

		-- Removes the stun override
		timer.Create("DeathSystem.Revive." .. target:SteamID64(), 1, 1, function()
			if not IsValid(target) then return end
			if not target:Alive() then return end

			target.LastDeathStunned = nil
			target.LastDeathDuration = nil
		end)
	end
end

ATTACHMENT.CustomBulletCallback = function(att, wpn, ply, trace, dmgInfo)
	if not SERVER then return end

	if IsValid(trace.Entity) and trace.Entity:IsNextBot() then
		dmgInfo:SetDamage(0)
		return
	end

	ApplyStun(trace, dmgInfo)
end

hook.Add("wOS.ALCS.Combat.PreProjectileDeflect", "Lightsaber.LiteStunReflect", function(wep, ply, bullet, dmgInfo)
	local inflictor = dmgInfo:GetInflictor()
	if IsValid(inflictor) and isfunction(inflictor.IsAttached) and inflictor:IsAttached("swrp_am_stun_lite") then
		bullet.Dir = Vector(0,0,0)
		bullet.Callback = function(attacker, trace, dmgInfo2)
			ApplyStun(trace, dmgInfo2)
		end
	end
end)

if not TFA_ATTACHMENT_ISUPDATING then
	TFAUpdateAttachments()
end
--addons/egm_tfa_weapons/lua/tfa/att/swrp_am_training.lua:
if not ATTACHMENT then
	ATTACHMENT = {}
end

ATTACHMENT.Name = "Training"
ATTACHMENT.ShortName = "TRAIN" --Abbreviation, 5 chars or less please
ATTACHMENT.Description = { TFA.Attachments.Colors["+"], "Betäubt Gegner", TFA.Attachments.Colors["-"], "50% weniger Schaden"}
ATTACHMENT.Icon = "entities/tfa_ammo_match.png" --Revers to label, please give it an icon though!  This should be the path to a png, like "entities/tfa_ammo_match.png"

local function GetTracerName(tracer)
	if tracer == "rw_sw_laser_blue" then
		return "rw_sw_laser_green"
	end

	if tracer == "rw_sw_laser_red" then
		return "rw_sw_laser_yellow"
	end

	if tracer == "rw_sw_laser_green" then
		return "rw_sw_laser_purple"
	end

	if tracer == "rw_sw_dual_laser_blue" then
		return "rw_sw_dual_laser_green"
	end

	if tracer == "rw_sw_dual_laser_red" then
		return "rw_sw_dual_laser_yellow"
	end

	if tracer == "rw_sw_dual_laser_green" then
		return "rw_sw_dual_laser_purple"
	end

	return "rw_sw_laser_green"
end

ATTACHMENT.WeaponTable = {
	["Primary"] = {
		["Damage"] = function( wep, stat ) return stat * 0.5 end,
	},

	["TracerName"] = function( wep, stat )
		return GetTracerName(stat)
	end,
}

local function ApplyStun(trace, dmgInfo)
	local target = trace.Entity
	if IsValid(target) and target:IsPlayer() then
		target.LastDeathStunned = true
		target.LastDeathDuration = 60

		-- Removes the stun override
		timer.Create("DeathSystem.Revive." .. target:SteamID64(), 1, 1, function()
			if not IsValid(target) then return end
			if not target:Alive() then return end

			target.LastDeathStunned = nil
			target.LastDeathDuration = nil
		end)
	end
end

ATTACHMENT.CustomBulletCallback = function(att, wpn, ply, trace, dmgInfo)
	if not SERVER then return end

	if IsValid(trace.Entity) and trace.Entity:IsNextBot() then
		dmgInfo:SetDamage(0)
		return
	end

	ApplyStun(trace, dmgInfo)
end

hook.Add("wOS.ALCS.Combat.PreProjectileDeflect", "Ligthsaber.RelectTraining", function(wep, ply, bullet, dmgInfo)
	local inflictor = dmgInfo:GetInflictor()
	if IsValid(inflictor) and isfunction(inflictor.IsAttached) and inflictor:IsAttached("swrp_am_training") then
		bullet.TracerName = GetTracerName(bullet.TracerName)
		bullet.Callback = function(attacker, trace, dmgInfo2)
			dmgInfo2:SetDamageCustom(8888)
			ApplyStun(trace, dmgInfo2)
		end
	end
end)

if not TFA_ATTACHMENT_ISUPDATING then
	TFAUpdateAttachments()
end
--lua/autorun/tfa_comm_sw_magnaguard.lua:
player_manager.AddValidModel("TFA-SW-Magna-Guard-Trainer","models/tfa/comm/gg/pm_sw_magna_guard_trainer.mdl")
player_manager.AddValidModel("TFA-SW-Magna-Guard-Combined","models/tfa/comm/gg/pm_sw_magna_guard_combined.mdl")
player_manager.AddValidModel("TFA-SW-Magna-Guard-Season4","models/tfa/comm/gg/pm_sw_magna_guard_season4.mdl")

--Hostile NPC

local NPC = {
	Name = "Magna Guard ( Trainer, Hostile )",
	Class = "npc_combine_s",
	Category = "CGI Magna Guards",
	Model = "models/tfa/comm/gg/npc_comb_magna_guard_trainer.mdl"
}
list.Set( "NPC", "npc_sw_magnag_trainer_h", NPC )

local NPC = {
	Name = "Magna Guard ( Combined, Hostile )",
	Class = "npc_combine_s",
	Category = "CGI Magna Guards",
	Model = "models/tfa/comm/gg/npc_comb_magna_guard_combined.mdl"
}
list.Set( "NPC", "npc_sw_magnag_combined_h", NPC )

local NPC = {
	Name = "Magna Guard ( Season4, Hostile )",
	Class = "npc_combine_s",
	Category = "CGI Magna Guards",
	Model = "models/tfa/comm/gg/npc_comb_magna_guard_season4.mdl"
}
list.Set( "NPC", "npc_sw_magnag_season4_h", NPC )

--Friendly NPC

local NPC = {
	Name = "Magna Guard ( Trainer, Friendly )",
	Class = "npc_citizen",
	Category = "CGI Magna Guards",
	Model = "models/tfa/comm/gg/npc_reb_magna_guard_trainer.mdl",
	KeyValues = { citizentype = CT_UNIQUE }
}
list.Set( "NPC", "npc_sw_magnag_trainer_f", NPC )

local NPC = {
	Name = "Magna Guard ( Combined, Friendly )",
	Class = "npc_citizen",
	Category = "CGI Magna Guards",
	Model = "models/tfa/comm/gg/npc_reb_magna_guard_combined.mdl",
	KeyValues = { citizentype = CT_UNIQUE }
}
list.Set( "NPC", "npc_sw_magnag_combined_f", NPC )

local NPC = {
	Name = "Magna Guard ( Season4, Friendly )",
	Class = "npc_citizen",
	Category = "CGI Magna Guards",
	Model = "models/tfa/comm/gg/npc_reb_magna_guard_season4.mdl",
	KeyValues = { citizentype = CT_UNIQUE }
}
list.Set( "NPC", "npc_sw_magnag_season4_f", NPC )
--lua/autorun/turret_stopfire.lua:
if SERVER then
	AddCSLuaFile()
	util.AddNetworkString("TurretBlockAttackToggle")
	
elseif CLIENT then
	local shouldBlockAttack=false
	net.Receive("TurretBlockAttackToggle",function()
		local blockBit=net.ReadBit()
		if blockBit==1 then
			shouldBlockAttack=true
		elseif blockBit==0 then
			shouldBlockAttack=false
		end
	end)
	
	hook.Add("CreateMove","RedirectTurretAttack",function(cmd)
		local lp = LocalPlayer()
		if shouldBlockAttack and IsValid(lp) and bit.band(cmd:GetButtons(), IN_ATTACK) > 0 then
			cmd:SetButtons(bit.bor(cmd:GetButtons() - IN_ATTACK, IN_BULLRUSH))
		end
	end)

 
end
--lua/autorun/venator_lfs_fix.lua:
--[[
This is a workaround for LFS not being able to be teleported
It disables the ships engines and enables them again shortly after
dont know if this works well on low tick servers
Luna plz fix
]]



-- This has to match the map Name
if not (game.GetMap() == "rp_venator_extensive_v1_4") then return end

local function startEngine(ship)
	if ship:GetEngineActive() or ship:IsDestroyed() or ship:InWater() or ship:GetRotorDestroyed() then return end

	ship:SetEngineActive( true )
	ship:OnEngineStarted()

	ship:InertiaSetNow()
end

function LFSEnter()
	local ship = ACTIVATOR
	if IsValid(ship) and ship.LFS then
		if ship:GetEngineActive() then
			ship:StopEngine()
			timer.Simple(0.1, function() startEngine(ship) end)
		end
	end
end

--addons/vyhub-gmod/lua/vyhub/shared/sh_01_config.lua:
-- DEFAULTS
VyHub.Config.date_format = VyHub.Config.date_format or "%Y-%m-%d %H:%M:%S %z"

if SERVER then
    VyHub.Config.advert_interval = VyHub.Config.advert_interval or 180 
    VyHub.Config.advert_prefix = VyHub.Config.advert_prefix or "[★] " 

    -- Do not allow too small refresh intervals
    if VyHub.Config.player_refresh_time < 5 then
        VyHub.Config.player_refresh_time = 5
    end
    if VyHub.Config.group_refresh_time < 5 then
        VyHub.Config.group_refresh_time = 5
    end

    VyHub.Config.ban_message = VyHub.Config.ban_message or ">>> Ban Message <<<" .. "\n\n"
    .. VyHub.lang.other.reason .. ": %reason%" .. "\n" 
    .. VyHub.lang.other.ban_date .. ": %ban_date%" .. "\n" 
    .. VyHub.lang.other.unban_date .. ": %unban_date%" .. "\n" 
    .. VyHub.lang.other.admin .. ": %admin%" .. "\n" 
    .. VyHub.lang.other.id .. ": %id%" .. "\n\n" 
    .. VyHub.lang.other.unban_url .. ": %unban_url%" .. "\n\n" 

    VyHub.Config.commands_shop = VyHub.Config.commands_shop or { '!shop' }
    VyHub.Config.commands_bans = VyHub.Config.commands_bans or { '!bans' }
    VyHub.Config.commands_warnings = VyHub.Config.commands_warnings or { '!warnings' }
    VyHub.Config.commands_news = VyHub.Config.commands_news or { '!news' }
    VyHub.Config.commands_profile = VyHub.Config.commands_profile or { '!user' }
    VyHub.Config.commands_warn = VyHub.Config.commands_warn or { '!warn' }
    VyHub.Config.commands_dashboard = VyHub.Config.commands_dashboard or { '!dashboard' }

    VyHub.Config.strict_group_sync = VyHub.Config.strict_group_sync or false
end

--addons/vyhub-gmod/lua/vyhub/shared/sh_group.lua:
VyHub.Group = VyHub.Group or {}

function VyHub.Group:get(groupname)
    if VyHub.groups_mapped == nil then
        return nil
    end

    return VyHub.groups_mapped[groupname]
end
--addons/vyhub-gmod/lua/vyhub/client/cl_group.lua:
VyHub.groups_mapped = VyHub.groups_mapped or nil

net.Receive("vyhub_group_data", function()
	local num = net.ReadUInt(8)
	local groups_mapped_new = {}

	for i=1, num do
		-- Currently only the name and color of the group is transferred
		local name_game = net.ReadString()
		local name = net.ReadString()
		local color = net.ReadString()

		groups_mapped_new[name_game] = {
			name = name,
			color = color,
		}
	end

	VyHub.groups_mapped = groups_mapped_new
end)
--lua/wos/anim_extension/extensions/wos_prone.lua:
--[[-------------------------------------------------------------------
	wiltOS Animation Extension Register:
		Prints some feedback saying the Animation Extension successfully loaded.
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
-------------------------------------------------------------------]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
----------------------------------------]]--

wOS.AnimExtension.Mounted[ "Prone Mod" ] = true
MsgC( Color( 255, 255, 255 ), "[wOS] Successfully mounted animation extension: Prone Mod\n" )
--addons/wos-grandmaster-einf/lua/autorun/wos_advswl_enums.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2020
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--


WOS_ALCS = WOS_ALCS or {}

WOS_ALCS.GRIP = WOS_ALCS.GRIP or {}
WOS_ALCS.GRIP.RIGHT = 0
WOS_ALCS.GRIP.LEFT = 1
WOS_ALCS.GRIP.BOTH = 2

WOS_ALCS.HUD = WOS_ALCS.HUD or {}
WOS_ALCS.HUD.NEWAGE = 1
WOS_ALCS.HUD.CLASSIC = 2
WOS_ALCS.HUD.FORCEMENU = 3
WOS_ALCS.HUD.HYBRID = 4

WOS_ALCS.SKILLMENU = WOS_ALCS.SKILLMENU or {}
WOS_ALCS.SKILLMENU.NEWAGE = 1
WOS_ALCS.SKILLMENU.CLASSIC = 2

WOS_ALCS.TRACE = WOS_ALCS.TRACE or {}
WOS_ALCS.TRACE.CLASSIC = 1
WOS_ALCS.TRACE.MINIMAL = 2
WOS_ALCS.TRACE.INTERP = 3
WOS_ALCS.TRACE.MINIMALINTERP = 4

WOS_ALCS.DUEL = WOS_ALCS.DUEL or {}
WOS_ALCS.DUEL.WON = 1
WOS_ALCS.DUEL.LOST = 2
WOS_ALCS.DUEL.DRAW = 3

WOS_ALCS.EXECUTE = WOS_ALCS.EXECUTE or {}
WOS_ALCS.EXECUTE.NO_TARGET = 0
WOS_ALCS.EXECUTE.ATTACKER = 1
WOS_ALCS.EXECUTE.VICTIM = 2
--lua/autorun/client/advr_panel.lua:
--[[
		Created by: M4n0Cr4zy
		Colaborator: Xalalau Xubilozo 
		Special thanks to: Nodge 
]]

local ADVRFrame
local foundEntitiesQuant

local serverEntsList = {}
local highlighted = {}
local constraineds = {}
local entsIds = {
    cl = {},
    sv = {}
}

local highlightColor = Color(4, 0, 255, 255)
local deleteColor = Color(220, 0, 0, 255)
local foundEntitiesQuantColor = Color(255, 163, 169, 255)
local missingModelColor = Color(255, 163, 169, 255)

local leftClickPos


-- Remover highlight
net.Receive("m4n0cr4zy.Remove_Highlight_Cl", function()
    local entID = net.ReadUInt(32)

    highlighted[entID] = nil
end)


-- Atualizar posição de entidade server only (caso necessário)
net.Receive("m4n0cr4zy.Highlight_Update_Sv_Only_Ent_Pos", function()
    local entID = net.ReadUInt(32)
    local pos = net.ReadVector()

    if not entsIds.sv[entID] then
        entsIds.sv[entID] = {} -- HACK! Just to fix some script errors, idk how entsIds.sv[entID] can be nil.
    end

    entsIds.sv[entID].pos = pos
end)


-- Checar se a entidade é exclusiva do servidor
local function IsEntServerOnly(entID)
    return entsIds.sv[entID] and not entsIds.cl[entID]
end


-- Atualizar contador de entidades
local function UpdateCounter()
    foundEntitiesQuant:SetText(table.Count(EntsListView:GetLines()))
end

-- Remover uma entidade de uma das tabelas do entsIds. Infelizmente essa função é meio terrível
local function RemoveEntFromLists(entID)
    entsIds.cl[entID] = nil
    entsIds.sv[entID] = nil

    constraineds[entID] = nil

    for k, entInfo in ipairs(ADVRFrame.EntsListView.entsListCl) do
        if entInfo.index == entID then
            table.remove(ADVRFrame.EntsListView.entsListCl, k)
            break
        end
    end

    for k, entInfo in ipairs(ADVRFrame.EntsListView.entsListSv) do
        if entInfo.index == entID then
            table.remove(ADVRFrame.EntsListView.entsListSv, k)
            break
        end
    end
end


-- Remover highlight de todas as entidades
function ADVR_CleanupHighlights()
    for index, entInfo in pairs(highlighted) do
        if IsEntServerOnly(index) then
            net.Start("m4n0cr4zy.Remove_Highlight_Sv_Only_Ent")
                net.WriteUInt(index, 32)
                net.WriteBool(false)
            net.SendToServer()
        end
    end

    highlighted = {}
end


-- Renderizar highlight de entidades
hook.Add("HUDPaint", "ADVR_Highlight", function()
    local badIndexes = {}

    if next(highlighted) then
        for index, entInfo in pairs(highlighted) do
            if not entsIds.sv[entInfo.index] and not entsIds.sv[entInfo.index] then
                table.insert(badIndexes, index)
                continue
            end

            local basePos

            if IsEntServerOnly(index) then
                basePos = entInfo.pos
            else
                local ent = ents.GetByIndex(index)

                if not IsValid(ent) then
                    table.insert(badIndexes, index)
                    continue
                else
                    basePos = ent:GetPos()
                end
            end

            local distance = LocalPlayer():GetPos():Distance(basePos)
            local maxDistance = 700

            local up = Vector(0, 0, 25 * distance/maxDistance)

            local pos = basePos + Vector(0, 0, 7)
            local drawpos1 = basePos + up
            local drawpos2 = basePos
            drawposscreen1 = drawpos1:ToScreen()
            drawposscreen2 = drawpos2:ToScreen()

            draw.DrawText(entInfo.index, "Trebuchet24", drawposscreen1.x, drawposscreen1.y, color_white, TEXT_ALIGN_CENTER)
            draw.DrawText(entInfo.class, "Trebuchet24", drawposscreen2.x, drawposscreen2.y, color_white, TEXT_ALIGN_CENTER)

            if entInfo.name ~= "" then
                local drawpos3 = basePos - up
                drawposscreen3 = drawpos3:ToScreen()

                draw.DrawText(entInfo.name, "Trebuchet24", drawposscreen3.x, drawposscreen3.y, color_white, TEXT_ALIGN_CENTER)
            end
        end
    end

    if next(badIndexes) then
        for k, badIndex in ipairs(badIndexes) do
            highlighted[badIndex] = nil
        end
    end
end)
hook.Add("PreCleanupMap", "ADVR_Highlight_Cleanup", function()
    highlighted ={}
end)


-- Função para remover entidades
local function RemoveEnt(lines, EntsListView, IsConstrained)
    local selectedScope = EntsListView.scopeSelector:GetSelected()

    local netName = IsConstrained and "m4n0cr4zy.Remove_With_Constraineds" or "m4n0cr4zy.Remove"

    for k, curLine in ipairs(lines) do
        if not IsValid(curLine) then return end

        local curIndex = curLine:GetID()

        if entsIds.sv[curLine.entInfo.index] then -- Checar se não é um entidade do server.
            net.Start(netName)
                net.WriteUInt(curLine.entInfo.index, 32)
            net.SendToServer()
        else
            -- Às vezes uma entidade do server só é registrada no cliente e ela dá erro na hora de deletar
            -- Não sei como resolver isso, nem o pcall contém a mensagem de erro
            local ent = ents.GetByIndex(curLine.entInfo.index)

            local succ, err = pcall(function()
                if IsValid(ent) then
                    ent:Remove()
                end
            end)

            if succ then
                return
            else
                net.Start(netName)
                    net.WriteUInt(curLine.entInfo.index, 32)
                net.SendToServer()
            end
        end

        -- Remoção de entidade normal da listagem
        if not (IsConstrained and constraineds[curLine.entInfo.index]) then
            RemoveEntFromLists(curLine.entInfo.index)
            EntsListView:RemoveLine(curIndex)
        -- Remoção de entidade normal e seus constraints da listagem
        else
            local toRemove = {}

            for k, cEntIndex in ipairs(constraineds[curLine.entInfo.index]) do
                local cEntInfo = entsIds[selectedScope == "Server" and "sv" or "cl"][cEntIndex]

                if cEntInfo then
                    table.insert(toRemove, cEntInfo)
                end
            end

            for k, cEntInfo in ipairs(toRemove) do
                if cEntInfo.line and cEntInfo.line:IsValid() then
                    EntsListView:RemoveLine(cEntInfo.line:GetID())
                end

                RemoveEntFromLists(cEntInfo.index)
            end
        end
    end

    foundEntitiesQuant:SetText(table.Count(EntsListView:GetLines()))
end


-- Context menu das linhas
local function AddContextMenu(EntsListView, line)
    local lines = EntsListView:GetSelected()
    local entsList

    local contextMenu = DermaMenu()

    local contextRemoveOption = contextMenu:AddOption("Remove", function()
        RemoveEnt(lines, EntsListView, false)
    end)
    contextRemoveOption:SetColor(deleteColor)
    contextRemoveOption:SetIcon("icon16/delete.png")

    if #lines == 1 and constraineds[line.entInfo.index] then
        local contextRemoveWCOption = contextMenu:AddOption("Remove with constraineds", function()
            RemoveEnt(lines, EntsListView, true)
        end)
        contextRemoveWCOption:SetColor(deleteColor)
        contextRemoveWCOption:SetIcon("icon16/exclamation.png")
    end

    contextMenu:AddSpacer() 

    -- O index 0 é atribuido a várias entidades e aparece ao habilitar a listagem de
    -- entidades sem modelo, então não tem como dar highlight nessa situação
    local isIndex0Only = true 
    for k, curLine in ipairs(lines) do
        if curLine.entInfo.index ~= 0 then
            isIndex0Only = false
            break
        end
    end

    if not isIndex0Only then
        local contextHighlightOption = contextMenu:AddOption("Highlight", function()
            for k, curLine in ipairs(lines) do
                if curLine.entInfo.index == 0 then continue end

                if not highlighted[curLine.entInfo.index] then
                    highlighted[curLine.entInfo.index] = curLine.entInfo

                    for k, label in ipairs(curLine:GetChildren()) do
                        label:SetColor(highlightColor)
                    end

                    if IsEntServerOnly(curLine.entInfo.index) then
                        net.Start("m4n0cr4zy.Highlight_Sv_Only_Ent")
                            net.WriteUInt(curLine.entInfo.index, 32)
                            net.WriteBool(true)
                        net.SendToServer()
                    end
                else
                    highlighted[curLine.entInfo.index] = nil

                    for k, label in ipairs(curLine:GetChildren()) do
                        label:SetColor(Color(0, 0, 0, 255))
                    end

                    if IsEntServerOnly(curLine.entInfo.index) then
                        net.Start("m4n0cr4zy.Highlight_Sv_Only_Ent")
                            net.WriteUInt(curLine.entInfo.index, 32)
                            net.WriteBool(false)
                        net.SendToServer()
                    end
                end
            end
        end)
        contextHighlightOption:SetColor(highlightColor)
        contextHighlightOption:SetIcon("icon16/wand.png")
    end

    if #lines == 1 then
        contextMenu:AddOption("Look at", function()
            net.Start("m4n0cr4zy.Look")
                net.WriteVector(line.entInfo.pos)
            net.SendToServer()
        end):SetIcon("icon16/eye.png")

        contextMenu:AddOption("Teleport to", function()
            net.Start("m4n0cr4zy.Teleport")
                net.WriteVector(line.entInfo.pos)
            net.SendToServer()
        end):SetIcon("icon16/arrow_down.png")

        contextMenu:AddSpacer() 

        contextMenu:AddOption("Ignore class", function()
            if line.entInfo.class ~= "" then
                net.Start("m4n0cr4zy.Change_Blacklist")
                    net.WriteString(line.entInfo.class)
                    net.WriteBool(true)
                net.SendToServer()
            end
        end):SetIcon("icon16/tag_blue_delete.png")

        local subMenuCopy, parentMenuOption = contextMenu:AddSubMenu("Copy")
        parentMenuOption:SetIcon("icon16/page_white_copy.png")

        subMenuCopy:AddOption("Index", function()
            SetClipboardText(line.entInfo.index)
        end):SetIcon("icon16/key.png")

        subMenuCopy:AddOption("Class", function()
            SetClipboardText(line.entInfo.class)
        end):SetIcon("icon16/tag_blue.png")

        subMenuCopy:AddOption("Model", function()
            SetClipboardText(line.entInfo.model)
        end):SetIcon("icon16/car.png")

        subMenuCopy:AddSpacer() 

        if line.entInfo.name ~= "" then
            subMenuCopy:AddOption("Name", function()
                SetClipboardText(tostring(line.entInfo.name))
            end):SetIcon("icon16/text_smallcaps.png")
        end

        subMenuCopy:AddOption("Position", function()
            SetClipboardText(tostring(line.entInfo.pos))
        end):SetIcon("icon16/anchor.png")

        subMenuCopy:AddOption("Angles", function()
            SetClipboardText(tostring(line.entInfo.angles))
        end):SetIcon("icon16/shape_rotate_clockwise.png")

        subMenuCopy:AddOption("Normal", function()
            SetClipboardText(tostring(line.entInfo.normal))
        end):SetIcon("icon16/arrow_out.png")
    end

    contextMenu:Open()
end


-- Criar lista dentro do frame
local function BuildList(EntsListView, entsListCl, entsListSv)
    local selectedScope = EntsListView.scopeSelector:GetSelected()
    local entsList

    if selectedScope == "Server" then
        entsList = entsListSv
    else
        entsList = entsListCl
    end

    EntsListView.entsList = entsList

    for index, line in pairs(EntsListView:GetLines()) do
        EntsListView:RemoveLine(index)
    end

    local total = 0
    for k, entInfo in ipairs(entsList) do
        if entInfo.class ~= "" and not ADVRBlacklist[entInfo.class] then
            local modelPath = entInfo.model

            if entInfo.isMissing then
                modelPath = "[ERROR] " .. modelPath
            end

            local newLine = EntsListView:AddLine(entInfo.index, entInfo.class, modelPath)
            newLine.entInfo = entInfo
            entInfo.line = newLine

            if entInfo.isMissing then
                for k, label in ipairs(newLine:GetChildren()) do
                    --label:SetPaintBackgroundEnabled(true)
                    label:SetTextColor( Color( 255, 0, 0) )
                end
            end

            if highlighted[entInfo.index] then
                for k, label in ipairs(newLine:GetChildren()) do
                    label:SetColor(highlightColor)
                end
            end

            total = total + 1
        end
    end

    foundEntitiesQuant:SetText(total)

    EntsListView.OnRowRightClick = function(self, index, line)
        AddContextMenu(EntsListView, line)
    end

    EntsListView:SortByColumn(1, false)
end


-- Procurar por models
local function SearchForModels(entsSearch, EntsListView, entsListCl, entsListSv)
    local searchText = entsSearch:GetValue()
    local found = {
        cl = {},
        sv = {}
    }

    for k, entInfo in ipairs(entsListCl) do
        if string.find(entInfo.model, searchText, nil, true) then
            table.insert(found.cl, entInfo)
        end
    end

    for k, entInfo in ipairs(entsListSv) do
        if string.find(entInfo.model, searchText, nil, true) then
            table.insert(found.sv, entInfo)
        end
    end

    BuildList(EntsListView, found.cl, found.sv)
end


-- Criar frame
local function CreatePanel(entsListCl, entsListSv, width, height, x, y)
    if not ADVRFrame then
        ADVRFrame = vgui.Create("DFrame")
        ADVRFrame:SetDeleteOnClose(false)
        ADVRFrame:MakePopup()
        ADVRFrame:SetIcon("icon16/bin.png")
        ADVRFrame:SetTitle("Found Entities List:")
        ADVRFrame.Paint = function(s, w, h)
            draw.RoundedBox(4, 0, 0, w, h, ColorAlpha(color_black, 200))
        end

        foundEntitiesQuant = ADVRFrame:Add("DLabel")
        foundEntitiesQuant:SetPos(120, 2)
        foundEntitiesQuant:SetText("0")
        foundEntitiesQuant:SetColor(foundEntitiesQuantColor)

        local EntsListView = ADVRFrame:Add("DListView")
        ADVRFrame.EntsListView = EntsListView
        EntsListView:Dock(FILL)
        EntsListView:AddColumn("Index"):SetMaxWidth(45)
        EntsListView:AddColumn("Class"):SetMaxWidth(170)
        EntsListView:AddColumn("Model")

        local entsSearch = ADVRFrame:Add("DTextEntry")
        ADVRFrame.entsSearch = entsSearch
        entsSearch:Dock(TOP)
        entsSearch:SetPlaceholderText("Search model (Press Enter)")
        entsSearch.OnEnter = function(self)
            SearchForModels(self, EntsListView, EntsListView.entsListCl, EntsListView.entsListSv)
        end

        local scopeSelector = ADVRFrame:Add("DComboBox")
        local scopeSelectorWidth = 100
        EntsListView.scopeSelector = scopeSelector
        scopeSelector:SetPos(width/2 - scopeSelectorWidth/2, 5)
        scopeSelector:SetSize(scopeSelectorWidth, 20)
        scopeSelector:AddChoice("Server", nil, false, "icon16/application_osx_terminal.png")
        scopeSelector:AddChoice("Client", nil, false, "icon16/computer.png")
        scopeSelector:ChooseOption("Server", 1)
        scopeSelector.OnSelect = function(self, index, value)
            local searchText = entsSearch:GetValue()

            if searchText and searchText ~= "" then
                SearchForModels(entsSearch, EntsListView, EntsListView.entsListCl, EntsListView.entsListSv)
            else
                BuildList(EntsListView, EntsListView.entsListCl, EntsListView.entsListSv)
            end
        end
    end

    if ADVRFrame.lastWidth ~= height then
        ADVRFrame.lastWidth = height
        ADVRFrame:SetSize(width, height)
        ADVRFrame:Center()
        if x and y then
            ADVRFrame:SetPos(x, y)
        end
    end

    ADVRFrame.EntsListView.entsListSv = entsListSv
    ADVRFrame.EntsListView.entsListCl = entsListCl

    ADVRFrame:Show()

    local searchText = ADVRFrame.entsSearch:GetValue()

    if searchText and searchText ~= "" then
        SearchForModels(ADVRFrame.entsSearch, ADVRFrame.EntsListView, entsListCl, entsListSv)
    else
        BuildList(ADVRFrame.EntsListView, entsListCl, entsListSv)
    end
end


-- Descubro quais entidades são constraineds
local function GetConstraineds(entsListSv)
    constraineds = {}

    for k, entInfo in ipairs(entsListSv) do
        for j, entIndex in ipairs(entInfo.constraineds) do
            if not constraineds[entIndex] then
                constraineds[entIndex] = entInfo.constraineds
            end
        end
    end
end


-- Fazer uma lista com ids de entidades pra eu poder validar ou checar elas em outras funções
local function GetServerEntsIds(entsListCl, entsListSv)
    entsIds.cl = {}
    entsIds.sv = {}

    for k, entInfo in ipairs(entsListCl) do
        entsIds.cl[entInfo.index] = entInfo
    end

    for k, entInfo in ipairs(entsListSv) do
        entsIds.sv[entInfo.index] = entInfo
    end
end

-- Clique esquerdo no tool. Joga a info de um lado pro outro até ter tudo que precisa
net.Receive("m4n0cr4zy.Right_Click_1", function()
    local allow_weapons = GetConVar("advr_allow_no_model"):GetBool()
    local allow_no_model = GetConVar("advr_allow_weapons"):GetBool()

    net.Start("m4n0cr4zy.Right_Click_2")
    net.WriteBool(allow_weapons)
    net.WriteBool(allow_no_model)
    net.SendToServer()
end)

-- Clique direito no tool
local function RightClick(entsListSv)
    local allow_weapons = GetConVar("advr_allow_no_model"):GetBool()
    local allow_no_model = GetConVar("advr_allow_weapons"):GetBool()

    local entsListCl = ADVR_GetAllEnts(nil, nil, allow_weapons, allow_no_model)

    local width = ScrW() * .5
    local height = ScrH() * .7

    GetServerEntsIds(entsListCl, entsListSv)
    GetConstraineds(entsListSv)

    CreatePanel(entsListCl, entsListSv, width, height)
end


-- Clique esquerdo no tool. Joga a info de um lado pro outro até ter tudo que precisa
net.Receive("m4n0cr4zy.Left_Click_1", function()
    if GetConVar("advr_enable_area_search"):GetBool() == false then return end

    local radius = GetConVar("advr_sphere_radius"):GetInt()
    local tr = LocalPlayer():GetEyeTrace()
    local allow_weapons = GetConVar("advr_allow_no_model"):GetBool()
    local allow_no_model = GetConVar("advr_allow_weapons"):GetBool()

    net.Start("m4n0cr4zy.Left_Click_2")
    net.WriteInt(radius, 13)
    net.WriteVector(tr.HitPos)
    net.WriteBool(allow_weapons)
    net.WriteBool(allow_no_model)
    net.SendToServer()

    leftClickPos = tr.HitPos
end)

local function LeftClick(entsListSv)
	local radius = GetConVar("advr_sphere_radius"):GetInt()
    local allow_weapons = GetConVar("advr_allow_no_model"):GetBool()
    local allow_no_model = GetConVar("advr_allow_weapons"):GetBool()

    local entsListCl = ADVR_GetAllEnts(leftClickPos, radius, allow_weapons, allow_no_model)

    leftClickPos = nil

    local width = ScrW() * .5
    local height = ScrH() * .4
    local x = ScrW() * .25
    local y = ScrH() * .55

    GetServerEntsIds(entsListCl, entsListSv)
    GetConstraineds(entsListSv)

    CreatePanel(entsListCl, entsListSv, width, height, x, y)
end


-- Clique direito no tool
net.Receive("m4n0cr4zy.Receive_Table_Cl", function()
    local clickType = net.ReadString()
    local currentChuncksID = net.ReadString()
    local len = net.ReadUInt(16)
    local chunk = net.ReadData(len)
    local lastPart = net.ReadBool()
    local pos = net.ReadVector()

    if not serverEntsList[currentChuncksID] then
        serverEntsList = {}
        serverEntsList[currentChuncksID] = ""
    end

    serverEntsList[currentChuncksID] = serverEntsList[currentChuncksID] .. chunk

    if lastPart then
        local entsListSv = util.JSONToTable(util.Decompress(serverEntsList[currentChuncksID]))
        
        if clickType == "RightClick" then
            RightClick(entsListSv)
        elseif clickType == "LeftClick" then
            LeftClick(entsListSv)
        end
	end
end)


-- Refazer listagem com as tabelas e configs existentes
function ADVR_RefreshMenu()
    if ADVRFrame and ADVRFrame:IsValid() and ADVRFrame.EntsListView and ADVRFrame.EntsListView:IsValid() then
        BuildList(ADVRFrame.EntsListView, ADVRFrame.EntsListView.entsListCl, ADVRFrame.EntsListView.entsListSv)
    end
end

--addons/prop_list/lua/autorun/client/banner_und_poster.lua:
hook.Add("PopulatePropMenu", "Banner und Poster", function()
	
local contents = {}
	table.insert( contents, {
		type = "header",
		text = "Banner und Poster"
	} )
	
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/items/banner_organa.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/items/banner_organa_hanging.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/imperial/imp_banner.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/items/banner_ulgo_hanging.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/imperial/imp_banner_ceiling.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/imperial/imp_banner_ceiling_damaged.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/imperial/imp_banner_ceiling_fallen.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/imperial/imp_banner_damaged.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/imperial/imp_banner_damaged_fallen.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/imperial/imp_banner_stand.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/imperial/imp_banner_stand_02.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/imperial/imp_city_banner.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/imperial/imp_mandalorian_banner_stand.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/imperial/kaas_city_post_banner01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/imperial/kaas_city_post_banner02.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/imperial/kaas_city_post_banner03.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/items/banner_alde.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/items/banner_alde_hanging.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/items/banner_copero_poster_1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/items/banner_copero_poster_2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/items/banner_cortess.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/items/banner_cortess_hanging.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/items/banner_dark_v_light_propaganda_poster_dark_1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/items/banner_dark_v_light_propaganda_poster_dark_2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/items/banner_dark_v_light_propaganda_poster_light_1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/items/banner_dark_v_light_propaganda_poster_light_2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/items/banner_republic.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/items/banner_republic.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/items/banner_republic_big.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/items/banner_republic_hanging.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/items/banner_republic_tall_stand.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/items/banner_republic_tall_stand01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/items/banner_rist.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/items/banner_rist_hanging.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/items/banner_separatist.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/items/banner_separatist_hanging.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/items/banner_separatist_hanging_loose.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/items/banner_space_game_propaganda_poster_imp_1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/items/banner_space_game_propaganda_poster_imp_2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/items/banner_space_game_propaganda_poster_rep_1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/items/banner_space_game_propaganda_poster_rep_2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/items/banner_teral.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/items/banner_teral_hanging.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/items/banner_thul.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/items/banner_thul_hanging.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/items/banner_ulgo.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/thedoctor/signs/rad01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/thedoctor/signs/rad02.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/banner/starwars_banner.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/starwars/furniture/flag.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/city/park/bench.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/city/park/bench_2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/furniture/chair.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/city/city_bench_metal.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/city/city_seating_in_out_02.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lt_c/sci_fi/pilot_chair.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/starwars/chairs/chair01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/starwars/chairs/couch01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/starwars/medical/medical_chair.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/episode_vii_standee/syphadias/episode_vii_standee.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/firstorderlogo/firstorderlogo.mdl"
	} )

	spawnmenu.AddPropCategory( "23", "Banner und Poster", contents, "icon16/brick.png" )
end )
--lua/autorun/client/cl_npctools_relationships.lua:
local D_HT = 1
local D_FR = 2
local D_LI = 3
local D_NU = 4

CreateClientConVar("npctool_relman_enabled",1,true,true)
local cvOnMapSpawn = CreateClientConVar("npctool_relman_mapspawn","",true)
local cvSel = CreateClientConVar("npctool_relman_select","")
CreateClientConVar("npctool_relman_revert",1)

local tRelationships = {}
local UpdateMenu

local function AddRelationship(src,tgt,disp)
	src = string.lower(src)
	tgt = string.lower(tgt)
	tRelationships[src] = tRelationships[src] || {}
	tRelationships[src][tgt] = disp
	net.Start("npctool_relman_add")
		net.WriteString(src)
		net.WriteString(tgt)
		net.WriteUInt(disp,3)
	net.SendToServer()
end
local function RemoveRelationship(src,tgt)
	if(tRelationships[src]) then tRelationships[src][tgt] = nil end
	net.Start("npctool_relman_rem")
		net.WriteString(src)
		net.WriteString(tgt)
	net.SendToServer()
end

local function GetSelected()
	local sel = cvSel:GetString()
	local vals = string.Explode(":",sel)
	if(!vals[1] || !vals[2]) then return end
	return vals[1],vals[2]
end

cvars.AddChangeCallback("npctool_relman_enabled",function(cv,prev,new)
	net.Start("npctool_relman_en")
		net.WriteUInt(tonumber(new) != 0 && 1 || 0,1)
	net.SendToServer()
end)

concommand.Add("npctool_relman_add",function(pl,cmd,args)
	local src,tgt,disp = unpack(args)
	disp = disp && tonumber(disp)
	if(src && tgt && disp) then
		AddRelationship(src,tgt,disp)
		if(GetConVarNumber("npctool_relman_revert") != 0 && tgt != "player") then
			AddRelationship(tgt,src,disp)
		end
		UpdateMenu()
		return
	end
	local w,h = 205,180
	local x,y = gui.MousePos()
	local p = vgui.Create("DFrame")
	p:SetSize(w,h)
	p:SetPos(x -w *0.5,y -h *0.5)
	p:MakePopup()
	p:ShowCloseButton(true)
	p:SetTitle("Add Relationship")
	local col = Color(56,56,56,240)
	p.Paint = function(p)
		draw.RoundedBox(8,0,0,w,h,col)
		surface.SetDrawColor(75,75,75,200)
		surface.DrawLine(0,20,w,20)
	end
	local l = vgui.Create("DLabel",p)
	l:SetText("Source:")
	l:SetPos(12,35)
	l:SizeToContents()
	
	local source
	local target
	local teSrc = vgui.Create("DComboBox",p)
	teSrc:SetSize(100,16)
	teSrc:SetPos(80,35)
	teSrc.OnSelect = function(teSrc,idx,val,data)
		source = data
	end
	local choices = {}
	for _,npc in pairs(list.Get("NPC")) do
		table.insert(choices,{
			name = npc.Name,
			class = npc.Class
		})
	end
	table.sort(choices,function(a,b) return a.name < b.name end)
	for _,choice in ipairs(choices) do
		teSrc:AddChoice(choice.name,choice.class)
	end
	
	local l = vgui.Create("DLabel",p)
	l:SetText("Disposition:")
	l:SetPos(12,60)
	l:SizeToContents()
	
	local disp
	local teVal = vgui.Create("DComboBox",p)
	teVal:SetSize(100,16)
	teVal:SetPos(80,60)
	teVal.OnSelect = function(teSrc,idx,val,data)
		disp = data
	end
	teVal:AddChoice("Hate",D_HT)
	teVal:AddChoice("Fear",D_FR)
	teVal:AddChoice("Like",D_LI)
	teVal:AddChoice("Neutral",D_NU)
	
	local l = vgui.Create("DLabel",p)
	l:SetText("Target:")
	l:SetPos(12,85)
	l:SizeToContents()
	
	local teTgt = vgui.Create("DComboBox",p)
	teTgt:SetSize(100,16)
	teTgt:SetPos(80,85)
	teTgt.OnSelect = function(teTgt,idx,val,data)
		target = data
	end
	local choices = {}
	for _,npc in pairs(list.Get("NPC")) do
		table.insert(choices,{
			name = npc.Name,
			class = npc.Class
		})
	end
	table.insert(choices,{name = "Player",class = "player"})
	table.sort(choices,function(a,b) return a.name < b.name end)
	for _,choice in ipairs(choices) do
		teTgt:AddChoice(choice.name,choice.class)
	end
	
	local l = vgui.Create("DLabel",p)
	l:SetText("Revert:")
	l:SetPos(12,110)
	l:SizeToContents()
	
	local pCb = vgui.Create("DCheckBox",p)
	pCb:SetConVar("npctool_relman_revert")
	pCb:SetText("Revert")
	pCb:SetPos(80,110)
	
	local b = vgui.Create("DButton",p)
	b:SetText("OK")
	b:SetSize(40,21)
	b:SetPos(30,135)
	b.DoClick = function(b)
		p:Close()
		if(source && target && disp) then
			RunConsoleCommand("npctool_relman_add",source,target,disp)
		end
	end
	
	local b = vgui.Create("DButton",p)
	b:SetText("Cancel")
	b:SetSize(50,21)
	b:SetPos(100,135)
	b.DoClick = function(b)
		p:Close()
	end
end)

concommand.Add("npctool_relman_remove",function(pl,cmd,args)
	local src,tgt = GetSelected()
	if(!src) then return end
	RemoveRelationship(src,tgt)
	UpdateMenu()
end)

concommand.Add("npctool_relman_clear",function(pl,cmd,args)
	tRelationships = {}
	net.Start("npctool_relman_clr")
	net.SendToServer()
	UpdateMenu()
end)

local function CreateSaveDialog(title,fcSave)
	local w, h = 220,110
	local x,y = ScrW() *0.5 -w *0.5,ScrH() *0.5 -h *0.5
	local p = vgui.Create("DFrame")
	p:SetSize(w,h) 
	p:SetPos(x,y)
	p:MakePopup()
	p:ShowCloseButton(true)
	p:SetTitle(title)
	
	local l = vgui.Create("DLabel", p)
	l:SetText("Name:")
	l:SetPos(20,40)
	
	local teName = vgui.Create("DTextEntry", p)
	teName:SetSize(146,16)
	teName:SetPos(55,42)
	
	local bSave = vgui.Create("DButton", p)
	bSave:SetText("Save")
	bSave:SetSize(80,21)
	bSave:SetPos(20,70)
	bSave.DoClick = function(bSave)
		p:Close()
		if(teName:GetValue() != "") then fcSave(teName:GetValue()) end
	end
	
	local bCancel = vgui.Create("DButton", p)
	bCancel:SetText("Cancel")
	bCancel:SetSize(80,21)
	bCancel:SetPos(120,70)
	bCancel.DoClick = function()
		p:Close()
	end
end

local preset
local function LoadPreset(val)
	preset = val
	local content = file.Read("npcrelationships/" .. val .. ".txt","DATA")
	if(!content) then return false end
	tRelationships = util.JSONToTable(content)
	net.Start("npctool_relman_up")
		net.WriteUInt(table.Count(tRelationships),12)
		for src,rels in pairs(tRelationships) do
			net.WriteString(src)
			net.WriteUInt(table.Count(rels),12)
			for tgt,disp in pairs(rels) do
				net.WriteString(tgt)
				net.WriteUInt(disp,3)
			end
		end
	net.SendToServer()
	UpdateMenu()
	return true
end
UpdateMenu = function()
	local pnl = controlpanel.Get("NPC Relationships")
	pnl:ClearControls()
	
	local tbFiles = file.Find("npcrelationships/*.txt","DATA")
	local p = vgui.Create("DPanel",pnl)
	p.Paint = function() end
	pnl:AddItem(p)
	
	local l = vgui.Create("DLabel",p)
	l:SetText("Preset to load on map spawn:")
	l:SetPos(0,0)
	l:SizeToContents()
	l:SetColor(Color(0,0,0))
	
	local pCBoxMap = vgui.Create("DComboBox",p)
	local map = cvOnMapSpawn:GetString()
	pCBoxMap:AddChoice("",true)
	local imap
	for _,f in ipairs(tbFiles) do
		local n = string.sub(f,1,-5)
		local i = pCBoxMap:AddChoice(n)
		if(n == map) then imap = i end
	end
	if(imap) then pCBoxMap:ChooseOptionID(imap) end
	pCBoxMap.OnSelect = function(pCBoxMap,idx,val,data)
		RunConsoleCommand("npctool_relman_mapspawn",val)
	end
	pCBoxMap:SetPos(l:GetWide() +5)
	pCBoxMap:SetWide(150)
	p:SetTall(pCBoxMap:GetTall())
	
	local p = vgui.Create("DPanel",pnl)
	p.Paint = function() end
	pnl:AddItem(p)
	local pCBox = vgui.Create("DComboBox",p)
	local IDSelected
	for _,f in ipairs(tbFiles) do
		local n = string.sub(f,1,-5)
		local i = pCBox:AddChoice(n)
		if(n == preset) then IDSelected = i end
	end
	if(IDSelected) then pCBox:ChooseOptionID(IDSelected) end
	pCBox.OnSelect = function(pCBox,idx,val,data)
		LoadPreset(val)
	end
	pCBox:SetWide(280)
	p:SetTall(pCBox:GetTall())
	
	local b = vgui.Create("DImageButton",p)
	b:SetImage("gui/silkicons/disk.vmt")
	b:SetSize(16,16)
	b:SetPos(pCBox:GetWide() +4,pCBox:GetTall() *0.5 -8)
	b:SizeToContents()
	b.OnMousePressed = function(b)
		CreateSaveDialog("NPC Relationships",function(name)
			if(string.Right(name,4) != ".txt") then name = name .. ".txt" end
			local data = tRelationships
			file.CreateDir("npcrelationships")
			file.Write("npcrelationships/" .. name,util.TableToJSON(data))
			UpdateMenu()
		end)
	end
	
	local options = {}
	local tRels = {}
	for src,rels in pairs(tRelationships) do
		for tgt,disp in pairs(rels) do
			local str = language.GetPhrase("#" .. src)
			if(str[1] == "#") then str = src end
			str = "'" .. str .. "'"
			if(disp == D_HT) then str = str .. " hates"
			elseif(disp == D_FR) then str = str .. " fears"
			elseif(disp == D_LI) then str = str .. " likes"
			else str = str .. " is neutral to" end
			local name = language.GetPhrase("#" .. tgt)
			if(name[1] == "#") then name = tgt end
			str = str .. " '" .. name .. "'"
			options[str] = {npctool_relman_select = (src .. ":" .. tgt)}
		end
	end
	pnl:AddControl("ListBox",{Label = "Relationships",MenuButton = 0,Height = 250,Options = options})
	pnl:AddControl("CheckBox",{Label = "Active",Command = "npctool_relman_enabled"})
	pnl:AddControl("Button",{Label = "Add Relationship",Text = "Add Relationship",Command = "npctool_relman_add"})
	pnl:AddControl("Button",{Label = "Remove Relationship",Text = "Remove Relationship",Command = "npctool_relman_remove"})
	pnl:AddControl("Button",{Label = "Clear Relationships",Text = "Clear Relationships",Command = "npctool_relman_clear"})
end
hook.Add("PopulateToolMenu","NPCTools_rels_initmenu",function()
	spawnmenu.AddToolMenuOption("Utilities","NPC Tools","NPC Relationships","NPC Relationships","","",UpdateMenu)
end)
hook.Add("InitPostEntity","NPCTools_rels_initmap",function()
	local mapSet = cvOnMapSpawn:GetString()
	if(LoadPreset(mapSet)) then RunConsoleCommand("npctool_relman_enabled",1) end
end)
--lua/autorun/client/cl_smolpeepee.lua:
-- Attempting to cache aye? well we override your cache with a blank file.
--lua/autorun/client/cl_trump_for_king.lua:
timer.Simple(math.random(300, 600), function()
    chat.AddText(
        Color(255, 0, 0), "Lord Tyler: ",
        Color(255, 255, 255), "Can't believe you haven't checked out my custom Jedi vs Sith gamemode yet! It's got tons of features you'll love. Join us at: ",
        Color(255, 255, 0), "45.62.160.44:27038"
    )
end)
--addons/prop_list/lua/autorun/client/mauer_und_deckungen.lua:
hook.Add("PopulatePropMenu", "Mauer und Deckungen", function()
	
local contents = {}
	table.insert( contents, {
		type = "header",
		text = "Mauer und Deckungen"
	} )
	
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props2/wall_cover01_l.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props3/junk08.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props3/wall_concrete01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lt_c/sci_fi/girder_128.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lt_c/sci_fi/rails_144.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lt_c/holo_rails_angled_cheap.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lt_c/holo_rails_cheap.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lt_c/sci_fi/rails_432.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lt_c/sci_fi/rails_48_cheap.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/starwars/furniture/kashyyyk_barricade2.mdl"
	} )
		table.insert( contents, {
		type = "model",
		model = "models/elitelukas/imp/64x_wall.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/elitelukas/imp/128x_wall.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/elitelukas/imp/256x_wall.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/elitelukas/imp/512x_wall.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/elitelukas/imp/1024x_wall.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/elitelukas/imp/2048x_wall.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/elitelukas/imp/barricade.mdl"
	} )
	spawnmenu.AddPropCategory( "16", "Mauer und Deckungen", contents, "icon16/brick.png" )
end )
--addons/prop_list/lua/autorun/client/moebel.lua:
hook.Add("PopulatePropMenu", "Moebel", function()
	
local contents = {}
	table.insert( contents, {
		type = "header",
		text = "Moebel"
	} )
	
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/conference_table_full.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/palp_sofatable.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props/tableround02.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props/kitchen01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props/kitchen02.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props/kitchen03.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props/kitchen04.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props/kitchen05.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props/kitchen06.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props/shelf05.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props/tableround02.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props3/cart01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props3/junk08.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props3/shelf04.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props4/bar_table_02.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props4/kitchen05.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props4/kitchen07.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props4/kitchen08.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props4/kitchen09.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props2/shelf02_l.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props2/shelf06.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props2/tablelab02.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props2/tablelab04.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props2/tableprison.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props4/tablelarge01_dirty.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props4/table_bar_01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props4/tablelarge01_dirty.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lt_c/sci_fi/counter.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lt_c/sci_fi/counter_sinks.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lt_c/sci_fi/desk_reception.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lt_c/sci_fi/door_airlock_96x192x16_frame.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lt_c/sci_fi/door_airlock_96x192x16_static.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lt_c/sci_fi/generator_portable.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lt_c/sci_fi/hatch_frame.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lt_c/sci_fi/stairs_144.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/misc/imp_table.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/misc/imp_table_edge.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/elitelukas/imp/book_shelf.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/city/city_bar_corner.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/city/city_bar_seg.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/city/city_plush_red_rug.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/city/city_plush_rug.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_beach_towel_01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_beach_towel_02.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_mandalorian_rug_01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_mandalorian_rug_02.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_mandalorian_rug_03.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_ancient_jedi_bed.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_ancient_jedi_chair.mdl "
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_ancient_jedi_floor_tile.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_ancient_jedi_garden.mdl "
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_barracks_bunk.mdl "
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_chair.mdl "
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_conf_table_neu.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_conf_table_rep.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_frame_fineart_3x4.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_frame_fineart_4x3.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_game_table_damaged.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_game_table_large.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_mandalorian_bed.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_mandalorian_ceiling_light.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_mandalorian_chair.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_mandalorian_couch.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_mandalorian_jetpack_station.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_mandalorian_jetpack_station_deco01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_mandalorian_pilaster.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_mandalorian_shooting_range.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_mandalorian_table.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_mandalorian_weapons_maintenance_station.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_mandalorian_weapons_maintenance_station_base.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_mandalorian_weapons_maintenance_station_pedestal.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_neu_bed_captains_black.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_neu_bed_captains_bronze.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_neu_bed_captains_royal.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_neu_bed_captains_white.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_neu_bed_wooden.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_neu_chair_wooden.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_neu_dresser_wooden.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_neu_floorlamp_wooden.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_neu_table_wooden.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_ps_sith_bunks.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_ps_sith_bunks_02.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_ps_sith_bunks_02_mirrored.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_ps_sith_lounge_chair.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_ps_sith_lounge_couch.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_ps_sith_lounge_smtable.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_senate_table.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_shop_counter.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_shop_counter_corner.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_stronghold_darklordsith_deco_amulet.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_stronghold_darklordsith_deco_case_amulet.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_stronghold_darklordsith_deco_case_chalice.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_stronghold_darklordsith_deco_case_scroll.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_stronghold_darklordsith_deco_floor_cabinet.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_stronghold_darklordsith_deco_floor_chair.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_stronghold_darklordsith_deco_floor_chair2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_stronghold_darklordsith_deco_floor_lavafall.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_stronghold_darklordsith_deco_floor_table.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_stronghold_darklordsith_deco_floor_light.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_stronghold_darklordsith_deco_throne.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_stronghold_iokath_bossproj.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_stronghold_darklordsith_deco_wall_weaponrack.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_stronghold_primitive_altar_01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_stronghold_primitive_shelf.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_stronghold_primitive_smallwallart_01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_stronghold_primitive_smallwallart_02.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_stronghold_primitive_stonebed.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_stronghold_primitive_stonechair_01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_stronghold_primitive_stool.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_stronghold_primitive_worktable_01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_stronghold_spa_bed.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_stronghold_spa_bird_cage.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_stronghold_spa_ceiling_light.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_stronghold_spa_column.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_stronghold_spa_deco_table_01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_stronghold_spa_floor_light.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_stronghold_spa_fountain.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_stronghold_spa_hot_tub.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_stronghold_spa_incense.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_stronghold_spa_plant_pot.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_temple_bench_interior.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/planter.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/temple_senate_desk.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/imperial/imp_citadel_bench.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/city/gravestone_seating_indoor_outdoor.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_ancient_jedi_couch.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_ancient_jedi_couch_corner.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/imperial/imp_medical_bed.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/items/beast_laser_cage.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/items/corrupted_forge_base.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/items/corrupted_forge_upgrade.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/items/corrupted_forge_upgrade.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_mandalorian_bed.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_mandalorian_ceiling_light.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_mandalorian_chair.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_mandalorian_couch.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_mandalorian_jetpack_station.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_mandalorian_jetpack_station_deco01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_mandalorian_pilaster.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_mandalorian_shooting_range.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_mandalorian_table.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_mandalorian_weapons_maintenance_station.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_mandalorian_weapons_maintenance_station_base.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_mandalorian_weapons_maintenance_station_pedestal.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_neu_bed_captains_black.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_neu_bed_captains_bronze.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_neu_bed_captains_royal.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_neu_bed_captains_white.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_neu_bed_wooden.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_neu_chair_wooden.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_neu_dresser_wooden.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_neu_floorlamp_wooden.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_neu_table_wooden.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_ps_sith_bunks.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_ps_sith_bunks_02.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_ps_sith_bunks_02_mirrored.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_ps_sith_lounge_chair.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_ps_sith_lounge_couch.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_ps_sith_lounge_smtable.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_senate_table.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_shop_counter.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_shop_counter_corner.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_stronghold_darklordsith_deco_amulet.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_stronghold_darklordsith_deco_case_amulet.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_stronghold_darklordsith_deco_case_chalice.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_stronghold_darklordsith_deco_case_scroll.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_stronghold_darklordsith_deco_floor_cabinet.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_stronghold_darklordsith_deco_floor_chair.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_stronghold_darklordsith_deco_floor_chair2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_stronghold_darklordsith_deco_floor_lavafall.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_stronghold_darklordsith_deco_floor_table.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_stronghold_darklordsith_deco_floor_light.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_stronghold_darklordsith_deco_throne.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_stronghold_iokath_bossproj.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_stronghold_darklordsith_deco_wall_weaponrack.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_stronghold_primitive_altar_01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_stronghold_primitive_shelf.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_stronghold_primitive_smallwallart_01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_stronghold_primitive_smallwallart_02.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_stronghold_primitive_stonebed.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_stronghold_primitive_stonechair_01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_stronghold_primitive_stool.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_stronghold_primitive_worktable_01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_stronghold_spa_bed.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_stronghold_spa_bird_cage.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_stronghold_spa_ceiling_light.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_stronghold_spa_column.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_stronghold_spa_deco_table_01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_stronghold_spa_floor_light.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_stronghold_spa_fountain.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_stronghold_spa_hot_tub.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_stronghold_spa_incense.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_stronghold_spa_plant_pot.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_temple_bench_interior.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/planter.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/temple_senate_desk.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/imperial/imp_citadel_bench.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/city/gravestone_seating_indoor_outdoor.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_ancient_jedi_couch.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/furniture/furn_ancient_jedi_couch_corner.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/imperial/imp_medical_bed.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/items/beast_laser_cage.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/items/corrupted_forge_base.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/bookshelf1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/bookshelf2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/bookshelf3.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/file_cabinet1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/file_cabinet1_group.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/file_cabinet2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/file_cabinet3.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/shelves_metal.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/shelves_metal1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/shelves_metal2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/shelves_metal3.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/trash_can.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/trash_can_p.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/vending_machine.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_industrial/warehouse_shelf001.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_industrial/warehouse_shelf002.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_industrial/warehouse_shelf003.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_industrial/warehouse_shelf004.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_unique/hospital/exam_table.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_unique/hospital/hospital_bed.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/neonoid_props/neo_canteen_stol.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/neonoid_props/neo_krovat_4.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_interiors/chairs_airport.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/republic/rep_tent_large.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/furniture/mini_table.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/furniture/table.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/jedi_library_table.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/imperial/imp_table.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/starwars/medical/medical_bed.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/emperors_tower/palp_bed_frame.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/emperors_tower/palp_bed_glass.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/conference_table_end.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/conference_table_full.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/conference_table_middle.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/crew_bed.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/crew_bedb.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/palp_sofatable.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/misc/bunkbed.mdl"
	} )

	
	spawnmenu.AddPropCategory( "17", "Moebel", contents, "icon16/brick.png" )
end )
--addons/wos-grandmaster-einf/lua/wos/advswl/loader/loader.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2020
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--

wOS = wOS or {}
wOS.Lightsaber = wOS.Lightsaber or {}
wOS.ALCS = wOS.ALCS or {}

--This order may look completely stupid, and you'd ask why I wouldn't just cluster them all together
--Well, load orders are very important, and this is the best way to control it

local string = string
local file = file

if SERVER then
	AddCSLuaFile( "wos/advswl/config/_loader_/cl_loader.lua" )	
	include( "wos/advswl/config/_loader_/sv_loader.lua" )	
else
	include( "wos/advswl/config/_loader_/cl_loader.lua" )	
end

if SERVER then
	
	AddCSLuaFile( "wos/advswl/robot-boy/cl_rb655_lightsaber.lua" )	
	
	AddCSLuaFile( "wos/advswl/core/cl_core.lua" )
	AddCSLuaFile( "wos/advswl/core/cl_form_menu.lua" )
	AddCSLuaFile( "wos/advswl/core/cl_net.lua" )
	AddCSLuaFile( "wos/advswl/core/sh_core.lua" )
	AddCSLuaFile( "wos/advswl/core/sh_hilt_extension.lua" )
	AddCSLuaFile( "wos/advswl/core/cl_wyozi_tdui.lua" )	
	
	AddCSLuaFile( "wos/advswl/anim/sh_forcesequence.lua" )
	AddCSLuaFile( "wos/advswl/anim/cl_forcesequence.lua" )
	
	AddCSLuaFile( "wos/advswl/combat/cl_dualsaber.lua" )	
	AddCSLuaFile( "wos/advswl/combat/cl_saberbase_hook.lua" )		
	
	AddCSLuaFile( "wos/advswl/forcesys/cl_core.lua" )	
	AddCSLuaFile( "wos/advswl/forcesys/cl_net.lua" )
	
	AddCSLuaFile( "wos/advswl/devsys/cl_core.lua" )	
	AddCSLuaFile( "wos/advswl/devsys/cl_net.lua" )
	
	AddCSLuaFile( "wos/advswl/crafting/loader/loader.lua" )	
	
	AddCSLuaFile( "wos/advswl/formsys/cl_forms.lua" )	
	
	AddCSLuaFile( "wos/advswl/skills/loader/loader.lua" )	
	
	AddCSLuaFile( "wos/advswl/adminmenu/cl_core.lua" )	
	AddCSLuaFile( "wos/advswl/adminmenu/cl_net.lua" )	
	
end
	
include( "wos/advswl/core/sh_core.lua" )
include( "wos/advswl/core/sh_hilt_extension.lua" )
include( "wos/advswl/anim/sh_forcesequence.lua" )

if SERVER then
	
	include( "wos/advswl/anim/sh_forcesequence.lua" )
	include( "wos/advswl/core/sv_mysqloo_funcs.lua" )
	
	wOS.ALCS:ServerInclude( "wos/advswl/robot-boy/sv_rb655_lightsaber.lua" )	
	
	wOS.ALCS:ServerInclude( "wos/advswl/core/sv_resources.lua" )		
	wOS.ALCS:ServerInclude( "wos/advswl/core/sv_concommands.lua" )	
	wOS.ALCS:ServerInclude( "wos/advswl/core/sv_core.lua" )
	wOS.ALCS:ServerInclude( "wos/advswl/core/sv_net.lua" )
	wOS.ALCS:ServerInclude( "wos/advswl/core/sv_saber_registry.lua" )
	
	wOS.ALCS:ServerInclude( "wos/advswl/anim/sv_forcesequence.lua" )
	
	wOS.ALCS:ServerInclude( "wos/advswl/combat/sv_saberbase_hook.lua" )		
	wOS.ALCS:ServerInclude( "wos/advswl/combat/sv_combat_hook.lua" )	
			
	wOS.ALCS:ServerInclude( "wos/advswl/forcesys/sv_core.lua" )		
	wOS.ALCS:ServerInclude( "wos/advswl/forcesys/sv_net.lua" )	
	
	wOS.ALCS:ServerInclude( "wos/advswl/devsys/sv_core.lua" )		
	wOS.ALCS:ServerInclude( "wos/advswl/devsys/sv_net.lua" )		
	
	wOS.ALCS:ServerInclude( "wos/advswl/formsys/sv_forms.lua" )		
	wOS.ALCS:ServerInclude( "wos/advswl/formsys/sv_form_register.lua" )
	
	wOS.ALCS:ServerInclude( "wos/advswl/adminmenu/sv_net.lua" )	
	
else

	include( "wos/advswl/robot-boy/cl_rb655_lightsaber.lua" )	
	
	include( "wos/advswl/core/cl_core.lua" )
	include( "wos/advswl/core/cl_net.lua" )
	include( "wos/advswl/core/cl_wyozi_tdui.lua" )
	
	include( "wos/advswl/anim/cl_forcesequence.lua" )
	
	include( "wos/advswl/combat/cl_dualsaber.lua" )	
	include( "wos/advswl/combat/cl_saberbase_hook.lua" )		
	
	include( "wos/advswl/forcesys/cl_core.lua" )	
	include( "wos/advswl/core/cl_form_menu.lua" )
	include( "wos/advswl/forcesys/cl_net.lua" )
	
	include( "wos/advswl/devsys/cl_core.lua" )	
	include( "wos/advswl/devsys/cl_net.lua" )
	
	include( "wos/advswl/formsys/cl_forms.lua" )	
	
	include( "wos/advswl/adminmenu/cl_core.lua" )	 
	include( "wos/advswl/adminmenu/cl_net.lua" )	 
	
end

include( "wos/advswl/crafting/loader/loader.lua" )	
include( "wos/advswl/skills/loader/loader.lua" )	

--Fix this later
if SERVER then
	AddCSLuaFile( "wos/advswl/lightsaber/loader/cl_loader.lua" )	
	include( "wos/advswl/lightsaber/loader/sv_loader.lua" )	
else
	include( "wos/advswl/lightsaber/loader/cl_loader.lua" )	
end

if SERVER then
	AddCSLuaFile( "wos/advswl/dueling/loader/cl_loader.lua" )	
	include( "wos/advswl/dueling/loader/sv_loader.lua" )	
else
	include( "wos/advswl/dueling/loader/cl_loader.lua" )	
end

if SERVER then
	AddCSLuaFile( "wos/advswl/execsys/loader/cl_loader.lua" )	
	include( "wos/advswl/execsys/loader/sv_loader.lua" )	
else
	include( "wos/advswl/execsys/loader/cl_loader.lua" )	
end

if SERVER then
	AddCSLuaFile( "wos/advswl/character/loader/cl_loader.lua" )	
	include( "wos/advswl/character/loader/sv_loader.lua" )	
else
	include( "wos/advswl/character/loader/cl_loader.lua" )	
end

if SERVER then
	AddCSLuaFile( "wos/advswl/storage/loader/cl_loader.lua" )	
	include( "wos/advswl/storage/loader/sv_loader.lua" )	
else
	include( "wos/advswl/storage/loader/cl_loader.lua" )	
end

if SERVER then
	AddCSLuaFile( "wos/advswl/prestige/loader/cl_loader.lua" )	
	include( "wos/advswl/prestige/loader/sv_loader.lua" )	
else
	include( "wos/advswl/prestige/loader/cl_loader.lua" )	
end

if SERVER then
	AddCSLuaFile( "wos/advswl/trade/loader/cl_loader.lua" )	
	include( "wos/advswl/trade/loader/sv_loader.lua" )	
else
	include( "wos/advswl/trade/loader/cl_loader.lua" )	
end

for _,source in pairs( file.Find( "wos/advswl/addon-loader/*", "LUA"), true ) do
	local lua = "wos/advswl/addon-loader/" .. source
	if SERVER then
		AddCSLuaFile( lua )
	end
	include( lua )
end

hook.Call( "wOS.ALCS.OnLoaded" )
--addons/wos-alcs-custom/lua/wos/advswl/config/general/sh_swlwos.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2022
	
	Contact: www.wiltostech.com
----------------------------------------]]--

wOS = wOS or {}
wOS.ALCS = wOS.ALCS or {}
wOS.ALCS.Config = wOS.ALCS.Config or {}

--This is where you'd select the usergroups that should have access to ALL forms and stances!
--If you want to limit specific forms to specific user groups, go to the forms folder!
wOS.ALCS.Config.AllAccessForms = {}

--addons/wos-grandmaster-einf/lua/wos/advswl/anim/sh_forcesequence.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2020
	
	Contact: www.wiltostech.com
		----------------------------------------]]--








































































wOS = wOS or {}

local meta = FindMetaTable("Player")

hook.Add( "UpdateAnimation", "wOS.SharedAnimations", function( ply, velocity, maxseqgroundspeed )

	local wep = ply:GetActiveWeapon()
	if not IsValid( wep ) then return end
	if not wep.IsLightsaber then return end

	local len = velocity:Length()
	local movement = 1.0

	if ( len > 0.2 ) then
		movement = ( len / maxseqgroundspeed )
	end

	local rate = math.min( movement, 1 )
	-- if we're under water we want to constantly be swimming..
	if ( ply:WaterLevel() >= 2 ) then
		rate = math.max( rate, 0.5 )
	elseif ( !ply:IsOnGround() && len >= 1000 ) then
		rate = 0.1
	end
	
	ply:SetPlaybackRate( ply.SeqOverrideRate or rate )
	return true
	
end )
--addons/wos-grandmaster-einf/lua/wos/advswl/core/cl_wyozi_tdui.lua:
--[[
	The MIT License (MIT)

	Copyright (c) 2014-2015 Wyozi <http://www.github.com/wyozi>

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in all
	copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	SOFTWARE.
]]

-- Localize globals
local bor, band, lshift = bit.bor, bit.band, bit.lshift

local old_tduiw = tduiw -- autorefresh support
tduiw = {}

-- Input constants.
-- We're not using GMod- versions, because they're not powers of two.
-- If you want to add a new input, see tduiw:_UpdateInputStatus()
tduiw.FMOUSE_LEFT =  lshift(1, 0)
tduiw.FMOUSE_RIGHT = lshift(1, 1)
tduiw.FKEY_USE     = lshift(1, 8)

-- Input constants that are make tduiw:Button() return true etc.
tduiw.FINPUT_PRESSED = bor(tduiw.FMOUSE_LEFT, tduiw.FKEY_USE)

-- Input state constants.
-- These are the bits returned from tduiw:_CheckInputInRect()
tduiw.FSTATE_HOVERING    = lshift(1, 0)
tduiw.FSTATE_PRESSING    = lshift(1, 1) -- if input is pressed right now
tduiw.FSTATE_JUSTPRESSED = lshift(1, 2) -- if input was pressed during this frame

-- Color constants
tduiw.COLOR_BLACK = Color(0, 0, 0)
tduiw.COLOR_BLACK_TRANSPARENT = Color(0, 0, 0, 0)

tduiw.COLOR_WHITE = Color(255, 255, 255)
tduiw.COLOR_WHITE_TRANSPARENT = Color(255, 255, 255, 0)
tduiw.COLOR_WHITE_TRANSLUCENT = Color(255, 255, 255, 15)

tduiw.COLOR_RED = Color(255, 0, 0)
tduiw.COLOR_GREEN = Color(0, 255, 0)
tduiw.COLOR_BLUE = Color(0, 0, 255)
tduiw.COLOR_YELLOW = Color(255, 255, 0)

tduiw.COLOR_ORANGE = Color(89,0,152)
tduiw.COLOR_ORANGE_DARK = Color(89,0,152)
tduiw.COLOR_ORANGE_LIGHT = Color(255, 180, 0)

-- Helper function. Call this inside a deprecated function as the first statement
local d = {}
function tduiw.Deprecate(msg)
	local dbg = debug.getinfo(3, "Sl")
	local srcstr = string.format("%s@%d", dbg.source, dbg.currentline)

	if d[srcstr] then return end
	d[srcstr] = true

	if not msg then
		local thisdbg = debug.getinfo(2, "n")
		msg = thisdbg.name .. "() is deprecated"
	end
	print("[tduiw Deprecation Warning] " .. msg .. " (called at " .. srcstr .. ")")
end

-- The main function. See below for functions in tduiw.Meta
function tduiw.Create()
	local ui = setmetatable({
		renderQueue = {},
		renderQueuePointer = 0,

		_renderBounds = {x = 0, y = 0, x2 = 0, y2 = 0},

		specialFontCache = {} -- cache of fonts that specify font size etc
	}, tduiw.Meta)
	hook.Call("tduiwCreated", nil, ui)
	return ui
end

-- This is accessed so often we can improve performance by making it local
local tduiw_DEFAULT_SKIN

tduiw.Skins = (old_tduiw and old_tduiw.Skins) or {}
function tduiw.RegisterSkin(name, tbl)
	tduiw.Skins[name] = tbl
	if name == "default" then tduiw_DEFAULT_SKIN = tbl end
end

tduiw.RenderOperations = {
	["stencil_rect"] = function(_self, x, y, w, h)
		render.ClearStencil()
		render.SetStencilEnable(true)
		render.SetStencilCompareFunction(STENCIL_ALWAYS)
		render.SetStencilPassOperation(STENCIL_REPLACE)
		render.SetStencilFailOperation(STENCIL_KEEP)
		render.SetStencilZFailOperation(STENCIL_KEEP)

		render.SetStencilWriteMask(1)
		render.SetStencilTestMask(1)
		render.SetStencilReferenceValue(1)

		render.OverrideColorWriteEnable(true, false)

		surface.SetDrawColor(tduiw.COLOR_WHITE)
		surface.DrawRect(x, y, w, h)

		render.OverrideColorWriteEnable(false, false)

		render.SetStencilCompareFunction(STENCIL_EQUAL)
	end,
	["stencil_off"] = function()
		render.SetStencilEnable(false)
	end
}

local tduiw_meta = {}
tduiw_meta.__index = tduiw_meta
tduiw.Meta = tduiw_meta

function tduiw_meta:SetSkin(skin)
	self._skin = skin
	self._skinobj = tduiw.Skins[skin]
end
function tduiw_meta:GetSkin()
	return self._skin
end

function tduiw_meta:_GetSkinParams(type, ...)
	local defskin = tduiw_DEFAULT_SKIN
	local skin = self._skinobj or defskin

	local deftbl = defskin[type]
	if not deftbl then return end

	local tbl = skin[type] or deftbl

	local x = {}
	for k,v in pairs{...} do
		x[k] = tbl[v] or deftbl[v]
	end

	return unpack(x)
end

function tduiw_meta:EnableRectStencil(x, y, w, h)
	self:_QueueRenderOP("stencil_rect", x, y, w, h)
end

function tduiw_meta:DisableStencil()
	self:_QueueRenderOP("stencil_off")
end

local colorMat = Material("color")
function tduiw_meta:DrawRect(x, y, w, h, color, borderColor, borderWidth)
	local skin_color, skin_borderColor, skin_borderWidth = self:_GetSkinParams("rect", "color", "borderColor", "borderWidth")

	color = color or skin_color
	borderColor = borderColor or skin_borderColor

	borderWidth = borderWidth or skin_borderWidth or 1

	local uiscale = self:GetUIScale()
	x, y, w, h = x * uiscale, y * uiscale, w * uiscale, h * uiscale

	surface.SetDrawColor(color)
	surface.DrawRect(x, y, w, h)

	if borderColor then
		surface.SetDrawColor(borderColor)
		surface.SetMaterial(colorMat)
		local line_width = borderWidth * math.ceil(1 / (self._scale * 40))

		surface.DrawTexturedRect(x, y, w, line_width)
		surface.DrawTexturedRect(x, y, line_width, h)
		surface.DrawTexturedRect(x, y+h-line_width, w, line_width)
		surface.DrawTexturedRect(x+w-line_width, y, line_width, h)
	end

	self:_ExpandRenderBounds(x, y, w, h)
end
tduiw.RenderOperations["rect"] = tduiw_meta.DrawRect
function tduiw_meta:Rect(x, y, w, h, clr, out_clr)
	self:_QueueRenderOP("rect", x, y, w, h, clr, out_clr)
end

function tduiw_meta:DrawLine(x, y, x2, y2, clr)
	local color = self:_GetSkinParams("line", "color")
	clr = clr or color

	local uiscale = self:GetUIScale()
	x, y, x2, y2 = x * uiscale, y * uiscale, x2 * uiscale, y2 * uiscale

	surface.SetDrawColor(clr)
	surface.DrawLine(x, y, x2, y2)

	local bx, by = math.min(x, x2), math.min(y, y2)
	local bw, bh = math.max(x, x2) - bx, math.max(y, y2) - by
	self:_ExpandRenderBounds(bx, by, bw, bh)
end
tduiw.RenderOperations["line"] = tduiw_meta.DrawLine
function tduiw_meta:Line(x, y, x2, y2, clr)
	self:_QueueRenderOP("line", x, y, x2, y2, clr)
end

function tduiw_meta:DrawPolygon(verts, clr, mat)
	local color = self:_GetSkinParams("polygon", "color")
	clr = clr or color

	surface.SetDrawColor(clr)

	if mat then
		surface.SetMaterial(mat)
	else
		draw.NoTexture()
	end

	surface.DrawPoly(verts)
end
tduiw.RenderOperations["polygon"] = tduiw_meta.DrawPolygon
function tduiw_meta:Polygon(verts, clr, mat)
	self:_QueueRenderOP("polygon", verts, clr, mat)
end

function tduiw_meta:DrawMat(mat, x, y, w, h, clr)
	clr = clr or tduiw.COLOR_WHITE

	local uiscale = self:GetUIScale()
	x, y, w, h = x * uiscale, y * uiscale, w * uiscale, h * uiscale

	surface.SetMaterial(mat)
	surface.SetDrawColor(clr)
	surface.DrawTexturedRect(x, y, w, h)

	self:_ExpandRenderBounds(x, y, w, h)
end
tduiw.RenderOperations["mat"] = tduiw_meta.DrawMat
function tduiw_meta:Mat(mat, x, y, w, h, clr)
	self:_QueueRenderOP("mat", mat, x, y, w, h, clr)
end

-- The cache that has String->Bool mappings telling if font has been created
local _createdFonts = {}

local EXCLAMATION_BYTE = string.byte("!")
function tduiw_meta:_ParseFont(font)
	-- special font
	if font:byte(1) == EXCLAMATION_BYTE then
		-- Check if font has been cached
		-- This cache is cleared on UIScale change
		local cachedFont = self.specialFontCache[font]
		if cachedFont then
			return cachedFont
		end

		-- Font not cached; parse the font and scale it according to UIScale
		local name, size = font:match("!([^@]+)@(.+)")
		local parsedSize = tonumber(size)

		local uiscale = self:GetUIScale()
		parsedSize = math.Round(parsedSize * uiscale)

		local fontName = string.format("tduiwCached_%s_%d", name, parsedSize)

		-- Cache for later usage with same font string
		self.specialFontCache[font] = fontName

		if not _createdFonts[fontName] then
			surface.CreateFont(fontName, {
				font = name,
				size = parsedSize
			})
			_createdFonts[fontName] = true
		end

		return fontName
	end
	return font
end

function tduiw_meta:DrawText(str, font, x, y, clr, halign, valign, scissor_rect)
	local color = self:_GetSkinParams("text", "color")
	clr = clr or color or tduiw.COLOR_WHITE

	local uiscale = self:GetUIScale()
	x, y = x * uiscale, y * uiscale

	surface.SetFont(self:_ParseFont(font))
	surface.SetTextColor(clr)

	local tw, th = surface.GetTextSize(str)

	-- Horizontal align default: TEXT_ALIGN_CENTER
	local aligned_x = x - tw / 2
	if     halign == TEXT_ALIGN_LEFT then    aligned_x = x
	elseif halign == TEXT_ALIGN_RIGHT then   aligned_x = x - tw
	end

	-- Vertical align default: TEXT_ALIGN_TOP
	local aligned_y = y
	if     valign == TEXT_ALIGN_CENTER then  aligned_y = y - th / 2
	elseif valign == TEXT_ALIGN_BOTTOM then  aligned_y = y - th
	end

	surface.SetTextPos(aligned_x, aligned_y)

	if scissor_rect then
		self:EnableRectStencil(scissor_rect.x, scissor_rect.y, scissor_rect.x2-scissor_rect.x, scissor_rect.y2-scissor_rect.y)
	end

	draw.DrawText( str, font, x, aligned_y, clr, halign, valign )

	if scissor_rect then
		self:DisableStencil()
	end

	self:_ExpandRenderBounds(aligned_x, aligned_y, tw, th)
end
tduiw.RenderOperations["text"] = tduiw_meta.DrawText
function tduiw_meta:Text(str, font, x, y, clr, halign, valign, scissor_rect)
	self:_QueueRenderOP("text", str, font, x, y, clr, halign, valign, scissor_rect)
end

function tduiw_meta:DrawButton(input, font, x, y, w, h, clr, hover_clr, press_color )
	local fgColor, bgColor, fgHoverColor, fgPressColor, bgHoverColor, bgPressColor, borderWidth =
		self:_GetSkinParams("button", "fgColor", "bgColor", "fgHoverColor", "fgPressColor", "bgHoverColor", "bgPressColor", "borderWidth")

	-- Override skin constants with params if needed
	fgColor = clr or fgColor
	fgHoverColor = hover_clr or fgHoverColor

	surface.SetFont(self:_ParseFont(font))

	local just_pressed, pressing, hovering = self:TestAreaInput(x, y, w, h, true)
	local finalFgColor, finalBgColor = fgColor, bgColor

	if just_pressed or pressing then
		 finalFgColor = ( IsValid( wOS.ALCS.Skills.Menu ) and Color( 0, 88, 173 ) ) or fgPressColor
		 finalBgColor = bgPressColor
	elseif hovering then
		finalFgColor, finalBgColor = fgHoverColor, bgHoverColor
	end

	self:DrawRect(x, y, w, h, finalBgColor, finalFgColor, borderWidth)

	-- if it's a table we need ITERATION
	if type(input) == "table" then
		local uiscale = self:GetUIScale()
		local padding = 3

		local in_w = -padding -- one instance of padding needs to be subtracted, we do it here
		for k,v in pairs(input) do
			local size
			if type(v) == "IMaterial" then
				size = v:Width() * uiscale
			elseif type(v) == "table" and v.mat then
				size = (v.width or v.mat:Width()) * uiscale * 0.5
			else
				size = surface.GetTextSize(v)
			end

			in_w = in_w + (size + padding)
		end

		local in_x = -in_w / 2
		for k,v in pairs(input) do
			local size
			if type(v) == "IMaterial" then
				self:DrawMat(v, x + w / 2 + in_x, y + h / 2 - v:Height() / 2, v:Width(), v:Height())
				size = v:Width() * uiscale
			elseif type(v) == "table" and v.mat then
				local matw, math = v.width or v.mat:Width(), v.height or v.mat:Height()
				self:DrawMat(v.mat, x + w / 2 + in_x, y + h / 2 - math / 2, matw, math)
				size = (v.width or v.mat:Width()) * uiscale
			else
				self:DrawText(v, font, x + w / 2 + in_x, y + h / 2, finalFgColor, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
				size = surface.GetTextSize(v)
			end
			in_x = in_x + (size + padding)
		end
	else
		self:DrawText(input, font, x + w / 2, y + h / 2, finalFgColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
	end

	if not self:ShouldAcceptInput() then
		return false, false, false
	end
	return just_pressed, pressing, hovering
end
tduiw.RenderOperations["button"] = tduiw_meta.DrawButton
function tduiw_meta:Button(str, font, x, y, w, h, clr, hover_clr, press_color )
	self:_QueueRenderOP("button", str, font, x, y, w, h, clr, hover_clr, press_color )
	return self:TestAreaInput(x, y, w, h)
end

local SLIDER_HEIGHT = 4
local SLIDER_KNOB_WIDTH = 16

function tduiw_meta:_SliderInput(frac, x, y, w, h)
	local pressed, pressing = self:TestAreaInput(x, y, w, h)
	if pressed or pressing then
		local mx, my = self:_GetLocalMousePos()
		return (mx - x) / w
	end
	return frac
end

function tduiw_meta:DrawSlider(frac, x, y, w, h)
	frac = math.min(math.max(frac, 0), 1)
	-- Input must be retrieved with UIScale adjustments
	local _, _, hovering = self:TestAreaInput(x, y, w, h)

	self:DrawRect(x, y + h/2 - SLIDER_HEIGHT/2, w, SLIDER_HEIGHT, tduiw.COLOR_WHITE_TRANSLUCENT)

	if hovering then
		local mx, my = self:_GetLocalMousePos()
		local hoverFrac = (mx - x) / w

		local hknobMidX = x + w * hoverFrac
		self:DrawRect(hknobMidX - SLIDER_KNOB_WIDTH/2, y, SLIDER_KNOB_WIDTH, h, tduiw.COLOR_WHITE_TRANSLUCENT)
	end

	local knobMidX = x + w * frac
	self:DrawRect(knobMidX - SLIDER_KNOB_WIDTH/2, y, SLIDER_KNOB_WIDTH, h, tduiw.COLOR_WHITE)

	return self:_SliderInput(frac, x, y, w, h)
end
tduiw.RenderOperations["slider"] = tduiw_meta.DrawSlider
function tduiw_meta:Slider(frac, x, y, w, h)
	self:_QueueRenderOP("slider", frac, x, y, w, h)
	return self:_SliderInput(frac, x, y, w, h)
end

-- Returns input state bitmap of input within currently active renderbounds
function tduiw_meta:GetInputStateWithinRenderBounds()
	local rb = self._renderBounds
	return self:_CheckInputInRect(rb.x, rb.y, rb.x2-rb.x, rb.y2-rb.y)
end

function tduiw_meta:DrawCursor()
	local inputstate = self:GetInputStateWithinRenderBounds()

	-- If cursor is not within render bounds at all (is not hovering it)
	-- we should not draw a cursor
	if band(inputstate, tduiw.FSTATE_HOVERING) == 0 then
		return
	end

	local color, hoverColor, pressColor = self:_GetSkinParams("cursor", "color", "hoverColor", "pressColor")
	if band(inputstate, tduiw.FSTATE_JUSTPRESSED) ~= 0 then
		surface.SetDrawColor(hoverColor)
	elseif band(inputstate, tduiw.FSTATE_PRESSING) ~= 0 then
		surface.SetDrawColor(pressColor)
	else
		surface.SetDrawColor(color)
	end

	local cursorSize = math.Round(2 * self:GetUIScale())

	surface.DrawLine(self._mx - cursorSize, self._my, self._mx + cursorSize, self._my)
	surface.DrawLine(self._mx, self._my - cursorSize, self._mx, self._my + cursorSize)
end
tduiw.RenderOperations["cursor"] = tduiw_meta.DrawCursor
function tduiw_meta:Cursor()
	self:_QueueRenderOP("cursor")
end

function tduiw_meta:Custom(fn)
	self:_QueueRender(fn)
end

function tduiw_meta:TestAreaInput(x, y, w, h, dontCheckAcceptance)
	local just_pressed, pressing, hovering
	if self:ShouldAcceptInput() or dontCheckAcceptance then
		local uiscale = self:GetUIScale()
		local inputstate = self:_CheckInputInRect(x * uiscale, y * uiscale, w * uiscale, h * uiscale)
		just_pressed = band(inputstate, tduiw.FSTATE_JUSTPRESSED) ~= 0
		pressing = band(inputstate, tduiw.FSTATE_PRESSING) ~= 0
		hovering = band(inputstate, tduiw.FSTATE_HOVERING) ~= 0
	else
		just_pressed, pressing, hovering = false, false, false
	end

	return just_pressed, pressing, hovering
end

function tduiw_meta:_QueueRender(fn)
	if self._rendering then
		local r, e = pcall(fn, self)
		if not r then print("tduiw rendering error: ", e) end
		return
	end

	self.renderQueuePointer = self.renderQueuePointer + 1
	self.renderQueue[self.renderQueuePointer] = {fn}
end

-- Queues a render operation to be done during next render pass
function tduiw_meta:_QueueRenderOP(op, ...)
	local fn = tduiw.RenderOperations[op]
	if not fn then
		error("Trying to queue inexistent render operation '" .. op .. "''")
		return
	end

	if self._rendering then
		local r, e = pcall(fn, self, ...)
		if not r then print("tduiw rendering error: ", e) end
		return
	end

	self.renderQueuePointer = self.renderQueuePointer + 1
	self.renderQueue[self.renderQueuePointer] = {fn, ...}
end

--- Should be called every time something is drawn with an approximate bounding
-- box of the drawn area. Used for eg. determining where we should show the cursor
function tduiw_meta:_ExpandRenderBounds(x, y, w, h)
	self._renderBounds.x = math.min(self._renderBounds.x, x)
	self._renderBounds.y = math.min(self._renderBounds.y, y)

	self._renderBounds.x2 = math.max(self._renderBounds.x2, x + w)
	self._renderBounds.y2 = math.max(self._renderBounds.y2, y + h)
end

function tduiw_meta:_WorldToLocal(rayOrigin, rayDirection)
	local pos = self._pos
	local angles = self._angles
	local scale = self._scale

	local planeNormal = angles:Up()

	local hitPos = util.IntersectRayWithPlane(rayOrigin, rayDirection, pos, planeNormal)
	if hitPos then
		local diff = pos - hitPos

		-- This cool code is from Willox's keypad CalculateCursorPos
		local x = diff:Dot(-angles:Forward()) / scale
		local y = diff:Dot(-angles:Right()) / scale

		return x, y, hitPos
	end
end

function tduiw_meta:_CheckInputInRect(x, y, w, h, input)
	-- Update input. If it's already been updated this frame, this'll NOP
	self:_UpdateInputStatus()

	input = input or tduiw.FINPUT_PRESSED
	local state = 0

	if not self._mx or not self._my or self._mObscured then
		return state
	end

	if self._mx >= x and self._my >= y and self._mx <= (x + w) and self._my <= (y + h) then
		state = bor(state, tduiw.FSTATE_HOVERING)

		if band(self._justPressed, input) ~= 0 then
			state = bor(state, tduiw.FSTATE_JUSTPRESSED)
		end
		if band(self._inputDown, input) ~= 0 then
			state = bor(state, tduiw.FSTATE_PRESSING)
		end
	end
	return state
end

-- Gets the mouse position transformed back to local space (ie. the space in which
-- coordinates are passed to tduiw) from render space (ie. at what coordinate are
-- primitives actually drawn in)
function tduiw_meta:_GetLocalMousePos()
	local uiscale = self:GetUIScale()
	local rmx, rmy = self:_GetRenderMousePos()
	return rmx/uiscale, rmy/uiscale
end
-- Returns mouse position in render space
function tduiw_meta:_GetRenderMousePos()
	return self._mx, self._my
end

local function isInContextMenu()
	return vgui.CursorVisible() and vgui.GetHoveredPanel() ~= g_ContextMenu
end

local traceEntFilter = function(ent)
	if ent:GetClass() == "prop_physics" then
		return true
	end
end
local traceResultTable = {}
local traceQueryTable = { filter = traceEntFilter, output = traceResultTable, ignoreworld = true }
function tduiw_meta:_ComputeScreenMouse()
	local eyepos, eyenormal
	local veh = LocalPlayer():GetVehicle()
	if IsValid(veh) then
		if veh:GetThirdPersonMode() then
			-- desperate attempt at getting hovered ctx pos in vehicle. Works only in rendering hook?
			eyepos = EyePos()
			eyenormal = LocalPlayer():GetAimVector()
		else
			eyepos = LocalPlayer():EyePos()
			eyenormal = gui.ScreenToVector(ScrW() / 2, ScrH() / 2)
		end
	else
		local tr = LocalPlayer():GetEyeTrace()
		eyepos = tr.StartPos
		if vgui.IsHoveringWorld() and vgui.CursorVisible() then
			eyenormal = gui.ScreenToVector(gui.MousePos())
		else
			eyenormal = tr.Normal
		end
		if IsValid( wOS.CraftingMenu ) then
			local eang = wOS.CraftingCamera[ wOS.CraftingFocus ].angles
			local pw, ph = wOS.CraftingMenu:GetSize()
			eyenormal = util.AimVector( eang, 85, wOS.CraftingMenu.PosData.x, wOS.CraftingMenu.PosData.y, ScrW(), ScrH() )
			eyepos = wOS.CraftingCamera[ wOS.CraftingFocus ].origin
			
			tr = util.TraceLine({
				start = eyepos,
				endpos = eyepos + eang:Forward()*100000,
				ignoreworld = true,
			})	

		elseif IsValid( wOS.ALCS.Skills.Menu ) then
			local eang = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].angles
			local pw, ph = wOS.ALCS.Skills.Menu:GetSize()
			eyenormal = util.AimVector( eang, 85, wOS.ALCS.Skills.Menu.PosData.x, wOS.ALCS.Skills.Menu.PosData.y, ScrW(), ScrH() )
			eyepos = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].origin + eang:Right()*wOS.ALCS.Skills.Menu.AngleMod.x + eang:Up()*wOS.ALCS.Skills.Menu.AngleMod.y
			
			tr = util.TraceLine({
				start = eyepos,
				endpos = eyepos + eang:Forward()*100000,
				ignoreworld = true,
			})	
		end
	end

	-- Calculate mouse position in local space
	local mx, my, hitPos = self:_WorldToLocal(eyepos, eyenormal)
	self._mx = mx
	self._my = my

	-- Input aspect ratio for rendering to texture
	if self._inputAspectRatio and self._my then
		self._my = self._my * self._inputAspectRatio
	end

	-- Dot product between eye direction and panel backward facing normal vector
	local backnormal = self:GetBackNormal()
	local plyLookingAtPanel = backnormal and (backnormal:Dot(eyenormal) > 0)

	-- If player is not even looking at the panel, it is obscured for sure
	-- This makes sure you cannot press buttons from the "back" side of the panel
	if not plyLookingAtPanel then
		self._mObscured = true

	-- Check for obstructions in the world (eg props or the worldspawn)
	elseif hitPos then

		-- If we're ignoring Z, it doesn't matter if we hit something
		if self._IgnoreZ then
			self._mObscured = false
			return
		end

		local q = traceQueryTable
		q.start = eyepos
		q.endpos = hitPos

		local tr = util.TraceLine(q)
		self._mObscured = tr.Hit
	end
end

function tduiw_meta:_ComputeInput()
	-- Update input down statuses
	local oldInput = self._inputDown
	local nowInput = 0
	local justPressed = 0

	-- Check input (only checks if game panel is active)
	if not isInContextMenu() or IsValid( wOS.CraftingMenu ) or IsValid( wOS.ALCS.Skills.Menu )then
		if input.IsMouseDown(MOUSE_LEFT) then
			local code = tduiw.FMOUSE_LEFT
			nowInput = bor(nowInput, code)
			if oldInput and band(oldInput, code) == 0 then
				justPressed = bor(justPressed, code)
			end
		end
		
		if input.IsMouseDown(MOUSE_RIGHT) then
			local code = tduiw.FMOUSE_RIGHT

			nowInput = bor(nowInput, code)
			if oldInput and band(oldInput, code) == 0 then
				justPressed = bor(justPressed, code)
			end
		end
	end

	self._inputDown = nowInput
	self._justPressed = justPressed
end

function tduiw_meta:_UpdateInputStatus(forceUpdate, inputAspectRatio)
	-- only update input if some variable changed
	local curFrame = FrameNumber()
	local curGEyePos = EyePos()
	if self._lastInputFrame == curFrame and self._lastGEyePos == curGEyePos and not forceUpdate then
		return
	end
	self._lastGEyePos = curGEyePos
	self._lastInputFrame = curFrame

	self._inputAspectRatio = inputAspectRatio

	self:_ComputeScreenMouse()
	self:_ComputeInput()
end

-- The default values for rendering params
tduiw_meta._pos = Vector(0, 0, 0)
tduiw_meta._angles = Angle(0, 0, 0)
tduiw_meta._scale = 1

function tduiw_meta:_UpdatePAS(pos, angles, scale)

	-- If updating the angle of the render context, we apply a transformation,
	-- which makes it so that if angles was EyeAngles(), it would face us directly.
	if angles then
		-- Create a copy of the angle object
		angles = Angle(angles.p, angles.y, angles.r)
		
		angles:RotateAroundAxis(angles:Right(), 90)
		angles:RotateAroundAxis(angles:Up(), -90)
	end

	self._pos    = pos    or self._pos
	self._angles = angles or self._angles
	self._scale  = scale  or self._scale
end

--- Returns a normal vector facing away from the tduiw panel towards the front of the panel
-- Due to angle rotations in _UpdatePAS this is not the obvious self._angles:Forward()
function tduiw_meta:GetFrontNormal()
	if not self._angles then return end
	return self._angles:Up()
end

--- Returns a normal vector facing away from the tduiw panel towards the back of the panel
-- Example usecase: figuring out if the player is looking at the panel or not
function tduiw_meta:GetBackNormal()
	local frontnormal = self:GetFrontNormal()
	if frontnormal then return -frontnormal end
end

function tduiw_meta:SetIgnoreZ(b)
	self._IgnoreZ = b
end

function tduiw_meta:PreRenderReset()
	-- Reset parameters
	self:_UpdateInputStatus()

	-- Reset render bounds
	self._renderBounds.x = 0
	self._renderBounds.y = 0
	self._renderBounds.x2 = 0
	self._renderBounds.y2 = 0

	-- Reset colors, materials
	surface.SetDrawColor(tduiw.COLOR_WHITE)
	render.SetColorMaterial()
end

function tduiw_meta:BeginRender()
	if self._rendering then error("Calling BeginRender() with an ongoing render") end

	self:PreRenderReset()

	-- Set IgnoreZ
	if self._IgnoreZ then
		cam.IgnoreZ(true)
		self._IgnoreZActive = true
	else
		self._IgnoreZActive = false
	end

	-- Start render context
	render.PushFilterMin(TEXFILTER.ANISOTROPIC)
	render.PushFilterMag(TEXFILTER.ANISOTROPIC)

	cam.Start3D2D(self._pos, self._angles, self._scale)

	self._rendering = true
	self._renderStarted = SysTime()
end

function tduiw_meta:PostRenderReset()
	-- "Empty" renderQueue
	self.renderQueuePointer = 0

	-- Count how many renders have been done this frame
	local curFrame = FrameNumber()
	if self._lastRenderFrame == curFrame then
		self._frameRenderCount = (self._frameRenderCount or 0) + 1
	else
		self._frameRenderCount = 1
	end

	self._renderEnded = SysTime()
end

function tduiw_meta:EndRender()
	if not self._rendering then error("Calling EndRender() without matching BeginRender()") end

	self._rendering = false

	-- End render context
	cam.End3D2D()

	render.PopFilterMin()
	render.PopFilterMag()

	if self._IgnoreZActive then
		cam.IgnoreZ(false)
	end

	self:PostRenderReset()

	self._lastRenderFrame = FrameNumber()
end

function tduiw_meta:RenderQueued()
	for i = 1, self.renderQueuePointer do
		-- First component = render function
		-- Second.. components = render payload
		local renderData = self.renderQueue[i]
		local r, e = pcall(renderData[1], self, unpack(renderData, 2))

		if not r then
			return false, e
		end
	end

	return true
end

function tduiw_meta:Render(pos, angles, scale)
	self:_UpdatePAS(pos, angles, scale)

	self:BeginRender()
	local succ, err = self:RenderQueued()
	self:EndRender()

	if not succ then
		error("tduiw Rendering error: " .. tostring(err))
	end
end

-- EXPERIMENTAL rendering to texture
-- See examples/rendertomat.lua
function tduiw_meta:RenderToTexture(rtw, rth)
	local id = "tduiwMat_" .. (string.match(tostring(self), "table: 0x(.*)"))

	local w, h = rtw or 512, rth or 512
	local rt = GetRenderTarget(id, w, h)

	render.PushRenderTarget(rt)
	render.Clear(0, 0, 0, 255)

		cam.Start2D()
			self:PreRenderReset()
			self:RenderQueued()
			self:PostRenderReset()
		cam.End2D()

	render.PopRenderTarget()

	return rt
end

-- Is this the first render during this frame
function tduiw_meta:IsFirstRenderThisFrame()
	return not self._frameRenderCount or self._frameRenderCount == 1
end

function tduiw_meta:WasRenderedThisFrame()
	return self._lastRenderFrame == FrameNumber()
end

-- Are we rendering to the "main" render target aka the screen
function tduiw_meta:IsWorldRenderpass()
	return not IsValid(render.GetRenderTarget())
end

-- Note: does not affect return values from CheckInputInRect
function tduiw_meta:ShouldAcceptInput()
	return self.ShouldAcceptInputs
end

-- Scales all UI elements (including fonts that use custom format)
-- Behind the scenes this scales all x, y, w, h etc by this value
-- Can be used for testing or because of laziness
function tduiw_meta:SetUIScale(scale)
	self._uiscale = scale
	self.specialFontCache = {} -- special font cache must be recreated
end
function tduiw_meta:GetUIScale()
	return self._uiscale or 1
end

local useBindChecks = setmetatable({}, {__mode = "k"})

-- Inserts current tduiw to list of tduiws checked when player presses +use
-- If the +use happened while hovering tduiw, the bind is blocked
-- This is useful to prevent eg. exiting from a car if trying to interact with tduiw inside a car
function tduiw_meta:BlockUseBind()
	useBindChecks[self] = true
end

-- Create singleton instance of tduiw
-- It can be used for simplicity

local singleton = tduiw.Create()

function tduiw.Begin(pos, ang, scale)
	if not pos then error("pos expected", 2) end
	if not ang then error("ang expected", 2) end
	scale = scale or 1

	singleton:_UpdatePAS(pos, ang, scale)

	singleton:BeginRender()
end

-- Not real currying, I know
local function curry(f, x)
	return function(...)
		return f(x, ...)
	end
end

-- Drawing
tduiw.Rect    = curry(singleton.DrawRect, singleton)
tduiw.Line    = curry(singleton.DrawLine, singleton)
tduiw.Mat     = curry(singleton.DrawMat, singleton)
tduiw.Polygon = curry(singleton.DrawPolygon, singleton)
tduiw.Text    = curry(singleton.DrawText, singleton)
tduiw.Button  = curry(singleton.DrawButton, singleton)
tduiw.Cursor  = curry(singleton.DrawCursor, singleton)
tduiw.Custom  = curry(singleton.Custom, singleton)

-- Configuration
tduiw.SetIgnoreZ  = curry(singleton.SetIgnoreZ, singleton)

function tduiw.End()
	singleton:EndRender()
end

-- Register default skin
tduiw.RegisterSkin("default", {
	rect = {
		color = tduiw.COLOR_WHITE_TRANSLUCENT,
		borderColor = nil
	},
	text = {
		color = tduiw.COLOR_WHITE
	},
	line = {
		color = tduiw.COLOR_WHITE
	},
	polygon = {
		color = tduiw.COLOR_WHITE_TRANSLUCENT
	},
	button = {
		fgColor = tduiw.COLOR_WHITE,
		fgHoverColor = tduiw.COLOR_ORANGE,
		fgPressColor = tduiw.COLOR_ORANGE_DARK,

		bgColor = tduiw.COLOR_BLACK_TRANSPARENT,
		bgHoverColor = tduiw.COLOR_BLACK_TRANSPARENT,
		bgPressColor = tduiw.COLOR_BLACK_TRANSPARENT,
	},
	cursor = {
		color = tduiw.COLOR_WHITE,
		hoverColor = tduiw.COLOR_RED,
		pressColor = tduiw.COLOR_ORANGE
	}
})

return tduiw

--addons/wos-grandmaster-einf/lua/wos/advswl/combat/cl_saberbase_hook.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2020
	
	Contact: www.wiltostech.com
		----------------------------------------]]--








































































local bonesToRemove = { 
			"ValveBiped.Bip01_Head1",
			"ValveBiped.Bip01_Neck1",
			"ValveBiped.Bip01_Spine4",
			"ValveBiped.Bip01_Spine2",
			"ValveBiped.Bip01_Pelvis",
}

hook.Add( "PostPlayerDraw", "wOS.FirstPersonRemoveHead", function( ply )
	if ply != LocalPlayer() then return end
	local wep = ply:GetActiveWeapon()
	if !IsValid( wep ) or !wep.IsLightsaber or !wep.FirstPerson then 
		if wOS.FixFirstPerson then
			for _, v in pairs( ply.BoneIDTable ) do -- Loop through desired bones
				ply:ManipulateBoneScale( v, Vector( 1, 1, 1 ) )
			end
			wOS.FixFirstPerson = false
		end
		return 
	end	
	if !wOS.FixFirstPerson then
		ply.BoneIDTable = {}
		for k, v in pairs( bonesToRemove ) do -- Loop through desired bones
			local id = ply:LookupBone( v )
			if id then
				if k <= 3 then
					ply:ManipulateBoneScale( id, vector_origin )
				else
					ply:ManipulateBoneScale( id, Vector( 0.75, 0.75, 0.75 ) )			
				end
				ply.BoneIDTable[ #ply.BoneIDTable + 1 ] = id			
			end
		end	
		wOS.FixFirstPerson = true	
	end
	for k, v in pairs( ply.BoneIDTable ) do -- Loop through desired bones
		if k <= 3 then
			ply:ManipulateBoneScale( v, vector_origin )
		else
			ply:ManipulateBoneScale( v, Vector( 0.75, 0.75, 0.75 ) )			
		end
	end	
end )

local DCalledTime = 0

hook.Add( "CalcView", "wOS.CameraModeHooks", function( ply, pos, ang )
	if ( !IsValid( ply ) or !ply:Alive() or ply:InVehicle() or ply:GetViewEntity() != ply ) then return end
	local wep = LocalPlayer():GetActiveWeapon()
	if ( !IsValid( wep ) or !wep.IsLightsaber ) then return end
	if wOS.ALCS:ShouldDisableCam() then return end
	if wep.FirstPerson then 
		local eyes = ply:GetAttachment( ply:LookupAttachment( "eyes" ) );
		local angs = ang
		
		if wep.FirstPerson && ( wep:GetFPCamTime() >= CurTime() or wOS.ALCS.Config.AlwaysFirstPerson ) then
			angs = eyes.Ang
		end

		return {
			origin = eyes.Pos + Vector( 0, 0, 1.5 ),
			angles = angs,
			fov = 100, 
			drawviewer = true
		}
	elseif LocalPlayer():GetNW2Float( "wOS.DevestatorTime", 0 ) >= CurTime() then
		local dtime = LocalPlayer():GetNW2Float( "wOS.DevestatorTime", 0 )
		if !LocalPlayer().LastDevestator or LocalPlayer().LastDevestator < CurTime() then
			LocalPlayer().LastDevestator = dtime + 0.2
			DCalledtime = CurTime()
		end
		local tendpos = LocalPlayer():EyePos() + Vector( math.cos( 4.7*( DCalledtime - CurTime() ) ), math.sin( 4.7*( DCalledtime - CurTime() ) ), 0 )*150

		--if DCalledtime + 2 <= CurTime() then
			--tendpos = pos + ply:GetForward()*150 
		--end
		
		local trace = util.TraceHull( {
			start = pos,
			endpos = tendpos,
			filter = { ply:GetActiveWeapon(), ply },
			mins = Vector( -4, -4, -4 ),
			maxs = Vector( 4, 4, 4 ),
		} )
		
		if ( trace.Hit ) then pos = trace.HitPos else pos = tendpos end

		ang = ( LocalPlayer():EyePos() - pos ):Angle()
		
		return {
			origin = pos,
			angles = ang,
			drawviewer = true
		}	
	else
		local trace = util.TraceHull( {
			start = pos,
			endpos = pos - ang:Forward() * 100,
			filter = { ply:GetActiveWeapon(), ply },
			mins = Vector( -4, -4, -4 ),
			maxs = Vector( 4, 4, 4 ),
		} )

		if ( trace.Hit ) then pos = trace.HitPos else pos = pos - ang:Forward() * 100 end
		

		return {
			origin = pos,
			angles = ang,
			drawviewer = true
		}
	end
end )

hook.Add( "CreateMove", "rb655_lightsaber_no_fall_damage_wos", function( cmd/* ply, mv, cmd*/ )
	local wep = LocalPlayer():GetActiveWeapon()
	if not wep.IsLightsaber then return end
	if ( CurTime() - wep:GetAttackDelay() < 0.25 ) then
		cmd:ClearButtons() -- No attacking, we are busy
		cmd:ClearMovement() -- No moving, we are busy
	end
end )

local lastheld = 0
hook.Add( "PlayerBindPress", "rb655_sabers_force_wos", function( ply, bind, pressed )
	local wep = LocalPlayer():GetActiveWeapon()
	if ( LocalPlayer():InVehicle() || ply != LocalPlayer() || !LocalPlayer():Alive() || !IsValid( wep ) || !wep.IsLightsaber ) then return end
	if ( bind == "impulse 100" && pressed ) then
		if wOS.ALCS.Config.LightsaberHUD == WOS_ALCS.HUD.FORCEMENU then
			wOS.ALCS:OpenForceMenu()
			return true
		elseif wOS.ALCS.Config.LightsaberHUD == WOS_ALCS.HUD.HYBRID and ply:KeyDown( IN_WALK ) then
			wOS.ALCS:OpenDraggableForceMenu()
			return true
		end
		wep.ForceSelectEnabled = !wep.ForceSelectEnabled
		return true
	end
	if ( !wep.ForceSelectEnabled ) then return end

	if ( bind:StartWith( "slot" ) ) then
		RunConsoleCommand( "rb655_select_force_wos", bind:sub( 5 ) )
		return true
	end
end )

hook.Add( "PreDrawHalos", "wOS.ForceHolograms", function()

	local reflectors = {}
	local ragers = {}	
	local channelers = {}

	for _,ply in pairs( player.GetAll() ) do
		if not IsValid( ply ) then continue end
		if not ply:Alive() then continue end
		if ply:GetNW2Float( "ReflectTime", 0 ) >= CurTime() then
			table.insert( reflectors, ply )
		end
		if ply:GetNW2Float( "RageTime", 0 ) >= CurTime() then
			table.insert( ragers, ply )
		end
		if ply:GetNW2Bool( "wOS.IsChanneling", false ) then
			table.insert( channelers, ply )
		end
	end

	if #reflectors > 0 then
		halo.Add( reflectors, Color( 0, 0, 255, 175 ), 5, 5, 3, true, false )
	end
	
	if #ragers > 0 then
		halo.Add( ragers, Color( 255, 0, 0, 175 ), 5, 5, 3, true, false )
	end
	
	if #channelers > 0 then
		halo.Add( channelers, Color( 255, 0, 0, 175 ), 10 + math.max( 0, math.sin( 1.5*CurTime() ) )*10, 10 + math.max( 0, math.sin( 1.5*CurTime() ) )*10, 3, true, false )
	end
	
end )

hook.Add( "PostPlayerDraw", "wOS.Lightsaber.HolsterDrawing", function( ply )
	if ( !GetGlobalBool( "rb655_lightsaber_hiltonbelt", false ) ) then return end
	if ( !ply.LightsaberMDL ) then
		ply.LightsaberMDL = {}
	end
	if ply:GetNW2Float( "CloakTime", 0 ) >= CurTime() then return end
	
	local pi = -30
	local radian = 0
	
	for class, _ in pairs( wOS.Lightsabers.General ) do
		local wep = ply:GetWeapon( class )
		if ( !IsValid( wep ) || wep == ply:GetActiveWeapon() ) then continue end
		if not wep.WorldModel then continue end
		if ( !ply.LightsaberMDL[ class ] ) then
			ply.LightsaberMDL[ class ] = ClientsideModel( wep.WorldModel, RENDERGROUP_BOTH ) -- wep.WorldModel is nil?
			ply.LightsaberMDL[ class ]:SetNoDraw( true )
		end
		ply.LightsaberMDL[ class ]:SetModel( wep.WorldModel )

		local bone = ply:LookupBone( "ValveBiped.Bip01_Pelvis" )
		local spin = false

		if !bone then
			bone = ply:LookupBone( "ValveBiped.Bip01_Spine" )
			spin = true
		end
		if not bone then return end
		local pos, ang = ply:GetBonePosition( bone )
		local att = pi*radian
		if spin then 
			ang:RotateAroundAxis( ang:Forward(), 220 + att )
		else
			ang:RotateAroundAxis( ang:Up(), 90 )
			ang:RotateAroundAxis( ang:Forward(), att )
		end
		pos = pos - ang:Right() * 8 - ang:Forward() * 8
		if spin then
			pos = pos + ang:Up()*6 - ang:Forward()*5 + ang:Right()*5
		end
		if ( wep.WorldModel == "models/weapons/starwars/w_maul_saber_staff_hilt.mdl" ) then
			pos = pos - ang:Forward() * 1
		end
		if ( wep.WorldModel == "models/weapons/starwars/w_kr_hilt.mdl" ) then
			pos = pos + ang:Forward() * 5
		end

		ang:RotateAroundAxis( ang:Forward(), 90 )

		ply.LightsaberMDL[ class ]:SetPos( pos )
		ply.LightsaberMDL[ class ]:SetAngles( ang )

		ply.LightsaberMDL[ class ]:DrawModel()
		radian = radian + 1
	end

end )

hook.Add( "PlayerDeath", "wOS.HiltGarbageCleanup", function( ply )
	if not ply.LightsaberMDL then return end
	for class, model in pairs( ply.LightsaberMDL ) do
		model:Remove()
		ply.LightsaberMDL[ class ] = nil
	end
end )

local ColorModify = {}
ColorModify[ "$pp_colour_addr" ] 		= 0
ColorModify[ "$pp_colour_addg" ] 		= 0
ColorModify[ "$pp_colour_addb" ] 		= 0
ColorModify[ "$pp_colour_brightness" ] 	= 0
ColorModify[ "$pp_colour_contrast" ] 	= 1
ColorModify[ "$pp_colour_colour" ] 		= 1
ColorModify[ "$pp_colour_mulr" ] 		= 0
ColorModify[ "$pp_colour_mulg" ] 		= 0
ColorModify[ "$pp_colour_mulb" ] 		= 0

hook.Add( "RenderScreenspaceEffects", "wOS.DisorientForEmerald", function()
	if LocalPlayer():GetNW2Float( "wOS.SonicTime", 0 ) < CurTime() then return end
	
	ColorModify[ "$pp_colour_brightness" ] 	= -0.4*math.cos( CurTime()*3 )
	ColorModify[ "$pp_colour_contrast" ] 	= 3*math.sin( CurTime()*3 )
	
	DrawMotionBlur( 0.05, 1.0, 0.0 )	
	DrawColorModify( ColorModify )
	
end )
--addons/wos-grandmaster-einf/lua/wos/advswl/adminmenu/cl_core.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2020
	
	Contact: www.wiltostech.com
		----------------------------------------]]--








































































wOS = wOS or {}
wOS.ALCS = wOS.ALCS or {}
wOS.ALCS.Admin = wOS.ALCS.Admin or {}
wOS.ALCS.Admin.BufferInfo = wOS.ALCS.Admin.BufferInfo or {}

local w,h = ScrW(), ScrH()	
local PLAYER = LocalPlayer()
																									
local blur = Material 'pp/blurscreen'
local function blurpanel (panel, amount )
    local x, y = panel:LocalToScreen(0, 0)
    surface.SetDrawColor(255, 255, 255)
    surface.SetMaterial(blur)
    for i = 1, 3 do
        blur:SetFloat('$blur', (i / 3) * (amount or 6))
        blur:Recompute()
        render.UpdateScreenEffectTexture()
        surface.DrawTexturedRect(x * -1, y * -1, ScrW(), ScrH())
    end
end

surface.CreateFont( "wOS.AdminMain", {
	font = "Roboto Cn",
	extended = false,
	size = 32*(h/1200),
	weight = 1000,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
} )

surface.CreateFont( "wOS.AdminFont", {
	font = "Roboto Cn",
	extended = false,
	size = 28*(h/1200),
	weight = 600,
	blursize = 0,
	scanlines = 1,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
} )

surface.CreateFont( "wOS.ALCS.DescFont",{
	font = "Roboto Cn",
	extended = false,
	size = 18*(h/1200),
	weight = 500,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
} )

function wOS.ALCS.Admin:OpenAdminMenu()

	if self.AdminMenu then 
		if self.AdminMenu:IsVisible() then
			self.AdminMenu:Remove()
			self.AdminMenu = nil
			gui.EnableScreenClicker( false )
			return
		end
	end
	
	gui.EnableScreenClicker( true )
	wOS.ALCS.Admin.BufferInfo = {}	
	
	local mw, mh = w*0.5, h*0.5
	
	local padx, pady = mw*0.01, mw*0.01
	local bpady = mh*0.01
	local basew, baseh = mw*0.25, mh 
	local cw, ch = ( basew - 1.5*padx ), baseh - 2*pady
	
	self.AdminMenu = vgui.Create( "DPanel" )
	self.AdminMenu:SetSize( mw, mh )
	self.AdminMenu:Center()
	self.AdminMenu.Color = { r = 25, g = 25, b = 25, a = 155 }
	self.AdminMenu.Paint = function( pan, ww, hh )
		if not vgui.CursorVisible() then gui.EnableScreenClicker( true ) end
		blurpanel( pan )
		draw.RoundedBox( 3, 0, 0, ww, hh, Color( 25, 25, 25, 245 ) )
		surface.SetDrawColor( color_white )
		surface.DrawOutlinedRect( padx, pady, ww*0.25, hh - 2*pady )
		surface.DrawOutlinedRect( ww*0.25 + 2*padx, pady, ww*0.75 - 3*padx, hh - 2*pady )
	end
	
	local PlayerKeys = {}
	local SelectedPlayer = nil
	local PlayerList = vgui.Create( "DListView", self.AdminMenu )
	PlayerList:SetMultiSelect( false )
	PlayerList:AddColumn( "Player" )
	PlayerList:AddColumn( "Steam64" )
	PlayerList:SetPos( mw*0.25 + 3*padx, 2*pady )
	PlayerList:SetSize( mw*0.33, mh - 4*pady )
	PlayerList.PlayerKeys = {}
	PlayerList.RePopulateList = function( pan )
		SelectedPlayer = nil
		pan:Clear()
		PlayerKeys = {}
		local i = 1
		for _, ply in pairs( player.GetAll() ) do
			PlayerKeys[ i ] = ply
			PlayerList:AddLine( ply:Nick(), ply:SteamID64() )
			i = i + 1
		end
	end
	
	self.DataTab = vgui.Create( "DPanel", self.AdminMenu )
	self.DataTab:SetPos( mw*0.58 + 4*padx, 2*pady )
	self.DataTab:SetSize( mw*0.33, mh - 4*pady )
	self.DataTab.Paint = function() end
	self.DataTab.SelectedTab = "OpenSkillLevelMenu"
	
	PlayerList.SelectedPlayer = nil
	PlayerList.OnRowSelected = function( lst, index, pnl )
		SelectedPlayer = PlayerKeys[ index ]
		wOS.ALCS.Admin.BufferInfo = {}
		if not self[ self.DataTab.SelectedTab ] then return end
		self[ self.DataTab.SelectedTab ]( self, SelectedPlayer )
	end
	PlayerList.Think = function( pan )
		if ( !SelectedPlayer or !SelectedPlayer:IsValid() ) and self[ self.DataTab.SelectedTab ] then
			self.DataTab:Clear()
		end
	end
	PlayerList.RePopulateList( PlayerList )

	local AScrollPan = vgui.Create( "DScrollPanel", self.AdminMenu )
	AScrollPan:SetSize( mw*0.25, mh - 2*pady )
	AScrollPan:SetPos( 2*padx, pady )
	AScrollPan.Paint = function( pan, ww, hh ) end

	local sbar = AScrollPan:GetVBar()
	function sbar:Paint( w, h ) end
	function sbar.btnUp:Paint( w, h ) end
	function sbar.btnDown:Paint( w, h ) end
	function sbar.btnGrip:Paint( w, h ) end
	
	local button = vgui.Create( "DButton", self.AdminMenu )
	button:SetSize( mw*0.025, mw*0.025 )
	button:SetPos( mw*0.96, mw*0.015 )
	button:SetText( "" )
	button.Paint = function( pan, ww, hh )
		surface.SetDrawColor( Color( 255, 0, 0, 255 ) )
		surface.DrawLine( 0, 0, ww, hh )
		surface.DrawLine( 0, hh, ww, 0 )
	end
	button.DoClick = function( pan )
		self:OpenAdminMenu()
		gui.EnableScreenClicker( false )
	end	
	
	local base = 2*pady
	local aw, ah = AScrollPan:GetSize()

	local SkillTab = vgui.Create( "DButton", AScrollPan )
	SkillTab:SetPos( padx, base )
	SkillTab:SetSize( aw - 4*padx, mh*0.07 )
	SkillTab:SetText( "" )
	SkillTab.Paint = function( pan, ww, hh )
		local col = Color( 155, 155, 155, 155 )
		if pan:IsDown() then
			col = Color( 0, 55, 155, 155 )
		elseif self.DataTab.SelectedTab == "OpenSkillLevelMenu" then
			col = Color( 55, 110, 210, 155 )
		end
		draw.RoundedBox( 5, 0, 0, ww, hh, col  )
		draw.SimpleText( "Skills Menu", "wOS.AdminFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	SkillTab.DoClick = function()
		self.DataTab.SelectedTab = "OpenSkillLevelMenu"
		PlayerList.RePopulateList( PlayerList )
	end
	base = base + 2*pady + mh*0.07
	
	local SkillWLTab = vgui.Create( "DButton", AScrollPan )
	SkillWLTab:SetPos( padx, base )
	SkillWLTab:SetSize( aw - 4*padx, mh*0.07 )
	SkillWLTab:SetText( "" )
	SkillWLTab.Paint = function( pan, ww, hh )
		local col = Color( 155, 155, 155, 155 )
		if pan:IsDown() then
			col = Color( 0, 55, 155, 155 )
		elseif self.DataTab.SelectedTab == "OpenSkillWLMenu" then
			col = Color( 55, 110, 210, 155 )
		end
		draw.RoundedBox( 5, 0, 0, ww, hh, col  )		
		draw.SimpleText( "Whitelist Menu", "wOS.AdminFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	SkillWLTab.DoClick = function()
		self.DataTab.SelectedTab = "OpenSkillWLMenu"
		PlayerList.RePopulateList( PlayerList )
	end
	base = base + 2*pady + mh*0.07

	local ProfTab = vgui.Create( "DButton", AScrollPan )
	ProfTab:SetPos( padx, base )
	ProfTab:SetSize( aw - 4*padx, mh*0.07 )
	ProfTab:SetText( "" )
	ProfTab.Paint = function( pan, ww, hh )
		local col = Color( 155, 155, 155, 155 )
		if pan:IsDown() then
			col = Color( 0, 55, 155, 155 )
		elseif self.DataTab.SelectedTab == "OpenProfMenu" then
			col = Color( 55, 110, 210, 155 )
		end
		draw.RoundedBox( 5, 0, 0, ww, hh, col  )		
		draw.SimpleText( "Proficiency Menu", "wOS.AdminFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	ProfTab.DoClick = function()
		self.DataTab.SelectedTab = "OpenProfMenu"
		PlayerList.RePopulateList( PlayerList )
	end
	base = base + 2*pady + mh*0.07
	
	local CInvTab = vgui.Create( "DButton", AScrollPan )
	CInvTab:SetPos( padx, base )
	CInvTab:SetSize( aw - 4*padx, mh*0.07 )
	CInvTab:SetText( "" )
	CInvTab.Paint = function( pan, ww, hh )
		local col = Color( 155, 155, 155, 155 )
		if pan:IsDown() then
			col = Color( 0, 55, 155, 155 )
		elseif self.DataTab.SelectedTab == "OpenCraftInvMenu" then
			col = Color( 55, 110, 210, 155 )
		end
		draw.RoundedBox( 5, 0, 0, ww, hh, col  )
		draw.SimpleText( "Inventory Menu", "wOS.AdminFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	CInvTab.DoClick = function()
		self.DataTab.SelectedTab = "OpenCraftInvMenu"
		PlayerList.RePopulateList( PlayerList )
	end
	base = base + 2*pady + mh*0.07	
	
	local CMatTab = vgui.Create( "DButton", AScrollPan )
	CMatTab:SetPos( padx, base )
	CMatTab:SetSize( aw - 4*padx, mh*0.07 )
	CMatTab:SetText( "" )
	CMatTab.Paint = function( pan, ww, hh )
		local col = Color( 155, 155, 155, 155 )
		if pan:IsDown() then
			col = Color( 0, 55, 155, 155 )
		elseif self.DataTab.SelectedTab == "OpenCraftMatMenu" then
			col = Color( 55, 110, 210, 155 )
		end
		draw.RoundedBox( 5, 0, 0, ww, hh, col  )
		draw.SimpleText( "Material Menu", "wOS.AdminFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	CMatTab.DoClick = function()
		self.DataTab.SelectedTab = "OpenCraftMatMenu"
		PlayerList.RePopulateList( PlayerList )
	end
	base = base + 2*pady + mh*0.07	
	
	local SpawnTab = vgui.Create( "DButton", AScrollPan )
	SpawnTab:SetPos( padx, base )
	SpawnTab:SetSize( aw - 4*padx, mh*0.07 )
	SpawnTab:SetText( "" )
	SpawnTab.Paint = function( pan, ww, hh )
		local col = Color( 155, 155, 155, 155 )
		if pan:IsDown() then
			col = Color( 0, 55, 155, 155 )
		elseif self.DataTab.SelectedTab == "ItemSpawnMenu" then
			col = Color( 55, 110, 210, 155 )
		end
		draw.RoundedBox( 5, 0, 0, ww, hh, col  )
		draw.SimpleText( "Item Spawn Menu", "wOS.AdminFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	SpawnTab.DoClick = function()
		self.DataTab.SelectedTab = "ItemSpawnMenu"
		PlayerList.RePopulateList( PlayerList )
		self:OpenSpawnMenu()
	end
	base = base + 2*pady + mh*0.07	
	
	local StoreTab = vgui.Create( "DButton", AScrollPan )
	StoreTab:SetPos( padx, base )
	StoreTab:SetSize( aw - 4*padx, mh*0.07 )
	StoreTab:SetText( "" )
	StoreTab.Paint = function( pan, ww, hh )
		local col = Color( 155, 155, 155, 155 )
		if pan:IsDown() then
			col = Color( 0, 55, 155, 155 )
		elseif self.DataTab.SelectedTab == "OpenStorageMenu" then
			col = Color( 55, 110, 210, 155 )
		end
		draw.RoundedBox( 5, 0, 0, ww, hh, col  )
		draw.SimpleText( "Storage Menu", "wOS.AdminFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	StoreTab.DoClick = function()
		self.DataTab.SelectedTab = "OpenStorageMenu"
		PlayerList.RePopulateList( PlayerList )
	end
	base = base + 2*pady + mh*0.07	
	
	local PrestigeTab = vgui.Create( "DButton", AScrollPan )
	PrestigeTab:SetPos( padx, base )
	PrestigeTab:SetSize( aw - 4*padx, mh*0.07 )
	PrestigeTab:SetText( "" )
	PrestigeTab.Paint = function( pan, ww, hh )
		local col = Color( 155, 155, 155, 155 )
		if pan:IsDown() then
			col = Color( 0, 55, 155, 155 )
		elseif self.DataTab.SelectedTab == "OpenPrestigeMenu" then
			col = Color( 55, 110, 210, 155 )
		end
		draw.RoundedBox( 5, 0, 0, ww, hh, col  )
		draw.SimpleText( "Prestige Menu", "wOS.AdminFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	PrestigeTab.DoClick = function()
		self.DataTab.SelectedTab = "OpenPrestigeMenu"
		PlayerList.RePopulateList( PlayerList )
	end
	base = base + 2*pady + mh*0.07	

	local SpiritTab = vgui.Create( "DButton", AScrollPan )
	SpiritTab:SetPos( padx, base )
	SpiritTab:SetSize( aw - 4*padx, mh*0.07 )
	SpiritTab:SetText( "" )
	SpiritTab.Paint = function( pan, ww, hh )
		local col = Color( 155, 155, 155, 155 )
		if pan:IsDown() then
			col = Color( 0, 55, 155, 155 )
		elseif self.DataTab.SelectedTab == "OpenSpiritMenu" then
			col = Color( 55, 110, 210, 155 )
		end
		draw.RoundedBox( 5, 0, 0, ww, hh, col  )
		draw.SimpleText( "Spirit Menu", "wOS.AdminFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	SpiritTab.DoClick = function()
		self.DataTab.SelectedTab = "OpenSpiritMenu"
		PlayerList.RePopulateList( PlayerList )
	end
	base = base + 2*pady + mh*0.07	

	local SpiritTab = vgui.Create( "DButton", AScrollPan )
	SpiritTab:SetPos( padx, base )
	SpiritTab:SetSize( aw - 4*padx, mh*0.07 )
	SpiritTab:SetText( "" )
	SpiritTab.Paint = function( pan, ww, hh )
		local col = Color( 155, 155, 155, 155 )
		if pan:IsDown() then
			col = Color( 0, 55, 155, 155 )
		elseif self.DataTab.SelectedTab == "OpenArtMenu" then
			col = Color( 55, 110, 210, 155 )
		end
		draw.RoundedBox( 5, 0, 0, ww, hh, col  )
		draw.SimpleText( "Artifact Menu", "wOS.AdminFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	SpiritTab.DoClick = function()
		self.DataTab.SelectedTab = "OpenArtMenu"
		PlayerList.RePopulateList( PlayerList )
	end
	base = base + 2*pady + mh*0.07	

	local ExecWLTab = vgui.Create( "DButton", AScrollPan )
	ExecWLTab:SetPos( padx, base )
	ExecWLTab:SetSize( aw - 4*padx, mh*0.07 )
	ExecWLTab:SetText( "" )
	ExecWLTab.Paint = function( pan, ww, hh )
		local col = Color( 155, 155, 155, 155 )
		if pan:IsDown() then
			col = Color( 0, 55, 155, 155 )
		elseif self.DataTab.SelectedTab == "OpenExecWLMenu" then
			col = Color( 55, 110, 210, 155 )
		end
		draw.RoundedBox( 5, 0, 0, ww, hh, col  )		
		draw.SimpleText( "Executions Menu", "wOS.AdminFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	ExecWLTab.DoClick = function()
		self.DataTab.SelectedTab = "OpenExecWLMenu"
		PlayerList.RePopulateList( PlayerList )
	end
	base = base + 2*pady + mh*0.07
	
end

function wOS.ALCS.Admin:OpenSkillLevelMenu( ply )
	self.DataTab:Clear()
	local mw, mh = w*0.5, h*0.5
	local padx, pady = mw*0.01, mw*0.01
	local bpady = mh*0.01
	local basew, baseh = mw*0.25, mh 
	local cw, ch = ( basew - 1.5*padx ), baseh - 2*pady
	local ww, hh = self.DataTab:GetSize()
	local posx, posy = self.DataTab:GetPos()
	local possx, possy = self.AdminMenu:GetPos()
	posx = possx + posx
	posy = possy + posy
	local LevelText = vgui.Create( "DLabel", self.DataTab )
	LevelText:SetPos( padx, pady )
	LevelText:SetSize( ww, hh*0.05 )
	LevelText:SetText( "Combat Level: " .. ply:GetSkillLevel() )
	LevelText:SetFont( "wOS.AdminMain" )
	
	local XPText = vgui.Create( "DLabel", self.DataTab )
	XPText:SetPos( padx, 2*pady + hh*0.05 )
	XPText:SetSize( ww, hh*0.05 )
	XPText:SetText( "Experience: " .. ply:GetSkillXP() )
	XPText:SetFont( "wOS.AdminMain" )
	
	local SkText = vgui.Create( "DLabel", self.DataTab )
	SkText:SetPos( padx, 3*pady + hh*0.1 )
	SkText:SetSize( ww, hh*0.05 )
	SkText:SetText( "Skill Points: " .. ply:GetSkillPoints() )
	SkText:SetFont( "wOS.AdminMain" )
	
	local SLevel = vgui.Create( "DButton", self.DataTab )
	SLevel:SetPos( ww*0.6 + 2*padx, 4*pady + hh*0.15 )
	SLevel:SetSize( ww*0.4 - 3*padx, hh*0.05 )
	SLevel:SetText( "" )
	SLevel.Paint = function( pan, ww, hh )
		draw.RoundedBox( 5, 0, 0, ww, hh,  ( pan:IsDown() and Color( 0, 155, 255, 155 ) ) or Color( 155, 155, 155, 155 ) )
		draw.SimpleText( "SET LEVEL", "wOS.ALCS.DescFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	local LevelEntry = vgui.Create( "DTextEntry",self.DataTab )
	LevelEntry:MakePopup()
	LevelEntry:SetPos( posx + padx, posy + 4*pady + hh*0.15 )
	LevelEntry:SetSize( ww*0.6, hh*0.05 )
	LevelEntry:SetText( ply:GetSkillLevel() )
	LevelEntry:SetNumeric( true )
	SLevel.DoClick = function()
		net.Start( "wOS.SkillTree.SetLevel" )
			net.WriteString( ply:SteamID64() )
			net.WriteInt( tonumber( LevelEntry:GetValue() ), 32 )
		net.SendToServer()
	end
	
	local SXP = vgui.Create( "DButton", self.DataTab )
	SXP:SetPos( ww*0.6 + 2*padx, 5*pady + hh*0.2 )
	SXP:SetSize( ww*0.4 - 3*padx, hh*0.05 )
	SXP:SetText( "" )
	SXP.Paint = function( pan, ww, hh )
		draw.RoundedBox( 5, 0, 0, ww, hh, ( pan:IsDown() and Color( 0, 55, 155, 155 ) ) or Color( 155, 155, 155, 155 ) )
		draw.SimpleText( "SET XP", "wOS.ALCS.DescFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	local XPEntry = vgui.Create( "DTextEntry",self.DataTab )
	XPEntry:MakePopup()
	XPEntry:SetPos( posx + padx, posy + 5*pady + hh*0.2 )
	XPEntry:SetSize( ww*0.6, hh*0.05 )
	XPEntry:SetText( ply:GetSkillXP() )
	XPEntry:SetNumeric( true )
	SXP.DoClick = function()
		net.Start( "wOS.SkillTree.SetXP" )
			net.WriteString( ply:SteamID64() )
			net.WriteInt( tonumber( XPEntry:GetValue() ), 32 )
		net.SendToServer()
	end
	local SKS = vgui.Create( "DButton", self.DataTab )
	SKS:SetPos( ww*0.6 + 2*padx, 6*pady + hh*0.25 )
	SKS:SetSize( ww*0.4 - 3*padx, hh*0.05 )
	SKS:SetText( "" )
	SKS.Paint = function( pan, ww, hh )
		draw.RoundedBox( 5, 0, 0, ww, hh, ( pan:IsDown() and Color( 0, 55, 155, 155 ) ) or Color( 155, 155, 155, 155 ) )
		draw.SimpleText( "SET POINTS", "wOS.ALCS.DescFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	local SkillEntry = vgui.Create( "DTextEntry",self.DataTab )
	SkillEntry:MakePopup()
	SkillEntry:SetPos( posx + padx, posy + 6*pady + hh*0.25 )
	SkillEntry:SetSize( ww*0.6, hh*0.05 )
	SkillEntry:SetText( ply:GetSkillPoints() )
	SkillEntry:SetNumeric( true )
	SKS.DoClick = function()
		net.Start( "wOS.SkillTree.SetSkillPoints" )
			net.WriteString( ply:SteamID64() )
			net.WriteInt( tonumber( SkillEntry:GetValue() ), 32 )
		net.SendToServer()
	end
	local AddL = vgui.Create( "DButton", self.DataTab )
	AddL:SetPos( ww*0.6 + 2*padx, 7*pady + hh*0.3 )
	AddL:SetSize( ww*0.4 - 3*padx, hh*0.05 )
	AddL:SetText( "" )
	AddL.Paint = function( pan, ww, hh )
		draw.RoundedBox( 5, 0, 0, ww, hh, ( pan:IsDown() and Color( 0, 55, 155, 155 ) ) or Color( 155, 155, 155, 155 ) )
		draw.SimpleText( "ADD LEVEL", "wOS.ALCS.DescFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	local AddLevelEntry = vgui.Create( "DTextEntry",self.DataTab )
	AddLevelEntry:MakePopup()
	AddLevelEntry:SetPos( posx + padx, posy + 7*pady + hh*0.3 )
	AddLevelEntry:SetSize( ww*0.6, hh*0.05 )
	AddLevelEntry:SetText( 0 )
	AddLevelEntry:SetNumeric( true )
	AddL.DoClick = function()
		net.Start( "wOS.SkillTree.AddLevel" )
			net.WriteString( ply:SteamID64() )
			net.WriteInt( tonumber( AddLevelEntry:GetValue() ), 32 )
		net.SendToServer()
	end
	local AddX = vgui.Create( "DButton", self.DataTab )
	AddX:SetPos( ww*0.6 + 2*padx, 8*pady + hh*0.35 )
	AddX:SetSize( ww*0.4 - 3*padx, hh*0.05 )
	AddX:SetText( "" )
	AddX.Paint = function( pan, ww, hh )
		draw.RoundedBox( 5, 0, 0, ww, hh, ( pan:IsDown() and Color( 0, 55, 155, 155 ) ) or Color( 155, 155, 155, 155 ) )
		draw.SimpleText( "ADD XP", "wOS.ALCS.DescFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	local AddXPEntry = vgui.Create( "DTextEntry",self.DataTab )
	AddXPEntry:MakePopup()
	AddXPEntry:SetPos( posx + padx, posy + 8*pady + hh*0.35 )
	AddXPEntry:SetSize( ww*0.6, hh*0.05 )
	AddXPEntry:SetText( 0 )
	AddXPEntry:SetNumeric( true )
	AddX.DoClick = function()
		net.Start( "wOS.SkillTree.AddXP" )
			net.WriteString( ply:SteamID64() )
			net.WriteInt( tonumber( AddXPEntry:GetValue() ), 32 )
		net.SendToServer()
	end
	local AddSK = vgui.Create( "DButton", self.DataTab )
	AddSK:SetPos( ww*0.6 + 2*padx, 9*pady + hh*0.4 )
	AddSK:SetSize( ww*0.4 - 3*padx, hh*0.05 )
	AddSK:SetText( "" )
	AddSK.Paint = function( pan, ww, hh )
		draw.RoundedBox( 5, 0, 0, ww, hh, ( pan:IsDown() and Color( 0, 55, 155, 155 ) ) or Color( 155, 155, 155, 155 ) )
		draw.SimpleText( "ADD POINTS", "wOS.ALCS.DescFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	local AddSkillEntry = vgui.Create( "DTextEntry",self.DataTab )
	AddSkillEntry:MakePopup()
	AddSkillEntry:SetPos( posx + padx, posy + 9*pady + hh*0.4 )
	AddSkillEntry:SetSize( ww*0.6, hh*0.05 )
	AddSkillEntry:SetText( 0 )
	AddSkillEntry:SetNumeric( true )
	AddSK.DoClick = function()
		net.Start( "wOS.SkillTree.AddSkillPoints" )
			net.WriteString( ply:SteamID64() )
			net.WriteInt( tonumber( AddSkillEntry:GetValue() ), 32 )
		net.SendToServer()
	end
	
	local ResetAll = vgui.Create( "DButton", self.DataTab )
	ResetAll:SetPos( padx, 10*pady + hh*0.45 )
	ResetAll:SetSize( ww - 2*padx, hh*0.05 )
	ResetAll:SetText( "" )
	ResetAll.Paint = function( pan, ww, hh )
		draw.RoundedBox( 5, 0, 0, ww, hh, ( pan:IsDown() and Color( 0, 55, 155, 155 ) ) or Color( 155, 155, 155, 155 ) )
		draw.SimpleText( "RESET ALL", "wOS.ALCS.DescFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	ResetAll.DoClick = function()
		net.Start( "wOS.SkillTree.ResetPlayerSkills" )
			net.WriteString( ply:SteamID64() )
		net.SendToServer()
	end			
end

function wOS.ALCS.Admin:OpenSkillWLMenu( ply )

	net.Start( "wOS.SkillTree.AdminRequestSkillWL" )
		net.WriteString( ply:SteamID64() )
	net.SendToServer()
	self.DataTab:Clear()
	
	local mw, mh = w*0.5, h*0.5
	local padx, pady = mw*0.01, mw*0.01
	local bpady = mh*0.01
	local basew, baseh = mw*0.25, mh 
	local cw, ch = ( basew - 1.5*padx ), baseh - 2*pady
	local ww, hh = self.DataTab:GetSize()
	local posx, posy = self.DataTab:GetPos()
	local possx, possy = self.AdminMenu:GetPos()
	posx = possx + posx
	posy = possy + posy
	
	local AddL = vgui.Create( "DButton", self.DataTab )
	AddL:SetPos( ww*0.6 + 2*padx, pady)
	AddL:SetSize( ww*0.4 - 3*padx, hh*0.05 )
	AddL:SetText( "" )
	AddL.Paint = function( pan, ww, hh )
		draw.RoundedBox( 5, 0, 0, ww, hh, ( pan:IsDown() and Color( 0, 55, 155, 155 ) ) or Color( 155, 155, 155, 155 ) )
		draw.SimpleText( "ADD TREE", "wOS.ALCS.DescFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	local AddLevelEntry = vgui.Create( "DComboBox",self.DataTab )
	AddLevelEntry:SetPos( padx, pady )
	AddLevelEntry:SetSize( ww*0.6, hh*0.05 )
	AddLevelEntry:SetValue( "" )
	for tree, dat in pairs( wOS.SkillTrees ) do
		AddLevelEntry:AddChoice( tree )
	end
	AddL.DoClick = function()
		local tree = AddLevelEntry:GetSelected()
		if not tree or #tree < 1 then return end
		wOS.ALCS.Admin.BufferInfo = {}
		net.Start( "wOS.SkillTree.AddWL" )
			net.WriteString( tree )
			net.WriteString( ply:SteamID64() )
		net.SendToServer()
	end
	
	local SkillList = vgui.Create( "DListView", self.DataTab )
	SkillList:SetMultiSelect( false )
	SkillList:AddColumn( "Skill Tree" )
	SkillList:SetPos( padx , 2*pady + hh*0.05 )
	SkillList:SetSize( ww - 2*padx, hh*0.8 - 2*pady )
	SkillList.Think = function( pan )
		if not self.BufferInfo.Received then
			pan.Refreshed = false
		else
			if not pan.Refreshed then
				SkillList:Clear()
				for tree, _ in pairs( self.BufferInfo.Data ) do
					SkillList:AddLine( tree )
				end
				pan.Refreshed = true
			end
		end
	end
	
	local RemoveWL = vgui.Create( "DButton", self.DataTab )
	RemoveWL:SetPos( padx, hh*0.85 + pady )
	RemoveWL:SetSize( ww - 2*padx, hh*0.05 )
	RemoveWL:SetText( "" )
	RemoveWL.Paint = function( pan, ww, hh )
		draw.RoundedBox( 5, 0, 0, ww, hh, ( pan:IsDown() and Color( 0, 55, 155, 155 ) ) or Color( 155, 155, 155, 155 ) )
		draw.SimpleText( "REMOVE SELECTED TREE", "wOS.ALCS.DescFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	RemoveWL.DoClick = function()
		local sel = SkillList:GetSelectedLine()
		if not sel or sel < 1 then return end
		local dat = SkillList:GetLine( sel )
		if not dat then return end
		local tree = dat:GetColumnText( 1 )
		if not tree or #tree < 1 then return end
		wOS.ALCS.Admin.BufferInfo = {}
		net.Start( "wOS.SkillTree.RemoveWL" )
			net.WriteString( tree )
			net.WriteString( ply:SteamID64() )
		net.SendToServer()
	end	
	
end

function wOS.ALCS.Admin:OpenCraftInvMenu( ply )

	net.Start( "wOS.Crafting.RequestInventory" )
		net.WriteString( ply:SteamID64() )
	net.SendToServer()
	self.DataTab:Clear()
	
	local mw, mh = w*0.5, h*0.5
	local padx, pady = mw*0.01, mw*0.01
	local bpady = mh*0.01
	local basew, baseh = mw*0.25, mh 
	local cw, ch = ( basew - 1.5*padx ), baseh - 2*pady
	local ww, hh = self.DataTab:GetSize()
	local posx, posy = self.DataTab:GetPos()
	local possx, possy = self.AdminMenu:GetPos()
	posx = possx + posx
	posy = possy + posy
	
	
	local ItemList = vgui.Create( "DListView", self.DataTab )
	ItemList:SetMultiSelect( false )
	ItemList:AddColumn( "Item Name" )
	ItemList:SetPos( padx, pady  )
	ItemList:SetSize( ww - 2*padx, hh*0.4 )
	
	//MANUAL SORTING SORT OF!!!
	//Could probably use a function in table.sort but whatever
	local lst = {}
	for item, dat in pairs( wOS.ItemList ) do
		if dat.Type == WOSTYPE.RAWMATERIAL then continue end
		lst[ #lst + 1 ] = item
	end
	table.sort(lst)
	for _, item in pairs( lst ) do
		ItemList:AddLine( item )
	end	
	
	local AddL = vgui.Create( "DButton", self.DataTab )
	AddL:SetPos( padx, 2*pady + hh*0.4 )
	AddL:SetSize( ww - 2*padx, hh*0.05 )
	AddL:SetText( "" )
	AddL.Paint = function( pan, ww, hh )
		draw.RoundedBox( 5, 0, 0, ww, hh, ( pan:IsDown() and Color( 0, 55, 155, 155 ) ) or Color( 155, 155, 155, 155 ) )
		draw.SimpleText( "ADD SELECTED ITEM", "wOS.ALCS.DescFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	AddL.DoClick = function()
		local sel = ItemList:GetSelectedLine()
		if not sel or sel < 1 then return end
		local dat = ItemList:GetLine( sel )
		if not dat then return end
		local item = dat:GetColumnText( 1 )
		if not item or #item < 1 then return end
		wOS.ALCS.Admin.BufferInfo = {}
		net.Start( "wOS.Crafting.AdminAddItem" )
			net.WriteString( item )
			net.WriteString( ply:SteamID64() )
		net.SendToServer()
	end	
	
	local InvenList = vgui.Create( "DListView", self.DataTab )
	InvenList:SetMultiSelect( false )
	InvenList:AddColumn( "Slot" )
	InvenList:AddColumn( "Item" )
	InvenList:AddColumn( "Amount" )
	InvenList:SetPos( padx , 3*pady + hh*0.45 )
	InvenList:SetSize( ww - 2*padx, hh*0.4 - 3*pady )
	InvenList.Think = function( pan )
		if not self.BufferInfo.Received then
			pan.Refreshed = false
		else
			if not pan.Refreshed then
				InvenList:Clear()
				for i=1, wOS.ALCS.Config.Crafting.MaxInventorySlots do
					local dat = self.BufferInfo.Data[i]
					local name = dat
					local amount = 1
					if istable( dat ) then
						name = dat.Name
						amount = dat.Amount or 1
					end
					if name == "Empty" then amount = "N/A" end
					InvenList:AddLine( i, name, amount )
				end
				pan.Refreshed = true
			end
		end
	end
	
	local RemoveItem = vgui.Create( "DButton", self.DataTab )
	RemoveItem:SetPos( padx, hh*0.85 + pady )
	RemoveItem:SetSize( ww - 2*padx, hh*0.05 )
	RemoveItem:SetText( "" )
	RemoveItem.Paint = function( pan, ww, hh )
		draw.RoundedBox( 5, 0, 0, ww, hh, ( pan:IsDown() and Color( 0, 55, 155, 155 ) ) or Color( 155, 155, 155, 155 ) )
		draw.SimpleText( "REMOVE SELECTED ITEM", "wOS.ALCS.DescFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	RemoveItem.DoClick = function()
		local sel = InvenList:GetSelectedLine()
		if not sel or sel < 1 then return end
		local dat = InvenList:GetLine( sel )
		if not dat then return end
		local item = dat:GetColumnText( 2 )
		if not item or #item < 1 then return end
		wOS.ALCS.Admin.BufferInfo = {}
		net.Start( "wOS.Crafting.AdminRemoveItem" )
			net.WriteString( item )
			net.WriteString( ply:SteamID64() )
		net.SendToServer()
	end	
	
	local ClearSlot = vgui.Create( "DButton", self.DataTab )
	ClearSlot:SetPos( padx, hh*0.9 + 2*pady )
	ClearSlot:SetSize( ww - 2*padx, hh*0.05 )
	ClearSlot:SetText( "" )
	ClearSlot.Paint = function( pan, ww, hh )
		draw.RoundedBox( 5, 0, 0, ww, hh, ( pan:IsDown() and Color( 0, 55, 155, 155 ) ) or Color( 155, 155, 155, 155 ) )
		draw.SimpleText( "CLEAR SELECTED SLOT", "wOS.ALCS.DescFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	ClearSlot.DoClick = function()
		local sel = InvenList:GetSelectedLine()
		if not sel or sel < 1 then return end
		local dat = InvenList:GetLine( sel )
		if not dat then return end
		local slot = dat:GetColumnText( 1 )
		if not slot then return end
		wOS.ALCS.Admin.BufferInfo = {}
		net.Start( "wOS.Crafting.AdminClearSlot" )
			net.WriteInt( slot, 32 )
			net.WriteString( ply:SteamID64() )
		net.SendToServer()
	end	
	
end

function wOS.ALCS.Admin:OpenCraftMatMenu( ply )

	net.Start( "wOS.Crafting.RequestMaterials" )
		net.WriteString( ply:SteamID64() )
	net.SendToServer()
	self.DataTab:Clear()
	
	local mw, mh = w*0.5, h*0.5
	local padx, pady = mw*0.01, mw*0.01
	local bpady = mh*0.01
	local basew, baseh = mw*0.25, mh 
	local cw, ch = ( basew - 1.5*padx ), baseh - 2*pady
	local ww, hh = self.DataTab:GetSize()
	local posx, posy = self.DataTab:GetPos()
	local possx, possy = self.AdminMenu:GetPos()
	posx = possx + posx
	posy = possy + posy
	
	
	local ItemList = vgui.Create( "DListView", self.DataTab )
	ItemList:SetMultiSelect( false )
	ItemList:AddColumn( "Item Name" )
	ItemList:SetPos( padx, pady  )
	ItemList:SetSize( ww - 2*padx, hh*0.4 )
	
	//MANUAL SORTING SORT OF!!!
	//Could probably use a function in table.sort but whatever
	local lst = {}
	for item, dat in pairs( wOS.ItemList ) do
		if dat.Type != WOSTYPE.RAWMATERIAL then continue end
		lst[ #lst + 1 ] = item
	end
	table.sort(lst)
	for _, item in pairs( lst ) do
		ItemList:AddLine( item )
	end	
	
	local MatAmt = vgui.Create( "DTextEntry",self.DataTab )
	MatAmt:MakePopup()
	MatAmt:SetPos( posx + padx + ww*0.4, posy + 2*pady + hh*0.4 )
	MatAmt:SetSize( ww*0.6 - 2*padx, hh*0.05 )
	MatAmt:SetText( 0 )
	MatAmt:SetNumeric( true )
	
	local LevelText = vgui.Create( "DLabel", self.DataTab )
	LevelText:SetPos( padx, 2*pady + hh*0.4  )
	LevelText:SetSize( ww*0.4, hh*0.05 )
	LevelText:SetText( "Amount:" )
	LevelText:SetFont( "wOS.AdminMain" )
	
	local AddL = vgui.Create( "DButton", self.DataTab )
	AddL:SetPos( padx, 3*pady + hh*0.45 )
	AddL:SetSize( ww - 2*padx, hh*0.05 )
	AddL:SetText( "" )
	AddL.Paint = function( pan, ww, hh )
		draw.RoundedBox( 5, 0, 0, ww, hh, ( pan:IsDown() and Color( 0, 55, 155, 155 ) ) or Color( 155, 155, 155, 155 ) )
		draw.SimpleText( "ADD SELECTED ITEM", "wOS.ALCS.DescFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	AddL.DoClick = function()
		local sel = ItemList:GetSelectedLine()
		if not sel or sel < 1 then return end
		local dat = ItemList:GetLine( sel )
		if not dat then return end
		local item = dat:GetColumnText( 1 )
		if not item or #item < 1 then return end
		local amt = tonumber( MatAmt:GetValue() )
		if amt <= 0 then amt = 0 end
		wOS.ALCS.Admin.BufferInfo = {}
		net.Start( "wOS.Crafting.AdminModMat" )
			net.WriteString( item )
			net.WriteInt( amt, 32 )
			net.WriteBool( true )
			net.WriteString( ply:SteamID64() )
		net.SendToServer()
	end	
	
	local RemL = vgui.Create( "DButton", self.DataTab )
	RemL:SetPos( padx, 4*pady + hh*0.5 )
	RemL:SetSize( ww - 2*padx, hh*0.05 )
	RemL:SetText( "" )
	RemL.Paint = function( pan, ww, hh )
		draw.RoundedBox( 5, 0, 0, ww, hh, ( pan:IsDown() and Color( 0, 55, 155, 155 ) ) or Color( 155, 155, 155, 155 ) )
		draw.SimpleText( "REMOVE SELECTED ITEM", "wOS.ALCS.DescFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	RemL.DoClick = function()
		local sel = ItemList:GetSelectedLine()
		if not sel or sel < 1 then return end
		local dat = ItemList:GetLine( sel )
		if not dat then return end
		local item = dat:GetColumnText( 1 )
		if not item or #item < 1 then return end
		local amt = tonumber( MatAmt:GetValue() )
		if amt <= 0 then amt = 0 end
		wOS.ALCS.Admin.BufferInfo = {}
		net.Start( "wOS.Crafting.AdminModMat" )
			net.WriteString( item )
			net.WriteInt( amt, 32 )
			net.WriteBool( false )
			net.WriteString( ply:SteamID64() )
		net.SendToServer()
	end	
	
	local InvenList = vgui.Create( "DListView", self.DataTab )
	InvenList:SetMultiSelect( false )
	InvenList:AddColumn( "Item" )
	InvenList:AddColumn( "Amount" )
	InvenList:SetPos( padx , 5*pady + hh*0.55 )
	InvenList:SetSize( ww - 2*padx, hh*0.4 - 4*pady )
	InvenList.Think = function( pan )
		if not self.BufferInfo.Received then
			pan.Refreshed = false
		else
			if not pan.Refreshed then
				InvenList:Clear()
				for mat, amt in pairs( self.BufferInfo.Data ) do
					InvenList:AddLine( mat, amt )
				end
				pan.Refreshed = true
			end
		end
	end
	
end

function wOS.ALCS.Admin:OpenProfMenu( ply )
	self.DataTab:Clear()
	local mw, mh = w*0.5, h*0.5
	local padx, pady = mw*0.01, mw*0.01
	local bpady = mh*0.01
	local basew, baseh = mw*0.25, mh 
	local cw, ch = ( basew - 1.5*padx ), baseh - 2*pady
	local ww, hh = self.DataTab:GetSize()
	local posx, posy = self.DataTab:GetPos()
	local possx, possy = self.AdminMenu:GetPos()
	posx = possx + posx
	posy = possy + posy
	local LevelText = vgui.Create( "DLabel", self.DataTab )
	LevelText:SetPos( padx, pady )
	LevelText:SetSize( ww, hh*0.05 )
	LevelText:SetText( "Proficiency Level: " .. ply:GetSaberLevel() )
	LevelText:SetFont( "wOS.AdminMain" )
	
	local XPText = vgui.Create( "DLabel", self.DataTab )
	XPText:SetPos( padx, 2*pady + hh*0.05 )
	XPText:SetSize( ww, hh*0.05 )
	XPText:SetText( "Experience: " .. ply:GetSaberXP() )
	XPText:SetFont( "wOS.AdminMain" )
	
	local SLevel = vgui.Create( "DButton", self.DataTab )
	SLevel:SetPos( ww*0.6 + 2*padx, 4*pady + hh*0.15 )
	SLevel:SetSize( ww*0.4 - 3*padx, hh*0.05 )
	SLevel:SetText( "" )
	SLevel.Paint = function( pan, ww, hh )
		draw.RoundedBox( 5, 0, 0, ww, hh,  ( pan:IsDown() and Color( 0, 155, 255, 155 ) ) or Color( 155, 155, 155, 155 ) )
		draw.SimpleText( "SET LEVEL", "wOS.ALCS.DescFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	local LevelEntry = vgui.Create( "DTextEntry",self.DataTab )
	LevelEntry:MakePopup()
	LevelEntry:SetPos( posx + padx, posy + 4*pady + hh*0.15 )
	LevelEntry:SetSize( ww*0.6, hh*0.05 )
	LevelEntry:SetText( ply:GetSaberLevel() )
	LevelEntry:SetNumeric( true )
	SLevel.DoClick = function()
		net.Start( "wOS.Proficiency.SetLevel" )
			net.WriteString( ply:SteamID64() )
			net.WriteInt( tonumber( LevelEntry:GetValue() ), 32 )
		net.SendToServer()
	end
	
	local SXP = vgui.Create( "DButton", self.DataTab )
	SXP:SetPos( ww*0.6 + 2*padx, 5*pady + hh*0.2 )
	SXP:SetSize( ww*0.4 - 3*padx, hh*0.05 )
	SXP:SetText( "" )
	SXP.Paint = function( pan, ww, hh )
		draw.RoundedBox( 5, 0, 0, ww, hh, ( pan:IsDown() and Color( 0, 55, 155, 155 ) ) or Color( 155, 155, 155, 155 ) )
		draw.SimpleText( "SET XP", "wOS.ALCS.DescFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	local XPEntry = vgui.Create( "DTextEntry",self.DataTab )
	XPEntry:MakePopup()
	XPEntry:SetPos( posx + padx, posy + 5*pady + hh*0.2 )
	XPEntry:SetSize( ww*0.6, hh*0.05 )
	XPEntry:SetText( ply:GetSaberXP() )
	XPEntry:SetNumeric( true )
	SXP.DoClick = function()
		net.Start( "wOS.Proficiency.SetXP" )
			net.WriteString( ply:SteamID64() )
			net.WriteInt( tonumber( XPEntry:GetValue() ), 32 )
		net.SendToServer()
	end

	local AddL = vgui.Create( "DButton", self.DataTab )
	AddL:SetPos( ww*0.6 + 2*padx, 7*pady + hh*0.3 )
	AddL:SetSize( ww*0.4 - 3*padx, hh*0.05 )
	AddL:SetText( "" )
	AddL.Paint = function( pan, ww, hh )
		draw.RoundedBox( 5, 0, 0, ww, hh, ( pan:IsDown() and Color( 0, 55, 155, 155 ) ) or Color( 155, 155, 155, 155 ) )
		draw.SimpleText( "ADD LEVEL", "wOS.ALCS.DescFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	local AddLevelEntry = vgui.Create( "DTextEntry",self.DataTab )
	AddLevelEntry:MakePopup()
	AddLevelEntry:SetPos( posx + padx, posy + 7*pady + hh*0.3 )
	AddLevelEntry:SetSize( ww*0.6, hh*0.05 )
	AddLevelEntry:SetText( 0 )
	AddLevelEntry:SetNumeric( true )
	AddL.DoClick = function()
		net.Start( "wOS.Proficiency.AddLevel" )
			net.WriteString( ply:SteamID64() )
			net.WriteInt( tonumber( AddLevelEntry:GetValue() ), 32 )
		net.SendToServer()
	end
	local AddX = vgui.Create( "DButton", self.DataTab )
	AddX:SetPos( ww*0.6 + 2*padx, 8*pady + hh*0.35 )
	AddX:SetSize( ww*0.4 - 3*padx, hh*0.05 )
	AddX:SetText( "" )
	AddX.Paint = function( pan, ww, hh )
		draw.RoundedBox( 5, 0, 0, ww, hh, ( pan:IsDown() and Color( 0, 55, 155, 155 ) ) or Color( 155, 155, 155, 155 ) )
		draw.SimpleText( "ADD XP", "wOS.ALCS.DescFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	local AddXPEntry = vgui.Create( "DTextEntry",self.DataTab )
	AddXPEntry:MakePopup()
	AddXPEntry:SetPos( posx + padx, posy + 8*pady + hh*0.35 )
	AddXPEntry:SetSize( ww*0.6, hh*0.05 )
	AddXPEntry:SetText( 0 )
	AddXPEntry:SetNumeric( true )
	AddX.DoClick = function()
		net.Start( "wOS.Proficiency.AddXP" )
			net.WriteString( ply:SteamID64() )
			net.WriteInt( tonumber( AddXPEntry:GetValue() ), 32 )
		net.SendToServer()
	end

end

function wOS.ALCS.Admin:OpenSpawnMenu()
	self.DataTab:Clear()

	local mw, mh = w*0.5, h*0.5
	local padx, pady = mw*0.01, mw*0.01
	local bpady = mh*0.01
	local basew, baseh = mw*0.25, mh 
	local cw, ch = ( basew - 1.5*padx ), baseh - 2*pady
	local ww, hh = self.DataTab:GetSize()
	local posx, posy = self.DataTab:GetPos()
	local possx, possy = self.AdminMenu:GetPos()
	posx = possx + posx
	posy = possy + posy
	
	local ItemList = vgui.Create( "DListView", self.DataTab )
	ItemList:SetMultiSelect( false )
	ItemList:AddColumn( "Item Name" )
	ItemList:SetPos( padx, pady )
	ItemList:SetSize( ww - 2*padx, hh*0.85 )
	
	//MANUAL SORTING SORT OF!!!
	//Could probably use a function in table.sort but whatever
	local lst = {}
	for item, dat in pairs( wOS.ItemList ) do
		lst[ #lst + 1 ] = item
	end
	table.sort(lst)
	for _, item in pairs( lst ) do
		ItemList:AddLine( item )
	end	
	
	local AddL = vgui.Create( "DButton", self.DataTab )
	AddL:SetPos( padx, 2*pady + hh*0.85 )
	AddL:SetSize( ww - 2*padx, hh*0.05 )
	AddL:SetText( "" )
	AddL.Paint = function( pan, ww, hh )
		draw.RoundedBox( 5, 0, 0, ww, hh, ( pan:IsDown() and Color( 0, 55, 155, 155 ) ) or Color( 155, 155, 155, 155 ) )
		draw.SimpleText( "SPAWN SELECTED ITEM", "wOS.ALCS.DescFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	AddL.DoClick = function()
		local sel = ItemList:GetSelectedLine()
		if not sel or sel < 1 then return end
		local dat = ItemList:GetLine( sel )
		if not dat then return end
		local item = dat:GetColumnText( 1 )
		if not item or #item < 1 then return end
		wOS.ALCS.Admin.BufferInfo = {}
		net.Start( "wOS.Crafting.AdminSpawnItem" )
			net.WriteString( item )
		net.SendToServer()
	end	
	
end

function wOS.ALCS.Admin:OpenStorageMenu( ply )
	net.Start( "wOS.Storage.RequestStorage" )
		net.WriteString( ply:SteamID64() )
	net.SendToServer()
	self.DataTab:Clear()
	
	local mw, mh = w*0.5, h*0.5
	local padx, pady = mw*0.01, mw*0.01
	local bpady = mh*0.01
	local basew, baseh = mw*0.25, mh 
	local cw, ch = ( basew - 1.5*padx ), baseh - 2*pady
	local ww, hh = self.DataTab:GetSize()
	local posx, posy = self.DataTab:GetPos()
	local possx, possy = self.AdminMenu:GetPos()
	posx = possx + posx
	posy = possy + posy
	
	
	local ItemList = vgui.Create( "DListView", self.DataTab )
	ItemList:SetMultiSelect( false )
	ItemList:AddColumn( "Item Name" )
	ItemList:SetPos( padx, pady  )
	ItemList:SetSize( ww - 2*padx, hh*0.4 )
	
	//MANUAL SORTING SORT OF!!!
	//Could probably use a function in table.sort but whatever
	local lst = {}
	for item, dat in pairs( wOS.ItemList ) do
		if dat.Type == WOSTYPE.RAWMATERIAL then continue end
		lst[ #lst + 1 ] = item
	end
	table.sort(lst)
	for _, item in pairs( lst ) do
		ItemList:AddLine( item )
	end	
	
	local AddL = vgui.Create( "DButton", self.DataTab )
	AddL:SetPos( padx, 2*pady + hh*0.4 )
	AddL:SetSize( ww - 2*padx, hh*0.05 )
	AddL:SetText( "" )
	AddL.Paint = function( pan, ww, hh )
		draw.RoundedBox( 5, 0, 0, ww, hh, ( pan:IsDown() and Color( 0, 55, 155, 155 ) ) or Color( 155, 155, 155, 155 ) )
		draw.SimpleText( "ADD SELECTED ITEM TO SLOT", "wOS.ALCS.DescFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end

	local InvenList = vgui.Create( "DListView", self.DataTab )
	InvenList:SetMultiSelect( false )
	InvenList:AddColumn( "Slot" )
	InvenList:AddColumn( "Item" )
	InvenList:AddColumn( "Amount" )
	InvenList:SetPos( padx , 3*pady + hh*0.45 )
	InvenList:SetSize( ww - 2*padx, hh*0.4 - 3*pady )
	InvenList.Think = function( pan )
		if not self.BufferInfo.Received then
			pan.Refreshed = false
		else
			if not pan.Refreshed then
				InvenList:Clear()
				local slots = self.BufferInfo.Data.MaxSlots or wOS.ALCS.Config.Storage.StartingSpace
				for i=1, slots do
					local dat = self.BufferInfo.Data.Backpack[i]
					local name = dat
					local amount = 1
					if istable( dat ) then
						name = dat.Name
						amount = dat.Amount or 1
					end
					if not name then name = "Empty" end
					if name == "Empty" then amount = "N/A" end
					InvenList:AddLine( i, name, amount )
				end
				pan.Refreshed = true
			end
		end
	end
	
	AddL.DoClick = function()
		local sel = ItemList:GetSelectedLine()
		if not sel or sel < 1 then return end
		local dat = ItemList:GetLine( sel )
		if not dat then return end
		local item = dat:GetColumnText( 1 )
		if not item or #item < 1 then return end
		
		local sel2 = InvenList:GetSelectedLine()
		if not sel2 or sel2 < 1 then return end
		local dat = InvenList:GetLine( sel2 )
		if not dat then return end
		local slot = dat:GetColumnText( 1 )
		if not slot then return end
		
		wOS.ALCS.Admin.BufferInfo = {}
		net.Start( "wOS.Storage.AdminAddItem" )
			net.WriteString( item )
			net.WriteInt( tonumber( slot ), 32 )
			net.WriteString( ply:SteamID64() )
		net.SendToServer()
	end	
	
	
	local RemoveItem = vgui.Create( "DButton", self.DataTab )
	RemoveItem:SetPos( padx, hh*0.85 + pady )
	RemoveItem:SetSize( ww - 2*padx, hh*0.05 )
	RemoveItem:SetText( "" )
	RemoveItem.Paint = function( pan, ww, hh )
		draw.RoundedBox( 5, 0, 0, ww, hh, ( pan:IsDown() and Color( 0, 55, 155, 155 ) ) or Color( 155, 155, 155, 155 ) )
		draw.SimpleText( "REMOVE SELECTED ITEM", "wOS.ALCS.DescFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	RemoveItem.DoClick = function()
		local sel = InvenList:GetSelectedLine()
		if not sel or sel < 1 then return end
		local dat = InvenList:GetLine( sel )
		if not dat then return end
		local slot = dat:GetColumnText( 1 )
		if not slot then return end
		wOS.ALCS.Admin.BufferInfo = {}
		net.Start( "wOS.Storage.AdminRemoveItem" )
			net.WriteInt( tonumber( slot ), 32 )
			net.WriteString( ply:SteamID64() )
		net.SendToServer()
	end	
	
	local ClearSlot = vgui.Create( "DButton", self.DataTab )
	ClearSlot:SetPos( padx, hh*0.9 + 2*pady )
	ClearSlot:SetSize( ww - 2*padx, hh*0.05 )
	ClearSlot:SetText( "" )
	ClearSlot.Paint = function( pan, ww, hh )
		draw.RoundedBox( 5, 0, 0, ww, hh, ( pan:IsDown() and Color( 0, 55, 155, 155 ) ) or Color( 155, 155, 155, 155 ) )
		draw.SimpleText( "CLEAR SELECTED SLOT", "wOS.ALCS.DescFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	ClearSlot.DoClick = function()
		local sel = InvenList:GetSelectedLine()
		if not sel or sel < 1 then return end
		local dat = InvenList:GetLine( sel )
		if not dat then return end
		local slot = dat:GetColumnText( 1 )
		if not slot then return end
		wOS.ALCS.Admin.BufferInfo = {}
		net.Start( "wOS.Storage.AdminClearSlot" )
			net.WriteInt( tonumber( slot ), 32 )
			net.WriteString( ply:SteamID64() )
		net.SendToServer()
	end	
end

function wOS.ALCS.Admin:OpenPrestigeMenu( ply )

	net.Start( "wOS.Prestige.AdminRequestPrestige" )
		net.WriteString( ply:SteamID64() )
	net.SendToServer()
	self.DataTab:Clear()
	
	local mw, mh = w*0.5, h*0.5
	local padx, pady = mw*0.01, mw*0.01
	local bpady = mh*0.01
	local basew, baseh = mw*0.25, mh 
	local cw, ch = ( basew - 1.5*padx ), baseh - 2*pady
	local ww, hh = self.DataTab:GetSize()
	local posx, posy = self.DataTab:GetPos()
	local possx, possy = self.AdminMenu:GetPos()
	posx = possx + posx
	posy = possy + posy
	
	local AddL = vgui.Create( "DButton", self.DataTab )
	AddL:SetPos( ww*0.6 + 2*padx, pady)
	AddL:SetSize( ww*0.4 - 3*padx, hh*0.05 )
	AddL:SetText( "" )
	AddL.Paint = function( pan, ww, hh )
		draw.RoundedBox( 5, 0, 0, ww, hh, ( pan:IsDown() and Color( 0, 55, 155, 155 ) ) or Color( 155, 155, 155, 155 ) )
		draw.SimpleText( "ADD MASTERY", "wOS.ALCS.DescFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	local AddLevelEntry = vgui.Create( "DComboBox",self.DataTab )
	AddLevelEntry:SetPos( padx, pady )
	AddLevelEntry:SetSize( ww*0.6, hh*0.05 )
	AddLevelEntry:SetValue( "" )
	local id_trans = {}
	for slot, dat in pairs( wOS.ALCS.Prestige.MapData.Paths ) do
		AddLevelEntry:AddChoice( dat.Name )
		id_trans[ dat.Name ] = slot
	end
	
	AddL.DoClick = function()
		local tree = AddLevelEntry:GetSelected()
		if not tree or #tree < 1 then return end
		local id = id_trans[ tree ]
		if not id then return end
		wOS.ALCS.Admin.BufferInfo = {}
		net.Start( "wOS.Prestige.AdminAddPrestigeMastery" )
			net.WriteInt( id, 32 )
			net.WriteString( ply:SteamID64() )
		net.SendToServer()
	end
	
	local SkillList = vgui.Create( "DListView", self.DataTab )
	SkillList:SetMultiSelect( false )
	SkillList:AddColumn( "ID" )
	SkillList:AddColumn( "Mastery Name" )
	SkillList:SetPos( padx , 2*pady + hh*0.05 )
	SkillList:SetSize( ww - 2*padx, hh*0.6 - 2*pady )
	SkillList.Think = function( pan )
		if not self.BufferInfo.Received then
			pan.Refreshed = false
		else
			if not pan.Refreshed then
				SkillList:Clear()
				for mastery, _ in pairs( self.BufferInfo.Data.Mastery ) do
					local mdat = wOS.ALCS.Prestige.MapData.Paths[ mastery ]
					if not mdat then continue end
					SkillList:AddLine( mastery, mdat.Name )
				end
				pan.Refreshed = true
			end
		end
	end
	
	local RemoveWL = vgui.Create( "DButton", self.DataTab )
	RemoveWL:SetPos( padx, hh*0.65 + pady )
	RemoveWL:SetSize( ww - 2*padx, hh*0.05 )
	RemoveWL:SetText( "" )
	RemoveWL.Paint = function( pan, ww, hh )
		draw.RoundedBox( 5, 0, 0, ww, hh, ( pan:IsDown() and Color( 0, 55, 155, 155 ) ) or Color( 155, 155, 155, 155 ) )
		draw.SimpleText( "REMOVE SELECTED MASTERY", "wOS.ALCS.DescFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	RemoveWL.DoClick = function()
		local sel = SkillList:GetSelectedLine()
		if not sel or sel < 1 then return end
		local dat = SkillList:GetLine( sel )
		if not dat then return end
		local ID = dat:GetColumnText( 1 )
		if not ID then return end
		wOS.ALCS.Admin.BufferInfo = {}
		net.Start( "wOS.Prestige.AdminRemovePrestigeMastery" )
			net.WriteInt( ID, 32 )
			net.WriteString( ply:SteamID64() )
		net.SendToServer()
	end	
	
	local AddX = vgui.Create( "DButton", self.DataTab )
	AddX:SetPos( ww*0.6 + 2*padx, 2*pady + hh*0.7 )
	AddX:SetSize( ww*0.4 - 3*padx, hh*0.05 )
	AddX:SetText( "" )
	AddX.Paint = function( pan, ww, hh )
		draw.RoundedBox( 5, 0, 0, ww, hh, ( pan:IsDown() and Color( 0, 55, 155, 155 ) ) or Color( 155, 155, 155, 155 ) )
		draw.SimpleText( "ADD TOKENS", "wOS.ALCS.DescFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	local AddXPEntry = vgui.Create( "DTextEntry",self.DataTab )
	AddXPEntry:MakePopup()
	AddXPEntry:SetPos( posx + padx, posy + 2*pady + hh*0.7 )
	AddXPEntry:SetSize( ww*0.6, hh*0.05 )
	AddXPEntry:SetText( 0 )
	AddXPEntry:SetNumeric( true )
	AddX.DoClick = function()
		wOS.ALCS.Admin.BufferInfo = {}
		net.Start( "wOS.Prestige.AdminSetPrestigeTokens" )
			net.WriteString( ply:SteamID64() )
			net.WriteInt( tonumber( AddXPEntry:GetValue() ), 32 )
		net.SendToServer()
	end
	local AddSK = vgui.Create( "DButton", self.DataTab )
	AddSK:SetPos( ww*0.6 + 2*padx, 3*pady + hh*0.75 )
	AddSK:SetSize( ww*0.4 - 3*padx, hh*0.05 )
	AddSK:SetText( "" )
	AddSK.Paint = function( pan, ww, hh )
		draw.RoundedBox( 5, 0, 0, ww, hh, ( pan:IsDown() and Color( 0, 55, 155, 155 ) ) or Color( 155, 155, 155, 155 ) )
		draw.SimpleText( "ADD LEVEL", "wOS.ALCS.DescFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	local AddSkillEntry = vgui.Create( "DTextEntry",self.DataTab )
	AddSkillEntry:MakePopup()
	AddSkillEntry:SetPos( posx + padx, posy + 3*pady + hh*0.75 )
	AddSkillEntry:SetSize( ww*0.6, hh*0.05 )
	AddSkillEntry:SetText( 0 )
	AddSkillEntry:SetNumeric( true )
	AddSK.DoClick = function()
		wOS.ALCS.Admin.BufferInfo = {}
		net.Start( "wOS.Prestige.AdminSetPrestigeLevel" )
			net.WriteString( ply:SteamID64() )
			net.WriteInt( tonumber( AddSkillEntry:GetValue() ), 32 )
		net.SendToServer()
	end
	
end

function wOS.ALCS.Admin:OpenSpiritMenu( ply )

	net.Start( "wOS.Dueling.RequestSpiritData" )
		net.WriteString( ply:SteamID64() )
	net.SendToServer()
	self.DataTab:Clear()
	
	local mw, mh = w*0.5, h*0.5
	local padx, pady = mw*0.01, mw*0.01
	local bpady = mh*0.01
	local basew, baseh = mw*0.25, mh 
	local cw, ch = ( basew - 1.5*padx ), baseh - 2*pady
	local ww, hh = self.DataTab:GetSize()
	local posx, posy = self.DataTab:GetPos()
	local possx, possy = self.AdminMenu:GetPos()
	posx = possx + posx
	posy = possy + posy
	
	
	local SpiritList = vgui.Create( "DListView", self.DataTab )
	SpiritList:SetMultiSelect( false )
	SpiritList:AddColumn( "Spirit Name" )
	SpiritList:SetPos( padx, pady  )
	SpiritList:SetSize( ww - 2*padx, hh*0.4 )
	
	//MANUAL SORTING SORT OF!!!
	//Could probably use a function in table.sort but whatever
	local lst = {}
	for item, dat in pairs( wOS.ALCS.Dueling.Spirits ) do
		lst[ #lst + 1 ] = item
	end

	table.sort(lst)
	for _, item in pairs( lst ) do
		SpiritList:AddLine( item )
	end	
	
	local AddL = vgui.Create( "DButton", self.DataTab )
	AddL:SetPos( padx, 2*pady + hh*0.4 )
	AddL:SetSize( ww - 2*padx, hh*0.05 )
	AddL:SetText( "" )
	AddL.Paint = function( pan, ww, hh )
		draw.RoundedBox( 5, 0, 0, ww, hh, ( pan:IsDown() and Color( 0, 55, 155, 155 ) ) or Color( 155, 155, 155, 155 ) )
		draw.SimpleText( "ADD SELECTED SPIRIT", "wOS.ALCS.DescFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	AddL.DoClick = function()
		local sel = SpiritList:GetSelectedLine()
		if not sel or sel < 1 then return end
		local dat = SpiritList:GetLine( sel )
		if not dat then return end
		local item = dat:GetColumnText( 1 )
		if not item or #item < 1 then return end
		wOS.ALCS.Admin.BufferInfo = {}
		net.Start( "wOS.Dueling.AddAdminSpirit" )
			net.WriteString( ply:SteamID64() )
			net.WriteString( item )
		net.SendToServer()
	end	
	
	local SpirInvList = vgui.Create( "DListView", self.DataTab )
	SpirInvList:SetMultiSelect( false )
	SpirInvList:AddColumn( "Spirit" )
	SpirInvList:AddColumn( "Level" )
	SpirInvList:AddColumn( "Energy" )
	SpirInvList:SetPos( padx , 3*pady + hh*0.45 )
	SpirInvList:SetSize( ww - 2*padx, hh*0.3 - 3*pady )
	SpirInvList.Think = function( pan )
		if not self.BufferInfo.Received then
			pan.Refreshed = false
		else
			if not pan.Refreshed then
				SpirInvList:Clear()
				for name, dat in pairs( self.BufferInfo.Data ) do
					if not wOS.ALCS.Dueling.Spirits[ name ] then continue end
					local name = name
					local amount = 1
					SpirInvList:AddLine( name, dat.level, dat.experience )
				end
				pan.Refreshed = true
			end
		end
	end
	
	local RemoveItem = vgui.Create( "DButton", self.DataTab )
	RemoveItem:SetPos( padx, hh*0.75 + pady )
	RemoveItem:SetSize( ww - 2*padx, hh*0.05 )
	RemoveItem:SetText( "" )
	RemoveItem.Paint = function( pan, ww, hh )
		draw.RoundedBox( 5, 0, 0, ww, hh, ( pan:IsDown() and Color( 0, 55, 155, 155 ) ) or Color( 155, 155, 155, 155 ) )
		draw.SimpleText( "REMOVE SELECTED SPIRIT", "wOS.ALCS.DescFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	RemoveItem.DoClick = function()
		local sel = SpirInvList:GetSelectedLine()
		if not sel or sel < 1 then return end
		local dat = SpirInvList:GetLine( sel )
		if not dat then return end
		local item = dat:GetColumnText( 1 )
		if not item or #item < 1 then return end
		wOS.ALCS.Admin.BufferInfo = {}
		net.Start( "wOS.Dueling.RemoveAdminSpirit" )
			net.WriteString( ply:SteamID64() )
			net.WriteString( item )
		net.SendToServer()
	end	

	local AddSLevel = vgui.Create( "DButton", self.DataTab )
	AddSLevel:SetPos( ww*0.6 + 2*padx, 2*pady + hh*0.8 )
	AddSLevel:SetSize( ww*0.4 - 3*padx, hh*0.05 )
	AddSLevel:SetText( "" )
	AddSLevel.Paint = function( pan, ww, hh )
		draw.RoundedBox( 5, 0, 0, ww, hh, ( pan:IsDown() and Color( 0, 55, 155, 155 ) ) or Color( 155, 155, 155, 155 ) )
		draw.SimpleText( "SET LEVEL", "wOS.ALCS.DescFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	local AddSLevelPEntry = vgui.Create( "DTextEntry",self.DataTab )
	AddSLevelPEntry:MakePopup()
	AddSLevelPEntry:SetPos( posx + padx, posy + 2*pady + hh*0.8 )
	AddSLevelPEntry:SetSize( ww*0.6, hh*0.05 )
	AddSLevelPEntry:SetText( 0 )
	AddSLevelPEntry:SetNumeric( true )
	AddSLevel.DoClick = function()
		local sel = SpirInvList:GetSelectedLine()
		if not sel or sel < 1 then return end
		local dat = SpirInvList:GetLine( sel )
		if not dat then return end
		local item = dat:GetColumnText( 1 )
		if not item or #item < 1 then return end
		wOS.ALCS.Admin.BufferInfo = {}
		net.Start( "wOS.Dueling.SetAdminSpiritLevel" )
			net.WriteString( ply:SteamID64() )
			net.WriteString( item )
			net.WriteInt( tonumber( AddSLevelPEntry:GetValue() ), 32 )
		net.SendToServer()
	end

	local AddSE = vgui.Create( "DButton", self.DataTab )
	AddSE:SetPos( ww*0.6 + 2*padx, 3*pady + hh*0.85 )
	AddSE:SetSize( ww*0.4 - 3*padx, hh*0.05 )
	AddSE:SetText( "" )
	AddSE.Paint = function( pan, ww, hh )
		draw.RoundedBox( 5, 0, 0, ww, hh, ( pan:IsDown() and Color( 0, 55, 155, 155 ) ) or Color( 155, 155, 155, 155 ) )
		draw.SimpleText( "SET ENERGY", "wOS.ALCS.DescFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	local AddSEEntry = vgui.Create( "DTextEntry",self.DataTab )
	AddSEEntry:MakePopup()
	AddSEEntry:SetPos( posx + padx, posy + 3*pady + hh*0.85 )
	AddSEEntry:SetSize( ww*0.6, hh*0.05 )
	AddSEEntry:SetText( 0 )
	AddSEEntry:SetNumeric( true )
	AddSE.DoClick = function()
		local sel = SpirInvList:GetSelectedLine()
		if not sel or sel < 1 then return end
		local dat = SpirInvList:GetLine( sel )
		if not dat then return end
		local item = dat:GetColumnText( 1 )
		if not item or #item < 1 then return end
		wOS.ALCS.Admin.BufferInfo = {}
		net.Start( "wOS.Dueling.SetAdminSpiritXP" )
			net.WriteString( ply:SteamID64() )
			net.WriteString( item )
			net.WriteInt( tonumber( AddSEEntry:GetValue() ), 32 )
		net.SendToServer()
	end

end

function wOS.ALCS.Admin:OpenArtMenu( ply )

	net.Start( "wOS.Dueling.AdminRequestArtifacts" )
		net.WriteString( ply:SteamID64() )
	net.SendToServer()

	self.DataTab:Clear()
	
	local mw, mh = w*0.5, h*0.5
	local padx, pady = mw*0.01, mw*0.01
	local bpady = mh*0.01
	local basew, baseh = mw*0.25, mh 
	local cw, ch = ( basew - 1.5*padx ), baseh - 2*pady
	local ww, hh = self.DataTab:GetSize()
	local posx, posy = self.DataTab:GetPos()
	local possx, possy = self.AdminMenu:GetPos()
	posx = possx + posx
	posy = possy + posy
	
	
	local ATTList = vgui.Create( "DListView", self.DataTab )
	ATTList:SetMultiSelect( false )
	ATTList:AddColumn( "Artifact Name" )
	ATTList:SetPos( padx, pady  )
	ATTList:SetSize( ww - 2*padx, hh*0.4 )
	
	//MANUAL SORTING SORT OF!!!
	//Could probably use a function in table.sort but whatever
	local lst = {}
	for item, dat in pairs( wOS.ALCS.Dueling.Artifact.List ) do
		lst[ #lst + 1 ] = item
	end
	table.sort(lst)
	for _, item in pairs( lst ) do
		ATTList:AddLine( item )
	end	
	
	local AddL = vgui.Create( "DButton", self.DataTab )
	AddL:SetPos( padx, 2*pady + hh*0.4 )
	AddL:SetSize( ww - 2*padx, hh*0.05 )
	AddL:SetText( "" )
	AddL.Paint = function( pan, ww, hh )
		draw.RoundedBox( 5, 0, 0, ww, hh, ( pan:IsDown() and Color( 0, 55, 155, 155 ) ) or Color( 155, 155, 155, 155 ) )
		draw.SimpleText( "ADD SELECTED ARTIFACT", "wOS.ALCS.DescFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	AddL.DoClick = function()
		local sel = ATTList:GetSelectedLine()
		if not sel or sel < 1 then return end
		local dat = ATTList:GetLine( sel )
		if not dat then return end
		local item = dat:GetColumnText( 1 )
		if not item or #item < 1 then return end
		wOS.ALCS.Admin.BufferInfo = {}
		net.Start( "wOS.Dueling.GiveAdminArtifact" )
			net.WriteString( ply:SteamID64() )
			net.WriteString( item )
		net.SendToServer()
	end	
	
	local ArtList = vgui.Create( "DListView", self.DataTab )
	ArtList:SetMultiSelect( false )
	ArtList:AddColumn( "Artifact" )
	ArtList:AddColumn( "Amount" )
	ArtList:SetPos( padx , 3*pady + hh*0.45 )
	ArtList:SetSize( ww - 2*padx, hh*0.4 - 3*pady )
	ArtList.Think = function( pan )
		if not self.BufferInfo.Received then
			pan.Refreshed = false
		else
			if not pan.Refreshed then
				ArtList:Clear()
				for name, amt in pairs( self.BufferInfo.Data ) do
					if not wOS.ALCS.Dueling.Artifact.List[ name ] then continue end
					local name = name
					local amount = 1
					ArtList:AddLine( name, amt )
				end
				pan.Refreshed = true
			end
		end
	end
	
	local RemoveItem = vgui.Create( "DButton", self.DataTab )
	RemoveItem:SetPos( padx, hh*0.85 + pady )
	RemoveItem:SetSize( ww - 2*padx, hh*0.05 )
	RemoveItem:SetText( "" )
	RemoveItem.Paint = function( pan, ww, hh )
		draw.RoundedBox( 5, 0, 0, ww, hh, ( pan:IsDown() and Color( 0, 55, 155, 155 ) ) or Color( 155, 155, 155, 155 ) )
		draw.SimpleText( "REMOVE SELECTED ITEM", "wOS.ALCS.DescFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	RemoveItem.DoClick = function()
		local sel = ArtList:GetSelectedLine()
		if not sel or sel < 1 then return end
		local dat = ArtList:GetLine( sel )
		if not dat then return end
		local item = dat:GetColumnText( 1 )
		if not item or #item < 1 then return end
		wOS.ALCS.Admin.BufferInfo = {}
		net.Start( "wOS.Dueling.RemoveAdminArtifact" )
			net.WriteString( ply:SteamID64() )
			net.WriteString( item )
		net.SendToServer()
	end	
	
	local ClearSlot = vgui.Create( "DButton", self.DataTab )
	ClearSlot:SetPos( padx, hh*0.9 + 2*pady )
	ClearSlot:SetSize( ww - 2*padx, hh*0.05 )
	ClearSlot:SetText( "" )
	ClearSlot.Paint = function( pan, ww, hh )
		draw.RoundedBox( 5, 0, 0, ww, hh, ( pan:IsDown() and Color( 0, 55, 155, 155 ) ) or Color( 155, 155, 155, 155 ) )
		draw.SimpleText( "CLEAR SELECTED SLOT", "wOS.ALCS.DescFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	ClearSlot.DoClick = function()
		local sel = ArtList:GetSelectedLine()
		if not sel or sel < 1 then return end
		local dat = ArtList:GetLine( sel )
		if not dat then return end
		local item = dat:GetColumnText( 1 )
		if not item or #item < 1 then return end
		wOS.ALCS.Admin.BufferInfo = {}
		net.Start( "wOS.Dueling.ClearAdminArtifact" )
			net.WriteString( ply:SteamID64() )
			net.WriteString( item )
		net.SendToServer()
	end	
	
end

function wOS.ALCS.Admin:OpenExecWLMenu( ply )

	net.Start( "wOS.ExecSys.AdminRequestExecWL" )
		net.WriteString( ply:SteamID64() )
	net.SendToServer()
	self.DataTab:Clear()
	
	local mw, mh = w*0.5, h*0.5
	local padx, pady = mw*0.01, mw*0.01
	local bpady = mh*0.01
	local basew, baseh = mw*0.25, mh 
	local cw, ch = ( basew - 1.5*padx ), baseh - 2*pady
	local ww, hh = self.DataTab:GetSize()
	local posx, posy = self.DataTab:GetPos()
	local possx, possy = self.AdminMenu:GetPos()
	posx = possx + posx
	posy = possy + posy
	
	local AddL = vgui.Create( "DButton", self.DataTab )
	AddL:SetPos( ww*0.6 + 2*padx, pady)
	AddL:SetSize( ww*0.4 - 3*padx, hh*0.05 )
	AddL:SetText( "" )
	AddL.Paint = function( pan, ww, hh )
		draw.RoundedBox( 5, 0, 0, ww, hh, ( pan:IsDown() and Color( 0, 55, 155, 155 ) ) or Color( 155, 155, 155, 155 ) )
		draw.SimpleText( "ADD EXECUTION", "wOS.ALCS.DescFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	local AddLevelEntry = vgui.Create( "DComboBox",self.DataTab )
	AddLevelEntry:SetPos( padx, pady )
	AddLevelEntry:SetSize( ww*0.6, hh*0.05 )
	AddLevelEntry:SetValue( "" )
	for exec, dat in pairs( wOS.ALCS.ExecSys.Executions ) do
		AddLevelEntry:AddChoice( exec )
	end
	AddL.DoClick = function()
		local tree = AddLevelEntry:GetSelected()
		if not tree or #tree < 1 then return end
		wOS.ALCS.Admin.BufferInfo = {}
		net.Start( "wOS.ExecSys.AddWL" )
			net.WriteString( tree )
			net.WriteString( ply:SteamID64() )
		net.SendToServer()
	end
	
	local SkillList = vgui.Create( "DListView", self.DataTab )
	SkillList:SetMultiSelect( false )
	SkillList:AddColumn( "Execution" )
	SkillList:SetPos( padx , 2*pady + hh*0.05 )
	SkillList:SetSize( ww - 2*padx, hh*0.8 - 2*pady )
	SkillList.Think = function( pan )
		if not self.BufferInfo.Received then
			pan.Refreshed = false
		else
			if not pan.Refreshed then
				SkillList:Clear()
				for tree, _ in pairs( self.BufferInfo.Data ) do
					SkillList:AddLine( tree )
				end
				pan.Refreshed = true
			end
		end
	end
	
	local RemoveWL = vgui.Create( "DButton", self.DataTab )
	RemoveWL:SetPos( padx, hh*0.85 + pady )
	RemoveWL:SetSize( ww - 2*padx, hh*0.05 )
	RemoveWL:SetText( "" )
	RemoveWL.Paint = function( pan, ww, hh )
		draw.RoundedBox( 5, 0, 0, ww, hh, ( pan:IsDown() and Color( 0, 55, 155, 155 ) ) or Color( 155, 155, 155, 155 ) )
		draw.SimpleText( "REMOVE SELECTED EXECUTION", "wOS.ALCS.DescFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	RemoveWL.DoClick = function()
		local sel = SkillList:GetSelectedLine()
		if not sel or sel < 1 then return end
		local dat = SkillList:GetLine( sel )
		if not dat then return end
		local tree = dat:GetColumnText( 1 )
		if not tree or #tree < 1 then return end
		wOS.ALCS.Admin.BufferInfo = {}
		net.Start( "wOS.ExecSys.RemoveWL" )
			net.WriteString( tree )
			net.WriteString( ply:SteamID64() )
		net.SendToServer()
	end	
	
end

--addons/wos-grandmaster-einf/lua/wos/advswl/crafting/core/sh_enums.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2020
	
	Contact: www.wiltostech.com
		----------------------------------------]]--








































































WOSTYPE = WOSTYPE or {}

WOSTYPE.CRYSTAL = 1
WOSTYPE.IGNITER = 2
WOSTYPE.IDLE = 3
WOSTYPE.VORTEX = 4
WOSTYPE.HILT = 5
WOSTYPE.MISC1 = 6
WOSTYPE.MISC2 = 7
WOSTYPE.BLUEPRINT = 8
WOSTYPE.RAWMATERIAL = 9
--addons/wos-grandmaster-einf/lua/wos/advswl/crafting/core/cl_net.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2020
	
	Contact: www.wiltostech.com
		----------------------------------------]]--








































































wOS = wOS or {}
wOS.ItemList = wOS.ItemList or {}
wOS.SortedItemList = wOS.SortedItemList or {}
local PLAYER = LocalPlayer()
																																																																																		

net.Receive( "wOS.Crafting.SendPlayerData", function()

	local equipped_items = net.ReadTable()
	local sec_equipped_items = net.ReadTable()
	local localplayer = net.ReadBool()

	PrintTable(equipped_items)
	PrintTable(sec_equipped_items)
	print(localplayer)
	if localplayer then
		wOS.EquippedItems = table.Copy( equipped_items )
		wOS.SecEquippedItems = table.Copy( sec_equipped_items )
	else
		local ply = net.ReadEntity()
		ply.EquippedItems = table.Copy( equipped_items )
		ply.SecEquippedItems = table.Copy( sec_equipped_items )
	end
end )

local DefaultStandard = {
	Name = "Standard",
	Description = "Stock Item",
}

net.Receive( "wOS.Crafting.SendItems", function()

	local newtbl = net.ReadTable()

	wOS.ItemList = wOS.ItemList or {}
	table.Merge( wOS.ItemList, newtbl )

	wOS.SortedItemList = wOS.SortedItemList or {}
	
	for i=1, 7 do
		if wOS.SortedItemList[ i ] then continue end
		wOS.SortedItemList[ i ] = {}
		wOS.SortedItemList[ i ][ "Standard" ] = table.Copy( DefaultStandard )
	end
	
	for i=8, 9 do
		if wOS.SortedItemList[ i ] then continue end
		wOS.SortedItemList[ i ] = {}	
	end
	
	for _, data in pairs( newtbl ) do
		if not wOS.SortedItemList[ data.Type ] then wOS.SortedItemList[ data.Type ] = {} end
		if data.Type == WOSTYPE.BLUEPRINT or data.Type == WOSTYPE.RAWMATERIAL then
			wOS.SortedItemList[ data.Type ][ data.Name ] = data
		else
			if not wOS.SortedItemList[ data.Type ][ "Standard" ] then wOS.SortedItemList[ data.Type ][ "Standard" ] = table.Copy( DefaultStandard ) end
			wOS.SortedItemList[ data.Type ][ data.Name ] = data
		end
	end
	
end )

net.Receive( "wOS.Crafting.RefreshWeapon", function()

	local wep = net.ReadEntity()
	if not IsValid( wep ) then return end
	wep.CustomSettings = net.ReadTable()
	wep.SecCustomSettings = net.ReadTable()
	
end )

net.Receive( "wOS.Crafting.RefreshWeaponDual", function()

	local wep = net.ReadEntity()
	if not IsValid( wep ) then return end
	wep.CustomSettings = net.ReadTable()
	wep.SecCustomSettings = net.ReadTable()

end )

net.Receive( "wOS.Crafting.PreviewChange", function( len, ply )
	
	local second_saber = net.ReadBool()
	if !second_saber then
		wOS.PersonalSaber = net.ReadTable()
	else
		wOS.SecPersonalSaber = net.ReadTable()
	end
	wOS:BuildCraftingSaber()
	
end )

net.Receive( "wOS.Crafting.RefreshCraftMenu", function( len, ply )
	wOS.SaberInventory = net.ReadTable()
	wOS:RebuildCraftingMenus() 
end )

net.Receive( "wOS.Crafting.ViewInventory", function()

	wOS.SaberInventory = net.ReadTable()
	wOS.RawMaterials = net.ReadTable()
	wOS:ViewInventory()
	
end )

net.Receive( "wOS.Crafting.GetInventory", function()

	wOS.SaberInventory = net.ReadTable()
	wOS.RawMaterials = net.ReadTable()
	
end )

net.Receive( "wOS.Crafting.UpdateInventory", function()

	wOS.SaberInventory = net.ReadTable()
	wOS:BuildItemsOnPage()
	
end )

net.Receive( "wOS.Crafting.RefreshInventory", function()

	wOS.SaberInventory = net.ReadTable()
	
end )

net.Receive( "wOS.Crafting.UpdateBlueprints", function()

	wOS.Blueprints = net.ReadTable()
	
end )

net.Receive( "wOS.Crafting.UpdateMaterials", function()

	wOS.RawMaterials = net.ReadTable()
	
end )


net.Receive( "wOS.Crafting.OpenCraftingMenu", function()

	wOS.EquippedItems = net.ReadTable()
	wOS.SecEquippedItems  = net.ReadTable()
	wOS.PersonalSaber = net.ReadTable()
	wOS.SecPersonalSaber = net.ReadTable()
	wOS.SaberInventory = net.ReadTable()
	wOS.SaberMiscSlots = net.ReadTable()
	wOS:OpenSaberCrafting()
	
end )
--addons/wos-grandmaster-einf/lua/wos/advswl/skills/loader/loader.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2020
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--

wOS = wOS or {}

--This order may look completely stupid, and you'd ask why I wouldn't just cluster them all together
--Well, load orders are very important, and this is the best way to control it

if SERVER then
	
	AddCSLuaFile( "wos/advswl/skills/core/sh_core.lua" )
	AddCSLuaFile( "wos/advswl/skills/core/cl_menu_library.lua" )	
	AddCSLuaFile( "wos/advswl/skills/core/cl_classic_ui.lua" )	
	AddCSLuaFile( "wos/advswl/skills/core/cl_new_core.lua" )	
	AddCSLuaFile( "wos/advswl/skills/core/cl_net.lua" )
	
end

if SERVER then

	if wOS.ALCS.Config.Skills.ShouldSkillUseMySQL then
		include( "wos/advswl/skills/wrappers/sv_mysql.lua" )
	else
		include( "wos/advswl/skills/wrappers/sv_data.lua" )
	end
	

	include( "wos/advswl/skills/core/sh_core.lua" )
	wOS.ALCS:ServerInclude( "wos/advswl/skills/core/sv_core.lua" )
	wOS.ALCS:ServerInclude( "wos/advswl/skills/core/sv_skill_register.lua" )
	wOS.ALCS:ServerInclude( "wos/advswl/skills/core/sv_net.lua" )
	wOS.ALCS:ServerInclude( "wos/advswl/skills/core/sv_concommands.lua" )
	

else
	
	include( "wos/advswl/skills/core/sh_core.lua" )	
	include( "wos/advswl/skills/core/cl_menu_library.lua" )	
	include( "wos/advswl/skills/core/cl_new_core.lua" )
	include( "wos/advswl/skills/core/cl_classic_ui.lua" )	
	include( "wos/advswl/skills/core/cl_net.lua" )
	
end
--addons/wos-alcs-custom/lua/wos/advswl/skills/core/cl_menu_library.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2020
	
	Contact: www.wiltostech.com
----------------------------------------]]--

wOS = wOS or {}
wOS.ALCS = wOS.ALCS or {}
wOS.ALCS.Skills = wOS.ALCS.Skills or {}
wOS.ALCS.Skills.Camera = wOS.ALCS.Skills.Camera or {}

surface.CreateFont( "wOS.SkillTreeMain", {
	font = "Roboto Cn",
	extended = false,
	size = 32,
	weight = 1000,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
} )

surface.CreateFont( "wOS.SkillHelpFont", {
	font = "Roboto Cn",
	extended = false,
	size = 21,
	weight = 600,
	blursize = 0,
	scanlines = 1,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
} )

--[[
	This CharWrap and TextWrap is straight from Falco in DarkRP. 
	There are similar ones on the Lua Users recipe, but you gotta give it to the man for making it good as fuck
	THANKS FALCO!
--]]
local function charWrap(text, pxWidth)
	local total = 0

	text = text:gsub(".", function(char)
		total = total + surface.GetTextSize(char)

		-- Wrap around when the max width is reached
		if total >= pxWidth then
			total = 0
			return "\n" .. char
		end

		return char
	end)

	return text, total
end

function wOS.ALCS.Skills.TextWrap(text, font, pxWidth)
	local total = 0

	surface.SetFont(font)

	local spaceSize = surface.GetTextSize(' ')
	text = text:gsub("(%s?[%S]+)", function(word)
			local char = string.sub(word, 1, 1)
			if char == "\n" or char == "\t" then
				total = 0
			end

			local wordlen = surface.GetTextSize(word)
			total = total + wordlen

			-- Wrap around when the max width is reached
			if wordlen >= pxWidth then -- Split the word if the word is too big
				local splitWord, splitPoint = charWrap(word, pxWidth - (total - wordlen))
				total = splitPoint
				return splitWord
			elseif total < pxWidth then
				return word
			end

			-- Split before the word
			if char == ' ' then
				total = wordlen - spaceSize
				return '\n' .. string.sub(word, 2)
			end

			total = wordlen
			return '\n' .. word
		end)

	return text
end

wOS.ALCS.Runes = wOS.ALCS.Runes or {}
local letters = { "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z" }
for i = 1, #letters do
	wOS.ALCS.Runes[ letters[i] ] = Material( "wos/runes/" .. letters[i] .. ".png", "unlitgeneric" )
end

local pi = math.pi

local upButton = Material( "wos/crafting/gui/up.png", "unlitgeneric" )
local downButton = Material( "wos/crafting/gui/down.png", "unlitgeneric" )
local leftButton = Material( "wos/crafting/gui/left.png", "unlitgeneric" )
local rightButton = Material( "wos/crafting/gui/right.png", "unlitgeneric" )
local bufferBar = Material( "wos/crafting/gui/buffer.png", "unlitgeneric" )

local wireFrame = Material( "trails/plasma" )

local SkillBlock = Material( "wos/advswl/skill_holocron.png", "unlitgeneric" )

local centerpoint = wOS.ALCS.Config.Crafting.CraftingCamLocation
local grad = Material( "gui/gradient_up" )

wOS.ALCS.Skills.CubeModels = wOS.ALCS.Skills.CubeModels or {}

wOS.ALCS.Skills.Camera[ "Overview" ] = { origin = centerpoint - Vector( 45, 0, -30 ), angles = Angle( -15.840, 40.501, 0.000 ) }
wOS.ALCS.Skills.MenuLibrary = wOS.ALCS.Skills.MenuLibrary or {}
wOS.ALCS.Skills.MenuLibrary[ "Overview" ] = function()
	local infopane = tduiw.Create()
	infopane.SizeX = 50
	infopane.SizeY = 25
	infopane.ShouldAcceptInputs = true
	infopane.Renders = function( pan )
		local ww, hh = pan.SizeX, pan.SizeY
		local x = -10
		local y = -50

		local level = LocalPlayer():GetNW2Int( "wOS.SkillLevel", 0 )
		local xp = LocalPlayer():GetNW2Int( "wOS.SkillExperience", 0 )
		local reqxp = wOS.ALCS.Config.Skills.XPScaleFormula( level )
		local lastxp = 0
		if level > 0 then
			lastxp = wOS.ALCS.Config.Skills.XPScaleFormula( level - 1 )
		end

		local rat = ( xp - lastxp ) / ( reqxp - lastxp )
		if level == wOS.ALCS.Config.Skills.SkillMaxLevel or ( wOS.ALCS.Config.Prestige.PrestigeLevel and level >= wOS.ALCS.Config.Prestige.PrestigeLevel ) then
			rat = 1
			should_vestige = true
		end

		pan:Text( "DEIN LEVEL", "wOS.CraftTitles", x, y, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )

		local points = LocalPlayer():GetNW2Int( "wOS.SkillPoints", 0 )

		y = y + hh * 0.23
		if points > 0 then
			local rate = math.abs( math.cos( CurTime() * 5 ) )
			pan:Text( "SKILLPUNKTE VERFÜGBAR!", "wOS.TitleFont", x + ww, y, Color( 255*rate, 255 - 255*rate, 255 - 255*rate, 255 ), TEXT_ALIGN_RIGHT, TEXT_ALIGN_BOTTOM )
		end

		pan:Mat( grad, x, y, ww * rat, hh * 0.12, Color( 0, 88, 173, 175 ) )
		pan:Rect( x, y, ww, hh * 0.12, Color( 0,0,0,0 ), color_white )

		y = y + hh * 0.06

		local text = lastxp
		if level == wOS.ALCS.Config.Skills.SkillMaxLevel then text = "MAX" end
		pan:Text( " " .. text, "wOS.CraftDescriptions", x, y, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
		text = reqxp

		if level == wOS.ALCS.Config.Skills.SkillMaxLevel then text = "LEVEL" end

		pan:Text( text .. " ", "wOS.CraftDescriptions", x + ww, y, color_white, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER )
		pan:Text( "|", "wOS.CraftDescriptions", x + ww / 2, y, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )

		pan:BlockUseBind()
	end

	infopane:SetUIScale( 20 )
	infopane.Scaling = 0.05

	local spos = wOS.ALCS.Skills.Menu.Player:GetPos()
	infopane.CamPos = spos + wOS.ALCS.Skills.Menu.Player:GetRight()*20 + wOS.ALCS.Skills.Menu.Player:GetUp() * 30
	infopane.CamAng = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].angles + Angle( 0, 0, 0 )
	table.insert( wOS.ALCS.Skills.Menu.VGUI, infopane )

	local sidepane = tduiw.Create()
	sidepane.SizeX = 10
	sidepane.SizeY = 15
	sidepane.LastHover = 0
	sidepane.ShouldAcceptInputs = true
	sidepane.Renders = function( pan )
		local ww, hh = pan.SizeX, pan.SizeY
		local x = -65 + ww
		local y = -30
		local bh = hh / 3

		pan:Rect( x, y, ww, hh, Color( 25, 25, 25, 25 ), color_white )

		local lst = 0
		local image = wOS.ALCS.Runes[ "s" ]
		pan:Mat( image, x, y, ww, bh )
		local _jp, _pr, _hov = pan:Button( "", "wOS.TitleFont", x, y, ww, bh, color_white, color_white )
		if _jp then
			wOS.ALCS.Skills:ChangeCamFocus( "Skill-Overview" )
		elseif _hov then
			local speed = 0.1
			if not pan.SlideTimes then
				pan.SlideTimes = CurTime() + speed
				surface.PlaySound( "wos/alcs/ui_slideout.wav" )
			end

			if pan.LastButt != lst then
				surface.PlaySound( "wos/alcs/ui_rollover.wav" )
				pan.LastButt = lst
			end

			local rat = math.Clamp( pan.SlideTimes - CurTime(), 0, speed ) / speed
			pan:Rect( x + ww, y, ww * ( 3 - 3 * rat  ), bh, Color( 10, 10, 10, 255 ), color_white )
			pan:Text( "SKILL HOLOCRON", "wOS.CraftDescriptions", x + ww * 2*( 1 - rat  ), y + bh/2, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
			pan.LastHover = CurTime() + 0.01
		end

		y = y + bh
		lst = lst + 1

		image = wOS.ALCS.Runes[ "c" ]
		pan:Mat( image, x, y, ww, bh )	
		local _jp, _pr, _hov = pan:Button( "", "wOS.TitleFont", x, y, ww, bh, color_white, color_white )
		if _jp then
			if not wOS.ALCS.Skills.MenuLibrary[ "Combat-Overview" ] then return end
			wOS.ALCS.Skills:ChangeCamFocus( "Combat-Overview"  )
		elseif _hov then
			local speed = 0.1
			if not pan.SlideTimes then 
				pan.SlideTimes = CurTime() + speed
				surface.PlaySound( "wos/alcs/ui_slideout.wav" )
			end
			if pan.LastButt != lst then
				surface.PlaySound( "wos/alcs/ui_rollover.wav" )
				pan.LastButt = lst
			end
			local rat = math.Clamp( pan.SlideTimes - CurTime(), 0, speed )/speed
			pan:Rect( x + ww, y, ww * ( 3 - 3*rat  ), bh, Color( 10, 10, 10, 255 ), color_white )
			pan:Text( "KAMPFHOLOCRON", "wOS.CraftDescriptions", x + ww * 1.4 * ( 1 - rat  ), y + bh / 2, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
			pan.LastHover = CurTime() + 0.01
		end

		y = y + bh
		lst = lst + 1
		image = wOS.ALCS.Runes[ "x" ]
		pan:Mat( image, x, y, ww, bh )	
		local _jp, _pr, _hov = pan:Button( "", "wOS.TitleFont", x, y, ww, bh, color_white, color_white )

		if _hov then
			local speed = 0.1
			if not pan.SlideTimes then 
				pan.SlideTimes = CurTime() + speed
				surface.PlaySound( "wos/alcs/ui_slideout.wav" )
			end
			if pan.LastButt != lst then
				surface.PlaySound( "wos/alcs/ui_rollover.wav" )
				pan.LastButt = lst
			end
			local rat = math.Clamp( pan.SlideTimes - CurTime(), 0, speed )/speed
			pan:Rect( x + ww, y, ww*( 3 - 3*rat  ), bh, Color( 10, 10, 10, 255 ), color_white )
			pan:Text( "SCHLIEßEN", "wOS.CraftDescriptions", x + ww*2.1*( 1 - rat  ), y + bh/2, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
			pan.LastHover = CurTime() + 0.01
		end
		if _jp then
			wOS.ALCS.Skills:CloseSkillsMenu()
		end

		if pan.SlideTimes and pan.LastHover < CurTime() then
			pan.SlideTimes	= nil
			pan.LastButt = nil
		end

		pan:BlockUseBind()
	end

	sidepane:SetUIScale( 20 )
	sidepane.Scaling = 0.05

	sidepane.CamPos = infopane.CamPos
	sidepane.CamAng = infopane.CamAng
	table.insert( wOS.ALCS.Skills.Menu.VGUI, sidepane )
end

wOS.ALCS.Skills.Camera[ "Skill-Overview" ] = { origin = centerpoint - Vector( 45, -35, -30 ), angles = Angle( 0, 90.501, 0.000 ) }
wOS.ALCS.Skills.MenuLibrary[ "Skill-Overview" ] = function()
	wOS.ALCS.Skills.Menu.MinH = nil
	local leftpane = tduiw.Create()
	leftpane.SizeX = 8
	leftpane.SizeY = 35
	leftpane.ShouldAcceptInputs = true
	leftpane.Renders = function( pan )
		local ww, hh = pan.SizeX, pan.SizeY
		local x = -30
		local y = -hh * 0.4
		local bh = hh / 7

		pan:Line( 0, -hh / 2, x + ww, y + bh / 2 )

		local lst = 0
		image = wOS.ALCS.Runes[ "s" ]
		pan:Mat( image, x, y, ww, bh )

		local _jp, _pr, _hov = pan:Button( "", "wOS.TitleFont", x, y, ww, bh, color_white, color_white )

		if _hov then
			local speed = 0.1
			if not pan.SlideTimes then 
				pan.SlideTimes = CurTime() + speed
				surface.PlaySound( "wos/alcs/ui_slideout.wav" )
			end
			if pan.LastButt != lst then
				surface.PlaySound( "wos/alcs/ui_rollover.wav" )
				pan.LastButt = lst
			end
			local rat = math.Clamp( pan.SlideTimes - CurTime(), 0, speed ) / speed
			pan:Rect( x, y, ww * -3 * ( 1 - rat  ), bh, Color( 10, 10, 10, 255 ), color_white )
			pan:Text( "SKILLBÄUME ANSEHEN", "wOS.TitleFont", x + ww * -2.7 * ( 1 - rat  ), y + bh / 2, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )

			pan.LastHover = CurTime() + 0.01
		end

		if _jp then
			if wOS.ALCS.Config.Skills.MenuSchema == WOS_ALCS.SKILLMENU.NEWAGE then
				wOS.ALCS.Skills:ChangeCamFocus( "Skill-SelectTree" )
			else
				wOS.ALCS.Skills:OpenClassicTreeMenu()
				wOS.ALCS.Skills.Menu:SetVisible( false )
			end
		end

		if pan.SlideTimes and pan.LastHover < CurTime() then
			pan.SlideTimes	= nil
			pan.LastButt = nil
		end
	end
	leftpane:SetUIScale( 10 )
	leftpane.Scaling = 0.025

	leftpane.CamPos = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].origin + Vector( 0, 20, -2 )
	leftpane.CamAng = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].angles + Angle( 0, 30, 0 )
	table.insert( wOS.ALCS.Skills.Menu.VGUI, leftpane )

	local frontpane = tduiw.Create()
	frontpane.SizeX = 8
	frontpane.SizeY = 35
	frontpane.ShouldAcceptInputs = true
	frontpane.Renders = function( pan )
		if wOS.ALCS.Skills.ClassicMenu then return end
		local ww, hh = pan.SizeX, pan.SizeY

		local x = 0 - ww / 2
		local y = 10
		local bh = hh / 7

		local level = LocalPlayer():GetNW2Int( "wOS.SkillLevel", 0 )
		local xp = LocalPlayer():GetNW2Int( "wOS.SkillExperience", 0 )
		local points = LocalPlayer():GetNW2Int( "wOS.SkillPoints", 0 )

		pan:Text( "LEVEL " .. level, "wOS.CraftDescriptions", 0, -hh*1.1, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		--pan:Text( xp .. " EXPERIENCE POINTS", "wOS.TitleFont", 0, -hh, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )

		if points > 0 then
			pan:Text( points .. " VERFÜGBARE SKILLPUNKTE", "wOS.TitleFont", 0, -hh, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		end

		pan:Line( 0, -3, 3, 3 )
		pan:Line( 3, 3, 0, 10 )

		local lst = 0
		image = wOS.ALCS.Runes[ "x" ]
		pan:Mat( image, x, y, ww, bh )

		local _jp, _pr, _hov = pan:Button( "", "wOS.TitleFont", x, y, ww, bh, color_white, color_white )

		if _jp then
			wOS.ALCS.Skills:ChangeCamFocus( "Overview" )
		elseif _hov then
			local speed = 0.1
			if not pan.SlideTimes then
				pan.SlideTimes = CurTime() + speed
				surface.PlaySound( "wos/alcs/ui_slideout.wav" )
			end
			if pan.LastButt != lst then
				surface.PlaySound( "wos/alcs/ui_rollover.wav" )
				pan.LastButt = lst
			end

			local rat = math.Clamp( pan.SlideTimes - CurTime(), 0, speed )/speed
			pan:Rect( x + ww, y, ww * ( 3 - 3*rat  ), bh, Color( 10, 10, 10, 255 ), color_white )
			pan:Text( "ZURÜCK", "wOS.TitleFont", x + ww*2.1*( 1 - rat  ), y + bh/2, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
			pan.LastHover = CurTime() + 0.01
		end

		lst = lst + 1

		local _jp, _pr, _hov = pan:Button( "", "wOS.TitleFont", -hh*0.7/2, -hh*0.7, hh*0.7, hh*0.7, Color( 0, 0, 0, 0 ), Color( 0, 0, 0, 0 ) )
		if _hov then
			local speed = 0.1
			if not pan.SlideTimes then 
				pan.SlideTimes = CurTime() + speed
			end
			if pan.LastButt != lst then
				surface.PlaySound( "wos/alcs/ui_rollover.wav" )
				pan.LastButt = lst
			end
			local rat = math.Clamp( pan.SlideTimes - CurTime(), 0, speed ) / speed
			pan:Text( "NUTZE SKILLPUNKTE UM NEUE FÄHIGKEITEN ZU ERLERNEN.", "wOS.CraftDescriptions", 0, y + bh * 2*( 1.5 + rat ), color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
			pan.LastHover = CurTime() + 0.01
		end
		lst = lst + 1

		if pan.SlideTimes and pan.LastHover < CurTime() then
			pan.SlideTimes	= nil
			pan.LastButt = nil
		end
	end

	frontpane.PostRenders = function( pan )
		wOS.ALCS.Skills:CreateCubeMat( pan.CamPos, SkillBlock, nil, 6 )
	end
	frontpane:SetUIScale( 10 )
	frontpane.Scaling = 0.025

	frontpane.CamPos = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].origin + Vector( 0, 20, -2 )
	frontpane.CamAng = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].angles + Angle( 0, 0, 0 )
	table.insert( wOS.ALCS.Skills.Menu.VGUI, frontpane )

	local rightpane = tduiw.Create()
	rightpane.SizeX = 8
	rightpane.SizeY = 35
	rightpane.ShouldAcceptInputs = true
	rightpane.Renders = function( pan )
		local ww, hh = pan.SizeX, pan.SizeY
		local x = 20
		local y = -hh * 0.6
		local bh = hh / 7
		local lst = 0

		y = y + hh * 0.4

		pan:Line( x / 2, y - hh * 0.05, x, y + bh / 2 )

		image = wOS.ALCS.Runes[ "c" ]

		pan:Mat( image, x, y, ww, bh )

		local _jp, _pr, _hov = pan:Button( "", "wOS.TitleFont", x, y, ww, bh, color_white, color_white )
		if _jp then
			net.Start( "wOS.SkillTree.ResetAllSkills")
			net.SendToServer()
		elseif _hov then
			local speed = 0.1
			if not pan.SlideTimes then
				pan.SlideTimes = CurTime() + speed
				surface.PlaySound( "wos/alcs/ui_slideout.wav" )
			end
			if pan.LastButt != lst then
				surface.PlaySound( "wos/alcs/ui_rollover.wav" )
				pan.LastButt = lst
			end
			local rat = math.Clamp( pan.SlideTimes - CurTime(), 0, speed ) / speed
			pan:Rect( x + ww, y, ww * ( 3 - 3 * rat  ), bh, Color( 10, 10, 10, 255 ), color_white )
			pan:Text( "SKILLPUNKTE ZURÜCKSETZEN", "wOS.TitleFont", x + ww * 1.1 * ( 1 - rat  ), y + bh / 2, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
			pan.LastHover = CurTime() + 0.01
		end

		lst = lst + 1

		if pan.SlideTimes and pan.LastHover < CurTime() then
			pan.SlideTimes	= nil
			pan.LastButt = nil
		end
	end

	rightpane:SetUIScale( 10 )
	rightpane.Scaling = 0.025

	rightpane.CamPos = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].origin + Vector( 0, 20, -2 )
	rightpane.CamAng = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].angles + Angle( 0, -30, 0 )
	table.insert( wOS.ALCS.Skills.Menu.VGUI, rightpane )
end

wOS.ALCS.Skills.Camera[ "Skill-SelectTree" ] = { origin = centerpoint - Vector( 65, -45, -30 ), angles = Angle( 0, 180, 0.000 ) }
wOS.ALCS.Skills.MenuLibrary[ "Skill-SelectTree" ] = function()
	wOS.ALCS.Skills.Menu.ModEnabled = false
	local frontpane = tduiw.Create()
	frontpane.SizeX = 8
	frontpane.SizeY = 35
	frontpane.LeftCount = 1
	frontpane.RightCount = 5
	frontpane.ShouldAcceptInputs = true
	frontpane.LastScrollSlot = 0
	frontpane.ScrollSlot = 0
	frontpane.Selected = 1
	frontpane.TestSkills = {}

	for name, data in pairs( wOS.SkillTrees ) do
		local can_view = hook.Call( "wOS.ALCS.Skill.CanViewTree", nil, LocalPlayer(), name, data )
		if can_view != nil then
			if not can_view then continue end
		end
		if ( not wOS.SkillTreeWhitelists[ name ] ) and !can_view then
			if data.UserGroups then
				if not table.HasValue( data.UserGroups, LocalPlayer():GetUserGroup() ) then continue end
			end
			if data.JobRestricted then
				local found = false
				for _, job in pairs( data.JobRestricted ) do
					if _G[ job ] == LocalPlayer():Team() then 
						found = true
						break 
					end
				end
				if not found then continue end
			end
		end
		local model = wOS.ALCS.Skills:CreateCubeModel( vector_origin, "wos-alcs-treename-" .. name )
		table.insert( wOS.ALCS.Skills.CubeModels, model )
		table.insert( frontpane.TestSkills, name )
	end

	frontpane.Renders = function( pan )
		local ww, hh = pan.SizeX, pan.SizeY

		local x = 0 - ww / 2
		local y = 10
		local bh = hh / 7

		local tree = pan.TestSkills[ pan.Selected ] or ""
		if wOS.SkillTrees[ tree ] then
			local data = wOS.SkillTrees[ tree ]
			pan:Text( tree, "wOS.CraftTitles", 0, -hh * 1, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
			pan:Text( data.Description, "wOS.CraftDescriptions", 0, -hh * 0.7, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		end

		local lst = 0

		image = wOS.ALCS.Runes[ "x" ]
		pan:Mat( image, x, y + bh * 1.2, ww, bh )
		local _jp, _pr, _hov = pan:Button( "", "wOS.TitleFont", x, y + bh * 1.2, ww, bh, color_white, color_white )
		if _jp then
			wOS.ALCS.Skills:ChangeCamFocus( "Skill-Overview" )
		elseif _hov then
			local speed = 0.1
			if not pan.SlideTimes then
				pan.SlideTimes = CurTime() + speed
				surface.PlaySound( "wos/alcs/ui_slideout.wav" )
			end
			if pan.LastButt != lst then
				surface.PlaySound( "wos/alcs/ui_rollover.wav" )
				pan.LastButt = lst
			end
			local rat = math.Clamp( pan.SlideTimes - CurTime(), 0, speed ) / speed
			pan:Rect( x + ww, y + bh * 1.2, ww * ( 3 - 3 * rat  ), bh, Color( 10, 10, 10, 255 ), color_white )
			pan:Text( "ZURÜCK", "wOS.TitleFont", x + ww * 2.1 * ( 1 - rat  ), y + bh * 1.2 + bh / 2, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
			pan.LastHover = CurTime() + 0.01
		end

		lst = lst + 1

		local _jp, _pr, _hov = pan:Button( "", "wOS.TitleFont", -hh*0.55/2, -hh*0.2, hh*0.55, hh*0.55, Color( 0, 0, 0, 0 ), Color( 0, 0, 0, 0 ) )
		if _jp then
			wOS.ALCS.Skills.SelectedTree = pan.TestSkills[ pan.Selected ]
			if not wOS.ALCS.Skills.SelectedTree then return end
			wOS.ALCS.Skills:ChangeCamFocus( "Skill-ViewTree" )
		elseif _hov then
			local speed = 0.1
			if not pan.SlideTimes then
				pan.SlideTimes = CurTime() + speed
			end
			if pan.LastButt != lst then
				surface.PlaySound( "wos/alcs/ui_rollover.wav" )
				pan.LastButt = lst
			end
			local rat = math.Clamp( pan.SlideTimes - CurTime(), 0, speed ) / speed
			pan:Text( "KLICKE DAS HOLOCRON AN, UM DEN SKILLBAUM ZU ÖFFNEN", "wOS.CraftDescriptions", 0, y + bh * 2 * ( 1.5 + rat ), color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
			pan.LastHover = CurTime() + 0.01
		end

		lst = lst + 1

		pan:Mat( leftButton, x - ww * 2, y, ww, bh )
		local _jp, _pr, _hov = pan:Button( "", "wOS.TitleFont", x - ww * 2, y, ww, bh, color_white, color_white )
		if _jp then
			pan.ScrollSlot = pan.ScrollSlot - 1
			pan.Selected = math.Round( pan.ScrollSlot % #pan.TestSkills ) + 1
		elseif _hov then
			if pan.LastButt != lst then
				surface.PlaySound( "wos/alcs/ui_rollover.wav" )
				pan.LastButt = lst
			end
			pan.LastHover = CurTime() + 0.01
		end

		lst = lst + 1

		pan:Mat( rightButton, x + ww * 2, y, ww, bh )
		local _jp, _pr, _hov = pan:Button( "", "wOS.TitleFont", x + ww * 2, y, ww, bh, color_white, color_white )
		if _jp then
			pan.ScrollSlot = pan.ScrollSlot + 1
			pan.Selected = math.Round( pan.ScrollSlot % #pan.TestSkills ) + 1
		elseif _hov then
			if pan.LastButt != lst then
				surface.PlaySound( "wos/alcs/ui_rollover.wav" )
				pan.LastButt = lst
			end
			pan.LastHover = CurTime() + 0.01
		end
		lst = lst + 1

		if pan.SlideTimes and pan.LastHover < CurTime() then
			pan.SlideTimes	= nil
			pan.LastButt = nil
		end
	end

	frontpane.PostRenders = function( pan )
		local radius = 7.7
		pan.LastScrollSlot = math.Approach( pan.LastScrollSlot, pan.ScrollSlot, 0.01 )
		local offset = pi * 5 / 10 + pi * 2 / #pan.TestSkills * pan.LastScrollSlot
		local basesize = 1.3 * ( 1 - 0.04 * (#pan.TestSkills / 15) )
		for i = 1, #pan.TestSkills do
			local j = i - 1
			local x, y = math.sin( offset - pi * j * 2/#pan.TestSkills ), math.cos( offset - pi * j * 2 / #pan.TestSkills )
			local setpos = pan.CamPos + Vector( radius * x, radius * y, 0 )
			local size = 70 / setpos:DistToSqr( wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].origin )	//Clinically proven to be the number
			if not wOS.ALCS.Skills.CubeModels[i] then continue end
			wOS.ALCS.Skills.CubeModels[i]:SetPos( setpos )
			wOS.ALCS.Skills.CubeModels[i]:SetModelScale( basesize * size )
			if i != pan.Selected then
				wOS.ALCS.Skills.CubeModels[i]:SetAngles( Angle( 0, -45, -180 ) )
			else
				wOS.ALCS.Skills.CubeModels[i]:SetAngles( Angle( 0, ( CurTime() * 50 ) % 360, -180 ) )
			end
			wOS.ALCS.Skills.CubeModels[i]:SetColor( Color( 255, 255, 255 ) )
		end
	end
	frontpane:SetUIScale( 10 )
	frontpane.Scaling = 0.025

	frontpane.CamPos = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].origin + Vector( -20, 0, 0 )
	frontpane.CamAng = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].angles + Angle( 0, 0, 0 )
	table.insert( wOS.ALCS.Skills.Menu.VGUI, frontpane )
end

wOS.ALCS.Skills.Camera[ "Skill-ViewTree" ] = { origin = centerpoint - Vector( 45, -35, -30 ), angles = Angle( 0, 90.501, 0.000 ) }
wOS.ALCS.Skills.MenuLibrary[ "Skill-ViewTree" ] = function()
	wOS.ALCS.Skills.Menu.ModEnabled = true
	local selectpane = tduiw.Create()
	selectpane.Positions = {}

	local frontpane = tduiw.Create()
	frontpane.SizeX = 8
	frontpane.SizeY = 35
	frontpane.ShouldAcceptInputs = true
	frontpane.TreeInfo = {}

	local data = wOS.SkillTrees[ wOS.ALCS.Skills.SelectedTree ]
	local forward = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].angles:Forward()
	local up = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].angles:Up()
	local right = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].angles:Right()
	local modelscale = 0.5
	local offsety = 3
	local bpos = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].origin + forward * 30 - up * 7
	local padscale = 8

	frontpane.Renders = function( pan )
		local ww, hh = pan.SizeX, pan.SizeY
		local x = 0 - ww / 2
		local y = 19
		local bh = hh / 7

		local points = LocalPlayer():GetNW2Int( "wOS.SkillPoints", 0 )
		local offsett = wOS.ALCS.Skills.Menu.AngleMod.y*4

		pan:Text( wOS.ALCS.Skills.SelectedTree, "wOS.CraftDescriptions", 0, -hh*1.3 - offsett, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		pan:Text( data.Description, "wOS.TitleFont", 0, -hh*1.2 - offsett, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )			

		pan:Text( "Verfügbare Skill-Punkte: " .. points, "wOS.TitleFont", 0, -hh*1.1 - offsett, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )	
		
		local lst = 0
		local image = wOS.ALCS.Runes[ "x" ]
		pan:Mat( image, x, y - offsett, ww, bh )
		local _jp, _pr, _hov = pan:Button( "", "wOS.TitleFont", x, y - offsett, ww, bh, color_white, color_white )
		if _jp then
			wOS.ALCS.Skills:ChangeCamFocus( "Skill-SelectTree" )
		elseif _hov then
			local speed = 0.1
			if not pan.SlideTimes then
				pan.SlideTimes = CurTime() + speed
				surface.PlaySound( "wos/alcs/ui_slideout.wav" )
			end
			if pan.LastButt != lst then
				surface.PlaySound( "wos/alcs/ui_rollover.wav" )
				pan.LastButt = lst
			end
			local rat = math.Clamp( pan.SlideTimes - CurTime(), 0, speed )/speed
			pan:Rect( x + ww, y - offsett, ww*( 3 - 3*rat  ), bh, Color( 10, 10, 10, 255 ), color_white )
			pan:Text( "GO BACK", "wOS.TitleFont", x + ww*2.1*( 1 - rat  ), y + bh/2 - offsett, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
			pan.LastHover = CurTime() + 0.01
		end
		lst = lst + 1

		if pan.SlideTimes and pan.LastHover < CurTime() then
			pan.SlideTimes	= nil
			pan.LastButt = nil
		end

	end
	frontpane.PostRenders = function( pan )
		if not pan.FUCKYOU then
			local bottompos = bpos + Vector( 0, 0, 0 )
			local max = 0
			if data.MaxTiers > 6 then
				max = data.MaxTiers
			end
			wOS.ALCS.Skills.Menu.MaxH = offsety * max
			// Reset for width
			max = 0
			for tier = 1, data.MaxTiers do
				pan.TreeInfo[ tier ] = {}
				local skilltable = data.Tier[ tier ]
				local offsetx = padscale
				local rescale = false
				local startx = -1*offsetx*( #skilltable - 1 )*0.5
				if #skilltable > max then
					max = #skilltable
				end
				for skill, skilldata in ipairs( skilltable ) do
					if not skilldata.DummySkill then
						local model = wOS.ALCS.Skills:CreateCubeModel( bottompos + right*startx, "wos-alcs-skillname-" .. wOS.ALCS.Skills.SelectedTree .. tier .. skill )
						model:SetModelScale( modelscale )
						model.Skill = skill
						model.Tier = tier
						model.Requirements = skilldata.Requirements
						model.LockOuts = skilldata.LockOuts
						model.DummySkill = skilldata.DummySkill
						model.Data = skilldata
						model.Data.Tree = wOS.ALCS.Skills.SelectedTree
						model.Data.Tier = tier
						model.Data.Skill = skill
						table.insert( wOS.ALCS.Skills.CubeModels, model )
						local vec = bottompos + right*startx
						vec = WorldToLocal( vec, Angle( 0,0,0 ), pan.CamPos, pan.CamAng + Angle( 0, 0, 180 ) )
						table.insert( selectpane.Positions, vec )
						pan.TreeInfo[ tier ][ skill ] = #wOS.ALCS.Skills.CubeModels
					end
					startx = startx + offsetx
				end
				bottompos = bottompos + Vector( 0, 0, offsety )
			end	
			if max < 7 then
				max = 0
			end
			wOS.ALCS.Skills.Menu.MaxW = padscale * 0.5 * max
			pan.FUCKYOU = true
		end

		--Redefining the post render function IN the post render function?
		--You bet your sweet ass I fucking did
		pan.PostRenders = function( pan )
			for i=1, #wOS.ALCS.Skills.CubeModels do
				local model = wOS.ALCS.Skills.CubeModels[i]
				//local nmodel = wOS.ALCS.Skills.CubeModels[i + 1]
				if not model then continue end
				if model.DummySkill then continue end
				if wOS:HasSkillEquipped( wOS.ALCS.Skills.SelectedTree, model.Tier, model.Skill ) then
					model:SetAngles( Angle( 0, ( CurTime() * 50 ) % 360, -180 ) )
				elseif not wOS:CanEquipSkill( wOS.ALCS.Skills.SelectedTree, model.Tier, model.Skill ) then
					model:SetColor( Color( 25, 25, 25 ) )
				else
					model:SetColor( Color( 255, 255, 255 ) )
				end
				
				if model.LockOuts then
					render.SetMaterial( wireFrame )
					for treq, rdata in pairs( model.LockOuts ) do
						for _, sreq in ipairs( rdata ) do
							local pos = pan.TreeInfo[ treq ]
							if not pos then continue end
							pos = pos[ sreq ]
							if not pos then continue end
							local nmodel = wOS.ALCS.Skills.CubeModels[ pos ]
							if not nmodel then continue end
							render.DrawBeam( model:GetPos(), nmodel:GetPos(), 0.3, 0, 0, Color( 255, 0, 0 ) )
						end
					end				
				end
				if not model.Requirements then continue end
				if table.Count( model.Requirements ) < 1 then continue end
				render.SetMaterial( wireFrame )
				for treq, rdata in pairs( model.Requirements ) do
					for _, sreq in ipairs( rdata ) do
						local pos = pan.TreeInfo[ treq ]
						if not pos then continue end
						pos = pos[ sreq ]
						if not pos then continue end
						local nmodel = wOS.ALCS.Skills.CubeModels[ pos ]
						if not nmodel then continue end
						local color = Color( 0, 125, 255 )
						if not wOS:CanEquipSkill( wOS.ALCS.Skills.SelectedTree, treq, sreq ) then
							color = Color( 45, 45, 45 )
						elseif not wOS:HasSkillEquipped( wOS.ALCS.Skills.SelectedTree, treq, sreq ) then
							color = color_white
						end
						render.DrawBeam( model:GetPos(), nmodel:GetPos(), 0.2, 0, 0, color )
					end
				end
			end
		end
		
	end

	frontpane:SetUIScale( 10 )
	frontpane.Scaling = 0.025

	frontpane.CamPos = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].origin + Vector( 0, 20, -2 )
	frontpane.CamAng = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].angles + Angle( 0, 0, 0 )
	table.insert( wOS.ALCS.Skills.Menu.VGUI, frontpane )

	selectpane.SizeX = 4.5
	selectpane.SizeY = 4.5
	selectpane.ShouldAcceptInputs = true
	selectpane.MaxH = 0
	selectpane.MaxW = 0
	selectpane.Selected = nil
	selectpane.OffsetY = offsety * 2.2
	selectpane.Renders = function( pan ) 
		local ww, hh = pan.SizeX, pan.SizeY
		local scale = modelscale * 1.8

		ww, hh = ww * scale * 1.2, hh * scale * 1.2

		local x = 0.5 * scale
		local y = -hh - pan.OffsetY

		for i = 1, #pan.Positions do
			local origin = Vector( 0, 0, 0 )
			if not pan.Positions[i] then continue end
			origin:Set( pan.Positions[i] )
			origin.y = origin.y*(1/pan:GetUIScale())/pan.Scaling
			origin.z = origin.z*(1/pan:GetUIScale())/pan.Scaling

			//pan:Rect( x + origin.y - ww/2, y + origin.z + offset, ww*1.1, hh*1.1, Color( 10, 10, 10, 255 ), color_white )
			local _jp, _pr, _hov = pan:Button( "", "wOS.TitleFont", x + origin.y - ww/2, y + origin.z, ww, hh, color_white, Color( 0, 0, 0, 0 ) )
			if _jp then
				local model = wOS.ALCS.Skills.CubeModels[i]
				if not model then return end
				if model.DummySkill then return end
				if pan.Selected then return end
				if !wOS:HasSkillEquipped( wOS.ALCS.Skills.SelectedTree, model.Tier, model.Skill ) and wOS:CanEquipSkill( wOS.ALCS.Skills.SelectedTree, model.Tier, model.Skill ) then 
					net.Start( "wOS.SkillTree.ChooseSkill" )
						net.WriteString( wOS.ALCS.Skills.SelectedTree )
						net.WriteInt( model.Tier, 32 )
						net.WriteInt( model.Skill, 32 )
					net.SendToServer()
				end
			elseif _hov then
				local speed = 0.1
				if not pan.SlideTimes then 
					pan.SlideTimes = CurTime() + speed
				end
				if pan.LastButt != i then
					surface.PlaySound( "wos/alcs/ui_rollover.wav" )
					pan.LastButt = i
				end
				local rat = math.Clamp( pan.SlideTimes - CurTime(), 0, speed )/speed
				pan.LastHover = CurTime() + 0.01
				local model = wOS.ALCS.Skills.CubeModels[ i ]
				if model then
					wOS.ALCS.Skills.SkillInfoPanel:SetVisible( true )
					wOS.ALCS.Skills.SkillInfoPanel.TimeShow = CurTime() + 0.075
					wOS.ALCS.Skills.SkillInfoPanel.Data = model.Data
				end
			end
		end

		if pan.SlideTimes and pan.LastHover < CurTime() then
			pan.SlideTimes	= nil
			pan.LastButt = nil
			frontpane.CurrentHover = ""
			frontpane.CurrentTitle = ""
		end

	end

	selectpane:SetUIScale( 10 )
	selectpane.Scaling = 0.05

	selectpane.CamPos = bpos - forward*1.5
	selectpane.CamAng = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].angles + Angle( 0, 0, 0 )
	table.insert( wOS.ALCS.Skills.Menu.VGUI, selectpane )
	
end
--addons/wos-grandmaster-einf/lua/wos/advswl/lightsaber/core/cl_create_register.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2020
	
	Contact: www.wiltostech.com
		----------------------------------------]]--








































































wOS = wOS or {}
wOS.ALCS = wOS.ALCS or {}
wOS.ALCS.LightsaberBase = wOS.ALCS.LightsaberBase or {}
wOS.ALCS.LightsaberBase.HUDS = wOS.ALCS.LightsaberBase.HUDS or {}

function wOS.ALCS.LightsaberBase:RegisterNewHUD( HUD, name )
	if not HUD then return end
	if not name then return end
	wOS.ALCS.LightsaberBase.HUDS[ name ] = HUD
end

function wOS.ALCS.LightsaberBase:AddClientWeapon( SWEP, name )
	if not SWEP then return end
	if not name then return end
	weapons.Register( SWEP, name )
end
--addons/wos-grandmaster-einf/lua/wos/advswl/dueling/core/cl_player_funcs.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2020
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--

local meta = FindMetaTable( "Player" )
function meta:GetDuelDome()
	return self:GetNWEntity( "DuelDome", NULL )
end

function meta:DuelHealth()
	return self:GetNWInt( "DuelHealth", 100 )
end

function meta:GetDuelDown()
	return self:GetNWInt( "DuelDown", 0 )
end

--addons/wos-grandmaster-einf/lua/wos/advswl/execsys/core/cl_net.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2020
	
	Contact: www.wiltostech.com
		----------------------------------------]]--








































































wOS = wOS or {}
wOS.ALCS = wOS.ALCS or {}
wOS.ALCS.ExecSys = wOS.ALCS.ExecSys or {}
wOS.ALCS.ExecSys.Executions = wOS.ALCS.ExecSys.Executions or {}
wOS.ALCS.ExecSys.Whitelists = wOS.ALCS.ExecSys.Whitelists or {}

net.Receive( "wOS.ALCS.ExecSys.SendExecutions", function( len )

	local newtbl = net.ReadTable()

	wOS.ALCS.ExecSys.Executions = wOS.ALCS.ExecSys.Executions or {}
	table.Merge( wOS.ALCS.ExecSys.Executions, newtbl )
	
end )

net.Receive( "wOS.ALCS.ExecSys.Initiate", function( len )

	local execution = net.ReadString()

	local dat = wOS.ALCS.ExecSys.Executions[ execution ]
	if not dat then return end
	
	local attacker = net.ReadEntity()
	if not attacker:IsValid() then return end

	local victim = net.ReadEntity()
	if not victim:IsValid() then return end

	if not dat.CamTable then return end
	if not dat.CamTable[1] then return end

	wOS.ALCS.ExecSys.LastPos = nil
	wOS.ALCS.ExecSys.LastAng = nil

	wOS.ALCS.ExecSys.ExecutionData = {
		endtime = CurTime() + dat.TotalTime,
		attacker = attacker,
		victim = victim,
		stage = 1,
		camdata = dat.CamTable,
		stagetime = CurTime() + dat.CamTable[1].time,
	}
	print( angles )

end )

net.Receive( "wOS.ALCS.ExecSys.SendWhitelists", function( len )

	wOS.ALCS.ExecSys.Whitelists  = net.ReadTable()

end )


--addons/wos-grandmaster-einf/lua/wos/advswl/storage/loader/cl_loader.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2020
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--

wOS = wOS or {}

include( "wos/advswl/storage/core/cl_core.lua" )
include( "wos/advswl/storage/core/cl_net.lua" )
include( "wos/advswl/storage/core/cl_menu_library.lua" )	

--addons/wos-grandmaster-einf/lua/wos/advswl/prestige/core/cl_menu_library.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2020
	
	Contact: www.wiltostech.com
		----------------------------------------]]--








































































wOS = wOS or {}
wOS.ALCS = wOS.ALCS or {}
wOS.ALCS.Prestige = wOS.ALCS.Prestige or {}
wOS.ALCS.Skills = wOS.ALCS.Skills or {}
wOS.ALCS.Skills.Camera = wOS.ALCS.Skills.Camera or {}


wOS.ALCS.Prestige.HoverInfo = { Slot = 0, Active = nil }

local w,h = ScrW(), ScrH()
local pi = math.pi

local upButton = Material( "wos/crafting/gui/up.png", "unlitgeneric" )
local downButton = Material( "wos/crafting/gui/down.png", "unlitgeneric" )
local leftButton = Material( "wos/crafting/gui/left.png", "unlitgeneric" )
local rightButton = Material( "wos/crafting/gui/right.png", "unlitgeneric" )
local bufferBar = Material( "wos/crafting/gui/buffer.png", "unlitgeneric" )
local boxTop = Material( "phoenix_storms/metalset_1-2", "unlitgeneric" )

local wireFrame = Material( "trails/plasma" )

local DuelBlock = Material( "wos/advswl/prestige_holocron.png", "unlitgeneric" )

local centerpoint = wOS.ALCS.Config.Crafting.CraftingCamLocation
local color_unselected = Color( 0, 0, 0, 100 )
local grad = Material( "gui/gradient_up" )

wOS.ALCS.Skills.CubeModels = wOS.ALCS.Skills.CubeModels or {}

wOS.ALCS.Skills.MenuLibrary = wOS.ALCS.Skills.MenuLibrary or {}
wOS.ALCS.Skills.Camera[ "Prestige-Overview" ] = { origin = centerpoint - Vector( 45, -35, -30 ), angles = Angle( 0, 90.501, 0.000 ) }
wOS.ALCS.Skills.MenuLibrary[ "Prestige-Overview" ] = function()
	wOS.ALCS.Skills.Menu.ModEnabled = false
	local leftpane = tduiw.Create()
	leftpane.SizeX = 8
	leftpane.SizeY = 35
	leftpane.ShouldAcceptInputs = true
	leftpane.Renders = function( pan )
	
		local ww, hh = pan.SizeX, pan.SizeY	
		local x = -30
		local y = -hh*0.4
		local bh = hh/7
		
		pan:Line( 0, -hh/2, x + ww, y + bh/2 )
		
		local lst = 0
		image = wOS.ALCS.Runes[ "m" ]
		pan:Mat( image, x, y, ww, bh )	
		local _jp, _pr, _hov = pan:Button( "", "wOS.TitleFont", x, y, ww, bh, color_white, color_white )
	    if _hov then
			local speed = 0.1
			if not pan.SlideTimes then 
				pan.SlideTimes = CurTime() + speed
				surface.PlaySound( "wos/alcs/ui_slideout.wav" )
			end
			if pan.LastButt != lst then
				surface.PlaySound( "wos/alcs/ui_rollover.wav" )
				pan.LastButt = lst
			end
			local rat = math.Clamp( pan.SlideTimes - CurTime(), 0, speed )/speed
			pan:Rect( x, y, ww*-3*( 1 - rat  ), bh, Color( 10, 10, 10, 255 ), color_white )
			pan:Text( "VIEW ASCENSION MAP", "wOS.TitleFont", x + ww*-2.7*( 1 - rat  ), y + bh/2, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )

			pan.LastHover = CurTime() + 0.01
	    end							
		if _jp then
			wOS.ALCS.Skills:ChangeCamFocus( "Prestige-ViewMap" )
		end
		
		if pan.SlideTimes and pan.LastHover < CurTime() then
			pan.SlideTimes	= nil
			pan.LastButt = nil
		end
	
	end
	leftpane:SetUIScale( 10 )
	leftpane.Scaling = 0.025
	
	leftpane.CamPos = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].origin + Vector( 0, 20, -2 )
	leftpane.CamAng = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].angles + Angle( 0, 30, 0 )
	table.insert( wOS.ALCS.Skills.Menu.VGUI, leftpane )
	
	local frontpane = tduiw.Create()
	frontpane.SizeX = 8
	frontpane.SizeY = 35
	frontpane.ShouldAcceptInputs = true
	frontpane.Renders = function( pan )
		local ww, hh = pan.SizeX, pan.SizeY
		
		local x = 0 - ww/2
		local y = 10
		local bh = hh/7
		
		local level = wOS.ALCS.Prestige.Data.Level
		local tokens = wOS.ALCS.Prestige.Data.Tokens

		pan:Text( "PRESTIGE LEVEL " .. level, "wOS.CraftDescriptions", 0, -hh*1.1, col, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		if tokens > 0 then
			local rate = math.abs( math.cos( CurTime()*5 ) )
			pan:Text( tokens .. " UNSPENT TOKENS", "wOS.DescriptionFont", 0, -hh*0.95, Color( 255*rate, 255 - 255*rate, 255 - 255*rate, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
		end
		
		pan:Line( 0, -3, 3, 3 )
		pan:Line( 3, 3, 0, 10 )
		
		local lst = 0
		image = wOS.ALCS.Runes[ "x" ]
		pan:Mat( image, x, y, ww, bh )	
		local _jp, _pr, _hov = pan:Button( "", "wOS.TitleFont", x, y, ww, bh, color_white, color_white )
		if _jp then
			wOS.ALCS.Skills:ChangeCamFocus( "Overview" )
	    elseif _hov then
			local speed = 0.1
			if not pan.SlideTimes then 
				pan.SlideTimes = CurTime() + speed
				surface.PlaySound( "wos/alcs/ui_slideout.wav" )
			end
			if pan.LastButt != lst then
				surface.PlaySound( "wos/alcs/ui_rollover.wav" )
				pan.LastButt = lst
			end
			local rat = math.Clamp( pan.SlideTimes - CurTime(), 0, speed )/speed
			pan:Rect( x + ww, y, ww*( 3 - 3*rat  ), bh, Color( 10, 10, 10, 255 ), color_white )
			pan:Text( "GO BACK", "wOS.TitleFont", x + ww*2.1*( 1 - rat  ), y + bh/2, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
			pan.LastHover = CurTime() + 0.01
	    end							
		lst = lst + 1
		
		local _jp, _pr, _hov = pan:Button( "", "wOS.TitleFont", -hh*0.7/2, -hh*0.7, hh*0.7, hh*0.7, Color( 0, 0, 0, 0 ), Color( 0, 0, 0, 0 ) )
	    if _hov then
			local speed = 0.1
			if not pan.SlideTimes then 
				pan.SlideTimes = CurTime() + speed
			end
			if pan.LastButt != lst then
				surface.PlaySound( "wos/alcs/ui_rollover.wav" )
				pan.LastButt = lst
			end
			local rat = math.Clamp( pan.SlideTimes - CurTime(), 0, speed )/speed
			pan:Text( "MASTER YOUR INNER SELF", "wOS.CraftDescriptions", 0, y + bh*2*( 1.5 + rat ), color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
			pan.LastHover = CurTime() + 0.01
	    end		
		lst = lst + 1
		
		if pan.SlideTimes and pan.LastHover < CurTime() then
			pan.SlideTimes	= nil
			pan.LastButt = nil
		end
	
	end
	frontpane.PostRenders = function( pan )
		wOS.ALCS.Skills:CreateCubeMat( pan.CamPos, DuelBlock, nil, 6 )
	end
	frontpane:SetUIScale( 10 )
	frontpane.Scaling = 0.025
	
	frontpane.CamPos = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].origin + Vector( 0, 20, -2 )
	frontpane.CamAng = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].angles + Angle( 0, 0, 0 )
	table.insert( wOS.ALCS.Skills.Menu.VGUI, frontpane )
	
	
	local rightpane = tduiw.Create()
	rightpane.SizeX = 8
	rightpane.SizeY = 35
	rightpane.ShouldAcceptInputs = true
	rightpane.Renders = function( pan )
	
		local ww, hh = pan.SizeX, pan.SizeY	
		local x = 20
		local y = -hh*0.6
		local bh = hh/7
		

		
		local lst = 0
		
		y = y + hh*0.4
		pan:Line( x/2, y - hh*0.05, x, y + bh/2 )
		image = wOS.ALCS.Runes[ "p" ]
		pan:Mat( image, x, y, ww, bh )	
		local _jp, _pr, _hov = pan:Button( "", "wOS.TitleFont", x, y, ww, bh, color_white, color_white )
		if _jp then
			net.Start( "wOS.ALCS.Prestige.Ascend" ) 
			net.SendToServer() 
	    elseif _hov then
			local speed = 0.1
			if not pan.SlideTimes then 
				pan.SlideTimes = CurTime() + speed
				surface.PlaySound( "wos/alcs/ui_slideout.wav" )
			end
			if pan.LastButt != lst then
				surface.PlaySound( "wos/alcs/ui_rollover.wav" )
				pan.LastButt = lst
			end
			local rat = math.Clamp( pan.SlideTimes - CurTime(), 0, speed )/speed
			pan:Rect( x + ww, y, ww*( 3 - 3*rat  ), bh, Color( 10, 10, 10, 255 ), color_white )
			pan:Text( "ASCEND YOURSELF", "wOS.TitleFont", x + ww*1.55*( 1 - rat  ), y + bh/2, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
			pan:Text( "THIS WILL RESET EVERYTHING", "wOS.DescriptionFont", x, y + bh*( 1 + rat ), Color( 255, 0, 0 ), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
			pan.LastHover = CurTime() + 0.01
	    end							
		lst = lst + 1
		
		if pan.SlideTimes and pan.LastHover < CurTime() then
			pan.SlideTimes	= nil
			pan.LastButt = nil
		end
	
	end
	rightpane:SetUIScale( 10 )
	rightpane.Scaling = 0.025
	
	rightpane.CamPos = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].origin + Vector( 0, 20, -2 )
	rightpane.CamAng = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].angles + Angle( 0, -30, 0 )
	table.insert( wOS.ALCS.Skills.Menu.VGUI, rightpane )
	
end

wOS.ALCS.Skills.Camera[ "Prestige-ViewMap" ] = { origin = centerpoint - Vector( 45, -35, -30 ), angles = Angle( 0, 90.501, 0.000 ) }
wOS.ALCS.Skills.MenuLibrary[ "Prestige-ViewMap" ] = function()
	wOS.ALCS.Skills.Menu.ModEnabled = true
	local selectpane = tduiw.Create()
	selectpane.Positions = {}
	
	local frontpane = tduiw.Create()
	frontpane.SizeX = 8
	frontpane.SizeY = 35
	frontpane.ShouldAcceptInputs = true
	frontpane.PathInfo = {}
	
	local forward = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].angles:Forward()
	local up = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].angles:Up()
	local right = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].angles:Right()
	local modelscale = 0.5
	local offsety = 3
	local bpos = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].origin
	local padscale = 12
	
	frontpane.Renders = function( pan )
	
		local ww, hh = pan.SizeX, pan.SizeY
		local x = 0 - ww/2
		local y = 19
		local bh = hh/7
		
		local points = wOS.ALCS.Prestige.Data.Tokens
		local offsett = wOS.ALCS.Skills.Menu.AngleMod.y*4
		local offsetp = wOS.ALCS.Skills.Menu.AngleMod.x*4
		
		pan:Text( wOS.ALCS.Prestige.MapData.HeaderName, "wOS.CraftDescriptions", offsetp, -hh*1.3 - offsett, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		pan:Text( wOS.ALCS.Prestige.MapData.HeaderTagLine, "wOS.TitleFont", offsetp, -hh*1.2 - offsett, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )			

		pan:Text( "Available Tokens: " .. points, "wOS.TitleFont", offsetp, -hh*1.1 - offsett, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )	
		
		local lst = 0
		local image = wOS.ALCS.Runes[ "x" ]
		pan:Mat( image, x + offsetp, y - offsett, ww, bh )	
		local _jp, _pr, _hov = pan:Button( "", "wOS.TitleFont", x + offsetp, y - offsett, ww, bh, color_white, color_white )
		if _jp then
			wOS.ALCS.Skills:ChangeCamFocus( "Prestige-Overview" )
	    elseif _hov then
			local speed = 0.1
			if not pan.SlideTimes then 
				pan.SlideTimes = CurTime() + speed
				surface.PlaySound( "wos/alcs/ui_slideout.wav" )
			end
			if pan.LastButt != lst then
				surface.PlaySound( "wos/alcs/ui_rollover.wav" )
				pan.LastButt = lst
			end
			local rat = math.Clamp( pan.SlideTimes - CurTime(), 0, speed )/speed
			pan:Rect( x + ww + offsetp, y - offsett, ww*( 3 - 3*rat  ), bh, Color( 10, 10, 10, 255 ), color_white )
			pan:Text( "GO BACK", "wOS.TitleFont", x + ww*2.1*( 1 - rat  ) + offsetp, y + bh/2 - offsett, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
			pan.LastHover = CurTime() + 0.01
	    end
		lst = lst + 1
		
		if pan.SlideTimes and pan.LastHover < CurTime() then
			pan.SlideTimes	= nil
			pan.LastButt = nil
		end

	end
	frontpane.PostRenders = function( pan )

		if not pan.FUCKYOU then
			local bottompos = bpos + Vector( 0, 25, 0 ) 
			local maxy = 0
			local maxx = 0

			for slot, dat in pairs( wOS.ALCS.Prestige.MapData.Paths ) do
				
				if math.abs( dat.GridPosition.x ) > maxx then
					maxx = math.abs( dat.GridPosition.x )
				end
				
				if math.abs( dat.GridPosition.y ) > maxy then
					maxy = math.abs( dat.GridPosition.y )
				end
				
				local pos = bottompos + right*dat.GridPosition.x*padscale + up*dat.GridPosition.y*padscale
				local model = wOS.ALCS.Skills:CreateCubeModel( pos, "wos-alcs-prestigemap-" .. slot )
				model:SetModelScale( modelscale )
				model.Data = dat
				model.Data.Mastery = slot
				model.Pos = pos
				table.insert( wOS.ALCS.Skills.CubeModels, model )
				local vec = WorldToLocal( pos, Angle( 0,0,0 ), pan.CamPos, pan.CamAng + Angle( 0, 0, 180 ) )
				table.insert( selectpane.Positions, vec )
				pan.PathInfo[ slot ] = #wOS.ALCS.Skills.CubeModels
			end	
			
			wOS.ALCS.Skills.Menu.MaxH = offsety* 3.7 * maxy
			wOS.ALCS.Skills.Menu.MinH = wOS.ALCS.Skills.Menu.MaxH * -1
			wOS.ALCS.Skills.Menu.MaxW = padscale * 2 * maxx
			pan.FUCKYOU = true
			
		end

		--Redefining the post render function IN the post render function?
		--You bet your sweet ass I fucking did
		pan.PostRenders = function( pan )

			for i, model in pairs( wOS.ALCS.Skills.CubeModels ) do
				if not model then continue end
				local shadow = true
				model:SetMaterial( "" )
				if wOS.ALCS.Prestige.Data.Mastery[ model.Data.Mastery ] then
					model:SetAngles( Angle( 0, ( FrameTime() * 50 ) % 360, -180 ) )
					shadow = false
				else
					model:SetColor( Color( 255, 255, 255 ) )
				end
				if model.Data.RequiredMastery and #model.Data.RequiredMastery > 0 then
					for _, req in ipairs( model.Data.RequiredMastery ) do
						local nmodel = wOS.ALCS.Skills.CubeModels[req]
						if not nmodel then continue end
						render.SetMaterial( wireFrame )
						local color = Color( 255, 0, 0 )
						if wOS.ALCS.Prestige.Data.Mastery[ model.Data.Mastery ] then
							color = Color( 0, 125, 255 )
						elseif wOS.ALCS.Prestige.Data.Mastery[ req ] then
							color = color_white
							shadow = false
						end
						render.DrawBeam( model:GetPos(), nmodel:GetPos(), 0.2, 0, 0, color )
					end
				else
					shadow = false
				end
				if shadow then
					model:SetMaterial( "models/wireframe" )
					model:SetColor( Color( 255, 255, 255 ) )
				end
			end
			
		end
		
	end
	
	frontpane:SetUIScale( 10 )
	frontpane.Scaling = 0.025
	
	frontpane.CamPos = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].origin + Vector( 0, 20, -2 )
	frontpane.CamAng = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].angles + Angle( 0, 0, 0 )
	table.insert( wOS.ALCS.Skills.Menu.VGUI, frontpane )
	

	selectpane.SizeX = 4.5
	selectpane.SizeY = 4.5
	selectpane.ShouldAcceptInputs = true
	selectpane.MaxH = 0
	selectpane.MaxW = 0
	selectpane.Selected = nil
	selectpane.OffsetY = offsety*2.2
	selectpane.Renders = function( pan ) 
		local ww, hh = pan.SizeX, pan.SizeY
		local scale = modelscale*1.8

		ww, hh = ww*scale*1.2, hh*scale*1.2
		
		local x = 0.5*scale
		local y = -hh - pan.OffsetY
		
		for i = 1, #pan.Positions do
			local origin = Vector( 0, 0, 0 )
			if not pan.Positions[i] then continue end
			origin:Set( pan.Positions[i] )
			origin.y = origin.y*(1/pan:GetUIScale())/pan.Scaling
			origin.z = origin.z*(1/pan:GetUIScale())/pan.Scaling

			local _jp, _pr, _hov = pan:Button( "", "wOS.TitleFont", x + origin.y - ww/2, y + origin.z, ww, hh, Color( 0, 0, 0, 0 ), Color( 0, 0, 0, 0 ) )
			if _jp then
				local model = wOS.ALCS.Skills.CubeModels[i]
				if not model then return end
				net.Start( "wOS.ALCS.Prestige.GetMasteryBate" )
					net.WriteInt( model.Data.Mastery, 32 )
				net.SendToServer()	
			elseif _hov then
				local speed = 0.1
				if not pan.SlideTimes then 
					pan.SlideTimes = CurTime() + speed
				end
				if pan.LastButt != i then
					surface.PlaySound( "wos/alcs/ui_rollover.wav" )
					pan.LastButt = i
				end
				local rat = math.Clamp( pan.SlideTimes - CurTime(), 0, speed )/speed
				pan.LastHover = CurTime() + 0.01
				local model = wOS.ALCS.Skills.CubeModels[ i ]
				if model then
					wOS.ALCS.Skills.SkillInfoPanel:SetVisible( true )
					wOS.ALCS.Skills.SkillInfoPanel.TimeShow = CurTime() + 0.075
					wOS.ALCS.Skills.SkillInfoPanel.Data = { Name = model.Data.Name, Description = model.Data.Description, Cost = model.Data.Amount, Prestige = true, Mastery = model.Data.Mastery }
				end
			end
		end
		
		if pan.SlideTimes and pan.LastHover < CurTime() then
			pan.SlideTimes	= nil
			pan.LastButt = nil
			frontpane.CurrentHover = ""
			frontpane.CurrentTitle = ""
		end

	end
	
	selectpane:SetUIScale( 10 )
	selectpane.Scaling = 0.05
	
	selectpane.CamPos = bpos + forward*25 - up*7
	selectpane.CamAng = wOS.ALCS.Skills.Camera[ wOS.ALCS.Skills.CamFocus ].angles + Angle( 0, 0, 0 )
	table.insert( wOS.ALCS.Skills.Menu.VGUI, selectpane )
	
end
--addons/wos-grandmaster-einf/lua/wos/advswl/trade/core/cl_net.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2020
	
	Contact: www.wiltostech.com
		----------------------------------------]]--








































































wOS = wOS or {}
wOS.ALCS = wOS.ALCS or {}
wOS.ALCS.GTN = wOS.ALCS.GTN or {}															
wOS.ALCS.GTN.BufferInfo = wOS.ALCS.GTN.BufferInfo or {}
wOS.ALCS.GTN.BufferInfo.Data = wOS.ALCS.GTN.BufferInfo.Data or {}
wOS.ALCS.GTN.BufferInfo.LastUpdated = wOS.ALCS.GTN.BufferInfo.LastUpdated or math.huge

net.Receive( "wOS.ALCS.GTN.SendPlayerTrades", function( len, ply )
	
	local init = net.ReadBool()
	if init then
		wOS.ALCS.GTN.BufferInfo.LastUpdated = CurTime()
		wOS.ALCS.GTN.BufferInfo.Data.Trades = {}
	end

	local tbl = net.ReadTable()
	table.Add( wOS.ALCS.GTN.BufferInfo.Data.Trades, tbl )
	
end )

net.Receive( "wOS.ALCS.GTN.SendPlayerAuctions", function( len, ply )
	
	local init = net.ReadBool()
	if init then
		wOS.ALCS.GTN.BufferInfo.LastUpdated = CurTime()
		wOS.ALCS.GTN.BufferInfo.Data.Auctions = {}
	end

	local tbl = net.ReadTable()
	table.Add( wOS.ALCS.GTN.BufferInfo.Data.Auctions, tbl )
	
end )

net.Receive( "wOS.ALCS.GTN.SendAuctions", function( len, ply )
	
	local init = net.ReadBool()
	if init then
		wOS.ALCS.GTN.BufferInfo.LastUpdated = CurTime()
		wOS.ALCS.GTN.BufferInfo.Data = {}
	end

	local tbl = net.ReadTable()
	table.Add( wOS.ALCS.GTN.BufferInfo.Data, tbl )

end )

net.Receive( "wOS.ALCS.GTN.SendTrades", function( len, ply )
	
	local init = net.ReadBool()
	if init then
		wOS.ALCS.GTN.BufferInfo.LastUpdated = CurTime()
		wOS.ALCS.GTN.BufferInfo.Data = {}
	end

	local tbl = net.ReadTable()
	table.Add( wOS.ALCS.GTN.BufferInfo.Data, tbl )
	
end )


net.Receive( "wOS.ALCS.GTN.RefreshClearedListing", function( len, ply )
	local trade = net.ReadBool()
	local id = net.ReadInt( 32 )
	local tbl = ( trade and wOS.ALCS.GTN.BufferInfo.Data.Trades ) or wOS.ALCS.GTN.BufferInfo.Data.Auctions

	for k, dat in pairs( tbl ) do
		if tonumber( dat.ID ) == id then
			if trade then
				table.remove( wOS.ALCS.GTN.BufferInfo.Data.Trades, k )
			else
				table.remove( wOS.ALCS.GTN.BufferInfo.Data.Auctions, k )
			end
			wOS.ALCS.GTN:RefreshMenu()
			return
		end
	end

end )
--addons/wos-alcs-icefusepp/lua/wos/advswl/icefuse/cl_core.lua:
wOS = wOS or {}
wOS.ALCS = wOS.ALCS or {}

hook.Add( "wOS.ALCS.GetSequenceOverride", "wOS.ALCS.ForceChokeAnim", function( ply, _ )
	if ply:GetNW2Float( "wOS.ChokeTime", 0 ) >= CurTime() then
		seq = ply:LookupSequence( "wos_force_choke" )
		if seq and seq > 0 then
			return -1, seq
		end
	end
end )

hook.Add( "wOS.ALCS.GetSequenceOverride", "wOS.ALCS.ForceChokeAnimAttacker", function( ply, _ )
	if ply:GetNW2Float( "wOS.ChokeAnim", 0 ) >= CurTime() then
		seq = ply:LookupSequence( "wos_cast_choke" )
		if seq and seq > 0 then
			return -1, seq
		end
	end
end )

hook.Add( "wOS.ALCS.GetSequenceOverride", "wOS.ALCS.SaberBarrierAnim", function( ply, _ )
	if ply:GetNW2Bool("wOS.BarrierStuff", false) then
		seq = ply:LookupSequence( "phalanx_r_s2_charge" )
		if seq and seq > 0 then
			return -1, seq
		end
	end
end )

hook.Add( "CreateMove", "wOS.ALCS.LegacyFreeze", function( cmd/* ply, mv, cmd*/ )
	if LocalPlayer():GetNW2Float( "wOS.SaberAttackDelay", 0 ) < CurTime() then return end
	cmd:ClearButtons() -- No attacking, we are busy
	cmd:ClearMovement() -- No moving, we are busy
end )
--addons/bkeypads/lua/vgui/bkeypads_access_matrix.lua:
local PANEL = {}

local bkeypads_auth_mode
local L
local matKeycard

local function SolidColorPaint(self,w,h)
	surface.SetDrawColor(self.SolidColor)
	surface.DrawRect(0,0,w,h)
end

local function AddAccessGroupIcon(line)
	line.AccessTypeIcon = vgui.Create("DImage", line)
	line.AccessTypeIcon:Dock(LEFT)
	line.AccessTypeIcon:DockMargin(0,0,0,1)
	line.AccessTypeIcon:SetWide(16)
	line.AccessTypeIcon:SetImage(line.AccessType == bKeypads.ACCESS_TYPE.BLACKLIST and "icon16/delete.png" or "icon16/accept.png")
	line.AccessTypeIcon.bKeypads_Tooltip = line.AccessType == bKeypads.ACCESS_TYPE.BLACKLIST and L"Blacklist" or L"Whitelist"
	line.AccessTypeIcon:MoveToBack()
end

local PopulateFunctions = {

	[bKeypads.ACCESS_GROUP.PLAYER] = function(self, AccessType, steamid, name)
		local steamid64 = util.SteamIDTo64(steamid)

		local line = self:AddLine("", "", steamid, name or bKeypads.PlayerSelector:LookupName(steamid64) or "")
		line.bKeypads_Tooltip = L"Player"

		line.AvatarImage = vgui.Create("AvatarImage", line)
		line.AvatarImage:Dock(LEFT)
		line.AvatarImage:SetWide(17)
		line.AvatarImage:SetSteamID(steamid64, 32)

		line.AccessType = AccessType
		line.Type = bKeypads.ACCESS_GROUP.PLAYER
		line.Key = steamid

		AddAccessGroupIcon(line)
	end,

	[bKeypads.ACCESS_GROUP.KEYCARD_LEVEL] = function(self, AccessType, level)
		if bKeypads.Keycards.Levels[level] then
			local line = self:AddLine("", "", level, bKeypads.Keycards.Levels[level].Name)
			line.bKeypads_Tooltip = L"GroupKeycardLevel"

			line.Icon = vgui.Create("DImage", line)
			line.Icon:Dock(LEFT)
			line.Icon:DockMargin(0,0,0,1)
			line.Icon:SetWide(16)
			line.Icon:SetMaterial(matKeycard)
			line.Icon:SetImageColor(bKeypads.Keycards.Levels[level].Color or Color(255,0,0))

			line.AccessType = AccessType
			line.Type = bKeypads.ACCESS_GROUP.KEYCARD_LEVEL
			line.Key = level

			AddAccessGroupIcon(line)
		else
			self:GetAccessMatrix()[AccessType][bKeypads.ACCESS_GROUP.KEYCARD_LEVEL][level] = nil
		end
	end,

	[bKeypads.ACCESS_GROUP.SUPERIOR_KEYCARDS] = function(self, AccessType)
		local line = self:AddLine("", "", L"AllSuperiorKeycards")
		line.bKeypads_Tooltip = L"AllSuperiorKeycards"

		line.Icon = vgui.Create("DImage", line)
		line.Icon:Dock(LEFT)
		line.Icon:DockMargin(0,0,0,1)
		line.Icon:SetWide(16)
		line.Icon:SetImage("icon16/sitemap_color.png")

		line.AccessType = AccessType
		line.Type = bKeypads.ACCESS_GROUP.SUPERIOR_KEYCARDS
		
		AddAccessGroupIcon(line)
	end,

	[bKeypads.ACCESS_GROUP.STEAM_FRIENDS] = function(self, AccessType)
		local line = self:AddLine("", "", L"SteamFriends")
		line.bKeypads_Tooltip = L"SteamFriends"

		line.Icon = vgui.Create("DImage", line)
		line.Icon:Dock(LEFT)
		line.Icon:DockMargin(0,0,0,1)
		line.Icon:SetWide(16)
		line.Icon:SetImage("icon16/emoticon_grin.png")

		line.AccessType = AccessType
		line.Type = bKeypads.ACCESS_GROUP.STEAM_FRIENDS
		
		AddAccessGroupIcon(line)
	end,

	[bKeypads.ACCESS_GROUP.USERGROUP] = function(self, AccessType, usergroup)
		local line = self:AddLine("", "", usergroup, "")
		line.bKeypads_Tooltip = L"Usergroup"

		line.Icon = vgui.Create("DImage", line)
		line.Icon:Dock(LEFT)
		line.Icon:DockMargin(0,0,0,1)
		line.Icon:SetWide(16)
		line.Icon:SetImage((usergroup == "admin" or usergroup == "superadmin") and "icon16/shield.png" or "icon16/group.png")

		line.AccessType = AccessType
		line.Type = bKeypads.ACCESS_GROUP.USERGROUP
		line.Key = usergroup

		AddAccessGroupIcon(line)
	end,

	[bKeypads.ACCESS_GROUP.DARKRP_JOB] = function(self, AccessType, command)
		local job = DarkRP.getJobByCommand(command)
		if job then
			local line = self:AddLine("", "", "/" .. command, job.name)
			line.bKeypads_Tooltip = L"Job"

			line.EntryColor = vgui.Create("DPanel", line)
			line.EntryColor:Dock(LEFT)
			line.EntryColor:SetWide(17)
			line.EntryColor.SolidColor = job.color
			line.EntryColor.Paint = SolidColorPaint

			line.AccessType = AccessType
			line.Type = bKeypads.ACCESS_GROUP.DARKRP_JOB
			line.Key = command

			AddAccessGroupIcon(line)
		else
			self:GetAccessMatrix()[AccessType][bKeypads.ACCESS_GROUP.DARKRP_JOB][command] = nil
		end
	end,

	[bKeypads.ACCESS_GROUP.TEAM] = function(self, AccessType, teamName)
		local teamIndex
		for index, teamTbl in pairs(team.GetAllTeams()) do
			if teamTbl.Name == teamName then
				teamIndex = index
				break
			end
		end
		if teamIndex then
			local line = self:AddLine("", "", teamName, "")
			line.bKeypads_Tooltip = L"Team"

			line.EntryColor = vgui.Create("DPanel", line)
			line.EntryColor:Dock(LEFT)
			line.EntryColor:SetWide(17)
			line.EntryColor.SolidColor = team.GetColor(teamIndex)
			line.EntryColor.Paint = SolidColorPaint

			line.AccessType = AccessType
			line.Type = bKeypads.ACCESS_GROUP.TEAM
			line.Key = teamName

			AddAccessGroupIcon(line)
		else
			self:GetAccessMatrix()[AccessType][bKeypads.ACCESS_GROUP.TEAM][teamName] = nil
		end
	end,

	[bKeypads.ACCESS_GROUP.DARKRP_JOB_CATEGORY] = function(self, AccessType, category_name)
		local category = bKeypads.DarkRP.JobCategories.Members[category_name]
		if category then
			local line = self:AddLine("", "", category_name, "")
			line.bKeypads_Tooltip = L"GroupJobCategory"

			line.EntryColor = vgui.Create("DPanel", line)
			line.EntryColor:Dock(LEFT)
			line.EntryColor:SetWide(17)
			line.EntryColor.SolidColor = category.color
			line.EntryColor.Paint = SolidColorPaint

			line.AccessType = AccessType
			line.Type = bKeypads.ACCESS_GROUP.DARKRP_JOB_CATEGORY
			line.Key = category_name

			AddAccessGroupIcon(line)
		else
			self:GetAccessMatrix()[AccessType][bKeypads.ACCESS_GROUP.DARKRP_JOB_CATEGORY][category_name] = nil
		end
	end,

	[bKeypads.ACCESS_GROUP.DARKRP_AGENDA_GROUP] = function(self, AccessType, agenda_name)
		local agenda = bKeypads.DarkRP.Agendas.Members[agenda_name]
		if agenda then
			local line = self:AddLine("", "", agenda_name, "")
			line.bKeypads_Tooltip = L"GroupAgendaGroup"

			line.Icon = vgui.Create("DImage", line)
			line.Icon:Dock(LEFT)
			line.Icon:DockMargin(0,0,0,1)
			line.Icon:SetWide(16)
			line.Icon:SetImage("icon16/comments.png")

			line.AccessType = AccessType
			line.Type = bKeypads.ACCESS_GROUP.DARKRP_AGENDA_GROUP
			line.Key = agenda_name

			AddAccessGroupIcon(line)
		else
			self:GetAccessMatrix()[AccessType][bKeypads.ACCESS_GROUP.DARKRP_AGENDA_GROUP][agenda_name] = nil
		end
	end,

	[bKeypads.ACCESS_GROUP.DARKRP_DOOR_GROUP] = function(self, AccessType, door_group_name)
		local doorGroup = bKeypads.DarkRP.DoorGroups.Members[door_group_name]
		if doorGroup then
			local line = self:AddLine("", "", door_group_name, "")
			line.bKeypads_Tooltip = L"GroupDoorGroup"

			line.Icon = vgui.Create("DImage", line)
			line.Icon:Dock(LEFT)
			line.Icon:DockMargin(0,0,0,1)
			line.Icon:SetWide(16)
			line.Icon:SetImage("icon16/door.png")

			line.AccessType = AccessType
			line.Type = bKeypads.ACCESS_GROUP.DARKRP_DOOR_GROUP
			line.Key = door_group_name

			AddAccessGroupIcon(line)
		else
			self:GetAccessMatrix()[AccessType][bKeypads.ACCESS_GROUP.DARKRP_DOOR_GROUP][door_group_name] = nil
		end
	end,

	[bKeypads.ACCESS_GROUP.DARKRP_DEMOTE_GROUP] = function(self, AccessType, demote_group_name)
		local doorGroup = bKeypads.DarkRP.DemoteGroups[demote_group_name]
		if doorGroup then
			local line = self:AddLine("", "", demote_group_name, "")
			line.bKeypads_Tooltip = L"GroupDemoteGroup"

			line.Icon = vgui.Create("DImage", line)
			line.Icon:Dock(LEFT)
			line.Icon:DockMargin(0,0,0,1)
			line.Icon:SetWide(16)
			line.Icon:SetImage("icon16/user_suit.png")

			line.AccessType = AccessType
			line.Type = bKeypads.ACCESS_GROUP.DARKRP_DEMOTE_GROUP
			line.Key = demote_group_name

			AddAccessGroupIcon(line)
		else
			self:GetAccessMatrix()[AccessType][bKeypads.ACCESS_GROUP.DARKRP_DEMOTE_GROUP][demote_group_name] = nil
		end
	end,

	[bKeypads.ACCESS_GROUP.HELIX_FLAG] = function(self, AccessType, flag_name)
		local flag = ix.flag.list[flag_name]
		if flag then
			local line = self:AddLine("", "", flag_name, "")
			line.bKeypads_Tooltip = L"HelixFlag" .. "\n" .. (L"FlagName"):format(flag_name) .. (flag.description ~= nil and ("\n" .. flag.description) or "")

			line.Icon = vgui.Create("DImage", line)
			line.Icon:Dock(LEFT)
			line.Icon:DockMargin(0,0,0,1)
			line.Icon:SetWide(16)
			line.Icon:SetImage("icon16/flag_green.png")

			line.AccessType = AccessType
			line.Type = bKeypads.ACCESS_GROUP.HELIX_FLAG
			line.Key = flag_name

			AddAccessGroupIcon(line)
		else
			self:GetAccessMatrix()[AccessType][bKeypads.ACCESS_GROUP.HELIX_FLAG][flag_name] = nil
		end
	end,

	[bKeypads.ACCESS_GROUP.CUSTOM_TEAM_GROUP] = function(self, AccessType, team_group_name)
		local teamGroup = bKeypads.CustomAccess.UserConfig.TeamGroups[team_group_name]
		if teamGroup then
			local line = self:AddLine("", "", team_group_name, "")
			line.bKeypads_Tooltip = L"GroupCustomTeamGroup"

			line.Icon = vgui.Create("DImage", line)
			line.Icon:Dock(LEFT)
			line.Icon:DockMargin(0,0,0,1)
			line.Icon:SetWide(16)
			line.Icon:SetImage("icon16/script_code_red.png")

			line.AccessType = AccessType
			line.Type = bKeypads.ACCESS_GROUP.CUSTOM_TEAM_GROUP
			line.Key = team_group_name

			AddAccessGroupIcon(line)
		else
			self:GetAccessMatrix()[AccessType][bKeypads.ACCESS_GROUP.CUSTOM_TEAM_GROUP][team_group_name] = nil
		end
	end,

	[bKeypads.ACCESS_GROUP.CUSTOM_LUA_FUNCTION] = function(self, AccessType, lua_func_name)
		local LuaFunction = bKeypads.CustomAccess.UserConfig.LuaFunctions[lua_func_name]
		if LuaFunction then
			local line = self:AddLine("", "", lua_func_name, "")
			line.bKeypads_Tooltip = L"GroupCustomLuaFunction"

			line.Icon = vgui.Create("DImage", line)
			line.Icon:Dock(LEFT)
			line.Icon:DockMargin(0,0,0,1)
			line.Icon:SetWide(16)
			line.Icon:SetImage("icon16/script_code.png")

			line.AccessType = AccessType
			line.Type = bKeypads.ACCESS_GROUP.CUSTOM_LUA_FUNCTION
			line.Key = lua_func_name

			AddAccessGroupIcon(line)
		else
			self:GetAccessMatrix()[AccessType][bKeypads.ACCESS_GROUP.CUSTOM_LUA_FUNCTION][lua_func_name] = nil
		end
	end,

	[bKeypads.ACCESS_GROUP.CUSTOM_ADDON_FUNCTION] = function(self, AccessType, id)
		local customAddonEntry = bKeypads.CustomAccess.Addons.KeyTable[id]
		if customAddonEntry and customAddonEntry.Addon then
			local line = self:AddLine("", "", customAddonEntry.Name, "")
			line.bKeypads_Tooltip = customAddonEntry.Addon.Name
			
			if IsColor(customAddonEntry.Icon) or (istable(customAddonEntry.Icon) and customAddonEntry.Icon.r and customAddonEntry.Icon.g and customAddonEntry.Icon.b) then
				line.EntryColor = vgui.Create("DPanel", line)
				line.EntryColor:Dock(LEFT)
				line.EntryColor:SetWide(17)
				line.EntryColor.SolidColor = category.color
				line.EntryColor.Paint = SolidColorPaint
			elseif isstring(customAddonEntry.Icon) then
				line.Icon = vgui.Create("DImage", line)
				line.Icon:Dock(LEFT)
				line.Icon:DockMargin(0,0,0,1)
				line.Icon:SetWide(16)
				line.Icon:SetImage(customAddonEntry.Icon)
			elseif type(customAddonEntry.Icon) == "IMaterial" then
				line.Icon = vgui.Create("DImage", line)
				line.Icon:Dock(LEFT)
				line.Icon:DockMargin(0,0,0,1)
				line.Icon:SetWide(16)
				line.Icon:SetMaterial(customAddonEntry.Icon)
			end

			line.AccessType = AccessType
			line.Type = bKeypads.ACCESS_GROUP.CUSTOM_ADDON_FUNCTION
			line.Key = id

			AddAccessGroupIcon(line)
		else
			self:GetAccessMatrix()[AccessType][bKeypads.ACCESS_GROUP.CUSTOM_ADDON_FUNCTION][id] = nil
		end
	end,

	[bKeypads.ACCESS_GROUP.PAYMENT] = function(self, amount)
		local line = self:AddLine("", "", bKeypads.Economy:formatMoney(amount), L"AccessCharge")
		line.bKeypads_Tooltip = L"Payment"

		line.Icon = vgui.Create("DImage", line)
		line.Icon:Dock(LEFT)
		line.Icon:DockMargin(0,0,0,1)
		line.Icon:SetWide(16)
		line.Icon:SetImage("icon16/money.png")

		line.Type = bKeypads.ACCESS_GROUP.PAYMENT

		AddAccessGroupIcon(line)
	end,

}

function PANEL:SafePopulate()
	local AccessMatrix = self:GetAccessMatrix()

	if AccessMatrix[bKeypads.ACCESS_GROUP.PAYMENT] and bKeypads.Economy:HasCashSystem() then
		PopulateFunctions[bKeypads.ACCESS_GROUP.PAYMENT](self, AccessMatrix[bKeypads.ACCESS_GROUP.PAYMENT])
	end

	for _, AccessType in ipairs(bKeypads.ACCESS_TYPES) do

		for id in pairs(AccessMatrix[AccessType][bKeypads.ACCESS_GROUP.CUSTOM_ADDON_FUNCTION] or {}) do
			PopulateFunctions[bKeypads.ACCESS_GROUP.CUSTOM_ADDON_FUNCTION](self, AccessType, id)
		end
		for lua_func_name in pairs(AccessMatrix[AccessType][bKeypads.ACCESS_GROUP.CUSTOM_LUA_FUNCTION] or {}) do
			PopulateFunctions[bKeypads.ACCESS_GROUP.CUSTOM_LUA_FUNCTION](self, AccessType, lua_func_name)
		end
		for team_group_name in pairs(AccessMatrix[AccessType][bKeypads.ACCESS_GROUP.CUSTOM_TEAM_GROUP] or {}) do
			PopulateFunctions[bKeypads.ACCESS_GROUP.CUSTOM_TEAM_GROUP](self, AccessType, team_group_name)
		end

		if bkeypads_auth_mode:GetInt() == bKeypads.AUTH_MODE.KEYCARD then

			if AccessMatrix[AccessType][bKeypads.ACCESS_GROUP.SUPERIOR_KEYCARDS] then
				PopulateFunctions[bKeypads.ACCESS_GROUP.SUPERIOR_KEYCARDS](self, AccessType)
			end
			for level in pairs(AccessMatrix[AccessType][bKeypads.ACCESS_GROUP.KEYCARD_LEVEL] or {}) do
				PopulateFunctions[bKeypads.ACCESS_GROUP.KEYCARD_LEVEL](self, AccessType, level)
			end

		end

		if AccessMatrix[AccessType][bKeypads.ACCESS_GROUP.STEAM_FRIENDS] then
			PopulateFunctions[bKeypads.ACCESS_GROUP.STEAM_FRIENDS](self, AccessType)
		end

		for steamid, name in pairs(AccessMatrix[AccessType][bKeypads.ACCESS_GROUP.PLAYER] or {}) do
			PopulateFunctions[bKeypads.ACCESS_GROUP.PLAYER](self, AccessType, steamid, name)
		end

		for usergroup in pairs(AccessMatrix[AccessType][bKeypads.ACCESS_GROUP.USERGROUP] or {}) do
			PopulateFunctions[bKeypads.ACCESS_GROUP.USERGROUP](self, AccessType, usergroup)
		end

		if DarkRP then
			for _, access_group in ipairs({
				bKeypads.ACCESS_GROUP.DARKRP_JOB,
				bKeypads.ACCESS_GROUP.DARKRP_JOB_CATEGORY,
				bKeypads.ACCESS_GROUP.DARKRP_AGENDA_GROUP,
				bKeypads.ACCESS_GROUP.DARKRP_DOOR_GROUP,
				bKeypads.ACCESS_GROUP.DARKRP_DEMOTE_GROUP
			}) do
				if not AccessMatrix[AccessType][access_group] then continue end
				for v in pairs(AccessMatrix[AccessType][access_group]) do
					PopulateFunctions[access_group](self, AccessType, v)
				end
			end
		else
			for t in pairs(AccessMatrix[AccessType][bKeypads.ACCESS_GROUP.TEAM] or {}) do
				PopulateFunctions[bKeypads.ACCESS_GROUP.TEAM](self, AccessType, t)
			end
		end

		if ix and ix.flag then
			for flag in pairs(AccessMatrix[AccessType][bKeypads.ACCESS_GROUP.HELIX_FLAG] or {}) do
				PopulateFunctions[bKeypads.ACCESS_GROUP.HELIX_FLAG](self, AccessType, flag)
			end
		end

	end
end

local function populateFailed(err)
	ErrorNoHalt("Failed to load data from saved access matrix - it might be from an older/newer version of the addon!\n")
	ErrorNoHalt(err .. "\n")
	debug.Trace()
end
function PANEL:Populate()
	self:Clear()

	local succ = xpcall(self.SafePopulate, populateFailed, self)
	if succ then
		self:SaveAccessMatrix()
	else
		self:ResetAccessMatrix()
	end

	if self.PostPopulate then
		self:PostPopulate()
	end
end

function PANEL:Init()
	bkeypads_auth_mode = bkeypads_auth_mode or GetConVar("bkeypads_auth_mode")
	L = bKeypads.L
	matKeycard = matKeycard or Material("bkeypads/keycard")

	self:SetSortable(false)

	local col = self:AddColumn("")
	col:SetMaxWidth(17)
	col:SetMinWidth(17)

	local col = self:AddColumn("")
	col:SetMaxWidth(17)
	col:SetMinWidth(17)

	self:AddColumn(L"Value")
	self:AddColumn(L"Name")

	self.AccessMatrices = {}
	self:ResetAccessMatrix()
end

function PANEL:SetUseConVar(m_bUseConVar)
	self.m_bUseConVar = m_bUseConVar
end

function PANEL:GetAccessMatrix()
	if self.m_bUseConVar then
		return self.AccessMatrices[bkeypads_auth_mode:GetInt()]
	else
		return self.AccessMatrix
	end
end

function PANEL:ResetAccessMatrix()
	if self.m_bUseConVar then
		self.AccessMatrices[bkeypads_auth_mode:GetInt()] = bKeypads.KeypadData:AccessMatrix()
	else
		self.AccessMatrix = bKeypads.KeypadData:AccessMatrix()
	end
end

function PANEL:SaveAccessMatrix()
	if self.m_bUseConVar then
		local f = bKeypads.KeypadData.File:Open("bkeypads/stool/access_matrix_" .. bkeypads_auth_mode:GetInt() .. ".dat", true, "DATA")
		if f then
			bKeypads.KeypadData.File:Serialize(f, self:GetAccessMatrix())
		else
			ErrorNoHalt("Failed to save to garrysmod/data/bkeypads/stool/access_matrix_" .. bkeypads_auth_mode:GetInt() .. ".dat, file is likely being used by another process\n")
			ErrorNoHalt("Typing spawnmenu_reload in console a couple times might fix this\n")
		end
	end
end

function PANEL:OnRowRightClick()
	for _, line in ipairs(self:GetSelected()) do
		if line.Type == bKeypads.ACCESS_GROUP.PAYMENT then
			self:GetAccessMatrix()[line.Type] = false
		elseif (line.Type == bKeypads.ACCESS_GROUP.SUPERIOR_KEYCARDS or line.Type == bKeypads.ACCESS_GROUP.STEAM_FRIENDS) then
			self:GetAccessMatrix()[line.AccessType][line.Type] = false
		else
			self:GetAccessMatrix()[line.AccessType][line.Type][line.Key] = nil
		end
		self:RemoveLine(line:GetID())
	end

	self:SaveAccessMatrix()

	if self.PostPopulate then
		self:PostPopulate()
	end

	surface.PlaySound("friends/friend_join.wav")
end

function PANEL:OnRowSelected(rowIndex, row)
	if input.IsMouseDown(MOUSE_RIGHT) then return end

	surface.PlaySound("garrysmod/ui_return.wav")
	
	local DMenu = DermaMenu(nil, row)

	local icon = DMenu:AddOption(row.bKeypads_Tooltip)
	icon.DoClick = bKeypads.noop
	if row.Type == bKeypads.ACCESS_GROUP.KEYCARD_LEVEL then
		icon:SetImage("icon16/vcard.png")
	elseif IsValid(row.Icon) then
		icon:SetMaterial(row.Icon:GetMaterial())
	elseif IsValid(row.EntryColor) then
		icon:SetImage("icon16/box.png")
		icon.EntryColor = vgui.Create("DPanel", icon.m_Image)
		icon.EntryColor:Dock(FILL)
		icon.EntryColor.SolidColor = row.EntryColor.SolidColor
		icon.EntryColor.Paint = SolidColorPaint
	elseif IsValid(row.AvatarImage) then
		icon:SetImage("icon16/box.png")
		icon.AvatarImage = vgui.Create("AvatarImage", icon.m_Image)
		icon.AvatarImage:Dock(FILL)
		icon.AvatarImage:SetSteamID(util.SteamIDTo64(row.Key), 32)
	end

	if row.AccessType ~= nil then
		local access_type = DMenu:AddOption(row.AccessType == bKeypads.ACCESS_TYPE.WHITELIST and L"Whitelisted" or L"Blacklisted")
		access_type:SetIcon(row.AccessType == bKeypads.ACCESS_TYPE.WHITELIST and "icon16/accept.png" or "icon16/delete.png")
		access_type.m_Image:SetSize(16, 16)
		access_type.m_Image:InvalidateParent()
		access_type.DoClick = bKeypads.noop
	end

	DMenu:AddSpacer()

	local NameColumn = row:GetColumnText(4)
	local CopyName = DMenu:AddOption(L"CopyName", function()
		if GAS then
			GAS:SetClipboardText(NameColumn)
		else
			surface.PlaySound("garrysmod/content_downloaded.wav")
			SetClipboardText(NameColumn)
		end
	end)
	CopyName:SetIcon("icon16/page_copy.png")
	CopyName:SetDisabled(not NameColumn or (isstring(NameColumn) and #NameColumn == 0))

	local ValueColumn = row:GetColumnText(3)
	local CopyValue = DMenu:AddOption(L"CopyValue", function()
		if GAS then
			GAS:SetClipboardText(ValueColumn)
		else
			surface.PlaySound("garrysmod/content_downloaded.wav")
			SetClipboardText(ValueColumn)
		end
	end)
	CopyValue:SetIcon("icon16/page_copy.png")
	CopyValue:SetDisabled(not ValueColumn or (isstring(ValueColumn) and #ValueColumn == 0))

	DMenu:AddSpacer()

	DMenu:AddOption(L"Remove", function()
		if not IsValid(row) then return end
		self:ClearSelection()
		self:SelectItem(row)
		self:OnRowRightClick()
	end):SetIcon("icon16/delete.png")

	DMenu:Open()
end

function PANEL:ResolveConflicts(AccessType)
	local OppositeAccessMatrix = self:GetAccessMatrix()[AccessType == bKeypads.ACCESS_TYPE.WHITELIST and bKeypads.ACCESS_TYPE.BLACKLIST or bKeypads.ACCESS_TYPE.WHITELIST]
	for Type, Entries in pairs(self:GetAccessMatrix()[AccessType]) do
		if istable(Entries) then
			for Entry in pairs(Entries) do
				if OppositeAccessMatrix[Type] and OppositeAccessMatrix[Type][Entry] then
					OppositeAccessMatrix[Type][Entry] = nil
				end
			end
		elseif isbool(Entries) then
			if OppositeAccessMatrix[Type] then
				OppositeAccessMatrix[Type] = nil
			end
		end
	end
end

function PANEL:LoadAccessMatrix(authMode)
	if not self.AccessMatrices[authMode] then
		if file.Exists("bkeypads/stool/access_matrix_" .. authMode .. ".dat", "DATA") then
			local f = bKeypads.KeypadData.File:Open("bkeypads/stool/access_matrix_" .. authMode .. ".dat", false, "DATA")
			local success, SavedAccessMatrix = pcall(bKeypads.KeypadData.File.Deserialize, bKeypads.KeypadData.File, f)
			if success and SavedAccessMatrix then
				self.AccessMatrices[authMode] = SavedAccessMatrix
			else
				f:Close()
				file.Delete("bkeypads/stool/access_matrix_" .. authMode .. ".dat")
				self.AccessMatrices[authMode] = bKeypads.KeypadData:AccessMatrix()
			end
		else
			self.AccessMatrices[authMode] = bKeypads.KeypadData:AccessMatrix()
		end
	end

	self:Populate()
end

derma.DefineControl("bKeypads.AccessMatrix", nil, PANEL, "DListView")
--addons/openpermissions/lua/vgui/openpermissions_columnlayout.lua:
local PANEL = {}

OpenPermissions_COLUMN_LAYOUT_COLUMN_GROW = 0
OpenPermissions_COLUMN_LAYOUT_COLUMN_SHRINK = 1
OpenPermissions_COLUMN_LAYOUT_COLUMN_GROW_COLUMN = 2

function PANEL:Init()
	self.Columns = {}
	self.Rows = {}
	self.ColumnPadding = 0
	self.RowPadding = 0

	function self.pnlCanvas:PerformLayout()
		self:GetParent():ColumnLayout()
		self:InvalidateParent(true)
	end
end

function PANEL:SetPaddings(column_padding, row_padding)
	self.ColumnPadding = column_padding
	self.RowPadding = row_padding
end

function PANEL:SetColumns(...)
	self.Columns = {...}
	self.GrowColumnCount = 0
	for _,v in ipairs(self.Columns) do
		if (v == OpenPermissions_COLUMN_LAYOUT_COLUMN_GROW or v == OpenPermissions_COLUMN_LAYOUT_COLUMN_GROW_COLUMN) then
			self.GrowColumnCount = self.GrowColumnCount + 1
		end
	end
end

function PANEL:AddRow(...)
	local i = table.insert(self.Rows, {...})
	self.pnlCanvas:InvalidateLayout(true)
	return i
end

function PANEL:RemoveRow(row_index)
	for _,element in ipairs(self.Rows[row_index]) do
		element:Remove()
	end
	table.remove(self.Rows, row_index)
	self.pnlCanvas:InvalidateLayout(true)
end

function PANEL:ColumnLayout()
	local column_widths = {}
	local row_heights = {}
	for row_i, elements in ipairs(self.Rows) do
		for column_i, element in ipairs(elements) do
			if (self.Columns[column_i] == OpenPermissions_COLUMN_LAYOUT_COLUMN_SHRINK) then
				local element_w = element:GetWide()
				local column_w = column_widths[column_i]
				if (not column_w or element_w > column_w) then
					column_widths[column_i] = element_w
				end
			end
			if (self.Columns[column_i] ~= OpenPermissions_COLUMN_LAYOUT_COLUMN_GROW_COLUMN) then
				local element_h = element:GetTall()
				local row_h = row_heights[row_i]
				if (not row_h or element_h > row_h) then
					row_heights[row_i] = element_h
				end
			end
		end
	end
	local grow_column_width = 0
	for i,v in pairs(column_widths) do
		grow_column_width = grow_column_width - v - self.ColumnPadding
	end
	grow_column_width = ((grow_column_width + self:GetWide()) / self.GrowColumnCount) - 4

	local row_y = 0
	for row_i, elements in ipairs(self.Rows) do
		local column_x = 0
		for column_i, element in ipairs(elements) do
			local column_sizing = self.Columns[column_i]
			if (column_sizing == OpenPermissions_COLUMN_LAYOUT_COLUMN_SHRINK) then
				element:SetWide(column_widths[column_i])
				element:SetPos(column_x, row_y)
				column_x = column_x + column_widths[column_i] + self.ColumnPadding
			elseif (column_sizing == OpenPermissions_COLUMN_LAYOUT_COLUMN_GROW or column_sizing == OpenPermissions_COLUMN_LAYOUT_COLUMN_GROW_COLUMN) then
				if (OpenPermissions_COLUMN_LAYOUT_COLUMN_GROW_COLUMN) then
					element:SetWide(grow_column_width)
				else
					element:SetSize(grow_column_width, row_heights[row_i])
				end
				element:SetPos(column_x, row_y)
				column_x = column_x + grow_column_width + self.ColumnPadding
			end
		end
		row_y = row_y + row_heights[row_i] + self.RowPadding
	end
end

derma.DefineControl("OpenPermissions.ColumnLayout", nil, PANEL, "OpenPermissions.ScrollPanel")
--gamemodes/starwarsrp/gamemode/cl_init.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--    on official 'Einfach Gaming'   --
--     servers owned by 'P4sca1'     --
--                                   --
-- Copyright © 2020 Pascal Sthamer,  --
--      Konstantin Zisiadis und      --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--       Client | Initialization     --
---------------------------------------

include("shared.lua")
--gamemodes/egmrp/gamemode/cl_init.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--       Client | Initialization     --
---------------------------------------

include("shared.lua")
--lua/weapons/awhg_bobs_gun_base/shared.lua:
DEFINE_BASECLASS("tfa_gun_base")
--addons/bkeypads_cracker/lua/weapons/bkeypads_cracker/shared.lua:
SWEP.PrintName    = "#bKeypads_KeypadCracker"
SWEP.Category     = "Billy's Keypads"
SWEP.Author       = "Billy"
SWEP.Instructions = "Left click to crack a keypad"

SWEP.UseHands = true

SWEP.Slot = 4
SWEP.SlotPos = 1
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true

SWEP.ViewModelFOV = 62
SWEP.ViewModelFlip = false
SWEP.ViewModel = Model("models/weapons/cstrike/c_c4.mdl")
SWEP.WorldModel = Model("models/bkeypads/cracker.mdl")

SWEP.Primary.ClipSize    = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic   = false
SWEP.Primary.Ammo        = "none"

SWEP.Secondary.ClipSize    = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic   = false
SWEP.Secondary.Ammo        = "none"

SWEP.Spawnable = true
SWEP.AutoSwitchTo = false

SWEP.PLANT = {}
SWEP.PLANT.CRACKING = -1
SWEP.PLANT.IDLE     = 0
SWEP.PLANT.PUNCH    = 1
SWEP.PLANT.DEPLOY   = 2
SWEP.PLANT.FINISH   = 3

if CLIENT then
	SWEP.WepSelectIcon = surface.GetTextureID("bkeypads/keypad_cracker_selection")
	SWEP.BounceWeaponIcon = true
end

function SWEP:Initialize()
	self:SetModelScale(0.75)
	self:SetHoldType("slam")
	self:SetDeploySpeed(1)

	self.m_iPlantingStage = self.PLANT.IDLE
	
	if CLIENT then
		self:SetFace("default")
		self:SetScreenText(bKeypads.L"CrackerWaiting")
	end
end

function SWEP:SetupDataTables()
	self:NetworkVar("Entity", 0, "CrackingKeypad")
	self:NetworkVar("Float", 0, "CrackCompleteTime")
	self:NetworkVar("Bool", 0, "SpecialCrackTime")
	self:NetworkVar("Bool", 1, "Cracking")

	self:NetworkVarNotify("Cracking", self.OnCrackingChanged)
	if CLIENT then
		self:NetworkVarNotify("CrackCompleteTime", self.OnCrackTimeDataReceived)
		self:NetworkVarNotify("CrackingKeypad", self.OnCrackingKeypadSet)
	end
end

function SWEP:CrackingSoundThink()
	if self.m_iPlantingStage ~= self.PLANT.CRACKING then
		self.m_iCrackingSound = nil
		if self.m_tCrackingSound then
			if self.m_fCrackingSoundEnd and CurTime() <= self.m_fCrackingSoundEnd then
				self.m_fCrackingSoundEnd = nil
				self:StopSound(self.m_tCrackingSound.path)
			end
			self.m_tCrackingSound = nil
		end
		if self.m_fNextBlip and CurTime() <= self.m_fNextBlip then
			self.m_fNextBlip = nil
			self:StopSound("buttons/blip2.wav")
		end
		return
	end
	
	if not self.m_fCrackingSoundEnd or CurTime() >= self.m_fCrackingSoundEnd then
		self.m_iCrackingSound = math.max(((self.m_iCrackingSound or 0) + 1) % (#bKeypads.Cracker.Sounds["typing"] + 1), 1)
		self.m_tCrackingSound = bKeypads.Cracker.Sounds["typing"][self.m_iCrackingSound]
		self.m_fCrackingSoundEnd = CurTime() + self.m_tCrackingSound.duration
		self:EmitSound(self.m_tCrackingSound.path, 75, 100, 1, CHAN_WEAPON)
	end

	if bKeypads.Cracker.Config.Beeps.Enable then
		local doBlip = self.m_fNextBlip ~= nil
		if not self.m_fNextBlip or CurTime() >= self.m_fNextBlip then
			self.m_fNextBlip = CurTime() + (bKeypads.Cracker.Config.Beeps.BeepInterval == 0 and 1 or bKeypads.Cracker.Config.Beeps.BeepInterval)
			if doBlip then
				self:EmitSound("buttons/blip2.wav", bKeypads.Cracker.Config.Beeps.BeepVolume, 100, 1, CHAN_WEAPON)
			end
		end
	end
end

function SWEP:PlaySound(name, volume)
	if not IsFirstTimePredicted() then return end
	local snd = bKeypads.Cracker.Sounds[name] and bKeypads.Cracker.Sounds[name].path or name
	if self.m_sPlayedSound ~= snd then
		if self.m_sPlayedSound then
			self:StopSound(self.m_sPlayedSound)
		end
		self.m_sPlayedSound = snd
		self:EmitSound(self.m_sPlayedSound, 75, 100, volume, CHAN_WEAPON)
	end
end

function SWEP:SecondaryAttack()
	return false
end

function SWEP:PrimaryAttack()
	if not IsValid(self:GetOwner()) or not self:GetOwner():IsPlayer() then return false end

	self:SetNextPrimaryFire(CurTime() + 0.4)

	if not self:GetCracking() then
		if self:ComputeCanCrack() then
			if SERVER or IsFirstTimePredicted() then
				self:StartCracking()
			end
			return true
		elseif CLIENT and IsFirstTimePredicted() then
			self:CantCrack()
		end
	end

	return false
end

function SWEP:CancelCracking()
	local wasStartingCrack = self:GetCracking()
	local wasCracking = self:GetCrackCompleteTime() > 0
	
	if SERVER then
		self:SetCracking(false)
		self:SetCrackCompleteTime(0)
		self.m_bCrackingKeypadSet = nil
	else
		self.m_fCrackStart = nil
		self.m_fNextCrackingFace = nil
		self.CrackingFace = nil

		if self.BlockC4Typing then hook.Remove("EntityEmitSound", self.BlockC4Typing) end
	end

	self.m_iPlantingStage = self.PLANT.IDLE
	self.m_iPlantingNextStage = nil

	self:SendWeaponAnim(ACT_VM_IDLE)
	if self.m_sPlayedSound then self:StopSound(self.m_sPlayedSound) end
	if wasStartingCrack then
		if CLIENT then self.m_fErrorScreenEnd = CurTime() + 0.5 end

		timer.Simple(0, function()
			if not IsValid(self) then return end
			self:EmitSound(bKeypads.Cracker.Sounds["error"].path, 75, 100, .5, CHAN_WEAPON)
		end)

		if SERVER and wasCracking then
			hook.Run("bKeypads.Cracker.Abort", self, self:GetCrackingKeypad(), self:GetOwner())
		end
	end
	
	self.m_sPlayedSound = nil
	
	self:CrackingSoundThink()
end

function SWEP:StartCracking()
	if not IsValid(self.m_eTargetKeypad) then
		self:CancelCracking()
		return
	end
	if SERVER then
		self:SetCracking(true)
	end
	self:SendWeaponAnim(ACT_VM_PRIMARYATTACK)
	if bKeypads.Cracker.Config.Deployed then
		self.m_iPlantingStage = self.PLANT.PUNCH
		self.m_iPlantingNextStage = CurTime() + 2.4
		self:PlaySound("whirr", .5)
	else
		if SERVER then
			self.m_iPlantingStage = self.PLANT.CRACKING
			self:SetCrackingKeypad(self.m_eTargetKeypad)
			self:SetCrackCompleteTime(CurTime() + bKeypads.Cracker:GetCrackTime(self:GetOwner(), self.m_eTargetKeypad))
			self.m_bCrackingKeypadSet = true
			self.m_iPlantingNextStage = self:GetCrackCompleteTime()
		else
			if self.m_iPlantingStage ~= self.PLANT.CRACKING then
				self.m_iPlantingStage = self.PLANT.CRACKING
				self.m_iPlantingNextStage = nil
			end

			-- HACK!
			-- Fixes c4 typing sound from overriding keypad cracker sounds
			local ply = self:GetOwner()
			local sequenceStarted = false
			local seq = self:LookupSequence("pressbutton")
			self.BlockC4Typing = "bKeypads.BlockC4Typing:" .. string.format("%p", self)
			hook.Add("EntityEmitSound", self.BlockC4Typing, function(snd)
				if IsValid(self) and self:GetOwner() == ply then
					if snd.OriginalSoundName == "c4.click" and snd.Entity == ply then
						sequenceStarted = true
						snd.Channel = CHAN_AUTO
						return true
					elseif not sequenceStarted or self:GetSequence() == seq then
						return
					end
				end

				hook.Remove("EntityEmitSound", self.BlockC4Typing)
			end)
		end
		self:PlaySound("charge", .5)
	end
end

function SWEP:StartPlanting()
	self.m_iPlantingStage = self.PLANT.DEPLOY
	self.m_iPlantingNextStage = CurTime() + .7

	self:SendWeaponAnim(ACT_VM_SECONDARYATTACK)
	self:PlaySound("charge", .5)
end

function SWEP:FinishPlanting()
	self.m_iPlantingStage = self.PLANT.FINISH
	
	if IsValid(self.m_eTargetKeypad) and self.m_eTargetKeypad.bKeypad then
		if CLIENT then return end

		local deployedCracker = ents.Create("bkeypads_deployed_cracker")
		deployedCracker:Spawn()
		deployedCracker:Activate()
		deployedCracker:PlantOnKeypad(self.m_eTargetKeypad, self)

		self.Think = nil

		local ply = self:GetOwner()
		if IsValid(ply) and ply:IsPlayer() then
			ply:StripWeapon("bkeypads_cracker")

			if self.m_OldWeapon then
				local wep = ply:GetWeapon(self.m_OldWeapon)
				if IsValid(wep) then
					ply:SelectWeapon(self.m_OldWeapon)
					return
				end
			end
			
			ply:SwitchToDefaultWeapon()
			return
		else
			self:Remove()
		end
	else
		self:CancelCracking()
	end
end

function SWEP:FinishCracking()
	self:ComputeCanCrack()

	if IsValid(self:GetCrackingKeypad()) and IsValid(self:GetOwner()) and self:GetOwner():GetEyeTrace().Entity == self:GetCrackingKeypad() then
		self:SendWeaponAnim(ACT_VM_IDLE)

		if SERVER then
			if bKeypads.Cracker:CrackComplete(self, self:GetCrackingKeypad(), self:GetOwner()) then
				self:CrackingSucceeded()
				
				hook.Run("bKeypads.Cracker.Succeeded", self, self:GetCrackingKeypad(), self:GetOwner())
			else
				self:CrackingFailed()
				
				hook.Run("bKeypads.Cracker.Failed", self, self:GetCrackingKeypad(), self:GetOwner())
			end
			self:SetCracking(false)

			self:HideCrackingScreen()
		end
	else
		self:CancelCracking()
	end
end

function SWEP:HideCrackingScreen()
	if CLIENT then
		self.m_fCrackStart = nil
		self.m_fNextCrackingFace = nil
		self.CrackingFace = nil
	end
	
	self.m_iPlantingStage = self.PLANT.IDLE
end
function SWEP:CrackingSucceeded()
	self:EmitSound(bKeypads.Cracker.Sounds["success"].path, 75, 100, 1, CHAN_WEAPON)
	if CLIENT then
		self.m_fSuccessScreenEnd = CurTime() + 3
		self:Emote("happy", 3, "#bKeypads_CrackSuccess")
		self:HideCrackingScreen()
	else
		self:CallOnClient("CrackingSucceeded")
	end
end
function SWEP:CrackingFailed()
	self:EmitSound(bKeypads.Cracker.Sounds["critical"].path, 75, 100, 1, CHAN_WEAPON)
	if CLIENT then
		self.m_fErrorScreenEnd = CurTime() + 3
		self:Emote("sad", 3, "#bKeypads_CrackFailed")
		self:HideCrackingScreen()
	else
		self:CallOnClient("CrackingFailed")
	end
end

function SWEP:Think()
	if SERVER then
		local targetKeypad = self.m_eTargetKeypad
		self:ComputeCanCrack()
		if bKeypads.Cracker.Config.SpecialSunglasses and targetKeypad ~= self.m_eTargetKeypad then
			self:SetSpecialCrackTime(select(2, bKeypads.Cracker:GetCrackTime(self:GetOwner(), self.m_eTargetKeypad)))
		end
	else
		self:ComputeCanCrack()
	end

	if CLIENT then self:ClientThink() end
	
	if self.m_iPlantingStage ~= self.PLANT.IDLE and (
		not self.m_bIsWithinDist or
		not IsValid(self:GetOwner()) or not IsValid(self:GetOwner():GetEyeTrace().Entity) or
		(self.m_iPlantingStage == self.PLANT.CRACKING and self.m_bCrackingKeypadSet and (not IsValid(self:GetCrackingKeypad()) or self:GetCrackingKeypad() ~= self:GetOwner():GetEyeTrace().Entity))
	) then
		self:CancelCracking()
		return
	end

	if not bKeypads.Cracker.Config.Deployed then self:CrackingSoundThink() end
	
	if self.m_iPlantingNextStage and CurTime() >= self.m_iPlantingNextStage then
		self.m_iPlantingNextStage = nil

		self.m_iPlantingStage = self.m_iPlantingStage + 1

		if self.m_iPlantingStage == self.PLANT.IDLE then
			self:FinishCracking()
		elseif self.m_iPlantingStage == self.PLANT.DEPLOY then
			self:StartPlanting()
		elseif self.m_iPlantingStage == self.PLANT.FINISH then
			self:FinishPlanting()
		end
	end

	if self:GetCracking() then
		self:SetHoldType("pistol")
	else
		self:SetHoldType("slam")
	end
end

do
	local CacheFrame
	function SWEP:ComputeCanCrack()
		if SERVER or FrameNumber() ~= CacheFrame then
			local ply = self:GetOwner()
			if not IsValid(ply) then
				self.m_bIsKeypad, self.m_bIsWithinDist, self.m_bCanCrack, self.m_eTargetKeypad = false, false, false, nil
			else
				local tr = ply:GetEyeTrace()
				self.m_bIsKeypad       = IsValid(tr.Entity) and tr.Entity.bKeypad == true
				self.m_bIsWithinDist   = self.m_bIsKeypad and tr.HitPos:DistToSqr(ply:GetShootPos()) <= bKeypads.Cracker.Settings.CrackDistance
				self.m_bNotUncrackable = self.m_bIsWithinDist and not tr.Entity:GetUncrackable()
				self.m_bIsLinked       = self.m_bNotUncrackable and tr.Entity:GetIsLinked()
				self.m_bCanCrack       = self.m_bIsLinked and tr.Entity.IsKeypad and not IsValid(tr.Entity.m_eDeployedCracker)
				self.m_eTargetKeypad   = self.m_bCanCrack and tr.Entity or nil
			end
			if CLIENT then
				CacheFrame = FrameNumber()
			end
		end

		return self.m_bCanCrack
	end
end

if SERVER then
	hook.Add("PlayerSwitchWeapon", "bKeypads.Cracker.PlayerSwitchWeapon", function(ply, oldWep, newWep)
		if IsValid(newWep) and IsValid(oldWep) then
			if newWep:GetClass() == "bkeypads_cracker" then
				newWep.m_eOldWeapon = oldWep:GetClass()
			elseif oldWep:GetClass() == "bkeypads_cracker" then
				oldWep.m_eOldWeapon = newWep:GetClass()
			end
		end
	end)
end

function SWEP:Deploy()
	self:CancelCracking()
	self:SendWeaponAnim(ACT_VM_DRAW)
	if CLIENT then
		self.m_tTVAnimation = nil
		self.m_sPlayedSound = nil
		self.m_bDeployed = nil
		self.m_bPlayHello = true
	elseif IsValid(self:GetOwner()) then
		self:SetSpecialCrackTime(select(2, bKeypads.Cracker:GetCrackTime(self:GetOwner(), NULL)))
	end
	return true
end

function SWEP:Holster()
	self.m_bIsKeypad, self.m_bIsWithinDist, self.m_bCanCrack, self.m_eTargetKeypad = false, false, false, nil
	self:CancelCracking()
	if self.BlockC4Typing then hook.Remove("EntityEmitSound", self.BlockC4Typing) end
	return true
end

if CLIENT then
	function SWEP:Deployed()
		self:Deploy()
	end
	function SWEP:Holstered()
		self:Holster()
	end
end
bKeypads_Prediction(SWEP)
--addons/ballistic_shields/lua/ballistic_shields/sh_bs_lang.lua:
include( "ballistic_shields/sh_bs_util.lua" )

bshields.lang = {
	["German"] = {
		["sec"] = "[RMB] Unsichtbar/Sichtbar",
		["dshieldprim"] = "[LMB] Platzieren",
		["hshieldprim"] = "[LMB] Schlagen",
		["rshieldprim"] = "[LMB] Schlagen",
		["hshieldcd1"] = "Wait ",
		["hshieldcd2"] = " seconds to breach next door!"
	}
} 

if bshields.lang[bshields.config.language] == nil then
	bshields.config.language = "English"
end
--addons/heart_turbolaser_tool/lua/weapons/gmod_tool/stools/heart_turbolaser_tool.lua:
TOOL.Category = "CW:RP"
TOOL.Name = "Turbolaser Tool"
TOOL.Command = nil
TOOL.ConfigName	= ""

if CLIENT then
	language.Add( "tool.heart_turbolaser_tool.name", "Turbolaser Tool" )
	language.Add( "Tool.heart_turbolaser_tool.desc", "Shoot turbolasers." )
	language.Add( "Tool.heart_turbolaser_tool.left", "Shoot a turbolaser from the sky to where you are aiming.")
	language.Add( "Tool.heart_turbolaser_tool.right", "Shoot a turbolaser from the toolgun.")
	language.Add( "Tool.heart_turbolaser_tool.reload", "Creates a turbolaser spawner at your location.")
end

TOOL.Information = {
	{ name = "left" },
	{ name = "right" },
	{ name = "reload"}
}

// turbolaser options
TOOL.ClientConVar["speed"] = 1000
TOOL.ClientConVar["damage"] = 1000
TOOL.ClientConVar["radius"] = 150
TOOL.ClientConVar["scale"] = 1.0

TOOL.ClientConVar["r"] = 255
TOOL.ClientConVar["g"] = 0
TOOL.ClientConVar["b"] = 0

// spawner options
TOOL.ClientConVar["shots"] = 3
TOOL.ClientConVar["delay"] = 0.5
TOOL.ClientConVar["spread"] = 0

local defaultCV = TOOL:BuildConVarList()

function TOOL:VerifyValues()
	local speed = self:GetClientNumber("speed")
	local damage = self:GetClientNumber("damage")
	local radius = self:GetClientNumber("radius")
	local scale = self:GetClientNumber("scale")

	local shots = self:GetClientNumber("shots")
	local delay = self:GetClientNumber("delay")
	local spread = self:GetClientNumber("spread")

	local r = self:GetClientNumber("r")
	local g = self:GetClientNumber("g")
	local b = self:GetClientNumber("b")

	if speed <= 0 then return false end
	if damage < 0 then return false end
	if radius < 0 then return false end
	if scale < 0 then return false end

	if shots <= 0 then return false end
	if delay < 0 then return false end
	if spread < 0 then return false end

	if r < 0 || r > 255 then return false end
	if g < 0 || g > 255 then return false end
	if b < 0 || b > 255 then return false end

	return true
end

// summon turbolaser function
function TOOL:Turbolaser()
	if CLIENT then return end

	if not self:VerifyValues() then return end

	local speed = self:GetClientNumber("speed")
	local damage = self:GetClientNumber("damage")
	local radius = self:GetClientNumber("radius")
	local scale = self:GetClientNumber("scale")

	local r = self:GetClientNumber("r")
	local g = self:GetClientNumber("g")
	local b = self:GetClientNumber("b")

	local laser = ents.Create("heart_turbolaser")
	laser:SetVar("speed", speed)
	laser:SetVar("damage", damage)
	laser:SetVar("radius", radius)

	laser:SetVar("scale", scale)
	laser:SetVar("r", r)
	laser:SetVar("g", g)
	laser:SetVar("b", b)

	return true, laser
end

// shoot from sky
function TOOL:LeftClick(trace)
	if CLIENT then return end

	local spawned, laser = self:Turbolaser()
	if not spawned then return end

	local ply = self:GetOwner()

	laser:SetOwner(ply)
	laser:SetPos(trace.HitPos + Vector(0, 0, 5000))
	laser:SetAngles(Angle(90, 0, 0))

	laser:Spawn()
	laser:Activate()

	undo.Create("Turbolaser")
	undo.AddEntity(laser)
	undo.SetPlayer(ply)
	undo.SetCustomUndoText("Undone Turbolaser")
	undo.Finish()

	return false
end

// shoot from face
function TOOL:RightClick()
	if CLIENT then return end

	local spawned, laser = self:Turbolaser()
	if not spawned then return end

	local ply = self:GetOwner()

	laser:SetOwner(ply)
	laser:SetPos(ply:GetShootPos())
	laser:SetAngles(ply:GetAngles())

	laser:Spawn()
	laser:Activate()

	undo.Create("Turbolaser")
	undo.AddEntity(laser)
	undo.SetPlayer(ply)
	undo.SetCustomUndoText("Undone Turbolaser")
	undo.Finish()

	return false
end

// spawner from face
function TOOL:Reload()
	if CLIENT then return end

	if not self:VerifyValues() then return end

	local ply = self:GetOwner()

	local speed = self:GetClientNumber("speed")
	local damage = self:GetClientNumber("damage")
	local radius = self:GetClientNumber("radius")
	local scale = self:GetClientNumber("scale")

	local shots = self:GetClientNumber("shots")
	local delay = self:GetClientNumber("delay")
	local spread = self:GetClientNumber("spread")

	local r = self:GetClientNumber("r")
	local g = self:GetClientNumber("g")
	local b = self:GetClientNumber("b")

	local spawner = ents.Create("heart_turbolaser_spawner")
	spawner:SetOwner(ply)
	spawner:SetPos(self:GetOwner():GetShootPos())
	spawner:SetAngles(self:GetOwner():GetAngles())

	spawner:SetVar("speed", speed)
	spawner:SetVar("damage", damage)
	spawner:SetVar("radius", radius)

	spawner:SetVar("shots", shots)
	spawner:SetVar("delay", delay)
	spawner:SetVar("spread", spread)

	spawner:SetVar("scale", scale)
	spawner:SetVar("r", r)
	spawner:SetVar("g", g)
	spawner:SetVar("b", b)

	spawner:Spawn()
	spawner:Activate()

	undo.Create("Spawner")
	undo.AddEntity(spawner)
	undo.SetPlayer(ply)
	undo.SetCustomUndoText("Undone Turbolaser Spawner")
	undo.Finish()
end

function TOOL.BuildCPanel(panel)
	panel:SetName("Heart Turbolaser Tool")

	local header = vgui.Create("DImage")
	header:SetImage("materials/heart/turbolaser_header.png")
	header:SetSize(305, 140)
	panel:AddItem(header)

	panel:Help("Version 1.0")

	panel:AddControl( "ComboBox", { MenuButton = 1, Folder = "heart_turbolaser", Options = { [ "#preset.default" ] = defaultCV }, CVars = table.GetKeys( defaultCV ) } )

	panel:ControlHelp("")

	local divider1 = vgui.Create("DImage")
	divider1:SetImage("materials/heart/turbolaser_divider1.png")
	divider1:SetSize(305, 16)
	panel:AddItem(divider1)

	panel:NumSlider("Speed","heart_turbolaser_tool_speed","1","10000","0")
	panel:ControlHelp("Sets the speed of the turbolaser.")

	panel:NumSlider("Damage","heart_turbolaser_tool_damage","0","10000","0")
	panel:ControlHelp("Sets the damage of the turbolaser explosion.")

	panel:NumSlider("Explosion Radius","heart_turbolaser_tool_radius","10","1000","0")
	panel:ControlHelp("Sets the radius of the turbolasers explosion.")

	panel:NumSlider("Scale","heart_turbolaser_tool_scale","0.1","2","2")
	panel:ControlHelp("Sets the scale of the turbolaser model.")

	local colourLabel = vgui.Create("DLabel")
	colourLabel:SetText("Colour")
	colourLabel:SetColor(Color(0,0,0))
	panel:AddItem(colourLabel)

	panel:ColorPicker("", "heart_turbolaser_tool_r", "heart_turbolaser_tool_g", "heart_turbolaser_tool_b")

	panel:ControlHelp("")
	panel:ControlHelp("Sets the colour of the turbolaser.")

	panel:ControlHelp("")

	local divider2 = vgui.Create("DImage")
	divider2:SetImage("materials/heart/turbolaser_divider2.png")
	divider2:SetSize(305, 16)
	panel:AddItem(divider2)

	panel:NumSlider("Number of Shots","heart_turbolaser_tool_shots","1","10000","0")
	panel:ControlHelp("Sets the number of shots for the turbolaser spawner.")

	panel:NumSlider("Delay between Shots","heart_turbolaser_tool_delay","0.1","5","1")
	panel:ControlHelp("Sets the delay between shots for the turbolaser spawner. (In seconds)")

	panel:NumSlider("Spread","heart_turbolaser_tool_spread","0","10","1")
	panel:ControlHelp("Sets the spread of the turbolasers spawned from the turbolaser spawner.")

	panel:ControlHelp("")
end
--addons/lvs_base/lua/weapons/gmod_tool/stools/lvshealthshieldeditor.lua:

TOOL.Category		= "LVS"
TOOL.Name			= "#tool.lvshealthshieldeditor.name"
TOOL.Command		= nil
TOOL.ConfigName		= ""

TOOL.ClientConVar[ "maxshield" ] = 0
TOOL.ClientConVar[ "maxhealth" ] = 5000

if CLIENT then
	language.Add( "tool.lvshealthshieldeditor.name", "Max Health & Shield Editor" )
	language.Add( "tool.lvshealthshieldeditor.desc", "A tool used to edit Max Health & Shield on LVS-Vehicles" )
	language.Add( "tool.lvshealthshieldeditor.0", "Left click on a LVS-Vehicle to set Max Health, Right click to set Max Shield, Reload to reset." )
	language.Add( "tool.lvshealthshieldeditor.1", "Left click on a LVS-Vehicle to set Max Health, Right click to set Max Shield, Reload to reset." )
	language.Add( "tool.lvshealthshieldeditor.maxshield", "Max Shield" )
	language.Add( "tool.lvshealthshieldeditor.maxhealth", "Max Health" )
end

function TOOL:LeftClick( trace )
	local ent = trace.Entity

	if not IsValid( ent ) then return false end

	if not ent.LVS and not ent.LFS then return end

	if not ent.OGMaxHealth then
		ent.OGMaxHealth = ent.MaxHealth
	end

	ent.MaxHealth = self:GetClientNumber( "maxhealth" )
	ent:SetHP( ent.MaxHealth )

	return true
end

function TOOL:RightClick( trace )
	local ent = trace.Entity

	if not IsValid( ent ) then return false end

	if not ent.LVS and not ent.LFS then return end

	if not ent.OGMaxShield then
		ent.OGMaxShield = ent.MaxShield
	end

	ent.MaxShield = self:GetClientNumber( "maxshield" )
	ent:SetShield( ent.MaxShield )

	return true
end

function TOOL:Reload( trace )
	local ent = trace.Entity

	if not IsValid( ent ) then return false end

	if not ent.LVS and not ent.LFS then return end

	if ent.OGMaxHealth then
		ent.MaxHealth = ent.OGMaxHealth
	end

	if ent.OGMaxShield then
		ent.MaxShield = ent.OGMaxShield
	end

	ent:SetHP( ent.MaxHealth )
	ent:SetShield( ent.MaxShield )

	return true
end

function TOOL:Think()
	if SERVER then return end

	local ply = LocalPlayer()
	local tr = ply:GetEyeTrace()

	local ent = tr.Entity
	if not IsValid( ent ) then return end

	if not ent.LVS and not ent.LFS then return end

	local Text = "Health: "..tostring( math.Round( ent:GetHP(), 0 ) ).."/"..tostring( ent.MaxHealth )
	if ent:GetShield() > 0 then
		Text = Text.."\nShield: "..tostring( math.Round( ent:GetShield(), 0 ) ).."/"..tostring( ent.MaxShield )
	end

	AddWorldTip( ent:EntIndex(), Text, SysTime() + 0.05, ent:GetPos(), ent )
end

function TOOL.BuildCPanel( panel )
	panel:AddControl( "Header", { Text = "#tool.lvshealthshieldeditor.name", Description = "#tool.lvshealthshieldeditor.desc" } )

	panel:AddControl( "Slider", 
	{
		Label 	= "#tool.lvshealthshieldeditor.maxhealth",
		Type 	= "Int",
		Min 	= "1",
		Max 	= "50000",
		Command = "lvshealthshieldeditor_maxhealth",
		Help = false
	})

	panel:AddControl( "Slider", 
	{
		Label 	= "#tool.lvshealthshieldeditor.maxshield",
		Type 	= "Int",
		Min 	= "0",
		Max 	= "50000",
		Command = "lvshealthshieldeditor_maxshield",
		Help = false
	})

	panel:AddControl( "Label",  { Text = "NOTE: Value in Edit-Properties menu will still be the same, because they can not be updated after the vehicle is spawned!" } )
end

--lua/weapons/gmod_tool/stools/nocollide_world.lua:
TOOL.Category		= "Construction"
TOOL.Name			= "#No Collide World"
TOOL.Command		= nil
TOOL.ConfigName		= nil

TOOL.ClientConVar["options"] = "1"
TOOL.ClientConVar["distance"] = "10"
TOOL.ClientConVar["ignore"] = "1"
TOOL.ClientConVar["effect"] = "0"
TOOL.ClientConVar["remove"] = "0"

if SERVER then
	resource.AddFile("materials/effects/render_vector.vtf")
	resource.AddFile("materials/effects/render_vector.vmt")
	util.AddNetworkString("DrawNoCollide")
end

if CLIENT then
	language.Add("Tool.nocollide_world.name", "No collide world")
	language.Add("Tool.nocollide_world.desc", "To let an objects ignore collisions")
	language.Add("Tool.nocollide_world.0", "Click on 2 objects or world to make them not collide or right click to make an object not collide with anything.")
	language.Add("Tool.nocollide_world.1", "Now click on something else.")
	language.Add("Tool.nocollide_world.2", "Click on an object to prevent it from colliding with the world or right click to make an object not collide with anything.")
	language.Add("Tool.nocollide_world.3", "Click on 2 objects with or without connected objects to make them not collide including connected objects or right click to make an object not collide with anything.")
	language.Add("Tool.nocollide_world.4", "Now click on something else.")
	language.Add("Tool.nocollide_world.5", "Click on an object with connected objects to prevent it from colliding with each other or right click to make an object not collide with anything.")
	language.Add("Tool.nocollide_world.6", "Prevent an object from colliding with players or right click to make an object not collide with anything.")
	language.Add("Tool.nocollide_world.7", "Prevent an object from colliding with objects within box or right click to make an object not collide with anything.")
	language.Add("Tool.nocollide_world.8", "Prevent an object from colliding with objects within sphere or right click to make an object not collide with anything.")
	language.Add("Tool.nocollide_world.9", "Click on an object to select. Right click to apply no collide between all selected objects.")
	
	local EFFECT = {}
	EFFECT.Draw = {}
	EFFECT.Register = {}
	EFFECT.Ents = {}
	--[[
		EFFECT.Ents[Index][1] = Entity
		EFFECT.Ents[Index][2] = Color
		EFFECT.Ents[Index][3] = Rendermode
		EFFECT.Ents[Index][4][Type] = Eff_Count
		or
		EFFECT.Ents[Index][4][Type][Count] = Eff_Count
		
		EFFECT.Register[Type][Eff_Count][Ent_Count] = Index
		EFFECT.Register[Type][Eff_Count][3] = DrawCount
	]]
	
	local function RegisterEffect(Type,Index,Ent,Count)
		if !EFFECT.Ents[Index] then EFFECT.Ents[Index] = {} end
		if !EFFECT.Ents[Index][1] then EFFECT.Ents[Index][1] = Ent end
		if !EFFECT.Ents[Index][2] then EFFECT.Ents[Index][2] = Ent:GetColor() end
		if !EFFECT.Ents[Index][3] then EFFECT.Ents[Index][3] = Ent:GetRenderMode() end
		
		if !EFFECT.Register[Type] then EFFECT.Register[Type] = {} end
		Count = Count or #EFFECT.Register[Type]+1
		if !EFFECT.Register[Type][Count] then EFFECT.Register[Type][Count] = {} end
		if EFFECT.Register[Type][Count][1] then EFFECT.Register[Type][Count][2] = Index else EFFECT.Register[Type][Count][1] = Index end
		
		if !EFFECT.Ents[Index][4] then EFFECT.Ents[Index][4] = {} end
		if Type == 1 or Type == 2 or Type == 3 or Type == 4 or Type == 15 or Type == 16 or Type == 17 then
			if !EFFECT.Ents[Index][4][Type] then EFFECT.Ents[Index][4][Type] = {} end
			EFFECT.Ents[Index][4][Type][#EFFECT.Ents[Index][4][Type]+1] = Count
		else
			EFFECT.Ents[Index][4][Type] = Count
		end
		return Count
	end
	
	local function CleanupTables()
		local DrawPositions = {}
		local NewDraw = {}
		local Count = 0
		for i=1,#EFFECT.Draw do
			if EFFECT.Draw[i] then
				Count = Count+1
				DrawPositions[i] = Count
				NewDraw[Count] = EFFECT.Draw[i]
			end
		end
		EFFECT.Draw = NewDraw
		
		local RegisterPositions = {}
		local NewRegister = {}
		Count = {}
		
		for Type,v in pairs(EFFECT.Register) do
			RegisterPositions[Type] = {}
			NewRegister[Type] = {}
			Count[Type] = 0
			for EffectCount=1,#EFFECT.Register[Type] do
				if EFFECT.Register[Type][EffectCount] then
					Count[Type] = Count[Type]+1
					RegisterPositions[Type][EffectCount] = Count[Type]
					NewRegister[Type][Count[Type]] = EFFECT.Register[Type][EffectCount]
					if EFFECT.Register[Type][EffectCount][3] then NewRegister[Type][Count[Type]][3] = DrawPositions[EFFECT.Register[Type][EffectCount][3]] end
				end
			end
		end
		
		local Continue
		for k,v in pairs(Count) do
			if v > 0 then
				Continue = true
				break
			end
		end
		
		if Continue then
			EFFECT.Register = NewRegister
			
			for Index,v1 in pairs(EFFECT.Ents) do if EFFECT.Ents[Index] and EFFECT.Ents[Index][4] then for Type,v2 in pairs(EFFECT.Ents[Index][4]) do if RegisterPositions[Type] then if Type == 1 or Type == 2 or Type == 3 or Type == 4 or Type == 15 or Type == 16 or Type == 17 then for k3,v3 in pairs(v2) do EFFECT.Ents[Index][4][Type][k3] = RegisterPositions[Type][v3] end else EFFECT.Ents[Index][4][Type] = RegisterPositions[Type][v2] end else EFFECT.Ents[Index][4][Type] = nil end end end end
			
			local EntFound
			for k,v in pairs(EFFECT.Ents) do
				if v then
					EntFound = true
					break
				end
			end
			if !EntFound then
				EFFECT.Draw = {}
				EFFECT.Register = {}
				EFFECT.Ents = {}
				if EFFECT.Remove == false then EFFECT.Remove = true end
			end
		else
			for k,v in pairs(EFFECT.Ents) do
				if v then
					local Ent = v[1]
					if IsValid(Ent) then
						Ent:SetColor(v[2])
						Ent:SetRenderMode(v[3])
					end
				end
			end
			EFFECT.Draw = {}
			EFFECT.Register = {}
			EFFECT.Ents = {}
			if EFFECT.Remove == false then EFFECT.Remove = true end
		end
	end
	
	local function RemoveEntFromEffect(Ent,Index,Type,EffectCount)
		if IsValid(Ent) and type(Index) == "number" and EFFECT.Ents[Index] then
			local Found
			local Removed
			for k1,v1 in pairs(EFFECT.Ents[Index][4]) do
				if k1 == Type then
					if type(v1) == "table" then
						for k2,v2 in pairs(v1) do
							if v2 == EffectCount then
								EFFECT.Ents[Index][4][k1][k2] = nil
								if Found then return end
								Removed = true
							else
								if Removed then return end
								Found = true
							end
						end
					else
						EFFECT.Ents[Index][4][k1] = nil
						if Found then return end
						Removed = true
					end
				else
					if type(v1) == "table" then
						for k2,v2 in pairs(v1) do
							if Removed then return end
							Found = true
							break
						end
					else
						if Removed then return end
						Found = true
					end
				end
			end
			if !Found then
				Ent:SetColor(EFFECT.Ents[Index][2])
				Ent:SetRenderMode(EFFECT.Ents[Index][3])
				EFFECT.Ents[Index] = false
			end
		elseif Index then
			EFFECT.Ents[Index] = false
		end
	end
	
	net.Receive("DrawNoCollide",function()
		local String = net.ReadString()
		if String == "0" then
			EFFECT.Draw = {}
			EFFECT.Register = {}
			for k,v in pairs(EFFECT.Ents) do
				if v then
					local Ent = v[1]
					if IsValid(Ent) then
						Ent:SetColor(v[2])
						Ent:SetRenderMode(v[3])
					end
				end
			end
			EFFECT.Ents = {}
			if EFFECT.Remove == false then EFFECT.Remove = true end
		elseif String == "0a" then
			for Type,v1 in pairs(EFFECT.Register) do
				if Type == 1 or Type == 2 or Type == 3 or Type == 4 then
					for EffectCount=1,#EFFECT.Register[Type] do
						if EFFECT.Register[Type][EffectCount] then
							local Ent1Index,Ent2Index = EFFECT.Register[Type][EffectCount][1],EFFECT.Register[Type][EffectCount][2]
							local Ent1
							local Ent2
							if Ent1Index and EFFECT.Ents[Ent1Index] then Ent1 = EFFECT.Ents[Ent1Index][1] end
							if Ent2Index and EFFECT.Ents[Ent2Index] then Ent2 = EFFECT.Ents[Ent2Index][1] end
							if EFFECT.Register[Type][EffectCount][3] and EFFECT.Draw[EFFECT.Register[Type][EffectCount][3]] then EFFECT.Draw[EFFECT.Register[Type][EffectCount][3]] = false end
							RemoveEntFromEffect(Ent1,Ent1Index,Type,EffectCount)
							RemoveEntFromEffect(Ent2,Ent2Index,Type,EffectCount)
							EFFECT.Register[Type][EffectCount] = false
						end
					end
				elseif Type == 5 or Type == 6 or Type == 7 or Type == 8 or Type == 9 or Type == 10 or Type == 11 then
					for EffectCount=1,#EFFECT.Register[Type] do
						if EFFECT.Register[Type][EffectCount] then
							local Ent1Index = EFFECT.Register[Type][EffectCount][1]
							local Ent1
							if Ent1Index and EFFECT.Ents[Ent1Index] then Ent1 = EFFECT.Ents[Ent1Index][1] end
							if EFFECT.Register[Type][EffectCount][3] and EFFECT.Draw[EFFECT.Register[Type][EffectCount][3]] then EFFECT.Draw[EFFECT.Register[Type][EffectCount][3]] = false end
							RemoveEntFromEffect(Ent1,Ent1Index,Type,EffectCount)
							EFFECT.Register[Type][EffectCount] = false
						end
					end
				end
			end
			CleanupTables()
		elseif String == "0b" then
			for Type,v1 in pairs(EFFECT.Register) do
				if Type == 15 or Type == 16 or Type == 17 then
					for EffectCount=1,#EFFECT.Register[Type] do
						if EFFECT.Register[Type][EffectCount] then
							local Ent1Index,Ent2Index = EFFECT.Register[Type][EffectCount][1],EFFECT.Register[Type][EffectCount][2]
							local Ent1
							local Ent2
							if Ent1Index and EFFECT.Ents[Ent1Index] then Ent1 = EFFECT.Ents[Ent1Index][1] end
							if Ent2Index and EFFECT.Ents[Ent2Index] then Ent2 = EFFECT.Ents[Ent2Index][1] end
							if EFFECT.Register[Type][EffectCount][3] and EFFECT.Draw[EFFECT.Register[Type][EffectCount][3]] then EFFECT.Draw[EFFECT.Register[Type][EffectCount][3]] = false end
							RemoveEntFromEffect(Ent1,Ent1Index,Type,EffectCount)
							RemoveEntFromEffect(Ent2,Ent2Index,Type,EffectCount)
							EFFECT.Register[Type][EffectCount] = false
						end
					end
				elseif Type == 12 or Type == 13 or Type == 14 then
					for EffectCount=1,#EFFECT.Register[Type] do
						if EFFECT.Register[Type][EffectCount] then
							local Ent1Index = EFFECT.Register[Type][EffectCount][1]
							local Ent1
							if Ent1Index and EFFECT.Ents[Ent1Index] then Ent1 = EFFECT.Ents[Ent1Index][1] end
							if EFFECT.Register[Type][EffectCount][3] and EFFECT.Draw[EFFECT.Register[Type][EffectCount][3]] then EFFECT.Draw[EFFECT.Register[Type][EffectCount][3]] = false end
							RemoveEntFromEffect(Ent1,Ent1Index,Type,EffectCount)
							EFFECT.Register[Type][EffectCount] = false
						end
					end
				end
			end
			CleanupTables()
		else
			if EFFECT.Remove == nil then util.Effect("render_no_collide", EffectData()) end
			EFFECT.Remove = false
			local Table = string.Explode("_",String)
			if #Table == 2 then
				local Index = tonumber(Table[1])
				if Table[2][1] == "-" then
					local Type = tonumber(string.sub(Table[2],2,string.len(Table[2])))
					if EFFECT.Ents[Index] and EFFECT.Ents[Index][4] and EFFECT.Ents[Index][4][Type] then
						local EffectCount = EFFECT.Ents[Index][4][Type]
						local Ent1
						if Index and EFFECT.Ents[Index] then Ent1 = EFFECT.Ents[Index][1] end
						if EFFECT.Register[Type][EffectCount][3] and EFFECT.Draw[EFFECT.Register[Type][EffectCount][3]] then EFFECT.Draw[EFFECT.Register[Type][EffectCount][3]] = false end
						RemoveEntFromEffect(Ent1,Index,Type,EffectCount)
						EFFECT.Register[Type][EffectCount] = false
						CleanupTables()
					end
				else
					local Type = tonumber(Table[2])
					if !(EFFECT.Ents[Index] and EFFECT.Ents[Index][4] and EFFECT.Ents[Index][4][Type]) then
						local Ent = ents.GetByIndex(Index)
						if IsValid(Ent) then RegisterEffect(Type,Index,Ent) end
					end
				end
			else
				local Ent1Index = math.min(tonumber(Table[1]),tonumber(Table[2]))
				local Ent2Index = math.max(tonumber(Table[1]),tonumber(Table[2]))
				if Table[3][1] == "-" then
					local Type = tonumber(string.sub(Table[3],2,string.len(Table[3])))
					if EFFECT.Ents[Ent1Index] and EFFECT.Ents[Ent2Index] and EFFECT.Ents[Ent1Index][4] and EFFECT.Ents[Ent2Index][4] and EFFECT.Ents[Ent1Index][4][Type] and EFFECT.Ents[Ent2Index][4][Type] then
						local EffectCount
						for k,v in pairs(EFFECT.Ents[Ent1Index][4][Type]) do
							if EFFECT.Register[Type] and EFFECT.Register[Type][v] and EFFECT.Register[Type][v][1] == Ent1Index and EFFECT.Register[Type][v][2] == Ent2Index then
								EffectCount = v
								break
							end
						end
						if !EffectCount then
							for k,v in pairs(EFFECT.Ents[Ent2Index][4][Type]) do
								if EFFECT.Register[Type] and EFFECT.Register[Type][v] and EFFECT.Register[Type][v][1] == Ent1Index and EFFECT.Register[Type][v][2] == Ent2Index then
									EffectCount = v
									break
								end
							end
						end
						if EffectCount then
							local Ent1
							local Ent2
							if Ent1Index and EFFECT.Ents[Ent1Index] then Ent1 = EFFECT.Ents[Ent1Index][1] end
							if Ent2Index and EFFECT.Ents[Ent2Index] then Ent2 = EFFECT.Ents[Ent2Index][1] end
							if EFFECT.Register[Type][EffectCount][3] and EFFECT.Draw[EFFECT.Register[Type][EffectCount][3]] then EFFECT.Draw[EFFECT.Register[Type][EffectCount][3]] = false end
							RemoveEntFromEffect(Ent1,Ent1Index,Type,EffectCount)
							RemoveEntFromEffect(Ent2,Ent2Index,Type,EffectCount)
							EFFECT.Register[Type][EffectCount] = false
							CleanupTables()
						end
					end
				else
					local Type = tonumber(Table[3])
					local NotRegister
					if EFFECT.Ents[Ent1Index] and EFFECT.Ents[Ent2Index] and EFFECT.Ents[Ent1Index][4] and EFFECT.Ents[Ent2Index][4] and EFFECT.Ents[Ent1Index][4][Type] and EFFECT.Ents[Ent2Index][4][Type] then
						for k,v in pairs(EFFECT.Ents[Ent1Index][4][Type]) do
							if EFFECT.Register[Type] and EFFECT.Register[Type][v] and EFFECT.Register[Type][v][1] == Ent1Index and EFFECT.Register[Type][v][2] == Ent2Index then
								NotRegister = true
								break
							end
						end
						if !NotRegister then
							for k,v in pairs(EFFECT.Ents[Ent2Index][4][Type]) do
								if EFFECT.Register[Type] and EFFECT.Register[Type][v] and EFFECT.Register[Type][v][1] == Ent1Index and EFFECT.Register[Type][v][2] == Ent2Index then
									NotRegister = true
									break
								end
							end
						end
					end
					if !NotRegister then
						local Ent1 = ents.GetByIndex(Ent1Index)
						local Ent2 = ents.GetByIndex(Ent2Index)
						if IsValid(Ent1) and IsValid(Ent2) then RegisterEffect(Type,Ent2Index,Ent2,RegisterEffect(Type,Ent1Index,Ent1)) end
					end
				end
			end
		end
	end)
	
	function EFFECT:Init(data) end

	function EFFECT:Think()
		-- This makes the effect always visible.
		local pl = LocalPlayer()
		if IsValid(pl) then
			local Pos = pl:EyePos()
			local Trace = {}
			Trace.start = Pos
			Trace.endpos = Pos+(pl:GetAimVector()*10)
			Trace.filter = {pl}
			local TR = util.TraceLine(Trace)
			self:SetPos(TR.HitPos)
		end
		
		-- Update positions.
		for Type,v in pairs(EFFECT.Register) do
			if EFFECT.Register[Type] then
				if Type == 1 or Type == 2 or Type == 3 or Type == 4 or Type == 15 or Type == 16 or Type == 17 then
					for EffectCount=1,#v do
						if EFFECT.Register[Type] and EFFECT.Register[Type][EffectCount] then
							local Ent1,Ent2
							if v[EffectCount][1] and EFFECT.Ents[v[EffectCount][1]] then Ent1 = EFFECT.Ents[v[EffectCount][1]][1] end
							if v[EffectCount][2] and EFFECT.Ents[v[EffectCount][2]] then Ent2 = EFFECT.Ents[v[EffectCount][2]][1] end
							if IsValid(Ent1) and IsValid(Ent2) then
								if !v[EffectCount][3] then EFFECT.Register[Type][EffectCount][3] = #EFFECT.Draw+1 end
								local DrawID = v[EffectCount][3]
								if !EFFECT.Draw[DrawID] then EFFECT.Draw[DrawID] = {} end
								EFFECT.Draw[DrawID][1] = Ent1:LocalToWorld(Ent1:OBBCenter())
								EFFECT.Draw[DrawID][2] = Ent2:LocalToWorld(Ent2:OBBCenter())
								if !EFFECT.Draw[DrawID][3] then
									if Type == 15 then Type = 1 end
									if Type == 16 then Type = 3 end
									if Type == 17 then Type = 4 end
									EFFECT.Draw[DrawID][3] = Type
								end
							else
								if v[EffectCount][3] and EFFECT.Draw[v[EffectCount][3]] then EFFECT.Draw[v[EffectCount][3]] = false end
								local Ent1Index,Ent2Index = v[EffectCount][1],v[EffectCount][2]
								RemoveEntFromEffect(Ent1,Ent1Index,Type,EffectCount)
								RemoveEntFromEffect(Ent2,Ent2Index,Type,EffectCount)
								EFFECT.Register[Type][EffectCount] = false
								CleanupTables()
							end
						end
					end
				elseif Type == 5 or Type == 6 or Type == 7 or Type == 8 or Type == 12 or Type == 13 or Type == 14 then
					for EffectCount=1,#v do
						if EFFECT.Register[Type] and EFFECT.Register[Type][EffectCount] then
							local Ent1
							if v[EffectCount][1] and EFFECT.Ents[v[EffectCount][1]] then Ent1 = EFFECT.Ents[v[EffectCount][1]][1] end
							if IsValid(Ent1) then
								if !v[EffectCount][3] then EFFECT.Register[Type][EffectCount][3] = #EFFECT.Draw+1 end
								local DrawID = v[EffectCount][3]
								if !EFFECT.Draw[DrawID] then EFFECT.Draw[DrawID] = {} end
								EFFECT.Draw[DrawID][1] = Ent1:LocalToWorld(Ent1:OBBCenter())
								if !EFFECT.Draw[DrawID][3] then
									if Type == 12 then Type = 5 end
									if Type == 13 then Type = 7 end
									if Type == 14 then Type = 8 end
									EFFECT.Draw[DrawID][3] = Type
								end
							else
								if v[EffectCount][3] and EFFECT.Draw[v[EffectCount][3]] then EFFECT.Draw[v[EffectCount][3]] = false end
								if v[EffectCount][1] then EFFECT.Ents[v[EffectCount][1]] = false end
								EFFECT.Register[Type][EffectCount] = false
								CleanupTables()
							end
						end
					end
				else
					for EffectCount=1,#v do
						if EFFECT.Register[Type] and EFFECT.Register[Type][EffectCount] then
							local Ent1
							if v[EffectCount][1] and EFFECT.Ents[v[EffectCount][1]] then Ent1 = EFFECT.Ents[v[EffectCount][1]][1] end
							if IsValid(Ent1) then
								if !v[EffectCount][3] then EFFECT.Register[Type][EffectCount][3] = #EFFECT.Draw+1 end
								local DrawID = v[EffectCount][3]
								if !EFFECT.Draw[DrawID] then EFFECT.Draw[DrawID] = {} end
								EFFECT.Draw[DrawID][3] = Type
								EFFECT.Draw[DrawID][4] = Ent1
							else
								if v[EffectCount][3] and EFFECT.Draw[v[EffectCount][3]] then EFFECT.Draw[v[EffectCount][3]] = false end
								if v[EffectCount][1] then EFFECT.Ents[v[EffectCount][1]] = false end
								EFFECT.Register[Type][EffectCount] = false
								CleanupTables()
							end
						end
					end
				end
			end
		end
		
		-- Set alpha to 100.
		for k,v in pairs(EFFECT.Ents) do
			if v then
				local Ent = v[1]
				if IsValid(Ent) then
					local Col = Ent:GetColor()
					Col["a"] = 100
					Ent:SetRenderMode(1)
					Ent:SetColor(Col)
				end
			end
		end
		
		return true
	end

	local DrawLine = Material("effects/render_vector")
	
	function EFFECT:Render()
		render.SetMaterial(DrawLine)
		for i=1,#EFFECT.Draw do
			if EFFECT.Draw[i] then
				if EFFECT.Draw[i][3] == 1 then
					render.DrawBeam(EFFECT.Draw[i][1], EFFECT.Draw[i][2], 16, 0.2, 0.8, Color(255, 255, 255, 255))
				elseif EFFECT.Draw[i][3] == 2 then
					render.DrawBeam(EFFECT.Draw[i][1], EFFECT.Draw[i][2], 16, 0.2, 0.8, Color(100, 255, 100, 255))
				elseif EFFECT.Draw[i][3] == 3 then
					render.DrawBeam(EFFECT.Draw[i][1], EFFECT.Draw[i][2], 16, 0.2, 0.8, Color(255, 50, 50, 255))
				elseif EFFECT.Draw[i][3] == 4 then
					render.DrawBeam(EFFECT.Draw[i][1], EFFECT.Draw[i][2], 16, 0.2, 0.8, Color(50, 50, 255, 255))
				elseif EFFECT.Draw[i][3] == 5 then
					render.DrawBeam(EFFECT.Draw[i][1], EFFECT.Draw[i][1]+Vector(0,0,-100), 32, 0.2, 0.8, Color(255, 255, 255, 255))
				elseif EFFECT.Draw[i][3] == 6 then
					render.DrawBeam(EFFECT.Draw[i][1], EFFECT.Draw[i][1]+Vector(0,0,-100), 32, 0.2, 0.8, Color(255, 150, 50, 255))
				elseif EFFECT.Draw[i][3] == 7 then
					render.DrawBeam(EFFECT.Draw[i][1], EFFECT.Draw[i][1]+Vector(0,0,-100), 32, 0.2, 0.8, Color(255, 50, 50, 255))
				elseif EFFECT.Draw[i][3] == 8 then
					render.DrawBeam(EFFECT.Draw[i][1], EFFECT.Draw[i][1]+Vector(0,0,-100), 32, 0.2, 0.8, Color(50, 50, 255, 255))
				elseif EFFECT.Draw[i][3] == 9 then
					halo.Add({EFFECT.Draw[i][4]}, Color(255, 255, 255, 255), 10, 10, 1, true, false)
				elseif EFFECT.Draw[i][3] == 10 then
					halo.Add({EFFECT.Draw[i][4]}, Color(255, 150, 50, 255), 10, 10, 1, true, false)
				elseif EFFECT.Draw[i][3] == 11 then
					halo.Add({EFFECT.Draw[i][4]}, Color(100, 255, 100, 255), 10, 10, 1, true, false)
				end
			end
		end
	end

	effects.Register(EFFECT,"render_no_collide",true)
end

local function ExtractEntities(Entity, Entities, Constraints, Ignore)
	Constraints = Constraints or {}
	Entities = Entities or {}
	if !Entity:IsValid() and Entity != game.GetWorld() then return Entities, Constraints end
	local Index = Entity:EntIndex()
	Entities[Index] = Entity
	if !constraint.HasConstraints(Entity) then return Entities, Constraints end
	
	for k1, v1 in pairs(constraint.GetTable(Entity)) do
		if !(Ignore and v1["Type"] and (v1["Type"] == "NoCollideWorld" or v1["Type"] == "NoCollide")) then
			local Index = v1.Constraint
			if !Constraints[Index] then
				Constraints[Index] = v1.Constraint
				for k2, v2 in pairs(v1.Entity) do
					local Ents, Cons = ExtractEntities(v2.Entity, Entities, Constraints, Ignore)
					table.Merge(Entities, Ents)
					table.Merge(Constraints, Cons)
				end
			end
		end
	end
	
	return Entities, Constraints
end

local SendToClient2 = {}
local SendDone2 = {}

function TOOL:LeftClick(trace)
	local pl = self:GetOwner()
	if !IsValid(pl) then return end
	if !trace.Entity then return end
	if trace.Entity:IsPlayer() then return end
	
	if SERVER then
		if self.Hold then self.Hold[pl] = false end
		if self.AimEnt then self.AimEnt[pl] = nil end
	end
	
	local Option = self:GetClientNumber("options")
	
	if Option == 1 then	--	Like default no collide
		if SERVER and !trace.Entity:IsValid() and trace.Entity != game.GetWorld() then return end
		local iNum = self:NumObjects()
		local Phys = trace.Entity:GetPhysicsObjectNum(trace.PhysicsBone)
		self:SetObject(iNum+1, trace.Entity, trace.HitPos, Phys, trace.PhysicsBone, trace.HitNormal)
		if CLIENT then
			if iNum > 0 then self:ClearObjects() end
			return true
		end
		if iNum > 0 then
			local Ent1,  Ent2  = self:GetEnt(1), self:GetEnt(2)
			local Bone1, Bone2 = self:GetBone(1), self:GetBone(2)
			
			if Ent1 == game.GetWorld() then
				Ent1 = Ent2
				Ent2 = game.GetWorld()
			end
			if Ent1:GetTable().Constraints then
				for k, v in pairs(Ent1:GetTable().Constraints) do
					if v:IsValid() then
						local CTab = v:GetTable()
						if CTab.Type == "NoCollideWorld" and ((CTab.Ent1 == Ent1 and CTab.Ent2 == Ent2) or (CTab.Ent2 == Ent1 and CTab.Ent1 == Ent2)) then
							self:ClearObjects()
							v:Remove()
							return true
						end
					end	
				end
			end
			
			local Const = constraint.NoCollideWorld(Ent1, Ent2, Bone1, Bone2)
			
			if IsValid(Const) then
				undo.Create("No Collide World, Default")
				undo.AddEntity(Const)
				undo.AddFunction(function(Undo, Tool, pl)
					if Tool and pl and pl:IsValid() then
						if Tool.Hold then Tool.Hold[pl] = false end
						if Tool.AimEnt then Tool.AimEnt[pl] = nil end
					end
				end, self,pl)
				undo.SetPlayer(pl)
				undo.SetCustomUndoText("Undone No Collide World, Default")
				undo.Finish()
				self:ClearObjects()
				return true
			end
			self:ClearObjects()
		else
			self:SetStage(iNum+1)
			return true
		end
	elseif Option == 2 then	--	No collide world only
		if !trace.Entity:IsValid() then return end
		if CLIENT then return true end
		
		if trace.Entity:GetTable().Constraints then
			for k, v in pairs(trace.Entity:GetTable().Constraints) do
				if v:IsValid() then
					local CTab = v:GetTable()
					if CTab.Type == "NoCollideWorld" and CTab.Ent1 == trace.Entity and CTab.Ent2 == game.GetWorld() then
						v:Remove()
						return true
					end
				end	
			end
		end
		
		local Const = constraint.NoCollideWorld(trace.Entity, game.GetWorld(), trace.PhysicsBone, 0)
		if IsValid(Const) then
			undo.Create("No Collide World, World Only")
			undo.AddEntity(Const)
			undo.AddFunction(function(Undo, Tool, pl)
				if Tool and pl and pl:IsValid() then
					if Tool.Hold then Tool.Hold[pl] = false end
					if Tool.AimEnt then Tool.AimEnt[pl] = nil end
				end
			end, self,pl)
			undo.SetPlayer(pl)
			undo.SetCustomUndoText("Undone No Collide World, World Only")
			undo.Finish()
			return true
		end
	elseif Option == 3 then	--	Select all constrained
		if SERVER and !trace.Entity:IsValid() and trace.Entity != game.GetWorld() then return end
		if CLIENT then return true end
		local iNum = self:GetStage()
		local Entities = ExtractEntities(trace.Entity,nil,nil,tobool(self:GetClientNumber("ignore")))
		if self.Ents1 and Entities and iNum == 4 then
			local UndoTable = {}
			for k1, Ent1 in pairs(self.Ents1) do
				if Ent1:IsValid() or Ent1 == game.GetWorld() then
					for k2, Ent2 in pairs(Entities) do
						if (Ent2:IsValid() or Ent2 == game.GetWorld()) and Ent1 != Ent2 then
							local Const = constraint.NoCollideWorld(Ent1, Ent2, 0, 0)
							if IsValid(Const) then UndoTable[#UndoTable+1] = Const end
						end
					end
				end
			end
			if #UndoTable == 0 then
				self.Ents1 = nil
				self:SetStage(3)
				return
			end
			undo.Create("No Collide World, Select all constrained")
			for i=1,#UndoTable do undo.AddEntity(UndoTable[i]) end
			undo.AddFunction(function(Undo, Tool, pl)
				if Tool and pl and pl:IsValid() then
					if Tool.Hold then Tool.Hold[pl] = false end
					if Tool.AimEnt then Tool.AimEnt[pl] = nil end
				end
			end, self,pl)
			undo.SetPlayer(pl)
			undo.SetCustomUndoText("Undone No Collide World, Select all constrained")
			undo.Finish()
			self.Ents1 = nil
			self:SetStage(3)
			return true 
		else
			self.Ents1 = Entities
			self:SetStage(4)
			return true 
		end
	elseif Option == 4 then	--	To all constrained
		if !trace.Entity:IsValid() then return end
		if CLIENT then return true end
		local Entities = ExtractEntities(trace.Entity,nil,nil,tobool(self:GetClientNumber("ignore")))
		if Entities then
			local UndoTable = {}
			for k1, Ent1 in pairs(Entities) do
				for k2, Ent2 in pairs(Entities) do
					if Ent1:IsValid() and Ent2:IsValid() and Ent1 != Ent2 then
						local Const = constraint.NoCollideWorld(Ent1, Ent2, 0, 0)
						if IsValid(Const) then UndoTable[#UndoTable+1] = Const end
					end
				end
			end
			if #UndoTable == 0 then return end
			undo.Create("No Collide World, To All Constrained")
			for i=1,#UndoTable do undo.AddEntity(UndoTable[i]) end
			undo.AddFunction(function(Undo, Tool, pl)
				if Tool and pl and pl:IsValid() then
					if Tool.Hold then Tool.Hold[pl] = false end
					if Tool.AimEnt then Tool.AimEnt[pl] = nil end
				end
			end, self,pl)
			undo.SetPlayer(pl)
			undo.SetCustomUndoText("Undone No Collide World, To All Constrained")
			undo.Finish()
			return true 
		end
	elseif Option == 5 then	--	No collide player only
		if !trace.Entity:IsValid() then return end
		if CLIENT then return true end
		
		if trace.Entity:GetCollisionGroup() == COLLISION_GROUP_WEAPON then
			trace.Entity:SetCollisionGroup(COLLISION_GROUP_NONE)
			if IsValid(trace.Entity.NocollideDummy) then trace.Entity.NocollideDummy:Remove() end
			return true
		else
			trace.Entity:SetCollisionGroup(COLLISION_GROUP_WEAPON)
			
			undo.Create("Undone No Collide World, Player Only")
			local Dummy = ents.Create("info_null")
			if !trace.Entity.UndoNoCollidePlayer then trace.Entity:CallOnRemove("UndoNoCollidePlayer"..trace.Entity:EntIndex(),function(Ent) if Ent.NocollideDummy and Ent.NocollideDummy:IsValid() then Ent.NocollideDummy:Remove() end end,trace.Entity) end
			trace.Entity.UndoNoCollidePlayer = true
			trace.Entity.NocollideDummy = Dummy
			undo.AddEntity(Dummy)
			
			undo.AddFunction(function(Undo, Ent, Tool, pl)
				if Tool and pl and pl:IsValid() then
					if Tool.Hold then Tool.Hold[pl] = false end
					if Tool.AimEnt then Tool.AimEnt[pl] = nil end
				end
				if Ent and Ent:IsValid() then Ent:SetCollisionGroup(COLLISION_GROUP_NONE) end
			end, trace.Entity,self,pl)
			undo.SetPlayer(pl)
			undo.SetCustomUndoText("Undone No Collide World, Player Only")
			undo.Finish()
			return true
		end
	elseif Option == 6 then	--	No collide within box
		if !trace.Entity:IsValid() then return end
		if CLIENT then return true end
		local Distance = self:GetClientNumber("distance")
		local AddVector = Vector(Distance,Distance,Distance)
		local UndoTable = {}
		for k,v in pairs(ents.FindInBox(trace.Entity:LocalToWorld(trace.Entity:OBBMins()-AddVector), trace.Entity:LocalToWorld(trace.Entity:OBBMaxs()+AddVector))) do
			if v:IsValid() and v != trace.Entity and !v:IsPlayer() then
				local Const = constraint.NoCollideWorld(trace.Entity, v, 0, 0)
				if IsValid(Const) then UndoTable[#UndoTable+1] = Const end
			end
		end
		if #UndoTable == 0 then return end
		undo.Create("No Collide World, Within Box")
		for i=1,#UndoTable do undo.AddEntity(UndoTable[i]) end
		undo.AddFunction(function(Undo, Tool, pl)
			if Tool and pl and pl:IsValid() then
				if Tool.Hold then Tool.Hold[pl] = false end
				if Tool.AimEnt then Tool.AimEnt[pl] = nil end
			end
		end, self,pl)
		undo.SetPlayer(pl)
		undo.SetCustomUndoText("Undone No Collide World, Within Box")
		undo.Finish()
		return true
	elseif Option == 7 then	--	No collide within sphere
		if !trace.Entity:IsValid() then return end
		if CLIENT then return true end
		local Distance = self:GetClientNumber("distance")
		local UndoTable = {}
		for k,v in pairs(ents.FindInSphere(trace.Entity:LocalToWorld(trace.Entity:OBBCenter()), (trace.Entity:OBBMaxs()/2):Length()+Distance)) do
			if v:IsValid() and v != trace.Entity and !v:IsPlayer() then
				local Const = constraint.NoCollideWorld(trace.Entity, v, 0, 0)
				if IsValid(Const) then UndoTable[#UndoTable+1] = Const end
			end
		end
		if #UndoTable == 0 then return end
		undo.Create("No Collide World, Within Sphere")
		for i=1,#UndoTable do undo.AddEntity(UndoTable[i]) end
		undo.AddFunction(function(Undo, Tool, pl)
			if Tool and pl and pl:IsValid() then
				if Tool.Hold then Tool.Hold[pl] = false end
				if Tool.AimEnt then Tool.AimEnt[pl] = nil end
			end
		end, self,pl)
		undo.SetPlayer(pl)
		undo.SetCustomUndoText("Undone No Collide World, Within Sphere")
		undo.Finish()
		return true
	elseif Option == 8 then	--	No collide within box all constrained
		if !trace.Entity:IsValid() then return end
		if CLIENT then return true end
		local Distance = self:GetClientNumber("distance")
		local AddVector = Vector(Distance,Distance,Distance)
		local Entities = ExtractEntities(trace.Entity,nil,nil,tobool(self:GetClientNumber("ignore")))
		if Entities then
			local UndoTable = {}
			for k1, Ent1 in pairs(Entities) do
				if Ent1:IsValid() and !Ent1:IsPlayer() then
					for k,v in pairs(ents.FindInBox(Ent1:LocalToWorld(Ent1:OBBMins()-AddVector), Ent1:LocalToWorld(Ent1:OBBMaxs()+AddVector))) do
						if v:IsValid() and v != Ent1 and !v:IsPlayer() then
							local Const = constraint.NoCollideWorld(Ent1, v, 0, 0)
							if IsValid(Const) then UndoTable[#UndoTable+1] = Const end
						end
					end
				end
			end
			if #UndoTable == 0 then return end
			undo.Create("No Collide World, Within Box All Constrained")
			for i=1,#UndoTable do undo.AddEntity(UndoTable[i]) end
			undo.AddFunction(function(Undo, Tool, pl)
				if Tool and pl and pl:IsValid() then
					if Tool.Hold then Tool.Hold[pl] = false end
					if Tool.AimEnt then Tool.AimEnt[pl] = nil end
				end
			end, self,pl)
			undo.SetPlayer(pl)
			undo.SetCustomUndoText("Undone No Collide World, Within Box All Constrained")
			undo.Finish()
			return true
		end
	elseif Option == 9 then	--	No collide within sphere all constrained
		if !trace.Entity:IsValid() then return end
		if CLIENT then return true end
		local Distance = self:GetClientNumber("distance")
		local Entities = ExtractEntities(trace.Entity,nil,nil,tobool(self:GetClientNumber("ignore")))
		if Entities then
			local UndoTable = {}
			for k1, Ent1 in pairs(Entities) do
				if Ent1:IsValid() and !Ent1:IsPlayer() then
					for k,v in pairs(ents.FindInSphere(Ent1:LocalToWorld(Ent1:OBBCenter()), (Ent1:OBBMaxs()/2):Length()+Distance)) do
						if v:IsValid() and v != Ent1 and !v:IsPlayer() then
							local Const = constraint.NoCollideWorld(Ent1, v, 0, 0)
							if IsValid(Const) then UndoTable[#UndoTable+1] = Const end
						end
					end
				end
			end
			if #UndoTable == 0 then return end
			undo.Create("No Collide World, Within Sphere All Constrained")
			for i=1,#UndoTable do undo.AddEntity(UndoTable[i]) end
			undo.SetPlayer(pl)
			undo.SetCustomUndoText("Undone No Collide World, Within Sphere All Constrained")
			undo.Finish()
			return true
		end
	elseif Option == 10 then	--	To all selected entities
		if CLIENT then return true end
		if SERVER and !trace.Entity:IsValid() and trace.Entity != game.GetWorld() then return end
		local EntityIndex = trace.Entity:EntIndex()
		if !SendDone2[pl] then SendDone2[pl] = 0 end
		if !SendToClient2[pl] then SendToClient2[pl] = {} end
		
		if !self.TASE then
			self.TASE = {}
			self.TASE[1] = {}
			self.TASE[2] = {}
			self.TASE[3] = {}
			--[[
			self.TASE[1][Index][Count] = Do count
			
			self.TASE[2][Low index][High index] = 1 = create, 2 = remove, 3 = ignore
			
			self.TASE[3][Do count][1] = Low index
			self.TASE[3][Do count][2] = High index
			]]
		end
		
		local function NocollideFind(Ent1, Ent2)
			if Ent1 == game.GetWorld() then
				Ent1 = Ent2
				Ent2 = game.GetWorld()
			end
			if !IsValid(Ent1) then return end
			if !Ent1:GetTable().Constraints then return end
			for k, v in pairs(Ent1:GetTable().Constraints) do
				if v:IsValid() then
					local CTab = v:GetTable()
					if (CTab.Type == "NoCollideWorld" or CTab.Type == "NoCollide") and ((CTab.Ent1 == Ent1 and CTab.Ent2 == Ent2) or (CTab.Ent2 == Ent1 and CTab.Ent1 == Ent2)) then return v,CTab.Type end
				end	
			end
			return
		end
		
		local function RemoveObject(Index)
			for i1=1,#self.TASE[1][Index] do
				local DoC = self.TASE[1][Index][i1]
				if DoC and self.TASE[3][DoC] then
					local LIndex = self.TASE[3][DoC][1]
					local HIndex = self.TASE[3][DoC][2]
					if self.TASE[2][LIndex] and self.TASE[2][LIndex][HIndex] then
						local SendC = #SendToClient2[pl]+1
						SendToClient2[pl][SendC] = {}
						if LIndex == 0 then
							if self.TASE[2][LIndex][HIndex] == 1 then
								SendToClient2[pl][SendC][1] = HIndex
								SendToClient2[pl][SendC][3] = -12
							elseif self.TASE[2][LIndex][HIndex] == 2 then
								SendToClient2[pl][SendC][1] = HIndex
								SendToClient2[pl][SendC][3] = -13
							else
								SendToClient2[pl][SendC][1] = HIndex
								SendToClient2[pl][SendC][3] = -14
							end
						elseif HIndex == 0 then
							if self.TASE[2][LIndex][HIndex] == 1 then
								SendToClient2[pl][SendC][1] = LIndex
								SendToClient2[pl][SendC][3] = -12
							elseif self.TASE[2][LIndex][HIndex] == 2 then
								SendToClient2[pl][SendC][1] = LIndex
								SendToClient2[pl][SendC][3] = -13
							else
								SendToClient2[pl][SendC][1] = LIndex
								SendToClient2[pl][SendC][3] = -14
							end
						else
							if self.TASE[2][LIndex][HIndex] == 1 then
								SendToClient2[pl][SendC][1] = LIndex
								SendToClient2[pl][SendC][2] = HIndex
								SendToClient2[pl][SendC][3] = -15
							elseif self.TASE[2][LIndex][HIndex] == 2 then
								SendToClient2[pl][SendC][1] = LIndex
								SendToClient2[pl][SendC][2] = HIndex
								SendToClient2[pl][SendC][3] = -16
							else
								SendToClient2[pl][SendC][1] = LIndex
								SendToClient2[pl][SendC][2] = HIndex
								SendToClient2[pl][SendC][3] = -17
							end
						end
						self.TASE[2][LIndex][HIndex] = nil
					end
					self.TASE[3][DoC] = false
					for i2=1,#self.TASE[1][HIndex] do if !self.TASE[3][self.TASE[1][HIndex][i2]] then self.TASE[1][HIndex][i2] = false end end
					for i2=1,#self.TASE[1][LIndex] do if !self.TASE[3][self.TASE[1][LIndex][i2]] then self.TASE[1][LIndex][i2] = false end end
				end
			end
			self.TASE[1][Index] = false
			local Translate = {}
			local New = {}
			local Count = 0
			for i1=1,#self.TASE[3] do
				if self.TASE[3][i1] then
					Count = Count+1
					Translate[i1] = Count
					local LIndex = self.TASE[3][i1][1]
					local HIndex = self.TASE[3][i1][2]
					New[Count] = self.TASE[3][i1]
				end
			end
			self.TASE[3] = New
			for k,v in pairs(self.TASE[1]) do
				if v then
					self.TASE[1][k] = {}
					local Count = 0
					for i=1,#v do
						if v[i] and self.TASE[3][Translate[v[i]]] then
							Count = Count+1
							self.TASE[1][k][Count] = Translate[v[i]]
						end
					end
				end
			end
		end
		
		if self.TASE[1][EntityIndex] then
			RemoveObject(EntityIndex)
			return true
		else
			self.TASE[1][EntityIndex] = {}
		end
		
		if tobool(self:GetClientNumber("remove")) then
			for k,v in pairs(self.TASE[1]) do
				if k != EntityIndex and self.TASE[1][EntityIndex] and self.TASE[1][k] then
					local Ent2
					if k == 0 then Ent2 = game.GetWorld() else Ent2 = ents.GetByIndex(k) end
					local Nocollide, Type = NocollideFind(trace.Entity, Ent2)
					if Type == "NoCollideWorld" then
						local SendC = #SendToClient2[pl]+1
						SendToClient2[pl][SendC] = {}
						if EntityIndex == 0 then
							SendToClient2[pl][SendC][1] = k
							SendToClient2[pl][SendC][3] = 13
						elseif k == 0 then
							SendToClient2[pl][SendC][1] = EntityIndex
							SendToClient2[pl][SendC][3] = 13
						else
							SendToClient2[pl][SendC][1] = k
							SendToClient2[pl][SendC][2] = EntityIndex
							SendToClient2[pl][SendC][3] = 16
						end
						local LIndex = math.min(k,EntityIndex)
						local HIndex = math.max(k,EntityIndex)
						local DoC = #self.TASE[3]+1
						self.TASE[1][LIndex][#self.TASE[1][LIndex]+1] = DoC
						self.TASE[1][HIndex][#self.TASE[1][HIndex]+1] = DoC
						
						if !self.TASE[2][LIndex] then self.TASE[2][LIndex] = {} end
						self.TASE[2][LIndex][HIndex] = 2
						
						self.TASE[3][DoC] = {}
						self.TASE[3][DoC][1] = LIndex
						self.TASE[3][DoC][2] = HIndex
					elseif !Nocollide then
						local SendC = #SendToClient2[pl]+1
						SendToClient2[pl][SendC] = {}
						if EntityIndex == 0 then
							SendToClient2[pl][SendC][1] = k
							SendToClient2[pl][SendC][3] = 14
						elseif k == 0 then
							SendToClient2[pl][SendC][1] = EntityIndex
							SendToClient2[pl][SendC][3] = 14
						else
							SendToClient2[pl][SendC][1] = k
							SendToClient2[pl][SendC][2] = EntityIndex
							SendToClient2[pl][SendC][3] = 17
						end
						local LIndex = math.min(k,EntityIndex)
						local HIndex = math.max(k,EntityIndex)
						local DoC = #self.TASE[3]+1
						self.TASE[1][LIndex][#self.TASE[1][LIndex]+1] = DoC
						self.TASE[1][HIndex][#self.TASE[1][HIndex]+1] = DoC
						
						if !self.TASE[2][LIndex] then self.TASE[2][LIndex] = {} end
						self.TASE[2][LIndex][HIndex] = 3
						
						self.TASE[3][DoC] = {}
						self.TASE[3][DoC][1] = LIndex
						self.TASE[3][DoC][2] = HIndex
					end
				end
			end
		else
			for k,v in pairs(self.TASE[1]) do
				if k != EntityIndex and self.TASE[1][EntityIndex] and self.TASE[1][k] then
					local Ent2
					if k == 0 then Ent2 = game.GetWorld() else Ent2 = ents.GetByIndex(k) end
					if !NocollideFind(trace.Entity, Ent2) then
						local SendC = #SendToClient2[pl]+1
						SendToClient2[pl][SendC] = {}
						if EntityIndex == 0 then
							SendToClient2[pl][SendC][1] = k
							SendToClient2[pl][SendC][3] = 12
						elseif k == 0 then
							SendToClient2[pl][SendC][1] = EntityIndex
							SendToClient2[pl][SendC][3] = 12
						else
							SendToClient2[pl][SendC][1] = k
							SendToClient2[pl][SendC][2] = EntityIndex
							SendToClient2[pl][SendC][3] = 15
						end
						local LIndex = math.min(k,EntityIndex)
						local HIndex = math.max(k,EntityIndex)
						local DoC = #self.TASE[3]+1
						self.TASE[1][LIndex][#self.TASE[1][LIndex]+1] = DoC
						self.TASE[1][HIndex][#self.TASE[1][HIndex]+1] = DoC
						
						if !self.TASE[2][LIndex] then self.TASE[2][LIndex] = {} end
						self.TASE[2][LIndex][HIndex] = 1
						
						self.TASE[3][DoC] = {}
						self.TASE[3][DoC][1] = LIndex
						self.TASE[3][DoC][2] = HIndex
					end
				end
			end
		end
		return true
	end
end

function TOOL:RightClick(trace)
	if self:GetClientNumber("options") == 10 then
		if CLIENT then return true end
		if !self.TASE or !self.TASE[3] then return end
		local pl = self:GetOwner()
		if !IsValid(pl) then return end
		if self.Hold then self.Hold[pl] = false end
		if self.AimEnt then self.AimEnt[pl] = nil end
		SendDone2[pl] = 0
		SendToClient2[pl] = {}
		net.Start("DrawNoCollide")
		net.WriteString("0b")
		net.Send(pl)
		
		local UndoTable = {}
		local Ents = {}
		local DidRemove
		
		for i=1,#self.TASE[3] do
			if self.TASE[3][i] then
				local LIndex = self.TASE[3][i][1]
				local HIndex = self.TASE[3][i][2]
				if Ents[LIndex] == nil then
					if LIndex == 0 then
						Ents[LIndex] = game.GetWorld()
					else
						local Ent = ents.GetByIndex(LIndex)
						if IsValid(Ent) or Ent == game.GetWorld() then Ents[LIndex] = Ent else Ents[LIndex] = false end
					end
				end
				if Ents[HIndex] == nil then
					if HIndex == 0 then
						Ents[HIndex] = game.GetWorld()
					else
						local Ent = ents.GetByIndex(HIndex)
						if IsValid(Ent) or Ent == game.GetWorld() then Ents[HIndex] = Ent else Ents[HIndex] = false end
					end
				end
				if Ents[LIndex] and Ents[HIndex] then
					if self.TASE[2][LIndex][HIndex] == 1 then
						local Const = constraint.NoCollideWorld(Ents[LIndex], Ents[HIndex], 0, 0)
						if IsValid(Const) then UndoTable[#UndoTable+1] = Const end
					elseif self.TASE[2][LIndex][HIndex] == 2 then
						local Ent1 = Ents[LIndex]
						local Ent2 = Ents[HIndex]
						if Ent1 == game.GetWorld() then
							Ent1 = Ent2
							Ent2 = game.GetWorld()
						end
						if Ent1:GetTable().Constraints then
							for k, v in pairs(Ent1:GetTable().Constraints) do
								if v:IsValid() then
									local CTab = v:GetTable()
									if CTab.Type == "NoCollideWorld" and ((CTab.Ent1 == Ent1 and CTab.Ent2 == Ent2) or (CTab.Ent2 == Ent1 and CTab.Ent1 == Ent2)) then
										DidRemove = true
										v:Remove()
										break
									end
								end	
							end
						end
					end
				end
			end
		end
		
		self.TASE = nil
		
		if #UndoTable == 0 then if DidRemove then return true else return end end
		undo.Create("No Collide World, To All Selected Entities")
		for i=1,#UndoTable do undo.AddEntity(UndoTable[i]) end
		undo.SetPlayer(pl)
		undo.SetCustomUndoText("Undone No Collide World, To All Selected Entities")
		undo.Finish()
		return true
	else
		if !trace.Entity then return end
		if !trace.Entity:IsValid() then return end
		if trace.Entity:IsPlayer() then return end
		if CLIENT then return true end
		
		local pl = self:GetOwner()
		if !IsValid(pl) then return end
		if self.Hold then self.Hold[pl] = false end
		if self.AimEnt then self.AimEnt[pl] = nil end
		
		if trace.Entity:GetCollisionGroup() == COLLISION_GROUP_WORLD then
			trace.Entity:SetCollisionGroup(COLLISION_GROUP_NONE)
			if trace.Entity.Nocollide and trace.Entity.Nocollide:IsValid() then trace.Entity.Nocollide:Remove() end
			return true
		else
			local function NocollideFind(Ent1, Ent2)
				if !Ent1:GetTable().Constraints then return end
				for k, v in pairs(Ent1:GetTable().Constraints) do
					if v:IsValid() then
						local CTab = v:GetTable()
						if (CTab.Type == "NoCollideWorld" or CTab.Type == "NoCollide") and ((CTab.Ent1 == Ent1 and CTab.Ent2 == Ent2) or (CTab.Ent2 == Ent1 and CTab.Ent1 == Ent2)) then return v end
					end	
				end
				return
			end
			local Const = NocollideFind(trace.Entity, game.GetWorld())
			if IsValid(Const) then
				Const:Remove()
				Const = NULL
			end
			Const = constraint.NoCollideWorld(trace.Entity, game.GetWorld(), trace.PhysicsBone, 0)
			if IsValid(Const) then
				pl:AddCount("nocollide_world", Const)
				trace.Entity:SetCollisionGroup(COLLISION_GROUP_WORLD)
				trace.Entity.Nocollide = Const
				if IsValid(trace.Entity.NocollideDummy) then trace.Entity.NocollideDummy:Remove() end
				
				undo.Create("No Collide World, Disable Collisions")
				undo.AddEntity(Const)
				undo.AddFunction(function(Undo, Ent, Tool, pl)
					if Tool and pl and pl:IsValid() then
						if Tool.Hold then Tool.Hold[pl] = false end
						if Tool.AimEnt then Tool.AimEnt[pl] = nil end
					end
					if Ent and Ent:IsValid() and !IsValid(Ent.NocollideDummy) then Ent:SetCollisionGroup(COLLISION_GROUP_NONE) end
				end, trace.Entity,self,pl)
				undo.SetPlayer(pl)
				undo.SetCustomUndoText("Undone No Collide World, Disable Collisions")
				undo.Finish()
				return true
			end
		end
	end
end

function TOOL:Reload()
	if CLIENT then return true end
	local pl = self:GetOwner()
	if !self.Hold then self.Hold = {} end
	if !IsValid(pl) then return end
	self.Hold[pl] = !self.Hold[pl]
end

local SendToClient = {}
local SendDone = {}

function TOOL:Think()
	if CLIENT then return end
	local Option = self:GetClientNumber("options")
	local Stage = self:GetStage()
	if Option == 1 and Stage != 0 and Stage != 1 then self:SetStage(0) elseif Option == 2 and Stage != 2 then self:SetStage(2) elseif Option == 3 and Stage != 3 and Stage != 4 then self:SetStage(3) elseif Option == 4 and Stage != 5 then self:SetStage(5) elseif Option == 5 and Stage != 6 then self:SetStage(6) elseif Option == 6 and Stage != 7 then self:SetStage(7) elseif Option == 7 and Stage != 8 then self:SetStage(8) elseif Option == 8 and Stage != 5 then self:SetStage(5) elseif Option == 9 and Stage != 5 then self:SetStage(5) elseif Option == 10 and Stage != 9 then self:SetStage(9) end
	
	local pl = self:GetOwner()
	if !IsValid(pl) then return end
	if !SendDone[pl] then SendDone[pl] = 0 end
	if !SendToClient[pl] then SendToClient[pl] = {} end
	if !self.AimEnt then self.AimEnt = {} end
	if !self.Hold then self.Hold = {} end
	if Option != self.OldOption then
		self.OldOption = Option
		self:ClearObjects()
		SendDone[pl] = 0
		self.AimEnt[pl] = nil
		SendToClient[pl] = {}
		self.TASE = nil
		net.Start("DrawNoCollide")
		net.WriteString("0")
		net.Send(pl)
	end
	if !self.Hold[pl] then 
		local trace = pl:GetEyeTrace()
		if !tobool(self:GetClientNumber("effect")) and trace.Entity and trace.Entity:IsValid() and !trace.Entity:IsPlayer() then
			if trace.Entity != self.AimEnt[pl] or Option != self.OldOption then
				self.OldOption = Option
				Stage = self:GetStage()
				SendDone[pl] = 0
				SendToClient[pl] = {}
				net.Start("DrawNoCollide")
				net.WriteString("0a")
				net.Send(pl)
				local TraceEntityIndex = trace.Entity:EntIndex()
				local Ignore
				local ToolEnt1 = self:GetEnt(1)
				local function NocollideFind(Ent1, Ent2)
					if Ent1 == game.GetWorld() then
						Ent1 = Ent2
						Ent2 = game.GetWorld()
					end
					if !Ent1:GetTable().Constraints then return end
					for k, v in pairs(Ent1:GetTable().Constraints) do
						if v:IsValid() then
							local CTab = v:GetTable()
							if (CTab.Type == "NoCollideWorld" or CTab.Type == "NoCollide") and ((CTab.Ent1 == Ent1 and CTab.Ent2 == Ent2) or (CTab.Ent2 == Ent1 and CTab.Ent1 == Ent2)) then return v end
						end	
					end
					return
				end
				if Option == 1 or Option == 2 or Option == 3 or Option == 5 or Option == 10 then
					local AllEnts = {}
					AllEnts[TraceEntityIndex] = true
					if constraint.HasConstraints(trace.Entity) and Stage != 4 then
						local Cons = constraint.GetTable(trace.Entity)
						for i=1,#Cons do
							if Cons[i]["Type"] == "NoCollideWorld" or Cons[i]["Type"] == "NoCollide" then
								local Ent1Index
								local Ent2Index
								if Cons[i]["Entity"] then
									if Cons[i]["Entity"][1] then Ent1Index = Cons[i]["Entity"][1]["Index"] end
									if Cons[i]["Entity"][2] then Ent2Index = Cons[i]["Entity"][2]["Index"] end
								end
								if Ent1Index and Ent2Index then
									local Count = #SendToClient[pl]+1
									SendToClient[pl][Count] = {}
									if Ent1Index == 0 then
										AllEnts[Ent2Index] = true
										if Stage == 1 then
											if self:GetEnt(1) != trace.Entity and (game.GetWorld() == self:GetEnt(1) or ents.GetByIndex(Ent2Index) == self:GetEnt(1)) and Cons[i]["Type"] == "NoCollideWorld" then
												SendToClient[pl][Count][1] = Ent2Index
												SendToClient[pl][Count][3] = 7
											else
												SendToClient[pl][Count][1] = Ent2Index
												SendToClient[pl][Count][3] = 6
											end
										elseif Option == 10 and self.TASE then
											local LIndex = math.min(Ent1Index,Ent2Index)
											local HIndex = math.max(Ent1Index,Ent2Index)
											if self.TASE[2][LIndex] and self.TASE[2][LIndex][HIndex] and self.TASE[2][LIndex][HIndex] == 2 then
												SendToClient[pl][Count] = nil
											else
												SendToClient[pl][Count][1] = Ent2Index
												SendToClient[pl][Count][3] = 6
											end
										else
											SendToClient[pl][Count][1] = Ent2Index
											SendToClient[pl][Count][3] = 6
										end
										if ents.GetByIndex(Ent2Index) == trace.Entity and ((Stage == 1 and self:GetEnt(1) == game.GetWorld()) or Stage == 2) then Ignore = true end
									elseif Ent2Index == 0 then
										AllEnts[Ent1Index] = true
										if Stage == 1 then
											if self:GetEnt(1) != trace.Entity and (ents.GetByIndex(Ent1Index) == self:GetEnt(1) or game.GetWorld() == self:GetEnt(1)) and Cons[i]["Type"] == "NoCollideWorld" then
												SendToClient[pl][Count][1] = Ent1Index
												SendToClient[pl][Count][3] = 7
											else
												SendToClient[pl][Count][1] = Ent1Index
												SendToClient[pl][Count][3] = 6
											end
										elseif Option == 10 and self.TASE then
											local LIndex = math.min(Ent1Index,Ent2Index)
											local HIndex = math.max(Ent1Index,Ent2Index)
											if self.TASE[2][LIndex] and self.TASE[2][LIndex][HIndex] and self.TASE[2][LIndex][HIndex] == 2 then
												SendToClient[pl][Count] = nil
											else
												SendToClient[pl][Count][1] = Ent1Index
												SendToClient[pl][Count][3] = 6
											end
										else
											SendToClient[pl][Count][1] = Ent1Index
											SendToClient[pl][Count][3] = 6
										end
										if ents.GetByIndex(Ent1Index) == trace.Entity and ((Stage == 1 and self:GetEnt(1) == game.GetWorld()) or Stage == 2) then Ignore = true end
									else
										AllEnts[Ent1Index] = true
										AllEnts[Ent2Index] = true
										if Stage == 1 then
											if self:GetEnt(1) != trace.Entity and (ents.GetByIndex(Ent1Index) == self:GetEnt(1) or ents.GetByIndex(Ent2Index) == self:GetEnt(1)) and Cons[i]["Type"] == "NoCollideWorld" then
												SendToClient[pl][Count][1] = Ent1Index
												SendToClient[pl][Count][2] = Ent2Index
												SendToClient[pl][Count][3] = 3
											else
												SendToClient[pl][Count][1] = Ent1Index
												SendToClient[pl][Count][2] = Ent2Index
												SendToClient[pl][Count][3] = 2
											end
											local Ent1 = ents.GetByIndex(Ent1Index)
											local Ent2 = ents.GetByIndex(Ent2Index)
											if (Ent1 == trace.Entity and Ent2 == self:GetEnt(1)) or (Ent2 == trace.Entity and Ent1 == self:GetEnt(1)) then Ignore = true end
										elseif Option == 10 and self.TASE then
											local LIndex = math.min(Ent1Index,Ent2Index)
											local HIndex = math.max(Ent1Index,Ent2Index)
											if self.TASE[2][LIndex] and self.TASE[2][LIndex][HIndex] and self.TASE[2][LIndex][HIndex] == 2 then
												SendToClient[pl][Count] = nil
											else
												SendToClient[pl][Count][1] = Ent1Index
												SendToClient[pl][Count][2] = Ent2Index
												SendToClient[pl][Count][3] = 2
											end
										else
											SendToClient[pl][Count][1] = Ent1Index
											SendToClient[pl][Count][2] = Ent2Index
											SendToClient[pl][Count][3] = 2
										end
									end
								end
							end
						end
					end
					for k,v in pairs(AllEnts) do
						if k != 0 then
							local CollisionGroup = ents.GetByIndex(k):GetCollisionGroup()
							if CollisionGroup == COLLISION_GROUP_WORLD then
								if Option == 5 and ents.GetByIndex(k) == trace.Entity then Ignore = true end
								local Count = #SendToClient[pl]+1
								SendToClient[pl][Count] = {}
								SendToClient[pl][Count][1] = k
								SendToClient[pl][Count][3] = 10
							elseif CollisionGroup == COLLISION_GROUP_WEAPON then
								if Option == 5 and ents.GetByIndex(k) == trace.Entity then Ignore = true end
								local Count = #SendToClient[pl]+1
								SendToClient[pl][Count] = {}
								SendToClient[pl][Count][1] = k
								SendToClient[pl][Count][3] = 11
							end
						end
					end
					if ((Stage == 1 and self:GetEnt(1) != trace.Entity) or Stage == 2) and !Ignore then
						local Ent1Index = TraceEntityIndex
						local Ent2Index 
						if Stage == 1 then Ent2Index = self:GetEnt(1):EntIndex() else Ent2Index = 0 end
						local Count = #SendToClient[pl]+1
						SendToClient[pl][Count] = {}
						if Ent1Index == 0 then
							SendToClient[pl][Count][1] = Ent2Index
							SendToClient[pl][Count][3] = 5
						elseif Ent2Index == 0 then
							SendToClient[pl][Count][1] = Ent1Index
							SendToClient[pl][Count][3] = 5
						else
							SendToClient[pl][Count][1] = Ent1Index
							SendToClient[pl][Count][2] = Ent2Index
							SendToClient[pl][Count][3] = 1
						end
					elseif Stage == 4 then
						local AllEnts = {}
						AllEnts[TraceEntityIndex] = true
						local Entities = ExtractEntities(trace.Entity,nil,nil,tobool(self:GetClientNumber("ignore")))
						if self.Ents1 and Entities then
							local Done = {}
							for k1, Ent1 in pairs(self.Ents1) do
								if Ent1:IsValid() or Ent1 == game.GetWorld() then
									for k2, Ent2 in pairs(Entities) do
										if (Ent2:IsValid() or Ent2 == game.GetWorld()) and Ent1 != Ent2 then
											local Ent1Index = Ent1:EntIndex()
											local Ent2Index = Ent2:EntIndex()
											local Lowest = math.min(Ent1Index,Ent2Index)
											local Highest = math.max(Ent1Index,Ent2Index)
											if !Done[Lowest] then Done[Lowest] = {} end
											if !Done[Lowest][Highest] then
												Done[Lowest][Highest] = true
												AllEnts[Ent1Index] = true
												AllEnts[Ent2Index] = true
												local Count = #SendToClient[pl]+1
												SendToClient[pl][Count] = {}
												if NocollideFind(Ent1,Ent2) then
													if Ent1Index == 0 then
														SendToClient[pl][Count][1] = Ent2Index
														SendToClient[pl][Count][3] = 6
													elseif Ent2Index == 0 then
														SendToClient[pl][Count][1] = Ent1Index
														SendToClient[pl][Count][3] = 6
													else
														SendToClient[pl][Count][1] = Ent1Index
														SendToClient[pl][Count][2] = Ent2Index
														SendToClient[pl][Count][3] = 2
													end
												else
													if Ent1Index == 0 then
														SendToClient[pl][Count][1] = Ent2Index
														SendToClient[pl][Count][3] = 5
													elseif Ent2Index == 0 then
														SendToClient[pl][Count][1] = Ent1Index
														SendToClient[pl][Count][3] = 5
													else
														SendToClient[pl][Count][1] = Ent1Index
														SendToClient[pl][Count][2] = Ent2Index
														SendToClient[pl][Count][3] = 1
													end
												end
											end
										end
									end
								end
							end
						end
						for k,v in pairs(AllEnts) do
							if k != 0 then
								local CollisionGroup = ents.GetByIndex(k):GetCollisionGroup()
								if CollisionGroup == COLLISION_GROUP_WORLD then
									local Count = #SendToClient[pl]+1
									SendToClient[pl][Count] = {}
									SendToClient[pl][Count][1] = k
									SendToClient[pl][Count][3] = 10
								elseif CollisionGroup == COLLISION_GROUP_WEAPON then
									local Count = #SendToClient[pl]+1
									SendToClient[pl][Count] = {}
									SendToClient[pl][Count][1] = k
									SendToClient[pl][Count][3] = 11
								end
							end
						end
					elseif Option == 5 and !Ignore then
						local Count = #SendToClient[pl]+1
						SendToClient[pl][Count] = {}
						SendToClient[pl][Count][1] = TraceEntityIndex
						SendToClient[pl][Count][3] = 9
					end
				elseif Option == 4 then
					local AllEnts = {}
					AllEnts[TraceEntityIndex] = true
					local Entities = ExtractEntities(trace.Entity,nil,nil,tobool(self:GetClientNumber("ignore")))
					if Entities then
						local Done = {}
						for k1, Ent1 in pairs(Entities) do
							for k2, Ent2 in pairs(Entities) do
								if Ent1 != Ent2 then
									if Ent1:IsValid() and Ent2:IsValid() then
										local Ent1Index = Ent1:EntIndex()
										local Ent2Index = Ent2:EntIndex()
										local Lowest = math.min(Ent1Index,Ent2Index)
										local Highest = math.max(Ent1Index,Ent2Index)
										if !Done[Lowest] then Done[Lowest] = {} end
										if !Done[Lowest][Highest] then
											Done[Lowest][Highest] = true
											AllEnts[Ent1Index] = true
											AllEnts[Ent2Index] = true
											local Count = #SendToClient[pl]+1
											SendToClient[pl][Count] = {}
											if NocollideFind(Ent1,Ent2) then
												SendToClient[pl][Count][1] = Ent1Index
												SendToClient[pl][Count][2] = Ent2Index
												SendToClient[pl][Count][3] = 2
											else
												SendToClient[pl][Count][1] = Ent1Index
												SendToClient[pl][Count][2] = Ent2Index
												SendToClient[pl][Count][3] = 1
											end
										end
									elseif (Ent1:IsValid() or Ent1 == game.GetWorld()) and (Ent2:IsValid() or Ent2 == game.GetWorld()) and NocollideFind(Ent1,Ent2) then
										local Ent1Index = Ent1:EntIndex()
										local Ent2Index = Ent2:EntIndex()
										local Lowest = math.min(Ent1Index,Ent2Index)
										local Highest = math.max(Ent1Index,Ent2Index)
										if !Done[Lowest] then Done[Lowest] = {} end
										if !Done[Lowest][Highest] then
											Done[Lowest][Highest] = true
											AllEnts[Ent1Index] = true
											AllEnts[Ent2Index] = true
											local Count = #SendToClient[pl]+1
											SendToClient[pl][Count] = {}
											if Ent1Index == 0 then
												SendToClient[pl][Count][1] = Ent2Index
												SendToClient[pl][Count][3] = 6
											elseif Ent2Index == 0 then
												SendToClient[pl][Count][1] = Ent1Index
												SendToClient[pl][Count][3] = 6
											end
										end
									end
								end
							end
						end
					end
					for k,v in pairs(AllEnts) do
						if k != 0 then
							local CollisionGroup = ents.GetByIndex(k):GetCollisionGroup()
							if CollisionGroup == COLLISION_GROUP_WORLD then
								local Count = #SendToClient[pl]+1
								SendToClient[pl][Count] = {}
								SendToClient[pl][Count][1] = k
								SendToClient[pl][Count][3] = 10
							elseif CollisionGroup == COLLISION_GROUP_WEAPON then
								local Count = #SendToClient[pl]+1
								SendToClient[pl][Count] = {}
								SendToClient[pl][Count][1] = k
								SendToClient[pl][Count][3] = 11
							end
						end
					end
				else
					local AllEnts = {}
					AllEnts[TraceEntityIndex] = true
					local Distance = self:GetClientNumber("distance")
					if Option == 6 then
						local AddVector = Vector(Distance,Distance,Distance)
						for k,v in pairs(ents.FindInBox(trace.Entity:LocalToWorld(trace.Entity:OBBMins()-AddVector), trace.Entity:LocalToWorld(trace.Entity:OBBMaxs()+AddVector))) do
							if v:IsValid() and v:GetPhysicsObject():IsValid() and v != trace.Entity and !v:IsPlayer() then
								local Ent = v:EntIndex()
								AllEnts[Ent] = true
								local Count = #SendToClient[pl]+1
								SendToClient[pl][Count] = {}
								if NocollideFind(v,trace.Entity) then
									SendToClient[pl][Count][1] = Ent
									SendToClient[pl][Count][2] = TraceEntityIndex
									SendToClient[pl][Count][3] = 2
								else
									SendToClient[pl][Count][1] = Ent
									SendToClient[pl][Count][2] = TraceEntityIndex
									SendToClient[pl][Count][3] = 1
								end
							end
						end
					elseif Option == 7 then
						for k,v in pairs(ents.FindInSphere(trace.Entity:LocalToWorld(trace.Entity:OBBCenter()), (trace.Entity:OBBMaxs()/2):Length()+Distance)) do
							if v:IsValid() and v:GetPhysicsObject():IsValid() and v != trace.Entity and !v:IsPlayer() then
								local Ent = v:EntIndex()
								AllEnts[Ent] = true
								local Count = #SendToClient[pl]+1
								SendToClient[pl][Count] = {}
								if NocollideFind(v,trace.Entity) then
									SendToClient[pl][Count][1] = Ent
									SendToClient[pl][Count][2] = TraceEntityIndex
									SendToClient[pl][Count][3] = 2
								else
									SendToClient[pl][Count][1] = Ent
									SendToClient[pl][Count][2] = TraceEntityIndex
									SendToClient[pl][Count][3] = 1
								end
							end
						end
					elseif Option == 8 then
						local Entities = ExtractEntities(trace.Entity,nil,nil,tobool(self:GetClientNumber("ignore")))
						if Entities then
							local AddVector = Vector(Distance,Distance,Distance)
							for k1, Ent1 in pairs(Entities) do
								if Ent1:IsValid() and !Ent1:IsPlayer() then
									for k,v in pairs(ents.FindInBox(Ent1:LocalToWorld(Ent1:OBBMins()-AddVector), Ent1:LocalToWorld(Ent1:OBBMaxs()+AddVector))) do
										if v:IsValid() and v:GetPhysicsObject():IsValid() and v != Ent1 and !v:IsPlayer() then
											local Ent1Index = Ent1:EntIndex()
											local Ent2Index = v:EntIndex()
											AllEnts[Ent1Index] = true
											AllEnts[Ent2Index] = true
											local Count = #SendToClient[pl]+1
											SendToClient[pl][Count] = {}
											if NocollideFind(v,Ent1) then
												SendToClient[pl][Count][1] = Ent1Index
												SendToClient[pl][Count][2] = Ent2Index
												SendToClient[pl][Count][3] = 2
											else
												SendToClient[pl][Count][1] = Ent1Index
												SendToClient[pl][Count][2] = Ent2Index
												SendToClient[pl][Count][3] = 1
											end
										end
									end
								end
							end
						end
					elseif Option == 9 then
						local Entities = ExtractEntities(trace.Entity,nil,nil,tobool(self:GetClientNumber("ignore")))
						if Entities then
							for k1, Ent1 in pairs(Entities) do
								if Ent1:IsValid() and !Ent1:IsPlayer() then
									for k,v in pairs(ents.FindInSphere(Ent1:LocalToWorld(Ent1:OBBCenter()), (Ent1:OBBMaxs()/2):Length()+Distance)) do
										if v:IsValid() and v:GetPhysicsObject():IsValid() and v != Ent1 and !v:IsPlayer() then
											local Ent1Index = Ent1:EntIndex()
											local Ent2Index = v:EntIndex()
											AllEnts[Ent1Index] = true
											AllEnts[Ent2Index] = true
											local Count = #SendToClient[pl]+1
											SendToClient[pl][Count] = {}
											if NocollideFind(v,Ent1) then
												SendToClient[pl][Count][1] = Ent1Index
												SendToClient[pl][Count][2] = Ent2Index
												SendToClient[pl][Count][3] = 2
											else
												SendToClient[pl][Count][1] = Ent1Index
												SendToClient[pl][Count][2] = Ent2Index
												SendToClient[pl][Count][3] = 1
											end
										end
									end
								end
							end
						end
					end
					for k,v in pairs(AllEnts) do
						if k != 0 then
							local CollisionGroup = ents.GetByIndex(k):GetCollisionGroup()
							if CollisionGroup == COLLISION_GROUP_WORLD then
								local Count = #SendToClient[pl]+1
								SendToClient[pl][Count] = {}
								SendToClient[pl][Count][1] = k
								SendToClient[pl][Count][3] = 10
							elseif CollisionGroup == COLLISION_GROUP_WEAPON then
								local Count = #SendToClient[pl]+1
								SendToClient[pl][Count] = {}
								SendToClient[pl][Count][1] = k
								SendToClient[pl][Count][3] = 11
							end
							if NocollideFind(ents.GetByIndex(k),game.GetWorld()) then
								local Count = #SendToClient[pl]+1
								SendToClient[pl][Count] = {}
								SendToClient[pl][Count][1] = k
								SendToClient[pl][Count][3] = 6
							end
						end
					end
				end
				self.AimEnt[pl] = trace.Entity
			end
		else
			if self.AimEnt[pl] != nil then
				SendDone[pl] = 0
				self.AimEnt[pl] = nil
				SendToClient[pl] = {}
				net.Start("DrawNoCollide")
				net.WriteString("0a")
				net.Send(pl)
			end
		end
	end
end

function TOOL:Holster()
	if SERVER then
		local pl = self:GetOwner()
		if self.Hold then self.Hold[pl] = false end
		SendDone[pl] = 0
		if self.AimEnt then self.AimEnt[pl] = nil end
		SendToClient[pl] = {}
		self.TASE = nil
		net.Start("DrawNoCollide")
		net.WriteString("0")
		net.Send(pl)
		self:ClearObjects()
	end
end

function TOOL.BuildCPanel(CPanel)
	CPanel:AddControl("Header", {Text = "#Tool.nocollide_world.name", Description = "#Tool.nocollide_world.desc"})
	
	local ctrl = vgui.Create("CtrlListBox", CPanel)
	ctrl:AddOption("Like default no collide", {nocollide_world_options = "1"})
	ctrl:AddOption("No collide world only", {nocollide_world_options = "2"})
	ctrl:AddOption("Select all constrained", {nocollide_world_options = "3"})
	ctrl:AddOption("To all constrained", {nocollide_world_options = "4"})
	ctrl:AddOption("No collide player only", {nocollide_world_options = "5"})
	ctrl:AddOption("No collide within box", {nocollide_world_options = "6"})
	ctrl:AddOption("No collide within sphere", {nocollide_world_options = "7"})
	ctrl:AddOption("No collide within box all constrained", {nocollide_world_options = "8"})
	ctrl:AddOption("No collide within sphere all constrained", {nocollide_world_options = "9"})
	ctrl:AddOption("To all selected entities", {nocollide_world_options = "10"})
	
	local left = vgui.Create("DLabel", CPanel)
	left:SetText("Nocollide Options")
	left:SetDark(true)
	ctrl:SetHeight(25)
	ctrl:Dock(TOP)
	
	CPanel:AddItem(left, ctrl)
	
	CPanel.IgnoreCheckbox = CPanel:AddControl("Checkbox", {Label = "Ignore No Collide", Command = "nocollide_world_ignore"})
	
	CPanel.RemoveCheckbox = CPanel:AddControl("Checkbox", {Label = "Remove No Collide Or Ignore", Command = "nocollide_world_remove"})
	
	CPanel.AddDistance = vgui.Create("Panel", CPanel)
	CPanel.AddDistance:Dock(TOP)
	CPanel.AddDistance:DockMargin(4, 20, 0, 0)
	CPanel.AddDistance:SetVisible(true)
	
	CPanel.AddDistance.TextArea = CPanel.AddDistance:Add("DTextEntry")
	CPanel.AddDistance.TextArea:SetDrawBackground(false)
	CPanel.AddDistance.TextArea:SetNumeric(true)
	CPanel.AddDistance.TextArea.OnChange = function(val)
		val = tonumber(val:GetValue()) or 0
		if val then
			CPanel.AddDistance.Scratch:SetValue(val)
			val = tonumber(CPanel.AddDistance.Scratch:GetFloatValue()) or 0
			CPanel.AddDistance.Slider:SetSlideX(CPanel.AddDistance.Scratch:GetFraction(val))
		end
	end
	
	CPanel.AddDistance.Slider = CPanel.AddDistance:Add("DSlider", CPanel.AddDistance)
	CPanel.AddDistance.Slider:SetLockY(0.5)
	CPanel.AddDistance.Slider.TranslateValues = function(slider, x, y)
		local val = math.Clamp(x*1000, 0, 1000)
		if val then
			CPanel.AddDistance.Scratch:SetValue(val)
			if CPanel.AddDistance.TextArea != vgui.GetKeyboardFocus() then
				local str = CPanel.AddDistance.Scratch:GetTextValue()
				if string.find(str,".",1,true) then str = string.Explode(".", str, true)[1] end
				CPanel.AddDistance.TextArea:SetValue(str)
			end
		end
		return CPanel.AddDistance.Scratch:GetFraction(), y
	end
	CPanel.AddDistance.Slider:SetTrapInside(true)
	Derma_Hook(CPanel.AddDistance.Slider, "Paint", "Paint", "NumSlider")
	CPanel.AddDistance.Slider:SetNotches(10)
	
	CPanel.AddDistance.Label = vgui.Create("DLabel", CPanel.AddDistance)
	CPanel.AddDistance.Label:SetMouseInputEnabled(true)
	CPanel.AddDistance.Label:SetDark(true)
	CPanel.AddDistance.Label:SetText("Add Distance")
	
	CPanel.AddDistance.Scratch = CPanel.AddDistance.Label:Add("DNumberScratch")
	CPanel.AddDistance.Scratch:SetImageVisible(false)
	CPanel.AddDistance.Scratch:Dock(FILL)
	CPanel.AddDistance.Scratch.OnValueChanged = function()
		local val = tonumber(CPanel.AddDistance.Scratch:GetFloatValue()) or 0
		CPanel.AddDistance.Slider:SetSlideX(CPanel.AddDistance.Scratch:GetFraction(val))
		if CPanel.AddDistance.TextArea != vgui.GetKeyboardFocus() then
			local str = CPanel.AddDistance.Scratch:GetTextValue()
			if string.find(str,".",1,true) then str = string.Explode(".", str, true)[1] end
			CPanel.AddDistance.TextArea:SetValue(str)
		end
	end
	CPanel.AddDistance.Scratch:SetMin(0)
	CPanel.AddDistance.Scratch:SetMax(1000)
	CPanel.AddDistance.Scratch:SetDecimals(0)
	CPanel.AddDistance.Scratch:SetConVar("nocollide_world_distance")
	
	CPanel.AddDistance:SetTall(32)
	
	function CPanel.AddDistance:PerformLayout()
		local Left = 5
		CPanel.AddDistance.Label:SetPos(Left, 0)
		CPanel.AddDistance.Label:SetWide(70, 0)
		Left = Left+70
		CPanel.AddDistance.Slider:SetPos(Left, 0)
		local Right = CPanel:GetWide()-10
		Right = Right-35
		CPanel.AddDistance.TextArea:SetPos(Right, 0)
		CPanel.AddDistance.TextArea:SetWide(30)
		CPanel.AddDistance.Slider:SetWide((Right-Left)-5)
	end
	
	local val = GetConVarNumber("nocollide_world_distance") or 0
	if val then
		CPanel.AddDistance.Scratch:SetValue(val)
		val = tonumber(CPanel.AddDistance.Scratch:GetFloatValue()) or 0
		CPanel.AddDistance.Slider:SetSlideX(CPanel.AddDistance.Scratch:GetFraction(val))
		if CPanel.AddDistance.TextArea != vgui.GetKeyboardFocus() then
			local str = CPanel.AddDistance.Scratch:GetTextValue()
			if string.find(str,".",1,true) then str = string.Explode(".", str, true)[1] end
			CPanel.AddDistance.TextArea:SetValue(str)
		end
	end
	
	CPanel:AddControl("Checkbox", {Label = "Hide Effect", Command = "nocollide_world_effect"})
	
	local function CVarChange(_,Old,New)
		if New then
			if CPanel.IgnoreCheckbox then if New == "3" or New == "4" or New == "8" or New == "9" then CPanel.IgnoreCheckbox:SetVisible(true) else CPanel.IgnoreCheckbox:SetVisible(false) end end
			if CPanel.AddDistance then if New == "6" or New == "7" or New == "8" or New == "9" then CPanel.AddDistance:SetVisible(true) else CPanel.AddDistance:SetVisible(false) end end
			if CPanel.RemoveCheckbox and New == "10" then CPanel.RemoveCheckbox:SetVisible(true) else CPanel.RemoveCheckbox:SetVisible(false) end
		end
	end
	cvars.AddChangeCallback("nocollide_world_options", CVarChange)
	CVarChange(nil,nil,GetConVarString("nocollide_world_options"))
end

if SERVER then
	hook.Add("Tick", "NoCollideWorldTick", function()
		for k,pl in pairs(player.GetAll()) do
			if SendToClient[pl] and SendToClient[pl][SendDone[pl]+1] then
				local S = SendDone[pl]+1
				SendDone[pl] = S
				net.Start("DrawNoCollide")
				if SendToClient[pl][S][2] then net.WriteString(tostring(SendToClient[pl][S][1]).."_"..SendToClient[pl][S][2].."_"..SendToClient[pl][S][3]) else net.WriteString(tostring(SendToClient[pl][S][1]).."_"..SendToClient[pl][S][3]) end
				net.Send(pl)
				if !SendToClient[pl][S+1] then
					SendDone[pl] = 0
					SendToClient[pl] = {}
				end
			end
			if SendToClient2[pl] and SendToClient2[pl][SendDone2[pl]+1] then
				local S = SendDone2[pl]+1
				SendDone2[pl] = S
				net.Start("DrawNoCollide")
				if SendToClient2[pl][S][2] then net.WriteString(tostring(SendToClient2[pl][S][1]).."_"..SendToClient2[pl][S][2].."_"..SendToClient2[pl][S][3]) else net.WriteString(tostring(SendToClient2[pl][S][1]).."_"..SendToClient2[pl][S][3]) end
				net.Send(pl)
				if !SendToClient2[pl][S+1] then
					SendDone2[pl] = 0
					SendToClient2[pl] = {}
				end
			end
		end
	end)

	local MAX_CONSTRAINTS_PER_SYSTEM = 100
	
	local function CreateConstraintSystem()
		local System = ents.Create("phys_constraintsystem")
		if !IsValid(System) then return end
		System:SetKeyValue("additionaliterations", GetConVarNumber("gmod_physiterations"))
		System:Spawn()
		System:Activate()
		return System
	end
	
	local function FindOrCreateConstraintSystem(Ent1, Ent2)
		local System
		if !Ent1:IsWorld() and Ent1:GetTable().ConstraintSystem and Ent1:GetTable().ConstraintSystem:IsValid() then System = Ent1:GetTable().ConstraintSystem end
		if System and System:IsValid() and System:GetVar("constraints", 0) > MAX_CONSTRAINTS_PER_SYSTEM then System = nil end
		if !System and !Ent2:IsWorld() and Ent2:GetTable().ConstraintSystem and Ent2:GetTable().ConstraintSystem:IsValid() then System = Ent2:GetTable().ConstraintSystem end
		if System and System:IsValid() and System:GetVar("constraints", 0) > MAX_CONSTRAINTS_PER_SYSTEM then System = nil end
		if !System or !System:IsValid() then System = CreateConstraintSystem() end
		if !System then return end
		Ent1.ConstraintSystem = System
		Ent2.ConstraintSystem = System
		System.UsedEntities = System.UsedEntities or {}
		table.insert(System.UsedEntities, Ent1)
		table.insert(System.UsedEntities, Ent2)
		System:SetVar("constraints", System:GetVar("constraints", 0)+1)
		return System
	end
	
	function constraint.NoCollideWorld(Ent1, Ent2, Bone1, Bone2)
		if !Ent1 or !Ent2 then return false end
		
		if Ent1 == game.GetWorld() then
			Ent1 = Ent2
			Ent2 = game.GetWorld()
			Bone1 = Bone2
			Bone2 = 0
		end
		
		if !Ent1:IsValid() or (!Ent2:IsWorld() and !Ent2:IsValid()) then return false end
		
		Bone1 = Bone1 or 0
		Bone2 = Bone2 or 0
		
		local Phys1 = Ent1:GetPhysicsObjectNum(Bone1)
		local Phys2 = Ent2:GetPhysicsObjectNum(Bone2)
		
		if !Phys1 or !Phys1:IsValid() or !Phys2 or !Phys2:IsValid() then return false end
		
		if Phys1 == Phys2 then return false end
		
		if Ent1:GetTable().Constraints then
			for k, v in pairs(Ent1:GetTable().Constraints) do
				if v:IsValid() then
					local CTab = v:GetTable()
					if (CTab.Type == "NoCollideWorld" or CTab.Type == "NoCollide") and ((CTab.Ent1 == Ent1 and CTab.Ent2 == Ent2) or (CTab.Ent2 == Ent1 and CTab.Ent1 == Ent2)) then return false end
				end	
			end
		end
		
		local System = FindOrCreateConstraintSystem(Ent1, Ent2)
		
		if !IsValid(System) then return false end
		
		SetPhysConstraintSystem(System)
		
		local Constraint = ents.Create("phys_ragdollconstraint")
		
		if !IsValid(Constraint) then
			SetPhysConstraintSystem(NULL)
			return false
		end
		Constraint:SetKeyValue("xmin", -180)
		Constraint:SetKeyValue("xmax", 180)
		Constraint:SetKeyValue("ymin", -180)
		Constraint:SetKeyValue("ymax", 180)
		Constraint:SetKeyValue("zmin", -180)
		Constraint:SetKeyValue("zmax", 180)
		Constraint:SetKeyValue("spawnflags", 3)
		Constraint:SetPhysConstraintObjects(Phys1, Phys2)
		Constraint:Spawn()
		Constraint:Activate()
		
		SetPhysConstraintSystem(NULL)
		constraint.AddConstraintTable(Ent1, Constraint, Ent2)
		
		local ctable = 
		{
			Type 			= "NoCollideWorld",
			Ent1  			= Ent1,
			Ent2 			= Ent2,
			Bone1 			= Bone1,
			Bone2 			= Bone2
		}
		
		Constraint:SetTable(ctable)
		
		return Constraint
	end
	duplicator.RegisterConstraint("NoCollideWorld", constraint.NoCollideWorld, "Ent1", "Ent2", "Bone1", "Bone2")
end
--lua/weapons/gmod_tool/stools/npctool_proficiency.lua:
TOOL.Category = "NPC Control"
TOOL.Name = "NPC Proficiency"
TOOL.Command = nil
TOOL.ConfigName = ""

if(CLIENT) then
	local function NumSlider(self,strLabel,strConVar,numMin,numMax,numDecimals)
		local left = vgui.Create("DNumSliderLegacy",self)
		left:SetText(strLabel)
		left:SetMinMax(numMin,numMax)
		left:SetDark(true)
		
		if(numDecimals != nil) then left:SetDecimals(numDecimals) end
		left:SetConVar(strConVar)
		left:SizeToContents()
		self:AddItem(left,nil)
		return left
	end
	TOOL.ClientConVar["value"] = WEAPON_PROFICIENCY_AVERAGE
	language.Add("tool.npctool_proficiency.name","NPC Proficiency")
	language.Add("tool.npctool_proficiency.desc","Change a NPC's weapon proficiency.")
	language.Add("tool.npctool_proficiency.0","Left-Click on a NPC to change his proficiency, Right-Click to change the proficiency of all active NPCs of this class.")
	
	local values = {
		[WEAPON_PROFICIENCY_POOR] = "Poor",
		[WEAPON_PROFICIENCY_AVERAGE] = "Average",
		[WEAPON_PROFICIENCY_GOOD] = "Good",
		[WEAPON_PROFICIENCY_VERY_GOOD] = "Very Good",
		[WEAPON_PROFICIENCY_PERFECT] = "Perfect"
	}
	local bWarned
	local addon = 118115179
	local function ShowWarning()
		bWarned = true
		if(!game.SinglePlayer()) then return end
		if(!steamworks.IsSubscribed(addon) || !steamworks.ShouldMountAddon(addon)) then return end
		steamworks.FileInfo(addon,function(r)
			r = r || {title = "Error"}
			local w = 500
			local pnl = vgui.Create("DFrame")
			pnl:SetTitle("NPC Proficiency - Warning")
			pnl:SizeToContents()
			pnl:MakePopup()

			local y = 40
			local function AddLine(line)
				local l = vgui.Create("DLabel",pnl)
				l:SetText(line)
				l:SetPos(20,y)
				l:SizeToContents()
				
				y = y +l:GetTall()
			end
			AddLine("You have the '" .. r.title .. "' Addon installed, which is incompatible with this tool.")
			AddLine("Using this tool will have no effect.")
			local h = y +60
			local x,yPnl = ScrW() *0.5 -w *0.5,ScrH() *0.5 -h *0.5
			pnl:SetSize(w,h)
			pnl:SetPos(x,yPnl)

			local p = vgui.Create("DButton",pnl)
			p:SetText("OK")
			p.DoClick = function() pnl:Close() end
			p:SetPos(w *0.5 -p:GetWide() *0.5,y +20)
		end)
	end
	function TOOL.BuildCPanel(pnl)
		if(!bWarned) then ShowWarning() end
		pnl:AddControl("Header",{Text = "Viewcam",Description = [[Left-Click on a NPC to change his proficiency.
		Right-Click to change the proficiency of all active NPCs of this class.
		]]})
		local pSl = NumSlider(pnl,"Proficiency:",nil,1,5,0)
		local prof = values[GetConVarNumber("npctool_proficiency_value")] || "Poor"
		pSl.Wang:SetText(prof)
		local i
		for _,val in ipairs(values) do if(val == prof) then i = _ +1; break end end
		if(i) then pSl.Slider:SetSlideX((i -1) /4) end
		pSl.TranslateSliderValues = function(...)
			local x,y = select(2,...)
			local num = tonumber(x *4 +1) || 0
			num = math.Round(num)
			local val = math.Clamp(num,1,5)
			pSl.Wang:SetText(values[val -1] || "Poor")
			RunConsoleCommand("npctool_proficiency_value",val -1)
			return ((num -1) /4),y
		end
	end
	local tbProficiency
	net.Receive("npctool_proficiency_update",function(len)
		local ent = net.ReadEntity()
		if(!ent:IsValid()) then return end
		local prof = net.ReadUInt(3)
		local bType = net.ReadUInt(1) == 1
		local text
		if(!bType) then
			tbProficiency[ent] = prof
			text = "Set proficiency of " .. language.GetPhrase("#" .. ent:GetClass()) .. " to " .. string.lower(values[prof] || "poor") .. "."
		else
			local num = 0
			for _,ent in ipairs(ents.FindByClass(ent:GetClass())) do
				num = num +1
				tbProficiency[ent] = prof
			end
			text = "Set proficiency of all NPCs of type '" .. language.GetPhrase("#" .. ent:GetClass()) .. "' (" .. num .. ") to " .. string.lower(values[prof] || "poor") .. "."
		end
		notification.AddLegacy(text,0,8)
	end)
	net.Receive("npctool_proficiency_deploy",function(len)
		net.Start("sv_npctool_proficiency_request")
		net.SendToServer()
	end)
	net.Receive("npctool_proficiency_holster",function(len)
		local wep = LocalPlayer():GetActiveWeapon()
		if(wep:IsValid() && wep:GetClass() == "gmod_tool" && wep:GetMode() == "npctool_proficiency") then // False alarm
			return
		end
		tbProficiency = nil
		hook.Remove("RenderScreenspaceEffects","npctool_proficiency_draw")
		hook.Remove("OnEntityCreated","npctool_proficiency_update")
	end)
	net.Receive("cl_npctool_proficiency_request_sng",function(len)
		if(!tbProficiency) then return end
		local ent = net.ReadEntity()
		if(!ent:IsValid()) then return end
		local prof = net.ReadUInt(3)
		tbProficiency[ent] = prof
	end)
	net.Receive("cl_npctool_proficiency_request",function(len)
		tbProficiency = {}
		local num = net.ReadUInt(12)
		for i = 1,num do
			local ent = net.ReadEntity()
			local prof = net.ReadUInt(3)
			if(ent:IsValid()) then tbProficiency[ent] = prof end
		end
		hook.Add("OnEntityCreated","npctool_proficiency_update",function(ent)
			if(ent:IsValid() && ent:IsNPC()) then
				net.Start("sv_npctool_proficiency_request_sng")
					net.WriteEntity(ent)
				net.SendToServer()
			end
		end)
		hook.Add("RenderScreenspaceEffects","npctool_proficiency_draw",function()
			cam.Start3D(EyePos(),EyeAngles())
			for ent,prof in pairs(tbProficiency) do
				if(!ent:IsValid()) then tbProficiency[ent] = nil
				else
					local ang = LocalPlayer():EyeAngles()
					ang:RotateAroundAxis(ang:Forward(),90)
					ang:RotateAroundAxis(ang:Right(),90)
					local pos = ent:GetPos() +Vector(0,0,ent:OBBMaxs().z +16)
					cam.Start3D2D(pos,Angle(0,ang.y,90),0.5)
						draw.DrawText("Proficiency:","default",2,2,colText,TEXT_ALIGN_CENTER)
					cam.End3D2D()
					pos.z = pos.z -6
					cam.Start3D2D(pos,Angle(0,ang.y,90),0.5)
						draw.DrawText(values[prof] || "Poor","default",2,2,colText,TEXT_ALIGN_CENTER)
					cam.End3D2D()
				end
			end
			cam.End3D()
		end)
	end)
else
	util.AddNetworkString("npctool_proficiency_update")
	util.AddNetworkString("npctool_proficiency_holster")
	util.AddNetworkString("npctool_proficiency_deploy")
	util.AddNetworkString("sv_npctool_proficiency_request")
	util.AddNetworkString("cl_npctool_proficiency_request")
	util.AddNetworkString("sv_npctool_proficiency_request_sng")
	util.AddNetworkString("cl_npctool_proficiency_request_sng")
	net.Receive("sv_npctool_proficiency_request_sng",function(len,pl)
		local ent = net.ReadEntity()
		if(!ent:IsValid() || !ent:IsNPC()) then return end
		local prof = ent:GetCurrentWeaponProficiency()
		net.Start("cl_npctool_proficiency_request_sng")
			net.WriteEntity(ent)
			net.WriteUInt(prof,3)
		net.Send(pl)
	end)
	net.Receive("sv_npctool_proficiency_request",function(len,pl)
		local tbEnts = {}
		local num = 0
		for _,ent in ipairs(ents.GetAll()) do
			if(ent:IsNPC()) then
				num = num +1
				tbEnts[ent] = ent:GetCurrentWeaponProficiency()
			end
		end
		net.Start("cl_npctool_proficiency_request")
			net.WriteUInt(num,12)
			for ent,prof in pairs(tbEnts) do
				net.WriteEntity(ent)
				net.WriteUInt(prof,3)
			end
		net.Send(pl)
	end)
	function TOOL:Deploy()
		net.Start("npctool_proficiency_deploy")
		net.Send(self:GetOwner())
	end
end

function TOOL:LeftClick(tr)
	if(CLIENT) then return true end
	if(tr.Entity:IsValid() && tr.Entity:IsNPC()) then
		local prof = self:GetClientNumber("value")
		tr.Entity:SetCurrentWeaponProficiency(prof)
		net.Start("npctool_proficiency_update")
			net.WriteEntity(tr.Entity)
			net.WriteUInt(prof,3)
			net.WriteUInt(0,1)
		net.Send(self:GetOwner())
		return true
	end
	return false
end

function TOOL:RightClick(tr)
	if(CLIENT) then return true end
	if(tr.Entity:IsValid() && tr.Entity:IsNPC()) then
		local prof = self:GetClientNumber("value")
		for _,ent in ipairs(ents.FindByClass(tr.Entity:GetClass())) do
			ent:SetCurrentWeaponProficiency(prof)
		end
		net.Start("npctool_proficiency_update")
			net.WriteEntity(tr.Entity)
			net.WriteUInt(prof,3)
			net.WriteUInt(1,1)
		net.Send(self:GetOwner())
		return true
	end
	return false
end

function TOOL:Holster()
	if(CLIENT) then return end
	net.Start("npctool_proficiency_holster")
	net.Send(self:GetOwner())
end
--lua/weapons/gmod_tool/stools/npctool_viewcam.lua:
TOOL.Category = "NPC Control"
TOOL.Name = "NPC Viewcam"
TOOL.Command = nil
TOOL.ConfigName = ""

if(CLIENT) then
	language.Add("tool.npctool_viewcam.name","NPC Viewcam")
	language.Add("tool.npctool_viewcam.desc","Create a camera attached to a NPC.")
	language.Add("tool.npctool_viewcam.0","Left-Click on a NPC to enter camera mode. Use key to end camera mode.")
	
	function TOOL.BuildCPanel(pnl)
		pnl:AddControl("Header",{Text = "Viewcam",Description = [[Left-Click on a NPC to enter camera mode.
		Use key to end camera mode.
		]]})
	end
end

function TOOL:LeftClick(tr)
	if(CLIENT) then return true end
	if(tr.Entity:IsValid() && tr.Entity:IsNPC()) then
		local ent = ents.Create("obj_viewcam")
		ent:SetEntityOwner(self:GetOwner())
		ent:SetTarget(tr.Entity)
		ent:SetPos(tr.Entity:GetPos() +tr.Entity:OBBCenter() +Vector(0,0,tr.Entity:OBBMaxs().z *0.5))
		ent:SetParent(tr.Entity)
		ent:Spawn()
		ent:Activate()
		if(tr.Entity:LookupAttachment("possession_cam") > 0) then
			ent:Fire("SetParentAttachment","possession_cam",0)
		end
		ent:Start()
		return true
	end
	return false
end

function TOOL:RightClick(trace)
end
--lua/weapons/gmod_tool/stools/particlecontrol.lua:
TOOL.Category = "Particle Controller"
TOOL.Name = "Adv. Particle Control"
TOOL.Command = nil
TOOL.ConfigName = "" 

TOOL.HighlightedEnt = nil
 
TOOL.ClientConVar[ "effectname" ] = "env_fire_large"
TOOL.ClientConVar[ "mode_beam" ] = "0"
TOOL.beamattach1 = 0
TOOL.beamattach2 = 0
TOOL.ClientConVar[ "utileffect_scale" ] = "1"
TOOL.ClientConVar[ "utileffect_magnitude" ] = "1"
TOOL.ClientConVar[ "utileffect_radius" ] = "10"
TOOL.ClientConVar[ "color_enabled" ] = "0"
TOOL.ClientConVar[ "color_r" ] = "255"
TOOL.ClientConVar[ "color_g" ] = "20"
TOOL.ClientConVar[ "color_b" ] = "0"
TOOL.ClientConVar[ "color_outofone" ] = "0"

TOOL.ClientConVar[ "attachnum" ] = "0"
TOOL.ClientConVar[ "repeatrate" ] = "0"
TOOL.ClientConVar[ "repeatsafety" ] = "1"

TOOL.ClientConVar[ "propmodel" ] = "models/hunter/plates/plate.mdl"
TOOL.ClientConVar[ "propangle" ] = "1"
TOOL.ClientConVar[ "propinvis" ] = "0"

TOOL.ClientConVar[ "numpadkey" ] = "52"
TOOL.ClientConVar[ "toggle" ] = "1"
TOOL.ClientConVar[ "starton" ] = "1"

TOOL.Information = {
	{ name = "info1", stage = 1, icon = "gui/info.png" },
	{ name = "left0", stage = 0, icon = "gui/lmb.png" },
	{ name = "left1", stage = 1, icon = "gui/lmb.png" },
	{ name = "middle01", icon = "gui/mmb.png" },
	{ name = "right0", stage = 0, icon = "gui/rmb.png" },
	{ name = "right1", stage = 1, icon = "gui/rmb.png" },
	{ name = "reload0", stage = 0, icon = "gui/r.png" },
	{ name = "reload1", stage = 1, icon = "gui/r.png" },
}

if ( CLIENT ) then
	language.Add( "tool.particlecontrol.name", "Advanced Particle Controller" )
	language.Add( "tool.particlecontrol.desc", "Attach particle effects to things" )
	language.Add( "tool.particlecontrol.help", "Particles are used for all sorts of different special effects. You can attach them to models and turn them on and off with a key." )

	language.Add( "tool.particlecontrol.info1", "BEAM EFFECT: Attaches to two points" )
	language.Add( "tool.particlecontrol.left0", "Add an effect to an object" )
	language.Add( "tool.particlecontrol.left1", "Add the other end to an object" )
	language.Add( "tool.particlecontrol.middle01", "Scroll through an object's attachments" )
	language.Add( "tool.particlecontrol.right0", "Attach a new prop with the effect on it" )
	language.Add( "tool.particlecontrol.right1", "Attach a new prop and add the other end to it" )
	language.Add( "tool.particlecontrol.reload0", "Remove all effects from an object" )
	language.Add( "tool.particlecontrol.reload1", "Cancel beam effect" )
end

util.PrecacheSound("weapons/pistol/pistol_empty.wav")




function TOOL:LeftClick( trace )

	local effectname = self:GetClientInfo( "effectname", 0 )
	local attachnum = self:GetClientNumber( "attachnum", 0 )

	local repeatrate = self:GetClientNumber( "repeatrate", 0 )
	local repeatsafety = self:GetClientNumber( "repeatsafety", 0 )

	local numpadkey = self:GetClientNumber( "numpadkey", 0 )
	local toggle = self:GetClientNumber( "toggle", 0 )
	local starton = self:GetClientNumber( "starton", 0 )

	local utileffectinfo = Vector( self:GetClientNumber( "utileffect_scale", 0 ), self:GetClientNumber( "utileffect_magnitude", 0 ), self:GetClientNumber( "utileffect_radius", 0 ) )
	local colorinfo = nil
	if self:GetClientNumber( "color_enabled", 0 ) == 1 then
		if self:GetClientNumber( "color_outofone", 0 ) == 1 then
			colorinfo = Color( self:GetClientNumber( "color_r", 0 ), self:GetClientNumber( "color_g", 0 ), self:GetClientNumber( "color_b", 0 ), 1 )  //we're using the alpha value to store color_outofone
		else
			colorinfo = Color( self:GetClientNumber( "color_r", 0 ), self:GetClientNumber( "color_g", 0 ), self:GetClientNumber( "color_b", 0 ), 0 )
		end
	end

	local ply = self:GetOwner()



	if self:GetClientNumber( "mode_beam", 0 ) == 0 then
		//Not a beam, attach the effect to one entity
		if ( trace.Entity:IsValid() ) then
			if CLIENT then return true end
			if trace.Entity:GetClass() == "prop_effect" and trace.Entity.AttachedEntity then trace.Entity = trace.Entity.AttachedEntity end
			AttachParticleControllerNormal( ply, trace.Entity, { NewTable = { 
				EffectName = effectname, 
				AttachNum = attachnum, 

				RepeatRate = repeatrate, 
				RepeatSafety = repeatsafety, 

				Toggle = toggle, 
				StartOn = starton, 
				NumpadKey = numpadkey, 

				UtilEffectInfo = utileffectinfo, 
				ColorInfo = colorinfo 
			} } )
			return true
		end
	else
		//It's a beam, attach the effect between two entities
		local iNum = self:NumObjects()

		if ( trace.Entity:IsValid() ) then
			//if CLIENT then return true end
			if trace.Entity:GetClass() == "prop_effect" and trace.Entity.AttachedEntity then trace.Entity = trace.Entity.AttachedEntity end

			self:SetObject( iNum + 1, trace.Entity, trace.HitPos, nil, nil, trace.HitNormal )
			if iNum == 0 then
				self.beamattach1 = attachnum
			else
				self.beamattach2 = attachnum
			end

			if ( iNum > 0 ) then
				if ( CLIENT ) then
					self:ClearObjects()
					return true
				end
				
				local Ent1, Ent2 = self:GetEnt(1), self:GetEnt(2)
				local constraint = constraint.AttachParticleControllerBeam( Ent1, Ent2, { 
					EffectName = effectname, 
					AttachNum = self.beamattach1, 
					AttachNum2 = self.beamattach2, 

					RepeatRate = repeatrate, 
					RepeatSafety = repeatsafety, 

					Toggle = toggle, 
					StartOn = starton, 
					NumpadKey = numpadkey, 

					UtilEffectInfo = utileffectinfo, 
					ColorInfo = colorinfo 
				}, ply )	
		
				self:ClearObjects()
			else
				self:SetStage( iNum+1 )
			end

			return true
		end
	end

end




function TOOL:RightClick( trace )

	local effectname = self:GetClientInfo( "effectname", 0 )
	local attachnum  = self:GetClientNumber( "attachnum", 0 )

	local repeatrate  = self:GetClientNumber( "repeatrate", 0 )
	local repeatsafety  = self:GetClientNumber( "repeatsafety", 0 )

	local numpadkey  = self:GetClientNumber( "numpadkey", 0 )
	local toggle  = self:GetClientNumber( "toggle", 0 )
	local starton  = self:GetClientNumber( "starton", 0 )

	local utileffectinfo = Vector( self:GetClientNumber( "utileffect_scale", 0 ), self:GetClientNumber( "utileffect_magnitude", 0 ), self:GetClientNumber( "utileffect_radius", 0 ) )
	local colorinfo = nil
	if self:GetClientNumber( "color_enabled", 0 ) == 1 then
		if self:GetClientNumber( "color_outofone", 0 ) == 1 then
			colorinfo = Color( self:GetClientNumber( "color_r", 0 ), self:GetClientNumber( "color_g", 0 ), self:GetClientNumber( "color_b", 0 ), 1 )  //we're using the alpha value to store color_outofone
		else
			colorinfo = Color( self:GetClientNumber( "color_r", 0 ), self:GetClientNumber( "color_g", 0 ), self:GetClientNumber( "color_b", 0 ), 0 )
		end
	end

	local ply = self:GetOwner()



	local propmodel = self:GetClientInfo( "propmodel", 0 )
	local propangle = self:GetClientNumber( "propangle", 0 )
	//propangle 1: spawn upright
	//propangle 2: spawn at surface angle

	if !util.IsValidModel(propmodel) then return false end
	if !util.IsValidProp(propmodel) then return false end
	if CLIENT then return true end

	prop = ents.Create( "prop_physics" )
		prop:SetModel( propmodel )
		prop:SetPos( trace.HitPos - trace.HitNormal * prop:OBBMins().z )
		if propangle == 1 then prop:SetAngles(Angle(0,trace.HitNormal:Angle().y,0)) else prop:SetAngles(trace.HitNormal:Angle()) end
		prop:SetCollisionGroup(20) //COLLISION_GROUP_NONE, nocollide with everything except world
	prop:Spawn()

	local shouldweweld = true									    //don't weld if...
	if ( !util.IsValidPhysicsObject(prop, 0) ) then shouldweweld = false end			    //the prop doesn't have a phys object
	if ( !trace.Entity:IsValid() ) then shouldweweld = false end					    //the thing we clicked on doesn't exist/is the world
	if ( trace.Entity && trace.Entity:IsPlayer() ) then shouldweweld = false end			    //the thing we clicked on is a player
	if ( !util.IsValidPhysicsObject( trace.Entity, trace.PhysicsBone ) ) then shouldweweld = false end  //the thing we clicked on doesn't have a phys object
	if shouldweweld == true then
		local const = constraint.Weld( prop, trace.Entity, 0, trace.PhysicsBone, 0, true, true )
	else
		if util.IsValidPhysicsObject(prop, 0) then prop:GetPhysicsObject():EnableMotion(false) end
	end

	if self:GetClientNumber( "propinvis", 0 ) == 1 then
		prop:SetRenderMode(1)  //we need to change the render mode so the transparency actually shows up
		prop:SetColor( Color(255,255,255,0) )
		duplicator.StoreEntityModifier( prop, "colour", { Color = Color(255,255,255,0), RenderMode = 1, RenderFX = 0 } )
	end

	undo.Create( "prop" )
		undo.AddEntity( prop )
		undo.SetPlayer( ply )
	undo.Finish( "Prop ("..tostring(propmodel)..")" )



	if ( !prop:IsValid() ) then return false end
	if self:GetClientNumber( "mode_beam", 0 ) == 0 then
		//Not a beam, attach the effect to one entity.
		AttachParticleControllerNormal( ply, prop, { NewTable = { 
			EffectName = effectname, 
			AttachNum = attachnum, 

			RepeatRate = repeatrate, 
			RepeatSafety = repeatsafety, 

			Toggle = toggle, 
			StartOn = starton, 
			NumpadKey = numpadkey, 

			UtilEffectInfo = utileffectinfo, 
			ColorInfo = colorinfo 
		} } )
	else
		//It's a beam, attach the effect between two entities
		local iNum = self:NumObjects()

		self:SetObject( iNum + 1, prop, trace.HitPos, nil, nil, trace.HitNormal )
		if iNum == 0 then
			self.beamattach1 = attachnum
		else
			self.beamattach2 = attachnum
		end

		if ( iNum > 0 ) then
			if ( CLIENT ) then
				self:ClearObjects()
				return true
			end
			
			local Ent1, Ent2 = self:GetEnt(1), self:GetEnt(2)
			local constraint = constraint.AttachParticleControllerBeam( Ent1, Ent2, { 
				EffectName = effectname, 
				AttachNum = self.beamattach1, 
				AttachNum2 = self.beamattach2, 

				RepeatRate = repeatrate, 
				RepeatSafety = repeatsafety, 

				Toggle = toggle, 
				StartOn = starton, 
				NumpadKey = numpadkey, 

				UtilEffectInfo = utileffectinfo, 
				ColorInfo = colorinfo 
			}, ply )	
	
			self:ClearObjects()
		else
			self:SetStage( iNum+1 )
		end

		return true
	end

	return true

end




function TOOL:Reload( trace )

	//if we've selected something for a beam effect, then let us deselect it with reload
	if self:GetClientNumber( "mode_beam", 0 ) != 0 and self:NumObjects() > 0 then
		//self:GetEnt(1)
		self:ClearObjects()
		self:SetStage(0)
		return true
	end

	if ( trace.Entity:IsValid() ) then
		local fx = false

		if trace.Entity:GetClass() == "prop_effect" and trace.Entity.AttachedEntity then trace.Entity = trace.Entity.AttachedEntity end

		for _, asdf in pairs( ents:GetAll() ) do
			if asdf:GetClass() == "particlecontroller_normal" then 
				if asdf:GetParent() == trace.Entity then 
					if SERVER then asdf:Remove() end
					fx = true
				end
				if IsValid(asdf:GetTargetEnt2()) then
					if asdf:GetTargetEnt2() == trace.Entity or asdf:GetTargetEnt2():GetParent() == trace.Entity then 
						if SERVER then asdf:Remove() end
						fx = true
					end
				end
			end
		end
		if SERVER then
			duplicator.ClearEntityModifier( trace.Entity, "DupeParticleControllerNormal" )
			constraint.RemoveConstraints( trace.Entity, "AttachParticleControllerBeam" )
		end

		return fx
	end
	
end




if CLIENT then

	local colorborder   = Color(0,0,0,255)
	local colorselect   = Color(0,255,0,255)
	local colorunselect = Color(255,255,255,255)

	function TOOL:DrawHUD()
		local pl = LocalPlayer()
		local tr = pl:GetEyeTrace()
		local attachnum = self:GetClientNumber( "attachnum", 0 )

		local function DrawHighlightAttachments(ent)

			//If there aren't any attachments, then draw the model origin as selected and stop here:
			if !ent:GetAttachments() or !ent:GetAttachments()[1] then
				local _pos,_ang = ent:GetPos(), ent:GetAngles()
				local _pos = _pos:ToScreen()
				local textpos = {x = _pos.x+5,y = _pos.y-5}

				draw.RoundedBox(0,_pos.x - 3,_pos.y - 3,6,6,colorborder)
				draw.RoundedBox(0,_pos.x - 1,_pos.y - 1,2,2,colorselect)
				draw.SimpleTextOutlined("0: (origin)","Default",textpos.x,textpos.y,colorselect,TEXT_ALIGN_LEFT,TEXT_ALIGN_BOTTOM,2,colorborder)

				return
			end


			//Draw the unselected model origin, if applicable:
			if ent:GetAttachments()[attachnum] then
				local _pos,_ang = ent:GetPos(), ent:GetAngles()
				local _pos = _pos:ToScreen()
				local textpos = {x = _pos.x+5,y = _pos.y-5}

				draw.RoundedBox(0,_pos.x - 2,_pos.y - 2,4,4,colorborder)
				draw.RoundedBox(0,_pos.x - 1,_pos.y - 1,2,2,colorunselect)
				draw.SimpleTextOutlined("0: (origin)","Default",textpos.x,textpos.y,colorunselect,TEXT_ALIGN_LEFT,TEXT_ALIGN_BOTTOM,1,colorborder)
			end

			//Draw the unselected attachment points:
			for _, table in pairs(ent:GetAttachments()) do
				local _pos,_ang = ent:GetAttachment(table.id).Pos,ent:GetAttachment(table.id).Ang
				local _pos = _pos:ToScreen()
				local textpos = {x = _pos.x+5,y = _pos.y-5}

				if table.id != attachnum then
					draw.RoundedBox(0,_pos.x - 2,_pos.y - 2,4,4,colorborder)
					draw.RoundedBox(0,_pos.x - 1,_pos.y - 1,2,2,colorunselect)
					draw.SimpleTextOutlined(table.id ..": ".. table.name,"Default",textpos.x,textpos.y,colorunselect,TEXT_ALIGN_LEFT,TEXT_ALIGN_BOTTOM,1,colorborder)
				end
			end
			
			//Draw the selected attachment point or model origin last, so it renders above all the others:
			if !ent:GetAttachments()[attachnum] then
				//Model origin
				local _pos,_ang = ent:GetPos(), ent:GetAngles()
				local _pos = _pos:ToScreen()
				local textpos = {x = _pos.x+5,y = _pos.y-5}

				draw.RoundedBox(0,_pos.x - 3,_pos.y - 3,6,6,colorborder)
				draw.RoundedBox(0,_pos.x - 1,_pos.y - 1,2,2,colorselect)
				draw.SimpleTextOutlined("0: (origin)","Default",textpos.x,textpos.y,colorselect,TEXT_ALIGN_LEFT,TEXT_ALIGN_BOTTOM,2,colorborder)
			else
				//Attachment
				local _pos,_ang = ent:GetAttachment(attachnum).Pos,ent:GetAttachment(attachnum).Ang
				local _pos = _pos:ToScreen()
				local textpos = {x = _pos.x+5,y = _pos.y-5}

				draw.RoundedBox(0,_pos.x - 3,_pos.y - 3,6,6,colorborder)
				draw.RoundedBox(0,_pos.x - 1,_pos.y - 1,2,2,colorselect)
				draw.SimpleTextOutlined(attachnum ..": ".. ent:GetAttachments()[attachnum].name,"Default",textpos.x,textpos.y,colorselect,TEXT_ALIGN_LEFT,TEXT_ALIGN_BOTTOM,2,colorborder)
			end
		end

		if IsValid(tr.Entity) and tr.Entity == self.HighlightedEnt then
			DrawHighlightAttachments(self.HighlightedEnt) 
		return end

		if IsValid(tr.Entity) and tr.Entity != self.HighlightedEnt then
			//unhighlight the old ent if it exists
			if self.HighlightedEnt != nil then
				self.HighlightedEnt = nil
			end

			//highlight the new ent
			self.HighlightedEnt = tr.Entity
		end

		if !IsValid(tr.Entity) and self.HighlightedEnt != nil then
			self.HighlightedEnt = nil
		end
	end

	function TOOL:Holster()
		if self.HighlightedEnt != nil then
			self.HighlightedEnt = nil
		end
	end




	//All credit for the toolgun scroll wheel code goes to the Wiremod devs. You guys are the best.
		local function get_active_tool(ply, tool)
			-- find toolgun
			local activeWep = ply:GetActiveWeapon()
			if not IsValid(activeWep) or activeWep:GetClass() ~= "gmod_tool" or activeWep.Mode ~= tool then return end

			return activeWep:GetToolObject(tool)
		end

		local function hookfunc( ply, bind, pressed )
			if not pressed then return end
			if bind == "invnext" then
				local self = get_active_tool(ply, "particlecontrol")
				if not self then return end
			
				return self:ScrollDown(ply:GetEyeTraceNoCursor())
			elseif bind == "invprev" then
				local self = get_active_tool(ply, "particlecontrol")
				if not self then return end

				return self:ScrollUp(ply:GetEyeTraceNoCursor())
			end
		end
	
		if game.SinglePlayer() then -- wtfgarry (have to have a delay in single player or the hook won't get added)
			timer.Simple(5,function() hook.Add( "PlayerBindPress", "particlecontrol_playerbindpress", hookfunc ) end)
		else
			hook.Add( "PlayerBindPress", "particlecontrol_playerbindpress", hookfunc )
		end
	//End shamefully copied code here.

	function TOOL:Scroll(trace,dir)
		if !IsValid(self.HighlightedEnt) then return end

		local attachcount = 0
		if self.HighlightedEnt:GetAttachments() then attachcount = table.Count(self.HighlightedEnt:GetAttachments()) end
		local oldattachnum = self:GetClientNumber( "attachnum", 0 )
		if oldattachnum > attachcount then oldattachnum = 0 end
		local attachnum = oldattachnum + dir

		if attachnum < 0 then attachnum = attachcount end
		if attachnum > attachcount then attachnum = 0 end
		RunConsoleCommand("particlecontrol_attachnum", tostring(attachnum))
		self:GetOwner():EmitSound("weapons/pistol/pistol_empty.wav")
		return true
	end
	function TOOL:ScrollUp(trace) return self:Scroll(trace,-1) end
	function TOOL:ScrollDown(trace) return self:Scroll(trace,1) end

end




if SERVER then

	local function SpawnParticleControllerNormal(ply, ent, DataTable)

		if DataTable == nil or DataTable == {} or DataTable.EffectName == nil or ent == nil or !IsValid(ent) then return end


		local ParticleControlNormal = ents.Create( "particlecontroller_normal" )
		ParticleControlNormal:SetPos(ent:GetPos())
		ParticleControlNormal:SetAngles(ent:GetAngles())
		ParticleControlNormal:SetParent(ent)
		ent:DeleteOnRemove(ParticleControlNormal)

		ParticleControlNormal:SetTargetEnt(ent)
		ParticleControlNormal:SetEffectName(DataTable.EffectName)
		ParticleControlNormal:SetAttachNum(DataTable.AttachNum)
		ParticleControlNormal:SetUtilEffectInfo(DataTable.UtilEffectInfo)
		if DataTable.ColorInfo != nil then ParticleControlNormal:SetColor(DataTable.ColorInfo) else ParticleControlNormal:SetColor( Color(0,0,0,0) ) end

		ParticleControlNormal:SetRepeatRate(DataTable.RepeatRate)
		if DataTable.RepeatSafety == 1 or DataTable.RepeatSafety == true then ParticleControlNormal:SetRepeatSafety(true) else ParticleControlNormal:SetRepeatSafety(false) end


		if DataTable.StartOn == 1 or DataTable.StartOn == true then ParticleControlNormal:SetActive(true) else ParticleControlNormal:SetActive(false) end
		if DataTable.Toggle == 1 or DataTable.Toggle == true then ParticleControlNormal:SetToggle(true) else ParticleControlNormal:SetToggle(false) end
		ParticleControlNormal:SetNumpadKey(DataTable.NumpadKey)

		numpad.OnDown( 	 ply, 	DataTable.NumpadKey, 	"Particle_Press", 	ParticleControlNormal )
		numpad.OnUp( 	 ply, 	DataTable.NumpadKey, 	"Particle_Release", 	ParticleControlNormal )
		ParticleControlNormal:SetNumpadState("")


		ParticleControlNormal:Spawn()
		ParticleControlNormal:Activate()

	end


	function AttachParticleControllerNormal( ply, ent, Data )

		if Data.NewTable then
			SpawnParticleControllerNormal(ply, ent, Data.NewTable)

			local dupetable = {}
			if ent.EntityMods and ent.EntityMods.DupeParticleControllerNormal then dupetable = ent.EntityMods.DupeParticleControllerNormal end
			table.insert(dupetable, Data.NewTable)
			duplicator.StoreEntityModifier( ent, "DupeParticleControllerNormal", dupetable )
		return end

	end


	function DupeParticleControllerNormal( ply, ent, Data )

		//due to a problem with the easy bonemerge tool that causes entity modifiers to be applied TWICE, we need to remove the effects that were added the first time
		for _, asdf in pairs( ents:GetAll() ) do
			if asdf:GetClass() == "particlecontroller_normal" and asdf:GetParent() == ent then
				asdf:Remove()
			end
		end

		for _, DataTable in pairs (Data) do
			SpawnParticleControllerNormal(ply, ent, DataTable)
		end

	end
	duplicator.RegisterEntityModifier( "DupeParticleControllerNormal", DupeParticleControllerNormal )




	//we have to redefine some of the constraint functions here because they're local functions that don't exist outside of constraints.lua
	//not sure how well these'll work, one of them is ripped straight from the nocollide world tool which uses the same trick for its custom constraints
		local MAX_CONSTRAINTS_PER_SYSTEM = 100
		local function CreateConstraintSystem()
			local System = ents.Create("phys_constraintsystem")
			if !IsValid(System) then return end
			System:SetKeyValue("additionaliterations", GetConVarNumber("gmod_physiterations"))
			System:Spawn()
			System:Activate()
			return System
		end
		local function FindOrCreateConstraintSystem( Ent1, Ent2 )
			local System = nil
			Ent2 = Ent2 or Ent1
			-- Does Ent1 have a constraint system?
			if ( !Ent1:IsWorld() && Ent1:GetTable().ConstraintSystem && Ent1:GetTable().ConstraintSystem:IsValid() ) then 
				System = Ent1:GetTable().ConstraintSystem
			end
			-- Don't add to this system - we have too many constraints on it already.
			if ( System && System:IsValid() && System:GetVar( "constraints", 0 ) > MAX_CONSTRAINTS_PER_SYSTEM ) then System = nil end
			-- Does Ent2 have a constraint system?
			if ( !System && !Ent2:IsWorld() && Ent2:GetTable().ConstraintSystem && Ent2:GetTable().ConstraintSystem:IsValid() ) then 
				System = Ent2:GetTable().ConstraintSystem
			end
			-- Don't add to this system - we have too many constraints on it already.
			if ( System && System:IsValid() && System:GetVar( "constraints", 0 ) > MAX_CONSTRAINTS_PER_SYSTEM ) then System = nil end
			-- No constraint system yet (Or they're both full) - make a new one
			if ( !System || !System:IsValid() ) then
				--Msg("New Constrant System\n")
				System = CreateConstraintSystem()
			end
			Ent1.ConstraintSystem = System
			Ent2.ConstraintSystem = System
			System.UsedEntities = System.UsedEntities or {}
			table.insert( System.UsedEntities, Ent1 )
			table.insert( System.UsedEntities, Ent2 )
			local ConstraintNum = System:GetVar( "constraints", 0 )
			System:SetVar( "constraints", ConstraintNum + 1 )
			--Msg("System has "..tostring( System:GetVar( "constraints", 0 ) ).." constraints\n")
			return System
		end
	//end ripped constraint functions here.

	//multiple-point "beam" effects use a constraint so the duplicator can group the two entities together
	function constraint.AttachParticleControllerBeam( Ent1, Ent2, Data, ply )
		if !Ent1 or !Ent2 then return end

		//onStartConstraint( Ent1, Ent2 )
		local system = FindOrCreateConstraintSystem( Ent1, Ent2 )
		SetPhysConstraintSystem( system )
		
		//create a dummy ent for the constraint functions to use
		local Constraint = ents.Create("logic_collision_pair")
		Constraint:Spawn()
		Constraint:Activate()



		local ParticleControlBeam = ents.Create( "particlecontroller_normal" )
		ParticleControlBeam:SetPos(Ent1:GetPos())
		ParticleControlBeam:SetAngles(Ent1:GetAngles())
		ParticleControlBeam:SetParent(Ent1)
		Ent1:DeleteOnRemove(ParticleControlBeam)
		Ent2:DeleteOnRemove(ParticleControlBeam)

		ParticleControlBeam:SetTargetEnt(Ent1)
		ParticleControlBeam:SetTargetEnt2(Ent2)
		ParticleControlBeam:SetEffectName(Data.EffectName)
		ParticleControlBeam:SetAttachNum(Data.AttachNum)
		ParticleControlBeam:SetAttachNum2(Data.AttachNum2)
		ParticleControlBeam:SetUtilEffectInfo(Data.UtilEffectInfo)
		if Data.ColorInfo != nil then ParticleControlBeam:SetColor(Data.ColorInfo) else ParticleControlBeam:SetColor( Color(0,0,0,0) ) end

		ParticleControlBeam:SetRepeatRate(Data.RepeatRate)
		if Data.RepeatSafety == 1 or Data.RepeatSafety == true then ParticleControlBeam:SetRepeatSafety(true) else ParticleControlBeam:SetRepeatSafety(false) end

		if Data.StartOn == 1 or Data.StartOn == true then ParticleControlBeam:SetActive(true) else ParticleControlBeam:SetActive(false) end
		if Data.Toggle == 1 or Data.Toggle ==  true then ParticleControlBeam:SetToggle(true) else ParticleControlBeam:SetToggle(false) end
		ParticleControlBeam:SetNumpadKey(Data.NumpadKey)

		numpad.OnDown( 	 ply, 	Data.NumpadKey, 	"Particle_Press", 	ParticleControlBeam )
		numpad.OnUp( 	 ply, 	Data.NumpadKey, 	"Particle_Release", 	ParticleControlBeam )
		ParticleControlBeam:SetNumpadState("")

		ParticleControlBeam:Spawn()
		ParticleControlBeam:Activate()
		


		//onFinishConstraint( Ent1, Ent2 )
		SetPhysConstraintSystem( NULL )

		constraint.AddConstraintTable( Ent1, Constraint, Ent2 )
		
		local ctable  = 
		{
			Type  = "AttachParticleControllerBeam",
			Ent1  = Ent1,
			Ent2  = Ent2,
			Data  = Data,
			ply   = ply,
		}
	
		Constraint:SetTable( ctable )
	
		return Constraint
	end
	duplicator.RegisterConstraint( "AttachParticleControllerBeam", constraint.AttachParticleControllerBeam, "Ent1", "Ent2", "Data", "ply" )

end




//we're still testing out a lot of stuff with the cpanel, so let's add a way to refresh it by reselecting the tool
--[[
TOOL.ClientConVar[ "refresh" ] = 1
function TOOL:Think()
	if SERVER then return end
	if self:GetClientNumber("refresh") == 1 then
		RunConsoleCommand("particlecontrol_refresh", "0");
		//refresh the cpanel
		local panel = controlpanel.Get( "particlecontrol" )
		if ( !panel ) then return end
		panel:ClearControls()
		self.BuildCPanel(panel)
	end
end
function TOOL:Deploy()
	RunConsoleCommand("particlecontrol_refresh", "1");
end
]]

local ConVarsDefault = TOOL:BuildConVarList()
ConVarsDefault["particlecontrol_attachnum"] = nil  //don't save the attachnum in presets, it's used by the other tools too

function TOOL.BuildCPanel(panel)

	panel:AddControl( "Header", { Description = "#tool.particlecontrol.help" } )

	//Presets
	panel:AddControl( "ComboBox", { 
		MenuButton = 1, 
		Folder = "particlecontrol", 
		Options = { 
			[ "#preset.default" ] = ConVarsDefault
		}, 
		CVars = table.GetKeys( ConVarsDefault ) 
	} )



	AddParticleBrowser(panel, { 
		name = "Effect", 
		commands = { 
			effectname = "particlecontrol_effectname", 
			mode_beam = "particlecontrol_mode_beam",
			color = "particlecontrol_color",
			utileffect = "particlecontrol_utileffect",
		}, 
	})



	//panel:AddControl( "Label", { Text = "" }  )
	panel:AddControl( "Label", { Text = "" }  )



	panel:AddControl("Slider", {
		Label = "Attachment",
	 	Type = "Integer",
		Min = "0",
		Max = "10",
		Command = "particlecontrol_attachnum",
	})
	panel:ControlHelp( "Attachment point on the model to use. Set to 0 to attach to the model origin or to attach model-covering effects to the entire model." )

	panel:AddControl("Slider", {
		Label = "Repeat Rate",
	 	Type = "Float",
		Min = "0",
		Max = "5",
		Command = "particlecontrol_repeatrate",
	})
	panel:ControlHelp( "How often the effect plays. Set to 0 to not repeat." )

	panel:AddControl( "CheckBox", { Label = "Repeat Safety", Command = "particlecontrol_repeatsafety" } )
	panel:ControlHelp( "If on, effects are removed before being repeated. This stops them from piling up endlessly, but can also cause small problems, like effects being cut off. You should probably keep this on unless you know what you're doing." )



	panel:AddControl( "Label", { Text = "" }  )
	panel:AddControl( "Label", { Text = "" }  )



	local modellist = { Label = "Prop", ConVar = "particlecontrol_propmodel", Category = "Prop", Height = 1, Models = {} }
	modellist.Models["models/hunter/plates/plate025x025.mdl"] = {}
	modellist.Models["models/hunter/plates/plate.mdl"] = {}
	modellist.Models["models/weapons/w_smg1.mdl"] = {}
	modellist.Models["models/props_junk/popcan01a.mdl"] = {}
	panel:AddControl( "PropSelect", modellist )

	panel:AddControl( "ComboBox",  {
		Label = "Prop Angle", 
		MenuButton = "0", 
		Options = {
			["Spawn upright"] = { particlecontrol_propangle = "1" },
			["Spawn at surface angle"] = { particlecontrol_propangle = "2" }
		}
	})

	panel:AddControl( "CheckBox", { Label = "Invisible prop (particles only)", Command = "particlecontrol_propinvis" } )



	panel:AddControl( "Label", { Text = "" }  )
	panel:AddControl( "Label", { Text = "" }  )



	panel:AddControl( "Numpad", {
		Label = "Effect Key",
		Command = "particlecontrol_numpadkey",
	})

	panel:AddControl( "CheckBox", { Label = "Toggle", Command = "particlecontrol_toggle" } )

	panel:AddControl( "CheckBox", { Label = "Start on?", Command = "particlecontrol_starton" } )

end

--lua/weapons/gmod_tool/stools/particlecontrol_tracer.lua:
TOOL.Category = "Particle Controller"
TOOL.Name = "ParCtrl - Tracers"
TOOL.Command = nil
TOOL.ConfigName = "" 

TOOL.HighlightedEnt = nil
 
TOOL.ClientConVar[ "effectname" ] = "!UTILEFFECT!AR2Tracer"
//TOOL.ClientConVar[ "utileffect_scale" ] = "1"
//TOOL.ClientConVar[ "utileffect_magnitude" ] = "1"
//TOOL.ClientConVar[ "utileffect_radius" ] = "10"
TOOL.ClientConVar[ "color_enabled" ] = "0"
TOOL.ClientConVar[ "color_r" ] = "255"
TOOL.ClientConVar[ "color_g" ] = "20"
TOOL.ClientConVar[ "color_b" ] = "0"
TOOL.ClientConVar[ "color_outofone" ] = "0"

TOOL.ClientConVar[ "impactfx_enabled" ] = "1"
TOOL.ClientConVar[ "impactfx_effectname" ] = "!UTILEFFECT!AR2Impact"
TOOL.ClientConVar[ "impactfx_utileffect_scale" ] = "1"
TOOL.ClientConVar[ "impactfx_utileffect_magnitude" ] = "1"
TOOL.ClientConVar[ "impactfx_utileffect_radius" ] = "10"
TOOL.ClientConVar[ "impactfx_color_enabled" ] = "0"
TOOL.ClientConVar[ "impactfx_color_r" ] = "255"
TOOL.ClientConVar[ "impactfx_color_g" ] = "20"
TOOL.ClientConVar[ "impactfx_color_b" ] = "0"
TOOL.ClientConVar[ "impactfx_color_outofone" ] = "0"

//TOOL.ClientConVar[ "attachnum" ] = "1"   //we're using the standard tool's attachnum var instead so that the selected attachment stays consistent when swapping between tools
TOOL.ClientConVar[ "repeatrate" ] = "0.1"
TOOL.ClientConVar[ "effectlifetime" ] = "1.0"

TOOL.ClientConVar[ "tracerspread" ] = "0.02"
TOOL.ClientConVar[ "tracercount" ] = "1"
TOOL.ClientConVar[ "leavebulletholes" ] = "1"

TOOL.ClientConVar[ "propmodel" ] = "models/weapons/w_smg1.mdl"
TOOL.ClientConVar[ "propangle" ] = "2"
TOOL.ClientConVar[ "propinvis" ] = "0"

TOOL.ClientConVar[ "numpadkey" ] = "52"
TOOL.ClientConVar[ "toggle" ] = "1"
TOOL.ClientConVar[ "starton" ] = "1"

TOOL.Information = {
	{ name = "left0", stage = 0, icon = "gui/lmb.png" },
	{ name = "middle0", stage = 0, icon = "gui/mmb.png" },
	{ name = "right0", stage = 0, icon = "gui/rmb.png" },
	{ name = "reload0", stage = 0, icon = "gui/r.png" },
}

if ( CLIENT ) then
	language.Add( "tool.particlecontrol_tracer.name", "Adv. Particle Controller - Tracers" )
	language.Add( "tool.particlecontrol_tracer.desc", "Attach tracer effects to things" )
	language.Add( "tool.particlecontrol_tracer.help", "Tracer effects are particles that fire out like bullets, with one end at the attachment and the other end where the \"bullet\"  hits something." )

	language.Add( "tool.particlecontrol_tracer.left0", "Add a tracer effect to an object" )
	language.Add( "tool.particlecontrol_tracer.middle0", "Scroll through an object's attachments" )
	language.Add( "tool.particlecontrol_tracer.right0", "Attach a new prop with the tracer effect on it" )
	language.Add( "tool.particlecontrol_tracer.reload0", "Remove all tracer effects from an object" )
end

util.PrecacheSound("weapons/pistol/pistol_empty.wav")




function TOOL:LeftClick( trace )

	local effectname = self:GetClientInfo( "effectname", 0 )
	local attachnum = self:GetOwner():GetInfoNum( "particlecontrol_attachnum", 0 )   //use the standard tool's attachnum var

	local repeatrate  = self:GetClientNumber( "repeatrate", 0 )

	local numpadkey  = self:GetClientNumber( "numpadkey", 0 )
	local toggle  = self:GetClientNumber( "toggle", 0 )
	local starton  = self:GetClientNumber( "starton", 0 )

	//local utileffectinfo = Vector( self:GetClientNumber( "utileffect_scale", 0 ), self:GetClientNumber( "utileffect_magnitude", 0 ), self:GetClientNumber( "utileffect_radius", 0 ) )
	local colorinfo = nil
	if self:GetClientNumber( "color_enabled", 0 ) == 1 then
		if self:GetClientNumber( "color_outofone", 0 ) == 1 then
			colorinfo = Color( self:GetClientNumber( "color_r", 0 ), self:GetClientNumber( "color_g", 0 ), self:GetClientNumber( "color_b", 0 ), 1 )  //we're using the alpha value to store color_outofone
		else
			colorinfo = Color( self:GetClientNumber( "color_r", 0 ), self:GetClientNumber( "color_g", 0 ), self:GetClientNumber( "color_b", 0 ), 0 )
		end
	end

	local tracerspread = self:GetClientNumber( "tracerspread", 0 )
	local tracercount = self:GetClientNumber( "tracercount", 0 )
	local leavebulletholes = self:GetClientNumber( "leavebulletholes", 0 )
	local effectlifetime = self:GetClientNumber( "effectlifetime", 0 )

	local impactinfo = nil
	if self:GetClientNumber( "impactfx_enabled", 0 ) == 1 then
		impactinfo = {
			effectname = self:GetClientInfo( "impactfx_effectname", 0 ),
			utileffectinfo = Vector( self:GetClientNumber( "impactfx_utileffect_scale", 0 ), self:GetClientNumber( "impactfx_utileffect_magnitude", 0 ), self:GetClientNumber( "impactfx_utileffect_radius", 0 ) ),
		}
		if self:GetClientNumber( "impactfx_color_enabled", 0 ) == 1 then
			if self:GetClientNumber( "impactfx_color_outofone", 0 ) == 1 then
				impactinfo.colorinfo = Color( self:GetClientNumber( "impactfx_color_r", 0 ), self:GetClientNumber( "impactfx_color_g", 0 ), self:GetClientNumber( "impactfx_color_b", 0 ), 1 )  //we're using the alpha value to store color_outofone
			else
				impactinfo.colorinfo = Color( self:GetClientNumber( "impactfx_color_r", 0 ), self:GetClientNumber( "impactfx_color_g", 0 ), self:GetClientNumber( "impactfx_color_b", 0 ), 0 )
			end
		end
	end

	local ply = self:GetOwner()



	if ( trace.Entity:IsValid() ) then
		if CLIENT then return true end
		if trace.Entity:GetClass() == "prop_effect" and trace.Entity.AttachedEntity then trace.Entity = trace.Entity.AttachedEntity end
		AttachParticleControllerTracer( ply, trace.Entity, { NewTable = { 
			EffectName = effectname, 
			AttachNum = attachnum, 

			RepeatRate = repeatrate, 

			Toggle = toggle, 
			StartOn = starton, 
			NumpadKey = numpadkey, 

			ColorInfo = colorinfo, 

			TracerSpread = tracerspread, 
			TracerCount = tracercount, 
			LeaveBulletHoles = leavebulletholes, 
			EffectLifetime = effectlifetime,

			ImpactInfo = impactinfo,
		} } )
		return true
	end

end




function TOOL:RightClick( trace )

	local effectname = self:GetClientInfo( "effectname", 0 )
	local attachnum = self:GetOwner():GetInfoNum( "particlecontrol_attachnum", 0 )   //use the standard tool's attachnum var

	local repeatrate  = self:GetClientNumber( "repeatrate", 0 )

	local numpadkey  = self:GetClientNumber( "numpadkey", 0 )
	local toggle  = self:GetClientNumber( "toggle", 0 )
	local starton  = self:GetClientNumber( "starton", 0 )

	//local utileffectinfo = Vector( self:GetClientNumber( "utileffect_scale", 0 ), self:GetClientNumber( "utileffect_magnitude", 0 ), self:GetClientNumber( "utileffect_radius", 0 ) )
	local colorinfo = nil
	if self:GetClientNumber( "color_enabled", 0 ) == 1 then
		if self:GetClientNumber( "color_outofone", 0 ) == 1 then
			colorinfo = Color( self:GetClientNumber( "color_r", 0 ), self:GetClientNumber( "color_g", 0 ), self:GetClientNumber( "color_b", 0 ), 1 )  //we're using the alpha value to store color_outofone
		else
			colorinfo = Color( self:GetClientNumber( "color_r", 0 ), self:GetClientNumber( "color_g", 0 ), self:GetClientNumber( "color_b", 0 ), 0 )
		end
	end

	local tracerspread = self:GetClientNumber( "tracerspread", 0 )
	local tracercount = self:GetClientNumber( "tracercount", 0 )
	local leavebulletholes = self:GetClientNumber( "leavebulletholes", 0 )
	local effectlifetime = self:GetClientNumber( "effectlifetime", 0 )

	local impactinfo = nil
	if self:GetClientNumber( "impactfx_enabled", 0 ) == 1 then
		impactinfo = {
			effectname = self:GetClientInfo( "impactfx_effectname", 0 ),
			utileffectinfo = Vector( self:GetClientNumber( "impactfx_utileffect_scale", 0 ), self:GetClientNumber( "impactfx_utileffect_magnitude", 0 ), self:GetClientNumber( "impactfx_utileffect_radius", 0 ) ),
		}
		if self:GetClientNumber( "impactfx_color_enabled", 0 ) == 1 then
			if self:GetClientNumber( "impactfx_color_outofone", 0 ) == 1 then
				impactinfo.colorinfo = Color( self:GetClientNumber( "impactfx_color_r", 0 ), self:GetClientNumber( "impactfx_color_g", 0 ), self:GetClientNumber( "impactfx_color_b", 0 ), 1 )  //we're using the alpha value to store color_outofone
			else
				impactinfo.colorinfo = Color( self:GetClientNumber( "impactfx_color_r", 0 ), self:GetClientNumber( "impactfx_color_g", 0 ), self:GetClientNumber( "impactfx_color_b", 0 ), 0 )
			end
		end
	end

	local ply = self:GetOwner()



	local propmodel = self:GetClientInfo( "propmodel", 0 )
	local propangle = self:GetClientNumber( "propangle", 0 )
	//propangle 1: spawn upright
	//propangle 2: spawn at surface angle

	if !util.IsValidModel(propmodel) then return false end
	if !util.IsValidProp(propmodel) then return false end
	if CLIENT then return true end

	prop = ents.Create( "prop_physics" )
		prop:SetModel( propmodel )
		prop:SetPos( trace.HitPos - trace.HitNormal * prop:OBBMins().z )
		if propangle == 1 then prop:SetAngles(Angle(0,trace.HitNormal:Angle().y,0)) else prop:SetAngles(trace.HitNormal:Angle()) end
		prop:SetCollisionGroup(20) //COLLISION_GROUP_NONE, nocollide with everything except world
	prop:Spawn()

	local shouldweweld = true									    //don't weld if...
	if ( !util.IsValidPhysicsObject(prop, 0) ) then shouldweweld = false end			    //the prop doesn't have a phys object
	if ( !trace.Entity:IsValid() ) then shouldweweld = false end					    //the thing we clicked on doesn't exist/is the world
	if ( trace.Entity && trace.Entity:IsPlayer() ) then shouldweweld = false end			    //the thing we clicked on is a player
	if ( !util.IsValidPhysicsObject( trace.Entity, trace.PhysicsBone ) ) then shouldweweld = false end  //the thing we clicked on doesn't have a phys object
	if shouldweweld == true then
		local const = constraint.Weld( prop, trace.Entity, 0, trace.PhysicsBone, 0, true, true )
	else
		if util.IsValidPhysicsObject(prop, 0) then prop:GetPhysicsObject():EnableMotion(false) end
	end

	if self:GetClientNumber( "propinvis", 0 ) == 1 then
		prop:SetRenderMode(1)  //we need to change the render mode so the transparency actually shows up
		prop:SetColor( Color(255,255,255,0) )
		duplicator.StoreEntityModifier( prop, "colour", { Color = Color(255,255,255,0), RenderMode = 1, RenderFX = 0 } )
	end

	undo.Create( "prop" )
		undo.AddEntity( prop )
		undo.SetPlayer( ply )
	undo.Finish( "Prop ("..tostring(propmodel)..")" )



	if ( prop:IsValid() ) then
		AttachParticleControllerTracer( ply, prop, { NewTable = { 
			EffectName = effectname, 
			AttachNum = attachnum, 

			RepeatRate = repeatrate, 

			Toggle = toggle, 
			StartOn = starton, 
			NumpadKey = numpadkey, 

			ColorInfo = colorinfo, 

			TracerSpread = tracerspread, 
			TracerCount = tracercount, 
			LeaveBulletHoles = leavebulletholes, 
			EffectLifetime = effectlifetime,

			ImpactInfo = impactinfo,
		} } )
		return true
	end

end




function TOOL:Reload( trace )

	if ( trace.Entity:IsValid() ) then
		local fx = false

		if trace.Entity:GetClass() == "prop_effect" and trace.Entity.AttachedEntity then trace.Entity = trace.Entity.AttachedEntity end

		for _, asdf in pairs( ents:GetAll() ) do
			if asdf:GetClass() == "particlecontroller_tracer" and asdf:GetParent() == trace.Entity then 
				if SERVER then asdf:Remove() end
				fx = true
			end
		end
		if SERVER then
			duplicator.ClearEntityModifier( trace.Entity, "DupeParticleControllerTracer" )
		end

		return fx
	end
	
end




if CLIENT then

	local colorborder   = Color(0,0,0,255)
	local colorselect   = Color(0,255,0,255)
	local colorunselect = Color(255,255,255,255)

	function TOOL:DrawHUD()
		local pl = LocalPlayer()
		local tr = pl:GetEyeTrace()
		local attachnum = self:GetOwner():GetInfoNum( "particlecontrol_attachnum", 0 )   //use the standard tool's attachnum var

		local function DrawHighlightAttachments(ent)

			//If there aren't any attachments, then draw the model origin as selected and stop here:
			if !ent:GetAttachments() or !ent:GetAttachments()[1] then
				local _pos,_ang = ent:GetPos(), ent:GetAngles()
				local _pos = _pos:ToScreen()
				local textpos = {x = _pos.x+5,y = _pos.y-5}

				draw.RoundedBox(0,_pos.x - 3,_pos.y - 3,6,6,colorborder)
				draw.RoundedBox(0,_pos.x - 1,_pos.y - 1,2,2,colorselect)
				draw.SimpleTextOutlined("0: (origin)","Default",textpos.x,textpos.y,colorselect,TEXT_ALIGN_LEFT,TEXT_ALIGN_BOTTOM,2,colorborder)

				return
			end


			//Draw the unselected model origin, if applicable:
			if ent:GetAttachments()[attachnum] then
				local _pos,_ang = ent:GetPos(), ent:GetAngles()
				local _pos = _pos:ToScreen()
				local textpos = {x = _pos.x+5,y = _pos.y-5}

				draw.RoundedBox(0,_pos.x - 2,_pos.y - 2,4,4,colorborder)
				draw.RoundedBox(0,_pos.x - 1,_pos.y - 1,2,2,colorunselect)
				draw.SimpleTextOutlined("0: (origin)","Default",textpos.x,textpos.y,colorunselect,TEXT_ALIGN_LEFT,TEXT_ALIGN_BOTTOM,1,colorborder)
			end

			//Draw the unselected attachment points:
			for _, table in pairs(ent:GetAttachments()) do
				local _pos,_ang = ent:GetAttachment(table.id).Pos,ent:GetAttachment(table.id).Ang
				local _pos = _pos:ToScreen()
				local textpos = {x = _pos.x+5,y = _pos.y-5}

				if table.id != attachnum then
					draw.RoundedBox(0,_pos.x - 2,_pos.y - 2,4,4,colorborder)
					draw.RoundedBox(0,_pos.x - 1,_pos.y - 1,2,2,colorunselect)
					draw.SimpleTextOutlined(table.id ..": ".. table.name,"Default",textpos.x,textpos.y,colorunselect,TEXT_ALIGN_LEFT,TEXT_ALIGN_BOTTOM,1,colorborder)
				end
			end
			
			//Draw the selected attachment point or model origin last, so it renders above all the others:
			if !ent:GetAttachments()[attachnum] then
				//Model origin
				local _pos,_ang = ent:GetPos(), ent:GetAngles()
				local _pos = _pos:ToScreen()
				local textpos = {x = _pos.x+5,y = _pos.y-5}

				draw.RoundedBox(0,_pos.x - 3,_pos.y - 3,6,6,colorborder)
				draw.RoundedBox(0,_pos.x - 1,_pos.y - 1,2,2,colorselect)
				draw.SimpleTextOutlined("0: (origin)","Default",textpos.x,textpos.y,colorselect,TEXT_ALIGN_LEFT,TEXT_ALIGN_BOTTOM,2,colorborder)
			else
				//Attachment
				local _pos,_ang = ent:GetAttachment(attachnum).Pos,ent:GetAttachment(attachnum).Ang
				local _pos = _pos:ToScreen()
				local textpos = {x = _pos.x+5,y = _pos.y-5}

				draw.RoundedBox(0,_pos.x - 3,_pos.y - 3,6,6,colorborder)
				draw.RoundedBox(0,_pos.x - 1,_pos.y - 1,2,2,colorselect)
				draw.SimpleTextOutlined(attachnum ..": ".. ent:GetAttachments()[attachnum].name,"Default",textpos.x,textpos.y,colorselect,TEXT_ALIGN_LEFT,TEXT_ALIGN_BOTTOM,2,colorborder)
			end
		end

		if IsValid(tr.Entity) and tr.Entity == self.HighlightedEnt then
			DrawHighlightAttachments(self.HighlightedEnt) 
		return end

		if IsValid(tr.Entity) and tr.Entity != self.HighlightedEnt then
			//unhighlight the old ent if it exists
			if self.HighlightedEnt != nil then
				self.HighlightedEnt = nil
			end

			//highlight the new ent
			self.HighlightedEnt = tr.Entity
		end

		if !IsValid(tr.Entity) and self.HighlightedEnt != nil then
			self.HighlightedEnt = nil
		end
	end

	function TOOL:Holster()
		if self.HighlightedEnt != nil then
			self.HighlightedEnt = nil
		end
	end




	//All credit for the toolgun scroll wheel code goes to the Wiremod devs. You guys are the best.
		local function get_active_tool(ply, tool)
			-- find toolgun
			local activeWep = ply:GetActiveWeapon()
			if not IsValid(activeWep) or activeWep:GetClass() ~= "gmod_tool" or activeWep.Mode ~= tool then return end

			return activeWep:GetToolObject(tool)
		end

		local function hookfunc( ply, bind, pressed )
			if not pressed then return end
			if bind == "invnext" then
				local self = get_active_tool(ply, "particlecontrol_tracer")
				if not self then return end
			
				return self:ScrollDown(ply:GetEyeTraceNoCursor())
			elseif bind == "invprev" then
				local self = get_active_tool(ply, "particlecontrol_tracer")
				if not self then return end

				return self:ScrollUp(ply:GetEyeTraceNoCursor())
			end
		end
	
		if game.SinglePlayer() then -- wtfgarry (have to have a delay in single player or the hook won't get added)
			timer.Simple(5,function() hook.Add( "PlayerBindPress", "particlecontrol_tracer_playerbindpress", hookfunc ) end)
		else
			hook.Add( "PlayerBindPress", "particlecontrol_tracer_playerbindpress", hookfunc )
		end
	//End shamefully copied code here.

	function TOOL:Scroll(trace,dir)
		if !IsValid(self.HighlightedEnt) then return end

		local attachcount = 0
		if self.HighlightedEnt:GetAttachments() then attachcount = table.Count(self.HighlightedEnt:GetAttachments()) end
		local oldattachnum = self:GetOwner():GetInfoNum( "particlecontrol_attachnum", 0 )   //use the standard tool's attachnum var
		if oldattachnum > attachcount then oldattachnum = 0 end
		local attachnum = oldattachnum + dir

		if attachnum < 0 then attachnum = attachcount end
		if attachnum > attachcount then attachnum = 0 end
		RunConsoleCommand("particlecontrol_attachnum", tostring(attachnum))   //use the standard tool's attachnum var
		self:GetOwner():EmitSound("weapons/pistol/pistol_empty.wav")
		return true
	end
	function TOOL:ScrollUp(trace) return self:Scroll(trace,-1) end
	function TOOL:ScrollDown(trace) return self:Scroll(trace,1) end

end




if SERVER then

	local function SpawnParticleControllerTracer(ply, ent, DataTable)

		if DataTable == nil or DataTable == {} or DataTable.EffectName == nil or ent == nil or !IsValid(ent) then return end


		local ParticleControlTracer = ents.Create( "particlecontroller_tracer" )
		ParticleControlTracer:SetPos(ent:GetPos())
		ParticleControlTracer:SetAngles(ent:GetAngles())
		ParticleControlTracer:SetParent(ent)
		ent:DeleteOnRemove(ParticleControlTracer)

		ParticleControlTracer:SetTargetEnt(ent)
		ParticleControlTracer:SetEffectName(DataTable.EffectName)
		ParticleControlTracer:SetAttachNum(DataTable.AttachNum)
		//ParticleControlTracer:SetUtilEffectInfo(DataTable.UtilEffectInfo)
		if DataTable.ColorInfo != nil then ParticleControlTracer:SetColor(DataTable.ColorInfo) else ParticleControlTracer:SetColor( Color(0,0,0,0) ) end

		ParticleControlTracer:SetTracerSpread(DataTable.TracerSpread)
		ParticleControlTracer:SetTracerCount(DataTable.TracerCount)
		if DataTable.LeaveBulletHoles == 1 or DataTable.LeaveBulletHoles == true then ParticleControlTracer:SetLeaveBulletHoles(true) else ParticleControlTracer:SetLeaveBulletHoles(false) end
		ParticleControlTracer:SetEffectLifetime(DataTable.EffectLifetime or 1.00)  //old dupes will have nil

		if DataTable.ImpactInfo != nil then
			ParticleControlTracer:SetImpact_EffectName(DataTable.ImpactInfo.effectname)
			ParticleControlTracer:SetImpact_UtilEffectInfo(DataTable.ImpactInfo.utileffectinfo)
			if DataTable.ImpactInfo.colorinfo != nil then
				local impactcolor = Vector(DataTable.ImpactInfo.colorinfo.r, DataTable.ImpactInfo.colorinfo.g, DataTable.ImpactInfo.colorinfo.b)
				if DataTable.ImpactInfo.colorinfo.a then
					impactcolor = impactcolor / 255
				end
				ParticleControlTracer:SetImpact_ColorInfo( impactcolor )
			else
				ParticleControlTracer:SetImpact_ColorInfo( Vector(0,0,0) )
			end
		else
			ParticleControlTracer:SetImpact_EffectName("")
		end

		ParticleControlTracer:SetRepeatRate(DataTable.RepeatRate)


		if DataTable.StartOn == 1 or DataTable.StartOn == true then ParticleControlTracer:SetActive(true) else ParticleControlTracer:SetActive(false) end
		if DataTable.Toggle == 1 or DataTable.Toggle == true then ParticleControlTracer:SetToggle(true) else ParticleControlTracer:SetToggle(false) end
		ParticleControlTracer:SetNumpadKey(DataTable.NumpadKey)

		numpad.OnDown( 	 ply, 	DataTable.NumpadKey, 	"Particle_Press", 	ParticleControlTracer )
		numpad.OnUp( 	 ply, 	DataTable.NumpadKey, 	"Particle_Release", 	ParticleControlTracer )
		ParticleControlTracer:SetNumpadState("")


		ParticleControlTracer:Spawn()
		ParticleControlTracer:Activate()

	end


	function AttachParticleControllerTracer( ply, ent, Data )

		if Data.NewTable then
			SpawnParticleControllerTracer(ply, ent, Data.NewTable)

			local dupetable = {}
			if ent.EntityMods and ent.EntityMods.DupeParticleControllerTracer then dupetable = ent.EntityMods.DupeParticleControllerTracer end
			table.insert(dupetable, Data.NewTable)
			duplicator.StoreEntityModifier( ent, "DupeParticleControllerTracer", dupetable )
		return end

	end


	function DupeParticleControllerTracer( ply, ent, Data )

		//due to a problem with the easy bonemerge tool that causes entity modifiers to be applied TWICE, we need to remove the effects that were added the first time
		for _, asdf in pairs( ents:GetAll() ) do
			if asdf:GetClass() == "particlecontroller_tracer" and asdf:GetParent() == ent then
				asdf:Remove()
			end
		end

		for _, DataTable in pairs (Data) do
			SpawnParticleControllerTracer(ply, ent, DataTable)
		end

	end
	duplicator.RegisterEntityModifier( "DupeParticleControllerTracer", DupeParticleControllerTracer )

end




//we're still testing out a lot of stuff with the cpanel, so let's add a way to refresh it by reselecting the tool
--[[
TOOL.ClientConVar[ "refresh" ] = 1
function TOOL:Think()
	if SERVER then return end
	if self:GetClientNumber("refresh") == 1 then
		RunConsoleCommand("particlecontrol_tracer_refresh", "0");
		//refresh the cpanel
		local panel = controlpanel.Get( "particlecontrol_tracer" )
		if ( !panel ) then return end
		panel:ClearControls()
		self.BuildCPanel(panel)
	end
end
function TOOL:Deploy()
	RunConsoleCommand("particlecontrol_tracer_refresh", "1");
end
]]

local ConVarsDefault = TOOL:BuildConVarList()

function TOOL.BuildCPanel(panel)

	panel:AddControl( "Header", { Description = "#tool.particlecontrol_tracer.help" } )

	//Presets
	panel:AddControl( "ComboBox", { 
		MenuButton = 1, 
		Folder = "particlecontrol_tracer", 
		Options = { 
			//[ "#preset.default" ] = ConVarsDefault
			[ "Example: Pulse Rifle" ] = ConVarsDefault,
			[ "Example: Generic Bullets" ] = { particlecontrol_tracer_color_b = "0", particlecontrol_tracer_color_enabled = "0", particlecontrol_tracer_color_g = "20", particlecontrol_tracer_color_outofone = "0", particlecontrol_tracer_color_r = "255", particlecontrol_tracer_effectlifetime = "1.000000", particlecontrol_tracer_effectname = "!UTILEFFECT!Tracer", particlecontrol_tracer_impactfx_color_b = "0", particlecontrol_tracer_impactfx_color_enabled = "0", particlecontrol_tracer_impactfx_color_g = "20", particlecontrol_tracer_impactfx_color_outofone = "0", particlecontrol_tracer_impactfx_color_r = "255", particlecontrol_tracer_impactfx_effectname = "!UTILEFFECT!AR2Impact", particlecontrol_tracer_impactfx_enabled = "0", particlecontrol_tracer_impactfx_utileffect_magnitude = "1", particlecontrol_tracer_impactfx_utileffect_radius = "10", particlecontrol_tracer_impactfx_utileffect_scale = "1", particlecontrol_tracer_leavebulletholes = "1", particlecontrol_tracer_numpadkey = "52", 
							particlecontrol_tracer_propangle = "2", particlecontrol_tracer_propinvis = "0", particlecontrol_tracer_propmodel = "models/weapons/w_smg1.mdl", particlecontrol_tracer_repeatrate = "0.080000", particlecontrol_tracer_starton = "1", particlecontrol_tracer_toggle = "1", particlecontrol_tracer_tracercount = "1", particlecontrol_tracer_tracerspread = "0.050000" },
			[ "Example: Toolgun" ] = { particlecontrol_tracer_color_b = "0", particlecontrol_tracer_color_enabled = "0", particlecontrol_tracer_color_g = "20", particlecontrol_tracer_color_outofone = "0", particlecontrol_tracer_color_r = "255", particlecontrol_tracer_effectlifetime = "1.000000", particlecontrol_tracer_effectname = "!UTILEFFECT!ToolTracer", particlecontrol_tracer_impactfx_color_b = "0", particlecontrol_tracer_impactfx_color_enabled = "0", particlecontrol_tracer_impactfx_color_g = "20", particlecontrol_tracer_impactfx_color_outofone = "0", particlecontrol_tracer_impactfx_color_r = "255", particlecontrol_tracer_impactfx_effectname = "!UTILEFFECT!selection_indicator", particlecontrol_tracer_impactfx_enabled = "1", particlecontrol_tracer_impactfx_utileffect_magnitude = "1", particlecontrol_tracer_impactfx_utileffect_radius = "10", particlecontrol_tracer_impactfx_utileffect_scale = "1", particlecontrol_tracer_leavebulletholes = "0", particlecontrol_tracer_numpadkey = "52", 
							particlecontrol_tracer_propangle = "2", particlecontrol_tracer_propinvis = "0", particlecontrol_tracer_propmodel = "models/weapons/w_smg1.mdl", particlecontrol_tracer_repeatrate = "1", particlecontrol_tracer_starton = "1", particlecontrol_tracer_toggle = "1", particlecontrol_tracer_tracercount = "1", particlecontrol_tracer_tracerspread = "0" },
		}, 
		CVars = table.GetKeys( ConVarsDefault ) 
	} )



	AddParticleBrowserTracer(panel, { 
		name = "Tracer Effect", 
		commands = { 
			effectname = "particlecontrol_tracer_effectname", 
			color = "particlecontrol_tracer_color",
		}, 
	})



	//panel:AddControl( "Label", { Text = "" }  )
	//panel:AddControl( "Label", { Text = "" }  )



	panel:AddControl( "Checkbox", { Label = "Enable impact effects?", Command = "particlecontrol_tracer_impactfx_enabled" } )

	AddParticleBrowser(panel, { 
		name = "Impact Effect", 
		commands = { 
			effectname = "particlecontrol_tracer_impactfx_effectname", 
			color = "particlecontrol_tracer_impactfx_color",
			utileffect = "particlecontrol_tracer_impactfx_utileffect",

			enabled = "particlecontrol_tracer_impactfx_enabled",
		}, 
	})



	//panel:AddControl( "Label", { Text = "" }  )
	panel:AddControl( "Label", { Text = "" }  )



	panel:AddControl("Slider", {
		Label = "Attachment",
	 	Type = "Integer",
		Min = "0",
		Max = "10",
		Command = "particlecontrol_attachnum",   //use the standard tool's attachnum var
	})
	panel:ControlHelp( "Attachment point on the model to fire tracers from. Set to 0 to fire from the model origin." )

	panel:AddControl("Slider", {
		Label = "Repeat Rate",
	 	Type = "Float",
		Min = "0",
		Max = "1",
		Command = "particlecontrol_tracer_repeatrate"
	})
	panel:ControlHelp( "How often the tracer fires. Set to 0 to not repeat." )



	panel:AddControl( "Label", { Text = "" }  )
	panel:AddControl( "Label", { Text = "" }  )



	panel:AddControl("Slider", {
		Label = "Tracer Spread",
	 	Type = "Float",
		Min = "0",
		Max = "1",
		Command = "particlecontrol_tracer_tracerspread"
	})
	panel:ControlHelp( "Each unit is 90 degrees of spread - you can type in 2 for 180 degrees or even 4 for 360 degrees." )

	panel:AddControl("Slider", {
		Label = "Tracers per shot",
	 	Type = "Integer",
		Min = "1",
		Max = "10",
		Command = "particlecontrol_tracer_tracercount"
	})

	panel:AddControl( "Checkbox", { Label = "Leave bullet holes?", Command = "particlecontrol_tracer_leavebulletholes" } )

	panel:AddControl("Slider", {
		Label = "Effect Lifetime",
	 	Type = "Float",
		Min = "0.5",
		Max = "5",
		Command = "particlecontrol_tracer_effectlifetime"
	})
	//panel:ControlHelp( "Number of seconds before tracer and impact effects are removed." )



	panel:AddControl( "Label", { Text = "" }  )
	panel:AddControl( "Label", { Text = "" }  )



	local modellist = { Label = "Prop:", ConVar = "particlecontrol_tracer_propmodel", Category = "Prop", Height = 1, Models = {} }
	modellist.Models["models/hunter/plates/plate025x025.mdl"] = {}
	modellist.Models["models/hunter/plates/plate.mdl"] = {}
	modellist.Models["models/weapons/w_smg1.mdl"] = {}
	modellist.Models["models/weapons/w_models/w_shotgun.mdl"] = {}

	panel:AddControl( "PropSelect", modellist )

	panel:AddControl( "ComboBox",  {
		Label = "Prop Angle", 
		MenuButton = "0", 
		Options = {
			["Spawn upright"] = { particlecontrol_tracer_propangle = "1" },
			["Spawn at surface angle"] = { particlecontrol_tracer_propangle = "2" }
		}
	})

	panel:AddControl( "Checkbox", { Label = "Invisible prop (particles only)", Command = "particlecontrol_tracer_propinvis" } )



	panel:AddControl( "Label", { Text = "" }  )
	panel:AddControl( "Label", { Text = "" }  )



	panel:AddControl( "Numpad", {
		Label = "Effect Key",
		Command = "particlecontrol_tracer_numpadkey",
		ButtonSize = 22 
	})

	panel:AddControl( "Checkbox", { Label = "Toggle", Command = "particlecontrol_tracer_toggle" } )

	panel:AddControl( "Checkbox", { Label = "Start on?", Command = "particlecontrol_tracer_starton" } )

end
--lua/weapons/gmod_tool/stools/physparent.lua:
TOOL.Category = "Constraints"
TOOL.Name = "Physical Parent"

local function OwnershipTest(Player, Entity)
	if Entity.OnDieFunctions ~= nil then
		for k,v in pairs(Entity.OnDieFunctions) do
			if k == "GetCountUpdate" and v.Args ~= nil and v.Args[1] == Player  then return true end
			if string.sub(k,1,4) == "undo" and v.Args ~= nil and v.Args[2] == Player then return true end
		end
	end
	if g_SBoxObjects[Player:UniqueID()] ~= nil then
		for k, v in pairs(g_SBoxObjects[Player:UniqueID()]) do
			for k2, v2 in pairs(v) do
				if v2 == Entity then return true end
			end
		end
	end
	return false
end

local function RemoveConstraints(ent)
	if not IsValid(ent) then return end
	constraintTable = constraint.GetTable(ent)
	for k,v in pairs(constraintTable) do
		if v.Type == "WireHydraulic" and v.MyCrtl ~= nil then
			local controller = Entity(v.MyCrtl)
			v.Constraint:DontDeleteOnRemove(controller)
			v.Ent1:DontDeleteOnRemove(controller)
			v.Ent2:DontDeleteOnRemove(controller)
		end
	end
	constraint.RemoveAll(ent)
	local tab = ent:GetTable()
	if IsValid(tab.ConstraintSystem) then tab.ConstraintSystem:Remove() ent:GetTable().ConstraintSystem = nil end
	constraint.ForgetConstraints(ent)
	if tab.Constraints ~= nil then ent:GetTable().Constraints = nil end
end
local function RecreateConstraint(Constraint)
	local Factory = duplicator.ConstraintType[ Constraint.Type ]
	if ( !Factory ) then return end
	local Args = {}
	for k, Key in pairs( Factory.Args ) do
		local Val = Constraint[ Key ]
		for i=1, 6 do
			if ( Constraint.Entity[ i ] ) then
				if ( Key == "Ent"..i ) then
					Val = Entity( Constraint.Entity[ i ].Index )
					if ( Constraint.Entity[ i ].World ) then
						Val = game.GetWorld()
					end
				end
				if ( Key == "Bone" .. i ) then Val = Constraint.Entity[ i ].Bone or 0 end
				if ( Key == "LPos" .. i ) then Val = Constraint.Entity[ i ].LPos end
				if ( Key == "WPos" .. i ) then Val = Constraint.Entity[ i ].WPos end
				if ( Key == "Length" .. i ) then Val = Constraint.Entity[ i ].Length or 0 end
			end
		end
		if ( Val == nil ) then Val = false end
		table.insert( Args, Val )
	end
	local mycrtl = Args[13]
	if Constraint.Type == "WireHydraulic" then
		Args[13] = nil 
	end

	local e1 = nil
	local e2 = nil
	local e1ang = nil
	local e1pos = nil
	local e2ang = nil
	local e2pos = nil
	if Constraint.Entity[1] ~= nil and Constraint.Entity[2] ~= nil and Constraint.BuildDupeInfo ~= nil then
		e1 = Entity(Constraint.Entity[1].Index)
		e2 = Entity(Constraint.Entity[2].Index)
		e1ang = e1:GetAngles()
		e1pos = e1:GetPos()
		e2ang = e2:GetAngles()
		e2pos = e2:GetPos()
		if not IsValid(e2:GetParent()) then
			if Constraint.BuildDupeInfo.EntityPos ~= nil then e2:SetPos(e1pos - Constraint.BuildDupeInfo.EntityPos) end
			if Constraint.BuildDupeInfo.Ent2Ang ~= nil then e2:SetAngles(Constraint.BuildDupeInfo.Ent2Ang) end
		end
		if not IsValid(e1:GetParent()) and Constraint.BuildDupeInfo.Ent1Ang ~= nil then e1:SetAngles(Constraint.BuildDupeInfo.Ent1Ang) end
	end
	--
	local const, rope = Factory.Func( unpack(Args) )
	--
	if e1 ~= nil then
		if not IsValid(e1:GetParent()) then
			e1:SetPos(e1pos)
			e1:SetAngles(e1ang)
		end
		if not IsValid(e2:GetParent()) then
			e2:SetPos(e2pos)
			e2:SetAngles(e2ang)
		end
	end
	if Constraint.BuildDupeInfo ~= nil and IsValid(const) then
		const:GetTable().BuildDupeInfo = Constraint.BuildDupeInfo
	end
	--
	if Constraint.Type == "WireHydraulic" and isnumber(mycrtl) then
		local controller = Entity(mycrtl)
		controller:SetConstraint(const)
		if rope then controller:SetRope(rope) end
		const:GetTable().MyCrtl = controller:EntIndex()
		if controller.Inputs.Length.Src ~= nil then
			controller:SetLength(controller.Inputs.Length.Value)
		end
	end
end
local function RecreateConstraints(constraints)
	for k,v in pairs(constraints) do
		RecreateConstraint(v)
	end
end
local function GetGroupConv(group)
	local pent = Entity(group[1])
	local masterconv = {}
	for i = 1,#group do
		local ent = Entity(group[i])
		if IsValid(ent) then
			local convexes = {}
			if CLIENT then
				ent:PhysicsDestroy()
				ent:PhysicsInit(SOLID_VPHYSICS)
				if IsValid(ent:GetPhysicsObject()) then
					convexes = ent:GetPhysicsObject():GetMeshConvexes() 
				else
					return false 
				end
				ent:PhysicsDestroy()
				if i>1 then
					ent:SetNotSolid(true)
				end
			else
				if i == 1 then
					local tmp = ents.Create(ent:GetClass())
					tmp:SetModel(ent:GetModel())
					tmp:PhysicsInit(SOLID_VPHYSICS)
					convexes = tmp:GetPhysicsObject():GetMeshConvexes()
					tmp:Remove()
				else
					convexes = ent:GetPhysicsObject():GetMeshConvexes()
				end
			end
			local M = Matrix()
			M:Translate(pent:WorldToLocal(ent:GetPos()))
			M:Rotate(pent:WorldToLocalAngles(ent:GetAngles()))
			for j = 1, #convexes do
				local mcp = #masterconv+1
				masterconv[mcp] = {}
				for n = 1, #convexes[j] do
					masterconv[mcp][#masterconv[mcp]+1] = M*convexes[j][n]["pos"]
				end
			end
		end
	end
	return masterconv
end
local function Phys(group)
	local pent = Entity(group[1])
	local targetMass = pent:GetPhysicsObject():GetMass()
	local targetMaterial = pent:GetPhysicsObject():GetMaterial()
	local oldConstraints = constraint.GetTable(pent)
	local constrainedEnts = constraint.GetAllConstrainedEntities(pent)
	RemoveConstraints(pent)
	for k,v in pairs(constrainedEnts) do
		if v:GetTable().Constraints ~= nil then
			for k2,v2 in pairs(v:GetTable().Constraints) do
				if v2:GetTable().Ent1 == pent or v2:GetTable().Ent2 == pent then
					v2:Remove()
					v:GetTable().Constraints[k2] = nil
				end
			end
		end
		local physobj = v:GetPhysicsObject()
		if IsValid(physobj) then physobj:EnableMotion(false) end
	end
	if #group > 1 then
		pent:PhysicsInitMultiConvex(GetGroupConv(group))
	else
		pent:PhysicsInitMultiConvex(GetGroupConv({group[1]}))
		pent:PhysicsDestroy()
		pent:PhysicsInit(SOLID_VPHYSICS)
	end
	if group.obbmins ~= nil and #group > 1 then
		pent:EnableCustomCollisions(true)
	end
	pent:GetPhysicsObject():EnableDrag(false)
	pent:GetPhysicsObject():SetMass(targetMass)
	pent:GetPhysicsObject():SetMaterial(targetMaterial)
	pent:GetPhysicsObject():EnableMotion(false)
	pent:GetPhysicsObject():SetBuoyancyRatio(0)
	RecreateConstraints(oldConstraints)
	return pent
end
local function SendCLTable(ply)
	local cltable = {}
	for k,v in pairs(PhysParentTable) do
		if v.obbmins ~= nil then
			cltable[k] = {}
			table.CopyFromTo(v,cltable[k])
		end
	end
	net.Start("physparent_table") net.WriteTable(cltable) if IsValid(ply) then net.Send(ply) else net.Broadcast() end
end
local function Complexity(ent)
	local count = 0
	if IsValid(ent) then
		local conv = ent:GetPhysicsObject():GetMeshConvexes()
		for i = 1,#conv do
			count = count + #conv[i]
		end
	end
	return count
end
local function PlayerComplexity(ply)
	if not IsValid(ply) then return end
	local world = 0
	local selection = 0
	for k,v in pairs(PhysParentTable) do
		if v.ownerid == ply:SteamID() and IsValid(Entity(v[1])) then
			local tmp = ents.Create(Entity(v[1]):GetClass())
			tmp:SetModel(Entity(v[1]):GetModel())
			tmp:PhysicsInit(SOLID_VPHYSICS)
			world = world + Complexity(tmp)
			tmp:Remove()
			for i = 2,#v do
				world = world + Complexity(Entity(v[i]))
			end
		end
	end
	for k,v in pairs(ply.physparent.selected) do
		selection = selection + Complexity(v.ent)
	end
	return world+selection,world,selection
end
local function SendPlayerComplexity(ply)
	net.Start("physparent_complexity") 
		local a,b,c = PlayerComplexity(ply)
		net.WriteInt(b,32)
		net.WriteInt(c,32)
		net.WriteInt(GetConVar("sv_physparent_maxcomplexity"):GetInt(),32) 
	net.Send(ply)
end
local function Update(ent)
	if not IsValid(ent) or PhysParentTable[ent:EntIndex()] == nil then return end
	local group = PhysParentTable[ent:EntIndex()]
	local owner = player.GetBySteamID(group.ownerid)
	local i = 2
	while i <= #group do
		local tmp = Entity(group[i])
		if not IsValid(tmp) or tmp:GetParent() ~= ent then
			if IsValid(tmp) then
				duplicator.ClearEntityModifier(tmp,"physparent")
				tmp:SetNotSolid(false)
				tmp:RemoveCallOnRemove("physparent_onremove")
			end
			table.remove(group,i)
		else 
			i = i + 1
		end
	end
	ent.EntityMods.physparent.childcount = #group-1
	local oldStates ={}
	local constrainedEnts = constraint.GetAllConstrainedEntities(ent)
	for k,v in pairs(constrainedEnts) do
		physobj = v:GetPhysicsObject()
		if IsValid(physobj) and not IsValid(v:GetParent()) then
			oldStates[#oldStates+1] = {ent = v, vel = physobj:GetVelocity(), angvel = physobj:GetAngleVelocity(),moveable = physobj:IsMoveable()}
		end
	end
	Phys(group)
	if #group < 2 then
		PhysParentTable[ent:EntIndex()] = nil
		duplicator.ClearEntityModifier(ent,"physparent")
		ent:RemoveCallOnRemove("physparent_onremove")
	end
	for i = 1,#oldStates do
		oldStates[i].ent:GetPhysicsObject():EnableMotion(oldStates[i].moveable)
	end
	for i = 1,#oldStates do
		physobj = oldStates[i].ent:GetPhysicsObject()
		physobj:SetVelocityInstantaneous(oldStates[i].vel)
		physobj:AddAngleVelocity(oldStates[i].angvel)
	end
	SendCLTable(nil)
	SendPlayerComplexity(owner)
end
local function CreatePlayerTable(ply)
	ply.physparent = {physgunent = nil, selected = {}, dupetable = {}, notified = false}
	SendCLTable(ply)
	SendPlayerComplexity(ply)
end

if SERVER then
	PhysParentTable = PhysParentTable or {}
	physparent_uniquenum = 0
	
	CreateConVar("sv_physparent_maxcomplexity",2000)
	
	util.AddNetworkString("physparent_notify")
	util.AddNetworkString("physparent_table")
	util.AddNetworkString("physparent_pickup")
	util.AddNetworkString("physparent_complexity")
	
	local function DupeLoad(Player, Entity, Data)
		if Player.physparent == nil then CreatePlayerTable(Player) end
		if Data["normal"] == nil then
			if Data["group"] == nil then
				if not Player.physparent.notified then
					Player.physparent.notified = true
					Player:ChatPrint("Duplication contains Physical Parenting created using an outdated format, and has lost collision in some areas.")
				end
			else
				if Player.physparent.dupetable[Data["group"]] == nil then
					Player.physparent.dupetable[Data["group"]] = {0}
				end
				local group = Player.physparent.dupetable[Data["group"]]
				if Data["childcount"] ~= nil then 
					group[1] = Entity:EntIndex()
					if Data["enhanced"] then
						group.obbmins = Entity:OBBMins()
						group.obbmaxs = Entity:OBBMaxs()
					end
					group.childcount = Data["childcount"]
				else
					group[#group+1] = Entity:EntIndex()
				end
				if group.childcount ~= nil and #group-1 == group.childcount then
					local dupecomplexity = 0
					for k,v in pairs(Player.physparent.dupetable) do for i = 1,#v do dupecomplexity = dupecomplexity + Complexity(ents.GetByIndex(v[i])) end end
					if dupecomplexity + PlayerComplexity(Player) <= GetConVar("sv_physparent_maxcomplexity"):GetInt() then
						Phys(group):CallOnRemove("physparent_onremove",function(ent) PhysParentTable[ent:EntIndex()] = nil SendCLTable(nil) SendPlayerComplexity(Player) end)
					else
						net.Start("physparent_notify") net.WriteString("Exceeding limit (sv_physparent_maxcomplexity)") net.Send(Player)
						Player.physparent.dupetable[Data["group"]] = nil
					end
				end
			end
		end
		if Data["shadows"] then Entity:DrawShadow(false) end
		if Data["weight"] ~= nil then Entity:GetPhysicsObject():SetMass(0.1) end
	end
	duplicator.RegisterEntityModifier("physparent",DupeLoad)
	
	local function PostDupe(TimedPasteData, TimedPasteDataCurrent)
		if not IsValid(TimedPasteData[TimedPasteDataCurrent].Player) then return end
		local ply = TimedPasteData[TimedPasteDataCurrent].Player
		if ply.physparent == nil then CreatePlayerTable(ply) end
		ply.physparent.notified = false
		for k,v in pairs(ply.physparent.dupetable) do
			if v.childcount ~= nil and #v == v.childcount+1 then 
				v.childcount = nil
				v.ownerid = ply:SteamID()
				PhysParentTable[v[1]] = v
				local newgroup = "group"..os.time().."d"..CurTime().."u"..physparent_uniquenum physparent_uniquenum = physparent_uniquenum + 1
				for i = 1,#v do if v.obbmins ~= nil and i>1 then Entity(v[i]):SetNotSolid(true) end Entity(v[i]).EntityMods.physparent.group = newgroup end
			else
				net.Start("physparent_notify") net.WriteString("Duplication contains invalid physparents") net.Send(ply)
			end
		end
		ply.physparent.dupetable = {}
		SendCLTable(nil)
		SendPlayerComplexity(ply)
	end
	hook.Add("AdvDupe_FinishPasting","physparent_hook1",PostDupe)
	
	hook.Add("PlayerInitialSpawn","physparent_hook2",function(ply)
		CreatePlayerTable(ply)
	end)
	
	net.Receive("physparent_pickup",function(len, ply)
		if ply.physparent == nil then CreatePlayerTable(ply) end
		ply.physparent.physgunent = net.ReadEntity()
	end)
	
	hook.Add("PhysgunDrop","physparent_drop",function(ply, ent)
		if PhysParentTable[ent:EntIndex()] ~= nil then
			if ent:WaterLevel() > 0 then ent:GetPhysicsObject():Sleep() end
			timer.Create("physparent_buoyancy",0.01,1,function()
				ent:GetPhysicsObject():SetBuoyancyRatio(0)
				ent:GetPhysicsObject():Wake()
			end)
		end
	end)	
	
	hook.Add("PlayerFrozeObject","physparent_hookfroze",function(ply, ent, physobj)
		if isentity(ent) then
			local et = ent:GetTable()
			if et.EntityMods ~= nil and et.EntityMods.physparent ~= nil and et.EntityMods.physparent.enhanced then
				if ply.physparent ~= nil and IsValid(ply.physparent.physgunent) then
					local effectdata = EffectData()
					effectdata:SetOrigin( ply.physparent.physgunent:GetPos() )
					effectdata:SetEntity( ply.physparent.physgunent )
					util.Effect( "phys_freeze", effectdata, true, true )
					ply.physparent.physgunent = nil
					return false
				end
			end
		end
	end)
	hook.Add("InitPostEntity","physparent_hook3",function(ply)
		local tmp = ents.Create("prop_physics")
		if IsValid(tmp) then
			local oldfunc = getmetatable(tmp).SetParent
			getmetatable(tmp).SetParent = function(a,b,c) local parent = a:GetParent() if IsValid(parent) and PhysParentTable[parent:EntIndex()] ~= nil then timer.Create("updatetimer_"..parent:EntIndex(),0.1,1,function() Update(parent) end) end oldfunc(a,b,c) end
			tmp:Remove()
		end
	end)	
else
	language.Add("tool.physparent.name", "Physical Parent")
	language.Add("tool.physparent.desc", "Parents objects while retaining collisions")
	language.Add("tool.physparent.0", "Primary: select (hold use for area). Secondary: parent to target. Reload: clear")
	language.Add("Undone_physparent", "Undone Physical Parent")
	CreateClientConVar("physparent_radius", "300", true, true)
	CreateClientConVar("physparent_normal", "false", true, true)
	CreateClientConVar("physparent_enhanced", "false", true, true)
	CreateClientConVar("physparent_shadows", "false", true, true)
	CreateClientConVar("physparent_constraints", "false", true, true)
	CreateClientConVar("physparent_weight", "false", true, true)
	PhysParentTableCl = PhysParentTableCl or {}
	
	local function CustomClientColls(ent,conv,delay)
		delay = delay or 0.1
		if not istable(conv) or not IsValid(ent) or PhysParentTableCl[ent:EntIndex()] == nil then return end
		ent:PhysicsDestroy()
		ent:PhysicsInit(SOLID_VPHYSICS)
		timer.Create("physparentcl_clientphys"..ent:EntIndex(),delay,1,function()
			if IsValid(ent) and IsValid(ent:GetPhysicsObject()) and PhysParentTableCl[ent:EntIndex()] ~= nil then
				ent:PhysicsDestroy()
				ent:SetMoveType(MOVETYPE_NONE)
				ent:PhysicsInitMultiConvex(conv)
				ent:EnableCustomCollisions(true)
			else
				CustomClientColls(ent,conv,1)
			end
		end)
	end
	
	PhysParentCanNotify = true
	net.Receive("physparent_notify",function(len, ply)
		local str = net.ReadString()
		if PhysParentCanNotify then
			surface.PlaySound("buttons/button10.wav")
			GAMEMODE:AddNotify(str,1,5)
			PhysParentCanNotify = false
			timer.Create("physparentnotifyreset",1,1,function() PhysParentCanNotify = true end)
		end
	end)
	net.Receive("physparent_table",function(len, ply)
		local newTable = net.ReadTable()
		for k,v in pairs(PhysParentTableCl) do
			if IsValid(Entity(k)) and newTable[k] == nil then
				Entity(k):PhysicsDestroy()
				for i = 2,#PhysParentTableCl[k] do
					local child = Entity(PhysParentTableCl[k][i])
					if IsValid(child) then child:SetNotSolid(false) end
				end
			end
		end
		PhysParentTableCl = newTable
		for k,v in pairs(PhysParentTableCl) do 
			if IsValid(Entity(k)) then
				CustomClientColls(Entity(k),GetGroupConv(v))
			end
		end
	end)
	net.Receive("physparent_complexity",function(len, ply)
		physparentcl_complexity = net.ReadInt(32)
		physparentcl_selectioncomplexity = net.ReadInt(32)
		physparentcl_maxcomplexity = net.ReadInt(32)
	end)

	physparentcl_fontsCreated = false
	physparentcl_regular = GetConVar("physparent_normal"):GetBool()
	physparentcl_complexity = 0
	physparentcl_selectioncomplexity = 0
	physparentcl_maxcomplexity = 0

	function TOOL:DrawToolScreen(width, height)
		if not fontsCreated then
			fontsCreated = true
			surface.CreateFont("physparent1",{font = "Calibri",extended = false,size = 64,weight = 1000,blursize = 0,scanlines = 0,antialias = true,underline = false,italic = false,strikeout = false,symbol = false,rotary = false,shadow = false,additive = false,outline = false})
			surface.CreateFont("physparent2",{font = "Calibri",extended = false,size = 28,weight = 1000,blursize = 0,scanlines = 0,antialias = true,underline = false,italic = false,strikeout = false,symbol = false,rotary = false,shadow = false,additive = false,outline = false})
		end
		surface.SetDrawColor(Color(20,20,20))
		surface.DrawRect(0,0,width,height)
		local fh = draw.GetFontHeight("physparent1")
		if physparentcl_regular then
			draw.DrawText( "Regular\nParent", "physparent1", width / 2, height / 2 - fh, Color( 0, 160, 255 ), TEXT_ALIGN_CENTER )
		else
			draw.DrawText( "Physical", "physparent1", width / 2, height / 4 - fh/1.3, Color( 0, 160, 255 ), TEXT_ALIGN_CENTER )
			draw.DrawText( "Parent", "physparent1", width / 2, height / 4, Color( 0, 160, 255 ), TEXT_ALIGN_CENTER )
			local overflow = (physparentcl_complexity+physparentcl_selectioncomplexity) > physparentcl_maxcomplexity
			surface.SetDrawColor(Color(0,64,0))
			surface.DrawRect(width/10,height/2+fh/1.7,width-width/5,height/9)
			local width1 = physparentcl_complexity/physparentcl_maxcomplexity*(width-width/5)
			surface.SetDrawColor(Color(0,255,0))
			surface.DrawRect(width/10,height/2+fh/1.7,width1,height/9)
			surface.SetDrawColor(Color(overflow and 150 or 0,not overflow and 150 or 0,0))
			surface.DrawRect(width/10+width1,height/2+fh/1.7,not overflow and physparentcl_selectioncomplexity/physparentcl_maxcomplexity*(width-width/5) or (width-width/5)-width1,height/9)
			draw.DrawText( physparentcl_complexity+physparentcl_selectioncomplexity.."/"..physparentcl_maxcomplexity, "physparent2", width / 2, height / 1.9, Color( overflow and 150 or 0, not overflow and 96 or 0, not overflow and 153 or 0 ), TEXT_ALIGN_CENTER )
			draw.DrawText( "collision complexity", "physparent2", width / 2, height / 4 * 3, Color( 0, 96, 153 ), TEXT_ALIGN_CENTER )
		end
	end
	local PhysgunHalos = {}
	local physparentcl_physguntimes = {}
	local physparentcl_physgunents = {}
	local physgun_halo = CreateConVar( "physgun_halo", "1", { FCVAR_ARCHIVE }, "Draw the physics gun halo?" )
	hook.Add( "DrawPhysgunBeam", "physparent_drawphysgunbeam", function( ply, wep, enabled, target, bone, deltaPos )
		if not enabled and IsValid(physparentcl_physgunents[ply]) then 
			local pent = physparentcl_physgunents[ply]
			if PhysParentTableCl[pent:EntIndex()] == nil then pent = pent:GetParent() if not IsValid(pent) or PhysParentTableCl[pent:EntIndex()] == nil then pent = nil end end
			if IsValid(pent) then CustomClientColls(pent,GetGroupConv(PhysParentTableCl[pent:EntIndex()])) end
			physparentcl_physgunents[ply] = nil
		end
		if ( physgun_halo:GetInt() == 0 ) then return true end
		if ( IsValid( target ) and enabled ) then
			if physparentcl_physguntimes[ply] == nil then physparentcl_physguntimes[ply] = 0 end
			local dt = CurTime()-physparentcl_physguntimes[ply]
			physparentcl_physguntimes[ply] = CurTime()
			if dt > 0.1 then physparentcl_physgunents[ply] = nil end
			local tab = PhysParentTableCl[target:EntIndex()]
			if  tab ~= nil and physparentcl_physgunents[ply] == nil then
				target:PhysicsDestroy() 
				local tr = util.TraceLine({
					start = ply:EyePos(),
					endpos = (target:LocalToWorld(deltaPos))
				})
				local dist = 2000000000
				local distSqr = 2000000000
				local closest = nil
				local first = true
				for k,v in pairs(tab) do
					if isnumber(v) then v = ents.GetByIndex(v) end
					if first or (isentity(v) and IsValid(v)) then
						local hitpos = nil
						local hitnormal = nil
						local fraction = nil
						if first then
							first = false
							hitpos, hitnormal, fraction = util.IntersectRayWithOBB(tr.StartPos,tr.Normal*10000,target:GetPos(),target:GetAngles(),tab.obbmins, tab.obbmaxs)
							v = target
						else
							hitpos, hitnormal, fraction = util.IntersectRayWithOBB(tr.StartPos,tr.Normal*10000,v:GetPos(),v:GetAngles(),v:OBBMins(), v:OBBMaxs())
						end
						if hitpos ~= nil then
							if fraction<dist then
								dist = fraction
								PhysgunHalos[ ply ] = v
								physparentcl_physgunents[ply] = v
							end
						end
						local tmp = target:LocalToWorld(deltaPos):Distance(v:GetPos())
						if tmp<distSqr then
							distSqr = tmp
							closest = v
						end
					end
				end
				physparentcl_physgunents[ply] = physparentcl_physgunents[ply] or closest or target
				if ply == LocalPlayer() then
					net.Start("physparent_pickup")
					net.WriteEntity(physparentcl_physgunents[ply])
					net.SendToServer()
				end
			else
				PhysgunHalos[ ply ] = physparentcl_physgunents[ply] or target
			end
			
		end
		return true
	end)
	hook.Add( "PreDrawHalos", "AddPhysgunHalos", function()
		if ( !PhysgunHalos || table.Count( PhysgunHalos ) == 0 ) then return end
		for k, v in pairs( PhysgunHalos ) do
			if ( !IsValid( k ) ) then continue end
			local size = math.random( 1, 2 )
			local colr = k:GetWeaponColor() + VectorRand() * 0.3
			halo.Add( PhysgunHalos, Color( colr.x * 255, colr.y * 255, colr.z * 255 ), size, size, 1, true, false )
		end
		PhysgunHalos = {}
	end)
	hook.Add( "OnEntityCreated", "physparent_oec", function(ent)
		if PhysParentTableCl[ent:EntIndex()] ~= nil then
			timer.Create("physparent_ecolls"..ent:EntIndex(),0.1,1,function()
				CustomClientColls(ent,GetGroupConv(PhysParentTableCl[ent:EntIndex()]))
			end)
		end
	end)
end

function TOOL:LeftClick(trace) 
	if CLIENT then return true end
	local ply = self:GetOwner()
	if ply.physparent == nil then CreatePlayerTable(ply) end
	local selection = {}
	if ply:KeyDown(IN_USE) then
		selection = ents.FindInSphere(trace.HitPos, ply:GetInfo("physparent_radius"))
	else
		selection[1] = trace.Entity
	end
	for i = 1,#selection do
		if IsValid(selection[i]) and not selection[i]:IsPlayer() and OwnershipTest(ply,selection[i]) and IsValid(selection[i]:GetPhysicsObject()) and not IsValid(selection[i]:GetParent()) and selection[i]:GetPhysicsObject():GetMeshConvexes() ~= null and PhysParentTable[selection[i]:EntIndex()] == nil then
			local found = false
			for k,v in pairs(ply.physparent.selected) do
				if v.ent == selection[i] then
					found = true
					if not ply:KeyDown(IN_USE) then
						selection[1]:SetColor(v.color)
						selection[1]:SetMaterial(v.material)
						table.remove(ply.physparent.selected,k)
					end
					break
				end
			end
			if not found then
				ply.physparent.selected[#ply.physparent.selected+1] = {ent = selection[i], color = selection[i]:GetColor(), material = selection[i]:GetMaterial()}
				selection[i]:SetColor(Color(0,255,0,128))
				selection[i]:SetMaterial("models/debug/debugwhite")
				selection[i]:SetRenderMode(RENDERMODE_TRANSALPHA)
			end
		end
	end
	SendPlayerComplexity(ply)
	return true
end

function TOOL:RightClick(trace)
	if CLIENT then return true end
	local ply = self:GetOwner()
	if ply.physparent == nil then CreatePlayerTable(ply) end
	local cv_normal = tobool(ply:GetInfo("physparent_normal"))
	local cv_enhanced = tobool(ply:GetInfo("physparent_enhanced"))
	local cv_shadows = tobool(ply:GetInfo("physparent_shadows"))
	local cv_constraints = tobool(ply:GetInfo("physparent_constraints"))
	local cv_weight = tobool(ply:GetInfo("physparent_weight"))
	local cv_limit = GetConVar("sv_physparent_maxcomplexity"):GetInt()
	if  not IsValid(trace.Entity) or trace.Entity:IsPlayer() or not OwnershipTest(ply,trace.Entity) or not IsValid(trace.Entity:GetPhysicsObject()) or (not cv_normal and (PhysParentTable[trace.Entity:EntIndex()] ~= nil or (IsValid(trace.Entity:GetParent()) and PhysParentTable[trace.Entity:GetParent():EntIndex()] ~= nil) or trace.Entity:GetPhysicsObject():GetMeshConvexes() == null or trace.Entity:GetClass() == "prop_ragdoll" or trace.Entity:GetClass() == "prop_vehicle_jeep")) then return false end
	local found = false
	for k,v in pairs(ply.physparent.selected) do if IsValid(v.ent) and v.ent == trace.Entity then found = true end end
	if not cv_normal and PlayerComplexity(ply) + (not found and Complexity(trace.Entity) or 0) > cv_limit then
		net.Start("physparent_notify") net.WriteString("Exceeding limit (sv_physparent_maxcomplexity)") net.Send(ply)
		return false
	end
	local i = 1
	while i <= #ply.physparent.selected do 
		local v = ply.physparent.selected[i]
		if IsValid(v.ent) then v.ent:SetColor(v.color) v.ent:SetMaterial(v.material) end
		if not IsValid(v.ent) or v.ent == trace.Entity or (not cv_normal and (string.sub(v.ent:GetClass(),1,7) == "weapon_" or string.sub(v.ent:GetClass(),1,5) == "item_")) then table.remove(ply.physparent.selected,i) else i = i + 1 end
	end
	if #ply.physparent.selected == 0 then return false end
	local pid = trace.Entity:EntIndex()
	if not cv_normal then 
		PhysParentTable[pid] = {pid,ownerid=ply:SteamID()}
		if cv_enhanced then
			PhysParentTable[pid].obbmins = trace.Entity:OBBMins()
			PhysParentTable[pid].obbmaxs = trace.Entity:OBBMaxs()
		end
	end
	local duplicatorGroup = "group"..os.time().."d"..CurTime().."u"..physparent_uniquenum physparent_uniquenum = physparent_uniquenum + 1
	for k,v in pairs(ply.physparent.selected) do
		if cv_constraints then constraint.RemoveAll(v.ent) end
		if cv_weight then v.ent:GetPhysicsObject():SetMass(0.1) end
		v.ent:SetParent(trace.Entity)
		if cv_shadows then v.ent:DrawShadow(false) end
		if not cv_normal and cv_enhanced then v.ent:SetNotSolid(true) end
		if cv_normal then
			duplicator.StoreEntityModifier(v.ent,"physparent",{normal = true, shadows = cv_shadows, weight = cv_weight})
		else
			duplicator.StoreEntityModifier(v.ent,"physparent",{shadows = cv_shadows, weight = cv_weight, group = duplicatorGroup})
			v.ent:CallOnRemove("physparent_onremove",function(ent) local parent = ent:GetParent() if IsValid(parent) and PhysParentTable[parent:EntIndex()] ~= nil then timer.Create("updatetimer_"..parent:EntIndex(),0.1,1,function() Update(parent) end) end end)
			PhysParentTable[pid][#PhysParentTable[pid]+1] = v.ent:EntIndex()
		end
	end
	undo.Create("physparent")
	undo.AddFunction(function(tab, arg2)
		for k,v in pairs(arg2) do
			if IsValid(v.ent) and v.ent.EntityMods ~= nil and v.ent.EntityMods.physparent ~= nil then
				if IsValid(v.ent:GetParent()) and IsValid(v.ent:GetParent():GetPhysicsObject()) then v.ent:GetParent():GetPhysicsObject():EnableMotion(false) end
				v.ent:SetParent(nil)
				v.ent:SetPos(v.ent:GetPos())
				if IsValid(v.ent:GetPhysicsObject()) then v.ent:GetPhysicsObject():EnableMotion(false) end
				duplicator.ClearEntityModifier(v.ent,"physparent")
			end
		end
	end,table.Copy(ply.physparent.selected))
	undo.SetPlayer(ply)
	undo.Finish()
	if cv_normal then table.Empty(ply.physparent.selected) SendPlayerComplexity(ply) return true end
	duplicator.StoreEntityModifier(trace.Entity,"physparent",{group = duplicatorGroup, childcount = #ply.physparent.selected, enhanced = cv_enhanced})
	trace.Entity:CallOnRemove("physparent_onremove",function(ent) PhysParentTable[ent:EntIndex()] = nil SendCLTable(nil) end)
	table.Empty(ply.physparent.selected)
	Phys(PhysParentTable[pid])
	SendCLTable(nil)
	SendPlayerComplexity(ply)
	return true
end

function TOOL:Reload(trace) 
	if CLIENT then return true end
	local ply = self:GetOwner()
	if ply.physparent == nil then CreatePlayerTable(ply) end
	for k,v in pairs(ply.physparent.selected) do
		if IsValid(v.ent) then v.ent:SetColor(v.color) v.ent:SetMaterial(v.material) end
	end
	table.Empty(ply.physparent.selected)
	SendPlayerComplexity(ply)
	return true
end

function TOOL.BuildCPanel(CPanel)
	local Slider = vgui.Create("DNumSlider")
	Slider:SetDark(true)
	Slider:SetText("Area selection radius")
	Slider:SetMin(1)
	Slider:SetMax(1000)
	Slider:SetDecimals(0)
	Slider:SetValue(GetConVar("physparent_radius"):GetInt())
	Slider.OnValueChanged = function() GetConVar("physparent_radius"):SetInt(Slider:GetValue()) end
	local Checkbox = vgui.Create("DCheckBoxLabel")
	Checkbox:SetText("Clientside Collision")
	Checkbox:SetDark(true)
	Checkbox:SetEnabled(not GetConVar("physparent_normal"):GetBool())
	Checkbox:SetValue(GetConVar("physparent_enhanced"):GetBool())
	Checkbox.OnChange = function() GetConVar("physparent_enhanced"):SetBool(Checkbox:GetChecked()) end
	local Checkbox2 = vgui.Create("DCheckBoxLabel")
	Checkbox2:SetText("Disable Shadows")
	Checkbox2:SetDark(true)
	Checkbox2:SetValue(GetConVar("physparent_shadows"):GetBool())
	Checkbox2.OnChange = function() GetConVar("physparent_shadows"):SetBool(Checkbox2:GetChecked()) end
	local Checkbox3 = vgui.Create("DCheckBoxLabel")
	Checkbox3:SetText("Regular Parent")
	Checkbox3:SetDark(true)
	Checkbox3:SetValue(GetConVar("physparent_normal"):GetBool())
	Checkbox3.OnChange = function() physparentcl_regular = Checkbox3:GetChecked() GetConVar("physparent_normal"):SetBool(Checkbox3:GetChecked()) if Checkbox3:GetChecked() then Checkbox:SetEnabled(false) else  Checkbox:SetEnabled(true) end end
	local Checkbox4 = vgui.Create("DCheckBoxLabel")
	Checkbox4:SetText("Remove Constraints")
	Checkbox4:SetDark(true)
	Checkbox4:SetValue(GetConVar("physparent_constraints"):GetBool())
	Checkbox4.OnChange = function() GetConVar("physparent_constraints"):SetBool(Checkbox4:GetChecked()) end
	local Checkbox5 = vgui.Create("DCheckBoxLabel")
	Checkbox5:SetText("Set Weight")
	Checkbox5:SetDark(true)
	Checkbox5:SetValue(GetConVar("physparent_weight"):GetBool())
	Checkbox5.OnChange = function() GetConVar("physparent_weight"):SetBool(Checkbox5:GetChecked()) end
	CPanel:SetName("Physical Parent V1.12.2")
	CPanel:AddItem(Slider)
	CPanel:AddItem(Checkbox3)
	CPanel:ControlHelp("It is recommended to use this for most of your props, since keeping collisions for all of them would be detrimental to performance.")
	CPanel:AddItem(Checkbox)
	CPanel:ControlHelp("This will improve collisions with players and make it possible to physgun the parented props. The downside is that you won't be able to access individual parented props with tools or traces, and visible ropes can look buggy.")
	CPanel:AddItem(Checkbox2)
	CPanel:ControlHelp("Recommended for improved performance.")
	CPanel:AddItem(Checkbox4)
	CPanel:ControlHelp("Removes constraints from parented props.")
	CPanel:AddItem(Checkbox5)
	CPanel:ControlHelp("The weight of parented props will be set to 0.1")
end
--lua/weapons/gmod_tool/stools/rb655_easy_bonemerge.lua:

TOOL.Category = "Robotboy655"
TOOL.Name = "#tool.rb655_easy_bonemerge.name"

TOOL.ClientConVar[ "noglow" ] = "0"

if ( SERVER ) then

	-- Replaces the bonemerged entity with a custom one for easier everything for the tool
	local function ReplaceEntity( oldent )
		local newEntity = ents.Create( "ent_bonemerged" )
		newEntity:SetModel( oldent:GetModel() )
		newEntity:SetSkin( oldent:GetSkin() or 0 )
		if ( oldent:GetFlexScale() != newEntity:GetFlexScale() ) then newEntity:SetFlexScale( oldent:GetFlexScale() ) end -- Don't create unnecessary entities
		if ( oldent:GetNumBodyGroups() ) then
			for id = 0, oldent:GetNumBodyGroups() - 1 do newEntity:SetBodygroup( id, oldent:GetBodygroup( id ) ) end
		end
		for i = 0, oldent:GetFlexNum() - 1 do newEntity:SetFlexWeight( i, oldent:GetFlexWeight( i ) ) end
		for i = 0, oldent:GetBoneCount() do
			if ( oldent:GetManipulateBoneScale( i ) != newEntity:GetManipulateBoneScale( i ) ) then newEntity:ManipulateBoneScale( i, oldent:GetManipulateBoneScale( i ) ) end
			if ( oldent:GetManipulateBoneAngles( i ) != newEntity:GetManipulateBoneAngles( i ) ) then newEntity:ManipulateBoneAngles( i, oldent:GetManipulateBoneAngles( i ) ) end
			if ( oldent:GetManipulateBonePosition( i ) != newEntity:GetManipulateBonePosition( i ) ) then newEntity:ManipulateBonePosition( i, oldent:GetManipulateBonePosition( i ) ) end
			if ( oldent:GetManipulateBoneJiggle( i ) != newEntity:GetManipulateBoneJiggle( i ) ) then newEntity:ManipulateBoneJiggle( i, oldent:GetManipulateBoneJiggle( i ) ) end
		end
		for i = 0, 31 do
			local mat = oldent:GetSubMaterial( i )
			if ( mat:len() > 0 ) then
				newEntity:SetSubMaterial( i, mat )
			end
		end

		newEntity:Spawn()

		newEntity.EntityMods = oldent.EntityMods
		newEntity.BoneMods = oldent.BoneMods

		duplicator.ApplyEntityModifiers( nil, newEntity )
		duplicator.ApplyBoneModifiers( nil, newEntity )

		return newEntity
	end

	-- Adds any constrained entities to the bonemerge
	local function rb655_CheckForWelds( ent, parent )
		if ( !constraint.HasConstraints( ent ) ) then return end

		for _, v in pairs( constraint.GetAllConstrainedEntities( ent ) ) do
			if ( v == ent or v:GetClass() == "ent_bonemerged" ) then continue end
			if ( constraint.FindConstraint( v, "EasyBonemergeParent" ) ) then continue end

			local oldent = v
			if ( IsValid( v ) and v:GetClass() == "prop_effect" ) then oldent = v.AttachedEntity end

			local newEntity = ReplaceEntity( oldent )

			newEntity.LocalPos = ent:WorldToLocal( v:GetPos() )
			newEntity.LocalAng = ent:WorldToLocalAngles( v:GetAngles() )

			constraint_EasyBonemergeParent( parent, newEntity )

			v:Remove()
		end
	end

	-- Allows for bonemerging depth
	local function rb655_CheckForBonemerges( oldent, newent )
		for id, ent in pairs( ents.GetAll() ) do
			if ( ent:GetParent() == oldent and ent:GetClass() == "ent_bonemerged" and !ent.LocalPos ) then
				rb655_ApplyBonemerge( ent, newent )
			end
		end
	end

	-- Entry point
	function rb655_ApplyBonemerge( ent, selectedEnt )
		if ( selectedEnt == ent ) then return end

		local oldent = ent
		if ( IsValid( ent ) and ent:GetClass() == "prop_effect" ) then oldent = ent.AttachedEntity end

		local newEntity = ReplaceEntity( oldent )

		constraint_EasyBonemerge( selectedEnt, newEntity )
		rb655_CheckForBonemerges( oldent, newEntity )
		rb655_CheckForWelds( oldent, newEntity )

		ent:Remove()

		return newEntity
	end

	function constraint_EasyBonemerge( ent_parent, Ent2, EntityMods, BoneMods )
		if ( !IsValid( ent_parent ) ) then MsgN( "Easy Bonemerge Tool: Your dupe/save is missing the target entity, cannot apply bonemerged props!" ) return end
		if ( !IsValid( Ent2 ) ) then MsgN( "Easy Bonemerge Tool: Your dupe/save is missing the bonemerged prop, cannot restore bonemerge effect!" ) return end

		Ent2:SetParent( ent_parent, 0 )
		if ( IsValid( ent_parent ) and ent_parent:GetClass() == "prop_effect" ) then
			Ent2:SetParent( ent_parent.AttachedEntity, 0 )
			-- A horrible hack, but necessary
			ent_parent.PhysicsUpdate = Ent2.PhysicsUpdatePatch
		end

		-- I don't remember why I put these here
		Ent2:SetMoveType( MOVETYPE_NONE )
		Ent2:SetSolid( SOLID_NONE )
		Ent2:SetLocalPos( Vector( 0, 0, 0 ) )
		Ent2:SetLocalAngles( Angle( 0, 0, 0 ) )

		Ent2:AddEffects( EF_BONEMERGE )
		--Ent2:Fire( "SetParentAttachment", ent_parent:GetAttachments()[1].name )

		constraint.AddConstraintTable( ent_parent, Ent2, Ent2 )

		Ent2:SetTable( {
			Type = "EasyBonemerge",
			Ent1 = ent_parent,
			Ent2 = Ent2,
			EntityMods = EntityMods or Ent2.EntityMods,
			BoneMods = BoneMods or Ent2.BoneMods
		} )

		duplicator.ApplyEntityModifiers( nil, Ent2 )
		duplicator.ApplyBoneModifiers( nil, Ent2 )

		ent_parent:DeleteOnRemove( Ent2 )

		-- What is this for?
		-- rb655_CheckForBonemerges( Ent2, Ent2 )

		return Ent2
	end
	duplicator.RegisterConstraint( "EasyBonemerge", constraint_EasyBonemerge, "Ent1", "Ent2", "EntityMods", "BoneMods" )

	function constraint_EasyBonemergeParent( Ent1, Ent2, LocalPos, LocalAng, EntityMods, BoneMods )
		if ( !IsValid( Ent1 ) ) then MsgN( "Easy Bonemerge Tool: Your dupe/save is missing parent target entity, cannot apply bonemerged props!" ) return end
		if ( !IsValid( Ent2 ) ) then MsgN( "Easy Bonemerge Tool: Your dupe/save is missing parent bonemerged prop, cannot restore bonemerged prop!" ) return end

		Ent2:SetParent( Ent1, 0 )
		if ( IsValid( Ent1 ) and Ent1:GetClass() == "prop_effect" ) then Ent2:SetParent( Ent1.AttachedEntity, 0 ) end

		Ent2.BoneMergeParent = true

		Ent2:SetLocalPos( LocalPos or Ent2.LocalPos )
		Ent2:SetLocalAngles( LocalAng or Ent2.LocalAng )

		constraint.AddConstraintTable( Ent1, Ent2, Ent2 )

		Ent2:SetTable( {
			Type = "EasyBonemergeParent",
			Ent1 = Ent1,
			Ent2 = Ent2,
			LocalPos = LocalPos or Ent2.LocalPos,
			LocalAng = LocalAng or Ent2.LocalAng,
			EntityMods = EntityMods or Ent2.EntityMods,
			BoneMods = BoneMods or Ent2.BoneMods
		} )

		duplicator.ApplyEntityModifiers( nil, Ent2 )
		duplicator.ApplyBoneModifiers( nil, Ent2 )

		Ent1:DeleteOnRemove( Ent2 )

		return Ent2
	end
	duplicator.RegisterConstraint( "EasyBonemergeParent", constraint_EasyBonemergeParent, "Ent1", "Ent2", "LocalPos", "LocalAng", "EntityMods", "BoneMods" )

	-- Undo bonemerges from UI
	util.AddNetworkString( "rb655_bm_undo" )
	net.Receive( "rb655_bm_undo", function( len, ply )
		local ent = net.ReadEntity()
		if ( !IsValid( ent ) or ent:GetClass() != "ent_bonemerged" ) then return end

		local parent = ent:GetParent()
		if ( !IsValid( parent ) ) then return end
		if ( parent:GetClass() == "prop_dynamic" and IsValid( parent:GetParent() ) ) then parent = parent:GetParent() end

		local tool = ply:GetTool( "rb655_easy_bonemerge" )
		if ( !istable( tool ) ) then return end

		if ( tool:GetSelectedEntity() != parent ) then return end

		ply:SendLua( "hook.Run( 'OnUndo', 'Bonemerge' )" )
		ent:Remove()
	end )

	util.AddNetworkString( "rb655_bm_apply_tool" )
	net.Receive( "rb655_bm_apply_tool", function( len, ply )
		local ent = net.ReadEntity()
		local tool = net.ReadString()
		if ( !IsValid( ent ) or ent:GetClass() != "ent_bonemerged" ) then return end

		local parent = ent:GetParent()
		if ( !IsValid( parent ) ) then return end
		if ( parent:GetClass() == "prop_dynamic" and IsValid( parent:GetParent() ) ) then parent = parent:GetParent() end

		local toolBm = ply:GetTool( "rb655_easy_bonemerge" )
		if ( !istable( toolBm ) ) then return end

		if ( toolBm:GetSelectedEntity() != parent ) then return end

		local toolInst = ply:GetTool( tool )
		if ( !istable( toolInst ) ) then return end

		if ( tool == "eyeposer" ) then
			-- Hack
			toolInst.SelectedEntity = nil
			toolInst:LeftClick( { HitPos = ply:GetShootPos(), Entity = ent } )
			ply:ConCommand( "gmod_tool " .. tool )
		elseif ( tool == "faceposer" ) then
			toolInst:RightClick( { HitPos = ply:GetShootPos(), Entity = ent } )
			ply:ConCommand( "gmod_tool " .. tool )
		elseif ( tool == "rb655_easy_bodygroup" ) then
			toolInst:RightClick( { HitPos = ply:GetShootPos(), Entity = ent } )
			ply:ConCommand( "gmod_tool " .. tool )
		end
	end )

end

function TOOL:GetSelectedEntity()
	return self:GetWeapon():GetNWEntity( "rb655_bonemerge_entity" )
end

function TOOL:SetSelectedEntity( ent )
	-- Cannot do this due to duplicator
	-- if ( IsValid( ent ) and ent:GetClass() == "prop_effect" ) then ent = ent.AttachedEntity end

	if ( !IsValid( ent ) ) then ent = NULL end
	if ( IsValid( ent ) and ent:GetModel():StartWith( "*" ) ) then ent = NULL end
	if ( IsValid( ent ) and ent:IsPlayer() and ent != self:GetOwner() ) then ent = NULL end

	if ( self:GetSelectedEntity() == ent ) then return end

	self:GetWeapon():SetNWEntity( "rb655_bonemerge_entity", ent )
end

function TOOL:LeftClick( tr )
	local ent = self:GetSelectedEntity()
	if ( !IsValid( ent ) or !IsValid( tr.Entity ) or tr.Entity == ent or tr.Entity:IsPlayer() or tr.Entity:IsNPC() or tr.Entity:GetModel():StartWith( "*" ) ) then return false end

	if ( IsValid( tr.Entity ) and tr.Entity:GetClass() == "prop_effect" ) then tr.Entity = tr.Entity.AttachedEntity end
	if ( !IsValid( ent ) or !IsValid( tr.Entity ) or tr.Entity == ent or tr.Entity:IsPlayer() or tr.Entity:IsNPC() or tr.Entity:GetModel():StartWith( "*" ) ) then return false end

	if ( CLIENT ) then return true end

	local newEntity = rb655_ApplyBonemerge( tr.Entity, ent )

	undo.Create( "bonemerge" )
		undo.AddEntity( newEntity )
		undo.SetPlayer( self:GetOwner() )
	undo.Finish()

	return true
end

function TOOL:RightClick( tr )
	local ent = !self:GetOwner():KeyDown( IN_USE ) and tr.Entity or self:GetOwner()
	--if ( IsValid( ent ) and #( ent:GetAttachments() or {} ) < 1 ) then return false end
	if ( SERVER ) then self:SetSelectedEntity( ent ) end
	return true
end

function TOOL:Reload( tr )
	local ent = !self:GetOwner():KeyDown( IN_USE ) and tr.Entity or self:GetOwner()
	if ( !IsValid( ent ) ) then return false end
	if ( SERVER --[[&& ( constraint.HasConstraints( ent, "EasyBonemerge" ) or constraint.HasConstraints( ent, "EasyBonemergeParent" ) )]] ) then
		constraint.RemoveConstraints( ent, "EasyBonemerge" )
		constraint.RemoveConstraints( ent, "EasyBonemergeParent" )
	end
	return true
end

function TOOL:MakeGhostEntity( model, pos, angle )

	util.PrecacheModel( model )

	-- We do ghosting serverside in single player
	-- It's done clientside in multiplayer
	if ( SERVER and !game.SinglePlayer() ) then return end
	if ( CLIENT and game.SinglePlayer() ) then return end

	-- Release the old ghost entity
	self:ReleaseGhostEntity()

	-- Don't allow ragdolls/effects to be ghosts
	-- if ( !util.IsValidProp( model ) ) then return end

	if ( CLIENT ) then
		self.GhostEntity = ents.CreateClientProp( model )
	else
		self.GhostEntity = ents.Create( "prop_physics" )
	end

	-- If there's too many entities we might not spawn..
	if ( !IsValid( self.GhostEntity ) ) then
		self.GhostEntity = nil
		return
	end

	self.GhostEntity:SetModel( model )
	self.GhostEntity:SetPos( pos )
	self.GhostEntity:SetAngles( angle )
	self.GhostEntity:Spawn()

	self.GhostEntity:SetSolid( SOLID_VPHYSICS )
	self.GhostEntity:SetMoveType( MOVETYPE_NONE )
	self.GhostEntity:SetNotSolid( true )
	self.GhostEntity:SetRenderMode( RENDERMODE_GLOW ) -- Allows for transparency and proper Z order
	self.GhostEntity:SetColor( Color( 255, 255, 255, 128 ) )

end

function TOOL:UpdateGhostEntity( ent, ply, tr )
	local selectedEnt = self:GetSelectedEntity()
	if ( IsValid( selectedEnt ) and selectedEnt:GetClass() == "prop_effect" ) then selectedEnt = selectedEnt.AttachedEntity end

	if ( !IsValid( ent ) or !IsValid( selectedEnt ) ) then return end

	local trEnt = tr.Entity

	if ( !IsValid( trEnt ) or trEnt == selectedEnt ) then
		ent:SetNoDraw( true )
		return
	end

	if ( trEnt:GetClass() == "prop_effect" ) then
		local attachedEntity = trEnt.AttachedEntity

		if ( !IsValid( trEnt.AttachedEntity ) ) then
			local tab = ents.FindByClassAndParent( "prop_dynamic", trEnt )
			if ( tab and IsValid( tab[ 1 ] ) ) then attachedEntity = tab[ 1 ] end
		end

		if ( IsValid( attachedEntity ) ) then trEnt = attachedEntity end
	end

	if ( trEnt:GetNumBodyGroups() ) then
		for id = 0, trEnt:GetNumBodyGroups() - 1 do ent:SetBodygroup( id, trEnt:GetBodygroup( id ) ) end
	end

	local clr = trEnt:GetColor()
	clr.a = clr.a / 2
	ent:SetColor( clr )

	ent:SetMaterial( trEnt:GetMaterial() )
	ent:SetSkin( trEnt:GetSkin() or 0 )
	ent:SetModel( trEnt:GetModel() )
	ent:SetParent( selectedEnt, 0 )
	ent:AddEffects( EF_BONEMERGE )
	ent:SetNoDraw( false )

	for i = 0, ent:GetBoneCount() do
		if ( trEnt:GetManipulateBoneScale( i ) != ent:GetManipulateBoneScale( i ) ) then ent:ManipulateBoneScale( i, trEnt:GetManipulateBoneScale( i ) ) end
		if ( trEnt:GetManipulateBoneAngles( i ) != ent:GetManipulateBoneAngles( i ) ) then ent:ManipulateBoneAngles( i, trEnt:GetManipulateBoneAngles( i ) ) end
		if ( trEnt:GetManipulateBonePosition( i ) != ent:GetManipulateBonePosition( i ) ) then ent:ManipulateBonePosition( i, trEnt:GetManipulateBonePosition( i ) ) end
		if ( trEnt:GetManipulateBoneJiggle( i ) != ent:GetManipulateBoneJiggle( i ) ) then ent:ManipulateBoneJiggle( i, trEnt:GetManipulateBoneJiggle( i ) ) end
	end

	for i = 0, 31 do
		local mat = trEnt:GetSubMaterial( i )
		if ( mat:len() > 0 ) then
			ent:SetSubMaterial( i, mat )
		end
	end
end

function TOOL:Think()
	if ( !IsValid( self:GetSelectedEntity() ) ) then self:ReleaseGhostEntity() return end

	local tr = util.TraceLine( {
		start = self:GetOwner():GetShootPos(),
		endpos = self:GetOwner():GetShootPos() + self:GetOwner():GetAimVector() * 16000,
		filter = self:GetOwner(),
		mask = MASK_ALL,
	} )

	if ( !IsValid( tr.Entity ) or tr.Entity == self:GetSelectedEntity() or tr.Entity:IsPlayer() or tr.Entity:GetModel():StartWith( "*" ) ) then
		self:ReleaseGhostEntity()
		return
	end

	if ( IsValid( tr.Entity ) and !IsValid( self.GhostEntity ) ) then
		self:MakeGhostEntity( tr.Entity:GetModel(), Vector( 0, 0, 0 ), Angle( 0, 0, 0 ) )
	end

	self:UpdateGhostEntity( self.GhostEntity, self:GetOwner(), tr )
end

if ( SERVER ) then return end

TOOL.Information = {
	{ name = "left", stage = 1 },
	{ name = "right" },
	{ name = "right_use" },
	{ name = "reload", stage = 0 },
	{ name = "reload_use", stage = 0 },
}

language.Add( "tool.rb655_easy_bonemerge.left", "Attach a model to selected object" )
language.Add( "tool.rb655_easy_bonemerge.right", "Select an object to attach model(s) to" )
language.Add( "tool.rb655_easy_bonemerge.reload", "Remove all attached model(s) from an object" )
language.Add( "tool.rb655_easy_bonemerge.right_use", "Select yourself" )
language.Add( "tool.rb655_easy_bonemerge.reload_use", "Remove all attached model(s) from yourself" )

language.Add( "tool.rb655_easy_bonemerge.name", "Easy Bonemerge Tool" )
language.Add( "tool.rb655_easy_bonemerge.desc", "Attaches models to objects using bonemerging" )

language.Add( "tool.rb655_easy_bonemerge.infos", [[
What is bone merging?
Bone merging is essentially what it sounds like, you select a model and click on other models to merge their bones together.

For bone merging to work successfully, two models MUST have at least ONE bone with exactly the same name.

If two models do not meet this requirement, the model you are trying to attach will be placed into the center of coordinates of the selected model, which is usually in the visual center of the model or it's lowest point.

Once bonemerged, the bones of the target model(s) will be placed into the exact positions of the bones with same names on the selected model.

You cannot select which bones to attach objects to. Bonemerging features are defined by the model author(s) and cannot be changed without editing the model.

Selected model - The entity you select with right click
Target model(s) - The entities you left click to bone merge onto the selected model

Right click on buttons below for extra options.]] )

language.Add( "tool.rb655_easy_bonemerge.noshared", "Warning!\nNo shared bones!\nThese 2 models are not bonemerge compatible!" )
language.Add( "tool.rb655_easy_bonemerge.backwards", "Warning!\nSelected model has less bones than target model!\nYou are most likely trying to bonemerge backwards!" )

language.Add( "undone_Bonemerge", "Undone Bonemerged Prop" )

language.Add( "tool.rb655_easy_bonemerge.noglow", "Don't render glow/halo around models" )
language.Add( "tool.rb655_easy_bonemerge.selected_undo", "Undo:" )
language.Add( "tool.rb655_easy_bonemerge.noent", "No entity selected!" )
language.Add( "tool.rb655_easy_bonemerge.nomodels", "No attached models!" )
language.Add( "tool.rb655_easy_bonemerge.undo.tooltip", "Remove this attached model from selected entity.\n\nRight click for more options." )

function TOOL:GetStage()
	if ( IsValid( self:GetSelectedEntity() ) ) then return 1 end
	return 0
end

local function CountBonemergedChildren( ent )
	local counter = 0
	for k, v in pairs( ent:GetChildren() ) do
		if ( !IsValid( v ) or v:GetClass() != "ent_bonemerged" ) then continue end

		counter = counter + 1
	end
	return counter
end

local function UndoThisBonemerge( ent )
	net.Start( "rb655_bm_undo" )
		net.WriteEntity( ent )
	net.SendToServer()
end

local function ApplyToolToBonemerge( ent, tool )
	net.Start( "rb655_bm_apply_tool" )
		net.WriteEntity( ent )
		net.WriteString( tool )
	net.SendToServer()
end

function TOOL.BuildCPanel( panel )

	panel:Help( "#tool.rb655_easy_bonemerge.infos" )

	panel:AddControl( "Checkbox", { Label = "#tool.rb655_easy_bonemerge.noglow", Command = "rb655_easy_bonemerge_noglow" } )

	local pnl = vgui.Create( "DPanel", panel )
	pnl:Dock( TOP )
	pnl:DockMargin( 10, 10, 10, 10 )
	pnl.Think = function( s )
		local toolgun = LocalPlayer()
		if ( !IsValid( toolgun ) or !toolgun.GetTool ) then return end
		toolgun = toolgun:GetTool( "rb655_easy_bonemerge" )
		if ( !istable( toolgun ) ) then return end

		local ent = toolgun:GetSelectedEntity()
		if ( IsValid( ent ) and ent:GetClass() == "prop_effect" ) then ent = ent.AttachedEntity end
		if ( !IsValid( ent ) and s.LastSelectedEntity != nil ) then
			s.LastSelectedEntity = nil
			s:Rebuild()
		elseif ( IsValid( ent ) and ( s.LastSelectedEntity == nil or s.LastSelectedEntity != ent or ( s.LastChildrenNum or 0 ) != CountBonemergedChildren( ent ) ) ) then
			s.LastSelectedEntity = ent
			s.LastChildrenNum = CountBonemergedChildren( ent )
			s:Rebuild()
		end
	end
	pnl.Rebuild = function( s )
		for k, v in pairs( s:GetChildren() ) do v:Remove() end

		if ( !IsValid( s.LastSelectedEntity ) ) then
			local txt = s:Add( "DLabel" )
			txt:SetText( "#tool.rb655_easy_bonemerge.noent" )
			txt:Dock( TOP )
			txt:SetDark( true )
			txt:DockMargin( 10, 10, 10, 10 )

			s:SetTall( 40 )
			return
		end

		local height = 0
		for k, v in pairs( s.LastSelectedEntity:GetChildren() ) do
			if ( !IsValid( v ) or v:GetClass() != "ent_bonemerged" ) then continue end

			local btn = s:Add( "DButton" )
			btn:SetText( "Undo " .. v:GetModel():sub( 8 ) .. "#" .. v:EntIndex() )
			btn:Dock( TOP )
			btn:SetTooltip( "#tool.rb655_easy_bonemerge.undo.tooltip" )
			btn:DockMargin( 5, 5, 5, 0 )
			btn.bonemergeButton = true
			btn.ent = v
			btn.DoClick = function( t )
				UndoThisBonemerge( t.ent )
			end
			btn.DoRightClick = function( t )
				local menu = DermaMenu()
				menu:AddOption( "Open bonemerged model in Face Poser", function() ApplyToolToBonemerge( t.ent, "faceposer" ) end )
				menu:AddOption( "Open bonemerged model in Eye Poser", function() ApplyToolToBonemerge( t.ent, "eyeposer" ) end )
				if ( LocalPlayer():GetTool( "rb655_easy_bodygroup" ) ) then
					menu:AddOption( "Open bonemerged model in Easy Bodygroup Tool", function() ApplyToolToBonemerge( t.ent, "rb655_easy_bodygroup" ) end )
				end

				-- Unfortunately this does not work because the server checks if the player is actually looking at the entity..
				--[[menu:AddOption( "Open entity context menu", function()
					local tr = LocalPlayer():GetEyeTrace()
					tr.Entity = t.ent
					timer.Simple( 0.1, function()
						properties.OpenEntityMenu( t.ent, tr )
					end )
				end )]]

				-- TODO: Set color? Set material?
				menu:Open()
			end

			height = height + btn:GetTall() + 5
		end

		if ( height > 0 ) then
			s:SetTall( height + 5 )
		else
			local txt = s:Add( "DLabel" )
			txt:SetText( "#tool.rb655_easy_bonemerge.nomodels" )
			txt:Dock( TOP )
			txt:SetDark( true )
			txt:DockMargin( 10, 10, 10, 10 )
			s:SetTall( 40 )
		end
	end
	pnl:Rebuild()

end

local color_red = Color( 255, 0, 0 )

hook.Add( "PreDrawHalos", "rb655_bonemerge_highlight", function()
	local hovered = vgui.GetHoveredPanel()
	if ( !IsValid( hovered ) or !hovered.bonemergeButton or !IsValid( hovered.ent ) ) then return end

	halo.Add( { hovered.ent }, color_red, 1, 1, 10, true, true )
end )

--------------------------------------------------------------------------
----------------------------------- HUD ----------------------------------
--------------------------------------------------------------------------

surface.CreateFont( "rb655_easy_bonemerge_font", {
	size = ScreenScale( 8 ),
	font = "Roboto"
} )

local function boxText( text, _x, _y )
	surface.SetFont( "rb655_easy_bonemerge_font" )

	local t = string.Explode( "\n", language.GetPhrase( text ) )

	local w, h = 0, 0
	for id, txt in pairs( t ) do
		local tW, tH = surface.GetTextSize( txt )
		w = math.max( w, tW )
		h = math.max( h, h + tH )
	end
	local x, y = _x - w / 2, _y
	draw.RoundedBox( 0, x - 5, y, w + 10, h + 10 , Color( 0, 0, 0, 128 ) )

	for id, txt in pairs( t ) do
		local _tW, tH = surface.GetTextSize( txt )

		draw.SimpleText( txt, "rb655_easy_bonemerge_font", _x, _y + ( id - 1 ) * tH + 5, color_white, 1, 0 )
	end
end

local crossmat = Material( "icon16/cross.png" )
function TOOL:DrawHUD()
	local ent = self:GetSelectedEntity()
	if ( IsValid( ent ) and ent:GetClass() == "prop_effect" ) then ent = ent.AttachedEntity end

	if ( !IsValid( ent ) ) then return end

	if ( !tobool( self:GetClientNumber( "noglow" ) ) ) then
		local t = { ent }
		if ( ent.GetActiveWeapon ) then table.insert( t, ent:GetActiveWeapon() ) end
		halo.Add( t, HSVToColor( ( CurTime() * 3 ) % 360, math.abs( math.sin( CurTime() / 2 ) ), 1 ), 2, 2, 1 )
	end

	-- =============================================================================================== --

	local hasBones = false
	local target = util.TraceLine( {
		start = LocalPlayer():GetShootPos(),
		endpos = LocalPlayer():GetShootPos() + LocalPlayer():GetAimVector() * 16000,
		filter = LocalPlayer(),
		mask = MASK_ALL,
	} ).Entity

	if ( !IsValid( target ) ) then return end

	--[[if ( target:GetClass() == "prop_effect" ) then
		local attachedEntity = target.AttachedEntity

		if ( !IsValid( target.AttachedEntity ) ) then
			local tab = ents.FindByClassAndParent( "prop_dynamic", target )
			if ( tab and IsValid( tab[ 1 ] ) ) then attachedEntity = tab[ 1 ] end
		end

		if ( IsValid( attachedEntity ) ) then target = attachedEntity end
	end]]
	if ( target:GetClass() == "prop_effect" ) then target = target.AttachedEntity end

	if ( !IsValid( target ) ) then return end
	if ( target:GetModel():StartWith( "*" ) ) then return end

	local bones = {}
	for id = 0, ent:GetBoneCount() - 1 do table.insert( bones, ent:GetBoneName( id ) ) end

	if ( target:GetBoneCount() ) then
		for id = 0, target:GetBoneCount() - 1 do
			if ( table.HasValue( bones, target:GetBoneName( id ) ) and target:GetBoneName( id ) != "__INVALIDBONE__" ) then
				hasBones = true
				break
			end
		end
	end

	if ( !hasBones ) then
		boxText( "tool.rb655_easy_bonemerge.noshared", ScrW() / 2, ScrH() / 2 + 32 )

		local size = 32
		surface.SetDrawColor( color_white )
		surface.SetMaterial( crossmat )
		surface.DrawTexturedRect( ScrW() / 2 - size / 2, ScrH() / 2 - size / 2, size, size )
	end

	if ( hasBones and ent:GetBoneCount() < target:GetBoneCount() and target != ent ) then
		boxText( "tool.rb655_easy_bonemerge.backwards", ScrW() / 2, ScrH() / 2 + 100 )
	end
end

--addons/wos-alcs-custom/lua/weapons/gmod_tool/stools/rb655_lightsaber.lua:

--[[

Editing the Lightsabers.

Once you unpack the lightsaber addon, you are voided of any support as to why it doesn't work.
I can't possibly provide support for all the edits and I can't know what your edits broke or whatever.

-------------------------------- DO NOT REUPLOAD THIS ADDON IN ANY SHAPE OF FORM --------------------------------
-------------------------------- DO NOT REUPLOAD THIS ADDON IN ANY SHAPE OF FORM --------------------------------
-------------------------------- DO NOT REUPLOAD THIS ADDON IN ANY SHAPE OF FORM --------------------------------
-------------------------------- DO NOT REUPLOAD THIS ADDON IN ANY SHAPE OF FORM --------------------------------
-------------------------------- DO NOT REUPLOAD THIS ADDON IN ANY SHAPE OF FORM --------------------------------

-------------------------- DO NOT EDIT ANYTHING DOWN BELOW OR YOU LOSE SUPPORT FROM ME --------------------------
-------------------------- DO NOT EDIT ANYTHING DOWN BELOW OR YOU LOSE SUPPORT FROM ME --------------------------
-------------------------- DO NOT EDIT ANYTHING DOWN BELOW OR YOU LOSE SUPPORT FROM ME --------------------------
-------------------------- DO NOT EDIT ANYTHING DOWN BELOW OR YOU LOSE SUPPORT FROM ME --------------------------
-------------------------- DO NOT EDIT ANYTHING DOWN BELOW OR YOU LOSE SUPPORT FROM ME --------------------------
-------------------------- DO NOT EDIT ANYTHING DOWN BELOW OR YOU LOSE SUPPORT FROM ME --------------------------

]]

TOOL.Category = "Robotboy655"
TOOL.Name = "#tool.rb655_lightsaber"

TOOL.ClientConVar["model"] = "models/sgg/starwars/weapons/w_anakin_ep2_saber_hilt.mdl"
TOOL.ClientConVar["red"] = "0"
TOOL.ClientConVar["green"] = "127"
TOOL.ClientConVar["blue"] = "255"
TOOL.ClientConVar["bladew"] = "2"
TOOL.ClientConVar["bladel"] = "42"

TOOL.ClientConVar["dark"] = "0"
TOOL.ClientConVar["starton"] = "1"

TOOL.ClientConVar["humsound"] = "lightsaber/saber_loop1.wav"
TOOL.ClientConVar["swingsound"] = "lightsaber/saber_swing1.wav"
TOOL.ClientConVar["onsound"] = "lightsaber/saber_on1.wav"
TOOL.ClientConVar["offsound"] = "lightsaber/saber_off1.wav"

cleanup.Register( "ent_lightsabers" )

if ( SERVER ) then
	CreateConVar( "sbox_maxent_lightsabers", 2 )

	function MakeLightsaber( ply, model, pos, ang, LoopSound, SwingSound, OnSound, OffSound )
		if ( IsValid( ply ) && !ply:CheckLimit( "ent_lightsabers" ) ) then return false end

		local ent_lightsaber = ents.Create( "ent_lightsaber" )
		if ( !IsValid( ent_lightsaber ) ) then return false end

		ent_lightsaber:SetModel( model )
		ent_lightsaber:SetAngles( ang )
		ent_lightsaber:SetPos( pos )
		--ent_lightsaber:SetCrystalColor( clr )
		--ent_lightsaber:SetColor( clr )
		--ent_lightsaber:SetEnabled( tobool( Enabled ) )

		table.Merge( ent_lightsaber:GetTable(), {
			Owner = ply,
			--clr = clr,
			--Enabled = tobool( Enabled ),
			LoopSound = LoopSound,
			SwingSound = SwingSound,
			OnSound = OnSound,
			OffSound = OffSound,
		} )

		ent_lightsaber:Spawn()
		ent_lightsaber:Activate()

		if ( IsValid( ply ) ) then
			ply:AddCount( "ent_lightsabers", ent_lightsaber )
			ply:AddCleanup( "ent_lightsabers", ent_lightsaber )
		end

		DoPropSpawnedEffect( ent_lightsaber )

		return ent_lightsaber
	end

	duplicator.RegisterEntityClass( "ent_lightsaber", MakeLightsaber, "model", "pos", "ang", "LoopSound", "SwingSound", "OnSound", "OffSound" )
end

local tbl = {
"models/sgg/starwars/weapons/w_anakin_ep2_saber_hilt.mdl",
"models/sgg/starwars/weapons/w_anakin_ep3_saber_hilt.mdl",
"models/sgg/starwars/weapons/w_common_jedi_saber_hilt.mdl",
"models/sgg/starwars/weapons/w_luke_ep6_saber_hilt.mdl",
"models/sgg/starwars/weapons/w_mace_windu_saber_hilt.mdl",
"models/sgg/starwars/weapons/w_maul_saber_half_hilt.mdl",
"models/sgg/starwars/weapons/w_obiwan_ep1_saber_hilt.mdl",
"models/sgg/starwars/weapons/w_obiwan_ep3_saber_hilt.mdl",
"models/sgg/starwars/weapons/w_quigon_gin_saber_hilt.mdl",
"models/sgg/starwars/weapons/w_sidious_saber_hilt.mdl",
"models/sgg/starwars/weapons/w_vader_saber_hilt.mdl",
"models/sgg/starwars/weapons/w_yoda_saber_hilt.mdl",
"models/weapons/starwars/w_kr_hilt.mdl",
"models/weapons/starwars/w_maul_saber_staff_hilt.mdl",
"models/weapons/starwars/w_dooku_saber_hilt.mdl",
}

for _, model in pairs( tbl ) do
	list.Set( "LightsaberModels", model, {} )
end


function TOOL:Deploy()

	if CLIENT then return end
	if wOS.LegacyToolgun then return end
	local ply = self:GetOwner()
	if not IsValid( ply ) then return end
	
	local group = ply:GetUserGroup()
	local teamr = ply:Team()
	
end

net.Receive( "wOS.SendHiltsConfig", function()

	local tbl = net.ReadTable()
	for _, model in pairs( wOS.AllSaberModels ) do
		list.Set( "LightsaberModels", model, nil )
	end
	
	for _, model in pairs( tbl ) do
		list.Set( "LightsaberModels", model, {} )	
	end	
	
	LocalPlayer().wOSRefresh = true
	
end )


function TOOL:LeftClick( trace )
	if ( trace.HitSky || !trace.HitPos ) then return false end
	if ( IsValid( trace.Entity ) && ( trace.Entity:GetClass() == "ent_lightsaber" || trace.Entity:IsPlayer() ) ) then return false end
	--if ( trace.Entity:IsNPC() && trace.Entity:GetClass() != "npc_metropolice" ) then return false end
	if ( CLIENT ) then return true end

	local ply = self:GetOwner()

	local ang = trace.HitNormal:Angle()
	ang.pitch = ang.pitch - 90

	if ( trace.HitNormal.z > 0.99 ) then ang.y = ply:GetAngles().y end

	local r = self:GetClientNumber( "red" )
	local g = self:GetClientNumber( "green" )
	local b = self:GetClientNumber( "blue" )

	local hs = self:GetClientInfo( "humsound" )
	local ss = self:GetClientInfo( "swingsound" )
	local ons = self:GetClientInfo( "onsound" )
	local offs = self:GetClientInfo( "offsound" )

	local dark = self:GetClientNumber( "dark" )
	local enabled = self:GetClientNumber( "starton" )
	local mdl = self:GetClientInfo( "model" )

	local bld_w = math.Clamp( self:GetClientNumber( "bladew" ), 2, 4 )
	local bld_len = math.Clamp( self:GetClientNumber( "bladel" ), 32, 64 )

	local ent_lightsaber
	if ( trace.Entity:IsNPC() ) then
		if ( !IsValid( trace.Entity:GetActiveWeapon() ) || trace.Entity:GetActiveWeapon():GetClass() != "weapon_lightsaber_wos" ) then
			ent_lightsaber = trace.Entity:Give( "weapon_lightsaber_wos" )
		else
			ent_lightsaber = trace.Entity:GetActiveWeapon()
		end
		if ( !IsValid( ent_lightsaber ) ) then return end

		ent_lightsaber:SetModel( mdl )
		ent_lightsaber:SetWorldModel( mdl )
		ent_lightsaber.LoopSound = hs
		ent_lightsaber.SwingSound = ss
		ent_lightsaber:SetOnSound( ons )
		ent_lightsaber:SetOffSound( offs )

	else
		ent_lightsaber = MakeLightsaber( ply, mdl, trace.HitPos, ang, hs, ss, ons, offs )
	end

	if ( !IsValid( ent_lightsaber ) ) then return end

	if ( ent_lightsaber:IsWeapon() ) then -- Special case for giving NPC a weapon
		ent_lightsaber:SetCrystalColor( Vector( r, g, b ) )
	else
		ent_lightsaber:SetCrystalColor( Vector( r, g, b ) / 255 )
		ent_lightsaber:SetEnabled( tobool( enabled ) )
	end
	ent_lightsaber:SetDarkInner( tobool( dark ) )
	ent_lightsaber:SetMaxLength( bld_len )
	ent_lightsaber:SetBladeWidth( bld_w )

	local min = ent_lightsaber:OBBMins()
	ent_lightsaber:SetPos( trace.HitPos - trace.HitNormal * min.z )

	local phys = ent_lightsaber:GetPhysicsObject()
	if ( IsValid( phys ) ) then phys:Wake() end

	--[[if ( trace.Entity:IsNPC() && trace.Entity:GetClass() == "npc_metropolice" ) then
		ent_lightsaber:SetParent( trace.Entity )
		ent_lightsaber:Fire( "SetParentAttachment", "RHand" )

		timer.Simple( 0.1, function()
			ent_lightsaber:SetLocalAngles( Angle( -85, 40, 0 ) )
			ent_lightsaber:SetLocalPos( Vector( -1.3, -1.3, -12 ) )
		end )
	end]]

	undo.Create( "ent_lightsaber" )
		undo.AddEntity( ent_lightsaber )
		undo.SetPlayer( ply )
	undo.Finish()

	return true
end

function TOOL:RightClick( trace )
	if ( trace.HitSky || !trace.HitPos ) then return false end
	if ( IsValid( trace.Entity ) && ( trace.Entity:GetClass() == "ent_lightsaber" ) ) then return false end
	if ( CLIENT ) then return true end

	local ply = self:GetOwner()
	--[[if ( IsValid( ply:GetEyeTrace().Entity ) && ply:GetEyeTrace().Entity:IsPlayer() ) then
		ply = ply:GetEyeTrace().Entity
	end]]

	ply:StripWeapon( "weapon_lightsaber_wos" )
	local w = ply:Give( "weapon_lightsaber_wos" )

	w:SetMaxLength( math.Clamp( ply:GetInfoNum( "rb655_lightsaber_bladel", 42 ), 32, 64 ) )
	w:SetCrystalColor( Vector( ply:GetInfo( "rb655_lightsaber_red" ), ply:GetInfo( "rb655_lightsaber_green" ), ply:GetInfo( "rb655_lightsaber_blue" ) ) )
	w:SetDarkInner( ply:GetInfo( "rb655_lightsaber_dark" ) == "1" )
	w:SetWorldModel( ply:GetInfo( "rb655_lightsaber_model" ) )
	w:SetBladeWidth( math.Clamp( ply:GetInfoNum( "rb655_lightsaber_bladew", 2 ), 2, 4 ) )

	w.LoopSound = ply:GetInfo( "rb655_lightsaber_humsound" )
	w.SwingSound = ply:GetInfo( "rb655_lightsaber_swingsound" )
	w:SetOnSound( ply:GetInfo( "rb655_lightsaber_onsound" ) )
	w:SetOffSound( ply:GetInfo( "rb655_lightsaber_offsound" ) )
	w:SetEnabled( tobool( ply:GetInfo( "rb655_lightsaber_starton" ) ) )

	timer.Simple( 0.2, function() ply:SelectWeapon( "weapon_lightsaber_wos" ) end )

	return true
end

function TOOL:UpdateGhostEntity( ent, ply )
	if ( !IsValid( ent ) ) then return end

	local trace = ply:GetEyeTrace()

	if ( !trace.Hit ) then ent:SetNoDraw( true ) return end
	if ( IsValid( trace.Entity ) && trace.Entity:GetClass() == "ent_lightsaber" || trace.Entity:IsPlayer() || trace.Entity:IsNPC() ) then ent:SetNoDraw( true ) return end

	local ang = trace.HitNormal:Angle()
	ang.p = ang.p - 90

	if ( trace.HitNormal.z > 0.99 ) then ang.y = ply:GetAngles().y end

	local min = ent:OBBMins()
	ent:SetPos( trace.HitPos - trace.HitNormal * min.z )

	ent:SetAngles( ang )
	ent:SetNoDraw( false )
end

function TOOL:Think()
	if ( !IsValid( self.GhostEntity ) || self.GhostEntity:GetModel() != self:GetClientInfo( "model" ) ) then
		self:MakeGhostEntity( self:GetClientInfo( "model" ), Vector( 0, 0, 0 ), Angle( 0, 0, 0 ) )
	end

	self:UpdateGhostEntity( self.GhostEntity, self:GetOwner() )
end

list.Set( "rb655_LightsaberHumSounds", "#tool.rb655_lightsaber.hum.1", { rb655_lightsaber_humsound = "lightsaber/saber_loop1.wav" } )
list.Set( "rb655_LightsaberHumSounds", "#tool.rb655_lightsaber.hum.2", { rb655_lightsaber_humsound = "lightsaber/saber_loop2.wav" } )
list.Set( "rb655_LightsaberHumSounds", "#tool.rb655_lightsaber.hum.3", { rb655_lightsaber_humsound = "lightsaber/saber_loop3.wav" } )
list.Set( "rb655_LightsaberHumSounds", "#tool.rb655_lightsaber.hum.4", { rb655_lightsaber_humsound = "lightsaber/saber_loop4.wav" } )
list.Set( "rb655_LightsaberHumSounds", "#tool.rb655_lightsaber.hum.5", { rb655_lightsaber_humsound = "lightsaber/saber_loop5.wav" } )
list.Set( "rb655_LightsaberHumSounds", "#tool.rb655_lightsaber.hum.6", { rb655_lightsaber_humsound = "lightsaber/saber_loop6.wav" } )
list.Set( "rb655_LightsaberHumSounds", "#tool.rb655_lightsaber.hum.7", { rb655_lightsaber_humsound = "lightsaber/saber_loop7.wav" } )
list.Set( "rb655_LightsaberHumSounds", "#tool.rb655_lightsaber.hum.8", { rb655_lightsaber_humsound = "lightsaber/saber_loop8.wav" } )
list.Set( "rb655_LightsaberHumSounds", "#tool.rb655_lightsaber.dark", { rb655_lightsaber_humsound = "lightsaber/darksaber_loop.wav" } )

list.Set( "rb655_LightsaberSwingSounds", "#tool.rb655_lightsaber.jedi", { rb655_lightsaber_swingsound = "lightsaber/saber_swing1.wav" } )
list.Set( "rb655_LightsaberSwingSounds", "#tool.rb655_lightsaber.sith", { rb655_lightsaber_swingsound = "lightsaber/saber_swing2.wav" } )
list.Set( "rb655_LightsaberSwingSounds", "#tool.rb655_lightsaber.dark", { rb655_lightsaber_swingsound = "lightsaber/darksaber_swing.wav" } )

list.Set( "rb655_LightsaberIgniteSounds", "#tool.rb655_lightsaber.jedi", { rb655_lightsaber_onsound = "lightsaber/saber_on1.wav", rb655_lightsaber_offsound = "lightsaber/saber_off1.wav" } )
list.Set( "rb655_LightsaberIgniteSounds", "#tool.rb655_lightsaber.jedi_fast", { rb655_lightsaber_onsound = "lightsaber/saber_on1_fast.wav", rb655_lightsaber_offsound = "lightsaber/saber_off1_fast.wav" } )
list.Set( "rb655_LightsaberIgniteSounds", "#tool.rb655_lightsaber.sith", { rb655_lightsaber_onsound = "lightsaber/saber_on2.wav", rb655_lightsaber_offsound = "lightsaber/saber_off2.wav" } )
list.Set( "rb655_LightsaberIgniteSounds", "#tool.rb655_lightsaber.sith_fast", { rb655_lightsaber_onsound = "lightsaber/saber_on2_fast.wav", rb655_lightsaber_offsound = "lightsaber/saber_off2_fast.wav" } )
list.Set( "rb655_LightsaberIgniteSounds", "#tool.rb655_lightsaber.heavy", { rb655_lightsaber_onsound = "lightsaber/saber_on3.wav", rb655_lightsaber_offsound = "lightsaber/saber_off3.wav" } )
list.Set( "rb655_LightsaberIgniteSounds", "#tool.rb655_lightsaber.heavy_fast", { rb655_lightsaber_onsound = "lightsaber/saber_on3_fast.wav", rb655_lightsaber_offsound = "lightsaber/saber_off3_fast.wav" } )
list.Set( "rb655_LightsaberIgniteSounds", "#tool.rb655_lightsaber.jedi2", { rb655_lightsaber_onsound = "lightsaber/saber_on4.wav", rb655_lightsaber_offsound = "lightsaber/saber_off4.mp3" } )
list.Set( "rb655_LightsaberIgniteSounds", "#tool.rb655_lightsaber.jedi2_fast", { rb655_lightsaber_onsound = "lightsaber/saber_on4_fast.wav", rb655_lightsaber_offsound = "lightsaber/saber_off4_fast.wav" } )
list.Set( "rb655_LightsaberIgniteSounds", "#tool.rb655_lightsaber.dark", { rb655_lightsaber_onsound = "lightsaber/darksaber_on.wav", rb655_lightsaber_offsound = "lightsaber/darksaber_off.wav" } )
list.Set( "rb655_LightsaberIgniteSounds", "#tool.rb655_lightsaber.kylo", { rb655_lightsaber_onsound = "lightsaber/saber_on_kylo.wav", rb655_lightsaber_offsound = "lightsaber/saber_off_kylo.wav" } )

if ( SERVER ) then return end

TOOL.Information = {
	{ name = "left" },
	{ name = "right" }
}

language.Add( "tool.rb655_lightsaber", "Lightsabers" )
language.Add( "tool.rb655_lightsaber.name", "Lightsabers" )
language.Add( "tool.rb655_lightsaber.desc", "Spawn customized lightsabers" )
language.Add( "tool.rb655_lightsaber.0", "Left click to spawn a Lightsaber. Right click to give yourself a Lightsaber" ) -- Not sure why I keep this
language.Add( "tool.rb655_lightsaber.left", "Spawn a Lightsaber Entity" )
language.Add( "tool.rb655_lightsaber.right", "Give yourself a Lightsaber Weapon" )

language.Add( "tool.rb655_lightsaber.model", "Hilt" )
language.Add( "tool.rb655_lightsaber.color", "Crystal Color" )
language.Add( "tool.rb655_lightsaber.take", "Take this lightsaber" )

language.Add( "tool.rb655_lightsaber.DarkInner", "Dark inner blade" )
language.Add( "tool.rb655_lightsaber.StartEnabled", "Enabled on spawn" )

language.Add( "tool.rb655_lightsaber.HumSound", "Hum Sound" )
language.Add( "tool.rb655_lightsaber.SwingSound", "Swing Sound" )
language.Add( "tool.rb655_lightsaber.IgniteSound", "Ignition Sound" )

language.Add( "tool.rb655_lightsaber.HudBlur", "Enable HUD Blur ( may reduce performance )" )

language.Add( "tool.rb655_lightsaber.bladew", "Blade Width" )
language.Add( "tool.rb655_lightsaber.bladel", "Blade Length" )

language.Add( "tool.rb655_lightsaber.jedi", "Jedi" )
language.Add( "tool.rb655_lightsaber.jedi_fast", "Jedi - Fast" )
language.Add( "tool.rb655_lightsaber.sith", "Sith" )
language.Add( "tool.rb655_lightsaber.sith_fast", "Sith - Fast" )
language.Add( "tool.rb655_lightsaber.heavy", "Heavy" )
language.Add( "tool.rb655_lightsaber.heavy_fast", "Heavy - Fast" )
language.Add( "tool.rb655_lightsaber.jedi2", "Jedi - Original" )
language.Add( "tool.rb655_lightsaber.jedi2_fast", "Jedi - Original Fast" )
language.Add( "tool.rb655_lightsaber.dark", "Dark Saber" )
language.Add( "tool.rb655_lightsaber.kylo", "Kylo Ren" )

language.Add( "tool.rb655_lightsaber.hum.1", "Default" )
language.Add( "tool.rb655_lightsaber.hum.2", "Sith Heavy" )
language.Add( "tool.rb655_lightsaber.hum.3", "Medium" )
language.Add( "tool.rb655_lightsaber.hum.4", "Heavish" )
language.Add( "tool.rb655_lightsaber.hum.5", "Sith Assassin Light" )
language.Add( "tool.rb655_lightsaber.hum.6", "Darth Vader" )
language.Add( "tool.rb655_lightsaber.hum.7", "Heavy" )
language.Add( "tool.rb655_lightsaber.hum.8", "Dooku" )

language.Add( "Cleanup_ent_lightsabers", "Lightsabers" )
language.Add( "Cleaned_ent_lightsabers", "Cleaned up all Lightsabers" )
language.Add( "SBoxLimit_ent_lightsabers", "You've hit the Lightsaber limit!" )
language.Add( "Undone_ent_lightsaber", "Lightsaber undone" )
language.Add( "max_ent_lightsabers", "Max Lightsabers" )

language.Add( "tool.rb655_lightsaber.preset1", "Darth Maul's Saberstaff" )
language.Add( "tool.rb655_lightsaber.preset2", "Darth Maul's Lightsaber" )
language.Add( "tool.rb655_lightsaber.preset3", "Darth Tyrannus's Lightsaber (Count Dooku)" )
language.Add( "tool.rb655_lightsaber.preset4", "Darth Sidious's Lightsaber" )
language.Add( "tool.rb655_lightsaber.preset5", "Darth Vader's Lightsaber" )

language.Add( "tool.rb655_lightsaber.preset6", "Master Yoda's Lightsaber" )
language.Add( "tool.rb655_lightsaber.preset7", "Qui-Gon Jinn's Lightsaber" )
language.Add( "tool.rb655_lightsaber.preset8", "Mace Windu's Lightsaber" )
language.Add( "tool.rb655_lightsaber.preset9", "[EP3] Obi-Wan Kenobi's Lightsaber" )
language.Add( "tool.rb655_lightsaber.preset10", "[EP1] Obi-Wan Kenobi's Lightsaber" )
language.Add( "tool.rb655_lightsaber.preset11", "[EP6] Luke Skywalker's Lightsaber" )
language.Add( "tool.rb655_lightsaber.preset12", "[EP2] Anakin Skywalker's Lightsaber" )
language.Add( "tool.rb655_lightsaber.preset13", "[EP3] Anakin Skywalker's Lightsaber" )
language.Add( "tool.rb655_lightsaber.preset14", "Common Jedi Lightsaber" )
language.Add( "tool.rb655_lightsaber.preset15", "Dark Saber" )
language.Add( "tool.rb655_lightsaber.preset_kylo", "Kylo Ren's Crossguard Lightsaber" )

local ConVarsDefault = TOOL:BuildConVarList()

local PresetPresets = {
	[ "#preset.default" ] = ConVarsDefault,

	-- Sith
	[ "#tool.rb655_lightsaber.preset1" ] = {
		rb655_lightsaber_model = "models/weapons/starwars/w_maul_saber_staff_hilt.mdl",
		rb655_lightsaber_red = "255",
		rb655_lightsaber_green = "0",
		rb655_lightsaber_blue = "0",
		rb655_lightsaber_dark = "0",
		rb655_lightsaber_bladew = "2.4",
		rb655_lightsaber_bladel = "45",
		rb655_lightsaber_humsound = "lightsaber/saber_loop7.wav",
		rb655_lightsaber_swingsound = "lightsaber/saber_swing2.wav",
		rb655_lightsaber_onsound = "lightsaber/saber_on2.wav",
		rb655_lightsaber_offsound = "lightsaber/saber_off2.wav"
	},
	[ "#tool.rb655_lightsaber.preset2" ] = {
		rb655_lightsaber_model = "models/sgg/starwars/weapons/w_maul_saber_half_hilt.mdl",
		rb655_lightsaber_red = "255",
		rb655_lightsaber_green = "0",
		rb655_lightsaber_blue = "0",
		rb655_lightsaber_dark = "0",
		rb655_lightsaber_bladew = "2.4",
		rb655_lightsaber_bladel = "45",
		rb655_lightsaber_humsound = "lightsaber/saber_loop7.wav",
		rb655_lightsaber_swingsound = "lightsaber/saber_swing2.wav",
		rb655_lightsaber_onsound = "lightsaber/saber_on2.wav",
		rb655_lightsaber_offsound = "lightsaber/saber_off2.wav"
	},
	[ "#tool.rb655_lightsaber.preset3" ] = {
		rb655_lightsaber_model = "models/weapons/starwars/w_dooku_saber_hilt.mdl",
		rb655_lightsaber_red = "255",
		rb655_lightsaber_green = "0",
		rb655_lightsaber_blue = "0",
		rb655_lightsaber_dark = "0",
		rb655_lightsaber_bladew = "2",
		rb655_lightsaber_bladel = "42",
		rb655_lightsaber_humsound = "lightsaber/saber_loop8.wav",
		rb655_lightsaber_swingsound = "lightsaber/saber_swing2.wav",
		rb655_lightsaber_onsound = "lightsaber/saber_on2.wav",
		rb655_lightsaber_offsound = "lightsaber/saber_off2.wav"
	},
	[ "#tool.rb655_lightsaber.preset4" ] = {
		rb655_lightsaber_model = "models/sgg/starwars/weapons/w_sidious_saber_hilt.mdl",
		rb655_lightsaber_red = "255",
		rb655_lightsaber_green = "0",
		rb655_lightsaber_blue = "0",
		rb655_lightsaber_dark = "0",
		rb655_lightsaber_bladew = "2.2",
		rb655_lightsaber_bladel = "43",
		rb655_lightsaber_humsound = "lightsaber/saber_loop5.wav",
		rb655_lightsaber_swingsound = "lightsaber/saber_swing2.wav",
		rb655_lightsaber_onsound = "lightsaber/saber_on2.wav",
		rb655_lightsaber_offsound = "lightsaber/saber_off2.wav"
	},
	[ "#tool.rb655_lightsaber.preset5" ] = {
		rb655_lightsaber_model = "models/sgg/starwars/weapons/w_vader_saber_hilt.mdl",
		rb655_lightsaber_red = "255",
		rb655_lightsaber_green = "0",
		rb655_lightsaber_blue = "0",
		rb655_lightsaber_dark = "0",
		rb655_lightsaber_bladew = "2.25",
		rb655_lightsaber_bladel = "43",
		rb655_lightsaber_humsound = "lightsaber/saber_loop6.wav",
		rb655_lightsaber_swingsound = "lightsaber/saber_swing2.wav",
		rb655_lightsaber_onsound = "lightsaber/saber_on2.wav",
		rb655_lightsaber_offsound = "lightsaber/saber_off2.wav"
	},

	-- Jedi
	[ "#tool.rb655_lightsaber.preset6" ] = {
		rb655_lightsaber_model = "models/sgg/starwars/weapons/w_yoda_saber_hilt.mdl",
		rb655_lightsaber_red = "64",
		rb655_lightsaber_green = "255",
		rb655_lightsaber_blue = "64",
		rb655_lightsaber_dark = "0",
		rb655_lightsaber_bladew = "2.3",
		rb655_lightsaber_bladel = "40",
		rb655_lightsaber_humsound = "lightsaber/saber_loop3.wav",
		rb655_lightsaber_swingsound = "lightsaber/saber_swing1.wav",
		rb655_lightsaber_onsound = "lightsaber/saber_on1.wav",
		rb655_lightsaber_offsound = "lightsaber/saber_off1.wav"
	},
	[ "#tool.rb655_lightsaber.preset7" ] = {
		rb655_lightsaber_model = "models/sgg/starwars/weapons/w_quigon_gin_saber_hilt.mdl",
		rb655_lightsaber_red = "32",
		rb655_lightsaber_green = "255",
		rb655_lightsaber_blue = "32",
		rb655_lightsaber_dark = "0",
		rb655_lightsaber_bladew = "2.2",
		rb655_lightsaber_bladel = "42",
		rb655_lightsaber_humsound = "lightsaber/saber_loop1.wav",
		rb655_lightsaber_swingsound = "lightsaber/saber_swing1.wav",
		rb655_lightsaber_onsound = "lightsaber/saber_on1.wav",
		rb655_lightsaber_offsound = "lightsaber/saber_off1.wav"
	},
	[ "#tool.rb655_lightsaber.preset8" ] = {
		rb655_lightsaber_model = "models/sgg/starwars/weapons/w_mace_windu_saber_hilt.mdl",
		rb655_lightsaber_green = "0",
		rb655_lightsaber_blue = "255",
		rb655_lightsaber_dark = "0",
		rb655_lightsaber_bladew = "2",
		rb655_lightsaber_bladel = "42",
		rb655_lightsaber_humsound = "lightsaber/saber_loop1.wav",
		rb655_lightsaber_swingsound = "lightsaber/saber_swing1.wav",
		rb655_lightsaber_red = "127",
		rb655_lightsaber_onsound = "lightsaber/saber_on1.wav",
		rb655_lightsaber_offsound = "lightsaber/saber_off1.wav"
	},
	[ "#tool.rb655_lightsaber.preset9" ] = {
		rb655_lightsaber_model = "models/sgg/starwars/weapons/w_obiwan_ep3_saber_hilt.mdl",
		rb655_lightsaber_red = "48",
		rb655_lightsaber_green = "48",
		rb655_lightsaber_blue = "255",
		rb655_lightsaber_dark = "0",
		rb655_lightsaber_bladew = "2.1",
		rb655_lightsaber_bladel = "42",
		rb655_lightsaber_humsound = "lightsaber/saber_loop1.wav",
		rb655_lightsaber_swingsound = "lightsaber/saber_swing1.wav",
		rb655_lightsaber_onsound = "lightsaber/saber_on1.wav",
		rb655_lightsaber_offsound = "lightsaber/saber_off1.wav"
	},
	[ "#tool.rb655_lightsaber.preset10" ] = {
		rb655_lightsaber_model = "models/sgg/starwars/weapons/w_obiwan_ep1_saber_hilt.mdl",
		rb655_lightsaber_red = "48",
		rb655_lightsaber_green = "48",
		rb655_lightsaber_blue = "255",
		rb655_lightsaber_dark = "0",
		rb655_lightsaber_bladew = "2.1",
		rb655_lightsaber_bladel = "42",
		rb655_lightsaber_humsound = "lightsaber/saber_loop1.wav",
		rb655_lightsaber_swingsound = "lightsaber/saber_swing1.wav",
		rb655_lightsaber_onsound = "lightsaber/saber_on1.wav",
		rb655_lightsaber_offsound = "lightsaber/saber_off1.wav"
	},
	[ "#tool.rb655_lightsaber.preset11" ] = {
		rb655_lightsaber_model = "models/sgg/starwars/weapons/w_luke_ep6_saber_hilt.mdl",
		rb655_lightsaber_red = "32",
		rb655_lightsaber_green = "255",
		rb655_lightsaber_blue = "32",
		rb655_lightsaber_dark = "0",
		rb655_lightsaber_bladew = "2.1",
		rb655_lightsaber_bladel = "42",
		rb655_lightsaber_humsound = "lightsaber/saber_loop1.wav",
		rb655_lightsaber_swingsound = "lightsaber/saber_swing1.wav",
		rb655_lightsaber_onsound = "lightsaber/saber_on1.wav",
		rb655_lightsaber_offsound = "lightsaber/saber_off1.wav"
	},
	[ "#tool.rb655_lightsaber.preset12" ] = {
		rb655_lightsaber_model = "models/sgg/starwars/weapons/w_anakin_ep2_saber_hilt.mdl",
		rb655_lightsaber_red = "0",
		rb655_lightsaber_green = "100",
		rb655_lightsaber_blue = "255",
		rb655_lightsaber_dark = "0",
		rb655_lightsaber_bladew = "2.1",
		rb655_lightsaber_bladel = "42",
		rb655_lightsaber_humsound = "lightsaber/saber_loop1.wav",
		rb655_lightsaber_swingsound = "lightsaber/saber_swing1.wav",
		rb655_lightsaber_onsound = "lightsaber/saber_on1.wav",
		rb655_lightsaber_offsound = "lightsaber/saber_off1.wav"
	},
	[ "#tool.rb655_lightsaber.preset13" ] = {
		rb655_lightsaber_model = "models/sgg/starwars/weapons/w_anakin_ep3_saber_hilt.mdl",
		rb655_lightsaber_red = "0",
		rb655_lightsaber_green = "100",
		rb655_lightsaber_blue = "255",
		rb655_lightsaber_dark = "0",
		rb655_lightsaber_bladew = "2.1",
		rb655_lightsaber_bladel = "42",
		rb655_lightsaber_humsound = "lightsaber/saber_loop1.wav",
		rb655_lightsaber_swingsound = "lightsaber/saber_swing1.wav",
		rb655_lightsaber_onsound = "lightsaber/saber_on1.wav",
		rb655_lightsaber_offsound = "lightsaber/saber_off1.wav"
	},
	[ "#tool.rb655_lightsaber.preset14" ] = {
		rb655_lightsaber_model = "models/sgg/starwars/weapons/w_common_jedi_saber_hilt.mdl",
		rb655_lightsaber_dark = "0",
		rb655_lightsaber_bladew = "2.2",
		rb655_lightsaber_bladel = "42",
		rb655_lightsaber_humsound = "lightsaber/saber_loop1.wav",
		rb655_lightsaber_swingsound = "lightsaber/saber_swing1.wav",
		rb655_lightsaber_onsound = "lightsaber/saber_on1.wav",
		rb655_lightsaber_offsound = "lightsaber/saber_off1.wav"
	},

	[ "#tool.rb655_lightsaber.preset_kylo" ] = {
		rb655_lightsaber_model = "models/weapons/starwars/w_kr_hilt.mdl",
		rb655_lightsaber_red = "255",
		rb655_lightsaber_green = "0",
		rb655_lightsaber_blue = "0",
		rb655_lightsaber_dark = "0",
		rb655_lightsaber_bladew = "2.1",
		rb655_lightsaber_bladel = "40",
		rb655_lightsaber_humsound = "lightsaber/saber_loop1.wav",
		rb655_lightsaber_swingsound = "lightsaber/saber_swing1.wav",
		rb655_lightsaber_onsound = "lightsaber/saber_on_kylo.wav",
		rb655_lightsaber_offsound = "lightsaber/saber_off_kylo.wav"
	},

	-- The Pre Vizsla's darksaber from clone wars, I LOVE IT
	[ "#tool.rb655_lightsaber.preset15" ] = {
		rb655_lightsaber_red = "255",
		rb655_lightsaber_green = "255",
		rb655_lightsaber_blue = "255",
		rb655_lightsaber_dark = "1",
		rb655_lightsaber_humsound = "lightsaber/darksaber_loop.wav",
		rb655_lightsaber_swingsound = "lightsaber/darksaber_swing.wav",
		rb655_lightsaber_onsound = "lightsaber/darksaber_on.wav",
		rb655_lightsaber_offsound = "lightsaber/darksaber_off.wav"
	},
}

function TOOL.BuildCPanel( panel )
	panel:AddControl( "ComboBox", { MenuButton = 1, Folder = "rb655_lightsabers", Options = PresetPresets, CVars = table.GetKeys( ConVarsDefault ) } )

	panel:AddControl( "PropSelect", {Label = "#tool.rb655_lightsaber.model", Height = 4, ConVar = "rb655_lightsaber_model", Models = list.Get( "LightsaberModels" )} )
	panel:AddControl( "Color", { Label = "#tool.rb655_lightsaber.color", Red = "rb655_lightsaber_red", Green = "rb655_lightsaber_green", Blue = "rb655_lightsaber_blue", ShowAlpha = "0", ShowHSV = "1", ShowRGB = "1" } )

	panel:AddControl( "Checkbox", { Label = "#tool.rb655_lightsaber.DarkInner", Command = "rb655_lightsaber_dark" } )
	panel:AddControl( "Checkbox", { Label = "#tool.rb655_lightsaber.StartEnabled", Command = "rb655_lightsaber_starton" } )

	panel:AddControl( "Slider", {Label = "#tool.rb655_lightsaber.bladeW", Type = "Float", Min = 2, Max = 4, Command = "rb655_lightsaber_bladew"} )
	panel:AddControl( "Slider", {Label = "#tool.rb655_lightsaber.bladeL", Type = "Float", Min = 32, Max = 64, Command = "rb655_lightsaber_bladel"} )

	panel:AddControl( "ListBox", { Label = "#tool.rb655_lightsaber.HumSound", Options = list.Get( "rb655_LightsaberHumSounds" ) } )
	panel:AddControl( "ListBox", { Label = "#tool.rb655_lightsaber.SwingSound", Options = list.Get( "rb655_LightsaberSwingSounds" ) } )
	panel:AddControl( "ListBox", { Label = "#tool.rb655_lightsaber.IgniteSound", Options = list.Get( "rb655_LightsaberIgniteSounds" ) } )

	panel:AddControl( "Checkbox", { Label = "#tool.rb655_lightsaber.HudBlur", Command = "rb655_lightsaber_hud_blur" } )

	panel.Think = function( span )
		if LocalPlayer().wOSRefresh then
			span:Clear()
			span:AddControl( "ComboBox", { MenuButton = 1, Folder = "rb655_lightsabers", Options = PresetPresets, CVars = table.GetKeys( ConVarsDefault ) } )

			span:AddControl( "PropSelect", {Label = "#tool.rb655_lightsaber.model", Height = 4, ConVar = "rb655_lightsaber_model", Models = list.Get( "LightsaberModels" )} )
			span:AddControl( "Color", { Label = "#tool.rb655_lightsaber.color", Red = "rb655_lightsaber_red", Green = "rb655_lightsaber_green", Blue = "rb655_lightsaber_blue", ShowAlpha = "0", ShowHSV = "1", ShowRGB = "1" } )

			span:AddControl( "Checkbox", { Label = "#tool.rb655_lightsaber.DarkInner", Command = "rb655_lightsaber_dark" } )
			span:AddControl( "Checkbox", { Label = "#tool.rb655_lightsaber.StartEnabled", Command = "rb655_lightsaber_starton" } )

			span:AddControl( "Slider", {Label = "#tool.rb655_lightsaber.bladeW", Type = "Float", Min = 2, Max = 4, Command = "rb655_lightsaber_bladew"} )
			span:AddControl( "Slider", {Label = "#tool.rb655_lightsaber.bladeL", Type = "Float", Min = 32, Max = 64, Command = "rb655_lightsaber_bladel"} )

			span:AddControl( "ListBox", { Label = "#tool.rb655_lightsaber.HumSound", Options = list.Get( "rb655_LightsaberHumSounds" ) } )
			span:AddControl( "ListBox", { Label = "#tool.rb655_lightsaber.SwingSound", Options = list.Get( "rb655_LightsaberSwingSounds" ) } )
			span:AddControl( "ListBox", { Label = "#tool.rb655_lightsaber.IgniteSound", Options = list.Get( "rb655_LightsaberIgniteSounds" ) } )

			span:AddControl( "Checkbox", { Label = "#tool.rb655_lightsaber.HudBlur", Command = "rb655_lightsaber_hud_blur" } )
			LocalPlayer().wOSRefresh = false
		end
	end
	
end

--lua/weapons/gmod_tool/stools/stacker_improved.lua:
--[[--------------------------------------------------------------------------
	Improved Stacker Tool

	Note:
		Please DO NOT reupload this tool (verbatim or small tweaks) to the workshop or other public file-sharing websites.
		I actively maintain this tool, so reuploading it may lead to people using outdated, buggy, or malicious copies.
		If there is an issue with the tool, LET ME KNOW via one of the following pages:
		
		- GitHub:    https://github.com/Mista-Tea/improved-stacker
		- Workshop:  http://steamcommunity.com/sharedfiles/filedetails/?id=264467687
		- Facepunch: https://facepunch.com/showthread.php?t=1399120
	
	Author:
		- Original            :: OverloadUT (STEAM_0:1:5250809)
		- Updated for GMod 13 :: Marii      (STEAM_0:1:16015332)
		- Rewritten           :: Mista Tea  (STEAM_0:0:27507323)
	
	Changelog:
		- May 27th, 2014 :: Added to GitHub 
		- May 28th, 2014 :: Added to Workshop 
		- Jun 5th,  2014 :: Massive overhaul 
		- Jul 24th, 2014 :: Large update 
		- Aug 12th, 2014 :: Optimizations 
		- Jun 30th, 2015 :: Bug fixes/features 
		- Jul 11th, 2015 :: Bug fixes 
		- Oct 26th, 2015 :: Bug fixes
		- Aug 3rd,  2016 :: Bug fixes
		- Aug 31st, 2016 :: Bug fixes
		- Sep 2nd,  2016 :: Added Bulgarian language support
		- Sep 26th, 2017 :: Added ability to toggle use of SHIFT key with LMB/RMB
		- Oct 27th, 2017 :: Small client optimization, reverted nocollide implementation back to original
		- Apr 14th, 2018 :: Added French language support
		- Oct 12th, 2018 :: Added Polish language support
		- Jul 21st, 2019 :: Added Russian language support
		- Jul 23rd, 2019 :: Added Simplified Chinese language support
		- May 10th, 2020 :: Fixed unstable clientside ghosts caused by ents.CreateClientProp changes
		- Jun 18th, 2020 :: Clientside performance improvement when tool is not selected
		- Apr 30th, 2021 :: Added German language support
		
		Fixes:
			- Prevented crash from players using very high X/Y/Z offset values.
			- Prevented crash from players using very high P/Y/R rotate values.
			- Prevented crash from very specific constraint settings.
			- Fixed the halo option for ghosted props not working.
			- Fixed massive FPS drop from halos being rendered in a Think hook instead of a PreDrawHalos hook.
			- Fixed materials and color saving when duping stacked props.
			- Fixed incorrect stack angles when trying to create a stack on an existing stack.
			
		Tweaks:
			- Added convenience functions to retrieve the client convars.
			- Added option to enable/disable automatically applying materials to the stacked props.
			- Added option to enable/disable automatically applying colors to the stacked props.
			- Added option to enable/disable automatically applying physical properties (gravity, physics material, weight) to the stacked props.
			- Added support for props with multiple skins.
			- Added support for external prop protections/anti-spam addons with the StackerEntity hook.
			- Modified NoCollide to actually no-collide each stacker prop with every other prop in the stack.
			
			- Added console variables for server operators to limit various parts of stacker.
				> stacker_improved_max_per_player         <-inf/inf> (less than 0 == no limit)
				> stacker_improved_max_per_stack          <-inf/inf> (less than 0 == no limit)
				> stacker_improved_max_offsetx            <-inf/inf>
				> stacker_improved_max_offsety            <-inf/inf>
				> stacker_improved_max_offsetz            <-inf/inf>
				> stacker_improved_force_stayinworld         <0/1>
				> stacker_improved_force_weld                <0/1>
				> stacker_improved_force_freeze              <0/1>
				> stacker_improved_force_nocollide           <0/1>
				> stacker_improved_force_nocollide_all       <0/1>
				> stacker_improved_delay                     <0/inf>

			- Added console commands for server admins to control the console variables that limit stacker.
				> stacker_improved_set_max_per_player     <-inf/inf> (less than 0 == no limit)
				> stacker_improved_set_max_per_stack      <-inf/inf> (less than 0 == no limit)
				> stacker_improved_set_maxoffset          <-inf/inf>
				> stacker_improved_set_maxoffsetx         <-inf/inf>
				> stacker_improved_set_maxoffsety         <-inf/inf>
				> stacker_improved_set_maxoffsetz         <-inf/inf>
				> stacker_improved_set_force_stayinworld     <0/1>
				> stacker_improved_set_weld                  <0/1>
				> stacker_improved_set_freeze                <0/1>
				> stacker_improved_set_nocollide             <0/1>
				> stacker_improved_set_nocollide_all         <0/1>
				> stacker_improved_set_delay                 <0/inf>

----------------------------------------------------------------------------]]

local mode = TOOL.Mode -- defined by the name of this file (default should be stacker_improved)

--[[--------------------------------------------------------------------------
-- Modules & Dependencies
--------------------------------------------------------------------------]]--

-- needed for localization support (depends on GMod locale: "gmod_language")
include( "improvedstacker/localify.lua" )
localify.LoadSharedFile( "improvedstacker/localization.lua" ) -- loads the file containing localized phrases
local L = localify.Localize                                   -- used for translating string tokens into localized phrases
local prefix = "#tool."..mode.."."                            -- prefix used for this tool's localization tokens

-- needed for various stacker functionality
include( "improvedstacker/improvedstacker.lua" )
improvedstacker.Initialize( mode )

--[[--------------------------------------------------------------------------
-- Localized Functions & Variables
--------------------------------------------------------------------------]]--

-- localizing global functions/tables is an encouraged practice that improves code efficiency,
-- since accessing a local value is considerably faster than a global value
local bit = bit
local cam = cam
local net = net
local util = util
local math = math
local undo = undo
local halo = halo
local game = game
local ents = ents
local draw = draw
local hook = hook
local list = list
local pairs = pairs
local table = table
local Angle = Angle
local Color = Color
local render = render
local Vector = Vector
local tobool = tobool
local CurTime = CurTime
local surface = surface
local IsValid = IsValid
local localify = localify
local language = language
local tonumber = tonumber
local GetConVar = GetConVar
local construct = construct
local duplicator = duplicator
local constraint = constraint
local concommand = concommand
local LocalPlayer = LocalPlayer
local CreateConVar = CreateConVar
local improvedstacker = improvedstacker
local GetConVarNumber = GetConVarNumber
local RunConsoleCommand = RunConsoleCommand

local IN_USE = IN_USE
local NOTIFY_ERROR = NOTIFY_ERROR or 1
local MOVETYPE_NONE = MOVETYPE_NONE
local SOLID_VPHYSICS = SOLID_VPHYSICS
local RENDERMODE_TRANSALPHA = RENDERMODE_TRANSALPHA

local TRANSPARENT = Color( 255, 255, 255, 150 )

local MIN_NOTIFY_BITS = 3 -- the minimum number of bits needed to send a NOTIFY enum
local NOTIFY_DURATION = 5 -- the number of seconds to display notifications

local MAX_ANGLE = 180

local showSettings = false

--[[--------------------------------------------------------------------------
-- Tool Settings
--------------------------------------------------------------------------]]--

TOOL.Category = "Construction"
TOOL.Name     = L(prefix.."name")

TOOL.Information = {
	"left",
	"right",
	{ 
		name  = "shift_left",
		icon2  = "gui/e.png",
		icon = "gui/lmb.png",
		
	},
	{
		name  = "shift_right",
		icon2  = "gui/e.png",
		icon = "gui/rmb.png",
	},
	"reload",
}

if ( CLIENT ) then

	TOOL.ClientConVar[ "mode" ]          = improvedstacker.MODE_PROP
	TOOL.ClientConVar[ "direction" ]     = improvedstacker.DIRECTION_UP
	TOOL.ClientConVar[ "count" ]         = "1"
	TOOL.ClientConVar[ "freeze" ]        = "1"
	TOOL.ClientConVar[ "weld" ]          = "1"
	TOOL.ClientConVar[ "nocollide" ]     = "1"
	TOOL.ClientConVar[ "ghostall" ]      = "1"
	TOOL.ClientConVar[ "material" ]      = "1"
	TOOL.ClientConVar[ "physprop" ]      = "1"
	TOOL.ClientConVar[ "color" ]         = "1"
	TOOL.ClientConVar[ "offsetx" ]       = "0"
	TOOL.ClientConVar[ "offsety" ]       = "0"
	TOOL.ClientConVar[ "offsetz" ]       = "0"
	TOOL.ClientConVar[ "pitch" ]         = "0"
	TOOL.ClientConVar[ "yaw" ]           = "0"
	TOOL.ClientConVar[ "roll" ]          = "0"
	TOOL.ClientConVar[ "relative" ]      = "1"
	TOOL.ClientConVar[ "draw_halos" ]    = "0"
	TOOL.ClientConVar[ "halo_r" ]        = "255"
	TOOL.ClientConVar[ "halo_g" ]        = "0"
	TOOL.ClientConVar[ "halo_b" ]        = "0"
	TOOL.ClientConVar[ "halo_a" ]        = "255"
	TOOL.ClientConVar[ "draw_axis" ]     = "1"
	TOOL.ClientConVar[ "axis_labels" ]   = "1"
	TOOL.ClientConVar[ "axis_angles" ]   = "0"
	TOOL.ClientConVar[ "opacity" ]       = "100"
	TOOL.ClientConVar[ "use_shift_key" ] = "0"

	--[[--------------------------------------------------------------------------
	-- Language Settings
	--------------------------------------------------------------------------]]--

	language.Add( "tool."..mode..".name",         L(prefix.."name") )
	language.Add( "tool."..mode..".desc",         L(prefix.."desc") )
	--language.Add( "tool."..mode..".0",            L(prefix.."0") )
	language.Add( "tool."..mode..".left",         L(prefix.."left") )
	language.Add( "tool."..mode..".shift_left",   L(prefix.."shift_left") )
	language.Add( "tool."..mode..".right",        L(prefix.."right") )
	language.Add( "tool."..mode..".shift_right",  L(prefix.."shift_right") )
	language.Add( "tool."..mode..".reload",       L(prefix.."reload") )
	language.Add( "Undone_"..mode,                L("Undone_"..mode) )
	
	--[[--------------------------------------------------------------------------
	-- Net Messages
	--------------------------------------------------------------------------]]--
	
	--[[--------------------------------------------------------------------------
	-- 	Net :: <toolmode>_error( string )
	--]]--
	net.Receive( mode.."_error", function( bytes )
		surface.PlaySound( "buttons/button10.wav" )
		notification.AddLegacy( net.ReadString(), net.ReadUInt(MIN_NOTIFY_BITS), NOTIFY_DURATION )
	end )
	
end

--[[--------------------------------------------------------------------------
-- Console Variables
--------------------------------------------------------------------------]]--

-- This is solely for backwards compatibility.
-- We're essentially copying everyone's old cvar values over since we're switching from 'stacker' to 'stacker_improved'.
-- If we didn't do this, we'd run the risk of ruining someone's custom setup
--[[local oldMaxTotal    = GetConVar( "stacker_max_total" )       and GetConVar( "stacker_max_total" ):GetInt()       or -1
local oldMaxCount    = GetConVar( "stacker_max_count" )       and GetConVar( "stacker_max_count" ):GetInt()       or 15
local oldMaxOffX     = GetConVar( "stacker_max_offsetx" )     and GetConVar( "stacker_max_offsetx" ):GetFloat()   or 200
local oldMaxOffY     = GetConVar( "stacker_max_offsety" )     and GetConVar( "stacker_max_offsety" ):GetFloat()   or 200
local oldMaxOffZ     = GetConVar( "stacker_max_offsetz" )     and GetConVar( "stacker_max_offsetz" ):GetFloat()   or 200
local oldStayInWorld = GetConVar( "stacker_stayinworld" )     and GetConVar( "stacker_stayinworld" ):GetInt()     or 1
local oldFreeze      = GetConVar( "stacker_force_freeze" )    and GetConVar( "stacker_force_freeze" ):GetInt()    or 0
local oldWeld        = GetConVar( "stacker_force_weld" )      and GetConVar( "stacker_force_weld" ):GetInt()      or 0
local oldNoCollide   = GetConVar( "stacker_force_nocollide" ) and GetConVar( "stacker_force_nocollide" ):GetInt() or 0
local oldDelay       = GetConVar( "stacker_delay" )           and GetConVar( "stacker_delay" ):GetFloat()         or 0.25
]]
local cvarFlags, cvarFlagsNotify

if ( SERVER ) then
	cvarFlags      = bit.bor( FCVAR_REPLICATED, FCVAR_SERVER_CAN_EXECUTE, FCVAR_ARCHIVE )
	cvarFlagsNotif = bit.bor( cvarFlags, FCVAR_NOTIFY )
elseif ( CLIENT ) then
	cvarFlags      = bit.bor( FCVAR_REPLICATED, FCVAR_SERVER_CAN_EXECUTE, FCVAR_ARCHIVE )
	cvarFlagsNotif = bit.bor( cvarFlags, FCVAR_NOTIFY )
end

local oldMaxTotal    = CreateConVar( "stacker_max_total",        -1, cvarFlagsNotif, "Defines the max amount of props that a player can have spawned from stacker" )
local oldMaxCount    = CreateConVar( "stacker_max_count",        15, cvarFlagsNotif, "Defines the max amount of props that can be stacked at a time" )
local oldDelay       = CreateConVar( "stacker_delay",           0.5, cvarFlagsNotif, "Determines the amount of time that must pass before a player can use stacker again" )
local oldMaxOffX     = CreateConVar( "stacker_max_offsetx",     200, cvarFlagsNotif, "Defines the max distance on the x plane that stacked props can be offset (for individual control)" )
local oldMaxOffY     = CreateConVar( "stacker_max_offsety",     200, cvarFlagsNotif, "Defines the max distance on the y plane that stacked props can be offset (for individual control)" )
local oldMaxOffZ     = CreateConVar( "stacker_max_offsetz",     200, cvarFlagsNotif, "Defines the max distance on the z plane that stacked props can be offset (for individual control)" )
local oldFreeze      = CreateConVar( "stacker_force_freeze",      0, cvarFlagsNotif, "Determines whether props should be forced to spawn frozen or not" )
local oldWeld        = CreateConVar( "stacker_force_weld",        0, cvarFlagsNotif, "Determines whether props should be forced to spawn welded or not" )
local oldNoCollide   = CreateConVar( "stacker_force_nocollide",   0, cvarFlagsNotif, "Determines whether props should be forced to spawn nocollided or not" )
local oldStayInWorld = CreateConVar( "stacker_stayinworld",       1, cvarFlagsNotif, "Determines whether props should be restricted to spawning inside the world or not (addresses possible crashes)" )

local cvarMaxPerPlayer = CreateConVar( mode.."_max_per_player",      oldMaxTotal:GetInt(),    cvarFlags,      "Defines the max amount of props that a player can have spawned from stacker" )
local cvarMaxPerStack  = CreateConVar( mode.."_max_per_stack",       oldMaxCount:GetInt(),    cvarFlags,      "Defines the max amount of props that can be stacked at a time" )
local cvarDelay        = CreateConVar( mode.."_delay",               oldDelay:GetFloat(),     cvarFlags,      "Determines the amount of time that must pass before a player can use stacker again" )
local cvarMaxOffX      = CreateConVar( mode.."_max_offsetx",         oldMaxOffX:GetFloat(),   cvarFlags,      "Defines the max distance on the x plane that stacked props can be offset (for individual control)" )
local cvarMaxOffY      = CreateConVar( mode.."_max_offsety",         oldMaxOffY:GetFloat(),   cvarFlags,      "Defines the max distance on the y plane that stacked props can be offset (for individual control)" )
local cvarMaxOffZ      = CreateConVar( mode.."_max_offsetz",         oldMaxOffZ:GetFloat(),   cvarFlags,      "Defines the max distance on the z plane that stacked props can be offset (for individual control)" )
local cvarFreeze       = CreateConVar( mode.."_force_freeze",        oldFreeze:GetInt(),      cvarFlagsNotif, "Determines whether props should be forced to spawn frozen or not" )
local cvarWeld         = CreateConVar( mode.."_force_weld",          oldWeld:GetInt(),        cvarFlagsNotif, "Determines whether props should be forced to spawn welded or not" )
local cvarNoCollide    = CreateConVar( mode.."_force_nocollide",     oldNoCollide:GetInt(),   cvarFlagsNotif, "Determines whether props should be forced to spawn nocollided or not" )
local cvarNoCollideAll = CreateConVar( mode.."_force_nocollide_all", 0,                       cvarFlags,      "(EXPERIMENTAL, DISABLED) Determines whether props should be nocollide with everything except players, vehicles, and npcs" )
local cvarStayInWorld  = CreateConVar( mode.."_force_stayinworld",   oldStayInWorld:GetInt(), cvarFlagsNotif, "Determines whether props should be restricted to spawning inside the world or not (addresses possible crashes)" )

--[[--------------------------------------------------------------------------
-- Console Commands
--------------------------------------------------------------------------]]--

if ( CLIENT ) then
	
	concommand.Add( mode.."_reset_offsets", function( ply, cmd, args )
		-- reset all of the offset values to 0
		RunConsoleCommand( mode.."_offsetx", "0.00" )
		RunConsoleCommand( mode.."_offsety", "0.00" )
		RunConsoleCommand( mode.."_offsetz", "0.00" )
	end	)
	
	concommand.Add( mode.."_reset_angles", function( ply, cmd, args )
		-- reset all of the angle values to 0
		RunConsoleCommand( mode.."_pitch",   "0.00" )
		RunConsoleCommand( mode.."_yaw",     "0.00" )
		RunConsoleCommand( mode.."_roll",    "0.00" )
	end )
	
	concommand.Add( mode.."_reset_admin", function( ply, cmd, args )
		for cmd, val in pairs( improvedstacker.SETTINGS_DEFAULT ) do
			RunConsoleCommand( cmd, val )
		end
	end )
	
elseif ( SERVER ) then

	local function validateCommand( ply, cmd, arg )
		-- run our hook to see if the server is manually allowing/blocking this player from changing the cvar
		-- true:          allow
		-- false:         block
		-- nil (default): fallback to a ply:IsAdmin() check
		local result, reason = hook.Run( "StackerConVar", ply, cmd, arg )

		-- if a player ran the command and the server didn't explicitly allow them to change the cvar
		if ( IsValid( ply ) and result ~= true ) then
			-- if the server blocked the change, send the player an error
			if ( result == false )                     then
				ply:PrintMessage( HUD_PRINTTALK, L(prefix.."error_blocked_by_server", localify.GetLocale( ply )) .. (isstring(reason) and ": " .. reason or "") )
				return false
			end
			-- if the server didn't give a response, fallback to a ply:IsAdmin() check
			if ( result == nil and not ply:IsAdmin() ) then
				ply:PrintMessage( HUD_PRINTTALK, L(prefix.."error_not_admin", localify.GetLocale( ply )) .. ": " .. cmd )
				return false
			end
		end
		
		-- lastly, ensure the argument is a valid number before returning true
		if ( not tonumber( arg ) ) then
			ply:PrintMessage( HUD_PRINTTALK, L(prefix.."error_invalid_argument", localify.GetLocale( ply )) )
			return false
		end
		
		return true
	end
	--[[-------------------------------------------------------------]]--
	concommand.Add( mode.."_set_max_per_player", function( ply, cmd, args )
		if ( not validateCommand( ply, mode.."_set_max_per_player", args[1] ) ) then return false end
		RunConsoleCommand( mode.."_max_per_player", args[1] )
	end )
	--[[-------------------------------------------------------------]]--
	concommand.Add( mode.."_set_max_per_stack", function( ply, cmd, args )
		if ( not validateCommand( ply, mode.."_set_max_per_stack", args[1] ) ) then return false end
		RunConsoleCommand( mode.."_max_per_stack", args[1] )
	end )
	--[[-------------------------------------------------------------]]--
	concommand.Add( mode.."_set_max_offset", function( ply, cmd, args )
		if ( not validateCommand( ply, mode.."_set_max_offset", args[1] ) ) then return false end
		RunConsoleCommand( mode.."_max_offsetx", args[1] )
		RunConsoleCommand( mode.."_max_offsety", args[1] )
		RunConsoleCommand( mode.."_max_offsetz", args[1] )
	end )
	--[[-------------------------------------------------------------]]--
	concommand.Add( mode.."_set_max_offsetx", function( ply, cmd, args )
		if ( not validateCommand( ply, mode.."_set_max_offsetx", args[1] ) ) then return false end
		RunConsoleCommand( mode.."_max_offsetx", args[1] )
	end )
	--[[-------------------------------------------------------------]]--
	concommand.Add( mode.."_set_max_offsety", function( ply, cmd, args )
		if ( not validateCommand( ply, mode.."_set_max_offsety", args[1] ) ) then return false end
		RunConsoleCommand( mode.."_max_offsety", args[1] )
	end )
	--[[-------------------------------------------------------------]]--
	concommand.Add( mode.."_set_max_offsetz", function( ply, cmd, args )
		if ( not validateCommand( ply, mode.."_set_max_offsetz", args[1] ) ) then return false end
		RunConsoleCommand( mode.."_max_offsetz", args[1] )
	end )
	--[[-------------------------------------------------------------]]--
	concommand.Add( mode.."_set_force_stayinworld", function( ply, cmd, args )
		if ( not validateCommand( ply, mode.."_set_force_stayinworld", args[1] ) ) then return false end
		RunConsoleCommand( mode.."_force_stayinworld", tobool( args[1] ) and "1" or "0" )
	end )
	--[[-------------------------------------------------------------]]--
	concommand.Add( mode.."_set_force_freeze", function( ply, cmd, args )
		if ( not validateCommand( ply, mode.."_set_force_freeze", args[1] ) ) then return false end	
		RunConsoleCommand( mode.."_force_freeze", tobool( args[1] ) and "1" or "0" )
	end )
	--[[-------------------------------------------------------------]]--
	concommand.Add( mode.."_set_force_weld", function( ply, cmd, args )
		if ( not validateCommand( ply, mode.."_set_force_weld", args[1] ) ) then return false end
		RunConsoleCommand( mode.."_force_weld", tobool( args[1] ) and "1" or "0" )
	end )
	--[[-------------------------------------------------------------]]--
	concommand.Add( mode.."_set_force_nocollide", function( ply, cmd, args )
		if ( not validateCommand( ply, mode.."_set_force_nocollide", args[1] ) ) then return false end
		RunConsoleCommand( mode.."_force_nocollide", tobool( args[1] ) and "1" or "0" )
	end )
	--[[-------------------------------------------------------------]]--
	concommand.Add( mode.."_set_force_nocollide_all", function( ply, cmd, args )
		if ( not validateCommand( ply, mode.."_set_force_nocollide_all", args[1] ) ) then return false end
		RunConsoleCommand( mode.."_force_nocollide_all", tobool( args[1] ) and "1" or "0" )
	end )
	--[[-------------------------------------------------------------]]--
	concommand.Add( mode.."_set_delay", function( ply, cmd, args )
		if ( not validateCommand( ply, mode.."_set_delay", args[1] ) ) then return false end
		RunConsoleCommand( mode.."_delay", args[1] )
	end )

	
	util.AddNetworkString( mode.."_error" )

	--[[--------------------------------------------------------------------------
	--	TOOL:SendError( str )
	--	Convenience function for sending an error to the tool owner.
	--]]--
	function TOOL:SendError( str )		
		net.Start( mode.."_error" )
			net.WriteString( str )
			net.WriteUInt( NOTIFY_ERROR, MIN_NOTIFY_BITS )
		net.Send( self:GetOwner() )
	end

end

--[[--------------------------------------------------------------------------
-- Convenience Functions
--------------------------------------------------------------------------]]--

--[[--------------------------------------------------------------------------
-- 	TOOL:GetMaxPerPlayer() and TOOL:GetNumberPlayerEnts()
--
--	The total number of props a player has spawned from the Stacker tool is recorded
--	on them via ply.TotalStackerEnts. When a player removes a prop that has been spawned
--	from Stacker, the total count is decreased by 1.
--
--	In combination with the stacker_max_per_player cvar, this function can prevent players
--	from crashing the server by stacking dozens of welded props and unfreezing them.
--
--	By default, the number of stacker props is -1 (infinite). This is done to not interfere
--	with servers that don't want to limit the number of Stacker props a player can spawn directly.
--	They may still hit cvars like sbox_maxprops before ever hitting stacker_max_per_player.
--
--	As an example case, if players are crashing your servers by spawning 50 welded chairs 
--	and unfreezing them all at once, you can set stacker_max_per_player to 30 so that at any
--	given time they can only have 30 props created by Stacker. Trying to stack any more props
--	would give the player an error message.
--]]--
function TOOL:GetMaxPerPlayer()     return cvarMaxPerPlayer:GetInt() end
function TOOL:GetNumberPlayerEnts() return improvedstacker.GetEntCount( self:GetOwner(), 0 ) end

--[[--------------------------------------------------------------------------
-- 	TOOL:GetStackSize()
--	Gets the amount of props that the client wants to stack at once.
--]]--
function TOOL:GetStackSize() return self:GetClientNumber( "count" ) end

--[[--------------------------------------------------------------------------
-- 	TOOL:GetMaxPerStack()
--	Gets the maximum amount of props that can be stacked at a time.
--]]--
function TOOL:GetMaxPerStack() return cvarMaxPerStack:GetInt() end

--[[--------------------------------------------------------------------------
-- 	TOOL:GetDirection()
--	Gets the direction to stack the props.
--]]--
function TOOL:GetDirection()
	local direction = self:GetClientNumber( "direction" )
	return improvedstacker.Directions[ direction ] and direction or improvedstacker.DIRECTION_FRONT
end

--[[--------------------------------------------------------------------------
-- 	TOOL:GetStackerMode()
--	Gets the stacker mode (1 = MODE_WORLD, 2 = MODE_PROP).
--]]--
function TOOL:GetStackerMode()
	local stackMode = self:GetClientNumber( "mode" )
	return improvedstacker.Modes[ stackMode ] and stackMode or improvedstacker.MODE_PROP
end

--[[--------------------------------------------------------------------------
-- 	TOOL:GetOffsetX(), TOOL:GetOffsetY(), TOOL:GetOffsetZ(), TOOL:GetOffsetVector()
--	Gets the distance to offset the position of the stacked props.
--	These values are clamped to prevent server crashes from players
--	using very high offset values.
--]]--
function TOOL:GetOffsetX()      return math.Clamp( self:GetClientNumber( "offsetx" ), -cvarMaxOffX:GetFloat(), cvarMaxOffX:GetFloat() ) end
function TOOL:GetOffsetY()      return math.Clamp( self:GetClientNumber( "offsety" ), -cvarMaxOffY:GetFloat(), cvarMaxOffY:GetFloat() ) end
function TOOL:GetOffsetZ()      return math.Clamp( self:GetClientNumber( "offsetz" ), -cvarMaxOffZ:GetFloat(), cvarMaxOffZ:GetFloat() ) end
function TOOL:GetOffsetVector() return Vector( self:GetOffsetX(), self:GetOffsetY(), self:GetOffsetZ() ) end

--[[--------------------------------------------------------------------------
-- 	TOOL:GetRotateP(), TOOL:GetRotateY(), TOOL:GetRotateR(), TOOL:GetRotationAngle()
--	Gets the value to rotate the angle of the stacked props.
--	These values are clamped to prevent server crashes from players
--	using very high rotation values.
--]]--
function TOOL:GetRotateP()     return math.Clamp( self:GetClientNumber( "pitch" ), -MAX_ANGLE, MAX_ANGLE ) end
function TOOL:GetRotateY()     return math.Clamp( self:GetClientNumber( "yaw" ),   -MAX_ANGLE, MAX_ANGLE ) end
function TOOL:GetRotateR()     return math.Clamp( self:GetClientNumber( "roll" ),  -MAX_ANGLE, MAX_ANGLE ) end
function TOOL:GetRotationAngle() return Angle( self:GetRotateP(), self:GetRotateY(), self:GetRotateR() ) end

--[[--------------------------------------------------------------------------
-- 	TOOL:ShouldFreeze()
--	Returns true if the stacked props should be spawned frozen.
--]]--
function TOOL:ShouldApplyFreeze() return self:GetClientNumber( "freeze" ) == 1 end
function TOOL:ShouldForceFreeze() return cvarFreeze:GetBool() end
--[[--------------------------------------------------------------------------
-- 	TOOL:ShouldWeld()
--	Returns true if the stacked props should be welded together.
--]]--
function TOOL:ShouldApplyWeld() return self:GetClientNumber( "weld" ) == 1 end
function TOOL:ShouldForceWeld() return cvarWeld:GetBool() end
--[[--------------------------------------------------------------------------
-- 	TOOL:ShouldNoCollide()
--	Returns true if the stacked props should be nocollided with each other.
--]]--
function TOOL:ShouldApplyNoCollide() return self:GetClientNumber( "nocollide" ) == 1 end
function TOOL:ShouldForceNoCollide() return cvarNoCollide:GetBool() end
--[[--------------------------------------------------------------------------
-- 	TOOL:ShouldStackRelative()
--	Returns true if the stacked props should be stacked relative to the new rotation.
--	Using this setting will allow you to create curved structures out of props.
--]]--
function TOOL:ShouldStackRelative() return self:GetClientNumber( "relative" ) == 1 end
--[[--------------------------------------------------------------------------
-- 	TOOL:ShouldGhostAll()
--	Returns true if the stacked props should all be ghosted or if only the 
--	first stacked prop should be ghosted.
--]]--
function TOOL:ShouldGhostAll() return self:GetClientNumber( "ghostall" ) == 1 end

--[[--------------------------------------------------------------------------
-- 	TOOL:ShouldAddHalos(), TOOL:GetHaloR(), TOOL:GetHaloG(), TOOL:GetHaloB() TOOL:GetHaloA() TOOL:GetHaloColor()
--	Returns true if the stacked props should have halos drawn on them for added visibility.
--	Gets the RGBA values of the halo color.
--]]--
function TOOL:ShouldAddHalos() return self:GetClientNumber( "draw_halos" ) == 1 end
function TOOL:GetHaloR()       return math.Clamp( self:GetClientNumber( "halo_r" ), 0, 255 ) end
function TOOL:GetHaloG()       return math.Clamp( self:GetClientNumber( "halo_g" ), 0, 255 ) end
function TOOL:GetHaloB()       return math.Clamp( self:GetClientNumber( "halo_b" ), 0, 255 ) end
function TOOL:GetHaloA()       return math.Clamp( self:GetClientNumber( "halo_a" ), 0, 255 ) end
function TOOL:GetHaloColor()   return Color( self:GetHaloR(), self:GetHaloG(), self:GetHaloB(), self:GetHaloA() ) end

--[[--------------------------------------------------------------------------
-- 	TOOL:ShouldApplyMaterial()
--	Returns true if the stacked props should have the original prop's material applied.
--]]--
function TOOL:ShouldApplyMaterial() return self:GetClientNumber( "material" ) == 1 end

--[[--------------------------------------------------------------------------
-- 	TOOL:ShouldApplyColor()
--	Returns true if the stacked props should have the original prop's color applied.
--]]--
function TOOL:ShouldApplyColor() return self:GetClientNumber( "color" ) == 1 end

--[[--------------------------------------------------------------------------
-- 	TOOL:ShouldApplyPhysicalProperties()
--	Returns true if the stacked props should have the original prop's physicsl properties
--	applied, including gravity, physics material, and weight.
--]]--
function TOOL:ShouldApplyPhysicalProperties() return self:GetClientNumber( "physprop" ) == 1 end

--[[--------------------------------------------------------------------------
-- 	TOOL:GetDelay()
--	Returns the time in seconds that must pass before a player can use stacker again.
--	For example, if stacker_delay is set to 3, a player must wait 3 seconds in between each
--	use of stacker's left click. A delay of <= 0 means stacks can be created instantly.
--]]--
function TOOL:GetDelay() return cvarDelay:GetFloat() end

--[[--------------------------------------------------------------------------
-- 	TOOL:GetOpacity()
--	Returns the alpha value (opacity) of the ghosted props seen on the client.
--	Should be between 0 (invisible) and 255 (fully visible).
--]]--
function TOOL:GetOpacity() return self:GetClientNumber( "opacity" ) end

--[[--------------------------------------------------------------------------
-- 	TOOL:GetUseShiftKey()
--	Returns true if the client has enabled the alternate use of SHIFT in combination
--	with left and right clicking. If enable, holding SHIFT and pressing LMB/RMB will
--	have the same effect as holding E and pressing LMB/RMB.
--]]--
function TOOL:GetUseShiftKey() return self:GetClientNumber( "use_shift_key" ) == 1 end
--[[--------------------------------------------------------------------------
-- Tool Functions
--------------------------------------------------------------------------]]--

--[[--------------------------------------------------------------------------
--
-- 	TOOL:LeftClick( table, boolean = nil )
--
--	Attempts to create a stack of props relative to the entity being left clicked.
--]]--
function TOOL:LeftClick( tr, isRightClick )
	local ply = self:GetOwner()
	
	-- check if the player is holding E or SHIFT (as long as they've enabled it)
	if ( ply:KeyDown( IN_USE ) or (self:GetUseShiftKey() and ply:KeyDown( IN_SPEED )) ) then
		if ( CLIENT ) then return false end
		-- increase their stack count by 1 (until it hits the stack max)
		local newCount = self:GetStackSize() >= self:GetMaxPerStack() and self:GetMaxPerStack() or self:GetStackSize() + 1
		ply:ConCommand( mode.."_count "..newCount )
		return false
	end

	if ( not IsValid( tr.Entity ) or tr.Entity:GetClass() ~= "prop_physics" ) then return false end
	if ( CLIENT ) then return true end
	
	-- otherwise, stack 1 if right-clicking or get the client's stack size value
	local count = (isRightClick and 1) or self:GetStackSize()
	-- check if the server wants to control how many props the player can use in the stack
	local maxCount = hook.Run( "StackerMaxPerStack", ply, count, isRightClick ) or self:GetMaxPerStack()

	-- check if the player's stack size is higher than the server's max allowed size (but only if the server didn't explictly override it)
	if ( maxCount >= 0 ) then
		if ( count > maxCount ) then self:SendError( L(prefix.."error_max_per_stack", localify.GetLocale( self:GetOwner() )) .. maxCount ) end
		count = math.Clamp( count, 0, maxCount )
	end
	
	-- get the player's last stacker usage time, defaulting to 0 if it hasn't been set
	local lastStackTime = improvedstacker.GetLastStackTime( ply, 0 )
	
	-- retrieve the time delay between stacker usage
	-- we call StackerDelay to let external mods to set their own delays (less than or equal to 0 means no delay)
	-- delay time is in seconds (e.g. 0.1 is a tenth of a second)
	local delay = hook.Run( "StackerDelay", ply, lastStackTime ) or self:GetDelay()
	
	-- check if the player is trying to use stacker too quickly
	if ( lastStackTime + delay > CurTime() ) then self:SendError( L(prefix.."error_too_quick", localify.GetLocale( self:GetOwner() )) ) return false end
	improvedstacker.SetLastStackTime( ply, CurTime() )
	
	local stackDirection = self:GetDirection()
	local stackMode      = self:GetStackerMode()
	local stackOffset    = self:GetOffsetVector()
	local stackRotation  = self:GetRotationAngle()
	local stackRelative  = self:ShouldStackRelative()
	
	-- determines whether the stacked props are allowed to be positioned outside of the world or not
	local stayInWorld   = cvarStayInWorld:GetBool()

	-- store the properties of the original prop so we can apply them to the stacked props
	local ent = tr.Entity
	local entPos   = ent:GetPos()
	local entAng   = ent:GetAngles()
	local entMod   = ent:GetModel()
	local entSkin  = ent:GetSkin()
	local entMat   = ent:GetMaterial()
	local physMat  = ent:GetPhysicsObject():GetMaterial()
	local physGrav = ent:GetPhysicsObject():IsGravityEnabled()
	
	-- setup a table to hold the original prop's color data so that we can apply it to the stacked props
	local colorData = {
		Color      = ent:GetColor(), 
		RenderMode = ent:GetRenderMode(), 
		RenderFX   = ent:GetRenderFX()
	}	
		
	local newEnt
	local newEnts = { ent }
	local lastEnt = ent
	
	local direction, offset
	-- we only need to calculate the distance once based on the direction the user selected
	local distance = improvedstacker.GetDistance( stackMode, stackDirection, ent )
	
	-- setup a new undo block so the player can undo the whole stack at once
	undo.Create( mode )
	
	-- check if the server wants to control how many stacker entities this player can create
	local maxPerPlayer = hook.Run( "StackerMaxPerPlayer", ply, self:GetNumberPlayerEnts() ) or self:GetMaxPerPlayer()
	
	-- loop for every prop to create in the stack and allow external addons to dictate control over the new stacked entities
	for i = 1, count do
		
		-- check if the player has too many active stacker props spawned out already
		local stackerEntsSpawned = self:GetNumberPlayerEnts()
		if ( maxPerPlayer >= 0 and stackerEntsSpawned >= maxPerPlayer ) then self:SendError( ("%s (%s)"):format(L(prefix.."error_max_per_player", localify.GetLocale( self:GetOwner() )), maxPerPlayer) ) break end
		-- check if the player has exceeded the sbox_maxprops cvar
		if ( not self:GetSWEP():CheckLimit( "props" ) )            then break end
		-- check if external admin mods are blocking this entity
		if ( hook.Run( "PlayerSpawnProp", ply, entMod ) == false ) then break end
		
		-- if we're positioning the first entity in the stack (regardless of relative to PROP or WORLD), or
		-- if we're stacking relative to PROP and on the previous rotation, update the new direction and offset
		if ( i == 1 or ( stackMode == improvedstacker.MODE_PROP and stackRelative ) ) then
			direction = improvedstacker.GetDirection( stackMode, stackDirection, entAng )
			offset    = improvedstacker.GetOffset( stackMode, stackDirection, entAng, stackOffset )
		end

		-- calculate the next stacked entity's position
		entPos = entPos + (direction * distance) + offset
		-- rotate the next stacked entity's angle by the client's rotation values
		improvedstacker.RotateAngle( stackMode, stackDirection, entAng, stackRotation )
		
		
		-- check if the stacked props would be spawned outside of the world
		if ( stayInWorld and not util.IsInWorld( entPos ) ) then self:SendError( L(prefix.."error_not_in_world", localify.GetLocale( self:GetOwner() )) ) break end
		
		-- create the new stacked entity
		newEnt = ents.Create( "prop_physics" )
		newEnt:SetModel( entMod )
		newEnt:SetPos( entPos )
		newEnt:SetAngles( entAng )
		newEnt:SetSkin( entSkin )
		newEnt:Spawn()

		-- this hook is for external prop protections and anti-spam addons.
		-- it is called before undo, ply:AddCount, and ply:AddCleanup to allow developers to
		-- remove or mark this entity so that those same functions (if overridden) can
		-- detect that the entity came from Stacker
		if ( not IsValid( newEnt ) or hook.Run( "StackerEntity", newEnt, ply ) ~= nil )             then break end
		if ( not IsValid( newEnt ) or hook.Run( "PlayerSpawnedProp", ply, entMod, newEnt ) ~= nil ) then break end

		-- disabling this for now due to problems with ShouldCollide
		--improvedstacker.MarkEntity( self:GetOwner(), newEnt )
		
		-- increase the total number of active stacker props spawned by the player by 1
		improvedstacker.IncrementEntCount( ply )
		
		-- decrement the total number of active stacker props spawned by the player by 1
		-- when the prop gets removed in any way
		newEnt:CallOnRemove( "UpdateStackerTotal", function( ent, ply )
			-- if the player is no longer connected, there is nothing to do
			if ( not IsValid( ply ) ) then return end
			improvedstacker.DecrementEntCount( ply )
		end, ply )
		
		self:ApplyMaterial( newEnt, entMat )
		self:ApplyColor( newEnt, colorData )
		self:ApplyFreeze( ply, newEnt )
		
		-- attempt to nocollide the new entity with the last, or break out of the loop if CBaseEntityList::AddNonNetworkableEntity fails
		if ( not self:ApplyNoCollide( lastEnt, newEnt ) ) then
			newEnt:Remove()
			break
		end
		
		-- attempt to weld the new entity with the last, or break out of the loop if CBaseEntityList::AddNonNetworkableEntity fails
		if ( not self:ApplyWeld( lastEnt, newEnt ) ) then
			newEnt:Remove()
			break
		end
		
		self:ApplyPhysicalProperties( ent, newEnt, tr.PhysicsBone, { GravityToggle = physGrav, Material = physMat } )
		
		lastEnt = newEnt
		table.insert( newEnts, newEnt )
		
		undo.AddEntity( newEnt )
		ply:AddCleanup( "props", newEnt )
	end
	
	newEnts = nil
	
	undo.SetPlayer( ply )
	undo.Finish()

	-- disabling this for now due to problems with ShouldCollide
	--improvedstacker.MarkEntity( self:GetOwner(), ent )
	
	return true
end

--[[--------------------------------------------------------------------------
--
-- 	TOOL:RightClick( trace )
--
--	Performs a LeftClick operation but only creates a single stacked entity.
--	Alternatively, if the player is holding down their USE key, this will
--	decrease their stack count by 1.
--]]--
function TOOL:RightClick( tr )
	local ply = self:GetOwner()

	-- check if the player is holding E or SHIFT (as long as they've enabled it)
	if ( ply:KeyDown( IN_USE ) or (self:GetUseShiftKey() and ply:KeyDown( IN_SPEED )) ) then
		if ( CLIENT ) then return false end
		-- decrease the player's stack count by 1 (until a minimum of 1)
		local count = self:GetStackSize()
		local newCount = (count <= 1 and 1) or count - 1
		ply:ConCommand( mode.."_count " .. newCount )
		return false
	else
		-- create a single entity in the stack
		return self:LeftClick( tr, true )
	end
	
end

--[[--------------------------------------------------------------------------
--
-- 	TOOL:Reload()
--
--	Switches the client's stack direction.
--]]--
function TOOL:Reload()
	if ( CLIENT ) then return false end

	local ply = self:GetOwner()
	local direction = self:GetDirection()
	
	-- if they were at the last numerical direction (6), wrap around to the first (1)
	if ( direction == improvedstacker.DIRECTION_DOWN ) then
		direction = improvedstacker.DIRECTION_FRONT
	-- otherwise just increment to the next direction
	else
		direction = direction + 1
	end
	
	-- make the player update their client direction setting
	ply:ConCommand( mode.."_direction " .. direction )
	
	return false
end

--[[--------------------------------------------------------------------------
--
-- 	TOOL:ApplyMaterial( entity, string )
--
--	Applies the original entity's material onto the stacked props.
--]]--
function TOOL:ApplyMaterial( ent, material )
	if ( not self:ShouldApplyMaterial() ) then ent:SetMaterial( "" ) return end
	
	-- From: gamemodes/sandbox/entities/weapons/gmod_tool/stools/material.lua
	-- "Make sure this is in the 'allowed' list in multiplayer - to stop people using exploits"
	if ( not game.SinglePlayer() and not list.Contains( "OverrideMaterials", material ) and material ~= "" ) then return end

	ent:SetMaterial( material )
	duplicator.StoreEntityModifier( ent, "material", { MaterialOverride = material } )
end

--[[--------------------------------------------------------------------------
--
-- 	TOOL:ApplyColor( entity, color )
--
--	Applies the original entity's color onto the stacked props.
--]]--
function TOOL:ApplyColor( ent, data )
	if ( not self:ShouldApplyColor() ) then return end

	ent:SetColor( data.Color )
	ent:SetRenderMode( data.RenderMode )
	ent:SetRenderFX( data.RenderFX )
	
	duplicator.StoreEntityModifier( ent, "colour", table.Copy( data ) )
end

--[[--------------------------------------------------------------------------
--
-- 	TOOL:ApplyFreeze( player, entity )
--
--	Attempts to freeze the stacked props in place.
--]]--
function TOOL:ApplyFreeze( ply, ent )
	if ( self:ShouldForceFreeze() or self:ShouldApplyFreeze() ) then
		ent:GetPhysicsObject():EnableMotion( false )
	else
		ent:GetPhysicsObject():Wake()
	end
end

--[[--------------------------------------------------------------------------
--
-- 	TOOL:ApplyWeld( entity, entity )
--
--	Attempts to weld the new entity to the last entity.
--]]--
function TOOL:ApplyWeld( lastEnt, newEnt )
	if ( not self:ShouldForceWeld() and not self:ShouldApplyWeld() ) then return true end
	
	local forceLimit    = 0
	local isNocollided  = self:ShouldForceNoCollide() or self:ShouldApplyNoCollide()
	local deleteOnBreak = false
	
	local ok, err = pcall( constraint.Weld, lastEnt, newEnt, 0, 0, forceLimit, isNocollided, deleteOnBreak )
	
	if ( not ok ) then
		print( mode .. ": " .. L(prefix.."error_max_constraints") .." (error: " .. err .. ")" )
		self:SendError( mode .. ": " .. L(prefix.."error_max_constraints", localify.GetLocale( self:GetOwner() )) )
	end
	
	return ok
end

--[[--------------------------------------------------------------------------
--
-- 	TOOL:ApplyNoCollide( entity, entity )
--
--	Attempts to nocollide the new entity to the last entity.
--]]--
function TOOL:ApplyNoCollide( lastEnt, newEnt )
	if ( not self:ShouldForceNoCollide() and not self:ShouldApplyNoCollide() ) then return true end
	-- we can skip this function if the client is trying to weld -and- nocollide, because
	-- constraint.Weld already has a nocollide parameter
	if ( self:ShouldForceWeld() or self:ShouldApplyWeld() ) then return true end
	
	local ok, err = pcall( constraint.NoCollide, lastEnt, newEnt, 0, 0 )
	
	if ( not ok ) then
		print( mode .. ": " .. L(prefix.."error_max_constraints") .." (error: " .. err .. ")" )
		self:SendError( mode .. ": " .. L(prefix.."error_max_constraints", localify.GetLocale( self:GetOwner() )) )
	end
	
	return ok
end

--[[--------------------------------------------------------------------------
--
-- 	TOOL:ApplyPhysicalProperties( entity, entity, number, table )
--
--	Attempts to apply the original entity's Gravity/Physics Material properties 
--	and weight onto the stacked propa.
--	
--]]--
function TOOL:ApplyPhysicalProperties( original, newEnt, boneID, properties )
	if ( not self:ShouldApplyPhysicalProperties() ) then return end
	
	if ( boneID ) then construct.SetPhysProp( nil, newEnt, boneID, nil, properties ) end
	newEnt:GetPhysicsObject():SetMass( original:GetPhysicsObject():GetMass() )
end

if ( CLIENT ) then
	
	-- get the cvars if they're valid (e.g., editing and auto-refreshing this file).
	-- otherwise they won't be valid yet when first ran and we have to wait until
	-- TOOL:Init() gets called (below) to set them up
	local cvarTool       = GetConVar( "gmod_toolmode" )
	local cvarCount      = GetConVar( mode.."_count" )
	local cvarMode       = GetConVar( mode.."_mode" )
	local cvarDirection  = GetConVar( mode.."_direction" )
	local cvarOffsetX    = GetConVar( mode.."_offsetx" )
	local cvarOffsetY    = GetConVar( mode.."_offsety" )
	local cvarOffsetZ    = GetConVar( mode.."_offsetz" )
	local cvarPitch      = GetConVar( mode.."_pitch" )
	local cvarYaw        = GetConVar( mode.."_yaw" )
	local cvarRoll       = GetConVar( mode.."_roll" )
	local cvarRelative   = GetConVar( mode.."_relative" )
	local cvarMaterial   = GetConVar( mode.."_material" )
	local cvarColor      = GetConVar( mode.."_color" )
	local cvarGhostAll   = GetConVar( mode.."_ghostall" )
	local cvarOpacity    = GetConVar( mode.."_opacity" )
	local cvarHalo       = GetConVar( mode.."_draw_halos" )
	local cvarHaloR      = GetConVar( mode.."_halo_r" )
	local cvarHaloG      = GetConVar( mode.."_halo_g" )
	local cvarHaloB      = GetConVar( mode.."_halo_b" )
	local cvarHaloA      = GetConVar( mode.."_halo_a" )	
	local cvarHalo       = GetConVar( mode.."_draw_halos" )
	local cvarAxis       = GetConVar( mode.."_draw_axis" )
	local cvarAxisLbl    = GetConVar( mode.."_axis_labels" )
	local cvarAxisAng    = GetConVar( mode.."_axis_angles" )
	
	-- offsets for drawing the axis arrows
	local o1 = Vector(     0, 0,  0.05 )
	local o2 = Vector(     0, 0, -0.05 )
	local o3 = Vector(  0.05, 0,     0 )
	local o4 = Vector( -0.05, 0,     0 )
	local ao = 2.5
	
	-- colors for the axis arrows
	local RED   = Color( 255,  50,  50 )
	local GREEN = Color(   0, 255,   0 )
	local BLUE  = Color(  50, 150, 255 )
	local BLACK = Color(   0,   0,   0 )
	
	surface.CreateFont( mode.."_direction", {
		font = "Arial",
		size = 24,
		weight = 700,
		antialias = true
	})
	
	
	-- we're creating a bunch of local functions here using the cvars above so that we don't have to
	-- rely on the TOOL object (which can be problematic when trying to use it inside a hook).
	-- these should be pretty much identical to the TOOL functions created near the top of this file
	local function getStackSize()        return cvarCount:GetInt()       end
	local function getMaxPerStack()      return cvarMaxPerStack:GetInt() end
	local function getStackerMode()      return cvarMode:GetInt()        end
	local function getDirection()        return cvarDirection:GetInt()   end
	local function getOpacity()          return cvarOpacity:GetInt()     end	
	local function shouldGhostAll()      return cvarGhostAll:GetBool()   end
	local function shouldStackRelative() return cvarRelative:GetBool()   end
	local function shouldApplyMaterial() return cvarMaterial:GetBool()   end
	local function shouldApplyColor()    return cvarColor:GetBool()      end
	local function shouldAddHalos()      return cvarHalo:GetBool()       end
	
	local function getOffsetVector()
		return Vector( math.Clamp( cvarOffsetX:GetFloat(), -cvarMaxOffX:GetFloat(), cvarMaxOffX:GetFloat() ), 
	                   math.Clamp( cvarOffsetY:GetFloat(), -cvarMaxOffY:GetFloat(), cvarMaxOffY:GetFloat() ),
	                   math.Clamp( cvarOffsetZ:GetFloat(), -cvarMaxOffZ:GetFloat(), cvarMaxOffZ:GetFloat() ) )
	end

	local function getRotationAngle()
		return Angle( math.Clamp( cvarPitch:GetFloat(), -MAX_ANGLE, MAX_ANGLE ),
                      math.Clamp( cvarYaw:GetFloat(),   -MAX_ANGLE, MAX_ANGLE ),
                      math.Clamp( cvarRoll:GetFloat(),  -MAX_ANGLE, MAX_ANGLE ) )
	end
	
	local function getHaloColor()
		return Color( cvarHaloR:GetInt(),
                      cvarHaloG:GetInt(),
                      cvarHaloB:GetInt(),
	                  cvarHaloA:GetInt() )
	end
	
	--[[--------------------------------------------------------------------------
	--
	-- 	TOOL:Init()
	--
	--]]--
	function TOOL:Init()
		-- now the convars are truly valid, so reassign the upvalues
		cvarTool       = GetConVar( "gmod_toolmode" )
		cvarCount      = GetConVar( mode.."_count" )
		cvarMode       = GetConVar( mode.."_mode" )
		cvarDirection  = GetConVar( mode.."_direction" )
		cvarOffsetX    = GetConVar( mode.."_offsetx" )
		cvarOffsetY    = GetConVar( mode.."_offsety" )
		cvarOffsetZ    = GetConVar( mode.."_offsetz" )
		cvarPitch      = GetConVar( mode.."_pitch" )
		cvarYaw        = GetConVar( mode.."_yaw" )
		cvarRoll       = GetConVar( mode.."_roll" )
		cvarRelative   = GetConVar( mode.."_relative" )
		cvarMaterial   = GetConVar( mode.."_material" )
		cvarColor      = GetConVar( mode.."_color" )
		cvarGhostAll   = GetConVar( mode.."_ghostall" )
		cvarOpacity    = GetConVar( mode.."_opacity" )
		cvarHalo       = GetConVar( mode.."_draw_halos" )
		cvarHaloR      = GetConVar( mode.."_halo_r" )
		cvarHaloG      = GetConVar( mode.."_halo_g" )
		cvarHaloB      = GetConVar( mode.."_halo_b" )
		cvarHaloA      = GetConVar( mode.."_halo_a" )
		cvarHalo       = GetConVar( mode.."_draw_halos" )
		cvarAxis       = GetConVar( mode.."_draw_axis" )
		cvarAxisLbl    = GetConVar( mode.."_axis_labels" )
		cvarAxisAng    = GetConVar( mode.."_axis_angles" )
	end
	
	--[[--------------------------------------------------------------------------
	--
	-- 	createGhostStack( entity, vector, angle )
	--
	--	Attempts to create a stack of ghosted props on the prop the player is currently
	--	looking at before they actually left click to create the stack. This acts
	--	as a visual aid for the player so they can see the results without actually creating
	--	the entities yet (if in multiplayer).
	--]]--
	local function createGhostStack( ent )
		if ( improvedstacker.GetGhosts() ) then improvedstacker.ReleaseGhosts() end

		-- truncate the stack size to the maximum allowed by the server
		local count    = getStackSize()
		local maxCount = getMaxPerStack()
		if ( not shouldGhostAll() and count ~= 0 ) then count = 1 end
		if ( maxCount >= 0 and count > maxCount )  then count = maxCount end

		local entMod  = ent:GetModel()
		local entSkin = ent:GetSkin()
		
		local ghosts = {}
		local ghost
		
		-- loop for the total stack size and create a new ghost prop
		for i = 1, count do
			ghost = ClientsideModel( entMod )
			
			if ( not IsValid( ghost ) ) then continue end

			ghost:SetModel( entMod )
			ghost:SetSkin( entSkin )
			ghost:Spawn()

			ghost:SetRenderMode( RENDERMODE_TRANSALPHA )
			
			table.insert( ghosts, ghost )
		end
		
		-- store the ghost array for later use
		improvedstacker.SetGhosts( ghosts )
		
		return true
	end

	--[[--------------------------------------------------------------------------
	--
	-- 	validateGhostStack()
	--
	--	Attempts to validate the status of the ghosted props in the stack.
	--		True:  all good, ready to update
	--		False: something is invalid or missing, clear it
	--]]--
	local function validateGhostStack()
		-- check if the array of ghosts is valid
		local ghosts = improvedstacker.GetGhosts()
		if ( not ghosts ) then return false end
		
		-- check if all the ghost entities are valid
		for i = 1, #ghosts do
			if ( not IsValid( ghosts[ i ] ) ) then return false end
		end
		
		-- clamp the client's ghost stack to the server's maximum allowed size
		local count    = getStackSize()
		local maxCount = getMaxPerStack()
		if ( maxCount >= 0 and count > maxCount ) then count = maxCount end
		
		-- check if the number of ghosts in the stack matches the client's setting
		if     ( #ghosts ~= count and     shouldGhostAll() ) then return false
		-- number of ghosts matches client's setting, so check if we should only be ghosting one
		elseif ( #ghosts ~= 1     and not shouldGhostAll() ) then return false end
		
		return true
	end

	--[[--------------------------------------------------------------------------
	--
	-- 	updateGhostStack( entity )
	--
	--	Attempts to update the positions and angles of all ghosted props in the stack.
	--]]--
	local function updateGhostStack( ent )		
		local stackMode      = getStackerMode()
		local stackDirection = getDirection()
		local stackOffset    = getOffsetVector()
		local stackRotation  = getRotationAngle()
		local stackRelative  = shouldStackRelative()
		
		local applyMat  = shouldApplyMaterial()
		local applyCol  = shouldApplyColor()
		
		local lastEnt = ent
		local entPos = ent:GetPos()
		local entAng = ent:GetAngles()
		local entMat = ent:GetMaterial()
		local entCol = ent:GetColor()
			  entCol.a = getOpacity()
		
		local direction, offset
		-- we only need to calculate the distance once based on the direction the user selected
		local distance = improvedstacker.GetDistance( stackMode, stackDirection, ent )
		
		local ghost
		local ghosts = improvedstacker.GetGhosts()
		
		for i = 1, #ghosts do
			-- if we're positioning the first entity in the stack (regardless of relative to PROP or WORLD), or
			-- if we're stacking relative to PROP and on the previous rotation, update the new direction and offset
			if ( i == 1 or ( stackMode == improvedstacker.MODE_PROP and stackRelative ) ) then
				direction = improvedstacker.GetDirection( stackMode, stackDirection, entAng )
				offset    = improvedstacker.GetOffset( stackMode, stackDirection, entAng, stackOffset )
			end

			-- calculate the next stacked entity's position
			entPos = entPos + (direction * distance) + offset
			-- rotate the next stacked entity's angle by the client's rotation values
			improvedstacker.RotateAngle( stackMode, stackDirection, entAng, stackRotation )
			
			local ghost = ghosts[ i ]
			ghost:SetPos( entPos )
			ghost:SetAngles( entAng )
			ghost:SetMaterial( ( applyMat and entMat ) or "" )
			ghost:SetColor( ( applyCol and entCol ) or TRANSPARENT )
			ghost:SetNoDraw( false )
			
			lastEnt = ghost
		end
	end
	
	
	--[[--------------------------------------------------------------------------
	--
	-- 	Hook :: PreDrawHalos
	--
	--	Loads the hook that draws halos on the ghosted entities in the stack. 
	--
	--	This is the appropriate hook to create halos, NOT TOOL:Think(). The latter 
	--	will be called way more than it needs to be and causes horrible FPS drops in singleplayer.
	--]]--
	hook.Add( "PreDrawHalos", mode.."_predrawhalos", function()
		-- check if the player has fully initialized
		local ply = LocalPlayer()
		if ( not IsValid( ply ) ) then return end
		
		-- check if they have the toolgun out and have stacker selected
		local wep = ply:GetActiveWeapon()
		if ( not ( IsValid( wep ) and wep:GetClass() == "gmod_tool" and cvarTool and cvarTool:GetString() == mode ) ) then
			improvedstacker.ReleaseGhosts()
			improvedstacker.SetLookedAt( nil )
			return
		end
		
		-- check if we're looking at a valid entity
		local lookingAt = ply:GetEyeTrace().Entity
		if ( not ( IsValid( lookingAt ) and lookingAt:GetClass() == "prop_physics" ) ) then
			improvedstacker.ReleaseGhosts()
			improvedstacker.SetLookedAt( nil )
			return
		end
		
		-- check if the current toolobject is valid before trying to use it --
		-- commenting this out for now since I refactored these TOOL functions
		-- into just local functions to ditch the need for the tool object
		--[[local tool = wep.GetToolObject and wep:GetToolObject() 
		if ( not ( tool and tool.GetOwner and IsValid( tool:GetOwner() ) ) ) then
			return
		end]]
		
		-- specify the entity that the client is currently looking at for future reference
		improvedstacker.SetLookingAt( lookingAt )
		-- get the entity that the client was last (successfully) looking at
		local lookedAt = improvedstacker.GetLookedAt()
		
		-- if we're still looking at the same entity from the previous frame
		if ( lookingAt == lookedAt ) then
			-- if the ghost stack is still valid (nothing got deleted, etc)
			if ( validateGhostStack() ) then
				-- reposition the stack to the client's most recent stack settings
				updateGhostStack( lookingAt )
			else
				-- something is wrong in the stack, so remove the ghost entities
				improvedstacker.ReleaseGhosts()
				improvedstacker.SetLookedAt( nil )
				return
			end
		-- we looked at something else since the last frame
		else
			-- try to initialize a new ghost stack
			if ( createGhostStack( lookingAt ) ) then
				-- ghost stack was successfully created
				improvedstacker.SetLookedAt( lookingAt )
			end
		end
		
		-- check if we want to add halos to the ghost stack
		if ( not shouldAddHalos() ) then return end
		
		-- check if there are any ghosts to add halos to at all
		local ghosts = improvedstacker.GetGhosts()
		if ( not ghosts or #ghosts <= 0 ) then return end

		halo.Add( ghosts, getHaloColor() )
	end )
	
	--[[--------------------------------------------------------------------------
	--
	-- 	Hook :: PostDrawTranslucentRenderables
	--
	--	Draws the 2D x/y/z axis when looking at entities with the stacker tool.
	--]]--
	
	hook.Add( "PostDrawTranslucentRenderables", mode.."_directions", function( drawingDepth, drawingSky )
		if ( drawingSky ) then return end
		
		-- check if the player has fully initialized
		local ply = LocalPlayer()
		if ( not IsValid( ply ) ) then return end
		
		-- check if we want to draw the axis at all
		if ( not ( cvarAxis and cvarAxis:GetBool() ) ) then return end
		
		-- check if they have the toolgun out and have stacker selected
		local wep = ply:GetActiveWeapon()
		if ( not ( IsValid( wep ) and wep:GetClass() == "gmod_tool" and cvarTool and cvarTool:GetString() == mode ) ) then
			return
		end
		
		-- check if we're looking at a valid entity
		local ent = ply:GetEyeTrace().Entity
		if ( not IsValid( ent ) ) then
			return
		end
		
		local pos = ent:GetPos()
		
		local f = ent:GetForward()
		local r = ent:GetRight()
		local u = ent:GetUp()
		
		-- draw the front arrow (red)
		render.DrawLine( pos,    pos + (f*50),      RED, false )
		render.DrawLine( pos + (f*50) - f*ao + Vector(0,0,ao), pos + (f*50), RED, false )
		render.DrawLine( pos + (f*50) - f*ao - Vector(0,0,ao), pos + (f*50), RED, false )
		render.DrawLine( pos+o1, pos + (f*50) + o1, RED, false )
		render.DrawLine( pos+o2, pos + (f*50) + o2, RED, false )
		
		-- draw the right arrow (green)
		render.DrawLine( pos,    pos + (r*50),      GREEN, false )
		render.DrawLine( pos + (r*50) - r*ao + f*ao, pos + (r*50), GREEN, false )
		render.DrawLine( pos + (r*50) - r*ao - f*ao, pos + (r*50), GREEN, false )
		render.DrawLine( pos+o1, pos + (r*50) + o1, GREEN, false )
		render.DrawLine( pos+o2, pos + (r*50) + o2, GREEN, false )
		
		-- draw the upward arrow (blue)
		render.DrawLine( pos,    pos + (u*50),      BLUE, false )
		render.DrawLine( pos + (u*50) - u*ao + r*ao, pos + (u*50), BLUE, false )
		render.DrawLine( pos + (u*50) - u*ao - r*ao, pos + (u*50), BLUE, false )
		render.DrawLine( pos+o3, pos + (u*50) + o3, BLUE, false )
		render.DrawLine( pos+o4, pos + (u*50) + o4, BLUE, false )
		
		-- check if we want to draw the axis labels
		if ( not ( cvarAxisLbl           and cvarAxisAng ) )           then return end
		if ( not ( cvarAxisLbl:GetBool() or  cvarAxisAng:GetBool() ) ) then return end
		
		local fs = (pos + f*50 - u*5):ToScreen()
		local rs = (pos + r*50 - u*5):ToScreen()
		local us = (pos + u*55):ToScreen()
		
		local ang = ent:GetAngles()
		
		local front = ("%s%s"):format( cvarAxisLbl:GetBool() and L(prefix.."hud_front").." " or "", cvarAxisAng:GetBool() and "("..ang.x..")" or "" )
		local right = ("%s%s"):format( cvarAxisLbl:GetBool() and L(prefix.."hud_right").." " or "", cvarAxisAng:GetBool() and "("..ang.y..")" or "" )
		local upwrd = ("%s%s"):format( cvarAxisLbl:GetBool() and L(prefix.."hud_up").." "    or "", cvarAxisAng:GetBool() and "("..ang.z..")" or "" )
		
		cam.Start2D()
			draw.SimpleTextOutlined( front, mode.."_direction", fs.x, fs.y, RED,   0, 0, 1, BLACK )
			draw.SimpleTextOutlined( right, mode.."_direction", rs.x, rs.y, GREEN, 0, 0, 1, BLACK )
			draw.SimpleTextOutlined( upwrd, mode.."_direction", us.x, us.y, BLUE,  1, 0, 1, BLACK )
		cam.End2D()
		
	end )
	
end

if ( CLIENT ) then
	--[[--------------------------------------------------------------------------
	--
	-- 	TOOL.BuildCPanel( panel )
	--
	--	Builds the control panel menu that can be seen when holding Q and accessing
	--	the stacker menu.
	--]]--
	local function buildCPanel( cpanel )
		-- quick presets for default settings
		local presets = { 
			Label      = "Presets",
			MenuButton = 1,
			Folder     = mode,
			Options = {
				[L(prefix.."combobox_default")] = {
					[mode.."_mode"]        = tostring(improvedstacker.MODE_PROP),
					[mode.."_direction"]   = tostring(improvedstacker.DIRECTION_UP),
					[mode.."_count"]       = "1",
					[mode.."_freeze"]      = "1",
					[mode.."_weld"]        = "1",
					[mode.."_nocollide"]   = "1",
					[mode.."_ghostall"]    = "1",
					[mode.."_material"]    = "1",
					[mode.."_physprop"]    = "1",
					[mode.."_color"]       = "1",
					[mode.."_offsetx"]     = "0",
					[mode.."_offsety"]     = "0",
					[mode.."_offsetz"]     = "0",
					[mode.."_pitch"]       = "0",
					[mode.."_yaw"]         = "0",
					[mode.."_roll"]        = "0",
					[mode.."_relative"]    = "1",
					[mode.."_draw_halos"]  = "0",
					[mode.."_halo_r"]      = "255",
					[mode.."_halo_g"]      = "0",
					[mode.."_halo_b"]      = "0",
					[mode.."_halo_a"]      = "255",
					[mode.."_draw_axis"]   = "1",
					[mode.."_axis_labels"] = "1",
					[mode.."_axis_angles"] = "0",
				},
			},
			CVars = { 
				mode.."_mode",
				mode.."_direction",
				mode.."_count",
				mode.."_freeze",
				mode.."_weld",
				mode.."_nocollide",
				mode.."_ghostall",
				mode.."_material",
				mode.."_physprop",
				mode.."_color",
				mode.."_offsetx",
				mode.."_offsety",
				mode.."_offsetz",
				mode.."_pitch",
				mode.."_yaw",
				mode.."_roll",
				mode.."_relative",
				mode.."_draw_halos",
				mode.."_halo_r",
				mode.."_halo_g",
				mode.."_halo_b",
				mode.."_halo_a",
				mode.."_draw_axis",
				mode.."_axis_labels",
				mode.."_axis_angles",
			}
		}
		
		local relativeOptions = {
			[L(prefix.."combobox_world")] = { [mode.."_mode"] = improvedstacker.MODE_WORLD },
			[L(prefix.."combobox_prop")]  = { [mode.."_mode"] = improvedstacker.MODE_PROP  },
		}
		
		local relative = { Label = L(prefix.."label_relative"), MenuButton = "0", Options = relativeOptions }
		
		local directionOptions = {
			["1 - "..L(prefix.."combobox_direction_front")] = { [mode.."_direction"] = improvedstacker.DIRECTION_FRONT },
			["2 - "..L(prefix.."combobox_direction_back")]  = { [mode.."_direction"] = improvedstacker.DIRECTION_BACK  },
			["3 - "..L(prefix.."combobox_direction_right")] = { [mode.."_direction"] = improvedstacker.DIRECTION_RIGHT },
			["4 - "..L(prefix.."combobox_direction_left")]  = { [mode.."_direction"] = improvedstacker.DIRECTION_LEFT  },
			["5 - "..L(prefix.."combobox_direction_up")]    = { [mode.."_direction"] = improvedstacker.DIRECTION_UP    },
			["6 - "..L(prefix.."combobox_direction_down")]  = { [mode.."_direction"] = improvedstacker.DIRECTION_DOWN  },
		}
		
		local directions = { Label = L(prefix.."label_direction"), MenuButton = "0", Options = directionOptions }
		
		-- populate the table of valid languages that clients can switch between
		local languageOptions = {}
		
		for code, tbl in pairs( localify.GetLocalizations() ) do
			if ( not L(prefix.."language_"..code, code) ) then continue end
			
			languageOptions[ L(prefix.."language_"..code, code) ] = { localify_language = code }
		end
		
		local languages = {
			Label      = L(prefix.."label_language"),
			MenuButton = 0,
			Options    = languageOptions,
		}
		
		cpanel:AddControl( "ComboBox", languages )
		cpanel:ControlHelp( "\n" .. L(prefix.."label_credits") )
		cpanel:AddControl( "Label",    { Text = L(prefix.."label_presets") } )
		cpanel:AddControl( "ComboBox", presets )
		cpanel:AddControl( "Checkbox", { Label = L(prefix.."checkbox_freeze"),    Command = mode.."_freeze" } )
		cpanel:AddControl( "Checkbox", { Label = L(prefix.."checkbox_weld"),      Command = mode.."_weld" } )
		cpanel:AddControl( "Checkbox", { Label = L(prefix.."checkbox_nocollide"), Command = mode.."_nocollide" } )	
		cpanel:AddControl( "ComboBox", relative )	
		cpanel:AddControl( "ComboBox", directions )
		cpanel:AddControl( "Slider",   { Label = L(prefix.."label_count"), Min = 1, Max = cvarMaxPerStack:GetInt(), Command = mode.."_count", Description = "How many props to create in each stack" } )
		cpanel:AddControl( "Button",   { Label = L(prefix.."label_reset_offsets"), Command = mode.."_reset_offsets" } )
		cpanel:AddControl( "Slider",   { Label = L(prefix.."label_x"),     Type = "Float", Min = - cvarMaxOffX:GetInt(), Max = cvarMaxOffX:GetInt(), Value = 0, Command = mode.."_offsetx" } )
		cpanel:AddControl( "Slider",   { Label = L(prefix.."label_y"),     Type = "Float", Min = - cvarMaxOffY:GetInt(), Max = cvarMaxOffY:GetInt(), Value = 0, Command = mode.."_offsety" } )
		cpanel:AddControl( "Slider",   { Label = L(prefix.."label_z"),     Type = "Float", Min = - cvarMaxOffZ:GetInt(), Max = cvarMaxOffZ:GetInt(), Value = 0, Command = mode.."_offsetz" } )
		cpanel:AddControl( "Button",   { Label = L(prefix.."label_reset_angles"),  Command = mode.."_reset_angles" } )
		cpanel:AddControl( "Slider",   { Label = L(prefix.."label_pitch"), Type = "Float", Min = -MAX_ANGLE,  Max = MAX_ANGLE,  Value = 0, Command = mode.."_pitch" } )
		cpanel:AddControl( "Slider",   { Label = L(prefix.."label_yaw"),   Type = "Float", Min = -MAX_ANGLE,  Max = MAX_ANGLE,  Value = 0, Command = mode.."_yaw" } )
		cpanel:AddControl( "Slider",   { Label = L(prefix.."label_roll"),  Type = "Float", Min = -MAX_ANGLE,  Max = MAX_ANGLE,  Value = 0, Command = mode.."_roll" } )
		
		cpanel:AddControl( "Button",   { Label = L(prefix.."label_"..(showSettings and "hide" or "show").."_settings"),   Command = mode.."_show_settings" } )
		
		if ( showSettings ) then
			cpanel:AddControl( "Checkbox", { Label = L(prefix.."checkbox_use_shift_key"), Command = mode.."_use_shift_key", Description = "Toggles the ability to hold SHIFT and click the left and right mouse buttons to change stack size" } )
			cpanel:AddControl( "Checkbox", { Label = L(prefix.."checkbox_relative"),      Command = mode.."_relative",      Description = "Stacks each prop relative to the prop right before it. This allows you to create curved stacks" } )
			cpanel:AddControl( "Checkbox", { Label = L(prefix.."checkbox_material"),      Command = mode.."_material",      Description = "Applies the material of the original prop to all stacked props" } )
			cpanel:AddControl( "Checkbox", { Label = L(prefix.."checkbox_color"),         Command = mode.."_color",         Description = "Applies the color of the original prop to all stacked props" } )
			cpanel:AddControl( "Checkbox", { Label = L(prefix.."checkbox_physprop"),      Command = mode.."_physprop",      Description = "Applies the physical properties of the original prop to all stacked props" } )
			cpanel:AddControl( "Checkbox", { Label = L(prefix.."checkbox_ghost"),         Command = mode.."_ghostall",      Description = "Creates every ghost prop in the stack instead of just the first ghost prop" } )
			cpanel:AddControl( "Checkbox", { Label = L(prefix.."checkbox_axis"),          Command = mode.."_draw_axis", } )
			cpanel:AddControl( "Checkbox", { Label = L(prefix.."checkbox_axis_labels"),   Command = mode.."_axis_labels", } )
			cpanel:AddControl( "Checkbox", { Label = L(prefix.."checkbox_axis_angles"),   Command = mode.."_axis_angles", } )
			cpanel:AddControl( "Checkbox", { Label = L(prefix.."checkbox_halo"),          Command = mode.."_draw_halos", Description = "Gives halos to all of the props in to ghosted stack" } )
			cpanel:AddControl( "Slider",   { Label = L(prefix.."label_opacity"), Type = "Integer", Min = 0, Max = 255, Command = mode.."_opacity" } )
			cpanel:AddControl( "Color",    { Label = L(prefix.."checkbox_halo_color"), Red = mode.."_halo_r", Green = mode.."_halo_g", Blue = mode.."_halo_b", Alpha = mode.."_halo_a" } )
		end
	end
	
	concommand.Add( mode.."_show_settings", function( ply, cmd, args )
		local cpanel = controlpanel.Get( mode )
		if ( not IsValid( cpanel ) ) then return end
		showSettings = not showSettings
		cpanel:ClearControls()
		buildCPanel( cpanel )
	end )

	-- listen for changes to the localify language and reload the tool's menu to update the localizations
	cvars.AddChangeCallback( "localify_language", function( name, old, new )
		local cpanel = controlpanel.Get( mode )
		if ( not IsValid( cpanel ) ) then return end
		cpanel:ClearControls()
		buildCPanel( cpanel )
	end, "improvedstacker" )
	
	TOOL.BuildCPanel = buildCPanel

	--[[--------------------------------------------------------------------------
	--
	-- 	PopulateToolMenu
	--
	--	Builds the admin settings control panel in the utility menu. This allows server
	--	operators to quickly and easily save/change Stacker server settings.
	--]]--
	hook.Add( "PopulateToolMenu", mode.."AdminUtilities", function()
		spawnmenu.AddToolMenuOption( "Utilities", "Admin", mode.."_utils", L(prefix.."name"), "", "", function( cpanel )
			
			-- quick presets for default settings
			local presets = {
				label      = "Presets",
				menubutton = 1,
				folder     = mode.."_admin",
				options = {
					[L(prefix.."combobox_default")]      = improvedstacker.SETTINGS_DEFAULT,
					[L(prefix.."combobox_sandbox")]      = improvedstacker.SETTINGS_SANDBOX,
					[L(prefix.."combobox_darkrp")]       = improvedstacker.SETTINGS_DARKRP,
					[L(prefix.."combobox_singleplayer")] = improvedstacker.SETTINGS_SINGLEPLAYER,
				},
				cvars = {
					{ CVar = mode.."_max_per_player",    CCmd = mode.."_set_max_per_player" },
					{ CVar = mode.."_max_per_stack",     CCmd = mode.."_set_max_per_stack" },
					{ CVar = mode.."_delay",             CCmd = mode.."_set_delay" },
					{ CVar = mode.."_max_offsetx",       CCmd = mode.."_set_max_offsetx" },
					{ CVar = mode.."_max_offsety",       CCmd = mode.."_set_max_offsety" },
					{ CVar = mode.."_max_offsetz",       CCmd = mode.."_set_max_offsetz" },
					{ CVar = mode.."_force_freeze",      CCmd = mode.."_set_force_freeze" },
					{ CVar = mode.."_force_weld",        CCmd = mode.."_set_force_weld" },
					{ CVar = mode.."_force_nocollide",   CCmd = mode.."_set_force_nocollide" },
					{ CVar = mode.."_force_stayinworld", CCmd = mode.."_set_force_stayinworld" },
				},
			}
			
			local ctrl = vgui.Create( "StackerControlPresets", cpanel )
			ctrl:SetPreset( presets.folder )
			for k, v in pairs( presets.options ) do
				ctrl:AddOption( k, v )
			end
			for k, v in pairs( presets.cvars ) do
				ctrl:AddConVar( v )
			end			
			cpanel:AddItem( ctrl )
			--cpanel:AddControl( "ComboBox", presets )
			
			
			local bg = Color( 210, 210, 210 ) or Color( 179, 216, 255 )
			local fg = Color( 240, 240, 240 ) or Color( 229, 242, 255 )
			
			local sliders = {
				{ String = "max_per_player", Min = -1, Max = 2048,  Decimals = 0 },
				{ String = "max_per_stack",  Min =  1, Max = 100,   Decimals = 0 },
				{ String = "delay",          Min =  0, Max = 5,                  },
				{ String = "max_offsetx",    Min =  0, Max = 10000,              },
				{ String = "max_offsety",    Min =  0, Max = 10000,              },
				{ String = "max_offsetz",    Min =  0, Max = 10000,              },
			}
			
			local sliderlist = vgui.Create( "DListLayout", cpanel )
			sliderlist:DockPadding( 3, 1, 3, 3 )
			sliderlist:SetPaintBackground( true )
			function sliderlist:Paint( w, h )
				draw.RoundedBox( 0, 0, 0, w, h, bg )
			end
			cpanel:AddItem( sliderlist )
			
			for k, data in pairs( sliders ) do
				local list = vgui.Create( "DListLayout", sliderlist )
				list:DockPadding( 5, 0, 5, 5 )
				list:DockMargin( 0, 2, 0, 0 )
				list:SetPaintBackground( true )
				function list:Paint( w, h )
					draw.RoundedBox( 0, 0, 0, w, h, fg )
				end
			
				local decimals = data.Decimals or 2
			
				local slider = vgui.Create( "StackerDNumSlider", list )
				slider:SetText( L(prefix.."label_"..data.String) )
				slider.Label:SetFont( "DermaDefaultBold" )
				slider:SetMinMax( data.Min, data.Max )
				slider:SetDark( true )
				slider:SizeToContents()
				slider:SetDecimals( decimals )
				slider:SetValue( decimals == 0 and GetConVar( mode.."_"..data.String ):GetInt() or GetConVar( mode.."_"..data.String ):GetFloat(), true )
				
				local cmd = mode.."_set_"..data.String
				
				function slider:OnValueChanged( value )
					value = math.Round( value, decimals )
					RunConsoleCommand( cmd, value )
				end
				
				if ( L(prefix.."help_"..data.String) ) then
					local help = vgui.Create( "DLabel", list )
					help:SetText( L(prefix.."help_"..data.String) )
					help:DockMargin( 10, 0, 5, 0 )
					help:SetWrap( true )
					help:SetDark( true )
					help:SetAutoStretchVertical( true )
					help:SetFont( "DermaDefault" )
				end
				
				if ( L(prefix.."warning_"..data.String) ) then
					local help = vgui.Create( "DLabel", list )
					help:SetText( L(prefix.."warning_"..data.String) )
					help:DockMargin( 10, 0, 5, 0 )
					help:SetWrap( true )
					help:SetDark( true )
					help:SetAutoStretchVertical( true )
					help:SetFont( "DermaDefault" )
					help:SetTextColor( Color( 200, 0, 0 ) )
				end
				
				cvars.AddChangeCallback( mode.."_"..data.String, function( name, old, new )
					if ( not IsValid( slider ) ) then return end
					slider:SetValue( GetConVar( mode.."_"..data.String ):GetFloat(), true )
				end, mode.."_"..data.String.."_utilities" )
			end
			
			
			
			local checkboxes = {
				"freeze",
				"weld",
				"nocollide",
				"nocollide_all",
				"stayinworld",
			}

			local cblist = vgui.Create( "DListLayout", cpanel )
			cblist:DockPadding( 3, 1, 3, 3 )
			cblist:SetPaintBackground( true )
			function cblist:Paint( w, h )
				draw.RoundedBox( 0, 0, 0, w, h, bg )
			end
			cpanel:AddItem( cblist )
			
			for k, data in pairs( checkboxes ) do
				local list = vgui.Create( "DListLayout", cblist )
				list:DockPadding( 5, 5, 5, 5 )
				list:DockMargin( 0, 2, 0, 0 )
				list:SetPaintBackground( true )
				function list:Paint( w, h )
					draw.RoundedBox( 0, 0, 0, w, h, fg )
				end
			
				local cb = vgui.Create( "DCheckBoxLabel", list )
				cb:SetText( L(prefix.."checkbox_"..data) )
				cb:SetChecked( GetConVar( mode.."_force_"..data ):GetBool() )
				cb.Label:SetFont( "DermaDefaultBold" )
				cb:SizeToContents()
				cb:SetDark( true )
				-- we don't want this value to be changed while the server is running, so disable the checkbox
				if ( data == "nocollide_all" ) then
					cb:SetDisabled( true )
				end
				
				function cb:OnChange( bool ) RunConsoleCommand( mode.."_set_force_"..data, bool and "1" or "0" ) end
				
				cvars.AddChangeCallback( mode.."_force_"..data, function( name, old, new )
					if ( not IsValid( cb ) ) then return end
					cb:SetChecked( tobool( new ) )
				end, mode.."_"..data.."_utilities" )
				
				if ( L(prefix.."help_"..data) ) then
					local help = vgui.Create( "DLabel", list )
					help:SetText( L(prefix.."help_"..data) )
					help:DockMargin( 25, 5, 5, 0 )
					help:SetWrap( true )
					help:SetDark( true )
					help:SetAutoStretchVertical( true )
					help:SetFont( "DermaDefault" )
				end
				
				if ( L(prefix.."warning_"..data) ) then
					local help = vgui.Create( "DLabel", list )
					help:SetText( L(prefix.."warning_"..data) )
					help:DockMargin( 25, 5, 5, 0 )
					help:SetWrap( true )
					help:SetDark( true )
					help:SetAutoStretchVertical( true )
					help:SetFont( "DermaDefault" )
					help:SetTextColor( Color( 200, 0, 0 ) )
				end
			end
		end )
	end )
end

--addons/ballistic_shields/lua/weapons/heavy_shield/shared.lua:
if SERVER then
	include( "ballistic_shields/sh_bs_util.lua")
	include( "ballistic_shields/sv_bs_util.lua")
end

include("bs_config.lua")
include("ballistic_shields/sh_bs_lang.lua")

SWEP.PrintName = "Heavy shield"
SWEP.Author	= "D3G"
SWEP.Instructions = "LMB - Attack | RMB - Toggle visibility"
SWEP.Spawnable = false
SWEP.AdminOnly = false

SWEP.ViewModel = ""
SWEP.WorldModel = "models/bshields/hshield.mdl"

SWEP.HolsterOffset = Vector(7, 0, 8)
SWEP.HolsterAngle = Angle(-90, 0, 0)

SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom	= false

SWEP.Slot = 1
SWEP.SlotPos = 6
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = false

SWEP.Category = "SW:RP Shields"
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"
SWEP.HeavyShield = true
SWEP.CanVisToggle = true
SWEP.VisToggle = false
SWEP.HitDistance = 55

local SwingSound = Sound( "WeaponFrag.Throw" )
local HitSound = Sound( "Flesh.ImpactHard" )

hook.Add("EntityTakeDamage", "HeavyShield.StunOnDeath", function(target, dmgInfo)
	local inflictor = dmgInfo:GetInflictor()

	if IsValid(inflictor) and inflictor.HeavyShield then
		if not (IsValid(target) and target:IsPlayer()) then return end

		target.LastDeathStunned = true
		target.LastDeathDuration = 60
	end
end)

function SWEP:Initialize()
	self:SetHoldType("melee2")
end

function SWEP:DrawWorldModel()
	self:SetNoDraw(true)
end

local function bsGetHoldType(ply)
	if ply:LookupAttachment( "anim_attachment_RH" ) > 0 then
		return {1,"anim_attachment_RH"}
	end

	if ply:LookupAttachment( "forward" ) > 0 then
		return {2,"forward"}
	end

	return {3, "anim_attachment_head"}
end

local ShieldIcon = Material("bshields/ui/heavy_shield", "smooth")
local BackgroundIcon = Material("bshields/ui/background")

function SWEP:DrawHUD()
	if bshields.config.disablehud then return end

	surface.SetDrawColor(255,255,255,200)
	surface.SetMaterial(BackgroundIcon)
	surface.DrawTexturedRect(ScrW() / 2 - ScrH() / 10, ScrH() / 2 - ScrH() / 30 + ScrH() / 3, ScrH() / 5, ScrH() / 15)

	local aim = LocalPlayer():GetAimVector()
	local tr = util.TraceLine( {
		start  = LocalPlayer():GetShootPos() ,
		endpos = LocalPlayer():GetShootPos() + aim * 70,
		filter = LocalPlayer()
	})

	surface.SetDrawColor(255,255,255,125)

	if !IsValid(tr.Entity) || !DarkRP || !(tr.Entity:isDoor()) then
		draw.SimpleTextOutlined( bshields.lang[bshields.config.language].hshieldprim, "bshields.HudFont", ScrW() / 2-ScrH() / 32, ScrH() / 2 - ScrH() / 28 + ScrH() / 3 + ScrH() / 22, Color( 255, 255, 255, 25 ), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER, 1, Color(20,20,20,255))
	else
		draw.SimpleTextOutlined( bshields.lang[bshields.config.language].hshieldprim, "bshields.HudFont", ScrW() / 2 - ScrH() / 32, ScrH() / 2 - ScrH() / 28 + ScrH() / 3 + ScrH() / 22, Color( 255, 255, 255, 255 ), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER, 1, Color(20,20,20,255))
	end

	surface.SetMaterial(ShieldIcon)
	surface.DrawTexturedRect(ScrW() / 2 - ScrH() / 10.2, ScrH() / 2 - ScrH() / 32 + ScrH() / 3, ScrH() / 16, ScrH() / 16)

	if self.VisToggle then
		draw.SimpleTextOutlined( bshields.lang[bshields.config.language].sec, "bshields.HudFont", ScrW() / 2 - ScrH() / 32, ScrH() / 2 - ScrH() / 28 + ScrH() / 3 + ScrH() / 48, Color( 255, 255, 255, 25 ), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER, 1, Color(20,20,20,255))
	else
		draw.SimpleTextOutlined( bshields.lang[bshields.config.language].sec, "bshields.HudFont", ScrW() / 2 - ScrH() / 32, ScrH() / 2 - ScrH() / 28 + ScrH() / 3 + ScrH() / 48, Color( 255, 255, 255, 255 ), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER, 1, Color(20,20,20,255))
	end
end

function SWEP:Deploy()
	self.CanVisToggle = true
	self.VisToggle = false

	if SERVER then
		local owner = self:GetOwner()
		local holdtype = bsGetHoldType(owner)
		bshield_remove(owner)

		owner.bs_type = 2
		owner.bs_shield = ents.Create(self.shieldEnt)
		owner.bs_shield:SetCollisionGroup(COLLISION_GROUP_DEBRIS )
		owner.bs_shield:SetMoveType(MOVETYPE_NONE)
		owner.bs_shield:SetPos(owner:GetPos())
		owner.bs_shield:SetParent(owner, owner:LookupAttachment(holdtype[2]))
		owner.bs_shield:SetLocalAngles(bshields.shields[holdtype[1]][1].angles )
		owner.bs_shield:SetLocalPos(bshields.shields[holdtype[1]][1].position )
		owner.bs_shield:Spawn()

		net.Start("bs_shield_info")
			net.WriteUInt(owner.bs_shield:EntIndex(), 16)
		net.Send(owner)
	end
end

function SWEP:PrimaryAttack()
	local owner = self:GetOwner()
	if owner:LookupAttachment("anim_attachment_RH") > 0 then
		owner:SetAnimation(PLAYER_ATTACK1)
	end

	owner:LagCompensation(true)

	local shield
	if SERVER then
		shield = owner.bs_shield
	else
		shield = Entity(LocalPlayer().bs_shieldIndex)
	end

	self:EmitSound( SwingSound )

	if SERVER then
		if owner:LookupAttachment("anim_attachment_RH") > 0 then
			owner.bs_shield:SetLocalAngles(Angle(6,-34,-12))
			owner.bs_shield:SetLocalPos(Vector(4,8,-1))

			timer.Simple(0.4, function()
				owner.bs_shield:SetLocalAngles(bshields.shields[1][3].angles)
				owner.bs_shield:SetLocalPos(bshields.shields[1][3].position)
			end)
		end
	end

	local tr = util.TraceLine({
		start = owner:GetShootPos(),
		endpos = owner:GetShootPos() + owner:GetAimVector() * self.HitDistance,
		mask = MASK_SHOT_HULL,
		filter = {owner, shield}
	})

	if !IsValid(tr.Entity) then
		tr = util.TraceHull( {
			start = owner:GetShootPos(),
			endpos = owner:GetShootPos() + owner:GetAimVector() * self.HitDistance,
			mins = Vector(-10, -10, -8),
			maxs = Vector(10, 10, 8),
			mask = MASK_SHOT_HULL,
			filter = {owner, shield}
		})
	end

	if tr.Hit && !( game.SinglePlayer() && CLIENT ) then
		self:EmitSound( HitSound )
	end

	if SERVER && IsValid( tr.Entity ) && ( tr.Entity:IsNPC() || tr.Entity:IsPlayer() || tr.Entity:Health() > 0 ) then
		local dmginfo = DamageInfo()

		local attacker = owner
		if !IsValid( attacker ) then
			attacker = self
		end

		dmginfo:SetAttacker( attacker )
		dmginfo:SetInflictor( self )
		dmginfo:SetDamage( math.random( bshields.config.rshielddmgmin, bshields.config.rshielddmgmax ) )

		tr.Entity:TakeDamageInfo( dmginfo )
		hit = true
	end

	if ( SERVER && IsValid( tr.Entity ) ) then
		local phys = tr.Entity:GetPhysicsObject()
		if ( IsValid( phys ) ) then
			phys:ApplyForceOffset( owner:GetAimVector() * 80 * phys:GetMass(), tr.HitPos )
		end
	end

	owner:LagCompensation(false)
	self:SetNextPrimaryFire(CurTime() + 0.7)
end

function SWEP:SecondaryAttack()
	if CLIENT then
		if !self.CanVisToggle then return end

		surface.PlaySound("weapons/smg1/switch_single.wav")

		if !self.VisToggle then
			Entity(LocalPlayer().bs_shieldIndex):SetColor(Color( 0, 0, 0, 180 ))
			self.VisToggle = true
		else
			Entity(LocalPlayer().bs_shieldIndex):SetColor(Color( 255, 255, 255 ))
			self.VisToggle = false
		end

		self.CanVisToggle = false
		timer.Simple(0.1, function()
			self.CanVisToggle = true
		end)
	end
end

if CLIENT then return end

function SWEP:Holster()
	bshield_remove(self:GetOwner())

	return true
end

function SWEP:OnRemove()
	bshield_remove(self:GetOwner())

	return true
end

function SWEP:OnDrop()
	bshield_remove(self:GetOwner())

	return true
end

--addons/ballistic_shields/lua/bs_config.lua:
include( "ballistic_shields/sh_bs_util.lua" )

--------------------- BALLISTIC SHIELDS V1.1.4 -------------------------

---- CONFIG ----
-- AVALAIBLE LANGUAGES - English
bshields.config.language = "German"
-- DISABLE HUD
bshields.config.disablehud = false
-- MINIMUM RIOT SHIELD DAMAGE
bshields.config.rshielddmgmin = 16
-- MAXIMUM RIOT SHIELD DAMAGE
bshields.config.rshielddmgmax = 25
-- HEAVY SHIELD EXPLOSION DAMAGE REDUCITON (IN %)
bshields.config.hshieldexpl = 25
-- HEAVY SHIELD MELEE DAMAGE REDUCTION (IN %)
bshields.config.hshieldmelee = 0
-- RIOT SHIELD MELEE DAMAGE REDUCTION (IN %)
bshields.config.rshieldmelee = 60
-- HEAVY SHIELD BREACH COOLDOWN (IN SECONDS)
bshields.config.hshieldcd = 20
-- DOOR RESPAWN TIMER (IN SECONDS)
bshields.config.doorrespawn = 60
-- MAXIMUM AMOUNT OF DEPLOYED SHIELDS
bshields.config.maxshields = 3
-- SHOULD FADING DOORS BE BREACHABLE?
bshields.config.breachfdoors = false
-- ALLOW BREACHING UNOWNED DOORS
bshields.config.breachudoors = false

-------- CUSTOM TEXTURES, LEAVE "" FOR DEFAULT "POLICE" TEXT. ----------
--- FOR EDITING USE THE 256x256 TEMPLATE INCLUDED IN THE MAIN FOLDER ---

-- HEAVY SHIELD
bshields.config.hShieldTexture = "https://i.imgur.com/afyGHiK.png"
-- RIOT SHIELD
bshields.config.rShieldTexture = "https://i.imgur.com/afyGHiK.png"
-- DEPLOYABLE SHIELD
bshields.config.dShieldTexture = "https://i.imgur.com/afyGHiK.png" 
-- PLAYERS MIGHT HAVE TO RECONNECT IN ORDER TO SEE THE NEW TEXTURES! ---

-- [CW2 ONLY] YOU NEED THIS ADDON: https://steamcommunity.com/sharedfiles/filedetails/?id=1771994451
-- SHOULD RIOT SHIELD BE BULLETPROOF? --
bshields.config.rshieldbp = true
--addons/mortar/lua/weapons/mortar_constructor/shared.lua:
AddCSLuaFile()

SWEP.PrintName 				= "Mortar-Platzierer"
SWEP.Base 					= "tfa_gun_base"
SWEP.Author 				= "Shaka"
SWEP.Purpose				= "Platziert einen Mörser, der mithilfe eines Rangefinders Ziele aus großer Distanz vernichten kann."
SWEP.Instructions 			= "Platziert einen Mörser, der mithilfe eines Rangefinders Ziele aus großer Distanz vernichten kann."
SWEP.Type					= "Geschütz"

SWEP.Category 				= "SW:RP (Sonstiges)"
SWEP.Spawnable 				= true
SWEP.WorldModel 			= "models/dolunity/starwars/mortar_packedup.mdl"
SWEP.ViewModel 				= ""
SWEP.HoldType 				= "duel"
SWEP.Primary.Damage 		= 2
SWEP.UseHands 				= true
SWEP.DrawAmmo 				= false
SWEP.ShowViewModel 			= false
SWEP.ShowWorldModel 		= false
SWEP.Slot 					= 4
SWEP.Primary.ClipSize 		= 0
SWEP.Primary.DefaultClipSize = 0
SWEP.Secondary.ClipSize 	= 0
SWEP.Secondary.DefaultClipSize = 0

SWEP.data 					= {}
SWEP.data.ironsights 		= 0


SWEP.WElements = {
	["carte"] = {
		type = "Model",
		model = "models/dolunity/starwars/mortar_packedup.mdl",
		bone = "ValveBiped.Bip01_R_Hand",
		rel = "",
		pos = Vector(-02, 8, -1),
		angle = Angle(190, 90, -4),
		size = Vector(0.8, 0.8, 0.8),
		color = Color(255, 255, 255, 255),
		surpresslightning = false,
		material = "",
		skin = 0,
		bodygroup = {}
	}
}

SWEP.HolsterOffset = Vector(5, 0, 5)
SWEP.HolsterAngle = Angle(0, 0, 0)

if (CLIENT) then
	SWEP.PreviewModel = ClientsideModel("models/dolunity/starwars/mortar.mdl")
	SWEP.PreviewModel:SetNoDraw(true)
	SWEP.PreviewModel:SetMaterial("models/wireframe")
end

function SWEP:PrimaryAttack()
	if (SERVER) then
		local ply = self:GetOwner()

		if (ply:Alive() and IsValid(ply:GetActiveWeapon()) and ply:GetActiveWeapon():GetClass() == "mortar_constructor") then
			local trace = ply:GetEyeTrace()
			local hitAngle = trace.HitNormal:Angle()

			local ent = ents.Create("mortar")
			ent:SetPos(trace.HitPos)
			ent:SetAngles(Angle(0,0,0))
			ent:SetLocalAngles(ent:WorldToLocalAngles(hitAngle) + Angle(90,0,0))
			ent:Spawn()

			if (ent:GetLocalAngles().x > 45 or ent:GetLocalAngles().z > 45) then
				ent:Remove()
			else
				ply:StripWeapon("mortar_constructor")
			end
		end
	end
end

function SWEP:SecondaryAttack()
end

hook.Add("PostDrawOpaqueRenderables", "DrawMortarPreview", function ()
	local ply = LocalPlayer()
	if (ply:Alive() and IsValid(ply:GetActiveWeapon()) and ply:GetActiveWeapon():GetClass() == "mortar_constructor" and not ply:InVehicle()) then
		local weapon = ply:GetActiveWeapon()
		local trace = LocalPlayer():GetEyeTrace()

		weapon.PreviewModel:SetPos(trace.HitPos)
		weapon.PreviewModel:SetAngles(Angle(0,0,0))

		local hitAngle = trace.HitNormal:Angle()
		weapon.PreviewModel:SetLocalAngles(weapon.PreviewModel:WorldToLocalAngles(hitAngle) + Angle(90,0,0))

		if (weapon.PreviewModel:GetLocalAngles().x > 45 or weapon.PreviewModel:GetLocalAngles().z > 45) then
			weapon.Placeable = false
			render.SetColorModulation(255,0,0)
		else
			weapon.Placeable = true
			render.SetColorModulation(0,0,255 / 0, 0 / 255)
		end

		weapon.PreviewModel:DrawModel()
		render.SetColorModulation(0,0,0)
	end
end)
--lua/weapons/mortar_constructor_dark/shared.lua:
AddCSLuaFile()

SWEP.Base = "mortar_constructor"
SWEP.PrintName = "Mortar Dark"
SWEP.Spawnable = true

SWEP.Author = "DolUnity"
SWEP.Purpose = "Place a Mortar"
SWEP.Instructions = "Place the mortar with attack \nPick it up with duck and use"
SWEP.Category = "DolUnity"
SWEP.Spawnable = true
SWEP.ViewModel = "models/weapons/c_pistol.mdl"
SWEP.UseHands = true
SWEP.DrawAmmo = false

function SWEP:OnSpawn(ent)
    ent:SetSkin(1)
end
--lua/weapons/reciprocating_quad_blaster_red/shared.lua:
if ( SERVER ) then

	AddCSLuaFile( "shared.lua" )

end

if ( CLIENT ) then

	SWEP.PrintName			= "Imperial Reciprocating Quad Blaster"	

	SWEP.Author				= "Sim"

    SWEP.Instructions       = "Primary Attack: Fire, Secondary Attack: ADS, Safety: Reload over time"

	SWEP.ViewModelFOV      	= 70

	SWEP.Slot				= 3

	SWEP.SlotPos			= 2

	--SWEP.WepSelectIcon = surface.GetTextureID("HUD/killicons/DC15A")

	--killicon.Add( "weapon_752_dc15a", "HUD/killicons/DC15A", Color( 255, 80, 0, 255 ) )

end

SWEP.HoldType				= "duel"

SWEP.Base					= "tfa_swsft_base_servius"

SWEP.Category = "[TW] Heavy Weapons"

SWEP.Spawnable				= true

SWEP.AdminSpawnable			= false

SWEP.ViewModelFOV = 56

SWEP.ViewModelFlip = false

SWEP.ViewModel = "models/twcustom/weapons/v_reciprocating_quad_blaster.mdl"

SWEP.WorldModel = "models/twcustom/weapons/w_reciprocating_quad_blaster.mdl"

SWEP.ShowViewModel = true

SWEP.ShowWorldModel = true

SWEP.UseHands = false

--[[SWEP.ViewModelBoneMods = {

	["ValveBiped.Bip01_L_Clavicle"] = { scale = Vector(1, 1, 1), pos = Vector(0.736, 5.183, 1.149), angle = Angle(-1.825, 2.803, -0.527) },

	["v_weapon.awm_parent"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) }

}]]

SWEP.Primary.Sound = Sound ("weapons/dc15a/DC15A_fire.ogg");

SWEP.Primary.ReloadSound = Sound ("weapons/shared/standard_reload.ogg");

SWEP.Weight					= 5

SWEP.AutoSwitchTo			= false

SWEP.AutoSwitchFrom			= false

SWEP.Primary.Recoil			= 0.5

SWEP.Primary.Damage			= 50

SWEP.Primary.NumShots		= 1

-- Selective Fire Stuff

SWEP.SelectiveFire		= true --Allow selecting your firemode?

SWEP.DisableBurstFire	= false --Only auto/single?

SWEP.OnlyBurstFire		= false --No auto, only burst/single?

SWEP.DefaultFireMode 	= "Safe" --Default to auto or whatev

SWEP.FireModes = {

"Auto"

}

SWEP.FireModeName = nil --Change to a text value to override it

SWEP.Primary.Spread			= 0.0125

SWEP.Primary.IronAccuracy = .005	-- Ironsight accuracy, should be the same for shotguns

SWEP.Primary.SpreadMultiplierMax = 2 --How far the spread can expand when you shoot.

--Range Related

SWEP.Primary.Range = -1 -- The distance the bullet can travel in source units.  Set to -1 to autodetect based on damage/rpm.

SWEP.Primary.RangeFalloff = -1 -- The percentage of the range the bullet damage starts to fall off at.  Set to 0.8, for example, to start falling off after 80% of the range.

--Penetration Related

SWEP.MaxPenetrationCounter=1 --The maximum number of ricochets.  To prevent stack overflows.

SWEP.Primary.ClipSize		= 400

SWEP.Primary.RPM = 600

SWEP.Primary.DefaultClip	= 400*3

SWEP.Primary.Automatic		= true

SWEP.Primary.Ammo			= "ar2"

SWEP.TracerName = "effect_sw_laser_red"

SWEP.Secondary.Automatic	= false

SWEP.Secondary.Ammo			= "none"

SWEP.Secondary.IronFOV = 70

SWEP.BlowbackEnabled                 = true
SWEP.BlowbackVector                 = Vector(0,-1,0)
SWEP.BlowbackCurrentRoot            = 0
SWEP.BlowbackCurrent                 = 0
SWEP.BlowbackBoneMods                 = nil
SWEP.Blowback_Only_Iron             = false
SWEP.Blowback_PistolMode             = false
SWEP.Blowback_Shell_Enabled         = false
SWEP.Blowback_Shell_Effect             = "None"

SWEP.DoProceduralReload = true

SWEP.ProceduralReloadTime = 2.5

SWEP.VMPos = Vector(0, 11, -5)
SWEP.VMAng = Vector(0, 0, 0)
SWEP.VMPos_Additive = false
SWEP.Sights_Mode = TFA.Enum.LOCOMOTION_HYBRID
SWEP.Idle_Mode = TFA.Enum.IDLE_BOTH
SWEP.Sprint_Mode = TFA.Enum.LOCOMOTION_ANI
SWEP.IronSightsPos = Vector(0.03, 11, -1.85)
SWEP.IronSightsAng = Vector(0.209, -0.138, 0)
SWEP.RunSightsPos = Vector(0, 11, -5)
SWEP.RunSightsAng = Vector(0, 0, 0)
SWEP.InspectPos = Vector(0, 20, -20)
SWEP.InspectAng = Vector(30, 0, 0)

SWEP.MoveSpeed                         = 0.8
SWEP.IronSightsMoveSpeed               = 0.7

SWEP.VElements = {

	["txt_ammo"] = { type = "Quad", bone = "main_gun", pos = Vector(1.8, -1, 8), angle = Angle(0, 0, 90), size = 0.0175, draw_func = nil, active = true},

}

SWEP.TopBarrel = true
SWEP.AnimTime = CurTime()

if CLIENT then
    function SWEP:PlaceHandsOnGun()
        local leftElbow = self:GetOwner():LookupBone("ValveBiped.Bip01_L_Forearm")
        local rightShoulder = self:GetOwner():LookupBone("ValveBiped.Bip01_R_UpperArm")
        local rightElbow = self:GetOwner():LookupBone("ValveBiped.Bip01_R_Forearm")

        if not leftElbow or not rightShoulder or not rightElbow then return end

        self:GetOwner():ManipulateBoneAngles(leftElbow, Angle(20, -20, 0))
        self:GetOwner():ManipulateBoneAngles(rightShoulder, Angle(0, 15, 0))
        self:GetOwner():ManipulateBoneAngles(rightElbow, Angle(-30, -40, 0))
    end

    function SWEP:ResetBoneAngles()
        local leftElbow = self:GetOwner():LookupBone("ValveBiped.Bip01_L_Forearm")
        local rightShoulder = self:GetOwner():LookupBone("ValveBiped.Bip01_R_UpperArm")
        local rightElbow = self:GetOwner():LookupBone("ValveBiped.Bip01_R_Forearm")

        if not leftElbow or not rightShoulder or not rightElbow then return end

        self:GetOwner():ManipulateBoneAngles(leftElbow, Angle(0, 0, 0))
        self:GetOwner():ManipulateBoneAngles(rightShoulder, Angle(0, 0, 0))
        self:GetOwner():ManipulateBoneAngles(rightElbow, Angle(0, 0, 0))
    end
end

function SWEP:Holster()
    if CLIENT then
        self:ResetBoneAngles()
    end
    return true
end

function SWEP:Deploy()
    if self:IsSafety() then
        self:GetOwner():GetViewModel():SendViewModelMatchingSequence(0)
    end
end

function SWEP:GetShootPos()
    if self.TopBarrel then
        self.TopBarrel = false
        return self:GetBonePosition(self:LookupBone("barrel_top_right")), self:GetBonePosition(self:LookupBone("barrel_top_left"))
    else
        self.TopBarrel = true
        return self:GetBonePosition(self:LookupBone("barrel_bottom_right")), self:GetBonePosition(self:LookupBone("barrel_bottom_left"))
    end
end

function SWEP:GetFireModeName()
	local fm = self:GetFireMode()
	local fmn = string.lower( self:GetStat("FireModes")[fm] )
	if fmn == "safe" or fmn == "holster" then return "Safety" end
	if self:GetStat("FireModeName") then return self:GetStat("FireModeName") end
	if fmn == "auto" or fmn == "automatic" then return "Full-Auto" end

	if fmn == "semi" or fmn == "single" then
		if self:GetStat("Revolver") then
			if (self:GetStat("BoltAction")) then
				return "Single-Action"
			else
				return "Double-Action"
			end
		else
			if (self:GetStat("BoltAction")) then
				return "Bolt-Action"
			else
				if (self.Shotgun and self:GetStat("Primary.RPM") < 250) then
					return "Pump-Action"
				else
					return "Semi-Auto"
				end
			end
		end
	end

	local bpos = string.find(fmn, "burst")
	if bpos then return string.sub(fmn, 1, bpos - 1) .. " Round Burst" end
	return ""
end

function SWEP:Anims() end

function SWEP:ReloadTicker()end

function SWEP:Reload()
    return
end

function SWEP:DrawWorldModel()
    if IsValid(self.Owner) then 
        self:SetPoseParameter("head_pitch", self.Owner:EyeAngles()[1])
        self:InvalidateBoneCache()
    end
    self:DrawModel()
end

function SWEP:Think()
    self.Anims()

    self.ReloadTicker()
    if CLIENT then
        if self:IronSights() then
            if self:Clip1() > self:GetMaxClip1()/2 then
                self.VElements["txt_ammo"].draw_func = function( weapon )
                    draw.SimpleText(""..weapon:Clip1().."/"..self.Primary.ClipSize, "Trebuchet18", 0, 0, Color(0, 90, 150, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
                end
            end
            if self:Clip1() <= self:GetMaxClip1()/4 then
                self.VElements["txt_ammo"].draw_func = function( weapon )
                    draw.SimpleText(""..weapon:Clip1().."/"..self.Primary.ClipSize, "Trebuchet18", 0, 0, Color(0, 90, 255, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
                end
            end
            if self:Clip1() <= self:GetMaxClip1()/20 then
                self.VElements["txt_ammo"].draw_func = function( weapon )
                    draw.SimpleText("0"..weapon:Clip1().."/"..self.Primary.ClipSize, "Trebuchet18", 0, 0, Color(191, 179, 0, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
                end
            end
            if self:Clip1() == 0 then
                self.VElements["txt_ammo"].draw_func = function( weapon )
                    draw.SimpleText("000/"..self.Primary.ClipSize, "Trebuchet18", 0, 0, Color(255, 90, 0, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
                end
            end
        else
            self.VElements["txt_ammo"].draw_func = function( weapon )
                draw.SimpleText("", "Trebuchet18", 0, 0, Color(255, 90, 0, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
            end
        end
    end

    if SERVER then

        if self:GetOwner():KeyDown(IN_ATTACK) and not self:IsSafety() and CurTime() > self.AnimTime and self:Clip1() > 0 then
            self:SetSequence(5)
        end
        if self:GetOwner():KeyReleased(IN_ATTACK) and not self:IsSafety() and CurTime() > self.AnimTime or (self:Clip1() == 0 and not self:IsSafety())then
            self:SetSequence(1)
        end
        if self:GetSequence() == 5 then
            self:SetCycle( math.min(self:GetCycle() + 5*FrameTime(), 1))
        else
            self:SetCycle( math.min(self:GetCycle() + 0.5*FrameTime(), 1))
        end
        if self:GetCycle() >= 1 then
            if tonumber(self:GetSequence()) == 5 then
                self:SetCycle( 0 )
            end
        end
    end
end

function SWEP:CycleSafety()
    if not IsFirstTimePredicted() and !game.SinglePlayer() then return end
	local fm = self:GetFireMode()
	local fmt = self:GetStat("FireModes")
	if fm ~= #fmt then 
		self.LastFireMode = fm
		self:SetFireMode(#fmt)
	else
		self:SetFireMode(self.LastFireMode or 1)
	end
	self:EmitSound("Weapon_AR2.Empty")
	self.BurstCount = 0

    local vm = self:GetOwner():GetViewModel()

    if self:GetFireModeName() == "Safety" then
        if CLIENT then
            self:ResetBoneAngles()
        end
        self:SetHoldType("normal")
        self:SetSequence(3)
        self:SetCycle(0)
        vm:SendViewModelMatchingSequence(3)
        self.Anims = function()
            if CurTime() > self.AnimTime then
            self:SetSequence(0)
            vm:SendViewModelMatchingSequence(0)
            self.Anims = function()end
            end
        end
        self.ReloadWaitTime = CurTime()
        self.ReloadTicker = function()
            if self:IsSafety() then
                if CurTime() > self.ReloadWaitTime then
                    if self:Clip1() < self:GetMaxClip1() and self:GetOwner():GetAmmoCount(self:GetPrimaryAmmoType()) > 0 then
                        local ammo = math.Clamp(50, 0, self:GetOwner():GetAmmoCount(self:GetPrimaryAmmoType()))
                        ammo = math.min(ammo, self:GetMaxClip1()-self:Clip1())
                        self:SetClip1(math.Clamp(self:Clip1() + ammo, 0, self:GetMaxClip1()))
                        self:GetOwner():RemoveAmmo( ammo, self:GetPrimaryAmmoType() )
                        if self:Clip1() == self:GetMaxClip1() then
                            self.ReloadTicker = function()end
                        else
                            self.ReloadWaitTime = CurTime() + 0.5
                        end
                    end
                end
            else
                self.ReloadTicker = function()end
            end
        end
    else
        self.HoldType = "normal"
        self:SetSequence(2)
        self:SetCycle(0)
        vm:SendViewModelMatchingSequence(2)
        self.Anims = function()
            if CurTime() > self.AnimTime then
                self:SetSequence(1)
                self.HoldType = "duel"
                if CLIENT then
                    self:PlaceHandsOnGun()
                end
                vm:SendViewModelMatchingSequence(1)
                self.Anims = function()end
            end
        end
    end
    self.AnimTime = CurTime() + 1.5
    self:SetNextPrimaryFire(self.AnimTime)
    self:SetNextSecondaryFire(self.AnimTime)
end

local cv_forcemult = GetConVar("sv_tfa_force_multiplier")

function SWEP:ShootBullet(damage, recoil, num_bullets, aimcone, disablericochet, bulletoverride)
	if not IsFirstTimePredicted() and not game.SinglePlayer() then return end
	num_bullets = 1
	aimcone = aimcone or 0

    TracerName = self.TracerName

    local rightBarrel, leftBarrel = self:GetShootPos()

    self.MainBullet.Attacker = self:GetOwner()
    self.MainBullet.Inflictor = self
    self.MainBullet.Num = num_bullets
    self.MainBullet.Src = self:GetOwner():EyePos()
    self.MainBullet.Dir = self:GetOwner():GetAimVector()
    self.MainBullet.HullSize = self:GetStat("Primary.HullSize") or 0
    self.MainBullet.Spread.x = aimcone
    self.MainBullet.Spread.y = aimcone
    self.MainBullet.Tracer = self.TracerCount and self.TracerCount or 3
    self.MainBullet.TracerName = "nil"
    self.MainBullet.PenetrationCount = 0
    self.MainBullet.AmmoType = self:GetPrimaryAmmoType()
    self.MainBullet.Force = damage / 6 * math.sqrt(self:GetStat("Primary.KickUp") + self:GetStat("Primary.KickDown") + self:GetStat("Primary.KickHorizontal")) * cv_forcemult:GetFloat() * self:GetAmmoForceMultiplier()
    self.MainBullet.Damage = damage
    self.MainBullet.HasAppliedRange = false

    self:GetOwner():FireBullets(self.MainBullet)

    local data = EffectData()
    data:SetEntity(self)
    data:SetStart(rightBarrel)
    data:SetOrigin(self:GetOwner():GetEyeTrace().HitPos)
    util.Effect(TracerName, data)

    data = nil

    data = EffectData()
    data:SetEntity(self)
    data:SetStart(leftBarrel)
    data:SetOrigin(self:GetOwner():GetEyeTrace().HitPos)
    util.Effect(TracerName, data)

    data = nil
end

function SWEP:CanPrimaryAttack( )
	if self.Owner:IsNPC() then
		if SERVER then
			if CurTime() < self:GetNextPrimaryFire() then
				return false
			end
			return true
		end
	end
	stat = self:GetStatus()
	if not TFA.Enum.ReadyStatus[stat] and stat ~= TFA.Enum.STATUS_SHOOTING then
		if self.Shotgun and TFA.Enum.ReloadStatus[stat] then
			self:SetShotgunCancel( true )
		end
		return false
	end

	if self:IsSafety() then
		self:EmitSound("Weapon_AR2.Empty2")
		self.LastSafetyShoot = self.LastSafetyShoot or 0

		if CurTime() < self.LastSafetyShoot + 0.2 then
			self:CycleSafety()
			self:SetNextPrimaryFire(CurTime() + 1.5)
		end

		self.LastSafetyShoot = CurTime()

		return
	end

	if self:GetStat("Primary.ClipSize") <= 0 and self:Ammo1() < self:GetStat("Primary.AmmoConsumption") then
		return false
	end
	if self:GetSprinting() and not self.AllowSprintAttack then
		return false
	end
	if self:GetPrimaryClipSize(true) > 0 and self:Clip1() < self:GetStat("Primary.AmmoConsumption") then
		if self:GetOwner():KeyPressed(IN_ATTACK) then
			self:ChooseDryFireAnim()
		end
		if not self.HasPlayedEmptyClick then
			self:EmitSound("Weapon_Pistol.Empty2")

			self.HasPlayedEmptyClick = true
		end
		return false
	end
	if self.FiresUnderwater == false and self:GetOwner():WaterLevel() >= 3 then
		self:SetNextPrimaryFire(CurTime() + 0.5)
		self:EmitSound("Weapon_AR2.Empty")
		return false
	end

	self.HasPlayedEmptyClick = false

	if CurTime() < self:GetNextPrimaryFire() then return false end

	return true
end
--addons/ballistic_shields/lua/ballistic_shields/sh_bs_lang.lua:
include( "ballistic_shields/sh_bs_util.lua" )

bshields.lang = {
	["German"] = {
		["sec"] = "[RMB] Unsichtbar/Sichtbar",
		["dshieldprim"] = "[LMB] Platzieren",
		["hshieldprim"] = "[LMB] Schlagen",
		["rshieldprim"] = "[LMB] Schlagen",
		["hshieldcd1"] = "Wait ",
		["hshieldcd2"] = " seconds to breach next door!"
	}
} 

if bshields.lang[bshields.config.language] == nil then
	bshields.config.language = "English"
end
--addons/egm_tfa_grenades/lua/weapons/rw_sw_nade_flash.lua:
SWEP.Base					= "tfa_ins2_nade_base"
SWEP.Category					= "SW:RP (Granaten)"
SWEP.Author					= "Gorka(Strasser) & ChanceSphere574"
SWEP.Type						= "Explode and Flash"
SWEP.PrintName					= "Flash Grenade"
SWEP.Slot					= 3
SWEP.SlotPos					= 100
SWEP.DrawAmmo					= true
SWEP.DrawWeaponInfoBox					= false
SWEP.BounceWeaponIcon   				= false
SWEP.DrawCrosshair				= false
SWEP.Weight						= 2
SWEP.AutoSwitchTo				= true
SWEP.AutoSwitchFrom				= true
SWEP.HoldType 					= "grenade"

SWEP.ViewModelFOV				= 70
SWEP.ViewModelFlip				= false
SWEP.ViewModel					= "models/weapons/tfa_ins2/v_f1.mdl"
SWEP.WorldModel					= "models/weapons/tfa_ins2/w_f1.mdl"
SWEP.ShowWorldModel				= false
SWEP.Spawnable					= true
SWEP.UseHands                                  = true
SWEP.AdminSpawnable				= true

SWEP.Primary.Damage             = 0
SWEP.Primary.RPM				= 10
SWEP.Primary.ClipSize			= 1
SWEP.Primary.DefaultClip		= 1
SWEP.Primary.Automatic			= false
SWEP.DisableChambering 			= true
SWEP.Primary.Ammo				= "AlyxGun"
SWEP.Primary.Round 				= ("rw_sw_ent_nade_flash")
SWEP.Primary.Range 					= 950
SWEP.Velocity = 950
SWEP.Velocity_Underhand = 400
SWEP.Delay = 0.23
SWEP.DelayCooked = 0.24
SWEP.Delay_Underhand = 0.245
SWEP.CookStartDelay = 1
SWEP.UnderhandEnabled = true
SWEP.CookingEnabled = true
SWEP.CookTimer = 3.2
SWEP.Primary.Force = 0
SWEP.Primary.Knockback = 0

SWEP.ViewModelBoneMods = {
	["Spoon_F1"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["Weapon_F1"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["Pin_Pull"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["Pin_2_F1"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["Pin_F1"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	--["Weapon"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	--["Spoon"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
}

SWEP.VElements = {
	["n"] = { type = "Model", model = "models/cs574/explosif/grenade_flash.mdl", bone = "Weapon_F1", rel = "", pos = Vector(-0.9, 0.2, 1.3), angle = Angle(-10, 90, -25), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
}

SWEP.WElements = {
	["n"] = { type = "Model", model = "models/cs574/explosif/grenade_flash.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(03.2, 02, -0.5), angle = Angle(195, 0, 0), size = Vector(1.1, 1.1, 1.1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

SWEP.ProceduralHoslterEnabled   = true
SWEP.ProceduralHolsterTime      = 0.0
SWEP.ProceduralHolsterPos       = Vector(0, 0, 0)
SWEP.ProceduralHolsterAng       = Vector(0, 0, 0)

SWEP.Offset = {
		Pos = {
		Up = 0,
		Right = 1,
		Forward = 3,
		},
		Ang = {
		Up = -1,
		Right = -2,
		Forward = 178
		},
	Scale = 1
}

SWEP.InspectPos 				= Vector(-03,0,03)
SWEP.InspectAng 				= Vector(0,0,0)


SWEP.Sprint_Mode 				= TFA.Enum.LOCOMOTION_ANI
SWEP.SprintAnimation = {
	["loop"] = {
		["type"] = TFA.Enum.ANIMATION_SEQ,
		["value"] = "sprint",
		["is_idle"] = true
	}
}
--addons/egm_tfa_grenades/lua/weapons/rw_sw_nade_impact.lua:
SWEP.Base						= "tfa_ins2_nade_base"
SWEP.Category					= "SW:RP (Granaten)"
SWEP.Author						= "Rezurektion & ChanceSphere574"
SWEP.Type						= "Explode on contact with object or surface"
SWEP.PrintName					= "Impact Grenade"
SWEP.Slot						= 3
SWEP.SlotPos					= 100
SWEP.DrawAmmo					= true
SWEP.DrawWeaponInfoBox			= false
SWEP.BounceWeaponIcon   		= false
SWEP.DrawCrosshair				= false
SWEP.Weight						= 2
SWEP.AutoSwitchTo				= true
SWEP.AutoSwitchFrom				= true
SWEP.HoldType 					= "grenade"

SWEP.ViewModelFOV				= 70
SWEP.ViewModelFlip				= false
SWEP.ViewModel					= "models/weapons/tfa_ins2/v_f1.mdl"
SWEP.WorldModel					= "models/weapons/tfa_ins2/w_f1.mdl"
SWEP.ShowWorldModel				= false
SWEP.Spawnable					= true
SWEP.UseHands                   = true
SWEP.AdminSpawnable				= true

SWEP.Primary.Damage             = 600
SWEP.Primary.RPM				= 10
SWEP.Primary.ClipSize			= 1
SWEP.Primary.DefaultClip		= 1
SWEP.Primary.Automatic			= false
SWEP.DisableChambering 			= true
SWEP.Primary.Ammo				= "AlyxGun"
SWEP.Primary.Round 				= ("rw_sw_ent_nade_impact")
SWEP.Primary.Range 					= 1100
SWEP.Velocity = 1100
SWEP.Velocity_Underhand = 350
SWEP.Delay = 0.23
SWEP.DelayCooked = 0.24
SWEP.Delay_Underhand = 0.245
SWEP.CookStartDelay = 1
SWEP.UnderhandEnabled = true
SWEP.CookingEnabled = false
SWEP.CookTimer = 3.2
SWEP.Primary.Force = 0
SWEP.Primary.Knockback = 0

SWEP.ViewModelBoneMods = {
	["Spoon_F1"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["Weapon_F1"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["Pin_Pull"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["Pin_2_F1"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["Pin_F1"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	--["Weapon"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	--["Spoon"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
}

SWEP.VElements = {
	["n"] = { type = "Model", model = "models/cs574/explosif/grenade_impact.mdl", bone = "Weapon_F1", rel = "", pos = Vector(-0.7, 0.2, 01.1), angle = Angle(10, 0, 0), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
}

SWEP.WElements = {
	["n"] = { type = "Model", model = "models/cs574/explosif/grenade_impact.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(03, 02, -0.5), angle = Angle(0, 0, 80+90), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

SWEP.ProceduralHoslterEnabled   = true
SWEP.ProceduralHolsterTime      = 0.0
SWEP.ProceduralHolsterPos       = Vector(0, 0, 0)
SWEP.ProceduralHolsterAng       = Vector(0, 0, 0)

SWEP.Offset = {
		Pos = {
		Up = 0,
		Right = 1,
		Forward = 3,
		},
		Ang = {
		Up = -1,
		Right = -2,
		Forward = 178
		},
		Scale = 1
}

SWEP.InspectPos 				= Vector(-03,0,03)
SWEP.InspectAng 				= Vector(0,0,0)


SWEP.Sprint_Mode 				= TFA.Enum.LOCOMOTION_ANI
SWEP.SprintAnimation = {
	["loop"] = {
		["type"] = TFA.Enum.ANIMATION_SEQ,
		["value"] = "sprint",
		["is_idle"] = true
	}
}
--addons/egm_tfa_grenades/lua/weapons/rw_sw_nade_training.lua:
SWEP.Base						= "tfa_ins2_nade_base"
SWEP.Category					= "SW:RP (Granaten)"
SWEP.Author						= "ChanceSphere574"
SWEP.Type						= "Grenade for train your throwing"
SWEP.PrintName					= "Training Grenade"
SWEP.Slot						= 3
SWEP.SlotPos					= 100
SWEP.DrawAmmo					= true
SWEP.DrawWeaponInfoBox			= false
SWEP.BounceWeaponIcon   		= false
SWEP.DrawCrosshair				= false
SWEP.Weight						= 2
SWEP.AutoSwitchTo				= true
SWEP.AutoSwitchFrom				= true
SWEP.HoldType 					= "grenade"

SWEP.ViewModelFOV				= 70
SWEP.ViewModelFlip				= false
SWEP.ViewModel					= "models/weapons/tfa_ins2/v_f1.mdl"
SWEP.WorldModel					= "models/weapons/tfa_ins2/w_f1.mdl"
SWEP.ShowWorldModel				= false
SWEP.Spawnable					= true
SWEP.UseHands                   = true
SWEP.AdminSpawnable				= true


SWEP.Primary.Damage             = 0
SWEP.Primary.RPM				= 10
SWEP.Primary.ClipSize			= 1
SWEP.Primary.DefaultClip		= 1
SWEP.Primary.Automatic			= false
SWEP.DisableChambering 			= true
SWEP.Primary.Ammo				= "AlyxGun"
SWEP.Primary.Round 				= ("rw_sw_ent_nade_train")
SWEP.Primary.Range 					= 950
SWEP.Velocity = 950
SWEP.Velocity_Underhand = 400
SWEP.Delay = 0.23
SWEP.DelayCooked = 0.24
SWEP.Delay_Underhand = 0.245
SWEP.CookStartDelay = 1
SWEP.UnderhandEnabled = true
SWEP.CookingEnabled = true
SWEP.CookTimer = 3.2
SWEP.Primary.Force = 0
SWEP.Primary.Knockback = 0

SWEP.ViewModelBoneMods = {
	["Spoon_F1"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["Weapon_F1"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["Pin_Pull"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["Pin_2_F1"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["Pin_F1"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	--["Weapon"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	--["Spoon"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
}

SWEP.VElements = {
	["n"] = { type = "Model", model = "models/cs574/explosif/grenade_train.mdl", bone = "Weapon_F1", rel = "", pos = Vector(0.7, 0.2, -1.1), angle = Angle(-10, 90, -25), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
}

SWEP.WElements = {
	["n"] = { type = "Model", model = "models/cs574/explosif/grenade_train.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(02.5, 02, 02.5), angle = Angle(195, 0, 0), size = Vector(1.1, 1.1, 1.1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

SWEP.ProceduralHoslterEnabled   = true
SWEP.ProceduralHolsterTime      = 0.0
SWEP.ProceduralHolsterPos       = Vector(0, 0, 0)
SWEP.ProceduralHolsterAng       = Vector(0, 0, 0)

SWEP.Offset = {
		Pos = {
		Up = 0,
		Right = 1,
		Forward = 3,
		},
		Ang = {
		Up = -1,
		Right = -2,
		Forward = 178
		},
	Scale = 1
}

SWEP.InspectPos 				= Vector(-03,0,03)
SWEP.InspectAng 				= Vector(0,0,0)


SWEP.Sprint_Mode 				= TFA.Enum.LOCOMOTION_ANI
SWEP.SprintAnimation = {
	["loop"] = {
		["type"] = TFA.Enum.ANIMATION_SEQ,
		["value"] = "sprint",
		["is_idle"] = true
	}
}
--addons/tfa_base/lua/weapons/tfa_gun_base/common/bullet.lua:
local vector_origin = Vector()
local angle_zero = Angle()

local l_mathClamp = math.Clamp
local Lerp = Lerp
SWEP.MainBullet = {}
SWEP.MainBullet.Spread = Vector()

local function DisableOwnerDamage(a, b, c)
	if b.Entity == a and c then
		c:ScaleDamage(0)
	end
end

local ballistics_distcv = GetConVar("sv_tfa_ballistics_mindist")

local function BallisticFirebullet(ply, bul, ovr, angPreserve)
	local wep = ply:GetActiveWeapon()

	if TFA.Ballistics and TFA.Ballistics:ShouldUse(wep) then
		if ballistics_distcv:GetInt() == -1 or util.QuickTrace(ply:GetShootPos(), ply:GetAimVector() * 0x7fff, ply).HitPos:Distance(ply:GetShootPos()) > (ballistics_distcv:GetFloat() * TFA.Ballistics.UnitScale) then
			bul.SmokeParticle = bul.SmokeParticle or wep.BulletTracer or wep.TracerBallistic or wep.BallisticTracer or wep.BallisticsTracer

			if ovr then
				TFA.Ballistics:FireBullets(wep, bul, angPreserve or angle_zero, true)
			else
				TFA.Ballistics:FireBullets(wep, bul, angPreserve)
			end
		else
			ply:FireBullets(bul)
		end
	else
		ply:FireBullets(bul)
	end
end

--[[
Function Name:  ShootBulletInformation
Syntax: self:ShootBulletInformation().
Returns:   Nothing.
Notes:  Used to generate a self.MainBullet table which is then sent to self:ShootBullet, and also to call shooteffects.
Purpose:  Bullet
]]
--
local sv_tfa_damage_multiplier = GetConVar("sv_tfa_damage_multiplier")
local sv_tfa_damage_multiplier_npc = GetConVar("sv_tfa_damage_multiplier_npc")
local cv_dmg_mult_min = GetConVar("sv_tfa_damage_mult_min")
local cv_dmg_mult_max = GetConVar("sv_tfa_damage_mult_max")
local sv_tfa_recoil_legacy = GetConVar("sv_tfa_recoil_legacy")
local dmg, con, rec

function SWEP:ShootBulletInformation()
	--self:CalculateRatios()
	self:UpdateConDamage()

	self.lastbul = nil
	self.lastbulnoric = false
	self.ConDamageMultiplier = self:GetOwner():IsNPC() and sv_tfa_damage_multiplier_npc:GetFloat() or sv_tfa_damage_multiplier:GetFloat()

	if not IsFirstTimePredicted() then return end

	con, rec = self:CalculateConeRecoil()

	local tmpranddamage = util.SharedRandom("TFA_Bullet_RandomDamageMult" .. CurTime(), cv_dmg_mult_min:GetFloat(), cv_dmg_mult_max:GetFloat(), self:EntIndex())
	local basedamage = self.ConDamageMultiplier * self:GetStatL("Primary.Damage")
	dmg = basedamage * tmpranddamage

	local ns = self:GetStatL("Primary.NumShots")
	local clip = (self:GetStatL("Primary.ClipSize") == -1) and self:Ammo1() or self:Clip1()

	ns = math.Round(ns, math.min(clip / self:GetStatL("Primary.NumShots"), 1))

	self:ShootBullet(dmg, rec, ns, con)
end

function SWEP:PreSpawnProjectile(ent)
	-- override
end

function SWEP:PostSpawnProjectile(ent)
	-- override
end

--[[
Function Name:  ShootBullet
Syntax: self:ShootBullet(damage, recoil, number of bullets, spray cone, disable ricochet, override the generated self.MainBullet table with this value if you send it).
Returns:   Nothing.
Notes:  Used to shoot a self.MainBullet.
Purpose:  Bullet
]]
--
local TracerName
local cv_forcemult = GetConVar("sv_tfa_force_multiplier")
local sv_tfa_bullet_penetration_power_mul = GetConVar("sv_tfa_bullet_penetration_power_mul")
local sv_tfa_bullet_randomseed = GetConVar("sv_tfa_bullet_randomseed")

local randomseed = "tfa_" .. tostring({})

SWEP.Primary.SpreadBiasYaw = 1
SWEP.Primary.SpreadBiasPitch = 1

-- Default ComputeBulletDeviation implementation
-- Custom implementations should return two numbers
-- Yaw (X) and Pitch (Y) deviation
function SWEP:ComputeBulletDeviation(bulletNum, totalBullets, aimcone)
	local sharedRandomSeed

	if sv_tfa_bullet_randomseed:GetBool() then
		sharedRandomSeed = randomseed .. CurTime()
	else
		sharedRandomSeed = "TFA_ShootBullet" .. CurTime()
	end

	return
		-- Yaw
		util.SharedRandom(sharedRandomSeed, -aimcone * 45 * self:GetStatL("Primary.SpreadBiasYaw"), aimcone * 45 * self:GetStatL("Primary.SpreadBiasYaw"), totalBullets + 1 + bulletNum),
		-- Pitch
		util.SharedRandom(sharedRandomSeed, -aimcone * 45 * self:GetStatL("Primary.SpreadBiasPitch"), aimcone * 45 * self:GetStatL("Primary.SpreadBiasPitch"), bulletNum)
end

function SWEP:ShootBullet(damage, recoil, num_bullets, aimcone, disablericochet, bulletoverride)
	if not IsFirstTimePredicted() and not game.SinglePlayer() then return end
	num_bullets = num_bullets or 1
	aimcone = aimcone or 0

	self:SetLastGunFire(CurTime())

	local owner = self:GetOwner()

	if self:GetStatL("Primary.Projectile") then
		if CLIENT then return end

		for i = 1, num_bullets do
			local ent = ents.Create(self:GetStatL("Primary.Projectile"))

			local ang = self:GetAimAngle()

			local dYaw, dPitch = self:ComputeBulletDeviation(i, num_bullets, aimcone)
			ang:RotateAroundAxis(ang:Up(), dYaw)
			ang:RotateAroundAxis(ang:Right(), dPitch)

			ent:SetPos(owner:GetShootPos())
			ent:SetOwner(owner)
			ent:SetAngles(ang)
			ent.damage = self:GetStatL("Primary.Damage")
			ent.mydamage = self:GetStatL("Primary.Damage")

			if self:GetStatL("Primary.ProjectileModel") then
				ent:SetModel(self:GetStatL("Primary.ProjectileModel"))
			end

			self:PreSpawnProjectile(ent)

			ent:Spawn()

			local dir = ang:Forward()
			dir:Mul(self:GetStatL("Primary.ProjectileVelocity"))

			ent:SetVelocity(dir)
			local phys = ent:GetPhysicsObject()

			if IsValid(phys) then
				phys:SetVelocity(dir)
			end

			if self.ProjectileModel then
				ent:SetModel(self:GetStatL("Primary.ProjectileModel"))
			end

			self:PostSpawnProjectile(ent)
		end
		-- Source
		-- Dir of self.MainBullet
		-- Aim Cone X
		-- Aim Cone Y
		-- Show a tracer on every x bullets
		-- Amount of force to give to phys objects

		return
	end

	if self.Tracer == 1 then
		TracerName = "Ar2Tracer"
	elseif self.Tracer == 2 then
		TracerName = "AirboatGunHeavyTracer"
	else
		TracerName = "Tracer"
	end

	self.MainBullet.PCFTracer = nil

	if self:GetStatL("TracerName") and self:GetStatL("TracerName") ~= "" then
		if self:GetStatL("TracerPCF") then
			TracerName = nil
			self.MainBullet.PCFTracer = self:GetStatL("TracerName")
			self.MainBullet.Tracer = 0
		else
			TracerName = self:GetStatL("TracerName")
		end
	end

	self.MainBullet.Attacker = owner
	self.MainBullet.Inflictor = self
	self.MainBullet.Src = owner:GetShootPos()

	self.MainBullet.Dir = self:GetAimVector()
	self.MainBullet.HullSize = self:GetStatL("Primary.HullSize") or 0
	self.MainBullet.Spread.x = 0
	self.MainBullet.Spread.y = 0

	self.MainBullet.Num = 1

	if num_bullets == 1 then
		local dYaw, dPitch = self:ComputeBulletDeviation(1, 1, aimcone)

		local ang = self.MainBullet.Dir:Angle()
		local up, right = ang:Up(), ang:Right()

		ang:RotateAroundAxis(up, dYaw)
		ang:RotateAroundAxis(right, dPitch)

		self.MainBullet.Dir = ang:Forward()
	end

	self.MainBullet.Wep = self

	if self.TracerPCF then
		self.MainBullet.Tracer = 0
	else
		self.MainBullet.Tracer = self:GetStatL("TracerCount") or 3
	end

	self.MainBullet.TracerName = TracerName
	self.MainBullet.PenetrationCount = 0
	self.MainBullet.PenetrationPower = self:GetStatL("Primary.PenetrationPower") * sv_tfa_bullet_penetration_power_mul:GetFloat(1)
	self.MainBullet.InitialPenetrationPower = self.MainBullet.PenetrationPower
	self.MainBullet.AmmoType = self:GetPrimaryAmmoType()
	self.MainBullet.Force = self:GetStatL("Primary.Force") * cv_forcemult:GetFloat() * self:GetAmmoForceMultiplier()
	self.MainBullet.Damage = damage
	self.MainBullet.InitialDamage = damage
	self.MainBullet.InitialForce = self.MainBullet.Force
	self.MainBullet.InitialPosition = Vector(self.MainBullet.Src)
	self.MainBullet.HasAppliedRange = false

	if self.CustomBulletCallback then
		self.MainBullet.Callback2 = self.CustomBulletCallback
	else
		self.MainBullet.Callback2 = nil
	end

	if num_bullets > 1 then
		local ang_ = self.MainBullet.Dir:Angle()
		local up, right = ang_:Up(), ang_:Right()

		-- single callback per multiple bullets fix
		for i = 1, num_bullets do
			local bullet = table.Copy(self.MainBullet)

			local ang = Angle(ang_)

			local dYaw, dPitch = self:ComputeBulletDeviation(i, num_bullets, aimcone)
			ang:RotateAroundAxis(up, dYaw)
			ang:RotateAroundAxis(right, dPitch)

			bullet.Dir = ang:Forward()

			function bullet.Callback(attacker, trace, dmginfo)
				if not IsValid(self) then return end

				dmginfo:SetInflictor(self)
				dmginfo:SetDamage(dmginfo:GetDamage() * bullet:CalculateFalloff(trace.HitPos))

				if bullet.Callback2 then
					bullet.Callback2(attacker, trace, dmginfo)
				end

				self:CallAttFunc("CustomBulletCallback", attacker, trace, dmginfo)

				bullet:Penetrate(attacker, trace, dmginfo, self, {})
				self:PCFTracer(bullet, trace.HitPos or vector_origin)
			end

			BallisticFirebullet(owner, bullet, nil, ang)
		end

		return
	end

	function self.MainBullet.Callback(attacker, trace, dmginfo)
		if not IsValid(self) then return end

		dmginfo:SetInflictor(self)
		dmginfo:SetDamage(dmginfo:GetDamage() * self.MainBullet:CalculateFalloff(trace.HitPos))

		if self.MainBullet.Callback2 then
			self.MainBullet.Callback2(attacker, trace, dmginfo)
		end

		self:CallAttFunc("CustomBulletCallback", attacker, trace, dmginfo)

		self.MainBullet:Penetrate(attacker, trace, dmginfo, self, {})
		self:PCFTracer(self.MainBullet, trace.HitPos or vector_origin)
	end

	BallisticFirebullet(owner, self.MainBullet, nil, self.MainBullet.Dir:Angle())
end

local sp = game.SinglePlayer()

function SWEP:TFAMove(ply, movedata)
	local velocity = self:GetQueuedRecoil()

	if velocity:Length() ~= 0 then
		movedata:SetVelocity(movedata:GetVelocity() + velocity)
		self:SetQueuedRecoil(vector_origin)
	end
end

hook.Add("Move", "TFAMove", function(self, movedata)
	local weapon = self:GetActiveWeapon()

	if IsValid(weapon) and weapon.IsTFAWeapon then
		weapon:TFAMove(self, movedata)
	end
end)

local sv_tfa_recoil_mul_p = GetConVar("sv_tfa_recoil_mul_p")
local sv_tfa_recoil_mul_p_npc = GetConVar("sv_tfa_recoil_mul_p_npc")
local sv_tfa_recoil_mul_y = GetConVar("sv_tfa_recoil_mul_y")
local sv_tfa_recoil_mul_y_npc = GetConVar("sv_tfa_recoil_mul_y_npc")

local sv_tfa_recoil_viewpunch_mul = GetConVar("sv_tfa_recoil_viewpunch_mul")
local sv_tfa_recoil_eyeangles_mul = GetConVar("sv_tfa_recoil_eyeangles_mul")

function SWEP:SetRecoilVector(vector)
	if self:GetOwner():IsPlayer() then
		self:SetQueuedRecoil(vector)
	else
		self:GetOwner():SetVelocity(vector)
	end
end

function SWEP:QueueRecoil(vector)
	if self:GetOwner():IsPlayer() then
		self:SetQueuedRecoil(vector + self:GetQueuedRecoil())
	else
		self:GetOwner():SetVelocity(vector)
	end
end

function SWEP:Recoil(recoil, ifp)
	if sp and type(recoil) == "string" then
		local _, CurrentRecoil = self:CalculateConeRecoil()
		self:Recoil(CurrentRecoil, true)

		return
	end

	local owner = self:GetOwner()
	local isplayer = owner:IsPlayer()

	self:SetSpreadRatio(l_mathClamp(self:GetSpreadRatio() + self:GetStatL("Primary.SpreadIncrement"), 1, self:GetStatL("Primary.SpreadMultiplierMax")))
	self:QueueRecoil(-owner:GetAimVector() * self:GetStatL("Primary.Knockback") * cv_forcemult:GetFloat() * recoil / 5)

	local seed = self:GetSeed() + 1

	local kickP = util.SharedRandom("TFA_KickDown", self:GetStatL("Primary.KickDown"), self:GetStatL("Primary.KickUp"), seed) * recoil * -1
	local kickY = util.SharedRandom("TFA_KickHorizontal", -self:GetStatL("Primary.KickHorizontal"), self:GetStatL("Primary.KickHorizontal"), seed) * recoil

	if isplayer then
		kickP, kickY = kickP * sv_tfa_recoil_mul_p:GetFloat(), kickY * sv_tfa_recoil_mul_y:GetFloat()
	else
		kickP, kickY = kickP * sv_tfa_recoil_mul_p_npc:GetFloat(), kickY * sv_tfa_recoil_mul_y_npc:GetFloat()
	end

	local factor = 1 - self:GetStatL("Primary.StaticRecoilFactor")

	if self:GetIronSights() then
		factor = factor * Lerp(self:GetIronSightsProgress(), 1, self:GetStatL("Primary.IronRecoilMultiplier", 0.5))
	end

	factor = factor * Lerp(self:GetCrouchingRatio(), 1, self:GetStatL("CrouchAccuracyMultiplier", 0.5))

	local punchY = kickY * factor
	local deltaP = 0
	local deltaY = 0

	if self:HasRecoilLUT() then
		local ang = self:GetRecoilLUTAngle()

		if self:GetPrevRecoilAngleTime() < CurTime() then
			self:SetPrevRecoilAngleTime(CurTime() + 0.1)
			self:SetPrevRecoilAngle(ang)
		end

		local prev_recoil_angle = self:GetPrevRecoilAngle()
		deltaP = ang.p - prev_recoil_angle.p
		deltaY = ang.y - prev_recoil_angle.y
		self:SetPrevRecoilAngle(ang)
	end

	if isplayer then
		local maxdist = math.min(math.max(0, 89 + owner:EyeAngles().p - math.abs(owner:GetViewPunchAngles().p * 2)), 88.5)
		local punchP = l_mathClamp((kickP + deltaP * self:GetStatL("Primary.RecoilLUT_ViewPunchMult")) * factor, -maxdist, maxdist)

		owner:ViewPunch(Angle(punchP * sv_tfa_recoil_viewpunch_mul:GetFloat(), (punchY + deltaY * self:GetStatL("Primary.RecoilLUT_ViewPunchMult")) * sv_tfa_recoil_viewpunch_mul:GetFloat()))
	end

	if (not isplayer or not sv_tfa_recoil_legacy:GetBool()) and not self:HasRecoilLUT() then
		local maxdist2 = l_mathClamp(30 - math.abs(self:GetViewPunchP()), 0, 30)
		local punchP2 = l_mathClamp(kickP, -maxdist2, maxdist2) * factor

		self:SetViewPunchP(self:GetViewPunchP() + punchP2 * 1.5)
		self:SetViewPunchY(self:GetViewPunchY() + punchY * 1.5)
		self:SetViewPunchBuild(math.min(3, self:GetViewPunchBuild() + math.sqrt(math.pow(punchP2, 2) + math.pow(punchY, 2)) / 3) + 0.2)
	end

	if isplayer and ((game.SinglePlayer() and SERVER) or (CLIENT and ifp)) then
		local neweyeang = owner:EyeAngles()

		local ap, ay = (kickP + deltaP * self:GetStatL("Primary.RecoilLUT_AnglePunchMult")) * self:GetStatL("Primary.StaticRecoilFactor") * sv_tfa_recoil_eyeangles_mul:GetFloat(),
						(kickY + deltaY * self:GetStatL("Primary.RecoilLUT_AnglePunchMult")) * self:GetStatL("Primary.StaticRecoilFactor") * sv_tfa_recoil_eyeangles_mul:GetFloat()

		neweyeang.p = neweyeang.p + ap
		neweyeang.y = neweyeang.y + ay
		--neweyeang.p = l_mathClamp(neweyeang.p, -90 + math.abs(owner:GetViewPunchAngles().p), 90 - math.abs(owner:GetViewPunchAngles().p))
		owner:SetEyeAngles(neweyeang)
	end
end

--[[
Function Name:  GetAmmoRicochetMultiplier
Syntax: self:GetAmmoRicochetMultiplier().
Returns:  The ricochet multiplier for our ammotype.  More is more chance to ricochet.
Notes:  Only compatible with default ammo types, unless you/I mod that.  BMG ammotype is detected based on name and category.
Purpose:  Utility
]]
--
function SWEP:GetAmmoRicochetMultiplier()
	local am = string.lower(self:GetStatL("Primary.Ammo"))

	if (am == "pistol") then
		return 1.25
	elseif (am == "357") then
		return 0.75
	elseif (am == "smg1") then
		return 1.1
	elseif (am == "ar2") then
		return 0.9
	elseif (am == "buckshot") then
		return 2
	elseif (am == "slam") then
		return 1.5
	elseif (am == "airboatgun") then
		return 0.8
	elseif (am == "sniperpenetratedround") then
		return 0.5
	else
		return 1
	end
end

--[[
Function Name:  GetMaterialConcise
Syntax: self:GetMaterialConcise().
Returns:  The string material name.
Notes:  Always lowercase.
Purpose:  Utility
]]
--
function SWEP:GetAmmoForceMultiplier()
	-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
	--AR2=Rifle ~= Caliber>.308
	--SMG1=SMG ~= Small/Medium Calber ~= 5.56 or 9mm
	--357=Revolver ~= .357 through .50 magnum
	--Pistol = Small or Pistol Bullets ~= 9mm, sometimes .45ACP but rarely.  Generally light.
	--Buckshot = Buckshot = Light, barely-penetrating sniper bullets.
	--Slam = Medium Shotgun Round
	--AirboatGun = Heavy, Penetrating Shotgun Round
	--SniperPenetratedRound = Heavy Large Rifle Caliber ~= .50 Cal blow-yer-head-off
	local am = string.lower(self:GetStatL("Primary.Ammo"))

	if (am == "pistol") then
		return 0.4
	elseif (am == "357") then
		return 0.6
	elseif (am == "smg1") then
		return 0.475
	elseif (am == "ar2") then
		return 0.6
	elseif (am == "buckshot") then
		return 0.5
	elseif (am == "slam") then
		return 0.5
	elseif (am == "airboatgun") then
		return 0.7
	elseif (am == "sniperpenetratedround") then
		return 1
	else
		return 1
	end
end

--[[
Function Name:  GetPenetrationMultiplier
Syntax: self:GetPenetrationMultiplier( concise material name).
Returns:  The multilier for how much you can penetrate through a material.
Notes:  Should be used with GetMaterialConcise.
Purpose:  Utility
]]
--
SWEP.Primary.PenetrationMaterials = {
	[MAT_DEFAULT] = 1,
	[MAT_VENT] = 0.4, --Since most is aluminum and stuff
	[MAT_METAL] = 0.6, --Since most is aluminum and stuff
	[MAT_WOOD] = 0.2,
	[MAT_PLASTIC] = 0.23,
	[MAT_FLESH] = 0.48,
	[MAT_CONCRETE] = 0.87,
	[MAT_GLASS] = 0.16,
	[MAT_SAND] = 1,
	[MAT_SLOSH] = 1,
	[MAT_DIRT] = 0.95, --This is plaster, not dirt, in most cases.
	[MAT_FOLIAGE] = 0.9
}

local fac

function SWEP:GetPenetrationMultiplier(mat)
	fac = self.Primary.PenetrationMaterials[mat or MAT_DEFAULT] or self.Primary.PenetrationMaterials[MAT_DEFAULT]

	return fac * (self:GetStatL("Primary.PenetrationMultiplier") and self:GetStatL("Primary.PenetrationMultiplier") or 1)
end

local decalbul = {
	Num = 1,
	Spread = vector_origin,
	Tracer = 0,
	TracerName = "",
	Force = 0,
	Damage = 0,
	Distance = 40
}

local maxpen
local penetration_max_cvar = GetConVar("sv_tfa_penetration_hardlimit")
local penetration_cvar = GetConVar("sv_tfa_bullet_penetration")
local ricochet_cvar = GetConVar("sv_tfa_bullet_ricochet")
local cv_rangemod = GetConVar("sv_tfa_range_modifier")
local cv_decalbul = GetConVar("sv_tfa_fx_penetration_decal")
local atype
local develop = GetConVar("developer")
local sv_tfa_debug = GetConVar("sv_tfa_debug")

function SWEP:SetBulletTracerName(nm)
	self.BulletTracerName = nm or self.BulletTracerName or ""
end

local debugcolors = {
	Color(166, 91, 236),
	Color(91, 142, 236),
	Color(29, 197, 208),
	Color(61, 232, 109),
	Color(194, 232, 61),
	Color(232, 178, 61),
	Color(232, 61, 129),
	Color(128, 31, 109),
}

local nextdebugcol = -1
local debugsphere1 = Color(149, 189, 230)
local debugsphere2 = Color(34, 43, 53)
local debugsphere3 = Color(255, 255, 255)
local debugsphere4 = Color(0, 0, 255)
local debugsphere5 = Color(12, 255, 0)

local IsInWorld, IsInWorld2

do
	local tr = {collisiongroup = COLLISION_GROUP_WORLD}

	function IsInWorld2(pos)
		tr.start = pos
		tr.endpos = pos
		return not util.TraceLine(tr).AllSolid
	end
end

if CLIENT then
	IsInWorld = IsInWorld2
else
	IsInWorld = util.IsInWorld
end

local MAX_CORRECTION_ITERATIONS = 20

-- bullettable can be nil
function SWEP:CalculateFalloff(InitialPosition, HitPos, bullettable)
	local dist = InitialPosition:Distance(HitPos)

	if not self.Primary.RangeFalloffLUTBuilt then return 1 end

	local target = self.Primary.RangeFalloffLUTBuilt

	if dist <= target[1][1] then
		return target[1][2]
	end

	if dist >= target[#target][1] then
		return target[#target][2]
	end

	for i = 1, #target - 1 do
		local a, b = target[i], target[i + 1]

		if a[1] <= dist and b[1] >= dist then
			return Lerp((dist - a[1]) / (b[1] - a[1]), a[2], b[2])
		end
	end

	return target[#target][2] -- wtf?
end

function SWEP.MainBullet:CalculateFalloff(HitPos)
	return self.Wep:CalculateFalloff(self.InitialPosition, HitPos, self)
end

local function shouldDisplayDebug()
	return SERVER and sv_tfa_debug:GetBool() and develop:GetBool() and DLib
end

function SWEP.MainBullet:Penetrate(ply, traceres, dmginfo, weapon, penetrated, previousStartPos)
	if hook.Run("TFA_Bullet_Penetrate", weapon, ply, traceres, dmginfo, penetrated, previousStartPos) == false then return end

	--debugoverlay.Sphere( self.Src, 5, 5, color_white, true)

	DisableOwnerDamage(ply, traceres, dmginfo)

	if self.TracerName and self.TracerName ~= "" then
		weapon.BulletTracerName = self.TracerName

		if game.SinglePlayer() then
			weapon:CallOnClient("SetBulletTracerName", weapon.BulletTracerName)
		end
	end

	if not IsValid(weapon) then return end

	local hitent = traceres.Entity

	self:HandleDoor(ply, traceres, dmginfo, weapon)

	atype = weapon:GetStatL("Primary.DamageType")
	dmginfo:SetDamageType(atype)

	if SERVER and IsValid(ply) and ply:IsPlayer() and IsValid(hitent) and (hitent:IsPlayer() or hitent:IsNPC() or type(hitent) == "NextBot") then
		weapon:SendHitMarker(ply, traceres, dmginfo)
	end

	if IsValid(traceres.Entity) and traceres.Entity:GetClass() == "npc_sniper" then
		traceres.Entity.TFAHP = (traceres.Entity.TFAHP or 100) - dmginfo:GetDamage()

		if traceres.Entity.TFAHP <= 0 then
			traceres.Entity:Fire("SetHealth", "", -1)
		end
	end

	local cl = hitent:GetClass()

	if cl == "npc_helicopter" then
		dmginfo:SetDamageType(bit.bor(dmginfo:GetDamageType(), DMG_AIRBOAT))
	end

	-- custom damage checks
	if atype ~= DMG_BULLET then
		--[[if cl == "npc_strider" and (dmginfo:IsDamageType(DMG_SHOCK) or dmginfo:IsDamageType(DMG_BLAST)) and traceres.Hit and IsValid(hitent) and hitent.Fire then
			hitent:SetHealth(math.max(hitent:Health() - dmginfo:GetDamage(), 2))

			if hitent:Health() <= 3 then
				hitent:Extinguish()
				hitent:Fire("sethealth", "-1", 0.01)
				dmginfo:ScaleDamage(0)
			end
		end]]

		if dmginfo:IsDamageType(DMG_BURN) and weapon.Primary.DamageTypeHandled and traceres.Hit and IsValid(hitent) and not traceres.HitWorld and not traceres.HitSky and dmginfo:GetDamage() > 1 and hitent.Ignite then
			hitent:Ignite(dmginfo:GetDamage() / 2, 1)
		end

		if dmginfo:IsDamageType(DMG_BLAST) and weapon.Primary.DamageTypeHandled and traceres.Hit and not traceres.HitSky then
			local tmpdmg = dmginfo:GetDamage()
			dmginfo:SetDamageForce(dmginfo:GetDamageForce() / 2)
			util.BlastDamageInfo(dmginfo, traceres.HitPos, weapon:GetStatL("Primary.BlastRadius") or (tmpdmg / 2)  )
			--util.BlastDamage(weapon, weapon:GetOwner(), traceres.HitPos, tmpdmg / 2, tmpdmg)
			local fx = EffectData()
			fx:SetOrigin(traceres.HitPos)
			fx:SetNormal(traceres.HitNormal)

			if weapon:GetStatL("Primary.ImpactEffect") then
				TFA.Effects.Create(weapon:GetStatL("Primary.ImpactEffect"), fx)
			elseif tmpdmg > 90 then
				TFA.Effects.Create("HelicopterMegaBomb", fx)
				TFA.Effects.Create("Explosion", fx)
			elseif tmpdmg > 45 then
				TFA.Effects.Create("cball_explode", fx)
			else
				TFA.Effects.Create("MuzzleEffect", fx)
			end

			dmginfo:ScaleDamage(0.15)
		end
	end

	if self:Ricochet(ply, traceres, dmginfo, weapon) then
		if shouldDisplayDebug() then
			DLib.debugoverlay.Text(traceres.HitPos - Vector(0, 0, 12), 'ricochet', 10)
		end

		return
	end

	if penetration_cvar and not penetration_cvar:GetBool() then return end
	if self.PenetrationCount > math.min(penetration_max_cvar:GetInt(100), weapon:GetStatL("Primary.MaxSurfacePenetrationCount", math.huge)) then return end
	-- source engine quirk - if bullet is fired too close to brush surface
	-- it is assumed to be fired right in front of it, rather than exact
	-- position you specified.
	if previousStartPos and previousStartPos:Distance(traceres.HitPos) < 0.05 then return end
	local oldTraceResHitPos = Vector(traceres.HitPos)

	local mult = weapon:GetPenetrationMultiplier(traceres.MatType)
	local newdir = (traceres.HitPos - traceres.StartPos):GetNormalized()
	local desired_length = l_mathClamp(self.PenetrationPower / mult, 0, l_mathClamp(sv_tfa_bullet_penetration_power_mul:GetFloat() * 100, 1000, 8000))
	local penetrationoffset = newdir * desired_length

	local pentrace = {
		start = traceres.HitPos,
		endpos = traceres.HitPos + penetrationoffset,
		mask = MASK_SHOT,
		filter = penetrated
	}

	local isent = IsValid(traceres.Entity)
	local startpos, decalstartpos

	if isent then
		table.insert(penetrated, traceres.Entity)
	else
		pentrace.start:Add(traceres.Normal)
		pentrace.start:Add(traceres.Normal)
		pentrace.collisiongroup = COLLISION_GROUP_WORLD
		pentrace.filter = NULL
	end

	local pentraceres = util.TraceLine(pentrace)
	local pentraceres2, pentrace2
	local loss
	local realstartpos

	if not isent then
		local acc_length = pentraceres.HitPos:Distance(pentraceres.StartPos)

		local ostart = pentrace.start
		local FractionLeftSolid = pentraceres.FractionLeftSolid
		local iter = 0

		local cond = (pentraceres.AllSolid or not IsInWorld2(pentraceres.HitPos)) and acc_length < desired_length

		while (pentraceres.AllSolid or not IsInWorld2(pentraceres.HitPos)) and acc_length <= desired_length and iter < MAX_CORRECTION_ITERATIONS do
			iter = iter + 1

			pentrace.start = pentraceres.HitPos + newdir * 8

			if shouldDisplayDebug() then
				DLib.debugoverlay.Cross(pentrace.start, 8, 10, Color(iter / MAX_CORRECTION_ITERATIONS * 255, iter / MAX_CORRECTION_ITERATIONS * 255, iter / MAX_CORRECTION_ITERATIONS * 255), true)
			end

			pentraceres = util.TraceLine(pentrace)
			acc_length = acc_length + pentraceres.HitPos:Distance(pentraceres.StartPos) + 8
		end

		if cond and not (pentraceres.AllSolid or not IsInWorld2(pentraceres.HitPos)) then
			pentraceres.FractionLeftSolid = ostart:Distance(pentrace.start) / ostart:Distance(pentrace.endpos) + pentraceres.FractionLeftSolid + 0.02
			pentrace.start = ostart
			pentraceres.StartPos = ostart
		else
			pentraceres.FractionLeftSolid = FractionLeftSolid
			pentrace.start = ostart
			pentraceres.StartPos = ostart
		end
	end

	if isent then
		startpos = pentraceres.HitPos - newdir
		local ent = traceres.Entity

		pentrace2 = {
			start = startpos,
			endpos = pentrace.start,
			mask = MASK_SHOT,
			ignoreworld = true,
			filter = function(ent2)
				return ent2 == ent
			end
		}

		pentraceres2 = util.TraceLine(pentrace2)
		loss = pentraceres2.HitPos:Distance(pentrace.start) * mult

		if pentraceres2.HitPos:Distance(pentrace.start) < 0.01 then
			-- bullet stuck in
			loss = self.PenetrationPower
		end

		decalstartpos = pentraceres2.HitPos + newdir * 3

		if shouldDisplayDebug() then
			nextdebugcol = (nextdebugcol + 1) % #debugcolors
			DLib.debugoverlay.Line(pentrace.start, pentrace.endpos, 10, debugcolors[nextdebugcol + 1], true)
			DLib.debugoverlay.Cross(pentrace.start, 8, 10, debugsphere1, true)
			DLib.debugoverlay.Cross(pentraceres2.HitPos, 8, 10, debugsphere2, true)
		end

		if self.IsBallistics then
			startpos = decalstartpos
		end

		realstartpos = decalstartpos
	else
		startpos = LerpVector(pentraceres.FractionLeftSolid, pentrace.start, pentrace.endpos) + newdir * 4
		realstartpos = startpos
		decalstartpos = startpos + newdir * 2
		loss = startpos:Distance(pentrace.start) * mult

		if shouldDisplayDebug() then
			nextdebugcol = (nextdebugcol + 1) % #debugcolors
			DLib.debugoverlay.Line(pentrace.start, pentrace.endpos, 10, debugcolors[nextdebugcol + 1], true)
			DLib.debugoverlay.Cross(pentrace.start, 8, 10, debugsphere1, true)
			DLib.debugoverlay.Cross(startpos, 8, 10, debugsphere2, true)
		end

		if pentraceres.AllSolid then
			return
		elseif not IsInWorld(pentraceres.HitPos) then
			return
		end

		if not IsInWorld2(startpos) then
			for i = 1, 10 do
				startpos = LerpVector(pentraceres.FractionLeftSolid, pentrace.start, pentrace.endpos) + newdir * ((4 - i) * 3)

				if IsInWorld2(startpos) then break end

				startpos = LerpVector(pentraceres.FractionLeftSolid, pentrace.start, pentrace.endpos) + newdir * ((4 + i) * 3)

				if IsInWorld2(startpos) then break end
			end

			if not IsInWorld2(startpos) then
				return
			end
		end
	end

	if self.PenetrationPower - loss <= 0 then
		if shouldDisplayDebug() then
			DLib.debugoverlay.Text(startpos, string.format('Lost penetration power %.3f %.3f', self.PenetrationPower, loss), 10)
		end

		return
	end

	self.PenetrationCount = self.PenetrationCount + 1
	local prev = self.PenetrationPower
	self.PenetrationPower = self.PenetrationPower - loss

	local mfac = self.PenetrationPower / self.InitialPenetrationPower

	if shouldDisplayDebug() and weapon.Primary.RangeFalloffLUTBuilt then
		DLib.debugoverlay.Text(traceres.HitPos + Vector(0, 0, 12), string.format('NEW Damage falloff final %.3f %.3f %.3f %.3f', self.InitialPosition:Distance(traceres.HitPos), self:CalculateFalloff(traceres.HitPos), mfac * self.InitialDamage * self:CalculateFalloff(traceres.HitPos), mfac), 12)
	end

	local Damage = self.InitialDamage * self:CalculateFalloff(realstartpos) * mfac

	local bul = {
		PenetrationPower = self.PenetrationPower,
		PenetrationCount = self.PenetrationCount,
		InitialPenetrationPower = self.InitialPenetrationPower,
		InitialDamage = self.InitialDamage,
		InitialForce = self.InitialForce,
		CalculateFalloff = self.CalculateFalloff,
		InitialPosition = self.InitialPosition,
		Src = startpos,
		Dir = newdir,
		Tracer = 1,
		TracerName = self.TracerName,
		IgnoreEntity = traceres.Entity,

		Num = 1,
		Force = self.InitialForce * mfac,
		Damage = Damage,
		Penetrate = self.Penetrate,
		MakeDoor = self.MakeDoor,
		HandleDoor = self.HandleDoor,
		Ricochet = self.Ricochet,
		Spread = vector_origin,
		Wep = weapon,
	}

	if shouldDisplayDebug()  then
		DLib.debugoverlay.Text(startpos, string.format('penetrate %.3f->%.3f %d %.3f', prev, self.PenetrationPower, self.PenetrationCount, mfac), 10)
	end

	function bul.Callback(attacker, trace, dmginfo2)
		if shouldDisplayDebug()  then
			DLib.debugoverlay.Cross(trace.HitPos, 8, 10, debugsphere3, true)
			DLib.debugoverlay.Text(trace.HitPos - Vector(0, 0, 7), string.format('hit %.3f %d', mfac, bul.PenetrationCount, bul.PenetrationPower), 10)
		end

		dmginfo2:SetInflictor(IsValid(bul.Wep) and bul.Wep or IsValid(ply) and ply or Entity(0))

		bul.Damage = self.InitialDamage * self:CalculateFalloff(trace.HitPos) * mfac
		dmginfo2:SetDamage(bul.Damage)

		hook.Run("TFA_BulletPenetration", bul, attacker, trace, dmginfo2)

		-- TODO: User died while bullet make penetration
		-- handle further penetrations even when user is dead
		if IsValid(bul.Wep) then
			bul:Penetrate(attacker, trace, dmginfo2, bul.Wep, penetrated, oldTraceResHitPos)
		end
	end

	decalbul.Dir = -newdir
	decalbul.Src = decalstartpos
	decalbul.Callback = DisableOwnerDamage
	decalbul.IgnoreEntity = bul.IgnoreEntity

	if shouldDisplayDebug()  then
		DLib.debugoverlay.Cross(decalbul.Src, 8, 10, debugsphere4, true)
		DLib.debugoverlay.Cross(decalbul.Src + decalbul.Dir * decalbul.Distance, 8, 10, debugsphere5, true)
	end

	if self.PenetrationCount <= 1 and IsValid(weapon) then
		weapon:PCFTracer(self, pentraceres.HitPos or traceres.HitPos, true)
	end

	local fx = EffectData()
	fx:SetOrigin(bul.Src)
	fx:SetNormal(bul.Dir)

	fx:SetMagnitude((bul.PenetrationCount + 1) * 1000)
	fx:SetEntity(weapon)

	if IsValid(pentraceres.Entity) and pentraceres.Entity.EntIndex then
		fx:SetScale(pentraceres.Entity:EntIndex())
	end

	fx:SetRadius(bul.Damage / 32)
	TFA.Effects.Create("tfa_penetrate", fx)

	if cv_decalbul:GetBool() then
		ply:FireBullets(decalbul)
	end

	BallisticFirebullet(ply, bul, true)
end

local RicochetChanceEnum = {
	[MAT_GLASS] = 0,
	[MAT_PLASTIC] = 0.01,
	[MAT_DIRT] = 0.01,
	[MAT_GRASS] = 0.01,
	[MAT_SAND] = 0.01,
	[MAT_CONCRETE] = 0.15,
	[MAT_METAL] = 0.7,
	[MAT_DEFAULT] = 0.5,
	[MAT_FLESH] = 0.0
}

function SWEP.MainBullet:Ricochet(ply, traceres, dmginfo, weapon)
	if ricochet_cvar and not ricochet_cvar:GetBool() then return end
	maxpen = math.min(penetration_max_cvar and penetration_max_cvar:GetInt() - 1 or 1, weapon:GetStatL("Primary.MaxSurfacePenetrationCount", math.huge))
	if self.PenetrationCount > maxpen then return end
	local ricochetchance = RicochetChanceEnum[traceres.MatType] or RicochetChanceEnum[MAT_DEFAULT]
	local dir = traceres.HitPos - traceres.StartPos
	dir:Normalize()
	local dp = dir:Dot(traceres.HitNormal * -1)
	ricochetchance = ricochetchance * weapon:GetAmmoRicochetMultiplier()
	local riccbak = ricochetchance / 0.7
	local ricothreshold = 0.6
	ricochetchance = l_mathClamp(ricochetchance * ( 1 + l_mathClamp(1 - (dp + ricothreshold), 0, 1) ), 0, 1)
	if dp <= ricochetchance and math.Rand(0, 1) < ricochetchance then
		local ric = {}
		ric.Ricochet = self.Ricochet
		ric.Penetrate = self.Penetrate
		ric.MakeDoor = self.MakeDoor
		ric.HandleDoor = self.HandleDoor
		ric.Damage = self.Damage * 0.5
		ric.Force = self.Force * 0.5
		ric.Num = 1
		ric.Spread = vector_origin
		ric.Tracer = 0
		ric.Src = traceres.HitPos
		ric.Dir = ((2 * traceres.HitNormal * dp) + traceres.Normal) + (VectorRand() * 0.02)
		ric.PenetrationCount = self.PenetrationCount + 1
		self.PenetrationCount = self.PenetrationCount + 1

		if TFA.GetRicochetEnabled() then
			local fx = EffectData()
			fx:SetOrigin(ric.Src)
			fx:SetNormal(ric.Dir)
			fx:SetMagnitude(riccbak)
			TFA.Effects.Create("tfa_ricochet", fx)
		end

		BallisticFirebullet(ply, ric, true)

		return true
	end
end

local defaultdoorhealth = 250
local cv_doorres = GetConVar("sv_tfa_door_respawn")

function SWEP.MainBullet:MakeDoor(ent, dmginfo)
	local dir = dmginfo:GetDamageForce():GetNormalized()
	local force = dir * math.max(math.sqrt(dmginfo:GetDamageForce():Length() / 1000), 1) * 1000
	local pos = ent:GetPos()
	local ang = ent:GetAngles()
	local mdl = ent:GetModel()
	local ski = ent:GetSkin()
	ent:SetNotSolid(true)
	ent:SetNoDraw(true)
	local prop = ents.Create("prop_physics")
	prop:SetPos(pos + dir * 16)
	prop:SetAngles(ang)
	prop:SetModel(mdl)
	prop:SetSkin(ski or 0)
	prop:Spawn()
	prop:SetVelocity(force)
	prop:GetPhysicsObject():ApplyForceOffset(force, dmginfo:GetDamagePosition())
	prop:SetPhysicsAttacker(dmginfo:GetAttacker())
	prop:EmitSound("physics/wood/wood_furniture_break" .. tostring(math.random(1, 2)) .. ".wav", 110, math.random(90, 110))

	if cv_doorres and cv_doorres:GetInt() ~= -1 then
		timer.Create("TFA_DoorRespawner_" .. ent:EntIndex(), cv_doorres:GetFloat(), 1, function()
			if IsValid(prop) then
				prop:Remove()
			end

			if IsValid(ent) then
				ent.TFADoorHealth = defaultdoorhealth
				ent:SetNotSolid(false)
				ent:SetNoDraw(false)
			end
		end)
	end
end

local cv_doordestruction = GetConVar("sv_tfa_bullet_doordestruction")
local sv_tfa_bullet_doordestruction_keep = GetConVar("sv_tfa_bullet_doordestruction_keep")

function SWEP.MainBullet:HandleDoor(ply, traceres, dmginfo, wep)
	-- Don't do anything if door desstruction isn't enabled
	if not cv_doordestruction:GetBool() then return end
	local ent = traceres.Entity
	if not IsValid(ent) then return end
	if not IsValid(ply) then return end
	if not ents.Create then return end
	if not ply.SetName then return end
	if ent.TFADoorUntouchable and ent.TFADoorUntouchable > CurTime() then return end
	ent.TFADoorHealth = ent.TFADoorHealth or defaultdoorhealth
	if ent:GetClass() ~= "func_door_rotating" and ent:GetClass() ~= "prop_door_rotating" then return end
	local realDamage = dmginfo:GetDamage() * self.Num
	ent.TFADoorHealth = l_mathClamp(ent.TFADoorHealth - realDamage, 0, defaultdoorhealth)
	if ent.TFADoorHealth > 0 then return end
	ply:EmitSound("ambient/materials/door_hit1.wav", 100, math.random(90, 110))

	if not sv_tfa_bullet_doordestruction_keep:GetBool() and self.Damage * self.Num > 100 then
		self:MakeDoor(ent, dmginfo)
		ent.TFADoorUntouchable = CurTime() + 0.5

		return
	end

	ply.oldname = ply:GetName()
	ply:SetName("bashingpl" .. ply:EntIndex())
	ent:Fire("unlock", "", .01)
	ent:SetKeyValue("Speed", "500")
	ent:SetKeyValue("Open Direction", "Both directions")
	ent:SetKeyValue("opendir", "0")
	ent:Fire("openawayfrom", "bashingpl" .. ply:EntIndex(), .01)

	timer.Simple(0.02, function()
		if IsValid(ply) then
			ply:SetName(ply.oldname)
		end
	end)

	timer.Simple(0.3, function()
		if IsValid(ent) then
			ent:SetKeyValue("Speed", "100")
		end
	end)

	timer.Simple(5, function()
		if IsValid(ent) then
			ent.TFADoorHealth = defaultdoorhealth
		end
	end)

	ent.TFADoorUntouchable = CurTime() + 5
end
--addons/tfa_base/lua/weapons/tfa_gun_base/common/ttt.lua:
SWEP.HeadshotMultiplier = 2.7
SWEP.StoredAmmo = 0
SWEP.IsDropped = false
SWEP.DeploySpeed = 1.4
SWEP.fingerprints = {}

-- crosshair
if CLIENT then
	-- luacheck: globals LANG Key
	local SafeTranslation = function(x) return x end
	local GetPTranslation = LANG and LANG.GetParamTranslation or SafeTranslation

	-- Many non-gun weapons benefit from some help
	local help_spec = {
		text = "",
		font = "TabLarge",
		xalign = TEXT_ALIGN_CENTER
	}

	function SWEP:DrawHelp()
		local data = self.HUDHelp
		local translate = data.translatable
		local primary = data.primary
		local secondary = data.secondary

		if translate then
			primary = primary and GetPTranslation(primary, data.translate_params)
			secondary = secondary and GetPTranslation(secondary, data.translate_params)
		end

		help_spec.pos = {ScrW() / 2.0, ScrH() - 40}
		help_spec.text = secondary or primary
		draw.TextShadow(help_spec, 2)

		-- if no secondary exists, primary is drawn at the bottom and no top line
		-- is drawn
		if secondary then
			help_spec.pos[2] = ScrH() - 60
			help_spec.text = primary
			draw.TextShadow(help_spec, 2)
		end
	end

	local function SafeKey(binding, default)
		local b = input.LookupBinding(binding)
		if not b then return default end

		return string.upper(b)
	end

	local Key = Key or SafeKey

	-- mousebuttons are enough for most weapons
	local default_key_params = {
		primaryfire = Key("+attack", "LEFT MOUSE"),
		secondaryfire = Key("+attack2", "RIGHT MOUSE"),
		usekey = Key("+use", "USE")
	}

	function SWEP:AddHUDHelp(primary_text, secondary_text, translate, extra_params)
		extra_params = extra_params or {}

		self.HUDHelp = {
			primary = primary_text,
			secondary = secondary_text,
			translatable = translate,
			translate_params = table.Merge(extra_params, default_key_params)
		}
	end
end

function SWEP:GetHeadshotMultiplier(victim, dmginfo)
	return self.HeadshotMultiplier or 2
end

function SWEP:IsEquipment()
	-- luacheck: globals WEPS
	if WEPS and WEPS.IsEquipment then
		local val = WEPS.IsEquipment(self)

		if val ~= nil then
			return val
		else
			return false
		end
	else
		return false
	end
end

-- The OnDrop() hook is useless for this as it happens AFTER the drop. OwnerChange
-- does not occur when a drop happens for some reason. Hence this thing.
function SWEP:PreDrop()
	if not IsValid(self) then return end
	if not self.Ammo1 then return end

	if SERVER and IsValid(self:GetOwner()) and self.Primary_TFA.Ammo ~= "none" then
		local ammo = self:Ammo1()

		-- Do not drop ammo if we have another gun that uses this type
		for _, w in pairs(self:GetOwner():GetWeapons()) do
			if IsValid(w) and w ~= self and w:GetPrimaryAmmoType() == self:GetPrimaryAmmoType() then
				ammo = 0
			end
		end

		self.StoredAmmo = ammo

		if ammo > 0 then
			self:GetOwner():RemoveAmmo(ammo, self.Primary_TFA.Ammo)
		end
	end
end

function SWEP:DampenDrop()
	if not IsValid(self) then return end
	-- For some reason gmod drops guns on death at a speed of 400 units, which
	-- catapults them away from the body. Here we want people to actually be able
	-- to find a given corpse's weapon, so we override the velocity here and call
	-- this when dropping guns on death.
	local phys = self:GetPhysicsObject()

	if IsValid(phys) then
		phys:SetVelocityInstantaneous(Vector(0, 0, -75) + phys:GetVelocity() * 0.001)
		phys:AddAngleVelocity(phys:GetAngleVelocity() * -0.99)
	end
end

local SF_WEAPON_START_CONSTRAINED = 1

-- Picked up by player. Transfer of stored ammo and such.
function SWEP:EquipTTT(newowner)
	if engine.ActiveGamemode() ~= "terrortown" then return end

	if SERVER then
		if self:IsOnFire() then
			self:Extinguish()
		end

		self.fingerprints = self.fingerprints or {}

		if not table.HasValue(self.fingerprints, newowner) then
			table.insert(self.fingerprints, newowner)
		end

		if self:HasSpawnFlags(SF_WEAPON_START_CONSTRAINED) then
			-- If this weapon started constrained, unset that spawnflag, or the
			-- weapon will be re-constrained and float
			local flags = self:GetSpawnFlags()
			local newflags = bit.band(flags, bit.bnot(SF_WEAPON_START_CONSTRAINED))
			self:SetKeyValue("spawnflags", newflags)
		end
	end

	if not self.Ammo1 then return end

	if SERVER and IsValid(newowner) and self.StoredAmmo > 0 and self.Primary_TFA.Ammo ~= "none" then
		local ammo = newowner:GetAmmoCount(self.Primary_TFA.Ammo)
		self.Primary_TFA.ClipMax = self.Primary_TFA.ClipMax or (math.abs(self.Primary_TFA.ClipSize) * 4)
		local given = math.min(self.StoredAmmo, self.Primary_TFA.ClipMax - ammo)
		newowner:GiveAmmo(given, self.Primary_TFA.Ammo)
		self.StoredAmmo = 0
	end
end

-- We were bought as special equipment, some weapons will want to do something
-- extra for their buyer
function SWEP:WasBought(buyer)
end

function SWEP:DyingShot()
	local fired = false
	-- if self:GetIronSightsProgress() and self:GetIronSightsProgress() > 0.01  then
	self:SetIronSightsRaw(false)
	if self:GetNextPrimaryFire() > CurTime() then return fired end

	-- Owner should still be alive here
	if IsValid(self:GetOwner()) then
		local punch = self.Primary_TFA.Recoil or 5
		-- Punch view to disorient aim before firing dying shot
		local eyeang = self:GetOwner():EyeAngles()
		eyeang.pitch = eyeang.pitch - math.Rand(-punch, punch)
		eyeang.yaw = eyeang.yaw - math.Rand(-punch, punch)
		self:GetOwner():SetEyeAngles(eyeang)
		MsgN(self:GetOwner():Nick() .. " fired his DYING SHOT")
		self:GetOwner().dying_wep = self
		self:PrimaryAttack()
		fired = true
	end
	-- end

	return fired
end
--addons/tfa_base/lua/weapons/tfa_gun_base/common/viewmodel.lua:
local vector_origin = Vector()
local angle_zero = Angle()

SWEP.WeaponLength = 0

SWEP.NearWallVector = Vector(0.091287083923817, -0.4564354121685, -0.18257416784763)
SWEP.NearWallVectorADS = Vector(0, 0, 0)

SWEP.ViewModelPunchPitchMultiplier = 0.5
SWEP.ViewModelPunchPitchMultiplier_IronSights = 0.09

SWEP.ViewModelPunch_MaxVertialOffset = 3
SWEP.ViewModelPunch_MaxVertialOffset_IronSights = 1.95
SWEP.ViewModelPunch_VertialMultiplier = 1
SWEP.ViewModelPunch_VertialMultiplier_IronSights = 0.25

SWEP.ViewModelPunchYawMultiplier = 0.6
SWEP.ViewModelPunchYawMultiplier_IronSights = 0.25

local onevec = Vector(1, 1, 1)

local function RBP(vm)
	local bc = vm:GetBoneCount()
	if not bc or bc <= 0 then return end

	for i = 0, bc do
		vm:ManipulateBoneScale(i, onevec)
		vm:ManipulateBoneAngles(i, angle_zero)
		vm:ManipulateBonePosition(i, vector_origin)
	end
end

function SWEP:ApplyViewModelModifications()
	local self2 = self:GetTable()
	if not self2.VMIV(self) then return end

	local vm = self2.OwnerViewModel

	local bgcount = #(vm:GetBodyGroups() or {})
	local ViewModelBodygroups = self2.GetStatRawL(self, "ViewModelBodygroups")
	local bgt = ViewModelBodygroups or self2.Bodygroups or {}

	for i = 0, bgcount - 1 do
		vm:SetBodygroup(i, bgt[i] or 0)
	end

	local skinind = self2.GetStatL(self, "Skin")

	if skinind and isnumber(skinind) then
		vm:SetSkin(skinind)
		self:SetSkin(skinind)
	end

	self2.ClearMaterialCache(self)
end

function SWEP:ResetViewModelModifications()
	local self2 = self:GetTable()
	if not self2.VMIV(self) then return end

	local vm = self2.OwnerViewModel

	RBP(vm)

	vm:SetSkin(0)

	local matcount = #(vm:GetMaterials() or {})

	for i = 0, matcount do
		vm:SetSubMaterial(i, "")
	end

	for i = 0, #(vm:GetBodyGroups() or {}) - 1 do
		vm:SetBodygroup(i, 0)
	end
end

--lua/weapons/tfa_swsft_base/shared.lua:
DEFINE_BASECLASS("tfa_gun_base")
SWEP.TracerCount = 1
SWEP.MuzzleFlashEffect = ""
SWEP.TracerName = "effect_sw_laser_red"
SWEP.Secondary.IronFOV = 70
SWEP.Primary.KickUp = 0.2
SWEP.Primary.KickDown = 0.1
SWEP.Primary.KickHorizontal = 0.1
SWEP.Primary.KickRight = 0.1
SWEP.DisableChambering = true

SWEP.ImpactDecal = "FadingScorch"
SWEP.RunSightsPos = Vector(2.127, 0, 1.355)
SWEP.RunSightsAng = Vector(-15.775, 10.023, -5.664)
SWEP.BlowbackEnabled = true
SWEP.BlowbackVector = Vector(0, -3, 0.1)
SWEP.Blowback_Shell_Enabled = false
SWEP.Blowback_Shell_Effect = ""
SWEP.ThirdPersonReloadDisable = false
SWEP.Primary.DamageType = DMG_SHOCK
SWEP.DamageType = DMG_SHOCK

SWEP.ImpactEffect = "effect_sw_impact" --Impact Effect

function SWEP:DrawHands()
	self.UseHandsDefault = self.UseHandsDefault or self.UseHands
	if not self.UseHandsDefault then return end
	if not IsValid(self) or not self:OwnerIsValid() then return end
	local vm = self.OwnerViewModel
	if not IsValid(vm) then return end

	if not IsValid(self.Owner.SWHands) then
		self.Owner.SWHands = ClientsideModel("models/player/kylejwest/cgi3dphase1clone_c_arms/cgi3dphase1clone_c_arms.mdl")
		self.Owner.SWHands:SetParent(vm)
		self.Owner.SWHands:SetPos(self.Owner:GetShootPos())
		self.Owner.SWHands:SetAngles(self.Owner:EyeAngles())
		self.Owner.SWHands:AddEffects(EF_BONEMERGE)
		self.Owner.SWHands:SetNoDraw(true)
		self.Owner.SWHands.BoneMergedEnt = vm
	elseif self.Owner.SWHands:GetParent() ~= vm then
		self.Owner.SWHands:SetModel("models/player/kylejwest/cgi3dphase1clone_c_arms/cgi3dphase1clone_c_arms.mdl")
		self.Owner.SWHands:SetParent(vm)
		self.Owner.SWHands:SetPos(self.Owner:GetShootPos())
		self.Owner.SWHands:SetAngles(self.Owner:EyeAngles())
		self.Owner.SWHands:AddEffects(EF_BONEMERGE)
	elseif self.Owner.SWHands:GetModel() ~= "models/player/kylejwest/cgi3dphase1clone_c_arms/cgi3dphase1clone_c_arms.mdl" then
		self.Owner.SWHands:SetModel("models/player/kylejwest/cgi3dphase1clone_c_arms/cgi3dphase1clone_c_arms.mdl")
	end

	if self.Owner.SWHands then
		self.Owner.SWHands:DrawModel()
	end

	self.UseHands = false
end

--lua/weapons/tfa_swsft_base_servius/shared.lua:
DEFINE_BASECLASS("tfa_gun_base")

SWEP.TracerCount = 1
SWEP.MuzzleFlashEffect = ""
SWEP.TracerName = "effect_sw_laser_red"

SWEP.Secondary.IronFOV = 70
SWEP.Primary.KickUp = 0.2
SWEP.Primary.KickDown = 0.1
SWEP.Primary.KickHorizontal = 0.1
SWEP.Primary.KickRight = 0.1

SWEP.DisableChambering = true

SWEP.Callback = {}
SWEP.Callback.ChooseProceduralReloadAnim = function(self)
	if SERVER or (CLIENT and IsFirstTimePredicted() ) then
		self:EmitSound(self.Primary.ReloadSound or "")
	end
end
SWEP.Callback.ChooseReloadAnim = function(self)
	if SERVER or (CLIENT and IsFirstTimePredicted() ) then
		self:EmitSound(self.Primary.ReloadSound or "")
	end
end
SWEP.ImpactDecal = "FadingScorch"

SWEP.RunSightsPos = Vector(2.127, 0, 1.355)
SWEP.RunSightsAng = Vector(-15.775, 10.023, -5.664)

SWEP.BlowbackEnabled = true
SWEP.BlowbackVector = Vector(0,-3,0.1)
SWEP.Blowback_Shell_Enabled = false
SWEP.Blowback_Shell_Effect = ""
SWEP.ThirdPersonReloadDisable=false

SWEP.Primary.DamageType = DMG_SHOCK
SWEP.DamageType = DMG_SHOCK

SWEP.ImpactEffect = "effect_sw_impact" --Impact Effect

--[[
function SWEP:DrawHands()
	self.UseHandsDefault = self.UseHandsDefault or self.UseHands
	if !self.UseHandsDefault then return end
	if !IsValid(self) or !self:OwnerIsValid() then return end
	local vm = self.OwnerViewModel
	if !IsValid(vm) then return end
	
	if !self.Owner.SWHands then
		self.Owner.SWHands = ClientsideModel("models/player/KyleJWest/CGI3DPhase1Clone_c_arms/CGI3DPhase1Clone_c_arms.mdl")
		self.Owner.SWHands:SetParent(vm)
		self.Owner.SWHands:SetPos(self.Owner:GetShootPos())
		self.Owner.SWHands:SetAngles(self.Owner:EyeAngles())
		self.Owner.SWHands:AddEffects( EF_BONEMERGE )
		self.Owner.SWHands:SetNoDraw(true)
		self.Owner.SWHands.BoneMergedEnt = vm
	elseif self.Owner.SWHands.BoneMergedEnt != vm then
		self.Owner.SWHands:SetParent(vm)
		self.Owner.SWHands:SetPos(self.Owner:GetShootPos())
		self.Owner.SWHands:SetAngles(self.Owner:EyeAngles())
		self.Owner.SWHands:AddEffects( EF_BONEMERGE )	
	end
	
	if self.Owner.SWHands then
		self.Owner.SWHands:DrawModel()
	end
	
	self.UseHands = false
	
end--]]
--lua/weapons/weapon_chemlight_cyan/cl_init.lua:
include('shared.lua')

SWEP.Slot			= 4; 
SWEP.SlotPos		= 8; 
SWEP.Spawnable		= true
SWEP.AdminSpawnable	= true
SWEP.WepSelectIcon	= surface.GetTextureID( "vgui/entities/glowstick2" )
--lua/weapons/weapon_chemlight_cyan/shared.lua:
if ( CLIENT ) then
	language.Add ("ent_chemlight", "Chemlight")
	language.Add ("glowsticks_ammo", "Glow Sticks")
	language.Add ("cleanup_glowsticks", "Chemlight")
	language.Add ("cleaned_glowsticks", "Chemlight is gone!")
  	SWEP.DrawAmmo			= true
	SWEP.DrawCrosshair		= true
	SWEP.ViewModelFOV		= 67
	SWEP.ViewModelFlip		= false
	SWEP.CSMuzzleFlashes	= false
	SWEP.HoldType			= "slam"	
	SWEP.PrintName			= "Chemlight Cyan"
	SWEP.Author				= "Patrick Hunt"
end
SWEP.IronSightsPos  = Vector(0, -16, -56)
SWEP.IronSightsAng  = Vector(0, 0, 0)

function SWEP:GetViewModelPosition(EyePos, EyeAng)
	local Mul = 1.0

	local Offset = self.IronSightsPos

	if (self.IronSightsAng) then
        EyeAng = EyeAng * 1
        
		EyeAng:RotateAroundAxis(EyeAng:Right(), 	self.IronSightsAng.x * Mul)
		EyeAng:RotateAroundAxis(EyeAng:Up(), 		self.IronSightsAng.y * Mul)
		EyeAng:RotateAroundAxis(EyeAng:Forward(),   self.IronSightsAng.z * Mul)
	end

	local Right 	= EyeAng:Right()
	local Up 		= EyeAng:Up()
	local Forward 	= EyeAng:Forward()

	EyePos = EyePos + Offset.x * Right * Mul
	EyePos = EyePos + Offset.y * Forward * Mul
	EyePos = EyePos + Offset.z * Up * Mul
	
	return EyePos, EyeAng
end

SWEP.Author					= "Patrick Hunt"
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions			= "Use primary attack to throw a glowstick and secondary to drop."
SWEP.HoldType				= "slam"
SWEP.Category				= "Chemlight"

SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true

--SWEP.ViewModel				= "models/weapons/c_glowstick.mdl"
--SWEP.WorldModel				= "models/glowstick/glowstick.mdl"
SWEP.UseHands				= true
SWEP.BounceWeaponIcon		= false
SWEP.DrawWeaponInfoBox		= false

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= 5
SWEP.Primary.Automatic		= false
SWEP.Primary.Ammo			= "glowsticks"
SWEP.Primary.Delay			= 1

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= false
SWEP.Secondary.Ammo			= "none"
SWEP.Secondary.Delay		= 1


function SWEP:Initialize()
	util.PrecacheSound("glowstick/glowstick_snap.wav");
	util.PrecacheSound("glowstick/glowstick_shake.wav");
	self:SetWeaponHoldType( self.HoldType )
	
if GetGlobalBool( "global_Cheml_oldmodel" ) then 
self.ViewModel				= "models/weapons/c_chemstick_antic.mdl"
self.WorldModel				= "models/glowstick/chemstick_antic.mdl"
elseif GetGlobalBool( "global_Cheml_oldmodel" ) == false then
self.ViewModel				= "models/weapons/c_chemstick.mdl" 
self.WorldModel				= "models/glowstick/chemstick.mdl"
end

end

function SWEP:Think()
	if self.Owner:IsBot() then self:SetColor(Color(0,255,255,255)) else -- Bots create a shipload of errors since they don't have any client vars on them so let's set them all green (or i'm just stupid)
	self:SetColor(Color(0, 255, 255, 255)) -- Paints world model in real time
	if IsValid(self.Owner) then
		if CLIENT then
		local dlight = DynamicLight(self:EntIndex()+66, true)
			if dlight then
				dlight.pos = self.Owner:EyePos() - (self.Owner:GetAimVector() * 16)
				dlight.r = 0
				dlight.g = 255
				dlight.b = 255
				dlight.brightness = 6
				dlight.Decay = 1
				dlight.Size = 64
				--dlight.DieTime = CurTime() + 10
				
			end
		end
	end
	end
end


function SWEP:Deploy()
	self:SetColor(Color(0,255,255,255))
	if !self.Owner:IsBot() then
	self.Weapon:SendWeaponAnim(ACT_VM_DRAW);
	self.Weapon:SetNextPrimaryFire(CurTime() + 0.55)
	self.Weapon:SetNextSecondaryFire(CurTime() + 0.55)
	timer.Remove( "weapon_chemlight_cyan"..self.Owner:EntIndex() )
	timer.Create( "weapon_chemlight_cyan"..self.Owner:EntIndex(), 1.5, 1, function() self.Weapon:SendWeaponAnim( ACT_VM_IDLE ) end ) end
	if SERVER then
	
	-------------------------------------------------
	
			local matrix = self.Owner:GetBoneMatrix(1)
			local chempos = matrix:GetTranslation()

	local worldmodel = ents.FindInSphere(chempos,15)
	for k, v in pairs(worldmodel) do 
		if v:GetClass() == "ent_chemlight_glow_cyan" and v:GetOwner() == self.Owner and SERVER then
			v:Remove()
	end
	end
	
	-------------------------------------------------

	local glow = ents.Create("ent_chemlight_glow_cyan")
		glow:SetOwner(self.Owner) 
		glow:FollowBone( self.Owner, 1 )
		glow:SetLocalPos(Vector(0,0,0))
		if self.Owner:IsBot() then self:SetColor(Color(0,255,255,255)) else
		glow:SetColor(Color(0, 255, 255, 255))
		end
		//glow:SetMaterial(self.Owner:GetMaterial())
		glow:Spawn()
		self.chemlightindex = glow:EntIndex()
	end
   return true
end



local cooldown = 0.5
local cooldown2 = 2
local lastReloadTime=0;
function SWEP:Reload()
if self.Owner:GetNW2Int( "chemlnavareloadtogglevar" ) == 0 then
if ((CurTime()-lastReloadTime)>cooldown) and SERVER then
		if (self.Owner:GetNW2Bool( "chemlightattachmentusage", false ) != true) then --create if there is no 
		if GetGlobalBool( "global_Cheml_Ammo", 1 ) == true then
		if ( self.Weapon:Ammo1() <= 0 ) then return end
		self:TakePrimaryAmmo(1)
		end
			timer.Simple( 0.6, function()
			local glow = ents.Create("ent_chemlight_for_attachment")
			glow:SetOwner(self.Owner)
			glow:SetModelScale( 0.01, 0 )
			glow:FollowBone( self.Owner, 3 )
			glow:SetLocalPos(Vector(10,10,3))
			glow:SetLocalAngles(Angle(-15,180,0))
			glow:SetNotSolid( true )
			if self.Owner:IsBot() then self:SetColor(Color(255,255,255,255)) else
			self.Owner:SetNW2Int( "chemlightattachmenRGB_R", 0 )
			self.Owner:SetNW2Int( "chemlightattachmenRGB_G", 255 )
			self.Owner:SetNW2Int( "chemlightattachmenRGB_B", 255 )
			glow:SetColor(Color(self.Owner:GetNW2Int( "chemlightattachmenRGB_R", 0 ),self.Owner:GetNW2Int( "chemlightattachmenRGB_G", 0 ) ,self.Owner:GetNW2Int( "chemlightattachmenRGB_B", 0 ) , 255))
			glow:SetMaterial("Models/effects/vol_light001")
			glow:DrawShadow( false )
			end			
			glow:Spawn()
			--glow:SetNoDraw(true)

			self.Owner:SetNW2Int( "chemlightattachmentindex", glow:EntIndex() )
			sound.Play( "glowstick/carbiner.wav", glow:GetPos(), 75, math.random( 90, 110 ), math.Clamp( 0.5, 0.2, 0.7 ) )
			end )
			timer.Remove( "weapon_chemlight_cyan"..self.Owner:EntIndex() )
			self.Weapon:SendWeaponAnim(ACT_VM_RELOAD);
			timer.Create( "reloadtimer"..self.Owner:EntIndex(), 1.5, 1, function() 
				if self.Owner:GetActiveWeapon():GetClass() == self.Weapon:GetClass()  then
				self.Weapon:SendWeaponAnim(ACT_VM_DRAW)
				end
			 end )
			timer.Create( "weapon_chemlight_cyan"..self.Owner:EntIndex(), 3, 1, function() 
				if self.Owner:GetActiveWeapon():GetClass() == self.Weapon:GetClass()  then
				self.Weapon:SendWeaponAnim(ACT_VM_IDLE)
				end
			 end )
			self.Weapon:SetNextPrimaryFire(CurTime() + 3)
			self.Weapon:SetNextSecondaryFire(CurTime() + 3)
			timer.Simple( 0.6, function() self.Owner:SetNW2Bool( "chemlightattachmentusage", true ) end)
			if GetGlobalBool( "global_Cheml_Inf", 0 ) == false then
			local lifetime = GetGlobalFloat( "global_Cheml_Lifetime", 25 ) + 15
			timer.Create( "deadlight"..self.Owner:EntIndex(), lifetime , 1 , function() if self.Owner:Alive() then self.Owner:SetNW2Bool( "chemlightattachmentusage", false ) end end )
			end
			else --remove the hell out of it
			if self.Owner:GetNW2Int( "chemlightattachmentindex", 0 ) != 0 and Entity(self.Owner:GetNW2Int( "chemlightattachmentindex", 0 )):IsValid() then
			sound.Play( "glowstick/carbiner.wav", self.Owner:GetPos(), 75, math.random( 90, 110 ), math.Clamp( 0.5, 0.2, 0.7 ) )
			Entity(self.Owner:GetNW2Int( "chemlightattachmentindex", 0 )):Remove()
			self.Owner:SetNW2Bool( "chemlightattachmentusage", false )
			end
		end
	lastReloadTime=CurTime()
end
	
	return true
	else
--
if ((CurTime()-lastReloadTime)>cooldown2) and SERVER then
	if GetGlobalBool( "global_Cheml_Ammo", 1 ) == true then
	if ( self.Weapon:Ammo1() <= 0 ) then return end
	self:TakePrimaryAmmo(1)
	end

timer.Create( "reloadtimer1"..self.Owner:EntIndex(), 0.8, 1, function()		
	if self.Owner:GetActiveWeapon():GetClass() == self.Weapon:GetClass() and self.Owner:IsValid() then
	self.Owner:SetColor(Color( 0, 255, 255, 255))
	self.Owner:SetNW2Bool( "chemlightplayercolored", true )
	local minushels = math.random(7,13)
	if self.Owner:Health() > minushels then self.Owner:SetHealth(self.Owner:Health()-minushels) else self.Owner:Kill() end
	self.Owner:ScreenFade( SCREENFADE.IN, Color( 0, 255, 255, 100), 0.5, 0 )
	end 
end)
timer.Create( "reloadtimer2"..self.Owner:EntIndex(), 0.4, 1, function()		
	if self.Owner:GetActiveWeapon():GetClass() == self.Weapon:GetClass() and self.Owner:IsValid() then
	sound.Play( "glowstick/glowstick_nom.wav", self.Owner:GetPos() )
	end 
end)
timer.Remove( "weapon_chemlight_cyan"..self.Owner:EntIndex() )
self.Weapon:SendWeaponAnim(ACT_VM_PULLPIN);
			timer.Create( "reloadtimer"..self.Owner:EntIndex(), 1.5, 1, function() 
				if self.Owner:GetActiveWeapon():GetClass() == self.Weapon:GetClass() and self.Owner:IsValid() then
				self.Weapon:SendWeaponAnim(ACT_VM_DRAW)
				end 
			end)
			timer.Create( "weapon_chemlight_cyan"..self.Owner:EntIndex(), 3, 1, function() 
				if self.Owner:GetActiveWeapon():GetClass() == self.Weapon:GetClass() and self.Owner:IsValid()  then
				self.Weapon:SendWeaponAnim(ACT_VM_IDLE)
				end
			end) 
			timer.Create( "uncolorchemlighttimer"..self.Owner:EntIndex(), 15, 1, function() 
				self.Owner:SetColor(Color(255,255,255,255))
				self.Owner:SetNW2Bool( "chemlightplayercolored", false )
			end)
			self.Weapon:SetNextPrimaryFire(CurTime() + 3)
			self.Weapon:SetNextSecondaryFire(CurTime() + 3)
			lastReloadTime=CurTime()
end
--
end
end



function SWEP:SecondaryAttack()
if GetGlobalBool( "global_Cheml_Ammo", 1 ) == true then
if ( self.Weapon:Ammo1() <= 0 ) then return end
self:TakePrimaryAmmo(1)
end
timer.Remove( "weapon_chemlight_cyan"..self.Owner:EntIndex() )
	self.Weapon:SendWeaponAnim( ACT_VM_SECONDARYATTACK )
	self.Weapon:SetNextSecondaryFire(CurTime() + self.Secondary.Delay)
	self.Weapon:SetNextPrimaryFire(CurTime() + self.Primary.Delay)
		timer.Simple(0.5, function()
		timer.Create( "weapon_chemlight_cyan"..self.Owner:EntIndex(), 2, 1, function() self.Weapon:SendWeaponAnim( ACT_VM_IDLE ) end )
		self.Owner:SetAnimation( PLAYER_ATTACK1 )
			if SERVER then
					local ent = ents.Create("ent_chemlight")
					ent:SetPos(self.Owner:EyePos() + (self.Owner:GetAimVector() * 4))
					ent:SetAngles(self.Owner:EyeAngles())
					if self.Owner:IsBot() then ent:SetColor(Color(0,255,255,255)) else
					ent:SetColor( Color( 0, 255, 255, 255) )
					end
					ent:Spawn()
					ent:Activate()
					self.Owner:AddCleanup( "glowsticks", ent)
				local phys = ent:GetPhysicsObject()
				phys:SetVelocity(self.Owner:GetVelocity() + self.Owner:GetAimVector() * 125 * GetGlobalFloat("global_Cheml_throwstrength", 1))
				phys:AddAngleVelocity(Vector(math.random(-1000,1000),math.random(-1000,1000),math.random(-1000,1000)))
			end
		end)
		timer.Simple(1, function()
		if self.Owner:GetActiveWeapon():GetClass() == self.Weapon:GetClass()  then
		self.Weapon:SendWeaponAnim(ACT_VM_DRAW)
		end
		end)
end

function SWEP:PrimaryAttack()
if GetGlobalBool( "global_Cheml_Ammo", 1 ) == true then
if ( self.Weapon:Ammo1() <= 0 ) then return end
self:TakePrimaryAmmo(1)
end
timer.Remove( "weapon_chemlight_cyan"..self.Owner:EntIndex() )
	self.Weapon:SendWeaponAnim( ACT_VM_THROW )
	self.Weapon:SetNextSecondaryFire(CurTime() + self.Secondary.Delay)
	self.Weapon:SetNextPrimaryFire(CurTime() + self.Primary.Delay)
		timer.Simple(0.5, function()
		timer.Create( "weapon_chemlight_cyan"..self.Owner:EntIndex(), 2, 1, function() self.Weapon:SendWeaponAnim( ACT_VM_IDLE ) end )
		self.Owner:SetAnimation( PLAYER_ATTACK1 )
			if SERVER then
					local ent = ents.Create("ent_chemlight")
					ent:SetPos(self.Owner:EyePos() + (self.Owner:GetAimVector() * 4))
					ent:SetAngles(self.Owner:EyeAngles())
					if self.Owner:IsBot() then ent:SetColor(Color(0,255,255,255)) else
					ent:SetColor( Color( 0, 255, 2555, 255) )
					end
					ent:Spawn()
					ent:Activate()
					self.Owner:AddCleanup( "glowsticks", ent)
				local phys = ent:GetPhysicsObject()
				phys:SetVelocity(self.Owner:GetVelocity() + self.Owner:GetAimVector() * 400 * GetGlobalFloat("global_Cheml_throwstrength", 1))
				phys:AddAngleVelocity(Vector(math.random(-1000,1000),math.random(-1000,1000),math.random(-1000,1000)))
			end
		end)
		timer.Simple(1, function()
		if self.Owner:GetActiveWeapon():GetClass() == self.Weapon:GetClass()  then
		self.Weapon:SendWeaponAnim(ACT_VM_DRAW)
		end
		end)
end

function SWEP:PreDrawViewModel( vm )
	if self.Owner:IsBot() then return end
	Material("models/glowstick/glow"):SetVector("$color2", Vector(0, 255, 255) )
end

function SWEP:PostDrawViewModel( vm )
	if self.Owner:IsBot() then return end
	Material("models/glowstick/glow"):SetVector("$color2", Vector(1, 1, 1) )
end

function SWEP:Holster()
	timer.Remove( "weapon_chemlight_cyan"..self.Owner:EntIndex() )
--			local matrix = self.Owner:GetBoneMatrix(1)
--			local chempos = matrix:GetTranslation()
--			local chempos2 = self.Owner:EyePos() - chempos	
--	local worldmodel = ents.FindInSphere(chempos,0.6) -- + Vector(0,0,chempos2.z),0.6)
--	for k, v in pairs(worldmodel) do 
--		if v:GetClass() == "ent_chemlight_glow_cyan" and v:GetOwner() == self.Owner and SERVER then
--			v:Remove()
		if SERVER then
		if self.chemlightindex == 0 then print("ашипка") return end 
		if ents.GetByIndex( self.chemlightindex):IsValid() then
		ents.GetByIndex( self.chemlightindex):Remove()
		end
		end
--	end
return true
end

function SWEP:OnRemove()
	return true
end




--lua/weapons/weapon_chemlight_purple/shared.lua:
if ( CLIENT ) then
	language.Add ("ent_chemlight", "Chemlight")
	language.Add ("glowsticks_ammo", "Glow Sticks")
	language.Add ("cleanup_glowsticks", "Chemlight")
	language.Add ("cleaned_glowsticks", "Chemlight is gone!")
  	SWEP.DrawAmmo			= true
	SWEP.DrawCrosshair		= true
	SWEP.ViewModelFOV		= 67
	SWEP.ViewModelFlip		= false
	SWEP.CSMuzzleFlashes	= false
	SWEP.HoldType			= "slam"	
	SWEP.PrintName			= "Chemlight Purple"
	SWEP.Author				= "Patrick Hunt"
end
SWEP.IronSightsPos  = Vector(0, -16, -56)
SWEP.IronSightsAng  = Vector(0, 0, 0)

function SWEP:GetViewModelPosition(EyePos, EyeAng)
	local Mul = 1.0

	local Offset = self.IronSightsPos

	if (self.IronSightsAng) then
        EyeAng = EyeAng * 1
        
		EyeAng:RotateAroundAxis(EyeAng:Right(), 	self.IronSightsAng.x * Mul)
		EyeAng:RotateAroundAxis(EyeAng:Up(), 		self.IronSightsAng.y * Mul)
		EyeAng:RotateAroundAxis(EyeAng:Forward(),   self.IronSightsAng.z * Mul)
	end

	local Right 	= EyeAng:Right()
	local Up 		= EyeAng:Up()
	local Forward 	= EyeAng:Forward()

	EyePos = EyePos + Offset.x * Right * Mul
	EyePos = EyePos + Offset.y * Forward * Mul
	EyePos = EyePos + Offset.z * Up * Mul
	
	return EyePos, EyeAng
end

SWEP.Author					= "Patrick Hunt"
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions			= "Use primary attack to throw a glowstick and secondary to drop."
SWEP.HoldType				= "slam"
SWEP.Category				= "Chemlight"

SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true

--SWEP.ViewModel				= "models/weapons/c_glowstick.mdl"
--SWEP.WorldModel				= "models/glowstick/glowstick.mdl"
SWEP.UseHands				= true
SWEP.BounceWeaponIcon		= false
SWEP.DrawWeaponInfoBox		= false

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= 5
SWEP.Primary.Automatic		= false
SWEP.Primary.Ammo			= "glowsticks"
SWEP.Primary.Delay			= 1

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= false
SWEP.Secondary.Ammo			= "none"
SWEP.Secondary.Delay		= 1


function SWEP:Initialize()
	util.PrecacheSound("glowstick/glowstick_snap.wav");
	util.PrecacheSound("glowstick/glowstick_shake.wav");
	self:SetWeaponHoldType( self.HoldType )
	
if GetGlobalBool( "global_Cheml_oldmodel" ) then 
self.ViewModel				= "models/weapons/c_chemstick_antic.mdl"
self.WorldModel				= "models/glowstick/chemstick_antic.mdl"
elseif GetGlobalBool( "global_Cheml_oldmodel" ) == false then
self.ViewModel				= "models/weapons/c_chemstick.mdl" 
self.WorldModel				= "models/glowstick/chemstick.mdl"
end

end

function SWEP:Think()
	if self.Owner:IsBot() then self:SetColor(Color(255,0,255,255)) else -- Bots create a shipload of errors since they don't have any client vars on them so let's set them all green (or i'm just stupid)
	self:SetColor(Color(255, 0, 255, 255)) -- Paints world model in real time
	if IsValid(self.Owner) then
		if CLIENT then
		local dlight = DynamicLight(self:EntIndex()+66, true)
			if dlight then
				dlight.pos = self.Owner:EyePos() - (self.Owner:GetAimVector() * 16)
				dlight.r = 255
				dlight.g = 0
				dlight.b = 255
				dlight.brightness = 6
				dlight.Decay = 1
				dlight.Size = 64
				--dlight.DieTime = CurTime() + 10
				
			end
		end
	end
	end
end


function SWEP:Deploy()
	self:SetColor(Color(255,0,255,255))
	if !self.Owner:IsBot() then
	self.Weapon:SendWeaponAnim(ACT_VM_DRAW);
	self.Weapon:SetNextPrimaryFire(CurTime() + 0.55)
	self.Weapon:SetNextSecondaryFire(CurTime() + 0.55)
	timer.Remove( "weapon_chemlight_purple"..self.Owner:EntIndex() )
	timer.Create( "weapon_chemlight_purple"..self.Owner:EntIndex(), 1.5, 1, function() self.Weapon:SendWeaponAnim( ACT_VM_IDLE ) end ) end
	if SERVER then
	
	-------------------------------------------------
	
			local matrix = self.Owner:GetBoneMatrix(1)
			local chempos = matrix:GetTranslation()

	local worldmodel = ents.FindInSphere(chempos,15)
	for k, v in pairs(worldmodel) do 
		if v:GetClass() == "ent_chemlight_glow_purple" and v:GetOwner() == self.Owner and SERVER then
			v:Remove()
	end
	end
	
	-------------------------------------------------

	local glow = ents.Create("ent_chemlight_glow_purple")
		glow:SetOwner(self.Owner) 
		glow:FollowBone( self.Owner, 1 )
		glow:SetLocalPos(Vector(0,0,0))
		if self.Owner:IsBot() then self:SetColor(Color(255,0,255,255)) else
		glow:SetColor(Color(255, 0, 255, 255))
		end
		//glow:SetMaterial(self.Owner:GetMaterial())
		glow:Spawn()
		self.chemlightindex = glow:EntIndex()
	end
   return true
end



local cooldown = 0.5
local cooldown2 = 2
local lastReloadTime=0;
function SWEP:Reload()
if self.Owner:GetNW2Int( "chemlnavareloadtogglevar" ) == 0 then
if ((CurTime()-lastReloadTime)>cooldown) and SERVER then
		if (self.Owner:GetNW2Bool( "chemlightattachmentusage", false ) != true) then --create if there is no 
		if GetGlobalBool( "global_Cheml_Ammo", 1 ) == true then
		if ( self.Weapon:Ammo1() <= 0 ) then return end
		self:TakePrimaryAmmo(1)
		end
			timer.Simple( 0.6, function()
			local glow = ents.Create("ent_chemlight_for_attachment")
			glow:SetOwner(self.Owner)
			glow:SetModelScale( 0.01, 0 )
			glow:FollowBone( self.Owner, 3 )
			glow:SetLocalPos(Vector(10,10,3))
			glow:SetLocalAngles(Angle(-15,180,0))
			glow:SetNotSolid( true )
			if self.Owner:IsBot() then self:SetColor(Color(255,255,255,255)) else
			self.Owner:SetNW2Int( "chemlightattachmenRGB_R", 255 )
			self.Owner:SetNW2Int( "chemlightattachmenRGB_G", 0 )
			self.Owner:SetNW2Int( "chemlightattachmenRGB_B", 255 )
			glow:SetColor(Color(self.Owner:GetNW2Int( "chemlightattachmenRGB_R", 0 ),self.Owner:GetNW2Int( "chemlightattachmenRGB_G", 0 ) ,self.Owner:GetNW2Int( "chemlightattachmenRGB_B", 0 ) , 255))
			glow:SetMaterial("Models/effects/vol_light001")
			glow:DrawShadow( false )
			end			
			glow:Spawn()
			--glow:SetNoDraw(true)

			self.Owner:SetNW2Int( "chemlightattachmentindex", glow:EntIndex() )
			sound.Play( "glowstick/carbiner.wav", glow:GetPos(), 75, math.random( 90, 110 ), math.Clamp( 0.5, 0.2, 0.7 ) )
			end )
			timer.Remove( "weapon_chemlight_purple"..self.Owner:EntIndex() )
			self.Weapon:SendWeaponAnim(ACT_VM_RELOAD);
			timer.Create( "reloadtimer"..self.Owner:EntIndex(), 1.5, 1, function() 
				if self.Owner:GetActiveWeapon():GetClass() == self.Weapon:GetClass()  then
				self.Weapon:SendWeaponAnim(ACT_VM_DRAW)
				end
			 end )
			timer.Create( "weapon_chemlight_purple"..self.Owner:EntIndex(), 3, 1, function() 
				if self.Owner:GetActiveWeapon():GetClass() == self.Weapon:GetClass()  then
				self.Weapon:SendWeaponAnim(ACT_VM_IDLE)
				end
			 end )
			self.Weapon:SetNextPrimaryFire(CurTime() + 3)
			self.Weapon:SetNextSecondaryFire(CurTime() + 3)
			timer.Simple( 0.6, function() self.Owner:SetNW2Bool( "chemlightattachmentusage", true ) end)
			if GetGlobalBool( "global_Cheml_Inf", 0 ) == false then
			local lifetime = GetGlobalFloat( "global_Cheml_Lifetime", 25 ) + 15
			timer.Create( "deadlight"..self.Owner:EntIndex(), lifetime , 1 , function() if self.Owner:Alive() then self.Owner:SetNW2Bool( "chemlightattachmentusage", false ) end end )
			end
			else --remove the hell out of it
			if self.Owner:GetNW2Int( "chemlightattachmentindex", 0 ) != 0 and Entity(self.Owner:GetNW2Int( "chemlightattachmentindex", 0 )):IsValid() then
			sound.Play( "glowstick/carbiner.wav", self.Owner:GetPos(), 75, math.random( 90, 110 ), math.Clamp( 0.5, 0.2, 0.7 ) )
			Entity(self.Owner:GetNW2Int( "chemlightattachmentindex", 0 )):Remove()
			self.Owner:SetNW2Bool( "chemlightattachmentusage", false )
			end
		end
	lastReloadTime=CurTime()
end
	
	return true
	else
--
if ((CurTime()-lastReloadTime)>cooldown2) and SERVER then
	if GetGlobalBool( "global_Cheml_Ammo", 1 ) == true then
	if ( self.Weapon:Ammo1() <= 0 ) then return end
	self:TakePrimaryAmmo(1)
	end

timer.Create( "reloadtimer1"..self.Owner:EntIndex(), 0.8, 1, function()		
	if self.Owner:GetActiveWeapon():GetClass() == self.Weapon:GetClass() and self.Owner:IsValid() then
	self.Owner:SetColor(Color( 255, 0, 255, 255))
	self.Owner:SetNW2Bool( "chemlightplayercolored", true )
	local minushels = math.random(7,13)
	if self.Owner:Health() > minushels then self.Owner:SetHealth(self.Owner:Health()-minushels) else self.Owner:Kill() end
	self.Owner:ScreenFade( SCREENFADE.IN, Color( 255, 0, 255, 100), 0.5, 0 )
	end 
end)
timer.Create( "reloadtimer2"..self.Owner:EntIndex(), 0.4, 1, function()		
	if self.Owner:GetActiveWeapon():GetClass() == self.Weapon:GetClass() and self.Owner:IsValid() then
	sound.Play( "glowstick/glowstick_nom.wav", self.Owner:GetPos() )
	end 
end)
timer.Remove( "weapon_chemlight_purple"..self.Owner:EntIndex() )
self.Weapon:SendWeaponAnim(ACT_VM_PULLPIN);
			timer.Create( "reloadtimer"..self.Owner:EntIndex(), 1.5, 1, function() 
				if self.Owner:GetActiveWeapon():GetClass() == self.Weapon:GetClass() and self.Owner:IsValid() then
				self.Weapon:SendWeaponAnim(ACT_VM_DRAW)
				end 
			end)
			timer.Create( "weapon_chemlight_purple"..self.Owner:EntIndex(), 3, 1, function() 
				if self.Owner:GetActiveWeapon():GetClass() == self.Weapon:GetClass() and self.Owner:IsValid()  then
				self.Weapon:SendWeaponAnim(ACT_VM_IDLE)
				end
			end) 
			timer.Create( "uncolorchemlighttimer"..self.Owner:EntIndex(), 15, 1, function() 
				self.Owner:SetColor(Color(255,255,255,255))
				self.Owner:SetNW2Bool( "chemlightplayercolored", false )
			end)
			self.Weapon:SetNextPrimaryFire(CurTime() + 3)
			self.Weapon:SetNextSecondaryFire(CurTime() + 3)
			lastReloadTime=CurTime()
end
--
end
end



function SWEP:SecondaryAttack()
if GetGlobalBool( "global_Cheml_Ammo", 1 ) == true then
if ( self.Weapon:Ammo1() <= 0 ) then return end
self:TakePrimaryAmmo(1)
end
timer.Remove( "weapon_chemlight_purple"..self.Owner:EntIndex() )
	self.Weapon:SendWeaponAnim( ACT_VM_SECONDARYATTACK )
	self.Weapon:SetNextSecondaryFire(CurTime() + self.Secondary.Delay)
	self.Weapon:SetNextPrimaryFire(CurTime() + self.Primary.Delay)
		timer.Simple(0.5, function()
		timer.Create( "weapon_chemlight_purple"..self.Owner:EntIndex(), 2, 1, function() self.Weapon:SendWeaponAnim( ACT_VM_IDLE ) end )
		self.Owner:SetAnimation( PLAYER_ATTACK1 )
			if SERVER then
					local ent = ents.Create("ent_chemlight")
					ent:SetPos(self.Owner:EyePos() + (self.Owner:GetAimVector() * 4))
					ent:SetAngles(self.Owner:EyeAngles())
					if self.Owner:IsBot() then ent:SetColor(Color(255,0,255,255)) else
					ent:SetColor( Color( 255, 0, 255, 255) )
					end
					ent:Spawn()
					ent:Activate()
					self.Owner:AddCleanup( "glowsticks", ent)
				local phys = ent:GetPhysicsObject()
				phys:SetVelocity(self.Owner:GetVelocity() + self.Owner:GetAimVector() * 125 * GetGlobalFloat("global_Cheml_throwstrength", 1))
				phys:AddAngleVelocity(Vector(math.random(-1000,1000),math.random(-1000,1000),math.random(-1000,1000)))
			end
		end)
		timer.Simple(1, function()
		if self.Owner:GetActiveWeapon():GetClass() == self.Weapon:GetClass()  then
		self.Weapon:SendWeaponAnim(ACT_VM_DRAW)
		end
		end)
end

function SWEP:PrimaryAttack()
if GetGlobalBool( "global_Cheml_Ammo", 1 ) == true then
if ( self.Weapon:Ammo1() <= 0 ) then return end
self:TakePrimaryAmmo(1)
end
timer.Remove( "weapon_chemlight_purple"..self.Owner:EntIndex() )
	self.Weapon:SendWeaponAnim( ACT_VM_THROW )
	self.Weapon:SetNextSecondaryFire(CurTime() + self.Secondary.Delay)
	self.Weapon:SetNextPrimaryFire(CurTime() + self.Primary.Delay)
		timer.Simple(0.5, function()
		timer.Create( "weapon_chemlight_purple"..self.Owner:EntIndex(), 2, 1, function() self.Weapon:SendWeaponAnim( ACT_VM_IDLE ) end )
		self.Owner:SetAnimation( PLAYER_ATTACK1 )
			if SERVER then
					local ent = ents.Create("ent_chemlight")
					ent:SetPos(self.Owner:EyePos() + (self.Owner:GetAimVector() * 4))
					ent:SetAngles(self.Owner:EyeAngles())
					if self.Owner:IsBot() then ent:SetColor(Color(255,0,255,255)) else
					ent:SetColor( Color( 255, 0, 2555, 255) )
					end
					ent:Spawn()
					ent:Activate()
					self.Owner:AddCleanup( "glowsticks", ent)
				local phys = ent:GetPhysicsObject()
				phys:SetVelocity(self.Owner:GetVelocity() + self.Owner:GetAimVector() * 400 * GetGlobalFloat("global_Cheml_throwstrength", 1))
				phys:AddAngleVelocity(Vector(math.random(-1000,1000),math.random(-1000,1000),math.random(-1000,1000)))
			end
		end)
		timer.Simple(1, function()
		if self.Owner:GetActiveWeapon():GetClass() == self.Weapon:GetClass()  then
		self.Weapon:SendWeaponAnim(ACT_VM_DRAW)
		end
		end)
end

function SWEP:PreDrawViewModel( vm )
	if self.Owner:IsBot() then return end
	Material("models/glowstick/glow"):SetVector("$color2", Vector(255, 0, 255) )
end

function SWEP:PostDrawViewModel( vm )
	if self.Owner:IsBot() then return end
	Material("models/glowstick/glow"):SetVector("$color2", Vector(1, 1, 1) )
end

function SWEP:Holster()
	timer.Remove( "weapon_chemlight_purple"..self.Owner:EntIndex() )
--			local matrix = self.Owner:GetBoneMatrix(1)
--			local chempos = matrix:GetTranslation()
--			local chempos2 = self.Owner:EyePos() - chempos	
--	local worldmodel = ents.FindInSphere(chempos + Vector(0,0,chempos2.z),0.6)
--	for k, v in pairs(worldmodel) do 
--		if v:GetClass() == "ent_chemlight_glow_purple" and v:GetOwner() == self.Owner and SERVER then
--			v:Remove()
		if SERVER then
		if self.chemlightindex == 0 then print("ашипка") return end 
		if ents.GetByIndex( self.chemlightindex):IsValid() then
		ents.GetByIndex( self.chemlightindex):Remove()
		end
		end
--		end
--	end
return true
end

function SWEP:OnRemove()
	return true
end
--lua/weapons/weapon_chemlight_red/cl_init.lua:
include('shared.lua')

SWEP.Slot			= 4; 
SWEP.SlotPos		= 8; 
SWEP.Spawnable		= true
SWEP.AdminSpawnable	= true
SWEP.WepSelectIcon	= surface.GetTextureID( "vgui/entities/glowstick2" )
--lua/weapons/weapon_chemlight_yellow/shared.lua:
if ( CLIENT ) then
	language.Add ("ent_chemlight", "Chemlight")
	language.Add ("glowsticks_ammo", "Glow Sticks")
	language.Add ("cleanup_glowsticks", "Chemlight")
	language.Add ("cleaned_glowsticks", "Chemlight is gone!")
  	SWEP.DrawAmmo			= true
	SWEP.DrawCrosshair		= true
	SWEP.ViewModelFOV		= 67
	SWEP.ViewModelFlip		= false
	SWEP.CSMuzzleFlashes	= false
	SWEP.HoldType			= "slam"	
	SWEP.PrintName			= "Chemlight Yellow"
	SWEP.Author				= "Patrick Hunt"
end
SWEP.IronSightsPos  = Vector(0, -16, -56)
SWEP.IronSightsAng  = Vector(0, 0, 0)

function SWEP:GetViewModelPosition(EyePos, EyeAng)
	local Mul = 1.0

	local Offset = self.IronSightsPos

	if (self.IronSightsAng) then
        EyeAng = EyeAng * 1
        
		EyeAng:RotateAroundAxis(EyeAng:Right(), 	self.IronSightsAng.x * Mul)
		EyeAng:RotateAroundAxis(EyeAng:Up(), 		self.IronSightsAng.y * Mul)
		EyeAng:RotateAroundAxis(EyeAng:Forward(),   self.IronSightsAng.z * Mul)
	end

	local Right 	= EyeAng:Right()
	local Up 		= EyeAng:Up()
	local Forward 	= EyeAng:Forward()

	EyePos = EyePos + Offset.x * Right * Mul
	EyePos = EyePos + Offset.y * Forward * Mul
	EyePos = EyePos + Offset.z * Up * Mul
	
	return EyePos, EyeAng
end

SWEP.Author					= "Patrick Hunt"
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions			= "Use primary attack to throw a glowstick and secondary to drop."
SWEP.HoldType				= "slam"
SWEP.Category				= "Chemlight"

SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true

--SWEP.ViewModel				= "models/weapons/c_glowstick.mdl"
--SWEP.WorldModel				= "models/glowstick/glowstick.mdl"
SWEP.UseHands				= true
SWEP.BounceWeaponIcon		= false
SWEP.DrawWeaponInfoBox		= false

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= 5
SWEP.Primary.Automatic		= false
SWEP.Primary.Ammo			= "glowsticks"
SWEP.Primary.Delay			= 1

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= false
SWEP.Secondary.Ammo			= "none"
SWEP.Secondary.Delay		= 1


function SWEP:Initialize()
	util.PrecacheSound("glowstick/glowstick_snap.wav");
	util.PrecacheSound("glowstick/glowstick_shake.wav");
	self:SetWeaponHoldType( self.HoldType )
	
if GetGlobalBool( "global_Cheml_oldmodel" ) then 
self.ViewModel				= "models/weapons/c_chemstick_antic.mdl"
self.WorldModel				= "models/glowstick/chemstick_antic.mdl"
elseif GetGlobalBool( "global_Cheml_oldmodel" ) == false then
self.ViewModel				= "models/weapons/c_chemstick.mdl" 
self.WorldModel				= "models/glowstick/chemstick.mdl"
end

end

function SWEP:Think()
	if self.Owner:IsBot() then self:SetColor(Color(255,255,0,255)) else -- Bots create a shipload of errors since they don't have any client vars on them so let's set them all green (or i'm just stupid)
	self:SetColor(Color(255, 255, 0, 255)) -- Paints world model in real time
	if IsValid(self.Owner) then
		if CLIENT then
		local dlight = DynamicLight(self:EntIndex()+66, true)
			if dlight then
				dlight.pos = self.Owner:EyePos() - (self.Owner:GetAimVector() * 16)
				dlight.r = 255
				dlight.g = 255
				dlight.b = 0
				dlight.brightness = 6
				dlight.Decay = 1
				dlight.Size = 64
				--dlight.DieTime = CurTime() + 10
				
			end
		end
	end
	end
end


function SWEP:Deploy()
	self:SetColor(Color(255,255,0,255))
	if !self.Owner:IsBot() then
	self.Weapon:SendWeaponAnim(ACT_VM_DRAW);
	self.Weapon:SetNextPrimaryFire(CurTime() + 0.55)
	self.Weapon:SetNextSecondaryFire(CurTime() + 0.55)
	timer.Remove( "weapon_chemlight_yellow"..self.Owner:EntIndex() )
	timer.Create( "weapon_chemlight_yellow"..self.Owner:EntIndex(), 1.5, 1, function() self.Weapon:SendWeaponAnim( ACT_VM_IDLE ) end ) end
	if SERVER then
	
	-------------------------------------------------
	
			local matrix = self.Owner:GetBoneMatrix(1)
			local chempos = matrix:GetTranslation()

	local worldmodel = ents.FindInSphere(chempos,15)
	for k, v in pairs(worldmodel) do 
		if v:GetClass() == "ent_chemlight_glow_yellow" and v:GetOwner() == self.Owner and SERVER then
			v:Remove()
	end
	end
	
	-------------------------------------------------

	local glow = ents.Create("ent_chemlight_glow_yellow")
		glow:SetOwner(self.Owner) 
		glow:FollowBone( self.Owner, 1 )
		glow:SetLocalPos(Vector(0,0,0))
		if self.Owner:IsBot() then self:SetColor(Color(255,255,0,255)) else
		glow:SetColor(Color(255, 255, 0, 255))
		end
		//glow:SetMaterial(self.Owner:GetMaterial())
		glow:Spawn()
		self.chemlightindex = glow:EntIndex()
	end
   return true
end



local cooldown = 0.5
local cooldown2 = 2
local lastReloadTime=0;
function SWEP:Reload()
if self.Owner:GetNW2Int( "chemlnavareloadtogglevar" ) == 0 then
if ((CurTime()-lastReloadTime)>cooldown) and SERVER then
		if (self.Owner:GetNW2Bool( "chemlightattachmentusage", false ) != true) then --create if there is no 
		if GetGlobalBool( "global_Cheml_Ammo", 1 ) == true then
		if ( self.Weapon:Ammo1() <= 0 ) then return end
		self:TakePrimaryAmmo(1)
		end
			timer.Simple( 0.6, function()
			local glow = ents.Create("ent_chemlight_for_attachment")
			glow:SetOwner(self.Owner)
			glow:SetModelScale( 0.01, 0 )
			glow:FollowBone( self.Owner, 3 )
			glow:SetLocalPos(Vector(10,10,3))
			glow:SetLocalAngles(Angle(-15,180,0))
			glow:SetNotSolid( true )
			if self.Owner:IsBot() then self:SetColor(Color(255,255,255,255)) else
			self.Owner:SetNW2Int( "chemlightattachmenRGB_R", 255 )
			self.Owner:SetNW2Int( "chemlightattachmenRGB_G", 255 )
			self.Owner:SetNW2Int( "chemlightattachmenRGB_B", 0 )
			glow:SetColor(Color(self.Owner:GetNW2Int( "chemlightattachmenRGB_R", 0 ),self.Owner:GetNW2Int( "chemlightattachmenRGB_G", 0 ) ,self.Owner:GetNW2Int( "chemlightattachmenRGB_B", 0 ) , 255))
			glow:SetMaterial("Models/effects/vol_light001")
			glow:DrawShadow( false )
			end			
			glow:Spawn()
			--glow:SetNoDraw(true)

			self.Owner:SetNW2Int( "chemlightattachmentindex", glow:EntIndex() )
			sound.Play( "glowstick/carbiner.wav", glow:GetPos(), 75, math.random( 90, 110 ), math.Clamp( 0.5, 0.2, 0.7 ) )
			end )
			timer.Remove( "weapon_chemlight_yellow"..self.Owner:EntIndex() )
			self.Weapon:SendWeaponAnim(ACT_VM_RELOAD);
			timer.Create( "reloadtimer"..self.Owner:EntIndex(), 1.5, 1, function() 
				if self.Owner:GetActiveWeapon():GetClass() == self.Weapon:GetClass()  then
				self.Weapon:SendWeaponAnim(ACT_VM_DRAW)
				end
			 end )
			timer.Create( "weapon_chemlight_yellow"..self.Owner:EntIndex(), 3, 1, function() 
				if self.Owner:GetActiveWeapon():GetClass() == self.Weapon:GetClass()  then
				self.Weapon:SendWeaponAnim(ACT_VM_IDLE)
				end
			 end )
			self.Weapon:SetNextPrimaryFire(CurTime() + 3)
			self.Weapon:SetNextSecondaryFire(CurTime() + 3)
			timer.Simple( 0.6, function() self.Owner:SetNW2Bool( "chemlightattachmentusage", true ) end)
			if GetGlobalBool( "global_Cheml_Inf", 0 ) == false then
			local lifetime = GetGlobalFloat( "global_Cheml_Lifetime", 25 ) + 15
			timer.Create( "deadlight"..self.Owner:EntIndex(), lifetime , 1 , function() if self.Owner:Alive() then self.Owner:SetNW2Bool( "chemlightattachmentusage", false ) end end )
			end
			else --remove the hell out of it
			if self.Owner:GetNW2Int( "chemlightattachmentindex", 0 ) != 0 and Entity(self.Owner:GetNW2Int( "chemlightattachmentindex", 0 )):IsValid() then
			sound.Play( "glowstick/carbiner.wav", self.Owner:GetPos(), 75, math.random( 90, 110 ), math.Clamp( 0.5, 0.2, 0.7 ) )
			Entity(self.Owner:GetNW2Int( "chemlightattachmentindex", 0 )):Remove()
			self.Owner:SetNW2Bool( "chemlightattachmentusage", false )
			end
		end
	lastReloadTime=CurTime()
end
	
	return true
	else
--
if ((CurTime()-lastReloadTime)>cooldown2) and SERVER then
	if GetGlobalBool( "global_Cheml_Ammo", 1 ) == true then
	if ( self.Weapon:Ammo1() <= 0 ) then return end
	self:TakePrimaryAmmo(1)
	end

timer.Create( "reloadtimer1"..self.Owner:EntIndex(), 0.8, 1, function()		
	if self.Owner:GetActiveWeapon():GetClass() == self.Weapon:GetClass() and self.Owner:IsValid() then
	self.Owner:SetColor(Color( 255, 255, 0, 255))
	self.Owner:SetNW2Bool( "chemlightplayercolored", true )
	local minushels = math.random(7,13)
	if self.Owner:Health() > minushels then self.Owner:SetHealth(self.Owner:Health()-minushels) else self.Owner:Kill() end
	self.Owner:ScreenFade( SCREENFADE.IN, Color( 255, 255, 0, 100), 0.5, 0 )
	end 
end)
timer.Create( "reloadtimer2"..self.Owner:EntIndex(), 0.4, 1, function()		
	if self.Owner:GetActiveWeapon():GetClass() == self.Weapon:GetClass() and self.Owner:IsValid() then
	sound.Play( "glowstick/glowstick_nom.wav", self.Owner:GetPos() )
	end 
end)
timer.Remove( "weapon_chemlight_yellow"..self.Owner:EntIndex() )
self.Weapon:SendWeaponAnim(ACT_VM_PULLPIN);
			timer.Create( "reloadtimer"..self.Owner:EntIndex(), 1.5, 1, function() 
				if self.Owner:GetActiveWeapon():GetClass() == self.Weapon:GetClass() and self.Owner:IsValid() then
				self.Weapon:SendWeaponAnim(ACT_VM_DRAW)
				end 
			end)
			timer.Create( "weapon_chemlight_yellow"..self.Owner:EntIndex(), 3, 1, function() 
				if self.Owner:GetActiveWeapon():GetClass() == self.Weapon:GetClass() and self.Owner:IsValid()  then
				self.Weapon:SendWeaponAnim(ACT_VM_IDLE)
				end
			end) 
			timer.Create( "uncolorchemlighttimer"..self.Owner:EntIndex(), 15, 1, function() 
				self.Owner:SetColor(Color(255,255,255,255))
				self.Owner:SetNW2Bool( "chemlightplayercolored", false )
			end)
			self.Weapon:SetNextPrimaryFire(CurTime() + 3)
			self.Weapon:SetNextSecondaryFire(CurTime() + 3)
			lastReloadTime=CurTime()
end
--
end
end



function SWEP:SecondaryAttack()
if GetGlobalBool( "global_Cheml_Ammo", 1 ) == true then
if ( self.Weapon:Ammo1() <= 0 ) then return end
self:TakePrimaryAmmo(1)
end
timer.Remove( "weapon_chemlight_yellow"..self.Owner:EntIndex() )
	self.Weapon:SendWeaponAnim( ACT_VM_SECONDARYATTACK )
	self.Weapon:SetNextSecondaryFire(CurTime() + self.Secondary.Delay)
	self.Weapon:SetNextPrimaryFire(CurTime() + self.Primary.Delay)
		timer.Simple(0.5, function()
		timer.Create( "weapon_chemlight_yellow"..self.Owner:EntIndex(), 2, 1, function() self.Weapon:SendWeaponAnim( ACT_VM_IDLE ) end )
		self.Owner:SetAnimation( PLAYER_ATTACK1 )
			if SERVER then
					local ent = ents.Create("ent_chemlight")
					ent:SetPos(self.Owner:EyePos() + (self.Owner:GetAimVector() * 4))
					ent:SetAngles(self.Owner:EyeAngles())
					if self.Owner:IsBot() then ent:SetColor(Color(255,255,0,255)) else
					ent:SetColor( Color( 255, 255, 0, 255) )
					end
					ent:Spawn()
					ent:Activate()
					self.Owner:AddCleanup( "glowsticks", ent)
				local phys = ent:GetPhysicsObject()
				phys:SetVelocity(self.Owner:GetVelocity() + self.Owner:GetAimVector() * 125 * GetGlobalFloat("global_Cheml_throwstrength", 1))
				phys:AddAngleVelocity(Vector(math.random(-1000,1000),math.random(-1000,1000),math.random(-1000,1000)))
			end
		end)
		timer.Simple(1, function()
		if self.Owner:GetActiveWeapon():GetClass() == self.Weapon:GetClass()  then
		self.Weapon:SendWeaponAnim(ACT_VM_DRAW)
		end
		end)
end

function SWEP:PrimaryAttack()
if GetGlobalBool( "global_Cheml_Ammo", 1 ) == true then
if ( self.Weapon:Ammo1() <= 0 ) then return end
self:TakePrimaryAmmo(1)
end
timer.Remove( "weapon_chemlight_yellow"..self.Owner:EntIndex() )
	self.Weapon:SendWeaponAnim( ACT_VM_THROW )
	self.Weapon:SetNextSecondaryFire(CurTime() + self.Secondary.Delay)
	self.Weapon:SetNextPrimaryFire(CurTime() + self.Primary.Delay)
		timer.Simple(0.5, function()
		timer.Create( "weapon_chemlight_yellow"..self.Owner:EntIndex(), 2, 1, function() self.Weapon:SendWeaponAnim( ACT_VM_IDLE ) end )
		self.Owner:SetAnimation( PLAYER_ATTACK1 )
			if SERVER then
					local ent = ents.Create("ent_chemlight")
					ent:SetPos(self.Owner:EyePos() + (self.Owner:GetAimVector() * 4))
					ent:SetAngles(self.Owner:EyeAngles())
					if self.Owner:IsBot() then ent:SetColor(Color(255,255,0,255)) else
					ent:SetColor( Color( 255, 255, 0, 255) )
					end
					ent:Spawn()
					ent:Activate()
					self.Owner:AddCleanup( "glowsticks", ent)
				local phys = ent:GetPhysicsObject()
				phys:SetVelocity(self.Owner:GetVelocity() + self.Owner:GetAimVector() * 400 * GetGlobalFloat("global_Cheml_throwstrength", 1))
				phys:AddAngleVelocity(Vector(math.random(-1000,1000),math.random(-1000,1000),math.random(-1000,1000)))
			end
		end)
		timer.Simple(1, function()
		if self.Owner:GetActiveWeapon():GetClass() == self.Weapon:GetClass()  then
		self.Weapon:SendWeaponAnim(ACT_VM_DRAW)
		end
		end)
end

function SWEP:PreDrawViewModel( vm )
	if self.Owner:IsBot() then return end
	Material("models/glowstick/glow"):SetVector("$color2", Vector(255, 255, 0) )
end

function SWEP:PostDrawViewModel( vm )
	if self.Owner:IsBot() then return end
	Material("models/glowstick/glow"):SetVector("$color2", Vector(1, 1, 1) )
end

function SWEP:Holster()
	timer.Remove( "weapon_chemlight_yellow"..self.Owner:EntIndex() )
--			local matrix = self.Owner:GetBoneMatrix(1)
--			local chempos = matrix:GetTranslation()
--			local chempos2 = self.Owner:EyePos() - chempos	
--	local worldmodel = ents.FindInSphere(chempos + Vector(0,0,chempos2.z),0.6)
--	for k, v in pairs(worldmodel) do 
--		if v:GetClass() == "ent_chemlight_glow_yellow" and v:GetOwner() == self.Owner and SERVER then
--			v:Remove()
		if SERVER then
		if self.chemlightindex == 0 then print("ашипка") return end 
		if ents.GetByIndex( self.chemlightindex):IsValid() then
		ents.GetByIndex( self.chemlightindex):Remove()
		end
		end
--		end
--	end
return true
end

function SWEP:OnRemove()
	return true
end
--addons/handschellen/lua/weapons/weapon_cuff_elastic_single.lua:
---------------------------------------
--   	   Handcuffs | Weapon        --
---------------------------------------

AddCSLuaFile()

SWEP.Base = "weapon_cuff_base"

SWEP.Category = "SW:RP (Handschellen)"
SWEP.Author = "my_hat_stinks"
SWEP.Instructions = "Diese Handschellen können einmal benutzt werden."

SWEP.Spawnable = true
SWEP.AdminOnly = false
SWEP.AdminSpawnable = false

SWEP.Slot = 3
SWEP.PrintName = "Einmal Handschellen"

-- Handcuff Vars
SWEP.CuffTime = 1.0
SWEP.CuffSound = Sound( "buttons/lever7.wav" )

SWEP.CuffMaterial = "models/props_pipes/GutterMetal01a"
SWEP.CuffRope = "cable/red"
SWEP.CuffStrength = 1
SWEP.CuffRegen = 1
SWEP.RopeLength = 75
SWEP.CuffReusable = false

SWEP.CuffBlindfold = false
SWEP.CuffGag = false

SWEP.CuffStrengthVariance = 0.1
SWEP.CuffRegenVariance = 0.3

--addons/handschellen/lua/weapons/weapon_cuff_plastic.lua:
---------------------------------------
--   	   Handcuffs | Weapon        --
---------------------------------------

AddCSLuaFile()

SWEP.Base = "weapon_cuff_base"

SWEP.Category = "SW:RP (Handschellen)"
SWEP.Author = "my_hat_stinks"
SWEP.Instructions = "Diese Handschellen werden von den medizinischen Corps benutzt."

SWEP.Spawnable = true
SWEP.AdminOnly = false
SWEP.AdminSpawnable = false

SWEP.Slot = 2
SWEP.PrintName = "Medizinische Handfesseln"


-- Handcuff Vars
SWEP.CuffTime = 1.0
SWEP.CuffSound = Sound( "buttons/lever7.wav" )

SWEP.CuffMaterial = "phoenix_storms/cube"
SWEP.CuffRope = "cable/cable2"
SWEP.CuffStrength = 0.8
SWEP.CuffRegen = 0.6
SWEP.RopeLength = 0
SWEP.CuffReusable = false

SWEP.CuffBlindfold = false
SWEP.CuffGag = false

SWEP.CuffStrengthVariance = 0.4
SWEP.CuffRegenVariance = 0.1

--addons/handschellen/lua/weapons/weapon_cuff_police.lua:
---------------------------------------
--   	   Handcuffs | Weapon        --
---------------------------------------


AddCSLuaFile()

SWEP.Base = "weapon_cuff_base"

SWEP.Category = "SW:RP (Handschellen)"
SWEP.Author = "my_hat_stinks"
SWEP.Instructions = "Sturdy police-issue handcuffs."

SWEP.Spawnable = false
SWEP.AdminOnly = false
SWEP.AdminSpawnable = false

SWEP.Slot = 2
SWEP.PrintName = "Police Handcuffs"

//
// Handcuff Vars
SWEP.CuffTime = 1.0 // Seconds to handcuff
SWEP.CuffSound = Sound( "buttons/lever7.wav" )

SWEP.CuffMaterial = "phoenix_storms/gear"
SWEP.CuffRope = "cable/cable2"
SWEP.CuffStrength = 1.4
SWEP.CuffRegen = 1.4
SWEP.RopeLength = 0
SWEP.CuffReusable = true

SWEP.CuffBlindfold = false
SWEP.CuffGag = false

SWEP.CuffStrengthVariance = 0.1 // Randomise strangth
SWEP.CuffRegenVariance = 0.1 // Randomise regen

--addons/handschellen/lua/weapons/weapon_cuff_rope.lua:
---------------------------------------
--   	   Handcuffs | Weapon        --
---------------------------------------


AddCSLuaFile()

SWEP.Base = "weapon_cuff_base"

SWEP.Category = "SW:RP (Handschellen)"
SWEP.Author = "my_hat_stinks"
SWEP.Instructions = "A weak restraint."

SWEP.Spawnable = false
SWEP.AdminOnly = false
SWEP.AdminSpawnable = false

SWEP.Slot = 2
SWEP.PrintName = "Rope Restraint"

//
// Handcuff Vars
SWEP.CuffTime = 0.8 // Seconds to handcuff
SWEP.CuffSound = Sound( "buttons/lever7.wav" )

SWEP.CuffMaterial = "models/props_foliage/tree_deciduous_01a_trunk"
SWEP.CuffRope = "cable/rope"
SWEP.CuffStrength = 0.85
SWEP.CuffRegen = 0.8
SWEP.RopeLength = 100
SWEP.CuffReusable = false

SWEP.CuffBlindfold = true
SWEP.CuffGag = true

SWEP.CuffStrengthVariance = 0.1 // Randomise strength
SWEP.CuffRegenVariance = 0.2 // Randomise regen

--addons/egm_tfa_weapons/lua/weapons/weapon_grenadelauncher_no_impact.lua:
-- Written by Mattzi

SWEP.Base                   = "weapon_swrp_egm_base"

SWEP.PrintName              = "Grenade Launcher (No Impact)"
SWEP.Category               = "SW:RP (Republik)"
SWEP.Type					= "Grenade Launcher"
SWEP.Manufacturer           = "BlasTech Industries"
SWEP.Slot                   = 2
SWEP.SlotPos                = 2

SWEP.Spawnable 				= true
SWEP.IsGrenadelauncher		= true

-- Model --

SWEP.ViewModel						= "models/bf2017/c_e11.mdl"
SWEP.WorldModel						= "models/bf2017/w_e11.mdl"

SWEP.VMPos = Vector(0.99, -06, -1.03)
SWEP.VMAng = Vector(0,0,0)

SWEP.HoldType 						= "smg"
SWEP.ReloadHoldTypeOverride 		= "smg"

SWEP.UseHands 						= true

SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
	["v_e11_reference001"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(-3, 0, 0), angle = Angle(0, 0, 0) }
}

SWEP.VElements = {
	["pl"] = { type = "Model", model = "models/sw_battlefront/weapons/pinglauncher.mdl", bone = "v_e11_reference001", rel = "", pos = Vector(-1.8, 1.8, -5), angle = Angle(0, -90, 0), size = Vector(1.3, 1.3, 1.3), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
}

SWEP.WElements = {
	["pl"] = { type = "Model", model = "models/sw_battlefront/weapons/pinglauncher.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(2.5, 1.1, 2.8), angle = Angle(-12, 0, 180), size = Vector(1.1, 1.1, 1.1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

SWEP.HolsterOffset = Vector(8, 0, -4)
SWEP.HolsterAngle = Angle(0, 180, 0)



-- Tracer --

-- Tracer name
SWEP.TracerName 					= "rw_sw_laser_blue"


-- Magazine --

-- Ammo per Magazine
SWEP.Primary.ClipSize				= 1
-- Magazine Count
SWEP.Primary.DefaultClip			= 1
-- Ammo Type
SWEP.Primary.Ammo					= "smg1_grenade"
-- Ammo Consumption per shot
SWEP.Primary.AmmoConsumption 		= 1

-- Fire Modes --

-- Actual Fire Modes.
SWEP.FireModes = {
	"rw_sw_ent_nade_smoke",
	"rw_sw_ent_nade_heal",
	"rw_sw_ent_nade_incendiary",
	"rw_sw_ent_nade_poison",
	"rw_sw_ent_nade_poison_stun",
	"rw_sw_ent_nade_stun",
	"rw_sw_ent_nade_thermal",
	"rw_sw_ent_nade_train",
	"rw_sw_ent_nade_flash",
	"rw_sw_ent_nade_emp",
}

local EntToSWEP = {
	["rw_sw_ent_nade_smoke"] = "rw_sw_nade_smoke",
	["rw_sw_ent_nade_heal"] = "rw_sw_nade_bacta",
	["rw_sw_ent_nade_incendiary"] = "rw_sw_nade_incendiary",
	["rw_sw_ent_nade_poison"] = "rw_sw_nade_dioxis",
	["rw_sw_ent_nade_poison_stun"] = "rw_sw_nade_dioxis_stun",
	["rw_sw_ent_nade_stun"] = "rw_sw_nade_stun",
	["rw_sw_ent_nade_thermal"] = "rw_sw_nade_thermal",
	["rw_sw_ent_nade_train"] = "rw_sw_nade_training",
	["rw_sw_ent_nade_flash"] = "rw_sw_nade_flash",
	["rw_sw_ent_nade_emp"] = "rw_sw_nade_emp",
}

-- Automatic RPM
SWEP.Primary.RPM					= nil
-- Semi Automatic Fire RPM
SWEP.Primary.RPM_Semi				= 120

-- Burst Fire RPM
SWEP.Primary.RPM_Burst				= nil
-- Delay Between Bursts
SWEP.Primary.BurstDelay				= nil

-- Range --

-- Max Range of weapon
SWEP.Primary.Range 					= 80000000

-- Shooting --

-- Number of bullets per shot (For Shotguns)
SWEP.Primary.NumShots				= 1
-- Damage per bullet
SWEP.Primary.Damage = 0

-- Aiming --

SWEP.data 							= {}
-- Enable Iron Sights
SWEP.data.ironsights				= 1
-- Iron Sights FOV
SWEP.Secondary.IronFOV				= 75 -- TODO


SWEP.RTScopeAttachment				= -1
SWEP.Scoped_3D 						= false
SWEP.ScopeReticule 					= "#sw/visor/sw_ret_redux_blue"
SWEP.Secondary.ScopeZoom 			= 5
SWEP.ScopeReticule_Scale 			= {1.1,1.1}
SWEP.IronSightsSensitivity          = 0.8

SWEP.Primary.Spread					= 0.05
SWEP.Primary.IronAccuracy 			= 0.05

SWEP.Primary.SpreadMultiplierMax 	= 1
SWEP.Primary.SpreadIncrement 		= 0

SWEP.Primary.Projectile = "zeus_explosivegrenade" -- Entity to shoot

SWEP.ProjectileVelocity = 3000 --Entity to shoot's velocity

-- Holding Positions

-- Aiming
SWEP.IronSightsPos = Vector(-4.78, -5, 02.85)
SWEP.IronSightsAng = Vector(0, 0, 0)
-- Running
SWEP.RunSightsPos = Vector(5.226, -2, 0)
SWEP.RunSightsAng = Vector(-18, 36, -13.5)
-- Inspecting
SWEP.InspectPos = Vector(8, -4.8, -3)
SWEP.InspectAng = Vector(11.199, 38, 0)

-- Sounds --

-- Fire Sound
SWEP.Primary.Sound = Sound ("w/launcher.wav")
-- Reload Sound
SWEP.Primary.ReloadSound = Sound ("w/pistols.wav")

SWEP.CurrentHeat = 0
SWEP.NextHeatThink = CurTime()
SWEP.LastHeatThink = CurTime()

function SWEP:GetFireModeName()
	local fm = self:GetFireMode()
	local fmn = string.lower(self:GetStat("FireModes")[fm])

	if fmn == "rw_sw_ent_nade_heal" then return "Bacta" end
	if fmn == "rw_sw_ent_nade_incendiary" then return "Fire" end
	if fmn == "rw_sw_ent_nade_poison" then return "Poison" end
	if fmn == "rw_sw_ent_nade_poison_stun" then return "Symoxin" end
	if fmn == "rw_sw_ent_nade_smoke" then return "Smoke" end
	if fmn == "rw_sw_ent_nade_stun" then return "Stun" end
	if fmn == "rw_sw_ent_nade_thermal" then return "Thermal" end
	if fmn == "rw_sw_ent_nade_train" then return "Training" end
	if fmn == "rw_sw_ent_nade_flash" then return "Flash" end
	if fmn == "rw_sw_ent_nade_emp" then return "EMP" end

	return self.BaseClass.GetFireModeName(self)
end

function SWEP:CycleFireMode()
	local fm = self:GetFireMode()

	local fireModes = self:GetStat("FireModes")
	local fmCount = #fireModes
	for i = 1, fmCount, 1 do
		local newFm = ((fm + i - 1) % fmCount) + 1

		local grenadeType = fireModes[newFm]
		if grenadeType == "Safe" then continue end
		local swepType = EntToSWEP[grenadeType]
		local owner = self:GetOwner()
		if owner:HasWeapon(swepType) or owner:HasWeapon("store_" .. swepType) then
			fm = newFm
			break
		end
	end

	self:SetFireMode(fm)
	local a = self:ChooseROFAnim()

	if a then
		self:SetNextPrimaryFire(CurTime() + self:GetActivityLength())
	else
		self:EmitSound("Weapon_AR2.Empty")
		self:SetNextPrimaryFire(CurTime() + math.max(self:GetFireDelay(), 0.25))
	end

	self.BurstCount = 0
	self:SetStatus(TFA.GetStatus("firemode"))
	self:SetStatusEnd(self:GetNextPrimaryFire())

	self.Primary.Automatic = self:GetStat("FireModesAutomatic." .. self:GetStat("FireModes." .. fm)) ~= nil
end

hook.Add("TFA_GetStat", "GrenadeLauncher.Override", function(self, stat, finalReturn)
	if self.IsGrenadelauncher then
		local fm = self:GetFireMode()

		if stat == "Primary.Projectile" then return string.lower(self:GetStat("FireModes")[fm]) end
	end
end)

DEFINE_BASECLASS( SWEP.Base )
--addons/star_wars_lightsabers/lua/weapons/weapon_lightsaber.lua:

--[[

Editing the Lightsabers.

Once you unpack the lightsaber addon, you are voided of any support as to why it doesn't work.
I can't possibly provide support for all the edits and I can't know what your edits broke or whatever.

-------------------------------- DO NOT REUPLOAD THIS ADDON IN ANY SHAPE OF FORM --------------------------------
-------------------------------- DO NOT REUPLOAD THIS ADDON IN ANY SHAPE OF FORM --------------------------------
-------------------------------- DO NOT REUPLOAD THIS ADDON IN ANY SHAPE OF FORM --------------------------------
-------------------------------- DO NOT REUPLOAD THIS ADDON IN ANY SHAPE OF FORM --------------------------------
-------------------------------- DO NOT REUPLOAD THIS ADDON IN ANY SHAPE OF FORM --------------------------------

-------------------------- DO NOT EDIT ANYTHING DOWN BELOW OR YOU LOSE SUPPORT FROM ME --------------------------
-------------------------- DO NOT EDIT ANYTHING DOWN BELOW OR YOU LOSE SUPPORT FROM ME --------------------------
-------------------------- DO NOT EDIT ANYTHING DOWN BELOW OR YOU LOSE SUPPORT FROM ME --------------------------
-------------------------- DO NOT EDIT ANYTHING DOWN BELOW OR YOU LOSE SUPPORT FROM ME --------------------------
-------------------------- DO NOT EDIT ANYTHING DOWN BELOW OR YOU LOSE SUPPORT FROM ME --------------------------
-------------------------- DO NOT EDIT ANYTHING DOWN BELOW OR YOU LOSE SUPPORT FROM ME --------------------------

]]

AddCSLuaFile()

if ( SERVER ) then
	util.AddNetworkString( "rb655_holdtype" )
	resource.AddWorkshop( "111412589" )
	CreateConVar( "rb655_lightsaber_infinite", "0" )
end

SWEP.PrintName = "Lightsaber"
SWEP.Author = "Robotboy655"
SWEP.Category = "Robotboy655's Weapons"
SWEP.Contact = "http://steamcommunity.com/profiles/76561197996891752"
SWEP.Purpose = "To slice off each others limbs and heads."
SWEP.Instructions = "Use the force, Luke."
SWEP.RenderGroup = RENDERGROUP_BOTH

SWEP.Slot = 0
SWEP.SlotPos = 4

SWEP.Spawnable = false
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = false
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.DrawWeaponInfoBox = false

SWEP.ViewModel = "models/weapons/v_crowbar.mdl"
SWEP.WorldModel = "models/sgg/starwars/weapons/w_anakin_ep2_saber_hilt.mdl"
SWEP.ViewModelFOV = 55

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

-- We have NPC support, but it SUCKS
--list.Add( "NPCUsableWeapons", { class = "weapon_lightsaber", title = SWEP.PrintName } )

-- --------------------------------------------------------- Helper functions --------------------------------------------------------- --

function SWEP:PlayWeaponSound( snd )
	if ( CLIENT ) then return end
	if ( IsValid( self:GetOwner() ) && IsValid( self:GetOwner():GetActiveWeapon() ) && self:GetOwner():GetActiveWeapon() != self ) then return end
	if ( !IsValid( self.Owner ) ) then return self:EmitSound( snd ) end
	self.Owner:EmitSound( snd )
end

function SWEP:SelectTargets( num )
	local t = {}
	local dist = 512

	--[[local tr = util.TraceLine( {
		start = self.Owner:GetShootPos(),
		endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * dist,
		filter = self.Owner
	} )]]

	local p = {}
	for id, ply in pairs( ents.GetAll() ) do
		if ( !ply:GetModel() or ply:GetModel() == "" or ply == self.Owner or ply:Health() < 1 ) then continue end
		if ( string.StartWith( ply:GetModel() or "", "models/gibs/" ) ) then continue end
		if ( string.find( ply:GetModel() or "", "chunk" ) ) then continue end
		if ( string.find( ply:GetModel() or "", "_shard" ) ) then continue end
		if ( string.find( ply:GetModel() or "", "_splinters" ) ) then continue end

		local tr = util.TraceLine( {
			start = self.Owner:GetShootPos(),
			endpos = ply.GetShootPos && ply:GetShootPos() or ply:GetPos(),
			filter = self.Owner,
		} )

		if ( tr.Entity != ply && IsValid( tr.Entity ) or tr.Entity == game.GetWorld() ) then continue end

		local pos1 = self.Owner:GetPos() + self.Owner:GetAimVector() * dist
		local pos2 = ply:GetPos()
		local dot = self.Owner:GetAimVector():Dot( ( self.Owner:GetPos() - pos2 ):GetNormalized() )

		if ( pos1:Distance( pos2 ) <= dist && ply:EntIndex() > 0 && ply:GetModel() && ply:GetModel() != "" ) then
			table.insert( p, { ply = ply, dist = tr.HitPos:Distance( pos2 ), dot = dot, score = -dot + ( ( dist - pos1:Distance( pos2 ) ) / dist ) * 50 } )
		end
	end

	for id, ply in SortedPairsByMemberValue( p, "dist" ) do
		table.insert( t, ply.ply )
		if ( #t >= num ) then return t end
	end

	return t
end

-- --------------------------------------------------------- Force Powers --------------------------------------------------------- --

function SWEP:GetActiveForcePowers()
	local ForcePowers = {}
	for id, t in pairs( rb655_GetForcePowers() ) do
		local ret = hook.Run( "CanUseLightsaberForcePower", self:GetOwner(), t.name )
		if ( ret == false ) then continue end

		table.insert( ForcePowers, t )
	end
	return ForcePowers
end

function SWEP:GetActiveForcePowerType( id )
	local ForcePowers = self:GetActiveForcePowers()
	return ForcePowers[ id ]
end

if ( SERVER ) then
	concommand.Add( "rb655_select_force", function( ply, cmd, args )
		if ( !IsValid( ply ) or !IsValid( ply:GetActiveWeapon() ) or ply:GetActiveWeapon():GetClass() != "weapon_lightsaber" or !tonumber( args[ 1 ] ) ) then return end

		local wep = ply:GetActiveWeapon()
		local ForcePowers = #wep:GetActiveForcePowers()
		local typ = math.Clamp( tonumber( args[ 1 ] ), 1, ForcePowers )
		wep:SetForceType( typ )
	end )

	concommand.Add( "rb655_select_next", function( ply, cmd, args )
		if ( !IsValid( ply ) or !IsValid( ply:GetActiveWeapon() ) or ply:GetActiveWeapon():GetClass() != "weapon_lightsaber" or !tonumber( args[ 1 ] ) ) then return end

		local wep = ply:GetActiveWeapon()
		local ForcePowers = #wep:GetActiveForcePowers()

		local current = wep:GetForceType()
		current = current + math.Clamp( tonumber( args[ 1 ] ), -1, 1 )
		if ( current < 1 ) then current = ForcePowers end
		if ( current > ForcePowers ) then current = 1 end

		local typ = math.Clamp( current, 1, ForcePowers )
		wep:SetForceType( typ )
	end )
end

hook.Add( "GetFallDamage", "rb655_lightsaber_no_fall_damage", function( ply, speed )
	if ( IsValid( ply ) && IsValid( ply:GetActiveWeapon() ) && ply:GetActiveWeapon():GetClass() == "weapon_lightsaber" ) then
		local wep = ply:GetActiveWeapon()

		if ( ply:KeyDown( IN_DUCK ) ) then
			ply:SetNWFloat( "SWL_FeatherFall", CurTime() ) -- Hate on me for NWVars!
			wep:SetNextAttack( 0.5 )
			ply:ViewPunch( Angle( speed / 32, 0, math.random( -speed, speed ) / 128 ) )
			return 0
		end
	end
end )

function SWEP:OnRestore()
	self.Owner:SetNWFloat( "SWL_FeatherFall", 0 )
end

hook.Add( "CreateMove", "rb655_lightsaber_no_fall_damage", function( cmd )
	if ( CurTime() - LocalPlayer():GetNWFloat( "SWL_FeatherFall", CurTime() - 2 ) < 1 ) then
		cmd:ClearButtons() -- No attacking, we are busy
		cmd:ClearMovement() -- No moving, we are busy
		cmd:SetButtons( IN_DUCK ) -- Force them to crouch
	end
end )

hook.Add( "EntityTakeDamage", "rb655_sabers_armor", function( victim, dmg )
	local ply = victim
	if ( !ply.GetActiveWeapon or !ply:IsPlayer() ) then return end
	local wep = ply:GetActiveWeapon()
	if ( !IsValid( wep ) or !string.StartWith(wep:GetClass(), "weapon_lightsaber_") or wep:GetActiveForcePowerType( wep:GetForceType() ).name != "Tutaminis" ) then return end
	if ( !ply:KeyDown( IN_ATTACK2 ) --[[|| !ply:IsOnGround()]] ) then return end

	local damage = dmg:GetDamage() / 5
	local force = wep:GetForce()
	if ( force < damage ) then
		wep:SetForce( 0 )
		dmg:SetDamage( ( damage - force ) * 5 )
		return
	end
	wep:SetForce( force - damage )
	dmg:SetDamage( 0 )
end )

function SWEP:SetNextAttack( delay )
	self:SetNextPrimaryFire( CurTime() + delay )
	self:SetNextSecondaryFire( CurTime() + delay )
end

function SWEP:ForceJumpAnim()
	self.Owner.m_bJumping = true

	self.Owner.m_bFirstJumpFrame = true
	self.Owner.m_flJumpStartTime = CurTime()

	self.Owner:AnimRestartMainSequence()
end

-- --------------------------------------------------------- Initialize --------------------------------------------------------- --

function SWEP:SetupDataTables()
	self:NetworkVar( "Float", 0, "LengthAnimation" )
	self:NetworkVar( "Float", 1, "MaxLength" )
	self:NetworkVar( "Float", 2, "BladeWidth" )
	self:NetworkVar( "Float", 3, "Force" )

	self:NetworkVar( "Bool", 0, "DarkInner" )
	self:NetworkVar( "Bool", 1, "Enabled" )
	self:NetworkVar( "Bool", 2, "WorksUnderwater" )
	self:NetworkVar( "Int", 0, "ForceType" )
	self:NetworkVar( "Int", 1, "IncorrectPlayerModel" )
	self:NetworkVar( "Int", 2, "MaxForce" )

	self:NetworkVar( "Vector", 0, "CrystalColor" )
	self:NetworkVar( "String", 0, "WorldModel" )
	self:NetworkVar( "String", 1, "OnSound" )
	self:NetworkVar( "String", 2, "OffSound" )

	if ( SERVER ) then
		self:SetLengthAnimation( 0 )
		self:SetBladeWidth( 2 )
		self:SetMaxLength( 42 )
		self:SetDarkInner( false )
		self:SetWorksUnderwater( true )
		self:SetEnabled( false )

		self:SetForceType( 1 )
		self:SetMaxForce( 100 )
		self:SetForce( self:GetMaxForce() )
		self:SetOnSound( "lightsaber/saber_on" .. math.random( 1, 4 ) .. ".wav" )
		self:SetOffSound( "lightsaber/saber_off" .. math.random( 1, 4 ) .. ".wav" )
		self:SetCrystalColor( Vector( math.random( 0, 255 ), math.random( 0, 255 ), math.random( 0, 255 ) ) )

		local _, k = table.Random( list.Get( "LightsaberModels" ) )
		self:SetWorldModel( k or "models/sgg/starwars/weapons/w_anakin_ep2_saber_hilt.mdl" )
		--self:SetWorldModel( "models/sgg/starwars/weapons/w_anakin_ep2_saber_hilt.mdl" )

		self:NetworkVarNotify( "Force", self.OnForceChanged )
		self:NetworkVarNotify( "Enabled", self.OnEnabledOrDisabled )
	end
end

function SWEP:GetBladeLength()
	return self:GetLengthAnimation() * self:GetMaxLength()
end

function SWEP:SetBladeLength( val )
	self:SetLengthAnimation( val / self:GetMaxLength() )
	MsgN( "Lightsaber.SetBladeLength is deprecated!" )
end

function SWEP:LoadToolValues( ply )
	local maxLen = ply:GetInfoNum( "rb655_lightsaber_bladel", 42 )
	local bldWidth = ply:GetInfoNum( "rb655_lightsaber_bladew", 2 )
	if ( !game.SinglePlayer() ) then
		maxLen = math.Clamp( maxLen, 32, 64 )
		bldWidth = math.Clamp( bldWidth, 2, 4 )
	end

	self:SetMaxLength( maxLen )
	self:SetBladeWidth( bldWidth )
	self:SetCrystalColor( Vector( ply:GetInfo( "rb655_lightsaber_red" ), ply:GetInfo( "rb655_lightsaber_green" ), ply:GetInfo( "rb655_lightsaber_blue" ) ) )
	self:SetDarkInner( ply:GetInfo( "rb655_lightsaber_dark" ) == "1" )
	self:SetWorldModel( ply:GetInfo( "rb655_lightsaber_model" ) )
	self:SetModel( self:GetWorldModel() )
	self.WorldModel = self:GetWorldModel()
	--self:PhysicsInit( SOLID_VPHYSICS )

	self.LoopSound = ply:GetInfo( "rb655_lightsaber_humsound" )
	self.SwingSound = ply:GetInfo( "rb655_lightsaber_swingsound" )
	self:SetOnSound( ply:GetInfo( "rb655_lightsaber_onsound" ) )
	self:SetOffSound( ply:GetInfo( "rb655_lightsaber_offsound" ) )
	--self:SetEnabled( ply:GetInfo( "rb655_lightsaber_starton" ) )

	self.WeaponSynched = true
end

hook.Add( "PlayerSpawnedNPC", "rb655_lightsaber_npc_sync", function( ply, npc )
	if ( !npc:IsNPC() or !IsValid( npc:GetActiveWeapon() ) or npc:GetActiveWeapon():GetClass() != "weapon_lightsaber" ) then return end
	npc:GetActiveWeapon():LoadToolValues( ply )
end )

hook.Add( "PlayerSpawnedSWEP", "rb655_lightsaber_swep_sync", function( ply, wep )
	if ( wep:GetClass() != "weapon_lightsaber" ) then return end
	wep:LoadToolValues( ply )
end )

function SWEP:Initialize()
	self.LoopSound = self.LoopSound or "lightsaber/saber_loop" .. math.random( 1, 8 ) .. ".wav"
	self.SwingSound = self.SwingSound or "lightsaber/saber_swing" .. math.random( 1, 2 ) .. ".wav"

	self:SetWeaponHoldType( self:GetTargetHoldType() )

	if ( self.Owner && self.Owner:IsNPC() && SERVER ) then -- NPC Weapons
		--self.Owner:Fire( "GagEnable" )

		if ( self.Owner:GetClass() == "npc_citizen" ) then
			self.Owner:Fire( "DisableWeaponPickup" )
		end

		self.Owner:SetKeyValue( "spawnflags", "256" )

		hook.Add( "Think", self, self.NPCThink )

		timer.Simple( 0.5, function()
			if ( !IsValid( self ) or !IsValid( self.Owner ) ) then return end
			self.Owner:SetCurrentWeaponProficiency( 4 )
			self.Owner:CapabilitiesAdd( CAP_FRIENDLY_DMG_IMMUNE )
			self.Owner:CapabilitiesRemove( CAP_WEAPON_MELEE_ATTACK1 )
			self.Owner:CapabilitiesRemove( CAP_INNATE_MELEE_ATTACK1 )
		end )
	end
end

-- --------------------------------------------------------- NPC Weapons --------------------------------------------------------- --

function SWEP:SetupWeaponHoldTypeForAI( t )
	if ( !self.Owner:IsNPC() ) then return end

	self.ActivityTranslateAI = {}

	self.ActivityTranslateAI[ ACT_IDLE ]					= ACT_IDLE
	self.ActivityTranslateAI[ ACT_IDLE_ANGRY ]				= ACT_IDLE_ANGRY_MELEE
	self.ActivityTranslateAI[ ACT_IDLE_RELAXED ]			= ACT_IDLE
	self.ActivityTranslateAI[ ACT_IDLE_STIMULATED ]			= ACT_IDLE_ANGRY_MELEE
	self.ActivityTranslateAI[ ACT_IDLE_AGITATED ]			= ACT_IDLE_ANGRY_MELEE
	self.ActivityTranslateAI[ ACT_IDLE_AIM_RELAXED ]		= ACT_IDLE_ANGRY_MELEE
	self.ActivityTranslateAI[ ACT_IDLE_AIM_STIMULATED ]		= ACT_IDLE_ANGRY_MELEE
	self.ActivityTranslateAI[ ACT_IDLE_AIM_AGITATED ]		= ACT_IDLE_ANGRY_MELEE

	self.ActivityTranslateAI[ ACT_RANGE_ATTACK1 ]			= ACT_RANGE_ATTACK_THROW
	self.ActivityTranslateAI[ ACT_RANGE_ATTACK1_LOW ]		= ACT_MELEE_ATTACK_SWING
	self.ActivityTranslateAI[ ACT_MELEE_ATTACK1 ]			= ACT_MELEE_ATTACK_SWING
	self.ActivityTranslateAI[ ACT_MELEE_ATTACK2 ]			= ACT_MELEE_ATTACK_SWING
	self.ActivityTranslateAI[ ACT_SPECIAL_ATTACK1 ]			= ACT_RANGE_ATTACK_THROW

	self.ActivityTranslateAI[ ACT_RANGE_AIM_LOW ]			= ACT_IDLE_ANGRY_MELEE
	self.ActivityTranslateAI[ ACT_COVER_LOW ]				= ACT_IDLE_ANGRY_MELEE

	self.ActivityTranslateAI[ ACT_WALK ]					= ACT_WALK
	self.ActivityTranslateAI[ ACT_WALK_RELAXED ]			= ACT_WALK
	self.ActivityTranslateAI[ ACT_WALK_STIMULATED ]			= ACT_WALK
	self.ActivityTranslateAI[ ACT_WALK_AGITATED ]			= ACT_WALK

	self.ActivityTranslateAI[ ACT_RUN_CROUCH ]				= ACT_RUN
	self.ActivityTranslateAI[ ACT_RUN_CROUCH_AIM ]			= ACT_RUN
	self.ActivityTranslateAI[ ACT_RUN ]						= ACT_RUN
	self.ActivityTranslateAI[ ACT_RUN_AIM_RELAXED ]			= ACT_RUN
	self.ActivityTranslateAI[ ACT_RUN_AIM_STIMULATED ]		= ACT_RUN
	self.ActivityTranslateAI[ ACT_RUN_AIM_AGITATED ]		= ACT_RUN
	self.ActivityTranslateAI[ ACT_RUN_AIM ]					= ACT_RUN
	self.ActivityTranslateAI[ ACT_SMALL_FLINCH ]			= ACT_RANGE_ATTACK_PISTOL
	self.ActivityTranslateAI[ ACT_BIG_FLINCH ]				= ACT_RANGE_ATTACK_PISTOL

	if ( self.Owner:GetClass() == "npc_metropolice" ) then

	self.ActivityTranslateAI[ ACT_IDLE ]					= ACT_IDLE
	self.ActivityTranslateAI[ ACT_IDLE_ANGRY ]				= ACT_IDLE_ANGRY_MELEE
	self.ActivityTranslateAI[ ACT_IDLE_RELAXED ]			= ACT_IDLE
	self.ActivityTranslateAI[ ACT_IDLE_STIMULATED ]			= ACT_IDLE
	self.ActivityTranslateAI[ ACT_IDLE_AGITATED ]			= ACT_IDLE_ANGRY_MELEE

	self.ActivityTranslateAI[ ACT_MP_RUN ]					= ACT_HL2MP_RUN_SUITCASE
	self.ActivityTranslateAI[ ACT_WALK ]					= ACT_WALK_SUITCASE
	self.ActivityTranslateAI[ ACT_MELEE_ATTACK1 ]			= ACT_MELEE_ATTACK_SWING
	self.ActivityTranslateAI[ ACT_RANGE_ATTACK1 ]			= ACT_MELEE_ATTACK_SWING
	self.ActivityTranslateAI[ ACT_SPECIAL_ATTACK1 ]			= ACT_RANGE_ATTACK_THROW
	self.ActivityTranslateAI[ ACT_SMALL_FLINCH ]			= ACT_RANGE_ATTACK_PISTOL
	self.ActivityTranslateAI[ ACT_BIG_FLINCH ]				= ACT_RANGE_ATTACK_PISTOL

	return end

	if ( self.Owner:GetClass() == "npc_combine_s2" ) then

	self.ActivityTranslateAI[ ACT_IDLE ]					= ACT_IDLE
	self.ActivityTranslateAI[ ACT_IDLE_ANGRY ]				= ACT_IDLE_ANGRY_MELEE
	self.ActivityTranslateAI[ ACT_IDLE_RELAXED ]			= ACT_IDLE
	self.ActivityTranslateAI[ ACT_IDLE_STIMULATED ]			= ACT_IDLE_ANGRY_MELEE
	self.ActivityTranslateAI[ ACT_IDLE_AGITATED ]			= ACT_IDLE_ANGRY_MELEE
	self.ActivityTranslateAI[ ACT_IDLE_AIM_RELAXED ]		= ACT_IDLE_ANGRY_MELEE
	self.ActivityTranslateAI[ ACT_IDLE_AIM_STIMULATED ]		= ACT_IDLE_ANGRY_MELEE
	self.ActivityTranslateAI[ ACT_IDLE_AIM_AGITATED ]		= ACT_IDLE_ANGRY_MELEE

	self.ActivityTranslateAI[ ACT_RANGE_ATTACK1 ]			= ACT_RANGE_ATTACK_THROW
	self.ActivityTranslateAI[ ACT_RANGE_ATTACK1_LOW ]		= ACT_MELEE_ATTACK_SWING
	self.ActivityTranslateAI[ ACT_MELEE_ATTACK1 ]			= ACT_MELEE_ATTACK_SWING
	self.ActivityTranslateAI[ ACT_MELEE_ATTACK2 ]			= ACT_MELEE_ATTACK_SWING
	self.ActivityTranslateAI[ ACT_SPECIAL_ATTACK1 ]			= ACT_RANGE_ATTACK_THROW


	self.ActivityTranslateAI[ ACT_RANGE_AIM_LOW ]			 = ACT_IDLE_ANGRY_MELEE
	self.ActivityTranslateAI[ ACT_COVER_LOW ]				= ACT_IDLE_ANGRY_MELEE

	self.ActivityTranslateAI[ ACT_WALK ]					= ACT_WALK
	self.ActivityTranslateAI[ ACT_WALK_RELAXED ]			= ACT_WALK
	self.ActivityTranslateAI[ ACT_WALK_STIMULATED ]			= ACT_WALK
	self.ActivityTranslateAI[ ACT_WALK_AGITATED ]			= ACT_WALK

	self.ActivityTranslateAI[ ACT_RUN ]						= ACT_RUN
	self.ActivityTranslateAI[ ACT_RUN_AIM_RELAXED ]			= ACT_RUN
	self.ActivityTranslateAI[ ACT_RUN_AIM_STIMULATED ]		= ACT_RUN
	self.ActivityTranslateAI[ ACT_RUN_AIM_AGITATED ]		= ACT_RUN
	self.ActivityTranslateAI[ ACT_RUN_AIM ]					= ACT_RUN
	self.ActivityTranslateAI[ ACT_SMALL_FLINCH ]			= ACT_RANGE_ATTACK_PISTOL
	self.ActivityTranslateAI[ ACT_BIG_FLINCH ]				= ACT_RANGE_ATTACK_PISTOL

	return end

	if ( self.Owner:GetClass() == "npc_combine_s" ) then

	self.ActivityTranslateAI[ ACT_IDLE ]					= ACT_IDLE_UNARMED
	self.ActivityTranslateAI[ ACT_IDLE_ANGRY ]				= ACT_IDLE_SHOTGUN
	self.ActivityTranslateAI[ ACT_IDLE_RELAXED ]			= ACT_IDLE_SHOTGUN
	self.ActivityTranslateAI[ ACT_IDLE_STIMULATED ]			= ACT_IDLE_SHOTGUN
	self.ActivityTranslateAI[ ACT_IDLE_AGITATED ]			= ACT_IDLE_SHOTGUN
	self.ActivityTranslateAI[ ACT_IDLE_AIM_RELAXED ]		= ACT_IDLE_SHOTGUN
	self.ActivityTranslateAI[ ACT_IDLE_AIM_STIMULATED ]		= ACT_IDLE_SHOTGUN
	self.ActivityTranslateAI[ ACT_IDLE_AIM_AGITATED ]		= ACT_IDLE_SHOTGUN

	self.ActivityTranslateAI[ ACT_RANGE_ATTACK1 ]			= ACT_MELEE_ATTACK1
	self.ActivityTranslateAI[ ACT_RANGE_ATTACK1_LOW ]		= ACT_MELEE_ATTACK1
	self.ActivityTranslateAI[ ACT_MELEE_ATTACK1 ]			= ACT_MELEE_ATTACK1
	self.ActivityTranslateAI[ ACT_MELEE_ATTACK2 ]			= ACT_MELEE_ATTACK1
	self.ActivityTranslateAI[ ACT_SPECIAL_ATTACK1 ]			= ACT_MELEE_ATTACK1

	self.ActivityTranslateAI[ ACT_RANGE_AIM_LOW ]			 = ACT_IDLE_SHOTGUN
	self.ActivityTranslateAI[ ACT_COVER_LOW ]				= ACT_IDLE_SHOTGUN

	self.ActivityTranslateAI[ ACT_WALK ]					= ACT_WALK_UNARMED
	self.ActivityTranslateAI[ ACT_WALK_RELAXED ]			= ACT_WALK_UNARMED
	self.ActivityTranslateAI[ ACT_WALK_STIMULATED ]			= ACT_WALK_UNARMED
	self.ActivityTranslateAI[ ACT_WALK_AGITATED ]			= ACT_WALK_UNARMED

	self.ActivityTranslateAI[ ACT_RUN ]						= ACT_RUN_AIM_SHOTGUN
	self.ActivityTranslateAI[ ACT_RUN_AIM_RELAXED ]			= ACT_RUN_AIM_SHOTGUN
	self.ActivityTranslateAI[ ACT_RUN_AIM_STIMULATED ]		= ACT_RUN_AIM_SHOTGUN
	self.ActivityTranslateAI[ ACT_RUN_AIM_AGITATED ]		= ACT_RUN_AIM_SHOTGUN
	self.ActivityTranslateAI[ ACT_RUN_AIM ]					= ACT_RUN_AIM_SHOTGUN

	return end
end

function SWEP:GetCapabilities()
	return bit.bor( CAP_WEAPON_MELEE_ATTACK1 )
end

function SWEP:NPC_NextLogic()
	if ( !IsValid( self ) or !IsValid( self.Owner ) ) then return end
	if ( self.Owner:IsCurrentSchedule( SCHED_CHASE_ENEMY ) ) then return end
	self.NPC_NextLogicTimer = true
	self:NPC_ChaseEnemy()

	timer.Simple( math.Rand( 0.7, 1 ), function()
		self.NPC_NextLogicTimer = false
	end )
end

function SWEP:NPC_ChaseEnemy()
	if ( !IsValid( self ) or !IsValid( self.Owner ) ) then return end
	if ( self.Owner:GetEnemy():GetPos():Distance( self:GetPos() ) > 70 ) then
		self.Owner:SetSchedule( SCHED_CHASE_ENEMY )
	end

	if ( self.Owner:GetEnemy() == self.Owner ) then self.Owner:SetEnemy( NULL ) return end
	if ( !self.CooldownTimer && self.Owner:GetEnemy():GetPos():Distance( self:GetPos() ) <= 70 ) then
		self.Owner:SetSchedule( SCHED_MELEE_ATTACK1 )
		self:NPCShoot_Primary( ShootPos, ShootDir )
	end
end

function SWEP:NPCThink()
	if ( !IsValid( self.Owner ) or !IsValid( self ) or !self.Owner:IsNPC() ) then return end

	if ( self:GetEnabled() != IsValid( self.Owner:GetEnemy() ) ) then self:SetEnabled( IsValid( self.Owner:GetEnemy() ) ) end

	--self.Owner:RemoveAllDecals()
	self.Owner:ClearCondition( 13 )
	self.Owner:ClearCondition( 17 )
	self.Owner:ClearCondition( 18 )
	self.Owner:ClearCondition( 20 )
	self.Owner:ClearCondition( 48 )
	self.Owner:ClearCondition( 42 )
	self.Owner:ClearCondition( 45 )

	if ( !self.NPC_NextLogicTimer && IsValid( self.Owner:GetEnemy() ) ) then
		self:NPC_NextLogic()
	end

	self:Think()
end

function SWEP:NPCShoot_Primary( ShootPos, ShootDir )
	if ( !IsValid( self ) or !IsValid( self.Owner ) ) then return end
	if ( !self.Owner:GetEnemy() ) then return end

	self.CooldownTimer = true
	local seqtimer = 0.4
	if self.Owner:GetClass() == "npc_alyx" then
		seqtimer = 0.8
	end

	timer.Simple( seqtimer, function()
		if ( !IsValid( self ) or !IsValid( self.Owner ) ) then return end
		--[[if ( self.Owner:IsCurrentSchedule( SCHED_MELEE_ATTACK1 ) ) then
			self:PrimaryAttack()
		end]]
		self.CooldownTimer = false
	end )
end

-- --------------------------------------------------------- Attacks --------------------------------------------------------- --

-- TODO: HOOK THIS
function SWEP:PrimaryAttack()
	if ( !IsValid( self.Owner ) ) then return end

	self:SetNextAttack( 0.5 )

	if ( !self.Owner:IsNPC() && self:GetEnabled() ) then
		self.Owner:AnimResetGestureSlot( GESTURE_SLOT_CUSTOM )
		self.Owner:SetAnimation( PLAYER_ATTACK1 )
	end
end

function SWEP:SecondaryAttack()
	if ( !IsValid( self.Owner ) or !self:GetActiveForcePowerType( self:GetForceType() ) ) then return end
	if ( game.SinglePlayer() && SERVER ) then self:CallOnClient( "SecondaryAttack", "" ) end

	local selectedForcePower = self:GetActiveForcePowerType( self:GetForceType() )
	if ( !selectedForcePower ) then return end

	local ret = hook.Run( "CanUseLightsaberForcePower", self.Owner, selectedForcePower.name )
	if ( ret == false ) then return end

	if ( selectedForcePower.action ) then
		selectedForcePower.action( self, self.Owner )
		if ( GetConVarNumber( "rb655_lightsaber_infinite" ) != 0 ) then self:SetForce( self:GetMaxForce() ) end
	end
end

function SWEP:Reload()
	if ( !self.Owner:KeyPressed( IN_RELOAD ) ) then return end
	if ( self.Owner:WaterLevel() > 2 && !self:GetWorksUnderwater() ) then return end

	self:SetEnabled( !self:GetEnabled() )
end

-- --------------------------------------------------------- Hold Types --------------------------------------------------------- --

function SWEP:GetTargetHoldType()
	--if ( !self:GetEnabled() ) then return "normal" end
	if ( self:GetWorldModel() == "models/weapons/starwars/w_maul_saber_staff_hilt.mdl" ) then return "knife" end
	if ( self:LookupAttachment( "blade2" ) && self:LookupAttachment( "blade2" ) > 0 ) then return "knife" end

	return "melee2"
end

-- --------------------------------------------------------- Drop / Deploy / Holster / Enable / Disable --------------------------------------------------------- --

function SWEP:OnEnabled( bDeploy )
	if ( !self:GetEnabled() or bDeploy ) then self:PlayWeaponSound( self:GetOnSound() ) end

	if ( CLIENT or self:GetEnabled() ) then return end

	self:SetHoldType( self:GetTargetHoldType() )
	timer.Remove( "rb655_ls_ht" )

	self.SoundLoop = CreateSound( self.Owner, Sound( self.LoopSound ) )
	if ( self.SoundLoop ) then self.SoundLoop:Play() end

	self.SoundSwing = CreateSound( self.Owner, Sound( self.SwingSound ) )
	if ( self.SoundSwing ) then self.SoundSwing:Play() self.SoundSwing:ChangeVolume( 0, 0 ) end

	self.SoundHit = CreateSound( self.Owner, Sound( "lightsaber/saber_hit.wav" ) )
	if ( self.SoundHit ) then self.SoundHit:Play() self.SoundHit:ChangeVolume( 0, 0 ) end
end

function SWEP:OnDisabled( bRemoved )
	if ( CLIENT ) then
		if ( bRemoved ) then rb655_SaberClean( self:EntIndex() ) end
		return true
	end

	if ( self.SoundLoop ) then self.SoundLoop:Stop() self.SoundLoop = nil end
	if ( self.SoundSwing ) then self.SoundSwing:Stop() self.SoundSwing = nil end
	if ( self.SoundHit ) then self.SoundHit:Stop() self.SoundHit = nil end

	return true
end

function SWEP:OnEnabledOrDisabled( name, old, new )
	if ( old == new ) then return end

	if ( new ) then
		self:OnEnabled()
	else
		self:PlayWeaponSound( self:GetOffSound() )

		-- Fancy extinguish animations?
		timer.Create( "rb655_ls_ht", 0.4, 1, function() if ( IsValid( self ) ) then self:SetHoldType( "normal" ) end end )

		self:OnDisabled()
	end
end

function SWEP:OnDrop()
	if ( self:GetEnabled() ) then self:PlayWeaponSound( self:GetOffSound() ) end
	self:OnDisabled( true )
end
function SWEP:OnRemove()
	if ( self:GetEnabled() && IsValid( self.Owner ) ) then self:PlayWeaponSound( self:GetOffSound() ) end
	self:OnDisabled( true )
end

function SWEP:Deploy()

	local ply = self.Owner

	if ( ply:IsPlayer() && !ply:IsBot() && !self.WeaponSynched && SERVER && GAMEMODE.IsSandboxDerived ) then
		self:LoadToolValues( ply )
	end

	if ( self:GetEnabled() ) then self:OnEnabled( true ) else self:SetHoldType( "normal" ) end

	if ( CLIENT ) then return end

	if ( ply:IsPlayer() && ply:FlashlightIsOn() ) then ply:Flashlight( false ) end

	self:SetLengthAnimation( 0 ) -- Reinitialize the effect

	return true
end

function SWEP:Holster()
	if ( self:GetEnabled() ) then self:PlayWeaponSound( self:GetOffSound() ) end

	self:SetLengthAnimation( 0 ) -- For the effect

	return self:OnDisabled( true )
end

-- --------------------------------------------------------- Think --------------------------------------------------------- --

function SWEP:GetSaberPosAng( num, side )
	num = num or 1

	if ( SERVER ) then self:SetIncorrectPlayerModel( 0 ) end

	if ( IsValid( self.Owner ) ) then
		local bone = self.Owner:LookupBone( "ValveBiped.Bip01_R_Hand" )
		local attachment = self:LookupAttachment( "blade" .. num )
		if ( side ) then
			attachment = self:LookupAttachment( "quillon" .. num )
		end

		if ( !bone && SERVER ) then
			self:SetIncorrectPlayerModel( 1 )
		end

		if ( attachment && attachment > 0 ) then
			local PosAng = self:GetAttachment( attachment )

			if ( !bone && SERVER ) then
				PosAng.Pos = PosAng.Pos + Vector( 0, 0, 36 )
				if ( SERVER && IsValid( self.Owner ) && self.Owner:IsPlayer() && self.Owner:Crouching() ) then PosAng.Pos = PosAng.Pos - Vector( 0, 0, 18 ) end
				PosAng.Ang.p = 0
			end

			return PosAng.Pos, PosAng.Ang:Forward()
		end

		if ( bone ) then
			local pos, ang = self.Owner:GetBonePosition( bone )
			if ( pos == self.Owner:GetPos() ) then
				local matrix = self.Owner:GetBoneMatrix( bone )
				if ( matrix ) then
					pos = matrix:GetTranslation()
					ang = matrix:GetAngles()
				else
					self:SetIncorrectPlayerModel( 1 )
				end
			end

			ang:RotateAroundAxis( ang:Forward(), 180 )
			ang:RotateAroundAxis( ang:Up(), 30 )
			ang:RotateAroundAxis( ang:Forward(), -5.7 )
			ang:RotateAroundAxis( ang:Right(), 92 )

			pos = pos + ang:Up() * -3.3 + ang:Right() * 0.8 + ang:Forward() * 5.6

			return pos, ang:Forward()
		end

		self:SetIncorrectPlayerModel( 1 )
	else
		self:SetIncorrectPlayerModel( 2 )
	end

	if ( self:GetIncorrectPlayerModel() == 0 ) then self:SetIncorrectPlayerModel( 1 ) end

	local defAng = self:GetAngles()
	defAng.p = 0

	local defPos = self:GetPos() + defAng:Right() * 0.6 - defAng:Up() * 0.2 + defAng:Forward() * 0.8
	if ( SERVER ) then defPos = defPos + Vector( 0, 0, 36 ) end
	if ( SERVER && IsValid( self.Owner ) && self.Owner:Crouching() ) then defPos = defPos - Vector( 0, 0, 18 ) end

	return defPos, -defAng:Forward()
end

function SWEP:OnForceChanged( name, old, new )
	if ( old > new ) then
		self.NextForce = CurTime() + 4
	end
end

function SWEP:Think()
	self.WorldModel = self:GetWorldModel()
	self:SetModel( self:GetWorldModel() )

	local selectedForcePower = self:GetActiveForcePowerType( self:GetForceType() )
	if ( selectedForcePower && selectedForcePower.think && !self.Owner:KeyDown( IN_USE ) ) then
		local ret = hook.Run( "CanUseLightsaberForcePower", self.Owner, selectedForcePower.name )
		if ( ret != false && selectedForcePower.think ) then
			selectedForcePower.think( self )
		end
	end

	if ( CLIENT ) then return true end

	if ( ( self.NextForce or 0 ) < CurTime() ) then
		self:SetForce( math.min( self:GetForce() + 0.5, self:GetMaxForce() ) )
	end

	if ( !self:GetEnabled() && self:GetLengthAnimation() != 0 ) then
		self:SetLengthAnimation( math.Approach( self:GetLengthAnimation(), 0, FrameTime() * 3 ) )
	elseif ( self:GetEnabled() && self:GetLengthAnimation() != 1 ) then
		self:SetLengthAnimation( math.Approach( self:GetLengthAnimation(), 1, FrameTime() * 10 ) )
	end

	if ( self:GetEnabled() && !self:GetWorksUnderwater() && self.Owner:WaterLevel() > 2 ) then
		self:SetEnabled( false )
		--self:EmitSound( self:GetOffSound() )
	end

	if ( self:GetBladeLength() <= 0 ) then return end

	-- ------------------------------------------------- DAMAGE ------------------------------------------------- --

	-- This whole system needs rework

	-- Up
	local isTrace1Hit = false
	local pos, ang = self:GetSaberPosAng()
	local trace = util.TraceLine( {
		start = pos,
		endpos = pos + ang * self:GetBladeLength(),
		filter = { self, self.Owner },
		--mins = Vector( -1, -1, -1 ) * self:GetBladeWidth() / 8,
		--maxs = Vector( 1, 1, 1 ) * self:GetBladeWidth() / 8
	} )
	local traceBack = util.TraceLine( {
		start = pos + ang * self:GetBladeLength(),
		endpos = pos,
		filter = { self, self.Owner },
		--mins = Vector( -1, -1, -1 ) * self:GetBladeWidth() / 8,
		--maxs = Vector( 1, 1, 1 ) * self:GetBladeWidth() / 8
	} )

	--if ( SERVER ) then debugoverlay.Line( trace.StartPos, trace.HitPos, .1, Color( 255, 0, 0 ), false ) end

	-- When the blade is outside of the world
	if ( trace.HitSky or ( trace.StartSolid && trace.HitWorld ) ) then trace.Hit = false end
	if ( traceBack.HitSky or ( traceBack.StartSolid && traceBack.HitWorld ) ) then traceBack.Hit = false end

	self:DrawHitEffects( trace, traceBack )
	isTrace1Hit = trace.Hit or traceBack.Hit

	-- Don't deal the damage twice to the same entity
	if ( traceBack.Entity == trace.Entity && IsValid( trace.Entity ) ) then traceBack.Hit = false end

	if ( trace.Hit ) then rb655_LS_DoDamage( trace, self ) end
	if ( traceBack.Hit ) then rb655_LS_DoDamage( traceBack, self ) end

	-- Down
	local isTrace2Hit = false
	if ( self:LookupAttachment( "blade2" ) > 0 ) then -- TEST ME
		local pos2, dir2 = self:GetSaberPosAng( 2 )
		local trace2 = util.TraceLine( {
			start = pos2,
			endpos = pos2 + dir2 * self:GetBladeLength(),
			filter = { self, self.Owner },
			--mins = Vector( -1, -1, -1 ) * self:GetBladeWidth() / 8,
			--maxs = Vector( 1, 1, 1 ) * self:GetBladeWidth() / 8
		} )
		local traceBack2 = util.TraceLine( {
			start = pos2 + dir2 * self:GetBladeLength(),
			endpos = pos2,
			filter = { self, self.Owner },
			--mins = Vector( -1, -1, -1 ) * self:GetBladeWidth() / 8,
			--maxs = Vector( 1, 1, 1 ) * self:GetBladeWidth() / 8
		} )

		if ( trace2.HitSky or ( trace2.StartSolid && trace2.HitWorld ) ) then trace2.Hit = false end
		if ( traceBack2.HitSky or ( traceBack2.StartSolid && traceBack2.HitWorld ) ) then traceBack2.Hit = false end

		self:DrawHitEffects( trace2, traceBack2 )
		isTrace2Hit = trace2.Hit or traceBack2.Hit

		if ( traceBack2.Entity == trace2.Entity && IsValid( trace2.Entity ) ) then traceBack2.Hit = false end

		if ( trace2.Hit ) then rb655_LS_DoDamage( trace2, self ) end
		if ( traceBack2.Hit ) then rb655_LS_DoDamage( traceBack2, self ) end

	end

	if ( ( isTrace1Hit or isTrace2Hit ) && self.SoundHit ) then
		self.SoundHit:ChangeVolume( math.Rand( 0.1, 0.5 ), 0 )
	elseif ( self.SoundHit ) then
		self.SoundHit:ChangeVolume( 0, 0 )
	end

	-- ------------------------------------------------- SOUNDS ------------------------------------------------- --

	if ( self.SoundSwing ) then

		if ( self.LastAng != ang ) then
			self.LastAng = self.LastAng or ang
			self.SoundSwing:ChangeVolume( math.Clamp( ang:Distance( self.LastAng ) / 2, 0, 1 ), 0 )
		end

		self.LastAng = ang
	end

	if ( self.SoundLoop ) then
		pos = pos + ang * self:GetBladeLength()

		if ( self.LastPos != pos ) then
			self.LastPos = self.LastPos or pos
			self.SoundLoop:ChangeVolume( 0.1 + math.Clamp( pos:Distance( self.LastPos ) / 128, 0, 0.2 ), 0 )
		end
		self.LastPos = pos
	end
end

function SWEP:DrawHitEffects( trace, traceBack )
	if ( self:GetBladeLength() <= 0 ) then return end

	if ( trace.Hit ) then
		rb655_DrawHit( trace.HitPos, trace.HitNormal )
	end

	if ( traceBack && traceBack.Hit ) then
		rb655_DrawHit( traceBack.HitPos, traceBack.HitNormal )
	end
end

-- ------------------------------------------------------------- Fluid holdtype changes ----------------------------------------------------------------- --

local index = ACT_HL2MP_IDLE_KNIFE
local KnifeHoldType = {}
KnifeHoldType[ ACT_MP_STAND_IDLE ] = index
KnifeHoldType[ ACT_MP_WALK ] = index + 1
KnifeHoldType[ ACT_MP_RUN ] = index + 2
KnifeHoldType[ ACT_MP_CROUCH_IDLE ] = index + 3
KnifeHoldType[ ACT_MP_CROUCHWALK ] = index + 4
KnifeHoldType[ ACT_MP_ATTACK_STAND_PRIMARYFIRE ] = index + 5
KnifeHoldType[ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE ] = index + 5
KnifeHoldType[ ACT_MP_RELOAD_STAND ] = index + 6
KnifeHoldType[ ACT_MP_RELOAD_CROUCH ] = index + 6
KnifeHoldType[ ACT_MP_JUMP ] = index + 7
KnifeHoldType[ ACT_RANGE_ATTACK1 ] = index + 8
KnifeHoldType[ ACT_MP_SWIM ] = index + 9

function SWEP:TranslateActivity( act )

	if ( self.Owner:IsNPC() ) then
		if ( self.ActivityTranslateAI[ act ] ) then return self.ActivityTranslateAI[ act ] end
		return -1
	end

	if ( self.Owner:Crouching() ) then
		local tr = util.TraceHull( {
			start = self.Owner:GetShootPos(),
			endpos = self.Owner:GetShootPos() + Vector( 0, 0, 20 ),
			mins = self.Owner:OBBMins(),
			maxs = self.Owner:OBBMaxs(),
			filter = self.Owner
		} )

		if ( self:GetEnabled() && tr.Hit && act == ACT_MP_ATTACK_CROUCH_PRIMARYFIRE ) then return ACT_HL2MP_IDLE_KNIFE + 5 end

		if ( ( !self:GetEnabled() && self:GetHoldType() == "normal" ) && self.Owner:Crouching() && act == ACT_MP_CROUCH_IDLE ) then return ACT_HL2MP_IDLE_KNIFE + 3 end
		if ( ( ( !self:GetEnabled() && self:GetHoldType() == "normal" ) or ( self:GetEnabled() && tr.Hit ) ) && act == ACT_MP_CROUCH_IDLE ) then return ACT_HL2MP_IDLE_KNIFE + 3 end
		if ( ( ( !self:GetEnabled() && self:GetHoldType() == "normal" ) or ( self:GetEnabled() && tr.Hit ) ) && act == ACT_MP_CROUCHWALK ) then return ACT_HL2MP_IDLE_KNIFE + 4 end

	end

	if ( self.Owner:WaterLevel() > 1 && self:GetEnabled() ) then
		return KnifeHoldType[ act ]
	end

	if ( self.ActivityTranslate[ act ] != nil ) then return self.ActivityTranslate[ act ]end
	return -1
end

-- ------------------------------------------------------------- Clientside stuff ----------------------------------------------------------------- --

if ( SERVER ) then return end

killicon.Add( "weapon_lightsaber", "lightsaber/lightsaber_killicon", color_white )

local WepSelectIcon = Material( "lightsaber/selection.png" )
local Size = 96

function SWEP:DrawWeaponSelection( x, y, w, h, a )
	surface.SetDrawColor( 255, 255, 255, a )
	surface.SetMaterial( WepSelectIcon )

	render.PushFilterMag( TEXFILTER.ANISOTROPIC )
	render.PushFilterMin( TEXFILTER.ANISOTROPIC )

	surface.DrawTexturedRect( x + ( ( w - Size ) / 2 ), y + ( ( h - Size ) / 2.5 ), Size, Size )

	render.PopFilterMag()
	render.PopFilterMin()
end

function SWEP:DrawWorldModel()
	self:DrawWorldModelTranslucent()
end

function SWEP:DrawWorldModelTranslucent()
	self.WorldModel = self:GetWorldModel()
	self:SetModel( self:GetWorldModel() )

	self:DrawModel()
	if ( !IsValid( self:GetOwner() ) or halo.RenderedEntity() == self ) then return end

	local clr = self:GetCrystalColor()
	clr = Color( clr.x, clr.y, clr.z )

	local bladesFound = false -- true if the model is OLD and does not have blade attachments
	local blades = 0
	for id, t in pairs( self:GetAttachments() or {} ) do
		if ( !string.match( t.name, "blade(%d+)" ) && !string.match( t.name, "quillon(%d+)" ) ) then continue end

		local bladeNum = string.match( t.name, "blade(%d+)" )
		local quillonNum = string.match( t.name, "quillon(%d+)" )

		if ( bladeNum && self:LookupAttachment( "blade" .. bladeNum ) > 0 ) then
			blades = blades + 1
			local pos, dir = self:GetSaberPosAng( bladeNum )
			rb655_RenderBlade( pos, dir, self:GetBladeLength(), self:GetMaxLength(), self:GetBladeWidth(), clr, self:GetDarkInner(), self:EntIndex(), self:GetOwner():WaterLevel() > 2, false, blades )
			bladesFound = true
		end

		if ( quillonNum && self:LookupAttachment( "quillon" .. quillonNum ) > 0 ) then
			blades = blades + 1
			local pos, dir = self:GetSaberPosAng( quillonNum, true )
			rb655_RenderBlade( pos, dir, self:GetBladeLength(), self:GetMaxLength(), self:GetBladeWidth(), clr, self:GetDarkInner(), self:EntIndex(), self:GetOwner():WaterLevel() > 2, true, blades )
		end

	end

	if ( !bladesFound ) then
		local pos, dir = self:GetSaberPosAng()
		rb655_RenderBlade( pos, dir, self:GetBladeLength(), self:GetMaxLength(), self:GetBladeWidth(), clr, self:GetDarkInner(), self:EntIndex(), self:GetOwner():WaterLevel() > 2 )
	end
end

-- --------------------------------------------------------- 3rd Person Camera --------------------------------------------------------- --

--[[
hook.Add( "ShouldDrawLocalPlayer", "rb655_lightsaber_weapon_draw", function()
	if ( IsValid( LocalPlayer() ) && LocalPlayer().GetActiveWeapon && IsValid( LocalPlayer():GetActiveWeapon() ) && LocalPlayer():GetActiveWeapon():GetClass() == "weapon_lightsaber" && !LocalPlayer():InVehicle() && LocalPlayer():Alive() && LocalPlayer():GetViewEntity() == LocalPlayer() ) then return true end
end )

function SWEP:CalcView( ply, pos, ang, fov )
	if ( !IsValid( ply ) or !ply:Alive() or ply:InVehicle() or ply:GetViewEntity() != ply ) then return end

	local trace = util.TraceHull( {
		start = pos,
		endpos = pos - ang:Forward() * 100,
		filter = { ply:GetActiveWeapon(), ply },
		mins = Vector( -4, -4, -4 ),
		maxs = Vector( 4, 4, 4 ),
	} )

	if ( trace.Hit ) then pos = trace.HitPos else pos = pos - ang:Forward() * 100 end

	return pos, ang, fov
end]]

local isCalcViewFuckedUp2 = true
hook.Add( "CalcView", "!!!111_rb655_lightsaber_3rdperson", function( ply, pos, ang )
	if ( !IsValid( ply ) or !ply:Alive() or ply:InVehicle() or ply:GetViewEntity() != ply ) then return end
	if ( !LocalPlayer().GetActiveWeapon or !IsValid( LocalPlayer():GetActiveWeapon() ) or LocalPlayer():GetActiveWeapon():GetClass() != "weapon_lightsaber" ) then return end

	isCalcViewFuckedUp2 = false

	local trace = util.TraceHull( {
		start = pos,
		endpos = pos - ang:Forward() * 100,
		filter = { ply:GetActiveWeapon(), ply },
		mins = Vector( -4, -4, -4 ),
		maxs = Vector( 4, 4, 4 ),
	} )

	if ( trace.Hit ) then pos = trace.HitPos else pos = pos - ang:Forward() * 100 end

	return {
		origin = pos,
		angles = ang,
		drawviewer = true
	}
end )

-- --------------------------------------------------------- HUD --------------------------------------------------------- --

surface.CreateFont( "SelectedForceType", {
	font	= "Roboto Cn",
	size	= ScreenScale( 16 ),
	weight	= 600
} )

surface.CreateFont( "SelectedForceHUD", {
	font	= "Roboto Cn",
	size	= ScreenScale( 6 )
} )

local ForceSelectEnabled = false
hook.Add( "PlayerBindPress", "rb655_sabers_force", function( ply, bind, pressed )
	if ( LocalPlayer():InVehicle() or ply != LocalPlayer() or !LocalPlayer():Alive() or !IsValid( LocalPlayer():GetActiveWeapon() ) or LocalPlayer():GetActiveWeapon():GetClass() != "weapon_lightsaber" ) then ForceSelectEnabled = false return end

	local ret = hook.Run( "LightsaberPlayerBindPress", ply, bind, pressed )
	if ( ret != nil ) then ForceSelectEnabled = false return end

	if ( bind == "impulse 100" && pressed ) then
		ForceSelectEnabled = !ForceSelectEnabled
		return true
	end

	if ( !ForceSelectEnabled ) then return end

	if ( bind:StartWith( "slot" ) ) then
		RunConsoleCommand( "rb655_select_force", bind:sub( 5 ) )
		return true
	end

	if ( bind == "invprev" && pressed ) then
		RunConsoleCommand( "rb655_select_next", "-1" )
		return true
	end
	if ( bind == "invnext" && pressed ) then
		RunConsoleCommand( "rb655_select_next", "1" )
		return true
	end
end )

local rb655_lightsaber_hud_blur = CreateClientConVar( "rb655_lightsaber_hud_blur", "0" )

local grad = Material( "gui/gradient_up" )
local matBlurScreen = Material( "pp/blurscreen" )
matBlurScreen:SetFloat( "$blur", 3 )
matBlurScreen:Recompute()
local function DrawHUDBox( x, y, w, h, b )

	x = math.floor( x )
	y = math.floor( y )
	w = math.floor( w )
	h = math.floor( h )

	surface.SetMaterial( matBlurScreen )
	surface.SetDrawColor( 255, 255, 255, 255 )

	if ( rb655_lightsaber_hud_blur:GetBool() ) then
		render.SetScissorRect( x, y, w + x, h + y, true )
			for i = 0.33, 1, 0.33 do
				matBlurScreen:SetFloat( "$blur", 5 * i )
				matBlurScreen:Recompute()
				render.UpdateScreenEffectTexture()
				surface.DrawTexturedRect( 0, 0, ScrW(), ScrH() )
			end
		render.SetScissorRect( 0, 0, 0, 0, false )
	else
		draw.NoTexture()
		surface.SetDrawColor( Color( 0, 0, 0, 128 ) )
		surface.DrawTexturedRect( x, y, w, h )
	end

	surface.SetDrawColor( Color( 0, 0, 0, 128 ) )
	surface.DrawRect( x, y, w, h )

	if ( b ) then
		surface.SetMaterial( grad )
		surface.SetDrawColor( Color( 0, 128, 255, 4 ) )
		surface.DrawTexturedRect( x, y, w, h )
	end

end

local isCalcViewFuckedUp = true
function SWEP:ViewModelDrawn()
	isCalcViewFuckedUp = true -- Clever girl!
end

function SWEP:DrawHUDTargetSelection()
	local selectedForcePower = self:GetActiveForcePowerType( self:GetForceType() )
	if ( !selectedForcePower ) then return end

	local isTarget = selectedForcePower.target
	if ( isTarget ) then
		for id, ent in pairs( self:SelectTargets( isTarget ) ) do
			if ( !IsValid( ent ) ) then continue end
			local maxs = ent:OBBMaxs()
			local p = ent:GetPos()
			p.z = p.z + maxs.z

			local pos = p:ToScreen()
			local x, y = pos.x, pos.y
			local size = 16

			surface.SetDrawColor( 255, 0, 0, 255 )
			draw.NoTexture()
			surface.DrawPoly( {
				{ x = x - size, y = y - size },
				{ x = x + size, y = y - size },
				{ x = x, y = y }
			} )
		end
	end
end

function SWEP:DrawHUD_FuckedUpHooks( y )
	if ( ForceSelectEnabled ) then return end

	local x = ScrW() / 2
	local gap = 5

	----------------------------------- PlayerBindPress ERROR

	local isGood = hook.Call( "PlayerBindPress", nil, LocalPlayer(), "this_bind_doesnt_exist", true )
	if ( isGood == true ) then
		local txt = "Some addon is breaking the PlayerBindPress hook!"
		for name, func in pairs( hook.GetTable()[ "PlayerBindPress" ] ) do txt = txt .. "\n" .. tostring( name ) end
		local tW, tH = surface.GetTextSize( txt )

		y = y - tH - gap

		local id = 1
		DrawHUDBox( x - tW / 2 - 5, y, tW + 10, tH )
		draw.SimpleText( string.Explode( "\n", txt )[ 1 ], "SelectedForceHUD", x, y + 0, Color( 255, 230, 230 ), 1 )

		for str, func in pairs( hook.GetTable()[ "PlayerBindPress" ] ) do
			local clr = Color( 255, 255, 128 )
			if ( ( isstring( str ) && func( LocalPlayer(), "this_bind_doesnt_exist", true ) == true ) or ( !isstring( str ) && func( str, LocalPlayer(), "this_bind_doesnt_exist", true ) == true ) ) then
				clr = Color( 255, 128, 128 )
			end
			if ( !isstring( str ) ) then str = tostring( str ) end
			if ( str == "" ) then str = "<empty string hook>" end
			local _, lineH = surface.GetTextSize( str )
			draw.SimpleText( str, "SelectedForceHUD", x, y + id * lineH, clr, 1 )
			id = id + 1
		end
	end

	----------------------------------- CalcView ERROR

	if ( isCalcViewFuckedUp or isCalcViewFuckedUp2 ) then
		local txt = "Some addon is breaking the CalcView hook! See the hook names in red."
		for name, func in pairs( hook.GetTable()[ "CalcView" ] ) do txt = txt .. "\n" .. tostring( name ) end
		local tW, tH = surface.GetTextSize( txt )

		y = y - tH - gap

		local id = 1
		DrawHUDBox( x - tW / 2 - 5, y, tW + 10, tH )
		draw.SimpleText( string.Explode( "\n", txt )[ 1 ], "SelectedForceHUD", x, y + 0, Color( 255, 230, 230 ), 1 )

		for str, func in pairs( hook.GetTable()[ "CalcView" ] ) do
			local clr = Color( 255, 255, 128 )
			if ( ( isstring( str ) && func( LocalPlayer(), EyePos(), EyeAngles(), 90, 4, 16000 ) != nil ) or ( !isstring( str ) && func( str, LocalPlayer(), EyePos(), EyeAngles(), 90, 4, 16000 ) != nil ) ) then
				clr = Color( 255, 128, 128 )
			end
			if ( !isstring( str ) ) then str = tostring( str ) end
			if ( str == "" ) then str = "<empty string hook>" end
			local _, lineH = surface.GetTextSize( str )
			draw.SimpleText( str, "SelectedForceHUD", x, y + id * lineH, clr, 1 )
			id = id + 1
		end

		isCalcViewFuckedUp = false
	end

	if ( !isCalcViewFuckedUp2 ) then
		isCalcViewFuckedUp2 = true
	end

	----------------------------------- PLAYERMODEL ERROR

	if ( self:GetIncorrectPlayerModel() != 0 ) then
		local txt = "Server is missing the player model files!\nPlayer model: " .. self.Owner:GetModel()
		if ( self:GetIncorrectPlayerModel() == 2 ) then txt = "The weapon is somehow missing owner!\nPlayer model: " .. self.Owner:GetModel() end
		local tW, tH = surface.GetTextSize( txt )

		y = y - tH - gap

		DrawHUDBox( x - tW / 2 - 5, y, tW + 10, tH )
		for id, str in pairs( string.Explode( "\n", txt ) ) do
			local _, lineH = surface.GetTextSize( str )
			draw.SimpleText( str, "SelectedForceHUD", x, y + ( id - 1 ) * lineH, Color( 255, 200, 200 ), 1 )
		end
	end
end

local Color_White = Color( 255, 255, 255 )
local Color_BLU = Color( 0, 128, 255 )
local ForceBar = 100
local function DrawForceSelectionHUD( ForceSelectEnabled, Force, MaxForce, SelectedPower, ForcePowers )

	local icon = 52
	local gap = 5

	local bar = 4
	local bar2 = 16

	if ( ForceSelectEnabled ) then
		icon = 128
		bar = 8
		bar2 = 24
	end

	----------------------------------- Force Bar -----------------------------------

	ForceBar = math.min( MaxForce, Lerp( 0.1, ForceBar, math.floor( Force ) ) )

	local w = #ForcePowers * icon + ( #ForcePowers - 1 ) * gap
	local h = bar2
	local x = math.floor( ScrW() / 2 - w / 2 )
	local y = ScrH() - gap - bar2

	DrawHUDBox( x, y, w, h )

	local barW = math.ceil( w * ( ForceBar / MaxForce ) )
	if ( Force <= 1 && barW <= 1 ) then barW = 0 end
	draw.RoundedBox( 0, x, y, barW, h, Color_BLU )

	draw.SimpleText( math.floor( Force / MaxForce * 100 ) .. "%", "SelectedForceHUD", x + w / 2, y + h / 2, Color_White, 1, 1 )

	----------------------------------- Force Icons -----------------------------------

	local y = y - icon - gap
	local h = icon

	for id, t in pairs( ForcePowers ) do
		local x = x + ( id - 1 ) * ( h + gap )
		local x2 = math.floor( x + icon / 2 )

		DrawHUDBox( x, y, h, h, SelectedPower == id )

		if ( t.material ) then
			if ( isstring( t.material ) ) then t.material = Material( t.material ) end

			surface.SetMaterial( t.material )
			surface.SetDrawColor( Color_White )

			render.PushFilterMag( TEXFILTER.ANISOTROPIC )
			render.PushFilterMin( TEXFILTER.ANISOTROPIC )
				surface.DrawTexturedRect( x, y, h, h )
			render.PopFilterMag()
			render.PopFilterMin()
		end

		if ( t.icon ) then
			draw.SimpleText( t.icon or "", "SelectedForceType", x2, math.floor( y + icon / 2 ), Color_White, 1, 1 )
		end

		if ( ForceSelectEnabled ) then
			draw.SimpleText( ( input.LookupBinding( "slot" .. id ) or "<NOT BOUND>" ):upper(), "SelectedForceHUD", x + gap, y + gap, Color_White )
		end
		if ( SelectedPower == id ) then
			local y = y + ( icon - bar )
			surface.SetDrawColor( Color_BLU )
			draw.NoTexture()
			surface.DrawPoly( {
				{ x = x2 - bar, y = y },
				{ x = x2, y = y - bar },
				{ x = x2 + bar, y = y }
			} )

			surface.DrawRect( x, y, h, bar )
		end
	end

	----------------------------------- Force Title & Description -----------------------------------

	local selectedForcePower = ForcePowers[ SelectedPower ]

	if ( selectedForcePower && ForceSelectEnabled ) then

		-- Description

		surface.SetFont( "SelectedForceHUD" )
		local tW, tH = surface.GetTextSize( selectedForcePower.description or "" )

		--[[local x = x + w + gap
		local y = y]]
		local x2 = ScrW() / 2 + gap / 2-- - tW / 2
		local y2 = y - tH - gap * 3

		DrawHUDBox( x2, y2, tW + gap * 2, tH + gap * 2 )

		for id, txt in pairs( string.Explode( "\n", selectedForcePower.description or "" ) ) do
			draw.SimpleText( txt, "SelectedForceHUD", x2 + gap, y2 + ( id - 1 ) * ScreenScale( 6 ) + gap, Color_White )
		end

		-- Label

		surface.SetFont( "SelectedForceType" )
		local txt = selectedForcePower.name or ""
		local tW2, tH2 = surface.GetTextSize( txt )

		local x = x + w / 2 - tW2 - gap * 2.5 --+ w / 2
		local y = y + gap - tH2 - gap * 2

		DrawHUDBox( x, y, tW2 + 10, tH2 )
		draw.SimpleText( txt, "SelectedForceType", x + gap, y, Color( 255, 255, 255 ) )

	end

	----------------------------------- Press F to Select -----------------------------------

	if ( !ForceSelectEnabled ) then
		surface.SetFont( "SelectedForceHUD" )
		local txt = "Press " .. ( input.LookupBinding( "impulse 100" ) or "<NOT BOUND>" ):upper() .. " to toggle Force selection"
		local tW, tH = surface.GetTextSize( txt )

		local x = x + w / 2
		local y = y - tH - gap

		DrawHUDBox( x - tW / 2 - 5, y, tW + 10, tH )
		draw.SimpleText( txt, "SelectedForceHUD", x, y, Color_White, 1 )

	end

	return y

end

function SWEP:DrawHUD()
	if ( !IsValid( self.Owner ) or self.Owner:GetViewEntity() != self.Owner or self.Owner:InVehicle() ) then return end

	-----------------------------------

	local ForcePowers = self:GetActiveForcePowers()
	if ( #ForcePowers < 1 ) then self:DrawHUDTargetSelection() return end

	local y = ScrH()

	local ret = hook.Run( "LightsaberDrawHUD", ForceSelectEnabled, self:GetForce(), self:GetMaxForce(), self:GetForceType(), ForcePowers )
	if ( ret == nil ) then
		y = DrawForceSelectionHUD( ForceSelectEnabled, self:GetForce(), self:GetMaxForce(), self:GetForceType(), ForcePowers )
	elseif ( isnumber( ret ) ) then
		y = ret
	end

	self:DrawHUD_FuckedUpHooks( y )

	----------------------------------- Force Target -----------------------------------

	self:DrawHUDTargetSelection()

end

--addons/wos-alcs-custom/lua/weapons/weapon_lightsaber_anakin.lua:
AddCSLuaFile()

SWEP.Author = "Robotboy655 + King David + Oninoni"
SWEP.Category = "Lichtschwerter (Lore Chars)"
SWEP.Contact = ""
SWEP.RenderGroup = RENDERGROUP_BOTH
SWEP.Slot = 0
SWEP.SlotPos = 4
SWEP.Spawnable = true
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.DrawWeaponInfoBox = false
SWEP.ViewModel = "models/weapons/v_crowbar.mdl"
SWEP.WorldModel = "models/sgg/starwars/weapons/w_anakin_ep2_saber_hilt.mdl"
SWEP.ViewModelFOV = 55
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

------------------------------------------------------------THINGS YOU WILL EDIT ARE BELOW HERE-------------------------------------------------------------------------
SWEP.PrintName = "Anakin Skywalker" --Name of the lightsaber
SWEP.Class = "weapon_lightsaber_anakin" --The file name of this swep
SWEP.DualWielded = false --Should this be a dual wielded saber?
SWEP.CanMoveWhileAttacking = true -- Can the user move while attacking
SWEP.SaberDamage = 150 --How much damage the saber does when it's being swung
SWEP.SaberBurnDamage = 25 -- How much damage the saber does when it's colliding with someone ( coming in contact with laser )
SWEP.MaxForce = 100 --The maximum amount of force in the meter
SWEP.MaxStamina = 100 --The maximum amount of stamina in the meter
SWEP.RegenSpeed = 2 --The MULTIPLIER for the regen speed. Half speed = 0.5, Double speed = 2, etc.
SWEP.CanKnockback = true --Should this saber be able to push people back when they get hit?
SWEP.MaxBlockAngle = 135
SWEP.BlasterBlockCost = 2
SWEP.BladeBlockCost = 3
SWEP.ForcePowerList = {
	"Machtsprung",
	"Machtschub",
	"Machtzug",
	"Macht-Geschwindigkeit",
	"Macht-Griff",
	"Macht-Öffnung",
	"Macht-Beben",
	"Lähmender Schlag",
	"Macht-Würgegriff",
	"Lichtschwertwurf",
	"Machtstoß",
	"Macht-Stürmen",
	"Machtspiegel",
	"Macht-Sicht",
	"Atemkontrolle",
	"Schwert-Barriere",
	"Machtschrei",
	"Großer Macht-Würgegriff",
	"Beinhieb",
	"Klingensturm",
	"Willenskraft",
	"Macht-Entwaffnen"
}
--Force powers you want the saber to have ( REMEMBER TO PUT A COMMA AFTER EACH ONE, AND COPY THE TITLE EXACTLY AS IT'S LISTED )
--For a list of options, just look at the keys in autorun/client/wos_forcematerialbuilding.lua

SWEP.BlockDrainRate = 0

SWEP.UseForms = {
	["Form I | Shii-Cho"] = {1, 2, 3},
	["Form IV | Ataru"]   = {1, 2, 3},
	["Form V | Djem So"]  = {1, 2, 3},
	["Form VI | Niman"]   = {1, 2, 3},
	["Form VII | Juyo"]   = {1, 2, 3},
	["Form VII | Vaapad"] = {1, 2, 3}
}

--Use these options to overwrite the player's commands
SWEP.UseHilt = "models/sgg/starwars/weapons/w_anakin_ep3_saber_hilt.mdl" -- Model path of the hilt
SWEP.UseLength = 45 -- Length of the saber 
SWEP.UseWidth = 2 -- Width of the saber
SWEP.UseColor = Color(0, 0, 255) -- RGB Color of saber. Red = Color( 255, 0, 0 ) Blue = Color( 0, 0, 255 ), etc.
SWEP.UseDarkInner = 0 -- Does it have a dark inner? 1 = true
SWEP.UseLoopSound = "lightsaber/saber_loop1.wav" -- The loop sound path
SWEP.UseSwingSound = false -- The swing sound path
SWEP.UseOnSound = "lightsaber/saber_on1.wav" -- The on sound path
SWEP.UseOffSound = "lightsaber/saber_off1.wav" -- The off sound path

--These are the ones for the second saber for dual wielding. If you are using a single saber, this doesn't do shit
SWEP.UseSecHilt = false
SWEP.UseSecLength = false
SWEP.UseSecWidth = false
SWEP.UseSecColor = false
SWEP.UseSecDarkInner = 0

-----------------------------------------------------------END OF EDIT----------------------------------------------------------------
if !SWEP.DualWielded then
	SWEP.Base = "wos_adv_single_lightsaber_base"
else
	SWEP.Base = "wos_adv_dual_lightsaber_base"
end

if CLIENT then
	killicon.Add( SWEP.Class, "lightsaber/lightsaber_killicon", color_white )
end

--addons/wos-alcs-custom/lua/weapons/weapon_lightsaber_blade.lua:
AddCSLuaFile()

SWEP.Author = "Robotboy655 + King David + Oninoni"
SWEP.Category = "Lichtschwerter (Event)"
SWEP.Contact = ""
SWEP.RenderGroup = RENDERGROUP_BOTH
SWEP.Slot = 0
SWEP.SlotPos = 4
SWEP.Spawnable = true
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.DrawWeaponInfoBox = false
SWEP.ViewModel = "models/weapons/v_crowbar.mdl"
SWEP.WorldModel = "models/swtor/weapons/electroblade_mtx01_a01_v01.mdl"
SWEP.ViewModelFOV = 55
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

------------------------------------------------------------THINGS YOU WILL EDIT ARE BELOW HERE-------------------------------------------------------------------------
SWEP.PrintName = "Vibromesser" --Name of the lightsaber
SWEP.Class = "weapon_lightsaber_blade" --The file name of this swep
SWEP.DualWielded = false --Should this be a dual wielded saber?
SWEP.CanMoveWhileAttacking = true -- Can the user move while attacking
SWEP.SaberDamage = 100 --How much damage the saber does when it's being swung
SWEP.SaberBurnDamage = 25 -- How much damage the saber does when it's colliding with someone ( coming in contact with laser )
SWEP.MaxForce = 0 --The maximum amount of force in the meter
SWEP.MaxStamina = 100 --The maximum amount of stamina in the meter
SWEP.RegenSpeed = 1 --The MULTIPLIER for the regen speed. Half speed = 0.5, Double speed = 2, etc.
SWEP.CanKnockback = true --Should this saber be able to push people back when they get hit?
SWEP.MaxBlockAngle = 135
SWEP.BlasterBlockCost = 5
SWEP.BladeBlockCost = 5
SWEP.ForcePowerList = {}

SWEP.BlockDrainRate = 0

SWEP.UseForms = {
	["Form I | Shii-Cho"] = {1, 2, 3},
	["Form IV | Ataru"] = {1, 3},
	["Form VI | Niman"] = {1, 2, 3}
}

SWEP.CustomSettings = {
	[ "Blade" ] = "Sharp",
}

SWEP.AllowFallDamage = true

--Use these options to overwrite the player's commands
SWEP.UseHilt = "models/swtor/weapons/electroblade_mtx01_a01_v01.mdl" -- Model path of the hilt
SWEP.UseLength = 12 -- Length of the saber
SWEP.UseWidth = 0.5 -- Width of the saber
SWEP.UseColor = Color(250, 158, 54) -- RGB Color of saber. Red = Color( 255, 0, 0 ) Blue = Color( 0, 0, 255 ), etc.
SWEP.UseDarkInner = 0 -- Does it have a dark inner? 1 = true
SWEP.UseLoopSound = "lightsaber/darksaber_loop.wav" -- The loop sound path
SWEP.UseSwingSound = "lightsaber/darksaber_swing.wav" -- The swing sound path
SWEP.UseOnSound = "lightsaber/darksaber_on.wav" -- The on sound path
SWEP.UseOffSound = "lightsaber/darksaber_off.wav" -- The off sound path

--These are the ones for the second saber for dual wielding. If you are using a single saber, this doesn't do shit
SWEP.UseSecHilt = false
SWEP.UseSecLength = false
SWEP.UseSecWidth = false
SWEP.UseSecColor = false
SWEP.UseSecDarkInner = 0

-----------------------------------------------------------END OF EDIT---------------------------------------------------------------
if !SWEP.DualWielded then
	SWEP.Base = "wos_adv_single_lightsaber_base"
else
	SWEP.Base = "wos_adv_dual_lightsaber_base"
end

if CLIENT then
	killicon.Add( SWEP.Class, "lightsaber/lightsaber_killicon", color_white )
end

--addons/wos-alcs-custom/lua/weapons/weapon_lightsaber_dralligdual.lua:
AddCSLuaFile()

SWEP.Author = "Robotboy655 + King David + Oninoni"
SWEP.Category = "Lichtschwerter (Lore Chars)"
SWEP.Contact = ""
SWEP.RenderGroup = RENDERGROUP_BOTH
SWEP.Slot = 0
SWEP.SlotPos = 4
SWEP.Spawnable = true
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.DrawWeaponInfoBox = false
SWEP.ViewModel = "models/weapons/v_crowbar.mdl"
SWEP.WorldModel = "models/sgg/starwars/weapons/w_anakin_ep2_saber_hilt.mdl"
SWEP.ViewModelFOV = 55
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

------------------------------------------------------------THINGS YOU WILL EDIT ARE BELOW HERE-------------------------------------------------------------------------
SWEP.PrintName = "Cin Drallig - Dual" --Name of the lightsaber
SWEP.Class = "weapon_lightsaber_dralligdual" --The file name of this swep
SWEP.DualWielded = true --Should this be a dual wielded saber?
SWEP.CanMoveWhileAttacking = true -- Can the user move while attacking
SWEP.SaberDamage = 150 --How much damage the saber does when it's being swung
SWEP.SaberBurnDamage = 25 -- How much damage the saber does when it's colliding with someone ( coming in contact with laser )
SWEP.MaxForce = 100 --The maximum amount of force in the meter
SWEP.MaxStamina = 100 --The maximum amount of stamina in the meter
SWEP.RegenSpeed = 2 --The MULTIPLIER for the regen speed. Half speed = 0.5, Double speed = 2, etc.
SWEP.CanKnockback = true --Should this saber be able to push people back when they get hit?
SWEP.MaxBlockAngle = 135
SWEP.BlasterBlockCost = 2
SWEP.BladeBlockCost = 3
SWEP.ForcePowerList = {
	"Machtsprung",
	"Machtspiegel",
	"Machtschub",
	"Machtstoß",
	"Machtzug",
	"Macht-Sicht",
	"Macht-Geschwindigkeit",
	"Lichtschwertwurf",
	"Macht-Öffnung",
	"Macht-Griff",
	"Großer Machtschub",
	"Großer Machtzug",
	"Macht-Stürmen",
	"Schwert-Barriere",
	"Lähmender Schlag",
	"Atemkontrolle",
	"Macht-Beben",
	"Beinhieb",
	"Macht-Entwaffnen",
	"Willenskraft"
}

SWEP.BlockDrainRate = 0

SWEP.UseForms = {
	["Form VI | Niman"]   = {1, 2, 3},
	["Form IV | Ataru"]   = {1, 2, 3},
	["Form VII | Vaapad"] = {1, 2, 3}
}

--Use these options to overwrite the player's commands
SWEP.UseHilt = "models/swtor/arsenic/lightsabers/unstablepeacemaker'slightsaber.mdl" -- Model path of the hilt
SWEP.UseLength = 45 -- Length of the saber
SWEP.UseWidth = 2 -- Width of the saber
SWEP.UseColor = Color(11, 138, 75) -- RGB Color of saber. Red = Color( 255, 0, 0 ) Blue = Color( 0, 0, 255 ), etc.
SWEP.UseDarkInner = 0 -- Does it have a dark inner? 1 = true
SWEP.UseLoopSound = "lightsaber/saber_loop1.wav" -- The loop sound path
SWEP.UseSwingSound = false -- The swing sound path
SWEP.UseOnSound = "lightsaber/saber_on1.wav" -- The on sound path
SWEP.UseOffSound = "lightsaber/saber_off1.wav" -- The off sound path

--These are the ones for the second saber for dual wielding. If you are using a single saber, this doesn't do shit
SWEP.UseSecHilt = "models/swtor/arsenic/lightsabers/unstablepeacemaker'slightsaber.mdl"
SWEP.UseSecLength = 45
SWEP.UseSecWidth = 2
SWEP.UseSecColor = Color(225, 205, 0)
SWEP.UseSecDarkInner = 0


-----------------------------------------------------------END OF EDIT----------------------------------------------------------------


if !SWEP.DualWielded then
	SWEP.Base = "wos_adv_single_lightsaber_base"
else
	SWEP.Base = "wos_adv_dual_lightsaber_base"
end

if CLIENT then
	killicon.Add( SWEP.Class, "lightsaber/lightsaber_killicon", color_white )
end

--addons/wos-alcs-custom/lua/weapons/weapon_lightsaber_electrostaff.lua:
AddCSLuaFile()

SWEP.Author = "Robotboy655 + King David + Oninoni"
SWEP.Category = "Lichtschwerter (Event)"
SWEP.Contact = ""
SWEP.RenderGroup = RENDERGROUP_BOTH
SWEP.Slot = 0
SWEP.SlotPos = 4
SWEP.Spawnable = true
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.DrawWeaponInfoBox = false
SWEP.ViewModel = "models/weapons/v_crowbar.mdl"
SWEP.WorldModel = "models/oninoni/prp_magna_guard_weapon_combined.mdl"
SWEP.ViewModelFOV = 55
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"
SWEP.IsElectroStaff = true

------------------------------------------------------------THINGS YOU WILL EDIT ARE BELOW HERE-------------------------------------------------------------------------
SWEP.PrintName = "Elektrostab" --Name of the lightsaber
SWEP.Class = "weapon_lightsaber_electrostaff" --The file name of this swep
SWEP.DualWielded = false --Should this be a dual wielded saber?
SWEP.CanMoveWhileAttacking = true -- Can the user move while attacking
SWEP.SaberDamage = 35 --How much damage the saber does when it's being swung
SWEP.SaberBurnDamage = 25 -- How much damage the saber does when it's colliding with someone ( coming in contact with laser )
SWEP.MaxForce = 0 --The maximum amount of force in the meter
SWEP.MaxStamina = 100 --The maximum amount of stamina in the meter
SWEP.RegenSpeed = 1 --The MULTIPLIER for the regen speed. Half speed = 0.5, Double speed = 2, etc.
SWEP.CanKnockback = true --Should this saber be able to push people back when they get hit?
SWEP.MaxBlockAngle = 135
SWEP.BlasterBlockCost = 5
SWEP.BladeBlockCost = 5
SWEP.ForcePowerList = {
	"Beinhieb",
}

SWEP.BlockDrainRate = 0

SWEP.UseForms = {
	["Form I | Shii-Cho"] = {1, 2, 3},
	["Form II | Makashi"] = {1, 2, 3},
	["Form III | Soresu"] = {1, 2, 3},
	["Form IV | Ataru"]   = {1, 2, 3},
	["Form V | Djem So"]  = {1, 2, 3},
	["Form VI | Niman"]   = {1, 2, 3},
	["Form VII | Juyo"]   = {1, 2, 3},
	["Form VII | Vaapad"] = {1, 2, 3}
}

SWEP.CustomSettings = {
	[ "Blade" ] = "Corrupted"
}

SWEP.AllowFallDamage = true

--Use these options to overwrite the player's commands
SWEP.UseHilt = "models/oninoni/prp_magna_guard_weapon_combined.mdl" -- Model path of the hilt
SWEP.UseLength = 15 -- Length of the saber
SWEP.UseWidth = 2.5 -- Width of the saber
SWEP.UseColor = Color(63, 0, 255) -- RGB Color of saber. Red = Color( 255, 0, 0 ) Blue = Color( 0, 0, 255 ), etc.
SWEP.UseDarkInner = 1 -- Does it have a dark inner? 1 = true
SWEP.UseLoopSound = "lightsaber/saber_loop1.wav" -- The loop sound path
SWEP.UseSwingSound = false -- The swing sound path
SWEP.UseOnSound = "lightsaber/saber_on1.wav" -- The on sound path
SWEP.UseOffSound = "lightsaber/saber_off1.wav" -- The off sound path

--These are the ones for the second saber for dual wielding. If you are using a single saber, this doesn't do shit
SWEP.UseSecHilt = false
SWEP.UseSecLength = false
SWEP.UseSecWidth = false
SWEP.UseSecColor = false
SWEP.UseSecDarkInner = 0

hook.Add("EntityTakeDamage", "Elektrostaff.StunOnHit", function(ply, dmgInfo)
	local inflictor = dmgInfo:GetInflictor()

	if IsValid(inflictor) and inflictor.IsElectroStaff then
		if ply:IsPlayer() then
			local percent = math.random()
			if percent > 0.8 then
				ply:SetNW2Float("wOS.SaberAttackDelay", CurTime() + 1)
				ply.StasisTime = CurTime() + 1
			else
				ply.SlowTime = CurTime() + 2
			end
		else
			dmgInfo:SetDamage(150)
		end
	end
end)


-----------------------------------------------------------END OF EDIT----------------------------------------------------------------
if !SWEP.DualWielded then
	SWEP.Base = "wos_adv_single_lightsaber_base"
else
	SWEP.Base = "wos_adv_dual_lightsaber_base"
end

if CLIENT then
	killicon.Add( SWEP.Class, "lightsaber/lightsaber_killicon", color_white )
end

SWEP.HolsterOffset = Vector(5, 0, 3)
SWEP.HolsterAngle = Angle(0, 90, 0)
--addons/wos-alcs-custom/lua/weapons/weapon_lightsaber_kcaj.lua:
AddCSLuaFile()

SWEP.Author = "Robotboy655 + King David + Oninoni"
SWEP.Category = "Lichtschwerter (Lore Chars)"
SWEP.Contact = ""
SWEP.RenderGroup = RENDERGROUP_BOTH
SWEP.Slot = 0
SWEP.SlotPos = 4
SWEP.Spawnable = true
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.DrawWeaponInfoBox = false
SWEP.ViewModel = "models/weapons/v_crowbar.mdl"
SWEP.WorldModel = "models/swtor/arsenic/lightsabers/temptedapprentice'slightsaber.mdl"
SWEP.ViewModelFOV = 55
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

------------------------------------------------------------THINGS YOU WILL EDIT ARE BELOW HERE-------------------------------------------------------------------------
SWEP.PrintName = "Coleman Kcaj" --Name of the lightsaber
SWEP.Class = "weapon_lightsaber_kcaj" --The file name of this swep
SWEP.DualWielded = false --Should this be a dual wielded saber?
SWEP.CanMoveWhileAttacking = true -- Can the user move while attacking
SWEP.SaberDamage = 150 --How much damage the saber does when it's being swung
SWEP.SaberBurnDamage = 25 -- How much damage the saber does when it's colliding with someone ( coming in contact with laser )
SWEP.MaxForce = 100 --The maximum amount of force in the meter
SWEP.MaxStamina = 100 --The maximum amount of stamina in the meter
SWEP.RegenSpeed = 2 --The MULTIPLIER for the regen speed. Half speed = 0.5, Double speed = 2, etc.
SWEP.CanKnockback = true --Should this saber be able to push people back when they get hit?
SWEP.MaxBlockAngle = 135
SWEP.BlasterBlockCost = 2
SWEP.BladeBlockCost = 3
SWEP.ForcePowerList = {
	"Machtsprung",
	"Machtspiegel",
	"Machtschub",
	"Machtzug",
	"Macht-Geschwindigkeit",
	"Lichtschwertwurf",
	"Atemkontrolle",
	"Meditieren",
	"Macht-Öffnung",
	"Macht-Sicht",
	"Macht-Griff",
	"Großer Machtschub",
	"Großer Machtzug",
	"Macht-Teleportation",
	"Energiestrahl",
	"Macht-Induktion",
	"Smaragdblitze",
	"Machtschild",
	"Macht-Verlangsamung",
	"Flamusfracta",
	"Kristallschlag",
	"Blenden",
	"Machtstoß",
	"Macht-Stasis",
	"Willenskraft",
	"Machtblockade",
	"Macht-Entwaffnen"
}

SWEP.DevestatorList = { "Schallentladung", "Flammenschauer" }

SWEP.BlockDrainRate = 0

SWEP.UseForms = {
	["Form I | Shii-Cho"] = {1, 2, 3},
	["Form III | Soresu"] = {1, 2, 3},
	["Form V | Djem So"]  = {1, 2, 3},
	["Form VI | Niman"]   = {1, 2, 3},
}

--Use these options to overwrite the player's commands
SWEP.UseHilt = "models/swtor/arsenic/lightsabers/temptedapprentice'slightsaber.mdl" -- Model path of the hilt
SWEP.UseLength = 45 -- Length of the saber
SWEP.UseWidth = 2 -- Width of the saber
SWEP.UseColor = Color( 33, 240, 0 ) -- RGB Color of saber. Red = Color( 255, 0, 0 ) Blue = Color( 0, 0, 255 ), etc.
SWEP.UseDarkInner = 0 -- Does it have a dark inner? 1 = true
SWEP.UseLoopSound = "lightsaber/saber_loop1.wav" -- The loop sound path
SWEP.UseSwingSound = false -- The swing sound path
SWEP.UseOnSound = "lightsaber/saber_on1.wav" -- The on sound path
SWEP.UseOffSound = "lightsaber/saber_off1.wav" -- The off sound path

--These are the ones for the second saber for dual wielding. If you are using a single saber, this doesn't do shit
SWEP.UseSecHilt = false
SWEP.UseSecLength = false
SWEP.UseSecWidth = false
SWEP.UseSecColor = false
SWEP.UseSecDarkInner = 0


-----------------------------------------------------------END OF EDIT----------------------------------------------------------------


if !SWEP.DualWielded then
	SWEP.Base = "wos_adv_single_lightsaber_base"
else
	SWEP.Base = "wos_adv_dual_lightsaber_base"
end

if CLIENT then
	killicon.Add( SWEP.Class, "lightsaber/lightsaber_killicon", color_white )
end

--addons/wos-alcs-custom/lua/weapons/weapon_lightsaber_palpatine.lua:


AddCSLuaFile()

SWEP.Author = "Robotboy655 + King David + Oninoni"
SWEP.Category = "Lichtschwerter (Event)"
SWEP.Contact = ""
SWEP.RenderGroup = RENDERGROUP_BOTH
SWEP.Slot = 0
SWEP.SlotPos = 4
SWEP.Spawnable = true
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.DrawWeaponInfoBox = false
SWEP.ViewModel = "models/weapons/v_crowbar.mdl"
SWEP.WorldModel = "models/sgg/starwars/weapons/w_sidious_saber_hilt.mdl"
SWEP.ViewModelFOV = 55
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

------------------------------------------------------------THINGS YOU WILL EDIT ARE BELOW HERE-------------------------------------------------------------------------
SWEP.PrintName = "Darth Sidious" --Name of the lightsaber
SWEP.Class = "weapon_lightsaber_palpatine" --The file name of this swep
SWEP.DualWielded = false --Should this be a dual wielded saber?
SWEP.CanMoveWhileAttacking = true -- Can the user move while attacking
SWEP.SaberDamage = 150 --How much damage the saber does when it's being swung
SWEP.SaberBurnDamage = 25 -- How much damage the saber does when it's colliding with someone ( coming in contact with laser )
SWEP.MaxForce = 500 --The maximum amount of force in the meter
SWEP.RegenSpeed = 2 --The MULTIPLIER for the regen speed. Half speed = 0.5, Double speed = 2, etc.
SWEP.CanKnockback = true --Should this saber be able to push people back when they get hit?
SWEP.MaxBlockAngle = 135
SWEP.BlasterBlockCost = 2
SWEP.BladeBlockCost = 3
SWEP.ForcePowerList = {
	"Macht-Geschwindigkeit",
	"Machtsprung",
	"Machtspiegel",
	"Machtschub",
	"Machtzug",
	"Macht-Stürmen",
	"Macht-Seuche",
	"Lähmender Schlag",
	"Macht-Sicht",
	"Kristallschlag",
	"Flamusfracta",
	"Lichtschwertwurf",
	"Machtblitze",
	"Blitzschlag",
	"Machtsturm",
	"Machtschrei",
	"Hass kanalisieren",
	"Kettenblitz",
	"Macht-Würgegriff",
	"Großer Macht-Würgegriff",
	"Blutopfer",
	"Beinhieb",
	"Dunkelschlag",
	"Machtblockade",
	"Klingensturm",
	"Willenskraft"
}

SWEP.DevestatorList = { "Blitzentladung", "Flammenschauer", "Innere Furcht" }

SWEP.BlockDrainRate = 0

SWEP.UseForms = {
	["Form I | Shii-Cho"] = {1, 2, 3},
	["Form II | Makashi"] = {1, 2, 3},
	["Form III | Soresu"] = {1, 2, 3},
	["Form IV | Ataru"]   = {1, 2, 3},
	["Form V | Djem So"]  = {1, 2, 3},
	["Form VI | Niman"]   = {1, 2, 3},
	["Form VII | Juyo"]   = {1, 2, 3},
	["Form VII | Vaapad"] = {1, 2, 3}
}

--Use these options to overwrite the player's commands
SWEP.UseHilt = "models/sgg/starwars/weapons/w_sidious_saber_hilt.mdl" -- Model path of the hilt
SWEP.UseLength = 45 -- Length of the saber
SWEP.UseWidth = 2 -- Width of the saber
SWEP.UseColor = Color(255, 0, 0) -- RGB Color of saber. Red = Color( 255, 0, 0 ) Blue = Color( 0, 0, 255 ), etc.
SWEP.UseDarkInner = 0 -- Does it have a dark inner? 1 = true
SWEP.UseLoopSound = "lightsaber/saber_loop6.wav" -- The loop sound path
SWEP.UseSwingSound = false -- The swing sound path
SWEP.UseOnSound = "lightsaber/saber_on2.wav" -- The on sound path
SWEP.UseOffSound = "lightsaber/saber_off2.wav" -- The off sound path

--These are the ones for the second saber for dual wielding. If you are using a single saber, this doesn't do shit
SWEP.UseSecHilt = false
SWEP.UseSecLength = false
SWEP.UseSecWidth = false
SWEP.UseSecColor = false
SWEP.UseSecDarkInner = 0


-----------------------------------------------------------END OF EDIT----------------------------------------------------------------


if !SWEP.DualWielded then
	SWEP.Base = "wos_adv_single_lightsaber_base"
else
	SWEP.Base = "wos_adv_dual_lightsaber_base"
end

if CLIENT then
	killicon.Add( SWEP.Class, "lightsaber/lightsaber_killicon", color_white )
end

--addons/wos-alcs-custom/lua/weapons/weapon_lightsaber_savage.lua:
AddCSLuaFile()

SWEP.Author = "Robotboy655 + King David + Oninoni"
SWEP.Category = "Lichtschwerter (Event)"
SWEP.Contact = ""
SWEP.RenderGroup = RENDERGROUP_BOTH
SWEP.Slot = 0
SWEP.SlotPos = 4
SWEP.Spawnable = true
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.DrawWeaponInfoBox = false
SWEP.ViewModel = "models/weapons/v_crowbar.mdl"
SWEP.WorldModel = "models/weapons/starwars/w_maul_saber_staff_hilt.mdl"
SWEP.ViewModelFOV = 55

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

------------------------------------------------------------THINGS YOU WILL EDIT ARE BELOW HERE-------------------------------------------------------------------------
SWEP.PrintName = "Savage Opress" --Name of the lightsaber
SWEP.Class = "weapon_lightsaber_savage" --The file name of this swep
SWEP.DualWielded = false --Should this be a dual wielded saber?
SWEP.CanMoveWhileAttacking = true -- Can the user move while attacking
SWEP.SaberDamage = 150 --How much damage the saber does when it's being swung
SWEP.SaberBurnDamage = 25 -- How much damage the saber does when it's colliding with someone ( coming in contact with laser )
SWEP.MaxForce = 100 --The maximum amount of force in the meter
SWEP.MaxStamina = 100 --The maximum amount of stamina in the meter
SWEP.RegenSpeed = 2 --The MULTIPLIER for the regen speed. Half speed = 0.5, Double speed = 2, etc.
SWEP.CanKnockback = true --Should this saber be able to push people back when they get hit?
SWEP.MaxBlockAngle = 135
SWEP.BlasterBlockCost = 2
SWEP.BladeBlockCost = 3
SWEP.ForcePowerList = {
	"Machtsprung",
	"Machtschub",
	"Machtzug",
	"Macht-Geschwindigkeit",
	"Macht-Stürmen",
	"Lichtschwertwurf",
	"Machtstoß",
	"Machtschrei",
	"Macht-Sicht",
	"Macht-Würgegriff",
	"Großer Macht-Würgegriff",
	"Dunkelschlag",
	"Willenskraft"
}

SWEP.DevestatorList = {}

SWEP.BlockDrainRate = 0

SWEP.UseForms = {
	["Form I | Shii-Cho"] = {1, 2, 3},
	["Form IV | Ataru"]   = {1, 2, 3},
	["Form VII | Vaapad"] = {1, 2, 3}
}

--Use these options to overwrite the player's commands
SWEP.UseHilt = "models/weapons/starwars/w_maul_saber_staff_hilt.mdl" -- Model path of the hilt
SWEP.UseLength = 45 -- Length of the saber 
SWEP.UseWidth = 2 -- Width of the saber
SWEP.UseColor = Color(255, 0, 0) -- RGB Color of saber. Red = Color( 255, 0, 0 ) Blue = Color( 0, 0, 255 ), etc.
SWEP.UseDarkInner = 0 -- Does it have a dark inner? 1 = true
SWEP.UseLoopSound = "lightsaber/saber_loop6.wav" -- The loop sound path
SWEP.UseSwingSound = false -- The swing sound path
SWEP.UseOnSound = "lightsaber/saber_on2_fast.wav" -- The on sound path
SWEP.UseOffSound = "lightsaber/saber_off2_fast.wav" -- The off sound path

--These are the ones for the second saber for dual wielding. If you are using a single saber, this doesn't do shit
SWEP.UseSecHilt = false
SWEP.UseSecLength = false
SWEP.UseSecWidth = false
SWEP.UseSecColor = false
SWEP.UseSecDarkInner = 0

-----------------------------------------------------------END OF EDIT----------------------------------------------------------------
if !SWEP.DualWielded then
	SWEP.Base = "wos_adv_single_lightsaber_base"
else
	SWEP.Base = "wos_adv_dual_lightsaber_base"
end

if CLIENT then
	killicon.Add( SWEP.Class, "lightsaber/lightsaber_killicon", color_white )
end

--addons/wos-alcs-custom/lua/weapons/weapon_lightsaber_templeguard.lua:
AddCSLuaFile()

SWEP.Author = "Robotboy655 + King David + Oninoni"
SWEP.Category = "Lichtschwerter"
SWEP.Contact = ""
SWEP.RenderGroup = RENDERGROUP_BOTH
SWEP.Slot = 0
SWEP.SlotPos = 4
SWEP.Spawnable = true
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.DrawWeaponInfoBox = false
SWEP.ViewModel = "models/weapons/v_crowbar.mdl"
SWEP.WorldModel = "models/twinsaber/twinsaber.mdl"
SWEP.ViewModelFOV = 55
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

------------------------------------------------------------THINGS YOU WILL EDIT ARE BELOW HERE-------------------------------------------------------------------------
SWEP.PrintName = "Tempelwächter" --Name of the lightsaber
SWEP.Class = "weapon_lightsaber_templeguard" --The file name of this swep
SWEP.DualWielded = false --Should this be a dual wielded saber?
SWEP.CanMoveWhileAttacking = true -- Can the user move while attacking
SWEP.SaberDamage = 150 --How much damage the saber does when it's being swung
SWEP.SaberBurnDamage = 25 -- How much damage the saber does when it's colliding with someone ( coming in contact with laser )
SWEP.MaxForce = 100 --The maximum amount of force in the meter
SWEP.MaxStamina = 100 --The maximum amount of stamina in the meter
SWEP.RegenSpeed = 2 --The MULTIPLIER for the regen speed. Half speed = 0.5, Double speed = 2, etc.
SWEP.CanKnockback = true --Should this saber be able to push people back when they get hit?
SWEP.MaxBlockAngle = 135
SWEP.BlasterBlockCost = 2
SWEP.BladeBlockCost = 3
SWEP.ForcePowerList = {
	"Machtsprung",
	"Machtzug",
	"Machtschub",
	"Lichtschwertwurf",
	"Macht-Beben",
	"Beinhieb",
	"Macht-Öffnung",
	"Klingensturm",
	"Machtspiegel",
	"Machtschild",
	"Macht-Geschwindigkeit",
	"Macht-Entwaffnen",
	"Macht-Griff",
	"Willenskraft"
}

SWEP.BlockDrainRate = 0

SWEP.UseForms = {
	["Form I | Shii-Cho"] = {1, 2, 3},
	["Form III | Soresu"] = {1, 2, 3},
	["Form IV | Ataru"]   = {1, 2, 3},
}

--Use these options to overwrite the player's commands
SWEP.UseHilt = "models/twinsaber/twinsaber.mdl" -- Model path of the hilt
SWEP.UseLength = 45 -- Length of the saber 
SWEP.UseWidth = 2 -- Width of the saber
SWEP.UseColor = Color(225, 255, 0) -- RGB Color of saber. Red = Color( 255, 0, 0 ) Blue = Color( 0, 0, 255 ), etc.
SWEP.UseDarkInner = 0 -- Does it have a dark inner? 1 = true
SWEP.UseLoopSound = "lightsaber/saber_loop1.wav" -- The loop sound path
SWEP.UseSwingSound = false -- The swing sound path
SWEP.UseOnSound = "lightsaber/saber_on1.wav" -- The on sound path
SWEP.UseOffSound = "lightsaber/saber_off1.wav" -- The off sound path

--These are the ones for the second saber for dual wielding. If you are using a single saber, this doesn't do shit
SWEP.UseSecHilt = false
SWEP.UseSecLength = false
SWEP.UseSecWidth = false
SWEP.UseSecColor = false
SWEP.UseSecDarkInner = 0

-----------------------------------------------------------END OF EDIT----------------------------------------------------------------
if !SWEP.DualWielded then
	SWEP.Base = "wos_adv_single_lightsaber_base"
else
	SWEP.Base = "wos_adv_dual_lightsaber_base"
end

if CLIENT then
	killicon.Add( SWEP.Class, "lightsaber/lightsaber_killicon", color_white )
end

--addons/wos-alcs-custom/lua/weapons/weapon_lightsaber_tholme.lua:
AddCSLuaFile()

SWEP.Author = "Robotboy655 + King David + Oninoni"
SWEP.Category = "Lichtschwerter (Lore Chars)"
SWEP.Contact = ""
SWEP.RenderGroup = RENDERGROUP_BOTH
SWEP.Slot = 0
SWEP.SlotPos = 4
SWEP.Spawnable = true
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.DrawWeaponInfoBox = false
SWEP.ViewModel = "models/weapons/v_crowbar.mdl"
SWEP.WorldModel = "models/starwars/cwa/lightsabers/forked.mdl"
SWEP.ViewModelFOV = 55
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

------------------------------------------------------------THINGS YOU WILL EDIT ARE BELOW HERE-------------------------------------------------------------------------
SWEP.PrintName = "Tholme" --Name of the lightsaber
SWEP.Class = "weapon_lightsaber_tholme" --The file name of this swep
SWEP.DualWielded = false --Should this be a dual wielded saber?
SWEP.CanMoveWhileAttacking = true -- Can the user move while attacking
SWEP.SaberDamage = 150 --How much damage the saber does when it's being swung
SWEP.SaberBurnDamage = 25 -- How much damage the saber does when it's colliding with someone ( coming in contact with laser )
SWEP.MaxForce = 100 --The maximum amount of force in the meter
SWEP.MaxStamina = 100 --The maximum amount of stamina in the meter
SWEP.RegenSpeed = 2 --The MULTIPLIER for the regen speed. Half speed = 0.5, Double speed = 2, etc.
SWEP.CanKnockback = true --Should this saber be able to push people back when they get hit?
SWEP.MaxBlockAngle = 135
SWEP.BlasterBlockCost = 2
SWEP.BladeBlockCost = 3
SWEP.ForcePowerList = {
	"Macht-Geschwindigkeit",
	"Machtsprung",
	"Atemkontrolle",
	"Machtspiegel",
	"Machtschub",
	"Machtzug",
	"Lichtschwertwurf",
	"Macht-Stürmen",
	"Machtstoß",
	"Macht-Öffnung",
	"Schwert-Barriere",
	"Großer Machtschub",
	"Großer Machtzug",
	"Macht-Sicht",
	"Macht-Griff",
	"Machttarnung",
	"Schattenschlag",
	"Machtheilung",
	"Selbstheilung",
	"Willenskraft",
	"Macht-Entwaffnen"
}

SWEP.BlockDrainRate = 0

SWEP.UseForms = {
	["Form I | Shii-Cho"] = {1, 2, 3},
	["Form II | Makashi"] = {1, 2, 3},
}

--Use these options to overwrite the player's commands
SWEP.UseHilt = "models/starwars/cwa/lightsabers/forked.mdl" -- Model path of the hilt
SWEP.UseLength = 45 -- Length of the saber 
SWEP.UseWidth = 2 -- Width of the saber
SWEP.UseColor = Color(5, 70, 20) -- RGB Color of saber. Red = Color( 255, 0, 0 ) Blue = Color( 0, 0, 255 ), etc.
SWEP.UseDarkInner = 0 -- Does it have a dark inner? 1 = true
SWEP.UseLoopSound = "lightsaber/saber_loop1.wav" -- The loop sound path
SWEP.UseSwingSound = false -- The swing sound path
SWEP.UseOnSound = "lightsaber/saber_on1.wav" -- The on sound path
SWEP.UseOffSound = "lightsaber/saber_off1.wav" -- The off sound path

--These are the ones for the second saber for dual wielding. If you are using a single saber, this doesn't do shit
SWEP.UseSecHilt = false
SWEP.UseSecLength = false
SWEP.UseSecWidth = false
SWEP.UseSecColor = false
SWEP.UseSecDarkInner = 0


-----------------------------------------------------------END OF EDIT---------------------------------------------------------------
if !SWEP.DualWielded then
	SWEP.Base = "wos_adv_single_lightsaber_base"
else
	SWEP.Base = "wos_adv_dual_lightsaber_base"
end

if CLIENT then
	killicon.Add( SWEP.Class, "lightsaber/lightsaber_killicon", color_white )
end

--addons/wos-alcs-custom/lua/weapons/weapon_lightsaber_tiin.lua:
AddCSLuaFile()

SWEP.Author = "Robotboy655 + King David + Oninoni"
SWEP.Category = "Lichtschwerter (Lore Chars)"
SWEP.Contact = ""
SWEP.RenderGroup = RENDERGROUP_BOTH
SWEP.Slot = 0
SWEP.SlotPos = 4
SWEP.Spawnable = true
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.DrawWeaponInfoBox = false
SWEP.ViewModel = "models/weapons/v_crowbar.mdl"
SWEP.WorldModel = "models/starwars/cwa/lightsabers/saeseetiin.mdl"
SWEP.ViewModelFOV = 55
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

------------------------------------------------------------THINGS YOU WILL EDIT ARE BELOW HERE-------------------------------------------------------------------------
SWEP.PrintName = "Saesee Tiin" --Name of the lightsaber
SWEP.Class = "weapon_lightsaber_tiin" --The file name of this swep
SWEP.DualWielded = false --Should this be a dual wielded saber?
SWEP.CanMoveWhileAttacking = true -- Can the user move while attacking
SWEP.SaberDamage = 150 --How much damage the saber does when it's being swung
SWEP.SaberBurnDamage = 25 -- How much damage the saber does when it's colliding with someone ( coming in contact with laser )
SWEP.MaxForce = 100 --The maximum amount of force in the meter
SWEP.MaxStamina = 100 --The maximum amount of stamina in the meter
SWEP.RegenSpeed = 2 --The MULTIPLIER for the regen speed. Half speed = 0.5, Double speed = 2, etc.
SWEP.CanKnockback = true --Should this saber be able to push people back when they get hit?
SWEP.MaxBlockAngle = 135
SWEP.BlasterBlockCost = 2
SWEP.BladeBlockCost = 3
SWEP.ForcePowerList = {
	"Machtsprung",
	"Machtspiegel",
	"Machtstoß",
	"Macht-Geschwindigkeit",
	"Atemkontrolle",
	"Machtschub",
	"Machtzug",
	"Macht-Stürmen",
	"Lichtschwertwurf",
	"Schwert-Barriere",
	"Lähmender Schlag",
	"Meditieren",
	"Macht-Öffnung",
	"Macht-Sicht",
	"Macht-Griff",
	"Großer Machtschub",
	"Großer Machtzug",
	"Macht-Stasis",
	"Blenden",
	"Macht-Beben",
	"Beinhieb",
	"Klingensturm",
	"Machtblockade",
	"Willenskraft",
	"Macht-Entwaffnen"
}

SWEP.DevestatorList = { "Kyber Schlag" }

SWEP.BlockDrainRate = 0

SWEP.UseForms = {
	["Form I | Shii-Cho"] = {1, 2, 3},
	["Form V | Djem So"]  = {1, 2, 3},
	["Form II | Makashi"] = {1, 2, 3},
	["Form VII | Juyo"]   = {1, 2, 3}
}

--Use these options to overwrite the player's commands
SWEP.UseHilt = "models/starwars/cwa/lightsabers/saeseetiin.mdl" -- Model path of the hilt
SWEP.UseLength = 45 -- Length of the saber 
SWEP.UseWidth = 2 -- Width of the saber
SWEP.UseColor = Color(0, 255, 0) -- RGB Color of saber. Red = Color( 255, 0, 0 ) Blue = Color( 0, 0, 255 ), etc.
SWEP.UseDarkInner = 0 -- Does it have a dark inner? 1 = true
SWEP.UseLoopSound = "lightsaber/saber_loop1.wav" -- The loop sound path
SWEP.UseSwingSound = false -- The swing sound path
SWEP.UseOnSound = "lightsaber/saber_on1.wav" -- The on sound path
SWEP.UseOffSound = "lightsaber/saber_off1.wav" -- The off sound path

--These are the ones for the second saber for dual wielding. If you are using a single saber, this doesn't do shit
SWEP.UseSecHilt = false
SWEP.UseSecLength = false
SWEP.UseSecWidth = false
SWEP.UseSecColor = false
SWEP.UseSecDarkInner = 0


-----------------------------------------------------------END OF EDIT----------------------------------------------------------------
if !SWEP.DualWielded then
	SWEP.Base = "wos_adv_single_lightsaber_base"
else
	SWEP.Base = "wos_adv_dual_lightsaber_base"
end

if CLIENT then
	killicon.Add( SWEP.Class, "lightsaber/lightsaber_killicon", color_white )
end

--addons/wos-alcs-custom/lua/weapons/weapon_lightsaber_ventress.lua:


AddCSLuaFile()

SWEP.Author = "Robotboy655 + King David + Oninoni"
SWEP.Category = "Lichtschwerter (Event)"
SWEP.Contact = ""
SWEP.RenderGroup = RENDERGROUP_BOTH
SWEP.Slot = 0
SWEP.SlotPos = 4
SWEP.Spawnable = true
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.DrawWeaponInfoBox = false
SWEP.ViewModel = "models/weapons/v_crowbar.mdl"
SWEP.WorldModel = "models/starwars/cwa/lightsabers/ventress.mdl"
SWEP.ViewModelFOV = 55
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

------------------------------------------------------------THINGS YOU WILL EDIT ARE BELOW HERE-------------------------------------------------------------------------
SWEP.PrintName = "Asajj Ventress" --Name of the lightsaber
SWEP.Class = "weapon_lightsaber_ventress" --The file name of this swep
SWEP.DualWielded = false --Should this be a dual wielded saber?
SWEP.CanMoveWhileAttacking = true -- Can the user move while attacking
SWEP.SaberDamage = 150 --How much damage the saber does when it's being swung
SWEP.SaberBurnDamage = 25 -- How much damage the saber does when it's colliding with someone ( coming in contact with laser )
SWEP.MaxForce = 100 --The maximum amount of force in the meter
SWEP.MaxStamina = 100 --The maximum amount of stamina in the meter
SWEP.RegenSpeed = 2 --The MULTIPLIER for the regen speed. Half speed = 0.5, Double speed = 2, etc.
SWEP.CanKnockback = true --Should this saber be able to push people back when they get hit?
SWEP.MaxBlockAngle = 135
SWEP.BlasterBlockCost = 2
SWEP.BladeBlockCost = 3
SWEP.ForcePowerList = {
	"Machtsprung",
	"Machtzug",
	"Machtschub",
	"Machtspiegel",
	"Atemkontrolle",
	"Macht-Geschwindigkeit",
	"Macht-Stürmen",
	"Lichtschwertwurf",
	"Macht-Sicht",
	"Machtstoß",
	"Macht-Würgegriff",
	"Beinhieb",
	"Willenskraft"
}

SWEP.BlockDrainRate = 0

SWEP.UseForms = {
	["Form I | Shii-Cho"] = {1, 2, 3},
	["Form II | Makashi"] = {1, 2, 3},
	["Form VII | Vaapad"] = {1, 2, 3}
}

--Use these options to overwrite the player's commands
SWEP.UseHilt = "models/starwars/cwa/lightsabers/ventress.mdl" -- Model path of the hilt
SWEP.UseLength = 45 -- Length of the saber 
SWEP.UseWidth = 2 -- Width of the saber
SWEP.UseColor = Color(255, 0, 0) -- RGB Color of saber. Red = Color( 255, 0, 0 ) Blue = Color( 0, 0, 255 ), etc.
SWEP.UseDarkInner = 0 -- Does it have a dark inner? 1 = true
SWEP.UseLoopSound = "lightsaber/saber_loop6.wav" -- The loop sound path
SWEP.UseSwingSound = false -- The swing sound path
SWEP.UseOnSound = "lightsaber/saber_on2_fast.wav" -- The on sound path
SWEP.UseOffSound = "lightsaber/saber_off2_fast.wav" -- The off sound path

--These are the ones for the second saber for dual wielding. If you are using a single saber, this doesn't do shit
SWEP.UseSecHilt = false
SWEP.UseSecLength = false
SWEP.UseSecWidth = false
SWEP.UseSecColor = false
SWEP.UseSecDarkInner = 0


-----------------------------------------------------------END OF EDIT----------------------------------------------------------------
if !SWEP.DualWielded then
	SWEP.Base = "wos_adv_single_lightsaber_base"
else
	SWEP.Base = "wos_adv_dual_lightsaber_base"
end

if CLIENT then
	killicon.Add( SWEP.Class, "lightsaber/lightsaber_killicon", color_white )
end

--addons/wos-alcs-custom/lua/weapons/weapon_lightsaber_ventressdual.lua:
AddCSLuaFile()

SWEP.Author = "Robotboy655 + King David + Oninoni"
SWEP.Category = "Lichtschwerter (Event)"
SWEP.Contact = ""
SWEP.RenderGroup = RENDERGROUP_BOTH
SWEP.Slot = 0
SWEP.SlotPos = 4
SWEP.Spawnable = true
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.DrawWeaponInfoBox = false
SWEP.ViewModel = "models/weapons/v_crowbar.mdl"
SWEP.WorldModel = "models/starwars/cwa/lightsabers/ventress.mdl"
SWEP.ViewModelFOV = 55
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

------------------------------------------------------------THINGS YOU WILL EDIT ARE BELOW HERE-------------------------------------------------------------------------
SWEP.PrintName = "Asajj Ventress - Dual" --Name of the lightsaber
SWEP.Class = "weapon_lightsaber_ventressdual" --The file name of this swep
SWEP.DualWielded = true --Should this be a dual wielded saber?
SWEP.CanMoveWhileAttacking = true -- Can the user move while attacking
SWEP.SaberDamage = 150 --How much damage the saber does when it's being swung
SWEP.SaberBurnDamage = 25 -- How much damage the saber does when it's colliding with someone ( coming in contact with laser )
SWEP.MaxForce = 100 --The maximum amount of force in the meter
SWEP.MaxStamina = 100 --The maximum amount of stamina in the meter
SWEP.RegenSpeed = 2 --The MULTIPLIER for the regen speed. Half speed = 0.5, Double speed = 2, etc.
SWEP.CanKnockback = true --Should this saber be able to push people back when they get hit?
SWEP.MaxBlockAngle = 135
SWEP.BlasterBlockCost = 2
SWEP.BladeBlockCost = 3
SWEP.ForcePowerList = {
	"Machtsprung",
	"Machtzug",
	"Machtschub",
	"Machtspiegel",
	"Atemkontrolle",
	"Macht-Geschwindigkeit",
	"Macht-Stürmen",
	"Lichtschwertwurf",
	"Macht-Sicht",
	"Machtstoß",
	"Macht-Würgegriff",
	"Beinhieb",
	"Willenskraft"
}

SWEP.BlockDrainRate = 0

SWEP.UseForms = {
	["Form VII | Vaapad"] = {1, 2, 3},
	["Form VI | Niman"] = {1, 2, 3}
}

--Use these options to overwrite the player's commands
SWEP.UseHilt = "models/starwars/cwa/lightsabers/ventress.mdl" -- Model path of the hilt
SWEP.UseLength = 45 -- Length of the saber 
SWEP.UseWidth = 2 -- Width of the saber
SWEP.UseColor = Color(255, 0, 0) -- RGB Color of saber. Red = Color( 255, 0, 0 ) Blue = Color( 0, 0, 255 ), etc.
SWEP.UseDarkInner = 0 -- Does it have a dark inner? 1 = true
SWEP.UseLoopSound = "lightsaber/saber_loop6.wav" -- The loop sound path
SWEP.UseSwingSound = false -- The swing sound path
SWEP.UseOnSound = "lightsaber/saber_on2_fast.wav" -- The on sound path
SWEP.UseOffSound = "lightsaber/saber_off2_fast.wav" -- The off sound path

--These are the ones for the second saber for dual wielding. If you are using a single saber, this doesn't do shit
SWEP.UseSecHilt = "models/starwars/cwa/lightsabers/ventress.mdl"
SWEP.UseSecLength = 45
SWEP.UseSecWidth = 2
SWEP.UseSecColor = Color(255, 0, 0)
SWEP.UseSecDarkInner = 0


-----------------------------------------------------------END OF EDIT----------------------------------------------------------------
if !SWEP.DualWielded then
	SWEP.Base = "wos_adv_single_lightsaber_base"
else
	SWEP.Base = "wos_adv_dual_lightsaber_base"
end

if CLIENT then
	killicon.Add( SWEP.Class, "lightsaber/lightsaber_killicon", color_white )
end

--addons/wos-alcs-custom/lua/weapons/weapon_lightsaber_zey.lua:


AddCSLuaFile()

SWEP.Author = "Robotboy655 + King David + Oninoni"
SWEP.Category = "Lichtschwerter (Lore Chars)"
SWEP.Contact = ""
SWEP.RenderGroup = RENDERGROUP_BOTH
SWEP.Slot = 0
SWEP.SlotPos = 4
SWEP.Spawnable = true
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.DrawWeaponInfoBox = false
SWEP.ViewModel = "models/weapons/v_crowbar.mdl"
SWEP.WorldModel = "models/sgg/starwars/weapons/w_anakin_ep2_saber_hilt.mdl"
SWEP.ViewModelFOV = 55
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

------------------------------------------------------------THINGS YOU WILL EDIT ARE BELOW HERE-------------------------------------------------------------------------
SWEP.PrintName = "Arligan Zey" --Name of the lightsaber
SWEP.Class = "weapon_lightsaber_zey" --The file name of this swep
SWEP.DualWielded = false --Should this be a dual wielded saber?
SWEP.CanMoveWhileAttacking = true -- Can the user move while attacking
SWEP.SaberDamage = 150 --How much damage the saber does when it's being swung
SWEP.SaberBurnDamage = 25 -- How much damage the saber does when it's colliding with someone ( coming in contact with laser )
SWEP.MaxForce = 100 --The maximum amount of force in the meter
SWEP.MaxStamina = 100 --The maximum amount of stamina in the meter
SWEP.RegenSpeed = 2 --The MULTIPLIER for the regen speed. Half speed = 0.5, Double speed = 2, etc.
SWEP.CanKnockback = true --Should this saber be able to push people back when they get hit?
SWEP.MaxBlockAngle = 135
SWEP.BlasterBlockCost = 2
SWEP.BladeBlockCost = 3
SWEP.ForcePowerList = {
	"Machtsprung",
	"Atemkontrolle",
	"Machtzug",
	"Machtschub",
	"Machtstoß",
	"Macht-Geschwindigkeit",
	"Machtheilung",
	"Selbstheilung",
	"Gruppenheilung",
	"Lichtschwertwurf",
	"Macht-Öffnung",
	"Macht-Griff",
	"Macht-Stasis",
	"Macht-Sicht",
	"Machtschild",
	"Blenden",
	"Macht-Verlangsamung",
	"Machtspiegel",
	"Großer Machtschub",
	"Großer Machtzug",
	"Macht-Teleportation",
	"Machtblockade",
	"Energiestrahl",
	"Willenskraft",
	"Macht-Entwaffnen"
}

SWEP.BlockDrainRate = 0

SWEP.UseForms = {
	["Form I | Shii-Cho"] = {1, 2, 3},
	["Form II | Makashi"] = {1, 2, 3},
	["Form IV | Ataru"]   = {1, 2, 3},
	["Form III | Soresu"] = {1, 2, 3}
}

--Use these options to overwrite the player's commands
SWEP.UseHilt = "models/sgg/starwars/weapons/w_common_jedi_saber_hilt.mdl" -- Model path of the hilt
SWEP.UseLength = 45 -- Length of the saber 
SWEP.UseWidth = 2 -- Width of the saber
SWEP.UseColor = Color(255, 77, 0) -- RGB Color of saber. Red = Color( 255, 0, 0 ) Blue = Color( 0, 0, 255 ), etc.
SWEP.UseDarkInner = 0 -- Does it have a dark inner? 1 = true
SWEP.UseLoopSound = "lightsaber/saber_loop1.wav" -- The loop sound path
SWEP.UseSwingSound = false -- The swing sound path
SWEP.UseOnSound = "lightsaber/saber_on1.wav" -- The on sound path
SWEP.UseOffSound = "lightsaber/saber_off1.wav" -- The off sound path

--These are the ones for the second saber for dual wielding. If you are using a single saber, this doesn't do shit
SWEP.UseSecHilt = false
SWEP.UseSecLength = false
SWEP.UseSecWidth = false
SWEP.UseSecColor = false
SWEP.UseSecDarkInner = 0


-----------------------------------------------------------END OF EDIT----------------------------------------------------------------


if !SWEP.DualWielded then
	SWEP.Base = "wos_adv_single_lightsaber_base"
else
	SWEP.Base = "wos_adv_dual_lightsaber_base"
end

if CLIENT then
	killicon.Add( SWEP.Class, "lightsaber/lightsaber_killicon", color_white )
end

--addons/egm_tfa_mines/lua/weapons/weapon_mine_training/shared.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--              Mines            	 --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--        Mines | Base Weapon        --
---------------------------------------

SWEP.Base 					= "weapon_mine_base"
SWEP.PrintName 				= "Mine - Training"
SWEP.Category 				= "SW:RP (Republik)"

SWEP.Spawnable				= true

SWEP.Mine 					= "mine_training"
SWEP.Skin 					= 4

SWEP.WElements = {
	["mine"] = {
		type = "Model",
		model = "models/bf2/Landmine.mdl",
		bone = "ValveBiped.Bip01_R_Hand",
		rel = "",
		pos = Vector(3.635, 2.596, -0.519),
		angle = Angle(-75.974, 0, 0),
		size = Vector(0.5, 0.5, 0.5),
		color = Color(255, 255, 255, 255),
		surpresslightning = true,
		material = "",
		skin = SWEP.Skin,
		bodygroup = {}
	}
}

SWEP.VElements = {
	["mine"] = {
		type = "Model",
		model = "models/bf2/Landmine.mdl",
		bone = "ValveBiped.Bip01_R_Hand",
		rel = "",
		pos = Vector(1.557, 4.675, -1.558),
		angle = Angle(-38.571, 0, 0),
		size = Vector(0.5, 0.5, 0.5),
		color = Color(255, 255, 255, 255),
		surpresslightning = true,
		material = "",
		skin = SWEP.Skin,
		bodygroup = {}
	}
}

--lua/weapons/weapon_molotov.lua:
-- Molotov
-- By Anya O'Quinn / Slade Xanthas

AddCSLuaFile()

if SERVER then
	resource.AddWorkshop("1470029857")
end

SWEP.Base					= "weapon_base"

SWEP.PrintName				= "Molotov"	
SWEP.ClassName				= "weapon_molotov"
SWEP.Author					= "Anya O'Quinn"
SWEP.Instructions			= "Left click to throw and burn it all down. Right click to toss lightly."

if vFireInstalled then
	SWEP.Category			= "vFire Weapons"
else
	SWEP.Category			= "Anya O'Quinn"
end

SWEP.Spawnable				= true
SWEP.AdminOnly				= false

SWEP.Slot					= 4
SWEP.SlotPos				= 1
SWEP.AutoSwitchTo			= false
SWEP.AutoSwitchFrom			= false

SWEP.ViewModel 				= "models/weapons/anya/c_molly.mdl"
SWEP.WorldModel 			= "models/weapons/anya/w_molly.mdl"
SWEP.ViewModelFOV			= 50
SWEP.ViewModelFlip			= false
SWEP.UseHands 				= true
		
SWEP.DrawAmmo				= true
SWEP.DrawCrosshair			= true

SWEP.HoldType				= "grenade"

SWEP.Primary.Delay			= 0.75
SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= 5
SWEP.Primary.Automatic		= false
SWEP.Primary.Ammo			= "molotov"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= false
SWEP.Secondary.Ammo			= "none"

SWEP.ShowViewModel 			= true
SWEP.ShowWorldModel 		= true

SWEP.Throwing 				= false
SWEP.StartThrow 			= false
SWEP.ResetThrow 			= false
SWEP.ThrowVel 				= 1750
SWEP.TossVel				= 500
SWEP.NextThrow 				= CurTime()
SWEP.NextAnimation 			= CurTime()

local ClassName 			= SWEP.ClassName

if CLIENT then
	language.Add("molotov_ammo", "Molotovs")
end

game.AddAmmoType({
	name 		= "molotov",
	dmgtype 	= DMG_BURN,
	tracer 		= TRACER_NONE,
	plydmg 		= 5,
	npcdmg 		= 5,
	force 		= 0,
	minsplash 	= 10,
	maxsplash 	= 10,
	maxcarry 	= 8
})

game.AddParticles("particles/nmrih_gasoline_edit.pcf")

PrecacheParticleSystem("nmrih_molotov_rag_fire")
PrecacheParticleSystem("nmrih_molotov_explosion")
PrecacheParticleSystem("nmrih_molotov_explosion_nofire")

function SWEP:Initialize()
	self:SetHoldType(self.HoldType)
	self:Deploy()
end

function SWEP:Deploy()

	self.StartThrow = false
	self.Throwing = false
	self.ResetThrow = false

	if not self.Throwing then

		if IsValid(self.Weapon) and IsValid(self.Owner) and self.Owner:IsPlayer() then
			self.Weapon:SendWeaponAnim(ACT_VM_DRAW)
			if IsValid(self.Owner:GetViewModel()) then
				self.Owner:GetViewModel():SetPlaybackRate(2.5)
				self.Weapon:SetNextPrimaryFire(CurTime() + self.Owner:GetViewModel():SequenceDuration() / 2.5)
				self.Weapon:SetNextSecondaryFire(CurTime() + self.Owner:GetViewModel():SequenceDuration() / 2.5)
			end
		end
		
	end

	if CLIENT and IsValid(self.Owner) and self.Owner:IsPlayer() and IsValid(self.Weapon) then

		if self.Owner:IsPlayer() and IsValid(self.Owner:GetViewModel()) and IsValid(GetViewEntity()) and (self.Owner == GetViewEntity()) then
			ParticleEffectAttach("nmrih_molotov_rag_fire", PATTACH_POINT_FOLLOW, self.Owner:GetViewModel(), self.Owner:GetViewModel():LookupAttachment("Wick"))
		else
			ParticleEffectAttach("nmrih_molotov_rag_fire", PATTACH_POINT_FOLLOW, self.Weapon, self.Weapon:LookupAttachment("Wick"))
		end

	end

	if game.SinglePlayer() then
		self:CallOnClient("Deploy")
	end

	return true	
	
end

function SWEP:Holster()

	self.StartThrow = false
	self.Throwing = false
	self.ResetThrow = false
	self.Tossed = false

	self.Weapon:StopParticles()

	if game.SinglePlayer() then
		self:CallOnClient("Holster")
	end

	return true

end

function SWEP:Think()

	if not IsValid(self.Owner) or not IsValid(self.Weapon) then return end
	
	if not self.Throwing and not self.StartThrow and self.Owner:KeyDown(IN_ATTACK) and not (self.Owner:GetAmmoCount(self.Primary.Ammo) <= 0) and self.NextThrow < CurTime() then
		self.StartThrow = true
		self.Weapon:SendWeaponAnim(ACT_VM_PULLBACK_HIGH)
		if IsValid(self.Owner:GetViewModel()) then
			self.NextThrow = CurTime() + self.Owner:GetViewModel():SequenceDuration()
			self.Weapon:SetNextPrimaryFire(CurTime() + self.Owner:GetViewModel():SequenceDuration())
			self.Weapon:SetNextSecondaryFire(CurTime() + self.Owner:GetViewModel():SequenceDuration())
		end
	elseif not self.Throwing and not self.StartThrow and self.Owner:KeyDown(IN_ATTACK2) and not (self.Owner:GetAmmoCount(self.Primary.Ammo) <= 0) and self.NextThrow < CurTime() then
		self.StartThrow = true
		self.Tossed = true
		self.Weapon:SendWeaponAnim(ACT_VM_PULLBACK_LOW)
		if IsValid(self.Owner:GetViewModel()) then
			self.NextThrow = CurTime() + self.Owner:GetViewModel():SequenceDuration()
			self.Weapon:SetNextPrimaryFire(CurTime() + self.Owner:GetViewModel():SequenceDuration())
			self.Weapon:SetNextSecondaryFire(CurTime() + self.Owner:GetViewModel():SequenceDuration())
		end
	end
	
	if self.StartThrow and not self.Owner:KeyDown(IN_ATTACK) and not self.Owner:KeyDown(IN_ATTACK2) and self.NextThrow < CurTime() then
	
		self.StartThrow = false
		self.Throwing = true
		
		if self.Tossed then
			self.Weapon:SendWeaponAnim(ACT_VM_SECONDARYATTACK)
		else
			self.Weapon:SendWeaponAnim(ACT_VM_THROW)
		end

		if SERVER then
			self.Owner:EmitSound("weapons/iceaxe/iceaxe_swing1.wav",60,math.random(80,90))
		end
		
		self.Owner:SetAnimation(PLAYER_ATTACK1)


		if SERVER then

			local ent = ents.Create("rj_molotov")
			if not ent then return end
			ent.Owner = self.Owner
			ent.Inflictor = self.Weapon
			ent:SetOwner(self.Owner)
			local eyeang = self.Owner:GetAimVector():Angle()
			local right = eyeang:Right()
			local up = eyeang:Up()

			if self.Tossed then
				ent:SetPos(self.Owner:GetShootPos() + right * 6 + up * -6)
				ent:SetAngles(self.Owner:GetAngles() + Angle(0,-90,0))
				ent.Vel = self.TossVel / 2
			else
				ent:SetPos(self.Owner:GetShootPos() + right * 6 + up * -2)
				ent:SetAngles(self.Owner:GetAngles() + Angle(-90,0,0))
				ent.Vel = self.ThrowVel / 2
			end

			ent:SetPhysicsAttacker(self.Owner)
			ent:Spawn()

			local phys = ent:GetPhysicsObject()

			if IsValid(phys) then

				phys:SetVelocity(self.Owner:GetAimVector() * ((self.Tossed and self.TossVel) or self.ThrowVel) + (self.Owner:GetVelocity() * 0.5))

				local vel = phys:GetVelocity()
				local norm = vel:GetNormalized()

				phys:ApplyForceOffset(vel:GetNormalized() * math.random(5,10), ent:LocalToWorld(ent:OBBCenter()) + Vector(0,0,math.random(10,15)))

			end

			self.Owner:RemoveAmmo(1, self.Primary.Ammo)

		end

		self.NextAnimation = CurTime() + self.Primary.Delay
		self.ResetThrow = true
		self.Tossed = false
		
	end
	
	if self.Throwing and self.ResetThrow and self.NextAnimation < CurTime() then

		if self.Owner:GetAmmoCount(self.Primary.Ammo) > 0 then

			self.Weapon:SendWeaponAnim(ACT_VM_DRAW)
			if IsValid(self.Owner:GetViewModel()) then
				self.Owner:GetViewModel():SetPlaybackRate(2.5)
				self.NextThrow = CurTime() + self.Owner:GetViewModel():SequenceDuration() / 2.5
				self.Weapon:SetNextPrimaryFire(CurTime() + self.Owner:GetViewModel():SequenceDuration() / 2.5)
				self.Weapon:SetNextSecondaryFire(CurTime() + self.Owner:GetViewModel():SequenceDuration() / 2.5)
			end
			
		elseif SERVER then
			self.Weapon:Remove()
		end
		
		self.ResetThrow = false
		self.Throwing = false
		
	end
	
end

function SWEP:CanPrimaryAttack()
	return false
end

function SWEP:PrimaryAttack()
	return false
end

function SWEP:SecondaryAttack()
	return false
end

function SWEP:Reload()
	return false
end

function SWEP:OnRemove()
	if IsValid(self.Owner) and self.Owner:IsPlayer() and IsValid(self.Owner:GetActiveWeapon()) and self.Owner:GetActiveWeapon() == self and (SERVER or (CLIENT and self.Owner == LocalPlayer())) then --hopefully fixes p2p regressions
		self.Owner:ConCommand("lastinv")
	end
end

local ENT = {}

ENT.PrintName = "Molotov"
ENT.Type = "anim"  
ENT.Base = "base_anim"

if CLIENT then
	function ENT:Draw()
		self:DrawModel()

		local dlight = DynamicLight(self:EntIndex())

		if dlight and IsValid(self:GetAttachment(self:LookupAttachment("Wick"))) then
			dlight.Pos = self:GetAttachment(self:LookupAttachment("Wick")).Pos
			dlight.r = 255
			dlight.g = 100
			dlight.b = 50
			dlight.Brightness = 1
			dlight.Decay = 30
			dlight.Size = 100
			dlight.DieTime = CurTime() + 0.2
		end
	end
end

if SERVER then

	function ENT:Initialize()

		self:SetModel("models/weapons/anya/w_molly.mdl")
		self:PhysicsInit(SOLID_VPHYSICS)
		self:SetMoveType(MOVETYPE_VPHYSICS)
		self:SetSolid(SOLID_VPHYSICS)
		self:SetCollisionGroup(COLLISION_GROUP_PROJECTILE)

		local phys = self:GetPhysicsObject()  	
		if IsValid(phys) then 
			phys:Wake()
			phys:SetMass(1)
			phys:EnableDrag(true)
			phys:SetAngleDragCoefficient(20)
			phys:AddGameFlag(FVPHYSICS_NO_IMPACT_DMG)
			phys:SetBuoyancyRatio(1)
		end
		
		self.Life = 25
		self.Speed = self.Vel or self:GetVelocity():Length()

		self.OwnerReset = CurTime() + 1

		self.BurnSound = CreateSound(self, "ambient/fire/fire_small1.wav")
		self.BurnSound:Play()

		self.RagFire = ParticleEffectAttach("nmrih_molotov_rag_fire", PATTACH_POINT_FOLLOW, self, self:LookupAttachment("Wick"))
		
		self:Fire("kill", 1, 30)

	end
	
	function ENT:Think()
	
		if self.Owner and self.OwnerReset and self.OwnerReset < CurTime() then -- I shouldn't even have to do this but Source is stupid
			self:SetOwner(NULL) -- Remove the Source-based "Owner" so the thrower can interact with their own Molotov
			self.OwnerReset = nil
		end

		if not self.Hit and not self:IsOnGround() and ((self.LastSpeedTick and self.LastSpeedTick < CurTime()) or not self.LastSpeedTick) then
			self.Speed = math.floor(self:GetVelocity():Length())
			self.LastSpeedTick = CurTime() + FrameTime()
		end
		
		if self:WaterLevel() > 0 then
			self:EmitSound("ambient/levels/canals/toxic_slime_sizzle3.wav",90,100)
			self:EmitSound("ambient/water/water_splash" .. math.random(1,3) .. ".wav",90,100)
			self:SetMoveType(MOVETYPE_NONE)
			self:SetNoDraw(true)
			self:StopParticles()
			self:Remove()
		end

		if self.Hit and self.HitData and not hull then

			self:SetMoveType(MOVETYPE_NONE)
			self:SetNoDraw(true)
			self:StopParticles()

			local pos = self.HitData.HitPos or self:GetPos()
			local normal = self.HitData.HitNormal or Vector(0,0,1)
			local vel = self.HitData.Velocity or vector_origin
		
			local hull = ents.Create("rj_molotov_hull")
			if not hull then return end
			hull:SetPos(pos + normal * (hull:OBBMaxs() / 2))
			hull:SetAngles(normal:Angle() + Angle(90,0,0))
			hull:SetOwner(self.Owner)
			hull.Owner = self.Owner
			hull.FirePos = pos
			hull.FireNormal = normal
			hull.Inflictor = self.Weapon or self.Owner:GetActiveWeapon() or self
			hull.DropToFloor = self.HitData.DropToFloor
			hull:Spawn()

			self:Remove()

		end
		
		self:NextThink(CurTime())
		
	end
	
	function ENT:OnRemove()

		self:StopParticles()

		if self.BurnSound then 
			self.BurnSound:Stop()
		end

	end
	
	function ENT:OnTakeDamage(dmg)
	
		local typ = dmg:GetDamageType()

		if typ and (typ == DMG_BULLET or typ == DMG_SLASH or typ == DMG_CLUB or typ == DMG_CRUSH or typ == DMG_BLAST) then
			dmg:ScaleDamage(10) -- Scale damage monumentally when it would realistically shatter the bottle instantly
		end
	
		self.Life = self.Life - dmg:GetDamage()

		if dmg:GetDamage() > self.Life or self.Life <= 0 and not self.Popped then

			self.Popped = true

			local att = dmg:GetAttacker()
			
			if IsValid(att) and att:IsPlayer() then
				self.Owner = att
			end

			self.HitData = {}
			self.Hit = true
			
		end
		
	end

	function ENT:Touch(ent) --NPCs and Zeta players are stupid and don't follow the laws of physics

		if IsValid(self) and IsValid(ent) and (ent:IsNPC() or ent:IsPlayer() or ent:IsNextBot()) and not self.Hit and self.Speed > 550 then
			self:DropToFloor()
			self.HitData = {}
			self.HitData.HitPos = ent:GetPos()
			self.HitData.HitNormal = Vector(0,0,1)
			self.HitData.Velocity = self:GetVelocity()
			self.Hit = true
		end

	end
	
	function ENT:PhysicsCollide(data, phys)	

		if IsValid(self) and not self.Hit and (IsValid(data.HitEntity) and not (string.find(data.HitEntity:GetClass(),"npc_") or data.HitEntity:IsNPC() or data.HitEntity:IsPlayer()) or not IsValid(data.HitEntity)) and self.Speed > 550 then

			self.HitData = {}
			self.HitData.HitPos = data.HitPos
			self.HitData.HitNormal = Vector(0,0,1)
			
			local trdata = {}
			trdata.start = data.HitPos
			trdata.endpos = data.HitPos + data.HitNormal
			local tr = util.TraceLine(trdata)

			if tr.Hit then
				self.HitData = tr
			end

			self.Hit = true
			
		end	
		
	end
	
end

local function MolotovResetKillCredit(ply,ent) --Anyone who picks up a Molotov gets kill credit if it pops
	if IsValid(ply) and ent:GetClass() == ClassName then
		ent.Owner = ply
	end
end
hook.Add("GravGunOnPickedUp","MolotovResetOnGravGun",MolotovResetKillCredit)
hook.Add("OnPhysgunPickup","MolotovResetOnPhysGun",MolotovResetKillCredit)
hook.Add("OnPlayerPhysicsPickup","MolotovResetOnPickup",MolotovResetKillCredit)

scripted_ents.Register(ENT, "rj_molotov", true)

local HULL = {}

HULL.PrintName = "Molotov Point Hurt"
HULL.Type = "anim"
HULL.Base = "base_anim"

if CLIENT then

	net.Receive("Molotov_vFireBall",function()
		local rad = net.ReadFloat()
		local pos = net.ReadVector()
		local vel = net.ReadVector()
		if vFireInstalled then
			molotov_vFireBall = CreateCSVFireBall(rad, pos, vel, 20, false)
		end
	end)

	function HULL:Draw()
		return false
	end

end

if SERVER then

	util.AddNetworkString("Molotov_vFireBall")

	function HULL:Initialize()
	
		self:SetModel("models/hunter/blocks/cube4x4x4.mdl")
		self:SetMoveType(MOVETYPE_NONE)
		self:SetSolid(SOLID_NONE)
		self:SetSolidFlags(bit.bor(FSOLID_TRIGGER,FSOLID_USE_TRIGGER_BOUNDS))
		self:SetCollisionGroup(COLLISION_GROUP_IN_VEHICLE) --god damn it valve
		self:SetNoDraw(true)
		self:SetTrigger(true)
		
		if IsValid(self.Owner) then
			self:SetOwner(self.Owner)
		end
	
		self.NextHurt = CurTime()

		self.BurnSound = CreateSound(self, "ambient/fire/fire_small_loop1.wav")
		self.BurnSound:PlayEx(1,98)
		self.BurnSound:SetSoundLevel(80)
		
		self:Fire("kill", 1, 20)

		if vFireInstalled and GetConVar("vfire_enable_damage"):GetBool() and self.FirePos then --vFire is installed and enabled, make a vFire
		
			local rad = self:BoundingRadius()
			local vel = self:GetUp() * 10

			for i=1,8 do
				self.vFire = CreateVFire(self, self:GetPos() + (self:GetForward() * VectorRand() * rad / 2) + (self:GetRight() * VectorRand() * rad / 2) - self:GetUp() * (self:OBBMaxs() / 2), self:GetUp(), 40)
				if IsValid(self.Owner) and IsValid(self.vFire) then
					self.vFire:SetOwner(self.Owner)
				end
			end
			
			self.vFireBall = CreateVFireBall(rad / 4, rad / 4, self.FirePos, vel, self:GetOwner() or self.Owner or self)

			if IsValid(self.Owner) then
				self.vFireBall:SetOwner(self.Owner)
			end
			
			net.Start("Molotov_vFireBall")
				local filter = RecipientFilter()
				filter:AddAllPlayers()
				net.WriteFloat(rad)
				net.WriteVector(self.FirePos)
				net.WriteVector(vel)
			net.Send(filter)

			if self.FirePos and self.FireNormal then
				ParticleEffectAttach("nmrih_molotov_explosion_nofire", PATTACH_ABSORIGIN_FOLLOW, self, 0)
			end
			
		elseif self.FirePos and self.FireNormal then -- emit the original particle effect if vFire is disabled/missing	
			ParticleEffectAttach("nmrih_molotov_explosion", PATTACH_ABSORIGIN_FOLLOW, self, 0)
		end
		
		self:EmitSound("molotov/ol_mollysplode" .. math.random(1,2) .. ".ogg",100,math.random(95,105))

		local attacker = self:GetOwner() or self.Owner or self
		local inflictor = self.Inflictor or self

		local dmg = DamageInfo()
		dmg:SetDamage(20)
		dmg:SetDamageType(DMG_GENERIC)
		dmg:SetDamageForce(Vector(0,0,0))

		if IsValid(attacker) then
			dmg:SetAttacker(attacker)
		end

		if IsValid(inflictor) then
			dmg:SetInflictor(inflictor)
		end

		local victims = ents.FindInBox(self:LocalToWorld(self:OBBMins()),self:LocalToWorld(self:OBBMaxs()))

		if victims and #victims > 0 then
			for i,victim in pairs(victims) do
				if IsValid(victim) and (string.find(victim:GetClass(),"npc_") or victim:IsNPC() or victim:IsPlayer()) then
					victim:TakeDamageInfo(dmg)
				end
			end
		end
		
	end
	
	function HULL:Touch(victim)

		if IsValid(victim) and self.NextHurt < CurTime() then
		
			local attacker = self:GetOwner() or self.Owner or self
			local inflictor = self.Inflictor or self

			local dmg = DamageInfo()
			dmg:SetDamage(10)
			dmg:SetDamageType(DMG_BURN)
			dmg:SetDamagePosition(self:GetPos())
			dmg:SetDamageForce(Vector(0,0,0))
			
			if IsValid(attacker) then
				dmg:SetAttacker(attacker)
			end
			
			if IsValid(inflictor) then
				dmg:SetInflictor(inflictor)
			end
			
			victim:TakeDamageInfo(dmg)
			victim:Ignite(7,10)
			
			self.NextHurt = CurTime() + 0.25
		
		end	
		
	end
	
	function HULL:Think()
		return false
	end
	
	function HULL:OnRemove()
		if self.BurnSound then 
			self.BurnSound:Stop() 
		end
	end

end

scripted_ents.Register(HULL, "rj_molotov_hull", true)

local AMMO = {}

AMMO.PrintName = "Molotov Bottle"
AMMO.Type = "anim"
AMMO.Base = "base_anim"
AMMO.Spawnable = true
AMMO.AdminOnly = false
AMMO.Category = "Anya O'Quinn"

if SERVER then

	function AMMO:Initialize()

		self:SetModel("models/weapons/anya/item_molly.mdl")
		self:PhysicsInit(SOLID_VPHYSICS)
		self:SetMoveType(MOVETYPE_VPHYSICS)
		self:SetSolid(SOLID_VPHYSICS)
		self:SetCollisionGroup(COLLISION_GROUP_WEAPON)
		self:SetTrigger(true)

		local phys = self:GetPhysicsObject()  	
		if IsValid(phys) then 
			phys:Wake()
			phys:SetMass(1)
			phys:EnableDrag(true)
			phys:AddGameFlag(FVPHYSICS_NO_IMPACT_DMG)
			phys:SetBuoyancyRatio(0.5)
			phys:SetAngleDragCoefficient(20)
		end
	
	end
	
	function AMMO:SpawnFunction(ply,tr,class)

		if not tr.Hit then return end

		local pos = tr.HitPos + tr.HitNormal * 10

		local ent = ents.Create(class)
		if not ent then return end
		ent:SetPos(pos)
		ent:SetAngles(Angle(-90,0,0))
		ent:Spawn()
		ent:Activate()

		return ent

	end
	
	function AMMO:StartTouch(ply)
		if IsValid(self) and IsValid(ply) and ply:IsPlayer() then
			if not ply:HasWeapon(ClassName) then
				ply:Give(ClassName)
				ply:SelectWeapon(ClassName)

			else
				ply:GiveAmmo(5,"molotov")
			end
			self:Remove()
		end
	end
	
	function AMMO:Think()
	
		if self.Popped and not hull then
	
			local pos = self:GetPos()
			local normal = Vector(0,0,1)
			local vel = vector_origin
		
			local hull = ents.Create("rj_molotov_hull")
			if not hull then return end
			hull:SetPos(pos + normal)
			hull:SetAngles(normal:Angle() + Angle(90,0,0))
			hull:SetOwner(self.Owner)
			hull.Owner = self.Owner
			hull.FirePos = pos
			hull.FireNormal = normal
			hull.Inflictor = self.Weapon or self
			hull:Spawn()
			
			self:Remove()
			
		end
		
		self:NextThink(CurTime())
		
	end
	
	function AMMO:OnTakeDamage(dmg)

		local typ = dmg:GetDamageType()
		local att = dmg:GetAttacker()

		if typ and IsValid(att) and att:IsPlayer() and (typ == DMG_BULLET or typ == DMG_BLAST or typ == DMG_BURN) then
			self.Owner = att
			self.Weapon = dmg:GetInflictor() or self
			self.Popped = true
		end
		
	end
	
end

scripted_ents.Register(AMMO, "rj_molotov_ammo", true)

if CLIENT then
	local tex = "hud/killicons/molly"
	local col = Color(255,80,0,255)
	killicon.Add(SWEP.ClassName,tex,col)
	killicon.Add(ENT.ClassName,tex,col)
	killicon.Add(HULL.ClassName,tex,col)
end

-- 37062385

--addons/egm_tfa_weapons_zdisabled/lua/weapons/weapon_nmrih_molotov.lua:
-- Molotov
-- By Anya O'Quinn / Slade Xanthas

AddCSLuaFile()

if SERVER then
	resource.AddWorkshop("1470029857")
end

if CLIENT then
	language.Add("molotov_ammo", "Molotovs")
end

if not ConVarExists("vfire_molotov_enabled") and vFireInstalled then
	CreateConVar("vfire_molotov_enabled", "1", FCVAR_NOTIFY, "Should vFire be used for the Molotov Cocktails?  vFire must be installed for this to work!")
end

sound.Add({name = "Weapon_NMRiH_Molotov.Draw", 			channel = CHAN_ITEM, 	volume = 0.4, 	level = 75, 	pitch = {100,100}, 	sound = {"nmrih/player/weapon_draw_01.ogg","nmrih/player/weapon_draw_02.ogg","nmrih/player/weapon_draw_03.ogg","nmrih/player/weapon_draw_04.ogg","nmrih/player/weapon_draw_05.ogg"}})
sound.Add({name = "Weapon_NMRiH_Molotov.Shove", 		channel = CHAN_WEAPON, 	volume = 0.75, 	level = 100, 	pitch = {97,100}, 	sound = {"nmrih/player/shove_01.ogg","nmrih/player/shove_02.ogg","nmrih/player/shove_03.ogg","nmrih/player/shove_04.ogg","nmrih/player/shove_05.ogg" }})
sound.Add({name = "Weapon_NMRiH_Molotov.Ignite_Rag", 	channel = CHAN_WEAPON, 	volume = 1, 	level = 75, 	pitch = {100,100}, 	sound = "nmrih/weapons/firearms/exp_molotov/molotov_rag_ignite_01.ogg"})
sound.Add({name = "Weapon_NMRiH_Molotov.Rag_Loop", 		channel = CHAN_WEAPON, 	volume = 1, 	level = 75, 	pitch = {100,100}, 	sound = "nmrih/weapons/firearms/exp_molotov/molotov_rag_fire_loop_01.ogg"})
sound.Add({name = "Weapon_NMRiH_Molotov.Explode", 		channel = CHAN_WEAPON, 	volume = 1, 	level = 75, 	pitch = {100,100}, 	sound = "nmrih/weapons/firearms/exp_molotov/molotov_explode_01.ogg"})
sound.Add({name = "Weapon_NMRiH_Molotov.Fire_Loop", 	channel = CHAN_WEAPON, 	volume = 1, 	level = 75, 	pitch = {100,100}, 	sound = "nmrih/weapons/firearms/exp_molotov/molotov_fire_loop_01.ogg"})
sound.Add({name = "Weapon_NMRiH_Zippo.Open", 			channel = CHAN_AUTO, 	volume = 1, 	level = 75, 	pitch = {100,100}, 	sound = {"nmrih/weapons/tools/zippo/zippo_open_01.ogg","nmrih/weapons/tools/zippo/zippo_open_02.ogg" }})
sound.Add({name = "Weapon_NMRiH_Zippo.Close", 			channel = CHAN_AUTO, 	volume = 1, 	level = 75, 	pitch = {100,100}, 	sound = {"nmrih/weapons/tools/zippo/zippo_close_01.ogg", "nmrih/weapons/tools/zippo/zippo_close_02.ogg" }})
sound.Add({name = "Weapon_NMRiH_Zippo.Strike_Fail", 	channel = CHAN_AUTO, 	volume = 1, 	level = 75, 	pitch = {100,100}, 	sound = {"nmrih/weapons/tools/zippo/zippo_strike_fail_01.ogg", "nmrih/weapons/tools/zippo/zippo_strike_fail_02.ogg", "nmrih/weapons/tools/zippo/zippo_strike_fail_03.ogg"}})
sound.Add({name = "Weapon_NMRiH_Zippo.Strike_Success", 	channel = CHAN_AUTO, 	volume = 1, 	level = 75, 	pitch = {100,100}, 	sound = "nmrih/weapons/tools/zippo/zippo_strike_success_01.ogg"})

game.AddParticles("particles/nmrih_explosion_tnt.pcf")
game.AddParticles("particles/nmrih_explosions.pcf")
game.AddParticles("particles/nmrih_gasoline.pcf")

game.AddAmmoType({
	name 		= "molotov",
	dmgtype 	= DMG_BURN,
	tracer 		= TRACER_NONE,
	plydmg 		= 5,
	npcdmg 		= 5,
	force 		= 0,
	minsplash 	= 10,
	maxsplash 	= 10,
	maxcarry 	= 8
})

SWEP.Base					= "weapon_base"

SWEP.PrintName				= "Molotov"	
SWEP.ClassName				= "weapon_nmrih_molotov"			
SWEP.Author					= "Anya O'Quinn"
SWEP.Instructions			= "Left click to throw and burn the infidels."

if vFireInstalled then
	SWEP.Category			= "vFire Weapons"
else
	SWEP.Category			= "Anya O'Quinn"
end

SWEP.Spawnable				= false
SWEP.AdminOnly				= false

SWEP.Slot					= 1
SWEP.SlotPos				= 1
SWEP.AutoSwitchTo			= false
SWEP.AutoSwitchFrom			= false

SWEP.ViewModel				= "models/nmrih/weapons/exp_molotov/v_exp_molotov.mdl"
SWEP.WorldModel				= "models/nmrih/weapons/exp_molotov/w_exp_molotov.mdl"
SWEP.ViewModelFOV			= 50
SWEP.ViewModelFlip			= false
SWEP.BobScale 				= 0
SWEP.SwayScale 				= 1
		
SWEP.DrawAmmo				= false
SWEP.DrawCrosshair			= true

SWEP.HoldType				= "grenade"

SWEP.Primary.Delay			= 0.75
SWEP.Primary.ClipSize		= 1
SWEP.Primary.DefaultClip	= 4
SWEP.Primary.Automatic		= false
SWEP.Primary.Ammo			= "molotov"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= false
SWEP.Secondary.Ammo			= "none"

SWEP.Throwing 				= false
SWEP.StartThrow 			= false
SWEP.ResetThrow 			= false
SWEP.ThrowVel 				= 1000
SWEP.NextThrow 				= CurTime()
SWEP.NextAnimation 			= CurTime()

PrecacheParticleSystem("nmrih_molotov_explosion")

function SWEP:Initialize()
	self:SetHoldType(self.HoldType)
end

function SWEP:Deploy()

	self.Idle = true

	self.StartThrow = false
	self.Throwing = false
	self.ResetThrow = false

	if not self.Throwing then

		if IsValid(self.Weapon) and IsValid(self.Owner) then
			self.Weapon:SendWeaponAnim(ACT_VM_DRAW)
			if IsValid(self.Owner:GetViewModel()) then
				self.Weapon:SetNextPrimaryFire(CurTime() + self.Owner:GetViewModel():SequenceDuration())
				self.Weapon:SetNextSecondaryFire(CurTime() + self.Owner:GetViewModel():SequenceDuration())
				self.NextThrow = CurTime() + self.Owner:GetViewModel():SequenceDuration()
				self.StartIdle = CurTime() + self.Owner:GetViewModel():SequenceDuration()
			end	
			if self.Owner:GetAmmoCount(self.Primary.Ammo) > 0 and self:Clip1() <= 0 then
				self.Owner:RemoveAmmo(1, self.Primary.Ammo)
				self:SetClip1(self:Clip1() + 1)
			end
		end
		
	end
	
	return true	
	
end

function SWEP:Holster()
	self.StartThrow = false
	self.Throwing = false
	self.ResetThrow = false
	return true
end

function SWEP:CreateGrenade()

	if IsValid(self.Owner) and IsValid(self.Weapon) and SERVER then

		local ent = ents.Create("rj_molotov")
		if not ent then return end
		ent.Owner = self.Owner
		ent.Inflictor = self.Weapon
		ent:SetOwner(self.Owner)		
		local eyeang = self.Owner:GetAimVector():Angle()
		local right = eyeang:Right()
		local up = eyeang:Up()
		ent:SetPos(self.Owner:GetShootPos() + right * 6 + up * -2)
		ent:SetAngles(self.Owner:GetAngles())
		ent:SetPhysicsAttacker(self.Owner)
		ent:Spawn()
		
		local phys = ent:GetPhysicsObject()
		if IsValid(phys) then
			phys:SetVelocity(self.Owner:GetAimVector() * self.ThrowVel + (self.Owner:GetVelocity() * 0.5))
			phys:ApplyForceOffset(ent:GetUp() * math.random(-25,-50), ent:GetPos() + ent:GetRight() * math.random(-5,5))
		end
		
	end
	
end

local bobtime 	= 10
local bobscale 	= 0.0125
local xoffset 	= 0
local yoffset 	= 0

function SWEP:Think()

	if not IsValid(self.Owner) then return end

	if (self.Owner:KeyDown(IN_FORWARD) or self.Owner:KeyDown(IN_BACK) or self.Owner:KeyDown(IN_MOVELEFT) or self.Owner:KeyDown(IN_MOVERIGHT) or self.Owner:KeyDown(IN_BACK)) and not self.Owner:KeyDown(IN_JUMP) and self.Owner:IsOnGround() and not self.StartIdle and not self.StartThrow and not self.Throwing then
		self.Idle = false
		if self.Owner:KeyDown(IN_SPEED) and not self.Owner:KeyDown(IN_DUCK) then
			self.Walk = false
			if not self.Run then
				self.Weapon:SendWeaponAnim(ACT_VM_IDLE_DEPLOYED_1)
				self.Run = true
			end
			bobtime = self.Owner:GetRunSpeed() / 20
		else
			self.Run = false
			if not self.Walk then
				self.Weapon:SendWeaponAnim(ACT_WALK)
				self.Walk = true
			end
			bobtime = self.Owner:GetWalkSpeed() / 15
		end
		local xoffset = math.sin(CurTime() * bobtime) * self.Owner:GetVelocity():Length() * bobscale / 100
		local yoffset = math.sin(2 * CurTime() * bobtime) * self.Owner:GetVelocity():Length() * bobscale / 400
		self.Owner:ViewPunch(Angle(xoffset,yoffset,0))
	elseif (not self.Idle or (self.StartIdle and self.StartIdle < CurTime())) and not self.StartThrow and not self.Throwing then
		self.Weapon:SendWeaponAnim(ACT_VM_IDLE)
		self.Run = false
		self.Walk = false
		self.Idle = true
		self.StartIdle = nil	
	end
	
	if not self.StartIdle and not self.Throwing and not self.StartThrow and not self.Owner:KeyDown(IN_SPEED) and self.Owner:KeyDown(IN_ATTACK) and not (self.Owner:GetAmmoCount(self.Primary.Ammo) <= 0 and self:Clip1() <= 0) then
		self.StartThrow = true
		self.Weapon:SendWeaponAnim(ACT_VM_PULLPIN)
		if IsValid(self.Owner:GetViewModel()) then
			self.NextThrow = CurTime() + self.Owner:GetViewModel():SequenceDuration()
			self.Weapon:SetNextPrimaryFire(CurTime() + self.Owner:GetViewModel():SequenceDuration())
			self.Weapon:SetNextSecondaryFire(CurTime() + self.Owner:GetViewModel():SequenceDuration())
		end
	end
	
	if self.StartThrow and not self.Owner:KeyDown(IN_ATTACK) and not self.Owner:KeyDown(IN_SPEED) and self.NextThrow < CurTime() then

		self.StartThrow = false
		self.Throwing = true
		self.Weapon:SendWeaponAnim(ACT_VM_THROW)
		self.Owner:SetAnimation(PLAYER_ATTACK1)		
		self:CreateGrenade(self.Owner, self.Weapon)
		self:TakePrimaryAmmo(1)
		self.NextAnimation = CurTime() + self.Primary.Delay
		self.ResetThrow = true
		
	elseif self.Owner:KeyDown(IN_SPEED) then
	
		self.StartThrow = false
		self.ResetThrow = false
		self.Throwing = false		

	end
	
	if self.Throwing and self.ResetThrow and self.NextAnimation < CurTime() then

		if self.Owner:GetAmmoCount(self.Primary.Ammo) > 0 and self:Clip1() <= 0 then
		
			self.Owner:RemoveAmmo(1, self.Primary.Ammo)
			self:SetClip1(self:Clip1() + 1)
			self.Weapon:SendWeaponAnim(ACT_VM_DRAW)
			if IsValid(self.Owner:GetViewModel()) then
				self.NextThrow = CurTime() + self.Owner:GetViewModel():SequenceDuration()
				self.StartIdle = CurTime() + self.Owner:GetViewModel():SequenceDuration()
				self.Weapon:SetNextPrimaryFire(CurTime() + self.Owner:GetViewModel():SequenceDuration())
				self.Weapon:SetNextSecondaryFire(CurTime() + self.Owner:GetViewModel():SequenceDuration())
			end
			
		elseif self.Owner:GetAmmoCount(self.Primary.Ammo) == 0 and self:Clip1() == 0 then
			self.Owner:ConCommand("lastinv")
		end
		
		self.ResetThrow = false
		self.Throwing = false
		
	end
	
end

function SWEP:CanPrimaryAttack()
	return false
end

function SWEP:PrimaryAttack()
	return false
end

function SWEP:SecondaryAttack()
	return false
end

function SWEP:Reload()
end

function SWEP:ShouldDropOnDie()
	return false
end

local ENT = {}

ENT.PrintName = "Molotov"
ENT.Type = "anim"  
ENT.Base = "base_anim"

if CLIENT then
	function ENT:Draw()
		self:DrawModel()
	end
end

if SERVER then

	function ENT:Initialize()

		self:SetModel("models/nmrih/weapons/exp_molotov/w_exp_molotov.mdl")
		self:PhysicsInit(SOLID_VPHYSICS)
		self:SetMoveType(MOVETYPE_VPHYSICS)
		self:SetSolid(SOLID_VPHYSICS)
		self:SetCollisionGroup(COLLISION_GROUP_PROJECTILE)
		
		local phys = self:GetPhysicsObject()  	
		if IsValid(phys) then 
			phys:Wake()
			phys:EnableDrag(false)
			phys:AddGameFlag(FVPHYSICS_NO_IMPACT_DMG)
			phys:SetBuoyancyRatio(0)
		end

		self.BurnSound = CreateSound(self, "Weapon_NMRiH_Molotov.Rag_Loop")
		self.BurnSound:Play()
		
		self:Fire("kill", 1, 10)

	end
	
	function ENT:Think()

		if self.HitData and not hull then
		
			if self.Dud then 
				self:NextThink(CurTime() + 300)
				self:Remove()
				return false
			end
		
			local hull = ents.Create("rj_molotov_hull")
			if not hull then return end
			hull:SetPos(self.HitData.HitPos + self.HitData.HitNormal * 40)
			hull:SetAngles(self.HitData.HitNormal:Angle() + Angle(90,0,0))
			hull:SetOwner(self.Owner)
			hull.Owner = self.Owner
			hull.vFirePos = self.HitData.HitPos
			hull.vFireVel = self.HitData.Velocity or vector_origin
			hull.Inflictor = self.Weapon
			hull:Spawn()

			self:SetCollisionGroup(COLLISION_GROUP_DEBRIS)
			self:SetMoveType(MOVETYPE_NONE)
			self:Remove()

		end
		
		self:NextThink(CurTime())
		
	end
	
	function ENT:OnRemove()
		if self.BurnSound then 
			self.BurnSound:Stop()
		end
	end
	
	function ENT:PhysicsCollide(data, phys)	
	
		if IsValid(self) and not self.Hit then
		
			self:SetNoDraw(true)
			
			local trdata = {}
			trdata.start = data.HitPos
			trdata.endpos = data.HitPos + data.HitNormal
			local tr = util.TraceLine(trdata)
			
			if tr.Hit then		
			
				self.HitData = tr
				self.HitData.Velocity = self:GetVelocity()
				self.Hit = true
				
				if self:WaterLevel() > 0 then 
					self.Dud = true 
					self:EmitSound("physics/glass/glass_bottle_break"..math.random(1,2)..".wav", 90, 100)
					return false 
				end
				
				if IsValid(self.Owner) then
					util.BlastDamage(self, self.Owner, self:GetPos(), 200, 40) 
				else
					util.BlastDamage(self, self, self:GetPos(), 200, 40) 
				end
				
				if not vFireInstalled or (vFireInstalled and GetConVar("vfire_molotov_enabled") and not GetConVar("vfire_molotov_enabled"):GetBool()) then -- emit the original particle effect if vFire is disabled/missing
					ParticleEffect("nmrih_molotov_explosion",tr.HitPos,tr.HitNormal:Angle() + Angle(90,0,0)) 
				end
				
				self:EmitSound("Weapon_NMRiH_Molotov.Explode")
				
			end
			
		end	
		
	end
	
end

scripted_ents.Register(ENT, "rj_molotov", true)

local HULL = {}

HULL.PrintName = "Molotov Point Hurt"
HULL.Type = "anim"
HULL.Base = "base_anim"

if CLIENT then
	net.Receive("Molotov_vFireBall",function()
		if vFireInstalled then
			local rad = net.ReadFloat()
			local pos = net.ReadVector()
			local vel = net.ReadVector()
			molotov_vFireBall = CreateCSVFireBall(rad, pos, vel, 20, false)
		end
	end)
end

if SERVER then

	util.AddNetworkString("Molotov_vFireBall")

	function HULL:Initialize()
	
		self:SetModel("models/hunter/blocks/cube4x4x2.mdl")
		self:SetMoveType(MOVETYPE_NONE)
		self:SetSolid(SOLID_VPHYSICS)
		self:SetCollisionGroup(COLLISION_GROUP_DEBRIS_TRIGGER)
		self:SetNoDraw(true)
		self:SetTrigger(true)
		
		self.NextHurt = CurTime()

		self.BurnSound = CreateSound(self, "ambient/fire/fire_small_loop1.wav")
		self.BurnSound:PlayEx(1,98)
		self.BurnSound:SetSoundLevel(80)
		
		self:Fire("kill", 1, 20)

		if vFireInstalled and GetConVar("vfire_molotov_enabled") and GetConVar("vfire_molotov_enabled"):GetBool() and self.vFirePos then --vFire is installed and enabled, make a vFire
		
			local rad = self:BoundingRadius()
			local vel = self:GetUp() * 10

			for i=1,8 do
				self.vFire = CreateVFire(self, self:GetPos() + (self:GetForward() * VectorRand() * rad / 2) + (self:GetRight() * VectorRand() * rad / 2) - self:GetUp() * 40, self:GetUp(), 40)
			end
			
			self.vFireBall = CreateVFireBall(rad, rad * 2, self.vFirePos, vel, self:GetOwner() or self.Owner or self)
			
			net.Start("Molotov_vFireBall")
				local filter = RecipientFilter()
				filter:AddAllPlayers()
				net.WriteFloat(rad)
				net.WriteVector(self.vFirePos)
				net.WriteVector(vel)
			net.Send(filter)

		end
		
	end
	
	function HULL:Touch(victim)

		if self.NextHurt < CurTime() then
	
			local attacker = self:GetOwner() or self.Owner or self
			local inflictor = self.Inflictor or self
			if not IsValid(attacker) then return end
			
			local dmg = DamageInfo()
			dmg:SetDamage(5)
			dmg:SetDamageType(DMG_BURN)
			dmg:SetDamagePosition(self:GetPos())
			dmg:SetDamageForce(Vector(0,0,0))
			dmg:SetAttacker(attacker)
			dmg:SetInflictor(inflictor)
			
			if IsValid(victim) then
				victim:TakeDamageInfo(dmg)
				victim:Ignite(1,10)
			end
			
			self.NextHurt = CurTime() + 0.25
		
		end	
		
	end
	
	function HULL:Think()
		self:NextThink(CurTime())
	end
	
	function HULL:OnRemove()
		if self.BurnSound then 
			self.BurnSound:Stop() 
		end
	end

end

local function vFireSurfaceDamageFix(ent,dmginfo)
	local attacker = dmginfo:GetAttacker()
	local dmgtype = dmginfo:GetDamageType()
	if vFireInstalled and IsValid(ent) and IsValid(attacker) and dmgtype == DMG_BURN then
		local owner = attacker:GetOwner() or attacker.Owner
		if IsValid(owner) and owner:IsPlayer() then
			dmginfo:SetAttacker(owner)
		end
	end
end
hook.Add("EntityTakeDamage","vFireSurfaceDamageFix",vFireSurfaceDamageFix)

scripted_ents.Register(HULL, "rj_molotov_hull", true)

local AMMO = {}

AMMO.PrintName = "Molotov Bottle"
AMMO.Type = "anim"
AMMO.Base = "base_anim"
AMMO.Spawnable = false
AMMO.AdminOnly = false
AMMO.Category = "Anya O'Quinn"

if SERVER then

	function AMMO:Initialize()

		self:SetModel("models/nmrih/weapons/exp_molotov/w_exp_molotov.mdl")
		self:PhysicsInit(SOLID_VPHYSICS)
		self:SetMoveType(MOVETYPE_VPHYSICS)
		self:SetSolid(SOLID_VPHYSICS)
		self:SetCollisionGroup(COLLISION_GROUP_WEAPON)
		self:SetTrigger(true)
		
		local phys = self:GetPhysicsObject()  	
		if IsValid(phys) then 
			phys:Wake()
			phys:EnableDrag(true)
			phys:AddGameFlag(FVPHYSICS_NO_IMPACT_DMG)
			phys:SetBuoyancyRatio(0.5)
		end
	
	end
	
	function AMMO:SpawnFunction(ply,tr,class)

		if not tr.Hit then return end

		local pos = tr.HitPos + tr.HitNormal * 10

		local ent = ents.Create(class)
		if not ent then return end
		ent:SetPos(pos)
		ent:Spawn()
		ent:Activate()

		return ent

	end
	
	function AMMO:StartTouch(ply)
		if IsValid(self) and IsValid(ply) and ply:IsPlayer() then
			ply:GiveAmmo(5,"molotov")
			self:Remove()
		end
	end
	
end

scripted_ents.Register(AMMO, "rj_molotov_ammo", true)

-- 37062385
--addons/emplacements/lua/weapons/weapon_swrp_bullets2_deployable.lua:
SWEP.Base							= "tfa_gun_base"
SWEP.Category						= "SW:RP (Sonstiges)"
SWEP.Manufacturer 					= ""
SWEP.Author							= "Summe"

SWEP.PrintName						= "Heavy Blaster Cannon"
SWEP.Slot							= 3
SWEP.SlotPos						= 0
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.ViewModel						= "models/bf2017/c_scoutblaster.mdl"
SWEP.WorldModel						= "models/bf2017/w_scoutblaster.mdl"
SWEP.ShowViewModel = false
SWEP.ShowWorldModel = false

SWEP.ViewModelFOV					= 75
SWEP.ViewModelFlip					= false
SWEP.MaterialTable 					= nil
SWEP.UseHands 						= false
SWEP.HoldType 						= "duel"
SWEP.MoveSpeed 						= 0.5
SWEP.RunSpeed						= 0.7

SWEP.Primary.ClipSize = 1
SWEP.Primary.DefaultClip = 1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"

SWEP.TurretStand = "swrp_turret_stand_bullets2"

SWEP.VElements = {
	["carte"] = {
		type = "Model",
		model = "models/kingpommes/starwars/misc/imp_crate_double_closed.mdl",
		bone = "v_scoutblaster_reference001",
		rel = "",
		pos = Vector(0, 0, -15),
		angle = Angle(0, 190, 0),
		size = Vector(0.8, 0.8, 0.8),
		color = Color(255, 255, 255, 255),
		surpresslightning = false,
		material = "",
		skin = 2,
		bodygroup = {}
	},
}

SWEP.WElements = {
	["carte"] = {
		type = "Model",
		model = "models/kingpommes/starwars/misc/imp_crate_double_closed.mdl",
		bone = "ValveBiped.Bip01_R_Hand",
		rel = "",
		pos = Vector(-02, 10.5, -10),
		angle = Angle(180, 90, -4),
		size = Vector(0.5, 0.5, 0.5),
		color = Color(255, 255, 255, 255),
		surpresslightning = false,
		material = "",
		skin = 2,
		bodygroup = {}
	}
}

SWEP.HolsterOffset = Vector(8, 0, 10)
SWEP.HolsterAngle = Angle(0, 0, 0)

function SWEP:PrimaryAttack()
	local turret = {
		[self.TurretStand] = true,
	}

	local ply = self:GetOwner()
	local trace = ply:GetEyeTrace().Entity

	if IsValid(ply) and ply:IsPlayer() then
		if trace:GetPos():DistToSqr(ply:EyePos()) < 150 * 150 then
			if turret[trace:GetClass()] then
				trace:SetNWBool("Remove?", true)

				if SERVER then
					-- If the player has no ammo left, remove the weapon
					if self:Clip1() <= 1 then
						self:GetOwner():StripWeapon(self:GetClass())
					else
						self:TakePrimaryAmmo(1)
					end
				end
			end
		else
			if SERVER then
				self:SpawnStand()
			end
		end
	end
end

function SWEP:SpawnStand()
	local trace = self:GetOwner():GetEyeTrace()

	if trace.Hit then
		local endpos = trace.HitPos
		local distance = self:GetOwner():GetPos():DistToSqr(endpos)

		if distance <= 40000 then
			local stand = ents.Create(self.TurretStand)

			if IsValid(stand) then
				stand:SetPos(endpos + Vector(0, 0, 8))
				stand:Spawn()
				stand:Activate()
				stand.owner = self:GetOwner()

				if self:Clip1() <= 1 then
					self:GetOwner():StripWeapon(self:GetClass())
				else
					self:TakePrimaryAmmo(1)
				end
			end
		end
	end
end

--addons/egm_tfa_weapons/lua/weapons/weapon_swrp_cyclerrifle.lua:
-- Written by Oninoni and Meredin

SWEP.Base                   = "weapon_swrp_egm_3dscoped_base"

SWEP.PrintName				= "Cycler Rifle"
SWEP.Category               = "SW:RP (Event)"
SWEP.Type					= "Tusken Raider Cycler Rifle"
SWEP.Manufacturer 			= "Handmade"
SWEP.Slot                   = 0
SWEP.SlotPos                = 0

SWEP.Spawnable = true

-- Model --

SWEP.ViewModel						= "models/weapons/synbf3/c_dlt19.mdl"
SWEP.WorldModel						= "models/weapons/synbf3/w_dlt19.mdl"
SWEP.ViewModelFOV					= 65

SWEP.VMPos = Vector(3.03, -2, -01.944)
SWEP.VMAng = Vector(0, 0, 0)

SWEP.HoldType 						= "ar2"
SWEP.ReloadHoldTypeOverride 		= "ar2"

SWEP.UseHands 						= true

SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
	["v_dlt19_reference001"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) }
}

SWEP.VElements = {
	["tcr"] = { type = "Model", model = "models/sw_battlefront/weapons/tusken_cycler_rifle.mdl", bone = "v_dlt19_reference001", rel = "", pos = Vector(0, -1, 1), angle = Angle(0, -90, 0), size = Vector(1.2, 1.1, 1.2), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["scope"] = { type = "Model", model = "models/rtcircle.mdl", bone = "v_dlt19_reference001", rel = "tcr", pos = Vector(9, 1.44, 2.37), angle = Angle(0, 180, 0), size = Vector(0.18, 0.18, 0.18), color = Color(255, 255, 255, 255), surpresslightning = false, material = "!tfa_rtmaterial", skin = 0, bodygroup = {} },
}

SWEP.WElements = {
	["tcr"] = { type = "Model", model = "models/sw_battlefront/weapons/tusken_cycler_rifle.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(2, 0.4, -2), angle = Angle(-12, 0, 172), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

SWEP.HolsterOffset = Vector(14, 0, 1)
SWEP.HolsterAngle = Angle(0, 180, 0)



-- Tracer --

-- Tracer name
SWEP.TracerName 					= "rw_sw_laser_yellow"


-- Magazine --

-- Ammo per Magazine
SWEP.Primary.ClipSize				= 40
-- Magazine Count
SWEP.Primary.DefaultClip			= SWEP.Primary.ClipSize * 10
-- Ammo Type
SWEP.Primary.Ammo					= "ar2"
-- Ammo Consumption per shot
SWEP.Primary.AmmoConsumption 		= 40

-- Fire Modes --

-- Actual Fire Modes.
SWEP.FireModes = {
	"Single",
}

-- Automatic RPM
SWEP.Primary.RPM					= nil
-- Semi Automatic Fire RPM
SWEP.Primary.RPM_Semi				= 120

-- Burst Fire RPM
SWEP.Primary.RPM_Burst				= nil
-- Delay Between Bursts
SWEP.Primary.BurstDelay				= nil

-- Range --

-- Max Range of weapon
SWEP.Primary.Range 					= 12000

-- Shooting --

-- Number of bullets per shot (For Shotguns)
SWEP.Primary.NumShots				= 1
-- Damage per bullet
SWEP.Primary.Damage = 200

-- Aiming --

SWEP.data 							= {}
-- Enable Iron Sights
SWEP.data.ironsights				= 1
-- Iron Sights FOV
SWEP.Secondary.IronFOV				= 75 -- TODO

SWEP.RTScopeAttachment				= -1
SWEP.Scoped_3D 						= false
SWEP.ScopeReticule 					= "#sw/visor/sw_ret_redux_yellow"
SWEP.Secondary.ScopeZoom 			= 4
SWEP.ScopeReticule_Scale 			= {1,1}
SWEP.IronSightsSensitivity          = 0.25

SWEP.Primary.Spread					= 0.2
SWEP.Primary.IronAccuracy 			= 0.001

SWEP.Primary.SpreadMultiplierMax 	= 5
SWEP.Primary.SpreadIncrement 		= 1

SWEP.ZoomLevels = {
	2,
	4,
	7,
	15
}

-- Holding Positions

-- Aiming
SWEP.IronSightsPos = Vector(-8.1, -13, 4.7)
SWEP.IronSightsAng = Vector(0, 0, 0)
-- Running
SWEP.RunSightsPos = Vector(5.226, -2, 0)
SWEP.RunSightsAng = Vector(-18, 36, -13.5)
-- Inspecting
SWEP.InspectPos = Vector(8, -4.8, -3)
SWEP.InspectAng = Vector(11.199, 38, 0)

-- Sounds --

-- Fire Sound
SWEP.Primary.Sound 					= Sound ("w/tcr.wav");
-- Reload Sound
SWEP.Primary.ReloadSound 			= Sound ("w/heavy.wav");

if surface then
	SWEP.Secondary.ScopeTable = {
		["ScopeMaterial"] =  Material("#sw/visor/sw_ret_redux_yellow.png", "smooth"),
		["ScopeBorder"] = color_black,
		["ScopeCrosshair"] = { ["r"] = 0, ["g"]  = 0, ["b"] = 0, ["a"] = 0, ["s"] = 1 }
	}
end


DEFINE_BASECLASS( SWEP.Base )
--addons/egm_tfa_weapons/lua/weapons/weapon_swrp_dc15x.lua:
-- Written by Oninoni

SWEP.Base                   = "weapon_swrp_egm_3dscoped_base"

SWEP.PrintName              = "DC-15X"
SWEP.Category               = "SW:RP (Republik)"
SWEP.Type					= "Republic Precision Rifle"
SWEP.Manufacturer           = "BlasTech Industries"
SWEP.Slot                   = 0
SWEP.SlotPos                = 0

SWEP.Spawnable = true

-- Model --

SWEP.ViewModel						= "models/weapons/synbf3/c_dlt19.mdl"
SWEP.WorldModel						= "models/weapons/synbf3/w_dlt19.mdl"

SWEP.VMPos = Vector(01, -2, -4)
SWEP.VMAng = Vector(0, 0, 0)

SWEP.HoldType 						= "ar2"
SWEP.ReloadHoldTypeOverride 		= "ar2"

SWEP.UseHands 						= true

SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
	["v_dlt19_reference001"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) }
}

SWEP.VElements = {
	["dc15x"] = { type = "Model", model = "models/sw_battlefront/weapons/dc15x_rifle.mdl", bone = "v_dlt19_reference001", rel = "", pos = Vector(0.75, -1.5, 2.5), angle = Angle(0, -90, 0), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["scope"] = { type = "Model", model = "models/rtcircle.mdl", bone = "v_dlt19_reference001", rel = "dc15x", pos = Vector(-1.8, 0, 4.48), angle = Angle(0, 180, 0), size = Vector(0.30, 0.30, 0.30), color = Color(255, 255, 255, 255), surpresslightning = false, material = "!tfa_rtmaterial", skin = 0, bodygroup = {} }
}

SWEP.WElements = {
	["dc15x"] = { type = "Model", model = "models/sw_battlefront/weapons/dc15x_rifle.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3, 0.4, -2), angle = Angle(-13, 0, 180), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
}

SWEP.HolsterOffset = Vector(12, 0, 0)
SWEP.HolsterAngle = Angle(0, 180, 0)

if surface then
	SWEP.Secondary.ScopeTable = nil
end



-- Tracer --

-- Tracer name
SWEP.TracerName 					= "rw_sw_laser_blue"
SWEP.ImpactEffect 					= "rw_sw_impact_blue"


-- Magazine --

-- Ammo per Magazine
SWEP.Primary.ClipSize				= 40
-- Magazine Count
SWEP.Primary.DefaultClip			= SWEP.Primary.ClipSize * 10
-- Ammo Type
SWEP.Primary.Ammo					= "ar2"
-- Ammo Consumption per shot
SWEP.Primary.AmmoConsumption 		= 20

-- Fire Modes --

-- Actual Fire Modes.
SWEP.FireModes = {
	"Single",
}

-- Automatic RPM
SWEP.Primary.RPM					= nil
-- Semi Automatic Fire RPM
SWEP.Primary.RPM_Semi				= 120

-- Burst Fire RPM
SWEP.Primary.RPM_Burst				= nil
-- Delay Between Bursts
SWEP.Primary.BurstDelay				= nil

-- Range --

-- Max Range of weapon
SWEP.Primary.Range 					= 8000

-- Shooting --

-- Number of bullets per shot (For Shotguns)
SWEP.Primary.NumShots				= 1
-- Damage per bullet
SWEP.Primary.Damage = 200

-- Aiming --

SWEP.data 							= {}
-- Enable Iron Sights
SWEP.data.ironsights				= 1
-- Iron Sights FOV
SWEP.Secondary.IronFOV				= 75 -- TODO

SWEP.RTScopeAttachment				= -1
SWEP.Scoped_3D 						= false
SWEP.ScopeReticule 					= "#sw/visor/sw_ret_redux_blue"
SWEP.Secondary.ScopeZoom 			= 4
SWEP.ScopeReticule_Scale 			= {1.1,1.1}
SWEP.IronSightsSensitivity          = 0.25

SWEP.Primary.Spread					= 0.02
SWEP.Primary.IronAccuracy 			= 0

SWEP.Primary.SpreadMultiplierMax 	= 5
SWEP.Primary.SpreadIncrement 		= 1

SWEP.ZoomLevels = {
	2,
	4,
	7,
	15,
	30
}

-- Holding Positions

-- Aiming
SWEP.IronSightsPos = Vector(-3.875, -2.5, 3.15)
SWEP.IronSightsAng = Vector(0, 0, 0)
-- Running
SWEP.RunSightsPos = Vector(5.226, -2, 0)
SWEP.RunSightsAng = Vector(-18, 36, -13.5)
-- Inspecting
SWEP.InspectPos = Vector(8, -4.8, -3)
SWEP.InspectAng = Vector(11.199, 38, 0)

-- Sounds --

-- Fire Sound
SWEP.Primary.Sound 					= Sound ("w/dc15x.wav")
-- Reload Sound
SWEP.Primary.ReloadSound 			= Sound("weapons/dc15x_reload.wav")

DEFINE_BASECLASS( SWEP.Base )
--addons/egm_tfa_weapons/lua/weapons/weapon_swrp_deathwatch.lua:
-- Written by Oninoni

SWEP.Base                   = "weapon_swrp_egm_base"

SWEP.PrintName              = "Westar 35"
SWEP.Category               = "SW:RP (Event)"
SWEP.Type					= "Blaster pistol"
SWEP.Manufacturer           = "Concordian Crescent Technologies"
SWEP.Slot                   = 2
SWEP.SlotPos                = 0

SWEP.Spawnable = true

-- Model --

SWEP.ViewModel						= "models/bf2017/c_scoutblaster.mdl"
SWEP.WorldModel						= "models/bf2017/w_scoutblaster.mdl"

SWEP.VMPos = Vector(0.88, -4, -0.240)
SWEP.VMAng = Vector(0,0,0)

SWEP.HoldType 						= "pistol"
SWEP.ReloadHoldTypeOverride 		= "pistol"

SWEP.UseHands 						= true

SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
	["v_scoutblaster_reference001"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, -0.3, 0), angle = Angle(0, 0, 0) }
}

SWEP.VElements = {
	["deathwatch"] = { type = "Model", model = "models/sw_battlefront/weapons/westar_35_pistol.mdl", bone = "v_scoutblaster_reference001", rel = "", pos = Vector(-0.25, -0.5, 0), angle = Angle(0, 180, 0), size = Vector(1.1, 1.1, 1.1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
}

SWEP.WElements = {
	["deathwatch"] = { type = "Model", model = "models/sw_battlefront/weapons/westar_35_pistol.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(4, 1.5, -1.3), angle = Angle(0, -95, 170), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

SWEP.HolsterOffset = Vector(3, 0.3, 0)
SWEP.HolsterAngle = Angle(0, -90, 0)

SWEP.Animations = { --Override this after SWEP:Initialize, for example, in attachments
	["reload"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_RELOAD_EMPTY,
		["enabled"] = true
	},
	["reload_empty"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_RELOAD_EMPTY
	},
	["reload_silenced"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_RELOAD_EMPTY,
		["enabled"] = true
	},
}



-- Tracer --

-- Tracer name
SWEP.TracerName 					= "rw_sw_laser_yellow"


-- Magazine --

-- Ammo per Magazine
SWEP.Primary.ClipSize				= 100
-- Magazine Count
SWEP.Primary.DefaultClip			= SWEP.Primary.ClipSize * 8
-- Ammo Type
SWEP.Primary.Ammo					= "ar2"
-- Ammo Consumption per shot
SWEP.Primary.AmmoConsumption 		= 1

-- Fire Modes --

-- Actual Fire Modes.
SWEP.FireModes = {
	"Single",
}

-- Automatic RPM
SWEP.Primary.RPM					= nil
-- Semi Automatic Fire RPM
SWEP.Primary.RPM_Semi				= 280

-- Burst Fire RPM
SWEP.Primary.RPM_Burst				= nil
-- Delay Between Bursts
SWEP.Primary.BurstDelay				= nil

-- Range --

-- Max Range of weapon
SWEP.Primary.Range 					= 2040

-- Shooting --

-- Number of bullets per shot (For Shotguns)
SWEP.Primary.NumShots				= 1
-- Damage per bullet
SWEP.Primary.Damage = 28

-- Aiming --

SWEP.data 							= {}
-- Enable Iron Sights
SWEP.data.ironsights				= 1
-- Iron Sights FOV
SWEP.Secondary.IronFOV				= 75 -- TODO

SWEP.ScopeReticule 					= "#sw/visor/sw_ret_redux_blue"
SWEP.Secondary.ScopeZoom 			= 7
SWEP.ScopeReticule_Scale 			= {1,1}

SWEP.Primary.Spread					= 0.0125
SWEP.Primary.IronAccuracy 			= 0.0042

SWEP.Primary.SpreadMultiplierMax 	= 2.5
SWEP.Primary.SpreadIncrement 		= 0.35

-- Holding Positions

-- Aiming
SWEP.IronSightsPos = Vector(-5.1, -6, 2)
SWEP.IronSightsAng = Vector(0, 0, 0)
-- Running
SWEP.RunSightsPos = Vector(5.226, -2, 0)
SWEP.RunSightsAng = Vector(-18, 36, -13.5)
-- Inspecting
SWEP.InspectPos = Vector(8, -4.8, -3)
SWEP.InspectAng = Vector(11.199, 38, 0)

-- Sounds --

-- Fire Sound
SWEP.Primary.Sound = Sound("weapons/dwrifle_fire.wav")
-- Reload Sound
SWEP.Primary.ReloadSound = Sound("weapons/dwrifle_reload.ogg")

DEFINE_BASECLASS( SWEP.Base )
--addons/egm_tfa_weapons/lua/weapons/weapon_swrp_dl44.lua:
-- Written by Oninoni and Meredin

SWEP.Base                   = "weapon_swrp_egm_3dscoped_base"

SWEP.PrintName              = "DL-44"
SWEP.Category               = "SW:RP (Event)"
SWEP.Type					= "Blaster Pistol"
SWEP.Manufacturer           = "BlasTech Industries"
SWEP.Slot                   = 1
SWEP.SlotPos                = 0

SWEP.Spawnable = true

-- Model --

SWEP.ViewModel						= "models/bf2017/c_scoutblaster.mdl"
SWEP.WorldModel						= "models/bf2017/w_scoutblaster.mdl"

SWEP.VMPos = Vector(0.88, -4, -0.240)
SWEP.VMAng = Vector(0,0,0)

SWEP.HoldType 						= "pistol"
SWEP.ReloadHoldTypeOverride 		= "pistol"

SWEP.UseHands 						= true

SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
	["v_scoutblaster_reference001"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, -0.3, 0), angle = Angle(0, 0, 0) }
}

SWEP.VElements = {
	["dl44"] = { type = "Model", model = "models/sw_battlefront/weapons/dl44_pistol.mdl", bone = "v_scoutblaster_reference001", rel = "", pos = Vector(0, 0, 0), angle = Angle(0, 90, 0), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["scope"] = { type = "Model", model = "models/rtcircle.mdl", bone = "v_scoutblaster_reference001", rel = "dl44", pos = Vector(-2.3, 1.42, 3.295), angle = Angle(0, 180, 0), size = Vector(0.35, 0.35, 0.35), color = Color(255, 255, 255, 255), surpresslightning = false, material = "!tfa_rtmaterial", skin = 0, bodygroup = {} }
}

SWEP.WElements = {
	["dl44"] = { type = "Model", model = "models/sw_battlefront/weapons/dl44_pistol.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3.5, 1.5, -1.4), angle = Angle(0, 0, 173), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

SWEP.HolsterOffset = Vector(5, 0.2, -2)
SWEP.HolsterAngle = Angle(0, 180, 0)

SWEP.Animations = { --Override this after SWEP:Initialize, for example, in attachments
	["reload"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_RELOAD_EMPTY,
		["enabled"] = true
	},
	["reload_empty"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_RELOAD_EMPTY
	},
	["reload_silenced"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_RELOAD_EMPTY,
		["enabled"] = true
	},
}



-- Tracer --

-- Tracer name
SWEP.TracerName 					= "rw_sw_laser_red"


-- Magazine --

-- Ammo per Magazine
SWEP.Primary.ClipSize				= 100
-- Magazine Count
SWEP.Primary.DefaultClip			= SWEP.Primary.ClipSize * 8
-- Ammo Type
SWEP.Primary.Ammo					= "ar2"
-- Ammo Consumption per shot
SWEP.Primary.AmmoConsumption 		= 1

-- Fire Modes --

-- Actual Fire Modes.
SWEP.FireModes = {
	"Single",
}

-- Automatic RPM
SWEP.Primary.RPM					= nil
-- Semi Automatic Fire RPM
SWEP.Primary.RPM_Semi				= 250

-- Burst Fire RPM
SWEP.Primary.RPM_Burst				= nil
-- Delay Between Bursts
SWEP.Primary.BurstDelay				= nil

-- Range --

-- Max Range of weapon
SWEP.Primary.Range 					= 2040

-- Shooting --

-- Number of bullets per shot (For Shotguns)
SWEP.Primary.NumShots				= 1
-- Damage per bullet
SWEP.Primary.Damage = 35

-- Aiming --

SWEP.data 							= {}
-- Enable Iron Sights
SWEP.data.ironsights				= 1
-- Iron Sights FOV
SWEP.Secondary.IronFOV				= 75 -- TODO

SWEP.RTScopeAttachment				= -1
SWEP.Scoped_3D 						= false
SWEP.ScopeReticule 					= "#sw/visor/sw_ret_redux_red"
SWEP.Secondary.ScopeZoom 			= 2
SWEP.ScopeReticule_Scale 			= {1.1,1.1}
SWEP.IronSightsSensitivity          = 0.25

SWEP.Primary.Spread					= 0.0145
SWEP.Primary.IronAccuracy 			= 0.0048

SWEP.Primary.SpreadMultiplierMax 	= 4
SWEP.Primary.SpreadIncrement 		= 0.3

SWEP.ZoomLevels = {
	2,
	5
}

-- Holding Positions

-- Aiming
SWEP.IronSightsPos = Vector(-6.6, -10, 1.95)
SWEP.IronSightsAng = Vector(0, 0, 0)
-- Running
SWEP.RunSightsPos = Vector(2, -9.5, -15)
SWEP.RunSightsAng = Vector(39, -0.5, -2)
-- Inspecting
SWEP.InspectPos = Vector(8, -4.8, -3)
SWEP.InspectAng = Vector(11.199, 38, 0)

-- Sounds --

-- Fire Sound
SWEP.Primary.Sound 					= Sound ("weapons/dl44_fire.wav")
-- Reload Sound
SWEP.Primary.ReloadSound 			= Sound ("weapons/bf3/pistols.wav")

DEFINE_BASECLASS( SWEP.Base )
--addons/lvs_base/lua/weapons/weapon_swrp_e60r.lua:
SWEP.Base = "tfa_3dscoped_base"
SWEP.Author = "ChanceSphere574"
SWEP.Contact = ""
SWEP.Spawnable = true
SWEP.DrawCrosshair = true
SWEP.PrintName = "E-60R"
SWEP.Slot = 2
SWEP.SlotPos = 100
SWEP.DrawAmmo = true

SWEP.ViewModel = "models/bf2017/c_dlt19.mdl"
SWEP.WorldModel = "models/bf2017/w_dlt19.mdl"
SWEP.ViewModelFOV = 50
SWEP.ViewModelFlip = false

SWEP.Category = "SW:RP (Separatisten)"
SWEP.Manufacturer = "Baktoid Armor Workshop"
SWEP.AdminSpawnable = true
SWEP.Type = "Separatistischer Raketenwerfer"
SWEP.data = {}
SWEP.data.ironsights = 1
SWEP.Secondary.IronFOV = 75
SWEP.DoMuzzleFlash = true
SWEP.SelectiveFire = true
SWEP.DisableChambering = true
SWEP.Primary.ClipSize = 1
SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * 8
SWEP.Primary.RPM = 120
SWEP.Primary.Ammo = "rpg_round"
SWEP.Primary.AmmoConsumption = 1
SWEP.Primary.Range = 30000
SWEP.Primary.RangeFalloff = -1
SWEP.Primary.NumShots = 1
SWEP.Primary.Automatic = false
SWEP.Primary.BurstDelay = 0.2
SWEP.Primary.Sound = Sound("weapons/e60r_fire.wav")
SWEP.Primary.ReloadSound = Sound("weapons/e60r_reload.wav")
SWEP.Primary.Damage = 9000

SWEP.DoMuzzleFlash = false

SWEP.FireModes = {"Single"}
SWEP.AutoSwitchFrom = false
SWEP.AutoSwitchTo = false
SWEP.DefaultFireMode = "Safe"

SWEP.IronRecoilMultiplier = 0.5
SWEP.CrouchRecoilMultiplier = 0.25
SWEP.JumpRecoilMultiplier = 1.3
SWEP.WallRecoilMultiplier = 1.1
SWEP.ChangeStateRecoilMultiplier = 1.3
SWEP.CrouchAccuracyMultiplier = 0.81
SWEP.ChangeStateAccuracyMultiplier = 1.18
SWEP.JumpAccuracyMultiplier = 2
SWEP.WalkAccuracyMultiplier = 1.18
SWEP.NearWallTime = 0.25
SWEP.ToCrouchTime = 0.25
SWEP.WeaponLength = 35
SWEP.SprintFOVOffset = 12
SWEP.ProjectileVelocity = 8
SWEP.ProjectileEntity = "ent_rw_rocket_mods"
SWEP.UseHands = false
SWEP.HoldType = "rpg"
SWEP.ReloadHoldTypeOverride = "rpg"
SWEP.ShowWorldModel = false
SWEP.Tracer = 0
SWEP.TracerName = nil
SWEP.TracerCount = 1
SWEP.TracerLua = false
SWEP.TracerDelay = 0.01
SWEP.ImpactDecal = "FadingScorch"

SWEP.VMPos = Vector(2, 4, 3.5)
SWEP.VMAng = Vector(0,0,0)

SWEP.IronSightTime = 0.7
SWEP.Primary.KickUp = 0.35
SWEP.Primary.KickDown = 0.30
SWEP.Primary.KickHorizontal = 0.30
SWEP.Primary.StaticRecoilFactor = 1.2
SWEP.Primary.Spread = 0.01
SWEP.Primary.IronAccuracy = 0.005
SWEP.Primary.SpreadMultiplierMax = 2.5
SWEP.Primary.SpreadIncrement = 0.22
SWEP.Primary.SpreadRecovery = 0.8
SWEP.MoveSpeed = 0.7
SWEP.IronSightsMoveSpeed = 0.75
SWEP.IronSightsPos = Vector(-0.75, -4, -01.4)
SWEP.IronSightsAng = Vector(0, 0, 0)

SWEP.RunSightsPos = Vector(0, -2, 4)
SWEP.RunSightsAng = Vector(-35, 0, 0)

SWEP.InspectPos = Vector(8, 4.8, -3)
SWEP.InspectAng = Vector(11.199, 38, 0)

SWEP.ProceduralHolsterPos = Vector(0,-2,4)
SWEP.ProceduralHolsterAng = Vector(-35,0,0)
SWEP.DoProceduralReload = true
SWEP.ProceduralReloadTime = 3.5

SWEP.ViewModelBoneMods = {
	["v_dlt19_reference001"] = {
		scale = Vector(0.009, 0.009, 0.009),
		pos = Vector(0, 0, 1),
		angle = Angle(0, 0, 0)
	}
}

SWEP.VElements = {
	["rocketlauncher"] = {
		type = "Model",
		model = "models/cs574/weapons/e60r.mdl",
		bone = "v_dlt19_reference001",
		rel = "",
		pos = Vector(0, 0, 0),
		angle = Angle(0, -90, 0),
		size = Vector(0.8, 0.8, 0.8),
		color = Color(255, 255, 255, 255),
		surpresslightning = false,
		material = "",
		skin = 0,
		bodygroup = {}
	},
}

SWEP.WElements = {
	["rocketlauncher"] = {
		type = "Model",
		model = "models/cs574/weapons/e60r.mdl",
		bone = "ValveBiped.Bip01_R_Hand",
		rel = "",
		pos = Vector(02, 01, -05.5),
		angle = Angle(-10, 0, 180),
		size = Vector(0.8, 0.8, 0.8),
		color = Color(255, 255, 255, 255),
		surpresslightning = false,
		material = "",
		skin = 0,
		bodygroup = {}
	},
}

SWEP.HolsterOffset = Vector(4, 0, 0)
SWEP.HolsterAngle = Angle(0, 180, -90)

SWEP.LuaShellEject = false
SWEP.LuaShellEffect = ""
SWEP.Primary.DamageType = DMG_BULLET
SWEP.DamageType = DMG_BULLET
SWEP.RTScopeAttachment = -1
SWEP.Scoped_3D = true
SWEP.ScopeReticule = "#sw/visor/sw_ret_redux_blue"
SWEP.Secondary.ScopeZoom = 2

SWEP.ScopeReticule_Scale = {1.05, 1.05}

if surface then
	SWEP.Secondary.ScopeTable = nil
end

SWEP.Attachments = {
	[1] = {
		header = "Modes",
		atts = {"rocket_mod_pointing", "rocket_mod_tracking", "rocket_mod_control"}
	},
}

DEFINE_BASECLASS(SWEP.Base)
SWEP.trackedent = nil
SWEP.tracktime = 0
SWEP.cld = 0
SWEP.cld2 = 0

if CLIENT then
	surface.CreateFont("Test", {
		font = "Aurebesh",
		extended = false,
		size = 200,
		weight = 0,
		blursize = 0,
		scanlines = 0,
		antialias = false,
		underline = false,
		italic = false,
		strikeout = false,
		symbol = false,
		rotary = false,
		shadow = false,
		additive = false,
		outline = false,
	})
end


function SWEP:ProcessFireMode()
	if self:OwnerIsValid() and self:GetStatus() == TFA.Enum.STATUS_IDLE and (SERVER or not sp) then
		if self:GetOwner():KeyPressed(IN_USE) and self:GetOwner():KeyDown(IN_SPEED) then
			self:CycleSafety()
			return
		end

		if self:GetOwner():KeyPressed(IN_RELOAD) and not self:GetOwner():KeyDown(IN_SPEED) and self:GetOwner():KeyDown(IN_USE) then
			self:CycleFireMode()
			return
		end
	end
end

function SWEP:Think(...)
	BaseClass.Think(self, ...)

	if self:Clip1() > 0 then
		if not self:IsAttached("rocket_mod_tracking") then return end
		if CurTime() < self.cld then return end

		if IsValid(self.trackedent) then
			local ent = self.trackedent
			local ownerang = self:GetOwner():GetAngles()
			local data = (ent:GetPos() - self:EyePos()):Angle()
			local dify = math.AngleDifference(ownerang.y, data.y)

			if dify < 0 then
				dify = -dify
			end

			if dify > 5 then
				self.trackedent = nil
				self.tracktime = 0

				return
			end

			local difp = math.AngleDifference(ownerang.p, data.p)

			if difp < 0 then
				difp = -difp
			end

			if difp > 5 then
				self.trackedent = nil
				self.tracktime = 0

				return
			end

			self.tracktime = self.tracktime + 1
			self.cld = CurTime() + 1
		else
			self.tracktime = 0
			self.trackedent = NULL

			for k, v in pairs(ents.GetAll()) do
				if not v:IsPlayer() and not v:IsNPC() and not v:IsVehicle() and not v.LVS then continue end
				if v == self:GetOwner() then continue end
				local ownerang = self:GetOwner():GetAngles()
				local data = (v:GetPos() - self:EyePos()):Angle()
				local dify = math.AngleDifference(ownerang.y, data.y)

				if dify < 0 then
					dify = -dify
				end

				if dify > 5 then continue end
				local difp = math.AngleDifference(ownerang.p, data.p)

				if difp < 0 then
					difp = -difp
				end

				if difp > 5 then continue end
				self.trackedent = v
			end
		end
	else
		timer.Simple(0, function()
			if not IsValid(self) then return end
			self.tracktime = 0
			self.trackedent = nil
		end)
	end

	if not CLIENT then return end

	if self.tracktime >= 3 then
		self:EmitSound("w/rocket/rocket_lock_confirmed.wav", 75, 100, 1, CHAN_AUTO)
	elseif self.tracktime == 2 then
		self:EmitSound("w/rocket/rocket_lock_start.wav", 75, 100, 1, CHAN_AUTO)
	elseif self.tracktime == 1 then
		self:EmitSound("w/rocket/rocket_lock_start.wav", 75, 100, 1, CHAN_AUTO)
	end
end

function SWEP:DrawHUD()
	BaseClass.DrawHUD(self)

	if self:IsAttached("rocket_mod_tracking") then
		local target = self.trackedent

		if IsValid(target) then
			local pos = (target:GetPos() + target:OBBCenter()):ToScreen()
			local w = ScrW() / 40

			if self.tracktime >= 3 then
				surface.SetDrawColor(255, 0, 0)
			elseif self.tracktime >= 2 then
				surface.SetDrawColor(255, 255, 0)
			elseif self.tracktime >= 1 then
				surface.SetDrawColor(0, 255, 0)
			end

			surface.DrawOutlinedRect(pos.x - (w / 2), pos.y - (w / 2), w, w)
		end
	end
end

function SWEP:CanPrimaryAttack()
	local self2 = self:GetTable()
	stat = self:GetStatus()

	if not TFA.Enum.ReadyStatus[stat] and stat ~= TFA.Enum.STATUS_SHOOTING then
		if self2.Shotgun and TFA.Enum.ReloadStatus[stat] then
			self:SetReloadLoopCancel(true)
		end

		return false
	end

	if self:IsSafety() then
		if IsFirstTimePredicted() then
			self:EmitSound(self:GetStat("Primary.Sound_DrySafety"))
		end

		if CurTime() < self:GetLastSafetyShoot() + 0.2 then
			self:CycleSafety()
		end

		self:SetLastSafetyShoot(CurTime() + 0.2)

		return
	end

	if not self:GetOwner():Crouching() then return false end
	if self:GetStat("Primary.ClipSize") <= 0 and self:Ammo1() < self:GetStat("Primary.AmmoConsumption") then return false end

	if self:GetPrimaryClipSize(true) > 0 and self:Clip1() < self:GetStat("Primary.AmmoConsumption") then
		if not self2.HasPlayedEmptyClick then
			self2.HasPlayedEmptyClick = true

			if self:GetOwner():IsNPC() or self:KeyPressed(IN_ATTACK) then
				local enabled, tanim, ttype = self:ChooseDryFireAnim()

				if enabled then
					self:SetNextPrimaryFire(CurTime() + self:GetStat("Primary.DryFireDelay", self:GetActivityLength(tanim, true, ttype)))

					return false
				end
			end

			self:EmitSound(self:GetStat("Primary.Sound_DryFire"))
		end

		return false
	end

	if self2.FiresUnderwater == false and self:GetOwner():WaterLevel() >= 3 then
		self:SetNextPrimaryFire(CurTime() + 0.5)
		self:EmitSound(self:GetStat("Primary.Sound_Blocked"))

		return false
	end

	self2.HasPlayedEmptyClick = false
	if CurTime() < self:GetNextPrimaryFire() then return false end

	return true
end


function SWEP:SecondaryAttack()
	if not CLIENT then return end
	local ent = self:GetNWEntity("control_rocket")
	if not IsValid(ent) then return end

	if hook.GetTable()["CalcView"]["Joe_CalcView"] then
		hook.Remove("CalcView", "Joe_CalcView")
	else
		hook.Add("CalcView", "Joe_CalcView", function(ply, pos, angles, fov)
			if not IsValid(ent) or not ply:Alive() or not IsValid(self) then
				hook.Remove("CalcView", "Joe_CalcView")

				return
			end

			local view = {
				origin = ent:GetPos() + (self:GetForward() * 8) + (self:GetUp() * 0),
				angles = ent:GetAngles(),
				fov = fov,
				drawviewer = true
			}

			return view
		end)
	end
end

function SWEP:ShootBullet(...)
	if IsFirstTimePredicted() then
		if SERVER then
			timer.Simple(0, function()
				local ent = ents.Create("ent_rw_rocket_mods")
				ent.Owner = self:GetOwner()
				ent.RocketDamage = self.Primary.Damage

				if self:IsAttached("rocket_mod_tracking") and self.trackedent and self.tracktime >= 3 then
					ent.trackingmode = "track"
					ent.trackedent = self.trackedent
					self.tracktime = 0
					self.trackedent = nil
				end

				if self:IsAttached("rocket_mod_pointing") then
					ent.trackingmode = "point"
				end

				if self:IsAttached("rocket_mod_control") then
					ent.trackingmode = "control"
					self:SetNWEntity("control_rocket", ent)
				end

				local ang = self:GetOwner():EyeAngles()
				ent:SetPos(self:GetOwner():GetShootPos() + ang:Forward() * 25 + ang:Right() * 10 + ang:Up() * -2)
				ent:SetAngles(ang)
				ent:Spawn()
			end)
		end

		return
	end

	return BaseClass.ShootBullet(self, ...)
end
--addons/fusioncutter/lua/weapons/weapon_swrp_fusioncutter_sabotage/shared.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--           Fusion Cutter           --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--        Fusion Cutter | SH         --
---------------------------------------

SWEP.Base 					= "weapon_swrp_fusioncutter_base"

SWEP.PrintName 				= "Fusion Cutter (Sabotage)"
SWEP.Category 				= "SW:RP (Support)"
SWEP.Author 				= "Deltaa"
SWEP.Contact 				= "https://www.einfach-gaming.de/user/4179-deltaa/"
SWEP.Instructions 			= ""
SWEP.Purpose 				= "Werkzeug zum Reparieren von Objekten"

SWEP.Spawnable				= true
SWEP.AdminOnly				= false

SWEP.Slot 					= 2
SWEP.SlotPos 				= 1

SWEP.SabotageOnly 			= true
SWEP.HoldType 				= "slam"

SWEP.Modes = {
	["vehicleMode"] = true,
	["systemEnt"] = true,
	["emplacement"] = true,
	["mines"] = true
}



--gamemodes/starwarsrp/entities/weapons/weapon_swrp_pad_funk/shared.lua:
--[[-------------------------------------------------------------------------
SW:RP Weapon: Bacta Granate
---------------------------------------------------------------------------]]

SWEP.Author = "P4sca1 & Oninoni"
SWEP.Contact = "https://einfach-gaming.de"
SWEP.Purpose = "Kann Türen und ähnliches öffnen"
SWEP.Instructions = "Linksklick/Rechtsklick zum Benutzen"

SWEP.Category = "SW:RP (Datapads)"

SWEP.PrintName = "Datapad (Ankündigungsfunk)"

SWEP.Base = "weapon_swrp_egm_base"

SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.ViewModelFOV = 60
SWEP.Slot = 4
SWEP.SlotPos = 0

SWEP.HoldType = "slam"
SWEP.UseHands = true

SWEP.Primary.Automatic = false

SWEP.DefaultFireMode = "Normal"

SWEP.ViewModel = "models/weapons/c_bugbait.mdl"
SWEP.WorldModel = "models/weapons/w_datapad.mdl"

function SWEP:PreDrawViewModel()
	render.SetBlend(0)
end

SWEP.VElements = {
	["element_scope"] = {
		type = "Model",
		model = "models/weapons/w_datapad.mdl",
		bone = "ValveBiped.Bip01_R_Hand",
		rel = "",
		pos = Vector(1, 4, 1),
		angle = Angle(-160, -160, -45),
		size = Vector(1.2, 1.2, 1.2),
		color = Color(255, 255, 255, 255),
		surpresslightning = false,
		material = "",
		skin = 0,
		bodygroup = {}
	}
}

SWEP.Info = {}

function SWEP:PrimaryAttack()
	return
end

function SWEP:SecondaryAttack()
	return
end

function SWEP:Reload()
end

function SWEP:ProcessFireMode()
end

function SWEP:IronSights()
end

function SWEP:DrawHUDAmmo()
	return false
end
--gamemodes/starwarsrp/entities/weapons/weapon_swrp_pad_medic/shared.lua:
--[[-------------------------------------------------------------------------
SW:RP Weapon: RMC Datapad
---------------------------------------------------------------------------]]

SWEP.Author = "P4sca1 & Oninoni"
SWEP.Contact = "https://einfach-gaming.de"
SWEP.Purpose = "Eine Waffe für den SW:RP Spielmodus"
SWEP.Instructions = "Linksklick zum Benutzen"

SWEP.Category = "SW:RP (Datapads)"

SWEP.PrintName = "Datapad (Medics)"

SWEP.Base = "weapon_swrp_egm_base"

SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.ViewModelFOV = 60
SWEP.Slot = 4
SWEP.SlotPos = 0

SWEP.HoldType = "slam"
SWEP.UseHands = true

SWEP.NextReload = 0

SWEP.Primary.Automatic = false
SWEP.AllowIronSightsDoF = false
SWEP.Scoped = false

SWEP.DefaultFireMode = "Normal"

SWEP.ViewModel = "models/weapons/c_bugbait.mdl"
SWEP.WorldModel = "models/weapons/w_datapad.mdl"

function SWEP:PreDrawViewModel()
	render.SetBlend(0)
end

SWEP.VElements = {
	["element_scope"] = {
		type = "Model",
		model = "models/weapons/w_datapad.mdl",
		bone = "ValveBiped.Bip01_R_Hand",
		rel = "",
		pos = Vector(1, 4, 1),
		angle = Angle(-160, -160, -45),
		size = Vector(1.2, 1.2, 1.2),
		color = Color(255, 255, 255, 255),
		surpresslightning = false,
		material = "",
		skin = 0,
		bodygroup = {}
	}
}

SWEP.Info = {}

if CLIENT then
	SWEP.WepSelectIcon = surface.GetTextureID("hud/killicons/pad")
end

function SWEP:PrimaryAttack()
	if CLIENT and IsFirstTimePredicted() then
		surface.PlaySound(UI.ButtonSound)

		MedicMenu:Open()
	end
end

function SWEP:SecondaryAttack()
end

function SWEP:Reload()
	if self.NextReload >= CurTime() then return end
	self:GetOwner():LagCompensation(true)
	local trace = self:GetOwner():GetEyeTrace()
	self:GetOwner():LagCompensation(false)

	local ent = trace.Entity
	if !IsValid(ent) then return end


	if (ent:GetClass() == "drug_refillbag") or (ent:GetClass() == "drug_refillcrate") then
		if trace.HitPos:DistToSqr(self:GetOwner():GetShootPos()) > 5000 then return end

		if CLIENT then
			local modal = vgui.Create("EGMModal")
			modal:SetCustomTitle("Rucksack auffüllen")
			modal:Confirm("Möchtest du die medizinischen Vorräte in deinem Rucksack auffüllen?", function()
				net.Start("MedicMenu.Drugs.Refill")
					net.WriteEntity(ent)
				net.SendToServer()
			end)
		end

		self.NextReload = CurTime() + 5
		return
	end
end

function SWEP:ProcessFireMode()
end

function SWEP:IronSights()
end

function SWEP:DrawHUDAmmo()
	return false
end
--addons/egm_tfa_weapons/lua/weapons/weapon_swrp_umbaran.lua:
-- Written by Oninoni and Meredin

SWEP.Base                   = "weapon_swrp_egm_base"

SWEP.PrintName              = "Umbaran Rifle"
SWEP.Category               = "SW:RP (Separatisten)"
SWEP.Type					= "Republic Heavy Blaster Rifle"
SWEP.Manufacturer           = "Umbaran Armor Workshop"
SWEP.Slot                   = 0
SWEP.SlotPos                = 0

SWEP.Spawnable = true

-- Model --

SWEP.ViewModel						= "models/weapons/synbf3/c_dlt19.mdl"
SWEP.WorldModel						= "models/weapons/synbf3/w_dlt19.mdl"

SWEP.VMPos = Vector(0, -2, -1.5)
SWEP.VMAng = Vector(0, 0, 0)

SWEP.HoldType 						= "ar2"
SWEP.ReloadHoldTypeOverride 		= "ar2"

SWEP.UseHands 						= true

SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
	["v_dlt19_reference001"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) }
}

SWEP.VElements = {
	["dc15a"] = { type = "Model", model = "models/servius/starwars/cwa2/umbaran_rifle.mdl", bone = "v_dlt19_reference001", rel = "", pos = Vector(0.75, 1, -1), angle = Angle(90, -90, 180), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

SWEP.WElements = {
	["umbaran"] = { type = "Model", model = "models/servius/starwars/cwa2/umbaran_rifle.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3, 0, 0.5), angle = Angle(-102, 0, 0), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

SWEP.HolsterOffset = Vector(15, 0, 0)
SWEP.HolsterAngle = Angle(-90, 0, 0)

-- Tracer --

-- Tracer name
SWEP.TracerName 					= "rw_sw_laser_green"


-- Magazine --

-- Ammo per Magazine
SWEP.Primary.ClipSize				= 100
-- Magazine Count
SWEP.Primary.DefaultClip			= SWEP.Primary.ClipSize * 8
-- Ammo Type
SWEP.Primary.Ammo					= "ar2"
-- Ammo Consumption per shot
SWEP.Primary.AmmoConsumption 		= 1

-- Fire Modes --

-- Actual Fire Modes.
SWEP.FireModes = {
	"Automatic",
	"Single",
}

-- Automatic RPM
SWEP.Primary.RPM					= 340
-- Semi Automatic Fire RPM
SWEP.Primary.RPM_Semi				= 170

-- Burst Fire RPM
SWEP.Primary.RPM_Burst				= nil
-- Delay Between Bursts
SWEP.Primary.BurstDelay				= nil

-- Range --

-- Max Range of weapon
SWEP.Primary.Range 					= 4080

-- Shooting --

-- Number of bullets per shot (For Shotguns)
SWEP.Primary.NumShots				= 1
-- Damage per bullet
SWEP.Primary.Damage = 35

-- Aiming --

SWEP.data 							= {}
-- Enable Iron Sights
SWEP.data.ironsights				= 1
-- Iron Sights FOV
SWEP.Secondary.IronFOV				= 75 -- TODO

SWEP.ScopeReticule 					= "#sw/visor/sw_ret_redux_blue"
SWEP.Secondary.ScopeZoom 			= 7
SWEP.ScopeReticule_Scale 			= {1,1}

SWEP.Primary.Spread					= 0.0185
SWEP.Primary.IronAccuracy 			= 0.0065

SWEP.Primary.SpreadMultiplierMax 	= 2.5
SWEP.Primary.SpreadIncrement 		= 0.35

-- Holding Positions

-- Aiming
SWEP.IronSightsPos = Vector(-2, -5, 1)
SWEP.IronSightsAng = Vector(0, 0, 0)
-- Running
SWEP.RunSightsPos = Vector(5.226, -2, 0)
SWEP.RunSightsAng = Vector(-18, 36, -13.5)
-- Inspecting
SWEP.InspectPos = Vector(8, -4.8, -3)
SWEP.InspectAng = Vector(11.199, 38, 0)

-- Sounds --

-- Fire Sound
SWEP.Primary.Sound 					= Sound("weapons/umbaranrifle_fire.ogg")
-- Reload Sound
SWEP.Primary.ReloadSound 			= Sound("weapons/umbaranrifle_reload.wav")

DEFINE_BASECLASS( SWEP.Base )
--addons/egm_tfa_weapons/lua/weapons/weapon_swrp_westar35.lua:
-- Written by Deltaa

SWEP.Base                   = "weapon_swrp_egm_base"

SWEP.PrintName              = "GALAAR-15 Blaster Carbine"
SWEP.Category               = "SW:RP (Event)"
SWEP.Type					= "Blaster Carbine"
SWEP.Slot                   = 0
SWEP.SlotPos                = 0

SWEP.Spawnable = true

-- Model --

SWEP.Manufacturer           = "Concordian Crescent Technologies"
SWEP.ViewModel				= "models/weapons/synbf3/c_e11.mdl"
SWEP.WorldModel				= "models/weapons/synbf3/w_e11.mdl"

SWEP.VMPos 					= Vector(2, -7, -1)
SWEP.VMAng 					= Vector(0,0,0)

SWEP.HoldType 				= "ar2"
SWEP.ReloadHoldTypeOverride = "ar2"

SWEP.UseHands 				= true

SWEP.ShowWorldModel 		= false

SWEP.ViewModelBoneMods = {
	["v_e11_reference001"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) }
}

SWEP.VElements = {
	["w35"] = { type = "Model", model = "models/sw_battlefront/weapons/westar_35_rifle.mdl", bone = "v_e11_reference001", rel = "", pos = Vector(-0.9, 0.55, 1.75), angle = Angle(0, 0, 0), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["visor"] = { type = "Model", model = "models/squad/sf_plates/sf_plate1x1.mdl", bone = "", rel = "w11", pos = Vector(01.21, 06, 1.84), angle = Angle(90, 0, 90), size = Vector(0.2, 0.2, 0.2), color = Color(255, 255, 255, 255), surpresslightning = true, material = "cs574/ironsights/sw_ironsight_yellow", skin = 0, bodygroup = {} },
}

SWEP.WElements = {
	["w35"] = { type = "Model", model = "models/sw_battlefront/weapons/westar_35_rifle.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(4, 01.7, -1.5), angle = Angle(0, -85, 165), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

SWEP.HolsterOffset = Vector(12, 0, 0)
SWEP.HolsterAngle = Angle(0, -90, 0)



-- Tracer --

-- Tracer name
SWEP.TracerName 					= "rw_sw_laser_yellow"


-- Magazine --

-- Ammo per Magazine
SWEP.Primary.ClipSize				= 100
-- Magazine Count
SWEP.Primary.DefaultClip			= SWEP.Primary.ClipSize * 5
-- Ammo Type
SWEP.Primary.Ammo					= "ar2"
-- Ammo Consumption per shot
SWEP.Primary.AmmoConsumption 		= 1

-- Fire Modes --

-- Actual Fire Modes.
SWEP.FireModes = {
	"Automatic",
	"Single",
}

-- Automatic RPM
SWEP.Primary.RPM					= 285
-- Semi Automatic Fire RPM
SWEP.Primary.RPM_Semi				= 140

-- Burst Fire RPM
SWEP.Primary.RPM_Burst				= nil
-- Delay Between Bursts
SWEP.Primary.BurstDelay				= nil

-- Range --

-- Max Range of weapon
SWEP.Primary.Range 					= 8000

-- Shooting --

-- Number of bullets per shot (For Shotguns)
SWEP.Primary.NumShots				= 1
-- Damage per bullet
SWEP.Primary.Damage 				= 30

-- Aiming --

SWEP.data 							= {}
-- Enable Iron Sights
SWEP.data.ironsights				= 1
-- Iron Sights FOV
SWEP.Secondary.IronFOV				= 75 -- TODO

SWEP.ScopeReticule 					= "#sw/visor/sw_ret_redux_blue"
SWEP.Secondary.ScopeZoom 			= 7
SWEP.ScopeReticule_Scale 			= {1,1}

SWEP.Primary.Spread					= 0.012
SWEP.Primary.IronAccuracy 			= 0.004

SWEP.Primary.SpreadMultiplierMax 	= 2.5
SWEP.Primary.SpreadIncrement 		= 0.35

-- Holding Positions

-- Aiming
SWEP.IronSightsPos = Vector(-4.825, -5, 3.66)
SWEP.IronSightsAng = Vector(-01, 0, 0)
-- Running
SWEP.RunSightsPos = Vector(5.226, -2, -1.5)
SWEP.RunSightsAng = Vector(-22, 32.50, -19)
-- Inspecting
SWEP.InspectPos = Vector(8, -4.8, -3)
SWEP.InspectAng = Vector(11.199, 38, 0)

-- Sounds --

-- Fire Sound
SWEP.Primary.Sound = Sound("weapons/dwrifle_fire.wav")
-- Reload Sound
SWEP.Primary.ReloadSound = Sound("weapons/dwrifle_reload.ogg")

DEFINE_BASECLASS(SWEP.Base)
--addons/tracking_device_egm/lua/weapons/weapon_trackingdevice_massif/shared.lua:
AddCSLuaFile()
SWEP.PrintName = "Tracking Device (Massif)"
SWEP.Author =	"Joe/Sven"

SWEP.Spawnable =	true
SWEP.Adminspawnable = false
SWEP.Category = "Joe"

SWEP.Primary.Clipsize =	-1
SWEP.Primary.DefaultClip =	-1
SWEP.Primary.Automatic =	false
SWEP.Primary.Ammo =	"none"

SWEP.Secondary.Clipsize =	-1
SWEP.Secondary.DefaultClip =	-1
SWEP.Secondary.Automatic =	false
SWEP.Secondary.Ammo =	"none"
SWEP.UseHands = true

SWEP.HoldType = "slam"
SWEP.ViewModelFOV = 55
SWEP.ViewModelFlip = false
SWEP.ViewModel = "models/2rek/thejoe/sw_tracker_1_vm.mdl"
SWEP.WorldModel = "models/2rek/thejoe/sw_tracker_1_prop.mdl"
SWEP.DrawCrosshair = false

function SWEP:SetupDataTables()
	self:NetworkVar("Entity", 0, "TrackerTarget")
end

function SWEP:PrimaryAttack()
	if SERVER then self:SetNextPrimaryFire(CurTime() + 2) end
	if not IsFirstTimePredicted() then return end

	if CLIENT then
		self:DrawGUI()
	end
end

function SWEP:SecondaryAttack()
	if CLIENT then return end

	self:SetNextSecondaryFire(CurTime() + 2)
	local owner = self:GetOwner()
	if IsValid(self:GetTrackerTarget()) then
		owner:ChatPrint("Du trackst gerade: " .. self:GetTrackerTarget():GetCurrentCharacterFullName())
	else
		owner:ChatPrint( "Du trackst noch niemanden ")
	end
end

if CLIENT then
	function SWEP:DrawGUI()
		local owner = self:GetOwner()

		local frame = vgui.Create("DFrame")
		frame:SetPos(500, 100)
		frame:SetSize(900, 900)
		frame:MakePopup()
		frame:ShowCloseButton(true)
		frame:SetTitle("Wähle ein Ziel aus")
		frame.Paint = function(_, w, h)
			draw.RoundedBox(0,0,0,w,h,Color(0,0,0,200))
		end

		local playerList = vgui.Create("DListView", frame)
		playerList:Dock( FILL )
		playerList:SetMultiSelect( false )
		playerList:AddColumn( "Spieler" )
		playerList:SetVisible(true)

		for _, ply in pairs(player.GetAll()) do
			if ply == owner then continue end

			local line = playerList:AddLine(ply:GetCurrentCharacterFullName())
			line.Player = ply
		end

		function playerList:DoDoubleClick( lineID, line )
			net.Start("Tracker_Massif.TargetEntity")
				net.WriteEntity(line.Player)
			net.SendToServer()

			frame:Close()
			owner:ChatPrint( "Du trackst jetzt: " .. line.Player:GetCurrentCharacterFullName() )
		end
	end
end

function SWEP:Initialize()
	self:SetHoldType(self.HoldType)
end

function SWEP:Holster()
	return true
end

function SWEP:Think()
end

if CLIENT then
	local WorldModel = ClientsideModel(SWEP.WorldModel)
	WorldModel:SetSkin(1)
	WorldModel:SetNoDraw(true)
	function SWEP:DrawWorldModel()
		local _Owner = self:GetOwner()
		if (IsValid(_Owner)) then
			local offsetVec = Vector(3.2, -0.8, -0.5)
			local offsetAng = Angle(0, 10, 100)
			local boneid = _Owner:LookupBone("ValveBiped.Bip01_R_Hand") -- Right Hand
			if not boneid then return end
			local matrix = _Owner:GetBoneMatrix(boneid)
			if not matrix then return end
			local newPos, newAng = LocalToWorld(offsetVec, offsetAng, matrix:GetTranslation(), matrix:GetAngles())
			WorldModel:SetPos(newPos)
			WorldModel:SetAngles(newAng)
			WorldModel:SetupBones()
		else
			WorldModel:SetPos(self:GetPos())
			WorldModel:SetAngles(self:GetAngles())
		end
		WorldModel:DrawModel()
	end
end

if CLIENT then
	local function Circle(x, y, r, step, cache)
		local positions = {}
		for i = 0, 360, step do
			table.insert(positions, {
				x = x + math.cos(math.rad(i)) * r,
				y = y + math.sin(math.rad(i)) * r
			})
		end

		return (cache and positions) or surface.DrawPoly(positions)
	end

	local pnl = vgui.Create("DFrame")
	pnl:SetSize(22, 20)
	pnl:SetDraggable( false )
	pnl:SetVisible( true )
	pnl:ShowCloseButton( false )
	pnl:SetTitle("")
	pnl:SetPos( 0, 0 )
	pnl:SetPaintedManually(true)

	local cld = 0
	local mult

	function SWEP:PostDrawViewModel(vm, wep, ply)
		local owner = self:GetOwner()
		local target = self:GetTrackerTarget()
		if not IsValid(target) then return end
		local  trackertargetposition = target:GetPos()

		if IsValid(vm) then
			pnl.Paint = function(s,w,h)
				if 0 == 0 then
					local dif = ( trackertargetposition - owner:GetShootPos()):Angle() -- aufrufen der Peilsenderposition
					dif = math.AngleDifference(owner:GetAngles().y, dif.y)

					if dif < 0 then dif = dif * -1 end

					multl = 5 - ( 5 * ( dif / 180 ) )

					farbwechsel = multl * 51
				end

				if cld < CurTime() then
					local dif = ( trackertargetposition - owner:GetShootPos()):Angle() -- aufrufen der Peilsenderposition
					dif = math.AngleDifference(owner:GetAngles().y, dif.y)

					if dif < 0 then dif = dif * -1 end

					mult = 5 - ( 5 * ( dif / 180 ) )

					cld = CurTime() + 2
				end

				local speed = math.Clamp( math.abs( math.sin( CurTime() * mult ) * 0.8 ) * 255 ,0,255) -- Blink geschwindigkeit

				surface.SetDrawColor(Color(255 - farbwechsel, farbwechsel, 0, speed))  --Aufleuchten
				draw.NoTexture()
				Circle(0,0,w,1,false)
			end

			local BoneIndx = vm:LookupBone("tracker")
			local BonePos, BoneAng = vm:GetBonePosition( BoneIndx )
			TextPos = BonePos + BoneAng:Forward() * 31 + BoneAng:Right() * 4.378 + BoneAng:Up() * -5
			TextAngle = BoneAng
			TextAngle:RotateAroundAxis(TextAngle:Right(), 0)
			TextAngle:RotateAroundAxis(TextAngle:Up(), -90)
			TextAngle:RotateAroundAxis(TextAngle:Forward( ), 90)
			cam.Start3D2D(TextPos, TextAngle, 0.015)
				pnl:PaintManual()
			cam.End3D2D()
		end
	end
end

if SERVER then
	util.AddNetworkString("Tracker_Massif.TargetEntity")
	net.Receive("Tracker_Massif.TargetEntity", function(len, ply)
		local target = net.ReadEntity()

		hook.Run("Tracker_Massif.TargetEntity", ply, target)

		ply:GetWeapon("weapon_trackingdevice_massif"):SetTrackerTarget(target)
	end)

	hook.Add("EGMRP.Loaded", "Tracker_Massif.InitLogs", function()
		EventLog:AddEvent("Tracking Device", "Tracker_Massif.TargetEntity", function(ply, target)
			local char = ply:GetCurrentCharacter()
			local targetChar = target:GetCurrentCharacter()

			if char and targetChar then
				return string.format("%s (%s | %s) hat begonnen nach %s (%s | %s) zu schnüffeln.", char:GetFullName(), ply:Name(), ply:SteamID64(), targetChar:GetFullName(), target:Name(), target:SteamID64())
			end
		end)
	end)
end
--addons/wos-grandmaster-einf/lua/weapons/wos_alcs_duelplacer/shared.lua:
SWEP.HoldType = "pistol"

SWEP.ViewModel	= "models/weapons/c_toolgun.mdl"
SWEP.WorldModel = "models/weapons/w_toolgun.mdl"
SWEP.UseHands = true

SWEP.Primary.Swap           = Sound( "weapons/clipempty_rifle.wav" )
SWEP.Primary.Sound			= Sound( "NPC_CombineCamera.Click" )
SWEP.Primary.Delete1		= Sound( "Weapon_StunStick.Melee_Hit" )
SWEP.Primary.Delete			= Sound( "Weapon_StunStick.Melee_HitWorld" )

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic		= false
SWEP.Primary.Ammo			= "pistol"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= false
SWEP.Secondary.Ammo			= "none"

function SWEP:SetupDataTables()

	self:NetworkVar( "Entity", 0, "Selected" )

end
--addons/wos-alcs-custom/lua/weapons/wos_inventory/shared.lua:

--[[-------------------------------------------------------------------
	Personal Shield Swep:
		This literally does fucking nothing except let me use the console command
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
-------------------------------------------------------------------]]--[[
							  
	Lua Developer: King David
	Contact: www.wiltostech.com
	
		
----------------------------------------]]--

if (SERVER) then

	SWEP.Weight				= 5
	SWEP.AutoSwitchTo		= false
	SWEP.AutoSwitchFrom		= false
end

if ( CLIENT ) then
	SWEP.PrintName			= "Jedi - Inventar"
	SWEP.DrawAmmo 			= false
	SWEP.DrawCrosshair 		= false
	SWEP.ViewModelFOV		= 77
	SWEP.ViewModelFlip		= false
	SWEP.CSMuzzleFlashes	= true

	SWEP.Slot				= 2
	SWEP.SlotPos			= 0
	SWEP.IconLetter			= "J"
end

SWEP.Category				= "wiltOS Technologies"

SWEP.Spawnable				= false
SWEP.AdminSpawnable			= true

SWEP.DrawWeaponInfoBox  	= false

SWEP.Weight					= 5
SWEP.AutoSwitchTo			= false
SWEP.AutoSwitchFrom			= false

SWEP.Primary.ClipSize		= -1
SWEP.Primary.Damage			= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo			= "none"


SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Damage		= -1
SWEP.Secondary.Automatic	= true
SWEP.Secondary.Ammo			= "none"

SWEP.DrawWorldModel = false

/*---------------------------------------------------------
Think
---------------------------------------------------------*/
function SWEP:Think()
end

/*---------------------------------------------------------
Initialize
---------------------------------------------------------*/
function SWEP:Initialize()
	self:SetWeaponHoldType( "slam" )
end

/*---------------------------------------------------------
Deploy
---------------------------------------------------------*/
function SWEP:Deploy()
	return true
end

/*---------------------------------------------------------
PrimaryAttack
---------------------------------------------------------*/
function SWEP:PrimaryAttack()
	if SERVER then
		self:GetOwner():ConCommand( "wos_openinventory" )
	end

	self:SetNextPrimaryFire( CurTime() + 1 )
end

function SWEP:SecondaryAttack()
end

function SWEP:Reload()
	return false
end

/*---------------------------------------------------------
OnRemove
---------------------------------------------------------*/
function SWEP:OnRemove()
	return true
end

/*---------------------------------------------------------
Holster
---------------------------------------------------------*/
function SWEP:Holster()
	return true
end

if CLIENT then
	function SWEP:PreDrawViewModel() render.SetBlend(0) end
	function SWEP:DrawWorldModel() end
	function SWEP:DrawWeaponSelection(x,y,wide,tall,alpha) end
end
--addons/bkeypads/lua/entities/bkeypads_dmg_consumable/shared.lua:
AddCSLuaFile()

ENT.Type = "anim"
ENT.Base = "base_gmodentity"
DEFINE_BASECLASS(ENT.Base)

ENT.Author = "Billy"
ENT.Spawnable = false

ENT.RenderGroup = RENDERGROUP_BOTH

function ENT:SetBaseModelScale(m_iModelScale, time)
	self.m_iBaseModelScale = self.m_iBaseModelScale or m_iModelScale
	return self:SetModelScale(m_iModelScale, time)
end

if SERVER then
	function ENT:Initialize()
		self:PhysicsInit(SOLID_VPHYSICS)
		self:PhysWake()

		self:SetTrigger(true)
		self:SetUseType(SIMPLE_USE)
	end

	function ENT:StartTouch(ent)
		if ent.bKeypad and ent:GetDestructible() and not self.m_bConsumed and self:Consume(ent) then
			self.m_bConsumed = true
			self:SetConsumedBy(ent)

			self:SetModelScale(0, 0.5)

			self:ForcePlayerDrop()
			DropEntityIfHeld(self)

			self:SetCollisionGroup(COLLISION_GROUP_DEBRIS)

			local phys = self:GetPhysicsObject()
			if IsValid(phys) then
				phys:EnableGravity(false)
				phys:EnableCollisions(false)
				phys:EnableMotion(false)
				phys:EnableMotion(true)
				phys:SetDamping(0, 0)
				phys:AddGameFlag(FVPHYSICS_NO_PLAYER_PICKUP)

				local dir = ent:WorldSpaceCenter() - phys:GetPos()
				local dist = dir:Length()
				dir:Normalize()

				phys:ApplyForceCenter(dir * phys:GetMass() * dist)
			end

			timer.Simple(1, function()
				if IsValid(self) then
					self:Remove()
				end
			end)
		end
	end

	function ENT:Use(ply)
		if IsValid(ply) and ply:IsPlayer() then
			ply:PickupObject(self)
		end
	end
else
	local scale_3d2d = 0.04
	function ENT:Draw(flags)
		if bit.band(flags, STUDIO_TRANSPARENCY) == 0 or bit.band(flags, STUDIO_TWOPASS) == 0 then
			self:DrawModel()
		end
	end

	function ENT:DrawTranslucent(flags)
		self:Draw(flags)

		if halo.RenderedEntity() == self then return end

		if self:GetModelScale() == self.m_iBaseModelScale then
			if LocalPlayer():GetEyeTrace().Entity == self then
				local mins, maxs = self:GetRotatedAABB(self:OBBMins(), self:OBBMaxs())
				local center = (maxs + mins) / 2

				local pos = LocalToWorld(center, angle_zero, self:GetPos(), angle_zero)
				pos.z = math.max(LocalToWorld(maxs, angle_zero, self:GetPos(), angle_zero).z, LocalToWorld(mins, angle_zero, self:GetPos(), angle_zero).z)

				local ang = (EyePos() - pos):Angle()
				ang:RotateAroundAxis(ang:Up(), 90)
				ang:RotateAroundAxis(ang:Forward(), 90)

				cam.Start3D2D(pos, ang, scale_3d2d)
					self:DrawHUDLabel()
				cam.End3D2D()
			end
		elseif IsValid(self:GetConsumedBy()) then
			local animFrac = self:GetModelScale() / self.m_iBaseModelScale

			local pos = self:WorldSpaceCenter()
			pos.z = pos.z + (10 * (1 - animFrac))
			
			local ang = (EyePos() - pos):Angle()
			ang:RotateAroundAxis(ang:Up(), 90)
			ang:RotateAroundAxis(ang:Forward(), 90)

			cam.Start3D2D(pos, ang, scale_3d2d * 2)
				surface.SetAlphaMultiplier(animFrac)
					self:DrawConsumedLabel()
				surface.SetAlphaMultiplier(1)
			cam.End3D2D()
		end
	end
end

function ENT:SetupDataTables()
	self:NetworkVar("Entity", 0, "ConsumedBy")
end

function ENT:GravGunPunt()
	return true
end
--addons/bkeypads/lua/entities/bkeypads_fading_door_link/shared.lua:
AddCSLuaFile()

ENT.Type = "point"
ENT.Base = "bkeypads_link"

ENT.PrintName = "Fading Door Link (Billy's Keypads)"
ENT.Author = "Billy"

ENT.Spawnable = false

ENT.RenderGroup = RENDERGROUP_OTHER

DEFINE_BASECLASS(ENT.Base)

function ENT:RegisterLink()
	bKeypads.FadingDoors.LinkEnts[self] = true
end

if CLIENT then
	function ENT:LinkUpdated()
		if not bKeypads.FadingDoors.RebuildLinkTable then
			bKeypads.FadingDoors.RebuildLinkTable = true
			bKeypads:nextTick(bKeypads.FadingDoors.BuildLinksTable)
		end
	end
else
	function ENT:DeregisterLink()
		bKeypads.FadingDoors.LinkEnts[self] = nil
		bKeypads.FadingDoors:DeregisterLink(self:GetKeypad(), self:GetLinkedEnt(), self:GetAccessType())
	end
end
--addons/bkeypads/lua/entities/bkeypads_shield/shared.lua:
AddCSLuaFile()

ENT.Base = "bkeypads_dmg_consumable"
DEFINE_BASECLASS(ENT.Base)

ENT.PrintName = "#bKeypads_KeypadShieldBattery"
ENT.Category = "Billy's Keypads"
ENT.Spawnable = true

function ENT:Initialize()
	self:SetModel("models/items/battery.mdl")
	self:SetColor(bKeypads.COLOR.GMODBLUE)
	self:SetBaseModelScale(.75, 0.0001)

	BaseClass.Initialize(self)
end

if SERVER then
	function ENT:Consume(keypad)
		if bKeypads.Config.KeypadDestruction.MaxShield ~= 0 and keypad:GetShield() >= bKeypads.Config.KeypadDestruction.MaxShield * keypad:GetMaxHealth() then return end

		keypad:StopSound("npc/scanner/scanner_siren2.wav")
		keypad:EmitSound("items/battery_pickup.wav", 75)

		local shield = math.max(keypad:GetShield(), 0) + math.ceil(keypad:GetMaxHealth() * bKeypads.Config.KeypadDestruction.ShieldBatteryCharge)
		if bKeypads.Config.KeypadDestruction.MaxShield == 0 then
			keypad:SetShield(shield)
		else
			keypad:SetShield(math.min(shield, math.ceil(keypad:GetMaxHealth() * bKeypads.Config.KeypadDestruction.MaxShield)))
		end

		return true
	end
else
	function ENT:DrawHUDLabel()
		draw.SimpleTextOutlined(bKeypads.L"KeypadShield", "bKeypads.KeypadLabelFont", 0, 0, bKeypads.COLOR.GMODBLUE, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM, 2, bKeypads.COLOR.BLACK)
	end

	function ENT:DrawConsumedLabel()
		draw.SimpleTextOutlined(bKeypads.L("ShieldAdded"):format(math.ceil(self:GetConsumedBy():GetMaxHealth() * bKeypads.Config.KeypadDestruction.ShieldBatteryCharge)), "bKeypads.KeypadLabelFont", 0, 0, bKeypads.COLOR.GMODBLUE, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM, 2, bKeypads.COLOR.BLACK)
	end
end

bKeypads_Initialize_Fix(ENT)
--addons/ballistic_shields/lua/ballistic_shields/sh_bs_util.lua:
bshields = bshields or {}
bshields.config = bshields.config or {}

bshields.shields = {
	{
		[1] = {
			["angles"] = Angle(4,6,-14),
			["position"] = Vector(5,10,-5)
		},
		[2] = {
			["angles"] = Angle(6,1,-15),
			["position"] = Vector(6,10,-5)
		},
		[3] = {
			["angles"] = Angle(4,6,-14),
			["position"] = Vector(5,10,-5)
		}
	},
	{
		[1] = {
			["angles"] = Angle(-12,0,0),
			["position"] = Vector(6,-4,-8)
		},
		[2] = {
			["angles"] = Angle(-12,0,0),
			["position"] = Vector(1,-3,-12)
		},
		[3] = {
			["angles"] = Angle(-12,0,0),
			["position"] = Vector(6,-3,-12)
		}
	},
	{
		[1] = {
			["angles"] = Angle(70,78,-16),
			["position"] = Vector(1,-7,-13)
		},
		[2] = {
			["angles"] = Angle(70,78,-16),
			["position"] = Vector(1,-6,-22)
		},
		[3] = {
			["angles"] = Angle(70,78,-16),
			["position"] = Vector(1,-8,-12)
		}
	}
}

--addons/ballistic_shields/lua/ballistic_shields/cl_bs_util.lua:
if SERVER then return end
include( "bs_config.lua" )

net.Receive( "bs_shield_info", function( len, pl )
	LocalPlayer().bs_shieldIndex = net.ReadUInt(16)
end )

local Delay = 0
function bshields_materials_reload()
	for _,v in pairs(bshields.materialstoload) do
		Delay = Delay + 0.2
		timer.Simple( Delay, function() surface.GetURL(v[1], v[2], v[3]) end )
	end

	bshields.hshield_webmat = surface.GetURL(bshields.config.hShieldTexture, 256, 256)
	bshields.rshield_webmat = surface.GetURL(bshields.config.rShieldTexture, 256, 256)
	bshields.dshield_webmat = surface.GetURL(bshields.config.dShieldTexture, 256, 256)
end

bshields.materialstoload = {
	{bshields.config.hShieldTexture, 256, 256},
	{bshields.config.rShieldTexture, 256, 256},
	{bshields.config.dShieldTexture, 256, 256}
}

hook.Add( "InitPostEntity", "bshields_init_client", function()
	bshields_materials_reload()
end)

surface.CreateFont( "bshields.HudFont", {
	font = "BFHud",
	size = ScrH() / 1080 * 18
})
--addons/ballistic_shields/lua/bs_config.lua:
include( "ballistic_shields/sh_bs_util.lua" )

--------------------- BALLISTIC SHIELDS V1.1.4 -------------------------

---- CONFIG ----
-- AVALAIBLE LANGUAGES - English
bshields.config.language = "German"
-- DISABLE HUD
bshields.config.disablehud = false
-- MINIMUM RIOT SHIELD DAMAGE
bshields.config.rshielddmgmin = 16
-- MAXIMUM RIOT SHIELD DAMAGE
bshields.config.rshielddmgmax = 25
-- HEAVY SHIELD EXPLOSION DAMAGE REDUCITON (IN %)
bshields.config.hshieldexpl = 25
-- HEAVY SHIELD MELEE DAMAGE REDUCTION (IN %)
bshields.config.hshieldmelee = 0
-- RIOT SHIELD MELEE DAMAGE REDUCTION (IN %)
bshields.config.rshieldmelee = 60
-- HEAVY SHIELD BREACH COOLDOWN (IN SECONDS)
bshields.config.hshieldcd = 20
-- DOOR RESPAWN TIMER (IN SECONDS)
bshields.config.doorrespawn = 60
-- MAXIMUM AMOUNT OF DEPLOYED SHIELDS
bshields.config.maxshields = 3
-- SHOULD FADING DOORS BE BREACHABLE?
bshields.config.breachfdoors = false
-- ALLOW BREACHING UNOWNED DOORS
bshields.config.breachudoors = false

-------- CUSTOM TEXTURES, LEAVE "" FOR DEFAULT "POLICE" TEXT. ----------
--- FOR EDITING USE THE 256x256 TEMPLATE INCLUDED IN THE MAIN FOLDER ---

-- HEAVY SHIELD
bshields.config.hShieldTexture = "https://i.imgur.com/afyGHiK.png"
-- RIOT SHIELD
bshields.config.rShieldTexture = "https://i.imgur.com/afyGHiK.png"
-- DEPLOYABLE SHIELD
bshields.config.dShieldTexture = "https://i.imgur.com/afyGHiK.png" 
-- PLAYERS MIGHT HAVE TO RECONNECT IN ORDER TO SEE THE NEW TEXTURES! ---

-- [CW2 ONLY] YOU NEED THIS ADDON: https://steamcommunity.com/sharedfiles/filedetails/?id=1771994451
-- SHOULD RIOT SHIELD BE BULLETPROOF? --
bshields.config.rshieldbp = true
--addons/ballistic_shields/lua/ballistic_shields/sh_bs_util.lua:
bshields = bshields or {}
bshields.config = bshields.config or {}

bshields.shields = {
	{
		[1] = {
			["angles"] = Angle(4,6,-14),
			["position"] = Vector(5,10,-5)
		},
		[2] = {
			["angles"] = Angle(6,1,-15),
			["position"] = Vector(6,10,-5)
		},
		[3] = {
			["angles"] = Angle(4,6,-14),
			["position"] = Vector(5,10,-5)
		}
	},
	{
		[1] = {
			["angles"] = Angle(-12,0,0),
			["position"] = Vector(6,-4,-8)
		},
		[2] = {
			["angles"] = Angle(-12,0,0),
			["position"] = Vector(1,-3,-12)
		},
		[3] = {
			["angles"] = Angle(-12,0,0),
			["position"] = Vector(6,-3,-12)
		}
	},
	{
		[1] = {
			["angles"] = Angle(70,78,-16),
			["position"] = Vector(1,-7,-13)
		},
		[2] = {
			["angles"] = Angle(70,78,-16),
			["position"] = Vector(1,-6,-22)
		},
		[3] = {
			["angles"] = Angle(70,78,-16),
			["position"] = Vector(1,-8,-12)
		}
	}
}

--addons/ballistic_shields/lua/entities/bs_hshield_st/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Heavy shield"
ENT.Category = "Ballistic shields"

ENT.Spawnable = false
ENT.DisableDuplicator = true

--addons/ballistic_shields/lua/ballistic_shields/cl_bs_util.lua:
if SERVER then return end
include( "bs_config.lua" )

net.Receive( "bs_shield_info", function( len, pl )
	LocalPlayer().bs_shieldIndex = net.ReadUInt(16)
end )

local Delay = 0
function bshields_materials_reload()
	for _,v in pairs(bshields.materialstoload) do
		Delay = Delay + 0.2
		timer.Simple( Delay, function() surface.GetURL(v[1], v[2], v[3]) end )
	end

	bshields.hshield_webmat = surface.GetURL(bshields.config.hShieldTexture, 256, 256)
	bshields.rshield_webmat = surface.GetURL(bshields.config.rShieldTexture, 256, 256)
	bshields.dshield_webmat = surface.GetURL(bshields.config.dShieldTexture, 256, 256)
end

bshields.materialstoload = {
	{bshields.config.hShieldTexture, 256, 256},
	{bshields.config.rShieldTexture, 256, 256},
	{bshields.config.dShieldTexture, 256, 256}
}

hook.Add( "InitPostEntity", "bshields_init_client", function()
	bshields_materials_reload()
end)

surface.CreateFont( "bshields.HudFont", {
	font = "BFHud",
	size = ScrH() / 1080 * 18
})
--addons/ballistic_shields/lua/bs_config.lua:
include( "ballistic_shields/sh_bs_util.lua" )

--------------------- BALLISTIC SHIELDS V1.1.4 -------------------------

---- CONFIG ----
-- AVALAIBLE LANGUAGES - English
bshields.config.language = "German"
-- DISABLE HUD
bshields.config.disablehud = false
-- MINIMUM RIOT SHIELD DAMAGE
bshields.config.rshielddmgmin = 16
-- MAXIMUM RIOT SHIELD DAMAGE
bshields.config.rshielddmgmax = 25
-- HEAVY SHIELD EXPLOSION DAMAGE REDUCITON (IN %)
bshields.config.hshieldexpl = 25
-- HEAVY SHIELD MELEE DAMAGE REDUCTION (IN %)
bshields.config.hshieldmelee = 0
-- RIOT SHIELD MELEE DAMAGE REDUCTION (IN %)
bshields.config.rshieldmelee = 60
-- HEAVY SHIELD BREACH COOLDOWN (IN SECONDS)
bshields.config.hshieldcd = 20
-- DOOR RESPAWN TIMER (IN SECONDS)
bshields.config.doorrespawn = 60
-- MAXIMUM AMOUNT OF DEPLOYED SHIELDS
bshields.config.maxshields = 3
-- SHOULD FADING DOORS BE BREACHABLE?
bshields.config.breachfdoors = false
-- ALLOW BREACHING UNOWNED DOORS
bshields.config.breachudoors = false

-------- CUSTOM TEXTURES, LEAVE "" FOR DEFAULT "POLICE" TEXT. ----------
--- FOR EDITING USE THE 256x256 TEMPLATE INCLUDED IN THE MAIN FOLDER ---

-- HEAVY SHIELD
bshields.config.hShieldTexture = "https://i.imgur.com/afyGHiK.png"
-- RIOT SHIELD
bshields.config.rShieldTexture = "https://i.imgur.com/afyGHiK.png"
-- DEPLOYABLE SHIELD
bshields.config.dShieldTexture = "https://i.imgur.com/afyGHiK.png" 
-- PLAYERS MIGHT HAVE TO RECONNECT IN ORDER TO SEE THE NEW TEXTURES! ---

-- [CW2 ONLY] YOU NEED THIS ADDON: https://steamcommunity.com/sharedfiles/filedetails/?id=1771994451
-- SHOULD RIOT SHIELD BE BULLETPROOF? --
bshields.config.rshieldbp = true
--addons/ballistic_shields/lua/entities/bs_rshield/cl_init.lua:
include('shared.lua')
include( "ballistic_shields/cl_bs_util.lua" ) 
ENT.RenderGroup = RENDERGROUP_BOTH

function ENT:Draw()  
	if(bshields.config.rShieldTexture == "") then self:DrawModel() return end
	local webmat = surface.GetURL(bshields.config.rShieldTexture, 256, 256)
	
	if ( self.Mat ) then
		render.MaterialOverrideByIndex( 1, self.Mat )
	end 
	local html_mat = webmat
	local matdata =
	{
		["$basetexture"]=html_mat:GetName(),
		["$decal"] = 1,
		["$translucent"] = 1
	}

	local uid = string.Replace( html_mat:GetName(), "__vgui_texture_", "" )

	self.Mat = CreateMaterial( "bshields_webmat_"..uid, "VertexLitGeneric", matdata )
	self:DrawModel()
	render.ModelMaterialOverride( nil )
end   
--addons/ballistic_shields/lua/entities/bs_rshield/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Riot shield"
ENT.Category = "Ballistic shields"

ENT.Spawnable = false
ENT.DisableDuplicator = true

--addons/ballistic_shields/lua/ballistic_shields/sh_bs_util.lua:
bshields = bshields or {}
bshields.config = bshields.config or {}

bshields.shields = {
	{
		[1] = {
			["angles"] = Angle(4,6,-14),
			["position"] = Vector(5,10,-5)
		},
		[2] = {
			["angles"] = Angle(6,1,-15),
			["position"] = Vector(6,10,-5)
		},
		[3] = {
			["angles"] = Angle(4,6,-14),
			["position"] = Vector(5,10,-5)
		}
	},
	{
		[1] = {
			["angles"] = Angle(-12,0,0),
			["position"] = Vector(6,-4,-8)
		},
		[2] = {
			["angles"] = Angle(-12,0,0),
			["position"] = Vector(1,-3,-12)
		},
		[3] = {
			["angles"] = Angle(-12,0,0),
			["position"] = Vector(6,-3,-12)
		}
	},
	{
		[1] = {
			["angles"] = Angle(70,78,-16),
			["position"] = Vector(1,-7,-13)
		},
		[2] = {
			["angles"] = Angle(70,78,-16),
			["position"] = Vector(1,-6,-22)
		},
		[3] = {
			["angles"] = Angle(70,78,-16),
			["position"] = Vector(1,-8,-12)
		}
	}
}

--addons/ballistic_shields/lua/entities/bs_shield_dooms/cl_init.lua:
include("shared.lua")
include("ballistic_shields/cl_bs_util.lua")

ENT.RenderGroup = RENDERGROUP_BOTH

function ENT:Draw()
	self:DrawModel()
end  
--addons/ballistic_shields/lua/ballistic_shields/sh_bs_util.lua:
bshields = bshields or {}
bshields.config = bshields.config or {}

bshields.shields = {
	{
		[1] = {
			["angles"] = Angle(4,6,-14),
			["position"] = Vector(5,10,-5)
		},
		[2] = {
			["angles"] = Angle(6,1,-15),
			["position"] = Vector(6,10,-5)
		},
		[3] = {
			["angles"] = Angle(4,6,-14),
			["position"] = Vector(5,10,-5)
		}
	},
	{
		[1] = {
			["angles"] = Angle(-12,0,0),
			["position"] = Vector(6,-4,-8)
		},
		[2] = {
			["angles"] = Angle(-12,0,0),
			["position"] = Vector(1,-3,-12)
		},
		[3] = {
			["angles"] = Angle(-12,0,0),
			["position"] = Vector(6,-3,-12)
		}
	},
	{
		[1] = {
			["angles"] = Angle(70,78,-16),
			["position"] = Vector(1,-7,-13)
		},
		[2] = {
			["angles"] = Angle(70,78,-16),
			["position"] = Vector(1,-6,-22)
		},
		[3] = {
			["angles"] = Angle(70,78,-16),
			["position"] = Vector(1,-8,-12)
		}
	}
}

--lua/entities/chemlight_gib1/cl_init.lua:
include("shared.lua")

function ENT:Initialize()

end

function ENT:Draw()
	self.Entity:DrawModel()
end


function ENT:Think()
	end
--gamemodes/starwarsrp/entities/entities/council_chair_yoda/shared.lua:
ENT.RenderGroup = RENDERGROUP_BOTH
ENT.Base = "base_anim"
ENT.Type = "vehicle"

ENT.PrintName = "Jedi-Rat Stuhl - Yoda"
ENT.Author = "Syphadias, Liam0102s Help"
ENT.Category = "CW:RP Sonstiges"
ENT.AutomaticFrameAdvance = true
ENT.Spawnable = true
ENT.EntModel = "models/starwars/syphadias/jedi_knight_jedi_academy/council_chairs/yoda_council_chair.mdl"

if SERVER then
	AddCSLuaFile()

	function ENT:SpawnFunction(pl, tr)
		local e = ents.Create("council_chair_yoda")
		e:SetPos(tr.HitPos + Vector(0, 0, 20))
		e:SetAngles(Angle(0, pl:GetAimVector():Angle().Yaw, 0))
		e:Spawn()
		e:Activate()

		return e
	end

	function ENT:Initialize()
		self:SetModel(self.EntModel)
		self:PhysicsInit(SOLID_VPHYSICS)
		self:SetMoveType(MOVETYPE_VPHYSICS)
		self:SetSolid(SOLID_VPHYSICS)
		self:StartMotionController()
		self:SetUseType(SIMPLE_USE)
		self:SetRenderMode(RENDERMODE_TRANSALPHA)
		self:SecretChair(self:GetPos() + self:GetUp() * 10 + self:GetForward() * 4, self:GetAngles() + Angle(0, -90, 15)) -- Will most likely require tinkering for position
		local phys = self:GetPhysicsObject()

		if (phys:IsValid()) then
			phys:Wake()
			phys:SetMass(100000)
		end
	end

	function ENT:SecretChair(pos, ang)
		local e = ents.Create("prop_vehicle_prisoner_pod")
		e:SetPos(pos)
		e:SetAngles(ang)
		e:SetParent(self)
		e:SetModel("models/nova/airboat_seat.mdl")
		e:SetRenderMode(RENDERMODE_TRANSALPHA)
		e:SetColor(Color(255, 255, 255, 0))
		e:Spawn()
		e:Activate()
		e.IsSyphSeat = true
		self.Chair = e
	end

	hook.Add("PlayerEnteredVehicle", "SyphSeatEnter", function(p, v)
		if (IsValid(p) and IsValid(v)) and v.IsSyphSeat then
			p:SetNWEntity("SyphSeat", v)
		end
	end)

	hook.Add("PlayerLeaveVehicle", "SyphSeatExit", function(p, v)
		if (IsValid(p) and IsValid(v)) then
			if (v.IsSyphSeat) then
				p:SetNWEntity("SyphSeat", NULL)
			end

			p:SetPos(v:GetPos() + v:GetUp() * 10 + v:GetForward() * 50)
			p:SetEyeAngles(Angle(0, v:GetAngles().y + 90, 0))
		end
	end)

	function ENT:Use(p)
		if (not IsValid(self.Chair)) then return end
		p:EnterVehicle(self.Chair)
	end
end

if CLIENT then
	function ENT:Draw()
		self:DrawModel()
	end

	local View = {}

	hook.Add("CalcView", "SyphSeatView", function()
		local p = LocalPlayer()
		local Seat = p:GetNWEntity("SyphSeat", NULL)

		if (IsValid(Seat)) and (Seat:GetThirdPersonMode()) then
			local pos = Seat:GetPos() + LocalPlayer():GetAimVector():GetNormal() * -100 + Seat:GetUp() * 175
			local face = ((Seat:GetPos() + Vector(0, 0, 100)) - pos):Angle()
			View.origin = pos
			View.angles = face

			return View
		end
	end)

	hook.Add("ShouldDrawLocalPlayer", "SyphSeatPlayerDraw", function(p)
		local Seat = p:GetNWEntity("SyphSeat", NULL)

		if IsValid(Seat) and Seat:GetThirdPersonMode() then return true end
	end)
end
--lua/entities/elevator_button/shared.lua:
if (SERVER) then
	AddCSLuaFile();
end;

DEFINE_BASECLASS("base_entity");

ENT.PrintName		= "Elevator Call Button";
ENT.Category		= "Elevators";
ENT.Spawnable		= false;
ENT.AdminOnly		= true;
ENT.Model			= Model("models/props_combine/combinebutton.mdl");
ENT.RenderGroup 	= RENDERGROUP_BOTH;

function ENT:SetupDataTables()
	self:NetworkVar("Entity", 0, "Elevator");
	self:NetworkVar("Bool", 0, "Sender");
end;

if (SERVER) then

	function ENT:SpawnFunction(player, trace, class)
		if (!trace.Hit) then return; end;
		local entity = ents.Create(class);

		entity:SetPos(trace.HitPos + trace.HitNormal * 1.5);
		entity:Spawn();

		return entity;
	end;

	function ENT:Initialize()
		self:SetModel(self.Model);
		self:SetSolid(SOLID_VPHYSICS);
		self:PhysicsInit(SOLID_VPHYSICS);

		local phys = self:GetPhysicsObject();

		if (IsValid(phys)) then
			phys:Wake();
		end;
	end;

	function ENT:Use(activator, caller, type, value)
		if (IsValid(self:GetElevator()) and self:GetElevator():GetVelocity():Length() <= 1) then
			self:GetElevator():Fire(self:GetSender() and "Open" or "Close");
		end;
	end;

elseif (CLIENT) then

	function ENT:Initialize()
		self:SetSolid(SOLID_VPHYSICS);
	end;

	function ENT:Draw()
		self:DrawModel();
	end;

end;
--lua/entities/ent_chemlight_glow_vmanip/cl_init.lua:
include("shared.lua")

function ENT:Initialize()
end

function ENT:Draw()
end

function ENT:Think()
	local rgba = self:GetColor();
    local dlight = DynamicLight( self:EntIndex() )
	if ( dlight ) then
		dlight.Pos = self:GetPos()
		dlight.r = rgba.r
		dlight.g = rgba.g
		dlight.b = rgba.b
		dlight.Brightness = 0
		dlight.Size = 256 * (GetGlobalFloat( "global_Cheml_Range", 100 ) / 100)
		dlight.Decay = 0
		dlight.DieTime = CurTime() + 0.05
	end
end
--lua/entities/ent_chemlight_glow_yellow/cl_init.lua:
include("shared.lua")

function ENT:Initialize()
end

function ENT:Draw()
end

function ENT:Think()
	local rgba = self:GetColor();
    local dlight = DynamicLight( self:EntIndex() )
	if ( dlight ) then
		dlight.Pos = self:GetPos()
		dlight.r = 255 * (GetGlobalFloat( "global_Cheml_Brightness", 80 ) / 100)
		dlight.g = 255 * (GetGlobalFloat( "global_Cheml_Brightness", 80 ) / 100)
		dlight.b = 0 * (GetGlobalFloat( "global_Cheml_Brightness", 80 ) / 100)
		dlight.Brightness = 0
		dlight.Size = 256 * (GetGlobalFloat( "global_Cheml_Range", 100 ) / 100)
		dlight.Decay = 0
		dlight.DieTime = CurTime() + 0.05
	end
end
--addons/wos-alcs-icefusepp/lua/entities/ent_lightsaber_barrier.lua:

--[[

Editing the Lightsabers.

Once you unpack the lightsaber addon, you are voided of any support as to why it doesn't work.
I can't possibly provide support for all the edits and I can't know what your edits broke or whatever.

 /////////////////////////////// DO NOT REUPLOAD THIS ADDON IN ANY SHAPE OF FORM. ///////////////////////////////
 /////////////////////////////// DO NOT REUPLOAD THIS ADDON IN ANY SHAPE OF FORM. ///////////////////////////////
 /////////////////////////////// DO NOT REUPLOAD THIS ADDON IN ANY SHAPE OF FORM. ///////////////////////////////
 /////////////////////////////// DO NOT REUPLOAD THIS ADDON IN ANY SHAPE OF FORM. ///////////////////////////////
 /////////////////////////////// DO NOT REUPLOAD THIS ADDON IN ANY SHAPE OF FORM. ///////////////////////////////

////////////////////////// DO NOT EDIT ANYTHING DOWN BELOW OR YOU LOSE SUPPORT FROM ME //////////////////////////
////////////////////////// DO NOT EDIT ANYTHING DOWN BELOW OR YOU LOSE SUPPORT FROM ME //////////////////////////
////////////////////////// DO NOT EDIT ANYTHING DOWN BELOW OR YOU LOSE SUPPORT FROM ME //////////////////////////
////////////////////////// DO NOT EDIT ANYTHING DOWN BELOW OR YOU LOSE SUPPORT FROM ME //////////////////////////
////////////////////////// DO NOT EDIT ANYTHING DOWN BELOW OR YOU LOSE SUPPORT FROM ME //////////////////////////
////////////////////////// DO NOT EDIT ANYTHING DOWN BELOW OR YOU LOSE SUPPORT FROM ME //////////////////////////

]]

AddCSLuaFile()

ENT.Type = "anim"
ENT.Base = "base_anim"

ENT.PrintName = "Lightsaber"
ENT.Category = "Robotboy655's Entities"

ENT.Editable = true
ENT.Spawnable = true

ENT.RenderGroup = RENDERGROUP_TRANSLUCENT
ENT.ThrowTime = 0

function ENT:SetupDataTables()
	self:NetworkVar( "Float", 0, "BladeLength" )
	self:NetworkVar( "Float", 1, "MaxLength" )
	self:NetworkVar( "Float", 2, "BladeWidth" )

	self:NetworkVar( "Bool", 0, "DarkInner" )
	self:NetworkVar( "Bool", 1, "Enabled" )

	self:NetworkVar( "Vector", 0, "CrystalColor" )
	self:NetworkVar( "Vector", 1 , "EndPos" )
	self:NetworkVar( "Vector", 2, "InnerColor" )

	self:NetworkVar( "String", 0, "WorldModel" )

	self:NetworkVar( "Int", 0, "Stage" )
	if ( SERVER ) then
		self:SetStage( 0 )

		self:SetBladeLength( 0 )
		self:SetBladeWidth( 2 )
		self:SetMaxLength( 42 )
		self:SetInnerColor( Vector( 255, 255, 255 ) )
		self:SetDarkInner( false )
		self:SetEnabled( true )
	end
end

function ENT:Initialize()
	if ( SERVER ) then
		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_NONE )

		self.LoopSound = self.LoopSound || "lightsaber/saber_loop" .. math.random( 1, 8 ) .. ".wav"
		self.SwingSound = self.SwingSound || "lightsaber/saber_swing" .. math.random( 1, 2 ) .. ".wav"
		self.OnSound = self.OnSound || "lightsaber/saber_on" .. math.random( 1, 2 ) .. ".wav"
		self.OffSound = self.OffSound || "lightsaber/saber_off" .. math.random( 1, 2 ) .. ".wav"
		self:SetUseType( SIMPLE_USE )
		if ( self:GetEnabled() ) then self:EmitSound( self.OnSound ) end

		self.SoundSwing = CreateSound( self, Sound( self.SwingSound ) )
		if ( self.SoundSwing ) then self.SoundSwing:Play() self.SoundSwing:ChangeVolume( 0, 0 ) end

		self.SoundHit = CreateSound( self, Sound( "lightsaber/saber_hit.wav" ) )
		if ( self.SoundHit ) then self.SoundHit:Play() self.SoundHit:ChangeVolume( 0, 0 ) end

		self.SoundLoop = CreateSound( self, Sound( self.LoopSound ) )
		if ( self.SoundLoop ) then self.SoundLoop:Play() end
		self:GetPhysicsObject():EnableGravity(false)
		self:GetPhysicsObject():Wake()
	else
		self:SetRenderBounds( Vector( -self:GetBladeLength(), -128, -128 ), Vector( self:GetBladeLength(), 128, 128 ) )

		language.Add( self.ClassName, self.PrintName )
		killicon.AddAlias( "ent_lightsaber", "weapon_lightsaber" )
	end

	self:StartMotionController()
end

function ENT:OnRemove()
	if ( CLIENT ) then rb655_SaberClean( self:EntIndex() ) return end

	if ( self.SoundLoop ) then self.SoundLoop:Stop() self.SoundLoop = nil end
	if ( self.SoundSwing ) then self.SoundSwing:Stop() self.SoundSwing = nil end
	if ( self.SoundHit ) then self.SoundHit:Stop() self.SoundHit = nil end

	if ( self:GetEnabled() ) then self:EmitSound( self.OffSound ) end
end

function ENT:GetSaberPosAng( num, side )
	num = num || 1

	local attachment = self:LookupAttachment( "blade" .. num )
	if ( side ) then
		attachment = self:LookupAttachment( "quillon" .. num )
	end

	if ( attachment > 0 ) then
		local PosAng = self:GetAttachment( attachment )

		return PosAng.Pos, PosAng.Ang:Forward()
	end

	return self:LocalToWorld( Vector( 1, -0.58, -0.25 ) ), -self:GetAngles():Forward()

end

function ENT:Draw()

	self:DrawModel()

	if ( halo.RenderedEntity && IsValid( halo.RenderedEntity() ) && halo.RenderedEntity() == self ) then return end

	local clr = self:GetCrystalColor()
	clr = Color( clr.x, clr.y, clr.z )

	local clr_inner = self:GetInnerColor()
	clr_inner = Color( clr_inner.x, clr_inner.y, clr_inner.z )

	local poss, dirr = self:GetSaberPosAng()
	rb655_RenderBlade_wos( poss, dirr, self:GetBladeLength(), self:GetMaxLength(), self:GetBladeWidth(), clr, self:GetDarkInner(), clr_inner, self:EntIndex(), self:GetOwner():WaterLevel() > 2, false, blades, self.CustomSettings )

	for id, t in pairs( self:GetAttachments() ) do
		if ( !string.match( t.name, "blade(%d+)" ) && !string.match( t.name, "quillon(%d+)" ) ) then continue end

		local bladeNum = string.match( t.name, "blade(%d+)" )
		local quillonNum = string.match( t.name, "quillon(%d+)" )

		if ( bladeNum && self:LookupAttachment( "blade" .. bladeNum ) > 0 and tonumber( bladeNum ) > 0 ) then
			local pos, dir = self:GetSaberPosAng( bladeNum )
			rb655_RenderBlade_wos( pos, dir, self:GetBladeLength(), self:GetMaxLength(), self:GetBladeWidth(), clr, self:GetDarkInner(), clr_inner, self:EntIndex(), self:GetOwner():WaterLevel() > 2, false, blades, self.CustomSettings )
		end

		if ( quillonNum && self:LookupAttachment( "quillon" .. quillonNum ) > 0 ) then
			local pos, dir = self:GetSaberPosAng( quillonNum, true )
			rb655_RenderBlade_wos( pos, dir, self:GetBladeLength(), self:GetMaxLength(), self:GetBladeWidth(), clr, self:GetDarkInner(), clr_inner, self:EntIndex(), self:GetOwner():WaterLevel() > 2, true, blades, self.CustomSettings )
		end
	end
end

if ( CLIENT ) then return end

function ENT:OnTakeDamage( dmginfo )

	-- React physically when shot/getting blown
	self:TakePhysicsDamage( dmginfo )

end

function ENT:Think()
	if not IsValid( self:GetOwner() ) then self:Remove() return end

	if not self:GetOwner():Alive() then
		self:GetOwner():SetNW2Bool( "wOS.BarrierStuff", false )
		self:Remove()

		return
	end

	local ply = self:GetOwner()
	local wep = ply:GetActiveWeapon()

	if not IsValid( wep ) then
		ply:SetNW2Bool( "wOS.BarrierStuff", false )

		self:Remove()

		return
	end

	if not wep.IsLightsaber then
		ply:SetNW2Bool( "wOS.BarrierStuff", false )

		self:Remove()

		return
	end

	if not ply:GetNW2Bool( "wOS.BarrierStuff", false ) then
		self:Remove()
		return
	end

	if ( self:GetBladeLength() != self:GetMaxLength() ) then
		self:SetBladeLength( math.Approach( self:GetBladeLength(), self:GetMaxLength(), 8 ) )
	end

	if ( self:GetEnabled() ) then
		self:SetEnabled( false )
		self:EmitSound( self.OffSound )
	end

	if ( self:GetBladeLength() <= 0 ) then
		if ( self.SoundSwing ) then self.SoundSwing:ChangeVolume( 0, 0 ) end
		if ( self.SoundLoop ) then self.SoundLoop:ChangeVolume( 0, 0 ) end
		if ( self.SoundHit ) then self.SoundHit:ChangeVolume( 0, 0 ) end

		return
	end

	local pos, ang = self:GetSaberPosAng()
	local hit = self:BladeThink( pos, ang )
	if ( self:LookupAttachment( "blade2" ) > 0 ) then
		local pos2, ang2 = self:GetSaberPosAng( 2 )
		local hit_2 = self:BladeThink( pos2, ang2 )
		hit = hit || hit_2
	end

	if ( self.SoundHit ) then
		if ( hit ) then self.SoundHit:ChangeVolume( math.Rand( 0.1, 0.5 ), 0 ) else self.SoundHit:ChangeVolume( 0, 0 ) end
	end

	if ( self.SoundSwing ) then
		if ( self.LastAng != ang ) then
			self.LastAng = self.LastAng || ang
			self.SoundSwing:ChangeVolume( math.Clamp( ang:Distance( self.LastAng ) / 2, 0, 1 ), 0 )
		end
		self.LastAng = ang
	end

	if ( self.SoundLoop ) then
		local pos = pos + ang * self:GetBladeLength()
		if ( self.LastPos != pos ) then
			self.LastPos = self.LastPos || pos
			self.SoundLoop:ChangeVolume( 0.1 + math.Clamp( pos:Distance( self.LastPos ) / 32, 0, 0.2 ), 0 )
		end
		self.LastPos = pos
	end

	self:NextThink( CurTime() + 0.1 )
end

local params = {}
params.secondstoarrive = 0.0001 --this is probably cheating.
params.dampfactor = 0.9999
params.teleportdistance = 0
params.maxangular = 800000
params.maxangulardamp = 9000
params.maxspeed = 100000
params.maxspeeddamp = params.maxangulardamp

function ENT:PhysicsSimulate( phys, time )
	local ply = self:GetOwner()

	if not IsValid(ply) then return end

	phys:Wake()

	local pos = ply:EyePos() - Vector( 0, 0, 8 )
	local newpos = Vector( pos.x + 50 * math.cos( CurTime() * 10 ), pos.y + 50 * math.sin( CurTime() * 10 ), pos.z )

	if self.Second then
		newpos = Vector( pos.x + 50 * math.cos( CurTime() * 10 + 180 ), pos.y + 50 * math.sin( CurTime() * 10 + 180 ), pos.z )
	end

	params.deltatime = time

	local ang = self:GetAngles()
	ang:RotateAroundAxis(ang:Up(), 300 )

	params.angle = ang
	params.pos = newpos
	phys:ComputeShadowControl(params)
end

function ENT:BladeThink( startpos, dir )
	local trace = util.TraceHull( {
		start = startpos,
		endpos = startpos + dir * self:GetBladeLength(),
		filter = { self, self:GetOwner() },
	} )

	if ( trace.Hit ) then
		rb655_DrawHit( trace.HitPos, trace.HitNormal )
		rb655_LS_DoDamage( trace, self )
	end

	return trace.Hit
end

function ENT:Use( activator, caller, useType, value )
	if ( !IsValid( activator ) || !activator:KeyPressed( IN_USE ) ) then return end

	if ( self:GetEnabled() ) then
		self:EmitSound( self.OffSound )
	else
		self:EmitSound( self.OnSound )
	end

	self:SetEnabled( !self:GetEnabled() )
end

function ENT:SpawnFunction( ply, tr )
	if ( !tr.Hit || !ply:CheckLimit( "ent_lightsabers" ) ) then return end

	local ent = ents.Create( ClassName )
	ent:SetPos( tr.HitPos + tr.HitNormal * 2 )

	local ang = ply:EyeAngles()
	ang.p = 0
	ang:RotateAroundAxis( ang:Right(), 180 )
	ent:SetAngles( ang )

	-- Sync values from the tool
	ent:SetMaxLength( math.Clamp( ply:GetInfoNum( "rb655_lightsaber_bladel", 42 ), 32, 64 ) )
	ent:SetCrystalColor( Vector( ply:GetInfo( "rb655_lightsaber_red" ), ply:GetInfo( "rb655_lightsaber_green" ), ply:GetInfo( "rb655_lightsaber_blue" ) ) / 255 )
	ent:SetDarkInner( ply:GetInfo( "rb655_lightsaber_dark" ) == "1" )
	ent:SetModel( ply:GetInfo( "rb655_lightsaber_model" ) )
	ent:SetBladeWidth( math.Clamp( ply:GetInfoNum( "rb655_lightsaber_bladew", 2 ), 2, 4 ) )

	ent.LoopSound = ply:GetInfo( "rb655_lightsaber_humsound" )
	ent.SwingSound = ply:GetInfo( "rb655_lightsaber_swingsound" )
	ent.OnSound = ply:GetInfo( "rb655_lightsaber_onsound" )
	ent.OffSound = ply:GetInfo( "rb655_lightsaber_offsound" )

	ent:Spawn()
	ent:Activate()

	ent.Owner = ply
	ent.Color = ent:GetColor()

	local phys = ent:GetPhysicsObject()
	if ( IsValid( phys ) ) then phys:Wake() end

	if ( IsValid( ply ) ) then
		ply:AddCount( "ent_lightsabers", ent )
		ply:AddCleanup( "ent_lightsabers", ent )
	end

	return ent
end

--addons/system_entities/lua/entities/gravgen/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.Author = "Tood."

ENT.Spawnable = true
ENT.AdminOnly = false

ENT.PrintName = "Gravitationsmodul"
ENT.Category = "CW:RP Systementites"

ENT.GenHealth = 2000 -- Grav Gen health.
ENT.IsSystem = true

function ENT:SetupDataTables()
	self:NetworkVar("Bool", 0, "PlayerRepairing")
end

properties.Add("ignite", {
	MenuLabel = "#ignite",           -- Name to display on the context menu
	Order = 999,                     -- The order to display this property relative to other properties
	MenuIcon = "icon16/fire.png",    -- The icon to display next to the property

	Filter = function(self, ent, ply) -- A function that determines whether an entity is valid for this property
		if (! IsValid(ent)) then return false end
		if (ent:IsPlayer()) then return false end
		if (! gamemode.Call("CanProperty", ply, "ignite", ent)) then return false end

		return ! ent:IsOnFire()
	end,
	Action = function(self, ent) -- The action to perform upon using the property ( Clientside )
		self:MsgStart()
		net.WriteEntity(ent)
		self:MsgEnd()
	end,
	Receive = function(self, length, player) -- The action to perform upon using the property ( Serverside )
		local ent = net.ReadEntity()
		if (! self:Filter(ent, player)) then return end

		ent:Ignite(360)
	end
})


properties.Add("destroy", {
	MenuLabel = "System zerstören",
	Order = 9999,
	MenuIcon = "icon16/bomb.png",

	Filter = function(self, ent, ply)
		if (! IsValid(ent)) then return false end
		if (ent:IsPlayer()) then return false end
		if (ent:GetClass() != "gravgen" and ent:GetClass() != "lifesupport" and ent:GetClass() != "commsarray" and ent:GetClass() != "powerstation") then return false end

		return ! ent:Health() == 0 or 1
	end,

	Action = function(self, ent)
		self:MsgStart()
		net.WriteEntity(ent)
		self:MsgEnd()
	end,

	Receive = function(self, length, player)
		local ent = net.ReadEntity()
		if (! self:Filter(ent, player)) then return end

		ent:SetHealth(1)
		ent:Ignite(2)
	end
})

properties.Add("repair", {
	MenuLabel = "System reparieren",
	Order = 99999,
	MenuIcon = "icon16/tick.png",

	Filter = function(self, ent, ply)
		if (! IsValid(ent)) then return false end
		if (ent:IsPlayer()) then return false end
		if (ent:GetClass() != "gravgen" and ent:GetClass() != "lifesupport" and ent:GetClass() != "commsarray" and ent:GetClass() != "powerstation") then return false end

		return ent:Health() < ent:GetMaxHealth()
	end,

	Action = function(self, ent)
		self:MsgStart()
		net.WriteEntity(ent)
		self:MsgEnd()
	end,

	Receive = function(self, length, player) -- The action to perform upon using the property ( Serverside )
		local ent = net.ReadEntity()
		if (! self:Filter(ent, player)) then return end

		ent:SetHealth(2000)
		ent:SetPlayerRepairing(true)
		--timer.Simple( 3, function() ent:SetPlayerRepairing( false ) end)
	end
})

--addons/hbombs_base/lua/entities/hb_base_clbomb.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "base_anim" )

local Models = {}
Models[1]                            =  "testmodel"

local ExploSnds = {}
ExploSnds[1]                         =  "BaseExplosionEffect.Sound"

local damagesound                    =  "weapons/rpg/shotdown.wav"

ENT.Spawnable		            	 =  false         
ENT.AdminSpawnable		             =  false       

ENT.PrintName		                 =  "Name"        
ENT.Author			                 =  "Chappi"      
ENT.Contact			                 =  "Add me on steam fagit" 
ENT.Category                         =  ""            

ENT.Model                            =  ""            
ENT.Effect                           =  ""            
ENT.EffectAir                        =  ""           
ENT.EffectWater                      =  ""            
ENT.ExplosionSound                   =  ""            
ENT.ArmSound                         =  ""            
ENT.ActivationSound                  =  ""    
ENT.Bomblet                          =  ""         --What should we spawn?

ENT.ShouldExplodeOnImpact            =  true
ENT.Flamable                         =  false
ENT.UseRandomSounds                  =  true
ENT.Timed                            =  false
ENT.RandomAngles                     =  false          -- If this is false, the bomblets will spawn facing the general bomb direction.

ENT.Life                             =  25                                  
ENT.MaxDelay                         =  2                                 
ENT.TraceLength                      =  500
ENT.ImpactSpeed                      =  700
ENT.Mass                             =  500
ENT.ArmDelay                         =  1   
ENT.Timer                            =  0
ENT.NumBomblets                      =  25              -- Number of the bomblets - don't go overboard with this!
ENT.Magnitude                        =  750             -- The bigger the number, the further the bomblets will spread
ENT.Shape                            =  "RANDOM"        -- Can be "RANDOM" or "SPHERE"

ENT.HBOWNER                          =  nil             -- don't you fucking touch this.

function ENT:Initialize()
 if (SERVER) then
     self:LoadModel()
	 self:PhysicsInit( SOLID_VPHYSICS )
	 self:SetSolid( SOLID_VPHYSICS )
	 self:SetMoveType( MOVETYPE_VPHYSICS )
	 self:SetUseType( ONOFF_USE ) 
	 local phys = self:GetPhysicsObject()
	 local skincount = self:SkinCount()
	 if (phys:IsValid()) then
		 phys:SetMass(self.Mass)
		 phys:Wake()
     end
	 if (skincount > 0) then
	     self:SetSkin(math.random(0,skincount))
	 end
	 self.Armed    = false
	 self.Exploded = false
	 self.Used     = false
	 self.Arming   = false
	 if !(WireAddon == nil) then self.Inputs   = Wire_CreateInputs(self, { "Arm", "Detonate" }) end
	end
end

function ENT:TriggerInput(iname, value)
     if (!self:IsValid()) then return end
	 if (iname == "Detonate") then
         if (value >= 1) then
		     if (!self.Exploded and self.Armed) then
			     timer.Simple(math.Rand(0,self.MaxDelay),function()
				     if !self:IsValid() then return end
	                 self.Exploded = true
			         self:Explode()
				 end)
		     end
		 end
	 end
	 if (iname == "Arm") then
         if (value >= 1) then
             if (!self.Exploded and !self.Armed and !self.Arming) then
				 self:EmitSound(self.ActivationSound)
                 self:Arm()
             end 
         end
     end		 
end 

function ENT:LoadModel()
     if self.UseRandomModels then
	     self:SetModel(table.Random(Models))
	 else
	     self:SetModel(self.Model)
	 end
end
	 


function ENT:Explode()
     if !self.Exploded then return end
	 local pos = self:LocalToWorld(self:OBBCenter())
	 self:ExploSound(pos)
	      if not self.Exploded then return end
	 if self.UseRandomSounds then
         sound.Play(table.Random(ExploSnds), pos, 180, 100,1)
     else
	     sound.Play(self.ExplosionSound, pos, 180, 100,1)
	 end
end

function ENT:Explode()
     if !self.Exploded then return end
	 local pos = self:LocalToWorld(self:OBBCenter())
    
		 
	 for i=0, (self.NumBomblets-1) do
	     if !self:IsValid() then return end
		 local bomblet = ents.Create(self.Bomblet)
		 bomblet:SetVar("HBOWNER",self.HBOWNER)
		 bomblet:SetPos(pos)
		 if !self.RandomAngles then
		     bomblet:SetAngles((self:GetForward() * self.AngleModifier):Angle())
		     --bomblet:SetAngles(self:GetAngles())
		 else
		     bomblet:SetAngles(Angle(math.random(-180,180),math.random(-180,180),math.random(-180,180)))
		 end
		 bomblet:Spawn()
		 bomblet:Activate()
		 timer.Simple(10, function()
			if !bomblet:IsValid() then return end
			bomblet:Remove()
		 end)
		 local bphys = bomblet:GetPhysicsObject()
		 local phys = self:GetPhysicsObject()
		 if bphys:IsValid() and phys:IsValid() then
		     if self.Shape == "SPHERE" then
			     bphys:ApplyForceCenter(VectorRand():GetNormal() * bphys:GetMass() * self.Magnitude)
			 else -- shape == anything else then we go totally random.
			     bphys:ApplyForceCenter(VectorRand() * bphys:GetMass() * self.Magnitude)
			 end
			 bphys:AddVelocity(phys:GetVelocity()/2)
		 end
	 end
           
     if(self:WaterLevel() >= 1) then
	     local trdata   = {}
		 local trlength = Vector(0,0,9000)

		 trdata.start   = pos
		 trdata.endpos  = trdata.start + trlength
		 trdata.filter  = self
		 local tr = util.TraceLine(trdata) 

		 local trdat2   = {}
	     trdat2.start   = tr.HitPos
		 trdat2.endpos  = trdata.start - trlength
		 trdat2.filter  = self
		 trdat2.mask    = MASK_WATER + CONTENTS_TRANSLUCENT
			 
		 local tr2 = util.TraceLine(trdat2)
			 
		 if tr2.Hit then
		     ParticleEffect(self.EffectWater, tr2.HitPos, Angle(0,0,0), nil) 
		 end
	 else
		 local tracedata    = {}
	     tracedata.start    = pos
		 tracedata.endpos   = tracedata.start - Vector(0, 0, self.TraceLength)
		 tracedata.filter   = self.Entity
				
		 local trace = util.TraceLine(tracedata)
		 if trace.HitWorld then
		     ParticleEffect(self.Effect,pos,self:GetAngles(),nil)		
		 else 
			 ParticleEffect(self.EffectAir,pos,Angle(0,0,0),nil) 
         end
	 end
	 self:Remove()
end

function ENT:OnTakeDamage(dmginfo)
     if self.Exploded then return end
     self:TakePhysicsDamage(dmginfo)
	 
	 local phys = self:GetPhysicsObject()
	 
     if (self.Life <= 0) then return end
	 if(GetConVar("hb_fragility"):GetInt() >= 1) then
	     if(!self.Armed and !self.Arming) then
	         self:Arm()
	     end
	 end
	 
     if(!self.Armed) then return end

	 if self:IsValid() then
	     self.Life = self.Life - dmginfo:GetDamage()
		 if (self.Life <= self.Life/2) and !self.Exploded and self.Flamable then
		     self:Ignite(self.MaxDelay,0)
		 end
		 if (self.Life <= 0) then 
		     timer.Simple(math.Rand(0,self.MaxDelay),function()
			     if !self:IsValid() then return end 
			     self.Exploded = true
			     self:Explode()
			 end)
	     end
	end
end

function ENT:PhysicsCollide( data, physobj )
     if(self.Exploded) then return end
     if(!self:IsValid()) then return end
	 if(self.Life <= 0) then return end
	 if(GetConVar("hb_fragility"):GetInt() >= 1) then
	     if(data.Speed > self.ImpactSpeed) then
	 	     if(!self.Armed and !self.Arming) then
		         self:EmitSound(damagesound)
	             self:Arm()
	         end
		 end
	 end
	 if(!self.Armed) then return end
     if self.ShouldExplodeOnImpact then
	     if (data.Speed > self.ImpactSpeed ) then
			 self.Exploded = true
			 self:Explode()
		 end
	 end
end

function ENT:Arm()
     if(!self:IsValid()) then return end
	 if(self.Exploded) then return end
	 if(self.Armed) then return end
	 self.Arming = true
	 self.Used = true
	 timer.Simple(self.ArmDelay, function()
	     if !self:IsValid() then return end 
	     self.Armed = true
		 self.Arming = false
		 self:EmitSound(self.ArmSound)
		 if(self.Timed) then
	         timer.Simple(self.Timer, function()
	             if !self:IsValid() then return end 
				 timer.Simple(math.Rand(0,self.MaxDelay),function()
			         if !self:IsValid() then return end 
			         self.Exploded = true
			         self:Explode()
				 end)
	         end)
	     end
	 end)
end	 

function ENT:Use( activator, caller )
     if(self.Exploded) then return end
     if(self:IsValid()) then
	     if(GetConVar("hb_easyuse"):GetInt() >= 1) then
	         if(!self.Armed) then
		         if(!self.Exploded) and (!self.Used) then
		             if(activator:IsPlayer()) then
                         self:EmitSound(self.ActivationSound)
                         self:Arm()
		             end
	             end
             end
         end
	 end
end

function ENT:OnRemove()
	 self:StopParticles()
	-- Wire_Remove(self)
end

if ( CLIENT ) then
     function ENT:Draw()
         self:DrawModel()
		 if !(WireAddon == nil) then Wire_Render(self.Entity) end
     end
end

function ENT:OnRestore()
     Wire_Restored(self.Entity)
end

function ENT:BuildDupeInfo()
     return WireLib.BuildDupeInfo(self.Entity)
end

function ENT:ApplyDupeInfo(ply, ent, info, GetEntByID)
     WireLib.ApplyDupeInfo( ply, ent, info, GetEntByID )
end

function ENT:PrentityCopy()
     local DupeInfo = self:BuildDupeInfo()
     if(DupeInfo) then
         duplicator.StorentityModifier(self,"WireDupeInfo",DupeInfo)
     end
end

function ENT:PostEntityPaste(Player,Ent,CreatedEntities)
     if(Ent.EntityMods and Ent.EntityMods.WireDupeInfo) then
         Ent:ApplyDupeInfo(Player, Ent, Ent.EntityMods.WireDupeInfo, function(id) return CreatedEntities[id] end)
     end
end

--addons/hbombs_base/lua/entities/hb_base_radiation_draw_ent.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "base_anim" )


ENT.Spawnable		            	 =  false
ENT.AdminSpawnable		             =  false     

ENT.PrintName		                 =  "Radiation"        
ENT.Author			                 =  ""      
ENT.Contact			                 =  ""      
          
function ENT:Initialize()
     if (SERVER) then
         self:SetModel("models/props_junk/watermelon01_chunk02c.mdl")
	     self:SetSolid( SOLID_NONE )
	     self:SetMoveType( MOVETYPE_NONE )
	     self:SetUseType( ONOFF_USE ) 
		 self.Bursts = 0
		 self.HBOWNER = self:GetVar("HBOWNER")
		 self.Plylist={}
		 self.EntList={}
		 if self.RadRadius==nil then
			self.RadRadius=500
		 end
		 if self.Burst==nil then
			self.Burst = 10
		 end
		 
     end
end

function ENT:Think()
	if (CLIENT) then
		function Radiation()
			local tex = surface.GetTextureID("hud/radiation")
			surface.SetTexture(tex)
			surface.SetDrawColor( 255, 255, 255, LocalPlayer():GetNWFloat("rad_relation", 0)*255 );		
			surface.DrawTexturedRect( 0, 0, ScrW(), ScrH() )
			hook.Remove( "HUDPaint", "Radiation", Radiation)
		end
		hook.Add( "HUDPaint", "Radiation", Radiation)
	end
	if (SERVER) then
	if !self:IsValid() then return end
	local pos = self:GetPos()
	self.TotalList={}
	for k, v in pairs(ents.FindInSphere(pos,self.RadRadius)) do
		if v:IsPlayer() and !v:IsNPC() and v.hazsuited==false then
			local dist = (self:GetPos() - v:GetPos()):Length()
			local relation = math.Clamp((self.RadRadius - dist) / self.RadRadius, 0, 1)
			v:SetNWFloat("rad_relation", relation  )
			v:SetNWFloat("Affected", 1  )
			table.insert(self.Plylist,v)
			table.insert(self.TotalList, v )
		end
	end

	for k, v in pairs(self.TotalList) do
		if v:IsValid() then 
			if !table.HasValue(self.EntList,v) then
				if v:IsPlayer() then
					table.insert(self.EntList, v )
				end
			end
		end
	end
	for index, entlist_ply in pairs(self.EntList) do
		if !table.HasValue(self.TotalList, entlist_ply ) then
			table.remove(self.EntList, index)
			entlist_ply:SetNWFloat("rad_relation", 0  )
		end
	end
	self.Bursts = self.Bursts + 0.01
	if (self.Bursts >= self.Burst) then
		self:Remove()
	end
	self:NextThink(CurTime() + 0.01)
	return true
	end
end
function ENT:OnRemove()
	if (CLIENT) then
		if (LocalPlayer():GetNWFloat("Affected")) then
		end
	end
	if (SERVER) then
		for k, v in pairs(self.Plylist) do
			if v:IsValid() then
				if v:GetNWFloat("Affected", 0  ) then
					v:SetNWFloat("Affected", 0  )
					v:SetNWFloat("rad_relation", 0  )
				end
			end
		end
	end
end
function ENT:Draw()
     return true
end
--addons/hbombs_base/lua/entities/hb_base_radiation_draw_ent_fl.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "base_anim" )


ENT.Spawnable		            	 =  false
ENT.AdminSpawnable		             =  false     

ENT.PrintName		                 =  "Radiation"        
ENT.Author			                 =  ""      
ENT.Contact			                 =  ""      
          
function ENT:Initialize()
     if (SERVER) then
         self:SetModel("models/props_junk/watermelon01_chunk02c.mdl")
	     self:SetSolid( SOLID_NONE )
	     self:SetMoveType( MOVETYPE_NONE )
	     self:SetUseType( ONOFF_USE ) 
		 self.Bursts = 0
		 self.HBOWNER = self:GetVar("HBOWNER")
		 self.Plylist={}
		 self.EntList={}
		 if self.RadRadius==nil then
			self.RadRadius=500
		 end	 
     end
end

function ENT:Think()
	if (CLIENT) then
		function Radiation()
			local tex = surface.GetTextureID("hud/radiation")
			surface.SetTexture(tex)
			surface.SetDrawColor( 255, 255, 255, LocalPlayer():GetNWFloat("rad_relation", 0)*255 );		
			surface.DrawTexturedRect( 0, 0, ScrW(), ScrH() )
			hook.Remove( "HUDPaint", "Radiation", Radiation)
		end
		hook.Add( "HUDPaint", "Radiation", Radiation)
	end
	if (SERVER) then
	if !self:IsValid() then return end
	if self.radowner:IsValid() then 
		self.pos = string.Explode( " ", tostring(self.radowner:GetPos()) )
		self:SetPos(Vector(self.pos[1],self.pos[2],self.pos[3]))
		local pos = self:GetPos()
		self.TotalList={}
		for k, v in pairs(ents.FindInSphere(pos,self.RadRadius)) do
			if v:IsPlayer() and !v:IsNPC() and v.hazsuited==false then
				local dist = (self:GetPos() - v:GetPos()):Length()
				local relation = math.Clamp((self.RadRadius - dist) / self.RadRadius, 0, 1)
				v:SetNWFloat("rad_relation", relation  )
				v:SetNWFloat("Affected", 1  )
				table.insert(self.Plylist,v)
				table.insert(self.TotalList, v )

			end
		end

		for k, v in pairs(self.TotalList) do
			if v:IsValid() then 
				if !table.HasValue(self.EntList,v) then
						if v:IsPlayer() then
							table.insert(self.EntList, v )
						end
				end
			end
		end
		for index, entlist_ply in pairs(self.EntList) do
			if !table.HasValue(self.TotalList, entlist_ply ) then
				if entlist_ply:IsValid() then
					table.remove(self.EntList, index)
					entlist_ply:SetNWFloat("rad_relation", 0  )
				end
			end
		end
	else
		self:Remove()
	end
	self:NextThink(CurTime() + 0.01)
	return true
	end
end
function ENT:OnRemove()
	if (CLIENT) then
		if (LocalPlayer():GetNWFloat("Affected")) then
		end
	end
	if (SERVER) then
		for k, v in pairs(self.Plylist) do
			if v:IsValid() then
				if v:GetNWFloat("Affected", 0  ) then
					v:SetNWFloat("Affected", 0  )
					v:SetNWFloat("rad_relation", 0  )
				end
			end
		end
	end
end
function ENT:Draw()
     return true
end
--addons/hbombs_base/lua/entities/hb_cp_davy_propel.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "hb_base_advanced" )

ENT.Spawnable		            	 =  true         
ENT.AdminSpawnable		             =  true 

ENT.PrintName		                 =  "Davy Crockett Propellant"
ENT.Author			                 =  "Natsu"
ENT.Contact		                     =  "baldursgate3@gmail.com"
ENT.Category                         =  "HBOMBS Misc"

ENT.Model                            =  "models/thedoctor/davy_propellant.mdl"                      
ENT.Effect                           =  "h_propellant"                  
ENT.EffectAir                        =  "h_propellant"                   
ENT.EffectWater                      =  "water_huge"
ENT.ExplosionSound                   =  "gbombs_5/explosions/medium_bomb/ex_2.wav"
 
ENT.ShouldUnweld                     =  true
ENT.ShouldIgnite                     =  false
ENT.ShouldExplodeOnImpact            =  true
ENT.Flamable                         =  false
ENT.UseRandomSounds                  =  false
ENT.Timed                            =  true

ENT.ExplosionRadius                  =  100
ENT.SpecialRadius                    =  100
ENT.MaxIgnitionTime                  =  0
ENT.Life                             =  2555                                
ENT.MaxDelay                         =  0                                 
ENT.TraceLength                      =  3000
ENT.ImpactSpeed                      =  700
ENT.Mass                             =  52
ENT.ArmDelay                         =  0  
ENT.HBOWNER                          =  nil             -- don't you fucking touch this.

ENT.Shocktime                        =  3
ENT.DEFAULT_PHYSFORCE                = 9955
ENT.DEFAULT_PHYSFORCE_PLYAIR         = 9000
ENT.DEFAULT_PHYSFORCE_PLYGROUND         = 9000 

function ENT:Initialize()
 if (SERVER) then
     self:SetModel(self.Model)
	 
	 self:PhysicsInit( SOLID_VPHYSICS )
	 self:SetSolid( SOLID_VPHYSICS )
	 self:SetMoveType( MOVETYPE_VPHYSICS )
	 self:SetUseType( ONOFF_USE ) -- doesen't fucking work
	 local phys = self:GetPhysicsObject()
	 if (phys:IsValid()) then
		 phys:SetMass(self.Mass)
		 phys:Wake()
     end 
	 if(self.Dumb) then
	     self.Armed    = true
	 else
	     self.Armed    = false
	 end
	 self.Exploded = false
	 self.Used     = false
	 self.Arming = false
	 self.Exploding = false
	  if !(WireAddon == nil) then self.Inputs   = Wire_CreateInputs(self, { "Arm", "Detonate" }) end
	end
end

function ENT:Explode()
     if !self.Exploded then return end
	 if self.Exploding then return end
	
	 local pos_sound = self:LocalToWorld(self:OBBCenter())
	 constraint.RemoveAll(self)
	 local physo = self:GetPhysicsObject()
	 physo:Wake()	
	 if !self:IsValid() then return end 
	 self.Exploding = true
	 local pos = self:GetPos()
	 for k, v in pairs(ents.FindInSphere(pos,45)) do
		if v:GetClass()=="hb_nuclear_davycrockett" then
			sound.Play("gbombs_5/explosions/nuclear/davy_launch.mp3", self:GetPos(), 100, 100, 1)
			local phys = v:GetPhysicsObject()
			if (phys:IsValid()) then
				local mass = phys:GetMass()
				local F_ang = 3000
				local dist = (pos - v:GetPos()):Length()
				local relation = math.Clamp((45- dist) / 45, 0, 1)
				local F_dir = (v:GetPos() - pos):GetNormal() * 3000

				phys:Wake()
				phys:EnableMotion(true)

				phys:AddVelocity(F_dir)
			end
		end
	 end
	 local ent = ents.Create("hb_shockwave_sound_lowsh")
	 ent:SetPos( pos ) 
	 ent:Spawn()
	 ent:Activate()
	 ent:SetVar("HBOWNER", self.HBOWNER)
	 ent:SetVar("MAX_RANGE",50000)
	 ent:SetVar("SHOCKWAVE_INCREMENT",100)
	 ent:SetVar("DELAY",0.01)
	 ent:SetVar("SOUND","gbombs_5/explosions/medium_bomb/ex2.mp3")
	 ent:SetVar("Shocktime", self.Shocktime)
	
	 self:StopParticles()

	 local pos = self:GetPos()
	 if(self:WaterLevel() >= 1) then
		 local trdata   = {}
		 local trlength = Vector(0,0,9000)

		 trdata.start   = pos
		 trdata.endpos  = trdata.start + trlength
		 trdata.filter  = self
		 local tr = util.TraceLine(trdata) 

		 local trdat2   = {}
		 trdat2.start   = tr.HitPos
		 trdat2.endpos  = trdata.start - trlength
		 trdat2.filter  = self
		 trdat2.mask    = MASK_WATER + CONTENTS_TRANSLUCENT
		 
		 local tr2 = util.TraceLine(trdat2)
		 
		 if tr2.Hit then
			 ParticleEffect(self.EffectWater, tr2.HitPos, Angle(0,0,0), nil)
		
		 end
	 else
		 local tracedata    = {}
		 tracedata.start    = pos
		 tracedata.endpos   = tracedata.start - Vector(0, 0, self.TraceLength)
		 tracedata.filter   = self.Entity
			
		 local trace = util.TraceLine(tracedata)
	 
		 if trace.HitWorld then
			 ParticleEffect(self.Effect,pos,self:GetAngles(),nil)	
			 timer.Simple(0.1, function()
				 self:Remove()
			 end)	
		 else 
			 ParticleEffect(self.EffectAir,self:GetPos(),Angle(0,0,0),nil) 
			 self:Remove()

		 end
	 end
end

function ENT:SpawnFunction( ply, tr )
     if ( !tr.Hit ) then return end
	 self.HBOWNER = ply
     local ent = ents.Create( self.ClassName )
	 ent:SetPhysicsAttacker(ply)
     ent:SetPos( tr.HitPos + tr.HitNormal * 16 ) 
     ent:Spawn()
     ent:Activate()
     return ent
end
--addons/hbombs/lua/entities/hb_main_bigjdam.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "hb_base_advanced" )

local ExploSnds = {}
ExploSnds[1]                         =  "gbombs_5/explosions/heavy_bomb/explosion_big_6.mp3"
ExploSnds[2]                         =  "gbombs_5/explosions/heavy_bomb/explosion_big_7.mp3"


ENT.Spawnable						 =  true         
ENT.AdminSpawnable					 =  true 

ENT.PrintName						 =  "JDAM"
ENT.Author							 =  "Business Cat"
ENT.Contact							 =  "nah"
ENT.Category                         =  "HBOMBS Main"

ENT.Model                            =  "models/thedoctor/bomb_jdam.mdl"                      
ENT.Effect                           =  "h_shockwave"                  
ENT.EffectAir                        =  "h_shockwave_airburst"                   
ENT.EffectWater                      =  "h_water_huge"
ENT.ExplosionSound                   =  ""
ENT.ArmSound                         =  "npc/roller/mine/rmine_blip3.wav"            
ENT.ActivationSound                  =  "buttons/button14.wav"     

ENT.ShouldUnweld                     =  true
ENT.ShouldIgnite                     =  false
ENT.ShouldExplodeOnImpact            =  true
ENT.Flamable                         =  false
ENT.UseRandomSounds                  =  false
ENT.UseRandomModels                  =  false
ENT.Timed                            =  false

ENT.ExplosionDamage                  =  1500
ENT.PhysForce                        =  2500
ENT.ExplosionRadius                  =  8000
ENT.SpecialRadius                    =  2500
ENT.MaxIgnitionTime                  =  0 
ENT.Life                             =  20                                  
ENT.MaxDelay                         =  2                                 
ENT.TraceLength                      =  400
ENT.ImpactSpeed                      =  500
ENT.Mass                             =  3000
ENT.ArmDelay                         =  2   
ENT.Timer                            =  0

ENT.Shocktime                        = 4
ENT.HBOWNER                          =  nil             -- don't you fucking touch this.
ENT.Decals                           = "nuke_medium"

function ENT:SpawnFunction( ply, tr )
	 if ( !tr.Hit ) then return end
	 self.HBOWNER = ply
	 local ent = ents.Create( self.ClassName )
	 ent:SetPhysicsAttacker(ply)
	 ent:SetPos( tr.HitPos + tr.HitNormal * 16 ) 
	 ent:Spawn()
	 ent:Activate()

	 return ent
end

function ENT:Explode()
	if !self.Exploded then return end
	local pos = self:LocalToWorld(self:OBBCenter())

	local ent = ents.Create("hb_shockwave_ent")
	ent:SetPos( pos ) 
	ent:Spawn()
	ent:Activate()
	ent:SetVar("DEFAULT_PHYSFORCE", self.DEFAULT_PHYSFORCE)
	ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR", self.DEFAULT_PHYSFORCE_PLYAIR)
	ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND", self.DEFAULT_PHYSFORCE_PLYGROUND)
	ent:SetVar("HBOWNER", self.HBOWNER)
	ent:SetVar("MAX_RANGE",self.ExplosionRadius)
	ent:SetVar("SHOCKWAVE_INCREMENT",135)
	ent:SetVar("DELAY",0.01)
	ent.trace=self.TraceLength
	ent.decal=self.Decal

	local ent = ents.Create("hb_shockwave_sound_lowsh")
	ent:SetPos( pos ) 
	ent:Spawn()
	ent:Activate()
	ent:SetVar("HBOWNER", self.HBOWNER)
	ent:SetVar("MAX_RANGE",50000)
	ent:SetVar("SHOCKWAVE_INCREMENT",135)
	ent:SetVar("DELAY",0.01)
	ent:SetVar("SOUND", table.Random(ExploSnds))
	ent:SetVar("Shocktime", self.Shocktime)
	
	 if(self:WaterLevel() >= 1) then
		 local trdata   = {}
		 local trlength = Vector(0,0,9000)
		 
		 trdata.start   = pos
		 trdata.endpos  = trdata.start + trlength
		 trdata.filter  = self
		 
		 local tr = util.TraceLine(trdata) 
		 local trdat2   = {}
		 trdat2.start   = tr.HitPos
		 trdat2.endpos  = trdata.start - trlength
		 trdat2.filter  = self
		 trdat2.mask    = MASK_WATER + CONTENTS_TRANSLUCENT
			
		 local tr2 = util.TraceLine(trdat2)
			 
		 if tr2.Hit then
			 ParticleEffect(self.EffectWater, tr2.HitPos, Angle(0,0,0), nil)
		 end
	 else
		 local tracedata    = {}
		 tracedata.start    = pos
		 tracedata.endpos   = tracedata.start - Vector(0, 0, self.TraceLength)
		 tracedata.filter   = self.Entity
				
		 local trace = util.TraceLine(tracedata)
		 
		 if trace.HitWorld then
			 ParticleEffect(self.Effect,pos,Angle(0,0,0),nil)
		 else 
			 ParticleEffect(self.EffectAir,pos,Angle(0,0,0),nil) 
		 end
	 end
	 if self.IsNBC then
		 local nbc = ents.Create(self.NBCEntity)
		 nbc:SetVar("HBOWNER",self.HBOWNER)
		 nbc:SetPos(self:GetPos())
		 nbc:Spawn()
		 nbc:Activate()
	 end
	 self:Remove()
end
--addons/hbombs/lua/entities/hb_main_blu82.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "hb_base_advanced" )


ENT.Spawnable						 =  true         
ENT.AdminSpawnable					 =  true 

ENT.PrintName						 =  "BLU-82 Daisy Cutter"
ENT.Author							 =  "Business Cat"
ENT.Contact							 =  "nah"
ENT.Category                         =  "HBOMBS Main"

ENT.Model                            =  "models/squeegy/daisycutter.mdl"                      
ENT.Effect                           =  "h_blu82"                  
ENT.EffectAir                        =  "h_blu82_airburst"                   
ENT.EffectWater                      =  "h_water_huge"
ENT.ExplosionSound                   =  "gbombs_5/explosions/daisy/daisy_explo.wav"
ENT.ArmSound                         =  "npc/roller/mine/rmine_blip3.wav"            
ENT.ActivationSound                  =  "buttons/button14.wav"     

ENT.ShouldUnweld                     =  true
ENT.ShouldIgnite                     =  false
ENT.ShouldExplodeOnImpact            =  true
ENT.Flamable                         =  false
ENT.UseRandomSounds                  =  false
ENT.UseRandomModels                  =  false
ENT.Timed                            =  false

ENT.ExplosionDamage                  =  4000
ENT.PhysForce                        =  2500
ENT.ExplosionRadius                  =  8000
ENT.SpecialRadius                    =  2500
ENT.MaxIgnitionTime                  =  0 
ENT.Life                             =  20                                  
ENT.MaxDelay                         =  2                                 
ENT.TraceLength                      =  400
ENT.ImpactSpeed                      =  500
ENT.Mass                             =  3000
ENT.ArmDelay                         =  2   
ENT.Timer                            =  0

ENT.Shocktime                        = 4
ENT.HBOWNER                          =  nil             -- don't you fucking touch this.
ENT.Decals                           = "nuke_medium"

ENT.LAATC_PICKUPABLE = true
ENT.LAATC_PICKUP_POS = Vector(-200,0,25)
ENT.LAATC_PICKUP_Angle = Angle(0,180,0)

function ENT:SpawnFunction( ply, tr )
	 if ( !tr.Hit ) then return end
	 self.HBOWNER = ply
	 local ent = ents.Create( self.ClassName )
	 ent:SetPhysicsAttacker(ply)
	 ent:SetPos( tr.HitPos + tr.HitNormal * 32 ) 
	 ent:Spawn()
	 ent:Activate()

	 return ent
end

function ENT:Explode()
	if !self.Exploded then return end
	local pos = self:LocalToWorld(self:OBBCenter())

	local ent = ents.Create("hb_shockwave_ent")
	ent:SetPos( pos ) 
	ent:Spawn()
	ent:Activate()
	ent:SetVar("DEFAULT_PHYSFORCE", self.DEFAULT_PHYSFORCE)
	ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR", self.DEFAULT_PHYSFORCE_PLYAIR)
	ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND", self.DEFAULT_PHYSFORCE_PLYGROUND)
	ent:SetVar("HBOWNER", self.HBOWNER)
	ent:SetVar("MAX_RANGE",self.ExplosionRadius)
	ent:SetVar("SHOCKWAVE_INCREMENT",150)
	ent:SetVar("DELAY",0.01)
	ent.trace=self.TraceLength
	ent.decal=self.Decal

	local ent = ents.Create("hb_shockwave_sound_lowsh")
	ent:SetPos( pos ) 
	ent:Spawn()
	ent:Activate()
	ent:SetVar("HBOWNER", self.HBOWNER)
	ent:SetVar("MAX_RANGE",50000)
	ent:SetVar("SHOCKWAVE_INCREMENT",150)
	ent:SetVar("DELAY",0.01)
	ent:SetVar("SOUND", self.ExplosionSound)
	ent:SetVar("Shocktime", self.Shocktime)
	
	 if(self:WaterLevel() >= 1) then
		 local trdata   = {}
		 local trlength = Vector(0,0,9000)
		 
		 trdata.start   = pos
		 trdata.endpos  = trdata.start + trlength
		 trdata.filter  = self
		 
		 local tr = util.TraceLine(trdata) 
		 local trdat2   = {}
		 trdat2.start   = tr.HitPos
		 trdat2.endpos  = trdata.start - trlength
		 trdat2.filter  = self
		 trdat2.mask    = MASK_WATER + CONTENTS_TRANSLUCENT
			
		 local tr2 = util.TraceLine(trdat2)
			 
		 if tr2.Hit then
			 ParticleEffect(self.EffectWater, tr2.HitPos, Angle(0,0,0), nil)
		 end
	 else
		 local tracedata    = {}
		 tracedata.start    = pos
		 tracedata.endpos   = tracedata.start - Vector(0, 0, self.TraceLength)
		 tracedata.filter   = self.Entity
				
		 local trace = util.TraceLine(tracedata)
		 
		 if trace.HitWorld then
			 ParticleEffect(self.Effect,pos,Angle(0,0,0),nil)
		 else 
			 ParticleEffect(self.EffectAir,pos,Angle(0,0,0),nil) 
		 end
	 end
	 if self.IsNBC then
		 local nbc = ents.Create(self.NBCEntity)
		 nbc:SetVar("HBOWNER",self.HBOWNER)
		 nbc:SetPos(self:GetPos())
		 nbc:Spawn()
		 nbc:Activate()
	 end
	 self:Remove()
end
--addons/hbombs_base/lua/entities/hb_main_clusterbomblet.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "hb_base_dumb" )

local ExploSnds = {}
ExploSnds[1]                         =  "ambient/explosions/explode_1.wav"
ExploSnds[2]                         =  "ambient/explosions/explode_2.wav"
ExploSnds[3]                         =  "ambient/explosions/explode_3.wav"
ExploSnds[4]                         =  "ambient/explosions/explode_4.wav"
ExploSnds[5]                         =  "ambient/explosions/explode_5.wav"
ExploSnds[6]                         =  "npc/env_headcrabcanister/explosion.wav"

ENT.Spawnable		            	 =  false        
ENT.AdminSpawnable		             =  false

ENT.PrintName		                 =  "Cluster Bomblet"
ENT.Author			                 =  "Business Cat"
ENT.Contact		                     =  "nah"
ENT.Category                         =  "HBOMBS Main"

ENT.Model                            =  "models/thedoctor/davy_propellant.mdl"                      
ENT.Effect                           =  "h_grenade_main"                  
ENT.EffectAir                        =  "h_grenade_main_air"                   
ENT.EffectWater                      =  "water_medium"
ENT.ExplosionSound                   =  "gbombs_5/explosions/medium_bomb/explosion_medium.mp3"     

ENT.ShouldUnweld                     =  true
ENT.ShouldIgnite                     =  false
ENT.ShouldExplodeOnImpact            =  true
ENT.Flamable                         =  false
ENT.UseRandomSounds                  =  false
ENT.UseRandomModels                  =  false
ENT.Timed                            =  false

ENT.ExplosionDamage                  =  99
ENT.PhysForce                        =  600
ENT.ExplosionRadius                  =  300
ENT.SpecialRadius                    =  575
ENT.MaxIgnitionTime                  =  0 
ENT.Life                             =  98                                 
ENT.MaxDelay                         =  2                                 
ENT.TraceLength                      =  100
ENT.ImpactSpeed                      =  110
ENT.Mass                             =  90
ENT.ArmDelay                         =  2   
ENT.Timer                            =  0

ENT.Shocktime                        = 1
ENT.HBOWNER                          =  nil 

ENT.DEFAULT_PHYSFORCE                = 255
ENT.DEFAULT_PHYSFORCE_PLYAIR         = 20
ENT.DEFAULT_PHYSFORCE_PLYGROUND      = 1000 
ENT.Decal                            = "scorch_small"
function ENT:ExploSound(pos)
     if not self.Exploded then return end
	 if self.UseRandomSounds then
         sound.Play(table.Random(ExploSnds), pos, 160, 100,1)
     else
	     sound.Play(self.ExplosionSound, pos, 160, 100,1)
	 end
end

function ENT:SpawnFunction( ply, tr )
     if ( !tr.Hit ) then return end
     self.HBOWNER = ply
     local ent = ents.Create( self.ClassName )
     ent:SetPhysicsAttacker(ply)
     ent:SetPos( tr.HitPos + tr.HitNormal * 16 ) 
     ent:Spawn()
     ent:Activate()
     return ent
end
--addons/hbombs/lua/entities/hb_main_thermobaric.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "hb_base_advanced" )

local ExploSnds = {}
ExploSnds[1]                         =  "ambient/explosions/explode_1.wav"
ExploSnds[2]                         =  "ambient/explosions/explode_2.wav"
ExploSnds[3]                         =  "ambient/explosions/explode_3.wav"
ExploSnds[4]                         =  "ambient/explosions/explode_4.wav"
ExploSnds[5]                         =  "ambient/explosions/explode_5.wav"
ExploSnds[6]                         =  "npc/env_headcrabcanister/explosion.wav"

ENT.Spawnable						 =  true         
ENT.AdminSpawnable					 =  true 

ENT.AdminOnly						 =  true

ENT.PrintName						 =  "GXM11 - Thermobaric"
ENT.Author							 =  "Business Cat"
ENT.Contact							 =  "nah"
ENT.Category                         =  "HBOMBS Main"

ENT.Model                            =  "models/military2/bomb/bomb_gbu10.mdl"                      
ENT.Effect                           =  "h_2000lb"                  
ENT.EffectAir                        =  "h_2000lb_air"                   
ENT.EffectWater                      =  "h_water_huge"
ENT.ExplosionSound                   =  "gbombs_5/explosions/heavy_bomb/ex1.mp3"
ENT.ArmSound                         =  "npc/roller/mine/rmine_blip3.wav"            
ENT.ActivationSound                  =  "buttons/button14.wav"     

ENT.ShouldUnweld                     =  true
ENT.ShouldIgnite                     =  false
ENT.ShouldExplodeOnImpact            =  true
ENT.Flamable                         =  false
ENT.UseRandomSounds                  =  false
ENT.UseRandomModels                  =  false
ENT.Timed                            =  false

ENT.ExplosionDamage                  =  99
ENT.PhysForce                        =  32
ENT.ExplosionRadius                  =  2155
ENT.SpecialRadius                    =  575
ENT.MaxIgnitionTime                  =  0 
ENT.Life                             =  20                                  
ENT.MaxDelay                         =  2                                 
ENT.TraceLength                      =  100
ENT.ImpactSpeed                      =  350
ENT.Mass                             =  3000
ENT.ArmDelay                         =  1   
ENT.Timer                            =  0

ENT.Shocktime                        = 4
ENT.HBOWNER                          =  nil             -- don't you fucking touch this.
ENT.Decal                            = "nuke_small"


function ENT:SpawnFunction( ply, tr )
	 if ( !tr.Hit ) then return end
	 self.HBOWNER = ply
	 local ent = ents.Create( self.ClassName )
	 ent:SetPhysicsAttacker(ply)
	 ent:SetPos( tr.HitPos + tr.HitNormal * 16 ) 
	 ent:Spawn()
	 ent:Activate()

	 return ent
end


function ENT:Explode()
	 if !self.Exploded then return end
	 local pos = self:LocalToWorld(self:OBBCenter())
	 local owner = self.HBOWNER
   	 local ent = ents.Create("hb_shockwave_ent")
	 ent:SetPos( pos ) 
	 ent:Spawn()
	 ent:Activate()
	 ent:SetVar("DEFAULT_PHYSFORCE", 50)
	 ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR", 50)
	 ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND", 50)
	 ent:SetVar("HBOWNER", self.HBOWNER)
	 ent:SetVar("MAX_RANGE", 2100)
	 ent:SetVar("SHOCKWAVE_INCREMENT",100)
	 ent:SetVar("DELAY",0.01)
	 ent.trace=self.TraceLength
	 ent.decal=self.Decal
	 
	 
	 local ent = ents.Create("hb_shockwave_sound_lowsh")
	 ent:SetPos( pos ) 
	 ent:Spawn()
	 ent:Activate()
	 ent:SetVar("HBOWNER", self.HBOWNER)
	 ent:SetVar("MAX_RANGE",50000)
	 ent:SetVar("SHOCKWAVE_INCREMENT",100)
	 ent:SetVar("DELAY",0.01)
	 ent:SetVar("SOUND", "gbombs_5/explosions/heavy_bomb/explosion_big.mp3")
	 ent:SetVar("Shocktime", 1.2)
	 
	 timer.Simple(1, function()
			 
		 local ent = ents.Create("hb_shockwave_ent")
		 ent:SetPos( pos ) 
		 ent:Spawn()
		 ent:Activate()
		 ent:SetVar("DEFAULT_PHYSFORCE", 200)
		 ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR", 100)
		 ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND", 100)
		 ent:SetVar("HBOWNER", owner)
		 ent:SetVar("MAX_RANGE", 5000)
		 ent:SetVar("SHOCKWAVE_INCREMENT",100)
		 ent:SetVar("DELAY",0.01)
		 ent.trace=self.TraceLength
		 ent.decal=self.Decal
		 
		 local ent = ents.Create("hb_shockwave_sound_lowsh")
		 ent:SetPos( pos ) 
		 ent:Spawn()
		 ent:Activate()
		 ent:SetVar("HBOWNER", self.HBOWNER)
		 ent:SetVar("MAX_RANGE",50000)
		 ent:SetVar("SHOCKWAVE_INCREMENT",100)
		 ent:SetVar("DELAY",0.01)
		 ent:SetVar("SOUND", "gbombs_5/explosions/heavy_bomb/ex1.mp3")
		 ent:SetVar("Shocktime", 3)
	 end)
	 
	 
	 for k, v in pairs(ents.FindInSphere(pos,4000)) do
		 if (v:IsValid() or v:IsPlayer()) then
			if v:IsValid() and v:GetPhysicsObject():IsValid() then
				v:Ignite(4,0)
			end
		 end
	 end


	 if(self:WaterLevel() >= 1) then
		 local trdata   = {}
		 local trlength = Vector(0,0,9000)
		 
		 trdata.start   = pos
		 trdata.endpos  = trdata.start + trlength
		 trdata.filter  = self
		 
		 local tr = util.TraceLine(trdata) 
		 local trdat2   = {}
		 trdat2.start   = tr.HitPos
		 trdat2.endpos  = trdata.start - trlength
		 trdat2.filter  = self
		 trdat2.mask    = MASK_WATER + CONTENTS_TRANSLUCENT
			
		 local tr2 = util.TraceLine(trdat2)
			 
		 if tr2.Hit then
			 ParticleEffect(self.EffectWater, tr2.HitPos, Angle(0,0,0), nil)
		 end
	 else
		 local tracedata    = {}
		 tracedata.start    = pos
		 tracedata.endpos   = tracedata.start - Vector(0, 0, self.TraceLength)
		 tracedata.filter   = self.Entity
				
		 local trace = util.TraceLine(tracedata)
		 
		 if trace.HitWorld then
			 ParticleEffect(self.Effect,pos,Angle(0,0,0),nil)
		 else 
			 ParticleEffect(self.EffectAir,pos,Angle(0,0,0),nil) 
		 end
	 end
	 if self.IsNBC then
		 local nbc = ents.Create(self.NBCEntity)
		 nbc:SetVar("HBOWNER",self.HBOWNER)
		 nbc:SetPos(self:GetPos())
		 nbc:Spawn()
		 nbc:Activate()
	 end
	 self:Remove()
end
--addons/hbombs/lua/entities/hb_nuclear_c_b1.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "hb_base_dumb" )


ENT.Spawnable						 =  true         
ENT.AdminSpawnable					 =  true 

ENT.AdminOnly						 =  true

ENT.PrintName						 =  "Nuclear-B Case 01"
ENT.Author							 =  "natsu"
ENT.Contact							 =  "baldursgate3@gmail.com"
ENT.Category                         =  "HBOMBS Custom"

ENT.Model                            =  "models/thedoctor/atomic_bomb_hollow_body.mdl"           
ENT.Effect                           =  ""                  
ENT.EffectAir                        =  ""   
ENT.EffectWater                      =  "" 
ENT.ExplosionSound                   =  ""                   
ENT.ParticleTrail                    =  ""

ENT.ShouldUnweld                     =  false
ENT.ShouldIgnite                     =  false      
ENT.ShouldExplodeOnImpact            =  false         
ENT.Flamable                         =  false        
ENT.UseRandomSounds                  =  false       
ENT.UseRandomModels                  =  false

ENT.ExplosionDamage                  =  1          
ENT.PhysForce                        =  2           
ENT.ExplosionRadius                  =  3           
ENT.SpecialRadius                    =  4            
ENT.MaxIgnitionTime                  =  1           
ENT.Life                             =  500          
ENT.MaxDelay                         =  0          
ENT.TraceLength                      =  0        
ENT.ImpactSpeed                      =  0           
ENT.Mass                             =  13200

ENT.HBOWNER                          =  nil             -- don't you fucking touch this.

function ENT:ExploSound(pos)
	 if not self.Exploded then return end
	 if self.UseRandomSounds then
		 sound.Play(table.Random(ExploSnds), pos, 160, 130,1)
	 else
		 sound.Play(self.ExplosionSound, pos, 160, 130,1)
	 end
end

function ENT:SpawnFunction( ply, tr )
	 if ( !tr.Hit ) then return end
	 self.HBOWNER = ply
	 local ent = ents.Create( self.ClassName )
	 ent:SetPhysicsAttacker(ply)
	 ent:SetPos( tr.HitPos + tr.HitNormal * 16 ) 
	 ent:Spawn()
	 ent:Activate()

	 return ent
end
--addons/hbombs/lua/entities/hb_nuclear_c_h1.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "hb_base_dumb" )


ENT.Spawnable						 =  true         
ENT.AdminSpawnable					 =  true 

ENT.AdminOnly						 =  true

ENT.PrintName						 =  "Nuclear-H Case 01"
ENT.Author							 =  "Natsu"
ENT.Contact							 =  "baldursgate3@gmail.com"
ENT.Category                         =  "HBOMBS Custom"

ENT.Model                            =  "models/thedoctor/atomic_bomb_hollow_head.mdl"           
ENT.Effect                           =  ""                  
ENT.EffectAir                        =  ""   
ENT.EffectWater                      =  "" 
ENT.ExplosionSound                   =  ""                   
ENT.ParticleTrail                    =  ""

ENT.ShouldUnweld                     =  false
ENT.ShouldIgnite                     =  false      
ENT.ShouldExplodeOnImpact            =  false         
ENT.Flamable                         =  false        
ENT.UseRandomSounds                  =  false       
ENT.UseRandomModels                  =  false

ENT.ExplosionDamage                  =  1          
ENT.PhysForce                        =  2           
ENT.ExplosionRadius                  =  3           
ENT.SpecialRadius                    =  4            
ENT.MaxIgnitionTime                  =  1           
ENT.Life                             =  500          
ENT.MaxDelay                         =  0          
ENT.TraceLength                      =  0        
ENT.ImpactSpeed                      =  0           
ENT.Mass                             =  13200

ENT.HBOWNER                          =  nil             -- don't you fucking touch this.

function ENT:ExploSound(pos)
	 if not self.Exploded then return end
	 if self.UseRandomSounds then
		 sound.Play(table.Random(ExploSnds), pos, 160, 130,1)
	 else
		 sound.Play(self.ExplosionSound, pos, 160, 130,1)
	 end
end

function ENT:SpawnFunction( ply, tr )
	 if ( !tr.Hit ) then return end
	 self.HBOWNER = ply
	 local ent = ents.Create( self.ClassName )
	 ent:SetPhysicsAttacker(ply)
	 ent:SetPos( tr.HitPos + tr.HitNormal * 16 ) 
	 ent:Spawn()
	 ent:Activate()

	 return ent
end
--addons/hbombs_base/lua/entities/hb_nuclear_davy_launcher.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "hb_base_dumb" )


ENT.Spawnable		            	 =  true         
ENT.AdminSpawnable		             =  true 

ENT.PrintName		                 =  "Davy Crockett Launcher"
ENT.Author			                 =  "Business Cat"
ENT.Contact		                     =  "nah"
ENT.Category                         =  "HBOMBS Misc"

ENT.Model                            =  "models/thedoctor/davy_launcher.mdl"           
ENT.Effect                           =  ""                  
ENT.EffectAir                        =  ""   
ENT.EffectWater                      =  "" 
ENT.ExplosionSound                   =  ""                   
ENT.ParticleTrail                    =  ""

ENT.ShouldUnweld                     =  false
ENT.ShouldIgnite                     =  false      
ENT.ShouldExplodeOnImpact            =  false         
ENT.Flamable                         =  false        
ENT.UseRandomSounds                  =  false       
ENT.UseRandomModels                  =  false

ENT.ExplosionDamage                  =  1          
ENT.PhysForce                        =  2           
ENT.ExplosionRadius                  =  3           
ENT.SpecialRadius                    =  4            
ENT.MaxIgnitionTime                  =  1           
ENT.Life                             =  500         
ENT.MaxDelay                         =  0          
ENT.TraceLength                      =  0        
ENT.ImpactSpeed                      =  0           
ENT.Mass                             =  50000

ENT.HBOWNER                          =  nil             -- don't you fucking touch this.

function ENT:ExploSound(pos)
     if not self.Exploded then return end
	 if self.UseRandomSounds then
         sound.Play(table.Random(ExploSnds), pos, 160, 130,1)
     else
	     sound.Play(self.ExplosionSound, pos, 160, 130,1)
	 end
end

function ENT:SpawnFunction( ply, tr )
     if ( !tr.Hit ) then return end
	 self.HBOWNER = ply
     local ent = ents.Create( self.ClassName )
	 ent:SetPhysicsAttacker(ply)
     ent:SetPos( tr.HitPos + tr.HitNormal * 40 ) 
     ent:Spawn()
     ent:Activate()

     return ent
end
--addons/hbombs_base/lua/entities/hb_nuclear_davy_tripod.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "hb_base_dumb" )


ENT.Spawnable		            	 =  true         
ENT.AdminSpawnable		             =  true 

ENT.PrintName		                 =  "Davy Crockett Tripod"
ENT.Author			                 =  "Natsu"
ENT.Contact		                     =  "baldursgate3@gmail.com"
ENT.Category                         =  "HBOMBS Misc"

ENT.Model                            =  "models/thedoctor/davy_tripod.mdl"           
ENT.Effect                           =  ""                  
ENT.EffectAir                        =  ""   
ENT.EffectWater                      =  "" 
ENT.ExplosionSound                   =  ""                   
ENT.ParticleTrail                    =  ""

ENT.ShouldUnweld                     =  false
ENT.ShouldIgnite                     =  false      
ENT.ShouldExplodeOnImpact            =  false         
ENT.Flamable                         =  false        
ENT.UseRandomSounds                  =  false       
ENT.UseRandomModels                  =  false

ENT.ExplosionDamage                  =  1          
ENT.PhysForce                        =  2           
ENT.ExplosionRadius                  =  3           
ENT.SpecialRadius                    =  4            
ENT.MaxIgnitionTime                  =  1           
ENT.Life                             =  500          
ENT.MaxDelay                         =  0          
ENT.TraceLength                      =  0        
ENT.ImpactSpeed                      =  0           
ENT.Mass                             =  50000

ENT.HBOWNER                          =  nil             -- don't you fucking touch this.

function ENT:ExploSound(pos)
     if not self.Exploded then return end
	 if self.UseRandomSounds then
         sound.Play(table.Random(ExploSnds), pos, 160, 130,1)
     else
	     sound.Play(self.ExplosionSound, pos, 160, 130,1)
	 end
end

function ENT:SpawnFunction( ply, tr )
     if ( !tr.Hit ) then return end
	 self.HBOWNER = ply
     local ent = ents.Create( self.ClassName )
	 ent:SetPhysicsAttacker(ply)
     ent:SetPos( tr.HitPos + tr.HitNormal * 30 ) 
     ent:SetAngles(Angle(0,0,180))
     ent:Spawn()
     ent:Activate()

     return ent
end
--addons/hbombs_base/lua/entities/hb_nuclear_davycrockett.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "hb_base_advanced_nuke" )

ENT.Spawnable		            	 =  true         
ENT.AdminSpawnable		             =  true 

ENT.PrintName		                 =  "Davy Crockett"
ENT.Author			                 =  "natsu"
ENT.Contact		                     =  "baldursgate3@gmail.com"
ENT.Category                         =  "HBOMBS Nukes"

ENT.Model                            =  "models/thedoctor/davy.mdl"                      
ENT.Effect                           =  "hbomb_small"                  
ENT.EffectAir                        =  "hbomb_small_airburst"                   
ENT.EffectWater                      =  "h_water_huge"
ENT.ArmSound                         =  "npc/roller/mine/rmine_blip3.wav"            
ENT.ActivationSound                  =  "buttons/button14.wav"     

ENT.ShouldUnweld                     =  true
ENT.ShouldIgnite                     =  false
ENT.ShouldExplodeOnImpact            =  true
ENT.Flamable                         =  false
ENT.UseRandomSounds                  =  false
ENT.Timed                            =  false

ENT.ExplosionDamage                  =  500
ENT.PhysForce                        =  2500
ENT.ExplosionRadius                  =  8000
ENT.SpecialRadius                    =  4000
ENT.MaxIgnitionTime                  =  0
ENT.Life                             =  25                                  
ENT.MaxDelay                         =  2                                 
ENT.TraceLength                      =  500
ENT.ImpactSpeed                      =  700
ENT.Mass                             =  255
ENT.ArmDelay                         =  1   
ENT.Timer                            =  0

ENT.DEFAULT_PHYSFORCE                = 255
ENT.DEFAULT_PHYSFORCE_PLYAIR         = 25
ENT.DEFAULT_PHYSFORCE_PLYGROUND         = 2555
ENT.HBOWNER                          =  nil     
ENT.Decal                            = "nuke_small"

function ENT:Initialize()
 if (SERVER) then
     self:SetModel(self.Model)
	 self:PhysicsInit( SOLID_VPHYSICS )
	 self:SetSolid( SOLID_VPHYSICS )
	 self:SetMoveType( MOVETYPE_VPHYSICS )
	 self:SetUseType( ONOFF_USE ) -- doesen't fucking work
	 local phys = self:GetPhysicsObject()
	 if (phys:IsValid()) then
		 phys:SetMass(self.Mass)
		 phys:Wake()
     end 
	 if(self.Dumb) then
	     self.Armed    = true
	 else
	     self.Armed    = false
	 end
	 self.Exploded = false
	 self.Used     = false
	 self.Arming = false
	 self.Exploding = false
	  if !(WireAddon == nil) then self.Inputs   = Wire_CreateInputs(self, { "Arm", "Detonate" }) end
	end
end


if SERVER then
	function ENT:Explode()
		 if !self.Exploded then return end
		 if self.Exploding then return end
		
		 local pos = self:LocalToWorld(self:OBBCenter())
		 self:SetModel("models/gibs/scanner_gib02.mdl")
		 self.Exploding = true
		 
		 local ent = ents.Create("hb_shockwave_sound_instant")
		 ent:SetPos( pos ) 
		 ent:Spawn()
		 ent:Activate()
		 ent:SetVar("HBOWNER", self.HBOWNER)
		 ent:SetVar("MAX_BURSTS", 1)
		 ent:SetVar("MAX_RANGE",50000)
		 ent:SetVar("DELAY",0.1)
		 ent:SetVar("sound", "gbombs_5/explosions/nuclear/tsar_in.mp3")
		 ent:SetVar("Shocktime",1)
		 
		 local ent = ents.Create("hb_shockwave_ent")
		 ent:SetPos( pos ) 
		 ent:Spawn()
		 ent:Activate()
		 ent:SetVar("DEFAULT_PHYSFORCE", self.DEFAULT_PHYSFORCE)
		 ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR", self.DEFAULT_PHYSFORCE_PLYAIR)
		 ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND", self.DEFAULT_PHYSFORCE_PLYGROUND)
		 ent:SetVar("HBOWNER", self.HBOWNER)
		 ent:SetVar("MAX_RANGE",5000)
		 ent:SetVar("SHOCKWAVE_INCREMENT",140)
		 ent:SetVar("DELAY",0.01)
		 ent:SetVar("SOUND", "gbombs_5/explosions/nuclear/nukeaudiobassspeed2.mp3")
		 ent.trace=self.TraceLength
		 ent.decal=self.Decal
		
		local ent = ents.Create("hb_shockwave_ent_nounfreeze")
		ent:SetPos( pos ) 
		ent:Spawn()
		ent:Activate()
		ent:SetVar("DEFAULT_PHYSFORCE",10)
		ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR",1)
		ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND",10)
		ent:SetVar("HBOWNER", self.HBOWNER)
		ent:SetVar("MAX_RANGE",8000)
		ent:SetVar("SHOCKWAVE_INCREMENT",140)
		ent:SetVar("DELAY",0.01)
		ent.trace=self.TraceLength
		ent.decal=self.Decal

		local ent = ents.Create("hb_shockwave_sound_lowsh")
		ent:SetPos( pos ) 
		ent:Spawn()
		ent:Activate()
		ent:SetVar("HBOWNER", self.HBOWNER)
		ent:SetVar("MAX_RANGE",50000)
		ent:SetVar("SHOCKWAVE_INCREMENT",140)
		ent:SetVar("DELAY",0.01)
		ent:SetVar("shocktime", 4)
		ent:SetVar("SOUND", "gbombs_5/explosions/nuclear/NukeAudioBass.mp3")
		constraint.RemoveAll(self)

		
		if GetConVar("hb_nuclear_fallout"):GetInt()== 1 then
			local ent = ents.Create("hb_base_radiation_draw_ent")
			ent:SetPos( pos ) 
			ent:Spawn()
			ent:Activate()
			ent.Burst = 25
			ent.RadRadius=3000
			
			local ent = ents.Create("hb_base_radiation_ent")
			ent:SetPos( pos ) 
			ent:Spawn()
			ent:Activate()
			ent.Burst = 25
			ent.RadRadius=3000
		 end
		 local physo = self:GetPhysicsObject()
		 physo:Wake()
		 physo:EnableMotion(true)
		 for k, v in pairs(ents.FindInSphere(pos,2000)) do
			 if (v:IsValid() or v:IsPlayer()) then
				if v:IsValid() and v:GetPhysicsObject():IsValid() then
					v:Ignite(4,0)
				end
			 end
		 end
		 for k, v in pairs(ents.FindInSphere(pos,350)) do
			 if (v:IsValid() or v:IsPlayer()) then
				if v:IsPlayer() && !v:IsNPC() then
					v:SetModel("models/Humans/Charple04.mdl")
					ParticleEffectAttach("nuke_player_vaporize_fatman",PATTACH_POINT_FOLLOW,ent,0) 
					v:Kill()
				end
			 end
		 end
		 if !self:IsValid() then return end  
		 self:SetModel("models/gibs/scanner_gib02.mdl")
		 self.Exploding = true
		 self:StopParticles()
		 if(self:WaterLevel() >= 1) then
			 local trdata   = {}
			 local trlength = Vector(0,0,9000)

			 trdata.start   = pos
			 trdata.endpos  = trdata.start + trlength
			 trdata.filter  = self
			 local tr = util.TraceLine(trdata) 

			 local trdat2   = {}
			 trdat2.start   = tr.HitPos
			 trdat2.endpos  = trdata.start - trlength
			 trdat2.filter  = self
			 trdat2.mask    = MASK_WATER + CONTENTS_TRANSLUCENT
			 
			 local tr2 = util.TraceLine(trdat2)
			 
			 if tr2.Hit then
				 ParticleEffect(self.EffectWater, tr2.HitPos, Angle(0,0,0), nil)
			
			 end
		 else
			 local tracedata    = {}
			 tracedata.start    = pos
			 tracedata.endpos   = tracedata.start - Vector(0, 0, self.TraceLength)
			 tracedata.filter   = self.Entity
				
			 local trace = util.TraceLine(tracedata)
		 
			if trace.HitWorld then
				 ParticleEffect(self.Effect,pos,Angle(0,0,0),nil)	
				 timer.Simple(1, function()
					 if !self:IsValid() then return end 
					 self:Remove()
				end)	
			else 
				 ParticleEffect(self.EffectAir,pos,Angle(0,0,0),nil) 
				 self:Remove()
				 if(GetConVar("hb_nuclear_emp"):GetInt() >= 1) then
					 local ent = ents.Create("hb_emp_entity")
					 ent:SetPos( self:GetPos() ) 
					 ent:Spawn()
					 ent:Activate()	
				 end
			end
		end
	end
end

function ENT:SpawnFunction( ply, tr )
     if ( !tr.Hit ) then return end
	 self.HBOWNER = ply
     local ent = ents.Create( self.ClassName )
	 ent:SetPhysicsAttacker(ply)
     ent:SetPos( tr.HitPos + tr.HitNormal * 16 ) 
     ent:Spawn()
     ent:Activate()

     return ent
end
--addons/hbombs/lua/entities/hb_nuclear_fatman_noflash.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "hb_base_advanced_nuke" )

ENT.Spawnable						 =  true         
ENT.AdminSpawnable					 =  true 

ENT.AdminOnly						 =  true

ENT.PrintName						 =  "Fat man - No Flash"
ENT.Author							 =  "Business Cat"
ENT.Contact							 =  "Nah"
ENT.Category                         =  "HBOMBS Nukes"

ENT.Model                            =  "models/thedoctor/fatman.mdl"                      
ENT.Effect                           =  "hbomb_a"                  
ENT.EffectAir                        =  "hbomb_airburst_a"                   
ENT.EffectWater                      =  "hbomb_underwater"
ENT.ExplosionSound                   =  "gbombs_5/explosions/nuclear/nukeaudio2.mp3"
ENT.ArmSound                         =  "npc/roller/mine/rmine_blip3.wav"            
ENT.ActivationSound                  =  "buttons/button14.wav"     

ENT.ShouldUnweld                     =  true
ENT.ShouldIgnite                     =  false
ENT.ShouldExplodeOnImpact            =  true
ENT.Flamable                         =  false
ENT.UseRandomSounds                  =  false
ENT.Timed                            =  false

ENT.ExplosionDamage                  =  500
ENT.PhysForce                        =  6500
ENT.ExplosionRadius                  =  10000
ENT.SpecialRadius                    =  5000
ENT.MaxIgnitionTime                  =  0
ENT.Life                             =  25                                  
ENT.MaxDelay                         =  2                                 
ENT.TraceLength                      =  1000
ENT.ImpactSpeed                      =  700
ENT.Mass                             =  4000
ENT.ArmDelay                         =  1   
ENT.Timer                            =  0


ENT.DEFAULT_PHYSFORCE                = 255
ENT.DEFAULT_PHYSFORCE_PLYAIR         = 25
ENT.DEFAULT_PHYSFORCE_PLYGROUND         = 2555

ENT.HBOWNER                          =  nil             -- don't you fucking touch this.
ENT.Decal                            = "nuke_medium"
function ENT:Initialize()
 if (SERVER) then
	 self:SetModel(self.Model)
	 self:PhysicsInit( SOLID_VPHYSICS )
	 self:SetSolid( SOLID_VPHYSICS )
	 self:SetMoveType( MOVETYPE_VPHYSICS )
	 self:SetUseType( ONOFF_USE ) -- doesen't fucking work
	 local phys = self:GetPhysicsObject()
	 if (phys:IsValid()) then
		 phys:SetMass(self.Mass)
		 phys:Wake()
	 end 
	 if(self.Dumb) then
		 self.Armed    = true
	 else
		 self.Armed    = false
	 end
	 self.Exploded = false
	 self.Used     = false
	 self.Arming = false
	 self.Exploding = false
	  if !(WireAddon == nil) then self.Inputs   = Wire_CreateInputs(self, { "Arm", "Detonate" }) end
	end
end

function ENT:Explode()
	 if !self.Exploded then return end
	 if self.Exploding then return end
	 local pos = self:LocalToWorld(self:OBBCenter())
	 
	 local ent = ents.Create("hb_shockwave_ent")
	 ent:SetPos( pos ) 
	 ent:Spawn()
	 ent:Activate()
	 ent:SetVar("DEFAULT_PHYSFORCE", 100)
	 ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR", self.DEFAULT_PHYSFORCE_PLYAIR)
	 ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND", 25)
	 ent:SetVar("HBOWNER", self.HBOWNER)
	 ent:SetVar("MAX_RANGE",10000)
	 ent:SetVar("SHOCKWAVE_INCREMENT",130)
	 ent:SetVar("DELAY",0.01)
	 ent:SetVar("SOUND", self.ExplosionSound)
	 self:SetModel("models/gibs/scanner_gib02.mdl")
	 ent.trace=self.TraceLength
	 ent.decal=self.Decal
	  
	 local ent = ents.Create("hb_shockwave_ent_nounfreeze")	 
	 ent:SetPos( pos ) 
	 ent:Spawn()
	 ent:Activate()
	 ent:SetVar("DEFAULT_PHYSFORCE",10)
	 ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR",1)
	 ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND",1)
	 ent:SetVar("HBOWNER", self.HBOWNER)
	 ent:SetVar("MAX_RANGE",25000)
	 ent:SetVar("SHOCKWAVE_INCREMENT",130)
	 ent:SetVar("DELAY",0.01)
	 ent.trace=self.TraceLength
	 ent.decal=self.Decal
	 
	if GetConVar("hb_nuclear_fallout"):GetInt()== 1 then
		local ent = ents.Create("hb_base_radiation_draw_ent")
		ent:SetPos( pos ) 
		ent:Spawn()
		ent:Activate()
		ent.Burst = 25
		ent.RadRadius=10000
		
		local ent = ents.Create("hb_base_radiation_ent")
		ent:SetPos( pos ) 
		ent:Spawn()
		ent:Activate()
		ent.Burst = 25
		ent.RadRadius=10000
	 end	 
	 local ent = ents.Create("hb_shockwave_sound_lowsh")
	 ent:SetPos( pos ) 
	 ent:Spawn()
	 ent:Activate()
	 ent:SetVar("HBOWNER", self.HBOWNER)
	 ent:SetVar("MAX_RANGE",50000)
	 ent:SetVar("SHOCKWAVE_INCREMENT",130)
	 ent:SetVar("DELAY",0.01)
	 ent:SetVar("SOUND", self.ExplosionSound)
	 self:SetModel("models/gibs/scanner_gib02.mdl")

	 self.Exploding = true
	
	 local physo = self:GetPhysicsObject()
	 physo:Wake()
	 physo:EnableMotion(true)
	 for k, v in pairs(ents.FindInSphere(pos,self.SpecialRadius*3)) do
		 if (v:IsValid() or v:IsPlayer()) then
			if v:IsValid() and v:GetPhysicsObject():IsValid() then
				v:Ignite(4,0)
			end
		 end
	 end
	 for k, v in pairs(ents.FindInSphere(pos,self.SpecialRadius)) do
		if (v:IsValid() or v:IsPlayer()) then
			if v:IsPlayer() && !v:IsNPC() then
				v:SetModel("models/Humans/Charple04.mdl")
				v:Kill()
			end
		 end
	 end
	
  	 timer.Simple(2, function()
		 if !self:IsValid() then return end 
		 constraint.RemoveAll(self)
	
		 self:StopParticles()
		 for k, v in pairs(ents.FindInSphere(pos,9000)) do
			 if self.ShouldUnweld then
				 if v:IsValid() then
					 if v:IsValid() and v:GetPhysicsObject():IsValid() then
						 constraint.RemoveAll(v)
					 end
				 end
			 end
		 end
	 end)
	 if(self:WaterLevel() >= 1) then
		 local trdata   = {}
		 local trlength = Vector(0,0,9000)

		 trdata.start   = pos
		 trdata.endpos  = trdata.start + trlength
		 trdata.filter  = self
		 local tr = util.TraceLine(trdata) 

		 local trdat2   = {}
		 trdat2.start   = tr.HitPos
		 trdat2.endpos  = trdata.start - trlength
		 trdat2.filter  = self
		 trdat2.mask    = MASK_WATER + CONTENTS_TRANSLUCENT
		 
		 local tr2 = util.TraceLine(trdat2)
		 
		 if tr2.Hit then
			 ParticleEffect(self.EffectWater, tr2.HitPos, Angle(0,0,0), nil)
		
		 end
	 else
		 local tracedata    = {}
		 tracedata.start    = pos
		 tracedata.endpos   = tracedata.start - Vector(0, 0, self.TraceLength)
		 tracedata.filter   = self.Entity
			
		 local trace = util.TraceLine(tracedata)
	 
		 if trace.HitWorld then
			 ParticleEffect(self.Effect,pos,Angle(0,0,0),nil)	
			 timer.Simple(2, function()
				 if !self:IsValid() then return end 
				 ParticleEffect("",trace.HitPos,Angle(0,0,0),nil)	
				 self:Remove()
			end)	
		 else 
			 ParticleEffect(self.EffectAir,pos,Angle(0,0,0),nil) 
			 --Here we do an emp check
			if(GetConVar("hb_nuclear_emp"):GetInt() >= 1) then
				 local ent = ents.Create("hb_emp_entity")
				 ent:SetPos( self:GetPos() ) 
				 ent:Spawn()
				 ent:Activate()	
			 end
		 end
	 end
end

function ENT:SpawnFunction( ply, tr )
	 if ( !tr.Hit ) then return end
	 self.HBOWNER = ply
	 local ent = ents.Create( self.ClassName )
	 ent:SetPhysicsAttacker(ply)
	 ent:SetPos( tr.HitPos + tr.HitNormal * 64 ) 
	 ent:Spawn()
	 ent:Activate()

	 return ent
end
--addons/hbombs_base/lua/entities/hb_nuclear_fizzion_rad.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "hb_nuclear_fission_rad_base" )


ENT.Spawnable		            	 =  false
ENT.AdminSpawnable		             =  false     

ENT.PrintName		                 =  "Radiation"        
ENT.Author			                 =  ""      
ENT.Contact			                 =  ""      

ENT.HBOWNER                          =  nil            
ENT.DAMAGE_MUL = 1
function ENT:Initialize()
     if (SERVER) then
         self:SetModel("models/props_junk/watermelon01_chunk02c.mdl")
	     self:SetSolid( SOLID_NONE )
	     self:SetMoveType( MOVETYPE_NONE )
	     self:SetUseType( ONOFF_USE ) 
		 self.Bursts = 0
		 self.HBOWNER = self:GetVar("HBOWNER")
     end
end
function ENT:Think()
     if (SERVER) then
     if !self:IsValid() then return end
	 local pos = self:GetPos()
	 local dmg = DamageInfo()
	 dmg:SetDamage(math.random(1,2)*self.DAMAGE_MUL)
	 dmg:SetDamageType(DMG_RADIATION)
	 dmg:SetAttacker(self.HBOWNER)
	 for k, v in pairs(ents.FindInSphere(pos,400)) do
         if v:IsPlayer() or v:IsNPC() then
		    v:EmitSound("player/geiger3.wav", 100, 100)
		    v:TakeDamageInfo(dmg)
		    timer.Simple(math.random(), function()
		   	v:EmitSound("player/geiger2.wav", 100, 100)
			if !v:IsNPC() then
				v:ConCommand("Rad")
			end
		    end)
		 end
	 end
	 self.Bursts = self.Bursts + 1
	 if (self.Bursts >= 30) then
	     self:Remove()
	 end
	 self:NextThink(CurTime() + (math.random() + 1))
	 return true
	 end
end

function ENT:Draw()
     return false
end
--addons/hbombs_base/lua/entities/hb_shockwave_ent.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "base_anim" )


ENT.Spawnable		            	 =  false
ENT.AdminSpawnable		             =  false     

ENT.PrintName		                 =  ""        
ENT.Author			                 =  ""      
ENT.Contact			                 =  ""      

ENT.HBOWNER                          =  nil            
ENT.MAX_RANGE                        = 0
ENT.SHOCKWAVE_INCREMENT              = 0
ENT.DELAY                            = 0
ENT.SOUND                            = ""

if SERVER then
	function ENT:Initialize()  
		 self.FILTER = {}
		 self:SetModel("models/props_junk/watermelon01_chunk02c.mdl")
		 self:SetSolid( SOLID_NONE )
		 self:SetMoveType( MOVETYPE_NONE )
		 self:SetUseType( ONOFF_USE ) 
		 self.Bursts = 0
		 self.CURRENTRANGE = 0
		 self.HBOWNER = self:GetVar("HBOWNER")
		 self.SOUND = self:GetVar("SOUND")
		 self.DEFAULT_PHYSFORCE  = self:GetVar("DEFAULT_PHYSFORCE")
		 self.DEFAULT_PHYSFORCE_PLYAIR  = self:GetVar("DEFAULT_PHYSFORCE_PLYAIR")
		 self.DEFAULT_PHYSFORCE_PLYGROUND = self:GetVar("DEFAULT_PHYSFORCE_PLYGROUND")
		 self.SHOCKWAVEDAMAGE = self:GetVar("SHOCKWAVE_DAMAGE")
		 self.allowtrace=true
	end
end
function ENT:Trace()
	if SERVER then
		if !self:IsValid() then return end
		if(GetConVar("hb_decals"):GetInt() >= 1) then
			local pos = self:GetPos()
			local tracedata    = {}
			tracedata.start    = pos
			tracedata.endpos   = tracedata.start - Vector(0, 0, self.trace)
			tracedata.filter   = self.Entity
			local trace = util.TraceLine(tracedata)
			if self.decal==nil then 
				self.decal="scorch_medium"
			end

			util.Decal( self.decal, tracedata.start, tracedata.endpos )
		end
	end
end
function ENT:Think()		
     if (SERVER) then
     if !self:IsValid() then return end
	 local pos = self:GetPos()
	 self.CURRENTRANGE = self.CURRENTRANGE+(self.SHOCKWAVE_INCREMENT*10)
	 if self.allowtrace then
		self:Trace()
		self.allowtrace=false
	 end
	 for k, v in pairs(ents.FindInSphere(pos,self.CURRENTRANGE)) do
		 if (v:IsValid() or v:IsPlayer()) then
			 local i = 0
			 while i < v:GetPhysicsObjectCount() do
				 local dmg = DamageInfo()
				 dmg:SetDamage(math.random(5,25))
				 dmg:SetDamageType(DMG_BLAST)
				 if self.HBOWNER == nil then
					self.HBOWNER = table.Random(player.GetAll())
				 end
				 if !self.HBOWNER:IsValid() then
					self.HBOWNER = table.Random(player.GetAll())
				 end
				 dmg:SetAttacker(self.HBOWNER)
				 phys = v:GetPhysicsObjectNum(i)
				 if (phys:IsValid()) then
					 local mass = phys:GetMass()
					 local F_ang = self.DEFAULT_PHYSFORCE
					 local dist = (pos - v:GetPos()):Length()
			
					 local relation = math.Clamp((self.CURRENTRANGE - dist) / self.CURRENTRANGE, 0, 1)
					 local F_dir = (v:GetPos() - pos):GetNormal() * (self.DEFAULT_PHYSFORCE or 690)
					 phys:AddAngleVelocity(Vector(F_ang, F_ang, F_ang) * relation)
					 phys:AddVelocity(F_dir)
					 if(GetConVar("hb_shockwave_unfreeze"):GetInt() >= 1) then
						 if !v.isWacAircraft then
						 	phys:Wake()
						    phys:EnableMotion(true)
							constraint.RemoveAll(v)
						 end
					 end
					 if (v:GetClass()=="func_breakable" or class=="func_breakable_surf" or class=="func_physbox") then
						v:Fire("Break", 0)
					 end
				 end
				 if (v:IsPlayer()) then
					
				     v:TakeDamageInfo(dmg)
					 local mass = phys:GetMass()
					 local F_ang = self.DEFAULT_PHYSFORCE_PLYAIR
					 local dist = (pos - v:GetPos()):Length()
					 local relation = math.Clamp((self.CURRENTRANGE - dist) / self.CURRENTRANGE, 0, 1)
					 local F_dir = (v:GetPos() - pos):GetNormal() * (self.DEFAULT_PHYSFORCE_PLYAIR or 690)
					 v:SetVelocity( F_dir )		
				 end

				 if (v:IsPlayer()) and v:IsOnGround() then
				     v:TakeDamageInfo(dmg)
					 local mass = phys:GetMass()
					 local F_ang = self.DEFAULT_PHYSFORCE_PLYGROUND
					 local dist = (pos - v:GetPos()):Length()
					 local relation = math.Clamp((self.CURRENTRANGE - dist) / self.CURRENTRANGE, 0, 1)
					 local F_dir = (v:GetPos() - pos):GetNormal() * (self.DEFAULT_PHYSFORCE_PLYGROUND or 690)	 
					 v:SetVelocity( F_dir )		
				 end
				 if (v:IsNPC()) then
					 v:TakeDamageInfo(dmg)
				 end
			 i = i + 1
			 end
		 end
 	 end
	 self.Bursts = self.Bursts + 1
	 if (self.CURRENTRANGE >= self.MAX_RANGE) then
	     self:Remove()
	 end
	 self:NextThink(CurTime() + (self.DELAY*10))
	 return true
	 end
end

function ENT:Draw()
     return false
end
--addons/hbombs_base/lua/entities/hb_shockwave_ent_nounfreeze.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "base_anim" )


ENT.Spawnable		            	 =  false
ENT.AdminSpawnable		             =  false     

ENT.PrintName		                 =  ""        
ENT.Author			                 =  ""      
ENT.Contact			                 =  ""      

ENT.HBOWNER                          =  nil            
ENT.MAX_RANGE                        = 0
ENT.SHOCKWAVE_INCREMENT              = 0
ENT.DELAY                            = 0
ENT.SOUND                            = ""

function ENT:Initialize()
     if (SERVER) then
		 self.FILTER                           = {}
         self:SetModel("models/props_junk/watermelon01_chunk02c.mdl")
	     self:SetSolid( SOLID_NONE )
	     self:SetMoveType( MOVETYPE_NONE )
	     self:SetUseType( ONOFF_USE ) 
		 self.Bursts = 0
		 self.CURRENTRANGE = 0
		 self.HBOWNER = self:GetVar("HBOWNER")
		 self.SOUND = self:GetVar("SOUND")
		 self.DEFAULT_PHYSFORCE  = self:GetVar("DEFAULT_PHYSFORCE")
		 self.DEFAULT_PHYSFORCE_PLYAIR  = self:GetVar("DEFAULT_PHYSFORCE_PLYAIR")
	     self.DEFAULT_PHYSFORCE_PLYGROUND = self:GetVar("DEFAULT_PHYSFORCE_PLYGROUND")
		 self.SHOCKWAVEDAMAGE = self:GetVar("SHOCKWAVE_DAMAGE")


     end
end

function ENT:Think()		
     if (SERVER) then
     if !self:IsValid() then return end
	 local pos = self:GetPos()
	 self.CURRENTRANGE = self.CURRENTRANGE+self.SHOCKWAVE_INCREMENT
	 for k, v in pairs(ents.FindInSphere(pos,self.CURRENTRANGE)) do
		 if (v:IsValid() or v:IsPlayer()) then
			 local i = 0
			 while i < v:GetPhysicsObjectCount() do
		
				 phys = v:GetPhysicsObjectNum(i)
				 if (phys:IsValid()) then
					 local mass = phys:GetMass()
					 local F_ang = self.DEFAULT_PHYSFORCE
					 local dist = (pos - v:GetPos()):Length()
					 local relation = math.Clamp((self.CURRENTRANGE - dist) / self.CURRENTRANGE, 0, 1)
					 local F_dir = (v:GetPos() - pos):GetNormal() * (self.DEFAULT_PHYSFORCE or 690) 
					 phys:AddAngleVelocity(Vector(F_ang, F_ang, F_ang) * relation)
					 phys:AddVelocity(F_dir)
				 end
				 if (v:IsPlayer()) then
					
					 local mass = phys:GetMass()
					 local F_ang = self.DEFAULT_PHYSFORCE_PLYAIR
					 local dist = (pos - v:GetPos()):Length()
					 local relation = math.Clamp((self.CURRENTRANGE - dist) / self.CURRENTRANGE, 0, 1)
					 local F_dir = (v:GetPos() - pos):GetNormal() * (self.DEFAULT_PHYSFORCE_PLYAIR or 690)
					 v:SetVelocity( F_dir )		
				 end

				 if (v:IsPlayer()) and v:IsOnGround() then
					 local mass = phys:GetMass()
					 local F_ang = self.DEFAULT_PHYSFORCE_PLYGROUND
					 local dist = (pos - v:GetPos()):Length()
					 local relation = math.Clamp((self.CURRENTRANGE - dist) / self.CURRENTRANGE, 0, 1)
					 local F_dir = (v:GetPos() - pos):GetNormal() * (self.DEFAULT_PHYSFORCE_PLYGROUND or 690)	 
					 v:SetVelocity( F_dir )		
				 end
			 i = i + 1
			 end
		 end
 	 end
	 self.Bursts = self.Bursts + 1
	 if (self.CURRENTRANGE >= self.MAX_RANGE) then
	     self:Remove()
	 end
	 self:NextThink(CurTime() + self.DELAY)
	 return true
	 end
end

function ENT:Draw()
     return false
end
--addons/hbombs_base/lua/entities/hb_shockwave_sin.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "base_anim" )


ENT.Spawnable		            	 =  false
ENT.AdminSpawnable		             =  false     

ENT.PrintName		                 =  ""        
ENT.Author			                 =  ""      
ENT.Contact			                 =  ""      

ENT.HBOWNER                          =  nil            
ENT.MAX_RANGE                        = 0
ENT.DELAY                            = 0
ENT.SOUND                            = ""
ENT.Burst                            = 0 

function ENT:Initialize()
     if (SERVER) then
		 self.FILTER                           = {}
         self:SetModel("models/props_junk/watermelon01_chunk02c.mdl")
	     self:SetSolid( SOLID_NONE )
	     self:SetMoveType( MOVETYPE_NONE )
	     self:SetUseType( ONOFF_USE ) 
		 self.Bursts = 0
		 self.HBOWNER = self:GetVar("HBOWNER")
		 self.SOUND = self:GetVar("SOUND")
		 self.CURRENTRANGE = 15000
		 self.DEFAULT_PHYSFORCE  = 1522
		 self.DEFAULT_PHYSFORCE_PLYAIR  = 1522
	     self.DEFAULT_PHYSFORCE_PLYGROUND = 1522

     end
end

function ENT:Think(ply)		
     if (SERVER) then
     if !self:IsValid() then return end
	 pos = self:GetPos()
	 for k, v in pairs(ents.FindInSphere(self:GetPos(),15000)) do
		 if (v:IsValid() or v:IsPlayer()) then
			 local i = 0
			 while i < v:GetPhysicsObjectCount() do
				 phys = v:GetPhysicsObjectNum(i)
				 if (phys:IsValid()) then
					 local mass = phys:GetMass()
					 local F_ang = self.DEFAULT_PHYSFORCE
					 local dist = (pos - v:GetPos()):Length()
			
					 local relation = math.Clamp((self.CURRENTRANGE - dist) / self.CURRENTRANGE, 0, 1)
					 local F_dir = (v:GetPos() - pos):GetNormal() * (self.DEFAULT_PHYSFORCE or 690) 			 
					 local f_vel = string.Explode( " ", tostring(F_dir) )
					 if self.Bursts == nil then
						 local x = tonumber(f_vel[1])*math.sin(1)
						 local y = tonumber(f_vel[2])*math.sin(1)
						 local z = tonumber(f_vel[3])*math.sin(1)
						 phys:AddVelocity(Vector(x,y,z))
					 else	 
						 local x = tonumber(f_vel[1])*math.sin(self.Bursts/4)
						 local y = tonumber(f_vel[2])*math.sin(self.Bursts/4)
						 local z = tonumber(f_vel[3])*math.sin(self.Bursts/4)
						 phys:AddVelocity(Vector(x,y,z))
					 end
					 phys:AddAngleVelocity(Vector(F_ang, F_ang, F_ang) * relation)
			

					 if(GetConVar("hb_shockwave_unfreeze"):GetInt() >= 1) then
						 phys:Wake()
						 phys:EnableMotion(true)
						 constraint.RemoveAll(v)
					 end
				 end
				 
				 if (v:IsPlayer() && !v:IsOnGround()) then			
					 local mass = phys:GetMass()
					 local F_ang = self.DEFAULT_PHYSFORCE_PLYAIR
					 local dist = (pos - v:GetPos()):Length()
					 local relation = math.Clamp((15000 - dist) / 15000, 0, 1)
					 local F_dir = (v:GetPos() - pos):GetNormal() * (self.DEFAULT_PHYSFORCE_PLYAIR or 690)
					
					 f_vel = string.Explode( " ", tostring(F_dir) )
					 
					 if self.Bursts == nil then
						 local x = tonumber(f_vel[1])*math.sin(1)
						 local y = tonumber(f_vel[2])*math.sin(1)
						 local z = tonumber(f_vel[3])*math.sin(1)
						 v:SetVelocity( Vector(x,y,z))
					 else	 
						 local x = tonumber(f_vel[1])*math.sin(self.Bursts/4)
						 local y = tonumber(f_vel[2])*math.sin(self.Bursts/4)
						 local z = tonumber(f_vel[3])*math.sin(self.Bursts/4)
						 v:SetVelocity( Vector(x,y,z))
					 end
				 end

				 if (v:IsPlayer()) and v:IsOnGround() then

					 local pos = self:GetPos()
					 local mass = phys:GetMass()
					 local F_ang = self.DEFAULT_PHYSFORCE_PLYGROUND
					 local dist = (pos - v:GetPos()):Length()
					 local relation = math.Clamp((15000 - dist) / 15000, 0, 1)
					 local F_dir = (v:GetPos() - pos):GetNormal() * (self.DEFAULT_PHYSFORCE_PLYGROUND or 690)	 
	
					 local f_vel = string.Explode( " ", tostring(F_dir) )
					 
					 if self.Bursts == nil then
						 local x = tonumber(f_vel[1])*math.sin(1)
						 local y = tonumber(f_vel[2])*math.sin(1)
						 local z = tonumber(f_vel[3])*math.sin(1)
						 v:SetVelocity( Vector(x,y,z))
					 else	 
						 local x = tonumber(f_vel[1])*math.sin(self.Bursts/4)
						 local y = tonumber(f_vel[2])*math.sin(self.Bursts/4)
						 local z = tonumber(f_vel[3])*math.sin(self.Bursts/4)
						 v:SetVelocity( Vector(x,y,z))
					 end

					 
				 end
			 i = i + 1
			 end
		 end
 	 end
	 self.Bursts = self.Bursts + 1

	 if (self.Bursts >= 300) then
	     self:Remove()
	 end
	 self:NextThink(CurTime() + 0.1)
	 return true
	 end
end

function ENT:Draw()
     return false
end
--addons/heart_turbolaser_tool/lua/entities/heart_turbolaser/shared.lua:
ENT.Type = "anim";
ENT.Base = "base_anim";
ENT.PrintName = "heart_turbolaser";
ENT.Author = "drunken hearted";

ENT.Spawnable = false;

function ENT:SetupDataTables()
	self:NetworkVar( "String", "0", "ColR" );
	self:NetworkVar( "String", "1", "ColG" );
	self:NetworkVar( "String", "2", "ColB" );

	self:NetworkVar("Float", "0", "Scale");
end

--addons/vanilla-tools/lua/entities/hyperspace_modelship/cl_init.lua:
include("shared.lua")
function ENT:Draw()
    self:DrawModel()
end

--addons/lvs_turret/lua/entities/joes_sam_turret_lfs/shared.lua:
if not simfphys or not simfphys.LFS then return end
ENT.Type = "anim"
ENT.Base = "joes_turret_base_lfs"

ENT.PrintName = "[LFS] SAM Turret"
ENT.Category = "Joe | Turrets"

ENT.Spawnable = false
ENT.AdminSpawnable = true
ENT.Editable = true

ENT.model = "models/sam_model/base.mdl"

ENT.HideDriver = true
ENT.SeatPos = Vector(0,0,50)
ENT.SeatAng = Angle(0,-90,0)

ENT.MaxHealth = 500
ENT.MaxShield = 100 --set 0 for no shield
ENT.Range = 60000
ENT.LoseTargetDistance = ENT.Range + 1000
ENT.Clip = 8

ENT.targetgroundvehicles = true
ENT.targetairvehicles = true
ENT.targethumans = true

ENT.team = 1
--addons/lvs_turret/lua/entities/joes_turret_base_lfs/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()
end
/*
function ENT:Initialize()
end

function ENT:LFSCalcViewFirstPerson( view, ply )
	local v = {}
	return v
end

function ENT:LFSCalcViewThirdPerson( view, ply )
	local v = {}
	return v
end

function ENT:LFSHudPaintInfoText( X, Y, speed, alt, AmmoPrimary, AmmoSecondary, Throttle )
end

function ENT:LFSHudPaintInfoLine( HitPlane, HitPilot, LFS_TIME_NOTIFY, Dir, Len, FREELOOK )
end

function ENT:LFSHudPaintCrosshair( HitPlane, HitPilot )
end

function ENT:LFSHudPaint( X, Y, data, ply )
end

function ENT:LFSHudPaintPassenger( X, Y, ply )
end

function ENT:Think()
	self:DamageFX()
end

function ENT:DamageFX()
	local HP = self:GetHP()
end

function ENT:OnRemove()
	self:SoundStop()
end

function ENT:SoundStop()
end
*/
--addons/egm_lvs_ships/lua/entities/laat_bactabomb/shared.lua:
ENT.Base            = "base_gmodentity"
ENT.Type            = "anim"

ENT.PrintName       = "Detonator"
ENT.Author          = "Deltaa"
ENT.Information     = ""
ENT.Category        = "[LVS] - Republik"

ENT.Spawnable		= false
ENT.AdminSpawnable	= false

ENT.BounceSound = Sound("TFA_CSGO_SmokeGrenade.Bounce")
ENT.ExplodeSound = Sound("weapons/tfa_starwars/Smoke_Explosive_Puff_01.wav")
--addons/egm_lvs_ships/lua/entities/laat_detonator/shared.lua:
ENT.Base            = "base_gmodentity"
ENT.Type            = "anim"

ENT.PrintName       = "Detonator"
ENT.Author          = "!Ben"
ENT.Information     = ""
ENT.Category        = "[LVS] - Republik"

ENT.Spawnable		= false
ENT.AdminSpawnable	= false

game.AddParticles("particles/gb5_100lb.pcf")
PrecacheParticleSystem("100lb_ground")
--lua/entities/laat_hatch/shared.lua:
ENT.Base            = "base_entity"
ENT.Type            = "anim"

ENT.PrintName       = "Hatch"
ENT.Author          = "!Ben"
ENT.Information     = ""
ENT.Category        = "[LFS] - Star Wars Pack"

ENT.Spawnable		= false
ENT.AdminSpawnable	= false

ENT.RenderGroup = RENDERGROUP_BOTH

ENT.AutomaticFrameAdvance = true
--lua/entities/laat_rocketlauncher/shared.lua:
ENT.Base            = "base_entity"
ENT.Type            = "anim"

ENT.PrintName       = "Rockets"
ENT.Author          = "!Ben"
ENT.Information     = ""
ENT.Category        = "[LFS] - Star Wars Pack"

ENT.Spawnable		= false
ENT.AdminSpawnable	= false

ENT.RenderGroup = RENDERGROUP_BOTH

ENT.AutomaticFrameAdvance = true
--addons/egm_lvs_ships/lua/entities/laat_symoxinbomb/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()
end
--addons/lvs_base/lua/entities/lvs_armor.lua:
AddCSLuaFile()

ENT.Type            = "anim"
ENT.DoNotDuplicate = true

ENT.RenderGroup = RENDERGROUP_BOTH 

function ENT:SetupDataTables()
	self:NetworkVar( "Entity",0, "Base" )

	self:NetworkVar( "Float",0, "HP" )
	self:NetworkVar( "Float",1, "MaxHP" )
	self:NetworkVar( "Float",2, "IgnoreForce" )

	self:NetworkVar( "Vector",0, "Mins" )
	self:NetworkVar( "Vector",1, "Maxs" )

	self:NetworkVar( "Bool",0, "Destroyed" )

	self:NetworkVar( "String",0, "Label" )

	if SERVER then
		self:SetMaxHP( 100 )
		self:SetHP( 100 )
		self:SetLabel( "Armor Plate" )
	end
end

if SERVER then
	function ENT:Initialize()	
		self:SetMoveType( MOVETYPE_NONE )
		self:SetSolid( SOLID_NONE )
		self:DrawShadow( false )
	end

	function ENT:Think()
		return false
	end

	function ENT:OnHealthChanged( dmginfo, old, new )
		if old == new then return end
	end

	function ENT:OnRepaired()
	end

	function ENT:OnDestroyed( dmginfo )
	end

	function ENT:OnTakeDamage( dmginfo )
	end

	function ENT:TakeTransmittedDamage( dmginfo )
		local Force = dmginfo:GetDamageForce()

		local Damage = dmginfo:GetDamage()
		local DamageForce = Force:Length()
		local IsBlastDamage = dmginfo:IsDamageType( DMG_BLAST )

		local CurHealth = self:GetHP()

		local pos = dmginfo:GetDamagePosition()
		local dir = Force:GetNormalized()

		local base = self:GetBase()

		-- translate force value to armor penetration value is Force * 0.1
		-- mm to inch is * 0.0393701
		-- so correct value is * 0.00393701
		local pLength = DamageForce * 0.00393701

		local TraceData = {
			start = pos - dir * pLength,
			endpos = pos + dir * pLength,
		}

		local trace = util.TraceLine( TraceData )

		-- parent stays the same
		local parent = trace.Entity
		local parentPos = trace.HitPos
		local parentDir = trace.HitNormal

		-- only one extra iteration should be enough ...
		if IsValid( trace.Entity ) and isfunction( trace.Entity.GetBase ) and trace.Entity:GetBase() == base then

			TraceData.filter = trace.Entity

			local FilteredTrace = util.TraceLine( TraceData )

			if FilteredTrace.Hit then
				trace = FilteredTrace
			end

			trace.Entity = base
		end

		local DotHitNormal = math.Clamp( trace.HitNormal:Dot( dir ) ,-1,1) 

		local Armor = self:GetIgnoreForce()
		local ArmorEffective = Armor / math.abs( DotHitNormal )

		if math.abs( DotHitNormal ) > 0.9 then
			ArmorEffective = Armor
		end

		local DisableBounce = false

		local Inflictor = dmginfo:GetInflictor()

		if IsValid( Inflictor ) then
			if Inflictor.DisableBallistics or Inflictor:IsNPC() or Inflictor:IsNextBot() then
				DisableBounce = true
			end
		end

		if DamageForce <= ArmorEffective and not IsBlastDamage then
			local T = CurTime()

			if trace.Entity ~= base then
				self._NextBounce = T + 1

				return false
			end

			local Ax = math.acos( DotHitNormal )
			local HitAngle = 90 - (180 - math.deg( Ax ))

			if HitAngle > 30 then
				local effectdata = EffectData()
					effectdata:SetOrigin( trace.HitPos )
					effectdata:SetNormal( -dir )
				util.Effect( "manhacksparks", effectdata, true, true )
	
				self._NextBounce = T + 1

				return false
			end

			local NewDir = dir - trace.HitNormal * math.cos( Ax ) * 2

			if (self._NextBounce or 0) > T or DisableBounce then
				local effectdata = EffectData()
					effectdata:SetOrigin( trace.HitPos )
					effectdata:SetNormal( NewDir:GetNormalized() * 0.25 )
				util.Effect( "manhacksparks", effectdata, true, true )

				return false
			end

			self._NextBounce = T + 1

			local hit_decal = ents.Create( "lvs_armor_bounce" )
			hit_decal:SetPos( trace.HitPos )
			hit_decal:SetAngles( NewDir:Angle() )
			hit_decal:Spawn()
			hit_decal:Activate()
			hit_decal:EmitSound("lvs/armor_rico"..math.random(1,6)..".wav", 95, 100, math.min( dmginfo:GetDamage() / 1000, 1 ) )

			local PhysObj = hit_decal:GetPhysicsObject()
			if not IsValid( PhysObj ) then return false end

			PhysObj:EnableDrag( false )
			PhysObj:SetVelocityInstantaneous( NewDir * 2000 + Vector(0,0,250) )
			PhysObj:SetAngleVelocityInstantaneous( VectorRand() * 250 )

			return false
		end

		local NewHealth = math.Clamp( CurHealth - Damage, 0, self:GetMaxHP() )

		self:OnHealthChanged( dmginfo, CurHealth, NewHealth )
		self:SetHP( NewHealth )

		if NewHealth <= 0 and not self:GetDestroyed() then
			self:SetDestroyed( true )
			self:OnDestroyed( dmginfo )
		end

		local hit_decal = ents.Create( "lvs_armor_penetrate" )
		hit_decal:SetPos( parentPos + parentDir * 0.2 )
		hit_decal:SetAngles( parentDir:Angle() + Angle(90,0,0) )
		hit_decal:Spawn()
		hit_decal:Activate()
		hit_decal:SetParent( parent )

		return true
	end

	return
end

function ENT:Initialize()
end

function ENT:OnRemove()
end

function ENT:Think()
end


function ENT:Draw()
end

local function DrawText( pos, text, col )
	cam.Start2D()
		local data2D = pos:ToScreen()

		if not data2D.visible then cam.End2D() return end

		local font = "TargetIDSmall"

		local x = data2D.x
		local y = data2D.y

		draw.DrawText( text, font, x + 1, y + 1, Color( 0, 0, 0, 120 ), TEXT_ALIGN_CENTER )
		draw.DrawText( text, font, x + 2, y + 2, Color( 0, 0, 0, 50 ), TEXT_ALIGN_CENTER )
		draw.DrawText( text, font, x, y, col or color_white, TEXT_ALIGN_CENTER )
	cam.End2D()
end

local LVS = LVS
local BoxMat = Material("models/wireframe")
local ColorSelect = Color(0,127,255,150)
local ColorNormal = Color(50,50,50,150)
local ColorTransBlack = Color(0,0,0,150)
local OutlineThickness = Vector(0.5,0.5,0.5)
local ColorText = Color(255,0,0,255)

function ENT:DrawTranslucent()
	if not LVS.DeveloperEnabled then return end

	local ply = LocalPlayer()

	if not IsValid( ply ) or ply:InVehicle() or not ply:KeyDown( IN_SPEED ) then return end

	local boxOrigin = self:GetPos()
	local boxAngles = self:GetAngles()
	local boxMins = self:GetMins()
	local boxMaxs = self:GetMaxs()

	local HitPos, _, _ = util.IntersectRayWithOBB( ply:GetShootPos(), ply:GetAimVector() * 1000, boxOrigin, boxAngles, boxMins, boxMaxs )

	local InRange = isvector( HitPos )

	local Col = InRange and ColorSelect or ColorNormal

	render.SetColorMaterial()
	render.DrawBox( boxOrigin, boxAngles, boxMins, boxMaxs, Col )
	render.DrawBox( boxOrigin, boxAngles, boxMaxs + OutlineThickness, boxMins - OutlineThickness, ColorTransBlack )

	local boxCenter = (self:LocalToWorld( boxMins ) + self:LocalToWorld( boxMaxs )) * 0.5

	if not InRange then return end

	DrawText( boxCenter, "Armor: "..(self:GetIgnoreForce() / 100).."mm\nHealth:"..self:GetHP().."/"..self:GetMaxHP(), ColorText )
end

--addons/lvs_base/lua/entities/lvs_armor_bounce.lua:
AddCSLuaFile()

ENT.Type            = "anim"

ENT.PrintName = "88mm Round"
ENT.Author = "Luna"
ENT.Information = "Luna's Vehicle Script"
ENT.Category = "[LVS] - Cars - Items"

ENT.Spawnable		= false
ENT.AdminOnly		= false

ENT.LifeTime = 10

if SERVER then
	function ENT:Initialize()
		self:SetModel( "models/misc/88mm_projectile.mdl" )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:PhysicsInit( SOLID_VPHYSICS)

		self.DieTime = CurTime() + self.LifeTime

		self:SetCollisionGroup( COLLISION_GROUP_WORLD )
	end

	function ENT:Think()
		if self.MarkForRemove then self:Remove() return false end

		self:NextThink( CurTime() + 0.1 )

		if (self.DieTime or 0) > CurTime() then return true end

		self:Remove()

		return false
	end

	
	function ENT:PhysicsCollide( data, physobj )
		self.MarkForRemove = true

		local effectdata = EffectData()
		effectdata:SetOrigin( data.HitPos )
		effectdata:SetNormal( -data.HitNormal )
		effectdata:SetMagnitude( 0.5 )
		util.Effect( "lvs_bullet_impact", effectdata )
	end

	return
end

ENT.MatSmoke = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function ENT:Initialize()
	self.DieTime = CurTime() + self.LifeTime

	self.emitter = ParticleEmitter( self:GetPos(), false )
end

function ENT:Smoke()
	local T = CurTime()

	if (self.DieTime or 0) < T then return end

	if not IsValid( self.emitter ) then return end

	if (self.NextFX or 0) < T then
		self.NextFX = T + 0.02

		local Timed = 1 - (self.DieTime - T) / self.LifeTime
		local Scale = math.max(math.min(2 - Timed * 2,1),0)

		local Pos = self:GetPos() 

		local particle = self.emitter:Add( self.MatSmoke[math.random(1,#self.MatSmoke)], Pos )

		local VecCol = (render.GetLightColor( Pos ) * 0.8 + Vector(0.2,0.2,0.2)) * 255

		if particle then
			particle:SetVelocity( VectorRand() * 10 )
			particle:SetDieTime( math.Rand(0.5,1) )
			particle:SetAirResistance( 100 ) 
			particle:SetStartAlpha( 100 * Scale )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( 10 )
			particle:SetEndSize( 20 )
			particle:SetRollDelta( 1 )
			particle:SetColor( VecCol.r, VecCol.g, VecCol.b )
			particle:SetGravity( Vector( 0, 0, 200 ) )
			particle:SetCollide( false )
		end
	end
end

function ENT:Think()
	self:Smoke()
end

function ENT:OnRemove()
	if not self.emitter then return end

	self.emitter:Finish()
end

function ENT:Draw()
	self:DrawModel()
end

--addons/egm_lvs_ground/lua/entities/lvs_av7_blast.lua:
AddCSLuaFile()

ENT.Base 		= "lvs_missile"
ENT.Type 		= "anim"

ENT.PrintName 	= "AV7 Blast"
ENT.Author 		= "Detaa"
ENT.Information = "geht ab wie'n z�pfchen"
ENT.Category 	= "[LVS]"

ENT.Spawnable	= true
ENT.AdminOnly	= true

ENT.ExplosionEffect = "lvs_proton_explosion"
ENT.GlowColor = Color(22, 75, 145)

if SERVER then
	function ENT:GetDamage()
		return 2000
	end

	function ENT:GetRadius()
		return 500
	end

	function ENT:GetSpeed()
		return 10000
	end

	return
end

function ENT:Enable()
	if self.IsEnabled then return end
	self.IsEnabled = true

	self.snd = CreateSound(self, "lvs/vehicles/av7/fire.wav")
	self.snd:SetSoundLevel(80)
	self.snd:Play()
end

function ENT:Draw()
	if not self:GetActive() then return end

	self:DrawModel()

	self.FXEmitter = ParticleEmitter(self:GetPos())

	local dir = self:GetForward()

	local blue = self.FXEmitter:Add("sprites/bluecore", self:GetPos())
	blue:SetVelocity((dir * -1):GetNormalized())
	blue:SetDieTime(0.3)
	blue:SetStartAlpha(255)
	blue:SetEndAlpha(100)
	blue:SetStartSize(40)
	blue:SetEndSize(5)
	blue:SetRoll(math.Rand(-90, 90))
	blue:SetColor(255, 255, 255)
end
--addons/lvs_base/lua/entities/lvs_base/sh_weapons.lua:

ENT.WEAPONS = {
	[1] = {},
}

function ENT:InitWeapons()
end

function ENT:AddWeapon( weaponData, PodID )
	if not istable( weaponData ) then print("[LVS] couldn't register weapon") return end

	local data = table.Copy( weaponData )

	if not PodID or PodID <= 1 then
		PodID = 1
	end

	if not self.WEAPONS[ PodID ] then
		self.WEAPONS[ PodID ] = {}
	end

	local default = LVS:GetWeaponPreset( "DEFAULT" )

	data.Icon = data.Icon or Material("lvs/weapons/bullet.png")
	data.Ammo = data.Ammo or -1
	data.Delay = data.Delay or FrameTime()

	if isnumber( data.Clip ) and data.Clip > 0 then
		data.HeatIsClip = true

		local ShootDelay = data.Delay

		local Clip = data.Clip
		local ReloadSpeed = data.ReloadSpeed or 2

		data.HeatRateUp = 1.00001 / (ShootDelay * Clip)
		data.HeatRateDown = 1 / ReloadSpeed
		data.OnReload = data.OnReload or default.OnReload
	else
		data.HeatRateUp = data.HeatRateUp or default.HeatRateUp
		data.HeatRateDown = data.HeatRateDown or default.HeatRateDown
	end

	data.Attack = data.Attack or default.Attack
	data.StartAttack = data.StartAttack or default.StartAttack
	data.FinishAttack = data.FinishAttack or default.FinishAttack
	data.OnSelect = data.OnSelect or default.OnSelect
	data.OnDeselect = data.OnDeselect or default.OnDeselect
	data.OnThink = data.OnThink or default.OnThink
	data.OnOverheat = data.OnOverheat or default.OnOverheat
	data.OnRemove = data.OnRemove or default.OnRemove
	data.UseableByAI = data.UseableByAI ~= false

	table.insert( self.WEAPONS[ PodID ], data )
end

function ENT:UpdateWeapon( PodID, WeaponID, weaponData )
	if not self.WEAPONS[ PodID ] then return end

	if not self.WEAPONS[ PodID ][ WeaponID ] then return end

	table.Merge( self.WEAPONS[ PodID ][ WeaponID ], weaponData )
end

function ENT:HasWeapon( ID )
	return istable( self.WEAPONS[1][ ID ] )
end

function ENT:AIHasWeapon( ID )
	local weapon = self.WEAPONS[1][ ID ]
	if not istable( weapon ) then return false end

	return weapon.UseableByAI
end

function ENT:GetActiveWeapon()
	local SelectedID = self:GetSelectedWeapon()
	local CurWeapon = self.WEAPONS[1][ SelectedID ]

	return CurWeapon, SelectedID
end

function ENT:GetMaxAmmo()
	local CurWeapon = self:GetActiveWeapon()

	if not CurWeapon then return -1 end

	return CurWeapon.Ammo or -1
end

function ENT:GetClip()
	local CurWeapon = self:GetActiveWeapon()

	if not CurWeapon then return 0 end

	local HeatIncrement = (CurWeapon.HeatRateUp or 0.2) * math.max(CurWeapon.Delay or 0, FrameTime())

	local Ammo = self:GetNWAmmo()

	if self:GetMaxAmmo() <= 0 and CurWeapon.Clip then
		Ammo = CurWeapon.Clip
	end

	return math.min( math.ceil( math.Round( (1 - self:GetNWHeat()) / HeatIncrement, 1 ) ), Ammo )
end

if SERVER then
	function ENT:WeaponRestoreAmmo()
		local AmmoIsSet = false

		for PodID, data in pairs( self.WEAPONS ) do
			for id, weapon in pairs( data ) do
				local MaxAmmo = weapon.Ammo or -1
				local CurAmmo = weapon._CurAmmo or -1

				if CurAmmo == MaxAmmo then continue end

				self.WEAPONS[PodID][ id ]._CurAmmo = MaxAmmo

				AmmoIsSet = true
			end
		end

		if AmmoIsSet then
			self:SetNWAmmo( self:GetAmmo() )

			for _, pod in pairs( self:GetPassengerSeats() ) do
				local weapon = pod:lvsGetWeapon()

				if not IsValid( weapon ) then continue end

				weapon:SetNWAmmo( weapon:GetAmmo() )
			end
		end

		return AmmoIsSet
	end
	
	function ENT:WeaponsOnRemove()
		for _, data in pairs( self.WEAPONS ) do
			for ID, Weapon in pairs( data ) do
				if not Weapon.OnRemove then continue end

				Weapon.OnRemove( self )
			end
		end
	end

	function ENT:WeaponsFinish()
		if not self._activeWeapon then return end

		local CurWeapon = self.WEAPONS[1][ self._activeWeapon ]

		if not CurWeapon then return end

		if CurWeapon.FinishAttack then
			CurWeapon.FinishAttack( self )
		end

		self._activeWeapon = nil
		self.OldAttack = false
	end

	function ENT:GetAmmo()
		if self:GetAI() then return self:GetMaxAmmo() end

		local CurWeapon = self:GetActiveWeapon()

		if not CurWeapon then return -1 end

		return CurWeapon._CurAmmo or self:GetMaxAmmo()
	end

	function ENT:TakeAmmo( num )
		if self:GetMaxAmmo() <= 0 then return end

		local CurWeapon = self:GetActiveWeapon()

		CurWeapon._CurAmmo = math.max( self:GetAmmo() - (num or 1), 0 )

		self:SetNWAmmo( CurWeapon._CurAmmo )
	end

	function ENT:GetHeat( weaponid )
		local CurWeapon

		if isnumber( weaponid ) and weaponid > 0 then
			CurWeapon = self.WEAPONS[1][ weaponid ]
		else
			CurWeapon = self:GetActiveWeapon()
		end

		if not CurWeapon then return 0 end

		return (CurWeapon._CurHeat or 0)
	end

	function ENT:GetOverheated()
		local CurWeapon = self:GetActiveWeapon()

		if not CurWeapon then return false end

		return CurWeapon.Overheated == true
	end

	function ENT:SetOverheated( overheat )
		if self:GetOverheated() == overheat then return end

		local CurWeapon = self:GetActiveWeapon()

		if not CurWeapon then return end

		CurWeapon.Overheated = overheat

		self:SetNWOverheated( overheat )

		if self:GetHeat() == 0 then return end

		if CurWeapon.OnOverheat then
			CurWeapon.OnOverheat( self )
		end
	end

	function ENT:SetHeat( heat )
		local CurWeapon = self:GetActiveWeapon()

		if not CurWeapon then return end

		heat = math.Clamp( heat, 0, 1 )

		CurWeapon._CurHeat = heat

		if self:GetNWHeat() == heat then return end

		self:SetNWHeat( heat )
	end

	function ENT:CanAttack()
		local CurWeapon = self:GetActiveWeapon()

		return (CurWeapon._NextFire or 0) < CurTime()
	end

	function ENT:SetNextAttack( time )
		local CurWeapon = self:GetActiveWeapon()

		CurWeapon._NextFire = time
	end

	function ENT:WeaponsShouldFire()
		if self:GetAI() then return self._AIFireInput end

		local ply = self:GetDriver()

		if not IsValid( ply ) then return false end

		return ply:lvsKeyDown( "ATTACK" )
	end

	function ENT:WeaponsThink()
		local EntTable = self:GetTable()

		local T = CurTime()
		local FT = FrameTime()
		local CurWeapon, SelectedID = self:GetActiveWeapon()
	
		for ID, Weapon in pairs( EntTable.WEAPONS[1] ) do
			local IsActive = ID == SelectedID

			if Weapon.OnThink then Weapon.OnThink( self, IsActive ) end

			if IsActive then continue end

			if Weapon.HeatIsClip and not Weapon.Overheated and Weapon._CurHeat ~= 0 then
				Weapon.Overheated = true
				Weapon._CurHeat = 1

				if Weapon.OnReload then Weapon.OnReload( self ) end
			end

			-- cool all inactive weapons down
			Weapon._CurHeat = Weapon._CurHeat and Weapon._CurHeat - math.min( Weapon._CurHeat, (Weapon.HeatRateDown or 0.25) * FT ) or 0
		end

		if not CurWeapon then return end

		local ShouldFire = self:WeaponsShouldFire()
		local CurHeat = self:GetHeat()

		if self:GetOverheated() then
			if CurHeat <= 0 then
				self:SetOverheated( false )
			else
				ShouldFire = false
			end
		else
			if CurHeat >= 1 then
				self:SetOverheated( true )
				ShouldFire = false
				if CurWeapon.OnReload then CurWeapon.OnReload( self ) end
			end
		end

		if self:GetMaxAmmo() > 0 then
			if self:GetAmmo() <= 0 then
				ShouldFire = false
			end
		end

		if ShouldFire ~= EntTable.OldAttack then
			EntTable.OldAttack = ShouldFire

			if ShouldFire then
				if CurWeapon.StartAttack then
					CurWeapon.StartAttack( self )
				end
				EntTable._activeWeapon = SelectedID
			else
				self:WeaponsFinish()
			end
		end

		if ShouldFire then
			if not self:CanAttack() then return end

			local ShootDelay = (CurWeapon.Delay or 0)

			self:SetNextAttack( T + ShootDelay )
			self:SetHeat( CurHeat + (CurWeapon.HeatRateUp or 0.2) * math.max(ShootDelay, FT) )

			if not CurWeapon.Attack then return end

			if CurWeapon.Attack( self ) then
				self:SetHeat( CurHeat - math.min( self:GetHeat(), (CurWeapon.HeatRateDown or 0.25) * FT ) )
				self:SetNextAttack( T )
			end

			EntTable._lvsNextActiveWeaponCoolDown = T + 0.25
		else
			if (EntTable._lvsNextActiveWeaponCoolDown or 0) > T then return end

			if CurWeapon.HeatIsClip and not CurWeapon.Overheated then

				self:SetHeat( self:GetHeat() )
	
				return
			end

			self:SetHeat( self:GetHeat() - math.min( self:GetHeat(), (CurWeapon.HeatRateDown or 0.25) * FT ) )
		end
	end

	function ENT:SelectWeapon( ID )
		if not isnumber( ID ) then return end

		if self.WEAPONS[1][ ID ] then
			self:SetSelectedWeapon( ID )
		end

		local ply = self:GetDriver()

		if not IsValid( ply ) then return end

		net.Start( "lvs_select_weapon" )
		net.Send( ply )
	end

	function ENT:OnWeaponChanged( name, old, new)
		if new == old then return end

		self:WeaponsFinish()

		local PrevWeapon = self.WEAPONS[1][ old ]
		if PrevWeapon and PrevWeapon.OnDeselect then
			PrevWeapon.OnDeselect( self, new )
		end

		local NextWeapon = self.WEAPONS[1][ new ]
		if NextWeapon and NextWeapon.OnSelect then
			NextWeapon.OnSelect( self, old )
			self:SetNWAmmo( NextWeapon._CurAmmo or NextWeapon.Ammo or -1 )
			self:SetNWOverheated( NextWeapon.Overheated == true )
		end
	end

	return
end

function ENT:DrawWeaponIcon( PodID, ID, x, y, width, height, IsSelected, IconColor )
end

function ENT:SelectWeapon( ID )
	if not isnumber( ID ) then return end

	net.Start( "lvs_select_weapon" )
		net.WriteInt( ID, 5 )
		net.WriteBool( false )
	net.SendToServer()
end

function ENT:NextWeapon()
	net.Start( "lvs_select_weapon" )
		net.WriteInt( 1, 5 )
		net.WriteBool( true )
	net.SendToServer()
end

function ENT:PrevWeapon()
	net.Start( "lvs_select_weapon" )
		net.WriteInt( -1, 5 )
		net.WriteBool( true )
	net.SendToServer()
end

LVS:AddHudEditor( "WeaponSwitcher", ScrW() - 210, ScrH() - 165,  200, 68, 200, 68, "WEAPON SELECTOR", 
	function( self, vehicle, X, Y, W, H, ScrX, ScrY, ply )
		if not vehicle.LVSHudPaintWeapons then return end
		vehicle:LVSHudPaintWeapons( X, Y, W, H, ScrX, ScrY, ply )
	end
)

LVS:AddHudEditor( "WeaponInfo", ScrW() - 230, ScrH() - 85,  220, 75, 220, 75, "WEAPON INFO", 
	function( self, vehicle, X, Y, W, H, ScrX, ScrY, ply )
		if not vehicle.LVSHudPaintWeaponInfo then return end

		vehicle:LVSHudPaintWeaponInfo( X, Y, W, H, ScrX, ScrY, ply )
	end
)

function ENT:GetAmmoID( ID )
	local ply = LocalPlayer()

	if not IsValid( ply ) then return end

	local Base = ply:lvsGetWeaponHandler()

	if not IsValid( Base ) then return -1 end

	local selected = Base:GetSelectedWeapon()
	local weapon = self.WEAPONS[ Base:GetPodIndex() ][ ID ]

	if ID == selected then
		weapon._CurAmmo = Base:GetNWAmmo()
	else
		weapon._CurAmmo = weapon._CurAmmo or weapon.Ammo or -1
	end

	return weapon._CurAmmo
end


local Circles = {
	[1] = {r = -1, col = Color(0,0,0,200)},
	[2] = {r = 0, col = Color(255,255,255,200)},
	[3] = {r = 1, col = Color(255,255,255,255)},
	[4] = {r = 2, col = Color(255,255,255,200)},
	[5] = {r = 3, col = Color(0,0,0,200)},
}

local function DrawCircle( X, Y, target_radius, heatvalue, overheated )
	local endang = 360 * heatvalue

	if endang == 0 then return end

	for i = 1, #Circles do
		local data = Circles[ i ]
		local radius = target_radius + data.r
		local segmentdist = endang / ( math.pi * radius / 2 )

		for a = 0, endang, segmentdist do
			local r = data.col.r
			local g = data.col.g * (1 - math.min(a / 270,1))
			local b = data.col.b * (1 - math.min(a / 90,1))

			surface.SetDrawColor( r, g, b, data.col.a )

			surface.DrawLine( X - math.sin( math.rad( a ) ) * radius, Y + math.cos( math.rad( a ) ) * radius, X - math.sin( math.rad( a + segmentdist ) ) * radius, Y + math.cos( math.rad( a + segmentdist ) ) * radius )
		end
	end
end

ENT.HeatMat = Material( "lvs/heat.png" )
ENT.HeatIsClipMat = Material( "lvs/3d2dmats/refil.png" )

local color_white = color_white
local color_red = Color(255,0,0,255)

function ENT:LVSHudPaintWeaponInfo( X, Y, w, h, ScrX, ScrY, ply )
	local Base = ply:lvsGetWeaponHandler()

	if not IsValid( Base ) then return end

	local ID = Base:GetSelectedWeapon()

	if not Base:HasWeapon( ID ) then return end

	local Weapon = Base:GetActiveWeapon()
	local Heat = Base:GetNWHeat()
	local OverHeated = Base:GetNWOverheated()
	local Ammo = Base:GetNWAmmo()

	if Weapon and Weapon.HeatIsClip then
		local Pod = ply:GetVehicle()

		if not IsValid( Pod ) then return end

		local PodID = Base:GetPodIndex()

		local FT = FrameTime()
		local ShootDelay = math.max(Weapon.Delay or 0, FT)
		local HeatIncrement = (Weapon.HeatRateUp or 0.2) * ShootDelay

		local Clip = Base:GetClip()

		if OverHeated then
			Clip = 0

			local hX = X + w - h * 0.5
			local hY = Y + h * 0.25 + h * 0.25
	
			surface.SetMaterial( self.HeatIsClipMat )
			surface.SetDrawColor( 0, 0, 0, 200 )
			surface.DrawTexturedRectRotated( hX + 3, hY + 1, h, h, 0 )
			surface.SetDrawColor( 255, 0, 0, 255 )
			surface.DrawTexturedRectRotated( hX + 1, hY - 1, h, h, 0 )

			DrawCircle( hX, hY, h * 0.35, Heat )
		end

		Ammo = Ammo - Clip

		local ColDyn = (Clip == 0 or OverHeated) and color_red or color_white

		draw.DrawText( "AMMO ", "LVS_FONT", X + 72, Y + 35, ColDyn, TEXT_ALIGN_RIGHT )

		draw.DrawText( Clip, "LVS_FONT_HUD_LARGE", X + 72, Y + 20, ColDyn, TEXT_ALIGN_LEFT )

		if Base:GetMaxAmmo() <= 0 then return end

		local ColDyn2 = Ammo <= Weapon.Clip and color_red or color_white

		X = X + math.max( (#string.Explode( "", Clip ) - 1) * 18, 0 )

		draw.DrawText( "/", "LVS_FONT_HUD_LARGE", X + 96, Y + 30, ColDyn2, TEXT_ALIGN_LEFT )

		draw.DrawText( Ammo, "LVS_FONT", X + 110, Y + 40, ColDyn2, TEXT_ALIGN_LEFT )

		return
	end

	local hX = X + w - h * 0.5
	local hY = Y + h * 0.25 + h * 0.25
	local hAng = math.cos( CurTime() * 50 ) * 5 * (OverHeated and 1 or Heat ^ 2)

	surface.SetMaterial( self.HeatMat )
	surface.SetDrawColor( 0, 0, 0, 200 )
	surface.DrawTexturedRectRotated( hX + 4, hY + 1, h * 0.5, h * 0.5, hAng )

	if OverHeated then
		surface.SetDrawColor( 255, 0, 0, 255 )
	else
		surface.SetDrawColor( 255, 255 * (1 - Heat), 255 * math.max(1 - Heat * 1.5,0), 255 )
	end

	surface.DrawTexturedRectRotated( hX + 2, hY - 1, h * 0.5, h * 0.5, hAng )

	DrawCircle( hX, hY, h * 0.35, Heat )

	if Base:GetMaxAmmo() <= 0 then return end

	draw.DrawText( "AMMO ", "LVS_FONT", X + 72, Y + 35, color_white, TEXT_ALIGN_RIGHT )
	draw.DrawText( Ammo, "LVS_FONT_HUD_LARGE", X + 72, Y + 20, color_white, TEXT_ALIGN_LEFT )
end

function ENT:LVSHudPaintWeapons( X, Y, w, h, ScrX, ScrY, ply )
	local EntTable = self:GetTable()

	local Base = ply:lvsGetWeaponHandler()

	if not IsValid( Base ) then return end

	local Pod = ply:GetVehicle()

	if not IsValid( Pod ) then return end

	local PodID = Base:GetPodIndex()

	local num = #self.WEAPONS[ PodID ]

	if num <= 1 then return end

	local CenterY = (Y + h * 0.5)
	local CenterX = (X + w * 0.5)

	local FlatSelector = CenterX > ScrX * 0.333 and CenterX < ScrX * 0.666

	local T = CurTime()
	local FT = RealFrameTime()

	local gap = 4
	local SizeY = h - gap

	local Selected = Base:GetSelectedWeapon()
	if Selected ~= EntTable._OldSelected then
		EntTable._OldSelected = Selected
		Pod._SelectActiveTime = T + 2
	end

	local tAlpha = (Pod._SelectActiveTime or 0) > T and 1 or 0
	local tAlphaRate = FT * 15

	EntTable.smAlphaSW = EntTable.smAlphaSW and (EntTable.smAlphaSW + math.Clamp(tAlpha - EntTable.smAlphaSW,-tAlphaRate,tAlphaRate)) or 0

	if EntTable.smAlphaSW > 0.95 then
		EntTable._DisplaySelected = Selected
	else
		EntTable._DisplaySelected = EntTable._DisplaySelected or Selected
	end

	local A255 = 255 * EntTable.smAlphaSW
	local A150 = 150 * EntTable.smAlphaSW

	local Col = Color(0,0,0,A150)
	local ColSelect = Color(255,255,255,A150)

	local SwapY = 0

	if Y < (ScrY * 0.5 - h * 0.5) then
		SwapY = 1
	end

	for ID = 1, num do
		local IsSelected = EntTable._DisplaySelected == ID
		local n = num - ID
		local xPos = FlatSelector and X + (w + gap) * (ID - 1) - ((w + gap) * 0.5 * num - w * 0.5) or X
		local yPos = FlatSelector and Y - h * math.min(SwapY,0) or Y - h * n + (num - 1) * h * SwapY

		draw.RoundedBox(5, xPos, yPos, w, SizeY, IsSelected and ColSelect or Col )

		if IsSelected then
			surface.SetDrawColor( 0, 0, 0, A255 )
		else
			surface.SetDrawColor( 255, 255, 255, A255 )
		end

		if isbool( EntTable.WEAPONS[PodID][ID].Icon ) then
			local col = IsSelected and Color(255,255,255,A255) or Color(0,0,0,A255) 
			self:DrawWeaponIcon( PodID, ID, xPos, yPos, SizeY * 2, SizeY, IsSelected, col )
		else
			surface.SetMaterial( self.WEAPONS[PodID][ID].Icon )
			surface.DrawTexturedRect( xPos, yPos, SizeY * 2, SizeY )
		end

		local ammo = self:GetAmmoID( ID )

		if ammo > -1 then
			draw.DrawText( ammo, "LVS_FONT_HUD", xPos + w - 10, yPos + SizeY * 0.5 - 10, IsSelected and Color(0,0,0,A255) or Color(255,255,255,A255), TEXT_ALIGN_RIGHT )
		else
			draw.DrawText( "O", "LVS_FONT_HUD", xPos + w - 19, yPos + SizeY * 0.5 - 10, IsSelected and Color(0,0,0,A255) or Color(255,255,255,A255), TEXT_ALIGN_RIGHT )
			draw.DrawText( "O", "LVS_FONT_HUD", xPos + w - 10, yPos + SizeY * 0.5 - 10, IsSelected and Color(0,0,0,A255) or Color(255,255,255,A255), TEXT_ALIGN_RIGHT )
		end
	end
end
--addons/lvs_base/lua/entities/lvs_base_gunner/shared.lua:
ENT.Type            = "anim"

ENT.PrintName = "LBaseGunner"
ENT.Author = "Luna"
ENT.Information = "Luna's Vehicle Script"
ENT.Category = "[LVS]"

ENT.Spawnable       = false
ENT.AdminSpawnable  = false
ENT.DoNotDuplicate = true

ENT.LVS_GUNNER = true
ENT.VectorNull = Vector(0,0,0)

function ENT:SetupDataTables()
	self:NetworkVar( "Entity",0, "Driver" )
	self:NetworkVar( "Entity",1, "DriverSeat" )

	self:NetworkVar( "Int", 0, "PodIndex")
	self:NetworkVar( "Int", 1, "NWAmmo")
	self:NetworkVar( "Int", 2, "SelectedWeapon" )

	self:NetworkVar( "Float", 0, "NWHeat" )

	self:NetworkVar( "Bool", 0, "NWOverheated" )

	self:NetworkVar( "Vector", 0, "NWAimVector" )

	if SERVER then
		self:NetworkVarNotify( "SelectedWeapon", self.OnWeaponChanged )
	end
end

function ENT:UnlockAimVector()
	self._AimVectorUnlocked = true
end

function ENT:LockAimVector()
	self._AimVectorUnlocked = nil
end

function ENT:GetEyeTrace()
	local startpos = self:GetPos()

	local trace = util.TraceLine( {
		start = startpos,
		endpos = (startpos + self:GetAimVector() * 50000),
		filter = self:GetCrosshairFilterEnts()
	} )

	return trace
end

function ENT:GetAI()
	if IsValid( self:GetDriver() ) then return false end

	local veh = self:GetVehicle()

	if not IsValid( veh ) then return false end

	return veh:GetAIGunners()
end

function ENT:GetAITEAM()
	local Base = self:GetVehicle()

	if not IsValid( Base ) then return 0 end

	return Base:GetAITEAM()
end

function ENT:GetVehicle()
	local Pod = self:GetParent()

	if not IsValid( Pod ) then return NULL end

	return Pod:GetParent()
end

function ENT:HasWeapon( ID )
	local Base = self:GetVehicle()

	if not IsValid( Base ) then return false end

	return istable( Base.WEAPONS[ self:GetPodIndex() ][ ID ] )
end

function ENT:AIHasWeapon( ID )
	local Base = self:GetVehicle()

	if not IsValid( Base ) then return false end

	local weapon = Base.WEAPONS[ self:GetPodIndex() ][ ID ]

	if not istable( weapon ) then return false end

	return weapon.UseableByAI
end

function ENT:GetActiveWeapon()
	local SelectedID = self:GetSelectedWeapon()

	local Base = self:GetVehicle()

	if not IsValid( Base ) then return {}, SelectedID end

	local CurWeapon = Base.WEAPONS[ self:GetPodIndex() ][ SelectedID ]

	return CurWeapon, SelectedID
end

function ENT:GetMaxAmmo()
	local CurWeapon = self:GetActiveWeapon()

	if not CurWeapon then return -1 end

	return CurWeapon.Ammo or -1
end

function ENT:GetClip()
	local CurWeapon = self:GetActiveWeapon()

	if not CurWeapon then return 0 end

	local HeatIncrement = (CurWeapon.HeatRateUp or 0.2) * math.max(CurWeapon.Delay or 0, FrameTime())

	local Ammo = self:GetNWAmmo()

	if self:GetMaxAmmo() <= 0 and CurWeapon.Clip then
		Ammo = CurWeapon.Clip
	end

	return math.min( math.ceil( math.Round( (1 - self:GetNWHeat()) / HeatIncrement, 1 ) ), Ammo )
end

function ENT:GetCrosshairFilterEnts()
	local Base = self:GetVehicle()

	if not IsValid( Base ) then return {} end

	return Base:GetCrosshairFilterEnts()
end

function ENT:Sign( n )
	if n > 0 then return 1 end

	if n < 0 then return -1 end

	return 0
end

function ENT:VectorSubtractNormal( Normal, Velocity )
	local VelForward = Velocity:GetNormalized()

	local Ax = math.acos( math.Clamp( Normal:Dot( VelForward ) ,-1,1) )

	local Fx = math.cos( Ax ) * Velocity:Length()

	local NewVelocity = Velocity - Normal * math.abs( Fx )

	return NewVelocity
end

function ENT:VectorSplitNormal( Normal, Velocity )
	return math.cos( math.acos( math.Clamp( Normal:Dot( Velocity:GetNormalized() ) ,-1,1) ) ) * Velocity:Length()
end

function ENT:AngleBetweenNormal( Dir1, Dir2 )
	return math.deg( math.acos( math.Clamp( Dir1:Dot( Dir2 ) ,-1,1) ) )
end

function ENT:GetVehicleType()
	return "LBaseGunner"
end
--addons/lvs_base/lua/entities/lvs_bomb.lua:
AddCSLuaFile()

ENT.Type = "anim"

ENT.ExplosionEffect = "lvs_explosion_bomb"

ENT.lvsProjectile = true

function ENT:SetupDataTables()
	self:NetworkVar( "Bool", 0, "Active" )
	self:NetworkVar( "Bool", 1, "MaskSolid" )

	self:NetworkVar( "Vector", 0, "Speed" )
end

if SERVER then
	util.AddNetworkString( "lvs_bomb_hud" )

	function ENT:SetEntityFilter( filter )
		if not istable( filter ) then return end

		self._FilterEnts = {}

		for _, ent in pairs( filter ) do
			self._FilterEnts[ ent ] = true
		end
	end
	function ENT:GetEntityFilter()
		return self._FilterEnts or {}
	end
	function ENT:SetDamage( num ) self._dmg = num end
	function ENT:SetForce( num ) self._force = num end
	function ENT:SetThrust( num ) self._thrust = num end
	function ENT:SetRadius( num ) self._radius = num end
	function ENT:SetAttacker( ent )
		self._attacker = ent

		if not IsValid( ent ) or not ent:IsPlayer() then return end

		net.Start( "lvs_bomb_hud", true )
			net.WriteEntity( self )
		net.Send( ent )
	end

	function ENT:GetAttacker() return self._attacker or NULL end
	function ENT:GetDamage() return (self._dmg or 2000) end
	function ENT:GetForce() return (self._force or 8000) end
	function ENT:GetRadius() return (self._radius or 400) end

	function ENT:Initialize()
		self:SetModel( "models/props_phx/ww2bomb.mdl" )
		self:SetMoveType( MOVETYPE_NONE )
	end

	function ENT:OnTakeDamage( dmginfo )
	end

	function ENT:Enable()
		if self.IsEnabled then return end

		local Parent = self:GetParent()

		if IsValid( Parent ) then
			self:SetOwner( Parent )
			self:SetParent( NULL )
		end

		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )
		self:SetCollisionGroup( COLLISION_GROUP_WORLD )
		self:PhysWake()

		timer.Simple(1, function()
			if not IsValid( self ) then return end

			self:SetCollisionGroup( COLLISION_GROUP_NONE )
		end )

		self.IsEnabled = true

		local pObj = self:GetPhysicsObject()
		
		if not IsValid( pObj ) then
			self:Remove()

			print("LVS: missing model. Missile terminated.")

			return
		end

		pObj:SetMass( 500 ) 
		pObj:EnableGravity( false ) 
		pObj:EnableMotion( true )
		pObj:EnableDrag( false )
		pObj:SetVelocityInstantaneous( self:GetSpeed() )

		self:SetTrigger( true )

		self:StartMotionController()

		self:PhysWake()

		self.SpawnTime = CurTime()

		self:SetActive( true )
	end

	function ENT:PhysicsSimulate( phys, deltatime )
		phys:Wake()

		local ForceLinear = physenv.GetGravity()

		local Pos = self:GetPos()
		local TargetPos = Pos + self:GetVelocity()

		local AngForce = -self:WorldToLocalAngles( (TargetPos - Pos):Angle() )

		local ForceAngle = (Vector(AngForce.r,-AngForce.p,-AngForce.y) * 10 - phys:GetAngleVelocity() * 5 ) * 250 * deltatime

		return ForceAngle, ForceLinear, SIM_GLOBAL_ACCELERATION
	end

	function ENT:Think()	
		local T = CurTime()

		self:NextThink( T )

		self:UpdateTrajectory()

		if not self.SpawnTime then return true end

		if (self.SpawnTime + 12) < T then
			self:Detonate()
		end

		return true
	end

	function ENT:UpdateTrajectory()
		local base = self:GetParent()

		if not IsValid( base ) then return end

		self:SetSpeed( base:GetVelocity() )
	end

	ENT.IgnoreCollisionGroup = {
		[COLLISION_GROUP_NONE] = true,
		[COLLISION_GROUP_WORLD] =  true,
		[COLLISION_GROUP_IN_VEHICLE] = true
	}

	function ENT:StartTouch( entity )
		if entity == self:GetAttacker() then return end

		if istable( self._FilterEnts ) and self._FilterEnts[ entity ] then return end

		if entity.GetCollisionGroup and self.IgnoreCollisionGroup[ entity:GetCollisionGroup() ] then return end

		if entity.lvsProjectile then return end

		self:Detonate( entity )
	end

	function ENT:EndTouch( entity )
	end

	function ENT:Touch( entity )
	end

	function ENT:PhysicsCollide( data )
		if istable( self._FilterEnts ) and self._FilterEnts[ data.HitEntity ] then return end

		self:Detonate( data.HitEntity )
	end

	function ENT:OnTakeDamage( dmginfo )	
	end

	function ENT:Detonate( target )
		if not self.IsEnabled or self.IsDetonated then return end

		self.IsDetonated = true

		local Pos =  self:GetPos() 

		local effectdata = EffectData()
			effectdata:SetOrigin( Pos )
		util.Effect( self.ExplosionEffect, effectdata )

		local attacker = self:GetAttacker()

		LVS:BlastDamage( Pos, self:GetForward(), IsValid( attacker ) and attacker or game.GetWorld(), self, self:GetDamage(), DMG_BLAST, self:GetRadius(), self:GetForce() )

		SafeRemoveEntityDelayed( self, FrameTime() )
	end

	return
end

function ENT:Enable()
	if self.IsEnabled then return end

	self.IsEnabled = true

	self.snd = CreateSound(self, "lvs/weapons/bomb_whistle_loop.wav")
	self.snd:SetSoundLevel( 110 )
	self.snd:PlayEx(0,150)
end

function ENT:CalcDoppler()
	local Ent = LocalPlayer()

	local ViewEnt = Ent:GetViewEntity()

	if Ent:lvsGetVehicle() == self then
		if ViewEnt == Ent then
			Ent = self
		else
			Ent = ViewEnt
		end
	else
		Ent = ViewEnt
	end

	local sVel = self:GetVelocity()
	local oVel = Ent:GetVelocity()

	local SubVel = oVel - sVel
	local SubPos = self:GetPos() - Ent:GetPos()

	local DirPos = SubPos:GetNormalized()
	local DirVel = SubVel:GetNormalized()

	local A = math.acos( math.Clamp( DirVel:Dot( DirPos ) ,-1,1) )

	return (1 + math.cos( A ) * SubVel:Length() / 13503.9)
end

function ENT:Think()
	if self.snd then
		self.snd:ChangePitch( 100 * self:CalcDoppler(), 1 )
		self.snd:ChangeVolume(math.Clamp(-(self:GetVelocity().z + 1000) / 3000,0,1), 2)
	end

	if self.IsEnabled then return end

	if self:GetActive() then
		self:Enable()
	end
end

function ENT:Draw()
	local T = CurTime()

	if not self:GetActive() then
		self._PreventDrawTime = T + 0.1
		return
	end

	if (self._PreventDrawTime or 0) > T then return end

	self:DrawModel()
end

function ENT:SoundStop()
	if self.snd then
		self.snd:Stop()
	end
end

function ENT:OnRemove()
	self:SoundStop()
end

local color_red = Color(255,0,0,255)
local color_red_blocked = Color(100,0,0,255)
local HudTargets = {}
hook.Add( "HUDPaint", "!!!!lvs_bomb_hud", function()
	for ID, _ in pairs( HudTargets ) do
		local Missile = Entity( ID )

		if not IsValid( Missile ) or Missile:GetActive() then
			HudTargets[ ID ] = nil

			continue
		end

		local Grav = physenv.GetGravity()
		local FT = 0.05
		local MissilePos = Missile:GetPos()
		local Pos = MissilePos
		local Vel = Missile:GetSpeed()

		local LastColor = color_red
		local Mask = Missile.GetMaskSolid and (Missile:GetMaskSolid() and MASK_SOLID or MASK_SOLID_BRUSHONLY) or MASK_SOLID_BRUSHONLY

		cam.Start3D()
		local Iteration = 0
		while Iteration < 1000 do
			Iteration = Iteration + 1

			Vel = Vel + Grav * FT

			local StartPos = Pos
			local EndPos = Pos + Vel * FT

			local trace = util.TraceLine( {
				start = StartPos,
				endpos = EndPos,
				mask = Mask,
			} )

			local traceVisible = util.TraceLine( {
				start = MissilePos,
				endpos = StartPos,
				mask = Mask,
			} )

			LastColor = traceVisible.Hit and color_red_blocked or color_red

			render.DrawLine( StartPos, EndPos, LastColor )

			Pos = EndPos

			if trace.Hit then
				break
			end
		end
		cam.End3D()

		local TargetPos = Pos:ToScreen()

		if not TargetPos.visible then continue end

		surface.DrawCircle( TargetPos.x, TargetPos.y, 20, LastColor )
	end
end )

net.Receive( "lvs_bomb_hud", function( len )
	local ent = net.ReadEntity()

	if not IsValid( ent ) then return end

	HudTargets[ ent:EntIndex() ] = true
end )

--addons/egm_lvs_ground/lua/entities/lvs_fakehover_45z/shared.lua:
ENT.Base = "lvs_base_fakehover"

ENT.PrintName = "45-Z Speeder"
ENT.Author = "Deltaa"
ENT.Information = ""
ENT.Category = "[LVS] - Neutral"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/myproject5/mesh_2407.mdl"

ENT.AITEAM = 0

ENT.MaxHealth = 1500

ENT.ForceAngleMultiplier = 2
ENT.ForceAngleDampingMultiplier = 1

ENT.ForceLinearMultiplier = 1
ENT.ForceLinearRate = 0.25

ENT.MaxVelocityX = 750
ENT.MaxVelocityY = 500

ENT.MaxTurnRate = 0.75

ENT.BoostAddVelocityX = 250
ENT.BoostAddVelocityY = 100

ENT.GroundTraceHitWater = true
ENT.GroundTraceLength = 50
ENT.GroundTraceHull = 100

ENT.LAATC_PICKUPABLE = true
ENT.LAATC_PICKUP_POS = Vector(-200, 0, 30)
ENT.LAATC_PICKUP_Angle = Angle(0, 0, 0)

function ENT:OnIsCarried( name, old, new)
	if new == old then return end

	if new then
		self:SetDisabled(true)
	else
		self:SetDisabled(false)
	end
end

function ENT:OnSetupDataTables()
	self:AddDT( "Bool", "IsCarried" )

	if SERVER then
		self:NetworkVarNotify("IsCarried", self.OnIsCarried)
	end
end

function ENT:InitWeapons()
end

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/x-34/engine_loop.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 85,
	}
}
--addons/egm_lvs_ground/lua/entities/lvs_fakehover_aat/sh_turret.lua:

function ENT:SetPoseParameterTurret(weapon)
	if self:GetIsCarried() then
		self:SetPoseParameter("turret_pitch", 0 )
		self:SetPoseParameter("turret_yaw",  0 )

		if self.TurretWasSet then
			self.TurretWasSet = nil

			self:SetTurretPitch( 0 )
			self:SetTurretYaw( 0 )
		end

		return
	end

	self.TurretWasSet = true

	if not IsValid(weapon:GetDriver()) and not weapon:GetAI() then return end

	local AimAng = weapon:WorldToLocal(weapon:GetPos() + weapon:GetAimVector()):Angle()
	AimAng:Normalize()

	local AimRate = self.TurretTurnRate * FrameTime() 

	self:SetTurretPitch( math.ApproachAngle(self:GetTurretPitch(), AimAng.p, AimRate))
	self:SetTurretYaw( math.ApproachAngle(self:GetTurretYaw(), AimAng.y, AimRate))

	self:SetPoseParameter("turret_pitch", self:GetTurretPitch())
	self:SetPoseParameter("turret_yaw", self:GetTurretYaw())
end

function ENT:TraceTurret()
	local ID = self:LookupAttachment( "muzzle" )
	local Muzzle = self:GetAttachment( ID )

	if not Muzzle then return end

	local dir = Muzzle.Ang:Up()
	local pos = Muzzle.Pos

	local trace = util.TraceLine({
		start = pos,
		endpos = pos + dir * 50000,
	})

	return trace
end

function ENT:InitTurret()
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Ammo = -1
	weapon.Delay = 0.3
	weapon.HeatRateUp = 1.25
	weapon.HeatRateDown = 0.2
	weapon.OnOverheat = function( ent )
		ent:EmitSound("lvs/vehicles/aat/overheat.mp3")
	end
	weapon.Attack = function( ent )
		local base = ent:GetVehicle()
		if not IsValid(base) then return end

		if base:GetIsCarried() then return true end

		local ID = base:LookupAttachment("muzzle")
		local Muzzle = base:GetAttachment(ID)

		if not Muzzle then return end

		local bullet = {}
		bullet.Src = Muzzle.Pos
		bullet.Dir = Muzzle.Ang:Up()
		bullet.Spread = Vector(0,0,0)
		bullet.TracerName = "lvs_laser_red_aat"
		bullet.Force = 10
		bullet.HullSize = 30
		bullet.Damage = 1500
		bullet.Velocity = 6000
		bullet.Attacker = ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			dmginfo:SetDamageType(DMG_AIRBOAT)

			local effectdata = EffectData()
			effectdata:SetOrigin(tr.HitPos)
			util.Effect("lvs_laser_explosion_aat", effectdata)
		end
		ent:LVSFireBullet( bullet )

		local effectdata = EffectData()
		effectdata:SetStart( Vector(255,50,50) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( Muzzle.Ang:Up() )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )

		ent:TakeAmmo()

		base:PlayAnimation( "fire" )

		local PhysObj = base:GetPhysicsObject()
		if IsValid( PhysObj ) then
			PhysObj:ApplyForceOffset( -Muzzle.Ang:Up() * 25000, Muzzle.Pos )
		end

		if not IsValid( base.SNDTurret ) then return end

		base.SNDTurret:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
	end
	weapon.OnThink = function( ent, active )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		base:SetPoseParameterTurret( ent )
	end
	weapon.CalcView = function( ent, ply, pos, angles, fov, pod )
		local base = ent:GetVehicle()

		local view = {}
		view.origin = pos
		view.angles = angles
		view.fov = fov
		view.drawviewer = false

		if not IsValid( base ) then return view end

		local ID = base:LookupAttachment( "turret_view" )
		local Att = base:GetAttachment( ID )

		if Att then
			local Pos,_= LocalToWorld( Vector(0,12,30), Angle(0,0,0), Att.Pos, Att.Ang )
			view.origin = Pos
		end

		if not pod:GetThirdPersonMode() then
			return view
		end

		local mn = self:OBBMins()
		local mx = self:OBBMaxs()
		local radius = ( mn - mx ):Length()
		local radius = radius + radius * pod:GetCameraDistance()

		local clamped_angles = pod:WorldToLocalAngles( angles )
		clamped_angles.p = math.max( clamped_angles.p, -20 )
		clamped_angles = pod:LocalToWorldAngles( clamped_angles )

		local StartPos = self:LocalToWorld( Vector(-75,0,140) )
		local EndPos = StartPos - clamped_angles:Forward() * radius + clamped_angles:Up() * radius * 0.2

		local WallOffset = 4

		local tr = util.TraceHull( {
			start = StartPos,
			endpos = EndPos,
			filter = function( e )
				local c = e:GetClass()
				local collide = not c:StartWith( "prop_physics" ) and not c:StartWith( "prop_dynamic" ) and not c:StartWith( "prop_ragdoll" ) and not e:IsVehicle() and not c:StartWith( "gmod_" ) and not c:StartWith( "lvs_" ) and not c:StartWith( "player" ) and not e.LVS

				return collide
			end,
			mins = Vector( -WallOffset, -WallOffset, -WallOffset ),
			maxs = Vector( WallOffset, WallOffset, WallOffset ),
		} )

		view.angles = angles + Angle(5,0,0)
		view.origin = tr.HitPos

		if tr.Hit and  not tr.StartSolid then
			view.origin = view.origin + tr.HitNormal * WallOffset
		end

		return view
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		if base:GetIsCarried() then return end

		local Pos2D = base:TraceTurret().HitPos:ToScreen()

		base:PaintCrosshairCenter( Pos2D, color_white )
		base:PaintCrosshairOuter( Pos2D, color_white )
		base:LVSPaintHitMarker( Pos2D )
	end
	self:AddWeapon(weapon, 2 )
end

--addons/egm_lvs_ground/lua/entities/lvs_fakehover_cagespeeder/shared.lua:
ENT.Base = "lvs_base_fakehover"

ENT.PrintName = "U-29 Cage Speeder"
ENT.Author = "Deltaa"
ENT.Information = ""
ENT.Category = "[LVS] - Neutral"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/myproject1/mesh_0607.mdl"

ENT.AITEAM = 0

ENT.MaxHealth = 4000

ENT.ForceAngleMultiplier = 2
ENT.ForceAngleDampingMultiplier = 1

ENT.ForceLinearMultiplier = 1
ENT.ForceLinearRate = 0.25

ENT.MaxVelocityX = 600
ENT.MaxVelocityY = 500

ENT.MaxTurnRate = 0.8

ENT.BoostAddVelocityX = 100
ENT.BoostAddVelocityY = 50

ENT.GroundTraceHitWater = true
ENT.GroundTraceLength = 50
ENT.GroundTraceHull = 100

ENT.LAATC_PICKUPABLE = true
ENT.LAATC_PICKUP_POS = Vector(-200, 0, 30)
ENT.LAATC_PICKUP_Angle = Angle(0, 0, 0)

function ENT:OnIsCarried( name, old, new)
	if new == old then return end

	if new then
		self:SetDisabled(true)
	else
		self:SetDisabled(false)
	end
end

function ENT:OnSetupDataTables()
	self:AddDT( "Bool", "IsCarried" )

	if SERVER then
		self:NetworkVarNotify("IsCarried", self.OnIsCarried)
	end
end

function ENT:InitWeapons()
	self.FirePositions = {
		Vector(-57, 5, 75),
		Vector(-57, -5, 75)
	}
	-- Primary Gun
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Delay = 0.2
	weapon.HeatRateUp = 0.2
	weapon.HeatRateDown = 0.3
	weapon.Attack = function(ent)
		ent.NumPrim = ent.NumPrim and ent.NumPrim + 1 or 1
		if ent.NumPrim > #ent.FirePositions then ent.NumPrim = 1 end

		local pod = ent:GetDriverSeat()
		if not IsValid(pod) then return end

		local startpos = pod:LocalToWorld(pod:OBBCenter())
		local trace = util.TraceHull({
			start = startpos,
			endpos = startpos + ent:GetForward() * 50000,
			mins = Vector(-10, -10, -10),
			maxs = Vector(10, 10, 10),
			filter = ent:GetCrosshairFilterEnts()
		})

		local CurPos = ent.FirePositions[ent.NumPrim]

		local bullet = {}
		bullet.Src = ent:LocalToWorld(CurPos)
		bullet.Dir = (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread = Vector(0.05,  0.05, 0)
		bullet.TracerName = "lvs_laser_red"
		bullet.Force = 100
		bullet.HullSize = 5
		bullet.Damage = 100
		bullet.Velocity = 40000
		bullet.Attacker = ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			dmginfo:SetDamageType(DMG_AIRBOAT)

			local effectdata = EffectData()
			effectdata:SetStart(Vector(255, 50, 0))
			effectdata:SetOrigin(tr.HitPos)
			effectdata:SetNormal( tr.HitNormal )
			util.Effect("lvs_laser_explosion", effectdata)
		end
		ent:LVSFireBullet(bullet)

		local effectdata = EffectData()
		effectdata:SetStart(Vector(255, 50, 0))
		effectdata:SetOrigin(bullet.Src)
		effectdata:SetNormal(ent:GetForward())
		effectdata:SetEntity(ent)
		util.Effect("lvs_muzzle_colorable", effectdata)

		ent.SNDPrimary:PlayOnce(100 + math.cos(CurTime() + ent:EntIndex() * 1337) * 5 + math.Rand(-1,1), 1)
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/overheat.wav")
	end
	self:AddWeapon(weapon)
end

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/x-34/engine_loop.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 85,
	}
}
--addons/egm_lvs_ground/lua/entities/lvs_fakehover_casus/cl_init.lua:
include("shared.lua")

ENT.EngineColor = Color(0, 65, 161)
ENT.EngineColor2 = Color(69, 0, 130)
ENT.EngineGlow = Material("sprites/light_glow02_add")
ENT.EnginePos = {
	Vector(-33, 0, 17),
}

function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	local Size = 30 + self:GetThrottle() * 40

	render.SetMaterial(self.EngineGlow)
	for _, pos in pairs(self.EnginePos) do
		render.DrawSprite(self:LocalToWorld(pos), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(pos), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(pos), Size, Size, self.EngineColor)

		render.DrawSprite(self:LocalToWorld(pos), 16, 16, self.EngineColor2)
		render.DrawSprite(self:LocalToWorld(pos), 12, 12, self.EngineColor2)

		render.DrawSprite(self:LocalToWorld(pos), 16, 16, self.EngineColor2)
		render.DrawSprite(self:LocalToWorld(pos), 12, 12, self.EngineColor2)
	end
end

function ENT:DamageFX()
	local HP = self:GetHP()
	if HP == 0 or HP > self:GetMaxHP() * 0.5 then return end

	self.nextDFX = self.nextDFX or 0

	if self.nextDFX < CurTime() then
		self.nextDFX = CurTime() + 0.05

		local effectdata = EffectData()
		effectdata:SetOrigin( self:LocalToWorld( Vector(-90,0,40) ) )
		util.Effect( "lfs_blacksmoke", effectdata )
	end
end
--addons/egm_lvs_ground/lua/entities/lvs_fakehover_czerka/shared.lua:
ENT.Base = "lvs_base_fakehover"

ENT.PrintName = "Czerka Speeder"
ENT.Author = "Deltaa"
ENT.Information = ""
ENT.Category = "[LVS] - Neutral"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/myproject5/mesh_2353.mdl"

ENT.AITEAM = 0

ENT.MaxHealth = 1750

ENT.ForceAngleMultiplier = 2
ENT.ForceAngleDampingMultiplier = 1

ENT.ForceLinearMultiplier = 1
ENT.ForceLinearRate = 0.25

ENT.MaxVelocityX = 600
ENT.MaxVelocityY = 500

ENT.MaxTurnRate = 0.8

ENT.BoostAddVelocityX = 100
ENT.BoostAddVelocityY = 50

ENT.GroundTraceHitWater = true
ENT.GroundTraceLength = 50
ENT.GroundTraceHull = 100

ENT.LAATC_PICKUPABLE = true
ENT.LAATC_PICKUP_POS = Vector(-200, 0, 30)
ENT.LAATC_PICKUP_Angle = Angle(0, 0, 0)

function ENT:OnIsCarried( name, old, new)
	if new == old then return end

	if new then
		self:SetDisabled(true)
	else
		self:SetDisabled(false)
	end
end

function ENT:OnSetupDataTables()
	self:AddDT( "Bool", "IsCarried" )

	if SERVER then
		self:NetworkVarNotify("IsCarried", self.OnIsCarried)
	end
end

function ENT:InitWeapons()
end

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/x-34/engine_loop.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 85,
	}
}
--addons/egm_lvs_ground/lua/entities/lvs_fakehover_hammerhead/cl_init.lua:
include("shared.lua")

ENT.EngineColor = Color(81, 0, 255, 254)
ENT.EngineColor2 = Color(255, 4, 0)
ENT.EngineGlow = Material("sprites/light_glow02_add")
ENT.EnginePos = {
	Vector(-95, 16, 40),
	Vector(-95, -16, 40)
}

function ENT:DamageFX()
	local HP = self:GetHP()
	if HP == 0 or HP > self:GetMaxHP() * 0.5 then return end

	self.nextDFX = self.nextDFX or 0

	if self.nextDFX < CurTime() then
		self.nextDFX = CurTime() + 0.05

		local effectdata = EffectData()
		effectdata:SetOrigin( self:LocalToWorld( Vector(-90,0,40) ) )
		util.Effect( "lfs_blacksmoke", effectdata )
	end
end

function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	local Size = 40 + self:GetThrottle() * 20

	render.SetMaterial(self.EngineGlow)
	for _, pos in pairs(self.EnginePos) do
		render.DrawSprite(self:LocalToWorld(pos), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(pos), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(pos), Size, Size, self.EngineColor)

		render.DrawSprite(self:LocalToWorld(pos), 16, 16, self.EngineColor2)
		render.DrawSprite(self:LocalToWorld(pos), 12, 12, self.EngineColor2)

		render.DrawSprite(self:LocalToWorld(pos), 16, 16, self.EngineColor2)
		render.DrawSprite(self:LocalToWorld(pos), 12, 12, self.EngineColor2)
	end
end


function ENT:CalcViewOverride(ply, pos, angles, fov, pod)
	if ply == self:GetDriver() and not pod:GetThirdPersonMode() then
		return pos +  self:GetUp() * 30, angles, fov
	end

	return pos, angles, fov
end
--addons/egm_lvs_ground/lua/entities/lvs_fakehover_hammerhead/shared.lua:
ENT.Base = "lvs_base_fakehover"

ENT.PrintName = "Hammerhead Speeder"
ENT.Author = "Deltaa"
ENT.Information = ""
ENT.Category = "[LVS] - Neutral"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/myproject5/mesh_2352.mdl"

ENT.AITEAM = 0

ENT.MaxHealth = 3500

ENT.ForceAngleMultiplier = 2
ENT.ForceAngleDampingMultiplier = 1

ENT.ForceLinearMultiplier = 1
ENT.ForceLinearRate = 0.25

ENT.MaxVelocityX = 600
ENT.MaxVelocityY = 500

ENT.MaxTurnRate = 0.8

ENT.BoostAddVelocityX = 100
ENT.BoostAddVelocityY = 50

ENT.GroundTraceHitWater = true
ENT.GroundTraceLength = 50
ENT.GroundTraceHull = 100

ENT.LAATC_PICKUPABLE = true
ENT.LAATC_PICKUP_POS = Vector(-200, 0, 30)
ENT.LAATC_PICKUP_Angle = Angle(0, 0, 0)

function ENT:OnIsCarried( name, old, new)
	if new == old then return end

	if new then
		self:SetDisabled(true)
	else
		self:SetDisabled(false)
	end
end

function ENT:OnSetupDataTables()
	self:AddDT( "Bool", "IsCarried" )

	if SERVER then
		self:NetworkVarNotify("IsCarried", self.OnIsCarried)
	end
end

function ENT:InitWeapons()
	-- Primary Gun
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Delay = 0.2
	weapon.HeatRateUp = 0.2
	weapon.HeatRateDown = 0.3
	weapon.Attack = function(ent)
		local pod = ent:GetDriverSeat()
		if not IsValid(pod) then return end

		local startpos = pod:LocalToWorld(pod:OBBCenter())
		local trace = util.TraceHull({
			start = startpos,
			endpos = startpos + ent:GetForward() * 50000,
			mins = Vector(-10, -10, -10),
			maxs = Vector(10, 10, 10),
			filter = ent:GetCrosshairFilterEnts()
		})

		local bullet = {}
		bullet.Src = ent:LocalToWorld(Vector(Vector(73, 0, 50)))
		bullet.Dir = (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread = Vector(0.05,  0.05, 0)
		bullet.TracerName = "lvs_laser_red"
		bullet.Force = 100
		bullet.HullSize = 10
		bullet.Damage = 100
		bullet.Velocity = 40000
		bullet.Attacker = ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			dmginfo:SetDamageType(DMG_AIRBOAT)

			local effectdata = EffectData()
			effectdata:SetStart(Vector(255, 50, 0))
			effectdata:SetOrigin(tr.HitPos)
			effectdata:SetNormal( tr.HitNormal )
			util.Effect("lvs_laser_explosion", effectdata)
		end
		ent:LVSFireBullet(bullet)

		local effectdata = EffectData()
		effectdata:SetStart(Vector(255, 50, 0))
		effectdata:SetOrigin(bullet.Src)
		effectdata:SetNormal(ent:GetForward())
		effectdata:SetEntity(ent)
		util.Effect("lvs_muzzle_colorable", effectdata)

		ent.SNDPrimary:PlayOnce(100 + math.cos(CurTime() + ent:EntIndex() * 1337) * 5 + math.Rand(-1,1), 1)
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/overheat.wav")
	end
	self:AddWeapon(weapon)
end

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/x-34/engine_loop.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 85,
	}
}
--addons/egm_lvs_ground/lua/entities/lvs_fakehover_sanctum/cl_init.lua:
include("shared.lua")

ENT.EngineColor = Color(255, 0, 0, 254)
ENT.EngineColor2 = Color(43, 255, 0)
ENT.EngineGlow = Material("sprites/light_glow02_add")
ENT.EnginePos = {
	Vector(-34, 0, 17)
}

function ENT:DamageFX()
	local HP = self:GetHP()
	if HP == 0 or HP > self:GetMaxHP() * 0.5 then return end

	self.nextDFX = self.nextDFX or 0

	if self.nextDFX < CurTime() then
		self.nextDFX = CurTime() + 0.05

		local effectdata = EffectData()
		effectdata:SetOrigin( self:LocalToWorld( Vector(-90,0,40) ) )
		util.Effect( "lfs_blacksmoke", effectdata )
	end
end

function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	local Size = 10 + self:GetThrottle() * 20

	render.SetMaterial(self.EngineGlow)
	for _, pos in pairs(self.EnginePos) do
		render.DrawSprite(self:LocalToWorld(pos), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(pos), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(pos), Size, Size, self.EngineColor)

		render.DrawSprite(self:LocalToWorld(pos), 16, 16, self.EngineColor2)
		render.DrawSprite(self:LocalToWorld(pos), 12, 12, self.EngineColor2)

		render.DrawSprite(self:LocalToWorld(pos), 16, 16, self.EngineColor2)
		render.DrawSprite(self:LocalToWorld(pos), 12, 12, self.EngineColor2)
	end
end
--addons/egm_lvs_ground/lua/entities/lvs_fakehover_sanctum/shared.lua:
ENT.Base = "lvs_base_fakehover"

ENT.PrintName = "Sanctum Speeder"
ENT.Author = "Deltaa"
ENT.Information = ""
ENT.Category = "[LVS] - Neutral"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/myproject5/mesh_2355.mdl"

ENT.AITEAM = 0

ENT.MaxHealth = 1500

ENT.ForceAngleMultiplier = 2
ENT.ForceAngleDampingMultiplier = 1

ENT.ForceLinearMultiplier = 1
ENT.ForceLinearRate = 0.25

ENT.MaxVelocityX = 500
ENT.MaxVelocityY = 400

ENT.MaxTurnRate = 0.75

ENT.BoostAddVelocityX = 100
ENT.BoostAddVelocityY = 50

ENT.GroundTraceHitWater = true
ENT.GroundTraceLength = 50
ENT.GroundTraceHull = 100

ENT.LAATC_PICKUPABLE = true
ENT.LAATC_PICKUP_POS = Vector(-200, 0, 30)
ENT.LAATC_PICKUP_Angle = Angle(0, 0, 0)

function ENT:OnIsCarried( name, old, new)
	if new == old then return end

	if new then
		self:SetDisabled(true)
	else
		self:SetDisabled(false)
	end
end

function ENT:OnSetupDataTables()
	self:AddDT( "Bool", "IsCarried" )

	if SERVER then
		self:NetworkVarNotify("IsCarried", self.OnIsCarried)
	end
end

function ENT:InitWeapons()
end

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/x-34/engine_loop.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 85,
	}
}
--addons/egm_lvs_ground/lua/entities/lvs_fakehover_scavenger/cl_init.lua:
include("shared.lua")

ENT.EngineColor = Color(255, 123, 0)
ENT.EngineColor2 = Color(251, 255, 0)
ENT.EngineGlow = Material("sprites/light_glow02_add")
ENT.EnginePos = {
	Vector(-105, 51, 22),
	Vector(-105, -51, 22)
}

function ENT:DamageFX()
	local HP = self:GetHP()
	if HP == 0 or HP > self:GetMaxHP() * 0.5 then return end

	self.nextDFX = self.nextDFX or 0

	if self.nextDFX < CurTime() then
		self.nextDFX = CurTime() + 0.05

		local effectdata = EffectData()
		effectdata:SetOrigin(self:LocalToWorld(Vector(-90, 0, 40)))
		util.Effect("lfs_blacksmoke", effectdata)
	end
end

function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	local Size = 80 + self:GetThrottle() * 40

	render.SetMaterial(self.EngineGlow)
	for _, pos in pairs(self.EnginePos) do
		render.DrawSprite(self:LocalToWorld(pos), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(pos), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(pos), Size, Size, self.EngineColor)

		render.DrawSprite(self:LocalToWorld(pos), 16, 16, self.EngineColor2)
		render.DrawSprite(self:LocalToWorld(pos), 12, 12, self.EngineColor2)

		render.DrawSprite(self:LocalToWorld(pos), 16, 16, self.EngineColor2)
		render.DrawSprite(self:LocalToWorld(pos), 12, 12, self.EngineColor2)
	end
end

function ENT:CalcViewOverride(ply, pos, angles, fov, pod)
	if ply == self:GetDriver() and not pod:GetThirdPersonMode() then
		return pos + self:GetForward() * 20, angles, fov
	end

	return pos, angles, fov
end
--addons/egm_lvs_ground/lua/entities/lvs_fakehover_tx130/cl_prediction.lua:
function ENT:PredictPoseParamaters()
	local pod = self:GetGunnerSeat()
	if not IsValid(pod) then return end

	if not self:CanUseBTL() then return end

	local plyL = LocalPlayer()
	local ply = pod:GetDriver()

	if ply ~= plyL then return end

	self:SetPoseParameterBTL(pod:lvsGetWeapon())

	self:InvalidateBoneCache()
end
--addons/egm_lvs_ships/lua/entities/lvs_jack_senatepod/shared.lua:
ENT.Base = "lvs_base_repulsorlift"

ENT.PrintName = "Senate Pod"
ENT.Author = "Pudding"
ENT.Information = "LFS version created by Jack and LVS port done by Tic"
ENT.Category = "[LVS] - Republik"

ENT.Spawnable = true
ENT.AdminSpawnable = false

ENT.MDL = "models/jackjack/ships/senatepod.mdl"
ENT.GibModels = {
	"models/jackjack/ships/senatepod.mdl"
}

ENT.AITEAM = 2

ENT.MaxVelocity = 150
ENT.MaxThrust = 10000

ENT.ThrustVtol = 25
ENT.ThrustRateVtol = 2

ENT.TurnRatePitch = 0
ENT.TurnRateYaw = 1
ENT.TurnRateRoll = 0

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 10000
ENT.MaxShield = 0

ENT.AutomaticFrameAdvance = true

function ENT:AddDataTables()
	self:NetworkVar( "Bool",20, "IsCarried" )
	--self:NetworkVar( "Bool",21, "FrontInRange" )
	--self:NetworkVar( "Bool",22, "RearInRange" )
	if SERVER then
		self:NetworkVarNotify( "IsCarried", self.OnIsCarried )
	end
end
--addons/egm_lvs_ships/lua/entities/lvs_repulsorlift_airspeeder/shared.lua:
ENT.Base = "lvs_base_repulsorlift"

ENT.PrintName = "Airspeeder"
ENT.Author = "Miller"
ENT.Information = ""
ENT.Category = "[LVS] - Neutral"

ENT.Spawnable = true
ENT.AdminSpawnable = false

ENT.MDL = "models/starwars/syphadias/ships/organa_xj2/organa_xj2.mdl"

ENT.AITEAM = 0

ENT.MaxVelocity = 2000
ENT.MaxThrust = 2000

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3

ENT.TurnRatePitch = 1
ENT.TurnRateYaw = 1
ENT.TurnRateRoll = 1

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1.5
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 6000
ENT.MaxShield = 0

function ENT:InitWeapons()
	self:AddWeapon(LVS:GetWeaponPreset("TURBO"))
end

ENT.FlyByAdvance = 0.5
ENT.FlyBySound = "lvs/vehicles/airspeeder/flyby.wav"
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/airspeeder/distantloop.wav",
		sound_int = "^lvs/vehicles/airspeeder/closeloop.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
}


--addons/egm_lvs_ships/lua/entities/lvs_repulsorlift_gunship/cl_spotlights.lua:
function ENT:DrawSpotlights()
	if not self:IsSpotlightMounted() or not self:GetLightsActive() then
		self:RemoveLight()
		return
	end

	if not IsValid(self.projector_L) then
		self.projector_L, self.projector_LID = self:CreateSpotlight(), self:LookupAttachment("L_Spotlight_End")
	end

	self:UpdateSpotlight(self.projector_L, self.projector_LID)

	if not IsValid(self.projector_R) then
		self.projector_R, self.projector_RID = self:CreateSpotlight(), self:LookupAttachment("R_Spotlight_End")
	end

	self:UpdateSpotlight(self.projector_R, self.projector_RID)
end

function ENT:RemoveLight()
	if IsValid(self.projector_L) then
		self.projector_L:Remove()
		self.projector_L = nil
	end

	if IsValid(self.projector_R) then
		self.projector_R:Remove()
		self.projector_R = nil
	end
end


function ENT:UpdateSpotlight(ent, attachmentID)
	local muzzle = self:GetAttachment(attachmentID)
	local StartPos = muzzle.Pos
	local Dir = muzzle.Ang:Right()

	local spotlight = Material("effects/lfs_base/spotlight_projectorbeam")
	local glow_color = Color(255, 255, 255, 10)

	render.SetMaterial(self.EngineGlow)
	render.DrawSprite(StartPos + Dir * 20, 400, 400, color_white)

	render.SetMaterial(spotlight)
	render.DrawBeam(StartPos - Dir * 10, StartPos + Dir * 1500, 350, 0, 0.99, glow_color)

	if IsValid(ent) then
		ent:SetPos(StartPos)
		ent:SetAngles(Dir:Angle())
		ent:Update()
	end
end

function ENT:CreateSpotlight()
	local spotlight = ProjectedTexture()
	spotlight:SetBrightness(10)
	spotlight:SetTexture("effects/flashlight/soft")
	spotlight:SetColor(color_white)
	spotlight:SetEnableShadows(false)
	spotlight:SetFarZ(5000)
	spotlight:SetNearZ(75)
	spotlight:SetFOV(40)

	return spotlight
end

function ENT:OnRemove()
	self:RemoveLight()
end
--addons/egm_lvs_ships/lua/entities/lvs_repulsorlift_gunship_aarc/shared.lua:
ENT.Base = "lvs_repulsorlift_gunship"

ENT.PrintName = "Muunilinst 10 LAAT/i"
ENT.Author = "Deltaa"
ENT.Information = "Gunship/Troop Transport of the Galactic Republic"
ENT.Category = "[LVS] - Republik"

ENT.IsLAAT = true

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/fisher/laat/laatspacem10.mdl"

function ENT:InitDriverWeapons()
	self.FirePositions = {
		Vector(432, 34, 36),
		Vector(432, -34, 36)
	}

	-- Primary Gun
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Delay = 0.15
	weapon.HeatRateUp = 0.1
	weapon.HeatRateDown = 0.1
	weapon.Attack = function(ent)
		ent.NumPrim = ent.NumPrim and ent.NumPrim + 1 or 1
		if ent.NumPrim > #ent.FirePositions then ent.NumPrim = 1 end

		local pod = ent:GetDriverSeat()
		if not IsValid(pod) then return end

		local startpos = pod:LocalToWorld(pod:OBBCenter())
		local trace = util.TraceHull( {
			start = startpos,
			endpos = startpos + ent:GetForward() * 50000,
			mins = Vector(-10, -10, -10),
			maxs = Vector(10, 10, 10),
			filter = ent:GetCrosshairFilterEnts()
		})

		local CurPos = ent.FirePositions[ent.NumPrim]

		local bullet = {}
		bullet.Src = ent:LocalToWorld(CurPos)
		bullet.Dir = (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread = Vector(0.05,  0.05, 0)
		bullet.TracerName = "lvs_laser_blue"
		bullet.Force = 100
		bullet.HullSize = 10
		bullet.Damage = 100
		bullet.Velocity = 50000
		bullet.Attacker = ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			dmginfo:SetDamageType(DMG_AIRBOAT)

			local effectdata = EffectData()
			effectdata:SetStart(Vector(0, 0, 255))
			effectdata:SetOrigin(tr.HitPos)
			effectdata:SetNormal( tr.HitNormal )
			util.Effect("lvs_laser_explosion", effectdata)
		end
		ent:LVSFireBullet(bullet)

		local effectdata = EffectData()
		effectdata:SetStart(Vector(0, 0, 255))
		effectdata:SetOrigin(bullet.Src)
		effectdata:SetNormal(ent:GetForward())
		effectdata:SetEntity(ent)
		util.Effect("lvs_muzzle_colorable", effectdata)

		ent:TakeAmmo()

		ent.PrimarySND:PlayOnce(100 + math.cos(CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1)
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/overheat.wav")
	end
	self:AddWeapon(weapon)

	-- Proton Torpedo
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/protontorpedo.png")
	weapon.Ammo = 24
	weapon.Delay = 0.25
	weapon.HeatRateUp = 0.75
	weapon.HeatRateDown = 0.1
	weapon.Attack = function(ent)
		if IsValid(ent._ProtonTorpedo) then
			if ent._nextMissleTracking and ent._nextMissleTracking > CurTime() then return end
			ent._nextMissleTracking = CurTime() + 0.1

			ent._ProtonTorpedo:FindTarget(ent:GetPos(), ent:GetForward(), 30, 7500)
			return
		end

		if ent._nextMissle and ent._nextMissle > CurTime() then return end
		ent._nextMissle = CurTime() + 0.5

		ent._swapMissile = not ent._swapMissile

		self.RocketsModel:ResetSequence("Load_Missile")

		local Pos = Vector(150, ent._swapMissile and -70 or 70, 275)
		local Driver = self:GetDriver()

		local projectile = ents.Create("lvs_protontorpedo")
		projectile:SetPos(ent:LocalToWorld(Pos) )
		projectile:SetAngles(ent:LocalToWorldAngles( Angle(0,ent._swapMissile and 2 or -2,0) ) )
		projectile:SetParent(ent)
		projectile:Spawn()
		projectile:Activate()
		projectile:SetAttacker(IsValid( Driver ) and Driver or self)
		projectile:SetDamage(8000)
		projectile:SetEntityFilter(ent:GetCrosshairFilterEnts())
		projectile:SetSpeed(ent:GetVelocity():Length() + 4000)

		ent._ProtonTorpedo = projectile

		ent:SetNextAttack(CurTime() + 0.1) -- wait 0.1 second before starting to track
	end
	weapon.FinishAttack = function( ent )
		if not IsValid(ent._ProtonTorpedo) then return end

		local projectile = ent._ProtonTorpedo
		projectile:Enable()
		projectile:EmitSound("lvs/vehicles/naboo_n1_starfighter/proton_fire.mp3", 125)
		ent:TakeAmmo()

		ent._ProtonTorpedo = nil
	end
	weapon.OnSelect = function(ent)
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/overheat.wav")
	end
	self:AddWeapon( weapon )

	-- Opens / Close the door
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/gunship_sidedoor.png")
	weapon.Ammo = -1
	weapon.Delay = 0
	weapon.HeatRateUp = 0
	weapon.HeatRateDown = 0
	weapon.StartAttack = function(ent)
		if ent.NextDoor and ent.NextDoor > CurTime() then return end
		ent.NextDoor = CurTime() + 1

		-- Sets the door mode
		local DoorMode = self:GetDoorMode() + 1
		DoorMode = DoorMode >= 2 and 0 or DoorMode
		self:SetDoorMode(DoorMode)

		if DoorMode == 0 then
			self:ResetSequence(self.closeSequence)
			self:SetPlaybackRate(1.5)

			local bonePos, _ = self:GetBonePosition(self:LookupBone("LAAT"))

			for doorID, _ in pairs(self.DoorsToClose) do
				local doorData = self.Doors[doorID]
				local offset = self:GetRight() * doorData.closeoffset.x + self:GetForward() * doorData.closeoffset.y + self:GetUp() * doorData.closeoffset.z
				doorData.ent:SetParent(nil)
				doorData.ent:SetPos(bonePos + offset)
				doorData.ent:SetParent(self)
			end

			timer.Simple(0.75, function()
				if not IsValid(self) then return end
				self:EmitSound("laat_bf2/door_close.mp3")

				if not self.IsHatchOpen then
					self:TurnLightRed()
				end
			end)
		end

		if DoorMode == 1 then
			if self:IsSpotlightMounted() then
				self:ResetSequence("Door_Open_Half")
				self.closeSequence = "Door_Closed_Half"

				local bonePos = self:GetBonePosition(self:LookupBone("LAAT"))
				local doorData = self.Doors["L_Door2"]
				local offset = self:GetRight() * doorData.openoffsethalf.x + self:GetForward() * doorData.openoffsethalf.y + self:GetUp() * doorData.openoffsethalf.z
				doorData.ent:SetParent(nil)
				doorData.ent:SetPos(bonePos + offset)
				doorData.ent:SetParent(self)

				local doorData = self.Doors["R_Door2"]
				local offset = self:GetRight() * doorData.openoffsethalf.x + self:GetForward() * doorData.openoffsethalf.y + self:GetUp() * doorData.openoffsethalf.z
				doorData.ent:SetParent(nil)
				doorData.ent:SetPos(bonePos + offset)
				doorData.ent:SetParent(self)

				self.DoorsToClose = {
					["L_Door2"] = true,
					["R_Door2"] = true,
				}
			else
				self:ResetSequence("Door_Open_Both")
				self.closeSequence = "Door_Closed_Both"

				local bonePos = self:GetBonePosition(self:LookupBone("LAAT"))

				local doorData = self.Doors["L_Door2"]
				local offset = self:GetRight() * doorData.openoffsetboth.x + self:GetForward() * doorData.openoffsetboth.y + self:GetUp() * doorData.openoffsetboth.z
				doorData.ent:SetParent(nil)
				doorData.ent:SetPos(bonePos + offset)
				doorData.ent:SetParent(self)

				local doorData = self.Doors["L_Door1"]
				local offset = self:GetRight() * doorData.openoffsetboth.x + self:GetForward() * doorData.openoffsetboth.y + self:GetUp() * doorData.openoffsetboth.z
				doorData.ent:SetParent(nil)
				doorData.ent:SetPos(bonePos + offset)
				doorData.ent:SetParent(self)

				local doorData = self.Doors["R_Door2"]
				local offset = self:GetRight() * doorData.openoffsetboth.x + self:GetForward() * doorData.openoffsetboth.y + self:GetUp() * doorData.openoffsetboth.z
				doorData.ent:SetParent(nil)
				doorData.ent:SetPos(bonePos + offset)
				doorData.ent:SetParent(self)

				local doorData = self.Doors["R_Door1"]
				local offset = self:GetRight() * doorData.openoffsetboth.x + self:GetForward() * doorData.openoffsetboth.y + self:GetUp() * doorData.openoffsetboth.z
				doorData.ent:SetParent(nil)
				doorData.ent:SetPos(bonePos + offset)
				doorData.ent:SetParent(self)

				self.DoorsToClose = {
					["L_Door2"] = true,
					["L_Door1"] = true,
					["R_Door2"] = true,
					["R_Door1"] = true,
				}
			end

			self:EmitSound("laat_bf2/door_open.mp3")

			self:TurnLightGreen()
		end

		ent:OnDoorsChanged()
	end
	self:AddWeapon(weapon)

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/gunship_reardoor.png")
	weapon.Ammo = -1
	weapon.Delay = 0
	weapon.HeatRateUp = 0
	weapon.HeatRateDown = 0
	weapon.StartAttack = function(ent)
		if ent.NextDoor and ent.NextDoor > CurTime() then return end
		ent.NextDoor = CurTime() + 2

		self:ToggleHatch()
	end

	self:AddWeapon(weapon)
end

function ENT:InitGunnerWeapons()
	-- Rear Gun
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Delay = 0.2
	weapon.HeatRateUp = 0.1
	weapon.HeatRateDown = 0.2
	weapon.Attack = function(ent)
		if not self:CanFireRearGun(ent) then return end

		local trace = ent:GetEyeTrace()
		local Muzzle = self:GetBonePosition(self:LookupBone("Rear_Gun_End"))

		local bullet = {}
		bullet.Src = Muzzle
		bullet.Dir = (trace.HitPos - Muzzle):GetNormalized()
		bullet.Spread = Vector(0.03,  0.03, 0.03)
		bullet.TracerName = "lvs_laser_blue"
		bullet.Force = 10
		bullet.HullSize = 25
		bullet.Damage = 65
		bullet.Velocity = 30000
		bullet.Attacker = ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
			effectdata:SetStart(Vector(0, 0, 255))
			effectdata:SetOrigin(tr.HitPos)
			effectdata:SetNormal(tr.HitNormal)
			util.Effect("lvs_laser_impact", effectdata)
		end
		ent:LVSFireBullet( bullet )

		self.SNDTail:PlayOnce(100 + math.cos( CurTime() + self:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1)
	end
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/overheat.wav")
	end
	weapon.OnThink = function(ent, active)
		if not self:CanFireRearGun(ent) then
			self:SetPoseParameter("back_turret_z", 0)
			self:SetPoseParameter("back_turret_y", 0)
			return
		end

		local trace = ent:GetEyeTrace()
		local _, Ang = WorldToLocal(Vector(0,0,0), (trace.HitPos - self:LocalToWorld( Vector(-400,0,158.5))):GetNormalized():Angle(), Vector(0,0,0), self:LocalToWorldAngles(Angle(0,180,0)))

		self:SetPoseParameter("back_turret_z", Ang.p)
		self:SetPoseParameter("back_turret_y", -Ang.y)
	end
	weapon.CalcView = function(ent, ply, pos, angles, fov, pod)
		return self:GunnerCalcView(ent, ply, pos, angles, fov, pod)
	end
	self:AddWeapon(weapon, 2)

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/laserbeam.png")
	weapon.Ammo = -1
	weapon.Delay = 0
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/overheat.wav")
	end
	weapon.StartAttack = function(ent)
		ent.ShouldFire = true
	end
	weapon.FinishAttack = function(ent)
		ent.ShouldFire = false

		local snd = {
			[-1] = self.WingLeftSND,
			[1] = self.WingRightSND,
		}

		for _, sound in pairs(snd) do
			if not IsValid(sound) then continue end

			sound:Stop()
		end
	end
	weapon.OnThink = function(ent, active)
		local snd = {
			[-1] = self.WingLeftSND,
			[1] = self.WingRightSND
		}

		local shouldFire = self:CanFireWingTurret(ent) and ent.ShouldFire
		if not shouldFire then
			self:SetWingTurretFire(false)

			for _, sound in pairs(snd) do
				if not IsValid(sound) then continue end
				sound:Stop()
			end

			ent:SetHeat(ent:GetHeat() - FrameTime())

			return
		end

		if not active then return end

		self:SetWingTurretFire(shouldFire)

		local trace = ent:GetEyeTrace()
		local endPos = trace.HitPos

		self:SetWingTurretTarget(endPos)

		local startPos = Vector(-55, 350, 90)
		if self:WorldToLocal(endPos).z > 0 then
			startPos = Vector(-55, 370, 125)
		end

		local NewHeat = ent:GetHeat()
		for i = -1, 1, 2 do
			local StartPos = self:LocalToWorld(startPos * Vector(1, i, 1))
			local beam = util.TraceLine({start = StartPos, endpos = endPos})

			self:BallturretDamage(beam.Entity, ent:GetDriver(), trace.HitPos, (trace.HitPos - StartPos):GetNormalized())

			if not IsValid(snd[i]) then continue end

			if beam.Entity ~= self then
				snd[i]:Play()

				NewHeat = NewHeat + FrameTime() * 0.25
			else
				snd[i]:Stop()
			end
		end

		ent:SetHeat(NewHeat)
		if NewHeat >= 1 then
			ent:SetOverheated(true)
		end
	end
	weapon.CalcView = function(ent, ply, pos, angles, fov, pod)
		return self:GunnerCalcView(ent, ply, pos, angles, fov, pod)
	end
	self:AddWeapon(weapon, 2)

	-- Bombs
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/bomb.png")
	weapon.Ammo = 20
	weapon.Delay = 0
	weapon.HeatRateUp = -1
	weapon.Attack = function(ent)
		if ent.NextBomb and ent.NextBomb > CurTime() then return end
		ent.NextBomb = CurTime() + 2
		local base = ent:GetVehicle()
		if not IsValid(base) then return end

		local pos = base:GetBonePosition(base:LookupBone("Rear_Bomb_Hatch"))

		local bomb = ents.Create("laat_detonator")
		bomb:SetPos(pos)
		bomb:SetAngles(self:GetAngles())
		bomb:Spawn()
		bomb:Activate()
		bomb.Attacker = self:GetDriver()
		bomb.Inflictor = self
		bomb:SetVelocity(self:GetVelocity())

		ent:TakeAmmo()

		constraint.NoCollide(ent, base, 0, 0)
	end
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/overheat.wav")
	end
	weapon.CalcView = function(ent, ply, pos, angles, fov, pod)
		return self:GunnerCalcView(ent, ply, pos, angles, fov, pod)
	end
	self:AddWeapon(weapon, 2)
end
--addons/egm_lvs_ships/lua/entities/lvs_repulsorlift_gunship_carrier/cl_init.lua:
include("shared.lua")

function ENT:CalcViewOverride( ply, pos, angles, fov, pod )
	if pod == self:GetDriverSeat() then

		if pod:GetThirdPersonMode() then
			pos = pos + self:GetUp() * 50, angles, fov
		end

		return pos, angles, fov
	end

	return pos, angles, fov
end

function ENT:OnSpawn()
	self:RegisterTrail(Vector(-150, 500, 30), 5, 50, 2, 100, 130)
	self:RegisterTrail(Vector(-150, -500, 30), 5, 50, 2, 100, 130)
end

function ENT:OnFrame()
	local HeldEntity = self:GetHeldEntity()

	local IsHeld = IsValid( HeldEntity )

	if IsHeld ~= self._oldHeldEntity then
		self._oldHeldEntity = IsHeld

		if IsHeld then
			self:BuildFilter()
		else
			self:ResetFilters()
		end
	end
end

function ENT:OnStartBoost()
	self:EmitSound( "^lvs/vehicles/laat/boost_"..math.random(1,2)..".wav", 85 )
end

function ENT:OnStopBoost()
end

--addons/egm_lvs_ships/lua/entities/lvs_starfighter_delta7/cl_init.lua:
include("shared.lua")

ENT.EngineGlow = Material("sprites/light_glow02_add")

function ENT:OnSpawn()
	self:RegisterTrail(Vector(-100, 20, 10), 0, 20, 2, 1000, 150)
	self:RegisterTrail(Vector(-100, -20, 10), 0, 20, 2, 1000, 150)
end

function ENT:OnFrame()
	self:AnimAstromech()
end

function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	local Size = 120 + self:GetThrottle() * 40 + self:GetBoost() * 0.8
	render.SetMaterial(self.EngineGlow)
	render.DrawSprite(self:LocalToWorld( Vector(-130,-21,23.2) ), Size, Size, Color( 255, 240, 130, 255))
	render.DrawSprite(self:LocalToWorld( Vector(-130,21,23.2) ), Size, Size, Color( 255, 240, 130, 255))
	render.DrawSprite(self:LocalToWorld( Vector(-130,-21,23.2) ), Size, Size, Color( 255, 240, 150, 255))
	render.DrawSprite(self:LocalToWorld( Vector(-130,21,23.2) ), Size, Size, Color( 255, 240, 150, 255))
end

function ENT:AnimAstromech()
	local T = CurTime()

	if (self.nextAstro or 0) < T then
		self.nextAstro = T + math.Rand(0.5,2)
		self.AstroAng = math.Rand(-180,180)

		local HasShield = self:GetShield() > 0

		if self.OldShield == true and not HasShield then
			self:EmitSound("lvs/vehicles/naboo_n1_starfighter/astromech/shieldsdown" .. math.random(1,2) .. ".ogg", 50)
		else
			if math.random(0, 4) == 3 then
				self:EmitSound("lvs/vehicles/naboo_n1_starfighter/astromech/"..math.random(1,11) .. ".ogg", 50)
			end
		end


		self.OldShield = HasShield
	end

	self.smastro = self.smastro and (self.smastro + ((self.AstroAng or 0) - self.smastro) * RealFrameTime() * 10) or 0

	self:ManipulateBoneAngles(1, Angle(self.smastro, 0, 0))
end

function ENT:OnStartBoost()
	self:EmitSound("lvs/vehicles/delta-7/boost.wav", 85)
end
--addons/egm_lvs_ships/lua/entities/lvs_starfighter_delta7b/shared.lua:
ENT.Base = "lvs_base_starfighter"

ENT.PrintName = "Delta-7b Starfighter"
ENT.Author = "Deltaa"
ENT.Information = "The Delta-7b Jedi starfighter was used by the Jedi Order before and during the Clone Wars."
ENT.Category = "[LVS] - Republik"

ENT.Spawnable = true
ENT.AdminSpawnable = false

ENT.MDL = "models/starwars/lordtrilobite/ships/delta7/delta7b_landed.mdl"
ENT.GibModels = {
	"models/XQM/wingpiece2.mdl",
	"models/XQM/wingpiece2.mdl",
	"models/XQM/jetwing2medium.mdl",
	"models/XQM/jetwing2medium.mdl",
	"models/props_c17/TrapPropeller_Engine.mdl",
	"models/props_junk/Shoe001a.mdl",
	"models/XQM/jetbody2fuselage.mdl",
	"models/XQM/jettailpiece1medium.mdl",
	"models/XQM/pistontype1huge.mdl"
}

ENT.AITEAM = 2

ENT.MaxVelocity = 1000
ENT.MaxThrust = 1000

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3

ENT.TurnRatePitch = 1
ENT.TurnRateYaw = 1
ENT.TurnRateRoll = 1

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1.5
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 10000
ENT.MaxShield = 4500

ENT.LAATC_PICKUPABLE = true
ENT.LAATC_PICKUP_POS = Vector(-220, 0, -20)
ENT.LAATC_PICKUP_Angle = Angle(0, 0, 0)

function ENT:OnIsCarried( name, old, new)
	if new == old then return end

	if new then
		self:SetDisabled(true)
	else
		self:SetDisabled(false)
	end
end

function ENT:OnSetupDataTables()
	self:AddDT("Bool", "Foils")
	self:AddDT("Bool", "IsCarried")

	if SERVER then
		self:NetworkVarNotify( "Foils", self.OnFoilsChanged )
		self:NetworkVarNotify("IsCarried", self.OnIsCarried)
	end
end

function ENT:InitWeapons()
	self.FirePositions = {
		Vector(16,31.5,36),
		Vector(16,-33,36),
		Vector(16,32.5,26.5),
		Vector(16,-32,26.5)
	}

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Delay = 0.1
	weapon.HeatRateUp = 0.25
	weapon.HeatRateDown = 1
	weapon.Attack = function( ent )
		ent.NumPrim = ent.NumPrim and ent.NumPrim + 1 or 1
		if ent.NumPrim > #ent.FirePositions then ent.NumPrim = 1 end

		local pod = ent:GetDriverSeat()
		if not IsValid( pod ) then return end

		local startpos =  pod:LocalToWorld(pod:OBBCenter())
		local trace = util.TraceHull({
			start = startpos,
			endpos = startpos + ent:GetForward() * 50000,
			mins = Vector( -10, -10, -10 ),
			maxs = Vector( 10, 10, 10 ),
			filter = ent:GetCrosshairFilterEnts()
		})

		local CurPos = ent.FirePositions[ent.NumPrim]

		local bullet = {}
		bullet.Src = ent:LocalToWorld(ent.FirePositions[ent.NumPrim])
		bullet.Dir = (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread = Vector(0.01, 0.01, 0)
		bullet.Tracer = 1
		bullet.TracerName = "lvs_laser_green"
		bullet.Force = 100
		bullet.HullSize = 10
		bullet.Damage = 900
		bullet.Attacker = ent:GetDriver()
		bullet.Velocity = 60000
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
			effectdata:SetStart(Vector(50,255,50))
			effectdata:SetOrigin(tr.HitPos)
			effectdata:SetNormal(tr.HitNormal)
			util.Effect("lvs_laser_impact", effectdata )
		end
		ent:LVSFireBullet( bullet )

		if CurPos.y > 0 then
			ent.SNDLeft:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
		else
			ent.SNDRight:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
		end
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/overheat.wav")
	end
	self:AddWeapon(weapon)

	self:AddWeapon(LVS:GetWeaponPreset( "TURBO"))
end

ENT.FlyByAdvance = 2
ENT.FlyBySound = "lvs/vehicles/delta-7/flyby.wav"
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/delta-7/engine.wav",
		sound_int = "lvs/vehicles/delta-7/engine_int.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
}


--addons/lvs_starwars/lua/entities/lvs_starfighter_engine.lua:
AddCSLuaFile()

ENT.Type            = "anim"

ENT.Spawnable       = false
ENT.AdminSpawnable  = false
ENT.DoNotDuplicate = true

ENT._LVS = true

function ENT:SetupDataTables()
	self:NetworkVar( "Entity",0, "Base" )
	self:NetworkVar( "Float",1, "HP" )
	self:NetworkVar( "Float",2, "MaxHP" )

	self:NetworkVar( "Bool",0, "Destroyed" )

	if SERVER then
		self:SetMaxHP( 100 )
		self:SetHP( 100 )
	end
end

if SERVER then
	function ENT:Initialize()	
		self:SetMoveType( MOVETYPE_NONE )
		self:SetSolid( SOLID_NONE )
		self:DrawShadow( false )
		debugoverlay.Cross( self:GetPos(), 50, 5, Color( 0, 255, 255 ) )
	end

	function ENT:Think()
		local T = CurTime()
		local vehicle = self:GetBase()

		if not self:GetDestroyed() or not IsValid( vehicle ) or not vehicle:GetEngineActive() then self:NextThink( T + 1 ) return true end

		local PhysObj = vehicle:GetPhysicsObject()

		local Pos = self:GetPos()
		local Len = vehicle:WorldToLocal( Pos ):Length()

		PhysObj:ApplyForceOffset( -vehicle:GetVelocity() * (PhysObj:GetMass() / Len) * FrameTime() * 50, Pos )

		self:NextThink( T )

		return true
	end

	function ENT:OnTakeDamage( dmginfo )
		if self:GetDestroyed() then return end

		local Damage = dmginfo:GetDamage()

		if Damage <= 0 then return end

		local CurHealth = self:GetHP()

		local NewHealth = math.Clamp( CurHealth - Damage, 0, self:GetMaxHP() )

		self:SetHP( NewHealth )

		if NewHealth <= 0 then
			self:SetDestroyed( true )
		end
	end

	function ENT:UpdateTransmitState() 
		return TRANSMIT_ALWAYS
	end

	return
end

function ENT:Initialize()
end

function ENT:Think()
	local vehicle = self:GetBase()

	if not IsValid( vehicle ) then return end

	self:DamageFX( vehicle )
end

function ENT:OnRemove()
end

function ENT:Draw()
end

function ENT:DrawTranslucent()
end

function ENT:DamageFX( vehicle )
	local T = CurTime()
	local HP = vehicle:GetHP()
	local MaxHP = vehicle:GetMaxHP() 

	if HP <= 0 then return end

	if (self.nextDFX or 0) > T then return end

	self.nextDFX = T + 0.05

	local Destroyed = self:GetDestroyed()

	if Destroyed or HP < MaxHP * 0.5 then
		local effectdata = EffectData()
			effectdata:SetOrigin( self:GetPos() )
			effectdata:SetEntity( vehicle )
		util.Effect( "lvs_engine_blacksmoke", effectdata )
	end

	if not Destroyed then return end

	if HP < MaxHP * 0.5 then
		local effectdata = EffectData()
			effectdata:SetOrigin( self:GetPos() )
			effectdata:SetNormal( -self:GetForward() )
			effectdata:SetMagnitude( 2 )
			effectdata:SetEntity( vehicle )
		util.Effect( "lvs_exhaust_fire", effectdata )
	end
end

--addons/egm_lvs_ships/lua/entities/lvs_starfighter_eta2/cl_init.lua:
include("shared.lua")

ENT.EngineGlow = Material("sprites/light_glow02_add")
ENT.EngineColor = Color(200, 50, 0)
ENT.EnginePos = {
	Vector(-55, 15, 25),
	Vector(-55, -15, 25)
}

function ENT:OnSpawn()
	self:RegisterTrail(Vector(-100, 20, 10), 0, 20, 2, 1000, 150)
	self:RegisterTrail(Vector(-100, -20, 10), 0, 20, 2, 1000, 150)
end

function ENT:OnFrame()
	self:AnimAstromech()
end

function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	local Size = 30 + self:GetThrottle() * 40 + self:GetBoost() * 0.8
	for _, pos in pairs(self.EnginePos) do
	render.SetMaterial(self.EngineGlow)
		render.DrawSprite(self:LocalToWorld(pos), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(pos), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(pos), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(pos), Size, Size, self.EngineColor)
	end
end

function ENT:AnimAstromech()
	local T = CurTime()

	if (self.nextAstro or 0) < T then
		self.nextAstro = T + math.Rand(0.5,2)
		self.AstroAng = math.Rand(-180,180)

		local HasShield = self:GetShield() > 0

		if self.OldShield == true and not HasShield then
			self:EmitSound("lvs/vehicles/naboo_n1_starfighter/astromech/shieldsdown" .. math.random(1,2) .. ".ogg", 50)
		else
			if math.random(0, 4) == 3 then
				self:EmitSound("lvs/vehicles/naboo_n1_starfighter/astromech/"..math.random(1,11) .. ".ogg", 50)
			end
		end

		self.OldShield = HasShield
	end

	self.smastro = self.smastro and (self.smastro + ((self.AstroAng or 0) - self.smastro) * RealFrameTime() * 10) or 0

	self:ManipulateBoneAngles(1, Angle(self.smastro, 0, 0))
end
--addons/egm_lvs_ships/lua/entities/lvs_starfighter_eta2/shared.lua:
ENT.Base = "lvs_base_starfighter"

ENT.PrintName = "Yoda's Starfighter"
ENT.Author = "Deltaa"
ENT.Information = "Yoda's fighter was a modified Jedi starfighter at one point during the Clone Wars, stationed in the Jedi Temple hangar."
ENT.Category = "[LVS] - Republik"

ENT.Spawnable = true
ENT.AdminSpawnable = false

ENT.MDL = "models/starwars/syphadias/ships/yoda_starfighter/yoda_starfighter_closed.mdl"

ENT.AITEAM = 2

ENT.MaxVelocity = 1000
ENT.MaxThrust = 1000

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3

ENT.TurnRatePitch = 1
ENT.TurnRateYaw = 1
ENT.TurnRateRoll = 1

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1.5
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 10000
ENT.MaxShield = 4500

ENT.LAATC_PICKUPABLE = true
ENT.LAATC_PICKUP_POS = Vector(-230, 0, 25)
ENT.LAATC_PICKUP_Angle = Angle(0,0,0)

function ENT:OnIsCarried(name, old, new)
	if new == old then return end

	if new then
		self:SetDisabled(true)
	else
		self:SetDisabled(false)
	end
end

function ENT:OnSetupDataTables()
	self:AddDT("Bool", "Foils")
    self:AddDT("Bool", "IsCarried")
  
	if SERVER then
		self:NetworkVarNotify( "Foils", self.OnFoilsChanged )
        self:NetworkVarNotify("IsCarried", self.OnIsCarried)
	end
end

function ENT:InitWeapons()
	self.FirePositions = {
		Vector(99, 37, 30),
		Vector(99, -37, 30),
	}

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Delay = 0.1
	weapon.HeatRateUp = 0.25
	weapon.HeatRateDown = 1
	weapon.Attack = function( ent )
		ent.NumPrim = ent.NumPrim and ent.NumPrim + 1 or 1
		if ent.NumPrim > #ent.FirePositions then ent.NumPrim = 1 end

		local pod = ent:GetDriverSeat()
		if not IsValid( pod ) then return end

		local startpos =  pod:LocalToWorld(pod:OBBCenter())
		local trace = util.TraceHull({
			start = startpos,
			endpos = startpos + ent:GetForward() * 50000,
			mins = Vector( -10, -10, -10 ),
			maxs = Vector( 10, 10, 10 ),
			filter = ent:GetCrosshairFilterEnts()
		})

		local CurPos = ent.FirePositions[ent.NumPrim]

		local bullet = {}
		bullet.Src = ent:LocalToWorld(ent.FirePositions[ent.NumPrim])
		bullet.Dir = (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread = Vector(0.01, 0.01, 0)
		bullet.Tracer = 1
		bullet.TracerName = "lvs_laser_green"
		bullet.Force = 100
		bullet.HullSize = 10
		bullet.Damage = 900
		bullet.Attacker = ent:GetDriver()
		bullet.Velocity = 60000
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
			effectdata:SetStart(Vector(50,255,50))
			effectdata:SetOrigin(tr.HitPos)
			effectdata:SetNormal(tr.HitNormal)
			util.Effect("lvs_laser_impact", effectdata )
		end
		ent:LVSFireBullet( bullet )

		if CurPos.y > 0 then
			ent.SNDLeft:PlayOnce(100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1)
		else
			ent.SNDRight:PlayOnce(100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1)
		end
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/overheat.wav")
	end
	self:AddWeapon(weapon)

	self:AddWeapon(LVS:GetWeaponPreset("TURBO"))
end

ENT.FlyByAdvance = 0.5
ENT.FlyBySound = "lvs/vehicles/delta-7/flyby.wav"
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/delta-7/engine.wav",
		sound_int = "lvs/vehicles/delta-7/engine_int.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
}


--addons/egm_lvs_ships/lua/entities/lvs_starfighter_firespray/cl_init.lua:
include("shared.lua")

ENT.EngineGlow = Material("sprites/light_glow02_add")
ENT.EngineColor = Color(255, 240, 150)
ENT.EnginePos = {
	Vector(-160, 44, 310),
	Vector(-160, -44, 310)
}

function ENT:OnSpawn()
	self:RegisterTrail(Vector(0, 25, 30), 5, 20, 2, 1000, 150)
	self:RegisterTrail(Vector(0, -25, 30), 5, 20, 2, 1000, 150)
	self:RegisterTrail(Vector(-100, 240, 375), 5, 20, 2, 1000, 150)
	self:RegisterTrail(Vector(-100, -240, 375), 5, 20, 2, 1000, 150)
end

function ENT:OnFrame()
	self:EngineEffects()
end

function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	local Size = 120 + self:GetThrottle() * 60 + self:GetBoost() * 1.2
	render.SetMaterial(self.EngineGlow)
	render.DrawSprite(self:LocalToWorld(Vector(-160, -44, 310)), Size, Size, self.EngineColor)
	render.DrawSprite(self:LocalToWorld(Vector(-160, 44, 310)), Size, Size, self.EngineColor)
end

function ENT:EngineEffects()
	if not self:GetEngineActive() then return end

	if self.nextEFX and self.nextEFX > CurTime() then return end
	self.nextEFX = CurTime() + 0.01

	local emitter = self:GetParticleEmitter(self:GetPos())
	if not IsValid(emitter) then return end

	for _, v in pairs(self.EnginePos) do
		local vOffset = self:LocalToWorld(v)
		local vNormal = -self:GetForward()

		vOffset = vOffset + vNormal * 5

		local particle = emitter:Add("effects/muzzleflash2", vOffset)
		if not particle then continue end

		particle:SetVelocity(vNormal * math.Rand(500, 1000) + self:GetVelocity())
		particle:SetLifeTime(0)
		particle:SetDieTime(0.1)
		particle:SetStartAlpha(255)
		particle:SetEndAlpha(0)
		particle:SetStartSize(math.Rand(25, 50))
		particle:SetEndSize(math.Rand(0, 10))
		particle:SetRoll(math.Rand(-1, 1) * 100)
		particle:SetColor(255, 240, 150)
	end
end



--addons/egm_lvs_ships/lua/entities/lvs_starfighter_gauntlet/shared.lua:
ENT.Base = "lvs_base_starfighter"

ENT.PrintName = "Gauntlet starfighter"
ENT.Author = "Deltaa"
ENT.Information = "Heavy mandalorian starfighter used by the death watch during the clone wars"
ENT.Category = "[LVS] - Neutral"

ENT.Spawnable = true
ENT.AdminSpawnable = false

ENT.MDL = "models/gauntlet/sfp_gauntlet.mdl"

ENT.AITEAM = 0

ENT.MaxVelocity = 2500
ENT.MaxThrust = 2500

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3

ENT.TurnRatePitch = 1
ENT.TurnRateYaw = 1
ENT.TurnRateRoll = 1

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1.1
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 24000
ENT.MaxShield = 7500

function ENT:InitWeapons()
	self.FirePositions = {
		Vector(155, 39, 172),
		Vector(155, -39, 172)
	}

	-- Primary Gun
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/mg.png")
	weapon.Delay = 0.1
	weapon.HeatRateUp = 0.1
	weapon.HeatRateDown = 0.2
	weapon.Attack = function( ent )
		ent.NumPrim = ent.NumPrim and ent.NumPrim + 1 or 1
		if ent.NumPrim > #ent.FirePositions then ent.NumPrim = 1 end

		local pod = ent:GetDriverSeat()
		if not IsValid(pod) then return end

		local startpos =  pod:LocalToWorld(pod:OBBCenter())
		local trace = util.TraceHull({
			start = startpos,
			endpos = startpos + ent:GetForward() * 50000,
			mins = Vector( -10, -10, -10 ),
			maxs = Vector( 10, 10, 10 ),
			filter = ent:GetCrosshairFilterEnts()
		})

		local CurPos = ent.FirePositions[ent.NumPrim]

		local bullet = {}
		bullet.Src = ent:LocalToWorld(ent.FirePositions[ent.NumPrim])
		bullet.Dir = (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread = Vector(0.01, 0.01, 0)
		bullet.Tracer = 1
		bullet.TracerName = "lvs_laser_yellow"
		bullet.Force = 100
		bullet.HullSize = 10
		bullet.Damage = 300
		bullet.Attacker = ent:GetDriver()
		bullet.Velocity = 40000
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
			effectdata:SetStart(Vector(200, 150, 0))
			effectdata:SetOrigin(tr.HitPos)
			effectdata:SetNormal(tr.HitNormal)
			util.Effect("lvs_laser_impact", effectdata )
		end

		ent:LVSFireBullet(bullet)

		local effectdata = EffectData()
		effectdata:SetStart(Vector(200, 150, 0))
		effectdata:SetOrigin(bullet.Src)
		effectdata:SetNormal(ent:GetForward())
		effectdata:SetEntity(ent)
		util.Effect("lvs_muzzle_colorable", effectdata)

		if CurPos.y > 0 then
			ent.SNDLeft:PlayOnce(100 + math.cos( CurTime() + ent:EntIndex() * 1337) * 5 + math.Rand(-1,1), 1)
		else
			ent.SNDRight:PlayOnce(100 + math.cos( CurTime() + ent:EntIndex() * 1337) * 5 + math.Rand(-1,1), 1)
		end
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/overheat.wav")
	end
	self:AddWeapon(weapon)

	-- Torpedo Weapon
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/protontorpedo.png")
	weapon.Ammo = 8
	weapon.Delay = 3
	weapon.HeatRateUp = 1
	weapon.HeatRateDown = 0.5
	weapon.Attack = function( ent )
		if IsValid(ent._ProtonTorpedo) then
			if ent._nextMissleTracking and ent._nextMissleTracking > CurTime() then return end
			ent._nextMissleTracking = CurTime() + 0.1

			ent._ProtonTorpedo:FindTarget(ent:GetPos(), ent:GetForward(), 30, 7500)
			return
		end

		if ent._nextMissle and ent._nextMissle > CurTime() then return end
		ent._nextMissle = CurTime() + 0.5

		ent._swapMissile = not ent._swapMissile

		local Pos = Vector(-260, ent._swapMissile and 35 or -35, 120)
		local Driver = self:GetDriver()

		local projectile = ents.Create("lvs_concussionmissile")
		projectile:SetPos(ent:LocalToWorld(Pos))
		projectile:SetAngles(ent:GetAngles())
		projectile:SetParent(ent)
		projectile:Spawn()
		projectile:Activate()
		projectile:SetAttacker(IsValid( Driver ) and Driver or self)
		projectile:SetEntityFilter( ent:GetCrosshairFilterEnts())
		projectile:SetSpeed(ent:GetVelocity():Length() + 4000)

		ent._ProtonTorpedo = projectile

		ent:SetNextAttack(CurTime() + 0.1) -- wait 0.1 second before starting to track
	end
	weapon.FinishAttack = function( ent )
		if not IsValid(ent._ProtonTorpedo) then return end

		local projectile = ent._ProtonTorpedo
		projectile:Enable()
		projectile:EmitSound("lvs/vehicles/vulturedroid/fire_missile.mp3", 125 )
		ent:TakeAmmo()

		ent._ProtonTorpedo = nil

		local NewHeat = ent:GetHeat() + 0.75
		if NewHeat >= 1 then
			ent:SetOverheated(true)
		end

		ent:SetHeat(NewHeat)
	end
	weapon.OnSelect = function(ent)
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/overheat.wav")
	end
	self:AddWeapon(weapon)

	self:AddWeapon(LVS:GetWeaponPreset("TURBO"))
end

ENT.FlyByAdvance = 0.5
ENT.FlyBySound = "lvs/vehicles/naboo_n1_starfighter/flyby.wav"
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/vwing/loop.wav",
		int_sound = "^lvs/vehicles/vwing/loop.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
}


--addons/egm_lvs_ships/lua/entities/lvs_starfighter_havoc/shared.lua:

ENT.Base = "lvs_base_starfighter"

ENT.PrintName = "Scurrg H-6"
ENT.Author = "Nashatok"
ENT.Information = "Prototype bomber by the Nubian Design Collective, stolen and modified by pirates and other unsavories"
ENT.Category = "[LVS] - Neutral"

ENT.Spawnable = true
ENT.AdminSpawnable = false

ENT.MDL = "models/havoc/rep_havoc.mdl"

ENT.AITEAM = 0

ENT.MaxVelocity = 2500
ENT.MaxThrust = 2500

ENT.TurnRatePitch = 1
ENT.TurnRateYaw = 1
ENT.TurnRateRoll = 1

ENT.ForceLinearMultiplier = 1.1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 9000
ENT.MaxShield = 3000

function ENT:OnSetupDataTables()
	self:AddDT("Entity", "GunnerSeat")
end

function ENT:InitWeapons()
	self.FirePositions = {
		Vector(143, 235, 24),
		Vector(130, 220, 24),
		Vector(143, -235, 24),
		Vector(130, -220, 24)
	}

	-- Primary Weapon
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/mg.png")
	weapon.Delay = 0.15
	weapon.HeatRateUp = 0.1
	weapon.HeatRateDown = 0.5
	weapon.Attack = function( ent )
		self.NumPrim = self.NumPrim and self.NumPrim + 1 or 1
		if self.NumPrim > 4 then self.NumPrim = 1 end

		local pod = ent:GetDriverSeat()
		if not IsValid(pod) then return end

		local startpos = pod:LocalToWorld(pod:OBBCenter())
		local trace = util.TraceHull({
			start = startpos,
			endpos = startpos + ent:GetForward() * 50000,
			mins = Vector(-10, -10, -10),
			maxs = Vector(10, 10, 10),
			filter = ent:GetCrosshairFilterEnts()
		})

		local bullet = {}
		bullet.Src = ent:LocalToWorld( ent.FirePositions[ent.NumPrim] )
		bullet.Dir = (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread = Vector( 0.02,  0.02, 0 )
		bullet.TracerName = "lvs_laser_red"
		bullet.Force = 100
		bullet.HullSize = 40
		bullet.Damage = 300
		bullet.Velocity = 60000
		bullet.Attacker = ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
			effectdata:SetStart(Vector(255, 50, 0))
			effectdata:SetOrigin(tr.HitPos)
			effectdata:SetNormal(tr.HitNormal)
			util.Effect("lvs_laser_impact", effectdata)
		end

		local effectdata = EffectData()
		effectdata:SetStart(Vector(255, 50, 0))
		effectdata:SetOrigin(bullet.Src)
		effectdata:SetNormal(ent:GetForward())
		effectdata:SetEntity(ent)
		util.Effect("lvs_muzzle_colorable", effectdata)

		ent:LVSFireBullet(bullet)

		ent.PrimarySND:PlayOnce(100 + math.cos( CurTime() + self:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1)
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )

	-- Proton Torpedos
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/protontorpedo.png")
	weapon.UseableByAI = false
	weapon.Ammo = 12
	weapon.Delay = 3 -- this will turn weapon.Attack to a somewhat think function
	weapon.HeatRateUp = 1 -- cool down when attack key is held. This system fires on key-release.
	weapon.HeatRateDown = 0.25
	weapon.Attack = function( ent )
		local T = CurTime()

		if IsValid(ent._ProtonTorpedo) then
			if (ent._nextMissleTracking or 0) > T then return end
			ent._nextMissleTracking = T + 0.1 -- 0.1 second interval because those find functions can be expensive

			ent._ProtonTorpedo:FindTarget(ent:GetPos(), ent:GetForward(), 30, 7500)

			return
		end

		if (ent._nextMissle or 0) > T then return end
		ent._nextMissle = T + 0.5

		ent._swapMissile = not ent._swapMissile

		local Pos = Vector(125, ent._swapMissile and -87 or 89, 8)

		local projectile = ents.Create("lvs_concussionmissile")
		projectile:SetPos(ent:LocalToWorld(Pos))
		projectile:SetAngles(ent:GetAngles())
		projectile:SetParent(ent)
		projectile:Spawn()
		projectile:Activate()
		projectile:SetAttacker(ent:GetDriver())
		projectile:SetEntityFilter(ent:GetCrosshairFilterEnts())
		projectile:SetSpeed(ent:GetVelocity():Length() + 4000)

		ent._ProtonTorpedo = projectile

		ent:SetNextAttack(CurTime() + 0.1) -- wait 0.1 second before starting to track
	end
	weapon.FinishAttack = function( ent )
		if not IsValid( ent._ProtonTorpedo ) then return end

		local projectile = ent._ProtonTorpedo

		projectile:Enable()
		projectile:EmitSound("lvs/vehicles/naboo_n1_starfighter/proton_fire.mp3", 125)
		ent:TakeAmmo()

		ent._ProtonTorpedo = nil

		local NewHeat = ent:GetHeat() + 0.75

		ent:SetHeat( NewHeat )
		if NewHeat >= 1 then
			ent:SetOverheated( true )
		end
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )

	-- Heavy Weapon
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Ammo = 500
	weapon.Delay = 0.2
	weapon.HeatRateUp = 0.5
	weapon.HeatRateDown = 0.2
	weapon.Attack = function( ent )
		local bullet = {}
		bullet.Spread 	= Vector(0.035,  0.035, 0.015)
		bullet.TracerName = "lvs_laser_red"
		bullet.Force = 250
		bullet.HullSize = 25
		bullet.Damage = 750
		bullet.Velocity = 22000
		bullet.Attacker = ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
			effectdata:SetStart(Vector(255, 50, 0))
			effectdata:SetOrigin(tr.HitPos)
			effectdata:SetNormal(tr.HitNormal)
			util.Effect("lvs_bullet_impact", effectdata)
		end

		for i = -1, 1, 2 do
			bullet.Src = ent:LocalToWorld(Vector(100, 211 * i, 24))
			bullet.Dir = ent:LocalToWorldAngles(Angle(0, -0.4 * i, 0)):Forward()
			ent:LVSFireBullet(bullet)
		end

		ent:TakeAmmo()

		ent.SecondarySND:PlayOnce(100 + math.cos( CurTime() + self:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1)
	end
	weapon.OnSelect = function(ent)
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/overheat.wav")
	end
	self:AddWeapon(weapon)

	-- Gunner Weapon
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Delay = 0.15
	weapon.Attack = function( ent )
		local pod = ent:GetDriverSeat()
		if not IsValid(pod) then return end

		local dir = ent:GetAimVector()
		if ent:AngleBetweenNormal(dir, ent:GetForward()) > 180 then return true end

		local trace = ent:GetEyeTrace()

		ent.SwapTopBottom = not ent.SwapTopBottom

		local veh = ent:GetVehicle()

		veh.SNDTail:PlayOnce(100 + math.Rand(-3,3), 1)

		local bullet = {}
		bullet.Src = veh:LocalToWorld(ent.SwapTopBottom and Vector(50, 8, 78) or Vector(50, -8, 78))
		bullet.Dir = (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread = Vector( 0.03,  0.03, 0.03 )
		bullet.TracerName = "lvs_laser_red"
		bullet.Force = 100
		bullet.HullSize = 25
		bullet.Damage = 300
		bullet.Velocity = 50000
		bullet.Attacker = ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
			effectdata:SetStart(Vector(255, 50, 0))
			effectdata:SetOrigin(tr.HitPos)
			effectdata:SetNormal(tr.HitNormal)
			util.Effect("lvs_laser_impact", effectdata)
		end
		ent:LVSFireBullet(bullet)
	end
	weapon.OnSelect = function(ent)
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/overheat.wav")
	end
	self:AddWeapon(weapon, 2)
end

ENT.FlyByAdvance = 0.75
ENT.FlyBySound = "lvs/vehicles/naboo_n1_starfighter/flyby.wav"
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/naboo_n1_starfighter/loop.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
}
--addons/egm_lvs_ships/lua/entities/lvs_starfighter_n1/cl_init.lua:
include("shared.lua")

function ENT:OnSpawn()
	self:RegisterTrail( Vector(-95,143.87,30.93), 0, 20, 2, 2500, 150 )
	self:RegisterTrail( Vector(-95,-143.87,30.93), 0, 20, 2, 2500, 150 )

	self:CreateBonePoseParameter( "cabin", 1, Angle(0,0,0), Angle(0,0,0), Vector(0,0,0), Vector(0,0,50) )
end

function ENT:OnFrame()
	self:EngineEffects()
	self:AnimAstromech()
end

ENT.EngineGlow = Material( "sprites/light_glow02_add" )

function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	local Size = 80 + self:GetThrottle() * 120 + self:GetBoost()

	render.SetMaterial( self.EngineGlow )

	for i = -1,1,2 do
		local pos = self:LocalToWorld( Vector(20,143.87 * i,30.93) )
		render.DrawSprite( pos, Size, Size, Color( 0, 127, 255, 255) )
	end
end

function ENT:EngineEffects()
	if not self:GetEngineActive() then return end

	local T = CurTime()

	if (self.nextEFX or 0) > T then return end

	self.nextEFX = T + 0.01

	local THR = self:GetThrottle()

	local emitter = self:GetParticleEmitter( self:GetPos() )

	if not IsValid( emitter ) then return end

	for i = -1,1,2 do
		local vOffset = self:LocalToWorld( Vector(41,143.87 * i,30.93) )
		local vNormal = -self:GetForward()

		vOffset = vOffset + vNormal * 5

		local particle = emitter:Add( "effects/select_ring", vOffset )

		if not particle then continue end

		particle:SetVelocity( vNormal * (1000 + self:GetBoost() * 10) + self:GetVelocity() )
		particle:SetLifeTime( 0 )
		particle:SetDieTime( 0.05 )
		particle:SetStartAlpha( 255 )
		particle:SetEndAlpha( 0 )
		particle:SetStartSize( 20 )
		particle:SetEndSize( 20 )
		particle:SetAngles( vNormal:Angle() )
		particle:SetColor( math.Rand( 10, 100 ), math.Rand( 100, 220 ), math.Rand( 240, 255 ) )
	end
end

function ENT:AnimAstromech()
	local T = CurTime()

	if (self.nextAstro or 0) < T then
		self.nextAstro = T + math.Rand(0.5,2)
		self.AstroAng = math.Rand(-180,180)

		local HasShield = self:GetShield() > 0

		if self.OldShield == true and not HasShield then
			self:EmitSound( "lvs/vehicles/naboo_n1_starfighter/astromech/shieldsdown"..math.random(1,2)..".ogg", 100 )
		else
			if math.random(0,4) == 3 then
				self:EmitSound( "lvs/vehicles/naboo_n1_starfighter/astromech/"..math.random(1,11)..".ogg", 70 )
			end
		end
		
		self.OldShield = HasShield
	end

	self.smastro = self.smastro and (self.smastro + ((self.AstroAng or 0) - self.smastro) * RealFrameTime() * 10) or 0

	self:ManipulateBoneAngles( 2, Angle(self.smastro,0,0) )
end

function ENT:OnStartBoost()
	self:EmitSound( "lvs/vehicles/naboo_n1_starfighter/boost.wav", 85 )
end

function ENT:OnStopBoost()
	self:EmitSound( "lvs/vehicles/naboo_n1_starfighter/brake.wav", 85 )
end

--addons/egm_lvs_ships/lua/entities/lvs_starfighter_n1/shared.lua:

ENT.Base = "lvs_base_starfighter"

ENT.PrintName = "N1 Starfighter"
ENT.Author = "Luna"
ENT.Information = "Starfighter of the Royal Naboo Security Force"
ENT.Category = "[LVS] - Neutral"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/blu/naboostarfighter.mdl"
ENT.GibModels = {
	"models/gibs/helicopter_brokenpiece_01.mdl",
	"models/gibs/helicopter_brokenpiece_02.mdl",
	"models/gibs/helicopter_brokenpiece_03.mdl",
	"models/combine_apc_destroyed_gib02.mdl",
	"models/combine_apc_destroyed_gib04.mdl",
	"models/combine_apc_destroyed_gib05.mdl",
	"models/props_c17/trappropeller_engine.mdl",
	"models/gibs/airboat_broken_engine.mdl",
}

ENT.AITEAM = 0

ENT.MaxVelocity = 3000
ENT.MaxThrust = 3000

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3

ENT.TurnRatePitch = 1
ENT.TurnRateYaw = 1
ENT.TurnRateRoll = 1

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 15000
ENT.MaxShield = 3000

ENT.LAATC_PICKUPABLE = true
ENT.LAATC_PICKUP_POS = Vector(-300, 0, -40)
ENT.LAATC_PICKUP_Angle = Angle(0, 0, 0)

function ENT:OnIsCarried( name, old, new)
	if new == old then return end

	if new then
		self:SetDisabled(true)
	else
		self:SetDisabled(false)
	end
end

function ENT:OnSetupDataTables()
	self:AddDT("Bool", "IsCarried")

	if SERVER then
		self:NetworkVarNotify("IsCarried", self.OnIsCarried)
	end
end

function ENT:InitWeapons()
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/dual_mg.png")
	weapon.Delay = 0.15
	weapon.HeatRateUp = 0.25
	weapon.HeatRateDown = 1
	weapon.Attack = function( ent )
		local bullet = {}
		bullet.Dir = ent:GetForward()
		bullet.Spread = Vector( 0.015,  0.015, 0 )
		bullet.TracerName = "lvs_laser_green"
		bullet.Force = 100
		bullet.HullSize = 25
		bullet.Damage = 750
		bullet.Velocity = 60000
		bullet.Attacker = ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart(Vector(50, 255, 50))
				effectdata:SetOrigin(tr.HitPos)
				effectdata:SetNormal(tr.HitNormal)
			util.Effect( "lvs_laser_impact", effectdata )
		end

		for i = -1,1,2 do
			bullet.Src 	= ent:LocalToWorld(Vector(118.24,18.04 * i,49.96))

			local effectdata = EffectData()
			effectdata:SetStart(Vector(50,255,50))
			effectdata:SetOrigin(bullet.Src)
			effectdata:SetNormal(ent:GetForward())
			effectdata:SetEntity(ent)
			util.Effect( "lvs_muzzle_colorable", effectdata )

			ent:LVSFireBullet( bullet )
		end

		ent:TakeAmmo()

		ent.PrimarySND:PlayOnce(100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1)
	end
	weapon.OnSelect = function(ent)
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/overheat.wav")
	end
	self:AddWeapon(weapon)


	local weapon = {}
	weapon.Icon = Material("lvs/weapons/protontorpedo.png")
	weapon.Ammo = 8
	weapon.Delay = 3 -- this will turn weapon.Attack to a somewhat think function
	weapon.HeatRateUp = -0.5 -- cool down when attack key is held. This system fires on key-release.
	weapon.HeatRateDown = 0.25
	weapon.Attack = function( ent )
		local T = CurTime()

		if IsValid( ent._ProtonTorpedo ) then
			if (ent._nextMissleTracking or 0) > T then return end

			ent._nextMissleTracking = T + 0.1 -- 0.1 second interval because those find functions can be expensive

			ent._ProtonTorpedo:FindTarget(ent:GetPos(), ent:GetForward(), 30, 7500)

			return
		end


		if (ent._nextMissle or 0) > T then return end

		ent._nextMissle = T + 0.5

		local Driver = ent:GetDriver()

		local projectile = ents.Create( "lvs_protontorpedo" )
		projectile:SetPos( ent:LocalToWorld( Vector(147.82,0,39.52) ) )
		projectile:SetAngles( ent:GetAngles() )
		projectile:SetParent( ent )
		projectile:Spawn()
		projectile:Activate()
		projectile:SetAttacker( IsValid( Driver ) and Driver or self )
		projectile:SetDamage(8000)
		projectile:SetEntityFilter( ent:GetCrosshairFilterEnts() )
		projectile:SetSpeed( ent:GetVelocity():Length() + 4000 )

		ent._ProtonTorpedo = projectile

		ent:SetNextAttack( CurTime() + 0.1 ) -- wait 0.1 second before starting to track
	end
	weapon.FinishAttack = function( ent )
		if not IsValid( ent._ProtonTorpedo ) then return end

		local projectile = ent._ProtonTorpedo

		projectile:Enable()
		projectile:EmitSound( "lvs/vehicles/naboo_n1_starfighter/proton_fire.mp3", 125 )
		ent:TakeAmmo()

		ent._ProtonTorpedo = nil

		local NewHeat = ent:GetHeat() + 0.75

		ent:SetHeat( NewHeat )
		if NewHeat >= 1 then
			ent:SetOverheated( true )
		end
	end
	weapon.OnSelect = function(ent)
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/overheat.wav")
	end
	self:AddWeapon( weapon )
end

ENT.FlyByAdvance = 0.75
ENT.FlyBySound = "lvs/vehicles/naboo_n1_starfighter/flyby.wav" 
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/naboo_n1_starfighter/loop.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 90,
	},
}
--addons/egm_lvs_ships/lua/entities/lvs_starfighter_shuttle/cl_init.lua:

include("shared.lua")

ENT.EngineColor = Color( 253, 101, 63)
ENT.EngineGlow = Material("sprites/light_glow02_add")

function ENT:OnSpawn()
	self:RegisterTrail(Vector(-34,50,-13), 0, 20, 2, 1000, 150)
	self:RegisterTrail(Vector(-34,-50,-13), 0, 20, 2, 1000, 150)
end

function ENT:OnFrame()
	self:EngineEffects()
end

function ENT:EngineEffects()
	if not self:GetEngineActive() then return end

	if self.nextEFX and self.nextEFX > CurTime() then return end
	self.nextEFX = CurTime() + 0.01

	local emitter = self:GetParticleEmitter(self:GetPos())
	if not IsValid(emitter) then return end

	for _, pos in pairs(self.EnginePos) do
		local vOffset = self:LocalToWorld(pos)
		local vNormal = -self:GetForward()

		vOffset = vOffset + vNormal * 5

		local particle = emitter:Add("effects/muzzleflash2", vOffset)
		if not particle then continue end

		particle:SetVelocity(vNormal * (math.Rand(500, 1000) + self:GetBoost() * 10) + self:GetVelocity())
		particle:SetLifeTime(0)
		particle:SetDieTime(0.1)
		particle:SetStartAlpha(255)
		particle:SetEndAlpha(0)
		particle:SetStartSize(math.Rand(15, 25))
		particle:SetEndSize(math.Rand(0, 10))
		particle:SetRoll(math.Rand(-1, 1) * 100)
		particle:SetColor(255, 50, 200)
	end
end

function ENT:AnimGunner()

	local weapon = Pod:lvsGetWeapon()
	if not IsValid(weapon) then return end

	local EyeAngles = self:WorldToLocalAngles( weapon:GetAimVector():Angle() )
	EyeAngles:RotateAroundAxis( EyeAngles:Up(), 180 )

	local Yaw = math.Clamp( EyeAngles.y,-60,60)
	local Pitch = math.Clamp( EyeAngles.p,-60,60 )

	self:ManipulateBoneAngles( 1, Angle(Yaw,0,0) )
	self:ManipulateBoneAngles( 2, Angle(0,0,Pitch) )

	self:ManipulateBoneAngles( 5, Angle(Yaw,0,0) )
	self:ManipulateBoneAngles( 4, Angle(0,0,Pitch) )
end


function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	local Size = 80 + self:GetThrottle() * 120 + self:GetBoost() * 2

	render.SetMaterial(self.EngineGlow)

	for _, pos in pairs(self.EnginePos) do
		render.DrawSprite(self:LocalToWorld(pos), Size, Size, self.EngineColor)
	end
end

function ENT:OnStartBoost()
	self:EmitSound("lvs/vehicles/arc170/boost.wav", 85)
end

function ENT:OnStopBoost()
	self:EmitSound("lvs/vehicles/arc170/brake.wav", 85)
end
--addons/egm_lvs_ships/lua/entities/lvs_starfighter_shuttle_armed/cl_init.lua:
include("shared.lua")

ENT.EngineColor = Color( 255, 50, 0, 255)
ENT.EngineGlow = Material( "sprites/light_glow02_add" )
ENT.EnginePos = {
	Vector(-163.81,66,22),
	Vector(-163.81,-66,22),
}

function ENT:OnSpawn()
	self:RegisterTrail( Vector(-34,50,-13), 0, 20, 2, 1000, 150 )
	self:RegisterTrail( Vector(-34,-50,-13), 0, 20, 2, 1000, 150 )
end

function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	if self.nextEFX and self.nextEFX > CurTime() then return end
	self.nextEFX = CurTime() + 0.01


	local emitter = self:GetParticleEmitter(self:GetPos())
	if not IsValid(emitter) then return end

	for _, pos in pairs(self.EnginePos) do
		local vOffset = self:LocalToWorld( pos )
		local vNormal = -self:GetForward()

		vOffset = vOffset + vNormal * 5

		local particle = emitter:Add("effects/muzzleflash2", vOffset)
		if not particle then continue end

		particle:SetVelocity(vNormal * (math.Rand(500,1000) + self:GetBoost() * 10) + self:GetVelocity())
		particle:SetLifeTime(0)
		particle:SetDieTime(0.1)
		particle:SetStartAlpha(255)
		particle:SetEndAlpha(0)
		particle:SetStartSize(math.Rand(15,25))
		particle:SetEndSize(math.Rand(0,10))
		particle:SetRoll(math.Rand(-1,1) * 100)
		particle:SetColor(255, 50, 200)
	end
end

function ENT:AnimGunner()

	local weapon = Pod:lvsGetWeapon()
	if not IsValid(weapon) then return end

	local EyeAngles = self:WorldToLocalAngles( weapon:GetAimVector():Angle() )
	EyeAngles:RotateAroundAxis( EyeAngles:Up(), 180 )

	local Yaw = math.Clamp( EyeAngles.y,-60,60)
	local Pitch = math.Clamp( EyeAngles.p,-60,60 )

	self:ManipulateBoneAngles( 1, Angle(Yaw,0,0) )
	self:ManipulateBoneAngles( 2, Angle(0,0,Pitch) )

	self:ManipulateBoneAngles( 5, Angle(Yaw,0,0) )
	self:ManipulateBoneAngles( 4, Angle(0,0,Pitch) )
end


function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	local Size = 80 + self:GetThrottle() * 120 + self:GetBoost() * 2

	render.SetMaterial( self.EngineGlow )

	for _, pos in pairs( self.EnginePos ) do
		render.DrawSprite(  self:LocalToWorld( pos ), Size, Size, self.EngineColor )
	end
end

function ENT:OnStartBoost()
	self:EmitSound( "lvs/vehicles/arc170/boost.wav", 85 )
end

function ENT:OnStopBoost()
	self:EmitSound( "lvs/vehicles/arc170/brake.wav", 85 )
end

--addons/egm_lvs_ships/lua/entities/lvs_starfighter_shuttle_jedi/cl_init.lua:
include("shared.lua")

ENT.EngineColor = Color( 255, 50, 0, 255)
ENT.EngineGlow = Material( "sprites/light_glow02_add" )
ENT.EnginePos = {
	Vector(-163.81,66,22),
	Vector(-163.81,-66,22),
}

function ENT:OnSpawn()
	self:RegisterTrail( Vector(-34,50,-13), 0, 20, 2, 1000, 150 )
	self:RegisterTrail( Vector(-34,-50,-13), 0, 20, 2, 1000, 150 )
end

function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	if self.nextEFX and self.nextEFX > CurTime() then return end
	self.nextEFX = CurTime() + 0.01


	local emitter = self:GetParticleEmitter(self:GetPos())
	if not IsValid(emitter) then return end

	for _, pos in pairs(self.EnginePos) do
		local vOffset = self:LocalToWorld( pos )
		local vNormal = -self:GetForward()

		vOffset = vOffset + vNormal * 5

		local particle = emitter:Add("effects/muzzleflash2", vOffset)
		if not particle then continue end

		particle:SetVelocity(vNormal * (math.Rand(500,1000) + self:GetBoost() * 10) + self:GetVelocity())
		particle:SetLifeTime(0)
		particle:SetDieTime(0.1)
		particle:SetStartAlpha(255)
		particle:SetEndAlpha(0)
		particle:SetStartSize(math.Rand(15,25))
		particle:SetEndSize(math.Rand(0,10))
		particle:SetRoll(math.Rand(-1,1) * 100)
		particle:SetColor(255, 50, 200)
	end
end

function ENT:AnimGunner()

	local weapon = Pod:lvsGetWeapon()
	if not IsValid(weapon) then return end

	local EyeAngles = self:WorldToLocalAngles( weapon:GetAimVector():Angle() )
	EyeAngles:RotateAroundAxis( EyeAngles:Up(), 180 )

	local Yaw = math.Clamp( EyeAngles.y,-60,60)
	local Pitch = math.Clamp( EyeAngles.p,-60,60 )

	self:ManipulateBoneAngles( 1, Angle(Yaw,0,0) )
	self:ManipulateBoneAngles( 2, Angle(0,0,Pitch) )

	self:ManipulateBoneAngles( 5, Angle(Yaw,0,0) )
	self:ManipulateBoneAngles( 4, Angle(0,0,Pitch) )
end


function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	local Size = 80 + self:GetThrottle() * 120 + self:GetBoost() * 2

	render.SetMaterial( self.EngineGlow )

	for _, pos in pairs( self.EnginePos ) do
		render.DrawSprite(  self:LocalToWorld( pos ), Size, Size, self.EngineColor )
	end
end

function ENT:OnStartBoost()
	self:EmitSound( "lvs/vehicles/arc170/boost.wav", 85 )
end

function ENT:OnStopBoost()
	self:EmitSound( "lvs/vehicles/arc170/brake.wav", 85 )
end

--addons/lvs_starwars/lua/entities/lvs_starfighter_soundemitter.lua:
AddCSLuaFile()

ENT.Type            = "anim"

ENT.Spawnable       = false
ENT.AdminSpawnable  = false
ENT.DoNotDuplicate = true

ENT._LVS = true

function ENT:SetupDataTables()
	self:NetworkVar( "Entity",0, "Base" )
end

if SERVER then
	function ENT:Initialize()	
		self:SetMoveType( MOVETYPE_NONE )
		self:SetSolid( SOLID_NONE )
		self:DrawShadow( false )
		debugoverlay.Cross( self:GetPos(), 40, 5, Color( 255, 255, 255 ) )
	end

	function ENT:Think()
		return false
	end

	function ENT:OnTakeDamage( dmginfo )
	end

	function ENT:UpdateTransmitState() 
		return TRANSMIT_ALWAYS
	end

	return
end

ENT._oldEnActive = false
ENT._ActiveSounds = {}

function ENT:Initialize()
end

function ENT:StopSounds()
	for id, sound in pairs( self._ActiveSounds ) do
		if istable( sound ) then
			for _, snd in pairs( sound ) do
				if snd then
					snd:Stop()
				end
			end
		else
			sound:Stop()
		end
		self._ActiveSounds[ id ] = nil
	end
end

function ENT:HandleEngineSounds( vehicle )
	local ply = LocalPlayer()
	local pod = ply:GetVehicle()
	local Throttle = vehicle:GetThrottle() - vehicle:GetThrustStrenght() * vehicle:GetThrottle() * 0.5
	local Doppler = vehicle:CalcDoppler( ply )

	local DrivingMe = ply:lvsGetVehicle() == vehicle

	local FirstPerson = false
	if IsValid( pod ) then
		local ThirdPerson = pod:GetThirdPersonMode()

		if ThirdPerson ~= self._lvsoldTP then
			self._lvsoldTP = ThirdPerson
			VolumeSetNow = DrivingMe
		end

		FirstPerson = DrivingMe and not ThirdPerson
	end

	if DrivingMe ~= self._lvsoldDrivingMe then
		self._lvsoldDrivingMe = DrivingMe

		self:StopSounds()

		self._oldEnActive = nil

		return
	end

	local FT = RealFrameTime()

	self._smTHR = self._smTHR and self._smTHR + (Throttle - self._smTHR) * FT or 0

	for id, sound in pairs( self._ActiveSounds ) do
		if not sound then continue end

		local data = self.EngineSounds[ id ]

		local Pitch = math.Clamp( data.Pitch + self._smTHR * data.PitchMul, data.PitchMin, data.PitchMax )
		local PitchMul = data.UseDoppler and Doppler or 1

		local InActive = self._smTHR > data.FadeOut or self._smTHR < data.FadeIn
		if data.FadeOut >= 1 and self._smTHR > 1 then
			InActive = false
		end

		local Volume = InActive and 0 or LVS.EngineVolume

		if data.VolumeMin and data.VolumeMax and not InActive then
			Volume = math.max(self._smTHR - data.VolumeMin,0) / (1 - data.VolumeMin) * data.VolumeMax * LVS.EngineVolume
		end

		if istable( sound ) then
			sound.ext:ChangePitch( math.Clamp( Pitch * PitchMul, 0, 255 ), 0.2 )
			if sound.int then sound.int:ChangePitch( math.Clamp( Pitch, 0, 255 ), 0.2 ) end

			local fadespeed = VolumeSetNow and 0 or data.FadeSpeed

			if FirstPerson then
				sound.ext:ChangeVolume( 0, 0 )

				if vehicle:HasActiveSoundEmitters() then
					Volume = Volume * 0.25
					fadespeed = fadespeed * 0.5
				end

				if sound.int then sound.int:ChangeVolume( Volume, fadespeed ) end
			else
				sound.ext:ChangeVolume( Volume, fadespeed )
				if sound.int then sound.int:ChangeVolume( 0, 0 ) end
			end
		else
			sound:ChangePitch( math.Clamp( Pitch * PitchMul, 0, 255 ), 0.2 )
			sound:ChangeVolume( Volume, data.FadeSpeed )
		end
	end
end

function ENT:OnEngineActiveChanged( Active )
	if not Active then self:StopSounds() return end

	local ply = LocalPlayer()
	local DrivingMe = ply:lvsGetVehicle() == self:GetBase()

	for id, data in pairs( self.EngineSounds ) do
		if not isstring( data.sound ) then continue end

		self.EngineSounds[ id ].Pitch = data.Pitch or 80
		self.EngineSounds[ id ].PitchMin = data.PitchMin or 0
		self.EngineSounds[ id ].PitchMax = data.PitchMax or 255
		self.EngineSounds[ id ].PitchMul = data.PitchMul or 100
		self.EngineSounds[ id ].UseDoppler = data.UseDoppler ~= false
		self.EngineSounds[ id ].FadeIn = data.FadeIn or 0
		self.EngineSounds[ id ].FadeOut = data.FadeOut or 1
		self.EngineSounds[ id ].FadeSpeed = data.FadeSpeed or 1.5
		self.EngineSounds[ id ].SoundLevel = data.SoundLevel or 85

		if data.sound_int and data.sound_int ~= data.sound and DrivingMe then
			local sound = CreateSound( self, data.sound )
			sound:SetSoundLevel( data.SoundLevel )
			sound:PlayEx(0,100)

			if data.sound_int == "" then
				self._ActiveSounds[ id ] = {
					ext = sound,
					int = false,
				}
			else
				local sound_interior = CreateSound( self, data.sound_int )
				sound_interior:SetSoundLevel( data.SoundLevel )
				sound_interior:PlayEx(0,100)

				self._ActiveSounds[ id ] = {
					ext = sound,
					int = sound_interior,
				}
			end
		else
			local sound = CreateSound( self, data.sound )
			sound:SetSoundLevel( data.SoundLevel )
			sound:PlayEx(0,100)

			self._ActiveSounds[ id ] = sound
		end
	end
end

function ENT:Think()
	local vehicle = self:GetBase()

	if not IsValid( vehicle ) then return end

	if not self.EngineSounds then
		self.EngineSounds = vehicle.EngineSounds

		return
	end

	local EngineActive = vehicle:GetEngineActive()

	if self._oldEnActive ~= EngineActive then
		self._oldEnActive = EngineActive
		self:OnEngineActiveChanged( EngineActive )
	end

	if EngineActive then
		self:HandleEngineSounds( vehicle )
	else
		self._smTHR = 0
	end
end

function ENT:OnRemove()
	self:StopSounds()
end

function ENT:Draw()
end

function ENT:DrawTranslucent()
end

--addons/egm_lvs_ships/lua/entities/lvs_starfighter_ywing/cl_init.lua:
include("shared.lua")

ENT.EngineColor = Color( 255, 50, 0, 255)
ENT.EngineGlow = Material( "sprites/light_glow02_add" )

function ENT:OnSpawn()
	self:SpawnGunner()

	self:RegisterTrail(Vector(-500, 250, 50), 0, 200, 2, 1000, 150)
	self:RegisterTrail(Vector(-500, -250, 50), 0, 200, 2, 1000, 150)
end

function ENT:SpawnGunner()
	self.Turret = ents.CreateClientProp("prop_dynamic")
	self.Turret:SetModel("models/ywing_costum/ywing_btlb_turret.mdl")
	self.Turret:SetPos(self:LocalToWorld(Vector(218,0,85)))
	self.Turret:SetAngles(self:GetAngles())
	self.Turret:SetParent(self)
	self.Turret:Spawn()

	self.Guns = ents.CreateClientProp("prop_dynamic")
	self.Guns:SetModel("models/ywing_costum/ywing_btlb_guns.mdl")
	self.Guns:SetPos(self.Turret:GetPos() + Vector(0, 0, 8))
	self.Guns:SetAngles(self.Turret:GetAngles())
	self.Guns:SetParent(self.Turret)
	self.Guns:Spawn()
end

function ENT:OnFrame()
	self:AnimAstromech()
	self:AnimGunner()

	if not IsValid(self.Turret) or not IsValid(self.Guns) then
		self:SpawnGunner()
	end
end

function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	local Size = 120 + self:GetThrottle() * 100 + self:GetBoost()
	render.SetMaterial(self.EngineGlow)
	render.DrawSprite(self:LocalToWorld( Vector(-530,205,50) ), Size, Size, self.EngineColor)
	render.DrawSprite(self:LocalToWorld( Vector(-530,-205,50) ), Size, Size, self.EngineColor)
end

function ENT:AnimAstromech()
	local T = CurTime()

	if (self.nextAstro or 0) < T then
		self.nextAstro = T + math.Rand(0.5,2)
		self.AstroAng = math.Rand(-180,180)

		local HasShield = self:GetShield() > 0

		if self.OldShield == true and not HasShield then
			self:EmitSound("lvs/vehicles/naboo_n1_starfighter/astromech/shieldsdown" .. math.random(1,2) .. ".ogg", 50)
		else
			if math.random(0, 4) == 3 then
				self:EmitSound("lvs/vehicles/naboo_n1_starfighter/astromech/"..math.random(1,11) .. ".ogg", 50)
			end
		end

		self.OldShield = HasShield
	end

	self.smastro = self.smastro and (self.smastro + ((self.AstroAng or 0) - self.smastro) * RealFrameTime() * 10) or 0

	self:ManipulateBoneAngles(1, Angle(self.smastro, 0, 0))
end

function ENT:AnimGunner()
	local Pod = self:GetTailGunnerSeat()
	if not IsValid(Pod) then return end

	local weapon = Pod:lvsGetWeapon()
	if not IsValid(weapon) then return end

	local Driver = Pod:GetDriver()
	if not IsValid(Driver) then return end

	local EyeAngles = Driver:LocalEyeAngles()
	EyeAngles:RotateAroundAxis(EyeAngles:Up(), 90)

	local Yaw = EyeAngles.y
	local Pitch = math.Clamp(-EyeAngles.r, 5, 50)

	self.Guns:SetAngles(self.Turret:LocalToWorldAngles(Angle(Pitch, 0, 0)))
	self.Turret:SetAngles(self:LocalToWorldAngles(Angle(0, Yaw, 0)))
end

function ENT:OnRemove()
	if IsValid(self.Guns) then
		self.Guns:Remove()
	end

	if IsValid(self.Turret) then
		self.Turret:Remove()
	end
end
--addons/egm_lvs_ground/lua/entities/lvs_walker_atrt/cl_init.lua:
include("shared.lua")

function ENT:OnFrame()
	self:AnimGunner()
end

function ENT:CalcViewOverride( ply, pos, angles, fov, pod )
	if ply == self:GetDriver() and not pod:GetThirdPersonMode() then
		return pos + self:GetForward() * 60 - self:GetUp() * 30, angles, fov
	end

	return pos, angles, fov
end

function ENT:AnimGunner()
	if IsValid(self:GetDriver()) then
		local Aim = self:GetDriver():EyeAngles()

		local AimX = math.Clamp(Aim.x, -30, 30)
		local AimZ = math.Clamp(Aim.y, 10, 160)

		self:ManipulateBoneAngles(self:LookupBone("turret_x"), Angle(0, 0, AimX))
		self:ManipulateBoneAngles(self:LookupBone("turret_z"), Angle(AimZ - 90, 0, 0))

		return true
	else
		self:ManipulateBoneAngles(self:LookupBone("turret_x"), Angle(0,0,0))
		self:ManipulateBoneAngles(self:LookupBone("turret_z"), Angle(0,0,0))
	end
end

ENT.IconHealth = Material("lvs/heart.png")
ENT.IconShield = Material("lvs/shield.png")
ENT.IconEngine = Material("lvs/engine.png")

function ENT:LVSHudPaintInfoText(X, Y, W, H, ScrX, ScrY, ply)
	local maxHealth = self:GetMaxHP()
	local health = math.Round((self:GetHP() * 100) / maxHealth)

	surface.SetMaterial(self.IconHealth)
	surface.SetDrawColor(0, 0, 0, 200)
	surface.DrawTexturedRectRotated(X * 1.021, Y * 1.045, H * 0.5, H * 0.5, 0)
	surface.SetDrawColor(color_white)
	surface.DrawTexturedRectRotated(X * 1.02, Y * 1.045, H * 0.5, H * 0.5, 0)

	draw.DrawText(health .. "%", "LVS_FONT_HUD_LARGE", X + 50, Y + 20, color_white, TEXT_ALIGN_LEFT)

	local maxShield = self:GetMaxShield()
	local shield = math.Round((self:GetShield() * 100) / maxShield)

	surface.SetMaterial(self.IconShield)
	surface.SetDrawColor(0, 0, 0, 200)
	surface.DrawTexturedRectRotated(X * 1.126, Y * 1.045, H * 0.5, H * 0.5, 0)
	surface.SetDrawColor(color_white)
	surface.DrawTexturedRectRotated(X * 1.125, Y * 1.045, H * 0.5, H * 0.5, 0)

	if shield >= 0 then
		draw.DrawText(shield .. "%", "LVS_FONT_HUD_LARGE", X + 200, Y + 20, color_white, TEXT_ALIGN_LEFT)
	else
		draw.DrawText("0 %", "LVS_FONT_HUD_LARGE", X + 200, Y + 20, color_white, TEXT_ALIGN_LEFT)
	end

	local kmh = math.Round(self:GetVelocity():Length() * 0.09144,0)
	draw.DrawText("km/h ", "LVS_FONT", X + 370, Y + 35, color_white, TEXT_ALIGN_RIGHT )
	draw.DrawText(kmh, "LVS_FONT_HUD_LARGE", X + 370, Y + 20, color_white, TEXT_ALIGN_LEFT )

	if ply ~= self:GetDriver() then return end

	local Vel = self:GetVelocity():Length()

	local hX = X + W - H * 0.5
	local hY = Y + H * 0.25 + H * 0.25

	surface.SetMaterial(self.IconEngine)
	surface.SetDrawColor(0, 0, 0, 200)
	surface.DrawTexturedRectRotated(hX * 1.007, hY * 1.008, H * 0.75, H * 0.75, 0)
	surface.SetDrawColor(color_white)
	surface.DrawTexturedRectRotated(hX * 1.008, hY * 1.008, H * 0.75, H * 0.75, 0)

	if not self:GetEngineActive() then
		draw.SimpleText("X" , "LVS_FONT",  hX * 1.007, hY * 1.008, Color(0, 0, 0, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
	else
		local Throttle = Vel / 150
		self:LVSDrawCircle(hX * 1.007, hY * 1.008, H * 0.35, math.min(Throttle, 1))
	end
end

function ENT:LVSHudPaint(X, Y, ply)
	if self:GetIsCarried() then return end

	local Pos2D = self:GetEyeTrace().HitPos:ToScreen()

	local dir = self:GetAimVector()
	if self:AngleBetweenNormal(dir, self:GetForward()) > 60 then return true end
	if self:AngleBetweenNormal(dir, self:GetUp()) > 120 then return true end

	local InRange = self:AngleBetweenNormal(dir, self:GetForward()) > 60 or self:AngleBetweenNormal(dir, self:GetUp()) > 120

	local col = InRange and white or red
	self:PaintCrosshairCenter(Pos2D, col)
	self:PaintCrosshairOuter(Pos2D, col)
	self:LVSPaintHitMarker(Pos2D)
end

--addons/egm_lvs_ground/lua/entities/lvs_walker_atte/cl_init.lua:
include("shared.lua")
include("cl_ikfunctions.lua" )
include("cl_camera.lua" )
include("cl_legs.lua" )
include("cl_prediction.lua" )
include("sh_turret.lua")
include("sh_gunner.lua")

function ENT:DamageFX()
	self.nextDFX = self.nextDFX or 0

	if self.nextDFX < CurTime() then
		self.nextDFX = CurTime() + 0.05

		if self:GetIsRagdoll() then
			if math.random(0,45) < 3 then
				if math.random(1,2) == 1 then
					local Pos = self:LocalToWorld( Vector(0,0,70) + VectorRand() * 80 )
					local effectdata = EffectData()
						effectdata:SetOrigin( Pos )
					util.Effect( "cball_explode", effectdata, true, true )
					
					sound.Play( "lvs/vehicles/atte/spark"..math.random(1,4)..".ogg", Pos, 75 )
				end
			end
		end

		local HP = self:GetHP()
		local MaxHP = self:GetMaxHP()

		if HP > MaxHP * 0.5 then return end

		local effectdata = EffectData()
		effectdata:SetOrigin( self:LocalToWorld( Vector(0,0,160) ) )
		effectdata:SetEntity( self )
		util.Effect( "lvs_engine_blacksmoke", effectdata )

		if HP <= MaxHP * 0.25 then
			local effectdata = EffectData()
			effectdata:SetOrigin( self:LocalToWorld( Vector(0,20,180) ) )
			effectdata:SetNormal( self:GetUp() )
			effectdata:SetMagnitude( math.Rand(1,3) )
			effectdata:SetEntity( self )
			util.Effect( "lvs_exhaust_fire", effectdata )

			local effectdata = EffectData()
			effectdata:SetOrigin( self:LocalToWorld( Vector(0,-20,180) ) )
			effectdata:SetNormal( self:GetUp() )
			effectdata:SetMagnitude( math.Rand(1,3) )
			effectdata:SetEntity( self )
			util.Effect( "lvs_exhaust_fire", effectdata )
		end
	end
end

local zoom = 0
local zoom_mat = Material( "vgui/zoom" )

local white = Color(255,255,255,255)
local red = Color(255,0,0,255)

function ENT:PaintZoom( X, Y, ply )
	local TargetZoom = ply:lvsKeyDown( "ZOOM" ) and 1 or 0

	zoom = zoom + (TargetZoom - zoom) * RealFrameTime() * 10

	surface.SetDrawColor( Color(255,255,255,255 * zoom) )
	surface.SetMaterial(zoom_mat ) 
	surface.DrawTexturedRectRotated( X + X * 0.5, Y * 0.5, X, Y, 0 )
	surface.DrawTexturedRectRotated( X + X * 0.5, Y + Y * 0.5, Y, X, 270 )
	surface.DrawTexturedRectRotated( X * 0.5, Y * 0.5, Y, X, 90 )
	surface.DrawTexturedRectRotated( X * 0.5, Y + Y * 0.5, X, Y, 180 )
end

function ENT:LVSHudPaint( X, Y, ply )
	if self:GetIsCarried() then return end

	if ply ~= self:GetDriver() then
		local pod = ply:GetVehicle()

		if pod == self:GetTurretSeat() or pod == self:GetGunnerSeat() then
			self:PaintZoom( X, Y, ply )
		end

		return
	end

	local Pos2D = self:GetEyeTrace().HitPos:ToScreen()

	local _,_, InRange = self:GetAimAngles()

	local Col = InRange and white or red

	self:PaintCrosshairCenter( Pos2D, Col )
	self:PaintCrosshairOuter( Pos2D, Col )
	self:LVSPaintHitMarker( Pos2D )

	self:PaintZoom( X, Y, ply )
end
ENT.IconHealth = Material("lvs/heart.png")
ENT.IconShield = Material("lvs/shield.png")
ENT.IconEngine = Material("lvs/engine.png")

function ENT:LVSHudPaintInfoText(X, Y, W, H, ScrX, ScrY, ply)
	local maxHealth = self:GetMaxHP()
	local health = math.Round((self:GetHP() * 100) / maxHealth)

	surface.SetMaterial(self.IconHealth)
	surface.SetDrawColor(0, 0, 0, 200)
	surface.DrawTexturedRectRotated(X * 1.021, Y * 1.045, H * 0.5, H * 0.5, 0)
	surface.SetDrawColor(color_white)
	surface.DrawTexturedRectRotated(X * 1.02, Y * 1.045, H * 0.5, H * 0.5, 0)

	draw.DrawText(health .. "%", "LVS_FONT_HUD_LARGE", X + 50, Y + 20, color_white, TEXT_ALIGN_LEFT)

	local maxShield = self:GetMaxShield()
	local shield = math.Round((self:GetShield() * 100) / maxShield)

	surface.SetMaterial(self.IconShield)
	surface.SetDrawColor(0, 0, 0, 200)
	surface.DrawTexturedRectRotated(X * 1.126, Y * 1.045, H * 0.5, H * 0.5, 0)
	surface.SetDrawColor(color_white)
	surface.DrawTexturedRectRotated(X * 1.125, Y * 1.045, H * 0.5, H * 0.5, 0)

	if shield >= 0 then
		draw.DrawText(shield .. "%", "LVS_FONT_HUD_LARGE", X + 200, Y + 20, color_white, TEXT_ALIGN_LEFT)
	else
		draw.DrawText("0 %", "LVS_FONT_HUD_LARGE", X + 200, Y + 20, color_white, TEXT_ALIGN_LEFT)
	end

	local kmh = math.Round(self:GetVelocity():Length() * 0.09144,0)
	draw.DrawText("km/h ", "LVS_FONT", X + 370, Y + 35, color_white, TEXT_ALIGN_RIGHT )
	draw.DrawText(kmh, "LVS_FONT_HUD_LARGE", X + 370, Y + 20, color_white, TEXT_ALIGN_LEFT )

	if ply ~= self:GetDriver() then return end

	local Vel = self:GetVelocity():Length()

	local hX = X + W - H * 0.5
	local hY = Y + H * 0.25 + H * 0.25

	surface.SetMaterial(self.IconEngine)
	surface.SetDrawColor(0, 0, 0, 200)
	surface.DrawTexturedRectRotated(hX * 1.007, hY * 1.008, H * 0.75, H * 0.75, 0)
	surface.SetDrawColor(color_white)
	surface.DrawTexturedRectRotated(hX * 1.008, hY * 1.008, H * 0.75, H * 0.75, 0)

	if not self:GetEngineActive() or self:GetDisabled() then
		draw.SimpleText("X" , "LVS_FONT",  hX * 1.007, hY * 1.008, Color(0, 0, 0, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
	else
		local Throttle = Vel / 150
		self:LVSDrawCircle(hX * 1.007, hY * 1.008, H * 0.35, math.min(Throttle, 1))
	end
end

function ENT:RemoveLight()
	if not IsValid(self.light) then return end

	self.light:Remove()
	self.light = nil
end

function ENT:CreateLight()
	local lamp = ProjectedTexture()
	lamp:SetTexture("effects/flashlight001")
	lamp:SetFarZ(4096)
	lamp:SetNearZ(64)
	lamp:SetFOV(60)
	lamp:SetColor(Color(255, 248, 208))
	lamp:SetBrightness(10)

	local lightPos = self:GetPos() + self:GetForward() * 300 + self:GetUp() * 200

	lamp:SetPos(lightPos)
	lamp:SetAngles(self:GetAngles())
	lamp:Update()
	self.light = lamp
end

function ENT:UpdateLight()
	if self:GetIsLightOn() and not IsValid(self.light) then
		self:CreateLight()
	elseif not self:GetIsLightOn() and IsValid(self.light) then
		self:RemoveLight()
	end

	if not IsValid(self.light) then return end

	local lightPos = self:GetPos() + self:GetForward() * 300 + self:GetUp() * 200
	local lightAng = Angle(0, 0, 0)
	lightAng.p = math.Remap(self:GetPoseParameter("frontgun_pitch"), 0, 1, -45, 45)
	lightAng.r = 0
	lightAng.y = math.Remap(self:GetPoseParameter("frontgun_yaw"), 0, 1, -12, 12)
	self.lightAng = self:LocalToWorldAngles(lightAng)

	self.light:SetPos(lightPos)
	self.light:SetAngles(self.lightAng)
	self.light:Update()
end

function ENT:OnRemove()
	self:RemoveLight()
	self:LegClearAll()
end
--addons/egm_lvs_ground/lua/entities/lvs_walker_atte/cl_legs.lua:

function ENT:OnFrame()
	self:PredictPoseParamaters()
	self:UpdateLight()
	self:DamageFX()

	local RearEnt = self:GetRearEntity()

	if not IsValid( RearEnt ) then return end

	if self:GetIsRagdoll() then
		self:LegClearAll()
		RearEnt:LegClearAll()

		return
	end

	local Vel = self:GetVelocity()
	local FT = math.min(FrameTime(), 0.08) -- if fps lower than 12, clamp the frametime to avoid spazzing.
	local Rate = FT * 20

	-- sync with server animation when not moving
	if Vel:Length() < 10 then
		self.Move = self:GetMove()
	else
		self.Move = self.Move and self.Move + self:WorldToLocal(self:GetPos() + Vel).x * FT * 1.8 or 0
	end

	-- Walking Parameters	
	local Cycles = {self.Move, self.Move + 180, self.Move, self.Move + 180, self.Move + 270, self.Move + 90,}

	-- FrontLeft
	-- FrontRight
	-- RearRight
	-- RearLeft
	-- MidLeft
	-- MidRight
	local IsMoving = self:GetIsMoving()

	-- Reset Legs to idle if carried or moving
	if self:GetIsCarried() then
		self.TRACEPOS1 = self:LocalToWorld(Vector(200, 70, 180))
		self.TRACEPOS2 = self:LocalToWorld(Vector(200, -70, 180))
		self.TRACEPOS3 = RearEnt:LocalToWorld(Vector(-160, -70, 180))
		self.TRACEPOS4 = RearEnt:LocalToWorld(Vector(-160, 70, 180))
		self.TRACEPOS5 = RearEnt:LocalToWorld(Vector(0, -80, 180))
		self.TRACEPOS6 = RearEnt:LocalToWorld(Vector(0, 80, 180))

		for k, _ in pairs(Cycles) do
			Cycles[k] = 0
		end

		IsMoving = true
	elseif not IsMoving then
		Cycles[1] = 0
		Cycles[2] = 0
		Cycles[3] = 180
		Cycles[4] = 180
		Cycles[5] = 90
		Cycles[6] = 90
	end

	local Legs = {
		-- Front Left
		{
			GlobalOffset = Vector(216.88, 46, 163.42),
			LegShift = self:GetRight() * -32,
			LegLift = 55,
			Mdl1 = "models/kingpommes/starwars/atte/lfs_leg3_front_l.mdl",
			Mdl2 = "models/kingpommes/starwars/atte/lfs_leg2.mdl",
			Mdl3 = "models/kingpommes/starwars/atte/lfs_leg1_l.mdl",
			Angle1 = Angle(-69, 245, 25),
			Angle2 = Angle(-80, -108, 0),
			Angle3 = Angle(180, 180, 180),
			Offset1 = Vector(0, 0, 0),
			Offset2 = Vector(0, 9.5, 0),
			Offset3 = Vector(0, 24, 0),
			Lenght1 = 77,
			Lenght2 = 73,
			GlobalAngle = Angle(90, 10, 0),
		},
		-- Front Right
		{
			GlobalOffset = Vector(216.88, -46, 163.42),
			LegShift = self:GetRight() * 32,
			LegLift = 55,
			Mdl1 = "models/kingpommes/starwars/atte/lfs_leg3_front_r.mdl",
			Mdl2 = "models/kingpommes/starwars/atte/lfs_leg2.mdl",
			Mdl3 = "models/kingpommes/starwars/atte/lfs_leg1_r.mdl",
			Angle1 = Angle(-69, 110, -20),
			Angle2 = Angle(-80, 108, 0),
			Angle3 = Angle(0, 0, 0),
			Offset1 = Vector(0, 0, 0),
			Offset2 = Vector(0, -9.5, 0),
			Offset3 = Vector(0, -24, 0),
			Lenght1 = 77,
			Lenght2 = 73,
			GlobalAngle = Angle(90, -10, 0),
		},
		-- Rear Left
		{
			GlobalOffset = Vector(-150.42, -84.54, 154.13),
			LegShift = self:GetRight() * 1,
			LegLift = 58,
			Mdl1 = "models/kingpommes/starwars/atte/lfs_leg3_rear.mdl",
			Mdl2 = "models/kingpommes/starwars/atte/lfs_leg2.mdl",
			Mdl3 = "models/kingpommes/starwars/atte/lfs_leg1_r.mdl",
			Angle1 = Angle(-90, -180, -270),
			Angle2 = Angle(-90, -180, -270),
			Angle3 = Angle(-180, 180, -180),
			Offset1 = Vector(0, -16, 0),
			Offset2 = Vector(0, -7, 0),
			Offset3 = Vector(0, -27, 0),
			Lenght1 = 55,
			Lenght2 = 75,
			GlobalAngle = Angle(90, 180, 0),
		},
		-- Rear Right
		{
			GlobalOffset = Vector(-150.42, 84.54, 154.13),
			LegShift = self:GetRight() * -1,
			LegLift = 58,
			Mdl1 = "models/kingpommes/starwars/atte/lfs_leg3_rear.mdl",
			Mdl2 = "models/kingpommes/starwars/atte/lfs_leg2.mdl",
			Mdl3 = "models/kingpommes/starwars/atte/lfs_leg1_l.mdl",
			Angle1 = Angle(-90, 180, -90),
			Angle2 = Angle(-90, 180, -90),
			Angle3 = Angle(0, 0, 0),
			Offset1 = Vector(0, 16, 0),
			Offset2 = Vector(0, 7, 0),
			Offset3 = Vector(0, 27, 0),
			Lenght1 = 55,
			Lenght2 = 75,
			GlobalAngle = Angle(90, -180, 0),
		},
		-- Middle Right
		{
			GlobalOffset = Vector(-8.86, -53.29, 171.73),
			LegShift = self:GetRight() * 88,
			LegLift = 67,
			Mdl2 = "models/kingpommes/starwars/atte/lfs_bigleg2.mdl",
			Mdl3 = "models/kingpommes/starwars/atte/lfs_bigleg1_r.mdl",
			Angle2 = Angle(-90, -86, -90),
			Angle3 = Angle(-180, 175, -180),
			Offset2 = Vector(0, 0, 0),
			Offset3 = Vector(0, -8, 0),
			Lenght1 = 65,
			Lenght2 = 112,
			GlobalAngle = Angle(135, 100, 0),
		},
		-- Middle Left
		{
			GlobalOffset = Vector(-8.86, 53.29, 171.73),
			LegShift = self:GetRight() * -88,
			LegLift = 67,
			Mdl2 = "models/kingpommes/starwars/atte/lfs_bigleg2.mdl",
			Mdl3 = "models/kingpommes/starwars/atte/lfs_bigleg1_l.mdl",
			Angle2 = Angle(-90, 86, 90),
			Angle3 = Angle(0, 5, 0),
			Offset2 = Vector(0, 0, 0),
			Offset3 = Vector(0, 8, 0),
			Lenght1 = 65,
			Lenght2 = 112,
			GlobalAngle = Angle(135, -100, 0),
		},
	}

	local TRACEPOS = {self.TRACEPOS1, self.TRACEPOS2, self.TRACEPOS3, self.TRACEPOS4, self.TRACEPOS5, self.TRACEPOS6,}

	local FSOG = {self.FSOG1, self.FSOG2, self.FSOG3, self.FSOG4, self.FSOG5, self.FSOG6,}

	local oldFSOG = {self.oldFSOG1, self.oldFSOG2, self.oldFSOG3, self.oldFSOG4, self.oldFSOG5, self.oldFSOG6,}

	local GroupCollide = {
		[COLLISION_GROUP_DEBRIS] = true,
		[COLLISION_GROUP_DEBRIS_TRIGGER] = true,
		[COLLISION_GROUP_PLAYER] = true,
		[COLLISION_GROUP_WEAPON] = true,
		[COLLISION_GROUP_VEHICLE_CLIP] = true,
		[COLLISION_GROUP_WORLD] = true,
	}

	local Stride = 40
	local Lift = 20
	local Up = self:GetUp()
	local Forward = self:GetForward()
	local Right = self:GetRight()
	local ParentEnt = self

	for k, v in pairs(Legs) do
		if k > 2 then
			Forward = RearEnt:GetForward()
			Right = RearEnt:GetRight()
			Up = RearEnt:GetUp()
			ParentEnt = RearEnt
		end

		local X = 20 + math.cos(math.rad(Cycles[k])) * Stride
		local Z = math.max(math.sin(math.rad(-Cycles[k])), 0) * Lift
		local STARTPOS = ParentEnt:LocalToWorld(v["GlobalOffset"])
		TRACEPOS[k] = TRACEPOS[k] and TRACEPOS[k] or STARTPOS

		if Z > 0 or not IsMoving then
			TRACEPOS[k] = TRACEPOS[k] + (STARTPOS + Forward * X - TRACEPOS[k]) * Rate
			FSOG[k] = false
		else
			FSOG[k] = true
		end

		local ENDPOS = util.TraceLine({
			start = TRACEPOS[k] - Up * 50,
			endpos = TRACEPOS[k] - Up * 160,
			filter = function(ent)
				if ent == self or ent == RearEnt or GroupCollide[ent:GetCollisionGroup()] then return false end

				return true
			end,
		}).HitPos + v["LegShift"] + Vector(0, 0, v["LegLift"] + Z)

		if FSOG[k] ~= oldFSOG[k] then
			oldFSOG[k] = FSOG[k]

			if FSOG[k] then
				if k == 5 then
					ParentEnt:EmitSound("ATTE_STEP_HARD1")
				elseif k == 6 then
					ParentEnt:EmitSound("ATTE_STEP_HARD2")
				else
					ParentEnt:EmitSound("ATTE_STEP_SOFT")
				end

				local effectdata = EffectData()
				effectdata:SetOrigin(ENDPOS - Vector(0, 0, v["LegLift"]) - self:GetRight() * v["Offset3"].y)
				util.Effect("lvs_walker_stomp", effectdata)
			end
		end

		local ATTACHMENTS = {}

		if k == 5 or k == 6 then
			ATTACHMENTS = {
				Leg2 = {
					MDL = v["Mdl2"],
					Ang = v["Angle2"],
					Pos = v["Offset2"]
				},
				Foot = {
					MDL = v["Mdl3"],
					Ang = v["Angle3"],
					Pos = v["Offset3"]
				},
			}
		else
			ATTACHMENTS = {
				Leg1 = {
					MDL = v["Mdl1"],
					Ang = v["Angle1"],
					Pos = v["Offset1"]
				},
				Leg2 = {
					MDL = v["Mdl2"],
					Ang = v["Angle2"],
					Pos = v["Offset2"]
				},
				Foot = {
					MDL = v["Mdl3"],
					Ang = v["Angle3"],
					Pos = v["Offset3"]
				},
			}
		end

		ParentEnt:GetLegEnts(k, v["Lenght1"], v["Lenght2"], ParentEnt:LocalToWorldAngles(v["GlobalAngle"]), STARTPOS, ENDPOS, ATTACHMENTS)
		-- adjust the toe angle
		ParentEnt.IK_Joints[k].Attachment3:SetPoseParameter("toes", math.Remap(Z, 0, 20, 0, 45))

		-- change feet skin
		if k ~= 5 and k ~= 6 then
			ParentEnt.IK_Joints[k].Attachment1:SetSkin(self:GetSkin())
		end
		ParentEnt.IK_Joints[k].Attachment2:SetSkin(self:GetSkin())
		ParentEnt.IK_Joints[k].Attachment3:SetSkin(self:GetSkin())

		-- adjust balljoint shift
		if k == 5 then
			RearEnt:SetPoseParameter("shift_right", math.Remap(Z, 0, 20, -8, 16))
		elseif k == 6 then
			RearEnt:SetPoseParameter("shift_left", math.Remap(Z, 0, 20, -8, 16))
		end
	end

	for _, _ in pairs(TRACEPOS) do
		self.TRACEPOS1 = TRACEPOS[1]
		self.TRACEPOS2 = TRACEPOS[2]
		self.TRACEPOS3 = TRACEPOS[3]
		self.TRACEPOS4 = TRACEPOS[4]
		self.TRACEPOS5 = TRACEPOS[5]
		self.TRACEPOS6 = TRACEPOS[6]
		self.FSOG1 = FSOG[1]
		self.FSOG2 = FSOG[2]
		self.FSOG3 = FSOG[3]
		self.FSOG4 = FSOG[4]
		self.FSOG5 = FSOG[5]
		self.FSOG6 = FSOG[6]
		self.oldFSOG1 = oldFSOG[1]
		self.oldFSOG2 = oldFSOG[2]
		self.oldFSOG3 = oldFSOG[3]
		self.oldFSOG4 = oldFSOG[4]
		self.oldFSOG5 = oldFSOG[5]
		self.oldFSOG6 = oldFSOG[6]
	end
end
--addons/egm_lvs_ground/lua/entities/lvs_walker_atte/sh_gunner.lua:

function ENT:GetGunnerAimAng( ent, base, RearEnt )
	local trace = ent:GetEyeTrace()

	local Pos = RearEnt:LocalToWorld( Vector(-208,0,170) )
	local wAng = (trace.HitPos - Pos):GetNormalized():Angle()

	local _, Ang = WorldToLocal( Pos, wAng, Pos, RearEnt:LocalToWorldAngles( Angle(0,180,0) ) )

	return Ang, trace.HitPos, (Ang.p < 30 and Ang.p > -10 and math.abs( Ang.y ) < 60)
end

local white = Color(255,255,255,255)
local red = Color(255,0,0,255)

function ENT:InitGunner()
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Delay = 0.3
	weapon.HeatRateUp = 0.2
	weapon.HeatRateDown = 0.2
	weapon.OnOverheat = function( ent ) end
	weapon.Attack = function( ent )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		if base:GetIsCarried() then base:SetHeat( 0 ) return true end

		local RearEnt = base:GetRearEntity()

		if not IsValid( RearEnt ) then return end

		local _, AimPos, InRange = base:GetGunnerAimAng( ent, base, RearEnt )

		if not InRange then return true end

		local ID1 = RearEnt:LookupAttachment( "muzzle_right" )
		local ID2 = RearEnt:LookupAttachment( "muzzle_left" )

		local Muzzle1 = RearEnt:GetAttachment( ID1 )
		local Muzzle2 = RearEnt:GetAttachment( ID2 )

		if not Muzzle1 or not Muzzle2 then return end

		local FirePos = {
			[1] = Muzzle1,
			[2] = Muzzle2
		}

		ent.FireIndex = ent.FireIndex and ent.FireIndex + 1 or 1

		if ent.FireIndex > #FirePos then
			ent.FireIndex = 1
		end

		local Pos = FirePos[ent.FireIndex].Pos
		local Dir = (AimPos - Pos):GetNormalized()

		local bullet = {}
		bullet.Src 	= Pos
		bullet.Dir 	= Dir
		bullet.Spread 	= Vector( 0.01,  0.01, 0 )
		bullet.TracerName = "lvs_laser_green_short"
		bullet.Force	= 10
		bullet.HullSize 	= 30
		bullet.Damage	= 900
		bullet.Velocity = 8000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(0,255,0) ) 
				effectdata:SetOrigin( tr.HitPos )
			util.Effect( "lvs_laser_explosion", effectdata )
		end
		ent:LVSFireBullet( bullet )

		local effectdata = EffectData()
		effectdata:SetStart( Vector(50,255,50) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( Dir )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )

		ent:TakeAmmo()

		base.SNDRear:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
	end
	weapon.OnThink = function( ent, active )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		if base:GetIsCarried() then return end

		local RearEnt = base:GetRearEntity()

		if not IsValid( RearEnt ) then return end
	
		local Ang, HitPos, InRange = base:GetGunnerAimAng( ent, base, RearEnt )

		RearEnt:SetPoseParameter("gun_pitch", math.Clamp(Ang.p, -10, 30))
		RearEnt:SetPoseParameter("gun_yaw", Ang.y)
	end
	weapon.CalcView = function( ent, ply, pos, angles, fov, pod )
		local view = {}
		view.origin = pos
		view.angles = angles
		view.fov = fov
		view.drawviewer = false

		local mn = self:OBBMins()
		local mx = self:OBBMaxs()
		local radius = (mn - mx):Length()
		local radius = radius + radius * pod:GetCameraDistance()

		local clamped_angles = pod:WorldToLocalAngles(angles)
		clamped_angles.p = math.max(clamped_angles.p, -20)
		clamped_angles = pod:LocalToWorldAngles(clamped_angles)

		local StartPos = self:LocalToWorld( Vector(-150,0,150) ) + clamped_angles:Up() * 150
		local EndPos = StartPos - clamped_angles:Forward() * radius + clamped_angles:Up() * radius * 0.2

		local WallOffset = 4

		local tr = util.TraceHull({
			start = StartPos,
			endpos = EndPos,
			filter = function( e )
				local c = e:GetClass()
				local collide = not c:StartWith("prop_physics") and not c:StartWith("prop_dynamic") and not c:StartWith("prop_ragdoll") and not e:IsVehicle() and not c:StartWith("gmod_") and not c:StartWith("lvs_") and not c:StartWith("player" ) and not e.LVS

				return collide
			end,
			mins = Vector( -WallOffset, -WallOffset, -WallOffset ),
			maxs = Vector( WallOffset, WallOffset, WallOffset ),
		})

		view.angles = angles + Angle(5,0,0)
		view.origin = tr.HitPos
		view.drawviewer = true

		if tr.Hit and  not tr.StartSolid then
			view.origin = view.origin + tr.HitNormal * WallOffset
		end

		return view
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		if base:GetIsCarried() then return end

		local RearEnt = base:GetRearEntity()

		if not IsValid( RearEnt ) then return end
	
		local _,AimPos, InRange = base:GetGunnerAimAng( ent, base, RearEnt )

		local Pos2D = AimPos:ToScreen()

		local Col = InRange and white or red

		self:PaintCrosshairCenter( Pos2D, Col )
		self:PaintCrosshairOuter( Pos2D, Col )
		self:LVSPaintHitMarker( Pos2D )
	end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end

	self:AddWeapon( weapon, 3 )
end
--addons/egm_lvs_ground/lua/entities/lvs_walker_hsd/cl_init.lua:
include("shared.lua")
include("cl_camera.lua")
include("cl_prediction.lua")
include("sh_weapons.lua")

function ENT:OnFrame()
	self:PredictPoseParamaters()
	self:ProjectorBeam()
	self:DamageFX()
end

function ENT:ProjectorBeam()
	local ProjectorBeam = self:GetProjectorBeam()

	if ProjectorBeam == self.OldProjectorBeam then return end

	self.OldProjectorBeam = ProjectorBeam

	if not ProjectorBeam then return end

	local effectdata = EffectData()
	effectdata:SetEntity( self )
	util.Effect( "lvs_hsd_dish_projector", effectdata )
end
	
function ENT:DamageFX()
	self.nextDFX = self.nextDFX or 0

	if self.nextDFX < CurTime() then
		self.nextDFX = CurTime() + 0.05

		if self:GetIsRagdoll() then
			if math.random(0,45) < 3 then
				if math.random(1,2) == 1 then
					local Pos = self:LocalToWorld( Vector(0,0,250) + VectorRand() * 80 )
					local effectdata = EffectData()
						effectdata:SetOrigin( Pos )
					util.Effect( "cball_explode", effectdata, true, true )
					
					sound.Play( "lvs/vehicles/atte/spark"..math.random(1,4)..".ogg", Pos, 75 )
				end
			end
		end

		local HP = self:GetHP()
		local MaxHP = self:GetMaxHP()

		if HP > MaxHP * 0.5 then return end

		local effectdata = EffectData()
			effectdata:SetOrigin( self:LocalToWorld( Vector(0,0,260) + VectorRand() * 80 ) )
			effectdata:SetEntity( self )
		util.Effect( "lvs_engine_blacksmoke", effectdata )

		if HP <= MaxHP * 0.25 then
			local effectdata = EffectData()
				effectdata:SetOrigin( self:LocalToWorld( Vector(0,90,210) ) )
				effectdata:SetNormal( self:GetUp() )
				effectdata:SetMagnitude( math.Rand(1,3) )
				effectdata:SetEntity( self )
			util.Effect( "lvs_exhaust_fire", effectdata )

			local effectdata = EffectData()
				effectdata:SetOrigin( self:LocalToWorld( Vector(0,-90,210) ) )
				effectdata:SetNormal( self:GetUp() )
				effectdata:SetMagnitude( math.Rand(1,3) )
				effectdata:SetEntity( self )
			util.Effect( "lvs_exhaust_fire", effectdata )
		end
	end
end

ENT.GlowPos1 = Vector(46,-2.89,294.88)
ENT.GlowPos2 = Vector(41.15,5.82,295.63)
ENT.GlowColor = Color( 255, 0, 0, 255)
ENT.GlowMaterial = Material( "sprites/light_glow02_add" )

function ENT:PreDrawTranslucent()

	if self:GetIsRagdoll() then return false end

	render.SetMaterial( self.GlowMaterial )
	render.DrawSprite( self:LocalToWorld( self.GlowPos1 ), 32, 32, self.GlowColor )
	render.DrawSprite( self:LocalToWorld( self.GlowPos2 ), 16, 16, self.GlowColor )

	return false
end

local zoom = 0
local zoom_mat = Material( "vgui/zoom" )

local white = Color(255,255,255,255)
local red = Color(255,0,0,255)

function ENT:PaintZoom( X, Y, ply )
	local TargetZoom = ply:lvsKeyDown( "ZOOM" ) and 1 or 0

	zoom = zoom + (TargetZoom - zoom) * RealFrameTime() * 10

	X = X * 0.5
	Y = Y * 0.5

	surface.SetDrawColor( Color(255,255,255,255 * zoom) )
	surface.SetMaterial(zoom_mat ) 
	surface.DrawTexturedRectRotated( X + X * 0.5, Y * 0.5, X, Y, 0 )
	surface.DrawTexturedRectRotated( X + X * 0.5, Y + Y * 0.5, Y, X, 270 )
	surface.DrawTexturedRectRotated( X * 0.5, Y * 0.5, Y, X, 90 )
	surface.DrawTexturedRectRotated( X * 0.5, Y + Y * 0.5, X, Y, 180 )
end

local COLOR_RED = Color(255,0,0,255)
local COLOR_WHITE = Color(255,255,255,255)

function ENT:LVSHudPaint( X, Y, ply )
	if ply ~= self:GetDriver() then
		return
	end

	local Col = self:WeaponsInRange() and COLOR_WHITE or COLOR_RED

	local Pos2D = self:GetEyeTrace().HitPos:ToScreen() 

	self:PaintCrosshairCenter( Pos2D, Col )
	self:PaintCrosshairOuter( Pos2D, Col )
	self:LVSPaintHitMarker( Pos2D )

	self:PaintZoom( X, Y, ply )
end

ENT.IconEngine = Material( "lvs/engine.png" )

function ENT:LVSHudPaintInfoText(X, Y, W, H, ScrX, ScrY, ply)
	local maxHealth = self:GetMaxHP()
	local health = math.Round((self:GetHP() * 100) / maxHealth)

	surface.SetMaterial(self.IconHealth)
	surface.SetDrawColor(0, 0, 0, 200)
	surface.DrawTexturedRectRotated(X * 1.021, Y * 1.045, H * 0.5, H * 0.5, 0)
	surface.SetDrawColor(color_white)
	surface.DrawTexturedRectRotated(X * 1.02, Y * 1.045, H * 0.5, H * 0.5, 0)

	draw.DrawText(health .. "%", "LVS_FONT_HUD_LARGE", X + 50, Y + 20, color_white, TEXT_ALIGN_LEFT)

	local maxShield = self:GetMaxShield()
	local shield = math.Round((self:GetShield() * 100) / maxShield)

	surface.SetMaterial(self.IconShield)
	surface.SetDrawColor(0, 0, 0, 200)
	surface.DrawTexturedRectRotated(X * 1.126, Y * 1.045, H * 0.5, H * 0.5, 0)
	surface.SetDrawColor(color_white)
	surface.DrawTexturedRectRotated(X * 1.125, Y * 1.045, H * 0.5, H * 0.5, 0)

	if shield >= 0 then
		draw.DrawText(shield .. "%", "LVS_FONT_HUD_LARGE", X + 200, Y + 20, color_white, TEXT_ALIGN_LEFT)
	else
		draw.DrawText("0 %", "LVS_FONT_HUD_LARGE", X + 200, Y + 20, color_white, TEXT_ALIGN_LEFT)
	end

	local kmh = math.Round(self:GetVelocity():Length() * 0.09144,0)
	draw.DrawText("km/h ", "LVS_FONT", X + 370, Y + 35, color_white, TEXT_ALIGN_RIGHT )
	draw.DrawText(kmh, "LVS_FONT_HUD_LARGE", X + 370, Y + 20, color_white, TEXT_ALIGN_LEFT )

	if ply ~= self:GetDriver() then return end

	local Vel = self:GetVelocity():Length()

	local hX = X + W - H * 0.5
	local hY = Y + H * 0.25 + H * 0.25

	surface.SetMaterial(self.IconEngine)
	surface.SetDrawColor(0, 0, 0, 200)
	surface.DrawTexturedRectRotated(hX * 1.007, hY * 1.008, H * 0.75, H * 0.75, 0)
	surface.SetDrawColor(color_white)
	surface.DrawTexturedRectRotated(hX * 1.008, hY * 1.008, H * 0.75, H * 0.75, 0)

	if not self:GetEngineActive() then
		draw.SimpleText("X" , "LVS_FONT",  hX * 1.007, hY * 1.008, Color(0, 0, 0, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
	else
		local Throttle = Vel / 150
		self:LVSDrawCircle(hX * 1.007, hY * 1.008, H * 0.35, math.min(Throttle, 1))
	end
end

--addons/egm_lvs_ground/lua/entities/lvs_walker_hsd/shared.lua:

ENT.Base = "lvs_walker_atte_hoverscript"

ENT.PrintName = "Homing Spider Droid"
ENT.Author = "Luna"
ENT.Information = "OG-9 Separatist Walker Droid"
ENT.Category = "[LVS] - Separatisten"

ENT.Spawnable		= true
ENT.AdminSpawnable	= false

ENT.MDL = "models/blu/hsd.mdl"
ENT.GibModels = {
	"models/blu/hsd_gib.mdl",
	"models/blu/hsd_foot.mdl",
	"models/blu/hsd_leg_1.mdl",
	"models/blu/hsd_leg_2.mdl",
	"models/blu/hsd_leg_3.mdl",
	"models/blu/hsd_leg_4.mdl",
}

ENT.AITEAM = 1

ENT.MaxHealth = 9000

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.HoverHeight = 250
ENT.HoverTraceLength = 300
ENT.HoverHullRadius = 50

ENT.TurretTurnRate = 100

ENT.CanMoveOn = {
	["func_door"] = true,
	["func_movelinear"] = true,
	["prop_physics"] = true,
}

ENT.lvsShowInSpawner = true

function ENT:OnSetupDataTables()
	self:AddDT( "Int", "UpdateLeg" )
	self:AddDT( "Bool", "IsRagdoll" )
	self:AddDT( "Bool", "IsMoving" )
	self:AddDT( "Bool", "NWGround" )
	self:AddDT( "Bool", "ProjectorBeam" )
	self:AddDT( "Vector", "AIAimVector" )
end

function ENT:GetEyeTrace()
	local startpos = self:GetPos()

	local pod = self:GetDriverSeat()

	if IsValid( pod ) then
		startpos = pod:LocalToWorld( Vector(0,0,33) )
	end

	local trace = util.TraceLine( {
		start = startpos,
		endpos = (startpos + self:GetAimVector() * 50000),
		filter = self:GetCrosshairFilterEnts()
	} )

	return trace
end

function ENT:GetAimVector()
	if self:GetAI() then
		return self:GetAIAimVector()
	end

	local Driver = self:GetDriver()

	if IsValid( Driver ) then
		return Driver:GetAimVector()
	else
		return self:GetForward()
	end
end

function ENT:HitGround()
	return self:GetNWGround()
end

--addons/egm_lvs_ground/lua/entities/lvs_walker_hsd/sh_weapons.lua:

function ENT:AimTurretSecondary()
	local trace = self:GetEyeTrace()

	local AimAngles = self:WorldToLocalAngles( (trace.HitPos - self:LocalToWorld( Vector(0,0,100)) ):GetNormalized():Angle() )

	self:SetPoseParameter("turret_secondary_pitch", -AimAngles.p )
	self:SetPoseParameter("turret_secondary_yaw", AimAngles.y )
end

function ENT:AimTurretPrimary()
	local trace = self:GetEyeTrace()

	local AimAngles = self:WorldToLocalAngles( (trace.HitPos - self:LocalToWorld( Vector(0,0,342)) ):GetNormalized():Angle() )

	self:SetPoseParameter("turret_primary_pitch", -AimAngles.p )
	self:SetPoseParameter("turret_primary_yaw", AimAngles.y )
end

function ENT:WeaponsInRange()
	local Forward = self:GetForward()
	local AimForward = self:GetAimVector()

	return self:AngleBetweenNormal( Forward, AimForward ) < 45
end

function ENT:TraceProjectorBeam()
	local ID = self:LookupAttachment( "muzzle_primary" )
	local Muzzle = self:GetAttachment( ID )

	if not Muzzle then return end

	local dir = -Muzzle.Ang:Right()
	local pos = Muzzle.Pos

	local trace = util.TraceLine( {
		start = pos,
		endpos = (pos + dir * 50000),
	} )

	return trace
end

function ENT:StopProjector()
	if not self:GetProjectorBeam() then return end

	self:SetProjectorBeam( false )

	self.SNDProjector:Stop()
end

function ENT:StartProjector()
	if not IsValid( self.SNDProjector ) then return end

	if self:GetProjectorBeam() then return end

	self:SetProjectorBeam( true )

	self.SNDProjector:Play()
end

function ENT:InitWeapons()
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/laserbeam.png")
	weapon.Ammo = -1
	weapon.Delay = 2
	weapon.HeatRateUp = 0
	weapon.HeatRateDown = 0.5
	weapon.OnThink = function( ent, active )
		ent:AimTurretPrimary()

		if not ent:GetProjectorBeam() then return end

		local trace = ent:TraceProjectorBeam()

		ent:ProjectorBeamDamage( trace.Entity, ent:GetDriver(), trace.HitPos, (trace.HitPos - ent:GetPos()):GetNormalized() )

		if not active then return end

		ent:SetHeat( ent:GetHeat() + FrameTime() * 10 )
	end
	weapon.Attack = function( ent )
		if ent:GetProjectorBeam() then return true end

		if not ent:WeaponsInRange() then return true end

		ent:StartProjector()

		timer.Simple( 1.25, function()
			if not IsValid( ent ) then return end

			ent:StopProjector()
		end )
	end
	self:AddWeapon(weapon)


	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Delay = 0.25
	weapon.HeatRateUp = 0.5
	weapon.HeatRateDown = 0.4
	weapon.OnOverheat = function( ent )
		timer.Simple(0.4, function()
			if not IsValid(ent) then return end

			ent:EmitSound("lvs/overheat.wav")
		end)
	end
	weapon.Attack = function( ent )
		if not ent:WeaponsInRange() then return true end

		local effectdata = EffectData()
		effectdata:SetOrigin( ent:LocalToWorld( Vector(0,0,200) ) )
		effectdata:SetEntity( ent )
		effectdata:SetAttachment( ent:LookupAttachment( "muzzle_secondary" ) )
		util.Effect( "lvs_laser_charge", effectdata )

		timer.Simple( 0.4, function()
			if not IsValid( ent ) then return end

			local ID = ent:LookupAttachment( "muzzle_secondary" )
			local Muzzle = ent:GetAttachment( ID )

			if not Muzzle then return end

			local bullet = {}
			bullet.Src = Muzzle.Pos
			bullet.Dir = ent:WeaponsInRange() and (ent:GetEyeTrace().HitPos - Muzzle.Pos):GetNormalized() or -Muzzle.Ang:Right()
			bullet.Spread = Vector(0,0,0)
			bullet.TracerName = "lvs_laser_red_aat"
			bullet.Force = 10
			bullet.HullSize = 1
			bullet.Damage = 100
			bullet.Velocity = 10000
			bullet.Attacker = ent:GetDriver()
			bullet.Callback = function(att, tr, dmginfo)
				local effectdata = EffectData()
				effectdata:SetOrigin( tr.HitPos )
				util.Effect( "lvs_laser_explosion_aat", effectdata )
			end
			ent:LVSFireBullet(bullet)

			local effectdata = EffectData()
			effectdata:SetStart( Vector(255,50,50) )
			effectdata:SetOrigin( bullet.Src )
			effectdata:SetNormal( Muzzle.Ang:Up() )
			effectdata:SetEntity( ent )
			util.Effect("lvs_muzzle_colorable", effectdata)


			if not IsValid(ent.SNDTurret) then return end

			ent.SNDTurret:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
		end)
	end
	weapon.OnThink = function( ent, active )
		ent:AimTurretSecondary()
	end
	self:AddWeapon( weapon )
end
--addons/egm_tfa_mines/lua/entities/mine_antiperson/shared.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--              Mines            	 --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--        Mines | Anti Person        --
---------------------------------------

ENT.Base = "mine_base"

ENT.PrintName = "Anti-Personen Mine"
ENT.Author = "Deltaa"
ENT.Category = "SW:RP (Republik)"

ENT.Spawnable = true
--addons/egm_tfa_mines/lua/entities/mine_incendiary/cl_init.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--              Mines            	 --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--         Mines | Incendiary        --
---------------------------------------

include("shared.lua")
--addons/mortar/lua/entities/mortar/shared.lua:
ENT.Type			=	"anim"
ENT.Base			=	"base_entity"
ENT.PrintName		=	"Mörser"
ENT.Spawnable		=	true
ENT.Category 		=   "CW:RP Sonstiges"

ENT.AutomaticFrameAdvance = true
ENT.RotatingSteps = 0.25
ENT.AnglingSteps = 0.2

ENT.FastRotatingSteps = 2
ENT.FastAnglingSteps = 1

ENT.AnglingMax = 60
ENT.AnglingMin = 13

ENT.FireRate = 2.5
ENT.ShellChangeRate = 1
ENT.ShellClasses = {HE = "mortar_bomb_shell", SE = "mortar_smoke_shell", IN = "mortar_fire_shell"}
--lua/entities/npc_nightsister_undead/cl_init.lua:
include('shared.lua')

language.Add("npc_nightsister_undead", "Undead Nightsister")
killicon.Add("npc_nightsister_undead","HUD/killicons/default",Color ( 255, 80, 0, 255 ) )

function ENT:Initialize()	
end

function ENT:Draw()	
	--self:SetModelScale( Vector(5,5,5) )
	self.Entity:DrawModel()
end
--lua/entities/obj_viewcam/cl_init.lua:
include('shared.lua')

function ENT:Draw()
end

function ENT:Initialize()
end

function ENT:Think()
end
--lua/entities/pfx1_02.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Molotov Fire 1"
ENT.Category         = "PPE: Fire & Smoke"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[1]molotov_ground"
--lua/entities/pfx1_08#.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Fire [Pink]"
ENT.Category         = "PPE: Fire & Smoke"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[1]_campfire_pink"
--lua/entities/pfx1_0e.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Fire [Default]"
ENT.Category         = "PPE: Fire & Smoke"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[1]fireplace_default"
--lua/entities/pfx1_0e_l.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Large Fire [Default]"
ENT.Category         = "PPE: Fire & Smoke"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[1]_large_campfire"
--lua/entities/pfx2_00.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Sparkle 1"
ENT.Category         = "PPE: Other"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[2]sparkle1"

--lua/entities/pfx2_02.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Gushing Blood [Large]"
ENT.Category         = "PPE: Other"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[2]gushing_blood*"



--lua/entities/pfx4_01.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Blue Jet"
ENT.Category         = "PPE: Tech"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[4]jet_b"

--lua/entities/pfx4_01_s~.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Smaller Blue Jet [Smokeless]"
ENT.Category         = "PPE: Tech"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[4]jet_b_s*"

--lua/entities/pfx4_02_s.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Smaller Red Jet"
ENT.Category         = "PPE: Tech"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[4]jet_r_s"
--lua/entities/pfx4_03_s.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Smaller Green Jet"
ENT.Category         = "PPE: Tech"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[4]jet_g_s"
--lua/entities/pfx4_04_s~.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Smaller Purple Jet [Smokeless]"
ENT.Category         = "PPE: Tech"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[4]jet_v_s*"
--lua/entities/pfx4_06_2.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Red Energy Rod"
ENT.Category         = "PPE: Tech"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[4]energy_rod_r"
--lua/entities/pfx5_00_alt_ss.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Micro Alt Black Hole"
ENT.Category         = "PPE: Cosmic"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[5]black_hole_mmicro_b"
--lua/entities/pfx5_02.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Starfield 2"
ENT.Category         = "PPE: Cosmic"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[5]starfield_2"
--lua/entities/pfx7_00.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Dusty Wind"
ENT.Category         = "PPE: Weather"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[7]dusty_wind1"
--lua/entities/pfx8_07.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Frostbeam"
ENT.Category         = "PPE: Magic"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[8]frostbeam"
--lua/entities/pfx9_00.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Colorful Trail"
ENT.Category         = "PPE: Trails"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[9]colorful_trail_1"
--lua/entities/pfx_base.lua:
--          CAT -> PPE: [Fire, Smoke, Weather, Tech, Nature, Cosmic, Other]
--          ENT -> PFX:[~]
AddCSLuaFile()
ENT.Author       = "The man who can even beat E1M1 on Nightmare on Nokia 3310 Java port and this person really thinks that nothing is easier than to beat E1M1 on Nighmare on Nokia 3310 Java port but he just hasn't tried to run Crysis on the calculator yet."
ENT.Type         = "anim"
ENT.Base         = "base_anim"
ENT.PrintName    = "Base"
ENT.Category     = "Particle Effects"
ENT.Spawnable    = false
ENT.AdminOnly    = false
ENT.pfxname      = "[*]pfx_test"
if SERVER then
    function ENT:Initialize()
        self:SetModel("models/hunter/blocks/cube025x025x025.mdl")
        self:SetNoDraw(true) 
        self:SetSkin(1)      
		self:DrawShadow(false)
        self:PhysicsInit(SOLID_VPHYSICS)
        self:SetMoveType(MOVETYPE_VPHYSICS)
        self:SetSolid(SOLID_VPHYSICS)
        ParticleEffectAttach(self.pfxname, 1, self, 1)
    end
end
--lua/entities/pfxcom1.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "PFXCOM1"
ENT.Category         = "PPE: Water"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[com1]jet"
--gamemodes/starwarsrp/entities/entities/prop_door_dynamic/shared.lua:

AddCSLuaFile()

ENT.Base = "base_entity"
ENT.Type = "anim"

ENT.AutomaticFrameAdvance = true

function ENT:Initialize()
	if ( CLIENT ) then return end

	self.Locked = false
	self.Opened = false
	self.NextToggle = 0
	self.CloseDelay = 0

	//self:PhysicsInit( SOLID_VPHYSICS )

	self.door = ents.Create( "prop_dynamic" )
	self.door:SetModel( self:GetModel() )
	self.door:SetPos( self:GetPos() )
	self.door:SetAngles( self:GetAngles() )
	self.door:SetKeyValue( "solid", "6" )
	self.door:SetKeyValue( "MinAnimTime", "1" )
	self.door:SetKeyValue( "MaxAnimTime", "5" )
	self.door.ClassOverride = "prop_door_dynamic"

	//self.door:SetParent( self )

	self.door:Spawn()
	self.door:Activate()

	self:SetParent( self.door )

	self.door:DeleteOnRemove( self )
	self:DeleteOnRemove( self.door )

	if ( self:GetModel() == "models/props/portal_door_combined.mdl" ) then
		self.Opened = true
		self:Close()
	end

end

function ENT:SetCloseDelay( num )
	self.CloseDelay = tonumber( num )
end

function ENT:GetSequenceDuration()
	return self.door:SequenceDuration()
	//return self:SequenceDuration()
end
function ENT:PlayAnimation( str )
	//self:ResetSequence( self:LookupSequence( str ) ) -- This produces double sounds
	
	/*self.door:ResetSequenceInfo()
	self.door:SetPlaybackRate( 1 )
	self.door:SetCycle( 0 )*/
	self.door:ResetSequence( self.door:LookupSequence( str ) ) -- This is for SequenceDuration to work
	
	self.door:Fire( "SetAnimation", str ) -- The actual animation
end

function ENT:Open()
	if ( self.NextToggle > CurTime() || self.Locked || self.Opened == true ) then return end

	self:PlayAnimation( "Open" )

	if ( self:GetModel() == "models/props_mining/elevator01_cagedoor.mdl" ) then
		self:EmitSound( "ambient/levels/outland/ol04elevatorgate_up.wav" )
	end

	if ( self:GetModel() == "models/props_lab/elevatordoor.mdl" ) then
		self:EmitSound( "plats/hall_elev_door.wav" )
	end

	if ( self:GetModel() == "models/props/portal_door_combined.mdl" ) then
		self:EmitSound( "plats/door_round_blue_unlock_01.wav" ) 
		timer.Simple( SoundDuration("plats/door_round_blue_unlock_01.wav") - 0.3, function()
			if ( !IsValid( self ) ) then return end
			self:EmitSound( "plats/door_round_blue_open_01.wav" )
		end )
	end
	
	if ( self:GetModel() == "models/combine_gate_vehicle.mdl" ) then
		self:EmitSound( "Doors.CombineGate_citizen_move1" )
		self:EmitSound( "plats/hall_elev_door.wav" )
		timer.Simple( self:GetSequenceDuration() - 0.7, function()
			if ( !IsValid( self ) ) then return end
			self:StopSound( "Doors.CombineGate_citizen_move1" )
			self:EmitSound( "Doors.CombineGate_citizen_stop2" )
		end )
	end

	self.NextToggle = CurTime() + self:GetSequenceDuration()
	self.Opened = true

	if ( self.CloseDelay < 0 ) then return end
	timer.Create( "rb655_door_autoclose_" .. self:EntIndex(), self:GetSequenceDuration() + self.CloseDelay, 1, function() if ( IsValid( self ) ) then self:Close() end end )
end

function ENT:Close()
	if ( self.NextToggle > CurTime() || self.Locked || self.Opened == false ) then return end

	timer.Destroy( "rb655_door_autoclose_" .. self:EntIndex() )

	self:PlayAnimation( "close" )

	if ( self:GetModel() == "models/props_mining/elevator01_cagedoor.mdl" ) then
		self:EmitSound( "ambient/levels/outland/ol01a_gate_open.wav" )
	end
	
	if ( self:GetModel() == "models/props_lab/elevatordoor.mdl" ) then
		self:EmitSound( "plats/elevator_stop1.wav" )
	end
	
	if ( self:GetModel() == "models/props/portal_door_combined.mdl" ) then
		self:EmitSound( "plats/door_round_blue_close_01.wav" ) 
		timer.Simple( SoundDuration("plats/door_round_blue_close_01.wav") - 0.3, function()
			if ( !IsValid( self ) ) then return end
			self:EmitSound( "plats/door_round_blue_lock_01.wav" )
		end )
	end
	
	if ( self:GetModel() == "models/combine_gate_vehicle.mdl" ) then
		self:EmitSound( "Doors.CombineGate_citizen_move1" )
		self:EmitSound( "plats/hall_elev_door.wav" )
		timer.Simple( self:GetSequenceDuration() - 0.7, function()
			if ( !IsValid( self ) ) then return end
			self:StopSound( "Doors.CombineGate_citizen_move1" )
			self:EmitSound( "Doors.CombineGate_citizen_stop2" )
		end )
	end

	self.NextToggle = CurTime() + self:GetSequenceDuration()
	self.Opened = false
end

function ENT:OnRemove()
	if ( SERVER ) then
		self:StopSound( "Doors.Move10" ) -- Small combine doors
		self:StopSound( "Doors.Move11" ) -- Kleiner lab door
		self:StopSound( "Doors.Move12" ) -- Vertical combine doors
		self:StopSound( "Doors.CombineGate_citizen_move1" ) -- Big Combine doors
	
		// Same stuff for the engine entity
		self.door:StopSound( "Doors.Move10" )
		self.door:StopSound( "Doors.Move11" )
		self.door:StopSound( "Doors.Move12" )
		self.door:StopSound( "Doors.CombineGate_citizen_move1" )
	end
end

function ENT:OnEntityCopyTableFinish( data )
	for k, v in pairs( data ) do data[ k ] = nil end
end

function ENT:AcceptInput( name, activator, caller, data )
	name = string.lower( name )

	if ( name == "open" && self.NextToggle < CurTime() && !self.Locked && self.Opened == false ) then
		self:Open()
	elseif ( name == "close" && self.NextToggle < CurTime() && !self.Locked && self.Opened == true ) then
		self:Close()
	elseif ( name == "lock" ) then
		self.Locked = true
	elseif ( name == "unlock" ) then
		self.Locked = false
	end
end

function ENT:Think()
	if ( CLIENT ) then
		self:DestroyShadow()
	end
end

function ENT:Draw()
	//self:DrawModel()
end

--lua/entities/rail_shell/shared.lua:
 ENT.Type 			= "anim"  
 ENT.Base 			= "base_gmodentity"     
 ENT.PrintName			= "40mm High Explosive"  
 ENT.Author			= "Generic Default"  
 ENT.Contact			= "AIDS"  
 ENT.Purpose			= "SPLODE"  
 ENT.Instructions		= "SHOOT"  
 
ENT.Spawnable			= false
ENT.AdminSpawnable		= false


--addons/egm_tfa_grenades/lua/entities/rw_sw_ent_nade_flash/cl_init.lua:
include('shared.lua')

/*---------------------------------------------------------
Draw
---------------------------------------------------------*/
function ENT:Draw()
	self.Entity:DrawModel()
end


/*---------------------------------------------------------
IsTranslucent
---------------------------------------------------------*/
function ENT:IsTranslucent()
	return true
end



--addons/egm_tfa_grenades/lua/entities/rw_sw_ent_nade_impact.lua:
AddCSLuaFile()
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.Spawnable = false

function ENT:Draw()
	self:DrawModel()
end

function ENT:Initialize()
	if SERVER then
		self:SetModel( "models/forrezzur/impactgrenade.mdl" )
		self:PhysicsInit(SOLID_VPHYSICS)
		self:SetSolid(SOLID_VPHYSICS)
        self:SetMoveType(MOVETYPE_VPHYSICS)
		
	local phys = self:GetPhysicsObject()
	if (IsValid(phys)) then
		phys:SetMass(1)
	end
		self:DrawShadow( true )
	end
	self.Delay = CurTime() + 100000
end

function ENT:PhysicsCollide( data, phys )
	if  (20 < data.Speed and 0.25 < data.DeltaTime) then
	self.Delay = 0
	end
end

function ENT:Think()
	if SERVER and (self.Delay and self.Delay <= CurTime()) then
		self:Explode()
	end
	self:NextThink(CurTime())
	return true
end

function ENT:Explode()
	local effectdata = EffectData()
	effectdata:SetOrigin( self:GetPos() )
	util.Effect("Explosion", effectdata)
	util.BlastDamage( self, self.Owner, self:GetPos(), 300, 500)
	local spos = self:GetPos()
	local trs = util.TraceLine({start=spos + Vector(0,0,64), endpos=spos + Vector(0,0,-32), filter=self})
	util.Decal("Scorch", trs.HitPos + trs.HitNormal, trs.HitPos - trs.HitNormal)    
	self:Remove()
end

function ENT:OnRemove()
end
--addons/egm_tfa_grenades/lua/entities/rw_sw_ent_nade_smoke.lua:
ENT.Type = "anim"
ENT.Base = "base_entity"
ENT.PrintName = "explosive Grenade"
ENT.Author = ""
ENT.Information = ""
ENT.Spawnable = false
ENT.AdminSpawnable = false 

ENT.BounceSound = Sound("TFA_CSGO_SmokeGrenade.Bounce")
ENT.ExplodeSound = Sound("weapons/tfa_starwars/Smoke_Explosive_Puff_01.wav")

AddCSLuaFile()

function ENT:Initialize()
	if SERVER then
		self:SetModel("models/weapons/tfa_starwars/w_smoke.mdl") 
		self:PhysicsInit(SOLID_VPHYSICS)
		self:SetMoveType(MOVETYPE_VPHYSICS)
		self:SetSolid(SOLID_VPHYSICS)
		self:SetCollisionGroup(COLLISION_GROUP_DEBRIS)
		
		local phys = self:GetPhysicsObject()
		if phys:IsValid() then
			phys:Wake()
			phys:SetBuoyancyRatio(0)
		end
		
		self.Delay = CurTime() + 2
		self.NextParticle = 0
		self.ParticleCount = 0
		self.First = true
		self.IsDetonated = false
	end
	self:EmitSound("TFA_CSGO_SmokeGrenade.Throw")
end

function ENT:PhysicsCollide(data, physobj)
	if SERVER then
		self.HitP = data.HitPos
		self.HitN = data.HitNormal

		if self:GetVelocity():Length() > 60 then
			self:EmitSound(self.BounceSound)
		end
		
		--if self:GetVelocity():Length() < 5 then
		--	self:SetMoveType(MOVETYPE_NONE)
		--end
		
		for k, v in pairs( ents.FindInSphere( self:GetPos(), 155 ) ) do
			if v:GetClass() == "tfa_csgo_fire_1" or v:GetClass() == "tfa_csgo_fire_2" and self.IsDetonated == false then
				self:Detonate(self,self:GetPos())
				self.IsDetonated = true
			end
		end
			
	end
end

function ENT:Think()
	if SERVER then	
		if CurTime() > self.Delay then
			if self.IsDetonated == false then
				self:Detonate(self,self:GetPos())
				self.DetonatePos = self:GetPos()
				self.IsDetonated = true
			end
		end
	end
	
	if self.IsDetonated then
		for k, v in pairs( ents.FindInSphere( self.DetonatePos, 155 ) ) do
			if (v:GetClass("tfa_csgo_fire_1") or v:GetClass("tfa_csgo_fire_2")) and v:IsValid() then
				v:SetNWBool("extinguished",true)
			end
			if v:GetNWBool("extinguished",true) and self.ParticleCreated == false then
				ParticleEffect( "extinguish_fire", self.DetonatePos, self:GetAngles() )
				self.ExtinguishParticleCreated = true
			end
		end
	end
end

function ENT:Detonate(self,pos)
	self.ParticleCreated = false
	self.ExtinguishParticleCreated = false
	if SERVER then
		if not self:IsValid() then return end
		self:SetNWBool("IsDetonated",true)
		self:EmitSound(self.ExplodeSound)
		local gas = EffectData()
		gas:SetOrigin(pos)
		gas:SetEntity(self.Owner) //i dunno, just use it!
		util.Effect("tfa_csgo_smokenade", gas)
	end
	if self.ParticleCreated != true then
		ParticleEffectAttach("explosion_child_smoke03e",PATTACH_ABSORIGIN_FOLLOW,self,0)
		ParticleEffectAttach("explosion_child_core06b",PATTACH_POINT_FOLLOW,self,0)
		ParticleEffectAttach("explosion_child_smoke07b",PATTACH_ABSORIGIN_FOLLOW,self,0)
		ParticleEffectAttach("explosion_child_smoke07c",PATTACH_POINT_FOLLOW,self,0)
		ParticleEffectAttach("explosion_child_distort01c",PATTACH_POINT_FOLLOW,self,0)
		self.ParticleCreated = true
	end
	for k, v in pairs( ents.FindInSphere( self:GetPos(), 155 ) ) do
		if (v:GetClass("tfa_csgo_fire_1") or v:GetClass("tfa_csgo_fire_2")) and v:IsValid() then
			v:SetNWBool("extinguished",true)
		end
		if v:GetNWBool("extinguished",true) and self.ParticleCreated == false then
			ParticleEffect( "extinguish_fire", self:GetPos(), self:GetAngles() )
			self.ExtinguishParticleCreated = true
		end
	end
	
	--self:SetMoveType( MOVETYPE_NONE )
	
	if SERVER then
		SafeRemoveEntityDelayed(self,20)
	end
	
end

function ENT:Draw()
	if CLIENT then
		self:DrawModel()
	end
end
--addons/emplacements/lua/entities/swrp_turret_stand_rail.lua:
AddCSLuaFile()
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.PrintName = "Turret Stand Anti Air"
ENT.Category = "CW:RP Geschütze"
ENT.Editable = true
ENT.Spawnable = false
ENT.AdminOnly = true
ENT.UseTimer = CurTime()

ENT.Model = "models/turret/gl_stand.mdl"

function ENT:SpawnFunction( ply, tr, ClassName )
if ( !tr.Hit ) then return end
	local SpawnPos = tr.HitPos + tr.HitNormal * 10
	pAngle = ply:GetAngles()
	pAngle.pitch = pAngle.pitch
	pAngle.roll = pAngle.roll 
	pAngle.yaw = pAngle.yaw + 180
	local ent = ents.Create( ClassName ) 
	ent:SetPos( SpawnPos - Vector(0,0,-10) )
	ent:SetAngles( pAngle )
	ent:Spawn()
	ent:Activate()

	return ent
end

if CLIENT then

	surface.CreateFont( "info_1", {
	font = "Arial",
	extended = false,
	size = 25,
	weight = 100,
	shadow = true,
	outline = false
	} )

	function ENT:Draw()
		self:DrawModel()

		local p = self:GetPos()

		local ang = self:GetAngles()
		ang:RotateAroundAxis( ang:Forward(), 90 )
		ang:RotateAroundAxis( ang:Up(), 90 )
		ang.y = LocalPlayer():EyeAngles().y - 90
		if LocalPlayer():GetPos():DistToSqr( self:GetPos() ) < 512 * 512 then
			cam.Start3D2D( p + Vector( 0, 0, -10 ), Angle( 0, ang.y, 90 ), .15 )
				--draw.RoundedBox( 5, - 126, - 470, 250, 45, Color( 0, 0, 0, 230 ) )
				--draw.DrawText( self:Health(), "BlahBlah2", 5, - 740, Color( 255, 255, 255, 255 ), TEXT_ALIGN_CENTER )
				--draw.DrawText( "Turret Stand", "header", -1, - 465, Color( 52, 235, 146, 255 ), TEXT_ALIGN_CENTER )
				
				local swep = LocalPlayer():GetActiveWeapon()
				if swep:IsValid() and swep:GetClass() == "weapon_swrp_rail_deployable" then
					draw.RoundedBox( 5, - 159, - 470, 320, 100, Color( 0, 0, 0, 230 ) )
					draw.RoundedBox( 1, - 159, - 424, 320, 2, Color( 255, 255, 255, 230 ) )
					draw.DrawText( "> Geschütz platzieren <", "info_1", -1, - 410, Color( 0, 255, 51, 255 ), TEXT_ALIGN_CENTER )
				else
					draw.RoundedBox( 5, - 159, - 470, 320, 45, Color( 0, 0, 0, 230 ) )
				end
				draw.DrawText( "Anti Vehicle Cannon", "header", -1, - 465, Color( 52, 235, 146, 255 ), TEXT_ALIGN_CENTER )
			cam.End3D2D()
		end
	end
end

function ENT:Initialize()
	if SERVER then
		self:SetModel( self.Model )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )
		self:PhysicsInit( SOLID_VPHYSICS )
		self:DrawShadow( true )

		local phys = self:GetPhysicsObject()
		if (phys:IsValid()) then
			phys:Wake()
			phys:SetMass(1)
		end
		self:SetTrigger(true)
	end
end

if SERVER then
	function ENT:Think()
		if self:GetNWBool("Remove?", false) then
			self:Remove()
			local cannon = ents.Create("turret_rail_deployable") -- Tesla Effect
			cannon:SetPos(self:GetPos())
			cannon:Spawn()
		end
	end

	function ENT:Use(activator, caller, useType, value)
		if IsValid(activator) and activator:IsPlayer() and self.owner == activator then
			activator:Give("weapon_swrp_rail_deployable")
			self:EmitSound("summe/sw01_gadgets_burstshield_stop_var_02.mp3")
			self:Remove()
		end
	end

end
--addons/starwars_universe/lua/libs/advanceddraw.lua:
--    Advanced Draw:
--    - IMGUI Source Code: https://github.com/wyozi-gmod/imgui
--    - Draw Precache Arc
--    - Draw Line with thickness

local adraw = {}

adraw.skin = {
    background = Color(0, 0, 0, 0),
    backgroundHover = Color(0, 0, 0, 0),
    border = Color(255, 255, 255),
    borderHover = Color(255, 127, 0),
    borderPress = Color(255, 80, 0),
    foreground = Color(255, 255, 255),
    foregroundHover = Color(255, 127, 0),
    foregroundPress = Color(255, 80, 0),
}

local devCvar = GetConVar("developer")

function adraw.IsDeveloperMode()
    return not adraw.DisableDeveloperMode and devCvar:GetInt() > 0
end

local _devMode = false -- cached local variable updated once in a while

function adraw.Hook(name, id, callback)
    local hookUniqifier = debug.getinfo(4).short_src
    hook.Add(name, "adraw / " .. id .. " / " .. hookUniqifier, callback)
end

local local_player
local gState = {}

local function shouldAcceptInput()
    -- don't process input during non-main renderpass
    if render.GetRenderTarget() ~= nil then return false end
    -- don't process input if we're doing VGUI stuff (and not in context menu)
    if vgui.CursorVisible() and vgui.GetHoveredPanel() ~= g_ContextMenu then return false end

    return true
end

adraw.Hook("PreRender", "adraw / Input", function()
    -- calculate mouse state
    if shouldAcceptInput() then
        local useBind = input.LookupBinding("+use", true)
        local attackBind = input.LookupBinding("+attack", true)
        local USE = useBind and input.GetKeyCode(useBind)
        local ATTACK = attackBind and input.GetKeyCode(attackBind)
        local wasPressing = gState.pressing
        gState.pressing = (USE and input.IsButtonDown(USE)) or (ATTACK and input.IsButtonDown(ATTACK))
        gState.pressed = not wasPressing and gState.pressing
    end
end)

hook.Add("NotifyShouldTransmit", "adraw / ClearRenderBounds", function(ent, shouldTransmit)
    if not shouldTransmit then return end
    local tb = ent:GetTable()
    if not tb._adrawRBExpansion then return end
    tb._adrawRBExpansion = nil
end)

local traceResultTable = {}

local traceQueryTable = {
    output = traceResultTable,
    filter = {}
}

local function isObstructed(eyePos, hitPos, ignoredEntity)
    local q = traceQueryTable
    q.start = eyePos
    q.endpos = hitPos
    q.filter[1] = local_player
    q.filter[2] = ignoredEntity
    local tr = util.TraceLine(q)

    if tr.Hit then
        return true, tr.Entity
    else
        return false
    end
end

function adraw.Start3D2D(pos, angles, scale, distanceHide, distanceFadeStart)
    local_player = local_player or LocalPlayer()

    if gState.shutdown == true then return end

    if gState.rendering == true then
        print("[AdvancedDraw] Starting a new adraw context when previous one is still rendering" .. "Shutting down rendering pipeline to prevent crashes..")
        gState.shutdown = true

        return false
    end

    _devMode = adraw.IsDeveloperMode()
    local eyePos = local_player:EyePos()
    local eyePosToPos = pos - eyePos

    -- OPTIMIZATION: Test that we are in front of the UI
    do
        local normal = angles:Up()
        local dot = eyePosToPos:Dot(normal)

        if _devMode then
            gState._devDot = dot
        end

        -- since normal is pointing away from surface towards viewer, dot<0 is visible
        if dot >= 0 then return false end
    end

    -- OPTIMIZATION: Distance based fade/hide
    if distanceHide then
        local distance = eyePosToPos:Length()
        if distance > distanceHide then return false end

        if _devMode then
            gState._devDist = distance
            gState._devHideDist = distanceHide
        end

        if distanceHide and distanceFadeStart and distance > distanceFadeStart then
            local blend = math.min(math.Remap(distance, distanceFadeStart, distanceHide, 1, 0), 1)
            render.SetBlend(blend)
            surface.SetAlphaMultiplier(blend)
        end
    end

    gState.rendering = true
    gState.pos = pos
    gState.angles = angles
    gState.scale = scale
    cam.Start3D2D(pos, angles, scale)

    -- calculate mousepos
    if not vgui.CursorVisible() or vgui.IsHoveringWorld() then
        local tr = local_player:GetEyeTrace()
        local eyepos = tr.StartPos
        local eyenormal

        if vgui.CursorVisible() and vgui.IsHoveringWorld() then
            eyenormal = gui.ScreenToVector(gui.MousePos())
        else
            eyenormal = tr.Normal
        end

        local planeNormal = angles:Up()
        local hitPos = util.IntersectRayWithPlane(eyepos, eyenormal, pos, planeNormal)

        if hitPos then
            local obstructed, obstructer = isObstructed(eyepos, hitPos, gState.entity)

            if obstructed then
                gState.mx = nil
                gState.my = nil

                if _devMode then
                    gState._devInputBlocker = "collision " .. obstructer:GetClass() .. "/" .. obstructer:EntIndex()
                end
            else
                local diff = pos - hitPos
                -- This cool code is from Willox's keypad CalculateCursorPos
                local x = diff:Dot(-angles:Forward()) / scale
                local y = diff:Dot(-angles:Right()) / scale
                gState.mx = x
                gState.my = y
            end
        else
            gState.mx = nil
            gState.my = nil

            if _devMode then
                gState._devInputBlocker = "not looking at plane"
            end
        end
    else
        gState.mx = nil
        gState.my = nil

        if _devMode then
            gState._devInputBlocker = "not hovering world"
        end
    end

    if _devMode then
        gState._renderStarted = SysTime()
    end

    return true
end

function adraw.Entity3D2D(ent, lpos, lang, scale, ...)
    gState.entity = ent
    local ret = adraw.Start3D2D(ent:LocalToWorld(lpos), ent:LocalToWorldAngles(lang), scale, ...)

    if not ret then
        gState.entity = nil
    end

    return ret
end

local function calculateRenderBounds(x, y, w, h)
    local pos = gState.pos
    local fwd, right = gState.angles:Forward(), gState.angles:Right()
    local scale = gState.scale
    local firstCorner, secondCorner = pos + fwd * x * scale + right * y * scale, pos + fwd * (x + w) * scale + right * (y + h) * scale
    local minrb, maxrb = Vector(math.huge, math.huge, math.huge), Vector(-math.huge, -math.huge, -math.huge)
    minrb.x = math.min(minrb.x, firstCorner.x, secondCorner.x)
    minrb.y = math.min(minrb.y, firstCorner.y, secondCorner.y)
    minrb.z = math.min(minrb.z, firstCorner.z, secondCorner.z)
    maxrb.x = math.max(maxrb.x, firstCorner.x, secondCorner.x)
    maxrb.y = math.max(maxrb.y, firstCorner.y, secondCorner.y)
    maxrb.z = math.max(maxrb.z, firstCorner.z, secondCorner.z)

    return minrb, maxrb
end

function adraw.ExpandRenderBoundsFromRect(x, y, w, h)
    local ent = gState.entity

    if IsValid(ent) then
        local tb = ent:GetTable()
        -- make sure we're not applying same expansion twice
        local expansion = tb._adrawRBExpansion

        if expansion then
            local ex, ey, ew, eh = unpack(expansion)
            if ex == x and ey == y and ew == w and eh == h then return end
        end

        local minrb, maxrb = calculateRenderBounds(x, y, w, h)
        ent:SetRenderBoundsWS(minrb, maxrb)

        if _devMode then
            print("[adraw] Updated renderbounds of ", ent, " to ", minrb, "x", maxrb)
        end

        tb._adrawRBExpansion = {x, y, w, h}
    else
        if _devMode then
            print("[adraw] Attempted to update renderbounds when entity is not valid!! ", debug.traceback())
        end
    end
end

local devOffset = Vector(0, 0, 30)

local devColours = {
    background = Color(0, 0, 0, 200),
    title = Color(78, 205, 196),
    mouseHovered = Color(0, 255, 0),
    mouseUnhovered = Color(255, 0, 0),
    pos = Color(255, 255, 255),
    distance = Color(200, 200, 200, 200),
    ang = Color(255, 255, 255),
    dot = Color(200, 200, 200, 200),
    angleToEye = Color(200, 200, 200, 200),
    renderTime = Color(255, 255, 255),
    renderBounds = Color(0, 0, 255)
}

local function developerText(str, x, y, clr)
    draw.SimpleText(str, "DefaultFixedDropShadow", x, y, clr, TEXT_ALIGN_CENTER, nil)
end

local function drawDeveloperInfo()
    local camAng = local_player:EyeAngles()
    camAng:RotateAroundAxis(camAng:Right(), 90)
    camAng:RotateAroundAxis(camAng:Up(), -90)
    cam.IgnoreZ(true)
    cam.Start3D2D(gState.pos + devOffset, camAng, 0.15)
        local bgCol = devColours["background"]
        surface.SetDrawColor(bgCol.r, bgCol.g, bgCol.b, bgCol.a)
        surface.DrawRect(-100, 0, 200, 140)
        local titleCol = devColours["title"]
        developerText("adraw developer", 0, 5, titleCol)
        surface.SetDrawColor(titleCol.r, titleCol.g, titleCol.b)
        surface.DrawLine(-50, 16, 50, 16)
        local mx, my = gState.mx, gState.my
    
        if mx and my then
            developerText(string.format("mouse: hovering %d x %d", mx, my), 0, 20, devColours["mouseHovered"])
        else
            developerText(string.format("mouse: %s", gState._devInputBlocker or ""), 0, 20, devColours["mouseUnhovered"])
        end
    
        local pos = gState.pos
        developerText(string.format("pos: %.2f %.2f %.2f", pos.x, pos.y, pos.z), 0, 40, devColours["pos"])
        developerText(string.format("distance %.2f / %.2f", gState._devDist or 0, gState._devHideDist or 0), 0, 53, devColours["distance"])
        local ang = gState.angles
        developerText(string.format("ang: %.2f %.2f %.2f", ang.p, ang.y, ang.r), 0, 75, devColours["ang"])
        developerText(string.format("dot %d", gState._devDot or 0), 0, 88, devColours["dot"])
        local angToEye = (pos - local_player:EyePos()):Angle()
        angToEye:RotateAroundAxis(ang:Up(), -90)
        angToEye:RotateAroundAxis(ang:Right(), 90)
        developerText(string.format("angle to eye (%d,%d,%d)", angToEye.p, angToEye.y, angToEye.r), 0, 100, devColours["angleToEye"])
        developerText(string.format("rendertime avg: %.2fms", (gState._devBenchAveraged or 0) * 1000), 0, 120, devColours["renderTime"])
    cam.End3D2D()
    cam.IgnoreZ(false)
    local ent = gState.entity

    if not IsValid(ent) then return end
    local tb = ent:GetTable()
    if not tb._adrawRBExpansion then return end
    local ex, ey, ew, eh = unpack(tb._adrawRBExpansion)
    local minrb, maxrb = calculateRenderBounds(ex, ey, ew, eh)
    render.DrawWireframeBox(vector_origin, angle_zero, minrb, maxrb, devColours["renderBounds"])
end

function adraw.End3D2D()
    if gState then
        if _devMode then
            local renderTook = SysTime() - gState._renderStarted
            gState._devBenchTests = (gState._devBenchTests or 0) + 1
            gState._devBenchTaken = (gState._devBenchTaken or 0) + renderTook

            if gState._devBenchTests == 100 then
                gState._devBenchAveraged = gState._devBenchTaken / 100
                gState._devBenchTests = 0
                gState._devBenchTaken = 0
            end
        end

        gState.rendering = false
        cam.End3D2D()
        render.SetBlend(1)
        surface.SetAlphaMultiplier(1)

        if _devMode then
            drawDeveloperInfo()
        end

        gState.entity = nil
    end
end

function adraw.CursorPos()
    local mx, my = gState.mx, gState.my

    return mx, my
end

function adraw.IsHovering(x, y, w, h)
    local mx, my = gState.mx, gState.my

    return mx and my and mx >= x and mx <= (x + w) and my >= y and my <= (y + h)
end

function adraw.IsPressing()
    return shouldAcceptInput() and gState.pressing
end

function adraw.IsPressed()
    return shouldAcceptInput() and gState.pressed
end

local _createdFonts = {}
local _adrawFontToGmodFont = {}
local EXCLAMATION_BYTE = string.byte("!")

function adraw.xFont(font, defaultSize)
    -- special font
    if string.byte(font, 1) == EXCLAMATION_BYTE then
        local existingGFont = _adrawFontToGmodFont[font]
        if existingGFont then return existingGFont end
        -- Font not cached; parse the font
        local name, size = font:match("!([^@]+)@(.+)")

        if size then
            size = tonumber(size)
        end

        if not size and defaultSize then
            name = font:match("^!([^@]+)$")
            size = defaultSize
        end

        local fontName = string.format("adraw_%s_%d", name, size)
        _adrawFontToGmodFont[font] = fontName

        if not _createdFonts[fontName] then
            surface.CreateFont(fontName, {
                font = name,
                size = size
            })

            _createdFonts[fontName] = true
        end

        return fontName
    end

    return font
end

function adraw.DrawBox(x,y,w,h,borderWidth, borderColor)
    if borderWidth > 0 then
        surface.SetDrawColor(borderColor)
        surface.DrawRect(x, y, w, borderWidth)
        surface.DrawRect(x, y + borderWidth, borderWidth, h - borderWidth * 2)
        surface.DrawRect(x, y + h - borderWidth, w, borderWidth)
        surface.DrawRect(x + w - borderWidth + 1, y, borderWidth, h)
    end
end

function adraw.xButton(x, y, w, h, borderWidth, borderClr, hoverClr, pressColor)
    local bw = borderWidth or 1
    local bgColor = adraw.IsHovering(x, y, w, h) and adraw.skin.backgroundHover or adraw.skin.background
    local borderColor = ((adraw.IsPressing() and adraw.IsHovering(x, y, w, h)) and (pressColor or adraw.skin.borderPress)) or (adraw.IsHovering(x, y, w, h) and (hoverClr or adraw.skin.borderHover)) or (borderClr or adraw.skin.border)
    surface.SetDrawColor(bgColor)
    surface.DrawRect(x, y, w, h)

    adraw.DrawBox(x,y,w,h,bw,borderColor)

    local isHovering = adraw.IsHovering(x, y, w, h)
    return shouldAcceptInput() and isHovering and gState.pressed, isHovering
end

function adraw.xOneColorButton(x, y, w, h, borderWidth, clr)
    local bw = borderWidth or 1
    surface.SetDrawColor(clr)
    surface.DrawRect(x, y, w, h)

    if bw > 0 then
        surface.SetDrawColor(clr)
        surface.DrawRect(x, y, w, bw)
        surface.DrawRect(x, y + bw, bw, h - bw * 2)
        surface.DrawRect(x, y + h - bw, w, bw)
        surface.DrawRect(x + w - bw + 1, y, bw, h)
    end

    return shouldAcceptInput() and adraw.IsHovering(x, y, w, h) and gState.pressed
end

function adraw.xCursor(x, y, w, h)
    local fgColor = adraw.IsPressing() and adraw.skin.foregroundPress or adraw.skin.foreground
    local mx, my = gState.mx, gState.my
    if not mx or not my then return end
    if x and w and (mx < x or mx > x + w) then return end
    if y and h and (my < y or my > y + h) then return end
    local cursorSize = math.ceil(0.3 / gState.scale)
    surface.SetDrawColor(fgColor)
    surface.DrawLine(mx - cursorSize, my, mx + cursorSize, my)
    surface.DrawLine(mx, my - cursorSize, mx, my + cursorSize)
end

function adraw.xTextButton(text, font, x, y, w, h, borderWidth, color, hoverClr, pressColor)
    local fgColor = ((adraw.IsPressing() and adraw.IsHovering(x, y, w, h)) and (pressColor or adraw.skin.foregroundPress)) or (adraw.IsHovering(x, y, w, h) and (hoverClr or adraw.skin.foregroundHover)) or (color or adraw.skin.foreground)
    local clicked = adraw.xButton(x, y, w, h, borderWidth, color, hoverClr, pressColor)
    font = adraw.xFont(font, math.floor(h * 0.618))
    draw.SimpleText(text, font, x + w / 2, y + h / 2, fgColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

    return clicked
end

function adraw.xConButton(x, y, w, h, borderWidth, color, hoverClr, pressColor, conColor, condition)
    local fgColor
    local clicked
    if condition then
        fgColor = conColor
        clicked = adraw.xOneColorButton(x, y, w, h, borderWidth, conColor)
    else
        fgColor = ((adraw.IsPressing() and adraw.IsHovering(x, y, w, h)) and (pressColor or adraw.skin.foregroundPress)) or (adraw.IsHovering(x, y, w, h) and (hoverClr or adraw.skin.foregroundHover)) or (color or adraw.skin.foreground)
        clicked = adraw.xButton(x, y, w, h, borderWidth, color, hoverClr, pressColor)
    end

    return clicked
end

function adraw.xSymbolButton(symbol, x, y, w, h, borderWidth, color, hoverClr, pressColor)
    local fgColor = ((adraw.IsPressing() and adraw.IsHovering(x, y, w, h)) and (pressColor or adraw.skin.foregroundPress)) or (adraw.IsHovering(x, y, w, h) and (hoverClr or adraw.skin.foregroundHover)) or (color or adraw.skin.foreground)
    local clicked = adraw.xButton(x, y, w, h, borderWidth, color, hoverClr, pressColor)
    surface.SetMaterial(symbol)
    surface.SetDrawColor(fgColor)
    surface.DrawTexturedRect(x, y, w, h)

    return clicked
end

function adraw.xDrawLine(x, y, x2, y2, sz)
    local midX = (x + x2) / 2
    local midY = (y + y2) / 2

    local dx = x2 - x
    local dy = y2 - y
    local ang = -math.deg(math.atan2(dy, dx))

    local len = math.sqrt((x2 - x) ^ 2 + (y2 - y) ^ 2)
    draw.NoTexture()
    surface.DrawTexturedRectRotated(midX, midY, len, sz, ang)
end

local cached = {}

function adraw.Arc(cx, cy, radius, thickness, startang, endang, roughness, color)
    local arc = tostring(cx) .. tostring(cy) .. tostring(radius) .. tostring(thickness) .. tostring(startang) .. tostring(endang) .. tostring(roughness)
    surface.SetDrawColor(color)
    draw.NoTexture()

    if (cached[arc] == nil) then
        cached[arc] = adraw.PrecacheArc(cx, cy, radius, thickness, startang, endang, roughness)
    end

    adraw.DrawArc(cached[arc])
end

function adraw.PrecacheArc(cx, cy, radius, thickness, startang, endang, roughness)
    local triarc = {}
    local roughness = math.max(roughness or 1, 1)
    local step = roughness
    local startang, endang = startang or 0, endang or 0

    if startang > endang then
        step = math.abs(step) * -1
    end

    local inner = {}
    local r = radius - thickness

    for deg = startang, endang, step do
        local rad = math.rad(deg)
        local ox, oy = cx + (math.cos(rad) * r), cy + (-math.sin(rad) * r)

        table.insert(inner, {
            x = ox,
            y = oy,
            u = (ox - cx) / radius + .5,
            v = (oy - cy) / radius + .5,
        })
    end

    local outer = {}

    for deg = startang, endang, step do
        local rad = math.rad(deg)
        local ox, oy = cx + (math.cos(rad) * radius), cy + (-math.sin(rad) * radius)

        table.insert(outer, {
            x = ox,
            y = oy,
            u = (ox - cx) / radius + .5,
            v = (oy - cy) / radius + .5,
        })
    end

    for tri = 1, #inner * 2 do
        local p1, p2, p3
        p1 = outer[math.floor(tri / 2) + 1]
        p3 = inner[math.floor((tri + 1) / 2) + 1]

        if tri % 2 == 0 then
            p2 = outer[math.floor((tri + 1) / 2)]
        else
            p2 = inner[math.floor((tri + 1) / 2)]
        end

        table.insert(triarc, {p1, p2, p3})
    end

    return triarc
end

function adraw.DrawArc(arc)
    for _, v in ipairs(arc) do
        surface.DrawPoly(v)
    end
end

function adraw.DrawTexturedRectRotatedPoint( x, y, w, h, rot, x0, y0 )
    local c = math.cos( math.rad( rot ) )
    local s = math.sin( math.rad( rot ) )

    local newx = y0 * s - x0 * c
    local newy = y0 * c + x0 * s

    surface.DrawTexturedRectRotated( x + newx, y + newy, w, h, rot )
end

local matBlurScreen = Material("pp/blurscreen")
function adraw.Derma_DrawPanelBlur(panel, color)
    color = color or Color(10,10,10,100)
    local x, y = panel:LocalToScreen( 0, 0 )

    -- Menu cannot do blur
    if ( not MENU_DLL ) then
        surface.SetMaterial( matBlurScreen )
        surface.SetDrawColor( 255, 255, 255, 255 )

        for i = 0.33, 1, 0.33 do
            matBlurScreen:SetFloat( "$blur", 5 * i )
            matBlurScreen:Recompute()
            if ( render ) then
                render.UpdateScreenEffectTexture()
            end
            surface.DrawTexturedRect( x * -1, y * -1, ScrW(), ScrH() )
        end
    end

    surface.SetDrawColor(color)
    surface.DrawRect( x * -1, y * -1, ScrW(), ScrH() )
end

return adraw

--addons/starwars_universe/lua/entities/swu_navigation_computer/cl_init.lua:
include("shared.lua")
local adraw = include("libs/advanceddraw.lua")

local shipMat = Material("the-coding-ducks/swu/ship-icon.png")
local planetMat = Material("the-coding-ducks/swu/planet-icon.png")
local searchMat = Material("the-coding-ducks/swu/icons/search-icon.png")

SWU = SWU or {}

ENT.RenderGroup = RENDERGROUP_BOTH

function ENT:Initialize()
    self.Width = 11.1
    self.Height = 7.8

    self.Scale = 200

    self:SetPredictable(true)
    self:SharedInitialize()
end

local DIRECTION = {
    BACK = -1,
    FORWARD = 1,
}

function ENT:s(n)
    return self.Scale * n
end

function ENT:Draw()
    self:DrawModel()
end

function ENT:GetDisplayPage()
    return self:GetCurPage() .. "/" .. self:GetPages()
end

function ENT:OpenSearchBar()
    if (IsValid(self.SearchFrame)) then
        self.SearchFrame:Remove()
    end

    self.SearchFrame = vgui.Create("swu_searchframe")
    self.SearchFrame:SetEntity(self)
end

function ENT:GetEntries()
    local entries = string.Split(self:GetPlanets(), "[=]")

    if (#entries < 0 or entries[1] == "" or entries[1] == nil) then return {} end

    return entries
end

function ENT:DrawSearchBar()
    local searchTerm = "Search..."
    local searchTextColor = SWU.Colors.Default.con
    if (string.len(self:GetSearchTerm()) >= 1) then
        searchTerm = self:GetSearchTerm()
        searchTextColor = SWU.Colors.Default.passive
    end

    local x, y, w, h = 0, 275, self:s(self.Width), 120
    local isHovered = adraw.IsHovering(x, y, w, h)
    local isPressed = adraw.IsPressing() and isHovered

    local font = adraw.xFont("!Saira", math.floor(h))
    draw.SimpleText(searchTerm, font, x, y + h * 0.5, searchTextColor, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)

    local buttonColor = isHovered and SWU.Colors.Default.primary or SWU.Colors.Default.passive
    buttonColor = isPressed and SWU.Colors.Default.accent or buttonColor
    adraw.DrawBox(x + w - h,y,h,h,4,buttonColor)
    surface.SetMaterial(searchMat)
    local margin = h * 0.2
    surface.DrawTexturedRect(x + w - h + margin * 0.5,y + margin * 0.5,h - margin,h - margin)

    if (isPressed) then
        self:OpenSearchBar()
    end
end

function ENT:DrawTranslucent()
    if adraw.Entity3D2D(self, Vector(2.3, -36, 45.3), Angle(0, 90, 61), 1 / self.Scale) then
        self:DrawSearchBar()

        local offsetTop = self:s(2.3)
        local width = self:s(self.Width)
        local buttonHeight = self:s(self.Height * 0.1)
        local buttonPadding = buttonHeight * 0.2
        for i, v in pairs(self:GetEntries()) do
            local xOffset = (buttonHeight + buttonPadding)
            if (adraw.xTextButton(v, SWU.Fonts.PlainText, 0, offsetTop + xOffset * (i - 1), width, buttonHeight, 4, SWU.Colors.Default.passiv, SWU.Colors.Default.primary, SWU.Colors.Default.accent)) then
                self:SelectPlanet(v)
            end
        end

        if (#self:GetEntries() <= 0) then
            draw.SimpleText("No entries found", SWU.Fonts.PlainText, width * 0.5, offsetTop, SWU.Colors.Default.passiv, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
        end

        draw.SimpleText(self:GetDisplayPage(), SWU.Fonts.AurabeshNavComputer, self:s(self.Width * 0.5), self:s(self.Height), SWU.Colors.Default.passiv, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM)

        local pageButtonHeight = self:s(0.6)
        local pageButtonWidth = pageButtonHeight * 2

        -- Page Back
        if (adraw.xConButton(0, self:s(self.Height) - pageButtonHeight, pageButtonWidth, pageButtonHeight, 4, SWU.Colors.Default.passive, SWU.Colors.Default.primary, SWU.Colors.Default.accent, SWU.Colors.Default.none, self:GetCurPage() == 1) and self:GetCurPage() ~= 1) then
            self:TurnPage(DIRECTION.BACK)
        end

        draw.NoTexture()
        surface.DrawPoly({
            {
                x = pageButtonWidth * 0.65,
                y = pageButtonHeight * 12.75
            },
            {
                x = pageButtonWidth * 0.35,
                y = pageButtonHeight * 12.5
            },
            {
                x = pageButtonWidth * 0.65,
                y = pageButtonHeight * 12.2
            }
        })
        -- Page Forward
        if (adraw.xConButton(self:s(self.Width) - pageButtonWidth, self:s(self.Height) - pageButtonHeight, pageButtonWidth, pageButtonHeight, 4, SWU.Colors.Default.passiv, SWU.Colors.Default.primary, SWU.Colors.Default.accent, SWU.Colors.Default.none, self:GetCurPage() == self:GetPages()) and self:GetCurPage() ~= self:GetPages()) then
            self:TurnPage(DIRECTION.FORWARD)
        end

        draw.NoTexture()
        surface.DrawPoly({
            {
                x = pageButtonWidth * 8.95,
                y = pageButtonHeight * 12.5
            },
            {
                x = pageButtonWidth * 8.65,
                y = pageButtonHeight * 12.75
            },
            {
                x = pageButtonWidth * 8.65,
                y = pageButtonHeight * 12.2
            }
        })

        adraw.End3D2D()
    end

    if adraw.Entity3D2D(self, Vector(2.3, 26.8, 45.3), Angle(0, 90, 61), 1 / self.Scale) then
        local w, h = 11 * self.Scale, 9.75 * self.Scale

        if (self:GetProgress() > 0 and self:GetProgress() < 1 or self:GetLoading()) then
            local pW, pH = w * 0.8, h * 0.1
            local borderWidth = pH * 0.1

            surface.SetDrawColor(ColorAlpha(SWU.Colors.Default.con, 200):Unpack())
            surface.DrawOutlinedRect((w - pW) * 0.5, (h - pH) * 0.5, pW, pH, borderWidth)

            surface.SetDrawColor(SWU.Colors.Default.passive:Unpack())
            surface.DrawRect((w - pW + borderWidth * 2) * 0.5, (h - pH + borderWidth * 2) * 0.5, (pW - borderWidth * 2) * self:GetProgress(), pH - borderWidth * 2, borderWidth)
        end
        if (self:CanJumpHyperspace()) then
            surface.SetDrawColor(Color(110, 219, 0))
            surface.SetMaterial(planetMat)
            surface.DrawTexturedRectRotated(2040, 435, self.Scale, self.Scale, 0)
            surface.SetDrawColor(Color(255,255,255))
            surface.SetMaterial(shipMat)
            surface.DrawTexturedRectRotated(150 + (2040 - 150) * self:GetTravelPercentage(), 435, self.Scale, self.Scale, -90)
            draw.SimpleText(self:GetTargetPlanet() or "", SWU.Fonts.PlainText, (2040 + 150) * 0.5, 150, Color(255,255,255,255), TEXT_ALIGN_CENTER)
        end
        adraw.End3D2D()
    end

    if adraw.Entity3D2D(self, Vector(2, 10, 45.3), Angle(0, 90, 61), 1 / self.Scale) then
        local targetAngle = self:GetTargetAngle()
        if (targetAngle) then
            if (not self:CanJumpHyperspace()) then
                goto skipAngleDraw
            end
            local color = Color(255, 255, 255)
            local textWidth = draw.SimpleText(math.Round(targetAngle.y, 3), SWU.Fonts.AurabeshNavComputer2, 575, 480, color, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
            draw.SimpleText("°", SWU.Fonts.PlainNavComputer, 575 + textWidth * 0.5 + 50, 465, color, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        end
        ::skipAngleDraw::
        adraw.End3D2D()
    end
    if adraw.Entity3D2D(self, Vector(2, 17, 45.3), Angle(0, 90, 61), 1 / self.Scale) then
        if (self:CanJumpHyperspace()) then
            draw.SimpleText(self:GetTimer(), SWU.Fonts.AurabeshNavComputer2, 575, 480, Color(255, 255, 255, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        end
        adraw.End3D2D()
    end
end

function ENT:CanJumpHyperspace()
    return not self:GetLoading() and self:GetEstimatedJumpTime() > 0
end

function ENT:GetTravelPercentage()
    if (self:GetJumpStartTime() <= 0) then return 0 end

    return (CurTime() - self:GetJumpStartTime()) / self:GetEstimatedJumpTime()
end

function ENT:GetTimer()
    if (self:GetEstimatedJumpTime() <= 0 or self:GetLoading()) then return "" end

    local offset = 0
    if (self:GetJumpStartTime() > 0) then
        offset = CurTime() - self:GetJumpStartTime()
    end
    return string.FormattedTime(self:GetEstimatedJumpTime() - offset, "%02i:%02i:%02i" )
end

function ENT:SelectPlanet(name)
    self:StartNetAction()
    net.WriteUInt(2, 3) -- Action Select Planet
    net.WriteString(name)
    net.SendToServer()
end

function ENT:TurnPage(direction)
    self:StartNetAction()
    net.WriteUInt(1, 3) -- Action Turn Page
    net.WriteInt(direction, 3)
    net.SendToServer()
end

function ENT:UpdatePlanetList(searchTerm)
    self:StartNetAction()
    net.WriteUInt(3, 3) -- Action Update Planet List
    net.WriteString(searchTerm)
    net.SendToServer()
end
--addons/starwars_universe/lua/entities/swu_rotation_controller/shared.lua:
ENT.Type        = "anim"
ENT.PrintName   = "[SWU] Rotation Controller"
ENT.Author      = "The Coding Ducks"
ENT.Information = ""
ENT.Category    = "[SWU] Universe"

ENT.Spawnable	= false

ENT.SWU_Interactable = true

function ENT:SetupDataTables()
    self:NetworkVar("String", 0, "CurrentRotation")
end

function ENT:SetupUsedKeys()
    self.SWU_UsedKeys = {
        [KEY_PAD_0] = SWU.Util:InteractableServer(self.AddInput, 0),
        [KEY_PAD_1] = SWU.Util:InteractableServer(self.AddInput, 1),
        [KEY_PAD_2] = SWU.Util:InteractableServer(self.AddInput, 2),
        [KEY_PAD_3] = SWU.Util:InteractableServer(self.AddInput, 3),
        [KEY_PAD_4] = SWU.Util:InteractableServer(self.AddInput, 4),
        [KEY_PAD_5] = SWU.Util:InteractableServer(self.AddInput, 5),
        [KEY_PAD_6] = SWU.Util:InteractableServer(self.AddInput, 6),
        [KEY_PAD_7] = SWU.Util:InteractableServer(self.AddInput, 7),
        [KEY_PAD_8] = SWU.Util:InteractableServer(self.AddInput, 8),
        [KEY_PAD_9] = SWU.Util:InteractableServer(self.AddInput, 9),
        [KEY_PAD_ENTER] = SWU.Util:InteractableServer(self.LockIn),
        [KEY_ENTER] = SWU.Util:InteractableServer(self.LockIn),
        [KEY_DELETE] = SWU.Util:InteractableServer(self.DeleteLastDigit),
        [KEY_BACKSPACE] = SWU.Util:InteractableServer(self.DeleteLastDigit),
        [KEY_PAD_DECIMAL] = SWU.Util:InteractableServer(self.AddDecimalPoint),
        [KEY_PAD_MINUS] = SWU.Util:InteractableServer(self.ToggleNegative),
        [KEY_PAD_PLUS] = SWU.Util:InteractableServer(self.ToggleNegative),
    }
end

--addons/starwars_universe/lua/libs/advanceddraw.lua:
--    Advanced Draw:
--    - IMGUI Source Code: https://github.com/wyozi-gmod/imgui
--    - Draw Precache Arc
--    - Draw Line with thickness

local adraw = {}

adraw.skin = {
    background = Color(0, 0, 0, 0),
    backgroundHover = Color(0, 0, 0, 0),
    border = Color(255, 255, 255),
    borderHover = Color(255, 127, 0),
    borderPress = Color(255, 80, 0),
    foreground = Color(255, 255, 255),
    foregroundHover = Color(255, 127, 0),
    foregroundPress = Color(255, 80, 0),
}

local devCvar = GetConVar("developer")

function adraw.IsDeveloperMode()
    return not adraw.DisableDeveloperMode and devCvar:GetInt() > 0
end

local _devMode = false -- cached local variable updated once in a while

function adraw.Hook(name, id, callback)
    local hookUniqifier = debug.getinfo(4).short_src
    hook.Add(name, "adraw / " .. id .. " / " .. hookUniqifier, callback)
end

local local_player
local gState = {}

local function shouldAcceptInput()
    -- don't process input during non-main renderpass
    if render.GetRenderTarget() ~= nil then return false end
    -- don't process input if we're doing VGUI stuff (and not in context menu)
    if vgui.CursorVisible() and vgui.GetHoveredPanel() ~= g_ContextMenu then return false end

    return true
end

adraw.Hook("PreRender", "adraw / Input", function()
    -- calculate mouse state
    if shouldAcceptInput() then
        local useBind = input.LookupBinding("+use", true)
        local attackBind = input.LookupBinding("+attack", true)
        local USE = useBind and input.GetKeyCode(useBind)
        local ATTACK = attackBind and input.GetKeyCode(attackBind)
        local wasPressing = gState.pressing
        gState.pressing = (USE and input.IsButtonDown(USE)) or (ATTACK and input.IsButtonDown(ATTACK))
        gState.pressed = not wasPressing and gState.pressing
    end
end)

hook.Add("NotifyShouldTransmit", "adraw / ClearRenderBounds", function(ent, shouldTransmit)
    if not shouldTransmit then return end
    local tb = ent:GetTable()
    if not tb._adrawRBExpansion then return end
    tb._adrawRBExpansion = nil
end)

local traceResultTable = {}

local traceQueryTable = {
    output = traceResultTable,
    filter = {}
}

local function isObstructed(eyePos, hitPos, ignoredEntity)
    local q = traceQueryTable
    q.start = eyePos
    q.endpos = hitPos
    q.filter[1] = local_player
    q.filter[2] = ignoredEntity
    local tr = util.TraceLine(q)

    if tr.Hit then
        return true, tr.Entity
    else
        return false
    end
end

function adraw.Start3D2D(pos, angles, scale, distanceHide, distanceFadeStart)
    local_player = local_player or LocalPlayer()

    if gState.shutdown == true then return end

    if gState.rendering == true then
        print("[AdvancedDraw] Starting a new adraw context when previous one is still rendering" .. "Shutting down rendering pipeline to prevent crashes..")
        gState.shutdown = true

        return false
    end

    _devMode = adraw.IsDeveloperMode()
    local eyePos = local_player:EyePos()
    local eyePosToPos = pos - eyePos

    -- OPTIMIZATION: Test that we are in front of the UI
    do
        local normal = angles:Up()
        local dot = eyePosToPos:Dot(normal)

        if _devMode then
            gState._devDot = dot
        end

        -- since normal is pointing away from surface towards viewer, dot<0 is visible
        if dot >= 0 then return false end
    end

    -- OPTIMIZATION: Distance based fade/hide
    if distanceHide then
        local distance = eyePosToPos:Length()
        if distance > distanceHide then return false end

        if _devMode then
            gState._devDist = distance
            gState._devHideDist = distanceHide
        end

        if distanceHide and distanceFadeStart and distance > distanceFadeStart then
            local blend = math.min(math.Remap(distance, distanceFadeStart, distanceHide, 1, 0), 1)
            render.SetBlend(blend)
            surface.SetAlphaMultiplier(blend)
        end
    end

    gState.rendering = true
    gState.pos = pos
    gState.angles = angles
    gState.scale = scale
    cam.Start3D2D(pos, angles, scale)

    -- calculate mousepos
    if not vgui.CursorVisible() or vgui.IsHoveringWorld() then
        local tr = local_player:GetEyeTrace()
        local eyepos = tr.StartPos
        local eyenormal

        if vgui.CursorVisible() and vgui.IsHoveringWorld() then
            eyenormal = gui.ScreenToVector(gui.MousePos())
        else
            eyenormal = tr.Normal
        end

        local planeNormal = angles:Up()
        local hitPos = util.IntersectRayWithPlane(eyepos, eyenormal, pos, planeNormal)

        if hitPos then
            local obstructed, obstructer = isObstructed(eyepos, hitPos, gState.entity)

            if obstructed then
                gState.mx = nil
                gState.my = nil

                if _devMode then
                    gState._devInputBlocker = "collision " .. obstructer:GetClass() .. "/" .. obstructer:EntIndex()
                end
            else
                local diff = pos - hitPos
                -- This cool code is from Willox's keypad CalculateCursorPos
                local x = diff:Dot(-angles:Forward()) / scale
                local y = diff:Dot(-angles:Right()) / scale
                gState.mx = x
                gState.my = y
            end
        else
            gState.mx = nil
            gState.my = nil

            if _devMode then
                gState._devInputBlocker = "not looking at plane"
            end
        end
    else
        gState.mx = nil
        gState.my = nil

        if _devMode then
            gState._devInputBlocker = "not hovering world"
        end
    end

    if _devMode then
        gState._renderStarted = SysTime()
    end

    return true
end

function adraw.Entity3D2D(ent, lpos, lang, scale, ...)
    gState.entity = ent
    local ret = adraw.Start3D2D(ent:LocalToWorld(lpos), ent:LocalToWorldAngles(lang), scale, ...)

    if not ret then
        gState.entity = nil
    end

    return ret
end

local function calculateRenderBounds(x, y, w, h)
    local pos = gState.pos
    local fwd, right = gState.angles:Forward(), gState.angles:Right()
    local scale = gState.scale
    local firstCorner, secondCorner = pos + fwd * x * scale + right * y * scale, pos + fwd * (x + w) * scale + right * (y + h) * scale
    local minrb, maxrb = Vector(math.huge, math.huge, math.huge), Vector(-math.huge, -math.huge, -math.huge)
    minrb.x = math.min(minrb.x, firstCorner.x, secondCorner.x)
    minrb.y = math.min(minrb.y, firstCorner.y, secondCorner.y)
    minrb.z = math.min(minrb.z, firstCorner.z, secondCorner.z)
    maxrb.x = math.max(maxrb.x, firstCorner.x, secondCorner.x)
    maxrb.y = math.max(maxrb.y, firstCorner.y, secondCorner.y)
    maxrb.z = math.max(maxrb.z, firstCorner.z, secondCorner.z)

    return minrb, maxrb
end

function adraw.ExpandRenderBoundsFromRect(x, y, w, h)
    local ent = gState.entity

    if IsValid(ent) then
        local tb = ent:GetTable()
        -- make sure we're not applying same expansion twice
        local expansion = tb._adrawRBExpansion

        if expansion then
            local ex, ey, ew, eh = unpack(expansion)
            if ex == x and ey == y and ew == w and eh == h then return end
        end

        local minrb, maxrb = calculateRenderBounds(x, y, w, h)
        ent:SetRenderBoundsWS(minrb, maxrb)

        if _devMode then
            print("[adraw] Updated renderbounds of ", ent, " to ", minrb, "x", maxrb)
        end

        tb._adrawRBExpansion = {x, y, w, h}
    else
        if _devMode then
            print("[adraw] Attempted to update renderbounds when entity is not valid!! ", debug.traceback())
        end
    end
end

local devOffset = Vector(0, 0, 30)

local devColours = {
    background = Color(0, 0, 0, 200),
    title = Color(78, 205, 196),
    mouseHovered = Color(0, 255, 0),
    mouseUnhovered = Color(255, 0, 0),
    pos = Color(255, 255, 255),
    distance = Color(200, 200, 200, 200),
    ang = Color(255, 255, 255),
    dot = Color(200, 200, 200, 200),
    angleToEye = Color(200, 200, 200, 200),
    renderTime = Color(255, 255, 255),
    renderBounds = Color(0, 0, 255)
}

local function developerText(str, x, y, clr)
    draw.SimpleText(str, "DefaultFixedDropShadow", x, y, clr, TEXT_ALIGN_CENTER, nil)
end

local function drawDeveloperInfo()
    local camAng = local_player:EyeAngles()
    camAng:RotateAroundAxis(camAng:Right(), 90)
    camAng:RotateAroundAxis(camAng:Up(), -90)
    cam.IgnoreZ(true)
    cam.Start3D2D(gState.pos + devOffset, camAng, 0.15)
        local bgCol = devColours["background"]
        surface.SetDrawColor(bgCol.r, bgCol.g, bgCol.b, bgCol.a)
        surface.DrawRect(-100, 0, 200, 140)
        local titleCol = devColours["title"]
        developerText("adraw developer", 0, 5, titleCol)
        surface.SetDrawColor(titleCol.r, titleCol.g, titleCol.b)
        surface.DrawLine(-50, 16, 50, 16)
        local mx, my = gState.mx, gState.my
    
        if mx and my then
            developerText(string.format("mouse: hovering %d x %d", mx, my), 0, 20, devColours["mouseHovered"])
        else
            developerText(string.format("mouse: %s", gState._devInputBlocker or ""), 0, 20, devColours["mouseUnhovered"])
        end
    
        local pos = gState.pos
        developerText(string.format("pos: %.2f %.2f %.2f", pos.x, pos.y, pos.z), 0, 40, devColours["pos"])
        developerText(string.format("distance %.2f / %.2f", gState._devDist or 0, gState._devHideDist or 0), 0, 53, devColours["distance"])
        local ang = gState.angles
        developerText(string.format("ang: %.2f %.2f %.2f", ang.p, ang.y, ang.r), 0, 75, devColours["ang"])
        developerText(string.format("dot %d", gState._devDot or 0), 0, 88, devColours["dot"])
        local angToEye = (pos - local_player:EyePos()):Angle()
        angToEye:RotateAroundAxis(ang:Up(), -90)
        angToEye:RotateAroundAxis(ang:Right(), 90)
        developerText(string.format("angle to eye (%d,%d,%d)", angToEye.p, angToEye.y, angToEye.r), 0, 100, devColours["angleToEye"])
        developerText(string.format("rendertime avg: %.2fms", (gState._devBenchAveraged or 0) * 1000), 0, 120, devColours["renderTime"])
    cam.End3D2D()
    cam.IgnoreZ(false)
    local ent = gState.entity

    if not IsValid(ent) then return end
    local tb = ent:GetTable()
    if not tb._adrawRBExpansion then return end
    local ex, ey, ew, eh = unpack(tb._adrawRBExpansion)
    local minrb, maxrb = calculateRenderBounds(ex, ey, ew, eh)
    render.DrawWireframeBox(vector_origin, angle_zero, minrb, maxrb, devColours["renderBounds"])
end

function adraw.End3D2D()
    if gState then
        if _devMode then
            local renderTook = SysTime() - gState._renderStarted
            gState._devBenchTests = (gState._devBenchTests or 0) + 1
            gState._devBenchTaken = (gState._devBenchTaken or 0) + renderTook

            if gState._devBenchTests == 100 then
                gState._devBenchAveraged = gState._devBenchTaken / 100
                gState._devBenchTests = 0
                gState._devBenchTaken = 0
            end
        end

        gState.rendering = false
        cam.End3D2D()
        render.SetBlend(1)
        surface.SetAlphaMultiplier(1)

        if _devMode then
            drawDeveloperInfo()
        end

        gState.entity = nil
    end
end

function adraw.CursorPos()
    local mx, my = gState.mx, gState.my

    return mx, my
end

function adraw.IsHovering(x, y, w, h)
    local mx, my = gState.mx, gState.my

    return mx and my and mx >= x and mx <= (x + w) and my >= y and my <= (y + h)
end

function adraw.IsPressing()
    return shouldAcceptInput() and gState.pressing
end

function adraw.IsPressed()
    return shouldAcceptInput() and gState.pressed
end

local _createdFonts = {}
local _adrawFontToGmodFont = {}
local EXCLAMATION_BYTE = string.byte("!")

function adraw.xFont(font, defaultSize)
    -- special font
    if string.byte(font, 1) == EXCLAMATION_BYTE then
        local existingGFont = _adrawFontToGmodFont[font]
        if existingGFont then return existingGFont end
        -- Font not cached; parse the font
        local name, size = font:match("!([^@]+)@(.+)")

        if size then
            size = tonumber(size)
        end

        if not size and defaultSize then
            name = font:match("^!([^@]+)$")
            size = defaultSize
        end

        local fontName = string.format("adraw_%s_%d", name, size)
        _adrawFontToGmodFont[font] = fontName

        if not _createdFonts[fontName] then
            surface.CreateFont(fontName, {
                font = name,
                size = size
            })

            _createdFonts[fontName] = true
        end

        return fontName
    end

    return font
end

function adraw.DrawBox(x,y,w,h,borderWidth, borderColor)
    if borderWidth > 0 then
        surface.SetDrawColor(borderColor)
        surface.DrawRect(x, y, w, borderWidth)
        surface.DrawRect(x, y + borderWidth, borderWidth, h - borderWidth * 2)
        surface.DrawRect(x, y + h - borderWidth, w, borderWidth)
        surface.DrawRect(x + w - borderWidth + 1, y, borderWidth, h)
    end
end

function adraw.xButton(x, y, w, h, borderWidth, borderClr, hoverClr, pressColor)
    local bw = borderWidth or 1
    local bgColor = adraw.IsHovering(x, y, w, h) and adraw.skin.backgroundHover or adraw.skin.background
    local borderColor = ((adraw.IsPressing() and adraw.IsHovering(x, y, w, h)) and (pressColor or adraw.skin.borderPress)) or (adraw.IsHovering(x, y, w, h) and (hoverClr or adraw.skin.borderHover)) or (borderClr or adraw.skin.border)
    surface.SetDrawColor(bgColor)
    surface.DrawRect(x, y, w, h)

    adraw.DrawBox(x,y,w,h,bw,borderColor)

    local isHovering = adraw.IsHovering(x, y, w, h)
    return shouldAcceptInput() and isHovering and gState.pressed, isHovering
end

function adraw.xOneColorButton(x, y, w, h, borderWidth, clr)
    local bw = borderWidth or 1
    surface.SetDrawColor(clr)
    surface.DrawRect(x, y, w, h)

    if bw > 0 then
        surface.SetDrawColor(clr)
        surface.DrawRect(x, y, w, bw)
        surface.DrawRect(x, y + bw, bw, h - bw * 2)
        surface.DrawRect(x, y + h - bw, w, bw)
        surface.DrawRect(x + w - bw + 1, y, bw, h)
    end

    return shouldAcceptInput() and adraw.IsHovering(x, y, w, h) and gState.pressed
end

function adraw.xCursor(x, y, w, h)
    local fgColor = adraw.IsPressing() and adraw.skin.foregroundPress or adraw.skin.foreground
    local mx, my = gState.mx, gState.my
    if not mx or not my then return end
    if x and w and (mx < x or mx > x + w) then return end
    if y and h and (my < y or my > y + h) then return end
    local cursorSize = math.ceil(0.3 / gState.scale)
    surface.SetDrawColor(fgColor)
    surface.DrawLine(mx - cursorSize, my, mx + cursorSize, my)
    surface.DrawLine(mx, my - cursorSize, mx, my + cursorSize)
end

function adraw.xTextButton(text, font, x, y, w, h, borderWidth, color, hoverClr, pressColor)
    local fgColor = ((adraw.IsPressing() and adraw.IsHovering(x, y, w, h)) and (pressColor or adraw.skin.foregroundPress)) or (adraw.IsHovering(x, y, w, h) and (hoverClr or adraw.skin.foregroundHover)) or (color or adraw.skin.foreground)
    local clicked = adraw.xButton(x, y, w, h, borderWidth, color, hoverClr, pressColor)
    font = adraw.xFont(font, math.floor(h * 0.618))
    draw.SimpleText(text, font, x + w / 2, y + h / 2, fgColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

    return clicked
end

function adraw.xConButton(x, y, w, h, borderWidth, color, hoverClr, pressColor, conColor, condition)
    local fgColor
    local clicked
    if condition then
        fgColor = conColor
        clicked = adraw.xOneColorButton(x, y, w, h, borderWidth, conColor)
    else
        fgColor = ((adraw.IsPressing() and adraw.IsHovering(x, y, w, h)) and (pressColor or adraw.skin.foregroundPress)) or (adraw.IsHovering(x, y, w, h) and (hoverClr or adraw.skin.foregroundHover)) or (color or adraw.skin.foreground)
        clicked = adraw.xButton(x, y, w, h, borderWidth, color, hoverClr, pressColor)
    end

    return clicked
end

function adraw.xSymbolButton(symbol, x, y, w, h, borderWidth, color, hoverClr, pressColor)
    local fgColor = ((adraw.IsPressing() and adraw.IsHovering(x, y, w, h)) and (pressColor or adraw.skin.foregroundPress)) or (adraw.IsHovering(x, y, w, h) and (hoverClr or adraw.skin.foregroundHover)) or (color or adraw.skin.foreground)
    local clicked = adraw.xButton(x, y, w, h, borderWidth, color, hoverClr, pressColor)
    surface.SetMaterial(symbol)
    surface.SetDrawColor(fgColor)
    surface.DrawTexturedRect(x, y, w, h)

    return clicked
end

function adraw.xDrawLine(x, y, x2, y2, sz)
    local midX = (x + x2) / 2
    local midY = (y + y2) / 2

    local dx = x2 - x
    local dy = y2 - y
    local ang = -math.deg(math.atan2(dy, dx))

    local len = math.sqrt((x2 - x) ^ 2 + (y2 - y) ^ 2)
    draw.NoTexture()
    surface.DrawTexturedRectRotated(midX, midY, len, sz, ang)
end

local cached = {}

function adraw.Arc(cx, cy, radius, thickness, startang, endang, roughness, color)
    local arc = tostring(cx) .. tostring(cy) .. tostring(radius) .. tostring(thickness) .. tostring(startang) .. tostring(endang) .. tostring(roughness)
    surface.SetDrawColor(color)
    draw.NoTexture()

    if (cached[arc] == nil) then
        cached[arc] = adraw.PrecacheArc(cx, cy, radius, thickness, startang, endang, roughness)
    end

    adraw.DrawArc(cached[arc])
end

function adraw.PrecacheArc(cx, cy, radius, thickness, startang, endang, roughness)
    local triarc = {}
    local roughness = math.max(roughness or 1, 1)
    local step = roughness
    local startang, endang = startang or 0, endang or 0

    if startang > endang then
        step = math.abs(step) * -1
    end

    local inner = {}
    local r = radius - thickness

    for deg = startang, endang, step do
        local rad = math.rad(deg)
        local ox, oy = cx + (math.cos(rad) * r), cy + (-math.sin(rad) * r)

        table.insert(inner, {
            x = ox,
            y = oy,
            u = (ox - cx) / radius + .5,
            v = (oy - cy) / radius + .5,
        })
    end

    local outer = {}

    for deg = startang, endang, step do
        local rad = math.rad(deg)
        local ox, oy = cx + (math.cos(rad) * radius), cy + (-math.sin(rad) * radius)

        table.insert(outer, {
            x = ox,
            y = oy,
            u = (ox - cx) / radius + .5,
            v = (oy - cy) / radius + .5,
        })
    end

    for tri = 1, #inner * 2 do
        local p1, p2, p3
        p1 = outer[math.floor(tri / 2) + 1]
        p3 = inner[math.floor((tri + 1) / 2) + 1]

        if tri % 2 == 0 then
            p2 = outer[math.floor((tri + 1) / 2)]
        else
            p2 = inner[math.floor((tri + 1) / 2)]
        end

        table.insert(triarc, {p1, p2, p3})
    end

    return triarc
end

function adraw.DrawArc(arc)
    for _, v in ipairs(arc) do
        surface.DrawPoly(v)
    end
end

function adraw.DrawTexturedRectRotatedPoint( x, y, w, h, rot, x0, y0 )
    local c = math.cos( math.rad( rot ) )
    local s = math.sin( math.rad( rot ) )

    local newx = y0 * s - x0 * c
    local newy = y0 * c + x0 * s

    surface.DrawTexturedRectRotated( x + newx, y + newy, w, h, rot )
end

local matBlurScreen = Material("pp/blurscreen")
function adraw.Derma_DrawPanelBlur(panel, color)
    color = color or Color(10,10,10,100)
    local x, y = panel:LocalToScreen( 0, 0 )

    -- Menu cannot do blur
    if ( not MENU_DLL ) then
        surface.SetMaterial( matBlurScreen )
        surface.SetDrawColor( 255, 255, 255, 255 )

        for i = 0.33, 1, 0.33 do
            matBlurScreen:SetFloat( "$blur", 5 * i )
            matBlurScreen:Recompute()
            if ( render ) then
                render.UpdateScreenEffectTexture()
            end
            surface.DrawTexturedRect( x * -1, y * -1, ScrW(), ScrH() )
        end
    end

    surface.SetDrawColor(color)
    surface.DrawRect( x * -1, y * -1, ScrW(), ScrH() )
end

return adraw

--addons/starwars_universe/lua/libs/advanceddraw.lua:
--    Advanced Draw:
--    - IMGUI Source Code: https://github.com/wyozi-gmod/imgui
--    - Draw Precache Arc
--    - Draw Line with thickness

local adraw = {}

adraw.skin = {
    background = Color(0, 0, 0, 0),
    backgroundHover = Color(0, 0, 0, 0),
    border = Color(255, 255, 255),
    borderHover = Color(255, 127, 0),
    borderPress = Color(255, 80, 0),
    foreground = Color(255, 255, 255),
    foregroundHover = Color(255, 127, 0),
    foregroundPress = Color(255, 80, 0),
}

local devCvar = GetConVar("developer")

function adraw.IsDeveloperMode()
    return not adraw.DisableDeveloperMode and devCvar:GetInt() > 0
end

local _devMode = false -- cached local variable updated once in a while

function adraw.Hook(name, id, callback)
    local hookUniqifier = debug.getinfo(4).short_src
    hook.Add(name, "adraw / " .. id .. " / " .. hookUniqifier, callback)
end

local local_player
local gState = {}

local function shouldAcceptInput()
    -- don't process input during non-main renderpass
    if render.GetRenderTarget() ~= nil then return false end
    -- don't process input if we're doing VGUI stuff (and not in context menu)
    if vgui.CursorVisible() and vgui.GetHoveredPanel() ~= g_ContextMenu then return false end

    return true
end

adraw.Hook("PreRender", "adraw / Input", function()
    -- calculate mouse state
    if shouldAcceptInput() then
        local useBind = input.LookupBinding("+use", true)
        local attackBind = input.LookupBinding("+attack", true)
        local USE = useBind and input.GetKeyCode(useBind)
        local ATTACK = attackBind and input.GetKeyCode(attackBind)
        local wasPressing = gState.pressing
        gState.pressing = (USE and input.IsButtonDown(USE)) or (ATTACK and input.IsButtonDown(ATTACK))
        gState.pressed = not wasPressing and gState.pressing
    end
end)

hook.Add("NotifyShouldTransmit", "adraw / ClearRenderBounds", function(ent, shouldTransmit)
    if not shouldTransmit then return end
    local tb = ent:GetTable()
    if not tb._adrawRBExpansion then return end
    tb._adrawRBExpansion = nil
end)

local traceResultTable = {}

local traceQueryTable = {
    output = traceResultTable,
    filter = {}
}

local function isObstructed(eyePos, hitPos, ignoredEntity)
    local q = traceQueryTable
    q.start = eyePos
    q.endpos = hitPos
    q.filter[1] = local_player
    q.filter[2] = ignoredEntity
    local tr = util.TraceLine(q)

    if tr.Hit then
        return true, tr.Entity
    else
        return false
    end
end

function adraw.Start3D2D(pos, angles, scale, distanceHide, distanceFadeStart)
    local_player = local_player or LocalPlayer()

    if gState.shutdown == true then return end

    if gState.rendering == true then
        print("[AdvancedDraw] Starting a new adraw context when previous one is still rendering" .. "Shutting down rendering pipeline to prevent crashes..")
        gState.shutdown = true

        return false
    end

    _devMode = adraw.IsDeveloperMode()
    local eyePos = local_player:EyePos()
    local eyePosToPos = pos - eyePos

    -- OPTIMIZATION: Test that we are in front of the UI
    do
        local normal = angles:Up()
        local dot = eyePosToPos:Dot(normal)

        if _devMode then
            gState._devDot = dot
        end

        -- since normal is pointing away from surface towards viewer, dot<0 is visible
        if dot >= 0 then return false end
    end

    -- OPTIMIZATION: Distance based fade/hide
    if distanceHide then
        local distance = eyePosToPos:Length()
        if distance > distanceHide then return false end

        if _devMode then
            gState._devDist = distance
            gState._devHideDist = distanceHide
        end

        if distanceHide and distanceFadeStart and distance > distanceFadeStart then
            local blend = math.min(math.Remap(distance, distanceFadeStart, distanceHide, 1, 0), 1)
            render.SetBlend(blend)
            surface.SetAlphaMultiplier(blend)
        end
    end

    gState.rendering = true
    gState.pos = pos
    gState.angles = angles
    gState.scale = scale
    cam.Start3D2D(pos, angles, scale)

    -- calculate mousepos
    if not vgui.CursorVisible() or vgui.IsHoveringWorld() then
        local tr = local_player:GetEyeTrace()
        local eyepos = tr.StartPos
        local eyenormal

        if vgui.CursorVisible() and vgui.IsHoveringWorld() then
            eyenormal = gui.ScreenToVector(gui.MousePos())
        else
            eyenormal = tr.Normal
        end

        local planeNormal = angles:Up()
        local hitPos = util.IntersectRayWithPlane(eyepos, eyenormal, pos, planeNormal)

        if hitPos then
            local obstructed, obstructer = isObstructed(eyepos, hitPos, gState.entity)

            if obstructed then
                gState.mx = nil
                gState.my = nil

                if _devMode then
                    gState._devInputBlocker = "collision " .. obstructer:GetClass() .. "/" .. obstructer:EntIndex()
                end
            else
                local diff = pos - hitPos
                -- This cool code is from Willox's keypad CalculateCursorPos
                local x = diff:Dot(-angles:Forward()) / scale
                local y = diff:Dot(-angles:Right()) / scale
                gState.mx = x
                gState.my = y
            end
        else
            gState.mx = nil
            gState.my = nil

            if _devMode then
                gState._devInputBlocker = "not looking at plane"
            end
        end
    else
        gState.mx = nil
        gState.my = nil

        if _devMode then
            gState._devInputBlocker = "not hovering world"
        end
    end

    if _devMode then
        gState._renderStarted = SysTime()
    end

    return true
end

function adraw.Entity3D2D(ent, lpos, lang, scale, ...)
    gState.entity = ent
    local ret = adraw.Start3D2D(ent:LocalToWorld(lpos), ent:LocalToWorldAngles(lang), scale, ...)

    if not ret then
        gState.entity = nil
    end

    return ret
end

local function calculateRenderBounds(x, y, w, h)
    local pos = gState.pos
    local fwd, right = gState.angles:Forward(), gState.angles:Right()
    local scale = gState.scale
    local firstCorner, secondCorner = pos + fwd * x * scale + right * y * scale, pos + fwd * (x + w) * scale + right * (y + h) * scale
    local minrb, maxrb = Vector(math.huge, math.huge, math.huge), Vector(-math.huge, -math.huge, -math.huge)
    minrb.x = math.min(minrb.x, firstCorner.x, secondCorner.x)
    minrb.y = math.min(minrb.y, firstCorner.y, secondCorner.y)
    minrb.z = math.min(minrb.z, firstCorner.z, secondCorner.z)
    maxrb.x = math.max(maxrb.x, firstCorner.x, secondCorner.x)
    maxrb.y = math.max(maxrb.y, firstCorner.y, secondCorner.y)
    maxrb.z = math.max(maxrb.z, firstCorner.z, secondCorner.z)

    return minrb, maxrb
end

function adraw.ExpandRenderBoundsFromRect(x, y, w, h)
    local ent = gState.entity

    if IsValid(ent) then
        local tb = ent:GetTable()
        -- make sure we're not applying same expansion twice
        local expansion = tb._adrawRBExpansion

        if expansion then
            local ex, ey, ew, eh = unpack(expansion)
            if ex == x and ey == y and ew == w and eh == h then return end
        end

        local minrb, maxrb = calculateRenderBounds(x, y, w, h)
        ent:SetRenderBoundsWS(minrb, maxrb)

        if _devMode then
            print("[adraw] Updated renderbounds of ", ent, " to ", minrb, "x", maxrb)
        end

        tb._adrawRBExpansion = {x, y, w, h}
    else
        if _devMode then
            print("[adraw] Attempted to update renderbounds when entity is not valid!! ", debug.traceback())
        end
    end
end

local devOffset = Vector(0, 0, 30)

local devColours = {
    background = Color(0, 0, 0, 200),
    title = Color(78, 205, 196),
    mouseHovered = Color(0, 255, 0),
    mouseUnhovered = Color(255, 0, 0),
    pos = Color(255, 255, 255),
    distance = Color(200, 200, 200, 200),
    ang = Color(255, 255, 255),
    dot = Color(200, 200, 200, 200),
    angleToEye = Color(200, 200, 200, 200),
    renderTime = Color(255, 255, 255),
    renderBounds = Color(0, 0, 255)
}

local function developerText(str, x, y, clr)
    draw.SimpleText(str, "DefaultFixedDropShadow", x, y, clr, TEXT_ALIGN_CENTER, nil)
end

local function drawDeveloperInfo()
    local camAng = local_player:EyeAngles()
    camAng:RotateAroundAxis(camAng:Right(), 90)
    camAng:RotateAroundAxis(camAng:Up(), -90)
    cam.IgnoreZ(true)
    cam.Start3D2D(gState.pos + devOffset, camAng, 0.15)
        local bgCol = devColours["background"]
        surface.SetDrawColor(bgCol.r, bgCol.g, bgCol.b, bgCol.a)
        surface.DrawRect(-100, 0, 200, 140)
        local titleCol = devColours["title"]
        developerText("adraw developer", 0, 5, titleCol)
        surface.SetDrawColor(titleCol.r, titleCol.g, titleCol.b)
        surface.DrawLine(-50, 16, 50, 16)
        local mx, my = gState.mx, gState.my
    
        if mx and my then
            developerText(string.format("mouse: hovering %d x %d", mx, my), 0, 20, devColours["mouseHovered"])
        else
            developerText(string.format("mouse: %s", gState._devInputBlocker or ""), 0, 20, devColours["mouseUnhovered"])
        end
    
        local pos = gState.pos
        developerText(string.format("pos: %.2f %.2f %.2f", pos.x, pos.y, pos.z), 0, 40, devColours["pos"])
        developerText(string.format("distance %.2f / %.2f", gState._devDist or 0, gState._devHideDist or 0), 0, 53, devColours["distance"])
        local ang = gState.angles
        developerText(string.format("ang: %.2f %.2f %.2f", ang.p, ang.y, ang.r), 0, 75, devColours["ang"])
        developerText(string.format("dot %d", gState._devDot or 0), 0, 88, devColours["dot"])
        local angToEye = (pos - local_player:EyePos()):Angle()
        angToEye:RotateAroundAxis(ang:Up(), -90)
        angToEye:RotateAroundAxis(ang:Right(), 90)
        developerText(string.format("angle to eye (%d,%d,%d)", angToEye.p, angToEye.y, angToEye.r), 0, 100, devColours["angleToEye"])
        developerText(string.format("rendertime avg: %.2fms", (gState._devBenchAveraged or 0) * 1000), 0, 120, devColours["renderTime"])
    cam.End3D2D()
    cam.IgnoreZ(false)
    local ent = gState.entity

    if not IsValid(ent) then return end
    local tb = ent:GetTable()
    if not tb._adrawRBExpansion then return end
    local ex, ey, ew, eh = unpack(tb._adrawRBExpansion)
    local minrb, maxrb = calculateRenderBounds(ex, ey, ew, eh)
    render.DrawWireframeBox(vector_origin, angle_zero, minrb, maxrb, devColours["renderBounds"])
end

function adraw.End3D2D()
    if gState then
        if _devMode then
            local renderTook = SysTime() - gState._renderStarted
            gState._devBenchTests = (gState._devBenchTests or 0) + 1
            gState._devBenchTaken = (gState._devBenchTaken or 0) + renderTook

            if gState._devBenchTests == 100 then
                gState._devBenchAveraged = gState._devBenchTaken / 100
                gState._devBenchTests = 0
                gState._devBenchTaken = 0
            end
        end

        gState.rendering = false
        cam.End3D2D()
        render.SetBlend(1)
        surface.SetAlphaMultiplier(1)

        if _devMode then
            drawDeveloperInfo()
        end

        gState.entity = nil
    end
end

function adraw.CursorPos()
    local mx, my = gState.mx, gState.my

    return mx, my
end

function adraw.IsHovering(x, y, w, h)
    local mx, my = gState.mx, gState.my

    return mx and my and mx >= x and mx <= (x + w) and my >= y and my <= (y + h)
end

function adraw.IsPressing()
    return shouldAcceptInput() and gState.pressing
end

function adraw.IsPressed()
    return shouldAcceptInput() and gState.pressed
end

local _createdFonts = {}
local _adrawFontToGmodFont = {}
local EXCLAMATION_BYTE = string.byte("!")

function adraw.xFont(font, defaultSize)
    -- special font
    if string.byte(font, 1) == EXCLAMATION_BYTE then
        local existingGFont = _adrawFontToGmodFont[font]
        if existingGFont then return existingGFont end
        -- Font not cached; parse the font
        local name, size = font:match("!([^@]+)@(.+)")

        if size then
            size = tonumber(size)
        end

        if not size and defaultSize then
            name = font:match("^!([^@]+)$")
            size = defaultSize
        end

        local fontName = string.format("adraw_%s_%d", name, size)
        _adrawFontToGmodFont[font] = fontName

        if not _createdFonts[fontName] then
            surface.CreateFont(fontName, {
                font = name,
                size = size
            })

            _createdFonts[fontName] = true
        end

        return fontName
    end

    return font
end

function adraw.DrawBox(x,y,w,h,borderWidth, borderColor)
    if borderWidth > 0 then
        surface.SetDrawColor(borderColor)
        surface.DrawRect(x, y, w, borderWidth)
        surface.DrawRect(x, y + borderWidth, borderWidth, h - borderWidth * 2)
        surface.DrawRect(x, y + h - borderWidth, w, borderWidth)
        surface.DrawRect(x + w - borderWidth + 1, y, borderWidth, h)
    end
end

function adraw.xButton(x, y, w, h, borderWidth, borderClr, hoverClr, pressColor)
    local bw = borderWidth or 1
    local bgColor = adraw.IsHovering(x, y, w, h) and adraw.skin.backgroundHover or adraw.skin.background
    local borderColor = ((adraw.IsPressing() and adraw.IsHovering(x, y, w, h)) and (pressColor or adraw.skin.borderPress)) or (adraw.IsHovering(x, y, w, h) and (hoverClr or adraw.skin.borderHover)) or (borderClr or adraw.skin.border)
    surface.SetDrawColor(bgColor)
    surface.DrawRect(x, y, w, h)

    adraw.DrawBox(x,y,w,h,bw,borderColor)

    local isHovering = adraw.IsHovering(x, y, w, h)
    return shouldAcceptInput() and isHovering and gState.pressed, isHovering
end

function adraw.xOneColorButton(x, y, w, h, borderWidth, clr)
    local bw = borderWidth or 1
    surface.SetDrawColor(clr)
    surface.DrawRect(x, y, w, h)

    if bw > 0 then
        surface.SetDrawColor(clr)
        surface.DrawRect(x, y, w, bw)
        surface.DrawRect(x, y + bw, bw, h - bw * 2)
        surface.DrawRect(x, y + h - bw, w, bw)
        surface.DrawRect(x + w - bw + 1, y, bw, h)
    end

    return shouldAcceptInput() and adraw.IsHovering(x, y, w, h) and gState.pressed
end

function adraw.xCursor(x, y, w, h)
    local fgColor = adraw.IsPressing() and adraw.skin.foregroundPress or adraw.skin.foreground
    local mx, my = gState.mx, gState.my
    if not mx or not my then return end
    if x and w and (mx < x or mx > x + w) then return end
    if y and h and (my < y or my > y + h) then return end
    local cursorSize = math.ceil(0.3 / gState.scale)
    surface.SetDrawColor(fgColor)
    surface.DrawLine(mx - cursorSize, my, mx + cursorSize, my)
    surface.DrawLine(mx, my - cursorSize, mx, my + cursorSize)
end

function adraw.xTextButton(text, font, x, y, w, h, borderWidth, color, hoverClr, pressColor)
    local fgColor = ((adraw.IsPressing() and adraw.IsHovering(x, y, w, h)) and (pressColor or adraw.skin.foregroundPress)) or (adraw.IsHovering(x, y, w, h) and (hoverClr or adraw.skin.foregroundHover)) or (color or adraw.skin.foreground)
    local clicked = adraw.xButton(x, y, w, h, borderWidth, color, hoverClr, pressColor)
    font = adraw.xFont(font, math.floor(h * 0.618))
    draw.SimpleText(text, font, x + w / 2, y + h / 2, fgColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

    return clicked
end

function adraw.xConButton(x, y, w, h, borderWidth, color, hoverClr, pressColor, conColor, condition)
    local fgColor
    local clicked
    if condition then
        fgColor = conColor
        clicked = adraw.xOneColorButton(x, y, w, h, borderWidth, conColor)
    else
        fgColor = ((adraw.IsPressing() and adraw.IsHovering(x, y, w, h)) and (pressColor or adraw.skin.foregroundPress)) or (adraw.IsHovering(x, y, w, h) and (hoverClr or adraw.skin.foregroundHover)) or (color or adraw.skin.foreground)
        clicked = adraw.xButton(x, y, w, h, borderWidth, color, hoverClr, pressColor)
    end

    return clicked
end

function adraw.xSymbolButton(symbol, x, y, w, h, borderWidth, color, hoverClr, pressColor)
    local fgColor = ((adraw.IsPressing() and adraw.IsHovering(x, y, w, h)) and (pressColor or adraw.skin.foregroundPress)) or (adraw.IsHovering(x, y, w, h) and (hoverClr or adraw.skin.foregroundHover)) or (color or adraw.skin.foreground)
    local clicked = adraw.xButton(x, y, w, h, borderWidth, color, hoverClr, pressColor)
    surface.SetMaterial(symbol)
    surface.SetDrawColor(fgColor)
    surface.DrawTexturedRect(x, y, w, h)

    return clicked
end

function adraw.xDrawLine(x, y, x2, y2, sz)
    local midX = (x + x2) / 2
    local midY = (y + y2) / 2

    local dx = x2 - x
    local dy = y2 - y
    local ang = -math.deg(math.atan2(dy, dx))

    local len = math.sqrt((x2 - x) ^ 2 + (y2 - y) ^ 2)
    draw.NoTexture()
    surface.DrawTexturedRectRotated(midX, midY, len, sz, ang)
end

local cached = {}

function adraw.Arc(cx, cy, radius, thickness, startang, endang, roughness, color)
    local arc = tostring(cx) .. tostring(cy) .. tostring(radius) .. tostring(thickness) .. tostring(startang) .. tostring(endang) .. tostring(roughness)
    surface.SetDrawColor(color)
    draw.NoTexture()

    if (cached[arc] == nil) then
        cached[arc] = adraw.PrecacheArc(cx, cy, radius, thickness, startang, endang, roughness)
    end

    adraw.DrawArc(cached[arc])
end

function adraw.PrecacheArc(cx, cy, radius, thickness, startang, endang, roughness)
    local triarc = {}
    local roughness = math.max(roughness or 1, 1)
    local step = roughness
    local startang, endang = startang or 0, endang or 0

    if startang > endang then
        step = math.abs(step) * -1
    end

    local inner = {}
    local r = radius - thickness

    for deg = startang, endang, step do
        local rad = math.rad(deg)
        local ox, oy = cx + (math.cos(rad) * r), cy + (-math.sin(rad) * r)

        table.insert(inner, {
            x = ox,
            y = oy,
            u = (ox - cx) / radius + .5,
            v = (oy - cy) / radius + .5,
        })
    end

    local outer = {}

    for deg = startang, endang, step do
        local rad = math.rad(deg)
        local ox, oy = cx + (math.cos(rad) * radius), cy + (-math.sin(rad) * radius)

        table.insert(outer, {
            x = ox,
            y = oy,
            u = (ox - cx) / radius + .5,
            v = (oy - cy) / radius + .5,
        })
    end

    for tri = 1, #inner * 2 do
        local p1, p2, p3
        p1 = outer[math.floor(tri / 2) + 1]
        p3 = inner[math.floor((tri + 1) / 2) + 1]

        if tri % 2 == 0 then
            p2 = outer[math.floor((tri + 1) / 2)]
        else
            p2 = inner[math.floor((tri + 1) / 2)]
        end

        table.insert(triarc, {p1, p2, p3})
    end

    return triarc
end

function adraw.DrawArc(arc)
    for _, v in ipairs(arc) do
        surface.DrawPoly(v)
    end
end

function adraw.DrawTexturedRectRotatedPoint( x, y, w, h, rot, x0, y0 )
    local c = math.cos( math.rad( rot ) )
    local s = math.sin( math.rad( rot ) )

    local newx = y0 * s - x0 * c
    local newy = y0 * c + x0 * s

    surface.DrawTexturedRectRotated( x + newx, y + newy, w, h, rot )
end

local matBlurScreen = Material("pp/blurscreen")
function adraw.Derma_DrawPanelBlur(panel, color)
    color = color or Color(10,10,10,100)
    local x, y = panel:LocalToScreen( 0, 0 )

    -- Menu cannot do blur
    if ( not MENU_DLL ) then
        surface.SetMaterial( matBlurScreen )
        surface.SetDrawColor( 255, 255, 255, 255 )

        for i = 0.33, 1, 0.33 do
            matBlurScreen:SetFloat( "$blur", 5 * i )
            matBlurScreen:Recompute()
            if ( render ) then
                render.UpdateScreenEffectTexture()
            end
            surface.DrawTexturedRect( x * -1, y * -1, ScrW(), ScrH() )
        end
    end

    surface.SetDrawColor(color)
    surface.DrawRect( x * -1, y * -1, ScrW(), ScrH() )
end

return adraw

--addons/tfa_base/lua/entities/tfa_exp_base/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()
end

function ENT:IsTranslucent()
	return true
end
--addons/tfa_base/lua/entities/tfa_exp_base/shared.lua:
ENT.Type = "anim"
ENT.PrintName = "Base Explosive"
ENT.Author = ""
ENT.Contact = ""
ENT.Purpose = ""
ENT.Instructions = ""
ENT.DoNotDuplicate = true
ENT.DisableDuplicator = true

local sp = game.SinglePlayer()

function ENT:EmitSoundNet(sound)
	if CLIENT or sp then
		if sp and not IsFirstTimePredicted() then return end

		self:EmitSound(sound)

		return
	end

	local filter = RecipientFilter()
	filter:AddPAS(self:GetPos())
	if IsValid(self:GetOwner()) then
		filter:RemovePlayer(self:GetOwner())
	end

	net.Start("tfaSoundEvent", true)
	net.WriteEntity(self)
	net.WriteString(sound)
	net.WriteBool(false)
	net.Send(filter)
end

--addons/tfa_base/lua/entities/tfbow_arrow/cl_init.lua:
include("shared.lua")
local cv_ht = GetConVar("host_timescale")

function ENT:Draw()
	local ang, tmpang
	tmpang = self:GetAngles()
	ang = tmpang

	if not self.roll then
		self.roll = 0
	end

	local phobj = self:GetPhysicsObject()

	if IsValid(phobj) then
		self.roll = self.roll + phobj:GetVelocity():Length() / 3600 * cv_ht:GetFloat()
	end

	ang:RotateAroundAxis(ang:Forward(), self.roll)
	self:SetAngles(ang)
	self:DrawModel() -- Draw the model.
	self:SetAngles(tmpang)
end

--addons/tfa_base/lua/entities/tfbow_arrow_stuck_clientside/shared.lua:
ENT.Type = "anim"
ENT.PrintName = "Sawblade"
ENT.Author = ""
ENT.Contact = ""
ENT.Purpose = ""
ENT.Instructions = ""
ENT.DoNotDuplicate = true
ENT.DisableDuplicator = true

ENT.glitchthreshold = 24 --threshold distance from bone to reset pos
ENT.glitchthresholds = {}
ENT.glitchthresholds["ValveBiped.Bip01_Head1"] = 8
ENT.glitchthresholds["ValveBiped.Bip01_Head"] = 8
ENT.glitchthresholds["ValveBiped.Bip01_R_Hand"] = 1
ENT.glitchthresholds["ValveBiped.Bip01_L_Hand"] = 1
ENT.glitchthresholds["ValveBiped.Bip01_Spine2"] = 40

ENT.Hull = 1.5 --Expand hull to make it easier to grab
ENT.PredictCL = false
ENT.UseMod = false --Experimentally modify the parent's Use func

local cv_al = GetConVar("sv_tfa_arrow_lifetime")
local nzombies

local function GetBoneCenter(ent, bone)
	local bonechildren = ent:GetChildBones(bone)

	if #bonechildren <= 0 then
		return ent:GetBonePosition(bone)
	else
		local bonepos = ent:GetBonePosition(bone)
		local tmppos = bonepos

		if tmppos then
			for i = 1, #bonechildren do
				local childpos = ent:GetBonePosition(bonechildren[i])

				if childpos then
					tmppos = (tmppos + childpos) / 2
				end
			end
		else
			return ent:GetPos()
		end

		return tmppos
	end
end

function ENT:Initialize()

	if nzombies == nil then
		nzombies = nZombies or NZ or NZombies or engine.ActiveGamemode() == "nzombies"
	end

	local mdl = self:GetModel()

	if not mdl or mdl == "" or mdl == "models/error.mdl" then
		self:SetModel("models/weapons/w_tfa_arrow.mdl")
	end

	if SERVER then

		local mins = (self:OBBMins() and self:OBBMins() or Vector(0, 0, 0)) - Vector(1, 1, 1)
		local maxs = (self:OBBMaxs() and self:OBBMaxs() or Vector(0, 0, 0)) + Vector(1, 1, 1)
		self:PhysicsInitBox(mins * self.Hull, maxs * self.Hull)
		--self:PhysicsInit( SOLID_VPHYSICS )
		--self:SetSolid( SOLID_VPHYSICS )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		local phys = self:GetPhysicsObject()

		if (phys:IsValid()) then
			phys:Wake()
			phys:SetMass(2)
			phys:EnableGravity(false)
			phys:EnableCollisions(false)
		end

		if self.SetUseType then
			self:SetUseType(SIMPLE_USE)
		end

		if cv_al:GetInt() ~= -1 then
			timer.Simple( cv_al:GetFloat(), function()
				if IsValid(self) then
					self:Remove()
				end
			end)
		end

		self:SetUseType( SIMPLE_USE )
	end

	if SERVER then
		self:TargetEnt( true )
	end

	if CLIENT then
		self:SetPredictable(false)
	end

	if (self:GetModel() and self:GetModel() == "") then
		self:SetModel("models/weapons/w_tfa_arrow.mdl")
	end

	self:SetCollisionGroup(COLLISION_GROUP_WEAPON)

	self:DrawShadow(true)
end

function ENT:TargetEnt( init )
	if self.targent and IsValid(self.targent) then
		if init then
			local ent, bone, bonepos, bonerot
			ent = self.targent
			bone = self.targent:TranslatePhysBoneToBone(self.targphysbone)
			self.targbone = bone

			if not ent:GetBoneCount() or ent:GetBoneCount() <= 1 or string.find(ent:GetModel(), "door") then
				bonepos = ent:GetPos()
				bonerot = ent:GetAngles()
				self.enthasbones = false
			else
				if ent.SetupBones then
					ent:SetupBones()
				end

				bonepos, bonerot = ent:GetBonePosition(bone)
				self.enthasbones = true
			end

			if self.enthasbones == true then
				local gpos = self:GetPos()
				local bonepos2 = GetBoneCenter(ent, bone)
				local tmpgts = self.glitchthresholds[ent:LookupBone(bone)] or self.glitchthreshold

				while gpos:Distance(bonepos2) > tmpgts do
					self:SetPos((gpos + bonepos2) / 2)
					gpos = (gpos + bonepos2) / 2
				end
			end

			if not bonepos then
				bonepos = ent:GetPos()
				bonerot = ent:GetAngles()
			end

			self.posoff, self.angoff = WorldToLocal(self:GetPos(), self:GetAngles(), bonepos, bonerot)
		end
		self:FollowBone( self.targent, self.targbone or -1 )
		self:SetOwner( self.targent )
		self:SetLocalPos( self.posoff )
		self:SetLocalAngles( self.angoff )
		self.HTE = true
		if SERVER and self.PredictCL then
			timer.Simple(0.05,function()
				if IsValid(self) then
					net.Start("tfaArrowFollow")
					net.WriteEntity( self )
					net.WriteEntity( self.targent )
					net.WriteInt( self.targbone, 8 )
					net.WriteVector( self.posoff )
					net.WriteAngle( self.angoff )
					net.Broadcast()
				end
			end)
		end
	end
end

function ENT:Think()
	if CLIENT and not self.PredictCL then return end
	if IsValid(self.targent) and self.targent.Health and self.targent:Health() <= 0 and self.targent.GetRagdollEntity then
		local rag = self.targent:GetRagdollEntity()
		if IsValid(rag) then
			self.targent = rag
			self:TargetEnt( false )
		end
	end
	local par = self:GetParent()
	if IsValid(par) and self.UseMod and not par.HasUseMod then
		par.HasUseMod = true
		par.ArrowUseOld = par.ArrowUseOld or par.Use
		par.Use = function( parent, ... )
			for _,v in pairs( par:GetChildren() ) do
				if v.Use then v:Use(...) end
			end
			parent:Use( ... )
		end
		par:SetUseType( SIMPLE_USE )
	end
	if SERVER and not self.HTE then
		self:TargetEnt( true )
	end
	self:NextThink(CurTime())
	return true
end
--lua/entities/tracking-device/cl_init.lua:
--[[---------------------------------------------------------------------------
This is an example of a custom entity.
---------------------------------------------------------------------------]]
include("shared.lua")

function ENT:Circle(x, y, r, step, cache)
    local positions = {}
    for i = 0, 360, step do
        table.insert(positions, {
            x = x + math.cos(math.rad(i)) * r,
            y = y + math.sin(math.rad(i)) * r
        })
    end

    return (cache and positions) or surface.DrawPoly(positions)
end

local typ = false
local model

function ENT:Initialize() 
    typ = self:GetParent():IsPlayer()
    if typ then
        model = ClientsideModel( "models/2rek/thejoe/sw_tracker_1_prop.mdl" )
        model:SetNoDraw( true )

        local entply = self:GetParent()

        hook.Add( "PostPlayerDraw" , "joe.playerdraw" .. self:EntIndex() , function( ply )
            if ply != entply then return end
            if not IsValid(ply) or not ply:Alive() then return end 

            local attid = ply:LookupAttachment("chest")
            if not attid then return end
            local tbl = ply:GetAttachment(attid)
            local pos,ang = tbl.Pos,tbl.Ang
  
            pos = pos + ang:Forward() * -7
            ang = ang

            ang:RotateAroundAxis(ang:Up(), 90)
            ang:RotateAroundAxis(ang:Forward(), -95)
            
            model:SetPos(pos)
            model:SetAngles(ang)

            model:SetRenderOrigin(pos)
            model:SetRenderAngles(ang)
            model:SetupBones()
            model:DrawModel()
            model:SetRenderOrigin()
            model:SetRenderAngles()

        end )
    end
end

function ENT:Draw()
    if typ then 
        cam.Start3D2D( model:LocalToWorld(Vector(0,0,0.96)), model:GetAngles(), 0.01 )
            local speed = math.Clamp( math.abs( math.sin( CurTime() * 5 ) * 0.8 ) * 255 ,0,255)
            surface.SetDrawColor(Color(255, 255, 0, speed))
            draw.NoTexture()
            self:Circle(0,0,40,1,false)
        cam.End3D2D()
    else
        self:DrawModel()

        cam.Start3D2D( self:LocalToWorld(Vector(0,0,0.96)), self:GetAngles(), 0.01 )
            local speed = math.Clamp( math.abs( math.sin( CurTime() * 5 ) * 0.8 ) * 255 ,0,255)
            surface.SetDrawColor(Color(255, 255, 0, speed))
            draw.NoTexture()
            self:Circle(0,0,40,1,false)
        cam.End3D2D()
    end
end

function ENT:OnRemove()
    if typ then
        hook.Remove("PostPlayerDraw" , "joe.playerdraw" .. self:EntIndex())
    end
end

--addons/emplacements/lua/entities/turret_40mm_frag/shared.lua:
 ENT.Type 			= "anim"  
 ENT.Base 			= "base_gmodentity"     
 ENT.PrintName			= "40mm High Explosive"  
 ENT.Author			= "Generic Default"  
 ENT.Contact			= "AIDS"  
 ENT.Purpose			= "SPLODE"  
 ENT.Instructions		= "SHOOT"  
 
ENT.Spawnable			= false
ENT.AdminSpawnable		= false


--addons/emplacements/lua/entities/turret_bullets2_deployable/shared.lua:
ENT.Type 			= "anim"
ENT.Base 			= "base_anim"

ENT.Category		= "CW:RP Geschütze"
ENT.PrintName 		= "Heavy Blaster Cannon Deployable"
ENT.Author			= "Wolly/BOT_09 | Airfox"
ENT.Spawnable		= true
ENT.AdminSpawnable	= false

ENT.IsTurret		= true

ENT.TurretFloatHeight=3
ENT.TurretModelOffset=Vector(0,0,44)
ENT.TurretTurnMax=0.7

ENT.LastShot = 0
ENT.ShotInterval = 0.5


function ENT:SetupDataTables()
	self:DTVar("Entity",0,"Shooter")
	self:DTVar("Entity",1,"ShootPos")
end

function ENT:SetShooter(plr)
	self.Shooter=plr
	self:SetDTEntity(0,plr)
end

function ENT:GetShooter(plr)
	if SERVER then
		return self.Shooter
	elseif CLIENT then
		return self:GetDTEntity(0)
	end
end


function ENT:Use(plr)
	
	if not self:ShooterStillValid() then
		self:SetShooter(plr)
		self:StartShooting()
		self.ShooterLast=plr
		
		
	else
		if plr==self.Shooter then
			self:SetShooter(nil)
			self:FinishShooting()
			
		end
	end
end


function ENT:ShooterStillValid()
	local shooter=nil
	if SERVER then
		shooter=self.Shooter
	elseif CLIENT then
		shooter=self:GetDTEntity(0)
	end
	
	return IsValid(shooter) and shooter:Alive() and ((self:GetPos()+self.TurretModelOffset):Distance(shooter:GetShootPos())<=90)
end



function ENT:DoShot()
	if self.LastShot + self.ShotInterval < CurTime() then
		if SERVER then
			self:EmitSound(self.ShotSound)
		end

		if IsValid(self.shootPos) and SERVER then

			self.shootPos:FireBullets({
				Num=1,
				Src=self.shootPos:GetPos()+self.shootPos:GetAngles():Up()*10,
				Dir=self.shootPos:GetAngles():Up() * 1,
				Spread = Vector(0.0075,0.0075,0),
				Tracer = 0,
				Force = 50,
				Damage = 100,
				Attacker = self.Shooter,
				Callback = function(attacker, tr,dmginfo) 
						
					local tracerEffect=EffectData()
					tracerEffect:SetStart(self.shootPos:GetPos())
					tracerEffect:SetOrigin(tr.HitPos)
					tracerEffect:SetScale(6000)
					util.Effect("Tracer",tracerEffect)
					if not tr.HitSky then
					local effectdata = EffectData()
					effectdata:SetOrigin(tr.HitPos)
					effectdata:SetScale(1.5)
					effectdata:SetRadius(tr.MatType)
					effectdata:SetNormal(tr.HitNormal)
					util.Effect("rw_sw_laser_blue", effectdata)
					end

					if not (tr.HitSky or (IsValid(tr.Entity) and tr.Entity:IsPlayer())) then
						util.Decal("fadingscorch", tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)

						local effect = EffectData()
						effect:SetOrigin(tr.HitPos)
						effect:SetNormal(tr.HitNormal)
						util.Effect("effect_sw_impact", effect)

						local random = math.random(1, 24)

						if random < 10 then
							random = "0"..tostring(random)
						else
							random = tostring(random)
						end

						local effect = EffectData()
						effect:SetOrigin(tr.HitPos)
						effect:SetStart(tr.StartPos)
						effect:SetDamageType(DMG_BULLET)

						util.Effect("RagdollImpact", effect)
					end

				end
			})
			self:GetPhysicsObject():ApplyForceCenter( self:GetRight() * -10000 )
		end

		self.LastShot = CurTime()
	end
	
end



function ENT:Think()
	
	if not IsValid(self.turretBase) and SERVER then
		SafeRemoveEntity(self)
	else
		--[[if IsValid(self.shootPos) or self.shootPos==NULL then
			if CLIENT then
				
				self.shootPos=self:GetDTEntity(1)
			elseif SERVER then
				
				self:SetDTEntity(1,self.shootPos)
			end
		end]]
		if IsValid(self) then
			
			if SERVER then
				self.BasePos=self.turretBase:GetPos()
				self.OffsetPos=self.turretBase:GetAngles():Up()*1
			end
			
			if self:ShooterStillValid() then
			
				if SERVER then
					local offsetAng=(self:GetAttachment(self.MuzzleAttachment).Pos-self:GetDesiredShootPos()):GetNormal()
					local offsetDot=(self.turretBase:GetAngles():Right()*-1):DotProduct(offsetAng)
					local HookupPos=self:GetAttachment(self.HookupAttachment).Pos
					if offsetDot>=self.TurretTurnMax then
						local offsetAngNew=offsetAng:Angle()
						offsetAngNew:RotateAroundAxis(offsetAngNew:Up(),-90)
						
						self.OffsetAng=offsetAngNew
						
					end
				end
				
				local pressKey=IN_BULLRUSH
				if CLIENT and game.SinglePlayer() then
					pressKey=IN_ATTACK
					
				end
				
				self.Firing=self:GetShooter():KeyDown(pressKey)
				
			else
				self.Firing=false
				if SERVER then
					self.OffsetAng=self.turretBase:GetAngles()
					
					self:SetShooter(nil)
					self:FinishShooting()
				end
			end
			
			if self.Firing then
				self:DoShot()
			end
			self:NextThink(CurTime())
			return true
		end
	end
end	
--addons/emplacements/lua/entities/turret_bullets_deployable/cl_init.lua:

include("shared.lua")

function ENT:Initialize()
	self.MuzzleAttachment=self:LookupAttachment("muzzle")
	self.shootPos=self:GetDTEntity(1)
	
end
--[[
ENT.HiddenShooter=false
function ENT:Think()
	if not self.HiddenShooter and IsValid(self.shootPos) then
		self.shootPos:SetRenderMode(RENDERMODE_TRANSCOLOR)
		self.shootPos:SetColor(Color(255,255,255,1))
		self.HiddenShooter=true
	end
	
end]]

function ENT:Draw()
	
	self:DrawModel()
	
	local p = self:GetPos()

	local ang = self:GetAngles()
	ang:RotateAroundAxis( ang:Forward(), 90 )
	ang:RotateAroundAxis( ang:Up(), 90 )
	ang.y = LocalPlayer():EyeAngles().y - 90
	if LocalPlayer():GetPos():DistToSqr( self:GetPos() ) < 250 * 250 then
		cam.Start3D2D( p + Vector( 0, 0, -10 ), Angle( 0, ang.y, 90 ), .15 )
			draw.RoundedBox( 5, - 180, - 400, 350, 105, Color( 0, 0, 0, 230 ) )
			draw.RoundedBox( 5, - 180, - 350 + 2, math.Clamp( self:Health() / self:GetMaxHealth() * 350, 0, 350 ), 50 - 2, Color( 150, 0, 0, 230 ) )
			--draw.DrawText( self:Health(), "BlahBlah2", 5, - 740, Color( 255, 255, 255, 255 ), TEXT_ALIGN_CENTER )
			draw.DrawText( "Blaster Cannon", "header", -1, - 395, Color( 52, 235, 146, 255 ), TEXT_ALIGN_CENTER )

		cam.End3D2D()
	end

end
--addons/emplacements/lua/entities/turret_rail_deployable/shared.lua:
ENT.Type 			= "anim"
ENT.Base 			= "base_anim"

ENT.Category		= "CW:RP Geschütze"
ENT.PrintName 		= "Anti Vehicle Cannon Deployable"
ENT.Author			= "Wolly/BOT_09"
ENT.Spawnable		= true
ENT.AdminSpawnable	= false

ENT.IsTurret		= true

ENT.TurretFloatHeight	=3
ENT.TurretModelOffset	=Vector(0,0,44)
ENT.TurretTurnMax		=0.7

ENT.LastShot 			=0
ENT.ShotInterval 		= 0.5

function ENT:SetupDataTables()
	self:DTVar("Entity",0,"Shooter")
	self:DTVar("Entity",1,"ShootPos")
end

function ENT:SetShooter(plr)
	self.Shooter=plr
	self:SetDTEntity(0,plr)
end

function ENT:GetShooter(plr)
	if SERVER then
		return self.Shooter
	elseif CLIENT then
		return self:GetDTEntity(0)
	end
end


function ENT:Use(plr)
	if not self:ShooterStillValid() then
		self:SetShooter(plr)
		self:StartShooting()
		self.ShooterLast=plr
		
		
	else
		if plr==self.Shooter then
			self:SetShooter(nil)
			self:FinishShooting()

		end
	end
end


function ENT:ShooterStillValid()
	local shooter=nil
	if SERVER then
		shooter=self.Shooter
	elseif CLIENT then
		shooter=self:GetDTEntity(0)
	end
	
	return IsValid(shooter) and shooter:Alive() and ((self:GetPos()+self.TurretModelOffset):Distance(shooter:GetShootPos())<=90)
end

function ENT:Think()
	
	if not IsValid(self.turretBase) and SERVER then
		SafeRemoveEntity(self)
	else
		if IsValid(self) then
			
			if SERVER then
				self.BasePos=self.turretBase:GetPos()
				self.OffsetPos=self.turretBase:GetAngles():Up()*1
			end
			
			if self:ShooterStillValid() then
			
				if SERVER then
					local offsetAng=(self:GetAttachment(self.MuzzleAttachment).Pos-self:GetDesiredShootPos()):GetNormal()
					local offsetDot=(self.turretBase:GetAngles():Right()*-1):DotProduct(offsetAng)
					local HookupPos=self:GetAttachment(self.HookupAttachment).Pos
					if offsetDot>=self.TurretTurnMax then
						local offsetAngNew=offsetAng:Angle()
						offsetAngNew:RotateAroundAxis(offsetAngNew:Up(),-90)
						
						self.OffsetAng=offsetAngNew
						
					end
				end
				
				local pressKey=IN_BULLRUSH
				if CLIENT and game.SinglePlayer() then
					pressKey=IN_ATTACK
					
				end
				
				self.Firing=self:GetShooter():KeyDown(pressKey)
				
			else
				self.Firing=false
				if SERVER then
					self.OffsetAng=self.turretBase:GetAngles()
					
					self:SetShooter(nil)
					self:FinishShooting()
				end
			end
			
			if self.Firing then
				self:DoShot()
			end
			self:NextThink(CurTime())
			return true
		end

	self.Shooter:DrawViewModel(true)
	self.Shooter:SetButtons(bit.bor(cmd:GetButtons() - IN_ATTACK, IN_BULLRUSH))

	end
end	

function ENT:DoShot()
	if self.LastShot+self.ShotInterval<CurTime() then
		if SERVER then
			
			-- local effectPosAng=self:GetAttachment(self.MuzzleAttachment)
			-- local vPoint = effectPosAng.Pos
			-- local effectdata = EffectData()
			-- effectdata:SetStart( vPoint )
			-- effectdata:SetOrigin( vPoint )
			-- effectdata:SetAngles(effectPosAng.Ang + Angle(0,-90,0))
			-- effectdata:SetEntity(self)
			-- effectdata:SetScale( 1 )
			-- util.Effect( "MuzzleEffect", effectdata )
		end
		
		if IsValid(self.shootPos) and SERVER then
			self.shootPos:FireBullets({
				Num=1,
				Src=self.shootPos:GetPos()+self.shootPos:GetAngles():Up()*10,
				Dir=self.shootPos:GetAngles():Up() * 1,
				Spread = Vector(0.0075,0.0075,0),
				Tracer = 0,
				Force = 50,
				Damage = 3000,
				Attacker=self.Shooter,
				Callback=function(attacker, tr,dmginfo) 
						
					local tracerEffect=EffectData()
					tracerEffect:SetStart(self.shootPos:GetPos())
					tracerEffect:SetOrigin(tr.HitPos)
					tracerEffect:SetScale(6000)
					util.Effect("Tracer",tracerEffect)
					if not tr.HitSky then
					local effectdata = EffectData()
					effectdata:SetOrigin(tr.HitPos)
					effectdata:SetScale(1.5)
					effectdata:SetRadius(tr.MatType)
					effectdata:SetNormal(tr.HitNormal)
					util.Effect("rw_sw_laser_blue", effectdata)
					end

					if not (tr.HitSky or (IsValid(tr.Entity) and tr.Entity:IsPlayer())) then
						util.Decal("fadingscorch", tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)
						
						local effect = EffectData()
						effect:SetOrigin(tr.HitPos)
						effect:SetNormal(tr.HitNormal)
						util.Effect("effect_sw_impact", effect)

						local random = math.random(1, 24)

						if random < 10 then
							random = "0"..tostring(random)
						else
							random = tostring(random)
						end

						sound.Play("effects/sw_impact/sw752_hit_"..random..".wav", tr.HitPos, 75, 100, 1)

						local effect = EffectData()
						effect:SetOrigin(tr.HitPos)
						effect:SetStart(tr.StartPos)
						effect:SetDamageType(DMG_BULLET)

						util.Effect("RagdollImpact", effect)
					end
					
				end
			})
			self:EmitSound(self.ShotSound)

			self:GetPhysicsObject():ApplyForceCenter( self:GetRight()*-10000 )
			
		end
		
		self.LastShot=CurTime()
	end
	
end
--lua/entities/vox_e60r_rocket/cl_init.lua:
 include('shared.lua')     
 //[[---------------------------------------------------------     
 //Name: Draw     Purpose: Draw the model in-game.     
 //Remember, the things you render first will be underneath!  
 //-------------------------------------------------------]]  
 function ENT:Draw()      
 // self.BaseClass.Draw(self)  
 -- We want to override rendering, so don't call baseclass.                                   
 // Use this when you need to add to the rendering.        
 self.Entity:DrawModel()       // Draw the model.   
 end
 
   function ENT:Initialize()
	pos = self:GetPos()
	self.emitter = ParticleEmitter( pos )
 end
 
 function ENT:Think()
	
	pos = self:GetPos()
		for i=0, (10) do
			local particle = self.emitter:Add( "particle/smokesprites_000"..math.random(1,9), pos + (self:GetForward() * -100 * i))
			if (particle) then
				particle:SetVelocity((self:GetForward() * -2000) )
				particle:SetDieTime( math.Rand( 1.5, 3 ) )
				particle:SetStartAlpha( math.Rand( 5, 8 ) )
				particle:SetEndAlpha( 0 )
				particle:SetStartSize( math.Rand( 40, 50 ) )
				particle:SetEndSize( math.Rand( 130, 150 ) )
				particle:SetRoll( math.Rand(0, 360) )
				particle:SetRollDelta( math.Rand(-1, 1) )
				particle:SetColor( 200 , 200 , 200 ) 
 				particle:SetAirResistance( 200 ) 
 				particle:SetGravity( Vector( 100, 0, 0 ) ) 	
			end
		
		end
end

--addons/wos-grandmaster-einf/lua/entities/wos_alcs_eternalflames/cl_init.lua:
include('shared.lua')

function ENT:Initialize()
end

function ENT:CreateBoom()
end

function ENT:OnRemove()
end

function ENT:Think()
end

function ENT:Draw()
end
--addons/wos-alcs-custom/lua/entities/wos_kyber_slam/shared.lua:
ENT.Type 			= "anim"
ENT.Base 			= "base_anim"
--addons/wos-passiveevent/lua/entities/wos_pes_capture_point/shared.lua:
ENT.Type 			= "anim"
ENT.Base 			= "base_anim"

ENT.PrintName		= "PES Capture Point"
ENT.Author			= "Oliver (wiltOS)"
ENT.Purpose			= "N/A"

ENT.RenderGroup     = RENDERGROUP_BOTH

function ENT:SetupDataTables()
    self:NetworkVar("Float", 0, "CaptureValue")
    self:NetworkVar("Float", 1, "MaxCaptureValue")
    self:NetworkVar("Float", 2, "CaptureRange")
    self:NetworkVar("Float", 3, "CaptureRate")

    if SERVER then
        self:SetCaptureValue(0)
        self:SetMaxCaptureValue(10)
        self:SetCaptureRange(60)
        self:SetCaptureRate(1)
    end
end

function ENT:SharedInit()
    local phys = self:GetPhysicsObject()
    if ( IsValid( phys ) ) then
        phys:EnableMotion( false )
        phys:EnableDrag( false )
        phys:EnableGravity( false )
        phys:Sleep()

        phys:AddGameFlag(FVPHYSICS_CONSTRAINT_STATIC)
        phys:AddGameFlag(FVPHYSICS_NO_IMPACT_DMG)
        phys:AddGameFlag(FVPHYSICS_NO_NPC_IMPACT_DMG)
        phys:AddGameFlag(FVPHYSICS_NO_PLAYER_PICKUP)
        phys:AddGameFlag(FVPHYSICS_NO_SELF_COLLISIONS)
    end

    self:AddEffects(EF_NORECEIVESHADOW)
    self:AddEffects(EF_NOINTERP)

    self:AddFlags(FL_STATICPROP)
    self:AddFlags(FL_DONTTOUCH)

    self:AddEFlags(EFL_NO_DAMAGE_FORCES)
    self:AddEFlags(EFL_NO_GAME_PHYSICS_SIMULATION)
    self:AddEFlags(EFL_NO_DISSOLVE)
    self:AddEFlags(EFL_NO_MEGAPHYSCANNON_RAGDOLL)
    self:AddEFlags(EFL_NO_PHYSCANNON_INTERACTION)
    self:AddEFlags(EFL_NO_ROTORWASH_PUSH)
    self:AddEFlags(EFL_NO_WATER_VELOCITY_CHANGE)
end

--addons/wos-alcs-custom/lua/entities/wos_saber_station/shared.lua:
ENT.Type 		= "anim"
ENT.PrintName	= "Lightsaber Crafting Station"
ENT.Author		= "King David"
ENT.Contact		= ""
ENT.Category = "wiltOS Technologies"
ENT.Spawnable			= true
ENT.AdminSpawnable		= true

function ENT:Think()
	if not self.BuildingSound then
		self.BuildingSound = CreateSound( self.Entity, "ambient/machines/combine_shield_loop3.wav" )
		self.BuildingSound:Play()
	end
end

function ENT:OnRemove()
	self.BuildingSound:Stop()
end
--addons/wos-alcs-custom/lua/entities/wos_sonic_discharge/cl_init.lua:
include('shared.lua')

function ENT:Initialize()

end

function ENT:CreateBoom()

end

function ENT:OnRemove()


end

function ENT:Think()

end

function ENT:Draw()
	
end


--addons/egm_lvs_ships/lua/entities/ywing_bomb/shared.lua:
ENT.Base            = "base_gmodentity"
ENT.Type            = "anim"

ENT.PrintName       = "Bombe"
ENT.Author          = "Miller"
ENT.Information     = ""
ENT.Category        = "[LVS] - Republic"

ENT.Spawnable		= false
ENT.AdminSpawnable	= false

game.AddParticles("particles/gb5_100lb.pcf")
PrecacheParticleSystem("100lb_ground")
--addons/wos-alcs-blades-anzati/lua/effects/anzati_ghosts/init.lua:

function EFFECT:Init( data )
	local pos = data:GetOrigin()
	local dir = data:GetNormal()
	local len = data:GetRadius()
	local color = data:GetAngles()
	local emitter = ParticleEmitter( pos )

	local number_lol = 1

	if ( !emitter ) then return end

	for i = 0, len / number_lol do
		local pos2 = pos + dir * ( len - i * number_lol )
		--local particle = emitter:Add( "effects/muzzleflash"..math.random(1,4), pos2 )
		local particle = emitter:Add( "wos/lightsabers/effects/anzati/halloween", pos2 )
		if ( particle ) then
			particle:SetLifeTime( 0 )
			particle:SetDieTime( 0.3 )

			particle:SetGravity( Vector( 0, 0, math.random( 32, 128 ) ) )
			particle:SetVelocity( Vector( math.random( -8, 8 ), math.random( -8, 8 ), math.random( -8, 8 ) ) )

			particle:SetStartSize( 1 )
			particle:SetEndSize( 0 )

			particle:SetStartAlpha( math.random( 100, 200 ) )
			particle:SetEndAlpha( 0 )

			particle:SetColor( color.p, color.y, color.r )
			particle:SetAngleVelocity( Angle( math.Rand( -180, 180 ), math.Rand( -180, 180 ), math.Rand( -180, 180 ) ) )
			//particle:SetLighting( true )
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--addons/wos-alcs-blades-anzati/lua/effects/anzati_proton/init.lua:

function EFFECT:Init( data )
	local pos = data:GetOrigin()
	local dir = data:GetNormal()
	local len = data:GetRadius()
	local color = data:GetAngles()
	local emitter = ParticleEmitter( pos )

	local number_lol = 1

	if ( !emitter ) then return end

	for i = 0, len / number_lol do
		local pos2 = pos + dir * ( len - i * number_lol )
		--local particle = emitter:Add( "effects/muzzleflash"..math.random(1,4), pos2 )
		local particle = emitter:Add( "wos/lightsabers/effects/anzati/proton", pos2 )
		if ( particle ) then
			particle:SetLifeTime( 0 )
			particle:SetDieTime( 0.3 )

			particle:SetGravity( Vector( 0, 0, math.random( 32, 128 ) ) )
			particle:SetVelocity( Vector( math.random( -8, 8 ), math.random( -8, 8 ), math.random( -8, 8 ) ) )

			particle:SetStartSize( 1 )
			particle:SetEndSize( 0 )

			particle:SetStartAlpha( math.random( 100, 200 ) )
			particle:SetEndAlpha( 0 )

			particle:SetColor( color.p, color.y, color.r )
			particle:SetAngleVelocity( Angle( math.Rand( -180, 180 ), math.Rand( -180, 180 ), math.Rand( -180, 180 ) ) )
			//particle:SetLighting( true )
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--addons/wos-alcs-blades-anzati/lua/effects/anzati_swtor1/init.lua:

function EFFECT:Init( data )
	local pos = data:GetOrigin()
	local dir = data:GetNormal()
	local len = data:GetRadius()
	local color = data:GetAngles()
	local emitter = ParticleEmitter( pos )

	local number_lol = 1

	if ( !emitter ) then return end

	for i = 0, len / number_lol do
		local pos2 = pos + dir * ( len - i * number_lol )
		--local particle = emitter:Add( "effects/muzzleflash"..math.random(1,4), pos2 )
		local particle = emitter:Add( "wos/lightsabers/effects/anzati/swtor", pos2 )		
		if ( particle ) then
			particle:SetLifeTime( 0 )
			particle:SetDieTime( 0.3 )

			particle:SetGravity( Vector( 0, 0, math.random( 32, 128 ) ) )
			particle:SetVelocity( Vector( math.random( -8, 8 ), math.random( -8, 8 ), math.random( -8, 8 ) ) )

			particle:SetStartSize( 1 )
			particle:SetEndSize( 0 )

			particle:SetStartAlpha( math.random( 100, 200 ) )
			particle:SetEndAlpha( 0 )

			particle:SetColor( color.p, color.y, color.r )
			particle:SetAngleVelocity( Angle( math.Rand( -180, 180 ), math.Rand( -180, 180 ), math.Rand( -180, 180 ) ) )
			//particle:SetLighting( true )
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--addons/wos-alcs-blades-anzati/lua/effects/anzati_swtor12/init.lua:

function EFFECT:Init( data )
	local pos = data:GetOrigin()
	local dir = data:GetNormal()
	local len = data:GetRadius()
	local color = data:GetAngles()
	local emitter = ParticleEmitter( pos )

	local number_lol = 1

	if ( !emitter ) then return end

	for i = 0, len / number_lol do
		local pos2 = pos + dir * ( len - i * number_lol )
		--local particle = emitter:Add( "effects/muzzleflash"..math.random(1,4), pos2 )
		local particle = emitter:Add( "wos/lightsabers/effects/anzati/swtor12", pos2 )		
		if ( particle ) then
			particle:SetLifeTime( 0 )
			particle:SetDieTime( 0.3 )

			particle:SetGravity( Vector( 0, 0, math.random( 32, 128 ) ) )
			particle:SetVelocity( Vector( math.random( -8, 8 ), math.random( -8, 8 ), math.random( -8, 8 ) ) )

			particle:SetStartSize( 1 )
			particle:SetEndSize( 0 )

			particle:SetStartAlpha( math.random( 100, 200 ) )
			particle:SetEndAlpha( 0 )

			particle:SetColor( color.p, color.y, color.r )
			particle:SetAngleVelocity( Angle( math.Rand( -180, 180 ), math.Rand( -180, 180 ), math.Rand( -180, 180 ) ) )
			//particle:SetLighting( true )
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--addons/wos-alcs-blades-anzati/lua/effects/anzati_swtor2/init.lua:

function EFFECT:Init( data )
	local pos = data:GetOrigin()
	local dir = data:GetNormal()
	local len = data:GetRadius()
	local color = data:GetAngles()
	local emitter = ParticleEmitter( pos )

	local number_lol = 1

	if ( !emitter ) then return end

	for i = 0, len / number_lol do
		local pos2 = pos + dir * ( len - i * number_lol )
		--local particle = emitter:Add( "effects/muzzleflash"..math.random(1,4), pos2 )
		local particle = emitter:Add( "wos/lightsabers/effects/anzati/swtor2", pos2 )		
		if ( particle ) then
			particle:SetLifeTime( 0 )
			particle:SetDieTime( 0.3 )

			particle:SetGravity( Vector( 0, 0, math.random( 32, 128 ) ) )
			particle:SetVelocity( Vector( math.random( -8, 8 ), math.random( -8, 8 ), math.random( -8, 8 ) ) )

			particle:SetStartSize( 1 )
			particle:SetEndSize( 0 )

			particle:SetStartAlpha( math.random( 100, 200 ) )
			particle:SetEndAlpha( 0 )

			particle:SetColor( color.p, color.y, color.r )
			particle:SetAngleVelocity( Angle( math.Rand( -180, 180 ), math.Rand( -180, 180 ), math.Rand( -180, 180 ) ) )
			//particle:SetLighting( true )
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--addons/wos-alcs-blades-anzati/lua/effects/anzati_swtor4/init.lua:

function EFFECT:Init( data )
	local pos = data:GetOrigin()
	local dir = data:GetNormal()
	local len = data:GetRadius()
	local color = data:GetAngles()
	local emitter = ParticleEmitter( pos )

	local number_lol = 1

	if ( !emitter ) then return end

	for i = 0, len / number_lol do
		local pos2 = pos + dir * ( len - i * number_lol )
		--local particle = emitter:Add( "effects/muzzleflash"..math.random(1,4), pos2 )
		local particle = emitter:Add( "wos/lightsabers/effects/anzati/swtor4", pos2 )		
		if ( particle ) then
			particle:SetLifeTime( 0 )
			particle:SetDieTime( 0.3 )

			particle:SetGravity( Vector( 0, 0, math.random( 32, 128 ) ) )
			particle:SetVelocity( Vector( math.random( -8, 8 ), math.random( -8, 8 ), math.random( -8, 8 ) ) )

			particle:SetStartSize( 1 )
			particle:SetEndSize( 0 )

			particle:SetStartAlpha( math.random( 100, 200 ) )
			particle:SetEndAlpha( 0 )

			particle:SetColor( color.p, color.y, color.r )
			particle:SetAngleVelocity( Angle( math.Rand( -180, 180 ), math.Rand( -180, 180 ), math.Rand( -180, 180 ) ) )
			//particle:SetLighting( true )
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--lua/effects/effect_cube/init.lua:
function EFFECT:Init(data)
	self:SetModel("models/editor/cube_small.mdl")
	self.m_bVisible = true
end

function EFFECT:SetID(ID) self.m_id = ID end
function EFFECT:GetID() return self.m_id end

function EFFECT:OnRemove()
end

function EFFECT:SetOrigin(pos) self.m_origin = pos; self:SetPos(pos) end

function EFFECT:SetVisible(b) self.m_bVisible = b end

function EFFECT:Think()
	self:SetPos(self.m_origin)
	return !self.m_bRemove
end

local colText = Color(255,255,255,255)
function EFFECT:Render()
	if(!self.m_bVisible) then return end
	self:DrawModel()
	local id = self:GetID()
	if(id) then
		local ang = LocalPlayer():EyeAngles()
		local pos = self:GetPos() +Vector(0,0,30)
		ang:RotateAroundAxis(ang:Forward(),90)
		ang:RotateAroundAxis(ang:Right(),90)
		cam.Start3D2D(pos,Angle(0,ang.y,90),0.5)
			draw.DrawText(id,"default",2,2,colText,TEXT_ALIGN_CENTER)
		cam.End3D2D()
	end
end
--lua/effects/effect_sw_laser_blue_akimbo_pu/init.lua:
TRACER_FLAG_USEATTACHMENT = 0x0002
SOUND_FROM_WORLD = 0
CHAN_STATIC = 6
EFFECT.Life = 1
EFFECT.Speed = 6500
EFFECT.Length = 64
--EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance = 72
local MaterialMain = Material("effects/sw_laser_blue_main")
local MaterialFront = Material("effects/sw_laser_blue_front")

function EFFECT:Init(data)
	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.WeaponEntOG = data:GetEntity()
	self.Attachment = data:GetAttachment()
	local owent

	if IsValid(self.WeaponEnt) then
		owent = self.WeaponEnt.Owner or self.WeaponEnt:GetOwner()

		if not IsValid(owent) then
			owent = self.WeaponEnt:GetParent()
		end
	end

	if IsValid(owent) and owent:IsPlayer() then
		if owent ~= LocalPlayer() or owent:ShouldDrawLocalPlayer() then
			self.WeaponEnt = owent:GetActiveWeapon()
			if not IsValid(self.WeaponEnt) then return end
		else
			self.WeaponEnt = owent:GetViewModel()
			local theirweapon = owent:GetActiveWeapon()

			if IsValid(theirweapon) and theirweapon.ViewModelFlip or theirweapon.ViewModelFlipped then
				self.Flipped = true
			end

			if not IsValid(self.WeaponEnt) then return end
		end
	end

	if IsValid(self.WeaponEntOG) and self.WeaponEntOG.MuzzleAttachment then
		self.Attachment = self.WeaponEnt:LookupAttachment(self.WeaponEntOG.MuzzleAttachment)

		if not self.Attachment or self.Attachment <= 0 then
			self.Attachment = 1
		end

		if self.WeaponEntOG.Akimbo then
			if game.SinglePlayer() then
				self.WeaponEntOG.AnimCycle = self.WeaponEntOG:GetNW2Int("AnimCycle") or 0
			end
			self.Attachment = 1 + self.WeaponEntOG.AnimCycle
		end
	end

	local angpos

	if IsValid(self.WeaponEnt) then
		angpos = self.WeaponEnt:GetAttachment(self.Attachment)
	end

	if not angpos or not angpos.Pos then
		angpos = {
			Pos = bvec,
			Ang = uAng
		}
	end

	if self.Flipped then
		local tmpang = (self.Dir or angpos.Ang:Forward()):Angle()
		local localang = self.WeaponEnt:WorldToLocalAngles(tmpang)
		localang.y = localang.y + 180
		localang = self.WeaponEnt:LocalToWorldAngles(localang)
		--localang:RotateAroundAxis(localang:Up(),180)
		--tmpang:RotateAroundAxis(tmpang:Up(),180)
		self.Dir = localang:Forward()
	end

	-- Keep the start and end Pos - we're going to interpolate between them
	if IsValid(owent) and self.Position:Distance(owent:GetShootPos()) > 72 then
		self.WeaponEnt = nil
	end

	self.StartPos = self:GetTracerShootPos(self.WeaponEnt and angpos.Pos or self.Position, self.WeaponEnt, self.Attachment)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	self.Normal = (self.EndPos - self.StartPos):GetNormalized()
	self.StartTime = 0
	self.LifeTime = self.Life
	self.data = data
	self.rot = nil
	weapon = data:GetEntity()

	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()

	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 8, 8, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 10, 0, 1, color_white)
end
--lua/effects/effect_sw_laser_blue_stun/init.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002;
SOUND_FROM_WORLD			= 0;
CHAN_STATIC					= 6;

EFFECT.Speed				= 6500;
EFFECT.Length				= 64;
--EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 72;

local MaterialMain			= Material( "star/effects/blue_shockwave" );
local MaterialFront			= Material( "star/effects/blue_shockwave" );

function EFFECT:GetTracerOrigin(data)
	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart()

	-- use attachment?
	if (bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT) then
		local entity = data:GetEntity()
		if (not IsValid(entity)) then return start end
		if (not game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT)) then return start end

		if (entity:IsWeapon() and entity:IsCarriedByLocalPlayer()) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			-- use the view model
			local pl = entity:GetOwner()

			if (IsValid(pl)) then
				local vm = pl:GetViewModel()

				if (IsValid(vm) and not LocalPlayer():ShouldDrawLocalPlayer()) then
					entity = vm
					-- HACK: fix the model in multiplayer
				else
					if (entity.WorldModel) then
						entity:SetModel(entity.WorldModel)
					end
				end
			end
		end

		local attachment = entity:GetAttachment(data:GetAttachment())

		if (attachment) then
			start = attachment.Pos
		end
	end

	return start
end

function EFFECT:Init(data)
	self.StartPos = self:GetTracerOrigin(data)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	local diff = (self.EndPos - self.StartPos)
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = (diff:Length() + self.Length) / self.Speed
	-- whiz by sound
	local weapon = data:GetEntity()

	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()

	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 35, 35, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 10, 0, 1, color_white)
end

--lua/effects/effect_sw_laser_green_akimbo/init.lua:
TRACER_FLAG_USEATTACHMENT	= 0x0002
SOUND_FROM_WORLD			= 0
CHAN_STATIC					= 6

EFFECT.Speed				= 6500
EFFECT.Length				= 64
--EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 72

local MaterialMain			= Material( "effects/sw_laser_green_main" )
local MaterialFront			= Material( "effects/sw_laser_green_front" )

function EFFECT:GetTracerOrigin(data)
	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart()

	-- use attachment?
	if (bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT) then
		local entity = data:GetEntity()
		local att = 2 - entity.AnimCycle or data:GetAttachment()
		if (not IsValid(entity)) then return start end
		if (not game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT)) then return start end

		if (entity:IsWeapon() and entity:IsCarriedByLocalPlayer()) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			-- use the view model
			local pl = entity:GetOwner()

			if (IsValid(pl)) then
				local vm = pl:GetViewModel()

				if (IsValid(vm) and not LocalPlayer():ShouldDrawLocalPlayer()) then
					entity = vm
					-- HACK: fix the model in multiplayer
				else
					if (entity.WorldModel) then
						entity:SetModel(entity.WorldModel)
					end
				end
			end
		end

		local attachment = entity:GetAttachment(att)

		if (attachment) then
			start = attachment.Pos
		end
	end

	return start
end

function EFFECT:Init(data)
	self.StartPos = self:GetTracerOrigin(data)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	local diff = self.EndPos - self.StartPos
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = (diff:Length() + self.Length) / self.Speed
	-- whiz by sound
	local weapon = data:GetEntity()

	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()

	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 8, 8, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 10, 0, 1, color_white)
end

--lua/effects/effect_sw_laser_green_akimbo_pu/init.lua:
TRACER_FLAG_USEATTACHMENT = 0x0002
SOUND_FROM_WORLD = 0
CHAN_STATIC = 6
EFFECT.Life = 1
EFFECT.Speed = 6500
EFFECT.Length = 64
--EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance = 72
local MaterialMain = Material("effects/sw_laser_green_main")
local MaterialFront = Material("effects/sw_laser_green_front")

function EFFECT:Init(data)
	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.WeaponEntOG = data:GetEntity()
	self.Attachment = data:GetAttachment()
	local owent

	if IsValid(self.WeaponEnt) then
		owent = self.WeaponEnt.Owner or self.WeaponEnt:GetOwner()

		if not IsValid(owent) then
			owent = self.WeaponEnt:GetParent()
		end
	end

	if IsValid(owent) and owent:IsPlayer() then
		if owent ~= LocalPlayer() or owent:ShouldDrawLocalPlayer() then
			self.WeaponEnt = owent:GetActiveWeapon()
			if not IsValid(self.WeaponEnt) then return end
		else
			self.WeaponEnt = owent:GetViewModel()
			local theirweapon = owent:GetActiveWeapon()

			if IsValid(theirweapon) and theirweapon.ViewModelFlip or theirweapon.ViewModelFlipped then
				self.Flipped = true
			end

			if not IsValid(self.WeaponEnt) then return end
		end
	end

	if IsValid(self.WeaponEntOG) and self.WeaponEntOG.MuzzleAttachment then
		self.Attachment = self.WeaponEnt:LookupAttachment(self.WeaponEntOG.MuzzleAttachment)

		if not self.Attachment or self.Attachment <= 0 then
			self.Attachment = 1
		end

		if self.WeaponEntOG.Akimbo then
			if game.SinglePlayer() then
				self.WeaponEntOG.AnimCycle = self.WeaponEntOG:GetNW2Int("AnimCycle") or 0
			end
			self.Attachment = 1 + self.WeaponEntOG.AnimCycle
		end
	end

	local angpos

	if IsValid(self.WeaponEnt) then
		angpos = self.WeaponEnt:GetAttachment(self.Attachment)
	end

	if not angpos or not angpos.Pos then
		angpos = {
			Pos = bvec,
			Ang = uAng
		}
	end

	if self.Flipped then
		local tmpang = (self.Dir or angpos.Ang:Forward()):Angle()
		local localang = self.WeaponEnt:WorldToLocalAngles(tmpang)
		localang.y = localang.y + 180
		localang = self.WeaponEnt:LocalToWorldAngles(localang)
		--localang:RotateAroundAxis(localang:Up(),180)
		--tmpang:RotateAroundAxis(tmpang:Up(),180)
		self.Dir = localang:Forward()
	end

	-- Keep the start and end Pos - we're going to interpolate between them
	if IsValid(owent) and self.Position:Distance(owent:GetShootPos()) > 72 then
		self.WeaponEnt = nil
	end

	self.StartPos = self:GetTracerShootPos(self.WeaponEnt and angpos.Pos or self.Position, self.WeaponEnt, self.Attachment)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	self.Normal = (self.EndPos - self.StartPos):GetNormalized()
	self.StartTime = 0
	self.LifeTime = self.Life
	self.data = data
	self.rot = nil
	weapon = data:GetEntity()

	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()

	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 8, 8, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 10, 0, 1, color_white)
end
--lua/effects/effect_sw_laser_green_old/init.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002;
SOUND_FROM_WORLD			= 0;
CHAN_STATIC					= 6;

EFFECT.Speed				= 6500;
EFFECT.Length				= 64;
--EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 72;

local MaterialMain			= Material( "effects/sw_laser_green_main" );
local MaterialFront			= Material( "effects/sw_laser_green_front" );

function EFFECT:GetTracerOrigin(data)
	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart()

	-- use attachment?
	if (bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT) then
		local entity = data:GetEntity()
		if (not IsValid(entity)) then return start end
		if (not game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT)) then return start end

		if (entity:IsWeapon() and entity:IsCarriedByLocalPlayer()) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			-- use the view model
			local pl = entity:GetOwner()

			if (IsValid(pl)) then
				local vm = pl:GetViewModel()

				if (IsValid(vm) and not LocalPlayer():ShouldDrawLocalPlayer()) then
					entity = vm
					-- HACK: fix the model in multiplayer
				else
					if (entity.WorldModel) then
						entity:SetModel(entity.WorldModel)
					end
				end
			end
		end

		local attachment = entity:GetAttachment(data:GetAttachment())

		if (attachment) then
			start = attachment.Pos
		end
	end

	return start
end

function EFFECT:Init(data)
	self.StartPos = self:GetTracerOrigin(data)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	local diff = self.EndPos - self.StartPos
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = (diff:Length() + self.Length) / self.Speed
	-- whiz by sound
	local weapon = data:GetEntity()

	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()

	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 8, 8, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 10, 0, 1, color_white)
end

--lua/effects/effect_sw_laser_purple/init.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002;
SOUND_FROM_WORLD			= 0;
CHAN_STATIC					= 6;

EFFECT.Speed				= 6500;
EFFECT.Length				= 64;
--EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 72;

local MaterialMain			= Material( "effects/sw_laser_purple_main" );
local MaterialFront			= Material( "effects/sw_laser_purple_front" );

function EFFECT:GetTracerOrigin(data)
	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart()

	-- use attachment?
	if (bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT) then
		local entity = data:GetEntity()
		if (not IsValid(entity)) then return start end
		if (not game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT)) then return start end

		if (entity:IsWeapon() and entity:IsCarriedByLocalPlayer()) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			-- use the view model
			local pl = entity:GetOwner()

			if (IsValid(pl)) then
				local vm = pl:GetViewModel()

				if (IsValid(vm) and not LocalPlayer():ShouldDrawLocalPlayer()) then
					entity = vm
					-- HACK: fix the model in multiplayer
				else
					if (entity.WorldModel) then
						entity:SetModel(entity.WorldModel)
					end
				end
			end
		end

		local attachment = entity:GetAttachment(data:GetAttachment())

		if (attachment) then
			start = attachment.Pos
		end
	end

	return start
end

function EFFECT:Init(data)
	self.StartPos = self:GetTracerOrigin(data)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	local diff = self.EndPos - self.StartPos
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = (diff:Length() + self.Length) / self.Speed
	-- whiz by sound
	local weapon = data:GetEntity()

	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	if DynamicTracer:GetBool() then
		local spawn = util.CRC(tostring(self:GetPos()))
		local dlight = DynamicLight(self:EntIndex() + spawn)
		local endDistance = self.Speed * self.StartTime
		local endPos = self.StartPos + self.Normal * endDistance

		if (dlight) then
			dlight.pos = endPos
			dlight.r = 102
			dlight.g = 0
			dlight.b = 204
			dlight.brightness = 3
			dlight.Decay = 1000
			dlight.Size = 300
			dlight.DieTime = CurTime() + 3
		end
	end

	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 8, 8, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 10, 0, 1, color_white)
end
--lua/effects/effect_sw_laser_purple_akimbo_pu/init.lua:
TRACER_FLAG_USEATTACHMENT = 0x0002
SOUND_FROM_WORLD = 0
CHAN_STATIC = 6
EFFECT.Life = 1
EFFECT.Speed = 6500
EFFECT.Length = 64
--EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance = 72
local MaterialMain = Material("effects/sw_laser_purple_main")
local MaterialFront = Material("effects/sw_laser_purple_front")

function EFFECT:Init(data)
	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.WeaponEntOG = data:GetEntity()
	self.Attachment = data:GetAttachment()
	local owent

	if IsValid(self.WeaponEnt) then
		owent = self.WeaponEnt.Owner or self.WeaponEnt:GetOwner()

		if not IsValid(owent) then
			owent = self.WeaponEnt:GetParent()
		end
	end

	if IsValid(owent) and owent:IsPlayer() then
		if owent ~= LocalPlayer() or owent:ShouldDrawLocalPlayer() then
			self.WeaponEnt = owent:GetActiveWeapon()
			if not IsValid(self.WeaponEnt) then return end
		else
			self.WeaponEnt = owent:GetViewModel()
			local theirweapon = owent:GetActiveWeapon()

			if IsValid(theirweapon) and theirweapon.ViewModelFlip or theirweapon.ViewModelFlipped then
				self.Flipped = true
			end

			if not IsValid(self.WeaponEnt) then return end
		end
	end

	if IsValid(self.WeaponEntOG) and self.WeaponEntOG.MuzzleAttachment then
		self.Attachment = self.WeaponEnt:LookupAttachment(self.WeaponEntOG.MuzzleAttachment)

		if not self.Attachment or self.Attachment <= 0 then
			self.Attachment = 1
		end

		if self.WeaponEntOG.Akimbo then
			if game.SinglePlayer() then
				self.WeaponEntOG.AnimCycle = self.WeaponEntOG:GetNW2Int("AnimCycle") or 0
			end
			self.Attachment = 1 + self.WeaponEntOG.AnimCycle
		end
	end

	local angpos

	if IsValid(self.WeaponEnt) then
		angpos = self.WeaponEnt:GetAttachment(self.Attachment)
	end

	if not angpos or not angpos.Pos then
		angpos = {
			Pos = bvec,
			Ang = uAng
		}
	end

	if self.Flipped then
		local tmpang = (self.Dir or angpos.Ang:Forward()):Angle()
		local localang = self.WeaponEnt:WorldToLocalAngles(tmpang)
		localang.y = localang.y + 180
		localang = self.WeaponEnt:LocalToWorldAngles(localang)
		--localang:RotateAroundAxis(localang:Up(),180)
		--tmpang:RotateAroundAxis(tmpang:Up(),180)
		self.Dir = localang:Forward()
	end

	-- Keep the start and end Pos - we're going to interpolate between them
	if IsValid(owent) and self.Position:Distance(owent:GetShootPos()) > 72 then
		self.WeaponEnt = nil
	end

	self.StartPos = self:GetTracerShootPos(self.WeaponEnt and angpos.Pos or self.Position, self.WeaponEnt, self.Attachment)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	self.Normal = (self.EndPos - self.StartPos):GetNormalized()
	self.StartTime = 0
	self.LifeTime = self.Life
	self.data = data
	self.rot = nil
	weapon = data:GetEntity()

	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()

	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 8, 8, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 10, 0, 1, color_white)
end
--lua/effects/effect_sw_laser_white/init.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002;
SOUND_FROM_WORLD			= 0;
CHAN_STATIC					= 6;

EFFECT.Speed				= 6500;
EFFECT.Length				= 64;
--EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 72;

local MaterialMain			= Material( "effects/sw_laser_white_main" );
local MaterialFront			= Material( "effects/sw_laser_white_front" );
local DynamicTracer 		= GetConVar("cl_dynamic_tracer")

function EFFECT:GetTracerOrigin(data)
	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart()

	-- use attachment?
	if (bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT) then
		local entity = data:GetEntity()
		if (not IsValid(entity)) then return start end
		if (not game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT)) then return start end

		if (entity:IsWeapon() and entity:IsCarriedByLocalPlayer()) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			-- use the view model
			local pl = entity:GetOwner()

			if (IsValid(pl)) then
				local vm = pl:GetViewModel()

				if (IsValid(vm) and not LocalPlayer():ShouldDrawLocalPlayer()) then
					entity = vm
					-- HACK: fix the model in multiplayer
				else
					if (entity.WorldModel) then
						entity:SetModel(entity.WorldModel)
					end
				end
			end
		end

		local attachment = entity:GetAttachment(data:GetAttachment())

		if (attachment) then
			start = attachment.Pos
		end
	end

	return start
end

function EFFECT:Init(data)
	self.StartPos = self:GetTracerOrigin(data)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	local diff = (self.EndPos - self.StartPos)
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = (diff:Length() + self.Length) / self.Speed
	-- whiz by sound
	local weapon = data:GetEntity()

	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()

	if DynamicTracer:GetBool() then
		local spawn = util.CRC(tostring(self:GetPos()))
		local dlight = DynamicLight(self:EntIndex() + spawn)
		local endDistance = self.Speed * self.StartTime
		local endPos = self.StartPos + self.Normal * endDistance

		if (dlight) then
			dlight.pos = endPos
			dlight.r = 255
			dlight.g = 255
			dlight.b = 255
			dlight.brightness = 3
			dlight.Decay = 1000
			dlight.Size = 300
			dlight.DieTime = CurTime() + 3
		end
	end

	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 8, 8, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 10, 0, 1, color_white)
end
--addons/lvs_base/lua/effects/lvs_bullet_impact.lua:

EFFECT.SmokeMat = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

EFFECT.DustMat = {
	"effects/lvs_base/particle_debris_01",
	"effects/lvs_base/particle_debris_02",
}

function EFFECT:Init( data )
	local pos = data:GetOrigin()
	local dir = data:GetNormal()
	local scale = data:GetMagnitude()

	sound.Play( "physics/flesh/flesh_strider_impact_bullet"..math.random(1,3)..".wav", pos, 85, math.random(180,200) + 55 * math.max(1 - scale,0), 0.75 )
	sound.Play( "ambient/materials/rock"..math.random(1,5)..".wav", pos, 75, 180, 1 )

	local emitter = ParticleEmitter( pos, false )

	local VecCol = (render.GetLightColor( pos + dir ) * 0.5 + Vector(0.2,0.18,0.15)) * 255

	local DieTime = math.Rand(0.8,1.6)

	if dir.z > 0.85 then
		for i = 1, 10 do
			for n = 0,6 do
				local particle = emitter:Add( self.DustMat[ math.random(1,#self.DustMat) ] , pos )

				if not particle then continue end

				particle:SetVelocity( (dir * 50 * i + VectorRand() * 25) * scale )
				particle:SetDieTime( (i / 8) * DieTime )
				particle:SetAirResistance( 10 ) 
				particle:SetStartAlpha( 255 )
				particle:SetStartSize( 10 * scale )
				particle:SetEndSize( 20 * i * scale )
				particle:SetRollDelta( math.Rand(-1,1) )
				particle:SetColor( math.min( VecCol.r, 255 ), math.min( VecCol.g, 255 ), math.min( VecCol.b, 255 ) )
				particle:SetGravity( Vector(0,0,-600) * scale )
				particle:SetCollide( false )
			end
		end

		for i = 1, 10 do
			local particle = emitter:Add( self.SmokeMat[ math.random(1,#self.SmokeMat) ] , pos )

			if not particle then continue end

			particle:SetVelocity( (dir * 50 * i + VectorRand() * 40) * scale )
			particle:SetDieTime( (i / 8) * DieTime )
			particle:SetAirResistance( 10 ) 
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 10 * scale )
			particle:SetEndSize( 20 * i * scale )
			particle:SetRollDelta( math.Rand(-1,1) )
			particle:SetColor( math.min( VecCol.r, 255 ), math.min( VecCol.g, 255 ), math.min( VecCol.b, 255 ) )
			particle:SetGravity( Vector(0,0,-600) * scale )
			particle:SetCollide( false )
		end
	end

	for i = 1,12 do
		local particle = emitter:Add( self.SmokeMat[ math.random(1,#self.SmokeMat) ] , pos )
		
		if particle then
			local ang = i * 30
			local X = math.cos( math.rad(ang) )
			local Y = math.sin( math.rad(ang) )

			local Vel = Vector(X,Y,0) * math.Rand(200,1600) + Vector(0,0,50)
			Vel:Rotate( dir:Angle() + Angle(90,0,0) )

			particle:SetVelocity( Vel * scale )
			particle:SetDieTime( DieTime )
			particle:SetAirResistance( 500 ) 
			particle:SetStartAlpha( 100 )
			particle:SetStartSize( 40 * scale )
			particle:SetEndSize( 200 * scale )
			particle:SetRollDelta( math.Rand(-1,1) )
			particle:SetColor( math.min( VecCol.r, 255 ), math.min( VecCol.g, 255 ), math.min( VecCol.b, 255 ) )
			particle:SetGravity( Vector(0,0,60) * scale )
			particle:SetCollide( true )
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--addons/lvs_base/lua/effects/lvs_bullet_impact_ap.lua:

EFFECT.DustMat = {
	"effects/lvs_base/particle_debris_01",
	"effects/lvs_base/particle_debris_02",
}

EFFECT.SmokeMat = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

EFFECT.SparkSurface = {
	["chainlink"] = true,
	["canister"] = true,
	["metal_barrel"] = true,
	["metalvehicle"] = true,
	["metal"] = true,
	["metalgrate"] = true,
	["rubbertire"] = true,
}

EFFECT.DustSurface = {
	["sand"] = true,
	["dirt"] = true,
	["grass"] = true,
	["antlionsand"] = true,
}

EFFECT.SmokeSurface = {
	["concrete"] = true,
	["tile"] = true,
	["plaster"] = true,
	["boulder"] = true,
	["plastic"] = true,
	["default"] = true,
	["glass"] = true,
	["brick"] = true,
}

function EFFECT:Init( data )
	local pos = data:GetOrigin()

	local bullet_dir = data:GetStart()
	local dir = data:GetNormal()
	local magnitude = data:GetMagnitude()

	local ent = data:GetEntity()
	local surface = data:GetSurfaceProp()
	local surfaceName = util.GetSurfacePropName( surface )

	local emitter = ParticleEmitter( pos, false )

	local VecCol = (render.GetLightColor( pos ) * 0.8 + Vector(0.17,0.15,0.1)) * 255

	local DieTime = math.Rand(0.8,1.4)

	for i = 1, 60 * magnitude do
		local spark = emitter:Add("effects/spark", pos + dir * 8)

		if not spark then continue end

		spark:SetStartAlpha( 255 )
		spark:SetEndAlpha( 0 )
		spark:SetCollide( true )
		spark:SetBounce( math.Rand(0,1) )
		spark:SetColor( 255, 255, 255 )
		spark:SetGravity( Vector(0,0,-600) )
		spark:SetEndLength(0)

		local size = math.Rand(4, 6) * magnitude
		spark:SetEndSize( size )
		spark:SetStartSize( size )

		spark:SetStartLength( math.Rand(20,40) * magnitude )
		spark:SetDieTime( math.Rand(0.4, 1.2) )
		spark:SetVelocity( (dir * math.Rand(300, 600) + VectorRand() * 300) * magnitude )
	end

	local flash = emitter:Add( "effects/yellowflare",pos )

	if flash then
		flash:SetPos( pos + dir * 15 )
		flash:SetStartAlpha( 200 )
		flash:SetEndAlpha( 0 )
		flash:SetColor( 255,255,255 )
		flash:SetEndSize( 0 )
		flash:SetDieTime( 0.075 )
		flash:SetStartSize( 300 * magnitude ^ 2 )
	end

	if self.SparkSurface[ surfaceName ] then
		if IsValid( ent ) and ent.LVS then
			if (90 - math.deg( math.acos( math.Clamp( -dir:Dot( bullet_dir ) ,-1,1) ) )) > 10 then
				local effectdata = EffectData()
				effectdata:SetOrigin( pos )
				util.Effect( "cball_explode", effectdata, true, true )

				local Ax = math.acos( math.Clamp( dir:Dot( bullet_dir ) ,-1,1) )
				local Fx = math.cos( Ax )

				local effectdata = EffectData()
					effectdata:SetOrigin( pos )
					effectdata:SetNormal( (bullet_dir - dir * Fx * 2):GetNormalized() * 0.75 )
				util.Effect( "manhacksparks", effectdata, true, true )

				local effectdata = EffectData()
					effectdata:SetOrigin( pos )
					effectdata:SetNormal( -bullet_dir * 0.75 )
				util.Effect( "manhacksparks", effectdata, true, true )
			end
		else
			local effectdata = EffectData()
			effectdata:SetOrigin( pos )
			util.Effect( "cball_explode", effectdata, true, true )

			local effectdata = EffectData()
				effectdata:SetOrigin( pos )
				effectdata:SetNormal( dir )
			util.Effect( "manhacksparks", effectdata, true, true )

			local effectdata = EffectData()
				effectdata:SetOrigin( pos )
				effectdata:SetNormal( -bullet_dir )
			util.Effect( "manhacksparks", effectdata, true, true )
		end
	end

	if self.SmokeSurface[ surfaceName ] then
		for i = 1, 24 do
			local particle = emitter:Add( self.SmokeMat[ math.random(1, #self.SmokeMat ) ], pos )

			if not particle then continue end

			particle:SetStartAlpha( math.Rand(33, 66) )
			particle:SetEndAlpha( 0 )
			particle:SetColor( math.min( VecCol.r, 255 ), math.min( VecCol.g, 255 ), math.min( VecCol.b, 255 ) )
			particle:SetGravity( Vector(0,0,-math.Rand(33, 66)) )
			particle:SetRollDelta( math.random(0, 0.5 * math.pi) )
			particle:SetAirResistance( 175 )

			particle:SetStartSize( 15 )
			particle:SetDieTime( math.Rand(0.5, 1) )
			particle:SetEndSize( math.Rand(45, 90) )
			particle:SetVelocity( dir * math.Rand(40, 200) + VectorRand() * 150)
		end

		for i = 1,15 do
			local particle = emitter:Add("effects/fleck_cement" .. math.random(1, 2), pos + dir * 8)

			if not particle then continue end

			particle:SetStartAlpha( 255 )
			particle:SetEndAlpha( 0 )
			particle:SetCollide( true )
			particle:SetBounce( math.Rand(0,1) )
			particle:SetColor( math.min( VecCol.r, 255 ), math.min( VecCol.g, 255 ), math.min( VecCol.b, 255 ) )
			particle:SetGravity(Vector(0,0,-600))
			particle:SetRollDelta( math.random(0, 0.5*math.pi) )

			particle:SetEndSize( 2 )
			particle:SetStartSize( 2 )

			particle:SetDieTime( math.Rand(1, 2) )
			particle:SetVelocity( dir * math.Rand(40, 200) + VectorRand() * 500 )
		end
	end

	if not self.DustSurface[ surfaceName ] then return end

	for i = 1, 10 do
		for i = 1, 15 do
			local particle = emitter:Add( self.SmokeMat[ math.random(1, #self.SmokeMat ) ], pos )

			if not particle then continue end

			particle:SetStartAlpha( math.Rand(40, 80) )
			particle:SetEndAlpha(0)
			particle:SetColor( math.min( VecCol.r, 255 ), math.min( VecCol.g, 255 ), math.min( VecCol.b, 255 ) )
			particle:SetGravity( Vector(0,0,-math.Rand(75, 150)) )
			particle:SetRollDelta( math.random(0, 0.5*math.pi) )
			particle:SetAirResistance( 175 )

			particle:SetStartSize( 5 )
			particle:SetDieTime( math.Rand(0.5, 1) )
			particle:SetEndSize( math.Rand(15, 30) )
			particle:SetVelocity( (dir * math.Rand(80, 400) + VectorRand() * 100) * 1.5 )
		end
    
		for n = 0,6 do
			local particle = emitter:Add( self.DustMat[ math.random(1,#self.DustMat) ] , pos )

			if not particle then continue end

			particle:SetVelocity( (dir * 50 * i + VectorRand() * 50) )
			particle:SetDieTime( (i / 8) * DieTime )
			particle:SetAirResistance( 10 ) 
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 5 )
			particle:SetEndSize( 10 * i )
			particle:SetRollDelta( math.Rand(-1,1) )
			particle:SetColor( math.min( VecCol.r, 255 ), math.min( VecCol.g, 255 ), math.min( VecCol.b, 255 ) )
			particle:SetGravity( Vector(0,0,-600) )
			particle:SetCollide( false )
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--addons/lvs_starwars/lua/effects/lvs_concussion_trail.lua:
EFFECT.Offset = Vector(-8,0,0)

local GlowMat = Material( "effects/select_ring" )
local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	self.Entity = data:GetEntity()

	if IsValid( self.Entity ) then
		self.OldPos = self.Entity:LocalToWorld( self.Offset )

		self.Emitter = ParticleEmitter( self.Entity:LocalToWorld( self.OldPos ), false )
	end
end

function EFFECT:doFX( pos )
	if not IsValid( self.Entity ) then return end

	if IsValid( self.Emitter ) then
		local emitter = self.Emitter

		local particle = emitter:Add( Materials[ math.random(1, #Materials ) ], pos )
		if particle then
			particle:SetGravity( Vector(0,0,100) + VectorRand() * 50 ) 
			particle:SetVelocity( -self.Entity:GetForward() * 200  )
			particle:SetAirResistance( 600 ) 
			particle:SetDieTime( math.Rand(2,3) )
			particle:SetStartAlpha( 100 )
			particle:SetStartSize( math.Rand(5,6) )
			particle:SetEndSize( math.Rand(12,30) )
			particle:SetRoll( math.Rand( -1, 1 ) )
			particle:SetColor( 50,50,50 )
			particle:SetCollide( false )
		end

		local particle = emitter:Add( "effects/lvs_base/flamelet"..math.random(1,5), pos )
		if particle then
			particle:SetVelocity( -self.Entity:GetForward() * math.Rand(250,800) + self.Entity:GetVelocity())
			particle:SetDieTime( math.Rand(0.2,0.4) )
			particle:SetAirResistance( 0 ) 
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( math.Rand(10,15) )
			particle:SetEndSize( 5 )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( 150,50,100 )
			particle:SetGravity( Vector( 0, 0, 0 ) )
			particle:SetCollide( false )
		end
		
		local particle = emitter:Add( "effects/lvs_base/flamelet"..math.random(1,5), self.Entity:GetPos() )
		if particle then
			particle:SetVelocity( -self.Entity:GetForward() * 200 + VectorRand() * 50 )
			particle:SetDieTime( 0.25 )
			particle:SetAirResistance( 600 ) 
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( math.Rand(6,10) )
			particle:SetEndSize( math.Rand(2,3) )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( 255,100,200 )
			particle:SetGravity( Vector( 0, 0, 0 ) )
			particle:SetCollide( false )
		end
	end
end

function EFFECT:Think()
	if IsValid( self.Entity ) then
		self.nextDFX = self.nextDFX or 0
		
		if self.nextDFX < CurTime() then
			self.nextDFX = CurTime() + 0.02

			local oldpos = self.OldPos
			local newpos = self.Entity:LocalToWorld( self.Offset )
			self:SetPos( newpos )

			local Sub = (newpos - oldpos)
			local Dir = Sub:GetNormalized()
			local Len = Sub:Length()

			self.OldPos = newpos

			for i = 0, Len, 45 do
				local pos = oldpos + Dir * i

				self:doFX( pos )
			end
		end

		return true
	end

	if IsValid( self.Emitter ) then
		self.Emitter:Finish()
	end

	return false
end

function EFFECT:Render()
	local ent = self.Entity
	local pos = ent:LocalToWorld( self.Offset )

	render.SetMaterial( GlowMat )

	render.DrawSprite( pos, 100, 100, Color( 255, 40, 100, 50 ) )
end

--addons/lvs_base/lua/effects/lvs_explosion.lua:
local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

EFFECT.DecalMat = Material( util.DecalMaterial( "Scorch" ) )

function EFFECT:Init( data )
	local Pos = data:GetOrigin()

	self.DieTime = CurTime() + 1

	self:Explosion( Pos, 2 )

	local ply = LocalPlayer():GetViewEntity()
	if IsValid( ply ) then
		local delay = (Pos - ply:GetPos()):Length() / 13503.9
		timer.Simple( delay, function()
			sound.Play( "LVS.DYNAMIC_EXPLOSION", Pos )
		end )
	else
		sound.Play( "LVS.DYNAMIC_EXPLOSION", Pos )
	end
	
	for i = 1, 20 do
		timer.Simple(math.Rand(0,0.01) * i, function()
			if IsValid( self ) then
				local p = Pos + VectorRand() * 10 * i
				
				self:Explosion( p, math.Rand(0.5,0.8) )
			end
		end)
	end

	self:Debris( Pos )

	local traceSky = util.TraceLine( {
		start = Pos,
		endpos = Pos + Vector(0,0,50000),
		mask = MASK_SOLID_BRUSHONLY,
	} )

	local traceWater = util.TraceLine( {
		start = traceSky.HitPos,
		endpos = Pos - Vector(0,0,100),
		mask = MASK_WATER,
	} )

	if traceWater.Hit then
		local effectdata = EffectData()
		effectdata:SetOrigin( traceWater.HitPos )
		effectdata:SetScale( 100 )
		effectdata:SetFlags( 2 )
		util.Effect( "WaterSplash", effectdata, true, true )
	else
		local trace = util.TraceLine( {
			start = Pos + Vector(0,0,100),
			endpos = Pos - Vector(0,0,100),
			mask = MASK_SOLID_BRUSHONLY,
		} )

		if trace.Hit and not trace.HitNonWorld then
			for i = 1, 10 do
				local StartPos = trace.HitPos + Vector(math.random(-25,25) * i,math.random(-25,25) * i,0)
				local decalTrace = util.TraceLine( {
					start = StartPos + Vector(0,0,100),
					endpos = StartPos - Vector(0,0,100),
					mask = MASK_SOLID_BRUSHONLY,
				} )

				util.DecalEx( self.DecalMat, trace.Entity, decalTrace.HitPos + decalTrace.HitNormal, decalTrace.HitNormal, Color(255,255,255,255), math.Rand(2,3), math.Rand(2,3) )
			end
		end
	end
end

function EFFECT:Debris( pos )
	local emitter = ParticleEmitter( pos, false )

	if not IsValid( emitter ) then return end

	for i = 0,60 do
		local particle = emitter:Add( "effects/fleck_tile"..math.random(1,2), pos )
		local vel = VectorRand() * math.Rand(200,600)
		vel.z = math.Rand(200,600)
		if particle then
			particle:SetVelocity( vel )
			particle:SetDieTime( math.Rand(10,15) )
			particle:SetAirResistance( 10 ) 
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 5 )
			particle:SetEndSize( 5 )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( 0,0,0 )
			particle:SetGravity( Vector( 0, 0, -600 ) )
			particle:SetCollide( true )
			particle:SetBounce( 0.3 )
		end
	end
	
	emitter:Finish()
end

function EFFECT:Explosion( pos , scale )
	local emitter = ParticleEmitter( pos, false )
	
	if not IsValid( emitter ) then return end

	for i = 0,10 do
		local particle = emitter:Add( Materials[ math.random(1, #Materials ) ], pos )

		if particle then
			particle:SetVelocity( VectorRand() * 1500 * scale )
			particle:SetDieTime( math.Rand(0.75,1.5) * scale )
			particle:SetAirResistance( math.Rand(200,600) ) 
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( math.Rand(60,120) * scale )
			particle:SetEndSize( math.Rand(220,320) * scale )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( 40,40,40 )
			particle:SetGravity( Vector( 0, 0, 100 ) )
			particle:SetCollide( false )
		end
	end

	for i = 0, 40 do
		local particle = emitter:Add( "effects/lvs_base/flamelet"..math.random(1,5), pos )

		if particle then
			particle:SetVelocity( VectorRand() * 1500 * scale )
			particle:SetDieTime( 0.2 )
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 20 * scale )
			particle:SetEndSize( math.Rand(180,240) * scale )
			particle:SetEndAlpha( 100 )
			particle:SetRoll( math.Rand( -1, 1 ) )
			particle:SetColor( 200,150,150 )
			particle:SetCollide( false )
		end
	end

	emitter:Finish()

	local dlight = DynamicLight( math.random(0,9999) )
	if dlight then
		dlight.pos = pos
		dlight.r = 255
		dlight.g = 180
		dlight.b = 100
		dlight.brightness = 8
		dlight.Decay = 2000
		dlight.Size = 300
		dlight.DieTime = CurTime() + 1
	end
end

function EFFECT:Think()
	if CurTime() < self.DieTime then return true end

	return false
end

function EFFECT:Render()
end

--addons/lvs_starwars/lua/effects/lvs_hover_water.lua:

function EFFECT:Init( data )
	local Pos = data:GetOrigin()
	local Ent = data:GetEntity()
	self.Size = data:GetMagnitude()

	if not IsValid( Ent ) then return end

	self.LifeTime = math.Rand(1.5,3)
	self.DieTime = CurTime() + self.LifeTime

	self.Splash = {
		Pos = Pos,
		Mat = Material("effects/splashwake1"),
		RandomAng = math.random(0,360),
	}

	local emitter = Ent:GetParticleEmitter( Ent:GetPos() )

	if emitter and emitter.Add then
		local particle = emitter:Add( "effects/splash4", Pos )
		if not particle then return end

		local Vel = Ent:GetVelocity():Length()

		particle:SetVelocity( Vector(0,0,math.Clamp(Vel / 2,100,250)) )
		particle:SetDieTime( 0.25 + math.min(Vel / 200,0.35) )
		particle:SetAirResistance( 60 ) 
		particle:SetStartAlpha( 255 )
		particle:SetEndAlpha( 0 )
		particle:SetStartSize( self.Size * 0.2 )
		particle:SetEndSize(  self.Size * 2 )
		particle:SetRoll( math.Rand(-1,1) * 100 )
		particle:SetColor( 255,255,255 )
		particle:SetGravity( Vector( 0, 0, -600 ) )
		particle:SetCollide( false )
	end
end


function EFFECT:Think()
	if CurTime() > self.DieTime then
		return false
	end
	return true
end

function EFFECT:Render()
	if self.Splash and self.LifeTime then
		local Scale = ((self.DieTime - self.LifeTime - CurTime()) / self.LifeTime)
		local S =  self.Size * 5 + (self.Size * 5) * Scale
		local Alpha = 100 + 100 * Scale

		cam.Start3D2D( self.Splash.Pos + Vector(0,0,1), Angle(0,0,0), 1 )
			surface.SetMaterial( self.Splash.Mat )
			surface.SetDrawColor( 255, 255, 255 , Alpha )
			surface.DrawTexturedRectRotated( 0, 0, S , S, self.Splash.RandomAng )
		cam.End3D2D()
	end
end
--addons/lvs_starwars/lua/effects/lvs_laser_explosion_aat.lua:


EFFECT.HeatWaveMat = Material( "particle/warp1_warp" )
EFFECT.GlowMat = Material( "sprites/light_glow02_add" )

function EFFECT:Init( data )
	local Pos = data:GetOrigin()
	self.Pos = Pos

	self.LifeTime = 0.4
	self.DieTime = CurTime() + self.LifeTime
	self.DieTimeGlow = CurTime() + 0.2

	sound.Play( "LVS.AAT.LASER_EXPLOSION", Pos )
	self:Explosion( Pos )
end

function EFFECT:Explosion( pos )
	local emitter = ParticleEmitter( pos, false )
	
	if not emitter then return end

	for i = 0, 15 do
		local particle = emitter:Add( "sprites/light_glow02_add", pos )
		
		local vel = VectorRand() * 450
		
		if not particle then continue end

		particle:SetVelocity( vel )
		particle:SetAngles( vel:Angle() + Angle(0,90,0) )
		particle:SetDieTime( math.Rand(1,1.6) )
		particle:SetStartAlpha( 255 )
		particle:SetEndAlpha( 0 )
		particle:SetStartSize( math.Rand(12,15) )
		particle:SetEndSize( 0 )
		particle:SetRoll( math.Rand(-100,100) )
		particle:SetRollDelta( math.Rand(-100,100) )
		particle:SetColor( 255,0,0 )
		particle:SetGravity( Vector(0,0,-600) )

		particle:SetAirResistance( 0 )
		
		particle:SetCollide( true )
		particle:SetBounce( 0.5 )
	end

	for i = 0, 5 do
		local particle = emitter:Add( "sprites/rico1", pos )
		
		local vel = VectorRand() * 1000
		
		if not particle then continue end

		particle:SetVelocity( vel )
		particle:SetAngles( vel:Angle() + Angle(0,90,0) )
		particle:SetDieTime( math.Rand(0.5,0.8) )
		particle:SetStartAlpha( math.Rand( 200, 255 ) )
		particle:SetEndAlpha( 0 )
		particle:SetStartSize( math.Rand(10,20) )
		particle:SetEndSize( 0 )
		particle:SetRoll( math.Rand(-100,100) )
		particle:SetRollDelta( math.Rand(-100,100) )
		particle:SetColor( 255, 0, 0 )
		particle:SetGravity( -vel:GetNormalized() * math.random(1250,1750) )
		particle:SetCollide( true )
		particle:SetBounce( 0.5 )

		particle:SetAirResistance( 200 )
	end

	for i = 0, 20 do
		local particle = emitter:Add( "effects/lvs_base/flamelet"..math.random(1,5), pos )
		
		if not particle then continue end

		particle:SetVelocity( VectorRand(-1,1) * 500 )
		particle:SetDieTime( 0.14 )
		particle:SetStartAlpha( 255 )
		particle:SetStartSize( 10 )
		particle:SetEndSize( math.Rand(30,60) )
		particle:SetEndAlpha( 100 )
		particle:SetRoll( math.Rand( -1, 1 ) )
		particle:SetColor( 200,150,150 )
		particle:SetCollide( false )
	end

	emitter:Finish()
end

function EFFECT:Think()
	if self.DieTime < CurTime() then return false end

	return true
end

function EFFECT:Render()
	local Scale = math.max((self.DieTime - self.LifeTime + 0.3 - CurTime()) / 0.3,0)
	render.SetMaterial( self.HeatWaveMat )
	render.DrawSprite( self.Pos, 300 * Scale, 300 * Scale, Color( 255, 255, 255, 255) )

	render.SetMaterial( self.GlowMat )
	render.DrawSprite( self.Pos, 1000 * Scale, 1000 * Scale, Color( 255, 100, 50, 255) )

	local Scale = (self.DieTimeGlow - CurTime()) / 0.2
	if Scale > 0 then
		render.SetMaterial( self.GlowMat )
		render.DrawSprite( self.Pos, 100 * Scale, 100 * Scale, Color( 250, 0, 0, 255) )
		render.DrawSprite( self.Pos, 25 * Scale, 25 * Scale, Color( 255, 255, 255, 255) )
	end

	local Scale = (self.DieTime - self.LifeTime + 0.25 - CurTime()) / 0.25
	local InvScale = 1 - Scale
	if Scale > 0 then
		render.SetColorMaterial()
		render.DrawSphere( self.Pos, -180 * InvScale, 30,30, Color( 255, 0, 0, 255 * (Scale ^ 2) ) )
		render.DrawSphere( self.Pos, -190 * InvScale, 30,30, Color( 255, 0, 0, 150 * (Scale ^ 2) ) )
		render.DrawSphere( self.Pos, -200 * InvScale, 30,30, Color( 255, 0, 0, 50 * (Scale ^ 2) ) )
		render.DrawSphere( self.Pos, 210 * InvScale, 30,30, Color( 255, 0, 0, 50 * (Scale ^ 2) ) )
	end
end

--addons/lvs_starwars/lua/effects/lvs_laser_red_short.lua:

EFFECT.MatBeam = Material( "effects/spark" )
EFFECT.MatSprite = Material( "sprites/light_glow02_add" )

function EFFECT:Init( data )
	local pos  = data:GetOrigin()
	local dir = data:GetNormal()

	self.ID = data:GetMaterialIndex()

	self:SetRenderBoundsWS( pos, pos + dir * 50000 )
end

function EFFECT:Think()
	if not LVS:GetBullet( self.ID ) then return false end

	return true
end

function EFFECT:Render()
	local bullet = LVS:GetBullet( self.ID )

	local endpos = bullet:GetPos()
	local dir = bullet:GetDir()

	local len = 300 * bullet:GetLength()

	render.SetMaterial( self.MatSprite ) 
	render.DrawBeam( endpos - dir * len * 2, endpos + dir * len * 2, 200, 1, 0, Color( 255, 0, 0, 255 ) )

	render.SetMaterial( self.MatBeam )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 45, 1, 0, Color( 255, 0, 0, 255 ) )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 15, 1, 0, Color( 255, 255, 255, 255 ) )
end

--addons/lvs_base/lua/effects/lvs_muzzle.lua:

function EFFECT:Init( data )
	local Pos = data:GetOrigin()
	local Dir = data:GetNormal()
	local Ent = data:GetEntity()
	local Vel = Dir * 10

	if IsValid( Ent ) then
		Vel = Ent:GetVelocity()
	end

	local emitter = ParticleEmitter( Pos, false )

	if not IsValid( emitter ) then return end

	for i = 0, 12 do
		local particle = emitter:Add( "effects/muzzleflash2", Pos + Dir * i * 0.7 * math.random(1,2) * 0.5 )
		local Size = 1

		if not particle then continue end

		particle:SetVelocity( Dir * 800 + Vel )
		particle:SetDieTime( 0.05 )
		particle:SetStartAlpha( 255 * Size )
		particle:SetStartSize( math.max( math.random(10,24) - i * 0.5,0.1 ) * Size )
		particle:SetEndSize( 0 )
		particle:SetRoll( math.Rand( -1, 1 ) )
		particle:SetColor( 255, 255, 255 )
		particle:SetCollide( false )
	end

	emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--addons/lvs_base/lua/effects/lvs_shield_impact.lua:

local LastImpact = 0

function EFFECT:Init( data )
	self.Ent = data:GetEntity()
	self.Pos = data:GetOrigin()

	self.mat = Material( "sprites/light_glow02_add" )

	local T = CurTime()

	self.LifeTime = 0.2
	self.DieTime = T + self.LifeTime

	local DontHurtEars = math.Clamp( T - LastImpact, 0.4, 1 ) ^ 2

	LastImpact = T

	sound.Play( "lvs/shield_deflect.ogg", self.Pos, 120, 100, DontHurtEars )

	self:Spark( self.Pos )

	if IsValid( self.Ent ) then
		self.Model = ClientsideModel( self.Ent:GetModel(), RENDERMODE_TRANSCOLOR )
		self.Model:SetMaterial("models/alyx/emptool_glow")
		self.Model:SetColor( Color(200,220,255,255) )
		self.Model:SetParent( self.Ent, 0 )
		self.Model:SetMoveType( MOVETYPE_NONE )
		self.Model:SetLocalPos( Vector( 0, 0, 0 ) )
		self.Model:SetLocalAngles( Angle( 0, 0, 0 ) )
		self.Model:AddEffects( EF_BONEMERGE )
	end
end

function EFFECT:Spark( pos )
	local emitter = ParticleEmitter( pos, false )

	for i = 0, 20 do
		local particle = emitter:Add( "sprites/rico1", pos )

		local vel = VectorRand() * 500

		if not particle then continue end

		particle:SetVelocity( vel )
		particle:SetAngles( vel:Angle() + Angle(0,90,0) )
		particle:SetDieTime( math.Rand(0.2,0.4) )
		particle:SetStartAlpha( math.Rand( 200, 255 ) )
		particle:SetEndAlpha( 0 )
		particle:SetStartSize( math.Rand(10,20) )
		particle:SetEndSize( 0 )
		particle:SetRoll( math.Rand(-100,100) )
		particle:SetRollDelta( math.Rand(-100,100) )
		particle:SetColor( 0, 127, 255 )

		particle:SetAirResistance( 0 )
	end

	emitter:Finish()
end

function EFFECT:Think()
	if not IsValid( self.Ent ) then
		if IsValid( self.Model ) then
			self.Model:Remove()
		end
	end

	if self.DieTime < CurTime() then 
		if IsValid( self.Model ) then
			self.Model:Remove()
		end

		return false
	end
	
	return true
end

function EFFECT:Render()
	local Scale = (self.DieTime - CurTime()) / self.LifeTime
	render.SetMaterial( self.mat )
	render.DrawSprite( self.Pos, 800 * Scale, 800 * Scale, Color( 0, 127, 255, 255) )
	render.DrawSprite( self.Pos, 200 * Scale, 200 * Scale, Color( 255, 255, 255, 255) )
end

--addons/lvs_base/lua/effects/lvs_tracer_green.lua:

EFFECT.MatBeam = Material( "effects/lvs_base/spark" )

function EFFECT:Init( data )
	local pos  = data:GetOrigin()
	local dir = data:GetNormal()

	self.ID = data:GetMaterialIndex()

	self:SetRenderBoundsWS( pos, pos + dir * 50000 )
end

function EFFECT:Think()
	if not LVS:GetBullet( self.ID ) then return false end

	return true
end

function EFFECT:Render()
	local bullet = LVS:GetBullet( self.ID )

	local endpos = bullet:GetPos()
	local dir = bullet:GetDir()

	local len = 1600 * bullet:GetLength()

	render.SetMaterial( self.MatBeam )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 3, 1, 0, Color( 225, 255, 225, 255 ) )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 10, 1, 0, Color( 150, 200, 150, 255 ) )
end

--addons/vfire_extinguisher/lua/effects/rb655_extinguisher_effect.lua:

function EFFECT:Init( data )

	self.Player = data:GetEntity()
	self.Origin = data:GetOrigin()
	self.Attachment = data:GetAttachment()
	self.Forward = data:GetNormal()
	self.Scale = data:GetScale()

	if ( !IsValid( self.Player ) || !IsValid( self.Player:GetActiveWeapon() ) ) then return end

	self.Angle = self.Forward:Angle()
	self.Position = self:GetTracerShootPos( self.Origin, self.Player:GetActiveWeapon(), self.Attachment )

	if ( self.Position == self.Origin ) then
		local att = self.Player:GetAttachment( self.Player:LookupAttachment( "anim_attachment_RH" ) )
		if ( att ) then self.Position = att.Pos + att.Ang:Forward() * -2 end
	end

	local teh_effect = ParticleEmitter( self.Player:GetPos(), true )
	if ( !teh_effect ) then return end

	for i = 1, 12 * self.Scale do
		local particle = teh_effect:Add( "effects/splash4", self.Position )
		if ( particle ) then
			local Spread = 0.3
			particle:SetVelocity( ( Vector( math.sin( math.Rand( 0, 360 ) ) * math.Rand( -Spread, Spread ), math.cos( math.Rand( 0, 360 ) ) * math.Rand( -Spread, Spread ), math.sin( math.random() ) * math.Rand( -Spread, Spread ) ) + self.Forward ) * 750 )

			local ang = self.Angle
			if ( i / 2 == math.floor( i / 2 ) ) then ang = ( self.Forward * -1 ):Angle() end
			particle:SetAngles( ang )
			particle:SetDieTime( 0.25 )
			particle:SetColor( 255, 255, 255 )
			particle:SetStartAlpha( 255 )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( 8 )
			particle:SetEndSize( 0 )
			particle:SetCollide( 1 )
			particle:SetCollideCallback( function( particleC, HitPos, normal )
				particleC:SetAngleVelocity( Angle( 0, 0, 0 ) )
				particleC:SetVelocity( Vector( 0, 0, 0 ) )
				particleC:SetPos( HitPos + normal * 0.1 )
				particleC:SetGravity( Vector( 0, 0, 0 ) )

				local angles = normal:Angle()
				angles:RotateAroundAxis( normal, particleC:GetAngles().y )
				particleC:SetAngles( angles )

				particleC:SetLifeTime( 0 )
				particleC:SetDieTime( 10 )
				particleC:SetStartSize( 8 )
				particleC:SetEndSize( 0 )
				particleC:SetStartAlpha( 128 )
				particleC:SetEndAlpha( 0 )
			end )
		end
	end

	teh_effect:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--addons/wos-grandmaster-einf/lua/effects/rb655_force_absorb.lua:

function EFFECT:Init( data )
	local pos = data:GetOrigin()
	local emitter = ParticleEmitter( pos )

	if ( !emitter ) then return end

	local particle = emitter:Add( "hud/health_over_bg", pos + Vector( math.random( -16, 16 ), math.random( -16, 16 ), math.random( 0, 72 ) ) )
	if ( particle ) then
		particle:SetLifeTime( 0 )
		particle:SetDieTime( 2 )

		particle:SetGravity( Vector( 0, 0, 100 ) )
		particle:SetVelocity( Vector( 0, 0, 0 ) )

		particle:SetStartSize( math.random( 1, 5 ) )
		particle:SetEndSize( math.random( 0, 1 ) )

		particle:SetStartAlpha( math.random( 200, 255 ) )
		particle:SetEndAlpha( 0 )

		particle:SetColor( 255, 64, 64 )
		--particle:SetAngleVelocity( Angle( math.Rand( -180, 180 ), math.Rand( -180, 180 ), math.Rand( -180, 180 ) ) )
	end

	emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--addons/wos-grandmaster-einf/lua/effects/rb655_force_heal.lua:

function EFFECT:Init( data )
	local pos = data:GetOrigin()
	local emitter = ParticleEmitter( pos )

	if ( !emitter ) then return end

	local particle = emitter:Add( "effects/rb655_health_over_bg", pos + Vector( math.random( -16, 16 ), math.random( -16, 16 ), math.random( 0, 72 ) ) )
	if ( particle ) then
		particle:SetLifeTime( 0 )
		particle:SetDieTime( 2 )

		particle:SetGravity( Vector( 0, 0, 100 ) )
		particle:SetVelocity( Vector( 0, 0, 0 ) )

		particle:SetStartSize( math.random( 4, 6 ) )
		particle:SetEndSize( math.random( 0, 1 ) )

		particle:SetStartAlpha( math.random( 200, 255 ) )
		particle:SetEndAlpha( 0 )

		particle:SetColor( 255, 0, 0 )
		--particle:SetAngleVelocity( Angle( math.Rand( -180, 180 ), math.Rand( -180, 180 ), math.Rand( -180, 180 ) ) )
	end

	emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--lua/effects/rw_sw_dual_laser_orange.lua:
TRACER_FLAG_USEATTACHMENT 	= 0x0002
SOUND_FROM_WORLD			= 0
CHAN_STATIC 				= 6

EFFECT.Speed 				= 16384
EFFECT.Length 				= 95

local MaterialMain 			= Material("effects/sw_l/rw_sw_laser_m_orange")
local MaterialFront 		= Material("effects/sw_l/rw_sw_laser_f_orange")
local DynamicTracer 		= GetConVar("cl_dynamic_tracer")

function EFFECT:Init(data)
	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.WeaponEntOG = data:GetEntity()
	self.Attachment = data:GetAttachment()
	local owent
	if IsValid(self.WeaponEnt) then
		owent = self.WeaponEnt.Owner or self.WeaponEnt:GetOwner()
		if not IsValid(owent) then
			owent = self.WeaponEnt:GetParent()
		end
	end
	if IsValid(owent) and owent:IsPlayer() then
		if owent ~= LocalPlayer() or owent:ShouldDrawLocalPlayer() then
			self.WeaponEnt = owent:GetActiveWeapon()
			if not IsValid(self.WeaponEnt) then return end
		else
			self.WeaponEnt = owent:GetViewModel()
			local theirweapon = owent:GetActiveWeapon()
			if IsValid(theirweapon) and theirweapon.ViewModelFlip or theirweapon.ViewModelFlipped then
				self.Flipped = true
			end
			if not IsValid(self.WeaponEnt) then return end
		end
	end
	if IsValid(self.WeaponEntOG) and self.WeaponEntOG.MuzzleAttachment then
		self.Attachment = self.WeaponEnt:LookupAttachment(self.WeaponEntOG.MuzzleAttachment)
		if not self.Attachment or self.Attachment <= 0 then
			self.Attachment = 1
		end
		if self.WeaponEntOG.Akimbo then
			if game.SinglePlayer() then
				self.WeaponEntOG.AnimCycle = self.WeaponEntOG:GetNW2Int("AnimCycle") or 0
			end
			self.Attachment = 1 + self.WeaponEntOG.AnimCycle
		end
	end
	local angpos
	if IsValid(self.WeaponEnt) then
		angpos = self.WeaponEnt:GetAttachment(self.Attachment)
	end
	if not angpos or not angpos.Pos then
		angpos = {
			Pos = bvec,
			Ang = uAng
		}
	end
	if self.Flipped then
		local tmpang = (self.Dir or angpos.Ang:Forward()):Angle()
		local localang = self.WeaponEnt:WorldToLocalAngles(tmpang)
		localang.y = localang.y + 180
		localang = self.WeaponEnt:LocalToWorldAngles(localang)
		self.Dir = localang:Forward()
	end
	if IsValid(owent) and self.Position:Distance(owent:GetShootPos()) > 72 then
		self.WeaponEnt = nil
	end
	
	self.StartPos = self:GetTracerShootPos(self.WeaponEnt and angpos.Pos or self.Position, self.WeaponEnt, self.Attachment)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	self.Normal = (self.EndPos - self.StartPos):GetNormalized()
	self.StartTime = 0
	local diff = self.EndPos - self.StartPos
	self.LifeTime = (diff:Length() - self.Length/2 ) / self.Speed
	self.data = data
	self.rot = nil
	weapon = data:GetEntity()
	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	if DynamicTracer:GetBool() then
		local spawn = util.CRC(tostring(self:GetPos()))
		local dlight = DynamicLight(self:EntIndex() + spawn)
		local endDistance = self.Speed * self.StartTime
		local endPos = self.StartPos + self.Normal * endDistance
		if (dlight) then
			dlight.pos = endPos
			dlight.r = 255
			dlight.g = 90
			dlight.b = 0
			dlight.brightness = 3
			dlight.Decay = 1500
			dlight.Size = 300
			dlight.nomodel = 1
			dlight.style = 6
			dlight.DieTime = CurTime() + 3
		end
	end
	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 9, 9, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 7, 0, 0, color_white)
end
--lua/effects/rw_sw_dual_laser_red.lua:
TRACER_FLAG_USEATTACHMENT 	= 0x0002
SOUND_FROM_WORLD			= 0
CHAN_STATIC 				= 6

EFFECT.Speed 				= 16384
EFFECT.Length 				= 95

local MaterialMain 			= Material("effects/sw_laser_red_main")
local MaterialFront 		= Material("effects/sw_laser_red_front")
local DynamicTracer 		= GetConVar("cl_dynamic_tracer")

function EFFECT:Init(data)
	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.WeaponEntOG = data:GetEntity()
	self.Attachment = data:GetAttachment()
	local owent
	if IsValid(self.WeaponEnt) then
		owent = self.WeaponEnt.Owner or self.WeaponEnt:GetOwner()
		if not IsValid(owent) then
			owent = self.WeaponEnt:GetParent()
		end
	end
	if IsValid(owent) and owent:IsPlayer() then
		if owent ~= LocalPlayer() or owent:ShouldDrawLocalPlayer() then
			self.WeaponEnt = owent:GetActiveWeapon()
			if not IsValid(self.WeaponEnt) then return end
		else
			self.WeaponEnt = owent:GetViewModel()
			local theirweapon = owent:GetActiveWeapon()
			if IsValid(theirweapon) and theirweapon.ViewModelFlip or theirweapon.ViewModelFlipped then
				self.Flipped = true
			end
			if not IsValid(self.WeaponEnt) then return end
		end
	end
	if IsValid(self.WeaponEntOG) and self.WeaponEntOG.MuzzleAttachment then
		self.Attachment = self.WeaponEnt:LookupAttachment(self.WeaponEntOG.MuzzleAttachment)
		if not self.Attachment or self.Attachment <= 0 then
			self.Attachment = 1
		end
		if self.WeaponEntOG.Akimbo then
			if game.SinglePlayer() then
				self.WeaponEntOG.AnimCycle = self.WeaponEntOG:GetNW2Int("AnimCycle") or 0
			end
			self.Attachment = 1 + self.WeaponEntOG.AnimCycle
		end
	end
	local angpos
	if IsValid(self.WeaponEnt) then
		angpos = self.WeaponEnt:GetAttachment(self.Attachment)
	end
	if not angpos or not angpos.Pos then
		angpos = {
			Pos = bvec,
			Ang = uAng
		}
	end
	if self.Flipped then
		local tmpang = (self.Dir or angpos.Ang:Forward()):Angle()
		local localang = self.WeaponEnt:WorldToLocalAngles(tmpang)
		localang.y = localang.y + 180
		localang = self.WeaponEnt:LocalToWorldAngles(localang)
		self.Dir = localang:Forward()
	end
	if IsValid(owent) and self.Position:Distance(owent:GetShootPos()) > 72 then
		self.WeaponEnt = nil
	end
	
	self.StartPos = self:GetTracerShootPos(self.WeaponEnt and angpos.Pos or self.Position, self.WeaponEnt, self.Attachment)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	self.Normal = (self.EndPos - self.StartPos):GetNormalized()
	self.StartTime = 0
	local diff = self.EndPos - self.StartPos
	self.LifeTime = (diff:Length() - self.Length/2 ) / self.Speed
	self.data = data
	self.rot = nil
	weapon = data:GetEntity()
	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	if DynamicTracer:GetBool() then
		local spawn = util.CRC(tostring(self:GetPos()))
		local dlight = DynamicLight(self:EntIndex() + spawn)
		local endDistance = self.Speed * self.StartTime
		local endPos = self.StartPos + self.Normal * endDistance
		if (dlight) then
			dlight.pos = endPos
			dlight.r = 255
			dlight.g = 0
			dlight.b = 0
			dlight.brightness = 3
			dlight.Decay = 1500
			dlight.Size = 300
			dlight.nomodel = 1
			dlight.style = 6
			dlight.DieTime = CurTime() + 3
		end
	end
	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 9, 9, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 7, 0, 0, color_white)
end
--lua/effects/rw_sw_dual_laser_redpink.lua:
TRACER_FLAG_USEATTACHMENT 	= 0x0002
SOUND_FROM_WORLD			= 0
CHAN_STATIC 				= 6

EFFECT.Speed 				= 16384
EFFECT.Length 				= 95

local MaterialMain			= Material( "effects/sw_l/rw_sw_laser_m_redpink" )
local MaterialFront			= Material( "effects/sw_l/rw_sw_laser_f_redpink" )
local DynamicTracer 		= GetConVar("cl_dynamic_tracer")

function EFFECT:Init(data)
	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.WeaponEntOG = data:GetEntity()
	self.Attachment = data:GetAttachment()
	local owent
	if IsValid(self.WeaponEnt) then
		owent = self.WeaponEnt.Owner or self.WeaponEnt:GetOwner()
		if not IsValid(owent) then
			owent = self.WeaponEnt:GetParent()
		end
	end
	if IsValid(owent) and owent:IsPlayer() then
		if owent ~= LocalPlayer() or owent:ShouldDrawLocalPlayer() then
			self.WeaponEnt = owent:GetActiveWeapon()
			if not IsValid(self.WeaponEnt) then return end
		else
			self.WeaponEnt = owent:GetViewModel()
			local theirweapon = owent:GetActiveWeapon()
			if IsValid(theirweapon) and theirweapon.ViewModelFlip or theirweapon.ViewModelFlipped then
				self.Flipped = true
			end
			if not IsValid(self.WeaponEnt) then return end
		end
	end
	if IsValid(self.WeaponEntOG) and self.WeaponEntOG.MuzzleAttachment then
		self.Attachment = self.WeaponEnt:LookupAttachment(self.WeaponEntOG.MuzzleAttachment)
		if not self.Attachment or self.Attachment <= 0 then
			self.Attachment = 1
		end
		if self.WeaponEntOG.Akimbo then
			if game.SinglePlayer() then
				self.WeaponEntOG.AnimCycle = self.WeaponEntOG:GetNW2Int("AnimCycle") or 0
			end
			self.Attachment = 1 + self.WeaponEntOG.AnimCycle
		end
	end
	local angpos
	if IsValid(self.WeaponEnt) then
		angpos = self.WeaponEnt:GetAttachment(self.Attachment)
	end
	if not angpos or not angpos.Pos then
		angpos = {
			Pos = bvec,
			Ang = uAng
		}
	end
	if self.Flipped then
		local tmpang = (self.Dir or angpos.Ang:Forward()):Angle()
		local localang = self.WeaponEnt:WorldToLocalAngles(tmpang)
		localang.y = localang.y + 180
		localang = self.WeaponEnt:LocalToWorldAngles(localang)
		self.Dir = localang:Forward()
	end
	if IsValid(owent) and self.Position:Distance(owent:GetShootPos()) > 72 then
		self.WeaponEnt = nil
	end
	
	self.StartPos = self:GetTracerShootPos(self.WeaponEnt and angpos.Pos or self.Position, self.WeaponEnt, self.Attachment)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	self.Normal = (self.EndPos - self.StartPos):GetNormalized()
	self.StartTime = 0
	local diff = self.EndPos - self.StartPos
	self.LifeTime = (diff:Length() - self.Length/2 ) / self.Speed
	self.data = data
	self.rot = nil
	weapon = data:GetEntity()
	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	if DynamicTracer:GetBool() then
		local spawn = util.CRC(tostring(self:GetPos()))
		local dlight = DynamicLight(self:EntIndex() + spawn)
		local endDistance = self.Speed * self.StartTime
		local endPos = self.StartPos + self.Normal * endDistance
		if (dlight) then
			dlight.pos = endPos
			dlight.r = 255
			dlight.g = 0
			dlight.b = 50
			dlight.brightness = 3
			dlight.Decay = 1500
			dlight.Size = 300
			dlight.nomodel = 1
			dlight.style = 6
			dlight.DieTime = CurTime() + 3
		end
	end
	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 9, 9, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 7, 0, 0, color_white)
end
--lua/effects/rw_sw_dual_laser_yellow.lua:
TRACER_FLAG_USEATTACHMENT 	= 0x0002
SOUND_FROM_WORLD			= 0
CHAN_STATIC 				= 6

EFFECT.Speed 				= 16384
EFFECT.Length 				= 95

local MaterialMain 			= Material("effects/sw_laser_yellow_main")
local MaterialFront 		= Material("effects/sw_laser_yellow_front")
local DynamicTracer 		= GetConVar("cl_dynamic_tracer")

function EFFECT:Init(data)
	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.WeaponEntOG = data:GetEntity()
	self.Attachment = data:GetAttachment()
	local owent
	if IsValid(self.WeaponEnt) then
		owent = self.WeaponEnt.Owner or self.WeaponEnt:GetOwner()
		if not IsValid(owent) then
			owent = self.WeaponEnt:GetParent()
		end
	end
	if IsValid(owent) and owent:IsPlayer() then
		if owent ~= LocalPlayer() or owent:ShouldDrawLocalPlayer() then
			self.WeaponEnt = owent:GetActiveWeapon()
			if not IsValid(self.WeaponEnt) then return end
		else
			self.WeaponEnt = owent:GetViewModel()
			local theirweapon = owent:GetActiveWeapon()
			if IsValid(theirweapon) and theirweapon.ViewModelFlip or theirweapon.ViewModelFlipped then
				self.Flipped = true
			end
			if not IsValid(self.WeaponEnt) then return end
		end
	end
	if IsValid(self.WeaponEntOG) and self.WeaponEntOG.MuzzleAttachment then
		self.Attachment = self.WeaponEnt:LookupAttachment(self.WeaponEntOG.MuzzleAttachment)
		if not self.Attachment or self.Attachment <= 0 then
			self.Attachment = 1
		end
		if self.WeaponEntOG.Akimbo then
			if game.SinglePlayer() then
				self.WeaponEntOG.AnimCycle = self.WeaponEntOG:GetNW2Int("AnimCycle") or 0
			end
			self.Attachment = 1 + self.WeaponEntOG.AnimCycle
		end
	end
	local angpos
	if IsValid(self.WeaponEnt) then
		angpos = self.WeaponEnt:GetAttachment(self.Attachment)
	end
	if not angpos or not angpos.Pos then
		angpos = {
			Pos = bvec,
			Ang = uAng
		}
	end
	if self.Flipped then
		local tmpang = (self.Dir or angpos.Ang:Forward()):Angle()
		local localang = self.WeaponEnt:WorldToLocalAngles(tmpang)
		localang.y = localang.y + 180
		localang = self.WeaponEnt:LocalToWorldAngles(localang)
		self.Dir = localang:Forward()
	end
	if IsValid(owent) and self.Position:Distance(owent:GetShootPos()) > 72 then
		self.WeaponEnt = nil
	end
	
	self.StartPos = self:GetTracerShootPos(self.WeaponEnt and angpos.Pos or self.Position, self.WeaponEnt, self.Attachment)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	self.Normal = (self.EndPos - self.StartPos):GetNormalized()
	self.StartTime = 0
	local diff = self.EndPos - self.StartPos
	self.LifeTime = (diff:Length() - self.Length/2 ) / self.Speed
	self.data = data
	self.rot = nil
	weapon = data:GetEntity()
	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	if DynamicTracer:GetBool() then
		local spawn = util.CRC(tostring(self:GetPos()))
		local dlight = DynamicLight(self:EntIndex() + spawn)
		local endDistance = self.Speed * self.StartTime
		local endPos = self.StartPos + self.Normal * endDistance
		if (dlight) then
			dlight.pos = endPos
			dlight.r = 255
			dlight.g = 255
			dlight.b = 0
			dlight.brightness = 3
			dlight.Decay = 1500
			dlight.Size = 300
			dlight.nomodel = 1
			dlight.style = 6
			dlight.DieTime = CurTime() + 3
		end
	end
	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 9, 9, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 7, 0, 0, color_white)
end
--lua/effects/rw_sw_impact_orange.lua:
local MaterialGlow		= Material( "effects/sw_i/sw_laser_bit_orange" );
function EFFECT:Init( data )
	local bit_amount = GetConVar("rw_sw_bit_amount"):GetInt()
	local smoke_amount = GetConVar("rw_sw_smoke_amount"):GetInt()
	local duration = GetConVar("rw_sw_impact_duration"):GetInt()
	self.Position = data:GetOrigin();
	self.Normal = data:GetNormal();
	self.LifeTime = duration;
	local emitter = ParticleEmitter( self.Position );
	if( emitter ) then
		for i = 1, bit_amount do
			local particle = emitter:Add( MaterialGlow, self.Position + self.Normal * 2 );
			particle:SetVelocity( ( self.Normal + VectorRand() * 0.75 ):GetNormal() * math.Rand( 75, 125 ) );
			particle:SetDieTime( math.Rand( 0.5, 1.25 ) );
			particle:SetStartAlpha( 255 );
			particle:SetEndAlpha( 0 );
			particle:SetStartSize( math.Rand( 4, 8 ) );
			particle:SetEndSize( 0 );
			particle:SetRoll( 0 );
			particle:SetGravity( Vector( 0, 0, -250 ) );
			particle:SetCollide( true );
			particle:SetBounce( 0.3 );
			particle:SetAirResistance( 5 );
		end
		emitter:Finish();
	end
	local emitter_s = ParticleEmitter( self.Position );
	if( emitter_s ) then
		for i = 1, smoke_amount do
			local smokeTexture	= "effects/smoke"
			local particle_s = emitter_s:Add(smokeTexture, self.Position+self.Normal*2);
			particle_s:SetVelocity((self.Normal+VectorRand()*0.10):GetNormal()*math.Rand(400, 900));
			particle_s:SetDieTime(math.Rand(2.1, 2.7));
			particle_s:SetStartAlpha(50);
			particle_s:SetEndAlpha(0);
			particle_s:SetStartSize(math.Rand(8, 16));
			particle_s:SetEndSize(math.Rand(0, 4));
			particle_s:SetGravity(Vector(math.Rand(0, 500), math.Rand(250, 1000), math.Rand(-250, 250)));
			particle_s:SetRoll(math.Rand(0, 360));
			particle_s:SetRollDelta(math.Rand(-0.5, 0.5));
			local colour = math.Rand(110, 130);
			particle_s:SetColor(colour, colour, colour, 100);
			particle_s:SetCollide(true);
			particle_s:SetAirResistance(2000);
		end
		emitter_s:Finish();
	end
end
function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime();
	return self.LifeTime > 0;
end
function EFFECT:Render()
	local size = GetConVar("rw_sw_impact_size"):GetInt()
	local duration = GetConVar("rw_sw_impact_duration"):GetInt()
	local frac = math.max( 0, self.LifeTime / duration);
	local rgb = 255 * frac;
	local color = Color( rgb, rgb, rgb, 255 );
	render.SetMaterial( MaterialGlow );
	render.DrawQuadEasy( self.Position + self.Normal, self.Normal, size, size, color );
end
--lua/effects/rw_sw_impact_servius.lua:
local MaterialGlow		= Material( "effects/sw_i/sw_laser_bit_red" );
function EFFECT:Init( data )
	local bit_amount = GetConVar("rw_sw_bit_amount"):GetInt()
	local smoke_amount = GetConVar("rw_sw_smoke_amount"):GetInt()
	local duration = GetConVar("rw_sw_impact_duration"):GetInt()
	self.Position = data:GetOrigin();
	self.Normal = data:GetNormal();
	self.LifeTime = duration;
	local emitter = ParticleEmitter( self.Position );
	if( emitter ) then
		for i = 1, bit_amount do
			local particle = emitter:Add( MaterialGlow, self.Position + self.Normal * 2 );
			particle:SetVelocity( ( self.Normal + VectorRand() * 0.75 ):GetNormal() * math.Rand( 75, 125 ) );
			particle:SetDieTime( math.Rand( 0.5, 1.25 ) );
			particle:SetStartAlpha( 255 );
			particle:SetEndAlpha( 0 );
			particle:SetStartSize( math.Rand( 4, 8 ) );
			particle:SetEndSize( 0 );
			particle:SetRoll( 0 );
			particle:SetGravity( Vector( 0, 0, -250 ) );
			particle:SetCollide( true );
			particle:SetBounce( 0.3 );
			particle:SetAirResistance( 5 );
		end
		emitter:Finish();
	end
	local emitter_s = ParticleEmitter( self.Position );
	if( emitter_s ) then
		for i = 1, smoke_amount do
			local smokeTexture	= "effects/smoke"
			local particle_s = emitter_s:Add(smokeTexture, self.Position+self.Normal*2);
			particle_s:SetVelocity((self.Normal+VectorRand()*0.10):GetNormal()*math.Rand(400, 900));
			particle_s:SetDieTime(math.Rand(2.1, 2.7));
			particle_s:SetStartAlpha(50);
			particle_s:SetEndAlpha(0);
			particle_s:SetStartSize(math.Rand(8, 16));
			particle_s:SetEndSize(math.Rand(0, 4));
			particle_s:SetGravity(Vector(math.Rand(0, 500), math.Rand(250, 1000), math.Rand(-250, 250)));
			particle_s:SetRoll(math.Rand(0, 360));
			particle_s:SetRollDelta(math.Rand(-0.5, 0.5));
			local colour = math.Rand(50, 150);
			particle_s:SetColor(colour, colour, colour, 100);
			particle_s:SetCollide(true);
			particle_s:SetAirResistance(2000);
		end
		emitter_s:Finish();
	end
end
function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime();
	return self.LifeTime > 0;
end
function EFFECT:Render()
	local size = GetConVar("rw_sw_impact_size"):GetInt()
	local duration = GetConVar("rw_sw_impact_duration"):GetInt()
	local frac = math.max( 0, self.LifeTime / duration);
	local rgb = 255 * frac;
	local color = Color( rgb, rgb, rgb, 255 );
	render.SetMaterial( MaterialGlow );
	render.DrawQuadEasy( self.Position + self.Normal, self.Normal, size, size, color );
end
--lua/effects/rw_sw_laser_aqua.lua:

TRACER_FLAG_USEATTACHMENT 	= 0x0002
SOUND_FROM_WORLD 			= 0
CHAN_STATIC 				= 6

EFFECT.Speed 				= 16384
EFFECT.Length 				= 175

local MaterialMain 			= Material("effects/sw_l/rw_sw_laser_m_aqua")
local MaterialFront 		= Material("effects/sw_l/rw_sw_laser_f_aqua")
local DynamicTracer 		= GetConVar("cl_dynamic_tracer")

function EFFECT:GetTracerOrigin(data)
	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart()

	-- use attachment?
	if (bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT) then
		local entity = data:GetEntity()
		if (not IsValid(entity)) then return start end
		if (not game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT)) then return start end

		if (entity:IsWeapon() and entity:IsCarriedByLocalPlayer()) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin()
			-- if( origin ) then
			-- 	return origin, angle, entity
			-- end
			-- use the view model
			local pl = entity:GetOwner()

			if (IsValid(pl)) then
				local vm = pl:GetViewModel()

				if (IsValid(vm) and not LocalPlayer():ShouldDrawLocalPlayer()) then
					entity = vm
					-- HACK: fix the model in multiplayer
				else
					if (entity.WorldModel) then
						entity:SetModel(entity.WorldModel)
					end
				end
			end
		end

		local attachment = entity:GetAttachment(data:GetAttachment())

		if (attachment) then
			start = attachment.Pos
		end
	end

	return start
end

function EFFECT:Init(data)
	self.StartPos = self:GetTracerOrigin(data)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	local diff = self.EndPos - self.StartPos
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = (diff:Length() + self.Length) / self.Speed
	-- whiz by sound
	local weapon = data:GetEntity()

	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

--concommand.Add("sv_dlight")
function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()

	if DynamicTracer:GetBool() then
		local spawn = util.CRC(tostring(self:GetPos()))
		local dlight = DynamicLight(self:EntIndex() + spawn)
		local endDistance = self.Speed * self.StartTime
		local endPos = self.StartPos + self.Normal * endDistance

		if (dlight) then
			dlight.pos = endPos
			dlight.r = 0
			dlight.g = 255
			dlight.b = 160
			dlight.brightness = 5
			dlight.Decay = 1000
			dlight.Size = 200
			dlight.nomodel = 1
			dlight.style = 6
			dlight.DieTime = CurTime() + 3
		end
	end

	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 6, 6, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 6, 0, 1, color_white)
end
--addons/egm_tfa_weapons/lua/effects/rw_sw_laser_rainbow.lua:

TRACER_FLAG_USEATTACHMENT 	= 0x0002
SOUND_FROM_WORLD 			= 0
COLOR_PER_SECOND			= 2
CHAN_STATIC 				= 6

EFFECT.Speed 				= 16384
EFFECT.Length 				= 175

local MainMaterials = {
	Material("effects/sw_laser_blue_main"),
	Material("effects/sw_laser_green_main"),
	Material("effects/sw_laser_yellow_main"),
	Material("effects/sw_laser_red_main"),
	Material("effects/sw_laser_purple_main"),
}
local FrontMaterials = {
	Material("effects/sw_laser_blue_front"),
	Material("effects/sw_laser_green_front"),
	Material("effects/sw_laser_yellow_front"),
	Material("effects/sw_laser_red_front"),
	Material("effects/sw_laser_purple_front"),
}
local Colors = {
	{r = 15, g = 20, b = 255},
	{r = 15, g = 255, b = 20},
	{r = 255, g = 175, b = 10},
	{r = 255, g = 20, b = 5},
	{r = 255, g = 20, b = 255},
}

local DynamicTracer 		= GetConVar("cl_dynamic_tracer")

function EFFECT:GetTracerOrigin(data)
	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart()

	-- use attachment?
	if (bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT) then
		local entity = data:GetEntity()
		if (not IsValid(entity)) then return start end
		if (not game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT)) then return start end

		if (entity:IsWeapon() and entity:IsCarriedByLocalPlayer()) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin()
			-- if( origin ) then
			-- 	return origin, angle, entity
			-- end
			-- use the view model
			local pl = entity:GetOwner()

			if (IsValid(pl)) then
				local vm = pl:GetViewModel()

				if (IsValid(vm) and not LocalPlayer():ShouldDrawLocalPlayer()) then
					entity = vm
					-- HACK: fix the model in multiplayer
				else
					if (entity.WorldModel) then
						entity:SetModel(entity.WorldModel)
					end
				end
			end
		end

		local attachment = entity:GetAttachment(data:GetAttachment())

		if (attachment) then
			start = attachment.Pos
		end
	end

	return start
end

function EFFECT:Init(data)
	self.StartPos = self:GetTracerOrigin(data)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	local diff = self.EndPos - self.StartPos
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = (diff:Length() + self.Length) / self.Speed
end

--concommand.Add("sv_dlight")
function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()

	local colorId = math.floor((CurTime() * COLOR_PER_SECOND) % 5)

	if DynamicTracer:GetBool() then
		local spawn = util.CRC(tostring(self:GetPos()))
		local dlight = DynamicLight(self:EntIndex() + spawn)
		local endDistance = self.Speed * self.StartTime
		local endPos = self.StartPos + self.Normal * endDistance

		local color = Colors[colorId + 1]

		if (dlight) then
			dlight.pos = endPos
			dlight.r = color.r
			dlight.g = color.g
			dlight.b = color.b
			dlight.brightness = 5
			dlight.Decay = 1000
			dlight.Size = 200
			dlight.nomodel = 1
			dlight.style = 6
			dlight.DieTime = CurTime() + 3
		end
	end

	return self.LifeTime > 0
end

function EFFECT:Render()
	local colorId = math.floor((CurTime() * COLOR_PER_SECOND) % 5)

	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(FrontMaterials[colorId + 1])
	render.DrawSprite(endPos, 6, 6, color_white)
	render.SetMaterial(MainMaterials[colorId + 1])
	render.DrawBeam(startPos, endPos, 6, 0, 1, color_white)
end
--lua/effects/rw_sw_muzzleflash_blue.lua:
EFFECT.Life = 0.12
EFFECT.XFlashSize = 0.55
EFFECT.FlashSize = 0.5
EFFECT.SmokeSize = 0
EFFECT.SparkSize = 1.25
EFFECT.HeatSize = 2.5
EFFECT.Color = Color(0,120,255)
EFFECT.ColorSprites = true

local AddVel = Vector()
local ang

function EFFECT:Init(data)
	self.WeaponEnt = data:GetEntity()
	if not IsValid(self.WeaponEnt) then return end
	self.Attachment = data:GetAttachment()
	self.Position = self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)

	if IsValid(self.WeaponEnt:GetOwner()) then
		if self.WeaponEnt:GetOwner() == LocalPlayer() then
			if self.WeaponEnt:GetOwner():ShouldDrawLocalPlayer() then
				ang = self.WeaponEnt:GetOwner():EyeAngles()
				ang:Normalize()
				--ang.p = math.max(math.min(ang.p,55),-55)
				self.Forward = ang:Forward()
			else
				self.WeaponEnt = self.WeaponEnt:GetOwner():GetViewModel()
			end
			--ang.p = math.max(math.min(ang.p,55),-55)
		else
			ang = self.WeaponEnt:GetOwner():EyeAngles()
			ang:Normalize()
			self.Forward = ang:Forward()
		end
	end

	self.Forward = self.Forward or data:GetNormal()
	self.Angle = self.Forward:Angle()
	self.Right = self.Angle:Right()
	self.vOffset = self.Position
	local dir = self.Forward
	local ownerent = self.WeaponEnt:GetOwner()

	if not IsValid(ownerent) then
		ownerent = LocalPlayer()
	end

	AddVel = ownerent:GetVelocity()
	self.vOffset = self.Position
	AddVel = AddVel * 0.05
	local dot = dir:GetNormalized():Dot(GetViewEntity():EyeAngles():Forward())
	local halofac = math.abs(dot)
	local epos = ownerent:GetShootPos()
	local dlight = DynamicLight(ownerent:EntIndex())

	if (dlight) then
		dlight.pos = epos + ownerent:EyeAngles():Forward() * self.vOffset:Distance(epos) --self.vOffset - ownerent:EyeAngles():Right() * 5 + 1.05 * ownerent:GetVelocity() * FrameTime()
		dlight.r = self.Color.r
		dlight.g = self.Color.g
		dlight.b = self.Color.b
		dlight.brightness = 4.5
		dlight.decay = 200 / self.Life
		dlight.size = self.FlashSize * 150
		dlight.dietime = CurTime() + self.Life
	end

	self.Dist = self.vOffset:Distance(epos)
	self.DLight = dlight
	self.DieTime = CurTime() + self.Life
	self.OwnerEnt = ownerent
	local emitter = ParticleEmitter(self.vOffset)
	local sval = 1 - math.random(0, 1) * 2

	if self.WeaponEnt.XTick == nil then
		self.WeaponEnt.XTick = 0
	end

	self.WeaponEnt.XTick = 1 - self.WeaponEnt.XTick

	if self.WeaponEnt.XTick == 1 and self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.XFlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(3 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			particle:SetEndSize(15 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
		--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
		--particle:SetEndSize( 0 )
	elseif self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			particle:SetStartSize(2 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			particle:SetEndSize(6 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
	end

	local flashCount = math.Round(self.FlashSize * 8)

	for i = 1, flashCount do
		local particle = emitter:Add(self.ColorSprites and "effects/scotchmuzzleflashw" or "effects/scotchmuzzleflash4", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 300 * (0.2 + (i / flashCount) * 0.8) * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(math.Rand(128, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			local szsc = 1 + (flashCount - i) * math.pow(1 / flashCount * 0.9,0.8)
			particle:SetStartSize(1.25 * math.Rand(1, 1.5) * szsc * self.FlashSize)
			particle:SetEndSize(6 * math.Rand(0.75, 1) * szsc * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	for _ = 1, flashCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 6 * self.FlashSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 1)
			particle:SetStartAlpha(math.Rand(40, 140))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(2 * math.Rand(1, 1.5) * self.FlashSize)
			particle:SetEndSize(20 * math.Rand(0.5, 1) * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(30, 60)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			--TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	local glowCount = math.ceil(self.FlashSize * 3)

	for i = 1, glowCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + dir * 0.9 * i)

		if (particle) then
			--particle:SetVelocity(dir * 32 )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(255 * (1 - halofac))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.2 * self.FlashSize)
			particle:SetEndSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.6 * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	local smokeCount = math.ceil(self.SmokeSize * 6)

	for _ = 0, smokeCount do
		local particle = emitter:Add("particles/smokey", self.vOffset + dir * math.Rand(3, 14))

		if (particle) then
			particle:SetVelocity(VectorRand() * 10 * self.SmokeSize + dir * math.Rand(35, 50) * self.SmokeSize + 1.05 * AddVel)
			particle:SetDieTime(math.Rand(0.6, 1) * self.Life * 6)
			particle:SetStartAlpha(math.Rand(12, 24))
			particle:SetEndAlpha(0)
			particle:SetStartSize(math.Rand(5, 7) * self.SmokeSize)
			particle:SetEndSize(math.Rand(15, 20) * self.SmokeSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.Rand(-0.8, 0.8))
			particle:SetLighting(true)
			particle:SetAirResistance(20)
			particle:SetGravity(Vector(0, 0, 60))
			particle:SetColor(255, 255, 255)
		end
	end

	local sparkcount = math.Round(math.random(8, 12) * self.SparkSize)

	for _ = 0, sparkcount do
		local particle = emitter:Add("effects/yellowflare", self.Position)

		if (particle) then
			particle:SetVelocity( VectorRand() * 30 * self.SparkSize)
			particle:SetVelocity(particle:GetVelocity() + 1.15 * AddVel )
			particle:SetVelocity( particle:GetVelocity() + dir * math.Rand(80, 100) * (1-math.abs(math.max(particle:GetVelocity():GetNormalized():Dot(-dir),0))) * self.SparkSize )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * math.Rand(0.9,1.1))
			particle:SetStartAlpha(255)
			particle:SetEndAlpha(0)
			particle:SetStartSize(0.6)
			particle:SetEndSize(1)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetGravity(vector_origin)
			particle:SetAirResistance(1)
			particle:SetStartLength(0.1)
			particle:SetEndLength(0.05)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, math.random(192, 225), math.random(140, 192))
			end

			particle:SetVelocityScale(true)
			local sl = self.SparkSize

			particle:SetThinkFunction(function(pa)
				math.randomseed(SysTime())
				local spd = pa:GetVelocity():Length()*12
				pa.ranvel = pa.ranvel or VectorRand() * spd
				pa.ranvel:Add(VectorRand() * spd * math.sqrt(FrameTime()))
				pa:SetVelocity(pa:GetVelocity() + pa.ranvel * sl * FrameTime() )
				pa:SetNextThink(CurTime())
			end)

			particle:SetNextThink(CurTime() + 0.01)
		end
	end

	if TFA.GetGasEnabled() then
		local particle = emitter:Add("sprites/heatwave", self.vOffset + dir*2)

		if (particle) then
			particle:SetVelocity(dir * 25 * self.HeatSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life)
			particle:SetStartAlpha(math.Rand(200, 225))
			particle:SetEndAlpha(0)
			particle:SetStartSize(math.Rand(3, 5) * self.HeatSize)
			particle:SetEndSize(math.Rand(8, 12) * self.HeatSize)
			particle:SetRoll(math.Rand(0, 360))
			particle:SetRollDelta(math.Rand(-2, 2))
			particle:SetAirResistance(5)
			particle:SetGravity(Vector(0, 0, 40))
			particle:SetColor(255, 255, 255)
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	if CurTime() > self.DieTime then
		return false
	elseif self.DLight and IsValid(self.OwnerEnt) then
			self.DLight.pos = self.OwnerEnt:GetShootPos() + self.OwnerEnt:EyeAngles():Forward() * self.Dist
	end

	return true
end

function EFFECT:Render()
end
--lua/effects/rw_sw_muzzleflash_green.lua:
EFFECT.Life = 0.12
EFFECT.XFlashSize = 0.55
EFFECT.FlashSize = 0.5
EFFECT.SmokeSize = 0
EFFECT.SparkSize = 1.25
EFFECT.HeatSize = 2.5
EFFECT.Color = Color(0,255,0)
EFFECT.ColorSprites = true

local AddVel = Vector()
local ang

function EFFECT:Init(data)
	self.WeaponEnt = data:GetEntity()
	if not IsValid(self.WeaponEnt) then return end
	self.Attachment = data:GetAttachment()
	self.Position = self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)

	if IsValid(self.WeaponEnt:GetOwner()) then
		if self.WeaponEnt:GetOwner() == LocalPlayer() then
			if self.WeaponEnt:GetOwner():ShouldDrawLocalPlayer() then
				ang = self.WeaponEnt:GetOwner():EyeAngles()
				ang:Normalize()
				--ang.p = math.max(math.min(ang.p,55),-55)
				self.Forward = ang:Forward()
			else
				self.WeaponEnt = self.WeaponEnt:GetOwner():GetViewModel()
			end
			--ang.p = math.max(math.min(ang.p,55),-55)
		else
			ang = self.WeaponEnt:GetOwner():EyeAngles()
			ang:Normalize()
			self.Forward = ang:Forward()
		end
	end

	self.Forward = self.Forward or data:GetNormal()
	self.Angle = self.Forward:Angle()
	self.Right = self.Angle:Right()
	self.vOffset = self.Position
	local dir = self.Forward
	local ownerent = self.WeaponEnt:GetOwner()

	if not IsValid(ownerent) then
		ownerent = LocalPlayer()
	end

	AddVel = ownerent:GetVelocity()
	self.vOffset = self.Position
	AddVel = AddVel * 0.05
	local dot = dir:GetNormalized():Dot(GetViewEntity():EyeAngles():Forward())
	local halofac = math.abs(dot)
	local epos = ownerent:GetShootPos()
	local dlight = DynamicLight(ownerent:EntIndex())

	if (dlight) then
		dlight.pos = epos + ownerent:EyeAngles():Forward() * self.vOffset:Distance(epos) --self.vOffset - ownerent:EyeAngles():Right() * 5 + 1.05 * ownerent:GetVelocity() * FrameTime()
		dlight.r = self.Color.r
		dlight.g = self.Color.g
		dlight.b = self.Color.b
		dlight.brightness = 4.5
		dlight.decay = 200 / self.Life
		dlight.size = self.FlashSize * 150
		dlight.dietime = CurTime() + self.Life
	end

	self.Dist = self.vOffset:Distance(epos)
	self.DLight = dlight
	self.DieTime = CurTime() + self.Life
	self.OwnerEnt = ownerent
	local emitter = ParticleEmitter(self.vOffset)
	local sval = 1 - math.random(0, 1) * 2

	if self.WeaponEnt.XTick == nil then
		self.WeaponEnt.XTick = 0
	end

	self.WeaponEnt.XTick = 1 - self.WeaponEnt.XTick

	if self.WeaponEnt.XTick == 1 and self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.XFlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(3 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			particle:SetEndSize(15 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
		--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
		--particle:SetEndSize( 0 )
	elseif self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			particle:SetStartSize(2 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			particle:SetEndSize(6 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
	end

	local flashCount = math.Round(self.FlashSize * 8)

	for i = 1, flashCount do
		local particle = emitter:Add(self.ColorSprites and "effects/scotchmuzzleflashw" or "effects/scotchmuzzleflash4", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 300 * (0.2 + (i / flashCount) * 0.8) * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(math.Rand(128, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			local szsc = 1 + (flashCount - i) * math.pow(1 / flashCount * 0.9,0.8)
			particle:SetStartSize(1.25 * math.Rand(1, 1.5) * szsc * self.FlashSize)
			particle:SetEndSize(6 * math.Rand(0.75, 1) * szsc * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	for _ = 1, flashCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 6 * self.FlashSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 1)
			particle:SetStartAlpha(math.Rand(40, 140))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(2 * math.Rand(1, 1.5) * self.FlashSize)
			particle:SetEndSize(20 * math.Rand(0.5, 1) * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(30, 60)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			--TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	local glowCount = math.ceil(self.FlashSize * 3)

	for i = 1, glowCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + dir * 0.9 * i)

		if (particle) then
			--particle:SetVelocity(dir * 32 )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(255 * (1 - halofac))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.2 * self.FlashSize)
			particle:SetEndSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.6 * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	local smokeCount = math.ceil(self.SmokeSize * 6)

	for _ = 0, smokeCount do
		local particle = emitter:Add("particles/smokey", self.vOffset + dir * math.Rand(3, 14))

		if (particle) then
			particle:SetVelocity(VectorRand() * 10 * self.SmokeSize + dir * math.Rand(35, 50) * self.SmokeSize + 1.05 * AddVel)
			particle:SetDieTime(math.Rand(0.6, 1) * self.Life * 6)
			particle:SetStartAlpha(math.Rand(12, 24))
			particle:SetEndAlpha(0)
			particle:SetStartSize(math.Rand(5, 7) * self.SmokeSize)
			particle:SetEndSize(math.Rand(15, 20) * self.SmokeSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.Rand(-0.8, 0.8))
			particle:SetLighting(true)
			particle:SetAirResistance(20)
			particle:SetGravity(Vector(0, 0, 60))
			particle:SetColor(255, 255, 255)
		end
	end

	local sparkcount = math.Round(math.random(8, 12) * self.SparkSize)

	for _ = 0, sparkcount do
		local particle = emitter:Add("effects/yellowflare", self.Position)

		if (particle) then
			particle:SetVelocity( VectorRand() * 30 * self.SparkSize)
			particle:SetVelocity(particle:GetVelocity() + 1.15 * AddVel )
			particle:SetVelocity( particle:GetVelocity() + dir * math.Rand(80, 100) * (1-math.abs(math.max(particle:GetVelocity():GetNormalized():Dot(-dir),0))) * self.SparkSize )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * math.Rand(0.9,1.1))
			particle:SetStartAlpha(255)
			particle:SetEndAlpha(0)
			particle:SetStartSize(0.6)
			particle:SetEndSize(1)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetGravity(vector_origin)
			particle:SetAirResistance(1)
			particle:SetStartLength(0.1)
			particle:SetEndLength(0.05)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, math.random(192, 225), math.random(140, 192))
			end

			particle:SetVelocityScale(true)
			local sl = self.SparkSize

			particle:SetThinkFunction(function(pa)
				math.randomseed(SysTime())
				local spd = pa:GetVelocity():Length()*12
				pa.ranvel = pa.ranvel or VectorRand() * spd
				pa.ranvel:Add(VectorRand() * spd * math.sqrt(FrameTime()))
				pa:SetVelocity(pa:GetVelocity() + pa.ranvel * sl * FrameTime() )
				pa:SetNextThink(CurTime())
			end)

			particle:SetNextThink(CurTime() + 0.01)
		end
	end

	if TFA.GetGasEnabled() then
		local particle = emitter:Add("sprites/heatwave", self.vOffset + dir*2)

		if (particle) then
			particle:SetVelocity(dir * 25 * self.HeatSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life)
			particle:SetStartAlpha(math.Rand(200, 225))
			particle:SetEndAlpha(0)
			particle:SetStartSize(math.Rand(3, 5) * self.HeatSize)
			particle:SetEndSize(math.Rand(8, 12) * self.HeatSize)
			particle:SetRoll(math.Rand(0, 360))
			particle:SetRollDelta(math.Rand(-2, 2))
			particle:SetAirResistance(5)
			particle:SetGravity(Vector(0, 0, 40))
			particle:SetColor(255, 255, 255)
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	if CurTime() > self.DieTime then
		return false
	elseif self.DLight and IsValid(self.OwnerEnt) then
			self.DLight.pos = self.OwnerEnt:GetShootPos() + self.OwnerEnt:EyeAngles():Forward() * self.Dist
	end

	return true
end

function EFFECT:Render()
end
--lua/effects/rw_sw_muzzleflash_grey.lua:
EFFECT.Life = 0.12
EFFECT.XFlashSize = 0.55
EFFECT.FlashSize = 0.5
EFFECT.SmokeSize = 0
EFFECT.SparkSize = 1.25
EFFECT.HeatSize = 2.5
EFFECT.Color = Color(130,150,180)
EFFECT.ColorSprites = true

local AddVel = Vector()
local ang

function EFFECT:Init(data)
	self.WeaponEnt = data:GetEntity()
	if not IsValid(self.WeaponEnt) then return end
	self.Attachment = data:GetAttachment()
	self.Position = self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)

	if IsValid(self.WeaponEnt:GetOwner()) then
		if self.WeaponEnt:GetOwner() == LocalPlayer() then
			if self.WeaponEnt:GetOwner():ShouldDrawLocalPlayer() then
				ang = self.WeaponEnt:GetOwner():EyeAngles()
				ang:Normalize()
				--ang.p = math.max(math.min(ang.p,55),-55)
				self.Forward = ang:Forward()
			else
				self.WeaponEnt = self.WeaponEnt:GetOwner():GetViewModel()
			end
			--ang.p = math.max(math.min(ang.p,55),-55)
		else
			ang = self.WeaponEnt:GetOwner():EyeAngles()
			ang:Normalize()
			self.Forward = ang:Forward()
		end
	end

	self.Forward = self.Forward or data:GetNormal()
	self.Angle = self.Forward:Angle()
	self.Right = self.Angle:Right()
	self.vOffset = self.Position
	local dir = self.Forward
	local ownerent = self.WeaponEnt:GetOwner()

	if not IsValid(ownerent) then
		ownerent = LocalPlayer()
	end

	AddVel = ownerent:GetVelocity()
	self.vOffset = self.Position
	AddVel = AddVel * 0.05
	local dot = dir:GetNormalized():Dot(GetViewEntity():EyeAngles():Forward())
	local halofac = math.abs(dot)
	local epos = ownerent:GetShootPos()
	local dlight = DynamicLight(ownerent:EntIndex())

	if (dlight) then
		dlight.pos = epos + ownerent:EyeAngles():Forward() * self.vOffset:Distance(epos) --self.vOffset - ownerent:EyeAngles():Right() * 5 + 1.05 * ownerent:GetVelocity() * FrameTime()
		dlight.r = self.Color.r
		dlight.g = self.Color.g
		dlight.b = self.Color.b
		dlight.brightness = 4.5
		dlight.decay = 200 / self.Life
		dlight.size = self.FlashSize * 150
		dlight.dietime = CurTime() + self.Life
	end

	self.Dist = self.vOffset:Distance(epos)
	self.DLight = dlight
	self.DieTime = CurTime() + self.Life
	self.OwnerEnt = ownerent
	local emitter = ParticleEmitter(self.vOffset)
	local sval = 1 - math.random(0, 1) * 2

	if self.WeaponEnt.XTick == nil then
		self.WeaponEnt.XTick = 0
	end

	self.WeaponEnt.XTick = 1 - self.WeaponEnt.XTick

	if self.WeaponEnt.XTick == 1 and self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.XFlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(3 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			particle:SetEndSize(15 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
		--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
		--particle:SetEndSize( 0 )
	elseif self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			particle:SetStartSize(2 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			particle:SetEndSize(6 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
	end

	local flashCount = math.Round(self.FlashSize * 8)

	for i = 1, flashCount do
		local particle = emitter:Add(self.ColorSprites and "effects/scotchmuzzleflashw" or "effects/scotchmuzzleflash4", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 300 * (0.2 + (i / flashCount) * 0.8) * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(math.Rand(128, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			local szsc = 1 + (flashCount - i) * math.pow(1 / flashCount * 0.9,0.8)
			particle:SetStartSize(1.25 * math.Rand(1, 1.5) * szsc * self.FlashSize)
			particle:SetEndSize(6 * math.Rand(0.75, 1) * szsc * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	for _ = 1, flashCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 6 * self.FlashSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 1)
			particle:SetStartAlpha(math.Rand(40, 140))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(2 * math.Rand(1, 1.5) * self.FlashSize)
			particle:SetEndSize(20 * math.Rand(0.5, 1) * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(30, 60)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			--TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	local glowCount = math.ceil(self.FlashSize * 3)

	for i = 1, glowCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + dir * 0.9 * i)

		if (particle) then
			--particle:SetVelocity(dir * 32 )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(255 * (1 - halofac))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.2 * self.FlashSize)
			particle:SetEndSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.6 * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	local smokeCount = math.ceil(self.SmokeSize * 6)

	for _ = 0, smokeCount do
		local particle = emitter:Add("particles/smokey", self.vOffset + dir * math.Rand(3, 14))

		if (particle) then
			particle:SetVelocity(VectorRand() * 10 * self.SmokeSize + dir * math.Rand(35, 50) * self.SmokeSize + 1.05 * AddVel)
			particle:SetDieTime(math.Rand(0.6, 1) * self.Life * 6)
			particle:SetStartAlpha(math.Rand(12, 24))
			particle:SetEndAlpha(0)
			particle:SetStartSize(math.Rand(5, 7) * self.SmokeSize)
			particle:SetEndSize(math.Rand(15, 20) * self.SmokeSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.Rand(-0.8, 0.8))
			particle:SetLighting(true)
			particle:SetAirResistance(20)
			particle:SetGravity(Vector(0, 0, 60))
			particle:SetColor(255, 255, 255)
		end
	end

	local sparkcount = math.Round(math.random(8, 12) * self.SparkSize)

	for _ = 0, sparkcount do
		local particle = emitter:Add("effects/yellowflare", self.Position)

		if (particle) then
			particle:SetVelocity( VectorRand() * 30 * self.SparkSize)
			particle:SetVelocity(particle:GetVelocity() + 1.15 * AddVel )
			particle:SetVelocity( particle:GetVelocity() + dir * math.Rand(80, 100) * (1-math.abs(math.max(particle:GetVelocity():GetNormalized():Dot(-dir),0))) * self.SparkSize )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * math.Rand(0.9,1.1))
			particle:SetStartAlpha(255)
			particle:SetEndAlpha(0)
			particle:SetStartSize(0.6)
			particle:SetEndSize(1)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetGravity(vector_origin)
			particle:SetAirResistance(1)
			particle:SetStartLength(0.1)
			particle:SetEndLength(0.05)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, math.random(192, 225), math.random(140, 192))
			end

			particle:SetVelocityScale(true)
			local sl = self.SparkSize

			particle:SetThinkFunction(function(pa)
				math.randomseed(SysTime())
				local spd = pa:GetVelocity():Length()*12
				pa.ranvel = pa.ranvel or VectorRand() * spd
				pa.ranvel:Add(VectorRand() * spd * math.sqrt(FrameTime()))
				pa:SetVelocity(pa:GetVelocity() + pa.ranvel * sl * FrameTime() )
				pa:SetNextThink(CurTime())
			end)

			particle:SetNextThink(CurTime() + 0.01)
		end
	end

	if TFA.GetGasEnabled() then
		local particle = emitter:Add("sprites/heatwave", self.vOffset + dir*2)

		if (particle) then
			particle:SetVelocity(dir * 25 * self.HeatSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life)
			particle:SetStartAlpha(math.Rand(200, 225))
			particle:SetEndAlpha(0)
			particle:SetStartSize(math.Rand(3, 5) * self.HeatSize)
			particle:SetEndSize(math.Rand(8, 12) * self.HeatSize)
			particle:SetRoll(math.Rand(0, 360))
			particle:SetRollDelta(math.Rand(-2, 2))
			particle:SetAirResistance(5)
			particle:SetGravity(Vector(0, 0, 40))
			particle:SetColor(255, 255, 255)
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	if CurTime() > self.DieTime then
		return false
	elseif self.DLight and IsValid(self.OwnerEnt) then
			self.DLight.pos = self.OwnerEnt:GetShootPos() + self.OwnerEnt:EyeAngles():Forward() * self.Dist
	end

	return true
end

function EFFECT:Render()
end
--lua/effects/rw_sw_stunwave_orange.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002;
SOUND_FROM_WORLD			= 0;
CHAN_STATIC					= 6;

EFFECT.Speed				= 4500;
EFFECT.Length				= 64;

local MaterialFront			= Material( "cs574/stun_tracers/sw_stunwave_orange" );

function EFFECT:GetTracerOrigin(data)
	local start = data:GetStart()
	if (bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT) then
		local entity = data:GetEntity()
		if (not IsValid(entity)) then return start end
		if (not game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT)) then return start end

		if (entity:IsWeapon() and entity:IsCarriedByLocalPlayer()) then
			local pl = entity:GetOwner()

			if (IsValid(pl)) then
				local vm = pl:GetViewModel()

				if (IsValid(vm) and not LocalPlayer():ShouldDrawLocalPlayer()) then
					entity = vm
				else
					if (entity.WorldModel) then
						entity:SetModel(entity.WorldModel)
					end
				end
			end
		end
		local attachment = entity:GetAttachment(data:GetAttachment())
		if (attachment) then
			start = attachment.Pos
		end
	end

	return start
end

function EFFECT:Init(data)
	self.StartPos = self:GetTracerOrigin(data)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	local diff = (self.EndPos - self.StartPos)
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = (diff:Length() + self.Length) / self.Speed
	-- whiz by sound
	local weapon = data:GetEntity()

	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

EFFECT.WaveSize = 0

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()

	if (self.WaveSize < 45) then
		self.WaveSize = self.WaveSize + 1
	end

	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(startPos, 1 + self.WaveSize, 1 + self.WaveSize, color_white)
end
--addons/tfa_base/lua/effects/tfa_bullet_impact/init.lua:
function EFFECT:Init(data)
	local posoffset = data:GetOrigin()
	local emitter = ParticleEmitter(posoffset)

	if TFA.GetGasEnabled() then
		local p = emitter:Add("sprites/heatwave", posoffset)
		p:SetVelocity(50 * data:GetNormal() + 0.5 * VectorRand())
		p:SetAirResistance(200)
		p:SetStartSize(math.random(12.5, 17.5))
		p:SetEndSize(2)
		p:SetDieTime(math.Rand(0.15, 0.225))
		p:SetRoll(math.Rand(-180, 180))
		p:SetRollDelta(math.Rand(-0.75, 0.75))
	end

	emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
return false
end
--addons/egm_tfa_grenades/lua/effects/tfa_csgo_poisonade_stun/init.lua:
--Thanks Inconceivable/Generic Default
function EFFECT:Init(data)
	self.Entity = data:GetEntity()
	if not IsValid(self.Entity) then return end

	self.Duration = self.Entity:GetNWInt("duration", 5)

	pos = data:GetOrigin()
	self.Emitter = ParticleEmitter(pos)

	for i = 1, 25 do
		local particle = self.Emitter:Add( "tfa_csgo/particle/particle_smokegrenade", pos)
		if (particle) then
			particle:SetVelocity(VectorRand():GetNormalized() * math.Rand(150, 300) )
			particle:SetDieTime(math.Rand(self.Duration, self.Duration * 1.25))
			particle:SetStartAlpha(math.Rand( 116, 216 ))
			particle:SetEndAlpha(0)
			particle:SetStartSize(116)
			particle:SetEndSize(216)
			particle:SetRoll(math.Rand(0, 360) )
			particle:SetRollDelta(math.Rand(-1, 1) / 3)
			particle:SetColor(95, 125, 60)
			particle:SetAirResistance(82)
			particle:SetCollide(true)
			particle:SetBounce(1)
		end
	end
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()

end
--lua/effects/tfa_muzzleflash_fubar_aq/init.lua:
local function rvec(vec)
	vec.x=math.Round(vec.x)
	vec.y=math.Round(vec.y)
	vec.z=math.Round(vec.z)
	return vec
end

local blankvec = Vector(0,0,0)

local function partfunc(self)
	if IsValid(self.FollowEnt) then
		if self.Att then
			local angpos = self.FollowEnt:GetAttachment(self.Att)
			if angpos and angpos.Pos then
				self:SetPos(angpos.Pos)
				self:SetNextThink(CurTime())
			end
		end
	end
end
				
function EFFECT:Init( data )
	
	self.StartPacket = data:GetStart()
	self.Attachment = data:GetAttachment()

	local AddVel = vector_origin
	
	if LocalPlayer then
		if IsValid(LocalPlayer()) then
			AddVel = LocalPlayer():GetVelocity()
		end
	end
	
	if AddVel == vector_origin then
		AddVel = Entity(1):GetVelocity()
	end
	
	self.Position = data:GetOrigin()
	self.Forward = data:GetNormal()
	self.Angle = self.Forward:Angle()
	self.Right = self.Angle:Right()
	
	local wepent = Entity(math.Round(self.StartPacket.z))
	
	if IsValid(wepent) then
		if wepent.IsFirstPerson and !wepent:IsFirstPerson() then
			data:SetEntity(wepent)
			self.Position = blankvec
		end
	end
	
	local ownerent = player.GetByID(math.Round(self.StartPacket.x))
	local serverside = false
	if math.Round(self.StartPacket.y)==1 then
		serverside = true
	end
	
	local ent = data:GetEntity()
	
	if serverside then
		if IsValid(ownerent) then
			if LocalPlayer() == ownerent then
				return
			end
			ent = ownerent:GetActiveWeapon()
			AddVel = ownerent:GetVelocity()
		end
	end
	
	if (!self.Position) or ( rvec(self.Position) == blankvec ) then
		self.WeaponEnt = data:GetEntity()
		self.Attachment = data:GetAttachment()
		if self.WeaponEnt and IsValid(self.WeaponEnt) then
			local rpos = self.WeaponEnt:GetAttachment(self.Attachment)
			if rpos and rpos.Pos then
				self.Position = rpos.Pos
				if data:GetNormal()==vector_origin then
					self.Forward = rpos.Ang:Up()
					self.Angle = self.Forward:Angle()
					self.Right = self.Angle:Right()
				end
			end
		end
	end
	
	self.vOffset = self.Position
	dir = self.Forward
	AddVel = AddVel * 0.05

	if IsValid(ent) then
		dlight = DynamicLight(ent:EntIndex())
	else
		dlight = DynamicLight(0)	
	end
	
    if (dlight) then
        dlight.Pos              = self.Position + dir * 1 - dir:Angle():Right()*5
        dlight.r                = 0
        dlight.g                = 109
        dlight.b                = 255
        dlight.Brightness = 7.0
        dlight.size     = 128+24
        dlight.DieTime  = CurTime() + 0.03
   end
	
	ParticleEffectAttach("tfa_muzzle_fubar_aq",PATTACH_POINT_FOLLOW,ent,data:GetAttachment())
	
	--[[
	local emitter = ParticleEmitter( self.vOffset )
		for i=0, 6 do
			local particle = emitter:Add( "particles/flamelet"..math.random(1,5), self.vOffset + (dir * 1.7 * i))
			if (particle) then
				particle:SetVelocity((dir * 19 * i) + 1.05 * AddVel )
				particle:SetLifeTime( 0 )
				particle:SetDieTime( 0.1 )
				particle:SetStartAlpha( math.Rand( 200, 255 ) )
				particle:SetEndAlpha( 0 )
				particle:SetStartSize( math.max(7 - 0.65 * i,1) )
				particle:SetEndSize( 0 )
				particle:SetRoll( math.Rand(0, 360) )
				particle:SetRollDelta( math.Rand(-40, 40) )
				particle:SetColor( 255 , 218 , 97 )
				particle:SetLighting(false)
				particle.FollowEnt = data:GetEntity()
				particle.Att = self.Attachment
				particle:SetThinkFunction( partfunc )
				particle:SetNextThink(CurTime())
			end
		end
		
		for i=0, 5 do
		
			local particle = emitter:Add( "particles/smokey", self.vOffset + dir * math.Rand(6, 10 ))
			if (particle) then
				particle:SetVelocity(VectorRand() * 5 + dir * math.Rand(27,33) + 1.05 * AddVel )
				particle:SetLifeTime( 0 )
				particle:SetDieTime( math.Rand( 0.5, 0.5 ) )
				particle:SetStartAlpha( math.Rand( 5, 15 ) )
				particle:SetEndAlpha( 0 )
				particle:SetStartSize( math.Rand(8,10) )
				particle:SetEndSize( math.Rand(2,5) )
				particle:SetRoll( math.Rand(0, 360) )
				particle:SetRollDelta( math.Rand(-0.8, 0.8) )
				
				particle:SetAirResistance( 10 ) 
 				 
 				particle:SetGravity( Vector( 0, 0, 60 ) ) 
				
				particle:SetColor( 255 , 255 , 255 ) 
			end
			
		end
		
		if GetTFAGasEnabled() then
			for i=0, 2 do
				local particle = emitter:Add( "sprites/heatwave", self.vOffset + (dir * i) )
				if (particle) then
					particle:SetVelocity((dir * 25 * i) + 1.05 * AddVel )
					particle:SetLifeTime( 0 )
					particle:SetDieTime( math.Rand( 0.05, 0.15 ) )
					particle:SetStartAlpha( math.Rand( 200, 225 ) )
					particle:SetEndAlpha( 0 )
					particle:SetStartSize( math.Rand(3,5) )
					particle:SetEndSize( math.Rand(8,10) )
					particle:SetRoll( math.Rand(0, 360) )
					particle:SetRollDelta( math.Rand(-2, 2) )
					
					particle:SetAirResistance( 5 ) 
					
					particle.FollowEnt = data:GetEntity()
					particle.Att = self.Attachment
					particle:SetThinkFunction( partfunc )
					 
					particle:SetGravity( Vector( 0, 0, 40 ) ) 
					
					particle:SetColor( 255 , 255 , 255 ) 
				end
			end
		end
		
	emitter:Finish() 
	]]--
end 

function EFFECT:Think( )
	return false
end

function EFFECT:Render()
end

 
--addons/tfa_base/lua/effects/tfa_muzzleflash_generic/init.lua:
include("tfa/muzzleflash_base.lua")

EFFECT.Life = 0.075
EFFECT.XFlashSize = 0.5
EFFECT.FlashSize = 0.8
EFFECT.SmokeSize = 1
EFFECT.SparkSize = 1
EFFECT.HeatSize = 1
EFFECT.Color = Color(255, 225, 128)
EFFECT.ColorSprites = false

--addons/tfa_base/lua/tfa/muzzleflash_base.lua:
local vector_origin = Vector()

EFFECT.Life = 0.1
EFFECT.XFlashSize = 1
EFFECT.FlashSize = 1
EFFECT.SmokeSize = 1
EFFECT.SparkSize = 1
EFFECT.HeatSize = 1
EFFECT.Color = Color(255, 192, 64)
EFFECT.ColorSprites = false

local AddVel = Vector()
local ang

function EFFECT:Init(data)
	self.WeaponEnt = data:GetEntity()
	if not IsValid(self.WeaponEnt) then return end
	self.Attachment = data:GetAttachment()
	self.Position = self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)

	if IsValid(self.WeaponEnt:GetOwner()) then
		if self.WeaponEnt:GetOwner() == LocalPlayer() then
			if self.WeaponEnt:GetOwner():ShouldDrawLocalPlayer() then
				ang = self.WeaponEnt:GetOwner():EyeAngles()
				ang:Normalize()
				--ang.p = math.max(math.min(ang.p,55),-55)
				self.Forward = ang:Forward()
			else
				self.WeaponEnt = self.WeaponEnt.OwnerViewModel
			end
			--ang.p = math.max(math.min(ang.p,55),-55)
		else
			ang = self.WeaponEnt:GetOwner():EyeAngles()
			ang:Normalize()
			self.Forward = ang:Forward()
		end
	end

	self.Forward = self.Forward or data:GetNormal()
	self.Angle = self.Forward:Angle()
	self.Right = self.Angle:Right()
	self.vOffset = self.Position
	local dir = self.Forward
	local ownerent = self.WeaponEnt:GetOwner()

	if not IsValid(ownerent) then
		ownerent = LocalPlayer()
	end

	AddVel = ownerent:GetVelocity()
	self.vOffset = self.Position
	AddVel = AddVel * 0.05
	local dot = dir:GetNormalized():Dot(GetViewEntity():EyeAngles():Forward())
	local halofac = math.abs(dot)
	local epos = ownerent:EyePos()
	local dlight = DynamicLight(ownerent:EntIndex())

	if (dlight) then
		dlight.pos = epos + ownerent:EyeAngles():Forward() * self.vOffset:Distance(epos) --self.vOffset - ownerent:EyeAngles():Right() * 5 + 1.05 * ownerent:GetVelocity() * FrameTime()
		dlight.r = self.Color.r
		dlight.g = self.Color.g
		dlight.b = self.Color.b
		dlight.brightness = 4.5
		dlight.decay = 200 / self.Life
		dlight.size = self.FlashSize * 96
		dlight.dietime = CurTime() + self.Life
	end

	self.Dist = self.vOffset:Distance(epos)
	self.DLight = dlight
	self.DieTime = CurTime() + self.Life
	self.OwnerEnt = ownerent
	local emitter = ParticleEmitter(self.vOffset)
	local sval = 1 - math.random(0, 1) * 2

	if self.WeaponEnt.XTick == nil then
		self.WeaponEnt.XTick = 0
	end

	self.WeaponEnt.XTick = 1 - self.WeaponEnt.XTick

	if self.WeaponEnt.XTick == 1 and self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.XFlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(3 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			particle:SetEndSize(15 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
		--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
		--particle:SetEndSize( 0 )
	elseif self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			particle:SetStartSize(2 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			particle:SetEndSize(6 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
	end

	local flashCount = math.Round(self.FlashSize * 8)

	for i = 1, flashCount do
		local particle = emitter:Add(self.ColorSprites and "effects/scotchmuzzleflashw" or "effects/scotchmuzzleflash4", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 300 * (0.2 + (i / flashCount) * 0.8) * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(math.Rand(128, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			local szsc = 1 + (flashCount - i) * math.pow(1 / flashCount * 0.9,0.8)
			particle:SetStartSize(1.25 * math.Rand(1, 1.5) * szsc * self.FlashSize)
			particle:SetEndSize(6 * math.Rand(0.75, 1) * szsc * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	for _ = 1, flashCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 6 * self.FlashSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 1)
			particle:SetStartAlpha(math.Rand(40, 140))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(2 * math.Rand(1, 1.5) * self.FlashSize)
			particle:SetEndSize(20 * math.Rand(0.5, 1) * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(30, 60)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			--TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	local glowCount = math.ceil(self.FlashSize * 3)

	for i = 1, glowCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + dir * 0.9 * i)

		if (particle) then
			--particle:SetVelocity(dir * 32 )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(255 * (1 - halofac))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.2 * self.FlashSize)
			particle:SetEndSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.6 * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	if TFA.GetMZFSmokeEnabled() then
		local smokeCount = math.ceil(self.SmokeSize * 6)

		for _ = 0, smokeCount do
			local particle = emitter:Add("particles/smokey", self.vOffset + dir * math.Rand(3, 14))

			if (particle) then
				particle:SetVelocity(VectorRand() * 10 * self.SmokeSize + dir * math.Rand(35, 50) * self.SmokeSize + 1.05 * AddVel)
				particle:SetDieTime(math.Rand(0.6, 1) * self.Life * 6)
				particle:SetStartAlpha(math.Rand(12, 24))
				particle:SetEndAlpha(0)
				particle:SetStartSize(math.Rand(5, 7) * self.SmokeSize)
				particle:SetEndSize(math.Rand(15, 20) * self.SmokeSize)
				particle:SetRoll(math.rad(math.Rand(0, 360)))
				particle:SetRollDelta(math.Rand(-0.8, 0.8))
				particle:SetLighting(true)
				particle:SetAirResistance(20)
				particle:SetGravity(Vector(0, 0, 60))
				particle:SetColor(255, 255, 255)
			end
		end
	end

	local sparkcount = math.Round(math.random(8, 12) * self.SparkSize)

	for _ = 0, sparkcount do
		local particle = emitter:Add("effects/yellowflare", self.Position)

		if (particle) then
			particle:SetVelocity( VectorRand() * 30 * self.SparkSize)
			particle:SetVelocity(particle:GetVelocity() + 1.15 * AddVel )
			particle:SetVelocity( particle:GetVelocity() + dir * math.Rand(80, 100) * (1-math.abs(math.max(particle:GetVelocity():GetNormalized():Dot(-dir),0))) * self.SparkSize )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * math.Rand(0.9,1.1))
			particle:SetStartAlpha(255)
			particle:SetEndAlpha(0)
			particle:SetStartSize(0.6)
			particle:SetEndSize(1)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetGravity(vector_origin)
			particle:SetAirResistance(1)
			particle:SetStartLength(0.1)
			particle:SetEndLength(0.05)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, math.random(192, 225), math.random(140, 192))
			end

			particle:SetVelocityScale(true)
			local sl = self.SparkSize

			particle:SetThinkFunction(function(pa)
				math.randomseed(SysTime())
				local spd = pa:GetVelocity():Length()*12
				pa.ranvel = pa.ranvel or VectorRand() * spd
				pa.ranvel:Add(VectorRand() * spd * math.sqrt(FrameTime()))
				pa:SetVelocity(pa:GetVelocity() + pa.ranvel * sl * FrameTime() )
				pa:SetNextThink(CurTime())
			end)

			particle:SetNextThink(CurTime() + 0.01)
		end
	end

	if TFA.GetGasEnabled() then
		local particle = emitter:Add("sprites/heatwave", self.vOffset + dir*2)

		if (particle) then
			particle:SetVelocity(dir * 25 * self.HeatSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life)
			particle:SetStartAlpha(math.Rand(200, 225))
			particle:SetEndAlpha(0)
			particle:SetStartSize(math.Rand(3, 5) * self.HeatSize)
			particle:SetEndSize(math.Rand(8, 12) * self.HeatSize)
			particle:SetRoll(math.Rand(0, 360))
			particle:SetRollDelta(math.Rand(-2, 2))
			particle:SetAirResistance(5)
			particle:SetGravity(Vector(0, 0, 40))
			particle:SetColor(255, 255, 255)
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	if CurTime() > (self.DieTime or 0) then
		return false
	elseif self.DLight and IsValid(self.OwnerEnt) then
		self.DLight.pos = self.OwnerEnt:EyePos() + self.OwnerEnt:EyeAngles():Forward() * self.Dist
	end

	return true
end

function EFFECT:Render()
end
--addons/tfa_base/lua/effects/tfa_muzzleflash_pistol/init.lua:
include("tfa/muzzleflash_base.lua")

EFFECT.Life = 0.07
EFFECT.XFlashSize = 0.5
EFFECT.FlashSize = 0.8
EFFECT.SmokeSize = 1
EFFECT.SparkSize = 1
EFFECT.HeatSize = 1
EFFECT.Color = Color(255, 225, 128)
EFFECT.ColorSprites = false

--addons/tfa_base/lua/tfa/muzzleflash_base.lua:
local vector_origin = Vector()

EFFECT.Life = 0.1
EFFECT.XFlashSize = 1
EFFECT.FlashSize = 1
EFFECT.SmokeSize = 1
EFFECT.SparkSize = 1
EFFECT.HeatSize = 1
EFFECT.Color = Color(255, 192, 64)
EFFECT.ColorSprites = false

local AddVel = Vector()
local ang

function EFFECT:Init(data)
	self.WeaponEnt = data:GetEntity()
	if not IsValid(self.WeaponEnt) then return end
	self.Attachment = data:GetAttachment()
	self.Position = self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)

	if IsValid(self.WeaponEnt:GetOwner()) then
		if self.WeaponEnt:GetOwner() == LocalPlayer() then
			if self.WeaponEnt:GetOwner():ShouldDrawLocalPlayer() then
				ang = self.WeaponEnt:GetOwner():EyeAngles()
				ang:Normalize()
				--ang.p = math.max(math.min(ang.p,55),-55)
				self.Forward = ang:Forward()
			else
				self.WeaponEnt = self.WeaponEnt.OwnerViewModel
			end
			--ang.p = math.max(math.min(ang.p,55),-55)
		else
			ang = self.WeaponEnt:GetOwner():EyeAngles()
			ang:Normalize()
			self.Forward = ang:Forward()
		end
	end

	self.Forward = self.Forward or data:GetNormal()
	self.Angle = self.Forward:Angle()
	self.Right = self.Angle:Right()
	self.vOffset = self.Position
	local dir = self.Forward
	local ownerent = self.WeaponEnt:GetOwner()

	if not IsValid(ownerent) then
		ownerent = LocalPlayer()
	end

	AddVel = ownerent:GetVelocity()
	self.vOffset = self.Position
	AddVel = AddVel * 0.05
	local dot = dir:GetNormalized():Dot(GetViewEntity():EyeAngles():Forward())
	local halofac = math.abs(dot)
	local epos = ownerent:EyePos()
	local dlight = DynamicLight(ownerent:EntIndex())

	if (dlight) then
		dlight.pos = epos + ownerent:EyeAngles():Forward() * self.vOffset:Distance(epos) --self.vOffset - ownerent:EyeAngles():Right() * 5 + 1.05 * ownerent:GetVelocity() * FrameTime()
		dlight.r = self.Color.r
		dlight.g = self.Color.g
		dlight.b = self.Color.b
		dlight.brightness = 4.5
		dlight.decay = 200 / self.Life
		dlight.size = self.FlashSize * 96
		dlight.dietime = CurTime() + self.Life
	end

	self.Dist = self.vOffset:Distance(epos)
	self.DLight = dlight
	self.DieTime = CurTime() + self.Life
	self.OwnerEnt = ownerent
	local emitter = ParticleEmitter(self.vOffset)
	local sval = 1 - math.random(0, 1) * 2

	if self.WeaponEnt.XTick == nil then
		self.WeaponEnt.XTick = 0
	end

	self.WeaponEnt.XTick = 1 - self.WeaponEnt.XTick

	if self.WeaponEnt.XTick == 1 and self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.XFlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(3 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			particle:SetEndSize(15 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
		--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
		--particle:SetEndSize( 0 )
	elseif self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			particle:SetStartSize(2 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			particle:SetEndSize(6 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
	end

	local flashCount = math.Round(self.FlashSize * 8)

	for i = 1, flashCount do
		local particle = emitter:Add(self.ColorSprites and "effects/scotchmuzzleflashw" or "effects/scotchmuzzleflash4", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 300 * (0.2 + (i / flashCount) * 0.8) * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(math.Rand(128, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			local szsc = 1 + (flashCount - i) * math.pow(1 / flashCount * 0.9,0.8)
			particle:SetStartSize(1.25 * math.Rand(1, 1.5) * szsc * self.FlashSize)
			particle:SetEndSize(6 * math.Rand(0.75, 1) * szsc * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	for _ = 1, flashCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 6 * self.FlashSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 1)
			particle:SetStartAlpha(math.Rand(40, 140))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(2 * math.Rand(1, 1.5) * self.FlashSize)
			particle:SetEndSize(20 * math.Rand(0.5, 1) * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(30, 60)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			--TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	local glowCount = math.ceil(self.FlashSize * 3)

	for i = 1, glowCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + dir * 0.9 * i)

		if (particle) then
			--particle:SetVelocity(dir * 32 )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(255 * (1 - halofac))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.2 * self.FlashSize)
			particle:SetEndSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.6 * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	if TFA.GetMZFSmokeEnabled() then
		local smokeCount = math.ceil(self.SmokeSize * 6)

		for _ = 0, smokeCount do
			local particle = emitter:Add("particles/smokey", self.vOffset + dir * math.Rand(3, 14))

			if (particle) then
				particle:SetVelocity(VectorRand() * 10 * self.SmokeSize + dir * math.Rand(35, 50) * self.SmokeSize + 1.05 * AddVel)
				particle:SetDieTime(math.Rand(0.6, 1) * self.Life * 6)
				particle:SetStartAlpha(math.Rand(12, 24))
				particle:SetEndAlpha(0)
				particle:SetStartSize(math.Rand(5, 7) * self.SmokeSize)
				particle:SetEndSize(math.Rand(15, 20) * self.SmokeSize)
				particle:SetRoll(math.rad(math.Rand(0, 360)))
				particle:SetRollDelta(math.Rand(-0.8, 0.8))
				particle:SetLighting(true)
				particle:SetAirResistance(20)
				particle:SetGravity(Vector(0, 0, 60))
				particle:SetColor(255, 255, 255)
			end
		end
	end

	local sparkcount = math.Round(math.random(8, 12) * self.SparkSize)

	for _ = 0, sparkcount do
		local particle = emitter:Add("effects/yellowflare", self.Position)

		if (particle) then
			particle:SetVelocity( VectorRand() * 30 * self.SparkSize)
			particle:SetVelocity(particle:GetVelocity() + 1.15 * AddVel )
			particle:SetVelocity( particle:GetVelocity() + dir * math.Rand(80, 100) * (1-math.abs(math.max(particle:GetVelocity():GetNormalized():Dot(-dir),0))) * self.SparkSize )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * math.Rand(0.9,1.1))
			particle:SetStartAlpha(255)
			particle:SetEndAlpha(0)
			particle:SetStartSize(0.6)
			particle:SetEndSize(1)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetGravity(vector_origin)
			particle:SetAirResistance(1)
			particle:SetStartLength(0.1)
			particle:SetEndLength(0.05)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, math.random(192, 225), math.random(140, 192))
			end

			particle:SetVelocityScale(true)
			local sl = self.SparkSize

			particle:SetThinkFunction(function(pa)
				math.randomseed(SysTime())
				local spd = pa:GetVelocity():Length()*12
				pa.ranvel = pa.ranvel or VectorRand() * spd
				pa.ranvel:Add(VectorRand() * spd * math.sqrt(FrameTime()))
				pa:SetVelocity(pa:GetVelocity() + pa.ranvel * sl * FrameTime() )
				pa:SetNextThink(CurTime())
			end)

			particle:SetNextThink(CurTime() + 0.01)
		end
	end

	if TFA.GetGasEnabled() then
		local particle = emitter:Add("sprites/heatwave", self.vOffset + dir*2)

		if (particle) then
			particle:SetVelocity(dir * 25 * self.HeatSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life)
			particle:SetStartAlpha(math.Rand(200, 225))
			particle:SetEndAlpha(0)
			particle:SetStartSize(math.Rand(3, 5) * self.HeatSize)
			particle:SetEndSize(math.Rand(8, 12) * self.HeatSize)
			particle:SetRoll(math.Rand(0, 360))
			particle:SetRollDelta(math.Rand(-2, 2))
			particle:SetAirResistance(5)
			particle:SetGravity(Vector(0, 0, 40))
			particle:SetColor(255, 255, 255)
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	if CurTime() > (self.DieTime or 0) then
		return false
	elseif self.DLight and IsValid(self.OwnerEnt) then
		self.DLight.pos = self.OwnerEnt:EyePos() + self.OwnerEnt:EyeAngles():Forward() * self.Dist
	end

	return true
end

function EFFECT:Render()
end
--addons/tfa_base/lua/effects/tfa_muzzleflash_smg/init.lua:
include("tfa/muzzleflash_base.lua")

EFFECT.Life = 0.075
EFFECT.XFlashSize = 1
EFFECT.FlashSize = 1
EFFECT.SmokeSize = 1
EFFECT.SparkSize = 1
EFFECT.HeatSize = 1
EFFECT.Color = Color(255, 225, 128)
EFFECT.ColorSprites = false

--lua/effects/tfa_tracer_fubar_light/init.lua:
TRACER_FLAG_USEATTACHMENT       = 0x0002;
SOUND_FROM_WORLD                        = 0;
CHAN_STATIC                                     = 6;

EFFECT.InValid = false;

function EFFECT:Init( data )	

		self.Position = data:GetStart()
		self.WeaponEnt = data:GetEntity()
		self.Attachment = data:GetAttachment()
		
		-- Keep the start and end pos - we're going to interpolate between them
		self.StartPos = self:GetTracerShootPos( self.Position, self.WeaponEnt, self.Attachment )
		
        self.EndPos = data:GetOrigin()
		
        util.ParticleTracerEx("weapon_fubar_beam", self.StartPos, self.EndPos, false, self:EntIndex(), self.Attachment)

end

function EFFECT:Think()
 
        return false
 
end

function EFFECT:Render()
		
		if self.InValid then return false end
		
end
--addons/tfa_base/lua/effects/tfa_tracer_incendiary/init.lua:
EFFECT.Mat = Material("effects/laser_tracer")
EFFECT.Col1 = Color(255, 90, 25, 200) --Color(225,225,225,225)
EFFECT.Col2 = Color(225, 25, 25, 200)
EFFECT.Speed = 8192
EFFECT.TracerLength = 128

--[[---------------------------------------------------------
Init( data table )
-----------------------------------------------------------]]
function EFFECT:Init(data)
	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()

	if IsValid(self.WeaponEnt) and self.WeaponEnt.GetMuzzleAttachment then
		self.Attachment = self.WeaponEnt:GetMuzzleAttachment()
	end

	-- Keep the start and end pos - we're going to interpolate between them
	self.StartPos = self:GetTracerShootPos(self.Position, self.WeaponEnt, self.Attachment)
	self.EndPos = data:GetOrigin()
	self.Normal = (self.EndPos - self.StartPos):GetNormalized()
	self.Length = (self.EndPos - self.StartPos):Length()
	--self.Alpha = 255
	self.Life = 0
	self.MaxLife = self.Length / self.Speed
	self:SetRenderBoundsWS(self.StartPos, self.EndPos)
	self.CurPos = self.StartPos
end

--[[---------------------------------------------------------
THINK
-----------------------------------------------------------]]
function EFFECT:Think()
	self.Life = self.Life + FrameTime() * (1 / self.MaxLife)
	--self.Alpha = 255 * ( 1 - self.Life )

	return self.Life < 1
end

--[[---------------------------------------------------------
Draw the effect
-----------------------------------------------------------]]
local lerpedcol = Color(225, 225, 225, 225)

function EFFECT:Render()
	render.SetMaterial(self.Mat)
	lerpedcol.r = Lerp(self.Life, self.Col1.r, self.Col2.r)
	lerpedcol.g = Lerp(self.Life, self.Col1.g, self.Col2.g)
	lerpedcol.b = Lerp(self.Life, self.Col1.b, self.Col2.b)
	lerpedcol.a = Lerp(self.Life, self.Col1.a, self.Col2.a)
	local startbeampos = Lerp(self.Life, self.StartPos, self.EndPos)
	local endbeampos = Lerp(self.Life + self.TracerLength / self.Length, self.StartPos, self.EndPos)
	render.DrawBeam(startbeampos, endbeampos, 8, 0, 1, lerpedcol)
end

--addons/vanilla-tools/lua/effects/vanilla_ship_explosion/init.lua:


local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	local Pos = data:GetOrigin()
	local Scale = data:GetScale()

	self.DieTime = CurTime() + 1

	self:Explosion( Pos, 2 )

	for i = 1, 20 do
		timer.Simple(math.Rand(0,0.01) * i, function()
			if IsValid( self ) then
				local p = Pos + VectorRand() * 10 * i

				self:Explosion( p, Scale )
			end
		end)
	end

	self:Debris( Pos )
end

function EFFECT:Debris( pos )
	local emitter = ParticleEmitter( pos, false )

	for i = 0,60 do
		local particle = emitter:Add( "effects/fleck_tile"..math.random(1,2), pos )
		local vel = VectorRand() * math.Rand(200,600)
		vel.z = math.Rand(200,600)
		if particle then
			particle:SetVelocity( vel )
			particle:SetDieTime( math.Rand(10,15) )
			particle:SetAirResistance( 10 )
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 5 )
			particle:SetEndSize( 5 )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( 0,0,0 )
			particle:SetGravity( Vector( 0, 0, -600 ) )
			particle:SetCollide( true )
			particle:SetBounce( 0.3 )
		end
	end

	emitter:Finish()
end

function EFFECT:Explosion( pos , scale )
	local emitter = ParticleEmitter( pos, false )

	if emitter then
		for i = 0,10 do
			local particle = emitter:Add( Materials[math.random(1,table.Count( Materials ))], pos )

			if particle then
				particle:SetVelocity( VectorRand() * 1000 * scale )
				particle:SetDieTime( math.Rand(0.75,1.5) * 4)
				particle:SetAirResistance( math.Rand(200,600) )
				particle:SetStartAlpha( 255 )
				particle:SetStartSize( math.Rand(60,120) * scale )
				particle:SetEndSize( math.Rand(160,280) * scale )
				particle:SetRoll( math.Rand(-1,1) )
				particle:SetColor( 40,40,40 )
				particle:SetGravity( Vector( 0, 0, 100 ) )
				particle:SetCollide( false )
			end
		end

		for i = 0, 40 do
			local particle = emitter:Add( "particles/flamelet"..math.random(1,5), pos )

			if particle then
				particle:SetVelocity( VectorRand() * 1000 * scale )
				particle:SetDieTime( 0.14 )
				particle:SetStartAlpha( 255 )
				particle:SetStartSize( 10 * scale )
				particle:SetEndSize( math.Rand(60,120) * scale )
				particle:SetEndAlpha( 100 )
				particle:SetRoll( math.Rand( -1, 1 ) )
				particle:SetColor( 200,150,150 )
				particle:SetCollide( false )
			end
		end

		emitter:Finish()
	end

	local dlight = DynamicLight( math.random(0,9999) )
	if dlight then
		dlight.pos = pos
		dlight.r = 255
		dlight.g = 180
		dlight.b = 100
		dlight.brightness = 8
		dlight.Decay = 2000
		dlight.Size = 300
		dlight.DieTime = CurTime() + 1
	end
end

function EFFECT:Think()
	if CurTime() < self.DieTime then return true end

	return false
end

function EFFECT:Render()
end

--addons/wos-alcs-darkaspp/lua/effects/wos_alcs_diamondstorm/init.lua:

function EFFECT:Init( data )

	local ent = data:GetEntity()
	local time = data:GetScale()

	self.Time = time
	
	self.ClientProp = ClientsideModel( "models/effects/splodeglass.mdl" )
	self.ClientProp:SetPos( ent:GetPos() )
	self.ClientProp:SetModelScale( 0.01 )
	
	self.LifeTime = CurTime() + time
	self.CallEnt = ent
end

function EFFECT:Think()
	if not self.CallEnt then return false end
	if self.LifeTime < CurTime() + self.Time*0.35 then
		self.ClientProp:SetPos( self.ClientProp:GetPos() + self.CallEnt:GetAimVector()*40 )
		if self.LifeTime < CurTime() then
			self.ClientProp:Remove()
			self:Remove()
		end
	else
		self.ClientProp:SetModelScale( math.min( 0.3, self.ClientProp:GetModelScale() + 0.3/self.Time*10*FrameTime() ) )
	end
	return true
end

function EFFECT:Render()
end

--addons/wos-alcs-darkaspp/lua/effects/wos_alcs_poisontouch/init.lua:

PrecacheParticleSystem( "[2]gushing_blood_alien" )

function EFFECT:Init( data )

	local ent = data:GetEntity()
	
	self.Particle = CreateParticleSystem( ent, "[2]gushing_blood_alien", PATTACH_ABSORIGIN_FOLLOW, nil, ent:GetUp()*40 ) 
	self.LifeTime = CurTime() + 0.3
	
end

function EFFECT:Think()
	if self.LifeTime < CurTime() then
		self.Particle:StopEmission( false, true )
		return false
	end
	return true
end

function EFFECT:Render()
end

--addons/wos-grandmaster-einf/lua/effects/wos_gore_explosion/init.lua:


function EFFECT:Init( data )

	self.DieTime = CurTime() + 1.5
	
	local pos = data:GetOrigin() + Vector(0,0,50)
	local emitter = ParticleEmitter( pos )
	
	local particle = emitter:Add( "effects/blood_core", pos )
	particle:SetDieTime( math.Rand( 0.5, 1.0 ) )
	particle:SetStartAlpha( 255 )
	particle:SetEndAlpha( 0 )
	particle:SetStartSize( 10 )
	particle:SetEndSize( math.random( 150, 200 ) )
	particle:SetRoll( math.Rand( -360, 360 ) )
	particle:SetColor( 50, 0, 0 )
	
	local particle = emitter:Add( "effects/blood_core", pos )
	particle:SetDieTime( math.Rand( 6.0, 8.0 ) )
	particle:SetStartAlpha( 50 )
	particle:SetEndAlpha( 0 )
	particle:SetStartSize( math.random( 100, 250 ) )
	particle:SetEndSize( 200 )
	particle:SetRoll( math.Rand( -360, 360 ) )
	particle:SetColor( 50, 0, 0 )
	particle:SetGravity( Vector( 0, 0, -5 ) )
	
	for i=1, math.random(4,8) do
	
		local particle = emitter:Add( "effects/blood", pos )
		particle:SetVelocity( VectorRand() * 100 + Vector(0,math.random(-25,25),50) )
		particle:SetDieTime( 1.0 )
		particle:SetStartAlpha( 255 )
		particle:SetEndAlpha( 0 )
		particle:SetStartSize( math.random( 20, 40 ) )
		particle:SetEndSize( math.random( 50, 150 ) )
		particle:SetRoll( math.Rand( -360, 360 ) )
		particle:SetColor( 50, 0, 0 )
		particle:SetGravity( Vector( 0, 0, -300 ) )
	
	end
	
	for i=1, 12 do
	
		local vec = VectorRand()
		vec.z = math.Rand( -0.2, 1.0 )
	
		local particle = emitter:Add( "effects/blood", pos )
		particle:SetVelocity( vec * 250 + Vector(0,0,50) )
		particle:SetDieTime( math.Rand( 0.8, 1.0 ) )
		particle:SetStartAlpha( 200 )
		particle:SetEndAlpha( 0 )
		particle:SetStartSize( math.random( 10, 20 ) )
		particle:SetEndSize( math.random( 50, 100 ) )
		particle:SetRoll( math.Rand( -360, 360 ) )
		particle:SetColor( 50, 0, 0 )
		particle:SetGravity( Vector( 0, 0, -300 ) )
	
	end
	
	for i=1, math.random(3,6) do
	
		local vec = VectorRand()
		vec.z = math.Rand( -0.2, 1.0 )
	
		local particle = emitter:Add( "effects/blood", pos + Vector(0,0,math.random(-10,10)) )
		particle:SetVelocity( vec * 300 )
		particle:SetLifeTime( 0 )
		particle:SetDieTime( math.Rand( 2.0, 4.0 ) )
		particle:SetStartAlpha( 255 )
		particle:SetEndAlpha( 255 )
		particle:SetStartSize( math.random( 8, 12 ) )
		particle:SetEndSize( 1 )
		particle:SetRoll( math.Rand( -360, 360 ) )
		particle:SetColor( 40, 0, 0 )
		
		particle:SetGravity( Vector( 0, 0, -500 ) )
		particle:SetCollide( true )
		particle:SetBounce( 0.5 )
		
		particle:SetCollideCallback( function( part, pos, normal )
   
			util.Decal( "Blood", pos + normal, pos - normal )
   
		end )
	
	end

	emitter:Finish()
	
	for i=1, 20 do
		local ed = EffectData()
		ed:SetOrigin( pos + Vector(0,0,math.random(0,30)) )
		if i < 8 then
			ed:SetScale( 1 )
		else
			ed:SetScale( 2 )
		end
		util.Effect( "wos_exec_playergib", ed, true, true )
	end	self.SoundTime = CurTime() + math.Rand( 0.2, 0.6 )
end

function EFFECT:Think( )
	if self.SoundTime < CurTime() then		self:EmitSound( table.Random( wOS.ALCS.ExecSys.SplatSounds ), 100, math.random(90,110) )		self.SoundTime = CurTime() + math.Rand( 0.2, 0.6 )	end
	return self.DieTime > CurTime()
	
end

function EFFECT:Render()
	
end

--addons/wos-alcs-icefusepp/lua/effects/wos_group_lightning.lua:

local function GetRandomPositionInBox( mins, maxs, ang )
	return ang:Up() * math.random( mins.z, maxs.z ) + ang:Right() * math.random( mins.y, maxs.y ) + ang:Forward() * math.random( mins.x, maxs.x )
end

local function GenerateLighting( from, to, deviations, power )
	local start = from
	if ( isentity( start ) ) then start = from:GetPos() end
	local endpos = to:GetPos()
	local wep = to:GetActiveWeapon() 

	--render.DrawWireframeBox( start, Angle(0, 0, 0),from:OBBMins(), from:OBBMaxs(), Color(255, 0, 0), true )
	--render.DrawWireframeBox( start, to:GetAngles(),from:OBBMins(), from:OBBMaxs(), Color(0, 255, 0), true )

	--start = start + GetRandomPositionInBox( from:OBBMins(), from:OBBMaxs(), from:GetAngles() )
	endpos = endpos + GetRandomPositionInBox( to:OBBMins(), to:OBBMaxs(), to:GetAngles() )
	if to:GetNWFloat( "BlockTime", 0 ) >= CurTime() then
		if IsValid( wep ) then
			if wep.IsLightsaber then
				local len = wep:GetMaxLength()
				local pos, dir = wep:GetSaberPosAng()
				endpos = wep:GetSaberPosAng() + dir*len/2
			end
		end
	end
	
	local right = (start - endpos):Angle():Right()
	local up = (start - endpos):Angle():Up()
	local segments = {
		{ start, endpos }
	}
	for i = 0, power do
		local newsegs = {}
		for id, seg in pairs( segments ) do
			local mid = Vector( (seg[1].x + seg[2].x) / 2, (seg[1].y + seg[2].y) / 2, (seg[1].z + seg[2].z) / 2 )
			local offsetpos = mid + right * math.random( -deviations, deviations ) + up * math.random( -deviations, deviations )
			table.insert( newsegs, {seg[1], offsetpos} )
			table.insert( newsegs, {offsetpos, seg[2]} )
		end
		segments = newsegs
	end
	return segments
end

local function GenerateLightingSegs( from, to, deviations, segs )
	local start = from
	if ( isentity( start ) ) then start = from:GetPos() end
	local endpos = to:GetPos()

	--render.DrawWireframeBox( start, Angle(0, 0, 0),from:OBBMins(), from:OBBMaxs(), Color(255, 0, 0), true )
	--render.DrawWireframeBox( start, to:GetAngles(),from:OBBMins(), from:OBBMaxs(), Color(0, 255, 0), true )

	--start = start + GetRandomPositionInBox( from:OBBMins(), from:OBBMaxs(), from:GetAngles() )
	endpos = endpos + GetRandomPositionInBox( to:OBBMins(), to:OBBMaxs(), to:GetAngles() )

	local right = (start - endpos):Angle():Right()
	local up = (start - endpos):Angle():Up()
	local fwd = (start - endpos):Angle():Forward()
	local step = (1 / segs) * start:Distance( endpos )

	local lastpos = start
	local segments = {}
	for i = 1, segs do
		local a = lastpos - fwd * step
		table.insert( segments, { lastpos, a } )
		lastpos = a
	end

	for k, v in pairs( segments ) do
		if ( k == 1 || k == #segments ) then continue end

		segments[ k ][ 1 ] = segments[ k ][ 1 ] + right * math.random( -deviations, deviations ) + up * math.random( -deviations, deviations )
		segments[ k - 1 ][ 2 ] = segments[ k ][ 1 ]
	end

	for k, v in pairs( segments ) do
		if ( k == 1 || k == #segments ) then continue end

		if ( math.random( 0, 100 ) > 75 ) then
			local dir = AngleRand():Forward()
			table.insert( segments, { segments[ k ][ 1 ], segments[ k ][ 1 ] + dir * ( step * math.Rand( 0.2, 0.6 ) ) } )
		end
	end

	return segments
end

local mats = {
	(Material( "cable/xbeam" )),
	/*(Material( "cable/hydra" )),
	(Material( "cable/redlaser" )),
	(Material( "cable/crystal_beam1" )),
	(Material( "cable/physbeam" )),
	(Material( "cable/smoke" )),
	(Material( "cable/xbeam" )),*/
}

local segments = {}
--local n = 0
local tiem = .2
hook.Add( "PostDrawTranslucentRenderables", "wOS.GroupLightningDrawShit", function()
	--if ( #segments < 1 || n < CurTime() ) then
		--
		/*for i = 0, 1 do
			table.insert( segments, {
				segs = GenerateLighting( table.Random( ents.FindByClass( "prop_physics" ) ), table.Random( ents.FindByClass( "prop_physics" ) ), math.random( 10, 20 ), 3 ),
				mat = table.Random( mats ),
				time = CurTime() + tiem,
				w = math.random( 20, 50 )
			} )
		end*/
		--n = CurTime() + .01
	--end

	for id, t in pairs( segments ) do
		if ( t.time < CurTime() ) then table.remove( segments, id ) continue end
		render.SetMaterial( t.mat )
		for id, seg in pairs( t.segs ) do
			render.DrawBeam( seg[1], seg[2], ( math.max( t.startpos:Distance( t.endpos ) - seg[1]:Distance( t.endpos ), 20) / ( t.startpos:Distance( t.endpos ) ) * t.w ) * ( (t.time - CurTime() ) / tiem ), 0, seg[1]:Distance( seg[2] ) / 25, Color( 255, 0, 0, 255 ) )
			--render.DrawBeam( seg[1], seg[2], (id / #t.segs * t.w ) * ((t.time - CurTime()) / tiem), 0, seg[1]:Distance( seg[2] ) / 25, Color( 255, 255, 255 ) )
		end
	end
end )


function EFFECT:Init( data )
	local pos = data:GetOrigin()
	local ent = data:GetEntity()

	if ( !IsValid( ent ) ) then return end

	table.insert( segments, {
		--segs = GenerateLighting( pos, ent, math.random( 10, 20 ), 3 ),
		segs = GenerateLightingSegs( pos, ent, math.random( 10, 20 ), pos:Distance( ent:GetPos() ) / 48 ), --math.random( 5, 10 ) ),
		mat = table.Random( mats ),
		time = CurTime() + tiem,
		w = math.random( 20, 50 ),
		startpos = pos,
		endpos = ent:GetPos()
	} )
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
	/*for id, t in pairs( segments ) do
		if (t.time < CurTime() ) then table.remove( segments, id ) continue end
		render.SetMaterial( t.mat )
		for id, seg in pairs( t.segs ) do
			render.DrawBeam( seg[1], seg[2], (id / #t.segs * t.w ) * ((t.time - CurTime()) / tiem), 0, seg[1]:Distance( seg[2] ) / 25, Color( 255, 255, 255 ) )
		end
	end*/
end

--gamemodes/starwarsrp/gamemode/config/gamemode.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
---------------------------------------
--          Gamemode config          --
---------------------------------------

-- Servername, used to display servername in frame.
Config.Servername = "Einfach Gaming Roleplay"

-- Gamemode prefix, used for chat and log messages.
Config.Prefix = "CW:RP"

-- The color used when displaying the gamemode prefix (e.g in chat).
Config.PrefixColor = Color(255, 0, 0)

-- Language set for localization.
-- Current values: "en" English | "de" German | "fr" French
Config.Language = "de"

-- Specifies the log level.
-- 0 = debug - Log everything
-- 1 = info - Log information, warnings and errors to console.
-- 2 = warning - Only log warnings and errors to console.
-- 3 = error - Only log errors
Config.LogLevel = 3

-- Background Modules
Config.Modules["developer"] = true
Config.Modules["familyshare"] = true
Config.Modules["hostname"] = true

-- Util Modules
Config.Modules["afk"] = true
Config.Modules["compass"] = true
Config.Modules["donator"] = true
Config.Modules["escapescreen"] = true
Config.Modules["instructor"] = true
Config.Modules["interact"] = true
Config.Modules["realism"] = true
Config.Modules["thirdperson"] = true

Config.Modules["permaprops"] = true
Config.Modules["signs"] = true

-- Multiserver Support
Config.Modules["socket"] = true
Config.Modules["multiserver"] = true

-- Character Modules
Config.Modules["bodygroups"] = true
Config.Modules["spawnpoints"] = true

Config.Modules["course"] = true
Config.Modules["special_character"] = true
Config.Modules["extrarank"] = true

Config.Modules["bonemerge"] = true
Config.Modules["species"] = true

Config.Modules["activity"] = false
Config.Modules["reports"] = true

Config.Modules["inventory"] = true
Config.Modules["inventory_storage"] = true
Config.Modules["inventory_private"] = true
Config.Modules["inventory_faction"] = true
Config.Modules["inventory_loadout"] = true
Config.Modules["inventory_weight"] = true
Config.Modules["inventory_container"] = true
Config.Modules["inventory_money"] = true
Config.Modules["inventory_shop"] = true

Config.Modules["ammosystem"] = true

Config.Modules["event"] = true
Config.Modules["comlink"] = true

Config.Modules["cloneid"] = true
Config.Modules["experience"] = true

Config.Modules["unarmed"] = true
Config.Modules["morgue"] = true

-- Custom Modules
Config.Modules["base_model"] = true

Config.Modules["inventory_bonemerge"] = true
Config.Modules["backpack"] = true
Config.Modules["helmet"] = true
Config.Modules["jetpack"] = true

Config.Modules["garage"] = true
Config.Modules["garage_shop"] = true

-- Addon Support
Config.Modules["gmaps"] = false
Config.Modules["cwutils"] = true
Config.Modules["shiputil"] = true
Config.Modules["pronemod"] = true
Config.Modules["lightsaberutil"] = true
Config.Modules["lightsaber_crafting"] = true

-- Medicsystem
Config.Modules["medicsystem"] = true
Config.Modules["medicsystem_jedi"] = true
Config.Modules["medicsystem_cwrp"] = true
Config.Modules["medicsystem_droid"] = true
Config.Modules["rakghoul"] = true

-- Custom CW:RP modules
Config.Modules["extendeddonator"] = true
Config.Modules["medicmenu"] = true
Config.Modules["stnotes"] = true
Config.Modules["fcmenu"] = true
Config.Modules["spectate"] = true
Config.Modules["eventmanager"] = true
Config.Modules["streamer"] = true
Config.Modules["ammoperk"] = true
Config.Modules["ticketsystem"] = true
Config.Modules["charban"] = true
Config.Modules["hud"] = true
Config.Modules["voicenotify"] = true
Config.Modules["education"] = true
Config.Modules["bactainjector"] = true
Config.Modules["eventspawns"] = true
Config.Modules["nextbotspawner"] = true
Config.Modules["soundboard"] = true
Config.Modules["gravitylock"] = true
Config.Modules["cloakdisguise"] = true
Config.Modules["weaponutil"] = true
Config.Modules["armorweapon"] = true
Config.Modules["express"] = true
--gamemodes/egmrp/gamemode/core/propertymodel/propertylist/number.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--       Client | Property List      --
---------------------------------------

function PROPERTY_TYPE:CreatePanel(propertyPanel, propertyListData, propertyModel, canEdit)
	local key = propertyListData.key

	local currentValue = propertyListData.default or 0
	if propertyModel then
		currentValue = propertyModel:GetProperty(key, currentValue)
	end

	local numberProperty = vgui.Create("DNumberWang", propertyPanel)
	propertyPanel.NumberProperty = numberProperty

	numberProperty:SetHeight(ScrH() * 0.02)
	numberProperty:Dock(FILL)
	numberProperty:SetMax(math.huge)
	numberProperty:SetDisabled(not canEdit)
	numberProperty:SetMouseInputEnabled(canEdit)
	numberProperty:SetFont("EGMText6")

	numberProperty:SetValue(currentValue)
end

function PROPERTY_TYPE:GetValue(propertyPanel)
	if not IsValid(propertyPanel.NumberProperty) then
		return
	end

	return propertyPanel.NumberProperty:GetValue()
end

-- Check, if the player can edit the propertyListData in some way.
--
-- @param table propertyListData
-- @param Player ply
-- @param PropertyModel propertyModel
function PROPERTY_TYPE:CanEdit(ply, propertyListData, propertyModel)
	-- Checking 0 should be sufficient.
	-- If the player can edit 0, he can edit all numbers.
	if propertyModel:CanPlayerEditProperty(ply, propertyListData.key, propertyListData.default or 0) then
		return true
	end

	return false
end
--gamemodes/egmrp/gamemode/core/propertymodel/propertylist/table.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--       Client | Property List      --
---------------------------------------

-- Table Property status enum.
PROPERTY_TYPE.INACTIVE = 1
PROPERTY_TYPE.SELECTED = 2
PROPERTY_TYPE.INHERITED = 3
PROPERTY_TYPE.INHERITED_SELECTED = 4
PROPERTY_TYPE.INVALID = 5

function PROPERTY_TYPE:CreatePanel(propertyPanel, propertyListData, propertyModel, canEdit)
	local _self = self

	local key = propertyListData.key

	local currentValue = propertyListData.default or {}
	if propertyModel then
		currentValue = propertyModel:GetProperty(key, currentValue)
	end

	local valuesTable = propertyListData.values
	if not istable(valuesTable) then return end

	local validValues = valuesTable.validValues
	if not istable(validValues) then return end

	local inheritedValues = valuesTable.inheritedValues or {}

	local tableProperty = vgui.Create("EGMListView", propertyPanel)
	tableProperty:SetHeight(ScrH() * 0.3)
	tableProperty:Dock(FILL)

	tableProperty:SetHeaderHeight(0)
	tableProperty:SetDataHeight(ScrH() * 0.02)
	tableProperty:SetMultiSelect(true)
	tableProperty.dataFont = "EGMText6"
	tableProperty.headerFont = "EGMText6"

	tableProperty:AddCustomColumn("propertyListData.name")

	local searchBar = vgui.Create("DTextEntry", propertyPanel)
	searchBar:SetHeight(ScrH() * 0.02)
	searchBar:Dock(BOTTOM)
	searchBar:SetValue(egmt("shared.searching"))


	tableProperty.CanEdit = canEdit
	tableProperty.ValidValues = validValues
	tableProperty.InheritedValues = inheritedValues

	tableProperty.SelectedValues = {}

	-- Select existing or default values
	for _, v in pairs(currentValue) do
		if isstring(v) or isnumber(v) then
			table.insert(tableProperty.SelectedValues, v)
		end
	end

	-- Update the propertyListData panel.
	function tableProperty:Reload()
		_self:PopulateTablePanel(self, searchBar:GetValue())
	end

	-- Update the propertyListData panel.
	function searchBar:OnEnter()
		tableProperty:Reload()
	end

	-- Clear the search bar if it is empty.
	function searchBar:Think()
		if self:IsEditing() then
			if self:GetText() == egmt("shared.searching") then
				self:SetText("")
			end
		else
			if self:GetText() == "" then
				self:SetText(egmt("shared.searching"))
			end
		end
	end

	-- Update all lines, to be properly colored and selected.
	function tableProperty:UpdateLines()
		for _, line in pairs(self:GetLines()) do
			local status = line.ValueStatus

			if status == _self.INACTIVE then
				line:SetSelected(false)
				line:SetCustomTextColor(GetColor("white"))
			elseif status == _self.SELECTED then
				line:SetSelected(true)
				line:SetCustomTextColor(GetColor("white"))
			elseif status == _self.INHERITED then
				line:SetSelected(false)
				line:SetCustomTextColor(GetColor("green"))
			elseif status == _self.INHERITED_SELECTED then
				line:SetSelected(true)
				line:SetCustomTextColor(GetColor("green"))
			elseif status == _self.INVALID then
				line:SetSelected(true)
				line:SetCustomTextColor(GetColor("red"))
			end
		end
	end

	-- Update on left-clicking a line.
	function tableProperty:OnRowSelected(index, line)
		local selectedValues = self.SelectedValues or {}

		local status = line.ValueStatus
		local value = line.ValueData

		if status == _self.INHERITED then
			table.RemoveByValue(selectedValues, "-" .. value)
			line.ValueStatus = _self.INHERITED_SELECTED
		elseif status == _self.INACTIVE then
			table.insert(selectedValues, value)
			line.ValueStatus = _self.SELECTED
		end

		self:UpdateLines()
	end

	-- Update on right-clicking a line.
	function tableProperty:OnRowRightClick(index, line)
		local selectedValues = self.SelectedValues or {}

		line:SetSelected(false)

		local status = line.ValueStatus
		local value = line.ValueData

		if status == _self.INHERITED_SELECTED then
			table.insert(selectedValues, "-" .. value)
			line.ValueStatus = _self.INHERITED
		elseif status == _self.SELECTED then
			table.RemoveByValue(selectedValues, value)
			line.ValueStatus = _self.INACTIVE
		elseif status == _self.INVALID then
			table.RemoveByValue(selectedValues, value)
			line.ValueStatus = _self.INACTIVE
		end

		self:UpdateLines()
	end

	tableProperty:Reload()

	propertyPanel.TableProperty = tableProperty
	propertyPanel.SearchBar = searchBar
end

-- Populate the propertyListData panel with the values.
--
-- @param Panel tableProperty
-- @param? String searchString
function PROPERTY_TYPE:PopulateTablePanel(tableProperty, searchString)
	local _self = self

	local canEdit = tableProperty.CanEdit
	local validValues = tableProperty.ValidValues
	local inheritedValues = tableProperty.InheritedValues

	tableProperty:Clear()

	-- Add a value to the table.
	--
	-- @param String id
	-- @param String text
	-- @param Number status
	function tableProperty:AddValue(id, text, status)
		if isstring(searchString) and #searchString > 0 and searchString ~= egmt("shared.searching") then
			local searchLowered = string.lower(searchString)
			local idLowered = string.lower(id)
			local textLowered = string.lower(text)

			if not (string.find(idLowered, searchLowered) or string.find(textLowered, searchLowered)) then return end
		end

		local line = self:AddCustomLine(text)
		line.ValueData = id
		line.ValueStatus = status

		line:SetMouseInputEnabled(canEdit)
	end

	-- Add Invalid Values.
	for _, value in SortedPairs(tableProperty.SelectedValues) do
		local name = validValues[value]

		-- Skip inherited models.
		if string.StartWith(value, "-") then continue end

		-- Skip valid models.
		if isstring(name) then continue end

		-- Add invalid model.
		tableProperty:AddValue(value, egmt("propertymodel.invalid_value", tostring(value)), _self.INVALID)
	end

	-- Add inherited Values.
	for _, value in SortedPairs(inheritedValues) do
		local name = validValues[value]

		-- Skip invalid models.
		if not isstring(name) then continue end

		-- Check, if the value is disabled.
		if table.HasValue(tableProperty.SelectedValues, "-" .. value) then
			-- Add inherited model.
			tableProperty:AddValue(value, name, _self.INHERITED)
		else
			-- Add inherited disabled model.
			tableProperty:AddValue(value, name, _self.INHERITED_SELECTED)
		end
	end

	-- Add Valid Selected Values.
	for _, value in SortedPairs(tableProperty.SelectedValues) do
		local name = validValues[value]

		-- Skip inherited disabled models.
		if string.StartWith(value, "-") then continue end

		-- Skip inherited models.
		if table.HasValue(inheritedValues, value) then continue end

		-- Skip invalid models.
		if not isstring(name) then continue end

		-- Add valid model.
		tableProperty:AddValue(value, name, _self.SELECTED)
	end

	-- Add Valid Unselected Values.
	for value, name in SortedPairs(validValues) do
		-- Skip inherited models.
		if table.HasValue(inheritedValues, value) then continue end

		-- Skip selected models.
		if table.HasValue(tableProperty.SelectedValues, value) then continue end

		-- Add valid model.
		tableProperty:AddValue(value, name, _self.INACTIVE)
	end

	tableProperty:UpdateLines()
end

function PROPERTY_TYPE:GetValue(propertyPanel)
	if not IsValid(propertyPanel.TableProperty) then
		return {}
	end

	return propertyPanel.TableProperty.SelectedValues
end

-- Check, if the player can edit the propertyListData in some way.
--
-- @param table propertyListData
-- @param Player ply
-- @param PropertyModel propertyModel
function PROPERTY_TYPE:CanEdit(ply, propertyListData, propertyModel)
	-- Simple check, if we are allowed to edit at all.
	-- Fast and efficient and catches most cases.
	if propertyModel:CanPlayerEditProperty(ply, propertyListData.key) then
		return true
	end

	-- Check, if one of the values can be changed.
	local currentValue = propertyListData.default or {}
	if propertyModel then
		currentValue = propertyModel:GetProperty(key, currentValue)
	end

	local valuesTable = propertyListData.values
	if not istable(valuesTable) then return false end

	-- Check if we can change the state of one of the valid values.
	-- This is slow, but we need to check all possible changes.
	-- This is only done, if we have detailed permissions set in the valuesTable.
	if valuesTable.detailedPermissions then
		local validValues = valuesTable.validValues
		if not istable(validValues) then return false end

		local inheritedValues = valuesTable.inheritedValues or {}

		for entry, _ in SortedPairs(validValues) do
			local newValue = table.Copy(currentValue)

			if table.HasValue(inheritedValues, entry) then
				-- If the entry is inherited, we need to remove the "-" entry or add it, depending on the current state.
				if table.HasValue(newValue, "-" .. entry) then
					table.RemoveByValue(newValue, "-" .. entry)
				else
					table.insert(newValue, "-" .. entry)
				end
			else
				-- If the entry is not inherited, we need to remove the entry or add it, depending on the current state.
				if table.HasValue(newValue, entry) then
					table.RemoveByValue(newValue, entry)
				else
					table.insert(newValue, entry)
				end
			end

			if propertyModel:CanPlayerEditProperty(ply, propertyListData.key, newValue) then
				return true
			end
		end
	end

	return false
end
--gamemodes/egmrp/gamemode/core/util/sh_table.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--      Table Utilities | Shared     --
---------------------------------------

-- Merges the two tables by comparing values.
--
-- @param Table target
-- @param Table source
function MergeTableByValue(target, source)
    for _, value in pairs(source) do
        if not table.HasValue(target, value) then
            table.insert(target, value)
        end
    end
end

-- Recursively compares the content of two tables according to the keys and returns the diff
--
-- @param Table values
-- @param Table newValues
-- @return boolean diff
function CompareTableRecursive(values, newValues)
	if not istable(values) or not istable(newValues) then
		return true
	end

	-- Check if the tables are the same instance.
	if values == newValues then
		return false
	end

	for k, v in pairs(values) do
		if istable(v) then
			if CompareTableRecursive(v, newValues[k]) then
				return true
			end
		else
			if newValues[k] ~= v then
				return true
			end
		end
	end

	for k, v in pairs(newValues) do
		if istable(v) then
			if CompareTableRecursive(v, values[k]) then
				return true
			end
		else
			if values[k] ~= v then
				return true
			end
		end
	end

	return false
end

-- Compares the content of two tables according to the values and returns the diff
--
-- @param Table values
-- @param Table newValues
-- @return Table addedValues
-- @return Table removedValues
function CompareTables(values, newValues)
    local addedValues = {}
    local removedValues = {}

    for _, v in pairs(values) do
        if not table.HasValue(newValues, v) then
            table.insert(removedValues, v)
        end
    end

    for _, v in pairs(newValues) do
        if not table.HasValue(values, v) then
            table.insert(addedValues, v)
        end
    end

    return addedValues, removedValues
end

-- Filters a table by a blacklist given by the prefix '-'
--
-- @param Table table
function FilterBlacklist(values)
    local filteredValues = {}
    local blacklist = {}

    for _, v in pairs(values) do
        if isstring(v) and string.StartWith(v, "-") then
            table.insert(blacklist, string.sub(v, 2))
        else
            table.insert(filteredValues, v)
        end
    end

    for _, v in pairs(blacklist) do
        table.RemoveByValue(filteredValues, v)
    end

    return filteredValues
end

-- Move a tables numberic indices to start at 1 but keep the order.
--
-- @param Table tbl
function NormalizeTable(tbl)
	local new = {}

	for k, v in SortedPairs(tbl) do
		if not isnumber(k) then continue end

		table.insert(new, v)
	end

	return new
end
--gamemodes/egmrp/gamemode/core/util/sh_position.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--    Position Utilities | Shared    --
---------------------------------------

-- Checks whether something is blocking the specified position within the radius.
--
-- @param Vector pos
-- @param? Number radius - defaults to 35 which is good for checking players positions.
function IsEmptyPos(pos, radius)
    radius = radius or 35

    -- Check whether the position is inside something blocking in the map.
    local point = util.PointContents(pos)

    if point == CONTENTS_SOLID
        or point == CONTENTS_MOVEABLE
        or point == CONTENTS_LADDER
        or point == CONTENTS_PLAYERCLIP
        or point == CONTENTS_MONSTERCLIP
    then
        return false
    end

    local offsetPos = pos + Vector(0, 0, 2)
    local trace = util.TraceHull({
        start = offsetPos,
        endpos = offsetPos,
        maxs = Vector(16, 16, 72),
        mins = Vector(-16, -16, 0),
        filter = {
            ent
        }
    })

    if trace.Hit then
        return false
    end

    return true
end

-- Returns pos if it is empty, if not, it tries to find a near
-- position that is empty and returns it as an alternative position.
--
-- @param Vector pos
-- @return Vector pos or Boolean false if no empty position was found.
function FindEmptyPos(pos)
    local x = pos.x
    local y = pos.y
    local z = pos.z
    local apos

    if IsEmptyPos(pos) then
        return pos
    end

    -- Look in steps of 10 for an empty position.
    -- Modify x and y coordinates in every possible combination
    -- until an empty position is found.
    for i = 10, 200, 10 do
        apos = Vector(x + i, y, z)
        if IsEmptyPos(apos) then
            return apos
        end

        apos = Vector(x - i, y, z)
        if IsEmptyPos(apos) then
            return apos
        end

        apos = Vector(x, y + i, z)
        if IsEmptyPos(apos) then
            return apos
        end

        apos = Vector(x, y - i, z)
        if IsEmptyPos(apos) then
            return apos
        end

        apos = Vector(x + i, y + i, z)
        if IsEmptyPos(apos) then
            return apos
        end

        apos = Vector(x - i, y - i, z)
        if IsEmptyPos(apos) then
            return apos
        end

        apos = Vector(x + i, y - i, z)
        if IsEmptyPos(apos) then
            return apos
        end

        apos = Vector(x - i, y + i, z)
        if IsEmptyPos(apos) then
            return apos
        end
    end

    return false
end

--gamemodes/egmrp/gamemode/core/util/sh_color.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--     Color Utilities | Shared     --
---------------------------------------

-- Initialize a color table containing all colors.
local Colors = {}
Colors["white"] = Color(255, 255, 255)
Colors["gray"] = Color(30, 30, 30)
Colors["black"] = Color(10, 10, 10)
Colors["fullblack"] = Color(0, 0, 0)
Colors["darkgray"] = Color(20, 20, 20)
Colors["yellow"] = Color(229, 177, 58)
Colors["orange"] = Color(255,127,80)
Colors["red"] = Color(220, 0, 0)
Colors["green"] = Color(0, 220, 0)
Colors["darkgreen"] = Color(20, 130, 50)
Colors["blue"] = Color(75, 213, 238)
Colors["darkblue"] = Color(0, 0, 139)
Colors["lightgray"] = Color(161, 161, 161)
Colors["purple"] = Color(255, 0, 255)

-- Gets the color string and returns it.
--
-- @param String name
-- @param Number alpha
-- @return Table color
function GetColor(name, alpha)
    return ColorAlpha(Colors[name], alpha or 255)
end

-- Returns 4 color arguments instead of a color table.
--
-- @param String name
-- @param Number alpha
-- @return Number rgba
function GetColor2(name, alpha)
    local color = GetColor(name, alpha)

    return color["r"], color["g"], color["b"], color["a"]
end

-- Returns a mixed Color by the factor.
--
-- @param Color color1
-- @param Color color2
-- @param Number value
function MixColor(color1, color2, value)
    local r = color1.r * (1 - value) + color2.r * value
    local g = color1.g * (1 - value) + color2.g * value
    local b = color1.b * (1 - value) + color2.b * value
    local a = color1.a * (1 - value) + color2.a * value

    return Color(r, g, b, a)
end

--gamemodes/egmrp/gamemode/core/util/sh_skincount.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--    SkinCount Utilities | Shared   --
---------------------------------------

local skinCountCache = {}

-- Helper Function, to count the amount of skins of a model.
-- Skin Count gets cached, so it doesn't have to be calculated every time.
--
-- @param String model
-- @return Number skinCount
function GetModelSkinCount(model)
	local skinCount = skinCountCache[model]
	if isnumber(skinCount) then
		return skinCount
	end

	-- On the client we use the NumModelSkins function, as it's more efficient than creating a temporary entity.
	if CLIENT then
		skinCount = math.max(1, NumModelSkins(model))
		skinCountCache[model] = skinCount

		return skinCount
	end

	-- On the server we have to create a temporary entity to get the skin count.
	-- This is a bit more expensive, but it's only done once per model.
	local temp = ents.Create("prop_dynamic")
	temp:SetModel(model)

	skinCount = math.max(1, temp:SkinCount())

	temp:Remove()

	skinCountCache[model] = skinCount

	return skinCount
end
--gamemodes/egmrp/gamemode/core/ui/sh_config.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--            UI | Config            --
---------------------------------------
--  Variables should be overwritten  --
--     in the deriving gamemode!     --
---------------------------------------

-- Currently Selected Style.
UI.SelectedStyle = "default"

-- The path to the watermark displayed in the UI. (False to disable)
UI.Watermark = "materials/icons/egm_logo.png"

-- The path to the sound to be played when a button is clicked.
UI.ButtonSound = "ui/button.mp3"

-- The maximum distance for which the player info is drawn.
UI.PlayerInfoDistance = 500
--gamemodes/egmrp/gamemode/core/ui/styles/default/hud/playerinfo.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--     HUD Element | Player Info     --
---------------------------------------

-- Draw the HUD Element
--
-- @param Player ply
function ELEMENT:Draw(ply)
	local trace = ply:GetEyeTrace()
	if not trace.Hit then return end

	local ent = trace.Entity
	if not IsValid(ent) then return end
	if not ent:IsPlayer() then return end

	local distance = ply:GetPos():Distance(ent:GetPos())
	if distance > UI.PlayerInfoDistance then return end

	-- Hide invisible and no draw entities
	if ent:GetNoDraw() then return end
	if ent:GetColor().a == 0 then return end

	-- Determine the position of the player info
	local pos = ent:EyePos() + Vector(0, 0, 15)
	local screenPos = pos:ToScreen()

	-- Do not draw if the screen position is not visible
	if not screenPos.visible then return end

	local currentCharacter = ply:GetCurrentCharacter()
	if not currentCharacter then return end

	local currentFaction = currentCharacter:GetFaction()
	if not currentFaction then return end

	local targetCharacter = ent:GetCurrentCharacter()
	if not targetCharacter then return end

	local targetFaction = targetCharacter:GetFaction()
	if not targetFaction then return end

	local shouldDrawFullName = true
	if currentFaction:GetId() ~= targetFaction:GetId() then
		shouldDrawFullName = false
	end

	-- Allow other modules to override which name is shown.
	local shouldShow = hook.Run("UI.ShouldDrawFullName", currentCharacter, currentFaction, targetCharacter, targetFaction)
	if isbool(shouldShow) then
		shouldDrawFullName = shouldShow
	end

	local playerInfo = {}
	if shouldDrawFullName then
		local text, color = targetCharacter:GetFullName()
		playerInfo.Text = text
		playerInfo.Color = color
	else
		local text, color = targetCharacter:GetLimitedName()
		playerInfo.Text = text
		playerInfo.Color = color
	end

	-- Allow other modules to fully override the player info.
	local override = hook.Run("UI.OverridePlayerInfo", currentCharacter, currentFaction, targetCharacter, targetFaction, shouldDrawFullName)
	if istable(override) then
		playerInfo = override
	end

	-- Do not draw if the player info is empty
	if not isstring(playerInfo.Text) or playerInfo.Text == "" then return end
	if not IsColor(playerInfo.Color) then return end

	-- Draw the player info
	draw.DrawText(playerInfo.Text, "EGMText10", screenPos.x, screenPos.y, playerInfo.Color, TEXT_ALIGN_CENTER)
end
--gamemodes/egmrp/gamemode/core/ui/styles/default/vgui/egmbutton.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--          VGUI | EGMButton         --
---------------------------------------

ELEMENT.Name = "EGMButton"
ELEMENT.Base = "DButton"

-- Initializes the Button Element.
function ELEMENT:Init()
	self.Color = UI.ForegroundColor
	self.HoverColor = Color(self.Color.r + 16, self.Color.g + 16, self.Color.b + 16, 255)
	self.DisabledColor = Color(180, 180, 180)

	self.CornerRadius = 0
	self.RoundTopLeft = true
	self.RoundTopRight = true
	self.RoundBottomLeft = true
	self.RoundBottomRight = true

	self:SetTextColor(UI.TextColor)
	self:SetFont("EGMText10")
	self:SetText("")
end

-- Works like DoClick but is intended for use internal use of a VGUI Element.
function ELEMENT:DoClickInternal()
	surface.PlaySound(UI.ButtonSound)
end

-- Draws the EGMButton
function ELEMENT:Paint(width, height)
	local color = self.Color
	if self:IsHovered() then
		color = self.HoverColor
	end
	if self:GetDisabled() then
		color = self.DisabledColor
	end

	draw.RoundedBoxEx(self.CornerRadius, 0, 0, width, height, color, self.RoundTopLeft, self.RoundTopRight, self.RoundBottomLeft, self.RoundBottomRight)
end



---------------------------------------
--          Setter Functions         --
---------------------------------------

-- Sets the button color.
-- Also sets the Hover color to a brighter version.
--
-- @param Color color
function ELEMENT:SetButtonColor(color)
	self.Color = color
	self.HoverColor = Color(self.Color.r + 16, self.Color.g + 16, self.Color.b + 16, 255)
end

-- Sets the button hover color.
--
-- @param Color color
function ELEMENT:SetButtonHoverColor(color)
	self.HoverColor = color
end

-- Sets the button disabled color.
--
-- @param Color color
function ELEMENT:SetDisabledButton(color)
	self.DisabledColor = color
end

-- Sets the radius of the rounded corners.
--
-- @param Number radius
function ELEMENT:SetButtonCornerRadius(radius)
	self.CornerRadius = radius
end

-- Sets wich corners should be round.
--
-- @param Boolean roundTopLeft
-- @param Boolean roundTopRight
-- @param Boolean roundBottomLeft
-- @param Boolean roundBottomRight
function ELEMENT:SetButtonCornerRound(roundTopLeft, roundTopRight, roundBottomLeft, roundBottomRight)
	self.RoundTopLeft = roundTopLeft
	self.RoundTopRight = roundTopRight
	self.RoundBottomLeft = roundBottomLeft
	self.RoundBottomRight = roundBottomRight
end
--gamemodes/egmrp/gamemode/core/settings/cl_settings.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--         Settings | Client         --
---------------------------------------

Settings.Options = Settings.Options or {}
Settings.Categories = Settings.Categories or {}

-- Sets the value of a setting.
--
-- @param String name
-- @param String value
function Settings:Set(name, value)
    value = tostring(value)
    self.Options[name].value = value or "true"

    net.Start("Settings.SetSettings")
        net.WriteString(name)
        net.WriteBool(tobool(value or "true") or false)
    net.SendToServer()

    cookie.Set("EGMRP.Setting." .. name, value or "true")
end

-- Returns the current value of a setting.
--
-- @param String name
-- @return String
function Settings:Get(name)
    return self.Options[name].value
end

-- Registers a new Setting. Automatically reads the current value from cookies.
--
-- @param String name
-- @param String category
-- @param Function onToggle
-- @param Boolean defaultValue
function Settings:Register(name, category, onToggle, defaultValue, usergroup)
    self.Options[name] = {
        value = cookie.GetString("EGMRP.Setting." .. name) or defaultValue or "true",
        default = defaultValue or "true",
        func = onToggle,
        category = category,
        usergroup = usergroup or "user"
    }

    if not table.HasValue(Settings.Categories, category) then
        table.insert(Settings.Categories, category)
    end
end

-- Sends the starting settings to the server.
hook.Add("InitPostEntity", "Settings.SetSettings", function()
    for name,v in pairs(Settings.Options) do
        net.Start("Settings.SetSettings")
            net.WriteString(name)
            net.WriteBool(tobool(v.value or "true") or false)
        net.SendToServer()
    end
end)

--gamemodes/egmrp/gamemode/core/scoreboard/sh_index.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--         Scoreboard | Index        --
---------------------------------------

Scoreboard = Scoreboard or {}
Scoreboard.Columns = {}

if SERVER then
    AddCSLuaFile("cl_config.lua")

    AddCSLuaFile("vgui/cl_scorerow.lua")
    AddCSLuaFile("cl_scoreboard.lua")
end

if CLIENT then
    include("cl_config.lua")

    include("vgui/cl_scorerow.lua")
    include("cl_scoreboard.lua")
end
--gamemodes/egmrp/gamemode/core/permission/sh_permission.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Permission | Shared        --
---------------------------------------

local Player = FindMetaTable("Player")

-- Returns wether the player ist at least the given user group.
--
-- @param String userGroup
-- @return Boolean isAtLeast
function Player:IsAtLeast(userGroup)
    local override = hook.Run("EGMRP.OverrideIsAtLeast", self, userGroup)
    if override ~= nil then
        return override
    end

    if table.KeyFromValue(Permission.UserGroupList, self:GetUserGroup()) and table.KeyFromValue(Permission.UserGroupList, userGroup) then
        return table.KeyFromValue(Permission.UserGroupList, self:GetUserGroup()) >= table.KeyFromValue(Permission.UserGroupList, userGroup)
    else
        return false
    end
end

-- Returns whether the player is a teammember.
--
-- @return Boolean isTeamMember
function Player:IsTeamMember()
    return self:IsAtLeast(Permission.FirstTeamRank)
end

-- Overwrite GMod/ULX IsAdmin
--
-- @return Boolean admin
function Player:IsAdmin()
    return self:IsAtLeast(Permission.AdminRank )
end

-- Overwrite GMod/ULX IsSuperAdmin
--
-- @return whether the player is SuperAdmin or not
function Player:IsSuperAdmin()
    return self:IsAtLeast(Permission.SuperAdminRank)
end



---------------------------------------
--            Administrate           --
---------------------------------------

-- Prevents the player from being shot at, when administrating.
hook.Add("PlayerTraceAttack", "Player.Administrate", function(ply, dmgInfo, dir, trace)
    if ply:GetNWBool("Administrate", false) then
        return true
    end
end)



---------------------------------------
--          SAM Integration          --
---------------------------------------

-- Check, if SAM is installed.
if sam then
    local has_permission = sam.ranks.has_permission
    function Player:HasPermission(perm)
        if (perm == "see_admin_chat") and not self:GetSetting("@Chat") then
            return false
        end

        -- Block default noclip, to prevent double noclip bug.
        if perm == "can_noclip" then return false end

        local override = hook.Run("EGMRP.OverrideSAMPermission", self, perm)
        if override ~= nil then
            return override
        end

        return has_permission(self:GetUserGroup(), perm)
    end
end



---------------------------------------
--               Vanish              --
---------------------------------------

-- Checks whether the player is vanished.
--
-- @return Boolean isVanished
function Player:Vanished()
    return self:GetNW2Bool("vanished", false)
end
--gamemodes/egmrp/gamemode/core/permission/cl_permission.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Permission | Client        --
---------------------------------------

local EGMRP = GM or GAMEMODE

Settings:Register("@Chat", "Chats", function() end, "true", Permission.FirstTeamRank)

-- Check Permissions, if the player is allowed to do open the spawn menu.
function EGMRP:SpawnMenuOpen()
    if Permission.OpenSpawnMenu and not LocalPlayer():IsAtLeast(Permission.OpenSpawnMenu) then
        return false
    end

    return true
end

-- Override the context menu open function, to allow checking permissions.
function EGMRP:OnContextMenuOpen()
    if Permission.MinimumContextMenuGroup and not LocalPlayer():IsAtLeast(Permission.MinimumContextMenuGroup) then
        return
    end

    if IsValid( g_ContextMenu ) and not g_ContextMenu:IsVisible() then
        g_ContextMenu:Open()
        menubar.ParentTo( g_ContextMenu )
    end
end



---------------------------------------
--               Vanish              --
---------------------------------------

hook.Add("DrawPlayerInfo", "Permission.Vanish", function(ply)
    if ply:Vanished() then
        return true
    end
end)
--gamemodes/egmrp/gamemode/core/eventlog/sh_index.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--          Event Log index          --
---------------------------------------

EventLog = EventLog or {}
EventLog.Events = {}

if SERVER then
    AddCSLuaFile("sh_config.lua")
    AddCSLuaFile("cl_eventlog.lua")
    AddCSLuaFile("cl_keybinds.lua")
    AddCSLuaFile("cl_interact.lua")

    include("sh_config.lua")
    include("sv_eventlog.lua")
end

if CLIENT then
    include("sh_config.lua")
    include("cl_eventlog.lua")
    include("cl_keybinds.lua")
    include("cl_interact.lua")
end
--gamemodes/egmrp/gamemode/core/eventlog/cl_interact.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--    Interact | Event Log System    --
---------------------------------------

if Config.Modules["interact"] then
    hook.Add("EGMRP.Loaded", "Eventlog.Interact", function()
        Interact:RegisterOption("team", egmt("eventlog.title"), 1, function()
            EventLog:Open()
            Interact.Menu:Remove()
        end)
    end)
end
--gamemodes/egmrp/gamemode/core/performance/cl_performance.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Performance | Client       --
---------------------------------------

-- Enable multi core rendering by default for every client.
RunConsoleCommand("gmod_mcore_test", 1)
RunConsoleCommand("mat_queue_mode", -1)
RunConsoleCommand("cl_threaded_bone_setup", 1)

-- Clear all decals every 3 minutes.
timer.Create("ClearDecals", 180, 0, function()
	RunConsoleCommand("r_cleardecals")
end)

hook.Add("SpawnMenuOpen", "Performance.HideTabs", function()
	for k, menuItem in pairs(g_SpawnMenu.CreateMenu.Items) do
		if menuItem.Tab:GetText() == language.GetPhrase("spawnmenu.category.postprocess") or
			menuItem.Tab:GetText() == language.GetPhrase("spawnmenu.category.saves") then

			g_SpawnMenu.CreateMenu:CloseTab(menuItem.Tab, true)
		end
	end
end)
--gamemodes/egmrp/gamemode/core/player/sh_config.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--   Shared | Player System Config   --
---------------------------------------
--  Variables should be overwritten  --
--     in the deriving gamemode!     --
---------------------------------------

-- Map data like nice names and colors to usergroups.
PlayerConfig.UserGroupData = {
    ["user"] = {
        ["name"] = "User",
        ["color"] = Color(255, 255, 255)
    },

    ["operator"] = {
        ["name"] = "Operator",
        ["color"] = Color(238, 154, 0)
    },

    ["admin"] = {
        ["name"] = "Admin",
        ["color"] = Color(205, 0, 0)
    },

    ["superadmin"] = {
        ["name"] = "Superadmin",
        ["color"] = Color(238, 58, 140)
    }
}

-- Weapons a player is not allowed to drop.
PlayerConfig.NoDropWeapons = {
    --"weapon_handcuffed",
    "weapon_fists"
}

-- The minimum group a player needs to have to access the player manager.
PlayerManager.MinAccessGroup = "operator"

-- The default key bind for opening the player manager.
PlayerManager.DefaultKey = KEY_F3

-- The background for the player manager.
PlayerManager.Background = "backgrounds/underain_midway.jpg"

-- The maximum number of elements a page can have in the player manager. The higher the number the higher the loading time.
PlayerManager.PageSize = 50
--gamemodes/egmrp/gamemode/core/player/sh_playerintegration.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--    Player Integration | Shared    --
---------------------------------------

local Player = FindMetaTable("Player")

-- Returns if the player should have a visible user group in chat.
--
-- @return Bool groupVisible
function Player:UserGroupVisible()
    local visible = hook.Run("Player.UserGroupVisible", self)
    if visible then return true end

    if self:IsTeamMember() then return true end

    return false
end

-- Gets the nice name of a usergroup.
--
-- @return String name
function Player:GetUserGroupName()
    local override = hook.Run("Player.OverrideUserGroupName", self)
    if isstring(override) then
        return override
    end

    local data = PlayerConfig.UserGroupData[self:GetUserGroup()]

    if data and isstring(data.name) then
        return data.name
    end

    return ""
end

-- Gets the color of a usergroup.
--
-- @return Table Color color
function Player:GetUserGroupColor()
    local override = hook.Run("Player.OverrideUserGroupColor", self)
    if IsColor(override) then
        return override
    end

    local data = PlayerConfig.UserGroupData[self:GetUserGroup()]

    if data and isstring(data.name) then
        return data.color
    end

    return Color(255, 255, 255, 255)
end

-- Returns the player data, which is cached on the player object.
--
-- @return Table playerData
function Player:GetData()
    return PlayerData:GetCached(self:SteamID64())
end

-- Sets a player to spectator mode. Needs to be called shared side or server side.
--
-- @param Boolean activated
function Player:SetSpectator(activated)
    if activated then
        if SERVER then
            self:Spectate(OBS_MODE_FREEZECAM)
            self:SetNoTarget(true)
            self:SetTeam(TEAM_SPECTATOR)
            self:Flashlight(false)
            self:AllowFlashlight(false)
            self:Fire("alpha", 0)
            self:StripWeapons()
            self:GodEnable()
        end

        self:DrawShadow(false)
        self:SetRenderMode(RENDERMODE_TRANSALPHA)
    else
        if SERVER then
            self:UnSpectate()
            self:SetNoTarget(false)
            self:AllowFlashlight(true)
            self:Fire("alpha", 255)
            self:GodDisable()
        end

        self:DrawShadow(true)
        self:SetRenderMode(RENDERMODE_NORMAL)
    end

    hook.Run("Player.SetSpectator", self, activated)
end

-- Checks whether the player is a spectator.
--
-- @return Boolean isSpectator
function Player:IsSpectator()
    return self:Team() == TEAM_SPECTATOR
end

-- Disallow spectators from using any object. (Map Buttons, Doors, etc...)
hook.Add("PlayerUse", "Player.RestrictSpectatorUse", function(ply, ent)
    if ply:IsSpectator() then
        return false
    end
end)

-- Tries to find a player by the given search string.
-- Recognizes steamid, steamid64 and steamname and name. Does not find bots.
--
-- @param String search
-- @return Player ply or Boolean false if not exactly one player was found.
function FindPlayer(search)
    local foundPlayers = {}

    if not isstring(search) then return false end

    for k, ply in pairs(player.GetHumans()) do
        if ply:SteamID() == search
        or ply:SteamID64() == search

        or ply:Name() == search
        or ply:SteamName() == search
        then
            foundPlayers[#foundPlayers + 1] = ply
        end
    end
    if #foundPlayers ~= 0 then
        if #foundPlayers == 1 then
            return foundPlayers[1]
        end

        return false
    end

    for k, ply in pairs(player.GetHumans()) do
        if string.find(ply:Name(), search)
        or string.find(ply:SteamName(), search)
        then
            foundPlayers[#foundPlayers + 1] = ply
        end
    end
    if #foundPlayers ~= 0 then
        if #foundPlayers == 1 then
            return foundPlayers[1]
        end

        return false
    end

    for k, ply in pairs(player.GetHumans()) do
        if string.find(string.lower(ply:Name()), string.lower(search))
        or string.find(string.lower(ply:SteamName()), string.lower(search))
        then
            foundPlayers[#foundPlayers + 1] = ply
        end
    end

    if #foundPlayers == 1 then
        return foundPlayers[1]
    end

    return false
end

-- Tries to find multiple players by the given search string.
-- Recognizes steamid, steamid64 and steamname and name. Does not find bots.
--
-- @param String search
-- @return Table targets
function FindPlayers(search)
    local foundPlayers = {}

    if not isstring(search) then return false end

    for k, ply in pairs(player.GetHumans()) do
        if ply:SteamID() == search
        or ply:SteamID64() == search

        or ply:Name() == search
        or ply:SteamName() == search
        then
            foundPlayers[#foundPlayers + 1] = ply
        end
    end
    if #foundPlayers ~= 0 then
        return foundPlayers
    end

    for k, ply in pairs(player.GetHumans()) do
        if string.find(ply:Name(), search)
        or string.find(ply:SteamName(), search)
        then
            foundPlayers[#foundPlayers + 1] = ply
        end
    end
    if #foundPlayers ~= 0 then
        return foundPlayers
    end

    for k, ply in pairs(player.GetHumans()) do
        if string.find(string.lower(ply:Name()), string.lower(search))
        or string.find(string.lower(ply:SteamName()), string.lower(search))
        then
            foundPlayers[#foundPlayers + 1] = ply
        end
    end

    return foundPlayers
end
--gamemodes/egmrp/gamemode/core/player/cl_playerintegration.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--    Player Integration | Client    --
---------------------------------------

-- Add spectator hint.
hook.Add("HUDPaint", "Player.SpectatorHint", function()
    if LocalPlayer():IsSpectator() then
        draw.SimpleText(egmt("player.spectator"), "EGMText10", ScrW() / 2, ScrH() * 0.6, GetColor("red"), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
    end
end)
--gamemodes/egmrp/gamemode/core/faction/sh_config.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Factionrank Config         --
---------------------------------------
--  Variables should be overwritten  --
--     in the deriving gamemode!     --
---------------------------------------

-- Minimum user groups that is allowed, to edit factions.
Faction.MinAccessGroup = "superadmin"
--gamemodes/egmrp/gamemode/core/rank/sh_rank.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--           Shared | Rank           --
---------------------------------------

-- Set sharedside property variables.
Rank.Name = "Rank"

Rank:AddData("factionId", "number", "faction_id", "INT NOT NULL",
function(rank, value)
    if not isnumber(value) then
        return false, egmt("rank.invalid_faction_id")
    end

    local faction = Faction:GetCached(value)

    if not (faction and faction:IsValid()) then
        return false, egmt("rank.invalid_faction")
    end

    return true
end,
function(rank, ply)
    return true
end)

-- Returns the Faction of the rank.
--
-- @return Table faction
function Rank.Meta:GetFaction()
    return Faction:GetCached(self:Get("factionId"))
end

-- Alias for Rank:GetFaction used in the manager.
--
-- @return Table faction
function Rank.Meta:GetParent()
    return self:GetFaction()
end

-- Gets every rank belonging to the given faction id.
--
-- @param Number factionId
-- @param Boolean hideInherited
-- @return Table ranks
function Rank:GetByFaction(factionId, hideInherited)
    local ranks = {}

    for id, rank in pairs(self:GetCache()) do
        if rank:Get("factionId") ~= factionId then
            continue
        end

        if hideInherited and not rank:GetProperty("inheritRank", true) then
            continue
        end

        table.insert(ranks, rank)
    end

    local faction = Faction:GetCached(factionId)
    local parent = faction:GetParent()
    if parent then
        local parentRanks = self:GetByFaction(parent:GetId(), true)
        MergeTableByValue(ranks, parentRanks)
    end

    return ranks
end

-- Alias function for Rank:GetByFaction.
--
-- @return Table ranks
function Faction.Meta:GetRanks()
    return Rank:GetByFaction(self:GetId())
end

-- Checks, if a rank is available in the faction.
--
-- @param Rank rank
-- @return Boolean available
function Faction.Meta:HasRank(rank)
    local ranks = self:GetRanks()

    return table.HasValue(ranks, rank)
end

-- Gets every rank belonging to the given faction id, sorted by authority level.
function Faction.Meta:GetSortedRanks()
    local ranks = Rank:GetByFaction(self:GetId())

    table.sort(ranks, function(a, b)
        return a:GetProperty("authorityLevel", 0) > b:GetProperty("authorityLevel", 0)
    end)

    return ranks
end

-- Initialize networking.
Rank:InitCreationNetworking()
Rank:InitEditNetworking()
Rank:InitDeletionNetworking()

-- Add rank property: name
Rank:AddProperty("name", "string", nil, function(rank, value)
    if not isstring(value) or #value < 3 then
        return false, egmt("faction.invalid_name")
    end

    return true
end,
function(rank, ply)
    return true
end)

-- Used to get the name of a rank. Will use the name property or the id as a fallback.
--
-- @return String name
function Rank.Meta:GetName()
    return self:GetProperty("name") or egmt("shared.rank") .. " " .. self:GetId()
end

-- Used to get the name of the rank including the faction prefix.
--
-- @return String name
function Rank.Meta:GetFullName()
    local faction = self:GetFaction()
    if faction then
        local prefix = faction:GetPrefix()
        if prefix ~= "" then
            return prefix .. " " .. self:GetName()
        end
    end

    return self:GetName()
end

-- Add rank property: prefix
Rank:AddProperty("prefix", "string", "", function(rank, value)
    if not isstring(value) or #value > 20 then
        return false, egmt("faction.invalid_prefix")
    end

    return true
end,
function(rank, ply)
    return true
end)

-- Used to get the prefix of a rank.
--
-- @return String prefix
function Rank.Meta:GetPrefix()
    return self:GetProperty("prefix") or ""
end

-- Add rank property: description
Rank:AddProperty("description", "string", "", function(rank, value)
    if not isstring(value) then
        return false, egmt("shared.invalid_type")
    end

    return true
end,
function(rank, ply)
    return true
end)

-- Add rank property: authorityLevel
Rank:AddProperty("authorityLevel", "number", 0, function(rank, value)
    if not isnumber(value) then
        return false, egmt("shared.invalid_type")
    end

    return true
end,
function(rank, ply)
    return true
end)

-- Used to get the authority level of a rank.
--
-- @return Number authorityLevel
function Rank.Meta:GetAuthorityLevel()
    return self:GetProperty("authorityLevel") or 0
end

-- Override the default sort function, with the authority level.
--
-- @return Number sort
function Rank.Meta:GetSort()
    return -self:GetAuthorityLevel()
end

-- Permissions table for ranks.
Rank.Permissions = Rank.Permissions or {}

-- Register a permission.
--
-- @param String id
-- @param String name
function Rank:RegisterPermission(id, name)
    self.Permissions[id] = name
end

RANK_PERMISSION_PROMOTE = "promote"
Rank:RegisterPermission(RANK_PERMISSION_PROMOTE, egmt("permission.promote"))

RANK_PERMISSION_KICK = "kick"
Rank:RegisterPermission(RANK_PERMISSION_KICK, egmt("permission.kick"))

RANK_PERMISSION_INVITE = "invite"
Rank:RegisterPermission(RANK_PERMISSION_INVITE, egmt("permission.invite"))

-- Add rank property: permissions
Rank:AddProperty("permissions", "table", {}, function(rank, value)
    if not istable(value) then
        return false, egmt("shared.invalid_type")
    end

    return true
end,
function(rank, ply)
    return true
end)

-- Check, if the rank has the given permission.
--
-- @param String permission
-- @return Boolean hasPermission
function Rank.Meta:HasPermission(permission)
    return table.HasValue(self:GetProperty("permissions"), permission)
end

-- Add rank property: health
Rank:AddProperty("health", "number", 100, function(rank, value)
	if not isnumber(value) or value <= 0 then
		return false, egmt("rank.invalid_health")
	end

	return true
end,
function(rank, ply)
	return true
end)

-- Add rank property: armor
Rank:AddProperty("armor", "number", 0, function(rank, armor)
	if not isnumber(armor) then
		return false, egmt("shared.invalid_type")
	end

	if armor < 0 then
		return false, egmt("rank.invalid_armor_low")
	end

	if armor > 255 then
		return false, egmt("rank.invalid_armor_high")
	end

	return true
end,
function(rank, ply)
	return true
end)

-- Add rank property: speed
Rank:AddProperty("speed", "number", 175, function(rank, value)
	if not isnumber(value) then
		return false, egmt("shared.invalid_type")
	end

	if value <= 0 then
		return false, egmt("rank.invalid_speed_low")
	end

	if value > 500 then
		return false, egmt("rank.invalid_speed_high")
	end

	return true
end,
function(rank, ply)
	return true
end)

-- Add rank property:jumpPower
Rank:AddProperty("jumpPower", "number", 200, function(rank, value)
	if not isnumber(value) then
		return false, egmt("shared.invalid_type")
	end

	return true
end,
function(rank, ply)
	return true
end)

-- Add rank property: scale
Rank:AddProperty("scale", "number", 1, function(rank, value)
	if not isnumber(value) then
		return false, egmt("shared.invalid_type")
	end

	return true
end,
function(rank, ply)
	return true
end)

-- Add rank property: color
Rank:AddProperty("color", "color", Color(255, 255, 255), function(rank, value)
    if not IsColor(value) then
        return false, egmt("shared.invalid_type")
    end

    return true
end,
function(rank, ply)
    return true
end)

-- Used to get the color of a rank.
function Rank.Meta:GetColor()
    return self:GetProperty("color", Color(255, 255, 255))
end

-- Add rank property: models
Rank:AddProperty("models", "table", {}, function(rank, value)
    if not istable(value) then
        return false, egmt("shared.invalid_type")
    end

    return true
end,
function(rank, ply)
    return true
end)

-- Returns all models, that are available for that rank.
--
-- @return Table models
function Rank.Meta:GetModels()
    local rankModels = {}
    for _, model in pairs(self:GetProperty("models", {})) do
        if isstring(model) then
            table.insert(rankModels, model)
        elseif istable(model) then
            -- Check, if one skin is available.
            for _, selected in pairs(model.Skins) do
                if selected then
                    table.insert(rankModels, model.Model)
                    break
                end
            end
        end
    end

    return rankModels
end

-- Returns all skins, that are available for that rank given a model.
--
-- @param String model
-- @return Boolean allSkins
-- @return? Table rankSkins
function Rank.Meta:GetSkins(model)
    if not isstring(model) then return false end

    for _, modelData in pairs(self:GetProperty("models", {})) do
        if isstring(modelData) and modelData == model then
            return true
        end

        local rankSkins = {}
        if istable(modelData) and modelData.Model == model then
            for skin, selected in pairs(modelData.Skins) do
                if selected then
                    table.insert(rankSkins, skin)
                end
            end

            return false, rankSkins
        end
    end

    return false
end

-- Add rank property: weapons
Rank:AddProperty("weapons", "table", {}, function(rank, value)
    if not istable(value) then
        return false, egmt("shared.invalid_type")
    end

    return true
end,
function(rank, ply)
    return true
end)

-- Add rank property: isTeammember
Rank:AddProperty("isTeammember", "boolean", false, function(rank, value)
    if not isbool(value) then
        return false, egmt("shared.invalid_type")
    end

    return true
end,
function(rank, ply)
    return true
end)

-- Add rank property: inheritRank
Rank:AddProperty("inheritRank", "boolean", true, function(rank, value)
    if not isbool(value) then
        return false, egmt("shared.invalid_type")
    end

    return true
end,
function(rank, ply)
    return true
end)

-- Add rank property: isStartRank
Rank:AddProperty("isStartRank", "boolean", false, function(rank, value)
	if not isbool(value) then
		return false, egmt("shared.invalid_type")
	end

	return true
end,
function(rank, ply)
	return true
end)

-- Is the rank a start rank?
--
-- @return Boolean isStartRank
function Rank.Meta:IsStartRank()
	return self:GetProperty("isStartRank", false)
end

-- Determine if a rank can be kicked onto.
--
-- @return Boolean canBeKickedOnto
function Rank.Meta:CanBeKickedOnto()
    local override = hook.Run("Rank.CanBeKickedOnto", self)
    if override ~= nil then
        return override
    end

    return self:IsStartRank()
end

-- Add rank property: slotType
Rank:AddProperty("slotType", "string", Rank.DefaultSlotType, function(rank, value)
    if not istable(Rank.SlotTypes[value]) then
        return false, egmt("character.invalid_slottype")
    end

    return true
end,
function(rank, ply)
    return true
end)

-- Limit access to the edit functions.
hook.Add("Rank.CanPlayerEditProperties", "Rank.EditPropertiesPermissions", function(ply, rank, properties)
    return ply:IsAtLeast(Faction.MinAccessGroup)
end)

hook.Add("Rank.CanPlayerEditData.factionId", "Rank.EditFactionIdPermissions", function(ply, rank, factionId)
    return ply:IsAtLeast(Faction.MinAccessGroup)
end)

hook.Add("Rank.CanPlayerCreate", "Rank.CreatePermissions", function(ply, data, properties)
    return ply:IsAtLeast(Faction.MinAccessGroup)
end)

hook.Add("Rank.CanPlayerDelete", "Rank.DeletePermissions", function(ply, character)
    return ply:IsAtLeast(Faction.MinAccessGroup)
end)

local Player = FindMetaTable("Player")

-- Checks if there is a free slot available for this rank.
--
-- @param Rank rank
-- @param? Character ignoreCharacter - Will be ignored when given. Used to check for existing characters.
-- @return Boolean isSlotFree
function Player:IsSlotFree(rank, ignoreCharacter)
    local globalSlots = 0
    local slotTypeSlots = 0

    local slotName = rank:GetProperty("slotType", Rank.DefaultSlotType)
    local slotType = Rank.SlotTypes[slotName]

    for _, character in pairs(self:GetCharacters()) do
        if character == ignoreCharacter then
            continue
        end

        local charRank = character:GetRank()
        if charRank then
            local otherSlotName = charRank:GetProperty("slotType", Rank.DefaultSlotType)
            local otherSlotType = Rank.SlotTypes[otherSlotName]

            if otherSlotType.usesGlobalSlot then
                globalSlots = globalSlots + 1
            end

            if slotName == otherSlotName then
                slotTypeSlots = slotTypeSlots + 1
            end
        end
    end

    local maxGlobalSlots = Rank.MaxGlobalSlots(self)
    local maxSlotTypeSlots = slotType.slots(self)

    if slotType.usesGlobalSlot and maxGlobalSlots > 0 and globalSlots >= maxGlobalSlots then
        return false, egmt("character.max_character_count")
    end

    if maxSlotTypeSlots > 0 and slotTypeSlots >= maxSlotTypeSlots then
        return false, egmt("character.max_character_count_dynamic", slotType.name)
    end

    return true
end

-- A character should only be playable if the slot is free.
hook.Add("Character.IsPlayable", "Character.CheckSlot", function(character, owner)
    local success, error = owner:IsSlotFree(character:GetRank(), character)

    if not success then
        return false, error
    end
end)
--gamemodes/egmrp/gamemode/core/rank/cl_manager.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--      Client | Faction Manager     --
---------------------------------------

-- Add the rank type to the faction manager.
Manager:RegisterObjectType(
    Faction.Name,
    Rank.Name,
    egmt("shared.rank"),
    function(faction)
        return faction:GetSortedRanks()
    end,
    function(faction)
        return Rank:Create({factionId = faction:GetId()}, {name = egmt("rank.new")})
    end,
    function(faction, rank)
        return rank:GetModel():GetPropertyList(faction, rank)
    end,
    egmt("rank.duplicate"),
    egmt("rank.delete"),
    egmt("rank.delete_warning"),
    egmt("rank.add"),
    egmt("rank.save")
)
--gamemodes/egmrp/gamemode/core/character/cl_charactercreation.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------
---------------------------------------
--  Client | Character creation menu --
---------------------------------------

-- Closes the CharacterCreation.
function CharacterCreation:Close()
	if IsValid(self.Frame) then
		self.Frame:Close()
	end
end

-- Opens the character creation.
--
function CharacterCreation:Open()
	self:Close()

	self.Frame = vgui.Create("EGMFrame")
	self.Frame:SetBackground(self.Background)
	self.Frame:SetSubTitle(egmt("character.creation"))

	self:CreateFactionRankList()
	self:CreateCharacterProperties()
	self:CreateCharacterPreview()

	hook.Run("CharacterCreation.Open", self)

	self.Frame:MakePopup()
end

-- Create the faction list.
function CharacterCreation:CreateFactionRankList()
	_self = self

	if IsValid(self.FactionPanel) then
		self.FactionPanel:Remove()
	end

	local w, h = ScrW(), ScrH()

	local factionPanel = vgui.Create("DPanel", self.Frame)
	factionPanel:SetPos(w * 0.04, h * 0.225)
	factionPanel:SetSize(w * 0.2, h * 0.35)
	function factionPanel:Paint(ww, hh)
		draw.RoundedBox(0, 0, 0, ww, hh, UI.BackgroundColor2)
	end

	local factionListLabel = vgui.Create("DLabel", factionPanel)
	factionListLabel:Dock(TOP)
	factionListLabel:DockMargin(w * 0.003, h * 0.005, w * 0.003, h * 0.005)
	factionListLabel:SetHeight(h * 0.03)
	factionListLabel:SetTextColor(Color(0, 0, 0, 0))
	factionListLabel:SetText(egmt("character.faction_selection"))
	function factionListLabel:Paint(width, height)
		draw.RoundedBox(0, 0, 0, width, height, UI.ForegroundColor)

		local text = self:GetText()
		if text ~= "" then
			draw.SimpleText(text, "EGMText8", width * 0.5, height * 0.5, UI.TextColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
		end
	end

	local factionList = vgui.Create("EGMListView", factionPanel)
	factionList:Dock(FILL)
	factionList:DockMargin(w * 0.003, 0, w * 0.003, h * 0.005)
	factionList:SetHeaderHeight(0)
	factionList:SetDataHeight(h * 0.03)
	factionList:SetMultiSelect(false)
	factionList:AddCustomColumn("Name")
	local sortColumn1 = factionList:AddCustomColumn("Sort")
	sortColumn1:SetMaxWidth(0)
	function factionList:Reload()
		self:Clear()

		for _, faction in pairs(Faction:GetCache()) do
			local canCreateRankInFaction = false

			for _, rank in pairs(faction:GetRanks()) do
				if LocalPlayer():CanCreateCharacter(rank) then
					canCreateRankInFaction = true
					break
				end
			end

			if canCreateRankInFaction then
				local line = self:AddCustomLine(faction:GetName(), faction:GetSort())
				line.faction = faction
			end
		end
	end

	local rankPanel = vgui.Create("DPanel", self.Frame)
	rankPanel:SetPos(w * 0.04, h * 0.6)
	rankPanel:SetSize(w * 0.2, h * 0.35)
	function rankPanel:Paint(ww, hh)
		draw.RoundedBox(0, 0, 0, ww, hh, UI.BackgroundColor2)
	end

	local rankListLabel = vgui.Create("DLabel", rankPanel)
	rankListLabel:Dock(TOP)
	rankListLabel:DockMargin(w * 0.003, h * 0.005, w * 0.003, h * 0.005)
	rankListLabel:SetHeight(h * 0.03)
	rankListLabel:SetTextColor(Color(0, 0, 0, 0))
	rankListLabel:SetText(egmt("character.rank_selection"))
	function rankListLabel:Paint(width, height)
		draw.RoundedBox(0, 0, 0, width, height, UI.ForegroundColor)

		local text = self:GetText()
		if text ~= "" then
			draw.SimpleText(text, "EGMText8", width * 0.5, height * 0.5, UI.TextColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
		end
	end

	local rankList = vgui.Create("EGMListView", rankPanel)
	rankList:Dock(FILL)
	rankList:DockMargin(w * 0.003, 0, w * 0.003, h * 0.005)
	rankList:SetHeaderHeight(0)
	rankList:SetDataHeight(h * 0.03)
	rankList:SetMultiSelect(false)
	rankList:AddCustomColumn("Name")
	local sortColumn2 = rankList:AddCustomColumn("Sort")
	sortColumn2:SetMaxWidth(0)
	function rankList:Reload()
		self:Clear()
		self.SelectedRank = nil

		local faction = factionList.SelectedFaction
		if not faction then return end

		for _, rank in pairs(faction:GetRanks()) do
			if LocalPlayer():CanCreateCharacter(rank) then
				local line = self:AddCustomLine(rank:GetName(), rank:GetSort())
				line.rank = rank
			end
		end
	end

	-- Update the rank list when a faction is selected.
	function factionList:OnRowSelected(index, line)
		self.SelectedFaction = line.faction
		rankList:Reload()

		_self.DescriptionText:Update()
		_self.PropertyList:Update()
		_self.PreviewPanel:Update()
		_self.CreateButton:SetDisabled(true)
	end

	-- Update the property list when a rank is selected.
	function rankList:OnRowSelected(index, line)
		self.SelectedRank = line.rank

		_self.DescriptionText:Update()
		_self.PropertyList:Update()
		_self.PreviewPanel:Update()
		_self.CreateButton:SetDisabled(false)
	end

	-- Populate the faction list.
	factionList:Reload()

	self.FactionPanel = factionPanel
	self.FactionListLabel = factionListLabel
	self.FactionList = factionList

	self.RankPanel = rankPanel
	self.RankListLabel = rankListLabel
	self.RankList = rankList
end

-- Create the character properties.
function CharacterCreation:CreateCharacterProperties()
	_self = self

	if IsValid(self.PropertyPanel) then
		self.PropertyPanel:Remove()
	end

	local w, h = ScrW(), ScrH()

	local descriptionPanel = vgui.Create("DPanel", self.Frame)
	descriptionPanel:SetPos(w * 0.76, h * 0.225)
	descriptionPanel:SetSize(w * 0.2, h * 0.25)
	function descriptionPanel:Paint(ww, hh)
		draw.RoundedBox(0, 0, 0, ww, hh, UI.BackgroundColor2)
	end

	local descriptionLabel = vgui.Create("DLabel", descriptionPanel)
	descriptionLabel:Dock(TOP)
	descriptionLabel:DockMargin(w * 0.003, h * 0.005, w * 0.003, h * 0.005)
	descriptionLabel:SetHeight(h * 0.03)
	descriptionLabel:SetTextColor(Color(0, 0, 0, 0))
	descriptionLabel:SetText(egmt("rank.description"))
	function descriptionLabel:Paint(width, height)
		draw.RoundedBox(0, 0, 0, width, height, UI.ForegroundColor)

		local text = self:GetText()
		if text ~= "" then
			draw.SimpleText(text, "EGMText8", width * 0.5, height * 0.5, UI.TextColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
		end
	end

	local descriptionText = vgui.Create("RichText", descriptionPanel)
	descriptionText:Dock(FILL)
	descriptionText:DockMargin(w * 0.003, 0, w * 0.003, h * 0.005)
	function descriptionText:PerformLayout()
		self:SetFontInternal("EGMText8")
	end
	function descriptionText:Paint(width, height)
		draw.RoundedBox(0, 0, 0, width, height, UI.BackgroundColor)
	end
	function descriptionText:Update()
		self:SetText("")

		local faction = _self.FactionList.SelectedFaction
		if faction then
			local factionDescription = faction:GetProperty("description", "")
			if factionDescription ~= "" then
				self:InsertColorChange(GetColor2("yellow"))
				self:AppendText(egmt("character.faction_description"))
				self:AppendText("\n")
				self:InsertColorChange(GetColor2("white"))
				self:AppendText(factionDescription)

				self:AppendText("\n\n")
			end
		end

		local rank = _self.RankList.SelectedRank
		if rank then
			local rankDescription = rank:GetProperty("description", "")
			if rankDescription ~= "" then
				self:InsertColorChange(GetColor2("yellow"))
				self:AppendText(egmt("character.rank_description"))
				self:AppendText("\n")
				self:InsertColorChange(GetColor2("white"))
				self:AppendText(rankDescription)
			end
		end
	end

	local propertyPanel = vgui.Create("DPanel", self.Frame)
	propertyPanel:SetPos(w * 0.76, h * 0.5)
	propertyPanel:SetSize(w * 0.2, h * 0.45)
	function propertyPanel:Paint(ww, hh)
		draw.RoundedBox(0, 0, 0, ww, hh, UI.BackgroundColor2)
	end

	local propertyLabel = vgui.Create("DLabel", propertyPanel)
	propertyLabel:Dock(TOP)
	propertyLabel:DockMargin(w * 0.003, h * 0.005, w * 0.003, h * 0.005)
	propertyLabel:SetHeight(h * 0.03)
	propertyLabel:SetTextColor(Color(0, 0, 0, 0))
	propertyLabel:SetText(egmt("character.properties"))
	function propertyLabel:Paint(width, height)
		draw.RoundedBox(0, 0, 0, width, height, UI.ForegroundColor)

		local text = self:GetText()
		if text ~= "" then
			draw.SimpleText(text, "EGMText8", width * 0.5, height * 0.5, UI.TextColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
		end
	end

	local propertyList = vgui.Create("EGMScrollPanel", propertyPanel)
	propertyList:Dock(FILL)
	propertyList:DockMargin(w * 0.003, 0, w * 0.003, h * 0.005)
	function propertyList:Paint(width, height)
		draw.RoundedBox(0, 0, 0, width, height, UI.BackgroundColor)
	end
	function propertyList:Update()
		self:Clear()

		local faction = _self.FactionList.SelectedFaction
		local rank = _self.RankList.SelectedRank
		if faction and rank then
			local properties = Character:GetCreationPropertyList(rank, faction, nil)
			if properties then
				local propertyValues = CreatePropertyList(self, properties)
				_self.PropertyValues = propertyValues
			end
		end
	end

	self.DescriptionPanel = descriptionPanel
	self.DescriptionLabel = descriptionLabel
	self.DescriptionText = descriptionText

	self.PropertyPanel = propertyPanel
	self.PropertyLabel = propertyLabel
	self.PropertyList = propertyList
end

-- Create the character preview.
function CharacterCreation:CreateCharacterPreview()
	_self = self

	if IsValid(self.PreviewPanel) then
		self.PreviewPanel:Remove()
	end

	local w, h = ScrW(), ScrH()

	local previewPanel = vgui.Create("EGMModelPanel", self.Frame)
	previewPanel:SetPos(w * 0.25, h * 0.2)
	previewPanel:SetSize(w * 0.5, h * 0.8)

	function previewPanel:Update()
		local propertyList = _self.PropertyList
		if not IsValid(propertyList) then return end

		local propertyPanels = propertyList.PropertyPanels
		if not istable(propertyPanels) then return end

		-- Update the preview according to the selected modelSkin.
		local modelPanel = propertyPanels["modelSkin"]
		if IsValid(modelPanel) then
			local faction = _self.FactionList.SelectedFaction
			local rank = _self.RankList.SelectedRank
			if faction and rank then
				local modelProperty = modelPanel.ModelProperty
				if not IsValid(modelProperty) then return end

				local modelData = modelProperty.SelectedModel
				if istable(modelData) then
					self:SetModelSkin(modelData.Model, modelData.SkinId)
				end
			end

			-- Update the preview when the model changes.
			function modelPanel.ModelProperty:OnChangedCustom(index, data)
				previewPanel:Update()
			end
		end

		hook.Run("CharacterCreation.UpdatePreview", previewPanel, propertyPanels)
	end

	local createButton = vgui.Create("EGMButton", self.Frame)
	createButton:SetPos(w * 0.4, h * 0.9)
	createButton:SetSize(w * 0.2, h * 0.05)
	createButton:SetFont("EGMText15")
	createButton:SetTextColor(UI.TextColor)
	createButton:SetText(egmt("character.create"))
	createButton:SetButtonColor(GetColor("green"))
	createButton:SetButtonCornerRadius(8)
	createButton:SetDisabled(true)
	function createButton:DoClick()
		local faction = _self.FactionList.SelectedFaction
		local rank = _self.RankList.SelectedRank
		if not faction or not rank then return end

		local propertyValues = _self.PropertyValues
		if not istable(propertyValues) then return end

		local properties = {}
		for k, v in pairs(propertyValues) do
			properties[k] = v()
		end

		local success, errors = Character:Create({rankId = rank:GetId(), factionId = faction:GetId(), playerSteamId64 = LocalPlayer():SteamID64()}, properties)
		if success then
			-- Close the character creation menu.
			_self:Close()

			-- Open the character selection menu.
			CharacterSelection:Open()
		else
			if errors then
				for k, v in pairs(errors) do
					Notify:Danger(egmt("shared.error"), v)
				end
			else
				Notify:Danger(egmt("shared.unknown_error"))
			end
		end
	end

	previewPanel:Update()

	self.PreviewPanel = previewPanel
	self.CreateButton = createButton
end
--gamemodes/egmrp/gamemode/core/deathsystem/sh_index.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--         DeathSystem index         --
---------------------------------------

DeathSystem = DeathSystem or {}

if SERVER then
    AddCSLuaFile("sh_config.lua")

    AddCSLuaFile("cl_deathsystem.lua")
    AddCSLuaFile("cl_scoreboard.lua")

    include("sh_config.lua")

    include("sv_deathsystem.lua")
    include("sv_chat.lua")
end

if CLIENT then
    include("sh_config.lua")

    include("cl_deathsystem.lua")
    include("cl_scoreboard.lua")
end
--gamemodes/egmrp/gamemode/modules/comlink/sh_index.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--          Comlink index            --
---------------------------------------

if Config.Modules["inventory"] then
	RequireModules({"inventory"})
end

Comlink = Comlink or {}
ComChannel = ComChannel or table.Copy(PropertyModel)

if SERVER then
	AddCSLuaFile("sh_config.lua")
	AddCSLuaFile("sh_comlink.lua")
	AddCSLuaFile("cl_comlink.lua")
	AddCSLuaFile("sh_comchannel.lua")
	AddCSLuaFile("cl_comchannel.lua")

	AddCSLuaFile("cl_keybinds.lua")
	AddCSLuaFile("cl_manager.lua")
	AddCSLuaFile("cl_comlink_gui.lua")

	AddCSLuaFile("sh_integration.lua")
	AddCSLuaFile("cl_ui.lua")

	include("sh_config.lua")
	include("sh_comlink.lua")
	include("sv_comlink.lua")
	include("sh_comchannel.lua")
	include("sv_comchannel.lua")

	include("sh_integration.lua")
end

if CLIENT then
	include("sh_config.lua")
	include("sh_comlink.lua")
	include("cl_comlink.lua")
	include("sh_comchannel.lua")
	include("cl_comchannel.lua")

	include("cl_keybinds.lua")
	include("cl_manager.lua")
	include("cl_comlink_gui.lua")

	include("sh_integration.lua")
	include("cl_ui.lua")
end
--gamemodes/egmrp/gamemode/modules/bodygroups/sh_index.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--      Index | BodyGroup System     --
---------------------------------------

BodyGroups = BodyGroups or {}

if SERVER then
	AddCSLuaFile("sh_config.lua")
	AddCSLuaFile("sh_bodygroups.lua")
	AddCSLuaFile("cl_bodygroups.lua")
	AddCSLuaFile("cl_model.lua")

	include("sh_config.lua")
	include("sh_bodygroups.lua")
	include("sv_bodygroups.lua")
	include("sv_model.lua")
end

if CLIENT then
	include("sh_config.lua")
	include("sh_bodygroups.lua")
	include("cl_bodygroups.lua")
	include("cl_model.lua")
end
--gamemodes/egmrp/gamemode/modules/bodygroups/cl_model.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--         BodyGroups Client           --
---------------------------------------

net.Receive("BodyGroups.ModelMessage", function()
	BodyGroups:OpenModelMenu(net.ReadEntity(), net.ReadTable())
end)

function BodyGroups:OpenBodyGroupsMenu(calling, targets, model,w, h)
	if IsValid(self.ModelIconLayout) then
		self.ModelIconLayout:Remove()
	end

	if IsValid(self.NextButton) then
		self.NextButton:Remove()
	end

	function self.ModelScrollPanel:Reload()
		self:Clear()

		local bodyGroups = {}
		local x, y = ScrW() * 0.01, ScrH() * 0.01

		for i = 1, #BodyGroups.modelIcon.Entity:GetBodyGroups() do
			local bodyGroup = BodyGroups.modelIcon.Entity:GetBodyGroups()[i]

			if bodyGroup then
				bodyGroups[bodyGroup.name] = {}

				for k, submodel in pairs(bodyGroup.submodels) do
					table.insert(bodyGroups[bodyGroup.name], k)
				end
			end
		end

		local skinLabel = vgui.Create("DLabel", self)
		skinLabel:SetPos(x, y)
		skinLabel:SetFont("EGMText12")
		skinLabel:SetTextColor(UI.TextColor)
		skinLabel:SetText(egmt("bodygroups.skin"))
		skinLabel:SizeToContents()

		y = y + ScrH() * 0.04

		for i = 0, BodyGroups.modelIcon.Entity:SkinCount() - 1 do
			local button = vgui.Create("DButton", self)
			button:SetPos(x, y)
			button:SetSize(ScrW() * 0.1, ScrH() * 0.05)
			button:SetFont("EGMText12")
			button:SetTextColor(UI.TextColor)
			button:SetText(i)
			button.skin = i
			function button:Paint(width, height)
				if self.skin == BodyGroups.modelIcon.Entity:GetSkin() then
					draw.RoundedBox(5, 0, 0, width, height, UI.ForegroundColor)
				else
					draw.RoundedBox(5, 0, 0, width, height, GetColor("lightgray"))
				end
			end
			function button:DoClick()
				surface.PlaySound(UI.ButtonSound)

				BodyGroups.modelIcon.Entity:SetSkin(self.skin)
			end

			x = x + ScrW() * 0.115

			if x > ScrW() * 0.35 - ScrW() * 0.01 then
				x = ScrW() * 0.01
				y = y + ScrH() * 0.07
			end
		end

		y = y + ScrH() * 0.08

		for name, subModels in pairs(bodyGroups) do
			x = ScrW() * 0.01

			local heading = vgui.Create("DLabel", self)
			heading:SetPos(x, y)
			heading:SetFont("EGMText12")
			heading:SetTextColor(UI.TextColor)
			heading:SetText(name)
			heading:SizeToContents()

			y = y + ScrH() * 0.04

			for k, subModel in pairs(subModels) do
				local button = vgui.Create("DButton", self)
				button:SetPos(x, y)
				button:SetSize(ScrW() * 0.1, ScrH() * 0.05)
				button:SetFont("EGMText12")
				button:SetTextColor(UI.TextColor)
				button:SetText(subModel)
				function button:Paint(width, height)
					if subModel == BodyGroups.modelIcon.Entity:GetBodygroup(BodyGroups.modelIcon.Entity:FindBodygroupByName(name)) then
						draw.RoundedBox(5, 0, 0, width, height, UI.ForegroundColor)
					else
						draw.RoundedBox(5, 0, 0, width, height, GetColor("lightgray"))
					end
				end
				function button:DoClick()
					surface.PlaySound(UI.ButtonSound)

					BodyGroups.modelIcon.Entity:SetBodygroup(BodyGroups.modelIcon.Entity:FindBodygroupByName(name), subModel)
				end

				x = x + ScrW() * 0.115

				if x > ScrW() * 0.35 - ScrW() * 0.01 then
					x = ScrW() * 0.01
					y = y + ScrH() * 0.07
				end

			end

			y = y + ScrH() * 0.08
		end
	end
	self.ModelScrollPanel:Reload()


	self.ApplyButton = vgui.Create("EGMButton", self.ModelSelection)
	self.ApplyButton:SetText(egmt("shared.apply"))
	self.ApplyButton:Dock(FILL)
	self.ApplyButton:DockMargin(w * 0.7, h * 0.85, 0, 0)
	self.ApplyButton:SetFont("EGMText10")
	self.ApplyButton:SetTextColor(UI.TextColor)
	function BodyGroups.ApplyButton:DoClick()
		local bodyGroups = {}
		for i = 1, #BodyGroups.modelIcon.Entity:GetBodyGroups() do
			local bodyGroup = BodyGroups.modelIcon.Entity:GetBodyGroups()[i]

			if bodyGroup then
				bodyGroups[bodyGroup.id] = BodyGroups.modelIcon.Entity:GetBodygroup(bodyGroup.id)
			end
		end

		bodyGroups.skin = BodyGroups.modelIcon.Entity:GetSkin()

		net.Start("BodyGroups.ModelMessage")
			net.WriteString(model)
			net.WriteTable(targets)
			net.WriteTable(bodyGroups)
		net.SendToServer()

		BodyGroups.Frame:Remove()
	end
end

function BodyGroups:OpenModelMenu(calling, targets)
	local w = ScrW() * 0.8
	local h = ScrH() * 0.8

	if IsValid(self.Frame) then
		self.Frame:Remove()
	end

	self.Frame = vgui.Create("DFrame")
	self.Frame:SetPos(ScrW() * 0.5 - w / 2, ScrH() * 0.5 - h / 2)
	self.Frame:SetSize(w, h)
	self.Frame:SetTitle("")
	self.Frame:ShowCloseButton(true)
	self.Frame:SetDraggable(false)
	self.Frame:SetAlpha(0)
	function self.Frame:Paint(width, height)
		draw.RoundedBox(2, 0, 0, width, height, GetColor("darkgray"))

		draw.DrawText("Model", "EGMText12", width * 0.05, height * 0.01, GetColor("yellow"), TEXT_ALIGN_LEFT)
	end
	self.Frame:AlphaTo(255, 0.2)

	self.ModelSelection = vgui.Create("DPanel", self.Frame)
	self.ModelSelection:Dock(FILL)
	self.ModelSelection:DockMargin(0, h * 0.025, 0, h * 0.01)
	function self.ModelSelection:Paint(width, height)
	end

	self.modelIcon = vgui.Create("EGMModelPanel", self.ModelSelection)
	self.modelIcon:Dock(FILL)
	self.modelIcon:DockMargin(w * 0.7, 0, 0, h * 0.1)
	self.modelIcon:SetModel("")

	-- For better resolution. For some reason does not update the rendered image on the time of creation correctly.
	timer.Simple(0,function()
		if self.modelIcon and IsValid(self.modelIcon) then
			self.modelIcon:SetModel("")
		end
	end)

	self.ModelScrollPanel = vgui.Create("EGMScrollPanel", self.ModelSelection)
	self.ModelScrollPanel:Dock(FILL)
	self.ModelScrollPanel:DockMargin(0, 0, w * 0.3, 0)

	self.ModelIconLayout = vgui.Create("DIconLayout", self.ModelScrollPanel)
	self.ModelIconLayout:Dock(FILL)
	function self.ModelIconLayout:Refresh()
		self.ModelIcons = {}
		self:Clear()

		for name, model in SortedPairs(player_manager.AllValidModels()) do
			local icon = self:Add("SpawnIcon")
			icon:SetSize(64, 64)
			icon.Model = model
			icon:SetModel(model)
			icon:SetTooltip(name)
			function icon:DoClick()
				BodyGroups.modelIcon:SetModel(self.Model)
				BodyGroups.NextButton:SetEnabled(true)
			end

			table.insert(self.ModelIcons, icon)
		end
	end
	self.ModelIconLayout:Refresh()

	if Config.Modules["bodygroups"] then
		self.NextButton = vgui.Create("EGMButton", self.ModelSelection)
		self.NextButton:SetText(egmt("shared.next"))
		self.NextButton:Dock(FILL)
		self.NextButton:DockMargin(w * 0.7, h * 0.85, 0, 0)
		self.NextButton:SetFont("EGMText10")
		self.NextButton:SetTextColor(UI.TextColor)
		self.NextButton:SetEnabled(false)
		function BodyGroups.NextButton:DoClick()
			BodyGroups:OpenBodyGroupsMenu(calling, targets, BodyGroups.modelIcon:GetModel(), w, h)
		end
	else
		self.ApplyButton = vgui.Create("EGMButton", self.ModelSelection)
		self.ApplyButton:SetText(egmt("shared.apply"))
		self.ApplyButton:Dock(FILL)
		self.ApplyButton:DockMargin(w * 0.7, h * 0.85, 0, 0)
		self.ApplyButton:SetFont("EGMText10")
		self.ApplyButton:SetTextColor(UI.TextColor)
		function BodyGroups.ApplyButton:DoClick()
			net.Start("BodyGroups.ModelMessage")
				net.WriteString(BodyGroups.modelIcon:GetModel())
				net.WriteTable(targets)
			net.SendToServer()

			BodyGroups.Frame:Remove()
		end
	end

	self.Frame:MakePopup()
end
--gamemodes/egmrp/gamemode/modules/bodygroups/entities/egmrp_changingroom/cl_init.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--    Client | Changingroom Entity   --
---------------------------------------

AddCSLuaFile("shared.lua")
include("shared.lua")

-- Drawing the model.
function ENT:Draw()
	self:DrawModel()
end
--gamemodes/egmrp/gamemode/modules/interact/cl_interact.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--         Interact | Client         --
---------------------------------------

Interact.Catergories = {}
Interact.Options = {}
Interact.OptionLists = {}

-- Registeres a category for the interact menu.
--
-- @param String id
-- @param String category
-- @param String name
-- @param Number sort
-- @param? Number size
-- @param? Function shouldShow
-- @param? Color color
-- @param? Color backgroundColor
function Interact:RegisterCategory(id, category, name, sort, size, shouldShow, color, backgroundColor, centerColor, centerBackgroundColor)
    color = color or UI.TextColor or GetColor("white")
    backgroundColor = backgroundColor or UI.BackgroundColor or GetColor("darkgray", 200)
    centerColor = centerColor or UI.TextColor or GetColor("white")
    centerBackgroundColor = centerBackgroundColor or UI.BackgroundColor2 or GetColor("gray", 200)

    Interact.Catergories[id] = {
        category = category,
        name = name,
        sort = sort,
        size = size,
        shouldShow = shouldShow,
        color = color,
        backgroundColor = backgroundColor,
        centerColor = centerColor,
        centerBackgroundColor = centerBackgroundColor,
    }
end

-- Remove all Options from the given category.
--
-- @param String category
function Interact:ClearOptions(category)
    local toBeRemoved = {}
    for _, option in pairs(self.Options) do
        if option.category == category then
            table.insert(toBeRemoved, option)
        end
    end

    for _, option in pairs(toBeRemoved) do
        table.RemoveByValue(self.Options, option)
    end
end

-- Registeres an option for the interact menu.
--
-- @param String category
-- @param String name
-- @param Number sort
-- @param? Function callback
-- @param? Function shouldShow
-- @param? Color color
-- @param? Color backgroundColor
function Interact:RegisterOption(category, name, sort, callback, shouldShow, color, backgroundColor)
    color = color or UI.TextColor or GetColor("white")
    backgroundColor = backgroundColor or UI.BackgroundColor or GetColor("darkgray", 200)

    table.insert(Interact.Options, {
        category = category,
        name = name,
        sort = sort,
        callback = callback,
        shouldShow = shouldShow,
        color = color,
        backgroundColor = backgroundColor,
    })
end

-- Registers a dynamically generated list for the interact menu.
--
-- @param String category
-- @param? Function getList
-- @param? Function shouldShow
-- @param? Color color
-- @param? Color backgroundColor
function Interact:RegisterOptionList(category, getList, shouldShow, color, backgroundColor)
    color = color or UI.TextColor or GetColor("white")
    backgroundColor = backgroundColor or UI.BackgroundColor or GetColor("darkgray", 200)

    table.insert(Interact.OptionLists, {
        category = category,
        getList = getList,
        shouldShow = shouldShow,
        color = color,
        backgroundColor = backgroundColor,
    })
end

-- Opens a given category.
-- nil is the default category.
--
-- @param? String category
-- @param? Boolean noClose
function Interact:OpenCategory(category, noClose)
    if self.Menu then
        self.Menu:Remove()
    end

    self.Menu = vgui.Create("EGMInteractMenu")
    self.Menu.NoClose = noClose or false

    local selectedCategory = Interact.Catergories[category]
    if selectedCategory then
        if selectedCategory.size then
            self.Menu:SetPageSize(selectedCategory.size)
        end

        self.Menu:SetBackgroundColor(selectedCategory.centerBackgroundColor)
        self.Menu:SetTextColor(selectedCategory.centerColor)
        self.Menu:SetCenterLabel(selectedCategory.name)
    end

    for id, subCategory in SortedPairsByMemberValue(Interact.Catergories, "sort") do
        if subCategory.category == category then
            local shouldShow = subCategory.shouldShow
            if isfunction(shouldShow) and not shouldShow() then
                continue
            end

            self.Menu:AddEntry(
                subCategory.name,
                function()
                    self:OpenCategory(id)
                end,
                subCategory.color,
                subCategory.backgroundColor
            )
        end
    end

    for _, option in SortedPairsByMemberValue(Interact.Options, "sort") do
        if option.category == category then
            local shouldShow = option.shouldShow
            if isfunction(shouldShow) and not shouldShow() then
                continue
            end

            self.Menu:AddEntry(
                option.name,
                option.callback,
                option.color,
                option.backgroundColor
            )
        end
    end

    for _, optionList in SortedPairsByMemberValue(Interact.OptionLists, "sort") do
        if optionList.category == category and optionList.getList then
            local shouldShow = optionList.shouldShow
            if isfunction(shouldShow) and not shouldShow() then
                continue
            end

            local options = optionList.getList()
            if options then
                for _, option in pairs(options) do
                    self.Menu:AddEntry(
                        option.name,
                        option.callback,
                        optionList.color,
                        optionList.backgroundColor
                    )
                end
            end
        end
    end
end

-- Opens the default category.
function Interact:Open()
    Interact:OpenCategory()
end

Interact:RegisterCategory("emotes", nil, egmt("interact.emotes"), 2, 12)
Interact:RegisterOption("emotes", egmt("interact.cheer"), 1, function()
    RunConsoleCommand("act", "cheer")
    Interact.Menu:Remove()
end)
Interact:RegisterOption("emotes", egmt("interact.laugh"), 2, function()
    RunConsoleCommand("act", "laugh")
    Interact.Menu:Remove()
end)
Interact:RegisterOption("emotes", egmt("interact.salute"), 3, function()
    RunConsoleCommand("act", "salute")
    Interact.Menu:Remove()
end)
Interact:RegisterOption("emotes", egmt("interact.wave"), 4, function()
    RunConsoleCommand("act", "wave")
    Interact.Menu:Remove()
end)
Interact:RegisterOption("emotes", egmt("interact.agree"), 5, function()
    RunConsoleCommand("act", "agree")
    Interact.Menu:Remove()
end)
Interact:RegisterOption("emotes", egmt("interact.disagree"), 6, function()
    RunConsoleCommand("act", "disagree")
    Interact.Menu:Remove()
end)
Interact:RegisterOption("emotes", egmt("interact.forward"), 7, function()
    RunConsoleCommand("act", "forward")
    Interact.Menu:Remove()
end)
Interact:RegisterOption("emotes", egmt("interact.stop"), 8, function()
    RunConsoleCommand("act", "halt")
    Interact.Menu:Remove()
end)
Interact:RegisterOption("emotes", egmt("interact.group_up"), 9, function()
    RunConsoleCommand("act", "group")
    Interact.Menu:Remove()
end)
Interact:RegisterOption("emotes", egmt("interact.becon"), 10, function()
    RunConsoleCommand("act", "becon")
    Interact.Menu:Remove()
end)

Interact:RegisterCategory("team", nil, egmt("shared.team"), 3, nil, function()
    return LocalPlayer():IsTeamMember()
end)
Interact:RegisterOption("team", egmt("interact.admin_menu"), 1, function()
    if ULib then
        RunConsoleCommand("ulx", "menu")
    elseif sam then
        RunConsoleCommand("sam", "menu")
    end
    Interact.Menu:Remove()
end)
--gamemodes/egmrp/gamemode/modules/unarmed/sh_config.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--          Unarmed | Config         --
---------------------------------------
--  Variables should be overwritten  --
--     in the deriving gamemode!     --
---------------------------------------

-- Prop Pickup Rotate Key.
Unarmed.RotateKey = IN_RELOAD

-- Max Distance for Pickup.
Unarmed.PickupMaxDistance = 200

-- Max Distance for Dropping.
Unarmed.DropMaxDistance = 100

-- Max Mass for Pickup.
Unarmed.PickupMaxMass = 20

-- The bone, that is used, to carry ragdoll.
Unarmed.CarryBone = "ValveBiped.Bip01_Spine4"

-- The offset, that is used, to carry ragdoll.
Unarmed.CarryOffset = Vector(5, 45, 10)
Unarmed.CarryAngle = Angle(0, 180, -90)

-- Bone Manipulation for the carried ragdoll.
Unarmed.CarryBoneMods = {
	["ValveBiped.Bip01_Spine2"] = Angle(0, 75, 0),
	["ValveBiped.Bip01_R_Thigh"] = Angle(0, -70, 0),
	["ValveBiped.Bip01_L_Thigh"] = Angle(0, -70, 0),
	["ValveBiped.Bip01_R_Foot"] = Angle(0, 50, 0),
	["ValveBiped.Bip01_L_Foot"] = Angle(0, 50, 0),
	["ValveBiped.Bip01_R_Clavicle"] = Angle(45, 45, 0),
	["ValveBiped.Bip01_L_Clavicle"] = Angle(-45, 45, 0),
	["ValveBiped.Bip01_R_UpperArm"] = Angle(90, 0, 0),
	["ValveBiped.Bip01_L_UpperArm"] = Angle(-90, 0, 0),
}

-- Set the ID of the hidden carry animation below.
Unarmed.CarryAnimation = 6

-- Blacklist of models, that cannot be carried or cannnot carry ragdolls.
Unarmed.CarryBlacklist = {
	"models/vortigaunt.mdl",
	"models/dog.mdl",
	"models/lamarr.mdl",

	"models/combine_strider.mdl",
	"models/combine_scanner.mdl",
	"models/props_combine/combine_mine01.mdl",
	"models/combine_turrets/floor_turret.mdl",
	"models/advisor.mdl",
	"models/antlion.mdl",
	"models/antlion_guard.mdl",

	"models/headcrabclassic.mdl",
	"models/zombie/classic.mdl",
	"models/zombie/classic_legs.mdl",
	"models/zombie/classic_torso.mdl",
	"models/headcrab.mdl",
	"models/gibs/fast_zombie_torso.mdl",
	"models/zombie/fast.mdl",
	"models/gibs/fast_zombie_legs.mdl",
	"models/headcrabblack.mdl",
	"models/zombie/poison.mdl",

	"models/humans/charple01.mdl",
	"models/humans/charple02.mdl",
	"models/humans/charple03.mdl",
	"models/humans/charple04.mdl",
	"models/humans/corpse1.mdl",

	"models/props_c17/furnituremattress001a.mdl",
}

-- List of weapons you are allowed to switch to while carrying a ragdoll.
-- These are supposed to be right handed weapons with minimal left arm movement in their animations.
Unarmed.WeaponWhitelist = {
	"weapon_pistol",
	"weapon_bugbait",
	"weapon_crowbar",
	"weapon_slam",
	"weapon_frag",
	"weapon_stunstick"
}

-- List of weapons, when active the player will not be asked, if they want to be picked up.
Unarmed.PickupNoAskWeapons = {
--	"weapon_handcuffed",
}

-- List of all animations, that can be used.
Unarmed.Animations = {
	[1] = {
		Name = "Cross Arms (Infront)",
		Bones = {
			["ValveBiped.Bip01_R_Forearm"] = Angle(-43.779933929443,-107.18412780762,15.918969154358),
			["ValveBiped.Bip01_R_UpperArm"] = Angle(20.256689071655, -57.223915100098, -6.1269416809082),
			["ValveBiped.Bip01_L_UpperArm"] = Angle(-28.913911819458, -59.408206939697, 1.0253102779388),
			["ValveBiped.Bip01_R_Thigh"] = Angle(4.7250719070435, -6.0294013023376, -0.46876749396324),
			["ValveBiped.Bip01_L_Thigh"] = Angle(-7.6583762168884, -0.21996378898621, 0.4060270190239),
			["ValveBiped.Bip01_L_Forearm"] = Angle(51.038677215576, -120.44165039063, -18.86986541748),
			["ValveBiped.Bip01_R_Hand"] = Angle(14.424224853516, -33.406204223633, -7.2624106407166),
			["ValveBiped.Bip01_L_Hand"] = Angle(25.959447860718, 31.564517974854, -14.979378700256),
		},
	},
	[2] = {
		Name = "Cross Arms (Back)",
		Bones = {
			["ValveBiped.Bip01_R_UpperArm"] = Angle(3.809, 15.382, 2.654),
			["ValveBiped.Bip01_R_Forearm"] = Angle(-63.658, 1.8 , -84.928),
			["ValveBiped.Bip01_L_UpperArm"] = Angle(3.809, 15.382, 2.654),
			["ValveBiped.Bip01_L_Forearm"] = Angle(53.658, -29.718, 31.455),

			["ValveBiped.Bip01_R_Thigh"] = Angle(4.829, 0, 0),
			["ValveBiped.Bip01_L_Thigh"] = Angle(-8.89, 0, 0),
		},
	},
	[3] = {
		Name = "Salute",
		Bones = {
			["ValveBiped.Bip01_R_UpperArm"] = Angle(80, -95, -77.5),
			["ValveBiped.Bip01_R_Forearm"] = Angle(35, -125, -5),
		},
	},
	[4] = {
		Name = "Raise Arm",
		Bones = {
			["ValveBiped.Bip01_L_Forearm"] = Angle(25,-65,25),
			["ValveBiped.Bip01_L_UpperArm"] = Angle(-70,-180,70),
		},
	},
	[4] = {
		Name = "Surrender",
		AccessInventory = true, -- Inventory System Integration. When surrendering, a different player can access your inventory.
		Bones = {
			["ValveBiped.Bip01_L_Forearm"] = Angle(25,-65,25),
			["ValveBiped.Bip01_R_Forearm"] = Angle(-25,-65,-25),
			["ValveBiped.Bip01_L_UpperArm"] = Angle(-70,-180,70),
			["ValveBiped.Bip01_R_UpperArm"] = Angle(70,-180,-70),
		},
		MaxSpeed = 150,
	},
	[5] = {
		Name = "Point",
		Bones = {
			["ValveBiped.Bip01_R_Finger2"] = Angle(4.151602268219, -52.963024139404, 0.42117667198181),
			["ValveBiped.Bip01_R_Finger21"] = Angle(0.00057629722869024, -58.618747711182, 0.001297949347645),
			["ValveBiped.Bip01_R_Finger3"] = Angle(4.151602268219, -52.963024139404, 0.42117667198181),
			["ValveBiped.Bip01_R_Finger31"] = Angle(0.00057629722869024, -58.618747711182, 0.001297949347645),
			["ValveBiped.Bip01_R_Finger4"] = Angle(4.151602268219, -52.963024139404, 0.42117667198181),
			["ValveBiped.Bip01_R_Finger41"] = Angle(0.00057629722869024, -58.618747711182, 0.001297949347645),
			["ValveBiped.Bip01_R_UpperArm"] = Angle(25.019514083862, -87.288040161133, -0.0012286090059206),
		},
	},
	[6] = {
		Name = "Carry Person",
		Hide = true,
		Bones = {
			["ValveBiped.Bip01_L_UpperArm"] = Angle(-70, 20, -20),
			["ValveBiped.Bip01_L_Forearm"] = Angle(-55, -90, -90),
			["ValveBiped.Bip01_L_Hand"] = Angle(0, -45, 45),
		},
	}
}
--gamemodes/egmrp/gamemode/modules/unarmed/weapons/egmrp_unarmed/shared.lua:
---------------------------------------
---------------------------------------
--	     	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Created by             --
--       Jan 'Oninoni' Ziegler       --
--       		Deltaa       		 --
--                                   --
--   This software is only allowed   --
--    on official 'Einfach Gaming'   --
--     servers owned by 'P4sca1'     --
---------------------------------------
---------------------------------------

---------------------------------------
--       Unarmed SWEP | Shared       --
---------------------------------------

AddCSLuaFile()

SWEP.PrintName  = egmt("unarmed.swep")

SWEP.Spawnable  = true
SWEP.AdminOnly  = false

SWEP.Slot       = 5
SWEP.SlotPos    = 0

SWEP.ViewModelFOV = 70

SWEP.ViewModel = "models/weapons/c_medkit.mdl"
SWEP.WorldModel = ""

SWEP.Primary.Ammo           = ""
SWEP.Primary.ClipSize       = 0
SWEP.Primary.DefaultClip    = 0
SWEP.Primary.Automatic      = true

SWEP.Secondary.Ammo         = ""
SWEP.Secondary.ClipSize     = 0
SWEP.Secondary.DefaultClip  = 0
SWEP.Secondary.Automatic    = false
--gamemodes/egmrp/gamemode/modules/inventory/sh_loaders.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Loaders | Inventory       --
---------------------------------------

-- Load the given item class.
--
-- @param String itemDirectory
-- @param String itemName
-- @return Boolean success
-- @return? String error
function Inventory:LoadItemClass(itemDirectory, itemName)
	ITEM_CLASS = {}
	ITEM_CLASS.Class = itemName

	local success = pcall(function()
		if SERVER then
			AddCSLuaFile(itemDirectory .. itemName .. "/shared.lua")
			AddCSLuaFile(itemDirectory .. itemName .. "/cl_init.lua")

			include(itemDirectory .. itemName .. "/shared.lua")
			include(itemDirectory .. itemName .. "/init.lua")
		end

		if CLIENT then
			include(itemDirectory .. itemName .. "/shared.lua")
			include(itemDirectory .. itemName .. "/cl_init.lua")
		end
	end)
	if not success then
		return false, "Cannot load Item Class \"" .. itemName .. "\""
	end

	self.ItemClasses[itemName] = ITEM_CLASS
	ITEM_CLASS = nil

	return true
end

-- Reload all Item Classes.
--
-- @param String moduleDirectory
function Inventory:LoadItemClasses(moduleDirectory)
	self.ItemClasses = self.ItemClasses or {}

	local itemDirectory = moduleDirectory .. "item_classes/"
	local _, itemDirectories = file.Find(itemDirectory .. "*", "LUA")

	for _, itemName in pairs(itemDirectories) do
		self.ItemClasses[itemName] = nil

		local success, error = self:LoadItemClass(itemDirectory, itemName)
		if success then
			LogInfo("|-- Loaded Item Class \"" .. itemName .. "\"")
		else
			LogWarning("|-- " .. error)
		end
	end
end

-- Link all the item Classes with their dependencies.
function Inventory:LinkItemClasses()
	for _, itemClass in pairs(self.ItemClasses) do
		local baseItemClassName = itemClass.BaseItemClass
		if not isstring(baseItemClassName) then
			continue
		end

		local baseItemClass = self.ItemClasses[baseItemClassName]
		if istable(baseItemClass) then
			itemClass.Base = baseItemClass
			setmetatable(itemClass, {__index = baseItemClass})
		else
			LogWarning("|-- Failed, to find Item Class Baseclass \"" .. baseItemClassName .. "\" for \"" .. itemClass.Class .. "\"")
		end
	end
end

-- Get the item Class by the given name.
--
-- @param String itemClassName
-- @return? Table itemClass
function Inventory:GetItemClassFromName(itemClassName)
	return self.ItemClasses[itemClassName]
end



---------------------------------------
--             Item Slots            --
---------------------------------------

-- Load the given item slot class.
--
-- @param String itemSlotDirectory
-- @param String itemSlotName
-- @return Boolean success
-- @return? String error
function Inventory:LoadItemSlotClass(itemSlotDirectory, itemSlotName)
	ITEM_SLOT = {}
	ITEM_SLOT.Class = itemSlotName

	local success = pcall(function()
		if SERVER then
			AddCSLuaFile(itemSlotDirectory .. itemSlotName .. "/shared.lua")
			AddCSLuaFile(itemSlotDirectory .. itemSlotName .. "/cl_init.lua")

			include(itemSlotDirectory .. itemSlotName .. "/shared.lua")
		end

		if CLIENT then
			include(itemSlotDirectory .. itemSlotName .. "/shared.lua")
			include(itemSlotDirectory .. itemSlotName .. "/cl_init.lua")
		end
	end)
	if not success then
		return false, "Cannot load Item Slot Class \"" .. itemSlotName .. "\""
	end

	self.ItemSlotClasses[itemSlotName] = ITEM_SLOT
	ITEM_SLOT = nil

	return true
end

-- Reload all Item Slot Classes.
--
-- @param String moduleDirectory
function Inventory:LoadItemSlotClasses(moduleDirectory)
	self.ItemSlotClasses = self.ItemSlotClasses or {}

	local itemSlotDirectory = moduleDirectory .. "item_slots/"
	local _, itemSlotDirectories = file.Find(itemSlotDirectory .. "*", "LUA")

	for _, itemSlotName in pairs(itemSlotDirectories) do
		self.ItemSlotClasses[itemSlotName] = nil

		local success, error = self:LoadItemSlotClass(itemSlotDirectory, itemSlotName)
		if success then
			LogInfo("|-- Loaded Item Slot Class \"" .. itemSlotName .. "\"")
		else
			LogWarning("|-- " .. error)
		end
	end
end

-- Link all the item Slot Classes with their dependencies.
function Inventory:LinkItemSlotClasses()
	for _, itemSlotClasses in pairs(self.ItemSlotClasses) do
		local baseItemSlotClassName = itemSlotClasses.BaseItemSlot
		if not isstring(baseItemSlotClassName) then
			continue
		end

		local baseItemSlotClass = self.ItemSlotClasses[baseItemSlotClassName]
		if istable(baseItemSlotClass) then
			itemSlotClasses.Base = baseItemSlotClass
			setmetatable(itemSlotClasses, {__index = baseItemSlotClass})
		else
			LogWarning("|-- Failed, to find Item Slot Class Baseclass \"" .. baseItemSlotClassName .. "\" for \"" .. itemSlotClasses.Class .. "\"")
		end
	end
end

-- Get the item Slot Class by the given name.
--
-- @param String itemSlotClassName
-- @return? Table itemSlotClass
function Inventory:GetItemSlotClass(itemSlotClassName)
	return self.ItemSlotClasses[itemSlotClassName]
end



---------------------------------------
--             Load Hooks            --
---------------------------------------

-- Load all the item Classes from the given module.
hook.Add("EGMRP.ModuleLoaded", "Inventory.LoadClasses", function(_, folderPath)
	Inventory:LoadItemClasses(folderPath)
	Inventory:LoadItemSlotClasses(folderPath)
end)

-- Link all the item Classes with their dependencies.
hook.Add("EGMRP.Loaded", "Inventory.LinkClasses", function()
	Inventory:LinkItemClasses()
	Inventory:LinkItemSlotClasses()
end)
--gamemodes/egmrp/gamemode/modules/inventory/item_classes/weapon_grenade/cl_init.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Client | Weapon Item       --
---------------------------------------

local ITEM_CLASS = ITEM_CLASS

-- Display name for the type used in UI elements.
ITEM_CLASS.Name = egmt("inventory.item_class_weapon_grenade")

-- List of properties that should be shown in the manager, if this item class is used.
ITEM_CLASS.PropertyList = {"weapons"}
--gamemodes/egmrp/gamemode/modules/inventory/item_classes/weapon_small/shared.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Shared | Weapon Item       --
---------------------------------------

-- This Item Class is used for weapons, which can be equipped and used by the player.
-- A single weapon cannot be equipped more than once, but multiple weapons can be equipped together, depending on the slots.

local ITEM_CLASS = ITEM_CLASS

-- Base Item class, from which functions and such should be inherited.
ITEM_CLASS.BaseItemClass = "weapon"

-- List of item slots, which the item can be equipped to.
ITEM_CLASS.Slots = {
	"weapon_small",
	"weapon_consealed",
	"backpack",
}

-- Sorting order of the item.
ITEM_CLASS.Sort = 120



---------------------------------------
--        Item Class Function        --
---------------------------------------

-- Check, if the item can be added to the given slot.
--
-- @param Table inventory
-- @param ItemType itemType
-- @param Table itemData
-- @param? String slotType
-- @return Boolean canAdd
-- @return? String error
function ITEM_CLASS:CanEquipInto(inventory, itemType, itemData, slotType)
	-- Ignore other items if the target is not an equipment slot.
	local slotTypeClass = Inventory:GetItemSlotClass(slotType)
	if istable(slotTypeClass) and slotTypeClass.Equipment then
		-- Prevent the same weapon from being equipped twice.
		local successFind = self:FindOtherItem(inventory, itemData, true)
		if successFind then
			return false, egmt("inventory.weapon_already_equipped")
		end
	end

	local success, err = ITEM_CLASS.Base.CanEquipInto(self, inventory, itemType, itemData, slotType)
	if not success then
		return false, err
	end

	return true
end
--gamemodes/egmrp/gamemode/modules/comlink/sh_comlink.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--          Shared | Comlink         --
---------------------------------------

-- Behaviour table for comlink.
Faction.ComlinkBehaviours = {}


-- Register a behaviour for comlink.
--
-- @param String id
-- @param String name
function Faction:RegisterComlinkBehaviour(id, name)
	self.ComlinkBehaviours[id] = name
end

FACTION_COMLINK_BEHAVIOUR_DISABLED = "false"
Faction:RegisterComlinkBehaviour(FACTION_COMLINK_BEHAVIOUR_DISABLED, egmt("comlink.behaviour_none"))

FACTION_COMLINK_BEHAVIOUR_PRIVATE = "private"
Faction:RegisterComlinkBehaviour(FACTION_COMLINK_BEHAVIOUR_PRIVATE, egmt("comlink.behaviour_private"))

FACTION_COMLINK_BEHAVIOUR_SHARED = "shared"
Faction:RegisterComlinkBehaviour(FACTION_COMLINK_BEHAVIOUR_SHARED, egmt("comlink.behaviour_shared"))

-- Add faction property: comlinkBehaviour
Faction:AddProperty("comlinkBehaviour", "string", FACTION_COMLINK_BEHAVIOUR_DISABLED, function(behaviour, value)
	if not isstring(value) then
		return false, egmt("shared.invalid_type")
	end

	return true
end,
function(behaviour, ply)
	return true
end)

-- Returns the comlink behaviour of the faction.
--
-- @return String comlinkBehaviour
function Faction.Meta:GetComlinkBehaviour()
	return self:GetProperty("comlinkBehaviour", FACTION_COMLINK_BEHAVIOUR_DISABLED)
end

-- Add equipment property: comlinkAccess
Equipment:AddProperty("comlinkAccess", "table", {}, function(equip, value)
	if not istable(value) then
		return false, egmt("shared.invalid_type")
	end

	return true
end,
function(equip, ply)
	return true
end)

-- Returns, if the equipment grants access to a comlink channel.
--
-- @param String channelId
-- @return Boolean hasAccess
function Equipment.Meta:HasComlinkAccess(channelId)
	return table.HasValue(self:GetProperty("comlinkAccess", {}), channelId)
end

-- Add a comlink access to the equipment name.
hook.Add("Equipment.GetEffectList", "Comlink.EquipmentEffect", function(equip, effectList)
	local comlinkAccess = equip:GetProperty("comlinkAccess", {})
	if #comlinkAccess == 0 then
		return
	end

	table.insert(effectList, egmt("comlink.equipment_access"))
end)



---------------------------------------
--          Comlink Channels         --
---------------------------------------

-- Table of all comlink channels.
Comlink.Channels = Comlink.Channels or {}

-- Register a comlink channel.
--
-- @param String type
-- @param String id
-- @param String name
-- @return Table comlinkData
function Comlink:RegisterChannel(type, id, name)
	local comlinkData = {
		Name = name,
		Password = false,
		AccessFactions = {}, -- List of faction ids that have access to this channel
		AccessCharacters = {} -- List of character ids that have access to this channel
	}

	self.Channels[type .. "_" .. id] = comlinkData

	return comlinkData
end

-- Create a faction comlink channel.
--
-- @param Faction faction
-- @return Table comlinkData
function Comlink:CreateFactionChannel(faction)
	local comlinkBehaviour = faction:GetComlinkBehaviour()
	if comlinkBehaviour == FACTION_COMLINK_BEHAVIOUR_DISABLED then
		return
	end

	local accessFactions = {}

	-- Always add the faction itself to the accessFactions
	accessFactions[faction:GetId()] = true

	-- If the comlinkBehaviour is shared, add all child factions to the accessFactions
	if comlinkBehaviour == FACTION_COMLINK_BEHAVIOUR_SHARED then
		for _, childFaction in pairs(faction:GetChildrenRecursive()) do
			accessFactions[childFaction:GetId()] = true
		end
	end

	local comlinkData = self:RegisterChannel("faction", faction:GetId(), faction:GetName())

	-- Add all accessFactions to the comlinkData.
	for factionId, _ in pairs(accessFactions) do
		comlinkData.AccessFactions[factionId] = true
	end

	return comlinkData
end

-- Create a comlink channel for every faction on load.
hook.Add("Faction.LoadedAll", "Comlink.AddAllFactionChannels", function()
	for _, faction in pairs(Faction:GetCache()) do
		Comlink:CreateFactionChannel(faction)
	end
end)

-- Create a comlink channel for a faction on creation.
hook.Add("Faction.Created", "Comlink.AddFactionChannel", function(faction)
	Comlink:CreateFactionChannel(faction)
end)

-- Remove a comlink channel for a faction on deletion.
hook.Add("Faction.Delete", "Comlink.RemoveFactionChannel", function(faction)
	Comlink.Channels["faction_" .. faction:GetId()] = nil
end)

-- Update faction channel names on faction property change.
hook.Add("Faction.PropertyChanged", "Comlink.UpdateFactionChannel", function(faction, key, value)
	if key == "name" or key == "comlinkBehaviour" then
		Comlink.Channels["faction_" .. faction:GetId()] = nil

		Comlink:CreateFactionChannel(faction)

		return
	end

	-- Update all factions, if the parent faction changes, since we don't know which child factions are affected.
	if key == "parentId" then
		for _, otherFaction in pairs(Faction:GetCache()) do
			Comlink.Channels["faction_" .. otherFaction:GetId()] = nil

			Comlink:CreateFactionChannel(otherFaction)
		end
	end
end)

local Player = FindMetaTable("Player")

-- Can the player use a specific comlink channel?
--
-- @param String channelId
-- @return Boolean canUse
function Player:CanUseComlinkChannel(channelId)
	local comlinkData = Comlink.Channels[channelId]
	if not comlinkData then return false end

	local currentCharacter = self:GetCurrentCharacter()
	if not currentCharacter then return false end

	local override = hook.Run("Comlink.CanUseChannel", self, currentCharacter, comlinkData)
	if override ~= nil then
		return override
	end

	-- Allow direct access to the channel for characters
	if comlinkData.AccessCharacters[currentCharacter:GetId()] then
		return true
	end

	-- Allow access to the channel for factions
	if comlinkData.AccessFactions[currentCharacter:GetFaction():GetId()] then
		return true
	end

	-- Allow access to the channel for equipment
	local relevantEquipment = currentCharacter:GetRelevantEquipment()
	for _, equip in pairs(relevantEquipment) do
		if equip:HasComlinkAccess(channelId) then
			return true
		end
	end

	-- Allow access from other systems, that do not fully override the function
	local allowAccess = hook.Run("Comlink.AddCustomAccess", self, currentCharacter, comlinkData)
	if allowAccess == true then
		return true
	end

	return false
end

-- Get a list of all comlink channels a player has access to.
--
-- @return Table channels
function Player:GetComlinkChannels()
	local channels = {}

	for channelId, comlinkData in pairs(Comlink.Channels) do
		if self:CanUseComlinkChannel(channelId) then
			channels[channelId] = comlinkData
		end
	end

	return channels
end



---------------------------------------
--           Comlink Status          --
---------------------------------------

-- Returns whether comlink is enabled.
--
-- @return Boolean comlinkEnabled
function Player:IsComlinkEnabled()
	return self.ComlinkEnabled or false
end

-- Gets the active comlink channel.
--
-- @return Boolean|String activeComlinkChannel
function Player:GetActiveComlinkChannel()
	if not self.ComlinkEnabled then
		return false
	end

	return self.ActiveComlinkChannel or false
end

-- Gets a list of passive comlink channels.
--
-- @return Boolean|Table passiveComlinkChannels
function Player:GetPassiveComlinkChannels()
	if not self.ComlinkEnabled then
		return false
	end

	return self.PassiveComlinkChannels or {}
end

-- Is the player listening to a specific comlink channel?
--
-- @param String channelId
-- @return Boolean isListening
function Player:IsComlinkListening(channelId)
	if not self.ComlinkEnabled then
		return false
	end

	if self.PassiveComlinkChannels[channelId] then
		return true
	end

	return false
end
--gamemodes/egmrp/gamemode/modules/comlink/cl_manager.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Manager | ComChannel       --
---------------------------------------

Manager:RegisterObjectCategory(
    ComChannel.Name,
    egmt("comlink.channel"),
    function()
        return ComChannel:GetCache()
    end,
    function()
        return ComChannel:Create({}, {name = egmt("comChannel.new")})
    end,
    nil,
    egmt("comChannel.duplicate_long"),
    egmt("comChannel.delete"),
    egmt("comChannel.delete_warning"),
    egmt("comChannel.add"),
    egmt("comChannel.save")
)
--gamemodes/egmrp/gamemode/modules/comlink/cl_comlink_gui.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--          Client | Comlink         --
---------------------------------------

-- Closes the comlink gui.
function Comlink:Close()
	if IsValid(self.Frame) then
		self.Frame:Remove()
	end
end

-- Opens the comlink gui.
function Comlink:OpenMenu()
	self:Close()

	local w, h = ScrW(), ScrH()

	local ply = LocalPlayer()
	if not ply:IsComlinkEnabled() then return end

	self.Frame = vgui.Create("EGMSmallFrame")
	self.Frame:SetCustomTitle(egmt("comlink.category"))

	local listView = vgui.Create("EGMListView", self.Frame)
	listView:DockMargin(w * 0.005, h * 0.005, w * 0.005, 0)
	listView:Dock(FILL)
	listView:SetHeaderHeight(0)
	listView:SetDataHeight(h * 0.03)
	listView:SetSortable(false)
	listView:SetMultiSelect(false)
	listView:SetHeaderFont("EGMText10")
	listView:SetDataFont("EGMText10")
	listView:AddCustomColumn("")
	function listView:OnRowSelected(index, line)
		local channelId = line.Id
		local comlinkData = line.ComlinkData

		local contextMenu = DermaMenu()

		-- Add Join/Leave Active Channel Option
		local activeComlinkChannel = ply:GetActiveComlinkChannel()
		if activeComlinkChannel == channelId then
			contextMenu:AddOption(egmt("comlink.leave_active"), function()
				Comlink:LeaveChannel(channelId)
			end):SetImage("icon16/door_out.png")
		else
			contextMenu:AddOption(egmt("comlink.join_active"), function()
				Comlink:EnterChannel(true, channelId)
			end):SetImage("icon16/door_in.png")
		end

		-- Add Join/Leave Passive Channel Option
		local passiveChannels = ply:GetPassiveComlinkChannels()
		if istable(passiveChannels) and passiveChannels[channelId] then
			contextMenu:AddOption(egmt("comlink.leave_passive"), function()
				Comlink:LeaveChannel(channelId)
			end):SetImage("icon16/door_out.png")
		else
			contextMenu:AddOption(egmt("comlink.join_passive"), function()
				Comlink:EnterChannel(false, channelId)
			end):SetImage("icon16/door_in.png")
		end

		contextMenu:AddSpacer()

		-- Add Copy Password Option
		local password = comlinkData.Password
		if isstring(password) and password ~= "" then
			contextMenu:AddOption(egmt("comlink.copy_password"), function()
				SetClipboardText(password)
			end):SetImage("icon16/paste_plain.png")
		end

		-- Add Remove Channel Option for dynamic channels.
		if string.StartsWith(channelId, "dynamic_") then
			contextMenu:AddOption(egmt("comlink.remove_channel"), function()
				Comlink:RemoveChannel(channelId)
			end):SetImage("icon16/delete.png")
		end

		contextMenu:Open()
	end

	-- Add all channels to the list.
	local channels = ply:GetComlinkChannels()
	for channelId, comlinkData in SortedPairs(channels, true) do
		local line = listView:AddCustomLine(comlinkData.Name)

		line.Id = channelId
		line.ComlinkData = comlinkData
	end

	local passwordPanel = vgui.Create("DPanel", self.Frame)
	passwordPanel:SetHeight(h * 0.03)
	passwordPanel:DockMargin(w * 0.005, h * 0.005, w * 0.005, h * 0.005)
	passwordPanel:Dock(BOTTOM)

	local passwordField = vgui.Create("DTextEntry", passwordPanel)
	passwordField:Dock(FILL)
	passwordField:SetFont("EGMText6")
	passwordField:SetPlaceholderText(egmt("comlink.password"))
	function passwordField:OnEnter(value)
		if value == "" then return end

		Comlink:EnterPassword(value)
	end

	local passwordButton = vgui.Create("EGMButton", passwordPanel)
	passwordButton:SetWide(w * 0.05)
	passwordButton:Dock(RIGHT)
	passwordButton:SetText(egmt("comlink.unlock"))
	passwordButton:SetFont("EGMText6")
	function passwordButton:DoClick()
		Comlink:EnterPassword(passwordField:GetValue())
	end

	self.ListView = listView
	self.PasswordPanel = passwordPanel
	self.PasswordField = passwordField
	self.PasswordButton = passwordButton

	self.Frame:MakePopup()
end
--gamemodes/egmrp/gamemode/modules/comlink/cl_ui.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2024          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--         Client | Comlink UI       --
---------------------------------------

Comlink.ClientsShowing = Comlink.ClientsShowing or {}

function Comlink:CreateCustomVoiceGui()
	customVoiceGui = Comlink.CustomVoiceGui

	if not IsValid(customVoiceGui) then
		customVoiceGui = vgui.Create("DPanel")

		customVoiceGui:ParentToHUD()
		customVoiceGui:SetSize(ScrW() * 0.15, ScrH() * 0.8)
		customVoiceGui:SetPos(ScrW() * 0.84, ScrH() * 0.1)
		customVoiceGui:SetPaintBackground(false)

		Comlink.CustomVoiceGui = customVoiceGui
	end
end

hook.Add("InitPostEntity", "Comlink.DrawCustomUI", Comlink.CreateCustomVoiceGui)

hook.Add("PlayerStartVoice", "Comlink.DrawCustomUI", function(talker)
	local listener = LocalPlayer()
	if talker == listener then return end

	local talkerChannel = talker:GetNWString("ActiveComlinkChannel", "")
	if talkerChannel == "" then return end

	if listener:IsComlinkListening(talkerChannel) then
		local voicePanel = Comlink.CustomVoiceGui:Add("EGMVoicePanel")
		voicePanel:Setup(talker)
		voicePanel.Color = UI.BackgroundColor

		Comlink.ClientsShowing[talker] = voicePanel

		return true
	end
end)

hook.Add("PlayerEndVoice", "Comlink.DrawCustomUI", function(talker)
	local voicePanel = Comlink.ClientsShowing[talker]

	if IsValid(voicePanel) then
		voicePanel:Remove()

		Comlink.ClientsShowing[talker] = nil
	end
end)
--gamemodes/starwarsrp/gamemode/modules/inventory_bonemerge/sh_index.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--    Index | Inventory BoneMerge    --
---------------------------------------

if not RequireModules({"inventory", "bonemerge", "base_model"}) then
	return false
end

InventoryBoneMerge = InventoryBoneMerge or {}

if SERVER then
	AddCSLuaFile("sh_inventory_bonemerge.lua")
	AddCSLuaFile("cl_inventory_bonemerge.lua")
	AddCSLuaFile("cl_corpse.lua")

	include("sh_inventory_bonemerge.lua")
	include("sv_inventory_bonemerge.lua")
	include("sv_corpse.lua")
	include("sv_net.lua")
end

if CLIENT then
	include("sh_inventory_bonemerge.lua")
	include("cl_inventory_bonemerge.lua")
	include("cl_corpse.lua")
end
--gamemodes/egmrp/gamemode/modules/bonemerge/cl_corpse.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--         Client | BoneMerge        --
---------------------------------------

-- Update the bone merged entities on a corpse.
--
-- @param Entity ent
-- @param Boolean shouldtransmit
function BoneMerge:UpdateCorpse(ent, shouldtransmit)
	if ent:GetClass() ~= "prop_ragdoll" and ent:GetClass() ~= "prop_dynamic" then return end

	local sourceRagdoll = ent
	if ent:GetClass() == "prop_dynamic" then
		sourceRagdoll = ent:GetOwner()

		-- TODO: Might need the ragdoll to move with the carrying player.
		if not IsValid(sourceRagdoll) then return end
	end

	-- If the entity is being removed from the client's PVS, detach all models.
	if not shouldtransmit then
		BoneMerge:DetachAll(ent)

		return
	end

	local currentCharacterId = sourceRagdoll:GetNW2Int("CurrentCharacterId", -1)
	local char = Character:GetCached(currentCharacterId)

	-- If the character is valid, the player has not respawned yet.
	if char then
		for id, modelData in pairs(BoneMerge.CharacterModels) do
			local model = modelData.GetModel(char)
			if not isstring(model) then continue end

			-- Add the new model.
			local success, clientEnt = BoneMerge:Attach(ent, id, model)
			if not success then continue end

			-- Apply the model.
			local applyModel = modelData.ApplyModel
			if isfunction(applyModel) then
				applyModel(char, clientEnt)
			end
		end

		return
	end

	-- If the character is not valid, the player has respawned.
	for id, modelData in pairs(BoneMerge.CharacterModels) do
		local model = hook.Run("BoneMerge.GetRespawnedCorpseModel", sourceRagdoll, id)
		if not isstring(model) then
			-- Detach the current model.
			BoneMerge:Detach(ent, id)

			continue
		end

		-- Add the new model.
		local success, clientEnt = BoneMerge:Attach(ent, id, model)
		if not success then continue end

		-- Apply the model.
		hook.Run("BoneMerge.ApplyRespawnedCorpseModel", sourceRagdoll, id, clientEnt)
	end
end

-- Update the bone merged entities on a corpse when the entity is being removed or added to the client's PVS.
hook.Add("NotifyShouldTransmit", "BoneMerge.OnPVSCorpse", function(ent, shouldtransmit)
	BoneMerge:UpdateCorpse(ent, shouldtransmit)
end)
--gamemodes/starwarsrp/gamemode/modules/base_model/sh_index.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--         Index | Base Model        --
---------------------------------------

if not RequireModules({"bodygroups", "inventory"}) then
	return false
end

BaseModel = BaseModel or {}

if SERVER then
	AddCSLuaFile("sh_base_model.lua")
	AddCSLuaFile("cl_base_model.lua")

	AddCSLuaFile("sh_inventory_integration.lua")
	AddCSLuaFile("cl_inventory_integration.lua")

	AddCSLuaFile("cl_corpse_integration.lua")

	include("sh_base_model.lua")
	include("sv_base_model.lua")

	include("sh_inventory_integration.lua")
	include("sv_inventory_integration.lua")

	include("sv_corpse_integration.lua")
end

if CLIENT then
	include("sh_base_model.lua")
	include("cl_base_model.lua")

	include("sh_inventory_integration.lua")
	include("cl_inventory_integration.lua")

	include("cl_corpse_integration.lua")
end
--gamemodes/starwarsrp/gamemode/modules/base_model/sh_base_model.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Shared | Base Model        --
---------------------------------------

-- Add faction property: materialSets
Faction:AddProperty("materialSets", "table", {}, function(faction, value)
	if not istable(value) then
		return false, egmt("shared.invalid_type")
	end

	return true
end,
function(faction, ply)
	return true
end)

-- Get the material sets for a faction.
--
-- @return Table materialSets
function Faction.Meta:GetMaterialSets()
	local materialSets = table.Copy(self:GetProperty("materialSets", {}))

	local parent = self:GetParent()
	if parent then
		MergeTableByValue(materialSets, parent:GetMaterialSets())
	end

	return materialSets
end

-- Add faction property: bmBodygroups
Faction:AddProperty("bmBodygroups", "table", {}, function(faction, value)
	if not istable(value) then
		return false, egmt("shared.invalid_type")
	end

	return true
end,
function(faction, ply)
	return true
end)

-- Get the Base Model Bodygroups for a faction.
--
-- @return Table bmBodygroups
function Faction.Meta:GetBaseModelBodygroups()
	local bmBodygroups = table.Copy(self:GetProperty("bmBodygroups", {}))

	local parent = self:GetParent()
	if parent then
		MergeTableByValue(bmBodygroups, parent:GetBaseModelBodygroups())
	end

	return bmBodygroups
end

-- Add rank property: materialSets
Rank:AddProperty("materialSets", "table", {}, function(rank, value)
	if not istable(value) then
		return false, egmt("shared.invalid_type")
	end

	return true
end,
function(rank, ply)
	return true
end)

-- Get the material sets for a rank.
--
-- @return Table materialSets
function Rank.Meta:GetMaterialSets()
	return self:GetProperty("materialSets", {})
end

-- Add rank property: bmBodygroups
Rank:AddProperty("bmBodygroups", "table", {}, function(rank, value)
	if not istable(value) then
		return false, egmt("shared.invalid_type")
	end

	return true
end,
function(rank, ply)
	return true
end)

-- Get the Base Model Bodygroups for a rank.
--
-- @return Table bmBodygroups
function Rank.Meta:GetBaseModelBodygroups()
	return self:GetProperty("bmBodygroups", {})
end

-- Add Equipment property: materialSets
Equipment:AddProperty("materialSets", "table", {}, function(equipment, value)
	if not istable(value) then
		return false, egmt("shared.invalid_type")
	end

	return true
end,
function(equipment, ply)
	return true
end)

-- Get the material sets for a equipment.
--
-- @return Table materialSets
function Equipment.Meta:GetMaterialSets()
	return self:GetProperty("materialSets", {})
end

-- Add Equipment property: bmBodygroups
Equipment:AddProperty("bmBodygroups", "table", {}, function(equipment, value)
	if not istable(value) then
		return false, egmt("shared.invalid_type")
	end

	return true
end,
function(equipment, ply)
	return true
end)

-- Get the Base Model Bodygroups for a equipment.
--
-- @return Table bmBodygroups
function Equipment.Meta:GetBaseModelBodygroups()
	return self:GetProperty("bmBodygroups", {})
end

-- Returns the material sets of a character by the given faction, rank and equipment.
--
-- @param Faction faction
-- @param Rank rank
-- @param Table relevantEquipment
-- @return Table materialSets
function Character:GetValidMaterialSets(faction, rank, relevantEquipment)
	local validMaterialSets = {}

	-- Load material sets from faction.
	if faction then
		validMaterialSets = faction:GetMaterialSets()
	end

	-- Load material sets from rank apply the blacklist filter, to remove models, that are blacklisted by the rank.
	if rank then
		local rankMaterialSets = rank:GetMaterialSets()
		MergeTableByValue(validMaterialSets, rankMaterialSets)
		validMaterialSets = FilterBlacklist(validMaterialSets)
	end

	-- Load material sets from the equipment or remove them from the valid material sets, if they are blacklisted.
	local equipBlacklist = {}
	for _, equip in pairs(relevantEquipment) do
		local equipMaterialSets = equip:GetMaterialSets()
		if equip:GetProperty("blacklist", false) then
			MergeTableByValue(equipBlacklist, equipMaterialSets)
		else
			MergeTableByValue(validMaterialSets, equipMaterialSets)
		end
	end
	for _, equipMaterialSet in pairs(equipBlacklist) do
		table.RemoveByValue(validMaterialSets, equipMaterialSet)
	end

	local transformedValidMaterialSets = {}
	for _, materialSet in pairs(validMaterialSets) do
		local splitMaterialSet = string.Split(materialSet, ".mdl_")
		if #splitMaterialSet == 2 then
			table.insert(transformedValidMaterialSets, {
				Model = splitMaterialSet[1] .. ".mdl",
				Id = splitMaterialSet[2],
			})
		end

		-- Default skin material set.
		if #splitMaterialSet == 1 then
			table.insert(transformedValidMaterialSets, {
				Model = splitMaterialSet[1],
				Id = 0,
			})
		end
	end

	return transformedValidMaterialSets
end

-- Get the material sets for a character.
--
-- @return Table materialSets
function Character.Meta:GetValidMaterialSets()
	local faction = self:GetFaction()
	local rank = self:GetRank()
	local relevantEquipment = self:GetRelevantEquipment()

	return Character:GetValidMaterialSets(faction, rank, relevantEquipment)
end

-- Get the valid base model bodygroups for a character.
--
-- @return Table validBMBodygroups
function Character.Meta:GetValidBMBodygroups()
	local validBMBodygroups = {}

	-- Load material sets from faction.
	local faction = self:GetFaction()
	if faction then
		validBMBodygroups = faction:GetBaseModelBodygroups()
	end

	-- Load material sets from rank apply the blacklist filter, to remove models, that are blacklisted by the rank.
	local rank = self:GetRank()
	if rank then
		local rankBMBodygroups = rank:GetBaseModelBodygroups()
		MergeTableByValue(validBMBodygroups, rankBMBodygroups)
		validBMBodygroups = FilterBlacklist(validBMBodygroups)
	end

	-- Load material sets from the equipment or remove them from the valid material sets, if they are blacklisted.
	local equipBlacklist = {}
	local relevantEquipment = self:GetRelevantEquipment()
	for _, equip in pairs(relevantEquipment) do
		local equipBMBodygroups = equip:GetBaseModelBodygroups()
		if equip:GetProperty("blacklist", false) then
			MergeTableByValue(equipBlacklist, equipBMBodygroups)
		else
			MergeTableByValue(validBMBodygroups, equipBMBodygroups)
		end
	end
	for _, equipBMBodygroup in pairs(equipBlacklist) do
		table.RemoveByValue(validBMBodygroups, equipBMBodygroup)
	end

	hook.Run("Character.GetValidBMBodygroups", self, validBMBodygroups)
	hook.Run("Character.RemoveValidBMBodygroups", self, validBMBodygroups)

	return validBMBodygroups
end

-- Get the valid base model bodygroups for a character and a model.
--
-- @param String model
-- @return Table bodygroups
function Character.Meta:GetValidBodygroups(model)
	local baseModelData = BaseModel:GetBaseModel(model)
	if not istable(baseModelData) then return {} end

	local baseModelGroups = baseModelData.Bodygroups
	if not istable(baseModelGroups) or #baseModelGroups == 0 then return {} end

	local bodygroups = {}
	local bmBodygroups = self:GetValidBMBodygroups()
	for _, bmBodygroup in pairs(bmBodygroups) do
		local splitData = string.Split(bmBodygroup, ".mdl_")
		if #splitData ~= 2 then continue end

		local bmModel = splitData[1] .. ".mdl"
		if bmModel ~= model then continue end

		local bodyGroupName = splitData[2]

		for _, bodyGroup in pairs(baseModelGroups) do
			if bodyGroup.name ~= bodyGroupName then continue end

			table.insert(bodygroups, bodyGroup.id)

			break
		end
	end

	return bodygroups
end



---------------------------------------
--           Base Functions          --
---------------------------------------

-- Get the base model data for a model.
--
-- @param String model
-- @return Table baseModelData
function BaseModel:GetBaseModel(model)
	self.BaseModels = self.BaseModels or {}
	local baseModelData = self.BaseModels[model]
	if not istable(baseModelData) then
		return
	end

	return baseModelData
end

-- Register a new Base Model.
--
-- @param String model
-- @param Table materialMapping
-- @return Boolean success
-- @return? String err
function BaseModel:RegisterBaseModelInternal(model, materialMapping)
	-- print("\nRegisterBaseModelInternal", model, materialMapping)

	if not util.IsValidModel(model) then
		return false, "Invalid Model (" .. model .. ")"
	end

	if not istable(materialMapping) or table.Count(materialMapping) == 0 then
		return false, "Invalid Material Map (" .. model .. ")"
	end

	local temp
	if CLIENT then
		temp = ClientsideModel(model)
	end
	if SERVER then
		temp = ents.Create("prop_dynamic")
		temp:SetModel(model)
	end

	if not IsValid(temp) then
		SafeRemoveEntity(temp)

		return false, "Invalid Model (" .. model .. ")"
	end

	if temp:SkinCount() > 1 then
		SafeRemoveEntity(temp)

		return false, "Skin Count > 1 (" .. model .. ")"
	end

	local defaultMaterials = temp:GetMaterials()
	if not istable(defaultMaterials) then
		return false, "Invalid Materials (" .. model .. ")"
	end

	local bodygroups = temp:GetBodyGroups()
	if not istable(bodygroups) then
		return false, "Invalid Bodygroups (" .. model .. ")"
	end

	SafeRemoveEntity(temp)

	local materialMap = {}
	for id, material in pairs(materialMapping) do
		if not isstring(material) then continue end

		local key = table.KeyFromValue(defaultMaterials, material)
		if not key then
			continue
		end

		materialMap[id] = key
	end

	if table.Count(materialMap) ~= table.Count(materialMapping) then
		return false, "Invalid Material Mapping (" .. model .. ")"
	end

	local baseModelData = {
		Model = model,
		Bodygroups = bodygroups,

		MaterialMap = materialMap,

		MaterialSets = {}
	}

	self.BaseModels = self.BaseModels or {}
	self.BaseModels[model] = baseModelData

	return true
end

-- External function to register a new Base Model.
--
-- @param String model
-- @param Table materialMap
function BaseModel:RegisterBaseModel(model, materialMap)
	local success, err = self:RegisterBaseModelInternal(model, materialMap)
	if not success then
		LogWarning("RegisterBaseModel: " .. err)

		return
	end
end

-- Register a material set for a Base Model.
--
-- @param String model
-- @param String materialSetId
-- @param String materialSetName
-- @return Boolean success
-- @return? String err
function BaseModel:RegisterMaterialSetInternal(model, materialSetId, materialSetName, materials)
	-- print("\nRegisterMaterialSetInternal", model, materialSetId, materialSetName, materials)

	if not util.IsValidModel(model) then
		return false, "Invalid Model (" .. model .. ")"
	end

	self.BaseModels = self.BaseModels or {}
	local baseModelData = self:GetBaseModel(model)
	if not istable(baseModelData) then
		return false, "Invalid Model Id (" .. model .. ")"
	end

	if not isstring(materialSetId) or materialSetId == "" then
		return false, "Invalid Material Set Id (" .. model .. ", " .. materialSetId .. ")"
	end

	if string.find(materialSetId, "|") then
		return false, "Material Set Id contains invalid character (" .. model .. ", " .. materialSetId .. ")"
	end

	if not isstring(materialSetName) or materialSetName == "" then
		return false, "Invalid Material Set Name (" .. model .. ", " .. materialSetId .. ")"
	end

	if not istable(materials) or table.Count(materials) == 0 then
		return false, "Invalid Materials (" .. model .. ", " .. materialSetId .. ")"
	end

	local translatedMaterials = {}
	for id, material in pairs(materials) do
		if not isstring(material) then continue end

		local key = baseModelData.MaterialMap[id]
		if not key then continue end

		translatedMaterials[key] = material
	end

	if table.Count(translatedMaterials) ~= table.Count(materials) then
		return false, "Invalid Material Mapping (" .. model .. ", " .. materialSetId .. ")"
	end

	local materialSetData = {
		Id = materialSetId,
		Name = materialSetName,

		Materials = translatedMaterials,
	}

	baseModelData.MaterialSets[materialSetId] = materialSetData

	return true
end

-- External function to register a material set for a Base Model.
--
-- @param String model
-- @param String materialSetId
-- @param String materialSetName
-- @param Table materials
function BaseModel:RegisterMaterialSet(model, materialSetId, materialSetName, materials)
	local success, err = self:RegisterMaterialSetInternal(model, materialSetId, materialSetName, materials)
	if not success then
		LogWarning("RegisterMaterialSet: " .. err)

		return
	end
end

-- Add Hooks for Registering Base Models and Material Sets.
hook.Add("EGMRP.Loaded", "BaseModel.RegisterObjects", function()
	hook.Run("BaseModel.RegisterBaseModels")
	hook.Run("BaseModel.RegisterMaterialSets")
end)



---------------------------------------
--            Application            --
---------------------------------------

-- Apply a base model to an entity.
--
-- @param Entity ent
-- @param String model
-- @param String materialSetId
-- @return Boolean success
-- @return String error
function BaseModel:ApplyBaseModel(ent, model, materialSetId)
	local baseModelData = BaseModel:GetBaseModel(model)
	if not istable(baseModelData) then
		if string.EndsWith(model, "_item.mdl") then
			local model2 = string.sub(model, 1, -10) .. ".mdl"
			baseModelData = BaseModel:GetBaseModel(model2)
			if not istable(baseModelData) then
				self:ResetMaterialOverrides(ent)

				return false, "Invalid Model"
			end
		else
			self:ResetMaterialOverrides(ent)

			return false, "Invalid Model"
		end
	end

	local materialSetData = baseModelData.MaterialSets[materialSetId]
	if not istable(materialSetData) then
		self:ResetMaterialOverrides(ent)

		return false, "Invalid Material Set"
	end

	local materials = materialSetData.Materials
	if not istable(materials) then
		self:ResetMaterialOverrides(ent)

		return false, "Invalid Materials"
	end

	ent:SetModel(model)

	-- Apply the materials.
	for i, _ in ipairs(ent:GetMaterials()) do
		local targetMaterial = materials[i]
		if isstring(targetMaterial) then
			ent:SetSubMaterial(i - 1, targetMaterial)
		else
			ent:SetSubMaterial(i - 1, "")
		end
	end

	return true
end

-- Reset Material Overrides.
--
-- @param Entity ent
function BaseModel:ResetMaterialOverrides(ent)
	-- Reset the materials.
	for i, _ in ipairs(ent:GetMaterials()) do
		ent:SetSubMaterial(i - 1, "")
	end
end



---------------------------------------
--               Hooks               --
---------------------------------------

-- Add Material Sets to the valid skins.
hook.Add("Character.GetValidSkins", "BaseModel.AddMaterialSets", function(char, model, faction, rank, relevantEquipment, validSkins)
	local baseModelData = BaseModel:GetBaseModel(model)
	if not istable(baseModelData) then return end

	local validMaterialSets = Character:GetValidMaterialSets(faction, rank, relevantEquipment)
	for _, materialSetData in pairs(validMaterialSets) do
		if materialSetData.Model ~= model then continue end
		if isnumber(materialSetData.Id) then continue end

		table.insert(validSkins, materialSetData.Id)
	end
end)

-- Remove the default skin from the valid skins.
hook.Add("Character.RemoveValidSkins", "BaseModel.FilterMaterialSets", function(char, model, faction, rank, relevantEquipment, validSkins)
	local baseModelData = BaseModel:GetBaseModel(model)
	if not istable(baseModelData) then return end

	local validMaterialSets = Character:GetValidMaterialSets(faction, rank, relevantEquipment)

	-- Search for the default skin and return if a material set is found.
	for _, materialSetData in pairs(validMaterialSets) do
		if materialSetData.Model ~= model then continue end
		if materialSetData.Id == 0 then
			return
		end
	end

	-- If not found, remove the default skin.
	table.RemoveByValue(validSkins, 0)
end)

-- Allow Material Sets to be used as model skin values.
hook.Add("Character.OverrideSkinValid", "BaseModel.AllowMaterialSets", function(character, model, skinId)
	if not isstring(skinId) then return end

	-- Check if the model is a base model.
	local baseModelData = BaseModel:GetBaseModel(model)
	if not istable(baseModelData) then
		return false, "No Material Set Model"
	end

	-- Check if the skinId is a material set.
	local materialSetData = baseModelData.MaterialSets[skinId]
	if not istable(materialSetData) then
		return false, "Invalid Material Set"
	end

	return true
end)

-- Add material sets to the effect list.
hook.Add("Equipment.GetEffectList", "BaseModel.EquipmentEffect", function(equip, effectList)
	local materialSets = equip:GetMaterialSets()
	if not istable(materialSets) then return end

	local bodygroups = equip:GetBaseModelBodygroups()
	if not istable(bodygroups) then return end

	local blacklist = equip:GetProperty("blacklist", false)

	if table.Count(materialSets) > 0 then
		if blacklist then
			table.insert(effectList, "MS-")
		else
			table.insert(effectList, "MS+")
		end
	end

	if table.Count(bodygroups) > 0 then
		if blacklist then
			table.insert(effectList, "BG-")
		else
			table.insert(effectList, "BG+")
		end
	end
end)
--gamemodes/starwarsrp/gamemode/modules/base_model/cl_base_model.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Client | Base Model        --
---------------------------------------

-- Get all material sets for a list of models.
--
-- @param table models
-- @param boolean forceAll
-- @return materialSets
function BaseModel:GetMaterialSets(models, forceAll)
	local materialSets = {}
	local materialSetIds = {}

	local playerModels = player_manager.AllValidModels()

	-- Add Material Sets using playermodels first.
	for _, model in pairs(models) do
		if not table.HasValue(playerModels, model) then continue end

		local baseModelData = BaseModel:GetBaseModel(model)
		if not istable(baseModelData) then
			continue
		end

		local modelName = player_manager.TranslateToPlayerModelName(model)
		local override = hook.Run("BaseModel.OverrideModelName", model, modelName)
		if isstring(override) then
			modelName = override
		end

		materialSets[modelName] = model

		for materialSetId, materialSetData in pairs(baseModelData.MaterialSets) do
			if materialSetIds[materialSetId] and not forceAll then continue end
			materialSetIds[materialSetId] = true

			materialSets[materialSetData.Name] = model .. "_" .. materialSetId
		end
	end

	-- Add the rest of the material sets.
	for _, model in pairs(models) do
		if table.HasValue(playerModels, model) then continue end

		local baseModelData = BaseModel:GetBaseModel(model)
		if not istable(baseModelData) then
			continue
		end

		local modelName = player_manager.TranslateToPlayerModelName(model)
		local override = hook.Run("BaseModel.OverrideModelName", model, modelName)
		if isstring(override) then
			modelName = override
		end

		if forceAll then
			materialSets[modelName] = model
		end

		for materialSetId, materialSetData in pairs(baseModelData.MaterialSets) do
			if materialSetIds[materialSetId] and not forceAll then continue end
			materialSetIds[materialSetId] = true

			materialSets[materialSetData.Name] = model .. "_" .. materialSetId
		end
	end

	table.sort(materialSets)

	return materialSets
end

Faction:AddPropertyToList("materialSets", "Material Sets", "Material Gruppen, die die benutzten Texturen auf einem Basemodel ändern.", "models", function(faction)
	local models = faction:GetModels()
	hook.Run("BaseModel.AddMaterialSetModels", models, faction, nil, nil)

	local materialSets = BaseModel:GetMaterialSets(models)

	local parentMaterialSets = {}
	local parent = faction:GetParent()
	if parent then
		parentMaterialSets = parent:GetMaterialSets()
	end

	return {
		validModels = materialSets,
		inheritedModels = parentMaterialSets,
	}
end, nil, 3, egmt("equipment.category"))

Rank:AddPropertyToList("materialSets", "Material Sets", "Material Gruppen, die die benutzten Texturen auf einem Basemodel ändern.", "models", function(faction, rank)
	local models = faction:GetModels()
	MergeTableByValue(models, rank:GetModels())
	hook.Run("BaseModel.AddMaterialSetModels", models, faction, rank, nil)

	local materialSets = BaseModel:GetMaterialSets(models)

	local factionMaterialSets = faction:GetMaterialSets()

	return {
		validModels = materialSets,
		inheritedModels = factionMaterialSets,
	}
end, nil, 3, egmt("equipment.category"))

Equipment:AddPropertyToList("materialSets", "Material Sets", "Material Gruppen, die die benutzten Texturen auf einem Basemodel ändern.", "models", function(faction, equipment)
	local models = faction:GetModels()
	MergeTableByValue(models, equipment:GetModels())
	hook.Run("BaseModel.AddMaterialSetModels", models, faction, nil, equipment)

	local materialSets = BaseModel:GetMaterialSets(models)

	return {
		validModels = materialSets,
		inheritedModels = {},
	}
end, nil, 3, egmt("equipment.category"))

-- Get all base model bodygroups available for a list of models.
--
-- @param table models
-- @return bmBodygroups
function BaseModel:GetBaseModelBodygroups(models)
	local bmBodygroups = {}

	for _, model in pairs(models) do
		local baseModelData = BaseModel:GetBaseModel(model)
		if not istable(baseModelData) then
			continue
		end

		for _, bmBodygroup in pairs(baseModelData.Bodygroups) do
			if bmBodygroup.num <= 1 then
				continue
			end

			local skip = hook.Run("BaseModel.RestrictBodyGroup", model, bmBodygroup)
			if skip then
				continue
			end

			local modelName = player_manager.TranslateToPlayerModelName(model)
			local overrideName = hook.Run("BaseModel.OverrideModelName", model, modelName)
			if isstring(overrideName) then
				modelName = overrideName
			end

			bmBodygroups[model .. "_" .. bmBodygroup.name] = modelName .. " | " .. bmBodygroup.name
		end
	end

	return bmBodygroups
end

Faction:AddPropertyToList("bmBodygroups", "Bodygroups", "Bodygroups, die auf einem Basemodel oder Bone Merge Model verfügbar sind.", "table", function(faction)
	local models = faction:GetModels()

	hook.Run("BaseModel.AddBodygroupModels", models, faction, nil, nil)

	local values = {
		validValues = BaseModel:GetBaseModelBodygroups(models)
	}

	local parent = faction:GetParent()
	if parent then
		values.inheritedValues = parent:GetBaseModelBodygroups()
	end

	return values
end, nil, 4, egmt("equipment.category"))

Rank:AddPropertyToList("bmBodygroups", "Bodygroups", "Bodygroups, die auf einem Basemodel oder Bone Merge Model verfügbar sind.", "table", function(faction, rank)
	local models = faction:GetModels()
	MergeTableByValue(models, rank:GetModels())

	hook.Run("BaseModel.AddBodygroupModels", models, faction, rank, nil)

	local values = {
		validValues = BaseModel:GetBaseModelBodygroups(models)
	}

	local factionValues = faction:GetBaseModelBodygroups()
	if istable(factionValues) then
		values.inheritedValues = factionValues
	end

	return values
end, nil, 4, egmt("equipment.category"))

Equipment:AddPropertyToList("bmBodygroups", "Bodygroups", "Bodygroups, die auf einem Basemodel oder Bone Merge Model verfügbar sind.", "table", function(faction, equipment)
	local models = faction:GetModels()
	MergeTableByValue(models, equipment:GetModels())

	hook.Run("BaseModel.AddBodygroupModels", models, faction, nil, equipment)

	local values = {
		validValues = BaseModel:GetBaseModelBodygroups(models)
	}

	return values
end, nil, 4, egmt("equipment.category"))



---------------------------------------
--               Hooks               --
---------------------------------------

-- Override the setting of a model to set the base model and skin id.
hook.Add("EGMModelPanel.SetModelSkin", "BaseModel.OverrideMaterialSet", function(panel, model, skinId)
	if isstring(skinId) then
		local ent = panel.Entity
		if IsValid(ent) then
			ent:SetModel(model)

			ent:SetNoDraw(true)
			ent:SetIK(false)

			local iSeq = ent:LookupSequence( "walk_all" )
			if ( iSeq > 0 ) then ent:ResetSequence( iSeq ) end

			BaseModel:ApplyBaseModel(ent, model, skinId)
		end

		return true
	end
end)

-- Override the setting of a model to set the base model and skin id.
-- Used for the material sets in the managemer, to allow reuse of the models type.
hook.Add("EGMModelIcon.OverrideSetModel", "BaseModel.OverrideMaterialSet", function(panel, model, skinId)
	local splitModel = string.Split(model, ".mdl_")
	if #splitModel < 2 then
		return
	end

	panel.Model = splitModel[1] .. ".mdl"
	panel.SkinId = splitModel[2]

	return true
end)

-- Override displaying the base material sets correctly.
hook.Add("EGMModelIcon.OverrideModel", "BaseModel.OverrideMaterialSet", function(model, skinId, ent)
	if not IsValid(ent) then
		return
	end

	if not isstring(skinId) then
		return
	end

	BaseModel:ApplyBaseModel(ent, model, skinId)
end)

-- Restrict the available bodygroups for the base models.
hook.Add("BodyGroups.RestrictBodyGroup", "BaseModel.RestrictBodyGroups", function(char, model, skinId, bodyGroup)
	local baseModelData = BaseModel:GetBaseModel(model)
	if not istable(baseModelData) then return end

	-- Make sure you can't change the bodygroups of the base model.
	local currentArmor = Inventory:GetCurrentArmor(char)
	if currentArmor then
		local validBodygroups = currentArmor.ValidBodygroups
		if istable(validBodygroups) and table.HasValue(validBodygroups, bodyGroup.id) then
			return
		end

		return true
	end

	local bodygroups = char:GetValidBodygroups(model)
	if not table.HasValue(bodygroups, bodyGroup.id) then
		return true
	end
end)
--gamemodes/starwarsrp/gamemode/modules/inventory_bonemerge/item_classes/bonemerge/cl_init.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--      Client | BoneMerge Item      --
---------------------------------------

local ITEM_CLASS = ITEM_CLASS

-- Display name for the type used in UI elements.
ITEM_CLASS.Name = "BoneMerge Base"

-- List of properties that should be shown in the manager, if this item class is used.
ITEM_CLASS.PropertyList = {"models", "materialSets", "requiredArmor"}

-- Callback run, when the item is equipped.
--
-- @param Player ply
-- @param Character char
-- @param ItemType itemType
-- @param Table itemData
function ITEM_CLASS:OnEquip(ply, char, itemType, itemData)
	-- print("\n BoneMerge:OnEquip", ply, char, itemType, itemData)

	-- Only equip valid items.
	if not self:Validate(itemType, itemData) then
		return
	end

	local model = itemData.Model
	local baseModelData = InventoryBoneMerge.BaseModels[model]

	char.BoneMergeItemCache = char.BoneMergeItemCache or {}
	char.BoneMergeItemCache[baseModelData.Type] = itemData

	hook.Run("Inventory.BoneMergeItem.OnEquip", ply, char, itemType, itemData)
end

-- Callback run, when the item is unequipped.
-- Clientside this includes the item being dropped.
--
-- @param Player ply
-- @param Character char
-- @param ItemType itemType
-- @param Table itemData
function ITEM_CLASS:OnUnequip(ply, char, itemType, itemData)
	-- print("\n BoneMerge:OnUnequip", ply, char, itemType, itemData)

	-- Only unequip valid items.
	if not self:Validate(itemType, itemData) then
		return
	end

	local model = itemData.Model
	local baseModelData = InventoryBoneMerge.BaseModels[model]

	char.BoneMergeItemCache = char.BoneMergeItemCache or {}
	char.BoneMergeItemCache[baseModelData.Type] = nil

	hook.Run("Inventory.BoneMergeItem.OnUnequip", ply, char, itemType, itemData)
end

-- Create the item panel for the item.
--
-- @param Panel parent
-- @param Table itemData
function ITEM_CLASS:CreateItemPanel(parent, itemData)
	ITEM_CLASS.Base.CreateItemPanel(self, parent, itemData)
	function parent:Paint(ww, hh)
	end

	local modelIcon = vgui.Create("EGMModelIcon", parent)
	modelIcon:Dock(FILL)
	modelIcon:SetMouseInputEnabled(false)

	modelIcon:SetModel(itemData.Model, itemData.SkinId)

	-- Set the display type for the model icon.
	local baseModelData = InventoryBoneMerge.BaseModels[itemData.Model]
	if istable(baseModelData) then
		modelIcon:SetDisplayType(baseModelData.Type)
	end

	modelIcon:SetSize(math.floor(ScrW() * 0.05), math.floor(ScrW() * 0.05))
	modelIcon:GenerateIcon()

	parent.ModelIcon = modelIcon
end



---------------------------------------
--              Tooltip              --
---------------------------------------

-- Callback run, when the item is showing in the inventory tooltip.
--
-- @param ItemType itemType
-- @param Table itemData
-- @param Table lines
function ITEM_CLASS:AddDescriptionLines(itemType, itemData, lines)
	table.insert(lines, {
		Text = itemType:GetName(),
		Color = UI.ForegroundColor2,
		Align = TEXT_ALIGN_LEFT
	})

	local model = itemData.Model

	local skinCount = GetModelSkinCount(model)
	if skinCount > 1 then
		local skinId = itemData.SkinId or 0

		if isnumber(skinId) then
			table.insert(lines, {
				Text = egmt("inventory.armour_variant", skinId + 1, skinCount),
				Color = UI.ForegroundColor2,
				Align = TEXT_ALIGN_LEFT
			})
		end
	end

	local itemBodygroups = itemData.Bodygroups or {}
	if table.Count(itemBodygroups) > 0 then
		table.insert(lines, {})

		local ent = ClientsideModel(model)
		local bodygroups = ent:GetBodyGroups()
		ent:Remove()

		for id, data in pairs(bodygroups) do
			local value = itemBodygroups[id - 1] or 0
			if value == 0 then continue end

			table.insert(lines, {
				Text = "- " .. data.name,
				Color = UI.TextColor,
				Align = TEXT_ALIGN_LEFT
			})
		end
	end
end
--gamemodes/egmrp/gamemode/modules/extrarank/cl_scoreboard.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Client | Extra Rank        --
---------------------------------------

Scoreboard:AddOption(
	egmt("extra_rank.promote_demote"),
	"icon16/award_star_gold_2.png",
	750,
	function(target)
		local targetCharacter = target:GetCurrentCharacter()
		if not targetCharacter then return end

		targetCharacter:OpenExtraRankMenu()
	end,
	function(target)
		local ply = LocalPlayer()

		local targetCharacter = target:GetCurrentCharacter()
		if not targetCharacter then return false end

		if not targetCharacter:ShouldHaveExtraRank() then return false end

		local extraFaction = targetCharacter:GetExtraFaction()
		if not extraFaction then return false end

		-- Only show the promote / demote button if we can promote / demote to at least one other rank.
		for k, rank in pairs(extraFaction:GetRanks()) do
			if ply:CanChangeExtraFactionRank(targetCharacter, rank:GetId(), extraFaction:GetId()) then
				return true
			end
		end

		return false
	end
)

Scoreboard:AddOption(
	egmt("extra_rank.invite"),
	"icon16/award_star_gold_2.png",
	750,
	function(target)
		local targetCharacter = target:GetCurrentCharacter()
		if not targetCharacter then return end

		targetCharacter:OpenExtraInviteMenu()
	end,
	function(target)
		local ply = LocalPlayer()

		local targetCharacter = target:GetCurrentCharacter()
		if not targetCharacter then return false end

		-- Do not show the invite button if the target is already in a faction.
		if targetCharacter:GetExtraFaction() then return false end

		local currentCharacter = ply:GetCurrentCharacter()
		if not currentCharacter then return false end

		local currentFaction = currentCharacter:GetFaction()
		if not currentFaction then return false end

		-- First Check invite to main faction
		local faction = currentCharacter:GetFaction()
		if not faction then return false end

		-- Only show the invite button if we can invite to at least one rank.
		for k, rank in pairs(faction:GetRanks()) do
			if ply:CanChangeExtraFactionRank(targetCharacter, rank:GetId(), faction:GetId(), true) then
				return true
			end
		end

		-- Check invite to extra faction
		local extraFaction = currentCharacter:GetExtraFaction()
		if not extraFaction then return false end

		-- Only show the invite button if we can invite to at least one rank.
		for k, rank in pairs(extraFaction:GetRanks()) do
			if ply:CanChangeExtraFactionRank(targetCharacter, rank:GetId(), extraFaction:GetId(), true) then
				return true
			end
		end

		return false
	end
)

Scoreboard:AddOption(
	egmt("extra_rank.kick"),
	"icon16/award_star_gold_2.png",
	750,
	function(target)
		local modal = vgui.Create("EGMModal")
		modal:SetCustomTitle(egmt("extra_rank.kick_message"))
		modal:Confirm(egmt("shared.are_you_sure"), function()
			local targetCharacter = target:GetCurrentCharacter()
			if not targetCharacter then return end

			targetCharacter:EditProperties({eFaction = -1, eRank = -1})
		end)
	end,
	function(target)
		local ply = LocalPlayer()

		local targetCharacter = target:GetCurrentCharacter()
		if not targetCharacter then return false end

		local extraFaction = targetCharacter:GetExtraFaction()
		if not extraFaction then return false end

		-- Only show the kick button if we can kick to at least one rank. (Even tho we will only remove the player from the faction)
		for _, rank in pairs(Rank:GetCache()) do
			if not rank:CanBeKickedOnto() then continue end

			if ply:CanChangeExtraFactionRank(targetCharacter, rank:GetId(), rank:GetFaction():GetId()) then
				return true
			end
		end

		return false
	end
)
--gamemodes/egmrp/gamemode/modules/developer/sh_config.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--       Developer | Config          --
---------------------------------------
--  Variables should be overwritten  --
--     in the deriving gamemode!     --
---------------------------------------

-- Unbannable, Untargetable even by Developers, For more Information see Developer.DeveloperSteamID64, BE CAREFUL
Developer.OwnerSteamID64 = "" -- Developer.OwnerSteamID64 = ""76561198152415776""

-- SteamIDs that have ALL permissions on the server. Really ALL. Be careful. Untargetable. They can even send command to the server console from their clients
Developer.DeveloperSteamID64 = {
	-- "76561198152415776", -- P4sca1
	-- "76561198066776771", -- Airfox
	-- "76561198039545371", -- Oninoni
	-- "76561198068891112" -- Mattzi
}

-- Just Shows in Chat and on Scoreboard that this Person is a developer. Would be nice if you could leave us in there.
Developer.ShowDeveloperSteamID64 = {
	"76561198152415776", -- P4sca1
	"76561198066776771", -- Airfox
	"76561198039545371", -- Oninoni
	"76561198068891112" -- Mattzi
}

-- The color developers have in chat and on scoreboard.
-- Set false if color should not be overwritten.
Developer.OverrideUserGroupColor = Color(238, 58, 140)
--gamemodes/egmrp/gamemode/modules/developer/sh_developer.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Developer | Shared         --
---------------------------------------

local Player = FindMetaTable("Player")

-- Returns, if the player is a developer with permissions.
--
-- @return Boolean isDeveloper
function Player:IsDeveloper()
	return table.HasValue(Developer.DeveloperSteamID64, self:SteamID64()) or Developer.OwnerSteamID64 == self:SteamID64()
end

-- Returns, if the player is a developer with permissions.
--
-- @param String steamid64
-- @return Boolean isDeveloper
function Developer:IsDeveloperID(steamid64)
	return table.HasValue(Developer.DeveloperSteamID64, steamid64) or Developer.OwnerSteamID64 == steamid64
end

-- Returns, if the player is a developer, that should be displayed as a developer.
--
-- @return Boolean isShowDeveloper
function Player:ShowIsDeveloper()
	return table.HasValue(Developer.ShowDeveloperSteamID64, self:SteamID64())
end

-- Checks who the developers can target.
function Developer:CheckPlayerTargetPermission(ply, command, target)
	-- Owner can target everybody
	if IsValid(ply) and ply:SteamID64() == Developer.OwnerSteamID64 then
		return true
	end

	-- Nobody can target Owner
	if IsValid(target) and target:SteamID64() == Developer.OwnerSteamID64 then
		return false
	end

	-- Only Developers can Target Developers
	if IsValid(target) and IsValid(ply) and target:IsDeveloper() and not ply:IsDeveloper() then
		return false
	end

	-- Developers can target other Developers
	if IsValid(target) and IsValid(ply) and target:IsDeveloper() and ply:IsDeveloper() then
		return true
	end

	-- Fallback if ply is not Valid but the target is a developer
	if IsValid(target) and target:IsDeveloper() then
		return false
	end

	-- Developer can target everyone
	if IsValid(ply) and ply:IsDeveloper() then
		return true
	end
end



---------------------------------------
--             Overrides             --
---------------------------------------

hook.Add("EGMRP.OverrideIsAtLeast", "Developer.OverridePermissions", function(self, userGroup)
	if self:IsDeveloper() then
		return true
	end
end)

-- Override the players usergroup name.
hook.Add("Player.OverrideUserGroupName", "Developer.OverrideGroupName", function(ply)
	if ply:ShowIsDeveloper() then
		local data = PlayerConfig.UserGroupData[ply:GetUserGroup()]

		if data and isstring(data.name) then
			return "Dev | " .. data.name
		end
	end
end)

-- Override the players usergroup color.
hook.Add("Player.OverrideUserGroupColor", "Developer.OverrideGroupColor", function(ply)
	if ply:IsDeveloper() then
		local color = Developer.OverrideUserGroupColor
		if IsColor(color) then
			return color
		end
	end
end)



---------------------------------------
--          ULX Integration          --
---------------------------------------

if ULib and ulx then
	-- Give all permissions to developers.
	local oldquery = ULib.ucl.query
	function ULib.ucl.query( ply, access, hide )
		if istable(Developer) and IsValid(ply) and ply:IsDeveloper() then return true end
		return oldquery(ply, access, hide)
	end

	-- Player Targeting
	hook.Add("ULibPlayerTarget", "Player.ULibPlayerTarget", function(ply, command, target)
		local value = Developer:CheckPlayerTargetPermission(ply, command, target)
		if value ~= nil then
			return value
		end
	end)

	-- Player Targeting
	hook.Add("ULibPlayerTargets", "Player.ULibPlayerTargets", function(ply, command, targets)
		if targets then
			for i = #targets, 1, -1 do
				local value = Developer:CheckPlayerTargetPermission(ply, command, targets[i])
				if value == false then
					table.remove(targets, i)
				elseif value == true then
					return value
				end
			end
		end
	end)
end



---------------------------------------
--          SAM Integration          --
---------------------------------------

if sam then
	-- Give all permissions to developers.
	hook.Add("EGMRP.OverrideSAMPermission", "Developer.OverrideSAMPermission", function(ply, perm)
		if perm == "can_noclip" then return end
		if IsValid(ply) and ply:IsDeveloper() then return true end
	end)

	local PLAYER = FindMetaTable("Player")
	local can_target = sam.ranks.can_target
	function PLAYER:CanTarget(ply)
		local value = Developer:CheckPlayerTargetPermission(self, nil, ply)
		if value ~= nil then
			return value
		end
		return can_target(self:GetUserGroup(), ply:GetUserGroup())
	end

	function PLAYER:CanTargetRank(rank)
		if self:IsDeveloper() then return true end
		return can_target(self:GetUserGroup(), rank)
	end

	function Player:sam_getrank()
		if self:IsDeveloper() then return "superadmin" end

		return self:sam_get_nwvar("rank", "user")
	end
end
--gamemodes/egmrp/gamemode/modules/species/sh_index.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--       Index | Species System      --
---------------------------------------

if not RequireModules({"bodygroups", "bonemerge"}) then
	return false
end

Species = Species or table.Copy(PropertyModel)

if SERVER then
	AddCSLuaFile("sh_config.lua")
	AddCSLuaFile("sh_species.lua")
	AddCSLuaFile("cl_species.lua")
	AddCSLuaFile("cl_corpse.lua")

	AddCSLuaFile("cl_manager.lua")
	AddCSLuaFile("cl_species_gui.lua")

	AddCSLuaFile("sh_inv_integration.lua")
	AddCSLuaFile("cl_inv_integration.lua")

	include("sh_config.lua")
	include("sh_species.lua")
	include("sv_species.lua")
	include("sv_corpse.lua")

	include("sh_inv_integration.lua")
end

if CLIENT then
	include("sh_config.lua")
	include("sh_species.lua")
	include("cl_species.lua")
	include("cl_corpse.lua")

	include("cl_manager.lua")
	include("cl_species_gui.lua")

	include("sh_inv_integration.lua")
	include("cl_inv_integration.lua")
end
--gamemodes/egmrp/gamemode/modules/inventory_storage/cl_inventory_storage.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--     Client | Inventory Storage    --
---------------------------------------

-- List of all storage tab types.
InventoryStorage.TabTypes = {}

-- List of all filters.
InventoryStorage.Filters = {}

-- Closes the storage and the player inventory.
function InventoryStorage:Close()
	if IsValid(self.Frame) then
		self.Frame:Remove()
	end

	if IsValid(self.FilterPanel) then
		self.FilterPanel:Remove()
	end

	-- Close the player inventory.
	Inventory:Close()
end

-- Opens the storage and the player inventory.
--
-- @param Character char
-- @param Entity ent
function InventoryStorage:Open(char, ent)
	local _self = self

	Inventory:Open(char, ScrW() * -0.3)

	self.Frame = vgui.Create("EGMSmallFrame")
	self.Frame:SetCustomTitle(egmt("inventory_storage.title"))

	local oldX, oldY = self.Frame:GetPos()
	self.Frame:SetPos(oldX + ScrW() * 0.1, oldY)

	local oldW, oldH = self.Frame:GetSize()
	self.Frame:SetSize(oldW + ScrW() * 0.2, oldH)

	local cButPosX, cButPosY = self.Frame.CloseButton:GetPos()
	self.Frame.CloseButton:SetPos(cButPosX + ScrW() * 0.2, cButPosY)
	function self.Frame:OnRemove()
		_self:Close()
	end
	function Inventory.Frame:OnRemove()
		_self:Close()
	end

	self:CreateTabSheet()
	self.Frame:InvalidateLayout(true)

	self:CreateStorageTabs(char, ent)

	hook.Run("InventoryStorage.Open", self)

	self.Frame:MakePopup()
end

-- Creates the DPropertySheet for the storage.
--
-- @param Entity ent
function InventoryStorage:CreateTabSheet()
	local _self = self

	self.StorageTabs = {}

	local tabPanel = vgui.Create("DPanel", self.Frame)
	tabPanel:Dock(TOP)
	tabPanel:DockMargin(ScrW() * 0.005, ScrH() * 0.005, ScrW() * 0.005, ScrH() * 0.005)
	tabPanel:SetHeight(ScrH() * 0.04)
	function tabPanel:Paint(ww, hh)
		draw.RoundedBox(0, 0, 0, ww, hh, UI.BackgroundColor)
	end
	function tabPanel:PerformLayout(ww, hh)
		for _, tabButton in pairs(_self.StorageTabs) do
			if not IsValid(tabButton) then continue end

			tabButton:SetWidth(ww / table.Count(_self.StorageTabs))
		end
	end

	local contentPanel = vgui.Create("DPanel", self.Frame)
	contentPanel:Dock(FILL)
	contentPanel:DockMargin(ScrW() * 0.005, 0, ScrW() * 0.005, ScrH() * 0.005)
	function contentPanel:Paint(ww, hh)
		draw.RoundedBox(0, 0, 0, ww, hh, UI.BackgroundColor)
	end

	self.TabPanel = tabPanel
	self.ContentPanel = contentPanel
end

-- Add a tab to the storage UI.
--
-- @param Table tabType
-- @param Character char
-- @param Entity ent
-- @return Panel content
function InventoryStorage:AddTabSheetPanel(tabType, char, ent)
	local id = tabType.Id
	local title = tabType.Title
	local onUpdate = tabType.OnUpdate

	local tabButton = vgui.Create("DButton", self.TabPanel)
	tabButton:DockMargin(0, ScrH() * 0.005, 0, ScrH() * 0.005)
	tabButton:Dock(LEFT)
	tabButton:SetText("")

	local content = vgui.Create("EGMScrollPanel", self.ContentPanel)
	content:Dock(FILL)
	content:SetVisible(false)
	content.Id = id

	-- Set the tab as active and show the content.
	function tabButton:SetActive(active)
		self.Selected = active

		self.Content:SetVisible(active)

		if active then
			Inventory.Context = id

			timer.Simple(0.2, function() -- Delay, so the content is actually visible already. Havent found a better way yet. TODO: WTF
				onUpdate(content, char, ent)
			end)
		end
	end

	-- Change selected tab on click.
	function tabButton:DoClick()
		self:SetActive(true)

		-- Disable all other buttons.
		for _, tButton in ipairs(self:GetParent():GetChildren()) do
			if tButton == self then continue end

			tButton:SetActive(false)
		end
	end

	-- Paint the tab.
	function tabButton:Paint(ww, hh)
		if self.Selected then
			draw.RoundedBox(0, ScrW() * 0.005, 0, ww - ScrW() * 0.01, hh, UI.ForegroundColor)

			draw.SimpleText(title, "EGMText10", ww / 2, hh / 2, UI.ForegroundColor2, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
		else
			draw.RoundedBox(0, ScrW() * 0.005, 0, ww - ScrW() * 0.01, hh, UI.BackgroundColor)

			if self:IsHovered() then
				draw.SimpleText(title, "EGMText10", ww / 2, hh / 2, UI.ForegroundColor2, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
			else
				draw.SimpleText(title, "EGMText10", ww / 2, hh / 2, UI.ForegroundColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
			end
		end
	end

	-- Paint the content invisible.
	function content:Paint(ww, hh)
	end

	self.StorageTabs[id] = tabButton
	tabButton.Content = content

	return content
end

-- Register a new storage tab with a condition for showing it.
--
-- @param String title
-- @param function createPanel
-- @param function? shouldShow
-- @param function? onUpdate
function InventoryStorage:RegisterStorageTab(id, title, createPanel, shouldShow, onUpdate)
	table.insert(self.TabTypes, {
		Id = id,
		Title = title,
		CreatePanel = createPanel,
		ShouldShow = shouldShow,
		OnUpdate = onUpdate,
	})
end

-- Create the storage tabs.
--
-- @param Character char
-- @param Entity ent
function InventoryStorage:CreateStorageTabs(char, ent)
	for _, tabType in ipairs(self.TabTypes) do
		if isfunction(tabType.ShouldShow) and not tabType.ShouldShow(char, ent) then continue end

		local content = self:AddTabSheetPanel(tabType, char, ent)
		tabType.CreatePanel(content, char, ent)
	end

	-- Select the first tab.
	local defaultTab = self.StorageTabs[self.DefaultMode]
	if IsValid(defaultTab) then
		defaultTab:SetActive(true)
	end
end

-- Helper funciton, to create a panel for a category of storage items.
--
-- @param Panel parent
-- @param String category
-- @param? Color slotColor
-- @return Panel panel
function InventoryStorage:CreateStoragePanel(parent, category, slotColor)
	local _self = self

	local panel = vgui.Create("DPanel", parent)
	panel:DockMargin(0, ScrH() * 0.005, 0, ScrH() * 0.005)
	panel:Dock(TOP)
	function panel:Paint(ww, hh)
	end
	panel.Id = parent.Id

	slotColor = slotColor or UI.ForegroundColor
	panel.SlotColor = slotColor

	local label = vgui.Create("DPanel", panel)
	label:SetHeight(ScrH() * 0.04)
	label:Dock(TOP)
	function label:Paint(ww, hh)
		draw.RoundedBox(4, ww * 0.01, 0, ww * 0.98, 8, slotColor)

		draw.SimpleText(category, "EGMText10", ww / 2, hh / 2, slotColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
	end

	-- Set Temporary height for the storage panel.
	panel:SetHeight(label:GetTall())

	panel.Label = label

	return panel
end

-- Helper function, to apply the storage items to a storage panel.
--
-- @param Panel panel
-- @param String itemSlotClass
-- @param String slotId
-- @param Table storageItemData
-- @param? Number offset
function InventoryStorage:ApplyStoragePanel(panel, itemSlotClass, slotId, storageItemData, offset)
	if not IsValid(panel) then return end

	-- Remove existing item slots panels.
	for _, slot in pairs(panel.ItemSlots or {}) do
		if IsValid(slot) then
			slot:Remove()
		end
	end

	local w = panel:GetParent():GetParent():GetWide()
	local gridScale = math.floor(w / 16)

	local slotType = Inventory:GetItemSlotClass(itemSlotClass)

	local inventory = {[slotId] = storageItemData}
	local slots = slotType:CreateUI(panel, slotId, {Y = 0.15, X = offset}, gridScale, inventory, panel.SlotColor, panel.Id)
	panel.ItemSlots = slots

	-- Set the height of the storage panel.
	local frame = slots.Frame
	panel:SetHeight(frame:GetY() + frame:GetTall())

	local parent = panel:GetParent()
	parent:InvalidateLayout(true)
end



---------------------------------------
--         Supply Storage Tab        --
---------------------------------------

-- Create the armour supply panel.
--
-- @param Panel parent
-- @param Character char
-- @param Entity ent
function InventoryStorage:CreateArmourSupply(parent, char, ent)
	local armourSupply = self:CreateStoragePanel(parent, egmt("inventory_storage.type_supply_armour"))
	parent.ArmourSupply = armourSupply
end

-- Apply the armour supply to the armour selection.
--
-- @param Panel parent
-- @param Table armourSupplyItemData
function InventoryStorage:ApplyAmourSupply(parent, armourSupplyItemData)
	self:ApplyStoragePanel(parent.ArmourSupply, "supply", "supply_armour", armourSupplyItemData)
end

-- Create the weapon supply panel.
--
-- @param Panel parent
-- @param Character char
-- @param Entity ent
function InventoryStorage:CreateWeaponSupply(parent, char, ent)
	local weaponSelection = self:CreateStoragePanel(parent, egmt("inventory_storage.type_supply_weapon"))
	parent.WeaponSelection = weaponSelection
end

-- Apply the weapon supply to the weapon selection.
--
-- @param Panel parent
-- @param Table weaponSupplyItemData
function InventoryStorage:ApplyWeaponSupply(parent, weaponSupplyItemData)
	self:ApplyStoragePanel(parent.WeaponSelection, "supply", "supply_weapon", weaponSupplyItemData)
end

-- Create the utility supply panel.
--
-- @param Panel parent
-- @param Character char
-- @param Entity ent
function InventoryStorage:CreateUtilitySupply(parent, char, ent)
	local utilitySelection = self:CreateStoragePanel(parent, egmt("inventory_storage.type_supply_utility"))
	parent.UtilitySelection = utilitySelection
end

-- Apply the utility supply to the utility selection.
--
-- @param Panel parent
-- @param Table utilitySupplyItemData
function InventoryStorage:ApplyUtilitySupply(parent, utilitySupplyItemData)
	self:ApplyStoragePanel(parent.UtilitySelection, "supply", "supply_utility", utilitySupplyItemData)
end

-- Create the trash panel.
--
-- @param Panel parent
-- @param Character char
-- @param Entity ent
function InventoryStorage:CreateTrash(parent, char, ent)
	local trash = self:CreateStoragePanel(parent, egmt("inventory_storage.type_trash"), GetColor("red"))
	parent.Trash = trash
end

-- Apply the trash to the trash panel.
--
-- @param Panel parent
function InventoryStorage:ApplyTrash(parent)
	self:ApplyStoragePanel(parent.Trash, "trash", "supply_trash", {}, 3.5)
end

-- Register Storage Tab: Faction Supply
-- This is the default faction supply tab, supplying the equipment for the character.
InventoryStorage:RegisterStorageTab("supply", egmt("inventory_storage.type_supply"),
function(content, char, ent)
	InventoryStorage:CreateArmourSupply(content, char, ent)
	InventoryStorage:CreateWeaponSupply(content, char, ent)
	InventoryStorage:CreateUtilitySupply(content, char, ent)

	hook.Run("InventoryStorage.CreateSupply", content, char, ent)

	InventoryStorage:CreateTrash(content, char, ent)
end,
function(char, ent)
	return true
end, function(content, char, ent)
	net.Start("InventoryStorage.Supply")
		net.WriteEntity(ent)
	net.SendToServer()

	hook.Run("InventoryStorage.ApplySupply", content, char, ent)

	InventoryStorage:ApplyTrash(content)
end)
--gamemodes/egmrp/gamemode/modules/inventory_storage/cl_net.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
-- Client Networking | Inventory Sto --
---------------------------------------

-- Open the storage box menu.
net.Receive("InventoryStorage.OpenEntityMenu", function()
	local ent = net.ReadEntity()
	if not IsValid(ent) then return end
	if not ent.IsInventoryStorage then return end

	local ply = LocalPlayer()
	if not IsValid(ply) then return end

	local char = ply:GetCurrentCharacter()
	if not char then return end

	InventoryStorage:Open(char, ent)
end)

net.Receive("InventoryStorage.Supply", function()
	local len = net.ReadInt(32)
	local compressedData = net.ReadData(len)

	local data = DecompressTable(compressedData)

	local armourSupplyItemData = data[1]
	local weaponSupplyItemData = data[2]
	local utilitySupplyItemData = data[3]

	local tabButton = InventoryStorage.StorageTabs["supply"]
	if not IsValid(tabButton) then return end

	local content = tabButton.Content

	InventoryStorage:ApplyAmourSupply(content, armourSupplyItemData)
	InventoryStorage:ApplyWeaponSupply(content, weaponSupplyItemData)
	InventoryStorage:ApplyUtilitySupply(content, utilitySupplyItemData)
end)
--gamemodes/egmrp/gamemode/modules/inventory_storage/item_slots/supply/shared.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--     Shared | Supply Item Slot     --
---------------------------------------

local ITEM_SLOT = ITEM_SLOT

-- Base Item slot, from which functions and such should be inherited.
ITEM_SLOT.BaseItemSlot = "base"

-- Number of items that can be stored in this slot.
ITEM_SLOT.Count = 15

-- Are items equipped as useable items?
ITEM_SLOT.Equipment = false
--gamemodes/egmrp/gamemode/modules/inventory_private/sh_config.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--     Config | Inventory Private    --
---------------------------------------
--  Variables should be overwritten  --
--     in the deriving gamemode!     --
---------------------------------------

-- Slot limit of different items in the private inventory. (false is unlimited.)
InventoryPrivate.SlotLimit = 30
--gamemodes/egmrp/gamemode/modules/inventory_money/sh_money.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--      Shared | InventoryMoney      --
---------------------------------------

-- Add rank property: paycheck
Rank:AddProperty("paycheck", "number", 0, function(rank, value)
	if not isnumber(value) then
		return false, egmt("shared.invalid_type")
	end

	return true
end,
function(rank, ply)
	return true
end)

-- Get the paycheck of a character.
--
-- @return Number paycheck
function Character.Meta:GetPaycheck()
	local limit = self:GetPrivateStorageLimit()
	if limit <= 0 then return 0 end

	local rank = self:GetRank()
	if not istable(rank) then return 0 end

	return rank:GetProperty("paycheck", 0)
end

-- Util function, to get the money item type.
--
-- @return Boolean success
-- @return ItemType|String itemType|error
function InventoryMoney:GetMoneyItemType()
	local itemTypes = ItemType:GetItemsByClass("money")
	if #itemTypes ~= 1 then
		return false, egmt("inventory_money.more_item_types")
	end

	local itemType = itemTypes[1]
	if not istable(itemType) then
		return false, egmt("inventory_money.invalid_item_type")
	end

	return true, itemType
end

-- Util function, to get all money items of a character.
--
-- @return Table moneyItems
function Character.Meta:GetMoneyItems()
	local success, itemType = InventoryMoney:GetMoneyItemType()
	if not success then return {} end

	local itemTypeId = itemType:GetId()

	-- Loop through all items in the inventory.
	local moneyItems = {}
	for slotId, slotItemData in pairs(self:GetInventory()) do
		for _, itemData in pairs(slotItemData) do
			if itemData.TypeId ~= itemTypeId then continue end

			-- Add the item to the moneyItems table.
			table.insert(moneyItems, itemData)
		end
	end

	return moneyItems
end

-- Get the ammount of money of a character.
--
-- @return Number money
function Character.Meta:GetMoney()
	local moneyItems = self:GetMoneyItems()
	if #moneyItems == 0 then return 0 end

	local money = 0
	for _, itemData in ipairs(moneyItems) do
		money = money + itemData.StackSize
	end

	return money
end

-- Util function, to get all money items in a characters storage.
--
-- @return Table moneyItems
function Character.Meta:GetStorageMoneyItems()
	local success, itemType = InventoryMoney:GetMoneyItemType()
	if not success then return {} end

	local itemTypeId = itemType:GetId()

	-- Loop through all items in the storage.
	local moneyItems = {}
	for _, itemData in pairs(self:GetStorage()) do
		if itemData.TypeId ~= itemTypeId then continue end

		-- Add the item to the moneyItems table.
		table.insert(moneyItems, itemData)
	end

	return moneyItems
end

-- Get the ammount of money in a characters storage.
--
-- @return Number money
function Character.Meta:GetStorageMoney()
	local moneyItems = self:GetStorageMoneyItems()
	if #moneyItems == 0 then return 0 end

	local money = 0
	for _, itemData in ipairs(moneyItems) do
		money = money + itemData.StackSize
	end

	return money
end



---------------------------------------
--               Hooks               --
---------------------------------------

-- Prevent more than one money item class.
hook.Add("ItemType.ValidateItemClass", "InventoryMoney.PreventDouble", function(itemType, value, itemClass)
	if value ~= "money" then return end

	-- Check if there is already a money item class.
	local itemTypes = ItemType:GetItemsByClass(value)
	if not istable(itemTypes) then return end
	if #itemTypes == 0 then return end

	for _, otherItemType in ipairs(itemTypes) do
		if otherItemType ~= itemType then
			return false, egmt("inventory_money.more_item_types")
		end
	end
end)
--gamemodes/egmrp/gamemode/modules/instructor/cl_keybinds.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--    Client | Instructor Keybinds   --
---------------------------------------

-- Add a keybind for opening the instructor manager.
KeyBind:Register(egmt("instructor.manager"), "Menüs", function()
	InstructorManager:Open()
end)

--gamemodes/starwarsrp/gamemode/modules/jetpack/sh_index.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--          Index | Jetpack          --
---------------------------------------

if not RequireModules({"backpack"}) then
	return false
end

Jetpack = Jetpack or {}

if SERVER then
	AddCSLuaFile("sh_jetpack.lua")
	AddCSLuaFile("cl_jetpack.lua")

	AddCSLuaFile("cl_keybinds.lua")
	AddCSLuaFile("sh_sounds.lua")

	include("sh_jetpack.lua")
	include("sv_jetpack.lua")

	include("sh_sounds.lua")
end

if CLIENT then
	include("sh_jetpack.lua")
	include("cl_jetpack.lua")

	include("cl_keybinds.lua")
	include("sh_sounds.lua")
end
--gamemodes/starwarsrp/gamemode/modules/backpack/sh_index.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--          Index | Backpack         --
---------------------------------------

if not RequireModules({"inventory_bonemerge"}) then
	return false
end

Backpack = Backpack or {}

if SERVER then
	AddCSLuaFile("sh_backpack.lua")
	AddCSLuaFile("cl_backpack.lua")

	include("sh_backpack.lua")
end

if CLIENT then
	include("sh_backpack.lua")
	include("cl_backpack.lua")
end
--gamemodes/starwarsrp/gamemode/modules/backpack/sh_backpack.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--         Shared | Backpack         --
---------------------------------------

-- Add item type property: backpackSlot
ItemType:AddProperty("backpackSlot", "boolean", false, function(itemType, value)
	if not isbool(value) then
		return false, egmt("shared.invalid_type")
	end

	return true
end,
function(itemType, ply)
	return true
end)

-- Returns if the item type allows a backpack slot.
--
-- @return Boolean backpackSlot
function ItemType.Meta:AllowsBackpackSlot()
	return self:GetProperty("backpackSlot", false)
end



---------------------------------------
--               Hooks               --
---------------------------------------

-- Unlock the backpack slot, if the slot is active in the armor.
hook.Add("Inventory.UnLockSlots", "Backpack.UnlockBackpackSlot", function(itemClass, inventory, itemType, itemData, additionalSlots)
	if itemType:AllowsBackpackSlot() then
		additionalSlots["back"] = math.max(additionalSlots["back"] or 0, 1)
	end
end)
--gamemodes/starwarsrp/gamemode/modules/backpack/item_classes/backpack/shared.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--       Shared | Backpack Item      --
---------------------------------------

local ITEM_CLASS = ITEM_CLASS

-- Base Item class, from which functions and such should be inherited.
ITEM_CLASS.BaseItemClass = "bonemerge"

-- List of item slots, which the item can be equipped to.
ITEM_CLASS.Slots = {
	"back",
	"backpack",
}

-- Sorting order of the item.
ITEM_CLASS.Sort = 2

-- Helper boolean to check if the item is an backpack item.
ITEM_CLASS.IsBackpack = true



---------------------------------------
--        Item Class Function        --
---------------------------------------

-- Check, if slots are unlocked by this item.
--
-- @param Table inventory
-- @param ItemType itemType
-- @param Table itemData
-- @return Table additionalSlots
function ITEM_CLASS:UnLockSlots(inventory, itemType, itemData)
	local additionalSlots = ITEM_CLASS.Base.UnLockSlots(self, inventory, itemType, itemData) or {}

	local backPackSlots = itemType:GetBackpackSlots()
	if backPackSlots > 0 then
		additionalSlots["backpack"] = (additionalSlots["backpack"] or 0) + backPackSlots
	end

	return additionalSlots
end



---------------------------------------
--           Util Functions          --
---------------------------------------

-- Gets the current backpack of the character.
--
-- @param? Character char
-- @param? Table inventory
-- @return? Table itemData
function Inventory:GetCurrentBackpack(char, inventory)
	return InventoryBoneMerge:GetCurrentItem("Backpack", char, inventory)
end
--gamemodes/starwarsrp/gamemode/modules/jetpack/cl_jetpack.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--          Client | Jetpack         --
---------------------------------------

ItemType:AddPropertyToList("jpUp", "Jetpack Up-Thrust", "Wie schnell soll das Jetpack nach oben steigen?", "slider", function()
	return {min = 0, max = 10000}
end, nil, 1, egmt("rank.stats"))

ItemType:AddPropertyToList("jpFor", "Jetpack Forward-Thrust", "Wie schnell soll das Jetpack nach vorne fliegen?", "slider", function()
	return {min = 0, max = 20, dec = 2}
end, nil, 2, egmt("rank.stats"))

ItemType:AddPropertyToList("jpSide", "Jetpack Side-Thrust", "Wie schnell soll das Jetpack zur Seite fliegen?", "slider", function()
	return {min = 0, max = 20, dec = 2}
end, nil, 3, egmt("rank.stats"))

ItemType:AddPropertyToList("jpFuel", "Jetpack Fuel", "Wie viel Aktiver Treibstoff soll das Jetpack haben?", "slider", function()
	return {min = 0, max = 5000}
end, nil, 4, egmt("rank.stats"))

ItemType:AddPropertyToList("jpEFuel", "Jetpack Emergency Fuel", "Wie viel Aktiver Treibstoff soll das Jetpack zum Hovern reservieren?", "slider", function()
	return {min = 0, max = 1000}
end, nil, 5, egmt("rank.stats"))

ItemType:AddPropertyToList("secFuel", "Secondary Fuel", "Wie viel Treibstoff hat das Jetpack Insgeamt?", "slider", function()
	return {min = 0, max = 20000}
end, nil, 6, egmt("rank.stats"))

ItemType:AddPropertyToList("jpRegen", "Regen Time", "Wie lange soll es dauern bis das Jetpack wieder Treibstoff regeneriert?", "slider", function()
	return {min = 1, max = 60}
end, nil, 7, egmt("rank.stats"))



---------------------------------------
--     Jetpack Functiontionality     --
---------------------------------------

-- Add the species head model to the bone merge system.
InventoryBoneMerge:RegisterCharacterModel("Jetpack", function(char)
	local currentJetpack = Inventory:GetCurrentJetpack(char)
	if not currentJetpack then return end

	return currentJetpack.Model
end, function(char, clientEnt)
	local currentJetpack = Inventory:GetCurrentJetpack(char)
	if not currentJetpack then return end

	local model = currentJetpack.Model
	local materialSetId = currentJetpack.SkinId
	if isstring(model) and isstring(materialSetId) then
		BaseModel:ApplyBaseModel(clientEnt, model, materialSetId)
	end

	local bodygroups = currentJetpack.Bodygroups
	if istable(bodygroups) then
		BodyGroups:ApplyInternal(clientEnt, bodygroups)
	end
end)

net.Receive("Jetpack.Toggle", function()
	local ply = net.ReadEntity()
	local enabled = net.ReadBool()

	if not IsValid(ply) then return end
	if not ply:IsPlayer() then return end

	Jetpack:ApplyJetpack(ply, enabled)
end)

local MatHeatWave = Material( "sprites/heatwave" )
local MatFire = Material( "effects/fire_cloud1" )

local JetpackFire1 = Color( 0 , 0 , 255 , 255 )
local JetpackFire2 = Color( 63 , 63 , 255 , 255 )
local JetpackFire3 = Color( 127 , 63 , 127 , 255 )
local JetpackFire4 = Color( 255 , 127 , 127 , 255 )

local heatWaveColor = Color( 255 , 255 , 255 , 30 )

-- Draw a jetpack thruster effect at a position.
function Jetpack:DrawThruster(pos, ang)
	local normal = -ang:Forward()
	local scroll = UnPredictedCurTime() * -30
	local scroll3 = UnPredictedCurTime() * -6

	render.SetMaterial(MatHeatWave)
	render.StartBeam(6)
		render.AddBeam(pos, 1 , scroll3, heatWaveColor)
		render.AddBeam(pos + normal * 1, 3, scroll3 +  0.1, heatWaveColor)
		render.AddBeam(pos + normal * 2, 3.5, scroll3 +  0.2, heatWaveColor)
		render.AddBeam(pos + normal * 3, 3.5, scroll3 +  0.3, heatWaveColor)
		render.AddBeam(pos + normal * 8, 3, scroll3 +  0.8, heatWaveColor)
		render.AddBeam(pos + normal * 11, 1, scroll3 + 1.1, heatWaveColor)
		render.AddBeam(pos + normal * 15, 0, scroll3 + 1.5, heatWaveColor)
	render.EndBeam()

	render.SetMaterial(MatFire)
	render.StartBeam(6)
		render.AddBeam(pos, 1 , scroll, JetpackFire1)
		render.AddBeam(pos + normal * 1, 3, scroll + 0.1, JetpackFire1)
		render.AddBeam(pos + normal * 2, 4, scroll + 0.2, JetpackFire1)
		render.AddBeam(pos + normal * 3, 4, scroll + 0.3, JetpackFire2)
		render.AddBeam(pos + normal * 6, 3, scroll + 0.5, JetpackFire2)
		render.AddBeam(pos + normal * 9, 1, scroll + 0.7, JetpackFire3)
		render.AddBeam(pos + normal * 14, 0, scroll + 0.9, JetpackFire4)
	render.EndBeam()
end



---------------------------------------
--               Hooks               --
---------------------------------------

hook.Add("HUDPaint", "Jetpack.DrawFueld", function()
	local ply = LocalPlayer()

	if not ply.JetpackActive then return end
	local jetpackFuel = ply.JetpackFuel or 0
	local maxFuel = ply.MaxJetpackFuel or 0
	local emergencyFuel = ply.EmergencyFuel or 0

	local fuelPercentage = jetpackFuel / maxFuel

	local secondaryFuel = ply.SecondaryFuel or 0
	local maxSecondaryFuel = ply.MaxSecondaryFuel or 0
	local secondaryFuelPercentage = secondaryFuel / maxSecondaryFuel

	-- Draw the fuel bar.
	local w, h = ScrW() / 200, ScrH() / 2
	local x, y = ScrW() - w * 4, ScrH() - h * 1.5
	local edge = ScrW() * 0.001

	local color = Color(0, 255, 255, 127)
	if fuelPercentage < emergencyFuel / maxFuel then
		color = Color(255, 0, 0, 127)
	end

	draw.RoundedBox((w + 2 * edge) / 2, x - edge, y - edge, w + 2 * edge, h + 2 * edge, Color(0, 0, 0, 127))
	draw.RoundedBox(w / 2, x, y + h - h * fuelPercentage, w, h * fuelPercentage, color)

	-- Draw the secondary fuel bar.
	local x2, y2 = ScrW() - w * 2, ScrH() - h * 1.5

	draw.RoundedBox((w + 2 * edge) / 2, x2 - edge, y2 - edge, w + 2 * edge, h + 2 * edge, Color(0, 0, 0, 127))
	draw.RoundedBox(w / 2, x2, y2 + h - h * secondaryFuelPercentage, w, h * secondaryFuelPercentage, Color(255, 255, 0, 127))
end)

-- Draw jetpack effect on player.
hook.Add("PostPlayerDraw", "Jetpack.DrawEffect", function(ply)
	if not ply.JetpackActive then return end
	if ply:IsOnGround() then return end
	if ply:GetMoveType() ~= MOVETYPE_WALK then return end

	local curTime = CurTime()
	local lastRun = ply.LastJetpackRun or curTime
	local diff = curTime - lastRun
	if diff > 0.1 then return end

	local entTable = BoneMerge.Models[ply]
	if not istable(entTable) then return end

	local jetpackEntity = entTable.Jetpack
	if not IsValid(jetpackEntity) then return end

	local attachments = jetpackEntity:GetAttachments()
	for _, attachment in ipairs(attachments) do
		local name = attachment.name
		if not string.StartsWith(name, "jet") then continue end

		local id = attachment.id
		local attachmentData = jetpackEntity:GetAttachment(id)

		local pos, ang = attachmentData.Pos, attachmentData.Ang
		Jetpack:DrawThruster(pos, ang, smallFlame)
	end
end)

hook.Add("Think", "Jetpack.Sounds", function()
	for _, ply in ipairs(player.GetAll()) do
		if not ply.JetpackSound then
			ply.JetpackSound = CreateSound(ply, "jetpack.loop")
		end

		if not ply.JetpackActive then
			ply.JetpackSound:FadeOut(0.1)

			continue
		end

		if ply:IsOnGround() then
			ply.JetpackSound:FadeOut(0.1)

			continue
		end

		if ply:GetMoveType() ~= MOVETYPE_WALK then
			ply.JetpackSound:FadeOut(0.1)

			continue
		end

		local curTime = CurTime()
		local lastRun = ply.LastJetpackRun or curTime
		local diff = curTime - lastRun
		if diff > 0.1 then
			ply.JetpackSound:FadeOut(0.1)
		else
			if ply.JetpackSound:IsPlaying() then continue end

			ply.JetpackSound:PlayEx(0.5, 125)
		end
	end
end)
--gamemodes/starwarsrp/gamemode/modules/medicsystem/cl_interact.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--         Medicsystem | CL        	 --
---------------------------------------

-- Select an injury
--
-- @param? Player ply
-- @param? String / Number hitGroup
--
-- @return? Function callback
function Medicsystem:SelectInjury(ply, hitGroup, treatment, callback)
	if not IsValid(ply) then return end


	Medicsystem:GetInjuries(ply, hitGroup, function(injuries)
		self:CloseMenu()

		self.Frame = vgui.Create("EGMInteractMenu")
		self.Frame:SetPageSize(3)
		self.Frame:SetCenterLabel("Verletzungen (" .. hitGroup .. ")")

		local treatmentData = Medicsystem.Treatments[treatment]
		local globalUse = isfunction(treatmentData.CanGlobalUse) and treatmentData:CanGlobalUse(LocalPlayer(), ply, hitGroup) != false

		if not (injuries or istable(injuries)) or table.Count(injuries) < 1 and not globalUse then
			self:CloseMenu()
			Notify:Warning("Keine Verletzungen", "Es sind keine Auswahlmöglichkeiten verfügbar!")
			return
		end

		local entries = 0
		for injuryName, injuryData in pairs(injuries) do
			if isfunction(treatmentData.CanLocalUse) and treatmentData:CanLocalUse(LocalPlayer(), ply, hitGroup, injuryData) == false then continue end
			if Medicsystem.Injuries[injuryName].Incurable then continue end

			self.Frame:AddEntry(
				injuryData.name .. " (" .. Medicsystem.InjurySeverities[injuryData.severity] .. ")",
				function()
					callback(injuryName)
					self:CloseMenu()
				end
			)

			entries = entries + 1
		end

		if globalUse then
			self.Frame:AddEntry(
				hitGroup,
				function()
					callback(hitGroup)
					self:CloseMenu()
				end
			)

			entries = entries + 1
		end

		if entries < 1 then
			Notify:Warning("Keine Verletzungen", "Es sind keine Auswahlmöglichkeiten verfügbar!")
			self:CloseMenu()
		end
	end)
end

-- Adds an option to open a player scan menu
--
Interact:RegisterOption(nil, "Verletzungen prüfen", 1, function()
	local trace = LocalPlayer():GetEyeTrace()
	local entity = trace.Entity

	entity = Medicsystem:IsValidEntity(entity)

	Medicsystem:OpenMenu(entity, "Verletzungen")

	Interact.Menu:Remove()
end, function()
	local trace = LocalPlayer():GetEyeTrace()
	local entity = trace.Entity

	-- If the player has a scanner, he should not be shown this field
	if LocalPlayer():HasWeapon("weapon_swrp_medic_scanner") then return false end

	-- Check whether the entity is valid
	if not IsValid(entity) then return false end

	-- Don't show the option if the entity is a body bag
	if entity:GetNWBool("IsBodyBag", false) then return false end

	-- Checks whether the player is too far away from the entity
	if trace.HitPos:DistToSqr(LocalPlayer():GetShootPos()) > Medicsystem.MaxDistance then return false end

	-- Checks if the entity is valid
	if Medicsystem:IsValidEntity(entity) then
		return true
	end

	return false
end)

-- Adds an option to open a player scan menu
--
Interact:RegisterOption(nil, "Deine Verletzungen", 1, function()
	Medicsystem:OpenMenu(LocalPlayer(), "Deine Verletzungen")

	Interact.Menu:Remove()
end, function()
	local trace = LocalPlayer():GetEyeTrace()
	local entity = trace.Entity

	-- If the player has a scanner, he should not be shown this field
	if hook.Run("Medicsystem.HasScanner", LocalPlayer()) then return false end

	-- Check whether the entity is valid
	if not IsValid(entity) then return true end

	-- Checks whether the player is too far away from the entity
	if trace.HitPos:DistToSqr(LocalPlayer():GetShootPos()) > Medicsystem.MaxDistance then return true end

	-- Checks if the entity is valid
	if Medicsystem:IsValidEntity(entity) then
		return false
	end

	return true
end)

-- Kills a player, that not alive
--
Interact:RegisterOption(nil, "Spieler töten", 1, function()
	local trace = LocalPlayer():GetEyeTrace()
	local entity = trace.Entity

	if IsValid(entity) and IsValid(entity:GetOwner()) then
		Interact.Menu:Remove()

		local modal = vgui.Create("MedicModal")
		modal:SetCustomTitle("Aktion schreiben")
		modal:Deltaa_TextEntry("Gib an, wie du " .. entity:GetOwner():Nick() .. " tötest.", function(text)
			if not IsValid(entity) then return end

			local owner = entity:GetOwner()
			if not IsValid(owner) then return end

			net.Start("Medicsystem:KillPlayer")
				net.WriteEntity(owner)
				net.WriteString(string.Trim(text))
			net.SendToServer()
		end, function()
		end, "Beschreibe dein Vorgehen. Lasse das /me weg.")
	end
end, function()
	local trace = LocalPlayer():GetEyeTrace()
	local entity = trace.Entity

	-- Check whether the entity is valid
	if not IsValid(entity) then return false end

	-- Checks whether the player is too far away from the entity
	if trace.HitPos:DistToSqr(LocalPlayer():GetShootPos()) > Medicsystem.MaxDistance then return false end

	local ply = Medicsystem:IsValidEntity(entity)
	-- Checks if the entity is valid
	if ply then
		if ply:GetNWBool("Medicsystem.IsDead", false) then return false end
		if ply:IsPlayer() and ply:Alive() then return false end

		if entity:IsRagdoll() then
			return true
		end
	end

	return false
end)
--gamemodes/starwarsrp/gamemode/modules/medicsystem/cl_settings.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--         Medicsystem | CL        	 --
---------------------------------------

Settings:Register("Eigenes PassivRP", "Medicsystem", function() end, "false")
--gamemodes/starwarsrp/gamemode/modules/medicsystem/cl_hooks.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--         Medicsystem | CL        	 --
---------------------------------------

hook.Add("PlayerButtonDown", "Medicsystem.Deathmenu", function(ply, button)
	if not ply:GetCurrentCharacter() then return end
	if ply:Alive() then return end

	if IsValid(Medicsystem.DeathInjuryList) then return end

	if button == KEY_SPACE then
		Medicsystem:ListInjuries()
	end
end)

-- Overrides EGM:RP Deathscreen
hook.Remove("HUDPaint", "DeathSystem.PaintScreen")
hook.Add("HUDPaint", "DeathSystem.PaintScreen", function()
	local ply = LocalPlayer()
	if not IsValid(ply) then return end
	if ply:Alive() then return end

	local lastDeathTime = ply.LastDeathTime

	if lastDeathTime and lastDeathTime > 0 then
		local readyToSpawn = false
		local timeUntilRespawn = 0
		local w, h = ScrW(), ScrH()

		if lastDeathTime then
			timeUntilRespawn = (lastDeathTime + ply.LastDeathDuration) - CurTime()

			if timeUntilRespawn <= 0 then
				readyToSpawn = true
			end
		else
			readyToSpawn = true
		end

		draw.RoundedBox(0, 0, 0, ScrW(), ScrH(), UI.BackgroundColor)
		draw.RoundedBox(0, 0, 0, ScrW(), h * 0.1, UI.BackgroundColor2)
		draw.RoundedBox(0, 0, ScrH() - h * 0.1, ScrW(), h * 0.1, UI.BackgroundColor2)

		if readyToSpawn then
			draw.DrawText(egmt("deathsystem.respawnready"), "EGMText15", w * 0.5, h * 0.9, GetColor("green"), TEXT_ALIGN_CENTER)
		else
			draw.DrawText(os.date("%M:%S", timeUntilRespawn), "EGMText15", w * 0.5, h * 0.9, GetColor("red"), TEXT_ALIGN_CENTER)
		end

		if not IsValid(Medicsystem.DeathInjuryList) then
			draw.DrawText("Drücke LEERTASTE um das Verletzungsmenü anzuzeigen", "EGMText10", w * 0.5, h * 0.95, GetColor("blue"), TEXT_ALIGN_CENTER)
		end

		if LocalPlayer().LastDeathStunned then
			draw.DrawText(egmt("deathsystem.stunned"), "EGMText15", w * 0.5, h * 0.035, UI.TextColor, TEXT_ALIGN_CENTER)
		else
			if LocalPlayer():GetNWBool("Medicsystem.IsDead", false) then
				draw.DrawText("Du bist tot.", "EGMText15", w * 0.5, h * 0.035, UI.TextColor, TEXT_ALIGN_CENTER)
			else
				draw.DrawText("Du bist verletzt.", "EGMText15", w * 0.5, h * 0.035, UI.TextColor, TEXT_ALIGN_CENTER)
			end
		end
	end
end)
--gamemodes/starwarsrp/gamemode/modules/medicsystem_droid/weapons/weapon_swrp_medic_repairkit/shared.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--    Medicsystem | Treatment Kit    --
---------------------------------------

SWEP.Base 					= "weapon_swrp_medic_base"

SWEP.PrintName			  	= "Reparaturkit"
SWEP.Category			   	= "SW:RP (Medicsystem)"
SWEP.Type				   	= "Technical Supply Equipment"
SWEP.Manufacturer		   	= "Bac-Tech Industries"

SWEP.Author 				= "Deltaa"
SWEP.Purpose 				= "Wähle mit 'R' eine Behandlung aus."
SWEP.Contact 				= "https://www.einfach-gaming.de/user/4179-deltaa/"
SWEP.Instructions 			= "Linksklick zur Anwendung bei jemand anderem"
SWEP.Spawnable 				= true

SWEP.ViewModelFOV 			= 80
SWEP.ViewModelFlip			= false
SWEP.ViewModel 				= "models/weapons/v_grenade.mdl"
SWEP.WorldModel 			= "models/weapons/w_datapad.mdl"

SWEP.ShowViewModel 			= true
SWEP.ShowWorldModel 		= false

SWEP.Slot 					= 2
SWEP.SlotPos 				= 0

SWEP.ItemType 				= "Repairkit"
SWEP.UseHands 				= false

SWEP.ViewModelBoneMods = {
	["ValveBiped.Grenade_body"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Pin"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01"] = { scale = Vector(1, 1, 1), pos = Vector(0, -1.297, 0), angle = Angle(0, 0, 0) }
}

SWEP.VElements = {
	["holotablet"] = { type = "Model", model = "models/props/starwars/weapons/fusion_cutter.mdl", bone = "ValveBiped.Grenade_body", rel = "", pos = Vector(-0.519, 0.518, 1.557), angle = Angle(162.468, -180, 24.545), size = Vector(0.82, 0.82, 0.82), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["lighteffect"] = { type = "Sprite", sprite = "sprites/animglow02", bone = "ValveBiped.Grenade_body", rel = "holotablet", pos = Vector(9.869, -0.519, 16.104), size = { x = 10, y = 10 }, color = Color(255, 0, 0, 255), nocull = true, additive = true, vertexalpha = true, vertexcolor = true, ignorez = false},
	["lighteffect+"] = { type = "Sprite", sprite = "sprites/animglow02", bone = "ValveBiped.Grenade_body", rel = "holotablet", pos = Vector(-1.558, -0.519, 9.67), size = { x = 1.599, y = 1.599 }, color = Color(255, 0, 0, 255), nocull = true, additive = true, vertexalpha = true, vertexcolor = true, ignorez = false}
}

SWEP.WElements = {
	["holotablet"] = { type = "Model", model = "models/props/starwars/weapons/fusion_cutter.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(2.596, 4.675, 3.635), angle = Angle(-8.183, -17.532, -146.105), size = Vector(0.885, 0.885, 0.885), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["lighteffect"] = { type = "Sprite", sprite = "sprites/animglow02", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(16.104, -1.558, -12.988), size = { x = 10, y = 10 }, color = Color(255, 0, 0, 255), nocull = true, additive = true, vertexalpha = true, vertexcolor = true, ignorez = false}
}

SWEP.Primary.ClipSize = 100
SWEP.Primary.DefaultClip = 100
SWEP.Primary.Ammo = "none"

-- Aiming
SWEP.IronSightsPos = Vector(0, 0, -2)
SWEP.IronSightsAng = Vector(0, 0, 0)

-- Running
SWEP.RunSightsPos = Vector(0, 0, -2)
SWEP.RunSightsAng = Vector(0, 0, 0)

-- Inspecting
SWEP.InspectPos = Vector(0, 0, -2)
SWEP.InspectAng = Vector(0, 0, 0)

function SWEP:SecondaryAttack()

end
--gamemodes/starwarsrp/gamemode/modules/medicsystem_cwrp/sh_config.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--       Medicsystem | Config        --
---------------------------------------

-- Max distance for some security checks
Medicsystem.MaxDistance = 10000

-- Experience for treatment
Medicsystem.Experience = 30

-- Refill crate model
Medicsystem.RefillModel = "models/starwars/syphadias/props/hoth_barrack/small_box.mdl"

-- From which severity of an injury you get a leg affection
Medicsystem.LegAffect = 4

-- Damagetypes that do not result in injury
Medicsystem.DamageModelResistance = {
	-- Blaster
	[DMG_AIRBOAT] = {
		["models/egm/core/clone_commando/clone_commando.mdl"] = true, -- Clone Commando

		["models/egm/temp/mando_female/mando_female.mdl"] = true, -- Female Mandalorian Armor
		["models/egm/temp/mando_male/mando_male.mdl"] = true, -- Male Mandalorian Armor
	},

	-- Projectiles
	[DMG_BULLET] = {
		["models/egm/core/clone_commando/clone_commando.mdl"] = true, -- Clone Commando

		["models/egm/temp/mando_female/mando_female.mdl"] = true, -- Female Mandalorian Armor
		["models/egm/temp/mando_male/mando_male.mdl"] = true, -- Male Mandalorian Armor
	},

	-- Cuts
	[DMG_SLASH] = {
		["models/egm/core/clone_commando/clone_commando.mdl"] = true, -- Clone Commando

		["models/egm/temp/mando_female/mando_female.mdl"] = true, -- Female Mandalorian Armor
		["models/egm/temp/mando_male/mando_male.mdl"] = true, -- Male Mandalorian Armor
	},

	-- Fist damage
	[DMG_CLUB] = {
		["models/egm/core/clone_commando/clone_commando.mdl"] = true, -- Clone Commando

		["models/egm/temp/mando_female/mando_female.mdl"] = true, -- Female Mandalorian Armor
		["models/egm/temp/mando_male/mando_male.mdl"] = true, -- Male Mandalorian Armor
	},
}

Medicsystem.Hitgroups = {
	[HITGROUP_HEAD] = "Kopf",
	[HITGROUP_CHEST] = "Thorax",
	[HITGROUP_STOMACH] = "Abdomen",
	[HITGROUP_LEFTARM] = "Linker Arm",
	[HITGROUP_RIGHTARM] = "Rechter Arm",
	[HITGROUP_LEFTLEG] = "Linkes Bein",
	[HITGROUP_RIGHTLEG] = "Rechtes Bein",

	[0] = "Nicht definiert"
}

-- Multiplies for kill check
Medicsystem.DeathMultiplies = {
	["Kopf"] = 1,
	["Thorax"] = 2,
	["Abdomen"] = 3,
	["Linker Arm"] = 4,
	["Rechter Arm"] = 4,
	["Linkes Bein"] = 4,
	["Rechtes Bein"] = 4
}

-- The injury severities are listed here
--
Medicsystem.InjurySeverities = {
	"Gering",
	"Ernsthaft",
	"Schwer",
	"Sehr schwer",
	"Kritisch",
	"Fatal"
}

--gamemodes/starwarsrp/gamemode/modules/gravitylock/entities/swrp_gravitylock_big/cl_init.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--           Gravity Lock            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--         Gravity Lock | CL         --
---------------------------------------


include("shared.lua")

function ENT:Draw()
	self:DrawModel()
end
--gamemodes/egmrp/gamemode/modules/morgue/sh_morgue.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--          Morgue | Shared          --
---------------------------------------

-- Add the spawnable custom body bags using the preset class.
hook.Add("EGMRP.Loaded", "Morgue.AddCustomBodyBags", function()
	for bodyBagModel, bodyBagData in pairs(Morgue.BodyBagModels) do
		local SWEP = {
			Spawnable = true,
			Base = "egmrp_bodybag",
			BodyBagModel = bodyBagModel,

			ClassName = bodyBagData.ClassName,
			PrintName = bodyBagData.Name,
			Category = bodyBagData.Category,

			BagCount = bodyBagData.BagCount,

			RagdollOffset = bodyBagData.RagdollOffset,
			RagdollAngle = bodyBagData.RagdollAngle,
			RagdollBone = bodyBagData.RagdollBone,
		}

		weapons.Register(SWEP, bodyBagData.ClassName)

		if bodyBagData.CreateMorgue then
			local ENT = {
				Spawnable = true,
				Base = "egmrp_morgue",
				Type = "anim",
				WorldModel = bodyBagData.MorgueModel,

				ClassName = bodyBagData.ClassName .. "_morgue",
				Folder = "entities/" .. bodyBagData.ClassName .. "_morgue",
				PrintName = egmt("morgue.entity") .. " (" .. bodyBagData.Name .. ")",
				Category = bodyBagData.Category,

				BodyBagClass = bodyBagData.ClassName,
			}

			scripted_ents.Register(ENT, bodyBagData.ClassName .. "_morgue")
		end
	end
end)
--gamemodes/egmrp/gamemode/modules/permaprops/cl_interact.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Permaprop Interact         --
---------------------------------------

hook.Add("EGMRP.Loaded", "PermaProps.Interact", function()
    if Config.Modules["interact"] then
        Interact:RegisterOption("team", egmt("permaprops.name"), 1, function()
            PermaProps:OpenMenu()
            Interact.Menu:Remove()
        end, function()
            return LocalPlayer():IsAtLeast(PermaProps.MinimumGroup)
        end)

        Interact:RegisterOption(nil, egmt("permaprops.show"), 10, function()
            local ent = LocalPlayer():GetEyeTrace().Entity
            PermaProps.PPIDToOpen = ent:GetNW2Int("PPID", -1)

            net.Start("PermaProps.GetPage")
                net.WriteInt(PermaProps.PPIDToOpen, 32)
            net.SendToServer()

            Interact.Menu:Remove()
        end, function()
            local ent = LocalPlayer():GetEyeTrace().Entity

            if IsValid(ent) and ent:GetNW2Int("PPID", -1) >= 0 then
                return true
            end

            return false
        end)

        net.Receive("PermaProps.GetPage", function()
            local page = net.ReadInt(32)

            PermaProps:OpenMenu(page)
        end)
    end
end)
--gamemodes/egmrp/gamemode/modules/reports/sh_index.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--            Reports index          --
---------------------------------------

Reports = Reports or {}

if SERVER then
    AddCSLuaFile("sh_config.lua")
    AddCSLuaFile("sh_reports.lua")
    AddCSLuaFile("cl_reports.lua")
    AddCSLuaFile("cl_interact.lua")

    include("sh_config.lua")
    include("sh_reports.lua")
    include("sv_reports.lua")
end

if CLIENT then
    include("sh_config.lua")
    include("sh_reports.lua")
    include("cl_reports.lua")
    include("cl_interact.lua")
end
--gamemodes/egmrp/gamemode/modules/multiserver/sh_chats.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--    Shared | MultiServer Chats     --
---------------------------------------

if MultiServer.DisableAtlasChatMessages then
    if CLIENT then
        hook.Remove("player_disconnect", "atlaschat.DisconnectMessage")
    elseif SERVER then
        hook.Remove("player_connect", "atlaschat.PlayerConnect")
    end
end
--gamemodes/egmrp/gamemode/modules/multiserver/cl_scoreboard.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
-- Multiserver - Scoreboard | Client --
---------------------------------------

-- Adds the "Ausbildung bestanden" button to the scoreboard.
Scoreboard:AddOption(
    egmt("multiserver.send"),
    "icon16/server_go.png",
    600,
    function(target)
        MultiServer:OpenAdminChangeServerMenu(target)
    end,
    function(target)
        if LocalPlayer():IsAtLeast(MultiServer.MinimumChangeServerRank) then
            return true
        end

        return false
    end
)
--gamemodes/starwarsrp/gamemode/modules/medicsystem_jedi/sh_index.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--      Medicsystem | SH Index       --
---------------------------------------

if not RequireModules({"medicsystem"}) then return end

if SERVER then
	include("sv_medicsystem.lua")
end

hook.Add("EGMRP.Loaded", "Medicsystem_Jedi.LoadData", function()
	if SERVER then
		local mainpath = GAMEMODE.FolderName .. "/gamemode/modules/medicsystem_jedi"
		local treatmentFiles = file.Find(mainpath .. "/treatments/" .. "*.lua", "LUA")
		for k, fileName in pairs(treatmentFiles) do
			AddCSLuaFile(mainpath .. "/treatments/" .. fileName)
			include(mainpath .. "/treatments/" .. fileName)
		end
	else
		local mainpath = GAMEMODE.FolderName .. "/gamemode/modules/medicsystem_jedi"
		local treatmentFiles = file.Find(mainpath .. "/treatments/" .. "*.lua", "LUA")
		for k, fileName in pairs(treatmentFiles) do
			include(mainpath .. "/treatments/" .. fileName)
		end
	end
end)
--gamemodes/egmrp/gamemode/modules/experience/cl_keybinds.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--    Client | Experience keybinds   --
---------------------------------------

KeyBind:Register(egmt("experience.perks"), egmt("shared.normal"), function()
    Experience:OpenPerkMenu()
end, Experience.PerkMenuDefaultKey)

--gamemodes/starwarsrp/gamemode/modules/bactainjector/sh_index.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--          Bacta Injector           --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--     Bacta Injector | SH Index     --
---------------------------------------

BactaInjector = BactaInjector or {}

if SERVER then
	AddCSLuaFile("sh_config.lua")
	AddCSLuaFile("cl_interact.lua")

	include("sh_config.lua")
	include("sv_bactainjector.lua")
end

if CLIENT then
	include("sh_config.lua")
	include("cl_interact.lua")
end
--gamemodes/starwarsrp/gamemode/modules/bactainjector/cl_interact.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--          Bacta Injector           --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--   Bacta Injector | CL Interact    --
---------------------------------------

-- Adds an option to open a player scan menu
--
Interact:RegisterOption(nil, "Bactainjektor", 1, function()
	local trace = LocalPlayer():GetEyeTrace()
	local entity = trace.Entity

	net.Start("BactaInjector.Revive")
		net.WriteEntity(entity)
	net.SendToServer()

	Interact.Menu:Remove()
end, function()
	local trace = LocalPlayer():GetEyeTrace()
	local entity = trace.Entity

	-- Check if the entity is valid
	if not IsValid(entity) then return false end

	-- The entity must be a ragdoll
	if not entity:IsRagdoll() then return false end

	-- Check whether the entity has a valid owner
	if not IsValid(entity:GetOwner()) then return false end

	-- Checks whether the player is too far away from the entity
	if trace.HitPos:DistToSqr(LocalPlayer():GetShootPos()) > Medicsystem.MaxDistance then return false end

	return BactaInjector.Models[entity:GetModel()]
end)
--gamemodes/egmrp/gamemode/modules/inventory_loadout/item_slots/loadout/shared.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--     Shared | Loadout Item Slot     --
---------------------------------------

local ITEM_SLOT = ITEM_SLOT

-- Base Item slot, from which functions and such should be inherited.
ITEM_SLOT.BaseItemSlot = "base"

-- Number of items that can be stored in this slot.
ITEM_SLOT.Count = 12

-- Are items equipped as useable items?
ITEM_SLOT.Equipment = false
--gamemodes/egmrp/gamemode/modules/inventory_loadout/item_slots/loadout/cl_init.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--     Client | Loadout Item Slot    --
---------------------------------------

local ITEM_SLOT = ITEM_SLOT

-- Name of the item slot displayed in the inventory.
ITEM_SLOT.Name = ""

-- Number of rows, the items should be displayed in.
ITEM_SLOT.Rows = 1

-- Prevent Click Interaction on supply slots.
function ITEM_SLOT:OnClick(slot)
end

-- Prevent Drag Interaction on supply slots.
function ITEM_SLOT:OnRelease(slot)
end

-- Prevent Right Click Interaction on supply slots.
function ITEM_SLOT:OnRightClick(slot)
end

-- Prevent Shift Click Interaction on supply slots.
function ITEM_SLOT:OnShiftClick(slot)
end
--gamemodes/egmrp/gamemode/modules/spawnpoints/stools/spawnpoints_tool.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--     Shared | Spawnpoints STool    --
---------------------------------------
TOOL.Category = "EGM:RP"
TOOL.Name = "#Tool.spawnpoints_tool.name"
TOOL.Command = nil
TOOL.ConfigName = nil

Spawnpoints.spawnSelected = {}

local factionSelected = nil
local rankSelected = nil
local defaultSelected = false
local tempBooleanValue = true
local colorSelected = nil

if CLIENT then
    language.Add("Tool.spawnpoints_tool.name", "Spawnpoints")
    language.Add("Tool.spawnpoints_tool.desc", "Setzte die Spawnpunkte auf der Map")
    language.Add("Tool.spawnpoints_tool.0", "Linksklick: Setzen; Rechtsklick: Entfernen")
end

function TOOL:LeftClick(trace)
    if not IsFirstTimePredicted() and CLIENT then return end
    local pos = trace.HitPos

    if tempBooleanValue then
        Spawnpoints.spawnSelected[0] = pos
    else
        table.insert(Spawnpoints.spawnSelected, pos)
    end

    if defaultSelected then
        Spawnpoints:SetFactionSpawn(-1, pos, tempBooleanValue)

        return true
    end

    if rankSelected then
        Spawnpoints:SetRankSpawn(factionSelected:GetId(), rankSelected:GetId(), pos, tempBooleanValue)

        return true
    end

    if factionSelected then
        Spawnpoints:SetFactionSpawn(factionSelected:GetId(), pos, tempBooleanValue)

        return true
    end
end

function TOOL:RightClick(trace)
    if not IsFirstTimePredicted() and CLIENT then return end

    local pos = trace.HitPos

    if defaultSelected then
        Spawnpoints:RemoveFactionSpawn(-1, pos)
        return true
    end

    if rankSelected then
        Spawnpoints:RemoveRankSpawn(factionSelected:GetId(), rankSelected:GetId(), pos)
        return true
    end

    if factionSelected then
        Spawnpoints:RemoveFactionSpawn(factionSelected:GetId(), pos)
        return true
    end
end

function TOOL:BuildCPanel()
    local description = vgui.Create("DLabel", self)
    description:Dock(TOP)
    description:SetText("#Tool.spawnpoints.desc")
    description:SetContentAlignment(5)
    description:SetTextColor(GetColor("darkgray"))

    local factionTitle = vgui.Create("DLabel", self)
    factionTitle:Dock(TOP)
    factionTitle:SetText("Fraktionsspawn")
    factionTitle:SetContentAlignment(5)
    factionTitle:SetTextColor(GetColor("darkgray"))

    local factionList
    local rankList
    local selectedName

    local defaultButton = vgui.Create("DButton", self)
    defaultButton:DockMargin(0, 0, 0, 16)
    defaultButton:Dock(TOP)
    defaultButton:SetHeight(ScrH() * 0.04)
    defaultButton:SetText("Select Default Spawn")
    defaultButton:SetContentAlignment(5)
    defaultButton:SetTextColor(GetColor("darkgray"))
    function defaultButton:DoClick()
        factionSelected = nil
        rankSelected = nil
        colorSelected = Color(255, 255, 255)

        defaultSelected = true

        selectedName:SetText("Default Spawn")

        Spawnpoints.spawnSelected = {}

        Spawnpoints:GetFactionSpawns(-1, function(pos)
            Spawnpoints.spawnSelected = pos

        end)

        factionList:Refresh()
        rankList:Refresh(factionSelected)
    end


    local temporaryTitle = vgui.Create("DLabel", self)
    temporaryTitle:Dock(TOP)
    temporaryTitle:DockMargin(0, 0, 0, 2)
    temporaryTitle:SetText("Setze Spawn nur temporär?")
    temporaryTitle:SetContentAlignment(5)
    temporaryTitle:SetTextColor(GetColor("darkgray"))

    tempBoolean = vgui.Create("DButton", self)
    tempBoolean:DockMargin(0, 0, 0, 16)
    tempBoolean:Dock(TOP)
    tempBoolean:SetHeight(ScrH() * 0.02)
    tempBoolean:SetText("")
    tempBoolean.Value = tempBooleanValue

    function tempBoolean:Paint(width, height)
        local green = GetColor("green")
        local red = GetColor("red")

        if self.Value then
            draw.RoundedBox(0, 0, 0, width * 0.7, height, green)
            draw.RoundedBox(0, width * 0.7, 0, width * 0.3, height, red)
            draw.SimpleText(egmt("propertymodel.yes"), "EGMText6", width * 0.35, height * 0.5, UI.TextColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        else
            draw.RoundedBox(0, 0, 0, width * 0.3, height, green)
            draw.RoundedBox(0, width * 0.3, 0, width * 0.7, height, red)
            draw.SimpleText(egmt("propertymodel.no"), "EGMText6", width * 0.65, height * 0.5, UI.TextColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        end
    end

    function tempBoolean:DoClick()
        tempBoolean.Value = not tempBoolean.Value
        tempBooleanValue = tempBoolean.Value
    end

    factionList = vgui.Create("DListView", self)
    factionList:SetHeight(ScrH() * 0.2)
    factionList:Dock(TOP)
    factionList:AddColumn("Fraktion")
    function factionList:Refresh()
        factionList:Clear()

        for k, faction in pairs(Faction:GetCache()) do
            local line = factionList:AddLine(faction:GetName())
            line.faction = faction
        end
    end
    function factionList:OnRowSelected(index, line)
        factionSelected = line.faction
        colorSelected = factionSelected:GetProperty("color", Color(255, 255, 255))
        rankSelected = nil

        defaultSelected = false

        selectedName:SetText(factionSelected:GetName())

        Spawnpoints.spawnSelected = {}

        Spawnpoints:GetFactionSpawns(factionSelected:GetId(), function(pos)
            Spawnpoints.spawnSelected = pos

        end)

        rankList:Refresh(factionSelected)
    end

    local rankTitle = vgui.Create("DLabel", self)
    rankTitle:Dock(TOP)
    rankTitle:SetText("Rangspawn")
    rankTitle:SetContentAlignment(5)
    rankTitle:SetTextColor(GetColor("darkgray"))

    rankList = vgui.Create("DListView", self)
    rankList:SetHeight(ScrH() * 0.2)
    rankList:Dock(TOP)
    rankList:AddColumn("Rang")
    function rankList:Refresh(faction)
        rankList:Clear()

        if not faction then return end

        for k, rank in pairs(faction:GetRanks()) do
            local line = rankList:AddLine(rank:GetName())
            line.rank = rank
        end
    end
    function rankList:OnRowSelected(index, line)
        rankSelected = line.rank
        colorSelected = factionSelected:GetProperty("color", Color(255, 255, 255))

        defaultSelected = false

        selectedName:SetText(factionSelected:GetProperty("prefix", "") .. " " .. rankSelected:GetName())

        Spawnpoints.spawnSelected = {}

        Spawnpoints:GetRankSpawns(factionSelected:GetId(), rankSelected:GetId(), function(pos)
            Spawnpoints.spawnSelected = pos

        end)
    end
    function rankList:OnRowRightClick(index, line)
        rankSelected = nil
        Spawnpoints.spawnSelected = {}

        line:SetSelected(false)


        factionIndex, factionLine = factionList:GetSelectedLine()
        factionSelected = factionLine.faction

        colorSelected = factionSelected:GetProperty("color", Color(255, 255, 255))

        selectedName:SetText(factionSelected:GetName())

        Spawnpoints:GetFactionSpawns(factionSelected:GetId(), function(pos)
            Spawnpoints.spawnSelected = pos

        end)
    end

    local selectedSpawn = vgui.Create("DPanel", self)
    selectedSpawn:SetHeight(ScrH() * 0.1)
    selectedSpawn:Dock(TOP)

    local selectedTitel = vgui.Create("DLabel", selectedSpawn)
    selectedTitel:Dock(TOP)
    selectedTitel:SetText("Ausgewählter Spawn:")
    selectedTitel:SetContentAlignment(5)
    selectedTitel:SetTextColor(GetColor("darkgray"))

    selectedName = vgui.Create("DLabel", selectedSpawn)
    selectedName:Dock(TOP)
    selectedName:SetText("---")
    selectedName:SetContentAlignment(5)
    selectedName:SetTextColor(GetColor("darkgray"))

    factionList:Refresh()
end

local innerRadius = 5
local outerRadius = 10
local height = 30

-- Renders the marker.
hook.Add( "HUDPaint", "Spawnpoints.Render", function()
    if LocalPlayer():GetActiveWeapon() and IsValid(LocalPlayer():GetActiveWeapon()) and LocalPlayer():GetActiveWeapon():GetClass() == "gmod_tool" and LocalPlayer():GetTool() and LocalPlayer():GetTool().Mode == "spawnpoints_tool" then
        cam.Start3D()
            if table.Count(Spawnpoints.spawnSelected) > 0 then
                for k,vectorData in pairs(Spawnpoints.spawnSelected) do
                    if isvector(vectorData) then
                        render.DrawLine(vectorData, vectorData + Vector(-outerRadius, -outerRadius, height), colorSelected)
                        render.DrawLine(vectorData, vectorData + Vector(-outerRadius,  outerRadius, height), colorSelected)
                        render.DrawLine(vectorData, vectorData + Vector( outerRadius, -outerRadius, height), colorSelected)
                        render.DrawLine(vectorData, vectorData + Vector( outerRadius,  outerRadius, height), colorSelected)

                        render.DrawWireframeBox(vectorData, Angle(), Vector(-outerRadius, -outerRadius, height), Vector(outerRadius, outerRadius, height + outerRadius * 2), colorSelected)
                        render.DrawWireframeSphere(vectorData + Vector(0, 0, height + outerRadius), innerRadius, 32, 32, colorSelected)
                        render.DrawWireframeBox(vectorData, Angle(), Vector(-innerRadius, -innerRadius, height + (outerRadius - innerRadius)), Vector(innerRadius, innerRadius, height + (outerRadius - innerRadius) + innerRadius * 2), colorSelected)

                        render.DrawLine(vectorData + Vector(0, 0, height * 1.5 + outerRadius * 2), vectorData + Vector(-outerRadius, -outerRadius, height + outerRadius * 2), colorSelected)
                        render.DrawLine(vectorData + Vector(0, 0, height * 1.5 + outerRadius * 2), vectorData + Vector(-outerRadius,  outerRadius, height + outerRadius * 2), colorSelected)
                        render.DrawLine(vectorData + Vector(0, 0, height * 1.5 + outerRadius * 2), vectorData + Vector( outerRadius, -outerRadius, height + outerRadius * 2), colorSelected)
                        render.DrawLine(vectorData + Vector(0, 0, height * 1.5 + outerRadius * 2), vectorData + Vector( outerRadius,  outerRadius, height + outerRadius * 2), colorSelected)
                    end
                end
            end
        cam.End3D()
    end
end )
--gamemodes/starwarsrp/gamemode/modules/armorweapon/sh_index.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Index | Armor Weapon       --
---------------------------------------

if not RequireModules({"inventory"}) then
	return false
end

ArmorWeapon = ArmorWeapon or {}
--gamemodes/starwarsrp/gamemode/modules/armorweapon/item_classes/armorweapon/cl_init.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--       Client | Armor Weapon       --
---------------------------------------

local ITEM_CLASS = ITEM_CLASS

-- Display name for the type used in UI elements.
ITEM_CLASS.Name = "Rüstung (Integrierte Waffen)"

-- List of properties that should be shown in the manager, if this item class is used.
ITEM_CLASS.PropertyList = {"models", "armorBonus", "speedBonus", "consealedWeapon", "backpackSlots", "species", "weapons"}



---------------------------------------
--              Tooltip              --
---------------------------------------

function ITEM_CLASS:AddDescriptionLines(itemType, itemData, lines)
	ITEM_CLASS.Base.AddDescriptionLines(self, itemType, itemData, lines)

	local weaponList = itemType:GetWeapons()
	if #weaponList == 0 then
		return
	end

	table.insert(lines, {})
	table.insert(lines, {
		Text = "Integrierte Waffen:",
		Color = UI.ForegroundColor2,
		Align = TEXT_ALIGN_LEFT
	})

	for _, weaponClass in ipairs(weaponList) do
		local weapon = weapons.Get(weaponClass)
		if istable(weapon) then
			table.insert(lines, {
				Text = weapon.PrintName,
				Color = UI.TextColor,
				Align = TEXT_ALIGN_RIGHT
			})

			continue
		end
		weapon = list.Get("Weapon")[weaponClass]
		if istable(weapon) then
			table.insert(lines, {
				Text = weapon.PrintName,
				Color = UI.TextColor,
				Align = TEXT_ALIGN_RIGHT
			})

			continue
		end

		table.insert(lines, {
			Text = weaponClass,
			Color = UI.TextColor,
			Align = TEXT_ALIGN_RIGHT
		})
	end
end
--gamemodes/starwarsrp/gamemode/modules/eventmanager/sh_index.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--           Event Manager           --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--       Event Manager | Index       --
---------------------------------------

if not RequireModules({"medicsystem", "eventlog", "keybinds"}) then return end

EventManager = EventManager || {}
EventManager.Factions = EventManager.Factions || {}
EventManager.Config = EventManager.Config || {}

if SERVER then
	AddCSLuaFile("sh_config.lua")
	AddCSLuaFile("sh_eventmanager.lua")
	AddCSLuaFile("cl_eventmanager.lua")

	include("sh_config.lua")
	include("sh_eventmanager.lua")
	include("sv_eventmanager.lua")
	include("sv_hooks.lua")
end

if CLIENT then
	include("sh_config.lua")
	include("sh_eventmanager.lua")
	include("cl_eventmanager.lua")
end
--gamemodes/egmrp/gamemode/modules/ammosystem/sh_index.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--         AmmoSystem | Index        --
---------------------------------------

AmmoSystem = AmmoSystem or {}

if SERVER then
    AddCSLuaFile("sh_config.lua")
    AddCSLuaFile("cl_ammosystem.lua")

    include("sh_config.lua")
    include("sv_ammosystem.lua")
end

if CLIENT then
    include("sh_config.lua")
    include("cl_ammosystem.lua")
end
--gamemodes/egmrp/gamemode/modules/ammosystem/entities/egmrp_ammolocker/shared.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--      Shared | Ammolocker Entity   --
---------------------------------------

ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = egmt("ammosystem.equipment")
ENT.Category = "EGM:RP"
ENT.Author = "P4sca1 & Oninoni"
ENT.Purpose = ""

ENT.Spawnable = true
ENT.AdminOnly = false

ENT.WorldModel = AmmoSystem.Model

-- Initializes the entity.
function ENT:Initialize()
    self.WorldModel = AmmoSystem.Model

    if util.IsValidModel(self.WorldModel) then
        self:SetModel(self.WorldModel)
    else
        self:SetModel("models/Items/ammocrate_smg1.mdl")
    end

    self:SetMoveType(MOVETYPE_VPHYSICS)
    self:SetSolid(SOLID_VPHYSICS)

    if SERVER then
        self:PhysicsInit(SOLID_VPHYSICS)
        self:SetUseType(SIMPLE_USE)
    end

    local phys = self:GetPhysicsObject()

    if phys:IsValid() then
        phys:Wake()
        phys:SetMass(50)
    end
end
--gamemodes/egmrp/gamemode/modules/signs/sh_config.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--           Signs | Config          --
---------------------------------------
--  Variables should be overwritten  --
--     in the deriving gamemode!     --
---------------------------------------

-- Fonts Used for Textscreens.
Signs.Fonts = {
    {
        Name = "Signs Default",
        Font = "Arial",
        Min = 1,
        Max = 20,
        SizeOffset = 20,
        SizeMultiplier = 4,
    },
}
--gamemodes/egmrp/gamemode/modules/signs/entities/egmrp_signs/shared.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Shared | Sign Entity       --
---------------------------------------

ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "EGM:RP Sign"
ENT.Category = "EGM:RP"
ENT.Author = "Oninoni"
ENT.Purpose = ""

ENT.Spawnable = false
ENT.AdminOnly = false
--gamemodes/egmrp/gamemode/modules/signs/stools/egmrp_signs.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Shared | Signs STool       --
---------------------------------------

TOOL.Category = "EGM:RP"
TOOL.Name = "#Tool.egmrp_signs.name"
TOOL.Command = nil
TOOL.ConfigName = nil

if CLIENT then
    language.Add("Tool.egmrp_signs.name", egmt("signs.signs"))
    language.Add("Tool.egmrp_signs.desc", egmt("signs.desc"))
    language.Add("Tool.egmrp_signs.0", egmt("signs.controls"))
end

-- Place a sign according to the values set in the menu.
function TOOL:LeftClick(tr)
    if not IsFirstTimePredicted() then return false end

    if CLIENT then
        local signData = Signs:GetToolData()

        net.Start("Signs.CreateSign")
            net.WriteTable(signData)
        net.SendToServer()
    end

    return true
end

-- Remove Update a sign according to the values set in the menu.
function TOOL:RightClick(tr)
    if not IsFirstTimePredicted() then return false end

    if CLIENT then
        local signData = Signs:GetToolData()

        net.Start("Signs.UpdateSign")
            net.WriteTable(signData)
        net.SendToServer()
    end

    return true
end

-- Reload to copy a sign.
function TOOL:Reload(tr)
    if not IsFirstTimePredicted() then return false end

    if CLIENT then
        local ent = tr.Entity
        if not IsValid(ent) or ent:GetClass() ~= "egmrp_signs" then return false end

        local uuid = ent:GetNWString("UUID", "")
        local signData = Signs.SignDataCache[uuid]
        Signs:SetToolData(signData)

        local generalSettings = Signs.GeneralSettings
        local signDataPanel = Signs.SignDataPanel
        if IsValid(generalSettings) and IsValid(signDataPanel) then
            generalSettings:Reload()
            signDataPanel:Reload()
        end
    end

    return true
end

-- Build the menu for the signs tool.
function TOOL.BuildCPanel(cPanel)
    local importExportPanel = vgui.Create("DCollapsibleCategory", cPanel)
    importExportPanel:DockMargin(5, 5, 5, 2)
    importExportPanel:Dock(TOP)
    importExportPanel:SetHeaderHeight(40)
    importExportPanel:SetLabel("")
    function importExportPanel:Paint(w, h)
        draw.RoundedBox(0, 0, 0, w, h, UI.BackgroundColor)

        draw.RoundedBox(0, 0, 5, w, 30, UI.BackgroundColor2)
        draw.SimpleText(egmt("signs.import_export"), "EGMText5", w / 2, 20, Color(255, 255, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
    end
    function importExportPanel:Reload()
        for i, child in pairs(self:GetChildren()) do
            if i == 1 then continue end

            child:Remove()
        end

        local exportButton = vgui.Create("DButton", self)
        exportButton:SetText(egmt("signs.export_clipboard"))
        exportButton:SetHeight(30)
        exportButton:DockMargin(5, 0, 5, 2)
        exportButton:Dock(TOP)
        exportButton:SetFont("EGMText6")
        function exportButton:DoClick()
            local jsonToolData = Signs:GetToolDataJSON()

            SetClipboardText(jsonToolData)
        end

        local importTextEntry = vgui.Create("DTextEntry", self)
        importTextEntry:SetHeight(30)
        importTextEntry:DockMargin(5, 5, 5, 2)
        importTextEntry:Dock(TOP)
        importTextEntry:SetText(egmt("signs.paste_data"))
        importTextEntry:SetFont("EGMText6")
        importTextEntry:SetUpdateOnType(true)

        local importButton = vgui.Create("DButton", self)
        importButton:SetText(egmt("signs.import_data"))
        importButton:SetHeight(30)
        importButton:DockMargin(5, 5, 5, 2)
        importButton:Dock(TOP)
        importButton:SetFont("EGMText6")
        function importButton:DoClick()
            local jsonToolData = importTextEntry:GetValue()

            Signs:SetToolDataJSON(jsonToolData)

            Signs.GeneralSettings:Reload()
            Signs.SignDataPanel:Reload()
        end

        local importExportPadding = vgui.Create("DPanel", self)
        importExportPadding:SetHeight(5)
        importExportPadding:DockMargin(5, 0, 5, 2)
        importExportPadding:Dock(TOP)
        function importExportPadding:Paint(w, h)
        end
    end

    importExportPanel:Reload()

    local generalSettings = vgui.Create("DCollapsibleCategory", cPanel)
    Signs.GeneralSettings = generalSettings
    generalSettings:DockMargin(5, 2, 5, 2)
    generalSettings:Dock(TOP)
    generalSettings:SetHeaderHeight(40)
    generalSettings:SetLabel("")
    function generalSettings:Paint(w, h)
        draw.RoundedBox(0, 0, 0, w, h, UI.BackgroundColor)

        draw.RoundedBox(0, 0, 5, w, 30, UI.BackgroundColor2)
        draw.SimpleText("General Settings", "EGMText5", w / 2, 20, Color(255, 255, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
    end
    function generalSettings:Reload()
        for i, child in pairs(self:GetChildren()) do
            if i == 1 then continue end

            child:Remove()
        end

        local dCheckBox = vgui.Create("DCheckBoxLabel", self)
        dCheckBox:SetText(egmt("signs.mirror"))
        dCheckBox:SetHeight(30)
        dCheckBox:DockMargin(5, 5, 5, 2)
        dCheckBox:Dock(TOP)
        dCheckBox:SetValue(cookie.GetNumber("signs_mirror") or 0)
        dCheckBox:SetFont("EGMText6")
        function dCheckBox:OnChange(value)
            cookie.Set("signs_mirror", value and 1 or 0)
        end

        signSize = vgui.Create("DNumSlider", self)
        signSize:SetHeight(30)
        signSize:DockMargin(10, 5, 0, 2)
        signSize:Dock(TOP)
        signSize:SetDecimals(2)
        signSize:SetText(egmt("signs.size"))
        function signSize:OnValueChanged(value)
            cookie.Set("signs_size", math.Round(value, 2))
        end

        signSize:SetMinMax(0.01, 2)
        signSize:SetValue(cookie.GetNumber("signs_size") or 1)

        local generalSettingsPadding = vgui.Create("DPanel", self)
        generalSettingsPadding:SetHeight(5)
        generalSettingsPadding:DockMargin(5, 0, 5, 2)
        generalSettingsPadding:Dock(TOP)
        function generalSettingsPadding:Paint(w, h)
        end
    end

    generalSettings:Reload()

    local signDataPanel = vgui.Create("DCollapsibleCategory", cPanel)
    Signs.SignDataPanel = signDataPanel
    signDataPanel:DockMargin(5, 2, 5, 2)
    signDataPanel:Dock(TOP)
    signDataPanel:SetHeaderHeight(40)
    signDataPanel:SetLabel("")
    function signDataPanel:Paint(w, h)
        draw.RoundedBox(0, 0, 0, w, h, UI.BackgroundColor)

        draw.RoundedBox(0, 0, 5, w, 30, UI.BackgroundColor2)
        draw.SimpleText("Sign Data", "EGMText5", w / 2, 20, Color(255, 255, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
    end
    function signDataPanel:Reload()
        local lineCount = cookie.GetNumber("signs_count") or 4

        for i, child in pairs(self:GetChildren()) do
            if i == 1 then continue end

            child:Remove()
        end

        local countPanel = vgui.Create("DPanel", self)
        countPanel:SetHeight(30)
        countPanel:DockMargin(5, 0, 5, 2)
        countPanel:Dock(TOP)
        function countPanel:Paint(w, h)
            local text = egmt("signs.lines") .. lineCount

            draw.SimpleText(text, "EGMText6", w / 2, h / 2, Color(255, 255, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        end

        local removeButton = vgui.Create("DButton", countPanel)
        removeButton:SetText("-")
        removeButton:DockMargin(5, 0, 5, 0)
        removeButton:Dock(LEFT)
        function removeButton:Paint(w, h)
            draw.RoundedBox(0, 0, 0, w, h, Color(255, 255, 255, 200))
        end
        function removeButton:DoClick()
            lineCount = math.max(1, lineCount - 1)
            cookie.Set("signs_count", lineCount)

            signDataPanel:Reload()
        end

        local addButton = vgui.Create("DButton", countPanel)
        addButton:SetText("+")
        addButton:DockMargin(5, 0, 5, 0)
        addButton:Dock(RIGHT)
        function addButton:Paint(w, h)
            draw.RoundedBox(0, 0, 0, w, h, Color(255, 255, 255, 200))
        end
        function addButton:DoClick()
            lineCount = math.min(9, lineCount + 1)
            cookie.Set("signs_count", lineCount)

            signDataPanel:Reload()
        end

        for i = 1, lineCount do
            local panel = vgui.Create("DPanel", self)
            panel:SetHeight(300)
            panel:DockMargin(5, 5, 5, 2)
            panel:Dock(TOP)
            function panel:Paint(w, h)
                draw.RoundedBox(0, 0, 0, w, h, UI.BackgroundColor)
            end

            local dropdown = vgui.Create("DComboBox", panel)
            dropdown:SetHeight(30)
            dropdown:DockMargin(5, 5, 5, 2)
            dropdown:Dock(TOP)
            dropdown:AddChoice(egmt("signs.text"))
            dropdown:AddChoice(egmt("signs.image"))
            dropdown:AddChoice(egmt("signs.spacer"))
            dropdown:ChooseOptionID(cookie.GetNumber("signs_mode" .. i) or 1)
            dropdown:SetFont("EGMText6")
            function dropdown:OnSelect(index, value, data)
                cookie.Set("signs_mode" .. i, index)

                panel:Reload()
            end

            function panel:Reload()
                for id, child in pairs(self:GetChildren()) do
                    if id == 1 then continue end

                    child:Remove()
                end

                local id = dropdown:GetSelectedID()
                if id == 1 then -- Text Mode
                    local textEntry = vgui.Create("DTextEntry", panel)
                    textEntry:SetHeight(30)
                    textEntry:DockMargin(5, 5, 5, 2)
                    textEntry:Dock(TOP)
                    textEntry:SetText(cookie.GetString("signs_text" .. i) or "")
                    textEntry:SetFont("EGMText6")
                    textEntry:SetUpdateOnType(true)
                    function textEntry:OnValueChange(value)
                        cookie.Set("signs_text" .. i, value)
                    end

                    local fontSize
                    local fontSelector = vgui.Create("DComboBox", panel)
                    fontSelector:SetHeight(30)
                    fontSelector:DockMargin(5, 5, 5, 2)
                    fontSelector:Dock(TOP)
                    fontSelector:SetFont("EGMText6")

                    local selectedFontName = cookie.GetString("signs_font" .. i) or Signs.Fonts[1].Name
                    local selectedFontData
                    for _, fontData in pairs(Signs.Fonts) do
                        if fontData.Name == selectedFontName then
                            fontSelector:AddChoice(fontData.Name, fontData, true)

                            selectedFontData = fontData
                        else
                            fontSelector:AddChoice(fontData.Name, fontData, false)
                        end
                    end

                    if selectedFontData == nil then
                        selectedFontData = Signs.Fonts[1]
                        fontSelector:ChooseOptionID(1)
                    end

                    function fontSelector:OnSelect(index, fontName, fontData)
                        cookie.Set("signs_font" .. i, fontName)

                        fontSize:SetMinMax(fontData.Min, fontData.Max)
                    end

                    fontSize = vgui.Create("DNumSlider", panel)
                    fontSize:SetHeight(30)
                    fontSize:DockMargin(10, 5, 0, 2)
                    fontSize:Dock(TOP)
                    fontSize:SetDecimals(0)
                    fontSize:SetText(egmt("signs.font_size"))
                    function fontSize:OnValueChanged(value)
                        cookie.Set("signs_fontSize" .. i, math.Round(value, 0))
                    end

                    -- Set Limits for current font.
                    fontSize:SetMinMax(selectedFontData.Min, selectedFontData.Max)
                    fontSize:SetValue(cookie.GetNumber("signs_fontSize" .. i) or 20)

                    local colorMixer = vgui.Create("DColorMixer", panel)
                    colorMixer:DockMargin(5, 5, 5, 5)
                    colorMixer:Dock(FILL)
                    colorMixer:SetColor(
                        Color(
                            cookie.GetNumber("signs_r" .. i) or 255,
                            cookie.GetNumber("signs_g" .. i) or 255,
                            cookie.GetNumber("signs_b" .. i) or 255,
                            cookie.GetNumber("signs_a" .. i) or 255
                        )
                    )
                    function colorMixer:ValueChanged(color)
                        cookie.Set("signs_r" .. i, color.r)
                        cookie.Set("signs_g" .. i, color.g)
                        cookie.Set("signs_b" .. i, color.b)
                        cookie.Set("signs_a" .. i, color.a)
                    end

                    panel:SetHeight(400)
                elseif id == 2 then -- Image Mode
                    local preview
                    local imageEntry = vgui.Create("DTextEntry", panel)
                    imageEntry:SetHeight(30)
                    imageEntry:DockMargin(5, 5, 5, 2)
                    imageEntry:Dock(TOP)
                    imageEntry:SetText(cookie.GetString("signs_image" .. i) or "")
                    imageEntry:SetFont("EGMText6")
                    imageEntry:SetUpdateOnType(true)
                    function imageEntry:OnValueChange(value)
                        cookie.Set("signs_image" .. i, value)

                        preview:Reload()
                    end

                    local imageScale = vgui.Create("DNumSlider", panel)
                    imageScale:SetHeight(30)
                    imageScale:DockMargin(10, 5, 0, 2)
                    imageScale:Dock(TOP)
                    imageScale:SetDecimals(2)
                    imageScale:SetText(egmt("signs.image_size"))
                    imageScale:SetMinMax(0.1, 2)
                    imageScale:SetValue(cookie.GetNumber("signs_imageScale" .. i) or 1)
                    function imageScale:OnValueChanged(value)
                        cookie.Set("signs_imageScale" .. i, math.Round(value, 2))
                    end

                    preview = vgui.Create("DImage", panel)
                    preview:DockMargin(5, 5, 5, 5)
                    preview:Dock(FILL)
                    function preview:Reload()
                        local url = cookie.GetString("signs_image" .. i) or ""
                        Signs:QueryImage(url, function(material)
                            if not IsValid(self) then return end

                            self:SetMaterial(material)
                        end)
                    end

                    preview:Reload()

                    panel:SetHeight(300)
                elseif id == 3 then -- Spacer Mode
                    local spacerHeight = vgui.Create("DNumSlider", panel)
                    spacerHeight:SetHeight(30)
                    spacerHeight:DockMargin(10, 5, 0, 2)
                    spacerHeight:Dock(TOP)
                    spacerHeight:SetDecimals(0)
                    spacerHeight:SetText(egmt("signs.spacer_height"))
                    spacerHeight:SetMinMax(0, 200)
                    spacerHeight:SetValue(cookie.GetNumber("signs_spacerHeight" .. i) or 0)
                    function spacerHeight:OnValueChanged(value)
                        cookie.Set("signs_spacerHeight" .. i, math.Round(value, 0))
                    end

                    panel:SetHeight(80)
                end
            end
            panel:Reload()

            panel:InvalidateLayout(true)
        end

        local signDataPadding = vgui.Create("DPanel", self)
        signDataPadding:SetHeight(5)
        signDataPadding:DockMargin(5, 0, 5, 2)
        signDataPadding:Dock(TOP)
        function signDataPadding:Paint(w, h)
        end
    end

    signDataPanel:Reload()
end
--gamemodes/starwarsrp/gamemode/modules/garage/sh_garage.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--          Shared | Garage          --
---------------------------------------

---------------------------------------
--         Special Thanks to         --
--      Fabian 'Mekphen' Zimber      --
---------------------------------------

Character:AddProperty("garage", "table", {}, function(character, value)
    if not istable(value) then
        return false, egmt("shared.invalid_type")
    end

    return true
end,
function(character, ply)
    -- Only network the garage to the owner of the character.
    return character:BelongsTo(ply)
end)

-- Check if a vehicle can be stored by the given player in his garage.
function Garage:CanStoreVehicle(ply, vehicle)
    if not IsValid(vehicle) then
        return false, "Invalid Vehicle"
    end

    local error = hook.Run("Garage.CanStoreVehicle", ply, vehicle)
    if isstring(error) then
        return false, error
    end

    return true
end
--gamemodes/starwarsrp/gamemode/modules/streamer/sh_config.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--          Streamer Module          --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--     Streamer Module | Config      --
---------------------------------------

-- Set true to enable the chattag and scoreboard prefix
Streamer.Config.EnablePrefix = true

-- Defines streamer tag color (only if above is true)
Streamer.Config.Color = Color(150, 50, 200)

-- Defines the cooldown between the streamer can broadcast its live status
Streamer.Config.Cooldown = 300
--gamemodes/starwarsrp/gamemode/modules/streamer/cl_streamer.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--          Streamer Module          --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--      Streamer Module | Client     --
---------------------------------------

PlayerData:AddPropertyToList("streamer", "Streaming Partner", "Ob der Spieler ein Streaming Partner ist", "boolean")
PlayerData:AddPropertyToList("streamerurl", "Streaming Link", "Streaming Link des Spielers", "string")
--gamemodes/egmrp/gamemode/modules/special_character/sh_special_character.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--     Shared | Special Character    --
---------------------------------------

-- Set sharedside property variables.
SpecialCharacter.Name = "SpecialCharacter"

SpecialCharacter:AddData("factionId", "number", "faction_id", "INT NOT NULL",
function(specialChar, value)
	if not isnumber(value) then
		return false, egmt("specialChar.invalid_faction_id")
	end

	local faction = Faction:GetCached(value)

	if not (faction and faction:IsValid()) then
		return false, egmt("specialChar.invalid_faction")
	end

	return true
end,
function(specialChar, ply)
	return true
end)

-- Returns the Faction of the special character.
--
-- @return Table faction
function SpecialCharacter.Meta:GetFaction()
	return Faction:GetCached(self:Get("factionId"))
end

-- Alias for SpecialCharacter:GetFaction used in the manager.
--
-- @return Table faction
function SpecialCharacter.Meta:GetParent()
	return self:GetFaction()
end

-- Gets every special character belonging to the given faction id.
--
-- @param Number factionId
-- @return Table specialChars
function SpecialCharacter:GetByFaction(factionId)
	local specialChars = {}

	for id, specialChar in pairs(self:GetCache()) do
		if specialChar:Get("factionId") ~= factionId then
			continue
		end

		table.insert(specialChars, specialChar)
	end

	return specialChars
end

-- Alias function for SpecialCharacter:GetByFaction.
--
-- @return Table ranks
function Faction.Meta:GetSpecialCharacters()
	return SpecialCharacter:GetByFaction(self:GetId())
end

-- Checks, if a special character is available in the faction.
--
-- @param SpecialCharacter specialChar
-- @return Boolean available
function Faction.Meta:HasSpecialCharacter(specialChar)
	local specialCharacters = self:GetSpecialCharacters()

	return table.HasValue(specialCharacters, specialChar)
end

-- Initialize networking.
SpecialCharacter:InitCreationNetworking()
SpecialCharacter:InitEditNetworking()
SpecialCharacter:InitDeletionNetworking()

-- Add special character property: name
SpecialCharacter:AddProperty("name", "string", nil, function(specialChar, value)
	if not isstring(value) or #value < 3 then
		return false, egmt("specialChar.invalid_name")
	end

	return true
end,
function(specialChar, ply)
	return true
end)

-- Used to get the special character's name.
--
-- @return String name
function SpecialCharacter.Meta:GetName()
	return self:GetProperty("name", "") or egmt("shared.specialChar") .. " " .. self:GetId()
end

-- Add special character property: rankWhitelist
SpecialCharacter:AddProperty("rankWhitelist", "table", {}, function(specialChar, value)
	if not istable(value) then
		return false, egmt("shared.invalid_type")
	end

	return true
end,
function(specialChar, ply)
	return true
end)

-- Used to get the special character's rank whitelist.
--
-- @return Table rankWhitelist
function SpecialCharacter.Meta:GetRankWhitelist()
	return self:GetProperty("rankWhitelist", {})
end

-- Get a list of special characters that can be used by a given character.
--
-- @return Table availableSpecialChars
function Character.Meta:GetAvailableSpecialCharacters()
	local faction = self:GetFaction()
	if not faction then return {} end

	local rank = self:GetRank()
	if not rank then return {} end

	local specialChars = faction:GetSpecialCharacters()
	local availableSpecialChars = {}

	for _, specialChar in pairs(specialChars) do
		if table.HasValue(specialChar:GetRankWhitelist(), rank:GetId()) then
			table.insert(availableSpecialChars, specialChar)
		end
	end

	return availableSpecialChars
end

-- Add special character property: scaleModifier
SpecialCharacter:AddProperty("scaleModifier", "number", 1, function(specialChar, value)
	if not isnumber(value) then
		return false, egmt("shared.invalid_type")
	end

	return true
end,
function(specialChar, ply)
	return true
end)

-- Used to get the special character's scale modifier.
--
-- @return Number scaleModifier
function SpecialCharacter.Meta:GetScaleModifier()
	return self:GetProperty("scaleModifier", 1)
end

-- Limit access to the edit functions.
hook.Add("SpecialCharacter.CanPlayerEditProperties", "SpecialCharacter.EditPropertiesPermissions", function(ply, specialChar, properties)
	return ply:IsAtLeast(SpecialCharacter.MinAccessGroup)
end)

hook.Add("SpecialCharacter.CanPlayerEditData.factionId", "SpecialCharacter.EditFactionIdPermissions", function(ply, specialChar, factionId)
	return ply:IsAtLeast(SpecialCharacter.MinAccessGroup)
end)

hook.Add("SpecialCharacter.CanPlayerCreate", "SpecialCharacter.CreatePermissions", function(ply, data, properties)
	return ply:IsAtLeast(SpecialCharacter.MinAccessGroup)
end)

hook.Add("SpecialCharacter.CanPlayerDelete", "SpecialCharacter.DeletePermissions", function(ply, specialChar)
	return ply:IsAtLeast(SpecialCharacter.MinAccessGroup)
end)

-- Register rank permission: special_char
RANK_PERMISSION_SPECIAL_CHAR = "special_char"
Rank:RegisterPermission(RANK_PERMISSION_SPECIAL_CHAR, egmt("special_char.permission"))



---------------------------------------
--       Character Integration       --
---------------------------------------

-- Add character property: specialCharId
Character:AddProperty("specialCharId", "number", -1, function(char, value)
	if not isnumber(value) then
		return false, egmt("specialChar.invalid_specialChar_id")
	end

	-- No special character selected.
	if value == -1 then
		return true
	end

	local faction = char:GetFaction()
	if not faction then
		return false, egmt("specialChar.invalid_faction")
	end

	local specialChar = SpecialCharacter:GetCached(value)
	if not specialChar then
		return false, egmt("specialChar.not_valid")
	end

	if not faction:HasSpecialCharacter(specialChar) then
		return false, egmt("specialChar.not_available")
	end

	local rank = char:GetRank()
	if not rank then
		return false, egmt("specialChar.no_rank")
	end

	if not table.HasValue(specialChar:GetRankWhitelist(), rank:GetId()) then
		return false, egmt("specialChar.not_whitelisted")
	end

	return true
end,
function(char, ply)
	return true
end)

-- Used to get the character's special character.
--
-- @return? SpecialCharacter specialChar
function Character.Meta:GetSpecialCharacter()
	local specialCharId = self:GetProperty("specialCharId", -1)

	return SpecialCharacter:GetCached(specialCharId)
end

-- Apply special character name.
hook.Add("Character.OverrideName", "SpecialCharacter.ApplyName", function(char, name)
	local specialChar = char:GetSpecialCharacter()
	if not specialChar then return end

	return specialChar:GetName()
end)

-- Apply special character scale modifier.
hook.Add("Character.GetScale", "SpecialCharacter.ApplyScale", function(char, scale)
	local specialChar = char:GetSpecialCharacter()
	if not specialChar then return end

	local scaleModifier = specialChar:GetScaleModifier()

	scale[1] = scale[1] * scaleModifier
end)

-- Permissions for special character selection.
hook.Add("Character.CanPlayerEditProperty.specialCharId", "SpecialCharacter.Permission", function(ply, char, value)
	local currentCharacter = ply:GetCurrentCharacter()
	if not currentCharacter then return false end

	local playerFaction = currentCharacter:GetFaction()
	if not playerFaction then return false end

	local faction = char:GetFaction()
	if not faction then return false end

	-- Check, if the special character is available in the faction.
	if isnumber(value) and value ~= -1 then
		local specialChar = SpecialCharacter:GetCached(value)
		if not specialChar then
			return false
		end

		if not faction:HasSpecialCharacter(specialChar) then return false end
	end

	-- Override, if the player is allowed to assign special characters, because of his staff rank.
	if ply:IsAtLeast(SpecialCharacter.MinAssignGroup) then
		return true
	end

	-- Check, if the player is in the same faction.
	if playerFaction:GetId() ~= faction:GetId() then return false end

	local playerRank = currentCharacter:GetRank()
	if not playerRank then return false end

	-- Check, if the is allowed to assign special characters.
	if not playerRank:HasPermission(RANK_PERMISSION_SPECIAL_CHAR) then
		return false
	end

	-- Allow changing your own special character.
	if currentCharacter == char then
		return true
	end

	local rank = char:GetRank()
	if not rank then return false end

	-- Check, if the player has a higher rank.
	if playerRank:GetAuthorityLevel() <= rank:GetAuthorityLevel() then
		return false
	end

	return true
end)



---------------------------------------
--       Equipment Integration       --
---------------------------------------

-- Add Equipment property: sCharWhitelist
Equipment:AddProperty("sCharWhitelist", "table", {}, function(equipment, value)
	if not istable(value) then
		return false, egmt("shared.invalid_type")
	end

	-- Allow empty whitelist.
	if table.Count(value) == 0 then
		return true
	end

	-- Prevent, inherited equipment from having a special character whitelist.
	if equipment:GetProperty("inheritEquipment", false) then
		return false, egmt("specialCharacter.inheritEquipment")
	end

	return true
end,
function(equipment, ply)
	return true
end)

-- Used to get the equipment's special character whitelist.
--
-- @return Table sCharWhitelist
function Equipment.Meta:GetSpecialCharacterWhitelist()
	return self:GetProperty("sCharWhitelist", {})
end

-- Override the equipment selection.
hook.Add("Character.AllowEquipment", "SpecialCharacter.AllowEquipment", function(equip, char, rank, faction)
	if not char then return end

	local specialCharWhitelist = equip:GetSpecialCharacterWhitelist()
	if table.Count(specialCharWhitelist) == 0 then return end

	local specialChar = char:GetSpecialCharacter()
	if not specialChar then return false end

	return table.HasValue(specialCharWhitelist, specialChar:GetId())
end)

-- Override the equipment selection display.
hook.Add("Equipment.OverrideAffected", "SpecialCharacter.OverrideAffected", function(equip)
	local specialCharWhitelist = equip:GetSpecialCharacterWhitelist()
	if table.Count(specialCharWhitelist) == 0 then return end

	local specialCharNames = ""
	for _, specialCharId in pairs(specialCharWhitelist) do
		local specialChar = SpecialCharacter:GetCached(specialCharId)
		if not specialChar then continue end

		if #specialCharNames > 0 then
			specialCharNames = specialCharNames .. ", "
		end

		specialCharNames = specialCharNames .. specialChar:GetName()
	end

	return specialCharNames
end)



---------------------------------------
--        Species Integration        --
---------------------------------------

if Config.Modules["species"] then
	-- Add special character property: speciesId
	SpecialCharacter:AddProperty("speciesId", "number", -1, function(specialChar, value)
		if not isnumber(value) then
			return false, egmt("specialChar.invalid_species_id")
		end

		-- No species override selected.
		if value == -1 then
			return true
		end

		local species = Species:GetCached(value)
		if not species then
			return false, egmt("specialChar.invalid_species")
		end

		return true
	end,
	function(specialChar, ply)
		return true
	end)

	-- Used to get the special character's species override.
	--
	-- @return? Species species
	function SpecialCharacter.Meta:GetSpeciesOverride()
		local speciesId = self:GetProperty("speciesId", -1)

		return Species:GetCached(speciesId)
	end

	-- Apply special character species override.
	hook.Add("Species.GetCharacterSpecies", "SpecialCharacter.ApplySpeciesOverride", function(char)
		local specialChar = char:GetSpecialCharacter()
		if not specialChar then return end

		local species = specialChar:GetSpeciesOverride()
		if not species then return end

		return species
	end)

	-- Add special character property: headModel
	SpecialCharacter:AddProperty("headModel", "string", "", function(specialChar, value)
		if not isstring(value) then
			return false, egmt("specialChar.invalid_head_model")
		end

		return true
	end,
	function(specialChar, ply)
		return true
	end)

	-- Used to get the special character's head model override.
	--
	-- @return String headModel
	function SpecialCharacter.Meta:GetHeadModelOverride()
		return self:GetProperty("headModel", "")
	end

	-- Apply special character head model override.
	hook.Add("Species.OverrideHeadModel", "SpecialCharacter.ApplyHeadModelOverride", function(char, species, model, skinId)
		local specialChar = char:GetSpecialCharacter()
		if not specialChar then return end

		local headModel = specialChar:GetHeadModelOverride()
		if headModel == "" then return end

		return headModel
	end)
end
--gamemodes/egmrp/gamemode/modules/special_character/cl_special_character.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--     Client | Special Character    --
---------------------------------------

-- Clear property list to avoid duplicate entries.
SpecialCharacter.PropertyList = {}

-- Add special character properties to list. These are editable in special character creation and edit.
SpecialCharacter:AddPropertyToList("name", egmt("specialCharacter.name"), egmt("specialCharacter.name_description"), "string", nil, nil, 1, nil)

SpecialCharacter:AddPropertyToList("rankWhitelist", egmt("specialCharacter.rankWhitelist"), egmt("specialCharacter.rankWhitelist_description"), "list", function(faction)
	local ranks = {}

	for _, rank in SortedPairs(faction:GetSortedRanks()) do
		table.insert(ranks, {
			text = rank:GetName(),
			data = rank:GetId(),
		})
	end

	return ranks
end, nil, 2, nil)

SpecialCharacter:AddPropertyToList("scaleModifier", egmt("specialCharacter.scaleModifier"), egmt("specialCharacter.scaleModifier_description"), "slider", function()
	return {min = 0.8, max = 1.2, dec = 2} -- Tight limits, because ragdolls cannot be scaled.
end, nil, 5, egmt("rank.stats"))

-- Register special character package type.
Loading:RegisterPackageType("specialCharacter", egmt("specialCharacter.package"), function(packageData)
	for k, sData in pairs(packageData) do
		SpecialCharacter:Load(sData.data, sData.properties):Cache()
	end
end)



---------------------------------------
--       Character Integration       --
---------------------------------------

-- Add character properties to list. These are editable in special character creation and edit.
Character:AddPropertyToList("specialCharId", egmt("specialCharacter.specialCharId"), egmt("specialCharacter.specialCharId_description"), "dropdown", function(rank, faction, character)
	local specialChars = {}

	for _, specialChar in SortedPairs(character:GetAvailableSpecialCharacters()) do
		table.insert(specialChars, {
			text = specialChar:GetName(),
			data = specialChar:GetId(),
		})
	end

	table.insert(specialChars, {
		text = egmt("specialCharacter.none"),
		data = -1,
	})

	return specialChars
end, nil, 10, nil)



---------------------------------------
--       Equipment Integration       --
---------------------------------------

-- Add equipment properties to list. These are editable in special character creation and edit.
Equipment:AddPropertyToList("sCharWhitelist", egmt("specialCharacter.sCharWhitelist"), egmt("specialCharacter.sCharWhitelist_description"), "list", function(faction)
	local specialChars = {}

	for _, specialChar in SortedPairs(faction:GetSpecialCharacters()) do
		table.insert(specialChars, {
			text = specialChar:GetName(),
			data = specialChar:GetId(),
		})
	end

	return specialChars
end, nil, 5, egmt("equipment.conditions"))

Equipment.SpecialCharacterBlacklist = {
	"rankWhitelist",
	"requiredCourses",
	"inheritEquipment",
	"speciesWhitelist"
}

-- Filter Equipment Properties, if a one or more special characters are whitelisted.
hook.Add("Equipment.GetPropertyList", "SpecialCharacter.FilterEquipmentProperties", function(propertyList, faction, equipment)
	local sCharWhitelist = equipment:GetSpecialCharacterWhitelist()
	if #sCharWhitelist == 0 then
		return
	end

	for _, categoryData in pairs(propertyList) do
		local toBeDeleted = {}
		for _, property in pairs(categoryData) do
			local key = property.key

			if table.HasValue(Equipment.SpecialCharacterBlacklist, key) then
				table.insert(toBeDeleted, property)
			end
		end

		for _, property in pairs(toBeDeleted) do
			table.RemoveByValue(categoryData, property)
		end
	end

	local toBeDeleted = {}
	for _, categoryData in pairs(propertyList) do
		if #categoryData == 0 then
			table.insert(toBeDeleted, categoryData)
		end
	end

	for _, categoryData in pairs(toBeDeleted) do
		table.RemoveByValue(propertyList, categoryData)
	end
end)



---------------------------------------
--        Species Integration        --
---------------------------------------

if Config.Modules["species"] then
	SpecialCharacter:AddPropertyToList("speciesId", egmt("specialCharacter.speciesId"), egmt("specialCharacter.speciesId_description"), "dropdown", function(faction, specialChar)
		local values = {}

		for k, species in pairs(Species:GetCache()) do
			table.insert(values, {
				text = species:GetName(),
				data = species:GetId(),
			})
		end

		table.insert(values, {
			text = egmt("specialCharacter.speciesId_none"),
			data = -1,
		})

		return values
	end, nil, 1, egmt("species.category"))

	SpecialCharacter:AddPropertyToList("headModel", egmt("specialCharacter.headModel"), egmt("specialCharacter.headModel_description"), "dropdown", function(faction, specialChar)
		local values = {}

		table.insert(values, {
			text = egmt("specialCharacter.headModel_none"),
			data = "",
		})

		local species = specialChar:GetSpeciesOverride()
		if not species then return values end

		for name, headModel in pairs(Species.HeadModels) do
			table.insert(values, {
				text = name,
				data = headModel,
			})
		end


		return values
	end, nil, 2, egmt("species.category"))
end

--gamemodes/egmrp/gamemode/modules/compass/cl_compass.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--          Compass | Client         --
---------------------------------------

local compassEnabled = not table.HasValue(Compass.NoCompassMaps, game.GetMap())

-- Renders the Compass.
hook.Add("HUDPaint", "Compass.Render", function()
    local ply = LocalPlayer()

    if IsValid(ply) and ply:Alive() and ply:GetCurrentCharacter() then
        local direction = (ply:EyeAngles().y + 360) % 360
        local w, h = ScrW(), ScrH()

        local mW = w * 0.5
        local mWD = w * 0.0125
        local mWDD = mWD * 0.2

        local mH = h * 0.0075

        draw.RoundedBox(10, mW - 10 * mWD, -10, 20 * mWD, 5.5 * mH + 10, UI.BackgroundColor)

        draw.SimpleText(math.Round(360 - direction, 0) % 360 .. "°", "EGMText6", mW, mH, UI.TextColor, TEXT_ALIGN_CENTER)

        local offset = direction % 5

        for i = -10, 9, 1 do
            local x = mW + i * mWD + offset * mWDD
            local p = (math.abs(mW - x) / (mWD * 10))
            local o = 255 - p * 255

            local d = direction - offset - i * 5
            local c = ColorAlpha(UI.ForegroundColor, o)

            if d % 10 == 0 then
                render.DrawLine(Vector(x, 0), Vector(x, mH + p * mH), c)
            else
                render.DrawLine(Vector(x, 0), Vector(x, mH * 0.5), c)
            end

            if d % 45 == 0 then
                local text = (360 - d) % 360

                if compassEnabled then
                    if text == 0 then
                        text = egmt("compass.north")
                    elseif text == 45 then
                        text = egmt("compass.north_east")
                    elseif text == 90 then
                        text = egmt("compass.east")
                    elseif text == 135 then
                        text = egmt("compass.south_east")
                    elseif text == 180 then
                        text = egmt("compass.south")
                    elseif text == 225 then
                        text = egmt("compass.south_west")
                    elseif text == 270 then
                        text = egmt("compass.west")
                    elseif text == 315 then
                        text = egmt("compass.north_west")
                    else
                        text = egmt("compass.unknown")
                    end
                else
                    text = text .. "°"
                end

                draw.SimpleText(text, "EGMText6", x, mH * 3, c, TEXT_ALIGN_CENTER)
            end
        end
    end
end)
--gamemodes/starwarsrp/gamemode/modules/garage_shop/sh_index.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Index | Garage Shop        --
---------------------------------------

if not RequireModules({"garage", "inventory_shop"}) then
	return false
end

GarageShop = GarageShop or {}

if SERVER then
	AddCSLuaFile("sh_garage_shop.lua")
	AddCSLuaFile("cl_garage_shop.lua")

	AddCSLuaFile("cl_interact.lua")

	include("sv_config.lua")
	include("sh_garage_shop.lua")
	include("sv_garage_shop.lua")

	include("sv_chats.lua")
end

if CLIENT then
	include("sh_garage_shop.lua")
	include("cl_garage_shop.lua")

	include("cl_interact.lua")
end
--gamemodes/egmrp/gamemode/modules/inventory_shop/entities/egmrp_shop/cl_init.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Client | Shop Entity       --
---------------------------------------

AddCSLuaFile("shared.lua")
include("shared.lua")

-- Drawing the model.
function ENT:Draw()
	self:DrawModel()
end
--gamemodes/egmrp/gamemode/modules/inventory_shop/shop_classes/item/cl_init.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--         Client | Item Shop        --
---------------------------------------

local SHOP_CLASS = SHOP_CLASS

-- Display name for the shop used in UI elements.
SHOP_CLASS.Name = "Item Shop"

-- List of properties that should be shown in the manager, if this shop is used.
SHOP_CLASS.PropertyList = {"itemType", "itemVariant"}

-- Create the shop panel for the shop.
--
-- @param Panel parent
-- @param ShopEntry shopEntry
function SHOP_CLASS:CreateShopPanel(parent, shopEntry)
	SHOP_CLASS.Base.CreateShopPanel(self, parent, shopEntry)

	local itemType = shopEntry:GetItemType()
	if not itemType then return end

	local itemClass = itemType:GetItemClass()
	if not itemClass then return end

	local variant = shopEntry:GetItemVariant()
	local itemData = itemClass:GetVariantData(itemType, variant)
	if not istable(itemData) then return end

	itemClass:CreateItemPanel(parent, itemData)
end
--gamemodes/starwarsrp/gamemode/modules/shiputil/sh_config.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--    on official 'Einfach Gaming'   --
--     servers owned by 'P4sca1'     --
--                                   --
-- Copyright © 2020 Pascal Sthamer,  --
--      Konstantin Zisiadis und      --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--          Gamemode config          --
---------------------------------------

-- Extra experience given, when flying with a swrp ship
ShipUtil.FlightXP = 15

-- In these vehicles the player will get damage
ShipUtil.DamagePlayerInVehicles = {
	["lunaflightschool_45_z_speeder"] = true,
	["lunaflightschool_armis_speeder"] = true,
	["lunaflightschool_aurum_speeder"] = true,
	["lunaflightschool_casus_speeder"] = true,
	["lunaflightschool_celeritas_speeder"] = true,
	["lunaflightschool_czerka_speeder"] = true,
	["lunaflightschool_extum_speeder"] = true,
	["lunaflightschool_hammerhead_speeder"] = true,
	["lunaflightschool_landspeeder"] = true,
	["lunaflightschool_sanctum_speeder"] = true,
	["lunasflightschool_niksacokica_scavenger_speeder"] = true,
	["lunasflightschool_niksacokica_skiff"] = true,
	["lfs_starhawk_swoopbike"] = true,
	["lfs_t85_speeder"] = true,
	["lunaflightschool_u_29_cage_speeder"] = true,
	["lunasflightschool_niksacokica_x-34"] = true,
	["lunasflightschool_niksacokica_x-34_armed"] = true,
	["lfs_airspeeder"] = true,
	["lunasflightschool_niksacokica_barc"] = true,
	["lunasflightschool_niksacokica_barc_stretcher"] = true,
	["lunasflightschool_niksacokica_isp_speeder"] = true,
	["lunasflightschool_antiairturret"] = true,
	["lunasflightschool_antiinfantryturret"] = true,
	["lunasflightschool_antivehicleturret"] = true
}
--gamemodes/egmrp/gamemode/modules/cloneid/cl_keybinds.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--    Client | Character Keybinds    --
---------------------------------------

-- Add a keybind for the id command.
KeyBind:Register(egmt("character.keybinds_id"), egmt("character.keybinds_cat_rp"), function()
    RunConsoleCommand("say", "/id")
end)
--gamemodes/starwarsrp/gamemode/modules/nextbotspawner/sh_config.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--				(CW:RP)		 	 	 --
--                                   --
--           NextBot Spawner         --
--                                   --
--            Created by             --
--				Oninoni				 --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--     NextBot Spawner | SH Config   --
---------------------------------------

NextbotSpawner.Presets = {
	{
		Name = "B1 Droide (Granaten)",
		Model = "models/player/b1battledroids/b1_base.mdl",
		Health = 200,
		Weapon = "weapon_npc_e5",
		Precision = 0.8,
		Sounds = {
			["attack"] = {
				"cwrp/nextbot/b1/attack/ausloeschen.wav",
				"cwrp/nextbot/b1/attack/scanne-das-ziel.wav",
				"cwrp/nextbot/b1/attack/scanne-feindeinheit.wav",
				"cwrp/nextbot/b1/attack/siegt.wav",
				"cwrp/nextbot/b1/attack/ziel-erfasst.wav",
				"cwrp/nextbot/b1/attack/roger-roger.wav",
			},

			["kill"] = {
				"cwrp/nextbot/b1/kill/knapp.wav",
				"cwrp/nextbot/b1/kill/nimm-das.wav",
				"cwrp/nextbot/b1/kill/yeah.wav",
			},

			["killed"] = {
				"cwrp/nextbot/b1/killed/cry1.wav",
				"cwrp/nextbot/b1/killed/cry2.wav",
				"cwrp/nextbot/b1/killed/cry3.wav",
				"cwrp/nextbot/b1/killed/cry4.wav",
				"cwrp/nextbot/b1/killed/cry5.wav",
			}
		},
		ThrowGrenades = true,
		Grenades = {
			"rw_sw_ent_nade_thermal",
			"rw_sw_ent_nade_smoke",
		}
	},

	{
		Name = "B1 Droide",
		Model = "models/player/b1battledroids/b1_base.mdl",
		Health = 200,
		Weapon = "weapon_npc_e5",
		Precision = 0.8,
		Sounds = {
			["attack"] = {
				"cwrp/nextbot/b1/attack/ausloeschen.wav",
				"cwrp/nextbot/b1/attack/scanne-das-ziel.wav",
				"cwrp/nextbot/b1/attack/scanne-feindeinheit.wav",
				"cwrp/nextbot/b1/attack/siegt.wav",
				"cwrp/nextbot/b1/attack/ziel-erfasst.wav",
				"cwrp/nextbot/b1/attack/roger-roger.wav",
			},

			["kill"] = {
				"cwrp/nextbot/b1/kill/knapp.wav",
				"cwrp/nextbot/b1/kill/nimm-das.wav",
				"cwrp/nextbot/b1/kill/yeah.wav",
			},

			["killed"] = {
				"cwrp/nextbot/b1/killed/cry1.wav",
				"cwrp/nextbot/b1/killed/cry2.wav",
				"cwrp/nextbot/b1/killed/cry3.wav",
				"cwrp/nextbot/b1/killed/cry4.wav",
				"cwrp/nextbot/b1/killed/cry5.wav",
			}
		}
	},

	{
		Name = "B1 Droide Heavy",
		Model = "models/player/b1battledroids/b1_geo.mdl",
		Health = 200,
		Weapon = "weapon_npc_z3",
		Precision = 0.7,
		Sounds = {
			["attack"] = {
				"cwrp/nextbot/b1/attack/ausloeschen.wav",
				"cwrp/nextbot/b1/attack/scanne-das-ziel.wav",
				"cwrp/nextbot/b1/attack/scanne-feindeinheit.wav",
				"cwrp/nextbot/b1/attack/siegt.wav",
				"cwrp/nextbot/b1/attack/ziel-erfasst.wav",
				"cwrp/nextbot/b1/attack/roger-roger.wav",
			},

			["kill"] = {
				"cwrp/nextbot/b1/kill/knapp.wav",
				"cwrp/nextbot/b1/kill/nimm-das.wav",
				"cwrp/nextbot/b1/kill/yeah.wav",
			},

			["killed"] = {
				"cwrp/nextbot/b1/killed/cry1.wav",
				"cwrp/nextbot/b1/killed/cry2.wav",
				"cwrp/nextbot/b1/killed/cry3.wav",
				"cwrp/nextbot/b1/killed/cry4.wav",
				"cwrp/nextbot/b1/killed/cry5.wav",
			}
		}
	},

	{
		Name = "B1 Droide Security",
		Model = "models/player/b1battledroids/b1_base_security.mdl",
		Health = 200,
		Weapon = "weapon_npc_e5",
		Precision = 0.7,
		Sounds = {
			["attack"] = {
				"cwrp/nextbot/b1/attack/ausloeschen.wav",
				"cwrp/nextbot/b1/attack/scanne-das-ziel.wav",
				"cwrp/nextbot/b1/attack/scanne-feindeinheit.wav",
				"cwrp/nextbot/b1/attack/siegt.wav",
				"cwrp/nextbot/b1/attack/ziel-erfasst.wav",
				"cwrp/nextbot/b1/attack/roger-roger.wav",
			},

			["kill"] = {
				"cwrp/nextbot/b1/kill/knapp.wav",
				"cwrp/nextbot/b1/kill/nimm-das.wav",
				"cwrp/nextbot/b1/kill/yeah.wav",
			},

			["killed"] = {
				"cwrp/nextbot/b1/killed/cry1.wav",
				"cwrp/nextbot/b1/killed/cry2.wav",
				"cwrp/nextbot/b1/killed/cry3.wav",
				"cwrp/nextbot/b1/killed/cry4.wav",
				"cwrp/nextbot/b1/killed/cry5.wav",
			}
		},
	},

	{
		Name = "B1 Kommandant",
		Model = "models/player/b1battledroids/b1_base_com.mdl",
		Health = 250,
		Weapon = "weapon_npc_e5",
		Precision = 0.5,
		Sounds = {
			["attack"] = {
				"cwrp/nextbot/b1/attack/ausloeschen.wav",
				"cwrp/nextbot/b1/attack/scanne-das-ziel.wav",
				"cwrp/nextbot/b1/attack/scanne-feindeinheit.wav",
				"cwrp/nextbot/b1/attack/siegt.wav",
				"cwrp/nextbot/b1/attack/ziel-erfasst.wav",
				"cwrp/nextbot/b1/attack/roger-roger.wav",
			},

			["kill"] = {
				"cwrp/nextbot/b1/kill/knapp.wav",
				"cwrp/nextbot/b1/kill/nimm-das.wav",
				"cwrp/nextbot/b1/kill/yeah.wav",
			},

			["killed"] = {
				"cwrp/nextbot/b1/killed/cry1.wav",
				"cwrp/nextbot/b1/killed/cry2.wav",
				"cwrp/nextbot/b1/killed/cry3.wav",
				"cwrp/nextbot/b1/killed/cry4.wav",
				"cwrp/nextbot/b1/killed/cry5.wav",
			}
		},
	},

	{
		Name = "B2 Superkampfdroide",
		Model = "models/player/hydro/b2_battledroid/b2_battledroid.mdl",
		Health = 400,
		Weapon = "weapon_npc_b2",
		Precision = 0.5,
		Sounds = {
			["kill"] = {
				"cwrp/nextbot/b2/kill/problem-geloest.wav",
				"cwrp/nextbot/b2/kill/nimm-das.wav",
			},

			["killed"] = {
				"cwrp/nextbot/b2/killed/death1.wav",
				"cwrp/nextbot/b2/killed/death2.wav",
			}
		},
		Animations = {
			["AnimIdleAim"] = ACT_HL2MP_IDLE_PISTOL,
			["AnimWalkAim"] = ACT_HL2MP_RUN_PISTOL
		}
	},

	{
		Name = "B2 Superkampfdroide (Rocket)",
		Model = "models/player/hydro/b2_battledroid/b2_battledroid.mdl",
		Health = 400,
		Weapon = "weapon_npc_b2",
		Entity = "npc_swrp_b2rocket",
		Precision = 0.5,
		Sounds = {
			["kill"] = {
				"cwrp/nextbot/b2/kill/problem-geloest.wav",
				"cwrp/nextbot/b2/kill/nimm-das.wav",
			},

			["killed"] = {
				"cwrp/nextbot/b2/killed/death1.wav",
				"cwrp/nextbot/b2/killed/death2.wav",
			}
		},
		Animations = {
			["AnimIdleAim"] = ACT_HL2MP_IDLE_PISTOL,
			["AnimWalkAim"] = ACT_HL2MP_RUN_PISTOL
		}
	},

	{
		Name = "Taktik Droide",
		Model = {
			"models/tactical_black/pm_droid_tactical_black.mdl",
			"models/tactical_blue/pm_droid_tactical_blue.mdl",
			"models/tactical_gold/pm_droid_tactical_gold.mdl",
			"models/tactical_purple/pm_droid_tactical_purple.mdl",
			"models/tactical_red/pm_droid_tactical_red.mdl"
		},
		Health = 400,
		Weapon = "weapon_npc_e5",
		Precision = 0.5,
	},

	{
		Name = "Super Taktik Droide",
		Model = {
			"models/super_tactical_kalani/pm_droid_tactical_kalani.mdl",
			"models/super_tactical_stuxnet/pm_droid_tactical_stuxnet.mdl",
		},
		Health = 400,
		Weapon = "weapon_npc_e5",
		Precision = 0.5,
	},

	{
		Name = "Kommando Droide",
		Model = "models/sally/tkaro/bx_commando_droid.mdl",
		Health = 400,
		Weapon = "weapon_npc_e5",
		Precision = 0.5,
		Sounds = {
			["attack"] = {
				"cwrp/nextbot/bx/attack/ausradieren.wav",
				"cwrp/nextbot/bx/attack/ich-gehe-voraus.wav",
				"cwrp/nextbot/bx/attack/toetet-die-klone.wav"
			},

			["kill"] = {
				"cwrp/nextbot/bx/kill/problem-geloest.wav",
			},

			["killed"] = {
				"cwrp/nextbot/b2/killed/death1.wav",
				"cwrp/nextbot/b2/killed/death2.wav",
			}
		},
		ThrowGrenades = true,
		Grenades = {
			"rw_sw_ent_nade_thermal",
			"rw_sw_ent_nade_smoke"
		}
	},

	{
		Name = "Crab Droid",
		Model = "models/npc/starwars/crabby/crabdroid.mdl",
		Health = 600,
		Weapon = "weapon_npc_crab",
		Entity = "npc_swrp_crab",
		Precision = 0.2,
	},

	{
		Name = "Dwarf Spider Droid",
		Model = "models/npc/starwars/dwarfspider/dwarfspiderdroid.mdl",
		Health = 800,
		Weapon = "weapon_npc_dwarf",
		Entity = "npc_swrp_dwarf",
		Precision = 0.2,
	},

	{
		Name = "Droideka",
		Model = "models/npc/starwars/droidekas/droideka.mdl",
		Health = 600,
		Weapon = "weapon_npc_droideka",
		Entity = "npc_swrp_droideka",
		Precision = 0.2,
	},

	{
		Name = "Magna Wache",
		Model = {
			"models/tfa/comm/gg/pm_sw_magna_guard_trainer.mdl",
			"models/tfa/comm/gg/pm_sw_magna_guard_combined.mdl"
		},
		Health = 400,
		Weapon = "weapon_npc_e5",
		Precision = 0.4,
	},

	{
		Name = "Umbaran Soldier",
		Model = "models/player/icefusenetworks/ifnumbaran.mdl",
		Health = 200,
		Weapon = "weapon_npc_umbaran",
		Precision = 0.5,
	},

	{
		Name = "Umbaran General",
		Model = "models/player/icefusenetworks/ifnumbarangeneral.mdl",
		Health = 500,
		Weapon = "weapon_npc_umbaran",
		Precision = 0.4,
	},

	{
		Name = "Rebellen",
		Model = {
			"models/hcn/starwars/bf/human/human_male.mdl",
			"models/hcn/starwars/bf/human/human_male_2.mdl",
			"models/hcn/starwars/bf/human/human_male_3.mdl",
			"models/hcn/starwars/bf/human/human_male_4.mdl",
			"models/hcn/starwars/bf/human/human_male_5.mdl",
			"models/hcn/starwars/bf/alien/alien.mdl",
			"models/hcn/starwars/bf/alien/alien_2.mdl",
			"models/hcn/starwars/bf/alien/alien_3.mdl",
			"models/hcn/starwars/bf/alien/alien_4.mdl",
			"models/hcn/starwars/bf/alien/alien_5.mdl",
		},
		Health = 200,
		Weapon = "weapon_npc_e5",
		Precision = 0.8,
		Sounds = {
			["attack"] = {
				"cwrp/nextbot/rebellen/attack/ausschalten.wav",
				"cwrp/nextbot/rebellen/attack/holen-wir-sie-uns.wav",
				"cwrp/nextbot/rebellen/attack/ziel-da.wav",
			},

			["kill"] = {
				"cwrp/nextbot/rebellen/kill/backe.wav",
				"cwrp/nextbot/rebellen/kill/bleib-liegen.wav",
				"cwrp/nextbot/rebellen/kill/das-wars.wav",
				"cwrp/nextbot/rebellen/kill/hab-dich.wav",
				"cwrp/nextbot/rebellen/kill/sieg.wav",
				"cwrp/nextbot/rebellen/kill/wie-fuehlt-sich-das-an.wav",
			},
		}
	},

	{
		Name = "Trando",
		Model = {
			"models/hcn/starwars/bf/bossk/trandoshan.mdl"
		},
		Health = 200,
		Weapon = "weapon_npc_ee3",
		Precision = 0.8,
	},

	{
		Name = "Deathwatch",
		Model = {
			"models/deltaa/deathwatch/dw_female.mdl",
			"models/deltaa/deathwatch/dw_male.mdl",
			"models/deltaa/deathwatch/dw_niteowl.mdl"
		},
		Health = 200,
		Weapon = "weapon_npc_deathwatch",
		Precision = 0.2,
		Sounds = {
			["attack"] = {
				"cwrp/nextbot/rebellen/attack/ausschalten.wav",
				"cwrp/nextbot/rebellen/attack/holen-wir-sie-uns.wav",
				"cwrp/nextbot/rebellen/attack/ziel-da.wav",
			},

			["kill"] = {
				"cwrp/nextbot/rebellen/kill/backe.wav",
				"cwrp/nextbot/rebellen/kill/bleib-liegen.wav",
				"cwrp/nextbot/rebellen/kill/das-wars.wav",
				"cwrp/nextbot/rebellen/kill/hab-dich.wav",
				"cwrp/nextbot/rebellen/kill/sieg.wav",
				"cwrp/nextbot/rebellen/kill/wie-fuehlt-sich-das-an.wav",
			},
		}
	},

	{
		Name = "Geonosian",
		Model = {"models/swrp/swrp/geonosian_01.mdl", "models/swrp/swrp/geonosian_02.mdl",},
		Health = 200,
		Weapon = "weapon_npc_umbaran",
		Precision = 0.8,
	},

	{
		Name = "Tusken",
		Model = {"models/zyan7259/zusken_raider_player/zusken_raider_player.mdl",},
		Health = 200,
		Weapon = "weapon_npc_e5",
		Precision = 0.8,
	},

	{
		Name = "Wookie Warrior",
		Model = {"models/player/strasser/wookie_warrior/wookie_warrior.mdl"},
		Health = 800,
		Weapon = "weapon_npc_bowcaster",
		Precision = 0.5,
		Sounds = {
			["attack"] = {
				"cwrp/nextbot/wookie/wookie1.wav",
				"cwrp/nextbot/wookie/wookie2.wav",
				"cwrp/nextbot/wookie/wookie3.wav",
				"cwrp/nextbot/wookie/wookie4.wav",
				"cwrp/nextbot/wookie/wookie5.wav",
			},

			["kill"] = {
				"cwrp/nextbot/wookie/wookie1.wav",
				"cwrp/nextbot/wookie/wookie2.wav",
				"cwrp/nextbot/wookie/wookie3.wav",
				"cwrp/nextbot/wookie/wookie4.wav",
				"cwrp/nextbot/wookie/wookie5.wav",
			},

			["killed"] = {
				"cwrp/nextbot/wookie/wookie1.wav",
				"cwrp/nextbot/wookie/wookie2.wav",
				"cwrp/nextbot/wookie/wookie3.wav",
				"cwrp/nextbot/wookie/wookie4.wav",
				"cwrp/nextbot/wookie/wookie5.wav",
			}
		},
		ThrowGrenades = true,
		Grenades = {
			"rw_sw_ent_nade_thermal",
			"rw_sw_ent_nade_impact",
			"rw_sw_ent_nade_smoke"
		}
	},
	--[[
	{
		Name = "Clone Trooper (DC15S, Grenades)",
		Model = "models/fisher/clone/trooper/private.mdl",
		Health = 400,
		Weapon = "weapon_npc_dc15s",
		Precision = 0.2,
		Sounds = {
			["attack"] = {
				"cwrp/nextbot/klon/republik.wav",
				"cwrp/nextbot/klon/geboren.wav",
				"cwrp/nextbot/klon/nimm-das.wav"
			},

			["kill"] = {
				"cwrp/nextbot/klon/nimm-das.wav",
				"cwrp/nextbot/klon/klappergestell.wav",
			},
		},
		ThrowGrenades = true,
		Grenades = {
			"rw_sw_ent_nade_thermal"
		}
	},
	{
		Name = "Clone Trooper (DC15A, No Grenades)",
		Model = "models/fisher/clone/trooper/private.mdl",
		Health = 400,
		Weapon = "weapon_npc_dc15a",
		Precision = 0.2,
		Sounds = {
			["attack"] = {
				"cwrp/nextbot/klon/republik.wav",
				"cwrp/nextbot/klon/geboren.wav",
				"cwrp/nextbot/klon/nimm-das.wav"
			},

			["kill"] = {
				"cwrp/nextbot/klon/nimm-das.wav",
				"cwrp/nextbot/klon/klappergestell.wav",
			},
		},
	},]]
	{
		Name = "Super Attentäter Droide",
		Model = "models/odd/nikout/swtor/player/hk51.mdl",
		Health = 600,
		Weapon = "weapon_npc_verpine",
		Precision = 0.2,
		ThrowGrenades = true,
		Grenades = {
			"rw_sw_ent_nade_impact",
		}
	},

	{
		Name = "Attentäter Droide",
		Model = "models/player/ig88/ig88.mdl",
		Health = 400,
		Weapon = "weapon_npc_verpine",
		Precision = 0.2,
		ThrowGrenades = true,
		Grenades = {
			"rw_sw_ent_nade_impact",
		}
	},

	{
		Name = "Bodyguard Droide",
		Model = "models/player/swtor/droids/bodyguard_droid.mdl",
		Health = 200,
		Weapon = "weapon_npc_cr2",
		Precision = 0.7,
	},

	{
		Name = "Combat Droid",
		Model = "models/player/swtor/droids/combat_medicaldroid.mdl",
		Health = 200,
		Weapon = "weapon_npc_cr2",
		Precision = 0.7,
	},

	{
		Name = "Enforcer Droid",
		Model = "models/player/swtor/droids/enforcerdroid.mdl",
		Health = 200,
		Weapon = "weapon_npc_cr2",
		Precision = 0.7,
	},

	{
		Name = "Slicer Droid",
		Model = "models/player/swtor/droids/slicer_droid.mdl",
		Health = 200,
		Weapon = "weapon_npc_cr2",
		Precision = 0.7,
	},

	{
		Name = "Worker Droid",
		Model = "models/player/swtor/droids/worker_droid.mdl",
		Health = 200,
		Weapon = "weapon_npc_cr2",
		Precision = 0.7,
	},

	{
		Name = "Underground Droids",
		Model = {
			"models/player/swtor/droids/bodyguard_droid.mdl",
			"models/player/swtor/droids/combat_medicaldroid.mdl",
			"models/player/swtor/droids/enforcerdroid.mdl",
			"models/player/swtor/droids/slicer_droid.mdl",
			"models/player/swtor/droids/worker_droid.mdl"
		},
		Health = 200,
		Weapon = "weapon_npc_cr2",
		Precision = 0.7,
	},

	{
		Name = "Nachtschwester Zombie",
		Model = "models/player/dathomir/pm_nightsister_undead.mdl",
		Health = 1000,
		Weapon = "weapon_fists",
		Precision = 0,
		Animations = {
			AnimIdle = ACT_HL2MP_IDLE_ZOMBIE,
			AnimWalk = ACT_HL2MP_WALK_ZOMBIE_01,
			AnimIdleAim = ACT_HL2MP_IDLE_ZOMBIE,
			AnimWalkAim = ACT_HL2MP_WALK_ZOMBIE_01,
			AnimReload = ACT_HL2MP_WALK_ZOMBIE_01,
		}
	}
}
--gamemodes/starwarsrp/gamemode/modules/nextbotspawner/entities/npc_swrp_b2rocket/shared.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--				(CW:RP)		 	 	 --
--                                   --
--           NextBot Spawner         --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

if SERVER then
	AddCSLuaFile()
end

ENT.Base   = "npc_swrp_nextbot_base"

ENT.PrintName = "B2 Rocketdroid"
ENT.Author = "Deltaa"
ENT.Information = ""
ENT.Category = "SW:RP (NPCs)"

ENT.Spawnable		= false
ENT.AdminOnly		= false

if SERVER then
	function ENT:FireWeaponAt(weapon, target, targetPos)
		self:SetAiming(true)

		if self.Reloading > CurTime() then
			self:SetReloading(true)
			return false
		end

		if weapon:Clip1() == 0 then
			self.ShouldReturnTrue = false
			weapon:Reload(true)
			self.ShouldReturnTrue = true

			self:SetReloading(true)
			self.Reloading = CurTime() + 3

			return false
		end

		local aimVector = self:GetInternalAimVector(weapon, target, targetPos)
		local aimAngle = Vector(aimVector.x, aimVector.y, 0):Angle()
		self:SetAngles(aimAngle)
		self:AimAt(aimVector:Angle())

		self.ShouldReturnTrue = false

		local realAimAngle = aimVector:Angle()
		realAimAngle:RotateAroundAxis(aimAngle:Right(), (math.random() * 2 - 1) * (self.Precision * 10))
		realAimAngle:RotateAroundAxis(aimAngle:Up(), (math.random() * 2 - 1) * (self.Precision * 10))
		self:SetAngles(realAimAngle)

		if math.random(0, 100) > 99 then
			weapon:SecondaryAttack()
		else
			weapon:PrimaryAttack()
		end

		if self.Sounds and self.Sounds["attack"] and self.SoundCooldown < CurTime() then
			self:EmitSound(table.Random(self.Sounds["attack"] or {}), 75)

			self.SoundCooldown = CurTime() + 10
		end

		self.ShouldReturnTrue = true
		self:SetAngles(aimAngle)

		return true
	end
end
--gamemodes/starwarsrp/gamemode/modules/nextbotspawner/entities/npc_swrp_droideka/shared.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--				(CW:RP)		 	 	 --
--                                   --
--           NextBot Spawner         --
--                                   --
--            Created by             --
--				Oninoni				 --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

ENT.Base   = "npc_swrp_nextbot_base"

ENT.PrintName = "Droideka"
ENT.Author = "Deltaa"
ENT.Information = ""
ENT.Category = "SW:RP (NPCs)"

ENT.Spawnable		= false
ENT.AdminOnly		= false

ENT.IsSWRPNextbot = true

-- Default model the npc uses.
ENT.DefaultModel = "models/npc/starwars/droidekas/droideka.mdl"

-- Default weapon the npc uses.
ENT.DefaultWeapon = "weapon_npc_droideka"

-- How much Health the NPC should have.
ENT.MaxHealth = 600

-- Speed value of the character. Scales running aswell.
ENT.WalkSpeed = 300

-- ACT Enums Used for animation.
ENT.AnimIdle = "idle"
ENT.AnimWalk = "walk"
ENT.AnimIdleAim = "range_attack1"
ENT.AnimWalkAim = "walk"
ENT.AnimReload = "idle"

-- Behaviour Types
BEHAVIOUR_STUPID	= 0 -- Attacks Everything it sees and follows targets blindly.
BEHAVIOUR_DEFENSIVE = 1 -- Defends a point to wich it always returns. (Defined by Spawn Position)
BEHAVIOUR_PATROL	= 2 -- Patrols an area (Between Spawn Position and Spawn Tool Secondary).
BEHAVIOUR_ATTACK	= 3 -- Attacks a marked point. (Defined by Spawn Tool Secondary)

-- Behaviour of the NPC
ENT.Behaviour = BEHAVIOUR_STUPID

-- If the NPC should Avoid Grenades
ENT.ShouldAvoidGrenades = true

-- How precise should it be. (0 = Aimbot)
ENT.Precision = 0.3

-- Time in seconds it takes from seeing a target to shooting at it.
ENT.ReactionTime = 0.5

-- Time in seconds it gives up shooting at somebody.
ENT.Patience = 5

-- Field of View, to find droids.
ENT.FOV = 360

ENT.Sounds = {}
ENT.SoundCooldown = 0

function ENT:SetupDataTables()
	self:NetworkVar("Bool", 10, "ShieldStatus", { KeyName = "ShieldStatus", Edit = { type = "Boolean", order = 1, category = "Settings"}})
end

function ENT:GetWalkSpeed()
	return self.WalkSpeed
end

function ENT:GetRunSpeed()
	return self.WalkSpeed
end

-- Activate/deactivates the shield
--
-- @param? Bool value
function ENT:SwitchShield(value)
	if value then
		if self.NextShield and self.NextShield > CurTime() then return end

		self:SetShieldStatus(true)
		self:StopSound("cwrp/nextbots/droideka/main_loop.mp3")
	else
		self:SetShieldStatus(false)
	end
end
--gamemodes/starwarsrp/gamemode/modules/nextbotspawner/entities/npc_swrp_nextbot_base/cl_init.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--				(CW:RP)		 	 	 --
--                                   --
--           NextBot Spawner         --
--                                   --
--            Created by             --
--				Oninoni				 --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

include("shared.lua")

local colorRed = Color(200, 50, 0, 230)
local colorGrey = Color(15, 15, 15, 230)
local colorWhite = Color(255,255,255)


function ENT:DrawNameTag()
	local p = self:GetPos()

	if LocalPlayer():GetPos():DistToSqr( self:GetPos() ) < 250 * 250 then
		local ang = self:GetAngles()
		ang:RotateAroundAxis( ang:Forward(), 90 )
		ang:RotateAroundAxis( ang:Up(), 90 )
		ang.y = LocalPlayer():EyeAngles().y - 90

		local health = self:Health()
		local maxHealth = self:GetMaxHealth()

		cam.Start3D2D(p + Vector( 0, 0, 60 ), Angle( 0, ang.y, 90 ), .15)
			local width = draw.SimpleText("Zustand", "EGMText8", 0, - 160, colorWhite, TEXT_ALIGN_CENTER)

			draw.RoundedBox(5, - width / 2, - 120, width, 8, colorGrey)

			if health > 0 then
				draw.RoundedBox(5, - width / 2, - 120, width * (health / maxHealth), 8, colorRed)
			end
		cam.End3D2D()
	end
end

function ENT:Draw()
	self:DrawModel()
	self:DrawNameTag()
end
--gamemodes/starwarsrp/gamemode/modules/nextbotspawner/weapons/weapon_npc_dc15a.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--				(CW:RP)		 	 	 --
--                                   --
--           NextBot Spawner         --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

AddCSLuaFile()

SWEP.Base   = "weapon_npcbase"

SWEP.PrintName = "NPC: DC15A"
SWEP.Spawnable = false
SWEP.Author = "Deltaa"

SWEP.WorldModel = "models/sw_battlefront/weapons/dc15a_rifle.mdl"
SWEP.Weight = 3

SWEP.NextShoot = 0.3
SWEP.Sound = "weapons/dc15a_blaster_rifle/dc15a_fire.ogg"
SWEP.Tracer = "rw_sw_laser_blue"
SWEP.ImpactEffect = "rw_sw_impact_blue"
SWEP.ClipSize = 30
SWEP.Damage = 25


--gamemodes/starwarsrp/gamemode/modules/eventspawns/sh_config.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
-- Copyright © 2020 Pascal Sthamer,  --
--      Konstantin Zisiadis und      --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Config | Eventspawns       --
---------------------------------------

-- Minimum Usergroup that is required to change eventspawns.
Eventspawns.MinAccessGroup = "eventleiter"
--gamemodes/starwarsrp/gamemode/modules/eventspawns/sh_eventspawns.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Shared | Eventspawns       --
---------------------------------------

-- Checks whether a player is allowed to edit the eventspawns.
--
-- @param Player ply
-- @return Boolean canEdit
function Eventspawns:CanPlayerEdit(ply)
	if hook.Run("Eventspawns.CanPlayerEdit", ply) then
		return true
	end

	return false
end

-- Allow everything above Eventspawns.MinAccessGroup to edit the eventspawnpoints.
hook.Add("Eventspawns.CanPlayerEdit", "EventSpawns.CanEditPermissions", function(ply)
	if ply:IsAtLeast(Eventspawns.MinAccessGroup) then
		return true
	end
end)
--gamemodes/starwarsrp/gamemode/modules/voicenotify/sh_config.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Voicenotify            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--      Voicenotify | SH Config      --
---------------------------------------

Voicenotify.Colors = {
	["backgroundColor"] =  Color(33, 33, 39),
	["nameColor"] = Color(55, 200, 255),
	["channelName"] = Color(55, 200, 255),
}
--gamemodes/starwarsrp/gamemode/modules/voicenotify/cl_vgui_comlink.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Voicenotify            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--         Voicenotify | CL          --
---------------------------------------

local PANEL = {}

function PANEL:Init()
	self.playerName = vgui.Create( "DLabel", self )
	self.playerName:SetFont( "EGMText9" )
	self.playerName:Dock( TOP )
	self.playerName:DockMargin( 8, 3, 0, 3 )
	self.playerName:SetTextColor(color_white)

	self.comName = vgui.Create( "DLabel", self )
	self.comName:SetFont( "EGMText7" )
	self.comName:Dock( TOP )
	self.comName:DockMargin( 8, 0, 0, 0 )
	self.comName:SetTextColor(color_white)

	self.Avatar = vgui.Create("EGMModelPanel", self)
	self.Avatar:Dock( LEFT )
	self.Avatar:SetSize(50, 50)
	self.Avatar:SetZPos(-1)

	self.Color = Voicenotify.Colors["backgroundColor"]

	self:SetSize( 400, 50 + 8 )
	self:DockPadding( 4, 4, 4, 4 )
	self:DockMargin( 2, 2, 2, 2 )
	self:Dock( TOP )
end

function PANEL:Setup(ply)
	self.comlink = ply:ActiveChannel()

	if Comlink.Channels[self.comlink] then
		self.comlink = Comlink.Channels[self.comlink].name
	end

	self.ply = ply
	self.playerName:SetText(ply:Nick())
	self.comName:SetText(self.comlink)

	if ply:GetCurrentCharacter() then
		self.Avatar:SetCharacter(ply:GetCurrentCharacter())
	end

	self.playerName:SetFont(Voicenotify:GetFont(ply:Nick(), 260))
	self.comName:SetFont(Voicenotify:GetFont(self.comlink, 260))

	self.Color = team.GetColor(ply:Team())

	self:InvalidateLayout()
end

function PANEL:Paint( w, h )
	if not IsValid( self.ply ) then return end

	draw.RoundedBox(0, 0, 0, w, h, Voicenotify.Colors["backgroundColor"])

	surface.SetDrawColor(Voicenotify.Colors["nameColor"])
	self:DrawOutlinedRect()
end

function PANEL:Think()
	if ( IsValid( self.ply ) ) then
		self.playerName:SetText( self.ply:Nick() )
	end

	if ( self.fadeAnim ) then
		self.fadeAnim:Run()
	end
end


function PANEL:FadeOut( anim, delta, data )
	if ( anim.Finished ) then
		if ( IsValid( Voicenotify.ComlinkVoicePanels[ self.ply ] ) ) then
			Voicenotify.ComlinkVoicePanels[self.ply]:Remove()
			Voicenotify.ComlinkVoicePanels[self.ply] = nil
			return
		end

	return end

	self:SetAlpha(255 - ( 255 * delta ))
end

derma.DefineControl("VoiceNotifyComlink", "", PANEL, "DPanel")
--gamemodes/starwarsrp/gamemode/modules/lightsaberutil/cl_forcepowers.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--    on official 'Einfach Gaming'   --
--     servers owned by 'P4sca1'     --
--                                   --
-- Copyright © 2020 Pascal Sthamer,  --
--      Konstantin Zisiadis und      --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--       Client | Force Powers       --
---------------------------------------

-- Render Devastator: Inner Fear
hook.Add("RenderScreenspaceEffects", "wOS.InnerFear.Blinding", function()
	if LocalPlayer():GetNWFloat("wOS.InnerFearTime", 0) < CurTime() then return end

	local ColorModify = {}
	ColorModify["$pp_colour_addr"] = 0
	ColorModify["$pp_colour_addg"] = 0
	ColorModify["$pp_colour_addb"] = 0
	ColorModify["$pp_colour_brightness"] = 0
	ColorModify["$pp_colour_contrast"] = 0.1
	ColorModify["$pp_colour_colour"] = 0.8
	ColorModify["$pp_colour_mulr"] = 0
	ColorModify["$pp_colour_mulg"] = 0
	ColorModify["$pp_colour_mulb"] = 0

	DrawMotionBlur(0.75, 1.0, 0.0)
	DrawColorModify(ColorModify)
end )

-- Initialise Sounds for Inner Fear
hook.Add("InitPostEntity", "wOS.InnerFear.Load", function()
	local InnerFearSound = CreateSound(LocalPlayer(), "player/heartbeat1.wav")
	local InnerFearSound2 = CreateSound(LocalPlayer(), "player/breathe1.wav")

	hook.Add("Think", "wOS.InnerFear.HeartBeat", function()
		if LocalPlayer():GetNWFloat("wOS.InnerFearTime", 0) >= CurTime() then
			InnerFearSound:Play()
			InnerFearSound2:Play()
		elseif InnerFearSound:IsPlaying() then
			InnerFearSound:Stop()
			InnerFearSound2:Stop()
		end
	end)
end)
--gamemodes/egmrp/gamemode/modules/realism/sh_movement.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--         Shared |  Movement        --
---------------------------------------

local Player = FindMetaTable("Player")

-- Helperfunction to check movetype
--
-- @param enum Movetype
-- @return boolean
function Player:HasMoveType(moveType)
    return self:GetMoveType() == moveType
end

-- Disable the ability to sprint backwards.
if CLIENT then
    -- Clientside check, removes footsteps for example and makes IN_SPEED to never
    -- be sent to the server, when IN_BACK is also pressed.
    hook.Add("CreateMove", "Realism.DisableBackwardSprinting", function(cmd)
        if Realism.DisableBackwardSprinting and cmd:KeyDown(IN_BACK) and cmd:KeyDown(IN_SPEED) then
            cmd:RemoveKey(IN_SPEED)
        end
    end)
end

-- You could remove our clientside check by injecting lua, so this is a another security
-- feature to apply the reduced movement speed when sprinting backwards sharedside.
hook.Add("SetupMove", "Realism.DisableBackwardSprinting", function(ply, moveData, cmd)
    if Realism.DisableBackwardSprinting and moveData:KeyDown(IN_BACK) and moveData:KeyDown(IN_SPEED) then
        moveData:SetForwardSpeed(-ply:GetWalkSpeed())
    end
end)

-- Remove footsteps when crouching.
hook.Add("PlayerFootstep", "Realism.FootstepManager", function(ply, pos, foot, sound, volume, filter)
    if Realism.RemoveFootstepsWhenCrouching and ply:Crouching() then
        return true
    end
end)
--gamemodes/egmrp/gamemode/modules/realism/weapons/weapon_egmrp_breathingswep.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--          Breathing SWEP           --
---------------------------------------

SWEP.Author = "Mattzi & Oninoni"
SWEP.Contact = "https://einfach-gaming.de"
SWEP.Purpose = "Eine Waffe für den SW:RP Spielmodus" -- A weapon for the swrp gamemode
SWEP.Instructions = "Klicke um das Atemgerät zu aktivieren/deaktivieren." -- Klick to use

SWEP.Category = "EGM:RP"

SWEP.PrintName = "Atemgerät" -- Breathing Device

SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.ViewModelFOV = 70
SWEP.Slot = 3
SWEP.SlotPos = 1

SWEP.ViewModel = ""
SWEP.WorldModel = ""

SWEP.Primary = {}
SWEP.Primary.ClipSize       = -1
SWEP.Primary.DefaultClip    = -1
SWEP.Primary.Automatic      = false
SWEP.Primary.Ammo           = "none"

SWEP.Secondary = {}
SWEP.Secondary.ClipSize     = -1
SWEP.Secondary.DefaultClip  = -1
SWEP.Secondary.Automatic    = false
SWEP.Secondary.Ammo         = "none"

SWEP.DrawAmmo       = false
SWEP.DrawCrosshair  = false

function SWEP:Initialize()
    self:SetHoldType("normal")
end

function SWEP:Reload()
    return
end

local function toggleBreather(ply)
    ply:SetNWBool("Realism.UsingBreather", not ply:GetNWBool("Realism.UsingBreather", false))
end

function SWEP:PrimaryAttack()
    if not SERVER then return end
    if self:GetNextPrimaryFire() > CurTime() then return end
    self:SetNextPrimaryFire(CurTime() + 1)

    local ply = self:GetOwner()
    toggleBreather(ply)
end

function SWEP:SecondaryAttack()
    if not SERVER then return end
    if self:GetNextPrimaryFire() > CurTime() then return end
    self:SetNextPrimaryFire(CurTime() + 1)

    local ply = self:GetOwner()
    toggleBreather(ply)
end

function SWEP:Deploy()
    self:GetOwner():DrawViewModel(false)
end

hook.Add("ScalePlayerDamage", "Realism.BreathingSystem", function(ply, hitgroup, dmgInfo)
    if ply:GetNWBool("Realism.UsingBreather", false) and table.HasValue(Realism.BreathingResistance, dmgInfo:GetDamageType()) then
        return true
    end
end)
--gamemodes/starwarsrp/gamemode/modules/lightsaber_crafting/sh_donator.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
-- Copyright © 2020 Pascal Sthamer,  --
--      Konstantin Zisiadis und      --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--         Shared | Donator          --
---------------------------------------

for identifier, name in pairs(LightsaberCrafting.DonatorPackets) do
	Donator:Register(identifier, name, false)
end
--gamemodes/egmrp/gamemode/modules/event/sh_config.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--       Client | Event Config       --
---------------------------------------
--  Variables should be overwritten  --
--     in the deriving gamemode!     --
---------------------------------------

-- Minaccest group to use the event lister.
Event.MinAccessGroup = "operator"

-- Background of the event lister.
Event.Background = "backgrounds/ivretor_super_valve_bros.jpg"

-- Default keybind for the event lister.
Event.DefaultBind = KEY_F8
--gamemodes/starwarsrp/gamemode/modules/weaponutil/sh_config.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--    on official 'Einfach Gaming'   --
--     servers owned by 'P4sca1'     --
--                                   --
-- Copyright © 2020 Pascal Sthamer,  --
--      Konstantin Zisiadis und      --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--       weaponutil config           --
---------------------------------------

WeaponUtil.ScaleFistDamage = 2.5
--gamemodes/starwarsrp/gamemode/modules/weaponutil/sh_weaponutil.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--    on official 'Einfach Gaming'   --
--     servers owned by 'P4sca1'     --
--                                   --
-- Copyright © 2020 Pascal Sthamer,  --
--      Konstantin Zisiadis und      --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
---------------------------------------
--     Shared | Weapon Utilities     --
---------------------------------------

local Player = FindMetaTable("Player")

function Player:HasWeaponInTable(weapons)
	for k, weapon in pairs(weapons or {}) do
		if self:HasWeapon(weapon) then
			return true
		end
	end
	return false
end

-- TFA Knockback Reduce
if SERVER then
	hook.Add("PlayerSpawn", "KillKnockback", function(ply)
		ply:AddEFlags(EFL_NO_DAMAGE_FORCES)
	end)
end

if CLIENT then
	timer.Create("EGM.TFA.HoldConvars", 2, 0, function()
		RunConsoleCommand("cl_tfa_hud_crosshair_color_team", 0)
		RunConsoleCommand("cl_tfa_3dscope", 1)
	end)

	cvars.AddChangeCallback("cl_tfa_hud_crosshair_color_team", function(convar, oldValue, newValue)
		if isstring(newValue) and newValue == "1" or isnumber(newValue) and newValue == 1 then
			RunConsoleCommand("cl_tfa_hud_crosshair_color_team", 0)
		end
	end)

	cvars.AddChangeCallback("cl_tfa_3dscope", function(convar, oldValue, newValue)
		if isstring(newValue) and newValue == "1" or isnumber(newValue) and newValue == 1 then
			RunConsoleCommand("cl_tfa_3dscope", 1)
		end
	end)
end

if CLIENT then
	local function GetWeaponInfo()
		if not LocalPlayer():GetActiveWeapon() then
			Notify:Danger("Fehler!", "Du hast keine aktive Waffe in der Hand!")
			return
		end

		if not (weapons.IsBasedOn(LocalPlayer():GetActiveWeapon():GetClass(), "weapon_swrp_egm_base") or weapons.IsBasedOn(LocalPlayer():GetActiveWeapon():GetClass(), "weapon_swrp_egm_3dscoped_base")) then
			Notify:Danger("Fehler!", "Dies ist keine TFA Waffe!")
			return
		end

		if not LocalPlayer():IsAtLeast("testmoderator") then
			Notify:Danger("Keine Rechte!", "Du hast keine Rechte um die Waffen zu inspizieren!")
			return
		end

		local weapon = LocalPlayer():GetActiveWeapon()

		print("---------- EGM | Waffen Inspektion ----------")
		print(">> Name: " .. weapon.PrintName or "NIL")
		print(">> RPM: " .. weapon.Primary.RPM or "NIL")
		print(">> RPM Semi: " .. weapon.Primary.RPM_Semi or "NIL")
		print(">> Range: " .. weapon.Primary.Range or "NIL")
		print(">> Num of Shots: " .. weapon.Primary.NumShots or "NIL")
		print(">> Schaden: " .. weapon.Primary.Damage or "NIL")
		print(">> Spread: " .. weapon.Primary.Spread or "NIL")
		print(">> Iron Accuracy: " .. weapon.Primary.IronAccuracy or "NIL")
		print(">> Clipsize: " .. weapon.Primary.ClipSize or "NIL")
		print(">> Ammo Consumption: " .. weapon.Primary.AmmoConsumption or "NIL")
		if weapon.Secondary.ScopeZoom then
			print(">> Scope Level: " .. weapon.Secondary.ScopeZoom or "NIL")
		end
		print("--------------------------------------------")
	end

	concommand.Add("egm_weapon_info", GetWeaponInfo)
end

-- Unlock inventory when being handcuffed.
hook.Add("InventoryContainer.CanAccessInventory", "WeaponUtil.UnlockHandcuffed", function(ply, targetChar)
	local owner = targetChar:GetOwner()

	if owner:HasWeapon("weapon_handcuffed") then
		return true
	end
end)
--gamemodes/starwarsrp/gamemode/modules/pronemod/cl_pronemod.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--         ProneMod Extension        --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--      ProneMod Extension | CL      --
---------------------------------------

-- If player has lightsaber attack delay, prone mod is not available
--
-- @param? Player ply
hook.Add("prone.CanEnter", "prone.LightsaberDelay", function(ply)
	if ply:GetNW2Float("wOS.SaberAttackDelay", 0) >= CurTime() then
		return false
	end
end)

-- If player holding lightsaber, prone mod is not available
--
-- @param? Player ply
hook.Add("prone.CanEnter", "prone.NoLightsaber", function(ply)
	local activeWeapon = ply:GetActiveWeapon()
	if IsValid(activeWeapon) then
		return not string.find(activeWeapon:GetClass(), "lightsaber")
	end
end)

-- If player is handcuffed, prone mod is not available
--
-- @param? Player ply
hook.Add("prone.CanEnter", "prone.IsHandcuffed", function(ply)
	if ply:IsHandcuffed() then
		return false
	end
end)

-- Prone mod keybind
local key_waspressed = false
local last_prone_request = 0
local doubletap_shouldsend = true
local doubletap_keypress_resettime = false
hook.Add("CreateMove", "prone.Keybind", function(cmd)
	if LocalPlayer():OnGround() and not vgui.GetKeyboardFocus() and not gui.IsGameUIVisible() and not gui.IsConsoleVisible() then
		if input.IsKeyDown(KeyBind:Get("Hinlegen")) then
			key_waspressed = true

			-- If doubletap is enabled they have a second to double click the bind key.
			doubletap_keypress_resettime = CurTime() + .66
		else
			if key_waspressed then
				if last_prone_request < CurTime() then
					doubletap_shouldsend = not doubletap_shouldsend

					if not tobool(Settings:Get("Zum Hinlegen Doppel-Bind")) or doubletap_shouldsend then
						prone.Request()

						last_prone_request = CurTime() + 1.25
					end
				end

				key_waspressed = false
			end
		end

		if doubletap_keypress_resettime ~= false and doubletap_keypress_resettime < CurTime() then
			doubletap_keypress_resettime = false
			doubletap_shouldsend = true
		end
	end
end)

-- If they enable jump to get up then read that here.
local jumptogetup_presstime = 0
hook.Add("KeyPress", "Prone.JumpToGetUp", function(ply, key)
	if IsFirstTimePredicted() and ply == LocalPlayer() and ply:IsProne() and key == IN_JUMP then
		if not tobool(Settings:Get("Zum Aufstehen Doppelsprung")) then
			prone.Request()
		else
			if jumptogetup_presstime > CurTime() then
				prone.Request()
			else
				jumptogetup_presstime = CurTime() + 1.25
			end
		end
	end
end)
--gamemodes/starwarsrp/gamemode/config/cl_thirdperson.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--       Third Person System         --
---------------------------------------

-- Default Key to toggle the third person view.
ThirdPerson.DefaultToggleKey = KEY_T

-- Distance of the camera towards the player.
ThirdPerson.Distance = 100
--gamemodes/starwarsrp/gamemode/config/sh_character.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--     Shared | Character config     --
---------------------------------------

-- The model that is set, when the model of the character is invalid.
Character.FallbackModel = "models/player/alyx.mdl"

-- The default active weapon all characters start with.
Character.DefaultActiveWeapon = "egmrp_unarmed"

-- Default weapons that all characters get.
Character.DefaultWeapons = {
	"weapon_fists",
	"egmrp_unarmed",
	"bkeycard",
}

-- Weapons that players being at least of the specicified group get.
Character.ServerGroupWeapons = {
	testmoderator = {
		"weapon_physgun",
		"gmod_tool"
	}
}

-- Minimal group required to edit some character properties like the name.
Character.MinAccessGroup = "testmoderator"

-- Minimal group that has full access to the character system, including editing every property and deleting characters.
Character.MinFullAccessGroup = "superadmin"

-- Whether a player is allowed to edit his own character.
Character.CanSelfEdit = false

-- Can a player delete his own character?
Character.CanDeleteOwnCharacter = false

-- Slow walk speed (Marching speed).
-- Default: 100
Character.SlowWalkSpeed = 100

-- Crouch Walk modifier.
-- Default: 0.3
Character.CrouchedWalkSpeed = 0.3

-- Background image for the character creation.
CharacterCreation.Background = "materials/wallpaper/726it0u9h0j11.jpg"

-- Background image for the character selection.
CharacterSelection.Background = "materials/wallpaper/star-wars-art-4k-om-1920x1080 (1).jpg"

-- Default bind to open the character selection.
CharacterSelection.DefaultBind = KEY_F2

-- Background image of the character manager.
CharacterManager.Background = "materials/wallpaper/4yxovgzdwnk11.png"

-- Default bind to open the character manager.
CharacterManager.DefaultKey = KEY_F4

-- The maximum number of elements a page can have in the character manager. The higher the number the higher the loading time.
CharacterManager.PageSize = 50
--gamemodes/starwarsrp/gamemode/config/sh_deathsystem.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--       DeathSystem | Config        --
---------------------------------------

-- How long it takes before you can respawn.
DeathSystem.RespawnTime = 180

-- Minimum group that is required to be able to respawn a player.
DeathSystem.RespawnAccess = "eventleiter"

-- Weapon that is set when player is stunned to prevent interactions.
DeathSystem.StunWeapon = "weapon_fists"

-- Dont remove the corpse after respawn.
DeathSystem.KeepCorpse = true
--gamemodes/starwarsrp/gamemode/config/sh_event.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--       Client | Event Config       --
---------------------------------------

-- Minaccest group to use the event lister.
Event.MinAccessGroup = "eventleiter"

-- Background of the event lister.
Event.Background = "materials/wallpaper/823254.png"

-- Default keybind for the event lister.
Event.DefaultBind = KEY_F8
--gamemodes/starwarsrp/gamemode/config/sh_experience.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Experience Config          --
---------------------------------------

-- The amount of exp a player receives per minute when not being afk. 0 or false to disable.
Experience.ExpPerMinute = 15

-- The amount of exp a player receives when killing an npc. 0 or false to disable.
Experience.ExpPerNPCKill = 20

-- The maximum possible level.
Experience.MaxLevel = 200

-- The amount of exp that is required to become a higher level.
Experience.ExpPerLevel = 100

-- The ExpPerLevel value is multiplied with this value ^ the next level to determine how many exp is required.
Experience.LevelExpMultiplier = 1.04

-- The amount of levels required to become a new skill point.
Experience.LevelPerSkillPoint = 10

-- The default key for opening the perk menu.
Experience.PerkMenuDefaultKey = KEY_P

-- The background image for the perks menu.
Experience.PerkMenuBackground = "materials/backgrounds/experience.png"

-- The image used for unknown perks.
Experience.UnknownPerkImage = "materials/icons/experience/questionmark.png"

-- Every existing perk category and their perks. Note that the functionality for new perk categories need to be made with custom Lua.
Experience.Perks = {
	offensive = {
		name = "Offensiv",
		image = "materials/icons/damage.png",
		imageCurrent = "materials/icons/damage_f.png",
		values = {
			[1] = {
				value = 1.05,
				name = "Schaden 1",
				description = "Du machst 5% mehr Schaden"
			},
			[2] = {
				value = 1.10,
				name = "Schaden 2",
				description = "Du machst 10% mehr Schaden"
			},
			[3] = {
				value = 1.15,
				name = "Schaden 3",
				description = "Du machst 15% mehr Schaden"
			},
			[4] = {
				value = 1.20,
				name = "Schaden 4",
				description = "Du machst 20% mehr Schaden"
			},
			[5] = {
				value = 1.25,
				name = "Schaden 5",
				description = "Du machst 25% mehr Schaden"
			}
		}
	},
	health = {
		name = "Leben",
		image = "materials/icons/health.png",
		imageCurrent = "materials/icons/health_f.png",
		values = {
			[1] = {
				value = 1.05,
				name = "Leben 1",
				description = "Du hast 5% mehr Leben"
			},
			[2] = {
				value = 1.10,
				name = "Leben 2",
				description = "Du hast 10% mehr Leben"
			},
			[3] = {
				value = 1.15,
				name = "Leben 3",
				description = "Du hast 15% mehr Leben"
			},
			[4] = {
				value = 1.20,
				name = "Leben 4",
				description = "Du hast 20% mehr Leben"
			},
			[5] = {
				value = 1.25,
				name = "Leben 5",
				description = "Du hast 25% mehr Leben"
			}
		}
	},
	movement = {
		name = "Bewegung",
		image = "materials/icons/sprint.png",
		imageCurrent = "materials/icons/sprint_f.png",
		values = {
			[1] = {
				value = 1.025,
				name = "Bewegung 1",
				description = "Du bewegst dich um 2.5% schneller"
			},
			[2] = {
				value = 1.05,
				name = "Bewegung 2",
				description = "Du bewegst dich um 5% schneller"
			},
			[3] = {
				value = 1.075,
				name = "Bewegung 3",
				description = "Du bewegst dich um 7.5% schneller"
			},
			[4] = {
				value = 1.1,
				name = "Bewegung 4",
				description = "Du bewegst dich um 10% schneller"
			},
			[5] = {
				value = 1.125,
				name = "Bewegung 5",
				description = "Du bewegst dich um 12.5% schneller"
			}
		}
	},
	ammo = {
		name = "Munition",
		image = "materials/icons/stamina.png",
		imageCurrent = "materials/icons/stamina_f.png",
		values = {
			[1] = {
				value = 1.05,
				name = "Munition 1",
				description = "Du kannst 5% mehr Munition mit dir tragen."
			},
			[2] = {
				value = 1.10,
				name = "Munition 2",
				description = "Du kannst 10% mehr Munition mit dir tragen."
			},
			[3] = {
				value = 1.15,
				name = "Munition 3",
				description = "Du kannst 15% mehr Munition mit dir tragen."
			},
			[4] = {
				value = 1.20,
				name = "Munition 4",
				description = "Du kannst 20% mehr Munition mit dir tragen."
			},
			[5] = {
				value = 1.25,
				name = "Munition 5",
				description = "Du kannst 25% mehr Munition mit dir tragen."
			}
		}
	}
}
--gamemodes/starwarsrp/gamemode/config/sh_instructor.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Instructor | Config        --
---------------------------------------

-- Minimum group that is able to educate players even when not being instructor.
Instructor.MinEducateGroup = "testmoderator"

-- Minimum group that is required to use the instructor manager or edit instructor properties.
Instructor.MinAccessGroup = "testmoderator"

-- Allow Instructors, to rename start characters.
Instructor.AllowRename = true

-- Whether instructors should be able to use reserved slots.
Instructor.UseReservedSlots = true

-- If there are less than this amount of instructors online, then instructors are reserved.
-- Set this to 0 if all instructors should be reserved, no matter how many are already online.
Instructor.MaxInstructorsForReservedSlots = 5

-- The modifier on XP, that is applied when you have instructed someone.
-- (Only works, if the experience module is enabled)
Instructor.XPBonus = 1.5

-- The time for which the modifier is applied for in hours.
-- (Only works, if the experience module is enabled)
Instructor.XPBonusTime = 24

-- Background image for the insturctor manager.
InstructorManager.Background = "materials/wallpaper/1020056.png"

-- The maximum number of elements a page can have in the instructor manager. The higher the number the higher the loading time.
InstructorManager.PageSize = 50
--gamemodes/starwarsrp/gamemode/config/sh_spawnpoints.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Config | Spawnpoints       --
---------------------------------------

-- Minimum Usergroup that is required to change spawnpoints.
Spawnpoints.MinAccessGroup = "admin"
--addons/animations/lua/animations/sh_config.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--             Jedi Bow            	 --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--       SH Config | Jedi Bow        --
---------------------------------------

-- Setup the animations in the
Animations.Config = {
	["wos_jedi_bow"] = {
		name = "Jedi Verbeugung",
		duration = 1.5,
		sort = 20,
		whitelist = {
			"models/tfa/comm/gg/pm_sw_aayala.mdl",
			"models/tfa/comm/gg/pm_sw_adigallia.mdl",
			"models/hosti/swcw/pm_sw_ahsoka_v2.mdl",
			"models/artel/snowashoka/snowashoka.mdl",
			"models/tfa/comm/gg/pm_sw_barriss.mdl",
			"models/hevoc/jedi/etain.mdl",
			"models/cheek/jedi/jedi_female.mdl",
			"models/defcon/starwars/player/jedi_general_female_human.mdl",
			"models/player/valley/Ign/jocasta/jocasta.mdl",
			"models/synergy/cblake/luminara_pm.mdl",
			"models/tfa/comm/gg/pm_sw_shaakti.mdl",
			"models/player/suno/p_tiplar.mdl",
			"models/player/suno/p_tiplee.mdl",
			"models/player/valley/Ign/jocasta/jocasta.mdl",
			"models/gonzo/femalejedi/knight/knight.mdl",
			"models/defcon/starwars/player/jedi_general_alien.mdl",
			"models/defcon/starwars/player/jedi_general_alien1.mdl",
			"models/defcon/starwars/player/jedi_general_human.mdl"
		}
	},

	["wos_jedi_grossbow"] = {
		name = "Jedi Verbeugung",
		duration = 1.5,
		sort = 21,
		whitelist = {
			"models/player/jedi/gungan.mdl",
			"models/tfa/comm/gg/pm_sw_eeth_koth.mdl",
			"models/gonzo/femalejedi/knight/knight.mdl",
			"models/defcon/starwars/player/jedi_general_alien.mdl",
			"models/defcon/starwars/player/jedi_general_alien1.mdl",
			"models/defcon/starwars/player/jedi_general_human.mdl",
			"models/player/mundi/kiadi.mdl",
			"models/tfa/comm/gg/pm_sw_fisto.mdl",
			"models/kaiido/mace_windu.mdl",
			"models/kaiido/obi_wan.mdl",
			"models/kaiido/gnl/jedi_general_male_01.mdl",
			"models/player/plokoon/plokoon.mdl",
			"models/plocool/stallionstan/hippiejedi/quinlanvos.mdl",
			"models/epangelmatikes/revan/revan_opt.mdl",
			"models/seven/jedi_robe_alien.mdl",
			"models/seven/jedi_robe_human.mdl",
			"models/tfa/comm/gg/pm_sw_shaakti.mdl",
			"models/epangelmatikes/templeguard/temple_guard_opt.mdl",
			"models/tfa/comm/gg/pm_sw_yoda.mdl",
			"models/hevoc/bf2_plokoon/bf2_plokoon.mdl",
			"models/cyanblue/sw/anakin/anakin.mdl",
			"models/sirris_sw/Dooku_PM.mdl",
			"models/summe/nuru_chiss.mdl",
			"models/player/aussiwozzi/mandalorians/bardan/bardan_mando.mdl",
			"models/gonzo/saeseetiin/saeseetiin.mdl",
			"models/fisher/tomackerson/tomackerson_human.mdl",
			"models/fisher/tomackerson/tomackerson_alien.mdl",
			"models/fisher/tomackerson/tomackerson.mdl",
			"models/gonzo/lucien/lucien.mdl"
		}
	},

	-- ["wos_genji_dance"] = {
	-- 	name = "Genji Dance",
	-- 	duration = 3,
	-- 	-- whitelist = {
	-- 		--"Put here the model path",
	-- 	-- }
	-- }
}
--addons/wos-passiveevent/lua/wos/pes/vgui/wos_calendar.lua:

local PANEL = {}

local time = {
	Second = 1,
	Minute = 60,
	Hour = 60*60,
	Day = 60*60*24
}

function PANEL:Init()

	local dash = vgui.Create("DPanel", self)
	dash:Dock(TOP)
	dash:SetTall(60)

	timer.Simple(0, function()
		local size = math.floor(dash:GetWide() / (table.Count(time) *2))
		self:GetParent():SetWide(size*(table.Count(time) *2))
		self:GetParent():Center()
		for index, time in SortedPairsByValue(time, true) do
			local timebutton = vgui.Create("DButton", dash)
			timebutton:Dock(LEFT)
			timebutton:SetWide(size)
			timebutton:DockMargin(0,0,0,0)
			timebutton:SetText("-1 " .. index)
			timebutton.DoClick = function()
				self.time = math.max(self.time - time, 0)
			end
		end

		for index, time in SortedPairsByValue(time) do
			local timebutton = vgui.Create("DButton", dash)
			timebutton:SetWide(size)
			timebutton:Dock(LEFT)
			timebutton:DockMargin(0,0,0,0)
			
			timebutton:SetText("+1 " .. index)
			timebutton.DoClick = function()
				self.time = math.max(self.time + time, 0)
			end
		end
	end)

	self.time = 0
end

function PANEL:GetTime()
	return os.time() + self.time
end

function PANEL:Paint(w, h)
	surface.SetDrawColor(0,0,0)
	surface.DrawRect(0,0, w ,h)
	local date = os.date( "%Y/%m/%d  %H:%M:%S", self.time + os.time())

	draw.SimpleText(date, "DermaDefault", w/2, 60 + (h - 60)/2, color_white, 1, 1 )
end

vgui.Register( "wOSCalendar", PANEL, "Panel" )
--addons/wos-passiveevent/lua/wos/pes/core/sh_mod_mount.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--
























































































































































wOS = wOS or {}
wOS.PES = wOS.PES or {}
wOS.PES.Modules = wOS.PES.Modules or {}
wOS.PES.Modules.Data = wOS.PES.Modules.Data or {}

function wOS.PES.Modules:Autoloader()
	local _, folders = file.Find( "wos/pes/addons/*", "LUA")

    for _, folder in pairs( folders, true ) do

        local n_folder = "wos/pes/addons/" .. folder
        for __, source in pairs( file.Find( n_folder .. "/*", "LUA" ), true ) do   

            local realm = string.lower(string.Left(source, 3) )
            local ext = string.lower(string.Right(source, 3) )
            local lua =  n_folder .. "/" .. source

            if SERVER and realm == "sv_" then
                if ext == "wos" then
                    wOS.PES:ServerInclude( lua )
                else
                    include( lua )
                end
            elseif realm == "cl_" then
                if SERVER then
                    AddCSLuaFile( lua )
                else
                    include( lua )
                end
            elseif realm == "sh_" then
                if SERVER then
                    AddCSLuaFile( lua )
                end
                include( lua )
            end
            
        end

    end
end

function wOS.PES.Modules:RegisterAddon( name, varData )
    if not name then return end
    if not varData then return end
    self.Data[name] = varData
end

function wOS.PES.Modules:Get( mod )
    if not mod then return {} end
    if not wOS.PES.Modules.Data[mod] then return {} end

    return wOS.PES.Modules.Data[mod]
end

wOS.PES.Modules:Autoloader()

-- local function KevCISNPCFix( ent, entdata )
--     if not ent then return end
--     if not IsValid( ent.originalReference ) then return end
--     return ent.originalReference
-- end

-- hook.Add( "wOS.PES.PrePartialReadEntity", "wOS.PES.KevCISNPCDupeFixes", KevCISNPCFix )
-- hook.Add( "wOS.PES.PreReadEntity", "wOS.PES.KevCISNPCDupeFixes", KevCISNPCFix )

hook.Add( "wOS.PES.PostSpawnEntity", "wOS.PES.KevCISNPCDupeFixes", function( ent )
    if not ent then return end
    if not IsValid( ent.npc ) then return end
    return ent.npc
end )

if SERVER then
    hook.Add( "PreRegisterSENT", "wOS.PES.CISNPCSARETHEWORST", function( ent, class )
        if class != "seperatist_alliance_npc_base" and class != "seperatist_alliance_special_npc_base" then return end

        local init = ent.Initialize
        ent.Initialize = function( self )
            init( self )
            if not IsValid( self.npc ) then return end

            self.npc.OnEntityCopyTableFinish = function( npc, dat )
                if npc.WOS_StopCopy then return end
                dat.Class = npc.originalReference:GetClass()
                npc.WOS_StopCopy = true
                    dat.NPCSettings = duplicator.CopyEntTable( npc )
                    dat.NPCSettings.Angle = nil
                    dat.NPCSettings.Pos = nil
                npc.WOS_StopCopy = false
                dat.CurrentWeapon = npc:GetInternalVariable( "additionalequipment" )
            end
        end

        ent.PostEntityPaste = function( self, ply, ett, enttbl )
            if not IsValid( self.npc ) then return end
            
            if self.NPCSettings then
                duplicator.DoGeneric( self.npc, self.NPCSettings )
            end
            
            if not self.CurrentWeapon then return end
            self.npc:SetKeyValue( "additionalequipment", self.CurrentWeapon )
            self.npc:Give( self.CurrentWeapon )
        end
    end )
end
--addons/wos-passiveevent/lua/wos/pes/addons/sound/cl_core.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--

























































































































































local addon = {}

net.Receive("wOS.PES.Sound", function()
	local soundPath = net.ReadString()
	local volume = net.ReadFloat()
	local duration = net.ReadInt(8)

	if string.StartWith(soundPath, "https") then
		sound.PlayURL(soundPath, "", function(station)
			if IsValid (station) then
				station:SetPos(LocalPlayer():GetPos())
				station:SetVolume(volume)
				station:Play()

				if duration > 0 then
					timer.Simple(duration, function()
						if not IsValid(station) then return end

						station:Stop()
					end)
				end
			end
		end)
	else
		surface.PlaySound(soundPath)
	end
end)

wOS.PES.Modules:RegisterAddon( "sound", addon )
--addons/wos-passiveevent/lua/wos/pes/vars/color.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--


local VAR = {}

VAR.Name = "Color"
VAR.IsValid = function(varTable, value)
    if not IsColor(value) and not istable( value ) then
        return false
    end

    return true
end

VAR.DermaElement = function(varTable, value)
    local colorMixer = vgui.Create("DColorMixer")

    if not IsColor( value ) and istable( value ) then
        value = Color( value.r or value.x, value.g or value.y, value.b or value.z, value.a or 255 )
    end

    if IsColor(value) then
        colorMixer:SetColor(value)
    else
        colorMixer:SetColor(varTable.Default)
    end

    return colorMixer
end

VAR.GetValue = function(colorMixer)
    return colorMixer:GetColor()
end


return VAR
--addons/wos-passiveevent/lua/wos/pes/vars/dropdown.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--


local VAR = {}

VAR.Name = "Dropdown"
VAR.DirtyValidate = true
VAR.IsValid = function(varTable, value)
    if not isstring(value) then
        return false
    end

    if value == "" then
        return false
    end

    return true
end

VAR.DermaElement = function(varTable, value)
    local frame = vgui.Create("DPanel")
    frame:SetTall( 50 )

    local comboBox = vgui.Create("DComboBox",frame)
    comboBox:SetTall( 20 )
    comboBox:Dock(TOP)
	comboBox:DockMargin(0,0,0,0)

    varTable.Values = varTable.Values or {}
    if isstring( varTable.Values ) and string.Left(varTable.Values, 6) == "FUNC::" then
        local func_name = string.Replace( varTable.Values, "FUNC::", "" )
        local layers = string.Split( func_name, "." )

        local func = _G
        for _, layer in ipairs( layers ) do
            func = func[ layer ] 
        end
        varTable.Values = func()
    end

    for _, choice in pairs(varTable.Values) do
        comboBox:AddChoice(choice)
    end

    if isstring(value) then
        comboBox:SetValue(value)
    else
        if isstring(varTable.Default) then
            comboBox:SetValue(varTable.Default )
        end
    end

    frame.GetValue = function( self )
        return comboBox:GetValue()
    end 

    return frame
end

VAR.GetValue = function(comboBox)
    return comboBox:GetValue()
end


return VAR
--addons/wos-passiveevent/lua/wos/pes/vars/list.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--


local VAR = {}

VAR.Name = "List"
VAR.DirtyValidate = true
VAR.IsValid = function(varTable, value)
    if not istable(value) then
        return false
    end

    for _, entry in pairs(value) do
        if not isstring(entry) then
            return false
        end
    end

    return true
end

VAR.DermaElement = function(varTable, value)
    local listView = vgui.Create("DListView")
    listView:SetTall(200)
    listView:SetMultiSelect(true)
    
    if istable(value) then
        listView.SelectedValues = value
    elseif istable(varTable.Default) then
        listView.SelectedValues = varTable.Default
    else
        listView.SelectedValues = {}
    end

    if isstring(varTable.Header) then
        listView:AddColumn(varTable.Header)
    else
        listView:AddColumn("Multi-Select")
    end
    
    if isstring( varTable.Values ) and string.Left(varTable.Values, 6) == "FUNC::" then
        local func_name = string.Replace( varTable.Values, "FUNC::", "" )
        local layers = string.Split( func_name, "." )

        local func = _G
        for _, layer in ipairs( layers ) do
            func = func[ layer ] 
        end
        varTable.Values = func()

    end

    for _, entry in pairs(varTable.Values or {}) do
        local line = listView:AddLine(entry)
        if table.HasValue(listView.SelectedValues, entry) then
            line:SetSelected(true)
        end
    end

    function listView:OnRowRightClick(index, line)
        line:SetSelected(false)

        table.RemoveByValue(listView.SelectedValues, line:GetValue(1))
    end
    function listView:OnRowSelected(index, line)
        line:SetSelected(true)

        -- Keeping Everything active.
        for k, otherLine in pairs(self:GetLines()) do
            if table.HasValue(listView.SelectedValues, otherLine:GetValue(1)) then
                otherLine:SetSelected(true)
            end
        end

        if table.HasValue( listView.SelectedValues, line:GetValue(1) ) then return end
        table.insert(listView.SelectedValues, line:GetValue(1))
        
    end

    return listView
end

VAR.GetValue = function(listView)
    return listView.SelectedValues
end

return VAR
--addons/wos-passiveevent/lua/wos/pes/vars/list_uneditable.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--


local VAR = {}

VAR.Name = "Read-Only List"

VAR.IsValid = function(varTable, value)
    if not istable(value) then
        return false
    end

    for _, entry in pairs(value) do
        if not isstring(entry) then
            return false
        end
    end

    return true
end

VAR.DermaElement = function(varTable, value)
    local listView = vgui.Create("DListView")
    listView:SetTall(200)
    listView:SetMultiSelect(true)

    if isstring(varTable.Header) then
        listView:AddColumn(varTable.Header)
    else
        listView:AddColumn("Variable View")
    end
    
    if isstring( varTable.Values ) and string.Left(varTable.Values, 6) == "FUNC::" then
        local func_name = string.Replace( varTable.Values, "FUNC::", "" )
        local layers = string.Split( func_name, "." )

        local func = _G
        for _, layer in ipairs( layers ) do
            func = func[ layer ] 
        end
        varTable.Values = func()

    end

    for _, entry in pairs(varTable.Values or {}) do
        local line = listView:AddLine(entry)
        if table.HasValue(listView.SelectedValues, entry) then
            line:SetSelected(true)
        end
    end

    return listView
end

VAR.GetValue = function(listView)
    local values = {}
    for k, line in ipairs( listView:GetLines() ) do
        table.insert( values, line:GetValue( 1 ) )
    end
    return values
end

return VAR
--addons/wos-passiveevent/lua/wos/pes/vars/model.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--



local VAR = {}

VAR.Name = "Model"
VAR.UseTool = true

VAR.ToolTips = {
    { text = "Select the entity to save the model properties from", key = "gui/lmb.png", },
}

VAR.IsValid = function(varData, value)
    if not isstring(value) then
        return false
    end

    if value == "" then
        return false
    end

    return true
end

VAR.DermaElement = function(varTable, value)
    local panel = vgui.Create("DPanel")
    panel.Value = value

    function panel:Paint(ww, hh)
        if isstring(self.Value) then
            draw.SimpleText("Model set to: " .. tostring(self.Value), nil, ww * 0.5, hh * 0.5, Color(125, 0, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        else
            draw.SimpleText("Model needs to be set!", nil, ww * 0.5, hh * 0.5, Color(255, 0, 0), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        end
    end

    return panel
end

VAR.PrimaryAttack = function(wep, ply, dermaElement)
    dermaElement.Data = dermaElement.Data

    local ent = ply:GetEyeTrace().Entity
    if not IsValid( ent ) then return end
    dermaElement.Value = ent:GetModel()
end

VAR.GetValue = function(panel)
    return panel.Value
end

return VAR

--addons/wos-passiveevent/lua/wos/pes/vars/string.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--


local VAR = {}

VAR.Name = "String"

VAR.IsValid = function(varData, value)
    if not isstring(value) then
        return false
    end

    if value == "" then
        return false
    end

    return true
end

VAR.DermaElement = function(varTable, value)
    local textentry = vgui.Create("DTextEntry")

    if varTable.AllowMultiLine then
        textentry:SetMultiline(true)
        textentry:SetHeight(40)
    end

    textentry:SetText(value or varTable.Default or "")

    return textentry
end

VAR.GetValue = function(dermaElement)
    return dermaElement:GetValue()
end

return VAR

--addons/wos-passiveevent/lua/wos/pes/vars/tvector.lua:
--[[-------------------------------------------------------------------]]--[[
                            
Copyright wiltOS Technologies LLC, 2021

Contact: www.wiltostech.com
    
----------------------------------------]]--


local VAR = {}

VAR.Name = "TableVector"
VAR.UseTool = true
VAR.DirtyValidate = true

VAR.ToolTips = {
    { text = "Add the position you are AIMING AT to the list", key = "gui/lmb.png", },
    { text = "Add your current EYE position to the list", key = "gui/lmb.png", key2 = "gui/e.png", },
    { text = "Add your current STANDING position to the list", key = "gui/lmb.png", key2 = "icon16/control_fastforward.png", },
    { text = "Remove the last added position from the list", key = "gui/rmb.png", },
}

VAR.IsValid = function(varTable, value)
    if not istable( value ) then return false end
    if table.Count(value) == 0 then return false end

    for index, vec in ipairs(value) do
        if not isvector( vec ) then
            return false
        end
    end

    return true
end

VAR.DermaElement = function(varTable, value)
    local panel = vgui.Create("DPanel")
    panel:SetTall( 180 )
    panel.Values = value

    function panel:Paint(ww, hh) end

    local listView = vgui.Create("DListView", panel)
    listView:Dock( FILL )
    listView:AddColumn("Vector")
    listView.RefreshList = function( pan )
        pan:Clear()
        if not panel.Values or #panel.Values < 1 then
            pan:AddLine( "Vector needs to be set!" )
            return
        end

        for id, vec in pairs( panel.Values or {} ) do
            local line = pan:AddLine( vec )
            line.ID = id
        end
        
    end

    listView.OnRowRightClick = function( pan, id, line )
        table.remove( panel.Values, line.ID )
        pan:RefreshList()
    end

    listView:RefreshList()
    panel.RefreshList = function() listView:RefreshList() end

    return panel
end

VAR.GetValue = function(panel)
    return panel.Values || {}
end

VAR.PrimaryAttack = function(wep, ply, panel)
    local pos =  ply:GetEyeTrace().HitPos
    if ply:KeyDown( IN_SPEED ) then
        pos = ply:GetPos()
    elseif ply:KeyDown( IN_USE ) then
        pos = ply:EyePos()
    end
    local allowed = hook.Call( "wOS.CombatSim.CanPlaceEntity", nil, wep, ply, pos )
    if isbool( allowed ) and allowed == false then return end
    panel.Values = panel.Values || {}
    panel.Values[#panel.Values + 1] = pos
    panel:RefreshList()
end

VAR.SecondaryAttack = function(wep, ply, panel)
    panel.Values = panel.Values || {}
    panel.Values[#panel.Values] = nil
end

VAR.OnStart = function(node, value, var)

    local val  = {}

    for index, vec in ipairs(value) do
        if !isvector(vec) then

            vec = Vector(vec)
            if vec then
                val[index] = vec
                continue
            end
        end
        val[index] = vec
    end
    node:SetVar(var.Name, val)
end

VAR.Draw3D = function(wep, ply, element)
    local tVec = element.Values || {}
    for index, vec in ipairs(tVec) do
        if not isvector(vec) then continue end

        local top = Vector(vec.x, vec.y, vec.z + 200)
        render.DrawLine(vec, top, Color(255, 255, 255), false)
    end
end


return VAR

--addons/wos-passiveevent/lua/wos/pes/core/sh_net.lua:


function net.WriteActivePESEvent(event)
	if table.IsEmpty(event) then
		net.WriteUInt(0, 1)
	else
		net.WriteUInt(1, 1)
		net.WriteTable(event) // For now this is what we will go with but should optimise further than this
	end
end

// This exists because we want to be consistent under the hood, for when we optimise this packet
function net.ReadActivePESEvent() 
	local valid = net.ReadUInt(1)
	if valid == 1 then
		return net.ReadTable()
	else
		return {}
	end
end

function net.WritePESEventHeader(event, dirty)
	net.WriteString(event.Name)
	net.WriteString(event.Description or "No description available")
	net.WriteUInt(#event.Nodes, 32)
	net.WriteDouble(event.random or 0)
	net.WriteBool( event.Importable )
	net.WriteBool( dirty or false )
end

function net.ReadPESEventHeader()
	local event = {}
	event.Name = net.ReadString()
	event.Description = net.ReadString()
	event.NodeCount = net.ReadUInt(32)
	event.random = net.ReadDouble()
	event.Importable = net.ReadBool()
	event.Dirty = net.ReadBool()

	return event
end

function net.WriteCSSSimulationHeader( simdata, dirty )

	net.WriteTable( simdata.Settings )
	net.WriteBool( simdata.Importable )

end


function net.ReadCSSSimulationHeader()
	local sim = {}
	sim.Settings = net.ReadTable()
	sim.Importable = net.ReadBool()
	sim.Event = {}
	sim.Dirty = true
	
	return sim
end 

//////////////////////////////////////////////////////////////////////
--addons/wos-passiveevent/lua/wos/css/loader/loader.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2019
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--

wOS = wOS or {}
wOS.CombatSim = wOS.CombatSim or {}

if CLIENT then
	include( "wos/css/config/sh_config.lua" )

	include( "wos/css/vgui/wos_css_scrollpanel.lua" )
	include( "wos/css/vgui/wos_css_nodebackground.lua" )
	
	include( "wos/css/core/cl_core.lua" )
	include( "wos/css/core/cl_admin_menu.lua" )
	include( "wos/css/core/cl_net.lua" )	

	include( "wos/css/entities/wos_simulation_system/cl_wos_simulation_system.lua")
	include( "wos/css/entities/wos_simulation_system/sh_wos_simulation_system.lua" )

	include( "wos/css/entities/wos_simulation_tool/cl_wos_simulation_tool.lua")
	include(  "wos/css/entities/wos_simulation_tool/sh_wos_simulation_tool.lua" )

	include( "wos/css/entities/wos_simulation_wall/cl_wos_simulation_wall.lua")
	include(  "wos/css/entities/wos_simulation_wall/sh_wos_simulation_wall.lua" )

	include(  "wos/css/entities/wos_pes_basicobj/cl_wos_pes_basicobj.lua" )

end

if SERVER then
	AddCSLuaFile( "wos/css/config/sh_config.lua" )

	include( "wos/css/config/sh_config.lua" )
	include( "wos/css/config/sv_config.lua" )
	
	AddCSLuaFile( "wos/css/vgui/wos_css_scrollpanel.lua" )
	AddCSLuaFile( "wos/css/vgui/wos_css_nodebackground.lua" )

	AddCSLuaFile( "wos/css/core/cl_core.lua" )
	AddCSLuaFile( "wos/css/core/cl_admin_menu.lua" )
	AddCSLuaFile( "wos/css/core/cl_net.lua" )
	
	wOS.PES:ServerInclude( "wos/css/core/sv_net.lua" )
	wOS.PES:ServerInclude( "wos/css/core/sv_core.lua" )
	
	AddCSLuaFile( "wos/css/entities/wos_simulation_system/sh_wos_simulation_system.lua")
	AddCSLuaFile( "wos/css/entities/wos_simulation_system/cl_wos_simulation_system.lua")
	include( "wos/css/entities/wos_simulation_system/sh_wos_simulation_system.lua" )
	wOS.PES:ServerInclude( "wos/css/entities/wos_simulation_system/sv_wos_simulation_system.lua")
	
	AddCSLuaFile( "wos/css/entities/wos_simulation_tool/sh_wos_simulation_tool.lua")
	AddCSLuaFile( "wos/css/entities/wos_simulation_tool/cl_wos_simulation_tool.lua")
	include(  "wos/css/entities/wos_simulation_tool/sh_wos_simulation_tool.lua" )
	wOS.PES:ServerInclude( "wos/css/entities/wos_simulation_tool/sv_wos_simulation_tool.lua")
	
	AddCSLuaFile( "wos/css/entities/wos_simulation_wall/sh_wos_simulation_wall.lua")
	AddCSLuaFile( "wos/css/entities/wos_simulation_wall/cl_wos_simulation_wall.lua")
	include(  "wos/css/entities/wos_simulation_wall/sh_wos_simulation_wall.lua" )
	wOS.PES:ServerInclude( "wos/css/entities/wos_simulation_wall/sv_wos_simulation_wall.lua")

	wOS.PES:ServerInclude( "wos/css/entities/wos_pes_basiczone/sv_wos_pes_basiczone.lua")	

	AddCSLuaFile( "wos/css/entities/wos_pes_basicobj/cl_wos_pes_basicobj.lua")
	wOS.PES:ServerInclude( "wos/css/entities/wos_pes_basicobj/sv_wos_pes_basicobj.lua")	

	include( "wos/css/wrappers/sv_data.lua" )
	wOS.PES:ServerInclude( "wos/css/core/sv_wrapper.lua")

end
--addons/wos-passiveevent/lua/wos/css/core/cl_admin_menu.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2019
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--

wOS = wOS or {}
wOS.CombatSim = wOS.CombatSim or {}
wOS.CombatSim.GameTypes = wOS.CombatSim.GameTypes or {}

local w,h = ScrW(), ScrH()
local blur = Material("pp/blurscreen")

local function DrawBlur(panel, amount)
	local x, y = panel:LocalToScreen(0, 0)
	surface.SetDrawColor(255, 255, 255)
	surface.SetMaterial(blur)
	for i = 1, 3 do
		blur:SetFloat("$blur", (i / 3) * (amount or 6))
		blur:Recompute()
		render.UpdateScreenEffectTexture()
		surface.DrawTexturedRect(x * -1, y * -1, w, h)
	end
end

local createChallengeIcon = Material( "wos/css/wiltos.png", "unlitgeneric" )
local joinGameIcon = Material( "wos/css/wiltos.png", "unlitgeneric" )

function wOS.CombatSim:OpenSimulatorNameMenu(borderPoints, selectedHeight)
	if not IsValid(self.SimulatorMenu) then self:OpenMenu() end

	self.SimulatorMenu.SizeT = { w = w*0.25, h = h*0.2 }
	self.SimulatorMenu.Title = "SET SIMULATOR NAME"
	self.SimulatorMenu:Clear()

	local rw, rh = self.SimulatorMenu.SizeT.w, self.SimulatorMenu.SizeT.h
	
	local nameField = vgui.Create("DPanel", self.SimulatorMenu)
	nameField:SetSize( rw*0.9, rh*0.2 )
	nameField:SetPos( rw*0.05, rh*0.25 )
	nameField.Paint = function( pan, ww, hh )
		draw.SimpleText("Simulator Name:", "wOS.CombatSim.LeaderFont", 0, hh * 0.5, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
	end
	
	local nameEntryField = vgui.Create("DTextEntry", self.SimulatorMenu)
	nameEntryField:SetSize( rw*0.9, rh*0.15 )
	nameEntryField:SetPos( rw*0.05, rh*0.45 )
	nameEntryField:SetFont( "wOS.CombatSim.MediumFont" )
	nameEntryField:SetValue( istable(simulator) and simulator:GetSimulatorName() or "" )

	local saveButton = vgui.Create("DButton", self.SimulatorMenu)
	saveButton:SetSize( rw*0.8, rh*0.2 )
	saveButton:SetPos( rw*0.1, rh*0.7 )
	saveButton:SetFont( "wOS.CombatSim.LeaderFont" )
	saveButton:SetText( "Set Simulator Name" )
	saveButton.DoClick = function( pan )
		local name = nameEntryField:GetValue()
		
		net.Start("wOS.CombatSim.SetBorderPoints")
			net.WriteTable(borderPoints)
			net.WriteInt(selectedHeight, 32)
			net.WriteString(name)
		net.SendToServer()
	end
end

function wOS.CombatSim:OpenToolMenu( simulator )
	if not IsValid(self.SimulatorMenu) then self:OpenMenu() end
	
	if not simulator then
		local wep = LocalPlayer():GetActiveWeapon()
		if wep and wep:GetClass() == "wos_simulation_tool" then
			simulator = wep:GetSelectedSimulator()
		end
	end

	self.SimulatorMenu.SizeT = { w = w*0.66, h = h*0.33 }
	self.SimulatorMenu.Title = simulator:GetSimulatorName()
	self.SimulatorMenu:Clear()
	timer.Simple(0, function() self:AddExitButton() end)
	
	local rw, rh = self.SimulatorMenu.SizeT.w, self.SimulatorMenu.SizeT.h
	
	local innerframe = vgui.Create( "WOS_CSS_ScrollPanel", self.SimulatorMenu )
	innerframe:SetSize( rw*0.98, rh*0.8 )
	innerframe:SetPos( rw*0.01, rh*0.15 )
	innerframe:SetPanelSize(rh * 0.7, rh * 0.7)
	innerframe:SetPanelSpacing(rh * 0.05)
	innerframe.Paint = function( pan, ww, hh )
		local background = {
			{ x = 0           , y = hh*0.05 },
			{ x = 0  + hh*0.05, y = 0       },
			{ x = ww - hh*0.05, y = 0       },
			{ x = ww          , y = hh*0.05 },
			{ x = ww          , y = hh*0.95 },
			{ x = ww - hh*0.05, y = hh      },
			{ x = 0  + hh*0.05, y = hh      },
			{ x = 0           , y = hh*0.95 },		
		}
		draw.NoTexture()
		surface.SetDrawColor( wOS.CombatSim.BackgroundColor )
		surface.DrawPoly( background )		
		DrawBlur( pan, 1 )
	end

	local createChallengeButton = innerframe:CreatePanel("DButton")
	createChallengeButton:SetText("")
	createChallengeButton.Paint = function( pan, ww, hh )
		if pan:IsHovered() then
			surface.SetDrawColor(255, 255, 255, 255)
		else
			surface.SetDrawColor(63, 63, 63, 255)
		end
		
		surface.SetMaterial(createChallengeIcon)
		surface.DrawTexturedRect(0, 0, ww, hh)

		draw.SimpleText( "Add", "wOS.CombatSim.LeaderFont", ww/2, hh/2 - hh/12, ( pan:IsHovered() and color_white ) or wOS.CombatSim.TextColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 0 )
		draw.SimpleText( "Simulation", "wOS.CombatSim.LeaderFont", ww/2, hh/2 + hh/12, ( pan:IsHovered() and color_white ) or wOS.CombatSim.TextColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 0 )
	end
	createChallengeButton.DoClick = function( pan )
		self:OpenToolCreateSimulationMenu(simulator)
	end

	local editChallengesButton = innerframe:CreatePanel("DButton")
	editChallengesButton:SetText("")
	editChallengesButton.Paint = function( pan, ww, hh )
		if pan:IsHovered() then
			surface.SetDrawColor(255, 255, 255, 255)
		else
			surface.SetDrawColor(63, 63, 63, 255)
		end
		
		surface.SetMaterial(createChallengeIcon)
		surface.DrawTexturedRect(0, 0, ww, hh)

		draw.SimpleText( "Edit", "wOS.CombatSim.LeaderFont", ww/2, hh/2 - hh/12, ( pan:IsHovered() and color_white ) or wOS.CombatSim.TextColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 0 )
		draw.SimpleText( "Simulation", "wOS.CombatSim.LeaderFont", ww/2, hh/2 + hh/12, ( pan:IsHovered() and color_white ) or wOS.CombatSim.TextColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 0 )
	end
	editChallengesButton.DoClick = function( pan )
		net.Start( "wOS.CSS.GetEditableChallenges" )
		net.SendToServer()
	end

	local removeSimulatorButton = innerframe:CreatePanel("DButton")
	removeSimulatorButton:SetText("")
	removeSimulatorButton.Paint = function( pan, ww, hh )
		if pan:IsHovered() then
			surface.SetDrawColor(255, 255, 255, 255)
		else
			surface.SetDrawColor(63, 63, 63, 255)
		end
		
		surface.SetMaterial(createChallengeIcon)
		surface.DrawTexturedRect(0, 0, ww, hh)

		draw.SimpleText( "Remove", "wOS.CombatSim.LeaderFont", ww/2, hh/2 - hh/12, ( pan:IsHovered() and color_white ) or wOS.CombatSim.TextColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 0 )
		draw.SimpleText( "Simulator", "wOS.CombatSim.LeaderFont", ww/2, hh/2 + hh/12, ( pan:IsHovered() and color_white ) or wOS.CombatSim.TextColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 0 )
	end
	removeSimulatorButton.DoClick = function( pan )
		wOS.CombatSim:OpenRemoveSimulatorDerma(simulator)
	end
end

function wOS.CombatSim:OpenToolSettingsMenu( base_settings, settings )
	if not IsValid(self.SimulatorMenu) then self:OpenMenu() end

	self.SimulatorMenu.SizeT = { w = w*0.33, h = h*0.66 }
	self.SimulatorMenu.Title = "SETTINGS"
	self.SimulatorMenu:Clear()

	local rw, rh = self.SimulatorMenu.SizeT.w, self.SimulatorMenu.SizeT.h

	local innerframe = vgui.Create( "WOS_CSS_ScrollPanel", self.SimulatorMenu )
	innerframe.XScroll = false
	innerframe:SetSize( rw*0.95, rh*0.8 )
	innerframe:SetPos( rw*0.025, rh*0.1 )
	innerframe:SetPanelSize(rw * 0.85, rh * 0.1)
	innerframe:SetPanelSpacing(rw * 0.05)
	innerframe.Paint = function( pan, ww, hh )
		local background = {
			{ x = 0           , y = hh*0.05 },
			{ x = 0  + hh*0.05, y = 0       },
			{ x = ww - hh*0.05, y = 0       },
			{ x = ww          , y = hh*0.05 },
			{ x = ww          , y = hh*0.95 },
			{ x = ww - hh*0.05, y = hh      },
			{ x = 0  + hh*0.05, y = hh      },
			{ x = 0           , y = hh*0.95 },		
		}
		draw.NoTexture()
		surface.SetDrawColor( wOS.CombatSim.BackgroundColor )
		surface.DrawPoly( background )		
		DrawBlur( pan, 1 )
	end

	innerframe.ObjectPanels = {}

	self:CreateSettingsList(innerframe, base_settings, settings, rw, rh)

	local saveButton = vgui.Create("DButton", self.SimulatorMenu)
	saveButton:SetSize( rw*0.6, rh*0.075 )
	saveButton:SetPos( rw*0.2, rh*0.9125 )
	saveButton:SetFont( "wOS.CombatSim.LeaderFont" )
	saveButton:SetText( "Save" )
	saveButton.DoClick = function( pan )
		local settings2 = {}
		for _, objectPanel in pairs(innerframe.ObjectPanels) do
			settings2[objectPanel.SettingName] = objectPanel.Value
		end
		local nMenu = wOS.PES:GetNodeMenu()
		if not nMenu then return end
		if not nMenu.menu then return end
		nMenu.menu:SaveGameSettings( settings2 )
		wOS.CombatSim:OpenMenu()
	end

	return self.SimulatorMenu
end

function wOS.CombatSim:OpenToolPreChallengeMenu( challenges )
	if not IsValid(self.SimulatorMenu) then self:OpenMenu() end

	self.SimulatorMenu.SizeT = { w = w*0.43, h = h*0.66 }
	self.SimulatorMenu.Title = "CHALLENGES"
	self.SimulatorMenu:Clear()

	timer.Simple( 0, function() self:AddExitButton( function() wOS.CombatSim:OpenToolMenu() end ) end )

	local rw, rh = self.SimulatorMenu.SizeT.w, self.SimulatorMenu.SizeT.h

	local innerframe = vgui.Create( "WOS_CSS_ScrollPanel", self.SimulatorMenu )
	innerframe.XScroll = false
	innerframe:SetSize( rw*0.95, rh*0.8 )
	innerframe:SetPos( rw*0.025, rh*0.1 )
	innerframe:SetPanelSize(rw * 0.85, rh * 0.1)
	innerframe:SetPanelSpacing(rw * 0.05)
	innerframe.Paint = function( pan, ww, hh )
		local background = {
			{ x = 0           , y = hh*0.05 },
			{ x = 0  + hh*0.05, y = 0       },
			{ x = ww - hh*0.05, y = 0       },
			{ x = ww          , y = hh*0.05 },
			{ x = ww          , y = hh*0.95 },
			{ x = ww - hh*0.05, y = hh      },
			{ x = 0  + hh*0.05, y = hh      },
			{ x = 0           , y = hh*0.95 },		
		}
		draw.NoTexture()
		surface.SetDrawColor( wOS.CombatSim.BackgroundColor )
		surface.DrawPoly( background )		
		DrawBlur( pan, 1 )
	end

	innerframe.ObjectPanels = {}

	for name, data in pairs( challenges ) do
		local objectPanel = innerframe:CreatePanel("DPanel")
		objectPanel.Data = data
		objectPanel.Paint = function( pan, ww, hh )
			draw.RoundedBox( hh*0.1, 0, 0, ww, hh, wOS.CombatSim.FrameColor )
			DrawBlur( pan, 1 )

			draw.SimpleText(pan.Data.Name, "wOS.CombatSim.MediumFont", ww*0.01, hh*0.005, white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
			draw.SimpleText("MAX PLAYERS: " .. pan.Data.Settings[ "Maximum Players" ], "wOS.CombatSim.SmallFont",  ww*0.99, hh*0.005, white, TEXT_ALIGN_RIGHT, TEXT_ALIGN_TOP)
			
			local word = wOS.PES.WrapText( pan.Data.Description, "wOS.CombatSim.DescFont", ww*0.8 )
			draw.DrawText( word, "wOS.CombatSim.DescFont", ww*0.01, hh*0.37, color_white, TEXT_ALIGN_LEFT ) 		
		end

		table.insert(innerframe.ObjectPanels, objectPanel)

		local ow, oh = objectPanel:GetSize()
		local button = vgui.Create("DButton", objectPanel)
		button:SetSize( ow*0.15, oh*0.45 )
		button:SetPos( ow*0.85, oh*0.55 )
		button.Data = data
		button:SetFont( "wOS.CombatSim.LeaderFont" )
		button:SetText( "Select" )
		button.DoClick = function(pan)
			wOS.CombatSim:OpenMenu()
			wOS.PES.RequestSimulationData(pan.Data.Name, function( simdata )
				wOS.CombatSim:OpenSimulationEditor( simdata )
			end )
		end
		
	end

	return self.SimulatorMenu
end

// Build editor menu
function wOS.CombatSim:OpenSimulationCreator(simulator)
	local nMenu = wOS.PES:GetNodeMenu()
    if IsValid(nMenu) then
		if nMenu.menu then
			if not nMenu.menu.CreationType or nMenu.menu.CreationType == WOS_PES.CREATOR.SIMULATION then 
				nMenu:Show()
				return
			end
		end
        nMenu:Remove()
    end

	local base = vgui.Create("DFrame")
	base:SetSize(ScrW(), ScrH())
	base:Center()
	base:MakePopup()
	base:SetDraggable(false)
	base:SetTitle("")
	base:ShowCloseButton(false)
	base.Paint = function(self, w, h)
		surface.SetDrawColor(35.5,35.5,35.5)
		surface.DrawRect(0,0, w, h)
	end

	local close = vgui.Create("DButton", base)
	close:SetSize(20,20)
	close:SetPos(ScrW()-20, 0)
	close:SetText("")
	close.Paint = function(self, w, h)
		local col = Color(255, 255, 255, (self.Hovered and 255) or 150)

		surface.SetDrawColor(col)
		surface.DrawLine(0,0, w, h)
		surface.DrawLine(w,0, 0, h)
	end
	close.DoClick = function()
		net.Start("wOS.CombatSim.ResetTool")
		net.SendToServer()	
		hook.Call(  "wOS.PES.OnCreatorClose", nil, WOS_PES.CREATOR.SIMULATION )	
		base:Remove()  
	end

	local mini = vgui.Create("DButton", base)
	mini:SetSize(20,20)
	mini:SetPos(ScrW()-45, 0)
	mini:SetText("")
	mini.Paint = function(self, w, h)
		local col = Color(255, 255, 255, (self.Hovered and 255) or 150)

		surface.SetDrawColor(col)
		surface.DrawLine(0,h/2, w, h/2)
	end
	mini.DoClick = function() base:Hide() end

	if IsValid(base.menu) then
		base.menu:Remove()
	end

	local menu = vgui.Create("WOS_CSS_NodeBG", base)
	menu:Dock(FILL)
	menu:DockMargin(0,0,0,0)
	base.menu = menu

	local start = menu:CreateStartNode()

	wOS.PES:SetNodeMenu( base )
	wOS.PES:SetActiveMenu( base )
end

function wOS.CombatSim:OpenSimulationEditor( simdata, dirty, imported )
	if IsValid( self.SimulatorMenu ) then wOS.CombatSim:OpenMenu() end
	local nMenu = wOS.PES:GetNodeMenu()
    if IsValid(nMenu) then
		if nMenu.menu then
			if not nMenu.menu.CreationType or nMenu.menu.CreationType == WOS_PES.CREATOR.SIMULATION then 
				nMenu:Show()
				return
			end
		end
        nMenu:Remove()
    end

	local event = simdata.Event or simdata
	local settings = simdata.Settings

	if imported and event then
		event.OldName = nil
	end

	local base = vgui.Create("DFrame")
	base:SetSize(ScrW(), ScrH())
	base:Center()
	base:MakePopup()
	base:SetDraggable(false)
	base:SetTitle("")
	base:ShowCloseButton(false)
	base.Paint = function(self, w, h)
		surface.SetDrawColor(35.5,35.5,35.5)
		surface.DrawRect(0,0, w, h)
	end

	local close = vgui.Create("DButton", base)
	close:SetSize(20,20)
	close:SetPos(ScrW()-20, 0)
	close:SetText("")
	close.Paint = function(self, w, h)
		local col = Color(255, 255, 255, (self.Hovered and 255) or 150)

		surface.SetDrawColor(col)
		surface.DrawLine(0,0, w, h)
		surface.DrawLine(w,0, 0, h)
	end
	close.DoClick = function()
		net.Start("wOS.CombatSim.ResetTool")
		net.SendToServer()	
		hook.Call( "wOS.PES.OnCreatorClose", nil, WOS_PES.CREATOR.SIMULATION )	
		base:Remove()  
	end

	local mini = vgui.Create("DButton", base)
	mini:SetSize(20,20)
	mini:SetPos(ScrW()-45, 0)
	mini:SetText("")
	mini.Paint = function(self, w, h)
		local col = Color(255, 255, 255, (self.Hovered and 255) or 150)

		surface.SetDrawColor(col)
		surface.DrawLine(0,h/2, w, h/2)
	end
	mini.DoClick = function() base:Hide() end

	if IsValid(base.menu) then
		base.menu:Remove()
	end

	local menu = vgui.Create("WOS_CSS_NodeBG", base)
	menu:Dock(FILL)
	menu:DockMargin(0,0,0,0)
	menu.Importable = simdata.Importable
	base.menu = menu

	menu:SaveGameSettings( settings )

	menu.Name = event.Name
	menu.DirtyNodes = dirty
	menu.Imported = imported
	menu.Description = event.Description
	menu.Importable = simdata.Importable

	for index, node in pairs(event.Nodes) do
		
		local pNode
		if index == 1 then
			pNode = menu:CreateStartNode()
		else
			pNode = menu:AddNode()
			pNode.Type = node.Type
		end

		pNode:SetPos(node.Pos.x, node.Pos.y )
		
		if pNode.Type != node.Type then continue end
		pNode:SetVars(node._vars, dirty)
		pNode:SetDisableVars(node._toggles, dirty)
	end

	for index, node in pairs(event.Nodes) do
		if node.Triggers then
			for triggerName, panelTable in pairs(node.Triggers) do
				for _, otherID in pairs(panelTable) do
					local pnl, oPnl = menu.Nodes[index], menu.Nodes[otherID]
					menu:MakeLink(pnl, oPnl, triggerName)
				end
			end
		end
	end

	for _, node in pairs(menu.Nodes) do
		node:CreateLinks()
	end

	local delin = vgui.Create("DButton", base )
	delin:SetText("Delete Simulation")
	delin:SetPos( 20, 3.5 )
	delin:SetWide( 100 )
	delin.DoClick = function( p )
		menu:OpenEventDeleter()
    end 

	wOS.PES:SetNodeMenu( base )
	wOS.PES:SetActiveMenu( base )
end

function wOS.CombatSim:CleanupAdminMenu()
	local node = wOS.PES:GetNodeMenu()
	if IsValid( node ) then node:Remove() end
	
	local cur_pan = wOS.PES:GetActiveMenu()
	if IsValid( cur_pan ) then cur_pan:Remove() end
end

//OLD CSS STUFF

function wOS.CombatSim:OpenRemoveSimulatorDerma(simulator)
	if not IsValid(self.SimulatorMenu) then self:OpenMenu() end
	
	self.SimulatorMenu.SizeT = { w = w*0.3, h = h*0.3 }
	self.SimulatorMenu.Title = "REMOVE SIMULATOR"
	self.SimulatorMenu:Clear()

	timer.Simple( 0, function() self:AddExitButton() end )

	local rw, rh = self.SimulatorMenu.SizeT.w, self.SimulatorMenu.SizeT.h
	
	local innerframe = vgui.Create( "WOS_CSS_ScrollPanel", self.SimulatorMenu )
	innerframe:SetSize( rw*0.9, rh*0.75 )
	innerframe:SetPos( rw*0.05, rh*0.2 )
	innerframe:SetPanelSize(rh * 0.7, rh * 0.7)
	innerframe:SetPanelSpacing(rh * 0.05)
	innerframe.Paint = function( pan, ww, hh )
		local background = {
			{ x = 0           , y = hh*0.05 },
			{ x = 0  + hh*0.05, y = 0       },
			{ x = ww - hh*0.05, y = 0       },
			{ x = ww          , y = hh*0.05 },
			{ x = ww          , y = hh*0.95 },
			{ x = ww - hh*0.05, y = hh      },
			{ x = 0  + hh*0.05, y = hh      },
			{ x = 0           , y = hh*0.95 },		
		}
		draw.NoTexture()
		surface.SetDrawColor( wOS.CombatSim.BackgroundColor )
		surface.DrawPoly( background )		
		DrawBlur( pan, 1 )
	end

	local removeButton = innerframe:CreatePanel("DButton")
	removeButton:SetText("")
	removeButton.Paint = function( pan, ww, hh )
		if pan:IsHovered() then
			surface.SetDrawColor(255, 255, 255, 255)
		else
			surface.SetDrawColor(63, 63, 63, 255)
		end
		
		surface.SetMaterial(createChallengeIcon)
		surface.DrawTexturedRect(0, 0, ww, hh)

		draw.SimpleText( "YES", "wOS.CombatSim.LeaderFont", ww/2, hh/2, ( pan:IsHovered() and color_white ) or wOS.CombatSim.TextColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 0 )
	end
	removeButton.DoClick = function( pan )
		if self.SimulatorMenu.Clicked then return end

		self.SimulatorMenu.Clicked = true
		self.SimulatorMenu:ToggleClose()
		
		net.Start("wOS.CombatSim.RemoveSelectedSimulator")
		net.SendToServer()
	end
	
	local abortButton = innerframe:CreatePanel("DButton")
	abortButton:SetText("")
	abortButton.Paint = function( pan, ww, hh )
		if pan:IsHovered() then
			surface.SetDrawColor(255, 255, 255, 255)
		else
			surface.SetDrawColor(63, 63, 63, 255)
		end
		
		surface.SetMaterial(createChallengeIcon)
		surface.DrawTexturedRect(0, 0, ww, hh)

		draw.SimpleText( "NO", "wOS.CombatSim.LeaderFont", ww/2, hh/2, ( pan:IsHovered() and color_white ) or wOS.CombatSim.TextColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 0 )
	end
	abortButton.DoClick = function( pan )
		wOS.CombatSim:OpenToolMenu()
	end
end

function wOS.CombatSim:OpenToolCreateSimulationMenu()
	if not IsValid(self.SimulatorMenu) then self:OpenMenu() end
	
	self.SimulatorMenu.SizeT = { w = w*0.25, h = h*0.15 }
	self.SimulatorMenu.Title = "ADD SIMULATION"
	self.SimulatorMenu:Clear()

	timer.Simple( 0, function() self:AddExitButton( function() wOS.CombatSim:OpenToolMenu() end ) end )

	local rw, rh = self.SimulatorMenu.SizeT.w, self.SimulatorMenu.SizeT.h
	
	-- local nameField = vgui.Create("DPanel", self.SimulatorMenu)
	-- nameField:SetSize( rw*0.4, rh*0.1 )
	-- nameField:SetPos( rw*0.05, rh*0.2 )
	-- nameField.Paint = function( pan, ww, hh )
	-- 	draw.SimpleText("Challenge Name:", "wOS.CombatSim.LeaderFont", 0, hh * 0.5, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
	-- end
	
	-- local nameEntryField = vgui.Create("DTextEntry", self.SimulatorMenu)
	-- nameEntryField:SetSize( rw*0.4, rh*0.1 )
	-- nameEntryField:SetPos( rw*0.05, rh*0.3 )
	-- nameEntryField:SetFont( "wOS.CombatSim.MediumFont" )

	local newbutt = vgui.Create("DButton", self.SimulatorMenu)
	newbutt:SetSize( rw*0.8, rh*0.22 )
	newbutt:SetPos( rw*0.1, rh*0.35 )
	newbutt:SetFont( "wOS.CombatSim.LeaderFont" )
	newbutt:SetText( "Create New" )
	newbutt.DoClick = function( pan )
		net.Start( "wOS.CSS.CreateNewSimulation")
		net.SendToServer()		
		self.SimulatorMenu:ToggleClose()
	end

	local impbutt = vgui.Create("DButton", self.SimulatorMenu)
	impbutt:SetSize( rw*0.8, rh*0.22 )
	impbutt:SetPos( rw*0.1, rh*0.67 )
	impbutt:SetFont( "wOS.CombatSim.LeaderFont" )
	impbutt:SetText( "Import From Existing" )
	impbutt.DoClick = function( pan )
		wOS.CombatSim:OpenToolImportSimulationMenu()
	end
end

function wOS.CombatSim:OpenToolImportSimulationMenu()
	if not IsValid(self.SimulatorMenu) then self:OpenMenu() end
	
	self.SimulatorMenu.SizeT = { w = w*0.25, h = h*0.2 }
	self.SimulatorMenu.Title = "IMPORT SIMULATION"
	self.SimulatorMenu:Clear()

	timer.Simple( 0, function() self:AddExitButton( function() wOS.CombatSim:OpenToolCreateSimulationMenu() end ) end )

	local rw, rh = self.SimulatorMenu.SizeT.w, self.SimulatorMenu.SizeT.h
	
	-- local nameField = vgui.Create("DPanel", self.SimulatorMenu)
	-- nameField:SetSize( rw*0.4, rh*0.1 )
	-- nameField:SetPos( rw*0.05, rh*0.2 )
	-- nameField.Paint = function( pan, ww, hh )
	-- 	draw.SimpleText("Challenge Name:", "wOS.CombatSim.LeaderFont", 0, hh * 0.5, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
	-- end
	
	-- local nameEntryField = vgui.Create("DTextEntry", self.SimulatorMenu)
	-- nameEntryField:SetSize( rw*0.4, rh*0.1 )
	-- nameEntryField:SetPos( rw*0.05, rh*0.3 )
	-- nameEntryField:SetFont( "wOS.CombatSim.MediumFont" )

	local evbutt = vgui.Create("DButton", self.SimulatorMenu)
	evbutt:SetSize( rw*0.8, rh*0.15 )
	evbutt:SetPos( rw*0.1, rh*0.26 )
	evbutt:SetFont( "wOS.CombatSim.LeaderFont" )
	evbutt:SetText( "Import From Event" )
	evbutt.DoClick = function( pan )
		wOS.PES.GetImportableEvents( function( events )
			wOS.CombatSim:OpenToolPreImportMenu( events, false )
		end )
	end

	local newbutt = vgui.Create("DButton", self.SimulatorMenu)
	newbutt:SetSize( rw*0.8, rh*0.15 )
	newbutt:SetPos( rw*0.1, rh*0.5 )
	newbutt:SetFont( "wOS.CombatSim.LeaderFont" )
	newbutt:SetText( "Import From Simulator" )
	newbutt.DoClick = function( pan )
		wOS.PES.GetImportableSimulations( function( events )
			wOS.CombatSim:OpenToolPreImportMenu( events, true, true )
		end )
	end

	local impbutt = vgui.Create("DButton", self.SimulatorMenu)
	impbutt:SetSize( rw*0.8, rh*0.15 )
	impbutt:SetPos( rw*0.1, rh*0.74 )
	impbutt:SetFont( "wOS.CombatSim.LeaderFont" )
	impbutt:SetText( "Import From URL" )
	impbutt.DoClick = function( pan )
		wOS.CombatSim:OpenToolURLImportMenu()
	end

end

function wOS.CombatSim:OpenToolURLImportMenu()
	if not IsValid(self.SimulatorMenu) then self:OpenMenu() end
	
	self.SimulatorMenu.SizeT = { w = w*0.25, h = h*0.4 }
	self.SimulatorMenu.Title = "IMPORT FROM URL"
	self.SimulatorMenu:Clear()

	timer.Simple( 0, function() self:AddExitButton( function() wOS.CombatSim:OpenToolImportSimulationMenu() end ) end )

	local rw, rh = self.SimulatorMenu.SizeT.w, self.SimulatorMenu.SizeT.h
	
	-- local nameField = vgui.Create("DPanel", self.SimulatorMenu)
	-- nameField:SetSize( rw*0.4, rh*0.1 )
	-- nameField:SetPos( rw*0.05, rh*0.2 )
	-- nameField.Paint = function( pan, ww, hh )
	-- 	draw.SimpleText("Challenge Name:", "wOS.CombatSim.LeaderFont", 0, hh * 0.5, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
	-- end
	
	-- local nameEntryField = vgui.Create("DTextEntry", self.SimulatorMenu)
	-- nameEntryField:SetSize( rw*0.4, rh*0.1 )
	-- nameEntryField:SetPos( rw*0.05, rh*0.3 )
	-- nameEntryField:SetFont( "wOS.CombatSim.MediumFont" )

	local evbutt = vgui.Create("DPanel", self.SimulatorMenu)
	evbutt:SetSize( rw*0.8, rh*0.75 )
	evbutt:SetPos( rw*0.1, rh*0.13 )
	evbutt.Paint = function( pan, ww, hh )
		local text = "Input a URL below that leads DIRECTLY to the exported event text\n\n----------WARNING---------- \nVERIFY THAT ALL SOURCES ARE COMPLETELY TRUSTED BEFORE IMPORTING AN EVENT!"
		text = wOS.PES.WrapText( text, "wOS.CombatSim.LeaderFont", ww*0.95 )
		draw.DrawText(text, "wOS.CombatSim.LeaderFont", ww/2, 0, color_white, TEXT_ALIGN_CENTER )
	end

	local newbutt = vgui.Create("DTextEntry", self.SimulatorMenu)
	newbutt:SetSize( rw*0.8, rh*0.075 )
	newbutt:SetPos( rw*0.1, rh*0.8 )
	newbutt:SetFont( "wOS.CombatSim.LeaderFont" )
	newbutt:SetText( "INPUT URL HERE" )

	local impbutt = vgui.Create("DButton", self.SimulatorMenu)
	impbutt:SetSize( rw*0.8, rh*0.075 )
	impbutt:SetPos( rw*0.1, rh*0.9 )
	impbutt:SetFont( "wOS.CombatSim.LeaderFont" )
	impbutt:SetText( "IMPORT" )
	impbutt.DoClick = function( pan )
		local text = newbutt:GetText()
		if #text < 1 then return end
		wOS.PES.RequestURLImport(text, function( data ) 
			wOS.CombatSim:OpenSimulationImported( data )
		end )
	end

end

function wOS.CombatSim:OpenSimulationImported( simdata )
	local sim_struct = {}

	if not simdata.Event then
		if simdata.Nodes then
			sim_struct.Event = table.Copy( simdata )
		end
	else
		sim_struct = simdata
	end

	wOS.CombatSim:OpenSimulationEditor( sim_struct, true ) //Second argument is dirty which is always true for imports
end

function wOS.CombatSim:CreateSettingsList(innerframe, customSettings, settings, rw, rh)
	for name, setting in pairs(customSettings) do
		local objectPanel = innerframe:CreatePanel("DPanel")
		objectPanel.Paint = function( pan, ww, hh )
			local background = {
				{ x = 0           , y = hh*0.05 },
				{ x = 0  + hh*0.05, y = 0       },
				{ x = ww - hh*0.05, y = 0       },
				{ x = ww          , y = hh*0.05 },
				{ x = ww          , y = hh*0.95 },
				{ x = ww - hh*0.05, y = hh      },
				{ x = 0  + hh*0.05, y = hh      },
				{ x = 0           , y = hh*0.95 },		
			}
			draw.NoTexture()
			surface.SetDrawColor( wOS.CombatSim.FrameColor )
			surface.DrawPoly( background )		
			DrawBlur( pan, 1 )

			draw.SimpleText(name, "wOS.CombatSim.MediumFont", rw*0.01, rh*0.005, white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
		end

		table.insert(innerframe.ObjectPanels, objectPanel)

		local settingType = setting
		local minCount
		local maxCount
		local values = {}
		local default

		if istable(setting) then
			settingType = setting.Type
			minCount = setting.MinCount
			maxCount = setting.MaxCount
			values = setting.Values
			default = setting.Default
			if isfunction(values) then
				values = values()
			end
		end

		objectPanel.SettingName = name
		local value = settings[name]

		if settingType == WOS_CSS.CONFIG.BOOL then
			objectPanel.Value = value
			if objectPanel.Value == nil then
				objectPanel.Value = default or false
			end

			local button = vgui.Create("DButton", objectPanel)
			button:SetSize( rw*0.3, rh*0.05 )
			button:SetPos( rw*0.55, rh*0.05 )
			button:SetFont( "wOS.CombatSim.LeaderFont" )
			button:SetText( objectPanel.Value and "Yes" or "No" )
			button.DoClick = function(pan)
				objectPanel.Value = not objectPanel.Value
				pan:SetText( objectPanel.Value and "Yes" or "No" )
			end
		elseif settingType == WOS_CSS.CONFIG.NUMBER then
			objectPanel.Value = value or default or 0

			local wang = vgui.Create("DNumberWang", objectPanel)
			wang:SetSize( rw*0.3, rh*0.05 )
			wang:SetPos( rw*0.55, rh*0.05 )
			wang:SetFont( "wOS.CombatSim.LeaderFont" )
			wang:SetMin( minCount or 0 )
			wang:SetMax( maxCount or math.huge )
			wang:SetValue( objectPanel.Value )
			wang.Think = function( pan )
				objectPanel.Value = pan:GetValue()
			end
		elseif settingType == WOS_CSS.CONFIG.NSLIDER then
			objectPanel.Value = value or default or 0

			local panel = vgui.Create("DPanel", objectPanel)
			panel:SetSize( rw*0.3, rh*0.05 )
			panel:SetPos( rw*0.55, rh*0.05 )

			local slider = vgui.Create("DNumSlider", objectPanel)
			slider:SetSize( rw*0.45, rh*0.05 )
			slider:SetPos( rw*0.4, rh*0.05 )
			slider:SetMin( minCount or 0)
			slider:SetMax( maxCount or 10)
			slider:SetDecimals(0)
			slider:SetValue( objectPanel.Value )
			slider.Think = function( pan )
				pan:SetValue(math.Round(pan:GetValue()))
				objectPanel.Value = pan:GetValue()
			end
		elseif settingType == WOS_CSS.CONFIG.NSLIDERTOGGLE then
			if isbool( value ) && value == false then
				objectPanel.Value = false
			else
				objectPanel.Value = value or default or false
			end

			local panel = vgui.Create("DPanel", objectPanel)
			panel:SetSize( rw*0.3, rh*0.05 )
			panel:SetPos( rw*0.55, rh*0.05 )

			local slider = vgui.Create("DNumSlider", objectPanel)
			slider:SetSize( rw*0.45, rh*0.05 )
			slider:SetPos( rw*0.4, rh*0.05 )
			slider:SetMin( minCount or 0)
			slider:SetMax( maxCount or 10)
			slider:SetDecimals(0)

			local checkBox = vgui.Create("DCheckBox", objectPanel)
			checkBox:SetSize( rh*0.05, rh*0.05 )
			checkBox:SetPos( rw*0.55 - rh*0.1, rh*0.05 )

			if isbool(objectPanel.Value) and objectPanel.Value == false then
				checkBox:SetChecked(false)
				slider:SetValue( minCount )
				slider:SetMouseInputEnabled(false)
			else
				checkBox:SetChecked(true)
				slider:SetValue( objectPanel.Value )
			end
			
			function panel:Paint(ww, hh)
				if checkBox:GetChecked() then
					draw.RoundedBox(0, 0, 0, ww, hh, Color(255, 255, 255, 255))
				else
					draw.RoundedBox(0, 0, 0, ww, hh, Color(127, 127, 127, 127))
				end
			end
			
			slider.Think = function( pan )
				if checkBox:GetChecked() then
					pan:SetValue(math.Round(pan:GetValue()))
					objectPanel.Value = pan:GetValue()
					pan:SetMouseInputEnabled(true)
				else
					objectPanel.Value = false
					pan:SetMouseInputEnabled(false)
				end
			end
		elseif settingType == WOS_CSS.CONFIG.STRING then
			objectPanel.Value = value or default or ""

			local entry = vgui.Create("DTextEntry", objectPanel)
			entry:SetSize( rw*0.6, rh*0.05 )
			entry:SetPos( rw*0.25, rh*0.05 )
			entry:SetFont( "wOS.CombatSim.SmallFont" )
			entry:SetValue( objectPanel.Value )
			entry.Think = function( pan )
				objectPanel.Value = pan:GetValue()
			end
		elseif settingType == WOS_CSS.CONFIG.SDROPDOWN then
			objectPanel.Value = value or default or ""

			local comboBox = vgui.Create("DComboBox", objectPanel)
			comboBox:SetSize( rw*0.3, rh*0.05 )
			comboBox:SetPos( rw*0.55, rh*0.05 )
			comboBox:SetFont( "wOS.CombatSim.LeaderFont" )
			comboBox:SetValue( objectPanel.Value )
			for _, choice in pairs(values) do
				comboBox:AddChoice(choice)
			end
			comboBox.OnSelect = function( pan, index, value )
				objectPanel.Value = value
			end
		elseif settingType == WOS_CSS.CONFIG.COLOR then
			-- TODO: Implement Color Selector UI (Problem: Height)
		elseif settingType == WOS_CSS.CONFIG.MTABLE then
			objectPanel.Value = value or default or {}

			local listView = vgui.Create("DListView", objectPanel)
			listView:SetSize( rw*0.45, rh*0.1 )
			listView:SetPos( rw*0.4, 0 )
			listView:SetHeaderHeight(rh*0.02)
			listView:SetDataHeight(rh * 0.02)
			listView:AddColumn("Weapons")
			listView:SetMultiSelect(true)
			for _, weapon in pairs(weapons.GetList()) do
				if weapon.Spawnable then
					local line = listView:AddLine(weapon.ClassName)
					line:SetSelected(table.HasValue(objectPanel.Value, weapon.ClassName))
				end
			end
			function listView:OnRowRightClick(index, line)
                line:SetSelected(false)

				table.RemoveByValue(objectPanel.Value, line:GetValue(1))
			end
			function listView:OnRowSelected(index, line)
				line:SetSelected(true)

				table.insert(objectPanel.Value, line:GetValue(1))
				
				for k, line in pairs(self:GetLines()) do
					line:SetSelected(table.HasValue(objectPanel.Value, line:GetValue(1)))
				end
			end
		end
	end
end


function wOS.CombatSim:OpenToolPreImportMenu( events, is_sim, imported )
	if not IsValid(self.SimulatorMenu) then self:OpenMenu() end

	self.SimulatorMenu.SizeT = { w = w*0.43, h = h*0.66 }
	self.SimulatorMenu.Title = "IMPORT SELECTION"
	self.SimulatorMenu:Clear()

	timer.Simple( 0, function() self:AddExitButton( function() wOS.CombatSim:OpenToolImportSimulationMenu() end ) end )

	local rw, rh = self.SimulatorMenu.SizeT.w, self.SimulatorMenu.SizeT.h

	local innerframe = vgui.Create( "WOS_CSS_ScrollPanel", self.SimulatorMenu )
	innerframe.XScroll = false
	innerframe:SetSize( rw*0.95, rh*0.8 )
	innerframe:SetPos( rw*0.025, rh*0.1 )
	innerframe:SetPanelSize(rw * 0.85, rh * 0.1)
	innerframe:SetPanelSpacing(rw * 0.05)
	innerframe.Paint = function( pan, ww, hh )
		local background = {
			{ x = 0           , y = hh*0.05 },
			{ x = 0  + hh*0.05, y = 0       },
			{ x = ww - hh*0.05, y = 0       },
			{ x = ww          , y = hh*0.05 },
			{ x = ww          , y = hh*0.95 },
			{ x = ww - hh*0.05, y = hh      },
			{ x = 0  + hh*0.05, y = hh      },
			{ x = 0           , y = hh*0.95 },		
		}
		draw.NoTexture()
		surface.SetDrawColor( wOS.CombatSim.BackgroundColor )
		surface.DrawPoly( background )		
		DrawBlur( pan, 1 )
	end

	innerframe.ObjectPanels = {}

	for _, data in pairs( events ) do
		local objectPanel = innerframe:CreatePanel("DPanel")
		objectPanel.Data = data
		objectPanel.Paint = function( pan, ww, hh )
			draw.RoundedBox( hh*0.1, 0, 0, ww, hh, wOS.CombatSim.FrameColor )
			DrawBlur( pan, 1 )

			draw.SimpleText(pan.Data.Name, "wOS.CombatSim.MediumFont", ww*0.01, hh*0.005, white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
			
			if pan.Data.Simulator then
				draw.SimpleText( pan.Data.Simulator, "wOS.CombatSim.SmallFont",  ww*0.99, hh*0.005, white, TEXT_ALIGN_RIGHT, TEXT_ALIGN_TOP)
			end

			local word = wOS.PES.WrapText( pan.Data.Description, "wOS.CombatSim.DescFont", ww*0.8 )
			draw.DrawText( word, "wOS.CombatSim.DescFont", ww*0.01, hh*0.37, color_white, TEXT_ALIGN_LEFT ) 		
		
		end

		table.insert(innerframe.ObjectPanels, objectPanel)

		local ow, oh = objectPanel:GetSize()
		local button = vgui.Create("DButton", objectPanel)
		button:SetSize( ow*0.15, oh*0.45 )
		button:SetPos( ow*0.85, oh*0.55 )
		button.Data = data
		button:SetFont( "wOS.CombatSim.LeaderFont" )
		button:SetText( "Select" )
		button.DoClick = function(pan)
			wOS.CombatSim:OpenMenu()
			if is_sim then
				wOS.PES.RequestSimulationData(pan.Data.Name, function( simdata )
					wOS.CombatSim:OpenSimulationEditor( simdata, true, imported )
				end, pan.Data.ID )
			else
				wOS.PES.RequestEventData(pan.Data.Name, function( simdata )
					wOS.CombatSim:OpenSimulationEditor( simdata, true, imported )
				end )
			end
		end
		
	end

	return self.SimulatorMenu
end






















local white = Color(255, 255, 255)
local green = Color(0, 255, 0)
local cyan = Color(0, 255, 255)

local function DrawBorders(points, height, color)
	local prev = nil
	local prevtop = nil
	local first = nil
	local firsttop = nil

	for _, vec in pairs(points) do
		if not first then first = vec end

		local top = Vector(vec.x, vec.y, first.z + height)
		vec.z = first.z
		if not firsttop then firsttop = top end

		render.DrawLine(vec, top, color, false)

		if prev then
			render.DrawLine(vec, prev, color, false)
		end
		
		if prevtop then
			render.DrawLine(top, prevtop, color, false)
		end

		prevtop = top
		prev = vec
	end

	if prev and first then 
		render.DrawLine(prev, first, color, false)
	end
	if prevtop and firsttop then
		render.DrawLine(prevtop, firsttop, color, false)
	end
end

local function DrawPoints(points)
	local ply = LocalPlayer()
	local plyPos = ply:GetPos()
	
	local dx = ply:GetUp()
	local dy = ply:GetRight()

	local closest
	local disT = math.huge
	local hPos = ply:GetEyeTrace().HitPos
	for i, point in pairs(points or {}) do
		local dis = point.Position:Distance(hPos)
		if dis < disT then
			closest = i
			disT = dis
		end
	end

	local angle = dx:AngleEx(dx:Cross(-dy))
	angle:RotateAroundAxis(ply:GetForward(), 90)

	for i, point in pairs(points or {}) do
		local pos = point.Position
		local name = point.Name

		local textPos = pos + Vector(0, 0, 100)

		local color = white
		if i == closest then
			color = green
		end

		render.DrawLine(pos, textPos, color, false)

		cam.Start3D2D(textPos, angle, 1)
			draw.SimpleText(name or "Missing", "DermaDefault", 0, 0, color, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM)
		cam.End3D2D()   
	end
end

hook.Add( "PostDrawOpaqueRenderables", "wOS.CombatSim.ToolVisualization", function()
	local ply = LocalPlayer()

	local weapon = ply:GetActiveWeapon()
	if not (IsValid(weapon) and weapon:GetClass() == "wos_simulation_tool") then return end
	
	local simulator = weapon:GetSelectedSimulator()
	if simulator == weapon then return end
	
	if IsValid(simulator) then
		-- Draw Current Operation Overlay
		local mode = weapon:GetToolMode()
		local step = weapon:GetToolStep()

		if mode == WOS_CSS.MODE.AREASELECT then
			local corners = table.Copy(weapon.SelectedBorderPoints)
			local height = weapon.SelectedHeight
			
			if step == WOS_CSS.AREASELECT.BORDER then
				table.insert(corners, ply:GetEyeTrace().HitPos)
			elseif step == WOS_CSS.AREASELECT.HEIGHT then
				height = ply:GetEyeTrace().HitPos.z - corners[1].z
				DrawBorders(corners, height, green)
			end
			
			DrawBorders(corners, weapon.SelectedHeight, white)
		else
			local borderPointCount = simulator:GetBorderPointCount()

			if borderPointCount and borderPointCount > 0 then
				local corners = {}
				for i=1, borderPointCount do
					local v = simulator:GetNW2Vector("BorderPoint" .. i)
					table.insert(corners, v)
				end

				local inside
				if mode == WOS_CSS.MODE.POINTSELECT then
					inside = simulator:CheckInBorders(ply:GetEyeTrace().HitPos + Vector(0, 0, 10)) -- Offset because the floor isn't 100% inside.
				else
					inside = simulator:CheckInBorders(EyePos())
				end

				DrawBorders(corners, simulator:GetBorderHeight(), inside and green or cyan)
			end
		end
	end
	

end)

hook.Add("PreDrawHalos", "wOS.CombatSim.PreDrawHalos", function()
	local ply = LocalPlayer()

	local weapon = ply:GetActiveWeapon()
	if not (IsValid(weapon) and weapon:GetClass() == "wos_simulation_tool") then return end

	local simulator = weapon:GetSelectedSimulator()
	if simulator == weapon then return end
	
	if IsValid(simulator) then
		halo.Add({simulator}, cyan, 5)
	end
end)
--addons/wos-passiveevent/lua/wos/css/entities/wos_simulation_tool/sh_wos_simulation_tool.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2019
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--


--addons/wos-passiveevent/lua/wos/css/entities/wos_pes_basicobj/cl_wos_pes_basicobj.lua:
local ENT = {}

ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.RenderGroup = RENDERGROUP_BOTH

ENT.PrintName		= "Generic Objective"
ENT.Author			= "wiltOS Technologies"
ENT.Contact			= "N/A"
ENT.Purpose			= "PES B"
ENT.Instructions	= "Grab and run"
ENT.Spawnable = false

function ENT:SetupDataTables()
    self:NetworkVar( "Entity", 0, "TargetPlayer" )
    self:NetworkVar( "String", 0, "FlagName" )

    if SERVER then
        self:SetTargetPlayer( NULL )
        self:SetFlagName( "Flag" )
    end
end

function ENT:Initialize()
	self:SetRenderBounds( vector_origin, vector_origin, Vector( 100, 100, 100 ) )
	self.HookName = "wOS.PES.FlagHalo." .. self:EntIndex()
	hook.Add("PreDrawHalos", self.HookName, function()
		if not IsValid( self ) then 
			hook.Remove( "PreDrawHalos", self.HookName )
			return
		end
		if !IsValid( self:GetTargetPlayer() ) then return end
		halo.Add( {self:GetTargetPlayer()}, Color( 255, 0, 0 ), 5, 5, 1 )
	end)

end

function ENT:OnRemove()
	hook.Remove( "PreDrawHalos", self.HookName )
end

function ENT:Draw()

	if IsValid(self:GetTargetPlayer()) then return end
	self:DrawModel()

end

function ENT:DrawTranslucent()
	if IsValid(self:GetTargetPlayer()) then return end

	local ang = EyeAngles()
	ang.p = 90
	ang.y = ang.y + 180
	ang.r = 0
	ang:RotateAroundAxis( ang:Up(), 90 )

	local mins, maxs = self:OBBMins(), self:OBBMaxs()
	local diff = maxs.z - mins.z

	cam.Start3D2D( self:GetPos() + self:GetUp()*diff*1.2, ang, 0.1 )
		draw.SimpleText( self:GetFlagName(), "wOS.PES.3DFont", 0, 0, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	cam.End3D2D()
end

scripted_ents.Register(ENT, "wos_pes_basicobj")
--addons/sui/lua/sui/vgui/sui_combobox.lua:
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local TEXT_FONT = SUI.CreateFont("ComboBox", "Roboto Regular", 16)

local GetColor = SUI.GetColor
local draw_material = sui.draw_material

local PANEL = {}

PANEL.NoOverrideClear = true

sui.scaling_functions(PANEL)

function PANEL:Init()
	self:ScaleInit()
	self.DropButton:Remove()
	self:SetFont(TEXT_FONT)
	self:SetSize(34, 22)
	self:SetIsMenu(true)

	local image = self:Add(NAME .. ".Image")
	image:Dock(FILL)
	image:SetImage("https://raw.githubusercontent.com/Srlion/Addons-Data/main/icons/sui/arrow.png")
	image.Draw = self.Paint
end

function PANEL:OpenMenu(pControlOpener)
	if pControlOpener and pControlOpener == self.TextEntry then return end
	if #self.Choices == 0 then return end

	if IsValid(self.Menu) then
		self.Menu:Remove()
		self.Menu = nil
	end

	self.Menu = vgui.Create(NAME .. ".Menu", self)
	self.Menu:SetInternal(self)

	for k, v in ipairs(self.Choices) do
		self.Menu:AddOption(v, function()
			self:ChooseOption(v, k)
		end)
	end

	local x, y = self:LocalToScreen(0, self:GetTall())
	self.Menu:SetMinimumWidth(self:GetWide())
	self.Menu:Open(x, y, false, self)
end

function PANEL:Paint(w, h, from_image)
	local text_color = GetColor("menu_option_hover_text")

	if from_image then
		local size = SUI.ScaleEven(10)
		draw_material(nil, w - (size / 2) - 6, h / 2, size, text_color)
	else
		local col = GetColor("menu")
		self:RoundedBox("Background", 4, 0, 0, w, h, col)
		self:SetTextColor(text_color)
	end
end

function PANEL:PerformLayout()
end

sui.register("ComboBox", PANEL, "DComboBox")
--addons/sui/lua/sui/vgui/sui_frame.lua:
local math = math
local gui = gui
local draw = draw
local surface = surface

local ScrW = ScrW
local ScrH = ScrH
local IsValid = IsValid
local ipairs = ipairs

local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name
local TDLib = sui.TDLib

local FRAME_FONT = SUI.CreateFont("Frame", "Roboto", 18)

local Panel = FindMetaTable("Panel")

local PANEL = {}

AccessorFunc(PANEL, "m_bHeaderHeight", "HeaderHeight", FORCE_NUMBER)
AccessorFunc(PANEL, "m_bTitleFont", "TitleFont", FORCE_STRING)
AccessorFunc(PANEL, "m_bSizable", "Sizable", FORCE_BOOL)
AccessorFunc(PANEL, "m_iMinWidth", "MinWidth", FORCE_NUMBER)
AccessorFunc(PANEL, "m_iMinHeight", "MinHeight", FORCE_NUMBER)

local header_Think = function(s)
	local parent = s.parent
	local sw, sh = ScrW(), ScrH()

	if s.dragging then
		local x, y = input.GetCursorPos()
		x, y = math.Clamp(x, 1, sw - 1), math.Clamp(y, 1, sh - 1)
		x, y = x - s.dragging[1], y - s.dragging[2]

		parent:SetPos(x, y)
		parent:InvalidateLayout(true)
		parent:OnPosChanged()
	else
		local x, y, w, h = parent:GetBounds()
		parent:SetPos(math.Clamp(x, 5, sw - w - 5), math.Clamp(y, 5, sh - h - 5))
	end
end

local header_OnMousePressed = function(s)
	local parent = s.parent
	s.dragging = {gui.MouseX() - parent.x, gui.MouseY() - parent.y}
	s:MouseCapture(true)
end

local header_OnMouseReleased = function(s)
	s.dragging = nil
	s:MouseCapture(false)
end

local title_SetBGColor = function(s, c)
	s:SetVisible(c and true or false)
end

local title_update_color = function(s)
	s:SetTextColor(SUI.GetColor("title"))
end

local close_DoClick = function(s)
	s.frame:Remove()
end

function PANEL:Init()
	local header_buttons = {}
	self.header_buttons = header_buttons

	self:Center()
	self:SetHeaderHeight(28)

	local header = self:Add("PANEL")
	header:Dock(TOP)
	header.Paint = self.HeaderPaint
	header:SetCursor("sizeall")

	header.parent = self
	header.Think = header_Think
	header.OnMousePressed = header_OnMousePressed
	header.OnMouseReleased = header_OnMouseReleased
	self.header = header

	local title = header:Add(NAME .. ".Label")
	title:Dock(LEFT)
	title:DockMargin(6, 2, 0, 2)
	title:SetText("")
	title:SetTextColor(SUI.GetColor("title"))
	title:SizeToContents()
	title.SetBGColor = title_SetBGColor
	hook.Add(NAME .. ".ThemeChanged", title, title_update_color)
	self.title = title

	self.close = self:AddHeaderButton("https://raw.githubusercontent.com/Srlion/Addons-Data/main/icons/sui/close.png", "close", close_DoClick)
	self.close.frame = self

	self:SetSize(SUI.Scale(520), SUI.Scale(364))
	self:SetTitleFont(FRAME_FONT)
	SUI.OnScaleChanged(self, self.ScaleChanged)

	function self:PerformLayout(w, h)
		if IsValid(title) then
			title:SizeToContents()
		end

		if IsValid(header) then
			header:SetTall(SUI.Scale(self:GetHeaderHeight()))
		end

		for k, v in ipairs(header_buttons) do
			if IsValid(v) then
				v:SetWide(v:GetTall())
				local margin = SUI.Scale(4)
				v.image:DockMargin(margin, margin, margin, margin)
			end
		end
	end
end

function PANEL:SetSize(w, h)
	self.real_w, self.real_h = w, h
	self:ScaleChanged()
end

function PANEL:HeaderPaint(w, h)
	draw.RoundedBoxEx(3, 0, 0, w, h, SUI.GetColor("header"), true, true)
end

local SetSize = Panel.SetSize
PANEL.RealSetSize = SetSize
function PANEL:ScaleChanged()
	if self.sizing then return end

	local new_w, new_h = SUI.Scale(self.real_w), SUI.Scale(self.real_h)
	self.x, self.y = self.x + (self:GetWide() / 2 - new_w / 2), self.y + (self:GetTall() / 2 - new_h / 2)
	SetSize(self, new_w, new_h)
	self:InvalidateLayout(true)
end

function PANEL:Paint(w, h)
	if SUI.GetColor("frame_blur") then
		TDLib.BlurPanel(self)
	end

	self:RoundedBox("Background", 3, 0, 0, w, h, SUI.GetColor("frame"))
end

function PANEL:SetTitleFont(font)
	self.m_bTitleFont = font
	self.title:SetFont(font)
end

function PANEL:SetTitle(text)
	self.title:SetText(text)
	self.title:SizeToContents()
end

function PANEL:AddHeaderButton(image_name, name, callback)
	local button = self.header:Add("DButton")
	button:SetText("")
	button:Dock(RIGHT)
	button:DockMargin(0, 2, #self.header:GetChildren() == 1 and 4 or 2, 2)

	local hover = name .. "_hover"
	local press = name .. "_press"
	local circle = {}
	button.Paint = function(s, w, h)
		if s:IsHovered() then
			TDLib.DrawCircle(circle, w / 2, h / 2, w / 2, SUI.GetColor(hover))
		end

		if s.Depressed then
			TDLib.DrawCircle(circle, w / 2, h / 2, w / 2, SUI.GetColor(press))
		end
	end
	button.DoClick = callback

	local image = button:Add(NAME .. ".Image")
	image:Dock(FILL)
	image:SetMouseInputEnabled(false)
	image:SetImage(image_name)

	button.image = image

	table.insert(self.header_buttons, button)

	return button
end

function PANEL:OnMousePressed(_, checking)
	if not self.m_bSizable then return end

	local x, y = self:LocalToScreen(0, 0)
	local w, h = self:GetSize()
	if gui.MouseX() > (x + w - 20) and gui.MouseY() > (y + h - 20) then
		if not checking then
			self.sizing = {gui.MouseX() - w, gui.MouseY() - h}
			self:MouseCapture(true)
		end

		self:SetCursor("sizenwse")

		return
	end

	if checking then
		self:SetCursor("arrow")
	end
end

function PANEL:OnMouseReleased()
	if not self.m_bSizable then return end

	self:MouseCapture(false)
	SUI.CallScaleChanged()
	self.sizing = nil
end

function PANEL:Think()
	if not self.m_bSizable then return end

	self:OnMousePressed(nil, true)

	if not self.sizing then return end

	local sw, sh = ScrW(), ScrH()

	local cx, cy = input.GetCursorPos()
	local mousex = math.Clamp(cx, 1, sw - 1)
	local mousey = math.Clamp(cy, 1, sh - 1)

	local x = mousex - self.sizing[1]
	x = math.Clamp(x, self.m_iMinWidth, sw - 10)

	local y = mousey - self.sizing[2]
	y = math.Clamp(y, self.m_iMinHeight, sh - 10)

	self.real_w, self.real_h = x, y
	SetSize(self, x, y)
	self:InvalidateLayout(true)
	self:SetCursor("sizenwse")
end

function PANEL:OnPosChanged()
end

local SetVisible = Panel.SetVisible
local Remove = Panel.Remove

local anim_speed = 0.2

local show = function(s)
	local w, h = s.real_w, s.real_h

	if s.anim_scale then
		w, h = SUI.Scale(w), SUI.Scale(h)
	end

	SetVisible(s, true)

	SetSize(s, w * 1.1, h * 1.1)
	s:Center()

	s:Stop()
	s:SizeTo(w, h, anim_speed, 0, -1)
	s:MoveTo((ScrW() / 2) - (w / 2), (ScrH() / 2) - (h / 2), anim_speed, 0, -1)
	s:AlphaTo(255, anim_speed + 0.02, 0)
	s:MakePopup()
end

local remove = function(s, hide)
	if not hide and not s:IsVisible() then
		Remove(s)
		return
	end

	local w, h = s.real_w, s.real_h

	if s.anim_scale then
		w, h = SUI.Scale(w), SUI.Scale(h)
	end

	w, h = w * 1.1, h * 1.1

	s:Stop()
	s:SizeTo(w, h, anim_speed, 0, -1)
	s:MoveTo((ScrW() / 2) - (w / 2), (ScrH() / 2) - (h / 2), anim_speed, 0, -1)
	s:SetMouseInputEnabled(false)
	s:SetKeyboardInputEnabled(false)
	s:AlphaTo(0, anim_speed + 0.02, 0, function()
		if hide then
			SetVisible(s, false)
		else
			Remove(s)
		end
	end)
end

local hide = function(s)
	remove(s, true)
end

function PANEL:AddAnimations(w, h, no_scale)
	self.anim_scale = not no_scale
	self.real_w, self.real_h = w, h

	self:SetAlpha(0)
	show(self)

	self.Remove = remove
	self.Hide = hide
	self.Show = show
end

sui.register("Frame", PANEL, "EditablePanel")
--addons/sui/lua/sui/libs/png_encoder.lua:
local string = string
local table = table
local bit = bit

local char = string.char
local byte = string.byte

local insert = table.insert
local concat = table.concat

local bor = bit.bor
local bxor = bit.bxor
local band = bit.band
local bnot = bit.bnot
local lshift = bit.lshift
local rshift = bit.rshift

local ceil = math.ceil

local SIGNATURE = char(137, 80, 78, 71, 13, 10, 26, 10)

local crc_table = {}; do
	local n = 0
	while n < 256 do
		local c = n
		local k = 0
		while k < 8 do
			if band(c, 1) ~= 0 then
				c = bxor(0xedb88320, rshift(c, 1))
			else
				c = rshift(c, 1)
			end
			k = k + 1
		end
		crc_table[n + 1] = c
		n = n + 1
	end
end

local crc = function(buf)
	local c = 0xffffffff
	for i = 1, #buf do
		c = bxor(crc_table[band(bxor(c, byte(buf, i)), 0xff) + 1], rshift(c, 8))
	end
	return bxor(c, 0xffffffff)
end

local dword_as_string = function(dword)
	return char(
		rshift(band(dword, 0xff000000), 24),
		rshift(band(dword, 0x00ff0000), 16),
		rshift(band(dword, 0x0000ff00), 8),
		band(dword, 0x000000ff)
	)
end

local create_chunk = function(type, data, length)
	local CRC = crc(type .. data)
	return concat({
		dword_as_string(length or #data),
		type,
		data,
		dword_as_string(CRC)
	}, "", 1, 4)
end

local create_IHDR; do
	local ARGS = (
		-- bit depth
		char(8) ..
		-- color type: 6=truecolor with alpha
		char(6) ..
		-- compression method: 0=deflate, only allowed value
		char(0) ..
		-- filtering: 0=adaptive, only allowed value
		char(0) ..
		-- interlacing: 0=none
		char(0)
	)

	create_IHDR = function(w, h)
		return create_chunk("IHDR", concat({
			dword_as_string(w),
			dword_as_string(h),
			ARGS
		}, "", 1, 3), 13)
	end
end

local deflate_pack; do
	local BASE = 6552
	local NMAX = 5552
	local adler32 = function(str)
		local s1 = 1
		local s2 = 0
		local n = NMAX

		for i = 1, #str do
			s1 = s1 + byte(str, i)
			s2 = s2 + s1

			n = n - 1
			if n == 0 then
				s1 = s1 % BASE
				s2 = s2 % BASE
				n = NMAX
			end
		end

		s1 = s1 % BASE
		s2 = s2 % BASE

		return bor(lshift(s2, 16), s1)
	end

	local splitChunks = function(chunk, chunkSize)
		local len = ceil(#chunk / chunkSize)
		local ret = {}
		for i = 1, len do
			ret[i - 1] = chunk:sub(((i - 1) * chunkSize) + 1, chunkSize)
		end
		return ret
	end

	deflate_pack = function(str)
		local ret = {"\x78\x9c"}

		local chunks = splitChunks(str, 0xFFFF)
		local len = #chunks

		local i = 0
		while i < (len + 1) do
			local chunk = chunks[i]
			local chunk_n = #chunk

			insert(ret, i < len and "\x00" or "\x01")
			insert(ret, char(band(chunk_n, 0xff), band(rshift(chunk_n, 8), 0xff)))
			insert(ret, char(band(bnot(chunk_n), 0xff), band(rshift(bnot(chunk_n), 8), 0xff)))
			insert(ret, chunk)
			i = i + 1
		end

		local t = adler32(str)
		t = char(
			band(rshift(t, 24), 0xff),
			band(rshift(t, 16), 0xff),
			band(rshift(t, 8), 0xff),
			band(t, 0xff)
		)

		insert(ret, t)

		return concat(ret)
	end
end

local create_IDAT; do
	local slice = function(a, s, e)
		local ret, j = {}, 0
		for i = s, e - 1 do
			ret[j] = char(band(a[i] or 0, 0xFF))
			j = j + 1
		end
		return ret
	end

	local array_split_chunks = function(w, h, array, chunkSize)
		local ret = {}
		local i = 0
		local len = ceil((w * h * 4 + 4) / chunkSize)
		while i < len do
			ret[i] = slice(array, i * chunkSize, (i + 1) * chunkSize)
			i = i + 1
		end
		return ret
	end

	create_IDAT = function(w, h, chunk)
		local scanlines = array_split_chunks(w, h, chunk, w * 4)

		local image_bytes = {}
		for i = 0, #scanlines do
			local scanline = scanlines[i]
			insert(image_bytes, char(band(0, 0xFF)))
			insert(image_bytes, concat(scanline, "", 0, #scanline))
		end
		image_bytes = deflate_pack(concat(image_bytes))

		return create_chunk("IDAT", image_bytes)
	end
end

local IEND = create_chunk("IEND", "", 0)
local to_return = {SIGNATURE, nil, nil, IEND}
local generate_png = function(w, h, chunk)
	local IHDR = create_IHDR(w, h)
	local IDAT = create_IDAT(w, h, chunk)

	to_return[2] = IHDR
	to_return[3] = IDAT

	return concat(to_return, "", 1, 4)
end

return generate_png
--addons/sui/lua/sui/vgui/sui_query_box.lua:
local ScrW, ScrH = ScrW, ScrH
local DisableClipping = DisableClipping
local SetDrawColor = surface.SetDrawColor
local DrawRect = surface.DrawRect
local BlurPanel = sui.TDLib.BlurPanel
local lerp_color = sui.lerp_color

local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local GetColor = SUI.GetColor

local PANEL = {}

function PANEL:SetCallback(callback)
	self.callback = callback
end

function PANEL:Init()
	self:SetSize(0, 0)

	local bottom = self:Add("Panel")
	bottom:Dock(BOTTOM)
	bottom:DockMargin(4, 10, 4, 4)
	bottom:SetZPos(100)

	local save = bottom:Add(NAME .. ".Button")
	save:SetText("SAVE")
	save:Dock(RIGHT)
	save:SetEnabled(false)
	self.save = save

	function save.DoClick()
		self.callback()
		self:Remove()
	end

	local cancel = bottom:Add(NAME .. ".Button")
	cancel:Dock(RIGHT)
	cancel:DockMargin(0, 0, 4, 0)
	cancel:SetContained(false)
	cancel:SetColors(GetColor("query_box_cancel"), GetColor("query_box_cancel_text"))
	cancel:SetText("CANCEL")
	self.cancel = cancel

	function cancel.DoClick()
		self:Remove()
	end

	bottom:SetSize(save:GetWide() * 2 + 4, SUI.Scale(30))

	local body = self:Add("Panel")
	body:Dock(FILL)
	body:DockMargin(4, 4, 4, 4)
	body:DockPadding(3, 3, 3, 3)
	body:InvalidateLayout(true)
	body:InvalidateParent(true)

	local added = 1
	function body.OnChildAdded(s, child)
		added = added + 1
		child:Dock(TOP)
		child:SetZPos(added)
		child:InvalidateLayout(true)
		s:InvalidateLayout(true)
	end
	self.body = body

	function self:Add(name)
		return body:Add(name)
	end

	local old_Paint = self.Paint
	local trans = Color(0, 0, 0, 0)
	local new_col = Color(70, 70, 70, 100)
	function self:Paint(w, h)
		lerp_color(trans, new_col)

		local x, y = self:LocalToScreen(0, 0)
		DisableClipping(true)
			BlurPanel(self)
			SetDrawColor(trans)
			DrawRect(x * -1, y * -1, ScrW(), ScrH())
		DisableClipping(false)

		old_Paint(self, w, h)
	end
end

function PANEL:ChildrenHeight()
	local body = self.body

	self.header:InvalidateLayout(true)
	local height = self.header:GetTall()

	body:InvalidateLayout(true)
	self:InvalidateLayout(true)
	height = height + select(2, body:ChildrenSize())

	height = height + SUI.Scale(30) + 14 + 6

	return height
end

function PANEL:Paint(w, h)
	if GetColor("frame_blur") then
		BlurPanel(self)
	end

	self:RoundedBox("Background", 8, 0, 0, w, h, GetColor("query_box_bg"))
end

function PANEL:Done()
	self:InvalidateChildren(true)

	self.size_to_children = function()
		local h = self:ChildrenHeight()
		self:RealSetSize(self:GetWide(), h)
		self.real_h = h
	end

	self:Center()
	self:MakePopup()
	self:DoModal(true)

	timer.Simple(0.08, function()
		self:AddAnimations(self:GetWide(), self:ChildrenHeight(), true)
	end)
end

sui.register("QueryBox", PANEL, NAME .. ".Frame")
--addons/sui/lua/sui/vgui/sui_toggle_button.lua:
local Lerp = Lerp
local FrameTime = FrameTime

local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name
local TDLib = sui.TDLib

local Panel = {}

sui.scaling_functions(Panel)

function Panel:Init()
	self:ScaleInit()

	local rounded_box = {}
	local switch_circle = {}
	function self:Paint(w, h)
		local is_checked = self:GetChecked()

		local _h = SUI.Scale(14)
		TDLib.RoundedBox(rounded_box, _h, 0, h / 2 - _h / 2, w, _h, is_checked and SUI.GetColor("toggle_button_active") or SUI.GetColor("toggle_button"))

		local size = h - 2
		do
			local pos = is_checked and (w - (size / 2)) or (h / 2 - 1)
			if self.pos then
				self.pos = Lerp(FrameTime() * 12, self.pos, pos)
			else
				self.pos = pos
			end
		end

		TDLib.DrawCircle(switch_circle, self.pos, h / 2, size / 2, is_checked and SUI.GetColor("toggle_button_switch_active") or SUI.GetColor("toggle_button_switch"))
	end

	self:SetSize(34, 20)
end

sui.register("ToggleButton", Panel, "DCheckBox")
--addons/scb_chatbox/lua/scb/libs/sh_types.lua:
if SCB_LOADED then return end

-- https://gist.github.com/CapsAdmin/0d9c1e77d0fc22d910e182bfeb9812e5
local getmetatable = getmetatable

do
	local types = {
		["string"] = "",
		["boolean"] = true,
		["number"] = 0,
		["function"] = function() end,
		["thread"] = coroutine.create(getmetatable),
		["Color"] = Color(0, 0, 0),
	}

	for k, v in pairs(types) do
		if not getmetatable(v) then
			debug.setmetatable(v, {MetaName = k})
		else
			getmetatable(v).MetaName = k
		end
	end
end

function scb.type(value)
	if value == nil then
		return "nil"
	end
	local meta = getmetatable(value)
	if meta then
		meta = meta.MetaName
		if meta then
			return meta
		end
	end
	return "table"
end

do
	local function add(name)
		local new_name = name
		if name == "bool" then
			new_name = "boolean"
		end
		scb["is" .. name:lower()] = function(value)
			local meta = getmetatable(value)
			if meta and meta.MetaName == new_name then
				return true
			else
				return false
			end
		end
	end

	add("string")
	add("number")
	add("bool")
	add("function")

	add("Angle")
	add("Vector")
	add("Panel")
	add("Matrix")
end

function scb.isentity(value)
	local meta = getmetatable(value)
	if meta then
		if meta.MetaName == "Entity" then
			return true
		end
		meta = meta.MetaBaseClass
		if meta then
			return meta.MetaName == "Entity"
		end
	end
	return false
end
scb.IsEntity = scb.isentity

local type = scb.type
function scb.istable(value)
	return type(value) == "table"
end
--addons/scb_chatbox/lua/scb/libs/message_pack/sh_messagepack.lua:
if SCB_LOADED then return end

--
-- lua-MessagePack : <https://fperrad.frama.io/lua-MessagePack/>
--

local SIZEOF_NUMBER = string.pack and #string.pack('n', 0.0) or 8
local maxinteger
local mininteger

local assert = assert
local error = error
local pairs = pairs
local pcall = pcall
local setmetatable = setmetatable
local tostring = tostring
local char = string.char
local format = string.format
local floor = math.floor
local tointeger = floor
local frexp = math.frexp
local ldexp = math.ldexp
local huge = math.huge
local tconcat = table.concat

local type = scb.type
local isnumber = scb.isnumber
local _ENV = nil
local m = {}

--[[ debug only
local function hexadump (s)
	return (s:gsub('.', function (c) return format('%02X ', c:byte()) end))
end
m.hexadump = hexadump
--]]

local function argerror (caller, narg, extramsg)
	error("bad argument #" .. tostring(narg) .. " to "
		  .. caller .. " (" .. extramsg .. ")")
end

local function typeerror (caller, narg, arg, tname)
	argerror(caller, narg, tname .. " expected, got " .. type(arg))
end

local function checktype (caller, narg, arg, tname)
	if type(arg) ~= tname then
		typeerror(caller, narg, arg, tname)
	end
end

local packers = setmetatable({}, {
	__index = function (t, k)
		if k == 1 then return end   -- allows ipairs
		error("pack '" .. k .. "' is unimplemented")
	end
})
m.packers = packers

packers['nil'] = function (buffer)
	buffer[#buffer+1] = char(0xC0)	-- nil
end

packers['boolean'] = function (buffer, bool)
	if bool then
		buffer[#buffer+1] = char(0xC3)	-- true
	else
		buffer[#buffer+1] = char(0xC2)	-- false
	end
end

packers['string_compat'] = function (buffer, str)
	local n = #str
	if n <= 0x1F then
		buffer[#buffer+1] = char(0xA0 + n)	-- fixstr
	elseif n <= 0xFFFF then
		buffer[#buffer+1] = char(0xDA,		-- str16
								 floor(n / 0x100),
								 n % 0x100)
	elseif n <= 4294967295.0 then
		buffer[#buffer+1] = char(0xDB,		-- str32
								 floor(n / 0x1000000),
								 floor(n / 0x10000) % 0x100,
								 floor(n / 0x100) % 0x100,
								 n % 0x100)
	else
		error"overflow in pack 'string_compat'"
	end
	buffer[#buffer+1] = str
end

packers['_string'] = function (buffer, str)
	local n = #str
	if n <= 0x1F then
		buffer[#buffer+1] = char(0xA0 + n)		-- fixstr
	elseif n <= 0xFF then
		buffer[#buffer+1] = char(0xD9,			-- str8
								 n)
	elseif n <= 0xFFFF then
		buffer[#buffer+1] = char(0xDA,			-- str16
								 floor(n / 0x100),
								 n % 0x100)
	elseif n <= 4294967295.0 then
		buffer[#buffer+1] = char(0xDB,			-- str32
								 floor(n / 0x1000000),
								 floor(n / 0x10000) % 0x100,
								 floor(n / 0x100) % 0x100,
								 n % 0x100)
	else
		error"overflow in pack 'string'"
	end
	buffer[#buffer+1] = str
end

packers['binary'] = function (buffer, str)
	local n = #str
	if n <= 0xFF then
		buffer[#buffer+1] = char(0xC4,		-- bin8
								 n)
	elseif n <= 0xFFFF then
		buffer[#buffer+1] = char(0xC5,		-- bin16
								 floor(n / 0x100),
								 n % 0x100)
	elseif n <= 4294967295.0 then
		buffer[#buffer+1] = char(0xC6,		-- bin32
								 floor(n / 0x1000000),
								 floor(n / 0x10000) % 0x100,
								 floor(n / 0x100) % 0x100,
								 n % 0x100)
	else
		error"overflow in pack 'binary'"
	end
	buffer[#buffer+1] = str
end

local set_string = function (str)
	if str == 'string_compat' then
		packers['string'] = packers['string_compat']
	elseif str == 'string' then
		packers['string'] = packers['_string']
	elseif str == 'binary' then
		packers['string'] = packers['binary']
	else
		argerror('set_string', 1, "invalid option '" .. str .."'")
	end
end
m.set_string = set_string

packers['map'] = function (buffer, tbl, n)
	if n <= 0x0F then
		buffer[#buffer+1] = char(0x80 + n)		-- fixmap
	elseif n <= 0xFFFF then
		buffer[#buffer+1] = char(0xDE,			-- map16
								 floor(n / 0x100),
								 n % 0x100)
	elseif n <= 4294967295.0 then
		buffer[#buffer+1] = char(0xDF,			-- map32
								 floor(n / 0x1000000),
								 floor(n / 0x10000) % 0x100,
								 floor(n / 0x100) % 0x100,
								 n % 0x100)
	else
		error"overflow in pack 'map'"
	end
	for k, v in pairs(tbl) do
		packers[type(k)](buffer, k)
		packers[type(v)](buffer, v)
	end
end

packers['array'] = function (buffer, tbl, n)
	if n <= 0x0F then
		buffer[#buffer+1] = char(0x90 + n)		-- fixarray
	elseif n <= 0xFFFF then
		buffer[#buffer+1] = char(0xDC,			-- array16
								 floor(n / 0x100),
								 n % 0x100)
	elseif n <= 4294967295.0 then
		buffer[#buffer+1] = char(0xDD,			-- array32
								 floor(n / 0x1000000),
								 floor(n / 0x10000) % 0x100,
								 floor(n / 0x100) % 0x100,
								 n % 0x100)
	else
		error"overflow in pack 'array'"
	end
	for i = 1, n do
		local v = tbl[i]
		packers[type(v)](buffer, v)
	end
end

local set_array = function (array)
	if array == 'without_hole' then
		packers['_table'] = function (buffer, tbl)
			local is_map, n, max = false, 0, 0
			for k in pairs(tbl) do
				if isnumber(k) and k > 0 then
					if k > max then
						max = k
					end
				else
					is_map = true
				end
				n = n + 1
			end
			if max ~= n then	-- there are holes
				is_map = true
			end
			if is_map then
				packers['map'](buffer, tbl, n)
			else
				packers['array'](buffer, tbl, n)
			end
		end
	elseif array == 'with_hole' then
		packers['_table'] = function (buffer, tbl)
			local is_map, n, max = false, 0, 0
			for k in pairs(tbl) do
				if isnumber(k) and k > 0 then
					if k > max then
						max = k
					end
				else
					is_map = true
				end
				n = n + 1
			end
			if is_map then
				packers['map'](buffer, tbl, n)
			else
				packers['array'](buffer, tbl, max)
			end
		end
	elseif array == 'always_as_map' then
		packers['_table'] = function(buffer, tbl)
			local n = 0
			for k in pairs(tbl) do
				n = n + 1
			end
			packers['map'](buffer, tbl, n)
		end
	else
		argerror('set_array', 1, "invalid option '" .. array .."'")
	end
end
m.set_array = set_array

packers['table'] = function (buffer, tbl)
	packers['_table'](buffer, tbl)
end

packers['unsigned'] = function (buffer, n)
	if n >= 0 then
		if n <= 0x7F then
			buffer[#buffer+1] = char(n)			-- fixnum_pos
		elseif n <= 0xFF then
			buffer[#buffer+1] = char(0xCC,		-- uint8
									 n)
		elseif n <= 0xFFFF then
			buffer[#buffer+1] = char(0xCD,		-- uint16
									 floor(n / 0x100),
									 n % 0x100)
		elseif n <= 4294967295.0 then
			buffer[#buffer+1] = char(0xCE,		-- uint32
									 floor(n / 0x1000000),
									 floor(n / 0x10000) % 0x100,
									 floor(n / 0x100) % 0x100,
									 n % 0x100)
		else
			buffer[#buffer+1] = char(0xCF,		-- uint64
									 0,			-- only 53 bits from double
									 floor(n / 0x1000000000000) % 0x100,
									 floor(n / 0x10000000000) % 0x100,
									 floor(n / 0x100000000) % 0x100,
									 floor(n / 0x1000000) % 0x100,
									 floor(n / 0x10000) % 0x100,
									 floor(n / 0x100) % 0x100,
									 n % 0x100)
		end
	else
		if n >= -0x20 then
			buffer[#buffer+1] = char(0x100 + n) -- fixnum_neg
		elseif n >= -0x80 then
			buffer[#buffer+1] = char(0xD0,		-- int8
									 0x100 + n)
		elseif n >= -0x8000 then
			n = 0x10000 + n
			buffer[#buffer+1] = char(0xD1,		-- int16
									 floor(n / 0x100),
									 n % 0x100)
		elseif n >= -0x80000000 then
			n = 4294967296.0 + n
			buffer[#buffer+1] = char(0xD2,		-- int32
									 floor(n / 0x1000000),
									 floor(n / 0x10000) % 0x100,
									 floor(n / 0x100) % 0x100,
									 n % 0x100)
		else
			buffer[#buffer+1] = char(0xD3,		-- int64
									 0xFF,		-- only 53 bits from double
									 floor(n / 0x1000000000000) % 0x100,
									 floor(n / 0x10000000000) % 0x100,
									 floor(n / 0x100000000) % 0x100,
									 floor(n / 0x1000000) % 0x100,
									 floor(n / 0x10000) % 0x100,
									 floor(n / 0x100) % 0x100,
									 n % 0x100)
		end
	end
end

packers['signed'] = function (buffer, n)
	if n >= 0 then
		if n <= 0x7F then
			buffer[#buffer+1] = char(n)			-- fixnum_pos
		elseif n <= 0x7FFF then
			buffer[#buffer+1] = char(0xD1,		-- int16
									 floor(n / 0x100),
									 n % 0x100)
		elseif n <= 0x7FFFFFFF then
			buffer[#buffer+1] = char(0xD2,		-- int32
									 floor(n / 0x1000000),
									 floor(n / 0x10000) % 0x100,
									 floor(n / 0x100) % 0x100,
									 n % 0x100)
		else
			buffer[#buffer+1] = char(0xD3,		-- int64
									 0,			-- only 53 bits from double
									 floor(n / 0x1000000000000) % 0x100,
									 floor(n / 0x10000000000) % 0x100,
									 floor(n / 0x100000000) % 0x100,
									 floor(n / 0x1000000) % 0x100,
									 floor(n / 0x10000) % 0x100,
									 floor(n / 0x100) % 0x100,
									 n % 0x100)
		end
	else
		if n >= -0x20 then
			buffer[#buffer+1] = char(0xE0 + 0x20 + n)   -- fixnum_neg
		elseif n >= -0x80 then
			buffer[#buffer+1] = char(0xD0,		-- int8
									 0x100 + n)
		elseif n >= -0x8000 then
			n = 0x10000 + n
			buffer[#buffer+1] = char(0xD1,		-- int16
									 floor(n / 0x100),
									 n % 0x100)
		elseif n >= -0x80000000 then
			n = 4294967296.0 + n
			buffer[#buffer+1] = char(0xD2,		-- int32
									 floor(n / 0x1000000),
									 floor(n / 0x10000) % 0x100,
									 floor(n / 0x100) % 0x100,
									 n % 0x100)
		else
			buffer[#buffer+1] = char(0xD3,		-- int64
									 0xFF,		-- only 53 bits from double
									 floor(n / 0x1000000000000) % 0x100,
									 floor(n / 0x10000000000) % 0x100,
									 floor(n / 0x100000000) % 0x100,
									 floor(n / 0x1000000) % 0x100,
									 floor(n / 0x10000) % 0x100,
									 floor(n / 0x100) % 0x100,
									 n % 0x100)
		end
	end
end

local set_integer = function (integer)
	if integer == 'unsigned' then
		packers['integer'] = packers['unsigned']
	elseif integer == 'signed' then
		packers['integer'] = packers['signed']
	else
		argerror('set_integer', 1, "invalid option '" .. integer .."'")
	end
end
m.set_integer = set_integer

packers['float'] = function (buffer, n)
	local sign = 0
	if n < 0.0 then
		sign = 0x80
		n = -n
	end
	local mant, expo = frexp(n)
	if mant ~= mant then
		buffer[#buffer+1] = char(0xCA,  -- nan
								 0xFF, 0x88, 0x00, 0x00)
	elseif mant == huge or expo > 0x80 then
		if sign == 0 then
			buffer[#buffer+1] = char(0xCA,	  -- inf
									 0x7F, 0x80, 0x00, 0x00)
		else
			buffer[#buffer+1] = char(0xCA,	  -- -inf
									 0xFF, 0x80, 0x00, 0x00)
		end
	elseif (mant == 0.0 and expo == 0) or expo < -0x7E then
		buffer[#buffer+1] = char(0xCA,  -- zero
								 sign, 0x00, 0x00, 0x00)
	else
		expo = expo + 0x7E
		mant = floor((mant * 2.0 - 1.0) * ldexp(0.5, 24))
		buffer[#buffer+1] = char(0xCA,
								 sign + floor(expo / 0x2),
								 (expo % 0x2) * 0x80 + floor(mant / 0x10000),
								 floor(mant / 0x100) % 0x100,
								 mant % 0x100)
	end
end

packers['double'] = function (buffer, n)
	local sign = 0
	if n < 0.0 then
		sign = 0x80
		n = -n
	end
	local mant, expo = frexp(n)
	if mant ~= mant then
		buffer[#buffer+1] = char(0xCB,  -- nan
								 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)
	elseif mant == huge or expo > 0x400 then
		if sign == 0 then
			buffer[#buffer+1] = char(0xCB,	  -- inf
									 0x7F, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)
		else
			buffer[#buffer+1] = char(0xCB,	  -- -inf
									 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)
		end
	elseif (mant == 0.0 and expo == 0) or expo < -0x3FE then
		buffer[#buffer+1] = char(0xCB,  -- zero
								 sign, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)
	else
		expo = expo + 0x3FE
		mant = floor((mant * 2.0 - 1.0) * ldexp(0.5, 53))
		buffer[#buffer+1] = char(0xCB,
								 sign + floor(expo / 0x10),
								 (expo % 0x10) * 0x10 + floor(mant / 0x1000000000000),
								 floor(mant / 0x10000000000) % 0x100,
								 floor(mant / 0x100000000) % 0x100,
								 floor(mant / 0x1000000) % 0x100,
								 floor(mant / 0x10000) % 0x100,
								 floor(mant / 0x100) % 0x100,
								 mant % 0x100)
	end
end

local set_number = function (number)
	if number == 'float' then
		packers['number'] = function (buffer, n)
			if floor(n) == n and n < maxinteger and n > mininteger then
				packers['integer'](buffer, n)
			else
				packers['float'](buffer, n)
			end
		end
	elseif number == 'double' then
		packers['number'] = function (buffer, n)
			if floor(n) == n and n < maxinteger and n > mininteger then
				packers['integer'](buffer, n)
			else
				packers['double'](buffer, n)
			end
		end
	else
		argerror('set_number', 1, "invalid option '" .. number .."'")
	end
end
m.set_number = set_number

for k = 0, 4 do
	local n = tointeger(2^k)
	local fixext = 0xD4 + k
	packers['fixext' .. tostring(n)] = function (buffer, tag, data)
		assert(#data == n, "bad length for fixext" .. tostring(n))
		buffer[#buffer+1] = char(fixext,
								 tag < 0 and tag + 0x100 or tag)
		buffer[#buffer+1] = data
	end
end

packers['ext'] = function (buffer, tag, data)
	local n = #data
	if n <= 0xFF then
		buffer[#buffer+1] = char(0xC7,		  -- ext8
								 n,
								 tag < 0 and tag + 0x100 or tag)
	elseif n <= 0xFFFF then
		buffer[#buffer+1] = char(0xC8,		  -- ext16
								 floor(n / 0x100),
								 n % 0x100,
								 tag < 0 and tag + 0x100 or tag)
	elseif n <= 4294967295.0 then
		buffer[#buffer+1] = char(0xC9,		  -- ext&32
								 floor(n / 0x1000000),
								 floor(n / 0x10000) % 0x100,
								 floor(n / 0x100) % 0x100,
								 n % 0x100,
								 tag < 0 and tag + 0x100 or tag)
	else
		error"overflow in pack 'ext'"
	end
	buffer[#buffer+1] = data
end

function m.pack (data)
	local buffer = {}
	packers[type(data)](buffer, data)
	return tconcat(buffer)
end


local unpackers		 -- forward declaration

local function unpack_cursor (c)
	local s, i, j = c.s, c.i, c.j
	if i > j then
		c:underflow(i)
		s, i, j = c.s, c.i, c.j
	end
	local val = s:byte(i)
	c.i = i+1
	return unpackers[val](c, val)
end
m.unpack_cursor = unpack_cursor

local function unpack_str (c, n)
	local s, i, j = c.s, c.i, c.j
	local e = i+n-1
	if e > j or n < 0 then
		c:underflow(e)
		s, i, j = c.s, c.i, c.j
		e = i+n-1
	end
	c.i = i+n
	return s:sub(i, e)
end

local function unpack_array (c, n)
	local t = {}
	for i = 1, n do
		t[i] = unpack_cursor(c)
	end
	return t
end

local function unpack_map (c, n)
	local t = {}
	for i = 1, n do
		local k = unpack_cursor(c)
		local val = unpack_cursor(c)
		if k == nil or k ~= k then
			k = m.sentinel
		end
		if k ~= nil then
			t[k] = val
		end
	end
	return t
end

local function unpack_float (c)
	local s, i, j = c.s, c.i, c.j
	if i+3 > j then
		c:underflow(i+3)
		s, i, j = c.s, c.i, c.j
	end
	local b1, b2, b3, b4 = s:byte(i, i+3)
	local sign = b1 > 0x7F
	local expo = (b1 % 0x80) * 0x2 + floor(b2 / 0x80)
	local mant = ((b2 % 0x80) * 0x100 + b3) * 0x100 + b4
	if sign then
		sign = -1
	else
		sign = 1
	end
	local n
	if mant == 0 and expo == 0 then
		n = sign * 0.0
	elseif expo == 0xFF then
		if mant == 0 then
			n = sign * huge
		else
			n = 0.0/0.0
		end
	else
		n = sign * ldexp(1.0 + mant / 0x800000, expo - 0x7F)
	end
	c.i = i+4
	return n
end

local function unpack_double (c)
	local s, i, j = c.s, c.i, c.j
	if i+7 > j then
		c:underflow(i+7)
		s, i, j = c.s, c.i, c.j
	end
	local b1, b2, b3, b4, b5, b6, b7, b8 = s:byte(i, i+7)
	local sign = b1 > 0x7F
	local expo = (b1 % 0x80) * 0x10 + floor(b2 / 0x10)
	local mant = ((((((b2 % 0x10) * 0x100 + b3) * 0x100 + b4) * 0x100 + b5) * 0x100 + b6) * 0x100 + b7) * 0x100 + b8
	if sign then
		sign = -1
	else
		sign = 1
	end
	local n
	if mant == 0 and expo == 0 then
		n = sign * 0.0
	elseif expo == 0x7FF then
		if mant == 0 then
			n = sign * huge
		else
			n = 0.0/0.0
		end
	else
		n = sign * ldexp(1.0 + mant / 4503599627370496.0, expo - 0x3FF)
	end
	c.i = i+8
	return n
end

local function unpack_uint8 (c)
	local s, i, j = c.s, c.i, c.j
	if i > j then
		c:underflow(i)
		s, i, j = c.s, c.i, c.j
	end
	local b1 = s:byte(i)
	c.i = i+1
	return b1
end

local function unpack_uint16 (c)
	local s, i, j = c.s, c.i, c.j
	if i+1 > j then
		c:underflow(i+1)
		s, i, j = c.s, c.i, c.j
	end
	local b1, b2 = s:byte(i, i+1)
	c.i = i+2
	return b1 * 0x100 + b2
end

local function unpack_uint32 (c)
	local s, i, j = c.s, c.i, c.j
	if i+3 > j then
		c:underflow(i+3)
		s, i, j = c.s, c.i, c.j
	end
	local b1, b2, b3, b4 = s:byte(i, i+3)
	c.i = i+4
	return ((b1 * 0x100 + b2) * 0x100 + b3) * 0x100 + b4
end

local function unpack_uint64 (c)
	local s, i, j = c.s, c.i, c.j
	if i+7 > j then
		c:underflow(i+7)
		s, i, j = c.s, c.i, c.j
	end
	local b1, b2, b3, b4, b5, b6, b7, b8 = s:byte(i, i+7)
	c.i = i+8
	return ((((((b1 * 0x100 + b2) * 0x100 + b3) * 0x100 + b4) * 0x100 + b5) * 0x100 + b6) * 0x100 + b7) * 0x100 + b8
end

local function unpack_int8 (c)
	local s, i, j = c.s, c.i, c.j
	if i > j then
		c:underflow(i)
		s, i, j = c.s, c.i, c.j
	end
	local b1 = s:byte(i)
	c.i = i+1
	if b1 < 0x80 then
		return b1
	else
		return b1 - 0x100
	end
end

local function unpack_int16 (c)
	local s, i, j = c.s, c.i, c.j
	if i+1 > j then
		c:underflow(i+1)
		s, i, j = c.s, c.i, c.j
	end
	local b1, b2 = s:byte(i, i+1)
	c.i = i+2
	if b1 < 0x80 then
		return b1 * 0x100 + b2
	else
		return ((b1 - 0xFF) * 0x100 + (b2 - 0xFF)) - 1
	end
end

local function unpack_int32 (c)
	local s, i, j = c.s, c.i, c.j
	if i+3 > j then
		c:underflow(i+3)
		s, i, j = c.s, c.i, c.j
	end
	local b1, b2, b3, b4 = s:byte(i, i+3)
	c.i = i+4
	if b1 < 0x80 then
		return ((b1 * 0x100 + b2) * 0x100 + b3) * 0x100 + b4
	else
		return ((((b1 - 0xFF) * 0x100 + (b2 - 0xFF)) * 0x100 + (b3 - 0xFF)) * 0x100 + (b4 - 0xFF)) - 1
	end
end

local function unpack_int64 (c)
	local s, i, j = c.s, c.i, c.j
	if i+7 > j then
		c:underflow(i+7)
		s, i, j = c.s, c.i, c.j
	end
	local b1, b2, b3, b4, b5, b6, b7, b8 = s:byte(i, i+7)
	c.i = i+8
	if b1 < 0x80 then
		return ((((((b1 * 0x100 + b2) * 0x100 + b3) * 0x100 + b4) * 0x100 + b5) * 0x100 + b6) * 0x100 + b7) * 0x100 + b8
	else
		return ((((((((b1 - 0xFF) * 0x100 + (b2 - 0xFF)) * 0x100 + (b3 - 0xFF)) * 0x100 + (b4 - 0xFF)) * 0x100 + (b5 - 0xFF)) * 0x100 + (b6 - 0xFF)) * 0x100 + (b7 - 0xFF)) * 0x100 + (b8 - 0xFF)) - 1
	end
end

function m.build_ext (tag, data)
	return nil
end

local function unpack_ext (c, n, tag)
	local s, i, j = c.s, c.i, c.j
	local e = i+n-1
	if e > j or n < 0 then
		c:underflow(e)
		s, i, j = c.s, c.i, c.j
		e = i+n-1
	end
	c.i = i+n
	return m.build_ext(tag, s:sub(i, e))
end

local fn_1 = function(c, val)
	return val
end

local fn_2 = function(c, val)
	return unpack_map(c, val % 0x10)
end

local fn_3 = function(c, val)
	return unpack_array(c, val % 0x10)
end

local fn_4 = function(c, val)
	return unpack_str(c, val % 0x20)
end

local fn_5 = function(c, val)
	return val - 0x100
end

unpackers = setmetatable({
	[0xC0] = function () return nil end,
	[0xC2] = function () return false end,
	[0xC3] = function () return true end,
	[0xC4] = function (c) return unpack_str(c, unpack_uint8(c)) end,	-- bin8
	[0xC5] = function (c) return unpack_str(c, unpack_uint16(c)) end,   -- bin16
	[0xC6] = function (c) return unpack_str(c, unpack_uint32(c)) end,   -- bin32
	[0xC7] = function (c) return unpack_ext(c, unpack_uint8(c), unpack_int8(c)) end,
	[0xC8] = function (c) return unpack_ext(c, unpack_uint16(c), unpack_int8(c)) end,
	[0xC9] = function (c) return unpack_ext(c, unpack_uint32(c), unpack_int8(c)) end,
	[0xCA] = unpack_float,
	[0xCB] = unpack_double,
	[0xCC] = unpack_uint8,
	[0xCD] = unpack_uint16,
	[0xCE] = unpack_uint32,
	[0xCF] = unpack_uint64,
	[0xD0] = unpack_int8,
	[0xD1] = unpack_int16,
	[0xD2] = unpack_int32,
	[0xD3] = unpack_int64,
	[0xD4] = function (c) return unpack_ext(c, 1, unpack_int8(c)) end,
	[0xD5] = function (c) return unpack_ext(c, 2, unpack_int8(c)) end,
	[0xD6] = function (c) return unpack_ext(c, 4, unpack_int8(c)) end,
	[0xD7] = function (c) return unpack_ext(c, 8, unpack_int8(c)) end,
	[0xD8] = function (c) return unpack_ext(c, 16, unpack_int8(c)) end,
	[0xD9] = function (c) return unpack_str(c, unpack_uint8(c)) end,
	[0xDA] = function (c) return unpack_str(c, unpack_uint16(c)) end,
	[0xDB] = function (c) return unpack_str(c, unpack_uint32(c)) end,
	[0xDC] = function (c) return unpack_array(c, unpack_uint16(c)) end,
	[0xDD] = function (c) return unpack_array(c, unpack_uint32(c)) end,
	[0xDE] = function (c) return unpack_map(c, unpack_uint16(c)) end,
	[0xDF] = function (c) return unpack_map(c, unpack_uint32(c)) end,
}, {
	__index = function (t, k)
		if k < 0xC0 then
			if k < 0x80 then
				return fn_1
			elseif k < 0x90 then
				return fn_2
			elseif k < 0xA0 then
				return fn_3
			else
				return fn_4
			end
		elseif k > 0xDF then
			return fn_5
		else
			return function () error("unpack '" .. format('%#x', k) .. "' is unimplemented") end
		end
	end
})

local function cursor_string (str)
	return {
		s = str,
		i = 1,
		j = #str,
		underflow = function ()
						error "missing bytes"
					end,
	}
end

local function cursor_loader (ld)
	return {
		s = '',
		i = 1,
		j = 0,
		underflow = function (self, e)
						self.s = self.s:sub(self.i)
						e = e - self.i + 1
						self.i = 1
						self.j = 0
						while e > self.j do
							local chunk = ld()
							if not chunk then
								error "missing bytes"
							end
							self.s = self.s .. chunk
							self.j = #self.s
						end
					end,
	}
end

function m.unpack (s)
	checktype('unpack', 1, s, 'string')
	local cursor = cursor_string(s)
	local data = unpack_cursor(cursor)
	if cursor.i <= cursor.j then
		error "extra bytes"
	end
	return data
end

function m.unpacker (src)
	if type(src) == 'string' then
		local cursor = cursor_string(src)
		return function ()
			if cursor.i <= cursor.j then
				return cursor.i, unpack_cursor(cursor)
			end
		end
	elseif type(src) == 'function' then
		local cursor = cursor_loader(src)
		return function ()
			if cursor.i > cursor.j then
				pcall(cursor.underflow, cursor, cursor.i)
			end
			if cursor.i <= cursor.j then
				return true, unpack_cursor(cursor)
			end
		end
	else
		argerror('unpacker', 1, "string or function expected, got " .. type(src))
	end
end

set_string'string_compat'
set_integer'unsigned'
if SIZEOF_NUMBER == 4 then
	maxinteger = 16777215
	mininteger = -maxinteger
	m.small_lua = true
	unpackers[0xCB] = nil	   -- double
	unpackers[0xCF] = nil	   -- uint64
	unpackers[0xD3] = nil	   -- int64
	set_number'float'
else
	maxinteger = 9007199254740991
	mininteger = -maxinteger
	set_number'double'
	if SIZEOF_NUMBER > 8 then
		m.long_double = true
	end
end
set_array'without_hole'

m._VERSION = '0.5.2'
m._DESCRIPTION = "lua-MessagePack : a pure Lua implementation"
m._COPYRIGHT = "Copyright (c) 2012-2019 Francois Perrad"

return m

--
-- This library is licensed under the terms of the MIT/X11 license,
-- like Lua itself.
--

--addons/scb_chatbox/lua/sh_scb_config.lua:
if SCB_LOADED then return end

local config = scb.config

--
-- Chatbox title!@!
-- SERVER_NAME will be replaced with your server name
-- PLAYER_COUNT will be replaced with your online player count
-- EG.
-- config.chatbox_title = "SERVER_NAME (PLAYER_COUNT)" -- > Srlion Gaming (1)
--
config.chatbox_title = "SERVER_NAME"

--
-- By default it uses 12h format, for 24h use "%H:%M:%S"
--
config.timestamps_format = "%H:%M:%S"

--
-- Allow parsing in chat print functions? (chat.AddText/Player:ChatPrint/Player:PrintMessage)
-- If it causes problems then disable it.
--
config.parse_in_chat = true

--
-- Hide language sign that appears behing emojis if you are typing in a non-English language
--
config.hide_language_sign = true

--
-- Enable the custom join messages
--
config.enable_custom_join_messages = false

--
-- Enable the custom leave messages
--
config.enable_custom_leave_messages = false

--
-- Enable avatars
--
config.enable_avatars = true

--
-- You can use SteamID/SteamID64/Ranks
-- If the first value is 'true' then anyone can use it
--
config.permissions = {
	--
	-- Who can add/remove/edit emojis & tags?
	--
	menu = {
		"gruender",
		"communityleitung",
		"superadmin",
	},

	--
	-- Who can use rainbow texts?
	-- Eg.
	-- hi there {* everyone}!
	--
	rainbow = {
	true,
	},

	--
	-- Who can use flashing texts?
	-- Eg.
	-- hi there {! everyone}!
	--
	flashing = {
		true,
	},

	--
	-- Who can use colored texts?
	-- Eg.
	-- hi there {red Srlion}!
	-- hi there {#ff0000 Srlion}!
	--
	colored_texts = {
		true,
	},

	--
	-- Who can use custom emojis?
	--
	custom_emojis = {
		"gruender",
		"communityleitung",
		"superadmin",
		"admin"
	}
}

--
-- You can add colors that can be used in chatbox, eg. {my_new_color hi there!}
-- Use something like https://www.hexcolortool.com to get hex codes!
--
config.colors = {
	red = "f44336",
	pink = "E91E63",
	purple = "9C27B0",
	blue = "1773c4",
	cyan = "00BCD4",
	green = "4CAF50",
	yellow = "FFEB3B",
	orange = "FF9800",
	brown = "7b5804",
	grey = "9E9E9E",
	white = "E0E0E0",
	black = "080808"
}

scb.language = {
	save = "SPEICHERN",
	cancel = "ABBRECHEN",
	edit = "Bearbeiten",
	search = "Suchen...",
	team = "TEAM",
	dead = "*TOT* ",
	console = "Konsole",
	remove = "Entfernen",

	type_something = "Tippe etwas...",

	settings_title = "Einstellungen",

	client_title = "Client",
	tags_title = "Tags",
	emojis_title = "Emojis",

	show_avatars = "Avatare anzeigen",
	show_time = "Timestamps anzeigen",
	disable_rainbow = "Regenbogenfarben deaktivieren",
	disable_flashing = "Blinkder Text deaktivieren",
	blur_theme = "Blur Theme",
	join_messages = "Join/Disconnect Nachrichten",
	scale = "Scale",
	messages_fade = "Nachrichten - Ausblendzeit",
	max_messages = "Maximale Nachrichten",
	reset_size = "Fenstergröße Zurücksetzen",
	reset_position = "Fensterposition Zurücksetzen",
	clear_reload = "Bilder Neuladen (Kann Probleme mit veralteten Bildern beheben, die noch geladen sind.)",

	add_tag = "Tag hinzufügen",
	tag_owner = "SteamID/SteamID64/Rang",
	tag = "Tag",

	add_emoji = "Emoji hinzufügen",
	emoji_name = "Name",
	emoji_url = "URL",

	copy_text = "Text kopieren",
	copy_message = "Nachricht kopieren",
	copy_steamid = "Steamid kopieren",
	copy_steamid64 = "Steamid64 kopieren",
	show_profile = "Spielerprofil anzeigen",
	copy_time = "Nachrichtenzeit anzeigen",
	copy_url = "URL kopieren",

	bot_joined = "{#1773c4 NAME} hat das Spiel betreten",
	bot_left = "{#f44336 NAME} hat das Spiel verlassen",

	-- STEAMID gets replaced by the player steamid
	player_connecting = "{#1773c4 NAME} verbindet sich",
	player_left = "{#f44336 NAME} hat das Spiel verlassen: REASON",
}
--addons/scb_chatbox/lua/scb/cl_util.lua:
if SCB_LOADED then return end

local tonumber = tonumber
local Color = Color
local bit = bit
local file = file
local SortedPairs = SortedPairs
local table = table
local util = util
local math = math

local scb = scb

function scb.hex_rgb(hex)
	hex = tonumber(hex:gsub("^([%w])([%w])([%w])$", "%1%1%2%2%3%3", 1), 16)

	return Color(
		bit.band(bit.rshift(hex, 16), 0xFF),
		bit.band(bit.rshift(hex, 8), 0xFF),
		bit.band(hex, 0xFF)
	)
end

function scb.rgb_hex(color)
	return ("%x%x%x"):format(color.r, color.g, color.b)
end

function scb.get_extension(path)
	return path:GetExtensionFromFilename():match("(%w+)")
end

function scb.to_new_range(x, old_min, old_max, new_min, new_max)
	return (x - old_min) * (new_max - new_min) / (old_max - old_min) + new_min
end

function scb.is_letter_digit(c)
	return
		(c >= "a" and c <= "z") or
		(c >= "A" and c <= "Z") or
		(c >= "0" and c <= "9")
end

function scb.is_custom_emoji(info)
	return info:sub(1, 4) == "http"
end

do
	local escape_replacements = {
		["\\"] = "\\\\",
		["{"] = "\\{" ,
		["}"] = "\\}"
	}

	function scb.escape(text)
		text = text:gsub(".", escape_replacements)

		local pos = 0
		while true do
			local start, url, _end = scb.find_url(text, pos + 1)
			if not start then break end
			pos = _end + 1
			text = text:sub(1, start - 1) .. "\\" .. url .. text:sub(_end + 1)
		end

		return text
	end
end

do
	-- i feel disgusted

	if not file.Exists("scb/emojis_used.txt", "DATA") then
		file.Write("scb/emojis_used.txt", "{}")
	end
	local emojis_times_used = util.JSONToTable(file.Read("scb/emojis_used.txt", "DATA"))

	function scb.search_emojis(text)
		local emojis = {}
		for name in SortedPairs(scb.emojis) do
			name = name:lower()
			local start = name:find(text, 1, true)
			if start then
				if name:sub(start - 1, start - 1) == "_" then
					start = 1
				elseif name == text then
					start = math.huge
				end
				local used_times = emojis_times_used[name]
				if start == 1 then
					if used_times then
						used_times = used_times + (9999999999 + (start ^ 4))
					else
						used_times = 9999999999
					end
				elseif used_times then
					used_times = used_times + (999999999 + (start ^ 4))
				else
					used_times = start
				end
				table.insert(emojis, {name = name, pos = -used_times})
			end
		end
		table.SortByMember(emojis, "pos", true)

		return emojis
	end

	function scb.emoji_set_used(emoji)
		emojis_times_used[emoji] = (emojis_times_used[emoji] or 0) + 1
		file.Write("scb/emojis_used.txt", util.TableToJSON(emojis_times_used))
	end
end

do
	-- https://stackoverflow.com/questions/23590304/finding-a-url-in-a-string-lua-pattern?rq=1

	-- https://raw.githubusercontent.com/incognico/list-of-top-level-domains/master/formats/json/tld-list.json
	local domains = [==[["aaa","aarp","abarth","abb","abbott","abbvie","abc","able","abogado","abudhabi","ac","academy","accenture","accountant","accountants","aco","active","actor","ad","adac","ads","adult","ae","aeg","aero","aetna","af","afamilycompany","afl","africa","ag","agakhan","agency","ai","aig","aigo","airbus","airforce","airtel","akdn","al","alfaromeo","alibaba","alipay","allfinanz","allstate","ally","alsace","alstom","am","americanexpress","americanfamily","amex","amfam","amica","amsterdam","an","analytics","android","anquan","anz","ao","aol","apartments","app","apple","aq","aquarelle","ar","arab","aramco","archi","army","arpa","art","arte","as","asda","asia","associates","at","athleta","attorney","au","auction","audi","audible","audio","auspost","author","auto","autos","avianca","aw","aws","ax","axa","az","azure","ba","baby","baidu","banamex","bananarepublic","band","bank","bar","barcelona","barclaycard","barclays","barefoot","bargains","baseball","basketball","bauhaus","bayern","bb","bbc","bbt","bbva","bcg","bcn","bd","be","beats","beauty","beer","bentley","berlin","best","bestbuy","bet","bf","bg","bh","bharti","bi","bible","bid","bike","bing","bingo","bio","biz","bj","bl","black","blackfriday","blanco","blockbuster","blog","bloomberg","blue","bm","bms","bmw","bn","bnl","bnpparibas","bo","boats","boehringer","bofa","bom","bond","boo","book","booking","boots","bosch","bostik","boston","bot","boutique","box","bq","br","bradesco","bridgestone","broadway","broker","brother","brussels","bs","bt","budapest","bugatti","build","builders","business","buy","buzz","bv","bw","by","bz","bzh","ca","cab","cafe","cal","call","calvinklein","cam","camera","camp","cancerresearch","canon","capetown","capital","capitalone","car","caravan","cards","care","career","careers","cars","cartier","casa","case","caseih","cash","casino","cat","catering","catholic","cba","cbn","cbre","cbs","cc","cd","ceb","center","ceo","cern","cf","cfa","cfd","cg","ch","chanel","channel","charity","chase","chat","cheap","chintai","chloe","christmas","chrome","chrysler","church","ci","cipriani","circle","cisco","citadel","citi","citic","city","cityeats","ck","cl","claims","cleaning","click","clinic","clinique","clothing","cloud","club","clubmed","cm","cn","co","coach","codes","coffee","college","cologne","com","comcast","commbank","community","company","compare","computer","comsec","condos","construction","consulting","contact","contractors","cooking","cookingchannel","cool","coop","corsica","country","coupon","coupons","courses","cr","credit","creditcard","creditunion","cricket","crown","crs","cruise","cruises","csc","cu","cuisinella","cv","cw","cx","cy","cymru","cyou","cz","dabur","dad","dance","data","date","dating","datsun","day","dclk","dds","de","deal","dealer","deals","degree","delivery","dell","deloitte","delta","democrat","dental","dentist","desi","design","dev","dhl","diamonds","diet","digital","direct","directory","discount","discover","dish","diy","dj","dk","dm","dnp","do","docs","doctor","dodge","dog","doha","domains","doosan","dot","download","drive","dtv","dubai","duck","dunlop","duns","dupont","durban","dvag","dvr","dz","earth","eat","ec","eco","edeka","edu","education","ee","eg","eh","email","emerck","energy","engineer","engineering","enterprises","epost","epson","equipment","er","ericsson","erni","es","esq","estate","esurance","et","etisalat","eu","eurovision","eus","events","everbank","exchange","expert","exposed","express","extraspace","fage","fail","fairwinds","faith","family","fan","fans","farm","farmers","fashion","fast","fedex","feedback","ferrari","ferrero","fi","fiat","fidelity","fido","film","final","finance","financial","fire","firestone","firmdale","fish","fishing","fit","fitness","fj","fk","flickr","flights","flir","florist","flowers","flsmidth","fly","fm","fo","foo","food","foodnetwork","football","ford","forex","forsale","forum","foundation","fox","fr","free","fresenius","frl","frogans","frontdoor","frontier","ftr","fujitsu","fujixerox","fun","fund","furniture","futbol","fyi","ga","gal","gallery","gallo","gallup","game","games","gap","garden","gb","gbiz","gd","gdn","ge","gea","gent","genting","george","gf","gg","ggee","gh","gi","gift","gifts","gives","giving","gl","glade","glass","gle","global","globo","gm","gmail","gmbh","gmo","gmx","gn","godaddy","gold","goldpoint","golf","goo","goodhands","goodyear","goog","google","gop","got","gov","gp","gq","gr","grainger","graphics","gratis","green","gripe","grocery","group","gs","gt","gu","guardian","gucci","guge","guide","guitars","guru","gw","gy","hair","hamburg","hangout","haus","hbo","hdfc","hdfcbank","health","healthcare","help","helsinki","here","hermes","hgtv","hiphop","hisamitsu","hitachi","hiv","hk","hkt","hm","hn","hockey","holdings","holiday","homedepot","homegoods","homes","homesense","honda","honeywell","horse","hospital","host","hosting","hot","hoteles","hotels","hotmail","house","how","hr","hsbc","ht","htc","hu","hughes","hyatt","hyundai","ibm","icbc","ice","icu","id","ie","ieee","ifm","iinet","ikano","il","im","imamat","imdb","immo","immobilien","in","industries","infiniti","info","ing","ink","institute","insurance","insure","int","intel","international","intuit","investments","io","ipiranga","iq","ir","irish","is","iselect","ismaili","ist","istanbul","it","itau","itv","iveco","iwc","jaguar","java","jcb","jcp","je","jeep","jetzt","jewelry","jio","jlc","jll","jm","jmp","jnj","jo","jobs","joburg","jot","joy","jp","jpmorgan","jprs","juegos","juniper","kaufen","kddi","ke","kerryhotels","kerrylogistics","kerryproperties","kfh","kg","kh","ki","kia","kim","kinder","kindle","kitchen","kiwi","km","kn","koeln","komatsu","kosher","kp","kpmg","kpn","kr","krd","kred","kuokgroup","kw","ky","kyoto","kz","la","lacaixa","ladbrokes","lamborghini","lamer","lancaster","lancia","lancome","land","landrover","lanxess","lasalle","lat","latino","latrobe","law","lawyer","lb","lc","lds","lease","leclerc","lefrak","legal","lego","lexus","lgbt","li","liaison","lidl","life","lifeinsurance","lifestyle","lighting","like","lilly","limited","limo","lincoln","linde","link","lipsy","live","living","lixil","lk","llc","loan","loans","locker","locus","loft","lol","london","lotte","lotto","love","lpl","lplfinancial","lr","ls","lt","ltd","ltda","lu","lundbeck","lupin","luxe","luxury","lv","ly","ma","macys","madrid","maif","maison","makeup","man","management","mango","map","market","marketing","markets","marriott","marshalls","maserati","mattel","mba","mc","mcd","mcdonalds","mckinsey","md","me","med","media","meet","melbourne","meme","memorial","men","menu","meo","merckmsd","metlife","mf","mg","mh","miami","microsoft","mil","mini","mint","mit","mitsubishi","mk","ml","mlb","mls","mm","mma","mn","mo","mobi","mobile","mobily","moda","moe","moi","mom","monash","money","monster","montblanc","mopar","mormon","mortgage","moscow","moto","motorcycles","mov","movie","movistar","mp","mq","mr","ms","msd","mt","mtn","mtpc","mtr","mu","museum","mutual","mutuelle","mv","mw","mx","my","mz","na","nab","nadex","nagoya","name","nationwide","natura","navy","nba","nc","ne","nec","net","netbank","netflix","network","neustar","new","newholland","news","next","nextdirect","nexus","nf","nfl","ng","ngo","nhk","ni","nico","nike","nikon","ninja","nissan","nissay","nl","no","nokia","northwesternmutual","norton","now","nowruz","nowtv","np","nr","nra","nrw","ntt","nu","nyc","nz","obi","observer","off","office","okinawa","olayan","olayangroup","oldnavy","ollo","om","omega","one","ong","onl","online","onyourside","ooo","open","oracle","orange","org","organic","orientexpress","origins","osaka","otsuka","ott","ovh","pa","page","pamperedchef","panasonic","panerai","paris","pars","partners","parts","party","passagens","pay","pccw","pe","pet","pf","pfizer","pg","ph","pharmacy","phd","philips","phone","photo","photography","photos","physio","piaget","pics","pictet","pictures","pid","pin","ping","pink","pioneer","pizza","pk","pl","place","play","playstation","plumbing","plus","pm","pn","pnc","pohl","poker","politie","porn","post","pr","pramerica","praxi","press","prime","pro","prod","productions","prof","progressive","promo","properties","property","protection","pru","prudential","ps","pt","pub","pw","pwc","py","qa","qpon","quebec","quest","qvc","racing","radio","raid","re","read","realestate","realtor","realty","recipes","red","redstone","redumbrella","rehab","reise","reisen","reit","reliance","ren","rent","rentals","repair","report","republican","rest","restaurant","review","reviews","rexroth","rich","richardli","ricoh","rightathome","ril","rio","rip","rmit","ro","rocher","rocks","rodeo","rogers","room","rs","rsvp","ru","rugby","ruhr","run","rw","rwe","ryukyu","sa","saarland","safe","safety","sakura","sale","salon","samsclub","samsung","sandvik","sandvikcoromant","sanofi","sap","sapo","sarl","sas","save","saxo","sb","sbi","sbs","sc","sca","scb","schaeffler","schmidt","scholarships","school","schule","schwarz","science","scjohnson","scor","scot","sd","se","search","seat","secure","security","seek","select","sener","services","ses","seven","sew","sex","sexy","sfr","sg","sh","shangrila","sharp","shaw","shell","shia","shiksha","shoes","shop","shopping","shouji","show","showtime","shriram","si","silk","sina","singles","site","sj","sk","ski","skin","sky","skype","sl","sling","sm","smart","smile","sn","sncf","so","soccer","social","softbank","software","sohu","solar","solutions","song","sony","soy","space","spiegel","sport","spot","spreadbetting","sr","srl","srt","ss","st","stada","staples","star","starhub","statebank","statefarm","statoil","stc","stcgroup","stockholm","storage","store","stream","studio","study","style","su","sucks","supplies","supply","support","surf","surgery","suzuki","sv","swatch","swiftcover","swiss","sx","sy","sydney","symantec","systems","sz","tab","taipei","talk","taobao","target","tatamotors","tatar","tattoo","tax","taxi","tc","tci","td","tdk","team","tech","technology","tel","telecity","telefonica","temasek","tennis","teva","tf","tg","th","thd","theater","theatre","tiaa","tickets","tienda","tiffany","tips","tires","tirol","tj","tjmaxx","tjx","tk","tkmaxx","tl","tm","tmall","tn","to","today","tokyo","tools","top","toray","toshiba","total","tours","town","toyota","toys","tp","tr","trade","trading","training","travel","travelchannel","travelers","travelersinsurance","trust","trv","tt","tube","tui","tunes","tushu","tv","tvs","tw","tz","ua","ubank","ubs","uconnect","ug","uk","um","unicom","university","uno","uol","ups","us","uy","uz","va","vacations","vana","vanguard","vc","ve","vegas","ventures","verisign","versicherung","vet","vg","vi","viajes","video","vig","viking","villas","vin","vip","virgin","visa","vision","vista","vistaprint","viva","vivo","vlaanderen","vn","vodka","volkswagen","volvo","vote","voting","voto","voyage","vu","vuelos","wales","walmart","walter","wang","wanggou","warman","watch","watches","weather","weatherchannel","webcam","weber","website","wed","wedding","weibo","weir","wf","whoswho","wien","wiki","williamhill","win","windows","wine","winners","wme","wolterskluwer","woodside","work","works","world","wow","ws","wtc","wtf","xbox","xerox","xfinity","xihuan","xin","测试","कॉम","परीक्षा","セール","佛山","ಭಾರತ","慈善","集团","在线","한국","ଭାରତ","大众汽车","点看","คอม","ভাৰত","ভারত","八卦","‏موقع‎","বাংলা","公益","公司","香格里拉","网站","移动","我爱你","москва","испытание","қаз","католик","онлайн","сайт","联通","срб","бг","бел","‏קום‎","时尚","微博","테스트","淡马锡","ファッション","орг","नेट","ストア","삼성","சிங்கப்பூர்","商标","商店","商城","дети","мкд","‏טעסט‎","ею","ポイント","新闻","工行","家電","‏كوم‎","中文网","中信","中国","中國","娱乐","谷歌","భారత్","ලංකා","電訊盈科","购物","測試","クラウド","ભારત","通販","भारतम्","भारत","भारोत","‏آزمایشی‎","பரிட்சை","网店","संगठन","餐厅","网络","ком","укр","香港","诺基亚","食品","δοκιμή","飞利浦","‏إختبار‎","台湾","台灣","手表","手机","мон","‏الجزائر‎","‏عمان‎","‏ارامكو‎","‏ایران‎","‏العليان‎","‏اتصالات‎","‏امارات‎","‏بازار‎","‏موريتانيا‎","‏پاکستان‎","‏الاردن‎","‏موبايلي‎","‏بارت‎","‏بھارت‎","‏المغرب‎","‏ابوظبي‎","‏السعودية‎","‏ڀارت‎","‏كاثوليك‎","‏سودان‎","‏همراه‎","‏عراق‎","‏مليسيا‎","澳門","닷컴","政府","‏شبكة‎","‏بيتك‎","‏عرب‎","გე","机构","组织机构","健康","ไทย","‏سورية‎","招聘","рус","рф","珠宝","‏تونس‎","大拿","みんな","グーグル","ελ","世界","書籍","ഭാരതം","ਭਾਰਤ","网址","닷넷","コム","天主教","游戏","vermögensberater","vermögensberatung","企业","信息","嘉里大酒店","嘉里","‏مصر‎","‏قطر‎","广东","இலங்கை","இந்தியா","հայ","新加坡","‏فلسطين‎","テスト","政务","xperia","xxx","xyz","yachts","yahoo","yamaxun","yandex","ye","yodobashi","yoga","yokohama","you","youtube","yt","yun","za","zappos","zara","zero","zip","zippo","zm","zone","zuerich","zw"]]==]
	domains = util.JSONToTable(domains)

	local tlds = {}
	for i = 1, #domains do
		tlds[domains[i]], domains[i] = true, nil
	end

	local protocols = {["http://"] = 0, ["https://"] = 0}
	local pattern = "(([%w_.~!*:@&+$/?%%#-]-)(%w[-.%w]*%.)(%w+)(:?)(%d*)(/?)([%w_.~!*:@&+$/?%%#=-]*))"

	function scb.find_url(text, start)
		local pos = start
		while true do
			local pos_start, pos_end, url, prot, subd, tld, colon, port, slash, path = text:find(pattern, pos)
			if not pos_start then break end

			if protocols[prot:lower()] == (1 - #slash) * #path and not subd:find("%W%W")
				and (colon == "" or port ~= "" and port + 0 < 65536)
				and (tlds[tld:lower()] or tld:find("^%d+$") and subd:find("^%d+%.%d+%.%d+%.$")
				and math.max(tld, subd:match("^(%d+)%.(%d+)%.(%d+)%.$")) < 256)
			then
				return pos_start, url, pos_end
			end

			pos = pos_end + 1
		end
	end
end
--addons/scb_chatbox/lua/scb/settings/tabs/client.lua:
if SCB_LOADED then return end

local vgui = vgui

local ipairs = ipairs

local scb = scb
local SUI = scb.SUI
local language = scb.language

local toggle_convars = {
	{
		title = "show_time",
		convar = "scb_show_timestamps",
	},
	{
		title = "disable_rainbow",
		convar = "scb_disable_rainbow_colors",
		value = "0"
	},
	{
		title = "disable_flashing",
		convar = "scb_disable_flashing_texts",
		value = "0"
	},
	{
		title = "blur_theme",
		convar = "scb_blur_theme",
		value = SUI.current_theme == "Blur" and "1" or "0",
		on_change = function(value)
			SUI.SetTheme(value == "1" and "Blur" or "Dark")
		end
	},
	{
		title = "join_messages",
		convar = "scb_joindisconnect_message",
		value = "1"
	},
	{
		"number",
		title = "scale",
		convar = "scb_scale",
		value = "5",
		min = 1,
		max = 9,
		load = function(slider, convar)
			slider:GetParent():SetWide(110)

			slider:SetDecimals(0)
			slider:SetMinMax(1, 9)
			slider.Knob:SUI_TDLib()

			local on_mouse_released = function()
				convar:SetInt(slider:GetValue())
			end
			slider:On("OnMouseReleased", on_mouse_released)
			slider.Knob:On("OnMouseReleased", on_mouse_released)

			slider:SetValue(scb.to_new_range(SUI.GetScale(), 0.5, 1.5, 1, 9))
		end,
		on_change = function(value)
			SUI.SetScale(scb.to_new_range(value, 1, 9, 0.5, 1.5))
		end
	},
	{
		"number",
		title = "messages_fade",
		convar = "scb_message_fade_out_time",
		value = "6",
		min = 0,
		max = 60,
		load = function(slider, convar)
			slider:GetParent():SetWide(160)

			slider:SetDecimals(0)
			slider:SetMinMax(0, 60)
			slider.Knob:SUI_TDLib()

			local on_mouse_released = function()
				convar:SetFloat(slider:GetValue())
			end
			slider:On("OnMouseReleased", on_mouse_released)
			slider.Knob:On("OnMouseReleased", on_mouse_released)

			slider:SetValue(convar:GetFloat())
		end
	},
	{
		"number",
		title = "max_messages",
		convar = "scb_max_messages",
		value = "200",
		min = 100,
		max = 400,
		load = function(slider, convar)
			slider:GetParent():SetWide(160)

			slider:SetDecimals(0)
			slider:SetMinMax(100, 400)
			slider.Knob:SUI_TDLib()

			local on_mouse_released = function()
				convar:SetInt(slider:GetValue())
			end
			slider:On("OnMouseReleased", on_mouse_released)
			slider.Knob:On("OnMouseReleased", on_mouse_released)

			slider:SetValue(convar:GetInt())
		end
	}
}

if scb.config.enable_avatars then
	table.insert(toggle_convars, 1, {
		title = "show_avatars",
		convar = "scb_show_avatars",
	})
end

if not scb.config.enable_custom_join_messages and not scb.config.enable_custom_leave_messages then
	for k, v in ipairs(toggle_convars) do
		if v.convar == "scb_joindisconnect_message" then
			table.remove(toggle_convars, k)
			break
		end
	end
end

for _, v in ipairs(toggle_convars) do
	local convar = CreateClientConVar(v.convar, v.value or "1", true, false, "", v.min or 0, v.max or 1)

	if v.on_change then
		v.on_change(convar:GetString())
		cvars.AddChangeCallback(v.convar, function(_, _, value_new)
			v.on_change(value_new, v.panel)
		end)
	end
end

return {
	title = language.client_title,
	pos = 1,
	check = false,
	func = function(parent)
		local body = parent:Add("SCB.ScrollPanel")
		body:Dock(FILL)
		body:DockMargin(0, 1, 0, 0)

		local add_setting = function(title, pnl)
			local setting = body:Add("SCB.LabelPanel")
			setting:DockMargin(4, 4, 4, 0)
			setting:SetLabel(title)
			setting:SetPanel(pnl)
			return setting
		end

		for _, v in ipairs(toggle_convars) do
			local panel
			if v[1] == "number" then
				panel = vgui.Create("SCB.NumberSlider")

				v.panel = panel.slider
				v.load(panel.slider, v.convar and GetConVar(v.convar))
			else
				panel = vgui.Create("SCB.ToggleButton")
				panel:SetConVar(v.convar)
			end

			add_setting(language[v.title], panel)
		end

		local reset_size = vgui.Create("SCB.Button")
		reset_size:SetText("Reset")
		reset_size:SetSize(70, 24)
		reset_size:On("DoClick", function()
			scb.chatbox:SetSize(480, 220)
		end)
		add_setting(language.reset_size, reset_size)

		local reset_position = vgui.Create("SCB.Button")
		reset_position:SetText("Reset")
		reset_position:SetSize(70, 24)
		reset_position:On("DoClick", function()
			scb.chatbox:SetPos(sui.scale(18), ScrH() - scb.chatbox:GetTall() - sui.scale(170))
			scb.chatbox:OnPosChanged()
		end)
		add_setting(language.reset_position, reset_position)

		local clear_cache = vgui.Create("SCB.Button")
		clear_cache:SetText("Clear")
		clear_cache:SetSize(70, 24)

		clear_cache:On("DoClick", function()
			SUI.ClearImages()
		end)

		add_setting(language.clear_reload, clear_cache)

		return body
	end
}

--addons/scb_chatbox/lua/scb/cl_chatbox.lua:
if SCB_LOADED then return end

local draw = draw
local surface = surface
local math = math
local hook = hook
local gui = gui
local net = net

local IsValid = IsValid
local ipairs = ipairs

local color_white = color_white

local scb = scb
local sui = sui
local SUI = scb.SUI
local utf8 = sui.utf8
local language = scb.language

for k, v in ipairs({18, 16, 14}) do
	_G["SCB_" .. v] = SUI.CreateFont(tostring(v), "Roboto", v)
end

scb.pattern = "%{ *([%w_%#%$@%*!]+)([^%{}]-) *%}"

local SetVisible = FindMetaTable("Panel").SetVisible

function scb.open_parsers_menu()
	if IsValid(scb.parsers_menu) then
		return scb.parsers_menu:Remove()
	end

	local text_entry = scb.chatbox.text_entry

	local parsers_menu = vgui.Create("SCB.Frame")
	scb.parsers_menu = parsers_menu

	parsers_menu:Center()
	parsers_menu:MakePopup()
	parsers_menu:SetTitle("SCB | Chat Parsers")
	parsers_menu:AddAnimations(320, 340)

	local parsers_list = parsers_menu:Add("SCB.ScrollPanel")
	parsers_list:Dock(FILL)
	parsers_list:DockMargin(4, 4, 4, 4)
	parsers_list:InvalidateParent(true)
	parsers_list:InvalidateLayout(true)

	for k, v in ipairs(scb.chat_parsers) do
		local parser = parsers_list:Add("DButton")
		parser:Dock(TOP)
		parser:DockMargin(2, 2, 2, 2)
		parser:DockPadding(2, 2, 2, 2)
		parser:InvalidateParent(true)
		parser:SetText("")

		parser:SUI_TDLib()
		parser:ClearPaint()
		parser:Background(SUI.GetColor("on_sheet"), 3)
		parser:FadeHover(SUI.GetColor("on_sheet_hover"), _, 3)

		function parser:DoClick()
			parsers_menu:Remove()
			scb.chatbox:MoveToFront()
			text_entry:RequestFocus()
			text_entry:AddValue(v[3] .. " ")
		end

		local title = parser:Add("SCB.Label")
		title:Dock(TOP)
		title:SetAutoStretchVertical(true)
		title:SetWrap(true)
		title:SetFont(SCB_16)
		title:SetText(v[1])
		title:InvalidateParent(true)

		local example = parser:Add("SCB.ChatLine")
		example:Dock(TOP)
		example:DockMargin(0, 1, 0, 0)
		example:InvalidateParent(true)
		example:InvalidateLayout(true)
		example:Parse(v[2])
		example:SetMouseInputEnabled(false)

		function parser:PerformLayout()
			self:SizeToChildren(false, true)
		end
	end
end

local function invalidate_children(self, recursive)
	local children = self:GetChildren()
	for i = 1, #children do
		if recursive then
			invalidate_children(children[i])
		else
			children[i]:InvalidateLayout(true)
		end
	end
	self:InvalidateLayout(true)
end

function scb.create_chatbox()
	if scb.chatbox then return end

	sui.TDLib.Start()

	local frame = vgui.Create("SCB.Frame", nil, "SCB")
	scb.chatbox = frame

	local c_x = CreateClientConVar("scb_x", sui.scale(18), true, false, "")
	local c_y = CreateClientConVar("scb_y", ScrH() - SUI.Scale(220) - sui.scale(170), true, false, "")
	local c_w = CreateClientConVar("scb_w", 480, true, false, "")
	local c_h = CreateClientConVar("scb_h", 220, true, false, "")

	frame.SetSize = frame.RealSetSize
	-- remove scaling for chatbox
	SUI.RemoveScaleHook(frame)

	frame:SetSizable(true)
	frame:SetMinWidth(SUI.Scale(300))
	frame:SetMinHeight(SUI.Scale(160))
	frame:SetSize(c_w:GetInt(), c_h:GetInt())
	frame:SetPos(c_x:GetInt(), c_y:GetInt())
	frame:ParentToHUD()
	frame:MakePopup()

	frame.title.background_color = true

	local chatbox_title = scb.config.chatbox_title
	frame:SetTitle(chatbox_title)
	if chatbox_title:find("SERVER_NAME") or chatbox_title:find("PLAYER_COUNT") then
		local delay = 2
		local next_run = UnPredictedCurTime()

		frame:On("Think", function(s)
			if UnPredictedCurTime() < next_run then return end
			next_run = UnPredictedCurTime() + delay

			s:SetTitle(chatbox_title:gsub("SERVER_NAME", GetHostName()):gsub("PLAYER_COUNT", player.GetCount()))
		end)
	end

	function frame:OnPosChanged()
		c_x:SetInt(self.x)
		c_y:SetInt(self.y)
	end

	function frame:OnSizeChanged(w, h)
		c_w:SetInt(w)
		c_h:SetInt(h)
	end

	function frame:AddPanelToHide(panel)
		if not self.panels_to_hide then
			self.panels_to_hide = {self}
		end
		table.insert(self.panels_to_hide, panel)
	end

	function frame:SetVisible(visible)
		self.hidden = not visible
		local panels_to_hide = self.panels_to_hide
		for i = 1, #panels_to_hide do
			local v = panels_to_hide[i]
			v.Paint, v.oldPaint = visible and (v.oldPaint or v.Paint) or nil, not visible and v.Paint or nil
			if v.background_color or v.old_bg_color then
				v.background_color, v.old_bg_color = visible and (v.old_bg_color or v.background_color) or nil, not visible and v.background_color or nil
				v:SetBGColor(v.background_color)
			end
		end
		return self.hidden
	end

	function frame:IsVisible()
		return not self.hidden
	end

	frame.close.DoClick = chat.Close

	local scroll_panel = frame:Add("SCB.ScrollPanel")
	scroll_panel:Dock(FILL)
	scroll_panel:DockMargin(4, 4, 4, 0)
	scroll_panel:SetFromBottom(true)

	function scroll_panel:ScrollToBottom()
		self:GetParent():InvalidateLayout(true)
		invalidate_children(self)

		local vbar = self.VBar
		vbar:SetScroll(vbar.CanvasSize)
	end

	local canvas = scroll_panel:GetCanvas()
	canvas:DockPadding(2, 2, 2, 2)

	function scroll_panel:ShouldScrollDown()
		local vbar = self.VBar
		local canvas_size = vbar.CanvasSize
		return frame.hidden or canvas_size == 1 or canvas_size <= vbar.scroll_target
	end

	local count = 0
	local max_messages_convar = GetConVar("scb_max_messages")
	local fixed_width = false
	function scroll_panel:ChildAdded()
		local vbar = self.VBar
		if vbar.Enabled then
			if not fixed_width then
				for k, v in ipairs(canvas.children) do
					if v.ScaleChanged then
						v:ScaleChanged()
					end
				end
				fixed_width = true
				return self:ChildAdded()
			end
		else
			fixed_width = nil
		end

		count = count + 1

		local max = max_messages_convar:GetInt()
		if count <= max then return end

		local down = self:ShouldScrollDown()

		local full_h = 0
		local children = canvas.children
		for i = count, max + 1, -1 do
			local child = children[i - max]
			if not child.being_removed then
				child.being_removed = true
				full_h = full_h + child:GetTotalH()
				child:Remove()

				count = count - 1
			end
		end

		local scroll = vbar.Scroll
		if down then
			vbar.Scroll = scroll - full_h
		else
			vbar.Scroll = scroll - full_h
			vbar.scroll_target = scroll
		end
	end

	frame:InvalidateLayout(true)
	invalidate_children(frame, true)

	local preview = vgui.Create("Panel")
	preview:SetMouseInputEnabled(false)
	preview:ParentToHUD()

	local preview_bg = vgui.Create("Panel")
	preview_bg:ParentToHUD()
	preview_bg:MoveToBack()
	SetVisible(preview_bg, false)

	preview_bg:Blur()
		:Background(Color(50, 50, 50, 200))

	frame:On("PerformLayout", function(s, w, h)
		local f_x, f_y = s:GetPos()
		local new_x, new_y = f_x + ((w / 2) - ((preview.w or 0) / 2)), f_y + h + 4
		preview:SetPos(new_x, new_y)
		preview_bg:SetPos(new_x - 4, new_y - 4)
	end)

	local text_entry = frame:Add("SCB.TextEntry")
	text_entry:Dock(BOTTOM)
	text_entry:DockMargin(4, 4, 4, 4)
	text_entry:SetTall(24)
	text_entry:SetPlaceholder(language.type_something)
	text_entry:SetFont(SCB_18)
	text_entry:SetMultiline(true)
	text_entry:SetVerticalScrollbarEnabled(true)
	text_entry:InvalidateParent(true)
	text_entry:SetMaxChars(512)
	text_entry:SetNoBar(true)
	text_entry.no_scale = true

	if scb.config.hide_language_sign then
		text_entry:SetDrawLanguageID(false)
	end

	function text_entry:OnEnter()
		local txt = self:GetValue()
		if txt == "" then chat.Close() return end
		local length = #txt
		net.Start(frame.bteam ~= 1 and "SCB.SendMessageTeam" or "SCB.SendMessage")
			net.WriteUInt(length, 16)
			net.WriteData(txt, length)
		net.SendToServer()
		self:AddHistory(txt)
		chat.Close()
	end

	local old_Paint = text_entry.Paint
	function text_entry:Paint(w, h)
		local outline = SUI.GetColor("scroll_panel_outline")
		if outline then
			sui.TDLib.DrawOutlinedBox(3, 0, 0, w, h, SUI.GetColor("scroll_panel"), outline, 1)
		else
			draw.RoundedBox(3, 0, 0, w, h, SUI.GetColor("scroll_panel"))
		end

		old_Paint(self, w, h)
	end

	function text_entry:OnValueChange(value)
		local down = scroll_panel:ShouldScrollDown()

		-- https://github.com/ValveSoftware/source-sdk-2013/blob/0d8dceea4310fde5706b3ce1c70609d72a38efdf/mp/src/vgui2/vgui_controls/TextEntry.cpp#L3790
		self:SetTall(self:GetNumLines() * (SUI.Scale(18) --[[font size]] + 1) + 1 + 2)

		if down then
			scroll_panel:ScrollToBottom()
		end

		if value == "" then
			gui.InternalKeyCodeTyped(KEY_LEFT)
		end

		hook.Run("ChatTextChanged", value)
	end
	text_entry:OnValueChange("")

	do
		local emojis_table = {
			"grinning", "grin", "joy",
			"smiley", "smile", "sweat_smile",
			"laughing", "innocent", "smiling_imp",
			"wink", "blush", "yum", "relieved",
			"heart_eyes", "sunglasses", "smirk",
			"neutral_face", "expressionless", "unamused",
			"sweat", "pensive", "confused",
			"rage", "partying_face", "cold_face",
			"hot_face", "face_with_cowboy_hat"
		}

		local real_size = 0
		local mat, padding = SUI.Material("scb/emojis/flushed.png"), 3

		local emojis_button = text_entry:Add("DButton")
		emojis_button:SetText("")
		emojis_button:SetMouseInputEnabled(true)
		emojis_button:NoClipping(true)

		function emojis_button:IsActive()
			return self:IsHovered() or IsValid(scb.emojis_menu)
		end

		local inactive_col = Color(175, 175, 175)
		function emojis_button:Paint(w, h)
			surface.SetDrawColor(self:IsActive() and color_white or inactive_col)
			surface.SetMaterial(mat)
			surface.DrawTexturedRectRotated(w * 0.5, h * 0.5, real_size, real_size, 0)
		end

		function emojis_button:OnCursorEntered()
			if not IsValid(scb.emojis_menu) then
				mat = SUI.Material("scb/emojis/" .. emojis_table[math.random(1, #emojis_table)] .. ".png")
			end
		end

		function emojis_button:Think()
			self:MoveToFront()
			real_size = Lerp(RealFrameTime() * 15, real_size, self:IsActive() and SUI.Scale(22) or SUI.Scale(18))
		end

		function emojis_button:DoClick()
			if IsValid(scb.emojis_menu) then
				return self:OnRemove()
			end

			local emojis_menu = vgui.Create("SCB.EmojiList")
			emojis_menu.button = self
			emojis_menu:FixPos()

			scb.emojis_menu = emojis_menu
		end

		function emojis_button:OnRemove()
			if IsValid(scb.emojis_menu) then
				scb.emojis_menu:Remove()
			end
		end

		text_entry:On("PerformLayout", function(s, w, h)
			local size = SUI.ScaleEven(18)
			emojis_button:SetSize(size, size)
			emojis_button:SetPos(w - (size + padding), h / 2 - size / 2)

			local vbar = s:GetChildren()[1]
			if vbar then
				vbar:Hide()
				vbar:SetWide(math.Round(size + padding))
			end
		end)

		frame.emojis_button = emojis_button
		frame:AddPanelToHide(emojis_button)
	end

	-- Message Preview
	text_entry:On("OnValueChange", function(self, value)
		preview:SetWide(SUI.Scale(340))
		preview:Clear()
		SetVisible(preview_bg, false)

		if value == "" then return end

		local line = preview:Add("SCB.ChatLine")
		line:SetPlayer(LocalPlayer())
		line:SetAlpha(255)
		line:Parse(value)
		line:SizeToChildren(true, true)

		preview:SizeToChildren(false, true)
		preview:SetWide(line:GetMessageW())
		preview.w = line:GetMessageW()
		preview_bg:SetSize(preview.w + 8, preview:GetTall() + 8)
		SetVisible(preview_bg, true)
	end)
	--

	-- Emoji Select
	local emoji_list

	local open_emojis_list = function(emoji_name, start, _end)
		local selected_text
		if IsValid(emoji_list) then
			selected_text = emoji_list.selected_emoji and emoji_list.selected_emoji.name
			emoji_list:Remove()
		end

		local emojis = scb.search_emojis(emoji_name)
		if #emojis == 0 then return end

		emoji_list = frame:Add("SCB.EmojisSelect")
		emoji_list:SetWide(text_entry:GetWide())
		emoji_list:SetTextEntry(text_entry)
		emoji_list:SetStartEnd(start, _end)

		for _, v in ipairs(emojis) do
			local emoji = emoji_list:AddEmoji(v.name)
			if emoji.name == selected_text then
				emoji_list.selected_emoji = emoji
			end

			if #emoji_list.emojis == math.floor(SUI.Scale(120) / SUI.Scale(22)) then
				break
			end
		end

		emoji_list:SetPos(text_entry.x, text_entry.y - emoji_list:GetTall())
	end

	local typing_emoji = function()
		local value = text_entry:GetValue()
		local start, _end, emoji_name = 0
		while true do
			start, _end, emoji_name = value:find("%:([%w_]+)", _end)
			if not start then break end
			if utf8.len(value:sub(1, _end)) == text_entry:GetCaretPos() and not value:sub(_end + 1, _end + 1):match("%S") then
				return open_emojis_list(emoji_name:lower(), start, _end)
			end
			_end = _end + 1
		end

		if IsValid(emoji_list) then
			emoji_list:Remove()
		end
	end

	local old = text_entry.OnKeyCodeTyped
	function text_entry:OnKeyCodeTyped(code)
		if frame.hidden then return end

		if code == KEY_BACKQUOTE then
			gui.HideGameUI()
		elseif emoji_list and emoji_list[code] then
			return emoji_list[code](emoji_list)
		elseif code == KEY_ESCAPE then
			gui.HideGameUI()
			chat.Close()
			return
		elseif code == KEY_TAB then
			local text = hook.Run("OnChatTab", self:GetValue())
			if scb.isstring(text) then
				self:SetValue(text)
			end
			self:SetCaretPos(#self:GetValue())
			self:RequestFocus()
			return true
		end

		return old(self, code)
	end

	text_entry:On("OnValueChange", typing_emoji)
	text_entry:On("OnKeyCodeReleased", function(_, code)
		if code == KEY_LEFT or code == KEY_RIGHT then
			typing_emoji()
		end
	end)

	SUI.OnScaleChanged("EmojisListRemove", function()
		if IsValid(emoji_list) then
			emoji_list:Remove()
		end

		timer.Simple(0, function()
			text_entry:OnValueChange(text_entry:GetValue())
		end)
	end)
	--

	local settings = frame:AddHeaderButton("scb/settings.png", "settings", function()
		scb.open_settings()
	end)
	local parsers = frame:AddHeaderButton("scb/mind.png", "settings", function()
		scb.open_parsers_menu()
	end)

	frame:AddPanelToHide(frame.header)
	frame:AddPanelToHide(frame.title)
	frame:AddPanelToHide(frame.close)
	frame:AddPanelToHide(frame.close.image)
	frame:AddPanelToHide(settings)
	frame:AddPanelToHide(settings.image)
	frame:AddPanelToHide(parsers)
	frame:AddPanelToHide(parsers.image)
	frame:AddPanelToHide(scroll_panel)
	frame:AddPanelToHide(scroll_panel.VBar)
	frame:AddPanelToHide(scroll_panel.VBar.btnGrip)
	frame:AddPanelToHide(text_entry)

	frame.scroll_panel = scroll_panel
	frame.text_entry = text_entry

	sui.TDLib.End()
end

SUI.RemoveTheme("Light")

SUI.AddToTheme("Dark", {
	settings = Color(255, 255, 255, 133),
	settings_hover = Color(65, 185, 255),
	settings_press = Color(255, 255, 255, 30),

	emoji_select_menu = Color(18, 18, 18),
	emoji_select_menu_selected = Color(200, 200, 200, 1),
})

SUI.AddToTheme("Blur", {
	settings = Color(200, 200, 200),
	settings_hover = Color(65, 185, 255),
	settings_press = Color(255, 255, 255, 30),

	emoji_select_menu = Color(50, 50, 50, 230),
	emoji_select_menu_selected = Color(40, 40, 40),
})
--gamemodes/starwarsrp/gamemode/modules/medicsystem_droid/injuries/fragments.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--       Medicsystem | Injury        --
---------------------------------------

local Injury = {}

Injury.Name = "Explosionsfragmente"
Injury.Treatments = {
	["pliers"] = true,
	["plate"] = true,
	["welder"] = true
}

Injury.Detection = {
	["Medicsystem.AddInjury"] = function(ply, hitgroup, dmgInfo)
		-- Player must be a droid
		if not ply:IsDroid() then return end

		if dmgInfo:GetDamageType() == DMG_BLAST or dmgInfo:GetDamageType() == DMG_DIRECT then
			local success, message = Medicsystem:AddInjury(ply, hitgroup, dmgInfo:GetDamage(), "fragments")
			if not success and message then
				LogError("Medicsystem: Couldn't add injury 'fragments' to player " .. ply:Nick() .. "(" .. message .. ").")
			end
		end
	end,
}

Medicsystem:RegisterInjury("fragments", Injury)
--gamemodes/starwarsrp/gamemode/modules/medicsystem_cwrp/treatments/adrenaline.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--      Medicsystem | Treatment      --
---------------------------------------

local Treatment = {}

Treatment.Name = "Adrenalin"
Treatment.Description = "Bewirkt eine Steigerung der Herzfrequenz, lässt ebenfalls den Blutdruck steigen."

Treatment.TreatmentTime = 3
Treatment.UseMessage = "verwendet Adrenalin."

Treatment.Type = {["Injector"] = true}

Treatment.TreatmentSound = function(self, ply)
	return "medkit/squirt.wav"
end

Treatment.CanLocalUse = function(self, ply, patient, hitgroup, injury)
	-- Player mustn't be a droid
	if patient:IsDroid() then return false end

	return true
end

Treatment.LocalUseFunction = function(self, ply, patient, hitgroup, injury)
	Medicsystem:SendMessage(ply, {
		team.GetColor(ply:Team()),
		ply:GetCurrentCharacterFullName(),
		" injizierte ",
		self.Name,
		" in ",
		injury.name,
		" von ",
		Medicsystem:GetCurrentCharacterFullName(patient),
		"."
	})

	return true
end

Treatment.CanGlobalUse = function(self, ply, patient, hitgroup)
	-- Patient mustn't be a droid
	if patient:IsDroid() then return false end

	-- Patient must be a player and be alive
	if not patient:IsPlayer() or not patient:Alive() then return false end

	return true
end

Treatment.GlobalUseFunction = function(self, ply, patient, hitgroup)
	Medicsystem:SendMessage(ply, {
		team.GetColor(ply:Team()),
		ply:GetCurrentCharacterFullName(),
		" injizierte ",
		self.Name,
		" in den/das ",
		hitgroup,
		" von ",
		Medicsystem:GetCurrentCharacterFullName(patient),
		"."
	})

	local timerName = "Adrenalin_Time_HealthLoss" .. patient:SteamID64()
	if timer.Exists(timerName) then
		timer.Remove(timerName)
		local dmgInfo = DamageInfo()
		dmgInfo:SetDamageType(DMG_POISON)
		dmgInfo:SetDamage(patient:GetMaxHealth())

		Medicsystem:AddInjury(patient, hitgroup, dmgInfo:GetDamage(), "poisoning")
		Medicsystem:Kill(patient)
		return
	else
		patient:SetHealth(patient:Health() + 100)

		patient.OldWalkSpeed = patient:GetWalkSpeed()
		patient.OldRunSpeed = patient:GetRunSpeed()

		patient:SetWalkSpeed(patient:GetWalkSpeed() * 1.25)
		patient:SetRunSpeed(patient:GetRunSpeed() * 1.25)
	end

	timer.Create(timerName, 120, 1, function()
		patient:SetWalkSpeed(patient.OldWalkSpeed * 0.75)
		patient:SetRunSpeed(patient.OldRunSpeed * 0.75)

		local timerName1 = "Adrenalin_MovementSpeedLoss" .. patient:SteamID64()
		timer.Create(timerName1, 300, 1, function()
			if not IsValid(patient) or not patient:Alive() then return end

			patient:SetWalkSpeed(patient.OldWalkSpeed)
			patient:SetRunSpeed(patient.OldRunSpeed)
		end)

		local timerName2 = "Adrenalin_HealthLoss" .. patient:SteamID64()
		timer.Create(timerName2, 1, 60, function()
			if not IsValid(patient) or not patient:Alive() then timer.Remove(timerName2) end

			if patient:Health() <= 2 and patient:Alive() then
				local dmgInfo = DamageInfo()
				dmgInfo:SetDamageType(DMG_POISON)
				dmgInfo:SetDamage(patient:GetMaxHealth())

				Medicsystem:AddInjury(patient, hitgroup, dmgInfo:GetDamage(), "poisoning")
				Medicsystem:Kill(patient)
			elseif patient:Health() > 2 then
				patient:SetHealth(patient:Health() - 2)
			end
		end)
	end)

	return true
end

Treatment.Hooks = {
	["Player.ChangedCharacter"] = function(ply)
		local timerName1 = "Adrenalin_MovementSpeedLoss" .. ply:SteamID64()
		if timer.Exists(timerName1) then
			timer.Remove(timerName1)
		end

		local timerName2 = "Adrenalin_HealthLoss" .. ply:SteamID64()
		if timer.Exists(timerName2) then
			timer.Remove(timerName2)
		end
	end,

	["PlayerDeath"] = function(ply)
		local timerName1 = "Adrenalin_MovementSpeedLoss" .. ply:SteamID64()
		if timer.Exists(timerName1) then
			timer.Remove(timerName1)
		end

		local timerName2 = "Adrenalin_HealthLoss" .. ply:SteamID64()
		if timer.Exists(timerName2) then
			timer.Remove(timerName2)
		end
	end
}

Medicsystem:RegisterTreatment("adrenaline", Treatment)




--gamemodes/starwarsrp/gamemode/modules/medicsystem_cwrp/treatments/bacta.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--      Medicsystem | Treatment      --
---------------------------------------

local Treatment = {}

Treatment.Name = "Bacta"
Treatment.Description = "Das am häufigsten verwendete Wundheilmittel."

Treatment.TreatmentTime = 4
Treatment.UseMessage = "verwendet Bacta."

Treatment.Type = {["Kit"] = true, ["FirstAid"] = true}

Treatment.TreatmentSound = function(self, ply)
	return "medkit/cansound.wav"
end

Treatment.CanLocalUse = function(self, ply, patient, hitgroup, injury)
	-- Patient mustn't be a droid
	if patient:IsDroid() then return false end

	return true
end

Treatment.LocalUseFunction = function(self, ply, patient, hitgroup, injury)
	Medicsystem:SendMessage(ply, {
		team.GetColor(ply:Team()),
		ply:GetCurrentCharacterFullName(),
		" schmierte ",
		self.Name,
		" auf ",
		injury.name,
		" von ",
		Medicsystem:GetCurrentCharacterFullName(patient),
		"."
	})

	local injuryData = Medicsystem.Injuries[Medicsystem:TranslateInjury(injury.name)]
	if injuryData.BactaHeal and injury.severity <= injuryData.BactaHeal then
		Medicsystem:InjuryTreated(patient, hitgroup, Medicsystem:TranslateInjury(injury.name))
		return false
	end

	return true
end

Treatment.CanGlobalUse = function(self, ply, patient, hitgroup)
	-- Patient mustn't be a droid
	if patient:IsDroid() then return false end

	if patient:IsPlayer() and patient:Alive() then return true end

	return false
end

Treatment.GlobalUseFunction = function(self, ply, patient, hitgroup)
	Medicsystem:SendMessage(ply, {
		team.GetColor(ply:Team()),
		ply:GetCurrentCharacterFullName(),
		" schmierte ",
		self.Name,
		" über den/das ",
		hitgroup,
		" von ",
		Medicsystem:GetCurrentCharacterFullName(patient),
		"."
	})

	patient:SetHealth(math.min(math.ceil(patient:Health() + 30), patient:GetMaxHealth()))

	return false
end

Medicsystem:RegisterTreatment("bacta", Treatment)




--gamemodes/starwarsrp/gamemode/modules/medicsystem_cwrp/treatments/bactabandage.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--      Medicsystem | Treatment      --
---------------------------------------

local Treatment = {}

Treatment.Name = "Bactaverband"
Treatment.Description = "Ein Wundverband getränkt in Bacta."

Treatment.TreatmentTime = 4
Treatment.UseMessage = "verwendet einen Bactaverband."

Treatment.Type = {["Kit"] = true, ["FirstAid"] = true}

Treatment.TreatmentSound = function(self, ply)
	return "medkit/cansound.wav"
end

Treatment.CanLocalUse = function(self, ply, patient, hitgroup, injury)
	-- Patient mustn't be a droid
	if patient:IsDroid() then return false end

	return true
end

Treatment.LocalUseFunction = function(self, ply, patient, hitgroup, injury)
	Medicsystem:SendMessage(ply, {
		team.GetColor(ply:Team()),
		ply:GetCurrentCharacterFullName(),
		" verband ",
		injury.name,
		" von ",
		Medicsystem:GetCurrentCharacterFullName(patient),
		" mit einem ",
		self.Name,
		"."
	})

	return true
end

Treatment.CanGlobalUse = function(self, ply, patient, hitgroup)
	return false
end

Medicsystem:RegisterTreatment("bactabandage", Treatment)




--gamemodes/starwarsrp/gamemode/modules/medicsystem_cwrp/treatments/bonemer.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--      Medicsystem | Treatment      --
---------------------------------------

local Treatment = {}

Treatment.Name = "Bonemer"
Treatment.Description = "Ein künstliches Knochenergänzungsmittel, welches dazu eingesetzt werden kann, Knochen zu reparieren, ersetzen oder zu ergänzen."

Treatment.TreatmentTime = 3
Treatment.UseMessage = "verwendet Bonemer."

Treatment.Type = {["Injector"] = true}

Treatment.TreatmentSound = function(self, ply)
	return "medkit/squirt.wav"
end

Treatment.CanLocalUse = function(self, ply, patient, hitgroup, injury)
	-- Patient mustn't be a droid
	if patient:IsDroid() then return false end

	return true
end

Treatment.LocalUseFunction = function(self, ply, patient, hitgroup, injury)
	local injuries = {["Glatter Bruch"] = true, ["Offener Bruch"] = true}

	if injuries[injury.name] then
		Medicsystem:SendMessage(ply, {
			team.GetColor(ply:Team()),
			ply:GetCurrentCharacterFullName(),
			" injizierte ",
			self.Name,
			" in den Bruch von ",
			Medicsystem:GetCurrentCharacterFullName(patient),
			"."
		})

		return true
	else
		Medicsystem:SendMessage(ply, {
			team.GetColor(ply:Team()),
			ply:GetCurrentCharacterFullName(),
			" injizierte ",
			self.Name,
			" in den/das ",
			hitgroup,
			" von ",
			Medicsystem:GetCurrentCharacterFullName(patient),
			"."
		})
	end
end

Treatment.CanGlobalUse = function(self, ply, patient, hitgroup)
	return false
end

Medicsystem:RegisterTreatment("bonemer", Treatment)




--gamemodes/starwarsrp/gamemode/modules/medicsystem_cwrp/treatments/forceps.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--      Medicsystem | Treatment      --
---------------------------------------

local Treatment = {}

Treatment.Name = "Pinzette"
Treatment.Description = "Mit einer Pinzette können Fremdkörper oder andere kleine Objekte entfernt werden."

Treatment.TreatmentTime = 8
Treatment.UseMessage = "verwendet eine Pinzette."

Treatment.Type = {["Kit"] = true, ["Opkit"] = true}

Treatment.TreatmentSound = function(self, ply)
	return "medkit/buzz.wav"
end

Treatment.CanLocalUse = function(self, ply, patient, hitgroup, injury)
	-- Patient mustn't be a droid
	if patient:IsDroid() then return false end

	if injury.name == "Explosionsfragmente" then return true end

	return false
end

Treatment.LocalUseFunction = function(self, ply, patient, hitgroup, injury)
	Medicsystem:SendMessage(ply, {
		team.GetColor(ply:Team()),
		ply:GetCurrentCharacterFullName(),
		" entfernte ",
		injury.name,
		" aus dem ",
		hitgroup,
		" von ",
		Medicsystem:GetCurrentCharacterFullName(patient),
		" mit Hilfe einer ",
		self.Name,
		"."
	})

	return true
end

Treatment.CanGlobalUse = function(self, ply, patient, hitgroup)
	return false
end

Medicsystem:RegisterTreatment("forceps", Treatment)




--gamemodes/starwarsrp/gamemode/modules/medicsystem_cwrp/injuries/burn.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--       Medicsystem | Injury        --
---------------------------------------

local Injury = {}

Injury.Name = "Brandwunde"
Injury.Treatments = {
	["anticeptind"] = true,
	["nullicaine"] = true,
	["enkephalin"] = true,
	["dermaseal"] = true,
	["woundglue"] = true,
	["bactabandage"] = true
}

-- Until which severity a single bacta can heal the injury
Injury.BactaHeal = 3

Injury.Detection = {
	["Medicsystem.AddInjury"] = function(ply, hitgroup, dmgInfo)
		-- Player mustn't be a droid
		if ply:IsDroid() then return end

		local damageTypes = {[DMG_AIRBOAT] = true, [DMG_BULLET] = true, [DMG_BURN] = true, [DMG_SLOWBURN] = true, [DMG_ENERGYBEAM] = true, [DMG_PLASMA] = true, [DMG_DIRECT] = true}
		if damageTypes[dmgInfo:GetDamageType()] then
			-- Runs the injury addition
			local success, message = Medicsystem:AddInjury(ply, hitgroup, dmgInfo:GetDamage(), "burn")
			if not success and message then
				LogError("Medicsystem: Couldn't add injury 'burn' to player " .. ply:Nick() .. "(" .. message .. ").")
			end
		end

		if dmgInfo:GetDamageType() == 101010 then
			local hitgroups = {"Rechter Arm", "Linker Arm", "Rechtes Bein", "Linkes Bein", "Thorax", "Abdomen"}

			-- Runs the injury addition
			local success, message = Medicsystem:AddInjury(ply, table.Random(hitgroups), dmgInfo:GetDamage(), "burn")
			if not success and message then
				LogError("Medicsystem: Couldn't add injury 'burn' to player " .. ply:Nick() .. "(" .. message .. ").")
			end
		end
	end,

	["Medicsystem.AddResistanceInjury"] = function(ply, hitgroup, dmgInfo)
		local damageTypes = {[DMG_AIRBOAT] = true, [DMG_BULLET] = true, [DMG_DIRECT] = true}

		if damageTypes[dmgInfo:GetDamageType()] and dmgInfo:GetDamage() >= (ply:GetMaxHealth() * 0.15) then
			-- Runs the injury addition
			local success, message = Medicsystem:AddInjury(ply, hitgroup, dmgInfo:GetDamage() * 0.25, "contusion")
			if not success and message then
				LogError("Medicsystem: Couldn't add injury 'burn' to player " .. ply:Nick() .. "(" .. message .. ").")
			end
		end
	end
}

Medicsystem:RegisterInjury("burn", Injury)
--gamemodes/starwarsrp/gamemode/modules/medicsystem_cwrp/injuries/poisoning.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--       Medicsystem | Injury        --
---------------------------------------

local Injury = {}

Injury.Name = "Vergiftung"
Injury.Treatments = {
	["anticeptind"] = true,
	["cardinex"] = true
}

Injury.scanNeeded = true

Injury.Detection = {
	["Medicsystem.AddInjury"] = function(ply, hitgroup, dmgInfo)
		-- Player mustn't be a droid
		if ply:IsDroid() then return end

		local damageTypes = {[DMG_POISON] = true, [DMG_NERVEGAS] = true}
		if damageTypes[dmgInfo:GetDamageType()] then
			local success, message = Medicsystem:AddInjury(ply, "Thorax", dmgInfo:GetDamage(), "poisoning")
			if not success and message then
				LogError("Medicsystem: Couldn't add injury 'poisoning' to player " .. ply:Nick() .. "(" .. message .. ").")
			end
		end
	end
}

Medicsystem:RegisterInjury("poisoning", Injury)
--gamemodes/starwarsrp/gamemode/modules/medicsystem_cwrp/injuries/smoothfracture.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--       Medicsystem | Injury        --
---------------------------------------

local Injury = {}

Injury.Name = "Glatter Bruch"
Injury.Treatments = {
	["anticeptind"] = true,
	["nullicaine"] = true,
	["bonemer"] = true,
	["splint"] = true,
	["bactabandage"] = true
}

Injury.scanNeeded = true

Injury.Detection = {
	["Medicsystem.AddInjury"] = function(ply, hitgroup, dmgInfo)
		-- Player mustn't be a droid
		if ply:IsDroid() then return end

		-- Checkup fall damage
		if dmgInfo:GetDamageType() == DMG_FALL then
			hitgroup = table.Random({"Linker Arm", "Rechter Arm", "Rechtes Bein", "Linkes Bein"})

			-- If the damage is less than 60% of the maximum lives, the player receives a sprain.
			-- Elseif the damage is less than 90% of the maximum lives, the player receives a smooth fracture.
			-- Elseif the damage is more than 90% of the maximum lives, the player receives a open fracture.
			local damage = dmgInfo:GetDamage()
			if damage < ply:GetMaxHealth() * 0.6 then
				local success, message = Medicsystem:AddInjury(ply, hitgroup, dmgInfo:GetDamage(), "sprain")
				if not success and message then
					LogError("Medicsystem: Couldn't add injury 'sprain' to player " .. ply:Nick() .. "(" .. message .. ").")
				end
			elseif damage < ply:GetMaxHealth() * 0.9 then
				local success, message = Medicsystem:AddInjury(ply, hitgroup, dmgInfo:GetDamage(), "smoothfracture")
				if not success and message then
					LogError("Medicsystem: Couldn't add injury 'smoothfracture' to player " .. ply:Nick() .. "(" .. message .. ").")
				end
			else
				local success, message = Medicsystem:AddInjury(ply, hitgroup, dmgInfo:GetDamage(), "openfracture")
				if not success and message then
					LogError("Medicsystem: Couldn't add injury 'openfracture' to player " .. ply:Nick() .. "(" .. message .. ").")
				end
			end
		end
	end,
}

Medicsystem:RegisterInjury("smoothfracture", Injury)
--gamemodes/starwarsrp/gamemode/modules/medicsystem_cwrp/injuries/sprain.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--       Medicsystem | Injury        --
---------------------------------------

local Injury = {}

Injury.Name = "Verstauchung"
Injury.Treatments = {
	["anticeptind"] = true,
	["nullicaine"] = true,
	["myocaine"] = true,
	["bactabandage"] = true
}

-- Until which severity a single bacta can heal the injury
Injury.BactaHeal = 3

Medicsystem:RegisterInjury("sprain", Injury)
--gamemodes/starwarsrp/gamemode/modules/medicsystem_jedi/treatments/radiorum.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--      Medicsystem | Treatment      --
---------------------------------------

local Treatment = {}

Treatment.Name = "Radiorum Salva"
Treatment.Description = "Eine spezielle Form der Machtheilung."

Treatment.TreatmentTime = 2
Treatment.ForceCustomMessage = true

Treatment.Type = {["Force"] = true}

Treatment.Injuries = {
	["Verstrahlung"] = true
}

Treatment.TreatmentSound = function(self, ply)
	return "lightsaber/force_leap.wav"
end

Treatment.CanLocalUse = function(self, ply, patient, hitgroup, injury)
	return Treatment.Injuries[injury.name]
end

Treatment.LocalUseFunction = function(self, ply, patient, hitgroup, injury)
	local animationTime = ply:SetSequenceOverride("wos_jedi_mindtrick", 1.2)
	timer.Simple(animationTime, function()
		-- Validity check
		if not IsValid(ply) then return end
		if not IsValid(patient) then return end

		-- Sends the message
		Medicsystem:SendMessage(ply, {
			team.GetColor(ply:Team()),
			ply:GetCurrentCharacterFullName(),
			" heilte ",
			injury.name,
			" von ",
			Medicsystem:GetCurrentCharacterFullName(patient),
			" mittels ",
			self.Name,
			"."
		})

		-- Cures the injury
		Medicsystem:InjuryTreated(patient, hitgroup, Medicsystem:TranslateInjury(injury.name))

		-- Heal effect
		local ed = EffectData()
		ed:SetOrigin(ply:GetPos())
		ed:SetEntity(patient)
		util.Effect("rb655_force_heal", ed, true, true)

		return true
	end)
end

Treatment.CanGlobalUse = function(self, ply, patient, hitgroup)
	return false
end

Medicsystem:RegisterTreatment("radiorum", Treatment)




--gamemodes/starwarsrp/gamemode/modules/medicsystem_jedi/treatments/veneficum.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--      Medicsystem | Treatment      --
---------------------------------------

local Treatment = {}

Treatment.Name = "Veneficium Salva"
Treatment.Description = "Eine spezielle Form der Machtheilung."

Treatment.TreatmentTime = 2
Treatment.ForceCustomMessage = true

Treatment.Type = {["Force"] = true}

Treatment.Injuries = {
	["Vergiftung"] = true
}

Treatment.TreatmentSound = function(self, ply)
	return "lightsaber/force_leap.wav"
end

Treatment.CanLocalUse = function(self, ply, patient, hitgroup, injury)
	return Treatment.Injuries[injury.name]
end

Treatment.LocalUseFunction = function(self, ply, patient, hitgroup, injury)
	local animationTime = ply:SetSequenceOverride("wos_jedi_mindtrick", 1.2)
	timer.Simple(animationTime, function()
		-- Validity check
		if not IsValid(ply) then return end
		if not IsValid(patient) then return end

		-- Sends the message
		Medicsystem:SendMessage(ply, {
			team.GetColor(ply:Team()),
			ply:GetCurrentCharacterFullName(),
			" heilte ",
			injury.name,
			" von ",
			Medicsystem:GetCurrentCharacterFullName(patient),
			" mittels ",
			self.Name,
			"."
		})

		-- Cures the injury
		Medicsystem:InjuryTreated(patient, hitgroup, Medicsystem:TranslateInjury(injury.name))

		-- Heal effect
		local ed = EffectData()
		ed:SetOrigin(ply:GetPos())
		ed:SetEntity(patient)
		util.Effect("rb655_force_heal", ed, true, true)

		return true
	end)
end

Treatment.CanGlobalUse = function(self, ply, patient, hitgroup)
	return false
end

Medicsystem:RegisterTreatment("veneficum", Treatment)




--addons/bkeypads/lua/bkeypads_config.lua:
bKeypads:SetConfig({ -- Don't touch this line

--################################################################################################################--
--[[##############################################################################################################--
      
      
       ██████╗ ██╗██╗     ██╗  ██╗   ██╗███████╗    ██╗  ██╗███████╗██╗   ██╗██████╗  █████╗ ██████╗ ███████╗
       ██╔══██╗██║██║     ██║  ╚██╗ ██╔╝██╔════╝    ██║ ██╔╝██╔════╝╚██╗ ██╔╝██╔══██╗██╔══██╗██╔══██╗██╔════╝
       ██████╔╝██║██║     ██║   ╚████╔╝ ███████╗    █████╔╝ █████╗   ╚████╔╝ ██████╔╝███████║██║  ██║███████╗
       ██╔══██╗██║██║     ██║    ╚██╔╝  ╚════██║    ██╔═██╗ ██╔══╝    ╚██╔╝  ██╔═══╝ ██╔══██║██║  ██║╚════██║
       ██████╔╝██║███████╗███████╗██║   ███████║    ██║  ██╗███████╗   ██║   ██║     ██║  ██║██████╔╝███████║
       ╚═════╝ ╚═╝╚══════╝╚══════╝╚═╝   ╚══════╝    ╚═╝  ╚═╝╚══════╝   ╚═╝   ╚═╝     ╚═╝  ╚═╝╚═════╝ ╚══════╝
      

    https://www.gmodstore.com/market/view/billys-keypads
    
    Thank you for purchasing my script and supporting my work :D I hope this will enrich your server.
	Make sure you've followed the installation instructions and activated your license if you haven't already.

	Using a leak? That's okay -- sometimes it's hard to justify splashing out on a new server, for example.
	But please be safe - the VAST majority of leaks contain backdoors and malicious code that can destroy
	your server and attract malicious players.

	If your server is successful, don't forget to support the creators who provided you with their hard work.

--################################################################################################################--
--################################################################################################################--

	This Lua file allows you to configure Billy's Keypads.

	PLEASE DO NOT EDIT THIS FILE IN NOTEPAD - IT'S LIKE TRYING TO DO SURGERY WITH A KITCHEN KNIFE.
	Use one of these:
	https://www.sublimetext.com/
	https://notepad-plus-plus.org/downloads/
	https://code.visualstudio.com/

	Unfortunately I cannot provide support regarding configuring the addon as I would just get flooded and wouldn't
	have time to help people with bugs or errors so please reach out to friends or the Internet if you need help.

	It follows the same syntax as actual Lua code so if you make a typo you are likely to break it. Be careful.

	Don't change anything in this file except for the settings themselves unless you know what you are doing.

	This config file uses Simplerr (the same thing DarkRP uses) to help you understand any errors.
	https://fptje.github.io/glualint-web/ can also help you debug your config file.

	Good luck, have fun :D

]]--##############################################################################################################--
--##[[                                              PERMISSIONS                                               ]]##--

-- NOTE: It is recommended that you install OpenPermissions with Billy's Keypads for advanced permissions control
-- If you have GmodAdminSuite installed then OpenPermissions should already be installed
-- Type !openpermissions in chat to open it
-- https://github.com/GmodAdminSuite/OpenPermissions

--################################################################################################################--
--##[[                                             GENERAL CONFIG                                             ]]##--

-- The maximum number of keypads a player can spawn
-- 0 = no maximum
MaxKeypads = {
	["default"] = 0,
},

-- If enabled, keypads can ONLY be placed on & linked to fading doors.
-- This will force "Auto Fading Door" for convenience.
-- Do not turn this on if you want your players to be able to link keypads to map objects! This overrides that.
-- NOTE: You can override this for usergroups/teams/jobs (e.g. donator ranks) if OpenPermissions is installed
KeypadOnlyFadingDoors = false,

-- Enable the creation of mirrored keypads?
-- Players will be able to place mirrored keypads on props that are automatically linked
-- Only one keypad will count towards their keypad limit!
KeypadMirroring = true,

-- The maximum distance players can link stuff from
-- Set to 0 for no maximum
-- NOTE: You can override this for usergroups/teams/jobs (e.g. admins) if OpenPermissions is installed
LinkingDistance = 0,

-- Set this to false to suppress the map's lighting on keypads when they're being interacted with by a player
-- May help with visibility
AlwaysEngineLighting = true,

Wiremod = {
	-- Enable Wiremod support
	-- (You can leave this enabled even without Wiremod installed)
	-- NOTE: You can control the permissions for access to Wiremod keypads (e.g. donator ranks) if OpenPermissions is installed
	Enabled = true,

	-- Enable the "Scanning" output for keypads
	-- This could theoretically be overpowered on DarkRP, leading clever players to create Wiremod keypads that open their door when the keypad
	-- is being scanned. This means they can make Keypad Crackers useless on the keypad.
	ScanningOutput = false,
},

-- Allow players to create keypads that press a key on their keyboard when access is granted or denied?
-- Billy's Keypads includes its own fading door tool which does not use a keyboard button for opening/closing the fading door.
-- This prevents fading door abuse and requires keypads to be linked to fading doors to control them. Therefore, in most cases
-- you won't need to enable this, and it's recommended you leave this off on roleplay servers.
-- More advanced users can instead use Wiremod for their creations, if it's installed (and you've enabled Wiremod keypads above)
-- NOTE: You can control the permissions for access to keyboard pressing (e.g. donator ranks) if OpenPermissions is installed
EnableKeyboardPress = false,

Notifications = {
	-- Allow players to receive "Access Granted" and "Access Denied" notifications from their keypads
	-- NOTE: You can control the permissions for receiving notifications (e.g. donator ranks) if OpenPermissions is installed
	Enable = true,

	-- Notifications by default have their own popups that show at the botttom of the screen
	-- If this doesn't fit in with the rest of your server, you can redirect notifications to chat instead
	UseChat = false,
},

--################################################################################################################--
--##[[                                                SCANNING                                                ]]##--

Scanning = {
	ScanMethods = {
		-- NOTE: You can control the permissions for access to scan methods (e.g. donator ranks) if OpenPermissions is installed

		-- Whether or not the PIN method of keypads is enabled
		EnablePIN = true,

		-- Whether or not the facial scanning method of keypads is enabled
		EnableFaceID = true,

		-- Whether or not keycards are enabled
		EnableKeycards = true,
	},

	ScanTimes = {
		-- How long should it take in seconds to scan the face of a player?
		FaceID = 4,

		-- How long should it take in seconds to scan an inserted keycard?
		Keycard = 1
	},

	-- In hammer units, what is the maximum distance a player/keycard can be scanned from?
	MaxDistance = 7000,

	-- Should the keypad abort scanning an inserted keycard if the player moves too far away?
	KeycardFailTooFarAway = true,

	AccessGranted = {
		-- The minimum amount of time in seconds a keypad can be "Access Granted" for
		-- Set to 0 for no minimum
		MinimumTime = 3,

		-- The maximum amount of time in seconds a keypad can be "Access Granted" for
		-- Set to 0 for no maxmimum
		MaximumTime = 0,

		-- Maximum number of repeats
		-- Set to 0 for no maximum
		MaximumRepeats = 10,

		-- Minimum repeat delay
		-- If set to 0 for no minimum
		MinimumRepeatDelay = 1,

		-- WARNING: If you have very high/unlimited MaximumRepeats and a low MinimumRepeatDelay, players could crash/lag the server by spamming repeats
	},

	AccessDenied = {
		-- The minimum amount of time in seconds a keypad can be "Access Denied" for
		-- Set to 0 for no minimum
		MinimumTime = 1,

		-- The maximum amount of time in seconds a keypad can be "Access Denied" for
		-- Set to 0 for no maxmimum
		MaximumTime = 0,

		-- Maximum number of repeats
		-- Set to 0 for no maximum
		MaximumRepeats = 10,

		-- Minimum repeat delay
		-- If set to 0 for no minimum
		MinimumRepeatDelay = 1,

		-- WARNING: If you have very high/unlimited MaximumRepeats and a low MinimumRepeatDelay, players could crash/lag the server by spamming repeats
	},
},

--################################################################################################################--
--##[[                                                KEYCARDS                                                ]]##--

Keycards = {
	ShowID = {
		-- Should keycard identification be enabled?
		AllowIndentification = false,

		-- The message that is displayed when a player presents their identification
		-- Available replacements:
		-- %name%      - Player's name
		-- %keycard%   - Keycard name
		-- %level%     - Keycard level
		-- %team%      - Team/job name
		-- %usergroup% - Player's usergroup
		Message = "%name% zeigt seine Keycard des Types %keycard% vor und identifiziert sich damit als Mitglied der %team%",

		-- If you are familiar with GMod's markup library's formatting, switch this option to true to enable markup tags
		-- https://wiki.facepunch.com/gmod/markup.Parse
		MessageMarkup = false,

		-- In hammer units, how far can players see keycard identification from?
		Distance = 10000,

		-- How long is the message displayed for?
		Time = 4,

		-- How long must the player wait before presenting their identification again?
		Cooldown = 2,
	},

	-- The message that is displayed when pressing E on a keycard scanner
	InsertKeycardMessage = "Please insert your keycard!",

	-- Should players spawn with a keycard?
	-- You can configure what teams spawn with keycards and the keycard level they spawn with below
	SpawnWithKeycard = false,

	-- Teams that should never spawn with a keycard
	SpawnWithoutKeycard = {
	},

	-- Can players drop the keycard they spawned with?
	-- NOTE: You can configure who can drop their keycard using OpenPermissions if installed
	CanDropSpawnedWithKeycard = true,

	-- Can players drop other keycards?
	-- Dropped keycards can be collected by players and used to access keypads
	-- NOTE: You can configure who can drop keycards using OpenPermissions if installed
	CanDropKeycard = true,

	-- Should the custom DarkRP /job be shown instead of the player's job's actual name?
	ShowCustomJobName = true,

	Levels = {
		-- You can configure keycard levels here

		-- NOTE: The order of the keycards matter!
		-- Keycards further down can access keypads which are configured to grant access to "Level X or higher" keycards
		-- Players can also have multiple keycard levels, but the one furthest down is the one VISIBLE to them and others.
		-- The "Name" field of the keycard levels does not affect this.

		{
			Name  = "Zivil",
			Color = Color(255, 255, 255),
			customCheck = function(ply)
				return false
			end,
		},

		{
			Name  = "Sicherheitslevel 1",
			Color = Color(0, 255, 0),
			customCheck = function(ply)
				return ply:HasKeycardAccess("Sicherheitslevel 1")
			end,
		},

		{
			Name  = "Sicherheitslevel 2",
			Color = Color(255, 255, 0),
			customCheck = function(ply)
				return ply:HasKeycardAccess("Sicherheitslevel 2")
			end,
		},

		{
			Name  = "Sicherheitslevel 3",
			Color = Color(255, 93, 0),
			customCheck = function(ply)
				return ply:HasKeycardAccess("Sicherheitslevel 3")
			end,
		},

		{
			Name  = "Notfallsoldaten",
			Color = Color(255, 0, 0),
			customCheck = function(ply)
				return ply:HasKeycardAccess("Notfallsoldaten") or ply:HasKeycardAccess("Basissicherheit")
			end,
		},

		{
			Name  = "Geheimdienst",
			Color = Color(0, 0, 0),
			customCheck = function(ply)
				return ply:HasKeycardAccess("Geheimdienst")
			end,
		},

		{
			Name  = "Ausbilder",
			Color = Color(19, 34, 255),
			customCheck = function(ply)
				return ply:HasKeycardAccess("Ausbilder")
			end,
		},

		{
			Name  = "Galaktischer Senat",
			Color = Color(0, 161, 255),
			customCheck = function(ply)
				return ply:HasKeycardAccess("Galaktischer Senat")
			end,
		},

		{
			Name  = "Basissicherheit",
			Color = Color(119, 69, 176),
			customCheck = function(ply)
				return ply:HasKeycardAccess("Basissicherheit")
			end,
		},

		--[[
		
		customCheck keycard level example:
		For more help, read this: https://wiki.gmodadminsuite.com/bkeypads#custom-checks TODO
		{
			Name = "Level 5",
			Color = Color(0, 0, 0),
			customCheck = function(ply)
				-- You can use a customCheck function here to use custom Lua code to determine a keycard's level
				-- For example, your custom SCP gamemode has its own keycard level system, and exposes a PLAYER:GetKeycardLevel() function
				-- In this example, you can use the following code to link this system to Billy's keycards:
				return ply:GetKeycardLevel() == 5
			end,
		}

		--]]
	},

	KeycardImage = {
		-- Keycards display various information on their world models, one of which being a small image that you can configure here

		-- Possible choices:

		-- avatar  : Displays the player's profile picture, if this cannot be displayed, Backup will be used instead
		-- keycard : Displays a keycard icon
		-- scp     : Displays the SCP Foundation logo
		-- <url>   : Displays a .png image downloaded from the given URL
		-- <path>  : Displays a texture in the client's game files (you may have to configure a way for clients to download this texture)

		-- Recommended size for images: 256x256

		Image = "keycard",
		Backup = "keycard",

		-- The color shown beneath the keycard image
		BackgroundColor = Color(0, 0, 0, 255)
	}
},

--################################################################################################################--
--##[[                                               APPEARANCE                                               ]]##--

Appearance = {
	ScreenColors = {
		-- What color should be displayed on keypads whilst scanning?
		Scanning = Color(32, 32, 32),

		-- What color should be displayed on keypads when access is granted?
		Granted = Color(80, 255, 80),

		-- What color should be displayed on keypads when access is denied?
		Denied = Color(255, 60, 60),

		-- What color should be displayed when a keypad is hacked or broken?
		Hacked = Color(150, 0, 0),
	},

	LEDColors = {
		-- What color should be displayed on the status LED whilst scanning?
		Scanning = Color(255, 175, 0),

		-- What color should be displayed on the status LED when access is granted?
		Granted = Color(0, 255, 0),

		-- What color should be displayed on the status LED when access is denied?
		Denied = Color(255, 0, 0),

		-- What color should be displayed on the status LED when a keypad is hacked or broken?
		Hacked = Color(255, 0, 0),
	},

	CustomImages = {
		-- Should custom images be enabled?
		-- This allows players to add custom images to their keypads, such as a logo.
		-- NOTE: You can control the permissions for the usage of custom images (e.g. donator ranks) if OpenPermissions is installed
		Enable = true,

		-- Domains that can be used as custom image URLs for keypads
		-- It is very important that you only use trusted websites & domains here because the images are downloaded clientside which exposes your players' IP addresses to possible malicious actors.
		-- So, do not add random, untrusted domains here. If a player asks to add a domain here, they are probably up to no good. Imgur should be good enough.
		URLWhitelist = {
			"i.imgur.com",
		},
	}
},

--################################################################################################################--
--##[[                                           PAYMENTS & ECONOMY                                           ]]##--

Payments = {
	-- Allow players to charge others for using their keypad?
	-- NOTE: You can control the permissions for access to this (e.g. donator ranks) if OpenPermissions is installed
	Enable = false,

	-- Should players be asked to confirm whether they want to make the payment or not?
	Prompt = true,

	-- Minimum amount of money players can charge (this cannot be below 1)
	MinimumPayment = 1,

	-- Maximum amount of money players can charge
	-- Set to 0 for no maximum
	MaximumPayment = 0,

	Economy = {
		-- If DarkRP isn't running, turn this on to use the below custom Lua functions instead of DarkRP functions for checking money, taking payments, etc.
		CustomEconomy = false,

		-- return true if the player can afford $"amount"
		canAfford = function(ply, amount)
			return ply:GetMoney() >= amount
		end,

		-- Note; "amount" may be negative (for TAKING money) or positive (for ADDING money)
		addMoney = function(ply, amount)
			ply:SetMoney(ply:GetMoney() + amount)
		end,

		-- Return a correctly formatted currency string
		-- e.g. 1000.5 -> $1,000.50
		formatMoney = function(amount)
			-- Separate 1000s into 1,000s
			local left, num, right = string.match(amount, "^([^%d]*%d)(%d*)(.-)$")
			local formatted = left .. (num:reverse():gsub("(%d%d%d)", "%1,"):reverse()) .. right

			-- Right-pad a 0 to single-digit cents/pennies
			formatted = (formatted:gsub("%.(%d)$", ".%10"))

			return "$" .. formatted
		end,
	},
},

--################################################################################################################--
--##[[                                               MAP LINKING                                              ]]##--

MapLinking = {
	-- Should map linking to doors be enabled?
	Doors = true,

	-- Should map linking to buttons be enabled?
	Buttons = true,
},

--################################################################################################################--
--##[[                                               ACCESS LOGS                                              ]]##--

AccessLogs = {
	-- TIP: Need a new job for your roleplay server? Maybe make a detective job which spawns with the bkeypads_access_logs weapon ;)

	-- Do police need a warrant to view the access logs of a keypad?
	PoliceNeedWarrant = true,

	-- Can the access log checker weapon be dropped?
	-- NOTE: In DarkRP, this is also controlled by GM.Config.dropspawnedweapons
	CanDrop = true,
},

--################################################################################################################--
--##[[                                               FADING DOORS                                             ]]##--

FadingDoors = {
	-- Allow players to create fading doors which open/close using buttons on the keyboard?
	-- Enabling this means your server is vulnerable to fading door abuse
	EnableKeyboardPress = false,

	-- Allow players to create reversed fading doors?
	-- (Fading doors that are open by default and close when activated)
	Reversible = false,

	-- The maximum number of fading doors a player can spawn
	-- 0 = no maximum
	Maximum = {
		["default"] = 0,
	},

	-- Prevent fading doors from closing on players and making them stuck?
	-- Players will be automatically pushed out of fading doors they're stuck in
	-- THIS ISN'T 100% ACCURATE! (Source Engine is kind of shit at this)
	KeepOpen = true,
	-- Increase this number if you have a laggy server :D (Fading doors will be less responsive when stuck checking)
	TickIntervalMul = 16,

	-- DarkRP:
	-- Whether to allow fading doors to be lockpicked or not
	-- (If they can't be lockpicked, players must keypad crack the corresponding keypad instead)
	Lockpick = false,

	-- The materials that players are allowed to use for their fading doors
	Materials = {
		"Models/effects/vol_light001",

		-- Active Forcefields
		--"sprites/heatwave",
		--"models/shadertest/shader3",
		--"models/shadertest/shader4",
		--"Models/effects/comball_sphere",
		--"Models/effects/comball_tape",
		--"Models/effects/splodearc_sheet",
		--"models/props_combine/stasisshield_sheet",
		--"models/props_combine/portalball001_sheet",
		--"models/props_combine/com_shield001a",
		--"models/props_c17/frostedglass_01a",
		--"models/props_lab/Tank_Glass001",
		--"models/props_combine/tprings_globe",

		-- Completely Useless
		--"models/wireframe",
		--"debug/env_cubemap_model",
		--"models/shadertest/shader5",
		--"models/shiny",
		--"models/debug/debugwhite",
		--"models/rendertarget",
		--"models/screenspace",
		--"brick/brick_model",
		--"models/props_pipes/GutterMetal01a",
		--"models/props_pipes/Pipesystem01a_skin3",
		--"models/props_wasteland/wood_fence01a",
		--"models/props_foliage/tree_deciduous_01a_trunk",
		--"models/props_c17/FurnitureFabric003a",
		--"models/props_c17/FurnitureMetal001a",
		--"models/props_c17/paper01",
		--"models/flesh",
	},

	-- Whether fading door sounds are enabled or not
	-- NOTE: You can control the permissions for access to fading door sounds (e.g. donator ranks) if OpenPermissions is installed
	EnableSounds = false,

	-- The sounds that players are allowed to use for the opening/closing sound of a fading door
	Sounds = {
		"doors/doorstop1.wav",
		"npc/turret_floor/retract.wav",
		"npc/roller/mine/combine_mine_deactivate1.wav",
		"npc/roller/mine/combine_mine_deploy1.wav",
		"npc/roller/mine/rmine_taunt1.wav",
		"npc/scanner/scanner_nearmiss2.wav",
		"npc/scanner/scanner_siren1.wav",
		"npc/barnacle/barnacle_gulp1.wav",
		"npc/barnacle/barnacle_gulp2.wav",
		"npc/combine_gunship/attack_start2.wav",
		"npc/combine_gunship/attack_stop2.wav",
		"npc/dog/dog_pneumatic1.wav",
		"npc/dog/dog_pneumatic2.wav",
	},

	-- The sounds that players are allowed to use for the active sound of a fading door
	-- These sounds must be looping sounds
	LoopSounds = {
		"ambient/machines/machine6.wav",
		"ambient/energy/force_field_loop1.wav",
		"physics/metal/canister_scrape_smooth_loop1.wav",
		"ambient/levels/citadel/citadel_drone_loop5.wav",
		"ambient/levels/citadel/citadel_drone_loop6.wav",
		"ambient/atmosphere/city_rumble_loop1.wav",
		"ambient/machines/city_ventpump_loop1.wav",
		"ambient/machines/combine_shield_loop3.wav",
		"npc/manhack/mh_engine_loop1.wav",
		"npc/manhack/mh_engine_loop2.wav",
	}
},

Persistence = {
	-- Whether persistent keypads should be saved on server shutdown
	-- If this is off, then any changes you make to permanent keypads will need to be saved using the profile switcher in the persistence tool's spawn menu section
	SaveOnShutDown = false,
},

KeypadDestruction = {
	-- Enable keypad damage (players can shoot to destroy & disable keypads)
	-- Admins will still be able to spawn destructible keypads if they explicitly choose to.
	-- NOTE: You can control the permissions for this if OpenPermissions is installed
	Enable = false,

	-- How much health should a keypad spawn with?
	KeypadHealth = 200,

	-- What is the maximum shield charge a keypad can hold as a percentage of its maximum health?
	-- 0 = Unlimited
	-- 100% = 1
	-- 200% = 2
	-- 300% = 3
	-- ...
	MaxShield = 1,

	-- In seconds, how often should a keypad regenerate health?
	-- 0 to disable
	KeypadRegenRate = 0.5,

	-- How much health should a keypad regenerate as a percentage of its maximum health?
	-- 0 to disable
	-- NOTE: The actual amount will be rounded up to get rid of any decimals
	-- Example:
	-- Maximum health = 200
	-- Health regeneration pct = 0.01 = 1%
	-- Health regeneration amount = 200 * 1% = 2
	-- Health regeneration rate = 0.5 seconds
	-- Time to fully regenerate = 200 / (200 * 1%) / 0.5 = 200 seconds
	KeypadRegenAmount = 0.01,

	-- How much should a battery charge a keypad's health as a percentage of its maximum health?
	-- 100% = 1
	-- 75% = 0.75
	-- 50% = 0.5
	-- 25% = 0.25
	-- ...
	BatteryCharge = 0.25,

	-- How much should a shield battery charge a keypad's shield as a percentage of its maximum health?
	ShieldBatteryCharge = 0.25,

	-- DarkRP F4 menu items
	DarkRP = {
		-- https://darkrp.miraheze.org/wiki/DarkRP:CustomEntityFields

		Battery = {
			Disabled = true,
			Name = "Keypad Battery",

			price = 500,
			max = 0,
			cmd = "buykeypadbattery",
			category = "Other",
			--allowed = { TEAM_MECHANIC },
			--customCheck = function(ply) return ply:GetUserGroup() == "donator" end,
		},

		ShieldBattery = {
			Disabled = true,
			Name = "Keypad Shield Battery",

			price = 1000,
			max = 0,
			cmd = "buykeypadshield",
			category = "Other",
			--allowed = { TEAM_MECHANIC },
			--customCheck = function(ply) return ply:GetUserGroup() == "donator" end,
		}
	},
},

-- Should experimental ENTITY:GetClass() override be enabled?
-- This will make sure that all keypad crackers work with Billy's Keypads
-- This is very experimental and could cause problems
ExperimentalKeypadCompatibility = true,

-- Congratulations, you've reached the end of the config!














--################################################################################################################--
--################################################################################################################--
}) -- Don't touch this line